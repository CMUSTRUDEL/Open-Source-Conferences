Title: Nir Arad - Controlling apples with snakes: Automating mobile apps with Appium - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Nir Arad

Testing mobile applications is hard. Testing manually is nearly impossible.
Thatâ€™s where automated testing shines. Just sit back and watch the machine go!
Python is a very powerful language for writing automated tests, but since Python is not installed on mobile platforms, we need to find a way to remotely control and monitor the device.
But how do we automate a device remotely? The answer is Appium.

In this talk I will go over the process of deploying and testing iOS (or Android) applications, and how to work with Appium to easily generate Python 3 code for testing your application.

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:00,000 --> 00:00:06,150
how are you doing everyone thank you for

00:00:04,470 --> 00:00:09,450
joining us today

00:00:06,150 --> 00:00:11,940
near arrive from waves radio is going to

00:00:09,450 --> 00:00:13,380
talk to us about controlling output with

00:00:11,940 --> 00:00:25,019
snakes

00:00:13,380 --> 00:00:27,060
take it away Anya thank you very much

00:00:25,019 --> 00:00:28,500
I'm very excited to be here it's my

00:00:27,060 --> 00:00:34,500
first bike on Talk

00:00:28,500 --> 00:00:35,460
I decided to keep it simple and not do

00:00:34,500 --> 00:00:37,680
fancy stuff

00:00:35,460 --> 00:00:41,870
Who am I kidding I brought an iPad for a

00:00:37,680 --> 00:00:46,110
live demo today I'm gonna talk about

00:00:41,870 --> 00:00:52,620
appium and how you can control your iOS

00:00:46,110 --> 00:00:55,710
or mobile applications using Python so I

00:00:52,620 --> 00:00:59,789
want you all to put yourself in the

00:00:55,710 --> 00:01:02,579
shoes of a QA manual tester your job is

00:00:59,789 --> 00:01:06,060
to run regression tests on all the

00:01:02,579 --> 00:01:09,060
company's products tests are tedious and

00:01:06,060 --> 00:01:12,810
repeat themselves and you probably ask

00:01:09,060 --> 00:01:16,979
yourself why am i doing this job why am

00:01:12,810 --> 00:01:20,880
i doing a machines job well this is

00:01:16,979 --> 00:01:24,390
pretty much the exact question I've been

00:01:20,880 --> 00:01:29,070
asking myself basically it's my story I

00:01:24,390 --> 00:01:31,350
started these sound engineering and I

00:01:29,070 --> 00:01:36,150
started working 10 years ago at waves

00:01:31,350 --> 00:01:42,659
audio it's an audio software company for

00:01:36,150 --> 00:01:44,520
the Pro and consumer market and we're

00:01:42,659 --> 00:01:49,439
gonna go over some of their products

00:01:44,520 --> 00:01:53,460
later I've been doing 5 years of manual

00:01:49,439 --> 00:01:56,130
testing and I got tired from that I

00:01:53,460 --> 00:01:58,799
wanted to do some more interesting stuff

00:01:56,130 --> 00:02:03,030
and I said ok why not automate the

00:01:58,799 --> 00:02:06,680
boring and tedious work so for the past

00:02:03,030 --> 00:02:09,780
five years I've been working with Python

00:02:06,680 --> 00:02:12,150
automating stuff automating tests and

00:02:09,780 --> 00:02:14,030
running tests for desktop applications

00:02:12,150 --> 00:02:16,920
and mobile applications

00:02:14,030 --> 00:02:19,709
so what our audio plugins basically

00:02:16,920 --> 00:02:22,430
there are set of tools to help sound

00:02:19,709 --> 00:02:26,069
engineers music producers and musicians

00:02:22,430 --> 00:02:32,159
create better mixes for their songs and

00:02:26,069 --> 00:02:34,560
records and even live performances there

00:02:32,159 --> 00:02:37,819
are many tools such as equalizers

00:02:34,560 --> 00:02:42,750
compressors reverbs here you see

00:02:37,819 --> 00:02:46,829
modeling of a tape machine used in Abbey

00:02:42,750 --> 00:02:55,349
Road Studios there's also great stuff

00:02:46,829 --> 00:02:57,599
like guitar amps and well you probably

00:02:55,349 --> 00:03:00,629
know this one if you don't know this

00:02:57,599 --> 00:03:02,370
song the audio plugin is pretty much

00:03:00,629 --> 00:03:06,599
revolutionized and changed the way we

00:03:02,370 --> 00:03:10,260
make music forever this is a plugin

00:03:06,599 --> 00:03:15,420
called wave tune and basically what it

00:03:10,260 --> 00:03:19,829
does it fixes the tune of a singer in

00:03:15,420 --> 00:03:22,199
life so back to our talk why do we use

00:03:19,829 --> 00:03:25,260
automated testing well waves audio

00:03:22,199 --> 00:03:27,919
specifically has more than 200 products

00:03:25,260 --> 00:03:30,599
and we have to test them every day and

00:03:27,919 --> 00:03:33,480
we're even using continuous integration

00:03:30,599 --> 00:03:37,199
and continuous build so we have to test

00:03:33,480 --> 00:03:40,530
them pretty much every hour it's not

00:03:37,199 --> 00:03:43,859
possible for human to do that and we

00:03:40,530 --> 00:03:47,579
prefer to leave the humans at the QA to

00:03:43,859 --> 00:03:50,819
more intelligent testing things are more

00:03:47,579 --> 00:03:55,680
dynamic and require them to adapt and to

00:03:50,819 --> 00:03:58,019
really think about that so automated

00:03:55,680 --> 00:04:01,229
testing is boring and it should be done

00:03:58,019 --> 00:04:04,799
by machines the benefits of automated

00:04:01,229 --> 00:04:09,680
testing well first it saves you time it

00:04:04,799 --> 00:04:12,690
runs 24/7 and you get immediate results

00:04:09,680 --> 00:04:18,389
they run much faster than humans tests

00:04:12,690 --> 00:04:21,229
like benchmark testing or stress testing

00:04:18,389 --> 00:04:24,330
are not possible to be done by humans

00:04:21,229 --> 00:04:25,520
try measuring the CPU 30 times per

00:04:24,330 --> 00:04:27,970
second

00:04:25,520 --> 00:04:30,710
you're gonna need a tool to do that

00:04:27,970 --> 00:04:34,880
they're more accurate they always run

00:04:30,710 --> 00:04:38,030
the same pretty much there's no human

00:04:34,880 --> 00:04:40,370
error they're reusable we can use

00:04:38,030 --> 00:04:42,849
actually write functions that are

00:04:40,370 --> 00:04:45,289
reusable from one test to another and

00:04:42,849 --> 00:04:48,440
most of all they can increase our

00:04:45,289 --> 00:04:54,889
coverage for better and faster releases

00:04:48,440 --> 00:04:57,770
we can catch bug bugs earlier so waves

00:04:54,889 --> 00:05:00,949
audio has been making applications for

00:04:57,770 --> 00:05:05,060
the desktop platforms Windows and Mac

00:05:00,949 --> 00:05:09,259
and some on Linux for years now and in

00:05:05,060 --> 00:05:14,150
the past year we I was addressed with a

00:05:09,259 --> 00:05:16,669
challenge wave started producing audio

00:05:14,150 --> 00:05:20,440
plug-ins for the iPad for the iOS

00:05:16,669 --> 00:05:23,000
platform and I was given a task to

00:05:20,440 --> 00:05:26,630
basically transfer our facilities our

00:05:23,000 --> 00:05:30,889
testing facilities from the desktop to

00:05:26,630 --> 00:05:34,419
the iOS and I have to address another

00:05:30,889 --> 00:05:38,180
issue that waves is not an app developer

00:05:34,419 --> 00:05:41,000
we don't actually have an app we are

00:05:38,180 --> 00:05:43,400
called a third-party plugin developer

00:05:41,000 --> 00:05:46,400
that means that our products are

00:05:43,400 --> 00:05:49,699
basically an in-app purchase so in order

00:05:46,400 --> 00:05:54,710
to test it we don't even have an app

00:05:49,699 --> 00:05:57,380
where tested on foreign apps or what we

00:05:54,710 --> 00:06:01,810
did is we created a testing app

00:05:57,380 --> 00:06:05,210
ourselves this is a basic app that can

00:06:01,810 --> 00:06:07,610
basically has a select plug-in which is

00:06:05,210 --> 00:06:10,310
gonna open a menu so you can select your

00:06:07,610 --> 00:06:14,449
plug-in it has a select song and play

00:06:10,310 --> 00:06:18,650
I'm gonna show it to you later so our

00:06:14,449 --> 00:06:22,219
journey begins first we came to test

00:06:18,650 --> 00:06:24,979
flight it's the main testing framework

00:06:22,219 --> 00:06:27,409
by Apple you can use it to create

00:06:24,979 --> 00:06:29,870
distinct IDs for a nap

00:06:27,409 --> 00:06:32,030
get your certificates and basically it's

00:06:29,870 --> 00:06:35,089
your one way gate to the App Store you

00:06:32,030 --> 00:06:39,320
have to get your app approved before you

00:06:35,089 --> 00:06:41,930
launch it on the App Store you can also

00:06:39,320 --> 00:06:47,390
use it for internal testing or external

00:06:41,930 --> 00:06:50,870
beta tests best beta testing but Iran

00:06:47,390 --> 00:06:53,770
only supports real devices and it

00:06:50,870 --> 00:06:56,360
doesn't support Python automated testing

00:06:53,770 --> 00:06:58,730
does exist but you have to know

00:06:56,360 --> 00:07:03,530
objective-c and it's really really hard

00:06:58,730 --> 00:07:09,410
so our tests pretty much failed or

00:07:03,530 --> 00:07:12,020
crashed and then we came to appium it's

00:07:09,410 --> 00:07:15,530
an open source project for automated

00:07:12,020 --> 00:07:18,770
testing it supports native web or hybrid

00:07:15,530 --> 00:07:24,170
applications native being an application

00:07:18,770 --> 00:07:28,250
that is built specifically for the the

00:07:24,170 --> 00:07:30,560
mobile platform and it's running on a

00:07:28,250 --> 00:07:32,960
native environment web applications are

00:07:30,560 --> 00:07:35,630
basically apps running inside of a

00:07:32,960 --> 00:07:39,710
browser and hybrid applications are

00:07:35,630 --> 00:07:44,200
native application frames that has a web

00:07:39,710 --> 00:07:48,910
application inside of it think of maybe

00:07:44,200 --> 00:07:52,640
Facebook app has a lot of hybrid

00:07:48,910 --> 00:07:56,990
applications inside of it it's open

00:07:52,640 --> 00:08:01,450
source and ready to use appium is

00:07:56,990 --> 00:08:05,000
produced by sauce labs which also has

00:08:01,450 --> 00:08:08,450
numerous other products in the field of

00:08:05,000 --> 00:08:11,810
automatic testing so how does happen

00:08:08,450 --> 00:08:15,080
work basically it's a node.js server

00:08:11,810 --> 00:08:21,770
running on the test machine which is our

00:08:15,080 --> 00:08:25,400
Mac for example and it's an HTTP it's an

00:08:21,770 --> 00:08:29,480
HTTP server and you can communicate with

00:08:25,400 --> 00:08:32,990
your from your tests to the to the

00:08:29,480 --> 00:08:37,880
server using an JSON protocol from there

00:08:32,990 --> 00:08:41,510
commands are sent to the device using

00:08:37,880 --> 00:08:45,410
some something called the webdriver aka

00:08:41,510 --> 00:08:49,430
the selenium webdriver so the webdriver

00:08:45,410 --> 00:08:51,950
sits as an app inside the device and it

00:08:49,430 --> 00:08:53,740
communicates back to the server and what

00:08:51,950 --> 00:08:58,450
it does

00:08:53,740 --> 00:09:01,089
translates the commands from what the

00:08:58,450 --> 00:09:06,399
user wrote in Python to the native

00:09:01,089 --> 00:09:10,750
environment framework and this happens

00:09:06,399 --> 00:09:15,910
back-and-forth epping uses a layer

00:09:10,750 --> 00:09:18,550
called instruments app inside the the

00:09:15,910 --> 00:09:22,269
iOS mobile platform on Android they have

00:09:18,550 --> 00:09:27,550
a different they have a different way to

00:09:22,269 --> 00:09:31,269
do that and basically it utilizes the

00:09:27,550 --> 00:09:35,470
libraries of the native device in order

00:09:31,269 --> 00:09:39,459
to control and automate the the device

00:09:35,470 --> 00:09:42,339
itself so we have two options when

00:09:39,459 --> 00:09:45,820
automating devices with appium we can

00:09:42,339 --> 00:09:48,430
use a real device like this one it's

00:09:45,820 --> 00:09:50,680
much more stable you get a real device

00:09:48,430 --> 00:09:55,089
performance basically your app is going

00:09:50,680 --> 00:09:57,579
to act the exact same way it did because

00:09:55,089 --> 00:10:02,290
it's a real device it's going to act the

00:09:57,579 --> 00:10:05,320
same as it will with the user however

00:10:02,290 --> 00:10:08,380
it's much more expensive he actually

00:10:05,320 --> 00:10:11,500
have to buy an iPad it's got a slower

00:10:08,380 --> 00:10:14,850
response time the app has to be copied

00:10:11,500 --> 00:10:17,829
from the machine into the device and

00:10:14,850 --> 00:10:21,699
every command has to be sent back and

00:10:17,829 --> 00:10:25,329
forth that can take time and it needs to

00:10:21,699 --> 00:10:28,329
be updated it can break and that's

00:10:25,329 --> 00:10:32,829
pretty much the disadvantages the

00:10:28,329 --> 00:10:36,190
emulated device is a virtual device

00:10:32,829 --> 00:10:39,209
sitting inside the testing machine it's

00:10:36,190 --> 00:10:42,610
much faster there's no data transfer

00:10:39,209 --> 00:10:45,060
easier to maintain it's free and on

00:10:42,610 --> 00:10:51,430
Android you can run it concurrently

00:10:45,060 --> 00:10:53,740
however H it's much less stable it tend

00:10:51,430 --> 00:10:55,810
to crash from time to time and basically

00:10:53,740 --> 00:10:58,839
it's not the real thing you're not

00:10:55,810 --> 00:11:01,589
getting the real performance for better

00:10:58,839 --> 00:11:01,589
or for worse

00:11:01,840 --> 00:11:08,340
for that reason and many others we chose

00:11:05,200 --> 00:11:14,140
to use a real device to do our tests

00:11:08,340 --> 00:11:16,930
basically it's much more stable so in

00:11:14,140 --> 00:11:20,190
order to connect from appium to the

00:11:16,930 --> 00:11:22,540
device we need to create a session

00:11:20,190 --> 00:11:25,810
session on defined by desired

00:11:22,540 --> 00:11:28,779
capabilities and basically it's our

00:11:25,810 --> 00:11:30,940
connection to appium these are

00:11:28,779 --> 00:11:34,150
capabilities are a set of keys and

00:11:30,940 --> 00:11:37,360
values that tell appium what kind of

00:11:34,150 --> 00:11:40,270
automation session is required you can

00:11:37,360 --> 00:11:43,470
set up things like language locale new

00:11:40,270 --> 00:11:47,860
command timeout and even browser name

00:11:43,470 --> 00:11:49,600
for this demonstration I've said our

00:11:47,860 --> 00:11:53,710
orientation to landscape

00:11:49,600 --> 00:11:55,779
I gave app him the path to our app so it

00:11:53,710 --> 00:11:58,420
will know how to where to get it from

00:11:55,779 --> 00:12:01,870
and how to copy it to the device and of

00:11:58,420 --> 00:12:06,730
course we're using iOS version 11 and I

00:12:01,870 --> 00:12:09,190
also gave the appium our UDID which the

00:12:06,730 --> 00:12:13,750
device unique ID so we'll know to which

00:12:09,190 --> 00:12:15,850
device to connect to so doing that in

00:12:13,750 --> 00:12:18,400
Python it's pretty simple you

00:12:15,850 --> 00:12:19,900
instantiate a dictionary you filled up

00:12:18,400 --> 00:12:24,460
with all the information that you want

00:12:19,900 --> 00:12:27,220
and all you have to do is instantiate in

00:12:24,460 --> 00:12:30,810
one line of code you have to instantiate

00:12:27,220 --> 00:12:33,460
your driver once you do that

00:12:30,810 --> 00:12:37,270
automatically appium is going to copy

00:12:33,460 --> 00:12:40,720
your app from the machine onto the

00:12:37,270 --> 00:12:46,360
device and launch the launch the app

00:12:40,720 --> 00:12:50,280
itself so now we're we have a connection

00:12:46,360 --> 00:12:55,480
ready we're ready to start our test and

00:12:50,280 --> 00:12:59,350
we do that by using GUI elements because

00:12:55,480 --> 00:13:05,220
webdriver uses basically its selenium so

00:12:59,350 --> 00:13:09,850
you have the same say the same language

00:13:05,220 --> 00:13:14,100
as any other test that you wrote for web

00:13:09,850 --> 00:13:15,760
applications so we have a few strategies

00:13:14,100 --> 00:13:18,400
we can locate

00:13:15,760 --> 00:13:22,450
eight elements by class name like

00:13:18,400 --> 00:13:25,180
buttons dialogue sliders etc we can use

00:13:22,450 --> 00:13:30,700
the accessibility ID which is a unique

00:13:25,180 --> 00:13:33,700
ID for each control and in the GUI how

00:13:30,700 --> 00:13:39,970
we can use locators such as name or

00:13:33,700 --> 00:13:42,550
XPath which are slower and are not

00:13:39,970 --> 00:13:48,210
really recommended unless you don't

00:13:42,550 --> 00:13:52,480
really know what to look for in order to

00:13:48,210 --> 00:13:55,980
fetch the accessibility IDs of each of

00:13:52,480 --> 00:13:59,530
the controls you can use IBM desktop

00:13:55,980 --> 00:14:03,160
it's a desktop application that you can

00:13:59,530 --> 00:14:06,070
connect to your device and basically see

00:14:03,160 --> 00:14:10,780
the tree of all the controls and

00:14:06,070 --> 00:14:13,360
elements in the GUI so our test is

00:14:10,780 --> 00:14:16,620
simple we want to press the select

00:14:13,360 --> 00:14:19,300
plug-in button that's gonna open a menu

00:14:16,620 --> 00:14:21,340
like you saw before and we want to

00:14:19,300 --> 00:14:25,570
iterate through each and every one of

00:14:21,340 --> 00:14:28,120
the plugins and what we want to do with

00:14:25,570 --> 00:14:30,460
each of the plugins is basically run an

00:14:28,120 --> 00:14:34,390
image comparison test take a screenshot

00:14:30,460 --> 00:14:37,240
copy it back here on Mac and see if the

00:14:34,390 --> 00:14:40,840
image match against a reference build

00:14:37,240 --> 00:14:44,830
which is basically a bill that is used

00:14:40,840 --> 00:14:47,500
by our users now take a look at the two

00:14:44,830 --> 00:14:50,680
images the top one is the reference and

00:14:47,500 --> 00:14:54,400
the bottom is the new and raise your

00:14:50,680 --> 00:15:00,340
hand if you can see one difference

00:14:54,400 --> 00:15:03,120
between them okay good now keep your

00:15:00,340 --> 00:15:06,120
hands up if you can see more than two

00:15:03,120 --> 00:15:06,120
differences

00:15:08,560 --> 00:15:18,400
this can be pretty hard good

00:15:14,770 --> 00:15:21,130
so humans are not really built to do

00:15:18,400 --> 00:15:24,400
some very accurate test and accuracy

00:15:21,130 --> 00:15:26,920
counts because I can tell you that in

00:15:24,400 --> 00:15:31,000
one of the changes we have a change

00:15:26,920 --> 00:15:33,010
that's only one pixel large and what

00:15:31,000 --> 00:15:36,010
you're seeing here is what the test

00:15:33,010 --> 00:15:39,130
created on the top image you see a dip

00:15:36,010 --> 00:15:43,000
in basically we took a black photo and

00:15:39,130 --> 00:15:44,680
we colored the images in green green

00:15:43,000 --> 00:15:47,800
pixels for every pixel that it's

00:15:44,680 --> 00:15:51,880
different from the original one and on

00:15:47,800 --> 00:15:54,460
the bottom photo what you see is

00:15:51,880 --> 00:15:56,800
basically the original image but with

00:15:54,460 --> 00:15:59,920
inverted pixels every pixel that's

00:15:56,800 --> 00:16:04,690
different from the original reference we

00:15:59,920 --> 00:16:06,089
basically color the inverted color so

00:16:04,690 --> 00:16:10,810
that's the answer

00:16:06,089 --> 00:16:14,400
sure you got it right and we're gonna

00:16:10,810 --> 00:16:17,380
move on this is our test code for

00:16:14,400 --> 00:16:20,740
running the test basically once we've

00:16:17,380 --> 00:16:23,830
instantiated the driver we need to find

00:16:20,740 --> 00:16:26,470
the Select plug-in button which is on

00:16:23,830 --> 00:16:29,470
top we use it by the accessibility ID

00:16:26,470 --> 00:16:32,440
that we fetched earlier and then we

00:16:29,470 --> 00:16:34,450
click on the menu next we want to

00:16:32,440 --> 00:16:37,000
iterate through the menu and find out

00:16:34,450 --> 00:16:40,600
every plug in every plugin button that's

00:16:37,000 --> 00:16:43,930
listed there so we can click on them we

00:16:40,600 --> 00:16:46,930
use XPath for that reason and once we

00:16:43,930 --> 00:16:48,820
iterate through every plug-in we can

00:16:46,930 --> 00:16:51,280
take a screenshot it's going to copy it

00:16:48,820 --> 00:16:55,480
to our Mac and then we can compare the

00:16:51,280 --> 00:16:59,550
images now the comparison function it's

00:16:55,480 --> 00:17:04,150
pretty straightforward and not very

00:16:59,550 --> 00:17:07,449
fancy or sexy basically what it does it

00:17:04,150 --> 00:17:12,220
opens the two images as a bitmap pixel

00:17:07,449 --> 00:17:14,949
matrix with each pixel represented by an

00:17:12,220 --> 00:17:17,110
RGB topple basically it's a number

00:17:14,949 --> 00:17:22,179
between 0 and 255

00:17:17,110 --> 00:17:22,750
they represent color for RG and B and we

00:17:22,179 --> 00:17:25,900
iterate

00:17:22,750 --> 00:17:29,200
every row and every column in the photo

00:17:25,900 --> 00:17:32,350
and we check if the color of the pixel

00:17:29,200 --> 00:17:35,470
is the same based on our reference if

00:17:32,350 --> 00:17:38,530
it's not then we take the black image

00:17:35,470 --> 00:17:43,420
and we paint a green pixel we take the

00:17:38,530 --> 00:17:48,160
original photo and we basically paint an

00:17:43,420 --> 00:17:51,460
inverted color on that location so you

00:17:48,160 --> 00:17:54,970
can see the test results for our little

00:17:51,460 --> 00:17:59,740
tests just over nine thousand pixels are

00:17:54,970 --> 00:18:03,780
different between these images now don't

00:17:59,740 --> 00:18:06,640
take my word for it I'm gonna show you

00:18:03,780 --> 00:18:09,130
this is by the way Dimitri he's a demo

00:18:06,640 --> 00:18:12,820
God for every demo he requires a

00:18:09,130 --> 00:18:17,200
sacrifice so I hope my sacrifice was

00:18:12,820 --> 00:18:19,870
good enough to run our test well now

00:18:17,200 --> 00:18:24,210
what you see here apart from the screen

00:18:19,870 --> 00:18:24,210
oh sorry

00:18:25,560 --> 00:18:33,940
close that okay on top you see the

00:18:31,090 --> 00:18:37,090
latest invention by Apple it's called

00:18:33,940 --> 00:18:39,610
quick time it's gonna represent this

00:18:37,090 --> 00:18:42,370
iPad here this is actual video this is

00:18:39,610 --> 00:18:44,260
not animation or anything and here we

00:18:42,370 --> 00:18:47,280
have our script and pycharm I'm just

00:18:44,260 --> 00:18:47,280
going to raise it up a little

00:18:55,210 --> 00:19:02,270
so we can start our script what it does

00:18:58,220 --> 00:19:03,860
it launches the appium server oh yes

00:19:02,270 --> 00:19:06,500
lunch is the appium server as a

00:19:03,860 --> 00:19:12,950
subprocess and once it does it's gonna

00:19:06,500 --> 00:19:18,050
copy the app from the Mac onto the

00:19:12,950 --> 00:19:20,960
device and once it's done it's gonna

00:19:18,050 --> 00:19:23,270
iterate through every plugin so it

00:19:20,960 --> 00:19:27,650
opened the first plugin and then it's

00:19:23,270 --> 00:19:34,760
gonna open the next one okay got the

00:19:27,650 --> 00:19:39,040
menu okay good so I didn't actually do

00:19:34,760 --> 00:19:39,040
anything or touch the iPad

00:19:44,240 --> 00:19:51,680
all right let's do some more exciting

00:19:49,440 --> 00:19:51,680
stuff

00:19:52,010 --> 00:19:56,010
well test screens behave very

00:19:54,660 --> 00:19:59,490
differently than a mouse

00:19:56,010 --> 00:20:04,130
they have gestures you can swipe you can

00:19:59,490 --> 00:20:08,220
tap you can large and do a lot of stuff

00:20:04,130 --> 00:20:11,850
in order to automate this appium gives

00:20:08,220 --> 00:20:14,990
us touch action object basically it

00:20:11,850 --> 00:20:20,240
contains a chain of events that

00:20:14,990 --> 00:20:22,820
simulates action as user on screen so

00:20:20,240 --> 00:20:25,470
what you see here is a touch action

00:20:22,820 --> 00:20:27,930
where you press on an element and then

00:20:25,470 --> 00:20:31,200
move it and then release you can also do

00:20:27,930 --> 00:20:33,390
positional based actions and appium

00:20:31,200 --> 00:20:38,780
gives you all these actions such as

00:20:33,390 --> 00:20:46,850
press release you can move tap or wait

00:20:38,780 --> 00:20:51,750
in order to do more elaborate gestures

00:20:46,850 --> 00:20:53,540
appium uses the multi-touch object which

00:20:51,750 --> 00:20:57,900
basically it's a collection of touch

00:20:53,540 --> 00:21:01,320
actions what it does you get only two

00:20:57,900 --> 00:21:04,920
functions add and perform when you run

00:21:01,320 --> 00:21:09,360
add basically it's adding the action

00:21:04,920 --> 00:21:11,490
that you want to run onto the say a list

00:21:09,360 --> 00:21:15,300
and it collects all the actions that you

00:21:11,490 --> 00:21:18,030
want to run once you run perform it's

00:21:15,300 --> 00:21:21,960
gonna send all the commands at once to

00:21:18,030 --> 00:21:24,420
the iPad or your device and basically

00:21:21,960 --> 00:21:27,150
it's gonna run them sequence lis and

00:21:24,420 --> 00:21:32,010
it's not gonna spend time sending each

00:21:27,150 --> 00:21:36,080
request separately so let's see that in

00:21:32,010 --> 00:21:36,080
action what I want to do is basically

00:21:36,320 --> 00:21:46,850
select a song and where's my mouse there

00:21:43,350 --> 00:21:46,850
it is okay

00:21:47,270 --> 00:21:54,390
so I'm gonna open a little plugin called

00:21:49,740 --> 00:21:57,750
H delay it's a delay plug-in and it has

00:21:54,390 --> 00:22:00,500
a button called tap tempo so you can

00:21:57,750 --> 00:22:04,410
actually click on the on the button to

00:22:00,500 --> 00:22:10,560
measure or to set the delay time based

00:22:04,410 --> 00:22:15,180
on your tempo so first we want to select

00:22:10,560 --> 00:22:18,740
a song and get rid of that notification

00:22:15,180 --> 00:22:22,350
center if occasion dialogue thank you

00:22:18,740 --> 00:22:28,620
I'm a jazz fan so I'm gonna pick a Dave

00:22:22,350 --> 00:22:31,140
Brubeck song and we can hear it and what

00:22:28,620 --> 00:22:35,970
I'm gonna do is I'm gonna try to that

00:22:31,140 --> 00:22:42,120
appium sync the tempo it's gonna tap and

00:22:35,970 --> 00:22:45,480
you can hear the delay changing now this

00:22:42,120 --> 00:22:48,090
is not a very consistent test as you can

00:22:45,480 --> 00:22:50,220
see the delay changed a bit more it's

00:22:48,090 --> 00:22:55,620
not actually pressing at the same time

00:22:50,220 --> 00:22:58,890
it's not synced up to the tempo I'm

00:22:55,620 --> 00:23:01,680
gonna stop the song and the reason is

00:22:58,890 --> 00:23:04,530
that because we didn't use multi actions

00:23:01,680 --> 00:23:12,180
I just used touch action sending each

00:23:04,530 --> 00:23:17,850
and each command so a bit about the app

00:23:12,180 --> 00:23:20,070
in philosophy most importantly you

00:23:17,850 --> 00:23:24,420
shouldn't recompile or modify your app

00:23:20,070 --> 00:23:27,810
this can introduce a risk of bugs or

00:23:24,420 --> 00:23:32,160
maybe even you can miss bugs that your

00:23:27,810 --> 00:23:36,150
automation is not using a certain

00:23:32,160 --> 00:23:38,550
feature that users using appium also

00:23:36,150 --> 00:23:41,120
states that you shouldn't be locked into

00:23:38,550 --> 00:23:44,580
a specific language to run your test or

00:23:41,120 --> 00:23:49,350
a framework basically it's an HTTP

00:23:44,580 --> 00:23:54,570
server so it can run on any platform on

00:23:49,350 --> 00:23:56,730
any language including Python a mobile

00:23:54,570 --> 00:23:58,950
automation framework shouldn't reinvent

00:23:56,730 --> 00:24:00,210
the wheel when it comes to automation

00:23:58,950 --> 00:24:02,639
api's

00:24:00,210 --> 00:24:06,590
basically what it means is they're using

00:24:02,639 --> 00:24:14,100
a proprietary webdriver selenium which

00:24:06,590 --> 00:24:17,730
is also done by by sauce labs and lastly

00:24:14,100 --> 00:24:20,399
a mobile animation framework should be

00:24:17,730 --> 00:24:23,039
open-source in spirit and that's what

00:24:20,399 --> 00:24:26,669
we're all here to collaborate and help

00:24:23,039 --> 00:24:30,330
Python grow I'm gonna give you some

00:24:26,669 --> 00:24:33,899
final tips on on creating your automated

00:24:30,330 --> 00:24:37,889
tests first try to divide your tests

00:24:33,899 --> 00:24:40,679
into separate chunks don't create one

00:24:37,889 --> 00:24:42,840
giant test that it's gonna test your app

00:24:40,679 --> 00:24:45,059
from one end to the other because if you

00:24:42,840 --> 00:24:49,049
get a failure you're gonna have to debug

00:24:45,059 --> 00:24:53,249
the test if you have let's say 50 tests

00:24:49,049 --> 00:24:55,649
doing very small parts and let's say

00:24:53,249 --> 00:24:59,700
that 15 of them failed you already have

00:24:55,649 --> 00:25:05,519
a reasonable understanding on how it

00:24:59,700 --> 00:25:07,740
failed or at what areas next try to

00:25:05,519 --> 00:25:10,999
choose tests take a long time to

00:25:07,740 --> 00:25:16,169
complete lately we've written a test

00:25:10,999 --> 00:25:20,429
that it took 12 hours to run but it took

00:25:16,169 --> 00:25:23,820
a human being a week a week's pay to

00:25:20,429 --> 00:25:28,190
complete it manually so we actually

00:25:23,820 --> 00:25:31,590
saved the week and running it overnight

00:25:28,190 --> 00:25:34,850
you have to consider the next item if

00:25:31,590 --> 00:25:37,710
you're using a reference for your test a

00:25:34,850 --> 00:25:42,929
reference data if it's images audio

00:25:37,710 --> 00:25:45,539
files database XML whatever make sure

00:25:42,929 --> 00:25:47,519
that you know and you are aware these

00:25:45,539 --> 00:25:52,860
are going to be changed once the

00:25:47,519 --> 00:25:56,190
products change and if you need to do a

00:25:52,860 --> 00:25:58,769
lot of work a lot of tests and maybe you

00:25:56,190 --> 00:26:01,320
need to consider tests that are that

00:25:58,769 --> 00:26:05,909
don't use a reference I can actually

00:26:01,320 --> 00:26:07,980
figure for them cells and lastly not

00:26:05,909 --> 00:26:13,510
every test is suitable as an automated

00:26:07,980 --> 00:26:16,080
test as I said before manual testing

00:26:13,510 --> 00:26:22,150
be intelligent testing that you have to

00:26:16,080 --> 00:26:24,690
think about and adapt and my last item

00:26:22,150 --> 00:26:28,150
that I want to present to you is this

00:26:24,690 --> 00:26:32,670
automated testing is an insurance policy

00:26:28,150 --> 00:26:36,480
the more you tests the more recovered so

00:26:32,670 --> 00:26:39,670
here are some links and sources first

00:26:36,480 --> 00:26:41,920
the appium website is very informative

00:26:39,670 --> 00:26:45,670
it's got a lot of documentation about

00:26:41,920 --> 00:26:49,030
how to run a p.m. how to set it up

00:26:45,670 --> 00:26:52,540
there's a nice ebook by Nisha and Verma

00:26:49,030 --> 00:26:56,350
for the Android I didn't talk about

00:26:52,540 --> 00:26:58,990
Android but basically it applies the

00:26:56,350 --> 00:27:04,020
same API so your code is gonna work on

00:26:58,990 --> 00:27:07,090
both iOS and Android the same code and

00:27:04,020 --> 00:27:10,210
also if you want to introduce your app

00:27:07,090 --> 00:27:14,320
into the App Store then you're gonna

00:27:10,210 --> 00:27:17,860
have to read or I I recommend you

00:27:14,320 --> 00:27:21,400
reading blog by Daniel Mathews about

00:27:17,860 --> 00:27:25,270
test flight and pretty producing apps to

00:27:21,400 --> 00:27:29,170
the App Store and you're free to come

00:27:25,270 --> 00:27:31,630
and see me later if you have at all if

00:27:29,170 --> 00:27:34,930
you have questions or anything you're

00:27:31,630 --> 00:27:38,800
free to go to the waves website and see

00:27:34,930 --> 00:27:40,950
some cool plugins that we do so thank

00:27:38,800 --> 00:27:40,950
you

00:27:41,270 --> 00:27:46,970

YouTube URL: https://www.youtube.com/watch?v=-ltFl1vbe6I


