Title: Steven Sklar - The Hare Wins the Race: Getting the most out of RabbitMQ in distributed applications
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Steven Sklar

As web apps grow increasingly complex, distributing asynchronous work across multiple background workers is often a basic requirement of a performant app.  While there are a variety of tools that exist to solve this issue, one common feature among them is the need for a robust messaging platform.

[RabbitMQ][1] is a stable, full-featured, and mature solution that is usually found in the Python ecosystem backing [Celery][2] implementations.  While Celery's utilization of RabbitMQ works just fine out of the gate, users with complex workflows, unique constraints, or tight budgets can take advantage of the flexibility of RabbitMQ to streamline their data pipelines and get the most out of their infrastructure.

This talk will provide an overview of RabbitMQ, review its varied message-routing capabilities, and demonstrate some of the ways in which these features can be utilized in Python applications to solve common yet difficult use-cases.

  [1]: https://www.rabbitmq.com/
  [2]: http://www.celeryproject.org/


Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:01,520 --> 00:00:07,680
good afternoon PyCon please welcome

00:00:05,069 --> 00:00:09,630
Steven Sklar here to share with us the

00:00:07,680 --> 00:00:11,400
hair wins the race getting the most out

00:00:09,630 --> 00:00:19,410
of rabbit mq and distributed

00:00:11,400 --> 00:00:21,210
applications thank you hi my name is

00:00:19,410 --> 00:00:23,609
Steven Sklar and I'm here today to talk

00:00:21,210 --> 00:00:25,289
to you about RabbitMQ and how to use it

00:00:23,609 --> 00:00:28,289
in your distributed applications written

00:00:25,289 --> 00:00:29,939
in Python but before I get started I've

00:00:28,289 --> 00:00:33,180
always wanted to say this from one of my

00:00:29,939 --> 00:00:40,410
favorite movies spinal tap hello

00:00:33,180 --> 00:00:42,300
Cleveland's hopefully hopefully this

00:00:40,410 --> 00:00:45,780
tacos better than spinal tap trying to

00:00:42,300 --> 00:00:47,520
find the stage now that we've gotten

00:00:45,780 --> 00:00:50,700
that out of the way a little bit about

00:00:47,520 --> 00:00:52,770
me I am a development engineer at

00:00:50,700 --> 00:00:54,629
pre-data a new york-based startup that

00:00:52,770 --> 00:00:56,910
specializes in alternative data and

00:00:54,629 --> 00:00:59,579
machine learning we make extensive use

00:00:56,910 --> 00:01:01,079
of RabbitMQ to orchestrate asynchronous

00:00:59,579 --> 00:01:02,579
work done throughout the day and also

00:01:01,079 --> 00:01:06,450
during our nightly machine learning

00:01:02,579 --> 00:01:08,790
pipeline here's a brief overview of what

00:01:06,450 --> 00:01:10,860
I'll be covering today first I will

00:01:08,790 --> 00:01:12,390
provide a general overview of RabbitMQ

00:01:10,860 --> 00:01:15,630
concepts for those who are unfamiliar

00:01:12,390 --> 00:01:17,130
with it or need a quick refresher then I

00:01:15,630 --> 00:01:20,189
will demonstrate how to interact with

00:01:17,130 --> 00:01:22,530
RabbitMQ through python i will then talk

00:01:20,189 --> 00:01:25,320
about the Python library celery and how

00:01:22,530 --> 00:01:28,290
it uses rabbitmq to run remote tasks on

00:01:25,320 --> 00:01:30,030
remote servers I will then use a short

00:01:28,290 --> 00:01:32,240
case study to demonstrate some more

00:01:30,030 --> 00:01:35,009
advanced use cases of RabbitMQ and

00:01:32,240 --> 00:01:36,299
finally I will review a few gotchas that

00:01:35,009 --> 00:01:40,350
i've personally encountered while

00:01:36,299 --> 00:01:42,740
working with rabbitmq how many of you

00:01:40,350 --> 00:01:46,799
have ever worked with rabbitmq before oh

00:01:42,740 --> 00:01:49,590
wow great very cool for those of you who

00:01:46,799 --> 00:01:53,729
haven't heard of it and are asking what

00:01:49,590 --> 00:01:59,180
is rabbitmq the answer is rapid mq is a

00:01:53,729 --> 00:02:01,680
message broker what's that you may ask

00:01:59,180 --> 00:02:04,770
basically it's a server that receives

00:02:01,680 --> 00:02:06,630
routes and delivers messages to and from

00:02:04,770 --> 00:02:10,050
various components of a distributed

00:02:06,630 --> 00:02:11,300
application there are currently a few

00:02:10,050 --> 00:02:13,690
message brokers out there today

00:02:11,300 --> 00:02:17,920
including rabbitmq

00:02:13,690 --> 00:02:22,210
apache kafka amazon sqs google pub/sub

00:02:17,920 --> 00:02:23,560
and 0 mq there are benefits and

00:02:22,210 --> 00:02:24,910
drawbacks to each of these which

00:02:23,560 --> 00:02:27,160
honestly could be the topic of an

00:02:24,910 --> 00:02:30,040
entirely separate talk so today I will

00:02:27,160 --> 00:02:33,940
solely focus on RabbitMQ and its uses in

00:02:30,040 --> 00:02:36,430
the Python ecosystem rabbitmq was

00:02:33,940 --> 00:02:37,720
written in Erlang in 2007 and is

00:02:36,430 --> 00:02:40,360
released under the Mozilla Public

00:02:37,720 --> 00:02:42,220
License according to their website it

00:02:40,360 --> 00:02:44,290
has at least 35,000 production

00:02:42,220 --> 00:02:46,420
deployments making it quote the most

00:02:44,290 --> 00:02:50,710
open the most popular open source

00:02:46,420 --> 00:02:52,770
message broker so now I'll review some

00:02:50,710 --> 00:02:54,940
of the basic building blocks of RabbitMQ

00:02:52,770 --> 00:02:59,200
and I'll start with producers and

00:02:54,940 --> 00:03:00,730
consumers this part is easy producers

00:02:59,200 --> 00:03:02,650
are simply applications that send

00:03:00,730 --> 00:03:04,840
messages to a RabbitMQ broker and

00:03:02,650 --> 00:03:07,480
consumers are applications that receive

00:03:04,840 --> 00:03:08,950
messages from one these are your

00:03:07,480 --> 00:03:11,110
applications really written in any

00:03:08,950 --> 00:03:13,120
programming language that need to send

00:03:11,110 --> 00:03:17,830
and receive messages to and from each

00:03:13,120 --> 00:03:22,930
other the next rabbitmq object is namely

00:03:17,830 --> 00:03:25,420
a queue queues are objects that live on

00:03:22,930 --> 00:03:27,730
the RabbitMQ Broker and store messages

00:03:25,420 --> 00:03:29,470
for consumers to retrieve like a

00:03:27,730 --> 00:03:30,070
standard queue object in computer

00:03:29,470 --> 00:03:34,810
science

00:03:30,070 --> 00:03:36,700
they are FIFO first-in-first-out queues

00:03:34,810 --> 00:03:39,730
have specific properties that can be set

00:03:36,700 --> 00:03:42,220
a creation time the most basic is the

00:03:39,730 --> 00:03:44,080
queue name but you can also set a queue

00:03:42,220 --> 00:03:45,790
to be durable meaning that it will

00:03:44,080 --> 00:03:49,150
persist if the broker restarts or

00:03:45,790 --> 00:03:51,250
crashes exclusive which means that the

00:03:49,150 --> 00:03:55,030
queue can only be used by one in only

00:03:51,250 --> 00:03:57,100
one connection and auto deleting which

00:03:55,030 --> 00:03:58,870
means that once a queue has been used it

00:03:57,100 --> 00:04:02,709
is destroyed once the last consumer

00:03:58,870 --> 00:04:04,660
disconnects from it rabbitmq also

00:04:02,709 --> 00:04:06,310
supports optional arguments that are

00:04:04,660 --> 00:04:08,019
used by various plugins throughout the

00:04:06,310 --> 00:04:12,280
ecosystem some of which I'll go over

00:04:08,019 --> 00:04:13,630
later in this talk the next building

00:04:12,280 --> 00:04:16,540
block that I'd like to discuss is in

00:04:13,630 --> 00:04:18,700
exchange exchanges are objects that

00:04:16,540 --> 00:04:20,350
accept messages from producers and then

00:04:18,700 --> 00:04:24,910
route those messages to the appropriate

00:04:20,350 --> 00:04:26,919
cues in rabbitmq it is important to note

00:04:24,910 --> 00:04:27,470
that producers do not directly send

00:04:26,919 --> 00:04:30,800
messages

00:04:27,470 --> 00:04:32,360
Q's instead exchanges are responsible

00:04:30,800 --> 00:04:34,460
for routing messages to the appropriate

00:04:32,360 --> 00:04:37,430
queues and producers then send those

00:04:34,460 --> 00:04:39,860
messages to exchanges light cues

00:04:37,430 --> 00:04:42,740
exchanges can also have properties like

00:04:39,860 --> 00:04:45,380
durability exclusivity and auto-delete

00:04:42,740 --> 00:04:47,690
ability there are multiple types of

00:04:45,380 --> 00:04:49,790
exchanges and each type routes messages

00:04:47,690 --> 00:04:51,470
in a different way but before I get into

00:04:49,790 --> 00:04:53,030
those details I want to quickly

00:04:51,470 --> 00:04:56,300
introduce you to one more important

00:04:53,030 --> 00:04:58,220
concept which is bindings a binding

00:04:56,300 --> 00:05:00,560
connects in exchange to a queue and

00:04:58,220 --> 00:05:03,470
contains additional metadata such as a

00:05:00,560 --> 00:05:05,240
binding key a queue can only receive

00:05:03,470 --> 00:05:07,640
messages from an exchange that it is

00:05:05,240 --> 00:05:09,230
bound to and an exchange can only send

00:05:07,640 --> 00:05:11,960
messages to the queues that are bound to

00:05:09,230 --> 00:05:14,300
in the binding key is used by the

00:05:11,960 --> 00:05:15,740
exchange to deliver messages to the

00:05:14,300 --> 00:05:19,550
appropriate queues based on the

00:05:15,740 --> 00:05:21,590
exchanges type so now that we've covered

00:05:19,550 --> 00:05:23,840
bindings we are ready to review the

00:05:21,590 --> 00:05:26,210
different types of exchanges three of

00:05:23,840 --> 00:05:28,790
them that ship with RabbitMQ are direct

00:05:26,210 --> 00:05:30,230
topic and fan-out and each one of these

00:05:28,790 --> 00:05:33,440
processes message routing keys

00:05:30,230 --> 00:05:38,330
differently first we'll talk about

00:05:33,440 --> 00:05:40,730
direct exchanges a direct exchange reads

00:05:38,330 --> 00:05:42,860
the routing key on a message finds the

00:05:40,730 --> 00:05:45,080
binding or bindings with the same

00:05:42,860 --> 00:05:48,050
binding key and routes the message to

00:05:45,080 --> 00:05:50,720
the queue at the other end so in this

00:05:48,050 --> 00:05:53,479
case a message with the routing key food

00:05:50,720 --> 00:06:00,500
op arm will be routed along the food bar

00:05:53,479 --> 00:06:03,290
binding to cue a similarly a message

00:06:00,500 --> 00:06:05,030
with the routing key futaba's will be

00:06:03,290 --> 00:06:09,950
routed along the food table as binding

00:06:05,030 --> 00:06:12,970
to QB now we're going to change the

00:06:09,950 --> 00:06:16,010
routing for QC to food op as as well

00:06:12,970 --> 00:06:17,540
this is to show that multiple queues can

00:06:16,010 --> 00:06:18,320
be bound to in exchange with the same

00:06:17,540 --> 00:06:20,630
binding key

00:06:18,320 --> 00:06:25,190
so both qs b and c received a final

00:06:20,630 --> 00:06:29,300
message next i'll talk about topic

00:06:25,190 --> 00:06:31,580
exchanges topic exchanges work similarly

00:06:29,300 --> 00:06:34,310
to direct exchanges with one important

00:06:31,580 --> 00:06:37,610
difference the binding key accepts two

00:06:34,310 --> 00:06:40,250
wildcards an asterisk can take the place

00:06:37,610 --> 00:06:41,210
of exactly one word and a hash tag can

00:06:40,250 --> 00:06:43,880
substitute for Zee

00:06:41,210 --> 00:06:46,840
or more words words are separated by

00:06:43,880 --> 00:06:50,600
periods and limited to 255 bytes in size

00:06:46,840 --> 00:06:54,350
so in the previous example foo bar and

00:06:50,600 --> 00:06:56,360
Baz are all examples of words a topic

00:06:54,350 --> 00:06:58,639
exchange behaves exactly the same as a

00:06:56,360 --> 00:07:00,680
direct exchange if no wild cards are

00:06:58,639 --> 00:07:03,710
used in a binding key so all of the

00:07:00,680 --> 00:07:06,229
previous bindings food bar and bar table

00:07:03,710 --> 00:07:09,110
as are all vapp completely valid for

00:07:06,229 --> 00:07:11,660
both direct and topic exchanges however

00:07:09,110 --> 00:07:13,250
the two wild cards and topic exchanges

00:07:11,660 --> 00:07:15,349
can be used in extremely powerful ways

00:07:13,250 --> 00:07:18,440
so let's walk through these bindings

00:07:15,349 --> 00:07:20,630
from top to bottom the first one all

00:07:18,440 --> 00:07:22,960
messages with routing keys starting with

00:07:20,630 --> 00:07:25,520
the word foo will now be routed to QA

00:07:22,960 --> 00:07:27,560
regardless of their length and this also

00:07:25,520 --> 00:07:30,349
includes routing keys with only one word

00:07:27,560 --> 00:07:33,860
foo since a hash tag can match zero

00:07:30,349 --> 00:07:36,580
words all messages with routing keys

00:07:33,860 --> 00:07:39,169
that end in Baz will be routed to QB

00:07:36,580 --> 00:07:43,460
again this also includes messages with a

00:07:39,169 --> 00:07:45,979
one word Baz routing team QC is a little

00:07:43,460 --> 00:07:48,650
different since an asterisk can only

00:07:45,979 --> 00:07:51,020
substitute for exactly one word this

00:07:48,650 --> 00:07:53,419
binding matches only three word routing

00:07:51,020 --> 00:07:54,949
keys that start with foo have another

00:07:53,419 --> 00:07:58,070
word in the middle that's substituted by

00:07:54,949 --> 00:08:01,760
the asterisk and end in Baz so let's

00:07:58,070 --> 00:08:04,280
look at some examples here a message

00:08:01,760 --> 00:08:07,909
with food a bar with a food bar routing

00:08:04,280 --> 00:08:10,699
key only matches the binding to QA since

00:08:07,909 --> 00:08:12,880
it starts with foo and ends in anything

00:08:10,699 --> 00:08:12,880
else

00:08:14,289 --> 00:08:20,300
routing key bar Baz only matches the

00:08:17,630 --> 00:08:22,389
binding to QB since it ends in Baz and

00:08:20,300 --> 00:08:24,830
begins with anything else

00:08:22,389 --> 00:08:27,349
both of these messages did not get

00:08:24,830 --> 00:08:29,870
routed to QC because QC requires a

00:08:27,349 --> 00:08:35,120
routing key of exactly three words and

00:08:29,870 --> 00:08:38,120
those only had two so futaba's now

00:08:35,120 --> 00:08:40,669
matches both Q's a and B because it

00:08:38,120 --> 00:08:45,159
begins with foo so it matches QA and

00:08:40,669 --> 00:08:45,159
ends in Baz and it matches QB

00:08:46,390 --> 00:08:52,700
food bar tapas now matches all three

00:08:50,150 --> 00:08:57,980
bindings so the message gets routed to

00:08:52,700 --> 00:09:01,910
all of our cues finally I'd like to

00:08:57,980 --> 00:09:04,130
discuss fan-out exchanges a fan-out

00:09:01,910 --> 00:09:06,500
exchange simply routes any message to

00:09:04,130 --> 00:09:07,850
all cues that it is bound to and just

00:09:06,500 --> 00:09:11,240
ignores the messages routing key

00:09:07,850 --> 00:09:16,040
altogether so in this case our message

00:09:11,240 --> 00:09:17,810
will be routed to cues a B and C this

00:09:16,040 --> 00:09:20,120
can also be replicated with the topic

00:09:17,810 --> 00:09:23,570
exchange by setting all of the binding

00:09:20,120 --> 00:09:25,700
keys to hash tags because remember a

00:09:23,570 --> 00:09:28,580
hash tag can match zero or more words

00:09:25,700 --> 00:09:34,340
which in effect matches every single

00:09:28,580 --> 00:09:36,680
possible binding key so again to wrap up

00:09:34,340 --> 00:09:39,170
a producer sends a message to an

00:09:36,680 --> 00:09:42,470
exchange which routes it to a cue that

00:09:39,170 --> 00:09:47,120
it is bound to a consumer then reads the

00:09:42,470 --> 00:09:48,740
message off the queue rabbitmq also

00:09:47,120 --> 00:09:51,890
ships with a very handy management

00:09:48,740 --> 00:09:54,260
interface it shows the status of all

00:09:51,890 --> 00:09:56,930
connections exchanges and queues in real

00:09:54,260 --> 00:10:00,560
time in a default installation it is

00:09:56,930 --> 00:10:02,600
reachable on port 15 672 and personally

00:10:00,560 --> 00:10:04,400
I found it extremely useful and I highly

00:10:02,600 --> 00:10:06,140
recommend taking a look at it if you

00:10:04,400 --> 00:10:10,940
have rabbitmq installed on your machine

00:10:06,140 --> 00:10:13,430
or server so now that I've covered some

00:10:10,940 --> 00:10:17,930
of the RabbitMQ basics let's explore how

00:10:13,430 --> 00:10:19,280
to harness its power in python the

00:10:17,930 --> 00:10:23,000
default way to communicate with the

00:10:19,280 --> 00:10:26,420
RabbitMQ broker is over AMQP or advanced

00:10:23,000 --> 00:10:28,340
Message Queuing protocol AMQP is an open

00:10:26,420 --> 00:10:30,170
source protocol that was developed in

00:10:28,340 --> 00:10:34,610
the early 2000s and first published in

00:10:30,170 --> 00:10:38,420
2006 the 1.0 spec was released in 2011

00:10:34,610 --> 00:10:39,980
and is the current version to date there

00:10:38,420 --> 00:10:44,120
are several libraries in Python that

00:10:39,980 --> 00:10:46,400
implement AMQP Lib rapid mq provides

00:10:44,120 --> 00:10:51,140
Python bindings over the liberated' mqc

00:10:46,400 --> 00:10:53,360
library which is written in c pi AMQP is

00:10:51,140 --> 00:10:58,579
a pure python implementation of libera

00:10:53,360 --> 00:11:00,079
mq pika is also a pure Python solution

00:10:58,579 --> 00:11:02,239
abstracts away some of the low-level

00:11:00,079 --> 00:11:05,920
connectivity functionality that you need

00:11:02,239 --> 00:11:05,920
to implement by hand in the previous two

00:11:06,369 --> 00:11:10,759
kombu provides an additional layer of

00:11:08,600 --> 00:11:13,160
abstraction over the AMQP protocol

00:11:10,759 --> 00:11:14,899
itself it is used as a general-purpose

00:11:13,160 --> 00:11:16,879
messaging framework and supports

00:11:14,899 --> 00:11:19,999
additional protocols including ones

00:11:16,879 --> 00:11:24,559
backed by Redis Amazon SQS pyro and

00:11:19,999 --> 00:11:26,360
others so now I will review a code

00:11:24,559 --> 00:11:27,769
example that will demonstrate how to

00:11:26,360 --> 00:11:29,929
send and receive messages from a

00:11:27,769 --> 00:11:32,149
rabbitmq broker using the Pico library

00:11:29,929 --> 00:11:34,369
if you'd like to follow along with the

00:11:32,149 --> 00:11:37,189
actual source all code is available on

00:11:34,369 --> 00:11:41,209
my github in the RabbitMQ presentation

00:11:37,189 --> 00:11:46,699
repo also there is my lovable dog nacho

00:11:41,209 --> 00:11:49,339
who I'm kind of obsessed with first we

00:11:46,699 --> 00:11:52,129
need to set up the environment in the

00:11:49,339 --> 00:11:54,019
inant RabbitMQ function I use pica to

00:11:52,129 --> 00:11:55,970
open a blocking connection to RabbitMQ

00:11:54,019 --> 00:11:58,100
and use that connection to open up a

00:11:55,970 --> 00:12:01,160
synchronous communication channel where

00:11:58,100 --> 00:12:03,499
all activity takes place I use that

00:12:01,160 --> 00:12:06,079
channel to declare Q and a direct

00:12:03,499 --> 00:12:09,860
exchange I then bind those two together

00:12:06,079 --> 00:12:11,509
with a simple routing key routing key so

00:12:09,860 --> 00:12:14,149
that any message sent to my exchange

00:12:11,509 --> 00:12:18,949
with a matching routing key will get

00:12:14,149 --> 00:12:22,160
routed to my queue next I built a simple

00:12:18,949 --> 00:12:23,720
producer class this producer accepts a

00:12:22,160 --> 00:12:25,999
blocking connection object in its

00:12:23,720 --> 00:12:28,549
constructor and has a method to send a

00:12:25,999 --> 00:12:30,919
message in order to send a message with

00:12:28,549 --> 00:12:33,709
this method we need its content the

00:12:30,919 --> 00:12:36,860
exchange name and the messages routing

00:12:33,709 --> 00:12:38,480
key given that information we publish

00:12:36,860 --> 00:12:43,369
the message to the specified exchange

00:12:38,480 --> 00:12:46,819
and then close the channel next I build

00:12:43,369 --> 00:12:48,439
a consumer class like the producer this

00:12:46,819 --> 00:12:51,019
accepts a connection to the broker in

00:12:48,439 --> 00:12:54,230
its constructor and has one method get

00:12:51,019 --> 00:12:56,419
message get message accepts one argument

00:12:54,230 --> 00:12:57,529
which is a string containing the name of

00:12:56,419 --> 00:13:00,259
the queue that it will attempt to

00:12:57,529 --> 00:13:02,360
retrieve a message from inside this

00:13:00,259 --> 00:13:05,480
method we create another channel and

00:13:02,360 --> 00:13:07,490
execute a basic yet if there is no

00:13:05,480 --> 00:13:10,039
message in the if there is no message on

00:13:07,490 --> 00:13:12,260
the queue frame and body will be none

00:13:10,039 --> 00:13:15,329
and the function will return on

00:13:12,260 --> 00:13:17,519
but what makes RabbitMQ so reliable and

00:13:15,329 --> 00:13:19,440
powerful is its message acknowledgement

00:13:17,519 --> 00:13:22,529
feature which you can see in the second

00:13:19,440 --> 00:13:24,690
to last line here once we've

00:13:22,529 --> 00:13:26,070
successfully retrieved a message we send

00:13:24,690 --> 00:13:28,170
an acknowledgement back to the broker

00:13:26,070 --> 00:13:30,480
that says it's okay to pop this message

00:13:28,170 --> 00:13:32,250
off the queue if our connection is

00:13:30,480 --> 00:13:34,430
interrupted between the time we get the

00:13:32,250 --> 00:13:37,350
message but before we acknowledge it

00:13:34,430 --> 00:13:39,360
rabbitmq places that message back on the

00:13:37,350 --> 00:13:42,089
queue for another consumer to read in

00:13:39,360 --> 00:13:44,220
the future this way we can guarantee

00:13:42,089 --> 00:13:46,529
that any processing related to that

00:13:44,220 --> 00:13:49,110
message has been completed in full as

00:13:46,529 --> 00:13:50,970
long as we acknowledge that the message

00:13:49,110 --> 00:13:53,750
sorry as long as we acknowledge the

00:13:50,970 --> 00:13:56,550
message after processing is complete

00:13:53,750 --> 00:13:58,199
this is a very useful property when

00:13:56,550 --> 00:14:00,540
using Amazon spot instances for example

00:13:58,199 --> 00:14:03,800
which have undefined lifespans and can

00:14:00,540 --> 00:14:03,800
shut down with only short notice

00:14:03,920 --> 00:14:09,300
so to run this example we first have to

00:14:07,050 --> 00:14:11,550
set up our RabbitMQ environment using

00:14:09,300 --> 00:14:13,800
the anit function we wrote earlier we

00:14:11,550 --> 00:14:16,290
then create a connection instantiate a

00:14:13,800 --> 00:14:20,940
producer and send a hello world message

00:14:16,290 --> 00:14:23,130
of course finally we instantiate a

00:14:20,940 --> 00:14:25,100
consumer attempt to retrieve the message

00:14:23,130 --> 00:14:27,449
off of our queue and print the message

00:14:25,100 --> 00:14:32,910
so if you run the code and github

00:14:27,449 --> 00:14:35,010
you'll get hello world so now moving on

00:14:32,910 --> 00:14:37,620
one of the main places that you'll see

00:14:35,010 --> 00:14:40,110
rabbitmq in the python ecosystem is in

00:14:37,620 --> 00:14:43,470
celery how many of you have ever used

00:14:40,110 --> 00:14:47,970
celery before Wow okay that's a lot of

00:14:43,470 --> 00:14:52,139
people for those of you who haven't what

00:14:47,970 --> 00:14:54,180
is celery yes it is a vegetable that is

00:14:52,139 --> 00:14:55,500
very tasty with some peanut butter and I

00:14:54,180 --> 00:14:58,589
can hold the raisins I don't really need

00:14:55,500 --> 00:15:00,389
them but celery is also a library that

00:14:58,589 --> 00:15:03,510
allows you to run functions on remote

00:15:00,389 --> 00:15:06,810
servers it also lets you link together

00:15:03,510 --> 00:15:08,730
tasks to create larger workflows there

00:15:06,810 --> 00:15:10,470
are celery plug-ins for a variety of the

00:15:08,730 --> 00:15:12,899
most popular web frameworks including

00:15:10,470 --> 00:15:14,699
Django and it works well with flask and

00:15:12,899 --> 00:15:15,990
you actually don't even need a web

00:15:14,699 --> 00:15:20,939
framework you can just import the

00:15:15,990 --> 00:15:23,910
library and start using it the basic

00:15:20,939 --> 00:15:26,040
building block in celery is a task to

00:15:23,910 --> 00:15:27,839
declare a task all you need to do

00:15:26,040 --> 00:15:30,750
is rap a function with celery's task

00:15:27,839 --> 00:15:33,420
decorator now you are ready to run this

00:15:30,750 --> 00:15:35,100
function locally or remotely and add it

00:15:33,420 --> 00:15:38,790
to workflows that link together other

00:15:35,100 --> 00:15:41,459
similarly wrapped functions so here by

00:15:38,790 --> 00:15:43,230
calling delay on the create user task we

00:15:41,459 --> 00:15:47,430
are instructing celery to run this task

00:15:43,230 --> 00:15:49,620
remotely this means that celery will

00:15:47,430 --> 00:15:51,690
send a message to an exchange with

00:15:49,620 --> 00:15:54,110
instructions on which task to run and

00:15:51,690 --> 00:15:57,269
any args and kwargs pass to the function

00:15:54,110 --> 00:15:59,430
as we saw earlier this message will also

00:15:57,269 --> 00:16:01,290
contain a routing key which routes the

00:15:59,430 --> 00:16:03,920
message to the appropriate queue based

00:16:01,290 --> 00:16:06,750
on the exchanges type and its bindings a

00:16:03,920 --> 00:16:09,720
celery worker watching a queue will then

00:16:06,750 --> 00:16:12,060
retrieve the message deserialize it run

00:16:09,720 --> 00:16:14,250
the function and store the result in a

00:16:12,060 --> 00:16:17,540
storage layer such as Redis for the

00:16:14,250 --> 00:16:17,540
client to pick up when it is ready

00:16:17,750 --> 00:16:22,440
celery is designed to work with its

00:16:19,980 --> 00:16:24,060
out-of-the-box configuration and chips

00:16:22,440 --> 00:16:27,779
with some sensible routing related

00:16:24,060 --> 00:16:30,029
defaults when using RabbitMQ as the

00:16:27,779 --> 00:16:32,399
message broker for celery by default

00:16:30,029 --> 00:16:34,680
celery creates a single exchange in a

00:16:32,399 --> 00:16:37,769
queue for all tasks conveniently named

00:16:34,680 --> 00:16:40,649
celery while this is fine for most

00:16:37,769 --> 00:16:42,810
workflows as we shall soon see this can

00:16:40,649 --> 00:16:48,000
cause problems in larger or more complex

00:16:42,810 --> 00:16:50,730
systems now that I've introduced some

00:16:48,000 --> 00:16:52,800
basics I'd like to use a case study to

00:16:50,730 --> 00:16:55,370
demonstrate how to use RabbitMQ to its

00:16:52,800 --> 00:16:55,370
full potential

00:16:56,300 --> 00:17:01,350
while this case study uses celery as the

00:16:59,279 --> 00:17:03,630
mechanism for interacting with rabbitmq

00:17:01,350 --> 00:17:05,669
the concepts presented here are

00:17:03,630 --> 00:17:07,829
applicable to any application using

00:17:05,669 --> 00:17:10,020
RabbitMQ through any of the libraries

00:17:07,829 --> 00:17:12,240
that I previously mentioned if you're

00:17:10,020 --> 00:17:13,740
following along github I don't see too

00:17:12,240 --> 00:17:16,020
many laptops out there but hopefully

00:17:13,740 --> 00:17:20,329
somebody is this example is under the

00:17:16,020 --> 00:17:23,490
celery example initial directory in

00:17:20,329 --> 00:17:26,159
celery's default configuration all tasks

00:17:23,490 --> 00:17:29,340
are sent to one queue as you can imagine

00:17:26,159 --> 00:17:31,260
this can cause several problems the

00:17:29,340 --> 00:17:32,580
biggest one we encountered was that all

00:17:31,260 --> 00:17:34,740
of our workers would get backed up

00:17:32,580 --> 00:17:37,290
running long tasks like fitting a model

00:17:34,740 --> 00:17:39,010
and other tasks would get stuck on our

00:17:37,290 --> 00:17:41,410
rabbitmq queues

00:17:39,010 --> 00:17:43,720
worker freedom this would lead to

00:17:41,410 --> 00:17:45,100
degraded website performance since many

00:17:43,720 --> 00:17:47,440
of these background tasks actually

00:17:45,100 --> 00:17:50,200
return results that are used on our

00:17:47,440 --> 00:17:54,430
client facing front end so let's see how

00:17:50,200 --> 00:17:57,280
this setup looks like in code here's our

00:17:54,430 --> 00:18:00,310
basic salary configuration it contains

00:17:57,280 --> 00:18:03,160
our RabbitMQ brokers URL a list of

00:18:00,310 --> 00:18:05,020
Python imports for workers to use and a

00:18:03,160 --> 00:18:07,240
back-end for storing asynchronous

00:18:05,020 --> 00:18:09,400
results which in this case is a simple

00:18:07,240 --> 00:18:10,990
sequel Lite database but could be

00:18:09,400 --> 00:18:16,690
something larger like Redis in

00:18:10,990 --> 00:18:18,970
production deployments here I defined to

00:18:16,690 --> 00:18:22,420
mock tasks that are proxies for other

00:18:18,970 --> 00:18:24,100
jobs in the system in this example the

00:18:22,420 --> 00:18:25,960
fit neural net task is meant to take

00:18:24,100 --> 00:18:32,410
significantly longer than the run user

00:18:25,960 --> 00:18:34,540
query tasks to run this example we

00:18:32,410 --> 00:18:36,840
launched a series of celery tasks each

00:18:34,540 --> 00:18:40,030
one sending a message to our exchange I

00:18:36,840 --> 00:18:42,640
have a worker with 4 threads listening

00:18:40,030 --> 00:18:45,520
to celery's to fall queue running tasks

00:18:42,640 --> 00:18:47,880
as they hit the queue so let's see what

00:18:45,520 --> 00:18:47,880
happens

00:18:52,330 --> 00:18:56,600
so here you can see our celery worker

00:18:54,799 --> 00:18:58,900
has started and it's just sitting there

00:18:56,600 --> 00:19:01,070
fitting neural nets with all these

00:18:58,900 --> 00:19:04,910
queries now just kind of stuck on our

00:19:01,070 --> 00:19:08,150
cues our website is slow our clients are

00:19:04,910 --> 00:19:15,230
unhappy and my boss is unhappy and but

00:19:08,150 --> 00:19:17,090
now here we go our queries have ran so

00:19:15,230 --> 00:19:20,559
again for the more visually inclined

00:19:17,090 --> 00:19:20,559
this is what's happening

00:19:24,190 --> 00:19:32,690
how can we use rabbitmq to solve this

00:19:26,990 --> 00:19:34,850
problem one solution would be to use two

00:19:32,690 --> 00:19:36,740
queues one for fitting our neural net

00:19:34,850 --> 00:19:39,679
and another for processing smaller

00:19:36,740 --> 00:19:42,169
quicker tasks we would also assign one

00:19:39,679 --> 00:19:44,270
of our workers to this second Q so

00:19:42,169 --> 00:19:45,710
queries could be processed at the same

00:19:44,270 --> 00:19:48,200
time that other workers are fitting

00:19:45,710 --> 00:19:53,510
neural nets so how can we set this up

00:19:48,200 --> 00:19:55,760
for those of you following along this

00:19:53,510 --> 00:19:59,809
code is in the celery example optimized

00:19:55,760 --> 00:20:01,929
directory celery provides options for

00:19:59,809 --> 00:20:04,790
users to define their own custom routes

00:20:01,929 --> 00:20:06,679
using these we can now route model

00:20:04,790 --> 00:20:09,530
fitting and other computationally

00:20:06,679 --> 00:20:12,860
intensive tasks to one queue and smaller

00:20:09,530 --> 00:20:15,260
client facing tasks to another we can

00:20:12,860 --> 00:20:17,120
optimize this even further by using more

00:20:15,260 --> 00:20:19,490
powerful workers to fit our neural nets

00:20:17,120 --> 00:20:21,830
and smaller instances to perform basic

00:20:19,490 --> 00:20:25,790
database queries which may even save us

00:20:21,830 --> 00:20:27,950
some money a celery router like this one

00:20:25,790 --> 00:20:29,780
is a function that accepts some

00:20:27,950 --> 00:20:32,240
arguments related to the task that you

00:20:29,780 --> 00:20:34,010
want to run and it returns a dict with

00:20:32,240 --> 00:20:36,020
information like the messages routing

00:20:34,010 --> 00:20:40,640
key and exchange that you want to send

00:20:36,020 --> 00:20:42,380
the message to celery then uses this

00:20:40,640 --> 00:20:44,900
information to send a message to an

00:20:42,380 --> 00:20:47,720
exchange that contains data on which

00:20:44,900 --> 00:20:49,010
tasks to run how to run it and any

00:20:47,720 --> 00:20:52,190
related arts and kwargs

00:20:49,010 --> 00:20:54,620
that will be passed to the function all

00:20:52,190 --> 00:20:57,590
of the works seen here happens at the

00:20:54,620 --> 00:21:00,800
producer level in Python code in the

00:20:57,590 --> 00:21:02,960
celery package once the message is sent

00:21:00,800 --> 00:21:04,920
to rapid MQ the calling function

00:21:02,960 --> 00:21:07,470
continues to run and the

00:21:04,920 --> 00:21:09,240
moves through the RabbitMQ broker to a

00:21:07,470 --> 00:21:12,360
queue bound to the exchange that the

00:21:09,240 --> 00:21:14,040
message was sent to here it will get

00:21:12,360 --> 00:21:16,560
picked up by one of our celery workers

00:21:14,040 --> 00:21:21,390
which will run the task and store its

00:21:16,560 --> 00:21:24,120
result in our storage layer now going

00:21:21,390 --> 00:21:25,920
back to our function in this case all

00:21:24,120 --> 00:21:28,620
this function does is return a dict

00:21:25,920 --> 00:21:31,170
specifying that all messages should be

00:21:28,620 --> 00:21:33,300
sent to our new smart exchange with a

00:21:31,170 --> 00:21:37,440
routing key equal to the tasks fully

00:21:33,300 --> 00:21:39,480
qualified name so now that we have our

00:21:37,440 --> 00:21:41,430
router written we do need to add some

00:21:39,480 --> 00:21:44,330
code to our celery config script to set

00:21:41,430 --> 00:21:47,670
up our new RabbitMQ exchanges in queues

00:21:44,330 --> 00:21:50,940
here we declare a topic exchange called

00:21:47,670 --> 00:21:52,380
smart remember this type of exchange has

00:21:50,940 --> 00:21:57,570
the ability to process keys with

00:21:52,380 --> 00:21:59,850
wildcards we then tell celery to use our

00:21:57,570 --> 00:22:02,720
new custom router instead of sending all

00:21:59,850 --> 00:22:08,250
messages to the default celery exchange

00:22:02,720 --> 00:22:10,350
and finally we set up two queues one for

00:22:08,250 --> 00:22:13,410
processing neural net tasks and the

00:22:10,350 --> 00:22:15,660
other for performing fast queries since

00:22:13,410 --> 00:22:17,370
we are using a topic exchange we can use

00:22:15,660 --> 00:22:19,530
a hash tag at the end of the namespace

00:22:17,370 --> 00:22:21,510
so that all tasks in the neural net

00:22:19,530 --> 00:22:23,820
namespace get routed to the neural net

00:22:21,510 --> 00:22:26,760
queue and likewise for all tasks in the

00:22:23,820 --> 00:22:28,500
web app namespace this is just an

00:22:26,760 --> 00:22:30,180
example but as you can see you can

00:22:28,500 --> 00:22:32,190
really get as specific or general with

00:22:30,180 --> 00:22:34,320
routing keys and celery configurations

00:22:32,190 --> 00:22:37,860
as you like depending on what your

00:22:34,320 --> 00:22:39,870
environment needs and also one thing to

00:22:37,860 --> 00:22:42,540
note even though we do instantiate a

00:22:39,870 --> 00:22:44,790
queue object here the library combooo

00:22:42,540 --> 00:22:47,310
creates the binding between the queue in

00:22:44,790 --> 00:22:48,690
the exchange specified in the args so we

00:22:47,310 --> 00:22:52,740
don't have to worry about explicitly

00:22:48,690 --> 00:22:54,920
declaring them here's what the new

00:22:52,740 --> 00:22:58,080
configuration code looks like altogether

00:22:54,920 --> 00:23:01,170
as you can see we have our new smart

00:22:58,080 --> 00:23:03,900
topic exchange our new celery router now

00:23:01,170 --> 00:23:05,400
on the producer and r2 queues with the

00:23:03,900 --> 00:23:10,080
appropriate bindings to this new

00:23:05,400 --> 00:23:12,240
exchange that we made another difference

00:23:10,080 --> 00:23:14,220
in this example is that we need to run

00:23:12,240 --> 00:23:17,460
two separate worker processes instead of

00:23:14,220 --> 00:23:18,809
one we assign one worker to read off the

00:23:17,460 --> 00:23:20,399
webapp q2

00:23:18,809 --> 00:23:22,440
guarantee that there is at least one

00:23:20,399 --> 00:23:25,259
worker available for running small tasks

00:23:22,440 --> 00:23:27,509
the second worker is listening to both

00:23:25,259 --> 00:23:29,220
cues which is the default behavior and

00:23:27,509 --> 00:23:32,909
the configuration that we used in the

00:23:29,220 --> 00:23:34,950
previous example since we can specify

00:23:32,909 --> 00:23:37,620
the number of threads for each worker

00:23:34,950 --> 00:23:39,509
we can still use 4 threads like we did

00:23:37,620 --> 00:23:42,659
before but now we're just allocating

00:23:39,509 --> 00:23:44,639
them to do different jobs in practice

00:23:42,659 --> 00:23:47,039
again you can run different processes on

00:23:44,639 --> 00:23:48,749
different machines as well allocating

00:23:47,039 --> 00:23:51,179
more powerful workers to run our fitting

00:23:48,749 --> 00:24:00,210
jobs and smaller workers to run simpler

00:23:51,179 --> 00:24:02,039
tasks so now let's see this in action so

00:24:00,210 --> 00:24:03,840
now we have two salary workers starting

00:24:02,039 --> 00:24:05,369
and all of our queries are running and

00:24:03,840 --> 00:24:07,679
we're fitting neural nets all at the

00:24:05,369 --> 00:24:17,220
same time and everybody's happy our data

00:24:07,679 --> 00:24:18,690
scientists in our clients one obvious

00:24:17,220 --> 00:24:20,549
downside of this is that you only

00:24:18,690 --> 00:24:23,369
dedicate three threads to finding neural

00:24:20,549 --> 00:24:24,960
nets instead of form so it does take you

00:24:23,369 --> 00:24:27,899
longer to run all of your fitting work

00:24:24,960 --> 00:24:29,700
than before but as we all know computer

00:24:27,899 --> 00:24:31,499
science is full of such trade-offs and

00:24:29,700 --> 00:24:34,159
you need to figure out what's important

00:24:31,499 --> 00:24:38,249
to optimize on in your particular case

00:24:34,159 --> 00:24:39,509
in these last few minutes I will go over

00:24:38,249 --> 00:24:41,419
some of the gotchas that I have

00:24:39,509 --> 00:24:43,200
encountered while working with RabbitMQ

00:24:41,419 --> 00:24:45,509
this isn't meant to be an

00:24:43,200 --> 00:24:46,980
all-encompassing list but it's more to

00:24:45,509 --> 00:24:51,119
demonstrate a few problems that I have

00:24:46,980 --> 00:24:52,799
encountered in the past personally what

00:24:51,119 --> 00:24:57,090
if your message doesn't get routed to a

00:24:52,799 --> 00:24:59,220
queue at all one of the biggest risks in

00:24:57,090 --> 00:25:02,009
this new configuration is that a message

00:24:59,220 --> 00:25:04,139
simply never reaches a queue this is

00:25:02,009 --> 00:25:07,080
because RabbitMQ does not guarantee that

00:25:04,139 --> 00:25:10,379
a message sent to an exchange will have

00:25:07,080 --> 00:25:12,210
a matching binding while RabbitMQ will

00:25:10,379 --> 00:25:15,360
log this as a warning on the broker a

00:25:12,210 --> 00:25:17,460
badly routed or drop message can cascade

00:25:15,360 --> 00:25:22,499
into some fairly large and hard to debug

00:25:17,460 --> 00:25:24,269
problems trust me on this one one

00:25:22,499 --> 00:25:26,850
solution that I found is to use an

00:25:24,269 --> 00:25:28,950
alternate exchange this feature is

00:25:26,850 --> 00:25:30,389
actually a rabbitmq plugin that ships

00:25:28,950 --> 00:25:32,160
with the standard installation of the

00:25:30,389 --> 00:25:34,200
broker

00:25:32,160 --> 00:25:36,630
all in alternate exchange does is

00:25:34,200 --> 00:25:40,440
reroute any unrouted messages from one

00:25:36,630 --> 00:25:42,750
exchange to another to implement this

00:25:40,440 --> 00:25:45,450
all we need to do is add the alternate

00:25:42,750 --> 00:25:47,190
exchange property to a new exchange with

00:25:45,450 --> 00:25:51,210
the value being the name of the fallback

00:25:47,190 --> 00:25:53,190
exchange so now any message that doesn't

00:25:51,210 --> 00:25:54,570
get routed by the new exchange will

00:25:53,190 --> 00:25:56,880
automatically get routed to the

00:25:54,570 --> 00:26:00,420
alternate exchange which uses its own

00:25:56,880 --> 00:26:02,040
set of bindings to queues the message

00:26:00,420 --> 00:26:04,140
will then get routed based on those

00:26:02,040 --> 00:26:08,700
bindings and the alternate exchanges

00:26:04,140 --> 00:26:11,910
type don't forget to actually declare

00:26:08,700 --> 00:26:14,070
your alternate exchange and also bind it

00:26:11,910 --> 00:26:15,900
to a queue that some workers listening

00:26:14,070 --> 00:26:17,640
to otherwise you just end up with the

00:26:15,900 --> 00:26:20,430
same problem but now on your alternate

00:26:17,640 --> 00:26:22,290
exchange I don't have time to walk

00:26:20,430 --> 00:26:23,940
through a full demo of this but I do

00:26:22,290 --> 00:26:26,700
have an example of how to use it in

00:26:23,940 --> 00:26:30,990
practice on github in the AE example dot

00:26:26,700 --> 00:26:33,600
PI file another thing to watch out for

00:26:30,990 --> 00:26:35,730
is that rabbitmq objects are immutable

00:26:33,600 --> 00:26:38,220
and cannot be changed once they've been

00:26:35,730 --> 00:26:39,990
declared this can be a benefit when

00:26:38,220 --> 00:26:41,940
writing code that talks to RabbitMQ

00:26:39,990 --> 00:26:44,120
because you can read eclair a queue or

00:26:41,940 --> 00:26:46,140
exchange as many times as you want

00:26:44,120 --> 00:26:49,710
knowing that a duplicate won't be

00:26:46,140 --> 00:26:52,170
created however this can cause problems

00:26:49,710 --> 00:26:55,590
if you change a property in code while

00:26:52,170 --> 00:26:57,540
read eclair an object if any property of

00:26:55,590 --> 00:26:59,700
your new object does not match the

00:26:57,540 --> 00:27:02,160
property of the existing objects on the

00:26:59,700 --> 00:27:03,060
broker RabbitMQ will return an

00:27:02,160 --> 00:27:05,280
inequivalent arg

00:27:03,060 --> 00:27:07,430
error and the software library you're

00:27:05,280 --> 00:27:09,840
using will probably raise an exception

00:27:07,430 --> 00:27:12,150
to change properties on an existing

00:27:09,840 --> 00:27:14,340
object you must first delete the object

00:27:12,150 --> 00:27:19,050
and then declare it with the properties

00:27:14,340 --> 00:27:22,110
that you wanted to have another problem

00:27:19,050 --> 00:27:24,480
we had is managing complexity with

00:27:22,110 --> 00:27:27,300
multiple exchanges queues and bindings

00:27:24,480 --> 00:27:30,990
our system grew fairly complex very

00:27:27,300 --> 00:27:33,270
quickly as tasks namespaces changed with

00:27:30,990 --> 00:27:36,000
more refactoring imports needed to be

00:27:33,270 --> 00:27:38,400
updated on the workers as we added more

00:27:36,000 --> 00:27:40,860
queues and exchanges we needed to update

00:27:38,400 --> 00:27:42,960
the commands that launched them that

00:27:40,860 --> 00:27:45,779
launched our workers to reflect the new

00:27:42,960 --> 00:27:47,340
desired behaviors and routings as

00:27:45,779 --> 00:27:48,629
really tricky problem and honestly I'd

00:27:47,340 --> 00:27:50,190
love to hear your thoughts if you want

00:27:48,629 --> 00:27:53,940
to discuss this after the talk I'll be

00:27:50,190 --> 00:27:55,529
right out there somewhere some ideas

00:27:53,940 --> 00:27:57,509
that I've thought of are using meta

00:27:55,529 --> 00:27:59,999
programming to generate a celery config

00:27:57,509 --> 00:28:02,700
file based on some persistent data that

00:27:59,999 --> 00:28:04,649
describes your infrastructure or using

00:28:02,700 --> 00:28:06,539
more advanced routing functions that

00:28:04,649 --> 00:28:11,249
return routing keys other than a tasks

00:28:06,539 --> 00:28:12,929
fully qualified name so in conclusion I

00:28:11,249 --> 00:28:16,080
hope that you now have an understanding

00:28:12,929 --> 00:28:18,570
of what RabbitMQ is how it works and how

00:28:16,080 --> 00:28:19,679
to interact with it while working in the

00:28:18,570 --> 00:28:22,289
Python ecosystem

00:28:19,679 --> 00:28:24,239
I want to implore that RabbitMQ is much

00:28:22,289 --> 00:28:26,309
more than a message transport for celery

00:28:24,239 --> 00:28:28,799
and can be used in a variety of creative

00:28:26,309 --> 00:28:31,049
ways wherever some sort of inter process

00:28:28,799 --> 00:28:33,839
or inter application messaging is

00:28:31,049 --> 00:28:36,780
required and I will end with some

00:28:33,839 --> 00:28:45,080
pictures of my dog thank you

00:28:36,780 --> 00:28:46,980
[Applause]

00:28:45,080 --> 00:28:49,800
even's going to be available for

00:28:46,980 --> 00:28:51,480
questions outside or offline let's all

00:28:49,800 --> 00:28:57,910
give him another round of applause

00:28:51,480 --> 00:28:57,910

YouTube URL: https://www.youtube.com/watch?v=WXkhJ92-fsY


