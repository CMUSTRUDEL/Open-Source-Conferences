Title: Claudio Freire - Efficient shared memory data structures - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Claudio Freire

Multithreading makes shared memory easy, but true parallelism next to impossible. Multiprocessing gives us true parallelism, but it makes sharing memory very difficult, and high overhead. In this talk, we'll explore techniques to share memory between processes efficiently, with a focus on sharing read-only massive data structures.

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:03,770 --> 00:00:07,919
welcome everybody

00:00:06,089 --> 00:00:11,639
our first speaker for this afternoon

00:00:07,919 --> 00:00:13,860
session is Claudio Freire he is coming

00:00:11,639 --> 00:00:16,020
to us from Argentina he's a frequent

00:00:13,860 --> 00:00:19,050
speaker at PyCon Argentina and this is

00:00:16,020 --> 00:00:20,620
his first time I had Pike on us so

00:00:19,050 --> 00:00:21,180
please give him a warm welcome

00:00:20,620 --> 00:00:24,280
[Applause]

00:00:21,180 --> 00:00:24,280
[Music]

00:00:25,160 --> 00:00:30,779
hey there well thanks for the

00:00:29,880 --> 00:00:34,800
introduction

00:00:30,779 --> 00:00:42,620
maybe this lights great okay so this is

00:00:34,800 --> 00:00:46,620
kind of redundant first how are you like

00:00:42,620 --> 00:00:50,670
hey great so we're here to talk about

00:00:46,620 --> 00:00:53,390
Python of course it's app icon and I

00:00:50,670 --> 00:00:59,520
would like to talk about sharing stuff

00:00:53,390 --> 00:01:02,430
mostly memory so if you have ever tried

00:00:59,520 --> 00:01:07,260
sharing stuff like CPU or whatever with

00:01:02,430 --> 00:01:11,850
Python you might feel like that right

00:01:07,260 --> 00:01:16,890
I mean Python doesn't make it easy like

00:01:11,850 --> 00:01:18,630
yield basically this the way we in

00:01:16,890 --> 00:01:21,630
threading doesn't let us really use

00:01:18,630 --> 00:01:24,540
multiple CPUs makes us need multi

00:01:21,630 --> 00:01:27,840
processing and we cannot share objects

00:01:24,540 --> 00:01:30,119
if we do multi processing so I'm glad to

00:01:27,840 --> 00:01:32,490
talk why I wanted to share memory

00:01:30,119 --> 00:01:34,890
because there are many reasons some

00:01:32,490 --> 00:01:36,869
people ask why why do I need to share

00:01:34,890 --> 00:01:40,829
memory I mean I know you don't because

00:01:36,869 --> 00:01:44,460
you're here but some people do wonder

00:01:40,829 --> 00:01:47,340
why would I need to do that so for me

00:01:44,460 --> 00:01:50,670
was because well I had lots of cash

00:01:47,340 --> 00:01:54,090
crashing in caches you know dictionaries

00:01:50,670 --> 00:01:57,450
with cache stuff and I couldn't feed

00:01:54,090 --> 00:02:00,090
them several times once per processor so

00:01:57,450 --> 00:02:04,320
I mean they could fit all in memory once

00:02:00,090 --> 00:02:07,320
but not 30 times so for me that was the

00:02:04,320 --> 00:02:09,119
motivation also another motivation that

00:02:07,320 --> 00:02:12,750
happened that appeared later when I had

00:02:09,119 --> 00:02:13,710
the the the means to share memory was

00:02:12,750 --> 00:02:16,080
like

00:02:13,710 --> 00:02:18,960
okay now all that I can I have this huge

00:02:16,080 --> 00:02:21,000
data set it doesn't fit in memory but I

00:02:18,960 --> 00:02:23,220
know I won't be accessing all of it

00:02:21,000 --> 00:02:26,070
so maybe the operating system can do the

00:02:23,220 --> 00:02:28,260
swapping magic and you know do I owe for

00:02:26,070 --> 00:02:32,010
me and I don't need to do I owe so

00:02:28,260 --> 00:02:34,080
that's one it also happens sometimes

00:02:32,010 --> 00:02:35,970
that yeah you can talk to a database you

00:02:34,080 --> 00:02:38,550
can talk to memcache you can do other

00:02:35,970 --> 00:02:40,680
stuff on it's okay you can work like

00:02:38,550 --> 00:02:45,390
that but serialization it's a

00:02:40,680 --> 00:02:47,940
right I mean you it consumes CPU it it's

00:02:45,390 --> 00:02:52,760
really tricky to make everything pick up

00:02:47,940 --> 00:02:55,920
big bubble so that's another motivation

00:02:52,760 --> 00:02:57,930
so how do we make this transition to

00:02:55,920 --> 00:02:59,790
share memory which I call shared buffers

00:02:57,930 --> 00:03:01,800
because I don't know why not you know I

00:02:59,790 --> 00:03:03,270
do a lot of Postgres and Postgres calls

00:03:01,800 --> 00:03:08,340
it to share about reso maybe that's

00:03:03,270 --> 00:03:12,660
that's why I called it like that well

00:03:08,340 --> 00:03:15,600
for the caching architecture which is

00:03:12,660 --> 00:03:19,680
what I'm familiar with the trick was to

00:03:15,600 --> 00:03:22,680
have have it all the information divided

00:03:19,680 --> 00:03:24,630
into you have the part of the data that

00:03:22,680 --> 00:03:28,980
doesn't change much because if you have

00:03:24,630 --> 00:03:30,420
like 50 gigabytes of data it's possible

00:03:28,980 --> 00:03:33,090
that it doesn't change all the time you

00:03:30,420 --> 00:03:35,460
know it's hard to make 50 gigabytes of

00:03:33,090 --> 00:03:37,620
information change all the time

00:03:35,460 --> 00:03:40,380
so we you will have a read-only layer

00:03:37,620 --> 00:03:43,710
for the sub that doesn't change and then

00:03:40,380 --> 00:03:46,260
something else for the stuff that does

00:03:43,710 --> 00:03:48,210
change often so I call that you know a

00:03:46,260 --> 00:03:50,580
read/write read-only layer the read-only

00:03:48,210 --> 00:03:54,210
layer is gonna be the stuff that we can

00:03:50,580 --> 00:03:56,610
easily share in memory the trick is that

00:03:54,210 --> 00:04:02,340
the read-only layer should be rather big

00:03:56,610 --> 00:04:04,530
compared to the read/write layer so some

00:04:02,340 --> 00:04:05,790
somebody asked why not use multi

00:04:04,530 --> 00:04:07,590
processing stuff you know multi

00:04:05,790 --> 00:04:10,170
processing keeps us shared c-types it

00:04:07,590 --> 00:04:14,210
gives us shared erase stuff like that

00:04:10,170 --> 00:04:17,460
well in my opinion first my experience

00:04:14,210 --> 00:04:19,500
using that for for writable stuff

00:04:17,460 --> 00:04:22,800
creates lots of lock contention I mean

00:04:19,500 --> 00:04:24,660
it becomes slow but also it's really

00:04:22,800 --> 00:04:27,240
difficult to use those primitives to put

00:04:24,660 --> 00:04:29,910
objects in shared memory

00:04:27,240 --> 00:04:34,650
I mean if you've ever tried who has ever

00:04:29,910 --> 00:04:38,970
tried that nice not many people I see

00:04:34,650 --> 00:04:41,759
but you know it's stuff and there's this

00:04:38,970 --> 00:04:45,539
little quote that I really love from the

00:04:41,759 --> 00:04:47,699
documentation even though you can put

00:04:45,539 --> 00:04:50,400
pointers I mean pointers are the basis

00:04:47,699 --> 00:04:52,139
of all complex data structures right so

00:04:50,400 --> 00:04:53,280
if you can't you can put pointers in

00:04:52,139 --> 00:04:59,669
shared memory but then your application

00:04:53,280 --> 00:05:02,009
will crash so yeah great so I want the

00:04:59,669 --> 00:05:04,440
best of both worlds I want to do multi

00:05:02,009 --> 00:05:06,060
processing I want to have cash I don't

00:05:04,440 --> 00:05:09,900
want to waste memory copying stuff and

00:05:06,060 --> 00:05:13,259
times so I do I divide like I said I

00:05:09,900 --> 00:05:15,479
divide everything in to first buffer

00:05:13,259 --> 00:05:17,250
that will be encoded as I'm all the

00:05:15,479 --> 00:05:17,880
whole talk was going to be about that so

00:05:17,250 --> 00:05:23,849
we'll see

00:05:17,880 --> 00:05:28,590
and then the read/write layer for me was

00:05:23,849 --> 00:05:31,469
the the the processes memory or a

00:05:28,590 --> 00:05:39,210
memcache server somewhere it's gonna be

00:05:31,469 --> 00:05:42,960
a little slower but it works the shared

00:05:39,210 --> 00:05:46,190
part is quite simple in fact because

00:05:42,960 --> 00:05:49,740
there's a very easy way to share stuff

00:05:46,190 --> 00:05:53,880
through memory mapped files I mean who

00:05:49,740 --> 00:05:56,909
gets what that is here not many okay for

00:05:53,880 --> 00:06:00,870
those who didn't raise their hands maybe

00:05:56,909 --> 00:06:02,789
you're asleep and that's why but but you

00:06:00,870 --> 00:06:05,099
can even have a file that has lots of

00:06:02,789 --> 00:06:08,909
data in it you can call a library that's

00:06:05,099 --> 00:06:12,840
called mem up mm up well it's hard to

00:06:08,909 --> 00:06:14,909
read but it's mmmm up and tell okay put

00:06:12,840 --> 00:06:17,340
this file in memory and give me all

00:06:14,909 --> 00:06:19,440
those bytes and the nice thing about

00:06:17,340 --> 00:06:21,990
this is that the kernel the operating

00:06:19,440 --> 00:06:24,300
system knows that if you have several

00:06:21,990 --> 00:06:27,690
processes doing this on the same file it

00:06:24,300 --> 00:06:30,120
won't have any copies of the other

00:06:27,690 --> 00:06:32,490
memory it will just use the same memory

00:06:30,120 --> 00:06:35,610
for that for those contents especially

00:06:32,490 --> 00:06:36,990
if all you do is read if you write it

00:06:35,610 --> 00:06:38,940
will have to copy because you know

00:06:36,990 --> 00:06:41,129
otherwise you'd be changing someone

00:06:38,940 --> 00:06:43,289
else's memory but you can't tell it

00:06:41,129 --> 00:06:48,779
not to copy so then you can share it

00:06:43,289 --> 00:06:50,279
stuff on right but how do you put

00:06:48,779 --> 00:06:53,969
objects in there right now

00:06:50,279 --> 00:06:56,249
that's what we want and mem map gives us

00:06:53,969 --> 00:06:59,759
bytes which is something but we want to

00:06:56,249 --> 00:07:02,219
put objects there so the trick is of

00:06:59,759 --> 00:07:04,800
course defined in a schema some like a

00:07:02,219 --> 00:07:08,939
shape the data will have the schema has

00:07:04,800 --> 00:07:11,639
to be easier easily manipulatable if

00:07:08,939 --> 00:07:15,179
that's a word that you have to be it has

00:07:11,639 --> 00:07:17,610
to be easy to read right and it has to

00:07:15,179 --> 00:07:20,069
be efficient I don't want it to be huge

00:07:17,610 --> 00:07:25,589
right I want an integer to be like four

00:07:20,069 --> 00:07:27,599
bytes pretty much ideally and I need the

00:07:25,589 --> 00:07:29,879
machinery to do all that in a pythonic

00:07:27,599 --> 00:07:36,329
way I don't want to work with protobuf

00:07:29,879 --> 00:07:38,969
sorry so basically the trick I found

00:07:36,329 --> 00:07:41,849
everybody will think about this like ok

00:07:38,969 --> 00:07:45,179
to manipulate bytes into structured data

00:07:41,849 --> 00:07:47,519
we have struct and proxies lets us you

00:07:45,179 --> 00:07:50,509
know shape other stuff and make it look

00:07:47,519 --> 00:07:57,719
pythonic so we'll do that

00:07:50,509 --> 00:07:59,969
no biggie if my remote works okay so we

00:07:57,719 --> 00:08:02,639
stripped it's rather simple you know

00:07:59,969 --> 00:08:05,419
import struct back and pack all the

00:08:02,639 --> 00:08:08,699
stuff you probably already know but

00:08:05,419 --> 00:08:11,309
that's kind of inconvenient you know in

00:08:08,699 --> 00:08:14,309
C I know this is Python you don't want

00:08:11,309 --> 00:08:16,529
to hear about C but in C I just can't

00:08:14,309 --> 00:08:19,979
define this struct and do you know point

00:08:16,529 --> 00:08:21,569
a dot a dot B that's C and just use it I

00:08:19,979 --> 00:08:24,629
don't know I don't have to go around

00:08:21,569 --> 00:08:30,749
packing and unpacking so that's what I

00:08:24,629 --> 00:08:33,389
want to do but I don't have C right so

00:08:30,749 --> 00:08:35,159
why do we get C into this well there are

00:08:33,389 --> 00:08:39,089
many reasons why we don't want to think

00:08:35,159 --> 00:08:42,149
in C terms first c structs are very very

00:08:39,089 --> 00:08:45,149
portable like lots of languages most of

00:08:42,149 --> 00:08:48,300
them really need to work with districts

00:08:45,149 --> 00:08:52,490
so they support some way of parsing them

00:08:48,300 --> 00:08:54,630
while passing them reading them all so

00:08:52,490 --> 00:08:57,360
if I can get sick

00:08:54,630 --> 00:09:00,330
cold in there somehow because the Python

00:08:57,360 --> 00:09:03,000
is written in C why not I will be able

00:09:00,330 --> 00:09:04,890
to access that data natively I don't

00:09:03,000 --> 00:09:06,330
need to serialize her this year there's

00:09:04,890 --> 00:09:10,020
anything you know it you can't just work

00:09:06,330 --> 00:09:13,920
with that information and because we can

00:09:10,020 --> 00:09:16,500
write Python I mean we can write C as if

00:09:13,920 --> 00:09:21,960
it were Python with seitan so that's

00:09:16,500 --> 00:09:24,270
what I do it's not trivial I mean the

00:09:21,960 --> 00:09:29,040
Python you're right reads more like C

00:09:24,270 --> 00:09:30,780
than Python but ok it's what we got but

00:09:29,040 --> 00:09:32,570
we end up with something really pythonic

00:09:30,780 --> 00:09:34,080
from the outside don't look inside that

00:09:32,570 --> 00:09:37,500
looks like this

00:09:34,080 --> 00:09:40,860
right it's really nice if you can do

00:09:37,500 --> 00:09:43,590
this basically the proxies let us look

00:09:40,860 --> 00:09:45,780
at the shared buffer as if it contained

00:09:43,590 --> 00:09:50,330
objects do you have to tell it where the

00:09:45,780 --> 00:09:55,050
object is and you do dot a to get the a

00:09:50,330 --> 00:09:57,000
dot B to get the B and in no no place

00:09:55,050 --> 00:09:59,010
you're like really serializing stuff

00:09:57,000 --> 00:10:00,720
you're not just reading the whole buffer

00:09:59,010 --> 00:10:04,770
and lo they need to memory because

00:10:00,720 --> 00:10:05,940
that's pointless so this is the thing

00:10:04,770 --> 00:10:09,690
but how do we do this

00:10:05,940 --> 00:10:11,400
right oh the benefit of doing this is

00:10:09,690 --> 00:10:13,050
like I said it doesn't require some

00:10:11,400 --> 00:10:15,830
realization because you go where you

00:10:13,050 --> 00:10:19,800
need to when you access that information

00:10:15,830 --> 00:10:22,260
also if you go back we can change the

00:10:19,800 --> 00:10:24,360
offset really simply right that proxy

00:10:22,260 --> 00:10:25,830
has an offset inside if I want to point

00:10:24,360 --> 00:10:29,910
in another object I just change the

00:10:25,830 --> 00:10:31,890
offset and that's it and so I don't have

00:10:29,910 --> 00:10:33,870
to create Python objects to work with

00:10:31,890 --> 00:10:36,120
the shared memory which would defeat the

00:10:33,870 --> 00:10:37,620
purpose of sharing the memory because

00:10:36,120 --> 00:10:41,730
you know Python objects are not

00:10:37,620 --> 00:10:44,070
shareable and thanks to doc typing you

00:10:41,730 --> 00:10:46,560
know proxies actually quack like

00:10:44,070 --> 00:10:48,780
whatever their proxy so they look like

00:10:46,560 --> 00:10:50,310
whatever their approximate for the for

00:10:48,780 --> 00:10:53,190
the other code so I can use them in

00:10:50,310 --> 00:10:58,890
place of the original object usually and

00:10:53,190 --> 00:11:02,370
it just works now how do we do this well

00:10:58,890 --> 00:11:04,560
in C I would like a proxy to the the

00:11:02,370 --> 00:11:06,360
object in the buffer to have a shape

00:11:04,560 --> 00:11:08,579
like this if I want to put an object

00:11:06,360 --> 00:11:11,489
imagine and know that Reno

00:11:08,579 --> 00:11:13,499
there has a value left and right right

00:11:11,489 --> 00:11:15,809
the left is a pointer actually a

00:11:13,499 --> 00:11:18,869
reference to another node right if

00:11:15,809 --> 00:11:21,119
another reference to another node we

00:11:18,869 --> 00:11:23,639
know how to encode in the buffer the

00:11:21,119 --> 00:11:25,619
three we struct we and call it as an

00:11:23,639 --> 00:11:27,360
integer three that's easy but how do we

00:11:25,619 --> 00:11:31,369
encode the reference to other objects

00:11:27,360 --> 00:11:36,389
well there are many ways of doing this I

00:11:31,369 --> 00:11:39,149
found that the the most convenient way

00:11:36,389 --> 00:11:41,339
was to use another integer to hold a

00:11:39,149 --> 00:11:43,230
relative pointer basically I hold the

00:11:41,339 --> 00:11:45,540
offset where that other object will be

00:11:43,230 --> 00:11:47,999
relative to the upset that's containing

00:11:45,540 --> 00:11:50,249
the reference making it relative make it

00:11:47,999 --> 00:11:53,929
makes it able to move around easily

00:11:50,249 --> 00:12:00,889
without having to rewrite all pointers

00:11:53,929 --> 00:12:04,259
so we can easily write code that

00:12:00,889 --> 00:12:09,269
interprets all this and makes it nice

00:12:04,259 --> 00:12:12,299
for the outside world if you work with

00:12:09,269 --> 00:12:14,489
properties you will get that code maybe

00:12:12,299 --> 00:12:17,519
it's a little bit ugly but you know how

00:12:14,489 --> 00:12:19,439
to fit on the slides but if you don't

00:12:17,519 --> 00:12:21,959
basically property is an object that

00:12:19,439 --> 00:12:25,230
when you assign it to to a field on a

00:12:21,959 --> 00:12:27,660
class it tells Python to actually invoke

00:12:25,230 --> 00:12:30,360
code when you access that property that

00:12:27,660 --> 00:12:31,079
attribute instead of really natural an

00:12:30,360 --> 00:12:33,720
attribute

00:12:31,079 --> 00:12:35,669
so basically when I do with that proxy

00:12:33,720 --> 00:12:39,869
when I have an instance of complex proxy

00:12:35,669 --> 00:12:42,839
if I do instance dot a you will invoke

00:12:39,869 --> 00:12:45,569
the get method in in property and that

00:12:42,839 --> 00:12:48,929
method will go and reach into the object

00:12:45,569 --> 00:12:51,299
and unpack the integer there this

00:12:48,929 --> 00:12:55,290
doesn't look very efficient but it can

00:12:51,299 --> 00:12:57,720
be made efficient with site on with the

00:12:55,290 --> 00:12:59,819
with the object references it's a little

00:12:57,720 --> 00:13:02,730
bit more involved but not that much

00:12:59,819 --> 00:13:04,769
basically I just unpack the relative

00:13:02,730 --> 00:13:07,589
pointer I had computed where there

00:13:04,769 --> 00:13:11,220
really the real object is by you know

00:13:07,589 --> 00:13:13,230
adding offsets and I build another proxy

00:13:11,220 --> 00:13:15,959
to that other object I just build the

00:13:13,230 --> 00:13:18,119
proxy I don't do anything else so it's

00:13:15,959 --> 00:13:20,399
efficient I mean the other object could

00:13:18,119 --> 00:13:21,379
be huge but I don't care because I'm

00:13:20,399 --> 00:13:27,499
just building a

00:13:21,379 --> 00:13:29,059
see so this looks very nice like few

00:13:27,499 --> 00:13:32,179
lines of code and you have everything

00:13:29,059 --> 00:13:34,099
looks like magic but when you get to it

00:13:32,179 --> 00:13:35,899
when you start walking on it you realize

00:13:34,099 --> 00:13:37,970
there are some caveats like for instance

00:13:35,899 --> 00:13:39,829
when you have complex data structures

00:13:37,970 --> 00:13:44,269
you end up with cyclic references and

00:13:39,829 --> 00:13:47,659
they are tough because they then you you

00:13:44,269 --> 00:13:49,429
never stop building your your buffer you

00:13:47,659 --> 00:13:51,259
try to try to build your buffer your

00:13:49,429 --> 00:13:52,819
file you start writing okay this object

00:13:51,259 --> 00:13:54,879
this object this object o this object

00:13:52,819 --> 00:13:57,019
contains another object so you write it

00:13:54,879 --> 00:13:59,029
okay this one consists another work

00:13:57,019 --> 00:14:00,799
object so you write it but that other

00:13:59,029 --> 00:14:02,449
object was the first object but you

00:14:00,799 --> 00:14:04,369
don't realize so you start on the loop

00:14:02,449 --> 00:14:06,649
infinite loop never finish then your

00:14:04,369 --> 00:14:10,399
computer runs out of disk and everything

00:14:06,649 --> 00:14:13,609
goes to hell so you have to be careful

00:14:10,399 --> 00:14:17,599
with that this tricks to do that or you

00:14:13,609 --> 00:14:19,369
can just say oh it I don't want

00:14:17,599 --> 00:14:21,499
cyclic references if you do cycling

00:14:19,369 --> 00:14:24,229
references my library doesn't support it

00:14:21,499 --> 00:14:26,329
just that's an option if you're not

00:14:24,229 --> 00:14:28,850
using data structure which is striking

00:14:26,329 --> 00:14:34,759
cyclic references good for you but I I

00:14:28,850 --> 00:14:37,489
am so I solve it so a way to solve it

00:14:34,759 --> 00:14:41,600
that's very nice I'm sure they're level

00:14:37,489 --> 00:14:44,749
otherwise but is to have an ID map an ID

00:14:41,600 --> 00:14:46,939
map basically Maps the address of the

00:14:44,749 --> 00:14:51,079
object an identifier of the object to

00:14:46,939 --> 00:14:53,299
them all the time trying to serialize to

00:14:51,079 --> 00:14:55,069
the offset so when I'm writing objects

00:14:53,299 --> 00:14:59,029
like I said if I find an object I

00:14:55,069 --> 00:15:01,100
already wrote I just put the the offset

00:14:59,029 --> 00:15:03,350
and don't write the contents so that

00:15:01,100 --> 00:15:07,129
breaks the cycle and it even makes the

00:15:03,350 --> 00:15:09,049
file smaller so there are tricky points

00:15:07,129 --> 00:15:11,139
I'm not going to go into much detail

00:15:09,049 --> 00:15:14,899
with something running short on time but

00:15:11,139 --> 00:15:17,929
pretty much the identity map has an

00:15:14,899 --> 00:15:19,489
issue that if you delete you destroy

00:15:17,929 --> 00:15:22,159
objects in memory you have to make sure

00:15:19,489 --> 00:15:23,869
to also destroy them from the and remove

00:15:22,159 --> 00:15:26,829
them from the editing bump or you get

00:15:23,869 --> 00:15:30,019
trouble and also you can get rather big

00:15:26,829 --> 00:15:31,819
at this point you're thinking okay this

00:15:30,019 --> 00:15:33,829
guy was talking about no serialization

00:15:31,819 --> 00:15:36,720
why is he talking about basically what

00:15:33,829 --> 00:15:40,290
amounts to sterilizing here

00:15:36,720 --> 00:15:44,290
because what I want to do is be able to

00:15:40,290 --> 00:15:49,300
read the file without sterilizing stuff

00:15:44,290 --> 00:15:52,510
I'm okay with making it an effort to

00:15:49,300 --> 00:15:52,960
write the file if you are not okay with

00:15:52,510 --> 00:15:55,510
that

00:15:52,960 --> 00:15:56,740
we can pick that too but I'm not going

00:15:55,510 --> 00:16:02,200
to talk about that because there's no

00:15:56,740 --> 00:16:07,060
time but it's possible so let's look at

00:16:02,200 --> 00:16:09,040
what objects look like inside first we

00:16:07,060 --> 00:16:10,870
have an attribute map basically not all

00:16:09,040 --> 00:16:12,010
attributes in all objects I mean if I

00:16:10,870 --> 00:16:13,780
have a schema it's not going to be

00:16:12,010 --> 00:16:15,550
perfect so some attributes won't be

00:16:13,780 --> 00:16:18,100
there some attributes will be none

00:16:15,550 --> 00:16:20,530
instead of an integer so that that's for

00:16:18,100 --> 00:16:22,510
that's why it's there then I'm gonna

00:16:20,530 --> 00:16:24,520
have the attributes that I defined in my

00:16:22,510 --> 00:16:26,230
schema the schema basically is the the

00:16:24,520 --> 00:16:30,070
properties when I define the property

00:16:26,230 --> 00:16:32,350
okay the integer is an offset 0 the left

00:16:30,070 --> 00:16:35,400
reference is enough to offset 4 and all

00:16:32,350 --> 00:16:38,020
that that's this came up pretty much so

00:16:35,400 --> 00:16:41,800
that's what I have here an integer

00:16:38,020 --> 00:16:44,410
absolute 0 on the object then another

00:16:41,800 --> 00:16:46,300
float in this case it's an example and

00:16:44,410 --> 00:16:47,890
then a reference to another object the

00:16:46,300 --> 00:16:51,970
reference is gonna be 8 bytes because I

00:16:47,890 --> 00:16:53,710
didn't know 64 bits why not so it's

00:16:51,970 --> 00:16:56,110
points somewhere it points not another

00:16:53,710 --> 00:16:59,530
offset that has a string a string is

00:16:56,110 --> 00:17:01,300
variable length so there it is a

00:16:59,530 --> 00:17:04,120
variable length string of course I'm

00:17:01,300 --> 00:17:06,970
gonna need not only the contents of the

00:17:04,120 --> 00:17:08,860
string I'm gonna need also the length of

00:17:06,970 --> 00:17:11,650
the string to be able to interpret that

00:17:08,860 --> 00:17:14,110
but it's gonna be a string there or I

00:17:11,650 --> 00:17:16,209
could have an object there right another

00:17:14,110 --> 00:17:18,280
object so basically the same structure

00:17:16,209 --> 00:17:20,170
that I had before I just repeat it there

00:17:18,280 --> 00:17:21,579
and it's the same thing I have a pointer

00:17:20,170 --> 00:17:24,400
to another object I mean a string it's

00:17:21,579 --> 00:17:26,110
an object so it's the same thing so I'm

00:17:24,400 --> 00:17:29,520
gonna have another attribute me bitmap

00:17:26,110 --> 00:17:32,410
an a B so I can have my tree like this

00:17:29,520 --> 00:17:34,240
but I don't know if it's a string or an

00:17:32,410 --> 00:17:36,130
object so I'm gonna want to add a type

00:17:34,240 --> 00:17:39,130
code something that does me what I have

00:17:36,130 --> 00:17:40,630
there right what do I have there so the

00:17:39,130 --> 00:17:42,310
type code is a little by that time is

00:17:40,630 --> 00:17:45,480
okay you have a string here you have an

00:17:42,310 --> 00:17:48,250
integer here you have blah whatever here

00:17:45,480 --> 00:17:48,760
nothing it's not rocket science right I

00:17:48,250 --> 00:17:53,440
mean

00:17:48,760 --> 00:17:58,240
whose loss at this point nobody oh okay

00:17:53,440 --> 00:18:00,580
I'm impressed so what about lists no I

00:17:58,240 --> 00:18:03,390
didn't talk about like complex stuff

00:18:00,580 --> 00:18:06,520
I mean objects are like the baby stuff

00:18:03,390 --> 00:18:08,440
so this are very simple you can imagine

00:18:06,520 --> 00:18:09,970
this as just objects with lots and lots

00:18:08,440 --> 00:18:13,090
of attributes that instead of active

00:18:09,970 --> 00:18:15,520
names they have indexes so and this is

00:18:13,090 --> 00:18:17,560
just a lot of pointers I'm gonna need to

00:18:15,520 --> 00:18:20,920
write the size of the list somewhere and

00:18:17,560 --> 00:18:22,870
then just index so the list of pointers

00:18:20,920 --> 00:18:29,800
I call it index why not I mean it makes

00:18:22,870 --> 00:18:31,840
sense and each item points to another

00:18:29,800 --> 00:18:33,820
object that could be an integer could be

00:18:31,840 --> 00:18:37,170
a string like we talked about or an

00:18:33,820 --> 00:18:40,650
object and I can write here right

00:18:37,170 --> 00:18:45,220
because I can reach into the buffer and

00:18:40,650 --> 00:18:48,850
change the integer here it's rather

00:18:45,220 --> 00:18:51,100
simple or I could reach into the index

00:18:48,850 --> 00:18:54,220
and change the pointer to point to

00:18:51,100 --> 00:18:56,140
another object I must like in this graph

00:18:54,220 --> 00:18:58,240
the object already existed in the buffer

00:18:56,140 --> 00:19:02,410
but if it didn't I can just put it

00:18:58,240 --> 00:19:04,750
somewhere and point to it so it's a

00:19:02,410 --> 00:19:07,150
dynamic structure I may not be able to

00:19:04,750 --> 00:19:08,440
add items easily to the list because

00:19:07,150 --> 00:19:11,170
otherwise I would have to move

00:19:08,440 --> 00:19:13,420
everything and it's quite a chore but I

00:19:11,170 --> 00:19:18,190
have a limited ability to modify the

00:19:13,420 --> 00:19:21,100
buffer what about maps dictionaries

00:19:18,190 --> 00:19:23,680
right we need to be able to you know

00:19:21,100 --> 00:19:27,340
have a addictive

00:19:23,680 --> 00:19:32,440
like I don't know an englis of phone

00:19:27,340 --> 00:19:34,480
numbers for someone so I like to use a

00:19:32,440 --> 00:19:35,980
term compound hash table but then you

00:19:34,480 --> 00:19:39,510
know there's a compact hostage a hash

00:19:35,980 --> 00:19:43,120
table in Python 3 and it's confusing so

00:19:39,510 --> 00:19:45,400
sorry but my compact has two hash tables

00:19:43,120 --> 00:19:48,280
are basically sort of the race of

00:19:45,400 --> 00:19:51,220
triplets with the hash key and the value

00:19:48,280 --> 00:19:54,310
so since they are sorted by hash and the

00:19:51,220 --> 00:19:56,740
hashes are meant to be uniform I have

00:19:54,310 --> 00:19:59,320
that I have a known distribution and now

00:19:56,740 --> 00:20:02,290
the keys are uniformly distributed so I

00:19:59,320 --> 00:20:02,559
can predict where an item will be just

00:20:02,290 --> 00:20:06,429
by

00:20:02,559 --> 00:20:09,370
computing the hash and then I can look

00:20:06,429 --> 00:20:12,129
at that place and maybe I will find the

00:20:09,370 --> 00:20:14,320
item or it's gonna be nearby so I'm

00:20:12,129 --> 00:20:18,460
gonna do it an exponential search and

00:20:14,320 --> 00:20:20,259
find the actual position so it's much

00:20:18,460 --> 00:20:23,769
more efficient than simply binary search

00:20:20,259 --> 00:20:26,830
I will show that a little bit later or I

00:20:23,769 --> 00:20:30,370
can even go even further I found it

00:20:26,830 --> 00:20:31,450
useful sometimes so to just drop all the

00:20:30,370 --> 00:20:33,549
keys because the kids were very

00:20:31,450 --> 00:20:34,840
redundant I told it in my case I found

00:20:33,549 --> 00:20:37,659
lots of cases where the keys are

00:20:34,840 --> 00:20:40,450
redundant I don't really need them I'm

00:20:37,659 --> 00:20:43,720
okay with hash collisions it's kind of

00:20:40,450 --> 00:20:47,139
like a bloom filter anybody heard heard

00:20:43,720 --> 00:20:49,539
of a bloom filter some people a few

00:20:47,139 --> 00:20:52,149
basically there are imperfect data

00:20:49,539 --> 00:20:54,460
structures that have some error so in my

00:20:52,149 --> 00:20:56,860
case I had a lot of use for this so you

00:20:54,460 --> 00:20:58,570
can make them smaller and more efficient

00:20:56,860 --> 00:21:01,299
because you don't have keys to worry

00:20:58,570 --> 00:21:03,519
about it's like a Compaq hash table

00:21:01,299 --> 00:21:06,610
perfect one without the approximation

00:21:03,519 --> 00:21:09,249
will look like this just an index like

00:21:06,610 --> 00:21:11,559
before lots of hashes keys and values

00:21:09,249 --> 00:21:12,909
keys and values would be pointers to an

00:21:11,559 --> 00:21:15,490
object that's a key and a knowledge of

00:21:12,909 --> 00:21:18,419
object of this value but the hashes are

00:21:15,490 --> 00:21:20,980
integers so I do a binary search there

00:21:18,419 --> 00:21:24,669
like in a concrete example if I'm

00:21:20,980 --> 00:21:29,139
looking for Bob Bob has hashed 7 and

00:21:24,669 --> 00:21:31,389
whoops okay Chloe also has hashed 7 it's

00:21:29,139 --> 00:21:33,279
okay I have the key so I'll go rich on

00:21:31,389 --> 00:21:36,940
the case and verify when they ask for

00:21:33,279 --> 00:21:40,659
Bob and I find find that V to the second

00:21:36,940 --> 00:21:43,179
value is what its value assigned to Bob

00:21:40,659 --> 00:21:46,299
and the same for Chloe it works it's not

00:21:43,179 --> 00:21:50,440
my fault but it works with a an

00:21:46,299 --> 00:21:53,559
approximate hash table I cannot know

00:21:50,440 --> 00:21:55,629
really which of the two values are meant

00:21:53,559 --> 00:21:57,610
for Bob on which have meant for Chloe so

00:21:55,629 --> 00:22:01,240
I just mash them together and I just

00:21:57,610 --> 00:22:03,669
return both of them may be useful for

00:22:01,240 --> 00:22:03,909
tea for you it was useful for me I don't

00:22:03,669 --> 00:22:08,889
know

00:22:03,909 --> 00:22:11,850
it's an idea let's I want to go a little

00:22:08,889 --> 00:22:13,960
bit into the details of this app

00:22:11,850 --> 00:22:16,330
optimized binary search because it's

00:22:13,960 --> 00:22:19,419
cool I mean we're here too

00:22:16,330 --> 00:22:21,880
here cool stuff so yeah I haven't found

00:22:19,419 --> 00:22:23,590
in the internet much reference to these

00:22:21,880 --> 00:22:27,220
kinds of algorithms although there are

00:22:23,590 --> 00:22:29,289
papers but we imagine we have an array

00:22:27,220 --> 00:22:31,450
sorted array like usual you would use

00:22:29,289 --> 00:22:33,429
binary search but you know the

00:22:31,450 --> 00:22:36,070
distribution of values in here you know

00:22:33,429 --> 00:22:39,640
they're uniform so if I'm looking for 56

00:22:36,070 --> 00:22:41,470
I know and it goes from zero to a

00:22:39,640 --> 00:22:45,309
hundred I know it's gonna be somewhere

00:22:41,470 --> 00:22:47,260
in the middle right so I predict is

00:22:45,309 --> 00:22:50,500
gonna be here but the distribution was

00:22:47,260 --> 00:22:52,330
in fact I mean I your eyes it was

00:22:50,500 --> 00:22:55,419
uniform but it was not perfectly uniform

00:22:52,330 --> 00:22:59,710
so when I go look it's a twenty seven oh

00:22:55,419 --> 00:23:02,409
well it sucks to be me but since it's

00:22:59,710 --> 00:23:04,840
twenty seven is less than 56 I know I'm

00:23:02,409 --> 00:23:07,600
the actual values on the right side so I

00:23:04,840 --> 00:23:11,350
move a little bit I check on the right

00:23:07,600 --> 00:23:14,830
side I get twenty nine I'm still way

00:23:11,350 --> 00:23:16,990
left so I move two spaces this time

00:23:14,830 --> 00:23:21,309
right that's an exponential search I

00:23:16,990 --> 00:23:23,649
move faster each step so now I have 45 I

00:23:21,309 --> 00:23:27,340
kind of have to keep moving and when I

00:23:23,649 --> 00:23:30,580
move four times I get 87 okay I have to

00:23:27,340 --> 00:23:33,490
talk right like I moved too far now I

00:23:30,580 --> 00:23:37,570
know the actual value if it's there it's

00:23:33,490 --> 00:23:39,820
between 45 and 87 so I just a binary

00:23:37,570 --> 00:23:43,840
search fight the actual value this is my

00:23:39,820 --> 00:23:49,149
upper bound and I find it so what's cool

00:23:43,840 --> 00:23:52,389
about this is that first you read the

00:23:49,149 --> 00:23:53,980
values around the actual position where

00:23:52,389 --> 00:23:57,730
your value is so it's actually very

00:23:53,980 --> 00:24:00,700
benign on the cache and on the way on

00:23:57,730 --> 00:24:02,649
the processor memory cache and all the

00:24:00,700 --> 00:24:05,139
disk cache if you have to do I offer

00:24:02,649 --> 00:24:06,700
this remember I said this data set could

00:24:05,139 --> 00:24:08,919
be bigger than my memory so the

00:24:06,700 --> 00:24:13,990
operating system will be swapping so

00:24:08,919 --> 00:24:18,130
that's IO so also if I have good

00:24:13,990 --> 00:24:20,230
predictions it's gonna be much faster

00:24:18,130 --> 00:24:23,380
than binary search because the actual

00:24:20,230 --> 00:24:26,860
cost of this you can prove it is to log

00:24:23,380 --> 00:24:28,630
the error so if they are small and it's

00:24:26,860 --> 00:24:30,160
going to be smaller than than the size

00:24:28,630 --> 00:24:34,270
of the array at least

00:24:30,160 --> 00:24:37,320
is gonna be faster and the approximate

00:24:34,270 --> 00:24:40,060
hash table is even better because it's

00:24:37,320 --> 00:24:41,890
it's constant size I mean there's no

00:24:40,060 --> 00:24:43,300
variable size thing I mean the keys are

00:24:41,890 --> 00:24:45,130
variable size I don't know how big

00:24:43,300 --> 00:24:46,780
they're gonna be but the approximate

00:24:45,130 --> 00:24:49,090
hash table has only integers so it's

00:24:46,780 --> 00:24:54,070
it's really a nice data structure to

00:24:49,090 --> 00:24:55,600
work with like I said this has the good

00:24:54,070 --> 00:24:56,230
thing that even if it doesn't fit in

00:24:55,600 --> 00:24:59,140
memory

00:24:56,230 --> 00:25:00,040
not even the active part I actually put

00:24:59,140 --> 00:25:02,860
this to the test

00:25:00,040 --> 00:25:05,080
and it's really efficient going to disk

00:25:02,860 --> 00:25:09,550
and even to rotational disks I mean you

00:25:05,080 --> 00:25:11,710
know rotating rust and since the index

00:25:09,550 --> 00:25:13,570
is small I can even preload it to memory

00:25:11,710 --> 00:25:16,270
it's more likely that the index will fit

00:25:13,570 --> 00:25:18,100
than the entire thing so I don't have to

00:25:16,270 --> 00:25:20,500
do the random i/o for the index search

00:25:18,100 --> 00:25:25,600
only for the value search so it's fun

00:25:20,500 --> 00:25:28,060
it's kind of like a data base and

00:25:25,600 --> 00:25:29,740
another way another thing I've been

00:25:28,060 --> 00:25:32,470
mentioning but let me mention it again

00:25:29,740 --> 00:25:34,150
if you want this to be really fast if

00:25:32,470 --> 00:25:36,280
you want attribute access to the process

00:25:34,150 --> 00:25:38,200
to be like attribute access to a real

00:25:36,280 --> 00:25:40,570
object you need to cite own eyes the

00:25:38,200 --> 00:25:42,040
properties because otherwise messing

00:25:40,570 --> 00:25:48,040
with stroke every time it's gonna be

00:25:42,040 --> 00:25:49,300
slow not terribly slow but slow even if

00:25:48,040 --> 00:25:51,280
you don't side own eyes you're not

00:25:49,300 --> 00:25:54,340
serializing the whole thing so it's not

00:25:51,280 --> 00:25:57,730
that bad and a trick I really like using

00:25:54,340 --> 00:25:59,410
is like I have a proxy sometimes I have

00:25:57,730 --> 00:26:01,300
to change the schema because I go from

00:25:59,410 --> 00:26:04,870
one object shape to another object shape

00:26:01,300 --> 00:26:06,790
okay an old references I don't know user

00:26:04,870 --> 00:26:09,550
so I need the the schema for the user

00:26:06,790 --> 00:26:11,590
now I don't need to create another proxy

00:26:09,550 --> 00:26:13,840
I can grab the proxy I haven't change

00:26:11,590 --> 00:26:16,180
the type because pythons really amazing

00:26:13,840 --> 00:26:18,180
lets me do this and this operation is

00:26:16,180 --> 00:26:26,440
fasted by tonight I was really surprised

00:26:18,180 --> 00:26:28,150
so basically that's it this link has

00:26:26,440 --> 00:26:31,300
nothing to do what was what I was

00:26:28,150 --> 00:26:33,460
talking recently but it's really

00:26:31,300 --> 00:26:35,140
fascinating read if you like about

00:26:33,460 --> 00:26:37,060
sharing memory because it implements

00:26:35,140 --> 00:26:38,920
memory sharing between Python processes

00:26:37,060 --> 00:26:41,560
in a completely different way that blow

00:26:38,920 --> 00:26:43,690
will blow your mind so the Google do go

00:26:41,560 --> 00:26:48,870
around and read it if you're interested

00:26:43,690 --> 00:27:03,640
and that's it they have of course oh

00:26:48,870 --> 00:27:05,560
okay questions no questions otherwise if

00:27:03,640 --> 00:27:06,970
you want to ask questions but that you

00:27:05,560 --> 00:27:12,490
think about later I'm gonna be outside

00:27:06,970 --> 00:27:14,580
of course so you're welcome to ask thank

00:27:12,490 --> 00:27:14,580

YouTube URL: https://www.youtube.com/watch?v=52zM4GgmqDE


