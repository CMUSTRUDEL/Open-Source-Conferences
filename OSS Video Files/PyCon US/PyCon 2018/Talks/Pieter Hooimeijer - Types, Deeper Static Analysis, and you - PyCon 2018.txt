Title: Pieter Hooimeijer - Types, Deeper Static Analysis, and you - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Pieter Hooimeijer

Many projects already take advantage of static analysis tools like flake8, PyLint, and MyPy. Can we do better? In this talk, I'll discuss how to take a type checker, bolt on an interprocedural static analyzer, and delight your security team with high quality results.

Abstract 

It is incredibly challenging to build a halfway decent static analysis tool for a dynamic language like Python. Fortunately, it gets quite a bit easier with Python type annotations. To explain why, I'll present a tool that finds security vulnerabilities by tracking dangerous flows of information interprocedurally across an entire codebase. **Then,** I'll demonstrate how that tool is really just a slightly slower, more sophisticated, type checker.



Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:02,060 --> 00:00:10,290
hello everyone hi so welcome to the talk

00:00:07,080 --> 00:00:12,480
on types diba static analysis and you

00:00:10,290 --> 00:00:21,330
please welcome Peter who will be

00:00:12,480 --> 00:00:36,780
presenting this awesome topic thank you

00:00:21,330 --> 00:00:39,980
how's my audio yeah all right how's my

00:00:36,780 --> 00:00:43,590
audio now not just the front row yeah

00:00:39,980 --> 00:00:46,410
all right so my slides are going to be a

00:00:43,590 --> 00:00:48,239
little stretched but mostly follow able

00:00:46,410 --> 00:00:50,879
so that's a plus

00:00:48,239 --> 00:00:53,940
title of the talk is types deeper static

00:00:50,879 --> 00:00:57,000
analysis and you so before I go into

00:00:53,940 --> 00:00:59,579
what that means a little about me

00:00:57,000 --> 00:01:02,190
I'm Peter at eff be calm in case you

00:00:59,579 --> 00:01:04,739
need to contact me after Peter with an

00:01:02,190 --> 00:01:06,570
extra I and I work in the product

00:01:04,739 --> 00:01:07,799
security team at Facebook this is

00:01:06,570 --> 00:01:10,500
basically Facebook's

00:01:07,799 --> 00:01:12,780
app sack team so we care about the

00:01:10,500 --> 00:01:14,939
security of all of our different code

00:01:12,780 --> 00:01:17,820
bases including Facebook itself

00:01:14,939 --> 00:01:21,900
obviously but also Instagram messenger

00:01:17,820 --> 00:01:23,820
oculus and so on I've been in Facebook

00:01:21,900 --> 00:01:25,080
for about six years there's a couple of

00:01:23,820 --> 00:01:27,990
things that I've worked on that are

00:01:25,080 --> 00:01:30,900
relevant so in 2012 I worked on the hack

00:01:27,990 --> 00:01:33,240
type checker for PHP so we had a lot of

00:01:30,900 --> 00:01:36,060
PHP at that time and we managed to add

00:01:33,240 --> 00:01:39,299
types to that code base and build a

00:01:36,060 --> 00:01:43,170
performing type checker for that code

00:01:39,299 --> 00:01:45,090
base back in the day more recently I've

00:01:43,170 --> 00:01:45,780
been involved with the Peyer check

00:01:45,090 --> 00:01:48,810
project

00:01:45,780 --> 00:01:51,689
Peyer is a performance type checker for

00:01:48,810 --> 00:01:55,799
python that we open sourced about two

00:01:51,689 --> 00:01:58,290
days ago and the sort of hack and pyro

00:01:55,799 --> 00:02:00,840
reference are relevant here because this

00:01:58,290 --> 00:02:03,240
talk will be about some of the cool

00:02:00,840 --> 00:02:04,710
things you can build on top of a type

00:02:03,240 --> 00:02:07,500
checker like that

00:02:04,710 --> 00:02:09,690
so this talk will basically be an

00:02:07,500 --> 00:02:11,430
experience report explaining some of the

00:02:09,690 --> 00:02:13,860
stuff that we've built internally at

00:02:11,430 --> 00:02:14,370
Facebook and Instagram and how you might

00:02:13,860 --> 00:02:16,140
benefit

00:02:14,370 --> 00:02:18,810
from this as well and I'll explain later

00:02:16,140 --> 00:02:21,870
what I mean by stuff like deep static

00:02:18,810 --> 00:02:25,700
analysis tool or deeper in the talk

00:02:21,870 --> 00:02:27,750
title so talk outline high-level it's a

00:02:25,700 --> 00:02:31,140
context that you need to know in order

00:02:27,750 --> 00:02:33,720
to get to the exciting part which is 2

00:02:31,140 --> 00:02:36,360
and then 3 I'll talk a little bit about

00:02:33,720 --> 00:02:38,250
our deployment of this stuff at Facebook

00:02:36,360 --> 00:02:40,620
and Instagram like why you should

00:02:38,250 --> 00:02:43,709
believe me what are your actual results

00:02:40,620 --> 00:02:47,519
type stuff so my context bit starts with

00:02:43,709 --> 00:02:49,769
an example and this is an example of a

00:02:47,519 --> 00:02:52,049
piece of code that exhibits a security

00:02:49,769 --> 00:02:54,359
problem that's like an actual thing that

00:02:52,049 --> 00:02:56,459
happened you have very likely used a

00:02:54,359 --> 00:02:58,319
product that had a security problem like

00:02:56,459 --> 00:03:01,730
this and I've kind of winnowed it down

00:02:58,319 --> 00:03:04,980
to like a couple of lines of Jango esque

00:03:01,730 --> 00:03:07,170
Python so if you literally add HTTP to

00:03:04,980 --> 00:03:09,209
request and response here didn't fit on

00:03:07,170 --> 00:03:12,480
the slide that would probably make this

00:03:09,209 --> 00:03:15,180
valid and point within a django web app

00:03:12,480 --> 00:03:18,109
so imagine this code is related to like

00:03:15,180 --> 00:03:20,609
facebook groups or a forum where there's

00:03:18,109 --> 00:03:21,930
groups of users and they can sort of

00:03:20,609 --> 00:03:23,880
create their own little cordoned off

00:03:21,930 --> 00:03:26,010
area that other users don't have access

00:03:23,880 --> 00:03:31,260
to and that's basically what this code

00:03:26,010 --> 00:03:33,900
will belong to so step one it gets the

00:03:31,260 --> 00:03:37,919
group ID from get parameter in the

00:03:33,900 --> 00:03:39,389
request step two it needs to double

00:03:37,919 --> 00:03:42,840
check that the currently logged in user

00:03:39,389 --> 00:03:45,419
has access to this group so it'll load

00:03:42,840 --> 00:03:46,769
some data pertaining to the group using

00:03:45,419 --> 00:03:48,449
the authenticated user and the

00:03:46,769 --> 00:03:51,000
assumption is that somewhere inside of

00:03:48,449 --> 00:03:54,299
load there will be a privacy check can

00:03:51,000 --> 00:03:57,720
this user see this group and then if

00:03:54,299 --> 00:03:59,669
everything goes well we render let's say

00:03:57,720 --> 00:04:01,290
maybe this is the thumbnail image

00:03:59,669 --> 00:04:03,239
belonging to this group or something

00:04:01,290 --> 00:04:06,949
like that so so far there's not a whole

00:04:03,239 --> 00:04:10,379
lot to argue with in terms of this code

00:04:06,949 --> 00:04:13,829
except for the error handling so if the

00:04:10,379 --> 00:04:16,019
data is none we throw a 404 with an

00:04:13,829 --> 00:04:19,260
indicative error message of sadness in

00:04:16,019 --> 00:04:23,490
this case and this is problematic

00:04:19,260 --> 00:04:26,669
because the data is user controlled the

00:04:23,490 --> 00:04:28,290
user can provide arbitrary group IDs and

00:04:26,669 --> 00:04:29,880
sort of check whether a

00:04:28,290 --> 00:04:32,580
currently logged-in user on facebook.com

00:04:29,880 --> 00:04:36,330
for example might be in a particular

00:04:32,580 --> 00:04:39,030
group so the user controls this branch

00:04:36,330 --> 00:04:41,550
prevents the sees exclamation point so

00:04:39,030 --> 00:04:42,360
this is an example of vulnerability that

00:04:41,550 --> 00:04:45,240
occurred

00:04:42,360 --> 00:04:47,460
for realsies in real products the way

00:04:45,240 --> 00:04:49,950
you would exploit this is by having your

00:04:47,460 --> 00:04:52,830
own evil comm and putting an image tag

00:04:49,950 --> 00:04:55,620
on it that hits this end point with a

00:04:52,830 --> 00:04:58,220
particular group ID and then has an

00:04:55,620 --> 00:05:01,110
onload and an on error event handler

00:04:58,220 --> 00:05:04,350
this is how you distinguish between the

00:05:01,110 --> 00:05:07,410
current user visiting your site has

00:05:04,350 --> 00:05:11,040
access to this group or not and this is

00:05:07,410 --> 00:05:13,980
an interesting sort of privacy Oracle

00:05:11,040 --> 00:05:15,930
that is externally accessible and kind

00:05:13,980 --> 00:05:18,600
of leaks information so I've included a

00:05:15,930 --> 00:05:20,310
URI here if you hit me up later I can

00:05:18,600 --> 00:05:23,300
send it to you that has sort of the full

00:05:20,310 --> 00:05:26,610
description of how this type of problem

00:05:23,300 --> 00:05:30,300
affected real products a couple of years

00:05:26,610 --> 00:05:32,520
ago so now the idea is wouldn't it be

00:05:30,300 --> 00:05:34,260
great if we could detect this sort of

00:05:32,520 --> 00:05:37,350
problem statically like we know this is

00:05:34,260 --> 00:05:40,620
an issue now can we find all occurrences

00:05:37,350 --> 00:05:43,860
in our code base and that's basically

00:05:40,620 --> 00:05:45,660
the underlying premise of this talk so I

00:05:43,860 --> 00:05:48,450
haven't defined yet what I mean by

00:05:45,660 --> 00:05:50,400
static analysis and this basically means

00:05:48,450 --> 00:05:51,600
many different things to different

00:05:50,400 --> 00:05:54,780
people

00:05:51,600 --> 00:05:58,710
and I want to be fairly precise I don't

00:05:54,780 --> 00:06:01,020
want you to take away that there's this

00:05:58,710 --> 00:06:03,630
super formal thing that won't work or

00:06:01,020 --> 00:06:05,790
that this is static analysis in terms of

00:06:03,630 --> 00:06:08,250
something that isn't relevant to your

00:06:05,790 --> 00:06:10,650
interest so let's be precise I want to

00:06:08,250 --> 00:06:13,470
show you a spectrum of static analysis

00:06:10,650 --> 00:06:17,070
tools on the left I'm going to put it

00:06:13,470 --> 00:06:18,930
fast easy to use and simple tools and

00:06:17,070 --> 00:06:22,590
then you can kind of guess where this is

00:06:18,930 --> 00:06:26,880
going on the right let's put slow hard

00:06:22,590 --> 00:06:27,840
to use and complex stuff all right so

00:06:26,880 --> 00:06:30,180
I'm gonna start on the right because

00:06:27,840 --> 00:06:32,340
that is the fun part let's talk about

00:06:30,180 --> 00:06:35,640
formal verification formal verification

00:06:32,340 --> 00:06:38,550
is a type of static analysis where the

00:06:35,640 --> 00:06:40,980
inputs are basically your code but also

00:06:38,550 --> 00:06:42,300
a full formal description of the

00:06:40,980 --> 00:06:45,659
property that needs to be

00:06:42,300 --> 00:06:48,180
proven and so on and then you write a

00:06:45,659 --> 00:06:49,590
very long proof script and then you have

00:06:48,180 --> 00:06:51,960
verified that your code completely

00:06:49,590 --> 00:06:53,610
matches the specification or something

00:06:51,960 --> 00:06:56,400
along those lines and it requires like a

00:06:53,610 --> 00:06:58,470
PhD or two to use you'll need grad

00:06:56,400 --> 00:07:01,830
students as well that's sort of your

00:06:58,470 --> 00:07:03,840
process here in the black box barely

00:07:01,830 --> 00:07:06,240
readable I've included an excerpt of an

00:07:03,840 --> 00:07:08,220
actual proof that I've written the

00:07:06,240 --> 00:07:09,629
relevant bit of that is that I wrote

00:07:08,220 --> 00:07:14,159
about thirteen hundred lines of proof

00:07:09,629 --> 00:07:17,219
script to verify five lines of code this

00:07:14,159 --> 00:07:19,530
is not super practical in its current

00:07:17,219 --> 00:07:23,129
form so let's go to the other side of

00:07:19,530 --> 00:07:24,780
the spectrum I've put grep I think grep

00:07:23,129 --> 00:07:26,520
is a static analysis tool in the sense

00:07:24,780 --> 00:07:28,469
that it looks at your code it's actually

00:07:26,520 --> 00:07:30,509
language agnostic - it only looks at the

00:07:28,469 --> 00:07:32,280
bytes of your code so you can grab for

00:07:30,509 --> 00:07:34,469
something like dangerous in your code

00:07:32,280 --> 00:07:36,840
and find all occurrences of it it's not

00:07:34,469 --> 00:07:38,909
very precise but it's very usable if

00:07:36,840 --> 00:07:41,400
you're a security engineer you could use

00:07:38,909 --> 00:07:43,169
this all the time and it will get you at

00:07:41,400 --> 00:07:44,759
least a start for where to start looking

00:07:43,169 --> 00:07:46,500
if you're interested in where a

00:07:44,759 --> 00:07:48,000
particular function is called or

00:07:46,500 --> 00:07:50,699
something like that and you might build

00:07:48,000 --> 00:07:52,800
frameworks that actually have the word

00:07:50,699 --> 00:07:54,870
dangerous in them like dangerously set

00:07:52,800 --> 00:07:55,319
inner HTML or something along those

00:07:54,870 --> 00:07:58,409
lines

00:07:55,319 --> 00:08:00,150
so this is not totally not useful but

00:07:58,409 --> 00:08:05,940
it's not great for finding flows of

00:08:00,150 --> 00:08:07,349
information in code as in the example so

00:08:05,940 --> 00:08:09,090
let's go a little bit more in the middle

00:08:07,349 --> 00:08:10,919
of this spectrum there's a bunch of

00:08:09,090 --> 00:08:12,960
linters so you could use pilant and

00:08:10,919 --> 00:08:14,909
flake eight and they're typically much

00:08:12,960 --> 00:08:16,500
better abstractions than grep for

00:08:14,909 --> 00:08:19,250
writing checks that you might care about

00:08:16,500 --> 00:08:21,900
they give you sort of typically point X

00:08:19,250 --> 00:08:23,069
based on an abstract syntax tree or

00:08:21,900 --> 00:08:25,800
something along those lines

00:08:23,069 --> 00:08:28,770
they let you write relatively low noise

00:08:25,800 --> 00:08:31,440
checks for relatively straightforward

00:08:28,770 --> 00:08:34,860
properties still not quite good enough

00:08:31,440 --> 00:08:35,610
though to find flows of information so

00:08:34,860 --> 00:08:39,329
moving right along

00:08:35,610 --> 00:08:40,680
what about types so types are a little

00:08:39,329 --> 00:08:42,390
bit more work you have to annotate your

00:08:40,680 --> 00:08:44,940
code so more consistently to get a

00:08:42,390 --> 00:08:46,970
benefit from it you can roll my PI or PI

00:08:44,940 --> 00:08:49,380
ER and they will give you type errors

00:08:46,970 --> 00:08:52,350
still not quite good enough to find

00:08:49,380 --> 00:08:54,240
flows of information though so the

00:08:52,350 --> 00:08:56,100
premise of the the next section of the

00:08:54,240 --> 00:08:58,589
talk is that we can build so

00:08:56,100 --> 00:09:01,079
purity focused data flow analysis tools

00:08:58,589 --> 00:09:03,389
and that find this kind of flow of

00:09:01,079 --> 00:09:05,459
information that we care about by

00:09:03,389 --> 00:09:06,750
leveraging only the existing types so I

00:09:05,459 --> 00:09:09,720
don't want the full formal verification

00:09:06,750 --> 00:09:11,910
thing where I need a giant proof script

00:09:09,720 --> 00:09:13,380
just to help the analyzer I just want to

00:09:11,910 --> 00:09:15,000
take advantage of the fact that we

00:09:13,380 --> 00:09:19,350
already have a code base with types in

00:09:15,000 --> 00:09:21,209
it and build on top of that so in order

00:09:19,350 --> 00:09:24,300
to explain that I need to go into some

00:09:21,209 --> 00:09:26,790
of the details behind how our type

00:09:24,300 --> 00:09:28,920
checkers work so hacking

00:09:26,790 --> 00:09:31,380
Peyer are very similar in this regard so

00:09:28,920 --> 00:09:33,329
I'm going to explain it at a somewhat

00:09:31,380 --> 00:09:35,880
high level sort of focusing on their

00:09:33,329 --> 00:09:37,889
architecture so let's type check some

00:09:35,880 --> 00:09:40,139
code I have two functions foo and bar

00:09:37,889 --> 00:09:41,850
they both have a parameter they both

00:09:40,139 --> 00:09:45,089
have a return type you can sort of read

00:09:41,850 --> 00:09:47,310
it as I talk what needs to happen for

00:09:45,089 --> 00:09:50,130
the type checker to verify that there is

00:09:47,310 --> 00:09:53,310
a problem in this code

00:09:50,130 --> 00:09:56,579
start by analyzing the expression bar of

00:09:53,310 --> 00:09:59,759
X so in order to verify this I need to

00:09:56,579 --> 00:10:02,790
make sure that the type of X matches the

00:09:59,759 --> 00:10:05,149
parameter for bar so I need to look up

00:10:02,790 --> 00:10:08,310
the type of X which is defined in the

00:10:05,149 --> 00:10:10,470
signature for foo and I need to look up

00:10:08,310 --> 00:10:13,259
the type of the first parameter of bar

00:10:10,470 --> 00:10:15,029
and make sure that they match so this is

00:10:13,259 --> 00:10:16,470
kind of like a consistency check and

00:10:15,029 --> 00:10:20,519
that's sort of the nature of type

00:10:16,470 --> 00:10:23,220
checkers in general next I need to check

00:10:20,519 --> 00:10:26,160
the full return type make sure that

00:10:23,220 --> 00:10:30,779
returning the result of bar of X matches

00:10:26,160 --> 00:10:32,730
the type of bar sorry matching it

00:10:30,779 --> 00:10:33,899
matches the return type of bar in this

00:10:32,730 --> 00:10:37,410
particular case that's where two type

00:10:33,899 --> 00:10:39,600
areas bar returns an int foo is supposed

00:10:37,410 --> 00:10:42,230
to return a string without some type of

00:10:39,600 --> 00:10:44,790
cast or conversion this is not good code

00:10:42,230 --> 00:10:46,800
and then there's a bunch of other stuff

00:10:44,790 --> 00:10:48,810
that I need to do so if I wanted to

00:10:46,800 --> 00:10:51,149
check bar itself I would need to compare

00:10:48,810 --> 00:10:52,620
its return type to its signature and so

00:10:51,149 --> 00:10:56,009
on there's an interesting observation

00:10:52,620 --> 00:10:56,579
here which is that to check the body of

00:10:56,009 --> 00:10:58,589
bar

00:10:56,579 --> 00:11:00,600
I don't need access to any of the

00:10:58,589 --> 00:11:03,269
information that I used to check the

00:11:00,600 --> 00:11:05,490
body of foo except for the signature of

00:11:03,269 --> 00:11:07,319
foo so I can actually type check a lot

00:11:05,490 --> 00:11:09,240
of these different functions in parallel

00:11:07,319 --> 00:11:11,850
fairly easily they don't depend on

00:11:09,240 --> 00:11:14,160
at all the high-level steps in the type

00:11:11,850 --> 00:11:16,830
checker or something like parse every

00:11:14,160 --> 00:11:18,450
function resolved the method calls so I

00:11:16,830 --> 00:11:20,100
need to know which bar is getting called

00:11:18,450 --> 00:11:24,180
so that I can look up its signature and

00:11:20,100 --> 00:11:26,940
then do these consistency checks and the

00:11:24,180 --> 00:11:28,860
observation here is that you can do a

00:11:26,940 --> 00:11:30,470
lot of these steps in parallel not all

00:11:28,860 --> 00:11:33,570
of them depend on each other

00:11:30,470 --> 00:11:36,209
so the parallelization in both of these

00:11:33,570 --> 00:11:39,510
type checkers works something like fire

00:11:36,209 --> 00:11:40,500
up some number of processes and or

00:11:39,510 --> 00:11:43,170
something like that

00:11:40,500 --> 00:11:44,910
and distribute the work so in other

00:11:43,170 --> 00:11:46,860
words if there's a hundred files to type

00:11:44,910 --> 00:11:50,250
check and I have 20 processes to do it

00:11:46,860 --> 00:11:54,740
they each get five files to type check

00:11:50,250 --> 00:11:57,690
or parse at least initially one

00:11:54,740 --> 00:11:59,250
particular insight behind the hack type

00:11:57,690 --> 00:12:01,160
checker back in the day was that we can

00:11:59,250 --> 00:12:03,240
share work between these processes

00:12:01,160 --> 00:12:05,670
relatively easily so if I need the

00:12:03,240 --> 00:12:08,040
signature for some function there's one

00:12:05,670 --> 00:12:10,290
of two things to do one is get it from

00:12:08,040 --> 00:12:12,240
the cache if it's not there just parse

00:12:10,290 --> 00:12:16,560
that function and put it in the cache

00:12:12,240 --> 00:12:20,959
for later use the dot here leads to but

00:12:16,560 --> 00:12:20,959
don't coordinate too much oh sorry

00:12:21,380 --> 00:12:28,950
in other words we actually will redo a

00:12:25,920 --> 00:12:30,779
bunch of work if there are two functions

00:12:28,950 --> 00:12:32,220
that need to be parse if there's a

00:12:30,779 --> 00:12:33,660
function that needs to be parsed by two

00:12:32,220 --> 00:12:36,450
different processes we might end up

00:12:33,660 --> 00:12:38,970
doing that because it's more expensive

00:12:36,450 --> 00:12:41,730
to coordinate between the processes than

00:12:38,970 --> 00:12:44,390
it is to occasionally duplicate work so

00:12:41,730 --> 00:12:47,160
those are kind of the pros and cons here

00:12:44,390 --> 00:12:49,770
this is a very high-level overview I

00:12:47,160 --> 00:12:51,930
apologize I wish I had more time to go

00:12:49,770 --> 00:12:54,000
into tons and tons of detail about how

00:12:51,930 --> 00:12:57,029
this works but we need to move on to

00:12:54,000 --> 00:13:00,360
building an actual analyzer on top of

00:12:57,029 --> 00:13:02,640
this so let's get back to the example so

00:13:00,360 --> 00:13:05,700
I sort of used this like red thing on

00:13:02,640 --> 00:13:07,050
the on the very left to highlight the

00:13:05,700 --> 00:13:09,660
path that I care about but I haven't

00:13:07,050 --> 00:13:12,390
really formally explained what is the

00:13:09,660 --> 00:13:16,680
property that I care about here so let's

00:13:12,390 --> 00:13:20,430
do that so basically I want branches

00:13:16,680 --> 00:13:22,329
that throw HTTP 404 that are based on a

00:13:20,430 --> 00:13:23,970
privacy decision

00:13:22,329 --> 00:13:26,529
because that's what makes this a leak

00:13:23,970 --> 00:13:29,319
that in turn are based on something that

00:13:26,529 --> 00:13:31,319
is a user controlled input because

00:13:29,319 --> 00:13:35,290
that's what makes this an exploitable

00:13:31,319 --> 00:13:37,089
privacy leak so typically in a sort of

00:13:35,290 --> 00:13:39,160
static analysis parlance we call this

00:13:37,089 --> 00:13:41,139
taint tracking it's like a variable

00:13:39,160 --> 00:13:42,850
becomes tainted and then stays that way

00:13:41,139 --> 00:13:45,459
unless you sanitize it or something like

00:13:42,850 --> 00:13:48,129
that and in the context of this

00:13:45,459 --> 00:13:50,829
particular example the branches that

00:13:48,129 --> 00:13:53,679
throw would be distinct the place where

00:13:50,829 --> 00:13:56,079
information goes that we don't want and

00:13:53,679 --> 00:14:00,579
the user controlled input would be the

00:13:56,079 --> 00:14:02,259
source some terminology so to build an

00:14:00,579 --> 00:14:05,350
analyzer like this there's basically

00:14:02,259 --> 00:14:06,369
three steps where I've code all the way

00:14:05,350 --> 00:14:09,549
on the left that's the code were

00:14:06,369 --> 00:14:11,319
analyzing I have shown you very roughly

00:14:09,549 --> 00:14:13,239
what a parallel type checker looks like

00:14:11,319 --> 00:14:15,549
and now there's two additional things

00:14:13,239 --> 00:14:17,980
there's the actual taint analysis the

00:14:15,549 --> 00:14:19,600
taint tracking step all the way on the

00:14:17,980 --> 00:14:21,819
right and then before that there's

00:14:19,600 --> 00:14:25,209
building a call graph and I'm gonna show

00:14:21,819 --> 00:14:28,269
you how we do the graph stuff before

00:14:25,209 --> 00:14:30,160
explaining why you actually need one and

00:14:28,269 --> 00:14:32,619
then there's an aside which is that it

00:14:30,160 --> 00:14:35,230
would be great if we could make both the

00:14:32,619 --> 00:14:37,989
call graph construction and the static

00:14:35,230 --> 00:14:40,389
analysis itself parallelizable as well

00:14:37,989 --> 00:14:42,549
because that would make this actually

00:14:40,389 --> 00:14:44,319
feasible from a does it run quickly

00:14:42,549 --> 00:14:47,199
enough to get you results before the

00:14:44,319 --> 00:14:49,749
code is already shipped point of view so

00:14:47,199 --> 00:14:51,819
let's focus on the call graph stuff so

00:14:49,749 --> 00:14:54,100
sort of traditional when you talk about

00:14:51,819 --> 00:14:55,839
call graphs to draw lots of dots on the

00:14:54,100 --> 00:14:57,249
slide and then lots of arrows I don't

00:14:55,839 --> 00:14:59,439
know if you've ever tried visualizing

00:14:57,249 --> 00:15:02,169
like a large code base this way it gets

00:14:59,439 --> 00:15:05,290
real messy really quickly so I've just

00:15:02,169 --> 00:15:08,589
sort of left it at this this is my best

00:15:05,290 --> 00:15:10,779
effort call graph I'll give you a formal

00:15:08,589 --> 00:15:12,879
definition though it's an over

00:15:10,779 --> 00:15:16,059
approximation of all function calls that

00:15:12,879 --> 00:15:18,879
can happen in the code base so what do I

00:15:16,059 --> 00:15:21,759
mean by over approximation essentially

00:15:18,879 --> 00:15:24,129
it is not feasible to statically say

00:15:21,759 --> 00:15:26,169
exactly which calls will and will not

00:15:24,129 --> 00:15:29,230
happen especially with class hierarchies

00:15:26,169 --> 00:15:31,720
and dynamic dispatch so in practice we

00:15:29,230 --> 00:15:33,819
want to create an edge an edge between

00:15:31,720 --> 00:15:35,769
two functions in the call graph if we

00:15:33,819 --> 00:15:36,160
think there might be a call even though

00:15:35,769 --> 00:15:37,540
in

00:15:36,160 --> 00:15:40,889
practice it might never happen at

00:15:37,540 --> 00:15:44,470
runtime let me give you an example

00:15:40,889 --> 00:15:47,230
suppose I have three classes a B and C a

00:15:44,470 --> 00:15:50,949
defines a method it's called get data

00:15:47,230 --> 00:15:52,329
returns data and it's abstract B and C

00:15:50,949 --> 00:15:54,459
I've sort of glossed over the details

00:15:52,329 --> 00:15:56,500
but let's assume they also implement get

00:15:54,459 --> 00:16:01,000
data and then I have a function foo

00:15:56,500 --> 00:16:03,220
which takes a B as input and calls get

00:16:01,000 --> 00:16:04,959
data on it and passing the result to a

00:16:03,220 --> 00:16:07,629
bar so what does the call graph look

00:16:04,959 --> 00:16:11,470
like for this bit of code looks like

00:16:07,629 --> 00:16:13,029
this so I'm not gonna like fancily step

00:16:11,470 --> 00:16:15,910
you through the animation or anything

00:16:13,029 --> 00:16:19,990
but definitely foo calls bar we can see

00:16:15,910 --> 00:16:22,660
that it might call B get data if X is an

00:16:19,990 --> 00:16:25,300
instance of B but because C is a subtype

00:16:22,660 --> 00:16:29,110
of B it could also be C dug at data if

00:16:25,300 --> 00:16:31,300
we pass X as a C so that's roughly what

00:16:29,110 --> 00:16:35,050
a call graph looks like at a super high

00:16:31,300 --> 00:16:37,689
level very quickly we need this to make

00:16:35,050 --> 00:16:41,920
the analysis both precise and also to

00:16:37,689 --> 00:16:44,230
make it fast so on to that so what is

00:16:41,920 --> 00:16:45,639
taint analysis this is the other term in

00:16:44,230 --> 00:16:49,149
addition to call graph that I've sort of

00:16:45,639 --> 00:16:51,730
used before actually defining it the key

00:16:49,149 --> 00:16:53,380
insight is that instead of parsing

00:16:51,730 --> 00:16:56,230
signatures which is why the type checker

00:16:53,380 --> 00:16:58,630
does or analyzing them we want to

00:16:56,230 --> 00:17:00,220
compute function summaries and one way

00:16:58,630 --> 00:17:02,920
to look at a summary is as like a very

00:17:00,220 --> 00:17:04,600
elaborate fancy type that is different

00:17:02,920 --> 00:17:06,339
from the type that you've annotated in

00:17:04,600 --> 00:17:09,819
your code and has a lot more detail and

00:17:06,339 --> 00:17:13,480
for this particular problem specifically

00:17:09,819 --> 00:17:17,640
it contains two things one is how data

00:17:13,480 --> 00:17:21,339
flows from sources to out of the cobble

00:17:17,640 --> 00:17:24,130
two is how data flows from the arguments

00:17:21,339 --> 00:17:26,049
into any dangerous sinks this is the

00:17:24,130 --> 00:17:27,640
information that we want for every

00:17:26,049 --> 00:17:29,530
single function in the code base and

00:17:27,640 --> 00:17:32,980
then we can stitch together paths of

00:17:29,530 --> 00:17:35,980
data that look risky or dangerous and

00:17:32,980 --> 00:17:39,610
show them to security engineers so yet

00:17:35,980 --> 00:17:41,559
another example another foo I have puck

00:17:39,610 --> 00:17:44,289
as the input here that stands for a

00:17:41,559 --> 00:17:47,409
potentially user controlled it calls

00:17:44,289 --> 00:17:48,760
sync on that and ever turns a value from

00:17:47,409 --> 00:17:50,020
source so it's sort of the shortest

00:17:48,760 --> 00:17:51,730
possible example

00:17:50,020 --> 00:17:54,190
that has two of the interesting

00:17:51,730 --> 00:17:56,230
properties let's say so let's compare

00:17:54,190 --> 00:17:57,910
its signature to its summary the

00:17:56,230 --> 00:18:00,580
signature is right there in the code

00:17:57,910 --> 00:18:02,710
takes a parameter string returns the

00:18:00,580 --> 00:18:05,380
string let's talk about this summary

00:18:02,710 --> 00:18:07,930
though it will basically consists of two

00:18:05,380 --> 00:18:10,120
parts which I've called the in summary

00:18:07,930 --> 00:18:11,560
and the out summary in this case the in

00:18:10,120 --> 00:18:14,230
summary says that the first argument

00:18:11,560 --> 00:18:18,370
flows into sink the out summary says

00:18:14,230 --> 00:18:20,830
that source gets returned from this

00:18:18,370 --> 00:18:22,210
function potentially in some cases if

00:18:20,830 --> 00:18:25,360
there's multiple returns we have to

00:18:22,210 --> 00:18:28,360
simplify so this is what this looks like

00:18:25,360 --> 00:18:30,280
for a single function and now you might

00:18:28,360 --> 00:18:33,070
ask you know how does that actually

00:18:30,280 --> 00:18:35,110
translate to useful results so I'm going

00:18:33,070 --> 00:18:37,600
to put up an assertion which is that

00:18:35,110 --> 00:18:39,580
this works for any depth call stack you

00:18:37,600 --> 00:18:41,110
can stitch together these summaries from

00:18:39,580 --> 00:18:43,600
different functions that call each other

00:18:41,110 --> 00:18:46,540
using the call graph and figure out

00:18:43,600 --> 00:18:49,750
longer flows of information so I'll give

00:18:46,540 --> 00:18:52,090
you a brief example in this case foo bar

00:18:49,750 --> 00:18:55,420
and buzz sort of each call each other in

00:18:52,090 --> 00:18:58,600
turn the original user controlled string

00:18:55,420 --> 00:19:00,730
flows from the top function into the

00:18:58,600 --> 00:19:02,740
bottom one and eventually into a sink so

00:19:00,730 --> 00:19:04,720
this is what we want to catch across

00:19:02,740 --> 00:19:07,590
function calls so I'm going to give you

00:19:04,720 --> 00:19:10,360
only the in summary parts for brevity

00:19:07,590 --> 00:19:12,670
and I'm gonna start with Baz at the

00:19:10,360 --> 00:19:16,240
bottom so the first argument flows into

00:19:12,670 --> 00:19:20,920
sink that is the full summary or the in

00:19:16,240 --> 00:19:24,040
summary for buzz the summary for bar is

00:19:20,920 --> 00:19:26,770
basically a forward reference to the

00:19:24,040 --> 00:19:29,830
summary for buzz so I say the first

00:19:26,770 --> 00:19:32,320
argument flows into whatever is the in

00:19:29,830 --> 00:19:36,310
summary for buzz and its first argument

00:19:32,320 --> 00:19:38,890
and I can repeat that trick so the first

00:19:36,310 --> 00:19:41,350
argument for foo is the in summary for

00:19:38,890 --> 00:19:43,420
bar at the first argument so if I

00:19:41,350 --> 00:19:45,610
analyze these functions in the right

00:19:43,420 --> 00:19:46,870
order though I can establish that

00:19:45,610 --> 00:19:49,540
there's a dangerous flow of information

00:19:46,870 --> 00:19:51,910
all the way from through into bar into

00:19:49,540 --> 00:19:53,890
Baz into a dangerous sink something

00:19:51,910 --> 00:19:56,110
along those lines there's a couple of

00:19:53,890 --> 00:19:58,000
design consequences here one is that the

00:19:56,110 --> 00:20:01,140
order in which you analyze functions

00:19:58,000 --> 00:20:03,820
matters and that we need basically a

00:20:01,140 --> 00:20:05,800
somewhat sophisticated scheduler

00:20:03,820 --> 00:20:08,890
to decide when these functions get

00:20:05,800 --> 00:20:10,990
analyzed in turn you can analyze them

00:20:08,890 --> 00:20:13,690
theoretically in an arbitrary order and

00:20:10,990 --> 00:20:15,940
your analyzer will take the lifetime of

00:20:13,690 --> 00:20:18,430
the universe to finish if you find the

00:20:15,940 --> 00:20:25,120
right order using a scheduler it can

00:20:18,430 --> 00:20:27,670
finish in to be pronounced later alright

00:20:25,120 --> 00:20:30,130
so that is roughly what an analyzer

00:20:27,670 --> 00:20:32,470
pipeline looks like each of the stages

00:20:30,130 --> 00:20:34,960
within themselves are highly parallel

00:20:32,470 --> 00:20:37,510
and the output of one stage sort of

00:20:34,960 --> 00:20:40,030
flows into the next you need a call

00:20:37,510 --> 00:20:42,070
graph specifically because it informs

00:20:40,030 --> 00:20:45,580
the scheduler in terms of how it runs

00:20:42,070 --> 00:20:50,070
the taint analysis so looking back on

00:20:45,580 --> 00:20:52,510
our our frame of reference here

00:20:50,070 --> 00:20:55,780
basically what we've done here is we've

00:20:52,510 --> 00:20:58,300
taken gradual type annotations and we

00:20:55,780 --> 00:21:00,910
benefit from type checking by itself but

00:20:58,300 --> 00:21:04,660
we can also find sort of deeper static

00:21:00,910 --> 00:21:06,280
analysis properties and I guess one

00:21:04,660 --> 00:21:08,500
thing I forgot to mention is this is

00:21:06,280 --> 00:21:10,090
called bottom-up static analysis because

00:21:08,500 --> 00:21:13,270
you analyze sort of one function at a

00:21:10,090 --> 00:21:16,840
time and stitch together results as you

00:21:13,270 --> 00:21:19,390
look at sort of fake call stacks so this

00:21:16,840 --> 00:21:21,280
doesn't require any new annotations it

00:21:19,390 --> 00:21:23,410
just requires a security engineer to

00:21:21,280 --> 00:21:28,900
tell you which sources and syncs you're

00:21:23,410 --> 00:21:31,300
interested in all right so I will now

00:21:28,900 --> 00:21:33,340
talk a little bit about our results and

00:21:31,300 --> 00:21:36,760
sort of why you should believe me in

00:21:33,340 --> 00:21:38,650
anyway so instagram has a million or so

00:21:36,760 --> 00:21:41,890
lines of Python will call it millions

00:21:38,650 --> 00:21:44,170
and we use Peyer for type checking as of

00:21:41,890 --> 00:21:46,240
a couple of weeks ago pyar takes about a

00:21:44,170 --> 00:21:48,790
minute to start up a little bit less and

00:21:46,240 --> 00:21:50,530
it produces sub 200 millisecond

00:21:48,790 --> 00:21:52,960
incremental updates so if you change

00:21:50,530 --> 00:21:55,540
some code save it in your editor you'll

00:21:52,960 --> 00:21:58,030
get quick type error results the taint

00:21:55,540 --> 00:22:00,670
analysis stuff of this is TBD smiley

00:21:58,030 --> 00:22:04,780
face that's what we're hoping to work on

00:22:00,670 --> 00:22:09,700
next however we have built this on top

00:22:04,780 --> 00:22:12,100
of hack for PHP hack type checks tens of

00:22:09,700 --> 00:22:14,920
millions of lines of code it's a little

00:22:12,100 --> 00:22:17,460
bit bigger and we have built internal

00:22:14,920 --> 00:22:19,980
tools for security analysis

00:22:17,460 --> 00:22:22,050
so this is used everyday by our security

00:22:19,980 --> 00:22:25,200
engineers not because we make them but

00:22:22,050 --> 00:22:27,120
because they want to and runs on every

00:22:25,200 --> 00:22:29,040
code change so I've used the terminology

00:22:27,120 --> 00:22:31,740
DIF here which is Facebook speak for

00:22:29,040 --> 00:22:34,800
every update to every requested change

00:22:31,740 --> 00:22:37,440
even prior to commit and it takes about

00:22:34,800 --> 00:22:40,350
20 minutes wall time checks a ton of

00:22:37,440 --> 00:22:43,980
properties takes about 20 minutes end to

00:22:40,350 --> 00:22:47,940
end that's without caching enabled which

00:22:43,980 --> 00:22:50,280
is fairly spectacular and it finds and

00:22:47,940 --> 00:22:52,650
prevents issues regularly so I can't go

00:22:50,280 --> 00:22:54,990
into a great amount of detail here

00:22:52,650 --> 00:22:56,700
but I would sort of point to the fact

00:22:54,990 --> 00:23:00,030
that our security engineers prefer to

00:22:56,700 --> 00:23:06,300
use this over grep in order to find

00:23:00,030 --> 00:23:08,030
security issues so in conclusion in my

00:23:06,300 --> 00:23:10,620
talk abstract if you've seen it I

00:23:08,030 --> 00:23:12,840
mentioned how to take a type checker

00:23:10,620 --> 00:23:14,880
bolt on an inter procedural static

00:23:12,840 --> 00:23:17,250
analyzer and delight your security team

00:23:14,880 --> 00:23:19,970
with high quality results I feel like

00:23:17,250 --> 00:23:22,440
I've covered most of this the TLDR is

00:23:19,970 --> 00:23:25,050
we've built some of this for hack and

00:23:22,440 --> 00:23:27,930
PHP we're hoping to build it for Python

00:23:25,050 --> 00:23:30,090
as well and we're very excited to do

00:23:27,930 --> 00:23:31,980
some of that in the open in the form of

00:23:30,090 --> 00:23:35,430
the the pyar type checker and sort of

00:23:31,980 --> 00:23:37,410
its extensions if you would like to talk

00:23:35,430 --> 00:23:39,960
super shop with people in terms of

00:23:37,410 --> 00:23:42,330
technical detail this is the pyar team

00:23:39,960 --> 00:23:44,400
and they're all here so Dominic Marco

00:23:42,330 --> 00:23:46,560
Shannon and Sinan actually did the

00:23:44,400 --> 00:23:48,390
technical work to make some of this

00:23:46,560 --> 00:23:51,030
possible I'm just here to sort of talk

00:23:48,390 --> 00:23:53,340
about it and you can find us on github

00:23:51,030 --> 00:23:55,980
as well and that's my talk and I have a

00:23:53,340 --> 00:24:05,180
few minutes for questions

00:23:55,980 --> 00:24:05,180
[Applause]

00:24:05,700 --> 00:24:10,210
hey everyone we have five minutes for

00:24:08,140 --> 00:24:14,620
questions so bring them on we have a mic

00:24:10,210 --> 00:24:18,280
up front do you find that because it has

00:24:14,620 --> 00:24:20,380
to expand the possible call stack to be

00:24:18,280 --> 00:24:23,830
the the most conservative possible large

00:24:20,380 --> 00:24:25,930
set that it sometimes it detects flow

00:24:23,830 --> 00:24:27,790
problems that don't ever actually occur

00:24:25,930 --> 00:24:29,770
because the functions aren't ever really

00:24:27,790 --> 00:24:31,150
called in that order yeah so the

00:24:29,770 --> 00:24:33,460
precision of the call graph is

00:24:31,150 --> 00:24:35,770
critically important to make the results

00:24:33,460 --> 00:24:38,200
precise as well and that affects

00:24:35,770 --> 00:24:40,480
performance as well so if your call

00:24:38,200 --> 00:24:42,970
graph is all functions can call all

00:24:40,480 --> 00:24:45,970
functions which is technically befitting

00:24:42,970 --> 00:24:48,010
of the definition then your analysis

00:24:45,970 --> 00:24:50,500
would be both very imprecise and also

00:24:48,010 --> 00:24:52,210
very slow so we put a lot of work into

00:24:50,500 --> 00:25:02,710
the details for making sure that the

00:24:52,210 --> 00:25:05,110
call graph is very accurate thank you so

00:25:02,710 --> 00:25:08,410
I was wondering how you deal with

00:25:05,110 --> 00:25:12,550
functions that um will modify some sort

00:25:08,410 --> 00:25:16,330
of shared state yep because in Python

00:25:12,550 --> 00:25:19,300
you might say save something that you

00:25:16,330 --> 00:25:23,800
should it as in instance attribute yeah

00:25:19,300 --> 00:25:27,640
make sense so this is where the talk is

00:25:23,800 --> 00:25:29,890
a lie there's more to it than just the

00:25:27,640 --> 00:25:32,170
in summaries and out summaries and we

00:25:29,890 --> 00:25:36,400
use an abstraction called access paths

00:25:32,170 --> 00:25:38,920
to define like the the sort of out of a

00:25:36,400 --> 00:25:41,650
function in addition to its return which

00:25:38,920 --> 00:25:44,740
can be sets this instance variable on

00:25:41,650 --> 00:25:46,840
the current object or any sort of number

00:25:44,740 --> 00:25:49,080
of dereferences away to a particular

00:25:46,840 --> 00:25:51,760
value and whether that is tainted or not

00:25:49,080 --> 00:25:53,830
that's actually surprisingly challenging

00:25:51,760 --> 00:25:55,540
there are other static analysis projects

00:25:53,830 --> 00:25:57,610
that Facebook has built that focus

00:25:55,540 --> 00:26:00,340
specifically on the separate problem of

00:25:57,610 --> 00:26:04,990
like what does the heap look like in the

00:26:00,340 --> 00:26:07,000
form of infer and shape analysis so this

00:26:04,990 --> 00:26:08,440
is something that we need less for the

00:26:07,000 --> 00:26:10,770
security specific problems that were

00:26:08,440 --> 00:26:13,390
interested in here so we've sort of

00:26:10,770 --> 00:26:16,360
iterated on this and come up with the

00:26:13,390 --> 00:26:18,850
level of fanciness that helps us without

00:26:16,360 --> 00:26:27,820
being so expensive that it becomes

00:26:18,850 --> 00:26:30,130
infeasible thank you hey there I was

00:26:27,820 --> 00:26:33,430
wondering do you have any references or

00:26:30,130 --> 00:26:35,770
material about the scheduler because I

00:26:33,430 --> 00:26:37,750
actually experienced that problem you

00:26:35,770 --> 00:26:40,300
mentioned yeah

00:26:37,750 --> 00:26:42,460
so the short answer is no unfortunately

00:26:40,300 --> 00:26:46,420
we haven't published that psych analysis

00:26:42,460 --> 00:26:49,450
work yet however I can say that that has

00:26:46,420 --> 00:26:51,280
taken a bunch of engineers a bunch of

00:26:49,450 --> 00:26:54,100
work in order to get right especially

00:26:51,280 --> 00:26:55,630
for our Facebook of this in terms of

00:26:54,100 --> 00:26:57,550
figuring out hey there's these large

00:26:55,630 --> 00:26:59,380
cycles of methods and you kind of need

00:26:57,550 --> 00:27:01,450
to analyze all of them concurrently so

00:26:59,380 --> 00:27:03,580
one unit of work is much larger than

00:27:01,450 --> 00:27:06,220
other units of work so we preemptively

00:27:03,580 --> 00:27:07,810
schedule those first so there's actually

00:27:06,220 --> 00:27:09,580
some hard coding that we get away with

00:27:07,810 --> 00:27:15,370
because it's an analyzer that's designed

00:27:09,580 --> 00:27:18,340
for single codebase hello thank you for

00:27:15,370 --> 00:27:21,690
this inspiring talk I was wondering are

00:27:18,340 --> 00:27:24,640
there any similarities between taint

00:27:21,690 --> 00:27:26,860
analysis and profiling and is there a

00:27:24,640 --> 00:27:29,380
way or is there an overlap and is there

00:27:26,860 --> 00:27:31,030
a way to get profiling for free when

00:27:29,380 --> 00:27:33,280
doing Taino let's say analysis or vice

00:27:31,030 --> 00:27:35,010
versa yeah that's a good question

00:27:33,280 --> 00:27:37,120
so there have been projects in the past

00:27:35,010 --> 00:27:39,850
including at Facebook if I remember

00:27:37,120 --> 00:27:43,090
correctly where we do the equivalent of

00:27:39,850 --> 00:27:45,580
this but at runtime so we somehow stick

00:27:43,090 --> 00:27:47,500
an extra bit of information onto a

00:27:45,580 --> 00:27:49,750
variable that has an object type like we

00:27:47,500 --> 00:27:51,430
rewrite the code so that it has an extra

00:27:49,750 --> 00:27:53,170
field just so that we can say it's

00:27:51,430 --> 00:27:55,570
tainted and then we look at that at

00:27:53,170 --> 00:27:57,460
runtime this is super challenging in

00:27:55,570 --> 00:27:59,590
practice it's kind of scary to rewrite

00:27:57,460 --> 00:28:01,810
your production code and then sort of

00:27:59,590 --> 00:28:03,700
trust the rewritten version that no one

00:28:01,810 --> 00:28:06,520
has seen visually or you know code

00:28:03,700 --> 00:28:08,530
reviewed to work correctly but we have

00:28:06,520 --> 00:28:10,510
done that in the past for caching

00:28:08,530 --> 00:28:12,820
performance problems as well as security

00:28:10,510 --> 00:28:17,350
problems but it has sort of a different

00:28:12,820 --> 00:28:21,150
set of challenges thank you Thanks all

00:28:17,350 --> 00:28:21,150
right thanks for coming in and

00:28:23,309 --> 00:28:27,959

YouTube URL: https://www.youtube.com/watch?v=hWV8t494N88


