Title: James Bennett - A Bit about Bytes: Understanding Python Bytecode - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: James Bennett

At some point every Python programmer sees Python bytecode files -- they're those '.pyc' files Python likes to leave behind after it runs. But have you ever wondered what's really going on in those files? Well, wonder no more! In this talk you'll learn what Python bytecode is and how it's used to execute your code, as well as how to decipher and read it, and how to reason about bytecode to understand the performance of your Python code.

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:07,250 --> 00:00:14,969
all right hi welcome to a bit about

00:00:11,490 --> 00:00:17,850
bytes about looking a Python byte code

00:00:14,969 --> 00:00:20,039
so in addition to being a clever play on

00:00:17,850 --> 00:00:22,830
words would be some useful information

00:00:20,039 --> 00:00:25,800
so without much further ado we have

00:00:22,830 --> 00:00:36,390
James Bennett Django core developer so

00:00:25,800 --> 00:00:38,040
let's get the talk underway hi so I want

00:00:36,390 --> 00:00:41,300
to start with a sort of an existential

00:00:38,040 --> 00:00:45,390
question why are we here

00:00:41,300 --> 00:00:52,079
at PyCon we're here because we love

00:00:45,390 --> 00:00:55,170
Python right right and why do we love

00:00:52,079 --> 00:00:57,000
Python we love Python because we all

00:00:55,170 --> 00:01:00,239
understand this great truth of

00:00:57,000 --> 00:01:03,059
programming did we read code much more

00:01:00,239 --> 00:01:05,970
often than we write it and so we should

00:01:03,059 --> 00:01:08,880
write our code to be as readable as we

00:01:05,970 --> 00:01:12,720
can make it and of course we love Python

00:01:08,880 --> 00:01:15,360
because we don't even built around that

00:01:12,720 --> 00:01:19,950
simple idea that code should be easy to

00:01:15,360 --> 00:01:24,270
read and that language is Python clear

00:01:19,950 --> 00:01:25,619
easy to read understandable Python even

00:01:24,270 --> 00:01:28,110
people who aren't necessarily

00:01:25,619 --> 00:01:30,329
programmers can at least be a look at

00:01:28,110 --> 00:01:36,650
some Python and follow the logic of

00:01:30,329 --> 00:01:39,990
what's going on right okay so this

00:01:36,650 --> 00:01:41,820
actually is Python or at least this is

00:01:39,990 --> 00:01:44,640
how Python works if you go download

00:01:41,820 --> 00:01:47,460
Python from Python org you know we call

00:01:44,640 --> 00:01:50,250
the C Python distribution this is how it

00:01:47,460 --> 00:01:53,820
executes your code we're going to learn

00:01:50,250 --> 00:01:56,790
about where this comes from how this

00:01:53,820 --> 00:01:59,430
works what sorts of useful things we can

00:01:56,790 --> 00:02:01,590
learn from understanding it and how we

00:01:59,430 --> 00:02:05,090
can apply that you know both practically

00:02:01,590 --> 00:02:07,350
and in a sort of theoretical sense but

00:02:05,090 --> 00:02:08,670
before we do that we need to understand

00:02:07,350 --> 00:02:10,709
a little bit about how computers work

00:02:08,670 --> 00:02:12,560
and we need to understand a little bit

00:02:10,709 --> 00:02:14,959
how programming languages

00:02:12,560 --> 00:02:19,340
work now I love this because it is

00:02:14,959 --> 00:02:21,200
beautiful and it is true but we do need

00:02:19,340 --> 00:02:24,380
to understand how a computer actually

00:02:21,200 --> 00:02:26,750
works deep down inside you have your CPU

00:02:24,380 --> 00:02:29,750
your processor it's a little wafer of

00:02:26,750 --> 00:02:32,000
silicon and inscribed on it are these

00:02:29,750 --> 00:02:33,230
electrical circuits and they're set up

00:02:32,000 --> 00:02:35,630
so if I send a certain pattern

00:02:33,230 --> 00:02:37,160
electricity in I get another different

00:02:35,630 --> 00:02:40,130
pattern of electricity out it's very

00:02:37,160 --> 00:02:42,830
predictable and we give names and

00:02:40,130 --> 00:02:45,110
meanings to these patterns we treat them

00:02:42,830 --> 00:02:46,580
as if they do mean something so we say

00:02:45,110 --> 00:02:49,340
this pattern of electricity actually

00:02:46,580 --> 00:02:51,380
means add two numbers together that's

00:02:49,340 --> 00:02:53,440
how your computer actually works

00:02:51,380 --> 00:02:56,239
those names we give to them we call them

00:02:53,440 --> 00:02:58,040
instructions for the CPU sometimes you

00:02:56,239 --> 00:03:00,290
hear them called machine code for the

00:02:58,040 --> 00:03:01,880
CPU if we show it in a slightly more

00:03:00,290 --> 00:03:05,060
human readable format you'll sometimes

00:03:01,880 --> 00:03:08,180
hear called assembly but it's not all

00:03:05,060 --> 00:03:11,290
that friendly to humans to look at this

00:03:08,180 --> 00:03:13,849
stuff anybody ever looked at assembly

00:03:11,290 --> 00:03:19,070
how many of you would like to write like

00:03:13,849 --> 00:03:22,280
that all the time so you want to write

00:03:19,070 --> 00:03:24,680
source code which is the beautiful clear

00:03:22,280 --> 00:03:26,450
easy to read easy to understand human

00:03:24,680 --> 00:03:29,209
friendly version but your computer wants

00:03:26,450 --> 00:03:33,049
these binary instructions so how are we

00:03:29,209 --> 00:03:34,010
gonna get from one to the other there

00:03:33,049 --> 00:03:35,030
are some options there are some

00:03:34,010 --> 00:03:37,010
different ideas that have been tried

00:03:35,030 --> 00:03:39,069
over the years some languages you're

00:03:37,010 --> 00:03:41,180
going to run a program called a compiler

00:03:39,069 --> 00:03:43,819
courtesy of Rear Admiral Grace Hopper

00:03:41,180 --> 00:03:45,889
which will take your source code and

00:03:43,819 --> 00:03:47,989
transform it directly into those machine

00:03:45,889 --> 00:03:51,019
code instructions we call those compiled

00:03:47,989 --> 00:03:53,630
languages some languages you just invoke

00:03:51,019 --> 00:03:55,819
the language itself with your program it

00:03:53,630 --> 00:03:57,829
runs your program directly translating

00:03:55,819 --> 00:03:59,500
source code into machine code as it goes

00:03:57,829 --> 00:04:02,150
we call that an interpreted language

00:03:59,500 --> 00:04:03,470
people often say pythons an interpreted

00:04:02,150 --> 00:04:06,079
language we talk about a Python

00:04:03,470 --> 00:04:10,160
interpreter but there's actually a third

00:04:06,079 --> 00:04:12,739
way some languages compiled to a set of

00:04:10,160 --> 00:04:16,160
instructions that's not for any real

00:04:12,739 --> 00:04:18,350
physical CPU that exists I mean I

00:04:16,160 --> 00:04:20,690
suppose you could go build one but it

00:04:18,350 --> 00:04:22,849
doesn't exist right now these languages

00:04:20,690 --> 00:04:25,780
compile to instructions for the CPU that

00:04:22,849 --> 00:04:28,060
doesn't exist and then the interpreter

00:04:25,780 --> 00:04:30,580
is a piece of software that implements

00:04:28,060 --> 00:04:32,320
that CPU that understands those

00:04:30,580 --> 00:04:34,570
instructions and how to translate them

00:04:32,320 --> 00:04:36,310
into the specific instructions for

00:04:34,570 --> 00:04:39,520
whatever actual processor you're running

00:04:36,310 --> 00:04:41,440
it on we call that byte code there are a

00:04:39,520 --> 00:04:45,460
lot of languages that do this anybody

00:04:41,440 --> 00:04:47,200
ever use Java Java compiler bytecode

00:04:45,460 --> 00:04:48,910
you've run it on the Java Virtual

00:04:47,200 --> 00:04:51,180
Machine anybody ever use one of the

00:04:48,910 --> 00:04:55,000
dotnet languages c-sharp c-sharp

00:04:51,180 --> 00:04:58,600
compiles to bytecode runs on the.net vm

00:04:55,000 --> 00:05:02,010
and python python compiles to bytecode

00:04:58,600 --> 00:05:04,480
which runs on the Python virtual machine

00:05:02,010 --> 00:05:08,770
so let's take a look at how this works

00:05:04,480 --> 00:05:11,470
we're gonna look at Python function this

00:05:08,770 --> 00:05:13,480
calculates two Bonacci numbers so this

00:05:11,470 --> 00:05:15,970
should be pretty easy to understand

00:05:13,480 --> 00:05:18,330
we've got you know a little if we're

00:05:15,970 --> 00:05:20,110
less than two return otherwise loop

00:05:18,330 --> 00:05:23,290
figuring out what the next two Bonacci

00:05:20,110 --> 00:05:25,320
number is eventually return it how will

00:05:23,290 --> 00:05:29,320
Python actually execute this function

00:05:25,320 --> 00:05:33,400
well is anybody we're seeing a file with

00:05:29,320 --> 00:05:35,530
an extension dot py c especially if you

00:05:33,400 --> 00:05:37,960
use Python to python to use to drop

00:05:35,530 --> 00:05:40,840
these directly next to your source code

00:05:37,960 --> 00:05:42,729
in the same directory python 3 we have a

00:05:40,840 --> 00:05:44,890
directory called pi cache with double

00:05:42,729 --> 00:05:47,350
underscores that's where your py c files

00:05:44,890 --> 00:05:50,229
go you may have heard these described as

00:05:47,350 --> 00:05:52,150
you know compiled Python or some sort of

00:05:50,229 --> 00:05:55,600
you know time saver for when you rerun

00:05:52,150 --> 00:05:56,890
it again that is python bytecode that's

00:05:55,600 --> 00:05:59,080
what's in that file it's actually the

00:05:56,890 --> 00:06:01,660
binary bytecode that python compiled

00:05:59,080 --> 00:06:03,850
your source code into so next time you

00:06:01,660 --> 00:06:06,010
run that or next time you import that

00:06:03,850 --> 00:06:08,110
module Python doesn't have to compile it

00:06:06,010 --> 00:06:10,600
all over again but that's the actual

00:06:08,110 --> 00:06:13,660
form that Python wants that code in in

00:06:10,600 --> 00:06:15,669
order to be able to execute it so how

00:06:13,660 --> 00:06:17,650
could we get at this and understand

00:06:15,669 --> 00:06:20,169
what's going on well suppose you typed

00:06:17,650 --> 00:06:22,660
in that Fibonacci function into a Python

00:06:20,169 --> 00:06:25,300
interpreter and you looked at it it's a

00:06:22,660 --> 00:06:27,039
function object and it would have this

00:06:25,300 --> 00:06:32,800
little attribute on it double underscore

00:06:27,039 --> 00:06:34,750
code this is a Python code object

00:06:32,800 --> 00:06:36,580
did nobody go to Emily Morehouse's talk

00:06:34,750 --> 00:06:38,849
yesterday about parsing and the ast

00:06:36,580 --> 00:06:40,679
there's really good talk and you

00:06:38,849 --> 00:06:42,389
learned a little bit about code objects

00:06:40,679 --> 00:06:43,349
and how Python uses them we're gonna

00:06:42,389 --> 00:06:45,179
look at some slightly different

00:06:43,349 --> 00:06:46,619
attributes than what Emily was talking

00:06:45,179 --> 00:06:48,389
about because we're looking at the other

00:06:46,619 --> 00:06:51,059
side of this is what happens after the

00:06:48,389 --> 00:06:52,919
parsing so this code object this

00:06:51,059 --> 00:06:54,569
contains everything Python needs to

00:06:52,919 --> 00:06:56,939
execute the function and it has

00:06:54,569 --> 00:06:59,249
attributes we can poke at to see how

00:06:56,939 --> 00:07:02,069
it's going to do that so one interesting

00:06:59,249 --> 00:07:04,860
attribute is called Co Const this is a

00:07:02,069 --> 00:07:06,990
tuple it contains all of the literal or

00:07:04,860 --> 00:07:09,389
constant values that were referenced in

00:07:06,990 --> 00:07:11,669
the body of our function so we see our

00:07:09,389 --> 00:07:13,979
integers you ate a 2 in there we had a 0

00:07:11,669 --> 00:07:17,580
we had a 1 we had a tuple of a 0 and a 1

00:07:13,979 --> 00:07:20,309
and we have none now none is kind of

00:07:17,580 --> 00:07:22,679
weird to see there because the body of

00:07:20,309 --> 00:07:24,869
that function didn't include a literal

00:07:22,679 --> 00:07:25,319
none anywhere the Python put it in there

00:07:24,869 --> 00:07:28,259
anyway

00:07:25,319 --> 00:07:31,409
there's a reason for that which is if

00:07:28,259 --> 00:07:33,719
Python is executing our function and it

00:07:31,409 --> 00:07:36,569
finishes executing without reaching any

00:07:33,719 --> 00:07:40,830
explicit return statement it's going to

00:07:36,569 --> 00:07:43,589
return none so Python needs to have none

00:07:40,830 --> 00:07:45,089
already loaded up already ready to go in

00:07:43,589 --> 00:07:47,069
that tuple so it can reference it

00:07:45,089 --> 00:07:48,959
because the time Python is compiling

00:07:47,069 --> 00:07:51,029
this it has no way of knowing whether

00:07:48,959 --> 00:07:52,589
any explicit return statement is ever

00:07:51,029 --> 00:07:55,889
going to be reached in fact that's a

00:07:52,589 --> 00:07:59,599
really hard / impossible thing to do in

00:07:55,889 --> 00:08:01,979
advance so these are our literals

00:07:59,599 --> 00:08:04,589
there's another one called Co VAR names

00:08:01,979 --> 00:08:06,599
this is a tuple containing the names of

00:08:04,589 --> 00:08:09,659
all the local variables of the function

00:08:06,599 --> 00:08:12,479
we had 3 of those and current.next so

00:08:09,659 --> 00:08:15,269
they're all in there then we have this

00:08:12,479 --> 00:08:17,639
one called Co names this would be any

00:08:15,269 --> 00:08:18,869
non-local names that we referenced in

00:08:17,639 --> 00:08:20,879
the body of the function now the

00:08:18,869 --> 00:08:22,679
Fibonacci function didn't include any

00:08:20,879 --> 00:08:25,740
non-local names so this is an empty

00:08:22,679 --> 00:08:30,649
tuple and finally we're gonna get to the

00:08:25,740 --> 00:08:33,419
fun part Co code this is the bytecode of

00:08:30,649 --> 00:08:36,300
the Fibonacci function this is not a

00:08:33,419 --> 00:08:38,219
string this is a Python bites object

00:08:36,300 --> 00:08:42,269
because this is being done in Python 3

00:08:38,219 --> 00:08:44,009
like it should be some of these

00:08:42,269 --> 00:08:46,019
characters do print or some of these

00:08:44,009 --> 00:08:47,309
bytes do print as ASCII characters

00:08:46,019 --> 00:08:49,470
that's just because that's how Python

00:08:47,309 --> 00:08:51,810
defaults to representing a bytes object

00:08:49,470 --> 00:08:55,200
but it's not a string we can't treat it

00:08:51,810 --> 00:08:57,210
a string it's a sequence of bytes now

00:08:55,200 --> 00:09:00,450
suppose we want to understand what's

00:08:57,210 --> 00:09:02,670
going on in this big long sequence of

00:09:00,450 --> 00:09:06,420
bytes well we can look at it that first

00:09:02,670 --> 00:09:08,370
byte printed as a pipe character now I

00:09:06,420 --> 00:09:10,920
don't know about any of you I have not

00:09:08,370 --> 00:09:13,350
memorized an ASCII table so I don't

00:09:10,920 --> 00:09:15,330
actually know what decimal byte value

00:09:13,350 --> 00:09:18,570
produces a pipe character in ascii

00:09:15,330 --> 00:09:21,029
fortunately I can ask Python and it will

00:09:18,570 --> 00:09:24,270
tell me Python will tell me the pipe

00:09:21,029 --> 00:09:26,310
character is decimal value 1 2 4 so the

00:09:24,270 --> 00:09:30,300
first byte of that byte code was a byte

00:09:26,310 --> 00:09:33,630
with value 1 2 4 that still doesn't tell

00:09:30,300 --> 00:09:36,060
me very much luckily there's a module in

00:09:33,630 --> 00:09:38,160
the standard library called disk with

00:09:36,060 --> 00:09:39,960
this list in it called up name it's a

00:09:38,160 --> 00:09:42,960
list of all the Python bytecode

00:09:39,960 --> 00:09:44,910
instructions and at each index is the

00:09:42,960 --> 00:09:46,620
instruction name that goes with that

00:09:44,910 --> 00:09:48,420
decimal value so what's the hundred and

00:09:46,620 --> 00:09:52,440
twenty fourth bytecode operation it's

00:09:48,420 --> 00:09:54,450
called load fast ok so now we know the

00:09:52,440 --> 00:09:57,270
first byte of this is a decimal one to

00:09:54,450 --> 00:10:00,030
four that's a load fast instruction the

00:09:57,270 --> 00:10:02,790
next byte of it was a zero so it's a

00:10:00,030 --> 00:10:05,030
load fast zero I don't know how much

00:10:02,790 --> 00:10:08,310
attention you paid to that first slide

00:10:05,030 --> 00:10:12,420
but that's what it started with load

00:10:08,310 --> 00:10:15,180
fast zero that's a Python bytecode

00:10:12,420 --> 00:10:18,960
instruction and specifically what this

00:10:15,180 --> 00:10:21,480
means is look up in that sea of our

00:10:18,960 --> 00:10:26,910
names tuple whatever item is at index

00:10:21,480 --> 00:10:29,820
zero which is local variable n push that

00:10:26,910 --> 00:10:31,200
on top of the evaluation stack we're

00:10:29,820 --> 00:10:33,690
gonna get to what the evaluation stack

00:10:31,200 --> 00:10:35,190
is in just a minute but first I'm gonna

00:10:33,690 --> 00:10:38,570
show you the shortcut I showed you the

00:10:35,190 --> 00:10:41,790
hard laborious way to read byte code

00:10:38,570 --> 00:10:44,459
here's the easy way use the disk module

00:10:41,790 --> 00:10:47,310
import disks call the function disk disk

00:10:44,459 --> 00:10:48,900
you can pass in almost anything you want

00:10:47,310 --> 00:10:50,850
to here and passing in a function you

00:10:48,900 --> 00:10:52,740
can pass in strings of source code you

00:10:50,850 --> 00:10:56,370
can pass in all sorts of Python objects

00:10:52,740 --> 00:10:58,320
and this will disassemble them print a

00:10:56,370 --> 00:11:00,930
human readable version of the byte code

00:10:58,320 --> 00:11:02,280
that they compile into and what you'll

00:11:00,930 --> 00:11:05,310
get out of that from that Fibonacci

00:11:02,280 --> 00:11:08,850
function is the contents of that first

00:11:05,310 --> 00:11:11,130
Lyde this is the bytecode of that

00:11:08,850 --> 00:11:12,900
Fibonacci function there's a couple

00:11:11,130 --> 00:11:14,700
things that are worth knowing here this

00:11:12,900 --> 00:11:17,130
output you'll see over on the left

00:11:14,700 --> 00:11:18,360
you'll see these numbers two three four

00:11:17,130 --> 00:11:20,610
five six seven eight

00:11:18,360 --> 00:11:22,910
those are the line numbers in the source

00:11:20,610 --> 00:11:25,470
code that's where each lines

00:11:22,910 --> 00:11:27,480
instructions are beginning you'll notice

00:11:25,470 --> 00:11:30,300
each line of Python source code turned

00:11:27,480 --> 00:11:32,250
into multiple bytecode instructions and

00:11:30,300 --> 00:11:34,430
then each instruction has a number next

00:11:32,250 --> 00:11:38,240
to it as well and they're always even

00:11:34,430 --> 00:11:41,610
does anybody want to guess why that is

00:11:38,240 --> 00:11:44,070
this is a nuez of python 3.6 those

00:11:41,610 --> 00:11:46,680
numbers are the offsets into the byte

00:11:44,070 --> 00:11:49,620
code if you grabbed that bytes object Co

00:11:46,680 --> 00:11:53,279
code on that code object and indexed

00:11:49,620 --> 00:11:57,600
into it say go to index 6 you would find

00:11:53,279 --> 00:11:59,550
a pop jump if false up code there the

00:11:57,600 --> 00:12:02,190
reason that those are even numbers is as

00:11:59,550 --> 00:12:04,740
of Python 3.6 not every byte code

00:12:02,190 --> 00:12:07,560
instruction actually uses an argument

00:12:04,740 --> 00:12:08,910
but as of Python 3.6 they all get an

00:12:07,560 --> 00:12:10,950
argument whether they want one or not

00:12:08,910 --> 00:12:14,460
because that makes every one of these

00:12:10,950 --> 00:12:16,680
exactly two bytes which makes it much

00:12:14,460 --> 00:12:19,140
easier to work with there are some

00:12:16,680 --> 00:12:21,210
instructions that if their argument gets

00:12:19,140 --> 00:12:22,680
too large to fit in a byte can actually

00:12:21,210 --> 00:12:24,870
split over multiple bytes but it's

00:12:22,680 --> 00:12:28,020
always a multiple of two bytes if you're

00:12:24,870 --> 00:12:29,760
looking at python 3.5 or earlier and you

00:12:28,020 --> 00:12:31,650
put in this same function you might see

00:12:29,760 --> 00:12:33,990
some odd-numbered offsets because not

00:12:31,650 --> 00:12:37,620
everything actually got an argument in

00:12:33,990 --> 00:12:40,200
python 3.5 one other thing worth noting

00:12:37,620 --> 00:12:42,300
here is we see some rate pointing angle

00:12:40,200 --> 00:12:44,839
brackets we see them like line four

00:12:42,300 --> 00:12:47,730
offset 12 at that load Const

00:12:44,839 --> 00:12:50,760
line five offset 22

00:12:47,730 --> 00:12:53,100
those are jump targets this is Python

00:12:50,760 --> 00:12:55,140
telling you these are instructions that

00:12:53,100 --> 00:12:57,990
may be jumped to by some other

00:12:55,140 --> 00:12:59,850
instruction that's going on here so you

00:12:57,990 --> 00:13:01,440
remember that Fibonacci function had a

00:12:59,850 --> 00:13:04,440
loop in it with the test at the

00:13:01,440 --> 00:13:06,360
beginning every time we go to the

00:13:04,440 --> 00:13:08,580
beginning of the loop we're doing a jump

00:13:06,360 --> 00:13:10,170
back to an earlier instruction those

00:13:08,580 --> 00:13:12,480
angle brackets are just there to tell

00:13:10,170 --> 00:13:12,830
you these are potential jump targets of

00:13:12,480 --> 00:13:17,090
other

00:13:12,830 --> 00:13:19,520
instructions so now we've seen some byte

00:13:17,090 --> 00:13:22,010
code we understand how we can actually

00:13:19,520 --> 00:13:24,020
get at the raw byte code as bytes how we

00:13:22,010 --> 00:13:26,780
could decipher it manual if we wanted to

00:13:24,020 --> 00:13:29,330
and now we know the easy shortcut we got

00:13:26,780 --> 00:13:33,080
actually talked about how Python works

00:13:29,330 --> 00:13:35,870
how it uses byte code so pythons VM the

00:13:33,080 --> 00:13:38,660
virtual machine in C Python is stack

00:13:35,870 --> 00:13:40,940
oriented it's built around the stack as

00:13:38,660 --> 00:13:43,340
a fundamental data structure if you've

00:13:40,940 --> 00:13:45,650
never worked with stacks they're sort of

00:13:43,340 --> 00:13:48,170
list like but they support two very

00:13:45,650 --> 00:13:49,790
important operations a stack has has two

00:13:48,170 --> 00:13:52,160
ends which we'll call a top and a bottom

00:13:49,790 --> 00:13:55,520
you have a push operation which means

00:13:52,160 --> 00:13:57,770
take this value put it on top and a pop

00:13:55,520 --> 00:14:01,820
operation which means take whatever is

00:13:57,770 --> 00:14:04,190
on top remove it return it each time you

00:14:01,820 --> 00:14:07,370
call a function in Python you're pushing

00:14:04,190 --> 00:14:09,680
a new entry a call frame on to a call

00:14:07,370 --> 00:14:11,840
stack that keeps track of every function

00:14:09,680 --> 00:14:14,360
being executed when one of those

00:14:11,840 --> 00:14:17,210
functions returns that call frame gets

00:14:14,360 --> 00:14:18,740
popped right back off the stack the

00:14:17,210 --> 00:14:21,350
return value gets pushed into the

00:14:18,740 --> 00:14:23,270
calling frame so you know if somebody

00:14:21,350 --> 00:14:24,800
calls bar Fibonacci function as we'll

00:14:23,270 --> 00:14:28,460
see in a minute we get that return value

00:14:24,800 --> 00:14:31,370
back now while you're executing this in

00:14:28,460 --> 00:14:34,160
that call frame in the call stack we're

00:14:31,370 --> 00:14:36,500
gonna use two more stacks one is an

00:14:34,160 --> 00:14:36,980
evaluation stack sometimes you also see

00:14:36,500 --> 00:14:40,220
called

00:14:36,980 --> 00:14:41,780
a data stack this is where Python is

00:14:40,220 --> 00:14:43,580
going to keep all of the data it's

00:14:41,780 --> 00:14:46,820
actually working with this is where most

00:14:43,580 --> 00:14:49,160
of the execution happens inside a Python

00:14:46,820 --> 00:14:50,990
function most of the instructions are

00:14:49,160 --> 00:14:53,210
about manipulating what's on top of that

00:14:50,990 --> 00:14:55,700
evaluation stack there's also a second

00:14:53,210 --> 00:14:57,440
one called a block stack a block stack

00:14:55,700 --> 00:15:00,200
keeps track of how many different blocks

00:14:57,440 --> 00:15:03,290
are active right now blocks are things

00:15:00,200 --> 00:15:04,100
like a try except with block you know

00:15:03,290 --> 00:15:06,440
anything like that

00:15:04,100 --> 00:15:09,050
Python needs that because there are some

00:15:06,440 --> 00:15:11,450
statements like break and continue that

00:15:09,050 --> 00:15:13,460
affect whatever the current block is so

00:15:11,450 --> 00:15:15,560
Python needs to know what is the current

00:15:13,460 --> 00:15:17,900
block and it does that by simply

00:15:15,560 --> 00:15:19,610
managing a stack like every time you go

00:15:17,900 --> 00:15:21,170
into certain constructs like this it

00:15:19,610 --> 00:15:24,310
pushes a new item on the block stack

00:15:21,170 --> 00:15:27,650
when it finishes pops that item back off

00:15:24,310 --> 00:15:29,720
so let's look at how we execute a

00:15:27,650 --> 00:15:31,850
function suppose we want to know the

00:15:29,720 --> 00:15:33,800
eighth Fibonacci number we're just going

00:15:31,850 --> 00:15:35,900
to ask Python to calculate that using

00:15:33,800 --> 00:15:39,590
our Fibonacci function that turns into

00:15:35,900 --> 00:15:42,710
three bytecode instructions load global

00:15:39,590 --> 00:15:44,330
load Const call function so let's take a

00:15:42,710 --> 00:15:46,460
look at what's going on here we start

00:15:44,330 --> 00:15:48,710
this we've got an empty evaluation stack

00:15:46,460 --> 00:15:52,400
so we get to our first instruction load

00:15:48,710 --> 00:15:54,800
global we're going to load the global

00:15:52,400 --> 00:15:57,440
name fib which is our Fibonacci function

00:15:54,800 --> 00:15:59,750
this is what's gonna go look in that Co

00:15:57,440 --> 00:16:01,490
names tuple that tuple of non local

00:15:59,750 --> 00:16:04,010
names it's going to look up that

00:16:01,490 --> 00:16:06,530
function push the function object on top

00:16:04,010 --> 00:16:09,170
of our evaluation stack next we're gonna

00:16:06,530 --> 00:16:10,610
have a load Const in this case it's

00:16:09,170 --> 00:16:12,290
going to get the first item out of our

00:16:10,610 --> 00:16:15,440
tuple of constants because remember Ida

00:16:12,290 --> 00:16:17,560
index zero is none so the first item in

00:16:15,440 --> 00:16:19,550
there at index one is the integer eight

00:16:17,560 --> 00:16:22,850
which is gonna be the argument to our

00:16:19,550 --> 00:16:26,360
function push that on to the stack then

00:16:22,850 --> 00:16:29,720
we hit a call function instruction has

00:16:26,360 --> 00:16:31,850
an argument of one the way Python is

00:16:29,720 --> 00:16:34,670
calling this function we're only using

00:16:31,850 --> 00:16:36,890
positional arguments is it pushes the

00:16:34,670 --> 00:16:39,530
function onto the stack pushes the

00:16:36,890 --> 00:16:42,260
positional arguments on top of it then

00:16:39,530 --> 00:16:43,700
call function the argument is the number

00:16:42,260 --> 00:16:46,340
of positional arguments to the function

00:16:43,700 --> 00:16:48,470
it pops all those off it knows the

00:16:46,340 --> 00:16:51,170
function is the next thing there pops

00:16:48,470 --> 00:16:54,010
that off pushes a new stack onto the

00:16:51,170 --> 00:16:56,930
call frame or onto the call stack

00:16:54,010 --> 00:17:00,310
execute our Fibonacci function inside

00:16:56,930 --> 00:17:03,339
that new frame gets a return value of 21

00:17:00,310 --> 00:17:06,020
pops the call stack get that frame off

00:17:03,339 --> 00:17:08,030
return value goes on to the top of our

00:17:06,020 --> 00:17:10,370
evaluation stack right here where we

00:17:08,030 --> 00:17:12,380
called the Fibonacci function and that

00:17:10,370 --> 00:17:14,329
is step by step how python is going to

00:17:12,380 --> 00:17:16,190
execute this function now the call

00:17:14,329 --> 00:17:18,290
function instruction is only for

00:17:16,190 --> 00:17:20,720
function calls that involve positional

00:17:18,290 --> 00:17:22,250
arguments if you used keyword arguments

00:17:20,720 --> 00:17:26,120
there's a different instruction called

00:17:22,250 --> 00:17:30,890
call function kW if you use any of the

00:17:26,120 --> 00:17:33,170
iterator or mapping unpacking syntax the

00:17:30,890 --> 00:17:34,640
asterisk double Asterix and syntax in

00:17:33,170 --> 00:17:36,450
your function call there's one called

00:17:34,640 --> 00:17:39,299
call function e^x

00:17:36,450 --> 00:17:42,480
that gets used to do that so that's how

00:17:39,299 --> 00:17:45,539
we're executing a function now if you

00:17:42,480 --> 00:17:47,490
want to you can go dig into the Python

00:17:45,539 --> 00:17:50,970
standard library documentation the dis

00:17:47,490 --> 00:17:53,340
module is extremely handy it has a list

00:17:50,970 --> 00:17:55,620
of all of the things in the module all

00:17:53,340 --> 00:17:58,519
of the bytecode instructions what they

00:17:55,620 --> 00:18:00,419
do what kind of arguments they take

00:17:58,519 --> 00:18:03,120
anything you could want to know about

00:18:00,419 --> 00:18:05,669
how Python bytecode works is all in

00:18:03,120 --> 00:18:07,159
there there are a couple things I want

00:18:05,669 --> 00:18:09,690
to point out though they're kind of cool

00:18:07,159 --> 00:18:12,929
one is another function that's in that

00:18:09,690 --> 00:18:15,210
module it's called disty be how many

00:18:12,929 --> 00:18:17,220
times have you looked at an exception

00:18:15,210 --> 00:18:18,269
and wondered where the heck did that

00:18:17,220 --> 00:18:21,480
come from

00:18:18,269 --> 00:18:25,080
what made that happen well this function

00:18:21,480 --> 00:18:27,330
disk dot dis TB you can call it either

00:18:25,080 --> 00:18:29,279
right after an exception has occurred or

00:18:27,330 --> 00:18:31,049
if you have a python trace back object

00:18:29,279 --> 00:18:33,299
that you've captured somehow you can

00:18:31,049 --> 00:18:36,990
pass it in and what it will do is

00:18:33,299 --> 00:18:39,600
disassemble whatever call frame on the

00:18:36,990 --> 00:18:41,580
call stack was active at the time show

00:18:39,600 --> 00:18:43,769
you the byte code that was being

00:18:41,580 --> 00:18:46,500
executed and give you a pointer

00:18:43,769 --> 00:18:48,990
specifically to the instruction where

00:18:46,500 --> 00:18:51,480
that exception got raised so for example

00:18:48,990 --> 00:18:54,149
here you can see I divided by 0 whoops

00:18:51,480 --> 00:18:57,269
Python raised an exception import dis

00:18:54,149 --> 00:19:00,870
dis TB and here I can see exactly what

00:18:57,269 --> 00:19:02,610
happened if you really want to

00:19:00,870 --> 00:19:04,500
understand what's going on I'm gonna

00:19:02,610 --> 00:19:07,139
have a link at the very end to where you

00:19:04,500 --> 00:19:08,700
can go look at the actual internals of

00:19:07,139 --> 00:19:11,720
the Python interpreter which are written

00:19:08,700 --> 00:19:14,730
in C this is the beginning of the actual

00:19:11,720 --> 00:19:16,620
real honest-to-goodness Python bytecode

00:19:14,730 --> 00:19:19,440
interpreter as it existed on github

00:19:16,620 --> 00:19:22,679
about two hours ago it is a gigantic

00:19:19,440 --> 00:19:25,019
switch statement that simply looks at

00:19:22,679 --> 00:19:27,389
whatever decimal value instruction was

00:19:25,019 --> 00:19:31,169
passed into it and figures out what to

00:19:27,389 --> 00:19:34,590
do with that so now we know some things

00:19:31,169 --> 00:19:37,260
about bytecode but what can we learn

00:19:34,590 --> 00:19:40,889
from this what use is it what good is it

00:19:37,260 --> 00:19:46,460
to us to know about bytecode has anybody

00:19:40,889 --> 00:19:48,990
here ever written any forth or if your

00:19:46,460 --> 00:19:50,220
little newer maybe played with a

00:19:48,990 --> 00:19:52,320
language like factor

00:19:50,220 --> 00:19:54,330
or heard of languages like forth and

00:19:52,320 --> 00:19:57,539
factor these are what are called stack

00:19:54,330 --> 00:19:59,730
oriented programming languages Python

00:19:57,539 --> 00:20:01,950
virtual machine is also stack oriented

00:19:59,730 --> 00:20:03,509
we saw this it all Orient's around

00:20:01,950 --> 00:20:05,250
pushing things on top of a stack

00:20:03,509 --> 00:20:08,039
manipulating the top of the stack

00:20:05,250 --> 00:20:09,929
popping things back off this is a very

00:20:08,039 --> 00:20:11,129
different way of doing programming than

00:20:09,929 --> 00:20:13,250
what we're used to but there have been

00:20:11,129 --> 00:20:15,330
entire languages built around it and

00:20:13,250 --> 00:20:18,000
understanding this way of programming is

00:20:15,330 --> 00:20:20,580
actually kind of cool you may never even

00:20:18,000 --> 00:20:22,889
get any practical use out of it but it's

00:20:20,580 --> 00:20:24,389
a thing you can learn and it's a thing

00:20:22,889 --> 00:20:25,830
will broaden your understanding of

00:20:24,389 --> 00:20:27,419
different styles of programming in

00:20:25,830 --> 00:20:30,299
different ways you can do programming

00:20:27,419 --> 00:20:32,340
and it really is amazing if you look at

00:20:30,299 --> 00:20:34,919
a stack oriented language or a stack

00:20:32,340 --> 00:20:37,679
oriented virtual machine to see just how

00:20:34,919 --> 00:20:39,870
much you can do with so few instructions

00:20:37,679 --> 00:20:42,690
and so few basic operations on a stack

00:20:39,870 --> 00:20:44,039
it's actually really really neat of

00:20:42,690 --> 00:20:46,830
course there are also some practical

00:20:44,039 --> 00:20:49,230
purposes people like to joke about see

00:20:46,830 --> 00:20:51,570
they like to call see a sort of portable

00:20:49,230 --> 00:20:54,389
assembler or portable assembly language

00:20:51,570 --> 00:20:57,600
because you can write C and read C and

00:20:54,389 --> 00:20:59,820
reason pretty well about what kind of

00:20:57,600 --> 00:21:03,029
machine code a given bit of C is going

00:20:59,820 --> 00:21:05,639
to turn into Python is sort of the same

00:21:03,029 --> 00:21:07,379
way we can learn Python bytecode and

00:21:05,639 --> 00:21:10,080
learn how to understand it and then we

00:21:07,379 --> 00:21:11,789
can reason about what kind of bytecode

00:21:10,080 --> 00:21:14,399
is Python going to turn my source code

00:21:11,789 --> 00:21:16,019
into how is this actually going to

00:21:14,399 --> 00:21:19,350
execute when I hand it off to the Python

00:21:16,019 --> 00:21:22,500
interpreter studying that can give you

00:21:19,350 --> 00:21:24,870
some insights also you can learn a bit

00:21:22,500 --> 00:21:26,789
about how Python works and how Python

00:21:24,870 --> 00:21:28,679
can help you and then of course what

00:21:26,789 --> 00:21:30,649
everybody wants to know is how you can

00:21:28,679 --> 00:21:33,720
look at it and reason about performance

00:21:30,649 --> 00:21:35,639
so here's a couple of functions both of

00:21:33,720 --> 00:21:37,769
these do the same thing they both

00:21:35,639 --> 00:21:40,139
calculate the number of seconds in a

00:21:37,769 --> 00:21:42,029
week except one of them is faster than

00:21:40,139 --> 00:21:46,529
the other can you guess which one it is

00:21:42,029 --> 00:21:49,980
I very cleverly hidden it I want you to

00:21:46,529 --> 00:21:52,590
stop and think why would one of these

00:21:49,980 --> 00:21:55,529
functions be faster than the other and

00:21:52,590 --> 00:21:56,820
how could we figure out why that is and

00:21:55,529 --> 00:21:59,309
the answer is we can look at the byte

00:21:56,820 --> 00:22:02,159
code we can ask the Dismal to

00:21:59,309 --> 00:22:04,320
disassemble these for us there's a big

00:22:02,159 --> 00:22:07,019
difference in what those turn

00:22:04,320 --> 00:22:09,210
into you notice that first one stored

00:22:07,019 --> 00:22:12,419
the number of seconds in a day in a

00:22:09,210 --> 00:22:15,690
variable which meant we had to load a

00:22:12,419 --> 00:22:17,549
constant Stewart in a variable then look

00:22:15,690 --> 00:22:19,649
up what was stored in a variable load

00:22:17,549 --> 00:22:22,169
another constant do a multiplication and

00:22:19,649 --> 00:22:24,600
finally return the value the second one

00:22:22,169 --> 00:22:27,210
only used multiplication with two

00:22:24,600 --> 00:22:30,320
integer constants and Python when it was

00:22:27,210 --> 00:22:32,549
compiling this noticed we're using

00:22:30,320 --> 00:22:35,100
arithmetic on to editor constants

00:22:32,549 --> 00:22:38,580
they're not going to change the values

00:22:35,100 --> 00:22:41,759
of seven and 86,400 are not going to

00:22:38,580 --> 00:22:43,500
change anytime soon so python can just

00:22:41,759 --> 00:22:45,870
optimize that away python can do that

00:22:43,500 --> 00:22:49,200
multiplication at compile time and now

00:22:45,870 --> 00:22:51,779
this function is just returned 600 4800

00:22:49,200 --> 00:22:53,610
there's nothing else to it so it's kind

00:22:51,779 --> 00:22:55,320
of a cool optimization Python will do

00:22:53,610 --> 00:22:57,929
that sort of constant folding anytime

00:22:55,320 --> 00:23:00,450
you have these operations on constants

00:22:57,929 --> 00:23:03,120
that it can optimize a way it isn't the

00:23:00,450 --> 00:23:05,759
only sneaky offer sneaky optimization

00:23:03,120 --> 00:23:08,399
Python does has anybody heard about

00:23:05,759 --> 00:23:11,820
specter and meltdown anybody familiar

00:23:08,399 --> 00:23:14,820
with those these were attacks against

00:23:11,820 --> 00:23:16,649
branch prediction where processors try

00:23:14,820 --> 00:23:18,629
to predict what's gonna happen on the

00:23:16,649 --> 00:23:20,370
other end of an if statement Python

00:23:18,629 --> 00:23:22,320
actually tries to predict what bytecode

00:23:20,370 --> 00:23:24,629
operations will happen some byte code

00:23:22,320 --> 00:23:27,059
operations come in pairs like a

00:23:24,629 --> 00:23:29,820
comparison is usually followed by a jump

00:23:27,059 --> 00:23:31,860
instruction of some type and the Python

00:23:29,820 --> 00:23:33,330
bytecode interpreter optimizes this and

00:23:31,860 --> 00:23:35,789
tries to predict what's going to come

00:23:33,330 --> 00:23:37,620
next in order to work with your CPUs

00:23:35,789 --> 00:23:39,269
branch predictor to make these run even

00:23:37,620 --> 00:23:41,929
faster so there are some cool things

00:23:39,269 --> 00:23:44,940
going on here you can also answer some

00:23:41,929 --> 00:23:46,350
perennial questions about Python

00:23:44,940 --> 00:23:48,470
performance people always ask things

00:23:46,350 --> 00:23:51,330
like why is a literal list or a literal

00:23:48,470 --> 00:23:55,350
dictionary faster than calling lists or

00:23:51,330 --> 00:23:57,720
dict well right there's your answer we

00:23:55,350 --> 00:24:00,539
just do a literal dict using that brief

00:23:57,720 --> 00:24:02,519
syntax that's two instructions we

00:24:00,539 --> 00:24:04,049
actually call the Dix function that's

00:24:02,519 --> 00:24:06,450
three instructions and one of them is a

00:24:04,049 --> 00:24:07,889
call instruction so we actually have to

00:24:06,450 --> 00:24:10,200
push another frame on the call stack

00:24:07,889 --> 00:24:12,960
execute a function body in there pop it

00:24:10,200 --> 00:24:15,750
back off you can see this in your own

00:24:12,960 --> 00:24:17,220
code here's a simple example this is

00:24:15,750 --> 00:24:17,760
just a function that calculates the

00:24:17,220 --> 00:24:20,550
first

00:24:17,760 --> 00:24:22,320
perfect squares and this isn't the whole

00:24:20,550 --> 00:24:25,800
bytecode this is just the body of that

00:24:22,320 --> 00:24:28,380
loop that while loop 15 bytecode

00:24:25,800 --> 00:24:30,600
instructions long we do better than that

00:24:28,380 --> 00:24:34,590
what if we change that while loop with a

00:24:30,600 --> 00:24:36,210
counter to a four loop with a range well

00:24:34,590 --> 00:24:39,300
suddenly it's a much shorter loop body

00:24:36,210 --> 00:24:42,030
now it's nine instructions what if we go

00:24:39,300 --> 00:24:43,310
really idiomatic Python and say this

00:24:42,030 --> 00:24:47,190
really ought to be a list comprehension

00:24:43,310 --> 00:24:48,900
what's that gonna turn into now the

00:24:47,190 --> 00:24:54,000
whole function body is nine instructions

00:24:48,900 --> 00:24:57,720
long but this is deceptive this is why I

00:24:54,000 --> 00:25:00,060
put this up here notice it's nine

00:24:57,720 --> 00:25:02,220
instructions but it involves building a

00:25:00,060 --> 00:25:03,750
function and calling a function so it

00:25:02,220 --> 00:25:05,730
has to push another frame onto the call

00:25:03,750 --> 00:25:08,510
stack execute another function body in

00:25:05,730 --> 00:25:10,320
there pop it back off return a value

00:25:08,510 --> 00:25:13,380
that's a slightly more expensive

00:25:10,320 --> 00:25:15,930
operation even though this is fewer

00:25:13,380 --> 00:25:18,300
bytecode instructions not all bytecode

00:25:15,930 --> 00:25:21,510
instructions are equally expensive to

00:25:18,300 --> 00:25:23,040
execute so this is where we start

00:25:21,510 --> 00:25:24,570
talking about comparing different

00:25:23,040 --> 00:25:26,220
bytecode at different bytecode

00:25:24,570 --> 00:25:28,380
operations and people always want to

00:25:26,220 --> 00:25:30,300
know about these micro optimizations the

00:25:28,380 --> 00:25:32,790
very first thing I want to tell you is

00:25:30,300 --> 00:25:35,130
Python is slow if you're worrying about

00:25:32,790 --> 00:25:37,260
how fast a Python bytecode operation is

00:25:35,130 --> 00:25:39,720
you're probably missing the forest for

00:25:37,260 --> 00:25:42,300
the trees because python is so much

00:25:39,720 --> 00:25:43,830
slower than C that it's not even worth

00:25:42,300 --> 00:25:46,110
worrying about that kind of micro

00:25:43,830 --> 00:25:49,440
optimization if you want to learn how to

00:25:46,110 --> 00:25:52,320
write really fast Python really blazing

00:25:49,440 --> 00:25:54,450
great performance Python the first thing

00:25:52,320 --> 00:25:56,520
you should do is take a good look

00:25:54,450 --> 00:25:58,760
through the standard library standard

00:25:56,520 --> 00:26:01,260
modules built-in functions and classes

00:25:58,760 --> 00:26:03,270
find out which of them are implemented

00:26:01,260 --> 00:26:05,460
in C versus which ones are implemented

00:26:03,270 --> 00:26:07,530
in Python because the speed difference

00:26:05,460 --> 00:26:09,450
there like some of these bytecode

00:26:07,530 --> 00:26:10,230
instructions you might gain you know

00:26:09,450 --> 00:26:12,360
this much

00:26:10,230 --> 00:26:16,610
whereas getting it in C you're gonna

00:26:12,360 --> 00:26:18,690
gain this much it's just no contest but

00:26:16,610 --> 00:26:22,830
you probably want some general

00:26:18,690 --> 00:26:24,840
guidelines so here are a few you ever

00:26:22,830 --> 00:26:27,840
seen a Python optimization guide that

00:26:24,840 --> 00:26:30,310
says don't refer to names inside a loop

00:26:27,840 --> 00:26:32,560
always alias it to something and then

00:26:30,310 --> 00:26:35,830
the alias inside the loop this is why

00:26:32,560 --> 00:26:38,410
not all load operations are equal load

00:26:35,830 --> 00:26:40,630
constant load fast are very fast load

00:26:38,410 --> 00:26:43,900
name load global are comparatively quite

00:26:40,630 --> 00:26:45,880
slow going into the details of why it's

00:26:43,900 --> 00:26:47,920
because the lookups for non local names

00:26:45,880 --> 00:26:49,840
can be fairly complex it may have to

00:26:47,920 --> 00:26:52,360
search in multiple namespaces before it

00:26:49,840 --> 00:26:53,950
finally finds what it's looking for if

00:26:52,360 --> 00:26:56,050
you go look at the actual interpreter

00:26:53,950 --> 00:26:57,490
implementation you can see the

00:26:56,050 --> 00:27:01,510
implementations of these instructions

00:26:57,490 --> 00:27:03,430
are pretty large another thing loops and

00:27:01,510 --> 00:27:06,100
blocks are really expensive avoid them

00:27:03,430 --> 00:27:08,230
if you can you'll see these instructions

00:27:06,100 --> 00:27:10,870
sort of jump out at you set up loop set

00:27:08,230 --> 00:27:13,870
up with set up exception anytime you

00:27:10,870 --> 00:27:15,880
enter or exit a loop or a block or

00:27:13,870 --> 00:27:18,130
anything like that you need multiple

00:27:15,880 --> 00:27:19,660
instructions to get into the loop set up

00:27:18,130 --> 00:27:22,210
all the context push on to the block

00:27:19,660 --> 00:27:24,220
stack execute the body of the loop jump

00:27:22,210 --> 00:27:26,140
back if you're if you're doing the loop

00:27:24,220 --> 00:27:27,850
the jumps back then finally pop

00:27:26,140 --> 00:27:30,580
everything back off and clean up that's

00:27:27,850 --> 00:27:34,960
an expensive operation avoid that one if

00:27:30,580 --> 00:27:36,880
you can attribute accesses dictionary

00:27:34,960 --> 00:27:38,920
lookups list indexing all of these

00:27:36,880 --> 00:27:42,430
things really stick out in byte code

00:27:38,920 --> 00:27:44,350
these load ad or binary subscript C

00:27:42,430 --> 00:27:45,850
people say if you need something out of

00:27:44,350 --> 00:27:47,740
a dictionary or something out of a list

00:27:45,850 --> 00:27:49,240
and you're gonna loop and you're gonna

00:27:47,740 --> 00:27:51,520
refer to it every time through the loop

00:27:49,240 --> 00:27:53,260
alias it to a local variable before you

00:27:51,520 --> 00:27:55,000
do that because otherwise you're doing

00:27:53,260 --> 00:27:57,040
this expensive look up every single time

00:27:55,000 --> 00:28:01,030
through the loop these are relatively

00:27:57,040 --> 00:28:03,100
expensive bytecode instructions a lot

00:28:01,030 --> 00:28:05,170
more of this you can learn by sort of

00:28:03,100 --> 00:28:06,460
looking through the documentation for

00:28:05,170 --> 00:28:08,190
the disk module look at all these

00:28:06,460 --> 00:28:10,900
different operations and what they do

00:28:08,190 --> 00:28:13,120
there are also some good resources I'm

00:28:10,900 --> 00:28:15,700
gonna recommend three here one is

00:28:13,120 --> 00:28:18,100
there's a free online book called inside

00:28:15,700 --> 00:28:20,350
the Python virtual machine you can read

00:28:18,100 --> 00:28:21,790
it at no charge you can also pay some

00:28:20,350 --> 00:28:24,400
money to the author to thank him for

00:28:21,790 --> 00:28:27,400
writing it this is a complete tour of

00:28:24,400 --> 00:28:28,180
how Python works inside the Python

00:28:27,400 --> 00:28:31,090
interpreter

00:28:28,180 --> 00:28:32,560
all of the internal mechanics all of

00:28:31,090 --> 00:28:36,130
those stacks all of the bytecode

00:28:32,560 --> 00:28:38,050
operations the whole thing Allyson

00:28:36,130 --> 00:28:39,130
Kaptur has written a Python interpreter

00:28:38,050 --> 00:28:40,960
in Python

00:28:39,130 --> 00:28:43,610
she walks you through and by the way she

00:28:40,960 --> 00:28:46,400
gave a great talk here at PyCon

00:28:43,610 --> 00:28:48,470
she walks you through how to build a

00:28:46,400 --> 00:28:50,480
Python bytecode interpreter with all the

00:28:48,470 --> 00:28:52,490
correct data structures and handling all

00:28:50,480 --> 00:28:55,010
of the byte code operations in Python

00:28:52,490 --> 00:28:57,830
itself and then finally of course you

00:28:55,010 --> 00:28:59,630
can read the bytecode interpreter which

00:28:57,830 --> 00:29:00,980
is that gigantic switch statement that I

00:28:59,630 --> 00:29:02,360
showed you part of earlier that switch

00:29:00,980 --> 00:29:04,040
statement I think is around a thousand

00:29:02,360 --> 00:29:05,540
lines long or at least it was in one

00:29:04,040 --> 00:29:08,030
version that I looked at it is

00:29:05,540 --> 00:29:09,200
definitely hundreds of lines long but

00:29:08,030 --> 00:29:11,690
you can actually read through it it's

00:29:09,200 --> 00:29:13,940
fairly clear fairly well written C pipe

00:29:11,690 --> 00:29:18,590
C Python source code tends to be on the

00:29:13,940 --> 00:29:21,980
readable side as C goes so all of those

00:29:18,590 --> 00:29:24,710
are really good resources also if you

00:29:21,980 --> 00:29:27,080
want to I am on Twitter I will be

00:29:24,710 --> 00:29:28,280
heading out of here I can take maybe one

00:29:27,080 --> 00:29:32,150
or two questions in the hallway

00:29:28,280 --> 00:29:36,260
afterward and you can find me online and

00:29:32,150 --> 00:29:39,970
follow up so thank you all for showing

00:29:36,260 --> 00:29:39,970
up hopefully you learn something

00:29:42,400 --> 00:29:44,460

YouTube URL: https://www.youtube.com/watch?v=cSSpnq362Bk


