Title: vigneshwer dhinakaran - Pumping up Python modules using Rust - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: vigneshwer dhinakaran

If you’ve spent much time writing (or debugging) Python performance problems, you’ve probably had a hard time managing memory with its limited language support. 

In this talk, we venture deep into the belly of the Rust Language to uncover the secret incantations for building high performance and memory safe Python extensions using Rust. 

Rust has a lot to offer in terms of safety and performance for high-level programming languages such Python, Ruby, Js and more with its easy Foreign Function Interface capabilities which enables developers to easily develop bindings for foreign code. 


Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:16,309 --> 00:00:24,259
[Applause]

00:00:30,020 --> 00:00:40,890
hey folks let's have another round of

00:00:33,000 --> 00:00:42,120
applause for our next speaker ok so

00:00:40,890 --> 00:00:43,980
hello and thank you all for coming today

00:00:42,120 --> 00:00:46,290
it's a pleasure to be here and I'm super

00:00:43,980 --> 00:00:47,880
thrilled to have this opportunity all to

00:00:46,290 --> 00:00:49,410
have the opportunity to speak to you all

00:00:47,880 --> 00:00:51,330
today about two of my most favorite

00:00:49,410 --> 00:00:52,860
programming languages a Python and trust

00:00:51,330 --> 00:00:54,239
you know both of them really make me

00:00:52,860 --> 00:00:55,770
feel like it acts like a complete

00:00:54,239 --> 00:00:59,640
developer I am here to no basically

00:00:55,770 --> 00:01:00,989
share those experiences with you so

00:00:59,640 --> 00:01:04,080
today I'm going to talk about you know

00:01:00,989 --> 00:01:05,910
how as we as Python developers can maybe

00:01:04,080 --> 00:01:08,100
write a small Python extensions or look

00:01:05,910 --> 00:01:10,170
take some part of a workload and

00:01:08,100 --> 00:01:11,670
converted to a statically typed language

00:01:10,170 --> 00:01:13,230
in order to get that performance boost

00:01:11,670 --> 00:01:16,230
so my talk is mostly gonna be around

00:01:13,230 --> 00:01:18,170
that so if you were like me and by

00:01:16,230 --> 00:01:20,550
adding all the kind of I know

00:01:18,170 --> 00:01:21,990
performance at a talk here in Python you

00:01:20,550 --> 00:01:24,270
probably must have noted down these

00:01:21,990 --> 00:01:26,940
golden rules so the first one is like

00:01:24,270 --> 00:01:28,500
you know look for a lot like like use

00:01:26,940 --> 00:01:30,270
some tools like a line profiler then

00:01:28,500 --> 00:01:32,010
look at which part of a program is

00:01:30,270 --> 00:01:34,080
actually slow and then the second thing

00:01:32,010 --> 00:01:35,640
would be to you know go ahead Google and

00:01:34,080 --> 00:01:36,960
see how people I solve this problem in

00:01:35,640 --> 00:01:38,790
the Python community because Python

00:01:36,960 --> 00:01:40,950
community is amazing and someone who has

00:01:38,790 --> 00:01:42,390
definitely solved that problem maybe use

00:01:40,950 --> 00:01:44,510
that libraries that they have build or

00:01:42,390 --> 00:01:46,800
use the techniques that they have used

00:01:44,510 --> 00:01:48,750
to not think about solving this problem

00:01:46,800 --> 00:01:50,760
that you are also facing the third thing

00:01:48,750 --> 00:01:53,540
is don't use Python like you something

00:01:50,760 --> 00:01:56,310
else that has to know worked before so

00:01:53,540 --> 00:01:57,630
so I thought like you know let's let's

00:01:56,310 --> 00:01:59,640
start from the third point you know

00:01:57,630 --> 00:02:01,260
let's start from something that is not

00:01:59,640 --> 00:02:02,790
Python so I'm really happy that my

00:02:01,260 --> 00:02:04,920
doctor said he'll at this point of time

00:02:02,790 --> 00:02:06,170
because after hearing all the

00:02:04,920 --> 00:02:08,910
performance area talks so they're gonna

00:02:06,170 --> 00:02:10,470
focus more on a third point of using

00:02:08,910 --> 00:02:13,290
something that's not Python but you know

00:02:10,470 --> 00:02:14,640
in order to use some languages like rush

00:02:13,290 --> 00:02:18,420
which is a system programming language

00:02:14,640 --> 00:02:20,819
to basically you know improve your

00:02:18,420 --> 00:02:23,220
Python modules so we'll talk a lot about

00:02:20,819 --> 00:02:24,750
trust in this talk and you know see how

00:02:23,220 --> 00:02:26,760
we can leverage his features in Python

00:02:24,750 --> 00:02:28,379
so before get started for getting

00:02:26,760 --> 00:02:30,540
started let me just quickly introduce

00:02:28,379 --> 00:02:32,010
myself my name is Rick Nash where I'm

00:02:30,540 --> 00:02:34,170
here today representing Mozilla as a

00:02:32,010 --> 00:02:36,150
tech speaker a lot of people you know

00:02:34,170 --> 00:02:38,099
looking at my badge asks what's it

00:02:36,150 --> 00:02:40,019
Mosler Tech speaker so I think I should

00:02:38,099 --> 00:02:41,459
talk a little about that it's an amazing

00:02:40,019 --> 00:02:42,790
program run by the developer outreach

00:02:41,459 --> 00:02:45,159
team of Mozilla

00:02:42,790 --> 00:02:46,450
you know really enthusiastic volunteers

00:02:45,159 --> 00:02:48,040
and train them to be like developer

00:02:46,450 --> 00:02:49,989
advocates to go out and develop a little

00:02:48,040 --> 00:02:53,769
case in conferences like these to talk

00:02:49,989 --> 00:02:57,579
about Mozilla and web in general I'm

00:02:53,769 --> 00:02:59,620
sorry sorry about this okay I'm just

00:02:57,579 --> 00:03:02,439
gonna keep moving my mouse to make sure

00:02:59,620 --> 00:03:04,689
that things are up apart from that I'm a

00:03:02,439 --> 00:03:06,220
data scientist by the day I work I build

00:03:04,689 --> 00:03:08,590
a lot of state of our machine learning

00:03:06,220 --> 00:03:10,989
algorithms I enjoy doing that that's

00:03:08,590 --> 00:03:15,970
where I use Python a lot you know Python

00:03:10,989 --> 00:03:17,409
is best for data science and yeah apart

00:03:15,970 --> 00:03:19,810
from that I've written a book in rust so

00:03:17,409 --> 00:03:21,159
it really helps people to get started

00:03:19,810 --> 00:03:22,419
with rushed programming it's called the

00:03:21,159 --> 00:03:25,930
rush to a book that's pretty much about

00:03:22,419 --> 00:03:27,340
myself so let's get started so why do we

00:03:25,930 --> 00:03:28,329
need a native extension like that's the

00:03:27,340 --> 00:03:30,519
first question that comes to our mind

00:03:28,329 --> 00:03:32,139
right so it's basically because you have

00:03:30,519 --> 00:03:33,849
some really good library that is

00:03:32,139 --> 00:03:35,139
statically typed and then you want to

00:03:33,849 --> 00:03:37,090
bring that to Python like computer

00:03:35,139 --> 00:03:38,950
visions a lot of you see a lot of image

00:03:37,090 --> 00:03:40,569
processing libraries that been used

00:03:38,950 --> 00:03:43,389
numpy for example and things of that

00:03:40,569 --> 00:03:45,129
sort so we want to use that great

00:03:43,389 --> 00:03:46,090
engineering work in our Python models

00:03:45,129 --> 00:03:47,949
you don't want to rewrite the entire

00:03:46,090 --> 00:03:49,299
thing so so that's where we start

00:03:47,949 --> 00:03:50,979
thinking about you know native

00:03:49,299 --> 00:03:53,620
extensions the second thing is when we

00:03:50,979 --> 00:03:55,180
need you know like little more freedom

00:03:53,620 --> 00:03:57,010
in memory management there's something

00:03:55,180 --> 00:03:59,049
that we don't get access to in Python

00:03:57,010 --> 00:04:00,430
and the third one is like maybe thinking

00:03:59,049 --> 00:04:02,199
around with the hardware and things of

00:04:00,430 --> 00:04:04,180
that sort so the point is that you know

00:04:02,199 --> 00:04:06,669
performance control has always been this

00:04:04,180 --> 00:04:08,709
key like for building stage like

00:04:06,669 --> 00:04:10,239
applications right now which are so

00:04:08,709 --> 00:04:12,190
demanding like you need to have all

00:04:10,239 --> 00:04:15,099
these amazing features you need to be

00:04:12,190 --> 00:04:16,389
competent and that's what will get you

00:04:15,099 --> 00:04:17,799
that edge you're in you're in a

00:04:16,389 --> 00:04:19,900
particular business or in a particular

00:04:17,799 --> 00:04:22,360
domain so products these they are very

00:04:19,900 --> 00:04:24,070
demanding so with Python I think with

00:04:22,360 --> 00:04:26,979
despite then it's gonna be little bit

00:04:24,070 --> 00:04:28,810
tricky so we need to start looking for

00:04:26,979 --> 00:04:31,750
some alternatives so that's one big

00:04:28,810 --> 00:04:33,610
motivation behind this talk so what has

00:04:31,750 --> 00:04:35,199
been the solution still now Python

00:04:33,610 --> 00:04:36,820
community like they have probably solved

00:04:35,199 --> 00:04:38,919
this problem for you just go out and

00:04:36,820 --> 00:04:40,720
look out for what they have done when's

00:04:38,919 --> 00:04:43,090
the last time that you know you probably

00:04:40,720 --> 00:04:44,590
have faced a problem and then the Python

00:04:43,090 --> 00:04:46,509
company was not there to help you most

00:04:44,590 --> 00:04:48,340
of the time it really works so this is

00:04:46,509 --> 00:04:50,500
not some this is not new to us like you

00:04:48,340 --> 00:04:52,029
know PI as being a Python developer you

00:04:50,500 --> 00:04:53,800
have somewhere use these kind of

00:04:52,029 --> 00:04:56,660
libraries so now before I jump I for

00:04:53,800 --> 00:04:58,610
example it's 53 percentage of C code

00:04:56,660 --> 00:05:00,470
what gets that's that's what makes it

00:04:58,610 --> 00:05:02,780
magical you know it made it makes it

00:05:00,470 --> 00:05:04,610
works so good tends to flow away for

00:05:02,780 --> 00:05:06,230
example that's something I do I use from

00:05:04,610 --> 00:05:09,110
day to day basis it's like 48 percentage

00:05:06,230 --> 00:05:10,790
of C++ code size and the type C Python

00:05:09,110 --> 00:05:13,550
the one that you know runs your Python

00:05:10,790 --> 00:05:15,410
code then has a lot of you know system

00:05:13,550 --> 00:05:17,120
programming code in it pillow is an

00:05:15,410 --> 00:05:19,160
again an image processing library which

00:05:17,120 --> 00:05:23,990
is heavily used across various domain

00:05:19,160 --> 00:05:25,940
there are again a lot of C code in it so

00:05:23,990 --> 00:05:27,350
but what was the problem like you know

00:05:25,940 --> 00:05:29,330
see places developers are like Superman

00:05:27,350 --> 00:05:31,970
they're really difficult to find like

00:05:29,330 --> 00:05:35,390
you know like yeah they're very strong

00:05:31,970 --> 00:05:36,820
like Superman yes but the reality is

00:05:35,390 --> 00:05:39,680
like it's very difficult to write this

00:05:36,820 --> 00:05:42,650
expression extensions you need you need

00:05:39,680 --> 00:05:44,990
to have that kind of expertise and given

00:05:42,650 --> 00:05:46,370
the kind of time lines where you know

00:05:44,990 --> 00:05:47,780
expression I can talk for myself I come

00:05:46,370 --> 00:05:49,700
from a service industry and you know

00:05:47,780 --> 00:05:51,350
time lines are a big problem for me I

00:05:49,700 --> 00:05:52,970
can't even think about santak code the

00:05:51,350 --> 00:05:55,670
reason why I use Python is to make sure

00:05:52,970 --> 00:05:58,880
that my code runs without any bug you

00:05:55,670 --> 00:06:00,650
know so that's what I see you know

00:05:58,880 --> 00:06:01,940
Python being really useful that's what

00:06:00,650 --> 00:06:07,490
makes Python really good it's treatable

00:06:01,940 --> 00:06:10,160
it's super easy and works just fine but

00:06:07,490 --> 00:06:12,410
the problem is there are people like Lex

00:06:10,160 --> 00:06:14,450
Luthor who who you know would be some

00:06:12,410 --> 00:06:16,520
kind of hacker who'd go down look at

00:06:14,450 --> 00:06:18,950
your system code and try to you know

00:06:16,520 --> 00:06:21,880
exploit it for example kryptonite is a

00:06:18,950 --> 00:06:23,870
big problem for Superman right so

00:06:21,880 --> 00:06:27,080
historically we have seen so many bugs

00:06:23,870 --> 00:06:27,680
that have you know causes a lot of

00:06:27,080 --> 00:06:29,330
problems

00:06:27,680 --> 00:06:31,400
Dayna racer sick for so this is

00:06:29,330 --> 00:06:33,350
something that you need to manually

00:06:31,400 --> 00:06:34,580
handle the Python just takes care of all

00:06:33,350 --> 00:06:36,800
that for us like you have a garbage

00:06:34,580 --> 00:06:41,630
collector well surely talk a lot more

00:06:36,800 --> 00:06:43,370
about that but the point is if you're

00:06:41,630 --> 00:06:45,020
writing C+ extension you need to handle

00:06:43,370 --> 00:06:47,600
these things which are a bit difficult

00:06:45,020 --> 00:06:49,580
that's the reason why I've stated that

00:06:47,600 --> 00:06:52,820
in writing C+ was extension is scary and

00:06:49,580 --> 00:06:56,600
painful so one of the other options that

00:06:52,820 --> 00:06:58,730
we have a heightened superset of Python

00:06:56,600 --> 00:07:00,380
you know it's easy way of calling C

00:06:58,730 --> 00:07:02,600
functions and the datatypes over that

00:07:00,380 --> 00:07:05,030
works pretty good

00:07:02,600 --> 00:07:06,680
numbah is on another very good option

00:07:05,030 --> 00:07:08,180
out available out there which uses the

00:07:06,680 --> 00:07:10,130
JIT compiler

00:07:08,180 --> 00:07:10,610
it's basically optimized machine code

00:07:10,130 --> 00:07:13,539
which works

00:07:10,610 --> 00:07:15,770
on the LLVM compiler works pretty good

00:07:13,539 --> 00:07:17,960
the last one is pipe I use something

00:07:15,770 --> 00:07:21,770
that's not even Python you know Python

00:07:17,960 --> 00:07:23,240
but he has a debatable topic again yeah

00:07:21,770 --> 00:07:25,219
it again uses suggestion and compiler

00:07:23,240 --> 00:07:26,960
works pretty fine but the problem is

00:07:25,219 --> 00:07:29,509
like for people like me I can't talk for

00:07:26,960 --> 00:07:31,659
all I kind of feel that I've lost my

00:07:29,509 --> 00:07:33,860
control like I use all these tools and

00:07:31,659 --> 00:07:35,349
it works fine for me like but I'm not

00:07:33,860 --> 00:07:38,300
sure what's actually exactly happening

00:07:35,349 --> 00:07:41,090
it kind of makes me feel sad that's why

00:07:38,300 --> 00:07:43,460
I started looking for alternatives and

00:07:41,090 --> 00:07:45,460
what does the main ask the main ask is

00:07:43,460 --> 00:07:47,449
that you know you want C++ kind of

00:07:45,460 --> 00:07:50,090
performance portability and a made

00:07:47,449 --> 00:07:53,270
ability without with you know guaranteed

00:07:50,090 --> 00:07:54,860
safety what I mean by safety is that the

00:07:53,270 --> 00:07:56,330
one that Python you know kind of gives

00:07:54,860 --> 00:07:57,500
to us you don't have to worry a lot

00:07:56,330 --> 00:07:59,000
about this memory and things of that

00:07:57,500 --> 00:08:00,830
sort I just want to focus on my

00:07:59,000 --> 00:08:05,479
application and again have these kinds

00:08:00,830 --> 00:08:07,279
of performance boost so let me introduce

00:08:05,479 --> 00:08:08,539
you to an amazing state of what

00:08:07,279 --> 00:08:10,639
programming language it's called trust

00:08:08,539 --> 00:08:12,409
it's a system programming language which

00:08:10,639 --> 00:08:14,900
I like to define has great control like

00:08:12,409 --> 00:08:17,750
C++ and daily was practically like in

00:08:14,900 --> 00:08:19,300
Python and it's super safe so there are

00:08:17,750 --> 00:08:21,349
three things that you know the rest

00:08:19,300 --> 00:08:23,569
language you know really really does

00:08:21,349 --> 00:08:25,460
really well so that's number one it's

00:08:23,569 --> 00:08:26,960
hack without fear second this

00:08:25,460 --> 00:08:29,060
abstraction without overhead and

00:08:26,960 --> 00:08:32,269
stability without stagnation so hack

00:08:29,060 --> 00:08:33,560
without fear is this concept of going to

00:08:32,269 --> 00:08:35,479
the prediction without having these kind

00:08:33,560 --> 00:08:37,010
of bugs abstraction without over it is

00:08:35,479 --> 00:08:38,240
the zero cost abstraction which the

00:08:37,010 --> 00:08:39,620
community is really proud about I'll

00:08:38,240 --> 00:08:41,180
talk a lot more about that when I come

00:08:39,620 --> 00:08:42,649
to trades and stability without

00:08:41,180 --> 00:08:44,600
stagnation is whenever a new version of

00:08:42,649 --> 00:08:47,449
rust comes in it should not you know go

00:08:44,600 --> 00:08:49,190
back and cause you any kind of problems

00:08:47,449 --> 00:08:51,199
with your current exchange so every

00:08:49,190 --> 00:08:52,820
version really should be flawless you

00:08:51,199 --> 00:08:55,339
know that's something that every

00:08:52,820 --> 00:08:56,600
software developer wants and I truly

00:08:55,339 --> 00:08:59,390
believe that rush is creating a new

00:08:56,600 --> 00:09:00,800
generation of system programmers I have

00:08:59,390 --> 00:09:02,209
never done system programming before but

00:09:00,800 --> 00:09:04,220
I'm really confident with all the sturm

00:09:02,209 --> 00:09:07,010
knowledge ease and I just go around you

00:09:04,220 --> 00:09:09,410
know is boasting about myself to be a

00:09:07,010 --> 00:09:10,790
system programmer but yeah the goal is

00:09:09,410 --> 00:09:12,560
that you know you need to create a

00:09:10,790 --> 00:09:15,290
really stable a confident and a safe

00:09:12,560 --> 00:09:17,510
safe system programming language so the

00:09:15,290 --> 00:09:19,940
Zen of rust is you have a memory safety

00:09:17,510 --> 00:09:21,800
without garbage collection again i'll

00:09:19,940 --> 00:09:23,690
when i come to ownership and boring

00:09:21,800 --> 00:09:24,980
which is the core concept behind the

00:09:23,690 --> 00:09:27,709
rush language this

00:09:24,980 --> 00:09:30,529
right system which allows you to have a

00:09:27,709 --> 00:09:32,240
lot of good things like you can read the

00:09:30,529 --> 00:09:33,709
code really well it's easy to understand

00:09:32,240 --> 00:09:34,699
you right you know we exactly know

00:09:33,709 --> 00:09:36,470
what's happening under the hood

00:09:34,699 --> 00:09:38,600
high-level iterators that's something we

00:09:36,470 --> 00:09:39,920
all love us Python developers obvious

00:09:38,600 --> 00:09:41,930
boil by it to so much then that's

00:09:39,920 --> 00:09:45,649
another topic altogether but yeah that

00:09:41,930 --> 00:09:46,760
is a lot of offerings over that freedom

00:09:45,649 --> 00:09:48,199
and data rises and I'm welcoming

00:09:46,760 --> 00:09:50,000
community this is something that you

00:09:48,199 --> 00:09:52,790
would really appreciate coming from a

00:09:50,000 --> 00:09:54,800
Python background like we need a really

00:09:52,790 --> 00:09:56,750
strong ecosystem a strong library core

00:09:54,800 --> 00:09:59,300
systems that something Russia is really

00:09:56,750 --> 00:10:04,760
focused on let's look at some facts and

00:09:59,300 --> 00:10:07,040
figures so this is a app called wire so

00:10:04,760 --> 00:10:09,410
it's basically an application that does

00:10:07,040 --> 00:10:10,730
business chats and the about TC

00:10:09,410 --> 00:10:11,990
conference calls and things of that sort

00:10:10,730 --> 00:10:13,730
so what they basically did was they

00:10:11,990 --> 00:10:16,310
moved their entire cryptocurrency part

00:10:13,730 --> 00:10:18,740
to rust and so like a good performance

00:10:16,310 --> 00:10:20,570
that's pretty cool this under company

00:10:18,740 --> 00:10:22,160
called sentry which I think I saw them

00:10:20,570 --> 00:10:25,250
here so they have done a pretty good job

00:10:22,160 --> 00:10:27,949
in you know writing their a pass for a

00:10:25,250 --> 00:10:29,240
parser which I know was passing of their

00:10:27,949 --> 00:10:31,069
source Maps and Trust and have

00:10:29,240 --> 00:10:33,800
significantly reduced their processing

00:10:31,069 --> 00:10:35,990
time so I think almond is this person

00:10:33,800 --> 00:10:37,970
who has written this and he also happens

00:10:35,990 --> 00:10:39,829
to be the guy who developed the flask

00:10:37,970 --> 00:10:41,149
app he's given a lot of cool talks

00:10:39,829 --> 00:10:42,620
before this so I really recommend to go

00:10:41,149 --> 00:10:45,800
check that out and they have done like

00:10:42,620 --> 00:10:48,589
significant work here so another company

00:10:45,800 --> 00:10:50,540
called snips they're like why system

00:10:48,589 --> 00:10:52,279
companies they are using rust heavily -

00:10:50,540 --> 00:10:54,380
you know ship their products ship their

00:10:52,279 --> 00:10:57,040
mortars across different hardware works

00:10:54,380 --> 00:10:59,630
really well for them there's another a

00:10:57,040 --> 00:11:02,269
proof of concept library that is written

00:10:59,630 --> 00:11:03,980
over a Tokyo which is a very fast and

00:11:02,269 --> 00:11:05,930
reliable way of writing handling

00:11:03,980 --> 00:11:08,029
asynchronous requests and if you can see

00:11:05,930 --> 00:11:10,040
this graphs the kind of requests that

00:11:08,029 --> 00:11:12,260
you can handle a synchronous is very

00:11:10,040 --> 00:11:14,269
high and you know it would basically you

00:11:12,260 --> 00:11:15,350
know help you save a lot of money in a

00:11:14,269 --> 00:11:16,519
production environment again this is a

00:11:15,350 --> 00:11:19,160
proof of concept but it'll be really

00:11:16,519 --> 00:11:21,620
good if this comes out to be comes out

00:11:19,160 --> 00:11:22,970
in a stable version so this is another

00:11:21,620 --> 00:11:24,889
thing that the res committee is really

00:11:22,970 --> 00:11:26,630
proud about you know for third time in

00:11:24,889 --> 00:11:28,790
the row they have been voted the most

00:11:26,630 --> 00:11:30,350
loud language this is something really

00:11:28,790 --> 00:11:34,100
cool for a language is just got released

00:11:30,350 --> 00:11:36,500
in 2015 right so there are companies are

00:11:34,100 --> 00:11:38,329
using them they have really really good

00:11:36,500 --> 00:11:38,810
use cases I don't have time to talk

00:11:38,329 --> 00:11:40,640
about the

00:11:38,810 --> 00:11:42,380
but I really recommend you guys to go

00:11:40,640 --> 00:11:44,210
check out the Friends of rest website

00:11:42,380 --> 00:11:46,070
like again there's a lot of inspiration

00:11:44,210 --> 00:11:48,440
that you could take you know take from

00:11:46,070 --> 00:11:50,900
that and kind of try to apply in your

00:11:48,440 --> 00:11:52,580
workplace so how did it all begin

00:11:50,900 --> 00:11:54,320
so Mozilla is the company that sponsors

00:11:52,580 --> 00:11:56,540
this project but is a community driven

00:11:54,320 --> 00:11:59,000
initiative all together so browser its

00:11:56,540 --> 00:12:01,339
its core perform p4 performance and they

00:11:59,000 --> 00:12:03,140
need safety as well so it was really

00:12:01,339 --> 00:12:05,120
important for Mozilla to you know invest

00:12:03,140 --> 00:12:07,839
in this so there that's the rush project

00:12:05,120 --> 00:12:10,339
for you which I think started around

00:12:07,839 --> 00:12:12,320
2006 maybe it was more like Mozilla

00:12:10,339 --> 00:12:14,029
employee was working on this and then

00:12:12,320 --> 00:12:15,650
something similar they had like a lot of

00:12:14,029 --> 00:12:17,330
functional programming influenced in it

00:12:15,650 --> 00:12:20,300
and it was very similar to C plus place

00:12:17,330 --> 00:12:22,130
and then at one point of time rest had

00:12:20,300 --> 00:12:25,220
garbage collectors so the language has

00:12:22,130 --> 00:12:27,950
evolved over time and it's such a nice

00:12:25,220 --> 00:12:29,180
experience to read about what what has

00:12:27,950 --> 00:12:30,800
been happening in the community and the

00:12:29,180 --> 00:12:34,160
server project is a way of creating

00:12:30,800 --> 00:12:35,779
high-performance browser engine which

00:12:34,160 --> 00:12:39,110
you know the whole Olaf rush language is

00:12:35,779 --> 00:12:40,910
influenced by that in Firefox 48 trust

00:12:39,110 --> 00:12:42,290
was introduced the first time I don't

00:12:40,910 --> 00:12:46,339
know as a such product of this scale

00:12:42,290 --> 00:12:48,470
Irish had come in it was a URL parser

00:12:46,339 --> 00:12:50,600
then fire for 57 great success story

00:12:48,470 --> 00:12:52,970
here they rewrote a lot of their parts

00:12:50,600 --> 00:12:57,290
in rust these Tyler was one among them

00:12:52,970 --> 00:12:59,839
which gave them a lot of moments at

00:12:57,290 --> 00:13:02,270
runtime I highly recommend to go out and

00:12:59,839 --> 00:13:03,740
check that out so let me just know

00:13:02,270 --> 00:13:05,030
introduce you to the other syntaxes

00:13:03,740 --> 00:13:06,530
because the later part of the slides

00:13:05,030 --> 00:13:08,510
have a lot of recent acts that you need

00:13:06,530 --> 00:13:10,730
to understand rush is really really easy

00:13:08,510 --> 00:13:12,920
to learn so use the lead variables to

00:13:10,730 --> 00:13:14,510
know create a variable binding you don't

00:13:12,920 --> 00:13:15,830
have to explicitly mention what type it

00:13:14,510 --> 00:13:18,440
is compiled is smart enough to

00:13:15,830 --> 00:13:19,880
understand that all variables by default

00:13:18,440 --> 00:13:21,770
are immutable and then you have to

00:13:19,880 --> 00:13:24,170
explicitly mention mutable type as mute

00:13:21,770 --> 00:13:27,200
in order to make a variable binding as

00:13:24,170 --> 00:13:28,760
suitable so in run in runtime you can

00:13:27,200 --> 00:13:31,089
change the value when you have mentioned

00:13:28,760 --> 00:13:33,830
it as mute otherwise it's not possible

00:13:31,089 --> 00:13:34,850
unlike and let variable you in if you

00:13:33,830 --> 00:13:37,040
want to declare a constant or to

00:13:34,850 --> 00:13:38,390
explicitly mention the type and this

00:13:37,040 --> 00:13:41,930
particular variable will be same

00:13:38,390 --> 00:13:43,610
throughout the scope of the program so

00:13:41,930 --> 00:13:45,160
functions are pretty similar so the only

00:13:43,610 --> 00:13:48,140
one thing that I would you know

00:13:45,160 --> 00:13:50,030
recommend to focus on is everything is

00:13:48,140 --> 00:13:51,530
explicitly mentioned the type that goes

00:13:50,030 --> 00:13:52,610
into a particular function this

00:13:51,530 --> 00:13:54,889
basically helps in

00:13:52,610 --> 00:13:55,759
reading your functions really well and

00:13:54,889 --> 00:13:57,799
then you don't have to explicitly

00:13:55,759 --> 00:14:00,379
mention return types it's the the last

00:13:57,799 --> 00:14:03,829
statement is usually the inference - the

00:14:00,379 --> 00:14:05,660
thing that you're trying to return flow

00:14:03,829 --> 00:14:08,179
control pretty straightforward nothing

00:14:05,660 --> 00:14:11,439
fancy here just if condition if passes

00:14:08,179 --> 00:14:14,809
it you know processes some code else not

00:14:11,439 --> 00:14:17,089
so pattern biting or switch in general

00:14:14,809 --> 00:14:18,709
is done through the keyword match so you

00:14:17,089 --> 00:14:20,480
have match a variable and then you have

00:14:18,709 --> 00:14:22,369
lot of conditions around it if you have

00:14:20,480 --> 00:14:23,959
a single value a group of values a range

00:14:22,369 --> 00:14:28,220
of values and the underscore is

00:14:23,959 --> 00:14:30,439
basically default this is an infinite

00:14:28,220 --> 00:14:33,379
loop a while loop with the condition so

00:14:30,439 --> 00:14:35,779
in interest you all have iterator type

00:14:33,379 --> 00:14:38,059
so you type need to be a type needs to

00:14:35,779 --> 00:14:41,749
be like a table in order to know run for

00:14:38,059 --> 00:14:44,059
loops here you basically have a range

00:14:41,749 --> 00:14:45,739
and you know expressions should be in

00:14:44,059 --> 00:14:48,079
triple type for it to run and four types

00:14:45,739 --> 00:14:49,910
so Russ gives you all the kind of types

00:14:48,079 --> 00:14:52,999
that you usually find in an system

00:14:49,910 --> 00:14:54,920
programming language nothing different

00:14:52,999 --> 00:14:56,420
so you have something called cargo which

00:14:54,920 --> 00:14:59,419
is really really cool it's very similar

00:14:56,420 --> 00:15:01,249
to pip but does things more I believe

00:14:59,419 --> 00:15:03,410
like there are little more functionality

00:15:01,249 --> 00:15:05,029
is that you know cargo really does well

00:15:03,410 --> 00:15:06,769
but there are lot of similarities over

00:15:05,029 --> 00:15:08,329
there so coming back from coming from a

00:15:06,769 --> 00:15:09,799
Python community cargo will be something

00:15:08,329 --> 00:15:12,649
that you'll really really enjoy because

00:15:09,799 --> 00:15:13,759
I definitely did so coming to the core

00:15:12,649 --> 00:15:15,199
concept this is something that you

00:15:13,759 --> 00:15:16,519
really need to understand if you are

00:15:15,199 --> 00:15:18,709
able to understand this you're probably

00:15:16,519 --> 00:15:20,509
master trusts so ownership that's some

00:15:18,709 --> 00:15:22,040
it's more like and right of processing

00:15:20,509 --> 00:15:23,540
something so let's look at this Python

00:15:22,040 --> 00:15:26,839
example so you have a class it

00:15:23,540 --> 00:15:28,160
calculates the area and then operating

00:15:26,839 --> 00:15:30,259
research objects

00:15:28,160 --> 00:15:32,209
and you know calculating the area and

00:15:30,259 --> 00:15:34,369
your you know having an accumulator that

00:15:32,209 --> 00:15:36,169
adds up the area over that so basically

00:15:34,369 --> 00:15:38,179
in the heap memory you would probably

00:15:36,169 --> 00:15:40,189
have three circles and what basically

00:15:38,179 --> 00:15:41,509
happens over time is there will be a

00:15:40,189 --> 00:15:43,850
garbage collector software which runs

00:15:41,509 --> 00:15:45,619
behind under the hood that would go and

00:15:43,850 --> 00:15:46,910
clear up this so it uses reference

00:15:45,619 --> 00:15:49,040
counting and things of that sort in

00:15:46,910 --> 00:15:50,360
Python so V as propoganda là-bas don't

00:15:49,040 --> 00:15:52,459
really you know care about it because

00:15:50,360 --> 00:15:55,699
this is something that is taken care by

00:15:52,459 --> 00:15:57,439
the Python interpreter pretty cool it so

00:15:55,699 --> 00:15:59,119
in similar to reference in you you can

00:15:57,439 --> 00:16:00,740
just you know get get some values out

00:15:59,119 --> 00:16:03,589
and pass it to different classes like

00:16:00,740 --> 00:16:04,939
considering booking service so that's a

00:16:03,589 --> 00:16:06,620
small type over there booking service

00:16:04,939 --> 00:16:08,420
and Reapers repairs

00:16:06,620 --> 00:16:10,430
are holding a reference to this way this

00:16:08,420 --> 00:16:14,030
variable and should totally work fine

00:16:10,430 --> 00:16:15,410
but let's say I do this interest this

00:16:14,030 --> 00:16:16,850
would this would you know fail at

00:16:15,410 --> 00:16:18,260
compile time it basically will throw you

00:16:16,850 --> 00:16:20,150
an error saying that you know this

00:16:18,260 --> 00:16:21,380
particular type hasn't moved like how

00:16:20,150 --> 00:16:22,730
are you supposed to even program this

00:16:21,380 --> 00:16:24,140
way like I can't even pass a reference

00:16:22,730 --> 00:16:25,010
so this is that ownership really really

00:16:24,140 --> 00:16:28,610
comes into place

00:16:25,010 --> 00:16:30,350
so everything interest is owned by you

00:16:28,610 --> 00:16:33,920
scopes or scope particular scope

00:16:30,350 --> 00:16:35,540
basically owns a particular a variable

00:16:33,920 --> 00:16:38,000
or a particular resource and the moment

00:16:35,540 --> 00:16:40,060
the variable the scope goes the variable

00:16:38,000 --> 00:16:42,440
goes out of scope it is deterministic

00:16:40,060 --> 00:16:43,730
domestically destructed so that's the

00:16:42,440 --> 00:16:45,830
reason why you don't need a garbage

00:16:43,730 --> 00:16:47,360
collector so the memories freed as soon

00:16:45,830 --> 00:16:48,770
as the own variable goes out of scope

00:16:47,360 --> 00:16:50,600
that's the most important thing that you

00:16:48,770 --> 00:16:52,190
need to you know remember there's a

00:16:50,600 --> 00:16:55,850
reason why when we pass the vehicle

00:16:52,190 --> 00:16:57,050
variable to the booking service and so

00:16:55,850 --> 00:16:58,370
the booking service is not explicitly

00:16:57,050 --> 00:17:01,640
returning back the ownership to the main

00:16:58,370 --> 00:17:05,180
thread so any call the repairs repair

00:17:01,640 --> 00:17:06,560
service this the vehicle will not exist

00:17:05,180 --> 00:17:08,720
because it has been dissed immensely

00:17:06,560 --> 00:17:10,400
destructed so how am I supposed to code

00:17:08,720 --> 00:17:11,480
like this like how can I pass variables

00:17:10,400 --> 00:17:13,550
routine threads so that's where

00:17:11,480 --> 00:17:15,140
borrowing comes into place so you could

00:17:13,550 --> 00:17:17,450
use a number sign symbol to pass a

00:17:15,140 --> 00:17:21,200
reference pretty simple ending is the

00:17:17,450 --> 00:17:23,000
key here so you can you are basically

00:17:21,200 --> 00:17:24,800
passing the ownership between threads or

00:17:23,000 --> 00:17:26,360
between functions and then there are two

00:17:24,800 --> 00:17:28,070
type of borrowing on it's immutable type

00:17:26,360 --> 00:17:30,410
and immutable type immutable type does

00:17:28,070 --> 00:17:32,090
not allow you to make a change if the

00:17:30,410 --> 00:17:34,310
particulars that particular memory

00:17:32,090 --> 00:17:36,380
location and immutable type allows you

00:17:34,310 --> 00:17:38,480
to do that you could have like any

00:17:36,380 --> 00:17:40,670
number of you know immutable references

00:17:38,480 --> 00:17:42,560
but you just can have at a given point

00:17:40,670 --> 00:17:45,680
of time one mutable reference makes

00:17:42,560 --> 00:17:48,980
sense right so yes so this is how you

00:17:45,680 --> 00:17:50,930
know rest kind of handles a memory

00:17:48,980 --> 00:17:52,490
management without any coverage

00:17:50,930 --> 00:17:53,870
collector so let's look at some

00:17:52,490 --> 00:17:55,340
high-level iterators it I have sold

00:17:53,870 --> 00:17:58,670
about so here by finding a particular

00:17:55,340 --> 00:18:00,770
word in a string and then you have

00:17:58,670 --> 00:18:04,460
things like you know into ITER which

00:18:00,770 --> 00:18:06,710
converts your particular strings into a

00:18:04,460 --> 00:18:08,660
table types and your map function which

00:18:06,710 --> 00:18:10,070
calls the WC line function in which you

00:18:08,660 --> 00:18:11,240
have filters and folds so these are the

00:18:10,070 --> 00:18:13,610
high-level interest I was talking about

00:18:11,240 --> 00:18:15,410
really makes it you to write really fast

00:18:13,610 --> 00:18:15,830
but how do I like do it in a parallel

00:18:15,410 --> 00:18:18,289
way like me

00:18:15,830 --> 00:18:20,539
things move faster that's does this

00:18:18,289 --> 00:18:22,940
package called rayon and all that here

00:18:20,539 --> 00:18:26,230
two changes you know make into I train

00:18:22,940 --> 00:18:29,330
to into PI writer pretty simple right so

00:18:26,230 --> 00:18:31,850
gives you a lot of boost at runtime so

00:18:29,330 --> 00:18:33,350
Ryan is a very very super cool package I

00:18:31,850 --> 00:18:34,940
highly recommend to check it out it

00:18:33,350 --> 00:18:38,149
really helps in data parallelism and

00:18:34,940 --> 00:18:39,409
data parallelism so there are some

00:18:38,149 --> 00:18:40,970
custom data types that the goodwill

00:18:39,409 --> 00:18:42,529
struct is a way to do that they're like

00:18:40,970 --> 00:18:45,980
lightweight references they have fields

00:18:42,529 --> 00:18:47,659
they also have methods so but you cannot

00:18:45,980 --> 00:18:51,470
have them partially fill it will throw

00:18:47,659 --> 00:18:52,940
you an error at runtime so with what you

00:18:51,470 --> 00:18:54,889
could basically do is use something like

00:18:52,940 --> 00:18:57,019
an option which is an enum that's

00:18:54,889 --> 00:18:59,029
usually used for error handling interest

00:18:57,019 --> 00:19:02,389
and match an enum or a very bit good way

00:18:59,029 --> 00:19:03,889
of doing error handling interest trucks

00:19:02,389 --> 00:19:06,700
can have method so use the implement

00:19:03,889 --> 00:19:09,500
keyword to you know build methods for

00:19:06,700 --> 00:19:11,149
trucks so the another important topic I

00:19:09,500 --> 00:19:13,159
want to talk about this trait which you

00:19:11,149 --> 00:19:15,139
are like interfaces interest that allows

00:19:13,159 --> 00:19:16,190
you to add functionality is like you

00:19:15,139 --> 00:19:17,779
know have the similar kind of

00:19:16,190 --> 00:19:19,639
functionality same function names for

00:19:17,779 --> 00:19:21,519
different types so this is where the

00:19:19,639 --> 00:19:24,169
dynamic dispatch happens at runtime and

00:19:21,519 --> 00:19:25,730
that's something called genrich's which

00:19:24,169 --> 00:19:26,929
is again a very cool topic thing I'm

00:19:25,730 --> 00:19:28,970
running over time in world I'm going to

00:19:26,929 --> 00:19:30,769
skip this part so let's look at

00:19:28,970 --> 00:19:32,090
developing and shipping rough sanctions

00:19:30,769 --> 00:19:34,429
in Python word is that's the reason why

00:19:32,090 --> 00:19:35,750
you guys are here right so the way to do

00:19:34,429 --> 00:19:38,389
it is using foreign function interface

00:19:35,750 --> 00:19:41,299
is foreign function faces are the way to

00:19:38,389 --> 00:19:42,649
you know you you probably want to share

00:19:41,299 --> 00:19:44,389
your particular data types from one

00:19:42,649 --> 00:19:46,010
language to the other languages that's

00:19:44,389 --> 00:19:48,799
that's where you know a foreign function

00:19:46,010 --> 00:19:50,750
interface comes into place it's based on

00:19:48,799 --> 00:19:52,250
platform dependent see bind see

00:19:50,750 --> 00:19:54,409
application binary interface is that you

00:19:52,250 --> 00:19:56,120
have and Trust is known to you know

00:19:54,409 --> 00:19:58,639
produce really the efficiency bindings

00:19:56,120 --> 00:20:00,679
that's one reason why I feel Russia's a

00:19:58,639 --> 00:20:03,049
you know a good option that you might

00:20:00,679 --> 00:20:05,120
consider for writing your by the next

00:20:03,049 --> 00:20:06,500
engines again coming to the point that

00:20:05,120 --> 00:20:08,750
you know the control aspects you really

00:20:06,500 --> 00:20:10,130
know what's happening you you you looked

00:20:08,750 --> 00:20:11,960
at the rush code it was pretty easy to

00:20:10,130 --> 00:20:13,639
understand it was not that difficult

00:20:11,960 --> 00:20:16,399
right it has lot of similarities to

00:20:13,639 --> 00:20:18,320
Python and other languages out there so

00:20:16,399 --> 00:20:20,029
it basically gives you this opportunity

00:20:18,320 --> 00:20:21,500
to understand what you are writing you

00:20:20,029 --> 00:20:23,899
don't have to blindly believe on some

00:20:21,500 --> 00:20:26,919
tools that's something that you know as

00:20:23,899 --> 00:20:29,779
programmers we need to really focus on

00:20:26,919 --> 00:20:31,549
so yeah if by the Ness Tony star

00:20:29,779 --> 00:20:33,859
and then Iron Man would be rust and the

00:20:31,549 --> 00:20:38,029
compress compiler would be javis oh that

00:20:33,859 --> 00:20:39,710
that's that's my you know example so

00:20:38,029 --> 00:20:42,349
it's really the ideal friend ideal for

00:20:39,710 --> 00:20:44,840
creating and using FF I'm audience so

00:20:42,349 --> 00:20:46,219
you start off by you know mentioning the

00:20:44,840 --> 00:20:48,169
library that you want to create so you

00:20:46,219 --> 00:20:51,019
have to in rust you have to first create

00:20:48,169 --> 00:20:52,340
a binary so use a dynamic so if you look

00:20:51,019 --> 00:20:54,979
at the create types grades are similar

00:20:52,340 --> 00:20:57,649
to libraries and trust that similar to

00:20:54,979 --> 00:20:59,179
libraries in Python and using a create

00:20:57,649 --> 00:21:01,909
type you create a dynamic library that

00:20:59,179 --> 00:21:05,599
would you know have an output like the

00:21:01,909 --> 00:21:06,950
daughter so files in Linux and a dot DLL

00:21:05,599 --> 00:21:09,440
file in Windows and things of that sort

00:21:06,950 --> 00:21:11,450
and next up is where you create an

00:21:09,440 --> 00:21:16,369
extension so rust standard library gives

00:21:11,450 --> 00:21:18,169
you some some inbuilt data types for

00:21:16,369 --> 00:21:20,539
interacting with these three strings and

00:21:18,169 --> 00:21:22,429
C inputs no mangle is a way to you know

00:21:20,539 --> 00:21:24,169
an attribute that you mentioned not a

00:21:22,429 --> 00:21:27,109
tell that don't change my function names

00:21:24,169 --> 00:21:29,299
while compiling and yeah you don't have

00:21:27,109 --> 00:21:30,919
to explicitly go through the code the

00:21:29,299 --> 00:21:33,889
point is that it's very easy to write

00:21:30,919 --> 00:21:36,919
these extensions and you can compile it

00:21:33,889 --> 00:21:38,299
to your Python code using the CFI

00:21:36,919 --> 00:21:40,279
modules I highly recommend to go out

00:21:38,299 --> 00:21:42,529
check out the documentation tests like

00:21:40,279 --> 00:21:43,909
quite quite a lot of things that needs

00:21:42,529 --> 00:21:47,210
to be covered and you could always build

00:21:43,909 --> 00:21:48,799
it with your setup dot py so there are

00:21:47,210 --> 00:21:50,269
other tools that I highly recommend to

00:21:48,799 --> 00:21:52,519
go check out like setup tools don't

00:21:50,269 --> 00:21:56,019
trust mill snake a mistake again written

00:21:52,519 --> 00:21:58,159
by the sentry guys so works really well

00:21:56,019 --> 00:21:59,749
but there are other alternatives as

00:21:58,159 --> 00:22:02,419
people say don't reinvent the wheels you

00:21:59,749 --> 00:22:04,580
have a lot of types too you know

00:22:02,419 --> 00:22:06,919
manually handle there are vectors and

00:22:04,580 --> 00:22:09,169
arrays that you want to basically pass

00:22:06,919 --> 00:22:11,479
out so rush C Python is a good library

00:22:09,169 --> 00:22:16,219
out there it's library or crate which

00:22:11,479 --> 00:22:18,259
probably handles the other other sea

00:22:16,219 --> 00:22:19,519
bindings that you want to have is a easy

00:22:18,259 --> 00:22:22,009
way to you know communicate with

00:22:19,519 --> 00:22:24,169
interest in Python so here I basically

00:22:22,009 --> 00:22:26,349
have a Python code which you know I'm

00:22:24,169 --> 00:22:29,389
trying to do some string processing come

00:22:26,349 --> 00:22:31,129
find the doubles in a particular line of

00:22:29,389 --> 00:22:33,019
string I'm using two ways you can just

00:22:31,129 --> 00:22:37,039
use a zip and then I'm using a red X to

00:22:33,019 --> 00:22:41,149
do that and I'm creating like a million

00:22:37,039 --> 00:22:44,790
characters so you use the rest benchmark

00:22:41,149 --> 00:22:47,670
is benchmark library to you no bench MA

00:22:44,790 --> 00:22:50,490
performance at one time and let's now

00:22:47,670 --> 00:22:53,100
create an extension in rust to do the

00:22:50,490 --> 00:22:55,320
same so the first first of all we start

00:22:53,100 --> 00:22:57,710
off mentioning the the crate that we're

00:22:55,320 --> 00:22:59,820
gonna use that the cpython call those

00:22:57,710 --> 00:23:04,050
string types that you're gonna probably

00:22:59,820 --> 00:23:07,770
use in our rust code and then here I

00:23:04,050 --> 00:23:09,810
have a similar implementation of the

00:23:07,770 --> 00:23:11,580
same accounting functionality interest

00:23:09,810 --> 00:23:14,490
and but if you can notice clearly have

00:23:11,580 --> 00:23:16,620
used pi result as my type because that's

00:23:14,490 --> 00:23:18,060
what's gonna like handle exceptions in

00:23:16,620 --> 00:23:21,210
python and you know communicate between

00:23:18,060 --> 00:23:24,090
the statically compiled iso file and

00:23:21,210 --> 00:23:25,890
your Python interpreter and it also the

00:23:24,090 --> 00:23:28,470
first argument or two that is in Python

00:23:25,890 --> 00:23:33,530
type which you know goes down and you

00:23:28,470 --> 00:23:37,610
know you locks your global Jill GL and

00:23:33,530 --> 00:23:39,630
yeah then okay is a way to written back

00:23:37,610 --> 00:23:42,720
the success of this particular program

00:23:39,630 --> 00:23:44,760
the final value at last you have to use

00:23:42,720 --> 00:23:46,430
and macro in order to explicitly mention

00:23:44,760 --> 00:23:49,170
the functions that are going to export

00:23:46,430 --> 00:23:51,300
again a nice interface to you know

00:23:49,170 --> 00:23:54,330
compile out the functions that are gonna

00:23:51,300 --> 00:23:56,390
use so yeah you would find a significant

00:23:54,330 --> 00:23:59,520
boost in performance so the pure Python

00:23:56,390 --> 00:24:02,460
you know this is just like 25 times

00:23:59,520 --> 00:24:04,920
faster and ten time almost ten times

00:24:02,460 --> 00:24:06,450
faster than the next version so that's

00:24:04,920 --> 00:24:08,910
the advantage of you know compiling

00:24:06,450 --> 00:24:10,980
ahead of time and using static

00:24:08,910 --> 00:24:12,540
programming languages so there are other

00:24:10,980 --> 00:24:14,310
things that you probably want to do with

00:24:12,540 --> 00:24:15,690
you know allocation of memory there's a

00:24:14,310 --> 00:24:18,000
lot more you know this is this is a very

00:24:15,690 --> 00:24:19,710
simple example but at building

00:24:18,000 --> 00:24:21,180
production applications you probably

00:24:19,710 --> 00:24:23,960
want to do a lot more things like pass

00:24:21,180 --> 00:24:26,160
vectors and things of that sort

00:24:23,960 --> 00:24:27,780
so you I would highly recommend this

00:24:26,160 --> 00:24:29,520
talk by my friend Nikita who also

00:24:27,780 --> 00:24:31,350
happens to be a tech speaker this is a

00:24:29,520 --> 00:24:34,200
good talk to go out and check yes talk

00:24:31,350 --> 00:24:35,700
in detail about have a five interest so

00:24:34,200 --> 00:24:37,260
there again good tooling system that is

00:24:35,700 --> 00:24:40,020
available in Russ you have rushed up

00:24:37,260 --> 00:24:41,640
which is the rush to just tool chain

00:24:40,020 --> 00:24:43,470
installer helps you to go between

00:24:41,640 --> 00:24:45,780
different versions of Russ rush for my

00:24:43,470 --> 00:24:47,610
trust with P there are some good ways to

00:24:45,780 --> 00:24:49,500
maintain like really good code bases

00:24:47,610 --> 00:24:50,730
cargo which I mentioned before packet

00:24:49,500 --> 00:24:52,320
manager and there lot of other tooling

00:24:50,730 --> 00:24:54,840
system out there

00:24:52,320 --> 00:24:56,220
Russ is a community driven project you

00:24:54,840 --> 00:24:57,550
know everything happens through an RFC

00:24:56,220 --> 00:24:59,900
you will have to

00:24:57,550 --> 00:25:01,730
if you want some kind of changes you you

00:24:59,900 --> 00:25:03,710
you submitted our C proposal the

00:25:01,730 --> 00:25:06,110
community verifies it there's something

00:25:03,710 --> 00:25:08,180
called crates dot IO where you know all

00:25:06,110 --> 00:25:10,430
these packages get you know uploaded

00:25:08,180 --> 00:25:11,900
you'll find I have plenty please it's a

00:25:10,430 --> 00:25:13,550
very good library Co system like given

00:25:11,900 --> 00:25:14,720
the time there's been a lot of crazy

00:25:13,550 --> 00:25:19,220
I've been published over there and

00:25:14,720 --> 00:25:20,930
pretty helpful to summarize no I when do

00:25:19,220 --> 00:25:23,120
you when do we have to use rust like you

00:25:20,930 --> 00:25:25,480
know like the main thing that I would

00:25:23,120 --> 00:25:27,920
say if there's some kind of mathematical

00:25:25,480 --> 00:25:29,660
complex complex code that you have that

00:25:27,920 --> 00:25:30,730
you have in your existing stack that's

00:25:29,660 --> 00:25:32,510
something that you can convert to

00:25:30,730 --> 00:25:34,570
understand you know get get the

00:25:32,510 --> 00:25:37,460
advantage of statically typed languages

00:25:34,570 --> 00:25:39,920
for accessing Hardware you know kernel

00:25:37,460 --> 00:25:42,100
level ApS just gives you like good types

00:25:39,920 --> 00:25:44,390
and you know interfaces to do that

00:25:42,100 --> 00:25:47,000
implementing advanced concurrency

00:25:44,390 --> 00:25:48,440
paradigms really really easy but just

00:25:47,000 --> 00:25:50,630
keep in mind that you know calling

00:25:48,440 --> 00:25:52,490
between languages it's a bit costly so

00:25:50,630 --> 00:25:54,560
do that in a very response will be make

00:25:52,490 --> 00:25:55,970
don't should not be like your for every

00:25:54,560 --> 00:26:00,740
you know APA requests or things of that

00:25:55,970 --> 00:26:02,720
sort you are calling in a rushed build

00:26:00,740 --> 00:26:05,660
function other statically typed rush

00:26:02,720 --> 00:26:09,020
functions so what does last has to offer

00:26:05,660 --> 00:26:10,400
it's modern replacement to C++ and if

00:26:09,020 --> 00:26:11,690
you're someone like me who is looking

00:26:10,400 --> 00:26:13,250
for learning system building language

00:26:11,690 --> 00:26:15,350
and then feels see process is a bit

00:26:13,250 --> 00:26:16,790
difficult to learn this is definitely a

00:26:15,350 --> 00:26:18,470
good choice and apart from that it's

00:26:16,790 --> 00:26:20,990
about improving your tool chain you you

00:26:18,470 --> 00:26:22,280
wanted you want to like learn on a

00:26:20,990 --> 00:26:23,660
day-to-day basis because there's some

00:26:22,280 --> 00:26:26,480
concepts that we don't really care about

00:26:23,660 --> 00:26:28,520
in Python but given computer science

00:26:26,480 --> 00:26:30,140
advancing so fast you need those Lang we

00:26:28,520 --> 00:26:31,370
need to know about those concepts and

00:26:30,140 --> 00:26:32,600
thrush is a very good way to learn them

00:26:31,370 --> 00:26:35,090
I personally learned it that way

00:26:32,600 --> 00:26:37,130
yesterday's runtime and then has a lot

00:26:35,090 --> 00:26:38,780
of strong functional programming

00:26:37,130 --> 00:26:40,220
influence which is really good and just

00:26:38,780 --> 00:26:43,250
something that we as Python developers

00:26:40,220 --> 00:26:46,490
really love so we have feel awesome like

00:26:43,250 --> 00:26:49,550
you know and that's pretty much about

00:26:46,490 --> 00:26:52,640
all that I wanted to cover and thank you

00:26:49,550 --> 00:26:54,410
so much like you can my great deviation

00:26:52,640 --> 00:26:56,240
in Twitter and then I have just put

00:26:54,410 --> 00:26:58,850
together some good talks in my con us

00:26:56,240 --> 00:27:00,620
tiny warp icon us so do feel to feel

00:26:58,850 --> 00:27:01,940
free to go check them out I think we

00:27:00,620 --> 00:27:05,560
have couple of more minutes left for

00:27:01,940 --> 00:27:05,560
questions thanks so much

00:27:20,020 --> 00:27:24,200
so if anyone has any questions please

00:27:22,790 --> 00:27:25,640
feel free to step up to the question

00:27:24,200 --> 00:27:28,790
mics there's one over here and one over

00:27:25,640 --> 00:27:30,980
there yeah we've got a couple more

00:27:28,790 --> 00:27:35,540
minutes so please please ask anything

00:27:30,980 --> 00:27:39,620
that's on your mind I'll be only a so

00:27:35,540 --> 00:27:43,010
feel free do you know yeah I was curious

00:27:39,620 --> 00:27:45,590
do you know if rust has much libraries

00:27:43,010 --> 00:27:47,360
for scientific computing like crunching

00:27:45,590 --> 00:27:50,660
numbers like people do with them by and

00:27:47,360 --> 00:27:53,030
stuff at this woman not many I'll be

00:27:50,660 --> 00:27:54,710
honest with you but that's something

00:27:53,030 --> 00:27:56,600
that I like to do in my free time I'm

00:27:54,710 --> 00:27:59,179
building where you know some deep

00:27:56,600 --> 00:28:00,620
learning packages like just one deep

00:27:59,179 --> 00:28:01,970
learning package well it's a fun thing

00:28:00,620 --> 00:28:03,980
to do you know you'll you'll learn a lot

00:28:01,970 --> 00:28:05,270
in that process they are very few

00:28:03,980 --> 00:28:08,000
actually very very specific to

00:28:05,270 --> 00:28:11,059
industries but there's a lot of amazing

00:28:08,000 --> 00:28:13,670
crates in networking embedded systems

00:28:11,059 --> 00:28:15,410
and those areas but we have a scientific

00:28:13,670 --> 00:28:17,660
computing we are not there yet

00:28:15,410 --> 00:28:22,610
but it's a very very interesting domain

00:28:17,660 --> 00:28:26,690
for rust yes thanks all right thanks for

00:28:22,610 --> 00:28:29,450
the talk so if I take an umpire array

00:28:26,690 --> 00:28:31,460
and I pass it to rust or if rust has

00:28:29,450 --> 00:28:34,460
some array and it wants to pass it back

00:28:31,460 --> 00:28:36,860
to Python what does it show up as like

00:28:34,460 --> 00:28:41,030
do you have to specify all the like the

00:28:36,860 --> 00:28:42,860
shapes manually or so so that's where

00:28:41,030 --> 00:28:45,500
things like you know rusty Python comes

00:28:42,860 --> 00:28:46,910
into picture they handle it for you but

00:28:45,500 --> 00:28:50,120
if you want to do that from scratch you

00:28:46,910 --> 00:28:57,559
can use the rust in build FFI modules to

00:28:50,120 --> 00:28:59,360
do that okay thank you yeah so currently

00:28:57,559 --> 00:29:01,160
if I want to speed up something with

00:28:59,360 --> 00:29:02,570
Python as far as computation is

00:29:01,160 --> 00:29:04,880
concerned I'm probably gonna use either

00:29:02,570 --> 00:29:07,550
scythe on or C++ or something along

00:29:04,880 --> 00:29:09,820
those lines out what kind of situations

00:29:07,550 --> 00:29:13,760
have you seen where rust will outperform

00:29:09,820 --> 00:29:15,880
scythe on or C++ I've not actually

00:29:13,760 --> 00:29:18,140
benchmarked between syphon and rust

00:29:15,880 --> 00:29:20,179
sometimes I think you get like really

00:29:18,140 --> 00:29:21,080
close performance really depends on what

00:29:20,179 --> 00:29:23,840
you are building and what your

00:29:21,080 --> 00:29:25,520
application is but like you know it's

00:29:23,840 --> 00:29:27,500
not all about control and you I showed

00:29:25,520 --> 00:29:29,390
some use cases right like in web

00:29:27,500 --> 00:29:32,210
development parsing and things of that

00:29:29,390 --> 00:29:33,200
sort they're starting to be in a good

00:29:32,210 --> 00:29:37,460
performance boost over

00:29:33,200 --> 00:29:39,620
that thank you hey thanks for the talk

00:29:37,460 --> 00:29:41,480
do you know of any Python C libraries

00:29:39,620 --> 00:29:44,179
that have switched to rest and what

00:29:41,480 --> 00:29:48,799
their experience like that has been yeah

00:29:44,179 --> 00:29:50,809
so the sentry guys have done that not

00:29:48,799 --> 00:29:52,279
really sure with the library names but

00:29:50,809 --> 00:29:58,179
there are a couple of them out that I

00:29:52,279 --> 00:30:01,760
can I can share that you later yeah

00:29:58,179 --> 00:30:06,080
thanks for the introduction to rust in

00:30:01,760 --> 00:30:08,750
your summary slide one line use rust is

00:30:06,080 --> 00:30:11,840
no wrong time needed can you kind of

00:30:08,750 --> 00:30:14,870
explain it a little bit I'm sorry I

00:30:11,840 --> 00:30:20,080
didn't follow the question one over your

00:30:14,870 --> 00:30:22,490
long says Ross is not wrong time needed

00:30:20,080 --> 00:30:26,049
I'm really really sorry I'm not able to

00:30:22,490 --> 00:30:26,049
pull are you able to get the question

00:30:28,000 --> 00:30:32,720
okay yeah so you're basically compiling

00:30:30,980 --> 00:30:34,880
ahead of time so you have your entire

00:30:32,720 --> 00:30:37,279
abstract syntax tree built so that's

00:30:34,880 --> 00:30:39,409
something python does on the fly right

00:30:37,279 --> 00:30:40,519
it's it's a scripting language and the

00:30:39,409 --> 00:30:42,649
other one is a system programming

00:30:40,519 --> 00:30:45,889
language that's where you get that kind

00:30:42,649 --> 00:30:47,950
of compute computation boost so that's

00:30:45,889 --> 00:30:51,980
that's what i meant by no runtime minute

00:30:47,950 --> 00:30:54,309
thank you hope that helps yeah thank you

00:30:51,980 --> 00:30:54,309
so much guys

00:30:54,530 --> 00:30:56,590

YouTube URL: https://www.youtube.com/watch?v=UYpWVfTng4s


