Title: Greg Price - Clearer Code at Scale: Static Types at Zulip and Dropbox - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Greg Price

Python now offers static types! Companies like Dropbox and Facebook, and open-source projects like Zulip, use static types (with [PEP 484](https://www.python.org/dev/peps/pep-0484/) and [mypy](https://github.com/python/mypy)) to make Python more productive and fun to work with — in existing codebases from 40k lines to 4 million, in Python 2 and 3, and while preserving the conciseness and flexibility that make Python a great language in the first place. I’ll describe how.

Reading and understanding code is a huge part of what we do as software developers. If we make it easier to understand our codebases, we make everyone more productive, help each other write fewer bugs, and lower barriers for new contributors. That's why Python now features optional static types, and why Dropbox, [Facebook](https://engineering.instagram.com/let-your-code-type-hint-itself-introducing-open-source-monkeytype-a855c7284881), and [Zulip](https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/) use them on part or all of their Python code.

In this talk, I’ll share lessons from Zulip’s and Dropbox’s experience — having led the mypy team at Dropbox and working now on the Zulip core team — for how you can start using static types in your own codebases, large or small. We’ll discuss how to make it a seamless part of your project’s tooling; what order to approach things in; and powerful new tools that make it even easier today to add static types to your Python codebase than ever before.


Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:08,630 --> 00:00:13,830
let's welcome our next speaker Greg

00:00:11,460 --> 00:00:17,750
price he's going to introduce himself in

00:00:13,830 --> 00:00:17,750
great detail so I'll let him get to it

00:00:17,830 --> 00:00:28,140
[Applause]

00:00:23,029 --> 00:00:30,029
hello everyone welcome I'm gonna tell

00:00:28,140 --> 00:00:33,570
you about how to make your code clearer

00:00:30,029 --> 00:00:37,980
even in a big codebase so a word with

00:00:33,570 --> 00:00:40,020
myself not too much to do when I was in

00:00:37,980 --> 00:00:42,840
college and grad school I started math

00:00:40,020 --> 00:00:45,030
and si si was proving theorems and I

00:00:42,840 --> 00:00:47,700
decided to go off to startups industry

00:00:45,030 --> 00:00:50,250
build things but kept the conviction

00:00:47,700 --> 00:00:52,260
that if you write things sometimes if

00:00:50,250 --> 00:00:53,850
you write things clearly you can make it

00:00:52,260 --> 00:00:57,030
actually clear that things are right and

00:00:53,850 --> 00:00:59,149
you can do that and it it can be better

00:00:57,030 --> 00:01:02,520
than then trying to show that they're

00:00:59,149 --> 00:01:04,439
they're not wrong and after various

00:01:02,520 --> 00:01:06,180
startups ended up at Dropbox for about

00:01:04,439 --> 00:01:09,720
three years where I helped create a team

00:01:06,180 --> 00:01:13,260
with the charge of making helping us

00:01:09,720 --> 00:01:15,479
make software better faster build better

00:01:13,260 --> 00:01:16,439
systems move faster and learn faster

00:01:15,479 --> 00:01:19,560
what the right products already built

00:01:16,439 --> 00:01:22,140
and we had by the time I left 700

00:01:19,560 --> 00:01:24,770
engineers most of them working in Python

00:01:22,140 --> 00:01:27,479
and most of those working in the same

00:01:24,770 --> 00:01:31,350
giant codebase many millions several

00:01:27,479 --> 00:01:33,780
millions of lines and so that was that

00:01:31,350 --> 00:01:36,090
was an education and now I'm working on

00:01:33,780 --> 00:01:38,189
Zula which just a word about that it's

00:01:36,090 --> 00:01:39,900
an open-source team chat application you

00:01:38,189 --> 00:01:43,340
might have heard of it actually core

00:01:39,900 --> 00:01:46,140
Python Devi's is started to use it now

00:01:43,340 --> 00:01:48,090
looks like this

00:01:46,140 --> 00:01:51,329
the thing we're most proud of as a

00:01:48,090 --> 00:01:53,610
product is it has threads that work

00:01:51,329 --> 00:01:55,170
which we think we feel supports like

00:01:53,610 --> 00:01:56,969
real discussions of some discussions

00:01:55,170 --> 00:01:59,790
more so than you can get in in slack or

00:01:56,969 --> 00:02:01,530
an IRC which are clones and makes it

00:01:59,790 --> 00:02:03,810
possible to not be constantly on and not

00:02:01,530 --> 00:02:06,060
miss things but what's relevant in this

00:02:03,810 --> 00:02:08,160
talk is sort of another side of what

00:02:06,060 --> 00:02:09,830
we're proud of as Ulla which is the open

00:02:08,160 --> 00:02:13,379
source community that we have built

00:02:09,830 --> 00:02:13,980
where we've we've really made it the

00:02:13,379 --> 00:02:15,209
case and I

00:02:13,980 --> 00:02:19,140
can't take most of the credit for this

00:02:15,209 --> 00:02:21,420
myself but that people can actually show

00:02:19,140 --> 00:02:24,840
up from the internet never worked on zoo

00:02:21,420 --> 00:02:28,380
before many of them without much program

00:02:24,840 --> 00:02:30,120
experience or open-source experience and

00:02:28,380 --> 00:02:33,209
actually make productive contributions

00:02:30,120 --> 00:02:34,650
that were glad to take and we've had

00:02:33,209 --> 00:02:36,300
over 400 people contribute to the code

00:02:34,650 --> 00:02:38,730
and we have commit over a hundred

00:02:36,300 --> 00:02:41,580
commits every week from typically dozens

00:02:38,730 --> 00:02:43,739
of people so that's not easy

00:02:41,580 --> 00:02:45,420
lots of open-source products don't don't

00:02:43,739 --> 00:02:48,390
manage that it takes a lot of work and

00:02:45,420 --> 00:02:51,110
some skill and I'm and one of the key

00:02:48,390 --> 00:02:53,880
things it takes is making the code clear

00:02:51,110 --> 00:02:55,470
because if the code is clear then people

00:02:53,880 --> 00:02:58,019
can come and can understand it and can

00:02:55,470 --> 00:02:59,340
write good changes and also if it's

00:02:58,019 --> 00:03:01,260
clear then it's we're in a much better

00:02:59,340 --> 00:03:04,200
position to review it and without a lot

00:03:01,260 --> 00:03:08,670
of effort to termini can actually merge

00:03:04,200 --> 00:03:09,810
it which I think puts up a lot is the

00:03:08,670 --> 00:03:10,739
source of barriers for a lot of open

00:03:09,810 --> 00:03:11,970
source projects there's just hard to

00:03:10,739 --> 00:03:17,010
tell if this contribution from a

00:03:11,970 --> 00:03:17,700
newcomer is is good and and so I'll be

00:03:17,010 --> 00:03:18,900
telling you about one of the

00:03:17,700 --> 00:03:19,500
technologies we use for that and a

00:03:18,900 --> 00:03:22,560
Dropbox

00:03:19,500 --> 00:03:26,040
similarly we wanted clear code we knew

00:03:22,560 --> 00:03:27,840
from surveys that 40% of the time that

00:03:26,040 --> 00:03:29,880
our engineers spent doing engineering

00:03:27,840 --> 00:03:32,310
was reading code and trying to

00:03:29,880 --> 00:03:35,730
understand it it's a huge part of

00:03:32,310 --> 00:03:37,140
everyone's day and when we can make that

00:03:35,730 --> 00:03:41,790
better that's a that has a big impact

00:03:37,140 --> 00:03:44,459
and that's why we built my PI there why

00:03:41,790 --> 00:03:47,700
I was able to get that at effort going

00:03:44,459 --> 00:03:50,549
and Dropbox engineers have loved it it's

00:03:47,700 --> 00:03:54,620
now on over 2 million lines of Python

00:03:50,549 --> 00:03:58,230
code is now statically typed at Dropbox

00:03:54,620 --> 00:04:01,709
and in fact there's a full-time team at

00:03:58,230 --> 00:04:05,100
Dropbox because the company values it so

00:04:01,709 --> 00:04:07,980
much for people Yuuka who's actually PhD

00:04:05,100 --> 00:04:10,790
thesis it was at the beginning and guido

00:04:07,980 --> 00:04:13,799
you know and a couple other people and

00:04:10,790 --> 00:04:14,910
so that that was that was my team in the

00:04:13,799 --> 00:04:17,150
past and there's many other people

00:04:14,910 --> 00:04:20,810
contributing it's an open-source project

00:04:17,150 --> 00:04:24,150
so we're talking about making code clear

00:04:20,810 --> 00:04:26,039
let's let's make it concrete I'm gonna

00:04:24,150 --> 00:04:27,389
tell you a little parable a story that

00:04:26,039 --> 00:04:29,280
I've lived many

00:04:27,389 --> 00:04:32,099
in many code bases Dropbox and elsewhere

00:04:29,280 --> 00:04:34,080
and that I think probably most of you

00:04:32,099 --> 00:04:37,319
have to in any code base where there's

00:04:34,080 --> 00:04:39,569
many other people working in it so

00:04:37,319 --> 00:04:41,939
here's some code you want to understand

00:04:39,569 --> 00:04:45,659
it it's a function we're interested in

00:04:41,939 --> 00:04:49,710
just this one line we try to validate a

00:04:45,659 --> 00:04:53,580
thing what does it do well it calls this

00:04:49,710 --> 00:04:55,289
method called validate we've we need to

00:04:53,580 --> 00:04:56,639
go look up that method and if we're

00:04:55,289 --> 00:04:57,659
lucky there will be documentation if

00:04:56,639 --> 00:04:58,860
we're less lucky read the implantation

00:04:57,659 --> 00:05:03,330
either way we need to fine the method

00:04:58,860 --> 00:05:06,300
okay so which method is that well we can

00:05:03,330 --> 00:05:09,270
go grep the code base for methods named

00:05:06,300 --> 00:05:12,689
validate but there might be a lot of

00:05:09,270 --> 00:05:14,610
them and in fact in the drop box code

00:05:12,689 --> 00:05:17,909
base there are over a hundred methods

00:05:14,610 --> 00:05:19,800
with that name and it's not because

00:05:17,909 --> 00:05:21,659
there's you know some base class the

00:05:19,800 --> 00:05:24,240
things implant or some API no no yet

00:05:21,659 --> 00:05:27,379
they're they're just independent uses of

00:05:24,240 --> 00:05:29,400
the name because it's a good word and

00:05:27,379 --> 00:05:31,349
there's lots of good words out there so

00:05:29,400 --> 00:05:34,469
there's this happens a lot that there

00:05:31,349 --> 00:05:36,089
are many methods by the same name and so

00:05:34,469 --> 00:05:37,710
when it comes down to to try to find

00:05:36,089 --> 00:05:39,960
this method so you can find out what it

00:05:37,710 --> 00:05:42,810
does is what is the type of the thing

00:05:39,960 --> 00:05:44,250
we're calling it on and lots of other

00:05:42,810 --> 00:05:45,750
cases of understanding code come down to

00:05:44,250 --> 00:05:48,710
this same former question what is the

00:05:45,750 --> 00:05:52,620
type of this thing we're acting on and

00:05:48,710 --> 00:05:54,330
okay well how we answer that depends

00:05:52,620 --> 00:05:55,849
where it comes from a very common case

00:05:54,330 --> 00:05:59,699
it comes from a parameter the function

00:05:55,849 --> 00:06:01,020
so we'll take that and great so how do

00:05:59,699 --> 00:06:04,289
we find out what type that is well we

00:06:01,020 --> 00:06:06,150
can go grep for call sites of the

00:06:04,289 --> 00:06:08,460
function right because what type is it

00:06:06,150 --> 00:06:09,539
is ultimately what the callers pass so

00:06:08,460 --> 00:06:10,620
we can go right for that and if we're

00:06:09,539 --> 00:06:12,360
lucky there's only one method by this

00:06:10,620 --> 00:06:14,909
name if we're less lucky it's named

00:06:12,360 --> 00:06:17,009
validate but say we are lucky we don't

00:06:14,909 --> 00:06:20,250
have that problem there may be a lot of

00:06:17,009 --> 00:06:23,310
call sites and at each of them we now

00:06:20,250 --> 00:06:24,810
have the same problem recursively if you

00:06:23,310 --> 00:06:26,279
have to sort out what type the argument

00:06:24,810 --> 00:06:28,199
is and if we're lucky it's like a string

00:06:26,279 --> 00:06:30,449
little or something and it's clear but

00:06:28,199 --> 00:06:33,419
but very often it's going to be another

00:06:30,449 --> 00:06:34,800
function call or it'll be a variable

00:06:33,419 --> 00:06:37,529
that perhaps was a parameter to that

00:06:34,800 --> 00:06:39,959
function there caller and so we end up

00:06:37,529 --> 00:06:40,950
searching after this first search for

00:06:39,959 --> 00:06:42,600
each of the callers

00:06:40,950 --> 00:06:45,080
searching for the call sites of those

00:06:42,600 --> 00:06:47,250
and we end up in this whole search tree

00:06:45,080 --> 00:06:48,390
where we may have to read through

00:06:47,250 --> 00:06:51,270
thousands and thousand lines of code

00:06:48,390 --> 00:06:56,760
just to understand what this one line

00:06:51,270 --> 00:06:59,850
did and was that's the thing I've done

00:06:56,760 --> 00:07:02,670
many times and I never want to do again

00:06:59,850 --> 00:07:08,060
and I never want my co-workers have to

00:07:02,670 --> 00:07:13,470
do again and that's what types are for

00:07:08,060 --> 00:07:15,480
static types so when we have an answer

00:07:13,470 --> 00:07:18,390
to what that is maybe from that search

00:07:15,480 --> 00:07:19,830
or better yet when we write the code you

00:07:18,390 --> 00:07:23,100
can write down the answer at the top of

00:07:19,830 --> 00:07:24,900
the function and if you do that then now

00:07:23,100 --> 00:07:27,870
when I go and I try to understand it and

00:07:24,900 --> 00:07:30,240
and and ask like what type is this thing

00:07:27,870 --> 00:07:34,620
the search terminates the depth zero

00:07:30,240 --> 00:07:36,120
that's right there top the function and

00:07:34,620 --> 00:07:39,750
so this makes things much much easier

00:07:36,120 --> 00:07:42,090
and by the way that syntax was for

00:07:39,750 --> 00:07:46,200
Python 3 only but if you're in Python -

00:07:42,090 --> 00:07:48,180
there's a syntax that totally works it

00:07:46,200 --> 00:07:52,800
doesn't looks nice but it works just as

00:07:48,180 --> 00:07:55,050
well and in fact I'll I'm gonna dwell on

00:07:52,800 --> 00:07:56,040
this a bit because I know this is

00:07:55,050 --> 00:07:59,010
something I know people get confused

00:07:56,040 --> 00:08:00,680
about which is perhaps our fault as the

00:07:59,010 --> 00:08:03,960
mypie developers but I'll do my bit here

00:08:00,680 --> 00:08:08,810
if you're still working in Python to

00:08:03,960 --> 00:08:10,980
seven and static types are for you - and

00:08:08,810 --> 00:08:12,990
that's a message for you and I hope if

00:08:10,980 --> 00:08:15,630
you have friends who are working in

00:08:12,990 --> 00:08:20,310
Python - still you will tell them setec

00:08:15,630 --> 00:08:22,440
types are for Python - as well those two

00:08:20,310 --> 00:08:30,060
million lines at Dropbox that are types

00:08:22,440 --> 00:08:33,090
are Python 2.7 and Zula added types

00:08:30,060 --> 00:08:36,540
first actually in 2016 before we then

00:08:33,090 --> 00:08:37,979
move to Python 3 and in fact once the

00:08:36,540 --> 00:08:42,390
types are in place that migration to

00:08:37,979 --> 00:08:44,970
Python 3 was easy because once the types

00:08:42,390 --> 00:08:47,280
pass in Python 2 and in Python 3 and

00:08:44,970 --> 00:08:50,550
once in particular you've sorted out the

00:08:47,280 --> 00:08:52,470
difference between whites and Unicode so

00:08:50,550 --> 00:08:54,930
the type checker accepts that in both 2

00:08:52,470 --> 00:09:04,980
and 3 mode there's just not that much

00:08:54,930 --> 00:09:06,990
left great so Python 2 as well as 3 so

00:09:04,980 --> 00:09:08,339
alright so maybe you're convinced maybe

00:09:06,990 --> 00:09:10,529
you would love to have static types in

00:09:08,339 --> 00:09:11,790
your codebase but of course you probably

00:09:10,529 --> 00:09:13,560
have a bunch of code already that

00:09:11,790 --> 00:09:15,000
doesn't have it most of us most of the

00:09:13,560 --> 00:09:17,339
time are working in a code base with

00:09:15,000 --> 00:09:21,330
lots of stuff in it already maybe

00:09:17,339 --> 00:09:26,190
millions of lines there's good news you

00:09:21,330 --> 00:09:28,110
can adopt it in that code base and again

00:09:26,190 --> 00:09:29,310
I'm speaking from experience with Zulu

00:09:28,110 --> 00:09:32,160
which is now almost a hundred thousand

00:09:29,310 --> 00:09:34,560
lines and went to 100 sent typed already

00:09:32,160 --> 00:09:38,310
in 2016 when the tools were a lot less

00:09:34,560 --> 00:09:42,240
mature than they are now and Dropbox

00:09:38,310 --> 00:09:43,860
again over 2 million and this is in my

00:09:42,240 --> 00:09:45,839
personal experience but I've talked with

00:09:43,860 --> 00:09:48,209
these people many times at Instagram

00:09:45,839 --> 00:09:50,550
which you may not know is the world's

00:09:48,209 --> 00:09:54,810
largest django app as far as anyone

00:09:50,550 --> 00:09:58,220
knows and they are right now at about

00:09:54,810 --> 00:10:00,540
50% type they started about a year ago

00:09:58,220 --> 00:10:04,529
so that's millions of lines at at

00:10:00,540 --> 00:10:06,870
Facebook as well I think so I'll

00:10:04,529 --> 00:10:08,130
describe a few principles for how I

00:10:06,870 --> 00:10:11,190
think all of these projects have gone

00:10:08,130 --> 00:10:12,720
about it so I'll go into much more

00:10:11,190 --> 00:10:15,540
detail at each of these you're gonna

00:10:12,720 --> 00:10:16,800
want to work incrementally the system is

00:10:15,540 --> 00:10:18,690
designed so that you get the benefit

00:10:16,800 --> 00:10:21,390
actually early on when even just a small

00:10:18,690 --> 00:10:23,520
fraction your codebase is typed you want

00:10:21,390 --> 00:10:26,520
to define what a clean build is and then

00:10:23,520 --> 00:10:29,970
keep it clean and consistently check and

00:10:26,520 --> 00:10:32,010
and not let errors creep in you can and

00:10:29,970 --> 00:10:34,110
you definitely should get started in a

00:10:32,010 --> 00:10:37,890
week or likely actually just in a couple

00:10:34,110 --> 00:10:40,500
of days and then move from there and you

00:10:37,890 --> 00:10:43,500
should definitely let robots do the work

00:10:40,500 --> 00:10:45,329
that's boring that's a luxury that that

00:10:43,500 --> 00:10:48,300
we didn't always have but you totally

00:10:45,329 --> 00:10:50,850
have now and should use so work

00:10:48,300 --> 00:10:53,880
incrementally the the set up type system

00:10:50,850 --> 00:10:55,680
that we have for Python is is gradual

00:10:53,880 --> 00:10:57,720
it's called gradual typing as that kind

00:10:55,680 --> 00:10:59,700
of turn for this well no that means is

00:10:57,720 --> 00:11:01,320
just that that when you have a cobia so

00:10:59,700 --> 00:11:05,010
it's partly typed and partly not the

00:11:01,320 --> 00:11:06,720
type part still benefits you you still

00:11:05,010 --> 00:11:08,580
got the benefit of of knowing what's

00:11:06,720 --> 00:11:12,779
going on there

00:11:08,580 --> 00:11:15,390
and this is not easy to to make the

00:11:12,779 --> 00:11:16,680
types of stable to to not just collapse

00:11:15,390 --> 00:11:17,580
in a mess of contradictions when I see

00:11:16,680 --> 00:11:19,740
is some places that doesn't know

00:11:17,580 --> 00:11:23,940
anything about 10-15 years ago nobody

00:11:19,740 --> 00:11:26,160
knew how did this in any language and

00:11:23,940 --> 00:11:27,779
that it's it's just develop since then

00:11:26,160 --> 00:11:32,100
and that's why it took a PhD thesis to

00:11:27,779 --> 00:11:34,470
begin this but we have it and so you

00:11:32,100 --> 00:11:35,870
should start with a few files even just

00:11:34,470 --> 00:11:42,839
a few functions and add more bit by bit

00:11:35,870 --> 00:11:44,250
and specifically you should define or

00:11:42,839 --> 00:11:46,020
the way you realize that is you should

00:11:44,250 --> 00:11:50,490
define what it means to to have a bill

00:11:46,020 --> 00:11:52,080
be clean so far in order to get the

00:11:50,490 --> 00:11:53,760
benefit that we described above that you

00:11:52,080 --> 00:11:55,529
can go look at the top function say oh I

00:11:53,760 --> 00:11:58,290
know what the type is it's it's that

00:11:55,529 --> 00:12:01,230
class there you have to be able to trust

00:11:58,290 --> 00:12:03,300
that annotation when you see it it can't

00:12:01,230 --> 00:12:06,270
be just like a comment or an old duck

00:12:03,300 --> 00:12:07,680
string from out where okay somebody

00:12:06,270 --> 00:12:09,810
thought that was a case once but they

00:12:07,680 --> 00:12:11,040
might've been wrong and even if they

00:12:09,810 --> 00:12:12,959
were the codes change and it might be

00:12:11,040 --> 00:12:15,140
out of date you have people to trust

00:12:12,959 --> 00:12:18,240
that that actually truly is the type and

00:12:15,140 --> 00:12:21,660
that's why we built my PI and the type

00:12:18,240 --> 00:12:24,690
checker so you need to run a type

00:12:21,660 --> 00:12:25,980
checker too regularly to confirm that

00:12:24,690 --> 00:12:30,120
the things are right and fix anything

00:12:25,980 --> 00:12:32,459
that's wrong and so the the playbook is

00:12:30,120 --> 00:12:34,860
you need to define some kind of

00:12:32,459 --> 00:12:38,910
reproducible build some like exact way

00:12:34,860 --> 00:12:41,040
of running my PI that then you maintain

00:12:38,910 --> 00:12:43,140
clean you keep it free of errors

00:12:41,040 --> 00:12:45,510
you should run it in your CI if you have

00:12:43,140 --> 00:12:48,270
CI which you totally should

00:12:45,510 --> 00:12:49,920
and and also run the exact same scripts

00:12:48,270 --> 00:12:51,270
in your local development workflow I

00:12:49,920 --> 00:12:52,920
know anytime you've you've had a bunch

00:12:51,270 --> 00:12:54,570
of stuff where you had a type error

00:12:52,920 --> 00:12:57,480
you're trying to fix it run the exact

00:12:54,570 --> 00:12:59,820
same script you run in CI that way they

00:12:57,480 --> 00:13:00,149
over did on the same page so how do you

00:12:59,820 --> 00:13:03,329
do that

00:13:00,149 --> 00:13:05,579
you should have in your repo a script

00:13:03,329 --> 00:13:07,770
that takes no arguments of its own no

00:13:05,579 --> 00:13:09,630
required arguments at least and does

00:13:07,770 --> 00:13:11,880
everything you need and the script might

00:13:09,630 --> 00:13:15,060
start out super simple here's a vo point

00:13:11,880 --> 00:13:20,280
one it's just my PI and a directory that

00:13:15,060 --> 00:13:22,410
contains all your code that will

00:13:20,280 --> 00:13:24,390
you'll rapidly want to move to an 0.2

00:13:22,410 --> 00:13:25,590
because that will we'll talk about some

00:13:24,390 --> 00:13:28,110
moment that'll probably get some errors

00:13:25,590 --> 00:13:30,510
up front and while you're fixing those

00:13:28,110 --> 00:13:32,070
you're going to want it run on on some

00:13:30,510 --> 00:13:33,540
like subset of files and here's sort of

00:13:32,070 --> 00:13:35,580
sketch what that might look like you

00:13:33,540 --> 00:13:39,000
might rather write it in Python but the

00:13:35,580 --> 00:13:40,890
shell fits on the slide better where in

00:13:39,000 --> 00:13:43,020
this example you maybe you look at all

00:13:40,890 --> 00:13:46,380
the all the files that like are actually

00:13:43,020 --> 00:13:48,480
in your repo and and you maybe have a

00:13:46,380 --> 00:13:52,770
list of files to include or a list to

00:13:48,480 --> 00:13:59,280
exclude one of the other both and and

00:13:52,770 --> 00:14:01,380
just past that list to to my PI when you

00:13:59,280 --> 00:14:03,360
want beyond 0.2 I have a recommendation

00:14:01,380 --> 00:14:06,540
go look at the script like this in the

00:14:03,360 --> 00:14:08,760
Zulu repo which has perhaps all the

00:14:06,540 --> 00:14:11,910
bells and whistles you'd want and this

00:14:08,760 --> 00:14:13,830
is arguably this is arguably a weakness

00:14:11,910 --> 00:14:16,200
of the my PI interface that you need

00:14:13,830 --> 00:14:17,700
this kind of script but let you do and

00:14:16,200 --> 00:14:18,810
it's essential again to have something

00:14:17,700 --> 00:14:20,190
reproducible that everyone on the same

00:14:18,810 --> 00:14:21,930
page about so that you don't have wait

00:14:20,190 --> 00:14:26,870
why why is this get an error you don't

00:14:21,930 --> 00:14:29,040
get an error that's why I had a script

00:14:26,870 --> 00:14:31,200
relatedly you want to write down the

00:14:29,040 --> 00:14:32,730
options to my PI there's a lot of

00:14:31,200 --> 00:14:35,390
options to configure turning on some

00:14:32,730 --> 00:14:37,080
checks or turning off some others and

00:14:35,390 --> 00:14:39,930
fortunately you can write those in a

00:14:37,080 --> 00:14:42,380
config file and you should definitely

00:14:39,930 --> 00:14:44,610
pin the version you use because my PI

00:14:42,380 --> 00:14:47,040
make is under development makes me

00:14:44,610 --> 00:14:48,960
releases and sometimes they fix bugs and

00:14:47,040 --> 00:14:51,510
sometimes those bugs are where it

00:14:48,960 --> 00:14:53,460
accepted code it shouldn't have so to

00:14:51,510 --> 00:14:55,320
keep your bill clean you need to you

00:14:53,460 --> 00:14:58,500
need to be thoughtful about upgrading

00:14:55,320 --> 00:14:59,700
and if you're using virtual end you can

00:14:58,500 --> 00:15:04,110
just stick it in requirements out txt

00:14:59,700 --> 00:15:06,480
and then of course run it in CI so you

00:15:04,110 --> 00:15:10,260
wanted to find a clean build and then

00:15:06,480 --> 00:15:11,280
keep it clean that's that's maybe the

00:15:10,260 --> 00:15:14,370
most important step not the most

00:15:11,280 --> 00:15:20,460
exciting though once you have started

00:15:14,370 --> 00:15:23,040
doing that you can you can get started

00:15:20,460 --> 00:15:27,720
with having the benefits of types so the

00:15:23,040 --> 00:15:31,730
first step that you might take and you

00:15:27,720 --> 00:15:34,350
should take is to run the type checker

00:15:31,730 --> 00:15:36,690
without yet adding a note

00:15:34,350 --> 00:15:38,070
it will when you do this it'll do a sort

00:15:36,690 --> 00:15:40,649
of a basic level of analysis on the

00:15:38,070 --> 00:15:42,750
whole code base basically they'll check

00:15:40,649 --> 00:15:44,070
the mud the top level of each module the

00:15:42,750 --> 00:15:49,020
stuff that's not inside a function

00:15:44,070 --> 00:15:51,510
definition or method definition and it

00:15:49,020 --> 00:15:52,790
will it'll probably give you some errors

00:15:51,510 --> 00:15:56,399
some things where it needs your help

00:15:52,790 --> 00:15:58,440
where like if you initialize a global

00:15:56,399 --> 00:15:59,940
variable it's an empty collection it

00:15:58,440 --> 00:16:01,260
needs to do tell what kind of list is

00:15:59,940 --> 00:16:07,830
that oh it's a list of integers that

00:16:01,260 --> 00:16:10,380
kind of thing and what I'd recommend is

00:16:07,830 --> 00:16:12,870
just run it you'll see this list might

00:16:10,380 --> 00:16:15,260
look like a long list don't worry it's

00:16:12,870 --> 00:16:18,649
it's pretty easy stuff to take care of

00:16:15,260 --> 00:16:20,820
and I would just go to the script and

00:16:18,649 --> 00:16:24,600
cut down a list of files you include

00:16:20,820 --> 00:16:26,880
maybe just one maybe a bunch that are no

00:16:24,600 --> 00:16:28,860
errors and then just start fixing these

00:16:26,880 --> 00:16:30,390
and almost all of these will be super

00:16:28,860 --> 00:16:33,360
easy so you could you should be able to

00:16:30,390 --> 00:16:36,839
get to probably your whole codebase

00:16:33,360 --> 00:16:39,750
pretty quickly and so that'll check the

00:16:36,839 --> 00:16:42,899
code at the top level module then check

00:16:39,750 --> 00:16:44,130
inside functions if you can and if your

00:16:42,899 --> 00:16:47,010
code base is in giant you totally can

00:16:44,130 --> 00:16:49,800
you should there's this this option to

00:16:47,010 --> 00:16:51,630
my PI called check untyped deaths and

00:16:49,800 --> 00:16:53,130
what that says is to to check not only

00:16:51,630 --> 00:16:54,450
the top level but but even where you

00:16:53,130 --> 00:16:56,730
haven't added annotations to go actually

00:16:54,450 --> 00:16:58,560
inside the function definitions and it

00:16:56,730 --> 00:16:59,700
won't people do a lot because it doesn't

00:16:58,560 --> 00:17:02,490
you know types yet because you burned

00:16:59,700 --> 00:17:06,780
them down but what it will do is sort of

00:17:02,490 --> 00:17:09,270
act like a like a smarter PI flakes like

00:17:06,780 --> 00:17:13,470
a linter that that has a pretty solid

00:17:09,270 --> 00:17:15,270
understanding of Python semantics and at

00:17:13,470 --> 00:17:18,720
this stage you'll get some errors again

00:17:15,270 --> 00:17:20,880
probably some of them be real bugs maybe

00:17:18,720 --> 00:17:23,550
bugs in exception hailing paths things

00:17:20,880 --> 00:17:25,079
you're tested and catch but probably

00:17:23,550 --> 00:17:26,579
some real bugs and probably also some

00:17:25,079 --> 00:17:29,190
stuff where you need to tell it the type

00:17:26,579 --> 00:17:34,559
of an empty collection things like that

00:17:29,190 --> 00:17:36,090
and and so this will it'll give you this

00:17:34,559 --> 00:17:39,830
again this sort of linter style benefit

00:17:36,090 --> 00:17:43,760
the the big power of doing this is that

00:17:39,830 --> 00:17:47,280
when you go on to start adding types

00:17:43,760 --> 00:17:47,940
this will greatly amplify the value of

00:17:47,280 --> 00:17:50,100
that

00:17:47,940 --> 00:17:53,610
because now you go and add the type to

00:17:50,100 --> 00:17:57,300
some function and my PI will see all the

00:17:53,610 --> 00:18:02,310
call sites and it'll be able to to cross

00:17:57,300 --> 00:18:03,720
check how the code interacts so check

00:18:02,310 --> 00:18:05,970
the top-level check inside function to

00:18:03,720 --> 00:18:07,980
check on type deaths and you should do

00:18:05,970 --> 00:18:09,420
this for the first I would say ten to a

00:18:07,980 --> 00:18:11,480
hundred thousand lines that you want to

00:18:09,420 --> 00:18:14,220
type this might be your whole codebase

00:18:11,480 --> 00:18:16,200
if it's if a couple is in that pick a

00:18:14,220 --> 00:18:18,870
section you want to start with and this

00:18:16,200 --> 00:18:22,680
for for one point of comparison when

00:18:18,870 --> 00:18:25,020
Zula adopted static types this stage

00:18:22,680 --> 00:18:26,960
going through both steps of this was

00:18:25,020 --> 00:18:29,130
about three days work

00:18:26,960 --> 00:18:31,830
that was a sixty thousand line codebase

00:18:29,130 --> 00:18:33,870
and that was in the early alpha stages

00:18:31,830 --> 00:18:37,350
of my PI and a lot of those three days

00:18:33,870 --> 00:18:39,900
of spent filing bugs which are fixed so

00:18:37,350 --> 00:18:45,830
this will be this will be quicker work

00:18:39,900 --> 00:18:48,720
for you in 2018 once you've done that

00:18:45,830 --> 00:18:51,810
you can start adding types to code and

00:18:48,720 --> 00:18:53,520
start bit-by-bit file-by-file getting

00:18:51,810 --> 00:18:55,080
the benefit of being able to see what

00:18:53,520 --> 00:18:58,590
the types are is you read code and

00:18:55,080 --> 00:18:59,790
understand much faster and the general

00:18:58,590 --> 00:19:02,550
strategy I'd recommend is start with

00:18:59,790 --> 00:19:04,560
core libraries core abstractions start

00:19:02,550 --> 00:19:09,000
with things that are called by tons of

00:19:04,560 --> 00:19:10,260
code because that way is you add it then

00:19:09,000 --> 00:19:12,750
to the other the sort of higher level

00:19:10,260 --> 00:19:13,860
application code it will see the

00:19:12,750 --> 00:19:15,480
connections and be able to cross check

00:19:13,860 --> 00:19:17,610
the types which is what the type checker

00:19:15,480 --> 00:19:19,020
is all about once you have the core

00:19:17,610 --> 00:19:22,130
abstractions and I think you're ready to

00:19:19,020 --> 00:19:24,810
start doing it to all new code you write

00:19:22,130 --> 00:19:26,820
an even code that is not new but you're

00:19:24,810 --> 00:19:28,830
editing because after all when you write

00:19:26,820 --> 00:19:32,100
the code or even when you go to make a

00:19:28,830 --> 00:19:35,660
change you hopefully know what you're

00:19:32,100 --> 00:19:37,860
doing and understand what the code does

00:19:35,660 --> 00:19:41,400
if you don't you should probably spend a

00:19:37,860 --> 00:19:43,800
little time understanding it anyway if

00:19:41,400 --> 00:19:44,970
you understand it that comes with some

00:19:43,800 --> 00:19:48,030
kind of expectation of what the types

00:19:44,970 --> 00:19:49,050
were supposed to be and these

00:19:48,030 --> 00:19:52,830
annotations are really just about

00:19:49,050 --> 00:19:53,940
writing that down so this is sort of

00:19:52,830 --> 00:19:59,070
algorithms in real life this is

00:19:53,940 --> 00:20:00,690
memoization it doesn't add much work and

00:19:59,070 --> 00:20:01,860
then once you're doing that at your

00:20:00,690 --> 00:20:04,320
leisure go back and

00:20:01,860 --> 00:20:05,910
and backfill all the stuff that that you

00:20:04,320 --> 00:20:08,130
haven't typed yet the stuff in the past

00:20:05,910 --> 00:20:12,929
and when you get to that and also for

00:20:08,130 --> 00:20:17,549
these core libraries the old-fashioned

00:20:12,929 --> 00:20:18,870
way is is work you're you're looking at

00:20:17,549 --> 00:20:20,040
some code you're figuring out what the

00:20:18,870 --> 00:20:22,350
types are supposed to be and that's

00:20:20,040 --> 00:20:24,540
that's the same story we told earlier

00:20:22,350 --> 00:20:28,170
right that's exactly the work we're

00:20:24,540 --> 00:20:30,450
trying to avoid and it's still it's

00:20:28,170 --> 00:20:32,340
still worth it even if you do it

00:20:30,450 --> 00:20:34,980
manually because at least you do it once

00:20:32,340 --> 00:20:36,299
and you write it down which is a lot

00:20:34,980 --> 00:20:37,860
better than doing it again and again and

00:20:36,299 --> 00:20:40,710
doing it when you're debugging and so on

00:20:37,860 --> 00:20:42,900
and this old-fashioned way is how sulit

00:20:40,710 --> 00:20:45,030
dr. % is how Dropbox did its first

00:20:42,900 --> 00:20:47,850
million lines there just wasn't weren't

00:20:45,030 --> 00:20:50,520
tools to make it easier but for you

00:20:47,850 --> 00:20:53,220
today you should definitely get some

00:20:50,520 --> 00:20:56,429
mechanical help because it's there there

00:20:53,220 --> 00:21:00,780
are several tools you can use to at

00:20:56,429 --> 00:21:02,460
runtime trace the actual types which is

00:21:00,780 --> 00:21:04,530
fantastic creating a draft of what the

00:21:02,460 --> 00:21:06,840
types are probably supposed to be

00:21:04,530 --> 00:21:09,179
there's monkey type developed at at

00:21:06,840 --> 00:21:11,760
Instagram Facebook there's pie in a

00:21:09,179 --> 00:21:12,840
tight pie annotate I drilled a Dropbox

00:21:11,760 --> 00:21:14,700
there's several others so you can find

00:21:12,840 --> 00:21:17,220
in the web those are two I actually know

00:21:14,700 --> 00:21:20,850
a little bit about there's also I have

00:21:17,220 --> 00:21:23,460
totally not tried to use this but but

00:21:20,850 --> 00:21:25,590
the some Python folks at Google have a

00:21:23,460 --> 00:21:27,630
tool called PI type that not at runtime

00:21:25,590 --> 00:21:30,210
but it tries to infer types and it does

00:21:27,630 --> 00:21:32,190
it much more aggressively than than a

00:21:30,210 --> 00:21:33,570
type checker like my PI would it it it

00:21:32,190 --> 00:21:36,210
does it like between functions and so on

00:21:33,570 --> 00:21:41,570
and they swear by it and you should try

00:21:36,210 --> 00:21:43,830
it out see if it works for you and and

00:21:41,570 --> 00:21:46,820
just to underline how perilous is

00:21:43,830 --> 00:21:50,970
Instagram actually runs Mikey type in

00:21:46,820 --> 00:21:53,970
production it's it slows the code down

00:21:50,970 --> 00:21:55,559
by like five times but for one million

00:21:53,970 --> 00:21:59,120
for the requests they figure that's okay

00:21:55,559 --> 00:22:01,500
and so maybe you can do that too

00:21:59,120 --> 00:22:03,179
if you're less brave you can run it on

00:22:01,500 --> 00:22:04,530
your tests or run Planet eight on your

00:22:03,179 --> 00:22:08,429
tests

00:22:04,530 --> 00:22:09,750
either way any of these tools will will

00:22:08,429 --> 00:22:12,210
function similar this example is monkey

00:22:09,750 --> 00:22:14,190
puppet type you you take the like data

00:22:12,210 --> 00:22:16,179
you produce sends it'll go and add the

00:22:14,190 --> 00:22:18,610
annotations to your code

00:22:16,179 --> 00:22:19,690
so you should play around with each of

00:22:18,610 --> 00:22:20,679
those try them out they're all

00:22:19,690 --> 00:22:22,990
relatively new they're written by

00:22:20,679 --> 00:22:26,409
different people with overlapping needs

00:22:22,990 --> 00:22:28,740
and use cases so which one is the best

00:22:26,409 --> 00:22:28,740
for you will depend

00:22:29,340 --> 00:22:33,940
these are drafts you should not take

00:22:32,710 --> 00:22:36,280
this annotation as necessary literally

00:22:33,940 --> 00:22:39,460
they will do things like oh I saw these

00:22:36,280 --> 00:22:42,000
eight different types go by and so it's

00:22:39,460 --> 00:22:44,140
a union of those but in fact they're all

00:22:42,000 --> 00:22:46,870
they're all subtypes of some base class

00:22:44,140 --> 00:22:48,789
you should just write that or it seems a

00:22:46,870 --> 00:22:50,380
function go by and it's pretty hard at

00:22:48,789 --> 00:22:52,990
runtime to sort out what type the

00:22:50,380 --> 00:22:55,000
functions supposed to be it's kind of

00:22:52,990 --> 00:22:56,409
fun really hard so so you're all as a

00:22:55,000 --> 00:22:58,570
human have to sort out what the type is

00:22:56,409 --> 00:23:00,970
actually posed to be more detail and

00:22:58,570 --> 00:23:03,610
also when you get these rafts from run

00:23:00,970 --> 00:23:06,039
time and sometimes it'll tell you that

00:23:03,610 --> 00:23:08,740
you had a type error somewhere else some

00:23:06,039 --> 00:23:09,789
other - annotation was wrong and so of

00:23:08,740 --> 00:23:12,640
course you want to sort that out so the

00:23:09,789 --> 00:23:14,710
build is clean before you check it in so

00:23:12,640 --> 00:23:16,870
it needs to min review but it it can get

00:23:14,710 --> 00:23:18,309
you a large fraction of the way make it

00:23:16,870 --> 00:23:24,549
much easier give you a lot of leverage

00:23:18,309 --> 00:23:26,740
and adding adding adding types all right

00:23:24,549 --> 00:23:28,000
so those are the four four key

00:23:26,740 --> 00:23:30,789
principles in my recommendation there's

00:23:28,000 --> 00:23:35,380
a secret fifth one which is you should

00:23:30,789 --> 00:23:38,110
expect your co-workers to love it once

00:23:35,380 --> 00:23:42,340
they see it in action

00:23:38,110 --> 00:23:45,450
I sometimes in the Python community

00:23:42,340 --> 00:23:49,210
there's a whole types those are terrible

00:23:45,450 --> 00:23:52,780
but I've never heard that from somebody

00:23:49,210 --> 00:23:54,970
at Dropbox and we got plenty of

00:23:52,780 --> 00:23:56,890
complaints and surveys about the tool

00:23:54,970 --> 00:23:59,320
isn't fast enough it's faster now

00:23:56,890 --> 00:24:01,000
the tools bugs are fixed plenty of

00:23:59,320 --> 00:24:02,909
complaints that are I want more types

00:24:01,000 --> 00:24:06,039
can you please give me more types sooner

00:24:02,909 --> 00:24:08,530
we've never heard a complaint that I

00:24:06,039 --> 00:24:11,110
wish we weren't doing types at all and

00:24:08,530 --> 00:24:13,990
instead the that comes together are like

00:24:11,110 --> 00:24:16,240
this that that refactoring is there's

00:24:13,990 --> 00:24:17,830
much much easier because you can you can

00:24:16,240 --> 00:24:20,200
see the types and you can relate them

00:24:17,830 --> 00:24:22,179
and and pycharm becomes more powerful if

00:24:20,200 --> 00:24:25,539
you use that refactoring before for

00:24:22,179 --> 00:24:28,270
highlighting type checkers will will

00:24:25,539 --> 00:24:28,960
soon integrate with with vs code and

00:24:28,270 --> 00:24:31,570
with

00:24:28,960 --> 00:24:34,060
Adam the Facebook's new one already does

00:24:31,570 --> 00:24:35,740
so you get all kinds of IDE goodness and

00:24:34,060 --> 00:24:38,260
Python that was fundamentally hard

00:24:35,740 --> 00:24:40,960
before or here's another drop box

00:24:38,260 --> 00:24:44,590
engineer who no connection to the MiFi

00:24:40,960 --> 00:24:48,520
team but they they got types on their

00:24:44,590 --> 00:24:51,610
code and it made a huge difference that

00:24:48,520 --> 00:24:54,940
they were very pleased with and this

00:24:51,610 --> 00:24:56,140
underlines why of those at Dropbox those

00:24:54,940 --> 00:24:59,050
two million lines of code they're

00:24:56,140 --> 00:25:02,530
annotated I'm almost none of that was by

00:24:59,050 --> 00:25:05,020
the mypie team that is engineers across

00:25:02,530 --> 00:25:06,850
the company see this they maybe see the

00:25:05,020 --> 00:25:08,830
first couple of teams that adopted it

00:25:06,850 --> 00:25:10,810
and what it did for them and they want

00:25:08,830 --> 00:25:13,510
it and they started doing the work to

00:25:10,810 --> 00:25:15,340
edit and and that again most of that

00:25:13,510 --> 00:25:16,600
half of that was before we had these

00:25:15,340 --> 00:25:21,310
mechanical tools that make it so much

00:25:16,600 --> 00:25:25,990
easier and not only Dropbox but at

00:25:21,310 --> 00:25:27,430
Instagram they're at 50% now of their

00:25:25,990 --> 00:25:31,360
huge codebase largest angle app in the

00:25:27,430 --> 00:25:33,430
world and the first half of that they

00:25:31,360 --> 00:25:37,510
say was the core team did a lot of push

00:25:33,430 --> 00:25:40,900
and then hands-off and it just took off

00:25:37,510 --> 00:25:42,390
grassroots as engineers see it and want

00:25:40,900 --> 00:25:45,250
more of it

00:25:42,390 --> 00:25:48,310
so those are my actual five principles

00:25:45,250 --> 00:25:49,570
how to do this you should totally take

00:25:48,310 --> 00:25:55,210
advantage the gradual nature work

00:25:49,570 --> 00:25:57,730
incrementally you need a clean build so

00:25:55,210 --> 00:25:59,770
you can trust the types you see and and

00:25:57,730 --> 00:26:02,740
so you can you can keep the progress you

00:25:59,770 --> 00:26:04,000
have as you make progress you can and

00:26:02,740 --> 00:26:06,910
totally should get started in a week or

00:26:04,000 --> 00:26:14,650
really less than that and let robots do

00:26:06,910 --> 00:26:16,870
all the boring stuff and that's what I

00:26:14,650 --> 00:26:19,150
have I hope you will try it out I think

00:26:16,870 --> 00:26:22,630
the easiest way to try it out is you go

00:26:19,150 --> 00:26:24,720
to the the my PI repo on github to read

00:26:22,630 --> 00:26:28,180
me there will get you started

00:26:24,720 --> 00:26:29,770
the my PI team will also be at the PyCon

00:26:28,180 --> 00:26:32,920
sprints starting tomorrow

00:26:29,770 --> 00:26:34,390
so if you are able to stay for that go

00:26:32,920 --> 00:26:36,550
go see them there they'll be working on

00:26:34,390 --> 00:26:39,370
on documentation and error messages so

00:26:36,550 --> 00:26:42,250
that's all stuff that you can very

00:26:39,370 --> 00:26:47,140
easily as a first-time user I think

00:26:42,250 --> 00:26:48,580
help with there's a detailed blog post

00:26:47,140 --> 00:26:50,350
by my new love colleague Tim Abbott

00:26:48,580 --> 00:26:53,710
which which you can find if you search

00:26:50,350 --> 00:26:55,020
for my pie Zula on the web with lots of

00:26:53,710 --> 00:26:58,300
detail tips on how it worked for us

00:26:55,020 --> 00:27:02,680
there are also two other talks today at

00:26:58,300 --> 00:27:05,050
PyCon on adopting static types and I can

00:27:02,680 --> 00:27:07,810
tell you about Carl Myers from Instagram

00:27:05,050 --> 00:27:08,680
because it happens in the last slot so

00:27:07,810 --> 00:27:10,270
they have to catch the video if you

00:27:08,680 --> 00:27:11,710
missed it but the videos go up real soon

00:27:10,270 --> 00:27:15,400
check back like tomorrow over the next

00:27:11,710 --> 00:27:17,370
day and he has a lot more detail on the

00:27:15,400 --> 00:27:20,140
type system which I didn't cover and

00:27:17,370 --> 00:27:22,330
also makes a different set of arguments

00:27:20,140 --> 00:27:25,030
for why you want types so if you're not

00:27:22,330 --> 00:27:26,680
totally convinced or you want help

00:27:25,030 --> 00:27:30,250
convincing your boss your coworkers

00:27:26,680 --> 00:27:31,720
check that out arguments I agree with it

00:27:30,250 --> 00:27:34,720
but you can't fit everything in in a

00:27:31,720 --> 00:27:37,270
talk and there's another talk on static

00:27:34,720 --> 00:27:39,760
types and on some I hear that haven't

00:27:37,270 --> 00:27:41,980
seen it yet some more advanced things

00:27:39,760 --> 00:27:45,550
you can do on top of it coming up in the

00:27:41,980 --> 00:27:48,340
next slot and with that I think we might

00:27:45,550 --> 00:27:58,170
have a couple of minutes of questions

00:27:48,340 --> 00:28:01,720
[Applause]

00:27:58,170 --> 00:28:06,960
hello yeah my name is Lyra and I work at

00:28:01,720 --> 00:28:09,940
patreon and we're about 25% of our code

00:28:06,960 --> 00:28:12,790
sorry we're at about 25% of our code

00:28:09,940 --> 00:28:15,030
being typed all right and we kind of hit

00:28:12,790 --> 00:28:18,430
a barrier which is sick alchemy is

00:28:15,030 --> 00:28:21,790
extremely non-friendly two types

00:28:18,430 --> 00:28:24,820
I know Dropbox users ikkaku me and I'm

00:28:21,790 --> 00:28:26,800
wondering how they achieve 100% yeah

00:28:24,820 --> 00:28:29,500
type coverage yeah you know I I don't

00:28:26,800 --> 00:28:30,700
have an up-to-date story and I think the

00:28:29,500 --> 00:28:31,560
team is sitting over there and you

00:28:30,700 --> 00:28:35,880
should ask them

00:28:31,560 --> 00:28:38,920
thank you yeah it's a good question hey

00:28:35,880 --> 00:28:41,560
is monkey type able to deal with bite on

00:28:38,920 --> 00:28:43,780
to code like building the type comments

00:28:41,560 --> 00:28:47,200
I doubt it

00:28:43,780 --> 00:28:48,670
yeah the the the archetype authors are

00:28:47,200 --> 00:28:51,130
very keen on you should be on the latest

00:28:48,670 --> 00:28:55,270
version always it's for Python 3 6 plus

00:28:51,130 --> 00:29:01,000
ok but PI annotate works great on to 7

00:28:55,270 --> 00:29:03,400
so you can use that ok thank you thanks

00:29:01,000 --> 00:29:05,110
for the talk what's the future of static

00:29:03,400 --> 00:29:10,600
typing and python like from here on out

00:29:05,110 --> 00:29:13,630
what's the future yes faster type

00:29:10,600 --> 00:29:15,210
checkers more integration with editors I

00:29:13,630 --> 00:29:19,780
think that's all relatively near term

00:29:15,210 --> 00:29:20,830
roadmap and there's there's been a

00:29:19,780 --> 00:29:22,180
number of developments in the type

00:29:20,830 --> 00:29:24,970
system which I didn't even get in touch

00:29:22,180 --> 00:29:28,330
with really at all today python 3 7 has

00:29:24,970 --> 00:29:30,940
some further developments and I'm sure

00:29:28,330 --> 00:29:32,410
there will be more that's far more

00:29:30,940 --> 00:29:34,860
detail than I can cover in this but

00:29:32,410 --> 00:29:34,860
thanks

00:29:42,919 --> 00:29:46,009

YouTube URL: https://www.youtube.com/watch?v=0c46YHS3RY8


