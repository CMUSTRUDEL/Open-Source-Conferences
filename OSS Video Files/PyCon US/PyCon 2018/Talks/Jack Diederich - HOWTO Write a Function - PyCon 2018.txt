Title: Jack Diederich - HOWTO Write a Function - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Jack Diederich

A function is a small chunk of code that does useful work. Your job when writing a function is to do it in a way that it easy to read. Based on over 15 years of code reviews here are some tips and guidelines I give again and again. 

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:06,350 --> 00:00:11,610
welcome everybody let's get started our

00:00:09,000 --> 00:00:22,920
next speaker is Jack Dieterich a core

00:00:11,610 --> 00:00:24,019
Python developer alright this is my con

00:00:22,920 --> 00:00:26,580
yeah good

00:00:24,019 --> 00:00:28,590
this talk is how to write a function a

00:00:26,580 --> 00:00:32,399
little bit about me this is my 16th

00:00:28,590 --> 00:00:33,989
PyCon so I've seen a lot of Python

00:00:32,399 --> 00:00:36,600
written read a lot of Python written a

00:00:33,989 --> 00:00:39,540
lot of Python myself and there's there's

00:00:36,600 --> 00:00:41,219
some things I say repeatedly when I'm

00:00:39,540 --> 00:00:44,010
looking at other people's code things I

00:00:41,219 --> 00:00:45,809
try to do in my own code if you've ever

00:00:44,010 --> 00:00:48,660
seen any of my other talks there they're

00:00:45,809 --> 00:00:52,440
mostly about code quality just how to do

00:00:48,660 --> 00:00:54,059
simple workmen like things you know your

00:00:52,440 --> 00:00:58,140
job is hard enough without people trying

00:00:54,059 --> 00:00:59,879
to clever up the place so this is a

00:00:58,140 --> 00:01:02,329
bunch of a bag of little tips and tricks

00:00:59,879 --> 00:01:06,180
things I say frequently in code reviews

00:01:02,329 --> 00:01:07,380
why talk about code reviews this is the

00:01:06,180 --> 00:01:09,780
one place most of you are going to get

00:01:07,380 --> 00:01:11,580
feedback on what you've written this is

00:01:09,780 --> 00:01:16,290
kind of your your last chance to polish

00:01:11,580 --> 00:01:18,330
up the code but before it goes out code

00:01:16,290 --> 00:01:22,259
reviews are kind of the gatekeeper for

00:01:18,330 --> 00:01:24,509
for publishing code and they force you

00:01:22,259 --> 00:01:27,150
to think about the reader so you read

00:01:24,509 --> 00:01:29,400
code a lot like that's a saying people

00:01:27,150 --> 00:01:31,590
read code more than they write it you

00:01:29,400 --> 00:01:33,560
yourself read the code you write many

00:01:31,590 --> 00:01:36,420
times before anyone else is even seen it

00:01:33,560 --> 00:01:37,650
you've read it when you write it you

00:01:36,420 --> 00:01:40,860
know when you're writing tests you're

00:01:37,650 --> 00:01:42,360
comparing the code and the tests you

00:01:40,860 --> 00:01:43,590
read it before you post it for review if

00:01:42,360 --> 00:01:46,560
you look for typos or anything else

00:01:43,590 --> 00:01:48,299
embarrassing the reviewer reads it

00:01:46,560 --> 00:01:51,270
depending on your organization might be

00:01:48,299 --> 00:01:54,030
multiple reviewers and then it goes out

00:01:51,270 --> 00:01:56,790
and any glass give or take forever until

00:01:54,030 --> 00:02:00,630
it's deleted so making the reader happy

00:01:56,790 --> 00:02:05,610
is very important why talk about a

00:02:00,630 --> 00:02:08,879
function function is 5 10 20 lines of

00:02:05,610 --> 00:02:12,020
code a function fits on a page most of

00:02:08,879 --> 00:02:13,430
your interactions in Python are

00:02:12,020 --> 00:02:15,110
if it's a function that's part of a

00:02:13,430 --> 00:02:17,210
class we call it a method but it's the

00:02:15,110 --> 00:02:19,790
same thing it's five ten twenty lines of

00:02:17,210 --> 00:02:22,700
code so the reader should be able to

00:02:19,790 --> 00:02:25,550
walk in and look at a function that's

00:02:22,700 --> 00:02:27,980
ten lines long and be able to figure out

00:02:25,550 --> 00:02:29,810
what it is if they already have domain

00:02:27,980 --> 00:02:32,450
knowledge about the module that it's in

00:02:29,810 --> 00:02:33,920
it might only take a minute but they

00:02:32,450 --> 00:02:35,870
should be able to to read it top to

00:02:33,920 --> 00:02:38,390
bottom and figure out what's going on

00:02:35,870 --> 00:02:39,590
if someone doesn't know anything about

00:02:38,390 --> 00:02:42,530
what the function is doing

00:02:39,590 --> 00:02:43,940
maybe they average like one line per

00:02:42,530 --> 00:02:45,800
minute understanding so they read a

00:02:43,940 --> 00:02:47,990
couple lines they go to and they say oh

00:02:45,800 --> 00:02:50,390
you know where were we again and they go

00:02:47,990 --> 00:02:52,550
back up but it's ten lines they should

00:02:50,390 --> 00:02:54,410
be able to to figure out what's going on

00:02:52,550 --> 00:02:58,150
and in a very short amount of time and

00:02:54,410 --> 00:02:58,150
it's your job is the writer to help them

00:02:59,170 --> 00:03:08,990
so there are lots of advice for always

00:03:04,670 --> 00:03:10,520
in Nevers this talk will not have any

00:03:08,990 --> 00:03:13,430
advice that hasn't always are never in

00:03:10,520 --> 00:03:15,890
it these are things I put in code

00:03:13,430 --> 00:03:17,140
reviews that usually sound like hey have

00:03:15,890 --> 00:03:19,250
you thought about this other thing or

00:03:17,140 --> 00:03:21,100
have you tried this what would it look

00:03:19,250 --> 00:03:23,360
like if you trim this other thing

00:03:21,100 --> 00:03:26,870
there's lots of device on the internet

00:03:23,360 --> 00:03:31,480
for always or Nevers here is a very

00:03:26,870 --> 00:03:34,250
simple function prints three lines

00:03:31,480 --> 00:03:37,370
completely understandable if someone

00:03:34,250 --> 00:03:41,360
comes along and says always make

00:03:37,370 --> 00:03:44,390
functions two lines or less this is easy

00:03:41,360 --> 00:03:45,680
feedback to give during a review you can

00:03:44,390 --> 00:03:48,620
you can literally give it on every

00:03:45,680 --> 00:03:52,700
review and it's easy advice to to action

00:03:48,620 --> 00:03:55,100
on and you end up with code like this so

00:03:52,700 --> 00:03:58,489
this is strictly followed the rule there

00:03:55,100 --> 00:04:00,980
is no function over two lines and the

00:03:58,489 --> 00:04:03,140
the reviewer is happy because he he gave

00:04:00,980 --> 00:04:05,450
you feedback and you're happy because

00:04:03,140 --> 00:04:07,520
you know you you action the feedback and

00:04:05,450 --> 00:04:09,610
everybody spent effort on this thing and

00:04:07,520 --> 00:04:12,020
it but it's actually not useful effort

00:04:09,610 --> 00:04:17,359
so my examples are going to be hopefully

00:04:12,020 --> 00:04:19,520
useful effort broadly speaking this talk

00:04:17,359 --> 00:04:22,070
has three parts thinking about function

00:04:19,520 --> 00:04:24,889
structure again a function is just not a

00:04:22,070 --> 00:04:26,780
big thing you should be able to

00:04:24,889 --> 00:04:28,400
look at a function and see what it does

00:04:26,780 --> 00:04:31,069
but but it generally has a flow from top

00:04:28,400 --> 00:04:33,080
to bottom helping the reader most of the

00:04:31,069 --> 00:04:34,759
small examples are things that you can

00:04:33,080 --> 00:04:37,219
do that just help the reader out a

00:04:34,759 --> 00:04:39,229
little bit and again if you're in a code

00:04:37,219 --> 00:04:41,719
review your job is to make it easy for

00:04:39,229 --> 00:04:43,909
the reader to say yes it's to make it

00:04:41,719 --> 00:04:45,650
easy for the reader to say this is this

00:04:43,909 --> 00:04:47,870
function does exactly what is promised

00:04:45,650 --> 00:04:51,110
ship it go out into the world no bugs

00:04:47,870 --> 00:04:53,719
and the final part which is shorter is

00:04:51,110 --> 00:04:55,759
things that don't help and advice you

00:04:53,719 --> 00:04:57,289
will get you can find on the internet

00:04:55,759 --> 00:04:59,449
things like functions shouldn't be

00:04:57,289 --> 00:05:03,110
longer than this moment number of lines

00:04:59,449 --> 00:05:09,909
and things to be on the look for look

00:05:03,110 --> 00:05:13,550
out for function structure functions

00:05:09,909 --> 00:05:15,409
it's again small bag of lines at the top

00:05:13,550 --> 00:05:17,000
you have input this is where you get the

00:05:15,409 --> 00:05:18,949
things that you were going to do in the

00:05:17,000 --> 00:05:20,150
middle there's a transform this is kind

00:05:18,949 --> 00:05:22,550
of where you add information to the

00:05:20,150 --> 00:05:24,830
system you're taking the inputs and then

00:05:22,550 --> 00:05:28,340
doing something to them that adds value

00:05:24,830 --> 00:05:30,770
and output at the end of every function

00:05:28,340 --> 00:05:35,029
is a return so this is what you are

00:05:30,770 --> 00:05:36,919
giving back to the reader I'm Twitter I

00:05:35,029 --> 00:05:39,770
tried to brainstorm some catchy names

00:05:36,919 --> 00:05:43,129
for for this concept I was not

00:05:39,770 --> 00:05:45,650
successful but but really a function

00:05:43,129 --> 00:05:48,650
should be unexcited your your job in a

00:05:45,650 --> 00:05:50,330
code review is to surprise no one and go

00:05:48,650 --> 00:05:52,159
on and get your job so the code of

00:05:50,330 --> 00:05:56,210
boringness the fund up funnel

00:05:52,159 --> 00:06:00,680
predictability let me know if any of

00:05:56,210 --> 00:06:02,900
these names catch on yeah so thinking

00:06:00,680 --> 00:06:04,870
about function structure the first thing

00:06:02,900 --> 00:06:07,189
that happens at the top of a function

00:06:04,870 --> 00:06:09,020
you were given some inputs or maybe you

00:06:07,189 --> 00:06:11,210
have to go out into the world and ask

00:06:09,020 --> 00:06:14,180
the database for some stuff that you

00:06:11,210 --> 00:06:17,089
need but input is where you're setting

00:06:14,180 --> 00:06:19,610
up expectations for the reader you are

00:06:17,089 --> 00:06:22,069
gathering up all the state of the world

00:06:19,610 --> 00:06:24,710
that will exist inside this function so

00:06:22,069 --> 00:06:26,779
at the top once the the reader has read

00:06:24,710 --> 00:06:28,969
the first few lines they should know

00:06:26,779 --> 00:06:31,279
okay you know he has an address and a

00:06:28,969 --> 00:06:34,430
user I bet I know where this is going

00:06:31,279 --> 00:06:35,930
and and then it should go there so at

00:06:34,430 --> 00:06:38,330
the top gather up the information you

00:06:35,930 --> 00:06:40,520
need throw out everything you don't

00:06:38,330 --> 00:06:44,090
so again this makes it easier for the

00:06:40,520 --> 00:06:45,740
reader if you the the database query

00:06:44,090 --> 00:06:47,840
that you do returns more information

00:06:45,740 --> 00:06:49,639
than you need let's try out this stuff

00:06:47,840 --> 00:06:51,020
you don't need and this tells the reader

00:06:49,639 --> 00:06:52,729
here is the two things that we're gonna

00:06:51,020 --> 00:06:54,110
care about in this function and then

00:06:52,729 --> 00:06:57,229
when you use those two things they're

00:06:54,110 --> 00:07:00,020
not surprised early errors are good

00:06:57,229 --> 00:07:01,819
errors so when you're gathering up the

00:07:00,020 --> 00:07:02,930
just the information you need if you

00:07:01,819 --> 00:07:04,729
don't have the information you need

00:07:02,930 --> 00:07:06,169
abort

00:07:04,729 --> 00:07:08,210
you're not going to be able to do the

00:07:06,169 --> 00:07:10,509
job that the function says it's going to

00:07:08,210 --> 00:07:13,219
do so just bail early with a nice error

00:07:10,509 --> 00:07:14,360
this not only makes it better when

00:07:13,219 --> 00:07:16,370
you're calling it because you get these

00:07:14,360 --> 00:07:18,460
big loud errors but it makes it easier

00:07:16,370 --> 00:07:20,509
for someone to review because they know

00:07:18,460 --> 00:07:22,340
they don't have to read the next the

00:07:20,509 --> 00:07:25,879
rest of the function to know these

00:07:22,340 --> 00:07:31,460
things are true and that's all you need

00:07:25,879 --> 00:07:33,740
on that note asserts add information so

00:07:31,460 --> 00:07:34,719
you are telling the reader that these

00:07:33,740 --> 00:07:42,139
two things are true

00:07:34,719 --> 00:07:44,599
keep reading transform this is the

00:07:42,139 --> 00:07:46,699
middle so you've set it up you have all

00:07:44,599 --> 00:07:49,610
the information you need to continue and

00:07:46,699 --> 00:07:51,889
this is where you collate people on

00:07:49,610 --> 00:07:54,590
addresses this is where you do matrix

00:07:51,889 --> 00:07:57,650
multiplication this is where you create

00:07:54,590 --> 00:08:00,770
something that has more value the reader

00:07:57,650 --> 00:08:02,389
should be bored at this point they've

00:08:00,770 --> 00:08:03,860
seen the inputs that you have they know

00:08:02,389 --> 00:08:06,319
the name of the function is transform

00:08:03,860 --> 00:08:09,590
matrix and in the middle you're going to

00:08:06,319 --> 00:08:13,340
transform the matrix great we like

00:08:09,590 --> 00:08:15,289
boring readers output is think of it

00:08:13,340 --> 00:08:18,020
like a printer printer so you've already

00:08:15,289 --> 00:08:19,279
had the inputs you've had the transform

00:08:18,020 --> 00:08:22,729
where you do the work in the middle and

00:08:19,279 --> 00:08:25,190
the output is creating whatever is

00:08:22,729 --> 00:08:26,479
useful to the caller so the function

00:08:25,190 --> 00:08:29,330
name might promise that you're returning

00:08:26,479 --> 00:08:32,120
them a list of names this is where you

00:08:29,330 --> 00:08:34,579
might have a dictionary of names or a

00:08:32,120 --> 00:08:36,890
set of names if you were making you know

00:08:34,579 --> 00:08:38,659
the result unique but if the function

00:08:36,890 --> 00:08:41,120
name promises that you're gonna return

00:08:38,659 --> 00:08:42,829
or a list of names this is the the point

00:08:41,120 --> 00:08:44,240
where you take the transform you did in

00:08:42,829 --> 00:08:45,100
the middle and you just turn it into a

00:08:44,240 --> 00:08:48,820
list of names

00:08:45,100 --> 00:08:48,820
callers happy everybody's happy

00:08:50,360 --> 00:08:58,280
so inputs happen first inputs is where

00:08:54,679 --> 00:08:59,529
the errors happen whenever possible so

00:08:58,280 --> 00:09:01,429
[Music]

00:08:59,529 --> 00:09:03,439
the first thing you should do when

00:09:01,429 --> 00:09:09,529
you're writing a function is think about

00:09:03,439 --> 00:09:11,329
your inputs in that there's lots of fun

00:09:09,529 --> 00:09:14,720
practice problems that you can find on

00:09:11,329 --> 00:09:16,309
the Internet project Euler if you want

00:09:14,720 --> 00:09:19,279
to do lots of stuff with combinatorics

00:09:16,309 --> 00:09:22,730
or you know just practice on on short

00:09:19,279 --> 00:09:25,660
problems those those are great ways to

00:09:22,730 --> 00:09:28,399
practice programming they don't help

00:09:25,660 --> 00:09:31,279
figure out how to they don't help teach

00:09:28,399 --> 00:09:33,999
you thinking about inputs because the

00:09:31,279 --> 00:09:36,170
inputs to every project Euler problem or

00:09:33,999 --> 00:09:40,850
exactly what you need to solve the

00:09:36,170 --> 00:09:43,369
problem and no more so in your real

00:09:40,850 --> 00:09:44,660
day-to-day job you're first the first

00:09:43,369 --> 00:09:46,459
thing you have to do when you're writing

00:09:44,660 --> 00:09:48,170
a function is figuring out how to get

00:09:46,459 --> 00:09:49,999
the information you need do I need to

00:09:48,170 --> 00:09:52,879
talk to the database do I need to call a

00:09:49,999 --> 00:09:55,309
REST API was everything passed in as

00:09:52,879 --> 00:09:57,319
arguments does a function so the first

00:09:55,309 --> 00:10:00,049
thing you have to do is figure out what

00:09:57,319 --> 00:10:01,189
you have and what you want and then to

00:10:00,049 --> 00:10:06,860
make it easier for the reader in the

00:10:01,189 --> 00:10:09,639
middle throw out what you don't need any

00:10:06,860 --> 00:10:12,739
time to practice thinking about inputs

00:10:09,639 --> 00:10:14,149
anytime you you see a board you can say

00:10:12,739 --> 00:10:15,759
okay how much information is in this

00:10:14,149 --> 00:10:18,110
board this is Conway's Game of Life

00:10:15,759 --> 00:10:21,709
there's five bits of information which

00:10:18,110 --> 00:10:24,379
dots are on a chess board doesn't have

00:10:21,709 --> 00:10:27,769
much information on it its positions and

00:10:24,379 --> 00:10:29,059
piece types and after you have these

00:10:27,769 --> 00:10:31,160
then you can figure out what you want to

00:10:29,059 --> 00:10:36,049
do with them but just try and think

00:10:31,160 --> 00:10:36,829
about inputs so here's an example

00:10:36,049 --> 00:10:39,230
function

00:10:36,829 --> 00:10:41,989
let's get a pound room of names so the

00:10:39,230 --> 00:10:43,549
the promise of the function is I am

00:10:41,989 --> 00:10:45,230
going to give you a bunch of names that

00:10:43,549 --> 00:10:49,429
are palindromes right there in a name

00:10:45,230 --> 00:10:52,790
perfect at first we have to get the some

00:10:49,429 --> 00:10:56,029
users to get the names so we get a list

00:10:52,790 --> 00:10:58,699
of users as a promise to the reader we

00:10:56,029 --> 00:11:01,399
then just take all the names from that

00:10:58,699 --> 00:11:03,740
list and this kind of hints the user

00:11:01,399 --> 00:11:04,250
that here's the thing we here's thing

00:11:03,740 --> 00:11:07,150
you should care

00:11:04,250 --> 00:11:09,470
right now which is just a list of names

00:11:07,150 --> 00:11:12,620
then in the the middle we do some work

00:11:09,470 --> 00:11:14,390
for name and names is this a palindrome

00:11:12,620 --> 00:11:16,910
all right so this is the information

00:11:14,390 --> 00:11:19,040
we've added we're checking to see which

00:11:16,910 --> 00:11:20,900
names are palindromes and at the bottom

00:11:19,040 --> 00:11:24,140
is a little bit of output and again

00:11:20,900 --> 00:11:28,790
functions are just not a lot of code so

00:11:24,140 --> 00:11:31,070
the input transform output is not very

00:11:28,790 --> 00:11:37,100
exciting but it does go generally

00:11:31,070 --> 00:11:39,680
speaking top to bottom this is an

00:11:37,100 --> 00:11:42,050
example of asserts adding information so

00:11:39,680 --> 00:11:44,960
if you have a function called get host

00:11:42,050 --> 00:11:46,970
configs the fact that it is the function

00:11:44,960 --> 00:11:49,580
name has a plural in it implies that

00:11:46,970 --> 00:11:51,820
it's returning a list so the the get

00:11:49,580 --> 00:11:58,190
host configs function is going to return

00:11:51,820 --> 00:12:00,770
0 or more configs this is you adding

00:11:58,190 --> 00:12:03,080
information to help the reader you

00:12:00,770 --> 00:12:06,260
happen to know that there is one and

00:12:03,080 --> 00:12:08,210
only one name that should be returned

00:12:06,260 --> 00:12:10,190
it's always it's never gonna return 0

00:12:08,210 --> 00:12:11,870
because at this point you are assuming

00:12:10,190 --> 00:12:14,060
you have a valid config if you don't you

00:12:11,870 --> 00:12:16,100
want to fail and you are telling the

00:12:14,060 --> 00:12:17,570
reader that if two configures are

00:12:16,100 --> 00:12:21,580
returned then something has gone

00:12:17,570 --> 00:12:24,980
seriously awry and you should also fail

00:12:21,580 --> 00:12:28,850
so you can say a certain length of

00:12:24,980 --> 00:12:30,350
results equals one great this says very

00:12:28,850 --> 00:12:32,510
low overhead and it tells the reader a

00:12:30,350 --> 00:12:34,930
little little bit extra about what's

00:12:32,510 --> 00:12:34,930
about to happen

00:12:36,130 --> 00:12:43,580
returning early adds confidence so dry

00:12:41,480 --> 00:12:45,290
run just means don't do the thing I'm

00:12:43,580 --> 00:12:47,390
asking you to do but tell me what you

00:12:45,290 --> 00:12:51,050
would have done so this is a very common

00:12:47,390 --> 00:12:53,690
pattern past the dry run flag great so

00:12:51,050 --> 00:12:57,860
let's get all the users and if this is a

00:12:53,690 --> 00:13:02,840
dry run then let them know how many

00:12:57,860 --> 00:13:04,780
things we would have done and seen this

00:13:02,840 --> 00:13:08,030
is good code this is very readable code

00:13:04,780 --> 00:13:12,550
this is code that you will see in a code

00:13:08,030 --> 00:13:18,080
review it's probably does the same thing

00:13:12,550 --> 00:13:20,870
but if dry run blog the info else

00:13:18,080 --> 00:13:23,270
and then it keeps going so the reader

00:13:20,870 --> 00:13:24,110
has to wonder is something else going to

00:13:23,270 --> 00:13:26,930
happen

00:13:24,110 --> 00:13:28,550
I'm the reader now has to scroll down

00:13:26,930 --> 00:13:30,800
the page and check to see if you

00:13:28,550 --> 00:13:31,460
actually did delete the users which

00:13:30,800 --> 00:13:34,430
would be bad

00:13:31,460 --> 00:13:36,110
so just return early when you can if

00:13:34,430 --> 00:13:37,940
you've done all the work in the function

00:13:36,110 --> 00:13:44,330
you intend to do get out

00:13:37,940 --> 00:13:46,340
great the gun on the mantle so in the

00:13:44,330 --> 00:13:47,990
theater the expression is the gun on the

00:13:46,340 --> 00:13:51,020
mantle and act one goes off and scene

00:13:47,990 --> 00:13:52,670
three because the the idea during a play

00:13:51,020 --> 00:13:54,890
as you build up suspense everybody in

00:13:52,670 --> 00:13:56,000
the audience knows that there's a gun on

00:13:54,890 --> 00:13:57,830
the mantle and expect something to

00:13:56,000 --> 00:14:00,650
happen to it and enjoys the journey as

00:13:57,830 --> 00:14:02,450
you go through and build suspense that

00:14:00,650 --> 00:14:05,930
is absolutely not what you want when

00:14:02,450 --> 00:14:09,590
when you're writing code the gun on the

00:14:05,930 --> 00:14:11,540
mantle goes back so if you tell someone

00:14:09,590 --> 00:14:12,890
about something too early they they have

00:14:11,540 --> 00:14:14,000
to wonder when you're gonna use it and

00:14:12,890 --> 00:14:15,800
they have to keep it in their mental

00:14:14,000 --> 00:14:18,500
stack that there's this there's a gun on

00:14:15,800 --> 00:14:20,360
the mantle so you know just introduce

00:14:18,500 --> 00:14:22,790
the gun make it go bang pick up the next

00:14:20,360 --> 00:14:28,010
cut make it go bang everybody's happier

00:14:22,790 --> 00:14:32,240
and this is kind of our inheritance from

00:14:28,010 --> 00:14:34,400
see like K&R style see old-school see

00:14:32,240 --> 00:14:36,230
you had to declare everything that you

00:14:34,400 --> 00:14:38,690
were going to any variable you might use

00:14:36,230 --> 00:14:39,410
at the top of the function that's just

00:14:38,690 --> 00:14:41,630
how it worked

00:14:39,410 --> 00:14:44,480
so you still see that kind of bleed

00:14:41,630 --> 00:14:45,920
through sometimes in Python where they

00:14:44,480 --> 00:14:47,870
tell you up front here are four

00:14:45,920 --> 00:14:50,930
variables I might use during this

00:14:47,870 --> 00:14:52,250
function and then they use one and then

00:14:50,930 --> 00:14:53,720
they can do some stuff and then they use

00:14:52,250 --> 00:14:55,970
another one and then they do some stuff

00:14:53,720 --> 00:14:59,630
but but this is Python you absolutely

00:14:55,970 --> 00:15:01,220
don't need to do that so just right

00:14:59,630 --> 00:15:04,370
before you are about to use something

00:15:01,220 --> 00:15:06,290
declare it so this helps the reader

00:15:04,370 --> 00:15:08,690
because they see you define a thing and

00:15:06,290 --> 00:15:10,250
then use a thing and then you take the

00:15:08,690 --> 00:15:13,100
output that was that thing and then you

00:15:10,250 --> 00:15:17,180
use it again and everyone's happy

00:15:13,100 --> 00:15:18,830
so this helping the reader by

00:15:17,180 --> 00:15:22,010
introducing fewer concepts at a time

00:15:18,830 --> 00:15:25,720
great make the job easy for a reader and

00:15:22,010 --> 00:15:25,720
get your ship it's everyone's happy

00:15:28,600 --> 00:15:37,400
again a little bit of inheritance from C

00:15:31,960 --> 00:15:42,410
it is okay to put constants in default

00:15:37,400 --> 00:15:43,040
function signatures so call API retry is

00:15:42,410 --> 00:15:46,490
equal three

00:15:43,040 --> 00:15:48,500
it is great it's very easy to read it

00:15:46,490 --> 00:15:52,370
tells you exactly what's about to happen

00:15:48,500 --> 00:15:58,640
we like that call a API retries equals

00:15:52,370 --> 00:16:00,350
max retries okay so you know they said

00:15:58,640 --> 00:16:05,240
this a little bit more colorfully on

00:16:00,350 --> 00:16:07,430
Twitter logo look it up times a it's

00:16:05,240 --> 00:16:08,960
it's rarely necessary

00:16:07,430 --> 00:16:11,240
and you might say max three tries is

00:16:08,960 --> 00:16:13,100
shared okay you can wait until it's

00:16:11,240 --> 00:16:14,510
shared before you declare it at the top

00:16:13,100 --> 00:16:19,850
of the file but that's a good thing to

00:16:14,510 --> 00:16:22,370
do but in C there was no way to express

00:16:19,850 --> 00:16:24,140
this concept so you had to put it where

00:16:22,370 --> 00:16:26,270
do you put your function defaults in C

00:16:24,140 --> 00:16:28,130
you don't where do you put your

00:16:26,270 --> 00:16:29,270
constants and see in the include file

00:16:28,130 --> 00:16:32,150
because that's the only place they could

00:16:29,270 --> 00:16:34,900
be in Python you have options so you

00:16:32,150 --> 00:16:34,900
know let's use them

00:16:41,470 --> 00:16:47,780
exceptions if you've seen some of my

00:16:46,160 --> 00:16:51,470
other talks I say exceptions are

00:16:47,780 --> 00:16:54,860
overused exceptions can are usually also

00:16:51,470 --> 00:16:56,870
far away which doesn't help so if

00:16:54,860 --> 00:16:59,000
there's an exception at the top of the

00:16:56,870 --> 00:17:00,560
module later on when you you go and

00:16:59,000 --> 00:17:02,480
raise it someone has to go back the

00:17:00,560 --> 00:17:03,350
reader has to go back check what the

00:17:02,480 --> 00:17:05,110
definition is

00:17:03,350 --> 00:17:09,230
see if it's inherits from anything and

00:17:05,110 --> 00:17:12,650
in Python you can usually get away with

00:17:09,230 --> 00:17:14,630
just reusing an existing hire and this

00:17:12,650 --> 00:17:17,540
has the added benefit that you don't

00:17:14,630 --> 00:17:19,550
have to go look up anything people

00:17:17,540 --> 00:17:24,740
already know the semantics of built-in

00:17:19,550 --> 00:17:30,940
exceptions and everything works great so

00:17:24,740 --> 00:17:34,280
names names are easy and hard both

00:17:30,940 --> 00:17:35,750
functions are small so there aren't

00:17:34,280 --> 00:17:39,080
going to be a lot of names in your

00:17:35,750 --> 00:17:41,600
function so you can make names simpler

00:17:39,080 --> 00:17:43,820
you don't have to add a lot of context

00:17:41,600 --> 00:17:46,490
to the names because the the reader of a

00:17:43,820 --> 00:17:47,870
function you know if they're five lines

00:17:46,490 --> 00:17:52,610
into a 10 line function and they have

00:17:47,870 --> 00:17:54,800
all the context they need good naming is

00:17:52,610 --> 00:17:57,250
still helpful good names are better than

00:17:54,800 --> 00:17:57,250
bad names

00:17:58,450 --> 00:18:02,990
there's a bunch of little words you can

00:18:01,250 --> 00:18:04,970
use to tell the reader that they

00:18:02,990 --> 00:18:07,160
shouldn't care about something so that

00:18:04,970 --> 00:18:09,170
the name raw is great

00:18:07,160 --> 00:18:13,160
the name bites is also great except in

00:18:09,170 --> 00:18:14,390
Python where it's a built-in so I tend

00:18:13,160 --> 00:18:16,600
to any anywhere where you might want to

00:18:14,390 --> 00:18:19,490
use bites I tend to use the word raw

00:18:16,600 --> 00:18:22,790
what does raw tell the reader raw tells

00:18:19,490 --> 00:18:24,730
the reader this is some data format it

00:18:22,790 --> 00:18:26,600
doesn't tell them what format and that

00:18:24,730 --> 00:18:28,700
tells them that they shouldn't care what

00:18:26,600 --> 00:18:30,500
the format is you're gonna be passing

00:18:28,700 --> 00:18:32,300
around whatever this Brawl thing is and

00:18:30,500 --> 00:18:34,250
then do something useful with it later

00:18:32,300 --> 00:18:34,820
it's a function so you're gonna do

00:18:34,250 --> 00:18:38,300
something with it

00:18:34,820 --> 00:18:39,850
very soon later so user equals

00:18:38,300 --> 00:18:42,350
deserialize user

00:18:39,850 --> 00:18:44,780
no one's guessing at what this is doing

00:18:42,350 --> 00:18:46,040
so it takes that raw blob that you got

00:18:44,780 --> 00:18:48,320
from somewhere and it gives you

00:18:46,040 --> 00:18:50,920
something that you use probably an

00:18:48,320 --> 00:18:50,920
instance of a class

00:18:51,560 --> 00:18:57,260
if you can you don't even have to use

00:18:55,190 --> 00:18:59,480
the temporary so again this is a

00:18:57,260 --> 00:19:02,210
function it's not a lot of there is a

00:18:59,480 --> 00:19:05,150
lot of context and a small amount it's

00:19:02,210 --> 00:19:07,850
good context so if you don't if you can

00:19:05,150 --> 00:19:10,010
get away without using a temporary then

00:19:07,850 --> 00:19:11,540
you know don't use a temporary it's it's

00:19:10,010 --> 00:19:14,030
one less thing that the reader has to

00:19:11,540 --> 00:19:17,030
think about they don't have to wonder if

00:19:14,030 --> 00:19:18,380
you're going to reuse raw later I mean

00:19:17,030 --> 00:19:21,620
they shouldn't you told them it was raw

00:19:18,380 --> 00:19:24,320
and then you used it but if you can if

00:19:21,620 --> 00:19:26,300
it doesn't get too complicated then

00:19:24,320 --> 00:19:29,180
immediately use the return value of the

00:19:26,300 --> 00:19:30,530
thing there's no variable in scope

00:19:29,180 --> 00:19:33,290
nobody has to wonder if you're gonna use

00:19:30,530 --> 00:19:38,930
it again so if you can skip the

00:19:33,290 --> 00:19:41,570
temporary if the reader really really

00:19:38,930 --> 00:19:45,560
shouldn't care there are a bunch of

00:19:41,570 --> 00:19:47,750
well-known idioms and Python for pretend

00:19:45,560 --> 00:19:50,810
this didn't exist you don't have to go

00:19:47,750 --> 00:19:54,380
around and and del individual variables

00:19:50,810 --> 00:19:56,180
that's overkill but if if the variable

00:19:54,380 --> 00:19:58,750
doesn't matter underscore very popular

00:19:56,180 --> 00:20:01,190
even people who haven't seen it before

00:19:58,750 --> 00:20:05,810
probably get what it is dummy

00:20:01,190 --> 00:20:09,070
perfect ignored is very popular in

00:20:05,810 --> 00:20:11,390
function signatures and says when you're

00:20:09,070 --> 00:20:13,220
working with someone else's code or

00:20:11,390 --> 00:20:15,980
updating an existing thing and you don't

00:20:13,220 --> 00:20:18,470
want to change all the colors if if some

00:20:15,980 --> 00:20:20,210
flag is no longer meaningful you know

00:20:18,470 --> 00:20:24,320
set the name to ignore it

00:20:20,210 --> 00:20:26,630
if the it promises the reader that this

00:20:24,320 --> 00:20:28,700
will not be used the reader should be

00:20:26,630 --> 00:20:32,180
surprised and angry if five lines down

00:20:28,700 --> 00:20:34,790
somebody checks the ignored flag and and

00:20:32,180 --> 00:20:41,260
you won't get your ship it's so ignored

00:20:34,790 --> 00:20:44,360
is is a great variable name ordinality

00:20:41,260 --> 00:20:46,340
so how many things are there you can use

00:20:44,360 --> 00:20:48,290
variable names to tell the readers

00:20:46,340 --> 00:20:50,870
something useful about the return value

00:20:48,290 --> 00:20:52,280
from a function get from API get four

00:20:50,870 --> 00:20:54,680
maybe I could we could be returning

00:20:52,280 --> 00:20:56,060
anything but if you can immediately tell

00:20:54,680 --> 00:21:00,470
the reader something about what was

00:20:56,060 --> 00:21:02,660
returned do pair equals items that's a

00:21:00,470 --> 00:21:04,410
promise to the reader that there's a

00:21:02,660 --> 00:21:07,290
pair of things that was returned

00:21:04,410 --> 00:21:10,770
that's a pretty good name left and right

00:21:07,290 --> 00:21:13,110
so this is even better because this will

00:21:10,770 --> 00:21:15,600
blow up if there's not two things so the

00:21:13,110 --> 00:21:17,190
reader now you've told the reader that

00:21:15,600 --> 00:21:18,330
there's two things and it doesn't even

00:21:17,190 --> 00:21:21,600
matter if they don't believe you because

00:21:18,330 --> 00:21:25,140
they believe the computer and left in

00:21:21,600 --> 00:21:27,390
left and right is a good generic thing

00:21:25,140 --> 00:21:30,300
so maybe the the left one and the right

00:21:27,390 --> 00:21:33,210
one don't actually have I mean it's just

00:21:30,300 --> 00:21:35,370
two things if you actually know

00:21:33,210 --> 00:21:37,710
something more about them those two

00:21:35,370 --> 00:21:39,210
things and then you you can tell the

00:21:37,710 --> 00:21:41,520
reader that two with naming a little bit

00:21:39,210 --> 00:21:44,220
if there's an old thing in a new thing

00:21:41,520 --> 00:21:46,770
old and new great names same thing

00:21:44,220 --> 00:21:48,540
primary secondary so if you have a pair

00:21:46,770 --> 00:21:50,130
of things and there's meaning you know

00:21:48,540 --> 00:21:56,250
name the variable with a little bit of

00:21:50,130 --> 00:21:58,500
meaning everybody's happier I did

00:21:56,250 --> 00:22:04,080
another talk name things once who what

00:21:58,500 --> 00:22:06,300
when where why this is who what when

00:22:04,080 --> 00:22:11,010
we're wearing the five W's are good when

00:22:06,300 --> 00:22:15,120
you're doing journalism not so much for

00:22:11,010 --> 00:22:17,400
free code who you don't really care who

00:22:15,120 --> 00:22:21,420
the person who did it

00:22:17,400 --> 00:22:25,650
when q2 is a terrible name to add to a

00:22:21,420 --> 00:22:27,620
function where where is usually some

00:22:25,650 --> 00:22:30,180
reference unnecessary reference to

00:22:27,620 --> 00:22:32,310
another module slipped into the name so

00:22:30,180 --> 00:22:33,900
what is four what is four functions what

00:22:32,310 --> 00:22:42,230
is this thing doing what promise am i

00:22:33,900 --> 00:22:46,340
making especially for newer coders names

00:22:42,230 --> 00:22:48,780
accumulate that kind of metadata so

00:22:46,340 --> 00:22:50,490
again in a function you're not going to

00:22:48,780 --> 00:22:52,440
have very many variables so you can

00:22:50,490 --> 00:22:54,180
afford to have short names because

00:22:52,440 --> 00:22:58,080
there's only three things and one of

00:22:54,180 --> 00:23:01,920
them is in config you will see things

00:22:58,080 --> 00:23:03,870
like config config from JSON and the

00:23:01,920 --> 00:23:05,700
name is almost a transposition the name

00:23:03,870 --> 00:23:07,470
on the left-hand side is almost a

00:23:05,700 --> 00:23:11,540
transposition from what's happening on

00:23:07,470 --> 00:23:15,300
the right hand side and you will see

00:23:11,540 --> 00:23:16,920
variables tend to get added to so the

00:23:15,300 --> 00:23:17,970
first one had two underscores the the

00:23:16,920 --> 00:23:20,400
second line has 300

00:23:17,970 --> 00:23:23,880
scores and I've seen this go on for six

00:23:20,400 --> 00:23:25,560
or seven underscores but again this is a

00:23:23,880 --> 00:23:28,440
function there's not much happening

00:23:25,560 --> 00:23:30,870
there's only a couple things in play in

00:23:28,440 --> 00:23:33,540
this function so you can afford to have

00:23:30,870 --> 00:23:36,690
very short concise variable names

00:23:33,540 --> 00:23:40,680
there's a config so let's name it config

00:23:36,690 --> 00:23:45,020
there's a name that's type there's a

00:23:40,680 --> 00:23:45,020
user so name is a terrible name for that

00:23:45,260 --> 00:23:52,320
return consistently so none of the

00:23:50,730 --> 00:23:55,130
examples I've given in a stalker will

00:23:52,320 --> 00:23:58,080
given this talk or the the code is wrong

00:23:55,130 --> 00:24:01,680
so it's not an example this code is

00:23:58,080 --> 00:24:03,720
wrong and bad it's you know here is a

00:24:01,680 --> 00:24:05,580
thing that gives you bytes and here's a

00:24:03,720 --> 00:24:06,990
thing that gives you the same bytes but

00:24:05,580 --> 00:24:09,720
it's a little bit easier to read so

00:24:06,990 --> 00:24:12,000
these three functions all give you the

00:24:09,720 --> 00:24:14,640
same bytes they all have exactly the

00:24:12,000 --> 00:24:17,660
same semantics in Python I mean they're

00:24:14,640 --> 00:24:21,090
super short so they're all easy to read

00:24:17,660 --> 00:24:22,920
they all set X equal to 3 which is kind

00:24:21,090 --> 00:24:28,140
of a know up here but they all end up

00:24:22,920 --> 00:24:30,600
returning none when they're called if

00:24:28,140 --> 00:24:32,340
you return explicitly you're making a

00:24:30,600 --> 00:24:34,980
different promise to the reader however

00:24:32,340 --> 00:24:37,920
so this is an example of something I'd

00:24:34,980 --> 00:24:40,920
send back for edit compared to lists so

00:24:37,920 --> 00:24:44,850
if these lists are the same when they're

00:24:40,920 --> 00:24:47,130
sorted returned true great and this

00:24:44,850 --> 00:24:50,760
false off the end and returns something

00:24:47,130 --> 00:24:53,760
false II so in almost every place you

00:24:50,760 --> 00:24:54,960
would call this code it's not going to

00:24:53,760 --> 00:24:58,020
blow up it's not going to do the wrong

00:24:54,960 --> 00:25:01,800
thing but when you're reading this as a

00:24:58,020 --> 00:25:03,990
code reviewer you have to wonder if they

00:25:01,800 --> 00:25:07,380
did that intentionally or not so if

00:25:03,990 --> 00:25:09,900
you're writing code make it plain that

00:25:07,380 --> 00:25:12,480
you've thought about this and tell the

00:25:09,900 --> 00:25:14,670
reviewer that yes I know exactly what

00:25:12,480 --> 00:25:17,250
I'm doing either returns true or returns

00:25:14,670 --> 00:25:21,390
false much easier to read no one has to

00:25:17,250 --> 00:25:24,900
doubt if you were half asleep and same

00:25:21,390 --> 00:25:27,600
thing with returning the same types this

00:25:24,900 --> 00:25:29,980
makes it easier for the reader to think

00:25:27,600 --> 00:25:32,750
about what you meant to do

00:25:29,980 --> 00:25:34,880
so a lot of times when you would call

00:25:32,750 --> 00:25:37,070
calc Union none might be okay

00:25:34,880 --> 00:25:41,180
they're either looking for something

00:25:37,070 --> 00:25:43,310
false or a set but we have another good

00:25:41,180 --> 00:25:46,210
thing for something false e which is an

00:25:43,310 --> 00:25:50,000
empty list so now we're returning a list

00:25:46,210 --> 00:25:52,640
so the promise of the function and the

00:25:50,000 --> 00:25:54,140
promise to the reader is we have a we

00:25:52,640 --> 00:26:01,220
have a function that returns a list

00:25:54,140 --> 00:26:04,730
great far less confusing we return the

00:26:01,220 --> 00:26:07,390
same types none so there's a couple ways

00:26:04,730 --> 00:26:10,040
you can you keep handle failure

00:26:07,390 --> 00:26:11,620
returning none is popular so either I

00:26:10,040 --> 00:26:15,290
found the thing you were looking for or

00:26:11,620 --> 00:26:16,580
here's nothing but this also tells the

00:26:15,290 --> 00:26:21,230
reader that you you clearly thought

00:26:16,580 --> 00:26:23,390
about the missing case or you can raise

00:26:21,230 --> 00:26:25,010
an error so a lot of functions will

00:26:23,390 --> 00:26:28,510
either return exactly the thing you were

00:26:25,010 --> 00:26:31,670
looking for or raise an exception and

00:26:28,510 --> 00:26:33,680
code should be somewhat consistent if

00:26:31,670 --> 00:26:34,820
you go with the exception style go with

00:26:33,680 --> 00:26:37,160
the exception style if you go with the

00:26:34,820 --> 00:26:38,150
none style go with a none style but this

00:26:37,160 --> 00:26:39,830
tells the reader that you've thought

00:26:38,150 --> 00:26:46,240
about your failure conditions and

00:26:39,830 --> 00:26:48,560
handled them keeping it together so

00:26:46,240 --> 00:26:51,860
functions are short and easy to write

00:26:48,560 --> 00:26:56,030
and short functions are easy to test if

00:26:51,860 --> 00:26:58,490
you you want things to be easy to think

00:26:56,030 --> 00:27:01,820
about so this this is perfectly fine

00:26:58,490 --> 00:27:04,100
code there's three functions though the

00:27:01,820 --> 00:27:06,950
one the meat of the the thing is

00:27:04,100 --> 00:27:10,160
actually the validate so we want to make

00:27:06,950 --> 00:27:12,770
sure that a config exists and it has

00:27:10,160 --> 00:27:17,270
owners great here's three functions they

00:27:12,770 --> 00:27:19,850
just do a couple little things this is

00:27:17,270 --> 00:27:22,670
the same code at the end of the day it

00:27:19,850 --> 00:27:25,580
generates the same bytes what this tells

00:27:22,670 --> 00:27:27,410
the user the reader to in addition is

00:27:25,580 --> 00:27:33,530
that these things will always happen in

00:27:27,410 --> 00:27:37,070
this order so this config exists and has

00:27:33,530 --> 00:27:40,730
owners this interface this has a bigger

00:27:37,070 --> 00:27:42,290
surface area so it kind of hints to the

00:27:40,730 --> 00:27:43,370
reader that you can call these things at

00:27:42,290 --> 00:27:45,200
any time

00:27:43,370 --> 00:27:48,680
and then that means you have to test for

00:27:45,200 --> 00:27:50,420
more things this tells the reader that

00:27:48,680 --> 00:27:52,490
these things will only ever happen in

00:27:50,420 --> 00:27:56,690
this order so you don't have to think

00:27:52,490 --> 00:27:58,340
about any side conditions where half of

00:27:56,690 --> 00:28:01,790
these things are true it will always

00:27:58,340 --> 00:28:04,310
happen 1 2 3 so this makes it a little

00:28:01,790 --> 00:28:07,100
bit easier to read might not make it

00:28:04,310 --> 00:28:11,480
easier to unit test I think I think it's

00:28:07,100 --> 00:28:14,330
about a wash in the end language

00:28:11,480 --> 00:28:16,220
features so everyone who learns a

00:28:14,330 --> 00:28:18,640
language feature immediately starts

00:28:16,220 --> 00:28:20,330
seeing an application for it everywhere

00:28:18,640 --> 00:28:23,570
this is great

00:28:20,330 --> 00:28:25,520
David Beasley's two rooms over B's gives

00:28:23,570 --> 00:28:27,140
great talks he takes one language

00:28:25,520 --> 00:28:30,440
feature and he tortures its death to

00:28:27,140 --> 00:28:32,000
learn its secrets but the more will the

00:28:30,440 --> 00:28:34,250
story of its talks as always here's how

00:28:32,000 --> 00:28:37,250
you actually want to use the thing but

00:28:34,250 --> 00:28:38,690
in code reviews you will often find you

00:28:37,250 --> 00:28:42,770
will you will see code about the feature

00:28:38,690 --> 00:28:44,630
that someone learned yesterday so it it

00:28:42,770 --> 00:28:46,820
is your professional responsibility to

00:28:44,630 --> 00:28:51,380
learn new things and then to apply them

00:28:46,820 --> 00:28:53,540
judiciously I'm leading with the the

00:28:51,380 --> 00:28:55,150
after effect during first which will

00:28:53,540 --> 00:28:58,930
make more sense once you see the before

00:28:55,150 --> 00:29:01,970
so this is a a simple function that

00:28:58,930 --> 00:29:05,840
takes reads of CSV great there's your

00:29:01,970 --> 00:29:09,380
inputs the transform in the middle is

00:29:05,840 --> 00:29:12,650
it's rolling up rows that have same

00:29:09,380 --> 00:29:16,880
state and zip accumulating population

00:29:12,650 --> 00:29:19,190
and then at the bottom for state zip in

00:29:16,880 --> 00:29:24,350
sorted population there's your output

00:29:19,190 --> 00:29:26,420
you're pretty printer great this is a

00:29:24,350 --> 00:29:30,530
fine function it does exactly what it

00:29:26,420 --> 00:29:32,720
says it's short it's readable this was

00:29:30,530 --> 00:29:35,890
the the first thing I saw in the code

00:29:32,720 --> 00:29:39,230
review for the code that then ended up

00:29:35,890 --> 00:29:41,480
on the previous slide and again that

00:29:39,230 --> 00:29:45,800
there is nothing wrong with this code

00:29:41,480 --> 00:29:49,730
this code is it's idiomatic Python it's

00:29:45,800 --> 00:29:51,770
idiomatic use of classes it does things

00:29:49,730 --> 00:29:53,270
well it defines both equal and less than

00:29:51,770 --> 00:29:55,840
which usually what you want to do if you

00:29:53,270 --> 00:29:55,840
have one or the other

00:29:56,630 --> 00:30:00,350
and there is nothing wrong with this

00:29:58,730 --> 00:30:06,530
code even then it didn't need to be

00:30:00,350 --> 00:30:09,980
written so this was the the first thing

00:30:06,530 --> 00:30:12,080
at the top of the review and this was

00:30:09,980 --> 00:30:16,400
the thing just underneath it so again

00:30:12,080 --> 00:30:19,400
the this is idiomatic Python it uses

00:30:16,400 --> 00:30:23,180
that class which was also idiomatic and

00:30:19,400 --> 00:30:25,700
I mean this code is actually like

00:30:23,180 --> 00:30:28,280
somewhat impressive so it uses the the

00:30:25,700 --> 00:30:29,630
group by function I don't know how many

00:30:28,280 --> 00:30:33,260
of yous the group by functions

00:30:29,630 --> 00:30:35,750
successfully I it's 16 years I'm not

00:30:33,260 --> 00:30:38,300
sure if I have so it has a very weird

00:30:35,750 --> 00:30:39,650
interface that works only in like 1 in

00:30:38,300 --> 00:30:43,490
10 cases where you think you want to

00:30:39,650 --> 00:30:46,430
group by this is one of those cases it

00:30:43,490 --> 00:30:49,340
also uses the reduced function which it

00:30:46,430 --> 00:30:50,930
which is another one of those Python

00:30:49,340 --> 00:30:53,150
things that that looks like it will be

00:30:50,930 --> 00:30:55,550
useful more often than it is as a very

00:30:53,150 --> 00:30:59,180
peculiar interface anyway so this is

00:30:55,550 --> 00:31:02,480
fine code this code it does exactly what

00:30:59,180 --> 00:31:07,730
it means to do there's no errors it's

00:31:02,480 --> 00:31:10,220
great but it's not this so this was a

00:31:07,730 --> 00:31:11,900
case of someone had just learned a bunch

00:31:10,220 --> 00:31:16,490
of language features all at once and use

00:31:11,900 --> 00:31:19,420
them all at once but after we had to sit

00:31:16,490 --> 00:31:22,150
down about it we ended up with this code

00:31:19,420 --> 00:31:25,010
we did some other discarded refactorings

00:31:22,150 --> 00:31:28,070
this one's kind of a clever use of some

00:31:25,010 --> 00:31:30,710
encounter the interface to counter can

00:31:28,070 --> 00:31:32,360
be a little bit wonky sometimes and the

00:31:30,710 --> 00:31:36,410
the person had written the original code

00:31:32,360 --> 00:31:38,200
hadn't hadn't seen it before and there

00:31:36,410 --> 00:31:41,300
were some questions about what some was

00:31:38,200 --> 00:31:43,430
so this might be like a little bit

00:31:41,300 --> 00:31:45,050
shorter but it introduced a couple extra

00:31:43,430 --> 00:31:48,220
confusions for the reader which at this

00:31:45,050 --> 00:31:48,220
point was the guy who wrote the code

00:31:49,600 --> 00:31:55,220
so so we went with a very simple for

00:31:52,130 --> 00:31:57,679
loop and a default dictionary so good I

00:31:55,220 --> 00:31:58,360
got to ship it's on the code everybody's

00:31:57,679 --> 00:32:03,309
happy

00:31:58,360 --> 00:32:06,770
so all effort feels like useful effort

00:32:03,309 --> 00:32:08,299
linters I'm not a huge fan so the

00:32:06,770 --> 00:32:10,809
problem with linters isn't that they

00:32:08,299 --> 00:32:14,030
tell you you have an unused import or

00:32:10,809 --> 00:32:16,370
some extra spaces on the end of the line

00:32:14,030 --> 00:32:23,419
the problem with linters is your

00:32:16,370 --> 00:32:25,429
co-workers who enjoy winters so I think

00:32:23,419 --> 00:32:27,679
it's pie flakes ships with some

00:32:25,429 --> 00:32:29,929
horrendous set of defaults and will

00:32:27,679 --> 00:32:31,610
complain about you know not just 81

00:32:29,929 --> 00:32:34,010
characters but it'll tell you that you

00:32:31,610 --> 00:32:36,530
know warning this line is 13 lines this

00:32:34,010 --> 00:32:38,150
function is 13 lines long and you have

00:32:36,530 --> 00:32:40,700
to go through and make a config file

00:32:38,150 --> 00:32:47,350
that it turns all these knobs on or off

00:32:40,700 --> 00:32:52,460
and then you fight about them and I mean

00:32:47,350 --> 00:32:54,169
yeah so three people can maintain a

00:32:52,460 --> 00:32:59,990
linter if two of them are dead something

00:32:54,169 --> 00:33:01,820
like that so the whole winter thing like

00:32:59,990 --> 00:33:03,590
but it feels like you're agreeing on

00:33:01,820 --> 00:33:05,210
things and it feels like you're you're

00:33:03,590 --> 00:33:07,549
making effort and then in a code review

00:33:05,210 --> 00:33:10,070
someone can immediately jump in and say

00:33:07,549 --> 00:33:11,419
you know the linter is unhappy and then

00:33:10,070 --> 00:33:12,830
and then you make the linter happy and

00:33:11,419 --> 00:33:16,010
then everyone feels like they've done

00:33:12,830 --> 00:33:19,870
something and have half the time you

00:33:16,010 --> 00:33:19,870
haven't it's just been it's been effort

00:33:20,260 --> 00:33:25,940
people can also add their personal

00:33:24,230 --> 00:33:29,200
preferences to to linters and I don't

00:33:25,940 --> 00:33:31,730
mean line length you can actually

00:33:29,200 --> 00:33:36,679
linters crawl the AST so you can add

00:33:31,730 --> 00:33:40,340
linter rules that one particular example

00:33:36,679 --> 00:33:43,130
so function default you can say x equals

00:33:40,340 --> 00:33:44,360
empty list and I think all of us have

00:33:43,130 --> 00:33:47,510
been tripped up on this once or twice

00:33:44,360 --> 00:33:49,370
that that empty list is created once and

00:33:47,510 --> 00:33:51,260
then goes into the function every single

00:33:49,370 --> 00:33:55,250
time so if someone starts mutating that

00:33:51,260 --> 00:33:58,210
list that list persists and that trips

00:33:55,250 --> 00:34:00,910
up people the first time they see it

00:33:58,210 --> 00:34:03,130
there are valid use cases however for

00:34:00,910 --> 00:34:06,700
doing that if the name of the variable

00:34:03,130 --> 00:34:09,340
is cash then you quite intentionally

00:34:06,700 --> 00:34:11,770
introduced a variable list into the the

00:34:09,340 --> 00:34:14,100
method definition but I've seen people

00:34:11,770 --> 00:34:16,330
mark that as an error in the winter and

00:34:14,100 --> 00:34:17,680
again then you have to fight about is

00:34:16,330 --> 00:34:22,980
this a rule it's not a rule

00:34:17,680 --> 00:34:22,980
so linters can be an attractive nuisance

00:34:23,880 --> 00:34:31,240
language features are also an attractive

00:34:26,110 --> 00:34:35,740
nuisance Python type annotations are

00:34:31,240 --> 00:34:38,530
good what they are good at which is the

00:34:35,740 --> 00:34:42,760
type annotations you write should agree

00:34:38,530 --> 00:34:44,140
with the type annotations you write so

00:34:42,760 --> 00:34:46,620
you can spend time making your

00:34:44,140 --> 00:34:53,500
annotations happy with each other I

00:34:46,620 --> 00:34:56,020
don't get it so and I'm on the outside

00:34:53,500 --> 00:34:59,410
on this one but it doesn't solve a

00:34:56,020 --> 00:35:01,870
problem I have I don't pass the wrong

00:34:59,410 --> 00:35:04,030
types into things or if I do I do it

00:35:01,870 --> 00:35:07,840
once very very early on before it

00:35:04,030 --> 00:35:10,030
shipped for me this is just a lot of

00:35:07,840 --> 00:35:12,850
extra effort to read and write things

00:35:10,030 --> 00:35:14,290
and I have friends who like them and

00:35:12,850 --> 00:35:16,240
they're smart people so there must be

00:35:14,290 --> 00:35:20,740
something to it but but personally I

00:35:16,240 --> 00:35:23,400
just don't get it and so like type

00:35:20,740 --> 00:35:26,230
theory is interesting I get that

00:35:23,400 --> 00:35:28,540
thinking about types is is fun I get

00:35:26,230 --> 00:35:33,450
that but going back to all eyford feels

00:35:28,540 --> 00:35:33,450
like useful effort I don't get it

00:35:34,090 --> 00:35:41,530
so during code reviews people will say

00:35:36,700 --> 00:35:44,530
unhelpful things I am NOT going to link

00:35:41,530 --> 00:35:48,400
to any of the things I talk about

00:35:44,530 --> 00:35:50,410
because I don't want them to spread so

00:35:48,400 --> 00:35:53,320
in researching this I went looking for

00:35:50,410 --> 00:35:56,740
people's lists of do's and don'ts people

00:35:53,320 --> 00:35:59,980
have some peculiar lists there was one

00:35:56,740 --> 00:36:02,170
that it was 50 things you should do in

00:35:59,980 --> 00:36:03,910
Python and clearly they started with the

00:36:02,170 --> 00:36:06,420
number of 50 and then work backwards to

00:36:03,910 --> 00:36:06,420
find things

00:36:07,080 --> 00:36:10,860
so you can find anyone who will agree

00:36:09,640 --> 00:36:13,090
with you on the Internet

00:36:10,860 --> 00:36:14,320
short short functions people will be

00:36:13,090 --> 00:36:16,360
very prescriptive about how long a

00:36:14,320 --> 00:36:19,510
function should be and functions should

00:36:16,360 --> 00:36:22,330
go on as long as it has to return once

00:36:19,510 --> 00:36:24,310
this is kind of goes back to like early

00:36:22,330 --> 00:36:27,610
compiler days it was helping the

00:36:24,310 --> 00:36:29,410
compiler to only return once it was

00:36:27,610 --> 00:36:31,600
easier for the compiler to rent reason

00:36:29,410 --> 00:36:33,940
about things because computers were 50

00:36:31,600 --> 00:36:35,650
megahertz but that's no longer true that

00:36:33,940 --> 00:36:40,150
hasn't been true for a long time know if

00:36:35,650 --> 00:36:42,790
statements is a curious one that has

00:36:40,150 --> 00:36:44,680
some popularity and this doesn't mean no

00:36:42,790 --> 00:36:46,330
branching that's a completely separate

00:36:44,680 --> 00:36:51,390
an interest the interesting thing that

00:36:46,330 --> 00:36:53,890
you do in GPUs this means don't type if

00:36:51,390 --> 00:36:56,730
so there's all kinds of convolutions you

00:36:53,890 --> 00:36:59,790
can do to not actually type the word if

00:36:56,730 --> 00:37:01,900
and and they're not pretty

00:36:59,790 --> 00:37:02,440
there your program is still allowed to

00:37:01,900 --> 00:37:04,480
branch

00:37:02,440 --> 00:37:07,950
it doesn't mean no branches it just

00:37:04,480 --> 00:37:07,950
means literally don't type the word if

00:37:09,240 --> 00:37:16,470
so in summary when you look at a

00:37:13,180 --> 00:37:20,170
function think input transform output

00:37:16,470 --> 00:37:23,970
use sensible names and avoid unnecessary

00:37:20,170 --> 00:37:26,020
work I mean don't clever up the place

00:37:23,970 --> 00:37:28,620
all right that's all I got

00:37:26,020 --> 00:37:28,620
any questions

00:37:33,620 --> 00:37:40,370
Thank You jack we please come to the

00:37:36,020 --> 00:37:43,580
microphone if you have a question Thanks

00:37:40,370 --> 00:37:47,030
so it can be tempting to use to have a

00:37:43,580 --> 00:37:50,510
function return a tuple say if you input

00:37:47,030 --> 00:37:52,970
a list of integers return max men

00:37:50,510 --> 00:37:54,410
average whatever what's your take on

00:37:52,970 --> 00:37:56,120
that and generally have to remember the

00:37:54,410 --> 00:38:00,050
order of the return or is it better just

00:37:56,120 --> 00:38:03,410
to return the list so the question was

00:38:00,050 --> 00:38:05,150
if you're returning a tuple should you

00:38:03,410 --> 00:38:07,130
return something that wraps the to pool

00:38:05,150 --> 00:38:09,830
so a function designed to return a list

00:38:07,130 --> 00:38:12,740
but you know your users in this program

00:38:09,830 --> 00:38:14,240
are going to want the max want the min

00:38:12,740 --> 00:38:16,160
wants a standard deviation want the

00:38:14,240 --> 00:38:18,680
average so rather than to write the

00:38:16,160 --> 00:38:20,030
function to return the list you return

00:38:18,680 --> 00:38:21,950
the list and all of these cool

00:38:20,030 --> 00:38:23,600
statistics you know it's kind of sloppy

00:38:21,950 --> 00:38:26,150
but you know your users are going to use

00:38:23,600 --> 00:38:28,310
it then again receiving the output of

00:38:26,150 --> 00:38:32,870
that function gets a little hairy what's

00:38:28,310 --> 00:38:35,180
your general take on that so the

00:38:32,870 --> 00:38:37,550
question was if you returning a list of

00:38:35,180 --> 00:38:38,960
numbers can you also return other things

00:38:37,550 --> 00:38:40,370
there are transformations than the

00:38:38,960 --> 00:38:44,990
number is a list of averages the list of

00:38:40,370 --> 00:38:46,820
men's list of maxes so I'm going to punt

00:38:44,990 --> 00:38:48,860
on that one it's your function should

00:38:46,820 --> 00:38:52,820
return whatever the caller expects it to

00:38:48,860 --> 00:38:54,470
return and if the answer is it wants a

00:38:52,820 --> 00:38:57,410
list of mins and a list of maxes then

00:38:54,470 --> 00:39:00,380
and that's what you return you

00:38:57,410 --> 00:39:02,390
recommended the use of the ignore value

00:39:00,380 --> 00:39:04,820
or name in the parameters how do you

00:39:02,390 --> 00:39:07,400
reconcile that against people's prefer

00:39:04,820 --> 00:39:11,180
practice to name all their values with

00:39:07,400 --> 00:39:12,830
keyword arguments can you repeat that in

00:39:11,180 --> 00:39:14,660
your definition of the function when you

00:39:12,830 --> 00:39:16,610
say function paren blah-blah-blah-blah

00:39:14,660 --> 00:39:17,930
to use the word ignored if you're not

00:39:16,610 --> 00:39:19,520
going to use that value yes

00:39:17,930 --> 00:39:21,290
how do you reconcile that against other

00:39:19,520 --> 00:39:23,360
people's tendency to say when they call

00:39:21,290 --> 00:39:24,740
a function they call all the arguments

00:39:23,360 --> 00:39:27,710
with their keyword names instead of the

00:39:24,740 --> 00:39:30,350
positional names I don't think I said

00:39:27,710 --> 00:39:31,160
anything about calling them with right

00:39:30,350 --> 00:39:34,700
that's why I'm asking

00:39:31,160 --> 00:39:36,860
Oh was then is the question when should

00:39:34,700 --> 00:39:39,020
I pass by position and when should I

00:39:36,860 --> 00:39:40,310
pass by Q no how do you reconcile the

00:39:39,020 --> 00:39:42,050
one against the other if you have a

00:39:40,310 --> 00:39:43,730
function that's supposed to be used as a

00:39:42,050 --> 00:39:45,290
you know it's used many different places

00:39:43,730 --> 00:39:46,850
you don't know what parameter is going

00:39:45,290 --> 00:39:47,450
to be passed into it or you do know what

00:39:46,850 --> 00:39:49,010
they are going to be

00:39:47,450 --> 00:39:50,600
you're not gonna use all of them if you

00:39:49,010 --> 00:39:52,460
don't give the name that was given in

00:39:50,600 --> 00:39:54,710
the parameter definition specification

00:39:52,460 --> 00:39:56,390
and it gets called with a keyword value

00:39:54,710 --> 00:39:57,920
equal that thing now you have a keyword

00:39:56,390 --> 00:40:01,760
mismatch and you get an error how do you

00:39:57,920 --> 00:40:04,490
reconcile that okay so the rephrase the

00:40:01,760 --> 00:40:05,840
question as broadly about what when do

00:40:04,490 --> 00:40:08,750
you do positional when should you do

00:40:05,840 --> 00:40:11,930
keyword what makes things easier to read

00:40:08,750 --> 00:40:13,820
so the the lots of people have opinions

00:40:11,930 --> 00:40:15,950
be the only one I think that is

00:40:13,820 --> 00:40:20,120
universal is if you're passing Flags

00:40:15,950 --> 00:40:22,100
boolean's use the keyword arc because

00:40:20,120 --> 00:40:28,660
it's very hard to read a function call

00:40:22,100 --> 00:40:32,690
that says do stuff true false false true

00:40:28,660 --> 00:40:34,760
yes I just kind of similar question but

00:40:32,690 --> 00:40:37,510
what's kind of your rule of thumb for

00:40:34,760 --> 00:40:40,520
using like star star kwargs

00:40:37,510 --> 00:40:42,680
because it I think it might sacrifice

00:40:40,520 --> 00:40:46,580
some of the readability of the method

00:40:42,680 --> 00:40:48,460
signature so passing star star kwargs

00:40:46,580 --> 00:40:52,340
and defining stuff as star star kwargs

00:40:48,460 --> 00:40:55,130
does hurt readability there are places

00:40:52,340 --> 00:40:59,780
where you do it because you have to if

00:40:55,130 --> 00:41:01,520
anyone's use the AWS boto api it has

00:40:59,780 --> 00:41:02,960
this weird I don't know if it's Java is

00:41:01,520 --> 00:41:07,250
um I don't know where I got it from but

00:41:02,960 --> 00:41:10,190
you you can't pass setting equals none

00:41:07,250 --> 00:41:12,530
you have to not pass that thing at all

00:41:10,190 --> 00:41:15,110
and that's where you end up doing weird

00:41:12,530 --> 00:41:16,430
kwargs stuff and adding to the kwargs

00:41:15,110 --> 00:41:19,820
and then calling it with star star

00:41:16,430 --> 00:41:26,500
kwargs yeah so using kwargs is usually a

00:41:19,820 --> 00:41:26,500
workaround for something else thank you

00:41:27,680 --> 00:41:29,740

YouTube URL: https://www.youtube.com/watch?v=rrBJVMyD-Gs


