Title: David Beazley - Reinventing the Parser Generator  - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: David Beazley

Writing lexers and parsers is a complex problem that often involves the use of special tools and domain specific languages (e.g., the lex/yacc tools on Unix).  In 2001, I wrote Python versions of these tools which can be found in the PLY project.  PLY predates a huge number of modern Python features including the iteration protocol, generators, decorators, metaclasses, and more.  As such, it relied on a variety of clever hacks to layer a domain specific parser specification language on top of Python itself. 

In this talk, I discuss a modernization of the PLY project that abandons its past and freely abuses modern Python features including advanced metaclasses, guaranteed dictionary ordering, class decorators, type hints, and more.   The result of this work can be found in the SLY project.  However, this talk isn't so much about SLY as it is focused on how far you can push Python metaprogramming features to create domain-specific languages.   Prepare to be horrified--and to write code that will break your IDE. 
 

Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:03,799 --> 00:00:08,010
for the thousands in attendance and the

00:00:06,779 --> 00:00:11,880
millions watching around the world

00:00:08,010 --> 00:00:23,910
ladies and gentlemen let's get ready to

00:00:11,880 --> 00:00:25,769
pipe the he needs no introduction he's

00:00:23,910 --> 00:00:29,429
the people's champion from Chicago

00:00:25,769 --> 00:00:42,989
Illinois presenting reinventing the

00:00:29,429 --> 00:00:44,910
parser generator David thank thank you

00:00:42,989 --> 00:00:49,530
very much where were you and I went up

00:00:44,910 --> 00:00:50,430
for tenure by the way all right all

00:00:49,530 --> 00:00:52,500
right so we're gonna we're gonna talk

00:00:50,430 --> 00:00:54,600
about parser generators in here I also

00:00:52,500 --> 00:00:56,789
have to apologize kind of get head of

00:00:54,600 --> 00:00:58,789
cold so if my voice kind of drops out

00:00:56,789 --> 00:01:01,379
and deal with that

00:00:58,789 --> 00:01:03,989
yeah parser generators well let's start

00:01:01,379 --> 00:01:05,549
this off I think the one thing I would

00:01:03,989 --> 00:01:07,619
start with is that programming is

00:01:05,549 --> 00:01:12,060
basically magic if you think about it

00:01:07,619 --> 00:01:13,430
and a big part of programming involves

00:01:12,060 --> 00:01:15,869
different levels of abstraction

00:01:13,430 --> 00:01:17,549
basically you take problems and you try

00:01:15,869 --> 00:01:19,259
to you know figure out ways to solve

00:01:17,549 --> 00:01:20,759
problems and did you know involves

00:01:19,259 --> 00:01:23,610
things like naming things and data

00:01:20,759 --> 00:01:25,290
structures and functions and and objects

00:01:23,610 --> 00:01:27,560
but at some point you're just going to

00:01:25,290 --> 00:01:30,170
exhaust all the possibilities of that

00:01:27,560 --> 00:01:32,400
and you're gonna need to go further than

00:01:30,170 --> 00:01:33,869
objects or something right I mean it's

00:01:32,400 --> 00:01:36,900
like we're like where do you go from

00:01:33,869 --> 00:01:39,630
where do you go from there you could

00:01:36,900 --> 00:01:42,689
jump into the land of Python magic

00:01:39,630 --> 00:01:45,570
methods you know Python gives you great

00:01:42,689 --> 00:01:48,060
flexibility and sort of modifying the

00:01:45,570 --> 00:01:52,590
the environment there so you could do

00:01:48,060 --> 00:01:54,060
you can do magic methods I don't know if

00:01:52,590 --> 00:01:56,219
people get angry with all your magic

00:01:54,060 --> 00:01:58,439
methods you can deflect their anger by

00:01:56,219 --> 00:02:00,299
just calling all of those dunder methods

00:01:58,439 --> 00:02:01,530
right so you know like mispronounce it

00:02:00,299 --> 00:02:02,939
then they're gonna be angry about that

00:02:01,530 --> 00:02:06,549
you can

00:02:02,939 --> 00:02:08,590
okay okay you do magic methods but you

00:02:06,549 --> 00:02:10,810
might take it kind of a step further

00:02:08,590 --> 00:02:13,150
than that and get into it I guess what

00:02:10,810 --> 00:02:15,850
describes linguistic abstraction which

00:02:13,150 --> 00:02:17,950
is basically making your own programming

00:02:15,850 --> 00:02:20,050
language your own language related to

00:02:17,950 --> 00:02:21,850
the problem that you're working on and

00:02:20,050 --> 00:02:23,170
there's a lot of history of this I mean

00:02:21,850 --> 00:02:25,630
involving things like mathematical

00:02:23,170 --> 00:02:28,569
notation and programming languages and

00:02:25,630 --> 00:02:30,430
things like sequel and config files and

00:02:28,569 --> 00:02:32,830
hardware description languages and all

00:02:30,430 --> 00:02:34,959
this all this stuff so you know there's

00:02:32,830 --> 00:02:36,760
certain problems where that really you

00:02:34,959 --> 00:02:38,500
know like you try to make a language

00:02:36,760 --> 00:02:39,850
it's kind of match the problem and in

00:02:38,500 --> 00:02:43,870
doing that you're trying to simplify the

00:02:39,850 --> 00:02:46,030
problem the the big problem is how do

00:02:43,870 --> 00:02:48,760
you do that like I mean you know just as

00:02:46,030 --> 00:02:50,319
an example let's let's say I don't know

00:02:48,760 --> 00:02:53,650
you made your own programming language

00:02:50,319 --> 00:02:55,120
and you had a statements like that how

00:02:53,650 --> 00:02:56,769
do you parse that like I mean if I were

00:02:55,120 --> 00:02:58,420
to ask you it could take that code and

00:02:56,769 --> 00:03:00,670
like break it up and parse it and

00:02:58,420 --> 00:03:02,950
understand it that turns out to be a

00:03:00,670 --> 00:03:04,989
pretty non-trivial problem I mean this

00:03:02,950 --> 00:03:07,120
is this is more than just sort of string

00:03:04,989 --> 00:03:08,500
splitting or string partitioning or

00:03:07,120 --> 00:03:10,360
something like that I mean there's

00:03:08,500 --> 00:03:13,410
there's basically the problem of

00:03:10,360 --> 00:03:15,760
breaking that up into tokens so

00:03:13,410 --> 00:03:17,680
recognizing that you know a is an

00:03:15,760 --> 00:03:19,359
identifier and you have numbers and

00:03:17,680 --> 00:03:22,690
symbols and so forth so there's kind of

00:03:19,359 --> 00:03:25,540
a tokenizing process there's also just

00:03:22,690 --> 00:03:26,980
the problem of like recognizing so

00:03:25,540 --> 00:03:29,350
there's a grammar of this thing like

00:03:26,980 --> 00:03:31,750
like what is this code you know what is

00:03:29,350 --> 00:03:33,220
it exactly and so there's there's kind

00:03:31,750 --> 00:03:34,660
of a notion of a grammar for what a

00:03:33,220 --> 00:03:36,400
program is you can say well you know

00:03:34,660 --> 00:03:38,350
program is a bunch of statements and

00:03:36,400 --> 00:03:40,000
well what's statements well statements

00:03:38,350 --> 00:03:42,609
are like one like many statements

00:03:40,000 --> 00:03:44,320
followed by one statement or a single

00:03:42,609 --> 00:03:45,670
statement and then you can ask what are

00:03:44,320 --> 00:03:47,530
the different statements I mean there's

00:03:45,670 --> 00:03:49,900
there's like assignment there's printing

00:03:47,530 --> 00:03:51,370
there's expressions I mean suddenly this

00:03:49,900 --> 00:03:54,790
this turns into a sort of a very

00:03:51,370 --> 00:03:56,620
non-trivial problem and then even if you

00:03:54,790 --> 00:03:58,989
kind of get past that you run into all

00:03:56,620 --> 00:04:01,319
these problems of like look even if you

00:03:58,989 --> 00:04:03,670
could break all this this code apart

00:04:01,319 --> 00:04:06,930
what do you turn it into like what's

00:04:03,670 --> 00:04:09,069
what's the end result of this thing and

00:04:06,930 --> 00:04:11,350
you might end up building things like

00:04:09,069 --> 00:04:13,239
abstract syntax trees or other other

00:04:11,350 --> 00:04:15,280
things but it's it's it's a highly kind

00:04:13,239 --> 00:04:18,760
of non-trivial problem too

00:04:15,280 --> 00:04:20,380
get into that if you ask you know

00:04:18,760 --> 00:04:22,510
co-workers or something you say well how

00:04:20,380 --> 00:04:24,730
do I solve this problem one thing that

00:04:22,510 --> 00:04:27,070
they might direct you to is they would

00:04:24,730 --> 00:04:29,230
say we'll go read the Dragon book this

00:04:27,070 --> 00:04:32,680
is the same it I modified it a little

00:04:29,230 --> 00:04:35,110
bit but you know they said that they

00:04:32,680 --> 00:04:37,810
yeah that you know the infamous Dragon

00:04:35,110 --> 00:04:39,280
book this is something that you that you

00:04:37,810 --> 00:04:41,650
give to students if you want to make

00:04:39,280 --> 00:04:44,680
them cry or something like like if you

00:04:41,650 --> 00:04:46,240
go in that book I mean the whole book

00:04:44,680 --> 00:04:49,090
basically looks something like that I

00:04:46,240 --> 00:04:50,500
mean it's it's like very dense very

00:04:49,090 --> 00:04:52,480
mathematical

00:04:50,500 --> 00:04:56,680
you know you'll walk away from that and

00:04:52,480 --> 00:04:58,690
just you know head spinning and the

00:04:56,680 --> 00:05:00,490
truth of the matter is like basically

00:04:58,690 --> 00:05:03,040
for doing parsing most people turn to

00:05:00,490 --> 00:05:05,710
tools I mean this is you know this is a

00:05:03,040 --> 00:05:07,360
well kind of trodden area of CS people

00:05:05,710 --> 00:05:10,180
have written you know tools to do

00:05:07,360 --> 00:05:11,950
parsing and tokenizing some of the sort

00:05:10,180 --> 00:05:15,580
of more classic tools for this or Lex

00:05:11,950 --> 00:05:18,790
and yak on UNIX yak was developed in

00:05:15,580 --> 00:05:21,790
kind of the early 1970s relax is kind of

00:05:18,790 --> 00:05:24,430
in the same ballpark and really kind of

00:05:21,790 --> 00:05:26,290
the idea there is that they have you

00:05:24,430 --> 00:05:29,530
describe your language and kind of a

00:05:26,290 --> 00:05:31,090
higher level maybe something like this

00:05:29,530 --> 00:05:33,130
where you'd write out your write out

00:05:31,090 --> 00:05:35,560
your grammar and then you run it through

00:05:33,130 --> 00:05:37,539
a code generator and then you get up

00:05:35,560 --> 00:05:38,979
like a you get a bundle of C code or

00:05:37,539 --> 00:05:44,200
something and then you take that and

00:05:38,979 --> 00:05:45,760
compile it into your program now it's

00:05:44,200 --> 00:05:47,830
not you know these are old tool turns

00:05:45,760 --> 00:05:50,590
out that Python works this way as well I

00:05:47,830 --> 00:05:53,020
mean this is maybe a little bit obscure

00:05:50,590 --> 00:05:55,960
but if you go into the like the Python

00:05:53,020 --> 00:05:57,880
source code you'll find that it's parser

00:05:55,960 --> 00:06:00,550
is basically automatically generated

00:05:57,880 --> 00:06:02,080
from a file I don't know their whether

00:06:00,550 --> 00:06:03,430
people have really seen that so I

00:06:02,080 --> 00:06:06,460
thought I would just kind of like show

00:06:03,430 --> 00:06:09,580
you that real quick so this is the the C

00:06:06,460 --> 00:06:10,900
Python distribution here essentially if

00:06:09,580 --> 00:06:12,760
you go into a directory there there's

00:06:10,900 --> 00:06:15,280
like a you know grammar directory you

00:06:12,760 --> 00:06:18,220
can find a file called grammar which is

00:06:15,280 --> 00:06:21,490
like a high-level description of what

00:06:18,220 --> 00:06:23,200
Python syntax is if you if you look at

00:06:21,490 --> 00:06:26,409
it let's just say just take a look at it

00:06:23,200 --> 00:06:27,729
there uh you all you know get this this

00:06:26,409 --> 00:06:29,199
thing saying okay well this is the

00:06:27,729 --> 00:06:30,699
grammar for Python

00:06:29,199 --> 00:06:32,560
it's a little little description you

00:06:30,699 --> 00:06:35,229
know guide for how to change it and

00:06:32,560 --> 00:06:36,939
you'll find this you know kind of

00:06:35,229 --> 00:06:38,849
description of what what the grammar is

00:06:36,939 --> 00:06:41,770
for Python and it goes on for a little

00:06:38,849 --> 00:06:46,150
little while there'll be quiz on reading

00:06:41,770 --> 00:06:48,310
this later on but then what what happens

00:06:46,150 --> 00:06:51,729
with this is this grammar is

00:06:48,310 --> 00:06:54,279
automatically turned into C code to to

00:06:51,729 --> 00:06:58,659
make pythons parser I'm the tool to do

00:06:54,279 --> 00:07:00,639
that it's this thing called P Jan I know

00:06:58,659 --> 00:07:02,169
how many people have done P gen before

00:07:00,639 --> 00:07:04,810
probably nobody yeah it actually

00:07:02,169 --> 00:07:07,060
predates Python itself it's actually one

00:07:04,810 --> 00:07:08,680
of the first files ever written for

00:07:07,060 --> 00:07:10,659
Python you know when it was first

00:07:08,680 --> 00:07:13,599
created so there's been versions of this

00:07:10,659 --> 00:07:15,370
that go all the way back and what you do

00:07:13,599 --> 00:07:18,460
on that is you feed it the grammar and

00:07:15,370 --> 00:07:20,169
then you give it some output files now

00:07:18,460 --> 00:07:23,080
you give it a header file and a C file

00:07:20,169 --> 00:07:25,479
and essentially run that and you get

00:07:23,080 --> 00:07:28,449
some C code and then if you want to

00:07:25,479 --> 00:07:33,339
shatter your head you look at that C

00:07:28,449 --> 00:07:36,580
code no it's it's like if you look at it

00:07:33,339 --> 00:07:38,710
this is what it looks like it's it's not

00:07:36,580 --> 00:07:41,259
meant to make any any sense I mean it's

00:07:38,710 --> 00:07:43,089
it's a lot of a lot of data structures

00:07:41,259 --> 00:07:44,560
and other other things and so some

00:07:43,089 --> 00:07:48,399
through some kind of magic that

00:07:44,560 --> 00:07:50,529
basically creates the the Python the

00:07:48,399 --> 00:07:52,750
Python grammar or the Python parser so

00:07:50,529 --> 00:07:54,819
so this is this is something that's just

00:07:52,750 --> 00:07:56,770
commonly done with these you know if you

00:07:54,819 --> 00:07:58,990
want to make a programming language you

00:07:56,770 --> 00:08:01,029
will often use parser generator tools

00:07:58,990 --> 00:08:03,520
and there's a lot of these tools kind of

00:08:01,029 --> 00:08:06,939
floating around out there be Jen's not

00:08:03,520 --> 00:08:09,339
then not the only one now now having

00:08:06,939 --> 00:08:12,069
haven't shown you that one of the things

00:08:09,339 --> 00:08:15,669
that really inspired me is it's kind of

00:08:12,069 --> 00:08:17,499
early on in my Python career so I went

00:08:15,669 --> 00:08:22,389
to the seventh international Python

00:08:17,499 --> 00:08:24,550
conference this was in 1998 and at the

00:08:22,389 --> 00:08:26,409
conference John a cocky I think it was a

00:08:24,550 --> 00:08:28,270
you might have been a grad student at

00:08:26,409 --> 00:08:29,349
the time he's currently a professor up

00:08:28,270 --> 00:08:31,389
in Canada

00:08:29,349 --> 00:08:34,510
he gave this talk about making little

00:08:31,389 --> 00:08:36,940
languages in Python and it was really

00:08:34,510 --> 00:08:39,729
this this awesome talk because a big

00:08:36,940 --> 00:08:41,319
feature of it is he did this horrible

00:08:39,729 --> 00:08:43,210
abuse of docstrings

00:08:41,319 --> 00:08:45,310
I actually remember

00:08:43,210 --> 00:08:48,250
when he gave the talk everybody kind of

00:08:45,310 --> 00:08:49,930
groaning in like all in like amazement

00:08:48,250 --> 00:08:52,300
and also kind of maybe horror at the

00:08:49,930 --> 00:08:54,010
same time but the but the the idea was

00:08:52,300 --> 00:08:56,980
that he had Python code

00:08:54,010 --> 00:08:58,960
we're just embedded right in the Python

00:08:56,980 --> 00:09:01,390
code in docstrings he had the grammar

00:08:58,960 --> 00:09:03,340
and then his tool just like magically

00:09:01,390 --> 00:09:04,930
made a parser it was like it was really

00:09:03,340 --> 00:09:06,640
neat because you didn't have to it

00:09:04,930 --> 00:09:08,350
wasn't like a code generator you didn't

00:09:06,640 --> 00:09:10,750
have to make separate files it wasn't

00:09:08,350 --> 00:09:14,440
like really complicated to lean or

00:09:10,750 --> 00:09:17,470
anything like that and I ended up sort

00:09:14,440 --> 00:09:19,450
of copying that years later for a

00:09:17,470 --> 00:09:22,480
separate project so I have this project

00:09:19,450 --> 00:09:27,090
called ply it was basically created in

00:09:22,480 --> 00:09:29,800
2001 for teaching a compilers course and

00:09:27,090 --> 00:09:31,990
it was kind of a it was kind of a like a

00:09:29,800 --> 00:09:35,050
mash of sort of yak and this spark

00:09:31,990 --> 00:09:36,610
toolkit for various reasons I didn't

00:09:35,050 --> 00:09:38,770
want to use spark because I was very

00:09:36,610 --> 00:09:41,530
interested in this very specific parsing

00:09:38,770 --> 00:09:43,750
algorithm which is this this lalr 1

00:09:41,530 --> 00:09:45,730
parser that don't worry about what that

00:09:43,750 --> 00:09:48,720
is but it's a you know I wanted to

00:09:45,730 --> 00:09:50,650
implement that that algorithm and so

00:09:48,720 --> 00:09:53,470
coded this tool a lot for teaching

00:09:50,650 --> 00:09:57,100
teaching the class and without getting

00:09:53,470 --> 00:09:58,360
into too much you know tutorial on that

00:09:57,100 --> 00:10:01,120
I thought I would actually do it like

00:09:58,360 --> 00:10:04,690
just an example of what it looks like to

00:10:01,120 --> 00:10:08,140
use a parser generator tool these tools

00:10:04,690 --> 00:10:10,870
are basically kind of insane magic if

00:10:08,140 --> 00:10:12,790
you ever get into this part of sort of

00:10:10,870 --> 00:10:15,040
computing and this is gonna be no

00:10:12,790 --> 00:10:17,350
different but let me do a little example

00:10:15,040 --> 00:10:20,860
of what it looks like to use this ply

00:10:17,350 --> 00:10:23,530
tool because gonna be my applied a my I

00:10:20,860 --> 00:10:25,510
typed in a few things in advance here so

00:10:23,530 --> 00:10:27,610
the thing we're gonna that we're gonna

00:10:25,510 --> 00:10:29,050
try to do is maybe parse that code that

00:10:27,610 --> 00:10:32,070
I had on the slide earlier you know the

00:10:29,050 --> 00:10:34,870
a is 3 times 4 plus 5 and then print a

00:10:32,070 --> 00:10:36,700
and essentially there's two facets of

00:10:34,870 --> 00:10:38,650
this that we have to worry about there's

00:10:36,700 --> 00:10:40,390
there's essentially a set of tokens and

00:10:38,650 --> 00:10:42,130
those are like the individual words that

00:10:40,390 --> 00:10:44,770
were gonna recognize or the individual

00:10:42,130 --> 00:10:46,660
symbols and then I've got this grammar

00:10:44,770 --> 00:10:48,580
at the end which kind of defines the

00:10:46,660 --> 00:10:52,470
valid kind of syntax of what this thing

00:10:48,580 --> 00:10:55,230
is so so to use a parser generator tool

00:10:52,470 --> 00:10:57,160
like they'd like this ply tool

00:10:55,230 --> 00:10:59,769
okay I'm gonna import

00:10:57,160 --> 00:11:01,230
this dysfunction lacks and essentially

00:10:59,769 --> 00:11:03,699
what you have to do is write out a

00:11:01,230 --> 00:11:05,620
specification of what is it that we're

00:11:03,699 --> 00:11:07,720
that we're doing here so one of the

00:11:05,620 --> 00:11:10,629
things that we have to write out is just

00:11:07,720 --> 00:11:13,180
tell it what tokens we're recognizing

00:11:10,629 --> 00:11:15,339
part of what you're doing here is you're

00:11:13,180 --> 00:11:17,769
sort of teaching the parser generator

00:11:15,339 --> 00:11:20,110
like what are the valid just you know

00:11:17,769 --> 00:11:22,720
symbols that are going to appear here so

00:11:20,110 --> 00:11:24,579
so we're sort of writing out kind of a

00:11:22,720 --> 00:11:27,220
list of the symbol they start with that

00:11:24,579 --> 00:11:28,930
and then what you what then what you

00:11:27,220 --> 00:11:31,120
have to do with that is you have to sort

00:11:28,930 --> 00:11:33,430
of teach it what these symbols are and

00:11:31,120 --> 00:11:35,589
and so that is gonna involve essentially

00:11:33,430 --> 00:11:37,209
regular expression you know all good

00:11:35,589 --> 00:11:40,000
problems are solved with regular

00:11:37,209 --> 00:11:41,889
expressions writing so so what what this

00:11:40,000 --> 00:11:44,110
pleye tool would like one of the ways

00:11:41,889 --> 00:11:45,579
that it works is you could write out

00:11:44,110 --> 00:11:47,560
strings and you can just you could

00:11:45,579 --> 00:11:51,370
prefix the string with like a lowercase

00:11:47,560 --> 00:11:53,139
T underscore and it would just

00:11:51,370 --> 00:11:55,689
understand that as being a token

00:11:53,139 --> 00:11:57,310
specification now if you must know how

00:11:55,689 --> 00:11:58,990
this is working by the way there's it

00:11:57,310 --> 00:12:01,630
essentially plies doing a bunch of

00:11:58,990 --> 00:12:03,850
introspection hacks where it's like

00:12:01,630 --> 00:12:06,279
looking at the environment and it's like

00:12:03,850 --> 00:12:07,990
basically defining tokens based on

00:12:06,279 --> 00:12:10,569
whether it seems like a T in front of

00:12:07,990 --> 00:12:12,610
your your variable that's that's an idea

00:12:10,569 --> 00:12:14,860
that was copied off of this spark

00:12:12,610 --> 00:12:17,259
toolkit so kind of a kind of

00:12:14,860 --> 00:12:21,069
appropriated that so you write out your

00:12:17,259 --> 00:12:22,959
token and then if you want to make a

00:12:21,069 --> 00:12:24,790
lexer you just you do this step you just

00:12:22,959 --> 00:12:28,720
leave Lex or equals Lex and then somehow

00:12:24,790 --> 00:12:30,550
through magic that makes a lexer for you

00:12:28,720 --> 00:12:31,269
so let the so so here's how that's gonna

00:12:30,550 --> 00:12:32,410
work okay

00:12:31,269 --> 00:12:34,420
for first of all getting a little

00:12:32,410 --> 00:12:37,600
warning about errors and I'll I'll talk

00:12:34,420 --> 00:12:38,649
about that in a second but essentially

00:12:37,600 --> 00:12:42,209
what you're gonna do with the with the

00:12:38,649 --> 00:12:44,019
lexer you're gonna feed it some input I

00:12:42,209 --> 00:12:46,180
don't know maybe you feed it some

00:12:44,019 --> 00:12:51,100
symbols like that and then you would do

00:12:46,180 --> 00:12:53,740
a for loop on it and what it's gonna do

00:12:51,100 --> 00:12:55,689
is break up the input into a bunch of

00:12:53,740 --> 00:12:57,699
tokens so it come back and say okay well

00:12:55,689 --> 00:13:00,399
there's your tokens you have an ID which

00:12:57,699 --> 00:13:03,100
is a and you have equal sign and num and

00:13:00,399 --> 00:13:04,389
times and um and plus and and so forth

00:13:03,100 --> 00:13:06,250
they say essentially it's trying to

00:13:04,389 --> 00:13:08,680
solve like a horrible sort of reg X

00:13:06,250 --> 00:13:11,080
problem for you in a in a sort of

00:13:08,680 --> 00:13:13,540
simplified way now there are

00:13:11,080 --> 00:13:15,070
there are some problems one thing that

00:13:13,540 --> 00:13:18,670
you should probably not do is ignore

00:13:15,070 --> 00:13:21,040
warning messages I kind of ignored that

00:13:18,670 --> 00:13:23,620
warning you know like not supposed to

00:13:21,040 --> 00:13:27,040
ignore warnings out the problem there is

00:13:23,620 --> 00:13:29,020
that you might run into input that

00:13:27,040 --> 00:13:30,970
doesn't work right like I just changed

00:13:29,020 --> 00:13:34,120
the input there to have some spaces and

00:13:30,970 --> 00:13:35,980
it turns out if I try to do that it

00:13:34,120 --> 00:13:38,530
basically blows up saying a lot what are

00:13:35,980 --> 00:13:40,390
you doing I you know got any legal

00:13:38,530 --> 00:13:43,480
character like a space and then it just

00:13:40,390 --> 00:13:45,310
dies one of the things with tokenizer is

00:13:43,480 --> 00:13:48,880
is that you have to basically teach them

00:13:45,310 --> 00:13:50,350
like the entire world of input and if

00:13:48,880 --> 00:13:52,960
you don't do that they just give up

00:13:50,350 --> 00:13:55,090
so that warning message is essentially

00:13:52,960 --> 00:13:58,000
telling me that I needed to add like an

00:13:55,090 --> 00:14:01,150
error function in here what you're doing

00:13:58,000 --> 00:14:02,920
an error function is you I know you

00:14:01,150 --> 00:14:04,450
maybe do some kind of recovery saying

00:14:02,920 --> 00:14:07,000
okay there was there was like an illegal

00:14:04,450 --> 00:14:10,090
character in there and then you get the

00:14:07,000 --> 00:14:13,150
option of what to do maybe you do like a

00:14:10,090 --> 00:14:17,320
skip ahead okay so I'm gonna do some

00:14:13,150 --> 00:14:21,790
some recovery to kind of skip will well

00:14:17,320 --> 00:14:23,290
we'll try it again here okay now you're

00:14:21,790 --> 00:14:24,640
getting now that now the thing is sort

00:14:23,290 --> 00:14:26,800
of stayin alive and I'm getting a lot of

00:14:24,640 --> 00:14:30,280
error messages sort of saying yeah I get

00:14:26,800 --> 00:14:32,170
a lot of whitespace ignoring that these

00:14:30,280 --> 00:14:34,840
tools often provide techniques for that

00:14:32,170 --> 00:14:36,550
as well turns out that this ply tool you

00:14:34,840 --> 00:14:39,820
can give it like a set of ignored

00:14:36,550 --> 00:14:44,160
characters for instance and then it will

00:14:39,820 --> 00:14:48,520
just discard any of those from the input

00:14:44,160 --> 00:14:50,650
okay let's let's let's try that okay so

00:14:48,520 --> 00:14:52,960
you're getting rid of illegal characters

00:14:50,650 --> 00:14:55,800
uh turns out that there's still other

00:14:52,960 --> 00:14:58,390
kinds of weird problems with this

00:14:55,800 --> 00:15:00,340
writing writing like lectures and

00:14:58,390 --> 00:15:02,170
parsers it's kind of a non-trivial thing

00:15:00,340 --> 00:15:05,890
because there's a lot of weird corner

00:15:02,170 --> 00:15:08,560
cases one of the corner cases here is

00:15:05,890 --> 00:15:11,080
that it turns out that parsing that like

00:15:08,560 --> 00:15:13,180
tokenizing that print statement doesn't

00:15:11,080 --> 00:15:19,660
actually work quite right if you try

00:15:13,180 --> 00:15:22,390
that let's check it out here you're

00:15:19,660 --> 00:15:25,420
gonna you're gonna find

00:15:22,390 --> 00:15:27,100
it does not recognize the print keyword

00:15:25,420 --> 00:15:29,260
I mean most languages they have like a

00:15:27,100 --> 00:15:31,680
keyword for print or something and what

00:15:29,260 --> 00:15:34,720
has happened here is that this thing has

00:15:31,680 --> 00:15:38,710
misidentified that print it's a little

00:15:34,720 --> 00:15:42,070
bit subtle but but in the in the rules

00:15:38,710 --> 00:15:44,350
up here I basically have a rule for for

00:15:42,070 --> 00:15:46,450
like an identifier and then I have a

00:15:44,350 --> 00:15:48,310
rule for print and the problem is that

00:15:46,450 --> 00:15:52,300
print and that other rule are kind of in

00:15:48,310 --> 00:15:54,160
conflict with each other like they like

00:15:52,300 --> 00:15:57,580
print is a valid identifier so they're

00:15:54,160 --> 00:15:59,530
they're in conflict you might think that

00:15:57,580 --> 00:16:01,450
you could fix that they may be moving

00:15:59,530 --> 00:16:04,510
the print first or something you could

00:16:01,450 --> 00:16:07,200
say well I'll move that first and maybe

00:16:04,510 --> 00:16:10,630
make that make that more more important

00:16:07,200 --> 00:16:12,280
it turns out that that does not fix the

00:16:10,630 --> 00:16:13,870
problem either it's like if you come

00:16:12,280 --> 00:16:18,460
down to this print thing and try it

00:16:13,870 --> 00:16:21,220
again it's still like it's still not

00:16:18,460 --> 00:16:23,380
picking up the print basically um and so

00:16:21,220 --> 00:16:26,680
in order to in order to fix that kind of

00:16:23,380 --> 00:16:28,330
stuff you have to kind of take extra

00:16:26,680 --> 00:16:30,670
steps I'm one of the things that this

00:16:28,330 --> 00:16:34,290
that this ply tool does is it allows you

00:16:30,670 --> 00:16:36,820
to write functions that match tokens

00:16:34,290 --> 00:16:38,500
where you embed like the Reg acts in a

00:16:36,820 --> 00:16:40,480
doc string like that okay so this is

00:16:38,500 --> 00:16:42,280
this horrible abuse of DOC strings where

00:16:40,480 --> 00:16:44,500
you'd say okay well there's a function

00:16:42,280 --> 00:16:46,360
with the reg ex back string and then in

00:16:44,500 --> 00:16:48,610
the function you could do an explicit

00:16:46,360 --> 00:16:50,530
check and you say well if it's print

00:16:48,610 --> 00:16:56,020
then let's like flip the type of the

00:16:50,530 --> 00:16:57,220
token to print return it bang okay so

00:16:56,020 --> 00:16:59,170
yeah you're doing a little bit of a

00:16:57,220 --> 00:17:03,550
little bit of a hack there to do to do

00:16:59,170 --> 00:17:04,890
that now what's gonna happen here if you

00:17:03,550 --> 00:17:07,420
try print

00:17:04,890 --> 00:17:09,339
let's try tokenizing it now it comes

00:17:07,420 --> 00:17:12,160
back and it says okay now I got I got

00:17:09,339 --> 00:17:15,100
print and I got got ID and and so forth

00:17:12,160 --> 00:17:16,780
so and tools allow some of these you

00:17:15,100 --> 00:17:18,520
know kinds of customizations where it's

00:17:16,780 --> 00:17:20,470
where it's like okay you can match

00:17:18,520 --> 00:17:24,760
things but then do special cases and

00:17:20,470 --> 00:17:27,160
some other some other things and see how

00:17:24,760 --> 00:17:30,250
people are doing out there there'll be a

00:17:27,160 --> 00:17:31,810
quiz on this on this later on some of

00:17:30,250 --> 00:17:33,580
the other things in tokenizing by the

00:17:31,810 --> 00:17:35,660
way you could put functions on some of

00:17:33,580 --> 00:17:40,130
the other symbols like

00:17:35,660 --> 00:17:42,559
like this number rule up here you might

00:17:40,130 --> 00:17:43,820
you might turn that into a function I

00:17:42,559 --> 00:17:46,490
want one of the things that you might

00:17:43,820 --> 00:17:48,140
decide to do there is if you tokenize it

00:17:46,490 --> 00:17:51,320
maybe you want to convert it into an

00:17:48,140 --> 00:17:53,090
integer just as soon as you see it and

00:17:51,320 --> 00:17:55,429
you know it's like instead of leaving it

00:17:53,090 --> 00:17:59,390
as a string you could basically like int

00:17:55,429 --> 00:18:01,280
convert it and then return it back and

00:17:59,390 --> 00:18:03,440
that might be might be something kind of

00:18:01,280 --> 00:18:06,080
convenient later and so when somebody

00:18:03,440 --> 00:18:07,640
sort of token eise's this thing it

00:18:06,080 --> 00:18:11,080
essentially has tokens that are already

00:18:07,640 --> 00:18:13,730
sort of converted into numeric value

00:18:11,080 --> 00:18:15,380
okay so that's that's part of using one

00:18:13,730 --> 00:18:17,240
of these parser generators kind of apply

00:18:15,380 --> 00:18:20,780
to all kind of works works like that you

00:18:17,240 --> 00:18:24,320
write rules out write some functions and

00:18:20,780 --> 00:18:26,690
so forth you've only really done half of

00:18:24,320 --> 00:18:30,710
the problem though it turns out that

00:18:26,690 --> 00:18:34,240
this grammar portion is also sort of

00:18:30,710 --> 00:18:37,220
magical in order to deal with that

00:18:34,240 --> 00:18:39,970
there's a separate component that you

00:18:37,220 --> 00:18:42,590
work with with which is this yak

00:18:39,970 --> 00:18:45,340
component by the way yak stands for yet

00:18:42,590 --> 00:18:47,960
another compiler compiler if you're

00:18:45,340 --> 00:18:50,360
realize I've not defined the acronym for

00:18:47,960 --> 00:18:51,200
that but that's what that stands for and

00:18:50,360 --> 00:18:54,620
you essentially what you do with this

00:18:51,200 --> 00:18:57,409
yak tool is you write functions that

00:18:54,620 --> 00:19:01,309
match different grammar rules so let me

00:18:57,409 --> 00:19:03,320
describe what I'm doing here what I'm

00:19:01,309 --> 00:19:04,789
doing to start as I'm writing a function

00:19:03,320 --> 00:19:08,570
that just says what what does it mean to

00:19:04,789 --> 00:19:10,580
have multiple statements and in the doc

00:19:08,570 --> 00:19:12,980
string I'm writing out this grammar rule

00:19:10,580 --> 00:19:14,870
I'm saying well multiple statements is

00:19:12,980 --> 00:19:17,840
multiple statements followed by a single

00:19:14,870 --> 00:19:19,400
statement it's recursive so you have to

00:19:17,840 --> 00:19:21,440
kind of wrap your brain around that a

00:19:19,400 --> 00:19:24,789
little bit but it's saying well multiple

00:19:21,440 --> 00:19:27,289
statements is multiple plus one they're

00:19:24,789 --> 00:19:29,270
not going to define what I put in there

00:19:27,289 --> 00:19:30,950
yet but you start writing out your your

00:19:29,270 --> 00:19:32,210
grammar kind of like this you would say

00:19:30,950 --> 00:19:33,860
okay well that's multiple statements

00:19:32,210 --> 00:19:37,970
well what does it mean for a single

00:19:33,860 --> 00:19:40,190
statement well you have a rule like that

00:19:37,970 --> 00:19:41,659
you would say okay well statements could

00:19:40,190 --> 00:19:44,330
either be a single statement or it could

00:19:41,659 --> 00:19:45,679
be multiple multiple statements and

00:19:44,330 --> 00:19:48,840
essentially you're gonna go through the

00:19:45,679 --> 00:19:50,950
through this grammar kind of doing this

00:19:48,840 --> 00:19:52,059
now--so doubt for this part of the

00:19:50,950 --> 00:19:54,570
grammar you would say well what kind of

00:19:52,059 --> 00:19:57,580
statements do I have well this first one

00:19:54,570 --> 00:19:59,230
looks like an assignment statement so so

00:19:57,580 --> 00:20:01,059
the grammar rule for that is that you

00:19:59,230 --> 00:20:04,900
have a statement that goes to like ID

00:20:01,059 --> 00:20:06,670
equals expression like name equals value

00:20:04,900 --> 00:20:11,740
basically okay so you're writing you're

00:20:06,670 --> 00:20:15,309
writing out grammar rule now you have a

00:20:11,740 --> 00:20:16,900
print statement so the rule for a print

00:20:15,309 --> 00:20:20,380
statement is you have the word print and

00:20:16,900 --> 00:20:22,570
then parentheses followed by some like

00:20:20,380 --> 00:20:24,250
expression basically so expression could

00:20:22,570 --> 00:20:26,590
be some kind of mathematical thing or

00:20:24,250 --> 00:20:28,240
something or something so you're kind of

00:20:26,590 --> 00:20:29,830
going through this this grammar and

00:20:28,240 --> 00:20:31,540
turning these into functions you're

00:20:29,830 --> 00:20:33,190
gonna do the same thing for expression

00:20:31,540 --> 00:20:36,160
down here so you have an expression for

00:20:33,190 --> 00:20:39,850
like a binary operator this is

00:20:36,160 --> 00:20:41,260
essentially like a like an like plus or

00:20:39,850 --> 00:20:48,820
minus kind of thing okay so maybe you

00:20:41,260 --> 00:20:50,380
have expert plus expert start with that

00:20:48,820 --> 00:20:52,360
and then you have some other cases down

00:20:50,380 --> 00:20:54,580
here where it's you have like an

00:20:52,360 --> 00:20:57,190
expression for a single number basically

00:20:54,580 --> 00:20:58,480
an expression could be a number and then

00:20:57,190 --> 00:21:05,710
you have an expression for like a

00:20:58,480 --> 00:21:06,910
variable look up because you're gonna

00:21:05,710 --> 00:21:08,610
you're gonna go through your grammar and

00:21:06,910 --> 00:21:12,790
kind of fill fill this out this last

00:21:08,610 --> 00:21:17,340
that you probably add F there okay this

00:21:12,790 --> 00:21:17,340
last part is an expression for grouping

00:21:21,330 --> 00:21:26,890
okay so you write out your you write out

00:21:23,559 --> 00:21:28,780
your your grammar like that just as a

00:21:26,890 --> 00:21:31,120
note by the way writing out grammars is

00:21:28,780 --> 00:21:32,650
a pretty non-trivial thing to like to

00:21:31,120 --> 00:21:33,970
actually figure out the grammar for a

00:21:32,650 --> 00:21:35,590
programming language so I don't want to

00:21:33,970 --> 00:21:37,480
gloss over that and say that's just like

00:21:35,590 --> 00:21:39,100
totally easy what's going on there but

00:21:37,480 --> 00:21:40,570
this is you know that's a fairly

00:21:39,100 --> 00:21:42,190
non-trivial thing but you're gonna write

00:21:40,570 --> 00:21:44,770
out you have your grammar basically in

00:21:42,190 --> 00:21:47,380
functions like that and then you take

00:21:44,770 --> 00:21:50,460
this sort of magic leap where you just

00:21:47,380 --> 00:21:53,380
run like yak on this thing and like

00:21:50,460 --> 00:21:57,190
somehow this produces a parser for you

00:21:53,380 --> 00:21:59,620
okay so so I'm gonna run that and it's

00:21:57,190 --> 00:22:00,700
gonna come back with some mystery first

00:21:59,620 --> 00:22:01,960
of all it comes back with a warning

00:22:00,700 --> 00:22:05,529
message about old Missy

00:22:01,960 --> 00:22:06,850
error function we can ignore all the the

00:22:05,529 --> 00:22:07,990
warnings right and then and then you get

00:22:06,850 --> 00:22:10,210
a again then you get a message about

00:22:07,990 --> 00:22:13,659
shift reduce conflicts it's like what is

00:22:10,210 --> 00:22:15,820
bad again I'm gonna ignore that for the

00:22:13,659 --> 00:22:18,370
moment you know the just warnings right

00:22:15,820 --> 00:22:20,470
they're just just warnings and how this

00:22:18,370 --> 00:22:23,380
is gonna how this is supposed to work is

00:22:20,470 --> 00:22:25,990
that you would say parser parse and then

00:22:23,380 --> 00:22:29,620
you give it some input and it's supposed

00:22:25,990 --> 00:22:31,570
to parse your input somehow okay so you

00:22:29,620 --> 00:22:34,480
say like parsed equals three times four

00:22:31,570 --> 00:22:38,140
plus five now at this point basically

00:22:34,480 --> 00:22:40,409
nothing happens it's like okay that was

00:22:38,140 --> 00:22:43,630
that was super anti-climatic right

00:22:40,409 --> 00:22:44,919
nothing nothing happens the only time

00:22:43,630 --> 00:22:46,539
that you'd be able to determine anything

00:22:44,919 --> 00:22:48,669
happening is if you actually gave it

00:22:46,539 --> 00:22:51,820
like invalid input or something like

00:22:48,669 --> 00:22:53,140
you've said a equals equals three it

00:22:51,820 --> 00:22:54,429
would suddenly come back saying like

00:22:53,140 --> 00:22:55,840
well okay I don't know what you're doing

00:22:54,429 --> 00:22:58,140
what is this extra equal I don't know

00:22:55,840 --> 00:23:02,289
anything about this extra equal sign so

00:22:58,140 --> 00:23:04,450
what's going on there all this thing is

00:23:02,289 --> 00:23:07,149
doing at this point is like is it valid

00:23:04,450 --> 00:23:10,149
syntax or not it does nothing else and

00:23:07,149 --> 00:23:12,760
in order to do more you basically have

00:23:10,149 --> 00:23:14,919
to teach this grammar to do other things

00:23:12,760 --> 00:23:16,750
on what you do in these functions by the

00:23:14,919 --> 00:23:19,600
way is you usually take some kind of

00:23:16,750 --> 00:23:23,230
action like in the number thing you

00:23:19,600 --> 00:23:25,059
could say hey I got a number if you

00:23:23,230 --> 00:23:27,159
print it out a value what would happen

00:23:25,059 --> 00:23:29,590
when you parse that or recognize the

00:23:27,159 --> 00:23:31,779
number is you would see that function

00:23:29,590 --> 00:23:32,980
fire basically like if you did a par so

00:23:31,779 --> 00:23:35,020
you'd see the thing saying hey I got a

00:23:32,980 --> 00:23:37,750
number so you says I got three got four

00:23:35,020 --> 00:23:40,870
I got five those rules are essentially

00:23:37,750 --> 00:23:42,549
like callback functions maybe it's not

00:23:40,870 --> 00:23:44,440
you know but if you've done callback

00:23:42,549 --> 00:23:45,669
functions with networking or gooeys or

00:23:44,440 --> 00:23:48,730
something like that it's kind of the

00:23:45,669 --> 00:23:50,230
same idea these are basically functions

00:23:48,730 --> 00:23:52,750
that get triggered when the when the

00:23:50,230 --> 00:23:54,250
parser recognizes the name and then

00:23:52,750 --> 00:23:56,770
typically what you're gonna do in there

00:23:54,250 --> 00:23:58,929
is build some kind of data structure now

00:23:56,770 --> 00:24:03,010
the kind of thing that you might build

00:23:58,929 --> 00:24:05,230
in here is maybe a like a tree like

00:24:03,010 --> 00:24:07,090
structure this is gonna this is going to

00:24:05,230 --> 00:24:09,010
look a little strange but I'm making I'm

00:24:07,090 --> 00:24:11,399
gonna make tuples in these different

00:24:09,010 --> 00:24:11,399
rules

00:24:17,710 --> 00:24:22,520
listen we'll just see what happens here

00:24:19,970 --> 00:24:24,680
okay so I'm making basically data

00:24:22,520 --> 00:24:26,120
structures of tuples I've what's happen

00:24:24,680 --> 00:24:28,580
to happen is these these things are

00:24:26,120 --> 00:24:30,500
basically gonna propagate in the in the

00:24:28,580 --> 00:24:32,890
parser guys I'm making making some

00:24:30,500 --> 00:24:32,890
tubule

00:24:34,450 --> 00:24:39,890
actually they we don't forget to need to

00:24:38,000 --> 00:24:41,630
do that okay so just as a little

00:24:39,890 --> 00:24:45,050
description of what's going on here this

00:24:41,630 --> 00:24:46,340
this p0 is sort of the result of parsing

00:24:45,050 --> 00:24:48,200
and the thing on the right is where

00:24:46,340 --> 00:24:50,600
you're getting it so this is saying well

00:24:48,200 --> 00:24:54,170
the result of a group is the result of

00:24:50,600 --> 00:24:56,570
whatever the second item is there left

00:24:54,170 --> 00:24:59,140
paren is the first item so you put you

00:24:56,570 --> 00:25:01,670
put in these rules rules like that let's

00:24:59,140 --> 00:25:04,070
let's just kind of continue up the thing

00:25:01,670 --> 00:25:07,070
here here I'm saying you're printing the

00:25:04,070 --> 00:25:11,179
value of an expression here you're

00:25:07,070 --> 00:25:15,080
assigning the value of a variable again

00:25:11,179 --> 00:25:19,760
the p3 means the expression part and p1

00:25:15,080 --> 00:25:22,040
means the ID part and you start filling

00:25:19,760 --> 00:25:25,910
and the grammar with with things like

00:25:22,040 --> 00:25:29,890
this okay so here's a single statement

00:25:25,910 --> 00:25:29,890
is a list with a single statement in it

00:25:31,809 --> 00:25:37,030
return and oh it's not not the return

00:25:34,760 --> 00:25:37,030
statement

00:25:44,250 --> 00:25:52,110
again there will be a quiz later on here

00:25:46,590 --> 00:25:52,590
okay so so okay so putting rules like

00:25:52,110 --> 00:25:54,929
that

00:25:52,590 --> 00:25:57,390
if I've done my job right now I'm not

00:25:54,929 --> 00:25:59,549
sure that I have what the result of this

00:25:57,390 --> 00:26:01,590
is gonna be is when you parse something

00:25:59,549 --> 00:26:03,480
you're gonna get like a little like

00:26:01,590 --> 00:26:04,950
structure of tuples like that it's

00:26:03,480 --> 00:26:09,179
basically saying hey you're assigning a

00:26:04,950 --> 00:26:10,140
and the value of a is the x operator and

00:26:09,179 --> 00:26:13,400
you're taking three and you're

00:26:10,140 --> 00:26:16,440
multiplying that times four plus five

00:26:13,400 --> 00:26:18,150
one thing that you may suddenly notice

00:26:16,440 --> 00:26:21,570
about that is that it's actually not the

00:26:18,150 --> 00:26:23,130
correct mathematical calculation like

00:26:21,570 --> 00:26:25,710
you're not taking three and multiplying

00:26:23,130 --> 00:26:27,840
it times four plus five that is actually

00:26:25,710 --> 00:26:29,850
what that warning message is with the

00:26:27,840 --> 00:26:32,130
shift reduce is that it's dealing you

00:26:29,850 --> 00:26:35,100
having like an ambiguity with operator

00:26:32,130 --> 00:26:37,440
precedence so these these parts are

00:26:35,100 --> 00:26:40,590
generators often have rules for dealing

00:26:37,440 --> 00:26:43,289
with that or you can teach them rules

00:26:40,590 --> 00:26:44,700
about operator like importance and

00:26:43,289 --> 00:26:47,850
precedents and stuff so you can put a

00:26:44,700 --> 00:26:49,770
specifier in like that maybe run this

00:26:47,850 --> 00:26:51,480
thing again and then it will start doing

00:26:49,770 --> 00:26:53,370
things more correctly here it's like

00:26:51,480 --> 00:26:56,640
okay now you now you're doing a plus and

00:26:53,370 --> 00:26:58,740
it's three you're dude it's it's the

00:26:56,640 --> 00:27:00,750
result of three times four plus five I

00:26:58,740 --> 00:27:04,080
don't want to get too bogged down in the

00:27:00,750 --> 00:27:05,820
in the details of this but one of the

00:27:04,080 --> 00:27:08,100
things that I want you to observe is

00:27:05,820 --> 00:27:10,590
that we're basically using Python it's

00:27:08,100 --> 00:27:12,510
kind of a domain-specific language in a

00:27:10,590 --> 00:27:16,530
way I mean we're sort of abusing Python

00:27:12,510 --> 00:27:18,510
syntax to do a parser generator and it's

00:27:16,530 --> 00:27:21,090
kind of an interesting it's kind of an

00:27:18,510 --> 00:27:23,400
interesting way to do that this is very

00:27:21,090 --> 00:27:26,150
much what this spark tool was doing it's

00:27:23,400 --> 00:27:31,039
very much what this ply project is doing

00:27:26,150 --> 00:27:33,960
and I guess some some comments on this

00:27:31,039 --> 00:27:36,450
display tool I mean it actually gives me

00:27:33,960 --> 00:27:38,909
sort of great sadness to be honest um

00:27:36,450 --> 00:27:40,799
one of the issues with this ply tool is

00:27:38,909 --> 00:27:44,100
it actually predates a lot of

00:27:40,799 --> 00:27:45,990
interesting Python features it predates

00:27:44,100 --> 00:27:48,030
like the iterator protocol there are no

00:27:45,990 --> 00:27:50,820
decorators there were no new style

00:27:48,030 --> 00:27:52,860
classes or anything like that it was

00:27:50,820 --> 00:27:56,130
actually written in somewhat great haste

00:27:52,860 --> 00:27:58,530
when it was first created it was made on

00:27:56,130 --> 00:28:00,660
a machine that was only 200 mega

00:27:58,530 --> 00:28:03,030
so you had to take some coding shortcuts

00:28:00,660 --> 00:28:06,120
to deal with that there's a lot of

00:28:03,030 --> 00:28:07,950
heuristics on on source code inspection

00:28:06,120 --> 00:28:10,920
and other stuff so the code is sort of

00:28:07,950 --> 00:28:12,830
insane and to give you some some ideas

00:28:10,920 --> 00:28:15,780
on that

00:28:12,830 --> 00:28:17,760
that this is this is typical of the code

00:28:15,780 --> 00:28:20,760
that you find in there the reason that I

00:28:17,760 --> 00:28:25,650
put this up is I'm especially proud of

00:28:20,760 --> 00:28:28,650
this little bit at the end I'm doing a

00:28:25,650 --> 00:28:32,010
for loop and I'm incrementing the

00:28:28,650 --> 00:28:33,900
variable Y like III put this up because

00:28:32,010 --> 00:28:36,300
I would like to just lay claim to that

00:28:33,900 --> 00:28:40,400
being the beasley pattern and if I need

00:28:36,300 --> 00:28:42,540
it okay so so I've had stuff like that

00:28:40,400 --> 00:28:46,559
this is also kind of an interesting

00:28:42,540 --> 00:28:49,290
thing how many how many people have a

00:28:46,559 --> 00:28:51,870
github profile looks like this don't

00:28:49,290 --> 00:28:56,550
don't be ashamed here so I got a bug

00:28:51,870 --> 00:29:00,330
report two years ago from somebody this

00:28:56,550 --> 00:29:03,809
was basically their github profile one

00:29:00,330 --> 00:29:06,030
one patch for replied they basically

00:29:03,809 --> 00:29:08,790
found a 15 year old critical but again

00:29:06,030 --> 00:29:10,559
ply and in finding that they actually

00:29:08,790 --> 00:29:12,360
found like the offending line of source

00:29:10,559 --> 00:29:13,890
code which is truly remarkable I can

00:29:12,360 --> 00:29:15,720
only think that that's why there's

00:29:13,890 --> 00:29:20,340
nothing contributing up to that point

00:29:15,720 --> 00:29:21,540
because it took that long and I mean it

00:29:20,340 --> 00:29:23,940
you know and you're like okay what is

00:29:21,540 --> 00:29:28,890
this 15-year critical bug well it's

00:29:23,940 --> 00:29:30,210
doing math correctly only they found

00:29:28,890 --> 00:29:32,640
like this case where you could do things

00:29:30,210 --> 00:29:35,400
like negative 3 minus 4 gives you 1 and

00:29:32,640 --> 00:29:36,660
it's like that's not that's not right I

00:29:35,400 --> 00:29:40,580
mean it's like that's not help that

00:29:36,660 --> 00:29:43,050
happens but reason I put that up you

00:29:40,580 --> 00:29:44,820
people like to look at github things is

00:29:43,050 --> 00:29:48,059
like kind of score or something you know

00:29:44,820 --> 00:29:49,740
got a high score on github that was

00:29:48,059 --> 00:29:54,530
probably the most significant bug I've

00:29:49,740 --> 00:29:54,530
gotten an apply project like 10 years so

00:29:54,920 --> 00:29:58,650
read that take take whatever you want

00:29:57,240 --> 00:30:01,140
from that but though that was sort of

00:29:58,650 --> 00:30:02,550
amazed I I did not put the person's name

00:30:01,140 --> 00:30:05,220
on here because I don't know whether

00:30:02,550 --> 00:30:07,830
this is a badge of honor or shame

00:30:05,220 --> 00:30:09,149
gonna delegate their out and then

00:30:07,830 --> 00:30:10,260
there's been some other projects out

00:30:09,149 --> 00:30:14,100
there that have actually tried to make

00:30:10,260 --> 00:30:15,059
this ply project respectable the

00:30:14,100 --> 00:30:17,460
province I don't want it to be

00:30:15,059 --> 00:30:19,320
respectable I'm getting kind of in the

00:30:17,460 --> 00:30:23,760
end here I actually want the project to

00:30:19,320 --> 00:30:25,110
die actually so uh so one of the one

00:30:23,760 --> 00:30:26,789
thing that I kind of did recently is I

00:30:25,110 --> 00:30:28,950
had this like why don't I just put an F

00:30:26,789 --> 00:30:31,590
string in it just kill like all private

00:30:28,950 --> 00:30:33,750
previous versions and then just go crazy

00:30:31,590 --> 00:30:35,250
with some new features there's a whole

00:30:33,750 --> 00:30:37,769
bunch of new stuff you can do in Python

00:30:35,250 --> 00:30:40,260
like you can rely on the fact that

00:30:37,769 --> 00:30:43,769
dictionaries now have definition order

00:30:40,260 --> 00:30:46,409
preserve or you can use you can write

00:30:43,769 --> 00:30:48,029
classes that that monitor subclasses

00:30:46,409 --> 00:30:51,779
there's kind of it's an it subclass

00:30:48,029 --> 00:30:53,519
thing that's pretty cool you can still

00:30:51,779 --> 00:30:55,380
use meta classes I mean they're kind of

00:30:53,519 --> 00:30:57,029
even more magical than they were before

00:30:55,380 --> 00:30:58,649
but you can do some things with the

00:30:57,029 --> 00:31:06,510
definition environment that are pretty

00:30:58,649 --> 00:31:10,260
interesting there's types yeah well III

00:31:06,510 --> 00:31:12,299
think that types could be magic I don't

00:31:10,260 --> 00:31:13,559
know that's a whole different topic okay

00:31:12,299 --> 00:31:17,220
so yeah yeah you could probably put use

00:31:13,559 --> 00:31:19,320
type annotations for stuff and kind of

00:31:17,220 --> 00:31:21,419
playing around with this so I have I

00:31:19,320 --> 00:31:25,559
have a sort of a second version of the

00:31:21,419 --> 00:31:28,019
ply project that that explores some of

00:31:25,559 --> 00:31:29,130
this in with flagrant disregard for

00:31:28,019 --> 00:31:31,820
anything

00:31:29,130 --> 00:31:38,039
probably decent basically but let's do a

00:31:31,820 --> 00:31:40,529
little demo of that so so the ply

00:31:38,039 --> 00:31:43,620
project or the sly project the way that

00:31:40,529 --> 00:31:46,230
that works is it does actually go to

00:31:43,620 --> 00:31:48,539
more of a proper kind of object-oriented

00:31:46,230 --> 00:31:50,970
technique so you do to fight you what

00:31:48,539 --> 00:31:53,340
you're gonna do is define a class that

00:31:50,970 --> 00:31:57,120
inherits from lexer and you're gonna

00:31:53,340 --> 00:31:59,730
define kind of a token set so you'll

00:31:57,120 --> 00:32:03,269
you'll define what your what your tokens

00:31:59,730 --> 00:32:07,470
are like that okay so there's your

00:32:03,269 --> 00:32:09,539
tokens and then it dispenses with the

00:32:07,470 --> 00:32:11,639
Holte thing okay so you can just you can

00:32:09,539 --> 00:32:15,179
take your class kind of write out your

00:32:11,639 --> 00:32:17,580
tokens like that and you you basically

00:32:15,179 --> 00:32:18,690
have a lexer at that point on so what

00:32:17,580 --> 00:32:27,179
you can do is say okay

00:32:18,690 --> 00:32:29,729
my looks there's my waxer all right so

00:32:27,179 --> 00:32:31,169
you do that and then if you want to if

00:32:29,729 --> 00:32:36,529
you want to tokenize something you can

00:32:31,169 --> 00:32:36,529
say for toke and you know lexer tokenize

00:32:37,039 --> 00:32:44,879
is anybody disturbed yet a little bit

00:32:40,499 --> 00:32:49,559
and yeah you're probably disturbed by

00:32:44,879 --> 00:32:51,090
the lack of quotes and okay okay so you

00:32:49,559 --> 00:32:55,710
get your you get your you get your

00:32:51,090 --> 00:32:57,690
tokenizer like like that it still

00:32:55,710 --> 00:32:59,669
suffers from some of the same problems

00:32:57,690 --> 00:33:02,820
as before i'm like that like the print

00:32:59,669 --> 00:33:04,859
thing down here that is still an issue

00:33:02,820 --> 00:33:06,929
like you like you have the problem that

00:33:04,859 --> 00:33:09,840
that being miss recognized or miss miss

00:33:06,929 --> 00:33:11,669
not not found but that's actually really

00:33:09,840 --> 00:33:14,009
easy to fix because you can teach

00:33:11,669 --> 00:33:15,599
identifier is that if you see print

00:33:14,009 --> 00:33:17,220
actually you don't need the quotes there

00:33:15,599 --> 00:33:22,499
you can just turn that into the print

00:33:17,220 --> 00:33:26,239
token okay so you can you can you can do

00:33:22,499 --> 00:33:28,769
things do things like that you can also

00:33:26,239 --> 00:33:31,830
okay so now it's basically saying you've

00:33:28,769 --> 00:33:34,200
got print and and so forth you can also

00:33:31,830 --> 00:33:36,210
attach functions to things so like if

00:33:34,200 --> 00:33:44,669
you wanted to have numbers converted you

00:33:36,210 --> 00:33:47,489
could you can do that too so what's

00:33:44,669 --> 00:33:49,409
going to happen with that is if you did

00:33:47,489 --> 00:33:51,210
if you did parse some numbers like a is

00:33:49,409 --> 00:33:54,629
3 plus 4 or something you would see

00:33:51,210 --> 00:33:56,639
those numbers basically being parsed oh

00:33:54,629 --> 00:34:02,849
yeah I didn't do the ignored characters

00:33:56,639 --> 00:34:03,510
yet so in let's teach it that too okay

00:34:02,849 --> 00:34:06,480
so

00:34:03,510 --> 00:34:08,610
kind of kind of like the old tool but a

00:34:06,480 --> 00:34:10,919
lot of it is sort of much more I don't

00:34:08,610 --> 00:34:13,620
know it's sort of much more contact and

00:34:10,919 --> 00:34:17,639
sort of much more elegant and in many

00:34:13,620 --> 00:34:20,340
many ways there the parser component of

00:34:17,639 --> 00:34:22,409
it is also kind of a kind of an

00:34:20,340 --> 00:34:24,510
interesting idea the way that that works

00:34:22,409 --> 00:34:30,659
is you're gonna make a kind of a parser

00:34:24,510 --> 00:34:32,370
that looks like this and you're gonna

00:34:30,659 --> 00:34:34,440
write functions okay so you're gonna

00:34:32,370 --> 00:34:36,210
write a function statements like like

00:34:34,440 --> 00:34:39,870
this so you kind of write functions that

00:34:36,210 --> 00:34:41,490
match the left-hand side but I have to

00:34:39,870 --> 00:34:43,050
admit I did get rid of docstrings

00:34:41,490 --> 00:34:45,389
people really did not like the docs

00:34:43,050 --> 00:34:48,929
during part of a part of the pleye

00:34:45,389 --> 00:34:50,580
project and it's like all right I'll

00:34:48,929 --> 00:34:53,190
give you something better than a doc

00:34:50,580 --> 00:34:59,280
string so I'm gonna give you the the

00:34:53,190 --> 00:35:00,720
underscore decorator it's the closest

00:34:59,280 --> 00:35:07,130
thing that I could come up with to look

00:35:00,720 --> 00:35:09,180
like Perl without actually being so the

00:35:07,130 --> 00:35:11,550
yeah I know if people are really gonna

00:35:09,180 --> 00:35:13,110
not like that okay so what you would

00:35:11,550 --> 00:35:14,910
what you would do is essentially write

00:35:13,110 --> 00:35:16,500
like like something like that you say

00:35:14,910 --> 00:35:18,720
well statements could either be more

00:35:16,500 --> 00:35:21,120
than one statement or statement or could

00:35:18,720 --> 00:35:22,380
be a single statement you'll notice

00:35:21,120 --> 00:35:26,880
there's like two functions with the same

00:35:22,380 --> 00:35:29,730
name there okay little disturbing maybe

00:35:26,880 --> 00:35:31,050
okay and then you kind of kind of fill

00:35:29,730 --> 00:35:34,680
this thing out you say well okay this

00:35:31,050 --> 00:35:43,640
statement with ID expression that's

00:35:34,680 --> 00:35:43,640
basically one statement it a print

00:35:49,160 --> 00:35:53,670
okay so you're defining two statements

00:35:51,450 --> 00:35:55,680
there like like that you kind of

00:35:53,670 --> 00:35:58,140
continue through the whole you know the

00:35:55,680 --> 00:36:01,349
whole thing here it's well if you want

00:35:58,140 --> 00:36:02,819
to do expressions a little I've only got

00:36:01,349 --> 00:36:13,559
like five minutes here so I got no you

00:36:02,819 --> 00:36:14,819
got a got you must type faster so the

00:36:13,559 --> 00:36:18,180
little looks looks a little different

00:36:14,819 --> 00:36:25,019
but it's it's it's kind of the same the

00:36:18,180 --> 00:36:26,670
same idea I'm not gonna do the grouping

00:36:25,019 --> 00:36:28,979
just in the interest of time here okay

00:36:26,670 --> 00:36:30,660
so you start off you basically do your

00:36:28,979 --> 00:36:34,170
grammar like that okay so you have a

00:36:30,660 --> 00:36:35,789
bunch of bunch of functions like that in

00:36:34,170 --> 00:36:37,559
those rules you're gonna do the same

00:36:35,789 --> 00:36:41,579
kind of thing that you did in the in the

00:36:37,559 --> 00:36:43,529
last example but it's gonna look a

00:36:41,579 --> 00:36:45,960
little different you'll say oh this this

00:36:43,529 --> 00:36:50,220
is like an ID or you have PID and this

00:36:45,960 --> 00:36:52,380
is a you know a number where you have

00:36:50,220 --> 00:36:55,799
sort of the number number value there

00:36:52,380 --> 00:36:57,749
this is going to return a tuple or that

00:36:55,799 --> 00:36:59,999
the values of the tuple or the operator

00:36:57,749 --> 00:37:02,009
and then you have like the expression on

00:36:59,999 --> 00:37:03,809
the the left and the expression on the

00:37:02,009 --> 00:37:06,089
right this might look a little weird by

00:37:03,809 --> 00:37:08,249
the way this is basically trying to

00:37:06,089 --> 00:37:10,049
disambiguate the two expressions and

00:37:08,249 --> 00:37:12,329
they're and the syntax for that is

00:37:10,049 --> 00:37:14,999
mirrored after what is used in compiler

00:37:12,329 --> 00:37:23,400
books so it's meant to mirror what's in

00:37:14,999 --> 00:37:28,920
the textbook actually okay so it kind of

00:37:23,400 --> 00:37:31,160
kind of continued on here we're almost

00:37:28,920 --> 00:37:31,160
done

00:37:32,599 --> 00:37:36,859
very famous last words okay so

00:37:40,480 --> 00:37:46,570
oh now I'm really in trouble at the

00:37:44,339 --> 00:37:47,290
hearing the applies on the other room

00:37:46,570 --> 00:37:51,220
there okay

00:37:47,290 --> 00:37:59,140
so you so you you basically do that and

00:37:51,220 --> 00:38:03,820
if I've done this right which statement

00:37:59,140 --> 00:38:05,800
oh yeah okay okay oh we should probably

00:38:03,820 --> 00:38:19,119
put some some precedence rules in this

00:38:05,800 --> 00:38:23,859
in it does need to have an opening break

00:38:19,119 --> 00:38:26,500
dragon on there okay so so if we if we

00:38:23,859 --> 00:38:28,329
done that okay not not quite yet

00:38:26,500 --> 00:38:35,010
it doesn't need to know what the tokens

00:38:28,329 --> 00:38:38,140
are okay so you do have to teach it that

00:38:35,010 --> 00:38:39,190
okay let's let's try it out here so what

00:38:38,140 --> 00:38:41,470
you're gonna do is basically parse

00:38:39,190 --> 00:38:49,930
something you have to give it kind of

00:38:41,470 --> 00:38:53,650
the the token list like that and you

00:38:49,930 --> 00:38:54,250
have to spell it right supposed to know

00:38:53,650 --> 00:38:56,920
what I'm doing

00:38:54,250 --> 00:38:59,609
you'll basically get back your net back

00:38:56,920 --> 00:39:02,530
your parsed output now we're basically

00:38:59,609 --> 00:39:04,599
at the end of this thing now and really

00:39:02,530 --> 00:39:07,450
the point of this this talk is not so

00:39:04,599 --> 00:39:10,300
much that I mean it's like okay you know

00:39:07,450 --> 00:39:12,819
it's parser generator I think the the

00:39:10,300 --> 00:39:15,160
interesting thing here oh well there are

00:39:12,819 --> 00:39:19,390
some downsides let me get to that

00:39:15,160 --> 00:39:20,890
downside here if you do this you're

00:39:19,390 --> 00:39:23,079
gonna break the universe by the way I

00:39:20,890 --> 00:39:25,240
mean this this slide tool breaks pycharm

00:39:23,079 --> 00:39:27,849
pet bait pile in my pie probably the

00:39:25,240 --> 00:39:29,410
whole well universe I sort of thought

00:39:27,849 --> 00:39:35,790
about like how would I defend myself

00:39:29,410 --> 00:39:40,300
against that and III think I think the

00:39:35,790 --> 00:39:42,550
interesting thing here is that that you

00:39:40,300 --> 00:39:44,890
know that talk that that's that talk on

00:39:42,550 --> 00:39:46,630
spark they saw like twenty years ago I

00:39:44,890 --> 00:39:49,540
thought that was so awesome

00:39:46,630 --> 00:39:52,119
or it's like oh man he's like totally

00:39:49,540 --> 00:39:53,770
abused Python in this like horrible way

00:39:52,119 --> 00:39:55,170
to do this cool thing with parser

00:39:53,770 --> 00:39:58,809
generator

00:39:55,170 --> 00:40:00,099
and what's happening Python 3 6 is that

00:39:58,809 --> 00:40:01,959
they've given you all these like new

00:40:00,099 --> 00:40:04,059
knobs to turn like it's like okay you

00:40:01,959 --> 00:40:05,709
have like ordered Guido's gonna regret

00:40:04,059 --> 00:40:07,749
making dictionaries ordered probably

00:40:05,709 --> 00:40:09,219
after this talk no no it's like you have

00:40:07,749 --> 00:40:11,109
you have ordered dictionaries you have

00:40:09,219 --> 00:40:12,939
all this way to monitor subclasses and

00:40:11,109 --> 00:40:15,400
you've got this like meta class stuff

00:40:12,939 --> 00:40:17,469
going on and type you know type hints

00:40:15,400 --> 00:40:19,420
and stuff there's some really

00:40:17,469 --> 00:40:22,630
interesting stuff you can do with those

00:40:19,420 --> 00:40:24,699
that that like take like that docstring

00:40:22,630 --> 00:40:26,140
thing from 20 years ago and just push it

00:40:24,699 --> 00:40:30,219
into like a whole different space-time

00:40:26,140 --> 00:40:32,199
like dimension basically and I think

00:40:30,219 --> 00:40:35,049
there may be some interesting things

00:40:32,199 --> 00:40:36,549
there like for certain kinds of problems

00:40:35,049 --> 00:40:38,079
it might be really cool to kind of play

00:40:36,549 --> 00:40:39,369
around with it I I've been kind of

00:40:38,079 --> 00:40:41,259
dealing with this with the parser

00:40:39,369 --> 00:40:43,479
generator and I've been doing this and

00:40:41,259 --> 00:40:45,309
you know some compiler classes and stuff

00:40:43,479 --> 00:40:47,680
it's it's it's really cool I mean it's

00:40:45,309 --> 00:40:49,900
super magical maybe maybe too magical

00:40:47,680 --> 00:40:51,939
but it is there's some interesting

00:40:49,900 --> 00:40:53,709
things there so kind of hoping that Navy

00:40:51,939 --> 00:40:57,130
will inspire some student or something

00:40:53,709 --> 00:40:59,799
to go run off and get fired or something

00:40:57,130 --> 00:41:01,679
yeah okay so anyway so that's the end of

00:40:59,799 --> 00:41:04,479
the end of the talk

00:41:01,679 --> 00:41:06,160
follow me on Twitter do we have any time

00:41:04,479 --> 00:41:07,479
for questions or we like out of time

00:41:06,160 --> 00:41:10,269
thanks David

00:41:07,479 --> 00:41:12,579
we have a time for a couple questions so

00:41:10,269 --> 00:41:14,920
if you'd like to ask one step up to the

00:41:12,579 --> 00:41:21,449
mic we ask that you only ask one

00:41:14,920 --> 00:41:21,449
question one question okay all right

00:41:30,540 --> 00:41:35,890
is there it's a note that people are too

00:41:33,580 --> 00:41:39,610
stunned for a question oh there we have

00:41:35,890 --> 00:41:43,120
one question hey David I saw on the

00:41:39,610 --> 00:41:44,950
parser and that tokenize a class that it

00:41:43,120 --> 00:41:47,470
referenced all the tokens before they

00:41:44,950 --> 00:41:48,700
were actually defined was that how come

00:41:47,470 --> 00:41:50,470
it's not a name error was there some

00:41:48,700 --> 00:41:55,030
middle class there you can do anything

00:41:50,470 --> 00:41:56,710
with metaclasses yeah hey I mean that

00:41:55,030 --> 00:41:58,930
might actually I want to make a comment

00:41:56,710 --> 00:42:01,960
about that um one of the one of the

00:41:58,930 --> 00:42:04,500
reasons why it does that is I have run

00:42:01,960 --> 00:42:07,570
into lots of problems in classes where

00:42:04,500 --> 00:42:11,140
people will put quotes around stuff like

00:42:07,570 --> 00:42:13,150
let's say it's quoted like that and then

00:42:11,140 --> 00:42:16,690
they'll they'll hit return in the middle

00:42:13,150 --> 00:42:20,280
of a line or something and not realize

00:42:16,690 --> 00:42:22,270
that they have an error in the code I

00:42:20,280 --> 00:42:25,180
don't know whether people can even spot

00:42:22,270 --> 00:42:27,640
the error there the error is that bass

00:42:25,180 --> 00:42:30,250
is a Python concatenates adjacent

00:42:27,640 --> 00:42:31,360
strings like if you miss a comma or

00:42:30,250 --> 00:42:34,420
something like that you get like

00:42:31,360 --> 00:42:36,250
adjacent string concatenation I was sick

00:42:34,420 --> 00:42:37,780
of dealing with it in teaching classes

00:42:36,250 --> 00:42:43,210
and I was like you know what you can't

00:42:37,780 --> 00:42:44,650
concatenate a JSON identifier like if

00:42:43,210 --> 00:42:48,870
you forget the comma you'll actually get

00:42:44,650 --> 00:42:50,980
like a like a syntax error in Python so

00:42:48,870 --> 00:42:52,450
no I might look kind of crazy but it's

00:42:50,980 --> 00:42:55,000
actually done to address like a very

00:42:52,450 --> 00:42:59,200
specific use of like using usability

00:42:55,000 --> 00:43:03,130
problem and like using it hi thanks for

00:42:59,200 --> 00:43:05,890
the talk we're big users apply and I'm

00:43:03,130 --> 00:43:08,860
wondering if there's any advantages for

00:43:05,890 --> 00:43:11,110
me to convert all my code than the new

00:43:08,860 --> 00:43:12,700
version like speed improvements stuff

00:43:11,110 --> 00:43:14,050
like that well the main advantage is

00:43:12,700 --> 00:43:17,400
that you can drop every version of

00:43:14,050 --> 00:43:17,400
Python prior to three six

00:43:17,550 --> 00:43:26,230
III just days back aside from that no I

00:43:23,770 --> 00:43:27,520
think there's actually liked fly a lot

00:43:26,230 --> 00:43:29,260
better because one of them one of the

00:43:27,520 --> 00:43:31,510
prawns with plies there's way too much

00:43:29,260 --> 00:43:33,850
weird hacking with like this like

00:43:31,510 --> 00:43:36,280
there's like this cached output file and

00:43:33,850 --> 00:43:37,960
like it does it does all sorts of weird

00:43:36,280 --> 00:43:38,930
things like writing things on the file

00:43:37,960 --> 00:43:40,640
system

00:43:38,930 --> 00:43:44,059
and causes a lot of problems with like

00:43:40,640 --> 00:43:45,410
deployment and other other things and

00:43:44,059 --> 00:43:47,390
it's like I tried to just get rid of

00:43:45,410 --> 00:43:49,130
that like it's like okay this is a new

00:43:47,390 --> 00:43:51,049
thing like let's just get rid of all

00:43:49,130 --> 00:43:54,230
this junk from when I had like my two

00:43:51,049 --> 00:43:58,099
hundred megahertz PC and and just like

00:43:54,230 --> 00:43:59,599
modernize the thing it does have the the

00:43:58,099 --> 00:44:04,460
feature though it does require Python

00:43:59,599 --> 00:44:06,200
three six though hey so apart from like

00:44:04,460 --> 00:44:07,970
the fun of abusing all the language

00:44:06,200 --> 00:44:09,680
syntax like if you actually had to write

00:44:07,970 --> 00:44:11,210
a language would you actually like use

00:44:09,680 --> 00:44:14,240
this or would you like recommend

00:44:11,210 --> 00:44:15,770
something like pi parsing um no people

00:44:14,240 --> 00:44:17,180
use this to write languages I would look

00:44:15,770 --> 00:44:19,250
at PI parsing too though I mean it's a

00:44:17,180 --> 00:44:21,170
different approach so I mean there's

00:44:19,250 --> 00:44:23,690
different tools out there I mean antler

00:44:21,170 --> 00:44:26,990
is another tool it's um that's out there

00:44:23,690 --> 00:44:29,150
I forget it said Eric snow that has the

00:44:26,990 --> 00:44:31,309
PEG parser I'm forgetting the name of

00:44:29,150 --> 00:44:33,020
his of his project off the top of my

00:44:31,309 --> 00:44:34,819
head but no there's a lot of tools out

00:44:33,020 --> 00:44:37,339
there I I would definitely just look

00:44:34,819 --> 00:44:39,109
around at tools especially you know

00:44:37,339 --> 00:44:40,910
compared to writing it yourself from

00:44:39,109 --> 00:44:43,910
hate light by hand like doing a hand

00:44:40,910 --> 00:44:46,490
written parser that's that's a really

00:44:43,910 --> 00:44:48,460
like tough slog to get through that so I

00:44:46,490 --> 00:44:51,640
would definitely look at the other tool

00:44:48,460 --> 00:44:59,940
all right thank you David okay thank you

00:44:51,640 --> 00:44:59,940

YouTube URL: https://www.youtube.com/watch?v=zJ9z6Ge-vXs


