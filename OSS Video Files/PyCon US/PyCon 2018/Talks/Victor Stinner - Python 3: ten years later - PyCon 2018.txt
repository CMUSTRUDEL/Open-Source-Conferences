Title: Victor Stinner - Python 3: ten years later - PyCon 2018
Publication date: 2018-08-06
Playlist: Talks
Description: 
	Speaker: Victor Stinner

Looking back at Python evolutions over the last 10 years.

Python 3.0 was released ten years ago (December 2008). It's time to look back: analyze the migration from Python 2 to Python 3, see the progress we made on the language, list bugs by cannot be fixed in Python 2 because of the backward compatibility, and discuss if it's time or not to bury Python 2.

Python became the defacto language in the scientific world and the favorite programming language as the first language to learn programming.



Slides can be found at: https://speakerdeck.com/pycon2018 and https://github.com/PyCon/2018-slides
Captions: 
	00:00:01,429 --> 00:00:09,210
okay good afternoon and welcome to

00:00:06,390 --> 00:00:16,440
Python 3 10 years later this is a Viktor

00:00:09,210 --> 00:00:18,359
Steiner give him a welcome thank you so

00:00:16,440 --> 00:00:20,490
hi everybody my name is Victor steena

00:00:18,359 --> 00:00:24,420
and I'm going to talk about Python free

00:00:20,490 --> 00:00:26,910
translator I'm a C Python code

00:00:24,420 --> 00:00:29,670
developers since eight years now I'm

00:00:26,910 --> 00:00:33,120
working on a sepia tone and OpenStack

00:00:29,670 --> 00:00:36,420
for edits working on Python means for

00:00:33,120 --> 00:00:39,809
example review pour requests to to

00:00:36,420 --> 00:00:42,510
triage bugs to to help newcomers to

00:00:39,809 --> 00:00:45,600
mentor people it's been a lot of

00:00:42,510 --> 00:00:49,020
different things and I'm very happy user

00:00:45,600 --> 00:00:51,930
of federal on V I disarray to organize

00:00:49,020 --> 00:00:55,680
my my slides in four parts the four

00:00:51,930 --> 00:00:59,609
seasons on let's start with autumn the

00:00:55,680 --> 00:01:02,789
bath of patent-free was in 2006 with the

00:00:59,609 --> 00:01:06,689
pep 3000 which we which were has been

00:01:02,789 --> 00:01:09,030
called Python 3000 the thing is that at

00:01:06,689 --> 00:01:11,670
this time more people started to

00:01:09,030 --> 00:01:18,020
complain about design issues of Python 2

00:01:11,670 --> 00:01:21,119
which are called Python wats because

00:01:18,020 --> 00:01:24,299
because python 2 was used by more people

00:01:21,119 --> 00:01:27,930
and as I started to complain but also

00:01:24,299 --> 00:01:29,759
because python 2 was modified during the

00:01:27,930 --> 00:01:32,640
development cycle of the pattern to

00:01:29,759 --> 00:01:34,680
branch to give you an example in Python

00:01:32,640 --> 00:01:36,540
2 you have two different types you have

00:01:34,680 --> 00:01:38,909
the small integer and you have the big

00:01:36,540 --> 00:01:40,829
integer on depending on the value

00:01:38,909 --> 00:01:43,500
depending on the operation you may get a

00:01:40,829 --> 00:01:44,970
small or large integer and so if you

00:01:43,500 --> 00:01:46,970
would like to test the type of a

00:01:44,970 --> 00:01:49,470
variable you have to test for both type

00:01:46,970 --> 00:01:52,799
which can be surprising and disturbing

00:01:49,470 --> 00:01:55,200
for newcomers and during the development

00:01:52,799 --> 00:01:57,780
of the Python 2 branch we added a new

00:01:55,200 --> 00:02:00,479
kind of class which is called the new

00:01:57,780 --> 00:02:02,820
class you have to hear it explicitly

00:02:00,479 --> 00:02:05,880
from the object type and if you don't do

00:02:02,820 --> 00:02:09,629
that you get all class and the issue

00:02:05,880 --> 00:02:11,129
with that is that if you don't hynny

00:02:09,629 --> 00:02:13,710
read form objects you get the whole

00:02:11,129 --> 00:02:17,300
class and some Python features like

00:02:13,710 --> 00:02:17,300
these are not working properly

00:02:17,670 --> 00:02:23,880
another example about a patent to issue

00:02:21,080 --> 00:02:26,670
is that when you divide two integrals

00:02:23,880 --> 00:02:30,150
like for example when you divide one by

00:02:26,670 --> 00:02:33,390
two you get an integral zero in the case

00:02:30,150 --> 00:02:35,870
of one by two and again this is

00:02:33,390 --> 00:02:38,790
surprising for newcomers who are used to

00:02:35,870 --> 00:02:42,510
calculators we expect a floating-point

00:02:38,790 --> 00:02:45,900
number like zero point five so it was

00:02:42,510 --> 00:02:49,470
decided to to change that to return a

00:02:45,900 --> 00:02:51,300
float and in Python 2 you already have

00:02:49,470 --> 00:02:53,190
an operator for that which is a double

00:02:51,300 --> 00:02:58,020
slash instead of us you think about

00:02:53,190 --> 00:02:59,700
single stash for for the Unicode I would

00:02:58,020 --> 00:03:02,850
say like everything is fine if your

00:02:59,700 --> 00:03:06,060
application is only speaking a Unicode

00:03:02,850 --> 00:03:07,920
if you only take Unicode as input your

00:03:06,060 --> 00:03:10,890
output is Unicode if everything is

00:03:07,920 --> 00:03:11,370
Unicode your file if you are using only

00:03:10,890 --> 00:03:13,800
bites

00:03:11,370 --> 00:03:15,780
everywhere you're fine but if you have

00:03:13,800 --> 00:03:18,030
some parts of your application which use

00:03:15,780 --> 00:03:21,420
bytes or an other parts which use

00:03:18,030 --> 00:03:24,780
Unicode you may get an exception when

00:03:21,420 --> 00:03:27,420
you pass non-ascii characters and that

00:03:24,780 --> 00:03:30,810
can be annoying because you don't get at

00:03:27,420 --> 00:03:33,120
rent at compilation and you don't get

00:03:30,810 --> 00:03:36,180
the river at the first run it depends

00:03:33,120 --> 00:03:39,840
the contents which can be surprising and

00:03:36,180 --> 00:03:42,900
can be an issue in prediction for the

00:03:39,840 --> 00:03:45,630
comparison in Python 2 we have something

00:03:42,900 --> 00:03:48,000
very strange which is that you can

00:03:45,630 --> 00:03:50,250
compare anything I mean that even if we

00:03:48,000 --> 00:03:53,670
don't implement the comparison operator

00:03:50,250 --> 00:03:56,970
between 24 types Python try something

00:03:53,670 --> 00:03:58,680
for you to return a value anyway for

00:03:56,970 --> 00:04:02,160
example if you compare the number one

00:03:58,680 --> 00:04:05,640
and the string hello a Python will take

00:04:02,160 --> 00:04:09,060
the name of the type like the string int

00:04:05,640 --> 00:04:13,310
and the string STR and compare these two

00:04:09,060 --> 00:04:16,230
strings to decide all to our values and

00:04:13,310 --> 00:04:19,650
the result can be very surprising if you

00:04:16,230 --> 00:04:21,870
are not aware of this choice so we

00:04:19,650 --> 00:04:26,889
wanted to change that to raise on a type

00:04:21,870 --> 00:04:29,830
error in Python 3 and last but not least

00:04:26,889 --> 00:04:32,439
the input in pythons who are relative by

00:04:29,830 --> 00:04:36,069
defaults which which means that if you

00:04:32,439 --> 00:04:37,900
use the same module names and name of a

00:04:36,069 --> 00:04:39,849
module in the standard library you get a

00:04:37,900 --> 00:04:42,490
conflict and you can get you can be very

00:04:39,849 --> 00:04:46,979
surprised by the results so we decided

00:04:42,490 --> 00:04:51,310
to move to absolutes imports by defaults

00:04:46,979 --> 00:04:54,189
so to limit the risk we decided to don't

00:04:51,310 --> 00:04:59,080
break everything only at knowledge wards

00:04:54,189 --> 00:05:00,940
and we also decided to have an open open

00:04:59,080 --> 00:05:04,409
community process for deciding what to

00:05:00,940 --> 00:05:07,590
change in practice it means writing pepp

00:05:04,409 --> 00:05:10,419
with number starting with 3 thousands

00:05:07,590 --> 00:05:13,449
and we didn't want to reemployment the

00:05:10,419 --> 00:05:16,150
interpreter from scratch because if you

00:05:13,449 --> 00:05:18,610
restart to read a new interpreter from

00:05:16,150 --> 00:05:21,969
scratch maybe you will get some scepter

00:05:18,610 --> 00:05:23,860
behavior differences and we we did

00:05:21,969 --> 00:05:28,479
wanted to limit the number of

00:05:23,860 --> 00:05:31,120
incompatible changes and finally to to

00:05:28,479 --> 00:05:33,639
announce to everybody that's say we love

00:05:31,120 --> 00:05:38,759
to do something we plan at the end of

00:05:33,639 --> 00:05:44,560
life of pattern 2 from the beginning and

00:05:38,759 --> 00:05:50,080
in finally in 2008 so Holy Grail item

00:05:44,560 --> 00:05:54,129
free we got it at the beginning we had a

00:05:50,080 --> 00:05:56,800
first migration plan which was very very

00:05:54,129 --> 00:05:59,349
obvious Python free comes with an

00:05:56,800 --> 00:06:02,289
application called - - free to port your

00:05:59,349 --> 00:06:05,259
application from Python - to Python free

00:06:02,289 --> 00:06:09,610
and the migration is done at once so you

00:06:05,259 --> 00:06:11,589
you run the program you're done but

00:06:09,610 --> 00:06:15,009
maybe if we are still here discussing a

00:06:11,589 --> 00:06:18,909
Python free 10 years later maybe it

00:06:15,009 --> 00:06:22,150
wasn't the best idea because in wrapping

00:06:18,909 --> 00:06:25,210
patent truth report was a no-go it means

00:06:22,150 --> 00:06:27,849
that when you are the maintainer of a

00:06:25,210 --> 00:06:31,750
module maybe you don't want to lose all

00:06:27,849 --> 00:06:34,899
your user base because when python 3 has

00:06:31,750 --> 00:06:37,930
been released many linux distribution

00:06:34,899 --> 00:06:40,129
for example didn'ts provided python free

00:06:37,930 --> 00:06:45,739
so it means that if you lose

00:06:40,129 --> 00:06:49,999
Python to support you lose your user and

00:06:45,739 --> 00:06:53,239
I don't know what it means another issue

00:06:49,999 --> 00:06:55,429
about porting code is that if you have

00:06:53,239 --> 00:06:58,429
dependencies on your application and a

00:06:55,429 --> 00:07:00,830
single dependency in all dependencies is

00:06:58,429 --> 00:07:02,689
not compatible with patent-free you are

00:07:00,830 --> 00:07:04,969
not able to run your application because

00:07:02,689 --> 00:07:08,869
you will get a syntax error or something

00:07:04,969 --> 00:07:10,909
else so you really have to first work on

00:07:08,869 --> 00:07:15,379
differences and if you have many of them

00:07:10,909 --> 00:07:18,409
in cat can take a lot of time and the

00:07:15,379 --> 00:07:20,959
final point is that we knew that Python

00:07:18,409 --> 00:07:24,379
2y was used but we didn't know that it

00:07:20,959 --> 00:07:27,319
was so heavily in production so it's

00:07:24,379 --> 00:07:27,949
mean that we when it's used in

00:07:27,319 --> 00:07:30,649
production

00:07:27,949 --> 00:07:35,719
it takes a lot more lot longer to to

00:07:30,649 --> 00:07:38,899
magic to move the code another issue

00:07:35,719 --> 00:07:41,029
about the migration to Python 3 it's

00:07:38,899 --> 00:07:43,339
something called the technical depth so

00:07:41,029 --> 00:07:45,050
image in that you have your discuss you

00:07:43,339 --> 00:07:48,169
are developer you're discussing of your

00:07:45,050 --> 00:07:50,089
manager and your manager asked why

00:07:48,169 --> 00:07:53,209
should I let you walk on Python free

00:07:50,089 --> 00:07:54,889
supports on the developer o for all

00:07:53,209 --> 00:07:59,449
these new cool Python free features

00:07:54,889 --> 00:08:04,039
obviously ok but can we use those

00:07:59,449 --> 00:08:08,110
features as a developer one since we

00:08:04,039 --> 00:08:11,689
still have supports spaten - nope

00:08:08,110 --> 00:08:16,029
this means that it's really difficult to

00:08:11,689 --> 00:08:18,649
explain to a manager 1 what is it depth

00:08:16,029 --> 00:08:20,839
because you don't give a new value

00:08:18,649 --> 00:08:25,519
immediately it's something that you will

00:08:20,839 --> 00:08:29,709
get longer nobody knows when because we

00:08:25,519 --> 00:08:29,709
are still discussing support in Python 2

00:08:29,919 --> 00:08:36,169
and when you would like to put your code

00:08:32,750 --> 00:08:38,000
patent-free you you may want to use two

00:08:36,169 --> 00:08:40,490
different branches in your source

00:08:38,000 --> 00:08:42,439
control management like it's for example

00:08:40,490 --> 00:08:45,680
one branch for python 2 rain branch for

00:08:42,439 --> 00:08:48,589
python free or maybe another choice is

00:08:45,680 --> 00:08:51,649
to really split as a repository to fork

00:08:48,589 --> 00:08:52,760
the repository and some project has been

00:08:51,649 --> 00:08:54,890


00:08:52,760 --> 00:08:57,890
- as the Python free supports for

00:08:54,890 --> 00:09:01,690
example the DNS Python module has been

00:08:57,890 --> 00:09:06,440
 as a new name DNS Python free

00:09:01,690 --> 00:09:08,540
sometimes upstream like PL doesn't care

00:09:06,440 --> 00:09:11,900
of bitin Python free for different

00:09:08,540 --> 00:09:13,760
reason so the community decided to focus

00:09:11,900 --> 00:09:16,490
with this project pillar under a new

00:09:13,760 --> 00:09:18,590
name which is pilau so then not only is

00:09:16,490 --> 00:09:22,760
a ported the code to Python free but I

00:09:18,590 --> 00:09:25,070
also added new features and in the worst

00:09:22,760 --> 00:09:27,470
case at the upstream simply doesn't

00:09:25,070 --> 00:09:30,740
reply as I don't read issues I don't

00:09:27,470 --> 00:09:33,170
read pull requests they don't it's

00:09:30,740 --> 00:09:36,050
basically dead but you still depend on

00:09:33,170 --> 00:09:38,300
this very important the dependency for

00:09:36,050 --> 00:09:41,030
example I'm working OpenStack and on the

00:09:38,300 --> 00:09:44,360
OpenStack we use the favorite database

00:09:41,030 --> 00:09:47,210
in my sequel and to access my sequel we

00:09:44,360 --> 00:09:50,150
used my sequel Python driver but this

00:09:47,210 --> 00:09:50,810
one didn't support bite onto a Python

00:09:50,150 --> 00:09:55,190
free sorry

00:09:50,810 --> 00:09:57,380
so someone my my sequel Python

00:09:55,190 --> 00:09:59,330
under a new name which is my sick my

00:09:57,380 --> 00:10:02,300
sequel clients to add Python free

00:09:59,330 --> 00:10:08,030
support and what new features and to fix

00:10:02,300 --> 00:10:10,670
bugs but we got some issue because about

00:10:08,030 --> 00:10:13,430
the packaging of the module it's a

00:10:10,670 --> 00:10:16,160
different name so we don't know what is

00:10:13,430 --> 00:10:19,160
a new upstream because for example maybe

00:10:16,160 --> 00:10:22,280
the the previous maintainer we will wake

00:10:19,160 --> 00:10:27,800
up and continues the developments we got

00:10:22,280 --> 00:10:29,810
a lot of troubles because of that so to

00:10:27,800 --> 00:10:33,650
explain you other issues that we had is

00:10:29,810 --> 00:10:36,170
that when python 3.0 has been released

00:10:33,650 --> 00:10:41,360
the real stable version of python who

00:10:36,170 --> 00:10:43,430
was python 2.6 and this version requires

00:10:41,360 --> 00:10:46,160
a lot of changes when you would like to

00:10:43,430 --> 00:10:49,430
write a single code base for python 2

00:10:46,160 --> 00:10:52,160
and python 3 there is something very

00:10:49,430 --> 00:10:54,770
convenient which is a 6 module it's a

00:10:52,160 --> 00:10:57,860
module which behaves the same on python

00:10:54,770 --> 00:10:59,510
to n-pentane free but it's use the

00:10:57,860 --> 00:11:02,540
implementation is different depending on

00:10:59,510 --> 00:11:05,180
the Python version and yeah when you use

00:11:02,540 --> 00:11:05,760
Python 2.6 you have to annotate a lot of

00:11:05,180 --> 00:11:09,300
code

00:11:05,760 --> 00:11:11,580
to using six and if you really want to

00:11:09,300 --> 00:11:13,410
use new Python free features and Python

00:11:11,580 --> 00:11:16,590
- you have to use something called back

00:11:13,410 --> 00:11:20,070
ports and in Python 2.6 you need a lot

00:11:16,590 --> 00:11:21,180
of them because we added some Python

00:11:20,070 --> 00:11:26,460
free features on

00:11:21,180 --> 00:11:30,530
- that's 2.7 but 3.6 was still a stable

00:11:26,460 --> 00:11:33,360
version now about the specific case of a

00:11:30,530 --> 00:11:36,780
Unicode string which is a string with

00:11:33,360 --> 00:11:40,370
the prefix you you had to annotate it

00:11:36,780 --> 00:11:43,440
with a function called a6 dot u because

00:11:40,370 --> 00:11:46,080
if you use the Euro prefix you get on

00:11:43,440 --> 00:11:52,320
syntax a wall until Python free that

00:11:46,080 --> 00:11:58,440
Frida - so after the episodes out on

00:11:52,320 --> 00:12:02,720
comes it's called winter and we will

00:11:58,440 --> 00:12:05,760
start with the Python free wall of shame

00:12:02,720 --> 00:12:09,000
this website has been created by someone

00:12:05,760 --> 00:12:11,520
who wanted not to blame

00:12:09,000 --> 00:12:14,700
Monty know but it was an attempt to

00:12:11,520 --> 00:12:17,520
motivate packing package maintainer to

00:12:14,700 --> 00:12:20,970
post the code to pattern free and when

00:12:17,520 --> 00:12:25,260
the website has been launched in 2011 we

00:12:20,970 --> 00:12:28,940
only had nine percent of the top 200

00:12:25,260 --> 00:12:32,760
projects compatible with pattern free

00:12:28,940 --> 00:12:35,490
and I identify three big players in the

00:12:32,760 --> 00:12:38,610
Python community which are twisted

00:12:35,490 --> 00:12:41,610
mercurial and Django twisted is a

00:12:38,610 --> 00:12:44,400
framework for networking clients but

00:12:41,610 --> 00:12:47,580
also networking service to write a

00:12:44,400 --> 00:12:50,390
synchronous code mercurial is a source

00:12:47,580 --> 00:12:54,210
control management seminar to get and

00:12:50,390 --> 00:12:56,820
Django is a very very famous framework

00:12:54,210 --> 00:12:59,340
for web application it's a Nora Webb

00:12:56,820 --> 00:13:01,820
templating and join and everything that

00:12:59,340 --> 00:13:04,470
you need to breed your web application

00:13:01,820 --> 00:13:06,840
so depending on the project we had

00:13:04,470 --> 00:13:10,500
different issues for twisted and

00:13:06,840 --> 00:13:12,600
Mercurian they they work at the low

00:13:10,500 --> 00:13:16,080
level for example twisted you are

00:13:12,600 --> 00:13:18,480
working on on the network so on sockets

00:13:16,080 --> 00:13:19,320
and at the circuit level you don't get

00:13:18,480 --> 00:13:22,470
Unicode

00:13:19,320 --> 00:13:27,810
you get is only bytes so for this reason

00:13:22,470 --> 00:13:31,020
twisted is an have an heavy used usage

00:13:27,810 --> 00:13:33,660
of bytes and for the case of mercury on

00:13:31,020 --> 00:13:36,120
mercury decided to use bytes for the

00:13:33,660 --> 00:13:39,210
file contents but also for the file file

00:13:36,120 --> 00:13:41,670
name and for this reason it's much more

00:13:39,210 --> 00:13:44,510
difficult to move this application to

00:13:41,670 --> 00:13:47,070
Python free because in Python freeze of

00:13:44,510 --> 00:13:50,040
Unicode is a falsities and class type

00:13:47,070 --> 00:13:54,630
and using Bad's it's it's more

00:13:50,040 --> 00:13:57,690
complicated and about Django they they

00:13:54,630 --> 00:14:00,950
add a partial support of Unicode but it

00:13:57,690 --> 00:14:04,470
was still incomplete at this time

00:14:00,950 --> 00:14:07,470
because of all this issue that that I

00:14:04,470 --> 00:14:11,220
just described we started to see

00:14:07,470 --> 00:14:14,100
something on the on the internet on

00:14:11,220 --> 00:14:16,800
farms on mailing lists which are chords

00:14:14,100 --> 00:14:21,720
not the French but the Python free

00:14:16,800 --> 00:14:23,940
throws because of all these issues the

00:14:21,720 --> 00:14:26,460
trolls consider that's pattern tree

00:14:23,940 --> 00:14:28,680
doesn't bring anything because I as I

00:14:26,460 --> 00:14:31,470
explained with a dialogue between the

00:14:28,680 --> 00:14:33,300
maintainer on the developer even if you

00:14:31,470 --> 00:14:35,130
move your code to Python free you still

00:14:33,300 --> 00:14:38,880
have to support Python 2 and at the end

00:14:35,130 --> 00:14:42,120
you cannot use new features and Python

00:14:38,880 --> 00:14:45,090
free according to the trolls introduce

00:14:42,120 --> 00:14:47,400
new Unicode issues because if you

00:14:45,090 --> 00:14:50,720
consider on a Python 2 application with

00:14:47,400 --> 00:14:53,310
which only use bites for for everything

00:14:50,720 --> 00:14:56,160
you never care about the anchoring you

00:14:53,310 --> 00:14:58,530
can get one encoding and you can you can

00:14:56,160 --> 00:15:01,020
get a different encoding if you merge

00:14:58,530 --> 00:15:05,490
the two texts you may be some user will

00:15:01,020 --> 00:15:07,980
complain but at the end is it's ok it's

00:15:05,490 --> 00:15:13,130
not a big deal so according to them so

00:15:07,980 --> 00:15:16,230
using bites it with just simpler and

00:15:13,130 --> 00:15:21,090
after after the descriptions I came up

00:15:16,230 --> 00:15:24,480
to to a new ID ok so maybe maybe there

00:15:21,090 --> 00:15:27,030
are still a lot of Python to users maybe

00:15:24,480 --> 00:15:30,810
we can just continue the development

00:15:27,030 --> 00:15:32,680
apply of Python tool because we we can

00:15:30,810 --> 00:15:37,629
add new features we can

00:15:32,680 --> 00:15:41,009
projects and I in 2014 there was an

00:15:37,629 --> 00:15:44,259
article on Linux weekly news saying that

00:15:41,009 --> 00:15:49,449
we are still debating a transition our

00:15:44,259 --> 00:15:51,689
python 2.8 so the concern that that was

00:15:49,449 --> 00:15:55,420
that Python free would never take off

00:15:51,689 --> 00:16:00,629
because according to them the path of

00:15:55,420 --> 00:16:04,720
free only represents 2% of packages and

00:16:00,629 --> 00:16:08,079
to to count down the strolls what we did

00:16:04,720 --> 00:16:11,470
is to to make it very very explicit that

00:16:08,079 --> 00:16:15,040
that Python freed 2.8 is not going to

00:16:11,470 --> 00:16:19,480
happen so in 2011 we brought our pep

00:16:15,040 --> 00:16:23,379
called the Python hooded to detain on

00:16:19,480 --> 00:16:27,939
release schedule it's a pep number 400

00:16:23,379 --> 00:16:30,069
for the pep not found and in the fact

00:16:27,939 --> 00:16:32,050
and in fact it's not 2 percent of

00:16:30,069 --> 00:16:35,379
project which were compatible with

00:16:32,050 --> 00:16:38,529
pattern 3 it was closer to 80 percent if

00:16:35,379 --> 00:16:43,899
you only look at the top 50 project on

00:16:38,529 --> 00:16:46,629
PI API and in in my opinion the best

00:16:43,899 --> 00:16:49,629
thing that we did in the world pattern

00:16:46,629 --> 00:16:52,240
free mess was that the last item is that

00:16:49,629 --> 00:16:55,689
in 2014

00:16:52,240 --> 00:16:58,240
guido van rossum at PyCon us unknown

00:16:55,689 --> 00:17:02,350
said that we will extend as a byte those

00:16:58,240 --> 00:17:06,189
reports of Python 2.7 from 5 years to 10

00:17:02,350 --> 00:17:08,949
years this is very various a strong

00:17:06,189 --> 00:17:11,230
signal to Python to users because we do

00:17:08,949 --> 00:17:13,209
not want to blame anyone we didn't want

00:17:11,230 --> 00:17:16,120
to force people to move immediately to

00:17:13,209 --> 00:17:18,939
Python free we know that when you are

00:17:16,120 --> 00:17:22,029
working for a huge company with a giant

00:17:18,939 --> 00:17:24,250
pile of code you you need more time to

00:17:22,029 --> 00:17:27,279
port code you you have a lot of

00:17:24,250 --> 00:17:29,770
practical issues so the message was that

00:17:27,279 --> 00:17:30,549
we still support Python 2 we are still

00:17:29,770 --> 00:17:32,740
fixing bugs

00:17:30,549 --> 00:17:41,260
we are still fixing security issues and

00:17:32,740 --> 00:17:42,440
we will do that until 2020 does the cold

00:17:41,260 --> 00:17:45,260
winter

00:17:42,440 --> 00:17:50,510
we get the fresh air of the Sprint's

00:17:45,260 --> 00:17:54,740
with Florence and the first very good

00:17:50,510 --> 00:17:57,950
news is that we fixed our our first

00:17:54,740 --> 00:17:59,780
issue and what is the first issue is

00:17:57,950 --> 00:18:03,410
that when you wanted to install

00:17:59,780 --> 00:18:05,180
something in Python the question was how

00:18:03,410 --> 00:18:08,330
to install a dependency and the answer

00:18:05,180 --> 00:18:11,690
was install set of tools but how should

00:18:08,330 --> 00:18:14,030
I install a set of tools and you had to

00:18:11,690 --> 00:18:17,210
go to a specific website download our

00:18:14,030 --> 00:18:20,860
scripts you have to stress the website

00:18:17,210 --> 00:18:23,810
and it was difficult to find setup tools

00:18:20,860 --> 00:18:25,820
like we got a fork of separate tools

00:18:23,810 --> 00:18:30,470
which was which was called distribute so

00:18:25,820 --> 00:18:33,680
we got a lot of issues but in 2011 peep

00:18:30,470 --> 00:18:37,150
1.0 has been released and three years

00:18:33,680 --> 00:18:40,550
later we included a module in a Python

00:18:37,150 --> 00:18:43,310
2009 and pattern free 4 which is not

00:18:40,550 --> 00:18:47,930
really people itself it's an internal to

00:18:43,310 --> 00:18:50,120
install pipe and thanks to this slowly

00:18:47,930 --> 00:18:54,410
people became the de facto installer for

00:18:50,120 --> 00:18:56,690
for Python so we the newcomer did not

00:18:54,410 --> 00:18:58,880
have to ask how to install some things

00:18:56,690 --> 00:19:02,330
in the answer was obvious its know

00:18:58,880 --> 00:19:04,940
people and know the Linux distribution

00:19:02,330 --> 00:19:06,950
started to ship directly pip so you

00:19:04,940 --> 00:19:12,470
don't have to care about how to get

00:19:06,950 --> 00:19:14,870
people ready in your system to put your

00:19:12,470 --> 00:19:18,680
code to Python free we saw that the

00:19:14,870 --> 00:19:21,830
first approach didn't work so we came to

00:19:18,680 --> 00:19:25,520
a new approach which is to stop

00:19:21,830 --> 00:19:28,130
promoting 2 to 3 which removes the

00:19:25,520 --> 00:19:30,440
Python 2 supports the new approach is

00:19:28,130 --> 00:19:33,950
very simple is to add Python free

00:19:30,440 --> 00:19:36,140
supports and when I say that today maybe

00:19:33,950 --> 00:19:37,970
it's obvious for everybody that's it's a

00:19:36,140 --> 00:19:40,760
wise way to do that but you have to

00:19:37,970 --> 00:19:43,010
understand that it took us a long long

00:19:40,760 --> 00:19:47,120
time to understand that we have a huge

00:19:43,010 --> 00:19:49,100
user base which I am where we are good

00:19:47,120 --> 00:19:51,710
reason to not move in a likely to Python

00:19:49,100 --> 00:19:53,970
free so it took us a lot of time to

00:19:51,710 --> 00:19:59,580
write new tooling to write new

00:19:53,970 --> 00:20:02,700
Brooks to explain that and for examples

00:19:59,580 --> 00:20:04,800
there is a six modular which has been

00:20:02,700 --> 00:20:07,230
created but also new tools like

00:20:04,800 --> 00:20:09,660
modernize on siksa which are tools to

00:20:07,230 --> 00:20:14,010
put your Python 2 code days to pattern

00:20:09,660 --> 00:20:16,950
free and the story behind 6 huh

00:20:14,010 --> 00:20:19,320
isn't this is my own tool is that I

00:20:16,950 --> 00:20:22,440
would I wanted to post OpenStack to

00:20:19,320 --> 00:20:26,550
Python free but reports free minions

00:20:22,440 --> 00:20:28,830
lines of code at once you get those

00:20:26,550 --> 00:20:33,090
different issues because in OpenStack

00:20:28,830 --> 00:20:35,760
the code was moving very quickly and if

00:20:33,090 --> 00:20:37,950
you use something like modernize to put

00:20:35,760 --> 00:20:41,040
your a single project to pattern free

00:20:37,950 --> 00:20:43,320
you get a giant patch and quickly the

00:20:41,040 --> 00:20:47,220
patch will be in conflict so you have to

00:20:43,320 --> 00:20:49,020
rebase or regenerate the patch so it's a

00:20:47,220 --> 00:20:53,220
nightmare to get a review on a such

00:20:49,020 --> 00:20:55,320
patch it shows a different approach the

00:20:53,220 --> 00:20:57,390
idea is that you apply a single change

00:20:55,320 --> 00:20:59,940
for example just add parentheses to the

00:20:57,390 --> 00:21:03,960
print statements and by doing that you

00:20:59,940 --> 00:21:06,750
get a much slower much shorter patch

00:21:03,960 --> 00:21:09,810
it's easier to review because it's only

00:21:06,750 --> 00:21:12,270
apply a single kind of change and thanks

00:21:09,810 --> 00:21:15,510
to rats I was able to port OpenStack to

00:21:12,270 --> 00:21:18,300
Python free and the other advantage of

00:21:15,510 --> 00:21:22,380
this rural approach of adding supports

00:21:18,300 --> 00:21:25,500
on not removing supports is that you can

00:21:22,380 --> 00:21:27,960
do it of one file after the other or you

00:21:25,500 --> 00:21:30,960
can apply one specific change and then

00:21:27,960 --> 00:21:35,520
after the other and each change can be

00:21:30,960 --> 00:21:40,320
tested by the CI so you you can do it in

00:21:35,520 --> 00:21:42,240
multiple mounts it's fine if you have a

00:21:40,320 --> 00:21:45,510
very large code base maybe you have some

00:21:42,240 --> 00:21:49,140
different issues for legacy code base

00:21:45,510 --> 00:21:51,330
one solution is first to to write new

00:21:49,140 --> 00:21:54,030
tests because you may know that in

00:21:51,330 --> 00:21:56,130
companies people like to put new

00:21:54,030 --> 00:21:58,980
features but not to spend time on tests

00:21:56,130 --> 00:22:02,250
or maybe the culture of the company is

00:21:58,980 --> 00:22:04,950
not to write new tests and thanks to

00:22:02,250 --> 00:22:06,460
test you are able to reduce the number

00:22:04,950 --> 00:22:09,879
of regressions

00:22:06,460 --> 00:22:12,999
and another approach tested by Dropbox

00:22:09,879 --> 00:22:16,240
is to annotate the type of the function

00:22:12,999 --> 00:22:19,960
parameters using a tool called my PI

00:22:16,240 --> 00:22:22,419
it's a static analyzer for the types and

00:22:19,960 --> 00:22:26,259
they are also working on the typing

00:22:22,419 --> 00:22:29,440
which is a standard way to describe the

00:22:26,259 --> 00:22:32,649
types for annotations and thanks to that

00:22:29,440 --> 00:22:36,659
the as I plan to ports something like

00:22:32,649 --> 00:22:36,659
five million lines of code Python free

00:22:37,860 --> 00:22:45,100
in addition to all the previous parts is

00:22:42,460 --> 00:22:48,220
that we are also building bridges

00:22:45,100 --> 00:22:51,369
between Python tube and Python free to

00:22:48,220 --> 00:22:54,070
Mexico transition simpler for example

00:22:51,369 --> 00:22:57,730
Python feeded free introduced as the you

00:22:54,070 --> 00:23:00,220
prefix for unicode strings which avoids

00:22:57,730 --> 00:23:03,249
to annotate each string using the six

00:23:00,220 --> 00:23:07,330
that you function which was a no-go for

00:23:03,249 --> 00:23:09,279
many maintenance python 3.7 adds bytes

00:23:07,330 --> 00:23:13,059
for motto which is very important for

00:23:09,279 --> 00:23:16,240
projects like twisted or mercurial but

00:23:13,059 --> 00:23:19,690
in Python 2 we also added new warnings

00:23:16,240 --> 00:23:22,539
new Python 3 warnings and the cool thing

00:23:19,690 --> 00:23:24,909
with that is that even if you don't

00:23:22,539 --> 00:23:27,190
start to put your code to Python free

00:23:24,909 --> 00:23:29,499
you can already take a look at all these

00:23:27,190 --> 00:23:31,899
warnings and you can already start to

00:23:29,499 --> 00:23:36,159
fix these warnings before starting the

00:23:31,899 --> 00:23:39,220
real emigration and in parallel we got

00:23:36,159 --> 00:23:41,649
more and more back ports which allows

00:23:39,220 --> 00:23:46,119
you to use new pattern Python free

00:23:41,649 --> 00:23:48,639
features and pi2 in python free so in

00:23:46,119 --> 00:23:53,529
consequence you you can use pattern free

00:23:48,639 --> 00:23:59,019
in practice and after the spring comes

00:23:53,529 --> 00:24:04,119
some time so to come back to my previous

00:23:59,019 --> 00:24:06,399
slide about the wall of shame the author

00:24:04,119 --> 00:24:09,909
of the website change the title of the

00:24:06,399 --> 00:24:13,899
page from the world of shame to war of

00:24:09,909 --> 00:24:16,960
superpower and the good thing is that we

00:24:13,899 --> 00:24:19,720
are we are almost as when and read

00:24:16,960 --> 00:24:22,810
percent of top

00:24:19,720 --> 00:24:26,980
200 projects compatible with Python free

00:24:22,810 --> 00:24:29,440
it's not exactly a 100% because in this

00:24:26,980 --> 00:24:32,110
list you have a lot of you have 10

00:24:29,440 --> 00:24:35,920
project which has been deprecated or

00:24:32,110 --> 00:24:39,910
replaced by a different solution so we I

00:24:35,920 --> 00:24:41,920
think we are good for this modules the

00:24:39,910 --> 00:24:45,130
other good news is that Python free is

00:24:41,920 --> 00:24:48,460
finally faster than Python 2 on this

00:24:45,130 --> 00:24:51,670
graphic you can see that all result are

00:24:48,460 --> 00:24:54,700
normalized to Python 2 and if something

00:24:51,670 --> 00:24:58,630
is below a range line it means that

00:24:54,700 --> 00:25:01,750
python free is faster so on this graphic

00:24:58,630 --> 00:25:06,150
I showed the benchmark where panel

00:25:01,750 --> 00:25:12,040
Python free is the most faster most fast

00:25:06,150 --> 00:25:14,860
fastest and there is just one case where

00:25:12,040 --> 00:25:17,740
Python free still slower its startup

00:25:14,860 --> 00:25:21,610
time but we are working on that issue

00:25:17,740 --> 00:25:25,540
oh and something else other good news is

00:25:21,610 --> 00:25:27,850
that pattern 3.7 is coming next month in

00:25:25,540 --> 00:25:32,560
a few months and it's already faster

00:25:27,850 --> 00:25:36,160
than 3.6 to give you an another number

00:25:32,560 --> 00:25:39,580
of performances as the Instagram company

00:25:36,160 --> 00:25:43,180
moved the application projections from

00:25:39,580 --> 00:25:47,020
Python 2 to Python 3 as I reduced the

00:25:43,180 --> 00:25:54,940
CPU usage by 12% on the memory usage

00:25:47,020 --> 00:25:56,830
they saved 30% okay if you if you didn't

00:25:54,940 --> 00:26:00,970
follow the development on pattern free

00:25:56,830 --> 00:26:04,300
this is a quick recap of python 2 issues

00:26:00,970 --> 00:26:06,430
and what we got in python free first

00:26:04,300 --> 00:26:09,700
what you have to know that since python

00:26:06,430 --> 00:26:12,850
2 is used for a long time we we know

00:26:09,700 --> 00:26:15,250
more and more birds the the list of

00:26:12,850 --> 00:26:17,560
known bugs is growing and for some

00:26:15,250 --> 00:26:19,330
reason we cannot fix some issues because

00:26:17,560 --> 00:26:22,180
of the thing called backward

00:26:19,330 --> 00:26:26,560
compatibility to give you a concrete

00:26:22,180 --> 00:26:28,930
example the Unicode supports maybe maybe

00:26:26,560 --> 00:26:32,380
we couldn't do something bite onto to

00:26:28,930 --> 00:26:33,370
raise an exception if you merge a string

00:26:32,380 --> 00:26:36,220
of bytes honest

00:26:33,370 --> 00:26:38,220
of Unicode but we decided to not touch

00:26:36,220 --> 00:26:42,690
this part because it would break like

00:26:38,220 --> 00:26:42,690
all application is in the world

00:26:42,880 --> 00:26:49,390
another example is it's an attack on the

00:26:46,480 --> 00:26:53,410
dictionary type when you generate very

00:26:49,390 --> 00:26:56,710
specific inputs you can make python much

00:26:53,410 --> 00:26:59,890
slower and so crash a server on

00:26:56,710 --> 00:27:02,860
prediction we fix the issue in Python

00:26:59,890 --> 00:27:06,460
free but in Python sue even if we

00:27:02,860 --> 00:27:09,100
implemented the solution to prevent this

00:27:06,460 --> 00:27:12,730
issue which is called ash function or

00:27:09,100 --> 00:27:16,360
error minimization we couldn't enable

00:27:12,730 --> 00:27:20,020
the the fix by default because it would

00:27:16,360 --> 00:27:23,590
break the backward compatibility and

00:27:20,020 --> 00:27:25,660
after that you start want a very dark

00:27:23,590 --> 00:27:28,750
place which are which are called the

00:27:25,660 --> 00:27:31,270
race condition this kind of bug are very

00:27:28,750 --> 00:27:35,110
very annoying very difficult to

00:27:31,270 --> 00:27:37,210
reproduce it means that usually you use

00:27:35,110 --> 00:27:39,220
so it's very frequently non prediction

00:27:37,210 --> 00:27:43,240
but you cannot reproduce it on your

00:27:39,220 --> 00:27:45,730
development laptop one example is a

00:27:43,240 --> 00:27:49,120
subprocess module which is not thread

00:27:45,730 --> 00:27:51,550
safe which means that if you spawn a sir

00:27:49,120 --> 00:27:54,700
process and your application in two

00:27:51,550 --> 00:27:57,960
different threads maybe you will get a

00:27:54,700 --> 00:28:00,670
crash you have to be aware of that

00:27:57,960 --> 00:28:03,340
another example are the recursive lock

00:28:00,670 --> 00:28:06,430
they are not senior safe which means

00:28:03,340 --> 00:28:08,020
that if you spawn as a process when the

00:28:06,430 --> 00:28:10,780
sub process completes you get a

00:28:08,020 --> 00:28:13,900
notification as a unique senior and this

00:28:10,780 --> 00:28:19,120
may may make the recursive lock

00:28:13,900 --> 00:28:22,450
inconsistent and one last example is

00:28:19,120 --> 00:28:25,900
that python use internally clocks for

00:28:22,450 --> 00:28:29,770
different operation like timeouts and we

00:28:25,900 --> 00:28:32,890
are using the system clock which which

00:28:29,770 --> 00:28:34,540
caused some troubles when if the system

00:28:32,890 --> 00:28:37,030
and administrator change the system

00:28:34,540 --> 00:28:39,910
system clock your application may be

00:28:37,030 --> 00:28:42,880
stuck for one hour or may crash we don't

00:28:39,910 --> 00:28:44,640
know but the good news is that we

00:28:42,880 --> 00:28:47,090
already fixed all these issues should

00:28:44,640 --> 00:28:49,910
just just upgrades of Python

00:28:47,090 --> 00:28:52,130
free and it will be good for example in

00:28:49,910 --> 00:28:55,250
pattern free dirt free we added a new

00:28:52,130 --> 00:28:59,840
monotonic function it is used internally

00:28:55,250 --> 00:29:02,120
to implement timeouts and the good thing

00:28:59,840 --> 00:29:05,560
with Patton free is that since the user

00:29:02,120 --> 00:29:08,870
base is a smaller and since it's it's

00:29:05,560 --> 00:29:12,610
seen as a newer project we are allowed

00:29:08,870 --> 00:29:15,200
to do incompatible changes because

00:29:12,610 --> 00:29:19,970
python 2 is seen as something like super

00:29:15,200 --> 00:29:22,820
stable and nobody wants to break it but

00:29:19,970 --> 00:29:26,150
part of pattern free it's it's kind of

00:29:22,820 --> 00:29:28,520
ok if you limit to really if you are

00:29:26,150 --> 00:29:31,840
able to limit the risk to give you a

00:29:28,520 --> 00:29:35,300
concrete example in Python 3.4 we change

00:29:31,840 --> 00:29:38,900
the file descriptor to make them non

00:29:35,300 --> 00:29:42,740
inevitable by default which which means

00:29:38,900 --> 00:29:45,770
that if you use fork plus exact by

00:29:42,740 --> 00:29:48,170
default you will not inherit open file

00:29:45,770 --> 00:29:50,960
descriptor this is very important in

00:29:48,170 --> 00:29:54,050
term of security because if you open a

00:29:50,960 --> 00:29:56,810
file like your secret password on spawn

00:29:54,050 --> 00:30:00,080
or sub process in Python tool if you use

00:29:56,810 --> 00:30:02,690
a for pearls reduce plus exact you will

00:30:00,080 --> 00:30:05,420
enrich the sensitive file you can also

00:30:02,690 --> 00:30:08,330
imagine the case of a very important a

00:30:05,420 --> 00:30:10,720
network connection again you inherit the

00:30:08,330 --> 00:30:13,040
open connection is it's a process it's

00:30:10,720 --> 00:30:17,540
not really what you expect when you

00:30:13,040 --> 00:30:21,080
spawn a new process in Python 3.5 we

00:30:17,540 --> 00:30:23,510
change how we understand yours it's a

00:30:21,080 --> 00:30:26,780
little bit more more technical is that

00:30:23,510 --> 00:30:30,050
if you application gets a unique senior

00:30:26,780 --> 00:30:34,820
by default system call is interrupted

00:30:30,050 --> 00:30:36,020
and you get anymore in Python 2 you use

00:30:34,820 --> 00:30:38,570
the function calls

00:30:36,020 --> 00:30:42,890
Gaetano so you add to loop yourself

00:30:38,570 --> 00:30:46,220
until you there is no more exception but

00:30:42,890 --> 00:30:48,310
in python 3.5 what we did is that if the

00:30:46,220 --> 00:30:51,440
signal Angela doesn't raise an exception

00:30:48,310 --> 00:30:54,650
we retry the function call for you

00:30:51,440 --> 00:30:56,930
so you don't have to do anything so it

00:30:54,650 --> 00:30:59,399
makes your application safer and more

00:30:56,930 --> 00:31:01,909
reliable

00:30:59,399 --> 00:31:05,519
to explain the idea of breaking

00:31:01,909 --> 00:31:08,999
comfortability guido van rossum routes

00:31:05,519 --> 00:31:11,759
when he approved my pap for non

00:31:08,999 --> 00:31:14,309
heritable file descriptor we are aware

00:31:11,759 --> 00:31:16,919
of the code breakage this is likely to

00:31:14,309 --> 00:31:24,330
cause and doing it anyway for the good

00:31:16,919 --> 00:31:27,029
of mankind and again about spasm free

00:31:24,330 --> 00:31:29,909
you have to know that we added a lot of

00:31:27,029 --> 00:31:33,269
new features just to give you a another

00:31:29,909 --> 00:31:36,690
view we added not less than 21 new

00:31:33,269 --> 00:31:40,169
models that's a lot I will not read the

00:31:36,690 --> 00:31:42,450
full list but to give you some examples

00:31:40,169 --> 00:31:44,940
there is a sink i/o which is a great

00:31:42,450 --> 00:31:47,639
module to write a synchronous code using

00:31:44,940 --> 00:31:50,940
a sink on our weight keywords there is a

00:31:47,639 --> 00:31:55,309
innum ennum type there is a path Lib

00:31:50,940 --> 00:31:57,899
which is very very popular - under path

00:31:55,309 --> 00:32:00,389
there is also the very useful and you

00:31:57,899 --> 00:32:02,580
need test dot mock if you don't know it

00:32:00,389 --> 00:32:06,330
if you don't know this one please and

00:32:02,580 --> 00:32:08,999
try it's really helpful to to write

00:32:06,330 --> 00:32:13,499
nearly tests and limit dependencies on

00:32:08,999 --> 00:32:15,869
the other part of your code so not only

00:32:13,499 --> 00:32:17,609
we added new features to the stock

00:32:15,869 --> 00:32:21,059
library but we also modified the

00:32:17,609 --> 00:32:23,369
language we added new features for

00:32:21,059 --> 00:32:26,820
example in 3.6 we added something called

00:32:23,369 --> 00:32:29,339
F string and in my opinion this is just

00:32:26,820 --> 00:32:32,279
the best way to format a string because

00:32:29,339 --> 00:32:35,070
it's very short it's very obvious when

00:32:32,279 --> 00:32:37,019
you read the code what it means and it's

00:32:35,070 --> 00:32:39,450
also very powerful because you can write

00:32:37,019 --> 00:32:42,239
any any Python expression that you want

00:32:39,450 --> 00:32:44,429
for example you can call a method you

00:32:42,239 --> 00:32:48,690
can apply an operator you can do

00:32:44,429 --> 00:32:53,429
whatever you want just just don't not

00:32:48,690 --> 00:32:57,509
abuse this one please from the a

00:32:53,429 --> 00:33:00,559
synchronous programming the first change

00:32:57,509 --> 00:33:05,429
was to add something called generates

00:33:00,559 --> 00:33:07,259
delegation is a yield from so I think I

00:33:05,429 --> 00:33:11,410
you started to use this one because it's

00:33:07,259 --> 00:33:14,900
a nice way to provide a synchronous

00:33:11,410 --> 00:33:17,350
but for I think I oh it was still a

00:33:14,900 --> 00:33:20,960
little bit surprising for users because

00:33:17,350 --> 00:33:24,440
the meaning of these keywords is

00:33:20,960 --> 00:33:27,380
confusing so we added two other keywords

00:33:24,440 --> 00:33:31,690
which are icing on our weight and they

00:33:27,380 --> 00:33:34,970
became real key was and in Python 3.6

00:33:31,690 --> 00:33:36,800
because when you read the code it's much

00:33:34,970 --> 00:33:38,870
more obvious that this function is a

00:33:36,800 --> 00:33:42,160
synchronous and our weights really means

00:33:38,870 --> 00:33:45,230
that you you are awaiting for something

00:33:42,160 --> 00:33:47,840
more recently we added support for a

00:33:45,230 --> 00:33:49,340
synchronous and generators which means

00:33:47,840 --> 00:33:52,820
that in a nursing

00:33:49,340 --> 00:33:56,780
I think function you can use yield this

00:33:52,820 --> 00:33:58,910
is this is very useful for to implement

00:33:56,780 --> 00:34:02,060
more advanced function in the

00:33:58,910 --> 00:34:05,210
synchronous programming and finally we

00:34:02,060 --> 00:34:07,550
we added a synchronous list

00:34:05,210 --> 00:34:12,680
comprehensions using asking for our

00:34:07,550 --> 00:34:15,550
weight inside the list comprehension but

00:34:12,680 --> 00:34:19,340
we we got more more changes for example

00:34:15,550 --> 00:34:23,150
you get q was only which are very useful

00:34:19,340 --> 00:34:26,620
to to prevent breaking application

00:34:23,150 --> 00:34:29,870
because Q was only you can add them and

00:34:26,620 --> 00:34:32,090
you really have to pass a name of the

00:34:29,870 --> 00:34:36,410
parameter otherwise you get any or at

00:34:32,090 --> 00:34:39,440
runtime to for an example of keywords

00:34:36,410 --> 00:34:42,320
only you have the print function oh yes

00:34:39,440 --> 00:34:44,660
this one was a statement in Python 2 and

00:34:42,320 --> 00:34:49,910
in pattern freed became a function the

00:34:44,660 --> 00:34:53,180
print function for unpacking we we add

00:34:49,910 --> 00:34:56,990
the start and pack the end of the list

00:34:53,180 --> 00:35:00,590
as a star tail but now you can also use

00:34:56,990 --> 00:35:04,100
the in to build new lists you can use

00:35:00,590 --> 00:35:06,980
saw anywhere and you can also use double

00:35:04,100 --> 00:35:11,030
star to unpack a dictionary to create a

00:35:06,980 --> 00:35:15,470
new ticket and something which looks

00:35:11,030 --> 00:35:17,930
very simple but in my opinion as a lot

00:35:15,470 --> 00:35:20,930
for the readability is that no you can

00:35:17,930 --> 00:35:24,470
put underscore in numbers to Kupa digits

00:35:20,930 --> 00:35:27,560
to make it much more easier to read

00:35:24,470 --> 00:35:29,960
for example - right right and 1 million

00:35:27,560 --> 00:35:33,380
is very it's much easier to read when

00:35:29,960 --> 00:35:36,170
you group digit by 3 we can also

00:35:33,380 --> 00:35:40,609
annotate variables and not only function

00:35:36,170 --> 00:35:43,329
parameters so using : ins you can

00:35:40,609 --> 00:35:46,430
specify this this variable is an integer

00:35:43,329 --> 00:35:49,609
for the context manager with you can now

00:35:46,430 --> 00:35:53,690
specify two different expression or more

00:35:49,609 --> 00:35:56,450
previously it was limited to 1 again we

00:35:53,690 --> 00:35:59,089
introduced base formatting which is

00:35:56,450 --> 00:36:01,849
useful for twisted Mercure or any

00:35:59,089 --> 00:36:04,670
projects which we prefer to use bytes

00:36:01,849 --> 00:36:06,829
for data on the last one is a new

00:36:04,670 --> 00:36:09,560
operator in my opinion it's very

00:36:06,829 --> 00:36:12,829
important for non PI and say scientific

00:36:09,560 --> 00:36:16,660
world because previously you had to use

00:36:12,829 --> 00:36:19,970
numpy dots dots function to multiply two

00:36:16,660 --> 00:36:26,359
matrixes and now you have a dedicated

00:36:19,970 --> 00:36:30,410
operator it's much better okay so we saw

00:36:26,359 --> 00:36:34,579
that pipe project emigrated to Python

00:36:30,410 --> 00:36:38,780
free Python free is much better so is it

00:36:34,579 --> 00:36:42,319
time to birbee by python - in fact if

00:36:38,780 --> 00:36:45,280
you look at Linux distribution its move

00:36:42,319 --> 00:36:49,849
already started for example Fedora 23

00:36:45,280 --> 00:36:51,950
and Ubuntu over the last year and don't

00:36:49,849 --> 00:36:53,990
doesn't come with python 2 in the best

00:36:51,950 --> 00:36:56,329
system which means that if you install a

00:36:53,990 --> 00:36:59,540
new computer using this operating system

00:36:56,329 --> 00:37:03,680
there is no python 2 so it's me that's

00:36:59,540 --> 00:37:06,200
the migration is ongoing but obviously

00:37:03,680 --> 00:37:08,569
if you install a python 2 only

00:37:06,200 --> 00:37:13,010
application like macula you will still

00:37:08,569 --> 00:37:15,829
pour the python 2 dependency something

00:37:13,010 --> 00:37:19,670
else is a python 3 statements it's a

00:37:15,829 --> 00:37:23,119
global timeline of all projects mostly

00:37:19,670 --> 00:37:25,910
in the scientific world which show when

00:37:23,119 --> 00:37:29,000
the pattern free support has been added

00:37:25,910 --> 00:37:32,119
but also when python python 2 will be

00:37:29,000 --> 00:37:35,300
dropped so using the slime timeline you

00:37:32,119 --> 00:37:37,730
can get another view of when you should

00:37:35,300 --> 00:37:40,910
move to python free only

00:37:37,730 --> 00:37:43,550
there is also the Python clock which is

00:37:40,910 --> 00:37:46,130
a simple calm down until the end of the

00:37:43,550 --> 00:37:50,360
Python 2 supports which is the first of

00:37:46,130 --> 00:37:54,220
January 2020 and last year we started to

00:37:50,360 --> 00:37:57,350
see measure Python application like

00:37:54,220 --> 00:38:00,860
ipython 6 and Django 2 which dropped

00:37:57,350 --> 00:38:04,040
python 2 supports so they are now Python

00:38:00,860 --> 00:38:06,230
Python free on e and in my opinion for

00:38:04,040 --> 00:38:09,020
the case of pattern - it's a very strong

00:38:06,230 --> 00:38:12,650
senior because python 2 is a big project

00:38:09,020 --> 00:38:16,160
is used by a lot of people so if if by

00:38:12,650 --> 00:38:18,980
if Django is able to to to move to

00:38:16,160 --> 00:38:36,980
pattern free maybe you are also able to

00:38:18,980 --> 00:38:38,820
do that ok so I don't fall what's the

00:38:36,980 --> 00:38:39,890
plan

00:38:38,820 --> 00:38:44,020
[Music]

00:38:39,890 --> 00:38:47,090
in practice what we decided is that

00:38:44,020 --> 00:38:49,550
maybe we made some mistake in Python

00:38:47,090 --> 00:38:52,760
free I mean that we didn't prepare

00:38:49,550 --> 00:38:53,410
carefully the migration for Python to to

00:38:52,760 --> 00:38:57,020
patent-free

00:38:53,410 --> 00:39:00,110
so what I would like for Python fall is

00:38:57,020 --> 00:39:03,320
that it will just be the release after

00:39:00,110 --> 00:39:06,650
the previous Python free release latest

00:39:03,320 --> 00:39:09,320
pattern free stable version so we just

00:39:06,650 --> 00:39:11,810
respect the same duplication timelines

00:39:09,320 --> 00:39:14,840
and we are already using for the pattern

00:39:11,810 --> 00:39:17,660
to branch for example first we dip and

00:39:14,840 --> 00:39:19,640
duplicate function in release to

00:39:17,660 --> 00:39:23,240
announce that we are going to remove it

00:39:19,640 --> 00:39:26,180
and only in the next version we remove

00:39:23,240 --> 00:39:30,560
the function and sometimes we are we

00:39:26,180 --> 00:39:33,290
even use free free release like we first

00:39:30,560 --> 00:39:36,320
raised a pending warning then added a

00:39:33,290 --> 00:39:39,560
duplication warning to finally remove

00:39:36,320 --> 00:39:42,260
the function so I think that we learn

00:39:39,560 --> 00:39:45,170
from our mistake and we we are not going

00:39:42,260 --> 00:39:47,330
to break the Python community one more

00:39:45,170 --> 00:39:53,630
time because I think that we only go to

00:39:47,330 --> 00:39:57,340
one ballads and we reused it so thank

00:39:53,630 --> 00:39:57,340
you everybody and

00:40:01,460 --> 00:40:06,470
if there is still time maybe we can you

00:40:04,520 --> 00:40:07,970
can go for a question yeah so I think

00:40:06,470 --> 00:40:10,220
you too Victor if anybody wants to come

00:40:07,970 --> 00:40:12,110
up there's two sets of microphones just

00:40:10,220 --> 00:40:14,030
reminder questions in our statement and

00:40:12,110 --> 00:40:18,050
they in a question mark and they're not

00:40:14,030 --> 00:40:20,840
a long story so carry on I see red hat

00:40:18,050 --> 00:40:27,370
on your slides yes when are they gonna

00:40:20,840 --> 00:40:30,650
drop - so we what we did in the red at 7

00:40:27,370 --> 00:40:32,870
7.5 which is the latest release we

00:40:30,650 --> 00:40:36,500
unknown see that Python - is deprecated

00:40:32,870 --> 00:40:38,630
and for the next major version of red &

00:40:36,500 --> 00:40:49,550
pharrell we are going to ship only

00:40:38,630 --> 00:40:51,170
patent-free so no no Python - yes are

00:40:49,550 --> 00:40:54,230
there any features that you personally

00:40:51,170 --> 00:40:56,930
think would are on the horizon that

00:40:54,230 --> 00:41:02,090
would need a Python for breaking changes

00:40:56,930 --> 00:41:05,990
you can't just fold into Python 3 when I

00:41:02,090 --> 00:41:08,660
discussed with Guido he maybe it doesn't

00:41:05,990 --> 00:41:11,300
show exactly the same opinion than me he

00:41:08,660 --> 00:41:13,790
would justify breaking the backward

00:41:11,300 --> 00:41:15,830
compatibility again if we have a real

00:41:13,790 --> 00:41:21,770
change love for example allow yes ting

00:41:15,830 --> 00:41:25,130
colectomy which breaks the capi but it's

00:41:21,770 --> 00:41:27,650
today is very difficult to know if we

00:41:25,130 --> 00:41:29,540
are going to do that or not because the

00:41:27,650 --> 00:41:36,140
colectomy still experimental we don't

00:41:29,540 --> 00:41:38,960
know yes yeah I guess in terms of like

00:41:36,140 --> 00:41:41,540
the kind of like the lessons learned

00:41:38,960 --> 00:41:44,480
from the transition from 2 to 3 was that

00:41:41,540 --> 00:41:45,680
sort of like the was kind of like the

00:41:44,480 --> 00:41:48,050
conclusion drawn from the mattress that

00:41:45,680 --> 00:41:49,400
like if like some steps were taking

00:41:48,050 --> 00:41:50,930
better it would have gone more quickly

00:41:49,400 --> 00:41:52,580
or that this just kind of takes time and

00:41:50,930 --> 00:41:53,990
that like kind of like the transition

00:41:52,580 --> 00:41:55,400
from two to three it was kind of like it

00:41:53,990 --> 00:42:04,130
took as long as I had to take because of

00:41:55,400 --> 00:42:07,130
the nature of the beast I guess I was

00:42:04,130 --> 00:42:08,870
just wondering in terms of why or like

00:42:07,130 --> 00:42:11,870
kind of like the conclusions drawn from

00:42:08,870 --> 00:42:13,700
the transition from two to three was the

00:42:11,870 --> 00:42:15,290
conclusion just that like

00:42:13,700 --> 00:42:16,910
this is just kind of how long this sort

00:42:15,290 --> 00:42:18,140
of thing takes or that if like some

00:42:16,910 --> 00:42:19,790
things were done better it would have

00:42:18,140 --> 00:42:25,460
gone faster and like this was kind of

00:42:19,790 --> 00:42:27,860
just like a learning experience today

00:42:25,460 --> 00:42:30,950
it's very easy to say that we make

00:42:27,860 --> 00:42:32,870
mistake but ten years ago it was much

00:42:30,950 --> 00:42:37,340
more difficult to understand that

00:42:32,870 --> 00:42:41,870
something bad was occurring so maybe if

00:42:37,340 --> 00:42:44,990
we if we do that again we will be

00:42:41,870 --> 00:42:50,290
different difference but I'm not sure

00:42:44,990 --> 00:42:50,290
that we we could we could do it faster

00:42:54,070 --> 00:42:57,720
that looks like everybody so thank you

00:42:56,690 --> 00:43:05,050
Victor

00:42:57,720 --> 00:43:05,050

YouTube URL: https://www.youtube.com/watch?v=Aj3KMefwOqI


