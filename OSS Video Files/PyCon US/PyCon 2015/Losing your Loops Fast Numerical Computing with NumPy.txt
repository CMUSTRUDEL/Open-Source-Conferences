Title: Losing your Loops Fast Numerical Computing with NumPy
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	
Captions: 
	00:00:00,199 --> 00:00:07,519
hello everyone how y'all doing all right

00:00:04,290 --> 00:00:09,269
good I want to go ahead find your seats

00:00:07,519 --> 00:00:10,830
get comfortable we're going to be

00:00:09,269 --> 00:00:13,830
getting a talk from Jake Vander Plaats

00:00:10,830 --> 00:00:16,289
he is a astronomer which I'm deeply

00:00:13,830 --> 00:00:17,820
jealous of probably more germane for

00:00:16,289 --> 00:00:19,920
this in particularly oh he's deeply

00:00:17,820 --> 00:00:21,240
involved in the scientific Python

00:00:19,920 --> 00:00:23,580
community and is one of the core

00:00:21,240 --> 00:00:27,529
developers for my favorite toy

00:00:23,580 --> 00:00:27,529
scikit-learn so Jake

00:00:31,700 --> 00:00:37,620
all right thanks it's good to be here on

00:00:34,610 --> 00:00:39,989
so I work a lot in scientific Python and

00:00:37,620 --> 00:00:42,719
I work on kind of data intensive science

00:00:39,989 --> 00:00:45,000
with Python my background is in

00:00:42,719 --> 00:00:47,070
astronomy so I do a bit of that and one

00:00:45,000 --> 00:00:49,800
of the key tools that we use in

00:00:47,070 --> 00:00:51,360
astronomy for numerical computing and in

00:00:49,800 --> 00:00:53,760
all of science actually is this library

00:00:51,360 --> 00:00:55,379
numpy which you're probably familiar

00:00:53,760 --> 00:00:57,719
with if you're not if something you

00:00:55,379 --> 00:00:59,579
should be familiar with and what I want

00:00:57,719 --> 00:01:02,270
to do today is talk about how to use

00:00:59,579 --> 00:01:06,119
numpy effectively to do data intensive

00:01:02,270 --> 00:01:08,010
computing and there's a couple ways it's

00:01:06,119 --> 00:01:09,960
it's relatively easy to use but there's

00:01:08,010 --> 00:01:12,119
some different ways that you need to

00:01:09,960 --> 00:01:14,340
think about writing your code when

00:01:12,119 --> 00:01:16,170
you're using numpy in order to use it

00:01:14,340 --> 00:01:19,740
effectively so I'm going to go through a

00:01:16,170 --> 00:01:22,170
few of those strategies so um I hope

00:01:19,740 --> 00:01:23,670
that background is okay there's not too

00:01:22,170 --> 00:01:26,100
much green background sorry about that

00:01:23,670 --> 00:01:28,650
so um I want to start out with saying

00:01:26,100 --> 00:01:31,290
python is fast this is why we use Python

00:01:28,650 --> 00:01:34,380
right for writing testing and developing

00:01:31,290 --> 00:01:36,030
code Python is incredibly fast and one

00:01:34,380 --> 00:01:38,759
of my favorite examples is I like to put

00:01:36,030 --> 00:01:41,250
up hello world in Python right you just

00:01:38,759 --> 00:01:43,079
print hello world it is great and if any

00:01:41,250 --> 00:01:44,250
of you have been in other languages you

00:01:43,079 --> 00:01:47,100
know that hello world and other

00:01:44,250 --> 00:01:49,500
languages like for example Java is not

00:01:47,100 --> 00:01:52,380
quite as clean you know to to print

00:01:49,500 --> 00:01:54,899
hello world if you're an intro C CS

00:01:52,380 --> 00:01:56,969
student you need to learn about classes

00:01:54,899 --> 00:02:00,030
you need to learn about public methods

00:01:56,969 --> 00:02:03,210
of classes and all this stuff just to do

00:02:00,030 --> 00:02:05,009
this and this this is just um is it this

00:02:03,210 --> 00:02:07,680
is just a drop in the bucket of what you

00:02:05,009 --> 00:02:09,989
need to write you know Java code or C++

00:02:07,680 --> 00:02:13,410
code or some of these other lower-level

00:02:09,989 --> 00:02:15,600
languages so python is very

00:02:13,410 --> 00:02:17,610
fast for developing another thing that

00:02:15,600 --> 00:02:19,980
Python gives you which is really nice

00:02:17,610 --> 00:02:21,660
for these high-level libraries to do

00:02:19,980 --> 00:02:24,120
some really interesting things this is

00:02:21,660 --> 00:02:26,220
an example of from the Seabourn library

00:02:24,120 --> 00:02:27,780
where you load a data set and then

00:02:26,220 --> 00:02:29,670
there's this pair plot function that

00:02:27,780 --> 00:02:31,620
allows you to examine that data set that

00:02:29,670 --> 00:02:34,590
data set is actually a panda's data

00:02:31,620 --> 00:02:36,780
frame so you can apply this this pair

00:02:34,590 --> 00:02:38,760
plot to any panda's data frame and you

00:02:36,780 --> 00:02:41,280
get out a nice visualization of the

00:02:38,760 --> 00:02:42,870
relationships between the points you

00:02:41,280 --> 00:02:44,850
know I'm sure there are libraries in

00:02:42,870 --> 00:02:46,500
Java or C++ it would allow you to do

00:02:44,850 --> 00:02:48,270
this but it's going to be a lot more

00:02:46,500 --> 00:02:51,300
boilerplate code to do this kind of

00:02:48,270 --> 00:02:53,310
thing so Python we like Python because

00:02:51,300 --> 00:02:55,350
it's fast and it's fast because it's

00:02:53,310 --> 00:02:57,420
interpreted because it's dynamically

00:02:55,350 --> 00:02:59,370
typed because it's high level and you

00:02:57,420 --> 00:03:02,880
can code quickly you can try things out

00:02:59,370 --> 00:03:05,040
quickly and you can you can get get the

00:03:02,880 --> 00:03:08,600
things from your mind into your script

00:03:05,040 --> 00:03:10,680
without much width without much effort

00:03:08,600 --> 00:03:14,850
but then of course on the other hand

00:03:10,680 --> 00:03:17,310
write Python is slow so and python is

00:03:14,850 --> 00:03:20,790
especially slow for repeated execution

00:03:17,310 --> 00:03:22,440
of low-level tasks so for example if we

00:03:20,790 --> 00:03:23,730
if we write this silly function in

00:03:22,440 --> 00:03:26,220
Python right here this is just a

00:03:23,730 --> 00:03:30,540
function that loops through end times

00:03:26,220 --> 00:03:33,330
and updates some variable with with a

00:03:30,540 --> 00:03:36,570
couple a couple different operations and

00:03:33,330 --> 00:03:38,400
returns the result I'm going to be using

00:03:36,570 --> 00:03:40,680
here that the time-it magic function

00:03:38,400 --> 00:03:42,690
which is available in ipython and the

00:03:40,680 --> 00:03:44,610
ipython notebook that allows you to

00:03:42,690 --> 00:03:46,800
quickly get benchmarks of simple

00:03:44,610 --> 00:03:48,870
functions like this so if we use the

00:03:46,800 --> 00:03:52,830
time-it and we call this funk python

00:03:48,870 --> 00:03:56,459
with for a loop of 10,000 we find that

00:03:52,830 --> 00:03:58,890
this executes sin 1.6 nine milliseconds

00:03:56,459 --> 00:04:01,110
okay so that may be fast may be slow but

00:03:58,890 --> 00:04:03,840
let's look at something in comparison if

00:04:01,110 --> 00:04:06,060
we instead implement these exact same

00:04:03,840 --> 00:04:08,190
function in Fortran here we're going to

00:04:06,060 --> 00:04:10,470
use this Fortran magic that's also part

00:04:08,190 --> 00:04:13,200
of ipython so I can write Fortran code

00:04:10,470 --> 00:04:14,850
in the ipython notebook it automatically

00:04:13,200 --> 00:04:16,980
produces a Python function that's

00:04:14,850 --> 00:04:18,780
wrapped that Fortran code and then we're

00:04:16,980 --> 00:04:20,040
going to time it so this is this is

00:04:18,780 --> 00:04:21,450
pretty awesome right here if you haven't

00:04:20,040 --> 00:04:23,580
checked out ipython you should you

00:04:21,450 --> 00:04:25,860
should see all this stuff it can do but

00:04:23,580 --> 00:04:26,790
if we time this this Fortran function we

00:04:25,860 --> 00:04:29,000
find that it

00:04:26,790 --> 00:04:32,690
completes in seventeen point nine

00:04:29,000 --> 00:04:35,160
microseconds so as a comparison we have

00:04:32,690 --> 00:04:37,260
we've seen that here that Python is

00:04:35,160 --> 00:04:39,420
about a factor of a hundred slower than

00:04:37,260 --> 00:04:41,820
Fortran when you're starting to write

00:04:39,420 --> 00:04:44,940
loops and do little operations over and

00:04:41,820 --> 00:04:47,010
over and this is not a fluke this is

00:04:44,940 --> 00:04:50,910
basically how it is whenever you're

00:04:47,010 --> 00:04:52,290
writing loops over data in Python right

00:04:50,910 --> 00:04:56,160
so this is the problem and the reason

00:04:52,290 --> 00:04:58,260
this is happening is because python has

00:04:56,160 --> 00:05:00,090
a high level interpreted dynamically

00:04:58,260 --> 00:05:02,220
typed language so each time you do a

00:05:00,090 --> 00:05:03,750
Python operation there's a little bit of

00:05:02,220 --> 00:05:06,030
overhead there are things like type

00:05:03,750 --> 00:05:08,430
checking you know when you do a plus B

00:05:06,030 --> 00:05:10,680
python has to type check the type of a

00:05:08,430 --> 00:05:13,140
check the type of B then find the right

00:05:10,680 --> 00:05:15,990
code to add say an integer to an integer

00:05:13,140 --> 00:05:17,700
and then produce the result there's also

00:05:15,990 --> 00:05:19,680
reference counting you know you have to

00:05:17,700 --> 00:05:22,050
you have to augment the reference or

00:05:19,680 --> 00:05:24,090
decrease the reference count for

00:05:22,050 --> 00:05:26,310
different variables as you as you change

00:05:24,090 --> 00:05:28,350
the values of them and all these are

00:05:26,310 --> 00:05:30,060
it's a small amount of overhead for a

00:05:28,350 --> 00:05:32,640
single operation for a single line of

00:05:30,060 --> 00:05:34,110
code but when you put this in a loop and

00:05:32,640 --> 00:05:36,210
you do this ten thousand or a hundred

00:05:34,110 --> 00:05:38,400
thousand or a million times that

00:05:36,210 --> 00:05:40,440
overhead builds up and can become really

00:05:38,400 --> 00:05:42,360
significant and that's basically the

00:05:40,440 --> 00:05:44,880
reason this Python loop is so much

00:05:42,360 --> 00:05:48,060
slower than the Fortran loop a factor of

00:05:44,880 --> 00:05:49,770
a hundred in this case so so this is the

00:05:48,060 --> 00:05:52,020
paradox that we have to work with when

00:05:49,770 --> 00:05:54,780
we're doing scientific or numerically

00:05:52,020 --> 00:05:58,890
intensive Python what makes Python fast

00:05:54,780 --> 00:06:00,540
for development this high-level this

00:05:58,890 --> 00:06:03,060
this high level interpreted and

00:06:00,540 --> 00:06:05,460
dynamically typed aspects of the

00:06:03,060 --> 00:06:08,670
language what makes it fast is exactly

00:06:05,460 --> 00:06:11,040
what makes it slow for code execution so

00:06:08,670 --> 00:06:12,840
we have to when we're using Python ian's

00:06:11,040 --> 00:06:14,610
it's always good to keep that in mind

00:06:12,840 --> 00:06:16,920
I should note here that there there are

00:06:14,610 --> 00:06:19,260
some approaches that are becoming more

00:06:16,920 --> 00:06:21,900
mature like pi PI numbah and other

00:06:19,260 --> 00:06:23,340
just-in-time compilations that might fix

00:06:21,900 --> 00:06:25,950
this in the future but for the time

00:06:23,340 --> 00:06:27,660
being see Python is kind of the the

00:06:25,950 --> 00:06:29,580
thing that most scientists are using and

00:06:27,660 --> 00:06:31,190
I can chat with you later about that if

00:06:29,580 --> 00:06:34,110
you have more questions

00:06:31,190 --> 00:06:36,000
so this is where numpy comes in numpy is

00:06:34,110 --> 00:06:39,360
basically designed to help us get the

00:06:36,000 --> 00:06:42,030
best of both worlds we want to have the

00:06:39,360 --> 00:06:44,009
asked code development time of Python

00:06:42,030 --> 00:06:46,469
but we want to have the fast code

00:06:44,009 --> 00:06:49,889
execution time of a language like C or

00:06:46,469 --> 00:06:51,900
Fortran and the way numpy does this is

00:06:49,889 --> 00:06:54,419
it recognizes that the things that are

00:06:51,900 --> 00:06:56,370
slow are when you're looping over small

00:06:54,419 --> 00:06:58,979
operations and building up that little

00:06:56,370 --> 00:07:01,409
overhead of repeated repeated operations

00:06:58,979 --> 00:07:04,229
in Python so it takes those looped up

00:07:01,409 --> 00:07:06,030
really operations and pushes them down

00:07:04,229 --> 00:07:08,280
into compiled code so that they can be

00:07:06,030 --> 00:07:10,379
done quickly so basically the in

00:07:08,280 --> 00:07:12,930
compiled code the type check only has to

00:07:10,379 --> 00:07:17,939
happen one time for the entire loop of a

00:07:12,930 --> 00:07:19,740
million repetitions right so um again

00:07:17,939 --> 00:07:22,110
that green I'm sorry I should have done

00:07:19,740 --> 00:07:24,599
better so for I wanted today to talk

00:07:22,110 --> 00:07:28,439
about four strategies for for speeding

00:07:24,599 --> 00:07:30,840
up code with numpy and basically these

00:07:28,439 --> 00:07:33,150
strategies boiled down to trying to get

00:07:30,840 --> 00:07:34,949
rid of loops in your code so that's why

00:07:33,150 --> 00:07:36,779
the title this talk is losing your loops

00:07:34,949 --> 00:07:39,479
you want to get rid of loops in Python

00:07:36,779 --> 00:07:41,520
and try as hard as you can to to put

00:07:39,479 --> 00:07:43,560
that code into numpy so the first

00:07:41,520 --> 00:07:45,089
strategy I'll talk about is you funks

00:07:43,560 --> 00:07:47,789
well we'll talk about what those are

00:07:45,089 --> 00:07:50,969
second strategy is using aggregations

00:07:47,789 --> 00:07:53,580
the third strategy is using broadcasting

00:07:50,969 --> 00:07:56,279
and the fourth strategy is using slicing

00:07:53,580 --> 00:07:58,169
masking and fancy indexing so all of

00:07:56,279 --> 00:07:59,849
these sound like jargony terms but I

00:07:58,169 --> 00:08:01,199
promise you all I'll dive in deep and

00:07:59,849 --> 00:08:03,210
let you know exactly what they all mean

00:08:01,199 --> 00:08:05,879
and again I want to emphasize the

00:08:03,210 --> 00:08:08,339
overall goal is to remove Python loops

00:08:05,879 --> 00:08:12,089
from your code if you have a Python loop

00:08:08,339 --> 00:08:13,710
that's more than 3 or 5 repetitions your

00:08:12,089 --> 00:08:16,860
code is going to be slower than it then

00:08:13,710 --> 00:08:19,800
it has to be ok so strategy number one

00:08:16,860 --> 00:08:23,639
using using you funks what what is a you

00:08:19,800 --> 00:08:26,339
func a you func is short for universal

00:08:23,639 --> 00:08:28,319
function and this is basically a special

00:08:26,339 --> 00:08:30,960
type of function defined within the

00:08:28,319 --> 00:08:33,870
numpy library that operates element-wise

00:08:30,960 --> 00:08:36,149
on arrays ok then let me let me show you

00:08:33,870 --> 00:08:38,279
an example of this if you're a Python

00:08:36,149 --> 00:08:40,649
programmer that doesn't use numpy and

00:08:38,279 --> 00:08:42,570
you want to do element wise operations

00:08:40,649 --> 00:08:45,290
on your arrays this is probably the best

00:08:42,570 --> 00:08:48,390
way to do it so here we have an array of

00:08:45,290 --> 00:08:51,810
about eight values and we want to add

00:08:48,390 --> 00:08:52,710
five to each of those values right so as

00:08:51,810 --> 00:08:54,300
a good pie

00:08:52,710 --> 00:08:57,090
non-programmer you break out your list

00:08:54,300 --> 00:08:59,640
comprehensions and you do val +5 for val

00:08:57,090 --> 00:09:02,010
and a and you get out this result which

00:08:59,640 --> 00:09:03,660
is exactly what you want great so this

00:09:02,010 --> 00:09:06,390
is great this is this is the pythonic

00:09:03,660 --> 00:09:12,450
way to do it the the numpy way to do

00:09:06,390 --> 00:09:14,820
this which is is a bit simpler is to if

00:09:12,450 --> 00:09:17,850
you import numpy and you turn this list

00:09:14,820 --> 00:09:19,950
into an array then what you can do is

00:09:17,850 --> 00:09:23,510
you can treat that array as just a

00:09:19,950 --> 00:09:26,820
number and you say B equals a plus 5 and

00:09:23,510 --> 00:09:30,210
numpy over loads that plus operator and

00:09:26,820 --> 00:09:32,850
actually produces this result element

00:09:30,210 --> 00:09:35,160
wise so when you add five to an array

00:09:32,850 --> 00:09:38,160
it's like adding five to every value of

00:09:35,160 --> 00:09:40,710
the array and notice what the difference

00:09:38,160 --> 00:09:43,290
here is we don't have any for Val and a

00:09:40,710 --> 00:09:45,690
in the Python code here in the numpy

00:09:43,290 --> 00:09:48,000
code R so in the numpy code below we're

00:09:45,690 --> 00:09:50,310
just that for loop is actually taking

00:09:48,000 --> 00:09:53,010
place in the internals of numpy and

00:09:50,310 --> 00:09:55,740
what's going on is it's pushing that for

00:09:53,010 --> 00:09:58,710
loop down into the compiled core of the

00:09:55,740 --> 00:10:01,050
numpy code and just to convince you that

00:09:58,710 --> 00:10:02,760
this is a this is a good idea if we if

00:10:01,050 --> 00:10:04,860
we bump this up to about a hundred

00:10:02,760 --> 00:10:07,080
thousand values and we do this in python

00:10:04,860 --> 00:10:09,900
we get about seven milliseconds per loop

00:10:07,080 --> 00:10:13,230
doing the same thing in numpy doing a

00:10:09,900 --> 00:10:15,240
plus 5 gives us 82 microseconds per loop

00:10:13,230 --> 00:10:17,070
so again we have about a factor of a

00:10:15,240 --> 00:10:20,340
hundred speed-up by going to this

00:10:17,070 --> 00:10:22,980
compiled version of the operation by

00:10:20,340 --> 00:10:25,530
taking away the loops in python we get

00:10:22,980 --> 00:10:26,970
to a faster version with numpy and also

00:10:25,530 --> 00:10:28,920
I should point out that it's much more

00:10:26,970 --> 00:10:30,780
concise and easier to type right it's

00:10:28,920 --> 00:10:32,790
harder to get that wrong it's harder to

00:10:30,780 --> 00:10:35,250
get a plus five wrong than this list

00:10:32,790 --> 00:10:36,960
comprehension so it's really it's really

00:10:35,250 --> 00:10:38,220
nice and there are a ton of you funks

00:10:36,960 --> 00:10:40,590
that you can use that are built in a

00:10:38,220 --> 00:10:42,720
numpy basically all the arithmetic

00:10:40,590 --> 00:10:45,240
bitwise and comparison operators in

00:10:42,720 --> 00:10:47,490
python are overloaded for numpy arrays

00:10:45,240 --> 00:10:49,320
to do this sort of universal function

00:10:47,490 --> 00:10:51,320
this element by element operation and

00:10:49,320 --> 00:10:54,510
there are a bunch of other ones like

00:10:51,320 --> 00:10:57,660
numpy has trigonometric functions

00:10:54,510 --> 00:10:59,730
exponential family functions in the SyFy

00:10:57,660 --> 00:11:01,440
package there are special functions if

00:10:59,730 --> 00:11:03,690
you want to do things like you know

00:11:01,440 --> 00:11:05,370
Bessel functions and gamma functions and

00:11:03,690 --> 00:11:06,510
all these things that physicists and

00:11:05,370 --> 00:11:08,910
mathematicians worry

00:11:06,510 --> 00:11:13,110
they're all in there as you funks so you

00:11:08,910 --> 00:11:14,970
can do them quickly over large arrays so

00:11:13,110 --> 00:11:16,560
those are you focus then the next

00:11:14,970 --> 00:11:19,620
strategy I want to talk about is using

00:11:16,560 --> 00:11:21,750
num pies aggregations so what is an

00:11:19,620 --> 00:11:23,850
aggregation an aggregation is a function

00:11:21,750 --> 00:11:26,760
which summarizes the values of an array

00:11:23,850 --> 00:11:30,050
somehow so good examples are minimum

00:11:26,760 --> 00:11:32,970
maximum the sum the mean the median

00:11:30,050 --> 00:11:34,740
these sorts of things and numpy has a

00:11:32,970 --> 00:11:37,320
bunch of these built in and again it's

00:11:34,740 --> 00:11:39,750
something that if you were to write it

00:11:37,320 --> 00:11:41,370
out raw and Python you could write it

00:11:39,750 --> 00:11:43,860
with a for loop right you could loop

00:11:41,370 --> 00:11:46,199
over these arrays and do it yourself but

00:11:43,860 --> 00:11:50,850
it's much faster to do these min and Max

00:11:46,199 --> 00:11:52,589
and other aggregations in numpy so just

00:11:50,850 --> 00:11:55,889
as an example to show you again the

00:11:52,589 --> 00:11:58,769
numpy beats Python in this if we take

00:11:55,889 --> 00:12:01,139
here we have a list of a hundred

00:11:58,769 --> 00:12:02,940
thousand random values and we're going

00:12:01,139 --> 00:12:05,190
to see how long it takes Python to get

00:12:02,940 --> 00:12:09,300
the minimum of those values and here you

00:12:05,190 --> 00:12:11,639
know it's it's about two milliseconds if

00:12:09,300 --> 00:12:15,810
we do the same thing in numpy if we if

00:12:11,639 --> 00:12:19,019
we take a if we convert this list to an

00:12:15,810 --> 00:12:22,139
array and then time the C dot min that

00:12:19,019 --> 00:12:24,720
the the min method of the array is num

00:12:22,139 --> 00:12:28,260
pies version of the the min function in

00:12:24,720 --> 00:12:29,880
Python and here we get 30.8 milliseconds

00:12:28,260 --> 00:12:32,250
so this is again almost a hundred

00:12:29,880 --> 00:12:35,430
hundred times speed-up for using the

00:12:32,250 --> 00:12:36,930
numpy code versus the Python code and I

00:12:35,430 --> 00:12:39,029
want to emphasize again the reason it's

00:12:36,930 --> 00:12:40,860
doing this is because when pythons min

00:12:39,029 --> 00:12:43,470
function goes through that list every

00:12:40,860 --> 00:12:45,540
value it gets to it asked to ask what's

00:12:43,470 --> 00:12:47,519
the type of this value okay I'm going to

00:12:45,540 --> 00:12:49,649
compare that type to the current minimum

00:12:47,519 --> 00:12:51,389
what's the type of the next value and

00:12:49,649 --> 00:12:53,730
all that overhead multiplied by a

00:12:51,389 --> 00:12:58,620
hundred thousand turns into this this

00:12:53,730 --> 00:13:00,600
slowdown over all so um the the other

00:12:58,620 --> 00:13:02,339
thing that numpy segregations can do is

00:13:00,600 --> 00:13:05,100
it can work on multi-dimensional arrays

00:13:02,339 --> 00:13:07,230
so if you want the sum of an entire

00:13:05,100 --> 00:13:11,430
array you can just do m dot sum and you

00:13:07,230 --> 00:13:14,220
get it out if you want the sum of say

00:13:11,430 --> 00:13:16,110
all the columns in the array you pass

00:13:14,220 --> 00:13:17,939
the sum and access argument and now

00:13:16,110 --> 00:13:19,980
instead of looping through the columns

00:13:17,939 --> 00:13:20,540
and asking for the sum of each one

00:13:19,980 --> 00:13:22,760
individually

00:13:20,540 --> 00:13:24,760
that loop is pushed down into the

00:13:22,760 --> 00:13:27,709
compiled layer and you have a very fast

00:13:24,760 --> 00:13:29,269
sum of all rows so some access equals

00:13:27,709 --> 00:13:31,730
zero gives you the sum of the columns

00:13:29,269 --> 00:13:34,339
sum of access equals one gives you the

00:13:31,730 --> 00:13:36,560
sum of all the rows and you get those

00:13:34,339 --> 00:13:38,300
answers out quickly and this this works

00:13:36,560 --> 00:13:40,910
for a three by five array it also works

00:13:38,300 --> 00:13:44,180
for a thousand by 10,000 array and it's

00:13:40,910 --> 00:13:45,949
relatively quick so there are a lot of

00:13:44,180 --> 00:13:47,449
aggregations available in numpy and you

00:13:45,949 --> 00:13:49,010
should get familiar with them if you're

00:13:47,449 --> 00:13:52,310
going to be doing so any large-scale

00:13:49,010 --> 00:13:54,500
data analysis minimum maximum sum

00:13:52,310 --> 00:13:56,870
product means standard deviation

00:13:54,500 --> 00:13:59,600
variance there are these boolean ones

00:13:56,870 --> 00:14:01,790
any or all which are similar to the

00:13:59,600 --> 00:14:04,699
Python any are all functions but faster

00:14:01,790 --> 00:14:06,410
for a race as median percentile rank

00:14:04,699 --> 00:14:08,480
based statistics there are things like

00:14:06,410 --> 00:14:10,550
argument and Arg max that give you the

00:14:08,480 --> 00:14:13,310
index of the minimum and the index of

00:14:10,550 --> 00:14:16,220
the maximum value very quickly and then

00:14:13,310 --> 00:14:18,620
for almost all of these they're nan min

00:14:16,220 --> 00:14:21,380
and Nan Max and nan some that do the

00:14:18,620 --> 00:14:24,170
same thing but ignore Nan's which are

00:14:21,380 --> 00:14:27,050
the special floating point not a number

00:14:24,170 --> 00:14:28,550
marker and the cool thing here is all

00:14:27,050 --> 00:14:30,980
these have the same call signature so

00:14:28,550 --> 00:14:32,750
you can pass access commands to them you

00:14:30,980 --> 00:14:34,819
can operate on multi-dimensional arrays

00:14:32,750 --> 00:14:37,610
and all of them work very very quickly

00:14:34,819 --> 00:14:40,069
so that's the second strategy

00:14:37,610 --> 00:14:42,889
aggregations the the third strategy that

00:14:40,069 --> 00:14:45,019
I want to go over is broadcasting so

00:14:42,889 --> 00:14:47,480
this is something that's very cool in in

00:14:45,019 --> 00:14:49,940
numpy what broadcasting does is it gives

00:14:47,480 --> 00:14:53,360
you a set of rules by which you funks

00:14:49,940 --> 00:14:56,930
operate on arrays of different sizes and

00:14:53,360 --> 00:14:59,269
dimensions so what these set of rules

00:14:56,930 --> 00:15:03,889
allow you to do is to do things like for

00:14:59,269 --> 00:15:06,920
example add a single digit to a vector

00:15:03,889 --> 00:15:10,220
like in that top row right there we can

00:15:06,920 --> 00:15:14,029
add a row to a matrix and it basically

00:15:10,220 --> 00:15:17,180
adds to every it adds to every row along

00:15:14,029 --> 00:15:19,220
there and we can do even crazier things

00:15:17,180 --> 00:15:21,230
like we can take a column vector and add

00:15:19,220 --> 00:15:24,100
it to a row vector and those are

00:15:21,230 --> 00:15:28,190
broadcast together to to become a

00:15:24,100 --> 00:15:30,050
two-dimensional array so these the rules

00:15:28,190 --> 00:15:32,149
of broadcasting are pretty simple

00:15:30,050 --> 00:15:33,620
sometimes a little bit confusing it

00:15:32,149 --> 00:15:35,810
takes a while to wrap your mind

00:15:33,620 --> 00:15:38,440
what's going on but once you once you

00:15:35,810 --> 00:15:40,400
get these down there's a huge amount of

00:15:38,440 --> 00:15:41,930
operations that you can do really

00:15:40,400 --> 00:15:44,420
efficiently with these broadcasting

00:15:41,930 --> 00:15:46,880
rules so the first rule is if the array

00:15:44,420 --> 00:15:50,540
shapes differe you left pad the smaller

00:15:46,880 --> 00:15:52,430
shape with ones then you compare the

00:15:50,540 --> 00:15:55,520
dimensions and if any dimension doesn't

00:15:52,430 --> 00:15:57,529
match you broadcast or kind of expand

00:15:55,520 --> 00:16:00,500
the dimension that has size equals one

00:15:57,529 --> 00:16:02,360
and if the dimensions don't match but

00:16:00,500 --> 00:16:04,100
neither of the dimensions is one

00:16:02,360 --> 00:16:06,740
there's no way to match those together

00:16:04,100 --> 00:16:09,170
and you raise an error so just as a

00:16:06,740 --> 00:16:12,430
quick example of how this goes if we

00:16:09,170 --> 00:16:15,080
look at this adding a scalar to a vector

00:16:12,430 --> 00:16:18,589
basically to start with the shape is

00:16:15,080 --> 00:16:22,190
three and empty a scalar value is zero

00:16:18,589 --> 00:16:24,589
dimensional so it has no shape we apply

00:16:22,190 --> 00:16:26,420
the first rule and we left pad the

00:16:24,589 --> 00:16:29,420
smaller shape with one so that turns our

00:16:26,420 --> 00:16:31,940
matrix R vectors into a shape three and

00:16:29,420 --> 00:16:35,060
shape one when we apply the second rule

00:16:31,940 --> 00:16:37,279
we we broadcast that one up to a three

00:16:35,060 --> 00:16:39,560
which means we sort of like we can think

00:16:37,279 --> 00:16:41,930
about copying the memory across into a

00:16:39,560 --> 00:16:43,670
length three vector but we're not

00:16:41,930 --> 00:16:45,470
actually copying the memory that's just

00:16:43,670 --> 00:16:47,930
an abstraction to think about so there's

00:16:45,470 --> 00:16:49,490
no memory overhead in this numpy just

00:16:47,930 --> 00:16:52,330
acts as if that's happening under the

00:16:49,490 --> 00:16:54,740
hood and now after these two shapes

00:16:52,330 --> 00:16:56,360
agree so the final shape will be a

00:16:54,740 --> 00:16:58,940
length three vector and we end up

00:16:56,360 --> 00:17:02,600
basically adding five to all those

00:16:58,940 --> 00:17:03,890
values looking at the second one it's

00:17:02,600 --> 00:17:05,750
very similar we have a three by three

00:17:03,890 --> 00:17:08,270
matrix we're adding to a length three

00:17:05,750 --> 00:17:09,829
vector the first thing we do is left Pat

00:17:08,270 --> 00:17:12,530
it with one's to make the number of

00:17:09,829 --> 00:17:14,929
dimensions match then we broadcast that

00:17:12,530 --> 00:17:18,490
one up and we stretch that vector across

00:17:14,929 --> 00:17:21,170
the whole matrix and then we we have to

00:17:18,490 --> 00:17:23,329
we now have two matrices of match we add

00:17:21,170 --> 00:17:26,449
them together and we get out shape 3/3

00:17:23,329 --> 00:17:28,610
and then the more complicated case or

00:17:26,449 --> 00:17:32,420
things like this where we have something

00:17:28,610 --> 00:17:35,030
that's a three by one array added to a

00:17:32,420 --> 00:17:37,370
length three vector and we just follow

00:17:35,030 --> 00:17:39,050
through we we pad the shapes so that

00:17:37,370 --> 00:17:42,980
they're the same number of dimensions

00:17:39,050 --> 00:17:44,600
then in this case both of the both the

00:17:42,980 --> 00:17:46,500
left-hand side and the right-hand side

00:17:44,600 --> 00:17:48,800
need to be broadcast to match

00:17:46,500 --> 00:17:51,630
the other so we broadcast both of them

00:17:48,800 --> 00:17:55,290
we add them together and we end up with

00:17:51,630 --> 00:17:58,110
a three by three array so what this

00:17:55,290 --> 00:18:00,450
allows you to do is things like rather

00:17:58,110 --> 00:18:02,970
than writing loops over one side and

00:18:00,450 --> 00:18:04,830
another to do like outer products and

00:18:02,970 --> 00:18:06,530
things like this of arrays rather than

00:18:04,830 --> 00:18:09,150
writing these loops in Python you can

00:18:06,530 --> 00:18:11,820
express them with this broadcasting

00:18:09,150 --> 00:18:14,430
syntax and you get a much faster

00:18:11,820 --> 00:18:15,930
computation and also much cleaner code

00:18:14,430 --> 00:18:19,400
you don't have to worry about loop

00:18:15,930 --> 00:18:21,540
indexes as you go through these things

00:18:19,400 --> 00:18:23,460
so that was the third strategy the

00:18:21,540 --> 00:18:26,700
fourth strategy I want to talk about is

00:18:23,460 --> 00:18:29,940
slicing masking and fancy indexing so if

00:18:26,700 --> 00:18:32,670
you're used to two lists in Python you

00:18:29,940 --> 00:18:35,940
know that you can index lists with an

00:18:32,670 --> 00:18:38,010
integer to find a single value you can

00:18:35,940 --> 00:18:40,230
index lists with a slice to find

00:18:38,010 --> 00:18:44,040
multiple values but that's pretty much

00:18:40,230 --> 00:18:47,340
the extent of indexing in in for Python

00:18:44,040 --> 00:18:49,380
lists now you can do the same thing with

00:18:47,340 --> 00:18:52,770
with numpy arrays if we turn this array

00:18:49,380 --> 00:18:55,470
this list into an array we can now take

00:18:52,770 --> 00:18:58,380
an integer index we can ask for l0 and

00:18:55,470 --> 00:19:00,840
we get back that first element we can

00:18:58,380 --> 00:19:03,570
ask for a slice of the array and we get

00:19:00,840 --> 00:19:08,340
get back another array that contains

00:19:03,570 --> 00:19:11,130
those elements but numpy actually offers

00:19:08,340 --> 00:19:13,170
a lot of other fast ways and convenient

00:19:11,130 --> 00:19:15,570
ways to do this sort of indexing and to

00:19:13,170 --> 00:19:18,150
index more complicated chunks of the

00:19:15,570 --> 00:19:19,950
array and chunks of data and one of

00:19:18,150 --> 00:19:22,170
those is masking and this is this is

00:19:19,950 --> 00:19:26,070
actually really really useful if you

00:19:22,170 --> 00:19:28,950
take an array of boolean values you can

00:19:26,070 --> 00:19:30,930
index the you can index an array with

00:19:28,950 --> 00:19:33,420
another array of boolean values and it

00:19:30,930 --> 00:19:36,000
treats it as a mask so basically here

00:19:33,420 --> 00:19:37,590
the the two lines up with the false the

00:19:36,000 --> 00:19:39,810
three lines up with the true the five

00:19:37,590 --> 00:19:41,850
lines up with the true and only the

00:19:39,810 --> 00:19:44,490
values which line up with throughs in

00:19:41,850 --> 00:19:47,640
that mask are returned by the indexing

00:19:44,490 --> 00:19:49,770
operation this might seem you know a

00:19:47,640 --> 00:19:51,480
little bit like why would you need to do

00:19:49,770 --> 00:19:53,610
this where this becomes really useful is

00:19:51,480 --> 00:19:56,400
when you combine it with some of the you

00:19:53,610 --> 00:19:58,590
funks that we saw earlier so for example

00:19:56,400 --> 00:20:00,210
here we're going to create a mask where

00:19:58,590 --> 00:20:00,720
we're going to say we want all the

00:20:00,210 --> 00:20:03,179
places

00:20:00,720 --> 00:20:05,309
where L is less than four so the value

00:20:03,179 --> 00:20:07,650
in the list is less than four and then

00:20:05,309 --> 00:20:09,450
we use the bitwise or operator and we

00:20:07,650 --> 00:20:13,110
say we want places where it's less than

00:20:09,450 --> 00:20:15,299
four or greater than eight and we apply

00:20:13,110 --> 00:20:18,140
that mask and it returns all the values

00:20:15,299 --> 00:20:20,520
in the list that satisfy those criteria

00:20:18,140 --> 00:20:23,280
so now instead of writing a loop over

00:20:20,520 --> 00:20:26,340
the list and saying you know for for

00:20:23,280 --> 00:20:28,470
item in list if item is less than four

00:20:26,340 --> 00:20:30,210
or item is greater than eight append it

00:20:28,470 --> 00:20:31,530
to the result this just happens

00:20:30,210 --> 00:20:33,690
automatically it happens in a couple

00:20:31,530 --> 00:20:36,960
lines of code and it's much much faster

00:20:33,690 --> 00:20:40,710
than the equivalent Python by hand

00:20:36,960 --> 00:20:43,950
version another another useful way of

00:20:40,710 --> 00:20:45,990
accessing elements is fancy indexing and

00:20:43,950 --> 00:20:49,289
fancy indexing is just basically passing

00:20:45,990 --> 00:20:50,970
a list or array of index in indices so

00:20:49,289 --> 00:20:52,559
if we want the zeroth element the fourth

00:20:50,970 --> 00:20:54,539
element and the second element from the

00:20:52,559 --> 00:20:57,929
array we just put those indices in a

00:20:54,539 --> 00:20:59,850
list and we pass that list to the to the

00:20:57,929 --> 00:21:02,130
array index and we get out the values

00:20:59,850 --> 00:21:04,440
and again we don't have to write a loop

00:21:02,130 --> 00:21:06,360
over all these indices we just pass them

00:21:04,440 --> 00:21:09,990
all at once and it's much quicker than

00:21:06,360 --> 00:21:12,150
writing the Python loop and finally

00:21:09,990 --> 00:21:14,340
these these can all be combined for

00:21:12,150 --> 00:21:17,039
multiple dimension multi-dimensional

00:21:14,340 --> 00:21:20,400
arrays so multi-dimensional arrays you

00:21:17,039 --> 00:21:23,159
can access by row comma column the

00:21:20,400 --> 00:21:26,130
indices the data that you want so if we

00:21:23,159 --> 00:21:30,350
pass 0 comma 1 we're asking for the row

00:21:26,130 --> 00:21:32,549
0 and column 1 and that is the value 1

00:21:30,350 --> 00:21:34,770
we can go further and we can combine

00:21:32,549 --> 00:21:37,320
slices and indices so here we're asking

00:21:34,770 --> 00:21:39,750
for all rows the the colon means an

00:21:37,320 --> 00:21:42,210
empty slice we're asking for all rows

00:21:39,750 --> 00:21:44,820
and we're asking for column number 1 so

00:21:42,210 --> 00:21:47,940
we get 1/4 which is that that's 2nd

00:21:44,820 --> 00:21:50,460
column in the matrix we can even do

00:21:47,940 --> 00:21:52,440
things like masking on the these

00:21:50,460 --> 00:21:53,909
multi-dimensional arrays if we here

00:21:52,440 --> 00:21:56,460
we're doing kind of a compound a poor

00:21:53,909 --> 00:21:58,350
operation we're saying M minus 3 so

00:21:56,460 --> 00:22:00,630
that's a you func that supplies element

00:21:58,350 --> 00:22:02,340
wise taking the absolute value of that

00:22:00,630 --> 00:22:04,350
another you func which applies element

00:22:02,340 --> 00:22:07,200
wise we're asking where that's less than

00:22:04,350 --> 00:22:08,940
2 so that returns a boolean mask element

00:22:07,200 --> 00:22:11,159
wise telling us where that condition is

00:22:08,940 --> 00:22:13,600
met and what we get out is an array of

00:22:11,159 --> 00:22:17,070
just the values that meet that condition

00:22:13,600 --> 00:22:19,929
where m -3 absolute value is less than 2

00:22:17,070 --> 00:22:24,789
so all this happens under the hood in

00:22:19,929 --> 00:22:26,650
compiled code very very quickly and now

00:22:24,789 --> 00:22:28,270
it gets even even more interesting we

00:22:26,650 --> 00:22:30,910
can start doing things like combining

00:22:28,270 --> 00:22:32,919
fancy indexing and slicing so here we're

00:22:30,910 --> 00:22:35,200
doing fancy indexing of the rows and

00:22:32,919 --> 00:22:38,140
slicing of the columns and we get out

00:22:35,200 --> 00:22:41,380
the row number 1 followed by row number

00:22:38,140 --> 00:22:44,370
0 and we get the slice of the first two

00:22:41,380 --> 00:22:47,140
elements so this happens very fast and

00:22:44,370 --> 00:22:48,760
we can do things like mixing masking and

00:22:47,140 --> 00:22:49,960
slicing so here what we're going to do

00:22:48,760 --> 00:22:51,730
is we're going to combine one of these

00:22:49,960 --> 00:22:53,710
aggregates we're going to sum along

00:22:51,730 --> 00:22:56,380
access equals 1 so we're summing along

00:22:53,710 --> 00:22:58,900
the rows and we're asking where the sum

00:22:56,380 --> 00:23:01,360
of the row is greater than 4 and we're

00:22:58,900 --> 00:23:04,000
going to pass that as a mask so that

00:23:01,360 --> 00:23:06,539
gives us one of the two rows and then in

00:23:04,000 --> 00:23:09,190
those rows that are returned we want

00:23:06,539 --> 00:23:12,010
elements starting at index 1 and the

00:23:09,190 --> 00:23:14,260
columns so we get out 4 comma 5 because

00:23:12,010 --> 00:23:17,200
that second row has a sum greater than 4

00:23:14,260 --> 00:23:18,730
and we get those second two elements so

00:23:17,200 --> 00:23:20,679
you can start to see by combining all

00:23:18,730 --> 00:23:22,270
these different things together putting

00:23:20,679 --> 00:23:24,539
them and composing them and putting them

00:23:22,270 --> 00:23:27,450
together in different ways you have a

00:23:24,539 --> 00:23:29,500
nearly limitless number of operations

00:23:27,450 --> 00:23:31,870
fundamental operations that you can do

00:23:29,500 --> 00:23:34,870
very very quickly that's scale very well

00:23:31,870 --> 00:23:37,059
to large arrays and large data sets and

00:23:34,870 --> 00:23:38,830
you don't have to write a single Python

00:23:37,059 --> 00:23:42,250
loop the whole time as you're going over

00:23:38,830 --> 00:23:44,320
this data so as a last little thing I

00:23:42,250 --> 00:23:47,260
want to give an example of computing

00:23:44,320 --> 00:23:49,480
nearest neighbors so imagine we have a

00:23:47,260 --> 00:23:51,400
bunch of points floating out there in

00:23:49,480 --> 00:23:53,110
space and we want to compute for each of

00:23:51,400 --> 00:23:57,010
those points which is the nearest

00:23:53,110 --> 00:23:59,559
neighbor of that point now you could do

00:23:57,010 --> 00:24:01,720
it basically the what we're going to do

00:23:59,559 --> 00:24:04,120
is compute the Euclidean distance so for

00:24:01,720 --> 00:24:06,460
each point we need each point I we need

00:24:04,120 --> 00:24:08,620
to look at another point J we need to

00:24:06,460 --> 00:24:11,350
take a difference of the X's difference

00:24:08,620 --> 00:24:13,059
of the Y's square them and then that'll

00:24:11,350 --> 00:24:15,159
give us the square distance between them

00:24:13,059 --> 00:24:17,350
right so the naive way to do this would

00:24:15,159 --> 00:24:19,659
be to do for I and range n for J and

00:24:17,350 --> 00:24:21,669
range n for k and range number of

00:24:19,659 --> 00:24:22,929
dimensions so you have three loops and

00:24:21,669 --> 00:24:25,150
then you do this thing and you keep

00:24:22,929 --> 00:24:27,430
track of it right so it's it starts to

00:24:25,150 --> 00:24:29,140
become a headache and keeping track

00:24:27,430 --> 00:24:31,480
indices and also you have all these slow

00:24:29,140 --> 00:24:34,900
Python loops but let's see if we can do

00:24:31,480 --> 00:24:36,280
this in numpy with putting together all

00:24:34,900 --> 00:24:38,800
these techniques that we've been talking

00:24:36,280 --> 00:24:40,210
about so here if you're used to

00:24:38,800 --> 00:24:42,760
scikit-learn or some of these other

00:24:40,210 --> 00:24:44,620
other libraries this is the way that we

00:24:42,760 --> 00:24:47,110
do multi-dimensional data this is a

00:24:44,620 --> 00:24:50,050
thousand points in three dimensions it's

00:24:47,110 --> 00:24:52,600
a thousand thousand by three dimensional

00:24:50,050 --> 00:24:56,110
array the first thing we'll do is we'll

00:24:52,600 --> 00:24:59,500
use broadcasting to get the differences

00:24:56,110 --> 00:25:02,140
between different pairs of dimensions so

00:24:59,500 --> 00:25:03,790
we reshape this X array and subtract X

00:25:02,140 --> 00:25:05,350
from it and if you follow the

00:25:03,790 --> 00:25:07,150
broadcasting rules what comes out is a

00:25:05,350 --> 00:25:09,940
thousand by thousand by three array so

00:25:07,150 --> 00:25:12,520
that says for point I and point J and

00:25:09,940 --> 00:25:15,850
dimension K what's the difference

00:25:12,520 --> 00:25:18,250
between those dimensions now of course

00:25:15,850 --> 00:25:20,410
we want to aggregate this we want to sum

00:25:18,250 --> 00:25:22,210
across those differences so we square

00:25:20,410 --> 00:25:24,760
these differences and we take the sum

00:25:22,210 --> 00:25:27,040
along the second dimension and that

00:25:24,760 --> 00:25:29,310
gives us a thousand by thousand matrix

00:25:27,040 --> 00:25:32,950
and this thousand by thousand matrix

00:25:29,310 --> 00:25:34,660
point our item IJ and there is the

00:25:32,950 --> 00:25:37,180
distance the squared distance between

00:25:34,660 --> 00:25:38,860
the ice point and the J point right we

00:25:37,180 --> 00:25:39,280
haven't written any loops yet so this is

00:25:38,860 --> 00:25:41,290
great

00:25:39,280 --> 00:25:44,230
now we need to figure out which is the

00:25:41,290 --> 00:25:46,870
minimum but the problem is every point

00:25:44,230 --> 00:25:49,270
is zero distance from itself right so

00:25:46,870 --> 00:25:50,530
let's hack this a little bit and we're

00:25:49,270 --> 00:25:53,320
going to set the diagonal of the matrix

00:25:50,530 --> 00:25:55,600
to infinity so we can do this with fancy

00:25:53,320 --> 00:25:57,490
indexing we want we want point zero zero

00:25:55,600 --> 00:25:59,260
to be infinity we will point point one

00:25:57,490 --> 00:26:00,550
one to be infinity and we go all the way

00:25:59,260 --> 00:26:06,990
through and we can do that with this

00:26:00,550 --> 00:26:06,990
arrange command that's very strange and

00:26:07,290 --> 00:26:13,510
once we have that we want to do a an

00:26:11,170 --> 00:26:15,790
aggregation across this array so we ask

00:26:13,510 --> 00:26:17,740
for not the minimum value but the

00:26:15,790 --> 00:26:19,990
argument we want to know the index of

00:26:17,740 --> 00:26:21,700
the minimum value and we get that out

00:26:19,990 --> 00:26:23,260
and we get the index of the minimum

00:26:21,700 --> 00:26:25,420
value which is the nearest neighbor of

00:26:23,260 --> 00:26:26,560
every point on this data set and just to

00:26:25,420 --> 00:26:28,840
double-check that we're doing the right

00:26:26,560 --> 00:26:30,820
thing we can pull in scikit-learn

00:26:28,840 --> 00:26:32,140
nearest neighbors and just do the

00:26:30,820 --> 00:26:34,900
nearest neighbors thing there and we get

00:26:32,140 --> 00:26:36,670
the same result out so this shows you

00:26:34,900 --> 00:26:38,620
that we have we've just done this huge

00:26:36,670 --> 00:26:40,570
operation that if you naively did it it

00:26:38,620 --> 00:26:41,110
would take a lot of loops but we did it

00:26:40,570 --> 00:26:45,220
with just

00:26:41,110 --> 00:26:47,830
a couple broadcasting and you funk and

00:26:45,220 --> 00:26:50,290
and aggregation commands and numpy and

00:26:47,830 --> 00:26:51,970
it'll happen really really fast in fact

00:26:50,290 --> 00:26:53,559
if you look at the nearest neighbors

00:26:51,970 --> 00:26:55,540
code the brute-force algorithm in

00:26:53,559 --> 00:26:59,350
scikit-learn this is essentially what it

00:26:55,540 --> 00:27:01,090
does under the hood so in a quick

00:26:59,350 --> 00:27:03,160
summary I want to leave you with this

00:27:01,090 --> 00:27:04,960
writing Python is fast writing it and

00:27:03,160 --> 00:27:07,000
developing in Python is fast but loops

00:27:04,960 --> 00:27:09,700
in particular can be really really slow

00:27:07,000 --> 00:27:12,610
so if you're looping over large data

00:27:09,700 --> 00:27:15,100
sets the best thing to do is to use the

00:27:12,610 --> 00:27:16,600
numpy package and try to get rid of

00:27:15,100 --> 00:27:18,910
those loops by using some of these

00:27:16,600 --> 00:27:20,350
strategies using the you funks for

00:27:18,910 --> 00:27:23,169
element wise operations using

00:27:20,350 --> 00:27:27,280
aggregations to summarize parts of the

00:27:23,169 --> 00:27:29,500
array using broadcasting to to combine

00:27:27,280 --> 00:27:31,690
arrays of different sizes and then using

00:27:29,500 --> 00:27:34,270
slicing masking and fancy indexing to

00:27:31,690 --> 00:27:37,570
access parts of arrays very very quickly

00:27:34,270 --> 00:27:38,980
and I'm going to leave it at that if

00:27:37,570 --> 00:27:41,350
you're interested in these slides you

00:27:38,980 --> 00:27:43,780
can go to my Twitter account Jake VDP

00:27:41,350 --> 00:27:45,669
and about half an hour ago I tweeted a

00:27:43,780 --> 00:27:46,840
link to the slides on speaker deck so

00:27:45,669 --> 00:27:49,030
you should be able to find them there

00:27:46,840 --> 00:27:52,710
and I think we have a few minutes for

00:27:49,030 --> 00:27:52,710
questions so thank you very much

00:27:55,990 --> 00:28:00,230
all right thank you very much we have

00:27:58,280 --> 00:28:02,150
just a minute or two for questions for

00:28:00,230 --> 00:28:05,840
Jake if you want to go ahead and ask one

00:28:02,150 --> 00:28:09,830
any questions see somebody sneaking

00:28:05,840 --> 00:28:12,230
towards the microphone ah hi Thank You

00:28:09,830 --> 00:28:13,910
great talk yeah um I'm so one of the

00:28:12,230 --> 00:28:16,610
things that I always get confused about

00:28:13,910 --> 00:28:19,970
so a number of your examples where you

00:28:16,610 --> 00:28:21,320
did the the reduc the mast and the fancy

00:28:19,970 --> 00:28:25,580
indexing combining all these things

00:28:21,320 --> 00:28:28,310
together the input started out as a say

00:28:25,580 --> 00:28:29,930
a two-dimensional array mm-hm but then

00:28:28,310 --> 00:28:31,670
when you did the masking you pulled out

00:28:29,930 --> 00:28:33,350
a strange subset of them and then the

00:28:31,670 --> 00:28:37,550
result ended up being a one-dimensional

00:28:33,350 --> 00:28:38,750
array right and so I'm so this is

00:28:37,550 --> 00:28:41,240
there's a sense in which sometimes

00:28:38,750 --> 00:28:45,020
that's kind of counterintuitive yeah

00:28:41,240 --> 00:28:46,430
yeah so in in that situation if you know

00:28:45,020 --> 00:28:49,250
if you're only pulling out a few values

00:28:46,430 --> 00:28:51,110
from a two-dimensional array there's no

00:28:49,250 --> 00:28:53,810
way to keep the dimensions unless you

00:28:51,110 --> 00:28:55,040
have some sort of sparse output right so

00:28:53,810 --> 00:28:57,260
if you're going to have a dense output

00:28:55,040 --> 00:28:59,750
that that's why it does just a single

00:28:57,260 --> 00:29:03,140
array out like that but you can do

00:28:59,750 --> 00:29:06,140
things like if if your index mask is

00:29:03,140 --> 00:29:10,550
multi dimensional you can actually pull

00:29:06,140 --> 00:29:12,710
out you can pull out a result of multi

00:29:10,550 --> 00:29:15,260
dimensions it'll the result will follow

00:29:12,710 --> 00:29:18,050
the shape of the index so is the default

00:29:15,260 --> 00:29:19,280
rule that it'll I guess it's assuming

00:29:18,050 --> 00:29:21,140
like you're either doing row or column

00:29:19,280 --> 00:29:24,380
major based indexing and it's just

00:29:21,140 --> 00:29:25,520
pulling those out in in whatever order

00:29:24,380 --> 00:29:30,110
it would be stored in memory

00:29:25,520 --> 00:29:32,540
um it's yes essentially that's that's

00:29:30,110 --> 00:29:34,190
what it does it uses the the internal

00:29:32,540 --> 00:29:35,810
storage of the matrix okay all right

00:29:34,190 --> 00:29:36,440
thank you I think we have time for one

00:29:35,810 --> 00:29:39,260
more question

00:29:36,440 --> 00:29:41,300
are you going to be and I'll stand

00:29:39,260 --> 00:29:42,260
around afterwards he'll we'll push them

00:29:41,300 --> 00:29:44,150
out the room and you'll stand around

00:29:42,260 --> 00:29:47,300
afterwards perhaps you can do an open

00:29:44,150 --> 00:29:49,970
space yeah so this is this seems like a

00:29:47,300 --> 00:29:51,710
great way to shrink the time of your

00:29:49,970 --> 00:29:53,840
loops but the loops are still there

00:29:51,710 --> 00:29:56,300
inside numpy correct so if you have a

00:29:53,840 --> 00:29:57,170
high algorithmic complexity it'll still

00:29:56,300 --> 00:29:58,640
come out in the end

00:29:57,170 --> 00:30:00,470
right absolutely so if you have an N

00:29:58,640 --> 00:30:02,420
squared algorithm you're still doing N

00:30:00,470 --> 00:30:04,580
squared evaluations but those are

00:30:02,420 --> 00:30:06,200
happening in the compiled layer that so

00:30:04,580 --> 00:30:08,540
you don't get the overhead of the pie

00:30:06,200 --> 00:30:10,490
phone type-checking okay thank you hmm

00:30:08,540 --> 00:30:13,600
excellent thank you very much thank you

00:30:10,490 --> 00:30:13,600

YouTube URL: https://www.youtube.com/watch?v=EEUXKG97YRw


