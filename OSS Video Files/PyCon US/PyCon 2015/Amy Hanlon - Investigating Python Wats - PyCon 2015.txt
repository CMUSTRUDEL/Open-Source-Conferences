Title: Amy Hanlon - Investigating Python Wats - PyCon 2015
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	"Speaker: Amy Hanlon

Many of us have experienced a ""wat"" in Python - some behavior that totally mystifies us. We'll look at three areas where wats arise - identity, mutability, and scope. For each of these three topics, we'll look at some common surprising behaviors, investigate the cause of the behaviors, and cover some practical tips on how to avoid related bugs.

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:06,140 --> 00:00:10,730
good morning everyone

00:00:08,240 --> 00:00:12,320
be all having a great day here so far

00:00:10,730 --> 00:00:14,219
yes

00:00:12,320 --> 00:00:17,039
what are you go back to hotel and take a

00:00:14,219 --> 00:00:17,760
nap come on all right there we go

00:00:17,039 --> 00:00:20,730
awesome

00:00:17,760 --> 00:00:22,529
so our first second talk today um well I

00:00:20,730 --> 00:00:25,170
guess our first non keynote talk today

00:00:22,529 --> 00:00:26,730
is by Amy Halen she is an engineer at

00:00:25,170 --> 00:00:28,920
venmo and she's an alum of the ricoeur

00:00:26,730 --> 00:00:31,859
Center and she's going to be talking to

00:00:28,920 --> 00:00:34,920
us about investigating Python watts I

00:00:31,859 --> 00:00:37,129
hope I pronounced that properly hello

00:00:34,920 --> 00:00:40,920
can you hear me

00:00:37,129 --> 00:00:43,170
cool so like you said I am Amy Hanlon

00:00:40,920 --> 00:00:47,160
and today I'd like to investigate some

00:00:43,170 --> 00:00:49,469
Python wax with you I work at venmo as

00:00:47,160 --> 00:00:51,000
an engineer I am also an alum of the

00:00:49,469 --> 00:00:53,640
recurse Center which you might know

00:00:51,000 --> 00:00:56,820
instead as hacker school and here's

00:00:53,640 --> 00:00:58,590
where you can find me on the Internet so

00:00:56,820 --> 00:01:01,739
first let's talk about what is a watt

00:00:58,590 --> 00:01:03,120
what do I mean by this thing so really

00:01:01,739 --> 00:01:06,180
what I mean is a surprising or

00:01:03,120 --> 00:01:08,280
unexpected behavior in Python some

00:01:06,180 --> 00:01:09,869
people might call them gotchas a quick

00:01:08,280 --> 00:01:13,140
show of hands here who has seen Gary

00:01:09,869 --> 00:01:14,670
Bernhardt SWAT lightning talk great okay

00:01:13,140 --> 00:01:15,900
so you're exactly the kind of people

00:01:14,670 --> 00:01:18,240
that I want to talk to if you haven't

00:01:15,900 --> 00:01:20,250
that's totally okay - not a prerequisite

00:01:18,240 --> 00:01:23,490
but it takes like four minutes to watch

00:01:20,250 --> 00:01:25,950
and I highly recommend it so for this

00:01:23,490 --> 00:01:27,900
talk what I want to do is go over some

00:01:25,950 --> 00:01:29,520
of these sort of like classic surprising

00:01:27,900 --> 00:01:31,560
behaviors in Python that might cause

00:01:29,520 --> 00:01:33,390
bugs and your programs when you are new

00:01:31,560 --> 00:01:37,500
to the language and really spend the

00:01:33,390 --> 00:01:39,150
time investigating why they happen so

00:01:37,500 --> 00:01:40,979
the surprising behavior is that I will

00:01:39,150 --> 00:01:43,860
go over today can be loosely grouped

00:01:40,979 --> 00:01:44,820
into three categories identity meaning

00:01:43,860 --> 00:01:49,170
object identity

00:01:44,820 --> 00:01:52,350
mutability and scope so first let's talk

00:01:49,170 --> 00:01:54,299
about object identity and we're going to

00:01:52,350 --> 00:01:56,670
illustrate this with a few examples to

00:01:54,299 --> 00:01:58,409
start out with so let's do a bit of

00:01:56,670 --> 00:02:00,930
trivia and hopefully we can make this

00:01:58,409 --> 00:02:03,149
interactive so let's try with the

00:02:00,930 --> 00:02:05,369
example we fire up our trusty C Python

00:02:03,149 --> 00:02:08,789
interpreter and we type in three

00:02:05,369 --> 00:02:12,370
different lines a equals 256 B also

00:02:08,789 --> 00:02:14,470
equals 256 and then we ask a is

00:02:12,370 --> 00:02:18,849
show of hands sir who thinks that this

00:02:14,470 --> 00:02:21,849
will evaluate to true cool and who

00:02:18,849 --> 00:02:24,160
thinks that will evaluate to false great

00:02:21,849 --> 00:02:28,330
5050 so like some of you might learn

00:02:24,160 --> 00:02:30,610
something today which is great true cool

00:02:28,330 --> 00:02:33,400
maybe this is surprising I guess to half

00:02:30,610 --> 00:02:37,110
of you it might be let's do another

00:02:33,400 --> 00:02:39,849
quick example so what if we say instead

00:02:37,110 --> 00:02:42,150
257 so the only difference between this

00:02:39,849 --> 00:02:44,080
slide is that we went one number bigger

00:02:42,150 --> 00:02:46,180
so we're still in the sea Python

00:02:44,080 --> 00:02:50,620
interpreter the first line we say a

00:02:46,180 --> 00:02:53,950
equals 257 second line B equals 257 and

00:02:50,620 --> 00:02:57,579
then we ask a is B raise our hand if you

00:02:53,950 --> 00:02:59,500
think it'll be true I kind of I think my

00:02:57,579 --> 00:03:02,170
maybe I gave it away so raise our head

00:02:59,500 --> 00:03:05,260
if you think it'll be false yeah so this

00:03:02,170 --> 00:03:07,950
is false so like what really I don't

00:03:05,260 --> 00:03:10,269
have any images of Darth vader-like

00:03:07,950 --> 00:03:13,720
like getting water out of the ocean and

00:03:10,269 --> 00:03:16,709
filtering it but hopefully it'll still

00:03:13,720 --> 00:03:18,700
be fun regardless so this is weird right

00:03:16,709 --> 00:03:21,519
so let's take a minute to really

00:03:18,700 --> 00:03:23,560
investigate what's happening here so

00:03:21,519 --> 00:03:25,750
this example is actually a quirk of the

00:03:23,560 --> 00:03:27,780
c python implementation of Python some

00:03:25,750 --> 00:03:30,910
implementations behave a bit differently

00:03:27,780 --> 00:03:33,370
but when you fire up your trusty C

00:03:30,910 --> 00:03:35,380
Python interpreter before you're even

00:03:33,370 --> 00:03:37,750
given your prompt the interpreter will

00:03:35,380 --> 00:03:40,780
create an array containing the integers

00:03:37,750 --> 00:03:43,720
between negative 5 and 256 so these are

00:03:40,780 --> 00:03:46,569
kind of interned in a sense so when you

00:03:43,720 --> 00:03:49,660
write a statement like a equals 257

00:03:46,569 --> 00:03:54,849
that's binding the name a to the integer

00:03:49,660 --> 00:03:56,829
value 256 R sorry 256 that has already

00:03:54,849 --> 00:03:59,530
been stored in memory for you in this

00:03:56,829 --> 00:04:02,319
array of integers so it does this rather

00:03:59,530 --> 00:04:05,859
than creating a new integer object which

00:04:02,319 --> 00:04:09,190
you might expect so then when you type B

00:04:05,859 --> 00:04:10,660
equals 256 the interpreter is smart

00:04:09,190 --> 00:04:12,340
enough to know that it already has this

00:04:10,660 --> 00:04:14,470
number stored in this array that it

00:04:12,340 --> 00:04:16,389
created for you when you started the

00:04:14,470 --> 00:04:21,390
Python interpreter so you bind the name

00:04:16,389 --> 00:04:24,610
B to the same integer 256 and that array

00:04:21,390 --> 00:04:27,460
then when we saw when we type in a

00:04:24,610 --> 00:04:29,500
is be this evaluates to true because is

00:04:27,460 --> 00:04:31,689
is really testing for object identity is

00:04:29,500 --> 00:04:36,669
this the exact same object that's stored

00:04:31,689 --> 00:04:39,370
in memory for the 257 example this

00:04:36,669 --> 00:04:41,710
happens to be outside of the array of

00:04:39,370 --> 00:04:45,009
integers that we initialize when we

00:04:41,710 --> 00:04:46,930
start the interpreter so we create a new

00:04:45,009 --> 00:04:49,509
instance of the integer class give the

00:04:46,930 --> 00:04:53,199
value 257 and store it in a different

00:04:49,509 --> 00:04:55,750
place in memory and then when a type b

00:04:53,199 --> 00:04:57,669
equals 257 the interpreter isn't smart

00:04:55,750 --> 00:05:00,219
enough at this point to know that we've

00:04:57,669 --> 00:05:03,069
already created an integer of the value

00:05:00,219 --> 00:05:05,050
257 so we create a new one we also store

00:05:03,069 --> 00:05:09,759
that in memory and we bind the name a to

00:05:05,050 --> 00:05:11,199
it so when we type a is b this evaluates

00:05:09,759 --> 00:05:13,629
to false because they're two different

00:05:11,199 --> 00:05:17,319
objects stored in memory even though

00:05:13,629 --> 00:05:20,110
they happen to have the same value so

00:05:17,319 --> 00:05:22,360
let's do another example what if on the

00:05:20,110 --> 00:05:26,919
same line and the interpreter we type A

00:05:22,360 --> 00:05:29,319
equals 257 and B equals 257 and then we

00:05:26,919 --> 00:05:32,370
ask a is B raise your hand if you think

00:05:29,319 --> 00:05:34,839
this will be true cool

00:05:32,370 --> 00:05:36,009
raise your hand oh no I gave it away

00:05:34,839 --> 00:05:38,080
okay it's alright

00:05:36,009 --> 00:05:40,180
that's right it is true some of you were

00:05:38,080 --> 00:05:41,889
right I don't know if the others in the

00:05:40,180 --> 00:05:44,139
audience were hesitant or thought it

00:05:41,889 --> 00:05:46,539
would be false but that's okay I'll just

00:05:44,139 --> 00:05:49,419
default to you learning something which

00:05:46,539 --> 00:05:50,979
is good okay so when they're defined on

00:05:49,419 --> 00:05:53,620
a separate line let's look at these like

00:05:50,979 --> 00:05:57,279
two examples side by side when they're

00:05:53,620 --> 00:05:59,169
defined on separate lines then a is B

00:05:57,279 --> 00:06:01,509
evaluates to false and when they're

00:05:59,169 --> 00:06:05,500
defined on the same line a is B

00:06:01,509 --> 00:06:08,800
evaluates to true what right what's

00:06:05,500 --> 00:06:10,960
going on here umm so let's talk about

00:06:08,800 --> 00:06:14,110
code objects to really illustrate this

00:06:10,960 --> 00:06:16,360
example when you type a line of code and

00:06:14,110 --> 00:06:18,069
the interpreter press ENTER and you get

00:06:16,360 --> 00:06:20,169
your prompt back that means the

00:06:18,069 --> 00:06:23,289
interpreter has compiled a code object

00:06:20,169 --> 00:06:25,750
for you so we can get a handle on this

00:06:23,289 --> 00:06:28,389
code object by defining our source code

00:06:25,750 --> 00:06:31,659
and a string and then using the built-in

00:06:28,389 --> 00:06:34,120
function compile and this will return a

00:06:31,659 --> 00:06:36,639
code object for us we passed some

00:06:34,120 --> 00:06:37,860
arguments like our source code also a

00:06:36,639 --> 00:06:42,210
file name and Moe

00:06:37,860 --> 00:06:44,129
but let's not focus on those so now that

00:06:42,210 --> 00:06:45,930
we have a handle on this code object

00:06:44,129 --> 00:06:48,569
there are some attributes to find on it

00:06:45,930 --> 00:06:51,330
one of those attributes is ko underscore

00:06:48,569 --> 00:06:53,430
constants and this is the constants

00:06:51,330 --> 00:06:55,409
defined in our statement the important

00:06:53,430 --> 00:06:58,949
part here is this first element of the

00:06:55,409 --> 00:07:04,020
tuple 357 the nan is just there because

00:06:58,949 --> 00:07:07,469
it's like the implicit return ok so then

00:07:04,020 --> 00:07:10,560
when we look at the code object for our

00:07:07,469 --> 00:07:12,300
second line of code the B equals 257 we

00:07:10,560 --> 00:07:14,580
can similarly use the built-in compile

00:07:12,300 --> 00:07:16,650
function to get a handle on it and look

00:07:14,580 --> 00:07:18,680
at the constants that are defined inside

00:07:16,650 --> 00:07:21,930
that code object and this has another

00:07:18,680 --> 00:07:23,879
257 in it so the main point that I want

00:07:21,930 --> 00:07:26,460
to illustrate here is that we have two

00:07:23,879 --> 00:07:27,930
separate code objects and that means the

00:07:26,460 --> 00:07:30,090
interpreter has gone through the phase

00:07:27,930 --> 00:07:30,930
of parsing all the way down to compiling

00:07:30,090 --> 00:07:33,539
into bytecode

00:07:30,930 --> 00:07:35,490
these two different lines and we don't

00:07:33,539 --> 00:07:38,669
really give the interpreter the chance

00:07:35,490 --> 00:07:41,099
to optimize between these two different

00:07:38,669 --> 00:07:44,550
code objects so when we define

00:07:41,099 --> 00:07:47,400
everything on the same line we get one

00:07:44,550 --> 00:07:49,080
code object and we can also get a handle

00:07:47,400 --> 00:07:52,680
on this code object using the compile

00:07:49,080 --> 00:07:54,360
built-in function and similarly we can

00:07:52,680 --> 00:07:58,529
look at its constants and there's only

00:07:54,360 --> 00:08:00,330
one 257 here so the interpreter has been

00:07:58,529 --> 00:08:05,759
given a chance to be kind of smart and

00:08:00,330 --> 00:08:07,770
only create one okay so we covered

00:08:05,759 --> 00:08:10,080
identity where we saw how the c python

00:08:07,770 --> 00:08:12,659
interpreter stores an array of integers

00:08:10,080 --> 00:08:14,939
for you when it's initialized and also

00:08:12,659 --> 00:08:17,909
how two objects can have the same value

00:08:14,939 --> 00:08:21,629
but different object identity now we're

00:08:17,909 --> 00:08:24,180
going to talk about mutability okay so

00:08:21,629 --> 00:08:26,759
suppose we wanted to build a tic-tac-toe

00:08:24,180 --> 00:08:29,610
board and we started by creating a

00:08:26,759 --> 00:08:32,039
representation of a row in the board and

00:08:29,610 --> 00:08:34,579
an empty string is gonna mean no one has

00:08:32,039 --> 00:08:37,019
claimed that spot yet on the board and

00:08:34,579 --> 00:08:40,579
so we create this row and really it's

00:08:37,019 --> 00:08:43,440
just a list of three empty strings and

00:08:40,579 --> 00:08:46,740
then we'd like our board to be a list

00:08:43,440 --> 00:08:48,750
containing three rows which we can do by

00:08:46,740 --> 00:08:50,730
creating a list with one row and

00:08:48,750 --> 00:08:54,360
multiplying it by three kind

00:08:50,730 --> 00:08:56,610
how we built the row cool so our board

00:08:54,360 --> 00:09:01,170
looks like this it's empty no one has

00:08:56,610 --> 00:09:02,880
claimed any spaces yet and it is the

00:09:01,170 --> 00:09:04,709
board itself is a list with three

00:09:02,880 --> 00:09:07,740
elements and each element in this list

00:09:04,709 --> 00:09:09,990
is a list with three elements so to

00:09:07,740 --> 00:09:12,060
illustrate that we can grab the top row

00:09:09,990 --> 00:09:15,360
of the board by grabbing the first

00:09:12,060 --> 00:09:17,010
element and we can grab the top left

00:09:15,360 --> 00:09:20,970
square of the board by grabbing the

00:09:17,010 --> 00:09:22,649
first element of the top row so let's

00:09:20,970 --> 00:09:24,980
say we want to start playing and we want

00:09:22,649 --> 00:09:27,510
player X to claim the top left square

00:09:24,980 --> 00:09:32,070
and we can do that by assigning the

00:09:27,510 --> 00:09:34,290
string X to the top left square so then

00:09:32,070 --> 00:09:37,350
when we display the board what do you

00:09:34,290 --> 00:09:39,389
think it will look like totally

00:09:37,350 --> 00:09:41,250
reasonable like our expectation here is

00:09:39,389 --> 00:09:43,250
that there's an X in the top left square

00:09:41,250 --> 00:09:45,420
right only one person has made a move

00:09:43,250 --> 00:09:49,769
but I see some of you shaking your head

00:09:45,420 --> 00:09:53,040
no what x wins this is like the easiest

00:09:49,769 --> 00:09:54,660
game of tic-tac-toe ever or I guess it's

00:09:53,040 --> 00:09:56,370
like a matter of perspective right like

00:09:54,660 --> 00:09:57,959
if we were oh it would be the hardest

00:09:56,370 --> 00:10:02,959
tic-tac-toe game ever you could just

00:09:57,959 --> 00:10:06,510
never win what so what's happening here

00:10:02,959 --> 00:10:08,040
so here I have a chart and this is going

00:10:06,510 --> 00:10:11,100
to sort of be like an abstraction of

00:10:08,040 --> 00:10:13,649
what's happening in memory so the first

00:10:11,100 --> 00:10:15,569
line of code that we type in is row

00:10:13,649 --> 00:10:18,000
equals it's empty string and a list

00:10:15,569 --> 00:10:20,880
times three and what that does is bind

00:10:18,000 --> 00:10:22,440
the name row to this list containing

00:10:20,880 --> 00:10:27,389
three elements that we're storing in

00:10:22,440 --> 00:10:30,569
memory so now when we create a new list

00:10:27,389 --> 00:10:33,360
board with three elements each of those

00:10:30,569 --> 00:10:36,000
elements is a reference to the same list

00:10:33,360 --> 00:10:40,230
that row references and that's just how

00:10:36,000 --> 00:10:42,060
like multiplying lists works here so we

00:10:40,230 --> 00:10:43,949
have a row and then we have like the top

00:10:42,060 --> 00:10:46,529
row of the board which is board at the

00:10:43,949 --> 00:10:48,510
index 0 and the middle row and the

00:10:46,529 --> 00:10:49,589
bottom row which is board at the index 2

00:10:48,510 --> 00:10:50,660
and they're all pointing to the same

00:10:49,589 --> 00:10:53,670
thing

00:10:50,660 --> 00:10:56,130
so when we modify the first element of

00:10:53,670 --> 00:10:58,949
the top row and assign it the value X

00:10:56,130 --> 00:11:01,980
that's actually since every row points

00:10:58,949 --> 00:11:03,839
to the same list it modifies all that

00:11:01,980 --> 00:11:04,410
whole column of the tic-tac-toe board

00:11:03,839 --> 00:11:09,209
and

00:11:04,410 --> 00:11:11,879
max wins so one of the ways that this

00:11:09,209 --> 00:11:13,529
sort of behavior with like lists being

00:11:11,879 --> 00:11:16,230
mutable objects but also they're like

00:11:13,529 --> 00:11:18,089
dictionaries and sets are using mutable

00:11:16,230 --> 00:11:22,019
objects as a default value for an

00:11:18,089 --> 00:11:23,819
argument and a function so let's

00:11:22,019 --> 00:11:25,620
illustrate that with an example this is

00:11:23,819 --> 00:11:28,350
going to be a very practical function

00:11:25,620 --> 00:11:31,589
called a pinned cat and it'll take one

00:11:28,350 --> 00:11:34,699
argument that we'll call L and it will

00:11:31,589 --> 00:11:37,139
default to the value of the empty list

00:11:34,699 --> 00:11:39,509
so it's a pretty simple function we just

00:11:37,139 --> 00:11:44,100
take L we append cat because we like

00:11:39,509 --> 00:11:47,100
cats and then we return the list so what

00:11:44,100 --> 00:11:52,649
happens when we call the function append

00:11:47,100 --> 00:11:55,110
cat once any guesses cat yeah it's a

00:11:52,649 --> 00:11:56,759
list with cat in it like that's pretty

00:11:55,110 --> 00:12:00,089
pretty straightforward we would

00:11:56,759 --> 00:12:01,980
definitely expect that to happen okay

00:12:00,089 --> 00:12:02,579
what happens if we invoke it a second

00:12:01,980 --> 00:12:04,129
time

00:12:02,579 --> 00:12:05,689
who thinks we'll get the same output

00:12:04,129 --> 00:12:09,750
show of hands

00:12:05,689 --> 00:12:12,810
nobody okay what about different output

00:12:09,750 --> 00:12:15,389
yeah you're right two cats there's so

00:12:12,810 --> 00:12:17,639
many cats where are they coming from how

00:12:15,389 --> 00:12:19,800
did that happen right it'd be totally

00:12:17,639 --> 00:12:22,410
reasonable to assume that any time we

00:12:19,800 --> 00:12:24,870
call a pinned cat without any arguments

00:12:22,410 --> 00:12:27,569
Python would initialize a new empty list

00:12:24,870 --> 00:12:30,029
for us to assign to L but that does not

00:12:27,569 --> 00:12:34,019
seem to be the case here so what's going

00:12:30,029 --> 00:12:35,490
on well in Python functions are objects

00:12:34,019 --> 00:12:37,709
and as a result they have some

00:12:35,490 --> 00:12:40,380
attributes assigned or defined on them

00:12:37,709 --> 00:12:43,110
and one of those attributes is called

00:12:40,380 --> 00:12:45,420
defaults in because we're using Python 3

00:12:43,110 --> 00:12:48,509
and if we're using Python 2 it'd be

00:12:45,420 --> 00:12:50,069
called defaults and we can use

00:12:48,509 --> 00:12:51,569
these attributes to sort of learn about

00:12:50,069 --> 00:12:53,550
what's happening in the function from

00:12:51,569 --> 00:12:55,410
outside of the function body and

00:12:53,550 --> 00:12:58,740
sometimes we can do some fun things to

00:12:55,410 --> 00:13:00,809
the function with them too so let's see

00:12:58,740 --> 00:13:03,600
what's inside this attribute so right

00:13:00,809 --> 00:13:06,449
now before we've invoked append cat it

00:13:03,600 --> 00:13:08,160
is a tuple with one element and that's

00:13:06,449 --> 00:13:14,100
the empty list so this is the default

00:13:08,160 --> 00:13:16,220
value of our argument l so suppose we

00:13:14,100 --> 00:13:17,930
invoke append cat and then

00:13:16,220 --> 00:13:19,940
in the second line we try looking at the

00:13:17,930 --> 00:13:24,110
defaults again you can see what that

00:13:19,940 --> 00:13:26,600
contains so now it contains a list with

00:13:24,110 --> 00:13:28,280
one element cat so you can kind of get a

00:13:26,600 --> 00:13:30,650
feel for what's going on here when

00:13:28,280 --> 00:13:33,800
Python defines a function with default

00:13:30,650 --> 00:13:35,090
arguments it'll store that value when

00:13:33,800 --> 00:13:37,430
the function is defined inside the

00:13:35,090 --> 00:13:39,050
defaults and it doesn't create a new

00:13:37,430 --> 00:13:42,680
list each time the function is invoked

00:13:39,050 --> 00:13:44,630
which you might otherwise expect so

00:13:42,680 --> 00:13:48,410
let's try to do like a fun thing here

00:13:44,630 --> 00:13:50,930
sometimes when these kind of internals

00:13:48,410 --> 00:13:53,630
of Python are exposed to me it can be a

00:13:50,930 --> 00:13:56,120
really fun learning exercise to see what

00:13:53,630 --> 00:13:57,860
bad things you can do with them so for

00:13:56,120 --> 00:14:00,770
fun let's see if we can mutate the

00:13:57,860 --> 00:14:03,560
default value of L from outside of the

00:14:00,770 --> 00:14:06,200
function body so we can get a handle on

00:14:03,560 --> 00:14:08,450
the default value but using this sort of

00:14:06,200 --> 00:14:10,670
trick in the Python interpreter using an

00:14:08,450 --> 00:14:12,560
underscore character so that is just

00:14:10,670 --> 00:14:14,270
bound to the return value of the

00:14:12,560 --> 00:14:17,180
previous statement and the interpreter

00:14:14,270 --> 00:14:19,580
we just get that for free and we can get

00:14:17,180 --> 00:14:22,070
a handle on this list containing cat by

00:14:19,580 --> 00:14:23,900
indexing into the tuple and then we'll

00:14:22,070 --> 00:14:26,060
try appending dragon to it

00:14:23,900 --> 00:14:30,110
dragon obviously does not belong in the

00:14:26,060 --> 00:14:34,340
siping cat function but we'll try so we

00:14:30,110 --> 00:14:36,890
try and voguing a pen cat so who thinks

00:14:34,340 --> 00:14:39,770
that like we have successfully inserted

00:14:36,890 --> 00:14:42,080
dragon into this like function who

00:14:39,770 --> 00:14:45,680
thinks it'll like return cat dragon cat

00:14:42,080 --> 00:14:49,820
cool anyone like not think that this is

00:14:45,680 --> 00:14:52,520
successful I kind of gave it away again

00:14:49,820 --> 00:14:54,290
yeah so catch I can catch what and one

00:14:52,520 --> 00:14:57,230
of the surprising things to me about

00:14:54,290 --> 00:14:59,210
this is that everyone knows or maybe not

00:14:57,230 --> 00:15:03,020
everyone that tuples are immutable

00:14:59,210 --> 00:15:04,730
objects but they can store immutable

00:15:03,020 --> 00:15:08,270
objects in their elements and you can

00:15:04,730 --> 00:15:09,710
like mutate those as you wish so this is

00:15:08,270 --> 00:15:13,300
kind of a fun thing that you can do with

00:15:09,710 --> 00:15:15,440
this like internal that's exposed to us

00:15:13,300 --> 00:15:17,750
great so we're done talking about

00:15:15,440 --> 00:15:19,610
mutability in which we saw how many

00:15:17,750 --> 00:15:22,580
names can be bound to a single object

00:15:19,610 --> 00:15:24,620
even if that object is mutable and also

00:15:22,580 --> 00:15:27,290
how mutable default arguments can have

00:15:24,620 --> 00:15:30,110
some surprising results so now I'd like

00:15:27,290 --> 00:15:33,209
us to talk a bit about scope

00:15:30,110 --> 00:15:36,389
let's start by defining a variable a

00:15:33,209 --> 00:15:38,130
with the value 1 and pretty simple

00:15:36,389 --> 00:15:43,410
example we just have this function foo

00:15:38,130 --> 00:15:46,649
and it will return a okay so when we

00:15:43,410 --> 00:15:48,750
invoke foo - probably reasonable things

00:15:46,649 --> 00:15:50,490
could happen one is that it could return

00:15:48,750 --> 00:15:54,480
one and another is that it could result

00:15:50,490 --> 00:15:56,009
in some like name error so what happens

00:15:54,480 --> 00:15:59,880
when we call foo raise your hand if you

00:15:56,009 --> 00:16:01,079
think it'll return one okay and raise

00:15:59,880 --> 00:16:06,839
your hand if you think that it will

00:16:01,079 --> 00:16:10,050
throw an error great it returns one what

00:16:06,839 --> 00:16:11,790
like how does this get there right so I

00:16:10,050 --> 00:16:14,459
want to use this to talk a minute about

00:16:11,790 --> 00:16:17,579
name resolution and how Python will

00:16:14,459 --> 00:16:20,040
resolve this name and so when we invoke

00:16:17,579 --> 00:16:22,290
foo and thus return a the Python

00:16:20,040 --> 00:16:24,600
interpreter needs to find what object

00:16:22,290 --> 00:16:26,269
has been bound to the name a and it does

00:16:24,600 --> 00:16:29,069
this by looking in a series of places

00:16:26,269 --> 00:16:31,199
first it looks inside the local scope

00:16:29,069 --> 00:16:33,569
within the function and we don't have

00:16:31,199 --> 00:16:36,089
any assignment statements inside this

00:16:33,569 --> 00:16:39,300
local scope so our search for the name a

00:16:36,089 --> 00:16:40,529
is unsuccessful next we'll look at the

00:16:39,300 --> 00:16:42,990
enclosing scope

00:16:40,529 --> 00:16:45,120
so if foo was maybe a function that was

00:16:42,990 --> 00:16:48,120
nested inside another function called

00:16:45,120 --> 00:16:50,639
bar and bar might have some assignment

00:16:48,120 --> 00:16:52,139
statements that would be an example of

00:16:50,639 --> 00:16:56,089
an enclosing scope but that's not the

00:16:52,139 --> 00:16:58,380
case here so we're also unsuccessful

00:16:56,089 --> 00:17:00,569
next we'll look inside the global

00:16:58,380 --> 00:17:03,930
namespace or global scope which is

00:17:00,569 --> 00:17:06,419
module level definitions and inside the

00:17:03,930 --> 00:17:09,630
interpreter this a equals one is in the

00:17:06,419 --> 00:17:12,360
global scope so we are successful here

00:17:09,630 --> 00:17:13,530
and we've resolved in AMA we know that

00:17:12,360 --> 00:17:15,030
it's supposed to be the value one

00:17:13,530 --> 00:17:16,559
because that's what it has inside the

00:17:15,030 --> 00:17:19,260
global scope and we can return

00:17:16,559 --> 00:17:20,579
successfully if we didn't find it there

00:17:19,260 --> 00:17:23,579
the last place that we would look is

00:17:20,579 --> 00:17:26,640
inside the built-ins namespace and this

00:17:23,579 --> 00:17:28,319
is what stores built-in names like true

00:17:26,640 --> 00:17:33,510
for example and binds them to their

00:17:28,319 --> 00:17:35,100
values we can also see that we're

00:17:33,510 --> 00:17:37,340
loading an object from the global scope

00:17:35,100 --> 00:17:40,169
by looking at this functions byte code

00:17:37,340 --> 00:17:42,210
so here we import the disk module from

00:17:40,169 --> 00:17:43,299
the standard library which is a byte

00:17:42,210 --> 00:17:46,299
code

00:17:43,299 --> 00:17:49,750
and just a note on this bytecode

00:17:46,299 --> 00:17:52,330
disassembler it will print out sort of

00:17:49,750 --> 00:17:54,279
the machine instructions bytecode the

00:17:52,330 --> 00:17:57,460
interpreter creates in a human readable

00:17:54,279 --> 00:18:00,100
form so when we pass our function foo

00:17:57,460 --> 00:18:03,220
into this disassembler we can see the

00:18:00,100 --> 00:18:05,320
slowed global instruction and this is

00:18:03,220 --> 00:18:07,179
the bytecode instruction form it's

00:18:05,320 --> 00:18:09,880
pretty straightforward loading an object

00:18:07,179 --> 00:18:11,380
from the global namespace so this is

00:18:09,880 --> 00:18:13,000
built into the language like at the

00:18:11,380 --> 00:18:16,450
bytecode level we know to look in the

00:18:13,000 --> 00:18:19,179
global namespace namespace let's look at

00:18:16,450 --> 00:18:20,350
a bit different of an example and this

00:18:19,179 --> 00:18:23,980
will be the last example that we'll look

00:18:20,350 --> 00:18:27,879
at today what if in foo we tried

00:18:23,980 --> 00:18:30,129
incrementing a and then returning it so

00:18:27,879 --> 00:18:33,519
when we invoke foo raise your hand if

00:18:30,129 --> 00:18:35,529
you think that this will return to great

00:18:33,519 --> 00:18:39,789
and raise your hand if you think that

00:18:35,529 --> 00:18:41,080
this will raise an exception okay a bit

00:18:39,789 --> 00:18:43,299
more uncertainty on this one which is

00:18:41,080 --> 00:18:45,429
good it's a good one to end on any

00:18:43,299 --> 00:18:51,460
guesses to what exception it raises

00:18:45,429 --> 00:18:54,090
Python trivia yeah unbound local error

00:18:51,460 --> 00:18:57,250
local variable a referenced before

00:18:54,090 --> 00:18:59,320
assignment so what does this mean it's

00:18:57,250 --> 00:19:01,360
kind of like a cryptic like I don't

00:18:59,320 --> 00:19:03,940
understand immediately what's supposed

00:19:01,360 --> 00:19:07,269
to be going on here so let's investigate

00:19:03,940 --> 00:19:09,669
a little bit so from the Python FAQ

00:19:07,269 --> 00:19:12,129
there's a statement when you make an

00:19:09,669 --> 00:19:16,120
assignment to a variable in a scope that

00:19:12,129 --> 00:19:17,740
variable becomes local to that scope so

00:19:16,120 --> 00:19:20,799
look at let's look at this in slightly

00:19:17,740 --> 00:19:22,600
different way what if instead of

00:19:20,799 --> 00:19:25,539
incrementing a we had like a very

00:19:22,600 --> 00:19:30,549
explicit assignment statement a equals a

00:19:25,539 --> 00:19:32,350
plus one so the eight equals part means

00:19:30,549 --> 00:19:35,409
we're making an assignment inside a

00:19:32,350 --> 00:19:38,440
scope local to foo and this makes a

00:19:35,409 --> 00:19:42,580
local variable inside foo according to

00:19:38,440 --> 00:19:44,620
the faq quote from the previous slide so

00:19:42,580 --> 00:19:47,230
we've decided that a is a locally bound

00:19:44,620 --> 00:19:49,629
name then when we try to calculate the

00:19:47,230 --> 00:19:52,600
value to buy into the name a we figure

00:19:49,629 --> 00:19:54,820
out or we need to figure out a plus one

00:19:52,600 --> 00:19:55,990
and we know that a is bound locally

00:19:54,820 --> 00:19:58,600
right

00:19:55,990 --> 00:20:01,180
we've already decided that but a isn't

00:19:58,600 --> 00:20:05,050
defined in the local scope yet so we get

00:20:01,180 --> 00:20:07,390
an unbound local error we can also look

00:20:05,050 --> 00:20:08,890
at this example at the byte code for

00:20:07,390 --> 00:20:11,710
this example to understand it a bit more

00:20:08,890 --> 00:20:14,770
in the previous example just recall that

00:20:11,710 --> 00:20:18,040
we use the load global operation to load

00:20:14,770 --> 00:20:20,230
the value of a from the global scope so

00:20:18,040 --> 00:20:22,840
in this example instead of load global

00:20:20,230 --> 00:20:25,000
we use a load fast which loads the

00:20:22,840 --> 00:20:28,030
object from the local scope instead and

00:20:25,000 --> 00:20:30,130
when this executes there is no a defined

00:20:28,030 --> 00:20:34,240
in the local scope yet so our program

00:20:30,130 --> 00:20:38,770
fails we don't even try looking in the

00:20:34,240 --> 00:20:41,500
global scope for a at this point so I

00:20:38,770 --> 00:20:44,050
would like to close with a quote from my

00:20:41,500 --> 00:20:47,950
friend ROS knowledge is power

00:20:44,050 --> 00:20:51,220
it's measured in watts and really if you

00:20:47,950 --> 00:20:53,110
would get one thing out of this talk I'd

00:20:51,220 --> 00:20:54,820
like for you to be inspired to discover

00:20:53,110 --> 00:20:56,470
what is really happening when you see

00:20:54,820 --> 00:20:58,510
unexpected behavior in your programs

00:20:56,470 --> 00:21:00,310
because really every bit of unexpected

00:20:58,510 --> 00:21:01,780
behavior is a chance for you to learn

00:21:00,310 --> 00:21:05,350
something new about the language that

00:21:01,780 --> 00:21:07,090
you choose and one last thing if you are

00:21:05,350 --> 00:21:09,400
interested in byte code and how the

00:21:07,090 --> 00:21:10,060
Python interpreter works plug for my

00:21:09,400 --> 00:21:12,520
friend

00:21:10,060 --> 00:21:15,280
check out Allison captors Tok bytes in

00:21:12,520 --> 00:21:20,340
the machine at 140 she demoed it to me

00:21:15,280 --> 00:21:20,340
last night and it's great thank you

00:21:26,970 --> 00:21:30,550
all right if we have any questions go

00:21:29,080 --> 00:21:34,120
ahead line up right there behind the

00:21:30,550 --> 00:21:36,280
microphone Center well the a equals 257

00:21:34,120 --> 00:21:39,280
certainly surprised me but then I had to

00:21:36,280 --> 00:21:42,160
try it in a Python program and it does

00:21:39,280 --> 00:21:44,140
come up is true so it depends on whether

00:21:42,160 --> 00:21:45,910
you're using the debugger or whether

00:21:44,140 --> 00:21:48,430
you're using the actual live interpreter

00:21:45,910 --> 00:21:51,100
yeah yeah so that's an interesting point

00:21:48,430 --> 00:21:53,110
so when you said you tried it with a

00:21:51,100 --> 00:21:55,750
Python program does that mean that you

00:21:53,110 --> 00:21:57,430
typed those two lines in a module and

00:21:55,750 --> 00:22:00,100
then ran that through the Python

00:21:57,430 --> 00:22:03,310
interpreter yes yeah okay so this is an

00:22:00,100 --> 00:22:07,270
interesting point too a python module is

00:22:03,310 --> 00:22:09,280
a code object so kind of similarly to

00:22:07,270 --> 00:22:11,680
how in an interpreter we have like two

00:22:09,280 --> 00:22:14,080
lines are like when we define them both

00:22:11,680 --> 00:22:16,120
on the same line of code that's one code

00:22:14,080 --> 00:22:18,100
object and that gives the interpreter

00:22:16,120 --> 00:22:20,680
the chance to optimize and only create

00:22:18,100 --> 00:22:22,600
one instance of the integer a similar

00:22:20,680 --> 00:22:24,580
thing happens if you just have that in a

00:22:22,600 --> 00:22:26,860
like dot PI file and run that through

00:22:24,580 --> 00:22:37,090
the Python interpreter thank you for

00:22:26,860 --> 00:22:39,010
answering the unasked sorry can you

00:22:37,090 --> 00:22:40,570
repeat your question for the mutable

00:22:39,010 --> 00:22:44,530
default arguments how do you get the

00:22:40,570 --> 00:22:46,240
expected behavior oh yeah absolutely so

00:22:44,530 --> 00:22:48,070
there's a pretty common pattern that

00:22:46,240 --> 00:22:51,370
people use and you might have seen it

00:22:48,070 --> 00:22:54,490
before generally you would default the

00:22:51,370 --> 00:22:56,440
list value to none and then at the

00:22:54,490 --> 00:22:59,320
beginning of your function check to see

00:22:56,440 --> 00:23:02,560
if your list is that none value and if

00:22:59,320 --> 00:23:04,480
it is then say the list is the empty

00:23:02,560 --> 00:23:06,250
list and that'll force the interpreter

00:23:04,480 --> 00:23:10,690
to create a new empty list each time you

00:23:06,250 --> 00:23:12,900
call the function you're welcome any

00:23:10,690 --> 00:23:17,470
other questions

00:23:12,900 --> 00:23:19,720
great thank you oh I was just kind of

00:23:17,470 --> 00:23:21,910
curious there are the tuples that stored

00:23:19,720 --> 00:23:23,260
the constant values and I'm assuming

00:23:21,910 --> 00:23:28,000
that there's another tuple that map's

00:23:23,260 --> 00:23:30,220
the argument names to that tuple I am

00:23:28,000 --> 00:23:33,550
not sure about that I don't think that

00:23:30,220 --> 00:23:36,040
it stores like the names that way but I

00:23:33,550 --> 00:23:37,720
might be wrong that's the question that

00:23:36,040 --> 00:23:39,539
I don't know the answer to okay thank

00:23:37,720 --> 00:23:41,529
you yeah

00:23:39,539 --> 00:23:44,100
excellent thank you very much everyone

00:23:41,529 --> 00:23:44,100

YouTube URL: https://www.youtube.com/watch?v=sH4XF6pKKmk


