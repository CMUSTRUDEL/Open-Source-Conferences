Title: Type Hints  - Guido van Rossum - PyCon 2015
Publication date: 2015-04-12
Playlist: PyCon 2015
Description: 
	
Captions: 
	00:00:03,330 --> 00:00:08,370
you for that bingo thing yeah can I get

00:00:06,840 --> 00:00:13,519
a picture with you would for that bingo

00:00:08,370 --> 00:00:13,519
thing let's do it afterwards

00:00:14,780 --> 00:00:29,090
oh hello I'm mom sorry I got distracted

00:00:24,200 --> 00:00:33,140
for a second so I wanted to do this talk

00:00:29,090 --> 00:00:36,770
in a smaller room somewhere like 710 or

00:00:33,140 --> 00:00:40,309
so but I asked Diana too late and she

00:00:36,770 --> 00:00:43,460
said well we have no slots in the

00:00:40,309 --> 00:00:45,470
schedule and but she said oh there's

00:00:43,460 --> 00:00:48,230
always some speaker who cancels so we'll

00:00:45,470 --> 00:00:49,910
stick you in a cancel slot and I said

00:00:48,230 --> 00:00:53,110
well I don't want such a large audience

00:00:49,910 --> 00:00:56,030
because this is is this kind of a very

00:00:53,110 --> 00:00:58,760
high technical topic and I'm afraid that

00:00:56,030 --> 00:01:03,289
people will sort of not understand it

00:00:58,760 --> 00:01:05,869
and she said well sure well we'll still

00:01:03,289 --> 00:01:07,700
find we'll find you a canceled slot and

00:01:05,869 --> 00:01:11,240
we'll put someone else's name on it and

00:01:07,700 --> 00:01:13,420
then you'll just sort of show up and so

00:01:11,240 --> 00:01:15,920
a couple weeks before the conference she

00:01:13,420 --> 00:01:17,630
emailed me and she said well nobody's

00:01:15,920 --> 00:01:23,090
cancelled yet and we've got a print that

00:01:17,630 --> 00:01:25,189
the the program so can we do plan D will

00:01:23,090 --> 00:01:26,600
will make an extra slot for you at the

00:01:25,189 --> 00:01:28,610
end of the conference and I still

00:01:26,600 --> 00:01:30,650
thought oh sure yeah but by then

00:01:28,610 --> 00:01:32,990
everybody's tired and they're going home

00:01:30,650 --> 00:01:35,420
or they're already on their flight so I

00:01:32,990 --> 00:01:38,299
was expecting like 200 people who are

00:01:35,420 --> 00:01:41,299
really into type theory here but well

00:01:38,299 --> 00:01:43,840
okay you're all into type theory thank

00:01:41,299 --> 00:01:43,840
you so much

00:01:48,560 --> 00:01:54,000
- got this out of the way if you want to

00:01:52,409 --> 00:01:58,620
see that logo again with somewhere here

00:01:54,000 --> 00:02:01,110
on the wall so I always like to start

00:01:58,620 --> 00:02:02,880
with ancient history like grandpa tell

00:02:01,110 --> 00:02:06,229
again the story about when you found

00:02:02,880 --> 00:02:09,840
that potato shaped like the baby Jesus

00:02:06,229 --> 00:02:13,530
so in 2000 which is pretty ancient

00:02:09,840 --> 00:02:15,240
history for pi from Python there was

00:02:13,530 --> 00:02:18,030
something called the types a get it

00:02:15,240 --> 00:02:22,680
actually lived from 98 to 2002 and then

00:02:18,030 --> 00:02:24,510
it died sad but in 2000 and I found this

00:02:22,680 --> 00:02:25,110
talk back it still somewhere on Python

00:02:24,510 --> 00:02:28,739
the dork

00:02:25,110 --> 00:02:31,860
I had this proposal for type annotations

00:02:28,739 --> 00:02:34,470
that looks just like what I'm now

00:02:31,860 --> 00:02:37,770
finally going to propose to put into the

00:02:34,470 --> 00:02:40,470
language but it didn't go anywhere

00:02:37,770 --> 00:02:42,360
because there were other proposals and

00:02:40,470 --> 00:02:45,120
and sort of we didn't understand what it

00:02:42,360 --> 00:02:48,300
was good for and we had more important

00:02:45,120 --> 00:02:53,100
things to deal with like unicode so a

00:02:48,300 --> 00:02:54,840
couple years later in 2004 2005 I

00:02:53,100 --> 00:02:57,480
started blogging about this stuff again

00:02:54,840 --> 00:03:01,890
and I guess I had sort of heard about

00:02:57,480 --> 00:03:03,570
Java generics because I had some little

00:03:01,890 --> 00:03:05,310
code examples somewhere in the block

00:03:03,570 --> 00:03:07,739
where I would define the generic

00:03:05,310 --> 00:03:10,019
function that sort of takes two items of

00:03:07,739 --> 00:03:12,720
two arguments of type T and it returns a

00:03:10,019 --> 00:03:15,120
T and I also had this notion of well you

00:03:12,720 --> 00:03:17,700
can he'll have lists of T or abstract

00:03:15,120 --> 00:03:21,090
data types like interval of T and that's

00:03:17,700 --> 00:03:23,100
all exactly like what we're now finally

00:03:21,090 --> 00:03:25,290
proposing except then I was using

00:03:23,100 --> 00:03:30,299
parentheses instead of square brackets

00:03:25,290 --> 00:03:33,090
which is a huge step forward but I

00:03:30,299 --> 00:03:37,260
didn't know that a little after that

00:03:33,090 --> 00:03:39,930
sort of I was still very excited about

00:03:37,260 --> 00:03:42,420
that idea but I couldn't get sort of the

00:03:39,930 --> 00:03:45,470
right shape for it and and people had

00:03:42,420 --> 00:03:48,690
all sorts of counter proposals and I

00:03:45,470 --> 00:03:51,000
thought well okay these these type hints

00:03:48,690 --> 00:03:53,660
are very complicated and that they need

00:03:51,000 --> 00:03:56,880
to bake little longer but let's at least

00:03:53,660 --> 00:03:59,220
put something in the language so that we

00:03:56,880 --> 00:04:01,200
can give people an opportunity to

00:03:59,220 --> 00:04:04,930
experiment and

00:04:01,200 --> 00:04:07,030
3107 function annotations and so you

00:04:04,930 --> 00:04:10,060
could actually write all those examples

00:04:07,030 --> 00:04:12,220
but you would have to sort of define the

00:04:10,060 --> 00:04:14,920
meaning for that yourself because the

00:04:12,220 --> 00:04:22,440
function annotations have syntax but now

00:04:14,920 --> 00:04:25,990
meaning more recently to pythons ago I

00:04:22,440 --> 00:04:29,290
met a PhD student from Cambridge who was

00:04:25,990 --> 00:04:33,520
working on actually a Python like

00:04:29,290 --> 00:04:36,370
language where he was going to do type

00:04:33,520 --> 00:04:38,710
checking and I talked him into changing

00:04:36,370 --> 00:04:42,130
the syntax of his language so that it

00:04:38,710 --> 00:04:44,380
was actually just regular Python all he

00:04:42,130 --> 00:04:47,310
had to do is come up with the right

00:04:44,380 --> 00:04:51,910
syntax to boot in those annotation slots

00:04:47,310 --> 00:04:54,340
and he went off and got his degree and

00:04:51,910 --> 00:04:58,510
all that and now he's also working with

00:04:54,340 --> 00:05:02,440
me at Dropbox and then but that that was

00:04:58,510 --> 00:05:06,190
still fairly sort of interesting

00:05:02,440 --> 00:05:09,729
curiosity but last summer at Euro Python

00:05:06,190 --> 00:05:13,479
Bob Eppolito who was also a big name in

00:05:09,729 --> 00:05:15,700
the Python world for very long gave

00:05:13,479 --> 00:05:17,710
three recommendations for things that

00:05:15,700 --> 00:05:19,900
Python could learn from Haskell actually

00:05:17,710 --> 00:05:23,260
maybe it was from Haskell and Erlang and

00:05:19,900 --> 00:05:25,840
I forget what the third one was the

00:05:23,260 --> 00:05:27,850
second one was completely in actionable

00:05:25,840 --> 00:05:31,180
was something like we should have

00:05:27,850 --> 00:05:33,190
immutable data types only but the his

00:05:31,180 --> 00:05:35,500
first recommendation was let's take my

00:05:33,190 --> 00:05:39,789
PI and run with it and let's do it

00:05:35,500 --> 00:05:41,500
and so I emailed you Carl

00:05:39,789 --> 00:05:43,800
let's meet about this let's see what we

00:05:41,500 --> 00:05:47,500
can do there was a Dropbox hack week

00:05:43,800 --> 00:05:50,410
other people got interested like Lucas

00:05:47,500 --> 00:05:52,539
longa and he sort of drafted app app

00:05:50,410 --> 00:05:54,940
that's just fell in our lap and now here

00:05:52,539 --> 00:05:57,669
we are and and we're I think we're this

00:05:54,940 --> 00:06:03,010
close to having a solid proposal that

00:05:57,669 --> 00:06:06,190
will introduce in Python 3 5 so so what

00:06:03,010 --> 00:06:08,110
what is this proposal I think that's

00:06:06,190 --> 00:06:09,880
sort of at the the really high level

00:06:08,110 --> 00:06:12,250
there are three parts to it there is a

00:06:09,880 --> 00:06:14,400
separate program which is a type checker

00:06:12,250 --> 00:06:17,040
for example my PI but there are P

00:06:14,400 --> 00:06:18,990
for working on competing type checkers

00:06:17,040 --> 00:06:21,810
and a type checker is like it's

00:06:18,990 --> 00:06:24,270
something that is more close to a linter

00:06:21,810 --> 00:06:26,610
than to a Python interpreter so as a

00:06:24,270 --> 00:06:30,120
developer you get to choose which

00:06:26,610 --> 00:06:32,880
checker and when to run it and whether

00:06:30,120 --> 00:06:36,330
you what you do with the output the

00:06:32,880 --> 00:06:39,750
second leg of the proposal is function

00:06:36,330 --> 00:06:41,729
annotations there is now a notation for

00:06:39,750 --> 00:06:44,430
what you put in the annotations that

00:06:41,729 --> 00:06:48,030
sort of defines what the types of the

00:06:44,430 --> 00:06:50,190
arguments and the return-type are and

00:06:48,030 --> 00:06:52,199
how they relate to each other and the

00:06:50,190 --> 00:06:56,039
third of the third leg of the argue of

00:06:52,199 --> 00:06:59,520
the proposal which actually is is very

00:06:56,039 --> 00:07:02,520
pragmatic is that many times you cannot

00:06:59,520 --> 00:07:04,260
actually put your stubs in your code for

00:07:02,520 --> 00:07:06,180
various reasons maybe you're not your

00:07:04,260 --> 00:07:07,860
code maybe it's written in C maybe it

00:07:06,180 --> 00:07:11,039
needs to be compatible with Python too

00:07:07,860 --> 00:07:13,320
and so it's also going to be possible to

00:07:11,039 --> 00:07:15,389
boot start to boot boot type annotations

00:07:13,320 --> 00:07:19,289
in separate files which we call stub

00:07:15,389 --> 00:07:23,580
files and more about that little later

00:07:19,289 --> 00:07:26,789
but why why do we want a static type

00:07:23,580 --> 00:07:29,400
checker well in an ideal world if you

00:07:26,789 --> 00:07:31,440
talk to sort of the people who are into

00:07:29,400 --> 00:07:33,840
static typing and usually they wanted in

00:07:31,440 --> 00:07:36,120
their compiler but in the end the reason

00:07:33,840 --> 00:07:40,470
is that static type checks find certain

00:07:36,120 --> 00:07:44,070
bugs sooner like before you deploy your

00:07:40,470 --> 00:07:46,710
code which is good if you annotate your

00:07:44,070 --> 00:07:48,840
code and in the Python world we sort of

00:07:46,710 --> 00:07:50,550
we have lots of other ways of catching

00:07:48,840 --> 00:07:52,530
bugs and there are plenty of bugs that

00:07:50,550 --> 00:07:55,139
don't get caught by type system so this

00:07:52,530 --> 00:07:57,180
is not a panacea but some bugs actually

00:07:55,139 --> 00:07:59,120
do get found sooner if you have type

00:07:57,180 --> 00:08:02,340
annotations and you check against them

00:07:59,120 --> 00:08:04,800
it turns out that who the larger your

00:08:02,340 --> 00:08:08,039
project is the more lines of code you

00:08:04,800 --> 00:08:10,050
have but especially the more people you

00:08:08,039 --> 00:08:12,720
have working on that project and the

00:08:10,050 --> 00:08:16,830
longer your project is stretched over

00:08:12,720 --> 00:08:20,099
time the more these kind of things tools

00:08:16,830 --> 00:08:23,789
like linters and type checks actually

00:08:20,099 --> 00:08:27,539
help it helps new engineers plunk old

00:08:23,789 --> 00:08:28,139
code that sort of only one engineer who

00:08:27,539 --> 00:08:29,939
knows

00:08:28,139 --> 00:08:33,000
longer works at the company would still

00:08:29,939 --> 00:08:36,779
understand otherwise and it turns out

00:08:33,000 --> 00:08:39,149
that large teams actually already have

00:08:36,779 --> 00:08:43,740
some form of static analysis running

00:08:39,149 --> 00:08:46,860
that they found that even without type

00:08:43,740 --> 00:08:50,310
annotations static analysis can help

00:08:46,860 --> 00:08:56,000
them find bugs sooner or do other things

00:08:50,310 --> 00:08:58,730
like yeah well fine bucks sooner sorry

00:08:56,000 --> 00:09:01,680
that's what it all comes down to right

00:08:58,730 --> 00:09:03,260
different kinds of bugs and so there are

00:09:01,680 --> 00:09:11,430
also people who are actually building

00:09:03,260 --> 00:09:13,890
products but so these static analysis

00:09:11,430 --> 00:09:16,260
tools currently work okay at least

00:09:13,890 --> 00:09:18,839
without type-ins why do you want the

00:09:16,260 --> 00:09:23,040
type ins well python is incredibly

00:09:18,839 --> 00:09:26,190
dynamic and it turns out that there are

00:09:23,040 --> 00:09:29,970
many many idioms in Python that actively

00:09:26,190 --> 00:09:32,100
work against static analysis that just

00:09:29,970 --> 00:09:35,010
sort of get in the way of static

00:09:32,100 --> 00:09:38,670
analysis because you sort of you read a

00:09:35,010 --> 00:09:40,890
string from a file or you asked user for

00:09:38,670 --> 00:09:43,560
to type a string and then you evaluate

00:09:40,890 --> 00:09:46,470
it and then you run with whatever object

00:09:43,560 --> 00:09:48,329
that evaluation returned then type

00:09:46,470 --> 00:09:51,570
checker has no way to figure out what

00:09:48,329 --> 00:09:53,339
that type is and then all the rest of

00:09:51,570 --> 00:09:55,589
the code that uses that value also

00:09:53,339 --> 00:10:01,230
doesn't know what the type is so often

00:09:55,589 --> 00:10:05,070
there are ways to to certif helped help

00:10:01,230 --> 00:10:08,850
type checkers to keep track of what what

00:10:05,070 --> 00:10:10,800
types are actually in used it in the

00:10:08,850 --> 00:10:13,320
insert of in the programmers mind that's

00:10:10,800 --> 00:10:16,890
often what it what it cares well it what

00:10:13,320 --> 00:10:19,890
it matters what matters most and so it

00:10:16,890 --> 00:10:21,810
turns out that because type hints are

00:10:19,890 --> 00:10:23,910
important to represent what's in the

00:10:21,810 --> 00:10:27,990
programmers mind they're also quite

00:10:23,910 --> 00:10:29,699
useful as documentation and yes they get

00:10:27,990 --> 00:10:31,649
out of date but that's where the static

00:10:29,699 --> 00:10:35,279
type checker helps the static type

00:10:31,649 --> 00:10:37,170
checker actually checks whether the type

00:10:35,279 --> 00:10:38,970
the type annotations that you put in

00:10:37,170 --> 00:10:41,310
your program match the code that you put

00:10:38,970 --> 00:10:43,620
in your program which is big advantage

00:10:41,310 --> 00:10:46,320
over putting the type information in

00:10:43,620 --> 00:10:49,320
docstrings because nobody checks that

00:10:46,320 --> 00:10:52,190
the dark strings are still correct it

00:10:49,320 --> 00:10:55,830
also turns out that everybody is

00:10:52,190 --> 00:10:59,640
building IDs that have all sorts of

00:10:55,830 --> 00:11:02,040
handy stuff in them and it's very useful

00:10:59,640 --> 00:11:04,050
for an IDE to be able to know what the

00:11:02,040 --> 00:11:06,839
type of a particular variable or

00:11:04,050 --> 00:11:08,310
argument is so that when you hit the dot

00:11:06,839 --> 00:11:11,040
and then you ask the IDE

00:11:08,310 --> 00:11:13,710
what could I type here that starts with

00:11:11,040 --> 00:11:15,660
an A and it can know that if it's a list

00:11:13,710 --> 00:11:17,279
that append is a pretty popular choice

00:11:15,660 --> 00:11:19,920
but if it's not the list append is

00:11:17,279 --> 00:11:22,770
probably not one of the choices

00:11:19,920 --> 00:11:24,870
IDs also like to put squiggly red or

00:11:22,770 --> 00:11:27,240
green lines under your code to help you

00:11:24,870 --> 00:11:31,920
sort of catch type errors early so all

00:11:27,240 --> 00:11:35,070
these things oh yeah let me quote a

00:11:31,920 --> 00:11:38,400
statistic someone who works for one of

00:11:35,070 --> 00:11:41,640
the big Python IDE developers mentioned

00:11:38,400 --> 00:11:45,360
at the language summit that they can

00:11:41,640 --> 00:11:48,180
correctly infer the type of about 50 to

00:11:45,360 --> 00:11:50,790
60 percent of all expressions occurring

00:11:48,180 --> 00:11:52,890
in typical code which means that nearly

00:11:50,790 --> 00:11:55,589
half of the expressions they cannot

00:11:52,890 --> 00:11:59,100
infer the type and that's where the type

00:11:55,589 --> 00:12:01,589
hints would be useful so why do you want

00:11:59,100 --> 00:12:04,470
these stub files why do you not always

00:12:01,589 --> 00:12:07,440
want to put your types your type in C in

00:12:04,470 --> 00:12:10,710
your annotations well the original

00:12:07,440 --> 00:12:12,690
reason why stop files were invented was

00:12:10,710 --> 00:12:14,250
that you somehow have to annotate the

00:12:12,690 --> 00:12:15,630
standard library and much of the

00:12:14,250 --> 00:12:17,880
standard library especially the

00:12:15,630 --> 00:12:20,610
built-ins is all implemented in C and

00:12:17,880 --> 00:12:23,040
you can't expect the poor type checker

00:12:20,610 --> 00:12:25,620
to also parse the C code and understand

00:12:23,040 --> 00:12:28,080
what's going on there because of this in

00:12:25,620 --> 00:12:31,320
the C code everything is an object how

00:12:28,080 --> 00:12:33,959
great it turns out there are many other

00:12:31,320 --> 00:12:37,110
useful use cases where stubs are handy

00:12:33,959 --> 00:12:39,779
like third-party packages you don't

00:12:37,110 --> 00:12:42,140
really want to sort of go modify the

00:12:39,779 --> 00:12:44,730
source code of a third party package

00:12:42,140 --> 00:12:46,800
because you would have to do it again

00:12:44,730 --> 00:12:48,920
for the next release and there are all

00:12:46,800 --> 00:12:52,410
sorts of reasons there's legacy code

00:12:48,920 --> 00:12:54,390
where there are places where that code

00:12:52,410 --> 00:12:56,820
is used where the type-ins

00:12:54,390 --> 00:12:58,920
would be in the way like for example

00:12:56,820 --> 00:13:02,010
Python 2 compatibility there are also

00:12:58,920 --> 00:13:04,020
reasons that maybe maybe the owner of

00:13:02,010 --> 00:13:06,330
the code just doesn't want you to put

00:13:04,020 --> 00:13:08,160
the type hints in there are plenty of

00:13:06,330 --> 00:13:09,570
people who don't like type hints and

00:13:08,160 --> 00:13:11,970
they don't want you to mess with their

00:13:09,570 --> 00:13:14,279
code but if you are using their package

00:13:11,970 --> 00:13:17,700
you might still want to sort of behind

00:13:14,279 --> 00:13:22,020
their back or with sort of with at least

00:13:17,700 --> 00:13:24,420
without their explicit agreement create

00:13:22,020 --> 00:13:28,920
a stub file that describes the types of

00:13:24,420 --> 00:13:30,630
their particular module or package so

00:13:28,920 --> 00:13:35,880
that you can type check your own code

00:13:30,630 --> 00:13:39,270
better plus it takes a long time to

00:13:35,880 --> 00:13:40,740
develop stubs and we don't want to wait

00:13:39,270 --> 00:13:42,450
until we have stubs for the whole

00:13:40,740 --> 00:13:46,110
standard library so we hope that

00:13:42,450 --> 00:13:48,180
actually people will start creating more

00:13:46,110 --> 00:13:51,209
stubs for more standard libraries

00:13:48,180 --> 00:13:56,640
modules after three-point-five has

00:13:51,209 --> 00:13:59,550
already been released and yet a lot of

00:13:56,640 --> 00:14:02,730
people when you sort of present this

00:13:59,550 --> 00:14:06,170
this idea to them there they're not just

00:14:02,730 --> 00:14:08,640
lukewarm they're actively resentful

00:14:06,170 --> 00:14:11,880
Python is dynamically typed we don't

00:14:08,640 --> 00:14:15,899
want type chat we don't want to have to

00:14:11,880 --> 00:14:19,649
write types in our programs well correct

00:14:15,899 --> 00:14:21,899
you don't have to do this I'm just

00:14:19,649 --> 00:14:25,290
adding this so that those people who

00:14:21,899 --> 00:14:29,640
have large code bases where they think

00:14:25,290 --> 00:14:31,079
that they can use type hints and that

00:14:29,640 --> 00:14:34,829
there that will make their static

00:14:31,079 --> 00:14:37,230
analysis better can use it and it's it's

00:14:34,829 --> 00:14:40,529
useful to have a standard notation so

00:14:37,230 --> 00:14:43,560
that everybody can sort of share stubs

00:14:40,529 --> 00:14:47,430
and agree on what those stubs mean but

00:14:43,560 --> 00:14:50,279
very much please please understand this

00:14:47,430 --> 00:14:52,529
is optional I'm not telling you you have

00:14:50,279 --> 00:14:54,810
to put stubs and I'm not even asking you

00:14:52,529 --> 00:14:58,589
to put I'm not even asking politely to

00:14:54,810 --> 00:15:01,620
put stubs in I'm telling you there is a

00:14:58,589 --> 00:15:05,070
proposal for stubs sorry for type type

00:15:01,620 --> 00:15:08,160
hints use it if you think you'll benefit

00:15:05,070 --> 00:15:10,680
from it ignore it if you don't care

00:15:08,160 --> 00:15:12,959
you can run the type checker or you can

00:15:10,680 --> 00:15:15,110
choose now to run a type checker that's

00:15:12,959 --> 00:15:19,620
completely up to you

00:15:15,110 --> 00:15:21,480
also in Python 3.5 we're making very

00:15:19,620 --> 00:15:25,829
sure that it's not gonna break anybody's

00:15:21,480 --> 00:15:28,139
code and it's entirely provisional which

00:15:25,829 --> 00:15:31,139
which actually means provisional in this

00:15:28,139 --> 00:15:34,500
case means that we can still tweak the

00:15:31,139 --> 00:15:37,050
API in certain backward incompatible

00:15:34,500 --> 00:15:39,180
ways if we find that we made a mistake

00:15:37,050 --> 00:15:40,949
and that's also important because we

00:15:39,180 --> 00:15:43,980
don't we don't want to sort of paint

00:15:40,949 --> 00:15:47,990
ourselves completely into a corner but

00:15:43,980 --> 00:15:47,990
we do want to release something at 3/5

00:15:48,259 --> 00:15:53,970
so I think I already said most of this

00:15:51,720 --> 00:15:58,079
currently a couple of companies have

00:15:53,970 --> 00:16:05,459
their own sort of notion of stubs that

00:15:58,079 --> 00:16:07,350
they they maintain themselves and I

00:16:05,459 --> 00:16:11,970
think it's just a good idea to have a

00:16:07,350 --> 00:16:14,910
PAP and accept that PAP of course so

00:16:11,970 --> 00:16:17,699
that everyone can say ok the issue of

00:16:14,910 --> 00:16:21,300
the syntax of the annotations and stubs

00:16:17,699 --> 00:16:23,519
is settled now we can all compete on who

00:16:21,300 --> 00:16:26,160
has the best type checker or the best

00:16:23,519 --> 00:16:32,040
type inference err or the best IDE and

00:16:26,160 --> 00:16:35,040
some people like type systems so if you

00:16:32,040 --> 00:16:38,339
were to go back to those old blog posts

00:16:35,040 --> 00:16:41,720
and that type cig proposals in 2000

00:16:38,339 --> 00:16:45,060
you'll find that there was a lot of Hope

00:16:41,720 --> 00:16:47,670
where we thought oh if we put the type

00:16:45,060 --> 00:16:49,920
annotations in with the compiler can

00:16:47,670 --> 00:16:53,459
generate more efficient code and our

00:16:49,920 --> 00:16:55,559
code will magically run faster well on

00:16:53,459 --> 00:16:57,389
the one hand if you want your code

00:16:55,559 --> 00:17:00,000
magically to run faster you should

00:16:57,389 --> 00:17:03,140
probably just use pi pi which works just

00:17:00,000 --> 00:17:05,970
fine without type-ins

00:17:03,140 --> 00:17:08,520
on the other hand there are certain

00:17:05,970 --> 00:17:11,789
systems like siphon that can perhaps use

00:17:08,520 --> 00:17:14,819
type hints just as they are standardized

00:17:11,789 --> 00:17:18,270
or maybe they'll have their own idea and

00:17:14,819 --> 00:17:20,850
then we'll have to talk more but well

00:17:18,270 --> 00:17:24,970
we'll see how this works out but

00:17:20,850 --> 00:17:28,360
I'm not yet holding my breath for faster

00:17:24,970 --> 00:17:31,660
code due to type hints however I am

00:17:28,360 --> 00:17:37,360
expecting fewer bugs and happier

00:17:31,660 --> 00:17:40,600
programmers due to type hints so again

00:17:37,360 --> 00:17:42,940
some of you have probably read PAP 3107

00:17:40,600 --> 00:17:46,570
or the corresponding documentation and

00:17:42,940 --> 00:17:49,270
gone to town defining your own type

00:17:46,570 --> 00:17:53,410
checking system or maybe command-line

00:17:49,270 --> 00:17:57,700
parsing system based on the type the

00:17:53,410 --> 00:18:02,280
function annotation syntax and your

00:17:57,700 --> 00:18:07,030
notation looks nothing like that 484

00:18:02,280 --> 00:18:09,670
well the best I can promise is that is

00:18:07,030 --> 00:18:14,800
totally in your right

00:18:09,670 --> 00:18:17,920
your code will still work in 3.5 it may

00:18:14,800 --> 00:18:19,480
not please a type checker but you don't

00:18:17,920 --> 00:18:22,750
have to run the type checker on that

00:18:19,480 --> 00:18:26,230
particular file or module or package if

00:18:22,750 --> 00:18:29,230
you want to peacefully coexist with type

00:18:26,230 --> 00:18:32,410
checkers that PAP actually also has a

00:18:29,230 --> 00:18:34,720
standard notation for turning off type

00:18:32,410 --> 00:18:36,310
checking and the simplest form is a

00:18:34,720 --> 00:18:44,410
decorator that you can put on an

00:18:36,310 --> 00:18:46,690
individual function so in much of the

00:18:44,410 --> 00:18:49,120
rest of the talk I'm going to try and

00:18:46,690 --> 00:18:51,640
explain what these type hints actually

00:18:49,120 --> 00:18:54,370
look like if they're not as simple as

00:18:51,640 --> 00:18:58,300
this is an INT and ethicist string this

00:18:54,370 --> 00:19:00,330
is even a tiny bit of theory but I get

00:18:58,300 --> 00:19:03,970
confused by the theory myself sometimes

00:19:00,330 --> 00:19:06,280
and it ends with a bunch of stuff that

00:19:03,970 --> 00:19:11,230
is necessary if you actually want to use

00:19:06,280 --> 00:19:15,550
this in practice so basics of what I

00:19:11,230 --> 00:19:17,650
what we call gradual typing it's gradual

00:19:15,550 --> 00:19:22,950
because you can have tie pins in some

00:19:17,650 --> 00:19:25,270
code and no tie pins in other code and

00:19:22,950 --> 00:19:27,880
something useful needs to have when

00:19:25,270 --> 00:19:32,730
annotated code and unallocated code

00:19:27,880 --> 00:19:35,760
needs and the idea is that

00:19:32,730 --> 00:19:38,190
the annotated code must conform to its

00:19:35,760 --> 00:19:40,880
own type hints so if you if you say this

00:19:38,190 --> 00:19:43,170
is an INT and that is an INT and then

00:19:40,880 --> 00:19:45,030
you do something with them that

00:19:43,170 --> 00:19:47,130
operation that you do on those two

00:19:45,030 --> 00:19:48,870
arguments better be something you can

00:19:47,130 --> 00:19:52,560
actually do with inns otherwise the type

00:19:48,870 --> 00:19:54,930
checker will be unhappy and tell you on

00:19:52,560 --> 00:19:58,260
the other hand the code that you didn't

00:19:54,930 --> 00:20:01,440
annotate the type checker is going to be

00:19:58,260 --> 00:20:04,920
silent because that's dynamic code and

00:20:01,440 --> 00:20:07,650
sort of by by the definition of the idea

00:20:04,920 --> 00:20:11,700
of gradual typing an annotated code is

00:20:07,650 --> 00:20:14,520
not checked and there is actually a

00:20:11,700 --> 00:20:20,600
special type in the type hinting system

00:20:14,520 --> 00:20:23,430
named NE which means shut up and not

00:20:20,600 --> 00:20:27,680
annotating a function is almost the same

00:20:23,430 --> 00:20:30,240
as annotating it with any all-around

00:20:27,680 --> 00:20:32,340
technically that's not entirely true so

00:20:30,240 --> 00:20:35,600
don't help me too much to it but that's

00:20:32,340 --> 00:20:40,230
sort of a first approximation

00:20:35,600 --> 00:20:43,800
interpretation of gradual typing so this

00:20:40,230 --> 00:20:47,550
anything is actually a pretty strange

00:20:43,800 --> 00:20:49,560
duckling and I don't know in which it's

00:20:47,550 --> 00:20:51,480
sort of how you draw your your class

00:20:49,560 --> 00:20:54,780
diagram so I don't know what's at the

00:20:51,480 --> 00:20:57,210
top or what's at the bottom but I can

00:20:54,780 --> 00:21:00,780
tell you that any is both at the top and

00:20:57,210 --> 00:21:03,870
at the bottom of your class tree because

00:21:00,780 --> 00:21:05,880
that's the definition of any and so it's

00:21:03,870 --> 00:21:08,430
let's say that object is at the top of

00:21:05,880 --> 00:21:10,380
your class tree and everything that

00:21:08,430 --> 00:21:12,780
derives from object and everything is

00:21:10,380 --> 00:21:18,630
below that then any is at the top

00:21:12,780 --> 00:21:21,810
because any value X is an instance of

00:21:18,630 --> 00:21:25,460
the type any and any class C is a

00:21:21,810 --> 00:21:28,800
subclass of the class any however and

00:21:25,460 --> 00:21:31,050
this is completely I mean so this first

00:21:28,800 --> 00:21:32,820
bullet any behaves just like object

00:21:31,050 --> 00:21:35,810
because all those things are true if you

00:21:32,820 --> 00:21:39,270
use object instead of any however

00:21:35,810 --> 00:21:42,330
because any is also at the other side of

00:21:39,270 --> 00:21:45,450
your class tweak any is actually a

00:21:42,330 --> 00:21:50,310
subclass of every other class

00:21:45,450 --> 00:21:52,530
and that is that is the magic of any

00:21:50,310 --> 00:21:55,290
that it also actually causes some

00:21:52,530 --> 00:21:58,020
trouble with is subclass if you take it

00:21:55,290 --> 00:22:01,290
literally because normally is subclass

00:21:58,020 --> 00:22:03,570
is transitive is if a is a subclass of B

00:22:01,290 --> 00:22:08,190
and B is a subclass of C then we know

00:22:03,570 --> 00:22:09,930
that the a is a subclass of C but if if

00:22:08,190 --> 00:22:13,860
something in the middle of a chain like

00:22:09,930 --> 00:22:15,780
that is any then you can't sort of go

00:22:13,860 --> 00:22:17,730
through that any because otherwise you'd

00:22:15,780 --> 00:22:20,100
end up with every subclass every class

00:22:17,730 --> 00:22:23,420
is subclass of every other subclass and

00:22:20,100 --> 00:22:26,490
that would be very useless type system

00:22:23,420 --> 00:22:29,220
so technically we're not using we

00:22:26,490 --> 00:22:32,130
shouldn't be saying subclass we should

00:22:29,220 --> 00:22:35,310
say is consistent with and this

00:22:32,130 --> 00:22:38,400
terminology I believe is due to Jeremy's

00:22:35,310 --> 00:22:40,710
seek of Indiana University and if you

00:22:38,400 --> 00:22:42,870
just google for what is gradual typing

00:22:40,710 --> 00:22:45,450
you'll find his excellent blog post

00:22:42,870 --> 00:22:48,330
which also has a few good things to say

00:22:45,450 --> 00:22:51,630
about dynamic versus static typing in

00:22:48,330 --> 00:22:53,910
general but there is a little definition

00:22:51,630 --> 00:22:57,750
where you say some type is consistent

00:22:53,910 --> 00:23:00,810
with another type which essentially

00:22:57,750 --> 00:23:02,850
means values of the first type can be

00:23:00,810 --> 00:23:06,720
assigned to variables of the other

00:23:02,850 --> 00:23:14,310
second type and this relationship is not

00:23:06,720 --> 00:23:18,360
in general symmetric or transitive but

00:23:14,310 --> 00:23:21,360
it is mostly that because what follows

00:23:18,360 --> 00:23:25,380
from being consistent with is the

00:23:21,360 --> 00:23:28,080
regular subclass property however is

00:23:25,380 --> 00:23:29,880
consistent with also works for any in

00:23:28,080 --> 00:23:32,670
the opposite direction so any is

00:23:29,880 --> 00:23:35,960
consistent with T and T is consistent

00:23:32,670 --> 00:23:39,180
with any and this is true for every T

00:23:35,960 --> 00:23:42,090
but you cannot conclude from this that

00:23:39,180 --> 00:23:44,160
every T is consistent with every other T

00:23:42,090 --> 00:23:48,450
because the relationship is defined as

00:23:44,160 --> 00:23:52,590
not transitive and that's as much theory

00:23:48,450 --> 00:23:56,110
as I can manage to try to explain but

00:23:52,590 --> 00:23:59,990
read the blog post is much better so

00:23:56,110 --> 00:24:02,779
back to sort of practical stuff there is

00:23:59,990 --> 00:24:06,380
actually in the whole proposal there's

00:24:02,779 --> 00:24:09,080
really only one thing I'm proposing to

00:24:06,380 --> 00:24:11,960
actually put in the next C Pyfrom

00:24:09,080 --> 00:24:13,880
distribution as part of the C Python

00:24:11,960 --> 00:24:18,429
standard library and that's the typing

00:24:13,880 --> 00:24:21,590
module there will be no type checking as

00:24:18,429 --> 00:24:25,220
part of C Python there will be no new

00:24:21,590 --> 00:24:28,220
syntax for typing every syntax I've

00:24:25,220 --> 00:24:31,460
shown you so far is actually already

00:24:28,220 --> 00:24:33,649
valid Python syntactically all you have

00:24:31,460 --> 00:24:37,490
to do is overload gather item in a few

00:24:33,649 --> 00:24:39,860
odd places we will also not put

00:24:37,490 --> 00:24:43,279
annotations in any other standard

00:24:39,860 --> 00:24:45,080
library modules and we may sort of in

00:24:43,279 --> 00:24:49,130
three point six we may change your mind

00:24:45,080 --> 00:24:50,750
about that but 43.5 typing the PI is the

00:24:49,130 --> 00:24:53,419
only thing we want in the standard

00:24:50,750 --> 00:24:57,019
library and thereby sort of the notion

00:24:53,419 --> 00:24:59,090
that there is now a standard notation

00:24:57,019 --> 00:25:02,600
which is defined by what's in typing the

00:24:59,090 --> 00:25:05,360
PI and what's in the pepper so if you

00:25:02,600 --> 00:25:07,600
want to use any or a number of other

00:25:05,360 --> 00:25:10,970
magical objects like unions or

00:25:07,600 --> 00:25:12,830
dictionaries and lists that can be sub

00:25:10,970 --> 00:25:17,029
scripted with types you have to import

00:25:12,830 --> 00:25:19,429
them from typing however that doesn't

00:25:17,029 --> 00:25:22,159
mean that you necessarily always need to

00:25:19,429 --> 00:25:24,889
start by import typing here's a simple

00:25:22,159 --> 00:25:26,720
class example that well it's pretty

00:25:24,889 --> 00:25:29,600
silly class I guess it's a chart in

00:25:26,720 --> 00:25:32,630
class with you in the interface defined

00:25:29,600 --> 00:25:35,600
by someone who had never defined a class

00:25:32,630 --> 00:25:42,740
before so there's this it would actually

00:25:35,600 --> 00:25:44,929
I wrote it set a label takes two

00:25:42,740 --> 00:25:47,210
arguments that are floats and one that's

00:25:44,929 --> 00:25:49,190
a string in it returns a bool maybe that

00:25:47,210 --> 00:25:51,230
that tells you whether it actually

00:25:49,190 --> 00:25:53,659
succeeded in setting a label and

00:25:51,230 --> 00:25:55,850
apparently there's a get nearest method

00:25:53,659 --> 00:25:59,779
that asks for the nearest label to a

00:25:55,850 --> 00:26:02,510
particular point on the chart there are

00:25:59,779 --> 00:26:04,610
also a couple of helper functions those

00:26:02,510 --> 00:26:06,350
those are not part of the class they're

00:26:04,610 --> 00:26:07,909
not methods they're just functions these

00:26:06,350 --> 00:26:09,200
are that they don't have a self argument

00:26:07,909 --> 00:26:11,750
as you can tell

00:26:09,200 --> 00:26:16,070
they are annotated make label takes a

00:26:11,750 --> 00:26:18,830
chart object so we see that user-defined

00:26:16,070 --> 00:26:22,490
classes can also show up in type in

00:26:18,830 --> 00:26:25,100
positions and well it does it actually

00:26:22,490 --> 00:26:26,450
calls the set label function the type

00:26:25,100 --> 00:26:29,960
checker can figure out that this is

00:26:26,450 --> 00:26:32,179
actually correct code that set label a

00:26:29,960 --> 00:26:37,309
is correct because set label takes a

00:26:32,179 --> 00:26:42,649
string and so on get labels so it takes

00:26:37,309 --> 00:26:45,860
a list of points and it just says that

00:26:42,649 --> 00:26:49,370
the points variable is a list that's a

00:26:45,860 --> 00:26:52,870
built-in list type and it also tells us

00:26:49,370 --> 00:26:55,700
that it returns a list which is all very

00:26:52,870 --> 00:26:59,659
partial information because actually if

00:26:55,700 --> 00:27:02,630
you look at the code it calls get

00:26:59,659 --> 00:27:04,370
nearest for two points so apparently the

00:27:02,630 --> 00:27:07,250
list of points is actually list of

00:27:04,370 --> 00:27:09,880
tuples of two floating point values and

00:27:07,250 --> 00:27:12,500
so what it returns is list of strings

00:27:09,880 --> 00:27:14,659
but you can't really tell that from the

00:27:12,500 --> 00:27:16,669
code here and the type checker would not

00:27:14,659 --> 00:27:19,340
be able to validate that you didn't make

00:27:16,669 --> 00:27:22,480
a mistake with that so here is a little

00:27:19,340 --> 00:27:25,580
bit of extra stuff that you can add

00:27:22,480 --> 00:27:27,889
we're going to import the capital list

00:27:25,580 --> 00:27:31,299
and capital to pool from the typing

00:27:27,889 --> 00:27:34,519
module and we're going to use those I

00:27:31,299 --> 00:27:37,940
don't have a pointer that's okay so we

00:27:34,519 --> 00:27:40,429
have now weari declare the get labels

00:27:37,940 --> 00:27:42,649
function as taking a list of tuples

00:27:40,429 --> 00:27:44,870
where they're actually tuples of two

00:27:42,649 --> 00:27:49,789
floating points and it returns a list of

00:27:44,870 --> 00:27:51,649
strings now that function doesn't

00:27:49,789 --> 00:27:55,100
actually care that the input is a list

00:27:51,649 --> 00:27:57,260
it can work with any iterable so let's

00:27:55,100 --> 00:28:00,260
import iterable from the typing module

00:27:57,260 --> 00:28:02,750
and then we can say it's an iterable of

00:28:00,260 --> 00:28:07,220
tuples and these are all actually

00:28:02,750 --> 00:28:09,190
working examples so but what exactly did

00:28:07,220 --> 00:28:12,799
we do here

00:28:09,190 --> 00:28:14,690
well typing dot iterable we set from

00:28:12,799 --> 00:28:16,909
typing import hits are also there so

00:28:14,690 --> 00:28:21,110
something to find in typing named

00:28:16,909 --> 00:28:22,999
iterable which is almost the same thing

00:28:21,110 --> 00:28:28,470
as the

00:28:22,999 --> 00:28:30,480
collections ABC named interval and that

00:28:28,470 --> 00:28:32,970
particular collection pretty much

00:28:30,480 --> 00:28:35,570
defines one piece of behavior which is

00:28:32,970 --> 00:28:39,570
that it has an under under hitter method

00:28:35,570 --> 00:28:41,990
and so the typing dot iterable does the

00:28:39,570 --> 00:28:46,259
same thing but it also lets you specify

00:28:41,990 --> 00:28:50,669
what's that that it'll actually contains

00:28:46,259 --> 00:28:52,919
or returns for various pragmatic reasons

00:28:50,669 --> 00:28:57,619
mostly having to do with not wanting to

00:28:52,919 --> 00:28:57,619
modify the cpython implementation at all

00:28:58,129 --> 00:29:04,679
typing that list is the moral equivalent

00:29:01,139 --> 00:29:07,769
of the built-ins list function or type

00:29:04,679 --> 00:29:10,830
actually but again you can specify what

00:29:07,769 --> 00:29:15,990
kind of items well the type of the items

00:29:10,830 --> 00:29:21,149
is tuple again represents or resembles

00:29:15,990 --> 00:29:22,889
the built in tuple function class typing

00:29:21,149 --> 00:29:26,279
the tuple is actually a little bit more

00:29:22,889 --> 00:29:30,809
special because we usually don't want to

00:29:26,279 --> 00:29:36,179
think of tuples as a variable immutable

00:29:30,809 --> 00:29:38,399
sequence of X's we probably think of the

00:29:36,179 --> 00:29:41,990
typical tuple alike in this example of

00:29:38,399 --> 00:29:44,759
it's a to tuple of two floats or maybe

00:29:41,990 --> 00:29:47,610
it's a tuple of two integers and a

00:29:44,759 --> 00:29:51,929
string and so that's what you can define

00:29:47,610 --> 00:29:55,669
with the tuple class now maybe in the

00:29:51,929 --> 00:30:00,299
future we can just write lowercase lists

00:29:55,669 --> 00:30:02,999
but for now in three point five in this

00:30:00,299 --> 00:30:05,970
proposal because we want to have just

00:30:02,999 --> 00:30:07,710
the single typing module that works in

00:30:05,970 --> 00:30:10,679
Python three five but actually also in

00:30:07,710 --> 00:30:13,740
previous versions you have to import

00:30:10,679 --> 00:30:16,740
that thing from the from typing oh and

00:30:13,740 --> 00:30:19,499
the way all these things work is there

00:30:16,740 --> 00:30:22,080
is a meta class that overloads getitem

00:30:19,499 --> 00:30:24,330
but you don't really have to know about

00:30:22,080 --> 00:30:26,700
that that's just sort of if you're

00:30:24,330 --> 00:30:30,240
surprised that you take a class and you

00:30:26,700 --> 00:30:32,980
put square brackets behind it if you're

00:30:30,240 --> 00:30:39,010
surprised that that's valid Python

00:30:32,980 --> 00:30:41,940
that previous slide was why but well

00:30:39,010 --> 00:30:45,280
there's there's there's a sad

00:30:41,940 --> 00:30:47,950
terminological problem in Python which I

00:30:45,280 --> 00:30:50,830
am personally responsible for which is

00:30:47,950 --> 00:30:53,020
that we've always done a terrible job of

00:30:50,830 --> 00:30:56,620
distinguishing between types and classes

00:30:53,020 --> 00:31:00,460
and for example the function to get the

00:30:56,620 --> 00:31:04,900
class of an object is actually named

00:31:00,460 --> 00:31:08,169
type and well they're historical reasons

00:31:04,900 --> 00:31:10,540
but for if you're talking about type

00:31:08,169 --> 00:31:13,450
checking and type hints it actually

00:31:10,540 --> 00:31:16,090
makes a little bit more sense to be

00:31:13,450 --> 00:31:19,870
careful about your terminology so in

00:31:16,090 --> 00:31:22,380
cases where it actually matters we will

00:31:19,870 --> 00:31:25,059
say class when we meet a concrete

00:31:22,380 --> 00:31:27,970
implementation and type when we mean

00:31:25,059 --> 00:31:31,090
something that is more in the mind of

00:31:27,970 --> 00:31:34,419
the type checker this again is pretty

00:31:31,090 --> 00:31:36,790
subtle and we may have to iterate on

00:31:34,419 --> 00:31:42,820
this terminology but this is what it is

00:31:36,790 --> 00:31:45,280
currently anyway so here is I believe a

00:31:42,820 --> 00:31:47,740
complete list of things that you can use

00:31:45,280 --> 00:31:50,650
in type hints and that type checkers are

00:31:47,740 --> 00:31:52,720
expected to understand so you can put

00:31:50,650 --> 00:31:55,450
classes in there could be built-in

00:31:52,720 --> 00:31:57,429
classes like object or float or could be

00:31:55,450 --> 00:31:59,799
user-defined classes like chart either

00:31:57,429 --> 00:32:02,320
in your own code or in some third party

00:31:59,799 --> 00:32:04,990
package then there are these generic

00:32:02,320 --> 00:32:07,870
types which are things like lists square

00:32:04,990 --> 00:32:09,400
bracket int or a dictionary with a

00:32:07,870 --> 00:32:11,010
string and an int where the string is

00:32:09,400 --> 00:32:15,549
the key in the interests of value

00:32:11,010 --> 00:32:18,309
abstract classes like interval then

00:32:15,549 --> 00:32:20,860
there are a bunch of magic things like

00:32:18,309 --> 00:32:23,340
ne and Union and it turns out that tuple

00:32:20,860 --> 00:32:26,590
and callable are also pretty magic and

00:32:23,340 --> 00:32:29,260
then there is a way of defining your own

00:32:26,590 --> 00:32:31,179
generic types do-it-yourself generic

00:32:29,260 --> 00:32:34,360
types you know show that later hopefully

00:32:31,179 --> 00:32:37,270
they'll all have time for that so Union

00:32:34,360 --> 00:32:39,910
is a very basic type that says it could

00:32:37,270 --> 00:32:41,679
either be this or that type so for

00:32:39,910 --> 00:32:46,030
example the union of int float and

00:32:41,679 --> 00:32:47,260
string those are all things that you can

00:32:46,030 --> 00:32:51,670
add to them

00:32:47,260 --> 00:32:54,850
one very common case is union of

00:32:51,670 --> 00:32:56,620
something and none actually something

00:32:54,850 --> 00:32:58,990
are the type of none because the

00:32:56,620 --> 00:33:02,670
arguments for union should be types we

00:32:58,990 --> 00:33:06,340
let you actually specify none also but

00:33:02,670 --> 00:33:08,980
either an int or none or either a chart

00:33:06,340 --> 00:33:11,110
or none or either something or not not

00:33:08,980 --> 00:33:14,170
something is so common that we have a

00:33:11,110 --> 00:33:16,150
special notation optional and that sort

00:33:14,170 --> 00:33:17,710
of that helps the human reader probably

00:33:16,150 --> 00:33:21,010
more than it helps the type checker

00:33:17,710 --> 00:33:25,420
because the type checker just reduces

00:33:21,010 --> 00:33:26,890
that to a union and works with that so I

00:33:25,420 --> 00:33:29,650
mentioned that tuple was a little bit

00:33:26,890 --> 00:33:33,970
special tuple actually has a variable

00:33:29,650 --> 00:33:36,700
number of parameters and sort of each of

00:33:33,970 --> 00:33:40,510
those is describes a different position

00:33:36,700 --> 00:33:43,360
in the tuple so tuple of int instr is a

00:33:40,510 --> 00:33:47,770
tuple of length 3 where the first two

00:33:43,360 --> 00:33:49,990
items are in sin the last is a stream of

00:33:47,770 --> 00:33:52,480
course we got a lot of pushback and was

00:33:49,990 --> 00:33:55,960
an endless thread about well but is a

00:33:52,480 --> 00:33:59,710
tuple not really just immutable sequence

00:33:55,960 --> 00:34:01,780
and well often we use a tuple as in an

00:33:59,710 --> 00:34:05,020
immutable sequence so as a sort of

00:34:01,780 --> 00:34:07,570
compromise you can say tuple of float

00:34:05,020 --> 00:34:10,440
comma dot dot dot and that's literally

00:34:07,570 --> 00:34:13,149
three dots and that is also already

00:34:10,440 --> 00:34:16,629
existing Python syntax I think way back

00:34:13,149 --> 00:34:19,090
since in Python 2 that was introduced to

00:34:16,629 --> 00:34:22,270
help the numerical Python people with

00:34:19,090 --> 00:34:24,159
certain types of slices so that is what

00:34:22,270 --> 00:34:26,620
you would write if you meant a tuple

00:34:24,159 --> 00:34:32,139
really as an immutable sequence of

00:34:26,620 --> 00:34:36,940
floats more stuff again this is this has

00:34:32,139 --> 00:34:39,399
been a fairly controversial way of of

00:34:36,940 --> 00:34:41,500
naming callable some people wanted to

00:34:39,399 --> 00:34:45,820
call it function but not all color balls

00:34:41,500 --> 00:34:48,790
are functions there have been different

00:34:45,820 --> 00:34:53,530
proposals for how to separate the

00:34:48,790 --> 00:34:55,540
argument list from the return type in

00:34:53,530 --> 00:34:57,700
the end I looked at all the different

00:34:55,540 --> 00:34:59,500
proposals and this still came out as

00:34:57,700 --> 00:35:00,590
that sort of the most straightforward

00:34:59,500 --> 00:35:03,050
and Lee

00:35:00,590 --> 00:35:05,600
or prone so you have a callable that

00:35:03,050 --> 00:35:08,090
takes three arguments these are the

00:35:05,600 --> 00:35:11,360
types and it has a certain return type

00:35:08,090 --> 00:35:14,480
if you have a callable that takes like

00:35:11,360 --> 00:35:18,530
keyword arguments or as varargs or has

00:35:14,480 --> 00:35:21,310
other strange things currently the pep

00:35:18,530 --> 00:35:24,730
for aid for notation cannot actually

00:35:21,310 --> 00:35:27,230
describe that because the proposals for

00:35:24,730 --> 00:35:29,920
describing all the possible signatures

00:35:27,230 --> 00:35:33,860
that you could have in Python def syntax

00:35:29,920 --> 00:35:37,360
got very complicated because the options

00:35:33,860 --> 00:35:40,790
are that the possibilities are endless

00:35:37,360 --> 00:35:42,800
we didn't want to to sort of color ball

00:35:40,790 --> 00:35:44,900
is really usually used for very simple

00:35:42,800 --> 00:35:46,700
callbacks that are almost always called

00:35:44,900 --> 00:35:49,670
with a fixed number of positional

00:35:46,700 --> 00:35:51,770
parameters and nothing else if you have

00:35:49,670 --> 00:35:54,110
a callback that is more complicated than

00:35:51,770 --> 00:35:55,730
that you can say three dots instead of

00:35:54,110 --> 00:35:58,820
the argument list and then the type

00:35:55,730 --> 00:36:02,870
checker is just supposed to take a break

00:35:58,820 --> 00:36:06,460
from that argument list generic types

00:36:02,870 --> 00:36:09,710
how do you make your own generic types

00:36:06,460 --> 00:36:12,830
you have to define type variables

00:36:09,710 --> 00:36:14,720
that's little clunky in Java that type

00:36:12,830 --> 00:36:16,820
variables are introduced by special

00:36:14,720 --> 00:36:19,340
syntax but in Python the syntax is not

00:36:16,820 --> 00:36:21,770
all that special so you have to tell

00:36:19,340 --> 00:36:25,250
Python I'm defining a type variable but

00:36:21,770 --> 00:36:27,170
usually most people never get to the

00:36:25,250 --> 00:36:29,030
point where they actually need to define

00:36:27,170 --> 00:36:31,400
a generic class because this is usually

00:36:29,030 --> 00:36:34,460
only needed when you're defining a new

00:36:31,400 --> 00:36:37,280
container type if you are defining a new

00:36:34,460 --> 00:36:39,500
container type you may have to define

00:36:37,280 --> 00:36:43,070
one or two type variables in an entire

00:36:39,500 --> 00:36:45,740
module so it's not much overhead to be

00:36:43,070 --> 00:36:48,190
forced to actually use that type fire

00:36:45,740 --> 00:36:51,290
function to define those type variables

00:36:48,190 --> 00:36:54,920
and now we can say we have class chart

00:36:51,290 --> 00:36:57,650
and apparently this is a variation of

00:36:54,920 --> 00:37:00,290
the chart I had before where the labels

00:36:57,650 --> 00:37:02,810
could be of type T and so we can have a

00:37:00,290 --> 00:37:06,800
chart of string but we could also have a

00:37:02,810 --> 00:37:09,110
chart of a tuple of int and string which

00:37:06,800 --> 00:37:11,690
would make every label a tuple of an int

00:37:09,110 --> 00:37:14,360
in the string of course nevertheless

00:37:11,690 --> 00:37:19,190
this is just sort of a watered down for

00:37:14,360 --> 00:37:21,110
you know things you can do in Java you

00:37:19,190 --> 00:37:25,010
can also do this with functions you can

00:37:21,110 --> 00:37:29,630
define a generic function without having

00:37:25,010 --> 00:37:33,440
it inside a generic class I don't really

00:37:29,630 --> 00:37:36,350
care about this detail all that much I

00:37:33,440 --> 00:37:42,680
also have a request for the organizers

00:37:36,350 --> 00:37:47,840
can I go a little over thank you I will

00:37:42,680 --> 00:37:50,330
I will try not to make it too crazy here

00:37:47,840 --> 00:37:52,520
is here is one particular example I'd

00:37:50,330 --> 00:37:55,790
like to show let's say we have a

00:37:52,520 --> 00:37:58,820
function that calls the built-in split

00:37:55,790 --> 00:38:00,710
and we try to annotate it and it takes a

00:37:58,820 --> 00:38:03,310
line which is a string and a separator

00:38:00,710 --> 00:38:07,090
which is an optional string essentially

00:38:03,310 --> 00:38:09,350
and it returns a list of strings and

00:38:07,090 --> 00:38:11,630
what the function actually does is it

00:38:09,350 --> 00:38:17,660
splits the line but it limits the split

00:38:11,630 --> 00:38:20,210
to at most one split point it turns out

00:38:17,660 --> 00:38:22,700
that that split method also works for

00:38:20,210 --> 00:38:25,970
bytes and we would like to express the

00:38:22,700 --> 00:38:29,000
type of this function so that it's legal

00:38:25,970 --> 00:38:31,760
for the color to call split one with a

00:38:29,000 --> 00:38:33,770
string or with bytes this is Python free

00:38:31,760 --> 00:38:36,800
of cars without strings and bytes or

00:38:33,770 --> 00:38:40,730
different things so our first attempt

00:38:36,800 --> 00:38:43,250
and bear with me let's say that any stir

00:38:40,730 --> 00:38:44,870
is a union of string or bytes which

00:38:43,250 --> 00:38:47,660
means that can either be a string or

00:38:44,870 --> 00:38:50,210
byte by the way this this is valid you

00:38:47,660 --> 00:38:53,060
can define your own type aliases so that

00:38:50,210 --> 00:38:55,040
you don't have to type so much so we

00:38:53,060 --> 00:38:57,950
define our split one function and now we

00:38:55,040 --> 00:39:00,260
say the argument is in any stir and the

00:38:57,950 --> 00:39:02,600
separator is an optional and easter and

00:39:00,260 --> 00:39:07,430
it returns a list of any stirrers and

00:39:02,600 --> 00:39:08,900
the body is still the same sadly there

00:39:07,430 --> 00:39:12,340
are two problems with that the first

00:39:08,900 --> 00:39:16,190
problem is that the function is actually

00:39:12,340 --> 00:39:20,690
more strict than what you would think

00:39:16,190 --> 00:39:25,030
given that signature because if the line

00:39:20,690 --> 00:39:27,619
is a string and the separator is a bytes

00:39:25,030 --> 00:39:29,839
it doesn't actually work

00:39:27,619 --> 00:39:31,759
and it turns out that if you feed that

00:39:29,839 --> 00:39:34,819
to the type checker the type checker is

00:39:31,759 --> 00:39:41,180
full of enthusiastic rejection of what

00:39:34,819 --> 00:39:45,079
you just wrote so we do something else

00:39:41,180 --> 00:39:46,640
we use a type variable and we this is a

00:39:45,079 --> 00:39:49,910
little bit of magic that you can

00:39:46,640 --> 00:39:53,029
actually came up with we constrain the

00:39:49,910 --> 00:39:55,609
type variable by calling type far with

00:39:53,029 --> 00:39:57,229
still type var always needs to take the

00:39:55,609 --> 00:39:59,299
name of the type variable that you're

00:39:57,229 --> 00:40:01,279
creating but now you give it extra

00:39:59,299 --> 00:40:07,390
positional arguments that are themselves

00:40:01,279 --> 00:40:11,930
types although they look like classes

00:40:07,390 --> 00:40:13,999
and now this type variable works like a

00:40:11,930 --> 00:40:17,269
type variable n Easter is just like that

00:40:13,999 --> 00:40:21,739
T we had earlier but the type checker

00:40:17,269 --> 00:40:23,479
also knows that when you call it so it

00:40:21,739 --> 00:40:25,489
knows it knows basically two things it

00:40:23,479 --> 00:40:27,529
knows that the line and step arguments

00:40:25,489 --> 00:40:32,239
must correspond they must either be both

00:40:27,529 --> 00:40:35,539
strings or both bytes and there must not

00:40:32,239 --> 00:40:37,700
be anything else and so that's how we

00:40:35,539 --> 00:40:41,779
solve this particular problem and it

00:40:37,700 --> 00:40:44,359
turns out okay if if we now make the

00:40:41,779 --> 00:40:47,119
runtime mistake we get a complaint from

00:40:44,359 --> 00:40:49,039
the type checker but the function itself

00:40:47,119 --> 00:40:50,809
is perfectly fine according to the type

00:40:49,039 --> 00:40:53,269
checker which is correct it is perfectly

00:40:50,809 --> 00:40:55,819
fine and this is actually such a common

00:40:53,269 --> 00:40:58,190
case that we have any ster predefined

00:40:55,819 --> 00:41:03,319
exactly as I was written on the previous

00:40:58,190 --> 00:41:05,269
slides in the typing module the

00:41:03,319 --> 00:41:09,109
constraint is a little bit magical that

00:41:05,269 --> 00:41:12,400
if any of the arguments is a sub has a

00:41:09,109 --> 00:41:15,469
type that is actually a subclass of ster

00:41:12,400 --> 00:41:17,900
that the type the type checker reduces

00:41:15,469 --> 00:41:20,690
that to exactly the the base class that

00:41:17,900 --> 00:41:24,249
is actually listed in the type variable

00:41:20,690 --> 00:41:27,799
so that we don't make the mistake of

00:41:24,249 --> 00:41:32,719
expecting that it will also return that

00:41:27,799 --> 00:41:35,089
same subclass because often subclasses

00:41:32,719 --> 00:41:39,430
of ster are very impure and their

00:41:35,089 --> 00:41:39,430
operations return regular stores

00:41:39,780 --> 00:41:45,930
I think that was the most complicated

00:41:43,410 --> 00:41:48,750
part that I wanted to talk about there

00:41:45,930 --> 00:41:51,360
is a whole bunch of pragmatic stuff like

00:41:48,750 --> 00:41:54,420
if you have if you're defining a

00:41:51,360 --> 00:41:58,590
container type or say a node for a

00:41:54,420 --> 00:42:00,600
binary tree you often need to name you

00:41:58,590 --> 00:42:03,480
want to mention the class that you're

00:42:00,600 --> 00:42:07,410
defining in the argument signature for

00:42:03,480 --> 00:42:09,600
some of the methods and it turns out

00:42:07,410 --> 00:42:12,030
that the way cpython works or the way

00:42:09,600 --> 00:42:14,820
python is defined that class object is

00:42:12,030 --> 00:42:16,860
not actually created and the name node

00:42:14,820 --> 00:42:19,320
is not actually defined until you've

00:42:16,860 --> 00:42:22,980
reached the bottom of the class so the

00:42:19,320 --> 00:42:25,080
reference referencing the class in the

00:42:22,980 --> 00:42:27,660
annotation of one of the methods doesn't

00:42:25,080 --> 00:42:29,430
work and as a compromise you can put

00:42:27,660 --> 00:42:31,410
string quotes around it and the type

00:42:29,430 --> 00:42:33,990
checker will just strip the string

00:42:31,410 --> 00:42:37,590
quotes and parse it that way well see

00:42:33,990 --> 00:42:39,690
Python or pipe I will just execute it as

00:42:37,590 --> 00:42:43,650
is and set the string in the annotations

00:42:39,690 --> 00:42:45,870
variable lots of other pragmatic things

00:42:43,650 --> 00:42:49,790
like in some cases you want to annotate

00:42:45,870 --> 00:42:54,870
variables we don't want to introduce yet

00:42:49,790 --> 00:42:57,780
we don't yet want to introduce a syntax

00:42:54,870 --> 00:43:01,680
for annotating variables in Python 3 5

00:42:57,780 --> 00:43:04,980
so as a compromise again you can put

00:43:01,680 --> 00:43:07,200
that in a type comment there's a cast

00:43:04,980 --> 00:43:08,760
function there's some debate about what

00:43:07,200 --> 00:43:12,570
the order of the arguments should be I

00:43:08,760 --> 00:43:16,100
think I'll just make it the first there

00:43:12,570 --> 00:43:21,890
are some other things like undefined I

00:43:16,100 --> 00:43:24,540
also implemented in the typing module

00:43:21,890 --> 00:43:30,600
instance and class checking so that if

00:43:24,540 --> 00:43:33,630
you actually have a a union of int and

00:43:30,600 --> 00:43:35,430
ster you can actually ask is 42 an

00:43:33,630 --> 00:43:38,310
instance of that and it will say yes and

00:43:35,430 --> 00:43:42,390
if you ask if 3.15 is an instance of

00:43:38,310 --> 00:43:46,290
that it will say no stop files oh yeah

00:43:42,390 --> 00:43:48,030
last minute this sort of choice was that

00:43:46,290 --> 00:43:50,130
we want this type files to have a

00:43:48,030 --> 00:43:52,750
different extension that wasn't clear in

00:43:50,130 --> 00:43:55,810
the early stages of the proposal

00:43:52,750 --> 00:43:57,790
but it is just too handy to be able to

00:43:55,810 --> 00:43:59,410
have stop file live in the same

00:43:57,790 --> 00:44:01,510
directory as the source that it

00:43:59,410 --> 00:44:05,620
describes even though that's not always

00:44:01,510 --> 00:44:09,070
how it works and so stop files are named

00:44:05,620 --> 00:44:12,220
py hi what'd you put in the stop file is

00:44:09,070 --> 00:44:15,970
simply class definitions method

00:44:12,220 --> 00:44:19,480
definitions function definitions but you

00:44:15,970 --> 00:44:21,460
can leave the bodies of the functions as

00:44:19,480 --> 00:44:23,620
short as you can like just put paths

00:44:21,460 --> 00:44:25,570
everywhere because the type checker

00:44:23,620 --> 00:44:28,860
looks for the signatures but it doesn't

00:44:25,570 --> 00:44:34,840
do any type checking otherwise

00:44:28,860 --> 00:44:39,460
overloading at some point we would like

00:44:34,840 --> 00:44:41,710
to have multiple dispatch but a good

00:44:39,460 --> 00:44:43,780
multiple dispatch implementation is

00:44:41,710 --> 00:44:47,380
really hard and we kind of ran out of

00:44:43,780 --> 00:44:49,830
time and we don't want to wait for the

00:44:47,380 --> 00:44:52,660
multiple dispatch implementation to land

00:44:49,830 --> 00:44:54,820
before we can use it in stubs because

00:44:52,660 --> 00:44:57,760
they understand especially amongst the

00:44:54,820 --> 00:45:00,460
built-in types and functions there are a

00:44:57,760 --> 00:45:03,100
couple of things that really are sort of

00:45:00,460 --> 00:45:05,560
in dire need of having an overloaded

00:45:03,100 --> 00:45:09,010
signature this example is from the bytes

00:45:05,560 --> 00:45:11,320
class if you pass got get item on a

00:45:09,010 --> 00:45:13,480
bytes object an integer argument and it

00:45:11,320 --> 00:45:15,700
returns an integer it returns the byte

00:45:13,480 --> 00:45:18,220
at that position but if you pass it a

00:45:15,700 --> 00:45:22,240
slice it returns a bytes object which is

00:45:18,220 --> 00:45:24,370
the slice of of bytes indicated by that

00:45:22,240 --> 00:45:28,270
slice so that's a clear example of

00:45:24,370 --> 00:45:31,920
overloading but sort of as a compromise

00:45:28,270 --> 00:45:34,630
you can only use overload in stub files

00:45:31,920 --> 00:45:38,700
let's see what else do we have

00:45:34,630 --> 00:45:41,980
oh yeah and I mentioned this earlier if

00:45:38,700 --> 00:45:43,960
you're if you're already a happy user of

00:45:41,980 --> 00:45:46,210
type annotations and you have different

00:45:43,960 --> 00:45:48,640
interpretation of type annotations you

00:45:46,210 --> 00:45:52,300
might want to disable them so you can

00:45:48,640 --> 00:45:55,420
stick a class or method decorator know

00:45:52,300 --> 00:45:57,220
type check or you can disable it for the

00:45:55,420 --> 00:45:59,980
whole file by putting type ignore

00:45:57,220 --> 00:46:02,200
comments at the top you can also

00:45:59,980 --> 00:46:04,060
probably use a stub file because the

00:46:02,200 --> 00:46:06,859
type checker will also prefer always

00:46:04,060 --> 00:46:09,650
prefer the stub file over the implement

00:46:06,859 --> 00:46:12,680
let's see what else is there to discuss

00:46:09,650 --> 00:46:18,740
there were a whole bunch of rejected

00:46:12,680 --> 00:46:21,500
alternatives the reason I ended up with

00:46:18,740 --> 00:46:25,069
the current somewhat clunky syntax that

00:46:21,500 --> 00:46:28,069
you can look up in pep for 8:4 is that

00:46:25,069 --> 00:46:30,230
it's easy to parse for example the

00:46:28,069 --> 00:46:32,660
angular bracket syntax is notoriously

00:46:30,230 --> 00:46:34,730
hard to parse because angular brackets

00:46:32,660 --> 00:46:36,740
are also used for comparison operators

00:46:34,730 --> 00:46:39,200
and in Python

00:46:36,740 --> 00:46:43,130
sort of there is no different portion of

00:46:39,200 --> 00:46:45,260
the syntax where types are used types

00:46:43,130 --> 00:46:47,210
are just possible everywhere because

00:46:45,260 --> 00:46:52,040
their classes traditionally are just

00:46:47,210 --> 00:46:54,020
objects the current notation has the

00:46:52,040 --> 00:46:56,240
advantage that there is no new syntax

00:46:54,020 --> 00:46:58,250
added so the typing module can actually

00:46:56,240 --> 00:47:01,369
be used back to Python fleet of 2 at

00:46:58,250 --> 00:47:04,819
least we didn't need any changes to C

00:47:01,369 --> 00:47:08,960
code we didn't need to make any changes

00:47:04,819 --> 00:47:11,240
to other standard library modules and it

00:47:08,960 --> 00:47:13,490
sort of its uniform when you see a

00:47:11,240 --> 00:47:15,260
capitalized word followed by square

00:47:13,490 --> 00:47:17,780
brackets you can be pretty sure that

00:47:15,260 --> 00:47:22,099
we're talking about some kind of type

00:47:17,780 --> 00:47:24,500
thingy now if if if you're one of the

00:47:22,099 --> 00:47:26,780
2,000 people in this room who has a

00:47:24,500 --> 00:47:28,970
strong opinion about type systems there

00:47:26,780 --> 00:47:34,819
are probably a few things you don't like

00:47:28,970 --> 00:47:38,300
about this proposal well it's not

00:47:34,819 --> 00:47:42,950
perfect but it will still help you find

00:47:38,300 --> 00:47:47,630
bugs what can I say so how is it this

00:47:42,950 --> 00:47:51,530
PAP going to be accepted I don't know

00:47:47,630 --> 00:47:57,230
it's probably I I'm hoping to find

00:47:51,530 --> 00:47:59,839
someone I have someone in mind to but

00:47:57,230 --> 00:48:02,810
not myself not one of the PAP offers

00:47:59,839 --> 00:48:07,670
that's that sort of a big constraint who

00:48:02,810 --> 00:48:10,069
is sufficiently independent to give lots

00:48:07,670 --> 00:48:13,520
of good pushback on this proposal and

00:48:10,069 --> 00:48:15,530
that would be the ideal be DFL delegate

00:48:13,520 --> 00:48:18,680
for this PAP if you're not familiar with

00:48:15,530 --> 00:48:19,610
that notion in general when there is a

00:48:18,680 --> 00:48:23,660
pap and

00:48:19,610 --> 00:48:26,180
I don't understand the topic or I'm too

00:48:23,660 --> 00:48:29,330
closely involved with the creation of

00:48:26,180 --> 00:48:31,460
the pep someone else some other senior

00:48:29,330 --> 00:48:34,000
person or knowledgeable person in the

00:48:31,460 --> 00:48:36,770
Python community needs to sort of

00:48:34,000 --> 00:48:39,500
volunteer to be the BD FL for that

00:48:36,770 --> 00:48:44,270
particular pep so they can have the last

00:48:39,500 --> 00:48:46,040
say in approving or rejecting it again

00:48:44,270 --> 00:48:49,130
it will be provisional which means that

00:48:46,040 --> 00:48:55,070
we can still tweak it while 3.5 has

00:48:49,130 --> 00:48:58,040
already rolled out and with apologies to

00:48:55,070 --> 00:48:59,600
the organizers I don't know if there is

00:48:58,040 --> 00:49:04,520
time for questions or if we should just

00:48:59,600 --> 00:49:07,130
go to the closing remarks no questions

00:49:04,520 --> 00:49:09,640
but come track me down I will I'll be

00:49:07,130 --> 00:49:09,640

YouTube URL: https://www.youtube.com/watch?v=2wDvzy6Hgxg


