Title: Curtis Lassam - Hash Functions and You: Partners in Freedom - PyCon 2015
Publication date: 2015-04-12
Playlist: PyCon 2015
Description: 
	"Speaker: Curtis Lassam

Our trusty friend, the hash function, is as crucial to programming as linked lists or recursion, but it doesn't always get the press that it deserves. 

We're going to talk about hash functions, some data structures involving hash functions, the stately bloom filter, and the security implications of password hashing. 

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:31,200 --> 00:00:38,380
ABOUT HASH FUNCTIONS AND YOU, PARTNERS IN FREEDOM.

00:00:38,380 --> 00:00:46,410
>> HELLO, I'M CURTIS LASSAM, CLASSAM ON TWITTER.

00:00:46,410 --> 00:00:50,320
WE'LL TALK ABOUT HASH FUNCTIONS.

00:00:50,320 --> 00:00:55,630
I'M GOING TO SHOW YOU WHY THIS FUNDAMENTAL TECHNIQUE BELONGS IN YOUR TOOL KIT AND YOU'LL

00:00:55,630 --> 00:00:58,710
SEE I'M NOT A HANDYMAN.

00:00:58,710 --> 00:01:08,180
WE'RE GOING TO TALK ABOUT HASH FUNCTIONS, #FILTER, BLOOM FILTERS AND HASHES INSECURITY.

00:01:08,180 --> 00:01:09,180
WHAT IS A HASH FUNCTION?

00:01:09,180 --> 00:01:10,220
THE VERY BEGINNING.

00:01:10,220 --> 00:01:12,090
HERE IS AN EXAMPLE.

00:01:12,090 --> 00:01:18,130
IT TAKES A STRING, SPLITS ITS INTO CHARACTERS, CONVERTS EVERY CHARACTER INTO AN INTEGER,

00:01:18,130 --> 00:01:20,672
ADDS THE INTEGERS TOGETHER AND MODELS THE RESULT

00:01:20,672 --> 00:01:21,750
BY 100.

00:01:21,750 --> 00:01:23,200
THIS IS A HASH IF YOU THINK.

00:01:23,200 --> 00:01:26,590
NOT EVERY HASH FUNCTION WORKS THIS WAY BUT THIS,

00:01:26,590 --> 00:01:28,470
LIKE MANY OTHER FUNCTIONS, IS AN EXAMPLE OF A

00:01:28,470 --> 00:01:29,720
HASH FUNCTION.

00:01:29,720 --> 00:01:32,740
IT HAS A NUMBER OF USEFUL PROPERTIES.

00:01:32,740 --> 00:01:34,930
REGARDLESS OF WHAT SEQUENCE OF CHARACTERS YOU PUT

00:01:34,930 --> 00:01:37,170
IN, YOU'RE GUARANTEED THAT THE OUTPUT WILL ALWAYS

00:01:37,170 --> 00:01:39,100
BE BETWEEN 0 AND 99.

00:01:39,100 --> 00:01:42,570
THE OUTPUT FOR A STRING WILL ALWAYS BE THE SAME.

00:01:42,570 --> 00:01:45,140
AND MANY DIFFERENT INPUTS CAN PRODUCE THE SAME

00:01:45,140 --> 00:01:46,330
OUTPUT.

00:01:46,330 --> 00:01:49,289
ALSO, GIVEN THE OUTPUT, IT'S IMPOSSIBLE TO GUESS

00:01:49,289 --> 00:01:51,119
THE INPUT THAT PRODUCED IT.

00:01:51,119 --> 00:01:56,649
I KNOW INVOKING THE WIKIPEDIA DEFINITION OF SOMETHING IS THE PRESENTATION EQUIVALENT TO

00:01:56,649 --> 00:01:58,820
OPENING WITH WEBSTER DEFINITIONS DEFINES BUT THE

00:01:58,820 --> 00:02:02,200
WIKIPEDIA HAS A GOOD DEFINITION OF A HASH FUNCTION.

00:02:02,200 --> 00:02:04,490
A HASH FUNCTION IS ANY ALGORITHM THAT MAPS DATA

00:02:04,490 --> 00:02:07,070
OF ARBITRARY LENGTH TO DATA OF A FIXED LENGTH.

00:02:07,070 --> 00:02:10,569
SO WHATEVER YOU PUT IN, YOU GET DATA OF A CERTAIN

00:02:10,569 --> 00:02:11,760
LENGTH.

00:02:11,760 --> 00:02:14,250
THAT'S HASH FUNCTION.

00:02:14,250 --> 00:02:15,930
LET'S TALK ABOUT HASH TABLES.

00:02:15,930 --> 00:02:19,230
THEY'RE A DATA CONCEPT USED TO STORE KEYS AND

00:02:19,230 --> 00:02:20,349
VALUES.

00:02:20,349 --> 00:02:22,100
KEYS AND VALUES ARE IMPORTANT, YOU DEAL WITH THEM

00:02:22,100 --> 00:02:25,790
WHEN YOU WORK WITH THINGS LIKE MUNGO DB OR PYTHON

00:02:25,790 --> 00:02:28,750
DICT, AND IF YOU'RE DEALING WITH KEYS AND VALUES,

00:02:28,750 --> 00:02:32,120
CHANCES ARE BEHIND THE SCENES SOMETHING CLEAR WITH HASH TABLES IS HAPPENING.

00:02:32,120 --> 00:02:36,750
IT COULD BE A TREE OR A TRI, BUT WE'RE NOT TALKING ABOUT THOSE SO WE'LL PRETEND THEY

00:02:36,750 --> 00:02:38,840
DON'T EXIST.

00:02:38,840 --> 00:02:40,920
SO LET'S START WITH A BIG BLOCK OF MEMORY, AN

00:02:40,920 --> 00:02:43,310
ARRAY WITH 100 ELEMENTS.

00:02:43,310 --> 00:02:49,939
WE WANT TO STORE THE VALUE, HASH 215D29 AGAINST THE KEY COLOR SO, WE RUN A HASH FUNCTION ON

00:02:49,939 --> 00:02:54,100
THE KEY, COLOR, THIS PRODUCES A NUMBER WHICH WE

00:02:54,100 --> 00:02:57,020
MOD BY THE LENGTH OF OUR TABLE AND THIS GIVES

00:02:57,020 --> 00:02:58,909
US AN INDEX.

00:02:58,909 --> 00:03:04,760
AND THEN WE CAN STORE OUR VALUE AT THE LOCATION POINTED TO BY THE INDEX, THAT'S A HASH TABLE.

00:03:04,760 --> 00:03:06,460
EASY PEASY.

00:03:06,460 --> 00:03:09,739
BUT IT IS NOT SO EASY NOR QUITE SO PEASY.

00:03:09,739 --> 00:03:13,079
AS THE ARRAY FILLS UP WITH VALUES, IT GETS MORE

00:03:13,079 --> 00:03:16,829
AND MORE LIKELY THAT WE'LL HAVE A HASH VALUE POINT TO A SPOT IN THE ARRAY THAT'S ALREADY

00:03:16,829 --> 00:03:18,489
FULL.

00:03:18,489 --> 00:03:22,579
THIS IS CALLED A COLLISION AS YOU MIGHT IMAGINE.

00:03:22,579 --> 00:03:23,890
WHAT DO WE DO WHEN THERE'S ALREADY A VALUE IN THE

00:03:23,890 --> 00:03:26,569
SPOT WHERE WE WANT TO STORE A VALUE?

00:03:26,569 --> 00:03:28,519
WE CAN KEEP WALKING FORWARD IN THE TABLE UNTIL WE

00:03:28,519 --> 00:03:32,359
FIND AN AVAILABLE SPOT, THIS IS CALLED LINEAR PROBING.

00:03:32,359 --> 00:03:35,540
ALTERNATIVELY, WE COULD LINK TO EVERY SPACE IN

00:03:35,540 --> 00:03:38,110
THE ARRAY, THAT WAY OUR HASH TABLES CAN TAKE AS

00:03:38,110 --> 00:03:40,870
MANY VARIABLES AS WE CAN THROW AT IT.

00:03:40,870 --> 00:03:43,840
OR ROOT A TREE AT EVERY SPACE IN THE TABLE.

00:03:43,840 --> 00:03:46,900
THIS, ROOTING A SEPARATE DATA STRUCTURE AT EVERY

00:03:46,900 --> 00:03:50,480
SPOT IN THE TABLE IS CALLED A CHAINED HASH TABLE.

00:03:50,480 --> 00:03:54,189
THERE'S ONE PROBLEM WITH A CHAINED HASH TABLE, HERE THERE'S A BUNCH OF DIFFERENT VALUES STORED

00:03:54,189 --> 00:03:55,379
WHERE WE'RE LOOKING FOR THE KEY.

00:03:55,379 --> 00:03:58,579
GEEZ, HOW DO WE KNOW WHICH IS THE RIGHT ONE.

00:03:58,579 --> 00:04:00,819
WE NEED TO STORE THE KEY WITH THE VALUE IN THE

00:04:00,819 --> 00:04:02,769
SECOND DATA STRUCTURE SO WE CAN MAKE SURE WE'RE

00:04:02,769 --> 00:04:04,829
RETRIEVERING THE RIGHT THING.

00:04:04,829 --> 00:04:06,610
THIS IS GOING TO BE THE CASE ANY TIME WE HAVE TO

00:04:06,610 --> 00:04:07,610
DEAL WITH COLLISION.

00:04:07,610 --> 00:04:09,420
IF WE CAN RETRIEVE MULTIPLE POTENTIAL VALUES FROM

00:04:09,420 --> 00:04:14,069
AUER HASH TABLE, WE NEEDS TO BE ABLE TO TELL WHICH IS THE CORRECT VALUE.

00:04:14,069 --> 00:04:18,220
SO EVEN WITH SOME STRATEGY FOR COLLISION DETECTION IN PLACE, IT'S POSSIBLE FOR THE

00:04:18,220 --> 00:04:21,170
TABLE TO GET SO FULL THAT IT PERFORMS VERY SLUGGISHLY.

00:04:21,170 --> 00:04:23,940
A CROWDED CHAINED HASH TABLE IS ONLY A LITTLE BIT

00:04:23,940 --> 00:04:27,150
BETTER THAN A LINKED LIST.

00:04:27,150 --> 00:04:29,750
OR IN THE CASE OF HASHING STRATEGIES THAT JUST

00:04:29,750 --> 00:04:32,220
SHUFFLE ADDRESSES AROUND, IT'S POSSIBLE FOR THE

00:04:32,220 --> 00:04:35,500
TABLE TO BECOME COMPLETELY FULL.

00:04:35,500 --> 00:04:38,610
WHEN THIS HAPPENS, IT'S TIME TO REBUILD THE HASH?

00:04:38,610 --> 00:04:43,550
THIS IS THE TIME-CONSUMING PROCESS OF ADDRESSING AN EVEN BIGGER WHACK OF MEMORY, TAKING ALL

00:04:43,550 --> 00:04:45,920
THE KEYS OUT OF THE ARRAY, REHASHING THEM AND

00:04:45,920 --> 00:04:48,380
PUTTING THEM IN THE SECONDS ARRAY.

00:04:48,380 --> 00:04:50,750
THERE'S ONE LANGUAGE I CAN THINK OF WHOSE DEFAULT

00:04:50,750 --> 00:04:55,660
HASH TABLE IMPLEMENTATION CAN PERFORM THIS COMPUTATIONALLY IMPORTANT STEP UNEXPECTEDLY

00:04:55,660 --> 00:04:59,760
ANY TIME AN INSERT PUSHES THE LOAD ABOVE THE LOAD

00:04:59,760 --> 00:05:00,790
LIMIT.

00:05:00,790 --> 00:05:02,440
FOR THE SAKE OF POLITENESS, I'M NOT GOING TO

00:05:02,440 --> 00:05:04,130
MENTION WHICH LANGUAGE.

00:05:04,130 --> 00:05:06,410
OF COURSE, LINEAR PROBING AND CHAINED HASHING ARE

00:05:06,410 --> 00:05:09,960
NOT THE ONLY MANAGEMENT STRATEGIES, THERE ARE

00:05:09,960 --> 00:05:12,720
MANY WAYS TO MANAGE A HASH TABLE, LIKE ROBIN HOOD

00:05:12,720 --> 00:05:15,170
HASHING WHICH STEALS DATA FROM THE RICHER TABLES

00:05:15,170 --> 00:05:22,410
AND PUT ITS INTO THE POORER TABLES, OR HOPSCOTCH WHERE YOU ARRAY IT ON THE PAVEMENT.

00:05:22,410 --> 00:05:26,290
YOU PROBABLY SHOULDN'T FACT-CHECK ME ON THOSE LAST TWO.

00:05:26,290 --> 00:05:30,170
SO A HASH TABLE USES THE HASH FUNCTION AS A

00:05:30,170 --> 00:05:33,500
LOCATION TO STORE THE DATA IN MEMORY.

00:05:33,500 --> 00:05:35,620
INSERT HAPPENS IN CONSTANT TIME.

00:05:35,620 --> 00:05:37,590
DELETE HAPPENS IN CONSTANT TIME.

00:05:37,590 --> 00:05:39,750
LOOK UP, HAPPENS IN CONSTANT TIME.

00:05:39,750 --> 00:05:42,600
AND YOU SHOULDN'T LINEAR SEARCH THROUGH A HASH

00:05:42,600 --> 00:05:45,360
TABLE.

00:05:45,360 --> 00:05:47,690
SO THAT FIRST FEW MINUTES OF THE PRESENTATION WAS

00:05:47,690 --> 00:05:49,470
THERE TO GET YOU UP TO SPEED ON THE BASIC.

00:05:49,470 --> 00:05:51,560
NOW LET'S GET TO SOME OF MEAT OF THE PRESENTATION.

00:05:51,560 --> 00:05:54,280
BLOOM FILTERS, THEY'RE FINANCE.

00:05:54,280 --> 00:05:58,190
A BLOOM FILTER IS A GREAT WAY TO KEEP BALLOONS OUT OF YOUR FACE.

00:05:58,190 --> 00:06:01,400
A BLOOM FILTER IS A DATA STRUCTURE THAT'S FAST

00:06:01,400 --> 00:06:05,870
AND SPACE EFFICIENT, USED TO TEST FOR MEMBERSHIP IN A SET.

00:06:05,870 --> 00:06:08,120
THAT'S IMPORTANT, IT TESTS FOR SET MEMBERSHIP, IT

00:06:08,120 --> 00:06:12,570
DOESN'T STORE ANY DATA, IT CAN TELL YOU IF SOMETHING IS IN A SET BUT YOU CAN'T RETRIEVE

00:06:12,570 --> 00:06:14,940
AN ITEM FROM THE SET.

00:06:14,940 --> 00:06:20,250
LIKE IF WE HAVE THREE OBJECTS, BANANA, APPLE, BOWLING BALL AND A BLOOM FILTER REPRESENTING

00:06:20,250 --> 00:06:23,380
THE SET OF FRUIT, WE CAN USE THE SET TO DETERMINE

00:06:23,380 --> 00:06:26,030
THE BANANA AND APPLE ARE PROBABLY FRUIT AND THAT

00:06:26,030 --> 00:06:28,630
BOWLING BALL IS DEFINITELY NOT.

00:06:28,630 --> 00:06:30,540
BUT WE CAN'T GIVE YOU A HIS OF ALL THE FRUIT THAT

00:06:30,540 --> 00:06:32,120
WE'RE USED TO POPULATE THE SET.

00:06:32,120 --> 00:06:33,940
WE DON'T KNOW THEM.

00:06:33,940 --> 00:06:35,710
SO A LOT OF THE TIME BLOOM FILTERS ARE USED TO

00:06:35,710 --> 00:06:38,500
ANSWER QUESTIONS LIKE, IS CHUMP'S A REAL WORLD?

00:06:38,500 --> 00:06:40,760
NO, CHUPPIES IS NOT A REAL WORLD.

00:06:40,760 --> 00:06:44,630
IS EVIL.YOU A REAL WEBSITE, I DON'T KNOW.

00:06:44,630 --> 00:06:46,890
AND IS MAIN.CSS IN THE CACHE?

00:06:46,890 --> 00:06:51,630
YES, IT IS. IS THIS A BAND IMAGE?

00:06:51,630 --> 00:06:53,490
SO LET'S LOOK AT THE PROBLEM OF BANNED IMAGES A

00:06:53,490 --> 00:06:54,930
LITTLE BIT.

00:06:54,930 --> 00:06:59,990
LET'S IMAGINE WE'RE RUNNING A FORUM AND OUR ITINERANT USERS KEEP POSTING BANNED IMAGES.

00:06:59,990 --> 00:07:02,580
HOW DO WE KNOW, LOOKING AT IMAGE DATA IF AN IMAGE

00:07:02,580 --> 00:07:05,590
HAS BEEN BANNED?

00:07:05,590 --> 00:07:08,070
LET'S SAY WE RUN A HASH FUNCTION ON THE IMAGE.

00:07:08,070 --> 00:07:11,300
YOU CAN HASH IMAGES, HASH JUST ABOUT ANYTHING THAT'S DATA.

00:07:11,300 --> 00:07:13,780
MOD THE RESULT BY THE LENGTH OF AN ARRAY, MOVE TO

00:07:13,780 --> 00:07:16,830
THAT INDEX LOCATION IN THE ARRAY, AND SAVE A LINK

00:07:16,830 --> 00:07:17,830
TO THE IMAGE THERE.

00:07:17,830 --> 00:07:19,810
THEN WHEN WE'RE CHECKING A NEW IMAGE, WE CAN HASH

00:07:19,810 --> 00:07:21,680
IT AND SEE IF IT'S IN OUR ARRAY.

00:07:21,680 --> 00:07:25,030
OF COURSE, THIS IS JUST A BUG STANDARD HASH TABLE

00:07:25,030 --> 00:07:27,520
AND I'M SUPPOSED TO BE TALKING ABOUT BLOOM FILTERS THIS.

00:07:27,520 --> 00:07:29,800
WORKS FINE, THE STRATEGY I'VE USED SO FAR, BUT

00:07:29,800 --> 00:07:32,080
TAKES UP A LOT OF SPACE AND I PROMISED YOU SPACE

00:07:32,080 --> 00:07:34,130
EFFICIENCY.

00:07:34,130 --> 00:07:36,080
LET'S IMAGINE THERE ARE 5,000 IMAGES WE WANT TO

00:07:36,080 --> 00:07:39,630
KEEP OUT OF OR FORUMS AND THEY TAKE UP 100 KILOBYTES EACH.

00:07:39,630 --> 00:07:43,060
THAT MEANS ABOUT A 500 MEGABYTE TABLE OF DUPLICATE IMAGES.

00:07:43,060 --> 00:07:45,530
WHILE NOT A TON OF SPACE, IT'S ENOUGH THAT YOU

00:07:45,530 --> 00:07:47,450
PROBABLY WON'T WANT TO KEEP THAT IN RAM OR SEND

00:07:47,450 --> 00:07:48,540
IT TO A CLIENT.

00:07:48,540 --> 00:07:50,901
REMEMBER, THOUGH, WE DON'T NEED STORAGE FROM THE

00:07:50,901 --> 00:07:56,560
DATA STRUCTURE, WE'RE ONLY INTERESTED IN WHETHER OR NOT THIS IMAGE EXISTS IN OUR DATA STRUCTURE.

00:07:56,560 --> 00:07:58,870
LET'S IMAGINE WE STORE ZEROS IN EVERY SPACE IN

00:07:58,870 --> 00:08:03,860
OUR TABLE AND WE STORE ONES WHERE THE HASH FUNCTIONS LANDS.

00:08:03,860 --> 00:08:06,270
THAT WAY WE CAN CHECK IF AN IMAGE IS BENT BY

00:08:06,270 --> 00:08:13,080
CHECKING IT AND SPOTTING IF IT HAS A ONE IN IT.

00:08:13,080 --> 00:08:15,210
IF THERE'S NO ONE THERE, WE CAN'T POSSIBLY HAVE

00:08:15,210 --> 00:08:17,450
SEEN THAT IMAGE BEFORE.

00:08:17,450 --> 00:08:21,140
THERE'S ONLY ONE SLIGHT PROBLEM WITH THIS TECHNIQUE, WHAT HAPPENS WHEN WE HAVE A DIFFERENT

00:08:21,140 --> 00:08:25,990
IMAGE THAT ACCIDENTALLY COLLIDES WITH AN IMAGE THAT WE SET EARLIER.

00:08:25,990 --> 00:08:28,750
THIS CREATES A FALSE-POSITIVE AND UNFAIRLY TAKES

00:08:28,750 --> 00:08:33,430
PICTURES OF NICHOLAS CAGE OUT OF CIRCULATION.

00:08:33,430 --> 00:08:36,010
SO HOW DO WE STOP COLLISIONS LIKE THIS FROM OCCURRING?

00:08:36,010 --> 00:08:40,779
WELL, WE COULD USE A HASH FUNCTION THAT GUARANTEES AN ASTRONOMICALLY LOW PROBABILITY

00:08:40,779 --> 00:08:41,940
OF COLLISION.

00:08:41,940 --> 00:08:44,030
MD5, FOR EXAMPLE.

00:08:44,030 --> 00:08:47,620
IT'S A HASH FUNCTION THAT GUARANTEES AN ASTRONOMICALLY PROBABILITY OF COLLISION BUT

00:08:47,620 --> 00:08:50,589
WITH THAT LOW PROBABILITY OF COLLISION, YOU GET

00:08:50,589 --> 00:08:54,920
AXIOMATICALLY A HIGH NUMBER OF OUTPUTS WITH ONE

00:08:54,920 --> 00:08:59,410
BIT FOR EVERY OUTPUT, YOU'RE SUDDENLY SADDLED WITH FOUR TIMES TEN TO THE 25 TERABYTES IN

00:08:59,410 --> 00:09:02,769
YOUR ARRAY, WHICH IS ALSO A LITTLE BIT UNREALISTIC

00:09:02,769 --> 00:09:05,650
TO CRAM INTO YOUR RAM.

00:09:05,650 --> 00:09:07,660
BUT IT DOES HIT ON ONE OF THE TWO STRATEGIES WE

00:09:07,660 --> 00:09:10,070
COULD USE TO REDUCE COLLISIONS IN OUR BIT ARRAY,

00:09:10,070 --> 00:09:11,370
MORE SPACE.

00:09:11,370 --> 00:09:15,040
LET'S LOOK AT THE LESS OBVIOUS STRATEGY FOR REDUCING COLLISIONS.

00:09:15,040 --> 00:09:17,390
MORE HASH FUNCTIONS.

00:09:17,390 --> 00:09:23,270
INSTEAD OF HASHING OUR IMAGE JUST ONCE, LET'S HASH IT TWICE, WITH TWO DIFFERENT HASH FUNCTIONS.

00:09:23,270 --> 00:09:28,260
THIS GIVES US TWO DIFFERENT LOCATIONS IN THE TABLE, AND WE CAN STORE ONE AT BOTH OF THEM.

00:09:28,260 --> 00:09:30,630
ANOTHER IMAGE MIGHT SHARE THE RESULT OF ONE OF

00:09:30,630 --> 00:09:32,990
THE HASH FUNCTIONS, BUT IT'S NOT AS LIKELY TO

00:09:32,990 --> 00:09:34,720
SHARE THE RESULTS OF ALL OF THEM.

00:09:34,720 --> 00:09:36,820
AND IF ANY OF THE HASH FUNCTIONS POINT TO A

00:09:36,820 --> 00:09:41,330
LOCATION WITH A ZERO IN IT, WE KNOW THAT THIS OBJECT CAN NEVER HAVE BEEN ENTERED INTO THE

00:09:41,330 --> 00:09:43,510
BLOOM FILTER.

00:09:43,510 --> 00:09:48,130
SO THIS IS A BLOOM FILTER, A BIT FIELD AND MULTIPLE HASH FUNCTIONS TO SET THE BITS IN

00:09:48,130 --> 00:09:49,740
THAT FIELD.

00:09:49,740 --> 00:09:55,260
WE PUT ITEMS IN BY HASHING THEM MULTIPLE TIMES AND SETTING THE BITS AT ALL OF THOSE LOCATIONS

00:09:55,260 --> 00:09:59,920
AND WE CHECK IF ITEMS ARE IN THE SET BY HASHING ITEMS MULTIPLE TIMES AND CHECKING IF THE BITS

00:09:59,920 --> 00:10:03,400
ARE SETS AT ALL OF THOSE LOCATIONS.

00:10:03,400 --> 00:10:05,780
THERE ARE SOME DOWNSIDES TO THIS.

00:10:05,780 --> 00:10:10,930
BECAUSE EACH ITEM WE PUT INTO THE BLOOM FILTER HAS MULTIPLE HASH FUNCTIONS, THERE CAN BE

00:10:10,930 --> 00:10:13,620
SOME OVERLAP, WHICH MEANS WE CAN NEVER DELETE ANYTHING

00:10:13,620 --> 00:10:16,000
FROM THE BLOOM FILTER.

00:10:16,000 --> 00:10:21,220
IF WE DO, WE RUN THE RISK OF ACCIDENTALLY DELETING SOMETHING ELSE FROM THE FILL --

00:10:21,220 --> 00:10:22,450
ACCIDENTALLY DELETING SOMETHING ELSE FROM THE

00:10:22,450 --> 00:10:23,450
FILTER.

00:10:23,450 --> 00:10:27,950
ON TOP OF THAT, WE'VE REDUCED THE CHANCE OF COLLISION BUT IT'S IMPRACTICAL TO REDUCE THAT

00:10:27,950 --> 00:10:31,060
CHANCE TO EFFECTIVELY ZERO SO ALWAYS SOME CHANCE

00:10:31,060 --> 00:10:32,380
OF A FALSE POSITIVE.

00:10:32,380 --> 00:10:35,430
HOWEVER, THE PROBABILITY OF A FALSE POSITIVE IS A

00:10:35,430 --> 00:10:38,990
NUMBER THAT WE HAVE SOME CONTROL OVER.

00:10:38,990 --> 00:10:43,420
IF WE KNOW THE DESIRED PROBABILITY OF A COLLISION, IN THE CASE OF OUR IMAGE FILTER,

00:10:43,420 --> 00:10:47,320
LET'S SAY 0.1% AND THE NUMBER OF THINGS THAT WE

00:10:47,320 --> 00:10:51,460
WANT TO PUT 2349 FILTER, WE MENTIONED BEFORE, 5,000

00:10:51,460 --> 00:10:57,150
IMAGES, WE CAN USE HAND-WAVEY MATH TO DETERMINE HOW MUCH SPACE WE NEED AND WHAT WE NEED TO

00:10:57,150 --> 00:10:58,920
GET THE OPTIMAL SOLUTION.

00:10:58,920 --> 00:11:01,090
WAVING MY HANDS, YOU DON'T TO HAVE MEMORIZE THIS

00:11:01,090 --> 00:11:04,260
OR WRITE IT DOWN, IT'S EASY TO FIND ON THE INTERNET.

00:11:04,260 --> 00:11:06,091
SO DOING THIS MATH WITH OUR NUMBERS, WE NEED AN

00:11:06,091 --> 00:11:11,450
ARRAY OF 71,888 BITS, WHICH IS 8.8 KILOBYTES AND

00:11:11,450 --> 00:11:12,910
THAT'S SMALL ENOUGH TO KEEP IT IN RAM.

00:11:12,910 --> 00:11:15,720
WE COULD SEND IT TO THE CLIENT SIDE IF WE WANTED

00:11:15,720 --> 00:11:16,720
TO.

00:11:16,720 --> 00:11:20,370
IT'S EASIER TO WORK WITH.

00:11:20,370 --> 00:11:22,640
AND WE NEED TEN DIFFERENT HASH FUNCTIONS.

00:11:22,640 --> 00:11:24,810
THAT IS TO SAY THE OPTIMAL PACKING REQUIRES THAT

00:11:24,810 --> 00:11:30,560
EACH ITEM WE PLACE IN THE TABLE SET TEN DIFFERENT BITS IN THE BLOOM FILTER.

00:11:30,560 --> 00:11:32,420
A LOT OF THE TIME BLOOM FILTERS ARE PAIRED UP

00:11:32,420 --> 00:11:34,670
WITH OTHER DATA STRUCTURE THAT HANDLE THE ACTUAL

00:11:34,670 --> 00:11:36,210
STORAGE.

00:11:36,210 --> 00:11:43,130
THERE'S SUPER USEFUL WHEN PAIRED WITH DATA STRUCTURES THAT EXHIBIT WORST-CASE PERFORMANCE.

00:11:43,130 --> 00:11:45,250
IN A LINKED LIST OR UNSORTED LARGE ARRAY, FOR

00:11:45,250 --> 00:11:49,200
EXAMPLE, YOU GET THE WORST POSSIBLE CASE WHEN YOU'RE SEARCHING FOR AN ITEM THAT JUST ISN'T

00:11:49,200 --> 00:11:50,220
THERE.

00:11:50,220 --> 00:11:52,010
THE BLOOM FILTER CAN CHECK BEFORE YOU HIT THE

00:11:52,010 --> 00:11:56,220
DATA STRUCTURE IN THE DATA IS IN THE DATA STRUCTURE.

00:11:56,220 --> 00:11:58,230
THEY'RE ALSO VERY USEFUL WHEN THE RETRIEVAL STEP

00:11:58,230 --> 00:11:59,910
FOR DATA TAKES A LONG TIME.

00:11:59,910 --> 00:12:01,930
FOR EXAMPLE, WHEN A NETWORK CALL NEEDS TO BE MADE

00:12:01,930 --> 00:12:04,540
TO A FAR-AWAY DATABASE, A LOCAL BLOOM FILTER IS A

00:12:04,540 --> 00:12:08,980
WONDERFUL WAY TO KNOW IF YOU'RE WASTE CRINGE EVERYBODY'S TIME WITH A REQUEST FOR DATA THAT

00:12:08,980 --> 00:12:11,370
JUST DOESN'T EXIST.

00:12:11,370 --> 00:12:13,279
OR DATA WITH A VERY LOW HIT RATE.

00:12:13,279 --> 00:12:14,540
IF YOU'RE DEALING WITH THE SORT OF DATA WHERE YOU

00:12:14,540 --> 00:12:19,360
GET TEN MISSES FOR EVERY HIT, IS THIS A SUSPICIOUS WEBSITE, FOR EXAMPLE, YOU CAN CATCH

00:12:19,360 --> 00:12:22,850
THE MISSES WITH A BLOOM FILTER.

00:12:22,850 --> 00:12:24,810
SO IN SUMMARY, THIS IS A VERY SMALL SUMMARY FOR

00:12:24,810 --> 00:12:30,160
THE PEOPLE IN THE BACK SO I'LL TRY TO BE LOUD, BLOOM FILTERS ARE FAST, COMPRESSED, STORAGE-FREE

00:12:30,160 --> 00:12:33,610
DATA STRUCTURE USED TO CHECK FOR SET MEMBERSHIP.

00:12:33,610 --> 00:12:39,530
IT'S IMPLEMENTED AS A SET OF HASH FUNCTIONS, POINTING TO A BIT ARRAY, NO RETRIEVAL IS ALLOWED,

00:12:39,530 --> 00:12:43,250
AND NO REMOVAL IS ALLOWED.

00:12:43,250 --> 00:12:45,510
SO NOW LET'S TALK ABOUT HOW TO PICK WHICH HASH

00:12:45,510 --> 00:12:47,940
FUNCTIONS TO USE WHEN YOU'RE BUILDING DATA STRUCTURES.

00:12:47,940 --> 00:12:53,000
I SHOWED YOU MY AWESOME CHEESE HASH FUNCTION EARLIER BUT IT'S TERRIBLE AND ON TOP OF THAT,

00:12:53,000 --> 00:12:54,850
REALLY ONLY WORKS ON STRINGS.

00:12:54,850 --> 00:12:57,560
NOW, THE NUMBER OF DIFFERENT HASH FUNCTIONS ARE

00:12:57,560 --> 00:13:00,430
COUNTLESS, EACH ONE IS A UNIQUE SNOWFLAKE, ONLY

00:13:00,430 --> 00:13:02,910
THREE OF THE ONES ON THIS BOARD ARE MADE UP AND

00:13:02,910 --> 00:13:04,730
IF YOU CAN PICK THEM OUT, I MIGHT GET A CHANCE TO

00:13:04,730 --> 00:13:06,240
ASK YOU WHICH ONES THEY ARE AT THE END OF THE

00:13:06,240 --> 00:13:10,720
PRESENTATION.

00:13:10,720 --> 00:13:11,780
I'LL COME BACK TO THAT SLIDE.

00:13:11,780 --> 00:13:13,120
IF WE NEED TO.

00:13:13,120 --> 00:13:16,770
WHICH ONES DO WE PICK FOR OUR DATA STRUCTURES?

00:13:16,770 --> 00:13:18,370
FOR DATA STRUCTURES, THE PROPERTIES WE'RE LOOKING

00:13:18,370 --> 00:13:21,480
FOR ARE THAT THE HASH FUNCTION SHOULD BE FAST AND

00:13:21,480 --> 00:13:24,140
WELL DISTRIBUTED.

00:13:24,140 --> 00:13:26,950
WHEN WE SAY FAST, WHAT WE MEAN IS NOT CRYPTOGRAPHIC.

00:13:26,950 --> 00:13:29,460
CRYPT CRASH HASHES ARE AWESOME, THEY HAVE A BUNCH

00:13:29,460 --> 00:13:37,710
OF -- THE MOST IMPORTANT ONE, THEY'RE COLLISION RESISTANT, IT'S ASTRONOMICALLY UNLIKELY THAT

00:13:37,710 --> 00:13:39,790
YOU'LL EVER BE ABLE TO FIND TWO DIFFERENT ITEMS

00:13:39,790 --> 00:13:42,420
THAT HAVE THE SAME HASH VALUE.

00:13:42,420 --> 00:13:46,870
BUT THE CRYPTOGRAPHIC FEATURES ALSO MAKE THEM MORE PROCESSER HUNGRY, SO WE SHOULD AVOID

00:13:46,870 --> 00:13:50,350
SHAH OR MD5 WHEN WORKING ON DATA STRUCTURE STUFF WE

00:13:50,350 --> 00:13:55,430
DON'T NEED THE SECURITY.

00:13:55,430 --> 00:13:57,400
SO NON-CRYPTOGRAPHIC.

00:13:57,400 --> 00:14:01,660
AND WELL-DISTRIBUTED WHICH MEANS THAT NO MATTER HOW SIMILAR YOUR DATA IS GOING INTO THE DATA

00:14:01,660 --> 00:14:05,760
STRUCTURE, THE OUTPUT SHOULD APPEAR ALL OVER THE

00:14:05,760 --> 00:14:07,360
SPECTRUM.

00:14:07,360 --> 00:14:11,760
HASH FUNCTIONS THAT EXHIBIT THIS QUALITY ARE KNOWN AS AVALANCHING HASHES, BECAUSE SMALL

00:14:11,760 --> 00:14:14,500
CHANGES IN THE INPUT LEAD TO LARGE CHANGES IN THE

00:14:14,500 --> 00:14:15,880
OUTPUT.

00:14:15,880 --> 00:14:18,240
OF COURSE, THIS IS ALSO A DESIRABLE PROPERTY IN

00:14:18,240 --> 00:14:23,320
CRYPTOGRAPHIC HASHES BUT THIS ONE WE'RE WILLING TO BLOW OUR TIME ON BECAUSE IT'S IMPORTANT

00:14:23,320 --> 00:14:25,290
FOR DATA STRUCTURE THAT HAVE HASH FUNCTIONS TO

00:14:25,290 --> 00:14:28,380
HAVE WELL-DISTRIBUTED HASH FUNCTIONS.

00:14:28,380 --> 00:14:32,620
A COMMON HASH USE FOR THIS PURPOSE IS THE NON-CRYPTO GRAPHIC, WELL AVALANCHING PUBLIC

00:14:32,620 --> 00:14:36,210
DOMAIN MURMUR THREE, IMPLEMENTATIONS EXIST FOR

00:14:36,210 --> 00:14:38,810
MOST MODERN LANGUAGES, INCLUDING PYTHON AND WHICH

00:14:38,810 --> 00:14:44,630
HAS APPEARED IN MOST OPEN SOURCE PRODUCTS.

00:14:44,630 --> 00:14:46,860
IT ALSO HAS A SEED VALUE SO YOU CAN CREATE DOZENS

00:14:46,860 --> 00:14:48,790
OF DIFFERENT HASH FUNCTIONS OUT OF THE MURMUR 3

00:14:48,790 --> 00:14:53,930
BASE HASH FUNCTION, JUST BY CHANGING THE SEED VALUE.

00:14:53,930 --> 00:14:57,360
THERE ARE SOME REASONS, THOUGH, THAT YOU MIGHT ACTUALLY WANT CRYPTOGRAPHIC HASHES IN YOUR

00:14:57,360 --> 00:14:59,050
DATA STRUCTURES.

00:14:59,050 --> 00:15:02,760
A CLEVER ATTACKER, FOR EXAMPLE, MIGHT TAKE ADVANTAGE OF YOUR DATA STRUCTURE AND ONLY

00:15:02,760 --> 00:15:05,880
INSERT DATA THAT MATCHES A CERTAIN SMALL SET OF HASHES,

00:15:05,880 --> 00:15:10,200
FORCING COLLISION AFTER COLLISION, UNTIL YOUR WHOLE APPLICATION FALLS OVER.

00:15:10,200 --> 00:15:14,430
IT'S BEEN DEMONSTRATED THAT PYTHON IS VULNERABLE TO THIS SORT OF ATTACK, ALTHOUGH THE BDFL

00:15:14,430 --> 00:15:16,910
CALL THIS SOME SECURITY RESEARCHERS DRUMMING UP

00:15:16,910 --> 00:15:19,180
BUSINESS.

00:15:19,180 --> 00:15:24,730
IN PEP 456, CHRISTIAN HEIMS LAYS OUT THE REASON BEHIND CHOOSING A CRYPTOGRAPHIC HASH FUNCTION

00:15:24,730 --> 00:15:28,740
AS THE DEFAULT FOR BITS AND BYTES, COMPARING

00:15:28,740 --> 00:15:34,440
THE -- AS WELL AS THE PRIVATE CPYTHON HASH

00:15:34,440 --> 00:15:36,210
IMPLEMENTATION.

00:15:36,210 --> 00:15:42,350
THIS PIP WAS ACCEPTED AND PYTHON 3.4, IT'S SIP

00:15:42,350 --> 00:15:44,899
HASH.

00:15:44,899 --> 00:15:45,899
ONE OTHER THING.

00:15:45,899 --> 00:15:48,430
WE HASHED AN IMAGE TO PUTS IN OUR DATA STRUCTURE EARLIER.

00:15:48,430 --> 00:15:50,640
WHAT SORT OF HASH FUNCTION WORKS ON AN IMAGE?

00:15:50,640 --> 00:15:53,680
MOST OF THEM, REALLY, BUT A PERCEPTUAL HASH, OR

00:15:53,680 --> 00:15:59,690
P-HASH IS DESIGNED 20 CLUSTER SIMILAR IMAGES TOGETHER IN THE HASH OUTPUT.

00:15:59,690 --> 00:16:03,800
FOR EXAMPLE, IF IT'S THE SAME IMAGE BUT SLICED LARGER OR SKEWED TO THE LEFT, IT SHOULD END

00:16:03,800 --> 00:16:06,230
UP WITH A HASH FUNCTION VERY CLOSE TO THE ORIGINAL

00:16:06,230 --> 00:16:07,940
IMAGE.

00:16:07,940 --> 00:16:10,240
OF COURSE, BY NATURE, THIS HASH FUNCTION WON'T BE

00:16:10,240 --> 00:16:11,970
DISTRIBUTED IN THE WAY THAT WE WOULD NEED FOR AN

00:16:11,970 --> 00:16:14,090
OPTIMAL GENERAL PURPOSE DATA STRUCTURE.

00:16:14,090 --> 00:16:17,640
IT'S THE OPPOSITE OF AN AFTER LAP HAVING HASH, SMALL CHANGES IN THE OUTPUT LEAD TO ALMOST

00:16:17,640 --> 00:16:18,810
NO CHANGES IN THE OUTPUT.

00:16:18,810 --> 00:16:20,589
I SAID OUTPUT TWICE IN THAT LAST SENTENCE.

00:16:20,589 --> 00:16:22,649
PAY NO ATTENTION.

00:16:22,649 --> 00:16:25,279
BUT WE CAN PAY -- WE CAN ABUSE THAT PROPERTY SO

00:16:25,279 --> 00:16:27,790
THAT FALSE POSITIVE ARE UNFAIRLY CLUSTERED ON

00:16:27,790 --> 00:16:30,310
IMAGES THAT LOOK VERY SIMILAR TO OUR BAND IMAGES,

00:16:30,310 --> 00:16:32,050
WHICH WOULD ACTUALLY PROBABLY BE A GOOD THING IN

00:16:32,050 --> 00:16:35,190
THE CASE OF TRYING TO FIND BANNED IMAGES, SO THAT

00:16:35,190 --> 00:16:38,640
CONCLUDES THE DATA STRUCTURE PORTIONS OF THE TALK.

00:16:38,640 --> 00:16:41,170
NOW LET'S TACK ABOUT HASH FUNCTIONS CONTRIBUTE TO

00:16:41,170 --> 00:16:44,850
THE SECURITY OF YOUR APPLICATION.

00:16:44,850 --> 00:16:47,110
SO YOU'RE RUNNING A WEB APPLICATION AND THE WORST

00:16:47,110 --> 00:16:49,240
CASE SCENARIO HAPPENS.

00:16:49,240 --> 00:16:51,370
SOME HACKER MAKES OFF WITH THE USER TABLE FROM

00:16:51,370 --> 00:16:52,370
YOUR DATABASE.

00:16:52,370 --> 00:16:53,370
HOW?

00:16:53,370 --> 00:16:55,550
I DON'T KNOW, FOR THE SAKE OF ARGUMENT, LET'S SAY

00:16:55,550 --> 00:16:56,940
SQL INJECTION.

00:16:56,940 --> 00:16:59,150
AT THIS POINT, YOU ARE YOUR USER ARE SHIT OUT OF

00:16:59,150 --> 00:17:03,209
WILL BE, SOME BRIGGAND MADE OFF WITH THEIR PASSWORDS.

00:17:03,209 --> 00:17:06,559
NO, SOMEBODY SECURED THEM BEFORE SAVING THEM.

00:17:06,559 --> 00:17:09,699
HOPEFULLY YOU ARE A AWARE OF THIS.

00:17:09,699 --> 00:17:12,179
IN ORDER TO HIDES THE PASSWORDS, WHEN THE USER

00:17:12,179 --> 00:17:17,949
SAVERS THE PASSWORDS, WE DON'T SAVE THE PASSWORDS ITSELF, WE SAVE THE RESULT OF THE HASH FUNCTION.

00:17:17,949 --> 00:17:20,501
LATER, WHEN THE USER TRIES TO LOG IN, THE THEY

00:17:20,501 --> 00:17:26,949
TRY TO -- THEY PROVIDE A PASSWORD AND WE HASH ITS.

00:17:26,949 --> 00:17:28,750
IF THE TWO ARE CORRECT, THE USER HAS PRIDES THE

00:17:28,750 --> 00:17:31,760
CORRECT PASSWORD.

00:17:31,760 --> 00:17:34,309
IF THE TWO DIFFERENT PASSWORDS EVER COLLIDES, IF

00:17:34,309 --> 00:17:36,950
TWO HASH STREAMS GO TO THE SAME VALUE, IT WOULD

00:17:36,950 --> 00:17:40,440
BE IMPOSSIBLE TO LOG INTO OUR SITE WITH THE WRONG

00:17:40,440 --> 00:17:41,440
PASSWORD.

00:17:41,440 --> 00:17:42,440
THAT'S BAD.

00:17:42,440 --> 00:17:47,210
DO YOU REMEMBER EARLIER WHEN I SAID THAT CRYPTOGRAPHIC HASHES LIKE MD 5, FOR EXAMPLE,

00:17:47,210 --> 00:17:49,169
HAVE A FEATURE CALLED COLLISION RESISTANCE WHICH

00:17:49,169 --> 00:17:51,549
MEANS THAT TWO INPUTS ARE ASTRONOMICALLY UNLIKELY

00:17:51,549 --> 00:17:52,669
TO COLLIDE?

00:17:52,669 --> 00:17:55,919
HERE IS WHERE THAT IS SUPER IMPORTANT.

00:17:55,919 --> 00:17:57,690
NOW OUR PASSWORDS ARE PROTECTED.

00:17:57,690 --> 00:17:58,690
YEP.

00:17:58,690 --> 00:17:59,690
TOTALLY PROTECTED.

00:17:59,690 --> 00:18:01,990
NOTHING CAN POSSIBLY GO WRONG.

00:18:01,990 --> 00:18:05,299
OKAY, SO LET'S TALK ABOUT DICTIONARY ATTACKS, THE

00:18:05,299 --> 00:18:09,690
WAY TO BREAK HASHED PASSWORDS.

00:18:09,690 --> 00:18:14,570
SO WE'VE STOLEN A WHOLE DATABASE FULL OF USER NAMES AND HASH PASSWORDS AND WE WANT TO GET

00:18:14,570 --> 00:18:16,190
AT THE RAW PASSWORDS SO THAT HE CAN TRY THEM

00:18:16,190 --> 00:18:19,779
OUT ON BANKING SITES AND STUFF.

00:18:19,779 --> 00:18:24,700
SO WHAT WE CAN DO IS CREATE A LIST OF EVERYTHING THAT WE CAN THINK OF AS A POSSIBLE PASSWORD,

00:18:24,700 --> 00:18:27,830
AN ENORMOUS COMPREHENSIVE LIST OF PASSWORDS.

00:18:27,830 --> 00:18:31,720
THEN WE USE THE SAME HASH THAT THE PROGRAMMER USED TO HASH THE ORIGINAL PASSWORDS AND WE

00:18:31,720 --> 00:18:34,059
RUN THAT ON EVERY SINGLE ITEM IN OUR GIGANTIC

00:18:34,059 --> 00:18:35,279
PASSWORD LIST.

00:18:35,279 --> 00:18:39,570
NOW WE HAVE A GIANT COLLECTION OF HASHED TO PASSWORDS PAIRS WHICH WE CAN COMPARE AGAINST

00:18:39,570 --> 00:18:42,080
THE ORIGINAL DATA.

00:18:42,080 --> 00:18:47,019
ANY TIME WE FIND A MATCH WITH ONE OF THE HASHES IN OUR SET, WE KNOW WHAT THE PASSWORD MUST

00:18:47,019 --> 00:18:48,279
HAVE BEEN.

00:18:48,279 --> 00:18:53,889
THIS CHECKING OF EVERY HASH IN THE SET AGAINST EVERY HASH IN THE DATABASE IS N SQUARED BUT

00:18:53,889 --> 00:18:56,409
IT'S INHERENTLY VERY PARALYZABLE SO WITH A BIT

00:18:56,409 --> 00:18:59,519
OF OPTIMIZATION, THIS CAN RUN VERY FAST AND SOME

00:18:59,519 --> 00:19:02,179
PEOPLE HAVE MANAGED TO USE GRAPHIC SOFTWARE TO

00:19:02,179 --> 00:19:06,070
RUN THEM VERY QUICKLY.

00:19:06,070 --> 00:19:09,179
SO THIS IS CALLED A PRE-COMPUTED DICTIONARY ATTACK.

00:19:09,179 --> 00:19:13,269
IT'S IMPORTANT TO NOTE THAT THIS ISN'T A RAINBOW TABLE, A RAINBOW TABLE IS A DIFFERENT THING,

00:19:13,269 --> 00:19:15,679
INVOLVE LASH CHAINS THAT ACCOMPLISHES THE SAME

00:19:15,679 --> 00:19:18,519
TASK BUT USING A LOT LESS STORAGE SPACE.

00:19:18,519 --> 00:19:22,669
AND I'M NOT GOING TO DESCRIBE THEM TODAY BECAUSE I'M NOT SURE IF I HAVE ENOUGH TIME AND I DON'T

00:19:22,669 --> 00:19:25,620
UNDERSTAND THEM SUPER WELL.

00:19:25,620 --> 00:19:29,059
SO THE MD 5 HASH FUNCTION IS SO COMMON THAT JUSO

00:19:29,059 --> 00:19:36,059
SOLONAN RELEASED A UTILITY CALLED BOZO CRACK, THAT TAKES A PASSWORD, SEARCHING FOR IT ON

00:19:36,059 --> 00:19:38,820
GOOGLE AND MD5 HASHING EVERYTHING THAT COMES BACK

00:19:38,820 --> 00:19:42,450
IN GOOGLE RESULTS UNTIL IT FINDS A MATCH.

00:19:42,450 --> 00:19:45,160
NOT AS COMPREHENSIVE AS MD5 DICTIONARY BUT STILL

00:19:45,160 --> 00:19:49,570
MANAGES TO BE DEPRESSINGLY EFFECTIVE, 85% EFFECTIVE, SCARY.

00:19:49,570 --> 00:19:54,279
PARTS OF THE REASON THESE ATTACKS ARE SO EFFECTIVE IS BECAUSE EVERY USER'S PASSWORD

00:19:54,279 --> 00:19:56,440
HAS BEEN HASHED WITH THE SAME HASH FUNCTION.

00:19:56,440 --> 00:20:00,039
IT'S POSSIBLE FOR US TO TEST PASSWORDS AGAINST THE ENTIRE TABLE ALL AT ONCE.

00:20:00,039 --> 00:20:03,049
WHILE IT'S UNLIKELY WE'LL NEVER CRACK ALL THE

00:20:03,049 --> 00:20:04,570
PASSWORDS, WE'RE ABLE TO FIND OUT THE USERS WHO

00:20:04,570 --> 00:20:08,360
HAVE SIMPLE PASSWORDS VERY, VERY EASILY.

00:20:08,360 --> 00:20:11,929
JUST TESTING THE WHOLE DATABASE AGAINST THE THOUSAND MOST COMMON PASSWORDS SHOULDN'T TAKE

00:20:11,929 --> 00:20:14,220
MORE THAN AN HOUR AND WILL PROVIDE US WITH A

00:20:14,220 --> 00:20:17,559
WEALTH OF POTENTIAL USEFUL DATA.

00:20:17,559 --> 00:20:21,910
SO WHAT WE WANT TO DO TO REDUCE THE EFFECTIVENESS OF THIS KIND OF ATTACK IS TO USE A DIFFERENT

00:20:21,910 --> 00:20:24,669
HASH FUNCTION FOR EVERY SINGLE PERSON IN THE DATABASE.

00:20:24,669 --> 00:20:27,549
THIS DOESN'T MEAN WE NEED TO ENLIST THOUSANDS OF

00:20:27,549 --> 00:20:31,180
DIFFERENT IMPLEMENTATIONS, WHAT IT MEANS WE NEED

00:20:31,180 --> 00:20:33,840
TO USE ONE WHICH WE SEED WITH A DIFFERENT VALUE

00:20:33,840 --> 00:20:38,679
FOR EACH USER IN THE TABLE.

00:20:38,679 --> 00:20:41,269
IT HAS TO BE A VALUE THAT WE HAVE ACCESS TO.

00:20:41,269 --> 00:20:44,789
BECAUSE WE NEED TO BE ABLE TO RECREATE THIS CUSTOM HASH FUNCTION EVERY TIME WE CHECK THE

00:20:44,789 --> 00:20:46,549
USER'S PASSWORD.

00:20:46,549 --> 00:20:48,739
IT'S QUITE COMMON TO USE THE USER NAME FOR THIS

00:20:48,739 --> 00:20:49,739
VALUE.

00:20:49,739 --> 00:20:51,600
DOESN'T MEAN YOU SHOULD USE THE USER NAME, CRIP

00:20:51,600 --> 00:20:57,759
TO GO FEARS REQUIRE THAT YOU USE A LARGE RANDOM BLOCK TO USE AS A SEED.

00:20:57,759 --> 00:21:01,809
THIS HASH SEEDING VALUE IS CALLED ASSAULT.

00:21:01,809 --> 00:21:07,230
SO ASSAULT IS RANDOM DATA USED AS ADDITIONAL INPUT TO A HASH FUNCTION TO PROTECT AGAINST

00:21:07,230 --> 00:21:10,259
RAINBOW TABLE AND DICTIONARY STYLE ATTACKS.

00:21:10,259 --> 00:21:14,470
OKAY, SO THAT COVERS THE VERY, VERY BASICS.

00:21:14,470 --> 00:21:17,690
AND WHEN I SAY BASIC, I MEAN THE VERY MOST BASICS.

00:21:17,690 --> 00:21:19,850
THIS ISN'T EXACTLY STATE OF THE ART.

00:21:19,850 --> 00:21:23,369
UNIX CRYPT FUNCTIONS FIRST USED SALT HASHES IN

00:21:23,369 --> 00:21:28,350
1976, A FULL DECADE BEFORE I WAS BORN.

00:21:28,350 --> 00:21:30,840
SO NOW LET'S TALK ABOUT NOT USING MD5, WHICH IS

00:21:30,840 --> 00:21:33,149
AN IMPORTANT TOPIC AND HASHES ALL TO ITSELF.

00:21:33,149 --> 00:21:36,040
MD5 IS WELL KNOWN AND WELL UNDERSTOOD AND BEEN IN

00:21:36,040 --> 00:21:37,840
USE FOR A VERY LONG TIME.

00:21:37,840 --> 00:21:42,440
UNFORTUNATELY, IN THAT VERY LONG TIME, SOME CRACKS HAVE BEGUN TO SHOW IN THIS VENERABLE

00:21:42,440 --> 00:21:44,890
HASHING ALGORITHM.

00:21:44,890 --> 00:21:49,009
THE BIGGEST REASON TO AVOID IT IS IT'S TOO FAST.

00:21:49,009 --> 00:21:52,629
IT'S POSSIBLE TO MD5 HASH MILLIONS OF VARIABLES PER SECOND.

00:21:52,629 --> 00:21:58,590
THIS MAKES BRUTE FORCE ATTACKS AGAINST PASSWORDS VERY, VERY EASY.

00:21:58,590 --> 00:22:02,429
THIS HASHING PYTHON SCRIPT I WROTE RUNS ON A

00:22:02,429 --> 00:22:05,840
CHEAP LITTLE VIRTUAL MACHINE, ONE MILLION MD5

00:22:05,840 --> 00:22:07,419
HASHES IN 1.5 SECONDS.

00:22:07,419 --> 00:22:12,490
AND THIS IS JUST LIKE A VAGRANT 512, YOU KNOW, POP-UP VIRTUAL MACHINE ON MY COMPUTER, NOT

00:22:12,490 --> 00:22:15,280
REALLY SOMETHING THAT IS BEEFY WITH A MUCH FASTER

00:22:15,280 --> 00:22:17,059
COMPUTER, YOU CAN RUN MANY MORE HASHES MUCH MORE

00:22:17,059 --> 00:22:19,779
QUICKLY.

00:22:19,779 --> 00:22:30,139
SO INSTEAD OF MD5, I RECOMMEND BCRYPT OR SCRYPT OR PDKF2 BCRYPT IS DESIGNED TO BE SLOW.

00:22:30,139 --> 00:22:34,779
USING THE DEFAULT SITTING ON THE SAME VIRTUAL MACHINE, THIS RUN WHERE I USED BCRYPT INSTEAD

00:22:34,779 --> 00:22:37,690
OF MD5 WOULD TAKE ME 3.4 DAYS.

00:22:37,690 --> 00:22:42,070
THE LAST ONE WAS 1.5 SECONDS, THIS TOOK ME 3.4

00:22:42,070 --> 00:22:43,070
DAYS.

00:22:43,070 --> 00:22:47,070
THIS COMBINED WITH ASSAULT FOR EACH INDIVIDUAL USER MEANS THAT BRUTE FORCING PASSWORDS OUT

00:22:47,070 --> 00:22:49,909
OF A DATABASE COULD TAKE DAYS OR MONTHS PER USER

00:22:49,909 --> 00:22:52,529
RATHER THAN AN HOUR OR TWO.

00:22:52,529 --> 00:22:56,019
IT ALSO COMES WITH A WORK VARIABLE THAT YOU CAN

00:22:56,019 --> 00:23:00,159
CRANK UP TO 11.

00:23:00,159 --> 00:23:06,910
WHEN I TURN IT UP TO 15, MY MILLION HASH SCRIPT GOES FROM 3.4 DAYS TO RUN TO 26 DAYS TO RUN.

00:23:06,910 --> 00:23:09,429
I DIDN'T ACTUALLY LET IT RUN FOR 26 DAYS, I

00:23:09,429 --> 00:23:11,320
ACTUALLY LETS IT RUN FOR A MUCH SMALLER AMOUNT OF

00:23:11,320 --> 00:23:13,480
TIMES AND MULTIPLIED THE TIME.

00:23:13,480 --> 00:23:15,909
SO AT THIS POINT LOGGING A SINGLE USER INTO PLY

00:23:15,909 --> 00:23:17,629
SITE COULD TAKE A COUPLE OF SECONDS, SO I'M NOT

00:23:17,629 --> 00:23:19,309
SURE THEY'RE WILLING TO WAITS THAT LONG BUT NICE

00:23:19,309 --> 00:23:24,230
TO HAVE THE VARIABLE THERE THAT I CAN CRANK UP.

00:23:24,230 --> 00:23:28,799
SO FOR PASSWORD SECURITY, YOU SHOULD BE USING SOMETHING THAT'S SPECIFICALLY DESIGNED FOR

00:23:28,799 --> 00:23:30,539
PASSWORDS SECURITY.

00:23:30,539 --> 00:23:34,090
LIKE BCRYPT OR PBKDF 2.

00:23:34,090 --> 00:23:38,659
BUT EVEN FOR GENERAL PURPOSES, IF YOU'RE LOOKING FOR A SECURE HASH ALL GO RHYTHM, MD5 IS KINDS

00:23:38,659 --> 00:23:41,710
OF OLD AND BROKEN, IT'S BEEN SHOWN THAT YOU CAN

00:23:41,710 --> 00:23:44,870
FORCE COLLISIONS IN MD5, BY RESEARCHERS BUT IT

00:23:44,870 --> 00:23:46,210
COULD HAPPEN.

00:23:46,210 --> 00:23:49,379
SO INSTEAD TRY SECURE HASH ALL GO RHYTHM.

00:23:49,379 --> 00:23:57,789
SO SECURE HASH ALGORITHM, OR SHAR 51123 HAS BECOME A NEW STANDARD FOR GRAPHING, ONE THAT'S

00:23:57,789 --> 00:24:00,999
MUCH MORE SECURE.

00:24:00,999 --> 00:24:06,210
AND THAT'S BEEN HASH FUNCTIONS, HASH TABLES, BLOOM FILTERS, CHOOSING HASH FUNCTIONS AND

00:24:06,210 --> 00:24:09,549
HASHES AND SECURITY, WHICH CONCLUDES THE BODY OF

00:24:09,549 --> 00:24:10,549
THE PRESENTATION.

00:24:10,549 --> 00:24:12,299
NOW, I BELIEVE THAT LEAVES US A LITTLE BIT OF

00:24:12,299 --> 00:24:16,409
TIME FOR Q AND A. BEFORE WE START Q AND A, THOUGH, I'M GOING

00:24:16,409 --> 00:24:20,629
TO BRING UP MY LIST OF FAKE HASH FUNCTIONS AND

00:24:20,629 --> 00:24:23,039
I'M GOING TO SEE IF YOU CAN GUESS WHICH ONES ARE

00:24:23,039 --> 00:24:25,029
THE FAKES.

00:24:25,029 --> 00:24:31,279
[ Audio Indiscernible ] >> NO, NOT THAT ONE.

00:24:31,279 --> 00:24:35,649
SOME 41 WAS A FAKE HASH FUNCTION.

00:24:35,649 --> 00:24:37,200
COME ON HASH FUNCTION SLIGHT, I KNOW YOU'RE IN

00:24:37,200 --> 00:24:38,230
HERE SOMEWHERE.

00:24:38,230 --> 00:24:42,019
OH, IT WAS IN DATA STRUCTURES, IT WASN'T IN SECURITY.

00:24:42,019 --> 00:24:43,179
THAT'S WHY.

00:24:43,179 --> 00:24:45,899
HERE WE GO.

00:24:45,899 --> 00:24:48,940
SO WE'VE SUCCESSFULLY IDENTIFIED SOME 41 AS A

00:24:48,940 --> 00:24:50,190
FAKE HASH.

00:24:50,190 --> 00:24:54,809
[ Audio Indiscernible ] THE LESTER B. PEARSON HASH IS A FAKE HASH.

00:24:54,809 --> 00:24:57,490
THE PIERSON HASH IS A REAL HASH, THOUGH.

00:24:57,490 --> 00:24:59,669
LET'S SEE HERE.

00:24:59,669 --> 00:25:03,309
MD5 IS REAL.

00:25:03,309 --> 00:25:06,949
ANY MORE GUESSES?

00:25:06,949 --> 00:25:10,879
[ Audio Indiscernible ] THE PERFECT HASH IS A REAL HASH.

00:25:10,879 --> 00:25:16,220
THE PERFECT HASH IS A HASH FUNCTION THAT HAS BEEN -- IT'S BEEN CALCULATED IN ADVANCE SO

00:25:16,220 --> 00:25:18,940
THAT THE SET OF INPUTS YOU HAVE PERFECTLY MAP TO

00:25:18,940 --> 00:25:20,299
A SET OF OUTPUTS.

00:25:20,299 --> 00:25:23,179
A REALLY INTERESTING HASH.

00:25:23,179 --> 00:25:25,470
AND -- THE FAKE HASH HERE IS THE COUNTRY HASH.

00:25:25,470 --> 00:25:27,539
CITY HASH IS REAL, COUNTRY HASH IS FAKE.

00:25:27,539 --> 00:25:30,220
PIERSON HASH IS FAKE, LESTER B. PIERSON IS FAKE.

00:25:30,220 --> 00:25:35,809
SOME SOME 42 IS REAL, SOME 41 IS BANNED.

00:25:35,809 --> 00:25:45,079
SO HAVING CONCLUDED THAT, IF YOU HAVE ANY QUESTIONS, NOW WOULD BE THE TIME TO ASK THEM.

00:25:45,079 --> 00:25:52,659
[ Applause ] >> THANK YOU VERY MUCH, AND JUST A REMINDER

00:25:52,659 --> 00:25:56,269
TO PLEASE ASK A QUESTION AND TRY TO BE CONCISE.

00:25:56,269 --> 00:25:57,269
THANKS.

00:25:57,269 --> 00:25:59,179
>> AUDIENCE: JUST A QUICK QUESTION.

00:25:59,179 --> 00:26:01,690
IS THERE A GOOD BLOOM FILTER IMPLEMENTATION FOR

00:26:01,690 --> 00:26:04,679
PYTHON ON PYPY OR SOMETHING?

00:26:04,679 --> 00:26:06,119
>> I HAVE LOOKED AROUND.

00:26:06,119 --> 00:26:08,299
I REMEMBER LOOKING AND EVENTUALLY CREATING MY OWN

00:26:08,299 --> 00:26:12,519
BUT I'M SURE THERE'S ONE ALREADY IN PYTHON SOMEWHERE.

00:26:12,519 --> 00:26:16,489
IT'S A REALLY COMMON DATA STRUCTURE AND MUST EXIST ALREADY, AND I THINK THE REASON I CREATED

00:26:16,489 --> 00:26:18,179
ONE WAS JUST BECAUSE I WANTED TO DO RESEARCH FOR

00:26:18,179 --> 00:26:22,009
THIS PRESENTATION, SO...

00:26:22,009 --> 00:26:27,340
>> AUDIENCE: THANK YOU.

00:26:27,340 --> 00:26:31,369
>> THAT'S ALL THE QUESTIONS.

00:26:31,369 --> 00:26:32,369
>> THANK YOU VERY MUCH.

00:26:32,369 --> 00:26:33,369
>> THANKS, EVERYONE.

00:26:33,369 --> 00:26:33,370

YouTube URL: https://www.youtube.com/watch?v=IGwNQfjLTp0


