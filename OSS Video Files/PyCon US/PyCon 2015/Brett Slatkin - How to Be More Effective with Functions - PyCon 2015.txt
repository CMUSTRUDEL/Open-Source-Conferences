Title: Brett Slatkin - How to Be More Effective with Functions - PyCon 2015
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	"Speaker: Brett Slatkin

Functions improve readability, encourage reuse, and facilitate refactoring. Python has many unique features that make functions significantly more powerful. This talk will show you the best ways to use functions in Python: when *args is helpful and when it'll crash your programs; how to use generators for arguments and return values; the value of keyword vs. keyword-only arguments; and more!

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:25,700 --> 00:00:30,240
hello everyone good morning we're going

00:00:28,860 --> 00:00:33,630
to get started here with the first

00:00:30,240 --> 00:00:35,760
session and so the first talk of the

00:00:33,630 --> 00:00:38,239
first session is Brett Slatkin with how

00:00:35,760 --> 00:00:46,320
to be more effective with functions

00:00:38,239 --> 00:00:48,830
let's all thank him great okay

00:00:46,320 --> 00:00:52,170
can I get on the screen here somewhere

00:00:48,830 --> 00:00:54,330
my presentation uh well okay my name is

00:00:52,170 --> 00:00:56,970
Brett Slatkin I'm a software engineer at

00:00:54,330 --> 00:01:00,440
Google it's my day job I also recently

00:00:56,970 --> 00:01:03,300
wrote a book called effective Python

00:01:00,440 --> 00:01:05,820
I'd like my slides over there there they

00:01:03,300 --> 00:01:08,640
are cool so the talk today is about how

00:01:05,820 --> 00:01:09,930
to be more effective with functions so I

00:01:08,640 --> 00:01:12,120
realize it's the first session the first

00:01:09,930 --> 00:01:14,310
day I'm still drinking my coffee I'm

00:01:12,120 --> 00:01:16,830
still waking up so I'm trying to set

00:01:14,310 --> 00:01:18,810
expectations for this talk really

00:01:16,830 --> 00:01:19,380
quickly show of hands who knows what

00:01:18,810 --> 00:01:21,870
this means

00:01:19,380 --> 00:01:25,320
so who's ever used an expression like

00:01:21,870 --> 00:01:28,530
this in the program it er it er foo is

00:01:25,320 --> 00:01:31,140
it or foo that's great okay good

00:01:28,530 --> 00:01:33,329
yes not that many people probably 10 10

00:01:31,140 --> 00:01:37,320
people so my goal by the end of this

00:01:33,329 --> 00:01:41,399
talk is to tell you what this means this

00:01:37,320 --> 00:01:42,479
is supposed to be a novice talk so this

00:01:41,399 --> 00:01:44,189
is the book this is where you can get

00:01:42,479 --> 00:01:46,350
the slides in code there's a link at the

00:01:44,189 --> 00:01:48,810
top if you go to effective python calm

00:01:46,350 --> 00:01:51,119
it's supposed to be novice talk but it's

00:01:48,810 --> 00:01:53,270
more like every slide is novice but put

00:01:51,119 --> 00:01:56,490
together it's really confusing perhaps

00:01:53,270 --> 00:01:58,380
so please follow along this is the

00:01:56,490 --> 00:02:01,020
agenda that's a lot of words so I'm

00:01:58,380 --> 00:02:02,310
going to just go as I go this is the

00:02:01,020 --> 00:02:04,799
code though that we're going to be

00:02:02,310 --> 00:02:06,570
talking about today so first we're going

00:02:04,799 --> 00:02:08,429
to talk about star args then we're going

00:02:06,570 --> 00:02:09,840
to talk about key word args then we're

00:02:08,429 --> 00:02:11,580
gonna talk about key word only arguments

00:02:09,840 --> 00:02:13,530
then we talk about generators and

00:02:11,580 --> 00:02:15,480
yielding and finally we're going to

00:02:13,530 --> 00:02:18,030
explain why it or foo is it or foo is

00:02:15,480 --> 00:02:20,220
actually a useful thing to do

00:02:18,030 --> 00:02:22,530
can everyone hear me okay I mean doing

00:02:20,220 --> 00:02:24,030
good okay and then people see the slides

00:02:22,530 --> 00:02:26,819
all right in the back and I get a

00:02:24,030 --> 00:02:28,280
thumbs-up cool all right so let's get

00:02:26,819 --> 00:02:33,330
going

00:02:28,280 --> 00:02:35,430
first thing is Starks so I think that

00:02:33,330 --> 00:02:37,030
you should reduce the visual noise in

00:02:35,430 --> 00:02:40,450
your programs by using

00:02:37,030 --> 00:02:42,610
variable position arguments and so let

00:02:40,450 --> 00:02:45,310
me tell you what that means and why so

00:02:42,610 --> 00:02:46,780
here's a function it's a log function it

00:02:45,310 --> 00:02:48,850
takes a message like a string message

00:02:46,780 --> 00:02:51,100
and a list of values that you want to

00:02:48,850 --> 00:02:53,230
print out along with the message if

00:02:51,100 --> 00:02:56,530
there are no values that just prints the

00:02:53,230 --> 00:02:58,540
log message to the terminal if there are

00:02:56,530 --> 00:03:02,440
values in the list then it stringify

00:02:58,540 --> 00:03:05,920
them and it joins them together using a

00:03:02,440 --> 00:03:08,709
comma and then prints it out so pretty

00:03:05,920 --> 00:03:09,670
simple if you want to use it here's how

00:03:08,709 --> 00:03:12,910
use the log function

00:03:09,670 --> 00:03:14,320
you say hey my numbers are 1 & 2 and if

00:03:12,910 --> 00:03:17,140
you have no numbers to print then you

00:03:14,320 --> 00:03:18,720
pass an empty list and it prints nothing

00:03:17,140 --> 00:03:21,340
at the bottom so those are our two cases

00:03:18,720 --> 00:03:23,350
so at the top here is the code at the

00:03:21,340 --> 00:03:26,890
bottom is the output that you expect

00:03:23,350 --> 00:03:28,870
from the program now this is kind of

00:03:26,890 --> 00:03:31,450
ugly because the 1 & 2 has these

00:03:28,870 --> 00:03:33,370
brackets around it extra brackets you

00:03:31,450 --> 00:03:35,200
don't really need when you have no

00:03:33,370 --> 00:03:38,050
values to pass you still have to put an

00:03:35,200 --> 00:03:40,840
empty list there it's really just noisy

00:03:38,050 --> 00:03:42,790
and so you can fix this in Python with

00:03:40,840 --> 00:03:45,070
special syntax for variable position

00:03:42,790 --> 00:03:46,120
arguments and the thing that's really

00:03:45,070 --> 00:03:48,040
nice about it is to take this function

00:03:46,120 --> 00:03:50,260
that operated on the sequence before and

00:03:48,040 --> 00:03:52,630
you just add a star to it that's it

00:03:50,260 --> 00:03:54,910
right there just put in that little star

00:03:52,630 --> 00:03:56,769
and what that does is it makes it so

00:03:54,910 --> 00:03:59,709
your function can work like this so

00:03:56,769 --> 00:04:02,320
where this was the way before you had to

00:03:59,709 --> 00:04:04,630
explicitly pass a list now you can only

00:04:02,320 --> 00:04:06,820
pass the parameters when you want to so

00:04:04,630 --> 00:04:09,070
this is the old usage and this is the

00:04:06,820 --> 00:04:10,900
new usage so this is really nice because

00:04:09,070 --> 00:04:13,269
it reduces the noise of the function

00:04:10,900 --> 00:04:14,500
makes a lot easier to read makes it so

00:04:13,269 --> 00:04:19,750
you don't have to pass an empty list

00:04:14,500 --> 00:04:20,739
which is just really unnecessary one of

00:04:19,750 --> 00:04:22,030
the things though is that maybe you

00:04:20,739 --> 00:04:24,669
already had a list and you wanted to

00:04:22,030 --> 00:04:26,650
pass a list in and you can still do that

00:04:24,669 --> 00:04:28,510
in Python you probably may have seen

00:04:26,650 --> 00:04:31,330
this before so if you have a list you

00:04:28,510 --> 00:04:32,440
can use star on the list the star

00:04:31,330 --> 00:04:34,630
operator on the list when you make the

00:04:32,440 --> 00:04:36,789
function call and that will have the

00:04:34,630 --> 00:04:39,190
effect of calling it with the parameters

00:04:36,789 --> 00:04:41,470
in line like this so it's the same same

00:04:39,190 --> 00:04:45,669
outcome and you'll see that the what it

00:04:41,470 --> 00:04:47,960
prints is the same in both cases the

00:04:45,669 --> 00:04:50,750
only problem with that is

00:04:47,960 --> 00:04:51,890
if you use a generator in this case the

00:04:50,750 --> 00:04:53,090
program is going to crash

00:04:51,890 --> 00:04:54,800
it might even crash your computer

00:04:53,090 --> 00:04:56,810
depending on what you're doing so this

00:04:54,800 --> 00:05:00,290
is a generator that just yields every

00:04:56,810 --> 00:05:03,680
number starting at zero and you if you

00:05:00,290 --> 00:05:04,850
use the star operator on a generator

00:05:03,680 --> 00:05:06,290
what Python is going to do under the

00:05:04,850 --> 00:05:08,030
covers is it's actually going to iterate

00:05:06,290 --> 00:05:10,940
through that sequence and turn it into a

00:05:08,030 --> 00:05:13,520
tuple and that tuple for all integers

00:05:10,940 --> 00:05:14,780
becomes infinitely large and so

00:05:13,520 --> 00:05:16,400
depending on what your computer is and

00:05:14,780 --> 00:05:18,170
you're you limit like on Linux it'll

00:05:16,400 --> 00:05:19,910
probably crash for the memory error on a

00:05:18,170 --> 00:05:21,740
Mac it might just fill your hard drive

00:05:19,910 --> 00:05:23,720
and swap space until you know something

00:05:21,740 --> 00:05:28,310
your battery drains or something like

00:05:23,720 --> 00:05:30,130
that so this is this is beware and so

00:05:28,310 --> 00:05:32,960
the real conclusion here is that

00:05:30,130 --> 00:05:35,390
arguments variable position arguments

00:05:32,960 --> 00:05:37,310
are really good for moving noise it's to

00:05:35,390 --> 00:05:39,830
make your code more readable it's not

00:05:37,310 --> 00:05:41,840
just saying like oh all of my API should

00:05:39,830 --> 00:05:43,910
work on a sequence so I'll just have it

00:05:41,840 --> 00:05:45,080
work on it on star arcs you really

00:05:43,910 --> 00:05:46,370
should only use it for the convenience

00:05:45,080 --> 00:05:50,260
of the programmer for the readability of

00:05:46,370 --> 00:05:54,950
your code it's not there to be a an N

00:05:50,260 --> 00:05:56,180
API versus a single call API so that's

00:05:54,950 --> 00:05:59,050
okay that's the first one trying to get

00:05:56,180 --> 00:06:01,490
harder and harder as they go next one is

00:05:59,050 --> 00:06:03,400
providing optional behavior with keyword

00:06:01,490 --> 00:06:07,100
arguments so I think you should do this

00:06:03,400 --> 00:06:08,870
and there's keyword argument right there

00:06:07,100 --> 00:06:10,940
so okay motivating example here I

00:06:08,870 --> 00:06:12,800
thought it needs to be more connected to

00:06:10,940 --> 00:06:14,600
the real world so imagine that you are

00:06:12,800 --> 00:06:17,450
trying to calculate the flow rate this

00:06:14,600 --> 00:06:19,430
is my high quality illustration maybe

00:06:17,450 --> 00:06:20,150
this is cream cheese for bagels or

00:06:19,430 --> 00:06:22,340
something like that

00:06:20,150 --> 00:06:24,830
I don't whatever they do in this town I

00:06:22,340 --> 00:06:27,110
have a scale I have a VAT sitting on a

00:06:24,830 --> 00:06:30,200
scale I have a clock and the idea is

00:06:27,110 --> 00:06:32,210
that I'm calculating how much material

00:06:30,200 --> 00:06:34,670
has flown into the VAT at some period

00:06:32,210 --> 00:06:36,590
okay and the idea is I can calculate the

00:06:34,670 --> 00:06:38,660
rate of flow by taking different weights

00:06:36,590 --> 00:06:40,310
at different times and then calculating

00:06:38,660 --> 00:06:44,090
the difference it's also known as

00:06:40,310 --> 00:06:46,910
division so this is a flow rate so this

00:06:44,090 --> 00:06:48,410
is our function and so this is great you

00:06:46,910 --> 00:06:51,050
can put it to work so if I have half a

00:06:48,410 --> 00:06:54,170
kilogram going into a VAT in three

00:06:51,050 --> 00:06:59,040
seconds that's going to be 167 grams per

00:06:54,170 --> 00:07:01,650
second 0.16 seven kilograms per second

00:06:59,040 --> 00:07:04,470
and and that's great and so this works

00:07:01,650 --> 00:07:06,270
as you expect with division in Python 3

00:07:04,470 --> 00:07:09,270
because that's not integer division but

00:07:06,270 --> 00:07:10,380
that's a separate story but now let's

00:07:09,270 --> 00:07:12,300
say that you wanted to support some

00:07:10,380 --> 00:07:14,550
alternative units like I'm from America

00:07:12,300 --> 00:07:17,700
so I use imperial units for some reason

00:07:14,550 --> 00:07:19,380
and so I want to add to this the ability

00:07:17,700 --> 00:07:21,180
to do pounds and maybe I want to

00:07:19,380 --> 00:07:24,720
calculate flow rates over longer periods

00:07:21,180 --> 00:07:26,550
of time so to do that I can add these

00:07:24,720 --> 00:07:28,800
two parameters the period and the units

00:07:26,550 --> 00:07:30,150
per kilogram conversion rates and this

00:07:28,800 --> 00:07:32,130
is just a simple unit conversion

00:07:30,150 --> 00:07:34,980
function I just added in some extra

00:07:32,130 --> 00:07:38,220
multipliers so I can put this to work

00:07:34,980 --> 00:07:39,840
now using some extra parameters here I

00:07:38,220 --> 00:07:42,630
have keywords in there to make it really

00:07:39,840 --> 00:07:47,100
clear what I'm trying to do and you'll

00:07:42,630 --> 00:07:50,100
see so now I pass in 3600 seconds for an

00:07:47,100 --> 00:07:52,290
hour and 2.2 pounds per kilogram and I

00:07:50,100 --> 00:07:54,150
get out the same numbers as before our

00:07:52,290 --> 00:07:56,760
thirteen hundred and twenty pounds per

00:07:54,150 --> 00:08:01,260
hour is the flow rate in another set of

00:07:56,760 --> 00:08:02,310
units so this works really well but but

00:08:01,260 --> 00:08:04,200
the problem is that you still have to

00:08:02,310 --> 00:08:07,050
pass the unit's even if you don't need

00:08:04,200 --> 00:08:08,700
them so I've added these these

00:08:07,050 --> 00:08:10,470
parameters but they're not optional and

00:08:08,700 --> 00:08:12,180
if you leave them out Python will get

00:08:10,470 --> 00:08:14,040
mad at you and say hey like you need to

00:08:12,180 --> 00:08:16,410
pass the period and the units per

00:08:14,040 --> 00:08:18,000
kilogram so this is noisy it's redundant

00:08:16,410 --> 00:08:20,820
it just doesn't make sense to have to do

00:08:18,000 --> 00:08:22,440
this every time so that's where default

00:08:20,820 --> 00:08:24,570
argument values come in so where the

00:08:22,440 --> 00:08:26,340
function was like this before all we

00:08:24,570 --> 00:08:31,200
have to do is add the default values to

00:08:26,340 --> 00:08:34,050
the function signature with 1 and 1 and

00:08:31,200 --> 00:08:35,940
you get this new behavior new capability

00:08:34,050 --> 00:08:38,370
in the function and what's so cool about

00:08:35,940 --> 00:08:40,290
this is that all existing function calls

00:08:38,370 --> 00:08:43,740
don't have to change so if you're adding

00:08:40,290 --> 00:08:47,130
functionality to an existing to an

00:08:43,740 --> 00:08:49,290
existing function default optional

00:08:47,130 --> 00:08:50,550
arguments are default default values for

00:08:49,290 --> 00:08:52,470
optional arguments let you add

00:08:50,550 --> 00:08:55,140
functionality over time without breaking

00:08:52,470 --> 00:08:56,400
the callers so existing function calls

00:08:55,140 --> 00:08:58,440
on top will just keep thinking it's

00:08:56,400 --> 00:09:00,420
kilograms per second new functions that

00:08:58,440 --> 00:09:01,680
know about the new functionality or new

00:09:00,420 --> 00:09:03,390
calls to the function that know about

00:09:01,680 --> 00:09:05,880
the functionality can pass in the new

00:09:03,390 --> 00:09:08,760
parameters and and get that new

00:09:05,880 --> 00:09:11,640
capabilities of the function so this is

00:09:08,760 --> 00:09:12,649
really nice way to extend things so

00:09:11,640 --> 00:09:14,119
again

00:09:12,649 --> 00:09:17,029
arguments let you admit arguments that

00:09:14,119 --> 00:09:18,199
you don't need new students can access a

00:09:17,029 --> 00:09:19,519
new functionality and then you don't

00:09:18,199 --> 00:09:21,319
have to update you have to refactor your

00:09:19,519 --> 00:09:23,110
code to add functionality which is

00:09:21,319 --> 00:09:28,279
really nice

00:09:23,110 --> 00:09:30,410
ok am I going too fast too slow I'm

00:09:28,279 --> 00:09:31,429
trying to go fast as a mom okay I got

00:09:30,410 --> 00:09:37,720
one thumbs up that means I'm going too

00:09:31,429 --> 00:09:40,839
fast slow down so I want to talk about

00:09:37,720 --> 00:09:46,100
one of the problems with this approach

00:09:40,839 --> 00:09:48,589
of passing keyword arguments and the

00:09:46,100 --> 00:09:50,839
problem is that you're not forced to be

00:09:48,589 --> 00:09:52,639
clear so I think that you should enforce

00:09:50,839 --> 00:09:55,189
clarity with keyword only arguments

00:09:52,639 --> 00:09:57,189
keyword are only arguments make it so

00:09:55,189 --> 00:09:59,509
that you have to be specific about

00:09:57,189 --> 00:10:00,110
default arguments so here's what I'm

00:09:59,509 --> 00:10:01,749
talking about

00:10:00,110 --> 00:10:04,429
let's say that we wanted to calculate

00:10:01,749 --> 00:10:08,660
ounces per second hour per minute going

00:10:04,429 --> 00:10:12,350
into the into the VAT which one of these

00:10:08,660 --> 00:10:14,179
is right well you know is it so 60

00:10:12,350 --> 00:10:15,949
seconds is a minute thirty five point

00:10:14,179 --> 00:10:19,220
two seven four is a count and conversion

00:10:15,949 --> 00:10:21,350
rate for ounces to kilograms but the

00:10:19,220 --> 00:10:22,730
question is was it period the period

00:10:21,350 --> 00:10:23,929
come first to the unit's per kilogram

00:10:22,730 --> 00:10:26,449
come first I don't actually don't even

00:10:23,929 --> 00:10:29,329
remember and I wrote the code it's not

00:10:26,449 --> 00:10:31,459
clear so when you have two parameters of

00:10:29,329 --> 00:10:33,350
the same type you've really got a

00:10:31,459 --> 00:10:35,990
problem because when you look at the

00:10:33,350 --> 00:10:38,899
call site it's not obvious to you what

00:10:35,990 --> 00:10:40,459
each of the parameters refers to and

00:10:38,899 --> 00:10:43,970
you'll see this all over Python code

00:10:40,459 --> 00:10:47,509
this is a really bad practice it's kind

00:10:43,970 --> 00:10:50,029
of like a it's an anti-pattern so

00:10:47,509 --> 00:10:51,649
luckily Python Python 3 and we'll talk

00:10:50,029 --> 00:10:53,749
about Python 2 in a second lets you

00:10:51,649 --> 00:10:55,759
solve this very easily you take this

00:10:53,749 --> 00:10:58,370
function definition from before exactly

00:10:55,759 --> 00:11:02,720
as it was and all you do is you add a

00:10:58,370 --> 00:11:04,730
star to it right there and by doing that

00:11:02,720 --> 00:11:07,970
everything that comes after that star is

00:11:04,730 --> 00:11:09,679
required to be passed as a keyword it's

00:11:07,970 --> 00:11:13,279
a required it just that's it it's all it

00:11:09,679 --> 00:11:15,709
takes and so now when we go to our this

00:11:13,279 --> 00:11:19,759
negative or anti-pattern example from

00:11:15,709 --> 00:11:21,730
before you'll see that python will

00:11:19,759 --> 00:11:23,290
actually complain to us and say hey

00:11:21,730 --> 00:11:24,760
I can't take those arguments

00:11:23,290 --> 00:11:27,699
positionally I have to take them as

00:11:24,760 --> 00:11:29,500
keywords so that's so that's the benefit

00:11:27,699 --> 00:11:31,389
here is that it forces the caller to

00:11:29,500 --> 00:11:34,139
change their code to pass in keyword

00:11:31,389 --> 00:11:38,440
arguments specified using the actual

00:11:34,139 --> 00:11:39,220
parameter name so this is this is the

00:11:38,440 --> 00:11:40,779
best practice

00:11:39,220 --> 00:11:43,240
you should always pass optional keyword

00:11:40,779 --> 00:11:45,820
arguments with the name that's just

00:11:43,240 --> 00:11:47,290
generally good style but especially if

00:11:45,820 --> 00:11:49,480
you have two parameters of the same type

00:11:47,290 --> 00:11:51,279
you really should do keyword only

00:11:49,480 --> 00:11:53,350
arguments so that is never ambiguous

00:11:51,279 --> 00:11:54,550
what is being used for what especially

00:11:53,350 --> 00:11:56,709
if your function is taking like boolean

00:11:54,550 --> 00:11:57,760
values like true and false you really

00:11:56,709 --> 00:12:02,800
need to do that or else it makes no

00:11:57,760 --> 00:12:04,899
sense what's happening really quickly if

00:12:02,800 --> 00:12:09,459
you have a log function like the one

00:12:04,899 --> 00:12:10,660
before and you are you want to extend

00:12:09,459 --> 00:12:12,250
this function this is especially

00:12:10,660 --> 00:12:13,389
problematic so let's say that I want to

00:12:12,250 --> 00:12:16,570
take this log function and add a

00:12:13,389 --> 00:12:18,040
sequence number to it so the sequence

00:12:16,570 --> 00:12:19,750
number could say like what order the

00:12:18,040 --> 00:12:20,050
messages came in for a log or something

00:12:19,750 --> 00:12:22,149
like that

00:12:20,050 --> 00:12:24,360
so here I've added a sequence parameter

00:12:22,149 --> 00:12:26,920
I've added to the first print statement

00:12:24,360 --> 00:12:28,750
so it gets printed first I've added it

00:12:26,920 --> 00:12:30,010
to the second print statement so it

00:12:28,750 --> 00:12:32,800
precedes the message that's been

00:12:30,010 --> 00:12:34,810
formatted now the problem with adding it

00:12:32,800 --> 00:12:37,360
to the beginning is it's going to break

00:12:34,810 --> 00:12:38,709
existing callers so new callers that

00:12:37,360 --> 00:12:40,120
know what's going on they can put a

00:12:38,709 --> 00:12:41,589
sequence number in the first position

00:12:40,120 --> 00:12:43,060
and the log function will work is

00:12:41,589 --> 00:12:47,500
expected you see down here it's one

00:12:43,060 --> 00:12:50,470
colon favorite 733 and that works but

00:12:47,500 --> 00:12:54,459
all old usage is now broken and because

00:12:50,470 --> 00:12:56,829
Python uses percent s and nice ways like

00:12:54,459 --> 00:13:00,430
this percent s like the string format in

00:12:56,829 --> 00:13:02,380
out right there and the percent s in

00:13:00,430 --> 00:13:04,540
that print statement when you do that in

00:13:02,380 --> 00:13:09,279
Python it'll convert anything you throw

00:13:04,540 --> 00:13:11,319
in there correctly and so you know it'll

00:13:09,279 --> 00:13:12,430
hide errors that you never meant to put

00:13:11,319 --> 00:13:13,899
in there you maybe you didn't mean to

00:13:12,430 --> 00:13:15,699
have a string in there maybe you know

00:13:13,899 --> 00:13:16,720
you accidentally passed an object or

00:13:15,699 --> 00:13:18,519
integer or something like that

00:13:16,720 --> 00:13:20,079
Python won't explode when it does this

00:13:18,519 --> 00:13:22,990
and so you get this really wacky

00:13:20,079 --> 00:13:25,060
behavior where the bottom here favorites

00:13:22,990 --> 00:13:26,380
: is the sequence number which is

00:13:25,060 --> 00:13:28,569
definitely not what we wanted like that

00:13:26,380 --> 00:13:30,850
was not the goal so we've broken the

00:13:28,569 --> 00:13:33,100
code and you will not find it like this

00:13:30,850 --> 00:13:36,250
is a total anti-pattern if you're going

00:13:33,100 --> 00:13:38,170
to use variable position arguments never

00:13:36,250 --> 00:13:39,850
do this because you will mess it up you

00:13:38,170 --> 00:13:42,880
will not find that one call or something

00:13:39,850 --> 00:13:45,730
something wrong will happen luckily you

00:13:42,880 --> 00:13:48,730
can solve this problem and all you have

00:13:45,730 --> 00:13:51,699
to do is use a keyword only argument

00:13:48,730 --> 00:13:53,230
this is the syntax in Python 3 and

00:13:51,699 --> 00:13:54,970
python 2 it's slightly different but I

00:13:53,230 --> 00:13:57,160
have it in the appendix if you're

00:13:54,970 --> 00:13:58,839
curious but all you have to do is just

00:13:57,160 --> 00:14:02,649
say ok I also want to get the sequence

00:13:58,839 --> 00:14:04,810
value and what i'm doing here is if the

00:14:02,649 --> 00:14:07,630
sequence value isn't supplied then i

00:14:04,810 --> 00:14:09,519
just pick one so time i just grab the

00:14:07,630 --> 00:14:11,680
current time and i'll set the sequence

00:14:09,519 --> 00:14:13,870
value to the current time and the rest

00:14:11,680 --> 00:14:16,630
of the function is the same and so now

00:14:13,870 --> 00:14:19,060
when i call it new usage works correctly

00:14:16,630 --> 00:14:21,089
by passing a sequence number of one old

00:14:19,060 --> 00:14:23,709
usage that doesn't know what's going on

00:14:21,089 --> 00:14:25,329
continues will continue working and it

00:14:23,709 --> 00:14:28,510
will take on the default value for that

00:14:25,329 --> 00:14:30,519
new keyword argument so this is a really

00:14:28,510 --> 00:14:32,649
nice way to extend any function that

00:14:30,519 --> 00:14:37,750
takes variable arguments without

00:14:32,649 --> 00:14:39,490
breaking existing callers so one more

00:14:37,750 --> 00:14:41,680
time you want to use keyword argue

00:14:39,490 --> 00:14:44,199
keyword only arguments to require

00:14:41,680 --> 00:14:48,040
clarity it's really important if you

00:14:44,199 --> 00:14:50,500
have things of the same type arguments

00:14:48,040 --> 00:14:52,240
of the same type this is really the best

00:14:50,500 --> 00:14:53,649
way to extend star args and you can

00:14:52,240 --> 00:14:55,209
actually do all of this in python to

00:14:53,649 --> 00:14:57,069
this syntax is slightly different it's

00:14:55,209 --> 00:14:59,380
not as pretty but you can achieve the

00:14:57,069 --> 00:15:04,329
same outcome so you can use it there to

00:14:59,380 --> 00:15:06,819
very easily okay how am i doing I'm

00:15:04,329 --> 00:15:08,769
doing okay everybody still with me

00:15:06,819 --> 00:15:11,199
people waking up a little bit okay doing

00:15:08,769 --> 00:15:14,920
okay all right so now it's gonna get a

00:15:11,199 --> 00:15:17,529
little bit harder so let's talk about

00:15:14,920 --> 00:15:22,829
another part of functions returning

00:15:17,529 --> 00:15:26,620
values either lists or generators so I

00:15:22,829 --> 00:15:28,990
have Owen sorry I think that you should

00:15:26,620 --> 00:15:30,730
consider generators instead of returning

00:15:28,990 --> 00:15:33,189
lists I think Python programmers often

00:15:30,730 --> 00:15:35,380
just return lists because it's easy and

00:15:33,189 --> 00:15:37,540
I'd like us to have a kind of a cultural

00:15:35,380 --> 00:15:39,610
change where we instead of saying why

00:15:37,540 --> 00:15:40,410
why I use a generator it's like why are

00:15:39,610 --> 00:15:42,660
you using a list

00:15:40,410 --> 00:15:45,569
you know that should be the default way

00:15:42,660 --> 00:15:48,629
that we implement things and I'm gonna

00:15:45,569 --> 00:15:52,290
try to explain why so let's say I have a

00:15:48,629 --> 00:15:56,160
file of some data this is population of

00:15:52,290 --> 00:15:57,420
people in the province of Quebec and I

00:15:56,160 --> 00:16:00,540
got this from Wikipedia so it might be

00:15:57,420 --> 00:16:02,970
wrong so I'm going to load this data

00:16:00,540 --> 00:16:04,259
file it's tab-separated data here's a

00:16:02,970 --> 00:16:06,509
function to do it

00:16:04,259 --> 00:16:09,329
load city's list it takes the path to

00:16:06,509 --> 00:16:11,490
the file on disk it creates a list of

00:16:09,329 --> 00:16:14,910
output it's going to be the city names

00:16:11,490 --> 00:16:17,339
and the number of people who live there

00:16:14,910 --> 00:16:19,050
I'm going to open up the file as a

00:16:17,339 --> 00:16:21,029
handle I'm going to go through every

00:16:19,050 --> 00:16:23,610
line in the handle I'm going to split

00:16:21,029 --> 00:16:24,899
every line by the tab into the name of

00:16:23,610 --> 00:16:26,459
the city and then how many people live

00:16:24,899 --> 00:16:30,420
in the city then I'm going to append

00:16:26,459 --> 00:16:32,870
that tuple to the to the output list and

00:16:30,420 --> 00:16:36,449
then I'm going to return the output list

00:16:32,870 --> 00:16:38,610
back to the caller and you can put this

00:16:36,449 --> 00:16:41,490
to work you can see that it works I have

00:16:38,610 --> 00:16:43,259
this population tab separated file that

00:16:41,490 --> 00:16:45,449
you can run it on and you'll see that

00:16:43,259 --> 00:16:48,630
Montreal is the largest followed by

00:16:45,449 --> 00:16:52,709
Quebec City and so on and that works

00:16:48,630 --> 00:16:54,180
great the problem is that you might run

00:16:52,709 --> 00:16:57,449
out of memory if you do this in other

00:16:54,180 --> 00:16:58,860
cases so if you have say you know this

00:16:57,449 --> 00:17:00,329
is great for Quebec but let's say you

00:16:58,860 --> 00:17:03,300
want to load this list of cities in the

00:17:00,329 --> 00:17:05,370
entire world something like that giant

00:17:03,300 --> 00:17:07,770
file or other data files besides these

00:17:05,370 --> 00:17:09,689
ones eventually will be so much data in

00:17:07,770 --> 00:17:11,789
this list that you'll run out of memory

00:17:09,689 --> 00:17:13,409
and crash your program won't work so

00:17:11,789 --> 00:17:15,110
generators are great solution to this

00:17:13,409 --> 00:17:18,419
it's really easy to implement them

00:17:15,110 --> 00:17:20,760
here's the list version and here's the

00:17:18,419 --> 00:17:22,169
generator version so what's really

00:17:20,760 --> 00:17:24,809
interesting is it's actually less code

00:17:22,169 --> 00:17:25,829
and it's easier to read so some people

00:17:24,809 --> 00:17:27,390
think about generators those are too

00:17:25,829 --> 00:17:29,280
complicated for me I shouldn't use them

00:17:27,390 --> 00:17:30,809
but really it's actually easier and the

00:17:29,280 --> 00:17:32,400
big differences are you don't need the

00:17:30,809 --> 00:17:34,409
out list anymore you don't have to

00:17:32,400 --> 00:17:37,169
return anything and then when you append

00:17:34,409 --> 00:17:39,030
the the tuple you don't need this extra

00:17:37,169 --> 00:17:41,309
parentheses parentheses which is kind of

00:17:39,030 --> 00:17:46,950
hard to read so just everything gets a

00:17:41,309 --> 00:17:49,110
lot more legible in this version and

00:17:46,950 --> 00:17:50,820
you'll see that it works as before I

00:17:49,110 --> 00:17:52,500
have to call next on it because it's a

00:17:50,820 --> 00:17:53,970
generator an iterator instead of a list

00:17:52,500 --> 00:17:57,780
so you don't have everything right there

00:17:53,970 --> 00:18:00,510
but the benefits are there's less noise

00:17:57,780 --> 00:18:02,670
there's no out equals or return out or

00:18:00,510 --> 00:18:05,040
parentheses parentheses the file can now

00:18:02,670 --> 00:18:08,430
be of any size all of the memory

00:18:05,040 --> 00:18:10,200
problems that we had are gone and this

00:18:08,430 --> 00:18:12,660
question so so again the question should

00:18:10,200 --> 00:18:14,700
be why when you writing a function why

00:18:12,660 --> 00:18:16,440
are you returning a list then why are

00:18:14,700 --> 00:18:18,090
you not defining a generator you should

00:18:16,440 --> 00:18:21,590
just always be defining a generator

00:18:18,090 --> 00:18:21,590
unless you have some really good reason

00:18:22,790 --> 00:18:28,770
okay this is the thing that's going to

00:18:26,340 --> 00:18:33,570
take a while so trying to try to get you

00:18:28,770 --> 00:18:35,970
warmed up for this one okay so I think

00:18:33,570 --> 00:18:38,820
that one of the most important things

00:18:35,970 --> 00:18:41,190
for you to do when you're writing

00:18:38,820 --> 00:18:43,950
functions is to be defensive when you're

00:18:41,190 --> 00:18:45,650
iterating over arguments and this is a

00:18:43,950 --> 00:18:47,880
subtlety

00:18:45,650 --> 00:18:49,020
I'm curious at the end how many people

00:18:47,880 --> 00:18:52,860
have been burned by this I've been

00:18:49,020 --> 00:18:54,090
burned by this so many times and I feel

00:18:52,860 --> 00:18:55,530
like it's like a badge of honor that

00:18:54,090 --> 00:18:57,810
once you've crossed the threshold of

00:18:55,530 --> 00:18:59,940
being burned by this you realize this

00:18:57,810 --> 00:19:00,960
and it er foo it or foo is the actual

00:18:59,940 --> 00:19:05,820
way out of this problem

00:19:00,960 --> 00:19:08,900
and I'm explained why so let's take that

00:19:05,820 --> 00:19:11,490
population data that we had before so

00:19:08,900 --> 00:19:12,870
we've got the population breakdown by

00:19:11,490 --> 00:19:15,420
percentage that I'm trying to calculate

00:19:12,870 --> 00:19:17,010
here so it's great to know that 1.6

00:19:15,420 --> 00:19:18,210
million people live in Montreal and some

00:19:17,010 --> 00:19:19,920
number live in Quebec City but I'd

00:19:18,210 --> 00:19:21,690
really like to know like what percentage

00:19:19,920 --> 00:19:24,420
that is of the total number of people

00:19:21,690 --> 00:19:26,160
who live in all of Quebec so here's a

00:19:24,420 --> 00:19:28,530
function to calculate that you pass in

00:19:26,160 --> 00:19:31,800
the list from before or the generator

00:19:28,530 --> 00:19:34,560
from before first I calculate the total

00:19:31,800 --> 00:19:36,870
number of people who live in Quebec so I

00:19:34,560 --> 00:19:39,510
take the whole file I go over all the

00:19:36,870 --> 00:19:42,030
lines I take the count from each line

00:19:39,510 --> 00:19:44,130
and I sum it up so that total equals sum

00:19:42,030 --> 00:19:45,720
that's what that line does ok so that

00:19:44,130 --> 00:19:48,510
gets me 6.5 million people or whatever

00:19:45,720 --> 00:19:50,850
the total population is then the for

00:19:48,510 --> 00:19:52,230
loop does this a second time it goes

00:19:50,850 --> 00:19:57,600
through the whole population a second

00:19:52,230 --> 00:19:59,900
time it it takes each population for

00:19:57,600 --> 00:20:02,850
each city it divides it by the total

00:19:59,900 --> 00:20:04,680
that's R that's the percentage that that

00:20:02,850 --> 00:20:07,350
city has of the total population and

00:20:04,680 --> 00:20:07,680
then it yields that city name and then

00:20:07,350 --> 00:20:11,160
the

00:20:07,680 --> 00:20:15,450
inch of that city is of the total

00:20:11,160 --> 00:20:19,890
population so now I can run this here it

00:20:15,450 --> 00:20:22,820
is you can see that Montreal is 25% of

00:20:19,890 --> 00:20:25,860
the population Quebec City is about 8%

00:20:22,820 --> 00:20:27,030
and I have to run next on the return

00:20:25,860 --> 00:20:29,280
value of normalized because it's a

00:20:27,030 --> 00:20:30,960
generator so it's returning an iterator

00:20:29,280 --> 00:20:33,290
so instead of getting a big list out I

00:20:30,960 --> 00:20:37,760
have to go through them one at a time

00:20:33,290 --> 00:20:37,760
and so this works properly that's great

00:20:38,300 --> 00:20:41,850
now you'd say well hey you shouldn't be

00:20:40,680 --> 00:20:44,040
using this list function I thought we

00:20:41,850 --> 00:20:46,260
just talked about that you know

00:20:44,040 --> 00:20:47,790
shouldn't you be using generator instead

00:20:46,260 --> 00:20:50,040
Paul on your own advice surely I should

00:20:47,790 --> 00:20:51,300
be that's right so let me do that and

00:20:50,040 --> 00:20:53,400
then and then what happens is the

00:20:51,300 --> 00:20:54,420
function doesn't work so I was sitting

00:20:53,400 --> 00:20:56,670
here telling you that you should do this

00:20:54,420 --> 00:21:00,270
and clearly you should not do this

00:20:56,670 --> 00:21:02,130
because it broke and what happened was

00:21:00,270 --> 00:21:04,350
we passed in the generator and we got

00:21:02,130 --> 00:21:06,260
out a stop Federation exception which is

00:21:04,350 --> 00:21:08,490
just nonsensical doesn't make any sense

00:21:06,260 --> 00:21:10,980
what's actually happening is we're

00:21:08,490 --> 00:21:12,150
getting out an empty list basically the

00:21:10,980 --> 00:21:14,310
there's nothing yielded from the

00:21:12,150 --> 00:21:16,740
generator and the question is how can

00:21:14,310 --> 00:21:18,450
this happen how is it possible because

00:21:16,740 --> 00:21:20,580
we know load city's generator works and

00:21:18,450 --> 00:21:22,110
we know normalized works so there's some

00:21:20,580 --> 00:21:26,220
combination of normalize and the

00:21:22,110 --> 00:21:27,840
generator that's not working and here's

00:21:26,220 --> 00:21:31,890
the reason and this is the gotcha that

00:21:27,840 --> 00:21:34,140
you'll get bitten by at some point we

00:21:31,890 --> 00:21:35,850
iterate over the population argument two

00:21:34,140 --> 00:21:36,960
times and when you first read this

00:21:35,850 --> 00:21:38,670
function you don't actually realize that

00:21:36,960 --> 00:21:40,530
that's what's happening but it's a big

00:21:38,670 --> 00:21:43,530
problem so the first time we iterate

00:21:40,530 --> 00:21:45,330
over it is for the sum so we go through

00:21:43,530 --> 00:21:46,650
the whole file calculate a you know

00:21:45,330 --> 00:21:49,710
figure out the total population of the

00:21:46,650 --> 00:21:52,680
entire province and then sum it up into

00:21:49,710 --> 00:21:55,020
the total then we iterate over this file

00:21:52,680 --> 00:21:56,280
again and we go through each city and

00:21:55,020 --> 00:21:58,470
figure out its contribution to the total

00:21:56,280 --> 00:21:59,850
so you have to do this it's just the

00:21:58,470 --> 00:22:00,930
nature of the problem you have to sum

00:21:59,850 --> 00:22:03,900
everything up and then you have to

00:22:00,930 --> 00:22:06,120
divide if there's a whole set of

00:22:03,900 --> 00:22:08,400
problems that are of this kind and they

00:22:06,120 --> 00:22:10,800
all suffer from this and the reason this

00:22:08,400 --> 00:22:14,580
doesn't work is because if popul if the

00:22:10,800 --> 00:22:16,410
pop argument is an iterator then sum is

00:22:14,580 --> 00:22:19,710
going to just iterate all the way

00:22:16,410 --> 00:22:21,420
through it until it's exhausted so some

00:22:19,710 --> 00:22:22,890
will just keep going next next next

00:22:21,420 --> 00:22:24,840
next until there's nothing left and it's

00:22:22,890 --> 00:22:27,270
like cool I'm done here's your total and

00:22:24,840 --> 00:22:28,440
then the for-loop says okay now I'm

00:22:27,270 --> 00:22:31,050
going to go through the same iterator

00:22:28,440 --> 00:22:32,700
and the iterator says I have nothing I

00:22:31,050 --> 00:22:36,240
have nothing left stop iteration I'm

00:22:32,700 --> 00:22:37,380
done the problem is that Python doesn't

00:22:36,240 --> 00:22:39,420
know the difference between those two

00:22:37,380 --> 00:22:41,040
circumstances I don't know if it's a

00:22:39,420 --> 00:22:43,260
design flaw in Python you could argue

00:22:41,040 --> 00:22:44,220
either way but the point is that Python

00:22:43,260 --> 00:22:46,170
doesn't know the difference between an

00:22:44,220 --> 00:22:48,180
iterator that's been exhausted been

00:22:46,170 --> 00:22:50,910
fully run and an iterator that had

00:22:48,180 --> 00:22:52,380
nothing in it in the first place that's

00:22:50,910 --> 00:22:56,640
the fundamental problem here Python

00:22:52,380 --> 00:22:57,780
can't tell the difference so let's talk

00:22:56,640 --> 00:23:00,630
about the iterator protocol really

00:22:57,780 --> 00:23:02,720
quickly how do you detect an iterator

00:23:00,630 --> 00:23:09,120
what is it what is integrator really do

00:23:02,720 --> 00:23:13,500
so iterators let you go through a

00:23:09,120 --> 00:23:14,910
sequence one step at a time and what's

00:23:13,500 --> 00:23:16,080
interesting about them is there's this

00:23:14,910 --> 00:23:18,890
thing called the iterator protocol that

00:23:16,080 --> 00:23:20,850
Python has it has that lets you inspect

00:23:18,890 --> 00:23:23,310
something and determine whether or not

00:23:20,850 --> 00:23:26,100
it's an iterator and what the protocol

00:23:23,310 --> 00:23:27,900
says is when you get irate over a list

00:23:26,100 --> 00:23:30,120
you get an object so when you call the

00:23:27,900 --> 00:23:32,070
it our built-in function on a list you

00:23:30,120 --> 00:23:33,810
get an iterator when you call the it our

00:23:32,070 --> 00:23:36,270
built-in function on an iterator it

00:23:33,810 --> 00:23:40,950
returns itself and so what you see here

00:23:36,270 --> 00:23:44,610
is that it ER of so C and B are the same

00:23:40,950 --> 00:23:47,640
thing so B is iterating over the list C

00:23:44,610 --> 00:23:49,950
is iterating over the iterator and CB is

00:23:47,640 --> 00:23:51,270
C they're the same objects you have the

00:23:49,950 --> 00:23:53,160
same address in memory I print them out

00:23:51,270 --> 00:23:56,460
down here and then the actual return

00:23:53,160 --> 00:23:58,680
value is true and so that's just the

00:23:56,460 --> 00:24:01,290
definition of iterators in Python but

00:23:58,680 --> 00:24:02,970
that's what's so that's that's a way to

00:24:01,290 --> 00:24:05,810
detect what's going on and that kind of

00:24:02,970 --> 00:24:08,280
hints solution to this problem also

00:24:05,810 --> 00:24:11,790
similarly how do you detect if an

00:24:08,280 --> 00:24:14,400
iterator is not the same or it's a

00:24:11,790 --> 00:24:15,720
container and so you'll notice here B

00:24:14,400 --> 00:24:19,530
and C the only difference between these

00:24:15,720 --> 00:24:21,780
is on line B I'm iterating over a on

00:24:19,530 --> 00:24:24,720
line see now I'm iterating over both a a

00:24:21,780 --> 00:24:27,030
second time right and so when I ate over

00:24:24,720 --> 00:24:28,920
the sequence twice I get two different

00:24:27,030 --> 00:24:30,660
objects at the bottom I get false and

00:24:28,920 --> 00:24:32,730
the memory addresses are different so

00:24:30,660 --> 00:24:35,070
the big difference here is if you get

00:24:32,730 --> 00:24:36,690
right over a sequence twice you get

00:24:35,070 --> 00:24:38,070
different iterators if you iterate over

00:24:36,690 --> 00:24:40,230
that's this one

00:24:38,070 --> 00:24:42,600
if you iterate over an iterator you get

00:24:40,230 --> 00:24:46,230
the same iterator again and that's the

00:24:42,600 --> 00:24:51,330
problem so that's what's causing this

00:24:46,230 --> 00:24:53,549
behavior where we get nothing back so to

00:24:51,330 --> 00:24:55,500
wrap it up the the simplest thing you

00:24:53,549 --> 00:24:57,090
can do to solve this is to just use a

00:24:55,500 --> 00:25:00,110
list that's what everyone's been doing

00:24:57,090 --> 00:25:04,500
if you want to do this the right way my

00:25:00,110 --> 00:25:05,730
suggestion for you is to take this

00:25:04,500 --> 00:25:08,610
generator function and go a little bit

00:25:05,730 --> 00:25:10,830
further so here's the generator function

00:25:08,610 --> 00:25:12,149
from before this is I just expanded it

00:25:10,830 --> 00:25:15,629
out so you can see everything that's in

00:25:12,149 --> 00:25:17,490
it and all you have to do is turn this

00:25:15,629 --> 00:25:19,889
into what what's called an iterable

00:25:17,490 --> 00:25:22,649
container and it's a really small class

00:25:19,889 --> 00:25:24,210
and this is all it is is the actual

00:25:22,649 --> 00:25:25,950
difference the meat of the program is

00:25:24,210 --> 00:25:27,570
the same it's just a little bit of

00:25:25,950 --> 00:25:28,950
boilerplate around it that tells python

00:25:27,570 --> 00:25:31,889
what you meant what you're actually

00:25:28,950 --> 00:25:33,629
trying to do so this is an object you

00:25:31,889 --> 00:25:35,879
handed the path of the file that you

00:25:33,629 --> 00:25:37,340
want to iterate over and you find this

00:25:35,879 --> 00:25:41,669
special method called itter

00:25:37,340 --> 00:25:43,740
so double under it ER and now python

00:25:41,669 --> 00:25:45,360
will understand how to treat this like a

00:25:43,740 --> 00:25:47,370
container like a list or a dictionary or

00:25:45,360 --> 00:25:49,590
set like the standard other containers

00:25:47,370 --> 00:25:51,509
that are in Python so again none of the

00:25:49,590 --> 00:25:55,049
functionality is different it's just the

00:25:51,509 --> 00:25:56,519
packaging of it and if you use that

00:25:55,049 --> 00:25:59,429
construction of an iterable container

00:25:56,519 --> 00:26:00,210
instead of a generator suddenly

00:25:59,429 --> 00:26:03,000
everything works

00:26:00,210 --> 00:26:05,340
so the code hasn't even changed like the

00:26:03,000 --> 00:26:07,470
meat of the function is the same but now

00:26:05,340 --> 00:26:09,809
suddenly it works correctly if I create

00:26:07,470 --> 00:26:11,159
the load cities object at the top and I

00:26:09,809 --> 00:26:14,100
pass it into the normalized function

00:26:11,159 --> 00:26:16,769
then I get Montreal 25% Quebec's 8% and

00:26:14,100 --> 00:26:21,679
so on so why does this work where the

00:26:16,769 --> 00:26:24,659
other one didn't work and the answer is

00:26:21,679 --> 00:26:25,919
when you when you call pop here with

00:26:24,659 --> 00:26:29,549
that actually tells Python to do is

00:26:25,919 --> 00:26:34,019
either pop sew it or pop then in turn

00:26:29,549 --> 00:26:35,940
calls pop itter and that's the solution

00:26:34,019 --> 00:26:40,139
because when you call pop it err

00:26:35,940 --> 00:26:41,940
you get a new iterator for each call the

00:26:40,139 --> 00:26:43,409
old way you're just you're just using

00:26:41,940 --> 00:26:45,059
the same iterators pythons just going to

00:26:43,409 --> 00:26:47,370
go through it but when you define a

00:26:45,059 --> 00:26:48,210
reason Taner an interval container

00:26:47,370 --> 00:26:49,830
python

00:26:48,210 --> 00:26:51,600
knows to do this magic where it's like

00:26:49,830 --> 00:26:53,790
Oh pop I know I'm an iterate over pop

00:26:51,600 --> 00:26:55,110
cool I'm going to get er over pop okay

00:26:53,790 --> 00:26:57,210
that actually means I'm going to call

00:26:55,110 --> 00:26:59,300
this function instead and that solves

00:26:57,210 --> 00:26:59,300
the problem

00:26:59,610 --> 00:27:06,780
yeah so that's that's the real solution

00:27:02,990 --> 00:27:10,710
the last thing I'll say on this is the

00:27:06,780 --> 00:27:12,420
final end of the of the riddle so you

00:27:10,710 --> 00:27:16,110
can determine whether or not you're

00:27:12,420 --> 00:27:18,090
going to get bit by this if you run this

00:27:16,110 --> 00:27:21,420
code so here's a not defensive one and

00:27:18,090 --> 00:27:24,450
here's the defensive one so when you get

00:27:21,420 --> 00:27:27,840
it an argument into your function you

00:27:24,450 --> 00:27:30,720
can test that argument and say is it or

00:27:27,840 --> 00:27:34,350
pop the same as it or pop this is that

00:27:30,720 --> 00:27:36,930
silly expression from before if pop is

00:27:34,350 --> 00:27:40,080
an iterator it returns the same thing to

00:27:36,930 --> 00:27:42,210
both of these calls so it or pop is that

00:27:40,080 --> 00:27:43,800
or pop will return the same exact object

00:27:42,210 --> 00:27:45,210
this will be true and you know this is a

00:27:43,800 --> 00:27:46,650
big problem and so you can just bail out

00:27:45,210 --> 00:27:49,500
and say type error like you cannot call

00:27:46,650 --> 00:27:51,900
this function with with such an iterator

00:27:49,500 --> 00:27:54,600
if it's container like a list a set or

00:27:51,900 --> 00:27:56,190
that nice load cities it err method that

00:27:54,600 --> 00:27:58,320
we under under hitter that we defined

00:27:56,190 --> 00:27:58,830
this will work properly and everything

00:27:58,320 --> 00:28:02,190
will be great

00:27:58,830 --> 00:28:03,840
and so you can see here if I call

00:28:02,190 --> 00:28:05,250
normalized offensive with that generator

00:28:03,840 --> 00:28:06,840
from before instead of getting an empty

00:28:05,250 --> 00:28:08,790
list I actually detect the situation I

00:28:06,840 --> 00:28:10,290
raise a type error and so I've now

00:28:08,790 --> 00:28:15,270
protected myself so I've made a

00:28:10,290 --> 00:28:16,800
defensive function and if I and then if

00:28:15,270 --> 00:28:18,830
I pass in load city's everything works

00:28:16,800 --> 00:28:22,380
as expected

00:28:18,830 --> 00:28:23,970
so beware of multiple iterations over

00:28:22,380 --> 00:28:25,320
the same argument that's just when

00:28:23,970 --> 00:28:26,820
you're defining a function and using

00:28:25,320 --> 00:28:29,190
generators this is a huge gotcha it's

00:28:26,820 --> 00:28:31,290
going to hurt you should define and use

00:28:29,190 --> 00:28:33,810
containers to avoid the problem you can

00:28:31,290 --> 00:28:35,310
use it or is it err to make sure that

00:28:33,810 --> 00:28:37,140
you're doing the right thing in a duct

00:28:35,310 --> 00:28:38,310
type kind of way and just in general you

00:28:37,140 --> 00:28:41,030
should know the iterator protocol and

00:28:38,310 --> 00:28:44,280
look it up make sure you have it all set

00:28:41,030 --> 00:28:45,240
cool I'm almost at a time and I wanted

00:28:44,280 --> 00:28:46,710
to have time for questions but nothing

00:28:45,240 --> 00:28:49,800
is going to happen the last thing I'm

00:28:46,710 --> 00:28:51,630
going to say is this all of this stuff

00:28:49,800 --> 00:28:53,310
and much more is in the book if you're

00:28:51,630 --> 00:28:54,930
interested I convinced them to give us

00:28:53,310 --> 00:28:57,990
50% off for the e-book today so it's

00:28:54,930 --> 00:29:01,530
like 16 bucks if you go to informit comm

00:28:57,990 --> 00:29:04,680
slash deals the slides encoded there and

00:29:01,530 --> 00:29:05,280
at hacks or one big fluke calm so if you

00:29:04,680 --> 00:29:06,780
like that

00:29:05,280 --> 00:29:09,150
and you want even more that's just the

00:29:06,780 --> 00:29:12,600
beginning part of the kind of things I

00:29:09,150 --> 00:29:14,900
talked about and that's all so thanks

00:29:12,600 --> 00:29:14,900
for coming

00:29:21,040 --> 00:29:24,980
so yeah well thank you very much Brad

00:29:23,900 --> 00:29:26,990
you're unfortunately you're right

00:29:24,980 --> 00:29:28,010
there's no time for questions but I'll

00:29:26,990 --> 00:29:31,540
be down here if you need to ask a

00:29:28,010 --> 00:29:31,540

YouTube URL: https://www.youtube.com/watch?v=WjJUPxKB164


