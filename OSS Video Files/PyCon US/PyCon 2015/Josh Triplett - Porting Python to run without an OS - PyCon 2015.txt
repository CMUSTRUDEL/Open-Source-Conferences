Title: Josh Triplett - Porting Python to run without an OS - PyCon 2015
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	"Speaker: Josh Triplett

We've ported Python to run directly on hardware, without an OS, as a testing and exploration environment for firmware, ACPI, and UEFI. This talk will explore porting Python to a new platform, embedding Python, recreating enough of libc and POSIX to run Python without an OS, and binding to platform-specific services. Includes live demo of bare-metal Python, directly driving hardware.

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:36,020 --> 00:00:39,770
ALL RIGHT. OUR LAST SPEAKER FOR THE DAY IS JOSH TRIPLETT,

00:00:39,770 --> 00:00:42,130
HE'LL BE TELLING US HOW HE PORTED PYTHON TO RUN

00:00:42,130 --> 00:00:56,200
WITHOUT AN OPERATING SYSTEM. >> YES, THE WHOLE POINT OF THIS TALK IS WE

00:00:56,200 --> 00:00:59,250
PORTED PYTHON TO WORK WITHOUT AN OS, AND I'LL GO

00:00:59,250 --> 00:01:00,309
INTO THAT.

00:01:00,309 --> 00:01:04,050
I'LL ALSO TALK ABOUT SOME OF THE OTHER THINGS WE

00:01:04,050 --> 00:01:09,930
ADDED TO PYTHON IN ORDER TO BUILD UP A NICE ENVIRONMENT TO WORK WITH AND WE MADE IT A

00:01:09,930 --> 00:01:11,800
SUFFICIENTLY COMFORTABLE ENVIRONMENT THAT THE

00:01:11,800 --> 00:01:16,620
ALTERNATE TITLE FOR THIS TALK WAS "WE ACCIDENTALLY HAD AN OPERATING SYSTEM."

00:01:16,620 --> 00:01:20,110
SO WITH THAT, YOU KNOW, THE BIG -- LET ME START

00:01:20,110 --> 00:01:23,720
WITH THE PUNCH LINE. WE PORTED PYTHON TO RUN IN THE GRUBE BOOT

00:01:23,720 --> 00:01:28,550
LOADER, TO RUN ON BIOS AND EFI FIRMWARE.

00:01:28,550 --> 00:01:30,800
SO THAT THEN RAISES A NUMBER OF QUESTIONS, THE

00:01:30,800 --> 00:01:34,650
MOST POPULAR OF WHICH TENDS TO BE WHY -- USUALLY IS YOU HAVE FIXED WITH SOMETHING LIKE WHY

00:01:34,650 --> 00:01:37,600
WOULD YOU DO SUCH A THING!!

00:01:37,600 --> 00:01:43,070
SO I WANT TO GO INTO THAT, WHAT THE MOTIVATION FOR THIS IS, WHAT WE USE THIS FOR OTHER THAN

00:01:43,070 --> 00:01:44,830
AS A NOVEL PARTY TRICK.

00:01:44,830 --> 00:01:48,940
THEN I'LL GO INTO WHAT WE PROVIDE AS PART OF THIS

00:01:48,940 --> 00:01:50,880
ENVIRONMENT, BOTH PYTHON ITSELF AND ABOVE AND

00:01:50,880 --> 00:01:55,070
BEYOND THAT. HOW IT WORKS, WHICH IS THE MAIN BULK OF THE

00:01:55,070 --> 00:01:58,500
TALK, HOW WE GOT PYTHON RUNNING WITHOUT AN OS.

00:01:58,500 --> 00:02:01,690
THEN, PLATFORM APIs THAT WE'VE ADDED ON TOP OF

00:02:01,690 --> 00:02:06,560
PYTHON JUST AS YOU WANT ACCESS TO WINDOWS SERVICES OR LINUX SERVICES, YOU WANT ACCESS

00:02:06,560 --> 00:02:09,410
TO THE PLATFORM SERVICES FOR THIS NOT AN OPERATING

00:02:09,410 --> 00:02:12,540
SYSTEM. AND I'M GOING TO BE INCLUDING QUITE A NUMBER

00:02:12,540 --> 00:02:14,830
OF DEMOS ALONG THE WAY, JUST SWITCHING OVER AND

00:02:14,830 --> 00:02:17,050
RUNNING THINGS WITHIN A VIRTUAL MACHINE TO SHOW

00:02:17,050 --> 00:02:22,010
OFF HOW THIS WORKS, THE WHOLE WAY THROUGH. FIRST OF ALL, WHY WOULD WE DO SUCH A THING

00:02:22,010 --> 00:02:25,500
IS IN THE ORIGINAL REASON IS THAT WE WANTED TO TEST

00:02:25,500 --> 00:02:30,780
HARDWARE BIOS, ACPI AND EFI. WE WANTED TO HAVE A NICE, CONVENIENT TEST

00:02:30,780 --> 00:02:35,760
ENVIRONMENT FOR POKING AT ALL OF THESE THINGS WITHOUT HAVING TO WRITE A WHOLE BUNCH OF ONE-OFF

00:02:35,760 --> 00:02:40,080
PROGRAMS TO DO TESTS. THAT WAS THE SECOND REASON, THE TRADITIONAL

00:02:40,080 --> 00:02:44,770
APPROACH TO TESTING BIOS OR EFI -- TESTING BYE,

00:02:44,770 --> 00:02:49,770
TESTING ACPI, WAS TO WRITE A WOULD YOU KNOW-OFF TEST PROGRAM USUALLY TARGETING DOS.

00:02:49,770 --> 00:02:54,240
THAT ISN'T REALLY A FULL OPERATING SYSTEM, DOESN'T HAVE ANY PROTECTIONS, YOU CAN POKE

00:02:54,240 --> 00:02:57,910
HARDWARE. WITH CURRENT EFI, THE SAME TENDED TO BE TRUE,

00:02:57,910 --> 00:03:01,190
YOU WOULD RUN AN EFI ENVIRONMENT AND RUN A ONE-OFF

00:03:01,190 --> 00:03:07,290
TEST PROGRAM. WE WANTED TO WRITE A SCRIPT WHICH IS MORE

00:03:07,290 --> 00:03:10,950
FUN. WE ALSO WANTED TO AVOID WRITING ANY MORE C-CODE

00:03:10,950 --> 00:03:14,880
OR FOR THAT MAT THE PREVIOUS INCARNATION OF THIS

00:03:14,880 --> 00:03:20,610
ACTUALLY USED GRUB SHELL-LIKE HANK LANGUAGE TOGETHER WITH A SHELL FUNCTION THAT EVALUATED

00:03:20,610 --> 00:03:26,470
C-LIKE EXPRESSIONS WITHIN GRUB SHELL. WE WANTED TO DO LESS OF THAT, AS WELL.

00:03:26,470 --> 00:03:31,000
IN GENERAL, THE MORE SENTENCES I CAN END WITH, WITHOUT WRITING ANY C-CODE, THE HAPPIER MY

00:03:31,000 --> 00:03:35,870
LIFE SFINALLY, WE TURNED OVER TIME THIS TURNED

00:03:35,870 --> 00:03:37,980
INTO A NICE EXPLORATORY ENVIRONMENT.

00:03:37,980 --> 00:03:40,230
I HAD SOMEONE COMMENT TO ME THEY WERE LOOKING FOR

00:03:40,230 --> 00:03:42,730
TO THIS ONE BECAUSE IT BROUGHT BACK SOME OF THE

00:03:42,730 --> 00:03:49,360
FUN OF HACKING ON A COMMODORE 64 OR A DOS ENVIRONMENT WHERE YOU CAN PEEK AND POKE THINGS.

00:03:49,360 --> 00:03:51,720
AND YOU CAN'T REALLY DO THAT ON MODERN HARDWARE ANYMORE.

00:03:51,720 --> 00:03:58,350
SO WE'VE SAID WHY. BUT WHAT AGENCY ARE WE PROVIDING HERE?

00:03:58,350 --> 00:04:05,361
THIS RUNS ON A FEW DIFFERENT TARGET PLATFORMS, RUNS ON BIOS IN 32 BIT, IFI IN EITHER 32 BIT

00:04:05,361 --> 00:04:06,540
OR 64 BIT.

00:04:06,540 --> 00:04:10,020
SO EFFECTIVELY PC HARDWARE WITH WHATEVER KIND OF

00:04:10,020 --> 00:04:16,989
FIRMWEAR YOU MIGHT BE RUNNING, THIS WILL RUN. IT'S CPYTHON, I APOLOGIZE IT IS PYTHON 2.7.

00:04:16,989 --> 00:04:19,440
THE REASON FOR THAT IS THE TARGET AUDIENCE FOR

00:04:19,440 --> 00:04:23,990
THIS TEST SUITE IS VERY FAMILIAR WITH PYTHON 2.7,

00:04:23,990 --> 00:04:29,160
USED IN A VARIETY OF OTHER TOOLS LIKE OPERATING -- HARDWARE SIMULATING ENVIRONMENTS

00:04:29,160 --> 00:04:33,240
OR TESTS FRAMEWORKS AND JTAGS AND VARIOUS SIMILAR

00:04:33,240 --> 00:04:37,070
TYPES, SO IF THE TARGET AUDIENCE MOVES TO 2.7, WE

00:04:37,070 --> 00:04:44,210
WOULD LOVE TO MOVE TO 3 IF WE CAN DO SO. WE HAVE A FULL INTERACTIVE PREDEVELOPMENT

00:04:44,210 --> 00:04:50,120
PRINT LOOP, SO TYPE AN ARBITRARY COMMAND, TAB-COMPLETE

00:04:50,120 --> 00:04:53,180
ALL THE INTERESTING FUNCTIONS, FILLING HISTORY AN

00:04:53,180 --> 00:04:58,009
LINE EDITING AVAILABLE AND WE HAVE A PRETTY SUBSTANTIAL FRACTION OF THE STANDARD PYTHON

00:04:58,009 --> 00:05:03,270
LIBRARY, AS WELL. SO ON TOP OF THAT, WE HAVE SOME ADDITIONAL

00:05:03,270 --> 00:05:07,460
MODULES FOR THINGS LIKE PLATFORM SUPPORT. WE HAVE WAYS TO ACCESS THE FUNCTIONS OF YOUR

00:05:07,460 --> 00:05:10,419
CPU, REGISTER CPUI. D.THAT KIND OF THING.

00:05:10,419 --> 00:05:13,229
WE HAVE SMP SUPPORT SO YOU CAN RUN THINGS ON

00:05:13,229 --> 00:05:17,790
CPUs THAT YOU DIDN'T BOOT ON. WE HAVE ACPI SUPPORT SO YOU CAN EXPLORE THAT

00:05:17,790 --> 00:05:20,150
PART OF YOUR FIRMWARE AND WE HAVE EFI SUPPORT IF

00:05:20,150 --> 00:05:26,220
YOU'RE RUNNING THAT PLATFORM. SO FINALLY, ON TOP OF ALL THAT, WE HAVE A

00:05:26,220 --> 00:05:29,120
TEST SUITE AND A BUNCH OF EXPLORATORY TOOLS ALL

00:05:29,120 --> 00:05:31,680
OF WHICH WE WERE ABLE TO WRITE IN PYTHON, WHICH

00:05:31,680 --> 00:05:33,110
IS GREAT.

00:05:33,110 --> 00:05:38,550
SO LET'S START WITH THE FIRST BUILT OF DEMO. I HAVE A PYTHON PROMPT RUNNING INSIDE A VIRTUAL

00:05:38,550 --> 00:05:42,650
MACHINE. AND I'VE GOT THE FULL POWER OF PYTHON HERE.

00:05:42,650 --> 00:05:53,259
I CAN DO LIST COMPREHENSIONS, FOR EXAMPLE. AND I'VE GOT BIG NUMBS, SO FULL POWER OF PYTHON

00:05:53,259 --> 00:05:58,719
AVAILABLE ON YOUR PROMPT. BUT THAT'S NOT THE ONLY THING WE CAN DO.

00:05:58,719 --> 00:06:01,639
SO LET'S TALK A LITTLE BIT ABOUT HOW WE GOT THAT

00:06:01,639 --> 00:06:09,669
FAR, THOUGH. SO IN OF CPYTHON, THERE'S ONE FUNCTION, SHOW

00:06:09,669 --> 00:06:12,590
THE PROMPT, READS, DO LINE EDITING, HANDLE ALL

00:06:12,590 --> 00:06:15,749
OF WHAT YOU'RE TRYING TO DO, PROCESS, RUN AND

00:06:15,749 --> 00:06:21,490
EVALUATE YOUR OPERATION, KEEP STATE AND THAT'S WHAT YOU DO WITH PI RUN INTERACTIVE LOOP.

00:06:21,490 --> 00:06:23,410
THE FIRST STANDARD IN HERE IS JUST WHERE DO I GET

00:06:23,410 --> 00:06:27,300
MY INPUT FROM. AND THE QUOTED STANDARD IN IS WHAT YOU SEE

00:06:27,300 --> 00:06:29,940
IF YOU GET AN EXCEPTION THROWN, YOU'LL SEE IN THE

00:06:29,940 --> 00:06:34,189
TRACE BACK, LINE X OF STANDARD IN, AND THAT WILL

00:06:34,189 --> 00:06:36,449
BE THE LAST ITEM IN YOUR TRACE BACK AND YOU MIGHT

00:06:36,449 --> 00:06:38,389
HAVE A FUNCTION THAT YOU CALLED FROM SOME OTHER MODULE

00:06:38,389 --> 00:06:40,849
BUT AT THE TOP LEVEL, YOU'RE TYPING AT THIS FILE

00:06:40,849 --> 00:06:45,340
NAME STANDARD IN. BUT THAT'S THE FUNCTION THAT WE CALL, THAT'S

00:06:45,340 --> 00:06:47,629
THE ONE FUNCTION THAT WE WANTED TO RUN AT THE

00:06:47,629 --> 00:06:48,660
TOP LEVEL.

00:06:48,660 --> 00:06:51,629
WHAT DID WE DO TO GET THERE? WELL, FIRST OF ALL, WE COULDN'T ACTUALLY USE

00:06:51,629 --> 00:06:57,020
PYTHON'S CONFIGURE AND MAKE. AUTOCOMP IS PORTABLE, RUNS ON A LOT OF PLATFORMS

00:06:57,020 --> 00:06:59,919
BUT THE REASON WE COULDN'T GO THAT ROUTE IS WE'RE

00:06:59,919 --> 00:07:05,409
BUILDING USING A HOST LINUX TOOL CHAIN, USING JCC, BUILDING AND TARGETING THE SAME THING

00:07:05,409 --> 00:07:06,710
THAT GRUB DOES.

00:07:06,710 --> 00:07:12,409
SO IN PARTICULAR WHAT WE DON'T HAVE IS THE CLASSIC CPU TRIPLE VENDOR YOU WOULD SEE FOR

00:07:12,409 --> 00:07:16,430
WHAT IS MY TARGETS OPERATING SYSTEM, LIKE I-386

00:07:16,430 --> 00:07:18,719
PC LINUX GENU.

00:07:18,719 --> 00:07:23,650
WE DON'T HAVE THAT SO WE CAN'T TARGET GRUB AND

00:07:23,650 --> 00:07:26,830
BUILD PYTHON WITH CONFIGURE AND MAKE, AND WE

00:07:26,830 --> 00:07:32,339
DON'T THAT HAVE TOOL CHAIN POINTING AT TARGET HEADERS FOR GRUB IN ORDER TO RUN IN OUR

00:07:32,339 --> 00:07:35,889
ENVIRONMENT. SO INSTEAD, WHAT WE DID WAS ADDED ALL OF THE

00:07:35,889 --> 00:07:40,379
PYTHON SOURCE FILES THAT MAKE UP THE PYTHON DISTRIBUTION, WHAT YOU WOULD NORMALLY HAVE

00:07:40,379 --> 00:07:41,800
IN THE MAKE FILE.

00:07:41,800 --> 00:07:46,561
WE PUT A LIST OF THOSE INTO THE GRUB BUILD SYSTEM, SAYING HERE'S ALL THE THINGS YOU NEED

00:07:46,561 --> 00:07:48,580
TO MAKE UP PYTHON AND ALL THE EXTEND END SEES

00:07:48,580 --> 00:07:50,599
OF PYTHON, A LIST OF C FILES.

00:07:50,599 --> 00:07:54,479
OKAY. AND THEN WE MANUALLY WROTE OUT THE CONFIGURATION

00:07:54,479 --> 00:07:58,390
FILE, FILE CONFIG.8. THIS IS THE FILE THAT AUTO O.COMP AND HEADER

00:07:58,390 --> 00:08:03,710
WOULD WRITE OUT THAT TELLS YOU I HAVE THIS FEATURE OR I DON'T EVER THIS FEATURE.

00:08:03,710 --> 00:08:06,330
SO WE HAVE A LONG LIST OF NO, I DON'T HAVES, AND

00:08:06,330 --> 00:08:10,490
A HANDFUL OF YES, WE DO HAVE THIS, FOR WAYS THAT

00:08:10,490 --> 00:08:12,830
PYTHON NEEDS TO WORK AROUND SHORTCOMINGS OF THE

00:08:12,830 --> 00:08:15,569
OPERATING SYSTEM. WE DON'T HAVE AN OPERATING SYSTEM SO WE DON'T

00:08:15,569 --> 00:08:18,249
HAVE A LOT OF THOSE FUNCTIONS, BUT ANYTHING THAT

00:08:18,249 --> 00:08:23,529
PYTHON REQUIRES TO RUN AND A HANDFUL OF THE OPTIONAL ITEMS WE ADDED.

00:08:23,529 --> 00:08:25,439
AND THEN WE HAVE TO PROVIDE THOSE FUNCTIONS THAT

00:08:25,439 --> 00:08:28,159
PYTHON EXPECTS. SO WHAT KIND OF FUNCTIONS ARE THOSE, WHAT

00:08:28,159 --> 00:08:31,160
DO YOU NEED TO REALLY RUN A CPYTHON?

00:08:31,160 --> 00:08:34,630
A COUPLE OF EXAMPLES. TURNS OUTS YOU NEEDS SOME NON-TRIVIAL FILE

00:08:34,630 --> 00:08:39,490
OPERATION HE IS TO RUN PYTHON. YOU NEEDS THINGS LIKE STATS OR -- IN ORDER

00:08:39,490 --> 00:08:41,460
TO FIND OUT, OH, IS THIS A DIRECTORY THAT MIGHT

00:08:41,460 --> 00:08:48,490
CONTAIN AN INCHIN.PI OR FOOD.PI. YOU NEED TO KNOW IF IT IS A TEMP NATURAL,

00:08:48,490 --> 00:08:52,170
A TTY, AND WE HAVE A SIMPLE IMPLEMENTATION OF THIS,

00:08:52,170 --> 00:08:56,970
IF FILE SCRIPTER LIST THAN 3, YES, I'M TTY.

00:08:56,970 --> 00:09:02,600
WE HAVE SEEK, WHICH THE GRUB FILE LAYER DIDN'T HAVE AN L-SEEK FUNCTION SO WE ADDED ONE FOR

00:09:02,600 --> 00:09:05,080
COMPATIBILITY AND IN ORDER TO SUPPORT ALL THESE

00:09:05,080 --> 00:09:07,750
FILE SCRIPTERS, WE NEEDED A FILE DESCRIBER TABLE,

00:09:07,750 --> 00:09:09,950
HERE, HAVE AN INTEGER THAT CORRESPONDENCE TO A

00:09:09,950 --> 00:09:14,000
FILE. GRUB'S LAYERS LIKE LIKE THE C-STANDS AROUND

00:09:14,000 --> 00:09:21,550
I.-- LAYER, AND THAT WAS EASY TO SUPPORT. BUT TO HANDLE SMALL INTEGER FILE DESCRIPTORS,

00:09:21,550 --> 00:09:23,540
WE HAD TO WRITE OUR OWN TABLE.

00:09:23,540 --> 00:09:27,050
THIS WAS ACTUALLY WHY IT TOOK SOME TIME TO IMPORT

00:09:27,050 --> 00:09:30,900
64-BIT BECAUSE WHEN THEY WERE 32 WE POINTED THE

00:09:30,900 --> 00:09:35,200
POINTER TO A BAD IT. BAD US.

00:09:35,200 --> 00:09:40,380
THERE IS A LOT OF OTHER THINGS WE HAD TO ADD. TURNS OUT WE -- PYTHON WANTS UNGITSYNC.

00:09:40,380 --> 00:09:45,990
PLEASE PUT THIS STANDARD CHARACTER BACK. USES THAT AS PART OF THE PARSERS, SO WE WROTE

00:09:45,990 --> 00:09:48,260
-- RATHER THAN ADDING A ONE-CHARACTER BUFFER,

00:09:48,260 --> 00:09:50,890
WE ADDED A QUICK HACK THAT SAYS PYTHON ALWAYS

00:09:50,890 --> 00:09:53,650
UNGETS THE CHARACTER IT JUST GOT SO SEEK BACKWARD

00:09:53,650 --> 00:09:56,080
BY ONE.

00:09:56,080 --> 00:09:59,310
WE NEEDED A QSORT IMPLEMENTATION AND GRUB DIDN'T

00:09:59,310 --> 00:10:01,150
HAVE ANY SORT FUNCTIONS SO WE ENDED UP HAVING TO

00:10:01,150 --> 00:10:04,790
OPEN-CODE THAT. WE NEEDED FLOATING POINT MATH BECAUSE PYTHON

00:10:04,790 --> 00:10:07,310
DOES HAVE FLOAT TYPES AND I CAN DO A QUICK DEMO

00:10:07,310 --> 00:10:11,380
OF THAT, AS WELL, IF I DO 2.5 TIME PLEA, WE HAVE

00:10:11,380 --> 00:10:17,340
FLOATING POINTS. WE NEEDED THAT, GRUB HAD NONE OF THAT, SO

00:10:17,340 --> 00:10:20,550
IT TURNS OUT THERE IS AN OPEN SOURCE PERMISSIVELY

00:10:20,550 --> 00:10:24,040
LICENSED LIB M IMPLEMENTATION FOR ALL THE MAJOR

00:10:24,040 --> 00:10:28,100
MATH FUNCTIONS THAT IS AVAILABLE, IT DOES PURE

00:10:28,100 --> 00:10:31,780
SOFTWARE, CALLED FDLIBIN'. DOESN'T HAVE ANY HARDWARE ACCELERATION.

00:10:31,780 --> 00:10:35,610
WE CONSIDERED THAT TO BE A BIT OF A FEATURE BECAUSE IT DOESN'T REQUIRE THE REST OF THE

00:10:35,610 --> 00:10:38,720
FIRMWARE TO HAVE PROPERLY INITIALIZED FLOATING POINT SUPPORT.

00:10:38,720 --> 00:10:42,130
IF YOU TRY TO USE FLOATING POINTS, IF THE FIRMWARE HASN'T INITIALIZED, YOU WOULD END

00:10:42,130 --> 00:10:44,880
UP BREAKING SO THAT'S GREAT.

00:10:44,880 --> 00:10:47,710
WE ALSO NEEDED PRINTS F, S PRINT OF, PYTHON USES

00:10:47,710 --> 00:10:50,940
THOSE. FOR THE MOST MART, WE COULD USE GRUB'S

00:10:50,940 --> 00:10:55,280
IMPLEMENTATION OF THESE FOR SOME OF THE BASIC FUNCTIONALITIES BUILT WHICH HAD TO EXTENDS

00:10:55,280 --> 00:10:57,790
IT FOR A FEW THINGS THAT GRUB DIDN'T KNOW HOW TO

00:10:57,790 --> 00:11:01,060
HANDLE. SO, FOR EXAMPLE, IT DIDN'T HAVE THE PERCENT

00:11:01,060 --> 00:11:07,680
PERCENT ESCAPE TO PUT A PERCENT IN THE FINAL STRING AND PYTHON USES THIS TO CREATE A FORMAT

00:11:07,680 --> 00:11:09,691
STRING AND THEN RUN THAT BACK THROUGH PRINT F,

00:11:09,691 --> 00:11:13,980
WHEN YOU HAVE * WHENEVER YOU USE THE PERCENT OPERATOR ON THE PYTHON COMMAND LINE SO UNTIL

00:11:13,980 --> 00:11:15,611
WE FIGURED OUT WE DIDN'T HAVE THIS, WE HAD SOME

00:11:15,611 --> 00:11:19,270
VERY INTERESTING BUGS.

00:11:19,270 --> 00:11:22,950
SO APART FROM THAT, WE ALSO WANTED TO WORK THROUGH A HANDFUL OF INTERESTING PERFORMANCE

00:11:22,950 --> 00:11:26,710
ISSUES. SO AT -- WHEN NOT TOO LONG AGO, WE FOUND OUT

00:11:26,710 --> 00:11:29,490
THIS TOOK A SURPRISINGLY LONG TIME TO BOOT AND

00:11:29,490 --> 00:11:32,380
THAT'S PAINFUL ENOUGH ON REAL HARDWARE, IT WAS EXTRA

00:11:32,380 --> 00:11:37,820
PAINFUL IF YOU'RE IN A CPU CIRCUIT SIMULATION ENVIRONMENT THAT RUNS VERY, VERY SLOWLY.

00:11:37,820 --> 00:11:40,420
WE WOULDN'T WANT THIS TO TAKE THREE DAYS TO BOOT.

00:11:40,420 --> 00:11:46,010
SO WHAT WE -- PART OF THIS COMES BECAUSE THE PYTHON PARISSER IS FAIRLY INTRICATE, READS

00:11:46,010 --> 00:11:48,820
READ CHARACTER BY CHARACTER, USES GITSYNC, GRUB

00:11:48,820 --> 00:11:59,230
HAS VERY FULL DISK CACHES, SO WE USED BYTE SUPPORT.

00:11:59,230 --> 00:12:03,980
WE BUILT AN EXTRA COPY OF PYTHON ON OUR HOST SYSTEM AS PART OF THE BUILD SYSTEM, USED TO

00:12:03,980 --> 00:12:08,560
THAT BYTE COMPILE INTO PI C FILES, AND THEN IT

00:12:08,560 --> 00:12:11,750
TURNS OUT GRUB DOESN'T HAVE MODIFICATION TIME SUPPORT

00:12:11,750 --> 00:12:13,871
BUT WE KNOW WE ALWAYS HAVE THE PI C FILES THAT WE

00:12:13,871 --> 00:12:16,930
JUST BUILT SO WE ZERO OUT THE MTIME IN THE FILES

00:12:16,930 --> 00:12:19,880
WHICH MATCHES THE ZERO FEEDBACK FROM OUR IMPLEMENTATION.

00:12:19,880 --> 00:12:24,991
YES, IT'S UP-TO-DATE. SILL A LITTLE SLOW BECAUSE ON A LINUX SYSTEM

00:12:24,991 --> 00:12:27,560
YOU EXPECT STAT TO TAKE MICROSECONDS AND OURS

00:12:27,560 --> 00:12:31,670
TAKES MILLISECONDS BUT IT'S STILL FASTER FORWARD

00:12:31,670 --> 00:12:33,680
ADDING THAT SUPPORTS.

00:12:33,680 --> 00:12:41,270
SPEEDING IT UP FURTHER, WE CAN USE ZIP IMPORT, ZIP UP THE BYTE CODES AND IMPORT IT THAT WAY

00:12:41,270 --> 00:12:44,160
AND WE DO ONE BIG CONSISTENT READS OFF DISK SO

00:12:44,160 --> 00:12:48,630
WE ADD THE Z-LIB SUPPORT NEEDED TO RUN ZIP SUPPORT.

00:12:48,630 --> 00:12:53,860
APART FROM THAT, WE ALSO WANTED HISTORY, WE WANTED COMPLETION, LINE EDITING, AND SO NORMALLY

00:12:53,860 --> 00:12:57,200
YOU DO THIS WITH THE READ LINE LIBRARY, BUT THAT

00:12:57,200 --> 00:13:00,950
DEPENDS ON POSIX AND DETAILS OF HOW TO RUN A

00:13:00,950 --> 00:13:05,540
TERMINAL. WE DON'T HAVE A DEV TTY OR PTC AREA LAYER,

00:13:05,540 --> 00:13:08,670
WE DON'T HAVE THE USUAL HIGH OCTALS TO RUN THAT

00:13:08,670 --> 00:13:12,550
KIND OF THING AND WE DIDN'T WANT TO RUN A PILE

00:13:12,550 --> 00:13:14,820
OF C-CODE THAT WE FRESHLY WROTE TO SOLVE THIS

00:13:14,820 --> 00:13:17,090
PROBLEM BECAUSE THAT'S WHAT WE'RE TRYING TO GET

00:13:17,090 --> 00:13:22,530
AWAY FROM, WE WANT TO WRITE MORE PYTHON. SO INSTEAD WE KIND OF HAD A SNAKE EATING ITS

00:13:22,530 --> 00:13:24,870
OWN TAIL HERE AND WE WROTE PYTHON'S OWN WRITING

00:13:24,870 --> 00:13:26,870
IN PYTHON.

00:13:26,870 --> 00:13:29,850
TO DO THAT, WE IMPLEMENTED THE LINE EDITING, THE

00:13:29,850 --> 00:13:34,250
COMPLETION IN THE PURE PYTHON AND IN C, IN THE

00:13:34,250 --> 00:13:41,000
SMALL C STUBS WE HAVE, WE SET THE PI OS FUNCTION POINTER TO A C FUNCTION THAT USES THE PYTHON

00:13:41,000 --> 00:13:43,980
API TO CALL A CALL BACK THAT WAS PREVIOUSLY SET

00:13:43,980 --> 00:13:48,220
UP. SO WE CALL IN TO PYTHON, GET THE DATA BACK,

00:13:48,220 --> 00:13:50,730
FEED THAT BACK INTO PYTHON, WHICH IS THEN RETURNED

00:13:50,730 --> 00:13:52,810
TO THE ORIGINAL PYTHON PROMPT SAYING HERE'S WHAT

00:13:52,810 --> 00:13:55,360
I LINE EDITED AND READ.

00:13:55,360 --> 00:13:59,290
SO THE MORE BITS THAT WE CAN WRITE IN PURE PYTHON, EVEN IF THEY WERE INTENDED TO BE WRITTEN

00:13:59,290 --> 00:14:04,660
IN C, THE BETTER. APART FROM THAT, WE ALSO WANTED TO HAVE DYNAMIC

00:14:04,660 --> 00:14:09,570
MENUS IN GRUB, SO THAT HAS A LOVELY MENU SYSTEM SO YOU CAN CHOOSE, DO YOU WANT TO BOOT LINUX

00:14:09,570 --> 00:14:12,800
OR WINDOWS OR SOME OTHER VERSION OF LINUX AND

00:14:12,800 --> 00:14:15,970
WE WANTED THAT MENU TO DO TEST SUITES.

00:14:15,970 --> 00:14:18,490
WHAT TESTS DO YOU WANT TO RUN, OR DO ALL OF THEM,

00:14:18,490 --> 00:14:21,130
OR DO THIS EXPLORATORY ACTIVITY OR PULL UP A

00:14:21,130 --> 00:14:25,370
PROMPT. GRUB ALREADY HAS DISK AND FILE SYSTEM PROVIDERS

00:14:25,370 --> 00:14:31,420
FOR THINGS LIKE ZERO HARD DISK, CDROM, FLOPPY DRIVE, SO WE ADDED ONE FOR PYTHON.

00:14:31,420 --> 00:14:34,780
THERE IS A GRUB N PYTHON DEVICE THAT WHEN YOU

00:14:34,780 --> 00:14:40,190
CALL IT, IT WILL GO READS THE FILE YOU SPECIFIED BY HANDING THAT TO PYTHON TO VERIFY IT AND

00:14:40,190 --> 00:14:45,010
FEEDING THE DATA BACK TO GRUB. YOU CAN ADD IN ANY MEMORY FILE YOU WANT, LIKE

00:14:45,010 --> 00:14:49,730
THE FUSE FILE SYSTEM, AND YOU RUN A GRUB COMMAND.

00:14:49,730 --> 00:14:54,200
MY CONFIG FILE IS IN THE PYTHON FILE SYSTEM, MENU.CFG.

00:14:54,200 --> 00:14:59,020
SO EVEN MORE C CODE WE DON'T HAVE TO WRITE. >> SO APART FROM THAT, THAT'S A LOT OF THE

00:14:59,020 --> 00:15:01,200
STUFF THAT WE'VE ADDED TO MAKE THAT INTERFACE WITH

00:15:01,200 --> 00:15:03,600
GRUB TO WORK BETTER ON THE SYSTEM.

00:15:03,600 --> 00:15:09,580
HOW DO WE HANDLE HARDWARE SPECIFIC FUNCTIONALITY. WELL, WE WANT TO HAVE THINGS LIKE CPU I.D.,

00:15:09,580 --> 00:15:16,820
MEMORY MAPPED IO, IO PORT SO WE DID THAT BY ADDING A NEW MODULE CALLED BITS.

00:15:16,820 --> 00:15:21,760
SO I CAN SHOW THAT OFF A LITTLE BIT, AS WELL. LET ME IMPORT BITS AND RUN -- I'M ALSO GOING

00:15:21,760 --> 00:15:23,790
TO NEEDS THE C-TYPES MODULE WHICH I'LL EXPLAIN

00:15:23,790 --> 00:15:27,120
IN A BIT IN ORDER TO GO TALK TO LITTLE PIECES OF

00:15:27,120 --> 00:15:28,120
REAL HARDWARE.

00:15:28,120 --> 00:15:31,570
NOT BECAUSE WE'RE CALLING IF YOU THINKS FROM THERE YET BUT BECAUSE WE NEED TO MANIPULATE

00:15:31,570 --> 00:15:33,670
RAW MEMORY IN WAYS THAT YOU WOULDN'T NORMALLY

00:15:33,670 --> 00:15:36,940
WANT TO DO ON A LIVE HOSTED SYSTEM.

00:15:36,940 --> 00:15:40,480
SO I'M GOING TO CALL CPU I.D. ON CPU ZERO AND GET

00:15:40,480 --> 00:15:46,460
THE NUMBER ZERO AND THAT GIVES YOU A CPU I.D. RESULT WITH THESE PROCESSOR REGISTERS,

00:15:46,460 --> 00:15:48,420
SO, FIRST OF ALL, HOW FUN IS THAT?

00:15:48,420 --> 00:15:52,080
GETTING PROCESSOR REGISTERS FROM PYTHON AND THEN

00:15:52,080 --> 00:15:56,370
I CAN INTERPRET THAT RESULT, THE LAST THREE REGISTERS THERE ARE AN IDENTIFIER OF WHAT

00:15:56,370 --> 00:15:57,690
CPU I RUN ON.

00:15:57,690 --> 00:16:03,951
I CAN SET UP A BUFFER OF THREE 32s AND THAT IS

00:16:03,951 --> 00:16:12,100
C.PDB, .EDX IN THAT ORDER AND THEN PART OF THE

00:16:12,100 --> 00:16:19,260
REASON I NEED C-TYPES IS SO I CAN REINTERPRET THAT IN A DIFFERENT WAY AS A C-CHARACTER ARRAY,

00:16:19,260 --> 00:16:22,920
A 12-CHARACTER STRING FROM THAT SAME BUFFER,

00:16:22,920 --> 00:16:24,480
AND WHAT'S THAT VALUE?

00:16:24,480 --> 00:16:28,460
THAT'S THE PROCESSER I'M RUNNING ON. SO GOING OFF AND DOING A CPU I.D. INSTRUCTION

00:16:28,460 --> 00:16:33,070
FROM PYTHON. A C-FUNCTION UNDERNEATH TO DO CPU I.D. BUT

00:16:33,070 --> 00:16:36,040
I DON'T HAVE TO ASSEMBLE THE RESULT FROM ANYTHING

00:16:36,040 --> 00:16:43,790
BUT PYTHON. SO BACK TO THE PRESENTATION.

00:16:43,790 --> 00:16:49,200
ANOTHER ONE, I MENTIONED ON CPU0. WE WANT TO TEST HIGHLY PARALLEL SYSTEMS WE,

00:16:49,200 --> 00:16:51,391
DON'T CRUST WANTS TO TEST THE CPU BOOTED ON, GRUB

00:16:51,391 --> 00:16:54,401
ONLY KNOWS ABOUT THE CPU YOU BOOTED ON SO WE NEED

00:16:54,401 --> 00:16:57,070
TO GO COLLECT AND MODIFY STATE ON ANY RANDOM

00:16:57,070 --> 00:17:00,040
CPU. SO WE WAKE UP EVERY CPU AT RUN TIME WHICH

00:17:00,040 --> 00:17:03,140
GRUB DOESN'T DO, PUT THEM INTO A SLEEPING LOOP

00:17:03,140 --> 00:17:06,029
USING MWAY AND SAY, OKAY, SIT THERE AND WAIT FOR

00:17:06,029 --> 00:17:08,250
ME TO HAVE WORK FOR YOU.

00:17:08,250 --> 00:17:10,560
AND THEN WE HAVE A FEW C FUNCTIONS THAT JUST SAY,

00:17:10,560 --> 00:17:12,880
GO WAKE UP THAT CPU, RUN THIS INSTRUCTION ON IT

00:17:12,880 --> 00:17:17,870
AND GET BACK TO ME WITH THE RESULT. AND THEN WE BIND ALL THOSE FUNCTIONS TO PYTHON.

00:17:17,870 --> 00:17:22,130
SO THE NICE THING IS THAT THEN WHEN WE COLLECT ALL THOSE RESULTS, PYTHON'S GREAT DATA STRUCTURES

00:17:22,130 --> 00:17:28,260
GIVE US THE ABILITY TO CORRELATES THOSE RESULTS, LIKE IF I RUN CFI I.D.ON EVERY ONE BUT 0,

00:17:28,260 --> 00:17:30,650
IT HAD THIS RESULTS AND 0 HAD THAT RESULT.

00:17:30,650 --> 00:17:35,039
THAT HE THAT'S INTERESTING. SAME THING WITH MSR, SAME THINGS WITH MEMORY

00:17:35,039 --> 00:17:38,179
READ FROM DIFFERENT PROCESSORS, YOU GET CORRELATING

00:17:38,179 --> 00:17:41,030
RESULTS THAT ARE HARD TO PUT TOGETHER AND SEE

00:17:41,030 --> 00:17:46,850
BECAUSE OF LACK OF BASIC DATA STRUCTURES. APART FROM THAT, WE WANTED TO TALK TO YOUR

00:17:46,850 --> 00:17:49,710
ACTUAL FIRMWARE, NOT JUST THE HARDWARE BUT FIRMWARE

00:17:49,710 --> 00:17:52,210
LAYER. IN PARTICULAR, THERE'S ACPI, THE ADVANCED

00:17:52,210 --> 00:17:56,090
CONFIGURATION POWER INTERFACE. THAT IS WHAT YOU USE TO FIND HARDWARE ON MODERN

00:17:56,090 --> 00:17:59,630
SYSTEMS, TO FIND OUT HOW TO PUT YOUR CPU TO SLEEP

00:17:59,630 --> 00:18:03,760
OR YOUR WHOLE SYSTEM TO SLEEP. IT HAS A BUNCH OF STATIC DATA TABLES AS WELL

00:18:03,760 --> 00:18:07,420
AS BYTE METHODS, AND WE WANTED TO DRIVE THIS

00:18:07,420 --> 00:18:11,520
FROM PYTHON, NOT FROM C, SO WE PULLED IN THE REFERENCE

00:18:11,520 --> 00:18:15,570
IMPLEMENTATION OF ACPI C.A., WE PUT THAT IN BITS

00:18:15,570 --> 00:18:21,090
AND HANDLED ITS PORTABILITY ISSUES, AS WELL. THAT IS A C-LIBRARY AND WE ADDED PYTHON BINDINGS

00:18:21,090 --> 00:18:24,320
TO IT. IN PARTICULAR, IT'S POSSIBLE TO EVALUATE AN

00:18:24,320 --> 00:18:31,110
ARBITRARY APCI METHOD, FEED IT ARGUMENTS FROM PYTHON, THEY GET CONVERTED TO ACPI, GO CALL

00:18:31,110 --> 00:18:33,650
AND INTERPRET THE BYTE KIDS METHOD, FEED THE RESULT

00:18:33,650 --> 00:18:37,710
BACK TO PYTHON AND, AGAIN, NO EXTRA C-CODE INVOLVED.

00:18:37,710 --> 00:18:43,630
SO LET'S DO A QUICK DEMO OF THAT. I CAN GO IMPORT ACPI.

00:18:43,630 --> 00:18:49,809
AND I CAN DUMP EVERY METHOD ON MY SYSTEM THAT HAS

00:18:49,809 --> 00:18:52,960
THE HARDWARE IDENTIFIER NAME SO GO FIND ME ALL MY

00:18:52,960 --> 00:18:55,370
HARDWARE AND WHAT MAGIC NUMBER IT HAS FOR WHAT

00:18:55,370 --> 00:18:57,580
THE KIND OF HARDWARE THIS IS AND YOU CAN SEE THAT

00:18:57,580 --> 00:18:59,940
WE'VE GOT THINGS LIKE A COUPLE OF SERIAL PORTS, A

00:18:59,940 --> 00:19:02,770
FLOPPY DISK CONTROLLER, A PS2 KEYBOARD AND MOUSE

00:19:02,770 --> 00:19:08,210
ALL PROVIDED BY THIS VIRTUAL MACHINE AND THEY HAVE DIFFERENT IDENTIFIERS, THIS ONE IS THE

00:19:08,210 --> 00:19:10,750
I.D. OF A SERIAL PORT AND BOTH OF THEM HAVE THE

00:19:10,750 --> 00:19:15,980
SAME I.D., SO THIS IS HOW YOUR MODERN LINUX SYSTEM OR MODERN WINDOWS SYSTEMS FINDS THE

00:19:15,980 --> 00:19:21,380
HARDWARE ON YOUR SYSTEM. HERE'S HARDWARE, HERE'S ITS I.D.

00:19:21,380 --> 00:19:25,230
SO I'M NOT GOING TO GO INTO GREAT DETAIL ABOUT HOW TO EXPLORE HARDWARE, I'VE GIVEN TALKS

00:19:25,230 --> 00:19:26,940
ABOUT THAT ELSEWHERE.

00:19:26,940 --> 00:19:30,250
THE FOCUS OF THIS IS HOW WE MADE THIS WORK AND

00:19:30,250 --> 00:19:36,140
HOW WE GOT THIS WORKING WITH FIRMWARE. SO THE NEXT ITEM I WANT TO GO INTO IS EFI.

00:19:36,140 --> 00:19:38,690
SO ON SYSTEMS THAT AREN'T JUST RUNNING BASIC BIOS

00:19:38,690 --> 00:19:42,920
BUT RUNNING THE EXTENSIVE FIRMWARE INTERFACE, YOU

00:19:42,920 --> 00:19:47,900
WANT SOME ABILITY TO CALL THE FUNCTIONS THAT PROVIDES AND EXTENSIBLE HERE IN EFA MEANS

00:19:47,900 --> 00:19:50,480
THAT EVERYTHING IS A PROTOCOL, IF YOU'RE FAMILIAR

00:19:50,480 --> 00:19:53,460
WITH COM ON WINDOWS, THIS WAS SOMEWHAT INSPIRED

00:19:53,460 --> 00:19:54,460
BY THAT.

00:19:54,460 --> 00:19:58,180
LET ME GO GET THIS INTERFACE, CALL ALL THE FUNCTIONS THAT IT PROVIDES, AND THOSE ARE

00:19:58,180 --> 00:20:00,921
ALL NATIVE C FUNNELS USING A CALLING CONVENTION

00:20:00,921 --> 00:20:04,480
PROVIDED BY C, SO LET'S TAKE A LOOK AT WHAT THAT

00:20:04,480 --> 00:20:08,900
WOULD LOOK LIKE. I CAN GO IMPORT THE EFI MODULE, WHICH ONLY

00:20:08,900 --> 00:20:12,600
EXISTS SINCE I'M BOOTED VIA EFI AND I CAN GET A METHOD

00:20:12,600 --> 00:20:15,550
FROM THE SYSTEM TABLE PROVIDED TO EFI APPS WHEN

00:20:15,550 --> 00:20:22,410
THEY START UP. IN PARTICULAR, A CONSOLE METHOD.

00:20:22,410 --> 00:20:27,059
I CAN GET THE ACTUAL STRUCTURE OF THAT SINCE THAT'S A POINTER, C-TYPE'S CONVENTION FOR

00:20:27,059 --> 00:20:31,390
REFERENCING A POINTER SO NOW I HAVE AN OUTPUT INTERFACE.

00:20:31,390 --> 00:20:34,530
AND I CAN CALL METHODS LIKE CLEAR SCREEN, AND

00:20:34,530 --> 00:20:42,780
PASS THAT INTERFACE AND CLEAR THE SCREEN BY CALLING A FIRMWARE FUNCTION FROM PYTHON.

00:20:42,780 --> 00:20:56,480
OR I COULD OUTPUT A FAMILIAR GREETING... AGAIN, USING FIRMWARE FUNCTIONS, NOT USING

00:20:56,480 --> 00:21:01,841
PYTHON. SO HOW THAT ACTUALLY WORKS, C-TYPES IS AN

00:21:01,841 --> 00:21:05,550
INTERFACE TO CALL C-TYPES AND C-FUNCTIONS FROM

00:21:05,550 --> 00:21:09,230
PYTHON. AND LIB FFI IS THE FOREIGN FUNCTION INTERFACE

00:21:09,230 --> 00:21:14,140
LIBRARY THAT'S BUILT ON THAT ACTUALLY IMPLEMENTS THE CALLING CONVENTIONS SO IT'S WHAT SAYS

00:21:14,140 --> 00:21:17,390
THAT IF YOU WANT TO CALL A FUNCTION, THEN THIS ARGUMENT

00:21:17,390 --> 00:21:22,100
IS IN THIS REGISTER THIS ONE HERE THE REMAINING ARGUMENTS ARE PUSHED ON THE STACK IN THIS

00:21:22,100 --> 00:21:24,270
ORDER, HERE'S HOW TO CLEAN IT UP.

00:21:24,270 --> 00:21:28,480
AND IT IMPLEMENTS ALTHOUGH PLATFORM SPECIFIC FUNCTIONALITY SO THAT PYTHON AND C-TYPES DON'T

00:21:28,480 --> 00:21:33,150
HAVE TO. SO WE PORTED LIB FFI TO LIVE INSIDE THE GRUB

00:21:33,150 --> 00:21:39,290
ENVIRONMENT AND WE ADDED SUPPORT FOR THE EFI CALLING CONVENTION WHICH IS DIFFERENT ON 32-BIT

00:21:39,290 --> 00:21:43,590
AND 64 BIT, ON 32-BIT, IT IS THE STANDARD CALL

00:21:43,590 --> 00:21:46,671
CONVENTION USED ON WINDOWS AND ON 64-BIT, IT'S

00:21:46,671 --> 00:21:49,110
THE WINDOWS 64-BIT CALLING CONVENTION WHERE YOU

00:21:49,110 --> 00:21:54,620
PASS A PILE OF ARGUMENTS IN REGISTERS. SO ONCE WE ADDED THAT SUPPORT, WE CAN NOW

00:21:54,620 --> 00:21:57,560
DECLARE AN EFI FUNCTION AND AN EFI FUNCTION PROTOCOL

00:21:57,560 --> 00:22:00,910
FULL OF FUNCTIONS ENTIRELY IN PYTHON USING THE

00:22:00,910 --> 00:22:04,590
C TYPE LANGUAGE, CALL THEM FROM PURE PYTHON AND WITHOUT

00:22:04,590 --> 00:22:09,900
WRITING A SINGLE LINE OF C-CODE TO CALL IN ARBITRARY FIRMWARE FUNCTION.

00:22:09,900 --> 00:22:14,980
SO WHAT KINDS OF THINGS CAN WE DO WITH THIS BEYOND JUST HELLO WORLD, THAT KIND OF THING.

00:22:14,980 --> 00:22:17,520
WE'VE GOT A BINDING FOR THE EFI FILE LAYER THAT

00:22:17,520 --> 00:22:20,760
USES EFI FILE PROTOCOL AND THE NICE THING ABOUT

00:22:20,760 --> 00:22:23,100
THIS, UNLIKE GRUBS FILE ERRORS, IT KNOWS HOW TO

00:22:23,100 --> 00:22:25,380
MAKE -- TO WRITES TO A FILE SYSTEM AND NOT JUST

00:22:25,380 --> 00:22:28,290
READ IT. SO WE CAN DO THINGS LIKE THIS, GO GET THE

00:22:28,290 --> 00:22:31,280
BOOT FILE SYSTEM, MAKE A DIRECTORY IN IT, CREATE

00:22:31,280 --> 00:22:33,630
A FILE IN THAT DIRECTORY, AND WRITE SOME CONTENTS

00:22:33,630 --> 00:22:37,300
TO THAT. WE CREATED A FILE-LIKE OBJECT ON TOP OF THIS

00:22:37,300 --> 00:22:40,580
INTERFACE THAT GIVES YOU ALL THE STANDARD THINGS

00:22:40,580 --> 00:22:46,510
YOU EXPECT FROM A PYTHON FILE. ON TOP OF THAT, HOW ABOUT GRAPHICS?

00:22:46,510 --> 00:22:51,120
WE'VE DONE TEXT BUT THERE IS AN EFI GRAPHICS OUTPUT PROTOCOL THAT GIVES YOU FUNCTIONS TO

00:22:51,120 --> 00:22:53,730
READ AND WRITE THE CONTENTS OF THE SCREEN.

00:22:53,730 --> 00:22:56,060
SO WHAT KINDS OF THINGS MIGHT WE DISPLAY WITH THIS ONE?

00:22:56,060 --> 00:23:02,210
WELL, IT TURNS OUT PRESENTATION SLIDES ARE GRAPHICS, SO WHEN I SAID THERE ARE DEMOS

00:23:02,210 --> 00:23:06,600
THROUGHOUT THIS TALK, I SHOULD ALSO SAY THIS ENTIRE TALK IS A DEMO AND IT'S ALL RUNNING

00:23:06,600 --> 00:23:13,669
INSIDE OF THIS ENVIRONMENT.

00:23:13,669 --> 00:23:20,350
[ Applause ] THANK YOU.

00:23:20,350 --> 00:23:22,570
SO IN PARTICULAR, EVERY TIME IT LOOKED LIKE I WAS

00:23:22,570 --> 00:23:25,100
DOING AN ALT TAB BACK AND FORTH BETWEEN A PYTHON

00:23:25,100 --> 00:23:27,860
WINDOW AND THIS, I WAS HITTING ESCAPE TO GET OUT

00:23:27,860 --> 00:23:30,850
OF MY PRESENTATION AND A HOT KEY THAT BINDS INTO

00:23:30,850 --> 00:23:35,570
OUR READ LINE LAYER TO JUMP BACK TO THE PRESENTATION.

00:23:35,570 --> 00:23:37,890
AND LOOKS A LOT LIKE I'M SWITCHING BUT IT'S ALL

00:23:37,890 --> 00:23:42,350
RUNNING IN THE SAME APPLICATION, WITHOUT AN OPERATING SYSTEM AND IMENTIRELY USING EFI

00:23:42,350 --> 00:23:48,610
GRAPHICS PROTOCOL. NO NEW C-CODE, NOT A SINGLE LINE.

00:23:48,610 --> 00:23:52,600
SO WITH THAT, THE -- ONE LAST DEMO I WANT TO GIVE

00:23:52,600 --> 00:23:55,710
SINCE I DO HAVE A MOMENT OF TIME, IS IF I CAN DO

00:23:55,710 --> 00:23:59,960
GRAPHICS, WHO HERE REMEMBERS THE FUN OLD DAYS OF

00:23:59,960 --> 00:24:02,460
COMMODORE 64, OF DOS, WHERE YOU COULD PEEK AND

00:24:02,460 --> 00:24:05,480
POKE HARDWARE AND ESPECIALLY YOU COULD GET A RAW

00:24:05,480 --> 00:24:07,720
POINTER TO THE SCREEN AND START SCRIBBLING ON IT

00:24:07,720 --> 00:24:09,790
AND DRAWING. ANYBODY?

00:24:09,790 --> 00:24:11,880
AWESOME. LOTS OF HANDS.

00:24:11,880 --> 00:24:16,850
LET'S DO SOME OF THAT. SO LET'S GET A POINTER TO THE FRAME BUFFER,

00:24:16,850 --> 00:24:20,350
WHICH EVERY COLOR HAPPENS TO BE A 32-BIT VALUE IN

00:24:20,350 --> 00:24:25,320
BGR DATE ORDER, FOR WHATEVER REASON.

00:24:25,320 --> 00:24:28,540
I HAVE AN 800 BY 600 DISPLAY, SO I'LL CREATE A

00:24:28,540 --> 00:24:34,620
GIANT TWO-DIMENSIONAL ARRAY. I'LL PUT -- GO GET THAT FROM BITS.PRESENT,

00:24:34,620 --> 00:24:37,100
WHICH IS ALREADY INITIALIZED GRAPHICS FOR ME.

00:24:37,100 --> 00:24:40,160
THE GOP INTERFACE, GRAPHICS OUTPUT PROTOCOL, GO

00:24:40,160 --> 00:24:44,010
GET THE VIDEO MODE STRUCTURE AND DE-REFERENCE IT

00:24:44,010 --> 00:24:48,990
AND GO GET FRAME BUFFER BASE, WHICH TELLS YOU THE

00:24:48,990 --> 00:24:51,510
EQUIVALENTS HERE WOULD BE GO CREATE A POINTER TO

00:24:51,510 --> 00:24:55,410
C-BILLION OR A BILLION IN DOS WHERE A VIDEO MEMORY HAPPENS TO LIVE.

00:24:55,410 --> 00:24:59,970
WELL, HERE'S WHERE IT LIVES. SO HERE'S MY FRAME BUFFER, LET'S DO A QUICK

00:24:59,970 --> 00:25:03,920
LOOP AND OUTPUT SOME THINGS.

00:25:03,920 --> 00:25:08,210
I'LL CREATE A 400 BY 400 IMAGE TO GET IT SOMETHING BIG ENOUGH TO SEE WITHOUT TAKING

00:25:08,210 --> 00:25:14,020
TOO LONG.

00:25:14,020 --> 00:25:19,020
AND I'LL DECLARE A COUPLE OF BITS OF MATH HERE TO

00:25:19,020 --> 00:25:28,260
BUILD SOMETHING INTERESTING. DOING SOME SCALING TO MAKE IT 400 BY 400.

00:25:28,260 --> 00:25:40,000
AND I'LL DO A LITTLE BIT OF ITERATIVE MATH.

00:25:40,000 --> 00:25:48,980
25 ITERATIONS OUGHT TO BE ENOUGH. LET'S ITERATE.

00:25:48,980 --> 00:25:59,000
AND THE OTHER COMPONENT. I HEAR SOME LAUGHTER FROM THE PEOPLE WHO

00:25:59,000 --> 00:26:09,590
RECOGNIZE WHAT I'M DOING. LET'S CHECK THE MAGNITUDE.

00:26:09,590 --> 00:26:16,170
AND LET'S DRAW SOME COLOR. BUT IT UP IN THE UPPER RIGHT CORNER.

00:26:16,170 --> 00:26:27,230
ASSIGN IT AN APPROPRIATE COLOR. DISTRIBUTE IT TO ALL THREE COMPONENT AND DRAW.

00:26:27,230 --> 00:26:38,970
WE HAVE FRACTILES IN PYTHON VIA GRAPHICS PROTOCOL.

00:26:38,970 --> 00:26:49,450
[ Applause ] >> AND WITH THAT, ANY QUESTIONS?

00:26:49,450 --> 00:26:55,320
ALL RIGHTY. THERE'S A MIC RIGHT THERE IN THE CENTER IF

00:26:55,320 --> 00:26:58,620
YOU WANT TO BE AUDIBILITY.

00:26:58,620 --> 00:27:10,610
>> AUDIENCE: THAT IS LOUD. YOUR FFI PORTS, DID YOU RUN INTO ANY PARTICULAR

00:27:10,610 --> 00:27:16,370
STRUGGLES IMPORTING THAT TO THE EFI ENVIRONMENT FOR ANY MEMORY MANAGEMENT OR POINTER HANDLING

00:27:16,370 --> 00:27:18,880
OR THE LIKE?

00:27:18,880 --> 00:27:21,310
>> SO MEMORY MANAGEMENT AND POINTER HANDLING IS

00:27:21,310 --> 00:27:25,640
ACTUALLY ALMOST EXCLUSIVELY HANDLED BY C-TYPES AND WE DIDN'T HAVE TO DO ANYTHING SPECIAL

00:27:25,640 --> 00:27:26,799
TO MAKE THAT WORK.

00:27:26,799 --> 00:27:32,770
THE NON-TRIVIAL EFFORT INVOLVED WAS ACTUALLY PORTING LIB FFI ITSELF TO UNDERSTAND THE CALLING

00:27:32,770 --> 00:27:37,400
CONVENTION USED BY EFI. SO IN PARTICULAR, LIB FFI UNDERSTANDS HOW

00:27:37,400 --> 00:27:39,940
TO CALL WINDOWS FUNCTIONS ON WINDOWS AND HOW TO CALL

00:27:39,940 --> 00:27:45,380
LINUX IF YOU THINKS ON LINUX. IT HAD NO IDEA HOW TO CALL WINDOWS FUNCTIONS

00:27:45,380 --> 00:27:49,059
ON WHAT WE'RE PRETENDING IS A POSIX SYSTEM AND

00:27:49,059 --> 00:27:50,960
THAT LAYER WAS NON-PORTABLE SHE IT ONLY RAN ON

00:27:50,960 --> 00:27:55,470
WINDOWS, SO WE ENDED UP WRITING ABOUT 50, 75

00:27:55,470 --> 00:28:02,429
LINES WORTH OF EXTRA CODE TO PORT THAT OVER, INCLUDING SOME X-86 AND X-6866 ASSEMBLY CODE

00:28:02,429 --> 00:28:04,890
TO MAKE THAT WORK IN BOTH PLAT FORAGES AND IT

00:28:04,890 --> 00:28:07,030
WAS ONE OF THOSE CASES WHERE IT WAS ABOUT A WEEKEND

00:28:07,030 --> 00:28:10,570
WORTH OF WORK TO RIGHT THE 55 LINES OF CODES AND

00:28:10,570 --> 00:28:14,990
DEBUG IT BUT ONCE WE HAD THAT WORKING, V-TYPES WAS REALLY TRIVIAL.

00:28:14,990 --> 00:28:19,830
>> AUDIENCE: GOTCHA. THANK YOU.

00:28:19,830 --> 00:28:22,380
>> AUDIENCE: IS THERE ANY WAY TO HANDLE INTERRUPTS?

00:28:22,380 --> 00:28:26,100
>> SO, RIGHT NOW, WE DON'T HAVE A HOOK FOR THAT.

00:28:26,100 --> 00:28:30,610
WE COULD EASILY ADD THAT ONE. THAT WOULD EFFECTIVELY BE, LET'S WRITE A SMALL

00:28:30,610 --> 00:28:33,830
HANDFUL OF LINES OF ASSEMBLY TO BUILD THE --

00:28:33,830 --> 00:28:38,080
ACTUALLY, I TAKE THAT BACK. LET ME COVER -- LET ME COVER ONE ITEM THERE.

00:28:38,080 --> 00:28:43,620
YOU COULD ACTUALLY WRITE TO THE INTERRUPT DESCRIPTOR TABLE EASILY ENOUGH AND YOU COULD

00:28:43,620 --> 00:28:46,929
USE C-TYPES TO CREATES A FUNCTION THAT IS CALLABLE

00:28:46,929 --> 00:28:51,179
FROM THAT ENVIRONMENT. THE ONLY REALLY TRICKY BIT THERE IS THAT WITHOUT

00:28:51,179 --> 00:28:53,559
A LITTLE EXTRA HELP FROM C, THERE'S NO WAY TO DO

00:28:53,559 --> 00:28:56,919
AN INTERRUPT RETURN, SO WE WOULD NEED A COUPLE OF

00:28:56,919 --> 00:28:59,720
EXTRA HELPER FUNCTIONS TO MAKE THAT WORK BUT WE

00:28:59,720 --> 00:29:03,210
DON'T YET HAVE THEM. FLIPPING THAT AROUND, WE SHOULD ALSO ADD THE

00:29:03,210 --> 00:29:07,860
CLASSIC ENT86 DOS C COMPILER FUNCTION SO THAT YOU

00:29:07,860 --> 00:29:13,100
COULD CALL THE SOFT WARE INTERRUPT BUT THOSE WOULD BE MAYBE, 10, 15 LINES OF CODES AND

00:29:13,100 --> 00:29:14,940
A PYTHON BINDING AND WE'RE DONE AND WE WRITE

00:29:14,940 --> 00:29:19,980
EVERYTHING THAT USES THAT IN PYTHON. SO FOR THAT MATTER, I WOULD BE HAPPY TO CHAT

00:29:19,980 --> 00:29:21,760
WITH YOU IF YOU WOULD LIKE TO HACK ON THAT AND

00:29:21,760 --> 00:29:22,760
WORK ON A PATCH FOR THAT.

00:29:22,760 --> 00:29:25,910
A FUN ENVIRONMENT TO HACK ON. NEXT QUESTION?

00:29:25,910 --> 00:29:31,120
>> AUDIENCE: I WANTED TO ANNOUNCE THAT THE LIGHTNING TALKS WILL BE STARTING IN A COUPLE

00:29:31,120 --> 00:29:32,990
OF MINUTES SO ANYONE WHO HAD SIGNED UP FOR THAT

00:29:32,990 --> 00:29:37,450
SHOULD HEAD DOWN BUT WE CAN DO FIVE MORE MINUTES OF QUESTIONS IN THIS ROOM.

00:29:37,450 --> 00:29:41,280
>> AWESOME. >> AUDIENCE: REALLY INTERESTING TALK.

00:29:41,280 --> 00:29:47,040
THERE IS ANOTHER THING CALLED MIRAGE OS WHICH IS

00:29:47,040 --> 00:29:50,490
AN ML MACRO KERNEL, I BELIEVE IT'S CALLED, WHERE

00:29:50,490 --> 00:29:53,620
IT'S JUST LIKE ML RUNNING ON A ZION HYPER ADVISOR.

00:29:53,620 --> 00:29:56,549
CAN YOU SEE SOMETHING LIKE THIS DOING THE SAME

00:29:56,549 --> 00:30:00,539
THING FOR PYTHON SO YOU COULD RUN A WEB SERVICE OR SOMETHING?

00:30:00,539 --> 00:30:04,290
>> SO, THAT'S A REALLY INTERESTING POINT, ACTUALLY, SO I AM FAMILIAR WITH MIRAGE OS

00:30:04,290 --> 00:30:06,500
AND THERE ARE SEVERAL OTHER KINDS OF JUST ENOUGH

00:30:06,500 --> 00:30:09,760
OS OR BARE OS KINDS OF EFFORTS OF, YOU KNOW,

00:30:09,760 --> 00:30:11,510
IT WOULD BE DIFFICULT TO DO THAT ON REAL HARDWARE

00:30:11,510 --> 00:30:13,290
BECAUSE YOU HAVE TO DRIVE REAL HARDWARE BUT IF

00:30:13,290 --> 00:30:15,010
YOU'RE RUNNING IN A VIRTUAL MACHINE, IT'S NOT

00:30:15,010 --> 00:30:20,180
THAT HARD TO HAVE A BARE METAL IMPLEMENTATION. IT TAKES A DECENT AMOUNT OF WORK TO PROVIDE

00:30:20,180 --> 00:30:26,440
BINDING BUT FOR PYTHON, WE'RE THERE. SO IF SOMEBODY WANTED TO EXTEND THIS TO PROVIDE

00:30:26,440 --> 00:30:30,490
THAT KIND OF ENVIRONMENT INSIDE A VIRTUAL MACHINE, IT WOULD ACTUALLY NOT BE THAT HARD

00:30:30,490 --> 00:30:31,490
TO DO.

00:30:31,490 --> 00:30:39,330
THE NEXT FUN ITEM ON OUR TO-DO LIST, FOR WHAT IT'S WORTH, IS EFI HAS A TCP/IP PROTOCOL,

00:30:39,330 --> 00:30:41,871
SO WE WERE GOING TO PROVIDE BINDINGS TO THAT, MAKE

00:30:41,871 --> 00:30:44,950
IT WORK WITH THE PYTHON SOCKET MODULE AND SEE

00:30:44,950 --> 00:30:51,120
IF WE CAN'T RUN SIMPLE TCP/IPSERVEER.

00:30:51,120 --> 00:30:57,500
SO THEN YOU COULD HAVE A WEB -- TO YOUR FIRMWARE. SO, YES, BY ALL MEANS, WOULD BE AWESOME.

00:30:57,500 --> 00:31:03,990
>> AUDIENCE: SOUNDS LIKE A LOT OF FUN. >> NEXT QUESTION.

00:31:03,990 --> 00:31:07,070
>> AUDIENCE: I LOVE THE -- KUDOSFOR THAT. >> THANK YOU.

00:31:07,070 --> 00:31:14,440
>> AUDIENCE: WHAT'S THE SPEED COMPARISON BETWEEN RUNNING WHAT YOU JUST DID FOR THIS SET VERSUS

00:31:14,440 --> 00:31:18,760
RUNNING PYTHON THROUGH THE NORMALLY NUKES KERNEL?

00:31:18,760 --> 00:31:24,780
>> SO, SPEED COMPARISON, IT'S FUNNY, THIS RENDERED FAIRLY SLOWLY BUT NOT ACTUALLY FOR

00:31:24,780 --> 00:31:27,360
ANY REASON HAVING TO DO WITH PYTHON.

00:31:27,360 --> 00:31:30,280
THE PYTHON CODE ACTUALLY RUNS AT EFFECTIVELY THE

00:31:30,280 --> 00:31:35,570
SAME SPEED AS C-PYTHON DOES ON ANY OTHER PLATFORM AS LONG AS YOU DON'T TOUCH PLATFORM SERVICES,

00:31:35,570 --> 00:31:37,420
THINGS LIKE STAT ARE A LITTLE SLOWER BECAUSE THE

00:31:37,420 --> 00:31:42,330
FILE ON THE MY ZAG ISN'T AS OPTIMIZED AS LINUX, NEVER NEEDED TO BE.

00:31:42,330 --> 00:31:46,110
THE REASON THIS IS SLOW IS BECAUSE OF THE LIB FM

00:31:46,110 --> 00:31:50,370
LIBRARY, THIS IS SLOW BECAUSE IT USES SOFTWARE FLOATING POINT.

00:31:50,370 --> 00:31:54,809
IF WE WERE TO PROVIDE A VERSION OF LIB M THAT WOULD PROVIDE FLOATING POINT SUPPORT, THIS

00:31:54,809 --> 00:31:59,039
WOULD BE AS FAST AS IT IS UNDER LIE NEXT OR UNDER

00:31:59,039 --> 00:32:02,250
WINDOWS. EVERYTHING ELSE IS REASONABLE SPEED TO WRITE

00:32:02,250 --> 00:32:04,100
OUT THE FRAME BUFFER.

00:32:04,100 --> 00:32:06,330
IF I WERE TO WRITE OUT, FOR EXAMPLE, PURE BLUE

00:32:06,330 --> 00:32:09,150
AND JUST FILL THE WHOLE SCREEN WITH BLUE, ALMOST

00:32:09,150 --> 00:32:13,090
INSTANTANEOUS. SO THAT MUCH IS NOT A BIG DEAL.

00:32:13,090 --> 00:32:15,559
THAT'S ALWAYS THE REASON I TYPED THIS OUT BY HAND

00:32:15,559 --> 00:32:18,780
RATHER THAN USING THE PYTHON COMPLEX TYPE WHICH

00:32:18,780 --> 00:32:22,330
WOULD HAVE MADE THIS BRIEFER AND SIMPLER TO RECOGNIZE.

00:32:22,330 --> 00:32:27,049
THAT MAKES IT SEVERAL TIMES SLOWER BECAUSE, AGAIN, THE PYTHON COMPLEX LIBRARY DOES A LITTLE

00:32:27,049 --> 00:32:30,370
BIT MORE FLOATING POINT MATH THAN IT NEEDS TO,

00:32:30,370 --> 00:32:35,049
COMPARED TO THIS OPEN CODED VERSION. >> AUDIENCE: THANK YOU.

00:32:35,049 --> 00:32:42,580
>> ANY OTHER QUESTIONS? >> OKAY.

00:32:42,580 --> 00:32:44,420
LOOKS LIKE THAT'S IT. THANK YOU SO MUCH, JOSH.

00:32:44,420 --> 00:32:45,210

YouTube URL: https://www.youtube.com/watch?v=bYQ_lq5dcvM


