Title: Brandon Rhodes - Oh, Come On Who Needs Bytearrays - PyCon 2015
Publication date: 2015-04-12
Playlist: PyCon 2015
Description: 
	
Captions: 
	00:00:07,830 --> 00:00:10,710
>> ALL RIGHT. HELLO, EVERYBODY.

00:00:10,710 --> 00:00:17,000
I HAVE QUITE AN HONOR TODAY. I AM LUCKY ENOUGH TO INTRODUCE BRANDON RHODES,

00:00:17,000 --> 00:00:20,050
A LONG-TIME PYTHON DEVELOPER, MAINTAINER OF

00:00:20,050 --> 00:00:23,410
SEVERAL AMATEUR ASTRONOMY LIBRARIES AND A DEVELOPER

00:00:23,410 --> 00:00:24,520
FOR DROPBOX.

00:00:24,520 --> 00:00:27,520
HE'S ALSO A QUIZ MASTER EXTRAORDINAIRE, AS SOME

00:00:27,520 --> 00:00:32,320
PEOPLE GOT TO FIND OUT LAST NIGHT. TODAY HE WILL BE PRESENTING ON OH, COME ON,

00:00:32,320 --> 00:00:33,820
WHO NEEDS BYTEARRAYS.

00:00:33,820 --> 00:00:39,670
WITHOUT FURTHER ADO, BRANDON RHODES. [ Applause ]

00:00:39,670 --> 00:00:47,629
>> WELCOME, EVERYBODY. I HOPE YOU'RE HAVING A GOOD TIME AT PYCON

00:00:47,629 --> 00:00:49,799
AND IN MONTREAL.

00:00:49,799 --> 00:00:56,250
MY TOPIC TODAY IS INDEED BYTEARRAYS. A VERY INTERESTING REASONED EDITION OF THE

00:00:56,250 --> 00:00:58,400
PYTHON ECOSYSTEM.

00:00:58,400 --> 00:01:02,229
BECAUSE IN PYTHON, NORMAL STRING OBJECTS, THE

00:01:02,229 --> 00:01:10,290
ONES WE'RE ACCUSTOMED TO DEALING WITH ARE IMMUTABLE, THEY CAN'T BE CHANGED OR MODIFIED.

00:01:10,290 --> 00:01:14,910
THIS IS TRUE OF THE TYPES AVAILABLE UNDER BOTH 2

00:01:14,910 --> 00:01:21,390
AND 3. THE ORIGINAL STRING TYPE, STR, WAS IN PYTHON

00:01:21,390 --> 00:01:24,110
3 RENAMED TO BYTES BECAUSE OF ITS LOW-LEVEL

00:01:24,110 --> 00:01:27,870
NATURE AND THAT SYNONYM WAS ALSO BACK PORTED TO PYTHON

00:01:27,870 --> 00:01:33,720
2. WE WON'T TALK MUCH TODAY ABOUT THE NEWER UNICODE

00:01:33,720 --> 00:01:39,380
BYTE STRINGS THAT WERE RENAMED TO THE STR TYPE,

00:01:39,380 --> 00:01:45,350
THE OFFICIAL STRING TYPE OF PYTHON 3. WE'RE GOING TO BE TALKING ABOUT THOSE LOWER-LEVEL

00:01:45,350 --> 00:01:48,681
ONES, THE STRINGS THAT DON'T PRETEND THAT THEY

00:01:48,681 --> 00:01:51,730
HAVE SYMBOLS INSIDE OF THEM SO MUCH AS THEY KNOW

00:01:51,730 --> 00:01:55,920
THAT THEIR INNARDS ARE REALLY BYTES, 8-BIT CODES

00:01:55,920 --> 00:02:04,680
0 THROUGH 255. FOR THE MOST PART I WILL PUT THAT LITTLE B

00:02:04,680 --> 00:02:09,780
IN FRONT OF THE BYTE STRINGS THAT I TYPE.

00:02:09,780 --> 00:02:16,740
IT IS OPTIONAL UNDER PYTHON 2 BUT IT BECOMES MANDATORY UNDER PYTHON 3, SO IF I WRITE MY

00:02:16,740 --> 00:02:20,200
STRINGS LIKE THIS, IT WILL WORK WHEREVER YOU TRY

00:02:20,200 --> 00:02:24,650
THIS LATER IF YOU WANT TO SEE THE EXAMPLES RUN.

00:02:24,650 --> 00:02:26,780
STRINGS ARE IMMUTABLE. WHAT DOES THAT MEAN IT?

00:02:26,780 --> 00:02:29,170
MEANS THAT WHEN YOU CALL METHODS, WHEN YOU DO

00:02:29,170 --> 00:02:33,410
THINGS TO THEM, THE ORIGINAL OBJECT ITSELF DOESN'T CHANGE.

00:02:33,410 --> 00:02:36,550
YOU GET GIVEN A NEW OBJECT AS THE RETURN VALUE OF

00:02:36,550 --> 00:02:39,880
THE METHOD YOU CALL SO IF DOT LOWER RETURNS TO

00:02:39,880 --> 00:02:42,720
YOU A NEW STRING, YOU CAN STILL PEEK BACK AND SEE

00:02:42,720 --> 00:02:47,950
THAT THE ORIGINAL IS UNTOUCHED AND UNCHANGED. IF YOU RUN SPLIT, YOU'LL SEE THAT BOTH OF

00:02:47,950 --> 00:02:50,580
THE OBJECTS YOU'VE BEEN GIVEN ARE NEW STRING OBJECTS,

00:02:50,580 --> 00:02:57,660
THE ORIGINAL IS STILL UNCHANGED. THEY DO NOT ALLOW ASSIGNMENT BECAUSE THAT

00:02:57,660 --> 00:03:00,300
WOULD MAKE THEM CHANGE, IT WOULD MAKE THEM MUTATE

00:03:00,300 --> 00:03:03,110
IS THE TECHNICAL TERM IN COMPUTER SCIENCE.

00:03:03,110 --> 00:03:10,720
NOW IMMUTABILITY HAS A LONG AND VERY SUCCESSFUL CAREER IN PYTHON BECAUSE IT MAKES THINGS SIMPLE

00:03:10,720 --> 00:03:17,739
YOU DON'T PASS A NAME TO A FUNCTION ONLY TO SUDDENLY DISCOVER IT'S ANOTHER NAME WHEN IT

00:03:17,739 --> 00:03:18,930
COMES BACK.

00:03:18,930 --> 00:03:21,660
YOU DON'T PASS A STRING OR A BLOCK TO SOMEONE AND

00:03:21,660 --> 00:03:24,510
SUDDENLY IT'S A DIFFERENT STRING OR BLOCK, IT'S A

00:03:24,510 --> 00:03:27,340
VERY, VERY SIMPLE MODEL THAT IF YOU HAVE THE WORD

00:03:27,340 --> 00:03:32,400
"PYTHON," YOU KNOW IT WILL ALWAYS REMAIN SO. AND IT ACTUALLY IS ONE OF THE MOST PARTS OF

00:03:32,400 --> 00:03:36,700
PYTHON THAT'S THE MOST LIKE FUNCTIONAL PROGRAMMING LANGUAGES, WHERE NEW RESULTS ARE

00:03:36,700 --> 00:03:42,890
RETURNED INSTEAD OF BEING WRITTEN ON TO DATA STRUCTURES YOU ALREADY HOLD.

00:03:42,890 --> 00:03:48,080
THE STRING TYPES ARE A PRIMARY EXAMPLE OF THAT.

00:03:48,080 --> 00:03:50,410
BUT IT SOMETIMES IS A LITTLE EXPRESSIVE IN TERMS

00:03:50,410 --> 00:03:53,760
OF ALLOCATION. ANY TIME YOU WANT TO MAKE A LITTLE TWEAK TO

00:03:53,760 --> 00:03:57,010
A STRING, IT HAS TO ALLOCATE A NEW ONE FOR YOU.

00:03:57,010 --> 00:04:00,010
THAT MEANS A LOT OF DATA GETS COPIED BACK AND

00:04:00,010 --> 00:04:07,060
FORTH INTO NEW AREAS OF MEMORY. NOT EVERYBODY IS HAPPY ABOUT THAT, AND SO

00:04:07,060 --> 00:04:10,360
PYTHON 3 INTRODUCED AND THEN IT WAS BACK-PORTED TO

00:04:10,360 --> 00:04:17,200
PYTHON 2, 6 AND 7, THE NEW BYTEARRAY. A BUILT-IN, PYTHON 2-7, PYTHON 3, YOU CAN

00:04:17,200 --> 00:04:19,729
JUST TYPE "BYTEARRAY" AND YOU'LL GET ACCESS TO

00:04:19,729 --> 00:04:24,720
THAT TYPE JUST LIKE WITH STR AND INT AND LIST.

00:04:24,720 --> 00:04:30,349
A BYTEARRAY IS IMMUTABLE STRING THAT IS BASED --

00:04:30,349 --> 00:04:35,710
THIS IS INTERESTING -- ON PYTHON 3'S BYTE STRING,

00:04:35,710 --> 00:04:42,449
NOT THE OLD STR STRING FROM PYTHON 2. AND THAT'S AN INTERESTING PROBLEM THAT IT'S

00:04:42,449 --> 00:04:48,770
BASED ON PYTHON 3 LEAST BYTE STRING TYPE, BECAUSE,

00:04:48,770 --> 00:04:53,780
HONESTLY, THE PYTHON 3 BYTES TYPE IS DESIGNED TO

00:04:53,780 --> 00:04:57,919
BE AWKWARD FOR STRING OPERATIONS. WHY?

00:04:57,919 --> 00:05:07,870
SO YOU WILL WANT TO BE A GOOD PERSON AND RUN DECODE BEFORE TREATING YOUR DATA AS CHARACTERS,

00:05:07,870 --> 00:05:14,809
AND THIS HAS LED TO PYTHON 3 PROGRAMMERS TENDING TO WRITE CODE THAT IS FROM THE GROUND UP PREPARED

00:05:14,809 --> 00:05:20,159
FOR INTERNATIONALIZATION AND DIFFERENT ALPHABETS BECAUSE THEY THINK ABOUT THE ISSUE OF DECODING

00:05:20,159 --> 00:05:23,590
ON THE WAY IN AND ENCODING ON THE WAY BACK OUT,

00:05:23,590 --> 00:05:27,330
BECAUSE THEY HAVE TO. BUT WE'LL SEE IT LEADS TO SOME INTERESTING

00:05:27,330 --> 00:05:30,849
BEHAVIORS, JUST PROFESSIONALLY, ALWAYS BEWARE OF

00:05:30,849 --> 00:05:36,729
USING STRING TYPES THAT WISH YOU WEREN'T USING THEM.

00:05:36,729 --> 00:05:41,229
IN PYTHON 2, LET'S COMPARE. WE CAN BUILD A STRING, WE COULD ASK ITS LENGTH,

00:05:41,229 --> 00:05:44,979
WE CAN SPLIT IT INTO PIECES. PYTHON 3'S BYTES TYPE.

00:05:44,979 --> 00:05:47,680
THERE IS A LITTLE B CHARACTERS HANGING OUT IN

00:05:47,680 --> 00:05:49,979
FRONT OF OUR BYTE STRINGS BUT WE CAN TAKE THE

00:05:49,979 --> 00:05:56,539
LENGTH, WE CAN CALL A METHOD LIKE SPLIT. IN PYTHON 2, WE CAN USE THOSE SQUARE BRACKETS

00:05:56,539 --> 00:05:59,309
WITH A COLON IN ORDER TO DO SLICING AND GET BACK

00:05:59,309 --> 00:06:05,819
A COPY OF THE INSIDE OF THE STRING. EXACT SAME THING WORKS EXACTLY THE SAME WAY

00:06:05,819 --> 00:06:08,580
IN PYTHON 3.

00:06:08,580 --> 00:06:11,539
IN PYTHON 2-, IT'S ALWAYS A CUSTOM IN PYTHON, IF

00:06:11,539 --> 00:06:14,060
SOMETHING HAS A LENGTH, IT SHOULD ALLOW ITSELF TO

00:06:14,060 --> 00:06:18,490
BE ITERATED OR LOOPED OVER. IN PYTHON 3, IF YOU LOOP OVER A CHARACTER

00:06:18,490 --> 00:06:25,099
STRING, YOU GET ONE CHARACTER STRINGS THAT ARE INSIDE.

00:06:25,099 --> 00:06:28,539
WHAT HAPPENS IF YOU PRINT -- PRESS "ENTER" FOR

00:06:28,539 --> 00:06:37,860
THIS LINE OF CODE IN PYTHON 3? YOU GET A SYNTAX ERROR.

00:06:37,860 --> 00:06:44,759
SYNTAX ERROR. YOU FAILED TO PAY THE PYTHON 3 PAREN TAX.

00:06:44,759 --> 00:06:49,479
[ Laughter ] PYTHON 3 IS KIND OF LIKE AN OLD TEXT-BASED

00:06:49,479 --> 00:06:52,149
ADVENTURE GAME WHERE YOU CAN TELL THE WRITER JUST

00:06:52,149 --> 00:06:54,949
THREW AN EXTRA OBSTACLE IN YOUR WAY BECAUSE THE

00:06:54,949 --> 00:07:05,849
ROOM NEEDED TO BE A LITTLE MORE COMPLICATED. YOU KNOW, IN -- YOU KNOW, IN THE -- IN SERIOUS...

00:07:05,849 --> 00:07:13,330
[ Applause ] IN SERIOUSNESS, I'VE KNOWN SOME RUBY PROGRAM

00:07:13,330 --> 00:07:16,189
YEARS, THIS IS A BIG DEBATE IN THE RUBY COMMUNITY.

00:07:16,189 --> 00:07:18,529
RUBY MAKES PARENTHESES OPTIONAL WHEN CALLING A

00:07:18,529 --> 00:07:23,129
FUNCTION. THE RUBYISTS WHO NEVER USE PARENTHESES ALWAYS

00:07:23,129 --> 00:07:27,099
TELL ME THEY COULD NEVER STAND PYTHON AGAIN AND I

00:07:27,099 --> 00:07:31,020
THOUGHT THAT WAS THE ODDEST THING. DOESN'T EVERYONE WANT TO TYPE PARENTHESES

00:07:31,020 --> 00:07:36,910
WHENEVER THEY ASK THEIR COMPUTER TO DO SOMETHING? AND I MUST ADMIT THAT ONCE IT WAS ME WHO WAS

00:07:36,910 --> 00:07:45,060
SUDDENLY HAVING TO TYPE PARENTHESIS, BUT THEY SURELY MUST STILL BE WRONG.

00:07:45,060 --> 00:07:50,219
ANYWAY... I DID A CONSERVATIVE ESTIMATE OF HOW MUCH

00:07:50,219 --> 00:07:54,229
TYPING IS COST ME BY THESE PRINT STATEMENTS IN PYTHON

00:07:54,229 --> 00:07:58,499
3 AND THIS IS -- THESE ARE CONSERVATIVE ESTIMATES,

00:07:58,499 --> 00:08:02,340
AND IT'S COMING OUT TO QUITE A BIT OF TYPING PER

00:08:02,340 --> 00:08:05,279
YEAR. I'M HAVING TO FACE GOING INTO PAREN DEBT JUST

00:08:05,279 --> 00:08:08,330
TO WRITE SOME EMARKS LISP NEXT WEEK.

00:08:08,330 --> 00:08:13,599
ANYWAY, PYTHON 3 WANTS THEM FOR THIS PRINT STATEMENT AND WHAT'S ANOTHER 2 PARENS WHEN

00:08:13,599 --> 00:08:17,550
I'VE ALREADY TYPED SO MANY?

00:08:17,550 --> 00:08:22,389
ONCE YOU GET THE PRINT STATEMENT WORKING, YOU'RE

00:08:22,389 --> 00:08:29,430
IN FOR ANOTHER SURPRISE. PYTHON 3 BYTES TYPE IS NOT MADE OF CHARACTERS,

00:08:29,430 --> 00:08:33,450
IT IS MADE OF NUMBERS.

00:08:33,450 --> 00:08:36,300
THIS BREAKS A VERY IMPORTANT CONTRACT THAT, FOR

00:08:36,300 --> 00:08:39,030
ME, EXISTED WITH STRINGS WHICH IS THAT I CAN PULL

00:08:39,030 --> 00:08:44,490
THEM INTO PIECES WITH EITHER INDEXING OR SLICING AND KNOW THAT THEY WOULD GO BACK TOGETHER

00:08:44,490 --> 00:08:48,040
AGAIN. NOW, THERE IS A WAY AROUND BY ASKING FOR ONE

00:08:48,040 --> 00:08:53,580
ELEMENT SLICES INSTEAD OF LOOKING UP INTEGER INDEXES.

00:08:53,580 --> 00:08:57,320
BUT, CLEARLY, IT DOESN'T WANT ME TO TREAT IT LIKE

00:08:57,320 --> 00:09:01,200
A STRING. SO BYTES OBJECTS EVEN IF YOU LEARN SOME

00:09:01,200 --> 00:09:03,990
WORK-AROUND ARE KIND OF AN AWKWARD FIT FOR MANY

00:09:03,990 --> 00:09:09,590
OF THE TASKS THEY'RE CALLED UPON TO DO. THEY'RE KIND OF THIS HYBRID TYPE BETWEEN A

00:09:09,590 --> 00:09:13,770
LIST OF NUMBERS AND A STRING.

00:09:13,770 --> 00:09:22,580
THEY ARE KIND OF IN-BETWEEN AND THEY DON'T NECESSARILY DO EITHER ONE PERFECTLY WELL.

00:09:22,580 --> 00:09:27,010
SO WHY DO I BRING ALL OF THAT UP? WHY DO I REHEARSE THESE WELL-KNOWN ISSUES

00:09:27,010 --> 00:09:29,690
WITH PYTHON 3 BYTES WHICH, BY THE WAY, ARE BEING

00:09:29,690 --> 00:09:30,750
TAKEN CARE OF.

00:09:30,750 --> 00:09:40,030
PYTHON 2-5 WILL REINTRODUCE PERCENT FORMATTING FOR BYTE STRINGS BECAUSE NOW THAT THE EXPERIMENT

00:09:40,030 --> 00:09:45,690
IS IN ITS FIFTH VERSION, I THINK IT IS BEGINNING TO BECOME CLEAR THAT THE REAL PROBLEM IN PYTHON

00:09:45,690 --> 00:09:48,500
2 WASN'T THAT STRINGS WERE CONVENIENT, AND SO

00:09:48,500 --> 00:09:51,320
WE IGNORE UNICODE, IT'S THAT CONVERSION COULD

00:09:51,320 --> 00:09:54,260
HAPPEN AUTOMATICALLY WITHOUT WARNING.

00:09:54,260 --> 00:09:57,320
AND SO THEY ARE BEGINNING TO ADD POWER BACK INTO

00:09:57,320 --> 00:10:04,160
PYTHON 3 BYTE STRINGS BUT THEY PROBABLY WILL ALWAYS BE MADE OF NUMBERS NOW FOR BACKWARDS

00:10:04,160 --> 00:10:10,440
COMPATIBILITY AND WE BRING ALL THAT UP BECAUSE THE BYTEARRAY THAT I WILL NOW TALK ABOUT IS

00:10:10,440 --> 00:10:14,930
A MUTABLE VERSION OF PYTHON 3'S BYTE STRING,

00:10:14,930 --> 00:10:18,030
A MUTABLE VERSION OF PYTHON'S MOST UNDERPOWERED

00:10:18,030 --> 00:10:23,210
STRING TYPE. SO WE'LL JUST QUICKLY LOOK AT A FEW POSSIBLE

00:10:23,210 --> 00:10:27,110
APPLICATIONS AND WHETHER A MUTABLE VECTOR OF

00:10:27,110 --> 00:10:29,860
BYTES IS ABLE TO ACCOMPLISH THINGS BETTER OR

00:10:29,860 --> 00:10:36,460
WORSE THAN TRADITIONAL PYTHON. SO, FIRST, LET'S BE FAIR TO IT.

00:10:36,460 --> 00:10:42,840
WHAT IF YOU ACTUALLY WANT A LIST OF NUMBERS BETWEEN ZERO AND 255?

00:10:42,840 --> 00:10:45,930
THAT NEVER HAPPENS TO ME. [ Laughter ]

00:10:45,930 --> 00:10:48,951
SO I INVENTED -- IN THOSE RARE CASES WHERE YOU

00:10:48,951 --> 00:10:52,010
ACTUALLY WANT TO STORE BYTES, IF YOU HAD ONE, IS

00:10:52,010 --> 00:10:54,570
THE BYTEARRAY A GOOD CHOICE. SO I INVENTED ONE.

00:10:54,570 --> 00:10:57,960
I WROTE MY FIRST BLOOM FILTER AS PREPARATION FOR

00:10:57,960 --> 00:11:03,760
THIS TALK, A BLOOM FILTER IS A WAY TO -- LET'S SAY YOU HAVE A DICTIONARY OF WORDS AND BEFORE

00:11:03,760 --> 00:11:07,650
YOU GO LOOK ON DISK FOR WHETHER WORD IS IN YOUR

00:11:07,650 --> 00:11:11,740
DICTIONARY, YOU WANT A QUICK WAY TO KNOCK OUT A

00:11:11,740 --> 00:11:17,460
LOT OF WORDS, IT'S JUST NOT BEING CANDIDATES. WHAT YOU CAN DO IS SET UP A BIG BIT FIELD

00:11:17,460 --> 00:11:20,880
AND HAVE A COUPLE OF HASH FUNCTIONS THAT YOU THROW

00:11:20,880 --> 00:11:27,450
THE WORLD "ELEPHANT" AT THEM AND THEY IDENTIFY SOME BITS FOR YOU THAT BELONG TO "ELEPHANT."

00:11:27,450 --> 00:11:29,990
YOU GIVE THEM THE WORD "PYTHON," A DIFFERENT SET

00:11:29,990 --> 00:11:33,840
OF BITS. THE IDEA IS THAT IF YOU LOAD UP YOUR DICTIONARY

00:11:33,840 --> 00:11:36,380
BY SETTING ALL OF THE BITS FOR ELEPHANT AND ALL

00:11:36,380 --> 00:11:41,900
THE BITS FOR PYTHON, THEN WHEN YOU SEE THOSE WORDS LATER IN A DOCUMENT, YOU CAN JUST CHECK

00:11:41,900 --> 00:11:46,450
WHETHER THEY'RE BITS ARE SET TO KNOW IF THERE'S ANY POSSIBILITY THAT "ELEPHANT" IS IN YOUR

00:11:46,450 --> 00:11:50,420
DICTIONARY BECAUSE MANY WORDS WILL HAVE SETS OF

00:11:50,420 --> 00:11:55,370
BITS THAT AREN'T SET AT ALL AND SO -- OR SEVERAL OF WHICH AREN'T SET AND THAT YOU KNOW COULD

00:11:55,370 --> 00:11:57,370
NOT HAVE BEEN IN THE DICTIONARY YOU LOADED.

00:11:57,370 --> 00:12:00,440
THIS IS A NICE EXAMPLE BECAUSE IT LETS US DO A

00:12:00,440 --> 00:12:13,190
PURE MATH OPERATION, IN THIS CASE, THE IN-PLACE OREING OF A BYTE IN THIS ARRAY A WITH ITSELF,

00:12:13,190 --> 00:12:17,480
AND WITH A BIT THAT WE CREATE OVER HERE IN SET.

00:12:17,480 --> 00:12:21,280
AND WE CAN RUN THROUGH, SET THIS UP, AND THEN WE

00:12:21,280 --> 00:12:27,500
WANT TO TEST A WORTH, GO BACK IN AND USE THE READING VERSION OF SQUARE BRACKETS, NOT IN

00:12:27,500 --> 00:12:30,070
AN ASSIGNMENT STATEMENT BUT IN AN EXPRESSION,

00:12:30,070 --> 00:12:32,290
TO READ BACK THE VALUE OF A BIT.

00:12:32,290 --> 00:12:39,540
A NICE EXERCISE TO SEE HOW DOES THIS THING PERFORM, STORING AND RECEIVING A FEW TENS

00:12:39,540 --> 00:12:41,330
OF THOUSANDS OF BYTES.

00:12:41,330 --> 00:12:44,420
BY THE WAY, THE NAME A IN THE PREVIOUS CODE CAN

00:12:44,420 --> 00:12:51,280
BE EITHER AN OLD-FASHIONED ARRAY.ARRAY THAT'S BEEN AROUND IN PYTHON FOREVER, OR A NEW-FANGLED

00:12:51,280 --> 00:12:54,300
BYTEARRAY. TO THIS EXTENT, THEY BOTH PROVIDE THE SAME

00:12:54,300 --> 00:12:58,950
INTERFACE, EACH SLOT YOU CAN ADDRESS GETS YOU OR

00:12:58,950 --> 00:13:03,980
LET'S YOU STORE A BYTE. AND SO WITH THIS APPLICATION, I RAN IT BOTH

00:13:03,980 --> 00:13:08,500
WAYS AND BYTEARRAY SCORED ITS FIRST VICTORY, BECAUSE

00:13:08,500 --> 00:13:11,261
IT IS SO MORE SPECIFIC THAN ARRAY.ARRAY WHICH I

00:13:11,261 --> 00:13:13,910
BELIEVE CAN ALSO HOLD FLOATS AND INTEGERS AND

00:13:13,910 --> 00:13:18,330
THINGS LIKE THAT, BECAUSE THE BYTEARRAYS CODE PATH HAS ALMOST NO DECISIONS, IT IS ALMOST

00:13:18,330 --> 00:13:22,840
ALWAYS GOING TO STORE BYTES, IT IS ALMOST 7% FASTER

00:13:22,840 --> 00:13:26,470
FOR RUNNING THAT BLOOM ARRAY CODE THAT I JUST

00:13:26,470 --> 00:13:29,830
SHOWED YOU THAN THE ORIGINAL PURPOSE ARRAY.ARRAY

00:13:29,830 --> 00:13:34,120
PURPOSE. SO YOU MIGHT THINK THIS IS IMMEDIATELY AND

00:13:34,120 --> 00:13:36,620
OBVIOUSLY A GO-TO DATA STRUCTURE FOR LISTS OF

00:13:36,620 --> 00:13:42,680
8-BIT NUMBERS. I TRIED IT ANOTHER WAY.

00:13:42,680 --> 00:13:46,210
I WANT WANT TO KNOW WHAT'S EVEN FASTER THAN ANOTHER BYTE AWAY?

00:13:46,210 --> 00:13:53,380
A LIST OF INTEGERS. 1% FASTER.

00:13:53,380 --> 00:13:58,690
IF YOU JUST SAY, HEY, PYTHON, HERE'S A ONE-ELEMENT LIST WITH A 0 IN IT, MAKE ME A

00:13:58,690 --> 00:14:00,430
LOT OF THESE.

00:14:00,430 --> 00:14:07,500
A PLAY -- SORRY, 2%, A PLAIN LIST OF INT OBJECTS THAT HAPPEN TO BE IN THE RANGE 0 TO 255, IT

00:14:07,500 --> 00:14:11,580
WILL RUN EVEN FASTER THAN THE BYTEARRAY.

00:14:11,580 --> 00:14:13,930
WHY? WELL, IT'S BECAUSE, THINK OF WHAT THE BYTEARRAY

00:14:13,930 --> 00:14:17,210
IS DOING. IT'S STORING REAL BYTES.

00:14:17,210 --> 00:14:19,690
LOW-LEVEL IN YOUR COMPUTER, THAT MUST EACH BE

00:14:19,690 --> 00:14:25,980
TRANSLATED INTO AN INT OBJECT ADDRESS WHEN THE

00:14:25,980 --> 00:14:29,350
VALUE IS BEING HANDED OUT INTO YOUR PYTHON CODE,

00:14:29,350 --> 00:14:35,510
AND THEN WHEN AN INT VALUE -- EXCUSE ME, YEAH, WHEN AN INT OBJECT IS HANDED BACK, IT HAS

00:14:35,510 --> 00:14:38,510
TO BE CHANGED BACK INTO A SIMPLE BYTE IN ORDER TO

00:14:38,510 --> 00:14:41,230
BE STORED.

00:14:41,230 --> 00:14:46,650
THE LIST SKIPS ALL THAT. IT JUST STORES THE ADDRESSES YOU GIVE IT.

00:14:46,650 --> 00:14:53,340
THE -- NOW, THE BYTEARRAY, BY THE WAY, DOESN'T HAVE TO PAY ANY PENALTY TO ALLOCATE OR CREATE

00:14:53,340 --> 00:14:56,070
ANY OF THOSE INT OBJECTS BECAUSE IT JUST SO HAPPENS

00:14:56,070 --> 00:14:59,250
THAT THE PYTHON -- THE CPYTHON INTERPRETER, WHEN

00:14:59,250 --> 00:15:02,779
IT STARTS UP PREALLOCATES ALL THE INTEGER OBJECTS

00:15:02,779 --> 00:15:08,670
NEGATIVE 5-256 SO THEY NEVER HAVE TO BE CREATED OR DESTROYED OVER THE LIFETIME OF THE

00:15:08,670 --> 00:15:12,190
INTERPRETER. SO WHEN YOU ASK THE BYTEARRAY WHAT'S AT POSITION

00:15:12,190 --> 00:15:18,170
100 AND IT WANTS TO SAY 70, IT CAN GRAB THE EXISTING 70 INTEGER OBJECT THAT ALWAYS EXISTS

00:15:18,170 --> 00:15:20,670
IN MEMORY AND HAND IT BACK SO IT'S NOT HAVING

00:15:20,670 --> 00:15:23,430
TO GO DO A MALLACK OR ANYTHING, IT'S NOT HAVING

00:15:23,430 --> 00:15:26,810
TO GOOD MEMORY BUT IT STILL HAS TO DO THE STEP OF

00:15:26,810 --> 00:15:32,250
TRANSLATION AND IT'S HONESTLY EASIER TO STORE THE

00:15:32,250 --> 00:15:37,020
ADDRESS OF THE 70 OBJECT. THAT'S WHY THE LIST OBJECT RUNS FASTER, AND

00:15:37,020 --> 00:15:38,440
SO THIS IS INTERESTING.

00:15:38,440 --> 00:15:45,710
WE HAVE THIS NEW SPECIAL CASE CONTAINER THAT'S SLIGHTLY SLOWER THAN JUST USING PYTHON'S

00:15:45,710 --> 00:15:51,570
WELL-HONED DEFAULT DATA TYPES. A PLAIN OLD LIST IS A FASTER BIT VECTOR THAN

00:15:51,570 --> 00:15:54,060
THE FANCY NEW BYTEARRAY.

00:15:54,060 --> 00:15:56,670
EXCEPT IF YOU'RE USING PYPY, WHERE THEY'RE ALL

00:15:56,670 --> 00:16:01,920
THE SAME BECAUSE IT BECOMES THE SAME C-CODES UNDER THE HOOD -- MACHINE CODE, I SHOULD SAY,

00:16:01,920 --> 00:16:04,790
AND ALL THREE RUN MUCH FASTER AS WELL AS BEING

00:16:04,790 --> 00:16:08,350
EXACTLY EQUIVALENT. I TRIED IT OUT IN PYPY, IN EACH CASE FIGURED

00:16:08,350 --> 00:16:11,420
OUT I WAS TRYING TO DO EXACTLY THE SAME THING.

00:16:11,420 --> 00:16:16,380
I GUESS THEY'RE DONE ALREADY. I'LL JUST KEEP GOING.

00:16:16,380 --> 00:16:19,170
SO FOR THIS FIRST EXPERIMENT, WHAT IF I NEED A

00:16:19,170 --> 00:16:26,220
LIST OF INTEGERS BETWEEN 0 AND 255? MY VERDICT IS THAT THE BIT VECTOR IS SPACE

00:16:26,220 --> 00:16:30,080
EFFICIENT. YOU DON'T CHOOSE IT BECAUSE IT'S GOING TO

00:16:30,080 --> 00:16:33,700
BE OBVIOUSLY FASTER, IT'S NOT, OR OBVIOUSLY SIMPLER,

00:16:33,700 --> 00:16:39,170
IT'S DOING A LITTLE MORE UNDER THE HOOD. BUT THE GOOD, OLD-FASHIONED LIST OF INTEGERS

00:16:39,170 --> 00:16:45,410
HAS TO STORE IN EACH SLOT THE ADDRESS OF THE REAL

00:16:45,410 --> 00:16:51,480
INTEGER OBJECT 70. THE BIT VECTOR JUST STORES THE 7 BITS -- 8

00:16:51,480 --> 00:16:54,550
BITS THAT REPRESENT 70 AND, THEREFORE, USES ON

00:16:54,550 --> 00:16:56,800
A 64-BIT MACHINE, WHICH IS WHAT I'LL PRESUME

00:16:56,800 --> 00:16:59,850
FOR ALL OF THESE CALCULATIONS, EIGHT TIMES LESS

00:16:59,850 --> 00:17:04,089
SPACE. AND THE POINT AFTER A BLOOM FILTER IS TO SAVE

00:17:04,089 --> 00:17:09,709
SAYS IN RAM. THAT FOR BIT OPERATIONS IS WHY YOU GO TO THE

00:17:09,709 --> 00:17:12,929
BYTEARRAY BECAUSE IT SCORES BYTES AS HONEST TO

00:17:12,929 --> 00:17:18,019
GOODNESS BYTES WITH NO EXTRA OVERHEAD PER BYTE.

00:17:18,019 --> 00:17:21,439
IT'S A GREAT WAY TO GET NUMBERS BETWEEN 0 AND

00:17:21,439 --> 00:17:27,999
255, PACKED IN THE MINIMUM SPACE POSSIBLE. SO IT IS A WIN BUT NOT IN THE WAY YOU MIGHT

00:17:27,999 --> 00:17:31,200
INITIALLY EXPECT. ALL RIGHT.

00:17:31,200 --> 00:17:35,379
SECOND, IT IS A RE-USABLE BUFFER, WHEN YOU READ A

00:17:35,379 --> 00:17:41,240
STRING THIS, YOU CAN'T DO ANYTHING TO IT BECAUSE IT'S IMMUTABLE BUT A BYTEARRAY CAN BE REUSED.

00:17:41,240 --> 00:17:47,250
FOR A QUICK BENCHMARK, I GOT -- MADE A RANDOM FILE OF A GIGABYTE OF RANDOM DATA, READ IT

00:17:47,250 --> 00:17:51,509
WITH CAT SO I WAS ABLE TO ESTIMATE THAT PROBABLY

00:17:51,509 --> 00:17:56,700
PYTHON WON'T BE ABLE TO DO BETTER THAN .11 SECONDS ON MY MACHINE, READ CRINGE IN THE

00:17:56,700 --> 00:17:58,960
SAME DATE AT THAT TIME I TRIED IT WITH TCP.

00:17:58,960 --> 00:18:06,309
ANYONE HERE EVER USE TCP TO REWRITE DATA? IT TOOK SIX TIMES LONGER.

00:18:06,309 --> 00:18:11,279
ANYONE KNOW WHY? I STRACED THEM AND IT'S BECAUSE OF THE BLOCK

00:18:11,279 --> 00:18:15,909
SIZE. DD, ALAS, IS AN OLD AND CRAFTY AND LOW-LEVEL

00:18:15,909 --> 00:18:21,150
TOOL, WHILE CAT WILL ZOOM ALONG WITH 128K BLOCKS,

00:18:21,150 --> 00:18:28,140
SO IT ASKS THE OS FOR SOME DATA AND GETS 128,000 BYTES IN A SINGLE SHOT.

00:18:28,140 --> 00:18:31,360
DD, BECAUSE IT'S AN OLD-LEVEL FOR WRITING TO

00:18:31,360 --> 00:18:38,590
ANCIENT 70s BLOCK DEVICES READS AND WRITES 5R.512 BYTES BY DEFAULT, GIVING DD THE SAME

00:18:38,590 --> 00:18:41,390
BLOCK SIZE DOES MAKE IT PERFORM THE SAME, YOU CAN

00:18:41,390 --> 00:18:46,049
GIVE IT A BLOCK SIZE OF 128K AND GETS .11 SECONDS

00:18:46,049 --> 00:18:51,630
RIGHT THERE WITH CAT BUT IT'S NOT THE DEFAULT DESPITE I SAME TO KNOW ALL THESE PEOPLE THAT

00:18:51,630 --> 00:18:55,499
THINK DD WOULD BE FASTER BY DEFAULT. IT'S NOT.

00:18:55,499 --> 00:19:05,759
IT'S THE SAME READS AND WRITES. AND CAT IS THE SAME -- DD CAME FROM IBM.

00:19:05,759 --> 00:19:07,980
BUT THIS TEACHES US A FIRST LESSON THAT WE WILL

00:19:07,980 --> 00:19:11,240
NOW APPLY AS WE LOOK AT PYTHON I.O., WE NEED TO

00:19:11,240 --> 00:19:13,980
KEEP BLOCK SIZE IN MEANT, THE SIZE OF THE CHUNKS

00:19:13,980 --> 00:19:16,570
YOU READ DETERMINES HOW MANY CHUNKS YOU NEED TO

00:19:16,570 --> 00:19:20,919
READ, DETERMINES HOW OFTEN YOU NEED TO CONVERSE WITH THE OPERATING SYSTEM.

00:19:20,919 --> 00:19:25,899
WHICH IS OFTEN THE EXPENSE THAT CAN COME TO DOMINATE YOUR RUN TIME.

00:19:25,899 --> 00:19:31,570
HERE'S HOW WE DO IT IN NORMAL PYTHON. READ A BLOCK AND WRITE THE DATA BACK OUT.

00:19:31,570 --> 00:19:37,830
NOTE, THIS IS PERFECTLY SAFE IF AN UNDERSIZED BLOCK COMES IN BECAUSE THE STRING THAT I'M

00:19:37,830 --> 00:19:40,299
HERE CALLING DATA THAT COMES BACK IS LABELED WITH

00:19:40,299 --> 00:19:41,299
ITS LENGTH.

00:19:41,299 --> 00:19:46,230
IT COULD BE 5 BYTES, IT COULD BE 128K, IT --

00:19:46,230 --> 00:19:48,909
PYTHON STRINGS KNOW THEIR LENGTH AND SO WRITE CAN

00:19:48,909 --> 00:19:51,659
JUST ASK THE LENGTH AND SEND THAT MANY BYTES OF

00:19:51,659 --> 00:19:57,549
DATA BACK OUT. MY FIRST ATTEMPT AT DOING A READ INTO SEEMED

00:19:57,549 --> 00:19:59,789
TO WORK, AT FIRST, UNTIL I NOTICED THAT EVERY

00:19:59,789 --> 00:20:06,889
FILE I WROTE, HOWEVER BIG IT WAS ORIGINALLY, THE

00:20:06,889 --> 00:20:09,549
COPY THAT I MADE WITH THIS ROUTINE WOULD ALWAYS

00:20:09,549 --> 00:20:12,419
BE A MULTIPLE OF MY BLOCK SIZE.

00:20:12,419 --> 00:20:16,169
WHY IS THAT? BECAUSE WHEN I CREATE ONE OF THESE NEW BYTEARRAYS

00:20:16,169 --> 00:20:21,489
OF, LET'S SAY, 128K, WHAT THIS LOOP WAS DOING IS

00:20:21,489 --> 00:20:24,549
READING SOME NUMBER OF BYTES, WHO KNOWS HOW MANY

00:20:24,549 --> 00:20:27,399
COME IN IN THE NEXT BLOCK OF THE FILE IF I'M NEAR

00:20:27,399 --> 00:20:35,210
THE END, READS SOME NUMBER OF BYTES INTO ANY BYTEARRAY, AND THEN WRITES OUT THE WHOLE

00:20:35,210 --> 00:20:39,639
BYTEARRAY, INCLUDING ALL THE JUNK AT THE END THAT'S MAYBE NOT PART OF THE CURRENT BLOCK

00:20:39,639 --> 00:20:41,549
OF THE FILE.

00:20:41,549 --> 00:20:48,909
I WAS DOING MY WRITE OF THE WHOLE 128K BLOCK WITHOUT CONSULTING THE LENGTH TO SEE IF I

00:20:48,909 --> 00:20:54,960
SHOULD HAVE BEEN WRITING THE ENTIRE 128K BLOCK.

00:20:54,960 --> 00:21:04,500
ONE FIX IS TO SIMPLY USE SLICING. IS TO GET THAT BYTEARRAY CALLED DATA AND TAKE

00:21:04,500 --> 00:21:08,210
FROM IT TO WRITE EACH TIME THE SLICE THAT IS

00:21:08,210 --> 00:21:12,940
LENGTH LONG. SO IF I GET A FULL-SIZED BLOCK, I'M WRITING

00:21:12,940 --> 00:21:15,529
OUT ALL OF THE DATA, BUT IF I GET ONLY HALF A

00:21:15,529 --> 00:21:18,629
BLOCK AT THE END OF THE FILE, I ONLY WRITE THAT

00:21:18,629 --> 00:21:21,960
-- WELL, LAST HALF BLOCK OUT FROM THE INITIAL

00:21:21,960 --> 00:21:24,590
PART OF MY BYTEARRAY.

00:21:24,590 --> 00:21:27,330
WHAT IF WE DIDN'T WANT THE EXPENSE, THOUGH, OF

00:21:27,330 --> 00:21:33,619
HAVING TO DO THAT, BACK ONE SLIDE, EXPENSIVE SLICING OPERATION, BECAUSE ASKING A PYTHON

00:21:33,619 --> 00:21:38,480
STRING UNICODE STRING OR BYTEARRAY FOR A SLICE CREATES

00:21:38,480 --> 00:21:41,960
A WHOLE NEW ONE, AND COPIES AS MUCH DATA INTO

00:21:41,960 --> 00:21:45,200
THE NEW ONE AS YOU ASK FOR WITH THE LIMITS YOU

00:21:45,200 --> 00:21:47,100
SET IN THE SLICE.

00:21:47,100 --> 00:21:50,499
IF WE WANT TO ACHIEVE ZERO COPY, THE PEOPLE WHO

00:21:50,499 --> 00:21:53,269
ADDED BYTEARRAY TO THE LANGUAGE, THEY THOUGHT OF

00:21:53,269 --> 00:21:57,120
THAT, AS WELL. THEY ADDED A SECOND FEATURE THAT WORKS WITH

00:21:57,120 --> 00:22:04,619
BYTEARRAY CALLED A MEMORY VIEW. A MEMORY VIEW IS A SLICEABLE OBJECT.

00:22:04,619 --> 00:22:10,029
HERE I TAKE THE SLICE 3:6 OF THAT BYTEARRAY, IT'S

00:22:10,029 --> 00:22:20,980
A SLICE WITH NO MEMORY OF ITS OWN BUT IS LETTING YOU REACH INTO THE MEMORY IT WAS SLICED FROM

00:22:20,980 --> 00:22:22,259
TO MAKE THE CHANGE.

00:22:22,259 --> 00:22:25,489
ESSENTIALLY THIS MEMORY VIEW, THE "V" THAT I

00:22:25,489 --> 00:22:30,110
CREATE HERE, IS JUST A -- ESSENTIALLY, IT'S LIKE

00:22:30,110 --> 00:22:33,710
A STRING OBJECT BUT THE ADDRESSES IT WANTS TO

00:22:33,710 --> 00:22:36,590
WRITE TO IN MEMORY ARE THE ADDRESSES RIGHT THERE

00:22:36,590 --> 00:22:39,369
IN THE MIDDLE OF THE BYTEARRAY, SO WHEN I TRY TO

00:22:39,369 --> 00:22:47,169
SET ITS INDEX 0 VALUE, IT REALLY GOES TO INDEX 3

00:22:47,169 --> 00:22:52,389
IN THE REAL BYTEARRAY. WHEN I SET ITEM 1, IT REALLY GOES TO SLOT

00:22:52,389 --> 00:22:56,730
4. WHEN I SET ITEM 2, IT GOES TO SLOT 5.

00:22:56,730 --> 00:22:59,340
IT REALLY IS JUST CREATING AN OBJECT THAT ACTS

00:22:59,340 --> 00:23:04,269
LIKE IT'S A ALSO BYTEARRAY BUT IS, IN FACT, JUST

00:23:04,269 --> 00:23:08,940
AN OFFSET. IT'S ADDING SOMETHING TO EACH INDEX YOU USE

00:23:08,940 --> 00:23:11,730
AS YOU READ AND WRITE FROM IT.

00:23:11,730 --> 00:23:16,499
AND THIS IS WHAT CAN HELP US IN THE SITUATION WE'RE IN.

00:23:16,499 --> 00:23:20,899
HERE IS A 0 COPY VERSION OF MY FIXED CODE TO TRY

00:23:20,899 --> 00:23:27,010
TO READ IN LOTS OF BLOCKS. BEFORE, I WAS ASKING DATA, THE BYTEARRAY ITSELF

00:23:27,010 --> 00:23:32,169
TO DO THE SLICING AND, LIKE ALL PYTHON STRINGS, IT GIVES ME A WHOLE NEW ONE WHEN I ASK FOR

00:23:32,169 --> 00:23:34,049
A SLICE.

00:23:34,049 --> 00:23:37,610
NOW I'M LOOKING AT IT THROUGH A MEMORY VIEW SO IF

00:23:37,610 --> 00:23:40,789
I ASK, LET'S SAY, FOR VIEW OF -- YOU KNOW, IF

00:23:40,789 --> 00:23:44,610
LENGTH IS 128K, I'M ASKING FOR ALL THE DATA, IT

00:23:44,610 --> 00:23:47,149
JUST GIVES ME A LITTLE MEMORY VIEW OBJECT WHOSE

00:23:47,149 --> 00:23:49,440
ADDRESSES ARE POINTING AT THE WHOLE BLOCK OF

00:23:49,440 --> 00:23:52,990
DATA, A VERY CHEAP OPERATION, AND SO MEMORY VIEWS

00:23:52,990 --> 00:23:57,929
ARE OFTEN NECESSARY TO GET THINK KIND OF PERFORMANCE OUT OF THE BYTEARRAY WHEN DOING

00:23:57,929 --> 00:24:00,989
IO, ESPECIALLY WHEN YOU CAN'T PREDICT HOW BIG

00:24:00,989 --> 00:24:03,510
THE NEXT DELIVERY OF INFORMATION WILL BE.

00:24:03,510 --> 00:24:09,649
HERE ARE THE RUNTIMES OF DD AND CAT THAT WE DISCUSSED EARLIER.

00:24:09,649 --> 00:24:19,100
COMPARED TO JUST PLAIN OLD READ, WITH NORMAL PYTHON STRINGS, READ INTO, MY FIRST VERSION

00:24:19,100 --> 00:24:21,330
THAT WAS BROKEN BECAUSE IT WASN'T CAREFUL ABOUT

00:24:21,330 --> 00:24:25,109
HOW MUCH IT WROTE, DOES RUN SLIGHTLY FASTER THAN

00:24:25,109 --> 00:24:28,009
THE TRADITIONAL PYTHON WAY OF DOING THINGS, BUT

00:24:28,009 --> 00:24:33,679
WHEN YOU THEN PIVOT TO USING A SLICE BYTEARRAY

00:24:33,679 --> 00:24:36,399
AND SLICING IT, BECAUSE YOU'RE COPYING EVERY PIECE

00:24:36,399 --> 00:24:39,779
OF DATA INTO MEMORY TWICE, IT'S MUCH MORE EXPENSIVE.

00:24:39,779 --> 00:24:47,950
IT IS THE MEMORY VIEW, IT IS THAT ZERO EXPENSE, VERY LITTLE EXPENSE, CONSTANT TIME EXPENSE,

00:24:47,950 --> 00:24:51,799
I SHOULD SAY, ABILITY TO SLICE WITHOUT COPING

00:24:51,799 --> 00:24:54,721
DATA, THAT LETS US CREATE A CORRECT VERSION OF A

00:24:54,721 --> 00:25:01,289
FILE COPY WITHOUT -- WHILE STILL SLIGHTLY BEATING

00:25:01,289 --> 00:25:02,960
READ AND WRITE.

00:25:02,960 --> 00:25:09,710
AND TRADITIONAL STRINGS. SO THAT WAS A LOT OF WORK, AND WE GOT A 4%

00:25:09,710 --> 00:25:14,609
SPEED-UP WITH BYTEARRAY. NOW, SMALL BLOCKS, THINGS GET WORSE FOR

00:25:14,609 --> 00:25:18,730
BYTEARRAY. BECAUSE WHAT WILL SLICING HERE SO OFTEN DO,

00:25:18,730 --> 00:25:21,749
IT CREATES A NEW OBJECT EVERY TIME AND CREATING

00:25:21,749 --> 00:25:24,450
ONE OF THESE LITTLE VIEW OBJECTS WITH ITS HE POINTERS

00:25:24,450 --> 00:25:26,879
IN THE PART OF THE BYTEARRAY I WANT TO LOOK AT

00:25:26,879 --> 00:25:32,900
WAS FINE WHEN I WAS ONLY DOING IT EVERY FEW HUNDRED K OF DATA BUT WHAT IF I WANT THE DEFAULTS

00:25:32,900 --> 00:25:37,049
OF DD AND I'M GOING TO BE RUNING 1200 BYTES AT A

00:25:37,049 --> 00:25:40,320
TIME, WHAT IF I HAVE TO SPIN UP A NEW MEMORY VIEW

00:25:40,320 --> 00:25:46,690
FOR EVERY HALF K OF DATA? THEN THINGS START TO LOOK VERY BAD AND, IN

00:25:46,690 --> 00:25:49,190
FACT, THE MEMORY VIEW USED CORRECTLY, WHERE YOU'RE

00:25:49,190 --> 00:25:57,090
CAREFUL OF YOUR LINKS, IS SIMPLY A LOSS. IT'S MUCH -- READING, WHERE IT JUST RETURNS

00:25:57,090 --> 00:26:00,289
A PYTHON STRING IS REALLY EFFICIENT.

00:26:00,289 --> 00:26:06,929
A WRITE OF A PYTHON STRING IS REALLY EFFICIENT. YOU CAN EASILY GET INTO SITUATIONS WITH THE

00:26:06,929 --> 00:26:10,450
FANCY ATTEMPTS ONE MAKES WITH A BYTEARRAY TO CREATE

00:26:10,450 --> 00:26:14,399
MORE EXPENSIVE IO THAN YOU HAD WHEN YOU JUST USED

00:26:14,399 --> 00:26:20,899
TRADITIONAL IMMUTABLE STRINGS THAT, YES, REQUIRED PYTHON TO BUILD A NEW STRING FOR EVERY CALL

00:26:20,899 --> 00:26:27,220
TO READ BUT CUT OUT ALL OF THE REST OF THAT EXPENSE.

00:26:27,220 --> 00:26:32,080
I WAS SAD FOR THE BYTEARRAY. AT THIS POINT IN MY TALK.

00:26:32,080 --> 00:26:39,809
SO I STARED AT THE EXAMPLE. 20% SLOWDOWN FOR A SMALL BLOCK SIZE.

00:26:39,809 --> 00:26:48,629
BUT THEN, I THOUGHT OF SOMETHING. WHAT IF WE DON'T ALWAYS SLICE, BECAUSE WHEN

00:26:48,629 --> 00:26:53,009
READING FROM A FILE, DIFFERENT FROM A NETWORK, WHEN READING FROM A FILE, THE NORMAL CASE

00:26:53,009 --> 00:26:55,489
IS THAT UNLESS YOU'RE AT THE VERY END OF THE FILE,

00:26:55,489 --> 00:26:57,669
YOU'RE GOING TO GET AS MUCH AS YOU ASK FOR.

00:26:57,669 --> 00:27:02,639
ASK FOR 128K, YOU'RE GOING TO GET IT. THE NORMAL CASE IS THAT THE LENGTH EQUALS

00:27:02,639 --> 00:27:06,690
THE BLOCK SIZE AND IN THAT CASE, THERE'S NOT ONLY

00:27:06,690 --> 00:27:09,120
NO REASON TO ASK THE BYTEARRAY TO TAKE A SLICE

00:27:09,120 --> 00:27:11,950
OF ITSELF AND COPY ALL THAT DATA, THERE'S NO

00:27:11,950 --> 00:27:15,909
REASON TO USE THE VIEW TO LIMIT THE AMOUNT OF DATA

00:27:15,909 --> 00:27:19,759
YOU'RE USING FROM THE BLOCK. YOU'RE GOING TO USE ALL OF IT AND SO IF YOU

00:27:19,759 --> 00:27:22,720
HANDLE THAT SPECIAL CASE, YOU DON'T INCUR AN

00:27:22,720 --> 00:27:26,820
OBJECT CREATION STEP IN ORDER TO GET THAT WRITE

00:27:26,820 --> 00:27:36,429
CALL STARTED, AND YOU SLIGHTLY BEAT THE PERFORMANCE OF THE TRADITIONAL READ-WRITE

00:27:36,429 --> 00:27:39,270
LOOP BY 4%.

00:27:39,270 --> 00:27:48,779
JUST LIKE... JUST LIKE FOR THE BIG BLOCK CASE, SO EVEN

00:27:48,779 --> 00:27:52,220
IF YOUR IO IS IN A SITUATION WHERE THE BLOCK SIZE

00:27:52,220 --> 00:27:56,919
WILL BE VARYING OR MIGHT BE SMALL, YOU CAN, IF YOU'RE

00:27:56,919 --> 00:28:03,759
CAREFUL AND CUT AND PASTE FROM MY TALK SLIDES, YOU CAN RUN SLIGHTLY FASTER THAN THE TRADITIONAL

00:28:03,759 --> 00:28:10,009
READ AND WRITE WITH IMMUTABLE DRINKS. PYTHON 2.7, BY THE WAY, HAS THE SAME RELATIVE

00:28:10,009 --> 00:28:12,899
BEHAVIORS BETWEEN THOSE DIFFERENT CHOICES ON MY

00:28:12,899 --> 00:28:17,799
MACHINE, SLIGHTLY SLOWER. AND I THINK THE LESSON HERE IS THAT IT IS

00:28:17,799 --> 00:28:20,450
JUST HARD TO BEAT OLD-FASHIONED STRINGS WHEN YOU'RE

00:28:20,450 --> 00:28:22,869
PULLING IN DATA AND THEN JUST IMMEDIATELY SENDING

00:28:22,869 --> 00:28:26,859
IT BACK TO THE OPERATING SYSTEM OVER SOME OTHER

00:28:26,859 --> 00:28:32,080
CHANNEL. IT'S REALLY SOMETHING HOW THE GOOD-OLD-FASHION

00:28:32,080 --> 00:28:38,340
IMMUTABLE STRING THAT MAKES FUNCTIONAL PROGRAMMERS' HEARTS SING IS PRETTY MUCH AS

00:28:38,340 --> 00:28:41,989
GOOD IN THIS CASE AS OUR WEIRD SIDE EFFECTY IDEA

00:28:41,989 --> 00:28:47,029
OF CONSTANTLY MODIFYING THIS SINGLE BYTES ARRAY

00:28:47,029 --> 00:28:48,690
THAT WE HAVE CREATED.

00:28:48,690 --> 00:28:54,019
SO, MY VERDICT IS THAT IT IS DANGEROUS, BECAUSE IT'S SO EASY TO WRITE WHAT LOOKS LIKE PRETTY

00:28:54,019 --> 00:28:57,869
CODE, IT LOOKS LIKE ALMOST THE SAME LITTLE READ-WRITE LOOP BUT GOING TO OPERATE

00:28:57,869 --> 00:29:00,809
SUBSTANTIALLY WORSE IN SITUATIONS THAT YOU MIGHT

00:29:00,809 --> 00:29:03,029
NOT THINK TO TEST FOR UNLESS YOU THINK OF THE

00:29:03,029 --> 00:29:08,399
SMALL BLOCKS INDICATION. THE ONE ADVANTAGE IT DOES OFFER IS A GREAT

00:29:08,399 --> 00:29:13,419
MEMORY PROFILE BECAUSE THERE IS A LINK LATER TO A

00:29:13,419 --> 00:29:15,779
GREAT BLOG POST ONLINE ABOUT SOMEONE WRITING AN

00:29:15,779 --> 00:29:18,149
AUDIO SERVER THAT NEEDED TO KEEP LOTS OF STRINGS

00:29:18,149 --> 00:29:20,980
IN A BUFFER AND HIS MEMORY USAGE WAS GOING THROUGH

00:29:20,980 --> 00:29:23,090
THE ROOF BECAUSE IF YOU'RE CONSTANTLY ALLOCATING

00:29:23,090 --> 00:29:25,899
AND DE-ALLOCATING DIFFERENTLY SIZED STRINGS BECAUSE

00:29:25,899 --> 00:29:28,059
EVERY CALL TO READ NEEDS TO MAKE A NEW STRING TO

00:29:28,059 --> 00:29:30,399
HANDS IT BACK TO YOU, THEN YOU CAN GET A LOT OF

00:29:30,399 --> 00:29:35,429
MEMORY FRAGMENTATION. IF INSTEAD YOU HAVE ONE BYTEARRAY AND YOU

00:29:35,429 --> 00:29:39,070
USE IT OVER AND OVER AND OVER AND OVER, THERE'S NOTHING

00:29:39,070 --> 00:29:42,720
HAPPENING TO GET FRAGMENTED. SO DON'T DO THE BYTEARRAY.

00:29:42,720 --> 00:29:49,059
I WOULDN'T DO THE BYTEARRAY FOR THE 4% SPEED-UP. I WOULD DO IT BECAUSE I WANTED TO CONTROL

00:29:49,059 --> 00:29:51,570
MY MEMORY PROFILE BUT ONLY IF I KNEW THAT WAS

00:29:51,570 --> 00:29:55,340
A PROBLEM IN MY APPLICATION DOMAIN.

00:29:55,340 --> 00:30:01,059
NOW WICK GO ON TO ANOTHER AND MORE INTERESTING SITUATION, USING THE BYTEARRAY AS THE

00:30:01,059 --> 00:30:04,799
ACCUMULATOR. FUN QUESTION FOR PEOPLE DOING NEW NETWORK

00:30:04,799 --> 00:30:09,450
PROGRAMMING. HOW MANY BYTES WILL RECEIVE 1024 RETURN?

00:30:09,450 --> 00:30:14,289
THE ANSWER IS... ONE.

00:30:14,289 --> 00:30:16,909
OR MORE, IF THE NETWORK STACK IS IN THE MOOD, BUT

00:30:16,909 --> 00:30:21,690
YOU'RE ONLY GUARANTEED ONE, AND THIS IS THE OPPOSITE OF FILE IO.

00:30:21,690 --> 00:30:25,789
FILE IO, YOU ASK FOR 128K, IF THERE'S 128K LEFT

00:30:25,789 --> 00:30:29,090
IN THE FILE, IT WILL WAIT FOR THE DISK TO SPIN,

00:30:29,090 --> 00:30:33,970
WAIT FOR THE HEAD TO BE IN THE RIGHT PLACE. IT WILL LEAVE YOU PAUSED UNTIL A FULL 128K

00:30:33,970 --> 00:30:36,509
IS READY FOR DELIVERY AND THEN WAKE YOU BACK

00:30:36,509 --> 00:30:39,440
UP. THE NETWORK IS THE OPPOSITE.

00:30:39,440 --> 00:30:45,700
RECEIVE WILL BLOCK ONLY UNTIL AT LEAST A SINGLE BYTE IS AVAILABLE AND THEN SET YOU OFF RUNNING

00:30:45,700 --> 00:30:46,720
TO PROCESS IT.

00:30:46,720 --> 00:30:53,100
AND THAT CAN HAPPEN IF YOUR BUFFER SIZE HAPPENS TO BE JUST A LITTLE LESS THAN THE SIZE OF

00:30:53,100 --> 00:30:54,840
THE LAST FEW PACKETS THAT ARRIVED.

00:30:54,840 --> 00:30:57,960
YOU CAN HAVE A CALL TO RECEIVE THAT FIND ONLY ONE

00:30:57,960 --> 00:31:02,669
OR TWO BYTES LEFT. MEANING, UNLIKE IN THE CASE WHERE WE WERE

00:31:02,669 --> 00:31:06,999
CHOOSING OUR READ SIZE FOR FILES, USUALLY IT'S

00:31:06,999 --> 00:31:11,960
THE NETWORK, IT'S THE CLIENTS, YOU'RE COMMUNICATING WITH THAT KIND OF DECIDE HOW

00:31:11,960 --> 00:31:14,620
BIG YOUR CHUNKS OF IO ARE WHEN YOU'RE TALKING

00:31:14,620 --> 00:31:17,100
ON THE NETWORK, SO YOU'RE ALWAYS POTENTIALLY IN THE

00:31:17,100 --> 00:31:19,139
CASE WHERE YOU'RE DEALING WITH LITTLE PIECES OF

00:31:19,139 --> 00:31:22,749
DATA. THIS FACT, BY THE WAY, THAT YOU ALWAYS ARE

00:31:22,749 --> 00:31:26,289
GIVEN AN ANSWER WHEN EACH JUST A FEW BYTES CAN BE

00:31:26,289 --> 00:31:29,679
SENT OR RECEIVED IS WHY NEW NETWORK PROGRAMMERS

00:31:29,679 --> 00:31:32,600
TEND TO GET INTO THE, "BUT IT WORKED WHEN I RAN

00:31:32,600 --> 00:31:36,960
AGAINST LOCAL HOST PROBLEM." THEY GET INTO THAT SITUATION BECAUSE WHEN

00:31:36,960 --> 00:31:39,499
YOU RUN YOUR SERVER THAT YOU'VE JUST WRITTEN IN YOUR

00:31:39,499 --> 00:31:41,789
LITTLE CLIENT YOU'VE JUST WRITTEN ON LOCAL HOST,

00:31:41,789 --> 00:31:45,119
THE OS WILL SEND ENORMOUS BLOCKS OF DATA BACK AND

00:31:45,119 --> 00:31:50,580
FORTH BETWEEN THE TWO PROCESSES. THEN, THEY'LL TAKE IT TO THEIR TEAM AND SAY,

00:31:50,580 --> 00:31:52,759
LOOK WHAT I WROTE, TRY IT BETWEEN TWO DIFFERENT

00:31:52,759 --> 00:31:55,809
MACHINES. AND IT WILL HANG AND NEVER GET ALL THE DATA

00:31:55,809 --> 00:31:58,940
BECAUSE THEY DIDN'T LEARN ON LOCAL HOST THAT YOU

00:31:58,940 --> 00:32:04,539
RECEIVE WILL OFTEN JUST GIVE YOU A FEW THOUSAND BYTES AND YOU NEED TO KEEP AT IT AND WATCH

00:32:04,539 --> 00:32:07,230
UNTIL EVERYTHING YOU NEED HAS ARRIVED.

00:32:07,230 --> 00:32:15,279
SO WHAT IS IT LIKE TO USE A TRADITIONAL RECEIVE SOLUTION GETTING A NEW STRING EACH TIME, HOLDING

00:32:15,279 --> 00:32:22,139
THE NEW DATA THAT'S COME IN? THIS IS WHAT IT LOOKS LIKE, AND, AGAIN, HERE,

00:32:22,139 --> 00:32:24,440
WE'RE GETTING LOTS OF MAYBE LITTLE PIECES OF DATA

00:32:24,440 --> 00:32:27,159
WHICH I'M SIMULATING BY ONLY ASKING FOR A SINGLE

00:32:27,159 --> 00:32:31,259
ETHER NET PACKAGE LENGTH SO EACH WHEN I RUN THIS

00:32:31,259 --> 00:32:34,269
ON LOCAL HOST, IT WILL PRETEND LIKE PACKETS ARE

00:32:34,269 --> 00:32:39,950
COME IN. AND THE -- THIS IS WHAT MANY PYTHON PROGRAMMERS

00:32:39,950 --> 00:32:43,139
START WITH, THEY JUST CREATES AN EMPTY STRING AND

00:32:43,139 --> 00:32:49,330
THEY PLUS-EQUAL MORE DATA TO IT EACH TIME. IN PYTHON TUTORIALS, YOU DOUBTLESS -- MANY

00:32:49,330 --> 00:32:52,231
OF YOU WILL HAVE SEEN THIS, THE CREATING OF THE STRING

00:32:52,231 --> 00:32:55,090
AND DATA PLUS EQUALS MORE AS AN ANTI-PATTERN THAT

00:32:55,090 --> 00:33:00,859
YOU AVOID BECAUSE I TRIED RUNNING THIS. HOW LONG DOES IT IS PLUS-EQUALS APPROACH TAKE?

00:33:00,859 --> 00:33:03,869
INFINITY TIME, MEANING THAT I FINALLY NEEDED MY

00:33:03,869 --> 00:33:06,670
LAPTOP BACK SO I KILLED IT AND I'LL NEVER NOW HOW

00:33:06,670 --> 00:33:08,690
LONG THE LOOP WOULD HAVE TAKEN TO READ MY BIG

00:33:08,690 --> 00:33:11,169
ABYTE OF DATA BUT WHEN YOU DO PLUS-EQUALS, YOU'RE

00:33:11,169 --> 00:33:14,299
ASKING PYTHON TO CLEATS A LITTLE STRING AND THEN

00:33:14,299 --> 00:33:17,590
YOUR FIRST PLUS-EQUALS MAKES A SLIGHTLY LONGER ONE.

00:33:17,590 --> 00:33:19,669
YOUR NICKS PLUS-EQUALS THROUGH THE LOOP CREATES A

00:33:19,669 --> 00:33:22,229
SLIGHTLY LONGER ONE INTO WHICH ALL THE DATA FROM

00:33:22,229 --> 00:33:24,919
THE SECOND STRING HAS TO BE COPIED TO MAKE THE

00:33:24,919 --> 00:33:26,749
THIRD ONE AND NOW YOU HAVE TO GO THROUGH THE LOOP

00:33:26,749 --> 00:33:29,729
AGAIN AND COPY ALL THAT DATA AGAIN TO MAKE YOUR

00:33:29,729 --> 00:33:33,669
FOURTH STRING AND IF YOU HAVE A MILLION BYTES TO

00:33:33,669 --> 00:33:36,559
READ, YOU WIND UP DOING HALF A TRILLION OPERATIONS.

00:33:36,559 --> 00:33:41,100
IT'S CALLED AN ORDER IN SQUARED ALGORITHM, GENERALLY TO BE AVOIDED IF YOU WANT IT TO

00:33:41,100 --> 00:33:44,070
FINISH BY LUNCHTIME.

00:33:44,070 --> 00:33:48,999
SO THIS IS WHAT WE TELL EVERYONE TO DO. PIVOT TO KEEPING A LIST OF BLOCKS THAT YOU'VE

00:33:48,999 --> 00:33:52,210
RECEIVED AND JOIN THEM TOGETHER AT THE END IN A

00:33:52,210 --> 00:33:57,840
SINGLE STEP, PYTHON'S MUCH BETTER AT THAT. THIS ACTUALLY FINISHED ON MY LAPTOP, IT IS

00:33:57,840 --> 00:34:00,389
TRADITIONAL WAY OF ACCUMULATING DATA FROM THE

00:34:00,389 --> 00:34:03,599
INTERNET ON PYTHON OR FROM A NETWORK, TOOK ABOUT

00:34:03,599 --> 00:34:06,190
A LITTLE MORE THAN A SECOND TO READ IN A GIG OF

00:34:06,190 --> 00:34:15,660
DATA IN THOSE SMALL 1.5K CHUNKS. NOW, THERE IS A VERSION, LIKE READ INTO, BUT

00:34:15,660 --> 00:34:19,320
THAT RECEIVES INTO A BYTEARRAY YOU'VE ALREADY BUILT

00:34:19,320 --> 00:34:21,700
INSTEAD OF BUILDING A NEW STRING, BUT IT NOW RUNS

00:34:21,700 --> 00:34:26,560
INTO A PROBLEM. WHEN WE DO READ INTO, OR RECEIVE INTO, WHERE

00:34:26,560 --> 00:34:27,740
DOES IT PUT THE DATA?

00:34:27,740 --> 00:34:31,860
AT THE BEGINNING OF THE ARRAY AND ALL OF OUR INCOMING BLOCKS WILL OVERWRITE EACH OTHER.

00:34:31,860 --> 00:34:34,490
WHOA WE WANT AS MORE AND MORE BLOCKS COME IN FROM

00:34:34,490 --> 00:34:38,290
THE NETWORK, IS TO ARRAIGNING THEM ALONG OUR BYTEARRAY.

00:34:38,290 --> 00:34:41,420
SO THAT MEMORY VIEW SLICING EXPENSE THAT I ADDED

00:34:41,420 --> 00:34:44,420
AN "IF" STATEMENT TO AVOID WHENEVER POSSIBLE IN

00:34:44,420 --> 00:34:47,610
THE PREVIOUS CODE? IT NOW BECOMES MANDATORY.

00:34:47,610 --> 00:34:54,659
AGAIN, THIS ABILITY WITH A VIEW TO WRITE INTO BYTE LOCATIONS THAT AREN'T AT THE BEGINNING

00:34:54,659 --> 00:34:57,330
BUT ARE SOMEWHERE IN THE MIDDLE OF THE BYTEARRAY

00:34:57,330 --> 00:35:00,480
YOU'VE BUILT. THE FIRST BLOCK CAN GO AT THE BEGINNING BUT

00:35:00,480 --> 00:35:02,490
YOU NEED TO BUILD A MEMORY VIEW TO TARGET THE

00:35:02,490 --> 00:35:05,540
SECOND BLOCK AFTER THE FIRST BLOCK.

00:35:05,540 --> 00:35:13,120
THE THIRD BLOCK AFTER THAT, AND SO FORTH. AND SO YOU NEED TO BUILD A MEMORY VIEW AND

00:35:13,120 --> 00:35:15,990
YOU'RE GOING TO NEED TO USE IT TO TARGET THAT RECEIVE

00:35:15,990 --> 00:35:21,720
V INTO AT SUBSEQUENT POSITIONS INSIDE OF YOUR

00:35:21,720 --> 00:35:25,140
BIG BYTEARRAY, PRESUME THAT YOU KNOW THE CONTENT

00:35:25,140 --> 00:35:27,850
LENGTH AHEAD OF TIME AND IF PREALLOCATED IT AND

00:35:27,850 --> 00:35:33,410
YOU'RE WAITING TO FILL IT WITH DATA. THIS TAKES ABOUT EIGHT-TENTHS OF A SECOND

00:35:33,410 --> 00:35:36,630
BECAUSE WE -- A BIT OF A WIN HERE BECAUSE YOU HAVEN'T

00:35:36,630 --> 00:35:39,240
HAD TO BUILD A LIST, YOU HAVEN'T HAD TO CALL JOIN,

00:35:39,240 --> 00:35:41,870
YOU HAVEN'T BUILT A BUNCH OF INTERMEDIATE CALL

00:35:41,870 --> 00:35:45,390
STRUCTURES, IT ACTUALLY IS A SIGNIFICANT WIN WHEN

00:35:45,390 --> 00:35:49,160
YOU NEED TO KEEP THE DATA THAT YOU'RE READING RATHER THAN JUST IMMEDIATELY PASSING IT BACK

00:35:49,160 --> 00:35:51,790
TO THE OS.

00:35:51,790 --> 00:35:54,410
ANOTHER POSSIBILITY I SAW ON SOMEONE'S BLOG IS TO

00:35:54,410 --> 00:35:56,980
DO AN OLD-FASHIONED RECEIVE OF A NEW STRING AND

00:35:56,980 --> 00:36:00,230
THEN TRY TO DO A BYTEARRAY EXTEND TO GROW YOUR

00:36:00,230 --> 00:36:05,310
BYTEARRAY WITH THESE NEW STRINGS. IT COPIES THE DATA TWICE BUT DOES GET RID

00:36:05,310 --> 00:36:08,860
OF THAT JOIN CONCATENATION.

00:36:08,860 --> 00:36:11,820
IT LOOKS SOMETHING LIKE THIS, DATA.EXTEND NEAR

00:36:11,820 --> 00:36:16,680
THE BOTTOM. IT IS NOT A WIN OVER THE NORMAL WAY OF USING

00:36:16,680 --> 00:36:23,560
BYTEARRAYS, BECAUSE IT TURNS OUTS BYTEARRAY EXTEND IS PRETTY INEFFICIENT.

00:36:23,560 --> 00:36:27,090
IT ASKS FOR AN ITERATOR OVER ITS ARGUMENT AND

00:36:27,090 --> 00:36:30,560
THEN CALLS -- THE ITERATOR'S NEXT FUNCTION OVER

00:36:30,560 --> 00:36:34,150
AND OVER FOR EVERY BYTE AND THEN ASKS THE INT

00:36:34,150 --> 00:36:38,180
OBJECT WHAT ITS VALUE IS, SO THAT IT CAN THEN PUT

00:36:38,180 --> 00:36:44,820
IT IN AN INTERMEDIATE ARRAY, AND THAT INVOLVES HAVING TO INCREMENT AND DECRIMENT THE NUMBER

00:36:44,820 --> 00:36:47,870
IT'S IN AND BY THE TIME YOU'RE DONE, YOU'VE COMPUTED

00:36:47,870 --> 00:36:54,880
AT LEAST 40 BYTES OF BAND WIDTH OF RAM EVEN IGNORING THE ARGUMENTS AND STACKS THAT YOU'RE

00:36:54,880 --> 00:37:02,680
PASSING IN ORDER TO GET THAT SINGLE BYTE VALUE EXTENDED ON TO THE END OF YOUR BYTEARRAY.

00:37:02,680 --> 00:37:08,560
PLUS, IT DOESN'T WRITE TO YOU BYTEARRAY. IT WRITES TO AN INTERMEDIATE BUFFER THAT GROWS

00:37:08,560 --> 00:37:10,920
DYNAMICALLY AND THEN DOES THE APPEND WHEN IT'S

00:37:10,920 --> 00:37:16,080
DONE SO THAT SHOULD THAT ITERATION DIE PARTWAY THROUGH, YOU DON'T WIND UP HAVING MODIFIED

00:37:16,080 --> 00:37:17,960
THE BYTEARRAY SOME.

00:37:17,960 --> 00:37:22,150
IT WANTS TO EITHER SUCCEED OR FAIL AS AN AUTONOMIC OPERATION.

00:37:22,150 --> 00:37:27,780
SO THAT'S WHY IT'S KIND OF SLOW, KIND OF KLUGY, BUT SEEING THAT BLOGS POST MADE ME ASK A

00:37:27,780 --> 00:37:31,630
QUESTION. DOES THE BYTEARRAY HAVE AN APPEND OPERATION

00:37:31,630 --> 00:37:34,830
THAT'S ANY GOOD? I MEAN, SURELY THE PEOPLE WRITING IT KNEW

00:37:34,830 --> 00:37:37,900
THAT WE'D WANT TO DO THAT BUT SPINNING UP AN ITERATOR

00:37:37,900 --> 00:37:43,370
AND CALLING IT 1500 TIMES? DOES IT HAVE AN OPERATION THAT'S REALLY GOOD?

00:37:43,370 --> 00:37:48,290
AND, YES, IT DOES. I READ THE C-CODE TO FIND IT.

00:37:48,290 --> 00:37:53,150
NOW, THINK ABOUT IT. WHERE WOULD YOU PUT THE REAL EXTEND OPERATOR,

00:37:53,150 --> 00:37:56,980
THE REAL ABILITY TO MAKE YOUR BYTEARRAY LONGER?

00:37:56,980 --> 00:38:03,080
OBVIOUSLY, YOU WOULD HIDE IT BEHIND THE OPERATOR THAT WE'VE SPENT 20 YEARS TELLING PEOPLE NEVER

00:38:03,080 --> 00:38:06,870
TO USE WITH STRING VALUES.

00:38:06,870 --> 00:38:11,840
[ Laughter ] [ Applause ]

00:38:11,840 --> 00:38:13,750
THIS MIGHT BE SO DIFFICULT THAT SOME OF YOU WILL

00:38:13,750 --> 00:38:16,550
NEVER DO IT BUT IF YOU CAN CONVINCE YOURSELF TO

00:38:16,550 --> 00:38:22,400
TYPE THIS AFTER ALL OF THIS TIME, THIS IS ACTUALLY SOMETHING THAT BYTEARRAYS DO

00:38:22,400 --> 00:38:29,860
MAGNIFICENTLY, JUST PLUS-EQUAL THE ADDITIONAL DATA TO YOUR BYTEARRAY AND YOU WILL BEAT EVEN

00:38:29,860 --> 00:38:34,720
RECEIVE INTO'S ABILITY TO GROW YOUR ARRAY WITH

00:38:34,720 --> 00:38:38,170
DATA. SO THIS CASE WHERE WE NEED TO ACCUMULATE AND

00:38:38,170 --> 00:38:42,030
KEEP THE WHOLE PAY ROAD IS A REAL WIN FOR THE

00:38:42,030 --> 00:38:44,030
BYTEARRAY IN ALL THE APPROACHES AND THERE DON'T

00:38:44,030 --> 00:38:46,660
SEEM TO BE SHARP EDGES THAT CAN SUDDENLY MAKE IT

00:38:46,660 --> 00:38:53,350
BEHAVE MUCH WORSE THAN THE LISTEN JOIN. 30% SPEED-UP IN THAT LAST VERSION OF THE

00:38:53,350 --> 00:38:59,560
ALGORITHM AND CLEANER CODE. ADMIT IT, YOU'VE ALWAYS WANTED TO JUST JUST

00:38:59,560 --> 00:39:00,990
-- JUST PLUS-EQUAL, HAVEN'T YOU?

00:39:00,990 --> 00:39:03,470
IT'S THE NATURAL WAY TO WRITE IT IN PYTHON AND

00:39:03,470 --> 00:39:06,950
THIS IS ONE OF THOSE NEAT INTERSECTIONS WITH WHAT

00:39:06,950 --> 00:39:13,880
LOOKS GOOD AND READS ON THE PAGE, AS WELL. SO I'M NOT GOING TO TALK ABOUT SEND.

00:39:13,880 --> 00:39:15,810
YOU MIGHT THINK ABOUT THE FACT THAT I'LL GET INTO

00:39:15,810 --> 00:39:17,950
SEND DOESN'T ALWAYS SEND THE WHOLE PAY LOAD BUT

00:39:17,950 --> 00:39:23,130
PYTHON HAS LONG HAD YOU COVERED HERE. PYTHON SOCKETS HAVE FOR A VERY LONG TIME HAD

00:39:23,130 --> 00:39:27,250
A SEND ALL THAT SITS IN A LOOP IN C, SENDING

00:39:27,250 --> 00:39:34,380
SHORTER AND SHORTER TAILS OF YOUR DATA UNTIL FINALLY THE OS BUFFERS HAVE BEEN ABLE TO RECEIVE

00:39:34,380 --> 00:39:37,240
IT ALL. SO I DON'T SEE THAT WE NEED BYTEARRAYS FOR

00:39:37,240 --> 00:39:41,800
THAT. AND I CAN DECLARE THE BYTEARRAY THE WINNER.

00:39:41,800 --> 00:39:44,390
IF YOU NEED AN ACCUMULATOR, IF YOU NEED TO VERY

00:39:44,390 --> 00:39:50,050
QUICKLY N A PERFORMANCE-SENSITIVE ENVIRONMENT, ACCUMULATE A LOT OF INCOMING DATA, IT IS A

00:39:50,050 --> 00:39:54,830
NOTICEABLY GOOD WIN WITH TWO DIFFERENT TECHNIQUES THAT WORK PRETTY WELL.

00:39:54,830 --> 00:39:57,250
I'LL BRIEFLY MENTION THAT SOME PEOPLE WANT A

00:39:57,250 --> 00:40:01,110
FREESTYLE MUTABLE STRING. WHEN THEY SEE THE BYTEARRAY, THEY DON'T THINK

00:40:01,110 --> 00:40:03,790
OF IO, THEY DON'T THINK OF BLOOM FILTERS AND

00:40:03,790 --> 00:40:07,410
BIT VEHICLESTORS, THEY WANT TO MESS WITH A STRING.

00:40:07,410 --> 00:40:14,960
THEY WANT A STRING THAT THEY CAN JUST CHANGE. AND ALL -- I HAVE NOT FOUND YET A GOOD USE

00:40:14,960 --> 00:40:15,960
FOR THIS.

00:40:15,960 --> 00:40:18,110
AND I'LL SORT OF SHOW YOU WHY IT WINDS UP BEING

00:40:18,110 --> 00:40:22,320
AWKWARD. YOU WANT TO CHANGE PART OF THE PAY LOAD BEFORE

00:40:22,320 --> 00:40:25,720
USING, STORING OR RE-TRANSMITTING. THAT WOULD BE THE USE CASE HERE BECAUSE IF

00:40:25,720 --> 00:40:27,720
YOU WANT TO LOWERCASE THE WHOLE THING, YOU HAVE

00:40:27,720 --> 00:40:29,510
TO TOUCH ALL THE BYTES ANYWAY SO YOU MIGHT AS

00:40:29,510 --> 00:40:30,900
WELL BUILD A NEW ONE.

00:40:30,900 --> 00:40:34,140
GOOD THINGS, THE BYTEARRAY IS IMMUTABLE, GET IT

00:40:34,140 --> 00:40:37,430
AND CHANGE IT BUT NONE OF THE METHODS THAT IT

00:40:37,430 --> 00:40:44,620
SHARES WITH STRINGS DO MUTATION TO IT. IF YOU CALLED UPPER ON YOUR BYTEARRAY, YOU

00:40:44,620 --> 00:40:46,390
GET A NEW BYTEARRAY.

00:40:46,390 --> 00:40:52,290
SO YOU HAVE A MUTABLE STRING TYPE THAT DOES NOTHING STRING-LIKE MUTABLY.

00:40:52,290 --> 00:40:58,660
A BYTEARRAY ONLY CHANGES WHEN SUBJECTED TO LIST-LIKE OPERATIONS, LIKE ASSIGNMENT TO AN

00:40:58,660 --> 00:41:02,280
INDEX OR ASSIGNMENT TO A SLICE OR .CLEAR, AND SO

00:41:02,280 --> 00:41:05,010
THE RESULT, IF YOU TRY WRITING A NETWORK ALGORITHM

00:41:05,010 --> 00:41:07,160
OR SOMETHING WITH THIS IS CURIOUS.

00:41:07,160 --> 00:41:10,370
YOU HAVE A MUTABLE STRING, BUT, ALAS, THAT DOES

00:41:10,370 --> 00:41:13,910
NO MUTATION PRECISELY WHEN YOU START CALLING ITS

00:41:13,910 --> 00:41:18,160
STRING METHODS. WANTS TO LOWERCASE A WORD ENOUGH TO MAKE A

00:41:18,160 --> 00:41:21,590
COPY TO CALL LOWER ON, YOU'RE GOING TO HAVE TO

00:41:21,590 --> 00:41:25,220
DO SLICING GIVING YOU A COPY, CALL LOWER, MAKING

00:41:25,220 --> 00:41:27,730
ANOTHER COPY AND THEN ASSIGNMENT TO COPY IT A

00:41:27,730 --> 00:41:31,070
THIRD TIME BACK INTO THE DATA STRUCTURE IN ORDER

00:41:31,070 --> 00:41:35,530
TO GET THAT ACCOMPLISHED. THERE ISN'T, I LOOKED, THERE ISN'T A LOWER

00:41:35,530 --> 00:41:38,840
INTO AND AN UPPER INTO THAT WOULD LET YOU DO

00:41:38,840 --> 00:41:44,540
SMALLER-GRAINED MANIPULATION THAT IS WROTE DIRECTLY TO YOUR NEW BYTEARRAY.

00:41:44,540 --> 00:41:50,330
CAN THE MEMORY VIEW SAVE US, THOUGH? IT DID IN ALL THE PREVIOUS OCCASIONS.

00:41:50,330 --> 00:41:55,090
NO. BECAUSE MEMORY VIEWS DON'T DO ANYTHING

00:41:55,090 --> 00:41:58,290
STRING-LIKE. THE MOMENT YOU MOVE TO A MEMORY VIEW WHICH

00:41:58,290 --> 00:42:02,780
LETS YOU LOOK AT A PIECE OF STRING EFFICIENTLY,

00:42:02,780 --> 00:42:05,180
YOU'RE NOT GOING TO BE ABLE TO DO ANYTHING STRING-LIKE

00:42:05,180 --> 00:42:08,600
TO IT. SO YOU HAVE TO DO A ROUND-TRIP OUT TO A SMALLER

00:42:08,600 --> 00:42:14,810
STRING TO DO A MANIPULATION AND STORE DATA BACK.

00:42:14,810 --> 00:42:17,650
TO MUTATE A BYTEARRAY WITHOUT REWRITING ITS WHOLE

00:42:17,650 --> 00:42:21,450
CONTENT, YOU'RE GOING NEED INDICES. DO YOU REMEMBER INDEX EBBS?

00:42:21,450 --> 00:42:23,710
BACK THE FIRST WEEK BEFORE YOU FOUND STRIP, SPLIT

00:42:23,710 --> 00:42:30,220
AND JOIN, AND WERE DOING EVERYTHING LIKE THIS, YOU GET TO DO IT AGAIN IF YOU DECIDE TO TRY

00:42:30,220 --> 00:42:34,740
MUTATING A BYTEARRAY. THE BYTEARRAY WILL LET YOU ENJOY THOSE DAYS

00:42:34,740 --> 00:42:37,650
ALL OVER AGAIN BECAUSE ALL THE MUTATION OPERATIONS

00:42:37,650 --> 00:42:43,830
ARE POWERED ONLY BY INDICES. ONE HINT, REGULAR EXPRESSIONS, WHILE THEY

00:42:43,830 --> 00:42:46,170
TURNED OFF A LOT OF OTHER STRING-LIKE THINGS WERE

00:42:46,170 --> 00:42:49,840
LEFT TURNED ON AND DO WORK AGAINST BYTEARRAYS AND

00:42:49,840 --> 00:42:53,630
CAN HELP GIVE YOU SOME USEFUL INDICES TO USE.

00:42:53,630 --> 00:43:00,130
FREESTYLE MUTABLE STRING, IT'S AWKWARD. I HAVE HERE AT THE END OF THE SLIDES SOME

00:43:00,130 --> 00:43:04,510
LINKS TO OTHER DOCUMENTATION, INCLUDING THE BLOG

00:43:04,510 --> 00:43:06,680
POSTS THAT INSPIRED THIS TALK AND MAYBE WANT TO

00:43:06,680 --> 00:43:09,730
BRING EVERYTHING TOGETHER IN ONE PLACE AND IN

00:43:09,730 --> 00:43:16,220
CONCLUSION, THE BYTEARRAY, IT IS A VERY MEMORY-EFFICIENT, NOT FASTER BUT MEMORY-EFFICIENT

00:43:16,220 --> 00:43:20,570
STORE OF BYTE INTEGERS, SHOULD YOU EVER NEED THEM.

00:43:20,570 --> 00:43:23,061
IT CAN HELP CONTROL MEMORY IMPLEMENTATION WHEN

00:43:23,061 --> 00:43:26,250
DOING HIGH-PERFORMANCE IO BECAUSE YOU DON'T HAVE

00:43:26,250 --> 00:43:29,220
TO CREATE A NEW STRING BUT IT'S HARD TO MAKE IT

00:43:29,220 --> 00:43:32,230
FASTER IN A RELIABLE WAY. BE CAREFUL.

00:43:32,230 --> 00:43:35,160
IT'S A GREAT WAY TO ACCUMULATE DATA THAT'S COMING

00:43:35,160 --> 00:43:39,130
IN A PIECE AT A TIME. THAT'S ITS REAL SUPER POWER, AND EVEN THOUGH

00:43:39,130 --> 00:43:42,120
IT'S TEMPTING FOR STRING OPERATIONS, IT'S A BIT

00:43:42,120 --> 00:43:47,290
UNDERPOWERED AND A BIT AWKWARD. THAT'S WHAT I'VE LEARNED SO FAR.

00:43:47,290 --> 00:44:01,440
THANK YOU VERY MUCH. [ Applause ]

00:44:01,440 --> 00:44:08,000
>> WE ARE OUT OF TIME, SO I WILL MEET BYTEARRAY INTERESTED FANS OUTSIDE THE DOOR IN A FEW

00:44:08,000 --> 00:44:08,560

YouTube URL: https://www.youtube.com/watch?v=z9Hmys8ojno


