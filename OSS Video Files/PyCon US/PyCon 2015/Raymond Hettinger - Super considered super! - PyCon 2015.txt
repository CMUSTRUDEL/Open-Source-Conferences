Title: Raymond Hettinger - Super considered super! - PyCon 2015
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	"Speaker: Raymond Hettinger

Python's super() is well-designed and powerful, but it can be tricky to use if you don't know all the moves.

This talk offers clear, practical advice with real-world use cases on how to use super() effectively and not get tripped-up by common mistakes.


Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:07,340 --> 00:00:12,480
hi our last speaker for this session

00:00:09,780 --> 00:00:21,090
will be remand Ettinger with super

00:00:12,480 --> 00:00:27,240
considered super please welcome him how

00:00:21,090 --> 00:00:32,130
are you all doing how many of you read

00:00:27,240 --> 00:00:33,390
my blog post super considered super then

00:00:32,130 --> 00:00:35,489
why are you here or how come you're not

00:00:33,390 --> 00:00:37,950
over to David Beasley's talk or Titus

00:00:35,489 --> 00:00:40,379
Brown or now I will tell you some things

00:00:37,950 --> 00:00:42,270
that are not in that blog post I will

00:00:40,379 --> 00:00:44,100
tell you about how to use super for

00:00:42,270 --> 00:00:47,280
dependency injection which is one of its

00:00:44,100 --> 00:00:49,320
magic superpowers when my goals here is

00:00:47,280 --> 00:00:51,570
to make sure that you know what super

00:00:49,320 --> 00:00:53,280
really does that you have a good mental

00:00:51,570 --> 00:00:56,219
model for it I could give you a series

00:00:53,280 --> 00:00:57,750
of rules for using it well but I'm going

00:00:56,219 --> 00:00:59,789
to try an experiment I'm going to get

00:00:57,750 --> 00:01:04,199
three volunteers from the audience one

00:00:59,789 --> 00:01:05,850
of whom tried to unvoluntary and will

00:01:04,199 --> 00:01:08,549
conduct a little experiment up here and

00:01:05,850 --> 00:01:11,729
the experiment is if we work out

00:01:08,549 --> 00:01:13,680
visually what's a super does will you be

00:01:11,729 --> 00:01:16,439
able to remember it I believe the answer

00:01:13,680 --> 00:01:20,040
will be yes with a live demo of people

00:01:16,439 --> 00:01:22,170
as classes so well learn what super

00:01:20,040 --> 00:01:23,820
really does then we'll do some magic

00:01:22,170 --> 00:01:25,110
with it something that I'm sure none of

00:01:23,820 --> 00:01:27,360
you've ever done before

00:01:25,110 --> 00:01:29,640
a death-defying act we will use super

00:01:27,360 --> 00:01:32,450
for dependency injection how many of you

00:01:29,640 --> 00:01:37,439
even know what a dependency injection is

00:01:32,450 --> 00:01:42,689
who's ever used super for it I'm

00:01:37,439 --> 00:01:46,369
astonished that I even got one so that's

00:01:42,689 --> 00:01:48,990
new okay and then super is all was

00:01:46,369 --> 00:01:52,820
introduced for a particular reason which

00:01:48,990 --> 00:01:52,820
is cooperative multiple inheritance

00:01:54,560 --> 00:01:59,880
which is really a fantastic idea there's

00:01:57,360 --> 00:02:01,140
a lot of research behind it but when it

00:01:59,880 --> 00:02:04,920
started out in Python it wasn't

00:02:01,140 --> 00:02:07,979
particularly well documented so a person

00:02:04,920 --> 00:02:09,479
went and tried it out and they tried it

00:02:07,979 --> 00:02:11,039
one way and they tried it another and

00:02:09,479 --> 00:02:13,110
they tried it another way in every way

00:02:11,039 --> 00:02:13,890
they tried failed so they wrote a blog

00:02:13,110 --> 00:02:15,750
post

00:02:13,890 --> 00:02:19,110
were considered harmful how many of you

00:02:15,750 --> 00:02:20,490
read that then why are you here if you

00:02:19,110 --> 00:02:23,370
super is bad for you

00:02:20,490 --> 00:02:26,069
and I think the problem with that

00:02:23,370 --> 00:02:27,780
article was a person said I tried out

00:02:26,069 --> 00:02:29,640
several ways to use it and it didn't

00:02:27,780 --> 00:02:31,560
work therefore you shouldn't use it as

00:02:29,640 --> 00:02:33,570
opposed to what I believe is a correct

00:02:31,560 --> 00:02:35,490
perspective is are there some things I

00:02:33,570 --> 00:02:38,040
need to know in order to get it to work

00:02:35,490 --> 00:02:39,870
and do all of its magic and the answer

00:02:38,040 --> 00:02:41,640
is yes and I'll tell you what those

00:02:39,870 --> 00:02:44,910
three things are so that's what we're

00:02:41,640 --> 00:02:47,130
we're going to do here I'm taking a

00:02:44,910 --> 00:02:48,989
risky approach I have no slides I have

00:02:47,130 --> 00:02:51,390
live code and I'm going to run it on

00:02:48,989 --> 00:02:53,130
screen and we'll edit and modify some of

00:02:51,390 --> 00:02:56,160
the code for you what could possibly go

00:02:53,130 --> 00:02:57,480
wrong I'll also do it in Emacs what

00:02:56,160 --> 00:02:59,250
could possibly go wrong

00:02:57,480 --> 00:03:01,350
I'll get volunteers from the audience

00:02:59,250 --> 00:03:04,500
who I didn't know before today what

00:03:01,350 --> 00:03:06,540
could possibly go wrong but remember you

00:03:04,500 --> 00:03:09,360
can always go over to Beasley's okay all

00:03:06,540 --> 00:03:15,470
right all right so now you know and our

00:03:09,360 --> 00:03:18,420
goal is inheritance is really easy

00:03:15,470 --> 00:03:20,610
inheritance is a tool for code reuse the

00:03:18,420 --> 00:03:22,500
whole idea is there's code in some other

00:03:20,610 --> 00:03:25,860
class and instead of copying it into

00:03:22,500 --> 00:03:28,489
your class you want to reuse it so when

00:03:25,860 --> 00:03:31,049
one of your clients an object calls you

00:03:28,489 --> 00:03:33,090
you can either do the work yourself or

00:03:31,049 --> 00:03:36,360
you can hand it off to someone else and

00:03:33,090 --> 00:03:38,489
knows how to who knows how to do the

00:03:36,360 --> 00:03:40,470
work so somebody asked you what

00:03:38,489 --> 00:03:41,940
inheritance is for don't give a job I

00:03:40,470 --> 00:03:43,829
answer it doesn't have to do with

00:03:41,940 --> 00:03:45,720
abstract base classes or whatnot

00:03:43,829 --> 00:03:48,269
what's inheritance for it's a tool for

00:03:45,720 --> 00:03:50,430
code reuse it lets one class use the

00:03:48,269 --> 00:03:50,900
code in another class and how hard could

00:03:50,430 --> 00:03:54,120
that be

00:03:50,900 --> 00:03:56,790
not very hard I just going to ask

00:03:54,120 --> 00:04:00,660
somebody else to do the work if I ask if

00:03:56,790 --> 00:04:02,280
I'm a company and one of my customers

00:04:00,660 --> 00:04:03,750
calls me and orders a product I ship

00:04:02,280 --> 00:04:05,700
them a product do they presume that I

00:04:03,750 --> 00:04:08,700
did all of the work myself or could i

00:04:05,700 --> 00:04:11,670
subcontract big companies have

00:04:08,700 --> 00:04:15,359
subcontractors they have suppliers it's

00:04:11,670 --> 00:04:18,269
a supply chain visible to the customer

00:04:15,359 --> 00:04:22,169
or not traditionally the view of

00:04:18,269 --> 00:04:24,000
interfaces is no it's not visible I'm

00:04:22,169 --> 00:04:25,050
going to ask you to alter your worldview

00:04:24,000 --> 00:04:27,960
a little bit instead

00:04:25,050 --> 00:04:29,909
who the supplier of a company is that

00:04:27,960 --> 00:04:30,479
matters so let's say you have some

00:04:29,909 --> 00:04:33,750
company

00:04:30,479 --> 00:04:35,460
you hate let's say they have genetically

00:04:33,750 --> 00:04:38,789
modified seeds or something like that

00:04:35,460 --> 00:04:40,650
and you have a restaurant that you like

00:04:38,789 --> 00:04:43,020
and you find out they get their food

00:04:40,650 --> 00:04:46,680
from that restaurant does the supplier

00:04:43,020 --> 00:04:48,479
matter to you it does it's part of their

00:04:46,680 --> 00:04:50,699
chain so even though you're interfaith

00:04:48,479 --> 00:04:54,560
contract with them is I order some food

00:04:50,699 --> 00:04:57,449
from you you give me some food back and

00:04:54,560 --> 00:04:59,400
that's the full relationship but in fact

00:04:57,449 --> 00:05:01,110
there's another part of the API is who

00:04:59,400 --> 00:05:03,479
are your suppliers were you getting your

00:05:01,110 --> 00:05:05,580
your seeds from fair enough and so I'm

00:05:03,479 --> 00:05:08,370
going to treat that as part of the API a

00:05:05,580 --> 00:05:10,229
reprogrammable part of the API something

00:05:08,370 --> 00:05:11,490
to where we can do dependency injection

00:05:10,229 --> 00:05:14,340
to where you can go to your favorite

00:05:11,490 --> 00:05:16,770
restaurant and say I'd like to order my

00:05:14,340 --> 00:05:18,810
favorite food but get it from someplace

00:05:16,770 --> 00:05:22,169
else you see where we're going with this

00:05:18,810 --> 00:05:23,639
what is inheritance for it's so that one

00:05:22,169 --> 00:05:26,310
class can reuse the code from another

00:05:23,639 --> 00:05:31,409
class the supplier what's super going to

00:05:26,310 --> 00:05:33,690
label us to do retarget it so

00:05:31,409 --> 00:05:35,779
inheritance is easy one class uses

00:05:33,690 --> 00:05:38,580
another well I should put it another way

00:05:35,779 --> 00:05:40,770
single inheritance is easy whatever you

00:05:38,580 --> 00:05:42,659
get multiple inheritance it could get

00:05:40,770 --> 00:05:45,090
more complicated but doesn't have to

00:05:42,659 --> 00:05:47,550
what is the easiest way to do multiple

00:05:45,090 --> 00:05:48,810
inheritance and hear it from two

00:05:47,550 --> 00:05:51,419
different classes that don't have any

00:05:48,810 --> 00:05:52,229
overlapping methods that also works

00:05:51,419 --> 00:05:54,719
perfectly

00:05:52,229 --> 00:05:57,479
mixing classes I'll work that way and

00:05:54,719 --> 00:05:58,740
are fantastically useful is multiple

00:05:57,479 --> 00:06:02,039
inheritance easy when there's no

00:05:58,740 --> 00:06:05,699
overlaps yep and inheritance is a tool

00:06:02,039 --> 00:06:08,430
for what code reuse okay I think you get

00:06:05,699 --> 00:06:11,240
the gist so multiple inheritance is easy

00:06:08,430 --> 00:06:13,620
single inheritance is easy what's hard

00:06:11,240 --> 00:06:15,990
what if you have multiple inheritance

00:06:13,620 --> 00:06:17,819
and there's a diamond diagram and same

00:06:15,990 --> 00:06:20,400
methods are repeated on either side of

00:06:17,819 --> 00:06:23,430
the chain then it gets harder how much

00:06:20,400 --> 00:06:26,449
harder it took a long long time for

00:06:23,430 --> 00:06:29,719
computer science to work this out and

00:06:26,449 --> 00:06:32,819
when they came up with it they have a

00:06:29,719 --> 00:06:34,770
proof that it is the optimum in best

00:06:32,819 --> 00:06:36,110
solution to this problem it's a C cubed

00:06:34,770 --> 00:06:40,400
linearization algorithm

00:06:36,110 --> 00:06:42,289
what is linearization mean make a line

00:06:40,400 --> 00:06:46,189
out of are you guys all sitting in a

00:06:42,289 --> 00:06:49,370
line now you're sitting in a big blob of

00:06:46,189 --> 00:06:51,379
rectangle of a mob but if I were to

00:06:49,370 --> 00:06:54,020
linearize you then you would be in a

00:06:51,379 --> 00:06:56,090
line why would i need to linearize you

00:06:54,020 --> 00:06:58,069
because I have a goal after this talk

00:06:56,090 --> 00:07:00,139
I'm going to go shake everybody's hand I

00:06:58,069 --> 00:07:03,050
can't do it all simultaneously so do I

00:07:00,139 --> 00:07:05,449
have to do it one at a time yep so I

00:07:03,050 --> 00:07:07,550
need to linearize you the C cube

00:07:05,449 --> 00:07:10,009
linearization algorithm is a way of

00:07:07,550 --> 00:07:12,050
taking this bla amorphous blob and

00:07:10,009 --> 00:07:13,520
putting it in a straight line one calls

00:07:12,050 --> 00:07:16,639
the other calls the other calls the

00:07:13,520 --> 00:07:20,569
other what is our biggest problem with

00:07:16,639 --> 00:07:22,490
super in a Python it's not its design

00:07:20,569 --> 00:07:23,389
its design I think is flawless it's

00:07:22,490 --> 00:07:25,430
beautiful

00:07:23,389 --> 00:07:28,009
cuido did an extraordinary job with it

00:07:25,430 --> 00:07:31,759
the problem is the name it should have

00:07:28,009 --> 00:07:33,860
been called super why not the answer is

00:07:31,759 --> 00:07:35,779
if you've learned super in any other

00:07:33,860 --> 00:07:39,139
language it doesn't do the same as

00:07:35,779 --> 00:07:46,580
Python so let me run my survey here how

00:07:39,139 --> 00:07:48,289
many of you use Java C++ small talk how

00:07:46,580 --> 00:07:52,699
many views any language that has super

00:07:48,289 --> 00:07:54,800
init how many of you realize that Python

00:07:52,699 --> 00:07:57,349
super is not like that at all what is

00:07:54,800 --> 00:07:59,449
super in every other language is not

00:07:57,349 --> 00:08:02,029
Python super what does it do in other

00:07:59,449 --> 00:08:04,639
languages in other language is it calls

00:08:02,029 --> 00:08:08,690
your parents and single inheritance it's

00:08:04,639 --> 00:08:12,889
easy hey Dad can I use a car multiple

00:08:08,690 --> 00:08:16,009
inheritance it's also easy dad can use a

00:08:12,889 --> 00:08:16,900
cart no mom can I have the car easy

00:08:16,009 --> 00:08:19,639
enough

00:08:16,900 --> 00:08:21,289
inheritance whenever you call super is

00:08:19,639 --> 00:08:24,680
about calling your parents

00:08:21,289 --> 00:08:27,440
but pythons does something different it

00:08:24,680 --> 00:08:30,620
does call parents but not your parents

00:08:27,440 --> 00:08:34,099
when you call super whose parents get

00:08:30,620 --> 00:08:37,750
called it is not your ancestors it's

00:08:34,099 --> 00:08:42,289
your children's ancestors so here's my

00:08:37,750 --> 00:08:44,000
family tree I've got our Raymond and our

00:08:42,289 --> 00:08:48,410
Ramon and Gail

00:08:44,000 --> 00:08:51,889
my parents my wife Dennis and Sharon are

00:08:48,410 --> 00:08:54,500
over Rachel her parents but while Rachel

00:08:51,889 --> 00:08:56,360
and I have a child Matthew so Matthew

00:08:54,500 --> 00:08:59,300
has a bigger family tree than we do

00:08:56,360 --> 00:09:02,089
it turns out all of our odd Matthews

00:08:59,300 --> 00:09:04,970
grandparents are descended from Adam and

00:09:02,089 --> 00:09:07,399
Eve I put those names in just to make it

00:09:04,970 --> 00:09:09,829
a diamond diagram so it spreads out and

00:09:07,399 --> 00:09:12,170
it comes back up at which point you have

00:09:09,829 --> 00:09:15,290
a non-trivial multiple inheritance our

00:09:12,170 --> 00:09:16,759
problem so that's our family tree you

00:09:15,290 --> 00:09:18,350
want to go talk to everybody in the

00:09:16,759 --> 00:09:22,250
family one at a time what do you have to

00:09:18,350 --> 00:09:25,220
do to The Blob linearize that which

00:09:22,250 --> 00:09:27,470
means make a line out of and that's what

00:09:25,220 --> 00:09:32,170
the MRO does the method resolution

00:09:27,470 --> 00:09:35,089
algorithm so let me turn on that code

00:09:32,170 --> 00:09:37,730
and one of the nice things about help is

00:09:35,089 --> 00:09:39,589
it shows the method resolution order it

00:09:37,730 --> 00:09:43,189
says if you have an instance of Matthew

00:09:39,589 --> 00:09:47,389
you start with Matthew if Matt how when

00:09:43,189 --> 00:09:50,750
Matthew call super it calls me when I

00:09:47,389 --> 00:09:52,550
call super it calls my dad but then

00:09:50,750 --> 00:09:56,569
something interesting happens when you

00:09:52,550 --> 00:09:58,610
call super on Ramon it doesn't go to his

00:09:56,569 --> 00:10:02,629
parent remember his parent is he's

00:09:58,610 --> 00:10:04,339
descended directly from Adam it calls

00:10:02,629 --> 00:10:06,889
out to the side which is kind of

00:10:04,339 --> 00:10:10,970
interesting because my father is about

00:10:06,889 --> 00:10:12,649
10 years older than his wife and so that

00:10:10,970 --> 00:10:14,899
means that when he was born

00:10:12,649 --> 00:10:18,860
his super call went somewhere else were

00:10:14,899 --> 00:10:20,449
other than where it goes now so he is

00:10:18,860 --> 00:10:23,000
super call where it went

00:10:20,449 --> 00:10:25,910
has changed over time what is it that

00:10:23,000 --> 00:10:29,269
changed it when he was born none of the

00:10:25,910 --> 00:10:31,040
rest of the people on here existed so if

00:10:29,269 --> 00:10:33,199
you looked at his super code you might

00:10:31,040 --> 00:10:35,930
think it called his parents Adam and Eve

00:10:33,199 --> 00:10:38,600
and in fact if he was the starting point

00:10:35,930 --> 00:10:41,209
yes but now that Matthew was born

00:10:38,600 --> 00:10:44,689
it's Matthew's inheritance tree that

00:10:41,209 --> 00:10:46,370
matters not his so when he calls super

00:10:44,689 --> 00:10:48,740
it doesn't call his parents

00:10:46,370 --> 00:10:51,230
it calls one of Matthew's ancestors in

00:10:48,740 --> 00:10:53,449
exactly this order so this is kind of

00:10:51,230 --> 00:10:54,490
shocking that means whenever you use

00:10:53,449 --> 00:10:56,980
super

00:10:54,490 --> 00:11:00,540
can't know in advance where it's going

00:10:56,980 --> 00:11:03,399
to call to learn something new

00:11:00,540 --> 00:11:05,200
super coals your parents right know it

00:11:03,399 --> 00:11:05,860
may call somebody who hasn't even been

00:11:05,200 --> 00:11:09,310
born yet

00:11:05,860 --> 00:11:10,959
Ramon super calls Gail now Gail's is

00:11:09,310 --> 00:11:12,760
kind of interesting because her super

00:11:10,959 --> 00:11:15,790
calls Rachel and Rachel is far younger

00:11:12,760 --> 00:11:18,010
than Gail Rachel goes to her parents who

00:11:15,790 --> 00:11:22,270
then call Adam and Eve and that is the

00:11:18,010 --> 00:11:23,709
MRO the method a resolution order the

00:11:22,270 --> 00:11:26,200
most important thing you learn so far

00:11:23,709 --> 00:11:28,740
linearization means to make a line out

00:11:26,200 --> 00:11:33,040
of it decide it is what order to visit

00:11:28,740 --> 00:11:34,390
everybody had what is Python superdude

00:11:33,040 --> 00:11:37,630
does it call your parents

00:11:34,390 --> 00:11:39,220
no it calls the parents or ancestors of

00:11:37,630 --> 00:11:40,860
your children if you've learned that

00:11:39,220 --> 00:11:44,230
much you know a great deal about a

00:11:40,860 --> 00:11:46,450
Python super now so what should it had

00:11:44,230 --> 00:11:49,089
been called well given that we've taken

00:11:46,450 --> 00:11:52,209
this diamond diagram and turned it into

00:11:49,089 --> 00:11:53,770
a line the line down here what super

00:11:52,209 --> 00:11:58,690
really should have been called is the

00:11:53,770 --> 00:12:01,029
next in line so Ramon what he called

00:11:58,690 --> 00:12:02,620
super it's not really super it's the

00:12:01,029 --> 00:12:08,050
next one in the line who's the next

00:12:02,620 --> 00:12:11,350
person in the line after Ramon don't

00:12:08,050 --> 00:12:13,390
leave me all alone up here alright yeah

00:12:11,350 --> 00:12:15,550
the next in the line after Ramona's Gail

00:12:13,390 --> 00:12:17,770
it's not about calling parents it's got

00:12:15,550 --> 00:12:21,040
the next in Matthews line to super mean

00:12:17,770 --> 00:12:23,470
next in line if you've got that then

00:12:21,040 --> 00:12:25,390
you're in wonderful shape so where do we

00:12:23,470 --> 00:12:28,240
get all of the awesomeness from and

00:12:25,390 --> 00:12:31,240
super one way is that this line gets

00:12:28,240 --> 00:12:34,390
computed automatically another way that

00:12:31,240 --> 00:12:36,640
super is awesome is it is the youngest

00:12:34,390 --> 00:12:39,040
person in the chain Matthew that

00:12:36,640 --> 00:12:41,110
determines what the line is and you

00:12:39,040 --> 00:12:43,180
can't know in advance where your super

00:12:41,110 --> 00:12:45,370
is going to go this is a good thing

00:12:43,180 --> 00:12:48,220
because it means your children get to

00:12:45,370 --> 00:12:50,260
change where it goes after all you guys

00:12:48,220 --> 00:12:52,839
didn't like the supplier of the food at

00:12:50,260 --> 00:12:55,390
the restaurant you went to maybe you can

00:12:52,839 --> 00:12:57,100
subclass the restaurant and change its

00:12:55,390 --> 00:12:59,980
order without breaking its interface

00:12:57,100 --> 00:13:02,870
what you like to see that in action okay

00:12:59,980 --> 00:13:09,200
we're about to uncork a

00:13:02,870 --> 00:13:11,029
you can of super whoop-ass here we go we

00:13:09,200 --> 00:13:15,740
got a dough factory and the dough

00:13:11,029 --> 00:13:19,220
factory has get dough we have a class

00:13:15,740 --> 00:13:21,800
Pizza and it only has one method order

00:13:19,220 --> 00:13:23,300
pizza and you all call in and order some

00:13:21,800 --> 00:13:26,600
toppings it prints it's getting some

00:13:23,300 --> 00:13:30,170
dough it makes some dough and drives off

00:13:26,600 --> 00:13:32,960
originally when this beats of her

00:13:30,170 --> 00:13:36,650
company was first formed it made its own

00:13:32,960 --> 00:13:40,010
dough but later it turned out other

00:13:36,650 --> 00:13:41,870
things needed dough as well what is a

00:13:40,010 --> 00:13:45,950
really good tool for code reuse when it

00:13:41,870 --> 00:13:48,310
comes to classes that's right it starts

00:13:45,950 --> 00:13:51,410
with an in here and ends with an intense

00:13:48,310 --> 00:13:53,180
right so what do we do at that point we

00:13:51,410 --> 00:13:55,160
take the code for getting dough and we

00:13:53,180 --> 00:13:57,860
pull it out to a parent class remember

00:13:55,160 --> 00:14:01,850
inheritance as a tool for code reuse so

00:13:57,860 --> 00:14:03,920
lots of other classes can go to this

00:14:01,850 --> 00:14:06,050
dough Factory and get their dough have

00:14:03,920 --> 00:14:09,050
we improved the code yes because we've

00:14:06,050 --> 00:14:12,290
eliminated redundancy the problem is

00:14:09,050 --> 00:14:15,560
this dough factory is hardware and if we

00:14:12,290 --> 00:14:17,060
change the name of the dough factory if

00:14:15,560 --> 00:14:18,709
we try to choose a different dough

00:14:17,060 --> 00:14:19,520
factory right here we have to change it

00:14:18,709 --> 00:14:23,660
in two places

00:14:19,520 --> 00:14:26,060
what what does dry stand for do not

00:14:23,660 --> 00:14:29,560
repeat yourself if I have to say it

00:14:26,060 --> 00:14:29,560
twice here am i repeating myself

00:14:31,840 --> 00:14:36,160
how you all know that's right there must

00:14:34,270 --> 00:14:44,230
be a better way and the better way is

00:14:36,160 --> 00:14:46,890
this never dude life coding I don't even

00:14:44,230 --> 00:14:46,890
see my cursor

00:14:47,999 --> 00:14:55,199
how is this possible okay oh it wants to

00:14:52,199 --> 00:14:55,829
know if it's changed on disk how is this

00:14:55,199 --> 00:15:02,720
possible

00:14:55,829 --> 00:15:05,129
I don't know what does he max stand for

00:15:02,720 --> 00:15:14,159
exclusively used by middle-aged computer

00:15:05,129 --> 00:15:17,279
scientists all right super in what way

00:15:14,159 --> 00:15:19,439
is the code better now the way that the

00:15:17,279 --> 00:15:21,689
code is better now is simply that we

00:15:19,439 --> 00:15:24,949
didn't mentioned olfactory twice so if I

00:15:21,689 --> 00:15:27,419
change to a different dough for a here

00:15:24,949 --> 00:15:29,999
super will automatically be aware of it

00:15:27,419 --> 00:15:31,109
that reduced redundancy in our code and

00:15:29,999 --> 00:15:33,989
makes it awesome

00:15:31,109 --> 00:15:35,220
didn't I mention super a super but I

00:15:33,989 --> 00:15:36,599
know what you're thinking that's the

00:15:35,220 --> 00:15:38,789
same way you would use it in every other

00:15:36,599 --> 00:15:41,939
language that has super and in fact you

00:15:38,789 --> 00:15:44,429
would yet you got a magic power whether

00:15:41,939 --> 00:15:46,819
you knew it or not what let's look in

00:15:44,429 --> 00:15:50,989
detail at what's actually happening here

00:15:46,819 --> 00:15:54,659
yes I want to save I will go run our

00:15:50,989 --> 00:15:57,629
pizza factory and what does it do it

00:15:54,659 --> 00:15:59,789
goes to a get dough that's the first

00:15:57,629 --> 00:16:02,699
step in making a pizza and it calls

00:15:59,789 --> 00:16:05,009
super and it goes to the dough Factory

00:16:02,699 --> 00:16:07,319
gets the dough and now we're making a

00:16:05,009 --> 00:16:09,539
pile with some insecticide-treated wheat

00:16:07,319 --> 00:16:12,839
dough you guys want some insecticide on

00:16:09,539 --> 00:16:14,759
your pizza right okay and we've got

00:16:12,839 --> 00:16:20,099
pepperoni and bell pepper two things

00:16:14,759 --> 00:16:22,259
good for you one of them not how did it

00:16:20,099 --> 00:16:24,720
work it called its parent to do the work

00:16:22,259 --> 00:16:28,379
can we see what it's method resolution

00:16:24,720 --> 00:16:30,809
in order is sure this is a simple linear

00:16:28,379 --> 00:16:36,659
inheritance so we could just run help on

00:16:30,809 --> 00:16:39,389
the pizza class and see the order is we

00:16:36,659 --> 00:16:41,549
search search the pizza for get dough

00:16:39,389 --> 00:16:44,669
and when we don't find it we fall back

00:16:41,549 --> 00:16:49,439
onto dough factory easy peasy

00:16:44,669 --> 00:16:51,629
any questions on that I hope not that's

00:16:49,439 --> 00:16:54,509
pretty easy there's only one problem

00:16:51,629 --> 00:16:57,299
with our program and that's the kind of

00:16:54,509 --> 00:16:58,780
people pizza it makes is treated with

00:16:57,299 --> 00:17:03,670
insecticide and

00:16:58,780 --> 00:17:10,060
you're all thinking there is there's

00:17:03,670 --> 00:17:11,230
another dough factory in town it's the

00:17:10,060 --> 00:17:14,860
thing I like about the Mack the whole

00:17:11,230 --> 00:17:17,860
zooming in it's an organic dough factory

00:17:14,860 --> 00:17:21,100
in fact it was a subsidiary I mean a

00:17:17,860 --> 00:17:23,020
subclass of the organ of the regular

00:17:21,100 --> 00:17:26,110
dough Factory and this one gives you

00:17:23,020 --> 00:17:30,130
pure untreated wheat dough with no

00:17:26,110 --> 00:17:33,010
insecticides good for you here's your

00:17:30,130 --> 00:17:35,320
problem your problem is over here in

00:17:33,010 --> 00:17:39,430
this class the dough factory is

00:17:35,320 --> 00:17:41,920
hardwired or is it it's not hardwired

00:17:39,430 --> 00:17:44,710
what the magic property of super in

00:17:41,920 --> 00:17:47,290
Python is the inheritance chain was not

00:17:44,710 --> 00:17:49,620
determined by Pizza the inheritance

00:17:47,290 --> 00:17:53,560
chain is determined by your children

00:17:49,620 --> 00:17:55,930
Matthew is the one who caused my my

00:17:53,560 --> 00:17:58,420
father to call out to the side to his

00:17:55,930 --> 00:18:01,390
wife instead of up to his parents so

00:17:58,420 --> 00:18:04,720
what we'd like to do is make a child of

00:18:01,390 --> 00:18:08,470
Pizza a subclass of Pizza that injects

00:18:04,720 --> 00:18:11,170
in between the pizza place and its

00:18:08,470 --> 00:18:14,200
supplier a new supplier in the chain and

00:18:11,170 --> 00:18:16,420
it's amazingly easy to do this is

00:18:14,200 --> 00:18:18,910
dependency injection with nothing up my

00:18:16,420 --> 00:18:21,280
sleeves without changing any of the code

00:18:18,910 --> 00:18:28,360
on the left side I will magically

00:18:21,280 --> 00:18:31,570
improve our pizza all we do is make an

00:18:28,360 --> 00:18:34,990
empty class and organic pizza is that a

00:18:31,570 --> 00:18:38,140
subclass of Pizza sure it is is it also

00:18:34,990 --> 00:18:39,820
a subclass of organic dough factory yes

00:18:38,140 --> 00:18:42,190
in the linearization algorithm

00:18:39,820 --> 00:18:44,950
guarantees that the organic dough

00:18:42,190 --> 00:18:47,560
factory will go before the pizza factory

00:18:44,950 --> 00:18:51,400
which is kind of Awesome so now I'll go

00:18:47,560 --> 00:18:53,920
order it with anchovies and without

00:18:51,400 --> 00:18:56,290
having change the order pizza notice

00:18:53,920 --> 00:18:59,400
that we now get pure untreated wheat

00:18:56,290 --> 00:19:03,520
dough who thinks that's awesome

00:18:59,400 --> 00:19:06,280
you can take anybody who has a supplier

00:19:03,520 --> 00:19:09,720
and the advertiser suppliers part of

00:19:06,280 --> 00:19:11,940
their API it's not actually hardwired

00:19:09,720 --> 00:19:14,310
inheritance chain it is telling you what

00:19:11,940 --> 00:19:16,070
the default supplier is unless you tell

00:19:14,310 --> 00:19:19,650
me any different I'll be giving you

00:19:16,070 --> 00:19:21,930
insecticide dough but if you tell me

00:19:19,650 --> 00:19:25,800
differently I'll go check the organic

00:19:21,930 --> 00:19:28,850
Godot Factory first this is awesome it's

00:19:25,800 --> 00:19:31,590
a magic power of super and I have not

00:19:28,850 --> 00:19:36,330
seen that in many other places who

00:19:31,590 --> 00:19:38,670
learned something new today it so are

00:19:36,330 --> 00:19:44,640
any of you even slightly unsettled by

00:19:38,670 --> 00:19:47,670
this why the reason you're unsettled by

00:19:44,640 --> 00:19:50,700
it is firstly is this fragile no it's

00:19:47,670 --> 00:19:53,010
deterministic there are precise rules

00:19:50,700 --> 00:19:57,030
that tell you when you make this

00:19:53,010 --> 00:19:59,670
subclass what order you'll sort it part

00:19:57,030 --> 00:20:02,850
of the default supplier chain is

00:19:59,670 --> 00:20:04,980
documented to be Gaudio factory and you

00:20:02,850 --> 00:20:07,470
are allowed to change the order he does

00:20:04,980 --> 00:20:09,240
this by design it's not an accident of

00:20:07,470 --> 00:20:12,150
super that it does this it's an on

00:20:09,240 --> 00:20:14,640
purpose the whole C cube algorithm was

00:20:12,150 --> 00:20:17,670
designed so you could do stuff exactly

00:20:14,640 --> 00:20:18,390
like this is it a accident or an on

00:20:17,670 --> 00:20:21,510
purpose

00:20:18,390 --> 00:20:24,180
so on purpose the only problem with this

00:20:21,510 --> 00:20:26,040
example well the good part of this

00:20:24,180 --> 00:20:29,700
example is I think everyone understands

00:20:26,040 --> 00:20:31,890
it the bad part of the example is that

00:20:29,700 --> 00:20:38,810
it's not compelling should we do

00:20:31,890 --> 00:20:42,300
something more interesting with it robot

00:20:38,810 --> 00:20:44,520
there now who's got the coolest

00:20:42,300 --> 00:20:47,450
presentation me or Beasley Beasley does

00:20:44,520 --> 00:20:47,450
have robots over there

00:20:49,720 --> 00:20:53,960
because his talk is on concurrency so I

00:20:52,370 --> 00:20:57,460
presume he's giving his talk and

00:20:53,960 --> 00:21:00,620
listening in this room at the same time

00:20:57,460 --> 00:21:02,900
all right so we've got this robot I

00:21:00,620 --> 00:21:05,240
didn't build it I bought it so I don't

00:21:02,900 --> 00:21:07,970
actually have control over the source

00:21:05,240 --> 00:21:10,250
code for this robot given a tool it can

00:21:07,970 --> 00:21:11,870
go fetch it it can move it forward it

00:21:10,250 --> 00:21:14,780
can move it back in and it can replace

00:21:11,870 --> 00:21:18,350
it back from wherever it uh got it from

00:21:14,780 --> 00:21:20,990
I just got prints in here but the actual

00:21:18,350 --> 00:21:23,750
robot moves every time you make one of

00:21:20,990 --> 00:21:25,790
these calls which is unfortunate because

00:21:23,750 --> 00:21:27,980
that robot is rather fragile and it

00:21:25,790 --> 00:21:29,900
wears down easily if you make too many

00:21:27,980 --> 00:21:31,250
calls with it that are unnecessarily

00:21:29,900 --> 00:21:32,870
you're going to wear out your poor

00:21:31,250 --> 00:21:34,970
little robot and you wouldn't want a

00:21:32,870 --> 00:21:38,300
worn-out robot would you no that would

00:21:34,970 --> 00:21:40,670
be a terrible thing so how do you

00:21:38,300 --> 00:21:44,840
specialize your robot it's a fairly easy

00:21:40,670 --> 00:21:48,230
thing you subclass it subclassing is

00:21:44,840 --> 00:21:50,360
used to specialized and so our extend

00:21:48,230 --> 00:21:53,510
we're going to extend the robot by

00:21:50,360 --> 00:21:55,940
adding a new method clean and what clean

00:21:53,510 --> 00:21:57,890
does is take advantage of the parent

00:21:55,940 --> 00:22:00,860
methods and we're programming the robot

00:21:57,890 --> 00:22:03,020
to use something useful this is not a

00:22:00,860 --> 00:22:05,780
toy example this is a proper way to use

00:22:03,020 --> 00:22:08,180
subclassing a parent provides a toolkit

00:22:05,780 --> 00:22:10,430
and then the child exercises that

00:22:08,180 --> 00:22:13,190
toolkit in some complex way it makes

00:22:10,430 --> 00:22:16,510
this robot programmable which is kind of

00:22:13,190 --> 00:22:20,060
cool we use Super which is kind of nice

00:22:16,510 --> 00:22:21,950
what does this do to clean something you

00:22:20,060 --> 00:22:23,540
fetch the tool you move it forward and

00:22:21,950 --> 00:22:25,670
backward a certain number of times and

00:22:23,540 --> 00:22:29,060
then you put the tool back in particular

00:22:25,670 --> 00:22:30,830
I'm going to use a a broom and I think

00:22:29,060 --> 00:22:35,510
you would be rather unsurprised at the

00:22:30,830 --> 00:22:37,640
outcome what did it do well it went and

00:22:35,510 --> 00:22:38,900
picked fetched a broom it moved it

00:22:37,640 --> 00:22:41,510
forward and backward forward and

00:22:38,900 --> 00:22:44,570
backward it swept and it replaced is

00:22:41,510 --> 00:22:46,160
that pretty darn useful a sweeping robot

00:22:44,570 --> 00:22:50,180
I bet no one's ever thought of that

00:22:46,160 --> 00:22:51,710
before Roomba and how did they design it

00:22:50,180 --> 00:22:55,360
they made a general-purpose robot and

00:22:51,710 --> 00:22:57,200
then they just subclassed it easy-peasy

00:22:55,360 --> 00:22:59,869
so I write this little routine

00:22:57,200 --> 00:23:02,460
specialize my robot should I test it

00:22:59,869 --> 00:23:04,320
yeah testing is a good thing but if I

00:23:02,460 --> 00:23:07,110
run a test on the actual robot I'm going

00:23:04,320 --> 00:23:09,360
to wear it out what can you do well I

00:23:07,110 --> 00:23:11,999
want to call this method but I don't

00:23:09,360 --> 00:23:14,580
want the real robot to be called what

00:23:11,999 --> 00:23:16,590
I'd like to do is I'll have a mock robot

00:23:14,580 --> 00:23:18,419
call because my goal is to test the

00:23:16,590 --> 00:23:21,629
clean method not to test the robot

00:23:18,419 --> 00:23:24,480
itself but it looks like this

00:23:21,629 --> 00:23:28,169
relationship is hard word cleaning

00:23:24,480 --> 00:23:31,230
robots are robots we say is a not has a

00:23:28,169 --> 00:23:32,789
cleaning robot is a robot and now I

00:23:31,230 --> 00:23:35,929
don't want it to actually is a be a

00:23:32,789 --> 00:23:43,470
robot I want it to be a is a mop bot and

00:23:35,929 --> 00:23:47,429
so we'll mock up our robot so let me put

00:23:43,470 --> 00:23:51,179
the bots side-by-side both of these the

00:23:47,429 --> 00:23:53,669
mock bots in the real bot have exactly

00:23:51,179 --> 00:23:55,200
the same methods but what the mod bot

00:23:53,669 --> 00:23:57,179
does is it doesn't actually do a

00:23:55,200 --> 00:23:58,950
physical movement all it does is record

00:23:57,179 --> 00:24:01,529
all of the calls that are made to it it

00:23:58,950 --> 00:24:03,450
appends it to a list of tasks you can

00:24:01,529 --> 00:24:06,330
call the mock but as much as you want

00:24:03,450 --> 00:24:09,509
and it won't wear out all we need to do

00:24:06,330 --> 00:24:11,519
is go edit this code and force it is to

00:24:09,509 --> 00:24:13,679
temporarily edit the code make it use a

00:24:11,519 --> 00:24:20,820
mock bot and then switch it back good

00:24:13,679 --> 00:24:23,970
idea about idea bad idea there is and it

00:24:20,820 --> 00:24:26,909
only takes one line of code a macht

00:24:23,970 --> 00:24:29,850
cleaning robot it inherits from robot

00:24:26,909 --> 00:24:32,820
and it inherits from Mokpo we are

00:24:29,850 --> 00:24:36,539
guaranteed by the linearization rules

00:24:32,820 --> 00:24:39,899
that anytime our cleaning robot calls

00:24:36,539 --> 00:24:42,480
its supplier of robotic services that it

00:24:39,899 --> 00:24:45,330
will check for mock BOTS before it takes

00:24:42,480 --> 00:24:48,289
the actual robot and so I can write a

00:24:45,330 --> 00:24:52,470
proper normal unit tests to test clean

00:24:48,289 --> 00:24:55,139
if I had this test the cleaning robot a

00:24:52,470 --> 00:24:56,789
real robot would be doing the physical

00:24:55,139 --> 00:24:59,129
movements as it did on the left of

00:24:56,789 --> 00:25:01,470
course wearing it out but with my mock

00:24:59,129 --> 00:25:04,980
cleaning robot I can go tell it to clean

00:25:01,470 --> 00:25:06,929
with a mop and then I can expect that it

00:25:04,980 --> 00:25:12,080
gets this output let's check it out

00:25:06,929 --> 00:25:14,570
I got a dot very satisfying

00:25:12,080 --> 00:25:19,640
what did you achieve it work today that

00:25:14,570 --> 00:25:21,559
dot your friends don't typically

00:25:19,640 --> 00:25:26,179
understand how satisfying it is to get a

00:25:21,559 --> 00:25:28,789
dot thank you I saw that one the last

00:25:26,179 --> 00:25:31,010
talk I ignored my timekeeper and they

00:25:28,789 --> 00:25:34,340
big hook came off they drugged me off of

00:25:31,010 --> 00:25:36,740
a stage much to the amusement of my

00:25:34,340 --> 00:25:40,010
audience all right

00:25:36,740 --> 00:25:42,169
so how did this work well very simply it

00:25:40,010 --> 00:25:45,649
injected itself into the chain run this

00:25:42,169 --> 00:25:49,870
in an interactive mode what version of

00:25:45,649 --> 00:25:50,990
Python am i using here three-point way

00:25:49,870 --> 00:25:56,659
uh-huh

00:25:50,990 --> 00:26:02,559
you don't have one of those see here all

00:25:56,659 --> 00:26:09,590
right and let's do help on the mocked

00:26:02,559 --> 00:26:11,990
cleaning robot and what I'm looking for

00:26:09,590 --> 00:26:14,210
is the mock cleaning robot resolution

00:26:11,990 --> 00:26:17,000
order which says it's going to go check

00:26:14,210 --> 00:26:23,330
for cleaning robot what will it find in

00:26:17,000 --> 00:26:26,090
cleaning robot there it's going to find

00:26:23,330 --> 00:26:29,360
a clean method but if you call some

00:26:26,090 --> 00:26:31,970
method on it like a fetch where does it

00:26:29,360 --> 00:26:34,309
look next the meaning of super is next

00:26:31,970 --> 00:26:36,769
in the MRO the next in the line and the

00:26:34,309 --> 00:26:39,289
next in the line is the mock by a head

00:26:36,769 --> 00:26:40,130
of the real robot so the mock robot gets

00:26:39,289 --> 00:26:43,730
called first

00:26:40,130 --> 00:26:47,240
this is dependency injection it's easy

00:26:43,730 --> 00:26:50,510
to do it's one line of code make a mock

00:26:47,240 --> 00:26:52,610
Klaus inject it just with this there's

00:26:50,510 --> 00:26:54,889
nothing fragile about it it's guaranteed

00:26:52,610 --> 00:26:56,720
behavior it's what it was designed for

00:26:54,889 --> 00:27:00,320
how many of you have you learned

00:26:56,720 --> 00:27:02,000
something new my work is done I could

00:27:00,320 --> 00:27:04,250
get off the stage right now and just

00:27:02,000 --> 00:27:09,350
declare victory that would be the smart

00:27:04,250 --> 00:27:11,809
play but hey I've already risk using

00:27:09,350 --> 00:27:15,049
Emacs on stage what could possibly go

00:27:11,809 --> 00:27:17,210
wrong if I just keep on talking I know

00:27:15,049 --> 00:27:19,940
you're thinking these are all contrived

00:27:17,210 --> 00:27:21,169
glasses why don't we try something from

00:27:19,940 --> 00:27:24,049
the standard library

00:27:21,169 --> 00:27:26,650
we've got counters in the collections

00:27:24,049 --> 00:27:29,540
module what our counters get for

00:27:26,650 --> 00:27:30,110
counting things they are a subclass of

00:27:29,540 --> 00:27:31,730
dict

00:27:30,110 --> 00:27:34,429
is addicted ordered collection or an

00:27:31,730 --> 00:27:37,130
unordered collection unordered

00:27:34,429 --> 00:27:39,320
collection so we're going to get counts

00:27:37,130 --> 00:27:40,790
but they're going to be scrambled what

00:27:39,320 --> 00:27:43,550
else do we have in the collections

00:27:40,790 --> 00:27:44,450
module that remembers order order

00:27:43,550 --> 00:27:46,520
dictionaries

00:27:44,450 --> 00:27:49,130
that's fantastic they remember the order

00:27:46,520 --> 00:27:53,600
that's a wonderful thing to order dicks

00:27:49,130 --> 00:27:55,790
count they don't so you've got a devil

00:27:53,600 --> 00:27:57,559
choice you can have your order or your

00:27:55,790 --> 00:28:05,020
counting but you can't have them both or

00:27:57,559 --> 00:28:05,020
can you there is it's quite simple I

00:28:06,700 --> 00:28:13,910
counted too hard an word counter how do

00:28:11,630 --> 00:28:16,040
you make one of them it's actually only

00:28:13,910 --> 00:28:19,460
this line that makes the ordered counter

00:28:16,040 --> 00:28:22,010
I inherit from counter and ordered it I

00:28:19,460 --> 00:28:24,440
am guaranteeing a particular order of

00:28:22,010 --> 00:28:27,320
calls where the underlying dictionary

00:28:24,440 --> 00:28:30,740
comes last so when the counter uses its

00:28:27,320 --> 00:28:32,990
default supplier of mapping services its

00:28:30,740 --> 00:28:34,400
default supplier for mapping services is

00:28:32,990 --> 00:28:36,410
dead which is unordered

00:28:34,400 --> 00:28:38,840
we're telling it to use another supplier

00:28:36,410 --> 00:28:41,750
ordered it and it's a remarkably easy

00:28:38,840 --> 00:28:43,250
thing to compose I went ahead and

00:28:41,750 --> 00:28:44,929
modified a couple things in the class

00:28:43,250 --> 00:28:47,420
because you not want to give it a

00:28:44,929 --> 00:28:50,840
nice-looking repper so that it looks

00:28:47,420 --> 00:28:52,309
pretty and I'll make it a pic level you

00:28:50,840 --> 00:28:53,870
do go ahead and polish up all your path

00:28:52,309 --> 00:28:56,570
classes to make sure that they look nice

00:28:53,870 --> 00:29:00,260
and pickle right that's what I thought

00:28:56,570 --> 00:29:03,830
we'll go and run this and presto this

00:29:00,260 --> 00:29:06,260
counter has inside it an order dict the

00:29:03,830 --> 00:29:08,540
order dick remember it has counted

00:29:06,260 --> 00:29:12,890
everything in abracadabra you see we can

00:29:08,540 --> 00:29:16,700
make that bigger but out of the letters

00:29:12,890 --> 00:29:19,670
if the a came first so it's listed first

00:29:16,700 --> 00:29:23,510
then we saw the B so it's listed second

00:29:19,670 --> 00:29:25,160
then the R and C in other words these

00:29:23,510 --> 00:29:27,890
now show and the order that they were

00:29:25,160 --> 00:29:29,190
encountered you've made a ordered

00:29:27,890 --> 00:29:32,480
counter in one line

00:29:29,190 --> 00:29:41,540
could who think super is super and now

00:29:32,480 --> 00:29:46,680
take that David Beasley my code is done

00:29:41,540 --> 00:29:49,050
you guys could go home Oh risk let's do

00:29:46,680 --> 00:29:50,910
more risk Emacs seems to work out well

00:29:49,050 --> 00:29:54,060
for me live demos have worked out for me

00:29:50,910 --> 00:29:56,280
take a bigger risk take three people who

00:29:54,060 --> 00:29:58,920
have never met before and bring them up

00:29:56,280 --> 00:30:03,380
on stage and have them model all of this

00:29:58,920 --> 00:30:05,310
for you what could possibly go wrong

00:30:03,380 --> 00:30:06,870
including there's not a lot of stage

00:30:05,310 --> 00:30:09,680
space and the lights are pointed right

00:30:06,870 --> 00:30:13,110
here and not right well they would be

00:30:09,680 --> 00:30:14,880
what is super mean if you take something

00:30:13,110 --> 00:30:16,740
away from this it means next in line

00:30:14,880 --> 00:30:18,990
where does the line come from the

00:30:16,740 --> 00:30:19,890
linearization algorithm what do you need

00:30:18,990 --> 00:30:21,990
to know about the linearization

00:30:19,890 --> 00:30:24,570
algorithm you could read a paper on it

00:30:21,990 --> 00:30:25,940
or just remember a couple things do you

00:30:24,570 --> 00:30:27,900
just like to know the couple things

00:30:25,940 --> 00:30:29,580
children get called before their parents

00:30:27,900 --> 00:30:33,270
and parents get called in the order

00:30:29,580 --> 00:30:36,750
listed up here who gets called first the

00:30:33,270 --> 00:30:40,110
ordered counter are the counter or the

00:30:36,750 --> 00:30:44,810
ordered date who's first ordered counter

00:30:40,110 --> 00:30:44,810
because children go before their parents

00:30:47,390 --> 00:30:53,660
okay now what about the parents who

00:30:50,550 --> 00:30:56,130
comes first the counter or the ordered a

00:30:53,660 --> 00:30:59,460
counter the parents stay in the order

00:30:56,130 --> 00:31:01,650
listed there's one other rule for the

00:30:59,460 --> 00:31:04,410
linearization algorithm but it's not a

00:31:01,650 --> 00:31:05,820
particularly it's important in practice

00:31:04,410 --> 00:31:08,850
but not important for you to remember

00:31:05,820 --> 00:31:10,620
and that is that the order is stable and

00:31:08,850 --> 00:31:13,140
that when these get combined your

00:31:10,620 --> 00:31:15,240
parents orders don't get scrambled those

00:31:13,140 --> 00:31:17,370
three rules put together say ordered

00:31:15,240 --> 00:31:19,260
counter gets call first then the counter

00:31:17,370 --> 00:31:21,540
then the ordered date and our whole goal

00:31:19,260 --> 00:31:24,270
was to make sure that counter when they

00:31:21,540 --> 00:31:25,940
asked for dictionary services got its

00:31:24,270 --> 00:31:27,330
supplier from the order dik first

00:31:25,940 --> 00:31:30,030
easy-peasy

00:31:27,330 --> 00:31:34,320
what is super mean it should have been

00:31:30,030 --> 00:31:35,990
called the next one in the line what's

00:31:34,320 --> 00:31:38,610
the word that means make into a line

00:31:35,990 --> 00:31:39,870
linearization what are the only things

00:31:38,610 --> 00:31:40,860
you need to remember about linearization

00:31:39,870 --> 00:31:42,630
children

00:31:40,860 --> 00:31:45,510
come before parents and parents stay in

00:31:42,630 --> 00:31:50,090
order with that rule you can force the

00:31:45,510 --> 00:31:50,090
line to be in the right order easy peasy

00:31:50,960 --> 00:31:56,010
so it means next in line think of that

00:31:54,090 --> 00:31:58,590
every time you think of super it does

00:31:56,010 --> 00:32:00,450
not mean call your parents do you think

00:31:58,590 --> 00:32:03,960
it's pretty easy to talk to the next

00:32:00,450 --> 00:32:05,700
person in line yes what is cooperative

00:32:03,960 --> 00:32:07,320
multiple inheritance cooperative

00:32:05,700 --> 00:32:09,480
multiple inheritance is where you design

00:32:07,320 --> 00:32:11,460
a tree of classes where everybody is

00:32:09,480 --> 00:32:14,640
cooperating and what kind of cooperation

00:32:11,460 --> 00:32:15,210
is required that everybody says next in

00:32:14,640 --> 00:32:19,500
line

00:32:15,210 --> 00:32:23,179
is a multiple inheritance with diamond

00:32:19,500 --> 00:32:23,179
diamond diagrams easy or hard

00:32:23,240 --> 00:32:28,049
while we said if there's no conflicts

00:32:25,650 --> 00:32:30,330
it's easy and we said if it's single

00:32:28,049 --> 00:32:32,870
inheritance is easy but everybody thinks

00:32:30,330 --> 00:32:36,020
of the other case is hard it's not hard

00:32:32,870 --> 00:32:36,020
but the

00:32:47,780 --> 00:32:52,370
if it's a battery problem wasn't it the

00:32:50,270 --> 00:32:54,380
article supers considered harmful

00:32:52,370 --> 00:32:56,270
suggested it was a hard problem I

00:32:54,380 --> 00:32:58,130
believe is because the author didn't

00:32:56,270 --> 00:33:00,380
know the rules he had a legitimate

00:32:58,130 --> 00:33:02,240
reason to not know the rules no one had

00:33:00,380 --> 00:33:03,590
ever published them you're about to find

00:33:02,240 --> 00:33:08,210
them out in a way that's easy to

00:33:03,590 --> 00:33:09,770
remember our problem is this the only

00:33:08,210 --> 00:33:12,560
thing we're trying to do when we call

00:33:09,770 --> 00:33:14,090
super is say I want the next in line and

00:33:12,560 --> 00:33:16,880
what kind of problems can you have with

00:33:14,090 --> 00:33:27,860
that let's observe may I have my three

00:33:16,880 --> 00:33:29,210
volunteers this is all unrehearsed these

00:33:27,860 --> 00:33:33,080
people don't know me

00:33:29,210 --> 00:33:36,370
oh one of them does one of them knows

00:33:33,080 --> 00:33:39,920
too much the stories he could tell

00:33:36,370 --> 00:33:41,990
you're kind of arranged in a blob what

00:33:39,920 --> 00:33:45,640
should I do to them I'm going to

00:33:41,990 --> 00:33:49,250
linearize you come off here at the end

00:33:45,640 --> 00:33:52,790
see bucco there you go they are now

00:33:49,250 --> 00:33:55,420
linearized we have a tool in Python that

00:33:52,790 --> 00:34:01,340
says next in line what does it call

00:33:55,420 --> 00:34:04,190
super all right we'll observe the first

00:34:01,340 --> 00:34:06,500
problem all of you have been programmed

00:34:04,190 --> 00:34:09,560
to call super which means give it to the

00:34:06,500 --> 00:34:12,129
next person where next person in line

00:34:09,560 --> 00:34:17,000
how hard could that be

00:34:12,129 --> 00:34:18,379
let's see how Nickie Nina does Nina hand

00:34:17,000 --> 00:34:21,290
it to the next person in line

00:34:18,379 --> 00:34:22,159
she was quite successful hand it to the

00:34:21,290 --> 00:34:24,649
next person in line

00:34:22,159 --> 00:34:30,050
she was quite successful Tomas handed -

00:34:24,649 --> 00:34:33,620
Oh problem number one the remember Tomas

00:34:30,050 --> 00:34:36,230
can't possibly know in advance who is

00:34:33,620 --> 00:34:40,129
going to be called so he has to hand it

00:34:36,230 --> 00:34:41,840
hand it off oops it's mine now he has to

00:34:40,129 --> 00:34:50,240
move it forward he's required to use

00:34:41,840 --> 00:34:52,490
super ok I'll just work with a mic ok

00:34:50,240 --> 00:34:54,139
and so his problem is he's going to make

00:34:52,490 --> 00:34:55,850
a call to a person who doesn't exist

00:34:54,139 --> 00:34:59,900
this was one of the problems mentioned

00:34:55,850 --> 00:35:01,700
in super considered harmful well you're

00:34:59,900 --> 00:35:04,610
on stage now could I take advantage of

00:35:01,700 --> 00:35:07,760
yes how about sin on the other side of

00:35:04,610 --> 00:35:10,040
Thomas okay whenever I tell you to hand

00:35:07,760 --> 00:35:13,150
it to the next person just say sure I

00:35:10,040 --> 00:35:16,970
did it but don't really do it okay okay

00:35:13,150 --> 00:35:19,610
all right here we go ready hand it to

00:35:16,970 --> 00:35:21,619
the next person and it's the next person

00:35:19,610 --> 00:35:23,420
and it to the next person hand it to the

00:35:21,619 --> 00:35:25,100
next part you're just supposed to say

00:35:23,420 --> 00:35:27,619
sure I really did it but not actually do

00:35:25,100 --> 00:35:31,880
it did that improve the situation a

00:35:27,619 --> 00:35:33,560
great deal so here's one of your

00:35:31,880 --> 00:35:35,780
problems with super you can't possibly

00:35:33,560 --> 00:35:37,700
know in advance who's upstream that's

00:35:35,780 --> 00:35:40,720
determined by your children not by you

00:35:37,700 --> 00:35:40,720
thank you very much

00:35:43,810 --> 00:35:48,350
Thomas has to hand it off to somebody

00:35:46,400 --> 00:35:49,940
but now the person at the end of the

00:35:48,350 --> 00:35:51,590
chain tries to hand it off to someone

00:35:49,940 --> 00:35:53,720
who doesn't exist and in Python that

00:35:51,590 --> 00:35:57,200
gives you an attribute error I know what

00:35:53,720 --> 00:36:00,380
you're thinking hey nothing broke this

00:35:57,200 --> 00:36:02,960
time and the answer is you put a stopper

00:36:00,380 --> 00:36:04,730
clasp at the end not object you can

00:36:02,960 --> 00:36:06,560
create an object called root and put it

00:36:04,730 --> 00:36:09,080
in and all it is is something that has

00:36:06,560 --> 00:36:11,480
the method of interest pass it along but

00:36:09,080 --> 00:36:12,890
doesn't actually cause super somebody at

00:36:11,480 --> 00:36:18,760
the end of the chain shouldn't have

00:36:12,890 --> 00:36:18,760
super easy enough alright next problem I

00:36:19,330 --> 00:36:22,900
lost to the middle

00:36:23,830 --> 00:36:30,980
he seemed amazingly cooperative but

00:36:26,780 --> 00:36:40,400
sometimes he's not we'll see pass it

00:36:30,980 --> 00:36:42,410
along pass it along I see how it is one

00:36:40,400 --> 00:36:47,619
of your problems is that someone along

00:36:42,410 --> 00:36:49,640
the way doesn't cooperate cooperate

00:36:47,619 --> 00:36:54,140
remember super was designed for

00:36:49,640 --> 00:36:55,670
cooperative multiple inheritance so what

00:36:54,140 --> 00:36:57,260
do you do if you want to worked up with

00:36:55,670 --> 00:37:00,160
Thomas and he's not going to forward it

00:36:57,260 --> 00:37:02,480
along do you want to volunteer again

00:37:00,160 --> 00:37:06,109
I'll put you right here in front of

00:37:02,480 --> 00:37:06,470
Thomas okay Thomas step back there you

00:37:06,109 --> 00:37:10,630
go

00:37:06,470 --> 00:37:13,830
alright Nina come back to two feet okay

00:37:10,630 --> 00:37:17,190
Nina's job her new job is

00:37:13,830 --> 00:37:19,290
when I tell you to do work briefly hand

00:37:17,190 --> 00:37:20,940
this to Thomas take it back and then

00:37:19,290 --> 00:37:22,710
when I say pass it along pass it to you

00:37:20,940 --> 00:37:25,650
left ready here we go

00:37:22,710 --> 00:37:29,130
Nina's very cooperative here we go Nina

00:37:25,650 --> 00:37:32,370
do something with the bowl okay take it

00:37:29,130 --> 00:37:35,130
back now pass it along this is a very

00:37:32,370 --> 00:37:37,020
simple thing what do you do when saw

00:37:35,130 --> 00:37:38,730
there's a class as designed

00:37:37,020 --> 00:37:42,570
thank you perfect when a class is

00:37:38,730 --> 00:37:45,420
designed non cooperatively like Thomas

00:37:42,570 --> 00:37:48,300
here the answer is you make another

00:37:45,420 --> 00:37:51,150
glass whose sole job is handed to Thomas

00:37:48,300 --> 00:37:52,850
let him do his work and then pass it

00:37:51,150 --> 00:37:55,830
along easy enough

00:37:52,850 --> 00:37:57,780
okay and so one of the problems

00:37:55,830 --> 00:37:59,280
mentioned is super considered harmful is

00:37:57,780 --> 00:38:01,200
it doesn't work with classes that

00:37:59,280 --> 00:38:02,850
weren't designed to cooperatively it

00:38:01,200 --> 00:38:04,680
does work perfectly you just have to put

00:38:02,850 --> 00:38:07,050
an extra cooperating class in front of

00:38:04,680 --> 00:38:09,750
it and it's remarkably easy to do who

00:38:07,050 --> 00:38:12,210
learned something new there's a third

00:38:09,750 --> 00:38:19,070
problem go ahead and line up again any

00:38:12,210 --> 00:38:22,710
order will do okay take the banana and

00:38:19,070 --> 00:38:26,700
pass the ball along take the banana and

00:38:22,710 --> 00:38:31,830
pass the Bowl along take the banana and

00:38:26,700 --> 00:38:36,340
pass what happened what happened was he

00:38:31,830 --> 00:38:39,220
got unexpected arguments in fact

00:38:36,340 --> 00:38:42,910
Nina wants a banana Thomas was the water

00:38:39,220 --> 00:38:45,730
I didn't get your name it and Ashley

00:38:42,910 --> 00:38:47,620
wants the banana remember none of these

00:38:45,730 --> 00:38:50,260
people knew each other before this

00:38:47,620 --> 00:38:51,390
started so they don't know what to hand

00:38:50,260 --> 00:38:54,460
to each other

00:38:51,390 --> 00:38:55,990
positional arguments won't do somebody

00:38:54,460 --> 00:38:57,970
was reaching for a banana in the

00:38:55,990 --> 00:39:00,580
positional argument and they got the

00:38:57,970 --> 00:39:02,320
wrong thing that's sort of uh through

00:39:00,580 --> 00:39:07,360
Tomas we're Lu I know what you're

00:39:02,320 --> 00:39:09,430
thinking keyword arguments with the

00:39:07,360 --> 00:39:11,680
keyword arguments I say water equal

00:39:09,430 --> 00:39:17,440
water but in equal banana apple equal

00:39:11,680 --> 00:39:22,570
Apple Nina take the banana Hamas take

00:39:17,440 --> 00:39:24,790
the water Ashley take the Apple and that

00:39:22,570 --> 00:39:25,960
covers 100% of the problems mentioned in

00:39:24,790 --> 00:39:29,070
super considered harmful

00:39:25,960 --> 00:39:29,070
thank you to my volunteers

00:39:32,620 --> 00:39:38,920
take two minutes to wrap up learning

00:39:36,580 --> 00:39:40,630
points there are when you're using super

00:39:38,920 --> 00:39:42,700
for cooperative multiple inheritance use

00:39:40,630 --> 00:39:45,010
keyword arguments because you can't know

00:39:42,700 --> 00:39:46,300
in advance who you're calling and you

00:39:45,010 --> 00:39:48,190
don't know what arguments are going to

00:39:46,300 --> 00:39:49,330
need they know which ones they need but

00:39:48,190 --> 00:39:52,840
they don't know who they're calling in

00:39:49,330 --> 00:39:54,400
advance the for this to work you can't

00:39:52,840 --> 00:39:57,370
have a Thomas in the middle who doesn't

00:39:54,400 --> 00:40:00,190
pass it along but you can make a wrapper

00:39:57,370 --> 00:40:02,200
around Thomas that is cooperative it's a

00:40:00,190 --> 00:40:04,960
trivially easy thing to do just make a

00:40:02,200 --> 00:40:07,630
subclass that has a super init and

00:40:04,960 --> 00:40:09,610
remember this is a chain of calls and at

00:40:07,630 --> 00:40:11,050
the end of the chain somebody has to be

00:40:09,610 --> 00:40:13,420
at the end of the line and stop making

00:40:11,050 --> 00:40:14,970
calls you do that with a stopper class

00:40:13,420 --> 00:40:17,470
this is all covered in the blog post

00:40:14,970 --> 00:40:20,290
along the way you've also learned to

00:40:17,470 --> 00:40:22,180
make ordered counters effortlessly how

00:40:20,290 --> 00:40:24,930
to do dependency injection with amak

00:40:22,180 --> 00:40:27,280
objects and how to get pizza that is

00:40:24,930 --> 00:40:30,600
organic instead of filled with

00:40:27,280 --> 00:40:33,670
insecticide who learned something new

00:40:30,600 --> 00:40:38,110
ok by a show of hands we're going to

00:40:33,670 --> 00:40:40,660
vote super or harmful ready how many of

00:40:38,110 --> 00:40:41,890
you think super is considered super how

00:40:40,660 --> 00:40:44,560
many of you think super is considered

00:40:41,890 --> 00:40:47,580
harmful my work is done here thank you

00:40:44,560 --> 00:40:47,580
very much for coming to my talk

00:40:51,800 --> 00:40:57,360
we have we have time for a few questions

00:40:54,120 --> 00:41:03,960
if you want to line up at the microphone

00:40:57,360 --> 00:41:06,060
in the center of the room I think our

00:41:03,960 --> 00:41:08,160
work is done here thank you sir

00:41:06,060 --> 00:41:10,800
oh now you guess it's not there is a

00:41:08,160 --> 00:41:13,020
question hi there thanks for your talk

00:41:10,800 --> 00:41:17,700
being a naive Python developer I would

00:41:13,020 --> 00:41:19,230
put self dot member in a class can you

00:41:17,700 --> 00:41:31,920
tell more about the one you should use

00:41:19,230 --> 00:41:33,540
super versus self the whole purpose of

00:41:31,920 --> 00:41:36,750
super is to call the next one in line

00:41:33,540 --> 00:41:40,170
that's the position after the first of

00:41:36,750 --> 00:41:42,990
the position line the current position

00:41:40,170 --> 00:41:45,630
line over here when we call super it

00:41:42,990 --> 00:41:46,950
goes up on level two pizza R I'm sorry

00:41:45,630 --> 00:41:48,540
starting with pizza we go one up one

00:41:46,950 --> 00:41:50,940
level two dough factory the next one

00:41:48,540 --> 00:41:53,070
goes to object if you don't need the

00:41:50,940 --> 00:41:54,780
next one in line if anybody in line

00:41:53,070 --> 00:41:57,360
would do if you'd like to start over

00:41:54,780 --> 00:41:58,560
again at the beginning yourself if you'd

00:41:57,360 --> 00:42:01,860
like the next in line

00:41:58,560 --> 00:42:04,080
use super does that make sense every

00:42:01,860 --> 00:42:06,480
time you do self dot the chain of lookup

00:42:04,080 --> 00:42:08,940
starts from the bottom and works its way

00:42:06,480 --> 00:42:11,400
up again super says next in line

00:42:08,940 --> 00:42:13,380
so in this chain here if we call it self

00:42:11,400 --> 00:42:15,180
it would have started all over again if

00:42:13,380 --> 00:42:16,100
we called super it was the next one in

00:42:15,180 --> 00:42:19,080
line

00:42:16,100 --> 00:42:26,730
excellent question five bucks I don't

00:42:19,080 --> 00:42:29,460
really pay up yes sir I basically have

00:42:26,730 --> 00:42:31,820
the exact same question so even I have

00:42:29,460 --> 00:42:41,120
the exact same answer

00:42:31,820 --> 00:42:43,190
I feel bad about that uh excuse my

00:42:41,120 --> 00:42:45,470
ignorance about the super but sometimes

00:42:43,190 --> 00:42:47,240
I see super use with arguments inside it

00:42:45,470 --> 00:42:49,490
is that only a Python to thing versus

00:42:47,240 --> 00:42:52,490
Python three thing or you can do it in

00:42:49,490 --> 00:42:57,080
Python three as well in it was so

00:42:52,490 --> 00:42:58,940
confusing in Python to that we put some

00:42:57,080 --> 00:43:00,320
deep dark magic in Python three to

00:42:58,940 --> 00:43:02,240
automatically compute those arguments

00:43:00,320 --> 00:43:04,700
for you so without arguments it looks

00:43:02,240 --> 00:43:06,920
beautiful intends to do the the right

00:43:04,700 --> 00:43:08,990
thing it's truly magical but in fact

00:43:06,920 --> 00:43:11,720
what do the arguments mean if you did

00:43:08,990 --> 00:43:14,090
put them in or using Python to basically

00:43:11,720 --> 00:43:16,730
we need two things we need to know

00:43:14,090 --> 00:43:19,670
Matthew who is that whose method

00:43:16,730 --> 00:43:22,280
resolution order are we searching so

00:43:19,670 --> 00:43:25,010
we're searching Matthews and we need to

00:43:22,280 --> 00:43:26,780
know where we are right now so in

00:43:25,010 --> 00:43:29,030
Matthews resident method resolution

00:43:26,780 --> 00:43:31,280
order which is all of this where are we

00:43:29,030 --> 00:43:33,350
right now we're at Rachel so Rachel's

00:43:31,280 --> 00:43:35,690
super will call the next in Matthews

00:43:33,350 --> 00:43:37,850
chain the person after Rachel so

00:43:35,690 --> 00:43:40,250
essentially this is a computation whose

00:43:37,850 --> 00:43:42,680
line are we dealing with Matt Matthews

00:43:40,250 --> 00:43:45,530
where are we in the line at Rachel and

00:43:42,680 --> 00:43:47,930
then super computes the next one in the

00:43:45,530 --> 00:43:50,540
line which is Dennis so let's say

00:43:47,930 --> 00:43:52,310
computation of two arguments that seemed

00:43:50,540 --> 00:43:54,440
to confuse the heck out of people deep

00:43:52,310 --> 00:43:55,060
dark magic has made it go away excellent

00:43:54,440 --> 00:43:58,430
question

00:43:55,060 --> 00:44:00,860
ten bucks okay but I got it right that

00:43:58,430 --> 00:44:02,960
the media argument is only in three

00:44:00,860 --> 00:44:05,210
right and two you need to put arguments

00:44:02,960 --> 00:44:08,830
right okay and the two arguments are

00:44:05,210 --> 00:44:11,600
whose line are we searching Matthew and

00:44:08,830 --> 00:44:13,760
where are we right now so that we can

00:44:11,600 --> 00:44:15,890
compute remember what super really means

00:44:13,760 --> 00:44:19,070
it's the next one in the line thanks a

00:44:15,890 --> 00:44:20,510
lot great talk don't be home for

00:44:19,070 --> 00:44:24,130
questions thank you very much again

00:44:20,510 --> 00:44:24,130

YouTube URL: https://www.youtube.com/watch?v=EiOglTERPEo


