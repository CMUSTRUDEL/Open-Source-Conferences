Title: Ying Li - Where in your RAM is "python san_diego.py"? - PyCon 2015
Publication date: 2015-04-12
Playlist: PyCon 2015
Description: 
	"Speaker: Ying Li

Gumshoes, the rogue program `san_diego.py` is threatening to cause havok!  What is it doing to hide itself?  What kind of things is it doing?  Who might it be communicating with?  RAM is a big place - how can we even find it, much less any of this information? Stay tuned and find out!

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:02:13,950 --> 00:02:17,959
GOING TO BE TALKING TO US ABOUT CARMEN SAN DIEGO,

00:02:17,959 --> 00:02:29,090
I THINK. >> WELCOME, GUMSHOES, TO ANOTHER EPISODE OF

00:02:29,090 --> 00:02:34,400
WHERE IN iRAN IS SAN DIEGO, PYTHON SAN DIEGO.PY?

00:02:34,400 --> 00:02:40,000
SPONSORED BY MY EMPLOYER, RACKSPACE. I'M YOUR HOST AND ACME CRIME NET LIAISON.

00:02:40,000 --> 00:02:41,910
THE CHEF APPRECIATES YOUR HELP AND DISCRETION IN

00:02:41,910 --> 00:02:45,260
THIS MATTER BUT I'LL LET HER EXPLAIN THE SITUATION HERSELF.

00:02:45,260 --> 00:02:47,700
GUMSHOES, WE'VE RECEIVED A CREDIBLE THREAT TO THE

00:02:47,700 --> 00:02:52,390
ACME CRIME NET CASE FILE SERVER. I GOT THIS TEXT FROM MY MOTHER EARLIER TODAY.

00:02:52,390 --> 00:02:54,569
MY MOTHER THINKS IF SHE THREATENS MY WORK, I'LL

00:02:54,569 --> 00:02:57,790
TO HAVE CALL HER AND ASK HER TO STOP. SHE'S PROBABLY RIGHT BUT I CAN'T LET THE

00:02:57,790 --> 00:03:00,579
ULTIMATUM STAND. THE NEXT TIME SHE MIGHT DEMAND THAT I MAKE

00:03:00,579 --> 00:03:04,410
THANKSGIVING DINNER. MY MOM IS A PYTHON PROGRAMMER BUT I DIDN'T

00:03:04,410 --> 00:03:09,440
SEE ANY PROCESSES LOADING.

00:03:09,440 --> 00:03:12,620
FIND THE ROGUE PROCESS, GUMSHOES. I NEED TO START THE SERVER UP AGAIN AT SOME

00:03:12,620 --> 00:03:14,620
POINT AND I CAN'T HAVE HER DELETING MY FILES.

00:03:14,620 --> 00:03:17,370
CHIEF OUT. >> THANKS, CHIEF.

00:03:17,370 --> 00:03:21,040
[ Laughter ] AND, I GUESS...

00:03:21,040 --> 00:03:25,160
THERE'S THE MEMORY DUMP. OKAY, SO NOW WE HAVE A TWO GIGABYTE BINARY

00:03:25,160 --> 00:03:28,720
FILE, A DUMP OF WHAT'S WAS ON THE RAM IN THE SERVER.

00:03:28,720 --> 00:03:34,020
IT SURE WOULD BE NICE IF THIS WAS SPLIT INTO PROCESS REGIONS.

00:03:34,020 --> 00:03:35,730
THEN WE CAN FIND THE PART THAT BELONGS TO THE

00:03:35,730 --> 00:03:39,200
ROGUE PYTHON PROCESS AND DO SOMETHING WITH IT.

00:03:39,200 --> 00:03:44,190
MAYBE WE CAN SPLIT IT OURSELVES, ALL PROCESSES ARE MANAGED BY A BOSS, RIGHT, THE KERNEL,

00:03:44,190 --> 00:03:46,100
WHICH MUST KNOW THEIR WHEREABOUTS AND WHAT THEY'VE

00:03:46,100 --> 00:03:47,100
BEEN UP TO.

00:03:47,100 --> 00:03:49,900
WE NEED TO FIND THE KERNEL AND INTERROGATE IT,

00:03:49,900 --> 00:03:54,310
BUT HOW? LUCKILY, THERE IS AN OUTSIDE CONTRACTOR WICK

00:03:54,310 --> 00:03:58,930
EMPLOY TO HUNT THROUGH MEMORY DUMPS FOR US. IT'S OPEN SOURCE, WRITTEN ENTIRELY IN PYTHON

00:03:58,930 --> 00:04:00,680
AND IF WE GIVE IT AN ACCURATE DESCRIPTION OF WHAT

00:04:00,680 --> 00:04:03,680
THE KERNEL LOOKS LIKE AND THE ADDRESS OF ITS KNOWN

00:04:03,680 --> 00:04:06,069
ASSOCIATES VOLATILITY CAN FIND THE KERNEL AND ANY

00:04:06,069 --> 00:04:10,630
PROCESSES THE KERNEL CAN MANAGE. THE FIRST THING WE NEED TO DO IS BUILD A PROFILE

00:04:10,630 --> 00:04:15,040
OF THE KERNEL. KERNEL HEADERS DESCRIBE THE KERNEL.

00:04:15,040 --> 00:04:19,480
THEY DEFINE THE DATA STRUCTURES IT USES, WHAT ATTRIBUTES THEY HAVE AND HOW BIG THEY ARE.

00:04:19,480 --> 00:04:27,479
THIS WILL TELL VOLATILITY WHAT THE CERTAINLY ENGINEER -- KERNEL WILL LOOK LIKE IN -- 

00:04:27,479 --> 00:04:29,071
THEY'RE PROVIDED BY THE LINUX HEADER PACKAGES FOR

00:04:29,071 --> 00:04:31,160
OUR PARTICULAR KERNEL VERSION.

00:04:31,160 --> 00:04:34,220
FOR OS 10, THEY CAN BE DOWNLOADED FROM AN HE WILL

00:04:34,220 --> 00:04:40,630
AND VOLATILITY HAS A LOT OF EXPERIENCE HUNTING DOWN THE KERNELS.

00:04:40,630 --> 00:04:42,780
SO WHAT ABOUT THE LOCATIONS OF THE KERNEL'S KNOWN

00:04:42,780 --> 00:04:46,280
SOMEBODY AT? WE'RE LOOKING FOR AN ADDRESS BOOK OF SORTS,

00:04:46,280 --> 00:04:49,720
CALLED THE SYMBOL TABLE. THAT HAS INFORMATION ABOUT IDENTIFIERS IN

00:04:49,720 --> 00:04:51,180
THE KERNEL CODE.

00:04:51,180 --> 00:04:55,210
INFORMATION LIKE AN IDENTIFIER IS AN ADDRESS WHICH IS JUST A NUMBER REPRESENTING AN OFFSET

00:04:55,210 --> 00:05:01,440
INTO MEMORY, WHERE THE IDENTIFIER CAN BE FOUND. IN LINUX, THE KERNEL SYMBOL TABLE CAN BE FOUND

00:05:01,440 --> 00:05:04,340
AT BOOT/SYSTEM.MAP.

00:05:04,340 --> 00:05:12,830
IT CAN BE USED TO EXTRACT THE MAPPING, LIKE HUMANELY, AND, AGAIN, VOLATILITY PROBABLY

00:05:12,830 --> 00:05:15,770
ALREADY KNOWS ALL THE WINDOWS ADDRESS BOOKS.

00:05:15,770 --> 00:05:19,050
OKAY. SO NOW THAT WE'VE BUILT OUR PROFILE, WE CAN

00:05:19,050 --> 00:05:23,030
INVOKE VOLATILITY. WE DEAD-DROP OUR PROFILE INTO A PLUG I IN

00:05:23,030 --> 00:05:24,890
DIRECTORY, TELL THE -- TELL VOLUME TAKE IT BOTH

00:05:24,890 --> 00:05:26,770
THE LOCATION OF THE DEAD-DROP AND THE NAME OF THE

00:05:26,770 --> 00:05:28,820
PROFILE AND THEN WE POINT IT AT THE MEMORY DUMP

00:05:28,820 --> 00:05:34,060
AND TELL IT WHAT WE WANT TO SEARCH FOR. LET'S START BY TELLING VOLATILITY TO FIND

00:05:34,060 --> 00:05:37,770
THE KERNEL AND BRING IT IN FOR A FRIENDLY CHAT.

00:05:37,770 --> 00:05:39,960
VOLATILITY FACILITATES THE INTERROGATION WITH AN

00:05:39,960 --> 00:05:45,419
INTERACTIVE SHELL COMMAND VOLUME VOL SHELL. THIS IS AN I-PYTHON SESSION WITH EXTRA CONTEXT.

00:05:45,419 --> 00:05:47,930
AS YOU CAN SEE, VOLATILITY THINKS IT'S FOUND THE

00:05:47,930 --> 00:05:55,110
KERNEL'S INIT TASK, THE PARENTS OF ALL OTHER PROCESSES NWINDOWS, THIS WOULD BE THE SYSTEM

00:05:55,110 --> 00:05:57,790
PROCESS, IN OS 10, THIS WOULD BE THE KERNEL TASK.

00:05:57,790 --> 00:06:02,710
THE LINUX KERNEL KEEPS TRACK OF ALL THE PROCESSES IT'S CURRENTLY MANAGING IN A LINKED LIST.

00:06:02,710 --> 00:06:08,650
THE FIRST LIMITS OF WHICH IS THE INIT TASK. SO THEY'VE FOUND THAT TASK, PROBABLY FOUND

00:06:08,650 --> 00:06:12,940
THE KERNEL AND WE CAN GET TO AMOUNT OTHER PROCESSES.

00:06:12,940 --> 00:06:14,870
SO LET'S USE THE I-PYTHON INTERFACE TO ASK SOME

00:06:14,870 --> 00:06:18,810
BASIC QUESTIONS TO ESTABLISH THE SUSPECT'S IDENTITY.

00:06:18,810 --> 00:06:21,229
THE VOLATILITY SHELL OBJECT IS PRESENTED AS SELF

00:06:21,229 --> 00:06:27,440
AND THE TASK CURRENTLY UNDER INTERROGATION SUPPOSEDLY INIT IS AN ATTRIBUTE ON VOLATILITY

00:06:27,440 --> 00:06:30,730
SHELL NAMED PROC. WE CAN START OFF WITH SOMETHING EASY.

00:06:30,730 --> 00:06:36,292
LET'S SAY, HEY, WHAT ARE YOU? TEST STRUCT, IT ANSWERS, AND THAT WOULD BE

00:06:36,292 --> 00:06:40,209
GREAT IF WE KNEW WHEN A TASK STRUCT WAS.

00:06:40,209 --> 00:06:41,690
TO ANSWER THAT, WE SHOULD UNDERSTAND WHAT THE

00:06:41,690 --> 00:06:46,250
KERNEL DOES WHEN A PROCESS STARTS UP. WE KNOW THAT INIT IS SOME KIND OF LINUX PROCESS

00:06:46,250 --> 00:06:51,270
AND WE KNOW THE KERNEL NEEDS SOME WAY TO KEEP TRACK OF ALL PROCESSES, SO IT OBVIOUSLY NEEDS

00:06:51,270 --> 00:06:53,910
TO STORE INFORMATION NEEDED TO MANAGE THE PROCESS,

00:06:53,910 --> 00:06:55,880
AND THE IT ALLOCATES MEMORY FOR THE PROCESS WHEN

00:06:55,880 --> 00:06:57,589
IT STARTS UP, WHICH MEANS IT NEEDS TO STORE WHAT

00:06:57,589 --> 00:07:02,440
MEMORY BELONGS TO WHAT PROCESS. THE PROCESS INFORMATION IS STORED IN A C DATA

00:07:02,440 --> 00:07:05,890
STRUCTURE OR STRUCT. YOU CAN THINK OF STRUCTS LIKE PYTHON NAMED

00:07:05,890 --> 00:07:10,450
UP HE WILLS, THEY GROUP DATA TOGETHER.

00:07:10,450 --> 00:07:14,730
IN LINUX, THIS STRUCT IS CALLED A TASK STRUCT. THE CORRESPONDING INSTRUCTOR IN WINDOWS WOULD

00:07:14,730 --> 00:07:18,169
BE E PROCESS AND IN OS 10 IT'S PROC, BUT THEY

00:07:18,169 --> 00:07:21,149
PRETTY MUCH ALL CONTAIN THE SAME INFORMATION.

00:07:21,149 --> 00:07:26,270
LIKE BASIC INFORMATION ABOUT THE PROCESS ITSELF, LIKE THE I.Z., THE SHORT NAME AND THE START

00:07:26,270 --> 00:07:29,900
TIME. THE EXAMPLE DISPLAYED HERE IS A LINUX TASK

00:07:29,900 --> 00:07:34,279
STRUCT. THEY ALSO USUALLY HAVE SOME WAY TO ACCESS

00:07:34,279 --> 00:07:36,960
THE PARENT PROCESSES, SIBLING PROCESSES AND CHILD

00:07:36,960 --> 00:07:39,980
PROCESSES, AND INFORMATION ABOUT THE OWNER OF THE

00:07:39,980 --> 00:07:43,970
PROCESS. SOME WAY TO LOOK UP THE PROCESSES OPEN FILES

00:07:43,970 --> 00:07:47,770
AND SOCKETS, AND FINALLY, SOME WAY TO STORE

00:07:47,770 --> 00:07:49,880
INFORMATION NEEDED TO MANAGE THE MEMORY OF THE

00:07:49,880 --> 00:07:52,470
PROCESS. IN LINUX, IT'S STORED IN ANOTHER STRUCTURE

00:07:52,470 --> 00:07:56,150
CALLED THE MM STRUCT.

00:07:56,150 --> 00:07:58,620
SO NOW WE KNOW WHAT THAT IS, LET'S RETURN TO THE

00:07:58,620 --> 00:08:04,330
INTERROGATION AND ASK MORE SPECIFIC QUESTIONS, LIKE WHAT'S YOUR PROCESS I.D.?

00:08:04,330 --> 00:08:06,260
ONE. THAT'S PRETTY COOL.

00:08:06,260 --> 00:08:08,940
THE INIT TASK ALWAYS HAS AN I.D. OF ONE IN LINUX.

00:08:08,940 --> 00:08:11,130
WHAT'S YOUR SHORT NAME? INIT.

00:08:11,130 --> 00:08:16,150
AWESOME, IDENTITIES VERIFIED, WE'VE CONFIRMED THIS IS THE SUSPECT.

00:08:16,150 --> 00:08:22,340
LET'S HAVE VOLATILITY A MUCH MORE EFFECTIVE INTERROGATOR THAN US ASK WHAT PROCESSES IT

00:08:22,340 --> 00:08:25,820
MANAGES. THE ANSWER LOOKS LIKE THE RESULT OF THE LINUS

00:08:25,820 --> 00:08:26,820
PS COMMANDS.

00:08:26,820 --> 00:08:31,210
THERE IS A LIST OF THE PROCESS I.D.s AND SHORT NAMES, NOTHING LOOKS SUPER SUSPICIOUS, THOUGH,

00:08:31,210 --> 00:08:34,890
SO LET'S HAVE VOLATILITY ASK A DIFFERENT WAY.

00:08:34,890 --> 00:08:36,649
THIS TIME THE ANSWER LOOKS A LOT LIKE THE RESULT

00:08:36,649 --> 00:08:41,149
OF THE LINUX PS AUX COMMAND. THIS GIVES US A COMPLETE COMMAND LINE ARGUMENTS

00:08:41,149 --> 00:08:43,769
FOR EACH PROCESS, AS OPPOSED TO JUST A SHORT NAME.

00:08:43,769 --> 00:08:48,240
STILL NOTHING SUSPICIOUS, THOUGH. WE SHOULD REALLY ASK MORE EXPLICITLY.

00:08:48,240 --> 00:08:54,330
KERNEL, DO YOU KNOW ABOUT ANY PYTHON PROCESSES? AND IT LOOKS LIKE NO.

00:08:54,330 --> 00:08:57,720
SO THAT'S PRETTY UNFORTUNATE. THE KERNEL WAS PERFECTLY COOPERATIVE AND

00:08:57,720 --> 00:08:59,750
FORTHCOMING WITH US, THOUGH, WHICH MEANS THAT THE

00:08:59,750 --> 00:09:02,620
ROGUE PROCESS WE ARE LOOKING FOR MUST HAVE GIVEN

00:09:02,620 --> 00:09:05,870
THE KERNEL A FAKE NAME AND IT'S LYING TO THE KERNEL.

00:09:05,870 --> 00:09:10,959
LOOKS LIKE THIS WILL TAKE SOME MORE LEG WORK. SO LET'S HAVE A CLOSER LOOK AT THE RESOURCE

00:09:10,959 --> 00:09:15,280
THE KERNEL GIVES THE PROCESSES AND TRACK IT DOWN

00:09:15,280 --> 00:09:18,200
THAT WAY.

00:09:18,200 --> 00:09:20,580
MAYBE WE SHOULD LOOK AT THE OPEN FILES AND SOCKETS?

00:09:20,580 --> 00:09:22,700
SINCE THE KERNEL PROVIDES AND KEEPS TRACK OF THIS

00:09:22,700 --> 00:09:25,570
ACCESS, IT'S AVAILABLE TO US IN THE MEMORY DUMP,

00:09:25,570 --> 00:09:28,270
TOO. SO THE KERNEL HAS GIVEN US A LIST OF EVERY

00:09:28,270 --> 00:09:31,110
OPEN FILE ACCESSED BY EVERY PROCESS.

00:09:31,110 --> 00:09:35,270
LOOKING AT THIS, WHAT WOULD WE CONSIDER SUSPICIOUS?

00:09:35,270 --> 00:09:37,170
ONE OBVIOUS THING WOULD BE TO SEE IF THERE WERE

00:09:37,170 --> 00:09:42,690
ANY PROCESSES TRYING TO DELETE THE CASE FILES. WHICH THERE DOESN'T SEEM TO BE.

00:09:42,690 --> 00:09:44,550
BUT WE'D ONLY SEE THAT IF A PROCESS HAPPENED TO

00:09:44,550 --> 00:09:48,830
BE DOING THAT AT THE TIME OF THE MEMORY DUMP. PRIOR ACCESS THAT HAD FINISHED BY THE TIME

00:09:48,830 --> 00:09:52,970
THE MEMORY WAS ACQUIRED WOULD NOT EVEN SHOW UP.

00:09:52,970 --> 00:09:54,740
SIMILARLY WITH OPEN SOCKETS, WE CAN LOOK AT WHAT

00:09:54,740 --> 00:09:57,330
PROCESSES ARE LISTENING TO WHAT SOCKETS BUT ALSO

00:09:57,330 --> 00:09:59,370
THE CHIEF HAPPENS TO KNOW HER MOM'S I.P., NOTHING

00:09:59,370 --> 00:10:02,670
WOULD JUMP OUT AT US. AND UNLESS THE PROCESS WAS CONTACTING THE

00:10:02,670 --> 00:10:05,240
SERVER AT THE EXACT MOMENT OF THE MEMORY DUMP, WE

00:10:05,240 --> 00:10:07,649
WOULDN'T SEE IT, ANYWAY. OKAY.

00:10:07,649 --> 00:10:12,010
SO OPEN FILES AND SOCKETS ARE A DEAD END. WE SHOULD HAVE A CLOSER LOOK AT THE MEMORY

00:10:12,010 --> 00:10:14,180
RESOURCES THE KERNEL PROVIDES EACH PROCESS IT

00:10:14,180 --> 00:10:19,950
MANAGES, SO LET'S CHECK OUT THE MM STRUCT. WHICH SORT OF LOOKS LIKE THIS.

00:10:19,950 --> 00:10:22,829
ON THE LEFT IS WHAT PROCESS MEMORY GENERALLY LOOKS LIKE.

00:10:22,829 --> 00:10:26,800
THE TOP IS THE END OF THE PROCESS MEMORY WHERE THE HIGHEST ADDRESS IS AND THE BOTTOM IS THE

00:10:26,800 --> 00:10:31,880
BEGINNING OF PROCESS MEMORY WHERE ZERO IS. ON THE RIGHT IS PART OF THE ACTUAL STRUCT

00:10:31,880 --> 00:10:34,940
DECLARINGATION. THE MM INSTRUCT AN OH SAYS SEVERAL INTERESTING

00:10:34,940 --> 00:10:39,269
REGIONS OF A PROCESS MEMORY. THINK OF IT LIKE SAKES INS A LIBRARY, LIKE

00:10:39,269 --> 00:10:44,399
MYSTERIES OR SCIENCE FICTION. THERE'S THE ENVIRONMENT VARIABLE SECTION NEAR

00:10:44,399 --> 00:10:46,750
THE TOP WHICH HAS THE ENVIRONMENT VARIABLES THE

00:10:46,750 --> 00:10:49,080
PROCESS WAS STARTED WITH, THEN BELOW THAT, THERE

00:10:49,080 --> 00:10:50,900
IS THE COMMAND LINE ARGUMENTS THE PROCESS WAS

00:10:50,900 --> 00:10:53,650
STARTED WITH. THEN THERE'S THE STACK WHICH IS LIKE A SCRATCH

00:10:53,650 --> 00:10:57,950
PAD FOR PROCESSES, IT'S WHERE IT WRITES INCRIMINATING EVIDENCE.

00:10:57,950 --> 00:11:02,090
THIS IS WHERE PROGRAMS STORE CALL INFORMATION, ARGUMENTS AND RETURN VALUES.

00:11:02,090 --> 00:11:04,080
IT STARTS AT HIGHER ADDRESSES AND AS MORE THINGS

00:11:04,080 --> 00:11:08,670
ARE ADDED TO THE STACK, GROWS DOWNWARD. NEXT IS THE MEMORY MAP SECTION.

00:11:08,670 --> 00:11:11,080
THIS IS WHERE NECESSARY FILES LIKE LIBRARIES MAKE

00:11:11,080 --> 00:11:14,400
MMAP TO MEMORY. FOR PYTHON PROGRAM, C-EXTENSIONS WOULD BE

00:11:14,400 --> 00:11:15,400
MAPPED HERE.

00:11:15,400 --> 00:11:17,120
ADDITIONAL FILE MAPPINGS GET ADDED TO THE SECTION

00:11:17,120 --> 00:11:19,580
AT THE BOTTOM SO IT GOES DOWNWARDS LIKE THE STACK

00:11:19,580 --> 00:11:26,140
AND LOOKING AT IT COULD ALSO GIVE INCRIMINATING EVIDENCE, LIKE A BAD READING LIST.

00:11:26,140 --> 00:11:28,190
THEN COMES THE HEAP, WHICH FOR HISTORICAL REASONS

00:11:28,190 --> 00:11:31,900
IS REFERRED TO AS BRICK. THIS IS WHERE DYNAMICALLY ALLOCATED OBJECTS

00:11:31,900 --> 00:11:34,520
GO. IN PYTHON, THAT'S LIKE EVERY OBJECT, VERY

00:11:34,520 --> 00:11:36,110
MUCH EVER, ALL OF IT -- ALL OF IT GOES ON THE HEAP

00:11:36,110 --> 00:11:40,650
SO THAT'S REALLY WHERE WE WANT TO LOOK IF WE

00:11:40,650 --> 00:11:44,130
HAVE FIND A ROGUE PROCESS.

00:11:44,130 --> 00:11:48,390
IN THE NEXT SECTION, WE FIND THE DATA SEGMENT WHICH IS THE NON-INSTRUCTION PARTS OF THE

00:11:48,390 --> 00:11:49,620
PROCESS BINARY.

00:11:49,620 --> 00:11:53,730
IT'S THE GLOBAL AND STATIC VARIABLES OF THE BINARY, FOR THE PYTHON BINARY, THIS WILL MAKE

00:11:53,730 --> 00:11:58,920
LIKE C-PYTHON BUILT-IN DOC STRINGS. THE NEXT REGION IS THE EXECUTABLE MACHINE

00:11:58,920 --> 00:12:03,170
INSTRUCTION PART OF THE PROCESS BINARY. THIS IS THE PART OF THE PYTHON BINARY THAT

00:12:03,170 --> 00:12:09,390
ACTUALLY RUNS PYTHON. SO IF THOSE WERE LIKE LIBRARY SECTIONS, WHAT'S

00:12:09,390 --> 00:12:14,690
THE UNIT OF THING THAT'S BEING CATEGORIZED? WHAT'S THE MEMORY ANALOG TO A BOOK?

00:12:14,690 --> 00:12:16,960
THAT WOULD BE A VIRTUAL MEMORY AREA, WHICH IS A

00:12:16,960 --> 00:12:19,000
CONTIGUOUS AREA OF PROCESS MEMORY THAT HAS THE

00:12:19,000 --> 00:12:21,440
SAME PERMISSIONS AND ALLOWED OPERATIONS AND THAT

00:12:21,440 --> 00:12:26,110
IS MAPPED TO THE SAME FILE. THERE MIGHT BE MULTIPLE VIRTUAL MEMORY MEMORIES

00:12:26,110 --> 00:12:31,461
IN A SAME SECTION. ALSO NOTE THAT A SINGLE VIRTUAL MEMORY AREA

00:12:31,461 --> 00:12:33,610
COVERS THE ENVIRONMENT VARIABLE, THE COMMAND LINE

00:12:33,610 --> 00:12:37,190
ARGUMENTS AND THE STACK. IF YOU THINK ABOUT IT, ENVIRONMENT VARIABLES

00:12:37,190 --> 00:12:39,710
AND THE COMMANDS LINE ARGUMENTS ARE LIKE THE FIRST

00:12:39,710 --> 00:12:42,490
FUNCTION CALL TO THE PROCESS SO THAT SORT OF

00:12:42,490 --> 00:12:45,870
MAKES SENSE. SO IF THE KERNEL HAS TO KEEP LISTS OF WHICH

00:12:45,870 --> 00:12:48,870
VIRTUAL AREAS BELONG TO WHICH PROCESS, THAT'S HOW

00:12:48,870 --> 00:12:53,529
A LIBRARY KEEPS A RECORDS OF THE BOOKS THE PATRONS CHECK OUT, RIGHT?

00:12:53,529 --> 00:12:58,029
AND VOLATILITY CAN GET US ACCESS TO THIS BOOK LIST WITHOUT NEEDING A COURT ORDER, USING

00:12:58,029 --> 00:12:59,770
THE COMMAND PROR MAPS.

00:12:59,770 --> 00:13:05,990
THIS IS PERFECTLY LEGAL AND ABOVEBOARD. ON A LIVE LINUX SYSTEM, YOU CAN SEE THE SAME

00:13:05,990 --> 00:13:10,660
LIST USING THE PROC FILE IN PROC/PITT/MAPS.

00:13:10,660 --> 00:13:15,740
THIS SYSTEM PROVIDES USER SPACE A WAY TO GET INFORMATION ABOUT PROCESSES WITHOUT HAVING

00:13:15,740 --> 00:13:18,990
TO MAYBE SYSTEM CALLS TO THE KERNEL.

00:13:18,990 --> 00:13:25,400
EACH HAS A START AND END ADDRESS, A PERMISSIONS FLAG WHICH SPECIFIES WHICH OPERATIONS ARE

00:13:25,400 --> 00:13:27,570
ALLOWED FOR THE VIRTUAL MEMORY AREA.

00:13:27,570 --> 00:13:31,420
SEE HOW EACH OF THESE THREE AREAS HAVE DIFFERENT SET OF PERMISSIONS, EVEN THOUGH THEY'RE MAPPED

00:13:31,420 --> 00:13:35,420
THE EXACT SAME FILE? SPEAKING OF, THE VIRTUAL MEMORY AREA HAS A

00:13:35,420 --> 00:13:37,380
NAME WHICH MIGHT BE THE NAME OF THE FILE THAT'S

00:13:37,380 --> 00:13:41,150
MAPPED OR MIGHT BE SOMETHING LIKE KEEP OR STACK.

00:13:41,150 --> 00:13:42,870
THE FIRST NUMBER OF VIRTUAL MEMORY AREA IN THIS

00:13:42,870 --> 00:13:47,630
LIST IS THE SEGMENTS PART OF THE FILE BECAUSE IT'S EXECUTABLE AND NOT WRITABLE.

00:13:47,630 --> 00:13:51,340
THE SECONDS AND THIRD MEMORY AREAS FORM THE SEGMENTS, ONE BEING READ-ONLY AND THE OTHER

00:13:51,340 --> 00:13:52,340
BEING READS-WRITE.

00:13:52,340 --> 00:13:58,800
SO, GREAT, WE HAVE SOME VIRTUAL MEMORY AREAS MANAGED BY THE KERNEL BUT HOW DOES THIS HELP

00:13:58,800 --> 00:14:00,430
US FIND OUR ROGUE PROCESS?

00:14:00,430 --> 00:14:02,850
WELL, WE JUST HAVE TO USE THE INFORMATION THE

00:14:02,850 --> 00:14:04,820
KERNEL KEEPS ABOUT WHAT'S HAPPENED IN MEMORY TO

00:14:04,820 --> 00:14:10,410
CATCH ONE OF THESE PROCESSES IN A LIE. 6 ENGINEERED, ALL THE PROCESSES MANAGED BY

00:14:10,410 --> 00:14:13,320
THE KERNEL DENY THEY'RE PYTHON PROCESSES BUT DO

00:14:13,320 --> 00:14:15,589
ANY OF THEM ACTUALLY HAVE THE THE PROCESS MAPPED

00:14:15,589 --> 00:14:17,150
AS A PYTHON CODE?

00:14:17,150 --> 00:14:21,580
IF SO, THAT SEEMS LIKE A CLEAR INTENT TO DECEIVE AND WARRANTS SUSPICION.

00:14:21,580 --> 00:14:24,740
SO, LET'S GO TALK TO THE KERNEL AGAIN AND WE'RE

00:14:24,740 --> 00:14:30,170
GOING TO GO THROUGH ITS PAPERWORK FOR PROCESSES WITH A FINE-TOOTHED COMB.

00:14:30,170 --> 00:14:33,880
EACH AND EVERY PROCESS THAT THE KERNEL MANAGES, WHICH IS STORED IN A LINKED LIST THAT WE CAN

00:14:33,880 --> 00:14:39,850
CONVENIENTLY ACCESS USING THE ATTRIBUTE TASKS. FOR EACH PROCESS, WE WANT TO IDENTIFY THE

00:14:39,850 --> 00:14:42,029
VIRTUAL MEMORY AREA THAT CORRESPONDENCES WITH THE

00:14:42,029 --> 00:14:46,260
EXECUTABLE PART OF THE PROCESS BINARY. WE WANT TO FIND THE CODE SEGMENT.

00:14:46,260 --> 00:14:48,560
SO WE GO THROUGH ALL OF THE VIRTUAL MEMORY AREAS

00:14:48,560 --> 00:14:50,720
FOR THAT PROCESS, WHICH WE CAN OBTAIN USING THE

00:14:50,720 --> 00:14:55,600
FUNCTION GET PROC MAPS. AND WE FIND ONE WHOSE START AND END ADDRESSES

00:14:55,600 --> 00:15:01,370
MATCH THE SEGMENT CODE START AND END ADDRESSES, THAT'S THE CODE SEGMENT.

00:15:01,370 --> 00:15:03,279
SOME PROCESSES, MAINLY THE KERNEL THREADS, SHARE

00:15:03,279 --> 00:15:06,880
THE KERNEL'S ADDRESS SPACE SO DON'T HAVE CODE SEGMENTS THEMSELVES.

00:15:06,880 --> 00:15:10,000
WE WANT TO IGNORE THOSE. FOR NON-KERNEL THREADS, THERE ARE NOT AND

00:15:10,000 --> 00:15:13,050
ONLY BE VIRTUAL MEMORY AREA FOR THE CODE SEGMENTS,

00:15:13,050 --> 00:15:15,540
WHEN WE FIND IT, WE WANT TO PRINT IT OUT -- PRINT

00:15:15,540 --> 00:15:18,180
OUT THE VIRTUAL MEMORY AREA NAME ALONG WITH A

00:15:18,180 --> 00:15:20,630
PROCESS I.D. AROUND THE SHORT NAME.

00:15:20,630 --> 00:15:22,580
AND THEN WE CAN COMPARE WHAT EACH PROCESS CLAIMS

00:15:22,580 --> 00:15:26,089
ITS NAME IS WITH WHAT EACH EXECUTABLE PROCESS THE

00:15:26,089 --> 00:15:30,240
PROCESS HAS MAPPED. AND THAT'S WEIRD, THERE ARE TWO PROCESSES

00:15:30,240 --> 00:15:33,080
CLAIMING TO BE WHOOPSIE, THE UBUNTU ERROR REPORTER.

00:15:33,080 --> 00:15:40,720
ONE IS USER BIN WHOOPSIE, WHICH IS PRETTY STANDARD AND THE OTHER IS USING USER BIN PYTHON,

00:15:40,720 --> 00:15:47,020
AND WE ARE LOOKING FOR A PYTHON PROCESS. I THINK WE HAVE A VIABLE SUSPECT, GUMSHOES.

00:15:47,020 --> 00:15:50,710
NOW WE NEED TO BUILD OUR CASE. WE KNOW THE PROCESS HAS BEEN LYING TO THE

00:15:50,710 --> 00:15:52,970
KERNEL BUT THAT'S NOT A CRIME.

00:15:52,970 --> 00:15:55,310
AFTER ALL, OTHER LEGITIMATE PROCESSES ALSO LIE

00:15:55,310 --> 00:15:59,779
ABOUT THE NAME, THEY OVERWRITE THEIR OWN SHORT TASK NAME AND COMMAND LINE ARGUMENTS.

00:15:59,779 --> 00:16:05,910
FOR INSTANCE, POSTGRASS DOES THIS TO RUN THE QUERY IN SHHD DOES THIS TO SHOW WHO'S LOGGED

00:16:05,910 --> 00:16:08,460
ON, SO WE NEED TO LEARN MORE.

00:16:08,460 --> 00:16:14,240
WHAT ELSE HAS THIS PROCESS BEEN DOING? WE CAN OF COURSE ASK VOLATILITY TO INTERROGATE

00:16:14,240 --> 00:16:18,680
THE KERNEL ABOUT THIS PROCESS SPECIFICALLY, WHEREAS WE WERE ASKING ABOUT ALL PROCESSES

00:16:18,680 --> 00:16:22,570
BEFORE. FOR INSTANCE, WE CAN LOOK AT THE OPEN FILES

00:16:22,570 --> 00:16:24,200
THIS PROCESS WAS USING.

00:16:24,200 --> 00:16:25,860
LOOKS LIKE IT WAS PIPING SOMETHING TO DEV NULL AT

00:16:25,860 --> 00:16:30,260
THE TIME OF MEMBERRY ACQUISITION, NOT SUSPICIOUS BUT IT DOES INDICATE THAT IT WAS PROBABLY

00:16:30,260 --> 00:16:32,649
RUNNING IN THE BACKGROUND.

00:16:32,649 --> 00:16:36,649
WE CAN LOOK AT ANY OPEN SOCKETS THAT THIS PARTICULAR PROCESS HAD ACCESS TO.

00:16:36,649 --> 00:16:39,080
LOOKS LIKE NONE. AT THE TIME OF THE MEMORY ACQUISITION.

00:16:39,080 --> 00:16:41,050
AGAIN, THIS DOESN'T MEAN THAT THE PROCESS NEVER

00:16:41,050 --> 00:16:43,300
MADE ANY NETWORK CONNECTIONS, JUST MEANS IT WON'T

00:16:43,300 --> 00:16:47,850
DOING SO AT THE TIME OF THE MEMORY DUMP. OKAY, SO LET'S HAVE A CLOSER LOOK AT THE PROCESS

00:16:47,850 --> 00:16:50,779
BINARIES. OH, LOOK, IT WAS USING THE PYTHON LIBRARY

00:16:50,779 --> 00:16:52,120
SET PROC TITLE.

00:16:52,120 --> 00:16:55,800
THIS IS A LIBRARY THAT PROVIDES AN API TO OVERRIDE A PROCESS NAME AND COMMAND LINE

00:16:55,800 --> 00:17:00,790
ARGUMENTS SO THAT'S HOW IT HID ITSELF. WE STILL DON'T KNOW ANYTHING USEFUL ABOUT

00:17:00,790 --> 00:17:02,750
THE PROCESS'S INTENTIONS, THOUGH, OR WHAT IT DID

00:17:02,750 --> 00:17:05,530
BEFORE THE CHIEF ACQUIRED THE MEMORY DUMP SO

00:17:05,530 --> 00:17:08,251
LET'S LOOK AT THE PROCESS'S BOOKS, NAMELY STACK

00:17:08,251 --> 00:17:11,620
AND HYPE. THERE MIGHT BE INCRIMINATING EVIDENCE IN THERE.

00:17:11,620 --> 00:17:13,550
WE HAVE THE START AND END ADDRESSES HERE SO WE

00:17:13,550 --> 00:17:15,910
CAN TAKE THE FILE THE CHIEF GAVE US, SEEK TO THE

00:17:15,910 --> 00:17:18,339
START ADDRESS AND READ UNTIL THE ENDS ADDRESS, RIGHT?

00:17:18,339 --> 00:17:22,209
SO LET'S START WITH THE STACK. THERE'S ONE PROBLEM.

00:17:22,209 --> 00:17:28,329
THE ADDRESSES ARE REALLY, REALLY BIG. THAT WOULD MEAN THE STACK IS ALMOST 141,000

00:17:28,329 --> 00:17:31,570
GIGABYTES INTO THE MEMORY DUMP BUT THAT'S ONLY 2

00:17:31,570 --> 00:17:34,750
GIGABYTES, SO WHAT GIVES? ARE THE KERNEL'S RECORDS WRONG?

00:17:34,750 --> 00:17:37,539
IS IT IN ON THE WHOLE THING AND IMPEDING OUR INVESTIGATION?

00:17:37,539 --> 00:17:43,800
NO, ACTUALLY, NO, IT ISN'T. WE'RE JUST INTERPRETING THE ADDRESSES WRONG.

00:17:43,800 --> 00:17:46,220
ALL THE ADDRESSES OF THE KERNEL LAST GIVEN US ARE

00:17:46,220 --> 00:17:52,080
VIRTUAL ADDRESSES. NOT PHYSICAL ADDRESSES OR OFFSETS INTO RAM.

00:17:52,080 --> 00:17:56,350
A PROCESSES OWN MEMORY IS ONE LARGE CONTIGUOUS BLOCK CALLED THE PROCESS ADDRESS SPACE OR

00:17:56,350 --> 00:17:59,550
PROCESS MEMORY AND ONLY EVER DEALS WITH VIRTUAL ADDRESSES

00:17:59,550 --> 00:18:03,191
IN ITS OWN ADDRESS SPACE. THAT'S THE ADDRESS YOU'LL GET IN GDB OR IF

00:18:03,191 --> 00:18:06,150
YOU REFER AN OBJECT IN PYTHON AND USUALLY REPRESENTED

00:18:06,150 --> 00:18:12,630
IN HEXADECIMAL FORM. IT'S NOT CONTIGUOUS IN PHYSICAL MEMORY, THOUGH,

00:18:12,630 --> 00:18:14,440
IT'S SLICED UP BY THE OPERATING SYSTEM INTO TINY

00:18:14,440 --> 00:18:19,000
CHUNKS CALLED PAGES BY ARE ABOUT FOUR KILOBYTES EACH, COULD BE LARGER.

00:18:19,000 --> 00:18:20,940
EACH PAGE MAYBE MAPPED TO A DIFFERENT PORTION OF

00:18:20,940 --> 00:18:24,760
THE PHYSICAL SPACE OR RAM. OR MIGHT NOT BE MAPPED AT ALL.

00:18:24,760 --> 00:18:29,580
MOST OF OUR PROCESSES SPACE IS NOT USED. YOU SAW THE STACK'S VIRTUAL ADDRESSES, LARGE

00:18:29,580 --> 00:18:33,180
NUMBERS, WHICH MEANS THE PROCESS IS BIGGER THAN

00:18:33,180 --> 00:18:36,880
RAM. SO WHY WASTE PHYSICAL MEMORY ON SPACE.

00:18:36,880 --> 00:18:39,850
EVEN THE PAGES THAT ARE USED MIGHT NOT BE CURRENTLY MAPPED TO PHYSICAL MEMORY.

00:18:39,850 --> 00:18:44,490
THEY MIGHT BE SWAPPED OUT TO DISK OR COMPRESSED IF THE PROCESS DOESN'T NEED THEM IMMEDIATELY.

00:18:44,490 --> 00:18:46,559
EACH PROCESS USES ONLY THE MEMORY THAT IT NEEDS

00:18:46,559 --> 00:18:51,350
WHEN IT NEEDS IT, THAT'S WHAT ALLOWS MANY PROCESSES, EACH HAVING A HUGE ADDRESS SPACE

00:18:51,350 --> 00:18:56,130
IS TO SHARE A LIMITED AMOUNT OF PHYSICAL MEMORY.

00:18:56,130 --> 00:18:57,990
THE REASON A PROCESS CAN PRETENDS THAT ITS MEMORY

00:18:57,990 --> 00:19:01,529
IS ONE GIANT CONTIGUOUS BLOCK IS THAT WHENEVER IT

00:19:01,529 --> 00:19:04,220
ACTS AS DATA AT A VIRTUAL ADDRESS, THE MMYOU WANT

00:19:04,220 --> 00:19:09,179
UOR MEMBER -- MEMBER BRING MANAGE. UNIT TRANSLATES THE ADDRESS INTO A PHYSICAL

00:19:09,179 --> 00:19:14,560
ADDRESS AND IF THE ADDRESS HAS BEEN TRANSLATED BEFORE, IT MIGHT BE CAMPED IN THE TLB OR

00:19:14,560 --> 00:19:17,350
TRANSLATION LOOK-ASIDE BUFFER INSTEAD OF BEING RETRANSLATED.

00:19:17,350 --> 00:19:23,080
IF THE DATA HAS BEEN SWAPPED OUT, IT'S SWAPPED BACK IN SO THE PROCESS CAN ACCESS IT AND ALL

00:19:23,080 --> 00:19:25,380
THIS HAPPENS TRANSPARENTLY TO THE PROCESS.

00:19:25,380 --> 00:19:31,190
WHO HAS NO IDEA ANY OF THIS IS GOING ON. VOLATILITY CAN ALSO TRANSLATE A VIRTUAL ADDRESS

00:19:31,190 --> 00:19:33,919
INTO A PHYSICAL ADDRESS. WE COULD JUST ASK IT TO DO THE TRANSLATION

00:19:33,919 --> 00:19:36,470
TORE US, TO GET US A STACK AND HEAP AND WE WILL

00:19:36,470 --> 00:19:39,100
DO THAT BUT ACME IS THE KIND OF ORGANIZATION

00:19:39,100 --> 00:19:41,070
THAT PROVIDES ACCOUNTABILITIES AND OVERSIGHT FOR

00:19:41,070 --> 00:19:47,360
CONTRACTORS, SOMETHING, SOMETHING -- SOMETHING-SOMETHING FRUIT OF THE POISON TREE,

00:19:47,360 --> 00:19:50,280
WE CAN'T LET VOLATILITY BLINDLY GET US THE EVIDENCE,

00:19:50,280 --> 00:19:56,749
WE HAVE TO UNDERSTAND HOW TRANSLATION WORKS. IN SOME CASES, IT MIGHT BE VERY SIMPLE.

00:19:56,749 --> 00:19:58,860
FOR EXAMPLE, ON LINUX AND OS 10, THE CODE AND

00:19:58,860 --> 00:20:01,529
DATA SEGMENTS OF THE KERNEL ADDRESS SPACE ARE

00:20:01,529 --> 00:20:06,080
IDENTITY-MAPPED, WHICH MEANS THAT WHILE THOSE REGIONS ARE STILL DIVIDE UP INTO PAGES, THOSE

00:20:06,080 --> 00:20:09,019
PAGES AREN'T SCATTERED EVERYWHERE THROUGH PHYSICAL MEMORY.

00:20:09,019 --> 00:20:12,179
THEY'RE LAID OUT IN THE SAME ORDER AS IN PROCESS MEMBER RIFF.

00:20:12,179 --> 00:20:18,029
BUT THAT'S ONLY THE IDENTITY MAPPED REGIONS. THE OTHER REGIONS ARE STILL SORT OF SCATTERED.

00:20:18,029 --> 00:20:22,740
FOR THE IDENTITIES MAPPED REGIONS, THE VIRTUAL ADDRESS IS THE PHYSICAL ADDRESS PLUS CONSTANT

00:20:22,740 --> 00:20:28,510
OFF-SET, WHICH IS FOR 64 BIT SYSTEMS. THE 32-BIT IS RECEIVE.

00:20:28,510 --> 00:20:35,389
IS THE SPACE RANDOMIZATION IS SUPPORTED, ASLR, AS

00:20:35,389 --> 00:20:40,070
IT IS IN NEWER VERSIONS, OTHER RANDOM CONSTANT ALSO GETS ADDED.

00:20:40,070 --> 00:20:43,740
THE RANDOM OFF IF SET HELPS MITIGATES BUFFER OVERFLOW ATTACKS BY MAKING IT HARD FOR CRITICAL

00:20:43,740 --> 00:20:47,710
ADDRESSES TO BE GUESSED. SO THE VIRTUAL TO PHYSICAL ADDRESS TRANSLATION

00:20:47,710 --> 00:20:51,639
FOR IDENTITY MAPPED SEGMENTS JUST MEANS SUBTRACTING SOME CONSTANT.

00:20:51,639 --> 00:20:53,990
BUT WHAT ABOUT THE PARTS OF KERNEL MEMORY THAT

00:20:53,990 --> 00:20:59,240
ARE NOT IDENTITY MAPPED OR NON-KERNEL PROCESSES WHICH ARE ALSO NOT IDENTITIES MAPPED.

00:20:59,240 --> 00:21:02,110
WELL, BY ITSELF, A VIRTUAL ADDRESS IS JUST AN

00:21:02,110 --> 00:21:05,149
OFFSET INTO THE PROCESS ADDRESS SPACE, BUT IT CAN

00:21:05,149 --> 00:21:07,649
BE SPLIT INTO A SERIES OF FIVE NUMBERS LIKE THIS

00:21:07,649 --> 00:21:12,809
THAT ARE USED IN ADDRESS TRANSLATION AND THIS DIVISION AGAIN ONLY APPLIES TO 64-BIT SYSTEMS,

00:21:12,809 --> 00:21:17,039
THEY'RE DIVIDED UP DIFFERENTLY AND IN FEWER PIECES ON 32-BIT SYSTEMS BUT THE PROCESS IS

00:21:17,039 --> 00:21:18,149
THE SAME.

00:21:18,149 --> 00:21:24,139
HERE, ONLY 48 BITS ARE USED FOR TRANSLATION. THE TOP 16 BITS SHOWN HERE IN BLACK ARE EITHER

00:21:24,139 --> 00:21:29,480
ALL ONES OR ZEROS AND THEY'RE THROWN AWAY. THESE NUMBERS, TOGETHER WITH SOME EXTRA

00:21:29,480 --> 00:21:31,940
INFORMATION, KIND OF WORK LIKE REAL-WORLD MAILING

00:21:31,940 --> 00:21:36,039
ADDRESSES. IN MOST COUNTRIES, MAILING ADDRESS LOOKS LIKE

00:21:36,039 --> 00:21:40,059
THIS, MODULO SOME FORMATTING. THERE ARE MULTIPLE DESCRIPTION ATTENTION OF

00:21:40,059 --> 00:21:41,710
A LOCATION, IN OTHER WORDS OF DECREASING

00:21:41,710 --> 00:21:45,049
SPECIFICITY. EACH DESCRIPTION IN THIS ADDRESS LETS US NARROW

00:21:45,049 --> 00:21:49,220
DOWN THE SEARCH. SO LET'S START WITH THE MOST SPECIFIC INFORMATION

00:21:49,220 --> 00:21:54,019
IN THE VIRTUAL ADDRESS, THE LAST 12 BITS. THIS IS LIKE THE APARTMENT NUMBER OF A VIRTUAL

00:21:54,019 --> 00:21:56,570
ADDRESS. AN APARTMENT NUMBER IDENTIFIES AN APARTMENT

00:21:56,570 --> 00:21:59,330
IN A BUILDING, THE LAST 12 BITS OF THE VIRTUAL

00:21:59,330 --> 00:22:01,510
ADDRESS IDENTIFY A BYTE IN A PAGE.

00:22:01,510 --> 00:22:06,029
I'VE MARKED THAT BYTE WITH AN X. THE RESULT OF THE TRANSLATION IS JUST THE

00:22:06,029 --> 00:22:11,389
PHYSICAL ADDRESS OF THAT X WHICH IS THE PHYSICAL ADDRESS OF THE PAGE PLUS THE 12-BIT OFFSET.

00:22:11,389 --> 00:22:13,490
BUT JUST LIKE THERE ARE MANY BUILDINGS IN THE

00:22:13,490 --> 00:22:18,019
WORLD, A PROCESS CAN HAVE MANY PAGES. SO WE NEED TO NARROW IT DOWN.

00:22:18,019 --> 00:22:19,799
THE NINE BITS IN GREEN IS LIKE THE STREET ADDRESS

00:22:19,799 --> 00:22:22,559
WHICH IDENTIFIES WHICH BUILDING HAS THE APARTMENT.

00:22:22,559 --> 00:22:25,429
THE PROCESS HAS A TABLE CALLED A PAGE TABLE THAT

00:22:25,429 --> 00:22:30,100
HAS A LIST OF PAGE ADDRESSES, THE GREEN BITS IDENTIFY THE RIGHT PAGE IN THAT LIST, THE

00:22:30,100 --> 00:22:32,220
PAGE THAT HAS THE DATA THAT WE'RE LOOKING FOR.

00:22:32,220 --> 00:22:36,780
ACTUALLY, NO, THE PROCESS HAS MANY PAGE TABLES, KIND OF LIKE HOW THERE ARE MANY STREETS IN

00:22:36,780 --> 00:22:38,440
THE WORLD NAMED MAIN.

00:22:38,440 --> 00:22:42,450
THE PROCESS DOES HAVE A TABLE OF TABLES, THOUGH, CALLED A PAGE DIRECTORY.

00:22:42,450 --> 00:22:44,309
IT LISTS PAGE TABLE ADDRESSES AND THE NINE BITS

00:22:44,309 --> 00:22:47,110
IN PURPLE IDENTIFY WHICH OF THOSE PAGE TABLES HAS

00:22:47,110 --> 00:22:50,770
THE PAGE WE'RE LOOKING FOR. ACTUALLY, NO, THERE ARE MANY PAGE DIRECTORIES

00:22:50,770 --> 00:22:53,119
ASSOCIATED WITH THE PROCESS AND YOU PROBABLY SEE

00:22:53,119 --> 00:22:55,110
WHERE I'M GOING WITH THIS SO LET ME SPOIL THE

00:22:55,110 --> 00:22:58,840
ENDING. EACH PROCESS HAS A TABLE OF TABLES OF TABLES

00:22:58,840 --> 00:23:00,639
OF TABLES OF PAGES.

00:23:00,639 --> 00:23:04,239
A FIVE-LEVEL SPARSE TREE OF TABLES. THE POINT S THEY NEED TO BE TRAVERSED USING

00:23:04,239 --> 00:23:06,179
THE NUMBERS IN THE ADDRESS TO GET TO A SINGLE

00:23:06,179 --> 00:23:09,980
PAGE WHICH WE CAN INDEX TO USING THE LAST 12 BITS.

00:23:09,980 --> 00:23:12,809
THE INTERVENING TABLE FLAMES DON'T MATTER BUT WE

00:23:12,809 --> 00:23:17,850
DO CARE ABOUT THE PER-PROCESS TOP LEVEL, WHILE THE VOLUME TAKE IT REFERRING TO IT AS THE

00:23:17,850 --> 00:23:21,101
DIRECTORY TABLE AND THE ADDRESS AS THE DTB OR

00:23:21,101 --> 00:23:24,580
DIRECTORY TABLE BASE. BECAUSE NO ONE CAN AGREE ON A THREE-LETTER

00:23:24,580 --> 00:23:27,740
ACRONYM, THE LINUX KERNEL REFERS TO IT AS THE

00:23:27,740 --> 00:23:33,040
PGD, PAGE TABLE DIRECTORY. WHOSE ADDRESS IS STORED IN EACH PROCESSES

00:23:33,040 --> 00:23:35,230
MM STRUCT.

00:23:35,230 --> 00:23:37,490
WITHOUT ACCESS TO THE TOP LEVEL TABLE, THERE IS

00:23:37,490 --> 00:23:40,600
NO ADDRESS TRANSLATION, AND SO THE KERNEL HAS

00:23:40,600 --> 00:23:42,139
ONE, TOO, FOR THE PARTS OF MEMORY THAT ARE NOT

00:23:42,139 --> 00:23:46,119
IDENTITY MAPPED. THE KERNEL'S DTB CAN BE FOUND IN THE SYMBOL

00:23:46,119 --> 00:23:48,940
THAT WE GAVE TO VOLATILITY, WHICH IT CAREFULLY

00:23:48,940 --> 00:23:50,739
DOCUMENTS HERE AT THE ENDS WHEN IT BRINGS US

00:23:50,739 --> 00:23:55,549
TASKS FOR INTERROGATION, FOR CHAIN OF EVIDENCE REASONS WHICH IS WHAT WE HERE AT ACME LIKE

00:23:55,549 --> 00:23:57,970
TO SEE.

00:23:57,970 --> 00:24:00,090
SO NOW THAT WE UNDERSTAND ADDRESS TRANSLATION AND

00:24:00,090 --> 00:24:05,130
WE SATISFIED OUR REGULATORY OVERSIGHT REQUIREMENTS, LET'S ASK VOLATILITY TO GET

00:24:05,130 --> 00:24:06,379
US THE STACK.

00:24:06,379 --> 00:24:09,259
WE JUST NEED TO NOTE THE START ADDRESS AND TELL

00:24:09,259 --> 00:24:11,120
VOLATILITY TO DUMP THE VIRTUAL MEMORY AREA THAT

00:24:11,120 --> 00:24:14,480
STARTS WITH THAT ADDRESS. IT WILL FIND AND READ EVERY PAGE ASSOCIATED

00:24:14,480 --> 00:24:17,590
WITH THAT VIRTUAL MEMORY AREA AND DUMP THEM INTO

00:24:17,590 --> 00:24:21,289
ONE SINGLE CONTIGUOUS BUY ENGINEER FILE.

00:24:21,289 --> 00:24:22,999
WHICH WE CAN LOOK AT USING STRINGS, WHICH IS A

00:24:22,999 --> 00:24:29,399
POSIX COMMAND FOR A SERIES OF FOUR OR MORE CHARACTERS ENDING WITH A NEW LINE OR NULL.

00:24:29,399 --> 00:24:31,940
BASICALLY HUMAN READABLE STRINGS, BUT THERE ARE A

00:24:31,940 --> 00:24:34,260
LOT OF FALSE POSITIVES WHICH ENDS UP GIVING US A

00:24:34,260 --> 00:24:41,180
BUNCH OF GARBAGE BUT ALSO RELEVANT DATA. REMEMBER WE -- THAT IT WAS PART OF THE STACK

00:24:41,180 --> 00:24:46,070
VIRTUAL MEMORY. THE ARGUMENTS ARE OVERWRITTEN TO BE WHOOPSIE

00:24:46,070 --> 00:24:49,299
BUT THE ACTUAL COMMANDS IS SHOWN IN THE VARIABLE

00:24:49,299 --> 00:24:51,110
LIST AS AN UNDERSCORE.

00:24:51,110 --> 00:24:54,960
IT LOOKS LIKE PYTHON RUN WITH NO HUB WHICH LETS A

00:24:54,960 --> 00:24:57,109
PROCESS RUN IN THE BACKGROUNDS WITHOUT DOING WHEN

00:24:57,109 --> 00:25:02,720
THE CONTROLLING TERMINAL IS CLOSED. SO NOW WORK DO THE SAME THING WITH HEAP BUT

00:25:02,720 --> 00:25:04,600
WOULDN'T IT BE NICE IF WE COULD REALLY GET INTO

00:25:04,600 --> 00:25:07,059
THE PROCESS'S MINDS, UNDERSTAND THE OBJECTS THAT

00:25:07,059 --> 00:25:11,000
IT WAS THROWING IN THERE? IF SO, WE NEEDS TO LEARN TO SPEAK ITS LANGUAGE.

00:25:11,000 --> 00:25:16,629
THE LANGUAGE OF PYTHON OBJECTS, AND THAT LANGUAGE IS C, BECAUSE THIS IS CPYTHON, WHICH MEANS

00:25:16,629 --> 00:25:20,519
THAT PYTHON OBJECTS IN THE HEAP ARE C-DATA STRUCTURES.

00:25:20,519 --> 00:25:22,779
WE MENTION C-STRUCTS BEFORE, THAT THERAPY COMPLEX

00:25:22,779 --> 00:25:32,330
DATA STRUCTURES COMPOSTED OF OTHERS, AND THEIR MEMBERS ARE TYPES, UNLIKE THE TOUPOs.

00:25:32,330 --> 00:25:35,890
THAT'S ALL TRUE. BUT SINCE WE WANT TO INTERPRET PARTS OF THE

00:25:35,890 --> 00:25:38,299
HEAP AS C-DATA STRUCKORS, WHAT'S MORE IMPORTANT

00:25:38,299 --> 00:25:40,980
IS THAT IT'S A PACKING FORMULA FOR BYTES.

00:25:40,980 --> 00:25:43,109
WE NEED TO KNOW WHAT ORDER THE BYTES APPEAR IN

00:25:43,109 --> 00:25:49,809
AND HOW MANY OF THEM THERE ARE. FOR EXAMPLE, THIS IS A STRUCT DECLARINGATION

00:25:49,809 --> 00:25:53,129
BECAUSE OF THE TYPE DECLARATION, WE KNOW EXACTLY WHAT IT SHOULD LOOK LIKE IN MEMORY, EIGHT

00:25:53,129 --> 00:25:56,510
BYTES OF DATA BECAUSE IT HAS TWO 4-BYTE INTEGERS.

00:25:56,510 --> 00:25:58,330
ANY EIGHT CONTIGUOUS BYTES OF MEMORY WOULD FIT

00:25:58,330 --> 00:26:02,559
INTO THE STRUCT. SO LET'S TAKE THE SNIPPETS OF MEMORY WHERE

00:26:02,559 --> 00:26:05,400
THE OFFSETS ARE SHOWN IN BLUE.

00:26:05,400 --> 00:26:09,379
IF WE WERE TO INTERPRET THE BEGINNING OF THIS CHUNK OF MEMORY AT OFFSETS ZERO AS A POINT

00:26:09,379 --> 00:26:12,279
STRUCTURE, WE WOULD END UP WITH ACTION -- AXIS THREE AND Y IS TWO.

00:26:12,279 --> 00:26:18,009
WHICH IS COOL. HOWEVER THE PART THAT STARTS AT ONE ALSO FIT

00:26:18,009 --> 00:26:19,309
INTO THE POINT STRUCTURE.

00:26:19,309 --> 00:26:23,509
XA BEYOND ARE REALLY WEIRD SO, IS THIS A VALID POINT?

00:26:23,509 --> 00:26:28,179
TECHNICALLY, YES, BECAUSE THEY'RE INTEGERS. BUT LET'S SAY THAT THE POINTS REPRESENTED

00:26:28,179 --> 00:26:30,429
BY THE STRUCT MUST FALL INSIDE A CIRCLE OF RADIUS

00:26:30,429 --> 00:26:32,879
10. IN THAT CASE, THIS ISN'T A VALID POINT, EVEN

00:26:32,879 --> 00:26:36,559
THOUGHT IT'S A VALID POINT STRUCTURE. WE NEED SOME KIND OF VALIDATION CHECK TO MAKE

00:26:36,559 --> 00:26:38,960
SURE THAT X AND Y ARE CORRECT, INDEPENDENTLY OF

00:26:38,960 --> 00:26:43,630
WHETHER THE BYTES ARE CORRECT. SO THAT IN MIND, LET'S LOOK AT HOW MANY BYTES

00:26:43,630 --> 00:26:45,580
ARE IN A PYTHON STRING OBJECT.

00:26:45,580 --> 00:26:49,340
THIS IS GENERIC APPROXIMATION OF THE PYTHON 2.7

00:26:49,340 --> 00:26:53,769
PY STRING OBJECT. I'M SORRY, CPYTHON DEVELOPERS SKIPPING OVER

00:26:53,769 --> 00:26:56,580
SOME STUFF BECAUSE WE'RE RACING THE CLOCK HERE.

00:26:56,580 --> 00:27:00,860
I WANT TO POINT OUT A COME OF THINGS. FIRST THE STATE IS A NUMBER RATION OF ONE

00:27:00,860 --> 00:27:03,149
OR TWO. WE NEEDS TO VALIDATE THAT.

00:27:03,149 --> 00:27:07,899
SECOND, THE CHARACTER ARRAY IS OF SIZE ONE SO

00:27:07,899 --> 00:27:09,679
THAT'S THE FIRST CHARACTER OF THE STRING, WHICH

00:27:09,679 --> 00:27:14,299
IS NULL TERMINATED AND THE REST OF THE STRING FOLLOWS IMMEDIATELY AFTER THE STRUCT.

00:27:14,299 --> 00:27:17,690
THIS IS DOCUMENTED IN A COMMENT TO THE CPYTHON SOURCE.

00:27:17,690 --> 00:27:20,629
BUT VOLATILITY CAN'T ACCEPT A C-STRUCT LIKE THIS.

00:27:20,629 --> 00:27:24,519
WE NEED TO TRANSLATE THE DESCRIPTION INTO SOMETHING THAT VOLATILITY UNDERSTANDS, WHICH

00:27:24,519 --> 00:27:26,729
IT CALLS THE V-TYPE.

00:27:26,729 --> 00:27:29,499
WHICH IS BASICALLY THE SAME STRUCT DEFINITION BUT

00:27:29,499 --> 00:27:33,950
AS A BUNCH OF PYTHON ARRAYS ANNOTATED WITH INFORMATION ABOUT THE SIZE OF THE STRUCT AND

00:27:33,950 --> 00:27:35,580
THE OFFSETS OF THE MEMBERS.

00:27:35,580 --> 00:27:39,440
THE TOTAL SIZE OF THE STRUCT AS IT WAS DECLARED IN C IS 37 BYTES.

00:27:39,440 --> 00:27:41,529
WE KNOW THAT FROM ADDING UP THE SIZES OF ALL THE

00:27:41,529 --> 00:27:44,500
MEMBERS. FOR EXAMPLE, OBJECT REV COUNT WAS THE FIRST

00:27:44,500 --> 00:27:47,639
MEMBER OF THE STRUCT DISKS WAS SPECIFIC SET ZERO,

00:27:47,639 --> 00:27:50,080
OF TYPE LONG, WHICH IS BASICALLY A REALLY BIG

00:27:50,080 --> 00:27:54,649
NUMBER. REMEMBER HOW WE SAID THAT -- WHICH IS WHY

00:27:54,649 --> 00:27:59,739
THE NEXT MEMBER OB TYPE STARTS AT 8 AND SO FORTH.

00:27:59,739 --> 00:28:02,529
BUT ANY SEQUENCE OF 37 BYTES WILL FIT INTO THIS

00:28:02,529 --> 00:28:04,409
STRUCT, WHETHER OR NOT THE VALUES MAKE SENSE SO,

00:28:04,409 --> 00:28:08,690
WE NEED TO TELL VOLATILITY HOW TO VALIDATE WHETHER THERE IS 37 BYTE CHUNK OF MEMORY IS

00:28:08,690 --> 00:28:13,899
REALLY A PYTHON STRING. SO WE READ THE STRING, WHICH IS 36 BYTES FROM

00:28:13,899 --> 00:28:15,529
THE BEGINNING OF THIS OBJECT BECAUSE, REMEMBER,

00:28:15,529 --> 00:28:17,210
THE FIRST CHARACTER OF THE THING WAS THE LAST

00:28:17,210 --> 00:28:20,269
BYTE OF THE PY STRING OBJECT.

00:28:20,269 --> 00:28:25,919
AND WE SEE IF IT'S A VALID PYTHON STRING. THE TYPE POINTER HAS TO BE A VALID POINTER.

00:28:25,919 --> 00:28:28,289
VOLATILITY KNOWS ALL ABOUT POINTER OBJECTS AND

00:28:28,289 --> 00:28:31,080
PROVIDES A VALIDITY CHECK THAT ENSURES THAT IT

00:28:31,080 --> 00:28:36,049
POINTS TO SOMETHING THAT'S INSIDE THE HEAP. THE SIZE OF THE STRING ALSO NEEDS TO BE

00:28:36,049 --> 00:28:40,710
NON-NEGATIVE AND WE CAN SKIP EMPTY STRINGS BECAUSE WE DON'T CARE ABOUT THEM AND TO SPEED

00:28:40,710 --> 00:28:44,440
THINGS UP, LET'S IGNORE REALLY LARGE STRINGS, TOO.

00:28:44,440 --> 00:28:47,799
THE STATE HAS TO BE ZERO, ONE OR TWO AS WE MENTIONED BEFORE.

00:28:47,799 --> 00:28:49,539
AND THE STRING HAS TO BE NULL-TERMINATED AS WE

00:28:49,539 --> 00:28:53,230
MENTIONED BEFORE. AND HASH EITHER HAS TO BE NEGATIVE 1, WHICH

00:28:53,230 --> 00:28:55,720
MEANS IT HASN'T BEEN COMPUTED YET OR IT HAS TO BE

00:28:55,720 --> 00:28:58,140
THE ACTUAL HASH OF THE STRING.

00:28:58,140 --> 00:28:59,830
AND WE COMPLETELY IGNORE REV COUNTS BECAUSE WE

00:28:59,830 --> 00:29:04,799
HAVE TO FIND GARBAGE-COLLECTED STRINGS. AND THEN HERE'S SOME PSEUDO COUNT THAT TELLS

00:29:04,799 --> 00:29:09,149
VOLATILITY TO BROUGHT-FORCE SEARCH THE WHOLE HEAP, BY TESTING EVERY SEQUENCE OF 37 BYTES

00:29:09,149 --> 00:29:13,340
IN THE HEAP FOR PY STRING OBJECT VALIDITY.

00:29:13,340 --> 00:29:15,700
SO NOW WHEN WE RUN IT, IT WILL DISPLAY THE ACTUAL

00:29:15,700 --> 00:29:18,350
PYTHON STRINGS FROM THE HEAP WHICH INCLUDES A TON

00:29:18,350 --> 00:29:23,159
OF PYTHON DOC STRINGS. BUT SOMETIMES YOU CAN FIND USEFUL INFORMATION,

00:29:23,159 --> 00:29:27,479
MAYBE IN THE FORM OF A GARBAGE COLLECTED STRING. IT LOOKS LIKE OUR PROCESS HAD PREVIOUSLY MADE

00:29:27,479 --> 00:29:30,029
AN HTTP REQUEST, NET STATS SHOWED NO CURRENT

00:29:30,029 --> 00:29:32,190
CONNECTIONS BUT WILL BELY THIS REQUEST IS STILL

00:29:32,190 --> 00:29:35,920
IN THE HEAP SO WE CAN LOOK AT IT. WE WOULD STILL SEE IT LIKE THIS EVEN IF IT

00:29:35,920 --> 00:29:38,659
WAS MADE OVER HTTPS BECAUSE THIS IS THE RAW REQUEST

00:29:38,659 --> 00:29:44,110
BEFORE IT'S END COPYRIGHTED OWNED WIRE. NOTE THE BASIC AUTHORIZATION HEADER.

00:29:44,110 --> 00:29:49,190
BASIC AUTHORIZATION ENCODES USER NAME AND PASSWORDS SEPARATED BY A COLON, WHICH MEANS

00:29:49,190 --> 00:29:51,460
WE CAN 64 DECODE IT AND GET THE USER NAME AND

00:29:51,460 --> 00:29:55,399
PASSWORD. I THINK THIS IS PRETTY INCRIMINATING AND A

00:29:55,399 --> 00:29:59,929
MESSAGE TO THE CHIEF. I KNOW WHAT YOU'RE PROBABLY THINKING, COULDN'T

00:29:59,929 --> 00:30:02,440
WE HAVE GOTTEN THIS INFORMATION USING THE STRING'S

00:30:02,440 --> 00:30:05,730
COMMAND? YES, WE WOULD HAVE, BOTH THE DOC STRINGS AND

00:30:05,730 --> 00:30:08,129
THE REQUEST, SO WHY DID WE BOTHER GOING TO ALL

00:30:08,129 --> 00:30:10,230
THIS TROUBLE?

00:30:10,230 --> 00:30:11,899
FINDING PYTHON STRINGS TELLS US SOMETHING ABOUT

00:30:11,899 --> 00:30:13,860
THE STRING BOUNDARIES, IF THAT REQUEST WAS NOT

00:30:13,860 --> 00:30:15,850
ONE STRING BUT MULTIPLE STRINGS, THAT MIGHT HAVE

00:30:15,850 --> 00:30:21,019
BEEN MINUTES SOMETHING COMPLETELY DIFFERENT. STRINGS ALSO ONLY RETURNS ASCII BUT WITH PYTHON

00:30:21,019 --> 00:30:22,570
STRINGS WE MIGHT BE ABLE TO SEE BYTES REDS INTO

00:30:22,570 --> 00:30:27,999
THE PROCESS FROM A FILE, LIKE AN IMAGE. ALSO WITH PYTHON THINGS, MORE FILTER AROUND

00:30:27,999 --> 00:30:29,470
THE LIFE CYCLE.

00:30:29,470 --> 00:30:36,830
MAYBE WE COULD TO EXCLUDE PYTHON STRINGS. AND IT USES VOLATILITY CHECKS TO FIND ALMOST

00:30:36,830 --> 00:30:41,960
ANYTHING, KERNEL STRUCTURES, MODULES, NETWORK PACKETS AND ON EVERY PLATS FORM, NOT JUST

00:30:41,960 --> 00:30:45,639
LINUX, USUALLY MORE CLEVERLY THAN BROUGHT FORCE,

00:30:45,639 --> 00:30:48,789
TOO. AND NOW WICK DO THE SAME ANYONE FOR OTHER

00:30:48,789 --> 00:30:53,379
PYTHON STRUCTURES, BUT UNFORTUNATELY THAT'S ALL THE

00:30:53,379 --> 00:30:55,809
TIME WE HAVE FOR TODAY AND I THINK THE CHIEF NEEDS

00:30:55,809 --> 00:30:58,830
TO DEAL WITH HER MOM.

00:30:58,830 --> 00:31:00,559
THAT'S RIGHT, DETECTIVE, I LOGGED INTO MY MOM'S

00:31:00,559 --> 00:31:02,559
SERVER WITH HER EVERY CONNECTIONS SEEMS LIKE IT

00:31:02,559 --> 00:31:06,409
WAS RETURNING COMMANDS THAT THE PYTHON PROCESS WAS SUPPOSED TO RUN ON THE ACME SERVER.

00:31:06,409 --> 00:31:09,239
I'M GOING TO BLOCK ALL INBOUND AND OUTBOUNDS TRAFFIC TO THAT I.P.

00:31:09,239 --> 00:31:11,200
NOW I'M GOING TO CALL MY MOM AND GLOAT ABOUT HOW

00:31:11,200 --> 00:31:14,859
WE FOILED HER PLANS. GOOD JOB, GUMSHOES.

00:31:14,859 --> 00:31:36,309
UNTIL NEXT TIME... [ Applause ]

00:31:36,309 --> 00:31:39,601
FOR MORE INFORMATION, I RECOMMEND THE BOOK THE

00:31:39,601 --> 00:31:41,679
"ART OF FORENSICS," WHICH MADE ME WANT TO DO THIS

00:31:41,679 --> 00:31:45,440
TALK. I DON'T DO ANY FORENSICS BUT A FUN LEARNING

00:31:45,440 --> 00:31:47,230
TOOL TO LEARN ABOUT MEMORY.

00:31:47,230 --> 00:31:49,729
ALSO, THREE FANTASTIC TALKS EARLIER AT PYCON THAT

00:31:49,729 --> 00:31:52,019
GO INTO GREATER DETAIL ABOUT SOME SUBJECTS THAT I

00:31:52,019 --> 00:31:54,350
BARELY TOUCHED UPON AND THEY'RE LISTED HERE, SO

00:31:54,350 --> 00:31:58,060
PLEASE CHECK THEM OUT. A FULL WORKING VERSION OF THE PYTHON STRING

00:31:58,060 --> 00:32:02,789
SEARCHING CODES IS ON MY GITHUB ACCOUNT. IT'S NOT BRUTE FORCE, MUCH MORE OPTIMIZED

00:32:02,789 --> 00:32:04,889
AND I WILL BE HAPPY TO ANSWER ANY QUESTIONS ON TWITTER

00:32:04,889 --> 00:32:07,039
OR OUTSIDE. THANK YOU FOR COMING AND THANK YOU FOR YOUR

00:32:07,039 --> 00:32:10,519
TIME. [ Applause ]

00:32:10,519 --> 00:32:18,479

YouTube URL: https://www.youtube.com/watch?v=tMKXcc2-xO8


