Title: Ned Batchelder - Facts and Myths about Python names and values - PyCon 2015
Publication date: 2015-04-11
Playlist: PyCon 2015
Description: 
	"Speaker: Ned Batchelder

The behavior of names and values in Python can be confusing. Like many parts of Python, it has an underlying simplicity that can be hard to discern, especially if you are used to other programming languages. Here I'll explain how it all works, and present some facts and myths along the way.  Call-by-reference? Call-by-value? The answer will be clear!

Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:17,439 --> 00:00:25,310
hello y'all ready for the next talk whoo

00:00:22,490 --> 00:00:26,840
all right so our next speaker probably

00:00:25,310 --> 00:00:27,349
familiar to many of you is Ned

00:00:26,840 --> 00:00:29,269
Batchelder

00:00:27,349 --> 00:00:32,029
you probably know him from his multitude

00:00:29,269 --> 00:00:33,800
of other awesome PyCon talks he's the

00:00:32,029 --> 00:00:37,129
driving force behind the Boston Python

00:00:33,800 --> 00:00:39,290
meetup group he is a huge presence on

00:00:37,129 --> 00:00:40,430
IRC he's going to make faces at me as I

00:00:39,290 --> 00:00:43,250
go down all the awesome stuff he's done

00:00:40,430 --> 00:00:45,049
he wrote coverage pie and he's now

00:00:43,250 --> 00:00:48,589
responsible for teaching billions of

00:00:45,049 --> 00:00:50,739
people awesome stuff at open edx thank

00:00:48,589 --> 00:00:50,739
you

00:00:53,240 --> 00:00:57,810
I'm going to try to break with tradition

00:00:55,170 --> 00:01:00,300
of a few of my previous PI contacts and

00:00:57,810 --> 00:01:01,920
most of our keynote errs and not swear

00:01:00,300 --> 00:01:03,900
on stage that's going to be my goal

00:01:01,920 --> 00:01:05,220
we're going to see if I can do it so I'm

00:01:03,900 --> 00:01:07,440
here to talk to you about facts and

00:01:05,220 --> 00:01:09,840
myths about names and values in Python

00:01:07,440 --> 00:01:11,640
first a quick word about openedx that

00:01:09,840 --> 00:01:13,940
ned helpfully mentioned our session

00:01:11,640 --> 00:01:16,860
shares also named Ned confusingly

00:01:13,940 --> 00:01:19,170
openedx is educating the world it is all

00:01:16,860 --> 00:01:21,180
open source you can find out more at

00:01:19,170 --> 00:01:21,540
openedx organ we're having an open space

00:01:21,180 --> 00:01:26,130
today

00:01:21,540 --> 00:01:28,380
3:45 in room 510 B but on to Python

00:01:26,130 --> 00:01:31,530
names and values so python is a very

00:01:28,380 --> 00:01:33,119
simple language when you come to it it

00:01:31,530 --> 00:01:34,650
often works just as you'd expect if

00:01:33,119 --> 00:01:36,420
you've worked in other languages so it

00:01:34,650 --> 00:01:39,090
works like those other languages do

00:01:36,420 --> 00:01:42,119
until it doesn't so there are surprises

00:01:39,090 --> 00:01:43,740
that will get you if you come to Python

00:01:42,119 --> 00:01:46,590
with sort of an intuitive understanding

00:01:43,740 --> 00:01:49,530
of what might happen underlying

00:01:46,590 --> 00:01:51,509
mechanisms are very very simple but the

00:01:49,530 --> 00:01:53,580
effects can be surprising and I know

00:01:51,509 --> 00:01:55,380
personally I used Python for about 10

00:01:53,580 --> 00:01:56,550
years without being able to describe

00:01:55,380 --> 00:01:59,040
some of the things I'm going to describe

00:01:56,550 --> 00:02:00,570
to you now so it can you can get along

00:01:59,040 --> 00:02:02,280
for quite a long while without

00:02:00,570 --> 00:02:03,900
understanding precisely what's going on

00:02:02,280 --> 00:02:06,030
but what I'm hoping to give to you today

00:02:03,900 --> 00:02:07,620
is an understanding of some fundamental

00:02:06,030 --> 00:02:09,690
mechanisms that will help you reason

00:02:07,620 --> 00:02:11,220
about your code and understand or

00:02:09,690 --> 00:02:12,989
hopefully even prevent some of those

00:02:11,220 --> 00:02:14,370
surprises and the things we're going to

00:02:12,989 --> 00:02:19,800
be talking about our names and values

00:02:14,370 --> 00:02:21,330
and assignment and mutability and as we

00:02:19,800 --> 00:02:24,120
go through this talk the facts in the

00:02:21,330 --> 00:02:26,580
headers of these slides are 100% facts

00:02:24,120 --> 00:02:28,440
simple statements about how Python works

00:02:26,580 --> 00:02:31,200
and the very first one is extremely

00:02:28,440 --> 00:02:33,390
simple names refer to values so the way

00:02:31,200 --> 00:02:34,830
variables work in Python is that they

00:02:33,390 --> 00:02:36,150
are a name that refers to a value that

00:02:34,830 --> 00:02:38,310
sounds like any other language an

00:02:36,150 --> 00:02:40,260
assignment simply makes the name refer

00:02:38,310 --> 00:02:43,590
to that value so for instance when we

00:02:40,260 --> 00:02:45,120
execute x equals 23 23 is an integer

00:02:43,590 --> 00:02:48,810
object which is drawn in this diagram

00:02:45,120 --> 00:02:50,549
with a circle around the 23 that tag

00:02:48,810 --> 00:02:52,530
shaped symbol with the X in it is the

00:02:50,549 --> 00:02:54,120
name and there's also it's like a tag

00:02:52,530 --> 00:02:56,910
hanging off the X but it's also kind of

00:02:54,120 --> 00:02:59,459
like an arrow and it points to the 23 so

00:02:56,910 --> 00:03:00,989
the X refers to the 23 and then the next

00:02:59,459 --> 00:03:03,720
time in your program when you use the

00:03:00,989 --> 00:03:05,640
name X python goes and finds the value

00:03:03,720 --> 00:03:06,180
it refers to and it uses that value so

00:03:05,640 --> 00:03:08,909
when you say

00:03:06,180 --> 00:03:10,739
exit prints at 23 very simple right I'm

00:03:08,909 --> 00:03:12,480
not I hope there's no one in the room

00:03:10,739 --> 00:03:14,370
who is baffled by this right I'm

00:03:12,480 --> 00:03:18,269
starting very simple let's just get the

00:03:14,370 --> 00:03:20,219
facts laid out in a line now many names

00:03:18,269 --> 00:03:23,159
can refer to one value so once we've

00:03:20,219 --> 00:03:25,950
assigned X equals 23 we can also say y

00:03:23,159 --> 00:03:28,439
equals x now note then we say y equals X

00:03:25,950 --> 00:03:31,469
Y is not referring to X Y is referring

00:03:28,439 --> 00:03:34,019
to the value that X refers to so Y and X

00:03:31,469 --> 00:03:36,780
are both names for the 23 neither one of

00:03:34,019 --> 00:03:39,299
them is the real name they are both

00:03:36,780 --> 00:03:40,950
equally valid names for the 23 and of

00:03:39,299 --> 00:03:43,409
course you can have many many more names

00:03:40,950 --> 00:03:48,329
any value can be referred to by as many

00:03:43,409 --> 00:03:50,189
names as would like to refer to it names

00:03:48,329 --> 00:03:52,379
are reassigned independently so if we

00:03:50,189 --> 00:03:55,349
have x equals 23 and we say y equals x

00:03:52,379 --> 00:03:57,780
when we say y equals 12 x equals 12

00:03:55,349 --> 00:04:00,150
rather it makes X refer to 12 but Y is

00:03:57,780 --> 00:04:02,700
still 23 right if you had looked at

00:04:00,150 --> 00:04:04,169
these three lines of code anyone in the

00:04:02,700 --> 00:04:06,450
room if we put a print y I should have

00:04:04,169 --> 00:04:09,060
put a print Y there we know that Y is

00:04:06,450 --> 00:04:11,909
still 23 right making X be 12 doesn't

00:04:09,060 --> 00:04:13,500
somehow make Y also be 12 right and I

00:04:11,909 --> 00:04:15,000
know this seems very simple but you're

00:04:13,500 --> 00:04:17,130
they're going to be a point later in

00:04:15,000 --> 00:04:18,150
this talk where this fact is going to be

00:04:17,130 --> 00:04:19,500
very important and you're going to

00:04:18,150 --> 00:04:21,329
remember this fact and it's going to

00:04:19,500 --> 00:04:25,979
explain a thing that surprises lots of

00:04:21,329 --> 00:04:27,539
people in Python memory is managed

00:04:25,979 --> 00:04:29,099
dynamically which means that values

00:04:27,539 --> 00:04:31,199
exist until there are no more references

00:04:29,099 --> 00:04:34,020
to them so if we have X referring to the

00:04:31,199 --> 00:04:36,960
string hello when we make X refer to the

00:04:34,020 --> 00:04:39,449
string world the hello value now has no

00:04:36,960 --> 00:04:41,639
names referring to it and so it is going

00:04:39,449 --> 00:04:43,770
to be reclaimed and it is removed from

00:04:41,639 --> 00:04:45,150
the process and exactly how that happens

00:04:43,770 --> 00:04:46,590
and when that happens doesn't matter the

00:04:45,150 --> 00:04:48,360
important thing to a Python programmer

00:04:46,590 --> 00:04:49,979
is that as long as names are still

00:04:48,360 --> 00:04:51,630
referring to values the values are still

00:04:49,979 --> 00:04:57,120
there and once all the names are gone

00:04:51,630 --> 00:04:58,949
the value is completely inaccessible now

00:04:57,120 --> 00:05:00,659
here's the fact that many people don't

00:04:58,949 --> 00:05:03,990
know about Python and starts to bring in

00:05:00,659 --> 00:05:06,360
the surprises assignment never copies

00:05:03,990 --> 00:05:09,330
data and there's no asterisk on this

00:05:06,360 --> 00:05:10,889
slide it's really true it never copies

00:05:09,330 --> 00:05:12,300
data if you're thinking now and I've

00:05:10,889 --> 00:05:14,219
given this talk I've rehearsed this talk

00:05:12,300 --> 00:05:15,599
a number of times and there is always a

00:05:14,219 --> 00:05:17,490
person who when I chat with them

00:05:15,599 --> 00:05:19,050
beforehand I think this person knows

00:05:17,490 --> 00:05:20,110
every fall of this stuff they're not

00:05:19,050 --> 00:05:21,460
going to get anything out of this

00:05:20,110 --> 00:05:23,500
I can entertain them with some of my

00:05:21,460 --> 00:05:25,300
clowny jokes but they know all this

00:05:23,500 --> 00:05:27,670
stuff and then afterwards they come up

00:05:25,300 --> 00:05:29,080
to me and they say yeah you know there's

00:05:27,670 --> 00:05:32,410
that one case the word isn't quite true

00:05:29,080 --> 00:05:32,980
and no it is always true it never copies

00:05:32,410 --> 00:05:35,650
data

00:05:32,980 --> 00:05:38,170
so here's nums referring to a list one

00:05:35,650 --> 00:05:40,180
two three when we make say other equals

00:05:38,170 --> 00:05:42,790
nums we didn't make a copy of the list

00:05:40,180 --> 00:05:44,650
now we just as before when we had x and

00:05:42,790 --> 00:05:46,810
y being both names referring to the same

00:05:44,650 --> 00:05:48,820
integer now we have other and nums which

00:05:46,810 --> 00:05:54,520
are two names referring to the same list

00:05:48,820 --> 00:05:56,020
there is only one list and as a result

00:05:54,520 --> 00:05:58,750
when we get to that same state other

00:05:56,020 --> 00:06:00,970
equal nums and we look at the value nums

00:05:58,750 --> 00:06:02,800
and we use a method on it appending a

00:06:00,970 --> 00:06:05,410
four to it where we've changed the list

00:06:02,800 --> 00:06:09,520
now to add a four to that list and we

00:06:05,410 --> 00:06:11,290
print other other is also one two three

00:06:09,520 --> 00:06:14,620
four because there's only ever been one

00:06:11,290 --> 00:06:16,480
list so if we modify it with append all

00:06:14,620 --> 00:06:18,100
the names that we're referring to that

00:06:16,480 --> 00:06:20,830
list are going to see that change and

00:06:18,100 --> 00:06:22,090
this is where people get surprised right

00:06:20,830 --> 00:06:23,800
lots of people will come and write a

00:06:22,090 --> 00:06:25,150
simple program and they'll think I want

00:06:23,800 --> 00:06:26,230
to keep that old list so I'm going to

00:06:25,150 --> 00:06:27,820
give it a new name and then I'm going to

00:06:26,230 --> 00:06:30,340
modify the new name and the old name

00:06:27,820 --> 00:06:31,690
will still have the old data but there's

00:06:30,340 --> 00:06:35,860
only wouldn't been one list because

00:06:31,690 --> 00:06:37,480
assignment never copies data so this is

00:06:35,860 --> 00:06:39,640
what's known as mutable aliasing and

00:06:37,480 --> 00:06:41,680
happens when you have a mutable value so

00:06:39,640 --> 00:06:43,840
lists have methods on them to let you

00:06:41,680 --> 00:06:45,970
change the value in place when we used

00:06:43,840 --> 00:06:48,640
dot append on the list we didn't make a

00:06:45,970 --> 00:06:52,570
brand new list we had one list object

00:06:48,640 --> 00:06:54,730
which changed its value we had more than

00:06:52,570 --> 00:06:56,710
one name the value is changed and all

00:06:54,730 --> 00:06:58,420
the names see the change now in the

00:06:56,710 --> 00:07:00,700
three little lines that I've got here

00:06:58,420 --> 00:07:02,380
four lines it's very easy to see what's

00:07:00,700 --> 00:07:03,640
going on because the two names are right

00:07:02,380 --> 00:07:05,890
next to each other but as we'll see

00:07:03,640 --> 00:07:07,750
later it's very easy in a larger program

00:07:05,890 --> 00:07:10,330
to have the two or three or four names

00:07:07,750 --> 00:07:12,130
be widely spread apart and for the

00:07:10,330 --> 00:07:13,510
change to happen in one place and for

00:07:12,130 --> 00:07:16,060
the use of the data to happen in another

00:07:13,510 --> 00:07:17,590
and so the surprise can be much more

00:07:16,060 --> 00:07:21,820
long distance than I can show on this

00:07:17,590 --> 00:07:24,070
slide now there are also immutable

00:07:21,820 --> 00:07:25,570
values in mutable values I'm from New

00:07:24,070 --> 00:07:27,430
York City and people told me that you

00:07:25,570 --> 00:07:28,810
can't understand me when I say immutable

00:07:27,430 --> 00:07:31,660
values like that so I'm going to try to

00:07:28,810 --> 00:07:34,300
slow it down in mutable values our

00:07:31,660 --> 00:07:36,699
values that cannot be changed in place

00:07:34,300 --> 00:07:39,159
Python types the numbers instant floats

00:07:36,699 --> 00:07:40,509
and strings and tuples there are no

00:07:39,159 --> 00:07:42,460
methods on them that let you change

00:07:40,509 --> 00:07:43,360
their value and if you think there are

00:07:42,460 --> 00:07:45,520
you should go back and look again

00:07:43,360 --> 00:07:48,190
because there aren't so when we say x

00:07:45,520 --> 00:07:50,590
equals hello X is referring to hello Y

00:07:48,190 --> 00:07:52,449
is referring to haha hello now when we

00:07:50,590 --> 00:07:54,190
say x equals x plus they are what we're

00:07:52,449 --> 00:07:56,620
really doing is building an entirely new

00:07:54,190 --> 00:08:00,069
string hello there and then making X

00:07:56,620 --> 00:08:02,860
refer to it and as a result Y still is

00:08:00,069 --> 00:08:06,129
hello because there is no way to change

00:08:02,860 --> 00:08:07,840
the value in place so we didn't have all

00:08:06,129 --> 00:08:10,050
the conditions necessary for mutable

00:08:07,840 --> 00:08:12,129
aliasing so you don't get aliasing here

00:08:10,050 --> 00:08:15,400
this is one of the reasons that people

00:08:12,129 --> 00:08:17,349
really like immutable values and let

00:08:15,400 --> 00:08:19,840
languages that support them much more

00:08:17,349 --> 00:08:21,460
strongly than Python have some real

00:08:19,840 --> 00:08:23,229
advantages over Python but you can still

00:08:21,460 --> 00:08:25,000
make use of these values in Python and

00:08:23,229 --> 00:08:26,800
if you understand where you're mutating

00:08:25,000 --> 00:08:29,409
values and where you're not you can

00:08:26,800 --> 00:08:34,539
build programs that are easier to reason

00:08:29,409 --> 00:08:36,519
about part of the problem with talking

00:08:34,539 --> 00:08:39,070
about this code is I've been using the

00:08:36,519 --> 00:08:41,500
word change but change really has a

00:08:39,070 --> 00:08:43,000
couple of meanings so it's unclear what

00:08:41,500 --> 00:08:44,920
you mean or you can get sloppy in your

00:08:43,000 --> 00:08:47,589
thinking about what you mean and it can

00:08:44,920 --> 00:08:48,790
really help to drill in on exactly what

00:08:47,589 --> 00:08:51,130
you mean by change and use different

00:08:48,790 --> 00:08:55,300
words so when we say we're changing an

00:08:51,130 --> 00:08:57,130
int x equals x plus 1 as you know InSAR

00:08:55,300 --> 00:08:59,440
immutable they cannot change what we

00:08:57,130 --> 00:09:02,440
mean by x equals x plus 1 is that we are

00:08:59,440 --> 00:09:03,910
going to rebind the name X so X refers

00:09:02,440 --> 00:09:07,060
to an inch sometimes that's called it's

00:09:03,910 --> 00:09:08,740
bound to an int we are going to rebind x

00:09:07,060 --> 00:09:10,329
so we're going to take X plus 1 which is

00:09:08,740 --> 00:09:11,950
going to give us a brand new integer and

00:09:10,329 --> 00:09:15,850
we're going to make X refer to that

00:09:11,950 --> 00:09:17,920
other new object we're rebinding X when

00:09:15,850 --> 00:09:21,250
we change the list by appending to it we

00:09:17,920 --> 00:09:24,220
are actually mutating the list so this

00:09:21,250 --> 00:09:27,190
statement changes X this statement

00:09:24,220 --> 00:09:29,980
changes nums but this is rebinding X

00:09:27,190 --> 00:09:32,740
this is mutating nums they're very very

00:09:29,980 --> 00:09:34,959
different right nums dot append 7

00:09:32,740 --> 00:09:38,430
doesn't make you a new object but x

00:09:34,959 --> 00:09:41,230
equals x plus 1 makes you a new end so

00:09:38,430 --> 00:09:42,699
we'll use change informally when we talk

00:09:41,230 --> 00:09:43,959
about things but when you have to reason

00:09:42,699 --> 00:09:45,339
about these things that can help be

00:09:43,959 --> 00:09:48,189
helpful to actually use those

00:09:45,339 --> 00:09:51,229
specialized words

00:09:48,189 --> 00:09:53,269
you can also rebind lists so we can also

00:09:51,229 --> 00:09:55,789
say numbs equals numbs plus seven numbs

00:09:53,269 --> 00:09:57,909
plus seven gives us a brand new list and

00:09:55,789 --> 00:10:00,469
then numbs equals that reminds that

00:09:57,909 --> 00:10:04,699
there is no way to mutate an int because

00:10:00,469 --> 00:10:06,379
they are immutable now some people will

00:10:04,699 --> 00:10:07,819
look at these problems and try to

00:10:06,379 --> 00:10:09,529
explain to you that while mutable

00:10:07,819 --> 00:10:11,239
objects and immutable objects are

00:10:09,529 --> 00:10:13,369
assigned differently and that is not

00:10:11,239 --> 00:10:15,679
true they are exactly the same for all

00:10:13,369 --> 00:10:16,849
values it's changing that's different

00:10:15,679 --> 00:10:17,539
for them and so you can get different

00:10:16,849 --> 00:10:19,249
effects

00:10:17,539 --> 00:10:21,499
so the aliasing that you can get by the

00:10:19,249 --> 00:10:23,329
differences in how you change values can

00:10:21,499 --> 00:10:24,739
give you different behavior and for some

00:10:23,329 --> 00:10:26,599
reason people like to attribute that

00:10:24,739 --> 00:10:29,179
change in behavior to the assignment

00:10:26,599 --> 00:10:31,849
operator statement but it's not the

00:10:29,179 --> 00:10:33,739
assignment it's the change there are

00:10:31,849 --> 00:10:36,499
some other assignment variance when we

00:10:33,739 --> 00:10:39,439
say X plus equals y conceptually that's

00:10:36,499 --> 00:10:41,599
the same as x equals x plus y but what

00:10:39,439 --> 00:10:44,389
it actually is is it calls a method on X

00:10:41,599 --> 00:10:46,369
called under I ad passing it Y which

00:10:44,389 --> 00:10:49,909
means that the type of X can decide what

00:10:46,369 --> 00:10:51,979
actually happens as it happens the way

00:10:49,909 --> 00:10:54,439
list works is that list implements

00:10:51,979 --> 00:10:57,169
dunder I add by using its own extend

00:10:54,439 --> 00:11:00,469
method to extend itself mutating itself

00:10:57,169 --> 00:11:02,569
in place and then returning itself which

00:11:00,469 --> 00:11:04,399
means that when you say num list plus

00:11:02,569 --> 00:11:06,469
gets four comma five what you're really

00:11:04,399 --> 00:11:08,269
doing is you're extending it with 4

00:11:06,469 --> 00:11:11,469
comma 5 and then doing a no op

00:11:08,269 --> 00:11:13,849
assignment of itself unto itself

00:11:11,469 --> 00:11:16,819
so you have to know what you're doing

00:11:13,849 --> 00:11:18,799
right this operation num list plus

00:11:16,819 --> 00:11:21,439
equals it looks like an assignment

00:11:18,799 --> 00:11:23,929
operate a statement which is a rebinding

00:11:21,439 --> 00:11:25,579
and technically it is but your rebinding

00:11:23,929 --> 00:11:27,229
the name to the value it already had so

00:11:25,579 --> 00:11:28,669
you're really just mutating something in

00:11:27,229 --> 00:11:29,989
place so you really have to know what

00:11:28,669 --> 00:11:31,639
you're doing and by the way the Python

00:11:29,989 --> 00:11:33,049
Doc's don't mention this behavior at all

00:11:31,639 --> 00:11:34,669
at least I can't find it so that's a

00:11:33,049 --> 00:11:36,349
challenge to you find me we're in the

00:11:34,669 --> 00:11:40,459
Python documentation it explains that

00:11:36,349 --> 00:11:42,649
lists do this now references can be more

00:11:40,459 --> 00:11:44,239
than just names so for instance list

00:11:42,649 --> 00:11:48,439
elements are references I've been

00:11:44,239 --> 00:11:51,259
drawing the list nums West as a row of

00:11:48,439 --> 00:11:53,599
boxes with numbers in them but really

00:11:51,259 --> 00:11:56,569
each of those boxes is itself a

00:11:53,599 --> 00:11:59,539
reference to a value and the integers

00:11:56,569 --> 00:12:00,290
are floating around in the matrix

00:11:59,539 --> 00:12:02,029
somewhere

00:12:00,290 --> 00:12:05,089
being referred to by the L by the list

00:12:02,029 --> 00:12:06,199
elements and for example the same things

00:12:05,089 --> 00:12:07,639
that you can do with names you can do

00:12:06,199 --> 00:12:10,910
with list elements so when we say x

00:12:07,639 --> 00:12:13,309
equals nums plus sub 1 that makes X

00:12:10,910 --> 00:12:15,319
refer to the same thing that the middle

00:12:13,309 --> 00:12:18,019
element of nums refers to so now we've

00:12:15,319 --> 00:12:23,239
got num sub 1 refers to 2 and X also

00:12:18,019 --> 00:12:25,220
refers to that 2 and lots of different

00:12:23,239 --> 00:12:27,109
things are references so object

00:12:25,220 --> 00:12:29,479
attributes and keys and values and

00:12:27,109 --> 00:12:31,309
dictionaries or references and list

00:12:29,479 --> 00:12:32,899
elements of references and it all nests

00:12:31,309 --> 00:12:34,789
together very common and complicated

00:12:32,899 --> 00:12:35,869
ways anything that can appear on the

00:12:34,789 --> 00:12:38,629
left-hand side of an assignment

00:12:35,869 --> 00:12:40,039
statement is a reference and all of the

00:12:38,629 --> 00:12:42,410
things that we're learning about how

00:12:40,039 --> 00:12:43,850
names behave those references do the

00:12:42,410 --> 00:12:45,739
same thing so you can have many

00:12:43,850 --> 00:12:48,169
references to objects they don't refer

00:12:45,739 --> 00:12:49,910
to each other reassigning one doesn't

00:12:48,169 --> 00:12:54,289
reassign the others all those sorts of

00:12:49,910 --> 00:12:56,029
things and by the way lots of things are

00:12:54,289 --> 00:12:58,189
assignments so the assignment statement

00:12:56,029 --> 00:13:01,759
is the obvious way to make a name have a

00:12:58,189 --> 00:13:03,350
new value but in Python lots of

00:13:01,759 --> 00:13:04,879
statements behave exactly like

00:13:03,350 --> 00:13:06,669
assignments so this is the one we've

00:13:04,879 --> 00:13:09,410
been talking about x equals some value

00:13:06,669 --> 00:13:11,569
but when you do a for loop for X in

00:13:09,410 --> 00:13:13,009
something that's actually assigning to X

00:13:11,569 --> 00:13:15,350
over and over again and I'll show you

00:13:13,009 --> 00:13:17,919
some examples when you define classes or

00:13:15,350 --> 00:13:20,089
functions you are assigning to that name

00:13:17,919 --> 00:13:21,619
this is the most important one we're

00:13:20,089 --> 00:13:23,359
going to cover this quite in quite some

00:13:21,619 --> 00:13:25,489
depth all of the arguments and viewer

00:13:23,359 --> 00:13:27,889
functions are assignments to the local

00:13:25,489 --> 00:13:28,970
names in the function and so on and so

00:13:27,889 --> 00:13:30,829
forth now you don't get in too many

00:13:28,970 --> 00:13:31,850
cases where import X is something if

00:13:30,829 --> 00:13:36,470
they're worried about how assignment

00:13:31,850 --> 00:13:37,910
works but it is exactly the same so

00:13:36,470 --> 00:13:40,579
let's talk about for loops a little bit

00:13:37,910 --> 00:13:42,230
when you see a for loop like this for X

00:13:40,579 --> 00:13:45,259
and sequence to do something with X

00:13:42,230 --> 00:13:46,639
what's really happening is X is assigned

00:13:45,259 --> 00:13:48,169
the first element in the sequence and

00:13:46,639 --> 00:13:49,909
I'm waving my hands over the whole

00:13:48,169 --> 00:13:51,049
subscript of 0 thing the important thing

00:13:49,909 --> 00:13:53,449
is that a value comes out of the

00:13:51,049 --> 00:13:55,309
sequence and gets assigned to X just as

00:13:53,449 --> 00:13:58,759
if it had we had said X equals that

00:13:55,309 --> 00:14:00,289
value and then we do the thing with X

00:13:58,759 --> 00:14:01,639
and then we assign to X again and then

00:14:00,289 --> 00:14:03,289
we do the thing with X and that's how

00:14:01,639 --> 00:14:04,970
for loops work and I don't mean it's

00:14:03,289 --> 00:14:06,949
kind of like assignment again it really

00:14:04,970 --> 00:14:08,659
is an assignment to the name X and

00:14:06,949 --> 00:14:09,859
whatever behavior you would have gotten

00:14:08,659 --> 00:14:11,179
by literally writing out all the

00:14:09,859 --> 00:14:12,499
assignment statements that's what

00:14:11,179 --> 00:14:13,900
behavior you're going to get from the

00:14:12,499 --> 00:14:16,130
for loop

00:14:13,900 --> 00:14:18,230
to give you a concrete example by the

00:14:16,130 --> 00:14:19,670
way one of my previous talks was looped

00:14:18,230 --> 00:14:21,200
like a native which I did two years ago

00:14:19,670 --> 00:14:22,760
at PyCon which you can look up it goes

00:14:21,200 --> 00:14:25,040
into the four loops in iteration in much

00:14:22,760 --> 00:14:26,750
more detail let's say we have a list of

00:14:25,040 --> 00:14:28,400
numbers and I want to change that list

00:14:26,750 --> 00:14:30,980
to have all of the values be ten times

00:14:28,400 --> 00:14:32,600
more than they had been all right so

00:14:30,980 --> 00:14:34,700
I'll make my list of numbers one two

00:14:32,600 --> 00:14:36,770
three and then I'll start iterating over

00:14:34,700 --> 00:14:38,780
my list for X and num so now extra first

00:14:36,770 --> 00:14:41,930
to the first element of nums and then

00:14:38,780 --> 00:14:43,580
I'll compute X times ten and I'll assign

00:14:41,930 --> 00:14:46,400
that to X now you can see what just

00:14:43,580 --> 00:14:49,610
happened here right so what we had there

00:14:46,400 --> 00:14:51,890
was the vert that one that integer one

00:14:49,610 --> 00:14:53,720
was referred to by two separate names it

00:14:51,890 --> 00:14:55,760
was referred to by num Sub Zero and it

00:14:53,720 --> 00:14:58,970
was referred to by X and when we

00:14:55,760 --> 00:15:00,320
realigned X that only modified one of

00:14:58,970 --> 00:15:01,550
the names because remember one of those

00:15:00,320 --> 00:15:02,720
things that you thought was so simply

00:15:01,550 --> 00:15:05,030
didn't have to pay attention to that

00:15:02,720 --> 00:15:06,890
early slide reassigning one of the names

00:15:05,030 --> 00:15:08,930
doesn't reassign the other names now

00:15:06,890 --> 00:15:10,850
here we had two names referring to the

00:15:08,930 --> 00:15:12,200
integer and we only reassigned one of

00:15:10,850 --> 00:15:14,450
them and the one we actually cared about

00:15:12,200 --> 00:15:15,770
was left behind right so if we go

00:15:14,450 --> 00:15:17,990
through this we can see we're computing

00:15:15,770 --> 00:15:20,120
all these nice ten times numbers but

00:15:17,990 --> 00:15:22,310
nothing is changing the list and at the

00:15:20,120 --> 00:15:24,440
end when we print num it's still one two

00:15:22,310 --> 00:15:26,330
three right so you might have written

00:15:24,440 --> 00:15:27,830
this code on your first day of Python or

00:15:26,330 --> 00:15:29,750
maybe on your second week of Python who

00:15:27,830 --> 00:15:31,520
knows when and been confused by it but

00:15:29,750 --> 00:15:33,770
now you understand enough to see all

00:15:31,520 --> 00:15:36,200
those really simple statements I made at

00:15:33,770 --> 00:15:40,430
the beginning pile up to explain exactly

00:15:36,200 --> 00:15:41,810
why this is happening but let's talk

00:15:40,430 --> 00:15:43,070
about functions because functions is

00:15:41,810 --> 00:15:45,080
where you're actually going to get into

00:15:43,070 --> 00:15:46,430
trouble okay some of you in the audience

00:15:45,080 --> 00:15:47,900
we're thinking yeah that was that weird

00:15:46,430 --> 00:15:49,070
time that that list changed and I didn't

00:15:47,900 --> 00:15:54,230
know why I'm telling you why it's

00:15:49,070 --> 00:15:57,070
because of function arguments so num

00:15:54,230 --> 00:15:59,300
equals 17 when we call a function

00:15:57,070 --> 00:16:01,160
functions have formal parameters in

00:15:59,300 --> 00:16:03,440
their definitions so X here is a formal

00:16:01,160 --> 00:16:05,480
parameter and they have actual arguments

00:16:03,440 --> 00:16:06,770
num in this function call is the actual

00:16:05,480 --> 00:16:08,510
argument and what happens during a

00:16:06,770 --> 00:16:10,190
function call is that the actual

00:16:08,510 --> 00:16:12,380
arguments are assigned to the formal

00:16:10,190 --> 00:16:15,790
parameters so these two statements

00:16:12,380 --> 00:16:17,960
together effectively do x equals num and

00:16:15,790 --> 00:16:19,880
when I say effectively I should really

00:16:17,960 --> 00:16:22,310
say it's actually an assignment to that

00:16:19,880 --> 00:16:24,350
name X's assigns the value of num and

00:16:22,310 --> 00:16:26,180
I've drawn here in a dotted line the

00:16:24,350 --> 00:16:26,540
stack frame which holds the local names

00:16:26,180 --> 00:16:28,160
of the

00:16:26,540 --> 00:16:30,470
so as you know when you call a function

00:16:28,160 --> 00:16:31,580
you get a bunch of local names that fall

00:16:30,470 --> 00:16:33,560
out of scope when the function returns

00:16:31,580 --> 00:16:35,780
I'm drawing that as a dotted line around

00:16:33,560 --> 00:16:38,510
those names so now we have num and X

00:16:35,780 --> 00:16:40,790
both referring to 17 when we print X of

00:16:38,510 --> 00:16:42,800
course we'll find 17 it will print when

00:16:40,790 --> 00:16:45,650
we return from the function the stack

00:16:42,800 --> 00:16:47,870
frame goes away taking with it any names

00:16:45,650 --> 00:16:49,580
that were in that stack frame and those

00:16:47,870 --> 00:16:51,200
names now are removing references from

00:16:49,580 --> 00:16:52,640
values which may or may not go away

00:16:51,200 --> 00:16:55,610
depending on if they were the only names

00:16:52,640 --> 00:16:56,840
referring to the values and when we get

00:16:55,610 --> 00:16:58,780
back out of here the only thing that's

00:16:56,840 --> 00:17:02,810
left is our number is still 17

00:16:58,780 --> 00:17:04,460
exactly you should expect let's talk

00:17:02,810 --> 00:17:05,660
about a more complicated example let's

00:17:04,460 --> 00:17:07,400
say I want to write a function that's

00:17:05,660 --> 00:17:10,490
going to append a value twice to the end

00:17:07,400 --> 00:17:12,230
of my list right so I get my usual

00:17:10,490 --> 00:17:14,570
numbers 1 2 3 I'm going to call append

00:17:12,230 --> 00:17:16,040
twice right so the formal parameter a

00:17:14,570 --> 00:17:18,260
list of numbers twice is going to get

00:17:16,040 --> 00:17:19,700
assigned the value from nums so now we

00:17:18,260 --> 00:17:22,730
have two names referring to the list and

00:17:19,700 --> 00:17:24,410
we're passing in 7 is the value when we

00:17:22,730 --> 00:17:25,850
append to a list we're going to add a 7

00:17:24,410 --> 00:17:27,200
to the end of the list we're going to

00:17:25,850 --> 00:17:29,990
add a 7 to the end of the list again

00:17:27,200 --> 00:17:32,870
when we return the frame is gone the

00:17:29,990 --> 00:17:35,510
names are going away we come back out

00:17:32,870 --> 00:17:37,250
nums has been modified 1 2 3 7 7 right

00:17:35,510 --> 00:17:40,160
so our function works great we've

00:17:37,250 --> 00:17:42,200
appended to the list twice right and you

00:17:40,160 --> 00:17:43,910
can see why it works and why the list

00:17:42,200 --> 00:17:45,410
the list didn't get copied in and then

00:17:43,910 --> 00:17:46,790
get copied out it was just a reference

00:17:45,410 --> 00:17:50,450
that was used from the function to the

00:17:46,790 --> 00:17:52,490
caller let's write it again a bad way so

00:17:50,450 --> 00:17:54,770
here's a list of numbers we're going to

00:17:52,490 --> 00:17:57,470
call a pen twice bad exactly the same

00:17:54,770 --> 00:18:00,170
way and then in here we're going to use

00:17:57,470 --> 00:18:02,210
a list plus Val Val is going to make us

00:18:00,170 --> 00:18:04,220
a new list 1 2 3 7 7 we're going to

00:18:02,210 --> 00:18:05,960
assign that to a list and then we're

00:18:04,220 --> 00:18:08,210
going to return the frame goes away the

00:18:05,960 --> 00:18:10,310
names go away on any of the values that

00:18:08,210 --> 00:18:12,530
only had one reference go away and we

00:18:10,310 --> 00:18:14,210
come back out and we've done a lot of

00:18:12,530 --> 00:18:15,650
work for nothing right so we did all

00:18:14,210 --> 00:18:20,000
that work in there the local name went

00:18:15,650 --> 00:18:24,740
away and we've accomplished nothing yeah

00:18:20,000 --> 00:18:27,920
yes so how can we fix that so here we

00:18:24,740 --> 00:18:30,290
can call a pen twice good we do the same

00:18:27,920 --> 00:18:31,520
thing we make a new list for a list but

00:18:30,290 --> 00:18:33,620
now we're going to return the value

00:18:31,520 --> 00:18:35,810
right so we've made a new value inside

00:18:33,620 --> 00:18:37,100
the function the return statement is

00:18:35,810 --> 00:18:38,660
going to give us sort of a little

00:18:37,100 --> 00:18:40,420
reference there on the frame so it can

00:18:38,660 --> 00:18:43,600
hold on to that value that's coming back

00:18:40,420 --> 00:18:45,430
we assign the return value to nums so

00:18:43,600 --> 00:18:46,630
that we can get that new list and now

00:18:45,430 --> 00:18:49,180
when we print num as we have what we

00:18:46,630 --> 00:18:51,130
want right so we've made three stabs at

00:18:49,180 --> 00:18:53,110
writing this very simple function to

00:18:51,130 --> 00:18:56,050
append to a list right and here they are

00:18:53,110 --> 00:18:57,940
so the first one mutates its argument

00:18:56,050 --> 00:19:00,340
this is a mutating version of a pen

00:18:57,940 --> 00:19:03,430
twice the list you pass in is mutated in

00:19:00,340 --> 00:19:04,060
place this one is useless don't worry

00:19:03,430 --> 00:19:06,100
about that

00:19:04,060 --> 00:19:08,980
this one makes a whole new list and

00:19:06,100 --> 00:19:11,050
returns it the best advice I can give

00:19:08,980 --> 00:19:13,060
you from all this is the best way to

00:19:11,050 --> 00:19:15,670
avoid the surprise of mutable aliasing

00:19:13,060 --> 00:19:18,970
is don't mutate values write functions

00:19:15,670 --> 00:19:20,770
like this that make new lists and as Ned

00:19:18,970 --> 00:19:22,450
mentioned I hang out in the Python IRC

00:19:20,770 --> 00:19:23,950
channel and there's a lot of times that

00:19:22,450 --> 00:19:25,840
people come in with questions like this

00:19:23,950 --> 00:19:27,310
and the advice is always just make a new

00:19:25,840 --> 00:19:30,100
list make a new list just make a new

00:19:27,310 --> 00:19:33,730
list it will make your code a lot easier

00:19:30,100 --> 00:19:35,140
to reason about now a few more facts

00:19:33,730 --> 00:19:37,870
about names and values just to cover

00:19:35,140 --> 00:19:40,060
everything python is dynamically typed

00:19:37,870 --> 00:19:41,680
at least until whatever we hear about

00:19:40,060 --> 00:19:45,190
from Kyoto morrow afternoon we're all

00:19:41,680 --> 00:19:47,680
afraid about that but any name can refer

00:19:45,190 --> 00:19:49,690
to any value at any time right names

00:19:47,680 --> 00:19:51,400
have no types associated with them so X

00:19:49,690 --> 00:19:52,780
can be 12 and then it can be a string

00:19:51,400 --> 00:19:53,980
and then it can be a list and then we

00:19:52,780 --> 00:19:55,960
can actually the list doesn't even have

00:19:53,980 --> 00:20:01,930
to be homogeneous it can be an int and a

00:19:55,960 --> 00:20:04,390
string and an end and it wasn't until I

00:20:01,930 --> 00:20:06,030
actually was preparing this talk that I

00:20:04,390 --> 00:20:10,090
realized there's this very interesting

00:20:06,030 --> 00:20:11,650
duality that names have a scope they

00:20:10,090 --> 00:20:14,470
come and go with functions but they have

00:20:11,650 --> 00:20:17,110
no type and values have a type right the

00:20:14,470 --> 00:20:19,210
int is always an int but they have no

00:20:17,110 --> 00:20:22,630
scope so you've got all these values

00:20:19,210 --> 00:20:23,920
that in C terms live on the heap and all

00:20:22,630 --> 00:20:26,590
these names that come and go in your

00:20:23,920 --> 00:20:28,960
stack frame other languages names will

00:20:26,590 --> 00:20:30,900
have both scope and type but but Python

00:20:28,960 --> 00:20:33,370
sort of splits it cleanly in two and

00:20:30,900 --> 00:20:34,810
keeping this in mind that values that

00:20:33,370 --> 00:20:36,670
are created way above you in the call

00:20:34,810 --> 00:20:39,820
stack can be used by functions down

00:20:36,670 --> 00:20:41,740
below and vice-versa can help you

00:20:39,820 --> 00:20:43,690
understand how data is flowing through

00:20:41,740 --> 00:20:48,970
your program and help you write programs

00:20:43,690 --> 00:20:51,610
that won't have big surprises so here's

00:20:48,970 --> 00:20:55,120
some other topics that wouldn't have fit

00:20:51,610 --> 00:20:57,730
in all honesty this entire talk was

00:20:55,120 --> 00:21:00,010
spite driven development by seeing

00:20:57,730 --> 00:21:02,680
people say that python has no variables

00:21:00,010 --> 00:21:04,000
and I'm hoping that most of you are

00:21:02,680 --> 00:21:05,410
baffled by this statement which means

00:21:04,000 --> 00:21:07,510
that you haven't heard it which means

00:21:05,410 --> 00:21:08,860
that it's falling out of favor when

00:21:07,510 --> 00:21:10,150
people have said this what they mean is

00:21:08,860 --> 00:21:12,370
that the variables don't work like they

00:21:10,150 --> 00:21:14,260
do in C and this is a silly way to

00:21:12,370 --> 00:21:15,940
explain Python for a number of reasons

00:21:14,260 --> 00:21:21,730
and I would be glad to rant about it

00:21:15,940 --> 00:21:23,020
over a beer with any one of you another

00:21:21,730 --> 00:21:24,490
question that comes up from people

00:21:23,020 --> 00:21:25,750
coming from other languages is Python

00:21:24,490 --> 00:21:28,240
call-by-value or is it called by

00:21:25,750 --> 00:21:29,950
reference and the answer is there's a

00:21:28,240 --> 00:21:32,710
couple of answers one is neither one is

00:21:29,950 --> 00:21:35,280
kind of both one is you know why are you

00:21:32,710 --> 00:21:35,280
worried about it

00:21:37,600 --> 00:21:44,230
some people explain it by saying that

00:21:40,440 --> 00:21:45,760
that Python is called by value but all

00:21:44,230 --> 00:21:49,120
the values or references which i think

00:21:45,760 --> 00:21:50,470
is just making matters worse i like to

00:21:49,120 --> 00:21:51,760
say it's called by assignment really

00:21:50,470 --> 00:21:53,020
because that's what it is right when you

00:21:51,760 --> 00:21:54,880
call the function what you're doing is

00:21:53,020 --> 00:21:56,230
assigning to that name of us understand

00:21:54,880 --> 00:22:00,100
assignment then you understand how the

00:21:56,230 --> 00:22:02,800
call works if you saw Amy's talk earlier

00:22:00,100 --> 00:22:05,560
she did the the tech Tac Toe example

00:22:02,800 --> 00:22:07,900
much better than than this but making a

00:22:05,560 --> 00:22:09,430
2d list is complicated and people will

00:22:07,900 --> 00:22:11,710
often get it wrong at first and it has

00:22:09,430 --> 00:22:15,340
to do again with sharing values rather

00:22:11,710 --> 00:22:16,720
than making new values and lastly if

00:22:15,340 --> 00:22:18,220
you're having questions about how your

00:22:16,720 --> 00:22:20,020
code works there's an awesome site

00:22:18,220 --> 00:22:21,850
called Python tutor where you can

00:22:20,020 --> 00:22:23,440
literally type in your own python code

00:22:21,850 --> 00:22:25,360
and step through it and it will make

00:22:23,440 --> 00:22:27,100
drawings like the ones I've got in this

00:22:25,360 --> 00:22:29,200
talk they're not as pretty but they're

00:22:27,100 --> 00:22:30,580
working on your code they happen

00:22:29,200 --> 00:22:33,730
automatically whereas the ones in this

00:22:30,580 --> 00:22:37,990
talk I their untold man-hours that went

00:22:33,730 --> 00:22:40,660
into them that's what I've got I'm happy

00:22:37,990 --> 00:22:42,130
to take your questions this is an

00:22:40,660 --> 00:22:44,200
awesome comic for those of you who don't

00:22:42,130 --> 00:22:45,760
have a question the there's one loop

00:22:44,200 --> 00:22:47,560
that goes 0 through 9 through that

00:22:45,760 --> 00:22:49,750
linked list and the other goes through

00:22:47,560 --> 00:22:50,950
the digits and another determined but

00:22:49,750 --> 00:22:52,180
mysterious order and you'll be

00:22:50,950 --> 00:22:53,950
interested to figure out what it is and

00:22:52,180 --> 00:22:55,510
don't forget about the open EDX open

00:22:53,950 --> 00:22:58,350
space yeah awesome

00:22:55,510 --> 00:22:58,350
so do

00:23:04,190 --> 00:23:08,420
if we have questions for Ned go ahead

00:23:06,350 --> 00:23:12,370
line up to that microphone right there

00:23:08,420 --> 00:23:15,410
in the center ask me a question

00:23:12,370 --> 00:23:15,710
hello hello really wonderful dog thank

00:23:15,410 --> 00:23:17,360
you

00:23:15,710 --> 00:23:18,740
I had a just a quick question just to

00:23:17,360 --> 00:23:21,830
sort of make sure I understood correctly

00:23:18,740 --> 00:23:24,050
if you have a list and you assign a

00:23:21,830 --> 00:23:27,320
member of that list to a variable and

00:23:24,050 --> 00:23:29,630
then later on you modify that member of

00:23:27,320 --> 00:23:31,130
the list independently if you do print

00:23:29,630 --> 00:23:32,540
you print out the variable you will

00:23:31,130 --> 00:23:34,670
actually get the modified version not

00:23:32,540 --> 00:23:36,560
the old value you'll cap the old one

00:23:34,670 --> 00:23:38,120
because right it's the same situation of

00:23:36,560 --> 00:23:40,010
having two names referring to a value

00:23:38,120 --> 00:23:43,340
and you've changed one of the names it

00:23:40,010 --> 00:23:45,560
doesn't change the other name okay

00:23:43,340 --> 00:23:48,440
there's there's no way in python to have

00:23:45,560 --> 00:23:50,000
a name refer to another name you can

00:23:48,440 --> 00:23:51,320
only have names referring to values

00:23:50,000 --> 00:23:55,100
that's the other thing I should have put

00:23:51,320 --> 00:23:56,810
on the this slide which is the this

00:23:55,100 --> 00:23:58,070
slide which is the arrows all have to go

00:23:56,810 --> 00:24:00,290
from the left side to the right side

00:23:58,070 --> 00:24:05,930
there's no arrows in and among the left

00:24:00,290 --> 00:24:09,110
side any other questions that nail it

00:24:05,930 --> 00:24:10,640
really you nailed it I nailed it Steph

00:24:09,110 --> 00:24:12,110
I'm waiting I could have slowed down and

00:24:10,640 --> 00:24:14,600
used the five minutes for more slides

00:24:12,110 --> 00:24:16,210
ten point Oh Russian judge loved it wait

00:24:14,600 --> 00:24:20,150
here

00:24:16,210 --> 00:24:22,340
so with those dotted dotted lines around

00:24:20,150 --> 00:24:24,290
the boxes there you show the values that

00:24:22,340 --> 00:24:25,670
are in the function definition going out

00:24:24,290 --> 00:24:27,850
of scope as soon as a function

00:24:25,670 --> 00:24:30,530
definition or the function exits yeah

00:24:27,850 --> 00:24:32,180
what happens when there's the I'm sure

00:24:30,530 --> 00:24:35,510
everybody's experience the pitfall of a

00:24:32,180 --> 00:24:38,480
mutable default value for a keyword Arg

00:24:35,510 --> 00:24:41,780
yeah so if you do default values are

00:24:38,480 --> 00:24:43,880
held on to by the function itself so if

00:24:41,780 --> 00:24:46,070
you get if you use a list as a default

00:24:43,880 --> 00:24:48,260
value for a function argument that is a

00:24:46,070 --> 00:24:50,840
value that is referred to by the

00:24:48,260 --> 00:24:53,300
function object itself and so it will

00:24:50,840 --> 00:24:55,400
stick around forever and it will be used

00:24:53,300 --> 00:24:57,770
for every function call that gets made

00:24:55,400 --> 00:25:02,450
and therefore it will grow indefinitely

00:24:57,770 --> 00:25:03,980
and surprise you thank you sure all

00:25:02,450 --> 00:25:07,480
right thank you enjoy the rest of the

00:25:03,980 --> 00:25:07,480

YouTube URL: https://www.youtube.com/watch?v=_AEJHKGk9ns


