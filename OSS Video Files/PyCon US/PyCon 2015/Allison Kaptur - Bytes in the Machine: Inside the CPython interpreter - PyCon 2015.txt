Title: Allison Kaptur - Bytes in the Machine: Inside the CPython interpreter - PyCon 2015
Publication date: 2015-04-12
Playlist: PyCon 2015
Description: 
	"Speaker: Allison Kaptur

Have you ever wondered how the CPython interpreter works? Do you know where to find a 1,500 line switch statement in CPython? I'll talk about the structure of the interpreter that we all use every day by explaining how Ned Batchelder and I chased down a mysterious bug in Byterun, a Python interpreter written in Python. We'll also see visualizations of the VM as it executes your code.


Slides can be found at: https://speakerdeck.com/pycon2015 and https://github.com/PyCon/2015-slides"
Captions: 
	00:00:05,730 --> 00:00:07,490
WELCOME TO DAY TWO OF PYCON. SO, ALLISON WILL NOW BE GIVING THE FIRST OF

00:00:07,490 --> 00:00:08,490
HER TWO TALKS FOR THIS SESSION.

00:00:08,490 --> 00:00:10,340
THIS ONE IS CALLED "BYTES IN THE MACHINE." ALLISON WORKS AT DROPBOX.

00:00:10,340 --> 00:00:11,340
I'LL LET HER TAKE IT AWAY. PLEASE GIVE HER A WARM WELCOME.

00:00:11,340 --> 00:00:12,340
[ Applause ] >> THANKS VERY MUCH.

00:00:12,340 --> 00:00:13,340
CAN YOU HEAR ME OKAY? HOW DOES THIS SOUND?

00:00:13,340 --> 00:00:14,340
CAN EVERYONE HEAR ME OKAY? GREAT.

00:00:14,340 --> 00:00:15,340
SO AS ESTHER SAID, I'M ALLISON KAPTUR, I WORK AT

00:00:15,340 --> 00:00:19,300
DROPBOX. I WAS PREVIOUSLY A PROFESSOR AT HACKER'S SCHOOL

00:00:19,300 --> 00:00:23,789
AND THIS IS WHERE YOU CAN FIND ME ON THE INTERNET AND THIS IS BASICALLY MY HANDLE ANYWHERE ON

00:00:23,789 --> 00:00:24,789
THE INTERNET.

00:00:24,789 --> 00:00:30,580
I'M GOING TO TALK ABOUT WRITING A PYTHON INTERPRETER IN PYTHON, PARTICULARLY CPYTHON.

00:00:30,580 --> 00:00:36,470
THIS IS BYTES RUN, AND DONE WITH NED BATCHELDER, HE DID MOST OF THE PYTHON 2 SUPPORT, HE CAME

00:00:36,470 --> 00:00:41,120
IN AND DID PYTHON 3 SUPPORT.

00:00:41,120 --> 00:00:43,350
WORKING ON THIS WITH NED FOR ABOUT A YEAR, AND

00:00:43,350 --> 00:00:48,270
IT'S BEEN A REALLY INTERESTING AND EDUCATIONAL EXPERIENCE AND I WANT TO SHARE THAT WITH ALL

00:00:48,270 --> 00:00:50,090
OF YOU TODAY.

00:00:50,090 --> 00:00:54,989
SO BEFORE WE GET STARTED, THE WORD "INTERPRETER" IS USED IN A VARIETY OF DIFFERENT WAYS WHEN

00:00:54,989 --> 00:00:59,280
PEOPLE ARE TALKING ABOUT PYTHON. SOMETIMES WHEN SOMEONE SAYS THE INTERPRETER

00:00:59,280 --> 00:01:04,500
THEY MEAN, THE REPL, THE INTERACTIVE YOU GET,

00:01:04,500 --> 00:01:06,810
SOMETIMES PEOPLE SAY THE PYTHON INTERPRETER TO

00:01:06,810 --> 00:01:10,800
MEAN ALL OF PYTHON, THE WHOLE PROCESS OF EXECUTING CODES.

00:01:10,800 --> 00:01:14,200
TODAY WE'RE GOING TO TALK ABOUT IT IN A MORE NARROW SENSE.

00:01:14,200 --> 00:01:17,110
AN INTERPRETER FOR OUR PURPOSES IS THE LAST STEP

00:01:17,110 --> 00:01:23,150
IN THE PROCESS OF RUNNING A PYTHON PROGRAM. WHEN PYTHON EXECUTES YOUR CODE, YOU CAN THINK

00:01:23,150 --> 00:01:25,020
OF THERE BEING 4 STAGES.

00:01:25,020 --> 00:01:26,890
THERE'S LEXING AND PARSING, WHICH IS GOING FROM

00:01:26,890 --> 00:01:31,680
SOURCE CODE INFILES TO AN AST THAT THE COMPILER KNOWS WHAT TO DO WITH.

00:01:31,680 --> 00:01:34,070
THEN THERE'S COMPILING, WHICH IS TAKING THE AST

00:01:34,070 --> 00:01:38,470
AND TURNING IT INTO A CODE OBJECT THE INTERPRETER KNOWS HOW TO HANDLE, AND THEN THERE'S

00:01:38,470 --> 00:01:41,110
INTERPRETING, WHICH IS TAKING THE CODE HANDLE AND

00:01:41,110 --> 00:01:45,590
DOING WHATEVER IT SAYS. SO BYTE RUN IS A PYTHON INTERPRETER IN THIS

00:01:45,590 --> 00:01:48,140
SENSE, TAKES COMPILE CODE OBJECTS AND MAKES THEM

00:01:48,140 --> 00:01:52,060
RUN. YOU MAY BE SURPRISED TO HEAR THAT COMPILING

00:01:52,060 --> 00:01:55,310
IS A STEP IN PYTHON AT ALL, SINCE PYTHON IS FAMOUSLY

00:01:55,310 --> 00:02:01,570
AN INTERPRETED LANGUAGE IN CONTRAST WITH THE COMPILED LANGUAGE LIKE C OR REST.

00:02:01,570 --> 00:02:03,270
IT TURNS OUT THAT THIS TERMINOLOGY IS NOT AS

00:02:03,270 --> 00:02:07,890
PRECISE AS IT SEEMS. AND IN FACT, MOST INTERPRETED LANGUAGES INCLUDING

00:02:07,890 --> 00:02:13,330
PYTHON DO INVOLVE A COMPILATION STEP. SO THE REASON WHY PYTHON IS CALLED INTERPRETED

00:02:13,330 --> 00:02:17,400
INSTEAD -- EVEN THOUGH IT INVOLVES COMPILATION, IS THAT THE COMPILATION DOESN'T DO A LOT OF

00:02:17,400 --> 00:02:21,160
WORK IN PYTHON AND THE COMPILER KNOWS VERY LITTLE.

00:02:21,160 --> 00:02:22,939
AND BY CONTRAST, THE INTERPRETER DOES A LOT MORE

00:02:22,939 --> 00:02:24,829
WORK AND THE INTERPRETER IS RESPONSIBLE FOR A LOT

00:02:24,829 --> 00:02:29,159
MORE. AND THE PYTHON COMPILER HAS MUCH LESS INFORMATION

00:02:29,159 --> 00:02:31,409
ABOUT THE PROGRAM THAT IT'S GOING TO EXECUTE THAN

00:02:31,409 --> 00:02:37,280
A C-COMPILER DOES. A PYTHON INTERPRETER IS A VIRTUAL MACHINE

00:02:37,280 --> 00:02:39,300
WHICH JUST MEANS THAT IT'S SOFTWARE THAT EMULATES

00:02:39,300 --> 00:02:40,920
A PHYSICAL COMPUTER.

00:02:40,920 --> 00:02:44,819
AND THIS PARTICULAR VIRTUAL MACHINE IS A STACK MACHINE, SO IT MANIPULATES SEVERAL STACKS

00:02:44,819 --> 00:02:46,540
TO PERFORM ITS OPERATIONS.

00:02:46,540 --> 00:02:48,820
THIS IS IN CONTRAST WITH A REGISTER MACHINE WITH

00:02:48,820 --> 00:02:51,200
WHICH YOU COULD MANAGE A VIRTUAL REGISTER MACHINE

00:02:51,200 --> 00:02:53,599
IS A DIFFERENT THING BUT THE IDEA WOULD BE YOU

00:02:53,599 --> 00:02:58,079
WRITE TO AND READ FROM VARIOUS LOCATIONS IN MEMORY, INSTEAD OF DOING THAT, WE'RE OPERATING

00:02:58,079 --> 00:03:00,049
ON A STACK.

00:03:00,049 --> 00:03:01,400
AND IN PARTICULAR, THE PYTHON INTERPRETER IS A

00:03:01,400 --> 00:03:06,840
BYTECODE INTERPRETER, SO ITS INPUT IS IN THESE INSTRUCTION SETS CALLED BYTECODE.

00:03:06,840 --> 00:03:12,180
WHEN YOU WRITE PYTHON, THE LEXER, COMPILER GENERATE THE BYTECODE, IN ADDITION TO SOME

00:03:12,180 --> 00:03:15,930
EXTRA PARTS THAT THE INTERPRETER NEEDS TO RUN.

00:03:15,930 --> 00:03:21,440
AND THE INTERPRETER THEN CONSUMES THOSE INSTRUCTIONS.

00:03:21,440 --> 00:03:25,720
BYTECODE IS OFTEN CALLED AN INTERMEDIATE REPRESENTATION OF PYTHON CODE BECAUSE IT

00:03:25,720 --> 00:03:28,020
EXPRESSES THE SOURCE CODES THAT YOU WROTE IN A

00:03:28,020 --> 00:03:32,340
WAY THE INTERPRETER CAN UNDERSTAND. THIS IS ANALOGOUS TO THE WAY ASSEMBLY LANGUAGE

00:03:32,340 --> 00:03:37,659
IS BETWEEN C-CODE AND A PIECE OF HARDWARE.

00:03:37,659 --> 00:03:39,829
AN INTERMEDIATE REPRESENTATION LIKE THIS ADDS A

00:03:39,829 --> 00:03:42,189
LAYER OF COMPLEXITY TO YOUR EXECUTION MODEL, SO

00:03:42,189 --> 00:03:46,109
THERE IS A COST TO IT IN THAT SENSE. BUT THE ADVANTAGE IS THAT ALL THIS WORK, THE

00:03:46,109 --> 00:03:48,599
LEXING, PARSING, COMBINING Y, ONLY HAS TO BE DONE

00:03:48,599 --> 00:03:51,129
ONCE FOR EACH CODE OBJECT INSTEAD OF EVERY TIME

00:03:51,129 --> 00:03:57,450
YOU NEED THE CODE OBJECT LATER. SO OUR GOAL TODAY IS A BYTECODE INTERPRETER.

00:03:57,450 --> 00:04:02,079
WHY WOULD YOU WRITES AN INTERPRETER? CPYTHON IS PRETTY GOOD AND REWRITING IT

00:04:02,079 --> 00:04:04,499
PARTICULARLY USING THE STRATEGY WE TOOK WHICH IS

00:04:04,499 --> 00:04:07,271
TO REWRITE IT IN PYTHON WON'T MAKE IT BETTER OR

00:04:07,271 --> 00:04:11,519
FASTER IN MOST WAYS. SO FOR NED BATCHELDER, YOU MAY KNOW HIM AS

00:04:11,519 --> 00:04:18,630
THE EDITOR OF COVERAGE TEST -- THIS IS A REALLY

00:04:18,630 --> 00:04:23,910
TRIVIAL EXAMPLE OF A LINE OF CODE WHERE LINE LEVEL COVERAGE CAN BE MISLEADING.

00:04:23,910 --> 00:04:26,170
YOU MAY HAVE WRITTEN A TEST, THE TEST A BUT NOT B

00:04:26,170 --> 00:04:28,560
SO YOU COULD HAVE A BUG IN YOUR PROGRAM HERE AND

00:04:28,560 --> 00:04:32,940
LINE LEVEL COVERAGE WOULDN'T CATCH THAT. SO THE ORIGINAL GOAL OF BYTE RUN WAS TO

00:04:32,940 --> 00:04:35,970
INVESTIGATE WHETHER BYTECODE LEVEL COVERAGE WOULD

00:04:35,970 --> 00:04:39,600
BE AN INTERESTING THING TO PURSUE. AND ONE OF THE LESSONS FROM WORKING ON THIS

00:04:39,600 --> 00:04:42,130
PROJECT IS THAT IT'S EXTREMELY FIDDLY AND WE HAVE

00:04:42,130 --> 00:04:46,060
NOT ENDED UP PURSUING THAT. I WAS IN THIS PROJECT MOSTLY AS AN INTELLECTUAL

00:04:46,060 --> 00:04:52,170
EXERCISE, I THINK IT'S VERY FUN AND INTERESTING >> SO THE NEXT QUESTION IS WHY WRITE A PYTHON

00:04:52,170 --> 00:04:54,390
INTERPRETER IN PYTHON AND PARTICULARLY DOING IT

00:04:54,390 --> 00:04:56,390
IN THIS RELATIVELY NAIVE WAY THAT WE WERE DOING

00:04:56,390 --> 00:04:58,270
AS OPPOSED TO SOMETHING MORE SOPHISTICATED THAN

00:04:58,270 --> 00:05:03,260
PYPY HAS TAKEN. THE OBVIOUS DISADVANTAGE IS SPEED, THIS WON'T

00:05:03,260 --> 00:05:06,170
BE A FUNCTIONAL INTERPRETER IN ANY INTERESTING

00:05:06,170 --> 00:05:09,770
WAY. BUT SINCE THE GOAL IS TO UNDERSTAND THE REAL

00:05:09,770 --> 00:05:12,080
CPYTHON INTERPRETER, WE DON'T CARE ABOUT SPEED OF

00:05:12,080 --> 00:05:17,890
EXECUTION SO WE'RE RUNNING IN A HIGH LEVEL LANGUAGE PYTHON THAT WE KNOW HOW TO READ AND

00:05:17,890 --> 00:05:22,140
WRITE EFFECTIVELY SO WE ENDS UP WITH A PRODUCT THAT IS EASILY UNDERSTANDABILITY.

00:05:22,140 --> 00:05:24,530
THE OTHER SIGNIFICANT ADVANTAGE IS BECAUSE WE

00:05:24,530 --> 00:05:28,030
IMPLEMENTED AN INTERPRETER IN PYTHON, WE DIDN'T HAVE TO IMPLEMENT THE OBJECT SYSTEM.

00:05:28,030 --> 00:05:30,070
WHERE YOU JUST SAY, OKAY, WHEN YOU GET TO AN

00:05:30,070 --> 00:05:34,870
OBJECT, FALL BACK TO THE REAL OBJECT SYSTEM ALREADY THERE IN PYTHON, SO THE INTERPRETER

00:05:34,870 --> 00:05:40,400
CAN DO SORT OF JUST THE BYTECODE STAGE OF THINGS.

00:05:40,400 --> 00:05:46,110
SO THIS IS AN EXAMPLE OF A TEST IN BYTE RUN. THE IDEA HERE IS THAT WE RUN THE CODE UNDER

00:05:46,110 --> 00:05:48,940
THE REAL PYTHON INTERPRETER AND THEN AGAIN UNDER

00:05:48,940 --> 00:05:52,870
BYTERUN AND WE MAKE SURE THAT THE SAME THING HAPPENS, SO WE CAPTURE STANDARD OUT, WE CAPTURE

00:05:52,870 --> 00:05:55,220
EXCEPTION STATE, WE COMPARE WHAT GOT PRINTED AND

00:05:55,220 --> 00:05:58,940
THE EXCEPTIONS AND SO ON. COMPARE BYTE RUN TO A REFERENCE IMPLEMENTATION

00:05:58,940 --> 00:06:01,250
IS A REALLY GREAT WAY TO DO QUICK DEBUGGING AND

00:06:01,250 --> 00:06:03,530
THIS IS IN FACT THE SAME STRATEGY USED FOR MANY

00:06:03,530 --> 00:06:09,080
NEW STRATEGIES, LIKE PISTON WHICH IS BEING USED

00:06:09,080 --> 00:06:10,080
IN DROPBOX.

00:06:10,080 --> 00:06:13,220
THIS ONE PASSES. SO WE HAVE IMPLEMENTED FOUR LOOPS IN A WAY

00:06:13,220 --> 00:06:14,780
THAT WORKS CORRECTLY.

00:06:14,780 --> 00:06:17,181
IN FACT, AS OF ABOUT A YEAR AND A HALF AGO, MOST

00:06:17,181 --> 00:06:20,050
THINGS WORKED CORRECTLY. WE COULD DO LOOPS, WE COULD DO FUNCTION CALLS,

00:06:20,050 --> 00:06:22,710
WE COULD DO EXCEPTION HANDLING, WE COULD DO CONTEXT

00:06:22,710 --> 00:06:29,000
MANAGERS, DECORATORS, GENERATORS, SO ON. WE HAD ONE PROBLEM THAT WAS STUMPING US.

00:06:29,000 --> 00:06:31,540
IN PARTICULAR, WE GOT ERRORS ON NESTED GENERATORS.

00:06:31,540 --> 00:06:36,500
WE GOT A REALLY WEIRD ERROR, TOO. WE WERE TRYING THIS CODES, WHICH SHOULD WORK

00:06:36,500 --> 00:06:38,340
AND WE GET A TYPERROR THAT WE WERE TRYING TO MULTIPLY

00:06:38,340 --> 00:06:41,590
TO NONE OBJECTS, WHICH IS OBVIOUSLY NOT GOING TO

00:06:41,590 --> 00:06:46,440
SUCCEED AND ALSO NOT AT ALL CLEAR WHERE THAT'S COMING FROM IN THIS CODES.

00:06:46,440 --> 00:06:49,980
SO I'M GOING TO TALK A LITTLE BIT ABOUT THE STRUCTURE OF BYTE RUN, WHICH MIRRORS THE

00:06:49,980 --> 00:06:51,880
STRUCTURE OF THE REAL C-PYTHON INTERPRETER TO

00:06:51,880 --> 00:06:55,520
UNCOVER THIS BUG AND IT'S AMAZING HOW WELL THIS

00:06:55,520 --> 00:06:57,690
WORKED CONSIDERING HOW WRONG WE WERE ABOUT THE

00:06:57,690 --> 00:07:00,770
STRUCTURE. TO BE CLEAR, EVERYTHING I'M GOING TO DESCRIBE

00:07:00,770 --> 00:07:02,700
IS THE CORRECT STRUCTURE AND THEN I'LL REVEAL

00:07:02,700 --> 00:07:07,250
WHAT OUR MISUNDERSTANDING WAS TOWARDS THE END.

00:07:07,250 --> 00:07:09,340
SO TO MAKE THIS CONCRETE, LET'S START WITH A VERY

00:07:09,340 --> 00:07:12,140
MINIMAL INTERPRETER. THIS INTERPRETER UNDERSTANDS USE THREE

00:07:12,140 --> 00:07:14,200
INSTRUCTIONS. HERE THEY ARE.

00:07:14,200 --> 00:07:18,680
LOAD OF VALUE, ADD-TO VALUES AND PRINT THE ANSWER.

00:07:18,680 --> 00:07:25,120
ALL THE CODE IT CAN EXECUTE CONSISTS OF THESE THREE INSTRUCTIONS IN DIFFERENT COMBINATIONS.

00:07:25,120 --> 00:07:30,400
SINCE WE'RE NOT CONCERNED AT ALL TODAY ABOUT LEXER OR PARSER OR COMPILER, WE DON'T CARE

00:07:30,400 --> 00:07:33,020
HOW YOU GOT THE INSTRUCTIONS.

00:07:33,020 --> 00:07:35,550
YOU COULD IMAGINE YOU PROPERTY SEVEN PLUS FIVE IN

00:07:35,550 --> 00:07:40,302
A PYTHONEE SYNTAX AND SOME FRIENDLY COMPILER GENERAL RAILS THE FOUR INSTRUCTIONS YOU SEE

00:07:40,302 --> 00:07:41,770
AT THE BOTTOM.

00:07:41,770 --> 00:07:46,330
OR IF YOU HAD A DIFFERENT COMPILER, YOU COULD WRITE LISP SYNTAX AND GET THE INSTRUCTIONS

00:07:46,330 --> 00:07:47,330
AT THE BOTTOM.

00:07:47,330 --> 00:07:49,580
TODAY WE DON'T CARE. THE INTERPRETER JUST CARES THERE IS A

00:07:49,580 --> 00:07:53,900
WELL-INFORMED ARRANGE. OF THESE THREE INSTRUCTIONS, AND THIS IS ONE

00:07:53,900 --> 00:07:57,170
THAT IS WELL-FORMED.

00:07:57,170 --> 00:07:59,990
SO NOW LET'S TALK ABOUT WHAT WE WANT THE INSTRUCTIONS TO DO.

00:07:59,990 --> 00:08:03,331
THE PYTHON INTERPRETER IS A STACK MACHINE SO IT'S

00:08:03,331 --> 00:08:07,810
GOING TO MANIPULATE STACKS TO ADD TO NUMBERS. IT WILL MANIPULATE STACKS TO DO EVERYTHING.

00:08:07,810 --> 00:08:11,960
NOW, WHEN YOU HEAR ABOUT STACKS, YOU'RE PROBABLY THINKING FIRST OF THE CALL STACK.

00:08:11,960 --> 00:08:15,710
THAT IS NOT THE STACK THAT WE'RE TALKING ABOUT RIGHT NOW, SO HOLD THAT THOUGHT.

00:08:15,710 --> 00:08:20,170
WE WILL COME BACK TO THE CALL STACK IN A MINUTE BUT FOR NOW, IGNORE IT COMPLETELY.

00:08:20,170 --> 00:08:25,300
SO WE HAVE SOME STACK THAT CAN HOLD DATA. AND WHEN THE INTERPRETER BEGINS, THE STACK

00:08:25,300 --> 00:08:26,310
IS EMPTY.

00:08:26,310 --> 00:08:32,050
IT EXECUTES THE FIRST INSTRUCTION, WHICH PUSHES THE FIRST NUMBER ON TO THE STACK, THAT'S SEVEN.

00:08:32,050 --> 00:08:33,950
THEN IT PUSHES THE SECOND NUMBER ON TO THE STACK,

00:08:33,950 --> 00:08:36,800
THAT'S FIVE. THEN IT ADDS THEM TOGETHER, PUSHES THE RESULT

00:08:36,800 --> 00:08:40,111
ON TO THE STACK, THAT'S 12, AND THEN WHEN PRINT

00:08:40,111 --> 00:08:42,520
ANSWER, WE'LL POP THE RESULT OFF THE STACK AND

00:08:42,520 --> 00:08:46,240
PRINT IT. SO THE MANIPULATION HERE IS LOAD VALUE IS

00:08:46,240 --> 00:08:50,689
RESPONSIBLE FOR GETTING VALUES ON TO THE STACK. ADD-20 VALUES IS RESPONSIBLE FOR POPPING THEM

00:08:50,689 --> 00:08:52,840
OFF AND ADDING AND PRINT ANSWER CONSUMES WHATEVER

00:08:52,840 --> 00:08:55,560
IS ON THE STACK AND PRINTS IT.

00:08:55,560 --> 00:08:59,310
YOU MAY BE WONDERING AT THIS POINT WHY INSTRUCTIONS OTHER THAN ADD-TO VALUES ARE

00:08:59,310 --> 00:09:02,999
NECESSARY AT ALL. AND ADMITTEDLY, FOR THE CASE WHERE WE JUST

00:09:02,999 --> 00:09:05,410
ADD TWO VALUES, IT IS SLIGHTLY CONTRIVED.

00:09:05,410 --> 00:09:08,580
BUT THIS CREATES A STRONG FRAMEWORK THAT WE CAN

00:09:08,580 --> 00:09:11,420
USE TO ADD A LOT OF COMPLEXITY SO JUST WITH THE

00:09:11,420 --> 00:09:14,199
INTERPRETER INSTRUCTIONS WE'VE DESIGNED SO FAR,

00:09:14,199 --> 00:09:17,740
WE CAN ADD THREE VALUES, OR ANY NUMBER OF VALUES.

00:09:17,740 --> 00:09:19,740
IF WE HAVE THIS WELL-INFORMED SET OF INSTRUCTIONS.

00:09:19,740 --> 00:09:22,149
AND THE STACK PROVIDES A REALLY CLEAN WAY TO

00:09:22,149 --> 00:09:24,589
TRACK THE INTERPRETER STATE AND IT WILL SUPPORT A

00:09:24,589 --> 00:09:30,959
LOT MORE COMPLEXITY AS WE GO ON. SO THE NEXT QUESTION IS, WHERE DO THESE NUMBERS

00:09:30,959 --> 00:09:34,610
COME FROM? IN OUR EXAMPLE OF THE INSTRUCTIONS, IT JUST

00:09:34,610 --> 00:09:38,470
SAYS LOAD VALUE BUT DOESN'T SAY WHAT VALUE TO LOAD.

00:09:38,470 --> 00:09:42,209
SO WE HAVE TO TELL THE INTERPRETER THAT. LET'S EXPAND OUR INSTRUCTIONS A LITTLE BIT.

00:09:42,209 --> 00:09:45,930
INSTEAD OF HAVING JUST A LIST OF INSTRUCTIONS, WE'LL HAVE THIS DICTIONARY, CALL WHAT TO EXECUTE.

00:09:45,930 --> 00:09:50,910
THERE ARE TWO PIECES, THE INSTRUCTIONS THEMSELVES AND THEN THE NUMBERS WHICH WE'LL ALSO NEED.

00:09:50,910 --> 00:09:55,110
AND WE ALSO NEED TO LINK EACH NUMBER TO THE CORRECT INSTRUCTION.

00:09:55,110 --> 00:09:58,990
SO LOAD VALUE THE FIRST TIME SHOULD LOAD THE FIRST NUMBER AND THEN THE SECOND TIME WILL

00:09:58,990 --> 00:10:00,910
LOAD THE SECOND NUMBER.

00:10:00,910 --> 00:10:03,759
IN PYTHON WHAT I'M CALLING INSTRUCTIONS HERE IS

00:10:03,759 --> 00:10:06,410
THE BYTECODE ITSELF AND THE WHOLE WHAT TO EXECUTE

00:10:06,410 --> 00:10:11,649
OBJECT IS ANALOGOUS TO THE CODES OBJECTS. SO WHY NOT JUST PUT THE NUMBERS DIRECTLY INTO

00:10:11,649 --> 00:10:13,870
THE INSTRUCTIONS?

00:10:13,870 --> 00:10:16,930
IMAGINE IF WE WERE ADDING TOGETHER STRINGS INSTEAD OF NUMBERS.

00:10:16,930 --> 00:10:19,149
WE MIGHT NOT KNOW HOW LONG THOSE STRINGS ARE, AND

00:10:19,149 --> 00:10:21,910
WE MIGHT NOT KNOW -- WE MIGHT WANT TO PACK THE

00:10:21,910 --> 00:10:23,730
INSTRUCTIONS IN A WAY WHERE THE LENGTH IS ALREADY

00:10:23,730 --> 00:10:27,240
PREDETERMINED. THE OTHER ADVANTAGE TO THIS DESIGN IS IF WE'RE

00:10:27,240 --> 00:10:32,839
ADDING 7 PLUS 7, INSTEAD OF 7 PLUS 5. WE ALL NEED ONE COPY OF THE NUMBER 7 IN THE

00:10:32,839 --> 00:10:33,839
CODE OBJECT.

00:10:33,839 --> 00:10:39,329
THIS COMES IN HANDY IN A LOT OF PLACES. OKAY, SO LET'S START WRITING OUR INTERPRETER

00:10:39,329 --> 00:10:43,189
ITSELF. WE KNOW THAT OUR INTERPRETER NEEDS A STACK.

00:10:43,189 --> 00:10:44,800
RIGHT NOW THAT'S ALMOST THE ONLY THING THAT WE

00:10:44,800 --> 00:10:47,920
NEED IN OUR INTERPRETER. AND WE NEED TO IMPLEMENTS THE INSTRUCTIONS

00:10:47,920 --> 00:10:49,579
SO THE INTERPRETER KNOWS WHAT TO DO WHEN IT HITS

00:10:49,579 --> 00:10:50,999
THAT INSTRUCTION.

00:10:50,999 --> 00:10:55,990
SO HERE WE HAVE THREE FUNCTIONS THAT ARE NAMED ANALOGOUS TO THE INSTRUCTIONS, VALUE LOADER

00:10:55,990 --> 00:10:58,080
FOR LOAD VALUE, ANSWER PRINTER FOR PRINT ANSWER

00:10:58,080 --> 00:11:00,830
AND TWO VALUE ADDER FOR ADDING INSTRUCTIONS.

00:11:00,830 --> 00:11:05,709
FOR ADDING THE VALUES. YOU'LL NOTICE THAT EACH OF THESE INTERACT

00:11:05,709 --> 00:11:07,749
WITH A STACK IN THE WAY WE JUST OUTLINED, THE VALUE

00:11:07,749 --> 00:11:09,470
LOADER PUSHES SOMETHING ON TO THE STACK AND TWO

00:11:09,470 --> 00:11:15,209
LOADER POPS SOMETHING OFF AND SO OPEN. SO WE NEED ONE MORE PIECE, A WAY TO MAKE THE

00:11:15,209 --> 00:11:20,459
THING GO. HERE WE HAVE A METHOD CALLED RUN CODE WHICH

00:11:20,459 --> 00:11:24,100
TAKES THAT WHAT TO EXECUTE OBJECT AND DOES WHAT

00:11:24,100 --> 00:11:25,180
IT SAYS IN IT.

00:11:25,180 --> 00:11:30,050
SO THE FIRST THING WE DO IS UNPACK INTO INSTRUCTIONS AND NUMBERS, JUST FOR CLARITY

00:11:30,050 --> 00:11:31,079
AND READABILITY.

00:11:31,079 --> 00:11:35,249
THEN WE LOOP OVER THE INSTRUCTION. WE PROCESS THE ARGUMENT TO THAT INSTRUCTION,

00:11:35,249 --> 00:11:37,210
IF THERE IS ANY, WHICH THERE MIGHT NOT BE.

00:11:37,210 --> 00:11:39,139
AND THEN WE CALL THE CORRESPONDING METHOD ON THE

00:11:39,139 --> 00:11:41,589
INTERPRETER OBJECT. AND WE JUST DO THAT WITH AN "F" STATEMENT.

00:11:41,589 --> 00:11:46,689
WE HAVE A METHOD DEFINED FOR EACH INSTRUCTION. WE SAY IN WE'RE LOOKING AT LOADS VALUE, CALL

00:11:46,689 --> 00:11:50,680
THE VALUE LOADER WITH THE CORRECT ARGUMENT.

00:11:50,680 --> 00:11:52,870
SO THIS INTERPRETER IS QUITE LIMITED, BUT THIS

00:11:52,870 --> 00:11:57,149
PROCESS IS ALMOST EXACTLY HOW THE REAL PYTHON INTERPRETER ADDS TWO NUMBERS.

00:11:57,149 --> 00:12:00,319
AND THERE ARE A COUPLE OF THINGS WE CAN NOTICE FROM THE SMALL EXAM WILL.

00:12:00,319 --> 00:12:02,029
THE FIRST ONE IS THAT SOME INSTRUCTIONS DO NEED

00:12:02,029 --> 00:12:05,100
ARGUMENTS, AND REAL PYTHON BYTECODE IS ABOUT HALF

00:12:05,100 --> 00:12:07,129
THE INSTRUCTIONS THAT NEED ARGUMENTS AND HALF DO

00:12:07,129 --> 00:12:10,550
NOT. THE SECOND THING TO NOTICE IS THE ARGUMENTS

00:12:10,550 --> 00:12:12,851
TO THE INSTRUCTION ARE PACKED IN WITH A BYTECODE

00:12:12,851 --> 00:12:20,279
WHERE WE HAD LOAD VALUE ZERO, THAT'S BASICALLY THE WAY THE BYTECODE IS STRUCTURED, AS WELL.

00:12:20,279 --> 00:12:24,100
AND WE CAN NOTICE THAT THE ARGUMENTS TO THE INSTRUCTIONS ARE DIFFERENT THAN THE ARGUMENTS

00:12:24,100 --> 00:12:26,940
TO THE FUNCTION BEING CALLED.

00:12:26,940 --> 00:12:30,230
SO FOR LOAD VALUE, WE NEED TO GO LOOK UP WHAT THE

00:12:30,230 --> 00:12:37,220
CORRECT ARGUMENT IS, AND THEN PASS THAT NUMBER, NOT THE INDEX INTO THE NUMBERS LIST THAT WE

00:12:37,220 --> 00:12:39,119
SAW EARLIER, PASS THE ACTUAL NUMBER AT THAT POINT

00:12:39,119 --> 00:12:44,279
INTO THE VALUE LOADER FUNCTION. AND FINALLY, NOTICE THAT THE ADD-TO VALUES

00:12:44,279 --> 00:12:46,920
DID NOT REQUIRE ANY ARGUMENTS SO THE INSTRUCTION

00:12:46,920 --> 00:12:49,689
ITSELF JUST SAYS, TAKE WHATEVER IS ON THE TOP OF

00:12:49,689 --> 00:12:53,439
THE STACK AND ADD IT TOGETHER. THE TOP TWO THINGS ON THE STACK, ADD THAT

00:12:53,439 --> 00:12:56,389
TOGETHER. THIS IS THE DEFINING FEATURE OF A STACK-BASED

00:12:56,389 --> 00:12:58,420
INTERPRETER, IS THAT WE WILL BE MANIPULATING THE

00:12:58,420 --> 00:13:02,610
STACK AND ANY TIME WE'RE DOING A CALCULATION, BASICALLY, THE VALUES HAVE BEEN ON THE STACK

00:13:02,610 --> 00:13:06,749
AT SOME POINT.

00:13:06,749 --> 00:13:10,559
SO LET'S NOW GRADUATE TO REAL PYTHON BYTECODE. AS I MENTIONED, THESE INSTRUCTIONS SETS IN

00:13:10,559 --> 00:13:14,061
PYTHON ARE CALLED BYTECODE AND THE OVERALL OBJECT

00:13:14,061 --> 00:13:15,800
IS CALLED THE CODES OBJECT.

00:13:15,800 --> 00:13:18,249
ONE GREAT THING ABOUT PYTHON IS IT EXPOSES A TON

00:13:18,249 --> 00:13:22,170
OF INTERNAL IMPLEMENTATION DETAILS IN THE WRAP-OUT SO IT'S EASY TO POKE AROUND AND EXPLORE

00:13:22,170 --> 00:13:25,250
AND SEE WHAT'S GOING ON, SO IT WON'T BE TOO HARD

00:13:25,250 --> 00:13:28,630
FOR US TO DO. SO HERE'S A FUNCTION THAT WE CAN USE TO EXPLORE.

00:13:28,630 --> 00:13:32,689
IT'S SIMPLE, CALLED MOD, TAKES TWO ARGUMENTS, CALCULATES THE MODULUS OF ONE AGAINST THE

00:13:32,689 --> 00:13:37,420
OTHER, AND THEN RETURNS THE RESULTS.

00:13:37,420 --> 00:13:40,199
SO WE CAN GET A HANDLE ON THE FUNCTION OBJECT, WHICH IS MOD.

00:13:40,199 --> 00:13:44,652
ON THE MOD FUNCTIONS CODE OBJECT, WHICH IS FUNCTION CODES, AND THEN WE CAN GET A HANDLE

00:13:44,652 --> 00:13:47,430
ON THE BYTECODE WHICH IS STORED UNDER CODE CODE.

00:13:47,430 --> 00:13:50,529
BYTECODE IS A SUBSET, NOT THE SAME THING AS A

00:13:50,529 --> 00:13:55,060
CODE OBJECT. SO LET'S LOOK AT THIS.

00:13:55,060 --> 00:13:59,519
SO JUST PRINTING THIS DOESN'T FEEL VERY ENLIGHTENING, BUT THERE IS IN FACT ONE THING

00:13:59,519 --> 00:14:00,980
THAT WE CAN LEARN JUST FROM DOING THIS AND THAT

00:14:00,980 --> 00:14:02,860
IS THAT BYTECODE IS A SERIES OF BYTES.

00:14:02,860 --> 00:14:06,740
A SERIES OF NUMBERS BETWEEN 0 AND 255 AND IT

00:14:06,740 --> 00:14:08,279
LOOKS A LITTLE FUNNY IN THE TERMINAL BECAUSE SOME

00:14:08,279 --> 00:14:10,509
OF THEM ARE PRINTABLE AND SOME ARE NOT BUT WE

00:14:10,509 --> 00:14:14,410
ALREADY KNOW SOMETHING ABOUT BYTES JUST FROM THAT.

00:14:14,410 --> 00:14:15,990
WE CAN MAKE THIS SLIGHTLY MORE INTELLIGIBLE BY

00:14:15,990 --> 00:14:18,269
CONVERTING TO ORDINALS AND THIS REALLY SHOWS THIS

00:14:18,269 --> 00:14:23,910
IS NUMBERS BETWEEN 0 AND 255 BUT STILL NOT EXACTLY READABLE.

00:14:23,910 --> 00:14:26,040
SO LUCKILY FOR US, THERE IS A TOOL WE CAN USE IN

00:14:26,040 --> 00:14:30,749
THE STANDARD LIBRARY TO MAKE THIS INTELLIGIBLE. YOU CAN JUST DIS, THE BYTECODE DISASSEMBLER

00:14:30,749 --> 00:14:33,130
AND IN GENERAL, YOU WANT A DISASSEMBLER WHEN YOU

00:14:33,130 --> 00:14:36,059
HAVE SOME SET OF INSTRUCTIONS INTENDED FOR A MACHINE

00:14:36,059 --> 00:14:40,399
AND YOU WANT TO MAKE THEM READABLE FOR HUMANS. SO ASSEMBLY LANGUAGE IS A CASE WHERE YOU WOULD

00:14:40,399 --> 00:14:47,179
USE A DISASSEMBLER VERY OFTEN. I CAN'T THINK OF A REASON WHY YOU WOULD WANT

00:14:47,179 --> 00:14:50,649
TO USE DIS IN PRODUCTION, IN FACT, DIS DOESN'T

00:14:50,649 --> 00:14:53,920
EVEN RETURN THIS OUTPUT, JUST PRINTS IT.

00:14:53,920 --> 00:14:56,570
THIS IS INTENDED FOR OUR EYES AND NOT FOR MACHINE

00:14:56,570 --> 00:15:00,259
CONSUMPTION. SO WE RUN OUR FUNCTION THROUGH THE DISASSEMBLER,

00:15:00,259 --> 00:15:04,990
WE GET THIS OUTPUT. I'VE GOT THIS ANNOTATED SLIGHTLY JUST BELOW

00:15:04,990 --> 00:15:05,990
THE CALL.

00:15:05,990 --> 00:15:07,911
THE LEFT-HAND COLUMN IS THE LINE NUMBER IN THE

00:15:07,911 --> 00:15:13,089
ORIGINAL SOURCE CODE SO OUR CODE WAS TWO LINES AND THIS IS LINE TWO AND THREE FROM THE REPL.

00:15:13,089 --> 00:15:18,101
THE SECOND COLUMN IS THE INDEX INTO THE BYTECODES SO THIS IS TELLING US AT POSITION 0 IS LOAD

00:15:18,101 --> 00:15:22,649
FAST, AT POSITION 7 IS STORE FAST AND SO ON.

00:15:22,649 --> 00:15:25,550
THE THIRD COLUMN IS THE INSTRUCTION -- IS THE

00:15:25,550 --> 00:15:28,860
BYTE MAPS TO A HUMAN-READABLE INSTRUCTION NAME,

00:15:28,860 --> 00:15:34,199
SO 124 BECOMES LOAD FAST AND 22 BECOMES BINARY MOD WHICH IS MUCH FRIENDLIER FOR US TO READ

00:15:34,199 --> 00:15:36,069
AS HUMANS.

00:15:36,069 --> 00:15:39,980
THE FOURTH COLUMN IS THE ARGUMENT TO THE INSTRUCTION AND NOTICE AGAIN, HERE, THAT BINARY

00:15:39,980 --> 00:15:44,970
MODULE LOAD DOES NOT TAKE ANY ARGUMENTS. THE FIRST TIME I SAW THIS I WAS REALLY SURPRISED

00:15:44,970 --> 00:15:47,399
AND CONFUSED BECAUSE I WOULD ASSUME THAT A BINARY

00:15:47,399 --> 00:15:49,350
FUNCTION IS ONE THAT TAKES TWO ARGUMENTS, THAT

00:15:49,350 --> 00:15:52,529
SEEMS DEFINITIONALLY TRUE, BUT IN BYTECODE, THOSE

00:15:52,529 --> 00:15:54,769
ARGUMENTS WILL ALREADY BE ON THE STACK SO THE

00:15:54,769 --> 00:15:59,730
INSTRUCTION ITSELF DOES NOT REQUIRE ARGUMENTS. THE FIFTH COLUMN IS A HINT FROM ELSEWHERE

00:15:59,730 --> 00:16:02,420
ON THE CODE OBJECT ABOUT WHAT THAT ARGUMENT MEANS,

00:16:02,420 --> 00:16:05,459
SO WE CAN TELL THAT THE FIRST TIME YOU DO LOAD FAST,

00:16:05,459 --> 00:16:07,059
YOU'RE GETTING A AND THE SECOND TIME YOU GET B

00:16:07,059 --> 00:16:12,040
AND SO ON SO WHAT HAPPENS IN THE INTERPRETER WHEN

00:16:12,040 --> 00:16:16,370
WE CALL THIS FUNCTION. IT'S JUST LIKE OUR MINIATURE EXAMPLE BEFORE.

00:16:16,370 --> 00:16:18,470
THE PYTHON INTERPRETER PUSHES THE VALUE OF A ON

00:16:18,470 --> 00:16:22,290
TO THE STACK, THAT'S 7. PUSHES THE VALUE OF B ON THE STACK, THAT'S

00:16:22,290 --> 00:16:25,110
FIVE. THEN IT CALCULATES BINARY MOD OF ONE AGAINST

00:16:25,110 --> 00:16:27,350
THE OTHER, GETS TWO AND PUSHES THAT ON TO THE

00:16:27,350 --> 00:16:30,720
STACK AND THEN THE ANSWER GETS STORED BY THE STORE-FAST

00:16:30,720 --> 00:16:33,879
INSTRUCTION WHICH MEANS THAT THE NAME ANSWER IN

00:16:33,879 --> 00:16:40,989
OUR EXAMPLE WILL BE BOUND TO THE NUMBER TWO. SO NOW WHAT?

00:16:40,989 --> 00:16:42,790
WE COMPLETED THIS FIRST LINE OF CODE HERE, THE

00:16:42,790 --> 00:16:48,989
ANSWER IS A MOD B AND DOWN TO LINE THREE. WE KNOW WHAT LOAD FAST DOES, HERE IN POSITION

00:16:48,989 --> 00:16:51,269
10, SECOND LINE UP FROM THE BOTTOM.

00:16:51,269 --> 00:16:54,920
THAT PUSHES THE VALUE ON TO STACK. AND THEN THERE'S RETURN VALUE, WHICH PRESUMABLY

00:16:54,920 --> 00:16:56,989
IS RELATED TO THIS RETURN STATEMENT BUT IN OUR

00:16:56,989 --> 00:17:01,989
CURRENT MENTAL MODEL, THE INTERPRETER, THERE'S NOWHERE TO RETURN TO.

00:17:01,989 --> 00:17:04,910
SO AT THIS MOMENT, I WOULD LIKE YOU TO REMEMBER THE CALL STACK THAT I ASKED YOU TO FORGET

00:17:04,910 --> 00:17:10,240
EARLIER AND ZOOM OUT A LEVEL.

00:17:10,240 --> 00:17:12,740
THE CALL STACK NOW IS MODEL TOP TO BOTTOM AND THE

00:17:12,740 --> 00:17:14,319
DATA STACK, WHICH IS THE STACK WE'VE BEEN LOOKING

00:17:14,319 --> 00:17:20,449
AT SO FAR IS GOING LEFT TO RIGHT. THE STACK THAT THE INTERPRETER IS USING FOR

00:17:20,449 --> 00:17:24,490
CALCULATIONS, I DON'T KNOW IF DATA STACK IS COMMON TERMINOLOGY BUT CERTAINLY IT IS A STACK

00:17:24,490 --> 00:17:27,039
THAT CONTAINS DATA SO THAT'S THE TERM I WILL BE

00:17:27,039 --> 00:17:30,860
USING TODAY. MEANWHILE, THE CALL STACK IS MADE UP OF FRAMES.

00:17:30,860 --> 00:17:35,200
YOU HAVE ONE FRAME ON THE CALL STACK FOR EACH LEVEL OF YOUR CODE, AND THIS IS SOMETHING

00:17:35,200 --> 00:17:36,790
THAT YOU'RE PROBABLY VISCERALLY REALLY FAMILIAR

00:17:36,790 --> 00:17:38,890
WITH BECAUSE YOU SEE IT ALL THE TIME IN TRACE-BACKS,

00:17:38,890 --> 00:17:43,370
SO YOUR TRACE-BACK SAYS MOST RECENT CALL ASKED AND THEN HAS SEVERAL LEVELS.

00:17:43,370 --> 00:17:46,220
EACH ONE OF THOSE LEVELS CORRESPONDS TO A FRAME.

00:17:46,220 --> 00:17:48,881
THE ONE FRAME FOR FUNCTION CALL, ONE FRAME FOR A

00:17:48,881 --> 00:17:53,080
MODULE AND SO ON. EACH FRAME HAS ITS OWN DATA STACK AND THEN

00:17:53,080 --> 00:17:55,159
ALSO HAS ANOTHER STACK OF BLOCKS WHICH I WON'T

00:17:55,159 --> 00:17:56,590
TALK ABOUT TODAY.

00:17:56,590 --> 00:17:58,480
SO THIS IS WHAT THE INTERPRETER LOOKS LIKE IN THE

00:17:58,480 --> 00:18:02,030
MIDDLE OF EXECUTING MOD, WHICH IS RIGHT BEFORE THE BINARY MODULAR HAPPENS.

00:18:02,030 --> 00:18:05,399
THERE'S TWO FRAMES ON THE STACK, ONE FOR THE MAIN

00:18:05,399 --> 00:18:12,070
SCOPE AND ONE FOR OUR FUNCTION MOD. AND WHEN RETURN VALUE IS EXECUTED, WHAT THAT'S

00:18:12,070 --> 00:18:14,740
DOING IS IT TELLS THE INTERPRETER TO PASS A VALUE

00:18:14,740 --> 00:18:18,549
FROM ONE FRAME TO ANOTHER. NOW, RETURN VALUE IS ONE OF ONLY TWO WAYS

00:18:18,549 --> 00:18:19,610
TO ACCOMPLISH THAT.

00:18:19,610 --> 00:18:24,649
THE OTHER WAY IS WITH YIELD. I WANT TO EMPHASIZE THAT THERE'S ONE FRAME

00:18:24,649 --> 00:18:27,289
ON THE STACK FOR EACH FUNCTION CALL, NOT FOR EACH

00:18:27,289 --> 00:18:31,940
FUNCTION OBJECT OR SOMETHING ELSE LIKE THAT. AGAIN, PICTURE YOURSELF MAYBE HITTING THE

00:18:31,940 --> 00:18:33,700
RECURSION LIMIT WHERE YOU GET A TRACE-BACK THAT

00:18:33,700 --> 00:18:38,890
IS 500 FRAMES LONG, EVEN THOUGH THE SAME FUNCTION.

00:18:38,890 --> 00:18:43,920
SO WE HAD A RECURSIVE CALL, LIKE THIS FACTORIAL CALCULATION AND IT WILL START OUT LOOKING

00:18:43,920 --> 00:18:44,920
LIKE THIS.

00:18:44,920 --> 00:18:46,809
I'M NOT SHOWING THE BYTECODES HERE BUT AT THIS

00:18:46,809 --> 00:18:51,200
POINT WE'RE IN THE MIDDLE OF THE CALL TO FACTOR OF 3 AND ABOUT TO CALCULATE THREE MINUS ONE,

00:18:51,200 --> 00:18:54,210
SO WE DO THAT, GET THE ANSWER TWO.

00:18:54,210 --> 00:18:59,810
AT THIS POINT, WE HAVE THE FUNCTION OBJECT FACTORIAL ON THE PREVIOUS FRAME'S DATA STACK.

00:18:59,810 --> 00:19:04,820
I KNOW THIS IS A LITTLE BIT WEIRD. CALL A FUNCTION CONSUMES A FUNCTION OBJECT

00:19:04,820 --> 00:19:07,929
OFF OF THE STACK IN THIS WAY AND WHEN IT'S ACTUALLY

00:19:07,929 --> 00:19:12,480
CALLED, IT CREATES A NEW FRAME FOR THE DEEPER RECURSIVE CALL.

00:19:12,480 --> 00:19:15,510
SO THEN THE INTERPRETER IS LOADING UP N, WHICH IS

00:19:15,510 --> 00:19:20,600
NOW TWO AND PUSHING THAT ON TO THE STACK. NOTICE, ALSO, THAT THERE IS A VALUE LEFT ON

00:19:20,600 --> 00:19:22,470
THE DATA STACK IN THE PREVIOUS FRAME.

00:19:22,470 --> 00:19:26,100
SO THAT'S THE N IN THE RESULT THAT IS WAITING FOR

00:19:26,100 --> 00:19:28,309
FACT OF N MINUS ONE TO FINISH EXECUTING SO WE CAN

00:19:28,309 --> 00:19:31,090
COME BACK TO IT. WE'LL NEED IT THERE TO MULTIPLY WHEN THE CALL

00:19:31,090 --> 00:19:36,290
STACK IS UNWINDING. SKIPPING AHEAD A LITTLE BIT, WE'LL HIT THE

00:19:36,290 --> 00:19:39,130
BASE CASE AND WE START UNWINDING SO THAT ONE GETS

00:19:39,130 --> 00:19:41,049
RETURNED FROM THE TOP FRAME DOWN TO THE NEXT ONE

00:19:41,049 --> 00:19:44,090
DOWN AND MULTIPLIED, MULTIPLY IT AGAIN, GET SIX

00:19:44,090 --> 00:19:51,820
AND PASS THAT BACK TO THE CALLING FRAME. SO THESE ARE THE BASIC PIECES THAT WE NEED

00:19:51,820 --> 00:19:54,260
TO IMPLEMENT A PYTHON INTERPRETER, OUR OWN VIRTUAL

00:19:54,260 --> 00:19:57,210
MACHINE. WE NEED SOME WAY TO CREATE FRAMES, WE NEED

00:19:57,210 --> 00:19:59,090
TO PROVIDE A DATA STACK FOR THAT FRAME AND ALSO

00:19:59,090 --> 00:20:02,070
BLOCK STACK, AND WE NEED TO DEFINE A WAY TO RUN

00:20:02,070 --> 00:20:04,860
THE FRAMES, AND TO RUN THE FRAMES, WE NEED TO

00:20:04,860 --> 00:20:08,910
DEFINE THE CORRECT OPERATIONS FOR EACH INSTRUCTION THAT WE MAY HIT, JUST AS WE DID

00:20:08,910 --> 00:20:11,640
FOR OUR TOY INTERPRETER AT THE BEGINNING.

00:20:11,640 --> 00:20:13,330
THE ONLY DIFFERENCE IS NOW THERE ARE A LOT MORE

00:20:13,330 --> 00:20:16,700
INSTRUCTIONS. I'M OMITSING A COUPLE OF OTHER NECESSARY

00:20:16,700 --> 00:20:22,080
INGREDIENTS, LIKE TRACKING THE EXCEPTION STATE AND TRACKING NAME SPACES AND SCOPES AND THAT

00:20:22,080 --> 00:20:23,080
SORT OF THING.

00:20:23,080 --> 00:20:24,080
IF THERE'S TIME, I CAN TALK ABOUT THAT IN Q AND

00:20:24,080 --> 00:20:30,909
A. SO WE HAVE A LOT MORE INSTRUCTIONS TO DEFINE

00:20:30,909 --> 00:20:33,200
FOR A REAL PYTHON INTERPRETER AND OF COURSE THE

00:20:33,200 --> 00:20:37,409
COMPLEXITY OF EACH INSTRUCTION IS ALSO GREATER. SO WE NEED TO WRITE THE OPERATIONS THAT THE

00:20:37,409 --> 00:20:41,380
INTERPRETER SHOULD PERFORM FOR EACH OF THESE INSTRUCTIONS FOR THIS TO BE ABLE TO EXECUTE.

00:20:41,380 --> 00:20:44,510
SO WHAT SHOULD THOSE BE? WELL, THE GOOD NEWS IS WE'RE NOT STARTING

00:20:44,510 --> 00:20:45,510
FROM SCRATCH.

00:20:45,510 --> 00:20:48,029
WE HAVE CPYTHON, THE REFERENCE IMPLEMENTATION AND

00:20:48,029 --> 00:20:51,710
WE CAN LOOK AT HOW IT IS IMPLEMENTED IN THE REFERENCE IMPLEMENTATION, IN THE ACTUAL C-PYTHON

00:20:51,710 --> 00:20:57,360
INTERPRETER AND GET GUIDANCE. THE MAIN LOOP IS IN THE C VAL.C.

00:20:57,360 --> 00:21:04,120
I SAW ON TWITTER THE WAY TO GETS INTO THE CPYTHON

00:21:04,120 --> 00:21:08,030
CODE BASE IS STARTED ON CCODE.C AND START FROM

00:21:08,030 --> 00:21:10,430
THERE, SO TODAY WE'LL TWO TWO OF THOSE STEPS AND

00:21:10,430 --> 00:21:16,340
HOPEFULLY THREE. IN OUR TOY INTERPRETER...

00:21:16,340 --> 00:21:19,690
CAN YOU SEE THIS OKAY IN THE BACK? [ Laughter ]

00:21:19,690 --> 00:21:24,360
IN OUR TOY INTERPRETER, WE HAD A BIG IF STATEMENT OR WHAT WOULD HAVE BEEN A BIG IF STATEMENT,

00:21:24,360 --> 00:21:26,730
IF THE INSTRUCTION IS THIS, DO THIS.

00:21:26,730 --> 00:21:30,669
IF THE INSTRUCTION IS THIS, DO THIS. CPYTHON IS IMPLEMENT HAD IN THE SAME WAY AND

00:21:30,669 --> 00:21:37,440
THE... THIS IS IT.

00:21:37,440 --> 00:21:39,639
I LOVE THIS BECAUSE IT FEELS LIKE SUCH AN OBVIOUS

00:21:39,639 --> 00:21:42,370
IMPLEMENTATION IN SOME WAYS, LIKE YOU CAN IMAGINE

00:21:42,370 --> 00:21:48,309
SITTING IN THE NETHERLANDS IN 1989 AND SAYING, OKAY, WE HAVE THESE INSTRUCTIONS AND EACH

00:21:48,309 --> 00:21:50,150
OF THEM MAPS TO A SET OF THINGS THAT NEEDS TO BE DONE

00:21:50,150 --> 00:21:52,389
AND WE'RE WRITING C, HOW SHOULD WE DO THAT?

00:21:52,389 --> 00:22:02,190
HOW ABOUT A GIANT SWITCH STATEMENT AND THAT'S EXACTLY HOW IT WORKS.

00:22:02,190 --> 00:22:09,180
IN FACT, 1500 LINE SWITCH STATEMENT IS SO LARGE -- SORRY -- 1500 SWITCH STATEMENT IS

00:22:09,180 --> 00:22:12,230
SO LARGE IT BREAKS SOME C COMPILERS AND THERE

00:22:12,230 --> 00:22:15,080
IS A MACRO YOU CAN TURN ON IF IT BREAKS IT, SO

00:22:15,080 --> 00:22:17,740
YOU CAN TURN IT INTO TWO SWITCH STATEMENTS THAT ARE

00:22:17,740 --> 00:22:20,590
ONLY 750 LINES EACH.

00:22:20,590 --> 00:22:24,000
[ Laughter ] SO THE INTERPRETER IS BASICALLY TAKING EACH

00:22:24,000 --> 00:22:27,039
INSTRUCTION AND THEN WHYSING A SWITCH STATEMENT TO LOOK UP THE CORRECT THINGS TO DO AND THEN

00:22:27,039 --> 00:22:29,870
DOING THOSE THINGS AND MOVING TO THE NEXT INSTRUCTION.

00:22:29,870 --> 00:22:32,710
IN PYTHON 3 AND UP, THIS IS NO LONGER LITERALLY A

00:22:32,710 --> 00:22:35,679
SWITCH, IT IS COMPUTED GO-TOES INSTEAD BUT THE

00:22:35,679 --> 00:22:40,399
IDEA REMAINS QUITE SIMILAR. OKAY, SO THESE ARE IN THE INSTRUCTIONS THAT

00:22:40,399 --> 00:22:42,889
WE NEED TO KNOW HOW TO IMPLEMENT FOR OUR PYTHON

00:22:42,889 --> 00:22:46,029
INTERPRETER AND LET'S LOOK AT THAT IMPLEMENTATION.

00:22:46,029 --> 00:22:48,940
HERE'S LOAD FAST, THE FIRST INSTRUCTION TO FIND.

00:22:48,940 --> 00:22:51,159
THE MOST COMMON INSTRUCTION IN MOOSE PYTHON CODE

00:22:51,159 --> 00:22:57,250
BASES AND THE C IS PRETTY READABLE HERE. YOU CAN SEE WE RUN THE MACRO GET LOCAL AND

00:22:57,250 --> 00:23:00,480
STORE THE VALUE, AND IF ANYTHING GOES WRONG, THEN

00:23:00,480 --> 00:23:04,480
WE THROW AN UNBOUND LOCAL ERROR -- HANDS-UP IF

00:23:04,480 --> 00:23:09,470
YOU'VE THROWN AN UNBOUND LOCAL ERROR BEFORE. SO THIS HAPPENS WHEN YOU TRY TO LOAD A LOCAL

00:23:09,470 --> 00:23:13,100
VARIABLE AND SOMETHING HAPPENS. BUT IN THE MEANTIME, IF SOMETHING HAS NOT

00:23:13,100 --> 00:23:15,299
FAILED, THEN WE PUSH THE RESULT ON TO THE STACK AND

00:23:15,299 --> 00:23:17,350
MOVE ON TO THE NEXT CODE.

00:23:17,350 --> 00:23:19,260
SO HERE IS THE CODE THAT RAISES THAT ERROR, THE

00:23:19,260 --> 00:23:21,760
ONLY PLACE IN THE CPYTHON CODES BASE WHERE THAT'S

00:23:21,760 --> 00:23:24,659
RAISED, I THINK, THAT'S PRETTY COOL WE CAN FIND

00:23:24,659 --> 00:23:29,200
THAT RIGHT THERE. AND HERE'S BINARY MODULAR, SO WE POP TWO THINGS

00:23:29,200 --> 00:23:31,840
OFF THE STACK, IN PRACTICE, IT'S NOT QUITE THAT

00:23:31,840 --> 00:23:34,679
BUT CLOSE ENOUGH. WE DO SOME STUFF, WE CALCULATE THE REMAINDER

00:23:34,679 --> 00:23:37,640
AND THEN WE PUSH THE RESULT BACK ON TO THE STACK.

00:23:37,640 --> 00:23:41,000
COOL. SO I'VE DESCRIBED THE STRUCTURE OF CPYTHON

00:23:41,000 --> 00:23:45,000
AND BY BY EXTENSION, THE EXTENSION OF BYTE RUN, BUT

00:23:45,000 --> 00:23:47,009
UP UNTIL ONE YEAR AGO, WE HAD ONE THING REALLY

00:23:47,009 --> 00:23:49,880
WRONG AND IN PARTICULAR WE ONLY HAD ONE DATA STACK

00:23:49,880 --> 00:23:52,139
FOR THE ENTIRE INTERPRETER INSTEAD OF ONE DATA

00:23:52,139 --> 00:23:53,639
STACK PER FRAME.

00:23:53,639 --> 00:23:58,510
WHAT'S INTERESTING IS HOW MUCH IS POSSIBLE DESPITE MAKING THAT ERROR.

00:23:58,510 --> 00:24:02,260
IN THIS CASE, THE NESTING THE GENERATORS, PAUSES

00:24:02,260 --> 00:24:05,809
AND RESUMPTION THE FRAME OF G SEVERAL TIMES, AND

00:24:05,809 --> 00:24:08,149
IT HAS TO DO SOME WORK IN-BETWEEN PAUSING AND

00:24:08,149 --> 00:24:11,250
RESUMING. SO THAT WORK IS ALSO MANIPULATING THE STACK

00:24:11,250 --> 00:24:13,600
THAT SHOULD BELONG TO THE SEPARATE FRAME BUT INSTEAD

00:24:13,600 --> 00:24:18,669
WAS IN THE WRONG PLACE. AND IT IS NONE APPEARED AND WE TRIED TO MULTIPLY

00:24:18,669 --> 00:24:20,840
IT BECAUSE RESUMING THE GENERATOR PUSHES NONE ON

00:24:20,840 --> 00:24:23,460
TO THE STACK AND THE GENERATOR FRAME KNOWS HOW TO

00:24:23,460 --> 00:24:27,890
CONSUME THAT APPROPRIATELY. UNDERSTANDING THE CORRECT STRUCTURE HERE THAT

00:24:27,890 --> 00:24:30,210
IN FACT THERE IS ONE DATA STACK FOR EVERY FRAME,

00:24:30,210 --> 00:24:33,830
GIVES US THE ABILITIES TO PAUSE AND RESUME FRAMES, WHICH IS WHAT WE NEED FOR GENERATORS

00:24:33,830 --> 00:24:36,941
AND BY CONTRAST, IF THE PYTHON INTERPRETER WERE

00:24:36,941 --> 00:24:38,950
IMPLEMENTED WITH ONLY ONE DATA STACK, THE ONLY

00:24:38,950 --> 00:24:46,779
FEATURE THAT YOU WOULD LOSE IS GENERATORS. SO IN THE LAST COME OF MINUTE HERE BEFORE

00:24:46,779 --> 00:24:48,759
Q AND A, I WANT TO TALK A LITTLE BIT ABOUT HOW PYTHON

00:24:48,759 --> 00:24:52,080
IS DYNAMIC. AND ONE THING YOU HEAR THIS A LOT, LIKE, OH,

00:24:52,080 --> 00:24:57,519
PYTHON IS DYNAMIC LANGUAGE, HAS DYNAMIC TYPING AND IF YOU LISTEN TO PETER'S KEYNOTE, I GUESS

00:24:57,519 --> 00:25:00,260
THE CLOSING TALK TOMORROW, YOU'LL HEAR ABOUT THE

00:25:00,260 --> 00:25:04,890
FUTURE OF TYPES AND PYTHON. I THINK A LOT OF FOLKS, PARTICULARLY THOSE

00:25:04,890 --> 00:25:08,470
OF US ON PYTHON 2, ARE NOT SUPER FAMILIAR WITH WHAT'S

00:25:08,470 --> 00:25:11,559
GOING ON HERE. BUT WITH THE CONTEXT THAT'S JUST -- WE'VE

00:25:11,559 --> 00:25:13,760
JUST BUILT UP ABOUT THE INTERPRETER, WE CAN TAKE

00:25:13,760 --> 00:25:15,450
A LOOK AT ONE OF THE PROBLEMS THAT THIS IS TRYING

00:25:15,450 --> 00:25:19,010
TO SOLVE. SO ONE THING IN THE DYNAMIC MEANS IS THAT

00:25:19,010 --> 00:25:21,000
A LOT IS HAPPENING AT RUN TIME.

00:25:21,000 --> 00:25:23,679
AND ANOTHER WAY OF PUTTING THIS IS THAT NOT A LOT

00:25:23,679 --> 00:25:27,529
IS HAPPENING AT COMPILE TIME. AND THE INTERPRETER HAS A LOT OF WORK TO DO.

00:25:27,529 --> 00:25:29,990
SO LET'S LOOK AT ACTUALLY CALLING UP THIS FUNCTION MOD.

00:25:29,990 --> 00:25:32,169
IT'S PRETTY OBVIOUS WHAT'S GOING ON HERE, WE CALL

00:25:32,169 --> 00:25:37,710
MOD ON 15 AND 4 AND WE GET THE RESULT 3. ANY GUESSES FOR WHAT WILL HAPPEN WHEN WE CALL

00:25:37,710 --> 00:25:40,019
THE FUNCTION LIKE THIS?

00:25:40,019 --> 00:25:46,330
[ PYTHON. >> RIGHT, GET PYCON RETURNED, SO THIS MIGHT

00:25:46,330 --> 00:25:48,779
LOOK WEIRD TO YOU BUT YOU'VE ALMOST CERTAINLY SEEN

00:25:48,779 --> 00:25:52,519
IT BEFORE, YOU'VE SEEN IT AS STRING FORM MATING.

00:25:52,519 --> 00:25:57,860
DOING THAT WITH A MOD LIKE THIS IS INVOKING BINARY MOD ON THE ARGUMENTS.

00:25:57,860 --> 00:26:02,169
SO THIS IS THE BYTECODE FOR THIS FUNCTION AND

00:26:02,169 --> 00:26:05,889
THIS IS ALWAYS THE BYTECODE FOR THIS FUNCTION. THE ADVANTAGE IS THAT WE'VE BUILT THIS ONE

00:26:05,889 --> 00:26:08,330
AND REUSE IT AGAIN AND AGAIN, SO NO MATTER WHAT

00:26:08,330 --> 00:26:10,409
ARGUMENTS ARE PASSED TO IT, WE'RE GOING TO CALL

00:26:10,409 --> 00:26:13,039
BINARY MODULO ON WHATEVER THE TOP TWO ITEMS ON

00:26:13,039 --> 00:26:15,840
THE STACK ARE AND THEY MAY BE TWO INTEGERS OR

00:26:15,840 --> 00:26:23,559
THEY MAY BE A 2PULL AND A STRING OR TWO STRINGS, THE COMPILER DOESN'T KNOW AND DOESN'T CARE.

00:26:23,559 --> 00:26:28,460
IT'S UP TO THE INTERPRETER TO DO THE RIGHT THING.

00:26:28,460 --> 00:26:31,509
SO I WENT BY THIS KIND OF FAST, ON PURPOSE, EARLIER.

00:26:31,509 --> 00:26:33,120
BUT ONE THING THAT YOU NOTICE HERE IS THAT THERE

00:26:33,120 --> 00:26:37,120
IS A F STATEMENT, SAYING IF V IS A STRING, THEN

00:26:37,120 --> 00:26:41,409
DISPATCH TO STRING FORMATTING. THIS KIND OF LOOKS LIKE IT'S TYPE-CHECKING,

00:26:41,409 --> 00:26:44,539
IT'S WORSE THAN THAT.

00:26:44,539 --> 00:26:49,980
THE TYPE-CHECKING HERE IS OPTIMIZATION. BECAUSE OF COURSE WE COULD PASS ANYTHING TO

00:26:49,980 --> 00:26:51,870
OUR MODULAR FUNCTIONING, DOESN'T HAVE TO BE EITHER

00:26:51,870 --> 00:26:54,571
A STRING OR A NUMBER, AND SO THIS PY NUMBER

00:26:54,571 --> 00:27:00,590
REMAINDER IS RESPONSIBLE FOR EVENTUALLY DOING DISPATCH ON WHATEVER THE OBJECT IS.

00:27:00,590 --> 00:27:02,630
SO THIS GETS EVEN WORSE THAN THIS, BECAUSE THIS

00:27:02,630 --> 00:27:06,370
IS PYTHON, RIGHT? SO WE CAN DEFINE OUR OWN TYPES AND WE CAN

00:27:06,370 --> 00:27:09,630
DEFINE WHAT DIFFERENT OPERATIONS MEAN ON THOSE TYPES.

00:27:09,630 --> 00:27:13,070
SO WE COULD WRITE AN OBJECT THAT HAS A SIDE EFFECTING MOD FUNCTIONING.

00:27:13,070 --> 00:27:16,679
SO HERE I'VE WRITTEN MOD THAT SAYS PRINT SOMETHING, WHEN YOU PUT ONE MOD AGAINST ANOTHER.

00:27:16,679 --> 00:27:19,419
I DON'T KNOW WHY YOU WOULD WANT TO DO THIS BUT

00:27:19,419 --> 00:27:23,840
YOU COULD AND IT IS STRICTLY UP TO THE INTERPRETER TO RESOLVE WHAT YOU MEAN BY BINARY

00:27:23,840 --> 00:27:25,750
MOD ON THE OBJECT. IT'S REALLY DEEP.

00:27:25,750 --> 00:27:31,880
THERE IS THIS GREAT PAPER BY RUSSELL POWER AND

00:27:31,880 --> 00:27:36,759
ALEX RUBINSTEIN CALLED "HOW FAST CAN WE MAKE INTERPRETED PYTHON" AND THE CONCLUSION FROM

00:27:36,759 --> 00:27:38,780
THE STRATEGIES THAT THEY TRIED WAS THAT IT'S VERY

00:27:38,780 --> 00:27:42,250
CHALLENGING. AND THE QUOTE HERE IS IN THE GENERAL ABSENCE

00:27:42,250 --> 00:27:44,660
OF TYPE INFORMATION, ALMOST EVERY INSTRUCTION

00:27:44,660 --> 00:27:48,100
MUST BE TREATED AS INVOKE ARBITRARY METHOD.

00:27:48,100 --> 00:27:52,620
SO GIVEN THAT THE COMPILEER KNOWS SO LITTLE WITHOUT RUNNING THE CODE, WE CAN'T REALLY

00:27:52,620 --> 00:27:54,389
OPTIMIZE IT, WE DON'T KNOW WHAT INSTRUCTIONS WE

00:27:54,389 --> 00:27:58,740
CAN TAKE OUT, WE CAN'T REASON ABOUT ITS CORRECTNESS, ALL THOSE ARE VERY HARD TO DO

00:27:58,740 --> 00:28:03,210
BECAUSE THE LANGUAGE IS SO DYNAMIC. BUT NOTICE THE COPY OUT HERE, IN THE GENERAL

00:28:03,210 --> 00:28:07,360
ABSENCE OF TYPE INFORMATION. SO ONE WAY TO SOLVE THIS PROBLEM IS TO SAY,

00:28:07,360 --> 00:28:10,639
FINE, LET'S ADD TYPE INFORMATION.

00:28:10,639 --> 00:28:12,669
AND THERE'S A LOT OF NUANCE TO HOW YOU DO THAT

00:28:12,669 --> 00:28:16,530
AND HOW TO MAKE THAT NOT BREAK FOR PEOPLE WHO ARE

00:28:16,530 --> 00:28:18,309
NOT INTERESTED IN THOSE SORTS OF THINGS BUT IN

00:28:18,309 --> 00:28:20,860
THE NEXT VERSION OF PYTHON, THIS IS BASICALLY WHAT'S HAPPENING.

00:28:20,860 --> 00:28:26,110
YOU CAN ADD OPTIONAL TYPE INFORMATION TO YOUR PYTHON, AND THE STATIC ANALYSIS TOOLS WILL

00:28:26,110 --> 00:28:27,110
BE MORE ROBUST BECAUSE OF IT.

00:28:27,110 --> 00:28:31,559
AND IT OPENS UP A LOT OF INTERESTING POSSIBILITIES THAT JUST AREN'T THERE WHEN

00:28:31,559 --> 00:28:36,110
EVERYTHING IS SO DYNAMIC. OKAY.

00:28:36,110 --> 00:28:38,480
SO I'VE GOT -- I'LL PUT UP THE LINKS A LITTLE BIT

00:28:38,480 --> 00:28:41,000
LATER, A COUPLE OF GREAT BLOGS, THERE ARE A

00:28:41,000 --> 00:28:47,600
COUPLE OF GREAT ARTICLES ABOUT THE INTERPRETER AND INTERNALS AND THE GO-TO STATEMENTS AND

00:28:47,600 --> 00:28:49,350
SO ON. IN THE MEANTIME, I'LL GO AHEAD AND TAKE SOME

00:28:49,350 --> 00:28:51,160
QUESTIONS. [ Applause ]

00:28:51,160 --> 00:29:01,150
>> THANK YOU, ALLISON. IF ANYONE HAS ANY QUESTIONS, PLEASE COME TO

00:29:01,150 --> 00:29:05,200
THE CENTER OF THE ROOM AND STAND BY THE MIC SO

00:29:05,200 --> 00:29:08,699
THE VIDEO CAN PICK YOU UP.

00:29:08,699 --> 00:29:14,129
>> AUDIENCE: GREAT TALK, THANKS. IS THERE ANY POSSIBILITY OF DOING, LIKE, DYNAMIC

00:29:14,129 --> 00:29:17,390
OPTIMIZATIONS LIKE -- >> DOING WHAT SORT OF OPTIMIZATIONS?

00:29:17,390 --> 00:29:26,499
>> AUDIENCE: I'M NOT VERY AWARE OF THE INTERNALS OF THE PYTHON INTERPRETER BUT CAN YOU DO LIKE

00:29:26,499 --> 00:29:29,960
-- LIKE THE EXAMPLE IN THE JAVA VM, IT WILL START

00:29:29,960 --> 00:29:35,100
REWRITING THINGS AS IT'S RUNNING? DOES PYTHON DO THAT?

00:29:35,100 --> 00:29:41,659
>> YES, PYTHON DOES A COUPLE OF OPTIMIZATIONS WHERE IT CAN, SO ONE IS CONSTANT FOLDING.

00:29:41,659 --> 00:29:46,740
IF YOU HAVE A FUNCTION THAT SAYS RETURN THREE PLUS TWO, THE PYTHON COMPILER WILL RETURN

00:29:46,740 --> 00:29:48,909
THAT INTO RETURN 5.

00:29:48,909 --> 00:29:50,600
BECAUSE PYTHON IS SO DYNAMIC, THERE'S VERY FEW

00:29:50,600 --> 00:29:53,020
CASES WHERE UNDER THE CURRENT STRUCTURE YOU CAN'T

00:29:53,020 --> 00:29:59,700
OPTIMIZE AND THE SOURCE IN THIS IS FAIRLY READABLE, HAD A BLOG POST ABOUT CONSTANT FOLDING

00:29:59,700 --> 00:30:05,200
AND THE WAY IT MESSES UP THE BYTECODE LEVEL COVERAGE BECAUSE THE BYTECODE ENDS UP CHANGING

00:30:05,200 --> 00:30:08,360
OUT FROM UNDER YOU, BUT IT HAPPENS A LITTLE BIT

00:30:08,360 --> 00:30:12,860
BUT IT'S PRETTY LIMITED BECAUSE OF THE STRUCTURE. >> AUDIENCE: THANK YOU.

00:30:12,860 --> 00:30:19,769
>> AUDIENCE: HI. I'M RESEARCHING ON INTERPRETERS AND JVMS AND

00:30:19,769 --> 00:30:26,309
SMALL -- SO I'M NOT THAT VERY FAMILIAR WITH CPYTHONS AND THE INTERPRETER BUT I WANTED

00:30:26,309 --> 00:30:29,950
TO KNOW, IS IT REAL SIMPLE SWITCH CASE OR IS

00:30:29,950 --> 00:30:34,820
THERE SMALL OPTIMIZATIONS LIKE TO DISPATCH OR DYNAMIC

00:30:34,820 --> 00:30:40,019
THREADED DISPATCHES, SO THERE ARE MORE DIFFERENT WAYS, SO IS IT JUST A SIMPLE SWITCH CASE OR

00:30:40,019 --> 00:30:41,429
IS IT SOMETHING ELSE?

00:30:41,429 --> 00:30:44,691
AND IS THERE A POSSIBILITY TO JIT THIS SCORE TO

00:30:44,691 --> 00:30:50,919
OPTIMIZE IT LIKE PYPY DOES? >> YEAH, SO TO THE FIRST QUESTION, IS THIS

00:30:50,919 --> 00:30:53,090
LITERAL SWITCH STATEMENT, ARE THERE OPTIMIZATIONS?

00:30:53,090 --> 00:30:57,049
YES TO BOTH, SO THE CODE IS LIKE LITERALLY, YOU

00:30:57,049 --> 00:31:02,480
KNOW, CASE LOAD FAST, CASE, SO ON. IN PYTHON 2.

00:31:02,480 --> 00:31:05,429
AND THERE ARE A COUPLE OF OPTIMIZATIONS WHERE IN

00:31:05,429 --> 00:31:09,019
PARTICULAR THERE ARE PAIRS OF BYTES THAT OFTEN FOLLOW EACH OTHER SO IF YOU HAVE LIKE A GET

00:31:09,019 --> 00:31:13,820
ITTERS, THERE'S PROBABLY A 4 AFTER IT. AND THE INTERPRETER IS SMART ENOUGH TO SAY

00:31:13,820 --> 00:31:18,440
OKAY, CHECK FIRST AT THIS PARTICULAR BYTE AFTER

00:31:18,440 --> 00:31:20,730
IT. THAT'S ONE OPTIMIZATION.

00:31:20,730 --> 00:31:24,570
THERE ARE A NUMBER OF OTHERS, SOME WORK HAS TO BE

00:31:24,570 --> 00:31:26,580
DONE IN-BETWEEN EACH INSTRUCTION, SOME WORK IS

00:31:26,580 --> 00:31:28,460
DONE EVERY HUNDRED INSTRUCTIONS, THOSE SORTS OF

00:31:28,460 --> 00:31:31,559
THINGS. IN TERMS OF WHETHER THIS STRUCTURE CAN BE

00:31:31,559 --> 00:31:34,460
JITED, I DON'T KNOW A WHOLE LOT ABOUT THE WAY THAT

00:31:34,460 --> 00:31:35,970
PYPY IS IMPLEMENTED.

00:31:35,970 --> 00:31:38,210
I THINK THAT PYPY IS SORT OF AN EXISTENCE PROOF

00:31:38,210 --> 00:31:42,570
THAT THIS CANNOT. LIKE YOU WOULDN'T HAVE TO GO THAT DIRECTION

00:31:42,570 --> 00:31:44,080
AND SOLVE THAT PROBLEM WITH A COMPLETELY NEW

00:31:44,080 --> 00:31:49,080
INTERPRETER AND A NEW SET OF BYTECODE IF THIS WERE AMENABLE TO INCREMENTAL CHANGE.

00:31:49,080 --> 00:31:56,510
>> AUDIENCE: OKAY, THANK YOU. >> AUDIENCE: I'M SORRY, THIS MAY BE A STUPID

00:31:56,510 --> 00:32:03,029
QUESTION BUT DO THE TYPE ANNOTATIONS HAVE ANYTHING TO DO WITH JIT COMPILING?

00:32:03,029 --> 00:32:08,980
>> NO, I THINK IS THE SHORT ANSWER. THE TYPE ANNOTATIONS ARE DESIGNED TO HELP

00:32:08,980 --> 00:32:11,850
STATIC ANALYSIS, SO WITHOUT RUNNING THE CODE WHAT,

00:32:11,850 --> 00:32:15,700
CAN WE SAY ABOUT IT NOW?

00:32:15,700 --> 00:32:18,889
DOING JIT COMPILATION I THINK IS MORE OR LESS A

00:32:18,889 --> 00:32:23,760
SEPARATE PROBLEM. >> AUDIENCE: YOU ALLUDED TO THE BLOCK STACK

00:32:23,760 --> 00:32:26,029
A COUPLE OF TIMES, CAN YOU EXPLAIN WHAT THAT

00:32:26,029 --> 00:32:31,059
IS? >> IN SHORT, THE BLOCK STACK IS KEEPING TRACK

00:32:31,059 --> 00:32:35,049
OF A DIFFERENT -- STATE IN A DIFFERENT WAY, SO

00:32:35,049 --> 00:32:37,220
THE CLASSIC EXAMPLE IS FOR AN ITERATOR, IF YOU'RE

00:32:37,220 --> 00:32:39,521
ON THE TOP INSTRUCTION OF AN ITERATOR, YOU'RE

00:32:39,521 --> 00:32:41,590
EITHER GOING TO STEP TO THE NEXT INSTRUCTION, IF

00:32:41,590 --> 00:32:43,330
YOU'RE IN THE BODY OF THE FORELOOP OR IF YOU'RE DONE,

00:32:43,330 --> 00:32:47,399
YOU'RE GOING TO JUMP OUT OF THE FORELOOP. SO THE BLOCK STACK IS RESPONSIBLE FOR KEENING

00:32:47,399 --> 00:32:50,909
TRACK OF THAT. IT'S USED FOR LOOPING AND EXCEPTION HANDLING

00:32:50,909 --> 00:32:53,539
AND I THINK THAT'S PRETTY MUCH IT.

00:32:53,539 --> 00:32:59,500
IT'S JUST LIKE ANOTHER WAY OF MANAGING STATE. >> AUDIENCE: OKAY.

00:32:59,500 --> 00:33:06,480
>> AUDIENCE: HI. I NOTICED IN YOUR EXAMPLE OF MODULAR, YOU

00:33:06,480 --> 00:33:09,720
ASSIGNED, LIKE, A MODULAR B TO ANSWER AND THEN

00:33:09,720 --> 00:33:13,659
RETURN ANSWER. IF YOU JUST DID LIKE RETURN A MODULAR B, IS

00:33:13,659 --> 00:33:18,129
THERE -- DOES PYTHON, LIKE, CREATE A VARIABLE FOR

00:33:18,129 --> 00:33:22,990
THAT STACK? >> IT WOULD NOT CREATE A VARIABLE, YEAH, SO

00:33:22,990 --> 00:33:28,360
YOU'RE TALKING ABOUT... YEAH, SO WHAT WE WOULD SEE IN THAT CASE, IS

00:33:28,360 --> 00:33:31,299
YOU WOULD HAVE BINARY MODULAR AND THEN IMMEDIATELY

00:33:31,299 --> 00:33:33,000
RETURN VALUE BECAUSE ALL THE RETURN VALUE NEEDS

00:33:33,000 --> 00:33:39,519
IS THE RESULT ON THE STACK. SO THIS IS JUST FOR READABILITY, YEAH.

00:33:39,519 --> 00:33:44,880
AND THE INTERESTING THING THERE IS THAT MY BINDING A NAME ANSWER TO THIS IS WHAT MAKES

00:33:44,880 --> 00:33:47,411
PYTHON SAY, OKAY, PULL THIS OFF THE STACK AND PUT

00:33:47,411 --> 00:33:50,309
IT INTO THE ENVIRONMENT. AND THEN IMMEDIATELY RETRIEVE IT FROM THE

00:33:50,309 --> 00:33:54,080
ENVIRONMENT AND RETURN IT. SO THERE'S -- THIS IS SOMETHING I DIDN'T GET

00:33:54,080 --> 00:33:55,779
INTO TOO MUCH ABOUT THE WAY THAT THE FRAME ALSO

00:33:55,779 --> 00:33:58,419
HAS TO MANAGE THE NAME SPACE, WHAT IS CURRENTLY IN

00:33:58,419 --> 00:34:01,850
THE LOCAL SCOPE AND THAT GETS MODIFIED AS YOU

00:34:01,850 --> 00:34:04,950
DO THINGS LIKE STORE FAST AND LOAD.

00:34:04,950 --> 00:34:10,370
>> AUDIENCE: THANK YOU. >> THANK YOU VERY MUCH, ALLISON.

00:34:10,370 --> 00:34:11,370
[ Applause ] [ BREAK ]

00:34:11,370 --> 00:34:12,370
[ MUSIC PLAYING ] [ MUSIC PLAYING ]

00:34:12,370 --> 00:34:12,371

YouTube URL: https://www.youtube.com/watch?v=HVUTjQzESeo


