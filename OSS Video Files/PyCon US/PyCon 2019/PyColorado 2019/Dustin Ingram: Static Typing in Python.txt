Title: Dustin Ingram: Static Typing in Python
Publication date: 2019-10-22
Playlist: PyColorado 2019
Description: 
	In this talk, we’ll discuss the advantages and disadvantages to a static type system, as well as recent efforts to introduce static typing to Python via optional “type hints” and various tools to aid in adding types to Python code.
Captions: 
	00:00:00,370 --> 00:00:46,440
[Music]

00:00:42,620 --> 00:00:48,630
so hi I'm Dustin like he said I'm a

00:00:46,440 --> 00:00:50,309
developer advocate at Google so I focus

00:00:48,630 --> 00:00:53,160
on supporting the Python community at

00:00:50,309 --> 00:00:55,829
Google and talking about things that are

00:00:53,160 --> 00:00:57,780
good for Python you stood at Google at

00:00:55,829 --> 00:01:00,000
conferences like this I'm not gonna talk

00:00:57,780 --> 00:01:02,580
about any real ugly stuff today I'm also

00:01:00,000 --> 00:01:04,379
the chair for PI Texas it's not too far

00:01:02,580 --> 00:01:05,369
away and it's not too long from now if

00:01:04,379 --> 00:01:07,890
you're interested in coming to Austin

00:01:05,369 --> 00:01:10,140
Texas will be there May 16th and 17th

00:01:07,890 --> 00:01:11,430
and like you said also I work on the

00:01:10,140 --> 00:01:13,190
Python package index and some of the

00:01:11,430 --> 00:01:15,570
other packaging infrastructure and tools

00:01:13,190 --> 00:01:18,840
but also not talking about that today

00:01:15,570 --> 00:01:22,380
all right so pop quiz is Python

00:01:18,840 --> 00:01:24,450
dynamically or statically typed who

00:01:22,380 --> 00:01:27,360
thinks is dynamically typed raise your

00:01:24,450 --> 00:01:28,530
hands who's like wait he's gonna talk

00:01:27,360 --> 00:01:30,840
about static typing in Python is

00:01:28,530 --> 00:01:32,460
probably statically typed right ants who

00:01:30,840 --> 00:01:37,679
thinks this is a trick question

00:01:32,460 --> 00:01:39,950
yeah okay so the answer is Python is

00:01:37,679 --> 00:01:42,960
dynamically typed but you can optionally

00:01:39,950 --> 00:01:44,520
statically type it this means that

00:01:42,960 --> 00:01:46,890
Python can be basically as statically

00:01:44,520 --> 00:01:48,300
typed as you want it to be and that

00:01:46,890 --> 00:01:50,640
answer might not like make a lot of

00:01:48,300 --> 00:01:53,280
sense to you and that's okay that's why

00:01:50,640 --> 00:01:55,709
I'm giving this talk so the steps to

00:01:53,280 --> 00:01:57,000
understand what that answer means we're

00:01:55,709 --> 00:01:59,910
gonna talk about a couple things we're

00:01:57,000 --> 00:02:01,709
talk about types in Python type systems

00:01:59,910 --> 00:02:03,989
in general like across other languages

00:02:01,709 --> 00:02:05,580
as well we're talk about dynamic typing

00:02:03,989 --> 00:02:08,069
in Python and then we'll talk about

00:02:05,580 --> 00:02:09,479
static typing in Python and then once we

00:02:08,069 --> 00:02:11,340
understand all those things we'll talk

00:02:09,479 --> 00:02:12,989
about how do you static typing in Python

00:02:11,340 --> 00:02:15,390
code turns out yes you can do static

00:02:12,989 --> 00:02:17,190
typing in Python when you should do it

00:02:15,390 --> 00:02:19,680
and when you shouldn't do static typing

00:02:17,190 --> 00:02:22,680
so let's talk about types and let's

00:02:19,680 --> 00:02:25,260
specifically talk about type type is a

00:02:22,680 --> 00:02:27,090
built-in in Python so I can say type of

00:02:25,260 --> 00:02:29,190
42 and it will tell me the type of that

00:02:27,090 --> 00:02:30,150
is an int all right makes sense we've

00:02:29,190 --> 00:02:33,780
probably done that before

00:02:30,150 --> 00:02:35,400
same thing for floats stores and lists

00:02:33,780 --> 00:02:38,280
right it should all be pretty familiar

00:02:35,400 --> 00:02:40,160
and yeah so yeah you can yeah I

00:02:38,280 --> 00:02:43,379
recognize all these I use these

00:02:40,160 --> 00:02:45,209
built-ins from time to time maybe I can

00:02:43,379 --> 00:02:47,430
you know assign a variable to a and then

00:02:45,209 --> 00:02:50,160
I can use these things like float stir

00:02:47,430 --> 00:02:52,079
list to change one type of variable to

00:02:50,160 --> 00:02:54,060
another right so you could do like turn

00:02:52,079 --> 00:02:55,340
the integer into a float you turn the

00:02:54,060 --> 00:02:57,580
float into string

00:02:55,340 --> 00:03:00,319
trying to string into an ugly ugly list

00:02:57,580 --> 00:03:02,239
who's had something like this show up in

00:03:00,319 --> 00:03:04,430
there yeah this happens

00:03:02,239 --> 00:03:06,050
that's a weird bug right that's a type

00:03:04,430 --> 00:03:07,819
error you were expecting something like

00:03:06,050 --> 00:03:10,580
a list and you got a string instead and

00:03:07,819 --> 00:03:12,200
you got like this really long list as

00:03:10,580 --> 00:03:14,900
all the characters of your string

00:03:12,200 --> 00:03:15,890
spelled out so that means if you've had

00:03:14,900 --> 00:03:17,150
that problem yet you're in the right

00:03:15,890 --> 00:03:20,629
place and I'm going to talk to you about

00:03:17,150 --> 00:03:23,000
how you can fix those kind of bugs so it

00:03:20,629 --> 00:03:24,950
sort of seemed to you that maybe these

00:03:23,000 --> 00:03:27,319
types are available to us but these are

00:03:24,950 --> 00:03:29,120
actually just classes that correspond to

00:03:27,319 --> 00:03:31,160
these built-ins right so when I say that

00:03:29,120 --> 00:03:34,430
type 42 is an INT I'm really actually

00:03:31,160 --> 00:03:36,500
just doing like class matching int is

00:03:34,430 --> 00:03:38,540
just another class like a class that we

00:03:36,500 --> 00:03:41,120
define any other class you've ever

00:03:38,540 --> 00:03:42,769
written so I can do like is instance 42

00:03:41,120 --> 00:03:46,040
int and it'll say true like it is an

00:03:42,769 --> 00:03:48,890
instance of the int class there are also

00:03:46,040 --> 00:03:50,269
other types in Python that don't

00:03:48,890 --> 00:03:52,069
correspond to things like int and the

00:03:50,269 --> 00:03:53,810
float these built-ins so for example the

00:03:52,069 --> 00:03:55,190
type of none is none type I'm sure

00:03:53,810 --> 00:03:56,930
you've seen it before but none type you

00:03:55,190 --> 00:03:59,540
can't type none type in a Python ripple

00:03:56,930 --> 00:04:01,010
and get a type it's not there seen it's

00:03:59,540 --> 00:04:03,590
true for function you do the type of a

00:04:01,010 --> 00:04:05,600
function you get class function we don't

00:04:03,590 --> 00:04:07,459
say like we don't use the function word

00:04:05,600 --> 00:04:09,560
and you're right Python code we say def

00:04:07,459 --> 00:04:11,540
function name whatever whatever and

00:04:09,560 --> 00:04:13,430
there's also like ellipses there's the

00:04:11,540 --> 00:04:17,000
ellipses type for whatever ellipse this

00:04:13,430 --> 00:04:19,609
is our four so there's other types as

00:04:17,000 --> 00:04:21,169
well so you can import the types module

00:04:19,609 --> 00:04:22,970
this isn't basically any version of

00:04:21,169 --> 00:04:25,280
Python and you get a whole bunch of

00:04:22,970 --> 00:04:28,160
stuff and so many of these types live in

00:04:25,280 --> 00:04:30,139
the types module and these classes can

00:04:28,160 --> 00:04:32,419
actually be used to instantiate these

00:04:30,139 --> 00:04:34,729
objects for example a function there's a

00:04:32,419 --> 00:04:36,169
function type in the middle there but we

00:04:34,729 --> 00:04:37,370
don't do that and we don't do that for a

00:04:36,169 --> 00:04:39,410
good reason it's because it can get

00:04:37,370 --> 00:04:40,970
really huge and gnarly and messy all the

00:04:39,410 --> 00:04:42,740
arguments that go into insane cheney's

00:04:40,970 --> 00:04:45,590
classes instead we just write functions

00:04:42,740 --> 00:04:47,270
the normal way so dynamic typing in

00:04:45,590 --> 00:04:48,979
Python when we say that python is a

00:04:47,270 --> 00:04:51,770
dynamically typed language that means

00:04:48,979 --> 00:04:53,599
that variables can be any of these types

00:04:51,770 --> 00:04:55,070
at all right and they can change a

00:04:53,599 --> 00:04:57,440
variable can be instantiated as one it

00:04:55,070 --> 00:04:59,360
can become something else so like I can

00:04:57,440 --> 00:05:01,840
import random and I can do random that

00:04:59,360 --> 00:05:04,909
choice of multiple types of objects and

00:05:01,840 --> 00:05:06,200
what is the type of a here right it

00:05:04,909 --> 00:05:08,130
actually could be like any of these

00:05:06,200 --> 00:05:09,870
things it's totally non-deterministic

00:05:08,130 --> 00:05:11,190
so say that a is flexible and we can

00:05:09,870 --> 00:05:13,410
change it as we want that's dynamic

00:05:11,190 --> 00:05:15,480
typing done in our typing also means

00:05:13,410 --> 00:05:17,130
that the arguments and return values of

00:05:15,480 --> 00:05:19,980
a function just like a variable can

00:05:17,130 --> 00:05:22,290
change and they can be different so it

00:05:19,980 --> 00:05:23,940
can be any type at all and it can you

00:05:22,290 --> 00:05:25,260
know we don't actually know what the

00:05:23,940 --> 00:05:26,790
return type of function can be it can

00:05:25,260 --> 00:05:29,430
change depending on the behavior of the

00:05:26,790 --> 00:05:31,970
function so if I define a function like

00:05:29,430 --> 00:05:33,810
this from negate just a made-up function

00:05:31,970 --> 00:05:35,730
you know when we write a function like

00:05:33,810 --> 00:05:37,680
this how do we how do we know what types

00:05:35,730 --> 00:05:39,930
this function is expecting right so if

00:05:37,680 --> 00:05:41,040
you saw this function and you didn't

00:05:39,930 --> 00:05:43,290
know what it does because you don't know

00:05:41,040 --> 00:05:45,090
what from negate means what would you

00:05:43,290 --> 00:05:47,370
expect the argument and return types to

00:05:45,090 --> 00:05:51,150
be here any guesses what the types of

00:05:47,370 --> 00:05:53,250
the integer okay sure so yeah if you

00:05:51,150 --> 00:05:54,750
created this function you could call

00:05:53,250 --> 00:05:55,410
with integers and you would get the sum

00:05:54,750 --> 00:05:57,270
of those integers

00:05:55,410 --> 00:05:59,130
all right maybe that's what it does you

00:05:57,270 --> 00:06:00,450
could also pass his strings that would

00:05:59,130 --> 00:06:02,790
totally work just fine

00:06:00,450 --> 00:06:04,320
it would concatenate the strings but

00:06:02,790 --> 00:06:06,150
what you couldn't do is mix those types

00:06:04,320 --> 00:06:07,260
right you couldn't pass it to integers

00:06:06,150 --> 00:06:08,570
on a string because that would just

00:06:07,260 --> 00:06:10,740
create a type error you can't combine

00:06:08,570 --> 00:06:13,770
strings and integers like that all right

00:06:10,740 --> 00:06:16,650
so this is really confusing how should

00:06:13,770 --> 00:06:18,630
we fix this so one thing we could do we

00:06:16,650 --> 00:06:20,700
could write really long dock strings

00:06:18,630 --> 00:06:25,080
they look like this sometimes we do this

00:06:20,700 --> 00:06:26,220
go does this I don't do this are they

00:06:25,080 --> 00:06:28,530
paying you guys enough to do this

00:06:26,220 --> 00:06:30,480
because that's a lot of work to get

00:06:28,530 --> 00:06:32,550
those exactly right and the thing is

00:06:30,480 --> 00:06:34,170
after you write those dock strings it

00:06:32,550 --> 00:06:35,670
doesn't make any guarantees about

00:06:34,170 --> 00:06:36,960
whether your function is actually gonna

00:06:35,670 --> 00:06:38,370
get called with those types it's just

00:06:36,960 --> 00:06:39,960
sort of a little bit of extra knowledge

00:06:38,370 --> 00:06:43,290
to the people that are looking at your

00:06:39,960 --> 00:06:45,300
code we could do this we could assert on

00:06:43,290 --> 00:06:47,310
all the argument values and on a return

00:06:45,300 --> 00:06:48,750
type we definitely don't do that though

00:06:47,310 --> 00:06:50,940
I've never actually seen Python code

00:06:48,750 --> 00:06:52,740
that isn't a test that doesn't that does

00:06:50,940 --> 00:06:54,780
that right that's a mess don't do that

00:06:52,740 --> 00:06:57,390
instead what we do is something called

00:06:54,780 --> 00:06:59,580
duck typing so basically if it walks

00:06:57,390 --> 00:07:01,350
like a duck and it quacks like a duck it

00:06:59,580 --> 00:07:03,840
is probably a duck we just sort of like

00:07:01,350 --> 00:07:06,360
manipulate and do things to objects in

00:07:03,840 --> 00:07:08,070
Python and if they do what we expect

00:07:06,360 --> 00:07:10,230
them to do that's what they are so

00:07:08,070 --> 00:07:12,780
here's some examples and each of these

00:07:10,230 --> 00:07:14,940
you can kind of guess what bar is based

00:07:12,780 --> 00:07:16,950
on what's being done with it right but

00:07:14,940 --> 00:07:20,100
like in the first one here a bar is

00:07:16,950 --> 00:07:21,420
probably like a list or string maybe and

00:07:20,100 --> 00:07:23,040
the second one bar is probably

00:07:21,420 --> 00:07:25,350
or float something we can compare with

00:07:23,040 --> 00:07:26,640
zero and the last one the last one's

00:07:25,350 --> 00:07:29,400
kind of ambiguous right like that could

00:07:26,640 --> 00:07:30,810
be a function it could be a class it's

00:07:29,400 --> 00:07:33,510
not really clear just looking at it what

00:07:30,810 --> 00:07:35,790
it is usually we would capitalize the F

00:07:33,510 --> 00:07:37,860
if it was a class but it could be

00:07:35,790 --> 00:07:39,060
anything and also the return value from

00:07:37,860 --> 00:07:40,800
it could be anything at all right we

00:07:39,060 --> 00:07:44,010
have no idea what its gonna give us when

00:07:40,800 --> 00:07:46,410
we call it so this is where static

00:07:44,010 --> 00:07:47,940
typing comes in basically a static

00:07:46,410 --> 00:07:50,670
typing means that a variable or function

00:07:47,940 --> 00:07:53,610
is defined to only return certain types

00:07:50,670 --> 00:07:55,350
and it's actually exists in a lot of

00:07:53,610 --> 00:07:57,210
other languages as well right so here's

00:07:55,350 --> 00:07:59,280
some examples of that same function in

00:07:57,210 --> 00:08:03,000
those other languages does anyone know

00:07:59,280 --> 00:08:06,060
what language this is let's see yeah see

00:08:03,000 --> 00:08:09,810
how about this one Java yeah that's kind

00:08:06,060 --> 00:08:11,280
of obvious anyone know this one Russ

00:08:09,810 --> 00:08:12,750
yeah so rust has like really

00:08:11,280 --> 00:08:14,670
fine-grained control of integer type

00:08:12,750 --> 00:08:18,270
it's the unsigned 8-bit integer you know

00:08:14,670 --> 00:08:19,580
all sorts of different types about this

00:08:18,270 --> 00:08:22,260
one anyone know this one

00:08:19,580 --> 00:08:23,760
yeah that's typescript it's a dead

00:08:22,260 --> 00:08:26,640
giveaway because in JavaScript there's

00:08:23,760 --> 00:08:29,100
only one type of number it's a number no

00:08:26,640 --> 00:08:30,270
integers there's no floats so you can

00:08:29,100 --> 00:08:32,520
sort of put languages into two

00:08:30,270 --> 00:08:35,520
categories right dynamically typed and

00:08:32,520 --> 00:08:36,930
statically typed and you know you can

00:08:35,520 --> 00:08:38,160
sort of think if you've programmed andis

00:08:36,930 --> 00:08:39,420
language you can remember like yeah and

00:08:38,160 --> 00:08:41,670
in Java I had to say

00:08:39,420 --> 00:08:44,160
hopefully int when I ever I created a

00:08:41,670 --> 00:08:45,450
function that returns an integer I'm

00:08:44,160 --> 00:08:47,190
gonna put a little asterisk here next to

00:08:45,450 --> 00:08:49,500
Python and we're gonna talk about why

00:08:47,190 --> 00:08:50,910
obviously and also I want to point out

00:08:49,500 --> 00:08:52,410
that ruby is technically going to also

00:08:50,910 --> 00:08:54,390
get optional type checking but it won't

00:08:52,410 --> 00:08:57,000
happen till the end of next year so for

00:08:54,390 --> 00:08:59,280
now it's still a dynamic language so

00:08:57,000 --> 00:09:00,990
yeah python is dynamically typed like I

00:08:59,280 --> 00:09:03,300
said before but it's optionally can be

00:09:00,990 --> 00:09:05,460
statically typed and this wasn't always

00:09:03,300 --> 00:09:07,230
true and Python was first created it was

00:09:05,460 --> 00:09:09,840
definitely solidly in the camp of a

00:09:07,230 --> 00:09:13,070
dynamically typed language and really

00:09:09,840 --> 00:09:15,600
the pipe a story of Python becoming a

00:09:13,070 --> 00:09:16,920
statically bascially statically typed

00:09:15,600 --> 00:09:18,840
language is also the story of the

00:09:16,920 --> 00:09:21,750
introduction of statically typed code at

00:09:18,840 --> 00:09:24,570
Dropbox so Dropbox has millions of lines

00:09:21,750 --> 00:09:26,640
of Python code and they basically

00:09:24,570 --> 00:09:28,080
decided at one point hey python is

00:09:26,640 --> 00:09:29,610
getting kind of messy we kind of need

00:09:28,080 --> 00:09:30,870
static typing and I'll talk about why in

00:09:29,610 --> 00:09:32,610
a second but there's some other things

00:09:30,870 --> 00:09:33,610
leading up to it before Dropbox started

00:09:32,610 --> 00:09:35,890
adding

00:09:33,610 --> 00:09:39,130
by the way they just published this blog

00:09:35,890 --> 00:09:40,870
post I'll include a link later like two

00:09:39,130 --> 00:09:42,850
days ago actually and it's a great story

00:09:40,870 --> 00:09:46,120
of how they adopted static typing in

00:09:42,850 --> 00:09:48,640
Python so let's go back a little bit in

00:09:46,120 --> 00:09:51,220
2006 Python 3 was about to come out and

00:09:48,640 --> 00:09:52,900
we had at that pep 3107 and this

00:09:51,220 --> 00:09:55,150
introduced function annotations in

00:09:52,900 --> 00:09:56,710
Python and you might not really have

00:09:55,150 --> 00:09:59,050
seen this too much it wasn't really

00:09:56,710 --> 00:10:01,030
super useful for a lot of things maybe

00:09:59,050 --> 00:10:04,030
except for typing so it allowed us to

00:10:01,030 --> 00:10:06,040
take a function like this and add any

00:10:04,030 --> 00:10:07,750
metadata that we wanted to annotate the

00:10:06,040 --> 00:10:09,880
arguments and the return value of that

00:10:07,750 --> 00:10:12,460
function so this would have zero effect

00:10:09,880 --> 00:10:13,720
on the execution of the function the

00:10:12,460 --> 00:10:15,580
behavior of that function the runtime of

00:10:13,720 --> 00:10:16,930
that function but it literally you could

00:10:15,580 --> 00:10:18,640
do anything you want right like here I

00:10:16,930 --> 00:10:20,500
am adding five and six I'm taking the

00:10:18,640 --> 00:10:23,320
max of two and nine and what happens is

00:10:20,500 --> 00:10:26,110
after that function is evaluated I can

00:10:23,320 --> 00:10:28,120
get the dunder annotations attribute and

00:10:26,110 --> 00:10:30,190
that has all those things after they've

00:10:28,120 --> 00:10:31,780
been evaluated so anything that's

00:10:30,190 --> 00:10:33,340
compiling this function has access to

00:10:31,780 --> 00:10:35,350
all these things and it can do some

00:10:33,340 --> 00:10:37,390
interesting stuff with it and that pep

00:10:35,350 --> 00:10:39,760
include is a huge list of things that

00:10:37,390 --> 00:10:41,140
could be done with function annotations

00:10:39,760 --> 00:10:42,700
right there are a lot of options they

00:10:41,140 --> 00:10:44,620
all kind of boil down to something that

00:10:42,700 --> 00:10:46,240
Kyle looked like typing and then like

00:10:44,620 --> 00:10:49,630
maybe documentation which isn't super

00:10:46,240 --> 00:10:51,490
useful because we also have comments so

00:10:49,630 --> 00:10:53,680
this allows us to write a function that

00:10:51,490 --> 00:10:56,020
would look like this where I specify the

00:10:53,680 --> 00:10:58,120
type for each of these arguments and

00:10:56,020 --> 00:11:00,430
also the return type but what it doesn't

00:10:58,120 --> 00:11:02,680
do is give us a way to evaluate whether

00:11:00,430 --> 00:11:04,480
this function is being correctly used

00:11:02,680 --> 00:11:06,010
right like again nothing is actually

00:11:04,480 --> 00:11:07,090
going to check whether these values are

00:11:06,010 --> 00:11:09,910
correct and whether it's actually being

00:11:07,090 --> 00:11:12,760
used correctly so around the same time

00:11:09,910 --> 00:11:14,310
Yuuka link faso was working his PhD

00:11:12,760 --> 00:11:18,250
research in university of cambridge and

00:11:14,310 --> 00:11:20,500
his PhD thesis was basically about the

00:11:18,250 --> 00:11:22,690
unification of statically typed and

00:11:20,500 --> 00:11:24,310
dynamically typed languages this is

00:11:22,690 --> 00:11:25,780
still back when python was totally

00:11:24,310 --> 00:11:28,180
dynamically typed and he was kind of

00:11:25,780 --> 00:11:30,400
looking at python as an example what he

00:11:28,180 --> 00:11:32,110
wanted to look at was ways to use the

00:11:30,400 --> 00:11:33,880
same language for everything from a

00:11:32,110 --> 00:11:35,950
really tiny script all the way to

00:11:33,880 --> 00:11:39,310
sprawling multi-line code bases and have

00:11:35,950 --> 00:11:41,410
static typing be optional and this would

00:11:39,310 --> 00:11:42,780
allow for gradual growth means that you

00:11:41,410 --> 00:11:44,830
could take something that was

00:11:42,780 --> 00:11:45,670
dynamically typed and slowly turn into

00:11:44,830 --> 00:11:47,980
something that was

00:11:45,670 --> 00:11:50,800
typed you not to do it all at once which

00:11:47,980 --> 00:11:54,130
sounds really nice so he published his

00:11:50,800 --> 00:11:56,230
thesis in 2011 and the TLDR is this

00:11:54,130 --> 00:11:58,090
basically he determined that adding a

00:11:56,230 --> 00:12:00,730
static type system to a dynamic language

00:11:58,090 --> 00:12:03,400
is basically it totally invasive and

00:12:00,730 --> 00:12:04,570
would be a huge dramatic change require

00:12:03,400 --> 00:12:06,390
changing basically everything in

00:12:04,570 --> 00:12:08,620
ecosystem and not really advisable

00:12:06,390 --> 00:12:10,660
however he found that you could create

00:12:08,620 --> 00:12:13,000
an optional pluggable type system that

00:12:10,660 --> 00:12:14,680
doesn't actually affect the semantics of

00:12:13,000 --> 00:12:16,570
a program and wouldn't actually require

00:12:14,680 --> 00:12:18,940
changing a bunch of existing code and

00:12:16,570 --> 00:12:21,790
tools to support it or really breaking

00:12:18,940 --> 00:12:24,310
compatibility with the language so this

00:12:21,790 --> 00:12:27,670
sounds pretty nice so what he did was in

00:12:24,310 --> 00:12:29,590
2013 he gave a talk at PyCon and he

00:12:27,670 --> 00:12:31,840
introduced something called my pie and

00:12:29,590 --> 00:12:33,370
my pie at the time was maybe if you've

00:12:31,840 --> 00:12:35,830
heard of my pub before it's not what you

00:12:33,370 --> 00:12:38,260
think it is he introduced my pie as an

00:12:35,830 --> 00:12:39,640
experimental variant of Python which

00:12:38,260 --> 00:12:41,350
would support writing programs that

00:12:39,640 --> 00:12:44,650
seamlessly mix dynamic and Static typing

00:12:41,350 --> 00:12:46,090
so basically in his research he didn't

00:12:44,650 --> 00:12:47,740
actually he couldn't use any of the

00:12:46,090 --> 00:12:49,270
existing languages to determine how to

00:12:47,740 --> 00:12:50,650
do this and since it was just research

00:12:49,270 --> 00:12:54,190
what he did was he created his own

00:12:50,650 --> 00:12:55,870
language I it was called a lore I think

00:12:54,190 --> 00:12:58,000
it's what it was called and this

00:12:55,870 --> 00:13:00,040
language could be compiled to Python and

00:12:58,000 --> 00:13:01,780
that language also supports static

00:13:00,040 --> 00:13:03,100
typing and it looked like this so it

00:13:01,780 --> 00:13:05,350
kind of actually looks a little bit like

00:13:03,100 --> 00:13:07,270
Python but it would let us do function

00:13:05,350 --> 00:13:10,030
annotation and variable annotation or

00:13:07,270 --> 00:13:11,440
all those other things so the issue is

00:13:10,030 --> 00:13:13,090
that even with the function annotations

00:13:11,440 --> 00:13:15,220
I just talked about Python couldn't

00:13:13,090 --> 00:13:17,650
support everything that was necessary to

00:13:15,220 --> 00:13:19,420
be statically typed itself and so what

00:13:17,650 --> 00:13:21,460
happened was he gave this talk at PyCon

00:13:19,420 --> 00:13:22,870
he presented it and then he just he

00:13:21,460 --> 00:13:24,700
talked to Ito about it afterwards and

00:13:22,870 --> 00:13:26,620
Gaeta was like hey don't don't keep

00:13:24,700 --> 00:13:28,000
working on this Python variant let's

00:13:26,620 --> 00:13:30,720
just make this work with a regular

00:13:28,000 --> 00:13:33,190
Python which i think is a good idea and

00:13:30,720 --> 00:13:35,080
at this time the other thing to note is

00:13:33,190 --> 00:13:37,660
that my PI was this variant but it also

00:13:35,080 --> 00:13:39,910
included this type checker that you

00:13:37,660 --> 00:13:42,190
could run on the variant to determine if

00:13:39,910 --> 00:13:44,650
it was correct if the typing was correct

00:13:42,190 --> 00:13:47,920
and that type checker is actually what

00:13:44,650 --> 00:13:50,560
we'll see becomes my PI so they did some

00:13:47,920 --> 00:13:52,780
collaboration and Kito published at 483

00:13:50,560 --> 00:13:54,610
this is guiteau's theory of type-ins

00:13:52,780 --> 00:13:57,910
based on some really high level ideas

00:13:54,610 --> 00:13:59,740
about how typing should work in PI

00:13:57,910 --> 00:14:00,880
so one thing really important to Guiteau

00:13:59,740 --> 00:14:03,339
that he got from you cos research

00:14:00,880 --> 00:14:05,110
optional typing right and I think this

00:14:03,339 --> 00:14:07,389
is sort of a lesson that we learned from

00:14:05,110 --> 00:14:08,620
the Python 2 to 3 migration we want to

00:14:07,389 --> 00:14:09,970
make this optional we don't wanna make

00:14:08,620 --> 00:14:13,000
this invasive you want to make this easy

00:14:09,970 --> 00:14:14,440
for people to adopt so basically an

00:14:13,000 --> 00:14:16,240
annotated function or an annotated

00:14:14,440 --> 00:14:17,740
variable should be and behave exactly

00:14:16,240 --> 00:14:19,120
the same way as one that was not

00:14:17,740 --> 00:14:21,370
annotated you shouldn't actually notice

00:14:19,120 --> 00:14:22,660
the difference the other was gradual

00:14:21,370 --> 00:14:24,370
typing right you shouldn't have to type

00:14:22,660 --> 00:14:25,779
your entire code base all at once if you

00:14:24,370 --> 00:14:27,670
have five million lines of Python code

00:14:25,779 --> 00:14:29,290
that's actually impossible so you should

00:14:27,670 --> 00:14:31,420
be able to do type some of your code

00:14:29,290 --> 00:14:33,370
type leave some of your other code

00:14:31,420 --> 00:14:35,350
untyped and have them run together and

00:14:33,370 --> 00:14:36,610
have it not cause problems and also if

00:14:35,350 --> 00:14:37,810
you want to check the code be able to

00:14:36,610 --> 00:14:40,209
check only certain parts of it

00:14:37,810 --> 00:14:41,680
another was variable annotation so we

00:14:40,209 --> 00:14:43,720
had function annotations already we

00:14:41,680 --> 00:14:44,889
needed a way to annotate variables and

00:14:43,720 --> 00:14:47,470
the pep talks a little bit about how we

00:14:44,889 --> 00:14:49,570
could do this so if I had a function

00:14:47,470 --> 00:14:52,720
like this I have the return type is baz

00:14:49,570 --> 00:14:54,760
in the middle there we could just add

00:14:52,720 --> 00:14:56,529
comments basically as what geeta said we

00:14:54,760 --> 00:14:58,180
could add a type comment it says it's in

00:14:56,529 --> 00:14:59,290
and our type checker can infer from the

00:14:58,180 --> 00:15:01,180
comments what the type of that variable

00:14:59,290 --> 00:15:02,769
should be this sort of like a way to

00:15:01,180 --> 00:15:04,180
decide step around actually having to

00:15:02,769 --> 00:15:06,399
change the syntax of the language to

00:15:04,180 --> 00:15:08,920
support this and the nice thing about

00:15:06,399 --> 00:15:10,870
type comments is that even though we got

00:15:08,920 --> 00:15:12,699
function annotations in Python three

00:15:10,870 --> 00:15:14,410
type comments mean that we could go back

00:15:12,699 --> 00:15:18,519
in time to Python two and still do

00:15:14,410 --> 00:15:20,050
static typing so even because even

00:15:18,519 --> 00:15:22,149
though stuck in time like they deserve

00:15:20,050 --> 00:15:25,149
function annotations and static typing

00:15:22,149 --> 00:15:27,370
as well so you take a Python free typed

00:15:25,149 --> 00:15:28,870
function like this and you could type it

00:15:27,370 --> 00:15:32,350
in Python two as well by adding a type

00:15:28,870 --> 00:15:33,940
comment thanks this step also introduced

00:15:32,350 --> 00:15:35,199
some special type constructs which it

00:15:33,940 --> 00:15:36,760
didn't exist before which we're really

00:15:35,199 --> 00:15:38,980
important to being able to do static

00:15:36,760 --> 00:15:41,920
typing so we had existing types like

00:15:38,980 --> 00:15:43,660
integer float stir but it also

00:15:41,920 --> 00:15:45,880
introduced some new types these came in

00:15:43,660 --> 00:15:47,680
a module called the typing module so if

00:15:45,880 --> 00:15:51,100
things like any any is like a wild card

00:15:47,680 --> 00:15:52,839
for types any type will match any the

00:15:51,100 --> 00:15:55,300
Union is a combination of multiple types

00:15:52,839 --> 00:15:58,329
so it'd be a variable that could be one

00:15:55,300 --> 00:16:00,699
or more different types optional would

00:15:58,329 --> 00:16:02,680
be the alias between one type and none

00:16:00,699 --> 00:16:04,959
and there's also tuple and call which

00:16:02,680 --> 00:16:06,010
would represent a function so this would

00:16:04,959 --> 00:16:08,470
allow us to write a function like this

00:16:06,010 --> 00:16:09,930
now we could use Union to say that okay

00:16:08,470 --> 00:16:11,190
from Kate we'll take an integer

00:16:09,930 --> 00:16:13,590
and integer and then the third argument

00:16:11,190 --> 00:16:15,510
could be an integer or a float and thus

00:16:13,590 --> 00:16:17,010
the return type if we're adding possible

00:16:15,510 --> 00:16:19,320
floats to integers that should also be a

00:16:17,010 --> 00:16:21,420
union of an integer and a float and this

00:16:19,320 --> 00:16:23,040
would be typed checked as valid right

00:16:21,420 --> 00:16:24,660
and we would be able to verify that

00:16:23,040 --> 00:16:26,010
every time that we call from the key it

00:16:24,660 --> 00:16:27,270
has an integer integer and then

00:16:26,010 --> 00:16:30,060
something that looks like an integer or

00:16:27,270 --> 00:16:31,710
float the other thing it defines is

00:16:30,060 --> 00:16:33,420
container types so container types are

00:16:31,710 --> 00:16:36,900
things like lists and dictionaries that

00:16:33,420 --> 00:16:38,760
contain other objects so in the pepp it

00:16:36,900 --> 00:16:40,320
says all right well we want to be able

00:16:38,760 --> 00:16:42,330
to say like I'm gonna create a list and

00:16:40,320 --> 00:16:46,590
this is only gonna be integers so it

00:16:42,330 --> 00:16:49,590
creates a way to create create new types

00:16:46,590 --> 00:16:52,050
from base base types like a list to say

00:16:49,590 --> 00:16:53,970
okay like I can add integers to my list

00:16:52,050 --> 00:16:55,980
but I can add strings had a dictionary

00:16:53,970 --> 00:16:59,700
that had a key of a string value of an

00:16:55,980 --> 00:17:01,230
integer I can do the opposite of that it

00:16:59,700 --> 00:17:03,210
adds generic types for when a class the

00:17:01,230 --> 00:17:05,610
function behaves in generic manner this

00:17:03,210 --> 00:17:08,040
would be like just the general iterable

00:17:05,610 --> 00:17:09,600
class for example so if we just want

00:17:08,040 --> 00:17:11,940
something that supports the inner

00:17:09,600 --> 00:17:13,650
function that could be a whole class of

00:17:11,940 --> 00:17:14,880
different things if we want to just say

00:17:13,650 --> 00:17:17,630
alright this is an inner bowl that has

00:17:14,880 --> 00:17:21,240
tasks inside it we could create a new

00:17:17,630 --> 00:17:22,560
interval type and I said here like tasks

00:17:21,240 --> 00:17:24,480
I'm using as a type here but you can see

00:17:22,560 --> 00:17:26,250
it's also defined as a class the other

00:17:24,480 --> 00:17:28,500
thing that this pepp did was it gave us

00:17:26,250 --> 00:17:30,840
the relationship between classes and

00:17:28,500 --> 00:17:32,850
types basically defines a lot of type is

00:17:30,840 --> 00:17:35,070
how subtypes really to it and the

00:17:32,850 --> 00:17:36,810
difference between what class isn't on

00:17:35,070 --> 00:17:38,880
type is because like I said before when

00:17:36,810 --> 00:17:40,710
I say type of 42 we were actually

00:17:38,880 --> 00:17:43,230
getting a class here class is just the

00:17:40,710 --> 00:17:45,330
type so we can create new classes and

00:17:43,230 --> 00:17:48,450
these are basically the same thing as a

00:17:45,330 --> 00:17:50,210
type of that instance so we can use type

00:17:48,450 --> 00:17:52,380
to determine what the classes here and

00:17:50,210 --> 00:17:53,790
yeah actually I bet most people didn't

00:17:52,380 --> 00:17:55,590
notice you can instantiate an n right

00:17:53,790 --> 00:17:58,200
and it is just a class in open closed

00:17:55,590 --> 00:17:59,850
paren will give you 0 and class in it's

00:17:58,200 --> 00:18:02,670
just that or the type of that integer is

00:17:59,850 --> 00:18:05,040
just an int and then we can also do

00:18:02,670 --> 00:18:06,810
custom classes so custom class obviously

00:18:05,040 --> 00:18:09,360
it's still a class but it can also be a

00:18:06,810 --> 00:18:11,520
type so we can use this as a type

00:18:09,360 --> 00:18:13,260
elsewhere and then the other thing to

00:18:11,520 --> 00:18:15,150
note is that these special kind of

00:18:13,260 --> 00:18:17,040
constructs that introduced before they

00:18:15,150 --> 00:18:18,630
can't actually be instantiated right it

00:18:17,040 --> 00:18:19,690
doesn't make sense to instantiate the

00:18:18,630 --> 00:18:24,129
union of a string

00:18:19,690 --> 00:18:25,860
it doesn't what is that even the one

00:18:24,129 --> 00:18:28,929
last thing this pep introduced was the

00:18:25,860 --> 00:18:30,070
ability to basically alias types so if

00:18:28,929 --> 00:18:32,919
we wanted to be a little bit more like

00:18:30,070 --> 00:18:35,200
JavaScript we could alias number two the

00:18:32,919 --> 00:18:37,230
union of all our number types and yeah

00:18:35,200 --> 00:18:39,850
it'd just be a little more confusing

00:18:37,230 --> 00:18:41,080
there's another pet at 484 so this

00:18:39,850 --> 00:18:42,940
basically took everything that is

00:18:41,080 --> 00:18:45,610
defined in the theory of types in Python

00:18:42,940 --> 00:18:47,620
and standardizes it standardizes

00:18:45,610 --> 00:18:49,509
everything in pet 43 and essentially

00:18:47,620 --> 00:18:51,580
standardizes myapi is behavior at this

00:18:49,509 --> 00:18:54,250
point it introduces the typing module

00:18:51,580 --> 00:18:57,009
the python includes a lot a lot of

00:18:54,250 --> 00:18:58,600
details about edge cases specific use

00:18:57,009 --> 00:19:00,100
cases and basically just gives us all

00:18:58,600 --> 00:19:04,509
the building blocks of tools we need to

00:19:00,100 --> 00:19:06,340
have type system so that was released in

00:19:04,509 --> 00:19:08,799
python pepper 484 support was in python

00:19:06,340 --> 00:19:11,500
3 5 which was least in 2015 not long

00:19:08,799 --> 00:19:13,389
after that we got pet 526 this gave us a

00:19:11,500 --> 00:19:15,159
true syntax support for variable

00:19:13,389 --> 00:19:17,529
annotations so we didn't have to keep

00:19:15,159 --> 00:19:19,720
using comments like this if we were

00:19:17,529 --> 00:19:21,610
instantiate a list instead of a comment

00:19:19,720 --> 00:19:24,100
we could just do this sort of like what

00:19:21,610 --> 00:19:25,509
we do in arguments one problem with a

00:19:24,100 --> 00:19:27,549
comment annotation it was awkward to

00:19:25,509 --> 00:19:29,769
instantiate a variable that didn't have

00:19:27,549 --> 00:19:31,360
a value yet so in the second example

00:19:29,769 --> 00:19:32,919
that just becomes something like this

00:19:31,360 --> 00:19:35,139
and you don't have to give it a value at

00:19:32,919 --> 00:19:36,940
that point and like the same thing for

00:19:35,139 --> 00:19:39,970
these things so I class variable is of a

00:19:36,940 --> 00:19:42,039
dictionary of strings of integers so pet

00:19:39,970 --> 00:19:44,019
5:26 support came in Python 3 6 which is

00:19:42,039 --> 00:19:46,330
in 2017 and at this point we had almost

00:19:44,019 --> 00:19:48,279
pretty much everything to do static

00:19:46,330 --> 00:19:50,830
typing in Python the last thing we need

00:19:48,279 --> 00:19:52,360
was a type checker right what uses

00:19:50,830 --> 00:19:53,590
writing all these annotations in your

00:19:52,360 --> 00:19:55,450
code if there's nothing that's going to

00:19:53,590 --> 00:19:58,450
check it so it's the last piece of the

00:19:55,450 --> 00:20:00,429
puzzle and basically there's two kind of

00:19:58,450 --> 00:20:02,139
types of type checkers they're also

00:20:00,429 --> 00:20:02,889
static and dynamic static means that

00:20:02,139 --> 00:20:04,419
they're not actually going to execute

00:20:02,889 --> 00:20:07,259
your code they're gonna look at it at

00:20:04,419 --> 00:20:09,429
rest and infer from it how it is written

00:20:07,259 --> 00:20:10,899
what the types are dynamic is gonna

00:20:09,429 --> 00:20:14,320
actually run with you at runtime and

00:20:10,899 --> 00:20:15,940
watch what your types are as you go so

00:20:14,320 --> 00:20:18,340
by this point my PI Hedren just

00:20:15,940 --> 00:20:20,320
transitioned from this Python variant

00:20:18,340 --> 00:20:21,970
that was kind of weird into an actress

00:20:20,320 --> 00:20:23,289
the type checker right and that was

00:20:21,970 --> 00:20:24,940
available on PI P and you could install

00:20:23,289 --> 00:20:27,129
and you can install now and the way it

00:20:24,940 --> 00:20:28,389
works is you install it you have a

00:20:27,129 --> 00:20:30,820
little file that has some Python code

00:20:28,389 --> 00:20:32,900
and that's annotated and maybe it's not

00:20:30,820 --> 00:20:34,940
being done correctly so if you run

00:20:32,900 --> 00:20:36,020
my pile on that file it will throw a

00:20:34,940 --> 00:20:37,880
bunch airs and say alright your

00:20:36,020 --> 00:20:39,080
arguments they're supposed to be strings

00:20:37,880 --> 00:20:41,510
but they got are supposed to be integers

00:20:39,080 --> 00:20:42,890
but their strings instead so there are a

00:20:41,510 --> 00:20:44,900
bunch of other type checkers besides

00:20:42,890 --> 00:20:47,270
myapi at this point so basically

00:20:44,900 --> 00:20:48,230
although like big Python shops have

00:20:47,270 --> 00:20:52,460
their own type checkers

00:20:48,230 --> 00:20:55,040
they all support pet v for pet 484 which

00:20:52,460 --> 00:20:56,180
is the standardization pet there are

00:20:55,040 --> 00:20:58,280
others that don't support that

00:20:56,180 --> 00:20:59,570
specification exactly but these are the

00:20:58,280 --> 00:21:01,370
ones that are probably most in use my

00:20:59,570 --> 00:21:03,530
pies from at this point is mostly from

00:21:01,370 --> 00:21:05,480
Dropbox as supported by Dropbox my type

00:21:03,530 --> 00:21:07,490
comes from Google hires from Facebook

00:21:05,480 --> 00:21:08,960
pyrites from Microsoft and there are

00:21:07,490 --> 00:21:11,630
other those are all static ones or

00:21:08,960 --> 00:21:12,800
dynamic ones as well they don't come

00:21:11,630 --> 00:21:15,470
from the big companies because the

00:21:12,800 --> 00:21:18,320
dynamic type checker thinks is gonna add

00:21:15,470 --> 00:21:20,510
a little bit of overhead to the actual

00:21:18,320 --> 00:21:22,700
running of your function so there are

00:21:20,510 --> 00:21:24,230
maybe used as much in production so

00:21:22,700 --> 00:21:26,570
disclaimer like I said I work at Google

00:21:24,230 --> 00:21:28,520
so I actually am somewhat partial to

00:21:26,570 --> 00:21:30,710
high type it's also available on pipey I

00:21:28,520 --> 00:21:32,390
and the inevitable question whenever you

00:21:30,710 --> 00:21:33,770
talk to someone about multiple type

00:21:32,390 --> 00:21:37,250
checkers is like okay what's the

00:21:33,770 --> 00:21:38,510
difference they both support pet 484 why

00:21:37,250 --> 00:21:40,130
would I use one or the other like is one

00:21:38,510 --> 00:21:43,160
a little bit faster save me some time

00:21:40,130 --> 00:21:44,390
and so there are actually some

00:21:43,160 --> 00:21:45,950
differences between the two and they

00:21:44,390 --> 00:21:49,040
basically the differences are things

00:21:45,950 --> 00:21:50,870
that aren't specified in pet 44 so for

00:21:49,040 --> 00:21:53,540
my PI and PI type which are probably

00:21:50,870 --> 00:21:55,100
most widely used ones the differences

00:21:53,540 --> 00:21:57,950
are what I'll call cross function in

00:21:55,100 --> 00:21:59,690
inference and runtime lenience so the

00:21:57,950 --> 00:22:01,730
first example is if I have this code

00:21:59,690 --> 00:22:03,800
it's totally untyped the first function

00:22:01,730 --> 00:22:05,240
returns a string second function calls

00:22:03,800 --> 00:22:07,370
that function and then tries to add an

00:22:05,240 --> 00:22:09,140
integer to it if I run this it's gonna

00:22:07,370 --> 00:22:11,690
fail right I'll get a type error you can

00:22:09,140 --> 00:22:13,220
add strings and integers together I for

00:22:11,690 --> 00:22:15,740
one this through my PI sorry it's a

00:22:13,220 --> 00:22:17,300
little small my does nothing it's like

00:22:15,740 --> 00:22:19,400
we didn't type any of that code I don't

00:22:17,300 --> 00:22:21,860
know what it is so it's between multiple

00:22:19,400 --> 00:22:23,210
functions I can't keep track of this if

00:22:21,860 --> 00:22:25,100
you run through PI type I type will blow

00:22:23,210 --> 00:22:26,720
up and say hey like I know this is gonna

00:22:25,100 --> 00:22:27,740
be a runtime error I can infer that from

00:22:26,720 --> 00:22:29,929
the way that you're calling these

00:22:27,740 --> 00:22:31,220
functions and you probably want to fix

00:22:29,929 --> 00:22:32,809
that and then that's actually pretty

00:22:31,220 --> 00:22:35,030
handy because when you're migrating code

00:22:32,809 --> 00:22:37,070
from dynamically to statically typed a

00:22:35,030 --> 00:22:38,090
lot of your code is still gonna be you

00:22:37,070 --> 00:22:39,380
know these other functions that you're

00:22:38,090 --> 00:22:41,000
calling they're not gonna be tight they

00:22:39,380 --> 00:22:41,990
might be in a third party module might

00:22:41,000 --> 00:22:43,970
be elsewhere in your code base you're

00:22:41,990 --> 00:22:45,800
not ready to type it yet so this this

00:22:43,970 --> 00:22:46,250
function L is actually quite nice I

00:22:45,800 --> 00:22:50,030
think in

00:22:46,250 --> 00:22:52,100
I type another example is this example

00:22:50,030 --> 00:22:53,750
so here there's just more untyped code

00:22:52,100 --> 00:22:55,220
right we're creating a list we're trying

00:22:53,750 --> 00:22:56,450
to depend an integer to it and that

00:22:55,220 --> 00:22:58,760
should be fine right this is totally

00:22:56,450 --> 00:23:00,290
valid Python create a list that has a

00:22:58,760 --> 00:23:02,390
string in it append an integer and then

00:23:00,290 --> 00:23:04,130
we cast them all to strings and return

00:23:02,390 --> 00:23:07,100
that value so if I run that that works

00:23:04,130 --> 00:23:08,960
like I Colorado 2019 if I run that with

00:23:07,100 --> 00:23:11,300
PI type it says no errors down write

00:23:08,960 --> 00:23:13,100
anything that is gonna not if it would

00:23:11,300 --> 00:23:14,570
work when you run the function it's not

00:23:13,100 --> 00:23:17,410
gonna raise an error because it's not

00:23:14,570 --> 00:23:20,000
actually gonna cause problems my PI for

00:23:17,410 --> 00:23:22,790
exactly say hey I noticed that you had

00:23:20,000 --> 00:23:23,840
this this list and you're trying to put

00:23:22,790 --> 00:23:25,310
some strings in it and I are trying put

00:23:23,840 --> 00:23:26,990
interest in it like I think that might

00:23:25,310 --> 00:23:30,050
be a problem it's a little more stricter

00:23:26,990 --> 00:23:32,210
about those things okay

00:23:30,050 --> 00:23:35,150
so you might say well why though like

00:23:32,210 --> 00:23:37,670
why should I use static typing after all

00:23:35,150 --> 00:23:39,290
this so first I'm gonna say why you

00:23:37,670 --> 00:23:41,180
shouldn't use that typing and the answer

00:23:39,290 --> 00:23:43,010
is basically never there are some times

00:23:41,180 --> 00:23:45,140
that you might not want it one example

00:23:43,010 --> 00:23:47,540
that I want to point out that typing is

00:23:45,140 --> 00:23:48,680
not a replacement for unit tests so

00:23:47,540 --> 00:23:51,020
there's actually like kind of a school

00:23:48,680 --> 00:23:52,490
of thought here that because the unit

00:23:51,020 --> 00:23:54,020
tests are actually sometimes they end up

00:23:52,490 --> 00:23:56,570
kind of just being like a bad type

00:23:54,020 --> 00:23:58,160
system this this tweet says basically

00:23:56,570 --> 00:24:00,200
type checking catches all these bugs

00:23:58,160 --> 00:24:02,180
that existed even when unit tests

00:24:00,200 --> 00:24:04,640
existed and unit tests are kind of

00:24:02,180 --> 00:24:06,710
acting like that type system however

00:24:04,640 --> 00:24:08,240
it's kind of just a bad idea to get rid

00:24:06,710 --> 00:24:10,820
of your unit tests and replacing the

00:24:08,240 --> 00:24:12,440
static typing like you you actually kind

00:24:10,820 --> 00:24:15,260
of probably need both you need unit

00:24:12,440 --> 00:24:17,390
tests and you need static typing when

00:24:15,260 --> 00:24:20,110
should you use static typing basically

00:24:17,390 --> 00:24:22,340
use as much as possible use it liberally

00:24:20,110 --> 00:24:24,050
you should use static typing if you're

00:24:22,340 --> 00:24:26,450
at millions of lines of Python code

00:24:24,050 --> 00:24:27,680
scale definitely if you're at this point

00:24:26,450 --> 00:24:29,600
you probably like writing your own

00:24:27,680 --> 00:24:31,760
static type checker or using one of the

00:24:29,600 --> 00:24:33,050
ones already but that's the point where

00:24:31,760 --> 00:24:35,420
it's kind of sweet spot

00:24:33,050 --> 00:24:37,640
Yuuka said in this blog post that he

00:24:35,420 --> 00:24:39,350
recently published at dropbox of scale

00:24:37,640 --> 00:24:41,540
and a facebook google scale basically

00:24:39,350 --> 00:24:42,980
these companies invested a lot of money

00:24:41,540 --> 00:24:45,020
and the work that they've done the

00:24:42,980 --> 00:24:47,330
static type systems because the lack of

00:24:45,020 --> 00:24:49,970
static typing causes is a huge liability

00:24:47,330 --> 00:24:51,470
for Python at this scale right it makes

00:24:49,970 --> 00:24:52,910
the code needlessly hard to understand

00:24:51,470 --> 00:24:54,290
it's hard to pick up it's hard to look

00:24:52,910 --> 00:24:56,090
at code and understand what it's doing

00:24:54,290 --> 00:24:58,190
when it doesn't have types so basically

00:24:56,090 --> 00:24:58,470
this is the graph that you should have

00:24:58,190 --> 00:25:00,990
any

00:24:58,470 --> 00:25:03,600
mind as your lines of code increase your

00:25:00,990 --> 00:25:05,039
desire to add type annotations is

00:25:03,600 --> 00:25:07,169
definitely gonna go up and it will start

00:25:05,039 --> 00:25:08,309
to go up very quickly and the ease of

00:25:07,169 --> 00:25:09,960
doing it will go down and there's a

00:25:08,309 --> 00:25:12,450
sweet spot here right so you're probably

00:25:09,960 --> 00:25:14,280
like here and maybe your company's about

00:25:12,450 --> 00:25:16,230
to get like Dropbox eyes and you're

00:25:14,280 --> 00:25:17,340
gonna have millions lines of code that's

00:25:16,230 --> 00:25:19,200
where you should migrate that's we

00:25:17,340 --> 00:25:20,700
should start adding you know type

00:25:19,200 --> 00:25:22,650
annotations that's probably where you're

00:25:20,700 --> 00:25:24,210
actually gonna do it but that's okay

00:25:22,650 --> 00:25:26,309
you'll still be able to do I mean

00:25:24,210 --> 00:25:28,280
Dropbox is able to do it they ported

00:25:26,309 --> 00:25:31,559
millions of lines of code at this point

00:25:28,280 --> 00:25:36,720
you should also use static typing okay

00:25:31,559 --> 00:25:38,940
so you want that one you should also use

00:25:36,720 --> 00:25:40,950
static typing just when your code is

00:25:38,940 --> 00:25:42,720
gonna be confusing like let's be honest

00:25:40,950 --> 00:25:44,760
we're all writing confusing code I've

00:25:42,720 --> 00:25:46,289
written confusing code annotations are

00:25:44,760 --> 00:25:47,429
basically and this is not my quote

00:25:46,289 --> 00:25:49,740
annotations are basically a machine

00:25:47,429 --> 00:25:51,720
verified documentation right your

00:25:49,740 --> 00:25:53,130
machine will verify the the

00:25:51,720 --> 00:25:55,530
documentation that you've done by adding

00:25:53,130 --> 00:25:56,970
type annotations if you feel like you

00:25:55,530 --> 00:25:58,830
need to document what the input and

00:25:56,970 --> 00:26:00,799
output of a function is gonna be you

00:25:58,830 --> 00:26:02,940
probably should add static typing to it

00:26:00,799 --> 00:26:04,890
you should also use static typing when

00:26:02,940 --> 00:26:07,080
your code is fit for public consumption

00:26:04,890 --> 00:26:08,580
so if it's gonna be a module and PI API

00:26:07,080 --> 00:26:11,159
or a library that's shared amongst

00:26:08,580 --> 00:26:12,750
multiple services and your team adding

00:26:11,159 --> 00:26:14,789
type annotations is gonna let developers

00:26:12,750 --> 00:26:17,640
know how they use the API is that you're

00:26:14,789 --> 00:26:19,679
distributing with your module it also is

00:26:17,640 --> 00:26:22,530
gonna help IDs like pycharm figure out

00:26:19,679 --> 00:26:24,000
where and how to use these models as

00:26:22,530 --> 00:26:26,669
well do a lot of completion that kind of

00:26:24,000 --> 00:26:28,440
thing and also if your users are already

00:26:26,669 --> 00:26:30,179
using static typing they're gonna really

00:26:28,440 --> 00:26:32,700
love that your third party code is

00:26:30,179 --> 00:26:34,559
statically typed as well not the time to

00:26:32,700 --> 00:26:36,270
use static typing is before migrating or

00:26:34,559 --> 00:26:38,159
refactoring so act I think is gonna be

00:26:36,270 --> 00:26:39,809
really helpful if you're doing a huge

00:26:38,159 --> 00:26:41,669
migration right cuz you're gonna know

00:26:39,809 --> 00:26:43,169
immediately if you statically type all

00:26:41,669 --> 00:26:44,940
of your functions then you go and do

00:26:43,169 --> 00:26:47,039
your refactor your migration from one

00:26:44,940 --> 00:26:48,929
Python version to another it'll tell you

00:26:47,039 --> 00:26:50,940
when they break so it's really helpful

00:26:48,929 --> 00:26:52,620
there you should all see you stack

00:26:50,940 --> 00:26:54,179
typing if you just want to experiment

00:26:52,620 --> 00:26:55,799
let's static typing right it doesn't

00:26:54,179 --> 00:26:57,600
hurt and it's not gonna slow you down

00:26:55,799 --> 00:26:59,070
it's just kind of interesting to

00:26:57,600 --> 00:27:01,799
experiment with and you should give it a

00:26:59,070 --> 00:27:03,059
try and also you should use static

00:27:01,799 --> 00:27:05,280
typing if you're just cold

00:27:03,059 --> 00:27:07,250
Gary Bernhardt says sightings are a warm

00:27:05,280 --> 00:27:09,890
blanket that I have missed so much

00:27:07,250 --> 00:27:11,390
so I guess they also make you warmer by

00:27:09,890 --> 00:27:13,730
the way Gary also has like the best

00:27:11,390 --> 00:27:16,880
background on his Twitter right now for

00:27:13,730 --> 00:27:17,570
this talk Gary was stung to death by

00:27:16,880 --> 00:27:20,210
Tigers

00:27:17,570 --> 00:27:22,640
Gary's awesome all right so here's how

00:27:20,210 --> 00:27:24,770
to use python static typing in python in

00:27:22,640 --> 00:27:26,510
five easy steps so first migrate to

00:27:24,770 --> 00:27:28,250
python greater than equal to three six

00:27:26,510 --> 00:27:29,450
you can do type comments in python to

00:27:28,250 --> 00:27:32,000
seven but let's be honest you should

00:27:29,450 --> 00:27:33,679
migrate anyway you should install a type

00:27:32,000 --> 00:27:35,360
checker locally i don't care which one

00:27:33,679 --> 00:27:37,789
just install one against all multiple

00:27:35,360 --> 00:27:39,200
ones if you want I don't care and then

00:27:37,789 --> 00:27:41,510
you can start optionally typing your

00:27:39,200 --> 00:27:43,039
code base like pick your hairiest file

00:27:41,510 --> 00:27:44,840
or your hardest function or like pick

00:27:43,039 --> 00:27:46,190
the easiest one no probably the easiest

00:27:44,840 --> 00:27:48,260
to do and you'll have to do it all the

00:27:46,190 --> 00:27:49,789
ones remember it's like it's gradual for

00:27:48,260 --> 00:27:51,320
a reason you don't have to invest all

00:27:49,789 --> 00:27:53,330
this work and to statically typing your

00:27:51,320 --> 00:27:56,539
entire code base pick a critical area

00:27:53,330 --> 00:27:58,070
and then just start there for run a type

00:27:56,539 --> 00:27:59,780
checker with your linting just do it at

00:27:58,070 --> 00:28:01,490
the same time it doesn't need to happen

00:27:59,780 --> 00:28:03,500
to run time just do it when you let your

00:28:01,490 --> 00:28:06,620
code do it when you run whack everyone's

00:28:03,500 --> 00:28:08,510
doing black right and finally then

00:28:06,620 --> 00:28:10,460
convince all your co-workers to join you

00:28:08,510 --> 00:28:12,320
in static typing and if you need help

00:28:10,460 --> 00:28:15,140
convincing them just tell them to come

00:28:12,320 --> 00:28:16,510
watch this YouTube video alright thanks

00:28:15,140 --> 00:28:20,810
everybody

00:28:16,510 --> 00:28:28,229
[Applause]

00:28:20,810 --> 00:28:28,229
[Music]

00:28:30,559 --> 00:28:32,620

YouTube URL: https://www.youtube.com/watch?v=8BNuawmpFXQ


