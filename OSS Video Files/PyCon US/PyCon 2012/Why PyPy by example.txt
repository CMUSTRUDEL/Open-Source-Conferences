Title: Why PyPy by example
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Maciej Fijalkowski, Alex Gaynor, Armin Rigo
One of the goals of PyPy is to make existing Python code faster, however an
even broader goal was to make it possible to write things in Python that
previous would needed to be written in C or other low-l
Captions: 
	00:00:00,030 --> 00:00:05,730
this is the real session of Evil

00:00:02,490 --> 00:00:08,250
Geniuses a little bit of a change up

00:00:05,730 --> 00:00:10,200
from yesterday we kind of ran sessions

00:00:08,250 --> 00:00:12,809
into each other yesterday the talks

00:00:10,200 --> 00:00:14,700
today we just want to make sure although

00:00:12,809 --> 00:00:17,220
in your schedules it says this

00:00:14,700 --> 00:00:19,289
particular talk goes till 11:05 or we're

00:00:17,220 --> 00:00:20,550
going to end at 1055 that's including

00:00:19,289 --> 00:00:23,519
questions so there's a 10-minute break

00:00:20,550 --> 00:00:26,279
between between the different talks so

00:00:23,519 --> 00:00:28,619
our first talk of the day y-pipe I by

00:00:26,279 --> 00:00:31,439
example this is ma cheek via cough ski

00:00:28,619 --> 00:00:33,769
Alex Gaynor and Armen rego please give

00:00:31,439 --> 00:00:33,769
my hand

00:00:37,970 --> 00:00:43,470
so hi everyone we're the developers of

00:00:41,250 --> 00:00:45,540
pyre at least some of them and I guess

00:00:43,470 --> 00:00:48,780
we have the slightly unending position

00:00:45,540 --> 00:00:50,250
of following Dave because truthfully

00:00:48,780 --> 00:00:53,430
we've tried to give the talk he just did

00:00:50,250 --> 00:00:55,530
explaining what pi PI is many times and

00:00:53,430 --> 00:00:57,500
the general conclusion is we have failed

00:00:55,530 --> 00:01:00,300
to convince you all that we aren't crazy

00:00:57,500 --> 00:01:01,769
because we tend to sound crazy whereas

00:01:00,300 --> 00:01:04,440
Dave sounds you know sane like a

00:01:01,769 --> 00:01:07,500
scientist investigating things so it's

00:01:04,440 --> 00:01:09,300
unfortunate for us but uh so what is pi

00:01:07,500 --> 00:01:10,649
PI Dave already told you the scary stuff

00:01:09,300 --> 00:01:13,860
we're going to try to keep it high level

00:01:10,649 --> 00:01:15,780
here pi PI is a fast implementation of

00:01:13,860 --> 00:01:18,300
Python that happens to be written in

00:01:15,780 --> 00:01:20,759
Python it's it's all open source and

00:01:18,300 --> 00:01:23,009
good and we've been a project for nine

00:01:20,759 --> 00:01:26,399
or ten years now I think nine nine nine

00:01:23,009 --> 00:01:29,850
years so in a while

00:01:26,399 --> 00:01:31,649
we are fast sort of Dave mentioned I

00:01:29,850 --> 00:01:33,179
think five or six pythons ago we were

00:01:31,649 --> 00:01:36,179
there or not me I didn't even know what

00:01:33,179 --> 00:01:37,830
Python was then but uh they were there

00:01:36,179 --> 00:01:39,330
and they were saying you know we have

00:01:37,830 --> 00:01:41,070
this thing it's Python written in Python

00:01:39,330 --> 00:01:43,470
and I it's 2,000 times slower it's

00:01:41,070 --> 00:01:45,180
really cool and everyone thought we were

00:01:43,470 --> 00:01:47,880
and everyone thought we were crazy and

00:01:45,180 --> 00:01:49,799
so like four years ago it was oh we've

00:01:47,880 --> 00:01:51,869
got this thing it's ten times slower and

00:01:49,799 --> 00:01:54,329
then three years ago was like oh we've

00:01:51,869 --> 00:01:56,759
got this thing and it's like maybe 20%

00:01:54,329 --> 00:01:58,860
faster to four times slower and like

00:01:56,759 --> 00:01:59,759
last year were like oh this time we

00:01:58,860 --> 00:02:02,369
really have this thing now it's like

00:01:59,759 --> 00:02:04,470
five times faster and that was pretty

00:02:02,369 --> 00:02:06,119
cool but so now we're we're at this

00:02:04,470 --> 00:02:08,130
really cool point we're like we're not

00:02:06,119 --> 00:02:09,509
trying to put numbers to how much faster

00:02:08,130 --> 00:02:11,250
we are you can go there

00:02:09,509 --> 00:02:13,920
speed up hi pilot or you can see we've

00:02:11,250 --> 00:02:16,470
got benchmarks there expert x times

00:02:13,920 --> 00:02:19,140
faster it's awesome but we're really

00:02:16,470 --> 00:02:21,660
happy to be a point sort of where we can

00:02:19,140 --> 00:02:24,120
say the performance if it's not faster

00:02:21,660 --> 00:02:26,130
that's a bug how much is very dependent

00:02:24,120 --> 00:02:27,420
on your program so we think that's

00:02:26,130 --> 00:02:30,840
actually a really cool place to be

00:02:27,420 --> 00:02:32,610
because that means every program we're

00:02:30,840 --> 00:02:34,470
targeting to be as fast as it can be

00:02:32,610 --> 00:02:35,609
we're not looking at what is the speed

00:02:34,470 --> 00:02:37,980
of the interpreter now we're looking at

00:02:35,609 --> 00:02:40,320
what is the speed of your program and so

00:02:37,980 --> 00:02:41,760
yes that means you should complain if

00:02:40,320 --> 00:02:43,380
it's not faster on your program and

00:02:41,760 --> 00:02:47,400
that's something we're very very proud

00:02:43,380 --> 00:02:48,690
of memory is also very program dependent

00:02:47,400 --> 00:02:49,500
you should measure you should complain

00:02:48,690 --> 00:02:51,450
this

00:02:49,500 --> 00:02:54,000
this is a sort of a very fun place to be

00:02:51,450 --> 00:02:56,580
we want people to come to us we get

00:02:54,000 --> 00:02:58,140
faster we get less memory usage when

00:02:56,580 --> 00:03:00,720
people tell us I have this example and

00:02:58,140 --> 00:03:03,960
you suck on it and that's how we get

00:03:00,720 --> 00:03:06,209
matter these days so now we're going to

00:03:03,960 --> 00:03:07,500
basically show a bunch of demos of stuff

00:03:06,209 --> 00:03:10,410
the pipe I can do that we don't think

00:03:07,500 --> 00:03:13,020
anyone else can do so well anyone else

00:03:10,410 --> 00:03:15,230
in terms of dynamic evm but anyway we're

00:03:13,020 --> 00:03:17,520
going to show some programs that are

00:03:15,230 --> 00:03:20,700
implemented specifically for pipe I

00:03:17,520 --> 00:03:24,050
sometimes and they're they're normal

00:03:20,700 --> 00:03:30,420
Python programs so maybe I will show you

00:03:24,050 --> 00:03:32,760
how does this not this is like a bit

00:03:30,420 --> 00:03:35,700
boring but it's a it's a Python program

00:03:32,760 --> 00:03:39,989
that accesses stuff if you look into it

00:03:35,700 --> 00:03:42,480
you'd see that EMG is not an actual list

00:03:39,989 --> 00:03:44,880
it's an object that overloads under

00:03:42,480 --> 00:03:47,840
under get item and then there will be

00:03:44,880 --> 00:03:52,140
objects it's like fully dynamic Python

00:03:47,840 --> 00:03:54,510
or what does they have a webcam here I

00:03:52,140 --> 00:03:58,140
hope it's not too dark so the JIT warms

00:03:54,510 --> 00:04:03,180
up and now it does edge detection here

00:03:58,140 --> 00:04:04,200
up yes this is a bottle I suppose yes

00:04:03,180 --> 00:04:07,590
here we go

00:04:04,200 --> 00:04:10,940
so does like somebody has stuff on their

00:04:07,590 --> 00:04:20,060
t-shirts maybe it will work nicely

00:04:10,940 --> 00:04:20,060
no it's slow the web comes slow but

00:04:22,669 --> 00:04:31,490
tries to do edge detection mm-hm to some

00:04:26,610 --> 00:04:35,850
extent anyway discern algorithm that

00:04:31,490 --> 00:04:39,200
it's implemented in Python fully and if

00:04:35,850 --> 00:04:45,000
I try to run with a default interpreter

00:04:39,200 --> 00:04:49,040
this is Python 2.7 I suppose so now we

00:04:45,000 --> 00:04:49,040
are waiting for the frame two to show up

00:04:50,630 --> 00:04:57,570
get away beat more I think takes about

00:04:53,669 --> 00:04:59,910
seven seconds to get a frame this

00:04:57,570 --> 00:05:02,120
precise example is about two thousand

00:04:59,910 --> 00:05:08,810
that oh here we go so

00:05:02,120 --> 00:05:12,790
I don't know what a virtuous negative

00:05:08,810 --> 00:05:16,000
actually it's not that slow however

00:05:12,790 --> 00:05:20,479
however this is like an example we're

00:05:16,000 --> 00:05:22,160
doing numerix in in pi pi is actually

00:05:20,479 --> 00:05:24,979
pretty fast because you operate on

00:05:22,160 --> 00:05:27,350
object on things that are integers and

00:05:24,979 --> 00:05:30,320
even though you didn't have to explain

00:05:27,350 --> 00:05:33,919
like this is see you wrote python and

00:05:30,320 --> 00:05:35,960
it's still not as fast as c but fast

00:05:33,919 --> 00:05:39,200
enough to do experimentation while it's

00:05:35,960 --> 00:05:41,479
not quite possible using using the c

00:05:39,200 --> 00:05:46,400
python i don't think anybody ever did

00:05:41,479 --> 00:05:49,280
dynamic vm and image detection before i

00:05:46,400 --> 00:05:50,930
at least I'm not aware so this is one of

00:05:49,280 --> 00:05:54,200
the examples where you would potentially

00:05:50,930 --> 00:06:03,380
use pi PI and well you want to show

00:05:54,200 --> 00:06:05,539
trace beam yeah so how do you okay so

00:06:03,380 --> 00:06:09,080
another thing we're really proud of is a

00:06:05,539 --> 00:06:10,610
we are we think tools for understanding

00:06:09,080 --> 00:06:12,289
what our programs are doing and being

00:06:10,610 --> 00:06:14,150
able to do profiling and things like

00:06:12,289 --> 00:06:16,250
that are really important a lot of the

00:06:14,150 --> 00:06:18,950
people who are looking at pi pi are not

00:06:16,250 --> 00:06:23,539
surprisingly looking at us for speed so

00:06:18,950 --> 00:06:25,610
we are we're very interested in how do

00:06:23,539 --> 00:06:27,800
we how do we understand the behavior of

00:06:25,610 --> 00:06:31,370
people's programs and there's been talks

00:06:27,800 --> 00:06:33,260
here already and about like the

00:06:31,370 --> 00:06:34,760
monitoring tools that JVM has other

00:06:33,260 --> 00:06:36,470
things in like we really want stuff like

00:06:34,760 --> 00:06:37,340
that for the Python community being able

00:06:36,470 --> 00:06:42,470
to understand

00:06:37,340 --> 00:06:46,789
they run jungles development the managed

00:06:42,470 --> 00:06:48,979
up high development run server and so we

00:06:46,789 --> 00:06:50,510
really want to have tools that allow us

00:06:48,979 --> 00:06:53,330
to do introspection of what our process

00:06:50,510 --> 00:06:56,599
is doing why it's performance is what it

00:06:53,330 --> 00:06:58,520
is and how do we get better so lately

00:06:56,599 --> 00:07:00,080
we've been working on a tool called try

00:06:58,520 --> 00:07:02,720
spin if you've seen us talk about the

00:07:00,080 --> 00:07:05,780
JIT view or tool and past this is this

00:07:02,720 --> 00:07:07,849
is the successor to that which we think

00:07:05,780 --> 00:07:09,969
makes it a whole lot better and more

00:07:07,849 --> 00:07:11,790
understandable for evil's programs so

00:07:09,969 --> 00:07:15,370
yeah

00:07:11,790 --> 00:07:20,110
so okay so an example yes so boring

00:07:15,370 --> 00:07:21,220
program does a stuff yeah

00:07:20,110 --> 00:07:26,949
can you go ahead now run it under the

00:07:21,220 --> 00:07:28,030
trace but now like the - MJ I mean like

00:07:26,949 --> 00:07:30,370
this yes

00:07:28,030 --> 00:07:32,590
no module name are you in the right

00:07:30,370 --> 00:07:36,490
Bertrille end and I don't know

00:07:32,590 --> 00:07:41,229
put it on the path yes like this

00:07:36,490 --> 00:07:46,770
yes mmm uh you got a Suffolk okay uh

00:07:41,229 --> 00:07:46,770
haha I likes your software sucks

00:07:52,080 --> 00:08:16,389
wow this is what we call alpha quality

00:07:56,710 --> 00:08:20,220
software now how now runs and we uploads

00:08:16,389 --> 00:08:20,220
our data automatically to the server and

00:08:24,419 --> 00:08:30,280
support and so it pulls up it pulls up

00:08:27,820 --> 00:08:31,870
what program we invoked which actually

00:08:30,280 --> 00:08:33,640
turns out it's actually really difficult

00:08:31,870 --> 00:08:35,349
to get exactly what program was invoked

00:08:33,640 --> 00:08:37,570
on the command line in a cross-platform

00:08:35,349 --> 00:08:40,300
way this is a shockingly hard thing to

00:08:37,570 --> 00:08:41,709
do it records our standard out how long

00:08:40,300 --> 00:08:44,290
it took and it records every single

00:08:41,709 --> 00:08:47,680
instruction the JIT compiled and scroll

00:08:44,290 --> 00:08:49,870
down to the loop look yeah and it so it

00:08:47,680 --> 00:08:52,660
records exactly what was compiled by the

00:08:49,870 --> 00:08:54,220
JIT for each line of Python code as may

00:08:52,660 --> 00:08:56,230
be worth pointing out the debug merge

00:08:54,220 --> 00:08:58,150
finds the debug information for Python

00:08:56,230 --> 00:09:00,790
bytecode so yeah that was like it's an

00:08:58,150 --> 00:09:02,950
example from our tests you end up with

00:09:00,790 --> 00:09:05,380
like seven assembler instructions for

00:09:02,950 --> 00:09:06,790
about 2500 codes that's pretty good I

00:09:05,380 --> 00:09:08,860
think yeah

00:09:06,790 --> 00:09:10,720
and so we think this is a tool that as

00:09:08,860 --> 00:09:12,520
we continue to expand and improve it and

00:09:10,720 --> 00:09:14,350
make it even more accessible to all

00:09:12,520 --> 00:09:16,839
programmers so you don't need knowledge

00:09:14,350 --> 00:09:18,850
of how exactly pi PI works to understand

00:09:16,839 --> 00:09:20,260
this tool we think being able to expose

00:09:18,850 --> 00:09:22,150
this performance information to

00:09:20,260 --> 00:09:24,160
developers really going to be super

00:09:22,150 --> 00:09:24,850
empowering and we're really pleased with

00:09:24,160 --> 00:09:26,050
like the

00:09:24,850 --> 00:09:28,720
building we have to get this debug

00:09:26,050 --> 00:09:33,190
information at runtime within our PI pi

00:09:28,720 --> 00:09:36,370
yes and some performers not least I got

00:09:33,190 --> 00:09:40,600
to say a few words about numpy so yeah

00:09:36,370 --> 00:09:44,579
trying to implement numpy and well not

00:09:40,600 --> 00:09:47,319
everybody gets excited about that and

00:09:44,579 --> 00:09:49,089
essentially we believe it's easier to

00:09:47,319 --> 00:09:52,870
add numpy to the jet that did to the

00:09:49,089 --> 00:09:54,490
numpy but it can be debatable but anyway

00:09:52,870 --> 00:09:57,519
what we are trying to achieve is that

00:09:54,490 --> 00:10:01,899
you implement numpy and you get the jet

00:09:57,519 --> 00:10:04,110
for free by optimizing well the way our

00:10:01,899 --> 00:10:06,759
JIT works make very possible so you just

00:10:04,110 --> 00:10:08,860
implements numpy as a library and i

00:10:06,759 --> 00:10:12,250
automatically works with a fast Python

00:10:08,860 --> 00:10:14,230
interpreter so you can write numpy code

00:10:12,250 --> 00:10:18,730
yes nicely vectorize but you can also

00:10:14,230 --> 00:10:21,370
write numpy code in in the way that just

00:10:18,730 --> 00:10:24,759
loops around number arrays and this will

00:10:21,370 --> 00:10:27,279
still be relatively fast but I mean

00:10:24,759 --> 00:10:29,410
twice slower than C code say and not

00:10:27,279 --> 00:10:31,149
2,000 times slower which is what you get

00:10:29,410 --> 00:10:33,880
now if you try in C Python to loop

00:10:31,149 --> 00:10:36,490
around an umpire all right super slow so

00:10:33,880 --> 00:10:38,740
we are implementing new PI and I have

00:10:36,490 --> 00:10:41,500
some preliminary results with trying to

00:10:38,740 --> 00:10:44,500
vectorize using sse and that kind of

00:10:41,500 --> 00:10:47,529
outperforms GCC on some examples so it's

00:10:44,500 --> 00:10:50,259
going really good so far but stay tuned

00:10:47,529 --> 00:10:52,360
it's probably like couple months two

00:10:50,259 --> 00:10:54,819
three months away before it's actually

00:10:52,360 --> 00:10:56,649
complete and and implements the whole

00:10:54,819 --> 00:10:59,199
numpy but this is something I'm working

00:10:56,649 --> 00:11:01,060
on this is my full-time job there's a

00:10:59,199 --> 00:11:03,189
donation button somewhere that you can

00:11:01,060 --> 00:11:13,610
donate and make it my full-time job for

00:11:03,189 --> 00:11:17,190
longer I suppose okey Armand yes so

00:11:13,610 --> 00:11:19,320
sorry about the this kind of talk which

00:11:17,190 --> 00:11:21,660
is five minutes on to PK and five minute

00:11:19,320 --> 00:11:26,550
and Big B and now I'm going to say five

00:11:21,660 --> 00:11:28,500
minutes on topic see garbage collection

00:11:26,550 --> 00:11:32,580
I'm talking here I'm addressing this

00:11:28,500 --> 00:11:34,590
audience at Pascale cone in 1982 trying

00:11:32,580 --> 00:11:39,930
to convince you that garbage collection

00:11:34,590 --> 00:11:41,670
is actually a good idea what is garbage

00:11:39,930 --> 00:11:45,690
collection you call malloc and you never

00:11:41,670 --> 00:11:48,660
need to call three very easy well of

00:11:45,690 --> 00:11:51,150
course of course of course as an

00:11:48,660 --> 00:11:53,400
implementer I cannot possibly recommend

00:11:51,150 --> 00:11:55,980
that everybody uses garbage collection

00:11:53,400 --> 00:11:59,060
because it is costly so what I'm going

00:11:55,980 --> 00:12:02,550
to propose is some some complicated

00:11:59,060 --> 00:12:04,920
system where we're actually just a small

00:12:02,550 --> 00:12:07,290
fraction of your mullux are going to be

00:12:04,920 --> 00:12:09,840
manageable garbage collection and for

00:12:07,290 --> 00:12:12,500
the rest use you still use your explicit

00:12:09,840 --> 00:12:17,070
memory management that you're so used to

00:12:12,500 --> 00:12:19,560
Android so yes but then it creates some

00:12:17,070 --> 00:12:21,690
some issues like what do you do if you

00:12:19,560 --> 00:12:25,020
have tons of pointers between the GC

00:12:21,690 --> 00:12:26,760
manage and non GC manage memory etc well

00:12:25,020 --> 00:12:30,590
it's it's sort of hard issues that are

00:12:26,760 --> 00:12:36,480
that are not sold even today absolutely

00:12:30,590 --> 00:12:38,820
well the solution of course is you put

00:12:36,480 --> 00:12:41,400
everything in the GC manage memory it

00:12:38,820 --> 00:12:43,410
means that relocation you do you hand it

00:12:41,400 --> 00:12:45,960
out to the automatic garbage collector

00:12:43,410 --> 00:12:47,970
of course of course of course of course

00:12:45,960 --> 00:12:51,150
I know it's a solution with quotes

00:12:47,970 --> 00:12:54,780
because because it's a riddle for

00:12:51,150 --> 00:12:56,400
personals I mean come on it to start

00:12:54,780 --> 00:12:59,940
with it will double the memory

00:12:56,400 --> 00:13:02,820
requirements of your program like you

00:12:59,940 --> 00:13:06,000
have you have your machine with 256

00:13:02,820 --> 00:13:09,840
kilobytes of memory you're never going

00:13:06,000 --> 00:13:11,880
to to to buy into any solution that's

00:13:09,840 --> 00:13:14,460
that does a number of requirements other

00:13:11,880 --> 00:13:17,400
than the speed when it creates pause

00:13:14,460 --> 00:13:19,080
like you have to wait four seconds for a

00:13:17,400 --> 00:13:22,010
complete garbage collection for example

00:13:19,080 --> 00:13:22,010
so

00:13:22,160 --> 00:13:30,020
so so yes I mean it's not a real

00:13:25,760 --> 00:13:32,810
solution right it's just a toy real

00:13:30,020 --> 00:13:41,120
programmers they can live with the mess

00:13:32,810 --> 00:13:43,640
of explicit memory management okay so

00:13:41,120 --> 00:13:50,870
now today I'm going to give exactly the

00:13:43,640 --> 00:13:52,520
same talk about a different topic today

00:13:50,870 --> 00:13:55,370
garbage collection is obviously

00:13:52,520 --> 00:13:59,840
automatic everywhere and I mean I mean

00:13:55,370 --> 00:14:01,780
you it was hard to get to get garbage

00:13:59,840 --> 00:14:04,730
collection done right but now it's done

00:14:01,780 --> 00:14:06,650
it's something you can assume and well

00:14:04,730 --> 00:14:08,780
we don't talk about about garbage

00:14:06,650 --> 00:14:11,510
collection unless we are we are doing

00:14:08,780 --> 00:14:14,120
some some some conference about

00:14:11,510 --> 00:14:16,820
implementation details of Java or

00:14:14,120 --> 00:14:22,190
something I mean real hard core kind of

00:14:16,820 --> 00:14:27,290
concert okay so what do we talk about

00:14:22,190 --> 00:14:29,780
now how to use multiple cores you have

00:14:27,290 --> 00:14:41,180
your photo eight core 16 core machines

00:14:29,780 --> 00:14:43,880
how do you use it well it's a mess mess

00:14:41,180 --> 00:14:48,440
with locks with reentrant lock semaphore

00:14:43,880 --> 00:14:51,440
events whatever propagating nest to get

00:14:48,440 --> 00:14:54,950
right and that even without even talking

00:14:51,440 --> 00:14:56,630
about the famous Python jail I mean the

00:14:54,950 --> 00:14:58,760
global interpreter lock which actually

00:14:56,630 --> 00:15:01,310
prevents you from getting multi-core

00:14:58,760 --> 00:15:03,470
performance of your baton program but

00:15:01,310 --> 00:15:08,840
that even if we kind of ignore this

00:15:03,470 --> 00:15:11,360
particular detail is still an ass I mean

00:15:08,840 --> 00:15:12,920
in yes in Python we have the calabria

00:15:11,360 --> 00:15:15,440
interpret a lot but we also have the

00:15:12,920 --> 00:15:18,350
threading module which means that if you

00:15:15,440 --> 00:15:20,330
want you can guess the mess it does not

00:15:18,350 --> 00:15:23,170
give you any benefit but if you want you

00:15:20,330 --> 00:15:23,170
can get the mess

00:15:27,740 --> 00:15:40,410
okay so the last well what my purpose

00:15:36,840 --> 00:15:43,650
now is to convince you that that it is

00:15:40,410 --> 00:15:46,830
actually possible it is possible that

00:15:43,650 --> 00:15:49,980
some some topic that is so far kind of

00:15:46,830 --> 00:15:52,500
research II can actually give the same

00:15:49,980 --> 00:15:55,020
kind of benefit as it did 30 years ago

00:15:52,500 --> 00:15:57,870
for for the glue for the garbage

00:15:55,020 --> 00:16:00,150
collection example on that well I

00:15:57,870 --> 00:16:02,610
believe it's transactional memory I'm

00:16:00,150 --> 00:16:03,500
not sure I mean syllabus research of

00:16:02,610 --> 00:16:06,240
course

00:16:03,500 --> 00:16:11,360
well production on memory is something

00:16:06,240 --> 00:16:15,620
that promise to give multi-core usage

00:16:11,360 --> 00:16:18,810
well it's of course if you look now

00:16:15,620 --> 00:16:21,390
today at the issues of transactional

00:16:18,810 --> 00:16:23,850
memory you're going to see performance

00:16:21,390 --> 00:16:26,580
issues is horribly slow like two times

00:16:23,850 --> 00:16:28,680
three times four times slower or or it's

00:16:26,580 --> 00:16:30,480
it's hard to integrate how do you

00:16:28,680 --> 00:16:34,050
cooperate between transactional and

00:16:30,480 --> 00:16:35,730
non-transactional code I mean let me

00:16:34,050 --> 00:16:37,770
remind you that it's exactly the same

00:16:35,730 --> 00:16:39,990
thing that we had thirty years ago how

00:16:37,770 --> 00:16:46,170
do you cooperate with between GC Mahajan

00:16:39,990 --> 00:16:48,390
on GC managed code well the solution is

00:16:46,170 --> 00:16:51,980
well just run everything transactional

00:16:48,390 --> 00:16:51,980
memories and you don't have the problem

00:16:53,000 --> 00:16:59,700
so I mean what it means more generally

00:16:56,730 --> 00:17:01,800
is well you have you have written some

00:16:59,700 --> 00:17:05,550
application using twisted or whatever

00:17:01,800 --> 00:17:08,730
ever web framework it needs to it to it

00:17:05,550 --> 00:17:10,800
resides web requests or handles events

00:17:08,730 --> 00:17:13,890
or does something and the point the

00:17:10,800 --> 00:17:17,429
point is that if you turn if it has to

00:17:13,890 --> 00:17:20,130
handle hundreds of events well most of

00:17:17,429 --> 00:17:24,240
the time that will be independent even I

00:17:20,130 --> 00:17:29,310
mean not always of course but most of

00:17:24,240 --> 00:17:33,150
the time you can kind of expect the

00:17:29,310 --> 00:17:36,030
events to be independent so so so the

00:17:33,150 --> 00:17:40,140
idea is simply that well

00:17:36,030 --> 00:17:43,020
we and in this slide you is the writer

00:17:40,140 --> 00:17:49,680
of the twisted program and we is the

00:17:43,020 --> 00:17:52,220
implementer of cpython or pi PI so the

00:17:49,680 --> 00:17:54,440
idea is that we care about

00:17:52,220 --> 00:17:57,570
synchronization issues under the hood

00:17:54,440 --> 00:18:04,530
and you don't have yes and you don't

00:17:57,570 --> 00:18:06,480
have to yes so so what I'm madam what

00:18:04,530 --> 00:18:09,540
I'm trying to sell to you is that this

00:18:06,480 --> 00:18:13,350
is a solution is the same way as GC was

00:18:09,540 --> 00:18:16,770
a solution 30 years ago it's it's the

00:18:13,350 --> 00:18:21,900
solution that will be or is a lot of

00:18:16,770 --> 00:18:24,720
hard work but it is likely worth to

00:18:21,900 --> 00:18:32,820
remove the quotes around solution it's

00:18:24,720 --> 00:18:35,600
just very hard work for us yes and well

00:18:32,820 --> 00:18:39,720
I mean there is a connection between

00:18:35,600 --> 00:18:43,380
whether allotted a set on pi PI is that

00:18:39,720 --> 00:18:45,690
I'm using pi PI as experimental just bed

00:18:43,380 --> 00:18:48,030
in which to actually implement software

00:18:45,690 --> 00:18:50,850
transactional memory and well I have

00:18:48,030 --> 00:18:56,330
some early prototypes and special

00:18:50,850 --> 00:18:56,330
version of Pi which well runs

00:18:56,750 --> 00:19:03,000
at some speed but actually it's not it's

00:19:02,190 --> 00:19:05,730
not that slow

00:19:03,000 --> 00:19:08,730
it's only two times slower than a

00:19:05,730 --> 00:19:11,550
comparable version but of course the

00:19:08,730 --> 00:19:14,430
comparable version is is a version

00:19:11,550 --> 00:19:16,680
without the advanced garbage collection

00:19:14,430 --> 00:19:19,200
without the JIT and without any of the

00:19:16,680 --> 00:19:24,750
other tricks attic that we usually also

00:19:19,200 --> 00:19:27,090
have in butter but well that's

00:19:24,750 --> 00:19:32,130
work-in-progress basically and we run

00:19:27,090 --> 00:19:34,710
donations yes so let's start walking

00:19:32,130 --> 00:19:39,930
progression and we are we are actually

00:19:34,710 --> 00:19:45,050
getting accepting donations to help this

00:19:39,930 --> 00:19:48,750
work going so i guess to wrap up things

00:19:45,050 --> 00:19:51,120
come and spin with us codebase might be

00:19:48,750 --> 00:19:54,450
hairy but we are friendly on the other

00:19:51,120 --> 00:19:56,070
hand yeah you can sprint on pi pi itself

00:19:54,450 --> 00:19:57,480
or interested in if you have projects

00:19:56,070 --> 00:19:59,400
that you wanting a running on pi pi we

00:19:57,480 --> 00:20:01,860
can help with that we now track down

00:19:59,400 --> 00:20:03,540
performance issues we're in shouldn't

00:20:01,860 --> 00:20:06,090
help any sort of working with the pi pi

00:20:03,540 --> 00:20:08,630
project so i think will now open it up

00:20:06,090 --> 00:20:08,630
for questions

00:20:26,880 --> 00:20:33,670
I believe I believe it's possible for a

00:20:31,750 --> 00:20:35,860
normal person to sprint on pipe I

00:20:33,670 --> 00:20:39,900
question is is it possible for a normal

00:20:35,860 --> 00:20:39,900
person to assist you in your STM project

00:20:39,960 --> 00:20:53,020
is it possible for another people to

00:20:43,270 --> 00:20:55,650
sprint on the same project yes it is no

00:20:53,020 --> 00:20:58,540
well I really mean it in the sense that

00:20:55,650 --> 00:21:02,140
well STM sounds carry that but again

00:20:58,540 --> 00:21:04,090
it's just a transformation of tyty so it

00:21:02,140 --> 00:21:07,720
means it's completely scary but not a

00:21:04,090 --> 00:21:09,640
lot of code it's like garbage collector

00:21:07,720 --> 00:21:11,920
is scary but the code in the corner

00:21:09,640 --> 00:21:14,110
doesn't touch the interpreter so you

00:21:11,920 --> 00:21:16,150
don't have to know tons of stuff yes you

00:21:14,110 --> 00:21:18,930
need to like understandably but it's

00:21:16,150 --> 00:21:22,870
here in one box

00:21:18,930 --> 00:21:26,260
umm what's the best way for mortals to

00:21:22,870 --> 00:21:31,300
help out what what do you guys need in

00:21:26,260 --> 00:21:34,360
the project yes that's as well but but

00:21:31,300 --> 00:21:36,340
also we need like for example if you're

00:21:34,360 --> 00:21:39,520
interested in numpy it's very easy to

00:21:36,340 --> 00:21:41,680
implement a function in numpy just a bit

00:21:39,520 --> 00:21:43,360
of python coding I think the biggest

00:21:41,680 --> 00:21:45,370
misconception is that we translate

00:21:43,360 --> 00:21:46,960
typing all the time and you need to know

00:21:45,370 --> 00:21:49,300
everything no no we almost never

00:21:46,960 --> 00:21:52,240
translate pipe I will always run tests

00:21:49,300 --> 00:21:54,700
and kind of lightly approach works by

00:21:52,240 --> 00:21:57,100
test-driven development and you kind of

00:21:54,700 --> 00:22:00,100
have to this is actually the biggest

00:21:57,100 --> 00:22:02,140
biggest problem for newcomers to like

00:22:00,100 --> 00:22:03,730
accept the fact that we draw we write

00:22:02,140 --> 00:22:06,880
tests first and this is the way to

00:22:03,730 --> 00:22:08,980
approach things in pi pi so knowing all

00:22:06,880 --> 00:22:11,080
the testing players is kind of scary but

00:22:08,980 --> 00:22:13,450
then you don't have to actually ever

00:22:11,080 --> 00:22:15,520
translate pi PI almost so coming say

00:22:13,450 --> 00:22:19,060
helping with numpy or coming helping

00:22:15,520 --> 00:22:21,300
with CSV module or Pico or something

00:22:19,060 --> 00:22:23,530
it's also a very interesting work or

00:22:21,300 --> 00:22:25,600
writing documentation it's something

00:22:23,530 --> 00:22:27,080
that we meet in places like having good

00:22:25,600 --> 00:22:29,210
documentations for pieces of

00:22:27,080 --> 00:22:31,820
and something people can definitely help

00:22:29,210 --> 00:22:34,280
now pi3k is another area we've started

00:22:31,820 --> 00:22:36,520
working on on a branch for Python 3 and

00:22:34,280 --> 00:22:39,320
there is tons of work to be done they're

00:22:36,520 --> 00:22:40,850
updating modules to like what new

00:22:39,320 --> 00:22:42,500
methods were added all kinds of stuff to

00:22:40,850 --> 00:22:44,060
be done there and I think it's a great

00:22:42,500 --> 00:22:47,000
place that may be very interesting to

00:22:44,060 --> 00:22:50,540
see that Python 3 is on the branch there

00:22:47,000 --> 00:22:53,300
and JIT is here and though the work does

00:22:50,540 --> 00:22:55,400
not collide at all like we don't have to

00:22:53,300 --> 00:22:57,590
upgrade the jet for Python 3 Jade will

00:22:55,400 --> 00:23:00,290
automatically work for Python 3 as well

00:22:57,590 --> 00:23:02,810
and if we improve it for Python 2 it

00:23:00,290 --> 00:23:05,690
will improve it for Python 3 so the work

00:23:02,810 --> 00:23:07,970
that you don't have to know x86 assembly

00:23:05,690 --> 00:23:12,410
or PowerPC assembler to work on the

00:23:07,970 --> 00:23:16,430
Python 3 part at all they have to know

00:23:12,410 --> 00:23:18,290
what's that so a key skill of the

00:23:16,430 --> 00:23:20,240
software engineer as opposed to the

00:23:18,290 --> 00:23:22,790
programmer is to spend a maximum amount

00:23:20,240 --> 00:23:24,860
of time solving the problem at hand and

00:23:22,790 --> 00:23:27,140
the least possible amount of time

00:23:24,860 --> 00:23:28,850
debugging tracing errors writing

00:23:27,140 --> 00:23:30,140
frameworks which we all love to do

00:23:28,850 --> 00:23:33,280
because it's easier than writing actual

00:23:30,140 --> 00:23:36,080
work writing unit tests and so on

00:23:33,280 --> 00:23:36,680
however writing compilers is insanely

00:23:36,080 --> 00:23:39,740
hard

00:23:36,680 --> 00:23:41,900
what rat-holes have you got stuck in and

00:23:39,740 --> 00:23:46,910
how do you struggle and manage to avoid

00:23:41,900 --> 00:23:48,710
them rev well we spent 8 years building

00:23:46,910 --> 00:23:51,220
infrastructure so we wouldn't have too

00:23:48,710 --> 00:23:53,900
many nowadays I guess is the biggest one

00:23:51,220 --> 00:23:55,880
we put a huge investment in time into

00:23:53,900 --> 00:23:57,590
having a scene for structure so the JIT

00:23:55,880 --> 00:23:59,180
is automatically generated and works on

00:23:57,590 --> 00:24:01,340
all different interpreters automatically

00:23:59,180 --> 00:24:02,930
so I don't know you guys were there when

00:24:01,340 --> 00:24:07,040
it was actually developed all this

00:24:02,930 --> 00:24:09,200
infrastructure I think it's just a very

00:24:07,040 --> 00:24:11,540
long-term solution it by a fibrous kind

00:24:09,200 --> 00:24:14,450
of a project 15 coming today for 9 years

00:24:11,540 --> 00:24:16,370
kind of project so we did a lot of work

00:24:14,450 --> 00:24:18,020
on building the basics yes it took

00:24:16,370 --> 00:24:20,300
forever and a lot of people lost

00:24:18,020 --> 00:24:21,230
fighting PI paper together they are not

00:24:20,300 --> 00:24:23,420
going anywhere

00:24:21,230 --> 00:24:24,950
but we were building the basics once

00:24:23,420 --> 00:24:26,720
they're done it's kind of cool now we

00:24:24,950 --> 00:24:28,520
can like release every three months and

00:24:26,720 --> 00:24:32,150
every version is like 20% faster than

00:24:28,520 --> 00:24:34,580
the previous one so we took a long time

00:24:32,150 --> 00:24:36,470
to build infrastructure like for example

00:24:34,580 --> 00:24:38,900
piping releases are just nicely built

00:24:36,470 --> 00:24:41,890
with very nine directories they're not

00:24:38,900 --> 00:24:41,890
any different than that

00:24:43,419 --> 00:24:47,440
my understanding of STM is that if you

00:24:45,999 --> 00:24:49,690
do something with side effects in a

00:24:47,440 --> 00:24:51,340
transaction that's not particularly good

00:24:49,690 --> 00:24:53,289
like Haskell can guarantee that with the

00:24:51,340 --> 00:24:54,729
language whereas my understanding of

00:24:53,289 --> 00:24:56,200
Python is it can and so I'm curious just

00:24:54,729 --> 00:24:59,679
how you're approaching that or what you

00:24:56,200 --> 00:25:02,019
yes well it's a question it's a question

00:24:59,679 --> 00:25:06,239
to which I have some answers well which

00:25:02,019 --> 00:25:08,859
would take long to explain all that but

00:25:06,239 --> 00:25:12,039
this is basically that if your

00:25:08,859 --> 00:25:14,609
transaction does some input/output then

00:25:12,039 --> 00:25:17,710
you mark the transaction as inevitable

00:25:14,609 --> 00:25:19,929
so that means basically basically you're

00:25:17,710 --> 00:25:22,059
backing in a word similar to the JIT

00:25:19,929 --> 00:25:26,859
there can be only one inevitable

00:25:22,059 --> 00:25:28,089
transaction running at a time so so if

00:25:26,859 --> 00:25:30,009
all your transactions are doing

00:25:28,089 --> 00:25:32,019
input-output of course of course you

00:25:30,009 --> 00:25:35,229
don't win anything over the jail then

00:25:32,019 --> 00:25:38,529
then but well support the point is that

00:25:35,229 --> 00:25:40,269
this approach works you I understand

00:25:38,529 --> 00:25:42,339
that your program still works correctly

00:25:40,269 --> 00:25:46,330
it's not getting any spirit but it works

00:25:42,339 --> 00:25:48,879
correctly and then from then well from

00:25:46,330 --> 00:25:50,979
then you can improve things like like

00:25:48,879 --> 00:25:52,599
you move the transaction move the

00:25:50,979 --> 00:25:55,119
input-output to the end of the

00:25:52,599 --> 00:25:57,249
transaction or if you can't you split

00:25:55,119 --> 00:26:01,599
the transaction in two just after doing

00:25:57,249 --> 00:26:08,080
input-output or or do things basically

00:26:01,599 --> 00:26:11,409
thanks a lot of people are waiting for

00:26:08,080 --> 00:26:12,909
pi PI to go mainstream I mean that we'll

00:26:11,409 --> 00:26:15,190
be able to use it for their everyday

00:26:12,909 --> 00:26:17,739
programs now the challenges are as I

00:26:15,190 --> 00:26:21,099
said lack of support for like numpy and

00:26:17,739 --> 00:26:22,389
different third-party packages and one

00:26:21,099 --> 00:26:24,249
of the the big challenges is

00:26:22,389 --> 00:26:25,539
understanding where to go and what to do

00:26:24,249 --> 00:26:28,570
and I think a lot of people want to

00:26:25,539 --> 00:26:31,509
contribute so it will be nice you had

00:26:28,570 --> 00:26:34,509
like a wiki page saying like we have the

00:26:31,509 --> 00:26:37,330
missing port from 2 to 3 like missing

00:26:34,509 --> 00:26:39,609
packages in pi PI and a lot of people

00:26:37,330 --> 00:26:41,859
are just waiting to contribute ok so

00:26:39,609 --> 00:26:44,200
there's actually a wikipedia or not a

00:26:41,859 --> 00:26:45,700
wikipedia up wiki on our bit bucket that

00:26:44,200 --> 00:26:48,159
says what packages are compatible with

00:26:45,700 --> 00:26:49,690
pi PI if there's an alternative do you

00:26:48,159 --> 00:26:50,740
need a patch to run it stuff like that

00:26:49,690 --> 00:26:52,660
so what you breathing

00:26:50,740 --> 00:26:54,490
the wiki page would also be very I

00:26:52,660 --> 00:26:56,650
suppose and we should probably link that

00:26:54,490 --> 00:27:01,870
on the main site yes I can find a hard

00:26:56,650 --> 00:27:05,650
to find one quick question one deeper

00:27:01,870 --> 00:27:08,980
question does c-types work yes c-types

00:27:05,650 --> 00:27:11,050
works okay very cool I spent a lot of my

00:27:08,980 --> 00:27:12,280
time taking crusty sea bindings and just

00:27:11,050 --> 00:27:14,950
converting them to use sea types so that

00:27:12,280 --> 00:27:16,929
will help a lot the other thing and this

00:27:14,950 --> 00:27:18,220
is the bigger thing for me one of the

00:27:16,929 --> 00:27:19,809
things I kind of hope to see out of pi

00:27:18,220 --> 00:27:21,670
pi was the ability to add new language

00:27:19,809 --> 00:27:24,309
features new constructs basically use it

00:27:21,670 --> 00:27:25,900
as playground to change the syntax is

00:27:24,309 --> 00:27:27,309
that something that's very easy to do

00:27:25,900 --> 00:27:29,230
with pi pi or is that something that's

00:27:27,309 --> 00:27:31,210
very difficult so when the pi pi project

00:27:29,230 --> 00:27:32,650
was conceived nine years ago one of the

00:27:31,210 --> 00:27:34,420
main ideas was that it would be a

00:27:32,650 --> 00:27:37,120
platform for language experimentation

00:27:34,420 --> 00:27:39,400
that people who were just just Python

00:27:37,120 --> 00:27:41,050
programmers wouldn't have to learn C and

00:27:39,400 --> 00:27:43,240
learn C Python code base they could just

00:27:41,050 --> 00:27:45,550
learn a Python code base and do

00:27:43,240 --> 00:27:48,220
experimentation so in terms of what we

00:27:45,550 --> 00:27:49,570
release when we do a release we're

00:27:48,220 --> 00:27:51,970
really committed to employment of the

00:27:49,570 --> 00:27:53,110
Python language as its defined but I

00:27:51,970 --> 00:27:54,700
think we still think it's a good

00:27:53,110 --> 00:27:57,280
platform for implementing new languages

00:27:54,700 --> 00:27:59,559
for adding syntax though like in the

00:27:57,280 --> 00:28:01,240
paper project we kind of always said

00:27:59,559 --> 00:28:04,330
okay we operate from the level of

00:28:01,240 --> 00:28:07,480
bytecode down and we pushed parsers to

00:28:04,330 --> 00:28:09,040
other people so definitely Benjamin

00:28:07,480 --> 00:28:11,200
though Benjamin Peterson who is

00:28:09,040 --> 00:28:13,210
somewhere around he's giving the next

00:28:11,200 --> 00:28:15,370
talk he wrote the parser and he can

00:28:13,210 --> 00:28:16,720
answer syntax questions okay and do you

00:28:15,370 --> 00:28:19,470
have to look like a Haskell programmer

00:28:16,720 --> 00:28:19,470
to work on STM

00:28:23,299 --> 00:28:27,179
it sounds like lots of people are

00:28:25,409 --> 00:28:30,779
familiar with Haskell today all of a

00:28:27,179 --> 00:28:32,509
sudden you mention STM so which Haskell

00:28:30,779 --> 00:28:34,710
feature are you guys going to take next

00:28:32,509 --> 00:28:38,129
and I don't mean this in a bad way

00:28:34,710 --> 00:28:39,870
because pi PI has garbage collection

00:28:38,129 --> 00:28:43,200
just like a skel except it doesn't

00:28:39,870 --> 00:28:43,799
allocate hundreds of thunks and screw up

00:28:43,200 --> 00:28:46,409
your memory

00:28:43,799 --> 00:28:48,570
you guys have STM but it's automatic

00:28:46,409 --> 00:28:50,549
Haskell's is very manual and it's

00:28:48,570 --> 00:28:54,720
totally possible to drop transactions on

00:28:50,549 --> 00:28:57,509
the floor which sucks but the STM and PI

00:28:54,720 --> 00:28:59,399
PI's are automatic so so what are you

00:28:57,509 --> 00:29:01,529
going to take from Haskell and improve

00:28:59,399 --> 00:29:07,500
upon next the beards it sounds like

00:29:01,529 --> 00:29:10,549
those are popular you should probably

00:29:07,500 --> 00:29:10,549
get started on that Alex

00:29:15,980 --> 00:29:23,550
you guys are awesome thanks hey so I'm

00:29:21,960 --> 00:29:25,440
kind of wondering for people interested

00:29:23,550 --> 00:29:27,090
in you know getting into the project and

00:29:25,440 --> 00:29:29,220
contributing what's the lowest hanging

00:29:27,090 --> 00:29:30,480
fruit and like is there sort of one part

00:29:29,220 --> 00:29:32,550
of the project that's easier to get

00:29:30,480 --> 00:29:33,870
started on than you know trying to sort

00:29:32,550 --> 00:29:36,660
of understand the whole thing at once

00:29:33,870 --> 00:29:38,280
so PI that is very modular if you want

00:29:36,660 --> 00:29:40,170
to work on the jet you work on the jet

00:29:38,280 --> 00:29:42,740
if you want to work on the Python three

00:29:40,170 --> 00:29:45,570
compatibility you work on this and I

00:29:42,740 --> 00:29:46,860
don't think they have like did they have

00:29:45,570 --> 00:29:49,590
different levels if you want to

00:29:46,860 --> 00:29:51,060
implement a GC implement the GC and in a

00:29:49,590 --> 00:29:55,050
different director if you want to work

00:29:51,060 --> 00:29:56,640
on sandbox you work on sandbox so there

00:29:55,050 --> 00:29:58,440
are different levels depends what

00:29:56,640 --> 00:30:00,090
interests you really is their

00:29:58,440 --> 00:30:03,210
documentation to cover that stuff or

00:30:00,090 --> 00:30:03,840
just don't dive inge going like IRC or

00:30:03,210 --> 00:30:05,760
sprints or

00:30:03,840 --> 00:30:11,880
IRC is better than documentation all

00:30:05,760 --> 00:30:13,560
right okay this isn't a question this is

00:30:11,880 --> 00:30:16,080
a comment all the people are asking how

00:30:13,560 --> 00:30:17,970
can I contribute if someone would

00:30:16,080 --> 00:30:19,740
contribute fixing up the docs and

00:30:17,970 --> 00:30:21,450
keeping the list of how other people can

00:30:19,740 --> 00:30:22,980
contribute because these guys are really

00:30:21,450 --> 00:30:26,760
awesome but no one understands what they

00:30:22,980 --> 00:30:29,550
say so what someone needs to do is

00:30:26,760 --> 00:30:31,110
volunteer to be the like the translator

00:30:29,550 --> 00:30:32,970
like we're going to Papua New Guinea and

00:30:31,110 --> 00:30:34,350
we're meeting the natives and someone

00:30:32,970 --> 00:30:36,390
needs to learn their language and then

00:30:34,350 --> 00:30:38,250
bring it back to us and if someone would

00:30:36,390 --> 00:30:42,830
take on that documentation I think we'd

00:30:38,250 --> 00:30:42,830
all really be appreciative Thanks

00:30:49,280 --> 00:30:54,440
we got about five more minutes till the

00:30:51,390 --> 00:30:54,440

YouTube URL: https://www.youtube.com/watch?v=P5ad6NpjR3M


