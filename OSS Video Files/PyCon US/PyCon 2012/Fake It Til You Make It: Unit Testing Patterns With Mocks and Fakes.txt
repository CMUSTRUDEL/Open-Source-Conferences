Title: Fake It Til You Make It: Unit Testing Patterns With Mocks and Fakes
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Brian K. Jones
In this talk, aimed at intermediate Pythonistas, we'll have a look at some common, simple patterns in code, and the testing patterns that go with them. We'll also discover what makes some code more testable than others, and how mocks a
Captions: 
	00:00:00,060 --> 00:00:09,480
I can't okay here we go

00:00:07,189 --> 00:00:17,390
thanks for coming my name is Brian Jones

00:00:09,480 --> 00:00:24,740
I'm a software engineer and hi hi

00:00:17,390 --> 00:00:27,750
thanks I'm SuperDuper nervous so I was a

00:00:24,740 --> 00:00:30,000
I'm a PSF member now since right after

00:00:27,750 --> 00:00:32,309
the last PyCon a software engineer I

00:00:30,000 --> 00:00:34,739
work right now for aweber communications

00:00:32,309 --> 00:00:36,809
before that it was my yearbook comm I've

00:00:34,739 --> 00:00:39,870
worked for add this calm before they

00:00:36,809 --> 00:00:41,940
were bought out I've worked in startups

00:00:39,870 --> 00:00:44,100
government academia so I have a pretty

00:00:41,940 --> 00:00:46,950
broad base background I co-authored

00:00:44,100 --> 00:00:48,719
Linux server hacks for O'Reilly in 2005

00:00:46,950 --> 00:00:51,360
and I'm working with David Beasley now

00:00:48,719 --> 00:00:52,430
on the third edition of the Python

00:00:51,360 --> 00:00:54,840
cookbook

00:00:52,430 --> 00:00:57,600
I'm BK Jones on github

00:00:54,840 --> 00:00:59,699
I'm Jonesy on freenode joined the Python

00:00:57,600 --> 00:01:01,920
testing IRC channel we have great

00:00:59,699 --> 00:01:05,040
discussions in there but it's relatively

00:01:01,920 --> 00:01:07,890
low traffic and my blog is protocol

00:01:05,040 --> 00:01:13,189
ostomy comm all the content there is

00:01:07,890 --> 00:01:13,189
technical and the ads are hysterical

00:01:16,020 --> 00:01:20,290
so we're gonna talk about some

00:01:18,850 --> 00:01:21,580
definitions and I want to let you know

00:01:20,290 --> 00:01:23,290
that I'm bastardizing some of the

00:01:21,580 --> 00:01:25,630
definitions for the context of this talk

00:01:23,290 --> 00:01:27,009
because I've made some assumptions about

00:01:25,630 --> 00:01:28,479
the audience and I'm sure that there's a

00:01:27,009 --> 00:01:31,180
broader array of people that I could

00:01:28,479 --> 00:01:33,280
possibly target in one talk but so I'm

00:01:31,180 --> 00:01:34,979
gonna use definitions that sometimes fly

00:01:33,280 --> 00:01:37,210
in the face of the literature

00:01:34,979 --> 00:01:38,860
quote-unquote we're going to talk about

00:01:37,210 --> 00:01:40,420
some some patterns when I talk about

00:01:38,860 --> 00:01:42,880
patterns I'm not talking about design

00:01:40,420 --> 00:01:44,229
patterns I'm talking about practical

00:01:42,880 --> 00:01:47,020
patterns that you actually see in code

00:01:44,229 --> 00:01:49,149
out in the while unit tests are sort of

00:01:47,020 --> 00:01:49,929
by definition low-level and so the

00:01:49,149 --> 00:01:51,789
patterns that we're going to be looking

00:01:49,929 --> 00:01:54,580
at are also low-level and design

00:01:51,789 --> 00:01:57,039
patterns or more high-level and then

00:01:54,580 --> 00:01:58,240
we'll talk about some tools as well I am

00:01:57,039 --> 00:02:01,209
NOT going to give you an intro to the

00:01:58,240 --> 00:02:02,740
unit test module I kind of assume that

00:02:01,209 --> 00:02:05,080
everyone is at least seen it before

00:02:02,740 --> 00:02:06,549
number one number two if you haven't it

00:02:05,080 --> 00:02:08,110
would take you all of it would take you

00:02:06,549 --> 00:02:11,860
probably less than an hour to write a

00:02:08,110 --> 00:02:13,299
reasonably sane looking test suite using

00:02:11,860 --> 00:02:17,080
the unit test module if you just use the

00:02:13,299 --> 00:02:18,790
documentation I'm also not going to give

00:02:17,080 --> 00:02:21,220
you a sales pitch for doing testing at

00:02:18,790 --> 00:02:23,380
all if you're here I assume that you see

00:02:21,220 --> 00:02:24,880
some value in testing and so my goal

00:02:23,380 --> 00:02:26,920
here is to really drive you further down

00:02:24,880 --> 00:02:29,320
the path from say smoke tests or

00:02:26,920 --> 00:02:31,209
acceptance testing as being you know

00:02:29,320 --> 00:02:33,640
pretty much all of your testing moving

00:02:31,209 --> 00:02:35,530
more down the path to further isolate

00:02:33,640 --> 00:02:42,160
your code and move more towards unit

00:02:35,530 --> 00:02:44,709
testing so what is a unit test a unit

00:02:42,160 --> 00:02:47,380
test is a test that doesn't require any

00:02:44,709 --> 00:02:49,299
parts of the larger system that it might

00:02:47,380 --> 00:02:53,170
otherwise interact with in order for the

00:02:49,299 --> 00:02:54,579
test to pass it's very granular meaning

00:02:53,170 --> 00:02:58,150
that you're only testing a very small

00:02:54,579 --> 00:02:59,739
piece of the code it's isolated and what

00:02:58,150 --> 00:03:01,450
falls out of that is that the feedback

00:02:59,739 --> 00:03:04,810
that you get from unit tests tends to be

00:03:01,450 --> 00:03:06,400
highly localized such that if you have a

00:03:04,810 --> 00:03:09,190
unit - if you have a method that has an

00:03:06,400 --> 00:03:10,989
if block and a try except block right

00:03:09,190 --> 00:03:12,549
you you already know you're probably

00:03:10,989 --> 00:03:14,380
going to write it you know at least for

00:03:12,549 --> 00:03:16,780
a unit test for it one where the if

00:03:14,380 --> 00:03:18,220
condition passes one where it fails one

00:03:16,780 --> 00:03:22,360
that triggers the except block to run

00:03:18,220 --> 00:03:24,970
and one that doesn't and if you name

00:03:22,360 --> 00:03:27,760
that test test foo if passes accept

00:03:24,970 --> 00:03:30,379
triggered and it fails

00:03:27,760 --> 00:03:32,540
you probably know just from looking at

00:03:30,379 --> 00:03:34,610
that output within five lines of code

00:03:32,540 --> 00:03:38,900
where your problem is so that's what I

00:03:34,610 --> 00:03:40,550
mean by localized it's not a unit test

00:03:38,900 --> 00:03:43,069
if something outside of the code that

00:03:40,550 --> 00:03:49,060
you care about has to work in order for

00:03:43,069 --> 00:03:51,380
the test to pass at that point it's

00:03:49,060 --> 00:03:54,220
maybe at best a low-level integration

00:03:51,380 --> 00:03:56,989
test if you're testing the entire system

00:03:54,220 --> 00:03:58,670
then I would call that that that has a

00:03:56,989 --> 00:04:02,090
lot of names out in the wild acceptance

00:03:58,670 --> 00:04:03,590
test QA testing you know spec testing

00:04:02,090 --> 00:04:04,940
some people call it to see if the

00:04:03,590 --> 00:04:09,319
functionality of this if the whole

00:04:04,940 --> 00:04:10,790
system matches a spec and and it for

00:04:09,319 --> 00:04:12,079
smaller usually for small scripts and

00:04:10,790 --> 00:04:17,450
stuff like that it's just called a smoke

00:04:12,079 --> 00:04:19,160
test so let's define coverage it's kind

00:04:17,450 --> 00:04:20,600
of a loaded term because the way that I

00:04:19,160 --> 00:04:24,410
hear it used a lot me I want to do I do

00:04:20,600 --> 00:04:26,960
a lot of code reviews and I do I read a

00:04:24,410 --> 00:04:29,060
lot of open source software's source

00:04:26,960 --> 00:04:29,720
code and you'll see sometimes in github

00:04:29,060 --> 00:04:32,539
readme

00:04:29,720 --> 00:04:35,990
it may be mine I have a hundred percent

00:04:32,539 --> 00:04:37,639
code coverage on this code and it's it's

00:04:35,990 --> 00:04:39,350
almost there as if it's supposed to be a

00:04:37,639 --> 00:04:42,289
selling point then you go and when I

00:04:39,350 --> 00:04:45,130
inspect the code further what I find

00:04:42,289 --> 00:04:49,610
sometimes is that they really went for

00:04:45,130 --> 00:04:51,860
individual lines of code I would assert

00:04:49,610 --> 00:04:53,479
that that is really not coverage it's

00:04:51,860 --> 00:04:55,250
not really where you want to be really

00:04:53,479 --> 00:04:57,889
where you want to be is you want to you

00:04:55,250 --> 00:04:59,720
want to cover all of the conditions that

00:04:57,889 --> 00:05:02,360
might surround the execution of that

00:04:59,720 --> 00:05:04,190
code so you could call it case coverage

00:05:02,360 --> 00:05:07,310
or branch coverage logic coverage

00:05:04,190 --> 00:05:09,050
decision point coverage but I think

00:05:07,310 --> 00:05:10,820
that's a totally separate thing and a

00:05:09,050 --> 00:05:15,950
much more valuable thing to go after

00:05:10,820 --> 00:05:21,139
than individual lines of code I use

00:05:15,950 --> 00:05:24,310
coverage spy I like a lot I recommend it

00:05:21,139 --> 00:05:27,180
who has never heard of coverage drop I

00:05:24,310 --> 00:05:29,530
okay

00:05:27,180 --> 00:05:32,890
well it's it's written by Ned Batchelder

00:05:29,530 --> 00:05:38,320
and Ned's code is awesome thank you very

00:05:32,890 --> 00:05:40,360
much thank you so much dad so it

00:05:38,320 --> 00:05:44,170
integrates with nose tests it is super

00:05:40,360 --> 00:05:46,060
duper duper easy to use I use it almost

00:05:44,170 --> 00:05:49,780
exclusively in the context of running

00:05:46,060 --> 00:05:52,300
nose tests as my test discovery tool and

00:05:49,780 --> 00:05:54,850
you can basically just say - - with

00:05:52,300 --> 00:05:56,710
coverage and and you'll have coverage

00:05:54,850 --> 00:05:58,420
and you can limit the scope of that

00:05:56,710 --> 00:05:59,170
coverage and do some nice things with

00:05:58,420 --> 00:06:01,950
that as well

00:05:59,170 --> 00:06:05,260
it'll also output HTML output for you

00:06:01,950 --> 00:06:06,970
it's it's very nice and you can even

00:06:05,260 --> 00:06:09,640
report on branch coverage using the -

00:06:06,970 --> 00:06:12,640
branch flag there just seems to be

00:06:09,640 --> 00:06:15,480
nothing that this can't do it can be

00:06:12,640 --> 00:06:19,060
used pretty easily with talks by itself

00:06:15,480 --> 00:06:20,500
or from within O's tests and again I

00:06:19,060 --> 00:06:27,190
want to say thanks - to Ned Batchelder

00:06:20,500 --> 00:06:29,920
for that great work so speaking of nose

00:06:27,190 --> 00:06:31,360
tests it's a great discovery tool you

00:06:29,920 --> 00:06:34,450
actually can write unit tests you can

00:06:31,360 --> 00:06:37,540
use those tests as your as a unit test

00:06:34,450 --> 00:06:42,520
module replacement I haven't done it but

00:06:37,540 --> 00:06:43,930
I've seen some tests that that use it so

00:06:42,520 --> 00:06:45,220
you CD to your test directory and you

00:06:43,930 --> 00:06:46,600
can just run those tests and it'll

00:06:45,220 --> 00:06:48,220
actually do something semi-intelligent

00:06:46,600 --> 00:06:50,080
with that it'll discover your tests

00:06:48,220 --> 00:06:51,220
there's a naming convention involved if

00:06:50,080 --> 00:06:52,960
you start everything with just test

00:06:51,220 --> 00:06:54,550
underscore that'll work

00:06:52,960 --> 00:06:55,960
you don't really need to look further

00:06:54,550 --> 00:06:57,880
than that but you can if you want to

00:06:55,960 --> 00:07:00,430
change the regular expression it uses to

00:06:57,880 --> 00:07:02,530
identify tests you can do that too but

00:07:00,430 --> 00:07:06,460
don't just just run those tests and name

00:07:02,530 --> 00:07:08,230
yourself sanely knows tests with

00:07:06,460 --> 00:07:10,600
coverage I already covered coverage top

00:07:08,230 --> 00:07:15,220
pi is a nose plugin it has a super nice

00:07:10,600 --> 00:07:19,120
HTML report that will highlight sort of

00:07:15,220 --> 00:07:22,180
github style the the code printout kind

00:07:19,120 --> 00:07:25,900
of looks that like similar to that and

00:07:22,180 --> 00:07:29,110
it highlights the uncovered code in red

00:07:25,900 --> 00:07:31,240
so that's nice it also integrates well

00:07:29,110 --> 00:07:32,290
with Jenkins and it can provide you HTML

00:07:31,240 --> 00:07:35,400
that integrates into the Jenkins

00:07:32,290 --> 00:07:38,699
interface pretty nicely and there's a

00:07:35,400 --> 00:07:42,569
plugin called nose X cover that will

00:07:38,699 --> 00:07:44,460
work with Jenkins's cobertura style

00:07:42,569 --> 00:07:48,720
output so you can get pretty graphs and

00:07:44,460 --> 00:07:52,530
you know managers like that so check it

00:07:48,720 --> 00:07:53,849
out so why unit tests at all I'm

00:07:52,530 --> 00:07:56,580
actually asked us a whole lot so I

00:07:53,849 --> 00:07:58,259
decided to cover it in the talk well you

00:07:56,580 --> 00:07:59,970
know I go around and I kind of go out of

00:07:58,259 --> 00:08:01,199
my way to talk to people about unit

00:07:59,970 --> 00:08:04,889
testing because I still consider myself

00:08:01,199 --> 00:08:06,120
a student of the of the trade and I want

00:08:04,889 --> 00:08:07,289
to learn as much as I can and one of the

00:08:06,120 --> 00:08:08,849
things I learned is that I'm completely

00:08:07,289 --> 00:08:10,490
backwards from everybody else who does

00:08:08,849 --> 00:08:12,870
any kind of testing at all in that I

00:08:10,490 --> 00:08:14,849
seek to test everything starting with

00:08:12,870 --> 00:08:16,979
the most granular and working my way out

00:08:14,849 --> 00:08:19,500
and it seems that everybody else starts

00:08:16,979 --> 00:08:21,569
with like a smoke test and then never

00:08:19,500 --> 00:08:23,039
goes anywhere else with it like there's

00:08:21,569 --> 00:08:25,319
tons of people that that's all they do

00:08:23,039 --> 00:08:27,150
is an acceptance level test you know I

00:08:25,319 --> 00:08:28,380
have a staging environment my code has

00:08:27,150 --> 00:08:32,039
access to all the resources it could

00:08:28,380 --> 00:08:33,300
ever possibly want and so and I have

00:08:32,039 --> 00:08:35,399
great success testing in that

00:08:33,300 --> 00:08:36,959
environment if something's wrong I send

00:08:35,399 --> 00:08:38,399
it back to the development team they

00:08:36,959 --> 00:08:40,260
spend the next three days figuring out

00:08:38,399 --> 00:08:42,719
where the actual problem is and then

00:08:40,260 --> 00:08:45,720
they put it back and they're ready to go

00:08:42,719 --> 00:08:47,430
so unit tests by contrasts are really

00:08:45,720 --> 00:08:49,709
fast and simple and when I say fast and

00:08:47,430 --> 00:08:51,540
simple yes they run very quickly because

00:08:49,709 --> 00:08:55,800
they're doing they're only working on a

00:08:51,540 --> 00:08:59,910
very small in a very small scope but

00:08:55,800 --> 00:09:02,010
they're really easy just to do I mean so

00:08:59,910 --> 00:09:03,300
right before I got on the plane to come

00:09:02,010 --> 00:09:06,510
out here it's a six hour flight from

00:09:03,300 --> 00:09:09,600
where I live I cloned a repository that

00:09:06,510 --> 00:09:11,399
had nothing but doc tests and I wrote

00:09:09,600 --> 00:09:14,089
all the tests that I need all the unit

00:09:11,399 --> 00:09:16,920
tests for it I wrote on the plane and

00:09:14,089 --> 00:09:19,020
when I go back to push that to some

00:09:16,920 --> 00:09:20,190
other environment I'll be able to run

00:09:19,020 --> 00:09:22,380
those tests again in whatever

00:09:20,190 --> 00:09:23,670
environment it goes in because you are

00:09:22,380 --> 00:09:25,649
creating when you read a unit test

00:09:23,670 --> 00:09:28,470
you're creating the entire execution

00:09:25,649 --> 00:09:29,940
environment by mocking out any of the

00:09:28,470 --> 00:09:32,700
external dependencies that may not

00:09:29,940 --> 00:09:34,230
otherwise be there so it becomes sort of

00:09:32,700 --> 00:09:36,180
like you know unit testing is sort of

00:09:34,230 --> 00:09:37,800
like my New York Times crossword puzzle

00:09:36,180 --> 00:09:41,779
you know some people do that on the

00:09:37,800 --> 00:09:41,779
plane I write unit tests

00:09:44,470 --> 00:09:48,100
the other reason is that that I like

00:09:46,570 --> 00:09:49,180
unit test is that I don't really don't

00:09:48,100 --> 00:09:51,070
want to go searching through the code

00:09:49,180 --> 00:09:54,190
right I really don't want to have this

00:09:51,070 --> 00:09:56,170
huge system and get a trace back and

00:09:54,190 --> 00:09:58,090
then figure out where in the huge system

00:09:56,170 --> 00:09:59,770
the actual root cause is of course you

00:09:58,090 --> 00:10:01,390
can find where the actual where things

00:09:59,770 --> 00:10:03,190
actually fail but that's not typically

00:10:01,390 --> 00:10:05,890
the root cause and then you're in charge

00:10:03,190 --> 00:10:08,050
of tracing everything back to where the

00:10:05,890 --> 00:10:09,880
root causes I'd rather actually know

00:10:08,050 --> 00:10:13,780
with a very low level of granularity

00:10:09,880 --> 00:10:15,100
where the problem is now all that said

00:10:13,780 --> 00:10:17,830
unit tests aren't enough there's

00:10:15,100 --> 00:10:19,390
absolutely nothing wrong with smoke

00:10:17,830 --> 00:10:21,190
tests and acceptance testing and

00:10:19,390 --> 00:10:24,070
integration testing and all the other

00:10:21,190 --> 00:10:26,110
kinds of testing out there in fact

00:10:24,070 --> 00:10:27,250
they're required and so don't stop doing

00:10:26,110 --> 00:10:28,600
that because I don't have to do a talk

00:10:27,250 --> 00:10:30,190
next year on why you need a staging

00:10:28,600 --> 00:10:33,570
environment and all that stuff and I

00:10:30,190 --> 00:10:33,570
don't know if I'm up for that

00:10:33,810 --> 00:10:38,350
specifically unit test by definition

00:10:35,950 --> 00:10:40,300
don't test integration they don't test

00:10:38,350 --> 00:10:42,010
that individual parts work together

00:10:40,300 --> 00:10:43,810
because the only parts that it's working

00:10:42,010 --> 00:10:47,050
with are the parts that you've mocked

00:10:43,810 --> 00:10:50,530
out right you've created stand-ins for

00:10:47,050 --> 00:10:53,520
external dependencies and and and that's

00:10:50,530 --> 00:10:57,370
what your code under test is talking to

00:10:53,520 --> 00:10:59,860
so here's a problem with unit tests I

00:10:57,370 --> 00:11:02,560
have this method this is from PI rabbit

00:10:59,860 --> 00:11:05,170
it's a module that I wrote to provide a

00:11:02,560 --> 00:11:10,780
wrapper to rabbit and Q's HTTP

00:11:05,170 --> 00:11:13,450
management API and this is a unit test

00:11:10,780 --> 00:11:15,220
and a test set that the code under test

00:11:13,450 --> 00:11:19,930
does what I expect it to do under the

00:11:15,220 --> 00:11:22,450
the conditions that I set forward but

00:11:19,930 --> 00:11:25,510
it's not an integration test so if some

00:11:22,450 --> 00:11:27,880
part of the of the API or something in

00:11:25,510 --> 00:11:29,920
the HTTP dot do call methods the

00:11:27,880 --> 00:11:31,930
signature changes or parts of the

00:11:29,920 --> 00:11:33,670
messages change on their on their way by

00:11:31,930 --> 00:11:37,930
the data changes on the way back like

00:11:33,670 --> 00:11:39,940
they change messages to depth then

00:11:37,930 --> 00:11:43,030
that's not going to be caught by this

00:11:39,940 --> 00:11:45,700
test this test will still pass so you

00:11:43,030 --> 00:11:46,840
still need integration tests right like

00:11:45,700 --> 00:11:48,910
you were supposed to go back yes and

00:11:46,840 --> 00:11:50,560
edit your code and update the test and

00:11:48,910 --> 00:11:52,810
everything else but you you may not and

00:11:50,560 --> 00:11:54,819
this test won't may may not catch all

00:11:52,810 --> 00:11:57,199
the issues

00:11:54,819 --> 00:12:00,859
so the solution is an integration test

00:11:57,199 --> 00:12:03,259
it includes the HTTP clients do call

00:12:00,859 --> 00:12:05,359
method so I didn't mock out that method

00:12:03,259 --> 00:12:07,659
so it is going to be executed so I'm

00:12:05,359 --> 00:12:09,979
actually testing that to some degree and

00:12:07,659 --> 00:12:13,629
I'm also testing don't forget the

00:12:09,979 --> 00:12:17,479
instantiation of the HTTP client as well

00:12:13,629 --> 00:12:19,009
and so this will actually call the do

00:12:17,479 --> 00:12:20,419
call method actually has like adjacent

00:12:19,009 --> 00:12:22,609
decode operations and stuff but I am

00:12:20,419 --> 00:12:24,139
mocking out inside that call there's a

00:12:22,609 --> 00:12:27,349
client request and I'm mocking that out

00:12:24,139 --> 00:12:29,119
so I've moved my I call it the reality

00:12:27,349 --> 00:12:31,969
distortion field I've moved it out a

00:12:29,119 --> 00:12:33,649
level so that now I there are two pieces

00:12:31,969 --> 00:12:36,889
of the system code talking to each other

00:12:33,649 --> 00:12:42,279
but now though that codes dependencies

00:12:36,889 --> 00:12:46,429
have been locked out mock is cool use it

00:12:42,279 --> 00:12:46,969
I I really this was a game changer for

00:12:46,429 --> 00:12:49,639
me

00:12:46,969 --> 00:12:52,159
because all of the libraries that I had

00:12:49,639 --> 00:12:55,449
ever used for unit testing prior to

00:12:52,159 --> 00:12:58,159
using mock had all used a record replay

00:12:55,449 --> 00:13:00,799
model of unit testing where you

00:12:58,159 --> 00:13:02,739
basically record how they how things are

00:13:00,799 --> 00:13:06,769
supposed to go and then replay them and

00:13:02,739 --> 00:13:08,959
it is it it flips the normal way you

00:13:06,769 --> 00:13:11,209
think about your code sort of upside

00:13:08,959 --> 00:13:12,979
down a little bit and I found it a

00:13:11,209 --> 00:13:15,349
little bit confusing and some tools are

00:13:12,979 --> 00:13:16,819
better at hiding it than others I had

00:13:15,349 --> 00:13:22,279
some success of your if you want to

00:13:16,819 --> 00:13:24,859
compare the mocks library mo X is one

00:13:22,279 --> 00:13:26,239
that I've had some success with until I

00:13:24,859 --> 00:13:27,349
found market which want to just kind of

00:13:26,239 --> 00:13:30,259
like threw them on the ground and ran

00:13:27,349 --> 00:13:34,339
away and just use them off mock uses a

00:13:30,259 --> 00:13:36,859
an action assertion model which fits my

00:13:34,339 --> 00:13:39,289
brain much better because basically you

00:13:36,859 --> 00:13:41,749
you do you set up the conditions for the

00:13:39,289 --> 00:13:43,759
for the execution environment you

00:13:41,749 --> 00:13:47,720
execute the code and you make assertions

00:13:43,759 --> 00:13:48,859
about about the result so we're going to

00:13:47,720 --> 00:13:50,949
see we're going to see a little bit of

00:13:48,859 --> 00:13:50,949
that

00:13:53,640 --> 00:13:57,700
macht also handles harder stuff we're

00:13:56,350 --> 00:13:59,560
not going to get into too much of it

00:13:57,700 --> 00:14:00,970
here because I really want to focus more

00:13:59,560 --> 00:14:02,650
on just getting over the hump and

00:14:00,970 --> 00:14:04,300
getting to where you can use these

00:14:02,650 --> 00:14:05,740
things and some of that has to do with

00:14:04,300 --> 00:14:08,350
how your code is laid out and things

00:14:05,740 --> 00:14:10,690
like that but you can make assertions

00:14:08,350 --> 00:14:12,790
about what methods on the mock object

00:14:10,690 --> 00:14:14,470
were called and with what arguments

00:14:12,790 --> 00:14:16,450
which is which is really nice

00:14:14,470 --> 00:14:18,820
it you can mock magic methods with

00:14:16,450 --> 00:14:22,750
writing really no code which is

00:14:18,820 --> 00:14:26,170
fantastic and it puts objects back the

00:14:22,750 --> 00:14:27,970
way it found them after a test which can

00:14:26,170 --> 00:14:32,110
really cause problems in unit tests if

00:14:27,970 --> 00:14:34,660
you if you have sort of a state leakage

00:14:32,110 --> 00:14:36,220
between your tests you can have tests

00:14:34,660 --> 00:14:37,690
that are passing and they really

00:14:36,220 --> 00:14:40,590
shouldn't be passing but because some

00:14:37,690 --> 00:14:43,780
state is leaking between your unit tests

00:14:40,590 --> 00:14:45,250
you'll get or just vice-versa two tests

00:14:43,780 --> 00:14:46,960
that should pass won't because state is

00:14:45,250 --> 00:14:48,850
leaking between your tests and the

00:14:46,960 --> 00:14:50,530
reason it's leaking is because something

00:14:48,850 --> 00:14:52,150
that you patched was never put back the

00:14:50,530 --> 00:14:54,190
way it was and so it still exists in

00:14:52,150 --> 00:14:56,080
that state and your test is trying to

00:14:54,190 --> 00:14:59,970
use it in some way that is either

00:14:56,080 --> 00:15:02,170
mistakenly valid or mistakenly invalid

00:14:59,970 --> 00:15:04,660
there's tons more note that this talk is

00:15:02,170 --> 00:15:07,440
really just a light intro okay you

00:15:04,660 --> 00:15:07,440
should really check it out

00:15:10,320 --> 00:15:17,190
so here's I have some code under test

00:15:13,050 --> 00:15:19,110
and when you're this is the whole system

00:15:17,190 --> 00:15:22,160
so what you're looking at now is if you

00:15:19,110 --> 00:15:25,199
have some code that's under test really

00:15:22,160 --> 00:15:28,110
you're testing the whole system and so I

00:15:25,199 --> 00:15:29,940
wanted to illustrate the how the reality

00:15:28,110 --> 00:15:33,180
distortion field the barrier that you

00:15:29,940 --> 00:15:38,160
create with your mock objects affects

00:15:33,180 --> 00:15:39,899
how your tests are useful so here we

00:15:38,160 --> 00:15:41,550
have we're mocking out the the bits of

00:15:39,899 --> 00:15:43,790
code that are closest to the code under

00:15:41,550 --> 00:15:46,019
test and the mocks replace everything

00:15:43,790 --> 00:15:48,750
starting from the point closest to the

00:15:46,019 --> 00:15:50,130
code under tests and then we have and

00:15:48,750 --> 00:15:52,949
then so and that's where you get the

00:15:50,130 --> 00:15:56,519
most localization of your problems when

00:15:52,949 --> 00:15:58,800
you move out a level these are basically

00:15:56,519 --> 00:16:01,259
low level integration tests now your

00:15:58,800 --> 00:16:02,970
code under test is talking two bits that

00:16:01,259 --> 00:16:05,759
are you know quote unquote one step away

00:16:02,970 --> 00:16:07,800
but everything from there beyond has

00:16:05,759 --> 00:16:09,959
been mocked out and so you get a little

00:16:07,800 --> 00:16:11,430
bit less localization but you get a more

00:16:09,959 --> 00:16:13,589
thorough test of the integration of

00:16:11,430 --> 00:16:18,000
those parts so there's still a lot of

00:16:13,589 --> 00:16:20,459
value in that at this point you're

00:16:18,000 --> 00:16:21,839
mocking out only the external resources

00:16:20,459 --> 00:16:24,269
like a database server an HTTP server

00:16:21,839 --> 00:16:26,930
maybe you're mocking out the other

00:16:24,269 --> 00:16:31,050
remote resources as well or even disk

00:16:26,930 --> 00:16:32,399
and again you know if you started here

00:16:31,050 --> 00:16:34,829
if this is where you're starting you

00:16:32,399 --> 00:16:37,110
still have a lot of question marks so if

00:16:34,829 --> 00:16:39,180
you're finding that you're testing in

00:16:37,110 --> 00:16:40,680
this sort of mode and you still have a

00:16:39,180 --> 00:16:42,630
lot of question marks when things don't

00:16:40,680 --> 00:16:44,760
go quite right you can move the reality

00:16:42,630 --> 00:16:46,380
storsch and field back and the way I do

00:16:44,760 --> 00:16:48,240
that is actually just by having separate

00:16:46,380 --> 00:16:50,880
modules that do unit testing versus

00:16:48,240 --> 00:16:52,410
integration testing and you know maybe

00:16:50,880 --> 00:16:54,689
higher level integration of testing in

00:16:52,410 --> 00:16:56,220
another module and then finally you have

00:16:54,689 --> 00:16:59,850
your acceptance test where it has in the

00:16:56,220 --> 00:17:02,370
entire system as a holistic system so

00:16:59,850 --> 00:17:04,020
how do you get there though and how do

00:17:02,370 --> 00:17:07,110
you how you get to be able to you know

00:17:04,020 --> 00:17:10,169
part of the resistance I think to moving

00:17:07,110 --> 00:17:12,329
from a staging environment more towards

00:17:10,169 --> 00:17:14,790
unit testing is that it does require a

00:17:12,329 --> 00:17:17,040
little bit deeper knowledge of the code

00:17:14,790 --> 00:17:18,540
it does require knowledge of some

00:17:17,040 --> 00:17:20,549
special techniques that you may not

00:17:18,540 --> 00:17:23,250
really need in a staging environment and

00:17:20,549 --> 00:17:26,069
it is an investment in terms of learn

00:17:23,250 --> 00:17:27,600
how to how to do it properly and I think

00:17:26,069 --> 00:17:29,610
there's some resistance there especially

00:17:27,600 --> 00:17:31,680
among managers that have large developer

00:17:29,610 --> 00:17:33,720
bases that you know don't want to make

00:17:31,680 --> 00:17:38,550
the investment to to train them all in

00:17:33,720 --> 00:17:40,110
unit testing so you might find using

00:17:38,550 --> 00:17:42,090
mocks difficult if your code is

00:17:40,110 --> 00:17:44,340
otherwise generally not doing the things

00:17:42,090 --> 00:17:45,780
that I'm about to tell you about but if

00:17:44,340 --> 00:17:48,090
you do them if you take the time to do

00:17:45,780 --> 00:17:50,460
these things your application code will

00:17:48,090 --> 00:17:52,260
be better off for it in the long run

00:17:50,460 --> 00:17:54,720
this is not done just for the sake of

00:17:52,260 --> 00:17:59,310
unit testing it's done it actually does

00:17:54,720 --> 00:18:00,840
improve your your code so there's a lot

00:17:59,310 --> 00:18:02,990
of low-hanging fruit these are things

00:18:00,840 --> 00:18:05,340
that I think are pretty simple to do

00:18:02,990 --> 00:18:07,680
without changing the API that your

00:18:05,340 --> 00:18:09,240
end-users might eventually be using so

00:18:07,680 --> 00:18:11,040
one is limiting the scope of

00:18:09,240 --> 00:18:13,080
responsibility so you if you have really

00:18:11,040 --> 00:18:15,620
long methods that you know are 75 lines

00:18:13,080 --> 00:18:18,810
long and they do everything soup-to-nuts

00:18:15,620 --> 00:18:20,670
inside them then breaking up the scope

00:18:18,810 --> 00:18:22,890
of responsibility is not only going to

00:18:20,670 --> 00:18:25,260
make your code more flexible and easier

00:18:22,890 --> 00:18:26,880
to refactor later but it's also going to

00:18:25,260 --> 00:18:29,340
make it a whole lot easier to unit tests

00:18:26,880 --> 00:18:31,530
and it's going to probably reduce the

00:18:29,340 --> 00:18:34,110
the amount of code the number of

00:18:31,530 --> 00:18:36,120
external dependencies and therefore you

00:18:34,110 --> 00:18:37,710
need fewer mops and writing the tests

00:18:36,120 --> 00:18:40,230
actually becomes really really simple I

00:18:37,710 --> 00:18:41,490
have lots and lots of unit tests that

00:18:40,230 --> 00:18:43,770
are really just four or five lines of

00:18:41,490 --> 00:18:46,760
code it's very simple and the mock

00:18:43,770 --> 00:18:50,820
library and other mock libraries to

00:18:46,760 --> 00:18:53,250
facilitate that I'm a huge advocate of

00:18:50,820 --> 00:18:58,770
creating local wrappers around things

00:18:53,250 --> 00:19:00,810
that talk to external resources and this

00:18:58,770 --> 00:19:02,820
buys you a number of things actually one

00:19:00,810 --> 00:19:04,470
is just better encapsulation if you're

00:19:02,820 --> 00:19:07,140
using URL Lib today and you want to use

00:19:04,470 --> 00:19:08,520
HTTP Lib tomorrow you want to be able to

00:19:07,140 --> 00:19:11,850
change that out without changing the API

00:19:08,520 --> 00:19:13,830
and impacting your users so creating

00:19:11,850 --> 00:19:16,560
local rappers is is definitely the way

00:19:13,830 --> 00:19:17,610
to go and then D duplicating code I

00:19:16,560 --> 00:19:19,950
think is probably one that's pretty

00:19:17,610 --> 00:19:21,930
obvious until you actually go and find

00:19:19,950 --> 00:19:24,930
try to try to actually inspect your code

00:19:21,930 --> 00:19:26,220
to find duplicate code I would imagine

00:19:24,930 --> 00:19:28,290
that almost everyone in this room will

00:19:26,220 --> 00:19:31,380
find duplicate code somewhere in their

00:19:28,290 --> 00:19:34,200
code bases it is a difficult thing to

00:19:31,380 --> 00:19:35,420
abolish because in in larger teams

00:19:34,200 --> 00:19:38,510
there's multiple pupil

00:19:35,420 --> 00:19:41,240
working on the codebase and the way that

00:19:38,510 --> 00:19:43,040
things evolve is something has to get

00:19:41,240 --> 00:19:44,060
out of the door right away and they say

00:19:43,040 --> 00:19:45,530
okay well I'm just going to cut and

00:19:44,060 --> 00:19:47,030
paste that over here I'm going to edit

00:19:45,530 --> 00:19:50,450
this one thing and then there you go you

00:19:47,030 --> 00:19:53,120
have to placate code but it is typically

00:19:50,450 --> 00:19:57,410
pretty easy to fix so let's look at an

00:19:53,120 --> 00:19:59,570
example I have class foo and in there is

00:19:57,410 --> 00:20:03,170
one method it's not a very long method

00:19:59,570 --> 00:20:07,160
but it's doing a lot of stuff and we're

00:20:03,170 --> 00:20:08,950
going to apply these three these three

00:20:07,160 --> 00:20:10,760
things to fix this code up a little bit

00:20:08,950 --> 00:20:13,760
so you have get pass

00:20:10,760 --> 00:20:15,590
get path is using URL Lib which means

00:20:13,760 --> 00:20:17,900
that it's not only using URL Lib to make

00:20:15,590 --> 00:20:20,060
the calls it's also dealing locally with

00:20:17,900 --> 00:20:23,630
the result object that's produced by URL

00:20:20,060 --> 00:20:26,000
Lib URL open so we'd like to create a

00:20:23,630 --> 00:20:27,770
wrapper around that so that when we if

00:20:26,000 --> 00:20:29,660
or when we decide that we don't like URL

00:20:27,770 --> 00:20:32,210
Lib anymore or we decide that something

00:20:29,660 --> 00:20:33,980
is easier to do with HTTP lib or URL Lib

00:20:32,210 --> 00:20:35,300
3 or something like that we can just put

00:20:33,980 --> 00:20:37,460
that in our local wrapper we can use

00:20:35,300 --> 00:20:39,080
multiple things in there and wrap it all

00:20:37,460 --> 00:20:44,230
up and still provide the same nice API

00:20:39,080 --> 00:20:46,400
for our end users so local rappers

00:20:44,230 --> 00:20:46,850
responsibility we're doing we're doing

00:20:46,400 --> 00:20:48,860
the getting

00:20:46,850 --> 00:20:53,420
we're doing the formatting and we're

00:20:48,860 --> 00:20:54,770
doing the logging right so this is

00:20:53,420 --> 00:20:56,840
really not the responsibility of this

00:20:54,770 --> 00:20:58,820
method this message says it gets a path

00:20:56,840 --> 00:21:05,210
and we're doing all kinds of other stuff

00:20:58,820 --> 00:21:07,790
inside of it we have a little bit of

00:21:05,210 --> 00:21:09,230
code duplication but it's compiled all

00:21:07,790 --> 00:21:11,360
admit it's completely concocted for the

00:21:09,230 --> 00:21:13,670
purpose of the talk the the result

00:21:11,360 --> 00:21:15,410
assignment assigns to shrink i/o -

00:21:13,670 --> 00:21:18,350
string i/o I could have just moved it up

00:21:15,410 --> 00:21:20,060
in the method but you know we want I

00:21:18,350 --> 00:21:22,730
wanted to make sure that I had all the

00:21:20,060 --> 00:21:26,480
all the pieces so here's part of the

00:21:22,730 --> 00:21:31,970
solution here's my local wrapper for URL

00:21:26,480 --> 00:21:35,350
Lib called HTTP client it has one method

00:21:31,970 --> 00:21:38,180
get' and that wraps my URL Lib

00:21:35,350 --> 00:21:40,370
dependency and what it returns is

00:21:38,180 --> 00:21:45,520
actually an instance of a wrapper that I

00:21:40,370 --> 00:21:48,300
created for the URL Lib response object

00:21:45,520 --> 00:21:50,970
so now when we go back to class

00:21:48,300 --> 00:21:53,130
phoo we actually won't have any code

00:21:50,970 --> 00:21:54,600
either that makes calls or that deals

00:21:53,130 --> 00:21:57,180
with the response object that is

00:21:54,600 --> 00:21:59,300
dependent on URL or even references it

00:21:57,180 --> 00:22:02,220
at all

00:21:59,300 --> 00:22:04,350
the result object for its part has

00:22:02,220 --> 00:22:06,480
methods that you can actually ask it for

00:22:04,350 --> 00:22:09,120
different representations of itself so

00:22:06,480 --> 00:22:10,650
the whole formatting thing you can

00:22:09,120 --> 00:22:11,640
either punt on it or you can leave it in

00:22:10,650 --> 00:22:13,140
there and just say well I'm just going

00:22:11,640 --> 00:22:14,790
to ask the result object for this and

00:22:13,140 --> 00:22:16,950
pass it on as a convenience to the user

00:22:14,790 --> 00:22:19,290
and that's pretty much what I did here

00:22:16,950 --> 00:22:23,360
so now in the initialization of the foo

00:22:19,290 --> 00:22:28,860
object we instantiate a an HTTP client

00:22:23,360 --> 00:22:32,520
and then get foo liens on that HTTP

00:22:28,860 --> 00:22:35,010
client to get the path and then if the

00:22:32,520 --> 00:22:37,260
format we kept the formatting we decided

00:22:35,010 --> 00:22:39,180
not to punt on that one and if the

00:22:37,260 --> 00:22:40,140
format is test text it just says you

00:22:39,180 --> 00:22:41,910
know give me the give me the text

00:22:40,140 --> 00:22:43,500
version otherwise give me the JSON

00:22:41,910 --> 00:22:49,860
version and then return return the

00:22:43,500 --> 00:22:51,240
result we did punt on logging I decided

00:22:49,860 --> 00:22:53,580
that you know if you were right really

00:22:51,240 --> 00:22:54,810
writing a class like this this class

00:22:53,580 --> 00:22:57,210
looks like it's something that's going

00:22:54,810 --> 00:22:58,950
to be used by other code this is not a

00:22:57,210 --> 00:23:01,040
end user code this is code that is

00:22:58,950 --> 00:23:03,120
probably used by end user code and

00:23:01,040 --> 00:23:04,770
really the end user code should be in

00:23:03,120 --> 00:23:06,210
charge of logging unless it's like debug

00:23:04,770 --> 00:23:08,640
logging and they turn on logging dot

00:23:06,210 --> 00:23:10,190
debug and so your code should log along

00:23:08,640 --> 00:23:12,210
with everything else and that's nice but

00:23:10,190 --> 00:23:14,400
but but the code that we had there

00:23:12,210 --> 00:23:17,310
before was logging to a to a file like

00:23:14,400 --> 00:23:18,570
it was doing manual logging by itself so

00:23:17,310 --> 00:23:20,310
I actually just completely threw that

00:23:18,570 --> 00:23:21,780
out and I would at that point I would

00:23:20,310 --> 00:23:28,320
say you know the user should really be

00:23:21,780 --> 00:23:30,570
logging this themselves so we're gonna

00:23:28,320 --> 00:23:34,320
have another look at a date/time

00:23:30,570 --> 00:23:37,410
extraction library and we'll look it a

00:23:34,320 --> 00:23:40,140
little bit how this works this is these

00:23:37,410 --> 00:23:42,180
are this is this is a package called

00:23:40,140 --> 00:23:44,640
time machine it's not on pi PI but it's

00:23:42,180 --> 00:23:47,040
in github /bk Jones if you want to take

00:23:44,640 --> 00:23:48,240
a look at the larger number there's

00:23:47,040 --> 00:23:51,390
there's a large none of our methods this

00:23:48,240 --> 00:23:53,970
is just a few representative samples

00:23:51,390 --> 00:23:55,620
from that all it only has it only

00:23:53,970 --> 00:23:56,190
imports two modules from the standard

00:23:55,620 --> 00:23:58,920
library

00:23:56,190 --> 00:24:00,570
it's a wrapper around that and it just

00:23:58,920 --> 00:24:01,220
does a bunch of date/time manipulation

00:24:00,570 --> 00:24:03,409
stuff

00:24:01,220 --> 00:24:06,490
I was doing some I was writing a support

00:24:03,409 --> 00:24:09,260
module for database reporting projects

00:24:06,490 --> 00:24:10,730
so you know if you want to say I need I

00:24:09,260 --> 00:24:12,799
need a report on every single month in

00:24:10,730 --> 00:24:14,659
the last three years I need to pass to

00:24:12,799 --> 00:24:16,669
the database function the start and end

00:24:14,659 --> 00:24:19,039
date of each month in that in that time

00:24:16,669 --> 00:24:20,330
frame so I wanted to just wrap all that

00:24:19,039 --> 00:24:23,990
stuff because it's pretty ugly to do

00:24:20,330 --> 00:24:28,309
otherwise so it's about a hundred lines

00:24:23,990 --> 00:24:30,530
of code that's actually executable it's

00:24:28,309 --> 00:24:32,210
one module it contains like just you

00:24:30,530 --> 00:24:34,100
know one small simple class called time

00:24:32,210 --> 00:24:35,870
machine you just do from Time Machine

00:24:34,100 --> 00:24:37,100
import time machine and you're off and

00:24:35,870 --> 00:24:39,409
running you instantiate it with no

00:24:37,100 --> 00:24:40,820
arguments it's easy to use it's only got

00:24:39,409 --> 00:24:42,559
two imports it just wraps the

00:24:40,820 --> 00:24:45,650
functionality of date/time and then a

00:24:42,559 --> 00:24:47,539
little bit of calendar and there are no

00:24:45,650 --> 00:24:51,200
third-party dependencies or external

00:24:47,539 --> 00:24:54,380
anything it is tested actually I removed

00:24:51,200 --> 00:24:57,080
it from the listing over here just for

00:24:54,380 --> 00:25:01,309
readability but it's actually tested

00:24:57,080 --> 00:25:02,690
using docked tests so so the question

00:25:01,309 --> 00:25:04,640
there is like do you really refactor

00:25:02,690 --> 00:25:07,909
this to do unit test like it's got its

00:25:04,640 --> 00:25:09,289
it actually is tested are you getting do

00:25:07,909 --> 00:25:11,480
I really need to go and create mocks and

00:25:09,289 --> 00:25:13,789
fakes and actually write a test stop pie

00:25:11,480 --> 00:25:15,919
with a unit test test case class and all

00:25:13,789 --> 00:25:19,760
this other stuff my answer to you would

00:25:15,919 --> 00:25:21,409
be yes you need to do this and the

00:25:19,760 --> 00:25:24,230
reason is that I don't think I have a

00:25:21,409 --> 00:25:26,299
screenshot of this but the when you

00:25:24,230 --> 00:25:27,590
iterate over your code you're gonna add

00:25:26,299 --> 00:25:28,669
a test every time there's a regression

00:25:27,590 --> 00:25:30,919
you're going to add a test to make sure

00:25:28,669 --> 00:25:33,470
that your code never falls prey to this

00:25:30,919 --> 00:25:35,150
problem again as you further iterate

00:25:33,470 --> 00:25:36,559
over the code so you end up with

00:25:35,150 --> 00:25:40,610
possibly a whole bunch of these things

00:25:36,559 --> 00:25:42,110
so and and so dot tests name implies

00:25:40,610 --> 00:25:44,720
that it should also serve something

00:25:42,110 --> 00:25:46,039
somewhat as documentation and I think

00:25:44,720 --> 00:25:48,110
that after a while this becomes rather

00:25:46,039 --> 00:25:50,090
unreadable and there's lots of like

00:25:48,110 --> 00:25:51,409
special case little pragmas and stuff

00:25:50,090 --> 00:25:53,270
like that in doc tests that you also

00:25:51,409 --> 00:25:54,980
have to you know bear in mind when

00:25:53,270 --> 00:25:56,000
you're reading the docs and you have to

00:25:54,980 --> 00:25:57,559
know about that so it's really not

00:25:56,000 --> 00:26:01,309
documentation unless you actually know

00:25:57,559 --> 00:26:02,630
how doc tests works so and and the same

00:26:01,309 --> 00:26:03,860
is true to some degree for unit tests

00:26:02,630 --> 00:26:05,720
but I feel like unit tests really

00:26:03,860 --> 00:26:08,960
provide just as good documentation if

00:26:05,720 --> 00:26:12,590
not better than doc tests after some

00:26:08,960 --> 00:26:14,200
period of time I don't want to read that

00:26:12,590 --> 00:26:16,779
I don't you know I don't

00:26:14,200 --> 00:26:19,450
that's I want I want named I want things

00:26:16,779 --> 00:26:22,029
that have names so that that give me

00:26:19,450 --> 00:26:23,710
some indication as to the the conditions

00:26:22,029 --> 00:26:25,480
that are being applied I want an

00:26:23,710 --> 00:26:27,190
assertion that clearly states what's

00:26:25,480 --> 00:26:29,139
being what's what it is that's being

00:26:27,190 --> 00:26:31,330
done what makes this thing pass or fail

00:26:29,139 --> 00:26:33,159
what makes it pass or fail is usually an

00:26:31,330 --> 00:26:34,480
assertion statement at the end you know

00:26:33,159 --> 00:26:36,279
I want these things I don't want to have

00:26:34,480 --> 00:26:39,070
to sift through all of these things and

00:26:36,279 --> 00:26:41,019
figure out which condition I'm

00:26:39,070 --> 00:26:42,940
interested in and then see you know how

00:26:41,019 --> 00:26:45,570
it's supposed to work I just don't find

00:26:42,940 --> 00:26:49,029
it to be very intuitive to the reader

00:26:45,570 --> 00:26:50,739
and this started out obviously is like

00:26:49,029 --> 00:26:52,749
just one doc test and when you have one

00:26:50,739 --> 00:26:57,009
doc test it's awesome but it grows over

00:26:52,749 --> 00:27:01,600
time like I said so this is part of what

00:26:57,009 --> 00:27:03,039
I did on the plane now I have a unit

00:27:01,600 --> 00:27:04,419
test test case so if you haven't seen

00:27:03,039 --> 00:27:06,730
those before that's what this is this is

00:27:04,419 --> 00:27:09,369
how you create a test case using the

00:27:06,730 --> 00:27:11,019
unit test module it has a setup which is

00:27:09,369 --> 00:27:11,980
something that the unit test module

00:27:11,019 --> 00:27:14,590
actually knows what that is

00:27:11,980 --> 00:27:16,389
and I instantiate a time machine object

00:27:14,590 --> 00:27:17,799
I set a start date that I'm just going

00:27:16,389 --> 00:27:20,440
to use for the purpose of this test case

00:27:17,799 --> 00:27:23,409
and then I have a test that says test

00:27:20,440 --> 00:27:25,869
previous by day and I set I setup my

00:27:23,409 --> 00:27:27,639
conditions in the in the first two lines

00:27:25,869 --> 00:27:29,169
so I said a day a week of Wednesday is

00:27:27,639 --> 00:27:35,609
gonna be passed in as an argument to the

00:27:29,169 --> 00:27:37,600
code under test I assign what I expect

00:27:35,609 --> 00:27:39,039
expected as assigned to a date/time

00:27:37,600 --> 00:27:42,999
object that I'm expecting to get back

00:27:39,039 --> 00:27:47,100
after this code is wrong I assign actual

00:27:42,999 --> 00:27:49,330
to basically run the run the code and

00:27:47,100 --> 00:27:50,710
then I just do an assert equal to make

00:27:49,330 --> 00:27:55,029
sure that the expected is equal to the

00:27:50,710 --> 00:27:56,379
actual and my test passes I'm following

00:27:55,029 --> 00:27:57,850
a rule here that not everybody follows

00:27:56,379 --> 00:28:00,600
by the way which is one test one

00:27:57,850 --> 00:28:04,239
assertion rule not everybody follows it

00:28:00,600 --> 00:28:07,210
I kind of recommend that you do follow

00:28:04,239 --> 00:28:09,820
it you will write probably more unit

00:28:07,210 --> 00:28:12,700
tests as a result but I think that your

00:28:09,820 --> 00:28:14,649
your overall unit testing regime will be

00:28:12,700 --> 00:28:16,149
better off for it you know you're

00:28:14,649 --> 00:28:17,440
supposed to care for your unit test in

00:28:16,149 --> 00:28:20,230
the same way that you care for your

00:28:17,440 --> 00:28:22,720
production code and the result of not

00:28:20,230 --> 00:28:24,970
doing that typically results in some rot

00:28:22,720 --> 00:28:27,710
in the unit test code and some resulting

00:28:24,970 --> 00:28:30,110
rot in the in the production code

00:28:27,710 --> 00:28:35,930
and it's just a spiral a downward spiral

00:28:30,110 --> 00:28:37,160
and it turns into a big mess so anyway I

00:28:35,930 --> 00:28:39,350
think this is this is actually way more

00:28:37,160 --> 00:28:43,040
readable if I had one of one of these

00:28:39,350 --> 00:28:45,350
tests for each one of those they would

00:28:43,040 --> 00:28:47,000
just be named after the different

00:28:45,350 --> 00:28:49,250
conditions that are used to generate the

00:28:47,000 --> 00:28:51,020
the outcome and I think that would be

00:28:49,250 --> 00:28:56,480
much more readable than than reading all

00:28:51,020 --> 00:28:59,390
these doc tests so let's look at a

00:28:56,480 --> 00:29:00,830
different pattern which is just a rest

00:28:59,390 --> 00:29:02,150
client module I mean there's tons of

00:29:00,830 --> 00:29:03,650
these out there so these are these are

00:29:02,150 --> 00:29:06,560
pretty popular things to have to write

00:29:03,650 --> 00:29:08,450
and like I said before I wrote won't

00:29:06,560 --> 00:29:10,730
call pie rabbit it's on its it actually

00:29:08,450 --> 00:29:13,610
is on pie pie and it's also on read the

00:29:10,730 --> 00:29:17,030
docs and it's also on github BK Jones

00:29:13,610 --> 00:29:18,980
pie rabbit it's a client for a rabbit

00:29:17,030 --> 00:29:21,350
and Q's rest management API it's about

00:29:18,980 --> 00:29:23,090
250 lines of executable codes probably

00:29:21,350 --> 00:29:25,310
because I don't fully cover the entire

00:29:23,090 --> 00:29:29,330
gamut of the API I've covered probably

00:29:25,310 --> 00:29:32,120
about 80% of it it has 200 lines of unit

00:29:29,330 --> 00:29:33,680
test code some of those unit tests all

00:29:32,120 --> 00:29:34,880
I'll admit are kind of cheating and

00:29:33,680 --> 00:29:38,510
they're actually very low-level

00:29:34,880 --> 00:29:41,690
integration tests and it uses HTTP lip

00:29:38,510 --> 00:29:43,010
to to talk to the actual web server for

00:29:41,690 --> 00:29:45,530
the REST API the reason I did that was

00:29:43,010 --> 00:29:46,790
because I wanted to Python 3 support out

00:29:45,530 --> 00:29:48,560
of the box from you know I was writing

00:29:46,790 --> 00:29:50,120
this from scratch Python 3 was out why

00:29:48,560 --> 00:29:51,890
would I why would I create a module of

00:29:50,120 --> 00:29:56,000
these days without supporting Python 3

00:29:51,890 --> 00:29:59,180
out of the box so so I used two HTTP Lib

00:29:56,000 --> 00:30:03,320
to the tests actually do pass I test

00:29:59,180 --> 00:30:05,180
with a - 6 - 7 and 3 - and I use talks

00:30:03,320 --> 00:30:08,750
to test across the different versions

00:30:05,180 --> 00:30:11,120
and tox is cool you should use tox I'll

00:30:08,750 --> 00:30:12,890
do an aside right now just to quickly

00:30:11,120 --> 00:30:15,530
tell you about talks what you're looking

00:30:12,890 --> 00:30:18,860
at is tox is a config file for PI rabbit

00:30:15,530 --> 00:30:20,180
and it's it the configuration is

00:30:18,860 --> 00:30:21,980
actually way easier than it even looks

00:30:20,180 --> 00:30:24,140
right here because most of this stuff is

00:30:21,980 --> 00:30:25,610
stuff that talks actually just tells you

00:30:24,140 --> 00:30:28,340
about in its documentation so you have

00:30:25,610 --> 00:30:30,710
an E and V list those that list that

00:30:28,340 --> 00:30:32,660
comma-separated list there are all names

00:30:30,710 --> 00:30:33,650
that tox knows about so it's going to

00:30:32,660 --> 00:30:35,390
tell you the environments that it

00:30:33,650 --> 00:30:38,750
supports one of them is PI 2 6 for

00:30:35,390 --> 00:30:40,780
example so I put it in there then I set

00:30:38,750 --> 00:30:43,470
up a default test env

00:30:40,780 --> 00:30:45,670
if there is no other qualifying

00:30:43,470 --> 00:30:47,110
environment than all of your

00:30:45,670 --> 00:30:48,520
environments will use this same

00:30:47,110 --> 00:30:50,620
configuration

00:30:48,520 --> 00:30:53,760
so what talks is going to do is set up a

00:30:50,620 --> 00:30:57,610
virtual env it's going to in this case

00:30:53,760 --> 00:30:59,020
install nose HTTP Lib 2 and mock it's

00:30:57,610 --> 00:31:00,880
going to change the directory to the

00:30:59,020 --> 00:31:02,680
tests under the PI rabbit top-level

00:31:00,880 --> 00:31:06,790
directory and it's going to run notes

00:31:02,680 --> 00:31:08,410
tests with no arguments I do have a

00:31:06,790 --> 00:31:10,540
special case though because I use the

00:31:08,410 --> 00:31:12,760
unit test 2 module when I'm using Python

00:31:10,540 --> 00:31:14,320
2 6 I also recommend that because the

00:31:12,760 --> 00:31:15,910
assert statements are actually way nicer

00:31:14,320 --> 00:31:17,710
and there are some other functionality

00:31:15,910 --> 00:31:19,990
built into unit test 2 I believe that's

00:31:17,710 --> 00:31:21,670
where the new test discovery actually

00:31:19,990 --> 00:31:22,150
lives is in the unit test 2 module is

00:31:21,670 --> 00:31:26,530
that right

00:31:22,150 --> 00:31:28,750
thank you so there are a lot of features

00:31:26,530 --> 00:31:32,230
of that so and it's been back ported to

00:31:28,750 --> 00:31:35,950
be supportable in 2.6 so go check that

00:31:32,230 --> 00:31:37,300
out so in Python 26 I'm gonna have to

00:31:35,950 --> 00:31:38,980
add a dependency to say you're gonna

00:31:37,300 --> 00:31:43,450
also have to install the unit test 2

00:31:38,980 --> 00:31:47,410
module in in 3 2 you don't need that in

00:31:43,450 --> 00:31:48,910
2 7 you also don't need that and that's

00:31:47,410 --> 00:31:50,380
it and then you've run tox and you

00:31:48,910 --> 00:31:51,700
literally just you know you in the

00:31:50,380 --> 00:31:53,620
directory where the tox thought I and I

00:31:51,700 --> 00:31:56,110
file lives which in my case is in the

00:31:53,620 --> 00:32:01,000
top-level directory of PI rabbit I just

00:31:56,110 --> 00:32:02,350
run tox pip install talks talks and it

00:32:01,000 --> 00:32:04,660
says ok I'm building the environment 4

00:32:02,350 --> 00:32:07,600
to 6 I'm gonna run the test for that and

00:32:04,660 --> 00:32:09,130
here you go past or or didn't and then

00:32:07,600 --> 00:32:11,050
it's going to do that again for 270 it's

00:32:09,130 --> 00:32:13,030
gonna do that again 4 3 2 and I actually

00:32:11,050 --> 00:32:15,130
broke something on the plane so so

00:32:13,030 --> 00:32:18,730
actually normally it says success

00:32:15,130 --> 00:32:19,930
congrats but but this one kind of makes

00:32:18,730 --> 00:32:23,460
a sad face at me right now

00:32:19,930 --> 00:32:25,480
so I haven't pushed that code though so

00:32:23,460 --> 00:32:29,080
this is what PI rabbit kind of looks

00:32:25,480 --> 00:32:30,640
like on the command line I should point

00:32:29,080 --> 00:32:33,820
out too that you actually don't need to

00:32:30,640 --> 00:32:35,590
do to use pi rabbit in this way if you

00:32:33,820 --> 00:32:37,930
just want to like mess around with your

00:32:35,590 --> 00:32:39,970
rabbit and Q server you can actually

00:32:37,930 --> 00:32:41,680
download another thing called bunny Q

00:32:39,970 --> 00:32:43,300
that I wrote that uses PI rabbit so it

00:32:41,680 --> 00:32:45,430
serves as an example code that uses PI

00:32:43,300 --> 00:32:47,860
rabbit and it also is a command shell

00:32:45,430 --> 00:32:49,480
for interacting with it but these are

00:32:47,860 --> 00:32:51,070
just some examples so this one just

00:32:49,480 --> 00:32:52,720
checks you know it creates the client

00:32:51,070 --> 00:32:55,710
object checks that it's alive creates a

00:32:52,720 --> 00:32:58,090
V host set some permission

00:32:55,710 --> 00:33:00,280
goes through and creates an exchange in

00:32:58,090 --> 00:33:01,210
a queue finds the exchange and the cute

00:33:00,280 --> 00:33:04,270
together

00:33:01,210 --> 00:33:06,340
publishes a message and then blows

00:33:04,270 --> 00:33:13,510
everything up so destroys everything it

00:33:06,340 --> 00:33:15,070
creates the the overall model I've tried

00:33:13,510 --> 00:33:16,420
to make as simple as possible and so I

00:33:15,070 --> 00:33:18,280
basically just have an HTTP client

00:33:16,420 --> 00:33:22,270
that's that's a wrapped it's a wrapper

00:33:18,280 --> 00:33:25,180
around HTTP lib - and all of the code in

00:33:22,270 --> 00:33:27,820
the API module just calls the do call

00:33:25,180 --> 00:33:33,940
method of the HTTP client passing in the

00:33:27,820 --> 00:33:35,770
HTTP method name and the path and as we

00:33:33,940 --> 00:33:38,110
the HTTP client module itself it only

00:33:35,770 --> 00:33:40,720
has a main class which only has three

00:33:38,110 --> 00:33:43,240
methods including in it and a couple of

00:33:40,720 --> 00:33:45,880
exception classes so the code is

00:33:43,240 --> 00:33:47,740
actually really simple and it made it a

00:33:45,880 --> 00:33:49,600
lot easier to test it didn't start out

00:33:47,740 --> 00:33:51,550
being very easy to test but because I

00:33:49,600 --> 00:33:53,200
actually I'm not doing pure test-driven

00:33:51,550 --> 00:33:54,460
development yet who's doing like pure

00:33:53,200 --> 00:33:55,420
test-driven development where you really

00:33:54,460 --> 00:34:01,230
don't write any code and tell this

00:33:55,420 --> 00:34:04,000
awesome I'm so close to being there and

00:34:01,230 --> 00:34:07,060
it's really fantastic but I am iterating

00:34:04,000 --> 00:34:08,980
quickly enough between the code that I'm

00:34:07,060 --> 00:34:10,780
writing in the tests that my tests still

00:34:08,980 --> 00:34:14,560
do have some time to inform my codes

00:34:10,780 --> 00:34:20,590
design so that that's been really

00:34:14,560 --> 00:34:24,250
enlightening so let's move on here so I

00:34:20,590 --> 00:34:30,570
have a get connections method inside the

00:34:24,250 --> 00:34:35,020
API module the client URLs is a class

00:34:30,570 --> 00:34:36,850
dictionary that just maps names to the

00:34:35,020 --> 00:34:40,030
path on the API server that I want to

00:34:36,850 --> 00:34:41,080
call so that when the API changes a path

00:34:40,030 --> 00:34:42,700
I just have to change it in one place

00:34:41,080 --> 00:34:45,820
any methods that use that just

00:34:42,700 --> 00:34:48,250
automatically work the connections are

00:34:45,820 --> 00:34:50,050
just a again a call to do call passing

00:34:48,250 --> 00:34:52,570
in the path and the HTTP method to use

00:34:50,050 --> 00:34:55,120
and it just returns whatever it gets

00:34:52,570 --> 00:34:56,740
back and if any exceptions are raised

00:34:55,120 --> 00:35:00,810
down there then they actually just

00:34:56,740 --> 00:35:00,810
bubble up through this purposely

00:35:02,630 --> 00:35:06,480
here's the to call method I wanted it

00:35:04,890 --> 00:35:08,220
we're gonna mock this out so I wanted to

00:35:06,480 --> 00:35:10,470
show to you before we mocked it out

00:35:08,220 --> 00:35:12,030
the lines in red are things that catch

00:35:10,470 --> 00:35:13,680
my eye right away when I look at a

00:35:12,030 --> 00:35:17,070
method like this and I'm thinking about

00:35:13,680 --> 00:35:18,780
mocking it out these represent things

00:35:17,070 --> 00:35:21,060
that I'm probably going to test at some

00:35:18,780 --> 00:35:24,030
point all right so I'm going to test

00:35:21,060 --> 00:35:25,500
that if if this exception is thrown that

00:35:24,030 --> 00:35:28,500
might then my code under test actually

00:35:25,500 --> 00:35:29,850
handles that properly if it returns none

00:35:28,500 --> 00:35:31,860
I'm going to test that my code handles

00:35:29,850 --> 00:35:33,270
that properly so everything that can

00:35:31,860 --> 00:35:34,650
possibly be returned to my code is

00:35:33,270 --> 00:35:43,080
actually going to be tested to verify

00:35:34,650 --> 00:35:45,120
that it handles the return properly so

00:35:43,080 --> 00:35:46,710
here's my test only that I'll point out

00:35:45,120 --> 00:35:48,870
right now that only the top test is

00:35:46,710 --> 00:35:50,340
actually a unit test the bottom test I

00:35:48,870 --> 00:35:51,840
think would technically qualify as a

00:35:50,340 --> 00:35:54,450
low-level integration test because I do

00:35:51,840 --> 00:36:00,090
not mock out the HTTP client itself i

00:35:54,450 --> 00:36:03,780
mock out the the HTTP clients instance

00:36:00,090 --> 00:36:11,580
of HTTP libs client its I mock its

00:36:03,780 --> 00:36:13,410
request method so in the first one I

00:36:11,580 --> 00:36:14,880
mock everything out and I'm using the

00:36:13,410 --> 00:36:16,860
mock library here to create a mock

00:36:14,880 --> 00:36:19,770
object for a self-taught client at HTTP

00:36:16,860 --> 00:36:21,540
and then the the do call method is a

00:36:19,770 --> 00:36:24,060
mock object and I've set the return

00:36:21,540 --> 00:36:26,850
value to true now when we looked at the

00:36:24,060 --> 00:36:28,020
code earlier we said that it's just

00:36:26,850 --> 00:36:29,490
going to make the do call method and

00:36:28,020 --> 00:36:30,900
return whatever it gets back so if it

00:36:29,490 --> 00:36:34,440
gets back true then this this should

00:36:30,900 --> 00:36:35,910
just return true when I run it so I have

00:36:34,440 --> 00:36:42,650
an assertion that says self assert true

00:36:35,910 --> 00:36:44,700
that when I run this it returns true so

00:36:42,650 --> 00:36:47,070
normally you might have to create like a

00:36:44,700 --> 00:36:48,900
whole mock thing over to the side to

00:36:47,070 --> 00:36:51,660
mock out your do call and you might have

00:36:48,900 --> 00:36:53,280
to you know you know import more stuff

00:36:51,660 --> 00:36:55,080
into your unit test module and

00:36:53,280 --> 00:36:57,510
everything else and really all I did was

00:36:55,080 --> 00:36:59,220
import mock and assign a return value to

00:36:57,510 --> 00:37:03,270
a mock object so if that mock object

00:36:59,220 --> 00:37:05,540
it's called it always returns that and

00:37:03,270 --> 00:37:08,670
then I have tests get connections and

00:37:05,540 --> 00:37:11,160
I'm saying that the request raises an

00:37:08,670 --> 00:37:13,080
exception so the you can see the

00:37:11,160 --> 00:37:14,250
response and content equals self client

00:37:13,080 --> 00:37:16,920
requests if

00:37:14,250 --> 00:37:19,340
throws any kind of exception the do call

00:37:16,920 --> 00:37:21,599
method should raise a network error

00:37:19,340 --> 00:37:22,800
because at this point in the execution

00:37:21,599 --> 00:37:24,240
of this code I'm assuming that any

00:37:22,800 --> 00:37:27,090
anything that goes wrong is related to

00:37:24,240 --> 00:37:32,730
the network not the not the content or

00:37:27,090 --> 00:37:34,890
anything like that and then I'm using I

00:37:32,730 --> 00:37:38,040
think this was added in unit test to

00:37:34,890 --> 00:37:41,430
actually the using self assert raises as

00:37:38,040 --> 00:37:43,890
a context manager and I'm asserting that

00:37:41,430 --> 00:37:47,910
what I'm about to do raises a pie rabbit

00:37:43,890 --> 00:37:50,910
HTTP network error and then I run self

00:37:47,910 --> 00:37:52,980
client get connections and if that does

00:37:50,910 --> 00:37:55,200
not raise the oh and I'm using mock

00:37:52,980 --> 00:37:57,060
using and I'm setting the side-effect

00:37:55,200 --> 00:38:00,720
parameter to my mock objects

00:37:57,060 --> 00:38:03,930
instantiation to be the to be the

00:38:00,720 --> 00:38:08,310
exception and so that shows up over here

00:38:03,930 --> 00:38:10,230
accept exception is out and then it

00:38:08,310 --> 00:38:11,820
should raise the network error which

00:38:10,230 --> 00:38:16,859
I've accounted for here by saying assert

00:38:11,820 --> 00:38:18,240
raises Network error so we're almost out

00:38:16,859 --> 00:38:22,650
of time already

00:38:18,240 --> 00:38:23,730
a couple other tricks with with mocks

00:38:22,650 --> 00:38:25,530
they're not really tricks they're just

00:38:23,730 --> 00:38:29,990
things that I think are are made pretty

00:38:25,530 --> 00:38:32,160
easy one is mocking a standard output

00:38:29,990 --> 00:38:34,440
this is just something that you see

00:38:32,160 --> 00:38:36,660
quite often in cases where like for the

00:38:34,440 --> 00:38:39,960
for anything that uses a CMD module you

00:38:36,660 --> 00:38:41,940
might want to mock standard out in order

00:38:39,960 --> 00:38:43,410
to perform unit test to verify that you

00:38:41,940 --> 00:38:47,940
know I don't know your opening prompt is

00:38:43,410 --> 00:38:49,670
right or something like that so here I

00:38:47,940 --> 00:38:53,310
have something called print primes and

00:38:49,670 --> 00:38:56,609
it just a prime number prime number

00:38:53,310 --> 00:38:59,160
function and and at the end of it prints

00:38:56,609 --> 00:39:02,339
the prime numbers and I give it some

00:38:59,160 --> 00:39:05,940
input in the test I give it some input

00:39:02,339 --> 00:39:08,609
I create a fake output stream I sign

00:39:05,940 --> 00:39:16,349
that to string IO I set the expected

00:39:08,609 --> 00:39:18,359
output and then I use mocks patch method

00:39:16,349 --> 00:39:20,760
I tell it to patch this standard out I

00:39:18,359 --> 00:39:22,530
tell it to use out stream as the

00:39:20,760 --> 00:39:26,260
replacement first hist standard out and

00:39:22,530 --> 00:39:30,280
I say call that out inside of this block

00:39:26,260 --> 00:39:32,620
and then I do mein print primes and I I

00:39:30,280 --> 00:39:35,140
say that the the actual output from that

00:39:32,620 --> 00:39:36,490
is going to be the get value from the

00:39:35,140 --> 00:39:38,110
string I object that I said is the

00:39:36,490 --> 00:39:40,270
output stream which was used to replace

00:39:38,110 --> 00:39:41,920
this standard out and then I just assert

00:39:40,270 --> 00:39:45,090
that the actual out and the expected

00:39:41,920 --> 00:39:45,090
output are equal

00:39:49,170 --> 00:39:54,340
testing decorated functions this is this

00:39:52,600 --> 00:39:57,040
this can be a minefield I don't want to

00:39:54,340 --> 00:40:00,550
make it seem like it's always easy

00:39:57,040 --> 00:40:04,030
it's not always easy but it doesn't

00:40:00,550 --> 00:40:06,700
necessarily have to be magical this is a

00:40:04,030 --> 00:40:10,450
needs admin proves this exists in the PI

00:40:06,700 --> 00:40:12,010
rabbit module so if it removes a lot of

00:40:10,450 --> 00:40:13,990
duplicate code right because if I'm

00:40:12,010 --> 00:40:16,120
doing something that I know the API

00:40:13,990 --> 00:40:17,590
requires administrative privileges for I

00:40:16,120 --> 00:40:19,420
don't really want to have to code that

00:40:17,590 --> 00:40:21,100
check into every module that every

00:40:19,420 --> 00:40:23,140
method that needs it so I just put a

00:40:21,100 --> 00:40:24,850
decorator on it and then you can see I'm

00:40:23,140 --> 00:40:26,200
using it here for the get users if

00:40:24,850 --> 00:40:27,700
you're doing get users it requires

00:40:26,200 --> 00:40:30,040
administrative privileges so I just put

00:40:27,700 --> 00:40:36,640
that decorator on there but now how do i

00:40:30,040 --> 00:40:38,140
how do I test this and here's one way to

00:40:36,640 --> 00:40:42,700
do it there's there's actually multiple

00:40:38,140 --> 00:40:44,890
ways to do this you can patch API client

00:40:42,700 --> 00:40:48,220
has admin rights call it mock rights and

00:40:44,890 --> 00:40:50,290
when get is called on that mock will

00:40:48,220 --> 00:40:52,090
return false in this case because the

00:40:50,290 --> 00:40:54,250
name of the test is test get users nope

00:40:52,090 --> 00:40:55,420
ribs so it should get some kind of error

00:40:54,250 --> 00:40:58,870
that says you don't have the sufficient

00:40:55,420 --> 00:41:00,970
privileges to perform this operation and

00:40:58,870 --> 00:41:03,730
then I'm assert I'm going to assert at

00:41:00,970 --> 00:41:06,700
the end that when I call self client get

00:41:03,730 --> 00:41:10,300
users that it raises the PI rabid API

00:41:06,700 --> 00:41:12,580
permissions error so I've worked around

00:41:10,300 --> 00:41:14,820
the fact that it's a decorator and

00:41:12,580 --> 00:41:18,630
leaned more on what the decorator does

00:41:14,820 --> 00:41:21,490
and it's that's worked out pretty well

00:41:18,630 --> 00:41:22,840
what I found harder just so you know and

00:41:21,490 --> 00:41:24,420
I don't have I don't have what I

00:41:22,840 --> 00:41:28,570
consider an elegant solution of this a

00:41:24,420 --> 00:41:30,190
big tornado user and I have not yet

00:41:28,570 --> 00:41:34,090
gotten around to figure out an elegant

00:41:30,190 --> 00:41:35,800
solution for testing methods that are

00:41:34,090 --> 00:41:38,710
decorated with tornadoes a synchronous

00:41:35,800 --> 00:41:39,940
decorator so if anybody has a really

00:41:38,710 --> 00:41:44,350
elegant solution for that I would

00:41:39,940 --> 00:41:48,400
love to know about that so we've covered

00:41:44,350 --> 00:41:49,930
what's a unit test why are they cool our

00:41:48,400 --> 00:41:51,460
unit tests all I need they're not all

00:41:49,930 --> 00:41:52,900
you need you need all kinds of tests

00:41:51,460 --> 00:41:54,250
unit tests are part of a complete

00:41:52,900 --> 00:41:56,050
breakfast

00:41:54,250 --> 00:42:00,180
what's mock why is it cool how can I use

00:41:56,050 --> 00:42:03,670
it use talks use nose tests use coverage

00:42:00,180 --> 00:42:05,890
we tested a simple very one module data

00:42:03,670 --> 00:42:09,250
manipulation date manipulation library

00:42:05,890 --> 00:42:10,840
and a REST API client library and and

00:42:09,250 --> 00:42:13,390
some other stuff as well so I hope that

00:42:10,840 --> 00:42:24,210
was useful in moving you forward at this

00:42:13,390 --> 00:42:26,730
point I can take questions is this on

00:42:24,210 --> 00:42:29,770
less of a question more of a

00:42:26,730 --> 00:42:33,100
announcement so Michael for the mock

00:42:29,770 --> 00:42:33,580
creator if you're using Python 3 as you

00:42:33,100 --> 00:42:36,300
should be

00:42:33,580 --> 00:42:38,980
in Python 3.3 we found out in the

00:42:36,300 --> 00:42:40,720
language summit on Wednesday that

00:42:38,980 --> 00:42:45,660
Mikey's not going to be in the standard

00:42:40,720 --> 00:42:45,660
library as unit tests mock in Python 3.3

00:42:51,840 --> 00:42:57,970
I wondered if you had any what's say on

00:42:55,470 --> 00:42:59,500
organizing unit tests is really easy you

00:42:57,970 --> 00:43:02,380
can set up a one-to-one corresponds with

00:42:59,500 --> 00:43:04,840
the unit tests I'm sorry yeah

00:43:02,380 --> 00:43:06,640
organizing unit tests is really easy you

00:43:04,840 --> 00:43:08,710
can set up a one to one with the the

00:43:06,640 --> 00:43:11,980
module under test and the unit test

00:43:08,710 --> 00:43:13,060
module itself do you have any words of

00:43:11,980 --> 00:43:14,500
wisdom on how you organize your

00:43:13,060 --> 00:43:16,600
integration tests because there isn't

00:43:14,500 --> 00:43:19,900
that clear one-to-one correspondence in

00:43:16,600 --> 00:43:21,430
my mind it's an iterative process that

00:43:19,900 --> 00:43:23,080
the question is how do you organize your

00:43:21,430 --> 00:43:26,320
integration test when integration tests

00:43:23,080 --> 00:43:28,420
really don't there isn't a one to one

00:43:26,320 --> 00:43:29,620
thing like you said between you know

00:43:28,420 --> 00:43:30,880
when you're writing unit tests you have

00:43:29,620 --> 00:43:31,990
your unit test and you have the unit

00:43:30,880 --> 00:43:34,120
test module and everything is pretty

00:43:31,990 --> 00:43:35,560
clean when you do integration test where

00:43:34,120 --> 00:43:37,600
you're setting your reality distortion

00:43:35,560 --> 00:43:39,510
field isn't a consistent thing and so

00:43:37,600 --> 00:43:44,500
how do you organize this in a way that

00:43:39,510 --> 00:43:45,850
you say you know I'm testing now I'm you

00:43:44,500 --> 00:43:47,290
know how do you organize it so that you

00:43:45,850 --> 00:43:49,690
say you're setting the barrier here and

00:43:47,290 --> 00:43:51,310
now I'm setting the barrier here and I

00:43:49,690 --> 00:43:53,500
try to do that with different modules

00:43:51,310 --> 00:43:57,580
the reality is that it's an iterative

00:43:53,500 --> 00:43:59,170
process and I say that because I find

00:43:57,580 --> 00:44:00,760
that I think I'm writing unit tests

00:43:59,170 --> 00:44:01,990
tonight and I mistakenly write a very

00:44:00,760 --> 00:44:03,820
low level integration test I've

00:44:01,990 --> 00:44:05,200
forgotten to mock something out and it

00:44:03,820 --> 00:44:07,150
actually becomes an integration test

00:44:05,200 --> 00:44:08,770
then when I go and create my integration

00:44:07,150 --> 00:44:11,650
test I find myself basically writing the

00:44:08,770 --> 00:44:14,140
same test and so I move it over and it's

00:44:11,650 --> 00:44:16,000
iterative and they and then when I want

00:44:14,140 --> 00:44:20,350
to move the distortion field out another

00:44:16,000 --> 00:44:22,180
level in some cases it's actually really

00:44:20,350 --> 00:44:23,560
straightforward right like for something

00:44:22,180 --> 00:44:25,360
like pie rabbit it's actually pretty

00:44:23,560 --> 00:44:29,500
straightforward for something like an

00:44:25,360 --> 00:44:31,750
entire website it is it is hairy and all

00:44:29,500 --> 00:44:35,050
I can tell you is is that what I do is I

00:44:31,750 --> 00:44:36,580
I wind up creating more files and then

00:44:35,050 --> 00:44:38,320
if I can if I can merge them later I

00:44:36,580 --> 00:44:41,710
will if there's if there's a clear line

00:44:38,320 --> 00:44:43,030
if I can define a clear line then all

00:44:41,710 --> 00:44:45,580
then I'll merge them all together but I

00:44:43,030 --> 00:44:47,830
try to and the files to me represent the

00:44:45,580 --> 00:44:50,410
the placement of the of the barrier and

00:44:47,830 --> 00:44:51,730
if I find later that well these two

00:44:50,410 --> 00:44:52,810
things are really placing the barrier in

00:44:51,730 --> 00:44:57,820
the same place I'll put them together

00:44:52,810 --> 00:44:59,710
but it's completely iterative you

00:44:57,820 --> 00:45:02,500
mentioned a bunch of the problems with

00:44:59,710 --> 00:45:04,240
tests but you saw in your module you

00:45:02,500 --> 00:45:06,460
would use to us initially I'm just

00:45:04,240 --> 00:45:08,200
wondering when do you find doc test is

00:45:06,460 --> 00:45:12,100
appropriate like when do you turn them

00:45:08,200 --> 00:45:14,110
because we've basically me to I stuck

00:45:12,100 --> 00:45:17,440
the question is when do you find doc

00:45:14,110 --> 00:45:18,850
tests useful when would you use doc

00:45:17,440 --> 00:45:20,680
tests and and I don't want to knock doc

00:45:18,850 --> 00:45:21,940
tests I mean for what it does it does a

00:45:20,680 --> 00:45:26,710
great job it does what it says it does

00:45:21,940 --> 00:45:29,950
but I I don't use doc tests really at

00:45:26,710 --> 00:45:32,920
all anymore in fact Time Machine was my

00:45:29,950 --> 00:45:35,170
introduction first use and last use of

00:45:32,920 --> 00:45:37,170
doc tests and I'm not I don't want to

00:45:35,170 --> 00:45:41,020
say that to knock doc tests at all

00:45:37,170 --> 00:45:43,660
because it works but for what I'm going

00:45:41,020 --> 00:45:45,220
after in my tests I don't really see a

00:45:43,660 --> 00:45:47,140
place for it I don't count it out I'll

00:45:45,220 --> 00:45:49,120
still consider it if I think that

00:45:47,140 --> 00:45:51,190
there's a use for it I'll use it but I

00:45:49,120 --> 00:45:54,150
can't I just don't foresee that

00:45:51,190 --> 00:45:54,150
happening myself

00:45:56,349 --> 00:46:00,239
don't test the testing bugs

00:46:01,829 --> 00:46:08,710
embedding source in documentation but

00:46:06,279 --> 00:46:10,989
then but then yeah yeah I could see that

00:46:08,710 --> 00:46:13,900
so if you want to embed you know a

00:46:10,989 --> 00:46:15,160
command-line interpreter session inside

00:46:13,900 --> 00:46:18,160
of your documentation for a Sphynx

00:46:15,160 --> 00:46:19,900
output that would be good although I

00:46:18,160 --> 00:46:21,160
would say that a lot of times I'm

00:46:19,900 --> 00:46:23,680
writing code that other code is going to

00:46:21,160 --> 00:46:25,989
use if I was writing end user code I'd

00:46:23,680 --> 00:46:27,609
probably do that but I'm usually writing

00:46:25,989 --> 00:46:29,170
code that other code is going to use in

00:46:27,609 --> 00:46:30,400
which case if I'm gonna embed code in my

00:46:29,170 --> 00:46:34,900
swing stocker mutation I'm probably

00:46:30,400 --> 00:46:36,579
gonna embed actual code so and at that

00:46:34,900 --> 00:46:37,630
point if all you want to do is put the

00:46:36,579 --> 00:46:39,249
interpreter session now I'm just gonna

00:46:37,630 --> 00:46:41,140
cut and paste it in there and it's only

00:46:39,249 --> 00:46:44,859
it's only really a doc test by

00:46:41,140 --> 00:46:46,749
coincidence right that's not a general

00:46:44,859 --> 00:46:49,479
question about it's designing for

00:46:46,749 --> 00:46:51,579
testability so I see a lot of the way

00:46:49,479 --> 00:46:52,930
that testing is written in Python it's

00:46:51,579 --> 00:46:55,809
kind of reliant on the fact that you

00:46:52,930 --> 00:46:57,940
have this clever ability to do monkey

00:46:55,809 --> 00:47:00,670
patching and modification of different

00:46:57,940 --> 00:47:03,519
modules at runtime so I'm curious about

00:47:00,670 --> 00:47:06,489
your thoughts on readability in code or

00:47:03,519 --> 00:47:08,859
some taking approach where you get

00:47:06,489 --> 00:47:10,930
dependencies passed to you versus

00:47:08,859 --> 00:47:12,969
calling out to them explicitly in your

00:47:10,930 --> 00:47:15,190
code and relying on this monkey patching

00:47:12,969 --> 00:47:18,099
at runtime to make the testing mock it

00:47:15,190 --> 00:47:20,650
out so you're talking about dependency

00:47:18,099 --> 00:47:22,150
injections yeah basically okay so my

00:47:20,650 --> 00:47:24,309
thoughts on dependency injection are

00:47:22,150 --> 00:47:28,359
that I actually use it in a lot of cases

00:47:24,309 --> 00:47:31,569
to took a lot of times to remove code

00:47:28,359 --> 00:47:35,380
duplication but it's sort of

00:47:31,569 --> 00:47:38,589
coincidental for to do dependency

00:47:35,380 --> 00:47:40,239
injection on a larger scale in my ex my

00:47:38,589 --> 00:47:41,859
own experience I'm usually working with

00:47:40,239 --> 00:47:43,329
a team of developers and and it's

00:47:41,859 --> 00:47:45,309
something that everybody has to be on

00:47:43,329 --> 00:47:46,390
board for otherwise people are gonna

00:47:45,309 --> 00:47:47,950
have a really difficult time getting

00:47:46,390 --> 00:47:51,579
over the hump and reading your code at

00:47:47,950 --> 00:47:53,289
all so it requires everybody to kind of

00:47:51,579 --> 00:47:54,910
be on board with that because it does

00:47:53,289 --> 00:47:57,789
flip some things upside down and makes

00:47:54,910 --> 00:48:01,599
the code less readable if you're not

00:47:57,789 --> 00:48:02,890
familiar with the technique right and so

00:48:01,599 --> 00:48:04,180
in that case it can make the code less

00:48:02,890 --> 00:48:05,529
readable if you're in an environment

00:48:04,180 --> 00:48:08,259
where dependency injection is not the

00:48:05,529 --> 00:48:10,119
north but for my own code I have

00:48:08,259 --> 00:48:12,249
absolutely no problem using it

00:48:10,119 --> 00:48:14,410
but I admittedly don't use it everywhere

00:48:12,249 --> 00:48:16,329
because it's not the the natural mode my

00:48:14,410 --> 00:48:18,940
brain thinks in until I get to a point

00:48:16,329 --> 00:48:21,130
where it's like this needs to end and

00:48:18,940 --> 00:48:23,230
and then this solution I come up with is

00:48:21,130 --> 00:48:24,970
is so dependency injection to me is a

00:48:23,230 --> 00:48:27,670
solution to a problem it's not something

00:48:24,970 --> 00:48:29,349
that I that I come across in my in my

00:48:27,670 --> 00:48:35,740
top-down design very often unless I'm

00:48:29,349 --> 00:48:37,809
able to foresee the problem that leads

00:48:35,740 --> 00:48:39,279
wonderfully into my comment and I'll

00:48:37,809 --> 00:48:41,349
keep it short because it is a comment

00:48:39,279 --> 00:48:43,359
which is that your problem with

00:48:41,349 --> 00:48:45,700
decorators is because the decorators

00:48:43,359 --> 00:48:48,400
couple things together at effectively

00:48:45,700 --> 00:48:50,349
compile time you can't split them apart

00:48:48,400 --> 00:48:52,299
anymore and the solution to that is

00:48:50,349 --> 00:48:54,400
basically dependency injection right you

00:48:52,299 --> 00:48:56,049
want to define your your method then if

00:48:54,400 --> 00:48:58,059
you can you want to wrap it with the

00:48:56,049 --> 00:48:59,559
decorator in another method where it's

00:48:58,059 --> 00:49:01,359
actually being used rather than wrapping

00:48:59,559 --> 00:49:02,740
it a definition time which means you're

00:49:01,359 --> 00:49:05,079
not using the syntax but you can still

00:49:02,740 --> 00:49:07,539
use the decorators I just know it's a

00:49:05,079 --> 00:49:09,940
common problem so I want to do a lot for

00:49:07,539 --> 00:49:11,740
that yeah I appreciate that so he's

00:49:09,940 --> 00:49:12,730
saying that the the problem that I have

00:49:11,740 --> 00:49:15,279
that I mentioned that I have with

00:49:12,730 --> 00:49:16,569
decorators is that you can't split them

00:49:15,279 --> 00:49:17,920
apart because decorators are something I

00:49:16,569 --> 00:49:19,299
applied at runtime and you can't split

00:49:17,920 --> 00:49:21,849
them apart after runtime you can't

00:49:19,299 --> 00:49:22,989
perform a unit test that way so the

00:49:21,849 --> 00:49:25,539
solution of that problem is actually

00:49:22,989 --> 00:49:26,890
dependency injection which is actually a

00:49:25,539 --> 00:49:29,400
really good point and I can already

00:49:26,890 --> 00:49:33,119
imagine places where I might be able to

00:49:29,400 --> 00:49:33,119

YouTube URL: https://www.youtube.com/watch?v=hvPYuqzTPIk


