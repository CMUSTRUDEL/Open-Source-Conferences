Title: Make Sure Your Programs Crash
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Moshe Zadka
With Python, segmentation faults and the like simply don't happen -- programs do not crash. However, the world is a messy, chaotic place. What happens when your programs crash? I will talk about how to make sure that your application surv
Captions: 
	00:00:00,000 --> 00:00:06,240
good afternoon it's my pleasure to

00:00:02,790 --> 00:00:08,490
introduce Moshe idea from VMware will be

00:00:06,240 --> 00:00:13,049
speaking on make sure your programs

00:00:08,490 --> 00:00:15,330
crash this is a 30 minute talk thank you

00:00:13,049 --> 00:00:16,830
so yeah I'm going to talk to you about

00:00:15,330 --> 00:00:18,900
why you should make sure your

00:00:16,830 --> 00:00:22,320
applications crash and hopefully after

00:00:18,900 --> 00:00:24,269
the crash recover from the crash that's

00:00:22,320 --> 00:00:27,660
even more awesome so start with telling

00:00:24,269 --> 00:00:32,250
you a story so I was working for a

00:00:27,660 --> 00:00:33,930
startup that was selling appliances my

00:00:32,250 --> 00:00:35,460
customer was seeing problems this was a

00:00:33,930 --> 00:00:37,860
keen of customer that they basically

00:00:35,460 --> 00:00:40,649
just sent me out to figure out what what

00:00:37,860 --> 00:00:42,870
what the problems were so as I'm logging

00:00:40,649 --> 00:00:46,379
into my machine to figure out what's the

00:00:42,870 --> 00:00:48,719
problem other unrelated problems they

00:00:46,379 --> 00:00:50,100
come every like half of the components

00:00:48,719 --> 00:00:51,899
were basically restarting every few

00:00:50,100 --> 00:00:53,850
minutes the nice thing is these were

00:00:51,899 --> 00:00:55,530
other problems meaning these were not

00:00:53,850 --> 00:00:57,660
the problems if customer complained

00:00:55,530 --> 00:01:00,090
about right even those things were

00:00:57,660 --> 00:01:02,010
crashing all the time and kind of the

00:01:00,090 --> 00:01:03,570
the reason I'm giving this talk is to

00:01:02,010 --> 00:01:06,299
show you how you can do some that

00:01:03,570 --> 00:01:08,040
justice awesome so basically stuff can

00:01:06,299 --> 00:01:11,159
we start all the time and tough can

00:01:08,040 --> 00:01:15,390
crash and nobody will see it and that's

00:01:11,159 --> 00:01:17,159
good enough for me so kind of the common

00:01:15,390 --> 00:01:19,799
stock is at Python doesn't crash right

00:01:17,159 --> 00:01:21,960
you have memory management so you don't

00:01:19,799 --> 00:01:24,659
accidentally double free or all kind of

00:01:21,960 --> 00:01:27,299
stepping on feet memories you don't have

00:01:24,659 --> 00:01:30,630
director pointer arithmetic so a lot of

00:01:27,299 --> 00:01:33,810
the common cases of crashes supposedly

00:01:30,630 --> 00:01:35,490
are like magically gone from Python well

00:01:33,810 --> 00:01:37,439
that's kind of like a nice you know

00:01:35,490 --> 00:01:39,270
fairy tale to tell your kids you know

00:01:37,439 --> 00:01:41,549
before you put them to sleep in bed but

00:01:39,270 --> 00:01:44,549
you know it's kind of a lie uh he don't

00:01:41,549 --> 00:01:47,670
everything crashes and burns right The

00:01:44,549 --> 00:01:50,970
Seeker has bugs these three modules have

00:01:47,670 --> 00:01:52,530
bugs it's kind of fun if you ever wanted

00:01:50,970 --> 00:01:54,329
like actually go in the Python bug

00:01:52,530 --> 00:01:56,159
tracker and see how many like

00:01:54,329 --> 00:01:57,960
potentially crashing bugs are you in

00:01:56,159 --> 00:02:00,149
your interpreter you will sleep less

00:01:57,960 --> 00:02:03,750
less soundly at night but possibly no

00:02:00,149 --> 00:02:05,729
more exception can go and trapped it's

00:02:03,750 --> 00:02:07,320
not always a good idea to drop all the

00:02:05,729 --> 00:02:10,110
exception because you know out of memory

00:02:07,320 --> 00:02:12,750
is also an exception not a good idea to

00:02:10,110 --> 00:02:13,410
trap it your code can have infinite

00:02:12,750 --> 00:02:18,240
loops

00:02:13,410 --> 00:02:20,400
mind us all right so that's not

00:02:18,240 --> 00:02:23,550
technically a crash but your process

00:02:20,400 --> 00:02:25,260
hanks who cares you're you can do a

00:02:23,550 --> 00:02:26,940
blocking code without noticing it

00:02:25,260 --> 00:02:28,290
because your socket was not in the land

00:02:26,940 --> 00:02:31,050
blocking mode that you thought it was

00:02:28,290 --> 00:02:33,090
and even though select it said that it

00:02:31,050 --> 00:02:36,030
could be read from it could not that's a

00:02:33,090 --> 00:02:39,000
lot of fun thread can deadlock and all

00:02:36,030 --> 00:02:40,800
it takes is one simple trying to lock

00:02:39,000 --> 00:02:42,120
two things and you're not of course

00:02:40,800 --> 00:02:44,460
aware that you're lacking two things

00:02:42,120 --> 00:02:49,560
because the locks are hidden far deep in

00:02:44,460 --> 00:02:51,870
some function and yeah and the best part

00:02:49,560 --> 00:02:54,030
that happens especially when you do trap

00:02:51,870 --> 00:02:56,910
exceptions is you get basically to an

00:02:54,030 --> 00:02:58,740
inconsistent residence state what I mean

00:02:56,910 --> 00:03:00,180
you draft an exception you thought you

00:02:58,740 --> 00:03:02,250
handled it but you didn't handle it

00:03:00,180 --> 00:03:03,720
properly which means now your problem is

00:03:02,250 --> 00:03:05,490
in the synchro sisters say that's the

00:03:03,720 --> 00:03:07,710
most part because your program looks

00:03:05,490 --> 00:03:10,920
like it's running right it looks fine

00:03:07,710 --> 00:03:13,290
except it spews out errors all the time

00:03:10,920 --> 00:03:15,600
that's you know even worse than a crash

00:03:13,290 --> 00:03:18,240
because you don't see it it's yes and

00:03:15,600 --> 00:03:19,800
like my point is these things happen

00:03:18,240 --> 00:03:21,480
these things you know happened to my

00:03:19,800 --> 00:03:23,370
program and possibly even though you're

00:03:21,480 --> 00:03:26,970
better programmers and i am sure these

00:03:23,370 --> 00:03:28,440
things might happen to your programs so

00:03:26,970 --> 00:03:30,630
the important thing is you have to

00:03:28,440 --> 00:03:31,890
recover from the crashes right so this

00:03:30,630 --> 00:03:33,870
is a quote so more like an old IBM

00:03:31,890 --> 00:03:35,700
manual if you actually read later the

00:03:33,870 --> 00:03:37,500
doc note they have like you know full

00:03:35,700 --> 00:03:40,080
references this is not a cool thing made

00:03:37,500 --> 00:03:41,970
up so basically the idea that you always

00:03:40,080 --> 00:03:44,640
have a recovery routine so whenever

00:03:41,970 --> 00:03:47,220
something fails no matter how badly you

00:03:44,640 --> 00:03:49,560
attempt to automatically restart it and

00:03:47,220 --> 00:03:53,070
if you do it right then any bug is the

00:03:49,560 --> 00:03:55,350
user sees is two bugs the bucket costs

00:03:53,070 --> 00:03:58,140
the original crash and the failure to

00:03:55,350 --> 00:04:00,330
recover from that crash so when you

00:03:58,140 --> 00:04:02,760
treat it like like we actually tweeted

00:04:00,330 --> 00:04:05,070
that way now in our bug system when we

00:04:02,760 --> 00:04:07,170
got the crashbug form a customer that

00:04:05,070 --> 00:04:08,910
bug actually turned into two bags the

00:04:07,170 --> 00:04:10,739
real bug that we try to analyze and

00:04:08,910 --> 00:04:12,810
obviously prevent the crash and the

00:04:10,739 --> 00:04:15,120
bucket why did the customer see that

00:04:12,810 --> 00:04:16,200
crash the more lot of bug that came and

00:04:15,120 --> 00:04:17,669
talked about system just because we

00:04:16,200 --> 00:04:19,680
downloaded the logs and so that was a

00:04:17,669 --> 00:04:21,570
crash that you know was recovered from

00:04:19,680 --> 00:04:25,350
silently and the customer i never knew

00:04:21,570 --> 00:04:27,120
better so there will the biggest problem

00:04:25,350 --> 00:04:29,070
when you crash

00:04:27,120 --> 00:04:31,229
is that whatever non-resident state

00:04:29,070 --> 00:04:34,050
meaning whatever storage you have will

00:04:31,229 --> 00:04:35,790
be from an arbitrary state right that's

00:04:34,050 --> 00:04:38,639
especially fun because you can't assume

00:04:35,790 --> 00:04:40,470
any kind of reasonable like get to a

00:04:38,639 --> 00:04:43,949
consistent state process has been done

00:04:40,470 --> 00:04:45,090
right the UM killer in Linux is a lot of

00:04:43,949 --> 00:04:46,530
fun because they don't kill Achilles

00:04:45,090 --> 00:04:48,960
like you know should your processing the

00:04:46,530 --> 00:04:51,419
head that's it like you know it can

00:04:48,960 --> 00:04:53,130
easily get to that state so you always

00:04:51,419 --> 00:04:56,400
want to assume that if your program

00:04:53,130 --> 00:04:58,979
crashed the storage can be an

00:04:56,400 --> 00:05:00,720
undetermined state that means that if

00:04:58,979 --> 00:05:02,760
you're not very careful about writing

00:05:00,720 --> 00:05:04,590
out data you're like writing to two

00:05:02,760 --> 00:05:06,419
places and you're not sure what happens

00:05:04,590 --> 00:05:09,270
first you might be actually in a place

00:05:06,419 --> 00:05:10,949
where you can't recover is this the

00:05:09,270 --> 00:05:12,780
right one or is this the right one I

00:05:10,949 --> 00:05:14,520
have no idea right what is this like you

00:05:12,780 --> 00:05:16,830
know two counters and they have to

00:05:14,520 --> 00:05:18,630
maintain some sort of consistency but a

00:05:16,830 --> 00:05:20,820
non-trivial consistency which is right I

00:05:18,630 --> 00:05:24,030
know the design consistent but you know

00:05:20,820 --> 00:05:25,500
possibly one of them should be right so

00:05:24,030 --> 00:05:27,660
the idea is that you always want to

00:05:25,500 --> 00:05:30,240
maintain your storage maybe not in a

00:05:27,660 --> 00:05:32,430
consistent state but neither state where

00:05:30,240 --> 00:05:34,710
consistency could be recovered form

00:05:32,430 --> 00:05:36,870
there's a very important difference and

00:05:34,710 --> 00:05:38,580
maybe i'll get to like show you examples

00:05:36,870 --> 00:05:42,570
are not sure that kind of depends on you

00:05:38,580 --> 00:05:44,669
know how long it will run so the easiest

00:05:42,570 --> 00:05:47,250
way to avoid ecosystem storage is to

00:05:44,669 --> 00:05:48,870
avoid storage all together which you can

00:05:47,250 --> 00:05:51,410
do a lot of the time that's like awesome

00:05:48,870 --> 00:05:53,910
right if you if you're like just

00:05:51,410 --> 00:05:55,229
something that analyzes resident states

00:05:53,910 --> 00:05:57,150
and just you know if you crash and

00:05:55,229 --> 00:05:59,760
startup just start up you know it really

00:05:57,150 --> 00:06:02,070
fine you know if you need some data to

00:05:59,760 --> 00:06:05,130
perform better just keep it in a cache

00:06:02,070 --> 00:06:06,510
caches are easy because at worst you can

00:06:05,130 --> 00:06:09,840
do like the stupidest thing which is

00:06:06,510 --> 00:06:12,570
like marks mark cash inconsistent do

00:06:09,840 --> 00:06:14,520
updates to cash mark cash consistent if

00:06:12,570 --> 00:06:17,760
you actually make sure that by the time

00:06:14,520 --> 00:06:20,430
every operation returns to you it has

00:06:17,760 --> 00:06:22,050
actually done which is unclear if you do

00:06:20,430 --> 00:06:24,900
it on the file system used to you have

00:06:22,050 --> 00:06:26,550
to use like the super F / method that's

00:06:24,900 --> 00:06:28,500
like different between operating systems

00:06:26,550 --> 00:06:30,570
but if you actually manage to get all

00:06:28,500 --> 00:06:34,050
this done then it's fine if you see that

00:06:30,570 --> 00:06:36,240
cash marked inconsistent you just dump

00:06:34,050 --> 00:06:38,550
the cash right so it could be that

00:06:36,240 --> 00:06:40,800
somehow you did manage to finish it and

00:06:38,550 --> 00:06:42,840
didn't get to write the flag cash is

00:06:40,800 --> 00:06:46,259
but that's fine so in some cases you

00:06:42,840 --> 00:06:47,849
like work a little bit harder but that's

00:06:46,259 --> 00:06:49,560
kind of the ideal they deal to avoid

00:06:47,849 --> 00:06:51,449
storage unfortunately in real life

00:06:49,560 --> 00:06:53,159
apparently people want to programs to

00:06:51,449 --> 00:06:58,129
actually have a lasting effect on like

00:06:53,159 --> 00:07:00,599
the universe so then the easiest like

00:06:58,129 --> 00:07:02,789
solution but people usually go to is

00:07:00,599 --> 00:07:04,500
transactional data bases and there are

00:07:02,789 --> 00:07:06,000
pretty good solution why does the reason

00:07:04,500 --> 00:07:08,690
everybody goes to that solution that's a

00:07:06,000 --> 00:07:12,419
very good solution databases have like

00:07:08,690 --> 00:07:15,030
30 40 years by now years of experience

00:07:12,419 --> 00:07:17,849
to actually like make sure that their

00:07:15,030 --> 00:07:19,440
state is somehow recoverable right like

00:07:17,849 --> 00:07:21,659
you know that's kind of where they make

00:07:19,440 --> 00:07:23,729
money off that that's why they have like

00:07:21,659 --> 00:07:27,360
multiple databases caching each other

00:07:23,729 --> 00:07:30,120
and all kind of crazy stuff like that so

00:07:27,360 --> 00:07:31,800
if used transactions that um that will

00:07:30,120 --> 00:07:33,840
just work and we'll sort of magically

00:07:31,800 --> 00:07:36,180
maintain consistency that's the awesome

00:07:33,840 --> 00:07:39,389
part about databases if you're not using

00:07:36,180 --> 00:07:42,090
one of those like you know $500,000

00:07:39,389 --> 00:07:44,669
databases however much they cost I never

00:07:42,090 --> 00:07:47,389
bought one but you know a company's buy

00:07:44,669 --> 00:07:51,180
them I've idea how much it costs a lot

00:07:47,389 --> 00:07:53,789
so the databases can crash and quite

00:07:51,180 --> 00:07:55,469
possibly your my sequel of postgres has

00:07:53,789 --> 00:07:57,539
never been through that kind of rigorous

00:07:55,469 --> 00:08:01,830
testing right you have no reason to

00:07:57,539 --> 00:08:04,139
assume that somebody actually made sure

00:08:01,830 --> 00:08:05,669
that every tiny bit of post quest has

00:08:04,139 --> 00:08:07,560
been gone through so like you maybe it

00:08:05,669 --> 00:08:10,050
can get into like an e cosÃ¬ to state if

00:08:07,560 --> 00:08:11,940
your if your file system is set up in a

00:08:10,050 --> 00:08:13,349
weird way or stuff like that so you want

00:08:11,940 --> 00:08:15,539
to make sure that you kind of account

00:08:13,349 --> 00:08:18,479
for is there like not being able to

00:08:15,539 --> 00:08:20,190
recover from from their cash that ways

00:08:18,479 --> 00:08:22,469
around it like if you may take multiple

00:08:20,190 --> 00:08:23,729
copies and failover you can do that you

00:08:22,469 --> 00:08:26,909
just want to make sure that if you have

00:08:23,729 --> 00:08:28,650
a crash recovery algorithm that depends

00:08:26,909 --> 00:08:30,719
on the database being inconsistent State

00:08:28,650 --> 00:08:33,839
you have a plan for what to do is a

00:08:30,719 --> 00:08:35,969
database is not inconsistent State even

00:08:33,839 --> 00:08:37,740
if that plan is just like calling the

00:08:35,969 --> 00:08:38,909
database vendor to whom you paid five

00:08:37,740 --> 00:08:41,010
hundred thousand dollars in complain

00:08:38,909 --> 00:08:46,529
that that's a valid plan but you want to

00:08:41,010 --> 00:08:48,540
make sure that you have some plan so if

00:08:46,529 --> 00:08:51,209
you don't want to use like all kinds of

00:08:48,540 --> 00:08:53,430
funky database stuff you can easily sort

00:08:51,209 --> 00:08:54,209
of all your own and basically the trick

00:08:53,430 --> 00:08:56,309
of all your

00:08:54,209 --> 00:08:58,050
all your roll your own schemes that I

00:08:56,309 --> 00:09:00,629
will show it sort of one but there's

00:08:58,050 --> 00:09:02,399
like gazillions of those depending on

00:09:00,629 --> 00:09:04,499
exactly what you need to maintain and

00:09:02,399 --> 00:09:07,800
I've written a few gazillions of those i

00:09:04,499 --> 00:09:10,319
think by now they all count to like the

00:09:07,800 --> 00:09:11,850
fact that the operating system moderate

00:09:10,319 --> 00:09:13,980
moderate operating systems are pretty

00:09:11,850 --> 00:09:17,279
good at crash recovery like you know if

00:09:13,980 --> 00:09:19,170
you use linux with 63 or i guess you

00:09:17,279 --> 00:09:21,629
know windows NT with whatever you know

00:09:19,170 --> 00:09:23,579
aunty things they have they can actually

00:09:21,629 --> 00:09:25,679
maintain reasonable enough state on the

00:09:23,579 --> 00:09:27,660
disk that no matter how hard your

00:09:25,679 --> 00:09:30,929
machine has crashed if you if you start

00:09:27,660 --> 00:09:34,199
back up your your file system is in a

00:09:30,929 --> 00:09:36,029
reasonable state and so the big atomic

00:09:34,199 --> 00:09:38,939
operation that you can layer like whole

00:09:36,029 --> 00:09:41,249
algorithms on top of if file rename if

00:09:38,939 --> 00:09:44,550
you do a file rename either the rename

00:09:41,249 --> 00:09:46,709
has has not been done or it has been

00:09:44,550 --> 00:09:48,689
done there's no intermediate state of

00:09:46,709 --> 00:09:50,999
the directory of the file we named half

00:09:48,689 --> 00:09:52,499
done right that's like opposed to like

00:09:50,999 --> 00:09:54,779
file copies and all kind of other

00:09:52,499 --> 00:09:57,540
operations those are not atomic but fine

00:09:54,779 --> 00:09:59,429
winnings are atomic and especially on

00:09:57,540 --> 00:10:01,619
unix based systems but even on windows

00:09:59,429 --> 00:10:04,920
based systems you can do like really

00:10:01,619 --> 00:10:06,360
awesome things so the example the first

00:10:04,920 --> 00:10:09,360
code example i'm going to show you how

00:10:06,360 --> 00:10:13,499
to do a counter with that with that

00:10:09,360 --> 00:10:15,929
version and i'll note that this example

00:10:13,499 --> 00:10:18,299
then work on windows if you get later

00:10:15,929 --> 00:10:20,759
the doc notes in the bonus slides which

00:10:18,299 --> 00:10:23,040
i might be able to get to i show how to

00:10:20,759 --> 00:10:25,199
do it on windows but this is like the

00:10:23,040 --> 00:10:27,929
simplest code that shows you how to do

00:10:25,199 --> 00:10:29,850
atomic operations right so you'll notice

00:10:27,929 --> 00:10:32,549
that i increment the counter in memory

00:10:29,850 --> 00:10:36,420
and kill that it's fine until i actually

00:10:32,549 --> 00:10:40,110
like finish writing the team p file also

00:10:36,420 --> 00:10:41,970
everything is fine and then if i do and

00:10:40,110 --> 00:10:44,069
then the last step is basically we name

00:10:41,970 --> 00:10:46,470
so either the rename has been completed

00:10:44,069 --> 00:10:48,119
and therefore i have countered at 60

00:10:46,470 --> 00:10:50,399
with like you know five instead of four

00:10:48,119 --> 00:10:52,559
or the winning has not been completed at

00:10:50,399 --> 00:10:56,160
the time of the crash you'll notice it

00:10:52,559 --> 00:10:58,559
if I don't like export out the counter

00:10:56,160 --> 00:11:01,860
make too many like tough promises on the

00:10:58,559 --> 00:11:04,139
counter I don't really have to commit I

00:11:01,860 --> 00:11:06,870
don't really have to do any kind of F /

00:11:04,139 --> 00:11:08,499
or magical things like that right worst

00:11:06,870 --> 00:11:09,669
case on the day

00:11:08,499 --> 00:11:11,079
because the counter is still four

00:11:09,669 --> 00:11:14,409
instead of five when I crashed my

00:11:11,079 --> 00:11:16,149
thought was five if I do commit outside

00:11:14,409 --> 00:11:18,039
if ice tell people you know this counter

00:11:16,149 --> 00:11:20,049
will only increment even if I crash and

00:11:18,039 --> 00:11:23,439
we start and I need to do like more

00:11:20,049 --> 00:11:26,259
things here but this this is kind of a

00:11:23,439 --> 00:11:29,589
simple code to show how you just can

00:11:26,259 --> 00:11:31,959
roll your own like you know completely

00:11:29,589 --> 00:11:33,639
recoverable operation you notice that if

00:11:31,959 --> 00:11:35,829
I crash there might be like a spurious

00:11:33,639 --> 00:11:38,349
temp file but that's fine the next time

00:11:35,829 --> 00:11:40,089
i increment the counter this temp file

00:11:38,349 --> 00:11:42,039
will be gone so unless you really really

00:11:40,089 --> 00:11:43,539
are like you know care about cleanliness

00:11:42,039 --> 00:11:45,669
its program start up you don't need to

00:11:43,539 --> 00:11:47,919
write any recovery code which is a fine

00:11:45,669 --> 00:11:53,829
the fun the fun part about about doing

00:11:47,919 --> 00:11:56,829
it this way so sometimes this method of

00:11:53,829 --> 00:11:59,199
like maintaining the code in all ways in

00:11:56,829 --> 00:12:01,869
kind of an always consistent way doesn't

00:11:59,199 --> 00:12:05,019
allow you to also maintain it in inner

00:12:01,869 --> 00:12:08,339
within an efficient way for example if

00:12:05,019 --> 00:12:11,169
you use something like I know my sequel

00:12:08,339 --> 00:12:12,959
then I I don't personally don't trust my

00:12:11,169 --> 00:12:15,039
sick well maybe it's just like sort of

00:12:12,959 --> 00:12:16,509
the bed rapid glad they don't pass my

00:12:15,039 --> 00:12:18,220
sequel that if it crash I can always

00:12:16,509 --> 00:12:19,659
recover my data for me but it's

00:12:18,220 --> 00:12:21,009
certainly very fast right that's like

00:12:19,659 --> 00:12:23,499
what they will save it's really fast

00:12:21,009 --> 00:12:25,449
like so maybe I do enjoy the speed of

00:12:23,499 --> 00:12:27,369
bicycle but they don't mind enjoys a

00:12:25,449 --> 00:12:29,529
chance of losing all my data in a bad

00:12:27,369 --> 00:12:31,449
crash cycle is mix and match right they

00:12:29,529 --> 00:12:32,949
can always have an efficient cash like

00:12:31,449 --> 00:12:34,479
my sickle treatises the cash we slightly

00:12:32,949 --> 00:12:36,639
algorithms only for Mike Marquez

00:12:34,479 --> 00:12:38,499
ecosystem are consistent and then have a

00:12:36,639 --> 00:12:40,929
reliable master right on top of this

00:12:38,499 --> 00:12:42,699
file rename I can you know build like an

00:12:40,929 --> 00:12:44,559
like an interesting key value store

00:12:42,699 --> 00:12:46,239
again if you see the bonus slide or if

00:12:44,559 --> 00:12:48,699
you see my talk notes I have like any

00:12:46,239 --> 00:12:50,919
complete implementation of the key value

00:12:48,699 --> 00:12:52,959
store so basically I mean technically

00:12:50,919 --> 00:12:55,539
value store enemy take my stuff in my

00:12:52,959 --> 00:12:57,369
sequel in parallel if it's start time I

00:12:55,539 --> 00:12:59,619
noticed that the cash is inefficient I

00:12:57,369 --> 00:13:01,239
will build it of course it's slow then

00:12:59,619 --> 00:13:03,339
you have a bunch of tricks like I want

00:13:01,239 --> 00:13:05,109
to be partially available while while

00:13:03,339 --> 00:13:06,519
you start and stuff like that I'm not

00:13:05,109 --> 00:13:09,879
going to get into all of these details

00:13:06,519 --> 00:13:11,889
right now but that's kind of a good kind

00:13:09,879 --> 00:13:13,809
of soft model for the case where you

00:13:11,889 --> 00:13:15,999
actually want like you know really fast

00:13:13,809 --> 00:13:17,859
select so really fast querying ability

00:13:15,999 --> 00:13:19,959
and the thing that gives you the really

00:13:17,859 --> 00:13:22,089
fast wearing ability just doesn't give

00:13:19,959 --> 00:13:24,009
you the reliability that you feel you're

00:13:22,089 --> 00:13:30,420
profitable with to like you know commit

00:13:24,009 --> 00:13:32,920
that you'll never lose the data so the

00:13:30,420 --> 00:13:34,480
the other thing I recommend is that once

00:13:32,920 --> 00:13:37,600
you do all of that once you make sure

00:13:34,480 --> 00:13:39,249
that at any point in your code issues as

00:13:37,600 --> 00:13:41,139
an um killer in Linux and each at your

00:13:39,249 --> 00:13:43,959
program in the head or is it was a power

00:13:41,139 --> 00:13:45,610
outage and there was no ordinary shut

00:13:43,959 --> 00:13:47,769
down the new program can still maintain

00:13:45,610 --> 00:13:49,209
don't write any code like you know

00:13:47,769 --> 00:13:51,759
usually all kinds of frameworks have

00:13:49,209 --> 00:13:54,009
like place to cook to write code for the

00:13:51,759 --> 00:13:56,470
shutdown's part or I didn't twisted it's

00:13:54,009 --> 00:13:59,800
like after shutdown in just core Python

00:13:56,470 --> 00:14:02,110
its sister at exit stuff like that don't

00:13:59,800 --> 00:14:03,819
put code there or you know if you really

00:14:02,110 --> 00:14:05,490
need to put codes or put like sort of

00:14:03,819 --> 00:14:08,139
unimportant cause they're like log

00:14:05,490 --> 00:14:09,220
statistics if you have to do without the

00:14:08,139 --> 00:14:11,379
statistics you'll do without the

00:14:09,220 --> 00:14:13,089
statistics but don't put any kind of

00:14:11,379 --> 00:14:15,430
like you know nice shut down make sure

00:14:13,089 --> 00:14:17,949
my data is consistent your data should

00:14:15,430 --> 00:14:19,300
always be consistent enough and if you

00:14:17,949 --> 00:14:22,629
do that that means that you basically

00:14:19,300 --> 00:14:25,389
crashing testing right every time that

00:14:22,629 --> 00:14:27,999
QA shuts down your program in the nice

00:14:25,389 --> 00:14:29,589
orderly way they basically crash it

00:14:27,999 --> 00:14:32,829
because you do not have shutdown code

00:14:29,589 --> 00:14:35,170
which means that any kind of unfortunate

00:14:32,829 --> 00:14:37,449
assumption you made that like you know

00:14:35,170 --> 00:14:39,399
this will be consistent will actually be

00:14:37,449 --> 00:14:41,679
caught of course then you want to train

00:14:39,399 --> 00:14:43,569
q8 like shut down your program at the

00:14:41,679 --> 00:14:45,279
most unfortunate moment so you will

00:14:43,569 --> 00:14:47,139
catch all these exceptions right this is

00:14:45,279 --> 00:14:49,360
and then you know make sure that you

00:14:47,139 --> 00:14:51,850
know you have a reasonable you know unit

00:14:49,360 --> 00:14:53,949
testing system that crashes is a code at

00:14:51,850 --> 00:14:56,290
least you know via all kind of like mock

00:14:53,949 --> 00:14:59,759
tweaks it's like the most horrible parts

00:14:56,290 --> 00:14:59,759
to make sure that you can always recover

00:14:59,970 --> 00:15:07,480
hmm I'm going a little bit faster than I

00:15:02,470 --> 00:15:09,249
thought I'm very happy okay so um the

00:15:07,480 --> 00:15:10,660
next part is let's assume that you've

00:15:09,249 --> 00:15:13,209
done all that let's assume that you've

00:15:10,660 --> 00:15:15,100
sort of been you know a good little boys

00:15:13,209 --> 00:15:17,829
and girls and made sure that your data

00:15:15,100 --> 00:15:20,620
is somehow always recoverable this means

00:15:17,829 --> 00:15:23,319
that if there is a problem you can just

00:15:20,620 --> 00:15:25,629
restart which means from from this point

00:15:23,319 --> 00:15:27,519
on it's not a matter of whether you can

00:15:25,629 --> 00:15:30,279
recover it's a matter of like you know

00:15:27,519 --> 00:15:31,779
number of nines if you will right if you

00:15:30,279 --> 00:15:34,269
think right if you think of it in terms

00:15:31,779 --> 00:15:35,750
of if you have a certain amount of

00:15:34,269 --> 00:15:42,920
crashes per day

00:15:35,750 --> 00:15:45,650
then the I think five minus the log 10

00:15:42,920 --> 00:15:48,020
of the seconds it takes you to wake up

00:15:45,650 --> 00:15:51,200
times the amount of crashes is basically

00:15:48,020 --> 00:15:53,740
the amount of knives you have they lose

00:15:51,200 --> 00:15:56,210
anyone with a mess do it in your heads

00:15:53,740 --> 00:15:58,070
anyway but but this is this is really

00:15:56,210 --> 00:15:59,450
the point right the faster you are

00:15:58,070 --> 00:16:01,610
obviously like you know it's better if

00:15:59,450 --> 00:16:03,980
your code crashes rarely alright this is

00:16:01,610 --> 00:16:06,680
kind of ideally you you try to like in a

00:16:03,980 --> 00:16:09,110
white coat the you know world crash all

00:16:06,680 --> 00:16:10,640
the time but given that you had a crash

00:16:09,110 --> 00:16:12,710
you want to restart as fast as possible

00:16:10,640 --> 00:16:15,110
this is what gets it to like the high

00:16:12,710 --> 00:16:17,240
nines what gets you to the Heinz is not

00:16:15,110 --> 00:16:18,830
necessarily recover like like never

00:16:17,240 --> 00:16:20,240
crashing what gets you is really really

00:16:18,830 --> 00:16:25,580
fast recovery so you want to make sure

00:16:20,240 --> 00:16:26,900
that you recover fast so there are two

00:16:25,580 --> 00:16:28,730
ways you can sort of improve your

00:16:26,900 --> 00:16:30,590
availability improve like the number of

00:16:28,730 --> 00:16:32,990
ninth which is you can limit the impact

00:16:30,590 --> 00:16:35,630
of any single crash right so maybe if a

00:16:32,990 --> 00:16:37,520
crash happens you do not go to zero

00:16:35,630 --> 00:16:39,500
percent availability you go to eighty

00:16:37,520 --> 00:16:41,780
percent availability again that kind of

00:16:39,500 --> 00:16:43,490
helps you on the lines you want to

00:16:41,780 --> 00:16:45,830
detect it fast you wanted to take the

00:16:43,490 --> 00:16:48,110
crash as soon as it happened and like

00:16:45,830 --> 00:16:50,540
you know obviously trade-offs here you

00:16:48,110 --> 00:16:54,020
don't want to detect a nun crash which

00:16:50,540 --> 00:16:56,540
is sometimes tricky anyone to improve

00:16:54,020 --> 00:17:00,680
your startup time and basically the

00:16:56,540 --> 00:17:05,390
ideas try to do things on all three on

00:17:00,680 --> 00:17:07,670
all three four fonts so two to limit

00:17:05,390 --> 00:17:09,439
impact basically want to space it into

00:17:07,670 --> 00:17:14,000
multiple processes right if you seem

00:17:09,439 --> 00:17:16,040
that the basic unit of restart ability

00:17:14,000 --> 00:17:17,449
is a process which you do want to assume

00:17:16,040 --> 00:17:19,760
because you should never shut down

00:17:17,449 --> 00:17:21,500
threads because that leads your

00:17:19,760 --> 00:17:23,180
programming even worse consistent state

00:17:21,500 --> 00:17:25,550
will probably lead to restart later just

00:17:23,180 --> 00:17:28,130
do the four three so now then you

00:17:25,550 --> 00:17:30,080
basically want to make sure that you

00:17:28,130 --> 00:17:31,340
that you have sort of redundancy in the

00:17:30,080 --> 00:17:33,050
processes and there are two ways to

00:17:31,340 --> 00:17:35,330
achieve that you can achieve it via

00:17:33,050 --> 00:17:36,560
vertical splitting the example you

00:17:35,330 --> 00:17:39,410
should probably all have in your head

00:17:36,560 --> 00:17:42,200
right now is Apache right Apache one's

00:17:39,410 --> 00:17:44,030
multiple children if one dies it

00:17:42,200 --> 00:17:45,710
actually has kind of zero impact and

00:17:44,030 --> 00:17:47,900
availability just means that the other

00:17:45,710 --> 00:17:49,370
ones won't the animals will have take to

00:17:47,900 --> 00:17:51,530
take care of more than their share

00:17:49,370 --> 00:17:53,570
work and eventually Apache will spin up

00:17:51,530 --> 00:17:56,750
in other and like everything will be

00:17:53,570 --> 00:17:58,880
hunky-dory so that's kind of vertical

00:17:56,750 --> 00:18:01,280
splitting it works well for the kind

00:17:58,880 --> 00:18:03,170
that vertical splitting is good at which

00:18:01,280 --> 00:18:04,790
is you know luckily the kind of thing

00:18:03,170 --> 00:18:07,340
that web servers are good at which is

00:18:04,790 --> 00:18:09,620
why Apache does it a lot right which is

00:18:07,340 --> 00:18:11,390
like you don't need to communicate a lot

00:18:09,620 --> 00:18:13,880
between different execution streams

00:18:11,390 --> 00:18:16,010
right if you have a single HTTP request

00:18:13,880 --> 00:18:18,920
it's perfectly reasonable to assume that

00:18:16,010 --> 00:18:21,530
it will not have to touch any other HTTP

00:18:18,920 --> 00:18:23,900
requests while being served right if you

00:18:21,530 --> 00:18:26,330
have sort of share data you have kind of

00:18:23,900 --> 00:18:28,309
a back-end you know my sequel or in like

00:18:26,330 --> 00:18:31,250
an message queue or whatever it is you

00:18:28,309 --> 00:18:33,440
have but ssf they probably shouldn't

00:18:31,250 --> 00:18:34,970
communicate too much so that works well

00:18:33,440 --> 00:18:39,790
for the case where vertical splitting

00:18:34,970 --> 00:18:42,440
makes sense the other kind of style that

00:18:39,790 --> 00:18:44,570
usually is in sort of in tandem with

00:18:42,440 --> 00:18:47,600
vertical splitting but sometimes is used

00:18:44,570 --> 00:18:50,360
purely on its own sorry for more

00:18:47,600 --> 00:18:52,790
interdependent service is horizontal

00:18:50,360 --> 00:18:54,530
splitting right so if the vertical

00:18:52,790 --> 00:18:56,570
splitting is kind of like an army

00:18:54,530 --> 00:18:57,800
everybody is exactly the same right like

00:18:56,570 --> 00:18:59,990
you have like a hundred soldiers

00:18:57,800 --> 00:19:01,760
marching in line horizontal splitting in

00:18:59,990 --> 00:19:03,290
a surgical team and much like the

00:19:01,760 --> 00:19:05,270
difference between a surgical team in an

00:19:03,290 --> 00:19:07,090
army the surgical team is much smaller

00:19:05,270 --> 00:19:09,830
right if you do a result of splitting

00:19:07,090 --> 00:19:12,410
usually you get ten fifteen twenty

00:19:09,830 --> 00:19:14,030
processes writing vertical splitting you

00:19:12,410 --> 00:19:16,550
very often you know get into the

00:19:14,030 --> 00:19:18,559
hundreds of processes right so so so

00:19:16,550 --> 00:19:20,600
that that also impacts availability in

00:19:18,559 --> 00:19:22,940
horizontal splitting you usually like

00:19:20,600 --> 00:19:24,980
have less of a good impact on on the

00:19:22,940 --> 00:19:27,559
availability on the other hand in

00:19:24,980 --> 00:19:30,860
horizontal splitting quite often you

00:19:27,559 --> 00:19:33,320
sort of localize the problems usually

00:19:30,860 --> 00:19:35,540
there is a particular part of the

00:19:33,320 --> 00:19:38,900
program that's more sensitive that tends

00:19:35,540 --> 00:19:40,100
to crash more I ideally death part will

00:19:38,900 --> 00:19:42,140
just sort of crush on its own without

00:19:40,100 --> 00:19:44,000
being the whole system down and if you

00:19:42,140 --> 00:19:45,559
sort of set up the other posters to like

00:19:44,000 --> 00:19:46,910
you know never trust completely classics

00:19:45,559 --> 00:19:48,980
out and kind of say to the user I'm

00:19:46,910 --> 00:19:50,150
working on it wait a minute while kind

00:19:48,980 --> 00:19:52,580
of like in a waiting for you to restart

00:19:50,150 --> 00:19:57,020
the often this gives you a pretty good

00:19:52,580 --> 00:19:58,790
approximation of availability the last

00:19:57,020 --> 00:20:00,679
part that's more necessary in the case

00:19:58,790 --> 00:20:02,120
of a horizontal splitter than a vertical

00:20:00,679 --> 00:20:02,930
straight by the vertical split one of

00:20:02,120 --> 00:20:04,970
the processes

00:20:02,930 --> 00:20:07,130
so I like you one out of a hundred died

00:20:04,970 --> 00:20:09,830
the rest have 100 over ninety-nine times

00:20:07,130 --> 00:20:11,300
the work nobody even notices in a

00:20:09,830 --> 00:20:13,550
horizontal split if one of the members

00:20:11,300 --> 00:20:15,740
of your surgical team is missing you

00:20:13,550 --> 00:20:17,240
want to know that really fast and

00:20:15,740 --> 00:20:20,690
replace him with someone that's working

00:20:17,240 --> 00:20:23,360
better so basically that's the job of a

00:20:20,690 --> 00:20:25,430
good watchdog and kind of watch joke is

00:20:23,360 --> 00:20:27,050
an overloaded term but unfortunately it

00:20:25,430 --> 00:20:29,120
is like you know sort of the term i

00:20:27,050 --> 00:20:31,850
usually use for that so i just prefer to

00:20:29,120 --> 00:20:33,950
sort of go with terminology I'm used to

00:20:31,850 --> 00:20:37,730
but it will come back to bite us in the

00:20:33,950 --> 00:20:39,620
ass later in the talk so the wash do

00:20:37,730 --> 00:20:43,040
basically is supposed to bone eater look

00:20:39,620 --> 00:20:44,990
for problems flag the problems and we

00:20:43,040 --> 00:20:47,420
mediate the problems and usually the

00:20:44,990 --> 00:20:53,300
remediation is kill the process start up

00:20:47,420 --> 00:20:55,730
in other one instead so the wash dog

00:20:53,300 --> 00:20:57,380
should not crash right I hope this is

00:20:55,730 --> 00:21:00,530
kind of obvious right if the washer

00:20:57,380 --> 00:21:02,540
crashes then nobody watches it and then

00:21:00,530 --> 00:21:04,700
it's you know sad like we actually had

00:21:02,540 --> 00:21:06,650
this problem because of not because i

00:21:04,700 --> 00:21:08,990
watch the crash but the old killer kills

00:21:06,650 --> 00:21:11,600
the watchdog and then like you knows

00:21:08,990 --> 00:21:13,490
things started it was bad later I will

00:21:11,600 --> 00:21:16,820
talk about how to sort of compensate for

00:21:13,490 --> 00:21:18,650
that but in any case usually the common

00:21:16,820 --> 00:21:22,820
compensations for that our mean like

00:21:18,650 --> 00:21:24,470
doing very very big things so you even

00:21:22,820 --> 00:21:25,550
if you did have this in compensation you

00:21:24,470 --> 00:21:27,470
still want to make sure that the

00:21:25,550 --> 00:21:30,020
watchdog doesn't crash unless something

00:21:27,470 --> 00:21:31,940
is really gone out of whack so there's

00:21:30,020 --> 00:21:33,920
simpler the watchdog is the simpler

00:21:31,940 --> 00:21:39,190
obviously there's a better chances you

00:21:33,920 --> 00:21:41,780
have to not have it crash so basically

00:21:39,190 --> 00:21:43,670
if you want the budget to be simple you

00:21:41,780 --> 00:21:45,650
don't want to start it communicating via

00:21:43,670 --> 00:21:47,450
sockets or stuff like that because that

00:21:45,650 --> 00:21:48,830
will complicate your watchdog you know

00:21:47,450 --> 00:21:50,840
then you're back to get stuck on a

00:21:48,830 --> 00:21:54,500
blocking call and again the whole system

00:21:50,840 --> 00:21:56,180
so falls down through sneeze so what

00:21:54,500 --> 00:21:57,680
they have here is the example of the way

00:21:56,180 --> 00:21:59,600
I like to do heartbeats which is

00:21:57,680 --> 00:22:01,760
basically touching a file the nice thing

00:21:59,600 --> 00:22:03,470
about touching a file you can check it

00:22:01,760 --> 00:22:05,150
offline right the watchdog doesn't have

00:22:03,470 --> 00:22:07,310
to be sort of closely aligned white is

00:22:05,150 --> 00:22:08,420
the work to come half a second later you

00:22:07,310 --> 00:22:12,440
can see that the file has been touched

00:22:08,420 --> 00:22:14,960
right so basically of the way I usually

00:22:12,440 --> 00:22:16,330
like to do it is to to sort of beat so

00:22:14,960 --> 00:22:18,970
this is a simple beat for

00:22:16,330 --> 00:22:20,500
from how you would do it in in twisted

00:22:18,970 --> 00:22:22,450
you so to put this code summer at the

00:22:20,500 --> 00:22:24,490
beginning and if you actually do that

00:22:22,450 --> 00:22:26,919
then this means that as long as twisted

00:22:24,490 --> 00:22:28,840
event loop is running okay which means

00:22:26,919 --> 00:22:31,330
nothing his blog nothing else crash

00:22:28,840 --> 00:22:32,919
testing his gun in a thread deadlock or

00:22:31,330 --> 00:22:35,380
something horrible like that Google

00:22:32,919 --> 00:22:37,090
touch the file as long as as soon as Sam

00:22:35,380 --> 00:22:39,070
one of these happen as soon as you get

00:22:37,090 --> 00:22:41,710
into a thread deadlock or as soon as you

00:22:39,070 --> 00:22:43,720
try to like you know just like stupidly

00:22:41,710 --> 00:22:45,640
import your really when you are a live

00:22:43,720 --> 00:22:48,669
dot Ural open form inside your twisted

00:22:45,640 --> 00:22:50,620
in against like a web server in case

00:22:48,669 --> 00:22:52,299
you're wondering this this is not

00:22:50,620 --> 00:22:54,639
necessarily your fault right you might

00:22:52,299 --> 00:22:57,399
be calling another library for example

00:22:54,639 --> 00:23:00,220
in xml RPC library which helpfully tries

00:22:57,399 --> 00:23:01,809
to retrieve the DTD right that's a lots

00:23:00,220 --> 00:23:03,760
of fun when you do that yes and then

00:23:01,809 --> 00:23:05,440
basically then your twisted process get

00:23:03,760 --> 00:23:09,250
stuck right and it's completely not your

00:23:05,440 --> 00:23:10,960
fault this happens so if this happens it

00:23:09,250 --> 00:23:12,279
won't touch the file for 30 seconds and

00:23:10,960 --> 00:23:15,940
you know later we can see how the

00:23:12,279 --> 00:23:17,769
watcher can monitor that but you can

00:23:15,940 --> 00:23:20,529
have multiple bits in the same process

00:23:17,769 --> 00:23:23,139
so if you're if you're twisted program

00:23:20,529 --> 00:23:25,360
also launches a sweat that has to do

00:23:23,139 --> 00:23:27,639
something every hour then you make sure

00:23:25,360 --> 00:23:30,220
that in that hourly cycle you touch a

00:23:27,639 --> 00:23:33,700
file and then you set this file sort of

00:23:30,220 --> 00:23:37,059
like betrayed to an hour we'll come to

00:23:33,700 --> 00:23:38,980
that in a second I guess so again kind

00:23:37,059 --> 00:23:41,019
of i don't want to put complicated

00:23:38,980 --> 00:23:42,820
parsing file into what consequently

00:23:41,019 --> 00:23:45,190
parsing logic in the watchdog because

00:23:42,820 --> 00:23:46,720
complicated parsing logic you know again

00:23:45,190 --> 00:23:51,159
makes a program more complicated more

00:23:46,720 --> 00:23:53,860
likely to fail so basically i use a file

00:23:51,159 --> 00:23:55,659
system is kind of my past three so I

00:23:53,860 --> 00:23:57,880
just put a lot of hearts and each heart

00:23:55,659 --> 00:24:00,850
says like you know the file is the

00:23:57,880 --> 00:24:02,860
hearts name and the content is just an

00:24:00,850 --> 00:24:05,260
integer well I can realize i would have

00:24:02,860 --> 00:24:06,519
a try except around it but later and I

00:24:05,260 --> 00:24:08,230
will explain why it's not necessarily

00:24:06,519 --> 00:24:10,809
important to have the try except around

00:24:08,230 --> 00:24:12,610
it but I want this to be simpler so

00:24:10,809 --> 00:24:16,120
basically parse all the hearts and then

00:24:12,610 --> 00:24:19,240
I we know how long each each beat has to

00:24:16,120 --> 00:24:21,330
go before it's pronounced dead okay so

00:24:19,240 --> 00:24:23,740
that's that kind of really simple in

00:24:21,330 --> 00:24:25,870
amin arco de actually sort of called is

00:24:23,740 --> 00:24:28,960
the echo gay and i used like last of

00:24:25,870 --> 00:24:30,570
medical metaphor the patient died was a

00:24:28,960 --> 00:24:36,059
log message it was very

00:24:30,570 --> 00:24:38,619
let's finally when customers saw it so

00:24:36,059 --> 00:24:40,929
basically sort of the way I kind of

00:24:38,619 --> 00:24:42,490
envisioned a watchdog and I sort of

00:24:40,929 --> 00:24:44,379
regret to say I did not do it the first

00:24:42,490 --> 00:24:47,950
time I implemented it I learned from

00:24:44,379 --> 00:24:50,169
experience maybe that's good so the

00:24:47,950 --> 00:24:53,230
watchdog just marks problem it doesn't

00:24:50,169 --> 00:24:54,850
actually try to do too much about them

00:24:53,230 --> 00:24:56,649
so in this case it's basically just

00:24:54,850 --> 00:24:58,450
whenever it is a problem with something

00:24:56,649 --> 00:25:00,820
it just tries to be a little bit careful

00:24:58,450 --> 00:25:02,440
so that the M time of the problem file

00:25:00,820 --> 00:25:04,889
will be when the problem was first

00:25:02,440 --> 00:25:07,980
noticed and not when the problem was

00:25:04,889 --> 00:25:10,629
last notice which is a fairly useless

00:25:07,980 --> 00:25:13,869
number but doesn't that basically just

00:25:10,629 --> 00:25:16,019
puts the problems there for something to

00:25:13,869 --> 00:25:18,909
do why a lot of people have like their

00:25:16,019 --> 00:25:21,309
the wash tokens up in the process like

00:25:18,909 --> 00:25:23,320
sort of starter in the same process

00:25:21,309 --> 00:25:26,110
that's bad because the watchdog should

00:25:23,320 --> 00:25:28,330
be simple but again we kind of had a lot

00:25:26,110 --> 00:25:32,110
of that so that's learning from

00:25:28,330 --> 00:25:33,970
experience well you'll notice that I put

00:25:32,110 --> 00:25:37,919
this as the content so there was one

00:25:33,970 --> 00:25:41,409
other thing I want to say before that

00:25:37,919 --> 00:25:44,230
where that I put in the content the

00:25:41,409 --> 00:25:46,360
watchdog that's obviously not necessary

00:25:44,230 --> 00:25:48,249
for anything but it will come in later

00:25:46,360 --> 00:25:50,200
like ideally if something does actually

00:25:48,249 --> 00:25:52,809
immediate the problems it will say

00:25:50,200 --> 00:25:55,090
problem detected by watchdog so you can

00:25:52,809 --> 00:25:57,369
actually have multiple detectors and

00:25:55,090 --> 00:25:58,809
they can mark it down and give it will

00:25:57,369 --> 00:26:02,519
all be nice log files you can lie to

00:25:58,809 --> 00:26:02,519
analyze to figure out what went wrong ah

00:26:03,840 --> 00:26:09,190
ha ha success ok so basically the

00:26:07,179 --> 00:26:11,470
watchdog only does if you check that

00:26:09,190 --> 00:26:13,990
someone solved it well it doesn't

00:26:11,470 --> 00:26:16,179
actually try to solve the problem but if

00:26:13,990 --> 00:26:18,730
the if a problem a single problem has

00:26:16,179 --> 00:26:21,460
gone unsolved what the watchdog assumes

00:26:18,730 --> 00:26:25,210
is that the guy responsible for fixing

00:26:21,460 --> 00:26:27,549
problems is gone now the 12 is not going

00:26:25,210 --> 00:26:29,169
to have complicated problem fixing logic

00:26:27,549 --> 00:26:31,450
because again if you have complicated

00:26:29,169 --> 00:26:34,899
problem fixing logic you complicate the

00:26:31,450 --> 00:26:36,279
watchdog so we're ideally you're like

00:26:34,899 --> 00:26:38,950
saying that monitors the problems

00:26:36,279 --> 00:26:40,539
doesn't crush a lot if it does crush the

00:26:38,950 --> 00:26:43,180
watchdog has sort of the one solution

00:26:40,539 --> 00:26:45,700
which I call the new cousin feels like

00:26:43,180 --> 00:26:47,260
and shoot them in the dark and the

00:26:45,700 --> 00:26:49,510
reason i call it is because getting like

00:26:47,260 --> 00:26:51,430
a lot of this kind of amusement is

00:26:49,510 --> 00:26:52,990
hidden inside the restart system which i

00:26:51,430 --> 00:26:54,280
will not show you but I will sort of

00:26:52,990 --> 00:26:56,380
tell you a little bit about what's going

00:26:54,280 --> 00:26:58,090
on there so ideally what what happened

00:26:56,380 --> 00:27:01,270
in the start system is first the

00:26:58,090 --> 00:27:04,240
watchdog goes and find like the log of

00:27:01,270 --> 00:27:06,370
the like thingy that so again the nice

00:27:04,240 --> 00:27:08,380
thing about it is this is an external

00:27:06,370 --> 00:27:10,690
script to watch dog so you know if the

00:27:08,380 --> 00:27:12,820
script has issues then you know this is

00:27:10,690 --> 00:27:14,740
not watchdogs problem ITC stripped hangs

00:27:12,820 --> 00:27:16,390
ideally shouldn't hang but kind of watch

00:27:14,740 --> 00:27:19,360
it will come in and try to you know we

00:27:16,390 --> 00:27:21,310
want the script so if it was just a

00:27:19,360 --> 00:27:24,520
temporary problems and this descriptor

00:27:21,310 --> 00:27:26,590
run again but this script goes into the

00:27:24,520 --> 00:27:29,050
whatever singing started the processors

00:27:26,590 --> 00:27:32,860
look at the post IDs and then kill them

00:27:29,050 --> 00:27:35,650
and then and then basically the shoot

00:27:32,860 --> 00:27:38,020
them in the dark is basically if you do

00:27:35,650 --> 00:27:41,290
it correctly the process monitor sort of

00:27:38,020 --> 00:27:43,630
stamps stamps itself and by by extension

00:27:41,290 --> 00:27:45,520
is children with kind of a marker which

00:27:43,630 --> 00:27:48,910
is an environment variable so it's an

00:27:45,520 --> 00:27:52,300
environment variable like my descendants

00:27:48,910 --> 00:27:54,370
to like some long uuid then the watchdog

00:27:52,300 --> 00:27:57,760
especially on a Linux system can go over

00:27:54,370 --> 00:28:00,190
the process list see who's marked with

00:27:57,760 --> 00:28:01,810
that mark of the UID and it knows it has

00:28:00,190 --> 00:28:04,420
to kill the ball because they were part

00:28:01,810 --> 00:28:06,730
of like you know that whole that whole

00:28:04,420 --> 00:28:09,190
system that needed to be restarted so it

00:28:06,730 --> 00:28:10,900
basically like really does like a nuke

00:28:09,190 --> 00:28:11,890
them in the mutant if they glow and then

00:28:10,900 --> 00:28:14,230
shoot them in the dark he tries to

00:28:11,890 --> 00:28:16,390
eliminate anyone who is part of that

00:28:14,230 --> 00:28:18,040
whole conglomerate which failed and

00:28:16,390 --> 00:28:21,250
ideally I then you know we start the

00:28:18,040 --> 00:28:24,070
system from scratch so who is that kind

00:28:21,250 --> 00:28:26,590
of like sort of separation of concerns

00:28:24,070 --> 00:28:28,540
so you do like the common solution to

00:28:26,590 --> 00:28:30,520
problems in a reasonable way of

00:28:28,540 --> 00:28:32,650
something that can so you know just

00:28:30,520 --> 00:28:35,800
picks us the given process that had a

00:28:32,650 --> 00:28:37,720
problem try to send it to 15 if it

00:28:35,800 --> 00:28:39,550
doesn't respond ten to nine check it

00:28:37,720 --> 00:28:41,860
died all that kind of sort of niceness

00:28:39,550 --> 00:28:43,690
and then basically when the watchdog

00:28:41,860 --> 00:28:46,660
Cesar Department has not been solved in

00:28:43,690 --> 00:28:48,130
enough time it basically like completely

00:28:46,660 --> 00:28:53,140
destroys the whole system and makes a

00:28:48,130 --> 00:28:56,770
new one and you know the loop is fairly

00:28:53,140 --> 00:28:58,510
simple ideally the marking of

00:28:56,770 --> 00:29:00,520
other than checking of solutions in the

00:28:58,510 --> 00:29:02,980
case where there are no problem is just

00:29:00,520 --> 00:29:04,510
reading a directory again kind of mobs

00:29:02,980 --> 00:29:08,020
my experience at the unix system on a

00:29:04,510 --> 00:29:11,470
common unix system the way it works oh

00:29:08,020 --> 00:29:15,580
okay i'm almost out of time so i'll kind

00:29:11,470 --> 00:29:18,480
of skip over the next few slides wow I

00:29:15,580 --> 00:29:21,610
thought I was so my conclusion is

00:29:18,480 --> 00:29:23,260
everything crashes you should plan for

00:29:21,610 --> 00:29:25,090
it because if you don't plan for it

00:29:23,260 --> 00:29:30,610
it'll still crash but you won't have a

00:29:25,090 --> 00:29:33,540
plan so that's it and I am happy to hear

00:29:30,610 --> 00:29:33,540
any questions you have

00:29:39,739 --> 00:29:43,679
we have time for a few questions if you

00:29:42,119 --> 00:29:45,269
could please come to the microphone over

00:29:43,679 --> 00:29:47,840
here if you have a question so that we

00:29:45,269 --> 00:29:47,840
can all hear you

00:29:54,820 --> 00:29:59,769
so

00:29:57,159 --> 00:30:02,529
so I guess I have a quick question so it

00:29:59,769 --> 00:30:04,690
seems like you are presenting the

00:30:02,529 --> 00:30:07,779
watchdog in small chunks which all in

00:30:04,690 --> 00:30:09,729
and of themselves seem fairly simple but

00:30:07,779 --> 00:30:13,239
taken as a whole seems still relatively

00:30:09,729 --> 00:30:15,340
complex have you run into issues with

00:30:13,239 --> 00:30:16,690
your watchdog and how do you so so

00:30:15,340 --> 00:30:18,580
that's a good question that's kind of

00:30:16,690 --> 00:30:21,700
the slides I kind of skipped to get to

00:30:18,580 --> 00:30:23,619
the end so what I presented the loop is

00:30:21,700 --> 00:30:26,229
just a Python process if you want to get

00:30:23,619 --> 00:30:28,059
like better reliability because these

00:30:26,229 --> 00:30:29,769
are just two parts which have nothing to

00:30:28,059 --> 00:30:32,710
do with each other you can run each of

00:30:29,769 --> 00:30:34,119
them from Quan and a one-second basis so

00:30:32,710 --> 00:30:36,039
basically like you sort of depend on the

00:30:34,119 --> 00:30:38,889
reliability of chron then you get into

00:30:36,039 --> 00:30:40,599
the issue okay what if grande eyes ah so

00:30:38,889 --> 00:30:42,700
basically what you do is from these

00:30:40,599 --> 00:30:45,609
things after you do the interesting

00:30:42,700 --> 00:30:47,080
thing you also touch a file and so you

00:30:45,609 --> 00:30:48,999
have these two files that have to be

00:30:47,080 --> 00:30:51,190
touched all the time then you can use

00:30:48,999 --> 00:30:53,049
the Linux watchdog that's kind of the

00:30:51,190 --> 00:30:54,759
the kind of horribleness of the watchdog

00:30:53,049 --> 00:30:56,379
that you know the like lots of things

00:30:54,759 --> 00:30:58,299
that uses that name to use the Linux

00:30:56,379 --> 00:31:00,999
watchdog demon to monitor these two

00:30:58,299 --> 00:31:02,649
files and when the link is a Linux my

00:31:00,999 --> 00:31:04,659
wife took demon what it does is it

00:31:02,649 --> 00:31:07,950
opened the Linux hardware or a sort of

00:31:04,659 --> 00:31:10,929
software emulated internal watchdog

00:31:07,950 --> 00:31:13,419
device and it has to I to it all the

00:31:10,929 --> 00:31:15,999
time it won't right if it either crashes

00:31:13,419 --> 00:31:18,369
or if one of these two files is missing

00:31:15,999 --> 00:31:21,489
if the wash dog doesn't twice to this

00:31:18,369 --> 00:31:23,440
file then basically Linux reboots so

00:31:21,489 --> 00:31:24,849
basically this is kind of the easy yes

00:31:23,440 --> 00:31:27,669
you have to be so too insane and

00:31:24,849 --> 00:31:29,859
paranoid I make sure that yeah so that's

00:31:27,669 --> 00:31:31,989
a good question yeah so I was going to

00:31:29,859 --> 00:31:33,970
sort of go over that so yes if you if

00:31:31,989 --> 00:31:36,429
you're insane and paranoid enough then

00:31:33,970 --> 00:31:38,679
you get into the situation where as long

00:31:36,429 --> 00:31:39,940
as Linux has not get gassing people like

00:31:38,679 --> 00:31:41,739
a really bad state which is

00:31:39,940 --> 00:31:44,739
unfortunately impossible to prevent from

00:31:41,739 --> 00:31:48,070
user space then eventually your process

00:31:44,739 --> 00:31:49,960
will restart Thank You them what and

00:31:48,070 --> 00:31:51,340
then you can use a hardware watchdog if

00:31:49,960 --> 00:31:54,220
you're really concerned about that and

00:31:51,340 --> 00:31:56,229
little supported just fine so the the

00:31:54,220 --> 00:31:57,309
sysadmin in me actually is horrified by

00:31:56,229 --> 00:31:58,979
all this I think this makes a lot of

00:31:57,309 --> 00:32:01,269
sense from a developer's perspective but

00:31:58,979 --> 00:32:04,359
if I have a cluster of 100 machines

00:32:01,269 --> 00:32:06,039
running your software and you know dis

00:32:04,359 --> 00:32:07,809
goes bad ram goes bad I mean hardware

00:32:06,039 --> 00:32:10,570
breaks and if the response of your heart

00:32:07,809 --> 00:32:12,429
of your software is to try repeatedly

00:32:10,570 --> 00:32:15,340
restart itself every second spamming

00:32:12,429 --> 00:32:16,779
messages spamming brokenness actually

00:32:15,340 --> 00:32:18,940
don't want that I want that system to

00:32:16,779 --> 00:32:22,029
just go away excellent question testing

00:32:18,940 --> 00:32:24,130
so yes I kind of started the whole story

00:32:22,029 --> 00:32:25,630
by talking about the appliance that you

00:32:24,130 --> 00:32:27,580
were writing so an appliance doesn't

00:32:25,630 --> 00:32:31,090
have a system me and appliance is

00:32:27,580 --> 00:32:33,070
supposed to just work ideally you should

00:32:31,090 --> 00:32:34,659
you know you get you used to be able to

00:32:33,070 --> 00:32:36,639
just run it without Abacha kind of the

00:32:34,659 --> 00:32:39,370
nice thing about this watchdog is it so

00:32:36,639 --> 00:32:41,440
it just marks problem you know if you

00:32:39,370 --> 00:32:43,480
sort of tweak it a little bit you can

00:32:41,440 --> 00:32:45,490
market this problem without checking for

00:32:43,480 --> 00:32:47,830
solutions and then that you can use a

00:32:45,490 --> 00:32:49,419
system without restarting and you will

00:32:47,830 --> 00:32:51,370
just sort of you know you can like you

00:32:49,419 --> 00:32:52,600
know sort of output it's so like make

00:32:51,370 --> 00:32:54,909
sure that you change your email if

00:32:52,600 --> 00:32:56,679
there's any problem file yes this is for

00:32:54,909 --> 00:32:58,090
system that do not have assisted mean

00:32:56,679 --> 00:33:00,190
because the system in would indeed be

00:32:58,090 --> 00:33:02,200
horrified by that this is a system that

00:33:00,190 --> 00:33:03,940
just have to work without any user

00:33:02,200 --> 00:33:08,080
intervention including system in which

00:33:03,940 --> 00:33:11,519
is still a user thank you dustin i think

00:33:08,080 --> 00:33:11,519
amount of time yeah

00:33:15,020 --> 00:33:17,080

YouTube URL: https://www.youtube.com/watch?v=OBbvj0WWT-g


