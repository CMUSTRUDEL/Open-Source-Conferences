Title: Parsing Horrible Things with Python
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Erik Rose
If you've ever wanted to get started with parsers, here's your chance for a ground-floor introduction. A harebrained spare-time project gives birth to a whirlwind journey from basic algorithms to Python libraries and, at last, to a parser f
Captions: 
	00:00:02,419 --> 00:00:07,020
hey everyone if I could have your

00:00:04,350 --> 00:00:09,420
attention like to introduce Eric Rose

00:00:07,020 --> 00:00:12,900
there's a Python Wrangler at vote is in

00:00:09,420 --> 00:00:14,820
working to fix American democracy the

00:00:12,900 --> 00:00:17,160
title of this talk is parsing horrible

00:00:14,820 --> 00:00:18,960
things with Python it's going to be a

00:00:17,160 --> 00:00:20,369
30-minute talk including five minutes

00:00:18,960 --> 00:00:22,800
for questions at the end you have

00:00:20,369 --> 00:00:26,570
questions after the talk please use the

00:00:22,800 --> 00:00:26,570
microphone that's in the aisle thank you

00:00:30,830 --> 00:00:35,430
thank you very much Ryan welcome to

00:00:33,480 --> 00:00:37,739
parsing horrible things or I

00:00:35,430 --> 00:00:39,570
accidentally the Chomsky hierarchy I'm

00:00:37,739 --> 00:00:41,280
going to show you how to avoid all the

00:00:39,570 --> 00:00:43,160
mistakes I made while trying to parse

00:00:41,280 --> 00:00:46,559
the MediaWiki syntax one of the most

00:00:43,160 --> 00:00:48,440
tangled and evil lingual constructs if

00:00:46,559 --> 00:00:51,390
you could even call that known to man

00:00:48,440 --> 00:00:53,160
along the way I will accidentally enough

00:00:51,390 --> 00:00:54,750
of parsing theory that you can shop for

00:00:53,160 --> 00:00:56,550
a parsing library for your own projects

00:00:54,750 --> 00:00:57,480
without having to paint yourself into a

00:00:56,550 --> 00:00:59,640
corner this is going to have you a

00:00:57,480 --> 00:01:02,550
catalogue of my mistakes as I figured

00:00:59,640 --> 00:01:04,019
out how parsing works I want to give a

00:01:02,550 --> 00:01:06,390
shout out before we get started to vote

00:01:04,019 --> 00:01:08,820
is in my current startup we are trying

00:01:06,390 --> 00:01:09,900
to fix American democracy and we figured

00:01:08,820 --> 00:01:12,360
that should be pretty simple should be

00:01:09,900 --> 00:01:14,670
done by lunch but when I submitted this

00:01:12,360 --> 00:01:17,520
talk I was still at Mozilla having a

00:01:14,670 --> 00:01:18,930
great time on their support Mozilla org

00:01:17,520 --> 00:01:21,570
site and this is where you go to get

00:01:18,930 --> 00:01:22,650
help with Firefox that sort of thing we

00:01:21,570 --> 00:01:23,880
have a wiki we have a Stack Overflow

00:01:22,650 --> 00:01:27,600
clone we have a threaded discussion

00:01:23,880 --> 00:01:30,030
forum and for strange legacy reasons our

00:01:27,600 --> 00:01:31,259
wiki is backed by MediaWiki syntax it

00:01:30,030 --> 00:01:36,509
had a lot of mindshare among our

00:01:31,259 --> 00:01:37,860
contributors so parsing is something

00:01:36,509 --> 00:01:40,950
that a lot of us just think of in a very

00:01:37,860 --> 00:01:43,290
limited way how do we turn strings into

00:01:40,950 --> 00:01:45,060
parse trees for example but really it's

00:01:43,290 --> 00:01:47,970
fundamental to everything that goes on

00:01:45,060 --> 00:01:51,509
around us every single day if you think

00:01:47,970 --> 00:01:53,070
about the ideas in your head there are a

00:01:51,509 --> 00:01:55,290
multi-dimensional construct they're a

00:01:53,070 --> 00:01:59,549
bunch of ideas all hooked together and

00:01:55,290 --> 00:02:01,979
related to each other and if you want to

00:01:59,549 --> 00:02:04,200
convey them to someone else you have to

00:02:01,979 --> 00:02:07,080
serialize them into this bunch of

00:02:04,200 --> 00:02:09,450
symbols bunch of letters bunch of sounds

00:02:07,080 --> 00:02:12,290
and then hope that they get into that

00:02:09,450 --> 00:02:14,670
other person's brain and get

00:02:12,290 --> 00:02:16,650
deserialized into a similar construct

00:02:14,670 --> 00:02:19,590
that you were trying to convey your

00:02:16,650 --> 00:02:22,050
parsing right now but it's not just text

00:02:19,590 --> 00:02:24,540
you can think of it in a variety of

00:02:22,050 --> 00:02:26,790
media for example think about it music a

00:02:24,540 --> 00:02:28,770
musical composition is made up of

00:02:26,790 --> 00:02:31,170
musical phrases kind of analogous to

00:02:28,770 --> 00:02:32,370
lingual ones you can use a partial to

00:02:31,170 --> 00:02:34,830
figure that out and figure out how these

00:02:32,370 --> 00:02:37,800
phrases interrelate you can think about

00:02:34,830 --> 00:02:40,380
dance pieces of choreography and body

00:02:37,800 --> 00:02:42,330
positions that make up a dance something

00:02:40,380 --> 00:02:44,610
that's coherent not like the Elaine

00:02:42,330 --> 00:02:48,270
Benes sort of dance that would

00:02:44,610 --> 00:02:49,530
be unpossible parse error so partially

00:02:48,270 --> 00:02:51,720
in the most general sense is anything

00:02:49,530 --> 00:02:54,150
that pulls structure out of a linear

00:02:51,720 --> 00:02:56,040
representation so how does it know how

00:02:54,150 --> 00:02:57,720
to do that well assume you've got a

00:02:56,040 --> 00:03:00,150
reasonable parsing library behind you

00:02:57,720 --> 00:03:04,440
you can just hand it a description like

00:03:00,150 --> 00:03:08,130
this and this is a part of the language

00:03:04,440 --> 00:03:10,410
that describes Python itself it's in EB

00:03:08,130 --> 00:03:11,580
NF or extended Bacchus noir form and

00:03:10,410 --> 00:03:13,080
you've probably all seen this in man

00:03:11,580 --> 00:03:14,810
pages and trying to learn programming

00:03:13,080 --> 00:03:17,250
languages and that sorts of things and

00:03:14,810 --> 00:03:18,810
you can conclude something interesting

00:03:17,250 --> 00:03:21,060
already just from the fact that it's in

00:03:18,810 --> 00:03:22,560
EB n F EB NF is just a bunch of

00:03:21,060 --> 00:03:24,239
definitions you know one definition on

00:03:22,560 --> 00:03:25,590
the left and then some stuff definition

00:03:24,239 --> 00:03:28,440
on the left and some stuff and because

00:03:25,590 --> 00:03:30,450
there's only one word on the left you

00:03:28,440 --> 00:03:32,940
know that this is a context-free grammar

00:03:30,450 --> 00:03:33,959
because you can see that take a look at

00:03:32,940 --> 00:03:37,170
anything they're like decorator the

00:03:33,959 --> 00:03:38,610
first one well decorators always this no

00:03:37,170 --> 00:03:40,170
matter the context it doesn't matter a

00:03:38,610 --> 00:03:42,090
decorator is always this it's not like

00:03:40,170 --> 00:03:44,190
if you have a funny word and then

00:03:42,090 --> 00:03:46,410
decorator then it's this stuff it's

00:03:44,190 --> 00:03:48,450
always so it's context-free and why is

00:03:46,410 --> 00:03:49,800
that important it's because if you're

00:03:48,450 --> 00:03:51,300
not context-free there are a couple

00:03:49,800 --> 00:03:53,820
other horrible things you can be you can

00:03:51,300 --> 00:03:55,920
be context-sensitive or you can just be

00:03:53,820 --> 00:03:57,720
a phrase structure grammar which means

00:03:55,920 --> 00:03:59,760
there are no rules at all and there's no

00:03:57,720 --> 00:04:01,860
way to parse those and there's hard ways

00:03:59,760 --> 00:04:04,519
to parse context-sensitive grammars but

00:04:01,860 --> 00:04:06,570
these most libraries can handle it a

00:04:04,519 --> 00:04:08,519
quick side note about regular

00:04:06,570 --> 00:04:10,350
expressions so we all have banged

00:04:08,519 --> 00:04:12,900
regular expressions against things and

00:04:10,350 --> 00:04:14,940
if you can you probably should but when

00:04:12,900 --> 00:04:16,500
should you reach for a parser two things

00:04:14,940 --> 00:04:19,440
when you're reg X gets so long you can't

00:04:16,500 --> 00:04:20,280
stand it anymore or two when there's

00:04:19,440 --> 00:04:21,600
nesting in the

00:04:20,280 --> 00:04:24,330
thing you want to parse a regular

00:04:21,600 --> 00:04:26,280
expression cannot represent can I

00:04:24,330 --> 00:04:29,370
recognize I should say nested

00:04:26,280 --> 00:04:33,090
parentheses nested constructs so on we

00:04:29,370 --> 00:04:35,760
go we have this e BNF how do we turn it

00:04:33,090 --> 00:04:38,610
into a nice tree format that we can then

00:04:35,760 --> 00:04:40,860
do processing on let's take a look here

00:04:38,610 --> 00:04:42,690
this is the start symbol so if we're

00:04:40,860 --> 00:04:45,210
trying to recognize it with this many

00:04:42,690 --> 00:04:49,650
language spans of bold text in a quasi

00:04:45,210 --> 00:04:51,419
HTML way like this our parser would

00:04:49,650 --> 00:04:53,040
start this bold text thing it would say

00:04:51,419 --> 00:04:56,610
well let's see is there a bold tag while

00:04:53,040 --> 00:04:58,620
yes there is is there some text then yes

00:04:56,610 --> 00:05:00,240
there is and then is there an end tag

00:04:58,620 --> 00:05:02,640
yes there is okay so we can construct

00:05:00,240 --> 00:05:05,880
this tree format out of it that's great

00:05:02,640 --> 00:05:07,830
and then we can walk the tree and we can

00:05:05,880 --> 00:05:09,930
do whatever we want the cool thing about

00:05:07,830 --> 00:05:12,000
parse trees is that their representation

00:05:09,930 --> 00:05:14,640
agnostic I could go back and render that

00:05:12,000 --> 00:05:16,710
HTML out of this no problem or I could

00:05:14,640 --> 00:05:18,510
have my tree Walker say bold tag well

00:05:16,710 --> 00:05:21,120
okay I'm going to print this out to a

00:05:18,510 --> 00:05:23,880
terminal so let's flip the flips a bit

00:05:21,120 --> 00:05:25,500
in our terminal escape sequence that

00:05:23,880 --> 00:05:27,120
causes it to become bold and it'll print

00:05:25,500 --> 00:05:29,340
our text and then we'll hit the end bold

00:05:27,120 --> 00:05:31,260
tag and flip that bit again so you could

00:05:29,340 --> 00:05:34,700
print an HTML or text or whatever you

00:05:31,260 --> 00:05:39,830
want trees are very versatile like that

00:05:34,700 --> 00:05:39,830
how parsing is a gateway drug

00:05:40,570 --> 00:05:44,860
once you've turned sis serialized

00:05:43,090 --> 00:05:47,080
gibberish into a tree you can do

00:05:44,860 --> 00:05:49,360
anything you want you can get into

00:05:47,080 --> 00:05:51,310
programming language design you can get

00:05:49,360 --> 00:05:53,160
into compilation you can get into

00:05:51,310 --> 00:05:55,870
natural language processing

00:05:53,160 --> 00:05:57,610
now unfortunately when you try to get

00:05:55,870 --> 00:05:59,530
into this field you encounter a lot of

00:05:57,610 --> 00:06:01,720
Greek chars and I'm not very familiar

00:05:59,530 --> 00:06:03,580
with the Greek alka alphabet so I

00:06:01,720 --> 00:06:05,650
promise today that the only Greek char

00:06:03,580 --> 00:06:09,780
you'll encounter is that ghostly lambda

00:06:05,650 --> 00:06:13,540
in my background pattern on to MediaWiki

00:06:09,780 --> 00:06:15,940
MediaWiki it mister municipal a

00:06:13,540 --> 00:06:19,000
MediaWiki is never turned into a parse

00:06:15,940 --> 00:06:23,350
tree in the original Klingon it's made

00:06:19,000 --> 00:06:27,100
of these 41 regular expressions that all

00:06:23,350 --> 00:06:28,450
get run over and over again and replaced

00:06:27,100 --> 00:06:30,520
search replace search replace replace

00:06:28,450 --> 00:06:32,200
and then magically at the end you ended

00:06:30,520 --> 00:06:34,150
up with this plate the wikitext turns

00:06:32,200 --> 00:06:35,500
straight into HTML if you want plain

00:06:34,150 --> 00:06:37,810
text too bad you're gonna have to like

00:06:35,500 --> 00:06:41,410
reparse the HTML and strip stuff off

00:06:37,810 --> 00:06:44,500
it's horrendous and in case that wasn't

00:06:41,410 --> 00:06:49,290
enough there are then 2300 lines of

00:06:44,500 --> 00:06:51,550
additional logic behind the thing yeah

00:06:49,290 --> 00:06:52,860
originally this is all in PHP I got to

00:06:51,550 --> 00:06:55,150
hand it to David Kramer for

00:06:52,860 --> 00:06:57,160
transliterating it to Python it is a

00:06:55,150 --> 00:07:01,930
transliteration there are still dollar

00:06:57,160 --> 00:07:04,900
signs in the comments it's kind of hard

00:07:01,930 --> 00:07:06,760
to understand it's kind of buggy and not

00:07:04,900 --> 00:07:10,750
David's fault he preserved all the bugs

00:07:06,760 --> 00:07:12,130
from the original implementation and the

00:07:10,750 --> 00:07:13,660
MediaWiki language just to keep you on

00:07:12,130 --> 00:07:15,130
your toes changes all the time every

00:07:13,660 --> 00:07:17,230
release they keep tweaking things

00:07:15,130 --> 00:07:18,370
because things are clearly screwed up I

00:07:17,230 --> 00:07:19,300
mean like if you have an internal link

00:07:18,370 --> 00:07:21,130
as my favorite you can't have an

00:07:19,300 --> 00:07:22,930
internal link you know and then you end

00:07:21,130 --> 00:07:24,910
up with a brace brace and then you have

00:07:22,930 --> 00:07:26,500
an HTML entity you can't do that it'll

00:07:24,910 --> 00:07:29,800
it'll wreck your internal link and not

00:07:26,500 --> 00:07:31,810
recognize it so they keep fixing stuff

00:07:29,800 --> 00:07:35,380
and because it's so hard to understand

00:07:31,810 --> 00:07:36,670
it's really hard to extend you change

00:07:35,380 --> 00:07:37,750
one thing in that rat's nest and

00:07:36,670 --> 00:07:42,100
everything else comes crashing down

00:07:37,750 --> 00:07:44,470
around you and we wanted to extend it we

00:07:42,100 --> 00:07:46,540
wanted to have our changes our pages

00:07:44,470 --> 00:07:48,100
rather change dynamically depending on

00:07:46,540 --> 00:07:49,630
the browser version and the operating

00:07:48,100 --> 00:07:51,700
system that the user brought to the

00:07:49,630 --> 00:07:53,500
table we want to have a construct like

00:07:51,700 --> 00:07:55,570
this we want to be able to say for Phi

00:07:53,500 --> 00:07:58,060
or fox such-and-such version show this

00:07:55,570 --> 00:08:01,090
paragraph otherwise show this paragraph

00:07:58,060 --> 00:08:04,240
for firefox 3.5 show this template down

00:08:01,090 --> 00:08:05,800
at the bottom good luck right when I

00:08:04,240 --> 00:08:07,630
took a first whack at this I actually

00:08:05,800 --> 00:08:09,310
did do the thing we're okay fine parser

00:08:07,630 --> 00:08:11,290
you just put it in HTML and I'll take it

00:08:09,310 --> 00:08:12,760
apart again I'll wrap it in another

00:08:11,290 --> 00:08:14,380
little partial that does my thing and

00:08:12,760 --> 00:08:16,390
I'll spit it back out it's just just a

00:08:14,380 --> 00:08:19,900
lot of redone work and tremendously hard

00:08:16,390 --> 00:08:22,120
to understand so I thought I'm going to

00:08:19,900 --> 00:08:24,040
write a proper parser for this once and

00:08:22,120 --> 00:08:26,560
for all I'm going to parse MediaWiki

00:08:24,040 --> 00:08:28,900
right so the first thing to think about

00:08:26,560 --> 00:08:31,990
is can i express this language in a

00:08:28,900 --> 00:08:34,330
formal way fortunately some work has

00:08:31,990 --> 00:08:36,729
been done on that there are a couple

00:08:34,330 --> 00:08:39,940
different competing representations on

00:08:36,729 --> 00:08:42,760
the MediaWiki site this one is a little

00:08:39,940 --> 00:08:44,380
chunk of the one done in BNF that seems

00:08:42,760 --> 00:08:46,630
to be the best developed so I thought

00:08:44,380 --> 00:08:48,370
great I'll take this I will translate it

00:08:46,630 --> 00:08:51,160
for some parsing library and I will have

00:08:48,370 --> 00:08:52,930
myself a parser so I started with PI

00:08:51,160 --> 00:08:55,690
parsing which i think of is kind of the

00:08:52,930 --> 00:08:56,890
canonical Python parsing library before

00:08:55,690 --> 00:08:57,340
we get into that I need to give you a

00:08:56,890 --> 00:09:01,060
warning

00:08:57,340 --> 00:09:03,970
Python parsing libraries are weird they

00:09:01,060 --> 00:09:05,620
do things like assume things about the

00:09:03,970 --> 00:09:08,470
content of your doc strings they take

00:09:05,620 --> 00:09:11,290
semantics out of them they do strange

00:09:08,470 --> 00:09:13,089
discovery of pieces of your grammar you

00:09:11,290 --> 00:09:14,320
know there's name sensitive you name

00:09:13,089 --> 00:09:17,290
them a certain way and they'll find them

00:09:14,320 --> 00:09:20,260
like unit test does and they do strange

00:09:17,290 --> 00:09:22,030
over writings of operators as well so so

00:09:20,260 --> 00:09:22,810
brace yourself but this is not for no

00:09:22,030 --> 00:09:24,970
reason at all

00:09:22,810 --> 00:09:27,280
this is for a couple of reasons for one

00:09:24,970 --> 00:09:30,010
thing conciseness it's a lot shorter to

00:09:27,280 --> 00:09:34,240
say you know vertical bar than to say

00:09:30,010 --> 00:09:37,360
dot or expression or dot alternation to

00:09:34,240 --> 00:09:39,310
a familiarity if you can make it look as

00:09:37,360 --> 00:09:41,050
much like BNF as possible then you know

00:09:39,310 --> 00:09:43,680
it's more concise and it's more familiar

00:09:41,050 --> 00:09:46,000
to people who are translating from BNF

00:09:43,680 --> 00:09:47,560
also I kind of suspect the people who

00:09:46,000 --> 00:09:48,970
are interested in parsing and who are

00:09:47,560 --> 00:09:51,370
writing these libraries are so

00:09:48,970 --> 00:09:52,810
interested in language in general that

00:09:51,370 --> 00:09:54,910
they just can't help playing around I

00:09:52,810 --> 00:09:56,830
mean that's that's true myself at least

00:09:54,910 --> 00:09:58,540
and then of course it's it's easier for

00:09:56,830 --> 00:10:01,240
the implementer the more you can sort of

00:09:58,540 --> 00:10:02,620
wedge the grammar definition into the

00:10:01,240 --> 00:10:04,930
Python language the less you have to

00:10:02,620 --> 00:10:06,829
implement yourself so with that warning

00:10:04,930 --> 00:10:09,029
by parsing

00:10:06,829 --> 00:10:11,610
first thing you might notice is this is

00:10:09,029 --> 00:10:14,160
a little bit hard to read a little dense

00:10:11,610 --> 00:10:17,970
a little jumbled so let's step through

00:10:14,160 --> 00:10:19,829
it one by one here you can think of this

00:10:17,970 --> 00:10:21,870
as kind of mirroring a BNF where the

00:10:19,829 --> 00:10:23,040
definition the terms are on the left the

00:10:21,870 --> 00:10:25,350
production names are on the left and the

00:10:23,040 --> 00:10:27,149
definitions on the right you can do

00:10:25,350 --> 00:10:28,649
string literals you can say oh this is a

00:10:27,149 --> 00:10:31,560
literal and here it is a quote quote

00:10:28,649 --> 00:10:32,910
quote for bold you can say there's one

00:10:31,560 --> 00:10:38,399
or more of these things that's your

00:10:32,910 --> 00:10:40,199
regular expression plus I it overrides

00:10:38,399 --> 00:10:42,899
some operators like these ones to do

00:10:40,199 --> 00:10:47,579
what you would expect or and followed by

00:10:42,899 --> 00:10:50,310
and then you have this group operator

00:10:47,579 --> 00:10:52,949
and the group operator is the way that

00:10:50,310 --> 00:10:55,889
you get a parse tree out of it rather

00:10:52,949 --> 00:10:58,019
than just a sequence of tokens so that

00:10:55,889 --> 00:11:00,269
group were rather the one below it by

00:10:58,019 --> 00:11:02,069
italic span is the thing that creates

00:11:00,269 --> 00:11:03,870
this nested list in the middle of this

00:11:02,069 --> 00:11:05,310
output now at the bottom I'm sorry that

00:11:03,870 --> 00:11:06,540
you can't see that but there are nested

00:11:05,310 --> 00:11:10,019
lists at the bottom and that's how it

00:11:06,540 --> 00:11:11,459
stores its trees but fault now there are

00:11:10,019 --> 00:11:14,490
a few unfortunate compromises they had

00:11:11,459 --> 00:11:16,139
to make because there's no way in Python

00:11:14,490 --> 00:11:19,500
to to look at what you're being assigned

00:11:16,139 --> 00:11:20,880
to I had to say set name all the time if

00:11:19,500 --> 00:11:26,220
I one of these expressions to have some

00:11:20,880 --> 00:11:27,569
idea what they were named also you can't

00:11:26,220 --> 00:11:29,040
really Express you can't afford

00:11:27,569 --> 00:11:30,720
references in Python really you can't do

00:11:29,040 --> 00:11:33,449
cycles and in a lot of a lot of places

00:11:30,720 --> 00:11:35,160
you need to do cycles among rules and so

00:11:33,449 --> 00:11:36,540
they introduced this forward thing so

00:11:35,160 --> 00:11:38,670
yeah I'm going to define this just hang

00:11:36,540 --> 00:11:41,370
on this is a proxy object and later I'll

00:11:38,670 --> 00:11:44,310
use this dink-dink operator to assign

00:11:41,370 --> 00:11:46,500
some useful value to it so that makes it

00:11:44,310 --> 00:11:48,329
a little bit less straightforward

00:11:46,500 --> 00:11:50,880
but we're really killed it for me was

00:11:48,329 --> 00:11:53,069
debugging I make a lot of mistakes and

00:11:50,880 --> 00:11:57,120
when I was trying to port this grammar

00:11:53,069 --> 00:11:58,740
over I needed the D I needed the library

00:11:57,120 --> 00:12:00,329
to hold my hand more than a data what I

00:11:58,740 --> 00:12:02,399
ended up getting was these terrible

00:12:00,329 --> 00:12:04,589
recursive trace backs to the guts of the

00:12:02,399 --> 00:12:07,290
library and since the library is a

00:12:04,589 --> 00:12:11,310
single 3,000 line module it really

00:12:07,290 --> 00:12:14,809
wasn't easy to follow so I took a second

00:12:11,310 --> 00:12:18,750
attempt I tried PL y which is a port of

00:12:14,809 --> 00:12:19,770
lexan DIAC by my personal hero David

00:12:18,750 --> 00:12:22,710
Beasley

00:12:19,770 --> 00:12:23,940
and I really can't say enough about Bly

00:12:22,710 --> 00:12:25,950
it's a great library

00:12:23,940 --> 00:12:27,900
it's an LR 1 parser and we'll get to

00:12:25,950 --> 00:12:29,850
what that means but the nice parts of it

00:12:27,900 --> 00:12:33,150
you can get by reading Wikipedia is that

00:12:29,850 --> 00:12:34,530
it it is order the length of your text

00:12:33,150 --> 00:12:36,240
he'll run portion of the length of your

00:12:34,530 --> 00:12:39,360
text independent of your grammar

00:12:36,240 --> 00:12:40,950
complexity it's a port of a sea library

00:12:39,360 --> 00:12:42,360
so you know if it ended up to go slow I

00:12:40,950 --> 00:12:44,070
figured hey I can just port straight

00:12:42,360 --> 00:12:45,300
forwardly one-to-one over to see give it

00:12:44,070 --> 00:12:49,920
a compile and away we go

00:12:45,300 --> 00:12:52,320
and best of all it's got fantastic debug

00:12:49,920 --> 00:12:53,760
output David who's teaching courses with

00:12:52,320 --> 00:12:55,410
this who teach the course where they

00:12:53,760 --> 00:12:58,260
build a little Pascal kind of

00:12:55,410 --> 00:13:00,390
interpreter thing and so his students

00:12:58,260 --> 00:13:02,370
have hit every possible wrong way to use

00:13:00,390 --> 00:13:03,750
this and he's got great error message

00:13:02,370 --> 00:13:05,190
it's great hand-holding really a

00:13:03,750 --> 00:13:06,650
pleasure to use here's what it looks

00:13:05,190 --> 00:13:10,290
like

00:13:06,650 --> 00:13:11,790
these are tokenization rules PL why does

00:13:10,290 --> 00:13:15,900
this the way a lot of parsers do it in

00:13:11,790 --> 00:13:19,980
two phases first it tries to break down

00:13:15,900 --> 00:13:23,310
your input text into who does our token

00:13:19,980 --> 00:13:25,860
is ends up okay tries to break the break

00:13:23,310 --> 00:13:31,080
them down into categories of symbols

00:13:25,860 --> 00:13:33,510
let's say the way it gets ahold of these

00:13:31,080 --> 00:13:35,040
is one of my weirdness bullets it scans

00:13:33,510 --> 00:13:36,300
the namespace usually a module but you

00:13:35,040 --> 00:13:37,830
can pass in a class if you want to be a

00:13:36,300 --> 00:13:39,420
little cleaner and it looks for things

00:13:37,830 --> 00:13:41,730
that start with T underscore token

00:13:39,420 --> 00:13:43,740
underscore and then it looks in the doc

00:13:41,730 --> 00:13:45,030
string second weirdness and it takes a

00:13:43,740 --> 00:13:46,830
regular expression of the doc string

00:13:45,030 --> 00:13:51,210
okay this token is recognized by this

00:13:46,830 --> 00:13:53,430
red X and you take all these red X's and

00:13:51,210 --> 00:13:56,160
it jams them together into one enormous

00:13:53,430 --> 00:13:58,170
master reg X and puts pipes between them

00:13:56,160 --> 00:13:59,910
and gives them names so then it can take

00:13:58,170 --> 00:14:02,040
this red X and just keep running it

00:13:59,910 --> 00:14:04,140
against the next thing in the input

00:14:02,040 --> 00:14:05,580
stream over and over again which is

00:14:04,140 --> 00:14:08,910
great because all the iteration is done

00:14:05,580 --> 00:14:11,340
in you know fast C reg X C finite state

00:14:08,910 --> 00:14:14,460
machine land instead of Python for loop

00:14:11,340 --> 00:14:15,600
land which is much slower so we end up

00:14:14,460 --> 00:14:17,070
with the input stream broken down into

00:14:15,600 --> 00:14:21,180
toking tokens this is called

00:14:17,070 --> 00:14:23,250
tokenization or lexing and lex then we

00:14:21,180 --> 00:14:24,960
move on to the parsing phase you can see

00:14:23,250 --> 00:14:26,940
it as a similar dynamic recognition sort

00:14:24,960 --> 00:14:28,410
of thing for the parse rules and this is

00:14:26,940 --> 00:14:30,420
where the BNF really comes in you say

00:14:28,410 --> 00:14:32,190
okay so you found an internal link token

00:14:30,420 --> 00:14:32,920
did you that's the brace brace that

00:14:32,190 --> 00:14:37,750
racket bracket

00:14:32,920 --> 00:14:39,670
should say in America does it follow

00:14:37,750 --> 00:14:41,560
this pattern do I have one of those and

00:14:39,670 --> 00:14:44,589
then some texts and then an internal

00:14:41,560 --> 00:14:47,200
link and bracket bracket if so well this

00:14:44,589 --> 00:14:48,610
is the rule for me and you know we'll

00:14:47,200 --> 00:14:52,750
construct my tree like I say I'm

00:14:48,610 --> 00:14:55,990
constructing it below here p0 is the

00:14:52,750 --> 00:14:59,649
output and p1 would be I believe the

00:14:55,990 --> 00:15:02,500
texts so I may have that wrong look that

00:14:59,649 --> 00:15:04,959
up anyway it's this insistence on

00:15:02,500 --> 00:15:08,470
upfront tokenization that killed this

00:15:04,959 --> 00:15:10,149
for me if you take a look at media

00:15:08,470 --> 00:15:11,380
wiki's internal links syntax it's got

00:15:10,149 --> 00:15:12,790
these these brackets around it starts

00:15:11,380 --> 00:15:14,980
with bracket bracket so I was going to

00:15:12,790 --> 00:15:17,170
call that internal link trouble is

00:15:14,980 --> 00:15:20,380
sometimes that's not what bracket

00:15:17,170 --> 00:15:24,100
bracket means take a look at the second

00:15:20,380 --> 00:15:26,260
line now here is an abortive internal

00:15:24,100 --> 00:15:28,019
link but then just and we think we're

00:15:26,260 --> 00:15:30,399
going to end it we start another one and

00:15:28,019 --> 00:15:34,060
the way the red X is in MediaWiki work

00:15:30,399 --> 00:15:35,560
out it says oh oh crap I guess I guess

00:15:34,060 --> 00:15:37,810
that wasn't an internal link after all

00:15:35,560 --> 00:15:39,820
I'm so the first one is plain text okay

00:15:37,810 --> 00:15:45,550
yay and then we will enter the second

00:15:39,820 --> 00:15:47,730
one PL y or LR one things in general

00:15:45,550 --> 00:15:51,699
they don't take too kindly to that

00:15:47,730 --> 00:15:55,120
LR stands well the one anyway extent is

00:15:51,699 --> 00:15:58,329
the look-ahead amount so how far can my

00:15:55,120 --> 00:16:01,480
parser look ahead to decide which rule

00:15:58,329 --> 00:16:06,610
to invoke look ahead and what look ahead

00:16:01,480 --> 00:16:11,350
in the token stream so take a look down

00:16:06,610 --> 00:16:13,209
here I get the internal link thing maybe

00:16:11,350 --> 00:16:15,130
I can look ahead to the text that would

00:16:13,209 --> 00:16:17,199
be fine but I can't look ahead all the

00:16:15,130 --> 00:16:19,660
way to the end brace let alone the pipe

00:16:17,199 --> 00:16:21,430
and the the gerbil and then the end

00:16:19,660 --> 00:16:23,319
brace thing so what happens is it

00:16:21,430 --> 00:16:25,750
commits too early to this internal link

00:16:23,319 --> 00:16:27,310
thing doesn't find what's looking for

00:16:25,750 --> 00:16:28,810
and blows up and goes into error

00:16:27,310 --> 00:16:30,310
handling mode and you know error

00:16:28,810 --> 00:16:31,510
handling is a master's thesis in itself

00:16:30,310 --> 00:16:35,350
you don't you don't want to end up in

00:16:31,510 --> 00:16:38,079
error handling mode so the other trouble

00:16:35,350 --> 00:16:40,029
is you have to keep well here's the way

00:16:38,079 --> 00:16:42,670
around it what you can do if you only

00:16:40,029 --> 00:16:44,079
have certain small manageable instances

00:16:42,670 --> 00:16:45,540
of this in your grammar and you want to

00:16:44,079 --> 00:16:48,000
use a nice fast memory of

00:16:45,540 --> 00:16:50,130
lr 1 parser is you can start jamming

00:16:48,000 --> 00:16:51,750
look Ahead's in the regular expressions

00:16:50,130 --> 00:16:53,490
for your tokenization rule you can have

00:16:51,750 --> 00:16:55,949
them assert well not only do I have

00:16:53,490 --> 00:16:58,440
bracket bracket but I'm also going to

00:16:55,949 --> 00:16:59,850
have pipe and the the gerbil and I'm

00:16:58,440 --> 00:17:01,410
also going to have this other set of

00:16:59,850 --> 00:17:03,720
braces over here and unless all that

00:17:01,410 --> 00:17:06,510
matches I'm not the tokenization rule

00:17:03,720 --> 00:17:09,510
for you now what that means is that I've

00:17:06,510 --> 00:17:12,299
repeated stuff there and there and now I

00:17:09,510 --> 00:17:14,309
have to keep things in sync now one of

00:17:12,299 --> 00:17:16,169
my goals for this parser was I wanted to

00:17:14,309 --> 00:17:17,669
have something more maintainable than

00:17:16,169 --> 00:17:18,689
the current MediaWiki parser and I could

00:17:17,669 --> 00:17:22,429
see this is going to very quickly

00:17:18,689 --> 00:17:25,620
explode into unmaintainable 'ti so

00:17:22,429 --> 00:17:28,970
unfortunately the LR 1 parsers were out

00:17:25,620 --> 00:17:32,220
and I had to move on to the next thing

00:17:28,970 --> 00:17:34,490
yes I could look ahead that far but not

00:17:32,220 --> 00:17:37,530
that far

00:17:34,490 --> 00:17:39,690
pshhh new so it's time to go shopping

00:17:37,530 --> 00:17:41,429
again and by this time my google Summer

00:17:39,690 --> 00:17:43,440
of Code project had begun and I had a

00:17:41,429 --> 00:17:47,309
shiny new grad student from France

00:17:43,440 --> 00:17:50,250
Peter Patrol now I've done a little

00:17:47,309 --> 00:17:51,870
research in the interim and I had

00:17:50,250 --> 00:17:54,030
narrowed it down to two classes of

00:17:51,870 --> 00:17:57,000
algorithms the early parsing algorithm

00:17:54,030 --> 00:17:59,490
which still might be promising and pe

00:17:57,000 --> 00:18:00,630
G's parsing expression grammars and this

00:17:59,490 --> 00:18:02,909
is kind of the new hotness that were

00:18:00,630 --> 00:18:06,630
introduced in a paper and once a 2004 by

00:18:02,909 --> 00:18:10,020
Brian Ford and they're also used by

00:18:06,630 --> 00:18:11,580
sweevil which is a Java based parser

00:18:10,020 --> 00:18:13,350
that succeeds in parsing all the

00:18:11,580 --> 00:18:18,240
MediaWiki corpus so I knew that

00:18:13,350 --> 00:18:20,159
theoretically it could work what I liked

00:18:18,240 --> 00:18:21,840
about it was that this is actually how

00:18:20,159 --> 00:18:24,179
you program it this is what you hand it

00:18:21,840 --> 00:18:27,240
you hand it pretty much vanilla BNF it's

00:18:24,179 --> 00:18:28,799
very nice it's great for developing the

00:18:27,240 --> 00:18:30,990
grammar we got it working

00:18:28,799 --> 00:18:33,990
it'll parse MediaWiki it makes a parse

00:18:30,990 --> 00:18:35,610
tree it'll output HTML it'll output text

00:18:33,990 --> 00:18:37,049
it'll output the raw tree you can do

00:18:35,610 --> 00:18:38,630
whatever you want it's up on it's up on

00:18:37,049 --> 00:18:41,250
github you can have a look if you like

00:18:38,630 --> 00:18:41,990
it's not pretty but it does work read

00:18:41,250 --> 00:18:45,059
the readme

00:18:41,990 --> 00:18:47,040
what I didn't like was that a patient

00:18:45,059 --> 00:18:49,559
who doesn't have any tests B it's kind

00:18:47,040 --> 00:18:51,179
of weird it's not really written Python

00:18:49,559 --> 00:18:52,200
eclis the doc strings I've like single

00:18:51,179 --> 00:18:56,880
quotes around them it's just kind of

00:18:52,200 --> 00:18:59,220
bizarre it's slow right now it takes 3

00:18:56,880 --> 00:19:03,310
seconds to render

00:18:59,220 --> 00:19:07,840
93 line wiki page and it takes a hundred

00:19:03,310 --> 00:19:09,190
and seventy Meg of RAM the author didn't

00:19:07,840 --> 00:19:11,170
do any optimization he said I didn't do

00:19:09,190 --> 00:19:12,580
any optimization he said I did this for

00:19:11,170 --> 00:19:14,020
understandability and that's great it

00:19:12,580 --> 00:19:16,830
really helped us develop the grammar and

00:19:14,020 --> 00:19:16,830
I gotta hand it to it

00:19:17,400 --> 00:19:23,620
my last complaint would be take a look

00:19:19,690 --> 00:19:25,750
over to the right here you have these

00:19:23,620 --> 00:19:29,320
things hanging off your rules which is

00:19:25,750 --> 00:19:31,270
which are alcohol tree transforms so it

00:19:29,320 --> 00:19:34,030
makes the tree and then while it's

00:19:31,270 --> 00:19:36,130
making the tree it'll run these things

00:19:34,030 --> 00:19:37,570
over the nodes it's creating its and

00:19:36,130 --> 00:19:39,190
replace them with the results of these

00:19:37,570 --> 00:19:41,470
things so it wants to render the

00:19:39,190 --> 00:19:43,420
internal link syntax to HTML as it's

00:19:41,470 --> 00:19:45,670
parsing which kind of freaks me out I

00:19:43,420 --> 00:19:47,620
would rather have the tree get it clean

00:19:45,670 --> 00:19:50,110
and then move it over here and then

00:19:47,620 --> 00:19:51,580
separately walk it and turn it into a

00:19:50,110 --> 00:19:53,710
syntax because maybe I want to build a

00:19:51,580 --> 00:19:54,820
wiki thing and a text thing and send it

00:19:53,710 --> 00:19:58,000
out an email I want to have to like

00:19:54,820 --> 00:19:59,380
parse it twice just for that and then

00:19:58,000 --> 00:20:01,270
third the grammar wasn't really

00:19:59,380 --> 00:20:03,700
extensible you have this stuff in a text

00:20:01,270 --> 00:20:06,220
file and there's no real way to insert

00:20:03,700 --> 00:20:09,430
more rules over time like I wanted to do

00:20:06,220 --> 00:20:13,150
with my for directive I'd have to build

00:20:09,430 --> 00:20:18,900
my own accessibility framework and so I

00:20:13,150 --> 00:20:21,490
come at last to writing my own I'm

00:20:18,900 --> 00:20:23,650
working on this called parsimonious and

00:20:21,490 --> 00:20:26,440
my primary goal is for it to go real

00:20:23,650 --> 00:20:27,940
fast no more three second wiki pages

00:20:26,440 --> 00:20:29,410
this thing has to go fast enough that we

00:20:27,940 --> 00:20:31,660
don't have to you know render everything

00:20:29,410 --> 00:20:33,430
ahead of time in cache at this point

00:20:31,660 --> 00:20:35,080
it's an ego thing I'm no longer working

00:20:33,430 --> 00:20:38,440
on that Mozilla project but now I'm

00:20:35,080 --> 00:20:41,890
interested in the problem so to make

00:20:38,440 --> 00:20:44,200
something like this go fast we can do

00:20:41,890 --> 00:20:47,020
what PI parsing does and what page new

00:20:44,200 --> 00:20:48,700
does is use the PAC read algorithm which

00:20:47,020 --> 00:20:50,560
basically means these things are

00:20:48,700 --> 00:20:52,360
recursive descent parsers they try to

00:20:50,560 --> 00:20:53,440
parse the bold thing so you're you know

00:20:52,360 --> 00:20:55,150
or the internal link thing let's just

00:20:53,440 --> 00:20:56,560
use that as an example oh you look like

00:20:55,150 --> 00:20:59,650
an internal link I see the double brace

00:20:56,560 --> 00:21:01,210
oh oh and here's the title oh oh well

00:20:59,650 --> 00:21:02,500
there's no pipe and there's no end okay

00:21:01,210 --> 00:21:04,840
I guess I screwed up let me let me just

00:21:02,500 --> 00:21:06,940
go back I'll go back up here okay so I

00:21:04,840 --> 00:21:09,499
guess your plain text

00:21:06,940 --> 00:21:11,090
so what we can do is we can cache the

00:21:09,499 --> 00:21:12,799
intermediate steps sometimes there you'd

00:21:11,090 --> 00:21:14,179
end up walking back up and then back

00:21:12,799 --> 00:21:15,950
down past something you've already

00:21:14,179 --> 00:21:17,629
parsed and you don't want to have to do

00:21:15,950 --> 00:21:19,519
that twice there's no reason to parse

00:21:17,629 --> 00:21:21,529
something twice so a packrat algorithm

00:21:19,519 --> 00:21:23,690
just part caches every single

00:21:21,529 --> 00:21:28,129
intermediate result hence the 170 Meg of

00:21:23,690 --> 00:21:29,720
RAM so my second goal is to use well to

00:21:28,129 --> 00:21:30,710
be short because I want to be 3000 lines

00:21:29,720 --> 00:21:33,169
long because why do these things have to

00:21:30,710 --> 00:21:36,700
be 3,000 lines long when I play 4,000

00:21:33,169 --> 00:21:38,809
lines long when we frugal with RAM

00:21:36,700 --> 00:21:41,269
understandable I have a lot of trouble

00:21:38,809 --> 00:21:41,869
reading existing parsing libs uh see

00:21:41,269 --> 00:21:44,840
what I can do

00:21:41,869 --> 00:21:49,100
I want awesome awesome readable

00:21:44,840 --> 00:21:52,029
extensible grammars I would like

00:21:49,100 --> 00:21:54,320
complete test coverage please and

00:21:52,029 --> 00:21:55,970
something I'm trying with this is I'm

00:21:54,320 --> 00:21:57,200
actually expressing my benchmarks I'm

00:21:55,970 --> 00:21:58,669
benchmarking from the very beginning

00:21:57,200 --> 00:22:01,730
before I actually make any assumptions

00:21:58,669 --> 00:22:03,919
I'm expressing each of my optimizations

00:22:01,730 --> 00:22:08,269
as tests so for example I have a test

00:22:03,919 --> 00:22:12,830
here that tests whether slots user isn't

00:22:08,269 --> 00:22:14,629
faster than class dicts and I figure out

00:22:12,830 --> 00:22:17,419
which is faster I use it a lot this

00:22:14,629 --> 00:22:19,369
faster and then I assert it in my test

00:22:17,419 --> 00:22:20,899
and then if that ever changes or if I

00:22:19,369 --> 00:22:22,369
run on pipeline it changes if I run on

00:22:20,899 --> 00:22:23,419
Jai thon that changes my test will say

00:22:22,369 --> 00:22:26,809
hey you know your optimization

00:22:23,419 --> 00:22:28,869
assumption is no longer valid so aside

00:22:26,809 --> 00:22:30,919
from the tests I also would like

00:22:28,869 --> 00:22:33,440
separation of tree building and

00:22:30,919 --> 00:22:35,419
formatting thank you very much and I

00:22:33,440 --> 00:22:36,799
want the thing to hold my hand and Pat

00:22:35,419 --> 00:22:38,509
my back while I'm building these

00:22:36,799 --> 00:22:41,230
grammars these things are hard enough I

00:22:38,509 --> 00:22:43,460
want really good error messages maybe

00:22:41,230 --> 00:22:46,700
maybe some terminal magic I don't know

00:22:43,460 --> 00:22:49,399
we'll see something interactive frats it

00:22:46,700 --> 00:22:53,509
kind of works it has enough in it to

00:22:49,399 --> 00:22:55,220
parse its own sort of BNF stuff I'm kind

00:22:53,509 --> 00:22:56,779
of specifying rules in a text format

00:22:55,220 --> 00:22:59,059
because that gives me all kinds of

00:22:56,779 --> 00:23:00,169
freedom we can do circular references

00:22:59,059 --> 00:23:01,999
without having to declare forward

00:23:00,169 --> 00:23:04,820
references we can do whatever we want we

00:23:01,999 --> 00:23:06,830
can do straight-out BNF we don't have to

00:23:04,820 --> 00:23:09,169
bow to limitations in the Python

00:23:06,830 --> 00:23:10,850
language and because we're not throwing

00:23:09,169 --> 00:23:12,740
anything away by the time we get the

00:23:10,850 --> 00:23:14,720
representation we can do all kinds of

00:23:12,740 --> 00:23:18,230
optimizations like there's this really

00:23:14,720 --> 00:23:19,299
cool paper on cuts in PE G and what it

00:23:18,230 --> 00:23:22,749
does is it

00:23:19,299 --> 00:23:24,730
- - amortized constant RAM usage even

00:23:22,749 --> 00:23:26,739
when you're doing packrat caching it

00:23:24,730 --> 00:23:28,269
says you know if you get this far well

00:23:26,739 --> 00:23:31,809
you can throw away all those cash things

00:23:28,269 --> 00:23:34,809
because we had going back so give us all

00:23:31,809 --> 00:23:38,289
those opportunities cool stuff I want to

00:23:34,809 --> 00:23:39,460
leave some time for questions so thanks

00:23:38,289 --> 00:23:41,110
to everybody who creative common

00:23:39,460 --> 00:23:43,929
licenses their stuff on Flickr I love

00:23:41,110 --> 00:23:46,869
your pictures it's great and now I want

00:23:43,929 --> 00:23:48,999
to open it up for burning questions what

00:23:46,869 --> 00:23:50,919
are your projects what horrible things

00:23:48,999 --> 00:23:56,279
are you trying to parse what was I

00:23:50,919 --> 00:23:56,279
unclear about big empty room

00:24:02,620 --> 00:24:07,240
oh and if you're shopping for parsers

00:24:05,020 --> 00:24:09,760
this last thing here deep in our

00:24:07,240 --> 00:24:12,279
MediaWiki repository is a shopping list

00:24:09,760 --> 00:24:15,100
of maybe two dozen Python parsing

00:24:12,279 --> 00:24:17,740
libraries that I looked at while I was

00:24:15,100 --> 00:24:19,120
trying to figure out what to do and lots

00:24:17,740 --> 00:24:21,669
of bullet points pros and cons

00:24:19,120 --> 00:24:28,150
suitability unsuitability I hope someone

00:24:21,669 --> 00:24:36,100
finds useful any questions thank you

00:24:28,150 --> 00:24:37,690
very much oh oh oh sorry um so you you

00:24:36,100 --> 00:24:39,909
just answer my question which is did you

00:24:37,690 --> 00:24:42,760
look at pie peg or pie maeda or any

00:24:39,909 --> 00:24:43,809
other peg parsers yes go buy monoghan

00:24:42,760 --> 00:24:47,110
okay

00:24:43,809 --> 00:24:50,350
yes pie maida I like a lot let's see

00:24:47,110 --> 00:24:52,090
what I said about it I think my Mota the

00:24:50,350 --> 00:24:53,620
thing that really scared me away from it

00:24:52,090 --> 00:24:55,240
was something stupid which is that it

00:24:53,620 --> 00:24:58,360
hadn't seen any inner talent standing

00:24:55,240 --> 00:24:59,559
behind you who wrote oh yeah - I wonder

00:24:58,360 --> 00:25:00,789
if they hadn't seen any commits for a

00:24:59,559 --> 00:25:02,230
year I guess Alan's been trying to get

00:25:00,789 --> 00:25:05,950
it adopted and that would've been a

00:25:02,230 --> 00:25:10,289
perfectly good choice yeah okay thanks

00:25:05,950 --> 00:25:13,360
sure hi I'm Alan and I wrote pie meta

00:25:10,289 --> 00:25:17,529
awesome talk I wondered what your

00:25:13,360 --> 00:25:19,360
thoughts on air-handling work uh yeah me

00:25:17,529 --> 00:25:20,980
too what you said it's a master's thesis

00:25:19,360 --> 00:25:23,860
in itself and you don't want to go there

00:25:20,980 --> 00:25:24,279
yeah I haven't written that thesis me

00:25:23,860 --> 00:25:26,409
neither

00:25:24,279 --> 00:25:28,179
my thoughts are I'm tired of looking at

00:25:26,409 --> 00:25:30,130
recursive trace backs I'm tired of

00:25:28,179 --> 00:25:33,070
looking at dumps of text I would like

00:25:30,130 --> 00:25:34,600
something more interactive I would like

00:25:33,070 --> 00:25:36,360
it to say you know here's your line of

00:25:34,600 --> 00:25:38,860
text or whatever unit is you're parsing

00:25:36,360 --> 00:25:41,440
make the underline move along as you're

00:25:38,860 --> 00:25:43,899
parsing it and then you know blow up and

00:25:41,440 --> 00:25:46,080
recurse when it doesn't let you step

00:25:43,899 --> 00:25:48,730
forward in time and backward in time and

00:25:46,080 --> 00:25:51,399
tell McNeal put arrows at point arrows

00:25:48,730 --> 00:25:55,149
at things put use the spatial terminal

00:25:51,399 --> 00:25:55,630
it doesn't have to be line based I like

00:25:55,149 --> 00:25:58,059
that idea

00:25:55,630 --> 00:25:58,990
let's build a visualizer for that we can

00:25:58,059 --> 00:26:02,100
sprint on that when we're not getting

00:25:58,990 --> 00:26:06,240
other things thank you you're welcome

00:26:02,100 --> 00:26:09,340
hi there um so this builds an AST right

00:26:06,240 --> 00:26:11,830
absolutely do you have the ability to

00:26:09,340 --> 00:26:14,320
associate callbacks so that when you

00:26:11,830 --> 00:26:15,879
parse particulars like the other example

00:26:14,320 --> 00:26:18,609
that you the other tool

00:26:15,879 --> 00:26:20,709
you gave an example of so that when you

00:26:18,609 --> 00:26:22,089
come to an element you can say boom I

00:26:20,709 --> 00:26:24,639
recognize it and take more of a

00:26:22,089 --> 00:26:26,559
streaming approach I guess sax versus

00:26:24,639 --> 00:26:27,039
Dom kind of thing yeah excellent

00:26:26,559 --> 00:26:30,279
question

00:26:27,039 --> 00:26:31,779
so yeah what do I do about node

00:26:30,279 --> 00:26:33,519
processors how do I walk a tree how do I

00:26:31,779 --> 00:26:34,899
transform it into something I want the

00:26:33,519 --> 00:26:35,229
tree I don't want to walk it as I'm

00:26:34,899 --> 00:26:37,899
going

00:26:35,229 --> 00:26:41,440
it's just philosophically but I don't

00:26:37,899 --> 00:26:43,359
leave you hanging there's you can't see

00:26:41,440 --> 00:26:47,859
that at all can you look at that no

00:26:43,359 --> 00:26:51,819
don't I do

00:26:47,859 --> 00:26:54,279
give you this not that this thing note

00:26:51,819 --> 00:26:56,079
visitor which is a lot like the visitor

00:26:54,279 --> 00:26:57,219
in the Python ast library kind of

00:26:56,079 --> 00:27:00,819
patterned after that works pretty well

00:26:57,219 --> 00:27:03,909
and all you have to do is fact I pull up

00:27:00,819 --> 00:27:06,069
my grammar thing you can see one here's

00:27:03,909 --> 00:27:10,869
the here's the visitor that turns the

00:27:06,069 --> 00:27:13,599
tree ization of my bigger finger bigger

00:27:10,869 --> 00:27:16,089
bigger bigger now it's rapid funny turns

00:27:13,599 --> 00:27:19,209
the BNF thing into useful structures in

00:27:16,089 --> 00:27:20,919
actually parse you say things like visit

00:27:19,209 --> 00:27:22,779
quantified and then nodes that are

00:27:20,919 --> 00:27:24,399
called quantified end up calling this

00:27:22,779 --> 00:27:27,369
and you can return what you want from

00:27:24,399 --> 00:27:30,659
them so hold your hand to helps you out

00:27:27,369 --> 00:27:30,659
cool thank you you're welcome

00:27:31,649 --> 00:27:39,099
hello has unicode also made your parsing

00:27:36,459 --> 00:27:40,419
problems harder and if so would any of

00:27:39,099 --> 00:27:42,459
the library is better for dealing with

00:27:40,419 --> 00:27:45,190
with unicode parsing problems than

00:27:42,459 --> 00:27:46,479
others choose new is okay for unicode

00:27:45,190 --> 00:27:49,119
input this is something we cared a lot

00:27:46,479 --> 00:27:50,679
about for the mozilla wiki because we

00:27:49,119 --> 00:27:55,299
have 80 languages we support including

00:27:50,679 --> 00:27:57,909
CJK stuff so yeah unicode rules and

00:27:55,299 --> 00:28:00,399
unicode input both work fine in kujou i

00:27:57,909 --> 00:28:02,019
think they work fine in pi parsing also

00:28:00,399 --> 00:28:07,179
because i know it's very Python three

00:28:02,019 --> 00:28:08,589
savvy this will has to the thing about

00:28:07,179 --> 00:28:11,649
the only other thing i can think about

00:28:08,589 --> 00:28:13,239
unicode is depending on internal

00:28:11,649 --> 00:28:15,399
representation it can be hard to slice

00:28:13,239 --> 00:28:17,409
unicode efficiently and say well what

00:28:15,399 --> 00:28:18,879
offset am i at but you can just use a

00:28:17,409 --> 00:28:21,789
lot of ram and use some kind of fixed

00:28:18,879 --> 00:28:23,319
width encoding because for instance in

00:28:21,789 --> 00:28:25,869
pi parsing one of the things that was

00:28:23,319 --> 00:28:27,399
difficult for was it really wants to

00:28:25,869 --> 00:28:29,169
have like a list of characters that

00:28:27,399 --> 00:28:29,470
you're looking for or you have to fall

00:28:29,169 --> 00:28:31,690
back

00:28:29,470 --> 00:28:34,380
regular expressions and even just saying

00:28:31,690 --> 00:28:36,280
alphanumeric please got so much harder

00:28:34,380 --> 00:28:38,679
so you want to be able to say

00:28:36,280 --> 00:28:41,890
alphanumeric and have that localized

00:28:38,679 --> 00:28:44,440
ibly interpreted it or even the full set

00:28:41,890 --> 00:28:45,460
of what alphanumeric means in Unicode I

00:28:44,440 --> 00:28:48,610
think that's a great idea

00:28:45,460 --> 00:28:52,630
I don't know thank you

00:28:48,610 --> 00:28:55,120
I was wondering if you'd looked at

00:28:52,630 --> 00:28:57,400
antler and the Python battlin or the

00:28:55,120 --> 00:28:59,650
Python bindings - antler

00:28:57,400 --> 00:29:03,549
I have not familiar with amber what is

00:28:59,650 --> 00:29:06,720
an antler antler yes there is a Python

00:29:03,549 --> 00:29:10,000
antler thing and let me see if I can

00:29:06,720 --> 00:29:14,470
figure out what was a deal with that

00:29:10,000 --> 00:29:16,090
antler I can't spell antler so antler

00:29:14,470 --> 00:29:17,650
yeah I had a separate code generation

00:29:16,090 --> 00:29:19,090
steps that I didn't like I didn't want

00:29:17,650 --> 00:29:23,919
to build step because I wanted to be

00:29:19,090 --> 00:29:27,190
able to extend these grammars without

00:29:23,919 --> 00:29:28,450
having to rebuild and it's also ends up

00:29:27,190 --> 00:29:30,580
slow in Python because it generates a

00:29:28,450 --> 00:29:31,840
whole lot of function calls which is a

00:29:30,580 --> 00:29:35,710
hash like of every time you do anything

00:29:31,840 --> 00:29:37,240
in Python arbitrary look-ahead is

00:29:35,710 --> 00:29:39,190
fantastic I mean you don't have that

00:29:37,240 --> 00:29:45,010
look-ahead problem LR once you can parse

00:29:39,190 --> 00:29:47,049
llk with it about getting the name of

00:29:45,010 --> 00:29:48,940
the variable that gets their return

00:29:47,049 --> 00:29:50,350
value of a function it's very useful if

00:29:48,940 --> 00:29:53,049
you don't want to repeat yourself and

00:29:50,350 --> 00:29:56,500
what you can do is disassemble the code

00:29:53,049 --> 00:29:58,150
of the upper frame and you get the name

00:29:56,500 --> 00:29:59,950
of the variable can you just deal with

00:29:58,150 --> 00:30:02,200
inspector do you have to actually go and

00:29:59,950 --> 00:30:04,330
do that it's assembly model this it has

00:30:02,200 --> 00:30:08,590
this dot this and you can pass it sis

00:30:04,330 --> 00:30:11,169
dot get frame and gets one one frame

00:30:08,590 --> 00:30:12,429
above you and you can get awesome now

00:30:11,169 --> 00:30:14,679
that you mention it philippi be used to

00:30:12,429 --> 00:30:16,330
do that in peak so yeah that's that's a

00:30:14,679 --> 00:30:21,280
good well stranger it's a weird idea

00:30:16,330 --> 00:30:22,900
very worthy inappropriate as I apologize

00:30:21,280 --> 00:30:24,309
we're sort of running out of time for

00:30:22,900 --> 00:30:28,169
questions here but everyone once again

00:30:24,309 --> 00:30:28,169

YouTube URL: https://www.youtube.com/watch?v=tCUdeLIj4hE


