Title: Code Generation in Python: Dismantling Jinja
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Armin Ronacher
For many DSLs such as templating languages it's important to use code generation to achieve acceptable performance in Python.  The current version of Jinja went through many different iterations to end up where it is currently.  This t
Captions: 
	00:00:00,030 --> 00:00:05,940
I'm picture of Browns campus name right

00:00:02,790 --> 00:00:08,940
arming run have the right what AHA

00:00:05,940 --> 00:00:11,160
run aha Armen run aha and he stuck it's

00:00:08,940 --> 00:00:13,590
about cogeneration in Python this

00:00:11,160 --> 00:00:16,370
mantling ginger so please give him a big

00:00:13,590 --> 00:00:16,370
round of applause

00:00:22,060 --> 00:00:27,020
hello everybody welcome to cogeneration

00:00:24,560 --> 00:00:29,480
peyten dismantling ginger

00:00:27,020 --> 00:00:31,040
my name is Amina hor-aha I'm the

00:00:29,480 --> 00:00:36,130
developer behind the ginger templating

00:00:31,040 --> 00:00:39,260
engine and this is a recap of basically

00:00:36,130 --> 00:00:43,340
changes in how cogeneration can be done

00:00:39,260 --> 00:00:45,770
in peyten since version 2.3 now to

00:00:43,340 --> 00:00:47,000
peyten 3.0 because they're a bunch of

00:00:45,770 --> 00:00:49,370
changes over the last couple of years

00:00:47,000 --> 00:00:51,500
and change it to originally started out

00:00:49,370 --> 00:00:54,559
as an engine that supported python 2.3

00:00:51,500 --> 00:00:55,909
and it's those supports 2.4 but there

00:00:54,559 --> 00:00:58,489
are a bunch of developments that make

00:00:55,909 --> 00:01:00,110
cogeneration more interesting and then

00:00:58,489 --> 00:01:05,960
obviously why would you do cogeneration

00:01:00,110 --> 00:01:08,990
the first place for D was called discuss

00:01:05,960 --> 00:01:11,720
mini sites there is a short link at

00:01:08,990 --> 00:01:14,330
least cogeneration and then you can drop

00:01:11,720 --> 00:01:17,270
various feed back in there if you want

00:01:14,330 --> 00:01:20,360
to do so alright so why would you do

00:01:17,270 --> 00:01:24,380
cogeneration isn't cogeneration really

00:01:20,360 --> 00:01:26,450
evil and the question here is why would

00:01:24,380 --> 00:01:28,550
cogeneration be actually evil and many

00:01:26,450 --> 00:01:30,740
people say the problem with cogeneration

00:01:28,550 --> 00:01:32,990
or evaluating code is that it's a

00:01:30,740 --> 00:01:35,150
security problem and it's actually

00:01:32,990 --> 00:01:36,800
really bad for performance but I would

00:01:35,150 --> 00:01:39,370
argue that none of these cases are true

00:01:36,800 --> 00:01:41,960
if you do proper cogeneration peyten

00:01:39,370 --> 00:01:44,030
the first thing is that security-wise

00:01:41,960 --> 00:01:46,520
cogeneration piping is actually pretty

00:01:44,030 --> 00:01:48,740
secure and the reason for this is that a

00:01:46,520 --> 00:01:51,650
lot of the built-in functions

00:01:48,740 --> 00:01:54,350
sorry the built-in literals in Python

00:01:51,650 --> 00:01:57,290
have a string representation that can be

00:01:54,350 --> 00:02:00,200
evaluated directly into Python code

00:01:57,290 --> 00:02:02,390
again so you can call wrapper on any of

00:02:00,200 --> 00:02:04,520
the built-in types and you get a

00:02:02,390 --> 00:02:08,989
representation of the object back that

00:02:04,520 --> 00:02:12,590
would evaluate to the proper object

00:02:08,989 --> 00:02:16,099
again and the other argument security

00:02:12,590 --> 00:02:18,890
wise would be that you can pollute your

00:02:16,099 --> 00:02:20,980
namespace by evaluating random code so

00:02:18,890 --> 00:02:24,459
it could change local variables and

00:02:20,980 --> 00:02:26,840
Titan has excellent support for

00:02:24,459 --> 00:02:29,360
evaluating codes in a different

00:02:26,840 --> 00:02:32,960
namespace so this could be mitigated as

00:02:29,360 --> 00:02:35,000
well when it comes to performance the

00:02:32,960 --> 00:02:35,250
only alternative to cogeneration pylons

00:02:35,000 --> 00:02:37,700
like

00:02:35,250 --> 00:02:41,850
right an interpreter on top of piping

00:02:37,700 --> 00:02:44,760
which is not really helping it and you

00:02:41,850 --> 00:02:47,160
have code that creates code the relic

00:02:44,760 --> 00:02:48,840
code runs which sounds really slow but

00:02:47,160 --> 00:02:51,959
it's a lot faster than having codes that

00:02:48,840 --> 00:02:55,560
code interprets on top of the piping

00:02:51,959 --> 00:02:56,610
virtual machine alright so why do we do

00:02:55,560 --> 00:03:01,530
it because there are no suitable

00:02:56,610 --> 00:03:03,390
alternatives so use responsibly here is

00:03:01,530 --> 00:03:05,220
quick introduction of how evaluating

00:03:03,390 --> 00:03:09,870
code in piping works if you do it right

00:03:05,220 --> 00:03:14,280
so evil 101 the first thing is you

00:03:09,870 --> 00:03:16,950
compile an arbitrary string into a code

00:03:14,280 --> 00:03:18,360
object and there are three arguments for

00:03:16,950 --> 00:03:20,400
the building compile function the first

00:03:18,360 --> 00:03:22,709
one is the code you want to compile I'm

00:03:20,400 --> 00:03:24,959
fighting to do this typically a byte

00:03:22,709 --> 00:03:27,330
string I'm fightin three it is a unicode

00:03:24,959 --> 00:03:29,610
string the second argument is the file

00:03:27,330 --> 00:03:33,060
name that corresponds to this piece of

00:03:29,610 --> 00:03:34,709
code in this case piden recommends that

00:03:33,060 --> 00:03:38,400
if it's not coming from an actual file

00:03:34,709 --> 00:03:42,450
you put these brackets around this ring

00:03:38,400 --> 00:03:46,160
and the third argument basically tells

00:03:42,450 --> 00:03:48,840
the compiler what the context of this

00:03:46,160 --> 00:03:51,360
piece of code is it could be exact in

00:03:48,840 --> 00:03:52,230
which case it contains any of any

00:03:51,360 --> 00:03:54,510
statements

00:03:52,230 --> 00:03:56,400
it could be evolve in which case it can

00:03:54,510 --> 00:03:58,380
only be an expression and there's assert

00:03:56,400 --> 00:04:01,519
I've called single which is used by the

00:03:58,380 --> 00:04:05,670
interactive Titan shell where the last

00:04:01,519 --> 00:04:07,799
the last expression in a list of

00:04:05,670 --> 00:04:11,790
statements can actually be printed to

00:04:07,799 --> 00:04:13,230
send it out and what you get back is a

00:04:11,790 --> 00:04:14,850
code object and this code object

00:04:13,230 --> 00:04:16,290
basically contains all the information

00:04:14,850 --> 00:04:19,950
that the pipe interpreter needs to

00:04:16,290 --> 00:04:21,630
evaluate this code if you want to

00:04:19,950 --> 00:04:23,820
evaluate it in fighting two you would

00:04:21,630 --> 00:04:25,860
create if you do it properly you create

00:04:23,820 --> 00:04:28,050
the dictionary as the namespace and then

00:04:25,860 --> 00:04:30,540
you exit code in namespace this is a

00:04:28,050 --> 00:04:33,570
syntax not everybody knows in Python 3

00:04:30,540 --> 00:04:37,110
the exit statement is not a function you

00:04:33,570 --> 00:04:39,690
do exact code comma name space and then

00:04:37,110 --> 00:04:41,910
parenthesis closed and the code that is

00:04:39,690 --> 00:04:44,700
executed is then executed in the context

00:04:41,910 --> 00:04:47,650
of this dictionary only so here we have

00:04:44,700 --> 00:04:49,570
a equals 1 plus 2

00:04:47,650 --> 00:04:52,810
and we if we evaluate this in the

00:04:49,570 --> 00:04:55,930
namespace there's a key one key a which

00:04:52,810 --> 00:04:57,820
is the value Sri so this is what was

00:04:55,930 --> 00:04:59,860
always possible with biting starting

00:04:57,820 --> 00:05:02,380
from two point three which is basically

00:04:59,860 --> 00:05:04,150
how ginger works internally when you

00:05:02,380 --> 00:05:06,460
have tightened to point six or later

00:05:04,150 --> 00:05:09,190
there is a better way to do this you

00:05:06,460 --> 00:05:10,750
could create an ast object and there are

00:05:09,190 --> 00:05:13,389
two ways to do that the first one is you

00:05:10,750 --> 00:05:15,880
can take a string and parse it into an

00:05:13,389 --> 00:05:20,440
AST tree is this short for abstract

00:05:15,880 --> 00:05:22,479
syntax tree and you basically use AST to

00:05:20,440 --> 00:05:26,229
parse give it a string you want to parse

00:05:22,479 --> 00:05:28,030
and then you get back a node and this

00:05:26,229 --> 00:05:30,310
node can then be again compiled into

00:05:28,030 --> 00:05:33,400
byte code so what's the purpose of this

00:05:30,310 --> 00:05:36,039
node you can create it yourself or you

00:05:33,400 --> 00:05:40,289
can modify it basically all the syntax

00:05:36,039 --> 00:05:43,810
rules that pythons contains of are

00:05:40,289 --> 00:05:46,479
compiled into these nodes into three of

00:05:43,810 --> 00:05:48,400
these nodes and the whole expression a

00:05:46,479 --> 00:05:51,729
equals one plus two can also be written

00:05:48,400 --> 00:05:54,729
as an ast module which takes one node

00:05:51,729 --> 00:05:56,410
which is an assignment and in this

00:05:54,729 --> 00:05:59,470
assignment we assigned to the variable a

00:05:56,410 --> 00:06:01,030
and every time we use a name or anything

00:05:59,470 --> 00:06:04,090
it can be used for reading and writing

00:06:01,030 --> 00:06:05,770
we also have to notify it if it's used

00:06:04,090 --> 00:06:08,590
for storing or for loading in this case

00:06:05,770 --> 00:06:12,909
we store into a and then the binary

00:06:08,590 --> 00:06:14,199
expression 1 plus 2 the last thing that

00:06:12,909 --> 00:06:16,990
is necessary before we can actually

00:06:14,199 --> 00:06:19,780
compile this is we need to specify line

00:06:16,990 --> 00:06:23,229
numbers and columns on every single node

00:06:19,780 --> 00:06:24,340
and there is a handy function called fix

00:06:23,229 --> 00:06:26,260
missing locations which will

00:06:24,340 --> 00:06:28,270
automatically add the missing

00:06:26,260 --> 00:06:30,190
information in this case it will always

00:06:28,270 --> 00:06:33,280
add one line one to every single

00:06:30,190 --> 00:06:35,800
expression what if we would have line

00:06:33,280 --> 00:06:38,500
numbers at least on the assignment note

00:06:35,800 --> 00:06:39,970
it would just propagate the line number

00:06:38,500 --> 00:06:43,150
of the assignment notes to all inner

00:06:39,970 --> 00:06:46,180
nodes so if you would assign ast assign

00:06:43,150 --> 00:06:48,220
the line number to the name and the

00:06:46,180 --> 00:06:50,860
binary operators and the number would

00:06:48,220 --> 00:06:54,220
also be stored in line two and then we

00:06:50,860 --> 00:06:56,409
can compile it and execute it again so

00:06:54,220 --> 00:07:00,099
this is the basic summary of how this

00:06:56,409 --> 00:07:01,290
works you don't pass strings directly to

00:07:00,099 --> 00:07:03,630
evolve you

00:07:01,290 --> 00:07:05,250
hilum first a reason for that is that

00:07:03,630 --> 00:07:07,110
you can actually keep the code up

00:07:05,250 --> 00:07:09,270
checked around so you have the whole

00:07:07,110 --> 00:07:11,580
advantage of not having to reparse and

00:07:09,270 --> 00:07:14,610
reevaluate the whole thing again all you

00:07:11,580 --> 00:07:15,840
have to do is you have to keep this code

00:07:14,610 --> 00:07:17,810
object around and they've heightened

00:07:15,840 --> 00:07:20,190
interpreter will then use the

00:07:17,810 --> 00:07:23,700
instructions on this code object to

00:07:20,190 --> 00:07:25,410
execute the code and this means to have

00:07:23,700 --> 00:07:28,200
you have an explicit compilation to

00:07:25,410 --> 00:07:30,600
bytecode and then you can execute it an

00:07:28,200 --> 00:07:35,400
explicit namespaces and you avoid the

00:07:30,600 --> 00:07:37,710
problem of polluting your namespace all

00:07:35,400 --> 00:07:39,960
right so if we look at how each entry

00:07:37,710 --> 00:07:43,380
internally works there's a very basic

00:07:39,960 --> 00:07:45,810
architecture changer as I mentioned

00:07:43,380 --> 00:07:48,570
earlier exists since fighting 2.4 so

00:07:45,810 --> 00:07:51,210
it's actually quite old and how the code

00:07:48,570 --> 00:07:53,490
paste works internally but there was

00:07:51,210 --> 00:07:57,390
actually a first version of ginger

00:07:53,490 --> 00:08:00,150
before that which had an even more an

00:07:57,390 --> 00:08:02,670
even simpler compilation model we

00:08:00,150 --> 00:08:05,430
quickly get to the difference between

00:08:02,670 --> 00:08:06,690
ginger 1 and Fincher 2 later the

00:08:05,430 --> 00:08:08,370
important part is that changes the

00:08:06,690 --> 00:08:11,550
templating engine generates Python code

00:08:08,370 --> 00:08:13,500
and it has mostly peyten semantics so

00:08:11,550 --> 00:08:15,270
it's mostly want to one mapping but

00:08:13,500 --> 00:08:17,310
there are some differences for instance

00:08:15,270 --> 00:08:19,980
if you use a variable doesn't exist in

00:08:17,310 --> 00:08:22,020
Python you get the name error in ginger

00:08:19,980 --> 00:08:24,000
you get an undefined object which then

00:08:22,020 --> 00:08:25,920
allows you to print it still without

00:08:24,000 --> 00:08:26,970
giving you an error but as soon as you

00:08:25,920 --> 00:08:29,280
do anything else with it

00:08:26,970 --> 00:08:32,130
it aresult and it has different scoping

00:08:29,280 --> 00:08:34,640
rules so quick show of hands how many of

00:08:32,130 --> 00:08:35,910
you using Django as a templating engine

00:08:34,640 --> 00:08:39,599
all right

00:08:35,910 --> 00:08:41,630
and how many using ginger that is quite

00:08:39,599 --> 00:08:45,300
impressive

00:08:41,630 --> 00:08:47,880
so ginger and Django are having sea

00:08:45,300 --> 00:08:50,460
inspired scoping rules which basically

00:08:47,880 --> 00:08:53,100
means that if you start a loop and you

00:08:50,460 --> 00:08:55,320
modify the context within the loop like

00:08:53,100 --> 00:08:57,450
assigning to a variable outside of that

00:08:55,320 --> 00:08:59,610
loop that variable will still be on the

00:08:57,450 --> 00:09:02,400
old value so you cannot actually modify

00:08:59,610 --> 00:09:05,520
your context and you have to map this to

00:09:02,400 --> 00:09:06,990
Python semantics which is tricky the way

00:09:05,520 --> 00:09:09,510
this works and ginger is basically you

00:09:06,990 --> 00:09:11,940
have a lexer which takes a string

00:09:09,510 --> 00:09:14,160
and then creates little tokens from that

00:09:11,940 --> 00:09:17,010
string these tokens are then passed to

00:09:14,160 --> 00:09:20,520
parser which then creates this tree of

00:09:17,010 --> 00:09:22,620
notes which then has a small analyzer

00:09:20,520 --> 00:09:24,900
which tries to figure out how variables

00:09:22,620 --> 00:09:27,270
flows through this whole program then it

00:09:24,900 --> 00:09:28,980
generates code which it does by creating

00:09:27,270 --> 00:09:31,020
patent sorts which it then compiled to

00:09:28,980 --> 00:09:33,150
bytecode which it then evaluates on the

00:09:31,020 --> 00:09:35,010
runtime and only the blue part is

00:09:33,150 --> 00:09:36,780
actually what is necessary to run the

00:09:35,010 --> 00:09:38,940
template everything else can be cached

00:09:36,780 --> 00:09:40,670
so you can write your bytecode to the

00:09:38,940 --> 00:09:42,810
file system if you want to than you

00:09:40,670 --> 00:09:45,810
avoid the whole overhead of the

00:09:42,810 --> 00:09:47,250
machinery all right so the complexities

00:09:45,810 --> 00:09:48,720
are basically you have different scoping

00:09:47,250 --> 00:09:51,900
rules so they have to be mapped properly

00:09:48,720 --> 00:09:54,270
to generated code and the biggest

00:09:51,900 --> 00:09:58,170
problem I had was ginger when I created

00:09:54,270 --> 00:10:03,270
this was doubles GI is generator based

00:09:58,170 --> 00:10:06,180
so if you have a response from your view

00:10:03,270 --> 00:10:08,700
in an inch angle or in any other

00:10:06,180 --> 00:10:11,940
framework you can either create one huge

00:10:08,700 --> 00:10:15,780
string and pass it to the 2d browser or

00:10:11,940 --> 00:10:18,780
you can return a generator which creates

00:10:15,780 --> 00:10:21,180
smaller pieces of of template code so if

00:10:18,780 --> 00:10:25,080
you would want to have like a gigabyte

00:10:21,180 --> 00:10:27,030
large CSV file and you would want to

00:10:25,080 --> 00:10:29,010
generate that the simplest way is you

00:10:27,030 --> 00:10:31,530
write it into a string and then you have

00:10:29,010 --> 00:10:33,840
a waste at one gigabyte of memory usage

00:10:31,530 --> 00:10:37,650
and four gigabytes even if you use

00:10:33,840 --> 00:10:39,540
unicode strings and in order to actually

00:10:37,650 --> 00:10:41,040
create a generator the whole ginger

00:10:39,540 --> 00:10:44,550
infrastructure internally has to be

00:10:41,040 --> 00:10:46,650
generated aware because we cannot create

00:10:44,550 --> 00:10:48,690
we cannot convert a function call into

00:10:46,650 --> 00:10:51,330
an yield event on the generator without

00:10:48,690 --> 00:10:54,210
using grid nuts yet a problem is that

00:10:51,330 --> 00:10:56,280
ginger has it uses actual cogeneration

00:10:54,210 --> 00:10:58,440
so it creates high ten lines of code

00:10:56,280 --> 00:11:01,230
which means the line numbers in the

00:10:58,440 --> 00:11:02,850
ginger create generated code do not map

00:11:01,230 --> 00:11:05,670
to the line numbers in your source

00:11:02,850 --> 00:11:07,620
template and in order to get around this

00:11:05,670 --> 00:11:09,450
there is an interesting hack within

00:11:07,620 --> 00:11:12,620
ginger that remaps the line numbers on

00:11:09,450 --> 00:11:15,120
trace back objects and the last big

00:11:12,620 --> 00:11:17,010
complexity that goes into ginger is that

00:11:15,120 --> 00:11:20,790
it can actually run untrusted template

00:11:17,010 --> 00:11:21,910
code and as we know Python cannot be

00:11:20,790 --> 00:11:23,830
really sandboxed

00:11:21,910 --> 00:11:25,900
so it has restricts the language it

00:11:23,830 --> 00:11:29,200
implements in ways that you can actually

00:11:25,900 --> 00:11:31,180
sandbox it properly alright so this is

00:11:29,200 --> 00:11:33,310
how a change Chango or change a template

00:11:31,180 --> 00:11:36,100
basically looks like you have beginning

00:11:33,310 --> 00:11:38,470
of a list then you iterate over all the

00:11:36,100 --> 00:11:41,070
items in a sequence you print each and

00:11:38,470 --> 00:11:43,420
every item and you close the list again

00:11:41,070 --> 00:11:46,180
the basic behavior for this is your

00:11:43,420 --> 00:11:48,840
printers and what happens between the

00:11:46,180 --> 00:11:52,870
iterations that you push the scope so

00:11:48,840 --> 00:11:55,000
the item is actually not exactly true

00:11:52,870 --> 00:11:58,720
because the item should be in the scope

00:11:55,000 --> 00:12:00,760
so if you iterate over a list of items

00:11:58,720 --> 00:12:03,400
and you're assigned to a variable named

00:12:00,760 --> 00:12:05,440
item this will also be available in

00:12:03,400 --> 00:12:06,640
white now after the loop which you

00:12:05,440 --> 00:12:08,290
typically don't want to have in a

00:12:06,640 --> 00:12:10,810
template because it makes it for

00:12:08,290 --> 00:12:12,790
interesting debugging situations where

00:12:10,810 --> 00:12:16,000
you can actually by accident overwrite

00:12:12,790 --> 00:12:18,550
things that shouldn't be overwritten so

00:12:16,000 --> 00:12:20,020
actually the each item should be off to

00:12:18,550 --> 00:12:23,470
push the scope but it's really hard to

00:12:20,020 --> 00:12:25,420
show this way and ginger and Django are

00:12:23,470 --> 00:12:27,130
also applying automatic escaping if you

00:12:25,420 --> 00:12:28,720
want so in this case we would want to

00:12:27,130 --> 00:12:32,410
automatic escape the item if it is

00:12:28,720 --> 00:12:34,930
necessary so the simple implementation

00:12:32,410 --> 00:12:36,910
which is how ginger one relaxed is you

00:12:34,930 --> 00:12:39,220
call a bunch of functions for each and

00:12:36,910 --> 00:12:41,440
every item and instead of using local

00:12:39,220 --> 00:12:43,960
variables you use a context object which

00:12:41,440 --> 00:12:46,240
is very close to dictionary and every

00:12:43,960 --> 00:12:48,940
operation on the context is performed

00:12:46,240 --> 00:12:52,990
through this object so for for each

00:12:48,940 --> 00:12:55,350
temporary variable in this in this in

00:12:52,990 --> 00:12:58,960
the sequence variable in the context of

00:12:55,350 --> 00:13:00,880
you assign this to a temporary then push

00:12:58,960 --> 00:13:03,700
the scope and then assign the temporary

00:13:00,880 --> 00:13:06,190
to the new scope in your context then

00:13:03,700 --> 00:13:08,440
you can access it as you would normally

00:13:06,190 --> 00:13:11,530
and on context stop the item disappears

00:13:08,440 --> 00:13:14,170
and this is actually really really slow

00:13:11,530 --> 00:13:16,570
if you compile this down it's about as

00:13:14,170 --> 00:13:18,250
slow as Django templates out by

00:13:16,570 --> 00:13:21,520
themselves you don't really gain

00:13:18,250 --> 00:13:22,930
anything in terms of performance so the

00:13:21,520 --> 00:13:26,020
actual implementation and change it to

00:13:22,930 --> 00:13:27,730
looks like this it assigns at first it

00:13:26,020 --> 00:13:30,670
resolves the sequence variable and

00:13:27,730 --> 00:13:32,350
assigns it to a local variable then it

00:13:30,670 --> 00:13:34,480
writes it this would actually be yield

00:13:32,350 --> 00:13:34,960
statement and for each item in the

00:13:34,480 --> 00:13:37,620
sequence

00:13:34,960 --> 00:13:40,870
does the other escaping and aresult and

00:13:37,620 --> 00:13:43,480
bails out which is interesting because

00:13:40,870 --> 00:13:45,490
this is actually if you look at it not

00:13:43,480 --> 00:13:47,230
according to this change of semantics so

00:13:45,490 --> 00:13:48,660
if there is no magic scoping happening

00:13:47,230 --> 00:13:51,070
so how does this work

00:13:48,660 --> 00:13:53,140
alright so this is a basic introduction

00:13:51,070 --> 00:13:55,150
into how the compilation works and I do

00:13:53,140 --> 00:13:58,780
not claim that I understand compilation

00:13:55,150 --> 00:14:02,170
because the whole ginger engine as it

00:13:58,780 --> 00:14:04,720
exists currently I didn't have any like

00:14:02,170 --> 00:14:06,340
IT background or computer science

00:14:04,720 --> 00:14:10,900
background so a lot of this is probably

00:14:06,340 --> 00:14:12,370
not how it's done in the book alright so

00:14:10,900 --> 00:14:14,020
in the art of cogeneration there are

00:14:12,370 --> 00:14:15,670
basically two levels there is low and

00:14:14,020 --> 00:14:18,040
there is high level if you would

00:14:15,670 --> 00:14:19,240
generate low level code in piping you

00:14:18,040 --> 00:14:23,530
would generate actual bytecode

00:14:19,240 --> 00:14:25,810
instructions so if you assign 1 + 2 to a

00:14:23,530 --> 00:14:27,760
you would load the constant 1 and then

00:14:25,810 --> 00:14:30,460
load the constant 2 then you would

00:14:27,760 --> 00:14:35,440
invoke the binary at operator and then

00:14:30,460 --> 00:14:39,280
you store it to the variable a the

00:14:35,440 --> 00:14:45,430
higher level would be you use ast nodes

00:14:39,280 --> 00:14:47,380
or write directly to source code and the

00:14:45,430 --> 00:14:49,570
AAC generation was introduced after

00:14:47,380 --> 00:14:50,890
ginger was created there was an

00:14:49,570 --> 00:14:54,220
alternative module which had an

00:14:50,890 --> 00:14:55,900
optimizing compiler which was not

00:14:54,220 --> 00:14:59,920
supported on a bunch of platforms

00:14:55,900 --> 00:15:01,960
including Google App Engine so the

00:14:59,920 --> 00:15:04,240
building blocks of bytecode which is the

00:15:01,960 --> 00:15:06,010
very low level yep 16 degrees in the

00:15:04,240 --> 00:15:07,750
source code so what are the problems

00:15:06,010 --> 00:15:10,420
with byte codes the biggest one is

00:15:07,750 --> 00:15:12,190
undocumented and it doesn't work on

00:15:10,420 --> 00:15:13,630
certain environments such as Google I

00:15:12,190 --> 00:15:15,750
mentioned and this is hugely

00:15:13,630 --> 00:15:17,980
implementation-specific

00:15:15,750 --> 00:15:19,960
the biggest problem there is that the

00:15:17,980 --> 00:15:21,190
instructions actually changed from one

00:15:19,960 --> 00:15:23,290
version to another of peyten

00:15:21,190 --> 00:15:26,110
so it's not that it's different between

00:15:23,290 --> 00:15:27,640
pi PI and C piden or tries on and co

00:15:26,110 --> 00:15:31,120
item that is actually different between

00:15:27,640 --> 00:15:34,660
c python 2.4 and c python 2.5 so the

00:15:31,120 --> 00:15:37,330
bytecode generation is needs a lot of

00:15:34,660 --> 00:15:39,310
maintenance if you want to do that the

00:15:37,330 --> 00:15:40,570
nice aspects of byte code generation is

00:15:39,310 --> 00:15:42,340
that you could actually map all the

00:15:40,570 --> 00:15:43,990
change of semantics on to the virtual

00:15:42,340 --> 00:15:47,650
machine of titan without having to do

00:15:43,990 --> 00:15:48,870
any weird tags the sd1 is more limited

00:15:47,650 --> 00:15:51,630
you're basically

00:15:48,870 --> 00:15:53,040
to this syntax of Titan there are some

00:15:51,630 --> 00:15:55,460
differences you can actually have a

00:15:53,040 --> 00:15:58,020
local variable called class for instance

00:15:55,460 --> 00:16:00,900
and it's easier to debug and you can

00:15:58,020 --> 00:16:02,370
like whose bytecode you could point the

00:16:00,900 --> 00:16:05,730
arrow directly to the correct line

00:16:02,370 --> 00:16:07,260
number and as of Python 2.7 you can

00:16:05,730 --> 00:16:10,800
actually not seg fault the interpreter

00:16:07,260 --> 00:16:12,779
with the ast which is also good because

00:16:10,800 --> 00:16:15,380
you can cycle the interpreter if you use

00:16:12,779 --> 00:16:17,550
wrong bytecode instructions there are no

00:16:15,380 --> 00:16:20,339
unless it was change there were no real

00:16:17,550 --> 00:16:22,170
guards against this the sauce generation

00:16:20,339 --> 00:16:23,640
works always is very limited and has the

00:16:22,170 --> 00:16:26,430
problem that the line I was pointed to

00:16:23,640 --> 00:16:28,860
wrong directions and ginger gets around

00:16:26,430 --> 00:16:32,040
this whole line number pointing to the

00:16:28,860 --> 00:16:33,779
wrong line by basically taking your

00:16:32,040 --> 00:16:34,500
trace back object and then it gives

00:16:33,779 --> 00:16:36,270
c-types

00:16:34,500 --> 00:16:39,600
to change the line numbers on the trace

00:16:36,270 --> 00:16:43,350
back object which works which is quite

00:16:39,600 --> 00:16:47,339
interesting but it's not really that

00:16:43,350 --> 00:16:49,800
nice and I wouldn't recommend doing that

00:16:47,339 --> 00:16:51,779
now that there are ast nodes they are a

00:16:49,800 --> 00:16:55,589
lot better to do deal with the problem

00:16:51,779 --> 00:16:58,920
all right so the basic idea why in

00:16:55,589 --> 00:17:00,900
ginger is actually fast continue to is

00:16:58,920 --> 00:17:03,770
fast compared with ginger 1 or Django

00:17:00,900 --> 00:17:09,150
templates or many other solutions is

00:17:03,770 --> 00:17:11,059
that it's that is operating on the fast

00:17:09,150 --> 00:17:14,339
aspects of the fighting virtual machine

00:17:11,059 --> 00:17:17,220
if you take this code this is faster

00:17:14,339 --> 00:17:20,250
it's not that fast but it's faster than

00:17:17,220 --> 00:17:22,050
this code and the difference is

00:17:20,250 --> 00:17:25,050
basically that this code is operating on

00:17:22,050 --> 00:17:28,410
a global scope and this code is

00:17:25,050 --> 00:17:29,760
operating on a local scope so why is the

00:17:28,410 --> 00:17:32,820
one faster than the other

00:17:29,760 --> 00:17:34,410
the slower code looks like this which

00:17:32,820 --> 00:17:37,800
you can probably not really read but

00:17:34,410 --> 00:17:40,350
what's important there is that it uses a

00:17:37,800 --> 00:17:42,150
function bytecode instruction code load

00:17:40,350 --> 00:17:45,929
name which was a dictionary lookup and

00:17:42,150 --> 00:17:50,340
the faster one looks at the variable by

00:17:45,929 --> 00:17:51,990
an index and so piping has soon as that

00:17:50,340 --> 00:17:54,590
the difference is basically these couple

00:17:51,990 --> 00:17:54,590
of instructions

00:17:55,539 --> 00:18:01,149
and basically every variable in a local

00:17:58,570 --> 00:18:03,539
scope is indexed by a number not by name

00:18:01,149 --> 00:18:06,850
and you can see this in action by

00:18:03,539 --> 00:18:09,399
calling by assigning to a local variable

00:18:06,850 --> 00:18:11,350
called a then you get the local scope by

00:18:09,399 --> 00:18:13,029
calling locals and you try to modify it

00:18:11,350 --> 00:18:15,399
and then we've returned a it's actually

00:18:13,029 --> 00:18:17,799
still the old value because the local

00:18:15,399 --> 00:18:20,019
dictionary is actually never used it's

00:18:17,799 --> 00:18:22,479
in couple situation pointing to the

00:18:20,019 --> 00:18:24,070
local dictionary can be used mainly if

00:18:22,479 --> 00:18:28,179
we use the exact statement in a function

00:18:24,070 --> 00:18:31,210
and you don't supply a dictionary but I

00:18:28,179 --> 00:18:32,950
think in Python 3 is always used so the

00:18:31,210 --> 00:18:37,720
dictionary is a lie and it doesn't work

00:18:32,950 --> 00:18:39,700
and this is important because this way

00:18:37,720 --> 00:18:43,299
the semantics of ginger can actually be

00:18:39,700 --> 00:18:47,950
mapped to the fast execution environment

00:18:43,299 --> 00:18:49,479
so remember the basic semantics are the

00:18:47,950 --> 00:18:52,179
same as before you push the scope you

00:18:49,479 --> 00:18:54,489
pop disco but obviously that's not how

00:18:52,179 --> 00:18:56,229
hiding works how do we make it work the

00:18:54,489 --> 00:18:57,849
solution is this one step in the ginger

00:18:56,229 --> 00:19:01,179
compiler which does the tracking of

00:18:57,849 --> 00:19:04,059
identifiers so for every identifier we

00:19:01,179 --> 00:19:05,619
know how it flows through the code and

00:19:04,059 --> 00:19:07,899
here's the big difference between ginger

00:19:05,619 --> 00:19:09,849
2 and Chango and why I wasn't able to

00:19:07,899 --> 00:19:12,429
make Chango as far as this ginger is

00:19:09,849 --> 00:19:14,889
that the context in ginger 2 is a data

00:19:12,429 --> 00:19:17,940
source and the context in Django is the

00:19:14,889 --> 00:19:20,440
data is a data store and basically

00:19:17,940 --> 00:19:22,869
ginger doesn't generate ginger doesn't

00:19:20,440 --> 00:19:26,019
allow you to modify the context in any

00:19:22,869 --> 00:19:27,789
way shape or form once it's in the

00:19:26,019 --> 00:19:30,489
runtime similar to how you cannot modify

00:19:27,789 --> 00:19:33,609
the local scope in a piping function by

00:19:30,489 --> 00:19:36,220
changing the dictionary if you take this

00:19:33,609 --> 00:19:38,710
source so for each item in the sequence

00:19:36,220 --> 00:19:40,239
you include another template the code

00:19:38,710 --> 00:19:42,970
that is generated looks roughly like

00:19:40,239 --> 00:19:44,799
this you get the other template and for

00:19:42,970 --> 00:19:48,070
every event in that other template you

00:19:44,799 --> 00:19:50,259
if you return this event again and event

00:19:48,070 --> 00:19:52,749
means a string of a related template

00:19:50,259 --> 00:19:54,909
code and here you can see the context is

00:19:52,749 --> 00:19:57,190
past which was the original context plus

00:19:54,909 --> 00:19:59,710
all the modifications on the local scope

00:19:57,190 --> 00:20:03,279
in this case the extra item is also

00:19:59,710 --> 00:20:04,809
passed to the include so what happens in

00:20:03,279 --> 00:20:06,820
the include station include you cannot

00:20:04,809 --> 00:20:07,330
change any variable in the include and

00:20:06,820 --> 00:20:09,910
expect

00:20:07,330 --> 00:20:11,950
to work outside of the included

00:20:09,910 --> 00:20:13,540
templates I couldn't do that

00:20:11,950 --> 00:20:16,060
because I would have to also know in

00:20:13,540 --> 00:20:18,220
advance at compilation time which

00:20:16,060 --> 00:20:20,680
modifications happen in the included

00:20:18,220 --> 00:20:23,020
template as such it's entirely

00:20:20,680 --> 00:20:24,780
impossible in ginger even if would try

00:20:23,020 --> 00:20:27,880
to make it possible to have a function

00:20:24,780 --> 00:20:30,070
that modifies the context that just

00:20:27,880 --> 00:20:32,980
doesn't work all right so here's some

00:20:30,070 --> 00:20:34,510
practical examples how this works this

00:20:32,980 --> 00:20:36,490
is the very basic for each item in

00:20:34,510 --> 00:20:39,010
sequence you assign you print the item

00:20:36,490 --> 00:20:42,400
and this is what the code looks like

00:20:39,010 --> 00:20:44,680
when it's generated it looks up the it

00:20:42,400 --> 00:20:47,230
knows that the code needs the sequence

00:20:44,680 --> 00:20:49,030
variable so it looks it up and then it

00:20:47,230 --> 00:20:53,500
yields the first part of the template

00:20:49,030 --> 00:20:54,880
then assigns missing to L item I get to

00:20:53,500 --> 00:20:59,260
this in a moment and then for each item

00:20:54,880 --> 00:21:01,630
in a sequence it yields a string with

00:20:59,260 --> 00:21:04,210
the escaped item value the reason why

00:21:01,630 --> 00:21:07,420
the signs missing to L item is basically

00:21:04,210 --> 00:21:09,670
if you call if you get a trace back some

00:21:07,420 --> 00:21:13,690
debuggers allow you to inspect which

00:21:09,670 --> 00:21:15,910
local variables exist and this way I can

00:21:13,690 --> 00:21:17,680
easily find out which which variables

00:21:15,910 --> 00:21:19,780
are actually set to missing and which or

00:21:17,680 --> 00:21:21,390
not for change I wouldn't be necessary

00:21:19,780 --> 00:21:24,810
because ginger knows that after the

00:21:21,390 --> 00:21:30,070
after the loop item section not in use

00:21:24,810 --> 00:21:31,840
if you take this loop for instance here

00:21:30,070 --> 00:21:33,910
we are using this special loop variable

00:21:31,840 --> 00:21:36,160
or for loop variable in Django which

00:21:33,910 --> 00:21:40,150
lets us print the index and if we go

00:21:36,160 --> 00:21:41,980
back you see there is no special counter

00:21:40,150 --> 00:21:44,080
or anything but we want to see in which

00:21:41,980 --> 00:21:45,520
iteration of the code we are the way it

00:21:44,080 --> 00:21:47,620
works this change receives okay this

00:21:45,520 --> 00:21:49,960
special loop variables XS so we need to

00:21:47,620 --> 00:21:52,720
generate more complex code in this case

00:21:49,960 --> 00:21:56,110
it will wrap all the execution in this

00:21:52,720 --> 00:21:58,810
loop context object and then we have

00:21:56,110 --> 00:22:00,460
access to the loop context which gives

00:21:58,810 --> 00:22:02,710
us the current iteration the number of

00:22:00,460 --> 00:22:06,010
items that are in the sequence were

00:22:02,710 --> 00:22:08,140
iterating over and so forth this is the

00:22:06,010 --> 00:22:11,290
more complex example this is the same as

00:22:08,140 --> 00:22:14,560
as before but in addition we have an

00:22:11,290 --> 00:22:16,900
item printed after the loop and this is

00:22:14,560 --> 00:22:20,020
not the same item as in the loop so in

00:22:16,900 --> 00:22:21,040
in this situation we would pass item is

00:22:20,020 --> 00:22:23,140
42 to the

00:22:21,040 --> 00:22:26,950
plates and a sequence of three items and

00:22:23,140 --> 00:22:29,860
after the iteration we want to get 42 as

00:22:26,950 --> 00:22:33,430
a value and here the compiler has to

00:22:29,860 --> 00:22:35,290
actually loads yeah it knows the item

00:22:33,430 --> 00:22:37,870
will be used later on so it resolves it

00:22:35,290 --> 00:22:40,780
from the context then he assigns the

00:22:37,870 --> 00:22:44,890
item to a temporary loops over the or

00:22:40,780 --> 00:22:46,570
the whole loop loop body again and then

00:22:44,890 --> 00:22:50,680
afterwards reassigned item to the

00:22:46,570 --> 00:22:53,350
temporary and prints it if we want to

00:22:50,680 --> 00:22:55,240
look how extending in expanding

00:22:53,350 --> 00:22:58,960
templates and ginger works it's very

00:22:55,240 --> 00:23:00,880
simple in fact the root function which

00:22:58,960 --> 00:23:03,100
is the one that's always called if you

00:23:00,880 --> 00:23:06,760
evaluate the template basically looks

00:23:03,100 --> 00:23:08,410
for the parents environment gets all of

00:23:06,760 --> 00:23:11,080
the blocks in there and for each and

00:23:08,410 --> 00:23:13,210
every block it appends the current

00:23:11,080 --> 00:23:15,430
blocks in addition and then calls the

00:23:13,210 --> 00:23:17,520
parent template and each block is

00:23:15,430 --> 00:23:22,210
basically just a function that points to

00:23:17,520 --> 00:23:24,760
a dictionary there if zero yield none is

00:23:22,210 --> 00:23:26,590
inserted by the compiler for simplicity

00:23:24,760 --> 00:23:29,830
reasons it basically forces a function

00:23:26,590 --> 00:23:31,600
to become a generator this is showing up

00:23:29,830 --> 00:23:34,870
in more places but I forgot to delete

00:23:31,600 --> 00:23:36,460
this here it's by if c or yield none

00:23:34,870 --> 00:23:38,440
needs basically removed that compilation

00:23:36,460 --> 00:23:42,280
in the python interpreter it doesn't do

00:23:38,440 --> 00:23:46,120
any damage and if we just look at how a

00:23:42,280 --> 00:23:49,110
template works without inheritance it's

00:23:46,120 --> 00:23:51,420
basically just for each and every block

00:23:49,110 --> 00:23:57,190
yielding the events and each block is

00:23:51,420 --> 00:23:59,440
essentially a function if we call into a

00:23:57,190 --> 00:24:01,870
super block so one from the template

00:23:59,440 --> 00:24:04,390
above it sees that the special variable

00:24:01,870 --> 00:24:07,270
super is used and super is basically

00:24:04,390 --> 00:24:08,710
just an object which is created from the

00:24:07,270 --> 00:24:12,400
context subject which knows how to

00:24:08,710 --> 00:24:15,340
evaluate the parent template all right

00:24:12,400 --> 00:24:17,920
so here a couple of things why ginger

00:24:15,340 --> 00:24:19,720
works in certain ways why does the du

00:24:17,920 --> 00:24:21,640
commander cogeneration basically because

00:24:19,720 --> 00:24:23,710
it didn't have a chance before that if

00:24:21,640 --> 00:24:25,510
you look at my github repository there

00:24:23,710 --> 00:24:27,670
is a new project called chasing ginger

00:24:25,510 --> 00:24:29,440
which attempts to have a very small

00:24:27,670 --> 00:24:31,870
version of ginger that can be compiled

00:24:29,440 --> 00:24:33,310
into JavaScript code as well or you have

00:24:31,870 --> 00:24:34,150
the same semantics for as long as you

00:24:33,310 --> 00:24:36,640
only pass

00:24:34,150 --> 00:24:38,140
not checks to the templating engine so

00:24:36,640 --> 00:24:41,680
you can render it on the server and on

00:24:38,140 --> 00:24:45,510
the client and this one is using ast

00:24:41,680 --> 00:24:48,520
nodes instead of actually cogeneration

00:24:45,510 --> 00:24:53,110
the generators instead of buffer append

00:24:48,520 --> 00:24:55,360
is for CC I the problem there is if you

00:24:53,110 --> 00:24:57,280
by accident have a stop iteration as

00:24:55,360 --> 00:24:58,810
part of the template evaluation it will

00:24:57,280 --> 00:25:00,940
just stop rendering the template and

00:24:58,810 --> 00:25:03,220
this is a good example why you should

00:25:00,940 --> 00:25:04,900
not have invent signaling so stop

00:25:03,220 --> 00:25:07,270
iteration to signal the end of an

00:25:04,900 --> 00:25:10,840
iterator is actually in this case really

00:25:07,270 --> 00:25:13,990
painful to deal with why does it map a

00:25:10,840 --> 00:25:16,990
variable X to L variable X mostly

00:25:13,990 --> 00:25:19,750
because I have internals for the

00:25:16,990 --> 00:25:22,600
templating engine needs for running like

00:25:19,750 --> 00:25:26,950
the temporary variables and this way it

00:25:22,600 --> 00:25:29,830
can just basically take the local scope

00:25:26,950 --> 00:25:34,090
and find out what very was actually used

00:25:29,830 --> 00:25:36,310
by the templating engine and template DK

00:25:34,090 --> 00:25:38,740
has a better approach it actually

00:25:36,310 --> 00:25:41,920
supports the template e case the project

00:25:38,740 --> 00:25:43,030
that you are chasing ginger is using it

00:25:41,920 --> 00:25:46,330
has a better approach where it can

00:25:43,030 --> 00:25:49,540
actually encode more information into

00:25:46,330 --> 00:25:53,650
the local variables so you can you can

00:25:49,540 --> 00:25:56,560
avoid having the temporaries just

00:25:53,650 --> 00:25:57,400
basically a couple of things how ginger

00:25:56,560 --> 00:25:59,500
does a couple things

00:25:57,400 --> 00:26:01,810
the Markov object I don't know if you

00:25:59,500 --> 00:26:05,620
know it is basically as a wrapper around

00:26:01,810 --> 00:26:07,810
a string where you can use by the

00:26:05,620 --> 00:26:12,520
operators are all overloaded in a way

00:26:07,810 --> 00:26:14,170
that you can do as automatic escaping so

00:26:12,520 --> 00:26:16,210
you can have a variable and append

00:26:14,170 --> 00:26:18,160
another string to it and it will

00:26:16,210 --> 00:26:21,430
automatically scape what the string that

00:26:18,160 --> 00:26:22,900
was a pendent part of the automatic

00:26:21,430 --> 00:26:25,900
escaping and ginger actually works at

00:26:22,900 --> 00:26:27,490
compile time if you take if you just

00:26:25,900 --> 00:26:30,760
print a string and the string is not

00:26:27,490 --> 00:26:33,490
safe it will basically recognize this

00:26:30,760 --> 00:26:35,920
constant string I think I can always

00:26:33,490 --> 00:26:38,700
keep it at compile time if it's a

00:26:35,920 --> 00:26:41,560
variable it has to do it at runtime and

00:26:38,700 --> 00:26:44,760
if I want to control her outer escaping

00:26:41,560 --> 00:26:47,940
works I can use the or escape false and

00:26:44,760 --> 00:26:51,210
disabled and if you look closely here it

00:26:47,940 --> 00:26:53,040
creates a new context which is the

00:26:51,210 --> 00:26:55,260
context evil context and says the others

00:26:53,040 --> 00:26:56,880
kept default the reason why does this is

00:26:55,260 --> 00:26:59,610
that the runtime knows if it can

00:26:56,880 --> 00:27:04,020
actually rely on or escaping to work or

00:26:59,610 --> 00:27:05,880
not and here's a more complex example

00:27:04,020 --> 00:27:09,450
how this will work if he order escaped

00:27:05,880 --> 00:27:12,780
is not recognized what compile time all

00:27:09,450 --> 00:27:14,520
right all the operators on a macro

00:27:12,780 --> 00:27:17,460
object are actually overloaded so you

00:27:14,520 --> 00:27:19,590
can create a markup object from a string

00:27:17,460 --> 00:27:21,480
and then you can has in the queue of an

00:27:19,590 --> 00:27:26,669
insecure string to the string formatting

00:27:21,480 --> 00:27:30,620
up operators and it will work all right

00:27:26,669 --> 00:27:32,880
this is basically overview of how they

00:27:30,620 --> 00:27:35,160
change the templating engine works and

00:27:32,880 --> 00:27:37,200
how it does the cogeneration there are a

00:27:35,160 --> 00:27:40,020
couple of more things that go into the

00:27:37,200 --> 00:27:42,270
whole compilation process for instance

00:27:40,020 --> 00:27:44,970
the undefined variables in ginger

00:27:42,270 --> 00:27:48,660
actually replaced by undefined objects

00:27:44,970 --> 00:27:50,340
and you can see if I create this

00:27:48,660 --> 00:27:52,110
undefined object is always returned by

00:27:50,340 --> 00:27:53,850
the resolving of the context so I can

00:27:52,110 --> 00:27:56,190
still convert it into an empty string

00:27:53,850 --> 00:27:57,929
but if I attempt to do an attribute

00:27:56,190 --> 00:27:58,770
look-up on it it will give me a missing

00:27:57,929 --> 00:28:02,070
VAR is undefined

00:27:58,770 --> 00:28:05,270
all right thank you if you have any

00:28:02,070 --> 00:28:05,270
questions feel free to ask

00:28:23,270 --> 00:28:26,350
someone has

00:28:32,640 --> 00:28:40,650
if anybody has a question we complete

00:28:34,680 --> 00:28:42,090
walk up to the doctor first if you had a

00:28:40,650 --> 00:28:46,560
chance to do it all over again would you

00:28:42,090 --> 00:28:48,780
use the ASD no yes I would definitely

00:28:46,560 --> 00:28:51,690
use the a steam water now and the chase

00:28:48,780 --> 00:28:54,210
machine super trick is using the HTML if

00:28:51,690 --> 00:28:55,740
you actually want to use a AC module and

00:28:54,210 --> 00:28:58,080
still support all the piping versions

00:28:55,740 --> 00:29:01,500
there is utility library which converts

00:28:58,080 --> 00:29:06,570
any ASD tree into piping codes which you

00:29:01,500 --> 00:29:11,190
can regularly compile January slides

00:29:06,570 --> 00:29:24,510
will be online at this URL and we are

00:29:11,190 --> 00:29:26,190
hiring you said that you use C types to

00:29:24,510 --> 00:29:27,600
make the line numbers line up

00:29:26,190 --> 00:29:31,050
yes curious if you could kind of give an

00:29:27,600 --> 00:29:31,980
overview of how that works if that's not

00:29:31,050 --> 00:29:33,750
possible

00:29:31,980 --> 00:29:37,650
it'sit's actually a very simple process

00:29:33,750 --> 00:29:39,300
the way it works is for every piece of

00:29:37,650 --> 00:29:41,700
code that the changer code template

00:29:39,300 --> 00:29:43,650
engine creates it inserts a special

00:29:41,700 --> 00:29:45,890
global variable into the namespace

00:29:43,650 --> 00:29:48,810
called underscore underscore ginger

00:29:45,890 --> 00:29:51,150
debug information something where it has

00:29:48,810 --> 00:29:52,620
the line number mapping so it knows what

00:29:51,150 --> 00:29:54,780
the source line number isn't what you

00:29:52,620 --> 00:29:56,760
expected generated line number is and

00:29:54,780 --> 00:29:59,790
then if I get the trace back I walk over

00:29:56,760 --> 00:30:01,290
all the frames in the trace back and for

00:29:59,790 --> 00:30:03,180
every one where I see the special marker

00:30:01,290 --> 00:30:04,770
in there I create a new code object

00:30:03,180 --> 00:30:06,930
which has the record line number and

00:30:04,770 --> 00:30:09,720
then a monkey patch it onto the trace

00:30:06,930 --> 00:30:12,240
back object and it works on all

00:30:09,720 --> 00:30:15,210
heightened versions I tested it with it

00:30:12,240 --> 00:30:18,900
also works on pipeline because high bias

00:30:15,210 --> 00:30:20,640
and a special proxy object which can be

00:30:18,900 --> 00:30:24,650
used to face the internal trace back

00:30:20,640 --> 00:30:24,650
object so it is actually really useful

00:30:24,710 --> 00:30:31,470
it did however one show up that Titan

00:30:27,840 --> 00:30:34,260
had a bug on some I don't even know what

00:30:31,470 --> 00:30:36,450
RT that was sparked something weird on

00:30:34,260 --> 00:30:38,280
the object size for math correct

00:30:36,450 --> 00:30:42,810
and then ginger was suddenly sick

00:30:38,280 --> 00:30:44,640
faulting on on some 64-bit to Spock

00:30:42,810 --> 00:30:46,320
machines so there are there are some

00:30:44,640 --> 00:30:52,290
problems you can have with these kinds

00:30:46,320 --> 00:30:53,880
of monkey patches thank you okay but

00:30:52,290 --> 00:30:58,370
that's all the time we have for today we

00:30:53,880 --> 00:30:58,370

YouTube URL: https://www.youtube.com/watch?v=jXlR0Icvvh8


