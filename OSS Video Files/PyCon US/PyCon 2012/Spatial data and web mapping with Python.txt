Title: Spatial data and web mapping with Python
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Paul Smith
Spatial data are often seen as opaque to most developers, and while dealing with them does require a shift in approach from the data types we most regularly handle, they needn't be the domain of specialists. High-quality Python libraries a
Captions: 
	00:00:01,100 --> 00:00:07,890
hello all right please be seated

00:00:04,560 --> 00:00:11,580
everyone our next speaker is Paul Smith

00:00:07,890 --> 00:00:14,549
is a deputy CTO of DNC and he's a

00:00:11,580 --> 00:00:16,560
co-founder of every block and he's going

00:00:14,549 --> 00:00:28,080
to talk about spatial data and web

00:00:16,560 --> 00:00:32,640
mapping with Python can everyone hear me

00:00:28,080 --> 00:00:37,050
okay okay I used to work at a company

00:00:32,640 --> 00:00:39,540
called every block and we made our own

00:00:37,050 --> 00:00:40,230
custom maps we did not take a solution

00:00:39,540 --> 00:00:44,789
off the shelf

00:00:40,230 --> 00:00:47,850
we took publicly and freely publicly

00:00:44,789 --> 00:00:51,420
available data about streets about parks

00:00:47,850 --> 00:00:54,570
water and along with a brand new library

00:00:51,420 --> 00:00:57,629
called map Nick and some custom Python

00:00:54,570 --> 00:00:59,579
and we made our own map tiles and we did

00:00:57,629 --> 00:01:02,340
it so that we could have control full

00:00:59,579 --> 00:01:06,659
control over the style as well as do

00:01:02,340 --> 00:01:11,850
some interesting visualizations and just

00:01:06,659 --> 00:01:14,880
as that was in 2008 in just this past

00:01:11,850 --> 00:01:17,520
week two major companies announced that

00:01:14,880 --> 00:01:20,430
they were they were essentially doing

00:01:17,520 --> 00:01:24,479
the same thing they were rolling their

00:01:20,430 --> 00:01:27,900
own map solutions and I think that it's

00:01:24,479 --> 00:01:29,640
instructive that back in 2008 we thought

00:01:27,900 --> 00:01:34,140
we were opening the floodgates for a

00:01:29,640 --> 00:01:36,840
slew of custom maps to emerge and it's

00:01:34,140 --> 00:01:38,130
been four years and I think we're

00:01:36,840 --> 00:01:40,049
finally starting to see that like

00:01:38,130 --> 00:01:44,030
mainstream acceptance of doing it

00:01:40,049 --> 00:01:46,079
yourself it I also think that it's

00:01:44,030 --> 00:01:48,960
indicative of the fact that working with

00:01:46,079 --> 00:01:52,700
spatial data and making maps is kind of

00:01:48,960 --> 00:01:56,610
a curveball for a lot of developers so

00:01:52,700 --> 00:01:58,920
my talk today is about understanding the

00:01:56,610 --> 00:02:00,570
full picture of spatial data and getting

00:01:58,920 --> 00:02:03,299
comfortable with it as developers and

00:02:00,570 --> 00:02:07,680
and what it looks like to work with it

00:02:03,299 --> 00:02:09,569
on a daily basis and make maps so we're

00:02:07,680 --> 00:02:11,280
going to be heavy on concepts today I'm

00:02:09,569 --> 00:02:13,989
also going to talk about Python

00:02:11,280 --> 00:02:15,370
libraries and applications you can use

00:02:13,989 --> 00:02:20,620
and I'll touch briefly on some data

00:02:15,370 --> 00:02:28,480
sources but conceptually I think there's

00:02:20,620 --> 00:02:31,269
a lot to cover and this is kind of a

00:02:28,480 --> 00:02:32,500
don't let this list intimidate you I'm

00:02:31,269 --> 00:02:34,480
going to go through pretty quickly but

00:02:32,500 --> 00:02:37,150
it should give you kind of a 30,000 foot

00:02:34,480 --> 00:02:38,920
view of what it's like to work with

00:02:37,150 --> 00:02:40,900
spatial data and these are sort of the

00:02:38,920 --> 00:02:43,660
big big categories that you'll encounter

00:02:40,900 --> 00:02:45,340
time and again so it's good to head to

00:02:43,660 --> 00:02:48,010
say like okay I know what that means and

00:02:45,340 --> 00:02:49,569
when presented with the problem you sort

00:02:48,010 --> 00:02:55,030
of be able to get your hand head around

00:02:49,569 --> 00:02:56,950
it so spatial data our data and

00:02:55,030 --> 00:02:59,799
collections of data with multiple

00:02:56,950 --> 00:03:01,330
dimensions usually to two dimensions or

00:02:59,799 --> 00:03:03,250
three dimensions and maybe sometimes

00:03:01,330 --> 00:03:05,920
four dimensions you could think of two

00:03:03,250 --> 00:03:07,450
and three dimensions that's pretty

00:03:05,920 --> 00:03:12,940
obvious fourth dimension maybe to add

00:03:07,450 --> 00:03:15,819
time but what that means there data that

00:03:12,940 --> 00:03:18,579
are coordinates that represent a point

00:03:15,819 --> 00:03:21,220
or points in space either on a plane

00:03:18,579 --> 00:03:24,459
like a geometric plane or on a globe

00:03:21,220 --> 00:03:27,940
like the earth and just as a little

00:03:24,459 --> 00:03:29,350
sidebar I think one of the reasons that

00:03:27,940 --> 00:03:33,989
there is this conceptual hurdle to

00:03:29,350 --> 00:03:35,620
working with spatial data is that for

00:03:33,989 --> 00:03:37,030
we're great at working with

00:03:35,620 --> 00:03:39,370
one-dimensional data we're great at

00:03:37,030 --> 00:03:41,140
working with non spatial data there's

00:03:39,370 --> 00:03:44,079
enormous amount of collective wisdom

00:03:41,140 --> 00:03:47,109
here and in in the programmer community

00:03:44,079 --> 00:03:51,250
at large with working with alphanumeric

00:03:47,109 --> 00:03:54,519
data chars int floats collections of

00:03:51,250 --> 00:03:57,670
that data strings and I think it gets to

00:03:54,519 --> 00:04:00,250
the fact that representational e you've

00:03:57,670 --> 00:04:02,730
got this array of memory cells in a

00:04:00,250 --> 00:04:05,709
computer and so you can have hello world

00:04:02,730 --> 00:04:07,750
encoded very straightforwardly and

00:04:05,709 --> 00:04:10,389
everybody understands how to work with

00:04:07,750 --> 00:04:13,359
that and how to slice and dice it and

00:04:10,389 --> 00:04:15,340
order it and sort it and it's because

00:04:13,359 --> 00:04:16,810
the machine that's we're working at the

00:04:15,340 --> 00:04:18,609
level of the machine there we're working

00:04:16,810 --> 00:04:23,169
with machine primitive operations and

00:04:18,609 --> 00:04:25,750
fast pointer operations so when you

00:04:23,169 --> 00:04:27,099
think of spatial data can't really do

00:04:25,750 --> 00:04:27,690
the same sort of things that you can do

00:04:27,099 --> 00:04:32,340
with

00:04:27,690 --> 00:04:34,200
non-spatial or scalar data comparisons

00:04:32,340 --> 00:04:35,670
well not really that's that doesn't

00:04:34,200 --> 00:04:38,790
really make sense like how would you

00:04:35,670 --> 00:04:41,610
compare a point in another point like

00:04:38,790 --> 00:04:43,800
you would like a lowercase a and an

00:04:41,610 --> 00:04:45,750
uppercase a that's pretty really pretty

00:04:43,800 --> 00:04:49,370
well understood how we compare those in

00:04:45,750 --> 00:04:52,020
programming but not in spatial data

00:04:49,370 --> 00:04:55,700
ordering that really range is kind of

00:04:52,020 --> 00:04:57,870
sorta so I think it's just as like a

00:04:55,700 --> 00:04:59,760
caveat it's worth thinking of spatial

00:04:57,870 --> 00:05:02,280
data is more like objects kind of opaque

00:04:59,760 --> 00:05:04,170
rather than values that are represented

00:05:02,280 --> 00:05:07,710
with machine primitives so with that

00:05:04,170 --> 00:05:11,040
aside if we if we talk about the sort of

00:05:07,710 --> 00:05:13,800
the root node of spatial data what we

00:05:11,040 --> 00:05:16,440
have geometry and we have geography and

00:05:13,800 --> 00:05:19,890
geometry is the planar this your your

00:05:16,440 --> 00:05:23,190
Jack your geometry class in grade school

00:05:19,890 --> 00:05:25,970
its Euclidean it's it's two-dimensional

00:05:23,190 --> 00:05:32,700
is three-dimensional XY may be X Y Z so

00:05:25,970 --> 00:05:34,230
some some horizon and in a horizontal

00:05:32,700 --> 00:05:38,520
line a vertical line maybe a line coming

00:05:34,230 --> 00:05:40,800
out of the wall and then geography we're

00:05:38,520 --> 00:05:42,540
talking about this the point on an

00:05:40,800 --> 00:05:44,850
ellipsoid so the earth is in a round

00:05:42,540 --> 00:05:46,919
sphere its bulges in the middle we call

00:05:44,850 --> 00:05:51,270
that an ellipsoid and a point on that

00:05:46,919 --> 00:05:53,370
ellipsoid is defined as a point of

00:05:51,270 --> 00:05:55,230
latitude and longitude or maybe we

00:05:53,370 --> 00:06:01,410
include elevation in the third dimension

00:05:55,230 --> 00:06:05,550
and the units of those two types of

00:06:01,410 --> 00:06:07,230
spatial data are in geometry

00:06:05,550 --> 00:06:09,930
it's whatever that the units of that

00:06:07,230 --> 00:06:12,870
plane are so if we've got a four foot by

00:06:09,930 --> 00:06:15,330
six foot map on the wall well the XY

00:06:12,870 --> 00:06:17,880
point on some arbitrary point on the

00:06:15,330 --> 00:06:21,600
wall will be in inches or feet or

00:06:17,880 --> 00:06:24,090
whatever and in geography we talk about

00:06:21,600 --> 00:06:27,120
degrees either in degrees decimal or

00:06:24,090 --> 00:06:28,830
with degrees minutes and seconds and if

00:06:27,120 --> 00:06:30,510
we're in the third dimension we include

00:06:28,830 --> 00:06:35,150
elevation that could be feet or meters

00:06:30,510 --> 00:06:37,800
or whatever and just real quick

00:06:35,150 --> 00:06:39,360
terminologically features you see this a

00:06:37,800 --> 00:06:40,700
lot working with spatial data features

00:06:39,360 --> 00:06:43,430
is just

00:06:40,700 --> 00:06:47,840
a way of saying you've got some domain

00:06:43,430 --> 00:06:51,230
data right like whatever you're tracking

00:06:47,840 --> 00:06:52,670
in your application and you've got which

00:06:51,230 --> 00:06:56,090
has some collection of attribute data

00:06:52,670 --> 00:06:58,040
maybe a name and email ID and then one

00:06:56,090 --> 00:07:01,430
or more geometries so that collection

00:06:58,040 --> 00:07:02,540
that bundle is called a feature so you

00:07:01,430 --> 00:07:10,310
could think of it as like a row in a

00:07:02,540 --> 00:07:12,190
database and in just the so we looked at

00:07:10,310 --> 00:07:14,030
the the two types of spatial data

00:07:12,190 --> 00:07:17,750
geometry and geography they're both

00:07:14,030 --> 00:07:19,910
geometries so they're both they both

00:07:17,750 --> 00:07:21,830
talk about objects that are points lines

00:07:19,910 --> 00:07:23,720
polygons we're all familiar with that

00:07:21,830 --> 00:07:25,790
and then the multiple versions of that

00:07:23,720 --> 00:07:27,650
so you can have a single geometry which

00:07:25,790 --> 00:07:30,590
is a multi-point or a multi string or

00:07:27,650 --> 00:07:34,430
multi polygon or you could have a

00:07:30,590 --> 00:07:36,080
collection of geometries that's agnostic

00:07:34,430 --> 00:07:38,060
about the type so it could be a

00:07:36,080 --> 00:07:42,230
collection of points and line strings

00:07:38,060 --> 00:07:44,240
and then another fundamental type is or

00:07:42,230 --> 00:07:46,580
not necessarily a fundamental type but a

00:07:44,240 --> 00:07:49,820
common type that we work with often our

00:07:46,580 --> 00:07:52,190
bounds it's also known as the minimum

00:07:49,820 --> 00:07:54,230
bounding rectangle sometimes referred to

00:07:52,190 --> 00:07:56,720
as a bounding box or an envelope you'll

00:07:54,230 --> 00:07:58,760
see those words thrown around and these

00:07:56,720 --> 00:08:01,370
are fairly well standardized there's a

00:07:58,760 --> 00:08:03,890
body that says okay these are the kinds

00:08:01,370 --> 00:08:06,050
of geometries that we're working with we

00:08:03,890 --> 00:08:08,470
typically work with and there's kind of

00:08:06,050 --> 00:08:10,520
a fourth one of the fundamental types

00:08:08,470 --> 00:08:11,660
just that I throw I throw out there

00:08:10,520 --> 00:08:13,580
because it's kind of important in the

00:08:11,660 --> 00:08:16,700
linear ring and it's just a bird it's

00:08:13,580 --> 00:08:20,390
just a kind of it's a form of the line

00:08:16,700 --> 00:08:22,640
string or line where the last point or

00:08:20,390 --> 00:08:24,440
the n minus one point is the identical

00:08:22,640 --> 00:08:28,160
to the zero point of the first point and

00:08:24,440 --> 00:08:31,310
that just defines a closed line string

00:08:28,160 --> 00:08:32,690
it's also known as a contour and the

00:08:31,310 --> 00:08:35,620
reason I mentioned the reason important

00:08:32,690 --> 00:08:39,830
is line string or linear rings comprised

00:08:35,620 --> 00:08:42,650
polygons so a polygon is an exterior

00:08:39,830 --> 00:08:46,850
which is a linear ring and maybe has

00:08:42,650 --> 00:08:48,350
zero or more interior linear rings

00:08:46,850 --> 00:08:51,520
there's also some other configurations

00:08:48,350 --> 00:08:51,520
but that's that's the general idea

00:08:52,020 --> 00:08:57,420
and then representationally we can have

00:08:54,380 --> 00:08:58,950
Python objects that represent so I

00:08:57,420 --> 00:09:01,050
talked a little bit about how we

00:08:58,950 --> 00:09:03,060
represent data in the machine with

00:09:01,050 --> 00:09:05,459
values and representationally with

00:09:03,060 --> 00:09:07,920
spatial data can be anything in P or an

00:09:05,459 --> 00:09:11,310
array a list of points coordinates tuple

00:09:07,920 --> 00:09:13,620
a dict where the key is X and the values

00:09:11,310 --> 00:09:17,730
the X is the value of that x coordinate

00:09:13,620 --> 00:09:21,060
and then bounds can be or a bounding box

00:09:17,730 --> 00:09:23,550
is almost always a fort in the case of

00:09:21,060 --> 00:09:24,209
two dimensions a four tuple or a list of

00:09:23,550 --> 00:09:26,610
params

00:09:24,209 --> 00:09:33,120
in some cases it can be a five point

00:09:26,610 --> 00:09:36,810
polygon and a bounding box is just min X

00:09:33,120 --> 00:09:39,180
min Y and Max X max max Y and so in the

00:09:36,810 --> 00:09:43,980
case of the polygon you have the one two

00:09:39,180 --> 00:09:47,490
three four or five points and then when

00:09:43,980 --> 00:09:52,260
you're your sort of work a day functions

00:09:47,490 --> 00:09:53,880
dealing with spatial data one of the

00:09:52,260 --> 00:09:55,529
things you're doing is you're performing

00:09:53,880 --> 00:09:59,579
operations on that data and that

00:09:55,529 --> 00:10:02,730
produces new geometries so you take one

00:09:59,579 --> 00:10:04,140
polygon and another polygon and what's

00:10:02,730 --> 00:10:07,980
the intersection that produces a new

00:10:04,140 --> 00:10:11,970
polygon we also so these are just some

00:10:07,980 --> 00:10:13,680
common operations DIF Union centroid

00:10:11,970 --> 00:10:17,610
getting the center point of a polygon or

00:10:13,680 --> 00:10:19,829
a line string buffer take a point and

00:10:17,610 --> 00:10:21,540
with some amount and create a buffer

00:10:19,829 --> 00:10:25,649
around it or a line string or polygon

00:10:21,540 --> 00:10:28,820
and create a buffer around it and you

00:10:25,649 --> 00:10:31,230
might recognize that the terminology

00:10:28,820 --> 00:10:33,649
looks a lot like dealing with sets and

00:10:31,230 --> 00:10:36,990
that's no accident the set theoretic

00:10:33,649 --> 00:10:39,209
language applies to spatial data we're

00:10:36,990 --> 00:10:41,339
talking about sets of points and how

00:10:39,209 --> 00:10:44,870
they intersect how they are different

00:10:41,339 --> 00:10:44,870
how they create unions

00:10:50,060 --> 00:10:54,740
and just some examples you're probably

00:10:53,090 --> 00:10:56,360
familiar with this kind of thing but if

00:10:54,740 --> 00:10:59,300
not let's imagine we at polygon a

00:10:56,360 --> 00:11:02,390
polygon B and on the right is the output

00:10:59,300 --> 00:11:06,230
of that operation so we have it we have

00:11:02,390 --> 00:11:07,520
an intersection that that green diamond

00:11:06,230 --> 00:11:09,350
in the middle is the intersection of

00:11:07,520 --> 00:11:10,700
those two polygons here's what the

00:11:09,350 --> 00:11:16,670
difference would be like the difference

00:11:10,700 --> 00:11:20,090
in points in it's sort of it's not you

00:11:16,670 --> 00:11:21,680
can't swap the order so polygon a what

00:11:20,090 --> 00:11:23,930
is the difference with polygon B in

00:11:21,680 --> 00:11:25,790
terms of points you swapped it you would

00:11:23,930 --> 00:11:27,530
have output that would be on the

00:11:25,790 --> 00:11:29,150
right-hand side of the green would be on

00:11:27,530 --> 00:11:30,620
the right-hand side in that case so the

00:11:29,150 --> 00:11:33,860
order matters in terms of difference

00:11:30,620 --> 00:11:36,440
like a minus operation or divide Union

00:11:33,860 --> 00:11:38,660
what is the union what what points are

00:11:36,440 --> 00:11:44,150
the union of these two polygons or two

00:11:38,660 --> 00:11:47,810
geometries a centroid point for this

00:11:44,150 --> 00:11:50,960
polygon and a buffer of that centroid so

00:11:47,810 --> 00:11:52,700
a buffer of a point creates a circle a

00:11:50,960 --> 00:11:54,530
buffer of a line string would create

00:11:52,700 --> 00:11:55,940
kind of an ellipse or buffer of a

00:11:54,530 --> 00:11:59,390
polygon would create some crazy-looking

00:11:55,940 --> 00:12:00,860
polygon and then we also have we have

00:11:59,390 --> 00:12:04,280
operations we have predicates and

00:12:00,860 --> 00:12:06,290
predicates answer questions about the

00:12:04,280 --> 00:12:08,060
relationships between two geometries two

00:12:06,290 --> 00:12:10,220
or more geometries we ask whether

00:12:08,060 --> 00:12:13,640
polygon a contains polygon B we ask

00:12:10,220 --> 00:12:16,460
whether line strings C is within polygon

00:12:13,640 --> 00:12:18,470
V we we ask whether they intersect we

00:12:16,460 --> 00:12:20,240
ask whether there's they're disjoint and

00:12:18,470 --> 00:12:26,270
again the set language comes into play

00:12:20,240 --> 00:12:28,040
here and then not only read performing

00:12:26,270 --> 00:12:29,270
operations and predicates on the these

00:12:28,040 --> 00:12:31,190
geometries we're dealing with

00:12:29,270 --> 00:12:33,200
collections of them and here we start to

00:12:31,190 --> 00:12:34,910
get a little more practical so how do we

00:12:33,200 --> 00:12:37,610
deal with these collections efficiently

00:12:34,910 --> 00:12:40,300
well there are two two big families of

00:12:37,610 --> 00:12:44,390
indexes that are unique to spatial data

00:12:40,300 --> 00:12:47,090
the first one is the archery family so

00:12:44,390 --> 00:12:50,470
this is good for all types whether it's

00:12:47,090 --> 00:12:52,850
a point or a polygon of geometry and

00:12:50,470 --> 00:12:56,750
then there's the quadtree which is best

00:12:52,850 --> 00:13:00,560
with point point data only and in our

00:12:56,750 --> 00:13:04,170
tree the core concept is it's a tree

00:13:00,560 --> 00:13:06,329
like a bee tree except that the bounds

00:13:04,170 --> 00:13:08,790
it has a each node has a bounding box

00:13:06,329 --> 00:13:11,850
and that bounding box is the sum or the

00:13:08,790 --> 00:13:15,959
union of all of its sub trees bounding

00:13:11,850 --> 00:13:18,060
boxes and then sort of the the way that

00:13:15,959 --> 00:13:21,959
it works is that you insert you update

00:13:18,060 --> 00:13:24,269
that tree and there's there's each node

00:13:21,959 --> 00:13:25,829
is defined with a maximum capacity and

00:13:24,269 --> 00:13:28,560
when that capacity is reached it splits

00:13:25,829 --> 00:13:30,360
and then the split is designed to

00:13:28,560 --> 00:13:33,649
minimize the overlap between the two new

00:13:30,360 --> 00:13:36,990
nodes in terms of their bounding box so

00:13:33,649 --> 00:13:40,019
this algorithm is actually really hard

00:13:36,990 --> 00:13:43,199
to do optimally so there are a lot of

00:13:40,019 --> 00:13:44,519
heuristics to do it and the the

00:13:43,199 --> 00:13:47,550
difference in the algorithms for

00:13:44,519 --> 00:13:49,709
splitting is what generally defines the

00:13:47,550 --> 00:13:52,589
family of our tree variance and so

00:13:49,709 --> 00:13:55,410
there's our tree original there's our

00:13:52,589 --> 00:13:57,480
star tree there's some others and that

00:13:55,410 --> 00:14:00,959
it's the split algorithm that really

00:13:57,480 --> 00:14:02,850
differentiates them and then the leaf

00:14:00,959 --> 00:14:05,790
nodes are your actual objects or your

00:14:02,850 --> 00:14:08,880
features so the way you would deal with

00:14:05,790 --> 00:14:11,970
an artery would be this is what it might

00:14:08,880 --> 00:14:14,220
look if you plotted in our tree on the

00:14:11,970 --> 00:14:17,490
top and at the bottom a tree diagram you

00:14:14,220 --> 00:14:20,430
can see that the bounding boxes overlap

00:14:17,490 --> 00:14:22,380
you the way you would query it is that

00:14:20,430 --> 00:14:26,029
you say you have a probe and you say is

00:14:22,380 --> 00:14:29,399
is my probe in the bounding box of this

00:14:26,029 --> 00:14:31,620
this other bounding box if yes then

00:14:29,399 --> 00:14:33,740
recursively descend and ask the same

00:14:31,620 --> 00:14:37,769
question if no move on to the next

00:14:33,740 --> 00:14:40,709
object in the in the node you'll notice

00:14:37,769 --> 00:14:43,620
that like for example in the case of 1 &

00:14:40,709 --> 00:14:46,079
2 their bounding boxes overlap so you

00:14:43,620 --> 00:14:48,540
might have to search more than one sub

00:14:46,079 --> 00:14:51,720
tree and there's some and that's the

00:14:48,540 --> 00:14:53,310
reason why optimally splitting nodes is

00:14:51,720 --> 00:14:55,940
so important because you minimize the

00:14:53,310 --> 00:14:58,709
chance that you would have to okay I

00:14:55,940 --> 00:14:59,760
descended down one sub tree I didn't

00:14:58,709 --> 00:15:03,540
find anything I got to go all the way

00:14:59,760 --> 00:15:08,069
back up and do another one real quick a

00:15:03,540 --> 00:15:09,750
quad tree is like I said that's what

00:15:08,069 --> 00:15:11,310
point data and what happens is it

00:15:09,750 --> 00:15:14,699
divides up a space in the quadrants

00:15:11,310 --> 00:15:15,959
recursively and just as a side note if

00:15:14,699 --> 00:15:17,580
people are familiar with the Geo hash

00:15:15,959 --> 00:15:19,500
it's actually concept

00:15:17,580 --> 00:15:20,970
equivalent to that so I encourage you to

00:15:19,500 --> 00:15:23,250
look that up on your own it's a way of

00:15:20,970 --> 00:15:24,810
reducing the dimensionality of like a

00:15:23,250 --> 00:15:28,020
latitude and longitude into a

00:15:24,810 --> 00:15:29,670
one-dimensional string and it's also

00:15:28,020 --> 00:15:30,900
which is the same concept as a

00:15:29,670 --> 00:15:32,640
space-filling curve so that's just

00:15:30,900 --> 00:15:34,530
something to think about if you're

00:15:32,640 --> 00:15:36,990
interested in exploring it further but

00:15:34,530 --> 00:15:39,300
this is what a quadtree looks like again

00:15:36,990 --> 00:15:41,760
dividing up a space recursively by

00:15:39,300 --> 00:15:44,970
quadrants and so your probe would be is

00:15:41,760 --> 00:15:48,360
my point within this bout in this

00:15:44,970 --> 00:15:51,780
quadrant yes or no and then you drill

00:15:48,360 --> 00:15:53,670
down until you find the sub quadrant

00:15:51,780 --> 00:16:00,500
that you're the thing you're looking for

00:15:53,670 --> 00:16:02,610
is in and then index queries are

00:16:00,500 --> 00:16:06,560
generally fall into these three

00:16:02,610 --> 00:16:08,760
categories you're asking given a point

00:16:06,560 --> 00:16:11,940
this is the case of the nearest neighbor

00:16:08,760 --> 00:16:13,590
what are the K or the 50 points closest

00:16:11,940 --> 00:16:17,040
to it or features closest to it

00:16:13,590 --> 00:16:19,530
given a bounding box give me back all

00:16:17,040 --> 00:16:21,660
the features that are within it and if I

00:16:19,530 --> 00:16:23,490
have a point query there may be some

00:16:21,660 --> 00:16:25,410
feature that's directly at that point so

00:16:23,490 --> 00:16:26,850
almost all of your index your day-to-day

00:16:25,410 --> 00:16:31,260
index queries are going to fall into

00:16:26,850 --> 00:16:34,500
these three categories projections put

00:16:31,260 --> 00:16:37,650
so a projection is how we go from the

00:16:34,500 --> 00:16:41,370
the ellipsoid or spheroid earth to a

00:16:37,650 --> 00:16:44,820
flat surface and it's it's you can think

00:16:41,370 --> 00:16:47,340
of it as if you were peeling an orange

00:16:44,820 --> 00:16:49,380
and you had that the skin of the orange

00:16:47,340 --> 00:16:51,360
peeled off how would you flatten it off

00:16:49,380 --> 00:16:53,700
flatten it onto the surface it's one way

00:16:51,360 --> 00:16:56,970
to think about it you would know that it

00:16:53,700 --> 00:16:59,250
doesn't quite that you can't quite get a

00:16:56,970 --> 00:17:00,330
perfect rectangle you've got to make

00:16:59,250 --> 00:17:01,740
some trade-offs so there's different

00:17:00,330 --> 00:17:03,450
trade-offs with different kinds of

00:17:01,740 --> 00:17:05,880
projections I could give a whole talk on

00:17:03,450 --> 00:17:07,709
projections alone I'm just going to

00:17:05,880 --> 00:17:10,980
gloss over them really quickly but

00:17:07,709 --> 00:17:15,180
that's how we go from basically the Big

00:17:10,980 --> 00:17:18,480
Big Jim geometric types to Geographic

00:17:15,180 --> 00:17:19,980
types and vice versa and spatial

00:17:18,480 --> 00:17:23,070
reference systems are basically ways

00:17:19,980 --> 00:17:25,290
that we hang labels on to certain

00:17:23,070 --> 00:17:27,720
projections so projections are this big

00:17:25,290 --> 00:17:30,210
parameterised lists of trigonometric

00:17:27,720 --> 00:17:30,790
operations a spatial reference system is

00:17:30,210 --> 00:17:32,860
a communion

00:17:30,790 --> 00:17:34,780
way of referring to one of those so

00:17:32,860 --> 00:17:36,190
we've got some common ones when you're

00:17:34,780 --> 00:17:38,290
dealing with latitude and longitude

00:17:36,190 --> 00:17:41,740
you're almost all it's you kind of has

00:17:38,290 --> 00:17:45,580
like a default projection which is wgs84

00:17:41,740 --> 00:17:46,750
and that is what I call a fake

00:17:45,580 --> 00:17:49,270
projection because it actually doesn't

00:17:46,750 --> 00:17:51,250
define how you project from latitude and

00:17:49,270 --> 00:17:53,350
longitude on us on the sphere to a flat

00:17:51,250 --> 00:17:56,470
surface but it's sort of a null

00:17:53,350 --> 00:17:58,750
operation that makes it easy to store

00:17:56,470 --> 00:18:00,760
and work with data so you'll often see

00:17:58,750 --> 00:18:10,990
that reference when you're dealing with

00:18:00,760 --> 00:18:12,850
just pure latitude longitude a spherical

00:18:10,990 --> 00:18:15,010
Mercator so people are familiar Google

00:18:12,850 --> 00:18:16,780
Maps this is the projection that Google

00:18:15,010 --> 00:18:20,950
Maps is in it's often called Google

00:18:16,780 --> 00:18:23,440
Mercator and a lot of other web maps

00:18:20,950 --> 00:18:27,100
have adopted it being in Yahoo and Open

00:18:23,440 --> 00:18:29,230
Street Map and others and then there are

00:18:27,100 --> 00:18:30,760
so I'm just talking about this is

00:18:29,230 --> 00:18:32,320
obviously not an exhaustive list I'm

00:18:30,760 --> 00:18:35,140
just referring to a few common ones that

00:18:32,320 --> 00:18:37,120
you might see Texas centric albers

00:18:35,140 --> 00:18:39,940
equal-area this is a particular favorite

00:18:37,120 --> 00:18:41,980
of mine this produces that classic

00:18:39,940 --> 00:18:44,170
shield shape of the US continental US

00:18:41,980 --> 00:18:45,910
and you'll know what I'm talking about

00:18:44,170 --> 00:18:48,610
here in a second and their various state

00:18:45,910 --> 00:18:50,080
plain projections that are great if

00:18:48,610 --> 00:18:52,810
you're dealing with and you need highly

00:18:50,080 --> 00:18:53,800
accurate data about a particular US

00:18:52,810 --> 00:18:55,810
state

00:18:53,800 --> 00:18:59,770
I'm sorry also this talk is fairly

00:18:55,810 --> 00:19:02,500
us-centric but conceptually a lot of

00:18:59,770 --> 00:19:04,360
these things apply to the whole world so

00:19:02,500 --> 00:19:07,630
this is WGA this is what a map like

00:19:04,360 --> 00:19:09,460
might look like in wgs84 in the fake

00:19:07,630 --> 00:19:11,890
projection you can see the US is kind of

00:19:09,460 --> 00:19:13,780
squat this is what it looks would look

00:19:11,890 --> 00:19:14,650
like maybe in Google Maps under the

00:19:13,780 --> 00:19:18,100
spherical Mercator

00:19:14,650 --> 00:19:20,560
and then here's albers equal-area map

00:19:18,100 --> 00:19:22,840
again here's the shield shape of the US

00:19:20,560 --> 00:19:23,890
so there are different what I'm glossing

00:19:22,840 --> 00:19:25,120
over here is they're different

00:19:23,890 --> 00:19:27,550
trade-offs with working with different

00:19:25,120 --> 00:19:29,410
projections this this projection I'm

00:19:27,550 --> 00:19:31,630
showing here it wouldn't make sense for

00:19:29,410 --> 00:19:33,640
the whole world spiracle Mercator the

00:19:31,630 --> 00:19:35,530
reason was picked was it's one that

00:19:33,640 --> 00:19:38,230
works at the highest zoom level to the

00:19:35,530 --> 00:19:40,240
lowest and all over the world and that's

00:19:38,230 --> 00:19:42,280
why it was picked so they're they're

00:19:40,240 --> 00:19:44,879
trade-offs based on what the scope of

00:19:42,280 --> 00:19:50,320
your spatial data are

00:19:44,879 --> 00:19:51,999
real quickly formats they're almost all

00:19:50,320 --> 00:19:55,749
of what I'm talking about here is vector

00:19:51,999 --> 00:19:59,139
data so points and lines and vectors and

00:19:55,749 --> 00:20:00,940
that's typically stored in there's a few

00:19:59,139 --> 00:20:02,679
common formats there's the shape file

00:20:00,940 --> 00:20:04,960
that's the sort of the granddaddy of

00:20:02,679 --> 00:20:08,229
them all it's actually not a file at all

00:20:04,960 --> 00:20:09,789
it's for files or sometimes three

00:20:08,229 --> 00:20:13,570
there's a misspelling oh that should be

00:20:09,789 --> 00:20:18,820
prj which would define projection which

00:20:13,570 --> 00:20:22,109
is sometimes optional the the data about

00:20:18,820 --> 00:20:24,190
the geometric shapes are is in the shape

00:20:22,109 --> 00:20:27,219
it's basically a pointer in the

00:20:24,190 --> 00:20:29,049
shapefile that shx is where the points

00:20:27,219 --> 00:20:31,690
actually live and then the DBF would be

00:20:29,049 --> 00:20:34,950
where your attribute data is geo jason

00:20:31,690 --> 00:20:37,570
is an extension of the JSON format that

00:20:34,950 --> 00:20:39,219
basically brings it into the world of

00:20:37,570 --> 00:20:42,609
features so you have attribute data and

00:20:39,219 --> 00:20:46,119
you have geometric data kml was is i

00:20:42,609 --> 00:20:51,159
think familiar with google maps it's a

00:20:46,119 --> 00:20:53,979
dialect or a version of xml real quick

00:20:51,159 --> 00:20:58,809
wkt stands for well known text and it's

00:20:53,979 --> 00:21:01,119
a simple human readable serialization of

00:20:58,809 --> 00:21:03,429
points lines and polygons that you'll

00:21:01,119 --> 00:21:06,580
often see when you're working with this

00:21:03,429 --> 00:21:08,049
data and real quick raster so not only

00:21:06,580 --> 00:21:09,999
are we talking about vector data we're

00:21:08,049 --> 00:21:11,649
also talking about maps that already

00:21:09,999 --> 00:21:13,869
exist that are already in a particular

00:21:11,649 --> 00:21:15,549
projection and that's what where you

00:21:13,869 --> 00:21:19,089
would find something like a geo tip

00:21:15,549 --> 00:21:22,059
which would let's say you know you've

00:21:19,089 --> 00:21:24,339
got satellite data or some flyover plane

00:21:22,059 --> 00:21:26,559
that's taking orthographic photos that

00:21:24,339 --> 00:21:30,339
that those photos are going to have

00:21:26,559 --> 00:21:37,450
embedded in it the the data about where

00:21:30,339 --> 00:21:41,259
that photo was taken so oops so that

00:21:37,450 --> 00:21:44,549
would be where you often see that in the

00:21:41,259 --> 00:21:49,210
format called geo TIFF sorry about that

00:21:44,549 --> 00:21:50,649
all right okay so we talked that was the

00:21:49,210 --> 00:21:51,639
big conceptual piece that's out of the

00:21:50,649 --> 00:21:54,489
way we can move on to some more

00:21:51,639 --> 00:21:56,320
practical fun stuff and then when we

00:21:54,489 --> 00:21:57,250
talk about libraries really we're

00:21:56,320 --> 00:21:59,050
talking about and

00:21:57,250 --> 00:22:01,510
assuming kind of a UNIX e-platform here

00:21:59,050 --> 00:22:03,520
we're talking about core dependencies

00:22:01,510 --> 00:22:04,390
that are almost always written in C or

00:22:03,520 --> 00:22:07,180
Java

00:22:04,390 --> 00:22:08,470
maybe but mostly C and then the Python

00:22:07,180 --> 00:22:10,780
libraries that you would use kind of on

00:22:08,470 --> 00:22:12,730
top of that to make your life a lot

00:22:10,780 --> 00:22:16,260
easier and you can work in pure Python

00:22:12,730 --> 00:22:18,720
and those common libraries are Google

00:22:16,260 --> 00:22:21,700
ogr which is part of the Google family

00:22:18,720 --> 00:22:24,460
this is for these this provides

00:22:21,700 --> 00:22:25,870
functions for opening vector data some

00:22:24,460 --> 00:22:29,400
of those formats I talked about earlier

00:22:25,870 --> 00:22:34,660
doing transforms in between projections

00:22:29,400 --> 00:22:36,190
Geass is a library that handles some of

00:22:34,660 --> 00:22:39,580
those operations of predicate Sai showed

00:22:36,190 --> 00:22:41,020
you earlier intersection some you know

00:22:39,580 --> 00:22:44,500
is this point within another that's

00:22:41,020 --> 00:22:46,390
often handled by GS proj four is where

00:22:44,500 --> 00:22:48,760
these spatial reference systems are

00:22:46,390 --> 00:22:51,820
defined and Lib spatial index is a

00:22:48,760 --> 00:22:58,120
pretty common c library for working with

00:22:51,820 --> 00:23:00,070
artery data or artery indexes is by no

00:22:58,120 --> 00:23:02,560
means an exhaustive list but here are

00:23:00,070 --> 00:23:04,360
some very common Python libraries that

00:23:02,560 --> 00:23:08,710
you'll encounter working with spatial

00:23:04,360 --> 00:23:12,160
data and maps Shapley are tree map NIC

00:23:08,710 --> 00:23:17,440
geo Django and cartograph Shapley is a

00:23:12,160 --> 00:23:20,140
nice wrapper around GS that that library

00:23:17,440 --> 00:23:22,960
that provides you operations and

00:23:20,140 --> 00:23:26,590
predicates for manipulating geometries

00:23:22,960 --> 00:23:29,770
so you could easily create a point using

00:23:26,590 --> 00:23:31,210
common Python syntax you could create a

00:23:29,770 --> 00:23:33,960
buffer around that point that's the

00:23:31,210 --> 00:23:37,090
amount of the buffer and get the area of

00:23:33,960 --> 00:23:39,520
that point or that new polygon that's

00:23:37,090 --> 00:23:41,650
created from the buffer and then there's

00:23:39,520 --> 00:23:43,690
the wkt the serialization that I

00:23:41,650 --> 00:23:45,900
mentioned earlier and just you must

00:23:43,690 --> 00:23:50,080
people might notice that the area that

00:23:45,900 --> 00:23:52,630
buffered point is not three one four one

00:23:50,080 --> 00:23:55,120
five dot one five nine it's not exactly

00:23:52,630 --> 00:23:57,190
pi and that's because when you buffer a

00:23:55,120 --> 00:23:59,350
point it doesn't actually create a pure

00:23:57,190 --> 00:24:01,330
circle it creates an approximation of a

00:23:59,350 --> 00:24:03,490
circle with a certain number of line

00:24:01,330 --> 00:24:05,350
segments so it's almost like a octagon

00:24:03,490 --> 00:24:07,210
or something hot but with more

00:24:05,350 --> 00:24:09,280
dimensions or not more dimensions but

00:24:07,210 --> 00:24:13,570
points than that so it's an

00:24:09,280 --> 00:24:15,540
approximation and here's an example of

00:24:13,570 --> 00:24:19,270
working with our tree the our tree

00:24:15,540 --> 00:24:23,140
Python library wraps lib spatial index

00:24:19,270 --> 00:24:26,620
and let's say that we have a collection

00:24:23,140 --> 00:24:29,200
of states state features they have a

00:24:26,620 --> 00:24:31,210
like a primary key some attribute data

00:24:29,200 --> 00:24:34,060
and a geometry that geometry could be a

00:24:31,210 --> 00:24:37,510
shapely geometry we create our index we

00:24:34,060 --> 00:24:41,410
iterate over our features and we insert

00:24:37,510 --> 00:24:45,340
into that index that that primary key

00:24:41,410 --> 00:24:47,590
and the bounding box of our feature our

00:24:45,340 --> 00:24:49,120
features geometry and then we let's have

00:24:47,590 --> 00:24:54,220
let's say we have a probe we want to

00:24:49,120 --> 00:24:58,240
find out which state is that point in so

00:24:54,220 --> 00:25:00,520
we create our point and then index dot

00:24:58,240 --> 00:25:02,380
intersection is that essentially

00:25:00,520 --> 00:25:06,330
bounding box query it's a it's an

00:25:02,380 --> 00:25:10,510
iterator so we call list around it and

00:25:06,330 --> 00:25:12,670
the the method call is dot intersection

00:25:10,510 --> 00:25:14,470
and then a bounding box so since we have

00:25:12,670 --> 00:25:17,920
a point we can sort of fake a bounding

00:25:14,470 --> 00:25:20,860
box by repeating the X and the y and

00:25:17,920 --> 00:25:22,120
then that returns two objects and the

00:25:20,860 --> 00:25:24,070
reason it returns two objects is

00:25:22,120 --> 00:25:27,510
remember it's only indexed our bounding

00:25:24,070 --> 00:25:31,180
box so even at that point is only in one

00:25:27,510 --> 00:25:34,360
pop is only in in the world one polygon

00:25:31,180 --> 00:25:35,830
it's in two different bounding boxes if

00:25:34,360 --> 00:25:39,280
you think about the bounding box of a

00:25:35,830 --> 00:25:41,170
state especially some smaller East Coast

00:25:39,280 --> 00:25:43,930
States their bounding boxes could easily

00:25:41,170 --> 00:25:47,350
overlap quite a bit so we so at this

00:25:43,930 --> 00:25:50,380
point we then I don't show it here but

00:25:47,350 --> 00:25:56,830
then what you would do is no I do show

00:25:50,380 --> 00:26:00,450
it here yes at that point we have a list

00:25:56,830 --> 00:26:05,470
of ID's then we would iterate over them

00:26:00,450 --> 00:26:08,110
right and then for each of the so that

00:26:05,470 --> 00:26:10,090
would be the the two that we found doing

00:26:08,110 --> 00:26:12,010
the bounding box query for each of those

00:26:10,090 --> 00:26:13,960
so we've narrowed it down to two for

00:26:12,010 --> 00:26:16,720
each of those then do the expensive

00:26:13,960 --> 00:26:18,910
query of is this point contained by our

00:26:16,720 --> 00:26:20,630
geometry and if we found it break out of

00:26:18,910 --> 00:26:25,100
that and we found at this point

00:26:20,630 --> 00:26:27,350
is in Maryland so conceptually we've

00:26:25,100 --> 00:26:31,880
you've windowed down the search space

00:26:27,350 --> 00:26:33,980
quite a bit by by using a bounding box

00:26:31,880 --> 00:26:36,560
search and then you can iterate over ass

00:26:33,980 --> 00:26:38,530
much smaller set so for example if you

00:26:36,560 --> 00:26:42,050
were working with say there's over

00:26:38,530 --> 00:26:44,000
250,000 voting precincts in the US and

00:26:42,050 --> 00:26:45,410
you wanted to find out where do I go to

00:26:44,000 --> 00:26:49,760
vote and I know my latitude and

00:26:45,410 --> 00:26:52,580
longitude well that's a big o n 250,000

00:26:49,760 --> 00:26:54,170
a number of objects that you would have

00:26:52,580 --> 00:26:56,660
to search through and ask is this point

00:26:54,170 --> 00:26:58,040
within using this using an archery

00:26:56,660 --> 00:27:01,130
career you can window that down to just

00:26:58,040 --> 00:27:03,560
a handful of objects so you're your Big

00:27:01,130 --> 00:27:12,140
O number becomes much smaller and you

00:27:03,560 --> 00:27:14,300
can get an answer real quick okay map

00:27:12,140 --> 00:27:16,610
Nick so map Nick like I mentioned is a

00:27:14,300 --> 00:27:18,110
library for creating maps and just

00:27:16,610 --> 00:27:21,200
terminologically what we're talking

00:27:18,110 --> 00:27:24,530
about our creating basically raster

00:27:21,200 --> 00:27:26,690
images of base maps map tiles you might

00:27:24,530 --> 00:27:29,090
hear that word throwing around it's

00:27:26,690 --> 00:27:32,270
written in C++ it has Python and nodejs

00:27:29,090 --> 00:27:35,330
bindings and it has plugins for reading

00:27:32,270 --> 00:27:38,660
from spatial databases and common vector

00:27:35,330 --> 00:27:40,880
formats and so typically what you would

00:27:38,660 --> 00:27:43,970
do if you're working in a map context on

00:27:40,880 --> 00:27:48,260
the web you would create individual map

00:27:43,970 --> 00:27:50,690
tiles that were say 256 by 256 pixels in

00:27:48,260 --> 00:27:53,540
size and each one of those is rendered

00:27:50,690 --> 00:27:55,520
individually the what happens is your

00:27:53,540 --> 00:27:58,070
browser has some JavaScript that knows

00:27:55,520 --> 00:27:59,810
the extent of your viewport and it

00:27:58,070 --> 00:28:01,610
translates that into some real-world

00:27:59,810 --> 00:28:04,040
latitude and longitude makes a request

00:28:01,610 --> 00:28:06,380
to your server and then it knows to say

00:28:04,040 --> 00:28:07,970
okay I need the tile for this bounding

00:28:06,380 --> 00:28:10,130
box this bounding box this bounding box

00:28:07,970 --> 00:28:12,740
and the Brett so those are each

00:28:10,130 --> 00:28:14,090
individual HTTP requests and then your

00:28:12,740 --> 00:28:16,430
browser does the work of reassembling

00:28:14,090 --> 00:28:18,110
that each of those individual image

00:28:16,430 --> 00:28:19,580
requests back together in your browser

00:28:18,110 --> 00:28:26,000
that's what happens when you use Google

00:28:19,580 --> 00:28:27,650
Maps or comparable product and map Nick

00:28:26,000 --> 00:28:29,740
is pretty flexible you people have done

00:28:27,650 --> 00:28:32,720
some really interesting work with it

00:28:29,740 --> 00:28:33,890
created an 8 date version of the city of

00:28:32,720 --> 00:28:36,110
New York

00:28:33,890 --> 00:28:38,720
so there's a lot you can do with it and

00:28:36,110 --> 00:28:41,179
just hear some some code to create a

00:28:38,720 --> 00:28:47,419
quick map in map Nick you would import

00:28:41,179 --> 00:28:49,720
map Nick you create a map object and it

00:28:47,419 --> 00:28:53,600
has a certain certain height and width

00:28:49,720 --> 00:28:56,270
you create essentially styles and layers

00:28:53,600 --> 00:28:58,809
and those styles match up with layers so

00:28:56,270 --> 00:29:01,309
in our case we would create a polygon

00:28:58,809 --> 00:29:03,260
style that has a certain color a line

00:29:01,309 --> 00:29:06,110
that has a certain color append that to

00:29:03,260 --> 00:29:09,049
our map has a style and then let's say

00:29:06,110 --> 00:29:13,370
we're creating a map of States we would

00:29:09,049 --> 00:29:16,130
query our spatial database we would then

00:29:13,370 --> 00:29:19,039
say that for this layer this certain

00:29:16,130 --> 00:29:21,830
style applies and then append that layer

00:29:19,039 --> 00:29:24,980
to our map and then we use an envelope

00:29:21,830 --> 00:29:28,460
or a bounding box to set the extent of

00:29:24,980 --> 00:29:30,710
our map so we zoom to that box we output

00:29:28,460 --> 00:29:32,899
we we get an image object we render into

00:29:30,710 --> 00:29:34,880
it and then we can return that as a byte

00:29:32,899 --> 00:29:40,070
string that you could serve directly to

00:29:34,880 --> 00:29:43,309
a client or save to a file geo Django is

00:29:40,070 --> 00:29:44,480
a fantastic library that's bundled with

00:29:43,309 --> 00:29:48,080
the Django web framework

00:29:44,480 --> 00:29:52,630
it basically spatially enables the ORM

00:29:48,080 --> 00:29:58,309
in Django and it has nice standalone

00:29:52,630 --> 00:30:00,740
wrappers for G us Google ogr geoip that

00:29:58,309 --> 00:30:03,620
are written in C types nice and clean in

00:30:00,740 --> 00:30:05,779
fact you can even import from those

00:30:03,620 --> 00:30:07,429
wrappers without importing all of the

00:30:05,779 --> 00:30:09,860
Django machinery so if you just need to

00:30:07,429 --> 00:30:13,610
work with spatial data

00:30:09,860 --> 00:30:16,700
I recommend that Shapley either of them

00:30:13,610 --> 00:30:19,850
can work with these of data types and

00:30:16,700 --> 00:30:22,640
file formats really well so here's an

00:30:19,850 --> 00:30:25,370
example of a spatially enabled model in

00:30:22,640 --> 00:30:26,929
geo Django it's it it's a feature

00:30:25,370 --> 00:30:30,309
essentially we've got some attribute

00:30:26,929 --> 00:30:33,649
data about it and then we've got a GM

00:30:30,309 --> 00:30:36,890
which is a multi polygon because states

00:30:33,649 --> 00:30:39,799
have multiple polygons if you think

00:30:36,890 --> 00:30:41,690
about islands or or the state of

00:30:39,799 --> 00:30:44,389
Michigan has two polygons the Upper

00:30:41,690 --> 00:30:46,370
Peninsula and then we and they

00:30:44,389 --> 00:30:47,690
essentially make it spatially enabled by

00:30:46,370 --> 00:30:49,580
creating a

00:30:47,690 --> 00:30:52,519
a different kind of manager for it

00:30:49,580 --> 00:30:53,840
objects equals model study manager so

00:30:52,519 --> 00:30:56,210
let's say we had a different model that

00:30:53,840 --> 00:30:59,000
was congressional districts and we

00:30:56,210 --> 00:31:02,240
wanted to know which of my Django

00:30:59,000 --> 00:31:04,909
objects that our congressional districts

00:31:02,240 --> 00:31:07,039
which of their geometries contain some

00:31:04,909 --> 00:31:11,240
point I'm interested in so you can see

00:31:07,039 --> 00:31:13,940
that it sort of enhances the the ORM

00:31:11,240 --> 00:31:17,090
existing query syntax to make that

00:31:13,940 --> 00:31:19,460
really an easy operation and this is a

00:31:17,090 --> 00:31:21,470
library that I just found out about this

00:31:19,460 --> 00:31:23,419
week that I think is pretty new it's

00:31:21,470 --> 00:31:28,850
only been a worked on for a couple of

00:31:23,419 --> 00:31:30,679
months it's called cartograph and it's a

00:31:28,850 --> 00:31:33,559
library and the command-line interface

00:31:30,679 --> 00:31:35,899
that essentially takes as input shape

00:31:33,559 --> 00:31:40,250
files and a little bit of configuration

00:31:35,899 --> 00:31:42,830
and outputs an SVG file and this is

00:31:40,250 --> 00:31:44,299
really interesting because when you're

00:31:42,830 --> 00:31:45,799
working with spatial data and trying to

00:31:44,299 --> 00:31:47,210
put it on the web there's kind of a

00:31:45,799 --> 00:31:49,250
dance that you need to do about what's

00:31:47,210 --> 00:31:53,779
your base map and what's your feature

00:31:49,250 --> 00:31:55,639
overlay data and this kind of bakes it

00:31:53,779 --> 00:31:57,919
so it would be really cool for like news

00:31:55,639 --> 00:32:00,409
applications and another sort of like

00:31:57,919 --> 00:32:01,340
one-off applications where you're you

00:32:00,409 --> 00:32:04,129
know you need to create like a

00:32:01,340 --> 00:32:06,409
nice-looking base map and and some other

00:32:04,129 --> 00:32:08,179
kind of data visualization on top of it

00:32:06,409 --> 00:32:09,980
and SVG which is very efficient format

00:32:08,179 --> 00:32:12,559
you can style it with CSS you can add

00:32:09,980 --> 00:32:15,440
behavior with JavaScript like the d3

00:32:12,559 --> 00:32:19,039
library or what have you so it's really

00:32:15,440 --> 00:32:21,379
exciting the the developer of it has

00:32:19,039 --> 00:32:23,870
created some beautiful maps in a

00:32:21,379 --> 00:32:25,399
showcase so I was just sort of blown

00:32:23,870 --> 00:32:29,090
away by it and I thought I'd include it

00:32:25,399 --> 00:32:31,429
here's the configuration that you would

00:32:29,090 --> 00:32:33,350
include it's just some JSON to make I

00:32:31,429 --> 00:32:35,389
just did this in like five minutes

00:32:33,350 --> 00:32:38,990
this is this configuration creates this

00:32:35,389 --> 00:32:40,610
map pretty easy and that's an SVG file

00:32:38,990 --> 00:32:47,149
you can load in your browser and include

00:32:40,610 --> 00:32:49,820
in another web page okay real quick so

00:32:47,149 --> 00:32:51,830
there's a couple of applications that

00:32:49,820 --> 00:32:53,990
you might be interested in

00:32:51,830 --> 00:32:55,730
tile stash so I talked earlier about the

00:32:53,990 --> 00:32:57,259
the map Nick and how it renders

00:32:55,730 --> 00:33:00,440
individual tiles that are sent to the

00:32:57,259 --> 00:33:01,280
browser by separate HTTP requests tile

00:33:00,440 --> 00:33:04,220
stashes the

00:33:01,280 --> 00:33:09,220
that kind of handles that ipython new

00:33:04,220 --> 00:33:12,140
version of ipython has inline has a

00:33:09,220 --> 00:33:15,800
graphical console and inline plotting

00:33:12,140 --> 00:33:17,480
that you can marry with spatial data in

00:33:15,800 --> 00:33:20,420
to create interactive console

00:33:17,480 --> 00:33:22,340
visualizations q GS is an exciting

00:33:20,420 --> 00:33:25,730
desktop application I'll talk about in

00:33:22,340 --> 00:33:29,690
one second okay tile stash

00:33:25,730 --> 00:33:32,090
this is a tile server it serves rendered

00:33:29,690 --> 00:33:34,490
map map NIC tile so you can import map

00:33:32,090 --> 00:33:36,830
Nick and point browsers directly at it

00:33:34,490 --> 00:33:39,950
you can serve pre-rendered tiles vector

00:33:36,830 --> 00:33:42,980
data and will also cash out to s3 or

00:33:39,950 --> 00:33:45,200
whatever cash back end you want to make

00:33:42,980 --> 00:33:47,270
subsequent loads that much more

00:33:45,200 --> 00:33:48,770
efficient it's just a wet of whiskey

00:33:47,270 --> 00:33:52,880
application so it's really easy to get

00:33:48,770 --> 00:33:55,670
to work with ipython late new versions

00:33:52,880 --> 00:33:58,340
like I mentioned have a QT console so if

00:33:55,670 --> 00:34:01,570
you're working with Shapley check out a

00:33:58,340 --> 00:34:05,720
library called descartes from pi pi and

00:34:01,570 --> 00:34:08,600
you can get in line plots using the

00:34:05,720 --> 00:34:10,370
matplotlib syntax of your geometric

00:34:08,600 --> 00:34:12,860
objects so this is really exciting this

00:34:10,370 --> 00:34:14,899
is how you invoke it and then you can

00:34:12,860 --> 00:34:18,140
just do pretty straightforward commands

00:34:14,899 --> 00:34:19,280
- these are the intersection graphs that

00:34:18,140 --> 00:34:23,080
I showed you earlier I just did that

00:34:19,280 --> 00:34:26,899
with the cute the ipython QT console

00:34:23,080 --> 00:34:30,710
QGIS this is a desktop application it's

00:34:26,899 --> 00:34:33,050
cross-platform it rivals ArcGIS and

00:34:30,710 --> 00:34:37,220
MapInfo in terms of functionality it's

00:34:33,050 --> 00:34:39,770
open source GPL and you can add layers

00:34:37,220 --> 00:34:41,810
to it from your shape files from spatial

00:34:39,770 --> 00:34:45,970
databases you can do all sorts of

00:34:41,810 --> 00:34:49,130
visualizations and spatial analysis and

00:34:45,970 --> 00:34:52,550
it works with Python you can write

00:34:49,130 --> 00:34:55,700
plugins to extend it that can do

00:34:52,550 --> 00:34:58,190
whatever you want from statistical

00:34:55,700 --> 00:35:00,740
analysis to nearest neighbor whatever

00:34:58,190 --> 00:35:04,100
kind of extension you need you can write

00:35:00,740 --> 00:35:06,950
Python for real quick some data sources

00:35:04,100 --> 00:35:08,810
that you might want to examine to get to

00:35:06,950 --> 00:35:11,570
work with and again us-centric

00:35:08,810 --> 00:35:14,510
caveat here the US Census provides

00:35:11,570 --> 00:35:15,200
freely available data from something

00:35:14,510 --> 00:35:18,170
called Tiger

00:35:15,200 --> 00:35:22,010
line this is streets congressional

00:35:18,170 --> 00:35:25,119
districts County boundaries states just

00:35:22,010 --> 00:35:30,410
a an enormous invaluable wealth of

00:35:25,119 --> 00:35:32,839
freely available data a national atlas

00:35:30,410 --> 00:35:34,000
if you need like shorelines and water

00:35:32,839 --> 00:35:36,770
features that's a great resource

00:35:34,000 --> 00:35:38,599
OpenStreetMap is when I showed you

00:35:36,770 --> 00:35:42,020
earlier Foursquare and Apple or

00:35:38,599 --> 00:35:44,420
converting to these these different Maps

00:35:42,020 --> 00:35:45,770
most of those maps are built using Open

00:35:44,420 --> 00:35:48,500
Street Map which is a collaboratively

00:35:45,770 --> 00:35:51,500
edited streets database which is kind of

00:35:48,500 --> 00:35:53,930
an amazing thing and you can often find

00:35:51,500 --> 00:35:56,599
data from your state and local GIS

00:35:53,930 --> 00:35:58,730
departments they're you know they're

00:35:56,599 --> 00:36:00,619
paid by our tax dollars they have great

00:35:58,730 --> 00:36:04,010
data they're often willing to share it

00:36:00,619 --> 00:36:06,530
so I would check that out I left out a

00:36:04,010 --> 00:36:08,900
lot in this talk there's so much to talk

00:36:06,530 --> 00:36:11,030
about when it comes to this topic

00:36:08,900 --> 00:36:14,450
including spatial databases I didn't get

00:36:11,030 --> 00:36:16,820
into post GIS which i think is the the

00:36:14,450 --> 00:36:21,050
the best out there it spatially enables

00:36:16,820 --> 00:36:22,700
post gray database also working in your

00:36:21,050 --> 00:36:25,670
browser with JavaScript that's where a

00:36:22,700 --> 00:36:27,349
lot of the action happens these these

00:36:25,670 --> 00:36:31,099
are some of the libraries you might use

00:36:27,349 --> 00:36:32,720
and then you things have gotten a lot

00:36:31,099 --> 00:36:34,460
better on the map design front and

00:36:32,720 --> 00:36:37,250
working interactively with design and

00:36:34,460 --> 00:36:38,660
maps and this is not a Python

00:36:37,250 --> 00:36:41,569
application but I thought I mentioned in

00:36:38,660 --> 00:36:44,420
anyway tile mil great great great

00:36:41,569 --> 00:36:47,810
application for for seeing the designs

00:36:44,420 --> 00:36:50,410
of your Maps before you render them so

00:36:47,810 --> 00:36:53,420
real quick I wanted to issue a challenge

00:36:50,410 --> 00:36:56,089
to you all with based on some of the

00:36:53,420 --> 00:36:57,770
information I gave you today I'd like

00:36:56,089 --> 00:36:59,420
you to ask like who is my congressman

00:36:57,770 --> 00:37:01,609
can I write an app to find out who my

00:36:59,420 --> 00:37:04,069
congressman is and you could do this

00:37:01,609 --> 00:37:05,930
with by downloading congressional

00:37:04,069 --> 00:37:08,569
districts and states shape files from

00:37:05,930 --> 00:37:10,550
Tiger Line US Census the sunlight

00:37:08,569 --> 00:37:11,900
foundation has an API to get the names

00:37:10,550 --> 00:37:14,890
of those representatives that are in

00:37:11,900 --> 00:37:18,530
those congressional districts and then

00:37:14,890 --> 00:37:20,990
use a Google Maps geo coder or your

00:37:18,530 --> 00:37:24,740
html5 geolocation in browser to get a

00:37:20,990 --> 00:37:26,599
point of where you're at so just to give

00:37:24,740 --> 00:37:28,640
you a hint of how you might do this I

00:37:26,599 --> 00:37:30,410
would build an archery index

00:37:28,640 --> 00:37:32,360
I would query for all congressional

00:37:30,410 --> 00:37:34,880
districts where that point that we found

00:37:32,360 --> 00:37:36,560
from geocoding is it within and then

00:37:34,880 --> 00:37:38,060
loop over the result set to find the one

00:37:36,560 --> 00:37:39,530
and only one congressional district at

00:37:38,060 --> 00:37:43,430
that point is it and then return the

00:37:39,530 --> 00:37:44,900
name of the congressman and with that

00:37:43,430 --> 00:37:47,680
I'm pretty much wrapped up and ready to

00:37:44,900 --> 00:37:47,680
take some questions

00:38:02,590 --> 00:38:16,010
everybody's already a GIS expert so

00:38:04,940 --> 00:38:18,140
there's no questions yeah what would be

00:38:16,010 --> 00:38:19,810
a good general purpose tool for someone

00:38:18,140 --> 00:38:23,930
who doesn't know what they're doing and

00:38:19,810 --> 00:38:26,150
but in particular when I'm approached it

00:38:23,930 --> 00:38:28,940
before I've been able to get hold of

00:38:26,150 --> 00:38:31,690
some shapefile but I can't translate

00:38:28,940 --> 00:38:33,980
them from one to the next and

00:38:31,690 --> 00:38:37,010
translating shapefile seems to be a

00:38:33,980 --> 00:38:39,050
black art the question so the question

00:38:37,010 --> 00:38:41,270
is how do we translate between different

00:38:39,050 --> 00:38:46,100
formats I would check out something

00:38:41,270 --> 00:38:47,660
called the Google so gdal I talked about

00:38:46,100 --> 00:38:51,920
a little bit earlier there's a

00:38:47,660 --> 00:38:55,220
collection of UNIX binaries that like oh

00:38:51,920 --> 00:38:57,620
gee R - o gr o gr info that is basically

00:38:55,220 --> 00:39:00,880
like a Swiss Army knife for converting

00:38:57,620 --> 00:39:02,900
between formats doing projections

00:39:00,880 --> 00:39:05,270
there's just a lot you can do you could

00:39:02,900 --> 00:39:07,340
say like I've got this huge data set

00:39:05,270 --> 00:39:09,350
some huge shapefile I only care about

00:39:07,340 --> 00:39:11,630
some small bit a bit so you don't so

00:39:09,350 --> 00:39:14,080
extract that part for me so I would

00:39:11,630 --> 00:39:14,080
check that out

00:39:17,030 --> 00:39:22,390
hey maybe you could speak to the

00:39:19,340 --> 00:39:24,590
differences between our trees and

00:39:22,390 --> 00:39:26,720
quadtrees you know in terms of like

00:39:24,590 --> 00:39:27,890
range queries and point queries and so

00:39:26,720 --> 00:39:32,930
forth it seems like you kind of glossed

00:39:27,890 --> 00:39:34,730
over that sure so an artery if your data

00:39:32,930 --> 00:39:37,880
set if you know that your data set is

00:39:34,730 --> 00:39:39,860
going to contain not just points but

00:39:37,880 --> 00:39:41,810
also lines polygons maybe multiple

00:39:39,860 --> 00:39:43,370
versions of those then really our tree

00:39:41,810 --> 00:39:47,930
is the only way to go because it it

00:39:43,370 --> 00:39:49,520
works by the bounding box if if you're

00:39:47,930 --> 00:39:51,080
if you know that your data set is all

00:39:49,520 --> 00:39:53,260
points it's always always going to be

00:39:51,080 --> 00:39:56,330
all points then a quadtree is a fine

00:39:53,260 --> 00:39:58,880
substitute in terms of performance

00:39:56,330 --> 00:40:02,050
I quietly is probably going to beat it

00:39:58,880 --> 00:40:06,200
if it's pure point data on both sides

00:40:02,050 --> 00:40:07,670
but in terms of trade-offs it really

00:40:06,200 --> 00:40:10,370
comes down to which what are your

00:40:07,670 --> 00:40:15,080
geometry types of your of your

00:40:10,370 --> 00:40:17,630
application I so I've got a little

00:40:15,080 --> 00:40:19,640
experience trying to develop mobile

00:40:17,630 --> 00:40:22,700
dashboards that are map based and the

00:40:19,640 --> 00:40:25,430
initial approach was to send all the

00:40:22,700 --> 00:40:27,470
data to the client and so you very

00:40:25,430 --> 00:40:29,240
quickly end up with you know Meg's of

00:40:27,470 --> 00:40:30,920
data on the client and Jason or whatever

00:40:29,240 --> 00:40:33,860
geo jason and trying to do it in the web

00:40:30,920 --> 00:40:37,000
map so do you have any best practices or

00:40:33,860 --> 00:40:39,740
any know of any libraries that help you

00:40:37,000 --> 00:40:42,500
optimize how much data you're going to

00:40:39,740 --> 00:40:44,530
send from server client depending on the

00:40:42,500 --> 00:40:47,360
kind of does that make sense yeah sure

00:40:44,530 --> 00:40:49,210
it's a really hard problem so there are

00:40:47,360 --> 00:40:52,130
a couple of things you could do one is

00:40:49,210 --> 00:40:54,950
oftentimes the serialized representation

00:40:52,130 --> 00:40:57,680
of the geo jason objects the geometries

00:40:54,950 --> 00:40:59,270
has way more precision than you need for

00:40:57,680 --> 00:41:00,890
your application so you often if you

00:40:59,270 --> 00:41:03,310
look at the source of it it might see a

00:41:00,890 --> 00:41:05,720
decimal point and then like 10 or 12

00:41:03,310 --> 00:41:08,480
places after that and you don't need all

00:41:05,720 --> 00:41:11,120
of that like three decimal places is I

00:41:08,480 --> 00:41:12,860
think like you know six six meters of

00:41:11,120 --> 00:41:14,570
accuracy or something like that so you

00:41:12,860 --> 00:41:18,050
could post process the data before it's

00:41:14,570 --> 00:41:19,550
sent to the client to strip that out and

00:41:18,050 --> 00:41:21,080
that will reduce the file size now if

00:41:19,550 --> 00:41:23,840
you're using gzip you might not get that

00:41:21,080 --> 00:41:27,490
much of a difference if you're using

00:41:23,840 --> 00:41:30,440
gzip encoding at your webserver level

00:41:27,490 --> 00:41:32,420
other ways to do it might be to

00:41:30,440 --> 00:41:35,089
this is kind of tricky but can you

00:41:32,420 --> 00:41:37,400
paginate the results in a way like can

00:41:35,089 --> 00:41:38,720
you start with a smaller bounding box

00:41:37,400 --> 00:41:41,510
that may be smaller than the actual

00:41:38,720 --> 00:41:44,390
viewport and return that set and then

00:41:41,510 --> 00:41:46,910
expand the viewport out successively

00:41:44,390 --> 00:41:50,630
send back several responses to the

00:41:46,910 --> 00:41:52,220
client that load without blocking that's

00:41:50,630 --> 00:41:54,109
one way to do it but another problem

00:41:52,220 --> 00:41:56,900
you're going to have is the more objects

00:41:54,109 --> 00:41:58,430
that you have in the client then you're

00:41:56,900 --> 00:42:00,140
going to get poor performance because

00:41:58,430 --> 00:42:01,550
it's tracking all these vertices so

00:42:00,140 --> 00:42:03,980
another suggestion I would have would be

00:42:01,550 --> 00:42:06,410
to look at simplification so

00:42:03,980 --> 00:42:09,410
simplification takes a geometric object

00:42:06,410 --> 00:42:11,300
and removes points that maybe not be

00:42:09,410 --> 00:42:15,680
necessary for display but keeps the

00:42:11,300 --> 00:42:19,550
topographic shape the same there are

00:42:15,680 --> 00:42:22,369
libraries that do that I'm drawing a

00:42:19,550 --> 00:42:25,420
blank at the moment but it's actually

00:42:22,369 --> 00:42:28,730
built in the post GIS you can say

00:42:25,420 --> 00:42:31,750
simplify my geometry by some tolerance

00:42:28,730 --> 00:42:34,579
and it will literally remove vertices

00:42:31,750 --> 00:42:36,619
greatly reduce the file size and

00:42:34,579 --> 00:42:39,109
especially if you're talking about a

00:42:36,619 --> 00:42:40,310
small scale map where your weight sumed

00:42:39,109 --> 00:42:42,410
way out you don't need all that

00:42:40,310 --> 00:42:46,220
resolution so that's something I would

00:42:42,410 --> 00:42:48,440
look at - you mentioned that quad trees

00:42:46,220 --> 00:42:50,480
aren't are only good for point data

00:42:48,440 --> 00:42:51,829
which I found a little disappointing

00:42:50,480 --> 00:42:55,730
because now makes me feel like I've been

00:42:51,829 --> 00:42:58,190
wasting my time on something using

00:42:55,730 --> 00:43:00,800
quadtrees it's possible to define you

00:42:58,190 --> 00:43:03,079
know if you say ABCD as your four

00:43:00,800 --> 00:43:07,970
quadrants you're able to define bounding

00:43:03,079 --> 00:43:10,099
boxes at R Burt arbitrary sizes so that

00:43:07,970 --> 00:43:12,530
you can do a linear search using for

00:43:10,099 --> 00:43:14,869
instance reg X in order to just look at

00:43:12,530 --> 00:43:17,060
the very beginning and determine whether

00:43:14,869 --> 00:43:20,480
or not something falls within that

00:43:17,060 --> 00:43:21,500
bounding box I know it's not strictly a

00:43:20,480 --> 00:43:23,690
quadtree

00:43:21,500 --> 00:43:25,819
but am I going down the wrong path

00:43:23,690 --> 00:43:28,130
hopelessly I mean I'm missing something

00:43:25,819 --> 00:43:29,930
here well I mean what kind of data are

00:43:28,130 --> 00:43:33,069
you trying to index is it point is it

00:43:29,930 --> 00:43:36,800
point data no polygon anything polygon

00:43:33,069 --> 00:43:37,940
multi-part anything I mean you the the

00:43:36,800 --> 00:43:39,260
essential thing that you're doing with

00:43:37,940 --> 00:43:40,640
the quadtree is you're trying to reduce

00:43:39,260 --> 00:43:44,599
the number of dimensions

00:43:40,640 --> 00:43:47,150
you're querying against right so I think

00:43:44,599 --> 00:43:48,680
what you're talking about can be made to

00:43:47,150 --> 00:43:51,920
happen with a lot of work I would look

00:43:48,680 --> 00:43:53,059
at an artery as a substitute instead of

00:43:51,920 --> 00:43:55,609
trying to jump through all these hoops

00:43:53,059 --> 00:43:58,089
to sort of fit your mental model of the

00:43:55,609 --> 00:44:00,980
data you're working at into the quadtree

00:43:58,089 --> 00:44:05,589
there I know there's been a lot of

00:44:00,980 --> 00:44:07,940
research in how we especially unlike

00:44:05,589 --> 00:44:10,039
distributed systems like these indexes

00:44:07,940 --> 00:44:12,170
only really work and make sense if

00:44:10,039 --> 00:44:14,690
you're talking about one node and what

00:44:12,170 --> 00:44:16,700
what would it be like index data across

00:44:14,690 --> 00:44:18,589
multiple nodes and so a lot of people

00:44:16,700 --> 00:44:21,170
are looking at dimension dimensionality

00:44:18,589 --> 00:44:25,010
reduction quadtrees geo hash that sort

00:44:21,170 --> 00:44:26,150
of thing so there may be research out

00:44:25,010 --> 00:44:28,220
there that kind of gets to what you're

00:44:26,150 --> 00:44:29,660
talking about but if if you can get away

00:44:28,220 --> 00:44:31,730
with it I would say just use an artery

00:44:29,660 --> 00:44:34,210
sure I get the real reason would be that

00:44:31,730 --> 00:44:36,859
now you get into a parallel MapReduce

00:44:34,210 --> 00:44:39,769
index search so that you can split up

00:44:36,859 --> 00:44:41,150
and index across you know many things

00:44:39,769 --> 00:44:41,329
and besides it's fun to reinvent the

00:44:41,150 --> 00:44:47,750
wheel

00:44:41,329 --> 00:44:49,839
great hi I was I had this map app in

00:44:47,750 --> 00:44:50,990
mind and I was wondering if there was a

00:44:49,839 --> 00:44:54,079
JavaScript

00:44:50,990 --> 00:44:56,210
oh so I have this map app in mind and I

00:44:54,079 --> 00:44:58,099
was wondering if there's this JavaScript

00:44:56,210 --> 00:45:00,529
library that does what I'm thinking of

00:44:58,099 --> 00:45:03,019
so like say you're you're panning around

00:45:00,529 --> 00:45:05,359
and you want polygons to load

00:45:03,019 --> 00:45:07,549
dynamically kind of behind the scenes in

00:45:05,359 --> 00:45:10,039
an intelligent manner caching in

00:45:07,549 --> 00:45:14,029
JavaScript and only grabbing the dit the

00:45:10,039 --> 00:45:15,740
deltas you need through say like Ajax is

00:45:14,029 --> 00:45:17,779
there any kind of like JavaScript

00:45:15,740 --> 00:45:23,299
library that makes that sort of thing

00:45:17,779 --> 00:45:25,519
easy I'm not sure I would look at open

00:45:23,299 --> 00:45:30,349
layers because it has such a rich

00:45:25,519 --> 00:45:32,109
feature set of functionality but without

00:45:30,349 --> 00:45:34,940
knowing more about your applications

00:45:32,109 --> 00:45:36,769
well I was as you looked at what would

00:45:34,940 --> 00:45:38,000
have you looked at so far I haven't

00:45:36,769 --> 00:45:39,680
looked at anything I was just thinking

00:45:38,000 --> 00:45:41,089
about this and it it sounds definitely

00:45:39,680 --> 00:45:43,069
doable but I was like oh there's

00:45:41,089 --> 00:45:45,079
definitely some tricky things in there

00:45:43,069 --> 00:45:47,390
and I was thinking there's probably

00:45:45,079 --> 00:45:49,250
someone's already done this all right is

00:45:47,390 --> 00:45:50,410
some extent I don't know I mean maybe we

00:45:49,250 --> 00:45:54,670
could talk after

00:45:50,410 --> 00:45:59,650
some options as a quick and dirty I've

00:45:54,670 --> 00:46:02,980
got a various shapes that are in raster

00:45:59,650 --> 00:46:04,869
form what would be the best tool to be

00:46:02,980 --> 00:46:08,710
able to overlay it on to something and

00:46:04,869 --> 00:46:10,960
and or apart from that create shapes

00:46:08,710 --> 00:46:15,760
from scratch where you really got to

00:46:10,960 --> 00:46:17,440
draw them in so you're saying I've got

00:46:15,760 --> 00:46:20,049
some raster's on I want to get vector

00:46:17,440 --> 00:46:22,210
data from yeah or in a little ad or in

00:46:20,049 --> 00:46:24,069
other words I've either got them in

00:46:22,210 --> 00:46:26,530
paper form or I've got them and so I'm

00:46:24,069 --> 00:46:27,700
sure none usable for some you know I can

00:46:26,530 --> 00:46:29,380
look at them but that's all I can do

00:46:27,700 --> 00:46:31,450
with them yeah like sir broadly this

00:46:29,380 --> 00:46:33,609
topic is called like geo registering so

00:46:31,450 --> 00:46:35,289
the idea is that you would take if you

00:46:33,609 --> 00:46:36,819
have a known coordinate space and then

00:46:35,289 --> 00:46:39,130
you have your map whatever it is like a

00:46:36,819 --> 00:46:41,049
scanned object or something all you need

00:46:39,130 --> 00:46:45,130
to do is define three points on it and

00:46:41,049 --> 00:46:47,349
it will wrap that it'll make that raster

00:46:45,130 --> 00:46:50,280
fit the underlying coordinate system and

00:46:47,349 --> 00:46:54,640
there's something called google rap gdal

00:46:50,280 --> 00:46:56,109
WR AP that does this automatically so is

00:46:54,640 --> 00:46:58,119
that an open source tool yeah it's open

00:46:56,109 --> 00:47:05,369
source it's part of the Google family of

00:46:58,119 --> 00:47:12,030
Corbeau Google rap good old GD al yeah

00:47:05,369 --> 00:47:14,970
find me a name here the first one

00:47:12,030 --> 00:47:17,580
I am how do the data structures behave

00:47:14,970 --> 00:47:19,770
when you want to query a polygon that

00:47:17,580 --> 00:47:23,070
cause you know the line on the Kiribati

00:47:19,770 --> 00:47:25,590
Islands where the plus not 118 - 980 are

00:47:23,070 --> 00:47:28,560
the same line so the fact that the earth

00:47:25,590 --> 00:47:30,960
is SPX fear and not a rectangle I'm

00:47:28,560 --> 00:47:34,470
sorry I didn't follow I'm sorry the

00:47:30,960 --> 00:47:37,620
longitude + 180 + - 980 are you talking

00:47:34,470 --> 00:47:40,710
about the the Dateline yeah yeah yeah

00:47:37,620 --> 00:47:45,480
they're basically the long and the short

00:47:40,710 --> 00:47:48,540
of it is that we define longitude to be

00:47:45,480 --> 00:47:50,850
might between minus 180 degrees and plus

00:47:48,540 --> 00:47:52,650
180 degrees so if you have geometric

00:47:50,850 --> 00:47:54,240
objects that span that and this is the

00:47:52,650 --> 00:47:56,760
International Dateline in the middle of

00:47:54,240 --> 00:47:59,010
the Pacific your mathematical

00:47:56,760 --> 00:48:01,770
calculations or whatever can blow up but

00:47:59,010 --> 00:48:05,850
most applications these days you can

00:48:01,770 --> 00:48:08,520
configure to recognize say basically

00:48:05,850 --> 00:48:11,850
like International Dateline equals true

00:48:08,520 --> 00:48:15,210
so a lot of libraries hat will expose

00:48:11,850 --> 00:48:23,090
that as a essentially a workaround all

00:48:15,210 --> 00:48:23,090

YouTube URL: https://www.youtube.com/watch?v=qmgh14LUOjQ


