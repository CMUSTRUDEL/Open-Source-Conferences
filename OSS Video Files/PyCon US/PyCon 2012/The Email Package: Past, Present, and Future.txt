Title: The Email Package: Past, Present, and Future
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	R. David Murray
The email package in the Python Standard library has had a somewhat rocky transition into the Python3 era, and still doesn't handle non-ASCII easily.  That is about to change. This talk will compare how things worked in Python2 (the p
Captions: 
	00:00:00,000 --> 00:00:04,980
oh this is my first ever talk at a

00:00:01,829 --> 00:00:08,040
convention so you'll forgive me if I am

00:00:04,980 --> 00:00:10,710
a little hesitant so first I want to

00:00:08,040 --> 00:00:13,969
give you a little bit of background for

00:00:10,710 --> 00:00:16,139
years very Wars and Barry Warsaw i

00:00:13,969 --> 00:00:20,070
didn't knew your name even though i just

00:00:16,139 --> 00:00:22,560
call you Barry okay and along with the

00:00:20,070 --> 00:00:24,660
Pythons sake were the maintainer of the

00:00:22,560 --> 00:00:26,760
email package in the Python standard

00:00:24,660 --> 00:00:31,230
library and it has a very long history

00:00:26,760 --> 00:00:32,790
and it started well I don't know all the

00:00:31,230 --> 00:00:36,090
history because I wasn't around for it

00:00:32,790 --> 00:00:38,129
so I won't try to go into that Barry

00:00:36,090 --> 00:00:40,890
also wrote and helps maintain the

00:00:38,129 --> 00:00:44,340
mailman package which he'll be talking

00:00:40,890 --> 00:00:46,950
about as the next talk he was involved

00:00:44,340 --> 00:00:53,699
in the port of the email package from

00:00:46,950 --> 00:00:56,610
Python 2 to python 3 and that port had a

00:00:53,699 --> 00:00:58,760
bit of an issue so the big transition

00:00:56,610 --> 00:01:01,770
from Python 2 to python 3 as you know

00:00:58,760 --> 00:01:05,070
was changing the fundamental string type

00:01:01,770 --> 00:01:09,659
of Python from what was essentially a

00:01:05,070 --> 00:01:14,729
binary data type to unicode so the email

00:01:09,659 --> 00:01:18,720
package is designed to deal with email

00:01:14,729 --> 00:01:21,450
messages which to our minds means text

00:01:18,720 --> 00:01:23,490
messages right then something readable

00:01:21,450 --> 00:01:26,729
is what we're trying to transmit from

00:01:23,490 --> 00:01:29,610
one person to another so logically those

00:01:26,729 --> 00:01:30,720
are strengths so you would think okay

00:01:29,610 --> 00:01:32,729
well this is really easy right

00:01:30,720 --> 00:01:36,240
everything strings now everything's

00:01:32,729 --> 00:01:38,280
unicode well no the transmission

00:01:36,240 --> 00:01:47,280
protocol for email is a binary data

00:01:38,280 --> 00:01:48,689
format there's actually the rfcs that

00:01:47,280 --> 00:01:51,960
explain how all this stuff is supposed

00:01:48,689 --> 00:01:55,740
to work give a way to translate binary

00:01:51,960 --> 00:01:57,840
data into a ski only data and when all

00:01:55,740 --> 00:01:58,890
this stuff was done binary data that was

00:01:57,840 --> 00:02:03,570
the only way you could transmit

00:01:58,890 --> 00:02:04,469
non-ascii characters things that weren't

00:02:03,570 --> 00:02:06,750
English so if you wanted to

00:02:04,469 --> 00:02:08,459
internationalize something initially you

00:02:06,750 --> 00:02:10,649
had to use binary you had to use an

00:02:08,459 --> 00:02:12,690
encoding like Latin one or one of the

00:02:10,649 --> 00:02:13,500
other various encoding so this was all

00:02:12,690 --> 00:02:16,620
pre unico

00:02:13,500 --> 00:02:22,200
so really in that intermediate stage

00:02:16,620 --> 00:02:24,540
email is binary so the data that a

00:02:22,200 --> 00:02:27,900
Python 3 e mail package needs to be able

00:02:24,540 --> 00:02:30,540
to handle is binary data but all of the

00:02:27,900 --> 00:02:33,390
algorithms that are in the email package

00:02:30,540 --> 00:02:35,940
deal with text so that proved to be a

00:02:33,390 --> 00:02:38,850
problem so what wound up happening is is

00:02:35,940 --> 00:02:41,670
not in Python 3.1 email could only

00:02:38,850 --> 00:02:44,100
handle nah I could only handle a ski

00:02:41,670 --> 00:02:46,410
data it could not handle a binary

00:02:44,100 --> 00:02:49,410
message that was received off of the

00:02:46,410 --> 00:02:54,800
wire in an email transmission so that

00:02:49,410 --> 00:02:56,790
was a major problem now to solve this

00:02:54,800 --> 00:02:58,020
you figure well we're going to have to

00:02:56,790 --> 00:03:00,870
rewrite all these algorithms so that

00:02:58,020 --> 00:03:03,420
they can handle binary so Barry started

00:03:00,870 --> 00:03:05,940
that rewrite several times and it was a

00:03:03,420 --> 00:03:09,750
major bear I mean it's just not an easy

00:03:05,940 --> 00:03:11,190
thing to do now three years ago I got

00:03:09,750 --> 00:03:13,440
involved as a Python contributor i've

00:03:11,190 --> 00:03:14,940
been using python for many years in my

00:03:13,440 --> 00:03:17,760
work but i decided to actually wanted to

00:03:14,940 --> 00:03:22,739
make contributions to the python project

00:03:17,760 --> 00:03:24,269
itself and i was attracted to the

00:03:22,739 --> 00:03:26,430
internet protocols piece of the standard

00:03:24,269 --> 00:03:28,350
library because most of my career has

00:03:26,430 --> 00:03:30,540
been involved with internet protocols

00:03:28,350 --> 00:03:32,820
one way or another i was director of

00:03:30,540 --> 00:03:35,430
technical services for a couple of small

00:03:32,820 --> 00:03:36,750
ISPs for a number of years so i've done

00:03:35,430 --> 00:03:38,130
a lot of server work I've done a lot of

00:03:36,750 --> 00:03:40,260
email work you know how does all this

00:03:38,130 --> 00:03:49,170
stuff work I understand that protocol

00:03:40,260 --> 00:03:53,660
level pretty well so that is that setup

00:03:49,170 --> 00:03:57,570
that's that's the past alright so now

00:03:53,660 --> 00:03:58,799
the next step was i joined the email

00:03:57,570 --> 00:04:00,329
sake because that was one of the things

00:03:58,799 --> 00:04:02,670
I was interested in and there was an

00:04:00,329 --> 00:04:04,769
ongoing discussion about okay how are we

00:04:02,670 --> 00:04:07,829
actually going to make the email

00:04:04,769 --> 00:04:09,000
packaged in Python 3 work how are we

00:04:07,829 --> 00:04:10,560
going to be able to actually communicate

00:04:09,000 --> 00:04:17,600
with all those mail servers out there

00:04:10,560 --> 00:04:19,950
that are sending this binary data so i

00:04:17,600 --> 00:04:23,400
participated in that discussion and sort

00:04:19,950 --> 00:04:25,150
of became the secretary and collected

00:04:23,400 --> 00:04:26,500
all the ideas and put them into a

00:04:25,150 --> 00:04:28,120
format that we could look at and say

00:04:26,500 --> 00:04:29,919
okay yes that's what we agree with no

00:04:28,120 --> 00:04:34,810
that's not going to work and we came up

00:04:29,919 --> 00:04:37,330
with a plan so the we figured well okay

00:04:34,810 --> 00:04:38,440
it's python3 forget about backward

00:04:37,330 --> 00:04:39,610
compatibility we're just going to

00:04:38,440 --> 00:04:41,530
rewrite this thing so that it works

00:04:39,610 --> 00:04:43,870
right we're going to redesign the API so

00:04:41,530 --> 00:04:46,530
that it's easy to use this is the modern

00:04:43,870 --> 00:04:48,729
era we want to be able to handle

00:04:46,530 --> 00:04:51,970
internationalized text we want to be

00:04:48,729 --> 00:04:54,370
able to handle unicode as the first

00:04:51,970 --> 00:04:55,840
class citizen the way the rest of Python

00:04:54,370 --> 00:04:57,100
3 does so we're going to need to change

00:04:55,840 --> 00:04:58,419
the API we're going to need to change

00:04:57,100 --> 00:05:01,690
ever whatever we need to change

00:04:58,419 --> 00:05:06,430
underneath to make it all work build a

00:05:01,690 --> 00:05:07,690
plan and then we figured well you know

00:05:06,430 --> 00:05:08,860
we'll do that and then what we'll do is

00:05:07,690 --> 00:05:12,039
we'll write a backward compatibility

00:05:08,860 --> 00:05:14,740
layer that can wrap those new api's and

00:05:12,039 --> 00:05:18,039
provide the old API seemed like a good

00:05:14,740 --> 00:05:20,169
plan so I proposed that I would do that

00:05:18,039 --> 00:05:22,389
rewrite I'm an independent consultant so

00:05:20,169 --> 00:05:24,460
I could have time available if somebody

00:05:22,389 --> 00:05:26,410
could pay me some money to do it so I

00:05:24,460 --> 00:05:29,160
put that proposal out and the psf gave

00:05:26,410 --> 00:05:32,620
seed funding to get the project started

00:05:29,160 --> 00:05:34,660
so I began that rewrite and that you

00:05:32,620 --> 00:05:36,580
know I started digging down into the

00:05:34,660 --> 00:05:41,560
underlying layers and figuring out okay

00:05:36,580 --> 00:05:43,810
now how do we handle text and text and

00:05:41,560 --> 00:05:45,669
binary you know we want to handle text

00:05:43,810 --> 00:05:50,620
but we have to handle binary do we make

00:05:45,669 --> 00:05:52,960
a dual algorithm do we do we use the the

00:05:50,620 --> 00:05:54,430
tricks where you have to use slices to

00:05:52,960 --> 00:05:57,340
get a single character out of a binary

00:05:54,430 --> 00:05:58,900
string so that the algorithm can be the

00:05:57,340 --> 00:06:00,659
same when will process and text remember

00:05:58,900 --> 00:06:02,919
presses you know so there are lots of

00:06:00,659 --> 00:06:04,150
possible ways to go about it but what

00:06:02,919 --> 00:06:06,370
that means is that I became very

00:06:04,150 --> 00:06:08,820
familiar with the algorithms that were

00:06:06,370 --> 00:06:11,560
underlying that now in the meantime

00:06:08,820 --> 00:06:15,130
Martin Van Lewis came up with the idea

00:06:11,560 --> 00:06:18,310
of the surrogate escape handler this is

00:06:15,130 --> 00:06:22,180
a way to take binary data and put it in

00:06:18,310 --> 00:06:23,889
a Unicode string in a in a way that

00:06:22,180 --> 00:06:25,030
preserves the meaning of the binary data

00:06:23,889 --> 00:06:29,340
so that you can get it back out again

00:06:25,030 --> 00:06:32,010
later and this is used to handle binary

00:06:29,340 --> 00:06:35,560
binary file names that come from the

00:06:32,010 --> 00:06:37,150
file system where you don't care what

00:06:35,560 --> 00:06:37,550
those binary bites are all you care is

00:06:37,150 --> 00:06:38,960
that it

00:06:37,550 --> 00:06:42,080
presents the name of the file so you

00:06:38,960 --> 00:06:44,510
read it in do you know move it around in

00:06:42,080 --> 00:06:46,640
your program use it to open the file you

00:06:44,510 --> 00:06:49,160
need those bytes to be preserved but you

00:06:46,640 --> 00:06:50,750
don't care what they are okay fine so

00:06:49,160 --> 00:06:53,060
that was one piece of a puzzle the other

00:06:50,750 --> 00:06:56,930
piece of a puzzle is that Antoine patrol

00:06:53,060 --> 00:06:58,430
took the nntp package which has a lot of

00:06:56,930 --> 00:07:03,950
the same problems as the email package

00:06:58,430 --> 00:07:05,600
does but actually deals with that nntp

00:07:03,950 --> 00:07:09,410
deals with binary data in a slightly

00:07:05,600 --> 00:07:11,600
different way and what heats are here we

00:07:09,410 --> 00:07:13,520
wrote the nntp package so it worked with

00:07:11,600 --> 00:07:15,170
unicode in python 3 and one of the

00:07:13,520 --> 00:07:17,510
tricks that he used was that same one

00:07:15,170 --> 00:07:20,330
the Martin used where you get the header

00:07:17,510 --> 00:07:22,760
in from the NTP server you don't care

00:07:20,330 --> 00:07:24,320
what the binary bites actually say you

00:07:22,760 --> 00:07:27,040
just preserve them and then when you

00:07:24,320 --> 00:07:31,280
send them out again you reconstruct them

00:07:27,040 --> 00:07:35,780
so when I saw him do that I thought okay

00:07:31,280 --> 00:07:38,630
so you actually can manipulate binary

00:07:35,780 --> 00:07:40,820
data using the standard Python text

00:07:38,630 --> 00:07:44,060
tools if you don't care what those

00:07:40,820 --> 00:07:47,240
binary bits are all you do all you care

00:07:44,060 --> 00:07:49,130
about is preserving them so based on my

00:07:47,240 --> 00:07:51,800
knowledge of how all the email

00:07:49,130 --> 00:07:54,290
algorithms work under the hood I look

00:07:51,800 --> 00:07:55,520
through and I said yeah ok so just carry

00:07:54,290 --> 00:07:58,490
the bytes along here guide them along

00:07:55,520 --> 00:08:01,160
here make sure that when the user asks

00:07:58,490 --> 00:08:05,330
for the ass for string out of the API

00:08:01,160 --> 00:08:07,370
here okay well now it's an invalid bite

00:08:05,330 --> 00:08:09,920
so we're going to do something with it

00:08:07,370 --> 00:08:13,160
so we'll turn it into a Unicode unknown

00:08:09,920 --> 00:08:16,880
character so that's a hack but it's a

00:08:13,160 --> 00:08:19,220
hack that works so that's the present

00:08:16,880 --> 00:08:20,510
Python 3.2 was released with full binary

00:08:19,220 --> 00:08:23,810
support in the email package you can

00:08:20,510 --> 00:08:25,970
read a binary data file off the off the

00:08:23,810 --> 00:08:28,520
wire you can manipulate it you can send

00:08:25,970 --> 00:08:30,470
it back out there's a binary generator

00:08:28,520 --> 00:08:32,420
that will reconstruct the bytes that you

00:08:30,470 --> 00:08:34,490
got and resend them as long as you

00:08:32,420 --> 00:08:36,740
didn't try to change anything now if you

00:08:34,490 --> 00:08:38,210
had to change something you're going to

00:08:36,740 --> 00:08:40,580
change them into unico done on

00:08:38,210 --> 00:08:43,700
characters and then on the back end or

00:08:40,580 --> 00:08:46,190
you might wind up with a unknown 8-bit

00:08:43,700 --> 00:08:48,089
encoding in your header says I don't

00:08:46,190 --> 00:08:52,610
know what this was but here they are

00:08:48,089 --> 00:08:54,959
I but it works so that's the present now

00:08:52,610 --> 00:08:59,339
going on to the future what happened

00:08:54,959 --> 00:09:03,089
next was that the QX corporation was

00:08:59,339 --> 00:09:04,499
very interested in Python and email and

00:09:03,089 --> 00:09:06,990
they called me up and said do you want

00:09:04,499 --> 00:09:10,889
funding to complete this project I said

00:09:06,990 --> 00:09:14,189
sure and so they paid me to continue to

00:09:10,889 --> 00:09:18,779
work on the email package and bring it

00:09:14,189 --> 00:09:21,089
into the full Python 3 feature using

00:09:18,779 --> 00:09:22,860
that new you know sort of right into

00:09:21,089 --> 00:09:25,559
that new API that we are designed now

00:09:22,860 --> 00:09:26,879
you will recall that I said in that new

00:09:25,559 --> 00:09:29,910
API we were throwing backward

00:09:26,879 --> 00:09:31,620
compatibility out the window well don't

00:09:29,910 --> 00:09:33,749
worry about that because as it turns out

00:09:31,620 --> 00:09:35,790
the way we wound up implementing

00:09:33,749 --> 00:09:41,550
everything we actually retain full

00:09:35,790 --> 00:09:46,199
backward compatibility so it's

00:09:41,550 --> 00:09:50,790
interesting to know that qnx is actually

00:09:46,199 --> 00:09:55,709
using Python 3 the the if you know the

00:09:50,790 --> 00:09:57,540
the PlayBook version 20 has this new PIN

00:09:55,709 --> 00:09:59,129
application personal information manager

00:09:57,540 --> 00:10:01,050
and one of the you know it talks to all

00:09:59,129 --> 00:10:03,749
kinds of servers and unifies everything

00:10:01,050 --> 00:10:05,129
into a single inbox and the back end of

00:10:03,749 --> 00:10:08,579
that the thing that talks to all those

00:10:05,129 --> 00:10:10,910
servers is written in Python 3.2 which i

00:10:08,579 --> 00:10:14,910
think is really cool all right now

00:10:10,910 --> 00:10:16,740
actual what's going on here so email

00:10:14,910 --> 00:10:19,410
past present future the past is Python

00:10:16,740 --> 00:10:24,179
to the president's Python 3.2 the future

00:10:19,410 --> 00:10:27,720
is Python 3.3 and beyond the email

00:10:24,179 --> 00:10:29,370
package has an internal version and this

00:10:27,720 --> 00:10:31,829
is because it started out as an external

00:10:29,370 --> 00:10:33,149
package and there are programs out there

00:10:31,829 --> 00:10:35,040
that test the email version to see

00:10:33,149 --> 00:10:36,949
whether certain features are provided so

00:10:35,040 --> 00:10:39,529
in the past it was email for an earlier

00:10:36,949 --> 00:10:45,149
four-point-oh point 3 is what's in 2.7

00:10:39,529 --> 00:10:47,610
the present is email 5.13 python email

00:10:45,149 --> 00:10:50,639
fun one Python 3.1 was released with

00:10:47,610 --> 00:10:53,100
email 5.0 which was the basic port 5.1

00:10:50,639 --> 00:10:54,600
adds the binary support the future we're

00:10:53,100 --> 00:10:56,720
calling email sex because we're going to

00:10:54,600 --> 00:11:00,379
change the API we're going to add to the

00:10:56,720 --> 00:11:02,449
p I alright so in email everything works

00:11:00,379 --> 00:11:06,889
great as long as you are working with a

00:11:02,449 --> 00:11:10,250
ski create a text message turning into a

00:11:06,889 --> 00:11:15,259
string it does the nice little mind

00:11:10,250 --> 00:11:17,420
things character set USS ki I'll go try

00:11:15,259 --> 00:11:19,490
to use unicode this is Python 2.7 you

00:11:17,420 --> 00:11:22,279
can see the little you there doesn't

00:11:19,490 --> 00:11:25,610
work quite so well but it does work okay

00:11:22,279 --> 00:11:28,009
so the way you actually do it is you

00:11:25,610 --> 00:11:29,509
have to tell it I want you to encode

00:11:28,009 --> 00:11:32,149
this message using the character set

00:11:29,509 --> 00:11:34,579
widen one in this example and it goes

00:11:32,149 --> 00:11:36,740
and does the encoding all right so uses

00:11:34,579 --> 00:11:39,410
the quoted-printable content transfer

00:11:36,740 --> 00:11:45,740
encoding so that works but it's kind of

00:11:39,410 --> 00:11:48,110
annoying all right so we can use I'm

00:11:45,740 --> 00:11:50,720
sorry I mean back up 14 sec so this is a

00:11:48,110 --> 00:11:52,100
binary string that we're giving as input

00:11:50,720 --> 00:11:54,589
so we have to tell it what character

00:11:52,100 --> 00:11:57,019
said that binary string is encoded using

00:11:54,589 --> 00:11:59,329
which is Latin one in this case we can

00:11:57,019 --> 00:12:00,860
also use Unicode and tell it what

00:11:59,329 --> 00:12:03,670
character set we want to encode that

00:12:00,860 --> 00:12:08,329
Unicode too so that works just as well

00:12:03,670 --> 00:12:09,860
now in the present if we use Unicode and

00:12:08,329 --> 00:12:11,990
we tell it what character set we want to

00:12:09,860 --> 00:12:14,329
encode it to in the message that works

00:12:11,990 --> 00:12:15,800
ok so that's the way you do it in Python

00:12:14,329 --> 00:12:22,189
3 you don't have you in front of the

00:12:15,800 --> 00:12:24,529
Unicode string in the future let's make

00:12:22,189 --> 00:12:26,209
this a little easier right utf-8 is

00:12:24,529 --> 00:12:30,709
becoming the default let's just use

00:12:26,209 --> 00:12:32,620
utf-8 as the default an encoded now

00:12:30,709 --> 00:12:35,059
there's a there's a little trick here

00:12:32,620 --> 00:12:37,910
that I'm hiding which is you'll see that

00:12:35,059 --> 00:12:39,529
that quoted-printable that encoding

00:12:37,910 --> 00:12:41,389
usually is using quoted-printable and

00:12:39,529 --> 00:12:45,949
but in fact the email package by default

00:12:41,389 --> 00:12:48,439
will use base64 for utf-8 because you

00:12:45,949 --> 00:12:50,120
might be doing chinese and why would you

00:12:48,439 --> 00:12:53,300
bother with quoted-printable if every

00:12:50,120 --> 00:12:54,949
single character was so i haven't

00:12:53,300 --> 00:12:57,410
written this algorithm yet but what I

00:12:54,949 --> 00:12:59,720
plan to do is do a little checking to

00:12:57,410 --> 00:13:04,759
see whether or not the first chunk of

00:12:59,720 --> 00:13:07,100
the data is going to be what proportion

00:13:04,759 --> 00:13:09,260
of non-ascii characters it has

00:13:07,100 --> 00:13:10,760
if it's mostly a ski we use

00:13:09,260 --> 00:13:13,010
quoted-printable if it's mostly not a

00:13:10,760 --> 00:13:14,120
ski then we use base64 I haven't

00:13:13,010 --> 00:13:18,530
actually written that algorithm yet

00:13:14,120 --> 00:13:20,420
that's a plan now it's actually ok

00:13:18,530 --> 00:13:22,340
that's an API change but it's actually

00:13:20,420 --> 00:13:24,920
okay to do that because right now if you

00:13:22,340 --> 00:13:27,440
don't pass in a character set you

00:13:24,920 --> 00:13:28,880
actually get Unicode in the data that

00:13:27,440 --> 00:13:34,400
you're trying to send on the wire and

00:13:28,880 --> 00:13:38,060
that doesn't work ok so more complicated

00:13:34,400 --> 00:13:41,210
stuff in email headers you can't

00:13:38,060 --> 00:13:44,060
actually put binary data at all you have

00:13:41,210 --> 00:13:46,010
two headers can only be a ski so there

00:13:44,060 --> 00:13:50,540
are various tricks that are used to make

00:13:46,010 --> 00:13:57,230
this this work so if we try our binary

00:13:50,540 --> 00:13:59,330
string in Python 2 and as a header and

00:13:57,230 --> 00:14:00,980
we encode our message we actually get

00:13:59,330 --> 00:14:03,350
binary data in the header and that's

00:14:00,980 --> 00:14:05,480
illegal according to Dr C so that's a

00:14:03,350 --> 00:14:09,020
non-starter be nice if that raised an

00:14:05,480 --> 00:14:13,300
error but it doesn't so what we do I'm

00:14:09,020 --> 00:14:15,950
sorry if we pass in a Unicode string as

00:14:13,300 --> 00:14:19,550
the header then the email package is

00:14:15,950 --> 00:14:20,780
smart enough to say oh this isn't we

00:14:19,550 --> 00:14:22,940
know this isn't asking data this is

00:14:20,780 --> 00:14:26,720
unicode we have to encode it so it

00:14:22,940 --> 00:14:29,540
encodes it to utf-8 by default and the

00:14:26,720 --> 00:14:31,820
header encoder is already does have the

00:14:29,540 --> 00:14:33,110
algorithm minute to see ok is it shorter

00:14:31,820 --> 00:14:34,790
if I encode this using quoted-printable

00:14:33,110 --> 00:14:39,590
or is it shorter if I encoded using

00:14:34,790 --> 00:14:43,160
base64 and does the right thing ok so

00:14:39,590 --> 00:14:44,360
now in 3.2 right if all Unicode string

00:14:43,160 --> 00:14:48,650
so everything's going to work great

00:14:44,360 --> 00:14:51,530
right no I found this bug while I was

00:14:48,650 --> 00:14:54,320
preparing these slides I plan to fix

00:14:51,530 --> 00:14:58,340
this during the sprints so that's a

00:14:54,320 --> 00:14:59,990
problem in the future though it'll work

00:14:58,340 --> 00:15:01,490
better so this algorithm has already

00:14:59,990 --> 00:15:04,670
been written I don't think it's

00:15:01,490 --> 00:15:08,630
committed to the email 6 repository yet

00:15:04,670 --> 00:15:10,430
but this works not only does it do the

00:15:08,630 --> 00:15:12,170
recognize that there's Unicode there and

00:15:10,430 --> 00:15:14,330
do the encoding it also looks for the

00:15:12,170 --> 00:15:16,400
minimum amount that it needs to encode

00:15:14,330 --> 00:15:19,440
in order to make it work so that as much

00:15:16,400 --> 00:15:22,250
as possible is readable in plain text

00:15:19,440 --> 00:15:24,990
okay addresses addresses are even harder

00:15:22,250 --> 00:15:27,330
so we have this function format address

00:15:24,990 --> 00:15:29,370
which will take your display name and

00:15:27,330 --> 00:15:31,650
your actual email address what the RFC's

00:15:29,370 --> 00:15:34,800
calls the outer spec and combine it into

00:15:31,650 --> 00:15:37,350
the correct string except that if you

00:15:34,800 --> 00:15:39,990
pass it a binary string it doesn't do

00:15:37,350 --> 00:15:43,590
any encoding again passes binary data in

00:15:39,990 --> 00:15:45,780
so that's not helpful okay so let's try

00:15:43,590 --> 00:15:47,520
passing new code in well then we get a

00:15:45,780 --> 00:15:50,040
Unicode string back out okay great so we

00:15:47,520 --> 00:15:53,070
can put that in as our header and email

00:15:50,040 --> 00:15:57,360
will automatically encode it right well

00:15:53,070 --> 00:15:59,130
yes and no that's not an RFC valid

00:15:57,360 --> 00:16:01,290
address because you don't have little @

00:15:59,130 --> 00:16:04,380
sign and various other the outer spec

00:16:01,290 --> 00:16:06,690
cannot have Unicode data in it at least

00:16:04,380 --> 00:16:08,730
not in the user name part so now a lot

00:16:06,690 --> 00:16:10,020
of email clients will actually handle

00:16:08,730 --> 00:16:11,940
that they'll decode that and then

00:16:10,020 --> 00:16:14,790
they'll look at it as an actual address

00:16:11,940 --> 00:16:16,380
after decoding it so that's called the

00:16:14,790 --> 00:16:19,110
poss tell principal if you get garbage

00:16:16,380 --> 00:16:22,080
do your best to understand it anyway but

00:16:19,110 --> 00:16:25,140
it's not right so how do you do it

00:16:22,080 --> 00:16:29,430
correctly what you do is you have to use

00:16:25,140 --> 00:16:32,400
a tool kit in the header package to

00:16:29,430 --> 00:16:34,530
create the header and here we're a

00:16:32,400 --> 00:16:36,150
pending the display name first and

00:16:34,530 --> 00:16:38,040
telling it that it's Latin once but it

00:16:36,150 --> 00:16:40,500
knows to encode it correctly then we're

00:16:38,040 --> 00:16:43,260
appending the adder spec and now if we

00:16:40,500 --> 00:16:45,740
encode that header we get a correctly

00:16:43,260 --> 00:16:48,330
for RFC correctly formatted address

00:16:45,740 --> 00:16:50,670
assign that is the header okay

00:16:48,330 --> 00:16:52,470
everything's great but you will notice

00:16:50,670 --> 00:16:54,300
here that you no longer have that nice

00:16:52,470 --> 00:16:57,390
little format address utility that knows

00:16:54,300 --> 00:17:00,050
how to quote things properly that

00:16:57,390 --> 00:17:06,329
doesn't actually matter because if you

00:17:00,050 --> 00:17:09,209
if you encode the if you use an encoded

00:17:06,329 --> 00:17:10,860
word to represent the display name it is

00:17:09,209 --> 00:17:11,910
a single atom there's no extra quoting

00:17:10,860 --> 00:17:14,610
to be done that's all the core do you

00:17:11,910 --> 00:17:16,319
need to do but to know that you have to

00:17:14,610 --> 00:17:17,970
understand the rfcs you have to be

00:17:16,319 --> 00:17:19,829
familiar with how all of this stuff is

00:17:17,970 --> 00:17:21,720
supposed to work you have to put it

00:17:19,829 --> 00:17:25,730
together yourself and that's a little

00:17:21,720 --> 00:17:29,630
suboptimal all right now in the present

00:17:25,730 --> 00:17:31,650
it's not any better but it works

00:17:29,630 --> 00:17:32,910
future here's what we want to have

00:17:31,650 --> 00:17:35,370
happen all right so this is actually

00:17:32,910 --> 00:17:37,680
checked into the Python 3.3 repository

00:17:35,370 --> 00:17:39,570
already format address can understand

00:17:37,680 --> 00:17:40,680
this is unicode let's encode it all

00:17:39,570 --> 00:17:44,130
right so you don't think about that

00:17:40,680 --> 00:17:49,350
anymore what we want to have happen and

00:17:44,130 --> 00:17:51,480
this is partly coded is to actually be

00:17:49,350 --> 00:17:53,520
able to take that string that you got

00:17:51,480 --> 00:17:56,540
from some other message assign it to

00:17:53,520 --> 00:17:58,560
where you want it to go and have it

00:17:56,540 --> 00:18:01,910
understand that as an address and

00:17:58,560 --> 00:18:01,910
correctly included according to the RFC

00:18:02,030 --> 00:18:08,940
other cool stuff now this is where it

00:18:05,280 --> 00:18:11,670
gets exciting okay in order to do that

00:18:08,940 --> 00:18:14,250
trick you know we have to parse an

00:18:11,670 --> 00:18:15,780
address header as an address header and

00:18:14,250 --> 00:18:17,490
once we do that then we can do all kinds

00:18:15,780 --> 00:18:21,210
of other things with that as an address

00:18:17,490 --> 00:18:23,810
so now and add a header that we know is

00:18:21,210 --> 00:18:26,310
what's the RFC's call structured header

00:18:23,810 --> 00:18:29,850
we know the structure we parse the

00:18:26,310 --> 00:18:31,230
structure and we create an object the

00:18:29,850 --> 00:18:33,090
object is still strengths that we have

00:18:31,230 --> 00:18:35,790
backward compatibility but it has extra

00:18:33,090 --> 00:18:38,040
attributes so now we can say okay I want

00:18:35,790 --> 00:18:39,630
the address that's in that header you

00:18:38,040 --> 00:18:42,750
may wonder why I'm using sender here

00:18:39,630 --> 00:18:44,400
I'll explain that in a minute we can say

00:18:42,750 --> 00:18:46,020
okay we've got an address I want the

00:18:44,400 --> 00:18:50,460
name I want the display name field I

00:18:46,020 --> 00:18:52,380
want the address spec field I want the

00:18:50,460 --> 00:18:54,360
user name out of that add respect I want

00:18:52,380 --> 00:18:55,950
the domain out of okay so all of that

00:18:54,360 --> 00:18:57,690
data is now available to your program

00:18:55,950 --> 00:19:03,120
without you having to do any further

00:18:57,690 --> 00:19:05,820
parsing I forget what's here okay now

00:19:03,120 --> 00:19:07,860
what we also want to be able to do so

00:19:05,820 --> 00:19:10,440
I'll field that can take multiple

00:19:07,860 --> 00:19:11,940
addresses we're going to parse that as

00:19:10,440 --> 00:19:14,970
an address list now we have a list of

00:19:11,940 --> 00:19:17,040
addresses so this can give you back a

00:19:14,970 --> 00:19:18,840
couple of address objects the address

00:19:17,040 --> 00:19:23,880
object again has a string representation

00:19:18,840 --> 00:19:25,500
that is the email address as you would

00:19:23,880 --> 00:19:33,390
look at it but it's actually an object

00:19:25,500 --> 00:19:35,760
so it has these same attributes and will

00:19:33,390 --> 00:19:38,320
eventually expose that address object so

00:19:35,760 --> 00:19:40,330
that instead of using format address too

00:19:38,320 --> 00:19:42,070
get a correctly displayed string you

00:19:40,330 --> 00:19:45,880
would use the address object this API is

00:19:42,070 --> 00:19:47,649
not is not really defined yet i'm just

00:19:45,880 --> 00:19:49,539
making something up for the purposes of

00:19:47,649 --> 00:19:56,500
this presentation the point is we want

00:19:49,539 --> 00:19:58,509
to expose that object to you now this is

00:19:56,500 --> 00:20:01,179
something we haven't decided about we

00:19:58,509 --> 00:20:05,380
could do this because we could support

00:20:01,179 --> 00:20:06,759
augmented edition so that you can add an

00:20:05,380 --> 00:20:09,009
address on and it will automatically

00:20:06,759 --> 00:20:11,320
update all of the percy and do the right

00:20:09,009 --> 00:20:14,200
thing with the text there's a different

00:20:11,320 --> 00:20:16,539
possible feature we can have the email

00:20:14,200 --> 00:20:20,409
package can know the to address can only

00:20:16,539 --> 00:20:22,269
appear once in your message and if you

00:20:20,409 --> 00:20:24,279
try to add a second one it's going to

00:20:22,269 --> 00:20:25,899
blow up now you have to understand that

00:20:24,279 --> 00:20:28,210
normally what the email package does

00:20:25,899 --> 00:20:31,240
with headers is you add a second cut you

00:20:28,210 --> 00:20:33,519
you assign to the same header name and

00:20:31,240 --> 00:20:35,230
it appends a new header with that name

00:20:33,519 --> 00:20:36,909
to the end of the list which is what you

00:20:35,230 --> 00:20:38,620
want to do with a lot of headers but not

00:20:36,909 --> 00:20:39,820
what the ones that are unique so we'll

00:20:38,620 --> 00:20:42,759
have to make a decision about how we're

00:20:39,820 --> 00:20:49,090
going to handle that ok let's see how

00:20:42,759 --> 00:20:51,279
fast I can get through this so the add

00:20:49,090 --> 00:20:55,269
string is just one interface that you

00:20:51,279 --> 00:20:59,080
can use on a message so it take it in

00:20:55,269 --> 00:21:02,500
the past it took one optional argument

00:20:59,080 --> 00:21:04,450
whether you emit a UNIX from or not in

00:21:02,500 --> 00:21:09,370
3.2 there's another optional argument

00:21:04,450 --> 00:21:11,200
max header in the future what we want to

00:21:09,370 --> 00:21:13,629
do so there's lots of api's that have

00:21:11,200 --> 00:21:15,009
all these optional parameters so what

00:21:13,629 --> 00:21:17,950
we've done is we've added a policy

00:21:15,009 --> 00:21:19,330
framework so that you can say here's a

00:21:17,950 --> 00:21:20,980
collection here's how I want all of

00:21:19,330 --> 00:21:22,899
these settings to work and you can pass

00:21:20,980 --> 00:21:24,370
it in a number of places in the API and

00:21:22,899 --> 00:21:29,110
it will do the right thing because all

00:21:24,370 --> 00:21:31,389
that data will be carried through so

00:21:29,110 --> 00:21:33,580
here here's a list of the policy

00:21:31,389 --> 00:21:36,309
controls that are available don't worry

00:21:33,580 --> 00:21:41,399
about this it's one thing i want to show

00:21:36,309 --> 00:21:43,840
you which is header folding so right now

00:21:41,399 --> 00:21:45,460
python doesn't unfold headers if a

00:21:43,840 --> 00:21:47,220
header comes in folded the character

00:21:45,460 --> 00:21:51,120
turns are still in the

00:21:47,220 --> 00:21:55,620
on what you get back what we want to do

00:21:51,120 --> 00:21:57,000
is we create so for backward

00:21:55,620 --> 00:21:59,190
compatibility reasons it's still going

00:21:57,000 --> 00:22:01,890
to work that way but if you pass it in a

00:21:59,190 --> 00:22:03,240
different policy the new email six

00:22:01,890 --> 00:22:05,640
policies is probably not going to be the

00:22:03,240 --> 00:22:08,280
name of the policy but that's the idea

00:22:05,640 --> 00:22:10,230
then it will do the unfolding so that

00:22:08,280 --> 00:22:12,000
when you ask for the header you will get

00:22:10,230 --> 00:22:13,490
the unfolded version which is ninety

00:22:12,000 --> 00:22:16,409
nine percent of the time what you want

00:22:13,490 --> 00:22:18,870
same thing with header de co diem right

00:22:16,409 --> 00:22:20,610
you get right now you just get back the

00:22:18,870 --> 00:22:22,799
encoded version and you have to decode

00:22:20,610 --> 00:22:24,690
it and in order to get Unicode you have

00:22:22,799 --> 00:22:26,190
to re you have to create it as a header

00:22:24,690 --> 00:22:27,809
object pass it through the Unicode

00:22:26,190 --> 00:22:32,309
function to get back on after a Unicode

00:22:27,809 --> 00:22:33,539
string so I'm Python 3.2 it's exactly

00:22:32,309 --> 00:22:35,700
the same except you don't have the you

00:22:33,539 --> 00:22:38,100
in front of your string but what we want

00:22:35,700 --> 00:22:40,590
to have happen is that if you say decode

00:22:38,100 --> 00:22:46,140
email six defaults you will actually get

00:22:40,590 --> 00:22:49,440
back the decode header so in the past

00:22:46,140 --> 00:22:51,480
what the email package was is it's a

00:22:49,440 --> 00:22:55,590
partial generator parses email generates

00:22:51,480 --> 00:22:58,200
emails the model that it uses in memory

00:22:55,590 --> 00:23:03,299
is that of the content transfer encoded

00:22:58,200 --> 00:23:05,030
message it's a mime toolkit its RFC 2047

00:23:03,299 --> 00:23:07,590
as those encoded words in your headers

00:23:05,030 --> 00:23:09,780
in order to use the email package now

00:23:07,590 --> 00:23:12,720
you have to understand the rfcs and the

00:23:09,780 --> 00:23:14,520
rfcs are really hard to understand in

00:23:12,720 --> 00:23:16,140
the present it's the same as the past

00:23:14,520 --> 00:23:18,720
but a little bit better unicode support

00:23:16,140 --> 00:23:20,280
what we want to have happen it's still

00:23:18,720 --> 00:23:23,070
an email partial generator but now the

00:23:20,280 --> 00:23:25,350
model is the model of the ideal email

00:23:23,070 --> 00:23:26,820
message that unicode text which is what

00:23:25,350 --> 00:23:29,220
you're really writing and what you

00:23:26,820 --> 00:23:32,159
really want your and you your recipient

00:23:29,220 --> 00:23:34,440
to see it encapsulates the RFC knowledge

00:23:32,159 --> 00:23:37,950
so that you don't have to know it it is

00:23:34,440 --> 00:23:40,380
backward compatible what else do we want

00:23:37,950 --> 00:23:42,690
to do in order to make this happen I had

00:23:40,380 --> 00:23:44,520
to write in our c22 parser so we're

00:23:42,690 --> 00:23:47,640
eventually will expose that which is a

00:23:44,520 --> 00:23:50,190
nice tool we want to add specialized

00:23:47,640 --> 00:23:52,679
support for creating my objects so that

00:23:50,190 --> 00:23:54,360
when when you read in the message you

00:23:52,679 --> 00:23:57,630
don't just get a generation eric my

00:23:54,360 --> 00:24:01,380
object you get an image you get audio

00:23:57,630 --> 00:24:03,880
file as a separate object with special

00:24:01,380 --> 00:24:05,380
be able to write your message bodies out

00:24:03,880 --> 00:24:07,180
to external storage so that you're not

00:24:05,380 --> 00:24:10,900
limited by how much memory you have

00:24:07,180 --> 00:24:12,400
which is really good for embedded create

00:24:10,900 --> 00:24:14,950
better integration with other STD ly

00:24:12,400 --> 00:24:18,400
packages I want pop lied to return you a

00:24:14,950 --> 00:24:21,730
message object ultimately world

00:24:18,400 --> 00:24:23,830
domination so there's actually a meaning

00:24:21,730 --> 00:24:25,540
behind that which is that one of the

00:24:23,830 --> 00:24:27,790
other features of the new email packages

00:24:25,540 --> 00:24:30,280
that it does a lot more sanity checking

00:24:27,790 --> 00:24:32,650
on the input and while it will parse

00:24:30,280 --> 00:24:35,170
anything it makes little notes about

00:24:32,650 --> 00:24:37,810
what was wrong so ultimately I want you

00:24:35,170 --> 00:24:39,160
to be able to submit an email message to

00:24:37,810 --> 00:24:41,970
the email package and get back a

00:24:39,160 --> 00:24:52,060
complete list of all the RFC violations

00:24:41,970 --> 00:24:55,000
right that's it thank you David if

00:24:52,060 --> 00:24:58,240
anyone has any questions for for him

00:24:55,000 --> 00:25:00,420
please come right up here and you can

00:24:58,240 --> 00:25:00,420
ask

00:25:06,480 --> 00:25:16,059
okay uh yeah hi thanks a lot for all the

00:25:13,840 --> 00:25:17,620
great work you've done up to now and and

00:25:16,059 --> 00:25:21,279
the great work that you're going to be

00:25:17,620 --> 00:25:25,000
doing thank you I think it's great I'm

00:25:21,279 --> 00:25:29,710
involved with the mailman project and we

00:25:25,000 --> 00:25:33,220
have some special needs offer email such

00:25:29,710 --> 00:25:37,240
as you know we get an email we were

00:25:33,220 --> 00:25:39,429
basically kind of relaying service but

00:25:37,240 --> 00:25:42,190
there are things there transformations

00:25:39,429 --> 00:25:45,760
to messages that we don't want to make

00:25:42,190 --> 00:25:47,260
right you know we don't want to unfold

00:25:45,760 --> 00:25:50,860
headers and then fold them back in

00:25:47,260 --> 00:25:54,909
different ways we don't necessarily want

00:25:50,860 --> 00:25:57,309
to break signed message----- parts right

00:25:54,909 --> 00:26:00,850
things like that are we going to be able

00:25:57,309 --> 00:26:02,649
to do all that absolutely so that that

00:26:00,850 --> 00:26:05,169
model that I said is the model of the

00:26:02,649 --> 00:26:08,440
ideal message that's the view that the

00:26:05,169 --> 00:26:10,149
user that that the application gets but

00:26:08,440 --> 00:26:12,580
behind the scenes everything is

00:26:10,149 --> 00:26:15,309
preserved one of those policy control

00:26:12,580 --> 00:26:17,110
headings is you know don't touch

00:26:15,309 --> 00:26:18,880
anything you don't have to touch right

00:26:17,110 --> 00:26:20,740
so as long as you don't transform an

00:26:18,880 --> 00:26:22,059
individual header whatever you

00:26:20,740 --> 00:26:24,840
originally got in that's what you get

00:26:22,059 --> 00:26:30,610
back out when you generate the message

00:26:24,840 --> 00:26:34,480
over there those leads handle a judgment

00:26:30,610 --> 00:26:37,299
very well I'm sorry you know doesn't

00:26:34,480 --> 00:26:39,039
handle attachments the question for the

00:26:37,299 --> 00:26:42,909
tape is does it handle attachments well

00:26:39,039 --> 00:26:45,340
um the Python email package in general

00:26:42,909 --> 00:26:48,820
does i'm not sure what specifically

00:26:45,340 --> 00:26:51,159
you're asking about yeah well is it easy

00:26:48,820 --> 00:26:54,340
to send email emails with that

00:26:51,159 --> 00:26:56,200
attachment is it easy to send an email

00:26:54,340 --> 00:27:00,700
with an attachment yeah it does it to

00:26:56,200 --> 00:27:03,220
require special knowledge no and that's

00:27:00,700 --> 00:27:06,970
even true currently you there's a object

00:27:03,220 --> 00:27:09,100
there's a set of classes in the mime sub

00:27:06,970 --> 00:27:10,960
package that represent different object

00:27:09,100 --> 00:27:13,240
types you instantiate one of those you

00:27:10,960 --> 00:27:14,919
pass it whatever your payload is and it

00:27:13,240 --> 00:27:17,440
does everything necessary to format that

00:27:14,919 --> 00:27:19,010
correctly will make that I think will

00:27:17,440 --> 00:27:22,700
ultimately make that even easy

00:27:19,010 --> 00:27:25,490
but it's pretty easy now yeah and what

00:27:22,700 --> 00:27:30,260
about alternate messages like plain text

00:27:25,490 --> 00:27:33,320
and HTML version a plain text or HTML

00:27:30,260 --> 00:27:36,160
version of the same message the question

00:27:33,320 --> 00:27:38,690
is okay a plain text or HTML so you saw

00:27:36,160 --> 00:27:42,020
it went by quickly in that slide but one

00:27:38,690 --> 00:27:43,970
of my policy types with HTTP so that

00:27:42,020 --> 00:27:46,370
means that when I generate a message out

00:27:43,970 --> 00:27:48,020
of that that model it's going to be an

00:27:46,370 --> 00:27:51,170
HTTP format which means there's no

00:27:48,020 --> 00:27:54,830
folding in the headers everything is / r

00:27:51,170 --> 00:27:57,170
/ and instead of /n or if you want if

00:27:54,830 --> 00:27:59,000
you use a policy control that says no

00:27:57,170 --> 00:28:01,070
binary at all it'll do whatever

00:27:59,000 --> 00:28:02,900
transformations are necessary to make

00:28:01,070 --> 00:28:06,320
sure that that message is rendered in

00:28:02,900 --> 00:28:07,700
completely in a ski or if you say you

00:28:06,320 --> 00:28:10,040
know this is normal email then it will

00:28:07,700 --> 00:28:11,800
use 8-bit where he bits allowed not all

00:28:10,040 --> 00:28:15,170
of that is implemented but most of it is

00:28:11,800 --> 00:28:18,260
yeah what I meant was that uh usually

00:28:15,170 --> 00:28:22,010
you want to send both separate plain

00:28:18,260 --> 00:28:27,290
text and separate HTML message in the

00:28:22,010 --> 00:28:28,970
same yeah so cool and this is this is

00:28:27,290 --> 00:28:31,730
still true of the current package in it

00:28:28,970 --> 00:28:33,230
I'm not sure we haven't really talked

00:28:31,730 --> 00:28:35,150
about this part of the API as far as

00:28:33,230 --> 00:28:36,800
future goes but you do have to

00:28:35,150 --> 00:28:38,480
understand a little bit about how my

00:28:36,800 --> 00:28:40,580
messages are structured in order to do

00:28:38,480 --> 00:28:42,650
that you have to build the my message by

00:28:40,580 --> 00:28:44,570
putting the attachments in the right

00:28:42,650 --> 00:28:51,170
place but there are those classes I

00:28:44,570 --> 00:28:53,750
talked about so you have the multi-part

00:28:51,170 --> 00:28:55,460
alternative class and then you attach to

00:28:53,750 --> 00:28:57,890
it your text version and you attach to

00:28:55,460 --> 00:29:00,080
it your HTML version and then it will

00:28:57,890 --> 00:29:03,110
render it correctly so you're dealing

00:29:00,080 --> 00:29:05,990
with objects in the Python library and

00:29:03,110 --> 00:29:11,330
then the library deals with actually

00:29:05,990 --> 00:29:13,910
generating the correct mine well I I

00:29:11,330 --> 00:29:16,960
just had a two quick comments first of

00:29:13,910 --> 00:29:19,340
all thank you very much for not only

00:29:16,960 --> 00:29:22,550
doing the right thing fixing all the

00:29:19,340 --> 00:29:24,290
stupid bugs that I added to the email

00:29:22,550 --> 00:29:28,050
package and all the boneheaded design

00:29:24,290 --> 00:29:30,810
decisions I made so really kudos to you

00:29:28,050 --> 00:29:33,390
I think the emo packages is really

00:29:30,810 --> 00:29:36,450
improve for 3.2 and under your tutelage

00:29:33,390 --> 00:29:37,890
it's going to be awesome for 33 so thank

00:29:36,450 --> 00:29:40,020
you very much for that the other thing

00:29:37,890 --> 00:29:42,300
is I'm wondering are you going to be

00:29:40,020 --> 00:29:44,220
sprinting on email package yes that's a

00:29:42,300 --> 00:29:46,170
very good question right I will be with

00:29:44,220 --> 00:29:47,850
the course print but i'll be working an

00:29:46,170 --> 00:29:50,490
email 60 anyone who wants to help out

00:29:47,850 --> 00:29:54,240
please come we had time for one more

00:29:50,490 --> 00:29:56,040
question okay so call me crazy i like to

00:29:54,240 --> 00:29:58,860
do as much as i can in the terminal and

00:29:56,040 --> 00:30:00,360
currently use mud is my email primary

00:29:58,860 --> 00:30:03,110
email client at work and such like that

00:30:00,360 --> 00:30:06,510
I've decided that I should write my own

00:30:03,110 --> 00:30:08,910
curses based email client and how I got

00:30:06,510 --> 00:30:10,290
started on this yeah okay and so you

00:30:08,910 --> 00:30:11,430
know obviously you've immediately

00:30:10,290 --> 00:30:13,740
convinced me that I should be doing this

00:30:11,430 --> 00:30:15,420
on Python 3 and using the new email

00:30:13,740 --> 00:30:16,830
package i'm curious what timeline there

00:30:15,420 --> 00:30:18,120
is or maybe if you can recommend some

00:30:16,830 --> 00:30:20,610
other packages that i should be looking

00:30:18,120 --> 00:30:22,590
at in the meantime to aid and you know

00:30:20,610 --> 00:30:24,270
just dealing with that and you know in

00:30:22,590 --> 00:30:28,140
the kind of context though well there is

00:30:24,270 --> 00:30:31,530
a package on pi pi which is this last

00:30:28,140 --> 00:30:33,690
slide right okay so the the pre-release

00:30:31,530 --> 00:30:35,070
version is available there's a bunch of

00:30:33,690 --> 00:30:36,720
some of the things I've talked about

00:30:35,070 --> 00:30:39,000
here not too much of it but some of it

00:30:36,720 --> 00:30:41,130
has not yet been committed to has not

00:30:39,000 --> 00:30:46,200
been released on pi PI but is in the

00:30:41,130 --> 00:30:50,940
there's a features sub repositories on

00:30:46,200 --> 00:30:53,580
the Python hg site mercurial site so

00:30:50,940 --> 00:30:54,870
that's there so you could check out that

00:30:53,580 --> 00:30:57,050
and use it or you can wait for me to

00:30:54,870 --> 00:31:00,860
release the next version on pi PI I

00:30:57,050 --> 00:31:03,210
would love to see most of this get into

00:31:00,860 --> 00:31:04,530
Python 3.3 I don't know whether that's

00:31:03,210 --> 00:31:05,670
going to be accepted or not yet I

00:31:04,530 --> 00:31:07,560
haven't even started that conversation

00:31:05,670 --> 00:31:09,920
because I have some cleanup I need to do

00:31:07,560 --> 00:31:12,510
before that would even be possible

00:31:09,920 --> 00:31:15,950
certainly the policy stuff is available

00:31:12,510 --> 00:31:18,360
in 3.3 because that's already in trunk

00:31:15,950 --> 00:31:20,820
but how much of the additional features

00:31:18,360 --> 00:31:22,800
are going to be there is not certain at

00:31:20,820 --> 00:31:24,240
this point but they will go out on pi PI

00:31:22,800 --> 00:31:26,490
so you can use that package in the

00:31:24,240 --> 00:31:29,100
meantime until it actually comes out in

00:31:26,490 --> 00:31:31,700
the release Python ladies and gentlemen

00:31:29,100 --> 00:31:31,700

YouTube URL: https://www.youtube.com/watch?v=C9K8DOe1zWw


