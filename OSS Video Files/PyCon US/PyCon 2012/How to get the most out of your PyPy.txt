Title: How to get the most out of your PyPy
Publication date: 2012-04-29
Playlist: PyCon 2012
Description: 
	Maciej Fijalkowski, Armin Rigo, Alex Gaynor
For many applications PyPy can provide performance benefits right out of the box. However, little details can push your application to perform much better.  In this tutorial we'll give you insights on how t
Captions: 
	00:00:01,399 --> 00:00:08,280
cool so hi everybody thanks to everyone

00:00:05,520 --> 00:00:10,349
for coming we are here to talk about how

00:00:08,280 --> 00:00:12,660
to get the absolute most out of a pie

00:00:10,349 --> 00:00:14,759
pie so I think first we can start off

00:00:12,660 --> 00:00:16,260
introducing ourselves I'm Alex Gaynor

00:00:14,759 --> 00:00:18,150
I've been working on pie pie for

00:00:16,260 --> 00:00:20,640
probably about two and a half years now

00:00:18,150 --> 00:00:21,960
and I've been working on just about

00:00:20,640 --> 00:00:24,330
every part of it

00:00:21,960 --> 00:00:25,920
get the Python interpreter and we're

00:00:24,330 --> 00:00:27,689
going to talk about more about what all

00:00:25,920 --> 00:00:34,079
these levels are and why they exist so

00:00:27,689 --> 00:00:36,090
I'll check with you I'm a Tchaikovsky

00:00:34,079 --> 00:00:40,800
and I also work on pretty much

00:00:36,090 --> 00:00:43,440
everything since 2006 or so and we gonna

00:00:40,800 --> 00:00:45,750
probably run something like talk about

00:00:43,440 --> 00:00:47,550
40 to 45 minutes and the questions and

00:00:45,750 --> 00:00:50,520
stuff it should be as interactive as

00:00:47,550 --> 00:00:52,590
possible and like ask questions anytime

00:00:50,520 --> 00:00:55,110
you want and then we'll run like

00:00:52,590 --> 00:00:57,300
hands-on will give you some code to try

00:00:55,110 --> 00:00:58,530
and optimize and see how it goes and I

00:00:57,300 --> 00:01:00,620
mean would you like to introduce

00:00:58,530 --> 00:01:04,199
yourself

00:01:00,620 --> 00:01:12,119
yes I'm amigo and I'm walkin bye-bye

00:01:04,199 --> 00:01:13,740
since beginning which is 2003 right so

00:01:12,119 --> 00:01:15,630
the first question we want to talk about

00:01:13,740 --> 00:01:17,369
is if we're gonna talk about how to get

00:01:15,630 --> 00:01:19,530
the absolute most out of pie pie in

00:01:17,369 --> 00:01:30,450
terms of performance how do i next slide

00:01:19,530 --> 00:01:32,909
okay so we had to ask what are what is

00:01:30,450 --> 00:01:34,920
optimization so there's any we have any

00:01:32,909 --> 00:01:36,720
ideas about what might be the very first

00:01:34,920 --> 00:01:42,659
rule of optimization no reading the gray

00:01:36,720 --> 00:01:45,630
text exactly you optimization is the

00:01:42,659 --> 00:01:47,549
process of taking a program and changing

00:01:45,630 --> 00:01:49,740
it so that it has the same behavior but

00:01:47,549 --> 00:01:52,200
it executes faster if you've changed the

00:01:49,740 --> 00:01:53,790
behavior then nothing else you've done

00:01:52,200 --> 00:01:56,430
matter I can write a Fibonacci function

00:01:53,790 --> 00:01:57,689
that executes in zero time except for

00:01:56,430 --> 00:02:00,030
it's totally wrong because its

00:01:57,689 --> 00:02:02,130
implementation has returned one it's not

00:02:00,030 --> 00:02:04,439
valid so from the PI pi projects

00:02:02,130 --> 00:02:07,829
perspective we are very big test driven

00:02:04,439 --> 00:02:10,530
development enthusiasts because this is

00:02:07,829 --> 00:02:13,630
a way to have an automated way to tell

00:02:10,530 --> 00:02:15,700
when does your optimization work because

00:02:13,630 --> 00:02:19,870
you know working does not just mean

00:02:15,700 --> 00:02:21,820
faster it means working working so the

00:02:19,870 --> 00:02:29,380
second rule of optimization any guesses

00:02:21,820 --> 00:02:31,750
no reading second rules of optimization

00:02:29,380 --> 00:02:34,330
is it must actually be faster the

00:02:31,750 --> 00:02:37,180
purpose of your process is to make your

00:02:34,330 --> 00:02:38,440
code run faster and that means that you

00:02:37,180 --> 00:02:40,300
need to have an automated way to know if

00:02:38,440 --> 00:02:42,130
it's faster that means good reproducible

00:02:40,300 --> 00:02:44,350
benchmarks in the same way you have

00:02:42,130 --> 00:02:47,830
tests of behavior you need tests of

00:02:44,350 --> 00:02:50,020
performance so you yeah you just need

00:02:47,830 --> 00:02:52,000
repeatability is the the name of the

00:02:50,020 --> 00:02:55,150
game being able to have what you do

00:02:52,000 --> 00:03:01,140
always work and always work any guesses

00:02:55,150 --> 00:03:05,890
on the third and final rule no one ok

00:03:01,140 --> 00:03:07,870
measure twice cut once it's it's really

00:03:05,890 --> 00:03:10,360
easy to take a small program and maybe

00:03:07,870 --> 00:03:12,160
tell why it's slow you know maybe it's a

00:03:10,360 --> 00:03:14,770
hundred lines in a single file it's easy

00:03:12,160 --> 00:03:17,170
to guess that large large applications

00:03:14,770 --> 00:03:19,930
you can't just guess why it's low you

00:03:17,170 --> 00:03:21,880
need to analyze and look at your

00:03:19,930 --> 00:03:23,890
benchmarks and try to understand what it

00:03:21,880 --> 00:03:26,980
is about them so that means tooling in

00:03:23,890 --> 00:03:29,230
order to understand why things are fast

00:03:26,980 --> 00:03:30,430
and why things are slow so these are

00:03:29,230 --> 00:03:32,320
sort of the rules of the game in terms

00:03:30,430 --> 00:03:34,330
of how you actually go about making code

00:03:32,320 --> 00:03:35,890
faster you it you have a way to verify

00:03:34,330 --> 00:03:38,260
their behaviors correct you have a way

00:03:35,890 --> 00:03:41,410
to verify when they get faster and you

00:03:38,260 --> 00:03:43,180
have a way to verify what it is that's

00:03:41,410 --> 00:03:48,010
causing your slowdown see you can work

00:03:43,180 --> 00:03:49,390
on that as your first priority so people

00:03:48,010 --> 00:03:53,380
here I'm guessing are mostly interested

00:03:49,390 --> 00:03:55,360
in performance of things so if people

00:03:53,380 --> 00:03:57,220
are probably mostly targeted cpython

00:03:55,360 --> 00:03:58,450
before in the past what are some other

00:03:57,220 --> 00:04:07,110
things you do on cpython

00:03:58,450 --> 00:04:09,580
to make your code run faster yeah ok oh

00:04:07,110 --> 00:04:12,090
ok so see extensions are a big way to

00:04:09,580 --> 00:04:15,340
make things run fast on cpython

00:04:12,090 --> 00:04:17,430
anyone else any other guesses any sort

00:04:15,340 --> 00:04:20,410
of hacks or tricks you can think of

00:04:17,430 --> 00:04:21,820
bowel methods another big one so we've

00:04:20,410 --> 00:04:24,490
come up with a short list of our own

00:04:21,820 --> 00:04:26,380
tricks that we found so using map

00:04:24,490 --> 00:04:27,460
instead of list comprehensions this is

00:04:26,380 --> 00:04:30,340
sort of the principle used

00:04:27,460 --> 00:04:32,889
writing C code to do it Maps inner loop

00:04:30,340 --> 00:04:34,660
is written in C so on C Python that

00:04:32,889 --> 00:04:37,389
tends to be faster anytime you can find

00:04:34,660 --> 00:04:39,880
a function which has a loop for you that

00:04:37,389 --> 00:04:44,229
tends to be a performance trick on C

00:04:39,880 --> 00:04:46,120
Python making Global's local so instead

00:04:44,229 --> 00:04:47,979
of doing in the middle of a loop looking

00:04:46,120 --> 00:04:53,080
up a global name if you could somehow

00:04:47,979 --> 00:04:56,139
look it up earlier that's faster the by

00:04:53,080 --> 00:04:57,970
method thing Dave talked about grabbing

00:04:56,139 --> 00:05:01,570
the Bob method that's loop function

00:04:57,970 --> 00:05:03,520
calls are slow and most importantly the

00:05:01,570 --> 00:05:05,860
last lines of Python you execute on C

00:05:03,520 --> 00:05:06,970
Python the fast you tend to be the more

00:05:05,860 --> 00:05:09,639
you can find a way to push your

00:05:06,970 --> 00:05:12,910
computations into C code the faster they

00:05:09,639 --> 00:05:15,520
will be these tricks are completely and

00:05:12,910 --> 00:05:18,130
utterly invalid ignore everything you

00:05:15,520 --> 00:05:20,500
thought you knew knew about fast writing

00:05:18,130 --> 00:05:23,280
fast code for Python when you're right

00:05:20,500 --> 00:05:23,280
targeting pi PI

00:06:00,470 --> 00:06:06,980
yeah yeah so tricks sometimes working

00:06:05,150 --> 00:06:09,080
sometimes don't so we won't have a

00:06:06,980 --> 00:06:11,270
holistic understanding of what the

00:06:09,080 --> 00:06:13,730
performance characteristics of running

00:06:11,270 --> 00:06:15,980
Python code aren't pi PI R what's fast

00:06:13,730 --> 00:06:19,160
what's slow you know what do we know

00:06:15,980 --> 00:06:21,560
about how stuff works and I think the

00:06:19,160 --> 00:06:24,230
most important thing about optimizing

00:06:21,560 --> 00:06:26,540
for pi PI is operations don't exist in

00:06:24,230 --> 00:06:29,360
isolation you can't say what is the

00:06:26,540 --> 00:06:31,040
speed of a function call with all a PI

00:06:29,360 --> 00:06:32,900
PI's infrastructure the speed of a

00:06:31,040 --> 00:06:35,390
function call matters is this function

00:06:32,900 --> 00:06:37,100
in line by the just-in-time compiler are

00:06:35,390 --> 00:06:39,140
you calling a sivir function versus a

00:06:37,100 --> 00:06:41,210
Python function does the function of its

00:06:39,140 --> 00:06:43,250
own loop inside it all these sort of

00:06:41,210 --> 00:06:45,590
details are me looking at operations do

00:06:43,250 --> 00:06:47,300
not exist alone you know the the

00:06:45,590 --> 00:06:49,430
canonical example of why can't you make

00:06:47,300 --> 00:06:52,520
Python fast is you have the function

00:06:49,430 --> 00:06:55,850
deff f which takes parameters x and y

00:06:52,520 --> 00:06:57,470
and returns x plus y in isolation you

00:06:55,850 --> 00:06:58,760
know we know in theory you have to do

00:06:57,470 --> 00:07:00,800
all these lookups you have to look for

00:06:58,760 --> 00:07:02,720
the under under add method on X the

00:07:00,800 --> 00:07:05,150
under under our add method on Y all

00:07:02,720 --> 00:07:07,190
these things in the full context of what

00:07:05,150 --> 00:07:10,070
you're doing the JIT can often see oh

00:07:07,190 --> 00:07:12,890
this f of X Y function really only ever

00:07:10,070 --> 00:07:15,140
takes integers and so it has a different

00:07:12,890 --> 00:07:17,230
performance characteristics when it's

00:07:15,140 --> 00:07:21,650
known to be only working on integers so

00:07:17,230 --> 00:07:23,780
operations do not exist on their own so

00:07:21,650 --> 00:07:25,310
if you're all taking this tutorial we've

00:07:23,780 --> 00:07:27,080
probably already convinced you it's it's

00:07:25,310 --> 00:07:29,600
worth knowing more about pi PI and maybe

00:07:27,080 --> 00:07:31,370
targeting it but in general there's

00:07:29,600 --> 00:07:34,190
three reasons to target pi pi we think

00:07:31,370 --> 00:07:35,330
performance memory and our sandbox we're

00:07:34,190 --> 00:07:37,760
really not going to be talking much

00:07:35,330 --> 00:07:39,740
about the sandbox today other than it is

00:07:37,760 --> 00:07:42,950
a thing that lets you execute untrusted

00:07:39,740 --> 00:07:44,680
python code without risk really but

00:07:42,950 --> 00:07:49,040
performance and memory are our real

00:07:44,680 --> 00:07:50,930
focuses for today so these sort of the

00:07:49,040 --> 00:07:54,350
flipside is why not pi PI

00:07:50,930 --> 00:07:57,080
embedding embed embedding Python in some

00:07:54,350 --> 00:07:59,020
other like C application we don't have

00:07:57,080 --> 00:08:02,930
really of the API C Python as for this

00:07:59,020 --> 00:08:06,919
embedded platforms like really really

00:08:02,930 --> 00:08:08,270
low memory stuff like single chip system

00:08:06,919 --> 00:08:10,729
I don't know what you call them chip on

00:08:08,270 --> 00:08:13,820
a board there's a term for them really

00:08:10,729 --> 00:08:17,510
really tiny platforms um things

00:08:13,820 --> 00:08:19,570
x86 or x64 we're working on arm and

00:08:17,510 --> 00:08:22,010
PowerPC

00:08:19,570 --> 00:08:25,010
so PowerPC apparently made some

00:08:22,010 --> 00:08:26,420
accomplished today it will be within I

00:08:25,010 --> 00:08:31,850
don't know a year both of those

00:08:26,420 --> 00:08:33,770
platforms will probably be ready okay so

00:08:31,850 --> 00:08:35,120
yes if you have a machine you want to

00:08:33,770 --> 00:08:39,800
turn into a bill bots talk to us

00:08:35,120 --> 00:08:44,240
afterwards so really right now what we

00:08:39,800 --> 00:08:47,780
have today x86 on OS x window windows 32

00:08:44,240 --> 00:08:49,130
Linux 32 and 64 our primary targeted

00:08:47,780 --> 00:08:53,030
platforms if you're not targeting one of

00:08:49,130 --> 00:08:55,670
those that's unfortunate and the final

00:08:53,030 --> 00:08:57,860
thing is if your codebase is primarily

00:08:55,670 --> 00:09:01,340
or as very important see extensions

00:08:57,860 --> 00:09:03,320
our support for cpython capi is not

00:09:01,340 --> 00:09:06,230
great that does not mean we can

00:09:03,320 --> 00:09:07,490
interface with c code as again talk

00:09:06,230 --> 00:09:10,280
about later we have the ability to

00:09:07,490 --> 00:09:13,220
interface with c code not c code the

00:09:10,280 --> 00:09:16,340
target c pythons api and that's the

00:09:13,220 --> 00:09:18,290
distinction we'll be getting on so the

00:09:16,340 --> 00:09:21,860
the absolute main thing in terms of a

00:09:18,290 --> 00:09:24,410
pipe eyes performance is we have an

00:09:21,860 --> 00:09:26,960
interpreter and we have a JIT C Python

00:09:24,410 --> 00:09:29,300
has just an interpreter if you're

00:09:26,960 --> 00:09:32,510
familiar with like Chrome's v8 that's

00:09:29,300 --> 00:09:36,680
just a JIT we have both and that's

00:09:32,510 --> 00:09:38,840
pretty important and we this works by

00:09:36,680 --> 00:09:41,810
compiling pipe I do assembler for your

00:09:38,840 --> 00:09:45,380
magic which will hopefully be unmagic

00:09:41,810 --> 00:09:46,880
magic after the day goes on and this

00:09:45,380 --> 00:09:50,450
produces the very different performance

00:09:46,880 --> 00:09:51,410
characteristics the important thing in

00:09:50,450 --> 00:09:53,540
really the goal of what we're going to

00:09:51,410 --> 00:09:55,370
talk about today is every virtual

00:09:53,540 --> 00:09:57,350
machine every compiler every interpreter

00:09:55,370 --> 00:10:00,380
they have a sweet spot that is

00:09:57,350 --> 00:10:03,020
operations whose performance is they are

00:10:00,380 --> 00:10:06,200
optimal at so sort of at its most basic

00:10:03,020 --> 00:10:09,200
level most C code is within a good C

00:10:06,200 --> 00:10:11,330
compilers hotspot C is sufficiently low

00:10:09,200 --> 00:10:13,580
level that every operation is as

00:10:11,330 --> 00:10:16,040
efficient as maybe you'd expect it to be

00:10:13,580 --> 00:10:18,200
or as an equivalently written thing by

00:10:16,040 --> 00:10:19,610
hand in machine code would be it's a

00:10:18,200 --> 00:10:22,220
little hand wavy we know it's possible

00:10:19,610 --> 00:10:25,310
to beat the compiler sometimes but all C

00:10:22,220 --> 00:10:27,410
code is sort of efficient and not all

00:10:25,310 --> 00:10:28,639
Python code is efficient we have

00:10:27,410 --> 00:10:30,019
we have all these abstractions we have

00:10:28,639 --> 00:10:32,269
the garbage collector everything is an

00:10:30,019 --> 00:10:35,209
object we don't know the type said we

00:10:32,269 --> 00:10:36,709
have all these abstractions which a lot

00:10:35,209 --> 00:10:38,209
of times we can defeat them and we'll be

00:10:36,709 --> 00:10:39,949
talking about when we sort of quote

00:10:38,209 --> 00:10:42,500
defeat the abstraction and get the

00:10:39,949 --> 00:10:44,839
performance that you know we might

00:10:42,500 --> 00:10:46,850
expect that the raw machine has but

00:10:44,839 --> 00:10:48,980
sometimes we don't and understanding

00:10:46,850 --> 00:10:50,629
where the what that sweet slot is what

00:10:48,980 --> 00:10:53,540
that set of operations that's as

00:10:50,629 --> 00:10:55,519
efficient as we'd like is uh the the

00:10:53,540 --> 00:10:57,529
goal and of course we're always trying

00:10:55,519 --> 00:10:59,029
to expand the sweet spot there are

00:10:57,529 --> 00:11:00,350
things that we say are inefficient today

00:10:59,029 --> 00:11:02,720
that might be more efficient tomorrow

00:11:00,350 --> 00:11:03,620
it's unlikely that there are things that

00:11:02,720 --> 00:11:05,629
are efficient today it will be

00:11:03,620 --> 00:11:07,310
inefficient tomorrow we we have

00:11:05,629 --> 00:11:09,230
benchmarks and you know tests of our

00:11:07,310 --> 00:11:11,050
performance to try to ensure we never

00:11:09,230 --> 00:11:15,110
have regressions like that

00:11:11,050 --> 00:11:17,360
so cpython sweet spot really tends to be

00:11:15,110 --> 00:11:19,930
moving a computation to see so this is

00:11:17,360 --> 00:11:24,920
sort of an example of the tricks so

00:11:19,930 --> 00:11:27,199
instead of uh doing X dot a for X in my

00:11:24,920 --> 00:11:31,310
list we're moving into the adder getter

00:11:27,199 --> 00:11:33,560
and my list and this is basically see

00:11:31,310 --> 00:11:36,259
python is just an interpreter every

00:11:33,560 --> 00:11:39,079
single function you have gets compiled

00:11:36,259 --> 00:11:41,899
to bytecode which the C Python VM then

00:11:39,079 --> 00:11:43,370
executes s-- virtual machines

00:11:41,899 --> 00:11:45,860
interpreters like this they have an

00:11:43,370 --> 00:11:48,860
overhead every single bytecode you

00:11:45,860 --> 00:11:51,019
execute the interpreter needs to fetch

00:11:48,860 --> 00:11:52,610
the bytecode from memory needs to decode

00:11:51,019 --> 00:11:54,589
what the operation is it needs to jump

00:11:52,610 --> 00:11:57,050
to its implementation of this all of

00:11:54,589 --> 00:11:59,029
this has a an overhead I think we found

00:11:57,050 --> 00:12:00,649
that in pipe I'm just removing that and

00:11:59,029 --> 00:12:02,660
doing absolutely nothing else is like a

00:12:00,649 --> 00:12:06,740
factor of two difference just removing

00:12:02,660 --> 00:12:11,389
the bytecode interpreter depends like

00:12:06,740 --> 00:12:14,180
everything so pipe eyes sweet spot is uh

00:12:11,389 --> 00:12:16,850
you know quote unquote simple pythons

00:12:14,180 --> 00:12:19,189
things which basically means if a human

00:12:16,850 --> 00:12:20,809
can read this and understand that it

00:12:19,189 --> 00:12:22,519
tends to be that the machine can read

00:12:20,809 --> 00:12:23,930
and understand it well or not read it

00:12:22,519 --> 00:12:27,889
but can execute and understand what it's

00:12:23,930 --> 00:12:29,750
doing and in generally if the machine

00:12:27,889 --> 00:12:31,160
doesn't understand what it's doing

00:12:29,750 --> 00:12:33,559
that's when you tend to leave the

00:12:31,160 --> 00:12:35,569
performance sweet spot if it's somehow

00:12:33,559 --> 00:12:37,639
more complicated it's not necessarily

00:12:35,569 --> 00:12:40,730
with the set of operations you do but

00:12:37,639 --> 00:12:41,240
whether the JIT has you can see the full

00:12:40,730 --> 00:12:43,279
scope

00:12:41,240 --> 00:12:45,050
what you're trying to do that is the

00:12:43,279 --> 00:12:47,630
more clearly you express your intentions

00:12:45,050 --> 00:12:49,610
to the JIT the better it tends to be

00:12:47,630 --> 00:13:00,680
able to actually execute your intentions

00:12:49,610 --> 00:13:04,010
efficiently so you want to yes okay so

00:13:00,680 --> 00:13:07,940
maybe the short introduction to the

00:13:04,010 --> 00:13:09,290
architecture the architecture of Taipei

00:13:07,940 --> 00:13:12,110
is pretty confusing and people get

00:13:09,290 --> 00:13:15,500
constantly confused but I'll try to keep

00:13:12,110 --> 00:13:17,709
that simple so first it's like bytecode

00:13:15,500 --> 00:13:19,730
interpreter the bytecode interpreter

00:13:17,709 --> 00:13:22,220
itself is written in a high-level

00:13:19,730 --> 00:13:24,050
language it doesn't quite matter what

00:13:22,220 --> 00:13:26,450
sort of high-level language disease but

00:13:24,050 --> 00:13:30,110
this is not see in our case this is our

00:13:26,450 --> 00:13:31,490
Python which happens to be a restricted

00:13:30,110 --> 00:13:34,640
subset of Python but this is not that

00:13:31,490 --> 00:13:36,350
crucial it's the crucial part is we have

00:13:34,640 --> 00:13:40,000
a description of the interpreter written

00:13:36,350 --> 00:13:42,140
high-level language and that gives us

00:13:40,000 --> 00:13:45,140
quite some possibilities that are

00:13:42,140 --> 00:13:47,600
relatively hard on C Python or any any

00:13:45,140 --> 00:13:49,520
sort of VM that's written in in C

00:13:47,600 --> 00:13:53,390
because we are able to analyze the

00:13:49,520 --> 00:13:55,459
entire interpreter for things so the

00:13:53,390 --> 00:13:59,240
main interpreter loop is written in our

00:13:55,459 --> 00:14:02,540
Python and you can run the pi PI as a

00:13:59,240 --> 00:14:05,600
Python program so if you have a check

00:14:02,540 --> 00:14:07,700
out you can you can the check out this

00:14:05,600 --> 00:14:10,310
on the USB sticks or you can just check

00:14:07,700 --> 00:14:12,770
out this from AG you can just run in bin

00:14:10,310 --> 00:14:18,709
directory there is PI dot pi you can run

00:14:12,770 --> 00:14:21,440
it well I suggest you actually do and if

00:14:18,709 --> 00:14:23,839
you run Python pi it it's a Python

00:14:21,440 --> 00:14:25,760
program that starts for like 20 seconds

00:14:23,839 --> 00:14:29,000
or something like this it is really slow

00:14:25,760 --> 00:14:31,339
but PI bi is a Python program that

00:14:29,000 --> 00:14:33,620
happens to interpret Python it's

00:14:31,339 --> 00:14:35,630
specifically written yes but it's it's

00:14:33,620 --> 00:14:38,209
also a Python program that interprets

00:14:35,630 --> 00:14:41,660
Python so if you run this and say a

00:14:38,209 --> 00:14:44,480
equals three for example you can press

00:14:41,660 --> 00:14:46,670
control C and that will get you to

00:14:44,480 --> 00:14:48,589
different level console where you get

00:14:46,670 --> 00:14:52,430
rough objects so you'll have W

00:14:48,589 --> 00:14:54,529
underscore a that will that will be a

00:14:52,430 --> 00:14:55,070
wrapped object that will be a Python

00:14:54,529 --> 00:14:58,070
object

00:14:55,070 --> 00:15:00,800
but a Python object on the on the actual

00:14:58,070 --> 00:15:07,880
VM not on the interpreter Python

00:15:00,800 --> 00:15:10,880
interpreter so we also wrote a JIT in

00:15:07,880 --> 00:15:15,500
our Python and the important part is the

00:15:10,880 --> 00:15:18,680
JIT is it's an our Python it's not a

00:15:15,500 --> 00:15:22,010
program really it's a transformation so

00:15:18,680 --> 00:15:25,700
we take our interpreter and we transform

00:15:22,010 --> 00:15:29,030
it to to create a JIT for a Python

00:15:25,700 --> 00:15:33,080
interpreter so for example the way we

00:15:29,030 --> 00:15:35,300
test the JIT is we have tons of small

00:15:33,080 --> 00:15:37,490
our Python programs that happen to be

00:15:35,300 --> 00:15:40,250
very strange interpreters that test like

00:15:37,490 --> 00:15:43,130
various cases we almost never test the

00:15:40,250 --> 00:15:45,050
JIT by running the full Python and then

00:15:43,130 --> 00:15:46,850
testing the jet like you would do pretty

00:15:45,050 --> 00:15:49,310
much with everything else with just like

00:15:46,850 --> 00:15:52,340
small pieces of our Python programs that

00:15:49,310 --> 00:15:54,350
our interpreters do we translate or like

00:15:52,340 --> 00:15:56,900
interpret or do something and then we

00:15:54,350 --> 00:15:59,200
have a Python interpreter as well

00:15:56,900 --> 00:16:01,190
written as an R Python program and

00:15:59,200 --> 00:16:03,800
assembler backend is a pretty typical

00:16:01,190 --> 00:16:07,070
thing like everybody else does this you

00:16:03,800 --> 00:16:08,990
can that the thing is like we get

00:16:07,070 --> 00:16:11,180
constantly asked why don't you just use

00:16:08,990 --> 00:16:14,870
a VM it solves the Jade issue so the

00:16:11,180 --> 00:16:16,940
LLVM would solve this part it wouldn't

00:16:14,870 --> 00:16:20,690
solve this part and this is really

00:16:16,940 --> 00:16:23,090
crucial LVM said assembler back-end that

00:16:20,690 --> 00:16:25,130
can be reused for various architectures

00:16:23,090 --> 00:16:30,250
yes it's quite a bit of work but it's

00:16:25,130 --> 00:16:35,930
not a jet as as we need it for Python so

00:16:30,250 --> 00:16:38,870
yes well I can show you I well if I try

00:16:35,930 --> 00:16:41,900
to like put on the slide walk up add up

00:16:38,870 --> 00:16:45,110
code actually does in Python it's it

00:16:41,900 --> 00:16:49,190
doesn't fit on one slide what we tried I

00:16:45,110 --> 00:16:54,640
thing at some point so I can show you

00:16:49,190 --> 00:16:54,640
for example can you swap the mic

00:17:01,160 --> 00:17:16,319
does it work yes okay so I can show you

00:17:08,459 --> 00:17:19,490
for example hello I have a simple simple

00:17:16,319 --> 00:17:30,150
program yes I know

00:17:19,490 --> 00:17:33,210
hub yes like this like this how about

00:17:30,150 --> 00:17:36,270
okay so this is a Python program that's

00:17:33,210 --> 00:17:39,900
relatively boring it like takes a fine

00:17:36,270 --> 00:17:42,210
having a function that sums all the all

00:17:39,900 --> 00:17:46,050
the integers from 1 to some large number

00:17:42,210 --> 00:17:47,790
that I typed by chance what it does it

00:17:46,050 --> 00:17:53,910
will run the function but first will

00:17:47,790 --> 00:17:58,490
drop so if I drop the Python bytecode if

00:17:53,910 --> 00:17:58,490
I run it maybe I should

00:18:13,700 --> 00:18:18,070
so rule

00:18:28,280 --> 00:18:36,620
up okay we can see so if you if you run

00:18:31,460 --> 00:18:39,890
the the example it like will display the

00:18:36,620 --> 00:18:42,500
byte code and the byte code is set up

00:18:39,890 --> 00:18:44,420
loop then you load the global X range

00:18:42,500 --> 00:18:46,520
and then you load the constant and then

00:18:44,420 --> 00:18:50,540
you called the function which will pick

00:18:46,520 --> 00:18:54,530
up variable and then a global which is X

00:18:50,540 --> 00:18:57,230
range then we'll have a loop and loop

00:18:54,530 --> 00:19:00,260
starts here at for either it starts a

00:18:57,230 --> 00:19:04,760
variable I close to the labor s loads

00:19:00,260 --> 00:19:09,290
one add stuff in place starts and jumps

00:19:04,760 --> 00:19:11,810
back to here so if we look back this is

00:19:09,290 --> 00:19:13,090
just those two lines and not even full

00:19:11,810 --> 00:19:17,960
because it doesn't contain the

00:19:13,090 --> 00:19:21,290
construction of X range I have like a

00:19:17,960 --> 00:19:25,400
special special thingy that will display

00:19:21,290 --> 00:19:27,620
me what pi PI actually does and then

00:19:25,400 --> 00:19:34,270
this is the display so this is the

00:19:27,620 --> 00:19:34,270
source code up we have the X range and

00:19:35,920 --> 00:19:41,890
those are Python byte codes and those

00:19:39,170 --> 00:19:44,090
are operations that happen but those are

00:19:41,890 --> 00:19:48,710
operations that happen in the assembler

00:19:44,090 --> 00:19:52,820
so I here is some variable I don't know

00:19:48,710 --> 00:19:56,840
quite what but a variable that's all on

00:19:52,820 --> 00:19:58,400
the register usually like if we make

00:19:56,840 --> 00:20:02,690
this slightly smaller we can show the

00:19:58,400 --> 00:20:07,730
assembler so we'll see that for example

00:20:02,690 --> 00:20:09,860
I here would be in our 10 so that's a

00:20:07,730 --> 00:20:13,070
register that's that's sea level

00:20:09,860 --> 00:20:18,280
variable so think about this as a sea

00:20:13,070 --> 00:20:23,420
code except it's written obscure style

00:20:18,280 --> 00:20:28,070
so then you do things and this this

00:20:23,420 --> 00:20:29,690
guard means guard that variable stays

00:20:28,070 --> 00:20:33,920
true this is probably a loop loop

00:20:29,690 --> 00:20:35,810
condition and then that staff and among

00:20:33,920 --> 00:20:40,250
stuff there is not that much assembler

00:20:35,810 --> 00:20:42,140
actually so this will be was that this

00:20:40,250 --> 00:20:44,030
this is the counter that count

00:20:42,140 --> 00:20:46,130
like current and the remaining in

00:20:44,030 --> 00:20:48,440
ex-french if the right now this is the

00:20:46,130 --> 00:20:51,200
addition that checks for overflow so for

00:20:48,440 --> 00:20:53,750
example if we overflow in too long then

00:20:51,200 --> 00:20:56,420
this guard will fail and will resume in

00:20:53,750 --> 00:21:01,100
the interpreter so this is like a single

00:20:56,420 --> 00:21:02,900
piece of assembler code and this is just

00:21:01,100 --> 00:21:04,790
obscure this is checking for control see

00:21:02,900 --> 00:21:06,590
working essentially so if you press

00:21:04,790 --> 00:21:08,590
control C you actually get interrupted

00:21:06,590 --> 00:21:15,620
with like a correct position in the code

00:21:08,590 --> 00:21:20,840
up slides so you you execute bytecode

00:21:15,620 --> 00:21:25,220
and you you do things then you get the

00:21:20,840 --> 00:21:27,350
look that gets hot and after about

00:21:25,220 --> 00:21:28,790
twelve thousand thirty nine rounds and

00:21:27,350 --> 00:21:32,830
or thousand six hundred nineteen

00:21:28,790 --> 00:21:36,410
function calls you start tracing the

00:21:32,830 --> 00:21:40,370
tracing the function or look and

00:21:36,410 --> 00:21:43,640
generate operations as interpreter would

00:21:40,370 --> 00:21:49,640
execute them anyone can guess why 2039

00:21:43,640 --> 00:21:52,340
and not a thousand so a thousand

00:21:49,640 --> 00:21:54,890
thirty-nine it's a prime number that's

00:21:52,340 --> 00:21:57,860
why it's like first prime number above

00:21:54,890 --> 00:22:00,860
thousand I think and that's because

00:21:57,860 --> 00:22:02,630
because well obscure reasons but most

00:22:00,860 --> 00:22:05,360
importantly if we have a tracer we don't

00:22:02,630 --> 00:22:08,330
want to hit obscure cases very often so

00:22:05,360 --> 00:22:10,400
if you want to hit a K if he you want

00:22:08,330 --> 00:22:12,500
traces to be as independent as possible

00:22:10,400 --> 00:22:15,230
and if you use prime numbers that gets

00:22:12,500 --> 00:22:18,020
as independent as you get and then you

00:22:15,230 --> 00:22:21,200
compile the assembler inside x86 as I

00:22:18,020 --> 00:22:23,420
like said Alex eighty six and x86 64 is

00:22:21,200 --> 00:22:25,640
the only supported platform as far as

00:22:23,420 --> 00:22:27,350
the release goes but there's our branch

00:22:25,640 --> 00:22:30,800
and PowerPC branch and they're getting

00:22:27,350 --> 00:22:32,510
in like per PC compiles fiber in almost

00:22:30,800 --> 00:22:34,670
runs or something like this and arm

00:22:32,510 --> 00:22:40,460
pretty much runs pi pi but it's still

00:22:34,670 --> 00:22:43,790
not on trunk so maybe I should show the

00:22:40,460 --> 00:22:47,120
pipe a cake so cake has layers by way

00:22:43,790 --> 00:22:49,430
also has layers lots of them so they

00:22:47,120 --> 00:22:50,540
like first layers your Python code this

00:22:49,430 --> 00:22:52,970
is completely separate to the

00:22:50,540 --> 00:22:55,160
interpreter they have an interpreter and

00:22:52,970 --> 00:22:55,620
you can just run your Python code on the

00:22:55,160 --> 00:22:58,140
interpret

00:22:55,620 --> 00:23:00,290
but but but if their brother is written

00:22:58,140 --> 00:23:02,760
our Python which means that you can

00:23:00,290 --> 00:23:05,210
analyze it analyzing means that you

00:23:02,760 --> 00:23:08,370
create a flow graph of your interpreter

00:23:05,210 --> 00:23:11,280
that gets like high-level low-level flow

00:23:08,370 --> 00:23:14,070
graphs and then thence the tricky point

00:23:11,280 --> 00:23:15,870
you go and make either see your

00:23:14,070 --> 00:23:18,450
presentation of the low-level flow graph

00:23:15,870 --> 00:23:20,730
or a thing that JIT can understand so as

00:23:18,450 --> 00:23:22,380
I said before is like graph

00:23:20,730 --> 00:23:24,720
transformation from the graphs of

00:23:22,380 --> 00:23:26,430
interpreter so the JIT is not written

00:23:24,720 --> 00:23:28,700
for the Python language RG doesn't know

00:23:26,430 --> 00:23:31,590
about Python at all out it only

00:23:28,700 --> 00:23:34,920
understands our Python and not even

00:23:31,590 --> 00:23:36,840
completely and then it's written as a

00:23:34,920 --> 00:23:39,090
graph transformation operation

00:23:36,840 --> 00:23:42,210
essentially so you create code for jet

00:23:39,090 --> 00:23:44,730
or code for the for a C but this means

00:23:42,210 --> 00:23:49,830
that all these stuff is generated from a

00:23:44,730 --> 00:23:51,840
single source file so G is complete by

00:23:49,830 --> 00:23:55,590
design as long as our interpreter is

00:23:51,840 --> 00:23:59,130
correct and now urge it has no bugs jet

00:23:55,590 --> 00:24:02,429
will be correct for the interpreter

00:23:59,130 --> 00:24:04,350
which means is also complete which means

00:24:02,429 --> 00:24:06,420
Java scripts has this problems that like

00:24:04,350 --> 00:24:08,610
they didn't implement some obscure case

00:24:06,420 --> 00:24:10,590
and suddenly your JavaScript ran into a

00:24:08,610 --> 00:24:12,360
place where they done JIT and say oh no

00:24:10,590 --> 00:24:15,450
no no no no we don't support exceptions

00:24:12,360 --> 00:24:16,679
so it's not true for us because our JIT

00:24:15,450 --> 00:24:19,980
is is complete

00:24:16,679 --> 00:24:23,040
if you have hot loops they will always

00:24:19,980 --> 00:24:25,470
get compiled by assembler so you won't

00:24:23,040 --> 00:24:28,640
get only one language description as I

00:24:25,470 --> 00:24:30,960
shown we have pretty decent tools well

00:24:28,640 --> 00:24:32,520
they're debatably decent because

00:24:30,960 --> 00:24:36,290
sometimes you can't guess what's going

00:24:32,520 --> 00:24:36,290
on there the state-of-the-art at least

00:24:36,920 --> 00:24:43,830
that's true so maybe maybe a word of

00:24:40,620 --> 00:24:45,840
warning like cases where we want speed

00:24:43,830 --> 00:24:47,550
up stuff at all by cheating it's cases

00:24:45,840 --> 00:24:50,820
where you spend significant amount of

00:24:47,550 --> 00:24:53,160
time in runtime so those are examples

00:24:50,820 --> 00:24:56,790
were like long edition or set

00:24:53,160 --> 00:24:59,010
intersection where the in C Python the

00:24:56,790 --> 00:25:01,559
entire thing is written in C it's not

00:24:59,010 --> 00:25:03,090
even true first set intersection

00:25:01,559 --> 00:25:07,590
business because you need to compare

00:25:03,090 --> 00:25:09,389
Python objects but for least that sort

00:25:07,590 --> 00:25:12,059
also you have to like call back

00:25:09,389 --> 00:25:15,239
at least long plus-plus long never calls

00:25:12,059 --> 00:25:18,149
any Python code back so the loop written

00:25:15,239 --> 00:25:20,669
C will be hopefully as efficient as

00:25:18,149 --> 00:25:23,219
possible and it's kind of impossible for

00:25:20,669 --> 00:25:24,899
our jib to outperform that so we'll just

00:25:23,219 --> 00:25:27,089
leave this to runtime so those are cases

00:25:24,899 --> 00:25:29,190
where people get constantly confuse ooh

00:25:27,089 --> 00:25:32,309
but my Python code doesn't my private

00:25:29,190 --> 00:25:33,899
code doesn't run faster and surviving

00:25:32,309 --> 00:25:35,820
yes because well you spend most of the

00:25:33,899 --> 00:25:37,829
time in runtime there's not much we can

00:25:35,820 --> 00:25:40,589
do with the JIT at least we can optimize

00:25:37,829 --> 00:25:44,839
in other ways but that we are not in

00:25:40,589 --> 00:25:44,839
anymore licensee pider in this regard so

00:25:45,320 --> 00:25:51,599
well to sum up like JIT never consider

00:25:50,039 --> 00:25:54,839
separation isolation they're always

00:25:51,599 --> 00:25:58,399
coming chunks G always works on like a

00:25:54,839 --> 00:26:01,169
loop or function at one time and

00:25:58,399 --> 00:26:03,269
optimized what we believe is common

00:26:01,169 --> 00:26:05,759
Python that might differ from other

00:26:03,269 --> 00:26:09,719
people's believe but it's important to

00:26:05,759 --> 00:26:14,070
note that what we believe is simple

00:26:09,719 --> 00:26:15,929
Python will be optimized it's often much

00:26:14,070 --> 00:26:18,570
faster than C Python for things that run

00:26:15,929 --> 00:26:20,159
at least one second for example depends

00:26:18,570 --> 00:26:22,919
on the size of your program a bit but

00:26:20,159 --> 00:26:24,389
typically if your program runs point one

00:26:22,919 --> 00:26:25,549
second there is no point in trying to

00:26:24,389 --> 00:26:28,889
even invoke bye-bye

00:26:25,549 --> 00:26:35,669
because it will not get the time budget

00:26:28,889 --> 00:26:37,259
to warm up so hairy sticks we specialize

00:26:35,669 --> 00:26:39,899
on some stuff and not specialize with

00:26:37,259 --> 00:26:43,070
other stuff and the good example of

00:26:39,899 --> 00:26:45,959
heuristic is takes versus objects so we

00:26:43,070 --> 00:26:48,570
assume things have a large set of

00:26:45,959 --> 00:26:51,029
independent keys that can change at any

00:26:48,570 --> 00:26:53,279
time and it's not uncommon for dick to

00:26:51,029 --> 00:26:57,389
have a key that stored and read once for

00:26:53,279 --> 00:26:59,489
example while objects would be you you

00:26:57,389 --> 00:27:01,139
can treat object to subject in Python

00:26:59,489 --> 00:27:03,299
you can just do set out there and get

00:27:01,139 --> 00:27:07,679
out and I've seen people doing that at

00:27:03,299 --> 00:27:11,249
least so object in our opinion will have

00:27:07,679 --> 00:27:13,799
a constant set of a small set of mostly

00:27:11,249 --> 00:27:16,529
consonant keys doesn't mean we enforce

00:27:13,799 --> 00:27:21,109
this but it means it will be faster if

00:27:16,529 --> 00:27:21,109
you do this so an example

00:27:30,650 --> 00:27:33,650
ha

00:27:36,880 --> 00:27:49,670
what's going on so you have an object

00:27:46,760 --> 00:27:52,640
and then a good usage of object would be

00:27:49,670 --> 00:27:55,190
to use objects like axes are two views

00:27:52,640 --> 00:27:58,550
and then all the time are to be

00:27:55,190 --> 00:28:00,200
successes are constant it's important to

00:27:58,550 --> 00:28:07,580
know that pipe it doesn't quite care if

00:28:00,200 --> 00:28:11,150
you write this or you write that well it

00:28:07,580 --> 00:28:12,710
cares if you write backslash here so

00:28:11,150 --> 00:28:14,960
this is the same the same code

00:28:12,710 --> 00:28:17,060
essentially I mean this will probably

00:28:14,960 --> 00:28:19,190
contain a check that you didn't over

00:28:17,060 --> 00:28:21,290
like get out ruin your buildings by

00:28:19,190 --> 00:28:25,640
chance but other than that the code

00:28:21,290 --> 00:28:28,220
stays the same if you however do like

00:28:25,640 --> 00:28:32,330
something like plus I hear then scum

00:28:28,220 --> 00:28:34,220
entirely different started so this is a

00:28:32,330 --> 00:28:37,970
bad usage of an object pipe it doesn't

00:28:34,220 --> 00:28:39,950
like that this is a relatively bet usage

00:28:37,970 --> 00:28:42,800
of a dick not know says that it will be

00:28:39,950 --> 00:28:44,330
slow but in the sense that you can write

00:28:42,800 --> 00:28:48,950
the same thing much faster using an

00:28:44,330 --> 00:28:53,920
object and this is like a typical usage

00:28:48,950 --> 00:28:53,920
of edge of the deck so if you run it I

00:28:55,390 --> 00:28:59,620
don't understand I'll just quite words

00:29:08,010 --> 00:29:27,520
so we go there dad by the way the extra

00:29:21,040 --> 00:29:31,930
dog wrapper is here and you can ID

00:29:27,520 --> 00:29:34,000
what's that it's on bitbucket org slash

00:29:31,930 --> 00:29:36,700
pi PI slash extra dog and you can find

00:29:34,000 --> 00:29:38,950
all the examples and the slides there if

00:29:36,700 --> 00:29:44,020
you want you can just go and poke at it

00:29:38,950 --> 00:29:49,740
anyway i'm i'm now on pi pi in the

00:29:44,020 --> 00:29:49,740
virtual end i will round the zero five

00:29:50,640 --> 00:30:02,110
yes examples you thank you so few are

00:29:59,200 --> 00:30:05,800
few things in the in object container

00:30:02,110 --> 00:30:08,830
take like about 0.3 second and a lot of

00:30:05,800 --> 00:30:11,590
them will take 10 seconds for example so

00:30:08,830 --> 00:30:15,400
well if i run for too long my megameters

00:30:11,590 --> 00:30:17,500
shut down from overheating so the deck

00:30:15,400 --> 00:30:20,590
for example many in the deck is slightly

00:30:17,500 --> 00:30:21,760
faster than many in the object but but

00:30:20,590 --> 00:30:23,890
the thing is the difference between

00:30:21,760 --> 00:30:26,620
using viewing addict and using feeling

00:30:23,890 --> 00:30:28,630
an object so if you have a constant set

00:30:26,620 --> 00:30:31,710
of this is just an example of a holistic

00:30:28,630 --> 00:30:34,420
but if you have a constant small set or

00:30:31,710 --> 00:30:36,340
mostly content set of small constant

00:30:34,420 --> 00:30:38,590
keys you should use an object another

00:30:36,340 --> 00:30:46,150
deck even if you don't know them in

00:30:38,590 --> 00:30:52,270
advance so another another thing is

00:30:46,150 --> 00:30:53,740
specialized list so pipe a will yes yes

00:30:52,270 --> 00:30:59,640
laws are completely pointless and

00:30:53,740 --> 00:30:59,640
bye-bye they don't save anything

00:31:02,660 --> 00:31:17,570
there's a number somewhere no I think

00:31:08,300 --> 00:31:19,280
it's like 25 or something yeah it is if

00:31:17,570 --> 00:31:22,660
you have a constant set of a thousand

00:31:19,280 --> 00:31:22,660
that wouldn't work quite nicely

00:31:22,720 --> 00:31:29,150
like you'll probably see like a sliding

00:31:26,900 --> 00:31:30,950
scale so it won't have a threshold but

00:31:29,150 --> 00:31:34,010
it will get slower and slower so you had

00:31:30,950 --> 00:31:36,710
more from like some number like 20 or 50

00:31:34,010 --> 00:31:38,210
or some and no measure if you have 50

00:31:36,710 --> 00:31:42,230
attributes and they're object you have

00:31:38,210 --> 00:31:43,850
other problems I think so then another

00:31:42,230 --> 00:31:46,430
example is specialized lists so

00:31:43,850 --> 00:31:48,320
specialized lists are if you keep only

00:31:46,430 --> 00:31:51,440
in store floats in the lay state it will

00:31:48,320 --> 00:31:52,520
store them unpacked not with boxes so

00:31:51,440 --> 00:31:56,270
that's very fast

00:31:52,520 --> 00:31:58,520
for example lace dot sort on the list of

00:31:56,270 --> 00:32:00,710
ends doesn't have to call any Python

00:31:58,520 --> 00:32:05,270
functions or look up anything it just

00:32:00,710 --> 00:32:07,520
sort them as fast as C and the range is

00:32:05,270 --> 00:32:12,020
a special kind of list so if you for

00:32:07,520 --> 00:32:13,760
example append and known to int only

00:32:12,020 --> 00:32:15,650
list you'll have to rewrite the entire

00:32:13,760 --> 00:32:18,680
list with like objects and that's quite

00:32:15,650 --> 00:32:20,540
expensive so this is another example of

00:32:18,680 --> 00:32:23,240
a heuristic that's actually very helpful

00:32:20,540 --> 00:32:27,770
in most cases but sometimes it's it's in

00:32:23,240 --> 00:32:30,680
your way so well we I have some examples

00:32:27,770 --> 00:32:33,560
and generally simple is good and

00:32:30,680 --> 00:32:36,320
patterns a very large language so if you

00:32:33,560 --> 00:32:38,810
use a pieces that we never seen before

00:32:36,320 --> 00:32:40,670
chances are they will be slow I have a

00:32:38,810 --> 00:32:48,880
very good example where we just wrote a

00:32:40,670 --> 00:32:48,880
random stuff how does this even work

00:32:50,740 --> 00:32:54,190
maybe like this

00:32:55,320 --> 00:33:09,220
no yes hmm

00:33:05,430 --> 00:33:11,140
so I have a usage of ETL tools uh I

00:33:09,220 --> 00:33:14,230
should there are people who disagree

00:33:11,140 --> 00:33:16,630
with me which is the simplest but I

00:33:14,230 --> 00:33:21,010
claim three is the simplest from the jit

00:33:16,630 --> 00:33:23,380
perspective it's you take two vectors

00:33:21,010 --> 00:33:25,690
and there are like several ways to write

00:33:23,380 --> 00:33:28,240
it down and everybody will come with a

00:33:25,690 --> 00:33:30,610
different solution but the thing is we

00:33:28,240 --> 00:33:33,550
promise you that the third one will be

00:33:30,610 --> 00:33:35,440
among the fastest we don't get is

00:33:33,550 --> 00:33:37,390
complete by design so it'll get all of

00:33:35,440 --> 00:33:39,490
them but every now and then will be some

00:33:37,390 --> 00:33:41,890
obscure detail and like one of those

00:33:39,490 --> 00:33:43,480
will be slow so this is a very important

00:33:41,890 --> 00:33:45,790
thing if you write simple code it will

00:33:43,480 --> 00:33:47,410
run fast if you write complex code it

00:33:45,790 --> 00:33:53,830
might run fast but you actually have to

00:33:47,410 --> 00:33:56,410
measure so this example and the thing is

00:33:53,830 --> 00:33:59,950
we didn't quite know how this example

00:33:56,410 --> 00:34:02,950
will perform and I just like randomly

00:33:59,950 --> 00:34:06,850
you roll few examples and this comes

00:34:02,950 --> 00:34:08,380
with very surprising so like the third

00:34:06,850 --> 00:34:10,270
is not quite the fastest but it's

00:34:08,380 --> 00:34:12,790
definitely among the fastest but it's

00:34:10,270 --> 00:34:16,570
like over ten times faster than other

00:34:12,790 --> 00:34:19,690
ones so it vastly depends on how you

00:34:16,570 --> 00:34:24,120
structure your program and on cpython

00:34:19,690 --> 00:34:24,120
they take like mostly at the same time

00:34:24,600 --> 00:34:32,350
so this is two point seven and they all

00:34:27,550 --> 00:34:34,210
take like about like so you get tons and

00:34:32,350 --> 00:34:35,890
tons of speed ups if you actually write

00:34:34,210 --> 00:34:38,470
the simple stuff and quite a bit of

00:34:35,890 --> 00:34:40,600
speed ups if you if you don't but

00:34:38,470 --> 00:34:43,440
there's definitely a difference how you

00:34:40,600 --> 00:34:43,440
write the code

00:34:51,870 --> 00:34:57,990
well regular zip has to create a list

00:34:54,930 --> 00:35:00,380
which is relatively expensive so the

00:34:57,990 --> 00:35:02,430
thing is like the simple stuff only

00:35:00,380 --> 00:35:05,340
iterates over list and never actually

00:35:02,430 --> 00:35:09,840
allocate anything well only up to the

00:35:05,340 --> 00:35:14,700
Sun so zip will not be fast and izip can

00:35:09,840 --> 00:35:16,380
be made fast but we just didn't and yes

00:35:14,700 --> 00:35:18,030
it probably requires like careful

00:35:16,380 --> 00:35:20,310
looking here and there and thinking what

00:35:18,030 --> 00:35:22,260
can be done but the the simple thing

00:35:20,310 --> 00:35:27,690
doesn't contain a single allocation and

00:35:22,260 --> 00:35:29,910
that that's the point mostly so yes that

00:35:27,690 --> 00:35:32,820
the point can't be stressed too much

00:35:29,910 --> 00:35:35,240
simpler it's good for the JIT so I have

00:35:32,820 --> 00:35:35,240
it twice

00:35:35,970 --> 00:35:43,950
things we could improve but didn't get

00:35:38,670 --> 00:35:45,750
to is frame access abort jet and not

00:35:43,950 --> 00:35:49,290
that we cannot compile it but because

00:35:45,750 --> 00:35:51,540
assembler suddenly gets huge so right

00:35:49,290 --> 00:35:53,340
now frame access just come it works

00:35:51,540 --> 00:35:54,960
completely so you can run PDB and

00:35:53,340 --> 00:36:27,780
everything but completely about the

00:35:54,960 --> 00:36:31,520
jetting yes so well I didn't do that or

00:36:27,780 --> 00:36:31,520
bother us enough that will make it fast

00:36:35,270 --> 00:36:43,020
yes I I think I think it's really ugly

00:36:39,260 --> 00:36:44,550
besides being obscurely slow so there

00:36:43,020 --> 00:36:47,130
are other reasons for not using use but

00:36:44,550 --> 00:36:49,440
yes if you want to support Python from

00:36:47,130 --> 00:36:52,920
the same source from 2.5 to 3 point

00:36:49,440 --> 00:37:00,060
something uses of X info and this is

00:36:52,920 --> 00:37:02,340
making JIT cry so well III want you to

00:37:00,060 --> 00:37:05,239
have a look at the code and like trying

00:37:02,340 --> 00:37:07,650
to run stuff and essentially

00:37:05,239 --> 00:37:09,869
assuming you have pipe I get the jet

00:37:07,650 --> 00:37:12,059
viewer from the unique like Piper and

00:37:09,869 --> 00:37:15,349
five Python checker pipe I check out and

00:37:12,059 --> 00:37:18,419
pipe I installed in the virtual end so I

00:37:15,349 --> 00:37:20,489
use the virtual end tools for that but

00:37:18,419 --> 00:37:23,640
feel free to use virtual anthlon and

00:37:20,489 --> 00:37:26,549
then install get viewer and then try to

00:37:23,640 --> 00:37:31,529
poke first with the examples like the GT

00:37:26,549 --> 00:37:33,269
viewer comes with the log dot pi PI log

00:37:31,529 --> 00:37:34,949
or something and you can poke at the

00:37:33,269 --> 00:37:36,959
examples in there sewers the Phi file

00:37:34,949 --> 00:37:39,269
that shows a few things I will walk

00:37:36,959 --> 00:37:46,439
through them if you can get the jet

00:37:39,269 --> 00:37:48,059
viewer to run but well we want generally

00:37:46,439 --> 00:37:50,219
to give you like a piece of code to

00:37:48,059 --> 00:37:52,729
optimize and then see how it goes like

00:37:50,219 --> 00:37:56,429
the piece of code is on the USB sticks

00:37:52,729 --> 00:37:58,559
under bench directory so we suggest you

00:37:56,429 --> 00:38:00,479
take the speed of code and like try to

00:37:58,559 --> 00:38:02,009
look at it try to look at it in viewer

00:38:00,479 --> 00:38:04,259
around the benchmark we wrote the

00:38:02,009 --> 00:38:10,499
benchmark there and essentially this is

00:38:04,259 --> 00:38:13,140
the exercise is that we took the JSON

00:38:10,499 --> 00:38:14,880
from before we did optimize it and after

00:38:13,140 --> 00:38:18,119
we optimize it and to compare

00:38:14,880 --> 00:38:20,579
performance essentially so this is the

00:38:18,119 --> 00:38:23,279
standard library JSON module and comes

00:38:20,579 --> 00:38:25,349
with a few problems for example the

00:38:23,279 --> 00:38:28,589
standard library JSON module has a C

00:38:25,349 --> 00:38:30,869
speed up and the way it's written the C

00:38:28,589 --> 00:38:33,390
speed up cross cuts are the very weird

00:38:30,869 --> 00:38:38,609
API layer so this actually makes pure

00:38:33,390 --> 00:38:43,609
Python version slower so well how many

00:38:38,609 --> 00:38:45,839
people have did you were running none

00:38:43,609 --> 00:38:47,339
maybe you should first get it you're

00:38:45,839 --> 00:38:52,079
running and then we can like walk

00:38:47,339 --> 00:38:53,789
through for a few examples that yes we

00:38:52,079 --> 00:39:00,359
will help you we have like five people

00:38:53,789 --> 00:39:03,089
to help you with JP hiding there okay so

00:39:00,359 --> 00:39:05,819
you need to setup your Python path to

00:39:03,089 --> 00:39:09,169
point your pipe I check out that's I

00:39:05,819 --> 00:39:09,169
always have also invested

00:39:14,480 --> 00:39:27,869
it's like for bash at least it looks

00:39:19,800 --> 00:39:30,750
like this hope so turn stuff stuff stuff

00:39:27,869 --> 00:39:31,800
stuff stuff you need type I check out in

00:39:30,750 --> 00:39:36,569
your pythonpath

00:39:31,800 --> 00:39:43,589
and then you go to cheat viewer wherever

00:39:36,569 --> 00:39:52,619
you have it Jade and then Iran cheat

00:39:43,589 --> 00:39:55,579
viewer log type I lock up boom I have

00:39:52,619 --> 00:39:55,579
already won running

00:40:11,900 --> 00:40:18,800
yes I well if you didn't em give you

00:40:15,120 --> 00:40:18,800
times you are in the Vigilant

00:40:56,450 --> 00:41:07,620
what so so I would like now to show the

00:41:04,220 --> 00:41:14,340
example of the deed of deed viewer when

00:41:07,620 --> 00:41:17,070
running this particular code I mean in

00:41:14,340 --> 00:41:20,780
the in the order of studying from the

00:41:17,070 --> 00:41:25,160
simplest one this runs this function

00:41:20,780 --> 00:41:25,160
containing this completely trivial code

00:41:41,220 --> 00:41:49,690
the way the way you look at visas is

00:41:45,450 --> 00:41:52,060
when it shows you every loop or every

00:41:49,690 --> 00:41:55,390
single function that was compiled by the

00:41:52,060 --> 00:41:58,270
date and it's sorted in number of times

00:41:55,390 --> 00:42:01,150
that it was run so it means if you have

00:41:58,270 --> 00:42:05,470
a real program unused with did viewer on

00:42:01,150 --> 00:42:09,840
it well the interesting points are or

00:42:05,470 --> 00:42:13,480
the first few of course but but well I

00:42:09,840 --> 00:42:17,920
mean in in this example we will will go

00:42:13,480 --> 00:42:19,900
here to F for the first example of

00:42:17,920 --> 00:42:23,430
course it's very far down

00:42:19,900 --> 00:42:27,960
and it's completely uninteresting but

00:42:23,430 --> 00:42:31,900
but well the point the point here is to

00:42:27,960 --> 00:42:37,260
do to show you how how this function f

00:42:31,900 --> 00:42:37,260
was compiled so you you go

00:42:45,720 --> 00:42:58,480
it is the correct time okay okay so what

00:42:54,609 --> 00:43:02,109
what will shows you is here here you

00:42:58,480 --> 00:43:04,329
have the source code so I mean it

00:43:02,109 --> 00:43:07,180
contains it is only the part of the

00:43:04,329 --> 00:43:10,569
function that was part of the loop that

00:43:07,180 --> 00:43:16,060
was compiled so the while and the I plus

00:43:10,569 --> 00:43:19,800
equal one and then in these boxes you

00:43:16,060 --> 00:43:25,390
have aligned to the left in uppercase

00:43:19,800 --> 00:43:31,119
bytecode so it's really well the

00:43:25,390 --> 00:43:33,609
bytecode in the standard Python way I

00:43:31,119 --> 00:43:36,660
mean it's it is the same byte code that

00:43:33,609 --> 00:43:41,579
you would have in survivin mostly and

00:43:36,660 --> 00:43:44,589
then indented you have the detail of

00:43:41,579 --> 00:43:49,630
operations but the JIT thinks it needs

00:43:44,589 --> 00:43:52,510
to do the same so these these operations

00:43:49,630 --> 00:43:55,540
are mostly assembler instructions the

00:43:52,510 --> 00:43:57,700
assembler levels it is an intermediate

00:43:55,540 --> 00:44:01,329
representation that then gets turned

00:43:57,700 --> 00:44:05,020
into assembler and if you are really

00:44:01,329 --> 00:44:09,579
interested in actual assembler the box

00:44:05,020 --> 00:44:13,510
is out of the you need to default has to

00:44:09,579 --> 00:44:17,369
be smaller it's because I'm not a web

00:44:13,510 --> 00:44:17,369
developer I don't know how to do it

00:44:20,970 --> 00:44:26,579
yes can you yes yes now we have that

00:44:23,880 --> 00:44:31,200
similar yes so so he here you see for

00:44:26,579 --> 00:44:33,780
example that these these two

00:44:31,200 --> 00:44:36,290
instructions actually correspond to

00:44:33,780 --> 00:44:40,560
these two assembler instructions only

00:44:36,290 --> 00:44:42,750
soso so V this is an ID this is of

00:44:40,560 --> 00:44:45,569
course completely boring example but RIS

00:44:42,750 --> 00:44:50,819
example is incredibly fast because

00:44:45,569 --> 00:44:53,670
because one two three four five maybe

00:44:50,819 --> 00:45:00,630
six or seven assembler instructions

00:44:53,670 --> 00:45:05,540
run it for you okay can you hide it

00:45:00,630 --> 00:45:05,540
again maybe yes thank you

00:45:06,680 --> 00:45:13,460
yes a shoe assembler the assembler link

00:45:10,619 --> 00:45:16,650
does not work I feel on OSX sorry

00:45:13,460 --> 00:45:21,569
because you need it use up dump which is

00:45:16,650 --> 00:45:24,750
not installed on normal ethics okay so

00:45:21,569 --> 00:45:28,349
so I mean if you want to to look a bit

00:45:24,750 --> 00:45:30,720
more in the detail here every variable

00:45:28,349 --> 00:45:33,690
starting with I means actually a

00:45:30,720 --> 00:45:36,720
register containing an integer I mean a

00:45:33,690 --> 00:45:41,640
register or or or if they are actually

00:45:36,720 --> 00:45:44,819
more more more variables here than there

00:45:41,640 --> 00:45:46,940
are typically registers on the x86 then

00:45:44,819 --> 00:45:49,109
it's every spilled on the stack and

00:45:46,940 --> 00:45:53,099
always think that well you can rethink

00:45:49,109 --> 00:45:55,170
about visas register so this myth this

00:45:53,099 --> 00:45:58,079
means compare the register with this

00:45:55,170 --> 00:46:01,680
constant you get a result and which

00:45:58,079 --> 00:46:04,500
means this means well God that it's true

00:46:01,680 --> 00:46:07,349
means actually if it's fault jumped

00:46:04,500 --> 00:46:12,109
somewhere else where somewhere else

00:46:07,349 --> 00:46:12,109
contains codes to resume the situation

00:46:12,560 --> 00:46:15,560
here

00:46:15,820 --> 00:46:22,390
well here to do the I plus equal one you

00:46:19,240 --> 00:46:25,510
see well for example these two byte

00:46:22,390 --> 00:46:28,690
codes in the sense of Python do not

00:46:25,510 --> 00:46:34,240
actually generate any low-level code but

00:46:28,690 --> 00:46:43,740
only the in place ad will do the I plus

00:46:34,240 --> 00:46:47,440
1 and this well as this example well you

00:46:43,740 --> 00:46:51,700
know in order to explain to you how we

00:46:47,440 --> 00:46:54,190
go from Python byte code to this super

00:46:51,700 --> 00:46:58,510
optimized assembler they're actually

00:46:54,190 --> 00:47:00,010
levels on the valve own levels but yeah

00:46:58,510 --> 00:47:03,280
it's something like seven instructions

00:47:00,010 --> 00:47:07,120
and see something like five like it's

00:47:03,280 --> 00:47:09,370
not much slower mm-hmm I mean I mean you

00:47:07,120 --> 00:47:11,290
really have to think that this is

00:47:09,370 --> 00:47:14,530
actually doing something that on the

00:47:11,290 --> 00:47:16,960
Python level well on the python level is

00:47:14,530 --> 00:47:20,500
actually manipulating objects not real

00:47:16,960 --> 00:47:22,780
integers that goes into a C or an

00:47:20,500 --> 00:47:24,490
assembler register of course but all

00:47:22,780 --> 00:47:27,070
these object manipulation were

00:47:24,490 --> 00:47:30,310
completely removed here and then here

00:47:27,070 --> 00:47:33,220
you have an addition plus one but maybe

00:47:30,310 --> 00:47:35,070
this can overflow and then if it does

00:47:33,220 --> 00:47:38,560
have a flow then you would need a long

00:47:35,070 --> 00:47:41,260
well everything you usually do in Python

00:47:38,560 --> 00:47:43,930
but no in this case it cannot overflow

00:47:41,260 --> 00:47:46,840
because you add one to a variable that

00:47:43,930 --> 00:47:51,190
you already checked is smaller than 1000

00:47:46,840 --> 00:47:54,700
so it cannot have a flow etc it's really

00:47:51,190 --> 00:48:00,150
a combination of all these factors that

00:47:54,700 --> 00:48:00,150
gives you this completely efficient code

00:48:00,720 --> 00:48:10,830
yes and these three lines are checking

00:48:04,720 --> 00:48:10,830
from for control C on this line well

00:48:12,990 --> 00:48:20,320
this line actually it's a it's an so

00:48:18,400 --> 00:48:24,190
called out of line guard if you already

00:48:20,320 --> 00:48:27,690
so the term used about some average it

00:48:24,190 --> 00:48:30,020
it's it is a guard that compiles to know

00:48:27,690 --> 00:48:35,760
assembler at

00:48:30,020 --> 00:48:39,300
it's a god that can fail but if if some

00:48:35,760 --> 00:48:42,960
other part of of the interpreter would

00:48:39,300 --> 00:48:45,660
suddenly change a value so that so that

00:48:42,960 --> 00:48:47,670
this God would fail then it's a job of

00:48:45,660 --> 00:48:53,490
the other part of the interpreter to go

00:48:47,670 --> 00:48:55,740
and actually patch your assembler so

00:48:53,490 --> 00:49:20,880
that's why it's it's actually no

00:48:55,740 --> 00:49:27,060
assembler code like so yes yes no source

00:49:20,880 --> 00:49:28,560
is Python yes but yes well here you

00:49:27,060 --> 00:49:31,170
really have to think that the source

00:49:28,560 --> 00:49:33,810
code is Python it's a full Python our

00:49:31,170 --> 00:49:40,260
Python is not in the equation like it's

00:49:33,810 --> 00:49:41,970
a detail yes if if if you mana if you if

00:49:40,260 --> 00:49:44,130
you take this and say that it is

00:49:41,970 --> 00:49:47,910
actually our buffin well yes it turned

00:49:44,130 --> 00:49:49,950
out to be our button yes and you compile

00:49:47,910 --> 00:49:53,880
it to see code and then you get the same

00:49:49,950 --> 00:49:56,280
thing but but we know well you don't get

00:49:53,880 --> 00:49:58,410
the same thing because you will not get

00:49:56,280 --> 00:50:00,590
automatically hit control-c detection

00:49:58,410 --> 00:50:05,850
and you will not get the overflow

00:50:00,590 --> 00:50:08,100
detection the overflow well

00:50:05,850 --> 00:50:14,160
also detection which which was actually

00:50:08,100 --> 00:50:19,050
removed in this case but any more

00:50:14,160 --> 00:50:22,440
questions that example yes the point

00:50:19,050 --> 00:50:24,960
that it is the assembler that you get is

00:50:22,440 --> 00:50:27,900
still implementing exactly the same

00:50:24,960 --> 00:50:38,910
semantics as the full ties and semantics

00:50:27,900 --> 00:50:47,150
ok next is the next example it's mostly

00:50:38,910 --> 00:50:47,150
mostly the same but with cold sorry

00:50:49,160 --> 00:50:55,290
ok so mostly the same but here you have

00:50:52,140 --> 00:51:07,670
a code to a function and here it returns

00:50:55,290 --> 00:51:07,670
the I plus 1 so in line calls

00:51:13,890 --> 00:51:21,430
so start with the comparisons the same

00:51:18,490 --> 00:51:27,940
as before then here you have a load

00:51:21,430 --> 00:51:30,190
Global to load what is the name inner so

00:51:27,940 --> 00:51:32,110
this becomes a god not invalidated which

00:51:30,190 --> 00:51:35,260
means no code at all actually

00:51:32,110 --> 00:51:37,270
so it means that that if by any chance

00:51:35,260 --> 00:51:42,120
you have some random code somewhere else

00:51:37,270 --> 00:51:45,070
that changes what is this global then

00:51:42,120 --> 00:51:47,320
then things will still work because at

00:51:45,070 --> 00:51:49,990
the point when the visca values change

00:51:47,320 --> 00:51:57,670
it will touch this assembler to make it

00:51:49,990 --> 00:52:04,420
invalid okay so what we have here I mean

00:51:57,670 --> 00:52:07,150
here it's just just well here you have

00:52:04,420 --> 00:52:09,910
the Col function and the cold function

00:52:07,150 --> 00:52:11,890
is actually in lined in the inter source

00:52:09,910 --> 00:52:15,880
code but that's only for displaying

00:52:11,890 --> 00:52:17,470
purposes here it's it's displayed as a

00:52:15,880 --> 00:52:22,540
link and you have to click on the link

00:52:17,470 --> 00:52:25,930
and here you see sir so the execution is

00:52:22,540 --> 00:52:29,170
going on in the function but you have to

00:52:25,930 --> 00:52:31,840
think about it as well this is in line

00:52:29,170 --> 00:52:36,450
in the color for example manipulating is

00:52:31,840 --> 00:52:41,190
a I 35 which really comes from the color

00:52:36,450 --> 00:52:44,950
also very efficient so yes so so so so

00:52:41,190 --> 00:52:48,030
basically this is well I mean if we

00:52:44,950 --> 00:52:52,740
compare with with what we had before

00:52:48,030 --> 00:52:55,960
there is there is only this instruction

00:52:52,740 --> 00:53:02,380
in addition and this actually turns into

00:52:55,960 --> 00:53:05,170
no assembler - so yes so in this case we

00:53:02,380 --> 00:53:09,730
completely removed any overhead from

00:53:05,170 --> 00:53:19,240
calling the function okay then a

00:53:09,730 --> 00:53:22,040
slightly worse this one

00:53:19,240 --> 00:53:26,810
when this has a bridge and the

00:53:22,040 --> 00:53:29,510
unenlightened call okay so so which has

00:53:26,810 --> 00:53:31,760
this it has two different things in

00:53:29,510 --> 00:53:34,640
addition to the previous example you

00:53:31,760 --> 00:53:36,619
have this which isn't so called an

00:53:34,640 --> 00:53:40,130
inline code because it called this

00:53:36,619 --> 00:53:44,750
function which contains itself a loop so

00:53:40,130 --> 00:53:47,060
so our tracing JIT whose purpose is

00:53:44,750 --> 00:53:50,060
really to follow every instruction as it

00:53:47,060 --> 00:53:52,510
goes here it will stop I mean it will

00:53:50,060 --> 00:53:55,430
actually inline the start of the call

00:53:52,510 --> 00:54:01,609
but then when it reaches the loop it

00:53:55,430 --> 00:54:07,369
will stop so how does it look outer or

00:54:01,609 --> 00:54:14,060
inner out of bridge bridge bridge this

00:54:07,369 --> 00:54:15,980
one yes you can see here that the

00:54:14,060 --> 00:54:18,200
modular instruction in Python is

00:54:15,980 --> 00:54:21,230
actually completely not the module

00:54:18,200 --> 00:54:25,849
instruction and in C it's a different

00:54:21,230 --> 00:54:28,130
operation yes a bit of a mess that we

00:54:25,849 --> 00:54:36,980
could maybe optimize a little bit better

00:54:28,130 --> 00:54:39,980
but but okay doing X modulo Y in Python

00:54:36,980 --> 00:54:44,930
that does not have the same semantics as

00:54:39,980 --> 00:54:48,680
in C with respect to negative numbers so

00:54:44,930 --> 00:54:51,170
we have to correct and this is doing the

00:54:48,680 --> 00:54:54,290
assembly instruction modulo but then we

00:54:51,170 --> 00:55:06,710
have to correct things correct for sign

00:54:54,290 --> 00:55:12,260
issues tailing guard this is which case

00:55:06,710 --> 00:55:16,609
yes it is the case where we take this

00:55:12,260 --> 00:55:20,089
path so it's just represented

00:55:16,609 --> 00:55:24,770
represented as a guard god that is the

00:55:20,089 --> 00:55:27,700
result of the modulo is is not true so

00:55:24,770 --> 00:55:27,700
it means is zero

00:55:29,070 --> 00:55:35,410
okay so so I mean what in one case we

00:55:32,560 --> 00:55:38,650
just do that lose that here you have an

00:55:35,410 --> 00:55:42,310
example of plus one that is actually in

00:55:38,650 --> 00:55:46,620
integer addition overflow which means it

00:55:42,310 --> 00:55:49,120
becomes in the instruction addition of

00:55:46,620 --> 00:55:54,960
registers but then it's followed by a

00:55:49,120 --> 00:56:01,030
god that it did not overflow okay but

00:55:54,960 --> 00:56:03,130
and then well well believe it is of

00:56:01,030 --> 00:56:05,260
course the first example that that we

00:56:03,130 --> 00:56:08,410
are showing in which the control flow

00:56:05,260 --> 00:56:12,760
actually changes during exact during

00:56:08,410 --> 00:56:17,500
segregation of the loops so in this case

00:56:12,760 --> 00:56:21,070
it shows it it this God fails often

00:56:17,500 --> 00:56:22,930
enough in the sense that that well you

00:56:21,070 --> 00:56:24,720
run with ten thousand time and that five

00:56:22,930 --> 00:56:27,730
thousand times the God is going to fail

00:56:24,720 --> 00:56:30,750
so when the guard starts to fail too

00:56:27,730 --> 00:56:35,650
often what we do is compile a bridge and

00:56:30,750 --> 00:56:38,980
a bridge is a name for the to term that

00:56:35,650 --> 00:56:43,840
well you have this as a loop and the

00:56:38,980 --> 00:56:47,410
bridge is well what what you would what

00:56:43,840 --> 00:56:50,080
you where you would like to jump to its

00:56:47,410 --> 00:56:53,650
another possible another potential tail

00:56:50,080 --> 00:56:56,770
of the same loop yes I claim zero

00:56:53,650 --> 00:56:59,530
percent is not every second go but

00:56:56,770 --> 00:57:07,840
probably it's like integer division or

00:56:59,530 --> 00:57:13,090
something no it's worse yes why I guess

00:57:07,840 --> 00:57:16,330
I know okay yes

00:57:13,090 --> 00:57:19,240
in this example now it's worth well well

00:57:16,330 --> 00:57:21,460
what we're doing is calling well the

00:57:19,240 --> 00:57:23,320
load global on the call like like before

00:57:21,460 --> 00:57:29,350
but it's got really contains its extra

00:57:23,320 --> 00:57:32,950
guards here where it's actually called

00:57:29,350 --> 00:57:40,800
yes here yes it's inline call to an

00:57:32,950 --> 00:57:40,800
inline call okay can you just follow up

00:57:42,600 --> 00:57:49,330
this is the first iteration and then

00:57:47,260 --> 00:57:52,210
frame a location and then call something

00:57:49,330 --> 00:57:52,750
yes yes it's a good example where is not

00:57:52,210 --> 00:57:57,220
great

00:57:52,750 --> 00:57:58,780
and we are trying to improve it so what

00:57:57,220 --> 00:58:00,460
is occurring here is of the first

00:57:58,780 --> 00:58:03,820
iteration through the loop is actually

00:58:00,460 --> 00:58:06,520
in lined but then then further

00:58:03,820 --> 00:58:09,910
iterations are not so the first

00:58:06,520 --> 00:58:12,070
iteration becomes this where you have

00:58:09,910 --> 00:58:16,720
the addition of one yes

00:58:12,070 --> 00:58:19,240
for example as political one well s you

00:58:16,720 --> 00:58:23,830
know it's zero anyway so it's all

00:58:19,240 --> 00:58:33,730
constant folded okay and here you have

00:58:23,830 --> 00:58:36,910
the call I mean when we the point is

00:58:33,730 --> 00:58:38,320
that control flow here is really

00:58:36,910 --> 00:58:41,560
completely different than the control

00:58:38,320 --> 00:58:46,420
flow of your source program meaning

00:58:41,560 --> 00:58:48,040
every call that really we every code

00:58:46,420 --> 00:58:53,890
that occurred in your source program is

00:58:48,040 --> 00:58:56,920
in lined always but if a call goes to a

00:58:53,890 --> 00:59:00,700
function with loop then what will occur

00:58:56,920 --> 00:59:05,080
is that as the level of assembler it

00:59:00,700 --> 00:59:08,020
will turn into a call a call to a

00:59:05,080 --> 00:59:13,990
function at the level of assembler that

00:59:08,020 --> 00:59:16,590
implements only the loop so Google

00:59:13,990 --> 00:59:16,590
confused

00:59:25,920 --> 00:59:38,130
yes yes yes explain maybe why when

00:59:31,170 --> 00:59:42,130
reading no it's it's kind of interesting

00:59:38,130 --> 00:59:45,250
if you call another function on the

00:59:42,130 --> 00:59:47,650
assembler you suddenly no longer in line

00:59:45,250 --> 00:59:50,860
your color which means you have to

00:59:47,650 --> 00:59:52,810
allocate the Python frame we we are

00:59:50,860 --> 00:59:55,690
working on removing that but we didn't

00:59:52,810 --> 00:59:58,360
quite yet so allocating Python frame

00:59:55,690 --> 00:59:59,770
means that you have to pass stuff in a

00:59:58,360 --> 01:00:02,620
shape that would come from the

00:59:59,770 --> 01:00:05,860
interpreter which in this case means for

01:00:02,620 --> 01:00:07,930
example we allocate probably this is

01:00:05,860 --> 01:00:09,280
frame allocation then we allocate a

01:00:07,930 --> 01:00:11,350
place for locals

01:00:09,280 --> 01:00:13,930
then he all kind like to locals and

01:00:11,350 --> 01:00:15,790
something and then at least object

01:00:13,930 --> 01:00:18,190
that's probably another local and then

01:00:15,790 --> 01:00:20,590
we have to like carefully staff stuff

01:00:18,190 --> 01:00:24,280
bird like you can see here we start a

01:00:20,590 --> 01:00:27,480
back Raph to like our frame so this

01:00:24,280 --> 01:00:31,030
would require another level of

01:00:27,480 --> 01:00:33,280
optimizing the frame allocation and then

01:00:31,030 --> 01:00:36,250
we start for example like all the stuff

01:00:33,280 --> 01:00:37,960
that the Python would do normally on the

01:00:36,250 --> 01:00:41,020
frame so you initialize the frame

01:00:37,960 --> 01:00:42,850
essentially and yes this this look

01:00:41,020 --> 01:00:45,190
obscurely inefficient but i remember

01:00:42,850 --> 01:00:46,870
that this is still much much faster than

01:00:45,190 --> 01:00:48,400
if you'd run it in the interpreter

01:00:46,870 --> 01:00:50,110
because this would happen at every call

01:00:48,400 --> 01:00:55,030
and we only do it like every few goes

01:00:50,110 --> 01:01:02,200
and this is also it's still optimized

01:00:55,030 --> 01:01:06,060
inside so if we follow this hope yes so

01:01:02,200 --> 01:01:11,250
now we are looking at the code of loop

01:01:06,060 --> 01:01:11,250
that was in the non inline function

01:01:13,750 --> 01:01:19,220
no no no the call is really a call at

01:01:17,510 --> 01:01:21,680
some level that really goes there

01:01:19,220 --> 01:01:24,020
directly so the funny thing is now we

01:01:21,680 --> 01:01:25,820
unpack the frame that we just created

01:01:24,020 --> 01:01:37,970
into local variables so it's clearly

01:01:25,820 --> 01:01:40,400
optimizable yes this just does that can

01:01:37,970 --> 01:01:49,520
you yes yes okay so this do we have

01:01:40,400 --> 01:01:52,700
another unrolled iteration and hub here

01:01:49,520 --> 01:01:57,500
you finally have the efficient version

01:01:52,700 --> 01:01:59,960
of this for loop I mean here it's a bit

01:01:57,500 --> 01:02:03,170
more instruction that than what we have

01:01:59,960 --> 01:02:06,740
had seen previously because it's for in

01:02:03,170 --> 01:02:09,380
the interactions are range objects now

01:02:06,740 --> 01:02:11,660
so so for example here we still have a

01:02:09,380 --> 01:02:13,880
multiplication with one of these that's

01:02:11,660 --> 01:02:17,390
probably always a constant one because

01:02:13,880 --> 01:02:24,760
that's a step in the rent we didn't

01:02:17,390 --> 01:02:28,490
quite figure that out yet but yes I mean

01:02:24,760 --> 01:02:31,790
yes yes from one point of view just just

01:02:28,490 --> 01:02:34,640
doing this kind of of demo just shows

01:02:31,790 --> 01:02:37,190
some completely of views in efficiencies

01:02:34,640 --> 01:02:39,410
but then you also have to take the other

01:02:37,190 --> 01:02:42,830
point of view which is that this is

01:02:39,410 --> 01:02:45,470
really assembly instruction so so yes

01:02:42,830 --> 01:02:48,050
yes we can we can remove one assembly

01:02:45,470 --> 01:02:50,390
instruction but but the total of 10 is

01:02:48,050 --> 01:02:55,000
separate instruction is is already

01:02:50,390 --> 01:02:55,000
incredibly much faster than citizens

01:02:55,510 --> 01:03:03,200
well the breach in loop exit bridge

01:02:59,660 --> 01:03:04,940
mm-hmm yes so so this is the god that

01:03:03,200 --> 01:03:10,180
will fail why when the range is

01:03:04,940 --> 01:03:12,680
exhausted and what are we doing here

01:03:10,180 --> 01:03:14,990
stirring stuff back on the on the frame

01:03:12,680 --> 01:03:18,020
yes we are yes we are storing again

01:03:14,990 --> 01:03:20,540
everything on the frame on the frame

01:03:18,020 --> 01:03:22,580
that we're about to leave so that just

01:03:20,540 --> 01:03:26,240
be just because just in case someone

01:03:22,580 --> 01:03:27,350
actually got a reference to the frame at

01:03:26,240 --> 01:03:30,020
the Python

01:03:27,350 --> 01:03:34,360
stored it somewhere and much later would

01:03:30,020 --> 01:03:39,770
ask what was the value of this locals

01:03:34,360 --> 01:03:43,010
well it's supported I guess this exhaust

01:03:39,770 --> 01:03:50,320
the example really let me go back to the

01:03:43,010 --> 01:03:52,660
color yes son yes so so all these well

01:03:50,320 --> 01:03:55,100
everything that we have shown is really

01:03:52,660 --> 01:04:00,200
assembler that calls other assembler

01:03:55,100 --> 01:04:05,630
there is no no no when no path where we

01:04:00,200 --> 01:04:08,000
give up on callback the interpreter and

01:04:05,630 --> 01:04:09,980
as you can see there's still place to

01:04:08,000 --> 01:04:11,810
optimize like we're by far enough done

01:04:09,980 --> 01:04:13,970
it's like you look at those traces like

01:04:11,810 --> 01:04:17,410
oh my god this is obviously optimizable

01:04:13,970 --> 01:04:17,410
like we should do something about that

01:04:25,360 --> 01:04:35,420
you sometimes do you have to well yes

01:04:33,830 --> 01:04:39,170
you sometimes do also in the sense that

01:04:35,420 --> 01:04:42,110
maybe this isn't not also called to a

01:04:39,170 --> 01:04:44,150
function but to a method of an object

01:04:42,110 --> 01:04:47,330
and then it depends on what the type of

01:04:44,150 --> 01:04:49,610
the object is but that but form um I

01:04:47,330 --> 01:04:51,080
mean most of the case the method you're

01:04:49,610 --> 01:04:53,990
calling is a one-liner

01:04:51,080 --> 01:04:58,610
so actually in lining it is an excellent

01:04:53,990 --> 01:05:00,440
idea yes I mean factly has very strange

01:04:58,610 --> 01:05:05,270
performance profile like in this

01:05:00,440 --> 01:05:06,980
particular case you you'd see that there

01:05:05,270 --> 01:05:08,540
are pieces that are about hundred times

01:05:06,980 --> 01:05:10,070
faster than the interpreter and the

01:05:08,540 --> 01:05:12,950
pieces that are only like five times

01:05:10,070 --> 01:05:15,080
faster it's still much faster here but

01:05:12,950 --> 01:05:17,120
the performance varies quite a lot

01:05:15,080 --> 01:05:18,830
depending on what you do and yes we are

01:05:17,120 --> 01:05:26,180
trying to idle it but doesn't always

01:05:18,830 --> 01:05:28,040
work as of now so well what do we

01:05:26,180 --> 01:05:32,390
explain the obscure enlightening of

01:05:28,040 --> 01:05:34,970
regular expression well yes I mean maybe

01:05:32,390 --> 01:05:37,900
I would just explain it by waving my

01:05:34,970 --> 01:05:41,470
hand here it's at

01:05:37,900 --> 01:05:44,410
here you actually have a call to a trick

01:05:41,470 --> 01:05:47,349
go to the regulated module and the

01:05:44,410 --> 01:05:49,869
regular expression is itself some kind

01:05:47,349 --> 01:05:54,160
of bad code interpreter it interprets

01:05:49,869 --> 01:05:56,589
the byte code made out of the regular

01:05:54,160 --> 01:06:00,369
expression so if it's a bytecode

01:05:56,589 --> 01:06:04,150
interpreter we can apply the JIT so we

01:06:00,369 --> 01:06:16,960
did and so this regular expression call

01:06:04,150 --> 01:06:22,869
is turned into well assembler is in line

01:06:16,960 --> 01:06:26,740
string stuff all of those yes yes so so

01:06:22,869 --> 01:06:28,569
this this is actually how how a regular

01:06:26,740 --> 01:06:30,880
expression byte code is compiled as

01:06:28,569 --> 01:06:33,190
opposed to a pipe in byte code which yes

01:06:30,880 --> 01:06:36,760
I mean it looks very similar it's just

01:06:33,190 --> 01:06:39,789
the same mechanisms at videos here you

01:06:36,760 --> 01:06:44,920
have getting out of this string this

01:06:39,789 --> 01:06:53,589
character checking that it is 51 what is

01:06:44,920 --> 01:06:56,859
51 53 maybe then there is a god and if

01:06:53,589 --> 01:06:59,740
not you increments a variable that is

01:06:56,859 --> 01:07:01,720
index and probably yes just finish which

01:06:59,740 --> 01:07:09,549
just meanwhile look at the next

01:07:01,720 --> 01:07:16,140
character simply that's a bridge while

01:07:09,549 --> 01:07:16,140
doing stuff and finishing as well yes

01:07:16,170 --> 01:07:22,240
yes the point is that again this regular

01:07:19,750 --> 01:07:24,010
expression is compiled into these fewest

01:07:22,240 --> 01:07:26,020
number instructions now the interesting

01:07:24,010 --> 01:07:28,510
part is usually not to like try to

01:07:26,020 --> 01:07:34,029
understand exact assembler instruction

01:07:28,510 --> 01:07:36,190
but did I guess the overall density how

01:07:34,029 --> 01:07:38,349
much how much a similar and how much

01:07:36,190 --> 01:07:41,980
allocations I actually need to execute

01:07:38,349 --> 01:07:43,569
that so like in these cases are like 2/3

01:07:41,980 --> 01:07:45,279
assembler instructions here and there

01:07:43,569 --> 01:07:46,280
are not really that interesting like a

01:07:45,279 --> 01:07:48,170
removing one with

01:07:46,280 --> 01:07:49,790
give you much but every now and then you

01:07:48,170 --> 01:07:51,410
will find yourself like this is

01:07:49,790 --> 01:07:53,150
allocates frame and like populates to

01:07:51,410 --> 01:07:54,680
have stuff and that's like hundreds of

01:07:53,150 --> 01:07:56,690
our similar instructions including your

01:07:54,680 --> 01:08:00,200
stuff in the GC and that's that's much

01:07:56,690 --> 01:08:05,750
more interesting this is the color I

01:08:00,200 --> 01:08:11,350
know this is the list comprehension of

01:08:05,750 --> 01:08:14,120
course so this is maybe interesting yes

01:08:11,350 --> 01:08:17,260
it's a call it's a call to the function

01:08:14,120 --> 01:08:20,780
that converts the into a string a

01:08:17,260 --> 01:08:23,000
similar level and yes I mean it's a call

01:08:20,780 --> 01:08:25,069
I hear here at the family level it's

01:08:23,000 --> 01:08:29,780
going to be a call to a function that

01:08:25,069 --> 01:08:30,920
was compiled in C and this is the thing

01:08:29,780 --> 01:08:42,799
that the resize is the list

01:08:30,920 --> 01:08:47,990
yes potentially yes this is inline

01:08:42,799 --> 01:08:50,359
string so for each element and yes we

01:08:47,990 --> 01:09:03,920
inline the call to stuff in the regular

01:08:50,359 --> 01:09:12,910
expression I mean here we are in the

01:09:03,920 --> 01:09:12,910
module are e dot PI like harsh at Apple

01:09:20,170 --> 01:09:31,069
know all things about dictionaries are

01:09:23,870 --> 01:09:33,319
really cold it's almost almost so yes

01:09:31,069 --> 01:09:34,760
this is the D clock up for example this

01:09:33,319 --> 01:09:36,920
is the actual dictionary some of the

01:09:34,760 --> 01:09:39,319
object an object would not have this an

01:09:36,920 --> 01:09:41,740
object would have the deep look up at

01:09:39,319 --> 01:09:45,230
the moment you compile the assembler and

01:09:41,740 --> 01:09:49,270
this this has dick lookup dynamically

01:09:45,230 --> 01:09:49,270
because you you don't potentially know

01:09:50,140 --> 01:09:54,740
yes dick lookups in Python can execute

01:09:53,000 --> 01:09:57,170
arbitrary Python including one that

01:09:54,740 --> 01:10:00,700
modifies your dictionary by calling

01:09:57,170 --> 01:10:00,700
comparison of a strange object

01:10:10,900 --> 01:10:31,190
it's an odd function so what no like a

01:10:28,430 --> 01:10:35,900
dictionary usually dictionaries who's

01:10:31,190 --> 01:10:38,120
who don't have a key value yes sorry so

01:10:35,900 --> 01:10:39,800
yes this is interesting so you compile

01:10:38,120 --> 01:10:44,330
the regular expression here and that

01:10:39,800 --> 01:10:46,250
took a beat and then you you comet out

01:10:44,330 --> 01:10:48,860
search on it which does quite a bit

01:10:46,250 --> 01:10:52,210
stuff it prepares the pattern somehow

01:10:48,860 --> 01:10:54,470
and like read some items this this is

01:10:52,210 --> 01:10:57,200
reading some code not sure was that

01:10:54,470 --> 01:10:59,360
that's probably the startup code yes and

01:10:57,200 --> 01:11:03,110
then you in line the call here which is

01:10:59,360 --> 01:11:04,880
then again the call in the assembler in

01:11:03,110 --> 01:11:06,530
in the assembler that goes to the

01:11:04,880 --> 01:11:08,300
regular expression engine so you just

01:11:06,530 --> 01:11:10,760
have one GT calling another JIT and

01:11:08,300 --> 01:11:16,370
completely in line you don't have going

01:11:10,760 --> 01:11:20,120
through the interpreter at all and then

01:11:16,370 --> 01:11:22,870
calls more stuff and we are back to the

01:11:20,120 --> 01:11:22,870
place where we've been

01:11:24,679 --> 01:11:31,909
I think the only other unusual pattern

01:11:29,030 --> 01:11:35,179
that that's really obscure is that

01:11:31,909 --> 01:11:38,659
tableau stuff so this is another example

01:11:35,179 --> 01:11:40,429
where the assembler representation is

01:11:38,659 --> 01:11:41,409
completely detached from what you write

01:11:40,429 --> 01:11:46,670
in Python

01:11:41,409 --> 01:11:50,750
yes well what occurs what up should I

01:11:46,670 --> 01:11:53,630
just show it yes okay so what I got is

01:11:50,750 --> 01:11:55,429
you see here the inner loop first just

01:11:53,630 --> 01:11:59,120
because it's the one that is run most

01:11:55,429 --> 01:12:01,850
often so it first compiled the inner

01:11:59,120 --> 01:12:07,699
loop and when this switch looks like

01:12:01,850 --> 01:12:10,880
what we have seen so far okay but then

01:12:07,699 --> 01:12:13,790
so then what would occur when we say

01:12:10,880 --> 01:12:19,130
iterator is exhausted it would go there

01:12:13,790 --> 01:12:22,190
follow with bridge and if we look this

01:12:19,130 --> 01:12:25,340
bridge well has popped block which means

01:12:22,190 --> 01:12:32,179
which is which means end of the for loop

01:12:25,340 --> 01:12:34,330
does a bit of thing jump ups jump

01:12:32,179 --> 01:12:37,190
absolute which means jump to the start

01:12:34,330 --> 01:12:42,770
so so really here it's doing the outer

01:12:37,190 --> 01:12:45,830
loop the for eater which we which is

01:12:42,770 --> 01:12:48,080
fish the next item out of the ranch and

01:12:45,830 --> 01:12:52,070
we see here as usual our multiplication

01:12:48,080 --> 01:13:01,400
by one yes then we create another range

01:12:52,070 --> 01:13:03,710
yes true the inner edge well it was some

01:13:01,400 --> 01:13:05,989
number of instruction but but you still

01:13:03,710 --> 01:13:10,640
have to think that everyone becomes one

01:13:05,989 --> 01:13:14,480
or two assembler instruction only you

01:13:10,640 --> 01:13:16,489
put stuff back on the on the frame in

01:13:14,480 --> 01:13:19,489
jump back that the crucial part is that

01:13:16,489 --> 01:13:22,460
you have inner loop which is small an

01:13:19,489 --> 01:13:24,620
outer loop which is in line as a bridge

01:13:22,460 --> 01:13:26,480
to inner loop so you have like reversed

01:13:24,620 --> 01:13:29,989
flow because this way this is the way

01:13:26,480 --> 01:13:34,690
stuff gets hot in in the running of your

01:13:29,989 --> 01:13:38,020
program so

01:13:34,690 --> 01:13:41,080
I guess firstly even yes I mean here if

01:13:38,020 --> 01:13:43,780
we have shown a bit small small well

01:13:41,080 --> 01:13:46,390
completely trivially small examples but

01:13:43,780 --> 01:13:48,790
the point is that this tool jitter is

01:13:46,390 --> 01:13:52,060
actually useful if you try done large

01:13:48,790 --> 01:13:53,710
example too because because well what

01:13:52,060 --> 01:13:56,500
you will see what you will see is the

01:13:53,710 --> 01:14:00,220
first few entries that are the most

01:13:56,500 --> 01:14:01,780
executed are the one well that's why

01:14:00,220 --> 01:14:04,000
it's interesting to go and then it's

01:14:01,780 --> 01:14:05,980
interesting to find this kind of code

01:14:04,000 --> 01:14:08,440
which means turns and turns of

01:14:05,980 --> 01:14:12,010
instructions that but corresponds to no

01:14:08,440 --> 01:14:15,060
or or to just a few Python byte code so

01:14:12,010 --> 01:14:19,960
so in this way you can find out where

01:14:15,060 --> 01:14:25,060
well where is optimization was not so

01:14:19,960 --> 01:14:27,490
successful basically yes you can either

01:14:25,060 --> 01:14:31,870
do it yourself or get back to us like

01:14:27,490 --> 01:14:35,410
that is essentially I think the plan for

01:14:31,870 --> 01:14:37,180
now is like e you guys are feel free I

01:14:35,410 --> 01:14:40,990
don't know it's been another hour or so

01:14:37,180 --> 01:14:42,760
what time is supposed to end yes so our

01:14:40,990 --> 01:14:44,230
in something and we can have a little

01:14:42,760 --> 01:14:45,700
break and then you guys that there's a

01:14:44,230 --> 01:14:47,230
benchmark on the USB stick the Jason

01:14:45,700 --> 01:14:48,820
benchmark you guys are free to run that

01:14:47,230 --> 01:14:50,380
or any other of your stuff and we'll go

01:14:48,820 --> 01:14:53,800
and help you and explain what's going on

01:14:50,380 --> 01:14:55,390
so the original idea I think was to take

01:14:53,800 --> 01:14:56,710
the Jason benchmark try to optimize it

01:14:55,390 --> 01:14:57,970
I'm not sure we have enough time but at

01:14:56,710 --> 01:15:00,310
least we can look at the cheap prices

01:14:57,970 --> 01:15:02,140
and see what's going on and where this

01:15:00,310 --> 01:15:04,420
stuff where this stuff is going so the

01:15:02,140 --> 01:15:07,630
Jason is the actual Jason from standard

01:15:04,420 --> 01:15:10,090
library Python 2.7 unmodified which

01:15:07,630 --> 01:15:12,310
means also with tons of stuff that not

01:15:10,090 --> 01:15:15,870
completely necessary and five I like if

01:15:12,310 --> 01:15:18,970
something has C speed up which we don't

01:15:15,870 --> 01:15:21,640
so it's may be interesting to look how

01:15:18,970 --> 01:15:23,860
real code looks in junior but also feel

01:15:21,640 --> 01:15:26,680
free to run down any of your code and

01:15:23,860 --> 01:15:30,970
like ask us for questions I guess that's

01:15:26,680 --> 01:15:33,520
the man essentially uh you run pi PI

01:15:30,970 --> 01:15:35,080
point eight your source program and then

01:15:33,520 --> 01:15:35,740
you add this extra environmental

01:15:35,080 --> 01:15:40,330
variable

01:15:35,740 --> 01:15:44,050
pi PI log equals JIT - log - opt comma

01:15:40,330 --> 01:15:47,980
JIT - back-end : log pi PI log and

01:15:44,050 --> 01:15:49,900
basically what sorry yes

01:15:47,980 --> 01:15:52,450
you a saying is we would like the log to

01:15:49,900 --> 01:15:54,510
contain the optimized logs of all the

01:15:52,450 --> 01:15:57,520
instructions we've been looking at

01:15:54,510 --> 01:16:00,940
back-end which contains the number of

01:15:57,520 --> 01:16:03,670
times each loop was executed and then it

01:16:00,940 --> 01:16:05,440
dumps it to a the log dot pi PI log file

01:16:03,670 --> 01:16:07,150
and so that's the name of the file you

01:16:05,440 --> 01:16:12,970
load on point chip you are at to display

01:16:07,150 --> 01:16:14,860
it yes so we'll leave this up yes and

01:16:12,970 --> 01:16:20,700
the tip you read me has that things well

01:16:14,860 --> 01:16:20,700
so sorry

01:16:22,020 --> 01:16:27,330
okay so we are now here to answer any

01:16:24,370 --> 01:16:27,330

YouTube URL: https://www.youtube.com/watch?v=oZw8m_lyhvo


