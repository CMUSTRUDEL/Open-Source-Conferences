Title: Cory Benfield - Building Protocol Libraries The Right Way - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Cory Benfield

One of the great strengths of the Python ecosystem is the enormous collection of powerful, flexible libraries. However, these libraries tend to suffer from one extremely common design flaw that mean that the work done is not easily re-usable or transferable. In this talk, we talk about how to build libraries that can be used as widely as possible, through the lens of the Python Hyper HTTP project.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:01,010 --> 00:00:05,010
And Cory Benfield is going to be talking about

00:00:05,010 --> 00:00:07,149
building protocol libraries the right way.

00:00:07,149 --> 00:00:10,830
So let's give a big hand for Cory.

00:00:10,830 --> 00:00:15,580
[applause]

00:00:15,580 --> 00:00:18,460
All right, thank you all for showing up

00:00:18,460 --> 00:00:21,220
for the most boringly named talk of the conference

00:00:21,220 --> 00:00:23,700
and getting over the fact that it's the last talk of the day.

00:00:24,320 --> 00:00:26,580
Hello, my name is Cory, but --

00:00:26,580 --> 00:00:28,540
that was just too tragic.

00:00:28,540 --> 00:00:30,660
[laughter]

00:00:30,660 --> 00:00:33,320
Hello, my name is Cory, I'm a software developer,

00:00:33,329 --> 00:00:35,169
I'm based in London.

00:00:35,169 --> 00:00:37,479
If you would like to give running commentary of this talk

00:00:37,479 --> 00:00:39,850
or tweet abuse, I'm available at various places.

00:00:39,850 --> 00:00:41,600
You can go find things.

00:00:41,600 --> 00:00:44,480
I live on the interwebs most of the time.

00:00:45,640 --> 00:00:48,560
I work at Hewlett Packard Enterprise.

00:00:48,569 --> 00:00:53,129
I work in Hewlett Packard Enterprise's kind of open source focused upstream team.

00:00:53,129 --> 00:00:55,700
And for my part that means

00:00:55,710 --> 00:01:00,250
that overwhelmingly I work on open source Python HTTP.

00:01:00,760 --> 00:01:03,519
This covers a really quite broad range of responsibilities

00:01:03,519 --> 00:01:08,470
but the ones I spend the most time on are some of the things on the board,

00:01:08,470 --> 00:01:12,610
the ones you're likely to know, Requests is obviously pretty famous.

00:01:12,610 --> 00:01:14,820
That's the one I spend a large chunk of time on,

00:01:14,820 --> 00:01:17,500
but I also spend a lot of time on urllib3

00:01:17,500 --> 00:01:20,200
which is the project underlying Requests.

00:01:20,200 --> 00:01:24,720
It's probably the most important Python project that none of you have heard of.

00:01:24,720 --> 00:01:26,840
On top of that, I work on the Python hyper project

00:01:26,850 --> 00:01:29,380
which is actually a collection of projects

00:01:29,380 --> 00:01:33,860
that are useful for HTTP and HTTP/2.

00:01:33,860 --> 00:01:36,520
They've got a whole lot of collection of fairly boring names.

00:01:36,530 --> 00:01:39,410
We're going to touch on a couple of them a little bit later.

00:01:40,080 --> 00:01:42,040
Then on top of all that,

00:01:42,050 --> 00:01:47,030
for my sins I am also a contributor to pyopenssl,

00:01:47,030 --> 00:01:50,270
which is a library that I think most of the contributors to

00:01:50,270 --> 00:01:52,550
would be quite happy to see the back of.

00:01:53,700 --> 00:01:56,720
So this talk's got a terrible name and that's because it used to have

00:01:56,720 --> 00:01:59,760
a great name that I decided was altogether too confrontational.

00:01:59,760 --> 00:02:01,980
So its original name was going to be:

00:02:01,980 --> 00:02:07,780
[laughter]

00:02:07,780 --> 00:02:11,920
But you can't, you can't put that on a program, right?

00:02:11,930 --> 00:02:14,190
You get angry tweets if you put that on a program.

00:02:14,190 --> 00:02:16,430
People think you're being snotty.

00:02:16,430 --> 00:02:18,980
But while this title's super inflammatory,

00:02:18,980 --> 00:02:21,240
it does highlight something I wanted to focus on,

00:02:21,240 --> 00:02:25,469
which is, in this talk I'm going to cover a design anti-pattern

00:02:25,469 --> 00:02:30,549
that the entire community engages in every time we build protocol libraries.

00:02:30,549 --> 00:02:33,209
And it's really easy when giving that kind of talk

00:02:33,209 --> 00:02:36,320
to feel like the speaker is all holier-than-thou

00:02:36,320 --> 00:02:38,860
and "Aren't I wonderful and smart?"

00:02:38,860 --> 00:02:40,980
And that's not what I'm saying. I'm terrible.

00:02:40,980 --> 00:02:42,980
I am stupider than most of you.

00:02:42,980 --> 00:02:47,460
I do this wrong all the time and I only got it right by chance once.

00:02:47,460 --> 00:02:50,680
So my success rate is not good.

00:02:52,140 --> 00:02:54,340
So, context.

00:02:54,980 --> 00:02:59,129
Python HTTP is great. I think we can all agree as a community

00:02:59,129 --> 00:03:01,700
we've got a whole lot of really great tools

00:03:01,700 --> 00:03:04,140
for working with HTTP in Python.

00:03:04,140 --> 00:03:07,460
We've got really awesome client libraries.

00:03:07,460 --> 00:03:11,520
Even if we wanted to pretend that Requests was not a really awesome client library,

00:03:11,529 --> 00:03:15,120
which it is, there still a huge number of other great client libraries

00:03:15,120 --> 00:03:18,719
floating around in Pythonland and built on top of Requests.

00:03:18,719 --> 00:03:24,019
So for example, HTTPie, which some of you probably don't know,

00:03:24,020 --> 00:03:26,040
one of the great tools lurking in the Python community

00:03:26,049 --> 00:03:28,420
that people don't really use.

00:03:28,420 --> 00:03:32,320
And then on top of that we've got great pure Python web servers like gunicorn,

00:03:32,329 --> 00:03:35,129
we've got great web frameworks, asynchronous web frameworks

00:03:35,129 --> 00:03:38,620
like aiohttp and Twisted and Tornado,

00:03:38,620 --> 00:03:41,239
and essentially we've just got things that cover

00:03:41,239 --> 00:03:44,899
pretty much the broad range of possible uses you could have.

00:03:44,900 --> 00:03:46,880
If you want something that's really easy to use

00:03:46,880 --> 00:03:49,500
and makes a lot of decisions for you, we've got you covered.

00:03:49,510 --> 00:03:51,400
If you want something that's super low level

00:03:51,400 --> 00:03:54,160
where you can control everything and do crazy wacky stuff,

00:03:54,160 --> 00:03:56,280
we've got you covered there too.

00:03:57,040 --> 00:04:00,060
And all of these libraries are great, and we love them all.

00:04:00,060 --> 00:04:04,180
And they all have one problem -- well, they've all got more than one problem.

00:04:04,180 --> 00:04:06,680
But they all have one common problem,

00:04:06,680 --> 00:04:10,540
which is that they don't share code.

00:04:12,080 --> 00:04:14,120
The pedants in the audience will now be pointing out

00:04:14,129 --> 00:04:16,569
that that's trivially untrue. They're all Python libraries

00:04:16,569 --> 00:04:19,860
so they all at the very least share some of the Python interpreter

00:04:19,870 --> 00:04:22,070
and also you know, the collections library,

00:04:22,070 --> 00:04:23,900
they probably all use the collections library,

00:04:23,900 --> 00:04:27,080
at least an abstract base class or something.

00:04:27,080 --> 00:04:31,940
But that's kind of trivial and not what I'm interested in.

00:04:31,940 --> 00:04:33,740
There's another case that's fairly obvious,

00:04:33,740 --> 00:04:35,560
which is some of them wrap each other.

00:04:35,560 --> 00:04:39,200
Requests is a wrapper for urllib3, so obviously they share some code.

00:04:39,200 --> 00:04:42,440
But that also misses my core point.

00:04:42,450 --> 00:04:48,390
What I mean is, they don't share any interesting code

00:04:48,390 --> 00:04:52,210
beyond the Python standard library, all the trivial wrapping cases.

00:04:52,720 --> 00:04:56,880
Now this is kind of odd because as software professionals

00:04:56,880 --> 00:04:59,590
we've all had beaten into us from the start of our career

00:04:59,590 --> 00:05:01,700
that code reuse is great.

00:05:01,700 --> 00:05:04,060
Like, code reuse is one of the core principles

00:05:04,060 --> 00:05:08,940
behind why people try to sell open --

00:05:08,940 --> 00:05:11,980
object-oriented code, rather.

00:05:11,980 --> 00:05:15,400
It is considered to be one of the great examples of code design

00:05:15,410 --> 00:05:18,640
is when you can reuse code as much as possible.

00:05:19,360 --> 00:05:21,660
Again, this is only sometimes true,

00:05:21,660 --> 00:05:24,140
but mostly we can say, with 100% certainty,

00:05:24,140 --> 00:05:27,360
that code reuse is great when it comes to well-defined problems

00:05:27,370 --> 00:05:29,970
with clear scope and correct results.

00:05:29,970 --> 00:05:32,210
For example,

00:05:32,210 --> 00:05:34,990
consider arithmetic, addition.

00:05:34,990 --> 00:05:38,280
There is no reason to write your own addition code, right?

00:05:38,280 --> 00:05:40,360
There's no reason to sit down and implement the microcode

00:05:40,370 --> 00:05:42,540
that is inside a CPU to do addition

00:05:42,540 --> 00:05:44,530
because addition has one right answer.

00:05:44,530 --> 00:05:46,450
When you add two numbers together,

00:05:46,450 --> 00:05:48,580
there's only one acceptable answer to come out of that.

00:05:48,580 --> 00:05:50,290
That's huge.

00:05:50,290 --> 00:05:52,140
So when you've got a problem like that,

00:05:52,140 --> 00:05:56,680
you want to avoid reinventing wheels in production code.

00:05:56,680 --> 00:05:58,500
There's obviously lots of value in reinventing wheels

00:05:58,500 --> 00:06:01,480
to teach yourself something, but if you're trying to sell a product

00:06:01,480 --> 00:06:06,180
or build something for people to use, you want to avoid reinventing wheels.

00:06:06,680 --> 00:06:08,700
There are a couple of really important examples

00:06:08,710 --> 00:06:11,760
of problems that are like this that are well defined,

00:06:11,760 --> 00:06:16,160
that have a really clearly defined scope and one correct answer.

00:06:16,160 --> 00:06:19,200
Some examples that we deal with a lot in nontrivial code

00:06:19,210 --> 00:06:23,030
are things like file formats, parsing a file format,

00:06:23,030 --> 00:06:27,100
parsing XML for example -- there's one correct answer for parsing XML --

00:06:27,100 --> 00:06:31,820
compression algorithms, and network protocol parses.

00:06:31,820 --> 00:06:34,320
I mention network protocol parses for two reasons.

00:06:34,320 --> 00:06:37,110
The first one is that that's what I do in my job

00:06:37,110 --> 00:06:39,410
so that's what I think about all the time.

00:06:39,410 --> 00:06:42,580
But I also talk about it because the goal of a network protocol

00:06:42,580 --> 00:06:45,940
is to be able to talk to a different computer somewhere far away.

00:06:45,940 --> 00:06:49,300
And to do that, you have to both agree on what the message means.

00:06:49,300 --> 00:06:51,620
If you disagree on what the message means, you're not communicating

00:06:51,620 --> 00:06:53,720
in a way that's very helpful.

00:06:53,720 --> 00:06:56,240
The advantage of having a network protocol is lost

00:06:56,240 --> 00:06:58,160
and you may as well just write a letter to someone

00:06:58,160 --> 00:07:00,220
because they've got about the same chance of getting it right

00:07:00,230 --> 00:07:02,330
as that random computer did.

00:07:03,000 --> 00:07:05,800
So with that in mind,

00:07:05,800 --> 00:07:09,260
given that there is one and only one correct way

00:07:09,260 --> 00:07:12,160
to parse an HTTP message,

00:07:12,160 --> 00:07:16,560
why do all of our HTTP libraries have their own parsing code?

00:07:18,560 --> 00:07:20,940
There is an answer to this, of course, and the answer to this

00:07:20,940 --> 00:07:24,400
is that all of these libraries do their own I/O, and worse than that,

00:07:24,400 --> 00:07:27,620
they mix their I/O into their parsing code.

00:07:27,620 --> 00:07:30,580
I'm going to pick a couple of basic examples,

00:07:30,580 --> 00:07:33,320
httplib in the Python standard library.

00:07:33,320 --> 00:07:36,640
Httplib has got a parser and it's got a state machine

00:07:36,640 --> 00:07:39,060
and it's got socket calls.

00:07:39,060 --> 00:07:42,540
And in a library that was really cleanly well designed,

00:07:42,540 --> 00:07:45,960
you would be able to separate each of these out into their own components pretty easily.

00:07:45,960 --> 00:07:48,780
You'd be able to grab the state machine and the protocol parser

00:07:48,780 --> 00:07:51,820
and yank that out nd just be left with socket calls.

00:07:51,820 --> 00:07:54,200
But that's not how httplib is actually designed.

00:07:54,200 --> 00:07:58,000
Httplib's parser is actually more or less implicit.

00:07:58,000 --> 00:08:03,120
It's broken up by socket calls that read and write in a slightly confusing way

00:08:03,120 --> 00:08:05,780
and that actually enforce the correctness of the library.

00:08:05,780 --> 00:08:09,180
If you don't have those socket calls there or if you change the way they behave,

00:08:09,180 --> 00:08:12,500
httplib can get quite a lot of things quite wrong.

00:08:13,780 --> 00:08:16,160
This is a problem. The various async modules

00:08:16,170 --> 00:08:19,070
like aiohttp and Tornado and Twisted,

00:08:19,070 --> 00:08:21,990
they're usually slightly better at this.

00:08:21,990 --> 00:08:25,060
But then they compound it with a different mistake.

00:08:25,070 --> 00:08:27,130
So having dodged that bullet,

00:08:27,130 --> 00:08:31,060
they then tend to mix their concurrency primitives in instead.

00:08:31,060 --> 00:08:33,920
If you go back into aiohttp, for example,

00:08:33,920 --> 00:08:37,220
you will frequently find that aiohttp

00:08:37,220 --> 00:08:40,020
uses asyncio's concurrency primitives

00:08:40,029 --> 00:08:42,300
which don't necessarily interoperate very well

00:08:42,300 --> 00:08:44,720
with the concurrency primitives of the other libraries.

00:08:44,720 --> 00:08:47,000
This gets, again, even worse if you think about

00:08:47,000 --> 00:08:49,260
asynchronous tools that aren't like those.

00:08:49,270 --> 00:08:53,150
For example, if I added /gevents to the end of that list,

00:08:53,150 --> 00:08:57,240
then gevents' HTTP stuff is very gevent-specific.

00:08:57,240 --> 00:08:59,830
You can't very easily yank it out.

00:08:59,830 --> 00:09:02,710
And this leads to a problem in the Python ecosystem.

00:09:02,710 --> 00:09:05,330
It means that the way you want to do I/O

00:09:05,330 --> 00:09:07,870
limits the Python libraries you can use.

00:09:07,870 --> 00:09:10,220
Or if you have structured it the other way

00:09:10,220 --> 00:09:12,460
and you're like a Requests zealot,

00:09:12,460 --> 00:09:16,000
wanting to use Requests means there are certain things you can't do.

00:09:16,000 --> 00:09:19,800
You can't necessarily say, "I want to use Requests in Tornado."

00:09:19,800 --> 00:09:21,740
You can, but you're going to fork out to a thread

00:09:21,740 --> 00:09:23,970
and then there's no point doing Tornado anymore.

00:09:23,970 --> 00:09:26,390
You can just have threads, it's fine.

00:09:27,860 --> 00:09:30,400
So, assuming you all grant me

00:09:30,400 --> 00:09:33,040
that that's a problem, which you might not,

00:09:33,040 --> 00:09:35,360
in which case the rest of this talk is going to be tough for you...

00:09:35,360 --> 00:09:37,680
[laughter]

00:09:37,680 --> 00:09:39,800
...why does this problem matter?

00:09:39,800 --> 00:09:44,560
So we've got lots of HTTP parsers, big deal, who cares?

00:09:45,000 --> 00:09:47,280
Well, there are some real problems about it.

00:09:47,280 --> 00:09:50,080
The first one is we're wasting our time,

00:09:50,080 --> 00:09:52,600
we're wasting our time, we're duplicating effort.

00:09:52,600 --> 00:09:56,800
When the people who wrote aiohttp

00:09:56,800 --> 00:10:01,120
wanted to write that they wanted a great async I/O HTTP library,

00:10:01,120 --> 00:10:04,560
did they need to write a new parser as part of that job?

00:10:04,560 --> 00:10:08,360
Are they adding something to the world with their parser?

00:10:08,360 --> 00:10:11,520
The answer is no, of course not. The parser is boring.

00:10:11,520 --> 00:10:13,820
There is only so good an HTTP parser can be.

00:10:13,820 --> 00:10:16,800
At a certain point you're not getting anything new out of it.

00:10:16,800 --> 00:10:20,040
So they didn't want to write that, they just had to write that.

00:10:20,040 --> 00:10:22,640
There was nothing else there for them to use.

00:10:22,640 --> 00:10:25,040
Speaking for the urllib3 team,

00:10:25,040 --> 00:10:28,310
we use httplib for our parser. We're not happy about that.

00:10:28,310 --> 00:10:30,290
I don't think anyone's ever happy about that.

00:10:30,290 --> 00:10:31,530
[laughter]

00:10:31,530 --> 00:10:35,540
Every time someone builds a new HTTP library in Python,

00:10:35,540 --> 00:10:38,260
you have to write a new parser because you can't get any

00:10:38,260 --> 00:10:40,280
out of the ones that are already there.

00:10:40,280 --> 00:10:43,360
This is effort you shouldn't have to spend and that no one wants to spend.

00:10:43,360 --> 00:10:45,480
There's just nothing fun about writing a parser.

00:10:45,480 --> 00:10:47,420
Trust me, it's what I do.

00:10:48,660 --> 00:10:51,400
But because of this, because you have to write a parser

00:10:51,400 --> 00:10:53,320
to build a new HTTP library,

00:10:53,320 --> 00:10:56,140
it's harder to experiment with building HTTP libraries.

00:10:56,140 --> 00:10:58,100
There are interesting things you can do in this space.

00:10:58,101 --> 00:11:00,040
You can come up with different API designs,

00:11:00,040 --> 00:11:02,680
you can come up with different approaches to working concurrently,

00:11:02,690 --> 00:11:04,400
you can try and do different things with I/O

00:11:04,400 --> 00:11:06,820
or use exciting new socket flags that the Linux kernel added

00:11:06,830 --> 00:11:08,960
because why the hell not?

00:11:08,960 --> 00:11:11,680
And if you want to try that stuff out, you can't diverge too far

00:11:11,690 --> 00:11:13,580
from what's already there or you have to write

00:11:13,580 --> 00:11:16,540
a brand new HTTP parser all over again.

00:11:18,040 --> 00:11:21,000
This is really unnecessary overhead given that, once again,

00:11:21,000 --> 00:11:25,280
that there's really only one correct answer when it comes to parsing an HTTP message.

00:11:26,100 --> 00:11:28,080
It gets a bit worse than that

00:11:28,080 --> 00:11:31,880
because it causes us to duplicate bugs.

00:11:32,400 --> 00:11:35,380
HTTP is famously one of those protocols

00:11:35,380 --> 00:11:37,600
that people think is easy to parse

00:11:37,600 --> 00:11:41,120
and are tripped up when they discover that that's not actually true.

00:11:41,120 --> 00:11:43,260
It's terribly difficult to parse.

00:11:44,780 --> 00:11:48,020
There are lots of mistakes you can make when parsing HTTP,

00:11:48,020 --> 00:11:50,760
and almost invariably,

00:11:50,760 --> 00:11:54,390
multiple Python libraries make the exact same mistake

00:11:54,390 --> 00:11:57,680
because they couldn't learn or build on top of the correct decision

00:11:57,680 --> 00:12:01,480
made by someone else elsewhere in the ecosystem.

00:12:01,860 --> 00:12:04,000
This means we all make the same mistakes

00:12:04,000 --> 00:12:06,670
and we all look like idiots in the exact same way

00:12:06,670 --> 00:12:09,470
and all of this is totally unnecessary.

00:12:10,820 --> 00:12:15,240
And then on top of all of this, it limits our ability to optimize.

00:12:15,250 --> 00:12:18,480
The Python community is frequently a bit schizophrenic

00:12:18,480 --> 00:12:20,360
when it comes to the way we talk about performance.

00:12:20,360 --> 00:12:22,200
Half the community say that performance is irrelevant

00:12:22,200 --> 00:12:24,720
because why would we write in Python if we cared about performance?

00:12:24,720 --> 00:12:26,620
And the other half say that Python is far too slow

00:12:26,620 --> 00:12:30,420
and we need to drop down to C because parsing is difficult in Python.

00:12:30,420 --> 00:12:32,960
Leaving aside the possibility that both of these people

00:12:32,960 --> 00:12:36,000
might be taking a pretty extreme view of the world,

00:12:36,000 --> 00:12:39,220
there is a truth here, which is that optimizing is hard.

00:12:39,220 --> 00:12:43,300
And optimizing a specific component is particularly difficult.

00:12:43,300 --> 00:12:47,020
For example, if you wanted to optimize socket I/O,

00:12:47,020 --> 00:12:49,720
that turns out to be a remarkably difficult thing to do.

00:12:49,720 --> 00:12:52,960
I'm certainly not smart enough to optimize socket I/O,

00:12:52,960 --> 00:12:55,040
and I've tried.

00:12:55,040 --> 00:12:57,740
It's a very specific skill.

00:12:57,740 --> 00:13:00,500
And that specific skill is not shared

00:13:00,500 --> 00:13:03,580
by most people who are good at writing parsers.

00:13:03,580 --> 00:13:05,420
Parsers are not like socket calls.

00:13:05,420 --> 00:13:07,360
For one thing, they mostly don't have to deal with

00:13:07,360 --> 00:13:10,080
the messy actual network where packets get lost.

00:13:10,080 --> 00:13:12,100
Packets never get lost in a parser because,

00:13:12,100 --> 00:13:15,010
how could they possibly get lost? It's just a parser.

00:13:15,010 --> 00:13:17,510
This means when you tie your I/O to your parser,

00:13:17,510 --> 00:13:19,480
you make it very hard for users

00:13:19,480 --> 00:13:22,260
to optimize I/O for the case they care about.

00:13:22,260 --> 00:13:26,180
If you've got a user who wants to send just massive binary files,

00:13:26,180 --> 00:13:28,410
they want a different approach to I/O than a user

00:13:28,410 --> 00:13:32,560
who is doing live streaming of very latency-strict data.

00:13:32,560 --> 00:13:36,700
They need different things, and when your I/O is in your parser,

00:13:36,700 --> 00:13:40,540
it affects what they can actually do and limits them.

00:13:40,540 --> 00:13:42,580
This limits how effectively they can perform

00:13:42,580 --> 00:13:44,460
and ends up forcing them to write Go.

00:13:44,460 --> 00:13:47,220
And then the whole world's just gotten slightly sadder.

00:13:47,220 --> 00:13:50,620
And that's not what we need as a community.

00:13:50,620 --> 00:13:52,720
It's not sadder because they had to write Go, by the way,

00:13:52,720 --> 00:13:54,600
and I'm not taking a shot at Go. Go is wonderful.

00:13:54,600 --> 00:13:56,500
It's sadder because they're not in our community

00:13:56,500 --> 00:13:58,360
which is where I would like them to stay.

00:13:58,360 --> 00:14:00,120
I want as many people in this community as possible

00:14:00,120 --> 00:14:01,940
because then I can hide.

00:14:01,940 --> 00:14:03,520
[laughter]

00:14:03,520 --> 00:14:07,100
So we have a problem with some costs.

00:14:07,110 --> 00:14:10,800
They might not be really high costs, but they are costs.

00:14:10,800 --> 00:14:13,780
The fact that these costs aren't high, by the way, is why we have this problem.

00:14:13,780 --> 00:14:16,140
If this cost was like, my machine doesn't boot at all

00:14:16,140 --> 00:14:20,140
because my parser and my I/O are mixed, we wouldn't have this problem anymore.

00:14:20,140 --> 00:14:23,080
That's not it. It just causes a low-level technical cost

00:14:23,089 --> 00:14:25,640
that affects your application from the day you started writing it

00:14:25,640 --> 00:14:28,440
till the day you give up and decide to become a farmer.

00:14:28,440 --> 00:14:29,839
[laughter]

00:14:29,839 --> 00:14:32,159
This is a real problem with a real set of costs.

00:14:32,160 --> 00:14:35,780
So what are we doing wrong, and how do we avoid the problem?

00:14:35,780 --> 00:14:37,620
Well, what are we doing wrong is easy

00:14:37,620 --> 00:14:39,840
because I've told you the whole way through this talk.

00:14:39,840 --> 00:14:42,600
It's don't do I/O, at all, ever.

00:14:42,600 --> 00:14:44,680
Pure functional programming.

00:14:44,680 --> 00:14:47,000
That is not the message of this talk. The message of this talk is,

00:14:47,000 --> 00:14:50,240
don't do I/O in your parsers and state machines.

00:14:50,240 --> 00:14:52,100
When you're tackling a network protocol,

00:14:52,100 --> 00:14:54,520
or for that matter a file format,

00:14:54,520 --> 00:14:57,000
it should be possible for you to pick up a parser

00:14:57,000 --> 00:14:59,140
for that network protocol or file format

00:14:59,140 --> 00:15:02,360
and plug it right into your chosen I/O paradigm,

00:15:02,360 --> 00:15:04,240
however you've decided to do it,

00:15:04,240 --> 00:15:06,460
whatever wacky decision you've decided to make,

00:15:06,460 --> 00:15:09,040
your parser should be able to just be plugged right in

00:15:09,040 --> 00:15:11,000
with no drama whatsoever.

00:15:11,600 --> 00:15:14,140
So if you are the kind of person who writes parsers,

00:15:14,140 --> 00:15:16,620
that means you need to keep a big hard wall

00:15:16,620 --> 00:15:19,320
between your parser and the code that does your I/O

00:15:19,320 --> 00:15:22,160
because the second your I/O code leaks into your parser,

00:15:22,160 --> 00:15:26,500
it becomes very, very difficult to reuse that work in a different context.

00:15:27,140 --> 00:15:29,860
Because this is a coding conference, we should have some code.

00:15:29,860 --> 00:15:34,000
This is an alternative better API for building network parsers.

00:15:34,000 --> 00:15:35,600
And I want to be clear,

00:15:35,600 --> 00:15:37,560
this is exactly what the API looks like

00:15:37,560 --> 00:15:42,250
except you maybe change perform_action to something somewhat more specific.

00:15:42,250 --> 00:15:46,330
You have one function that takes in data from the network.

00:15:46,760 --> 00:15:48,620
It doesn't care how the data got there.

00:15:48,630 --> 00:15:51,640
It could have come on a pigeon, it could have been sent on a boat,

00:15:51,640 --> 00:15:54,070
it doesn't matter, just some data showed up

00:15:54,070 --> 00:15:55,960
and it goes in one end,

00:15:55,960 --> 00:15:59,140
and out the other end come events. Something happened.

00:15:59,160 --> 00:16:01,880
In httpland, this event can be, "I received a request"

00:16:01,890 --> 00:16:06,570
or "I received some data" or "the user went away,"

00:16:06,570 --> 00:16:08,960
whatever happened in the protocol.

00:16:08,960 --> 00:16:11,720
Then on the other side, you can have one of two things.

00:16:11,720 --> 00:16:14,790
You can have a number of functions that perform specific events

00:16:14,790 --> 00:16:17,290
like "send a response,"

00:16:17,290 --> 00:16:20,870
or you can have one function that takes event objects.

00:16:20,870 --> 00:16:23,140
Same basic -- it's just an API design question,

00:16:23,140 --> 00:16:25,529
they have the same basic effect, but in both cases

00:16:25,529 --> 00:16:29,189
what they output, what they return, is more bytes.

00:16:29,660 --> 00:16:33,200
This library doesn't care how bytes get in or how they get out.

00:16:33,210 --> 00:16:36,180
It doesn't matter, it's not its problem, there just are bytes.

00:16:36,180 --> 00:16:40,480
They're nonspecific bytes in an idealized Platonic world that is all bytes.

00:16:40,480 --> 00:16:43,400
It's not a fun place to be but it's a place.

00:16:43,400 --> 00:16:48,780
And it's not its job to get those bytes onto or off a network.

00:16:48,790 --> 00:16:51,220
The goal here is that the parser author

00:16:51,220 --> 00:16:53,800
is going to let higher level libraries worry

00:16:53,800 --> 00:16:56,269
about how to get bytes on and off a network.

00:16:56,269 --> 00:16:59,829
The goal of the parser library is just to understand the bytes,

00:16:59,829 --> 00:17:03,689
not to worry about how they get there or how they go away.

00:17:04,860 --> 00:17:07,380
This is obviously not an all-purpose library, right?

00:17:07,380 --> 00:17:09,200
Like, there are some things in protocols

00:17:09,209 --> 00:17:11,630
that require more user intervention than this

00:17:11,630 --> 00:17:14,360
or that are in some way tied to I/O.

00:17:14,360 --> 00:17:17,660
A good example in HTTP/2 is flow control,

00:17:17,660 --> 00:17:20,520
which limits how much data a peer can send.

00:17:20,530 --> 00:17:23,630
There are ways you might want to control flow, control windows.

00:17:23,630 --> 00:17:26,580
Obviously a parser should not be deciding that, right?

00:17:26,580 --> 00:17:29,800
But it should be offering all the handles that need to be pulled

00:17:29,809 --> 00:17:31,909
in order to make those decisions.

00:17:32,420 --> 00:17:36,320
Additionally it should have documentation because documentation is good,

00:17:36,320 --> 00:17:38,320
and in that documentation it should say,

00:17:38,320 --> 00:17:41,480
"If you need to do flow control, here's the levers you pull."

00:17:42,400 --> 00:17:46,020
Then once you have your nice little HTTP parsing library,

00:17:46,020 --> 00:17:48,500
you got this core implementation, what you do is you wrap it

00:17:48,500 --> 00:17:51,720
in a higher level library that does do I/O, right?

00:17:51,720 --> 00:17:54,100
Like, I'm not saying that Requests is a bad thing to have

00:17:54,100 --> 00:17:57,429
and you should all pick up a parser and learn to write socket calls

00:17:57,429 --> 00:17:59,769
and do all this stuff. That's obviously crazy.

00:17:59,769 --> 00:18:02,129
Most people don't have time for that.

00:18:02,129 --> 00:18:03,929
Requests should exist,

00:18:03,929 --> 00:18:07,269
and so should aiohttp and all these other things.

00:18:07,269 --> 00:18:10,320
But they should also all have

00:18:10,320 --> 00:18:13,640
the same common parser at the base of them.

00:18:13,640 --> 00:18:16,020
You can think of them as having a little tree of things.

00:18:16,020 --> 00:18:19,820
There's the API on the top, Requests' famous API on the top,

00:18:19,820 --> 00:18:22,980
and then there is a bit that does sockety stuff

00:18:22,980 --> 00:18:26,720
and a bit that does parsingy stuff, and never the twain shall meet.

00:18:26,720 --> 00:18:29,560
They go through this little API layer at the top,

00:18:29,560 --> 00:18:32,820
and then that means that if you care about APIs

00:18:32,820 --> 00:18:34,640
or if you care about sockets,

00:18:34,640 --> 00:18:37,350
you can mess about with all of that to your heart's content

00:18:37,350 --> 00:18:41,220
without ever worrying about, is the parser going to break under my feet?

00:18:41,220 --> 00:18:43,780
You can build new versions of these things that are better

00:18:43,780 --> 00:18:45,720
than the janky stuff you've already got

00:18:45,720 --> 00:18:48,900
without worrying about, how the hell does, you know,

00:18:48,900 --> 00:18:50,980
line continuation work in HTTP?

00:18:50,980 --> 00:18:54,480
Because none of you even know that line continuation is a thing in HTTP.

00:18:54,480 --> 00:18:56,720
And you're gonna get it wrong and that's fine

00:18:56,720 --> 00:19:00,380
because we all get it wrong at least once. I got it wrong twice. It's not a big deal.

00:19:00,380 --> 00:19:03,340
But you don't want to do this and make these mistakes like me

00:19:03,340 --> 00:19:06,320
because you're just not gonna feel good about it.

00:19:06,320 --> 00:19:08,980
In this world, Requests is a wrapper around a parser.

00:19:08,990 --> 00:19:11,770
And aiohttp is a wrapper around the same parser.

00:19:11,770 --> 00:19:15,190
But they've got different I/O, they've got different API primitives.

00:19:15,190 --> 00:19:18,380
Aiohttp uses yield from because that's the new hotness

00:19:18,380 --> 00:19:22,260
and everyone's happy about these things, everyone gets what they want

00:19:22,260 --> 00:19:26,120
but we get fewer bugs, and that's great.

00:19:26,120 --> 00:19:28,500
So what do you get when you develop this way?

00:19:28,500 --> 00:19:31,120
Aside from fewer bugs, although fewer bugs is huge.

00:19:31,120 --> 00:19:34,880
The first thing you get is you get libraries that are super easy to test.

00:19:34,880 --> 00:19:38,010
This turns out to be not immediately obvious to a lot of people.

00:19:38,010 --> 00:19:42,410
But if you test a library that does I/O, really any I/O at all,

00:19:42,410 --> 00:19:45,160
it turns out to be almost impossible to test.

00:19:45,160 --> 00:19:48,940
This is because, because the I/O is deep in under the library,

00:19:48,940 --> 00:19:50,960
you have to exercise the I/O logic

00:19:50,960 --> 00:19:54,080
in order to exercise the other logic of the program, right?

00:19:54,080 --> 00:19:58,120
HTTP might care about how long bytes take to show up,

00:19:58,130 --> 00:20:01,100
and if you're going to test that, now you're also testing your parser as well.

00:20:01,100 --> 00:20:04,520
You need to send some byte stream in and then pause, you need to make a sleep,

00:20:04,530 --> 00:20:06,890
you need to do all kinds of other wacky stuff.

00:20:06,890 --> 00:20:10,290
This is really unpleasant and leads to all kinds of knotty problems.

00:20:10,290 --> 00:20:12,100
And if you want to see how unpleasant it is,

00:20:12,100 --> 00:20:14,360
you should go take a look at urllib3's test cases

00:20:14,360 --> 00:20:16,260
which frequently have to do something like this

00:20:16,260 --> 00:20:18,980
in order to hit weird edge cases in the code.

00:20:19,500 --> 00:20:22,000
But in this new model, where the parser is self-contained

00:20:22,000 --> 00:20:24,640
and just handles bytes based on function calls,

00:20:24,640 --> 00:20:28,640
it is really, really easy to test it thoroughly and extensively.

00:20:28,640 --> 00:20:33,500
This is from my HTTP/2 protocol suite.

00:20:34,420 --> 00:20:37,380
This is not the first time I've given this talk,

00:20:37,380 --> 00:20:39,940
and the last time I gave this talk I had only 600 tests.

00:20:39,940 --> 00:20:43,660
Now I have 900 tests because writing tests for these is just really easy.

00:20:43,660 --> 00:20:46,520
It's a thing you can do when you're bored in your spare time.

00:20:46,520 --> 00:20:49,880
They're super easy to test and hit weird edge cases

00:20:49,880 --> 00:20:52,700
because the only weird edge cases in here now just amount to,

00:20:52,700 --> 00:20:56,920
"I got byte x then byte y," that's pretty easy to test.

00:20:59,140 --> 00:21:02,600
The other advantage you get here is you can have application-specific I/O again.

00:21:02,600 --> 00:21:06,540
This is great. Do you know all the socket flags in the socket library?

00:21:07,340 --> 00:21:10,280
All right, there's one hand up, and I think that guy's lying.

00:21:10,280 --> 00:21:11,720
[laughter]

00:21:11,720 --> 00:21:13,340
(audience member) Just most of them.

00:21:13,340 --> 00:21:15,180
(Cory Benfield) Just most of them, yeah,

00:21:15,180 --> 00:21:17,240
well, most of them is already doing pretty well.

00:21:18,040 --> 00:21:21,160
On top of that, once you know what they are, do you know how to use them correctly?

00:21:21,160 --> 00:21:24,640
Lots of people think they know how to use, for example,

00:21:24,650 --> 00:21:30,330
the best one being delayed ac, the delayed act flag.

00:21:30,330 --> 00:21:32,840
No one uses that properly. I've seen code that uses it wrongly

00:21:32,840 --> 00:21:35,520
because it turns out using it correctly is really hard.

00:21:35,520 --> 00:21:38,940
And on top of that, your users probably want different flags than you.

00:21:38,940 --> 00:21:41,300
It's hard to write high performance I/O.

00:21:41,300 --> 00:21:44,480
And if you don't have to solve that problem, you shouldn't solve that problem

00:21:44,480 --> 00:21:47,760
because again, it's hard, and hard stuff is boring.

00:21:47,760 --> 00:21:49,240
Don't do it.

00:21:49,250 --> 00:21:52,530
And it's a very different problem than writing a good protocol parser.

00:21:52,530 --> 00:21:56,050
You don't have to solve both problems at once, and you shouldn't.

00:21:57,160 --> 00:22:00,480
But the main reason you want to do this is it lets you build a toolbox

00:22:00,490 --> 00:22:04,930
of really, really great implementations of things.

00:22:04,930 --> 00:22:06,880
The Python community is a great community

00:22:06,880 --> 00:22:09,040
and we have a lot of HTTP things.

00:22:09,040 --> 00:22:13,420
What we should have is one really excellent HTTP parser

00:22:13,429 --> 00:22:15,349
that everyone can use.

00:22:15,349 --> 00:22:17,260
This reduces the amount of bugs we have

00:22:17,270 --> 00:22:19,180
which means that we reduce the amount of time

00:22:19,180 --> 00:22:21,280
developers spend fixing these bugs.

00:22:21,280 --> 00:22:23,080
This is both developers of the libraries

00:22:23,080 --> 00:22:24,980
and also developers of the consumers of these libraries

00:22:24,980 --> 00:22:27,940
who really don't care about HTTP parsing at all,

00:22:27,940 --> 00:22:30,900
they just want to use the Twilio API so they can make a phone call.

00:22:30,900 --> 00:22:33,280
It's not interesting to them.

00:22:33,280 --> 00:22:36,340
We shouldn't be spending time solving this solved problem

00:22:36,340 --> 00:22:37,940
again and again.

00:22:37,940 --> 00:22:39,840
And then that means those few developers

00:22:39,840 --> 00:22:42,500
who do care about protocol parsing can share their work

00:22:42,510 --> 00:22:44,460
and combine their efforts and get together

00:22:44,460 --> 00:22:46,620
in increasingly nerdier and esoteric meetings

00:22:46,620 --> 00:22:49,120
to solve the few remaining problems that they have,

00:22:49,120 --> 00:22:51,560
which I will greatly enjoy, and you will all greatly enjoy

00:22:51,560 --> 00:22:54,660
not needing to care about it. It's enormously good.

00:22:54,660 --> 00:22:57,380
We should let developers worry about their high-level concerns

00:22:57,380 --> 00:23:01,150
and let developers who care about parsing protocols

00:23:01,150 --> 00:23:03,110
care about parsing protocols.

00:23:03,820 --> 00:23:07,940
It lets HTTP library design become about APIs and I/O

00:23:07,940 --> 00:23:11,360
rather than about boring solved problems.

00:23:12,660 --> 00:23:17,760
As an example of how this stuff looks in real code, I've got two.

00:23:17,760 --> 00:23:20,020
The first one is hyper-h2.

00:23:20,020 --> 00:23:22,740
This is an HTTP/2 protocol stack.

00:23:22,740 --> 00:23:27,059
As far as I know, it is still the only Python HTTP/2 protocol stack

00:23:27,060 --> 00:23:31,060
which means either I did a good job or no one cares about HTTP/2.

00:23:31,820 --> 00:23:34,300
You can take a look at its docs, and its docs talk about

00:23:34,309 --> 00:23:36,469
exactly how you use a library like this.

00:23:36,469 --> 00:23:39,040
And you can take a look at its code, and you can see that its code

00:23:39,049 --> 00:23:41,890
is terrifying and scary, and then you can put the code away,

00:23:41,890 --> 00:23:44,530
which is something I strongly encourage.

00:23:45,400 --> 00:23:48,580
A similar project exists for HTTP/1.1

00:23:48,580 --> 00:23:50,340
which was written by Nathaniel Smith.

00:23:50,340 --> 00:23:53,480
I happily had nothing to do with it so it's inevitably very good.

00:23:53,480 --> 00:23:55,360
And it's absolutely worth looking into

00:23:55,360 --> 00:23:57,300
because it is another way of solving this problem.

00:23:57,309 --> 00:24:02,109
It demonstrates that this is not an HTTP/2-only solution to this problem.

00:24:03,500 --> 00:24:05,340
But here's the thing.

00:24:05,660 --> 00:24:07,380
I'm only one person.

00:24:07,380 --> 00:24:10,920
Nathaniel is, as far as I know, also only one person.

00:24:10,920 --> 00:24:14,260
And we have a limited amount of time and we can only solve this problem

00:24:14,260 --> 00:24:17,240
in a few spaces and only in a few areas.

00:24:17,242 --> 00:24:20,419
I personally need help with the HTTP/2 side.

00:24:20,419 --> 00:24:22,859
Nathaniel presumably needs help with the HTTP/1.1 side,

00:24:22,860 --> 00:24:25,000
although again if he's multiple people, maybe not.

00:24:25,000 --> 00:24:28,580
You should check with him first, or them first.

00:24:28,580 --> 00:24:31,240
But you can also apply this philosophy to a whole set

00:24:31,240 --> 00:24:34,240
of other problems that aren't HTTP.

00:24:34,240 --> 00:24:36,260
So if you feel like you want to help out,

00:24:36,260 --> 00:24:38,960
there are some things you can do. You can, for example,

00:24:38,960 --> 00:24:43,180
try putting HTTP/2 support in your favorite HTTP tool.

00:24:43,180 --> 00:24:46,940
Alternatively you can think of another protocol or file format

00:24:46,950 --> 00:24:50,310
that's amenable to this kind of approach and supply a patch to them.

00:24:50,310 --> 00:24:52,080
See how it goes.

00:24:52,080 --> 00:24:54,900
I encourage you to take this up, I encourage you to give it a shot.

00:24:54,900 --> 00:24:57,320
And if you're not convinced by any of this,

00:24:57,320 --> 00:24:59,940
it is now time for you to ask me some questions.

00:24:59,940 --> 00:25:01,460
Thank you very much.

00:25:01,460 --> 00:25:08,980
[applause]

00:25:10,380 --> 00:25:12,820
Great talk, Cory. We have time for a few questions,

00:25:12,820 --> 00:25:15,320
if you could come to the microphone.

00:25:18,520 --> 00:25:20,040
Go ahead.

00:25:20,640 --> 00:25:37,580
[audience member inaudible]

00:25:37,580 --> 00:25:39,000
[laughter]

00:25:39,000 --> 00:25:41,960
(Cory Benfield) You don't get a microphone. It's not for you.

00:25:41,960 --> 00:25:43,560
(host) Is this one on?

00:25:43,560 --> 00:25:50,860
[audience member inaudible]

00:25:50,860 --> 00:25:53,200
[laughter]

00:25:54,700 --> 00:25:56,920
(audience member) More to your -- oh, Jesus.

00:25:56,920 --> 00:25:58,200
[laughter]

00:25:58,200 --> 00:26:02,799
More to your point that we should save time as a community,

00:26:02,799 --> 00:26:05,669
maybe we could save more time by

00:26:05,669 --> 00:26:08,060
letting the Node community do that work.

00:26:08,060 --> 00:26:10,800
What are your thoughts about using --

00:26:10,800 --> 00:26:14,660
about other communities sharing C libraries

00:26:14,660 --> 00:26:18,120
because so many languages have C bindings?

00:26:18,660 --> 00:26:20,600
(Cory Benfield) So there is definitely some value

00:26:20,600 --> 00:26:22,260
in doing that.

00:26:22,260 --> 00:26:26,160
The reason that I get nervous about that is that I really feel like

00:26:26,179 --> 00:26:30,499
letting untrusted input anywhere near C is usually a bad idea.

00:26:30,500 --> 00:26:34,460
[applause]

00:26:34,460 --> 00:26:36,660
On the other hand, if some other language communities

00:26:36,660 --> 00:26:40,360
would like to come and talk about say, a Rust parsing library,

00:26:40,370 --> 00:26:42,200
I am much more amenable to that discussion.

00:26:42,200 --> 00:26:44,620
I am happy to sit down in a room and see how that goes.

00:26:44,620 --> 00:26:46,560
But certainly yes, I think this is broader than just

00:26:46,560 --> 00:26:49,000
a Python-specific concern, and there are actually --

00:26:49,010 --> 00:26:51,260
I have written bindings for at least one

00:26:51,260 --> 00:26:54,540
very, very fast HTTP/1 parser

00:26:54,540 --> 00:26:56,960
that is something that I would consider using as well,

00:26:56,960 --> 00:26:58,660
so you're absolutely right.

00:26:58,660 --> 00:27:00,900
(Nathaniel Smith) If I could just add a comment on that --

00:27:00,900 --> 00:27:03,020
(Cory Benfield) That's Nathaniel, by the way.

00:27:03,860 --> 00:27:06,200
(Nathaniel Smith) I actually -- in H11 I started by

00:27:06,210 --> 00:27:08,630
wrapping the node.js parser.

00:27:08,630 --> 00:27:12,440
It turns out that parsing alone is only a small part of the problem

00:27:12,450 --> 00:27:15,660
of keeping track of an HTTP/1 connection state,

00:27:15,660 --> 00:27:18,049
like you have to keep track of the response, there's all these weird things

00:27:18,049 --> 00:27:20,749
that can happen with upgrades and all that.

00:27:20,749 --> 00:27:24,129
So as far as I know, there aren't any actual, like,

00:27:24,129 --> 00:27:27,500
libraries you can just drop in that actually do all of that for you,

00:27:27,500 --> 00:27:30,240
it's just the parser, and I ended up throwing that out

00:27:30,240 --> 00:27:32,040
because pure Python is actually nicer

00:27:32,040 --> 00:27:33,940
and once I had the state machine working otherwise,

00:27:33,940 --> 00:27:36,980
I think -- I don't know -- I don't think I spend

00:27:36,980 --> 00:27:39,700
pretty much any time with the actual parsing logic, so...

00:27:39,700 --> 00:27:42,700
But the nice thing about this, you have the nice Python API,

00:27:42,710 --> 00:27:44,550
you could plug that in.

00:27:45,940 --> 00:27:47,360
(audience member) Cool.

00:27:47,360 --> 00:27:50,280
(audience member) So the protocol examples that you gave

00:27:50,280 --> 00:27:52,600
involved protocols that you can handle

00:27:52,600 --> 00:27:55,060
by reading and writing a linear stream of bytes,

00:27:55,070 --> 00:27:59,550
and you showed the very simple API for handling that without I/O.

00:27:59,550 --> 00:28:04,160
Is there a sensible API for pulling the I/O out of a protocol

00:28:04,160 --> 00:28:09,320
that requires random access to a file, for example, a file format parser?

00:28:10,440 --> 00:28:12,680
(Cory Benfield) The answer to that is going to be yes,

00:28:12,680 --> 00:28:14,720
but it's not going to be quite so simple.

00:28:14,720 --> 00:28:19,360
So, necessarily that API needs to have a much more structured representation

00:28:19,360 --> 00:28:22,200
of what I called events.

00:28:22,200 --> 00:28:26,780
So HTTP and HTTP/1 and /2 and all those things

00:28:26,780 --> 00:28:30,560
are essentially streams of events that happen one after the other.

00:28:30,560 --> 00:28:33,200
There is obviously room for having an API

00:28:33,200 --> 00:28:35,780
that doesn't think about events in terms of streams

00:28:35,780 --> 00:28:38,340
but for example, might think of them in terms of trees

00:28:38,340 --> 00:28:40,980
or in terms of various kinds of nested structures.

00:28:40,980 --> 00:28:42,920
It can definitely be done.

00:28:42,920 --> 00:28:44,860
It is not the kind of thing hat you can just kind of

00:28:44,860 --> 00:28:49,840
sit at a laptop and YOLO for a while and then expect it to work out.

00:28:49,840 --> 00:28:52,040
You do need to think about it a bit.

00:28:52,040 --> 00:28:53,960
But yes, it can be done.

00:28:53,960 --> 00:28:55,660
(audience member) Thank you.

00:28:56,820 --> 00:28:59,960
(audience member) Hi. So, love the example in the talk

00:28:59,960 --> 00:29:03,800
of I/O over a network

00:29:03,800 --> 00:29:06,220
versus things you do with that I/O.

00:29:06,220 --> 00:29:09,420
It's very clear where to draw that boundary line.

00:29:10,020 --> 00:29:12,820
I feel like if you take that idea far enough,

00:29:12,820 --> 00:29:15,320
you basically end up with something like Haskell,

00:29:15,320 --> 00:29:18,400
like do all your stuff over here and then have your monads over here

00:29:18,409 --> 00:29:20,609
or whatever they are.

00:29:20,609 --> 00:29:22,620
Where do you -- how do you draw that line for other code

00:29:22,630 --> 00:29:25,490
where it's not so obvious, or in general do you see --

00:29:25,490 --> 00:29:27,880
do you think this is a good programming paradigm

00:29:27,880 --> 00:29:31,400
of like, do your functional stuff and only have your I/O where you need it

00:29:31,400 --> 00:29:33,840
and an API that ties the two together?

00:29:33,840 --> 00:29:36,200
(Cory Benfield) Uh, yeah, so the answer is yes,

00:29:36,210 --> 00:29:38,080
I think that is a good paradigm.

00:29:38,080 --> 00:29:41,320
Haskell's strictness is not necessarily very friendly,

00:29:41,320 --> 00:29:46,240
but it's frequently a good idea to make code as pure as possible,

00:29:46,240 --> 00:29:49,240
to have as little mutable state as you can.

00:29:49,250 --> 00:29:51,970
Please don't look inside hyper-h2, it's all mutable state.

00:29:51,970 --> 00:29:56,750
But if I was better at my job, I would have less mutable state,

00:29:56,750 --> 00:29:59,660
much more immutability, much more purity, because again,

00:29:59,669 --> 00:30:01,720
it further improves all these things we already have.

00:30:01,720 --> 00:30:05,400
It makes it easier to test, it makes it easier to make guarantees about.

00:30:05,400 --> 00:30:07,120
Those are all very valuable.

00:30:07,120 --> 00:30:11,460
Of course, you do then at some point need to actually write to a socket,

00:30:11,460 --> 00:30:15,991
but you can definitely learn lessons from the functional paradigm in that place.

00:30:17,640 --> 00:30:20,740
(audience member) Hey. I feel like there's another problem set

00:30:20,740 --> 00:30:24,660
that's very similar to HTTP and it's

00:30:24,660 --> 00:30:27,760
certificate validation for SSL and TLS.

00:30:27,760 --> 00:30:29,720
Do you know if there's a centralized effort

00:30:29,720 --> 00:30:33,700
to sort of merge that across all the different projects?

00:30:33,700 --> 00:30:36,100
(Cory Benfield) Uh, there are, at last count,

00:30:36,100 --> 00:30:38,860
at least 12 centralized efforts to do that.

00:30:38,860 --> 00:30:41,600
[laughter, applause]

00:30:43,530 --> 00:30:45,320
I'm a very pragmatic person.

00:30:45,320 --> 00:30:47,360
I have to live in the world that there is.

00:30:47,360 --> 00:30:51,080
And I feel like the best you can do usually

00:30:51,080 --> 00:30:54,220
is to use the validation libraries that your OS ships with.

00:30:54,220 --> 00:30:57,700
So that at least is consistent with everything else on the machine,

00:30:57,700 --> 00:30:59,920
and you can avoid those wacky problems where you get to say,

00:30:59,920 --> 00:31:02,560
"Oh, it works in my browser but not in anything else."

00:31:02,560 --> 00:31:05,940
That's really the best you can do, so I guess that means, you know,

00:31:05,940 --> 00:31:09,620
don't use mbed TLS to do it because no one's ever heard of it.

00:31:09,620 --> 00:31:12,240
You know, stick with the things that are really common.

00:31:12,240 --> 00:31:15,340
There is a whole separate problem around that on Windows and OS 10

00:31:15,340 --> 00:31:19,021
in Python which, if you want to talk about it after this talk

00:31:19,021 --> 00:31:21,429
where all these other people don't have to hear it,

00:31:21,429 --> 00:31:24,409
I'm happy to talk about, I've been doing some work in that space.

00:31:25,280 --> 00:31:27,140
(host) Thank you. I think we're out of time.

00:31:27,140 --> 00:31:29,700
If you have any more questions, perhaps you can meet outside.

00:31:29,700 --> 00:31:31,820
And let's have a another big round of applause.

00:31:31,820 --> 00:31:33,300
(Cory Benfield) Thank you.

00:31:33,300 --> 00:31:36,480

YouTube URL: https://www.youtube.com/watch?v=7cC3_jGwl_U


