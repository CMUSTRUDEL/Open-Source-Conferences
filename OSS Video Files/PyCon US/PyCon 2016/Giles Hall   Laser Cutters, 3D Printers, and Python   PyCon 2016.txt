Title: Giles Hall   Laser Cutters, 3D Printers, and Python   PyCon 2016
Publication date: 2016-06-17
Playlist: PyCon 2016
Description: 
	"Speaker: Giles Hall

How to leverage python to generate physical, tangible things.  We will discuss the basics of laser cutters, 3D printers, and how you can use python to design physical objects.  After a brief introduction to these    technologies, we will explore a few different examples of how we can use python to generate designs suitable for 3D printing and laser cutting.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides"
Captions: 
	00:00:00,280 --> 00:00:06,520
[applause]

00:00:07,940 --> 00:00:09,890
Hi there, how are you doing?

00:00:11,180 --> 00:00:15,580
Thank you so much for coming.

00:00:15,580 --> 00:00:21,760
So, I am here to talk about using Python to generate designs

00:00:21,760 --> 00:00:28,000
for 3D printers and laser cutters, but first I want to talk about myself

00:00:28,000 --> 00:00:29,840
and introduce myself.

00:00:29,840 --> 00:00:34,980
That's my email address and my GitHub repository.

00:00:34,980 --> 00:00:38,860
So, I work at a start-up in Boston called Ginkgo Bioworks.

00:00:38,860 --> 00:00:41,540
We apply techniques from synthetic biology

00:00:41,540 --> 00:00:44,120
and genetic engineering to build custom organisms

00:00:44,120 --> 00:00:45,980
for our customers.

00:00:45,980 --> 00:00:48,220
We build thousands of custom strains,

00:00:48,220 --> 00:00:50,900
and to do this at scale, we rely heavily on Python

00:00:50,900 --> 00:00:55,810
to help us design, track, and analyze our engineered samples.

00:00:55,810 --> 00:00:57,390
And if you're interested about Ginkgo,

00:00:57,390 --> 00:01:00,320
you can learn more about us at ginkgobioworks.com.

00:01:00,320 --> 00:01:01,800
We are hiring.

00:01:04,480 --> 00:01:07,060
In my spare time, I like to explore

00:01:07,060 --> 00:01:10,380
a lot of different hobbies, and that includes things like

00:01:10,380 --> 00:01:13,860
photography and gardening and cycling and cooking,

00:01:13,860 --> 00:01:16,160
electronics and making art.

00:01:16,160 --> 00:01:19,920
And for each one of my hobbies, I've at least written

00:01:19,920 --> 00:01:24,020
like a handful of Python scripts to facilitate it one way or another.

00:01:24,020 --> 00:01:26,800
So here's a quick example:

00:01:26,800 --> 00:01:31,180
in my backyard, I have a Davis weather station.

00:01:31,180 --> 00:01:34,500
This transmits weather data wirelessly to a Raspberry Pi

00:01:34,510 --> 00:01:38,470
in my house, and I have another Raspberry Pi in my basement

00:01:38,470 --> 00:01:42,010
that monitors this data and controls a set of relays

00:01:42,010 --> 00:01:45,540
that switch on sprinklers to water the garden.

00:01:45,540 --> 00:01:48,520
So Python for me, it's not just a programming language.

00:01:48,520 --> 00:01:51,840
It's one of the primary means I use to express myself creatively.

00:01:53,480 --> 00:01:59,220
But as powerful as Python is, programming by its very nature

00:01:59,220 --> 00:02:02,500
is not a physical medium.

00:02:02,500 --> 00:02:05,620
Frederick P. Brooks wrote one of my favorite quotes

00:02:05,620 --> 00:02:10,740
about computer programming in his book "The Mythical Man-Month."

00:02:10,740 --> 00:02:13,060
(reading quote)

00:02:21,180 --> 00:02:24,820
And the world is filled with these amazing but nebulous castles

00:02:24,820 --> 00:02:29,360
but we can't really appreciate them without the aid of a computer.

00:02:29,360 --> 00:02:31,980
You can't share your code like you would a painting,

00:02:31,980 --> 00:02:35,560
or a sculpture, or a well-cooked meal.

00:02:35,560 --> 00:02:39,000
And, you know, to be honest, I realize that this is not true.

00:02:39,000 --> 00:02:43,900
Like, we use software to manipulate our physical world every day.

00:02:46,060 --> 00:02:48,060
Our computers produce sound and light

00:02:48,060 --> 00:02:50,380
and they churn out printed documents.

00:02:50,380 --> 00:02:53,700
There are many ways that you can write code

00:02:53,700 --> 00:02:56,420
to affect the physical world.

00:02:56,420 --> 00:02:59,980
And that's the core of what I want to talk about.

00:02:59,980 --> 00:03:02,420
But first, a little history.

00:03:03,940 --> 00:03:08,460
Before there were computers, people had to make things by hand.

00:03:08,460 --> 00:03:10,880
The period between the late 19th century

00:03:10,880 --> 00:03:15,980
and the middle of the 20th century was collectively known as the Machine Age.

00:03:15,980 --> 00:03:18,720
And during this time, we perfected the art

00:03:18,720 --> 00:03:22,349
of building parts at an industrial scale

00:03:22,349 --> 00:03:26,500
using a process called subtractive manufacturing.

00:03:26,500 --> 00:03:30,800
This includes techniques such as: milling, turning, boring,

00:03:30,800 --> 00:03:34,660
broaching, sawing, reaming, tapping.

00:03:34,660 --> 00:03:39,860
The general idea was to shape bulk stock into some kind of part

00:03:39,860 --> 00:03:44,300
by removing material with incredible precision.

00:03:44,300 --> 00:03:48,060
But after the 1950s, the world entered the Atomic Age

00:03:48,060 --> 00:03:50,560
and ushered in the digital computer.

00:03:50,560 --> 00:03:55,000
And during the 1940s and 50s, existing tools like mills

00:03:55,000 --> 00:03:58,480
and lathes were connected to electric motors

00:03:58,480 --> 00:04:01,600
that were controlled by punch tape.

00:04:01,600 --> 00:04:06,160
This was the first step towards automation of these machine tools.

00:04:06,160 --> 00:04:09,600
And as computers evolved in sophistication,

00:04:09,600 --> 00:04:13,440
it spawned a new field of fabrication called

00:04:13,440 --> 00:04:17,680
computer numerical control, also known as CNC.

00:04:19,560 --> 00:04:22,920
So today, computer-controlled automation is ubiquitous

00:04:22,920 --> 00:04:25,740
throughout all areas of manufacturing.

00:04:25,740 --> 00:04:30,500
Not only has the computer hardware and software programming evolved

00:04:30,500 --> 00:04:33,080
to such a point of sophistication,

00:04:33,080 --> 00:04:37,400
but there are new manufacturing tools and processes that had never existed

00:04:37,400 --> 00:04:40,160
just a few decades prior.

00:04:40,160 --> 00:04:43,820
This includes things like plasma cutters and water jets

00:04:43,820 --> 00:04:47,800
and 5-axis milling machines, lithography,

00:04:47,800 --> 00:04:53,560
and two of my personal favorites: laser cutters and 3D printers.

00:04:53,560 --> 00:04:58,600
So, we're going to examine each one of these technologies individually,

00:04:58,600 --> 00:05:01,740
and then we're going to discuss how we can use Python

00:05:01,740 --> 00:05:05,020
to generate designs for these tools.

00:05:05,020 --> 00:05:10,140
So first, laser cutters.

00:05:10,140 --> 00:05:14,460
Laser cutters are devices that utilize high-powered lasers

00:05:14,460 --> 00:05:18,260
to etch or cut a variety of different materials.

00:05:18,260 --> 00:05:20,640
Most commercially available laser cutters are capable

00:05:20,640 --> 00:05:24,460
of cutting and etching paper or wood, plastic,

00:05:24,460 --> 00:05:28,600
leather, fabric, up to a certain thickness.

00:05:28,600 --> 00:05:31,600
And the laser tube itself is static to the device,

00:05:31,600 --> 00:05:35,300
typically mounted towards the back of the machine.

00:05:35,300 --> 00:05:38,120
Carefully positioned mirrors bounce the laser light

00:05:38,120 --> 00:05:41,520
to the laser head, and the laser head itself

00:05:41,520 --> 00:05:46,259
is composed of mirrors and lenses that focus the laser beam

00:05:46,259 --> 00:05:48,879
onto the target material.

00:05:48,880 --> 00:05:53,280
Stepper motors then move the laser head in the X and Y plane

00:05:53,280 --> 00:05:58,940
parallel to the work material, thus allowing the laser to trace out

00:05:58,940 --> 00:06:01,800
the contours of a given design.

00:06:01,800 --> 00:06:06,300
Laser cutters are incredibly precise and they're capable of producing

00:06:06,300 --> 00:06:13,300
just really complex and intricate detail in your design.

00:06:13,300 --> 00:06:16,040
Digital design for laser cutters though, typically start

00:06:16,040 --> 00:06:18,500
as vector graphics.

00:06:18,500 --> 00:06:22,540
This is, you know, design programs like Adobe Illustrator and Inkscape

00:06:22,550 --> 00:06:25,460
are vector illustrator packages.

00:06:25,460 --> 00:06:29,740
This is in contrast to programs like the GIMP or Photoshop

00:06:29,740 --> 00:06:34,500
which are raster or bitmap oriented graphics packages.

00:06:34,500 --> 00:06:38,440
Vector graphics make it easy for the software controlling the motion

00:06:38,440 --> 00:06:43,160
of the laser cutter to translate your graphics into motion.

00:06:45,640 --> 00:06:47,500
The process of creating laser cut designs

00:06:47,500 --> 00:06:50,260
is relatively straightforward.

00:06:50,260 --> 00:06:53,800
After you think about what your design should look like,

00:06:53,800 --> 00:06:57,580
you need to pick the material that you want to use and the size.

00:06:59,220 --> 00:07:00,800
Generally speaking, if you're cutting

00:07:00,800 --> 00:07:03,720
with a laser cutter, thinner is better than thicker.

00:07:04,880 --> 00:07:11,240
Your design should then be sized according to the constraints

00:07:11,240 --> 00:07:13,000
of the material you're cutting out.

00:07:14,720 --> 00:07:17,639
But with vector graphics you can scale your designs

00:07:17,640 --> 00:07:23,400
without losing any fidelity of your design.

00:07:23,400 --> 00:07:26,460
Most laser cutter software then requires you to indicate

00:07:26,469 --> 00:07:29,260
which parts of your design are meant to be cut

00:07:29,260 --> 00:07:32,400
versus which should be etched.

00:07:32,400 --> 00:07:34,620
This can be achieved with a color of the line,

00:07:34,620 --> 00:07:38,600
for example, red for cut or blue for etch.

00:07:39,840 --> 00:07:42,000
And then when you're ready to execute your cut,

00:07:42,000 --> 00:07:45,060
you position your material on the laser bed,

00:07:45,060 --> 00:07:50,240
and you focus the laser beam, and you upload your design file.

00:07:50,240 --> 00:07:52,640
Every laser cutter, to be honest, is a little different,

00:07:52,640 --> 00:07:56,179
so the specifics of how that actually gets done

00:07:56,179 --> 00:07:59,279
is dictated by the company that makes that specific cutter.

00:08:02,340 --> 00:08:09,000
So, you can upload your designs as PDF or EPS,

00:08:09,000 --> 00:08:12,540
but I personally prefer SVG.

00:08:12,540 --> 00:08:19,540
SVG files are XML documents and a closely-related cousin to HTML.

00:08:20,780 --> 00:08:23,159
HTML and SVG share a lot of attribute names

00:08:23,159 --> 00:08:28,619
for various tags, like width, height, style, and border.

00:08:28,620 --> 00:08:33,360
They share style syntax as well, and later revisions of SVG

00:08:33,360 --> 00:08:35,740
actually support cascading style sheets.

00:08:36,940 --> 00:08:40,800
This is a simple example of an SVG document.

00:08:40,800 --> 00:08:44,780
You can see the two tags: rec for rectangle,

00:08:44,780 --> 00:08:47,140
and circ for circle.

00:08:47,140 --> 00:08:50,180
The rectangle tag takes an XY position

00:08:50,181 --> 00:08:53,220
to define its top-left corner and a width and height value

00:08:53,220 --> 00:08:55,190
to define its size.

00:08:55,190 --> 00:08:57,940
The circle, on the other hand, requires an x and y coordinate

00:08:57,940 --> 00:09:01,860
to define its center, and another value for its radius.

00:09:01,860 --> 00:09:06,240
And each of these objects take parameters that define

00:09:06,240 --> 00:09:09,500
how the shape is stroked and filled, that is, with what color.

00:09:11,060 --> 00:09:18,600
But as you can see, you can get relatively complex designs

00:09:18,600 --> 00:09:21,580
with just a few lines of code with an SVG.

00:09:24,460 --> 00:09:28,120
My personal favorite feature of SVG are paths.

00:09:28,120 --> 00:09:31,740
A path is simply a list of connected line segments

00:09:31,740 --> 00:09:34,620
that are used to build complex polygons.

00:09:34,620 --> 00:09:36,740
A path segment can be a straight line

00:09:36,740 --> 00:09:39,700
or a curve spline with control points.

00:09:39,700 --> 00:09:42,200
Within the SVG document, the path is defined

00:09:42,200 --> 00:09:45,240
by a string of characters.

00:09:45,240 --> 00:09:46,920
It's broken up into single letter commands

00:09:46,920 --> 00:09:50,360
like m for move or l for line,

00:09:50,360 --> 00:09:56,100
and then two or more numbers that represent the coordinate

00:09:56,100 --> 00:09:58,400
of that command.

00:09:58,400 --> 00:10:00,620
You can do a lot with just circles and squares,

00:10:00,620 --> 00:10:04,280
but paths allow you to build incredibly complex shapes.

00:10:04,280 --> 00:10:06,400
And in this example, I just rattled off

00:10:06,400 --> 00:10:09,680
a few random points to make this squiggly line.

00:10:12,360 --> 00:10:15,920
So, for this talk I wrote a Python program

00:10:15,930 --> 00:10:22,820
to generate a laser-cuttable cube or box that uses finger joints.

00:10:22,820 --> 00:10:27,900
Even though this design originates in 2D space,

00:10:27,900 --> 00:10:29,560
when you put it together like a puzzle

00:10:29,560 --> 00:10:31,500
it produces a three-dimensional shape.

00:10:32,800 --> 00:10:35,700
The program itself is a few hundred lines of code

00:10:35,700 --> 00:10:38,300
so we won't be able to discuss it in its entirety,

00:10:38,300 --> 00:10:44,120
but you can go check out my GitHub repository

00:10:44,120 --> 00:10:46,340
after this talk, and look at the code,

00:10:46,340 --> 00:10:51,420
and look at the various options that allow you to change its design.

00:10:52,860 --> 00:10:56,060
I brought a bunch of examples as well, and so if you come find me,

00:10:56,060 --> 00:10:57,540
I can show them to you.

00:10:57,540 --> 00:11:01,320
And I'm gonna auction these off later at the PyLadies auction.

00:11:05,160 --> 00:11:07,720
So, this is what one of the generated designs

00:11:07,720 --> 00:11:11,720
looks like that is sent verbatim to the laser cutting control software.

00:11:13,020 --> 00:11:15,139
You can see that the layout of the design

00:11:15,139 --> 00:11:18,480
packs the faces closely together to minimize the overall waste

00:11:18,480 --> 00:11:20,820
of the material.

00:11:20,820 --> 00:11:26,680
And you can see that it's not the same face over and over again.

00:11:26,680 --> 00:11:30,280
There are slight differences between each of the individual faces.

00:11:30,280 --> 00:11:33,620
And that's to help the puzzle-like way

00:11:33,620 --> 00:11:35,000
that it fits together.

00:11:36,480 --> 00:11:38,639
And so this is the result of what you get

00:11:38,639 --> 00:11:45,319
when you cut that design on wood.

00:11:45,320 --> 00:11:48,940
You can see the scorch marks caused by small flare-ups

00:11:48,940 --> 00:11:53,500
as the material briefly ignites from the laser.

00:11:53,500 --> 00:11:57,600
As a bonus the board has this nice, refreshing burnt wood smell.

00:12:00,120 --> 00:12:02,260
Since the cube fits together like a puzzle,

00:12:02,260 --> 00:12:05,140
the edges of each face must interlock.

00:12:06,020 --> 00:12:10,820
I think of these edges as being either positive or negative,

00:12:10,820 --> 00:12:17,060
dependent upon whether they have a outer edge to them

00:12:17,060 --> 00:12:18,900
or an inner edge to them.

00:12:18,900 --> 00:12:22,200
And I've color coded them to distinguish this feature.

00:12:22,200 --> 00:12:26,740
So in this case, red is positive and green is negative.

00:12:30,180 --> 00:12:34,040
So, as we kind of dial in, we can just think about

00:12:34,040 --> 00:12:39,889
a single edge on a single face, and consider the code

00:12:39,889 --> 00:12:43,000
that we would need to write in order to generate it.

00:12:43,000 --> 00:12:45,220
The width of the material dictates the height

00:12:45,220 --> 00:12:48,580
of each individual finger, and the length of the edge

00:12:48,580 --> 00:12:52,499
combined with the number of fingers that you want in your design

00:12:52,499 --> 00:12:56,779
dictates the overall width of the finger itself.

00:12:56,780 --> 00:12:59,800
And so from these configurable parameters,

00:12:59,800 --> 00:13:02,460
we can write a function to draw a single edge.

00:13:03,940 --> 00:13:08,280
And this is what that code looks like.

00:13:08,280 --> 00:13:12,440
This function takes the size of a cube face as a tuple,

00:13:12,440 --> 00:13:16,120
the number of fingers in an edge, the width of a single finger,

00:13:16,120 --> 00:13:18,480
and the thickness of the material,

00:13:18,480 --> 00:13:22,700
and it calculates various geometrical offsets.

00:13:22,700 --> 00:13:26,840
First, we use the size of the face in order to find its center.

00:13:26,840 --> 00:13:28,880
Along with the number of fingers in the finger width,

00:13:28,880 --> 00:13:33,040
we use the center position then to calculate where our first point

00:13:33,040 --> 00:13:38,340
in the edge line should occur.

00:13:38,340 --> 00:13:42,160
We then build two lists of positional offsets,

00:13:42,160 --> 00:13:46,780
one for the finger width, and the other for the finger depth.

00:13:46,780 --> 00:13:52,200
And we iterate through each point along the edge,

00:13:52,200 --> 00:13:54,720
calculating the offsets for each.

00:13:54,720 --> 00:13:57,700
The code exploits the fact that every other point

00:13:57,700 --> 00:14:01,900
moves forward through the edge, and every second point

00:14:01,910 --> 00:14:05,360
raises the edge and every fourth point lowers it.

00:14:05,360 --> 00:14:09,439
So we use a modulus operator to replay those offsets

00:14:09,439 --> 00:14:11,319
as we build the edge profile.

00:14:13,700 --> 00:14:15,660
And here is an example of how you would call

00:14:15,660 --> 00:14:17,540
that previous function.

00:14:17,540 --> 00:14:19,640
Since the previous function was a generator

00:14:19,640 --> 00:14:21,580
that returns a list of positions,

00:14:21,580 --> 00:14:25,640
the caller takes those points and translates them into a string

00:14:25,640 --> 00:14:28,120
that is formatted as an SVG path.

00:14:29,160 --> 00:14:32,840
You can note that the first command is an M command

00:14:32,840 --> 00:14:36,200
because we want to move to that position.

00:14:36,200 --> 00:14:39,380
And then it's followed by L commands to actually draw

00:14:39,380 --> 00:14:40,860
those connected line segments.

00:14:42,740 --> 00:14:45,120
And that's the result of what we've drawn.

00:14:47,600 --> 00:14:51,260
This is obviously only a small piece of the overall box generator,

00:14:51,260 --> 00:14:55,400
but it's central to the design.

00:14:55,400 --> 00:14:59,260
The code is object-oriented and relatively easy to follow.

00:14:59,260 --> 00:15:02,700
You can configure and customize it in many different ways,

00:15:02,700 --> 00:15:06,380
such as the size of the box, the thickness of the material,

00:15:06,380 --> 00:15:10,440
and the designs on the box faces themselves.

00:15:10,440 --> 00:15:15,420
So for example, since the box generator itself

00:15:15,420 --> 00:15:19,360
has a base class that defines a geometric rules for each face,

00:15:19,360 --> 00:15:24,140
you can inherit from this class and hook into it's rendering method.

00:15:24,140 --> 00:15:27,260
In this example, I've added a Fermat's spiral.

00:15:27,260 --> 00:15:30,779
This is a simple mathematical function that generates a pattern

00:15:30,779 --> 00:15:34,039
that is reminiscent of the pattern of seeds you would find

00:15:34,040 --> 00:15:35,620
on the face of a sunflower.

00:15:37,780 --> 00:15:43,180
And this is the code that is used in order to generate that.

00:15:45,420 --> 00:15:49,540
Rather than going through this in detail, I just want to highlight

00:15:49,540 --> 00:15:56,579
this idea that you can come up with interesting artifacts like that

00:15:56,579 --> 00:16:00,319
and embed it in part of -- in your overall larger design.

00:16:01,620 --> 00:16:04,460
It's very easy to do, once you figure out kind of

00:16:04,460 --> 00:16:11,860
the base of your object, to add these kinds of artifacts

00:16:11,860 --> 00:16:16,060
that give your design more flavor.

00:16:18,380 --> 00:16:23,540
And this is the resultant image that is generated from that.

00:16:23,540 --> 00:16:28,700
So, SVG makes it really easy to layer in new elements

00:16:28,700 --> 00:16:31,860
and add to the design without requiring you to change

00:16:31,860 --> 00:16:35,820
the overall structure of the SVG document itself.

00:16:35,820 --> 00:16:38,320
Coupled with Python, it's the perfect technology

00:16:38,320 --> 00:16:41,420
to express your laser-cuttable designs.

00:16:44,260 --> 00:16:46,380
Whoops.

00:16:46,380 --> 00:16:49,520
Alright. So, 3D printers.

00:16:49,520 --> 00:16:52,120
3D printers are devices that can build

00:16:52,120 --> 00:16:53,740
three-dimensional objects.

00:16:53,740 --> 00:16:55,580
They range in price and sophistication,

00:16:55,580 --> 00:16:58,220
but the most common 3D printers available

00:16:58,220 --> 00:17:00,640
are known as fused deposition models.

00:17:02,560 --> 00:17:05,640
These work by breaking down three-dimensional objects

00:17:05,640 --> 00:17:09,220
into 2D slices that, when stacked one on top of the other,

00:17:09,220 --> 00:17:12,740
will reconstruct the geometry of the three-dimensional object.

00:17:12,740 --> 00:17:16,100
FDM printers, specifically, work by extruding plastics

00:17:16,100 --> 00:17:18,620
at really high temperatures.

00:17:18,620 --> 00:17:21,840
But unlike laser cutters, 3D printers work in three axes

00:17:21,850 --> 00:17:23,360
instead of two.

00:17:23,360 --> 00:17:26,130
The X and Y axes are utilized by the printhead

00:17:26,130 --> 00:17:28,750
to deposit the material in a desired shape,

00:17:28,750 --> 00:17:31,360
and the Z axis is then used to advance the model

00:17:31,370 --> 00:17:32,990
to the next two-dimensional slice.

00:17:36,820 --> 00:17:40,300
This is a high-level design pipeline for 3D printers.

00:17:40,300 --> 00:17:43,360
Most 3D printing software consumes STL files

00:17:43,370 --> 00:17:46,680
and produce what is known as GCODE files.

00:17:46,680 --> 00:17:49,980
But STL files are not easy to generate by hand

00:17:49,980 --> 00:17:53,880
since they actually represent the three-dimensional object

00:17:53,880 --> 00:17:56,180
in a triangle mesh form.

00:17:56,180 --> 00:17:59,980
Personally, I don't think about my three-dimensional designs

00:17:59,980 --> 00:18:01,500
as a mesh of triangles.

00:18:01,500 --> 00:18:04,020
I like to think about them as solid objects.

00:18:05,740 --> 00:18:08,100
About five years ago my girlfriend and I purchased

00:18:08,100 --> 00:18:11,560
our first 3D printer, and we were so excited about it

00:18:11,560 --> 00:18:15,180
that we were obsessed about all the things

00:18:15,190 --> 00:18:16,960
that we were going to design and make on it.

00:18:16,960 --> 00:18:21,540
But I was immediately frustrated with the standard tools out there

00:18:21,549 --> 00:18:25,920
that people typically used to design CAD models for printing.

00:18:25,920 --> 00:18:29,200
You know, I'd spend hours in programs like SketchUp

00:18:29,200 --> 00:18:31,750
building up a complex design only to realize

00:18:31,750 --> 00:18:35,480
I needed to change something core to the model.

00:18:35,480 --> 00:18:37,860
Most of the design tools do not make it easy for you

00:18:37,860 --> 00:18:40,020
to make these kinds of drastic changes.

00:18:40,020 --> 00:18:42,640
It's kind of like painting a family portrait

00:18:42,640 --> 00:18:44,960
and realizing you left out your brother.

00:18:46,880 --> 00:18:51,040
So, there are more sophisticated 3D modelers out there,

00:18:51,040 --> 00:18:53,760
including some that are parametric.

00:18:53,760 --> 00:18:56,980
But most are expensive or only run in Windows

00:18:56,990 --> 00:19:01,700
or are difficult to learn, or typically all three.

00:19:01,700 --> 00:19:04,160
So I looked around to find a programmatic solution

00:19:04,169 --> 00:19:05,779
that I would find more comfortable

00:19:05,779 --> 00:19:08,719
and that's how I discovered something called OpenSCAD.

00:19:10,840 --> 00:19:15,340
OpenSCAD utilizes constructive solid geometry.

00:19:15,340 --> 00:19:19,000
The idea is to build your objects from two-dimensional

00:19:19,000 --> 00:19:23,620
and three-dimensional primitives such as cubes, cylinders, and spheres.

00:19:23,620 --> 00:19:26,680
You position these objects in space and then you define

00:19:26,680 --> 00:19:29,020
boolean operations between them.

00:19:29,020 --> 00:19:32,300
The most common boolean operation is union,

00:19:32,300 --> 00:19:35,720
to join two or more solids together as one.

00:19:35,720 --> 00:19:39,320
And then there is difference, which is used to subtract

00:19:39,320 --> 00:19:42,220
one or more solids from another.

00:19:42,220 --> 00:19:46,680
So for example, let's just take a drinking glass.

00:19:46,690 --> 00:19:49,670
We can construct it with just two cylinders.

00:19:51,620 --> 00:19:53,540
The first cylinder --

00:19:53,540 --> 00:19:56,480
sorry, the top got cut off but we'll see the code later.

00:19:56,480 --> 00:19:59,240
The first cylinder describes the outside surface

00:19:59,240 --> 00:20:03,020
and the second describes the empty volume inside.

00:20:03,020 --> 00:20:05,920
Using OpenSCAD, we would define the first cylinder

00:20:05,920 --> 00:20:09,220
with a second cylinder inside.

00:20:09,230 --> 00:20:11,929
The inside cylinder would then be offset

00:20:11,929 --> 00:20:18,100
in the Z axis, or the up axis, and would have a smaller radius

00:20:18,100 --> 00:20:19,640
than the outer cylinder.

00:20:21,160 --> 00:20:23,260
We would then subtract that inner cylinder

00:20:23,260 --> 00:20:26,400
from the outer cylinder to create that empty envelope.

00:20:26,400 --> 00:20:29,299
In order for this to work, we have to make sure

00:20:29,299 --> 00:20:35,159
that it leaves the floor of the glass but creates the mouth as well,

00:20:35,160 --> 00:20:36,740
and that's why we do the offset.

00:20:38,380 --> 00:20:42,660
So this is what your two cylinders

00:20:42,660 --> 00:20:44,780
would look like.

00:20:44,780 --> 00:20:48,840
And you can see in the third line of code,

00:20:48,840 --> 00:20:50,660
there's a translate operation.

00:20:50,660 --> 00:20:55,420
And that is what moves that inner cylinder up

00:20:55,420 --> 00:20:58,400
to create the floor of the glass and the mouth of the glass.

00:21:00,400 --> 00:21:05,320
Right now I have this as a union of two objects

00:21:05,320 --> 00:21:09,820
to highlight the fact that these two cylinders are inset,

00:21:09,820 --> 00:21:13,520
but by changing that top union to a difference,

00:21:13,520 --> 00:21:18,720
we then create the empty volume that we're aiming for.

00:21:20,600 --> 00:21:23,380
OpenSCAD does all of the hard, complicated math

00:21:23,380 --> 00:21:25,760
to calculate the mesh for these objects,

00:21:25,760 --> 00:21:29,000
freeing us up to think about how to construct our models

00:21:29,060 --> 00:21:30,500
with just primitive shapes.

00:21:33,640 --> 00:21:36,200
I think it's impressive to consider what we can build

00:21:36,210 --> 00:21:38,400
with just four lines of code.

00:21:38,400 --> 00:21:41,600
But the scripting language for OpenSCAD is relatively simple

00:21:41,600 --> 00:21:43,360
in and of itself, and doesn't really provide

00:21:43,360 --> 00:21:47,900
a lot of the features that we know and love from Python.

00:21:47,900 --> 00:21:52,460
But with the simplicity of OpenSCAD in our favor,

00:21:52,460 --> 00:21:55,920
we can easily then generate OpenSCAD from Python.

00:21:57,400 --> 00:22:02,660
So, for a more complicated example, we're going to consider a flower pot.

00:22:02,660 --> 00:22:05,220
Flower pots are similar to drinking glasses,

00:22:05,220 --> 00:22:07,480
but they also have a few distinct features.

00:22:07,480 --> 00:22:09,720
First, most flower pots are wider at the top

00:22:09,720 --> 00:22:11,940
and smaller at the bottom.

00:22:11,940 --> 00:22:15,120
Although we think about the shape as a cone, it's often described

00:22:15,120 --> 00:22:18,060
as a cylinder in OpenSCAD because you can define a cylinder

00:22:18,060 --> 00:22:20,860
with two different radiuses for each end.

00:22:22,060 --> 00:22:23,860
Second, they usually have a hole at the bottom

00:22:23,860 --> 00:22:25,940
to facilitate drainage.

00:22:25,940 --> 00:22:29,700
And finally, they often provide a lipped collar at the top

00:22:29,700 --> 00:22:32,880
to make it easy to hold and move the pot around.

00:22:34,760 --> 00:22:37,240
So now that we have a feel for OpenSCAD syntax,

00:22:37,240 --> 00:22:39,720
let's talk about how we can generate

00:22:39,720 --> 00:22:42,100
this design from Python.

00:22:42,100 --> 00:22:44,480
There are a few different Python libraries that allow you

00:22:44,480 --> 00:22:47,480
to build OpenSCAD syntax from Python,

00:22:47,480 --> 00:22:50,840
including a library that I've written called Python SCAD.

00:22:50,840 --> 00:22:53,360
Most of these libraries work in very similar ways,

00:22:53,360 --> 00:22:57,920
wrapping OpenSCAD definitions with Python classes.

00:22:57,920 --> 00:22:59,880
For my demo, I'll be using my library

00:22:59,880 --> 00:23:01,669
but you can accomplish the same thing

00:23:01,669 --> 00:23:04,089
with any of the other alternative libraries out there.

00:23:06,240 --> 00:23:09,080
So, most of my SCAD objects that I write in Python

00:23:09,080 --> 00:23:12,039
start out like this, with a series of parametric variables

00:23:12,039 --> 00:23:15,999
that help define the physical constraints of the object.

00:23:16,000 --> 00:23:19,260
I try to write a few top-level variables that are designed

00:23:19,260 --> 00:23:22,920
to be flexible, and then compute other variable values

00:23:22,920 --> 00:23:25,760
based on those initial values.

00:23:25,760 --> 00:23:28,200
In this example, many of the variables

00:23:28,200 --> 00:23:32,840
for the flower pot are derived from the flowerpot's overall height.

00:23:32,840 --> 00:23:36,340
This makes it easy to change the overall size of the flower pot

00:23:36,350 --> 00:23:40,360
without having to change each individual variable.

00:23:40,360 --> 00:23:42,740
You can also see that I have -- as an example,

00:23:42,740 --> 00:23:47,320
I have ratios in there that define, for example,

00:23:47,320 --> 00:23:50,680
the top radius versus the bottom radius.

00:23:50,680 --> 00:23:53,200
You know, I went around measuring flower pots around my house

00:23:53,200 --> 00:23:56,980
and found that it was typically about a .6 ratio.

00:23:59,760 --> 00:24:02,640
And along with things like the thickness

00:24:02,649 --> 00:24:05,330
or the wall thickness of the pot itself,

00:24:05,330 --> 00:24:07,590
because we have to calculate our offsets

00:24:07,590 --> 00:24:09,530
in order to do the subtraction.

00:24:12,060 --> 00:24:15,019
So this is all the code that is required

00:24:15,019 --> 00:24:16,500
to then produce that pot.

00:24:16,500 --> 00:24:22,360
It's, to be honest, much simpler than the cube for the laser cutter.

00:24:22,360 --> 00:24:24,160
It's pretty boring, actually.

00:24:24,160 --> 00:24:27,520
We start from the outside and add other cylinders

00:24:27,529 --> 00:24:30,280
to carve out the spaces we need.

00:24:30,280 --> 00:24:33,200
It's built entirely with the cylinder primitive

00:24:33,200 --> 00:24:36,220
along with unions and translations.

00:24:36,220 --> 00:24:38,680
Really the only hard part is imagining your model

00:24:38,680 --> 00:24:41,420
and then breaking it down into primitive solids.

00:24:41,420 --> 00:24:44,220
Once you've done this, building the design and code

00:24:44,220 --> 00:24:45,880
is incredibly straightforward.

00:24:48,600 --> 00:24:54,480
So, this is my printer at home building a 2.5 inch flower pot

00:24:54,480 --> 00:24:56,860
which is right here.

00:24:56,860 --> 00:25:01,000
It took about two hours to print, but one thing you'll notice

00:25:01,000 --> 00:25:02,500
is that it's printing an outer wall

00:25:02,500 --> 00:25:04,840
that's actually not part of the design.

00:25:04,840 --> 00:25:08,260
This wall is generated by the printer software

00:25:08,269 --> 00:25:10,940
and is known as a support material.

00:25:10,940 --> 00:25:14,179
The lip of the flowerpot overhangs in space

00:25:14,179 --> 00:25:16,860
and without that support material, the printer wouldn't be able

00:25:16,860 --> 00:25:19,000
to successfully print that overhang.

00:25:19,000 --> 00:25:22,280
But you can just tear it off once the print is done.

00:25:23,800 --> 00:25:27,580
And there's the finished result.

00:25:27,580 --> 00:25:35,040
So, now I'm going to talk about two projects I have done

00:25:35,040 --> 00:25:37,580
with laser cutters and 3D printers

00:25:37,580 --> 00:25:40,680
that are more complicated, and the code is available

00:25:40,680 --> 00:25:42,179
for these projects.

00:25:42,179 --> 00:25:45,519
But it's to kind of whet your appetite of,

00:25:45,520 --> 00:25:49,940
beyond these simple examples what else can you do with it?

00:25:49,940 --> 00:25:54,320
So to start off first is my snowflake generator.

00:25:59,280 --> 00:26:04,580
This project, my girlfriend and I started about four years ago.

00:26:04,580 --> 00:26:06,700
We were trying to figure out what to make our friends

00:26:06,700 --> 00:26:10,340
and family for the holidays.

00:26:10,340 --> 00:26:12,340
And Rachel found this amazing paper

00:26:12,340 --> 00:26:17,380
that describes a physical model to simulate the growth of snowflakes.

00:26:17,380 --> 00:26:20,620
We translated the math from this paper into Python code

00:26:20,620 --> 00:26:23,290
and proceeded to make personalized snowflakes

00:26:23,290 --> 00:26:24,890
for everyone on our gift list.

00:26:26,220 --> 00:26:30,120
The model works at the mesoscopic level,

00:26:30,120 --> 00:26:34,160
which is to say it models a collection of molecules,

00:26:34,160 --> 00:26:38,080
specifically water molecules as an undefined unit.

00:26:38,080 --> 00:26:43,040
And it starts off first by constructing a hexagonal grid.

00:26:45,080 --> 00:26:47,620
The grid is then populated with a homogeneous field

00:26:47,620 --> 00:26:49,240
of water molecules.

00:26:49,240 --> 00:26:51,960
And these water molecules can move from one neighboring cell

00:26:51,960 --> 00:26:56,400
to another and can switch between three defined states:

00:26:56,400 --> 00:26:59,740
vapor, boundary, or frozen.

00:26:59,740 --> 00:27:03,940
The boundary state is often used to describe water that is neither

00:27:03,940 --> 00:27:08,780
vaporous or frozen, but caught in between those two states.

00:27:08,780 --> 00:27:10,480
The initial field of water molecules

00:27:10,480 --> 00:27:14,860
are set to a vaporous state, except for the cell in the middle,

00:27:14,870 --> 00:27:17,360
which is initialized as a frozen state.

00:27:17,360 --> 00:27:19,280
And then, from there, the simulation runs

00:27:19,289 --> 00:27:21,069
and the snowflake begins to form.

00:27:23,220 --> 00:27:25,820
The model takes eight different parameters

00:27:25,820 --> 00:27:28,860
which dictate the behavior of these individual steps

00:27:28,860 --> 00:27:30,480
in the algorithm.

00:27:30,480 --> 00:27:35,200
So each cell does these individual calculations

00:27:35,200 --> 00:27:37,580
for its own state.

00:27:37,580 --> 00:27:44,960
It first figures out how the vapor of the cell should move.

00:27:44,960 --> 00:27:47,140
And then it figures out if some of it should freeze

00:27:47,140 --> 00:27:49,160
to the boundary vapor.

00:27:49,160 --> 00:27:52,880
And a portion of the frozen boundary cells then attach

00:27:52,880 --> 00:27:55,160
to the body of the snowflake.

00:27:55,160 --> 00:27:58,360
And then a certain portion of them melt off.

00:27:58,360 --> 00:28:02,740
And finally, as a parameter for noise, which I think

00:28:02,740 --> 00:28:06,029
is really beautiful, it adds just a little bit of randomness

00:28:06,029 --> 00:28:07,780
to the overall simulation.

00:28:07,780 --> 00:28:11,740
And what you end up are not perfectly symmetrical snowflakes,

00:28:11,740 --> 00:28:16,240
but snowflakes with slight defects with respect to their individual arms.

00:28:17,720 --> 00:28:22,500
So, from a grid perspective, as the simulation progresses,

00:28:22,500 --> 00:28:25,400
the snowflake crystal begins to grow out from its initial seed,

00:28:25,400 --> 00:28:27,720
so you can see the frozen state in the middle,

00:28:27,720 --> 00:28:30,820
and then the boundary seeds around it.

00:28:30,820 --> 00:28:35,460
And the program works like a cellular automata simulation.

00:28:35,460 --> 00:28:38,440
Each cell inspects its neighbors and calculates its changes

00:28:38,450 --> 00:28:41,480
based on the parameters

00:28:41,480 --> 00:28:43,440
But because there's hundreds of thousands of cells,

00:28:43,440 --> 00:28:46,480
the simulation is computationally intensive,

00:28:46,480 --> 00:28:48,860
taking hours to run.

00:28:48,860 --> 00:28:50,659
In order to generate the hundred snowflakes

00:28:50,659 --> 00:28:52,149
we made as a gift, actually,

00:28:52,149 --> 00:28:55,449
we generated all of our snowflakes in the cloud.

00:28:55,449 --> 00:28:59,049
[laughter]

00:28:59,049 --> 00:29:03,280
[applause]

00:29:03,280 --> 00:29:07,340
So, the result of this simulation is a complex bitmap.

00:29:07,340 --> 00:29:11,360
But instead of capturing red green blue intensities

00:29:11,370 --> 00:29:14,830
on a Cartesian grid, this bitmap stores the density

00:29:14,830 --> 00:29:18,780
of the frozen water molecules within a hexagonal grid.

00:29:18,780 --> 00:29:21,919
When the snowflake reaches a certain predetermined size,

00:29:21,919 --> 00:29:24,200
the simulation stops and the program proceeds

00:29:24,200 --> 00:29:26,860
to translate that snowflake into SVG files.

00:29:28,380 --> 00:29:31,419
Two SVG files are produced and merged.

00:29:31,419 --> 00:29:33,570
The first SVG file is a representation

00:29:33,570 --> 00:29:38,220
of the densest bands of frozen water molecules

00:29:38,220 --> 00:29:41,720
in the snowflake.

00:29:41,720 --> 00:29:48,920
That is where the most common abundance of water that froze,

00:29:48,920 --> 00:29:54,320
and there are these bands of density that you can see.

00:29:54,320 --> 00:29:55,860
And the second SVG actually defines

00:29:55,860 --> 00:29:57,340
the outline of the snowflake,

00:29:57,340 --> 00:30:00,660
and these two files are merged into a single SVG

00:30:00,660 --> 00:30:02,340
and then sent to the laser cutter.

00:30:04,100 --> 00:30:07,560
So, I have a kind of a cool video that just describes

00:30:07,560 --> 00:30:09,620
this whole process.

00:30:09,620 --> 00:30:14,900
One thing that really astounds me about this model is that

00:30:14,900 --> 00:30:20,580
it can generate just an amazing variety

00:30:20,580 --> 00:30:24,140
of different kinds of snowflakes.

00:30:24,140 --> 00:30:28,700
And very much with each not looking like the last.

00:30:28,700 --> 00:30:34,840
So this is -- I ran the simulation saving an image of the snowflake

00:30:34,850 --> 00:30:38,980
at every step, so this shows you the overall growth of it.

00:30:38,980 --> 00:30:43,240
You can see the black aura around it, and that's actually

00:30:43,240 --> 00:30:47,920
the depleted vapor that it's sucking into the body

00:30:47,920 --> 00:30:49,660
of the snowflake,

00:30:49,660 --> 00:30:52,720
while the gray area is still vaporous water.

00:30:58,160 --> 00:31:01,420
And here we are etching and cutting one of the snowflakes.

00:31:01,420 --> 00:31:04,220
So, you can see right here the laser cutter is in

00:31:04,220 --> 00:31:08,159
an etching mode, where it is just pulsing the laser

00:31:08,160 --> 00:31:10,919
and just ablating the surface of the plastic off

00:31:10,919 --> 00:31:13,299
to make a depression in the plastic

00:31:13,299 --> 00:31:15,099
but then not actually cut it.

00:31:15,100 --> 00:31:19,060
And then once it's done, it does the cutting step,

00:31:19,060 --> 00:31:21,680
which allows us to remove the snowflake.

00:31:21,680 --> 00:31:25,160
And again, I have brought examples of these guys,

00:31:25,160 --> 00:31:30,020
so if you want to, come take a peek at them after the talk.

00:31:32,180 --> 00:31:36,700
Alright, so the other example that I want to show you

00:31:36,700 --> 00:31:39,140
is something that I called Rockit.

00:31:39,140 --> 00:31:41,980
So, this is a model rocket construction kit.

00:31:43,900 --> 00:31:46,559
You know, this is kind of the first project I did

00:31:46,559 --> 00:31:50,710
with OpenSCAD and Python, and I wanted to make

00:31:50,710 --> 00:31:52,360
something functional, right?

00:31:52,360 --> 00:31:54,830
I wanted to be able to print something off my printer

00:31:54,830 --> 00:31:56,640
and have it actually do something.

00:31:56,640 --> 00:32:03,980
And so I made this model rocket generator that can design

00:32:03,980 --> 00:32:08,399
and print a range of different rockets

00:32:08,399 --> 00:32:10,079
and rocket types.

00:32:10,080 --> 00:32:14,220
So if you're not familiar with model rocketry,

00:32:14,220 --> 00:32:17,420
you should know that there are a range of different engine sizes.

00:32:17,420 --> 00:32:21,120
And these engines are made of solid propellant

00:32:21,120 --> 00:32:23,940
packed into a cardboard tube.

00:32:23,940 --> 00:32:27,100
The sizes of these engines vary in length and diameter,

00:32:27,100 --> 00:32:31,120
requiring different-sized engine holders to start a design.

00:32:33,320 --> 00:32:35,560
When you start a design, you first select an engine

00:32:35,570 --> 00:32:39,809
and then Rockit will calculate a bunch of different parameters

00:32:39,809 --> 00:32:43,329
for the rocket based on that engine size.

00:32:45,520 --> 00:32:48,960
Another neat feature of Rockit is that it uses

00:32:48,970 --> 00:32:52,910
these coupling sleeves that allow you to snap together

00:32:52,910 --> 00:32:54,779
the rocket like Legos.

00:32:56,020 --> 00:32:59,200
I mean, you can literally just print this off your printer,

00:32:59,200 --> 00:33:01,340
snap it together and then launch it.

00:33:01,340 --> 00:33:03,419
But I recommend using glue

00:33:03,419 --> 00:33:06,039
because it will probably come apart in flight.

00:33:06,040 --> 00:33:08,020
[laughter]

00:33:09,260 --> 00:33:15,399
And you can even print the base with that coupling sleeve

00:33:15,399 --> 00:33:18,999
and that will allow you to make multistage rockets.

00:33:21,400 --> 00:33:24,720
Rockit makes it very easy to change different aspects

00:33:24,720 --> 00:33:26,260
of your design.

00:33:26,260 --> 00:33:28,980
For example, you can swap in different kinds of nose cones,

00:33:28,980 --> 00:33:33,600
or you can add or remove fins, or one of my favorite features

00:33:33,600 --> 00:33:37,070
is to tilt the fins so that when the rocket is launched,

00:33:37,070 --> 00:33:40,360
it rifles up into the sky.

00:33:40,360 --> 00:33:42,240
But what I think is really fantastic about this

00:33:42,240 --> 00:33:45,110
is that you can print two very similar rocket designs

00:33:45,110 --> 00:33:49,169
with a slight tweak between them and they'll be very --

00:33:49,169 --> 00:33:50,829
it's a very reproducible process.

00:33:50,829 --> 00:33:57,691
So you can empirically evaluate how you have changed

00:33:57,700 --> 00:33:59,480
the performance of your design.

00:34:01,600 --> 00:34:06,580
So, my friend Adam videotaped this one launch,

00:34:06,580 --> 00:34:09,800
and it's unfortunately the only video footage I have,

00:34:09,800 --> 00:34:11,480
and it's a pretty disastrous launch.

00:34:13,000 --> 00:34:14,620
But it does work.

00:34:14,620 --> 00:34:16,920
I believe this is one of the ones that had spiral,

00:34:16,920 --> 00:34:18,560
so it spiraled up into the air.

00:34:20,900 --> 00:34:26,440
But the weight ratio to the engine size

00:34:26,450 --> 00:34:29,090
was not calibrated,

00:34:29,090 --> 00:34:32,090
and so it also then promptly took a nosedive.

00:34:36,060 --> 00:34:37,960
But that's the best part --

00:34:37,960 --> 00:34:40,520
I mean, these rockets, to be honest, they're not the most robust thing.

00:34:40,520 --> 00:34:44,720
I mean, it's plastic, and plastic doesn't like heat,

00:34:44,720 --> 00:34:48,020
and so you're likely to melt them, but I say who cares?

00:34:48,020 --> 00:34:49,840
Just go home and print some more, you know?

00:34:49,840 --> 00:34:52,620
You'll definitely at least get a few flights out of it.

00:34:54,820 --> 00:34:57,840
But yeah, I just -- what I think is just so neat about this

00:34:57,850 --> 00:34:59,610
is that you can print something off your printer

00:34:59,610 --> 00:35:03,110
and stuff a rocket engine in it and it will fly.

00:35:05,220 --> 00:35:08,500
Anyway, you may be asking yourself,

00:35:08,500 --> 00:35:11,960
how do I get access to these tools?

00:35:11,960 --> 00:35:16,680
So I realize that not everybody has these at their disposal.

00:35:16,680 --> 00:35:22,520
And in Boston, where I'm from, there are a number

00:35:22,520 --> 00:35:24,940
of local maker spaces that provide access

00:35:24,940 --> 00:35:27,420
to 3D printers and laser cutters.

00:35:27,420 --> 00:35:29,560
Some public libraries have also booted up

00:35:29,560 --> 00:35:33,680
their own maker spaces to provide access to these tools.

00:35:34,960 --> 00:35:37,760
And if you can't find anything local,

00:35:37,760 --> 00:35:40,860
you can always use popular internet-based service providers

00:35:40,860 --> 00:35:43,800
such as Ponoko or Shapeways.

00:35:43,800 --> 00:35:47,340
For example, I got all of my materials cut at Ponoko

00:35:47,340 --> 00:35:49,300
before I came to this talk.

00:35:50,800 --> 00:35:53,020
But the whole field is really rapidly changing

00:35:53,020 --> 00:35:55,120
and new tools are coming out every year.

00:35:55,120 --> 00:35:59,280
And as these tools advance, the total cost of ownership

00:35:59,280 --> 00:36:00,700
comes down in price.

00:36:03,500 --> 00:36:07,760
These are the relevant GitHub URLs for all the various software

00:36:07,770 --> 00:36:09,560
that I've written.

00:36:09,560 --> 00:36:14,480
The top one is a mirror of this talk.

00:36:14,480 --> 00:36:16,640
But you can also find my snowflake generator,

00:36:16,640 --> 00:36:18,110
the rocket generator,

00:36:18,110 --> 00:36:19,970
and the Python SCAD library there.

00:36:21,360 --> 00:36:24,180
And that's it, thank you very much.

00:36:24,180 --> 00:36:31,100
[applause]

00:36:35,560 --> 00:36:37,460
(moderator) So, a few minutes for questions.

00:36:37,460 --> 00:36:39,520
If you have any, come to the microphones please.

00:36:42,000 --> 00:36:43,560
(audience member) I'm curious as to why

00:36:43,560 --> 00:36:46,880
you didn't print your pot upside down.

00:36:48,040 --> 00:36:50,580
(Giles Hall) That's a great question.

00:36:50,580 --> 00:36:54,780
The reason is that, um --

00:36:54,780 --> 00:36:56,140
the --

00:36:57,900 --> 00:37:00,700
the flatness of the bottom of the pot

00:37:00,720 --> 00:37:04,610
would then be the overhang as opposed to the lip.

00:37:04,610 --> 00:37:07,700
To be honest, it's probably six of one, half-dozen of the other.

00:37:07,700 --> 00:37:10,020
But you would imagine that it would have to print

00:37:10,030 --> 00:37:13,100
a scaffolding into the center of the pot,

00:37:13,100 --> 00:37:17,300
and I find that to dig out support material is harder

00:37:17,300 --> 00:37:19,100
than just being able to rip it,

00:37:19,100 --> 00:37:21,580
so that's why I chose that orientation.

00:37:21,580 --> 00:37:23,020
(audience member) Thanks.

00:37:27,540 --> 00:37:29,020
(moderator) So if there are no more questions,

00:37:29,020 --> 00:37:30,700
let's thank the speaker again.

00:37:30,700 --> 00:37:37,360

YouTube URL: https://www.youtube.com/watch?v=UwL-ncEr-_I


