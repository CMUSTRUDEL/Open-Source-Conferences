Title: Dorian Pula - Pythons in A Container - Lessons Learned Dockerizing Python Micro-Services
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Dorian Pula

Micro-services and Docker are all the rage for developing scalable systems.  But what challenges will you face when developing and deploying Python apps using Docker to production? This talk goes into the real-life lessons learned from creating, deploying and scaling Dockerized Python applications. 

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:01,680 --> 00:00:03,120
(host) Thank you for coming along

00:00:03,120 --> 00:00:05,620
to this third after-lunch session here at PyCon.

00:00:05,620 --> 00:00:09,140
If you are looking for popular terms in the industry at the moment --

00:00:09,140 --> 00:00:12,800
containers, dockerizing things, microservices --

00:00:12,800 --> 00:00:15,260
you've definitely come to the wrong place -- right place.

00:00:15,260 --> 00:00:16,780
[audience laughs]

00:00:16,780 --> 00:00:18,520
You've come to the right place because our presenter, Dorian Pula,

00:00:18,520 --> 00:00:21,260
is going to be talking about all of these at the same time.

00:00:21,260 --> 00:00:22,780
Please make him welcome.

00:00:22,780 --> 00:00:30,060
[applause]

00:00:30,060 --> 00:00:32,300
(Dorian Pula) Thank you so very much.

00:00:32,300 --> 00:00:34,800
Just before we start, just a quick show of hands.

00:00:34,800 --> 00:00:37,540
How many people have played around with Docker?

00:00:37,540 --> 00:00:39,060
Oh wow, okay.

00:00:39,060 --> 00:00:40,580
Keep your hands up.

00:00:40,580 --> 00:00:45,140
How many of you guys use it for your development regularly?

00:00:45,140 --> 00:00:46,600
Okay.

00:00:46,600 --> 00:00:50,420
How about testing, like, testing continuous integration?

00:00:50,420 --> 00:00:52,140
Okay.

00:00:52,140 --> 00:00:55,840
And how many of you brave souls actually use it in production?

00:00:55,840 --> 00:00:57,180
Okay, wow.

00:00:57,180 --> 00:00:59,480
More than I expected.

00:00:59,480 --> 00:01:01,360
Awesome.

00:01:01,640 --> 00:01:06,640
So, my talk, Pythons in A Container, is essentially --

00:01:06,640 --> 00:01:10,840
it's about the lessons that we've learned

00:01:10,840 --> 00:01:13,620
when dockerizing Python microservices,

00:01:13,620 --> 00:01:17,299
and lessons that we actually learned the hard way because,

00:01:17,299 --> 00:01:19,059
you know, that's the best way to learn anything.

00:01:20,800 --> 00:01:23,280
So, quick little introduction.

00:01:23,280 --> 00:01:25,160
So, who am I?

00:01:25,160 --> 00:01:26,480
I'm Dorian. Dorian Pula.

00:01:26,490 --> 00:01:29,880
I'm a software development engineer at points,

00:01:29,880 --> 00:01:33,480
which means I get to work on developing an e-commerce platform

00:01:33,480 --> 00:01:35,120
for loyalty programs.

00:01:35,120 --> 00:01:37,760
So if you're buying, gifting, or transferring points

00:01:37,770 --> 00:01:41,600
from, like, an airline or hotel, you may be using our system,

00:01:41,600 --> 00:01:47,780
and that actually translates into a lot of Flask REST APIs and apps,

00:01:47,780 --> 00:01:50,120
and I get to work on all of them.

00:01:50,120 --> 00:01:53,120
And, a lot --

00:01:53,120 --> 00:01:55,500
basically, the deployment strategy that we have --

00:01:55,500 --> 00:01:58,939
development and deployment strategy that we have decided to take at points

00:01:58,939 --> 00:02:03,019
is actually using sort of a dockerized microservices approach,

00:02:03,020 --> 00:02:04,780
and I'll be talking about that today.

00:02:06,220 --> 00:02:08,280
I'm also an open-source contributor.

00:02:08,280 --> 00:02:12,220
I have my own CMS because, you know,

00:02:12,220 --> 00:02:13,940
we all need one more CMS.

00:02:15,340 --> 00:02:17,140
It's built in Flask, though, not in PHP.

00:02:18,940 --> 00:02:23,100
I've contributed to Fabric, Ansible, and a little bit of core Python,

00:02:23,100 --> 00:02:27,280
and because I have a sort of an unhealthy interest

00:02:27,280 --> 00:02:31,280
in working on deployment and infrastructure processes,

00:02:31,280 --> 00:02:37,420
I've also come up with a bunch of -- released a bunch of Ansible roles

00:02:37,420 --> 00:02:41,480
for NGINX, uWSGI, Node.js, and Supervisor.

00:02:42,800 --> 00:02:45,100
And, okay. So, let's jump right in.

00:02:45,100 --> 00:02:46,380
What is this talk about?

00:02:46,380 --> 00:02:50,130
So, as I said, this is a sort of the lessons that we learned

00:02:50,130 --> 00:02:55,500
when actually using Docker for Flask REST APIs and apps,

00:02:55,500 --> 00:02:58,000
but a lot of the same things will apply for, like,

00:02:58,000 --> 00:02:59,800
Django, Pyramid, or Bottle.

00:02:59,800 --> 00:03:02,800
Basically, anything that you can have a uWSGI application

00:03:02,810 --> 00:03:05,470
should basically work as well.

00:03:07,140 --> 00:03:09,080
I'm also going to be talking about some of, like,

00:03:09,080 --> 00:03:13,100
incorporating the tools that Docker and Docker Compose provides,

00:03:13,100 --> 00:03:16,900
which basically enable a better sort of DevOps workflow.

00:03:17,900 --> 00:03:21,200
And about also

00:03:21,200 --> 00:03:26,120
the usefulness of unlearning some of the sort of regular accepted patterns

00:03:26,120 --> 00:03:28,360
that we do in Python development,

00:03:28,360 --> 00:03:31,780
because some of them don't really apply as well

00:03:31,780 --> 00:03:33,220
when working with Docker

00:03:34,700 --> 00:03:36,920
Also, what is this talk not about?

00:03:36,920 --> 00:03:39,140
So, it's not an introduction

00:03:39,140 --> 00:03:43,760
to basic Docker or WSGI application development

00:03:43,760 --> 00:03:45,520
because there simply just wouldn't be enough time

00:03:45,530 --> 00:03:48,330
to do sort of a tutorial for both.

00:03:50,080 --> 00:03:52,240
I won't also be talking about Docker Machine,

00:03:52,240 --> 00:03:55,020
which is a really cool technology

00:03:55,020 --> 00:03:57,709
basically letting you link local Docker containers

00:03:57,709 --> 00:04:01,880
with sort of like remote AWS instances and things like that,

00:04:01,880 --> 00:04:03,740
but that's a subject in of its own.

00:04:03,740 --> 00:04:07,920
And I won't get into really advanced Docker wizardry.

00:04:07,920 --> 00:04:10,680
For that, I recommend actually going to DockerCon

00:04:10,680 --> 00:04:13,620
which is actually next week, and if you guys do you,

00:04:13,620 --> 00:04:16,760
you may actually bump into some my co-workers there.

00:04:16,760 --> 00:04:19,099
And finally, I'm not going to try to give you an exposÃ©

00:04:19,099 --> 00:04:21,999
on why you must or must not use Docker.

00:04:22,000 --> 00:04:24,060
Essentially, just use the right tool for the job

00:04:24,060 --> 00:04:26,760
and understand why you want to use it.

00:04:26,760 --> 00:04:28,240
However, I will say that Docker

00:04:28,240 --> 00:04:30,840
definitely provides some really nice things.

00:04:30,840 --> 00:04:34,380
So, let's talk about, like, why we want to actually use

00:04:34,390 --> 00:04:37,620
microservices and Docker in the first place.

00:04:37,620 --> 00:04:41,400
So, to illustrate things a little bit easier,

00:04:41,400 --> 00:04:44,520
let's take sort of a sample situation.

00:04:44,520 --> 00:04:46,819
So, imagine that all of us in this room

00:04:46,819 --> 00:04:50,859
are tasked with actually building a new application or service

00:04:50,860 --> 00:04:53,720
that would provide, like, a loyalty program experience

00:04:53,720 --> 00:04:57,240
for, like, sprint contributors at PyCon.

00:04:57,240 --> 00:04:58,800
Essentially what would happen

00:04:58,800 --> 00:05:03,029
is that you would earn points per commit or issue resolved

00:05:03,029 --> 00:05:07,710
and you'd be able to redeem them for essential sprint goods

00:05:07,710 --> 00:05:10,320
like coffee, Pop-Tarts, and Dogecoin,

00:05:10,320 --> 00:05:13,480
all the things that you need to get through a coding sprint.

00:05:14,840 --> 00:05:16,780
And we'll have the following dependencies --

00:05:16,780 --> 00:05:18,260
the following components.

00:05:18,260 --> 00:05:19,819
We'll have a REST API.

00:05:19,819 --> 00:05:23,439
We'll host the front-end application.

00:05:23,440 --> 00:05:28,380
We'll have some sort of service for handling the redemption of points,

00:05:28,380 --> 00:05:30,360
user and project registration and linking,

00:05:30,360 --> 00:05:32,300
and also a database.

00:05:32,300 --> 00:05:35,380
So if we were to break that up into sort of an architecture,

00:05:35,380 --> 00:05:37,560
so why would -- sorry.

00:05:37,560 --> 00:05:39,000
Why would you actually want to --

00:05:39,000 --> 00:05:40,560
if you were tasked out to build something like this,

00:05:40,560 --> 00:05:43,760
why would you want to use microservices in the first place?

00:05:43,760 --> 00:05:48,100
Well, if we went with a microservices architecture,

00:05:48,100 --> 00:05:50,419
we could divide this up into multiple services

00:05:50,419 --> 00:05:52,159
and have multiple teams working on this

00:05:52,160 --> 00:05:54,260
on different services concurrently,

00:05:54,260 --> 00:05:56,600
and using sort of just technologies that they're good at.

00:05:58,480 --> 00:06:00,020
So, some of the benefits

00:06:00,020 --> 00:06:01,640
of actually going with this type of architecture

00:06:01,640 --> 00:06:05,860
is that you'd get smaller, less complex codebases, right?

00:06:05,860 --> 00:06:07,860
Because each one of the services you're working on

00:06:07,860 --> 00:06:09,920
has only one specific purpose.

00:06:11,040 --> 00:06:14,580
You would enable greater independence between codebases and teams,

00:06:14,580 --> 00:06:19,060
so if one team decided to build an application in Flask,

00:06:19,060 --> 00:06:21,040
that doesn't mean that another team can't build it

00:06:21,040 --> 00:06:24,240
in Tornado, Twisted, Node.js, or rubio, or whatever.

00:06:25,800 --> 00:06:30,440
And essentially it would enable us for more sort of flexible scaling schemes,

00:06:30,440 --> 00:06:33,780
and not scaling just in terms of production,

00:06:33,780 --> 00:06:35,320
but also organizationally.

00:06:36,560 --> 00:06:38,800
Of course, with any technology there's always a --

00:06:38,800 --> 00:06:41,800
or any kind of architecture -- there will be drawbacks.

00:06:41,800 --> 00:06:43,879
One of them being

00:06:43,879 --> 00:06:48,309
a distributed codebase is harder to think about, harder to infer.

00:06:48,309 --> 00:06:51,920
It may contain implicit inter-service dependencies

00:06:51,920 --> 00:06:56,700
which are not easily recognizable just from looking at a codebase.

00:06:56,700 --> 00:06:58,940
And we would definitely have more complex

00:06:58,940 --> 00:07:01,919
orchestration, monitoring, provisioning schemes,

00:07:01,919 --> 00:07:03,419
just because we have more services.

00:07:04,380 --> 00:07:08,220
Now, if we were to break this out into sort of like an architectural diagram,

00:07:08,220 --> 00:07:11,240
we could divide up our application into, like,

00:07:11,240 --> 00:07:13,680
three different REST services.

00:07:13,680 --> 00:07:18,640
One for, like, the redeem service which would connect to external vendors,

00:07:18,640 --> 00:07:22,920
one for the user and project registration service,

00:07:22,920 --> 00:07:25,060
and one for the actual app and API.

00:07:25,060 --> 00:07:26,520
Now, you can build --

00:07:26,520 --> 00:07:30,080
you know, you could break it up into various different components,

00:07:30,080 --> 00:07:31,560
but in essence that's what you're doing.

00:07:31,560 --> 00:07:33,020
You're taking an application and breaking it up

00:07:33,020 --> 00:07:34,720
into multiple different parts.

00:07:36,320 --> 00:07:39,080
So why would we want to actually use Docker for this?

00:07:39,080 --> 00:07:43,940
Well, Docker uses containers, which are usually --

00:07:43,940 --> 00:07:48,520
which are lighter in memory and processing than virtual machines.

00:07:49,280 --> 00:07:54,520
And that's because containers act more like user space instances,

00:07:54,520 --> 00:07:56,680
rather than trying to emulate a full machine.

00:07:57,520 --> 00:08:00,480
So they will definitely take less memory and less space

00:08:00,490 --> 00:08:02,930
because you don't have to emulate a full physical machine.

00:08:04,440 --> 00:08:08,320
Docker also uses an interesting sort of cached immutable layered file system

00:08:08,320 --> 00:08:09,880
which I'll talk about a little bit later.

00:08:12,320 --> 00:08:15,260
Also, one of the really nice things about Docker and Docker Compose

00:08:15,260 --> 00:08:17,500
is just the tooling that it provides.

00:08:17,500 --> 00:08:20,800
Tooling for basically quickly spinning up

00:08:20,800 --> 00:08:22,700
various containers or environments.

00:08:22,700 --> 00:08:25,600
It is very easy to do that in Docker Compose.

00:08:25,600 --> 00:08:29,540
And also to actually create, share, and publish these images,

00:08:29,540 --> 00:08:31,779
so that you can collaborate across your teams

00:08:31,780 --> 00:08:33,280
and with other people.

00:08:34,120 --> 00:08:37,640
And ultimately it actually just provides a better sort of workflow.

00:08:37,640 --> 00:08:39,660
A more unified workflow

00:08:39,660 --> 00:08:42,040
that would replace a bunch of the other tooling

00:08:42,040 --> 00:08:43,360
that you would normally have.

00:08:43,360 --> 00:08:49,260
Namely, things like chroot, LXC, and Vagrant, and so on.

00:08:49,260 --> 00:08:51,860
So, how would we actually develop this?

00:08:51,860 --> 00:08:54,700
So, the first thing that we would do is that we'd probably,

00:08:54,710 --> 00:08:57,270
we want to specify all of our services in one place

00:08:57,270 --> 00:08:59,060
just so it's easier to reason about,

00:08:59,060 --> 00:09:02,580
and this is where docker-compose.yaml would come into place.

00:09:02,580 --> 00:09:04,600
So, we specify all our services

00:09:04,600 --> 00:09:08,060
and the environment variables, hostnames, its dependencies,

00:09:08,060 --> 00:09:11,700
all that wonderful stuff in one single place.

00:09:11,700 --> 00:09:16,240
And then, we would actually basically start up this entire service

00:09:16,240 --> 00:09:19,360
just by simply going docker-compose up.

00:09:19,360 --> 00:09:21,480
And then that will bring up all of your services

00:09:21,480 --> 00:09:24,960
and make sure that everything is nicely connected and working,

00:09:24,960 --> 00:09:27,180
assuming that you've got everything right the first time around.

00:09:27,180 --> 00:09:28,680
(laughs)

00:09:29,920 --> 00:09:33,720
And so, the Docker workflow is really nice because

00:09:33,720 --> 00:09:38,040
it ultimately replaces some of the more conventional workflows.

00:09:40,000 --> 00:09:41,540
Most of you guys have used Vagrant, right?

00:09:41,540 --> 00:09:47,660
In the past for working with, like, complex setups for various applications?

00:09:48,580 --> 00:09:51,820
Well, Docker and Docker Compose specifically,

00:09:51,820 --> 00:09:54,580
if you put them together they will actually sort of map

00:09:54,580 --> 00:09:57,620
one to one with the commands that Vagrant would have,

00:09:57,620 --> 00:09:59,840
with ones that you would have in Docker Compose.

00:09:59,840 --> 00:10:04,700
So things like vagrant up and vagrant ssh, and then run $app_command,

00:10:04,700 --> 00:10:06,260
it would basically --

00:10:08,180 --> 00:10:11,480
it translates into docker run $app_command.

00:10:12,840 --> 00:10:15,620
vagrant halt becomes docker stop.

00:10:15,620 --> 00:10:19,120
vagrant status becomes docker ps because, yes,

00:10:19,120 --> 00:10:24,260
just like as you would do ps in Unix or a Linux system,

00:10:24,260 --> 00:10:26,860
if you did ps even without the sole docker ps,

00:10:26,860 --> 00:10:29,920
you could actually see your Docker processes and the containers

00:10:29,920 --> 00:10:31,740
actually running on your system.

00:10:31,740 --> 00:10:34,640
docker ps just gives you a nice little abstraction for that.

00:10:36,520 --> 00:10:39,660
You would have vagrant provision which becomes docker build,

00:10:39,660 --> 00:10:42,760
so, building of your images and your containers.

00:10:42,760 --> 00:10:46,880
And vagrant destroy becomes docker stop and docker rm

00:10:46,880 --> 00:10:48,780
to remove the images.

00:10:49,780 --> 00:10:53,140
And just like with Vagrant, how Vagrant handles

00:10:53,140 --> 00:10:56,690
the creation of base images, you also have similar commands

00:10:56,690 --> 00:11:00,010
in the case of, like, docker images, docker rmi.

00:11:01,400 --> 00:11:03,060
Okay.

00:11:03,060 --> 00:11:06,220
So, one of the lessons that we --

00:11:06,220 --> 00:11:11,680
that people learn when actually working with Docker,

00:11:11,680 --> 00:11:18,100
is the importance of having good Docker images.

00:11:21,780 --> 00:11:24,700
Here you have an example of a very simple Docker file

00:11:24,700 --> 00:11:30,460
just for bootstrapping the Flask application using uWSGI.

00:11:33,640 --> 00:11:36,240
One of the things that you'll notice

00:11:36,240 --> 00:11:40,200
is that each one of those steps, the from, run, add commands,

00:11:40,200 --> 00:11:44,140
they all will create sort of new layers in a file system,

00:11:44,140 --> 00:11:47,380
because Docker uses sort of like a layered file system,

00:11:47,390 --> 00:11:49,380
which basically builds up your image,

00:11:49,380 --> 00:11:52,620
and then all the layers work together as a sort of a container.

00:11:55,220 --> 00:11:58,220
The only problem is that each layer takes up a lot of space, right?

00:11:58,220 --> 00:12:00,060
So what you want -- one of the things that we learned

00:12:00,060 --> 00:12:02,900
is that we want to minimize, like,

00:12:02,900 --> 00:12:06,000
the number of steps that have the separate run steps,

00:12:06,000 --> 00:12:12,720
because instead of having one layer just for updating, like, apt-get,

00:12:12,720 --> 00:12:14,380
and then one layer for installing,

00:12:14,380 --> 00:12:17,200
you really don't care about those two separate layers.

00:12:17,200 --> 00:12:19,180
You just want one layer that says,

00:12:19,180 --> 00:12:25,440
"Okay, bringing my system up to date and install all my dependencies," right?

00:12:26,200 --> 00:12:31,900
Rather -- so, in this case we only need to have one command,

00:12:31,900 --> 00:12:34,360
rather than multiple commands

00:12:34,360 --> 00:12:36,340
and having multiple layers for each command.

00:12:38,060 --> 00:12:40,620
And ultimately you also want to make sure

00:12:40,620 --> 00:12:42,680
that your layers are cacheable.

00:12:43,360 --> 00:12:44,860
So, what does that mean?

00:12:44,860 --> 00:12:49,080
Well, that means that Docker, when it's building up your images,

00:12:49,080 --> 00:12:52,080
it uses the cache layer from a previous step,

00:12:53,360 --> 00:12:56,060
and it will try to reuse that layer if it finds out

00:12:56,070 --> 00:12:59,980
that there hasn't been a previous step that has changed,

00:12:59,980 --> 00:13:04,120
or if a particular source file has changed.

00:13:04,120 --> 00:13:07,400
If they haven't, then it will try to reuse the layers,

00:13:07,400 --> 00:13:10,220
which means you get a faster setup time

00:13:10,220 --> 00:13:12,820
for actually doing -- when you're building your containers.

00:13:14,640 --> 00:13:19,680
And if you find yourself that you have a lot of, sort of, like,

00:13:19,680 --> 00:13:22,640
basic setup just to get an image up,

00:13:22,640 --> 00:13:25,140
you want to look at stuff like base images,

00:13:25,140 --> 00:13:29,720
especially if you have, let's say, three different microservices

00:13:29,720 --> 00:13:32,280
and they all use the same sort of setup,

00:13:32,280 --> 00:13:33,720
whether they be like,

00:13:33,720 --> 00:13:38,380
you have a common Flask or you need Node to be installed,

00:13:38,380 --> 00:13:43,440
it's good to actually include the base image, and maintain that.

00:13:43,440 --> 00:13:45,280
If you're interested in actually maintaining

00:13:45,280 --> 00:13:47,960
sort of base images that other people can use,

00:13:47,960 --> 00:13:50,840
then go check out the ONBUILD command

00:13:50,840 --> 00:13:54,860
and that will help you build sort of like dynamic base images.

00:13:55,860 --> 00:13:58,480
And finally, one thing that's --

00:14:00,920 --> 00:14:04,320
it's not critical but it's useful when you're actually developing,

00:14:04,320 --> 00:14:07,940
and that's exposing sort of the ports and the volume maps

00:14:07,940 --> 00:14:11,200
just so that you can document how your image is going to work.

00:14:12,160 --> 00:14:13,680
Alright.

00:14:13,680 --> 00:14:15,120
So that's -- okay.

00:14:15,120 --> 00:14:18,280
So, so far I've really only been talking about, like, you know,

00:14:18,280 --> 00:14:20,840
basic Docker stuff that applies to all things,

00:14:20,840 --> 00:14:22,340
to all different kind of systems.

00:14:22,340 --> 00:14:26,160
But what about something that's Python-specific and specific to WSGI apps?

00:14:27,160 --> 00:14:30,080
One of the lessons that we learned is web servers.

00:14:31,840 --> 00:14:38,440
Since you want to keep nice, concise Docker images,

00:14:38,440 --> 00:14:40,360
you don't want to include too much stuff,

00:14:40,360 --> 00:14:42,540
and one of the things that you don't really need to include

00:14:42,540 --> 00:14:46,060
is actually including a web server for your image.

00:14:46,060 --> 00:14:49,420
Instead you should probably look at using sort of an external proxy,

00:14:49,420 --> 00:14:54,400
so an external NGINX instance or having your own web service container.

00:14:56,680 --> 00:15:00,840
Rather, if you're just using --

00:15:00,840 --> 00:15:02,860
if you're just building WSGI applications,

00:15:02,860 --> 00:15:09,540
then just do the simplest thing and run a simple WSGI app server

00:15:09,550 --> 00:15:13,130
to actually host and run your Python application.

00:15:14,280 --> 00:15:18,320
Two of the more popular examples being uWSGI and Gunicorn for that.

00:15:19,720 --> 00:15:24,420
Another thing that is sort of like a common accepted practice

00:15:24,430 --> 00:15:28,260
when developing complex or just any kind of Python applications,

00:15:28,260 --> 00:15:30,540
is the use of virtualenvs.

00:15:30,540 --> 00:15:34,580
virtualenvs to separate what packages you install in one place,

00:15:34,580 --> 00:15:38,980
rather than having a whole system of very conflicting packages,

00:15:38,980 --> 00:15:40,600
you use virtualenvs.

00:15:40,600 --> 00:15:42,940
But when you're actually working with Docker,

00:15:42,940 --> 00:15:47,440
actually you don't want to use virtualenvs inside your Docker container

00:15:47,440 --> 00:15:49,540
because you don't need them.

00:15:49,540 --> 00:15:54,170
Ultimately, each container is an isolated system

00:15:54,170 --> 00:16:00,410
and so you don't have to manage having separate environments.

00:16:01,620 --> 00:16:06,740
So, just install directly into the system Python site packages.

00:16:07,820 --> 00:16:10,060
It'll also save you a lot of time and hassle.

00:16:11,380 --> 00:16:12,820
Alright.

00:16:14,300 --> 00:16:16,860
Since usually, you know, when you're developing something,

00:16:16,860 --> 00:16:18,880
you don't always get it right the first time around

00:16:18,880 --> 00:16:22,180
so you may have to, like, debug containers or services.

00:16:22,860 --> 00:16:27,280
Now, normally, if you have a Vagrant instance you would ssh into this thing,

00:16:27,280 --> 00:16:31,300
but you don't want to include an ssh daemon into your Docker image

00:16:31,300 --> 00:16:34,400
because it's just going to get too large.

00:16:34,400 --> 00:16:37,440
So, how do you debug a running container in that case?

00:16:38,280 --> 00:16:40,480
Well, you can actually use the Docker commands

00:16:40,490 --> 00:16:43,440
to actually run various commands on the service.

00:16:43,440 --> 00:16:44,860
So in this case,

00:16:44,860 --> 00:16:48,400
let's say we want to run bash on a running service.

00:16:48,400 --> 00:16:52,360
We could do basically going back to our Docker Compose example,

00:16:52,360 --> 00:16:57,160
use Docker Compose, execute the service name, and /bin/bash.

00:16:57,160 --> 00:17:00,680
And there's a similar command for just running on pure, plain Docker.

00:17:02,880 --> 00:17:08,000
Similarly, if you want to just inspect what an application's logs are doing,

00:17:08,000 --> 00:17:11,220
then you could do that using the Docker Compose logs

00:17:11,220 --> 00:17:13,180
and providing the service name.

00:17:13,180 --> 00:17:17,600
Now mind you, Docker only handles standard out and standard in --

00:17:17,600 --> 00:17:20,580
sorry, standard out and standard error output --

00:17:20,580 --> 00:17:23,720
so, you can't use any sort of complex logging.

00:17:23,720 --> 00:17:28,820
Just have your application log to standard out and standard error

00:17:28,820 --> 00:17:30,640
and you'll be good.

00:17:30,640 --> 00:17:32,440
Finally you want to actually inspect your --

00:17:32,440 --> 00:17:34,420
you may want to inspect your running computer setup.

00:17:35,200 --> 00:17:38,820
So, you might want to -- you can use the docker inspect command,

00:17:38,820 --> 00:17:41,580
and it gives you a whole bunch of output.

00:17:41,580 --> 00:17:44,220
Like, it tells you what exposed parts you have,

00:17:44,220 --> 00:17:45,840
what volume maps, and all that stuff.

00:17:47,040 --> 00:17:48,640
One of the gotchas I've run into

00:17:48,640 --> 00:17:54,840
is that you would have docker inspect produce an incredible amount of output,

00:17:54,840 --> 00:17:56,460
so sometimes you just want to scale it down

00:17:56,460 --> 00:17:59,440
and just look at just a particular aspect.

00:17:59,440 --> 00:18:05,280
So you can use the format command and provide a golang format string

00:18:05,280 --> 00:18:07,820
to actually see those things.

00:18:09,740 --> 00:18:11,700
And a couple minor tips

00:18:11,700 --> 00:18:14,820
when coming to persistent configuration and processes.

00:18:15,740 --> 00:18:17,640
So, one thing with volume maps.

00:18:18,960 --> 00:18:22,760
You want to use volume maps because you want to --

00:18:22,760 --> 00:18:28,800
because when you make a change to a Docker container

00:18:28,809 --> 00:18:31,760
and you destroy it, all of those changes are lost.

00:18:31,760 --> 00:18:35,940
So, there are two approaches of actually getting around that.

00:18:35,940 --> 00:18:39,680
One is to have a volume map so you have an external host folder

00:18:39,680 --> 00:18:43,440
where you can dump all of your stuff for your database and whatnot.

00:18:43,440 --> 00:18:45,720
Another pattern that's often used

00:18:45,720 --> 00:18:47,980
is actually to have a separate Docker data container

00:18:47,980 --> 00:18:49,460
that won't go away.

00:18:50,180 --> 00:18:52,000
In terms of configuration

00:18:52,010 --> 00:18:55,180
you should be using environment variables for configuration.

00:18:55,180 --> 00:18:58,480
Your services are very single purpose,

00:18:58,480 --> 00:19:00,500
so you should be able -- they should be simple enough

00:19:00,510 --> 00:19:02,990
that you can just use environment variables to set things up.

00:19:05,820 --> 00:19:08,420
You can volume map configs as well,

00:19:08,420 --> 00:19:09,960
but that may be a warning sign

00:19:09,960 --> 00:19:12,700
you just have a really large, complex configuration setup,

00:19:12,700 --> 00:19:14,620
and your configuration may need refactoring.

00:19:16,020 --> 00:19:19,840
If you find yourself that you need to run multiple processes,

00:19:19,840 --> 00:19:21,820
you can use stuff like supervisord or runit

00:19:21,830 --> 00:19:24,100
to control multiple processes.

00:19:24,100 --> 00:19:26,900
However, in a microservices approach,

00:19:26,900 --> 00:19:30,740
the best way is just to have one type of process that you're running.

00:19:30,740 --> 00:19:33,060
So you may want to -- if you find yourself

00:19:33,060 --> 00:19:35,400
coming up with complex supervisord setups,

00:19:35,400 --> 00:19:38,000
then you should probably consider refactoring your service

00:19:38,000 --> 00:19:39,540
into multiple containers instead.

00:19:42,220 --> 00:19:45,600
Docker and Docker Compose really make testing a lot easier.

00:19:47,640 --> 00:19:50,740
It will add consistency into your CI environments

00:19:50,750 --> 00:19:53,270
so you no longer have to try to build up --

00:19:53,270 --> 00:19:58,500
if you're working in a -- with a large build farm,

00:19:58,500 --> 00:20:00,780
you don't have to make sure that each agent in your build farm

00:20:00,780 --> 00:20:02,260
has the exact same environment,

00:20:02,260 --> 00:20:05,380
because it's really simple to set up a Docker host,

00:20:05,380 --> 00:20:08,200
and then you take your environment with you.

00:20:10,600 --> 00:20:15,240
Because, you basically, you control whatever you put into that container.

00:20:15,250 --> 00:20:18,860
So that means that you can have repeatable workflows

00:20:18,860 --> 00:20:20,420
and simpler test processes.

00:20:21,720 --> 00:20:25,440
And there are a lot of cloud CI options with Docker support out there now.

00:20:26,480 --> 00:20:29,980
Very quickly, when it comes to tooling,

00:20:29,980 --> 00:20:34,080
it's probably not a good idea for you to write your own Docker tooling.

00:20:34,080 --> 00:20:40,940
The Docker commands usually provide enough things for you to work with.

00:20:40,940 --> 00:20:46,130
Plus, the API, the internal API, has a habit of changing a lot

00:20:46,130 --> 00:20:47,830
from version to version.

00:20:47,830 --> 00:20:51,500
If you do decide to actually do something like that,

00:20:51,500 --> 00:20:53,360
then take a look at docker-py.

00:20:53,360 --> 00:20:57,460
That's a Python client library for working with Docker.

00:20:59,180 --> 00:21:01,500
But again, you probably don't want to do this.

00:21:03,020 --> 00:21:06,980
So, we've covered sort of, like, the best ways of doing development,

00:21:06,980 --> 00:21:09,300
so how do we actually deploy this out into prod

00:21:09,300 --> 00:21:10,620
and how do we scale this up?

00:21:12,260 --> 00:21:15,220
Well, if we go back to the architecture

00:21:15,220 --> 00:21:18,240
that we selected for application,

00:21:18,240 --> 00:21:19,780
this -- well,

00:21:19,780 --> 00:21:22,160
it's a nice way to understand what we're trying to build.

00:21:22,160 --> 00:21:25,000
This really won't scale in production.

00:21:25,440 --> 00:21:29,400
Rather, in production your setup will probably look like this, right?

00:21:29,400 --> 00:21:33,300
Where you have the multiple load balancers between services.

00:21:33,300 --> 00:21:35,380
You may have, like --

00:21:35,380 --> 00:21:40,420
you may find that the application or front end just takes more,

00:21:40,420 --> 00:21:44,300
needs to handle more traffic, so you'll be running multiple containers

00:21:44,309 --> 00:21:47,809
over multiple data centers and things like that.

00:21:48,800 --> 00:21:51,220
So when you look at -- there's a lot of moving parts

00:21:51,220 --> 00:21:53,780
that you have to to consider.

00:21:53,780 --> 00:21:56,400
And I'm not even putting in things like message giving,

00:21:56,400 --> 00:21:58,100
data warehousing, and all that stuff.

00:21:58,100 --> 00:22:00,600
This is just our basic application, right?

00:22:00,600 --> 00:22:02,820
This is how it could potentially look in prod.

00:22:04,820 --> 00:22:08,020
And, when you think about it, ultimately,

00:22:08,020 --> 00:22:09,980
what you're really doing is you're setting up

00:22:09,980 --> 00:22:14,440
a little private cloud of various microservices,

00:22:14,440 --> 00:22:17,640
and so there's a couple things that you have to think about

00:22:17,640 --> 00:22:19,160
when you're actually doing that.

00:22:19,160 --> 00:22:23,580
You have to start worrying about load balancing and network topology

00:22:23,590 --> 00:22:27,410
so you have to look at using stuff like HAProxy and NGINX.

00:22:28,200 --> 00:22:29,840
You also have to deal with provisioning

00:22:29,840 --> 00:22:34,820
because you may not dockerize all of your systems,

00:22:34,820 --> 00:22:37,220
but you still want to have an automated repeatable setup

00:22:37,220 --> 00:22:39,110
for non-dockerized systems.

00:22:39,120 --> 00:22:42,760
Or you may even want to just have your Docker containers

00:22:42,770 --> 00:22:45,730
controlled separately by a provisioning script.

00:22:46,800 --> 00:22:50,160
So you should probably look at stuff like Ansible, Puppet, & Salt.

00:22:51,480 --> 00:22:54,540
Please don't try to run your own little Fabric script

00:22:54,550 --> 00:22:57,370
to get everything working together.

00:22:57,370 --> 00:22:59,250
It's just -- there's too many things,

00:22:59,250 --> 00:23:01,730
too many edge cases that you might run into.

00:23:03,000 --> 00:23:06,160
You also have to think about the monitoring.

00:23:06,160 --> 00:23:09,700
You have to know, if you're dealing with multiple services,

00:23:09,700 --> 00:23:11,380
what is the health of your app,

00:23:11,380 --> 00:23:13,640
what is the behavior of your application,

00:23:13,640 --> 00:23:19,940
and the system resources on basically all the systems that you're managing.

00:23:19,940 --> 00:23:23,500
So, suddenly things like Nagios, Pingdom, and New Relic become important.

00:23:25,140 --> 00:23:29,720
And logging becomes crucial because in a microservices architecture

00:23:29,720 --> 00:23:31,900
you're going to have multiple log streams,

00:23:31,900 --> 00:23:35,180
and you're going to need to aggregate the various logs

00:23:35,190 --> 00:23:36,750
and correlate the events

00:23:36,750 --> 00:23:38,710
so that you can be able to debug

00:23:38,710 --> 00:23:40,640
when something happens --

00:23:40,640 --> 00:23:42,420
if something breaks between services,

00:23:42,420 --> 00:23:47,420
or if basically the bug is not in the first service

00:23:47,429 --> 00:23:50,179
that you have to deal with but in some lower service

00:23:50,180 --> 00:23:51,600
along the way.

00:23:51,600 --> 00:23:54,580
So, tools like Splunk and others come in very helpful.

00:23:56,220 --> 00:24:00,220
So yeah, essentially if you go down the dockerized microservice approach,

00:24:00,220 --> 00:24:03,860
you have to get into sort of some of the cloud structure,

00:24:03,860 --> 00:24:06,840
and managing cloud infrastructure is hard.

00:24:07,440 --> 00:24:09,860
You need a lot of tooling and a lot of automation

00:24:09,870 --> 00:24:12,400
to get all that stuff into place.

00:24:12,400 --> 00:24:15,309
And you really don't want to build out your own tools

00:24:15,309 --> 00:24:17,609
unless you want to support those tools to the end of time.

00:24:19,000 --> 00:24:20,380
Unless you're a cloud tech vendor,

00:24:20,380 --> 00:24:24,360
in which case you don't really need to be at this talk.

00:24:24,360 --> 00:24:27,220
You should be out building awesome cloud stuff

00:24:27,220 --> 00:24:28,700
for all of us to use.

00:24:29,740 --> 00:24:30,960
So, instead of building your own

00:24:30,960 --> 00:24:34,500
you should probably look at using other services.

00:24:34,500 --> 00:24:38,120
Use something like Docker Swarm or Kubernetes.

00:24:38,120 --> 00:24:41,340
The OpenStack guys have a pretty interesting

00:24:41,340 --> 00:24:44,000
compute platform called Magnum.

00:24:44,000 --> 00:24:45,640
And there's also the CoreOS guys,

00:24:45,640 --> 00:24:49,740
so if you want an alternative to Docker, there is CoreOS Fleet.

00:24:51,020 --> 00:24:52,540
Alright.

00:24:52,540 --> 00:24:54,080
So, to summarize the lessons that we've learned,

00:24:55,880 --> 00:24:58,880
microservices and Docker can really improve

00:24:58,880 --> 00:25:01,460
building and deploying a large complex system,

00:25:01,460 --> 00:25:03,160
but neither one is a cure-all, right?

00:25:03,160 --> 00:25:05,420
There's a lot of things you have to keep in mind.

00:25:06,580 --> 00:25:10,800
Also, good development and deployment processes matter,

00:25:10,800 --> 00:25:13,180
because ultimately if you have a good, smooth

00:25:13,180 --> 00:25:17,180
development employment process you get happy devs, right?

00:25:17,180 --> 00:25:19,200
Makes life so much easier.

00:25:19,200 --> 00:25:21,220
And Docker has a fairly decent workflow

00:25:21,220 --> 00:25:23,120
that you can use to shape those processes.

00:25:24,480 --> 00:25:25,940
And you should expect

00:25:25,940 --> 00:25:28,780
lots of additional infrastructure around microservices,

00:25:30,420 --> 00:25:33,400
which might make you tempted to actually build your own tooling,

00:25:33,400 --> 00:25:36,600
but unless you want to support it, don't do so.

00:25:36,600 --> 00:25:38,620
It's not a fun thing,

00:25:38,620 --> 00:25:43,179
and even a lot of the cloud tech vendors are actually pooling their resources

00:25:43,179 --> 00:25:46,459
just not to rebuild the same kind of infrastructure tooling.

00:25:47,740 --> 00:25:51,100
Use Docker containers to do the actual effective isolation

00:25:51,100 --> 00:25:53,680
so you don't have to worry about using stuff like virtualenvs

00:25:53,680 --> 00:25:56,600
or any other kind of virtual environment.

00:25:57,600 --> 00:26:01,860
And ultimately good app design enables all this.

00:26:01,860 --> 00:26:05,520
A good app design will be able to work nicely

00:26:05,530 --> 00:26:09,950
into a dockerized system without a lot of manual rework.

00:26:11,540 --> 00:26:13,040
Okay.

00:26:13,040 --> 00:26:15,300
So, there's a couple of interesting resources

00:26:15,300 --> 00:26:17,540
that are included in the slides.

00:26:17,540 --> 00:26:20,340
I want to thank Jared Kerim from Mozilla,

00:26:20,340 --> 00:26:25,880
who presented this really great Django Docker template.

00:26:25,880 --> 00:26:27,860
If you are working with Django applications

00:26:27,870 --> 00:26:30,320
and you want to deal with some Docker Compose,

00:26:30,320 --> 00:26:32,900
take a look at his example.

00:26:32,900 --> 00:26:36,260
Also, if you haven't read 12 Factor apps, the guidelines,

00:26:36,260 --> 00:26:38,420
you should definitely read them.

00:26:38,429 --> 00:26:39,969
They're really good.

00:26:40,880 --> 00:26:46,040
I also built a dockerized sort of workflow example

00:26:46,040 --> 00:26:48,510
for my CMS, Rookeries.

00:26:50,520 --> 00:26:52,320
It's on a branch, but if you're interested

00:26:52,320 --> 00:26:54,360
in sort of a simple setup for, like,

00:26:54,360 --> 00:26:58,140
building a Flask application with a database attached to it,

00:26:58,140 --> 00:26:59,780
then go ahead and look at that.

00:27:00,740 --> 00:27:03,860
Thank you so very much for everyone for your time and attention.

00:27:03,860 --> 00:27:07,500
[applause]

00:27:07,500 --> 00:27:09,520
Have any questions?

00:27:09,520 --> 00:27:11,380
(host) Okay, if you have questions,

00:27:11,380 --> 00:27:13,720
line up at either of these two microphones.

00:27:13,720 --> 00:27:14,980
If you are going to stay in the room

00:27:14,990 --> 00:27:17,120
or even if you're walking out right now,

00:27:17,120 --> 00:27:18,960
please keep yourself relatively quiet

00:27:18,960 --> 00:27:21,460
so we can still hear the questions being asked and answered.

00:27:21,460 --> 00:27:22,900
Thank you.

00:27:22,900 --> 00:27:24,420
Over here.

00:27:24,420 --> 00:27:25,920
(audience member) You mentioned there are

00:27:25,920 --> 00:27:27,460
a couple different options --

00:27:27,460 --> 00:27:28,920
(host) excuse me.

00:27:28,920 --> 00:27:30,400
Please audience,

00:27:30,400 --> 00:27:31,700
keep the chatter to a minimum while questions are being asked.

00:27:31,700 --> 00:27:34,240
This is really valuable to the audience at the moment.

00:27:34,240 --> 00:27:35,980
(audience member) You mentioned there are

00:27:35,980 --> 00:27:37,580
a couple different options for running containers in production.

00:27:37,580 --> 00:27:39,120
What do you use and how do you like it?

00:27:40,720 --> 00:27:42,640
(Dorian Pula) So, right now we're actually

00:27:42,640 --> 00:27:45,640
manually managing our containers.

00:27:45,640 --> 00:27:49,620
We're looking into using Kubernetes in the future.

00:27:49,620 --> 00:27:51,660
It's something that we're still experimenting with.

00:27:54,300 --> 00:27:55,800
(audience member) How do you, if it all,

00:27:55,800 --> 00:27:57,740
handle database migrations

00:27:57,740 --> 00:28:00,740
in an environment where using Docker for the database?

00:28:02,040 --> 00:28:05,320
(Dorian Pula) So, database migrations

00:28:05,320 --> 00:28:07,700
for the most part are going to be very similar.

00:28:07,700 --> 00:28:11,740
You still have that whole graduated rollout of databases.

00:28:13,340 --> 00:28:16,340
You might be able to migrate

00:28:16,340 --> 00:28:21,440
some of your datas running on a separate container,

00:28:21,440 --> 00:28:26,960
but otherwise it's a very similar setup.

00:28:26,960 --> 00:28:31,720
The same rules for a database deployment of a gradual rollout still apply regardless.

00:28:33,440 --> 00:28:34,940
(audience member) Hi. I was wondering

00:28:34,940 --> 00:28:37,300
if you have any experience with -- say you have three services,

00:28:37,300 --> 00:28:38,820
A, B, and C.

00:28:38,820 --> 00:28:40,560
A depends on B, B depends on C,

00:28:40,560 --> 00:28:44,620
and you want to test A and not have to spin up

00:28:44,620 --> 00:28:47,080
the entire world basically to test it.

00:28:47,080 --> 00:28:48,580
(Dorian Pula) Yeah.

00:28:48,580 --> 00:28:50,800
Well, you can spin up the entire world.

00:28:50,800 --> 00:28:55,000
It's a useful end-to-end test and sometimes we do that.

00:28:55,000 --> 00:28:58,220
But ultimately I would say

00:28:58,220 --> 00:29:03,820
that using sort of a stub server to mock out A service B --

00:29:03,820 --> 00:29:08,260
if all you want to do is just test service A in isolation

00:29:08,260 --> 00:29:11,700
and only its dependence on service B,

00:29:11,700 --> 00:29:14,440
then it's better to just have a stub server,

00:29:14,440 --> 00:29:18,660
something like mountebank seems to work very well

00:29:18,660 --> 00:29:20,480
for those kinds of cases, yes.

00:29:20,480 --> 00:29:21,960
(audience member) Thank you.

00:29:22,920 --> 00:29:24,400
(host) We have one more over here.

00:29:24,400 --> 00:29:26,200
(audience member) A couple things.

00:29:26,200 --> 00:29:27,740
One thing that you mentioned was

00:29:27,740 --> 00:29:31,140
that an alternative for Docker was CoreOS Fleet,

00:29:31,140 --> 00:29:35,860
but Fleet is CoreOS's initial offering for a scheduler.

00:29:35,860 --> 00:29:40,640
So it's kind of like in the same sort of, like, realm as Docker Swarm.

00:29:40,640 --> 00:29:44,980
But CoreOS's container engine is something called rkt,

00:29:44,980 --> 00:29:46,400
which is kind of amazing.

00:29:46,400 --> 00:29:49,260
That's the first one; The second one is that,

00:29:49,260 --> 00:29:50,760
I'm sorry to say but a lot of these --

00:29:50,760 --> 00:29:52,240
(host) Is your second question a question?

00:29:52,240 --> 00:29:54,000
(audience member) It's more of a observation.

00:29:54,000 --> 00:29:55,820
(host) Then can we have somebody else?

00:29:55,820 --> 00:29:57,380
Thank you very much.

00:29:57,380 --> 00:29:58,800
(Dorian Pula) Feel free to talk to me afterwards.

00:29:58,800 --> 00:30:00,320
(audience member) Sure.

00:30:00,320 --> 00:30:01,880
(host) This is time for questions.

00:30:01,880 --> 00:30:03,320
Thank you.

00:30:03,320 --> 00:30:05,360
Okay, and with that,

00:30:05,360 --> 00:30:07,680
everybody please thank Dorian for a fantastic talk.

00:30:07,680 --> 00:30:14,180
[applause]

00:30:14,180 --> 00:30:17,460
We also have a real person operating the open captions

00:30:17,460 --> 00:30:19,160
and we should probably give her thanks as well.

00:30:19,160 --> 00:30:20,680
Thank the stenographer, please.

00:30:20,680 --> 00:30:25,940

YouTube URL: https://www.youtube.com/watch?v=qT0dQ8S7jOg


