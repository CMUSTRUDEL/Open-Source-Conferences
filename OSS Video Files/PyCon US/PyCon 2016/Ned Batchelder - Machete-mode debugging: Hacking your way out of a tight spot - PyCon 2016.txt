Title: Ned Batchelder - Machete-mode debugging: Hacking your way out of a tight spot - PyCon 2016
Publication date: 2016-06-09
Playlist: PyCon 2016
Description: 
	Speaker: Ned Batchelder

When chasing mysterious bugs, it's helpful to use all the tools at your disposal.  We'll explore ways to use Python's dynamic tools to help track down the cause of head-scratching problems in large systems.  Tools include the inspect module, monkey-patching, trace functions, and the Python mechanisms at work behind them all. 

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:07,220 --> 00:00:10,240
(presenter) Hello, this is machete-mode debugging

00:00:10,240 --> 00:00:12,240
with Ned Batchelder.

00:00:12,240 --> 00:00:14,950
Ned has been programming Python since 1999.

00:00:14,950 --> 00:00:21,180
He is the maintainer of coverage.py, and he works for edx.org.

00:00:21,180 --> 00:00:24,060
Please give a warm welcome to Ned Batchelder.

00:00:24,060 --> 00:00:30,060
[applause]

00:00:31,100 --> 00:00:33,380
(Ned Batchelder) Hi everyone, thank you.

00:00:33,380 --> 00:00:35,700
Oops, hi everyone, thank you.

00:00:35,710 --> 00:00:37,940
As Jesse mentioned, my name is Ned Batchelder.

00:00:37,940 --> 00:00:42,560
You can find me on Twitter or IRC or GitHub as nedbat.

00:00:42,560 --> 00:00:44,600
If you want to follow along online,

00:00:44,610 --> 00:00:47,320
the slides for this talk and another version of the text

00:00:47,320 --> 00:00:49,460
are at that bit.ly URL.

00:00:49,460 --> 00:00:51,780
A very important announcement: today at 7 o'clock,

00:00:51,780 --> 00:00:54,280
we're going to be having a juggling Open Space,

00:00:54,289 --> 00:00:57,129
and I welcome any of you to come and juggle with us.

00:00:58,800 --> 00:01:02,320
[applause]

00:01:02,320 --> 00:01:04,640
OK, machete-mode debugging.

00:01:05,400 --> 00:01:11,520
Whoops, let's get that clickable.

00:01:11,520 --> 00:01:14,020
OK, so I've been programming,

00:01:14,020 --> 00:01:16,480
as Jesse mentioned, in Python, for a very long time.

00:01:16,490 --> 00:01:18,930
Not as long as some, but a very long time,

00:01:18,930 --> 00:01:21,260
and it can be a bit chaotic.

00:01:21,260 --> 00:01:23,370
I love Python for its dynamic nature.

00:01:23,370 --> 00:01:25,990
One of the things that fascinates me about Python

00:01:25,990 --> 00:01:30,460
is that in its deepest structure, it's really very unstructured

00:01:30,460 --> 00:01:34,020
and you can build lots of different structures for your program out of it.

00:01:34,020 --> 00:01:35,920
But through conventions and agreement,

00:01:35,920 --> 00:01:40,910
we tend to build programs in a way similar to more strict languages

00:01:40,910 --> 00:01:43,390
which lets us build very large systems that work together.

00:01:43,390 --> 00:01:45,190
We can reason about our code.

00:01:45,190 --> 00:01:48,650
But in its nature, Python can be chaotic.

00:01:48,650 --> 00:01:50,510
It has dynamic typing,

00:01:50,510 --> 00:01:52,560
which means that names can take on values

00:01:52,560 --> 00:01:54,500
of different types at different times

00:01:54,500 --> 00:01:56,760
and sometimes unpredictably.

00:01:56,770 --> 00:01:59,310
There's no access control on your objects,

00:01:59,310 --> 00:02:01,320
no protected, private, or final,

00:02:01,320 --> 00:02:04,480
which means that things can change from far away in your program

00:02:04,480 --> 00:02:06,240
that you didn't expect.

00:02:06,240 --> 00:02:08,080
All of the objects are on the heap.

00:02:08,080 --> 00:02:09,920
There is no stack allocation,

00:02:09,920 --> 00:02:12,420
so things can live for much longer than you expect.

00:02:13,940 --> 00:02:16,880
Fundamentally, nothing is off limits in Python, right?

00:02:16,880 --> 00:02:18,640
We get questions about,

00:02:18,640 --> 00:02:20,580
"How can I ensure that someone doesn't do blah?"

00:02:20,580 --> 00:02:24,980
And generally Python doesn't do, "You can't do," very well, right?

00:02:24,980 --> 00:02:27,600
Whatever you want to do in Python, you can do.

00:02:28,400 --> 00:02:30,340
This can cause problems.

00:02:30,340 --> 00:02:32,840
If you build large systems, you'll get yourself into trouble

00:02:32,850 --> 00:02:35,710
where you have to debug situations because the chaos

00:02:35,710 --> 00:02:38,510
got a little farther out of hand than you had intended.

00:02:40,220 --> 00:02:42,160
So, let's use that to our advantage.

00:02:42,170 --> 00:02:44,310
The chaos got us into this mess.

00:02:44,310 --> 00:02:46,370
We can use the chaos to get us out of this mess.

00:02:46,370 --> 00:02:49,450
That's the fundamental thesis of this talk, which is:

00:02:49,450 --> 00:02:52,880
Python is very dynamic but we can -- in a karate-like move,

00:02:52,880 --> 00:02:55,860
we can use that against our opponent (our own program),

00:02:55,860 --> 00:02:58,840
and we can take the upper hand by using that chaos

00:02:58,850 --> 00:03:00,600
to get the information we need

00:03:00,600 --> 00:03:03,060
to get ourselves out of a sticky situation.

00:03:03,069 --> 00:03:05,380
The bulk of this talk is going to be a discussion

00:03:05,380 --> 00:03:08,150
of actual problems from a real project.

00:03:08,150 --> 00:03:09,950
And I won't tell you what project it is,

00:03:09,950 --> 00:03:12,180
because I want you to like Open edX.

00:03:12,180 --> 00:03:15,540
[laughter]

00:03:15,540 --> 00:03:19,200
The point is that these are actual problems that happened at work.

00:03:19,200 --> 00:03:21,380
I wrote up blog posts about them.

00:03:21,380 --> 00:03:23,500
People tended to like those blog posts,

00:03:23,510 --> 00:03:26,290
and so I've collected together the experiences, here in this talk.

00:03:27,560 --> 00:03:30,480
The other thing is, I really want to emphasize this.

00:03:30,480 --> 00:03:34,020
The things I’m going to show you, you shouldn't use in real code.

00:03:34,020 --> 00:03:35,880
Most of the code that I’m going to show you

00:03:35,880 --> 00:03:39,300
has meant to be in your code base for about 10 minutes.

00:03:39,300 --> 00:03:42,090
You write this code, you get the information you need out of it,

00:03:42,090 --> 00:03:43,980
you fix the problem,

00:03:43,980 --> 00:03:46,140
and then you get rid of that awful thing that I’m about to show you.

00:03:46,140 --> 00:03:48,850
If I hear that any of you are using any of this in production later,

00:03:48,850 --> 00:03:50,860
I’m going to feel really, really bad,

00:03:50,860 --> 00:03:52,820
and I’m going to not like you personally anymore.

00:03:52,820 --> 00:03:54,340
[laughter]

00:03:54,340 --> 00:03:55,800
So, don't do it.

00:03:55,800 --> 00:03:57,660
All right, Case 1.

00:03:57,670 --> 00:03:59,630
We've got four cases to cover.

00:03:59,630 --> 00:04:02,120
Case 1: Double importing.

00:04:02,120 --> 00:04:04,400
The problem was that we had modules in our system

00:04:04,400 --> 00:04:07,160
that were being imported more than once.

00:04:07,160 --> 00:04:08,900
And if you know about importing modules,

00:04:08,900 --> 00:04:10,730
you know that one of the fundamental ideas is that

00:04:10,730 --> 00:04:13,010
when you import a module you always get the same object

00:04:13,010 --> 00:04:16,620
no matter how many times you import it, but that wasn't the case for us.

00:04:16,620 --> 00:04:19,850
And the classes in those modules were then defined twice,

00:04:19,850 --> 00:04:22,710
which means we had two classes floating around

00:04:22,710 --> 00:04:25,690
which had the same code in the same name.

00:04:25,690 --> 00:04:28,120
And usually that's not a problem, although sometimes it is,

00:04:28,129 --> 00:04:31,659
but modern -- recent versions of Django actually complain about this.

00:04:31,659 --> 00:04:33,400
They will detect that this is happening

00:04:33,400 --> 00:04:36,300
and head off the eventual problems by complaining about it

00:04:36,300 --> 00:04:38,360
and preventing your program from running.

00:04:38,360 --> 00:04:41,009
And when we upgraded our code from Django 1.4 to Django 1.8,

00:04:41,009 --> 00:04:43,749
we started to see those complaints and we had to fix them.

00:04:44,900 --> 00:04:47,980
Now, how can it be that modules are imported more than once?

00:04:47,980 --> 00:04:49,760
So, here's a quick refresher.

00:04:49,760 --> 00:04:51,600
Oh by the way, as I’m going through this,

00:04:51,600 --> 00:04:53,840
what I’m going to show you is what the problems were,

00:04:53,840 --> 00:04:56,879
what mechanisms in Python made those problems possible,

00:04:56,879 --> 00:04:59,939
and then what mechanisms helped us debug those problems and fix them.

00:04:59,939 --> 00:05:02,000
So, I’m hoping along the way, in addition to showing you

00:05:02,000 --> 00:05:04,350
versions of code that you're not supposed to use in production,

00:05:04,350 --> 00:05:06,439
that you'll come away with a deeper understanding

00:05:06,439 --> 00:05:08,800
of some of the mechanisms underlying Python

00:05:08,800 --> 00:05:11,200
that got us into the mess and got us out.

00:05:11,200 --> 00:05:13,540
So, here's a quick refresher of how modules work.

00:05:13,540 --> 00:05:17,819
When you import a module, you ask for a module name.

00:05:17,819 --> 00:05:19,619
The first thing that happens is

00:05:19,620 --> 00:05:23,280
there's a dictionary in the sys module called sys.modules which has, as its keys,

00:05:23,289 --> 00:05:25,289
the names of all the modules that have been imported

00:05:25,289 --> 00:05:27,529
and as its values, the actual module objects.

00:05:27,529 --> 00:05:30,710
So, when you import a module, the first thing that happens is

00:05:30,710 --> 00:05:33,740
it looks in that dictionary to see if the module has already been imported.

00:05:33,740 --> 00:05:36,189
And if it has been, it just returns it.

00:05:36,189 --> 00:05:39,680
These two lines of code are what make it so that when you import modules,

00:05:39,680 --> 00:05:41,920
first of all, it goes very fast the second time,

00:05:41,920 --> 00:05:44,240
and you get the same object back.

00:05:44,640 --> 00:05:46,540
And if it's not found,

00:05:46,540 --> 00:05:49,680
then for every directory in the thing called sys.path,

00:05:49,690 --> 00:05:51,599
which is a list of directory names,

00:05:51,599 --> 00:05:54,039
it looks to see if it can make a file name in that directory

00:05:54,039 --> 00:05:56,349
from the module name that exists, and if it does,

00:05:56,349 --> 00:05:59,940
then it's going to actually execute that file to get an object

00:05:59,940 --> 00:06:02,560
that's going to stuff the object back in the sys.modules under the key

00:06:02,560 --> 00:06:04,340
and return it to you.

00:06:04,340 --> 00:06:06,100
That's how import works the first time.

00:06:06,100 --> 00:06:07,999
And if after going through all that loops, it doesn't find anything,

00:06:07,999 --> 00:06:09,759
it raises an import error.

00:06:09,760 --> 00:06:12,940
So, this is a wildly simplified version of how importing modules actually works,

00:06:12,940 --> 00:06:16,520
but this is good enough to get you about 10 years into your career with Python.

00:06:16,520 --> 00:06:19,550
So, this is pretty much -- I mean, nothing bad

00:06:19,550 --> 00:06:21,520
about Brett and all the good work he’s done,

00:06:21,520 --> 00:06:24,180
but this is enough for you to understand how importing works.

00:06:24,180 --> 00:06:26,080
So, with all this machinery in place,

00:06:26,080 --> 00:06:28,560
how did we have modules being imported more than once, right?

00:06:28,560 --> 00:06:32,220
We've somehow broken this fundamental promise that Python gives us.

00:06:33,260 --> 00:06:35,120
And how are we gonna find it, most importantly?

00:06:35,130 --> 00:06:39,210
So, this is the code that I actually put into an actual file of Python.

00:06:39,210 --> 00:06:41,840
And it's a little bit dense for you to read right now,

00:06:41,840 --> 00:06:45,240
but the idea is to get across a couple of points.

00:06:45,240 --> 00:06:50,220
One is, I actually went to the models file that Django was complaining about,

00:06:50,229 --> 00:06:53,360
and I actually put real code right into the top of the module.

00:06:53,360 --> 00:06:55,160
Right?

00:06:55,160 --> 00:06:56,920
What you're not supposed to do.

00:06:56,920 --> 00:06:59,340
And the code I put in was gonna use a module in the standard library called inspect.

00:06:59,340 --> 00:07:01,280
Inspect is a really useful tool

00:07:01,280 --> 00:07:03,699
for understanding how your program is structured.

00:07:03,699 --> 00:07:07,299
It can tell you about the contents of modules and classes and methods.

00:07:08,120 --> 00:07:09,920
In this case what we’re going to use is --

00:07:09,920 --> 00:07:12,100
we're going to use a function in inspect called stack

00:07:12,110 --> 00:07:14,220
which gives you a list of tuples,

00:07:14,220 --> 00:07:17,039
every tuple representing one call frame in your stack,

00:07:17,039 --> 00:07:18,879
showing you who called you, and who called them,

00:07:18,879 --> 00:07:20,830
and who called them and so on.

00:07:20,830 --> 00:07:23,210
And in those tuples are information about the file name,

00:07:23,210 --> 00:07:25,100
the function name, and the line number

00:07:25,100 --> 00:07:28,599
so that you can essentially create a traceback of your current position.

00:07:29,760 --> 00:07:32,980
So, here, what I did is, right there in the module, when it gets imported,

00:07:32,990 --> 00:07:35,439
I’m going to open a file name, and I’m going to append to it.

00:07:35,439 --> 00:07:38,139
And what I’m going to append to it is that I’m importing the file.

00:07:38,140 --> 00:07:40,980
And then for all of those objects in the stack,

00:07:40,990 --> 00:07:43,460
I’m going to write out a nicely formatted line,

00:07:43,460 --> 00:07:45,220
and I’m going to write that line.

00:07:45,220 --> 00:07:47,940
And then I actually have the models, right?

00:07:47,949 --> 00:07:50,960
Because I've just dumped this code straight into a file

00:07:50,960 --> 00:07:54,039
that has nothing to do with what I’m trying to find out, right?

00:07:54,039 --> 00:07:56,169
I’m not -- this isn't a file about stack traces.

00:07:56,169 --> 00:07:57,960
It’s a file about Django models.

00:07:57,960 --> 00:08:00,089
But like I said, I’m doing things the wrong way,

00:08:00,089 --> 00:08:02,529
because I just need to get the information I need.

00:08:03,520 --> 00:08:05,399
And when I ran it, I got results like this.

00:08:05,399 --> 00:08:08,669
It told me that it was importing first/models.py

00:08:08,669 --> 00:08:10,710
and that was being imported from this place,

00:08:10,710 --> 00:08:13,150
and it also told me that it was importing that file again

00:08:13,150 --> 00:08:14,920
and that it was coming from this place.

00:08:14,920 --> 00:08:18,440
And so, now I had the two locations where the file was being imported.

00:08:18,440 --> 00:08:20,240
And both of these locations were importing it

00:08:20,240 --> 00:08:22,899
and somehow executing the file.

00:08:22,900 --> 00:08:26,480
And when I looked at those locations, I could see what the problem was.

00:08:26,480 --> 00:08:30,340
One of them said "import thing.apps.first.models,"

00:08:30,349 --> 00:08:33,089
and the other place said "import first.models."

00:08:34,600 --> 00:08:38,760
And the reason that's a problem is because in our directory tree --

00:08:38,770 --> 00:08:41,319
I've got a map of the directory tree here, twice,

00:08:41,319 --> 00:08:44,270
and the stars are the directories that are on sys.path.

00:08:44,270 --> 00:08:47,199
So, the first import in the project directory

00:08:47,199 --> 00:08:50,910
found a thing directory, with an apps directory, with a first directory, with the models.py

00:08:50,910 --> 00:08:53,209
so it could import thing.apps.first.models

00:08:53,209 --> 00:08:56,789
which put thing.apps.first.models into sys.modules.

00:08:58,060 --> 00:09:01,800
The second import, because apps was also on the system path,

00:09:01,800 --> 00:09:05,300
could find a first directory with a models in it.

00:09:05,300 --> 00:09:10,620
And because the keys are different, thing.apps.first.models versus first.models,

00:09:10,620 --> 00:09:12,860
the uniqueness check, didn't kick in, right?

00:09:13,460 --> 00:09:16,740
So, I had that little bit of code that printed out a stack trace

00:09:16,740 --> 00:09:20,899
that told me exactly what I needed to know: where are the two modules being imported?

00:09:20,899 --> 00:09:23,440
From there, I can get the clues that I needed to fix it.

00:09:23,440 --> 00:09:25,260
But the reason, by the way,

00:09:25,260 --> 00:09:27,420
that sys.path is like this is because in our code

00:09:27,420 --> 00:09:29,279
we literally have sys.path.append

00:09:29,279 --> 00:09:32,959
to append extra directories onto the system path.

00:09:32,960 --> 00:09:34,840
And this is one of the reasons

00:09:34,840 --> 00:09:38,060
you shouldn't go around appending things onto system path, right?

00:09:38,940 --> 00:09:43,120
So, that's Case 1 solved, and by the way, the solution to the double import:

00:09:43,120 --> 00:09:46,440
the best solution, frankly, would be to get rid of the sys.path.append.

00:09:46,440 --> 00:09:48,230
I’m looking forward to that in the future.

00:09:48,230 --> 00:09:49,550
That's going to be awesome.

00:09:49,550 --> 00:09:54,100
The way we actually fixed it was to at least make all the imports have the same form,

00:09:54,110 --> 00:09:56,870
so that everyone who was talking about the module

00:09:56,870 --> 00:10:00,450
talked about it in the same way and the uniqueness check would work.

00:10:02,080 --> 00:10:04,500
So, what have we learned from Case 1?

00:10:04,510 --> 00:10:07,079
First, we learned that import really runs code.

00:10:07,079 --> 00:10:11,219
Now, if you're coming from another language, perhaps with static typing,

00:10:11,220 --> 00:10:13,160
you may think of an import as being,

00:10:13,170 --> 00:10:16,220
"There are classes and functions to find somewhere.

00:10:16,220 --> 00:10:19,380
Go and find those definitions, and let me use them."

00:10:19,380 --> 00:10:21,820
And in a way that's true, but the way Python does that is,

00:10:21,829 --> 00:10:25,509
it really executes all the code in that .py file.

00:10:25,509 --> 00:10:27,349
Now if you happen to write your .py file

00:10:27,349 --> 00:10:30,160
to have nothing but imports, and class, and def statements,

00:10:30,170 --> 00:10:32,380
then all that's going to happen when you execute the code

00:10:32,380 --> 00:10:34,620
is to define classes and functions.

00:10:34,620 --> 00:10:36,410
But if you put in a "with" statement and "print" statements,

00:10:36,410 --> 00:10:40,000
and if you put in global mutation statements, they're all going to run.

00:10:40,000 --> 00:10:43,130
Importing doesn't have a special mode where it just looks for definitions.

00:10:43,130 --> 00:10:45,560
All it does is it executes all the code.

00:10:45,560 --> 00:10:47,400
And we used that to our advantage in this case

00:10:47,400 --> 00:10:50,460
because we wanted to print out a stack trace when we imported the code, right?

00:10:50,470 --> 00:10:53,490
The file was being imported twice, we wanted to get two stack traces.

00:10:53,490 --> 00:10:55,220
It worked great to just dump the stack trace

00:10:55,220 --> 00:10:58,520
at the top level of the module as part of the import.

00:10:58,520 --> 00:11:00,340
But you shouldn't do that in real code

00:11:00,340 --> 00:11:02,420
because it makes it very difficult to reason about the code

00:11:02,430 --> 00:11:05,379
because you have code that's executed one time when you import it

00:11:05,379 --> 00:11:07,399
but not all the other times that you import it.

00:11:07,399 --> 00:11:10,639
So, don't put code at the top level of the module,

00:11:10,640 --> 00:11:13,340
but understand that that's how Python does imports.

00:11:14,820 --> 00:11:17,500
The second lesson we learned about machete-mode debugging is

00:11:17,509 --> 00:11:19,709
we just hardcoded a bunch of stuff in there, right?

00:11:19,709 --> 00:11:23,800
I just said, "with open/temp/," you know, "my information.txt."

00:11:23,800 --> 00:11:25,660
You'd never put that in real code.

00:11:25,660 --> 00:11:27,640
But the code is only going to live for 10 minutes, who cares?

00:11:27,640 --> 00:11:30,400
Just write straight to the file, and be done with it.

00:11:31,800 --> 00:11:34,460
In this case, wrong is OK,

00:11:34,460 --> 00:11:36,760
because we just need to get the information.

00:11:37,760 --> 00:11:41,620
And in terms of a positive lesson, don't append to sys.path, right?

00:11:41,620 --> 00:11:43,400
Don't fiddle with your system path

00:11:43,400 --> 00:11:45,259
to try to make your imports convenient or something.

00:11:45,259 --> 00:11:47,209
Choose a disciplined way to do it.

00:11:47,209 --> 00:11:50,309
Keep everything straight, and you won't run into this kind of chaos.

00:11:52,300 --> 00:11:54,320
Case 2:

00:11:56,040 --> 00:11:58,040
Finding temp file creators

00:11:59,160 --> 00:12:03,360
The problem was that we had tests -- that's not the problem.

00:12:03,360 --> 00:12:06,480
[laughter]

00:12:06,480 --> 00:12:10,180
The problem was that we had tests that would make temp files like this

00:12:10,180 --> 00:12:13,340
using tempfile.mkdtemp -- in this case a temp directory.

00:12:14,260 --> 00:12:17,079
And some of them would add a cleanup so that the temp directory

00:12:17,079 --> 00:12:19,899
would be sure to get cleaned up at the end of the test,

00:12:19,899 --> 00:12:23,079
but some tests would make a temp directory and didn't clean it up.

00:12:23,080 --> 00:12:25,019
And so you’d run your whole test suite

00:12:25,019 --> 00:12:27,870
and you end up with 20 temp files and directories left behind,

00:12:27,870 --> 00:12:30,759
which isn't really a problem, but you know my OCD kicks in,

00:12:30,759 --> 00:12:33,079
"That seems kind of messy; we should clean that up."

00:12:34,440 --> 00:12:36,200
But how do we find them, right?

00:12:36,209 --> 00:12:37,880
There's lots of tests.

00:12:37,880 --> 00:12:40,700
I think in our test suite we have about 8,000 tests.

00:12:40,700 --> 00:12:43,019
I’m not gonna be able to grep the whole test suite

00:12:43,019 --> 00:12:46,179
and find the places where it gets created but not cleaned up.

00:12:46,180 --> 00:12:48,240
Sometimes the cleanup is far away,

00:12:48,240 --> 00:12:50,760
sometimes it's a helper function that’s called from lots of places.

00:12:50,770 --> 00:12:52,570
It's just too hard.

00:12:52,570 --> 00:12:54,420
That's another underlying current here, which is --

00:12:54,420 --> 00:12:57,399
other languages have really great static analysis tools,

00:12:57,399 --> 00:12:59,389
and that's something that Python has a difficulty with

00:12:59,389 --> 00:13:01,280
because of its dynamic nature.

00:13:01,280 --> 00:13:03,259
So, we'll just skip the static analysis.

00:13:03,259 --> 00:13:07,999
And notice here I’m upgrading grep to static analysis, which sounds fancy...

00:13:08,000 --> 00:13:09,260
[laughter]

00:13:09,260 --> 00:13:11,200
But that's fundamentally what it is.

00:13:11,200 --> 00:13:13,300
It's a tool for looking at your source code without running it

00:13:13,310 --> 00:13:15,120
and trying to understand it.

00:13:15,120 --> 00:13:16,920
That's what static analysis is about.

00:13:16,920 --> 00:13:18,760
What I’m doing here is all dynamic analysis.

00:13:18,769 --> 00:13:20,949
Let's put something in the program that when you run it

00:13:20,949 --> 00:13:23,000
will tell you what you need to know.

00:13:23,760 --> 00:13:25,500
So, the temp files aren't getting cleaned up,

00:13:25,500 --> 00:13:27,580
and there's too many to eyeball.

00:13:27,580 --> 00:13:29,340
What I wanted to do is --

00:13:29,340 --> 00:13:31,700
I wanted to put some information in the file itself, right?

00:13:31,700 --> 00:13:33,560
After all, the whole problem here is

00:13:33,570 --> 00:13:37,010
that there's something left behind when something goes wrong.

00:13:37,010 --> 00:13:39,250
What if I could just use that thing left behind

00:13:39,250 --> 00:13:41,279
to give me the information I need, right?

00:13:41,279 --> 00:13:43,670
Unfortunately, I can't write into the temp file itself.

00:13:43,670 --> 00:13:45,960
The contents of the file are important to the test.

00:13:45,960 --> 00:13:48,840
They’ll fail if I just start writing random junk into it.

00:13:48,840 --> 00:13:50,620
But the interesting thing about temp files is

00:13:50,620 --> 00:13:52,420
that no one cares what they're called.

00:13:52,420 --> 00:13:55,040
So, we're going to put the information into the file name.

00:13:57,520 --> 00:14:00,660
And the way we’re going to do that is we're going to monkeypatch the standard library.

00:14:00,660 --> 00:14:05,279
So, monkeypatching is a technique where you write a function

00:14:05,279 --> 00:14:08,670
and you stuff it in place of some preexisting function.

00:14:08,670 --> 00:14:11,800
So, in this case, we're going to import a temp file.

00:14:11,800 --> 00:14:14,220
We're going to write a function called "my sneaky function,"

00:14:14,220 --> 00:14:17,540
and we're just going to assign it to tempfile.mkdtemp.

00:14:18,820 --> 00:14:21,420
And what that means is that the unsuspecting product code

00:14:21,430 --> 00:14:24,970
is going to import tempfile and call tempfile.mkdtemp,

00:14:24,970 --> 00:14:26,840
but now that's referring to "my function."

00:14:26,840 --> 00:14:29,759
So, when the product code tries to make a temp directory

00:14:29,759 --> 00:14:31,539
it's actually going to be calling "my function."

00:14:31,540 --> 00:14:33,380
This is called monkeypatching.

00:14:34,380 --> 00:14:37,220
And the key idea from Python that makes this possible

00:14:37,220 --> 00:14:39,000
is that any name can be reassigned.

00:14:39,000 --> 00:14:40,860
It feels a little bit weird, you know?

00:14:40,860 --> 00:14:42,860
The standard library's this thing that’s been handed down to us

00:14:42,860 --> 00:14:44,880
on engraved tablets, right?

00:14:44,880 --> 00:14:47,740
It's the foundation upon which we build our programs.

00:14:47,740 --> 00:14:49,899
It’s something we’ve come to count on.

00:14:49,899 --> 00:14:52,740
But it's just a Python module with attributes like anything else,

00:14:52,740 --> 00:14:54,520
and they can all be reassigned,

00:14:54,520 --> 00:14:56,540
so, we can just go ahead and reassign it when we want to.

00:14:58,060 --> 00:15:01,240
Of all the things I’m telling you not to do in production,

00:15:01,240 --> 00:15:03,220
definitely don't do this one

00:15:03,220 --> 00:15:05,220
[laughter]

00:15:06,720 --> 00:15:08,620
Now, what are we supposed to monkeypatch?

00:15:08,620 --> 00:15:11,080
Well here's where we can just read the source, right?

00:15:11,080 --> 00:15:16,300
Tempfile.py is a file on your disk in the standard library.

00:15:16,310 --> 00:15:18,430
You can go and find it and you can open it in your editor

00:15:18,430 --> 00:15:20,240
and you can read it, right?

00:15:20,240 --> 00:15:22,230
If you look in the temp file module,

00:15:22,230 --> 00:15:24,759
there are actually a half dozen or so different functions

00:15:24,759 --> 00:15:28,059
for making temporary things in different ways.

00:15:28,060 --> 00:15:29,920
We had some directories and some files,

00:15:29,930 --> 00:15:32,850
so we actually needed to deal with a number of those.

00:15:32,850 --> 00:15:35,600
And by the way, we only wanted to tweak the file names.

00:15:35,610 --> 00:15:37,600
There's a bunch of machinery in creating temp files

00:15:37,600 --> 00:15:39,440
that we didn't want to interfere with.

00:15:39,440 --> 00:15:41,240
We just wanted to give them new names.

00:15:41,240 --> 00:15:43,540
It turns out that there is a helper function inside tempfile

00:15:43,540 --> 00:15:45,829
called get_candidate_names.

00:15:45,829 --> 00:15:48,779
And the way the temporary functions work is,

00:15:48,779 --> 00:15:50,779
they use get_candidate_names

00:15:50,780 --> 00:15:56,459
to produce a series of those classic tempfile junky randomy things

00:15:56,459 --> 00:15:59,509
and then they use those names to find a file that doesn't exist yet

00:15:59,509 --> 00:16:01,940
and then they go ahead and make their file, and so this is perfect.

00:16:01,940 --> 00:16:04,110
Get_candidate_names solves both of our problems.

00:16:04,110 --> 00:16:06,069
It's used by all of the temporary-making things

00:16:06,069 --> 00:16:08,490
and it's only where the name comes from.

00:16:08,490 --> 00:16:12,030
So, if we monkeypatch get_candidate_names, it will do exactly what we want.

00:16:14,200 --> 00:16:16,660
But the other trick with monkeypatching is that you have to do it

00:16:16,660 --> 00:16:19,060
before the function gets called, right?

00:16:19,069 --> 00:16:20,889
If the function gets called before you monkeypatch

00:16:20,889 --> 00:16:22,640
then your code is way too late.

00:16:22,640 --> 00:16:24,240
It's not gonna work.

00:16:24,240 --> 00:16:26,960
What we'd like to have is a feature in Python that says,

00:16:26,970 --> 00:16:28,620
"Before you run the program,

00:16:28,620 --> 00:16:31,420
"run this little piece of code so I can monkeypatch first."

00:16:31,430 --> 00:16:33,280
Python doesn't have a switch like that.

00:16:33,280 --> 00:16:35,920
Perl has a switch that says, "Use this prologue before the main program."

00:16:35,920 --> 00:16:41,149
Python doesn't have that feature, but it has a thing called .pth files.

00:16:41,149 --> 00:16:45,670
Now path files are essentially symbolic links in your site packages directory.

00:16:45,670 --> 00:16:48,250
And you can go and look; you probably have a few of them.

00:16:49,520 --> 00:16:53,020
And they do this very odd thing which is when Python starts up,

00:16:53,029 --> 00:16:57,240
it finds all the .pth files, and it looks at every line in the .pth file.

00:16:57,240 --> 00:17:02,559
And literally, if the line starts with "import (space)" it executes the line.

00:17:02,559 --> 00:17:04,319
[audience chuckles]

00:17:04,320 --> 00:17:06,900
I’m not, I didn't -- OK look, I’m showing you lots of weird code.

00:17:06,900 --> 00:17:08,740
I didn't write this, OK?

00:17:08,740 --> 00:17:10,140
[laughter]

00:17:10,140 --> 00:17:13,720
This is really in there and every time you run Python, this is happening.

00:17:13,720 --> 00:17:18,070
And if it doesn't start with "import" then it just appends the line to sys.path.

00:17:18,070 --> 00:17:20,720
So, this is how sys.path gets really, really long

00:17:20,720 --> 00:17:23,080
and points to all of your imported modules.

00:17:23,080 --> 00:17:28,440
So, if you create, sorry -- if you create a 000.pth file

00:17:28,440 --> 00:17:32,330
in your site packages directory that just imports "first thing,"

00:17:32,330 --> 00:17:35,040
then you can write a first_thing.py

00:17:35,040 --> 00:17:38,180
and it will run before any other code in your Python process.

00:17:39,740 --> 00:17:41,840
And what we're going to do here in first_thing.py, again, is,

00:17:41,850 --> 00:17:46,410
I’m going to use inspect.stack to get information.

00:17:46,410 --> 00:17:49,020
First, I’m going to save off the original value of get_candidate_names

00:17:49,020 --> 00:17:51,140
because I actually like that randomy stuff.

00:17:51,140 --> 00:17:52,560
That's still important to keep,

00:17:52,560 --> 00:17:55,220
so I’m going to keep that function as real_get_candidate_names.

00:17:55,220 --> 00:17:56,660
And here again, functions --

00:17:56,660 --> 00:18:00,560
Python’s functions as first-order objects, first-class objects,

00:18:00,560 --> 00:18:04,140
lets us just hold that function with a new name, and we can use it later.

00:18:04,140 --> 00:18:06,760
Then I’m going to make my own get_candidate_names

00:18:06,760 --> 00:18:10,900
and I’m gonna take inspect.stack and join it together in such a way

00:18:10,910 --> 00:18:13,350
that I get a really long string that's still kind of readable

00:18:13,350 --> 00:18:16,030
so that I can see who's been calling me.

00:18:16,030 --> 00:18:20,500
And then I’m going to get the actual randomness from real -- from get_candidate_names

00:18:20,500 --> 00:18:22,530
and I’m going to yield my own sequence, right?

00:18:22,530 --> 00:18:24,330
And then I’m going to do the real monkeypatch.

00:18:24,330 --> 00:18:26,190
Again, I know this code is really dense.

00:18:26,190 --> 00:18:28,070
It's all online, you can go and study it later.

00:18:28,070 --> 00:18:31,070
But I’m trying to get the point across that we’re monkeypatching the standard library,

00:18:31,070 --> 00:18:33,910
and as a result, we get tempfile names that now look like this.

00:18:33,910 --> 00:18:39,470
And in this file, you can see that at case.py, Line 53 called case.py Line 78

00:18:39,470 --> 00:18:42,240
which called test_import_export Line 289

00:18:42,240 --> 00:18:45,560
So, I can go into test_import_export.py Line 289

00:18:45,560 --> 00:18:47,760
and see there's a mkdtemp right there.

00:18:47,760 --> 00:18:49,500
And that's when it's not getting cleaned up.

00:18:49,500 --> 00:18:52,450
So, I can fix that line and then go on to the next one

00:18:52,450 --> 00:18:56,750
where test_video 143 is calling tempfile line 455

00:18:56,750 --> 00:18:58,990
and etc., etc., etc.

00:19:00,500 --> 00:19:02,560
So, what did we learn?

00:19:03,000 --> 00:19:05,080
One, this is often overlooked.

00:19:05,080 --> 00:19:07,040
Forget monkeypatching for a second.

00:19:07,040 --> 00:19:11,180
You can just go and read the standard library, and sometimes that's all you need, right?

00:19:11,190 --> 00:19:13,080
The very fact that Python is open source --

00:19:13,080 --> 00:19:15,590
and forget the contribution, and the license, and all that stuff.

00:19:15,590 --> 00:19:17,570
The source is on your system.

00:19:17,570 --> 00:19:21,720
You don't even have to go to hg.cpython.org to dig it up.

00:19:21,720 --> 00:19:25,220
The standard library is all on your disk as Python source code

00:19:25,220 --> 00:19:28,450
and you can read it to figure out what it does.

00:19:28,450 --> 00:19:30,300
It's also patchable, so we can go in there

00:19:30,300 --> 00:19:33,160
and affect its behavior where we need to to get information.

00:19:34,490 --> 00:19:37,860
And for this kind of debugging, you should use whatever you can.

00:19:37,860 --> 00:19:40,280
Whatever you can touch and change, use it, it's fine.

00:19:40,280 --> 00:19:42,200
That code is only going to live for 10 minutes.

00:19:42,200 --> 00:19:45,380
You only have to feel really, really bad about yourself for 10 minutes

00:19:45,380 --> 00:19:47,820
and then you'll have the solution and everyone will think you're a hero

00:19:47,820 --> 00:19:51,500
and you don't have to explain to them how dirty your hands got in the process

00:19:51,500 --> 00:19:53,600
[laughter]

00:19:54,000 --> 00:19:55,800
And by the way, do use addCleanup.

00:19:55,800 --> 00:19:59,020
So, if you're using the unittest library and you're used to setups and teardowns,

00:19:59,020 --> 00:20:00,860
addCleanup is a much nicer way

00:20:00,860 --> 00:20:04,040
to clean up the behavior of your setup function than a teardown is,

00:20:04,040 --> 00:20:06,420
so look into that.

00:20:06,420 --> 00:20:08,420
OK, Case 3.

00:20:08,430 --> 00:20:10,570
Who is changing sys.path?

00:20:13,320 --> 00:20:16,480
The problem we had was that sys.path

00:20:16,480 --> 00:20:18,480
had an extra directory in it that we didn't expect,

00:20:18,490 --> 00:20:20,270
and in this case, it actually caused a problem

00:20:20,270 --> 00:20:24,210
because of some naming collisions where when we tried to import a certain block.py

00:20:24,210 --> 00:20:29,060
it was finding the wrong one, and we couldn't understand why that was.

00:20:29,060 --> 00:20:31,580
And again, grep couldn't find sys.path.

00:20:31,580 --> 00:20:35,220
And here, of course, I mean, as you remember from Case 1,

00:20:35,220 --> 00:20:37,730
we were doing some really ugly things to sys.path.

00:20:37,730 --> 00:20:39,540
My first thought is, "Well I guess there was

00:20:39,540 --> 00:20:42,580
"some more sys.path shenanigans in there that we should look for."

00:20:42,590 --> 00:20:44,870
But no, it wasn't our fault this time.

00:20:44,870 --> 00:20:46,840
We weren't doing a sys.path append.

00:20:46,840 --> 00:20:50,920
So, we needed to find who was adding that directory to sys.path.

00:20:51,880 --> 00:20:54,020
So, we figured it had to be in third-party code, right?

00:20:54,020 --> 00:20:55,900
Because we can grep all of our own code.

00:20:55,900 --> 00:20:59,720
Now, we're not going to go and grep all of the third-party code, right?

00:20:59,720 --> 00:21:04,120
Open edX has a requirements.txt suite that includes about a hundred packages,

00:21:04,120 --> 00:21:07,200
including NumPy, and SciPy, and SimPy,

00:21:07,200 --> 00:21:09,080
and you're not going to go and grep all that code,

00:21:09,080 --> 00:21:11,440
so, you need dynamic analysis to get at it.

00:21:12,520 --> 00:21:14,440
What we wanted was a data breakpoint.

00:21:14,450 --> 00:21:17,240
It would be really awesome if we could go into pdb and say,

00:21:17,240 --> 00:21:19,910
"Not break when you get to this line in this file,

00:21:19,910 --> 00:21:23,810
"but break whenever that piece of data changes in a certain way," right?

00:21:23,810 --> 00:21:27,140
What we wanted to know was: when does sys.path

00:21:27,140 --> 00:21:31,160
get a new entry at element 0 that ends with /lib?

00:21:31,160 --> 00:21:32,740
That's what we wanted to know.

00:21:32,740 --> 00:21:34,560
Who is adding that thing to sys.path?

00:21:34,560 --> 00:21:36,320
Pdb doesn't have that as a feature.

00:21:36,320 --> 00:21:39,200
There's no way to implement that directly in the debugger,

00:21:40,320 --> 00:21:42,480
so we write a trace function.

00:21:42,480 --> 00:21:45,100
Trace functions -- if you haven't encountered them before,

00:21:45,110 --> 00:21:48,170
CPython has a very simple-sounding feature

00:21:48,170 --> 00:21:51,810
which is that you can write a function and you can register it with the interpreter,

00:21:51,810 --> 00:21:53,680
and it will call your function

00:21:53,680 --> 00:21:56,020
for every line of your program that gets executed.

00:21:56,020 --> 00:21:58,390
And this is actually how debuggers are implemented,

00:21:58,390 --> 00:22:00,660
and profile tools, and coverage.py.

00:22:00,660 --> 00:22:03,830
The way a lot of these dynamic analysis tools

00:22:03,830 --> 00:22:07,150
understand the running of your program is that they write a trace function

00:22:07,150 --> 00:22:09,140
and then CPython calls them over and over again

00:22:09,140 --> 00:22:11,560
for every line of your program that gets executed.

00:22:12,140 --> 00:22:13,920
This makes it go very slow

00:22:13,920 --> 00:22:16,060
but you're only going to need it for a little while.

00:22:16,070 --> 00:22:18,000
Here is an example of a trace function.

00:22:18,000 --> 00:22:20,040
In fact, this is the entire trace function that I wrote.

00:22:20,040 --> 00:22:23,500
So, a trace function gets the frame that you're running in,

00:22:23,500 --> 00:22:26,380
it gets an event which is called a return or a line

00:22:26,380 --> 00:22:29,100
and it gets an arg which, in this case, isn’t interesting to us.

00:22:29,100 --> 00:22:31,280
In fact, none of the arguments are interesting to us,

00:22:31,280 --> 00:22:33,020
because we don't care where in the program we are

00:22:33,020 --> 00:22:34,980
and we don't care what's happening.

00:22:34,980 --> 00:22:36,800
What we want to know is --

00:22:36,800 --> 00:22:39,580
if the first element of sys.path ends with/lib,

00:22:39,590 --> 00:22:42,470
we want to stop right there and see what's going on.

00:22:46,150 --> 00:22:48,470
To make the trace function work, you call sys.settrace

00:22:48,470 --> 00:22:50,260
and you give it your trace function,

00:22:50,260 --> 00:22:52,280
and from then on it gets called on every line.

00:22:52,280 --> 00:22:55,180
Now, what we did here -- if you've seen this before,

00:22:55,180 --> 00:22:57,520
pdb.set_trace -- that's the horribly-named API

00:22:57,520 --> 00:22:59,580
to getting pdb to break, right?

00:22:59,580 --> 00:23:03,300
It should be called break_into_debugger," but it's called set_trace

00:23:03,300 --> 00:23:06,960
because literally this is where pdb sets its trace function

00:23:06,960 --> 00:23:08,740
as the trace function, right?

00:23:08,740 --> 00:23:12,020
This is a great example of an API being named for the internal concerns

00:23:12,020 --> 00:23:13,860
rather than for the external use,

00:23:13,860 --> 00:23:16,980
but this isn't a talk about API usability.

00:23:16,980 --> 00:23:22,300
And I apologize that pdb.set_trace has an underscore and sys.settrace does not.

00:23:22,300 --> 00:23:25,200
Again, see some other talk about API usability.

00:23:25,200 --> 00:23:27,120
[audience chuckles]

00:23:27,120 --> 00:23:30,280
But in this case, the trace function is incredibly simple, right?

00:23:30,280 --> 00:23:32,590
In fact, what I’m doing here is using what sounds like

00:23:32,590 --> 00:23:34,690
a really, really advanced feature, a trace function,

00:23:34,690 --> 00:23:36,440
but the amount of code and the complexity of code

00:23:36,440 --> 00:23:38,220
I had to write to use it

00:23:38,220 --> 00:23:41,380
was much simpler than the previous examples I've shown.

00:23:41,380 --> 00:23:43,200
And frankly when I wrote it,

00:23:43,200 --> 00:23:46,460
I wasn't quite sure: Am I allowed to call pdb.set_trace

00:23:46,460 --> 00:23:51,340
while I’m actually inside a trace function that is already being invoked by CPython?

00:23:51,340 --> 00:23:55,980
I figured there was about a 50-50 chance that this just wouldn't work at all, right?

00:23:55,980 --> 00:23:58,260
But it took me about a minute to write that function,

00:23:58,260 --> 00:23:59,800
so what have I got to lose?

00:23:59,800 --> 00:24:01,550
And in fact it worked great.

00:24:01,560 --> 00:24:04,820
I ran this, and it broke into the debugger

00:24:04,820 --> 00:24:06,720
and it was "nose," the test runner.

00:24:06,720 --> 00:24:09,640
So, nose has a helpful feature where if it sees

00:24:09,640 --> 00:24:11,860
that you have a directory called lib,

00:24:11,860 --> 00:24:13,920
it figures you probably want to import from it,

00:24:13,920 --> 00:24:15,720
and it adds it to the sys.path for you.

00:24:15,730 --> 00:24:19,540
Luckily, it also has a switch where you can just say, "Don't do that,"

00:24:19,540 --> 00:24:22,320
and we set the switch, and the problem was fixed.

00:24:22,320 --> 00:24:24,970
So, here's a trace function.

00:24:24,970 --> 00:24:28,370
It's a very advanced feature, but sometimes, it's exactly what you need.

00:24:30,760 --> 00:24:33,000
So, what did we learn from this?

00:24:33,000 --> 00:24:35,080
One, it's not just your code, right?

00:24:35,080 --> 00:24:38,390
It's a classic beginner mistake to think that it's a compiler bug

00:24:38,390 --> 00:24:41,260
or, you know, the standard library has a bug.

00:24:41,260 --> 00:24:43,580
Sometimes, it is other tools that do have bugs, right?

00:24:43,580 --> 00:24:45,570
You have to be open to that possibility.

00:24:45,570 --> 00:24:49,360
And because of Cases 1 through 2 or 3, whatever we’re up to here, you know,

00:24:49,360 --> 00:24:51,710
I was very willing to believe that it was our own code

00:24:51,710 --> 00:24:53,630
that was at fault, but it wasn't,

00:24:53,630 --> 00:24:55,880
and we needed to figure out a way to get at the behavior

00:24:55,880 --> 00:24:57,980
of these other third-party tools.

00:24:59,200 --> 00:25:02,240
Again, dynamic analysis is very, very powerful.

00:25:02,250 --> 00:25:06,540
This was an expensive thing to do, run an 8,000-test test suite

00:25:06,540 --> 00:25:09,460
with a Python implementation of a trace function.

00:25:09,460 --> 00:25:11,480
You can imagine how much slower it would run.

00:25:11,480 --> 00:25:14,220
Luckily it was very early on in that test suite

00:25:14,220 --> 00:25:15,550
that it hit that breakpoint,

00:25:15,550 --> 00:25:17,370
because it was the test runner setting it.

00:25:17,370 --> 00:25:20,000
But even if it took eight hours,

00:25:20,000 --> 00:25:23,500
that's probably faster than finding it some other way.

00:25:25,160 --> 00:25:27,200
And sometimes, you have to use big hammers, right?

00:25:27,210 --> 00:25:29,980
This, frankly, is kind of overkill to find that,

00:25:29,980 --> 00:25:33,840
but it was actually less time on my part and more time on the computer’s part,

00:25:33,840 --> 00:25:35,940
and it worked out really well.

00:25:37,740 --> 00:25:41,060
All right, Case 4: Why is random different?

00:25:41,070 --> 00:25:43,720
The problem: so Open edX presents problems to students,

00:25:43,720 --> 00:25:45,570
and we have a massive number of students.

00:25:45,580 --> 00:25:48,400
What we wanted to do is we wanted to present problems that were randomized

00:25:48,400 --> 00:25:51,040
so the problem I saw was different than the problem you saw.

00:25:51,040 --> 00:25:52,840
But we wanted them to be repeatable

00:25:52,840 --> 00:25:54,820
so that the next time I came back to look at a problem,

00:25:54,820 --> 00:25:57,240
I’d see the same problem I'd seen before.

00:25:57,250 --> 00:25:59,800
And so we do that by seeding the random number generation

00:25:59,800 --> 00:26:02,180
with a seed that's particular to the student.

00:26:02,180 --> 00:26:06,280
So, each student has a seed, we seed the random number generator,

00:26:06,280 --> 00:26:08,520
and then when it comes time to run the problem code

00:26:08,520 --> 00:26:10,460
that's going to present the problem,

00:26:10,460 --> 00:26:14,820
when the random number is generated, it comes out predictably.

00:26:14,820 --> 00:26:18,040
So, what I've shown here is the problem code

00:26:18,040 --> 00:26:21,980
generating a random number from 1 to 1,000, and it should be 420.

00:26:21,980 --> 00:26:25,350
The problem we had was that the first time that code ran,

00:26:25,350 --> 00:26:28,360
it came out different -- it came out as 284.

00:26:28,360 --> 00:26:30,280
And then the second, third, fourth,

00:26:30,280 --> 00:26:32,160
all the rest of the times, it came out as 420.

00:26:32,160 --> 00:26:34,960
So, there's something weird about how the random number seed

00:26:34,960 --> 00:26:38,170
was being used to produce the random number sequence.

00:26:38,170 --> 00:26:40,570
And the fact that we had that first time different than the other times

00:26:40,570 --> 00:26:43,460
made us think, maybe it's about that import thing, right?

00:26:43,460 --> 00:26:45,400
Remember, code gets run on import

00:26:45,400 --> 00:26:47,400
and then not the next time you import it, right?

00:26:47,400 --> 00:26:49,600
Different the first time than times 2 through n.

00:26:51,920 --> 00:26:53,740
So, how were we gonna find it?

00:26:53,740 --> 00:26:55,620
Well we're gonna monkeypatch again but we're going to use a new technique.

00:26:55,620 --> 00:26:58,000
And this is one of my favorite techniques.

00:26:58,000 --> 00:27:00,200
Well, this looks like, maybe, an esoteric thing.

00:27:00,200 --> 00:27:03,590
No, it's actually just 1 divided by 0.

00:27:03,590 --> 00:27:07,730
This is a really easy piece of code you can drop into anywhere.

00:27:07,730 --> 00:27:11,640
It generates an exception because you're not allowed to divide by 0.

00:27:11,640 --> 00:27:14,090
It's really fast to type because it's only three characters,

00:27:14,090 --> 00:27:17,870
and this is an exception that your real code probably never generates, right?

00:27:17,870 --> 00:27:20,600
So, if you put this code in the middle of anywhere

00:27:20,600 --> 00:27:23,970
and then you see an actual ZeroDivisionError come out on your console,

00:27:23,970 --> 00:27:25,990
it's that code that's making it happen.

00:27:25,990 --> 00:27:28,390
So, it's really easy to spot, right?

00:27:28,390 --> 00:27:31,760
These are -- this has got to be my favorite three-character Python expression.

00:27:31,760 --> 00:27:35,860
And I’d be glad to hear other candidates for great three-character Python expressions.

00:27:35,860 --> 00:27:38,080
I don't think you're going to be able to top 1/0.

00:27:39,000 --> 00:27:41,040
So, what we're gonna do is we’re going to monkeypatch again.

00:27:41,040 --> 00:27:43,140
We're gonna monkeypatch "random" with a booby trap, right?

00:27:43,140 --> 00:27:44,980
We're going to import "random,"

00:27:44,980 --> 00:27:47,840
and we’re going to say random.random = lambda: 1/0, right?

00:27:47,840 --> 00:27:50,010
And now, notice how reckless we’re being here.

00:27:50,010 --> 00:27:51,860
We don't care what the arguments are,

00:27:51,860 --> 00:27:55,110
we're not trying to reproduce the behavior, we're not returning anything.

00:27:55,110 --> 00:27:59,620
It's just an exception... but it worked great.

00:27:59,620 --> 00:28:01,680
So, we've got a booby-trapped random

00:28:01,690 --> 00:28:05,290
and what actually happened is, we got a ZeroDivisionError,

00:28:05,290 --> 00:28:09,410
and we could see that in one of our third party packages

00:28:09,410 --> 00:28:13,910
was a default value for a function of random.random, right?

00:28:13,910 --> 00:28:18,120
There was actually a class for this package for its tests.

00:28:18,120 --> 00:28:22,860
And one of the arguments to the dunder init was random.random.

00:28:22,860 --> 00:28:27,080
And remember that all the code in your modules is executed when it's imported,

00:28:27,080 --> 00:28:29,040
and when you define a function,

00:28:29,040 --> 00:28:32,480
the default values are evaluated so the value can be stored with the function.

00:28:32,480 --> 00:28:35,560
And so it was actually calling random.random once during import

00:28:35,560 --> 00:28:36,880
but only the first time.

00:28:36,880 --> 00:28:39,720
So, that was taking one of the numbers out of the sequence

00:28:39,720 --> 00:28:44,290
which put us off by one number which is why we got a different number the first time

00:28:44,290 --> 00:28:45,920
than all the other times, right?

00:28:45,920 --> 00:28:49,050
And I see some of you scrunching up your eyebrows,

00:28:49,050 --> 00:28:50,860
like, "Why would someone do that?"

00:28:50,860 --> 00:28:55,011
Just for an extra bonus, they never actually used that default value --

00:28:55,011 --> 00:28:57,031
[laughter]

00:28:57,040 --> 00:29:00,200
-- because the only places this function were ever called,

00:29:00,210 --> 00:29:02,200
actually supplied their own value for that.

00:29:02,200 --> 00:29:04,100
So, it was kind of a comedy of errors.

00:29:04,100 --> 00:29:06,140
The good news is we reported the bug,

00:29:06,140 --> 00:29:10,130
and they were very, very, uh, understanding, and fixed it.

00:29:10,130 --> 00:29:14,250
So, what’d we learn here?

00:29:14,250 --> 00:29:17,030
One: exceptions are a really good way to get information, right?

00:29:17,030 --> 00:29:19,391
The great thing about exceptions is that if no one catches it,

00:29:19,391 --> 00:29:21,690
it will come all the way back up to the top, right?

00:29:21,690 --> 00:29:25,370
So, you can have an exception way deep down in your program,

00:29:25,370 --> 00:29:26,560
and unless it's something

00:29:26,560 --> 00:29:28,430
that might get caught somewhere else like AttributeError --

00:29:28,430 --> 00:29:30,330
ZeroDivisionError is very unlikely to be caught

00:29:30,330 --> 00:29:35,500
unless you have an "exceptException" someplace, or, God forbid, an "except:" someplace.

00:29:35,500 --> 00:29:38,740
But it's very likely that it will come all the way out to the top of your program.

00:29:38,740 --> 00:29:42,040
And by the way, another good technique is that you can -- oop, sorry.

00:29:42,040 --> 00:29:46,790
You -- no, we're not?

00:29:46,790 --> 00:29:48,350
Sorry.

00:29:48,350 --> 00:29:51,600
So, exceptions are a good way to get information.

00:29:51,600 --> 00:29:53,430
And you can actually put information in the exception, right?

00:29:53,430 --> 00:29:54,840
You can put a string in your exception.

00:29:54,840 --> 00:29:56,820
That doesn't have to be a hard-coded string, right?

00:29:56,820 --> 00:29:59,040
Whatever value, deep down there, you want to see,

00:29:59,040 --> 00:30:00,040
format it into the message

00:30:00,040 --> 00:30:03,110
and let the exception bring it all the way up to the top.

00:30:03,110 --> 00:30:04,630
And don't be afraid to blow things up, right?

00:30:04,630 --> 00:30:08,700
This monkeypatch was horrible; The program wasn't gonna run, right?

00:30:08,700 --> 00:30:09,700
But I didn't care.

00:30:09,700 --> 00:30:12,420
I just needed to find out where the random.random was,and it told me

00:30:12,420 --> 00:30:13,650
that.

00:30:13,650 --> 00:30:16,690
And sometimes you get lucky, because, of course,

00:30:16,690 --> 00:30:19,190
there's an obvious flaw in this monkeypatch which is,

00:30:19,190 --> 00:30:22,320
maybe, it wasn't the first value that was going wrong.

00:30:22,320 --> 00:30:24,770
Maybe there were three values getting taken and every one did that right,

00:30:24,770 --> 00:30:27,500
but then a fourth, extra fourth value was being pulled off the sequence.

00:30:27,500 --> 00:30:29,250
And if that had been true,

00:30:29,250 --> 00:30:30,670
then I wouldn't have found out anything interesting

00:30:30,670 --> 00:30:32,200
because the first one would blow up.

00:30:32,200 --> 00:30:33,850
Well, then I’d have to try something else, right?

00:30:33,850 --> 00:30:36,850
In this case what I did is I tried the simplest thing I could think.

00:30:36,850 --> 00:30:37,850
Maybe it'll work, maybe it won't.

00:30:37,850 --> 00:30:39,240
It worked great, now we can move on.

00:30:39,240 --> 00:30:40,240
If it hadn't worked,

00:30:40,240 --> 00:30:43,120
well then I’d have to come up with a different way to see maybe more of random.

00:30:43,120 --> 00:30:45,830
It’d be a trickier monkeypatch, but I could still get in there

00:30:45,830 --> 00:30:48,330
and see where all the randoms were going.

00:30:48,330 --> 00:30:50,930
But sometimes you get lucky and it works out that way.

00:30:50,930 --> 00:30:54,550
So, don't over-engineer these things, just hack away at it, right?

00:30:54,550 --> 00:30:55,620
That's what machete mode’s all about.

00:30:55,620 --> 00:30:57,020
You're in the jungle, you need to get out.

00:30:57,020 --> 00:31:00,260
You’re not planning a whole paved road with road signs and traffic lights and everything.

00:31:00,260 --> 00:31:03,040
You just use the machete to cut your way straight through.

00:31:03,040 --> 00:31:06,830
Now, the real problem here was that we were sharing global state, right?

00:31:06,830 --> 00:31:09,290
There was one global random number sequence

00:31:09,290 --> 00:31:11,950
that we were using and this program was using --

00:31:11,950 --> 00:31:14,400
this package was using for its random numbers, right?

00:31:14,400 --> 00:31:19,400
The real solution was that we started creating our own random object

00:31:19,400 --> 00:31:21,320
to get our own random numbers from.

00:31:21,320 --> 00:31:24,090
Shared mutable state is a very, very difficult thing

00:31:24,090 --> 00:31:27,680
because it means that anywhere in your program could be filling with that,

00:31:27,680 --> 00:31:30,920
and it's very hard to reason at that kind of distance.

00:31:30,920 --> 00:31:36,120
So, do use your own random object.

00:31:36,120 --> 00:31:38,080
And do suspect third-party code.

00:31:38,080 --> 00:31:41,000
Again, you know, this is kind of a messed up piece of code

00:31:41,000 --> 00:31:46,230
that we got from a big well-known project that we trusted to do a lot of other stuff

00:31:46,230 --> 00:31:47,980
and it was kind of in a weird part of their code.

00:31:47,980 --> 00:31:50,880
By the way, the other weird thing is that just importing their main code

00:31:50,880 --> 00:31:54,860
was importing their test helpers which is where this code was.

00:31:54,860 --> 00:31:57,140
You know, people get sloppy, it's all right, you know?

00:31:57,140 --> 00:31:59,260
We're all in this together.

00:31:59,260 --> 00:32:02,460
But you have to be prepared for that kind of thing to happen.

00:32:02,460 --> 00:32:06,000
All right, the big lessons from the whole talk.

00:32:06,000 --> 00:32:09,110
One: break conventions to get what you need, right?

00:32:09,110 --> 00:32:10,960
This code doesn't even have to be checked in, right?

00:32:10,960 --> 00:32:12,530
It's all on your machine.

00:32:12,530 --> 00:32:16,080
You can use the full dynamic nature of Python

00:32:16,080 --> 00:32:21,140
to get the information you need, but only for debugging, right?

00:32:21,140 --> 00:32:25,030
So, the nefarious among you may be jotting down notes

00:32:25,030 --> 00:32:28,150
about how you're going to do that thing on that server somewhere.

00:32:28,150 --> 00:32:31,560
And I don't know who you are, so I can’t take any blame,

00:32:31,560 --> 00:32:33,510
but I really recommend you don't do that

00:32:33,510 --> 00:32:37,720
or I’ll be here next year debugging what you put on your server.

00:32:37,720 --> 00:32:40,610
So, and again, dynamic analysis is something

00:32:40,610 --> 00:32:44,410
that Python’s introspectability and malleability really lends itself to,

00:32:44,410 --> 00:32:46,770
so use it.

00:32:46,770 --> 00:32:50,240
And understand the mechanisms that underlie Python, right?

00:32:50,240 --> 00:32:53,230
If you understand how import really works, or what path files are,

00:32:53,230 --> 00:32:55,440
or the global and shared state of random,

00:32:55,440 --> 00:32:57,440
it will help you reason about the problems that you're seeing

00:32:57,440 --> 00:32:59,620
and get you the answers sooner.

00:32:59,620 --> 00:33:01,950
Any questions?

00:33:01,950 --> 00:33:04,780
Thank you.

00:33:04,780 --> 00:33:07,620
[applause]

00:33:07,620 --> 00:33:11,560
Do we have time for questions?

00:33:11,560 --> 00:33:14,270
Jesse, do we have time for questions?

00:33:14,270 --> 00:33:15,770
He's got no mic.

00:33:15,770 --> 00:33:16,890
(Jesse) Kind of.

00:33:16,890 --> 00:33:19,080
I think we can take just one or two.

00:33:19,080 --> 00:33:20,460
(Ned Batchelder) One or two.

00:33:20,460 --> 00:33:22,390
(audience member) So, Ned, you told us --

00:33:22,390 --> 00:33:24,070
great talk, by the way, Ned.

00:33:24,070 --> 00:33:27,050
You told us when you have a bad third-party library,

00:33:27,050 --> 00:33:28,160
you submitted a patch,

00:33:28,160 --> 00:33:29,810
or you told them what their problem was,

00:33:29,810 --> 00:33:33,370
but in the meantime, between the submission of the patch,

00:33:33,370 --> 00:33:34,370
how do you fix the problem?

00:33:34,370 --> 00:33:36,910
Do you actually patch the code and run it locally yourself

00:33:36,910 --> 00:33:38,220
or do you change your own code?

00:33:38,220 --> 00:33:39,730
(Ned Batchelder) No, in this case,

00:33:39,730 --> 00:33:42,250
it's the second bullet from the bottom: we used our own random object

00:33:42,250 --> 00:33:44,110
to avoid the global mutable state completely.

00:33:44,110 --> 00:33:46,120
(audience member) OK, so all right, so, you changed your code.

00:33:46,120 --> 00:33:49,110
(Ned Batchelder) In this case, we had an option.

00:33:49,110 --> 00:33:50,110
It could have been worse,

00:33:50,110 --> 00:33:52,610
and it could have been that we would have to fork the project

00:33:52,610 --> 00:33:56,410
and not an aggressive fork, a fork in the GitHub sense,

00:33:56,410 --> 00:33:58,220
and have our own copy of the code.

00:33:58,220 --> 00:33:59,840
And we've had to do that in a few places, too,

00:33:59,840 --> 00:34:00,840
just to keep things working.

00:34:00,840 --> 00:34:02,090
(audience member) OK, thank you.

00:34:02,090 --> 00:34:03,340
(Ned Batchelder) Sure, thanks.

00:34:03,340 --> 00:34:04,340
I don't know.

00:34:04,340 --> 00:34:05,340
Are we still --

00:34:05,340 --> 00:34:10,210
(audience member) Thanks for the talk, Ned.

00:34:10,210 --> 00:34:14,379
So, we've seen the answers to these debugging situations.

00:34:14,379 --> 00:34:16,640
Can you talk a bit about the thought process

00:34:16,640 --> 00:34:17,690
of, kind of, coming up with these?

00:34:17,690 --> 00:34:21,800
Like, were these your first suggestions and they just kind of worked out,

00:34:21,800 --> 00:34:24,910
or did you have a few that kind of didn't work out?

00:34:24,910 --> 00:34:26,770
How did you come up with these pretty, kind of, clever --

00:34:26,770 --> 00:34:27,810
(Ned Batchelder) That's a good question.

00:34:27,810 --> 00:34:31,870
I’m not, I’m not sure I've got any good answers

00:34:31,870 --> 00:34:36,429
for how to come up with these ideas other than to think outside the box

00:34:36,429 --> 00:34:41,540
and understand that it's all possible and you can --

00:34:41,540 --> 00:34:43,800
you can play around with that malleability.

00:34:43,800 --> 00:34:48,100
You can break outside of, sort of, the strict style of coding

00:34:48,100 --> 00:34:51,150
and treat it more like the touchable thing that Python is.

00:34:51,150 --> 00:34:52,531
I don't know how else to say it than that.

00:34:52,531 --> 00:34:55,720
I think we have to go, unfortunately,

00:34:55,720 --> 00:34:56,720
but thank you for coming.

00:34:56,720 --> 00:34:58,700
I'd be glad to talk about it with anyone else, outside.

00:34:58,700 --> 00:35:00,320
(audience member) Thank you.

00:35:00,320 --> 00:35:02,349

YouTube URL: https://www.youtube.com/watch?v=bAcfPzxB3dk


