Title: Melinda Shore - Advanced DNS Services for Securing Your Application and Enhancing User Privacy.mp4
Publication date: 2016-06-17
Playlist: PyCon 2016
Description: 
	Speaker: Melinda Shore

This talk introduces new features that have been added to the Domain Name System recently, and how to use those features to improve application security and user privacy. I also introduce the "getdns" Python library, which provides a simplified DNS API, and how to interface with popular crypto libraries. 

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:00,140 --> 00:00:02,380
(host) We're going to get started here

00:00:02,380 --> 00:00:07,600
with our first talk of this early afternoon session.

00:00:07,600 --> 00:00:09,520
And I would just like you all

00:00:09,520 --> 00:00:12,460
to help me welcome Melinda Shore here, who --

00:00:12,460 --> 00:00:19,760
[applause]

00:00:19,760 --> 00:00:24,000
Thank you. Melinda runs a cyber security consultancy

00:00:24,000 --> 00:00:26,520
and she'll be talking about DNS.

00:00:28,680 --> 00:00:31,880
Hi, my name is Melinda Shore.

00:00:31,880 --> 00:00:34,780
To be perfectly honest, this is my first PyCon,

00:00:34,780 --> 00:00:37,960
and I understand it's a little bit unusual to give talks here

00:00:37,960 --> 00:00:43,720
on what's basically network plumbing, network infrastructure.

00:00:43,720 --> 00:00:46,200
But we've got a library that makes some new features

00:00:46,200 --> 00:00:49,740
in that plumbing available to application developers

00:00:49,740 --> 00:00:51,820
and systems programmers,

00:00:51,820 --> 00:00:53,960
and so we thought we would come here and talk about it,

00:00:53,970 --> 00:00:56,670
and also talk about why you should care, because I think oftentimes

00:00:56,670 --> 00:01:01,860
information about what's going on doesn't propagate up the stack.

00:01:01,860 --> 00:01:06,760
So the context for this is that we've got a library called GETDNS.

00:01:06,760 --> 00:01:11,020
It's a new DNS library supporting new DNS protocol features,

00:01:11,020 --> 00:01:14,860
because there has been an awful lot of DNS protocol development

00:01:14,860 --> 00:01:17,360
been going on in the past several years.

00:01:17,360 --> 00:01:21,620
The library itself provides one‑step DNSSEC validation.

00:01:21,620 --> 00:01:23,580
It's asynchronous by default.

00:01:23,580 --> 00:01:26,300
It has transfer options to protect user privacy,

00:01:26,300 --> 00:01:29,380
avoid problems traversing what we call middleboxes,

00:01:29,380 --> 00:01:31,320
which are firewalls and NATs

00:01:31,320 --> 00:01:34,060
and other sorts of network transfer intermediaries

00:01:34,060 --> 00:01:37,600
that sometimes causes difficulties for applications.

00:01:37,600 --> 00:01:40,160
So our goal is to make advanced DNS features available

00:01:40,160 --> 00:01:43,120
to application developers without requiring you

00:01:43,120 --> 00:01:46,120
to know much about the protocol details.

00:01:48,200 --> 00:01:50,320
It was a project that was originally --

00:01:50,320 --> 00:01:53,540
the API was specified by Paul Hoffman,

00:01:53,540 --> 00:01:55,480
who now works for ICANN,

00:01:55,480 --> 00:01:57,840
and Allison Mankin at Verisign Labs

00:01:57,840 --> 00:02:00,900
put together a project to implement this API.

00:02:00,900 --> 00:02:04,920
And it's involved a fairly large team,

00:02:04,920 --> 00:02:08,320
a very international team and a very skilled team.

00:02:08,320 --> 00:02:11,740
Most of us are are active in the Internet Engineering Task Force,

00:02:11,740 --> 00:02:17,820
or IETF, which is where network protocols are made and specified.

00:02:18,600 --> 00:02:20,460
So that's the context.

00:02:20,460 --> 00:02:23,860
The original specification was for a C API.

00:02:23,870 --> 00:02:27,030
The data structures in the C API were very Pythonic,

00:02:27,030 --> 00:02:29,760
And so we thought, well, we could put a Python wrapper around this

00:02:29,760 --> 00:02:31,980
and get something that might be easier to use.

00:02:31,980 --> 00:02:35,300
And in fact, it's turned out to be really nice.

00:02:35,300 --> 00:02:38,300
We've also got language bindings, in addition to Python,

00:02:38,300 --> 00:02:42,340
for Node and PHP, and there's some work going on in Ruby.

00:02:42,340 --> 00:02:46,660
We've gone to a lot of hackathons and done extremely well there.

00:02:46,670 --> 00:02:49,260
I think the thing that we are proudest of so far in this project

00:02:49,260 --> 00:02:52,080
is that we won the "Best Internet Security Improvement"

00:02:52,080 --> 00:02:56,400
at an IETF hackathon in November.

00:02:56,400 --> 00:03:01,000
Anyways, so now we feel like it's starting to reach maturity.

00:03:01,000 --> 00:03:03,140
We've got some really interesting features in there

00:03:03,140 --> 00:03:05,740
and we want to talk about it in public.

00:03:05,740 --> 00:03:09,580
OK, so there are these changes in network plumbing.

00:03:09,580 --> 00:03:12,080
Oftentimes, when this happens, they're invisible to users,

00:03:12,080 --> 00:03:15,060
but not always -- not in this case.

00:03:16,020 --> 00:03:18,020
So we're going to talk a little bit about

00:03:18,020 --> 00:03:21,880
how this can make your life a little bit easier.

00:03:21,880 --> 00:03:26,319
I've got a very, very, very, very, very brief DNS tutorial.

00:03:26,320 --> 00:03:28,400
I'm not sure how many people are already familiar

00:03:28,400 --> 00:03:30,940
with how the DNS actually works.

00:03:30,940 --> 00:03:33,820
So I tried to keep it brief and just provide enough context

00:03:33,820 --> 00:03:38,000
for understanding some of the things that are being built on top of it.

00:03:38,000 --> 00:03:40,720
It's basically a stateless query‑response protocol.

00:03:40,720 --> 00:03:43,700
You send out a message, and it's stateless.

00:03:43,700 --> 00:03:46,200
A response comes back and it has enough information

00:03:46,200 --> 00:03:49,740
for you to be able to put it together with your query.

00:03:49,740 --> 00:03:52,120
What are sent along and what are returned

00:03:52,120 --> 00:03:54,629
are called resource records.

00:03:54,629 --> 00:03:58,420
The structure -- it's basically an enormous distributed database.

00:03:58,420 --> 00:04:01,060
It is hierarchical.

00:04:01,060 --> 00:04:03,519
The hierarchy is something that you're definitely familiar with.

00:04:03,520 --> 00:04:05,780
It starts at "dot," which is the root zone.

00:04:05,780 --> 00:04:08,640
Then you've got the top level domains, what are .com, .org,

00:04:08,640 --> 00:04:11,240
.uk, and hundreds of others.

00:04:11,240 --> 00:04:13,620
Second level domains include things like ietf,

00:04:13,620 --> 00:04:18,100
so you'd get ietf.org, python.org, isoc.org, eff.org,

00:04:18,100 --> 00:04:21,320
and then subdomains, like under "python,"

00:04:21,330 --> 00:04:25,270
you've got mail, pypi, ww, and so on.

00:04:25,270 --> 00:04:29,500
So what a query looks like is basically this.

00:04:29,500 --> 00:04:33,160
By the way, I said which dig here because it shows that you've got dig

00:04:33,160 --> 00:04:35,860
on your Macs already. It comes with the operating system.

00:04:35,860 --> 00:04:37,890
So if you're interested in poking around the DNS

00:04:37,890 --> 00:04:39,860
and learning a little bit more about the structure of records

00:04:39,860 --> 00:04:43,200
and the data that come back, this is a good way to do it.

00:04:43,200 --> 00:04:47,560
It's not as good as GETDNS, but it's already on your Mac.

00:04:47,560 --> 00:04:50,020
OK, so basically what we're doing here is we're saying

00:04:50,020 --> 00:04:53,540
dig getdnsapi.net a, which means we're asking for

00:04:53,540 --> 00:04:59,500
an A record or an IPD4 address record for getdnsapi.net.

00:04:59,500 --> 00:05:02,180
What comes back is the question that we asked,

00:05:02,180 --> 00:05:07,500
which is also circled here, along with the answer.

00:05:07,500 --> 00:05:10,080
Excuse me, the answer is circled.

00:05:10,080 --> 00:05:12,390
The question section is right above it.

00:05:12,390 --> 00:05:19,140
So basically the answer that comes back is 185.49.141.37.

00:05:19,140 --> 00:05:22,540
OK, so DNS, it's ubiquitous. It's everywhere.

00:05:22,540 --> 00:05:24,420
I mean, I think there are -- I know there are some of us

00:05:24,420 --> 00:05:30,020
who remember host.txt and the host file being distributed by FTP.

00:05:30,020 --> 00:05:33,440
But that was decades ago, and now it's all dynamic

00:05:33,440 --> 00:05:38,600
and it's being done through this distributed database called DNS.

00:05:38,600 --> 00:05:40,520
But it's not very secure.

00:05:40,520 --> 00:05:43,640
The stateless aspect of it makes it very easy

00:05:43,640 --> 00:05:48,040
for attackers to insert traffic

00:05:48,040 --> 00:05:51,960
and to commit what's called a cache poisoning attack

00:05:51,960 --> 00:05:55,980
in which they insert bogus answers into your DNS cache,

00:05:55,980 --> 00:05:57,820
with obvious consequences.

00:05:57,820 --> 00:06:00,960
It means that they can redirect your traffic pretty easily.

00:06:00,960 --> 00:06:03,640
There are also things they can do along --

00:06:03,640 --> 00:06:06,420
doing denial of service attacks and so on.

00:06:06,420 --> 00:06:10,300
So, DNSSEC was developed, which is a mechanism to prove

00:06:10,300 --> 00:06:13,910
the authenticity of a DNS record.

00:06:13,910 --> 00:06:18,980
The trust model is based on the DNS hierarchical structure.

00:06:18,980 --> 00:06:22,300
That is to say, you as somebody who owns a zone,

00:06:22,300 --> 00:06:25,080
a domain, you sign your own records.

00:06:25,080 --> 00:06:28,080
Your key is signed by your parent zone

00:06:28,080 --> 00:06:31,200
and so on up to the root.

00:06:32,300 --> 00:06:34,240
It uses public key cryptography.

00:06:34,240 --> 00:06:36,300
And I don't know how much -- yeah, this is awesome --

00:06:36,300 --> 00:06:38,230
I don't know how much you know about crypto,

00:06:38,230 --> 00:06:40,840
but in public key cryptography, you've got two keys,

00:06:40,840 --> 00:06:43,080
one of which is public and one of which is private.

00:06:43,080 --> 00:06:47,700
And the basic network problem around public key cryptography --

00:06:47,700 --> 00:06:50,320
well, to back up a little bit, one of the great things about it

00:06:50,320 --> 00:06:52,700
is that you can publish your public key

00:06:52,700 --> 00:06:54,660
and make it available, which means that you don't need

00:06:54,660 --> 00:06:57,560
a pre-existing relationship with somebody else.

00:06:57,560 --> 00:06:59,740
You don't need to pre-provision keys,

00:06:59,740 --> 00:07:02,140
it has nice scaling properties, and it's really nice.

00:07:02,140 --> 00:07:06,640
The problem is that, you know, I could say, "Here's my public key,

00:07:06,640 --> 00:07:09,560
"I'm Angela Merkel," and of course, I'm not.

00:07:09,560 --> 00:07:14,320
So there needs to be a mechanism to protect that identity.

00:07:14,320 --> 00:07:17,920
The way it's usually handled is to have somebody trusted

00:07:17,920 --> 00:07:21,450
vouch for the public key and say yes, you really are Angela Merkel,

00:07:21,450 --> 00:07:24,800
although I'm not, or Melinda Shore,

00:07:24,800 --> 00:07:28,780
and they sign it using their own keys.

00:07:29,460 --> 00:07:33,940
Generally -- PKI is hierarchical; DNSSEC is hierarchical.

00:07:33,940 --> 00:07:37,160
Some of you may be using PGP or OpenPGP,

00:07:37,160 --> 00:07:39,500
and that is a slightly different model.

00:07:39,500 --> 00:07:41,500
That's people vouching for each other,

00:07:41,500 --> 00:07:47,580
and it's more of a graph structure than a tree.

00:07:49,100 --> 00:07:51,780
So here's a DNSSEC example.

00:07:51,780 --> 00:07:56,320
In the query, I've said dig +dnssec getdnsapi.net a.

00:07:56,320 --> 00:07:58,540
Get the ipv4 address.

00:07:58,540 --> 00:08:02,380
And what comes back is the address and a signature.

00:08:02,380 --> 00:08:05,000
And there are additional records containing public keys

00:08:05,000 --> 00:08:07,960
that I can use to validate that signature

00:08:07,960 --> 00:08:10,750
and prove that the person who --

00:08:10,750 --> 00:08:13,260
or the entity that generated that signature

00:08:13,260 --> 00:08:17,690
does in fact have the private key associated with that domain.

00:08:18,560 --> 00:08:23,440
OK, so the first thing we do is we've got this new library, GETDNS,

00:08:23,440 --> 00:08:27,160
that makes it very, very easy to do DNSSEC validation.

00:08:27,160 --> 00:08:29,060
You don't have to know anything about crypto.

00:08:29,060 --> 00:08:33,000
You don't even really have to know anything about DNS.

00:08:33,000 --> 00:08:36,440
So here, I've -- there's a very short script, simple.py.

00:08:36,440 --> 00:08:39,580
We're importing GETDNS and SYS.

00:08:39,580 --> 00:08:41,780
GETDNS queries have a context,

00:08:41,780 --> 00:08:45,580
so the first thing you do is create a GETDNS context.

00:08:45,580 --> 00:08:49,620
We create a dictionary containing extensions

00:08:49,620 --> 00:08:54,540
and we've asked GETDNS to return only secure records.

00:08:56,500 --> 00:08:59,000
Then we generate an address query

00:08:59,000 --> 00:09:02,180
by saying -- you know, doing context.address

00:09:02,180 --> 00:09:05,820
on the argument that's passed into the script.

00:09:05,820 --> 00:09:09,520
And then all we do is, if we got a good response,

00:09:09,520 --> 00:09:12,940
if we got RESPSTATUS_GOOD, we just walk through the addresses

00:09:12,940 --> 00:09:18,120
and we know that everything there is valid under DNSSEC.

00:09:18,120 --> 00:09:20,520
There's additional data that comes back as well

00:09:20,520 --> 00:09:23,200
if you want a greater level of detail, but, you know,

00:09:23,200 --> 00:09:26,700
as you can see, this is extremely simple.

00:09:26,700 --> 00:09:29,700
So there I run it against getdnsapi.net.

00:09:29,700 --> 00:09:32,920
We get our addresses. I run it against google.com.

00:09:32,920 --> 00:09:37,360
Google doesn't use DNSSEC to protect their DNS records.

00:09:37,360 --> 00:09:39,640
They've opted not to.

00:09:39,640 --> 00:09:42,640
So we're looking at this and we're saying, well,

00:09:42,640 --> 00:09:47,580
DNSSEC protects public keys for DNS.

00:09:47,580 --> 00:09:49,640
Can it protect other stuff?

00:09:49,640 --> 00:09:52,000
It securely serves up public keys.

00:09:52,000 --> 00:09:55,110
Is this a new trust model for the Internet?

00:09:56,260 --> 00:09:58,300
And so the answer is yes.

00:09:58,300 --> 00:10:01,060
OK, so backing up a little bit to PKI.

00:10:01,060 --> 00:10:03,940
As I talked about earlier, you've got to trust somebody.

00:10:03,950 --> 00:10:07,030
The way PKI works is that your -- you know, typically,

00:10:07,030 --> 00:10:12,500
you've got trust roots that come pre-configured with your browser.

00:10:12,500 --> 00:10:16,720
And any certificate that you get during a TLS section

00:10:16,720 --> 00:10:19,920
should chain back up to a certificate

00:10:19,920 --> 00:10:22,820
that's in your root trust store.

00:10:24,420 --> 00:10:26,420
So that means that browser vendors are the ones

00:10:26,420 --> 00:10:28,400
who are making decisions about who to trust

00:10:28,400 --> 00:10:31,620
and who not to, and that hasn't always worked out well.

00:10:31,620 --> 00:10:34,500
They need to be authentic, the public keys,

00:10:34,500 --> 00:10:37,360
and the people who are using them, which is you,

00:10:37,360 --> 00:10:39,920
need to be able to prove authenticity

00:10:39,920 --> 00:10:41,960
So some of the things that we've been running into

00:10:41,960 --> 00:10:45,130
are certificate misissuance.

00:10:45,130 --> 00:10:49,560
A very common example is somebody issuing certificates

00:10:49,560 --> 00:10:53,080
for domains that the applicant doesn't own.

00:10:53,080 --> 00:10:58,580
This happened with TurkTrust, which was a fairly high-profile example.

00:10:58,580 --> 00:11:00,740
And if it chains back up

00:11:00,740 --> 00:11:06,420
to somebody who's already in your root trust store,

00:11:06,420 --> 00:11:10,260
the certificate is going to be valid even though it belongs to somebody else.

00:11:10,260 --> 00:11:14,440
Anyway, we've also been running into careless key usage constraints,

00:11:14,440 --> 00:11:19,280
which is certificate -- certification authorities

00:11:19,280 --> 00:11:22,440
issuing certificates that have the CA bitset,

00:11:22,450 --> 00:11:24,990
which allows the person with that certificate

00:11:24,990 --> 00:11:29,080
to act as a certification authority themselves and issue certificates.

00:11:29,080 --> 00:11:32,360
We've also had problems with compromised CAs.

00:11:32,360 --> 00:11:35,020
And one example that's getting a lot of press this week

00:11:35,020 --> 00:11:36,940
is the Blue Coat situation.

00:11:36,940 --> 00:11:38,800
Have you guys heard about this?

00:11:38,800 --> 00:11:45,660
Yeah. It's a -- Blue Coat is -- they make network intermediaries.

00:11:45,660 --> 00:11:51,660
They make network intermediary devices, kind of like firewalls, but it's...

00:11:51,660 --> 00:11:55,860
Reporters Without Borders in 2013 identified Blue Coat

00:11:55,860 --> 00:11:58,580
as an enemy of the Internet because their devices

00:11:58,580 --> 00:12:01,140
can terminate and reoriginate traffic,

00:12:01,140 --> 00:12:06,660
which allows authoritarian regimes to censor

00:12:06,660 --> 00:12:09,380
what the people in their domains see

00:12:09,380 --> 00:12:15,080
and to also do extensive surveillance on their citizens.

00:12:15,080 --> 00:12:18,700
Some of their customers have included people like Syria and Iran,

00:12:18,700 --> 00:12:21,240
China, and so on.

00:12:21,240 --> 00:12:23,420
So, one thing that happened this spring

00:12:23,420 --> 00:12:26,440
that was only discovered recently is that Symantec,

00:12:26,440 --> 00:12:28,900
which is one of the largest certification authorities,

00:12:28,900 --> 00:12:32,340
issued a CA cert to Blue Coat.

00:12:32,340 --> 00:12:34,880
Blue Coat says they won't be using it.

00:12:35,520 --> 00:12:38,180
We can believe them or not, but the issue remains

00:12:38,180 --> 00:12:41,640
that somebody -- something similar could happen with somebody else

00:12:41,640 --> 00:12:44,920
and we wouldn't know about it.

00:12:44,920 --> 00:12:48,960
I mean, the basic issue is that if you go out to google.com,

00:12:48,960 --> 00:12:53,120
Blue Coat can issue their own certificate for google.com

00:12:53,120 --> 00:12:56,160
and redirect you or censor what you're seeing or whatever.

00:12:56,160 --> 00:12:58,320
It's -- it will terminate your TLS section

00:12:58,320 --> 00:13:03,140
and reoriginate one so that it looks real, or not,

00:13:03,140 --> 00:13:06,920
but basically, there's a problem with censorship and surveillance here.

00:13:06,920 --> 00:13:11,060
So this is a problem that's built into the PKI.

00:13:11,070 --> 00:13:13,920
We know about it and we're trying to do something about it

00:13:13,920 --> 00:13:17,300
with a number of different efforts in the IETF.

00:13:17,300 --> 00:13:19,720
One of those is called DANE,

00:13:19,720 --> 00:13:23,080
which is DNS-Based Authentication of Named Entities.

00:13:23,080 --> 00:13:27,600
We like clever acronyms, even if it -- you know,

00:13:27,600 --> 00:13:32,260
it makes things ugly in reality. "DANE" is easy to pronounce

00:13:32,260 --> 00:13:36,160
even if "DNS-Based Authentication of Named Entities" is not.

00:13:36,720 --> 00:13:38,740
OK, here's the idea.

00:13:39,420 --> 00:13:42,520
People are running their own DNS servers.

00:13:42,520 --> 00:13:45,800
They've got DNSSEC protection of their records,

00:13:45,800 --> 00:13:48,660
so why not give them control

00:13:48,660 --> 00:13:54,000
over what certificates are issued to represent them, right?

00:13:54,000 --> 00:13:57,280
So that when you do a TLS session,

00:13:57,280 --> 00:14:04,980
you can retrieve the TLS certificate from their DNS store

00:14:04,980 --> 00:14:08,500
and match it against what you received on the TLS connection

00:14:08,500 --> 00:14:11,480
rather than having to trust some certification authority.

00:14:11,480 --> 00:14:13,420
You still have the problem of who to trust,

00:14:13,420 --> 00:14:15,480
but intuitively, it's a lot more comfortable

00:14:15,480 --> 00:14:18,740
to trust what a domain says about their own certificates

00:14:18,740 --> 00:14:22,020
than what some third party with a commercial interest

00:14:22,020 --> 00:14:24,140
says about their own certificates.

00:14:24,140 --> 00:14:30,010
So the implementation is basically: put public key credentials

00:14:30,010 --> 00:14:32,740
in the DNS protected by DNSSEC.

00:14:32,740 --> 00:14:36,940
For TLS, these credentials are --

00:14:36,940 --> 00:14:39,840
they're called TLSA records and they contain

00:14:39,840 --> 00:14:44,440
TLS certificates and entity certificates, server certs.

00:14:45,460 --> 00:14:49,140
OK, so basically, to authenticate TLS servers,

00:14:49,140 --> 00:14:53,160
retrieve a TLSA record from the DNS, make sure its signature checks out,

00:14:53,160 --> 00:14:55,100
compare the certificate you received with the one

00:14:55,100 --> 00:14:59,520
that you receive from the server in the server_hello.

00:14:59,520 --> 00:15:02,680
And in GETDNS, it looks like --

00:15:02,680 --> 00:15:07,340
we make a query for a TLSA record

00:15:07,340 --> 00:15:10,820
because the context.general method allows retrieval

00:15:10,820 --> 00:15:14,800
of arbitrary record types.

00:15:14,800 --> 00:15:17,320
Get the server cert the same way you currently would.

00:15:17,330 --> 00:15:20,240
We've been using M2Crypto

00:15:20,240 --> 00:15:22,990
because we -- at the time that we were looking,

00:15:22,990 --> 00:15:25,800
which was about two years ago, a year and a half ago,

00:15:25,800 --> 00:15:27,800
M2Crypto really had the best interface,

00:15:27,800 --> 00:15:31,420
the most complete interface to certificate services.

00:15:31,430 --> 00:15:34,149
Pull data out of the record. This looks like a lot of lines,

00:15:34,149 --> 00:15:37,080
and it's a lot of lines because that's a lot of data,

00:15:37,080 --> 00:15:38,960
but you can see that it's not doing anything

00:15:38,960 --> 00:15:41,360
particularly sophisticated there.

00:15:42,380 --> 00:15:44,720
Compare it with what you've got,

00:15:44,720 --> 00:15:48,480
and either it matches or it doesn't.

00:15:48,480 --> 00:15:52,940
We have a ton of sample code up on -- in our GitHub repo.

00:15:54,500 --> 00:15:57,800
Other DANE applications include OpenPGP keys,

00:15:57,800 --> 00:16:03,660
S/MIME keys, and people are now using TLSA to protect SMTP sessions.

00:16:03,660 --> 00:16:06,680
In particular, in Germany there's been very, very broad

00:16:06,680 --> 00:16:12,040
deployment of TLSA records and valid ones as well.

00:16:13,520 --> 00:16:17,740
We've also got an example of code that --

00:16:17,740 --> 00:16:20,980
we're calling it DANE encrypt.

00:16:20,980 --> 00:16:25,540
We're using S/MIME certificates to encrypt email

00:16:25,540 --> 00:16:28,460
based on certificates that are stored in a TSLA record.

00:16:28,460 --> 00:16:31,000
There's now an OpenPGP type.

00:16:31,920 --> 00:16:33,900
And since we're running a little bit short,

00:16:33,900 --> 00:16:36,940
I thought I'd move ahead to DNS privacy.

00:16:38,540 --> 00:16:42,580
After the revelations about Edward Snowden came out,

00:16:42,580 --> 00:16:46,000
the IETF took a good hard look at what was going on

00:16:46,000 --> 00:16:49,420
and published RFC 7258,

00:16:49,420 --> 00:16:52,980
which says that pervasive monitoring is a technical attack on the network,

00:16:52,980 --> 00:16:57,440
and we're taking great care now to protect protocols

00:16:57,440 --> 00:17:00,240
against possible privacy leaks.

00:17:00,240 --> 00:17:03,300
This includes encryption, but it's not limited to encryption.

00:17:03,300 --> 00:17:05,700
There's a lot of metadata out there that --

00:17:05,700 --> 00:17:09,100
where observers can make inferences about what users are doing

00:17:09,100 --> 00:17:12,360
based on their behavior.

00:17:12,360 --> 00:17:15,740
DNS in particular leaks a massive amount of information

00:17:15,740 --> 00:17:18,130
about what a user is doing in the network.

00:17:18,130 --> 00:17:22,929
So in parallel with protocol development work in the IETF,

00:17:22,929 --> 00:17:25,860
we've been implementing this in GETDNS.

00:17:25,860 --> 00:17:31,500
That includes things like adding TLS transport.

00:17:31,500 --> 00:17:35,680
The RFC specifying the use of TLS for DNS transport

00:17:35,680 --> 00:17:38,220
was just published a couple of weeks ago.

00:17:38,220 --> 00:17:40,140
We've implemented it already.

00:17:40,140 --> 00:17:42,800
It's available on a few servers but not many.

00:17:42,800 --> 00:17:47,100
We've also added optional padding so that an observer cannot tell

00:17:47,100 --> 00:17:51,280
how large your query is, and so on.

00:17:51,280 --> 00:17:55,640
Also, just as a quick note on roadblock avoidance,

00:17:55,640 --> 00:17:58,280
middleboxes such as firewalls and NATs

00:17:58,280 --> 00:18:02,760
sometimes filter out DNS traffic that they think is hinky.

00:18:02,760 --> 00:18:05,210
So we've got mechanisms to work around these.

00:18:05,210 --> 00:18:07,610
This is completely transparent to the programmer.

00:18:07,610 --> 00:18:11,080
This is not something that you would need to do anything to use,

00:18:11,080 --> 00:18:13,040
but you should know it's there.

00:18:13,520 --> 00:18:15,560
OK, current status.

00:18:15,560 --> 00:18:19,020
We're now feature complete with respect to the original API spec,

00:18:19,020 --> 00:18:23,220
and we've got ongoing integration of new protocol features

00:18:23,220 --> 00:18:26,280
as they're being issued by the IETF.

00:18:26,280 --> 00:18:29,600
One of the things that we've been really, really happy about

00:18:29,600 --> 00:18:33,460
using Python for doing this is that it's been incredibly quick

00:18:33,460 --> 00:18:36,940
to prototype new protocol features in the DNS using this.

00:18:36,940 --> 00:18:39,980
I mean, on the order of hours. You can just sit down at the REPL,

00:18:39,980 --> 00:18:44,740
construct a packet, and push it out, and there you go.

00:18:44,740 --> 00:18:47,600
So that's been a really wonderful feature.

00:18:49,960 --> 00:18:52,320
So we've got --

00:18:52,320 --> 00:18:55,640
the project homepage is getdnsapi.net.

00:18:55,640 --> 00:18:59,820
We've got the GitHub repo, PyPI.

00:18:59,820 --> 00:19:01,800
I put together a docker image,

00:19:01,800 --> 00:19:04,520
and I actually am really interested in feedback on this.

00:19:04,520 --> 00:19:06,780
Some people have found it difficult to build the bindings

00:19:06,780 --> 00:19:11,360
because of dependencies, particularly dependency on libgetdns,

00:19:11,360 --> 00:19:15,240
and so I put together a docker image, and it's seen very little download,

00:19:15,240 --> 00:19:19,440
not nearly as much download as the source code itself.

00:19:19,440 --> 00:19:21,720
And if people feel strongly one way or another

00:19:21,720 --> 00:19:24,000
about using docker for this sort of thing,

00:19:24,000 --> 00:19:26,900
I'd be very interested in hearing your feedback.

00:19:28,060 --> 00:19:30,840
OK, we've got a mailing list.

00:19:30,840 --> 00:19:33,120
Please feel free to join it.

00:19:33,800 --> 00:19:38,520
And we've got an upcoming hackathon in July in Berlin,

00:19:38,520 --> 00:19:43,100
and we're going to have a team there as usual.

00:19:43,100 --> 00:19:46,060
And we're really looking for participation

00:19:46,060 --> 00:19:48,580
from application developers about what kinds of things

00:19:48,580 --> 00:19:51,200
that they'd like to see to help them secure their protocols

00:19:51,200 --> 00:19:53,260
using some of this technology.

00:19:53,260 --> 00:19:57,840
So please feel free to drop us a line and get involved.

00:19:57,840 --> 00:20:01,160
You do not need to be registered for the IETF meeting

00:20:01,160 --> 00:20:04,200
or participating in the IETF meeting, you just need to be there.

00:20:04,200 --> 00:20:06,280
It's a Saturday and a Sunday.

00:20:06,280 --> 00:20:08,280
Some of the things we've got in mind

00:20:08,280 --> 00:20:11,320
include a GETDNS protocol for Twisted,

00:20:11,320 --> 00:20:13,920
a DANE API so that you don't even have to know

00:20:13,920 --> 00:20:15,980
as much as I showed you right there.

00:20:15,980 --> 00:20:17,870
You don't have to do any of the crypto stuff yourself

00:20:17,870 --> 00:20:20,700
or use the M2Crypto interface. Or whatever ideas

00:20:20,700 --> 00:20:24,060
you may have as well. It's a very, very open process.

00:20:24,060 --> 00:20:27,220
And that's the URL for the hackathon itself.

00:20:28,860 --> 00:20:30,700
That's my Twitter handle.

00:20:30,700 --> 00:20:33,660
And do people have questions?

00:20:34,700 --> 00:20:43,180
[applause]

00:20:50,100 --> 00:20:52,120
(host) Yeah, could I please ask folks

00:20:52,120 --> 00:20:55,720
to line up at the microphone, and remember to ask questions.

00:20:55,720 --> 00:20:57,500
Thank you.

00:20:58,260 --> 00:21:00,000
(Melinda Shore) Hi.

00:21:04,120 --> 00:21:06,160
There's no sound from that mic, eh?

00:21:06,160 --> 00:21:08,580
(host) Is the microphone on? There we go.

00:21:08,580 --> 00:21:10,420
(audience member) Firefox ships with its own

00:21:10,420 --> 00:21:12,700
search store, I think.

00:21:12,700 --> 00:21:14,620
Other browsers kind of defer to the OS,

00:21:14,620 --> 00:21:16,540
or maybe they ship some of their own.

00:21:16,540 --> 00:21:19,960
If you don't check the integrity of that download,

00:21:19,960 --> 00:21:23,560
then are you kind of opening yourself up to a bunch of vulnerabilities?

00:21:23,560 --> 00:21:25,640
(Melinda Shore) I'm sorry, I can't hear that.

00:21:25,640 --> 00:21:29,340
(audience member) So, the authentication, like --

00:21:29,340 --> 00:21:31,440
you were talking about PKI.

00:21:31,440 --> 00:21:35,000
So you've got some root cert that you're going to trust.

00:21:35,000 --> 00:21:38,960
And that root cert is embedded in, like, the Firefox download.

00:21:38,960 --> 00:21:41,840
So when you're downloading that Firefox download,

00:21:41,840 --> 00:21:45,480
you make sure that you're not getting a malicious copy

00:21:45,480 --> 00:21:47,840
that has an incorrect root cert store.

00:21:47,840 --> 00:21:50,010
So you kind of have, like, a chicken and an egg problem here.

00:21:50,010 --> 00:21:51,820
How do you resolve that?

00:21:51,820 --> 00:21:54,799
(Melinda Shore) Well there's a couple of things going on

00:21:54,800 --> 00:21:57,960
actually in that space. There's the --

00:21:57,960 --> 00:22:02,240
first off, we assume that Mozilla is making good decisions

00:22:02,240 --> 00:22:05,680
about what ends up in the cert store, and generally they have.

00:22:05,680 --> 00:22:10,000
But there are incidents where a CA is compromised

00:22:10,000 --> 00:22:12,600
or they've made a mistake

00:22:12,610 --> 00:22:17,220
and there needs to be the ability to respond to that.

00:22:17,220 --> 00:22:21,720
So the root trust store is --

00:22:21,720 --> 00:22:24,000
yeah, I mean, that's -- as I said,

00:22:24,000 --> 00:22:26,480
there's a bunch of different stuff going on around that right now.

00:22:26,480 --> 00:22:29,580
I don't know if you've heard about the Certificate Transparency Project,

00:22:29,580 --> 00:22:31,780
which allows you to audit what you're seeing and make sure

00:22:31,780 --> 00:22:34,640
that other people are seeing the same thing.

00:22:34,640 --> 00:22:37,220
And we're also doing some work around that

00:22:37,220 --> 00:22:40,800
on this project as well, but it wasn't relevant to this talk.

00:22:41,640 --> 00:22:45,500
This is a little bit different. You know, right now,

00:22:45,500 --> 00:22:48,660
one of the things that's been delaying implementing

00:22:48,660 --> 00:22:52,140
this kind of thing in Firefox and in other browsers

00:22:52,140 --> 00:22:56,900
is that it introduces additional latency

00:22:56,900 --> 00:22:59,340
into session startup, right, because you're --

00:22:59,340 --> 00:23:02,060
when you're having to do a bunch of DNS queries.

00:23:02,060 --> 00:23:05,640
So, another thing we're doing is

00:23:05,640 --> 00:23:09,060
a TLS protocol extension that allows the server

00:23:09,060 --> 00:23:11,880
to send down the entire DNSSEC validation chain

00:23:11,880 --> 00:23:14,580
along with the certificate, and that was just accepted

00:23:14,580 --> 00:23:17,100
as a TLS working group deliverable.

00:23:17,100 --> 00:23:19,480
And I've actually got an application into MAS

00:23:19,480 --> 00:23:23,180
for funding to support this -- implementing it.

00:23:23,180 --> 00:23:26,080
So there's a movement, you know, right now.

00:23:26,080 --> 00:23:31,140
This is a very transitional time, and yeah, we'll see what happens.

00:23:31,140 --> 00:23:33,660
I'm hoping that -- you know, the Chrome guys are involved

00:23:33,660 --> 00:23:35,740
in this as well, so...

00:23:40,340 --> 00:23:44,120
(audience member) Yeah, I really like the idea of DANE.

00:23:44,120 --> 00:23:46,280
It sounds awesome.

00:23:46,280 --> 00:23:48,280
My question was along the lines of what you just said.

00:23:48,280 --> 00:23:51,760
What sort of timeline do you think we would see

00:23:51,760 --> 00:23:54,800
before we see it in any of the major browsers?

00:23:54,800 --> 00:23:58,000
(Melinda Shore) Yeah, I think -- you know,

00:23:58,000 --> 00:24:01,840
I'm hoping that we can actually have a beta.

00:24:02,720 --> 00:24:05,220
I'm hoping we can have something out in Firefox

00:24:05,220 --> 00:24:09,440
within about six months or so that will do the DNSSEC extension,

00:24:09,440 --> 00:24:13,660
and that'll enable DANE and DNSSEC and some of these other technologies.

00:24:13,660 --> 00:24:17,740
Right now, I mean, the browser vendors are so sensitive to latency,

00:24:17,740 --> 00:24:19,900
and you can't blame them, so...

00:24:19,900 --> 00:24:21,720
(audience member) Thank you.

00:24:22,440 --> 00:24:27,040
(audience member) The Blue Coat CA cert,

00:24:27,049 --> 00:24:31,410
could that then further issue more CA certificates?

00:24:31,410 --> 00:24:35,000
And what would be the repercussions if that sort of got out?

00:24:35,000 --> 00:24:36,940
(Melinda Shore) This specific certificate

00:24:36,940 --> 00:24:39,690
cannot issue additional CA certificates

00:24:39,690 --> 00:24:43,420
because it's got -- I don't know how much you guys know about PKI

00:24:43,420 --> 00:24:48,500
and what's in the X.509 certs, but it's got a path length of zero,

00:24:48,500 --> 00:24:52,800
which means that it can only issue end entity certificates.

00:24:52,800 --> 00:24:55,960
But, you know, this is -- the attack is a broad one

00:24:55,960 --> 00:24:59,440
and somebody else could issue one with no path length,

00:24:59,440 --> 00:25:01,740
which means that anybody under them could -- you know,

00:25:01,740 --> 00:25:03,600
they could issue CA certificates.

00:25:03,600 --> 00:25:06,960
Right now, this specific certificate cannot.

00:25:06,960 --> 00:25:08,820
(audience member) I guess, what would the protocol be

00:25:08,820 --> 00:25:11,580
if something somewhere under the Symantec tree

00:25:11,580 --> 00:25:13,320
leaked with that ability.

00:25:13,320 --> 00:25:15,440
Would that invalidate everything up to the top?

00:25:15,440 --> 00:25:17,240
(Melinda Shore) I'm sorry?

00:25:17,240 --> 00:25:20,380
(audience member) If somewhere under Symantec's tree,

00:25:20,380 --> 00:25:25,980
a CA with no path line was leaked, would they generally then

00:25:25,980 --> 00:25:30,140
have to invalidate everything up to the top?

00:25:31,580 --> 00:25:33,520
(Melinda Shore) What happens is,

00:25:33,520 --> 00:25:35,900
the path length is checked as part of the validation,

00:25:35,900 --> 00:25:38,100
and it starts at the bottom, and as soon as you hit

00:25:38,100 --> 00:25:41,680
an invalid path length, you're done. It's no longer valid.

00:25:41,680 --> 00:25:45,100
So, typically CA certificates do not contain path lengths,

00:25:45,100 --> 00:25:49,620
I believe, but I'm not really sure. I mean, it's not really

00:25:49,620 --> 00:25:53,520
that heavily used, that particular field.

00:25:53,520 --> 00:25:56,940
So we were kind of surprised to see it in the Blue Coat cert,

00:25:56,940 --> 00:25:58,860
and it was just one of these things that makes you wonder

00:25:58,860 --> 00:26:01,300
what the heck they're doing and why they would issue

00:26:01,300 --> 00:26:03,620
a certificate that looked like that.

00:26:08,740 --> 00:26:11,240
(audience member) Hey, quick question.

00:26:11,240 --> 00:26:14,760
So you said that you have to trust somebody,

00:26:14,760 --> 00:26:19,120
and currently we have the CA trust system.

00:26:19,120 --> 00:26:22,480
With DNSSEC, it wasn't entirely clear to me

00:26:22,480 --> 00:26:26,040
who we're trusting there and why they are more trustworthy

00:26:26,040 --> 00:26:28,900
than the current checks and balances we have.

00:26:28,900 --> 00:26:32,360
(Melinda Shore) Sure. Typically, when a DNSSEC record

00:26:32,360 --> 00:26:37,660
is going to be signed by a zone -- by the domain that owns --

00:26:37,660 --> 00:26:40,580
I mean, basically, you're going to be signing your own records, right?

00:26:40,580 --> 00:26:43,960
Your key is going to be signed by your parent zone and so on,

00:26:43,960 --> 00:26:47,500
up to the the root zone.

00:26:47,500 --> 00:26:52,240
And this is an intuitive thing,

00:26:52,240 --> 00:26:54,820
I don't think you can really prove it, but the assumption here

00:26:54,820 --> 00:26:57,860
is that people are going -- not -- people are going to be disinclined

00:26:57,860 --> 00:27:03,080
to make false assertions about their own records, right?

00:27:03,080 --> 00:27:06,060
And they're not going -- you know, if I'm nomountain.net,

00:27:06,060 --> 00:27:10,720
I cannot make assertions about google.com because it won't validate.

00:27:11,360 --> 00:27:14,000
So there's a little -- it's a little bit cleaner.

00:27:14,000 --> 00:27:15,960
But again, you know, the assumption is

00:27:15,960 --> 00:27:19,000
that a CA is going to tend to be

00:27:19,000 --> 00:27:22,180
more problematic to deal with in terms of validating signatures

00:27:22,180 --> 00:27:25,840
and in terms of legitimacy of relationship

00:27:25,840 --> 00:27:29,260
than you are about yourself.

00:27:29,260 --> 00:27:38,000
I mean, how -- if you are blah.co.uk,

00:27:38,000 --> 00:27:41,700
how does -- how would a .com --

00:27:41,700 --> 00:27:44,740
how would a CA in the .com domain

00:27:44,750 --> 00:27:48,200
be entitled to issue certificates to you?

00:27:48,200 --> 00:27:53,400
I mean, how is anybody entitled to issue certificates to you?

00:27:53,400 --> 00:27:56,540
That's the basic problem here is we don't really know

00:27:56,540 --> 00:28:00,060
what the relationships are when a certificate is issued.

00:28:00,060 --> 00:28:03,260
We, you know, we can assume that a CA has good practice,

00:28:03,260 --> 00:28:06,520
but that's really a business question and not a technical one.

00:28:07,040 --> 00:28:10,180
(audience member) So if I have a .io, for instance,

00:28:10,180 --> 00:28:15,840
then is that as trustworthy as having a CA cert

00:28:15,840 --> 00:28:18,480
that's maybe in the Firefox store?

00:28:18,480 --> 00:28:20,400
(Melinda Shore) Well it's -- you're going to be --

00:28:20,400 --> 00:28:23,780
you're going to be making assertions about your own records,

00:28:23,780 --> 00:28:25,660
and you're not going to be making assertions

00:28:25,660 --> 00:28:29,280
about anybody else's records because they won't validate, right?

00:28:29,280 --> 00:28:34,900
Whereas a commercially purchased certificate from a CA,

00:28:34,900 --> 00:28:37,580
we don't know what the relationship between you and them is

00:28:37,580 --> 00:28:39,980
or if it's even valid.

00:28:39,980 --> 00:28:43,560
You know, there have been instances of CAs issuing

00:28:43,560 --> 00:28:46,660
microsoft.com certificates and google.com certificates

00:28:46,660 --> 00:28:50,280
to entities other than Microsoft and Google.

00:28:50,280 --> 00:28:52,400
And there's no way in the PKI system --

00:28:52,400 --> 00:28:54,900
well, there are name constraints but they're not heavily used.

00:28:54,900 --> 00:28:58,340
But, you know, it's -- the current PKI system

00:28:58,340 --> 00:29:01,660
doesn't really support expressing that relationship,

00:29:01,660 --> 00:29:03,440
which is a trust one.

00:29:03,440 --> 00:29:05,240
(audience member) OK, thanks.

00:29:05,960 --> 00:29:08,000
(host) I think we have time for one more question.

00:29:08,000 --> 00:29:09,920
(Melinda Shore) Yeah, I'll be around afterwards

00:29:09,920 --> 00:29:12,400
if people want to chat.

00:29:13,620 --> 00:29:15,520
(audience member) Is there some responsible group

00:29:15,520 --> 00:29:18,040
or entity or volunteer project or something

00:29:18,040 --> 00:29:21,860
that's monitoring the collective set of CA certificates

00:29:21,860 --> 00:29:23,720
that are going out with all the browsers

00:29:23,720 --> 00:29:25,620
and the JVMs and everything?

00:29:25,620 --> 00:29:27,520
(Melinda Shore) Yeah, there's something called

00:29:27,520 --> 00:29:29,460
the CAB Forum, the CA and Browser Forum,

00:29:29,460 --> 00:29:33,200
and they tend to be the ones who are setting policy around this stuff.

00:29:33,200 --> 00:29:36,340
It's -- of course, compliance is always voluntary, right?

00:29:36,340 --> 00:29:39,280
And since the incentives for behaving badly

00:29:39,280 --> 00:29:42,140
are pretty high, we need mechanisms

00:29:42,140 --> 00:29:46,120
to number one, mitigate those and number two, monitor those,

00:29:46,120 --> 00:29:49,960
and the latter of which is what certificate transparency is all about.

00:29:51,320 --> 00:29:54,820
So anyway, I will put the slides up somewhere

00:29:54,820 --> 00:29:58,200
and tweet it and make those available

00:29:58,200 --> 00:30:01,600
so that you'll have the URLs to get the software.

00:30:01,600 --> 00:30:03,720
And as I said, I'm really curious about how you all feel

00:30:03,720 --> 00:30:08,280
about docker and what facilities you would find useful

00:30:08,280 --> 00:30:11,060
as application and developers and systems programmers.

00:30:11,060 --> 00:30:13,320
So, thank you very much. I really appreciate your time.

00:30:13,320 --> 00:30:19,220

YouTube URL: https://www.youtube.com/watch?v=-BtIQ3brsIY


