Title: Paul Kehrer - Reliably Distributing Compiled Modules - PyCon 2016
Publication date: 2016-06-01
Playlist: PyCon 2016
Description: 
	Speaker: Paul Kehrer

Shipping Python libraries is easy! ...until you want to use a C library. How do you easily and reliably deliver software to users when they may not have the libraries you depend on, or even a compiler? How do you handle the significant differences between linux, OS X, Windows, FreeBSD, and other platforms Python runs on?

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:04,840 --> 00:00:07,320
Alright, so, hello and welcome.

00:00:07,320 --> 00:00:09,180
We're here to talk about reliably distributing compiled modules.

00:00:09,180 --> 00:00:13,320
Following Glyph is a tough act, so for the sake of courtesy

00:00:13,320 --> 00:00:16,260
please hold your snores until the end of the talk.

00:00:17,860 --> 00:00:19,060
So who am I?

00:00:19,060 --> 00:00:20,840
Well, I'm Paul Kehrer.

00:00:20,840 --> 00:00:24,900
I write software, sometimes I kiteboard, and I enjoy baking things.

00:00:24,900 --> 00:00:30,320
I am an inveterate Simpsons quoter and this is a thing that may be relevant.

00:00:30,320 --> 00:00:33,540
I am reaperhulk on Twitter, I am reaperhulk on freenode,

00:00:33,540 --> 00:00:36,930
I am reaperhulk on GitHub, and you get the idea.

00:00:38,680 --> 00:00:41,160
So what do I work on?

00:00:41,160 --> 00:00:44,860
As an employee of Rackspace I do occasionally work on things for my employer.

00:00:44,860 --> 00:00:46,640
Rackspace Managed Security.

00:00:46,640 --> 00:00:50,000
I see my co-workers laughing; maybe they don't agree with that statement.

00:00:50,000 --> 00:00:51,480
[laughter]

00:00:51,480 --> 00:00:54,990
I also work on the Python Cryptographic Authority, the PyCA,

00:00:54,990 --> 00:01:00,420
on the project's cryptography, pyOpenSSL, PyNaCl, bcrypt,

00:01:00,420 --> 00:01:02,510
but mostly cryptography.

00:01:02,510 --> 00:01:07,760
And then I also co-wrote Frinkiac, which is a separate talk.

00:01:09,120 --> 00:01:10,920
So what do we want to do?

00:01:10,920 --> 00:01:13,740
We want to install some software.

00:01:13,740 --> 00:01:17,280
Well, Python is simple and all you need is pip, right?

00:01:17,289 --> 00:01:21,689
Ultimately all we want is upon typing pip install your package,

00:01:21,689 --> 00:01:27,009
we get the software we want without errors and preferably reasonably quickly.

00:01:27,009 --> 00:01:29,719
In other words, we want compiled or binary modules

00:01:29,719 --> 00:01:33,229
to act like regular Python and just work.

00:01:33,229 --> 00:01:36,479
For the purposes of this talk and inflating my own ego,

00:01:36,479 --> 00:01:39,310
we'll be using cryptography as a demo of our user experience

00:01:39,310 --> 00:01:41,280
with compiled modules.

00:01:42,440 --> 00:01:45,060
But what actually is a compiled module?

00:01:45,060 --> 00:01:50,340
Well, facetiously, it is any module that uses binary code.

00:01:50,340 --> 00:01:55,619
But perhaps more usefully it's a module that calls code not written in Python.

00:01:55,619 --> 00:01:58,439
In some cases this might actually be code that simply dlopened,

00:01:58,439 --> 00:02:01,969
so no compilation is required.

00:02:01,969 --> 00:02:03,999
But in the majority of cases it will be some C code

00:02:03,999 --> 00:02:07,439
that needs to be compiled using GCC or Clang,

00:02:07,439 --> 00:02:10,090
which in turn calls system libraries or other bundle libraries

00:02:10,090 --> 00:02:12,300
that are also typically compiled C code.

00:02:12,300 --> 00:02:14,200
It doesn't have to be C.

00:02:14,200 --> 00:02:16,560
In fact, I'm sure Cory is thinking, "Why not compile it to Rust,"

00:02:16,560 --> 00:02:21,200
or some of the other people are going, "Oh, but Go can target the C ABI now."

00:02:21,200 --> 00:02:23,160
So, you can actually use those as well,

00:02:23,160 --> 00:02:25,600
but the C ABI, which is the application binary interface,

00:02:25,600 --> 00:02:30,740
is generally the lingua franca for FFI, which is foreign function interface.

00:02:30,740 --> 00:02:33,220
Common ways to write the type of compiled modules

00:02:33,220 --> 00:02:35,040
we're going to care about here today

00:02:35,040 --> 00:02:38,340
include the C Python C API and CFFI.

00:02:40,200 --> 00:02:43,700
So, let's install some software on a Linux VM.

00:02:43,700 --> 00:02:47,140
We're going to use Ubuntu 14.04 with the latest pip in a virtual environment

00:02:47,140 --> 00:02:51,370
because we're up-to-date developers but forgot 16.04 was out.

00:02:51,370 --> 00:02:54,700
We're also experienced people and know that we need a compiler probably,

00:02:54,700 --> 00:02:58,260
so we type the magic incantation needed for that on our platform.

00:02:58,260 --> 00:03:01,780
So that would be apt-get install build-essential on Ubuntu or Debian derivatives

00:03:01,780 --> 00:03:04,340
or something like yum install make automate gcc

00:03:04,340 --> 00:03:06,220
on RHEL or CentOS.

00:03:07,220 --> 00:03:09,480
Alright, let's install it.

00:03:10,160 --> 00:03:13,880
Oh, that clearly did not work.

00:03:13,890 --> 00:03:15,860
But actually as you can see from the snip markers

00:03:15,860 --> 00:03:18,560
that's been simplified to actually show the relevant error.

00:03:18,560 --> 00:03:21,830
The real error looks more like this.

00:03:21,830 --> 00:03:25,780
Well, we're almost there.

00:03:25,780 --> 00:03:28,340
Oh, I can see it says compilation terminated.

00:03:28,340 --> 00:03:31,840
Ah, okay, there we go.

00:03:31,840 --> 00:03:34,420
So, what went wrong?

00:03:34,420 --> 00:03:38,440
Well as you saw in the snipped area Python.h was not there.

00:03:38,440 --> 00:03:41,560
Python.h is the primary include header for Python itself.

00:03:41,560 --> 00:03:45,180
We're experienced people, so we know how to solve this.

00:03:45,180 --> 00:03:48,190
As you can see it says so right there.

00:03:48,190 --> 00:03:49,900
[laughter]

00:03:49,900 --> 00:03:53,980
Admittedly I might not be all that skilled at drawing arrows.

00:03:53,980 --> 00:03:58,170
So, we'll install the Python development headers which we naturally know are named

00:03:58,170 --> 00:04:03,140
python-dev, or python-devel if you're on a Red Hat derived distribution.

00:04:03,140 --> 00:04:05,460
And how about now?

00:04:05,460 --> 00:04:07,930
Well, not quite.

00:04:07,930 --> 00:04:10,580
But fortunately we're all ops and C toolchain experts,

00:04:10,580 --> 00:04:13,990
so, this is clearly because we're missing the libffi development headers

00:04:13,990 --> 00:04:17,489
and CFFI uses libffi to be able to do this.

00:04:17,489 --> 00:04:20,680
So, a trifle; we know that we can go ahead and install libffi.

00:04:21,800 --> 00:04:24,440
Yeah, so we install our libffi development headers.

00:04:26,080 --> 00:04:28,660
This time, mmm.

00:04:28,660 --> 00:04:30,500
Still nothing, come on.

00:04:30,500 --> 00:04:35,180
Well, we've come this far and I refuse to let a computer beat me.

00:04:35,190 --> 00:04:38,400
So let's go find the OpenSSL development requirements.

00:04:38,400 --> 00:04:40,450
So, we just go ahead and install those.

00:04:40,450 --> 00:04:42,860
Oh wait, sorry, wrong operating system.

00:04:42,860 --> 00:04:44,100
[laughter]

00:04:44,100 --> 00:04:45,980
There we go.

00:04:45,980 --> 00:04:47,760
Or was it that?

00:04:47,760 --> 00:04:50,020
Or maybe even that?

00:04:51,280 --> 00:04:53,380
Alright; well, either way,

00:04:53,390 --> 00:04:56,400
let's try and install it one final time.

00:04:56,400 --> 00:04:57,940
Success!

00:04:57,940 --> 00:04:59,710
We've actually managed to install it.

00:04:59,710 --> 00:05:01,520
So, terrific; problem solved.

00:05:01,520 --> 00:05:04,330
You all know how to do this now; we can just move on.

00:05:05,200 --> 00:05:08,300
Well, what are the real prerequisites?

00:05:08,300 --> 00:05:12,870
We guessed we'd need a compiler, but what actually is required?

00:05:12,870 --> 00:05:16,490
In the abstract you're going to need a compiler, which we knew.

00:05:16,490 --> 00:05:19,710
But that's typically, but not guaranteed, to be something like GCC, Clang,

00:05:19,710 --> 00:05:24,080
or on Windows it's going to be MSVC or occasionally MinGW.

00:05:25,360 --> 00:05:27,960
Libraries, if you're going to link against one.

00:05:27,960 --> 00:05:30,650
Headers, so the code can know what function signatures

00:05:30,650 --> 00:05:34,080
are actually available in the library.

00:05:34,080 --> 00:05:40,599
So, let's go through a few things on the primary three platforms of OS X, Windows, and Linux.

00:05:40,599 --> 00:05:42,770
Implicit in the following slides is an assumption

00:05:42,770 --> 00:05:45,370
that the user has root or admin privileges, by the way.

00:05:45,370 --> 00:05:50,080
If they do not then compiling a module may become extremely, extremely difficult.

00:05:51,520 --> 00:05:55,960
Alright, so on OS X, xcode-select --install.

00:05:55,960 --> 00:05:59,980
And this actually works even without administrative privileges.

00:05:59,980 --> 00:06:02,699
Except maybe your users are on something older than 10.9,

00:06:02,699 --> 00:06:05,860
and this is not as uncommon as it should be.

00:06:05,860 --> 00:06:09,350
Then they'll have to download an Xcode tools package from some legacy source

00:06:09,350 --> 00:06:13,900
which is usually deep in the bowels of developer.apple.com

00:06:13,900 --> 00:06:19,400
and you can only find it if you look at the right time in the third full moon.

00:06:19,400 --> 00:06:23,520
But let's assume for the moment you've got an actual functioning Xcode.

00:06:23,520 --> 00:06:28,160
But now, your software may depend on libraries that are outside the OS X default.

00:06:28,160 --> 00:06:31,880
In an ideal world, your setup.py somehow magically

00:06:31,880 --> 00:06:35,400
has all the code you need and will actually bootstrap the compile process,

00:06:35,400 --> 00:06:38,820
but of course that uses distutils and no one understands that,

00:06:38,820 --> 00:06:42,040
so it probably doesn't do that.

00:06:42,040 --> 00:06:44,520
So, if you don't have that then you're going to have to go ahead

00:06:44,520 --> 00:06:49,560
and install homebrew or macports as well so that the user has a package manager

00:06:49,560 --> 00:06:52,000
to install the additional dependencies they'll need.

00:06:52,000 --> 00:06:57,440
In cryptography's case, you'd need to brew install openssl in addition to xcode-select.

00:06:59,420 --> 00:07:02,040
Alright, on Windows.

00:07:02,040 --> 00:07:04,380
You need to download Visual Studio,

00:07:04,380 --> 00:07:07,200
or someone may choose MinGW as I previously mentioned

00:07:07,210 --> 00:07:10,889
and they will make your life very hard.

00:07:10,889 --> 00:07:12,820
For Python 2.7 the user will need

00:07:12,820 --> 00:07:16,500
the Microsoft Visual C++ Compiler for Python 2.7.

00:07:16,500 --> 00:07:19,580
For Python 3 & 4 you'll use Visual Studio 2010.

00:07:19,580 --> 00:07:24,040
And for Python 3.5 you'll use Visual Studio 2015.

00:07:24,040 --> 00:07:26,480
This fun thing we'll talk a little bit about later.

00:07:28,200 --> 00:07:30,500
Architecture also matters.

00:07:30,510 --> 00:07:34,610
There are 32-bit and 64-bit versions of Python available on Windows,

00:07:34,610 --> 00:07:38,610
which have surprisingly even usage models,

00:07:38,610 --> 00:07:41,490
and those require compilers of the corresponding architecture.

00:07:41,490 --> 00:07:44,270
And of course, just to complicate matters,

00:07:44,270 --> 00:07:50,240
Visual Studio 2010's free edition does not come with the 64-bit compilers.

00:07:50,240 --> 00:07:53,290
And of course, there's no package manager at all.

00:07:53,290 --> 00:07:55,669
So users are on their own building libraries from scratch

00:07:55,669 --> 00:07:58,180
if your package doesn't try to do it for them.

00:07:58,180 --> 00:08:01,080
It's an interesting experience attempting to use MSVC

00:08:01,080 --> 00:08:04,919
to compile libraries that claim to support Windows

00:08:04,920 --> 00:08:07,520
but have no tooling around it.

00:08:09,020 --> 00:08:11,180
So, we've covered what it takes to compile on Linux

00:08:11,181 --> 00:08:14,360
a little bit already in our experiment with installing cryptography.

00:08:14,360 --> 00:08:17,830
But to recap, on Linux each distribution has its own view

00:08:17,830 --> 00:08:20,920
of what packages provide the basic compiler tools,

00:08:20,920 --> 00:08:24,970
as well as its own opinion of what packages provide the required headers and libraries.

00:08:24,970 --> 00:08:28,870
So, unless you have someone who happens to just know

00:08:28,870 --> 00:08:33,139
what the package name differentials are or very good documentation,

00:08:33,140 --> 00:08:35,520
you're likely to end up Googling many things.

00:08:36,960 --> 00:08:40,340
But once you've done all that, there are still problems.

00:08:40,340 --> 00:08:42,200
When compiling modules,

00:08:42,200 --> 00:08:46,000
the C toolchain will look in standard locations for includes and libraries.

00:08:46,010 --> 00:08:50,310
If alternate software is installed separately to avoid conflict with system packages,

00:08:50,310 --> 00:08:56,120
then users may have to pass environment variables like CFLAGS or CPPFLAGS or LDFLAGS

00:08:56,120 --> 00:08:59,670
to make the compiler and linker look at the correct place.

00:08:59,670 --> 00:09:03,460
This is actually a specific requirement in the case of cryptography on OS X.

00:09:03,460 --> 00:09:07,660
usr/lib contains an existing libssl libcrypto implementation,

00:09:07,660 --> 00:09:09,860
but we don't want that because it's terrible.

00:09:09,870 --> 00:09:13,130
So, we want to link against the homebrew version,

00:09:13,130 --> 00:09:17,320
But that resides in something like usr/local/opt/openssl/lib,

00:09:17,320 --> 00:09:20,920
so we have to pass a bunch of extra flags to make this compile this way.

00:09:20,920 --> 00:09:26,600
On Linux you may need to also specify linker flags to set the r path

00:09:26,600 --> 00:09:28,620
so that it uses the right shared library

00:09:28,620 --> 00:09:31,820
because of the way namespacing and Linux SOs work.

00:09:31,820 --> 00:09:34,060
Or, you might even have to resort to things like

00:09:34,060 --> 00:09:36,940
LD_PRELOAD or LD_LIBRARY_PATH interposition.

00:09:39,180 --> 00:09:41,680
You might have unsupported library versions.

00:09:41,690 --> 00:09:44,141
The version of the library installed by the OS package manager

00:09:44,141 --> 00:09:48,390
may be too old or too new and thus unsupported by the Python module.

00:09:48,390 --> 00:09:50,830
The interfaces for any given library evolve over time

00:09:50,830 --> 00:09:54,550
and by necessity the Python bindings need to change with them.

00:09:54,550 --> 00:09:58,480
If they don't match then strange compilation errors may occur.

00:09:58,480 --> 00:10:02,070
This is especially common in OpenSSL security releases where ostensibly

00:10:02,070 --> 00:10:05,640
they don't change anything but in reality they change function signatures for no reason.

00:10:08,000 --> 00:10:10,700
Windows CRT and compiler restrictions.

00:10:10,700 --> 00:10:12,860
Remember how I said there are a lot of compilers there you needed

00:10:12,870 --> 00:10:15,680
for different versions of Python on Windows?

00:10:15,680 --> 00:10:18,740
This is a simple albeit onerous requirement.

00:10:18,740 --> 00:10:22,209
All the artifacts must have been compiled by the same compiler version.

00:10:22,209 --> 00:10:27,110
So, the module has to be compiled by the same compiler as Python itself was compiled with,

00:10:27,110 --> 00:10:31,540
and any libraries that may link against with are also bound by that same restriction.

00:10:33,260 --> 00:10:37,520
And finally, people do terrible things to their computers.

00:10:37,529 --> 00:10:40,279
Any number of crimes against a sane C build environment

00:10:40,280 --> 00:10:43,740
may have been committed in the past on a user's machine.

00:10:43,740 --> 00:10:47,060
Installers for projects will litter a user's file system with binary detritists

00:10:47,060 --> 00:10:50,600
and configs that may wreak havoc with your modules expectations.

00:10:50,600 --> 00:10:54,680
I remember one time when I -- years ago I installed MySQL on a Mac

00:10:54,680 --> 00:10:59,740
and it actually installed a DYLD library path into the bash profile.

00:10:59,740 --> 00:11:02,530
Automatically; it didn't tell you it was doing it.

00:11:02,530 --> 00:11:05,160
And these are the sort of things that work fine in isolation

00:11:05,160 --> 00:11:07,660
but can cause trouble with your build environments.

00:11:09,100 --> 00:11:12,620
So, obviously this is not reasonable.

00:11:12,630 --> 00:11:15,910
This is an unfortunately common experience for developers and end users

00:11:15,910 --> 00:11:20,220
and it just is not acceptable.

00:11:20,220 --> 00:11:24,460
Binary modules are currently causing a significant bifurcation of the user experience.

00:11:24,460 --> 00:11:26,690
On the one hand you have the good packages.

00:11:26,690 --> 00:11:29,920
Those are the pure Python ones where installation just works.

00:11:29,920 --> 00:11:34,709
And on the other hand you have the transcendentally awful binary packages

00:11:34,709 --> 00:11:36,610
that no one wants to add dependencies on

00:11:36,610 --> 00:11:38,500
because who knows what might break,

00:11:38,500 --> 00:11:41,140
and who knows what reports they're going to get?

00:11:41,140 --> 00:11:45,820
Because oh, you added this thing that doesn't work on my machine.

00:11:45,820 --> 00:11:50,860
Shockingly enough, despite what we just showed on the original Linux demo,

00:11:50,860 --> 00:11:54,120
other platforms, especially Windows, can be far more challenging

00:11:54,120 --> 00:11:56,220
to actually get things working.

00:11:57,220 --> 00:12:00,280
So, wouldn't it be nice if we could distribute pre-compiled software

00:12:00,280 --> 00:12:03,520
like the operating system package managers do?

00:12:03,520 --> 00:12:05,332
Then the users wouldn't have to know all of this

00:12:05,340 --> 00:12:07,120
just to use some software

00:12:07,120 --> 00:12:10,040
and the maintainers of said software wouldn't be inundated with issues

00:12:10,050 --> 00:12:12,060
that follow this sort of format.

00:12:12,060 --> 00:12:16,200
Or, to use the apparently 130 times better search engine.

00:12:17,140 --> 00:12:19,120
[laughter]

00:12:19,620 --> 00:12:22,940
So, of course the answer is wheels.

00:12:22,950 --> 00:12:26,700
With wheels, it can work as if there's no C magic inside.

00:12:26,700 --> 00:12:31,550
But of course, like any purported panacea there are a few significant caveats

00:12:31,550 --> 00:12:33,660
that we'll talk about a bit later.

00:12:35,380 --> 00:12:39,480
So, wheels are the modern Python package format.

00:12:39,480 --> 00:12:41,360
They are defined in quite a few PEPs.

00:12:41,370 --> 00:12:43,600
You are certainly welcome to read them.

00:12:43,600 --> 00:12:46,050
PEP 513 is actually one of the most interesting ones

00:12:46,050 --> 00:12:49,790
because it defines the manylinux1 format we'll be talking about a little bit later.

00:12:49,790 --> 00:12:54,520
They provide a way to distribute Python artifacts, both binary and non-binary, of course.

00:12:54,520 --> 00:12:57,670
They are superior in a variety of ways to eggs and sdists,

00:12:57,670 --> 00:13:00,540
although sdists still have their place.

00:13:00,540 --> 00:13:04,149
You will never get rid of them, and that's okay.

00:13:04,149 --> 00:13:07,589
They can install packages with binary dependencies sans root.

00:13:07,589 --> 00:13:10,019
For example, if you need to be able to install --

00:13:10,019 --> 00:13:15,230
imagine a world where you need to install a libsodium package, but you don't have root.

00:13:15,230 --> 00:13:18,610
It would be nice if you didn't have to get some authorization to

00:13:18,610 --> 00:13:23,339
sudo apt-get install libsodium-dev and instead you just typed pip install

00:13:23,339 --> 00:13:26,970
inside of your virtual environment and got what you needed.

00:13:26,970 --> 00:13:29,480
Of course, pip can both produce and install them.

00:13:29,480 --> 00:13:34,170
The pip wheel command, which is of course in conjunction with the wheel package itself.

00:13:34,170 --> 00:13:38,070
And wheels use tags to denote what a given wheel is compatible with.

00:13:38,070 --> 00:13:41,950
You can see that long message the cryptography wheel is which is basically

00:13:41,950 --> 00:13:46,160
the name of the package, the version, the version of Python,

00:13:46,160 --> 00:13:50,280
the SOABI of the Python which we'll talk about a bit later,

00:13:50,280 --> 00:13:53,840
the Mac OS X SDK version, and then the architecture.

00:13:55,900 --> 00:13:58,320
So, we have now reached the part of the talk

00:13:58,329 --> 00:14:01,880
where I theoretically actually impart useful information instead of esoterica

00:14:01,880 --> 00:14:04,340
that you can blindly forget immediately.

00:14:06,420 --> 00:14:09,700
So the questions for your project, if you want to build wheels.

00:14:09,700 --> 00:14:12,540
What platforms do you care about?

00:14:12,540 --> 00:14:14,620
In general, for building binary wheels,

00:14:14,620 --> 00:14:17,680
you should at minimum care about OS X and Windows.

00:14:17,680 --> 00:14:21,980
They are the most popular non-Linux platforms and PyPI supports uploading wheels for both.

00:14:23,280 --> 00:14:28,780
Manylinux1 now means that you can also potentially supply binary wheels for Linux users,

00:14:28,780 --> 00:14:30,860
but there are some caveats that we'll get into.

00:14:33,100 --> 00:14:36,140
What versions of Python do you care about?

00:14:36,140 --> 00:14:38,100
Do you care about Python 2.6?

00:14:38,100 --> 00:14:41,320
Do you care about Python 3 but less than 3.3?

00:14:41,320 --> 00:14:43,700
Please don't care about either of those, but maybe you do.

00:14:43,700 --> 00:14:45,640
What about PyPI?

00:14:45,640 --> 00:14:48,160
The answer to this combined with the platform question

00:14:48,160 --> 00:14:52,240
gives you almost the number of wheels you'll need to build.

00:14:52,240 --> 00:14:56,500
More Pythons means more wheels and significantly more infrastructure complexity

00:14:56,510 --> 00:15:00,079
if you're supporting Windows due to the multiple MSVC requirement.

00:15:00,080 --> 00:15:04,440
For reference, cryptography currently uploads 21 wheels to PyPI,

00:15:04,440 --> 00:15:06,580
but our requirements are somewhat extreme.

00:15:08,860 --> 00:15:12,100
Can you rely on the library you need to be present on all platforms?

00:15:12,100 --> 00:15:14,500
In some cases that answer will actually be yes,

00:15:14,500 --> 00:15:16,860
and then all you have is basically the glue code

00:15:16,860 --> 00:15:20,480
that dlopens the library or links against it.

00:15:20,480 --> 00:15:23,800
But if not, and the answer is probably no,

00:15:23,800 --> 00:15:26,350
you'll need to make some decisions on how you want to ship it.

00:15:26,350 --> 00:15:30,400
If you want an identical experience across all platforms,

00:15:30,400 --> 00:15:33,220
then you will need to bundle your library

00:15:33,230 --> 00:15:37,320
with all the additional maintenance burden that that implies.

00:15:37,320 --> 00:15:39,730
You may also have unusual dependencies,

00:15:39,730 --> 00:15:43,149
like optionally binding to system libraries for only specific OS releases,

00:15:43,149 --> 00:15:45,780
and that may affect the way you have to build your wheels.

00:15:47,180 --> 00:15:49,060
So what's required?

00:15:49,060 --> 00:15:51,960
Well, obviously you're going to need an OS X machine.

00:15:51,970 --> 00:15:56,060
Any recent release will do, but you should really be on El Capitan.

00:15:56,060 --> 00:15:59,680
There's no excuse not to be; it doesn't cost any money.

00:15:59,680 --> 00:16:02,960
Assuming you don't have an OS X version-specific dependencies,

00:16:02,960 --> 00:16:07,800
you can build wheels that work for pretty much any user on 10.6 or above.

00:16:07,800 --> 00:16:09,940
Since you're going to want to automate this,

00:16:09,940 --> 00:16:12,460
it's not a great idea for this to be your laptop.

00:16:12,460 --> 00:16:16,700
Instead, consider using a hosted machine from something like MacStadium or Macminicolo

00:16:16,700 --> 00:16:18,440
or things like that.

00:16:18,440 --> 00:16:21,920
You can set them up with ESXi and then you can put Mac VMs on.

00:16:21,930 --> 00:16:24,100
That's actually legitimate; that's actually legal.

00:16:24,100 --> 00:16:26,820
So, those are all good ways to do that stuff.

00:16:29,380 --> 00:16:31,730
There are of course challenges, right?

00:16:31,730 --> 00:16:34,670
This is not a panacea; it has problems.

00:16:34,670 --> 00:16:37,519
There are OS X SDK versions, there are universal wheels,

00:16:37,520 --> 00:16:41,520
and there are UCS2 vs UCS4 ABI issues.

00:16:41,520 --> 00:16:48,020
So, to handle OS X SDK issues, make sure you build against python.org Pythons.

00:16:48,030 --> 00:16:51,779
Not pyenv and not system python.

00:16:51,780 --> 00:16:53,900
Why python.org Pythons?

00:16:53,900 --> 00:16:57,800
python.org releases are linked against the 10.6 SDK.

00:16:57,810 --> 00:17:01,329
This is a little bit less relevant than it used to be, but you can't install

00:17:01,329 --> 00:17:04,380
an OS X wheel with an SDK tag newer than the OS

00:17:04,380 --> 00:17:06,230
that you're currently running.

00:17:06,230 --> 00:17:10,870
By using python.org Pythons, you can neatly sidestep this issue,

00:17:10,870 --> 00:17:15,720
unless you want to link against OS X features added in 10.7+, like Common Crypto,

00:17:15,720 --> 00:17:18,320
which is a system crypto service we use in cryptography,

00:17:18,320 --> 00:17:21,740
which kind of is the callback to why we have 21 current wheels.

00:17:23,900 --> 00:17:26,340
For universal wheels.

00:17:26,340 --> 00:17:31,299
Universal is Apple's shorthand for binaries or libraries containing multiple architectures.

00:17:31,299 --> 00:17:33,250
On OS X technically a universal library

00:17:33,250 --> 00:17:38,440
can contain PowerPC, PowerPC 64, x86, and x86_x64 code,

00:17:38,440 --> 00:17:42,380
but given that the x86 transition for OS X is now a decade in the past

00:17:42,380 --> 00:17:46,630
we're going to sweep that PowerPC stuff under the rug and move on.

00:17:46,630 --> 00:17:52,160
To create a universal wheel, you need both the universal Python and universal libraries.

00:17:52,160 --> 00:17:55,540
Universal wheels will work with universal Pythons

00:17:55,540 --> 00:18:00,120
as well as x86_64-only Pythons and x86-only Pythons

00:18:00,120 --> 00:18:02,200
if you can find any like that.

00:18:04,440 --> 00:18:08,380
Fortunately, python.org Python releases are already built universally,

00:18:08,380 --> 00:18:11,540
so they handle both the SDK and the universal question quite neatly.

00:18:13,220 --> 00:18:16,179
But, if you're linking against another library,

00:18:16,179 --> 00:18:18,950
you will need those libraries to also be universal.

00:18:18,950 --> 00:18:25,460
You can check that with a, uh, aptly named command, lipo.

00:18:25,460 --> 00:18:27,660
So, lipo -info and /path/to/lib will give you

00:18:27,660 --> 00:18:29,500
the information about what architectures

00:18:29,500 --> 00:18:32,550
are present in a given binary or library.

00:18:32,550 --> 00:18:35,900
Many homebrew libraries already ship as universal libraries,

00:18:35,900 --> 00:18:38,170
but sometimes you do have to do it yourself.

00:18:38,170 --> 00:18:41,000
In that case there are a pile of flags to pass

00:18:41,000 --> 00:18:43,140
and it may not actually work inside of homebrew,

00:18:43,140 --> 00:18:44,940
so you may have to build it yourself,

00:18:44,940 --> 00:18:47,600
and that's probably getting a bit out of the scope of this talk.

00:18:47,600 --> 00:18:49,610
You can, however, check cryptography's docs

00:18:49,610 --> 00:18:53,090
which is at cryptography.io in the "doing a release" section,

00:18:53,090 --> 00:18:55,000
and you can see the way we rebuild OpenSSL

00:18:55,000 --> 00:18:59,340
to make sure that we have a universal binary for our purposes.

00:19:01,140 --> 00:19:03,580
Finally, we have UCS2 and UCS4.

00:19:03,580 --> 00:19:08,560
So, if you've seen Symbol not found: _PyUnicodeUCS2_AsASCIIString

00:19:08,560 --> 00:19:11,840
you have already stubbed your toe on this problem.

00:19:11,840 --> 00:19:13,880
It's only recently started cropping up on OS X.

00:19:16,570 --> 00:19:21,460
The reason it came about is that Python has two ways to compile Unicode support in 2.x,

00:19:21,460 --> 00:19:26,180
and in less than 3.23 but we don't care about those releases, remember?

00:19:26,180 --> 00:19:28,980
So UCS2, which is sometimes known as narrow Unicode,

00:19:28,980 --> 00:19:33,169
and UCS4, sometimes known as wide Unicode, are two different ways to compile things.

00:19:33,169 --> 00:19:37,669
But the resulting Python has a different ABI which means we need different wheels.

00:19:37,669 --> 00:19:42,610
However, pip and wheel did not have a tag for this behavior until very recently.

00:19:42,610 --> 00:19:45,900
Pip 8.1 was the very first one that had it.

00:19:45,900 --> 00:19:49,480
On the OS X side the system Python is built as UCS2.

00:19:49,480 --> 00:19:51,840
Python.org is built as UCS2.

00:19:51,840 --> 00:19:54,180
Homebrew Python is built as UCS2, and they made

00:19:54,180 --> 00:19:57,290
an explicit decision to do so back in 2014.

00:19:57,290 --> 00:20:00,740
But pyenv just switched recently.

00:20:00,740 --> 00:20:03,960
The reason they did this is because pyenv is actually used

00:20:03,960 --> 00:20:05,960
on more than just OS X.

00:20:05,960 --> 00:20:11,960
So, with the advent of manylinux1 wheels, UCS4 is the common way it's compiled on Linux,

00:20:11,960 --> 00:20:14,039
so they wanted to be able to share wheels with

00:20:14,040 --> 00:20:18,240
pyenv on Linux and also system Pythons on Linux.

00:20:18,240 --> 00:20:20,179
So that's an issue that they solve on their end

00:20:20,179 --> 00:20:23,730
but actually adds an additional permutation on the OS X side.

00:20:23,730 --> 00:20:26,060
So we need to care about that configuration as well.

00:20:26,060 --> 00:20:27,971
The way we handle that is we go ahead and have

00:20:27,971 --> 00:20:30,440
one pyenv in Python 2.7

00:20:30,440 --> 00:20:32,580
that you use to handle this case.

00:20:33,340 --> 00:20:37,080
So, to recap, what's required to cover OS X users

00:20:37,090 --> 00:20:41,240
is Pythons from python.org, one pyenv Python 2.7,

00:20:41,240 --> 00:20:44,140
and the patience to understand all of these permutations.

00:20:46,410 --> 00:20:51,120
On Windows, you should make your life simple by building a separate VM

00:20:51,130 --> 00:20:53,690
for 32-bit vs 64-bit Python.

00:20:53,690 --> 00:20:55,740
You can try installing them all in one system

00:20:55,740 --> 00:20:58,740
but tools like tox have expectations of where they're going to find Python

00:20:58,740 --> 00:21:02,260
and it will make your life much, much easier to just let them have their way.

00:21:04,180 --> 00:21:06,840
We've already kind of gone through the way the compilers work for this,

00:21:06,840 --> 00:21:09,920
but effectively you'll need to install all these different compilers,

00:21:09,920 --> 00:21:12,110
and unfortunately you're going to need to find

00:21:12,110 --> 00:21:14,270
the non-free version of Visual Studio 2010

00:21:14,270 --> 00:21:17,340
if you want to be able to do the 64-bit version.

00:21:17,340 --> 00:21:22,010
It's not all that hard to talk to Microsoft and get MSDN things for open source purposes,

00:21:22,010 --> 00:21:24,299
so that's one avenue you can choose.

00:21:24,300 --> 00:21:26,720
I'm certainly not advocating that you BitTorrent it.

00:21:26,720 --> 00:21:28,840
[laughter]

00:21:30,640 --> 00:21:33,140
Manylinux1 -- It's brand new!

00:21:33,140 --> 00:21:35,780
It allows you to ship binary wheels for Linux.

00:21:35,780 --> 00:21:37,520
It's great.

00:21:37,520 --> 00:21:39,380
The team behind manylinux1 has done the hard work

00:21:39,380 --> 00:21:41,420
of constructing the build environment for you.

00:21:41,420 --> 00:21:48,530
So you can run the command you see right there without slash paths to Python code, obviously,

00:21:48,530 --> 00:21:52,370
and then run pip wheel inside of that against the variety of Pythons

00:21:52,370 --> 00:21:55,270
that live in that docker image to generate your set of wheels.

00:21:55,270 --> 00:21:59,820
They even have an audit wheel package that will check the resulting wheels

00:21:59,820 --> 00:22:03,590
to see if they comply with manylinux1's restrictions about which libraries

00:22:03,590 --> 00:22:05,789
are actually considered to be part of manylinux1,

00:22:05,789 --> 00:22:08,660
and the ones that aren't, it will automatically copy them in

00:22:08,660 --> 00:22:11,210
and then fix the r path up to automatically load

00:22:11,210 --> 00:22:13,400
those libraries for you properly.

00:22:13,400 --> 00:22:15,760
It's very nice.

00:22:15,760 --> 00:22:20,800
And of course, github.com/pypa/manylinx has many examples of exactly how to use it.

00:22:20,800 --> 00:22:22,860
That's a talk all to itself,

00:22:22,860 --> 00:22:25,210
so unfortunately I couldn't go in too much depth there.

00:22:25,720 --> 00:22:29,320
Finally, you need to have some automation.

00:22:29,320 --> 00:22:31,190
I mentioned earlier that automation was a thing

00:22:31,190 --> 00:22:33,220
you'd probably desire, but without automation

00:22:33,220 --> 00:22:37,780
as you can see this process is complex, finicky, and will result in errors.

00:22:37,780 --> 00:22:39,260
It just will.

00:22:39,260 --> 00:22:42,020
Rather than doing it by hand you should have something that is kicked off

00:22:42,020 --> 00:22:45,669
during your release process to automatically build them.

00:22:45,669 --> 00:22:48,980
In cryptography we use a Jenkins job that is triggered by an invoke command

00:22:48,980 --> 00:22:50,740
during our release process.

00:22:50,750 --> 00:22:54,340
The job builds and archives the wheels, and then the invoke task automatically

00:22:54,340 --> 00:22:57,080
downloads them and uploads them via twine to PyPI.

00:22:57,080 --> 00:23:00,490
As part of that we also actually import the wheels after generating them

00:23:00,490 --> 00:23:03,520
in a separate virtual environment to make sure they actually work,

00:23:03,520 --> 00:23:05,600
because we have had an instance in the past

00:23:05,600 --> 00:23:07,460
where we managed to build wheels

00:23:07,460 --> 00:23:09,420
that didn't actually work and put them on PyPI,

00:23:09,429 --> 00:23:11,230
and it turns out you don't want to do that.

00:23:11,230 --> 00:23:13,520
So, I can't stress this enough.

00:23:13,520 --> 00:23:16,000
Automate this or you will make mistakes.

00:23:17,080 --> 00:23:21,280
Alright, so I promised you caveats, and here they are.

00:23:21,280 --> 00:23:23,340
Users need the right versions of pip.

00:23:23,350 --> 00:23:26,880
Since the wheel tags that have only been recently finalized for manylinux1

00:23:26,880 --> 00:23:32,180
and the wide narrow unicode ABIs many users do not yet have the necessary versions.

00:23:32,180 --> 00:23:36,260
Based on the PyPI logs you can search on Google BigQuery --

00:23:36,260 --> 00:23:39,200
which you should all do; it's really cool --

00:23:39,200 --> 00:23:42,210
we can say that OS X pip tends to be far more up to date

00:23:42,210 --> 00:23:46,840
while Linux users are more likely to stick with their distributions pip.

00:23:46,840 --> 00:23:50,660
And then anecdotally we have seen a reasonable amount of success

00:23:50,660 --> 00:23:54,140
shipping modern wheel tags to our OS X users in cryptography

00:23:54,140 --> 00:23:58,000
while we're still thinking about what we want to do on the manylinux1 side.

00:23:59,780 --> 00:24:02,900
So, as I said previously, if the library you're using isn't guaranteed available

00:24:02,900 --> 00:24:05,090
you're going to have to bundle it.

00:24:05,090 --> 00:24:09,250
This bundling can be accomplished by either static linking or copying the dynamic library,

00:24:09,250 --> 00:24:12,870
but now you the wheel builder are on the hook for updating your package

00:24:12,870 --> 00:24:15,280
every time your upstream dependency changes,

00:24:15,280 --> 00:24:19,610
and your users are on the hook for knowing they need to update as well.

00:24:19,610 --> 00:24:22,830
For example, on OpenSSL this is an unpleasant issue.

00:24:22,830 --> 00:24:27,730
As users of a hypothetical manylinux1 wheel that links against libssl may not realize

00:24:27,730 --> 00:24:29,720
that when they upgraded their distributions package

00:24:29,720 --> 00:24:34,220
to close whatever CV was discovered in OpenSSL,

00:24:34,220 --> 00:24:38,190
it didn't update what their Python code was actually using.

00:24:38,190 --> 00:24:40,690
It may be possible to somewhat avoid this issue in the future

00:24:40,690 --> 00:24:42,840
if more Linux binary wheel tag types appear.

00:24:42,840 --> 00:24:46,960
There's been some discussion about one like an Ubuntu 16.04 or RHEL 7

00:24:46,960 --> 00:24:49,580
that allows you to say, well, the library will be provided

00:24:49,580 --> 00:24:52,480
by the underlying operating system, but it will still be a problem

00:24:52,500 --> 00:24:54,600
on OS X and Windows,

00:24:54,600 --> 00:24:59,280
and of course on Linux for anything that's not packaged by the OS in general.

00:24:59,280 --> 00:25:02,240
Unusual architectures are not supported by wheels on PyPI.

00:25:02,240 --> 00:25:06,900
So, your MIPS router and your open power systems will still have to compile it themselves.

00:25:06,900 --> 00:25:09,340
So even with all these wheels you're still going to have users

00:25:09,350 --> 00:25:11,870
that need to run through the full build process.

00:25:11,870 --> 00:25:15,210
So for the love of God, make sure it stays as good as it can be.

00:25:15,210 --> 00:25:18,040
It will also make your life easier in building your own wheels.

00:25:20,480 --> 00:25:25,200
There's also a download size and memory footprint increase potential risk.

00:25:25,200 --> 00:25:27,500
In large systems with many dependencies,

00:25:27,500 --> 00:25:29,680
an ecosystem where this sort of behavior is common

00:25:29,680 --> 00:25:33,240
may result in an increased memory footprint as well as a download size.

00:25:33,240 --> 00:25:35,340
It's unclear if this is going to be a significant issue

00:25:35,340 --> 00:25:39,030
outside of truly gigantic edifices like SciPy,

00:25:39,030 --> 00:25:42,300
but it is one to be aware of as we move into this brave new world.

00:25:44,100 --> 00:25:47,760
So, good luck, go forth, and build your wheels.

00:25:48,960 --> 00:25:55,920
[applause]

00:25:59,340 --> 00:26:01,200
(moderator) Alright.

00:26:01,200 --> 00:26:04,520
If there are any questions, stand up or raise your hand and I'll bring a microphone to you.

00:26:06,800 --> 00:26:08,800
(audience member 1) I think I missed something.

00:26:08,800 --> 00:26:10,780
What is manylinux, again?

00:26:10,780 --> 00:26:13,320
(Paul Kehrer) So, manylinux1 is a new tag that's --

00:26:13,320 --> 00:26:15,180
so, my apologies.

00:26:15,180 --> 00:26:17,360
I should have actually given a little more clarity on that.

00:26:17,360 --> 00:26:22,120
Manylinux1 is a new tag that's been added to the wheel standard that allows you to build

00:26:22,120 --> 00:26:26,140
binary wheels that work across many different versions of Linux.

00:26:26,140 --> 00:26:29,500
The way it actually works under the hood is kind of unpleasant

00:26:29,500 --> 00:26:34,159
but what that docker image is is actually a RHEL 5 version,

00:26:34,159 --> 00:26:36,350
and there's a set of acceptable libraries that

00:26:36,350 --> 00:26:39,059
everyone knows will be on pretty much every Linux,

00:26:39,059 --> 00:26:44,080
and so you can link against those dynamically and know that because the ABIs have been stable

00:26:44,080 --> 00:26:46,600
in the last several years that they will work going forward.

00:26:46,600 --> 00:26:48,440
So for example, basically they're linking against

00:26:48,440 --> 00:26:51,311
a really old glibc and knowing that the new glibc

00:26:51,311 --> 00:26:53,210
will work the same way.

00:26:53,210 --> 00:26:57,200
So it's a clever way to do it, but it has some interesting tradeoffs.

00:26:58,840 --> 00:27:01,460
(audience member 2) In the scientific field, conda is used a lot.

00:27:01,460 --> 00:27:03,540
Did you have a look at conda and maybe is there

00:27:03,540 --> 00:27:06,160
some way to work together with conda people?

00:27:06,160 --> 00:27:07,900
(Paul Kehrer) I'm sorry I couldn't quite catch that.

00:27:07,900 --> 00:27:10,480
(audience member 2) Conda is an installer that is used a lot

00:27:10,480 --> 00:27:12,200
in the scientific field.

00:27:12,200 --> 00:27:14,640
And just a question: Did you have a look at conda, how it works?

00:27:14,640 --> 00:27:17,160
Because it works for development, according to my experience.

00:27:17,169 --> 00:27:21,120
Maybe there's some way to use some -- conda is open source also,

00:27:21,120 --> 00:27:25,260
could reuse some of this -- what's in conda for these purposes.

00:27:25,260 --> 00:27:27,320
(Paul Kehrer) Yeah, so, the way conda currently

00:27:27,320 --> 00:27:31,260
does binary dependencies is kind of a hybrid of an OS packaging scheme

00:27:31,260 --> 00:27:36,049
and also the way Python wants to do it.

00:27:36,049 --> 00:27:39,049
There are some discussions that the PyPA folks and others have had with that,

00:27:39,049 --> 00:27:42,421
but I've honestly not been involved in it so I don't know a whole lot.

00:27:42,421 --> 00:27:45,580
I can say that from the perspective of the cryptography project,

00:27:45,580 --> 00:27:48,800
conda has caused us some trouble because they do some of those terrible things

00:27:48,800 --> 00:27:51,020
I was just talking about to the C toolchain

00:27:51,020 --> 00:27:53,799
where they have expectations of being able to rewrite the path

00:27:53,800 --> 00:27:56,300
but then the C, like, the linker will try and go

00:27:56,300 --> 00:27:58,380
and get a symbol that it shouldn't have gotten.

00:27:58,380 --> 00:28:00,560
So, we've had some issues on that front.

00:28:00,560 --> 00:28:03,480
It's not their fault, by any means; it's just an imperfect world.

00:28:03,480 --> 00:28:06,029
So, hopefully we can get better in the future by working with them

00:28:06,029 --> 00:28:08,340
and figuring out how to kind of merge these concepts.

00:28:09,420 --> 00:28:10,740
Hey, Jay.

00:28:10,740 --> 00:28:12,500
(audience member 3) Hey, Paul.

00:28:12,500 --> 00:28:14,360
Thanks for the talk; that was really good and really detailed.

00:28:14,360 --> 00:28:18,160
So as you said at the end, this is super complex and there's a lot of moving pieces,

00:28:18,160 --> 00:28:20,000
and you talked a bit about automation.

00:28:20,000 --> 00:28:24,299
And I'm wondering if you think that that's something that, you know,

00:28:24,300 --> 00:28:26,200
that is possible to sort of centralize?

00:28:26,200 --> 00:28:28,390
You know, imagine a build service that would take

00:28:28,390 --> 00:28:30,510
your Python and give you a bunch of wheels,

00:28:30,510 --> 00:28:33,340
or is that build process, like, differently finicky

00:28:33,340 --> 00:28:35,300
for different types of libraries?

00:28:35,300 --> 00:28:38,940
Would you need a different automation for cryptography as for something something something.

00:28:38,940 --> 00:28:40,929
(Paul Kehrer) So, I think actually that there's a good chance

00:28:40,929 --> 00:28:43,170
that this sort of thing can be centralized.

00:28:43,170 --> 00:28:45,750
Actually the cryptography Jenkins cluster is used

00:28:45,750 --> 00:28:48,160
for quite a few things these days, [laughs]

00:28:48,160 --> 00:28:51,240
because we built an infrastructure and it turns out we're willing to let

00:28:51,240 --> 00:28:54,320
a certain subset of other people we know well use it.

00:28:54,320 --> 00:28:56,920
I would love to see more of that get centralized.

00:28:56,920 --> 00:29:00,700
Obviously not everyone has the resources to run multiple Windows VMs,

00:29:00,700 --> 00:29:02,940
multiple OS X boxes,

00:29:02,940 --> 00:29:05,299
who knows how many other Linux machines eventually

00:29:05,300 --> 00:29:07,160
if we want to start testing whether or not our

00:29:07,160 --> 00:29:10,020
manylinux1 wheels work across a set of distros.

00:29:10,020 --> 00:29:14,260
I know Donald Stufft, one of the main guys behind PyPI,

00:29:14,270 --> 00:29:18,350
has a dream that he'd like a build server that would be able to do this sort of thing.

00:29:18,350 --> 00:29:22,270
I don't believe we've really moved particularly far forward on it yet,

00:29:22,270 --> 00:29:24,720
but hopefully at some point in the future this will become more possible.

00:29:24,720 --> 00:29:29,110
There's obviously the one core issue which is that

00:29:29,110 --> 00:29:31,690
you're running arbitrary untrusted code on a build server.

00:29:31,690 --> 00:29:35,280
So, it's a little tricky to decide who gets to do that.

00:29:35,280 --> 00:29:37,080
[laughs]

00:29:37,840 --> 00:29:39,680
(audience member 4) I just want to say first,

00:29:39,680 --> 00:29:43,660
thank you for the talk; that was really educational.

00:29:43,700 --> 00:29:47,500
One thing that you didn't mention too much is building Python packages

00:29:47,500 --> 00:29:51,640
that depend on the binary interfaces of other Python packages that have C extensions.

00:29:51,640 --> 00:29:55,360
I was wondering if you have any thoughts or advice on that.

00:29:55,360 --> 00:29:59,020
As far as I know there's no good way to build wheels for those packages

00:29:59,020 --> 00:30:01,620
because you can't know what --

00:30:01,620 --> 00:30:04,770
or, you can't express your binary dependencies in wheels right now,

00:30:04,770 --> 00:30:08,419
so is your recommendation to still use sdists for those kinds of packages,

00:30:08,420 --> 00:30:11,380
or is there some other technique that can be done there?

00:30:11,380 --> 00:30:13,100
(Paul Kehrer) Yeah, for the moment there's really no choice

00:30:13,100 --> 00:30:14,960
other than to use an sdist.

00:30:14,960 --> 00:30:16,740
I mean, I've always wondered -- because I haven't

00:30:16,750 --> 00:30:19,150
actually seen a whole lot of those packages,

00:30:19,150 --> 00:30:21,000
so I'd love to talk after this --

00:30:21,000 --> 00:30:26,640
why you want to reach into a C API built thing to actually to grab its single table.

00:30:26,640 --> 00:30:28,400
[laughs]

00:30:29,480 --> 00:30:31,200
(moderator) Alright, thank you.

00:30:31,200 --> 00:30:33,560
That concludes our question time.

00:30:33,560 --> 00:30:36,740

YouTube URL: https://www.youtube.com/watch?v=-j4lolWgD6Q


