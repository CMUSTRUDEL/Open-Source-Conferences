Title: Jacob Kovac - Revitalizing Python Game Development- Packaging, Performance, and Platforms.mp4
Publication date: 2016-06-20
Playlist: PyCon 2016
Description: 
	"Speaker: Jacob Kovac

With the advent of mobile platforms, as well as the prevalence of the GPU, Python has fallen almost entirely out of favor with game developers. However, there are some exciting solutions to the major issues being built on top of the Kivy GUI Framework. This talk will cover the recent developments that make it possible to build high quality, cross-platform games in Python.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides"
Captions: 
	00:00:00,280 --> 00:00:03,760
(moderator) Please help me in welcoming Jacob Kovac.

00:00:03,760 --> 00:00:09,860
[applause]

00:00:10,380 --> 00:00:12,400
(Jacob Kovac) Hello everyone. Thank you for coming.

00:00:12,400 --> 00:00:15,460
I'm Jacob Kovac. I run a small front end development company

00:00:15,460 --> 00:00:20,120
that does a combo of mobile and desktop apps using Kivy and Python

00:00:20,120 --> 00:00:23,600
and web apps with react.js,

00:00:23,600 --> 00:00:26,100
which is not what I'm going to talk about today.

00:00:26,580 --> 00:00:30,400
I also in the Kivy core developer where I focus on graphics programming.

00:00:30,400 --> 00:00:32,400
And I'm the developer of the KivEnt game engine

00:00:32,400 --> 00:00:35,860
which is an entity component game engine built on top of Kivy.

00:00:36,380 --> 00:00:39,140
Let's see here. So...

00:00:41,580 --> 00:00:43,740
I guess we're going to cover three major things here.

00:00:43,740 --> 00:00:46,399
We're going to cover platforms, which really is about ensuring

00:00:46,400 --> 00:00:50,120
that your code will run everywhere even when it has compiled dependencies

00:00:50,120 --> 00:00:53,530
because not all Python modules and not everything can be done

00:00:53,530 --> 00:00:56,280
purely in Python. And also, making sure

00:00:56,280 --> 00:00:58,400
that you can access system-specific functionality

00:00:58,400 --> 00:01:01,720
because a lot of these different platforms have all kinds of things in them

00:01:01,720 --> 00:01:05,660
that you either -- you may want for your games or you may need.

00:01:05,660 --> 00:01:08,840
Oftentimes you might want to, you know, open a native file chooser

00:01:08,840 --> 00:01:12,840
or something like that so that you can provide a simple,

00:01:12,840 --> 00:01:15,360
you know, user-friendly way for them to pick files

00:01:15,360 --> 00:01:17,740
out of their system or whatever.

00:01:18,380 --> 00:01:20,380
The second part of that is distribution,

00:01:20,380 --> 00:01:22,500
which is somewhat different from just getting your code

00:01:22,500 --> 00:01:25,060
to run on an operating system.

00:01:25,060 --> 00:01:28,560
It's about getting your code to run on random people's computers

00:01:28,560 --> 00:01:30,980
who have done who knows what to them.

00:01:30,980 --> 00:01:34,440
And, in general, I sort of have a very...

00:01:35,240 --> 00:01:38,340
You've got to be distributing compiled binaries for the specific platform.

00:01:38,340 --> 00:01:42,120
There's no other way to do this. You can't trust anything else,

00:01:42,120 --> 00:01:46,060
and most other things are going to be,

00:01:46,060 --> 00:01:48,260
especially for games, a little too much for your users,

00:01:48,260 --> 00:01:51,160
who pretty much want to install an app and click "go" and play a game.

00:01:51,160 --> 00:01:54,640
They don't want to bother about package management or anything.

00:01:54,640 --> 00:01:58,000
And finally, performance, which -- building games in Python

00:01:58,000 --> 00:02:01,200
has not really been all that popular, in large --

00:02:01,200 --> 00:02:07,140
er, at least a little bit because there is performance problems

00:02:07,140 --> 00:02:10,400
writing everything in Python. It's not exactly the best for gaming.

00:02:10,400 --> 00:02:13,460
It isn't really optimized for that. It's meant for other things.

00:02:13,460 --> 00:02:17,680
But we can get past that because Kivy is based heavily on Cython,

00:02:17,680 --> 00:02:23,340
which is a sort of an unholy union of C and Python all at the same time

00:02:23,340 --> 00:02:27,700
that is super sweet. I really like it, and it's the reason Kivy can work.

00:02:27,700 --> 00:02:30,100
It's the reason Kivy can be fast enough everywhere

00:02:30,100 --> 00:02:33,060
and it's the reason the KivEnt game engine

00:02:33,060 --> 00:02:35,480
can do what it can do.

00:02:35,480 --> 00:02:38,880
So in addition, I guess I felt like I needed to justify a little bit

00:02:38,880 --> 00:02:44,060
why Pygame, Vispy, Pyglet, your other favorite thing

00:02:44,060 --> 00:02:47,220
is not really --

00:02:47,220 --> 00:02:50,060
why I had to build another game engine, basically, in Python

00:02:50,060 --> 00:02:52,720
and another way to do this.

00:02:52,720 --> 00:02:55,280
Part of it is that the fundamental approach I'm taking

00:02:55,280 --> 00:02:58,300
is really heavily rooted in Cython,

00:02:58,300 --> 00:03:02,540
and the thing with going in that direction is that

00:03:02,540 --> 00:03:07,840
for the optimizations to truly work, you also want everything to be Cython,

00:03:07,840 --> 00:03:11,080
or a lot of things to be Cython, because as soon as you're falling back

00:03:11,080 --> 00:03:14,520
into hitting a different Python library or something else,

00:03:14,520 --> 00:03:18,080
you may not be able to -- you may impose a lot of the penalties

00:03:18,080 --> 00:03:22,740
of Python lookups and attribute access and so on,

00:03:22,740 --> 00:03:26,260
because you're having to write shims between your code that you have written

00:03:26,260 --> 00:03:31,580
and taken care of to be nice efficiency, but who knows what other libraries do.

00:03:33,340 --> 00:03:37,020
In addition, I guess on desktop there's also been some attempts

00:03:37,020 --> 00:03:39,540
to do this by using NumPy

00:03:39,540 --> 00:03:41,900
or something like that, which is a great approach.

00:03:41,900 --> 00:03:44,460
When I started KivEnt, NumPy did not run on mobile.

00:03:44,460 --> 00:03:47,240
The Kivy guys have done a really great job of fixing that since then.

00:03:47,240 --> 00:03:49,620
But -- so I decided to avoid

00:03:49,620 --> 00:03:51,960
any heavy dependencies like numpy.

00:03:51,960 --> 00:03:54,200
And in addition, I really think if you're trying to make Mario

00:03:54,200 --> 00:03:56,480
or Flappy Bird or something, you don't really need

00:03:56,480 --> 00:03:59,980
the entire scientific numerical analysis package.

00:04:01,580 --> 00:04:04,060
And in addition, some of these various frameworks

00:04:04,060 --> 00:04:06,180
have limited or no mobile compatibility,

00:04:06,180 --> 00:04:10,300
which I think building games in mobile is super fun.

00:04:10,300 --> 00:04:15,760
It's also, I think, the majority of devices out there now, so...

00:04:15,760 --> 00:04:18,500
Especially -- when I think this, I oftentimes --

00:04:18,500 --> 00:04:23,440
one of my biggest reasons for building KivEnt was that...

00:04:24,120 --> 00:04:26,460
...we want children to learn to program,

00:04:26,460 --> 00:04:29,680
and we often teach programming via games.

00:04:29,680 --> 00:04:32,160
And most of the time, as students get older,

00:04:32,160 --> 00:04:34,420
they're probably going to end up using some type of Python for something,

00:04:34,420 --> 00:04:37,080
whether it's research or whatever it is you do

00:04:37,080 --> 00:04:40,520
with the scientific stack of Python. I'm not really certain.

00:04:43,960 --> 00:04:49,000
So I wanted to make sure that kids could build games in Python,

00:04:49,000 --> 00:04:51,120
because that's going to be one of the most useful languages for them

00:04:51,120 --> 00:04:55,120
going forward if they don't become professional computer programmers.

00:04:55,120 --> 00:04:59,220
I am very much in love with the idea of computer literacy becoming much --

00:04:59,220 --> 00:05:01,840
or programming literacy becoming much more than a thing

00:05:01,840 --> 00:05:06,360
that the top 5% of the world does. So, yeah.

00:05:06,360 --> 00:05:09,400
And in addition, some of these things require you to write your own event loop

00:05:09,400 --> 00:05:15,280
or make blit calls and flip buffers and all that kind of stuff.

00:05:15,280 --> 00:05:19,360
That's all really, really not a good --

00:05:19,360 --> 00:05:21,360
like, that means that everybody has a bunch of spaghetti code

00:05:21,360 --> 00:05:23,320
where they've decided how to do all of these things

00:05:23,320 --> 00:05:25,280
for their unique project.

00:05:25,280 --> 00:05:29,430
And I was hoping I could come up with a way to make it so we can all share

00:05:29,430 --> 00:05:33,940
the same basic low-level event loops and flipping buffers and such,

00:05:33,940 --> 00:05:36,800
so that we can share our code more readily instead of having to

00:05:36,800 --> 00:05:39,680
cobble together things sort of haphazardly.

00:05:40,200 --> 00:05:43,900
And in addition, the Kivy framework is just wonderful.

00:05:43,900 --> 00:05:47,240
It's a much -- it addresses all of these kind of problems

00:05:47,240 --> 00:05:49,710
I've just mentioned, and it also provides a very powerful

00:05:49,710 --> 00:05:53,640
and simple API that has all kinds of cool things like replacements.

00:05:53,640 --> 00:05:58,000
The KV language is sort of a weird CSS that's super better than CSS

00:05:58,000 --> 00:06:02,420
and doesn't have any of its problems, at least from my opinion.

00:06:03,020 --> 00:06:09,320
Okay, so when it comes to platforms,

00:06:09,320 --> 00:06:12,980
the Kivy ecosystem gives us several really great ways

00:06:12,980 --> 00:06:15,580
to access these things.

00:06:15,580 --> 00:06:17,980
There are the Pyobjus and Pynjius tools,

00:06:17,980 --> 00:06:20,200
which give you access to Objective-C

00:06:20,200 --> 00:06:24,100
and Java code dynamically, so that you can basically call anything.

00:06:24,100 --> 00:06:27,720
This is a much better approach in the long term

00:06:27,720 --> 00:06:31,740
than simply providing a nice wrapper for y'all to use

00:06:31,740 --> 00:06:34,160
based on what we think you want, because now you can use

00:06:34,160 --> 00:06:37,240
any part of the Android or iOS systems depending on what you need

00:06:37,240 --> 00:06:39,940
rather than having to wait for us to wrap it.

00:06:39,940 --> 00:06:43,520
In addition, Cython is a great tool here because it will let you

00:06:43,520 --> 00:06:47,120
call C or C++ code fairly transparently

00:06:47,120 --> 00:06:50,640
in your Python files -- well, your Cython files.

00:06:51,320 --> 00:06:55,700
So between that, I mean if you can get access to C, C++, Java,

00:06:55,700 --> 00:06:59,160
and Objective-C code, I think you pretty much have access

00:06:59,160 --> 00:07:02,380
to a good bit of the ecosystem out there beyond Python

00:07:02,380 --> 00:07:05,300
that is a related to game development.

00:07:05,740 --> 00:07:08,660
In addition, I did want to mention that Kivy has a really cool project

00:07:08,660 --> 00:07:11,260
called Plyer, which is a platform-independent

00:07:11,260 --> 00:07:13,860
compatibility layer, which aims to make it so that

00:07:13,870 --> 00:07:16,920
you don't have to individually wrap all of these features.

00:07:16,920 --> 00:07:20,660
And instead we've already done it so that you can just import gyroscope,

00:07:20,669 --> 00:07:23,220
and if there's a gyroscope on your platform,

00:07:23,220 --> 00:07:27,080
you'll get the gyroscope data, and if there's not, you will --

00:07:27,080 --> 00:07:29,840
you'll get a "not implemented" error.

00:07:29,840 --> 00:07:33,060
And so, when it comes to making sure

00:07:33,060 --> 00:07:36,340
all of your dependencies work everywhere,

00:07:36,340 --> 00:07:39,060
there is basically two approaches.

00:07:39,060 --> 00:07:41,680
You can look for a library that's already been built to work everywhere --

00:07:41,680 --> 00:07:44,260
something like the STL 2, which prides itself

00:07:44,260 --> 00:07:47,040
on working on all desktop and mobile platforms.

00:07:47,040 --> 00:07:48,900
But sometimes you can't do that.

00:07:48,900 --> 00:07:53,160
Sometimes you're working with various libraries based on,

00:07:53,160 --> 00:07:55,819
you know, depending on the platform such as maybe interacting

00:07:55,820 --> 00:07:58,960
with the Windows API or the iOS API or something like that.

00:07:58,960 --> 00:08:02,960
And so you sometimes need to find a solution that abstracts

00:08:02,960 --> 00:08:06,820
over those various APIs to find a common ground

00:08:06,820 --> 00:08:10,440
that lets you transparently write Python to use those features.

00:08:10,440 --> 00:08:15,860
And Kivy provides really very good tools for doing this

00:08:15,860 --> 00:08:19,000
and for really getting your hands dirty and being able to make use

00:08:19,000 --> 00:08:22,760
of the whole platform without it being too much of a pain.

00:08:22,760 --> 00:08:25,360
So I just wanted to give a quick example.

00:08:25,360 --> 00:08:31,340
This is the -- from Plyer, this is the Java wrapper for the gyroscope.

00:08:31,340 --> 00:08:33,240
And...

00:08:34,600 --> 00:08:37,800
This is calling Java code. Almost everything in here is Java.

00:08:37,800 --> 00:08:40,340
And it doesn't really look like Java, I don't think.

00:08:40,340 --> 00:08:43,680
And it's definitely a lot better than actually starting out the clips

00:08:43,680 --> 00:08:47,680
and writing some Java. And so...

00:08:48,680 --> 00:08:50,880
I guess I don't really want to get too in detail here.

00:08:50,880 --> 00:08:53,820
If you're really interested in this, check out Plyer. Look at the code.

00:08:53,820 --> 00:08:56,520
Here's the Objective-C version, and notice that they're sort of

00:08:56,520 --> 00:08:58,900
very different because in the Android version of gyroscope,

00:08:58,900 --> 00:09:01,380
you need to schedule a callback that's going to get called,

00:09:01,380 --> 00:09:04,560
whereas in the Objective-C, you just hit the end point

00:09:04,560 --> 00:09:06,900
and check what the value is at that time.

00:09:06,900 --> 00:09:12,440
And so that's a great example of how, like, any of these features

00:09:12,440 --> 00:09:14,980
could be implemented vastly different across platform.

00:09:14,980 --> 00:09:18,540
And so oftentimes a one-to-one conversion

00:09:18,540 --> 00:09:20,800
can be a little difficult to come up with,

00:09:20,800 --> 00:09:23,000
although not impossible.

00:09:23,000 --> 00:09:26,440
And Plyer helps you do that.

00:09:26,440 --> 00:09:30,120
And this is what your code would look like if you're using the gyroscope in Plyer.

00:09:30,120 --> 00:09:33,160
Wherever you wanted to start your code, you'd just call gyroscope.enable.

00:09:33,160 --> 00:09:35,800
Wherever you wanted to -- once you're done with the gyroscope,

00:09:35,800 --> 00:09:39,860
you call gyroscope.disable and you get the orientation.

00:09:39,860 --> 00:09:42,000
You no longer have to think about, you know, Objective-C.

00:09:42,000 --> 00:09:45,500
You no longer have to think about Java. And this is sort of the dream

00:09:45,500 --> 00:09:49,520
of the Kivy project's view for Plyer

00:09:49,520 --> 00:09:51,760
is that we will get to a point

00:09:51,760 --> 00:09:54,860
where you never think about wrapping Java or wrapping Objective-C.

00:09:54,860 --> 00:09:57,580
We will just have all of this ready for you

00:09:57,580 --> 00:10:00,300
and ready to go in Python, which I think is super neat.

00:10:00,300 --> 00:10:02,360
And Plyer also works for desktop platforms,

00:10:02,360 --> 00:10:05,880
although it's more developed for mobile because there's a lot more sensors

00:10:05,880 --> 00:10:08,200
and hardware that you actually want to query,

00:10:08,200 --> 00:10:11,080
and desktop Python actually has fairly established ways

00:10:11,080 --> 00:10:14,400
to get access to a lot of that stuff compared to mobile.

00:10:14,400 --> 00:10:18,980
In addition, I wanted to mention briefly that you can also,

00:10:18,980 --> 00:10:21,540
oftentimes when you're building games you are going to be interacting

00:10:21,540 --> 00:10:24,080
with C libraries because that's where a lot of the tools

00:10:24,080 --> 00:10:25,900
in game development is.

00:10:25,900 --> 00:10:29,200
This is taken from Kivy's code for loading SVG files.

00:10:29,200 --> 00:10:32,300
And this is just an example of what Cython code looks like

00:10:32,300 --> 00:10:34,720
if you've never seen it before.

00:10:34,720 --> 00:10:38,940
And this is for libtest2 which is a triangulation library,

00:10:38,940 --> 00:10:40,940
and so something you may want in games

00:10:40,940 --> 00:10:43,780
because you deal with a lot of triangles there.

00:10:43,780 --> 00:10:46,300
So it's kind of ugly but not super ugly.

00:10:46,300 --> 00:10:49,100
You've got some static types, things like that.

00:10:49,860 --> 00:10:54,360
It's -- I like it because you can kind of start out

00:10:54,360 --> 00:10:56,940
by writing Python code, and then as you realize

00:10:56,940 --> 00:10:59,780
what you want to do, and also what parts of it are slow,

00:10:59,780 --> 00:11:05,280
you can conditionally convert that over to a kind of more C-like algorithm

00:11:05,280 --> 00:11:08,600
without really having to start over from scratch.

00:11:10,540 --> 00:11:13,840
And so...let's see here.

00:11:16,240 --> 00:11:20,520
The real -- Kivy is the key to how all of this works,

00:11:20,520 --> 00:11:24,060
in my opinion, because it really does manage

00:11:24,060 --> 00:11:26,240
almost all these platform complexity problems.

00:11:26,240 --> 00:11:30,560
Not only does it provide a consistent API for abstracting over various windowing,

00:11:30,560 --> 00:11:35,560
input, and getting images loaded and sound loaded

00:11:35,560 --> 00:11:38,580
and getting input from touch devices of all kinds --

00:11:38,580 --> 00:11:41,100
TUIO, mtdev,

00:11:41,100 --> 00:11:43,780
practically everything that's out there on the market.

00:11:43,780 --> 00:11:47,020
It also is built in case you don't want something generic

00:11:47,020 --> 00:11:49,180
but you have very, very specific use cases.

00:11:49,180 --> 00:11:53,620
Let's say FF Player is totally not useful for you

00:11:53,620 --> 00:11:58,360
in terms of your video displaying needs, but GStreamer is.

00:11:58,360 --> 00:12:01,700
Or you want to just target one specific operating system

00:12:01,700 --> 00:12:04,780
because you've got a very specific idea

00:12:04,780 --> 00:12:07,420
that's going to make use of Android or iOS or something.

00:12:07,420 --> 00:12:11,480
Kivy gives you the ability to configure it so that it works exactly the way you want

00:12:11,481 --> 00:12:14,900
with the providers you want, rather than just providing

00:12:14,900 --> 00:12:19,020
a single abstraction over everything.

00:12:19,020 --> 00:12:22,460
So it gives you a lot of flexibility, and that comes in really handy

00:12:22,460 --> 00:12:25,920
when you're doing things like connecting,

00:12:25,920 --> 00:12:29,260
you know, the connects to a 50-inch touchscreen

00:12:29,260 --> 00:12:31,460
and doing some kind of weird mall advertising display

00:12:31,460 --> 00:12:33,500
with liquor bottles or something.

00:12:33,500 --> 00:12:35,680
That's actually something one of our Kivy core developers does

00:12:35,680 --> 00:12:38,860
and it's really cool. His company's name is Tangible Display

00:12:38,860 --> 00:12:40,900
and you should check it out if you want to see the type of things

00:12:40,900 --> 00:12:43,940
that people are doing with Python and Kivy.

00:12:43,940 --> 00:12:45,780
And then...

00:12:47,180 --> 00:12:49,820
I always think it's important to mention that Kivy is far more

00:12:49,820 --> 00:12:55,100
than just a GUI platform. It is an ecosystem of packaging devi--

00:12:55,100 --> 00:13:00,540
packaging tools, compatibility libraries, and pretty much everything you need

00:13:00,540 --> 00:13:04,100
to get a really fully functional app deployed on Android.

00:13:04,100 --> 00:13:06,660
And so that gives you a very good starting point.

00:13:06,670 --> 00:13:09,160
For instance, these are all of the compiled libraries

00:13:09,160 --> 00:13:13,860
that you might commonly use in Python that are already ready for use on Android.

00:13:13,860 --> 00:13:17,700
These had to be patched or in some other way

00:13:17,700 --> 00:13:20,040
given special compiler instructions to compile on Android,

00:13:20,040 --> 00:13:23,060
but the Kivy community has already taken care of that for you.

00:13:23,060 --> 00:13:26,900
Unfortunately, on iOS, these are the modules that work.

00:13:26,900 --> 00:13:30,360
We're significantly behind on iOS

00:13:30,360 --> 00:13:33,580
and we do need more iOS and OS X developers.

00:13:33,580 --> 00:13:35,520
There's a lot of low-hanging fruit out there.

00:13:35,520 --> 00:13:38,000
If you're interested in how this stuff works,

00:13:38,000 --> 00:13:41,460
come on by to the Kivy chat channel or our user group or whatever

00:13:41,460 --> 00:13:44,660
and get started. It's really -- we need help.

00:13:44,660 --> 00:13:49,050
I know a lot of you guys -- a lot of programmers are OS X people.

00:13:49,050 --> 00:13:51,780
The Kivy team are largely Ubuntu and Windows

00:13:51,780 --> 00:13:55,120
and, you know, Linux and Windows and so on, and Android.

00:13:55,120 --> 00:13:59,280
We're not really Apple people on account of Apple prices,

00:13:59,280 --> 00:14:02,040
is what it really comes down to.

00:14:02,040 --> 00:14:05,560
So in terms of the packaging story,

00:14:05,560 --> 00:14:07,740
we really have great news

00:14:07,740 --> 00:14:09,780
because just recently in the last few months,

00:14:09,780 --> 00:14:13,100
Python 3 support was added to Python for Android,

00:14:13,100 --> 00:14:16,760
so that you can now build Python 2 and Python 3 applications with that tool.

00:14:16,760 --> 00:14:21,320
That's the Android new deployment target. And it's also super neat

00:14:21,320 --> 00:14:26,420
because prior to this release, we were manually patching Python

00:14:26,420 --> 00:14:29,180
to make sure it would compile on Android.

00:14:29,180 --> 00:14:33,240
And we have instead switched to the CrystaX NDK replacement,

00:14:33,240 --> 00:14:36,860
which is much more compatible and works as expected.

00:14:36,860 --> 00:14:41,280
And so it actually just deploys Python 2 and Python 3

00:14:41,280 --> 00:14:43,220
from their original source without any patches,

00:14:43,220 --> 00:14:46,405
which is a super big deal, I think, going forward

00:14:46,405 --> 00:14:49,820
for just not having all this weird random code

00:14:49,820 --> 00:14:53,120
that you need to apply to get it on Android.

00:14:53,120 --> 00:14:55,460
And so CrystaX is really cool.

00:14:55,460 --> 00:14:57,300
Kivy iOS is still only Py 2.

00:14:57,300 --> 00:15:00,460
Once again we're much further behind in the iOS world.

00:15:00,460 --> 00:15:03,980
And then finally, at least --

00:15:03,980 --> 00:15:06,340
for me, I use PyInstaller on desktop platforms

00:15:06,340 --> 00:15:08,920
because it's worked for me. There's several other things people could use.

00:15:08,920 --> 00:15:13,000
There's Nuitka, which is a C++ compiler thing

00:15:13,000 --> 00:15:16,080
that I have heard from some members of the Kivy community

00:15:16,080 --> 00:15:18,400
that they've managed to compile applications with that.

00:15:18,400 --> 00:15:22,400
So that's a way to go. There's also py2exe, py2app, and cx_Freeze,

00:15:22,400 --> 00:15:26,640
so, you know, you can get these in a couple ways.

00:15:26,640 --> 00:15:28,940
But I think PyInstaller is the most consistent

00:15:28,940 --> 00:15:32,380
and the most supported for Python 2 and 3.

00:15:32,380 --> 00:15:35,620
The goal of the Kivy team eventually is to have one packaging tool

00:15:35,620 --> 00:15:37,620
for all platforms. We've already started this.

00:15:37,630 --> 00:15:40,350
It's called Buildozer and it currently has OS X, iOS,

00:15:40,350 --> 00:15:42,620
and Android support. So you have one spec file

00:15:42,620 --> 00:15:45,100
that manages to take care of all this complexity,

00:15:45,100 --> 00:15:50,120
and you basically just say, "Buildozer Android" or "Buildozer iOS."

00:15:50,120 --> 00:15:55,540
And hopefully in the future, we will extend this to all desktop platforms.

00:15:55,540 --> 00:15:59,450
We've mainly been focused on the ones where there's actually tools missing,

00:15:59,450 --> 00:16:03,320
which is iOS and Android, but OS X was recently added to Buildozer

00:16:03,320 --> 00:16:06,860
because we've got some -- or at least the creator of Kivy,

00:16:06,860 --> 00:16:09,320
Tito, Mathieu Virbel, has some interesting ideas

00:16:09,320 --> 00:16:12,960
about how to deploy OSX and make it better.

00:16:14,220 --> 00:16:16,980
So let's get into kind of the meat of what I like to do,

00:16:16,980 --> 00:16:18,960
which is performance stuff.

00:16:18,960 --> 00:16:22,500
This is -- performance comes down to several things.

00:16:22,500 --> 00:16:24,740
One, it's -- and, I mean, I think the most important

00:16:24,740 --> 00:16:27,780
for visual simulations is correctly using graphics APIs --

00:16:27,780 --> 00:16:30,940
in this case OpenGL is what Kivy likes to use --

00:16:30,940 --> 00:16:33,820
because, I mean, these GPUs have fantastic levels of power,

00:16:33,820 --> 00:16:36,320
and if we use them correctly, we don't even have to worry

00:16:36,320 --> 00:16:39,200
about Python being that slow, because all the codes can be computed

00:16:39,200 --> 00:16:43,580
on the GPU, or at least a lot of the most intensive code is.

00:16:43,580 --> 00:16:46,060
In addition, as I mentioned, Cython is a great tool

00:16:46,060 --> 00:16:48,440
for allowing us to interact with low-level APIs

00:16:48,440 --> 00:16:50,720
such as OpenGL or a physics engine

00:16:50,720 --> 00:16:53,660
or whatever else it is you want to use it for,

00:16:53,660 --> 00:16:56,660
spatial hashing and so on.

00:16:57,280 --> 00:17:02,520
And I will go over what I -- the way I think Cython APIs

00:17:02,520 --> 00:17:05,600
should be built, because I have a sort of unique thing

00:17:05,600 --> 00:17:08,079
going on in the game engine where you're actually intended to

00:17:08,080 --> 00:17:11,020
either write Python code or Cython code

00:17:11,020 --> 00:17:15,580
that C imports, which is Cython's code word

00:17:15,580 --> 00:17:19,330
for importing C code rather than Python code,

00:17:19,330 --> 00:17:22,540
so that you can avoid the call overhead.

00:17:22,540 --> 00:17:24,960
A lot of Cython libraries are sort of built to be

00:17:24,960 --> 00:17:27,140
one-way used from Python,

00:17:27,140 --> 00:17:29,900
but there's actually a lot of power that can be gained from actually building

00:17:29,900 --> 00:17:32,800
an API that can also be used from Cython

00:17:32,800 --> 00:17:34,860
and properly type everything.

00:17:34,860 --> 00:17:37,920
Not only do you get much better static typing,

00:17:37,920 --> 00:17:42,300
which can help with large code bases, but you also get a lot of speed.

00:17:42,300 --> 00:17:45,300
Then I'm going to talk a little bit about an entity-component architecture,

00:17:45,300 --> 00:17:47,680
because I'm sure a lot of you have never heard of it.

00:17:47,680 --> 00:17:49,580
It's very popular in games nowadays.

00:17:49,580 --> 00:17:52,360
And finally, I'll introduce KivEnt a little more fully.

00:17:52,360 --> 00:17:55,700
So really, in a lot of ways, this comes down to:

00:17:55,700 --> 00:18:00,760
when we're working with visualizations, we're sending geometry to the GPU.

00:18:00,760 --> 00:18:04,860
That's all we're doing. There's basically two ways we can do this.

00:18:04,860 --> 00:18:06,960
The first way is sort of to send a flat array.

00:18:06,960 --> 00:18:10,200
Like if we have a bunch of -- like, say we have an X,Y coordinate

00:18:10,200 --> 00:18:13,200
representing a 2D, you know, position on the screen,

00:18:13,200 --> 00:18:16,100
we would send a whole bunch of floats in an array.

00:18:16,100 --> 00:18:18,980
And then maybe we want to have colors,

00:18:18,980 --> 00:18:21,120
and colors might be an unsigned character

00:18:21,120 --> 00:18:23,360
because that's a lot cheaper than a float to store.

00:18:23,360 --> 00:18:26,580
You can store the whole color in the same size as a single number.

00:18:26,580 --> 00:18:30,060
And OpenGL has really great support for converting those automatically

00:18:30,060 --> 00:18:33,780
to floating point numbers so that your math can work properly.

00:18:33,780 --> 00:18:37,220
And right now Kivy works by doing just that.

00:18:37,220 --> 00:18:39,260
So if you've got a bunch of floating-point numbers,

00:18:39,260 --> 00:18:42,140
it throws them into an array. And if you've got a bunch of

00:18:42,140 --> 00:18:44,200
whatever else you want, whatever other types --

00:18:44,200 --> 00:18:46,860
there's several in GL -- you know, each one is unique.

00:18:46,860 --> 00:18:51,360
And that's useful from Python because it's much simpler.

00:18:51,360 --> 00:18:55,360
We can simply take a Python list of floats and parse it and turn into an array.

00:18:55,360 --> 00:18:59,740
However, a lot of the time you actually want to

00:18:59,740 --> 00:19:02,220
interleave your data types, and this is something that KivEnt

00:19:02,220 --> 00:19:05,170
has brought to the Kivy engine, the graphics engine,

00:19:05,170 --> 00:19:07,930
is that you can now mix your floating-point numbers

00:19:07,930 --> 00:19:10,540
and your unsigned characters into a single struct

00:19:10,540 --> 00:19:16,400
which can be much better, I think, in terms of thinking about your code,

00:19:16,400 --> 00:19:19,060
because now you're no longer having to track several different arrays.

00:19:19,060 --> 00:19:21,280
You're uploading and making sure they all get uploaded

00:19:21,280 --> 00:19:23,220
and have their memory allocated and everything.

00:19:23,220 --> 00:19:25,860
You can just allocate one giant array of a single struct

00:19:25,860 --> 00:19:28,620
that's all the data you need for your geometry.

00:19:28,620 --> 00:19:31,580
And so ultimately the goal of any game engine

00:19:31,580 --> 00:19:34,260
is to make these arrays of your geometry

00:19:34,260 --> 00:19:36,220
and send them to the GPU

00:19:36,220 --> 00:19:38,600
and you get back what looks like a game.

00:19:38,600 --> 00:19:42,200
And so this is one of the most performance-intensive parts of games.

00:19:42,200 --> 00:19:45,320
You do it probably 60 times a second,

00:19:45,320 --> 00:19:48,960
and it can take a little while, and so...

00:19:51,020 --> 00:19:54,720
KivEnt has been built to minimize this time as much as possible.

00:19:54,720 --> 00:19:57,860
OK, so, I've said "entity-component architecture"

00:19:57,860 --> 00:20:00,600
a few times without ever explaining myself.

00:20:00,600 --> 00:20:04,800
It is a method of compositing game objects

00:20:04,800 --> 00:20:08,620
instead of using object-oriented inheritance.

00:20:08,620 --> 00:20:14,300
And one of the best examples, I guess, for why this is important is

00:20:14,300 --> 00:20:17,340
you take something like -- say you're building the WarCraft 2 game

00:20:17,340 --> 00:20:20,280
and you've, you know, you've got this little object hierarchy

00:20:20,280 --> 00:20:22,660
and you've got, like, a basic game object

00:20:22,660 --> 00:20:25,280
and then a movable game object that you turn into all your units,

00:20:25,280 --> 00:20:27,420
and then, like, maybe a building object

00:20:27,420 --> 00:20:31,040
that is a game object that doesn't move, and so on.

00:20:31,040 --> 00:20:34,720
And then you make an archer unit that's based off of the movable unit,

00:20:34,730 --> 00:20:38,780
and then you're like, "But I want a tower that's like an archer but it doesn't move."

00:20:38,780 --> 00:20:46,420
And suddenly your whole carefully orchestrated

00:20:46,420 --> 00:20:48,760
object-oriented thing has sort of got a wrench thrown in it

00:20:48,760 --> 00:20:51,420
because you want your tower to behave like an archer.

00:20:51,420 --> 00:20:53,420
You're either going to copy the code or you're going to try

00:20:53,420 --> 00:20:55,460
some funky multiple inheritance.

00:20:55,460 --> 00:20:57,740
It's much easier to simply split those up

00:20:57,740 --> 00:21:01,720
into a component that governs whether something can move,

00:21:01,720 --> 00:21:04,000
a component that governs how it's rendered to the screen,

00:21:04,000 --> 00:21:06,940
a component that governs whether it can shoot an arrow.

00:21:06,940 --> 00:21:09,260
And then if you want a tower, you simply add

00:21:09,260 --> 00:21:12,000
the shooting an arrow component to the building.

00:21:12,000 --> 00:21:15,570
And if you want a -- if you want an invisible archer,

00:21:15,570 --> 00:21:17,580
you simply remove the rendering component,

00:21:17,580 --> 00:21:19,900
and this flattens out the structure of your game

00:21:19,900 --> 00:21:21,940
and makes it much easier for you to experiment

00:21:21,940 --> 00:21:24,140
with the code you've already written

00:21:24,140 --> 00:21:27,920
and come up with new features faster and more efficiently.

00:21:29,040 --> 00:21:31,100
In addition, it allows us to better consider

00:21:31,100 --> 00:21:36,540
performance optimizations because each individual feature

00:21:36,540 --> 00:21:41,440
has been isolated so that we can turn it off, turn it on,

00:21:41,440 --> 00:21:43,660
test how much time it's taking, so on and so forth,

00:21:43,660 --> 00:21:46,400
and reorganize the way it manages its data or whatever

00:21:46,400 --> 00:21:49,600
so that it works best for what needs to happen.

00:21:49,600 --> 00:21:51,600
And finally, it allows us to build game systems

00:21:51,600 --> 00:21:54,480
that can work together with minimal integration costs,

00:21:54,480 --> 00:21:57,100
because I can go and write a physics system

00:21:57,100 --> 00:22:01,180
that will work for anybody's game without even knowing what your game is.

00:22:01,180 --> 00:22:03,640
And as long as you...

00:22:04,520 --> 00:22:06,800
I mean, you can just throw it in your game and it's going to do

00:22:06,800 --> 00:22:11,000
what it was going to do regardless of what else is in your game.

00:22:11,000 --> 00:22:13,000
Everything else doesn't matter.

00:22:13,000 --> 00:22:17,800
Just the very specific dependencies of an individual component.

00:22:18,480 --> 00:22:20,280
And so...

00:22:21,320 --> 00:22:24,140
Here's my first introduction to KivEnt here.

00:22:24,140 --> 00:22:29,140
The number one idea behind KivEnt is that we need to take

00:22:29,140 --> 00:22:34,420
this velocity component Python object and turn it into a struct.

00:22:34,420 --> 00:22:38,680
And that's actually going to give you a huge amount of speedup

00:22:38,680 --> 00:22:42,700
if you follow this through, hundreds to thousands of times faster,

00:22:42,700 --> 00:22:46,680
because if you're, you know, looking up velocity

00:22:46,680 --> 00:22:50,720
on 10,000 different objects and you're looking it up in Python,

00:22:50,720 --> 00:22:52,700
that is a lot of look-up calls,

00:22:52,700 --> 00:22:55,260
and that's going to slow you down immensely.

00:22:55,260 --> 00:22:58,920
And so, now that we've turned it into a struct,

00:22:58,920 --> 00:23:01,380
the problem is you can no longer write from it from Python.

00:23:01,380 --> 00:23:04,300
Luckily, Cython does provide us with a really cool cdef class

00:23:04,300 --> 00:23:06,920
that allows us to sort of write a bunch of ugly boilerplate

00:23:06,920 --> 00:23:10,840
that eventually allows you to interact with your new C struct in a way that --

00:23:10,840 --> 00:23:15,720
from Python that is going to be pretty transparent to the user.

00:23:15,720 --> 00:23:21,400
They're just going to, you know, hit vx here and vy and it's, you know,

00:23:21,400 --> 00:23:24,740
just going to be object.vx and object.vy.

00:23:24,740 --> 00:23:30,140
And so Cython -- that's where I think Cython is better than, say,

00:23:30,140 --> 00:23:34,000
just writing a bunch of C or C++ code and then, you know,

00:23:34,000 --> 00:23:37,600
using C types or something to link it together, is that

00:23:37,600 --> 00:23:42,460
we have this ability to write some kind of Python/Cython shim here

00:23:42,460 --> 00:23:46,020
in the same language without really --

00:23:46,020 --> 00:23:48,900
with -- actually, I'm not entirely certain on this,

00:23:48,900 --> 00:23:52,680
but probably less of an overhead than going through CFFI.

00:23:54,080 --> 00:23:56,880
And so to kind of continue this example,

00:23:56,880 --> 00:24:00,600
the original component's update function would look like the one at the top,

00:24:00,600 --> 00:24:03,200
and the one below it is our new Cythonized update function.

00:24:03,200 --> 00:24:06,840
It's got -- everything has been typed out and it's going to be much faster

00:24:06,840 --> 00:24:09,660
and it's pretty much a flat C loop at this point.

00:24:09,660 --> 00:24:13,240
And at no point does the actual 'for' loop there

00:24:13,240 --> 00:24:17,120
hit Python objects or go through Python anything.

00:24:17,120 --> 00:24:19,120
It's all C.

00:24:20,200 --> 00:24:22,240
And...

00:24:22,240 --> 00:24:24,360
I really think one of the big things here

00:24:24,360 --> 00:24:27,280
is that when you use these entity-component architectures,

00:24:27,280 --> 00:24:31,180
you have a lot of code reusability. This is why the Unity 3D engine

00:24:31,180 --> 00:24:33,420
is so big, is that they have split everything

00:24:33,420 --> 00:24:35,920
into little systems that do individual things

00:24:35,920 --> 00:24:38,220
so that they can go share them with each other or sell them to each other

00:24:38,220 --> 00:24:42,300
and do all the things so that you're not starting from scratch every time

00:24:42,300 --> 00:24:44,660
or struggling to integrate very different models.

00:24:44,660 --> 00:24:49,180
It's a -- you know, we've agreed upon a way to set up the data,

00:24:49,180 --> 00:24:51,360
to store the data, and to initialize the game objects

00:24:51,360 --> 00:24:53,900
so that we can all share our work.

00:24:55,320 --> 00:24:59,780
And so I hope maybe you'll go try to build some games with Kivy and KivEnt

00:24:59,780 --> 00:25:02,780
in the near future. You can make them for all platforms.

00:25:02,780 --> 00:25:06,780
You can worry less about low-level concerns.

00:25:06,780 --> 00:25:10,500
You will have a plan for when you -- something is too slow for Python

00:25:10,500 --> 00:25:13,660
so that your game doesn't just stop in its tracks right there.

00:25:13,660 --> 00:25:17,100
And you will have a much better organization, I think,

00:25:17,100 --> 00:25:19,780
than just spaghetti coding everything together.

00:25:19,780 --> 00:25:23,020
If you want to learn more, my favorite blog

00:25:23,020 --> 00:25:25,720
about entity-component systems is the T-machine blog.

00:25:25,720 --> 00:25:29,060
He has many articles written over the last, like, eight years about it.

00:25:29,060 --> 00:25:34,500
And then of course Kivy and KivEnt's address there.

00:25:34,500 --> 00:25:37,540
Yeah. That's kind of my talk.

00:25:37,940 --> 00:25:41,260
[applause]

00:25:41,260 --> 00:25:43,220
(moderator) Thank you. We have a few more minutes

00:25:43,220 --> 00:25:45,140
for questions.

00:25:55,860 --> 00:25:57,780
(Jacob Kovac) I have remembered that I have some --

00:25:57,780 --> 00:25:59,600
(moderator) Can you please approach the microphone?

00:25:59,600 --> 00:26:01,520
(Jacob Kovac) Oh, sweet.

00:26:01,520 --> 00:26:03,980
I do have some demos I was going to show off here.

00:26:05,640 --> 00:26:09,160
This is KivEnt initializing game objects from Python.

00:26:09,160 --> 00:26:11,080
They're not being deleted.

00:26:11,080 --> 00:26:13,520
The counter at the bottom is the number of objects.

00:26:15,780 --> 00:26:18,380
You cannot do this in Python normally.

00:26:19,620 --> 00:26:21,920
(audience member) So, with your game engines,

00:26:21,920 --> 00:26:25,100
have you started looking into AR and VR applications?

00:26:25,100 --> 00:26:27,060
(Jacob Kovac) Can you speak up a little?

00:26:27,060 --> 00:26:29,140
(audience member) I'm sorry. With your game engine,

00:26:29,140 --> 00:26:31,960
have you started looking into AR and VR applications?

00:26:31,960 --> 00:26:36,160
(Jacob Kovac) I have not looked into any AR or VR stuff yet.

00:26:37,560 --> 00:26:40,320
Not really something that's in Kivy's wheelhouse right now.

00:26:40,320 --> 00:26:42,320
We've mainly stuck in the 2D area.

00:26:42,320 --> 00:26:46,540
I'm still interested in but have not started doing any 3D work.

00:26:46,540 --> 00:26:48,380
(audience member) Thank you.

00:26:50,700 --> 00:26:52,620
(audience member) So I missed the beginning.

00:26:52,620 --> 00:26:54,660
You might have mentioned this already, but have you looked into pypy

00:26:54,660 --> 00:26:56,820
on mobile devices yet, and if so, have you run into any

00:26:56,820 --> 00:26:59,000
particular challenges with that?

00:26:59,000 --> 00:27:01,040
(Jacob Kovac) I have not looked into it,

00:27:01,040 --> 00:27:04,060
but from my perspective,

00:27:04,060 --> 00:27:08,580
one of the issues with the just-in-time compilation method

00:27:08,580 --> 00:27:12,060
for apps like games and such is that oftentimes,

00:27:12,060 --> 00:27:15,860
particularly on mobile, your app may not run for more than 2, 3 minutes,

00:27:15,860 --> 00:27:20,340
and that's not exactly JIT's wheelhouse, really.

00:27:20,340 --> 00:27:24,640
In addition, as soon as you switch to pypy,

00:27:24,640 --> 00:27:27,020
you pretty much lose the entire Kivy ecosystem,

00:27:27,020 --> 00:27:30,477
so it's not exactly easy to just slot in a replacement

00:27:30,480 --> 00:27:36,160
since Kivy is so hooked into C and C-based things.

00:27:40,860 --> 00:27:43,360
(audience member) So you mentioned briefly

00:27:43,360 --> 00:27:45,500
about the Unity engine.

00:27:45,500 --> 00:27:49,420
Do you know if there's a way to use Python interface

00:27:49,420 --> 00:27:52,440
to actually call Unity libraries,

00:27:52,440 --> 00:27:55,840
or using the engine to develop games?

00:27:55,840 --> 00:27:58,000
(Jacob Kovac) Can you repeat your question a little louder?

00:27:58,000 --> 00:28:00,820
(audience member) You mentioned briefly about the Unity engine.

00:28:00,820 --> 00:28:05,360
I'm just wondering if there's a way to use Python interface

00:28:05,360 --> 00:28:09,940
to, like, develop games using Unity engine.

00:28:11,740 --> 00:28:13,780
(Jacob Kovac) I am not certain on that.

00:28:13,780 --> 00:28:16,140
I'm sure there's a way, because with programming,

00:28:16,140 --> 00:28:20,180
there's almost always a way, but I imagine it might be a little dirty,

00:28:20,180 --> 00:28:23,140
knowing how annoying it is to interopt just with C code

00:28:23,140 --> 00:28:25,440
or C++ code from C# in Unity.

00:28:25,440 --> 00:28:27,540
It's not exactly fun.

00:28:27,540 --> 00:28:30,720
(audience member) OK. Thanks.

00:28:39,280 --> 00:28:41,220
(moderator) If we don't have any further questions,

00:28:41,220 --> 00:28:43,380
let's give Jacob a round of applause.

00:28:43,380 --> 00:28:45,280
(Jacob Kovac) Thank you all very much.

00:28:45,280 --> 00:28:49,320

YouTube URL: https://www.youtube.com/watch?v=OSvlNh9aQDc


