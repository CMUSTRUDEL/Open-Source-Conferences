Title: Anthony Scopatz - xonsh - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Anthony Scopatz

Xonsh is general purpose shell that combines Python and the best features of Bash, zsh, and fish. Relying only the standard library and PLY, the xonsh language is a strict superset of Python that compiles to a Python AST.  The shell provides exciting features such as a rich history, tab completion from bash and man pages, syntax highlighting, auto-suggestion, foreign-function aliases and more!

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:01,380 --> 00:00:02,940
(host) Hello everyone.

00:00:02,940 --> 00:00:05,800
Our next speaker will be Anthony Scopatz, and he will be speaking to us

00:00:05,800 --> 00:00:08,460
about a new command-line shell that you might be interested in.

00:00:08,460 --> 00:00:10,740
So please join me in welcoming Anthony. Thank you.

00:00:10,740 --> 00:00:12,460
[applause]

00:00:12,460 --> 00:00:14,200
(Anthony Scopatz) All right.

00:00:15,040 --> 00:00:17,260
All right. Hello everyone.

00:00:17,260 --> 00:00:20,109
I'm Anthony Scopatz and this is xonsh.

00:00:20,109 --> 00:00:22,260
So what is xonsh?

00:00:22,260 --> 00:00:26,079
Xonsh is meant as a general purpose shell language

00:00:26,079 --> 00:00:29,739
to replace things like bash or fish or Z shell,

00:00:29,740 --> 00:00:34,620
but it also is simultaneously a Python superset language.

00:00:34,620 --> 00:00:38,180
And some of the features of this are that we have no external dependencies

00:00:38,180 --> 00:00:41,680
other than the Python library, Python itself.

00:00:41,680 --> 00:00:46,300
And so if you have Python, you also have the ability to have xonsh.

00:00:46,300 --> 00:00:48,200
And because of that, we support, you know,

00:00:48,200 --> 00:00:51,120
the big three major platforms, Linux, Mac, and Windows.

00:00:51,120 --> 00:00:54,000
And sort of the purpose of xonsh, at least in my mind,

00:00:54,000 --> 00:00:59,360
is to trick scientists and engineers into being more reproducible,

00:00:59,360 --> 00:01:01,200
but I don't have time to go into that into this talk,

00:01:01,200 --> 00:01:03,280
so you'll just have to talk to me about that later.

00:01:03,880 --> 00:01:06,119
There's a lot of fancy features, especially if you're willing

00:01:06,120 --> 00:01:11,000
to install some other code, and we'll see some of that in this talk.

00:01:11,280 --> 00:01:14,200
But before that, I just wanted to give some motivating examples

00:01:14,200 --> 00:01:20,080
between bash and other sh languages and what we have available in Python.

00:01:20,080 --> 00:01:23,859
So, you know, here's a simple example of a 'for' loop, right?

00:01:23,859 --> 00:01:26,519
In an sh-based language, you have to do a little more

00:01:26,520 --> 00:01:29,360
for a 'for' loop, not a big deal.

00:01:29,360 --> 00:01:31,540
Our Python version we all know and love.

00:01:31,540 --> 00:01:35,060
[audience member inaudible]

00:01:35,060 --> 00:01:37,840
How do I --? OK.

00:01:38,480 --> 00:01:40,920
Uh, yeah. OK. Well...

00:01:42,400 --> 00:01:45,220
I can do this, maybe?

00:01:47,100 --> 00:01:49,900
No. All right. They promised me something.

00:01:51,180 --> 00:01:53,320
There we go. Yes? No?

00:01:54,120 --> 00:01:55,760
All right.

00:01:56,680 --> 00:02:00,380
Yeah, there is no other resolution that works, so...

00:02:01,980 --> 00:02:05,940
That works? OK. All right. We'll go from here. All right.

00:02:10,260 --> 00:02:12,220
All right. Sorry.

00:02:13,700 --> 00:02:15,040
The best-laid technical plans.

00:02:15,680 --> 00:02:19,300
Woo! All right. Live debugging. This is what we're all about.

00:02:19,300 --> 00:02:23,000
So, another terrible bash example is testing whether a file exists.

00:02:23,000 --> 00:02:25,860
There's a beautiful Python API for doing this.

00:02:25,870 --> 00:02:29,090
And in shell-based lang-- er, in sh-based languages,

00:02:29,090 --> 00:02:31,750
there's a lot of syntax and some weird commands,

00:02:31,750 --> 00:02:34,360
and they overlap with a bunch of other syntax,

00:02:34,360 --> 00:02:36,180
and it's hard to keep straight.

00:02:36,180 --> 00:02:38,040
And you almost always have to look this up.

00:02:38,040 --> 00:02:42,000
And the last example is just tokenizing a string by a non-whitespace character.

00:02:42,000 --> 00:02:45,600
In Python this is super easy, and in shell-based languages,

00:02:45,610 --> 00:02:48,070
you have to set global state and then reset it back

00:02:48,070 --> 00:02:50,640
after you're done tokenizing the string. It's an absolute disaster.

00:02:50,640 --> 00:02:53,560
OK, so you're all motivated right now.

00:02:54,880 --> 00:02:59,060
So the stages of xonsh development sort of went as follows.

00:02:59,060 --> 00:03:01,380
There was this initial conceptualization stage

00:03:01,390 --> 00:03:04,800
where, you know, "This situation cannot stand,"

00:03:04,800 --> 00:03:08,400
so what if you had the ability to take the best parts of Python

00:03:08,400 --> 00:03:12,920
and the best parts of bash or some other language?

00:03:12,920 --> 00:03:16,220
And then that, inevitably, led into actually looking up how to do this,

00:03:16,220 --> 00:03:21,500
you know, researching things like ply and other parser libraries out there,

00:03:21,500 --> 00:03:25,040
and coming to the realization that, you know,

00:03:25,040 --> 00:03:28,700
maybe it actually can't be that hard, right?

00:03:28,700 --> 00:03:31,920
And that, inevitably, once you have all the pieces in your toolbox

00:03:31,930 --> 00:03:34,830
and you know how to do it, you see the way to do it,

00:03:34,830 --> 00:03:38,640
you go ahead and you feel that you must build this library.

00:03:38,640 --> 00:03:42,460
And that's kind of where we are at emotionally with xonsh right now.

00:03:42,460 --> 00:03:45,540
And the following stages of anger, regret, and acceptance

00:03:45,550 --> 00:03:47,990
are sure to follow any day now.

00:03:49,500 --> 00:03:52,640
Without further ado, let's actually dive into

00:03:52,640 --> 00:03:55,300
what the language actually looks like in some examples.

00:03:55,300 --> 00:03:57,400
This is best done in a demo, so prepare yourself

00:03:57,400 --> 00:04:00,500
for some really fast typing here.

00:04:00,500 --> 00:04:02,480
All right, so the first thing you'll notice about xonsh

00:04:02,480 --> 00:04:06,920
is that it's really meant to be used as a general-purpose shell,

00:04:06,920 --> 00:04:09,850
so the prompt looks like what you would see in other languages, right?

00:04:09,850 --> 00:04:14,050
It has the -- who you are and where you are in the file system, etc.

00:04:14,050 --> 00:04:16,160
But on the other hand, it really is Python,

00:04:16,160 --> 00:04:18,740
so you can do things like add two numbers together.

00:04:18,740 --> 00:04:20,830
What a novelty!

00:04:20,830 --> 00:04:23,380
Or you can import modules -- that's kind of nice --

00:04:23,380 --> 00:04:26,400
and access members of that module.

00:04:26,400 --> 00:04:29,720
Or -- whoops. Ah, OK, I'm all messed up here.

00:04:30,560 --> 00:04:32,080
Sorry.

00:04:32,600 --> 00:04:35,640
Yeah, sorry. The re-res messed me up.

00:04:35,640 --> 00:04:37,520
Or you can create dictionary literals

00:04:37,530 --> 00:04:42,590
and access members of those dictionary literals,

00:04:42,590 --> 00:04:47,050
or do more complex statements like 'if' statements, etc.,

00:04:47,050 --> 00:04:49,240
or 'for' loops or 'while' loops,

00:04:49,250 --> 00:04:52,690
or define functions in your current execution context,

00:04:52,690 --> 00:04:55,500
and then go ahead and call those functions, right?

00:04:55,500 --> 00:04:59,640
In some very real sense, xonsh is Python.

00:04:59,640 --> 00:05:01,700
And it's all -- but it's a little more than Python

00:05:01,710 --> 00:05:05,330
because we add a bunch of shell-like primitives

00:05:05,330 --> 00:05:07,100
to the Python language.

00:05:07,100 --> 00:05:10,660
So for instance, we add a $ operator

00:05:10,660 --> 00:05:13,220
that works like it would in bash,

00:05:13,220 --> 00:05:16,780
where it looks up variable names in the environment.

00:05:16,780 --> 00:05:19,340
And this is very similar, but the difference here

00:05:19,340 --> 00:05:23,389
is that we're able to go ahead and set variables

00:05:23,389 --> 00:05:25,689
like you would in Python,

00:05:25,689 --> 00:05:27,780
set environment variables like you would in Python,

00:05:27,790 --> 00:05:32,540
and then access those from subprocess commands like you would in bash.

00:05:32,540 --> 00:05:36,669
So xonsh keeps a very clear notion

00:05:36,669 --> 00:05:40,260
of whether you're in Python mode or subprocess mode,

00:05:40,260 --> 00:05:43,500
and we'll talk more about this in the coming slides.

00:05:43,500 --> 00:05:46,740
But you can access and modify the environment,

00:05:46,750 --> 00:05:49,570
you know, in a sort of more Pythonic way.

00:05:50,040 --> 00:05:52,240
And additionally, because it's Python,

00:05:52,240 --> 00:05:56,180
things like your path are really a list of strings, right?

00:05:56,180 --> 00:05:59,260
They're not some crazy colon-separated list of strings.

00:05:59,260 --> 00:06:01,980
And this works for any type. You can have any structure.

00:06:01,980 --> 00:06:04,380
You can have your own custom class that you stick an instance of

00:06:04,389 --> 00:06:07,469
into your environment and then access it that way.

00:06:07,469 --> 00:06:10,829
OK. So that's easy peasy.

00:06:11,620 --> 00:06:15,200
Additionally, we add a ${ } operator,

00:06:15,200 --> 00:06:20,860
and what this does, it's distinct from the same operator in bash.

00:06:20,870 --> 00:06:23,340
So here we look up the environment variable

00:06:23,340 --> 00:06:28,460
based on an expression that's been evaluated inside of the curly braces.

00:06:28,460 --> 00:06:32,100
And so, you know, you can use this to programmatically look up variables

00:06:32,100 --> 00:06:34,020
if that's something that you want to do.

00:06:34,020 --> 00:06:38,100
And of course all of this stuff is available in subprocess mode as well,

00:06:38,110 --> 00:06:41,100
so you can echo "~ cows come $HOME".

00:06:41,100 --> 00:06:44,500
Additionally, if you look up an ellipsis,

00:06:44,500 --> 00:06:47,980
so if you do ${...},

00:06:47,980 --> 00:06:50,880
this is a reference to the environment itself.

00:06:50,880 --> 00:06:54,740
And so you're able to do things like test for containment

00:06:54,740 --> 00:06:58,020
or access methods of the environment

00:06:58,020 --> 00:07:01,900
just by using ${...}.

00:07:01,900 --> 00:07:03,520
OK.

00:07:04,160 --> 00:07:06,060
Moving right along, it wouldn't be a very good shell

00:07:06,060 --> 00:07:09,199
if you could change directories, so here we've just changed directory

00:07:09,200 --> 00:07:11,840
into the xonsh repository.

00:07:11,840 --> 00:07:13,960
And as you see, when you do that,

00:07:13,960 --> 00:07:17,180
the branch name pops up appropriately colored.

00:07:17,180 --> 00:07:20,100
This works with both mercurial and git,

00:07:20,100 --> 00:07:24,620
and so it's really sort of a developer-facing tool in that regard.

00:07:24,620 --> 00:07:28,540
It's meant to have all of these things that you would like and use.

00:07:28,540 --> 00:07:32,260
Additionally, if we go ahead and type "git sta" and then hit tab,

00:07:32,260 --> 00:07:34,360
you'll see that we have this drop-down menu

00:07:34,360 --> 00:07:37,880
of all the tab completion options that are available.

00:07:37,880 --> 00:07:41,440
And in particular, this is actually just eating

00:07:41,449 --> 00:07:43,689
the bash completions that have already been written.

00:07:43,689 --> 00:07:46,040
So we don't have to necessarily rewrite

00:07:46,040 --> 00:07:48,400
all of the completers for all the commands out there.

00:07:48,400 --> 00:07:50,750
They're just accessible to xonsh.

00:07:50,750 --> 00:07:54,250
And this works even on Windows, which is kind of cool.

00:07:55,540 --> 00:07:59,740
So, let's go back to the home directory.

00:08:01,020 --> 00:08:03,800
Additionally we have this $( ) operator

00:08:03,800 --> 00:08:06,220
which does pretty much exactly the same thing

00:08:06,229 --> 00:08:09,500
that it does in an sh-based language in that it returns to you

00:08:09,500 --> 00:08:12,300
the result of a subprocess as a string.

00:08:12,300 --> 00:08:14,260
No big deal there.

00:08:14,260 --> 00:08:16,560
Additionally, you can -- this is available

00:08:16,570 --> 00:08:18,890
in both Python mode and subprocess mode,

00:08:18,890 --> 00:08:23,430
so you can do $( ) to subprocess --

00:08:23,430 --> 00:08:25,970
to capture the subprocess as a Python variable,

00:08:25,970 --> 00:08:28,460
and then use Python string manipulation

00:08:28,460 --> 00:08:32,380
to modify that string however you want.

00:08:32,380 --> 00:08:34,700
And that's just a single expression.

00:08:34,700 --> 00:08:38,660
Additionally, we also add an !() operator.

00:08:38,660 --> 00:08:42,560
And what this does is it returns to you a special completed command object

00:08:42,560 --> 00:08:46,020
that contains not only the standard out but all of the metadata

00:08:46,020 --> 00:08:49,240
about how that command was run and what its results were.

00:08:50,200 --> 00:08:54,500
And furthermore, we add a ![ ] operator

00:08:54,500 --> 00:08:58,660
that does pretty much the same thing except that it streams the results to you.

00:08:58,660 --> 00:09:00,920
And then after that, you know,

00:09:00,920 --> 00:09:03,720
after you have this X, you're able to access things

00:09:03,720 --> 00:09:06,640
like the timestamp for when the command started and stopped,

00:09:06,640 --> 00:09:08,720
the alias that the command was run with,

00:09:08,720 --> 00:09:12,200
and we even implement appropriate Boolean semantics.

00:09:12,200 --> 00:09:17,320
So we look at the return value of that completed command

00:09:17,320 --> 00:09:20,740
and test whether it's equal to 0 and return that.

00:09:21,560 --> 00:09:23,240
OK.

00:09:23,680 --> 00:09:26,640
So, so far what we've seen is subprocess mode in Python mode.

00:09:26,640 --> 00:09:30,160
But of course we -- xonsh allows us to go the other way.

00:09:30,160 --> 00:09:32,900
And so, say we have two Python variables here.

00:09:32,910 --> 00:09:36,050
If we do "echo @( )",

00:09:36,050 --> 00:09:38,800
we evaluate what's inside of those parentheses

00:09:38,800 --> 00:09:41,660
as a Python expression, and then pass that --

00:09:41,660 --> 00:09:44,420
convert that to a string and then pass that down as a single argument

00:09:44,430 --> 00:09:47,610
to any subprocess that we want to call.

00:09:48,620 --> 00:09:50,660
And additionally, you know, this works for anything

00:09:50,660 --> 00:09:52,820
that's string convertible, so you could "echo @(2+2)"

00:09:52,830 --> 00:09:55,630
and actually get the result that you're interested in.

00:09:56,220 --> 00:10:00,800
And furthermore, if you pass in a list of expressions,

00:10:00,800 --> 00:10:03,700
each of those expressions will get sent down

00:10:03,700 --> 00:10:08,860
to the subprocess as individual arguments in the argument list.

00:10:09,980 --> 00:10:12,820
And obviously this stuff is perfectly nestable,

00:10:12,820 --> 00:10:15,600
and so if you're in Python mode and then you go into subprocess mode,

00:10:15,600 --> 00:10:20,060
you can go back into Python mode and everything works out just fine.

00:10:20,920 --> 00:10:24,600
Moreover, you can use this @( ) stuff

00:10:24,600 --> 00:10:27,500
to programmatically determine

00:10:27,500 --> 00:10:31,460
what command you want to run. Whether or not that's useful

00:10:31,460 --> 00:10:34,500
or how much obfuscation you like is up to you.

00:10:34,500 --> 00:10:37,120
But the place where this @() stuff really shines for me

00:10:37,120 --> 00:10:41,080
is the fact that you can now use normal Python looping semantics

00:10:41,080 --> 00:10:44,180
to loop over a set of data, and then run over subprocess commands

00:10:44,180 --> 00:10:47,840
very, very easily, like we see in this example here.

00:10:48,420 --> 00:10:50,520
OK. All right.

00:10:51,940 --> 00:10:53,820
Next, it wouldn't be a very good shell, of course,

00:10:53,820 --> 00:10:57,040
if you couldn't pipe things, so we implemented piping.

00:10:57,040 --> 00:11:00,340
Similarly, it wouldn't be a very good shell if you couldn't redirect things,

00:11:00,340 --> 00:11:06,050
so redirection to a file or to -- from standard error to standard out

00:11:06,050 --> 00:11:09,790
and all those things are available as well.

00:11:10,620 --> 00:11:12,070
OK.

00:11:14,420 --> 00:11:17,760
Additionally, we added, by popular demand,

00:11:17,760 --> 00:11:21,980
the ability to 'and' and 'or' subprocesses together

00:11:21,980 --> 00:11:24,320
using Python's 'and' and 'or' keywords.

00:11:24,330 --> 00:11:28,220
And this -- all this is doing is it's wrapping those subprocess commands

00:11:28,220 --> 00:11:31,720
in ![ ] before it runs them.

00:11:32,300 --> 00:11:34,500
And don't worry if you have a lot of muscle memory

00:11:34,510 --> 00:11:37,110
and you want to use &&||.

00:11:37,110 --> 00:11:40,830
You're welcome to do so. I won't hold it against you.

00:11:41,240 --> 00:11:43,140
And the place that this is particularly useful

00:11:43,140 --> 00:11:47,040
is if you want to test if a file exists and that a file doesn't exist --

00:11:47,040 --> 00:11:49,529
and that another file doesn't exist.

00:11:49,529 --> 00:11:53,489
If you do that, you'll just get back the appropriate Boolean.

00:11:53,489 --> 00:11:55,709
And this is all, you know,

00:11:55,709 --> 00:11:58,440
using the normal kind of Python 'and' and 'or',

00:11:58,450 --> 00:12:01,880
and parentheses groupings and negation semantics

00:12:01,880 --> 00:12:04,020
that we all know from Python.

00:12:05,460 --> 00:12:08,280
Additionally, we add

00:12:08,280 --> 00:12:11,440
regular expression file globbing using backticks.

00:12:11,440 --> 00:12:14,020
So anything in the backtick

00:12:14,020 --> 00:12:17,760
is compiled as a regular expression

00:12:17,760 --> 00:12:20,400
and then sent down to either the subprocess,

00:12:20,400 --> 00:12:24,040
or it returns a list of strings in Python mode.

00:12:24,050 --> 00:12:26,660
So we could write more complicated regular expressions.

00:12:26,660 --> 00:12:30,000
So if we -- initially we were just looking at all the Python files

00:12:30,000 --> 00:12:31,940
in a directory, but if, you know, we wanted to look at

00:12:31,940 --> 00:12:35,800
all the Python files that didn't include an underscore,

00:12:35,800 --> 00:12:37,760
that's easy to represent as well.

00:12:37,760 --> 00:12:39,640
And to just show that this works in Python mode,

00:12:39,640 --> 00:12:43,520
we can go ahead and take the length of that regular expression.

00:12:45,580 --> 00:12:49,280
OK. Like IPython, we add a '?' operator

00:12:49,290 --> 00:12:55,100
to give you help on whatever object you ask for help on. No big deal there.

00:12:55,100 --> 00:12:59,620
We also add a super help operator, so you can do '??',

00:12:59,620 --> 00:13:03,540
and what this does is, it goes and tries to find the source code

00:13:03,540 --> 00:13:07,860
that the object was defined with, and in xonsh we go ahead and

00:13:07,860 --> 00:13:11,480
syntax highlight that source code for you as well before we print it.

00:13:12,720 --> 00:13:14,220
OK.

00:13:14,980 --> 00:13:16,920
Additionally we have an aliases mapping, right.

00:13:16,930 --> 00:13:20,710
So this just maps command names

00:13:20,710 --> 00:13:23,350
to the command that you want to run.

00:13:23,820 --> 00:13:26,600
Nothing super complex there, except for the fact

00:13:26,600 --> 00:13:29,760
that we have a few different forms of aliases.

00:13:29,760 --> 00:13:34,510
So we have the normal diff -- the normal list of strings-based aliases

00:13:34,510 --> 00:13:39,330
that you would see in a bash or in other kinds of shells.

00:13:39,330 --> 00:13:41,740
But since we're Python, we also have the ability

00:13:41,740 --> 00:13:43,990
to take functions as aliases.

00:13:43,990 --> 00:13:47,870
So here let's just define a little alias

00:13:47,870 --> 00:13:51,180
that takes a lambda, that accepts the standard args --

00:13:51,180 --> 00:13:54,320
or, accepts an argument list and a standard in.

00:13:54,320 --> 00:13:58,140
And here we're just going to ignore that and return a string no matter what.

00:13:58,150 --> 00:14:03,250
You can also return standard error and return code if you desire.

00:14:03,250 --> 00:14:05,260
And so when we go ahead and run this command on the command line,

00:14:05,260 --> 00:14:07,320
we just get that string printed out.

00:14:07,320 --> 00:14:10,399
But this -- so maybe doing something a little more interesting.

00:14:10,400 --> 00:14:13,700
If we create another lambda that actually reads from standard in

00:14:13,700 --> 00:14:18,040
and maybe formats a string using Python string formatting,

00:14:18,040 --> 00:14:22,260
and then returns that result. So here, once we have this set up,

00:14:22,260 --> 00:14:26,480
we can go ahead and echo a name and then pipe that to our new alias,

00:14:26,480 --> 00:14:29,780
and we see the ominous message that we would expect.

00:14:31,740 --> 00:14:33,240
All right.

00:14:34,560 --> 00:14:37,040
Additionally,

00:14:37,040 --> 00:14:42,380
xonsh has a very well-defined notion of what it means to be a foreign shell,

00:14:42,380 --> 00:14:46,120
and so just as an example here, here's a little bash script

00:14:46,120 --> 00:14:48,860
called owl.sh that does a few different things.

00:14:48,860 --> 00:14:52,440
So the first thing that it does is it exports an environment variable,

00:14:52,440 --> 00:14:56,680
it defines an alias, and it also defines a bash function.

00:14:56,680 --> 00:15:00,200
Now in xonsh, we add a source bash command

00:15:00,200 --> 00:15:02,520
that allows you to source this bash file

00:15:02,520 --> 00:15:05,040
in exactly the same way that you would source it in bash

00:15:05,040 --> 00:15:08,060
And so if we look, we can see that this environment variable

00:15:08,060 --> 00:15:11,580
is loaded into the xonsh environment when we source that file.

00:15:11,580 --> 00:15:14,460
Additionally, we get the alias, as you would expect,

00:15:14,460 --> 00:15:16,620
and we can even call this bash function

00:15:16,620 --> 00:15:19,450
in exactly the same way that you would call it in bash.

00:15:19,450 --> 00:15:22,140
And this all just works. And so this is implemented currently

00:15:22,140 --> 00:15:27,600
for bash, Z shell, and cmd.exe.

00:15:27,600 --> 00:15:30,840
And clearly there's still a big fish in the room here.

00:15:33,840 --> 00:15:38,200
Of course, you know, another one -- another thing that makes --

00:15:38,200 --> 00:15:42,340
would make xonsh not be very good language is if it didn't have a file format.

00:15:42,340 --> 00:15:46,850
So here we are showing just that same owl.sh script

00:15:46,850 --> 00:15:49,730
written in the .xsh xonsh format.

00:15:49,730 --> 00:15:53,260
And additionally we've added a Python function

00:15:53,260 --> 00:15:57,380
that times a ping command and then returns the result.

00:15:57,390 --> 00:16:00,490
So if you go ahead and source owl.xsh,

00:16:00,490 --> 00:16:04,340
you get that timed ping command loaded into your current Python context

00:16:04,340 --> 00:16:06,240
and it runs just fine.

00:16:06,240 --> 00:16:10,080
Additionally xonsh also has import hooks for any .xsh file.

00:16:10,080 --> 00:16:13,020
So you can go ahead and those are easy to load

00:16:13,020 --> 00:16:16,360
thanks to Brett Cannon and other people.

00:16:16,370 --> 00:16:19,420
And you can just -- if you prefer to import owl

00:16:19,420 --> 00:16:23,640
and then do owl.time_ping, you're welcome to run code that way.

00:16:23,640 --> 00:16:25,360
OK.

00:16:25,360 --> 00:16:30,040
It's worth mentioning that xonsh has a very rich and detailed notion

00:16:30,040 --> 00:16:33,510
of what history is that I don't have time to go into here.

00:16:33,510 --> 00:16:36,070
So you're just going to have to look up the docs on your own,

00:16:36,070 --> 00:16:38,360
or talk to me afterwards, and this was kind of put in there

00:16:38,360 --> 00:16:41,360
for some of these reproducibility concerns that I mentioned before.

00:16:41,360 --> 00:16:42,840
OK.

00:16:43,340 --> 00:16:47,160
That all being said,

00:16:47,160 --> 00:16:51,320
xonsh -- the purpose of that was to show you that xonsh really is Python,

00:16:51,320 --> 00:16:53,550
but it also is meant to be used as a general-purpose shell,

00:16:53,550 --> 00:16:57,540
and so there's a more detailed translation guide

00:16:57,540 --> 00:17:01,100
on the website that you're welcome to check out.

00:17:01,100 --> 00:17:02,920
And how does all of this stuff work?

00:17:02,920 --> 00:17:04,779
Well, it works like most languages work.

00:17:04,779 --> 00:17:06,620
So we go through a number of common phases.

00:17:06,620 --> 00:17:11,040
We have a tokenizer, a lexer, a parser, compilation and execution stages.

00:17:11,040 --> 00:17:13,240
But the thing that's different is that xonsh inserts

00:17:13,250 --> 00:17:16,330
the syntax tree transformation phase.

00:17:16,330 --> 00:17:18,560
And this is super important.

00:17:18,569 --> 00:17:22,280
So, just to go through these one by one,

00:17:22,280 --> 00:17:25,790
the tokenizer and lexer are a little more complicated than you would think

00:17:25,790 --> 00:17:29,650
because xonsh has to keep track at a very deep level

00:17:29,650 --> 00:17:35,150
of whether it thinks you're in Python mode or in subprocess mode.

00:17:35,150 --> 00:17:39,200
Python is not whitespace-sensitive inside of an expression.

00:17:39,200 --> 00:17:41,970
So the three "ls -l" examples up here

00:17:41,970 --> 00:17:45,950
all compile to the exact same Python code.

00:17:45,950 --> 00:17:51,860
However, subprocess mode is exactly whitespace-sensitive.

00:17:51,870 --> 00:17:54,950
So these three "ls -l" expressions

00:17:54,950 --> 00:17:59,340
appear compiled to three distinct pieces of code

00:17:59,340 --> 00:18:02,000
and have different representations and would do different things.

00:18:02,000 --> 00:18:05,150
So we need some way of resolving the ambiguity

00:18:05,150 --> 00:18:07,670
between Python's whitespace-insensitiveness

00:18:07,670 --> 00:18:13,490
and subprocess's whitespace-sensitive aspects,

00:18:13,490 --> 00:18:15,810
which we'll get to in a couple slides.

00:18:15,810 --> 00:18:19,000
The parser is written in ply, and what the parser does is

00:18:19,010 --> 00:18:24,510
it produces a syntax tree of normal Python AST nodes.

00:18:24,510 --> 00:18:27,580
And so when I say xonsh is Python,

00:18:27,580 --> 00:18:30,340
it actually does produce the same exact syntax tree

00:18:30,340 --> 00:18:34,480
that if you called ast.parse you would get

00:18:34,480 --> 00:18:36,740
from the Python standard library.

00:18:36,740 --> 00:18:38,620
And this is really useful because we can just

00:18:38,620 --> 00:18:42,400
hand that syntax tree off to functions like exec and compile.

00:18:42,400 --> 00:18:44,900
And it's then the Python interpreter's job

00:18:44,910 --> 00:18:46,980
and we don't have to care about it anymore.

00:18:46,980 --> 00:18:49,000
And to make all this work, we shove a bunch of things

00:18:49,010 --> 00:18:51,630
into builtins. So sue us.

00:18:54,720 --> 00:18:57,100
The syntax tree transformation phase is really here

00:18:57,110 --> 00:19:00,030
to resolve this ls -l ambiguity.

00:19:00,030 --> 00:19:01,900
And so this has two subphases.

00:19:01,900 --> 00:19:06,260
It has a first phase which is context-insensitive,

00:19:06,260 --> 00:19:09,600
and then the second phase which is context-sensitive.

00:19:09,600 --> 00:19:13,700
And so, to keep this clear, we try to reduce this --

00:19:13,710 --> 00:19:16,360
we've reduced this to just a couple of simple rules

00:19:16,360 --> 00:19:18,880
for what it means to do context-sensitive parsing

00:19:18,880 --> 00:19:20,960
so that you can gain an intuition

00:19:20,960 --> 00:19:23,700
about how a command's gonna work or when it's gonna run.

00:19:26,540 --> 00:19:30,580
If the -- the rules are basically: if the leftmost name is in --

00:19:30,590 --> 00:19:33,750
is not in the Python context or Python scope,

00:19:33,750 --> 00:19:37,720
and the expression as a whole can be parsed in subprocess mode,

00:19:37,720 --> 00:19:41,110
so if the ls is not a Python variable, basically,

00:19:41,110 --> 00:19:44,510
then we will go ahead and wrap it in ![].

00:19:44,510 --> 00:19:49,960
And if the leftmost name is in the Python scope,

00:19:49,970 --> 00:19:52,790
then Python always wins and we parse it as Python.

00:19:52,790 --> 00:19:55,100
And if it doesn't compile

00:19:55,110 --> 00:19:57,590
with either Python mode or in subprocess mode,

00:19:57,590 --> 00:20:01,150
then it's a syntax error and we raise it as such.

00:20:01,150 --> 00:20:06,250
And if you want to avoid this, you're welcome to always type ![ ].

00:20:06,250 --> 00:20:08,010
It's your fingers.

00:20:08,720 --> 00:20:11,780
Compilation and execution, nothing new and special here.

00:20:11,780 --> 00:20:14,660
So we just hand it off to the Python interpreter.

00:20:15,520 --> 00:20:20,160
So that being said, I wanted to show you some more intense examples

00:20:20,160 --> 00:20:22,100
about sort of the things that you can do with xonsh

00:20:22,100 --> 00:20:24,120
now that you have this language available.

00:20:24,120 --> 00:20:28,220
So here is a ridiculous way to --

00:20:28,220 --> 00:20:31,360
really obfuscated way of typing ls -l

00:20:31,360 --> 00:20:36,520
using all the xonsh syntax.

00:20:36,520 --> 00:20:40,120
Sort of a silly example. I guess my thing is lost here.

00:20:40,120 --> 00:20:43,260
But another motivating piece

00:20:43,260 --> 00:20:45,880
is that the...

00:20:47,080 --> 00:20:50,140
You have the full Python library --

00:20:50,140 --> 00:20:53,480
you have all the Python ecosystem and libraries available to you,

00:20:53,480 --> 00:20:55,260
and you can directly pipe things.

00:20:55,260 --> 00:20:58,180
Wow, I'm gonna have to make this a little bigger. I'm sorry.

00:21:01,340 --> 00:21:03,940
Yeah. So, sorry if it gets cut off. Oops.

00:21:05,360 --> 00:21:08,060
So you can directly pipe things from the internet.

00:21:08,060 --> 00:21:10,100
So, say you wanted to go grab the xonsh license.

00:21:10,100 --> 00:21:14,280
You can take nltk and pass the result directly into nltk

00:21:14,280 --> 00:21:18,620
and get the first seven sentences or so as a list,

00:21:18,620 --> 00:21:21,580
just as a single Python expression.

00:21:22,220 --> 00:21:23,840
OK.

00:21:25,080 --> 00:21:29,200
This is also useful in -- wow, this is not working out. I'm sorry.

00:21:32,320 --> 00:21:34,340
Sorry if it gets cut off.

00:21:37,580 --> 00:21:41,760
So, you can also use this to grab --

00:21:41,770 --> 00:21:44,600
say you have some JSON API from the internet

00:21:44,600 --> 00:21:47,539
and you want to go grab that, you can pipe --

00:21:47,540 --> 00:21:49,400
use curl to grab that from the internet

00:21:49,400 --> 00:21:52,640
and then directly pass that into JSON.loads

00:21:52,650 --> 00:21:55,450
and use that to format a string.

00:21:55,450 --> 00:21:58,040
So if you deal with a lot of JSON APIs, this is, you know,

00:21:58,040 --> 00:22:00,419
all done as a potentially single expression

00:22:00,419 --> 00:22:04,579
and it will print you that message right away.

00:22:05,900 --> 00:22:08,060
That's something cool that can be done. Additionally,

00:22:08,060 --> 00:22:12,860
xonsh has a very well-developed notion of colors and color management.

00:22:14,700 --> 00:22:16,960
This was put in for a couple of reasons, like perhaps

00:22:16,960 --> 00:22:20,940
you're on a terrible system with really bad color styles,

00:22:20,940 --> 00:22:23,320
but also sort of the more important aspect

00:22:23,320 --> 00:22:26,720
is for people who may be colorblind,

00:22:26,720 --> 00:22:29,600
this is really helpful because you are able to --

00:22:29,600 --> 00:22:33,420
they're able to select a color palette that works for them.

00:22:33,420 --> 00:22:35,960
All right. So, finishing up here,

00:22:35,960 --> 00:22:39,660
while I'm on the subject of colors, just going to jump ahead here.

00:22:39,660 --> 00:22:42,440
If you import numpy and matplotlib,

00:22:42,440 --> 00:22:45,110
we have a third-party extension system that lets you --

00:22:45,110 --> 00:22:48,650
that we have written hooks for a matplotlib in,

00:22:48,650 --> 00:22:52,580
and will allow you to just dump out the current figure

00:22:52,590 --> 00:22:55,770
as -- via background colors.

00:22:55,770 --> 00:22:57,900
So, bam.

00:22:57,900 --> 00:23:03,280
[laughter, applause]

00:23:03,280 --> 00:23:06,620
If you like really pixelated graphics, I guess.

00:23:07,420 --> 00:23:09,500
Just to finish up,

00:23:09,500 --> 00:23:12,220
we believe that xonsh is a usable tool right now as a shell.

00:23:12,220 --> 00:23:15,660
There's obviously more to do. We're at version 0.3.2.

00:23:15,660 --> 00:23:19,760
Please, we love to have a community of users and contributors,

00:23:19,770 --> 00:23:23,690
so please, you know, try it out and let us know how you feel.

00:23:23,690 --> 00:23:27,720
And just remember that a vote for the shell in 2015

00:23:27,720 --> 00:23:31,040
yields xonsh in 2016. Thank you very much.

00:23:31,040 --> 00:23:36,760
[applause]

00:23:36,760 --> 00:23:38,420
(host) Thank you very much, Anthony.

00:23:38,430 --> 00:23:40,100
We do have time for some questions.

00:23:40,100 --> 00:23:42,179
So there are two microphones on either side of the room.

00:23:42,179 --> 00:23:44,339
Please feel free to line up and Anthony can answer.

00:23:44,340 --> 00:23:46,100
We'll start on this side.

00:23:46,100 --> 00:23:47,960
(audience member) Hey, great talk. I think I'm looking

00:23:47,960 --> 00:23:50,100
at my new shell. But one question:

00:23:50,110 --> 00:23:54,340
does there -- is there the prompt command?

00:23:54,340 --> 00:23:56,180
(Anthony Scopatz) The prompt command?

00:23:56,180 --> 00:23:58,100
(audience member) Yeah, so like, every time you hit Enter

00:23:58,100 --> 00:24:02,300
it can run a command as it -- like, to create your prompt?

00:24:02,300 --> 00:24:04,180
Like PS1 command.

00:24:04,180 --> 00:24:05,980
(Anthony Scopatz) Yeah. So you can mod --

00:24:05,980 --> 00:24:07,940
there's actually a prompt environment variable

00:24:07,950 --> 00:24:10,380
that you can totally customize and modify,

00:24:10,380 --> 00:24:12,200
and this is all the docs. And so, yeah.

00:24:12,200 --> 00:24:14,280
(audience member) OK, so as I go, it could --

00:24:14,280 --> 00:24:16,280
(Anthony Scopatz) Yeah, it's just called $ prompt,

00:24:16,280 --> 00:24:20,270
and there's huge documentation on how you color that and what aspects you want.

00:24:20,270 --> 00:24:22,630
There's even a write prompt if that's something you're interested in.

00:24:22,630 --> 00:24:24,870
you can customize the multi-line prompt and everything.

00:24:24,870 --> 00:24:26,810
(audience member) OK, awesome. Thank you.

00:24:29,800 --> 00:24:31,680
(audience member) Thank you.

00:24:32,200 --> 00:24:34,500
OK, I've got two questions.

00:24:34,500 --> 00:24:38,760
First, is this a strict superset of Python syntax?

00:24:38,760 --> 00:24:41,460
And second would be, have you implemented

00:24:41,460 --> 00:24:44,820
process substitution from bash and Korn shell?

00:24:44,820 --> 00:24:46,660
(Anthony Scopatz) Yes to both of those.

00:24:46,660 --> 00:24:48,100
(audience member) Awesome.

00:24:48,100 --> 00:24:49,860
(Anthony Scopatz) Now the process substitution

00:24:49,860 --> 00:24:52,140
may be buggy still, but it has been implemented.

00:24:52,140 --> 00:24:53,780
[laughter]

00:24:53,780 --> 00:24:56,280
(audience member) So, just a quick question on performance

00:24:56,289 --> 00:25:00,400
compared to other shells, a few words you can say about that?

00:25:00,400 --> 00:25:03,620
(Anthony Scopatz) Yeah, so startup times currently suck,

00:25:03,620 --> 00:25:05,540
but we're working on that,

00:25:05,540 --> 00:25:09,080
and they got worse on the last release, sadly, but we know how to fix it.

00:25:09,080 --> 00:25:11,140
The actual performance of different pieces,

00:25:11,140 --> 00:25:13,880
so the compilation/execution stage is actually relatively quick,

00:25:13,880 --> 00:25:16,860
and even doing things like tab completing

00:25:16,860 --> 00:25:18,760
is actually much faster than other shells

00:25:18,760 --> 00:25:22,520
because we keep in memory sort of all of these components.

00:25:22,520 --> 00:25:26,640
So in general the actual execution while you type is not so bad.

00:25:26,640 --> 00:25:28,540
It's just the startup time that we need to deal with.

00:25:28,540 --> 00:25:30,340
(audience member) Thank you.

00:25:31,140 --> 00:25:33,140
(audience member) Does it work inside a Jupiter notebook?

00:25:33,140 --> 00:25:35,040
(Anthony Scopatz) Yes it does. We come --

00:25:35,040 --> 00:25:37,900
we ship stock with a Jupiter notebook hook.

00:25:39,940 --> 00:25:42,920
(audience member) Does xonsh play nicely with virtualenvs?

00:25:42,920 --> 00:25:46,659
(Anthony Scopatz) It does, and we also have a command --

00:25:46,659 --> 00:25:49,730
so there's been a lot of talk about this, and so worst case scenario,

00:25:49,730 --> 00:25:53,170
we also ship with some virtualenv commands as well.

00:25:53,170 --> 00:25:55,740
But a lot of the foreign shell interface stuff

00:25:55,740 --> 00:25:58,080
was actually motivated by virtualenv.

00:25:58,080 --> 00:26:01,940
Now, virtualemv does some ridiculous things, and that makes it difficult,

00:26:01,940 --> 00:26:04,860
so if you're running into those, we have alternatives for you.

00:26:04,900 --> 00:26:06,840
(audience member) Perfect, thank you.

00:26:06,840 --> 00:26:09,000
(audience member) Amazing product.

00:26:09,000 --> 00:26:11,580
Why do you think it is that it took us until the year 2016

00:26:11,580 --> 00:26:13,580
to get to something like this?

00:26:13,580 --> 00:26:16,740
And how long do you think it'll be before this becomes standard,

00:26:16,740 --> 00:26:19,559
and then before we can settle on something

00:26:19,559 --> 00:26:21,919
a little bit less Frankenstein's-monster-feeling

00:26:21,920 --> 00:26:24,200
and more just, like, pure shell awesomeness,

00:26:24,200 --> 00:26:26,300
which is where this is taking us?

00:26:28,540 --> 00:26:31,140
(Anthony Scopatz) Why do I think it took until 2016?

00:26:31,150 --> 00:26:33,530
It was that moral compulsion to act, and probably the fact

00:26:33,530 --> 00:26:36,040
that no one wanted to re-implement the Python language spec,

00:26:36,040 --> 00:26:40,700
which I did as a stress reliever project while writing a book.

00:26:40,700 --> 00:26:42,300
(audience member) So you're a hero.

00:26:42,300 --> 00:26:44,160
(Anthony Scopatz) And then the --

00:26:44,160 --> 00:26:46,220
see, writing a book can be effective.

00:26:46,220 --> 00:26:49,120
And then, how long does it take till this becomes standard?

00:26:49,120 --> 00:26:51,000
Hopefully tonight.

00:26:51,000 --> 00:26:55,620
[laughter, applause]

00:26:55,620 --> 00:26:58,960
(audience member) Yeah, so this is insanely awesome.

00:26:58,960 --> 00:27:01,280
What's the configuration scheme and does it work with, like,

00:27:01,290 --> 00:27:03,580
bash profiles, bash rc, any of that?

00:27:03,580 --> 00:27:05,420
(Anthony Scopatz) Yeah, actually, so another reason

00:27:05,420 --> 00:27:08,760
for the foreign shell interface is that by default,

00:27:08,760 --> 00:27:11,920
it will load your bash profile and everything.

00:27:11,920 --> 00:27:14,160
But you can set it up to load your profile

00:27:14,160 --> 00:27:16,700
from any other shell that we have hooks for,

00:27:16,700 --> 00:27:19,240
or set it up to load profiles from no shell.

00:27:19,240 --> 00:27:23,200
And so, yes, it's -- we've rounded that out.

00:27:24,140 --> 00:27:26,300
(audience member) I noticed when -- well,

00:27:26,310 --> 00:27:29,880
when you ran ls earlier, the output was a little bit slow to come through.

00:27:29,880 --> 00:27:31,720
Is that because of the Chrome extension

00:27:31,720 --> 00:27:33,600
that you're using, or is that a performance thing?

00:27:33,610 --> 00:27:35,460
(Anthony Scopatz) Oh, this was not live.

00:27:35,460 --> 00:27:37,260
This was me fake typing.

00:27:37,260 --> 00:27:39,560
Yeah, I was not going to do that live.

00:27:39,560 --> 00:27:42,220
Did you see that URL for the weather underground? Come on.

00:27:42,220 --> 00:27:44,380
[laughter]

00:27:44,380 --> 00:27:46,220
(audience member) Thank you.

00:27:47,220 --> 00:27:49,380
(audience member) I was wondering if,

00:27:49,380 --> 00:27:52,580
in addition to standard libraries, can I install, like, requests

00:27:52,580 --> 00:27:56,150
and then suddenly start using requests as part of the command line?

00:27:56,150 --> 00:27:57,980
(Anthony Scopatz) Yes, absolutely. Yeah.

00:27:57,980 --> 00:28:01,960
Anything -- it is Python, so anything that you can import

00:28:01,960 --> 00:28:05,300
in Python you can import in xonsh directly and just start using it.

00:28:05,300 --> 00:28:07,280
(audience member) Perfect, thanks.

00:28:07,280 --> 00:28:09,440
(audience member) Hi, I was wondering if you have support

00:28:09,440 --> 00:28:13,580
for something similar to some of the IPython magic functions,

00:28:13,580 --> 00:28:16,700
where you can do, like, debugging and that kind of stuff.

00:28:17,140 --> 00:28:19,020
(Anthony Scopatz) So, we don't implement

00:28:19,020 --> 00:28:22,440
any particular debugger support, although that has been requested

00:28:22,440 --> 00:28:25,100
and hopefully someone will do that.

00:28:25,110 --> 00:28:28,290
The magic function stuff we don't have support for,

00:28:28,290 --> 00:28:30,470
but my question for the magic stuff is,

00:28:30,470 --> 00:28:33,810
what magics are people interested in, right?

00:28:34,720 --> 00:28:37,460
And then we can talk about how to implement those features specifically.

00:28:38,220 --> 00:28:40,200
(audience member) Do you feel that Python is the best

00:28:40,210 --> 00:28:42,180
language choice for this, or is it just the one

00:28:42,180 --> 00:28:44,400
that you happen to like the most of time?

00:28:44,400 --> 00:28:46,580
(Anthony Scopatz) I do feel that Python is the best language

00:28:46,580 --> 00:28:49,160
for this because it's a high-level dynamic language

00:28:49,160 --> 00:28:53,740
and you can do this syntax tree transformation stuff dynamically.

00:28:53,750 --> 00:28:57,400
You know, just the other dynamic languages out there, like,

00:28:57,400 --> 00:29:00,840
I don't think there's a good scope. So Ruby is an example.

00:29:00,840 --> 00:29:04,880
In Ruby, they don't have the same kind of scope and broad ecosystem.

00:29:04,880 --> 00:29:09,300
And languages like JavaScript, even if you're using node,

00:29:09,309 --> 00:29:12,850
they don't have the --

00:29:12,850 --> 00:29:16,610
they don't really have the OS-level things that you would need, right?

00:29:16,610 --> 00:29:18,620
You can't really manage signals very well.

00:29:18,620 --> 00:29:21,380
And Python has this beautiful -- maybe not beautiful

00:29:21,380 --> 00:29:24,919
but functional interface for handling signals.

00:29:24,919 --> 00:29:27,299
And so, you know, there is another project

00:29:27,299 --> 00:29:30,959
called ammonite out there that does something similar for scala,

00:29:30,960 --> 00:29:35,040
but I think we're doing a little better than them currently.

00:29:36,160 --> 00:29:37,960
(audience member) Seems like an awesome system.

00:29:37,960 --> 00:29:42,440
Are there reasons I should not switch to xonsh as the shell I always use?

00:29:42,440 --> 00:29:44,360
(Anthony Scopatz) I don't think so,

00:29:44,360 --> 00:29:47,580
but if you find them, please report them.

00:29:48,780 --> 00:29:51,260
(audience member) Wait, is there time for one more?

00:29:51,260 --> 00:29:53,740
(host) Last question, sure.

00:29:53,740 --> 00:29:55,760
(audience member) So how does the --

00:29:55,760 --> 00:29:57,820
do you have, like, multi-line line editing?

00:29:57,820 --> 00:29:59,240
(Anthony Scopatz) Uh-huh.

00:29:59,240 --> 00:30:02,540
(audience member) And is there, like, a VI mode, or not yet?

00:30:02,540 --> 00:30:04,300
(Anthony Scopatz) Yes, there is VI mode.

00:30:04,300 --> 00:30:07,260
So this is an important point. We have two back ends for line editing,

00:30:07,260 --> 00:30:11,620
so we use readline with all of its problems and glory.

00:30:11,620 --> 00:30:14,180
And then we also use prompt toolkit.

00:30:14,180 --> 00:30:17,240
And both of those have VI modes available.

00:30:17,240 --> 00:30:19,020
But the interface to that, we haven't --

00:30:19,020 --> 00:30:21,420
we don't have a unified interface for --

00:30:21,420 --> 00:30:25,700
in xonsh you can just set VI mode -- you know, $ VI mode = true,

00:30:25,700 --> 00:30:27,540
and then you get VI mode.

00:30:29,140 --> 00:30:31,120
(host) OK, let's thank Anthony again.

00:30:31,120 --> 00:30:34,760
[applause]

00:30:34,760 --> 00:30:37,360

YouTube URL: https://www.youtube.com/watch?v=uaje5I22kgE


