Title: Thomas Ballinger - Finding closure with closures - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Thomas Ballinger

What are closures all about anyway, and why is there a new keyword in Python
3?
We'll look at what a closure is, their history in the Python language, what
the Python 3 nonlocal keyword is about, and examine how closures are
idiomatically used (and avoided) in Python.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:29,120 --> 00:00:31,060
(moderator) So we'll get started.

00:00:31,060 --> 00:00:35,760
Our next talk is by Thomas Ballinger entitled,

00:00:35,760 --> 00:00:37,860
"Finding Closures with Closure."

00:00:37,870 --> 00:00:39,870
Please welcome him.

00:00:39,870 --> 00:00:41,810
[applause]

00:00:41,810 --> 00:00:43,810
(Thomas Ballinger) Thank you.

00:00:43,810 --> 00:00:46,260
[applause continues]

00:00:46,260 --> 00:00:49,840
(Thomas Ballinger) Hi, so a friend of mine was asked

00:00:49,850 --> 00:00:52,740
what closures were at a programming interview

00:00:52,740 --> 00:00:55,280
about 4, 4 or 5 years ago now.

00:00:55,280 --> 00:00:59,140
And this is a pretty competent kind of JavaScript and Python programmer

00:00:59,149 --> 00:01:01,140
who really froze up with this question.

00:01:01,140 --> 00:01:03,400
So can I ask, who would feel -- you know, if someone asked you

00:01:03,400 --> 00:01:06,440
in this programming interview a question that -- what are closure?

00:01:06,440 --> 00:01:08,480
What is a closure?

00:01:08,480 --> 00:01:11,080
Who would feel kind of comfortable saying some things for a bit, I guess?

00:01:11,090 --> 00:01:13,020
They could do -- okay so some.

00:01:13,020 --> 00:01:15,020
So I hope that today we come away, some of the closure we want

00:01:15,020 --> 00:01:17,240
is being able to say some things to that, whether you have

00:01:17,240 --> 00:01:19,740
a top of your head correct definition,

00:01:19,740 --> 00:01:22,800
at least you could -- you could respond a bit.

00:01:22,800 --> 00:01:25,290
And then another thing is I worked for several years

00:01:25,290 --> 00:01:29,329
at a kind of programming retreat where I would talk to a lot of people

00:01:29,329 --> 00:01:32,689
that were pretty experienced programmers,

00:01:32,689 --> 00:01:35,620
who were either coming to Python again

00:01:35,620 --> 00:01:37,680
after maybe 10 years being away from it,

00:01:37,690 --> 00:01:40,170
or coming into Python from maybe some more functional languages

00:01:40,170 --> 00:01:42,420
or maybe JavaScript, and they would ask me,

00:01:42,420 --> 00:01:44,520
"Does python even have closures? I'm kind of confused.

00:01:44,520 --> 00:01:46,720
"Do you have closures?

00:01:46,720 --> 00:01:48,760
"Like how do they use -- I tried to do this thing.

00:01:48,760 --> 00:01:50,760
"It didn't quite work like I thought it would."

00:01:50,820 --> 00:01:54,720
So that's something I'd like us to be able to kind of figure out as well.

00:01:54,730 --> 00:01:56,770
Spoiler alert --

00:01:56,770 --> 00:02:00,230
Okay one other question, spoiler is the other question I get --

00:02:00,230 --> 00:02:02,851
Does Python have closures? and we're going to come away with yes,

00:02:02,851 --> 00:02:05,590
yes it absolutely has closures, it totally has closures,

00:02:05,590 --> 00:02:07,870
but we'll discuss the variations of the answer.

00:02:07,880 --> 00:02:10,840
So to get there, we're going to talk about how free variables

00:02:10,840 --> 00:02:13,580
are resolved in Python, how Python determines variable scope,

00:02:13,580 --> 00:02:17,740
and then we're going to take this history through Python's journey with,

00:02:17,740 --> 00:02:21,200
or evolution with respect to scoping issues.

00:02:21,200 --> 00:02:24,420
And then finally we'll talk a bit more about how we use closures.

00:02:25,500 --> 00:02:28,180
So say I have two functions and they're both for formatting strings,

00:02:28,180 --> 00:02:31,240
but one of them is for HTML and the other one is for terminals.

00:02:31,240 --> 00:02:34,120
And terminals use ANSI escape sequences to make things red,

00:02:34,129 --> 00:02:36,420
like your tests are red. And you can make them bold too.

00:02:36,420 --> 00:02:39,820
And in HTML we put these little tags; you might have seen them before.

00:02:39,820 --> 00:02:42,260
I'm going to import these two functions. Let's do that.

00:02:42,260 --> 00:02:44,840
Let's bring up our Python interpreter and import these functions.

00:02:44,840 --> 00:02:49,880
I have to use this "from import as" syntax because they both have the same name.

00:02:49,880 --> 00:02:52,480
And then we're going to use this inspect module in the standard library

00:02:52,480 --> 00:02:55,400
for looking at the code of these functions, the source code.

00:02:55,400 --> 00:02:58,940
And this one is relatively simple; it's this one line,

00:02:58,950 --> 00:03:01,500
kind of, let's just slam these strings together.

00:03:01,500 --> 00:03:04,040
And then this other one looks remarkably similar, right?

00:03:04,040 --> 00:03:06,200
If we actually look at those together, they're the same,

00:03:06,210 --> 00:03:07,599
they look like the same function, right?

00:03:07,599 --> 00:03:09,880
That's the same text there, and yet I'd assert

00:03:09,880 --> 00:03:11,260
that when I use them, they're going to have

00:03:11,260 --> 00:03:14,700
this different behavior or these beautiful anti-escape sequences

00:03:14,700 --> 00:03:18,000
if you know terminal, exciting terminal stuff.

00:03:18,000 --> 00:03:20,380
And like how could that be? How is that possible that these

00:03:20,380 --> 00:03:22,360
really look the same but they have this different behavior?

00:03:22,360 --> 00:03:24,360
And instead of answering, we're going to talk about something else

00:03:24,360 --> 00:03:26,480
but we'll come right back to that.

00:03:27,340 --> 00:03:30,400
The way that's possible -- another question that we could ask,

00:03:30,410 --> 00:03:32,520
if we're looking at this:

00:03:32,520 --> 00:03:35,580
so this bold before here, I'm going to call it a free variable

00:03:35,580 --> 00:03:37,980
because it's not a local variable. It's not something

00:03:37,980 --> 00:03:39,900
that's a formal parameter.

00:03:39,900 --> 00:03:43,750
It's not text there, and there's not a local variable we assigned to in that function.

00:03:43,750 --> 00:03:49,110
So if we were to go back to -- if we look at this and we say,

00:03:49,110 --> 00:03:51,160
"What is this going to do?" Pop quiz:

00:03:51,160 --> 00:03:55,900
what's going to happen if I stick that function call, let's see, down here?

00:03:55,910 --> 00:03:58,560
This function call, I'm calling that function that uses that variable

00:03:58,560 --> 00:04:01,760
and before, I'm going to change what BEFOREBOLD is.

00:04:01,760 --> 00:04:04,060
I'm going to make this new local variable.

00:04:04,060 --> 00:04:06,940
And the question is: what is the behavior we'll get down here, right?

00:04:06,940 --> 00:04:10,400
Is that function that we saw before, is it going to use that new value,

00:04:10,400 --> 00:04:14,840
that in Sharpie, or is it going to use that original behavior?

00:04:14,840 --> 00:04:19,220
And this question is really about whether the Python language

00:04:19,229 --> 00:04:22,500
uses open free variables, where when you don't know the value

00:04:22,500 --> 00:04:25,140
because it's not a local variable, are you going to determine the value

00:04:25,140 --> 00:04:27,639
of that variable by looking up the call stack?

00:04:27,639 --> 00:04:29,659
Are you going to say, "Well, who called me? Did they have that variable?

00:04:29,660 --> 00:04:31,560
"Well, who called that?" And going up like that?

00:04:31,560 --> 00:04:34,639
Or are you going to say that we're going to use the value

00:04:34,639 --> 00:04:38,240
in the environment where I was defined?

00:04:38,240 --> 00:04:41,509
In this 1970 paper by Joel Moses, he points out --

00:04:41,509 --> 00:04:44,240
it's a paper about implementing both of these systems.

00:04:44,240 --> 00:04:47,720
If you look up the stack called dynamic scope or lexical scope,

00:04:47,720 --> 00:04:50,220
if you go back to the environment where it was.

00:04:50,220 --> 00:04:52,930
And he's discussing, he's saying, you know, implementation-wise,

00:04:52,930 --> 00:04:54,820
we'd really like to do the look up the stack.

00:04:54,820 --> 00:04:58,160
It's easier to write an interpreter or compiler that works like that.

00:04:58,160 --> 00:05:02,340
But the programmer probably wants to use the variables in the environment

00:05:02,350 --> 00:05:05,550
where they define the function, not the new variables

00:05:05,550 --> 00:05:08,680
that the user of the function that you've made.

00:05:08,680 --> 00:05:10,960
So with that in mind, with that the programmer

00:05:10,970 --> 00:05:15,050
would usually prefer that behavior of using the variables in the environment

00:05:15,050 --> 00:05:18,000
where the function was defined -- this is for everybody now --

00:05:18,010 --> 00:05:20,380
what do you think this is going to print?

00:05:20,380 --> 00:05:23,220
Is this going to be the old bold tags, the original behavior?

00:05:23,240 --> 00:05:26,060
Or is this going to print in Sharpie?

00:05:27,060 --> 00:05:29,220
Bold tags? Great some, a little bit of confidence there.

00:05:29,220 --> 00:05:34,820
Alright, yeah it's absolutely going to be the bold tags.

00:05:34,830 --> 00:05:37,380
Now what if we did something else? What if we change the global variable here?

00:05:37,380 --> 00:05:39,380
I'm going to import the function from another module

00:05:39,380 --> 00:05:40,900
and I'm going to change this global variable.

00:05:40,900 --> 00:05:42,900
I'm going to say BEFOREBOLD is now in Sharpie.

00:05:42,900 --> 00:05:44,920
Now what is this going to print?

00:05:44,920 --> 00:05:49,860
Is it going to be the original bold tags or is it going to say in Sharpie?

00:05:49,860 --> 00:05:52,260
It's going to be bold tags again because this -- yeah, sure,

00:05:52,260 --> 00:05:56,020
I changed that global variable here but that's a totally different global variable

00:05:56,030 --> 00:05:58,600
as the one that we used here.

00:05:58,600 --> 00:06:00,700
And let's finally look at the code for these functions.

00:06:00,710 --> 00:06:05,560
So indeed, they're similar, these modules, HTML format and terminal format.

00:06:05,560 --> 00:06:10,800
But we can see that they have these different global variable values.

00:06:10,800 --> 00:06:14,040
And the fact that I can say that, different global variables

00:06:14,040 --> 00:06:17,240
of the same name suggests that global is not a good name, right?

00:06:17,240 --> 00:06:19,680
So global variables in Python are not global at all.

00:06:19,680 --> 00:06:21,940
That's not a great name, but since we're kind of stuck,

00:06:21,940 --> 00:06:23,900
really they're module-level variables, right?

00:06:23,900 --> 00:06:26,720
Variables that kind of like static in C or something.

00:06:26,720 --> 00:06:29,960
They're shared while the function's in that module.

00:06:29,960 --> 00:06:33,550
But since we're stuck with this word global, maybe we should imagine them as existing

00:06:33,550 --> 00:06:35,490
on kind of separate planets, right?

00:06:35,490 --> 00:06:38,590
So global means within that globe, yeah, it's global, right?

00:06:38,590 --> 00:06:39,590
[laughter]

00:06:39,590 --> 00:06:42,570
There's only one on that planet there, but we're kind of stuck there.

00:06:42,570 --> 00:06:45,620
And now when we import a function from there, that function is

00:06:45,620 --> 00:06:50,419
like an emissary from that planet and it has a live a communication link, right?

00:06:50,419 --> 00:06:53,419
It talks to that planet and uses the environment there.

00:06:53,420 --> 00:06:57,060
So it talks to its home world and it has the constant link there.

00:06:57,060 --> 00:07:00,160
So if we're going to work that way, well, the way that it works

00:07:00,160 --> 00:07:04,060
is that Python functions have -- this is a function object here, bold.

00:07:04,060 --> 00:07:06,040
Not only does it have an attribute which is the string

00:07:06,040 --> 00:07:08,000
of the module it came from,

00:07:08,000 --> 00:07:12,140
but it actually has the actual name space of that module sitting there on it, right?

00:07:12,140 --> 00:07:15,980
So it has global stock keys, says, "Oh, here are the variables that I know about."

00:07:15,980 --> 00:07:19,940
And in fact that is object identity, the very same mapping as the one you get

00:07:19,949 --> 00:07:21,920
when you asked for the name space of that module

00:07:21,920 --> 00:07:24,520
That's what vars does, this built-in function.

00:07:24,520 --> 00:07:27,740
So this is the very same namespace.

00:07:27,740 --> 00:07:31,700
And Joel, our friend Joel, back in this paper,

00:07:31,700 --> 00:07:34,520
he talks about, "Alright, one way you could implement this behavior

00:07:34,530 --> 00:07:37,960
"that programmers would prefer, which is where functions look up

00:07:37,960 --> 00:07:41,139
"their free variables in the environment where they were defined, is you could have

00:07:41,139 --> 00:07:43,090
"the code, but you could also have some environment."

00:07:43,090 --> 00:07:46,419
And you want to stick those together, and the thing that we're going to call that

00:07:46,419 --> 00:07:48,419
when we stick them together is a closure.

00:07:48,420 --> 00:07:52,300
A closure is code plus environment kind of tied together.

00:07:52,300 --> 00:07:56,240
So, so far Python functions are looking an awful lot like closures, right?

00:07:56,240 --> 00:08:00,780
They have code and then there's an environment attached to it somehow.

00:08:00,789 --> 00:08:03,109
So because that's a live link to that module, alright,

00:08:03,109 --> 00:08:05,149
we can even change -- we can take this code,

00:08:05,149 --> 00:08:09,309
stick it at the bottom of that module, and, well, I'll ask you,

00:08:09,309 --> 00:08:12,160
if I run this here, this is now the new module code.

00:08:12,169 --> 00:08:14,240
I've changed those global variables at the bottom,

00:08:14,240 --> 00:08:18,640
and now I'm going to call, I could import that function, call bold on it.

00:08:18,640 --> 00:08:21,480
Are we going to see the bold tags or the new classier,

00:08:21,480 --> 00:08:24,760
like our CSS is happier, span tags there?

00:08:24,760 --> 00:08:26,540
(audience member) Span

00:08:26,540 --> 00:08:28,400
Span, yeah, because we've changed that global variable.

00:08:28,410 --> 00:08:30,479
It's not about the value when it was defined.

00:08:30,479 --> 00:08:32,219
It's about the value when we call it.

00:08:32,219 --> 00:08:34,279
So let's walk through that code. We go in there,

00:08:34,280 --> 00:08:36,660
we import that module, we define the global variables,

00:08:36,660 --> 00:08:39,719
we define the function, change the global variables.

00:08:39,719 --> 00:08:41,740
Now it's going to be right, that new value.

00:08:41,740 --> 00:08:45,830
How about if we modify those variables outside of the environment?

00:08:45,830 --> 00:08:49,680
We can take that module object and actually access it directly.

00:08:49,680 --> 00:08:52,639
Python lets us do that, and we can just change this.

00:08:52,639 --> 00:08:56,279
So now, I guess, before, I suppose it was for someone writing kind of

00:08:56,279 --> 00:08:58,500
a sign at PyCon that you see.

00:08:58,500 --> 00:09:01,600
And now I guess this new bold function is going to be for an airplane.

00:09:01,600 --> 00:09:03,850
So if an airplane's flying, you can't really bold the letters

00:09:03,850 --> 00:09:05,830
because it seems like they always have one font.

00:09:05,830 --> 00:09:08,830
But now it's going to say READ THIS, and I'm asking: is this now going to say

00:09:08,830 --> 00:09:11,510
READ THIS or is it going to be those old span tags?

00:09:11,510 --> 00:09:13,480
READ THIS, right, because we're changing it.

00:09:13,480 --> 00:09:17,819
So one more time it's about the value at the time that the function is called, right?

00:09:17,819 --> 00:09:20,220
So this distinction between function definition time

00:09:20,220 --> 00:09:23,119
and function execution time is really important

00:09:23,119 --> 00:09:25,309
because of that live link behavior.

00:09:25,309 --> 00:09:27,660
And some things happen at function definition time.

00:09:27,660 --> 00:09:30,089
Some happen at function execution time.

00:09:30,089 --> 00:09:32,999
One of the things that happens at function definition time

00:09:32,999 --> 00:09:37,719
is that Python analyzes our code and determines the scope of each variable.

00:09:37,720 --> 00:09:40,440
So when we're identifying the scope of a variable,

00:09:40,440 --> 00:09:43,679
this is something we're probably reasonably -- we might already have

00:09:43,679 --> 00:09:45,720
good programmer intuition for.

00:09:45,720 --> 00:09:48,739
So let's try this ourselves a bit.

00:09:48,739 --> 00:09:51,599
The process is that Python, you might say, compiles,

00:09:51,600 --> 00:09:55,180
but we'll just say defines here. We make this function object somehow,

00:09:55,180 --> 00:09:57,720
and all these attributes on it have the different information

00:09:57,720 --> 00:10:00,220
about the function. So some of the best information

00:10:00,220 --> 00:10:03,140
is on this Dunder code object. So we're going to look at some

00:10:03,140 --> 00:10:05,400
of the attributes on here because that's where Python

00:10:05,400 --> 00:10:08,300
puts information about how it processed the function,

00:10:08,300 --> 00:10:12,160
how it defined the function, how it compiled the function.

00:10:12,160 --> 00:10:14,450
So for as long as Python has been on the internet,

00:10:14,450 --> 00:10:19,580
which is 25 years at least I think, there've been at least two kinds of variables.

00:10:19,580 --> 00:10:22,700
There have been local variables and these phone home global variables

00:10:22,709 --> 00:10:27,600
that mean go get the value when we call the function.

00:10:27,600 --> 00:10:29,920
I mentioned you already have this intuition, so let's be

00:10:29,920 --> 00:10:31,700
the interpreter for a moment.

00:10:31,700 --> 00:10:33,799
Let's try to figure out, of the variables in here --

00:10:33,799 --> 00:10:36,999
this is this great function for blockbuster movie titles

00:10:36,999 --> 00:10:39,459
if that's a problem you face.

00:10:39,460 --> 00:10:43,820
Let's try to figure out whether the variables in here are local or global variables.

00:10:43,829 --> 00:10:48,520
So first up is phrase; is phrase in here a local or global variable?

00:10:48,520 --> 00:10:51,380
Local, yeah. Is capitalized,

00:10:51,380 --> 00:10:53,779
is that a local or a global variable?

00:10:53,779 --> 00:10:58,139
Local, so this function has only local variables in it.

00:10:58,140 --> 00:11:00,100
It's interesting because that kind of means --

00:11:00,100 --> 00:11:02,740
so one's a parameter to the function, right, one is a sign to in the function.

00:11:02,740 --> 00:11:05,260
Both of those things make them local variables.

00:11:05,260 --> 00:11:07,720
This is the kind of function that we might call a pure function.

00:11:07,720 --> 00:11:09,769
It doesn't really need that attached environment.

00:11:09,769 --> 00:11:11,850
We never go look things up there.

00:11:11,850 --> 00:11:15,309
And this brings us to one of our first forks in this definition of closure.

00:11:15,309 --> 00:11:18,029
Is it still a closure if it has attached environment

00:11:18,029 --> 00:11:20,580
but Python never looks at it because it doesn't need to?

00:11:20,580 --> 00:11:23,240
Python doesn't compile -- at least CPython doesn't compile that link

00:11:23,249 --> 00:11:25,959
to the module away, so it's still code and environment,

00:11:25,959 --> 00:11:27,919
but it never needs to use it.

00:11:27,920 --> 00:11:29,980
So this is the first of many times that we have to figure out

00:11:29,989 --> 00:11:31,999
which one is a closure and which isn't.

00:11:31,999 --> 00:11:36,100
And, besides that, in a little bit, stay tuned, we're going to find out

00:11:36,100 --> 00:11:38,790
that most people would not call either of these functions closures.

00:11:38,790 --> 00:11:42,070
And we'll get there, so stay tuned for that.

00:11:43,280 --> 00:11:47,340
Alright, next up -- okay,

00:11:47,350 --> 00:11:49,060
next up let's try the interpreter for this one.

00:11:49,060 --> 00:11:51,040
Did I just give the answers?

00:11:51,040 --> 00:11:53,959
No, these are the answers; this is where you can find the answers

00:11:53,959 --> 00:11:55,470
on that function object.

00:11:55,470 --> 00:11:57,019
Let's try another function.

00:11:57,019 --> 00:12:00,329
This is coming up with catchy phrases, I guess, it's -- or maybe,

00:12:00,329 --> 00:12:02,160
if your phrase is catchy enough.

00:12:02,160 --> 00:12:04,160
Is phrase local or global?

00:12:04,160 --> 00:12:05,140
(audience member) Global.

00:12:05,140 --> 00:12:07,320
Okay, is options local or global?

00:12:07,320 --> 00:12:08,280
(audience member) Global.

00:12:08,280 --> 00:12:10,880
Yeah, is default title local or global?

00:12:10,880 --> 00:12:11,860
(audience member) Global.

00:12:11,860 --> 00:12:13,740
And it helps because it's all caps.

00:12:13,749 --> 00:12:14,889
It's a convention in Python.

00:12:14,889 --> 00:12:16,929
Doesn't really matter, but how about catchiness?

00:12:16,929 --> 00:12:20,100
Is that a local or global variable?

00:12:20,100 --> 00:12:23,060
Yeah, it's local because -- well no not local at all.

00:12:23,060 --> 00:12:26,280
That's global; nowhere in there do we assign to it, right?

00:12:26,280 --> 00:12:28,380
It's lower case but that's not the important part.

00:12:28,380 --> 00:12:30,880
It's that we never assigned to it in that function.

00:12:30,880 --> 00:12:34,140
So let's check our answers, indeed.

00:12:34,149 --> 00:12:37,369
we're going to find the local variables in that co var names, and then co names

00:12:37,369 --> 00:12:41,580
is a bunch of stuff, but one of the things in there are the global variables.

00:12:41,580 --> 00:12:45,380
Alright so, so far our programmer intuition has kind of agreed.

00:12:45,380 --> 00:12:49,120
But we're going to see a function now where your intuition

00:12:49,120 --> 00:12:51,400
about what the author meant might not agree.

00:12:51,400 --> 00:12:54,360
We have a global variable called high score and looks like this function

00:12:54,370 --> 00:12:56,820
is supposed to change that high score somehow.

00:12:56,820 --> 00:13:01,920
But if we go through what -- is high score a local or global variable here?

00:13:03,040 --> 00:13:04,920
Yeah, it's local. It's kind of unfortunate.

00:13:04,920 --> 00:13:07,960
Because it's called new high score. It's maybe supposed to switch that.

00:13:07,960 --> 00:13:11,940
So what error, anybody know, will we get when we run this function?

00:13:11,940 --> 00:13:16,100
Unbound local, yeah, yeah great error, excellent error.

00:13:16,100 --> 00:13:20,280
So that's because the classification of high score didn't go as we had hoped.

00:13:20,280 --> 00:13:23,340
Yep, it's local, alright, because it's up there.

00:13:23,340 --> 00:13:26,060
So we need to tell Python to skip that heuristic.

00:13:26,060 --> 00:13:29,220
Don't use that heuristic of was it assigned in this function?

00:13:29,220 --> 00:13:31,680
Just make it a global variable anyway. So we have this global keyword

00:13:31,680 --> 00:13:33,700
for explicitly saying that.

00:13:33,700 --> 00:13:38,520
And now this code works as expected; we can assign backup to that scope.

00:13:38,520 --> 00:13:44,260
Alright, so so far we've gone through two big, kind of, fundamental things,

00:13:44,260 --> 00:13:48,040
one of which is that in review -- so the scope of a variable

00:13:48,040 --> 00:13:52,189
is determined at definition time, and the other one is that the value

00:13:52,189 --> 00:13:55,300
of a variable is determined at execution time.

00:13:55,300 --> 00:13:58,160
If we're feeling okay with that, then congratulations,

00:13:58,160 --> 00:14:00,760
you're now a Python 2.0 Scope Expert.

00:14:00,760 --> 00:14:02,720
That's all there is. This is cutting-edge technology

00:14:02,720 --> 00:14:05,200
in the year 2000, right. This is --

00:14:05,200 --> 00:14:08,560
we've kind of looked at everything there is.

00:14:08,560 --> 00:14:11,940
But in Python 2.0, there's an important method of closing

00:14:11,949 --> 00:14:14,460
over free variables that wasn't available to us.

00:14:14,460 --> 00:14:18,760
One that required -- one that's required by most people to call something a closure.

00:14:18,760 --> 00:14:20,819
So, many people would say, "None of these are closures yet.

00:14:20,819 --> 00:14:22,879
"Yeah, sure, you were accessing that global environment

00:14:22,880 --> 00:14:25,560
"but that doesn't count," for reasons unclear,

00:14:25,560 --> 00:14:28,540
probably that original Joel Moses paper, but in the intervening years

00:14:28,549 --> 00:14:31,960
we've made changes to the definition of closure.

00:14:31,960 --> 00:14:33,780
So let's take a look at this function. It might be --

00:14:33,780 --> 00:14:36,780
you might recognize it if you know an excellent talk

00:14:36,790 --> 00:14:39,040
by Ned Batchelder about looping.

00:14:39,040 --> 00:14:41,020
But here we're going to use it as an example

00:14:41,020 --> 00:14:43,239
of why that wasn't quite enough scopes.

00:14:43,239 --> 00:14:45,239
We've got these buildings,

00:14:45,240 --> 00:14:47,900
and then we're going to try to find the tallest building here.

00:14:47,900 --> 00:14:50,020
We're going to find the max of the buildings.

00:14:50,029 --> 00:14:52,249
The way we determine max, not alphabetically or something,

00:14:52,249 --> 00:14:54,640
it's going to be this local function height.

00:14:54,640 --> 00:14:57,240
And this just looks in that dictionary to grab it.

00:14:57,240 --> 00:15:00,500
Now if we're being the interpreter in this local function here,

00:15:00,500 --> 00:15:04,340
is name a local variable or a global variable?

00:15:04,340 --> 00:15:08,560
Great, is buildings a local variable or a global variable?

00:15:08,560 --> 00:15:09,980
[audience laughter]

00:15:09,980 --> 00:15:11,919
This is a trick question, right?

00:15:11,919 --> 00:15:15,569
Because we, yeah -- it turns out, it so happens that Python 2.0,

00:15:15,569 --> 00:15:18,200
it's like, well, I don't see it local, I guess it's global.

00:15:18,200 --> 00:15:21,680
But we really would like it to be that outer scope, right?

00:15:21,680 --> 00:15:25,480
So at this point, we need some kind of other scope.

00:15:25,480 --> 00:15:27,420
How about what error? Well, I just told you.

00:15:27,420 --> 00:15:31,360
It's going to be this global one, right? Global name, buildings is not defined.

00:15:31,370 --> 00:15:34,440
We need a new scope, and we can find evidence for it in here.

00:15:34,440 --> 00:15:37,980
It's going to be called co_freevars or where we'll find it on the function object.

00:15:37,980 --> 00:15:42,879
And this is when we want to bind to an outer scope that's not the global scope.

00:15:42,879 --> 00:15:45,139
And not the local scope, not the global scope,

00:15:45,140 --> 00:15:47,740
somewhere in between.

00:15:47,749 --> 00:15:51,959
So this was optional and Python 2.1, and then in Python 2.2

00:15:51,959 --> 00:15:55,859
it was just required, and variables from outer non-global scopes

00:15:55,860 --> 00:15:57,980
are always found in that freevars spot.

00:15:57,980 --> 00:16:01,259
This is what our function looks like, that height function,

00:16:01,259 --> 00:16:03,399
once it starts working. Once we've moved to 2.2

00:16:03,400 --> 00:16:06,960
or we import -- do the future import in 2.1.

00:16:08,920 --> 00:16:11,740
And now that we're talking about -- we've covered all the scopes, we're set.

00:16:11,740 --> 00:16:14,379
This has got to be -- these are definitely closures now because we're binding over

00:16:14,379 --> 00:16:17,459
any one of those outer scopes.

00:16:17,460 --> 00:16:19,580
But the implementation does get a little funky here, right?

00:16:19,580 --> 00:16:21,379
With modules we just had that namespace.

00:16:21,379 --> 00:16:25,159
It's even a thing we can reach out and touch and modify.

00:16:25,160 --> 00:16:27,660
But usually when people talk about closures, they're not thinking

00:16:27,660 --> 00:16:29,520
about the module level scope. I think this is --

00:16:29,520 --> 00:16:31,559
a lot of this is because the module level scope

00:16:31,559 --> 00:16:35,449
is kind of easy; Python modules are sort of singletons, right?

00:16:35,449 --> 00:16:39,400
You import it, you've just got that one, there's only that one scope.

00:16:39,400 --> 00:16:42,660
But once we start trying to save all those other scopes --

00:16:42,669 --> 00:16:44,729
like a function can be run many times, right?

00:16:44,729 --> 00:16:47,209
And each time it could produce a different set of those mappings.

00:16:47,209 --> 00:16:50,129
And each of the functions that has reference to that will need to --

00:16:50,129 --> 00:16:52,759
every time we produce a function that has reference to that scope

00:16:52,759 --> 00:16:56,499
created by the function running, we need to save it again.

00:16:56,500 --> 00:16:59,079
So let's look at a tricky example that has trouble --

00:16:59,079 --> 00:17:02,039
people have trouble with scopes with this in general.

00:17:02,040 --> 00:17:06,380
Let's make a bunch of format functions for each of the colors:

00:17:06,390 --> 00:17:09,680
red, green, and blue; let's define a function that colors text that color.

00:17:09,680 --> 00:17:11,640
Great, we're going to stick them in that dictionary.

00:17:11,640 --> 00:17:15,660
Now we pull out the green one; what color is hello going to be?

00:17:17,420 --> 00:17:20,400
We're not -- yeah, green's a good guess.

00:17:20,400 --> 00:17:23,520
Blue is a better guess. Maybe it's easier when we say

00:17:23,520 --> 00:17:27,460
print color here. What's the value of color after the four loop?

00:17:27,460 --> 00:17:30,500
Blue, right, the first time it was green, red then green then blue.

00:17:30,500 --> 00:17:33,140
By this point it's blue. All three of those functions --

00:17:33,140 --> 00:17:35,740
it's not a local variable, so it's a global variable out there --

00:17:35,740 --> 00:17:38,080
they're are all using the same global variable.

00:17:38,080 --> 00:17:41,840
So we're going to end up with three functions that all output in blue.

00:17:41,840 --> 00:17:46,520
And so, the solution to this is to build a new scope, right?

00:17:46,520 --> 00:17:50,380
We need -- we wish that we could have each of those functions have their own mapping,

00:17:50,380 --> 00:17:54,960
their own -- if each one had its own mapping, we could set each mapping appropriately.

00:17:54,970 --> 00:17:58,060
And so that's our goal here.

00:17:58,060 --> 00:18:01,160
Each time, make_color_function is called,

00:18:01,169 --> 00:18:05,460
we get a new local mapping, so that each color will be different.

00:18:05,460 --> 00:18:08,720
And a function called in_color is defined which references the color variable

00:18:08,720 --> 00:18:11,470
from that outer scope that was a local variable there.

00:18:11,470 --> 00:18:14,650
And we stick it in the dictionary, and now we have to think of it as--

00:18:14,650 --> 00:18:16,529
we've still got our global scope planet

00:18:16,529 --> 00:18:20,160
but these were maybe three little moon scopes here.

00:18:20,160 --> 00:18:22,600
Because with each of those functions, yeah, they had the global scope,

00:18:22,600 --> 00:18:24,889
but they also had their own little scopes.

00:18:24,889 --> 00:18:27,240
But those scopes aren't things like the global module,

00:18:27,240 --> 00:18:29,160
like a module that we can reach out and touch.

00:18:29,160 --> 00:18:31,559
Those are kind of hidden from us.

00:18:31,559 --> 00:18:33,440
We're not going to talk much about the implementation of this,

00:18:33,440 --> 00:18:36,360
except that I've pointed out it might be a little interesting.

00:18:36,360 --> 00:18:41,540
Our hint about it is that there's a dunder closure attribute on functions.

00:18:41,540 --> 00:18:43,260
If you look at that and then some other things,

00:18:43,260 --> 00:18:45,149
you can kind of learn about how this is implemented.

00:18:45,149 --> 00:18:46,830
If you read the pep where they implemented this,

00:18:46,830 --> 00:18:48,010
there's some interesting things,

00:18:48,010 --> 00:18:50,700
different ways that they could have implemented it.

00:18:50,700 --> 00:18:53,360
But now we've reached the most common definition of a closure, which is

00:18:53,370 --> 00:18:57,340
a function with free variables that closed -- that are closed --

00:18:57,340 --> 00:18:59,460
the function, the free variables of the function

00:18:59,460 --> 00:19:03,380
are closed by outer non-global scopes.

00:19:03,380 --> 00:19:05,920
It doesn't count if they're global because that was too easy.

00:19:07,960 --> 00:19:10,500
However another fork in definitions occurs here.

00:19:10,500 --> 00:19:14,760
So we had these three color functions, and before that, I forget already,

00:19:14,760 --> 00:19:17,549
but we had this other, this tallest building one.

00:19:17,549 --> 00:19:19,520
And some people would say, "This is not a closure

00:19:19,520 --> 00:19:21,580
"and these are."

00:19:21,580 --> 00:19:25,820
And that's because in here we --

00:19:25,820 --> 00:19:29,220
you could tell, like, the "make_color_func" was done running

00:19:29,230 --> 00:19:33,289
by the time we called that function, so it was clear that somebody somehow

00:19:33,289 --> 00:19:35,400
was preserving those mappings.

00:19:35,400 --> 00:19:38,780
But back here we called this height function

00:19:38,789 --> 00:19:41,009
inside the scope of tallest building.

00:19:41,009 --> 00:19:43,230
So you could use a kind of more dumb implementation

00:19:43,230 --> 00:19:47,120
that just looked up the stack or that somehow used the previous findings.

00:19:47,120 --> 00:19:49,440
I'd like to call both of these closures, because they're both implemented

00:19:49,440 --> 00:19:51,540
the same way. One gives us more evidence

00:19:51,540 --> 00:19:53,700
that it's a closure, but you can also read the Python source

00:19:53,700 --> 00:19:55,960
or look at these objects and find out that,

00:19:55,960 --> 00:19:59,000
yeah, they all have that link, that closure attribute.

00:20:00,060 --> 00:20:04,899
But we'll encounter more of those forks, what it quite means.

00:20:08,140 --> 00:20:10,940
That's the distinction, right, looking at the stack.

00:20:12,020 --> 00:20:15,300
So now we're Python 2.2, right?

00:20:15,300 --> 00:20:17,820
Definitely closures now; we absolutely have closures.

00:20:17,830 --> 00:20:19,620
If anyone's asking, "Oh, does Python have closures?"

00:20:19,620 --> 00:20:21,460
Yeah, yeah, we totally do, right?

00:20:21,460 --> 00:20:23,420
There's no if, ands, or buts about this.

00:20:23,420 --> 00:20:25,360
Maybe there are a little bit and we'll have to get to those,

00:20:25,360 --> 00:20:28,380
but congratulations, nothing important happens

00:20:28,390 --> 00:20:32,630
in Python scope till 2.7. So you're all now Python 2.7 scope experts.

00:20:32,630 --> 00:20:36,780
Again, cutting-edge technology in the year 2008.

00:20:36,780 --> 00:20:42,220
But if rumblings of the inefficiencies of Python 2's closures

00:20:42,220 --> 00:20:45,559
have ever reached your ears, you may not have closure yet.

00:20:45,559 --> 00:20:48,110
You may be thinking, like, wait but I tried to write this code

00:20:48,110 --> 00:20:50,159
from JavaScript and it didn't quite work.

00:20:50,159 --> 00:20:54,100
Or I heard someone say that Python has weak support for closures

00:20:54,100 --> 00:20:58,279
or read-only closures, but they're not full closures.

00:20:58,279 --> 00:21:02,490
And this comes from this asymmetry between the global variables before

00:21:02,490 --> 00:21:05,250
and these non-global outer scope variables

00:21:05,250 --> 00:21:09,370
that we have now, in that we can't specify

00:21:09,370 --> 00:21:11,410
a variable that we won't assign to

00:21:11,410 --> 00:21:14,580
in that outer scope as belonging to that outer scope.

00:21:14,580 --> 00:21:17,679
And when we make a variable in this inner scope,

00:21:17,679 --> 00:21:19,440
it's going to look like a local variable, right?

00:21:19,440 --> 00:21:21,340
We'll look at an example here.

00:21:21,340 --> 00:21:23,649
Here's an example of where you might want this.

00:21:23,649 --> 00:21:25,580
Let's walk through this again. We're going to be the compiler

00:21:25,580 --> 00:21:27,960
in this inner guess function.

00:21:27,960 --> 00:21:31,480
Is n a local variable or a global variable?

00:21:31,480 --> 00:21:35,760
Or a new option now. Is it an outer scope variable?

00:21:35,760 --> 00:21:38,220
I'll just call that outer. But n, local variable?

00:21:38,220 --> 00:21:40,360
Global variable? Outer scope variable?

00:21:40,370 --> 00:21:42,400
Local, yeah, great.

00:21:42,400 --> 00:21:47,440
Answer, is that a local variable, a global variable, or some outer scope variable?

00:21:47,440 --> 00:21:49,360
Outer scope, okay, yeah because it's a local variable up there

00:21:49,360 --> 00:21:51,260
and down here we never assigned to it. Cool.

00:21:51,260 --> 00:21:55,880
last_guess, what is that? Local, global, or outer scope?

00:21:56,780 --> 00:21:59,680
We'd love it to be an outer scope but it's not, unfortunately, right?

00:21:59,690 --> 00:22:02,860
This is the error we're going to get if we try to treat it like an outer scope.

00:22:02,860 --> 00:22:05,260
I should have asked you what error is that going to be

00:22:05,269 --> 00:22:07,649
because it's this great unbound local error again.

00:22:07,649 --> 00:22:12,520
The problem here is that we used assignment on it right down here on last guess.

00:22:12,529 --> 00:22:15,370
We said it equals something, and that makes it a local variable.

00:22:15,370 --> 00:22:19,090
And we wish we could fix that, we wish that we could specify it.

00:22:19,090 --> 00:22:23,960
So we need the analog to that global keyword.

00:22:23,960 --> 00:22:25,920
So we get that; it's non-local.

00:22:25,920 --> 00:22:28,600
We fix this, we put non-local there, it works like we expect.

00:22:28,600 --> 00:22:31,740
This is Python 3 now.

00:22:31,740 --> 00:22:34,260
So if we're in Python 3, we can do this.

00:22:34,260 --> 00:22:36,620
And we call these rebinding closures, right?

00:22:36,629 --> 00:22:40,860
We can actually change what that outer scope variable is.

00:22:40,860 --> 00:22:43,620
Now before, we could still send messages to that thing

00:22:43,620 --> 00:22:46,740
if that thing were a mutable object or a class or some -- or an object

00:22:46,740 --> 00:22:50,259
we could call methods on it. We could mutate it, but we couldn't rebind it.

00:22:50,259 --> 00:22:52,750
So if you're going to have last guess equals none,

00:22:52,750 --> 00:22:55,169
we were never going to be able to make it not none, and now we can.

00:22:55,169 --> 00:22:57,500
We can say last guess in that guess function,

00:22:57,500 --> 00:22:59,179
I'm talking about that outer one.

00:22:59,179 --> 00:23:02,499
You can kind of see what guess does here. I think that's less important.

00:23:02,500 --> 00:23:06,680
It's definitely a closure because it's binding over that outer variable.

00:23:06,690 --> 00:23:09,270
Okay, definitely closures now, right?

00:23:09,270 --> 00:23:11,000
We're absolutely -- these are definitely closures.

00:23:11,000 --> 00:23:14,180
Also,by the way you are now a Python 3.6 scope expert,

00:23:14,180 --> 00:23:18,040
or 3 point whatever because, that I know of, no big changes

00:23:18,040 --> 00:23:20,340
have happened to scopes.

00:23:20,340 --> 00:23:23,820
So what's left is how closures get used in Python.

00:23:24,780 --> 00:23:27,220
They're used all over the place. Any time you're wondering

00:23:27,220 --> 00:23:29,840
if something's a closure by that outer scopes definition,

00:23:29,840 --> 00:23:35,139
you can look for the closure attribute on it, that dunder closure thing,

00:23:35,139 --> 00:23:38,319
if it is closing over those outer non-local scopes.

00:23:38,320 --> 00:23:42,899
Here, the sum of the places they come up, so inner functions are often using variables

00:23:42,899 --> 00:23:45,999
from outside that inner scope.

00:23:46,000 --> 00:23:48,399
Lambdas usually are --

00:23:48,399 --> 00:23:50,539
all these places in the standard library where you need a callback,

00:23:50,539 --> 00:23:53,029
where you need a function, if that function is going to do

00:23:53,029 --> 00:23:57,800
anything interesting, then it's probably changing some state somewhere.

00:23:57,800 --> 00:24:00,020
And a common way to do that is with a closure.

00:24:00,020 --> 00:24:02,700
Decorators deserve their own slide because that is so common, right?

00:24:02,700 --> 00:24:05,760
A decorator's always something that takes a function

00:24:05,769 --> 00:24:08,280
and then usually returns a new function.

00:24:08,280 --> 00:24:11,480
And that new function usually has a reference to the old function

00:24:11,480 --> 00:24:14,049
so that it can be generic somehow.

00:24:14,049 --> 00:24:18,480
In this case this terrible retry decorator just tries to do something

00:24:18,480 --> 00:24:21,639
and then catches the exception and -- but you can see func, right,

00:24:21,639 --> 00:24:25,490
is a local variable in the retry scope and then --

00:24:25,490 --> 00:24:29,380
so this is definitely a closure because it's referencing that outer scope.

00:24:29,380 --> 00:24:34,340
And by even the stricter definition of: oh and the retry has to be done running, right?

00:24:34,340 --> 00:24:37,460
Decorators run at compile time, or at function definition time

00:24:37,470 --> 00:24:39,420
and then they're done, so those scopes are gone.

00:24:39,420 --> 00:24:41,900
It has to be preserved somehow, certainly in closure.

00:24:43,220 --> 00:24:47,640
One more aspect that I kind of want to find closure on

00:24:47,649 --> 00:24:52,340
is how did we get along without non-local for so long, right?

00:24:52,340 --> 00:24:55,259
Many people still use Python 2 code; how do they survive

00:24:55,259 --> 00:24:57,919
without this non local keyword?

00:24:57,920 --> 00:25:01,080
It took us nine years between Python 2.2

00:25:01,080 --> 00:25:04,020
and Python 3 to finally get

00:25:04,029 --> 00:25:07,110
this non local keyword, and if it's such an important change,

00:25:07,110 --> 00:25:10,230
why don't we see a ton of Python 3 code using it now?

00:25:10,230 --> 00:25:12,649
So now what follows are kind of some thoughts on maybe

00:25:12,649 --> 00:25:16,509
why this isn't as important in Python.

00:25:17,580 --> 00:25:20,720
A lot of real world examples do use the pattern of non-local.

00:25:20,730 --> 00:25:23,120
They're just trying to maintain Python 2, Python 3 compatibilities

00:25:23,120 --> 00:25:25,760
so they can't use it. So this is a real example,

00:25:25,760 --> 00:25:29,019
quite abbreviated from the Django code.

00:25:29,019 --> 00:25:31,919
Here we've got this variable root in that outer scope

00:25:31,919 --> 00:25:34,179
and we'd really like to change it, but you can't change variables

00:25:34,180 --> 00:25:36,140
like that in Python 2. So what we do is

00:25:36,140 --> 00:25:39,200
we wrap it in the simplest mutable object we can think of

00:25:39,200 --> 00:25:44,210
and then down here we, you know, assign this little bit more cumbersome syntax

00:25:44,210 --> 00:25:46,420
of saying non-local root, the thing in there,

00:25:46,420 --> 00:25:48,300
I want you to change that.

00:25:48,300 --> 00:25:53,020
And this is a, it's not elegant but it's not so bad.

00:25:53,020 --> 00:25:57,700
And I think many times when we could use a closure that can rebind that outer scope,

00:25:57,700 --> 00:25:59,230
something like this works.

00:25:59,230 --> 00:26:02,720
And this is kind of the most ridiculous case where you can --

00:26:02,720 --> 00:26:05,309
they're calling it non-local, right, they're just waiting for that refactor

00:26:05,309 --> 00:26:07,100
when we go in and change it.

00:26:07,100 --> 00:26:09,730
But sometimes there's other ways to express this, and you can always

00:26:09,730 --> 00:26:12,429
come up with something similar by sending that message

00:26:12,429 --> 00:26:15,929
to that mutable object that it should change.

00:26:17,680 --> 00:26:20,059
So another reason is we already have modules.

00:26:20,059 --> 00:26:24,619
We already have a global keyword which lets us change those module singletons.

00:26:24,620 --> 00:26:26,880
But I think a bigger reason, we don't see it a lot,

00:26:26,880 --> 00:26:29,160
is that we have a great object system in Python.

00:26:29,160 --> 00:26:32,320
And if we have something like this, this is an earlier example,

00:26:32,320 --> 00:26:35,399
instead of having to write that local function,

00:26:35,399 --> 00:26:39,499
we can instead say, "Oh the key is buildings.get," and what that means

00:26:39,499 --> 00:26:41,679
is that you're going to take that get function,

00:26:41,680 --> 00:26:45,560
build a method out of it that refers to the building's thing,

00:26:45,560 --> 00:26:48,580
and in this case buildings is this built in Python dictionary

00:26:48,580 --> 00:26:50,730
and get is the method that will get the data out of there.

00:26:50,730 --> 00:26:53,590
So this works kind of well for our previous example.

00:26:53,590 --> 00:26:56,190
That wasn't mutating anything, but buildings.get could be

00:26:56,190 --> 00:26:57,539
a method of any kind.

00:26:57,539 --> 00:26:59,780
And when things are methods, that kind of telegraphs to you

00:26:59,780 --> 00:27:02,169
that, like, hey I might modify that statement.

00:27:02,169 --> 00:27:05,549
So you end up with something, maybe, someone might argue, more readable

00:27:05,549 --> 00:27:08,190
because you have the object and a method on that.

00:27:08,190 --> 00:27:11,529
When you pass it in, the cool part in Python is it remembers

00:27:11,529 --> 00:27:13,850
which object it's attached to.

00:27:13,850 --> 00:27:17,200
So maybe a reason we don't use non-local there.

00:27:17,200 --> 00:27:19,380
And then I want to posit a cultural reason,

00:27:19,380 --> 00:27:23,320
which is that Python programmers are, oh, we tend to be comfortable

00:27:23,330 --> 00:27:26,460
with private data being externally accessible.

00:27:26,460 --> 00:27:29,560
I think Python and JavaScript are two relatively similar,

00:27:29,570 --> 00:27:33,990
in many ways, languages which both lack or at least at some point have lacked

00:27:33,990 --> 00:27:36,799
an ability to have private data in their objects.

00:27:36,799 --> 00:27:39,279
They both have these kind of full rebinding closures

00:27:39,280 --> 00:27:41,860
that you can use to hide data.

00:27:41,860 --> 00:27:43,799
And there's this pattern we're about to look at

00:27:43,799 --> 00:27:46,649
that is totally possible in both of these languages

00:27:46,649 --> 00:27:50,159
and it's really commonplace in JavaScript and isn't in Python.

00:27:50,159 --> 00:27:53,179
So let's look at that. It's going to be a bit of code.

00:27:53,180 --> 00:27:57,160
But if you have, say -- say that you want a person

00:27:57,169 --> 00:27:59,350
to have some methods and some hidden data.

00:27:59,350 --> 00:28:03,130
We could in Python make a person class that's really simple, and then I have

00:28:03,130 --> 00:28:06,289
this alternate constructor that takes some private --

00:28:06,289 --> 00:28:09,460
local data here: name and age, these local variables.

00:28:09,460 --> 00:28:11,800
We're going to make a person and then we're going to write some functions,

00:28:11,809 --> 00:28:14,220
ones with the lambda syntax, one with a def

00:28:14,220 --> 00:28:16,570
because it doesn't really matter which in Python, right?

00:28:16,570 --> 00:28:18,730
They're just sugar for each other.

00:28:18,730 --> 00:28:20,920
But all these access these local variables.

00:28:20,920 --> 00:28:24,840
And then we just slap those as attributes on to that object.

00:28:24,840 --> 00:28:27,880
And we turn the object so now we have this me person object.

00:28:27,889 --> 00:28:31,009
Apologies for using me as "person." It's a terrible example,

00:28:31,009 --> 00:28:34,220
but I have a birthday that we can call.

00:28:34,220 --> 00:28:37,120
But we can't access my age because it's not an attribute on there.

00:28:37,120 --> 00:28:40,400
And this really is used a fair bit in JavaScript,

00:28:40,410 --> 00:28:43,430
like, oh this is clever, we can hide the data in this closure.

00:28:43,430 --> 00:28:48,240
And I don't know what that's about, quite, but every year I've come to Python,

00:28:48,249 --> 00:28:50,960
people talk about, you know, it would be okay if you can see those attributes.

00:28:50,960 --> 00:28:54,159
Just use an underscore to indicate it's not part of public API.

00:28:54,159 --> 00:28:57,699
So it's, like, a reason maybe why we don't do that as much.

00:28:57,700 --> 00:29:01,999
Okay so let's -- we need to wrap up, we need to get our closure quickly.

00:29:01,999 --> 00:29:04,190
I think it's fine we don't use those rebinding closures so much.

00:29:04,190 --> 00:29:07,090
We have alternate way of expressing things.

00:29:07,090 --> 00:29:09,910
We should be using non-local where appropriate in Python 3 code.

00:29:09,910 --> 00:29:12,760
It comes up some; we don't need to search out places to use it,

00:29:12,760 --> 00:29:15,070
but like that Django example, sometimes it's a natural way

00:29:15,070 --> 00:29:19,640
to express code; it would be nice not to use that mutable object hack.

00:29:19,640 --> 00:29:21,840
What are closures and does Python have them?

00:29:21,840 --> 00:29:23,720
Yes, Python has them. We'll skip to that one.

00:29:23,720 --> 00:29:28,040
But closures are the combination of code and environment

00:29:28,040 --> 00:29:30,700
and all Python functions are that.

00:29:30,700 --> 00:29:33,580
Sometimes we say closures only count if they refer to variables

00:29:33,580 --> 00:29:37,920
from an outer scope, or if they refer to variables from an outer non-global scope,

00:29:37,920 --> 00:29:40,340
doesn't count of it's global because that's too easy.

00:29:40,340 --> 00:29:43,260
They preserve mappings that have gone out of scope because that proves

00:29:43,260 --> 00:29:46,059
that they're being preserved in some cool interesting way.

00:29:46,059 --> 00:29:49,799
And maybe they even have to rebind outer scope, those non global variables.

00:29:49,800 --> 00:29:51,840
But I kind of like the:

00:29:51,840 --> 00:29:55,480
closures refer to these variables from an outer non global scope.

00:29:55,480 --> 00:29:58,180
That's plenty for me.

00:29:58,180 --> 00:30:00,620
If you're asked, does Python even have closures?

00:30:00,630 --> 00:30:04,490
You could say something like this: "Yeah, Python functions can absolutely refer

00:30:04,490 --> 00:30:07,809
"to variables and outer scopes even after those variables themselves

00:30:07,809 --> 00:30:09,520
"have gone out of scope."

00:30:09,520 --> 00:30:12,360
So you could -- maybe could memorize that, just spout that out.

00:30:12,369 --> 00:30:14,240
But I think it's nicer to have a conversation about:

00:30:14,240 --> 00:30:16,760
"That's interesting that you say closures. "Now do you mean blank blank?"

00:30:16,760 --> 00:30:21,789
And then I think that's maybe more what the interviewer's looking for anyway.

00:30:21,789 --> 00:30:23,440
Does Python even have closures?

00:30:23,440 --> 00:30:25,860
Yeah, absolutely, maybe you can add this afterthought, like,

00:30:25,860 --> 00:30:29,580
yeah, since Python 2.2. but most of us when we're explaining our languages,

00:30:29,580 --> 00:30:32,610
we don't have to say, "Well, yeah, but only for the last 16 years,

00:30:32,610 --> 00:30:34,610
"right, only for the last 15 years."

00:30:34,610 --> 00:30:35,610
[laughter]

00:30:35,610 --> 00:30:38,850
So if you want you can add that. Maybe if you can make a guess

00:30:38,850 --> 00:30:40,820
how long you've been programming.

00:30:40,820 --> 00:30:42,660
Great! So if you want to find out more,

00:30:42,660 --> 00:30:44,840
here are things I couldn't get to that I would love to have.

00:30:44,850 --> 00:30:47,419
Unfortunately I don't have time for questions, but I'd love to take them

00:30:47,419 --> 00:30:49,210
out in the hall behind here.

00:30:49,210 --> 00:30:52,660
I'd love it if you could tell me about how my description of closures

00:30:52,660 --> 00:30:54,759
is kind of wrong or if you know something about the history of them,

00:30:54,759 --> 00:30:57,759
that'd be really fascinating.

00:30:57,759 --> 00:30:59,690
But I hope I've helped you all find closure with closures.

00:30:59,690 --> 00:31:01,690
Thanks so much for coming.

00:31:01,690 --> 00:31:05,570

YouTube URL: https://www.youtube.com/watch?v=E9wS6LdXM8Y


