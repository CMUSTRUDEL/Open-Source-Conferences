Title: Matt Bachmann - Better Testing With Less Code: Property Based Testing With Python - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Matt Bachmann

Standard unit tests have developers test specific inputs and outputs. This works, but often what breaks code are the cases we did not think about. Property based testing has developers define properties of output and has the computer explore the possible inputs to verify these properties. This talk will introduce property based testing and provide real world examples and patterns.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:00,000 --> 00:00:02,120
[applause]

00:00:02,940 --> 00:00:04,740
Howdy, everybody.

00:00:04,740 --> 00:00:06,800
Today -- I'm Matt Bachmann, and today I'm gonna be talking

00:00:06,800 --> 00:00:09,320
about property-based testing in Python.

00:00:09,330 --> 00:00:11,990
So I want to start with something that I think we already know:

00:00:11,990 --> 00:00:13,800
testing is important.

00:00:13,809 --> 00:00:16,980
It leads to better refactoring in that you have the safety to make changes,

00:00:16,980 --> 00:00:19,880
knowing that you didn't break everything.

00:00:19,880 --> 00:00:22,060
It gives you better design, in the sense that if you have code

00:00:22,060 --> 00:00:24,000
that's well tested and that's easy to test,

00:00:24,000 --> 00:00:26,640
you tend to have better code overall.

00:00:26,640 --> 00:00:29,520
It gives you regression protection in that you can encode a bug

00:00:29,520 --> 00:00:33,580
in the form of a test and verify you don't get that exact bug again,

00:00:33,580 --> 00:00:36,540
which is just delightful, and I think we have an argument

00:00:36,540 --> 00:00:40,280
that all this leads to faster development overall through safety.

00:00:40,900 --> 00:00:44,240
But I think we all know that testing is hard.

00:00:44,240 --> 00:00:46,640
First of all, it's code. I think a lot of people forget this.

00:00:46,640 --> 00:00:49,100
Test code is code. It needs to be maintained as such.

00:00:49,100 --> 00:00:51,100
You need to deal with duplication. You need to maintain it

00:00:51,100 --> 00:00:53,280
and make sure it still runs fast.

00:00:53,280 --> 00:00:56,080
Isolation is tricky in that trying to write tests

00:00:56,080 --> 00:00:58,220
that properly isolate parts of your system

00:00:58,230 --> 00:01:01,080
can lead to this interesting balance of,

00:01:01,080 --> 00:01:03,140
"Have I mocked too much? Have I not mocked enough?"

00:01:03,140 --> 00:01:05,060
And so it's a very challenging problem

00:01:05,060 --> 00:01:07,040
that I don't think we have an easy answer to.

00:01:07,040 --> 00:01:08,920
Fixtures are something that has to be managed.

00:01:08,920 --> 00:01:11,280
Pytest makes this very easy, but still,

00:01:11,280 --> 00:01:14,040
it's a large amount of test data that needs to be dealt with.

00:01:14,040 --> 00:01:16,280
And finally, the value's indirect.

00:01:16,280 --> 00:01:19,360
Not very often are you posing that the code is well tested

00:01:19,369 --> 00:01:21,449
as, like, the top line feature.

00:01:21,449 --> 00:01:24,380
And when you're playing with new technology, you're not first --

00:01:24,380 --> 00:01:26,640
well, most people aren't -- just reaching for the test, going,

00:01:26,649 --> 00:01:29,229
"OK, let me write some tests, and then let me try this new, exciting thing."

00:01:29,229 --> 00:01:32,620
You usually throw the test and say, "I'll do that later."

00:01:32,620 --> 00:01:34,600
That's because of the indirect value.

00:01:34,600 --> 00:01:36,940
But I think the key is that when writing tests,

00:01:36,950 --> 00:01:39,170
we want to capture the important cases

00:01:39,170 --> 00:01:41,020
and minimize the coding overhead.

00:01:41,020 --> 00:01:43,660
And this is a bit of an easy thing to say, right?

00:01:43,660 --> 00:01:46,809
We want to minimize how much work it is to test it,

00:01:46,809 --> 00:01:49,529
but we want to maximize the amount of coverage.

00:01:49,529 --> 00:01:52,040
And I have a tool that I think -- well, I don't have a tool --

00:01:52,049 --> 00:01:55,420
there is a tool that can help with that, and that's property-based testing.

00:01:55,420 --> 00:01:57,340
But, to go over this, I'm going to start with an example:

00:01:57,340 --> 00:01:59,460
sorting a list of integers. Now, I realize every day

00:01:59,460 --> 00:02:02,100
we have to write sorting algorithms, but just bear with me.

00:02:02,100 --> 00:02:05,359
It's an example that helps, that keeps it simple.

00:02:05,359 --> 00:02:08,179
So I have a sorting algorithm, and up on the screen here,

00:02:08,180 --> 00:02:09,820
you see essentially what --

00:02:09,820 --> 00:02:11,580
a reasonable test for the sorting algorithm.

00:02:11,590 --> 00:02:14,490
I throw an empty list at it, I throw an unsorted list,

00:02:14,490 --> 00:02:17,050
and I throw a sorted list.

00:02:17,050 --> 00:02:19,280
We can quibble about other tests that need to be run,

00:02:19,280 --> 00:02:21,620
because obviously this doesn't cover all the possible cases.

00:02:21,620 --> 00:02:23,520
You can also point out that I have some duplication,

00:02:23,520 --> 00:02:25,860
and that this could be a parameterized test,

00:02:25,860 --> 00:02:28,820
but generally reasonable. But I think we can do better,

00:02:28,830 --> 00:02:32,210
and the way we can do better is with property-based testing.

00:02:32,210 --> 00:02:35,930
If you get nothing else out of this talk, this slide really captures it.

00:02:35,930 --> 00:02:38,380
You describe the arguments that go into your test function,

00:02:38,390 --> 00:02:40,300
rather than specifying them.

00:02:40,300 --> 00:02:42,600
You describe the result of your code, rather than saying,

00:02:42,600 --> 00:02:45,720
"If I get x, I expect y," you do it more generally,

00:02:45,720 --> 00:02:47,740
trying to avoid that hard coding of data.

00:02:47,740 --> 00:02:49,640
And when you do this, it enables the computer

00:02:49,640 --> 00:02:51,580
to be the one to try to prove you wrong.

00:02:51,580 --> 00:02:53,440
You let the computer do the hard work of figuring out

00:02:53,440 --> 00:02:55,300
what cases break your code,

00:02:55,300 --> 00:02:58,200
and you just say what you want your code to do.

00:02:59,080 --> 00:03:02,200
So in a property-based test for our sorting example, we have two parts.

00:03:02,200 --> 00:03:04,100
The arguments, fairly easy.

00:03:04,100 --> 00:03:06,000
It's just a list of any integers.

00:03:06,010 --> 00:03:08,730
The properties of the result is, it better be a list.

00:03:08,730 --> 00:03:11,160
If I throw a list at a sorting algorithm and get a dictionary,

00:03:11,160 --> 00:03:12,960
I got a problem.

00:03:12,960 --> 00:03:15,140
All the elements better be there in the same amounts.

00:03:15,140 --> 00:03:17,040
I don't want any new elements added to my list.

00:03:17,040 --> 00:03:19,220
I don't want any elements taken out.

00:03:19,220 --> 00:03:21,720
And finally, the results are in ascending order.

00:03:21,720 --> 00:03:25,280
In other words, the list better be sorted after my sorting algorithm runs.

00:03:25,840 --> 00:03:27,800
So what does this look like in Python?

00:03:27,800 --> 00:03:30,460
And in order to do that, I need to a quick plug.

00:03:30,460 --> 00:03:32,340
The library that I'm gonna be using throughout this talk --

00:03:32,340 --> 00:03:34,320
and really, it's a library you're gonna reach for in Python --

00:03:34,320 --> 00:03:37,980
is called hypothesis. It's written by David R. MacIver.

00:03:37,980 --> 00:03:41,400
It's got fantastic docs. It's inspired by Haskell's quickcheck.

00:03:41,400 --> 00:03:43,320
And if anything I do impresses you today,

00:03:43,320 --> 00:03:45,220
he offers training for your organization.

00:03:45,220 --> 00:03:48,820
Look them up. Go to hypothesis.works. Plug over. Let's go on.

00:03:48,820 --> 00:03:53,820
So this is our property-based test for testing our little sorting algorithm.

00:03:53,820 --> 00:03:57,280
It looks pretty straightforward. It takes in a list and it sorts it.

00:03:57,280 --> 00:04:00,360
it verifies that it got back a list. Awesome.

00:04:00,360 --> 00:04:02,800
It's using the counter dictionary to basically say

00:04:02,810 --> 00:04:04,760
all the elements are there in the right amounts

00:04:04,760 --> 00:04:07,720
by counting both the resulting list and the input list.

00:04:07,730 --> 00:04:09,640
And then, finally, this little bit of functional code --

00:04:09,640 --> 00:04:11,560
just trust me if you don't want to figure that out --

00:04:11,560 --> 00:04:14,180
saying it's in ascending order.

00:04:14,540 --> 00:04:16,700
So, looking at our test, it looks like any standard test.

00:04:16,709 --> 00:04:18,729
It will -- this test will run in Pytest,

00:04:18,729 --> 00:04:20,969
it will run in Nose, it will run in unittest.

00:04:20,969 --> 00:04:23,449
But syntactically, we have one big difference:

00:04:23,449 --> 00:04:25,380
you have the given decorator.

00:04:25,380 --> 00:04:27,740
And what this decorator is doing is generally generating data

00:04:27,749 --> 00:04:30,849
to throw at your test using the description provided,

00:04:30,849 --> 00:04:32,640
in this case, a list of integers.

00:04:32,640 --> 00:04:34,860
And what it's doing under the hood is it's calling your test

00:04:34,870 --> 00:04:37,720
again and again and again with data it comes up with:

00:04:37,720 --> 00:04:39,640
an empty list, a list of one element,

00:04:39,640 --> 00:04:42,820
a list of two elements with big numbers, so on, so forth.

00:04:42,820 --> 00:04:44,600
These are just examples I came up with.

00:04:44,600 --> 00:04:47,860
You can see some crazy examples hypothesis comes up with.

00:04:47,860 --> 00:04:51,620
But the cool thing is that in your test suite, it looks like one test.

00:04:51,620 --> 00:04:54,140
Pretty nice. But the thing that's really, really important,

00:04:54,140 --> 00:04:56,560
that not all property-based testing frameworks do,

00:04:56,560 --> 00:04:59,960
but I think is kind of critical for them -- quickcheck definitely does it --

00:04:59,960 --> 00:05:02,500
is: say I've got a failing example up here.

00:05:02,509 --> 00:05:04,919
We can all guess on what I broke in my sorting algorithm

00:05:04,919 --> 00:05:07,651
to cause this test to fail, but what hypothesis will do is

00:05:07,651 --> 00:05:10,240
it will take that list and it will try to simplify it.

00:05:10,240 --> 00:05:13,080
It will say, "Hey, that failed, but so did this,"

00:05:13,080 --> 00:05:15,600
And then it will do that again, and it'll finally say,

00:05:15,600 --> 00:05:17,960
"I don't think you wrote a sorting algorithm at all.

00:05:17,960 --> 00:05:20,320
"I was able to simplify --

00:05:20,320 --> 00:05:23,140
"you can't handle the most basic sorting elements."

00:05:23,140 --> 00:05:26,320
But I think, looking at this, we can say the bottom

00:05:26,320 --> 00:05:29,529
is far easier to deal with than with the top.

00:05:29,529 --> 00:05:31,960
So even though you're dealing with random data,

00:05:31,960 --> 00:05:34,280
a good property-based testing framework

00:05:34,280 --> 00:05:37,240
will try to reduce that data down to a case that's easy to reason about

00:05:37,240 --> 00:05:39,020
whenever possible.

00:05:39,680 --> 00:05:41,500
Before we go on, I want to talk a little bit

00:05:41,500 --> 00:05:43,420
about the given decorator.

00:05:43,420 --> 00:05:46,380
And this is just the way hypothesis lets you write

00:05:46,380 --> 00:05:48,520
strategies to throw at your test cases.

00:05:48,520 --> 00:05:50,560
Essentially you have your types that you define

00:05:50,560 --> 00:05:52,720
in the form of these strategies: you have Booleans, floats,

00:05:52,720 --> 00:05:55,800
strings, complex numbers, ints, so on, so on, so on.

00:05:55,800 --> 00:05:57,860
You have your collection types, your dictionaries, your tuples,

00:05:57,860 --> 00:05:59,640
your lists, sets, builds,

00:05:59,650 --> 00:06:03,189
lets you call a function with arguments that get generated.

00:06:03,189 --> 00:06:05,400
And then you can combine these to more complicated things.

00:06:05,400 --> 00:06:07,780
I can give an entire talk on just generating data in hypothesis,

00:06:07,789 --> 00:06:09,720
but that's not really what I'm here to do.

00:06:09,720 --> 00:06:12,380
But I'm gonna go over a quick example, just so everyone walks out of here

00:06:12,380 --> 00:06:15,460
with a sense of what it's like to work with these strategies.

00:06:15,460 --> 00:06:18,040
So I have a dog test. It test dogs.

00:06:19,220 --> 00:06:22,180
It uses the builds decorator in order to construct a dog,

00:06:22,180 --> 00:06:24,560
and I describe the arguments to that dog.

00:06:24,560 --> 00:06:27,320
That way the dog gets put into my test and it runs.

00:06:27,320 --> 00:06:30,080
But very quickly, you'll realize that I have defined

00:06:30,080 --> 00:06:31,900
the strategy way too broadly, and what you tend to do is

00:06:31,900 --> 00:06:34,020
you tend to kind of massage the data a little bit.

00:06:34,020 --> 00:06:36,400
You say, "Well, I don't want breed to be ANY string.

00:06:36,400 --> 00:06:38,220
"I want it to be one of my known breeds."

00:06:38,220 --> 00:06:40,660
So you swap that out for a list of known breeds.

00:06:40,660 --> 00:06:42,600
You pull them out of that.

00:06:42,600 --> 00:06:44,680
Name -- chances are you don't want to deal with

00:06:44,680 --> 00:06:47,720
the empty string, so you put in some limits on that.

00:06:47,720 --> 00:06:50,740
You say, "I want at least five characters." That's fine.

00:06:50,740 --> 00:06:52,780
And then for height and weight, I put in floats,

00:06:52,789 --> 00:06:54,610
and if anyone works with floats, they know they're more complicated

00:06:54,610 --> 00:06:57,400
than just decimal numbers. I obviously don't want infinity,

00:06:57,400 --> 00:07:00,240
I don't want NaN, and I got a min-max value.

00:07:00,240 --> 00:07:03,040
And then finally I want to make sure it works with the boss's dog,

00:07:03,050 --> 00:07:05,330
so I put in the example, and what this is doing is saying,

00:07:05,330 --> 00:07:07,220
"I don't care what data you throw at my test,

00:07:07,220 --> 00:07:09,220
"just make sure one of the things you throw at my test

00:07:09,220 --> 00:07:11,140
"is this specified one."

00:07:11,140 --> 00:07:13,900
And so the idea is you sort of massage these strategies

00:07:13,909 --> 00:07:17,509
in order to generate the data that really fits your domain for your test.

00:07:17,509 --> 00:07:20,539
Fancy. But hopefully you're getting a sense

00:07:20,539 --> 00:07:24,159
that we have this framework that lets you have potentially infinite cases

00:07:24,160 --> 00:07:26,200
with no real data hard-coded, right?

00:07:26,200 --> 00:07:29,180
We're not saying, "If I get x, I expect y."

00:07:29,180 --> 00:07:31,440
You're saying, "If I get something that looks like x,

00:07:31,440 --> 00:07:33,680
"I expect behavior y."

00:07:34,080 --> 00:07:36,520
And that is very little code. Pretty powerful idea.

00:07:36,520 --> 00:07:38,820
But if you walk out of here with just this,

00:07:38,830 --> 00:07:40,860
you'll go back to your computer and you'll start playing with it

00:07:40,860 --> 00:07:43,880
you'll start to realize that you've not really written many tests like this.

00:07:43,880 --> 00:07:46,440
It's actually really hard to think about how it should fit

00:07:46,440 --> 00:07:49,740
into your code until someone teaches you patterns.

00:07:49,740 --> 00:07:51,520
Welcome to my talk.

00:07:51,520 --> 00:07:53,039
[laughter]

00:07:53,039 --> 00:07:55,399
First thing I want to bring up: I'm not talking about a magic bullet.

00:07:55,400 --> 00:07:57,720
This is not going to replace your entire test suite.

00:07:57,720 --> 00:08:00,820
This is not going to be just "revolutionize everything ever,"

00:08:00,820 --> 00:08:02,760
but it is going to be a very interesting tool

00:08:02,760 --> 00:08:04,840
that I think more people should be reaching for,

00:08:04,840 --> 00:08:07,620
and hopefully by the end of today, you'll give it a shot.

00:08:07,620 --> 00:08:11,400
First pattern: the code should not explode.

00:08:12,000 --> 00:08:14,469
I challenge anyone in this room not to find a way

00:08:14,469 --> 00:08:17,049
to use this pattern in their code, because essentially,

00:08:17,049 --> 00:08:19,700
when I run your code, it shouldn't explode.

00:08:19,700 --> 00:08:22,180
I think this is a pretty basic requirement.

00:08:23,440 --> 00:08:27,120
So, say I got an API. I do some contracting work for Batman.

00:08:27,120 --> 00:08:29,800
He has an API for his batputer. It'll pull out criminal aliases.

00:08:29,800 --> 00:08:33,620
It's got some parameters, an ID, a sorting, and a max.

00:08:33,620 --> 00:08:36,460
And the biggest thing about this API is it's a JSON response,

00:08:36,460 --> 00:08:40,880
and it's got some status codes: a 200, 401, 400, 404,

00:08:40,880 --> 00:08:43,260
and anything outside this range is weird.

00:08:43,260 --> 00:08:46,160
A potential explosion, as it were.

00:08:46,520 --> 00:08:48,920
So think about how we would test this API.

00:08:48,920 --> 00:08:51,420
And keep in mind, I'm not trying to say the API works.

00:08:51,420 --> 00:08:55,420
I'm not promising that. All I'm promising is that it didn't explode.

00:08:55,420 --> 00:08:58,080
That's the big thing to take away.

00:08:58,080 --> 00:09:00,060
And here's what that test looks like.

00:09:00,459 --> 00:09:02,660
I give it my properties of an integer --

00:09:02,660 --> 00:09:04,600
uh, I give it my parameters of an integer,

00:09:04,600 --> 00:09:06,620
some text, some other integer,

00:09:06,620 --> 00:09:09,400
feed it into my test. I simply make the API call.

00:09:09,400 --> 00:09:13,540
I verify, no matter what happened, that the response came back as JSON

00:09:13,540 --> 00:09:16,960
and that the status code is in one of my expected status codes.

00:09:16,960 --> 00:09:19,300
I guarantee you if you put this pattern into your code base --

00:09:19,300 --> 00:09:22,019
and it doesn't have to be an API example; you can do, like, raising --

00:09:22,019 --> 00:09:24,269
making sure your code didn't raise any unexpected exceptions,

00:09:24,269 --> 00:09:26,869
so on, so forth -- you'll make your code more stable,

00:09:26,869 --> 00:09:28,900
and you'll potentially make it more secure.

00:09:28,900 --> 00:09:31,260
I've seen this pattern catch security bugs,

00:09:31,260 --> 00:09:33,720
but mostly what it catches is a lot of validation errors,

00:09:33,730 --> 00:09:36,230
because your users are going to throw data you don't expect,

00:09:36,230 --> 00:09:39,520
so you're probably not going to think to encode everything into a test.

00:09:39,520 --> 00:09:41,560
And letting the computer try to find those problems

00:09:41,560 --> 00:09:44,260
is a lot cheaper than letting your users find them.

00:09:45,680 --> 00:09:48,000
Boop, boop, boop. Nobody saw that.

00:09:48,000 --> 00:09:50,700
Pattern 2: reversible operations.

00:09:51,420 --> 00:09:53,780
So the idea here is if you have something that can be undone,

00:09:53,780 --> 00:09:55,960
you have a property which you can test.

00:09:56,920 --> 00:09:59,760
Some examples of when you use this pattern are encoding operations,

00:09:59,760 --> 00:10:02,340
undo operations, and serialization.

00:10:02,340 --> 00:10:04,840
I'm going to focus on serialization for my example.

00:10:04,840 --> 00:10:08,520
I also like to call this pattern the "It works, don't fi-- don't --

00:10:08,520 --> 00:10:12,140
"It works, don't break it." "It works, don't fix it"? Whatever.

00:10:12,140 --> 00:10:15,500
Historical object. So I have an object.

00:10:17,740 --> 00:10:19,640
Sorry, my brain got messed up.

00:10:19,640 --> 00:10:21,200
[laughter]

00:10:21,200 --> 00:10:23,100
This is the reversible options pattern.

00:10:23,100 --> 00:10:25,240
So I've created a historical event.

00:10:25,240 --> 00:10:27,760
It has an ID, description, time,

00:10:27,760 --> 00:10:29,600
and I want to communicate with a web front end.

00:10:29,600 --> 00:10:32,920
So I write JSON encoder and then I write a decoder.

00:10:32,930 --> 00:10:35,410
So I can send objects to my framework -- to my web end,

00:10:35,410 --> 00:10:37,380
my web can send me objects back.

00:10:37,380 --> 00:10:39,460
And the key property I'm trying to test

00:10:39,460 --> 00:10:42,240
is that I can go from Python to JSON

00:10:42,240 --> 00:10:45,560
back to Python without losing anything.

00:10:45,560 --> 00:10:49,000
In other words, can I encode? Can I decode?

00:10:49,560 --> 00:10:51,460
And here's what that testlooks like.

00:10:51,460 --> 00:10:54,820
Take in my types in order to construct my object,

00:10:54,820 --> 00:10:58,420
build my event, dump it out into JSON,

00:10:58,420 --> 00:11:01,680
load it into a different object from JSON to my object,

00:11:01,680 --> 00:11:04,340
and verify I got the same thing back.

00:11:04,340 --> 00:11:07,360
And some of you might be saying, "Well, this is very easy code.

00:11:07,360 --> 00:11:09,860
"I could just write one or two tests and I'd be fine."

00:11:09,860 --> 00:11:11,700
And chances are, most of you would be fine.

00:11:11,700 --> 00:11:13,600
In fact, I was worried when I wrote this example

00:11:13,600 --> 00:11:16,160
that I wasn't gonna be able to reasonably construct a bug,

00:11:16,160 --> 00:11:18,280
but it turns out, I found a bug.

00:11:18,960 --> 00:11:22,780
It was in dateutil, and the problem with dateutil --

00:11:22,780 --> 00:11:25,680
and this is a very obscure bug. Dateutil is a fine library.

00:11:25,680 --> 00:11:28,020
But the problem was, if you had a historical event

00:11:28,029 --> 00:11:30,460
that was between 0 and 100 A.D.

00:11:30,460 --> 00:11:32,940
and you were parsing it as an ISO-formatted string,

00:11:32,940 --> 00:11:34,800
dateutil would mess up.

00:11:34,800 --> 00:11:36,760
And this is exactly what i'm talking about.

00:11:36,760 --> 00:11:39,560
it's an obscure bug, but I'm glad I found it in the --

00:11:39,560 --> 00:11:42,420
when I was writing the test, mainly because I was writing the talk.

00:11:42,420 --> 00:11:44,400
But if in a real app, I'm glad I found it in the test

00:11:44,401 --> 00:11:46,261
and not in production.

00:11:46,261 --> 00:11:50,200
And that patch has been fixed. Dateutil continues to be great.

00:11:50,200 --> 00:11:52,500
Pattern 3: testing oracle.

00:11:52,500 --> 00:11:56,120
Earlier when my brain broke, I was talking about this example.

00:11:56,120 --> 00:11:57,900
So the idea behind the testing oracle is

00:11:57,900 --> 00:11:59,700
you have a system that you know to be correct,

00:11:59,700 --> 00:12:01,520
and you have a system you don't know to be correct,

00:12:01,520 --> 00:12:03,560
and you use the unknown system to test --

00:12:03,569 --> 00:12:06,209
use the known system to test the unknown system.

00:12:06,209 --> 00:12:10,669
I like to call the pattern the "Leave it alone" pattern.

00:12:10,669 --> 00:12:12,180
[laughter]

00:12:12,190 --> 00:12:14,710
You have an ugly system. Leave it alone.

00:12:14,710 --> 00:12:17,340
Use it for your test. Other cases where this is useful:

00:12:17,350 --> 00:12:19,709
it's useful for when you're emulating something.

00:12:19,709 --> 00:12:22,049
If you can hook up that original thing to your test suite,

00:12:22,049 --> 00:12:24,369
you can use that as your test. Another way --

00:12:24,369 --> 00:12:26,220
another thing it's good for is optimization,

00:12:26,220 --> 00:12:28,840
and I'll get into a little bit about that later.

00:12:28,850 --> 00:12:32,090
So the property being tested here is that my clean, fancy,

00:12:32,090 --> 00:12:36,250
beautiful new system better do the same thing as my broken system,

00:12:36,250 --> 00:12:39,210
assuming the assumption of "the broken system generally works

00:12:39,210 --> 00:12:42,560
"but I just can't touch it because it's scary" is correct,

00:12:42,560 --> 00:12:46,640
which, I admit, is a big exception, but let's go on.

00:12:46,640 --> 00:12:49,020
This is what that test looks like. Very simple.

00:12:49,020 --> 00:12:52,460
Take in -- generate your arguments, throw it to your new hotness,

00:12:52,460 --> 00:12:55,740
run it against your legacy system, and verify you get the same result.

00:12:55,740 --> 00:12:57,820
Now I guarantee you, if you try this pattern out,

00:12:57,830 --> 00:12:59,760
you'll find that your legacy system isn't as great

00:12:59,760 --> 00:13:02,160
as everyone was telling you, but that's fine.

00:13:02,160 --> 00:13:04,920
You can -- this is where massaging the strategy comes in.

00:13:04,930 --> 00:13:07,720
This comes into throwing out examples that you know not to work.

00:13:07,720 --> 00:13:10,040
And there's a lot you can go into this, but this isn't specifically

00:13:10,040 --> 00:13:13,300
a hypothesis talk, so I'm not gonna go into those details.

00:13:13,300 --> 00:13:16,560
Another example of this pattern is comparing against brute force.

00:13:16,560 --> 00:13:18,380
I think we've all been in the situation of

00:13:18,380 --> 00:13:21,900
we wanted to write a fancy algorithm, and we knew the easy way to do it

00:13:21,900 --> 00:13:23,800
where you check every case, but you know in production

00:13:23,800 --> 00:13:26,700
that's just not going to fly because it just hurts, performance-wise.

00:13:26,700 --> 00:13:30,040
But you can use that easy-to-implement version as a test

00:13:30,040 --> 00:13:32,640
for your fancy, super-cool version,

00:13:32,640 --> 00:13:35,360
and that test looks identical to the one I showed you earlier.

00:13:35,360 --> 00:13:37,360
You take -- you generate your arguments,

00:13:37,360 --> 00:13:40,000
you throw it to the easy-but-inefficient solution,

00:13:40,000 --> 00:13:43,800
and make sure you get the same result in your optimized, fancy solution.

00:13:43,800 --> 00:13:46,639
And then just, a billion test cases, almost no code.

00:13:46,639 --> 00:13:48,620
That's effectively a three-liner that I've broken up

00:13:48,620 --> 00:13:51,480
because I like to break up lines.

00:13:52,900 --> 00:13:54,820
Pattern 4: stateful testing.

00:13:54,820 --> 00:13:58,320
This is sort of the pro mode of property-based testing.

00:13:58,320 --> 00:14:01,319
The idea behind stateful testing

00:14:01,319 --> 00:14:03,379
is that we're testing more interesting systems.

00:14:03,380 --> 00:14:06,040
Everything we've talked about up to now has been:

00:14:06,040 --> 00:14:09,140
input goes into my system, I get an output.

00:14:09,140 --> 00:14:11,700
No side effects, very functional.

00:14:11,700 --> 00:14:14,280
And a lot of people, when they hear about property-based testing,

00:14:14,280 --> 00:14:16,820
think it only works for this case, and in the real world,

00:14:16,820 --> 00:14:20,129
our systems get more complicated, and they get more complicated,

00:14:20,129 --> 00:14:21,900
and so on and so forth.

00:14:21,900 --> 00:14:24,060
So, stateful test is you define a state,

00:14:24,060 --> 00:14:27,280
you define what operations can happen in what conditions,

00:14:27,280 --> 00:14:29,940
you define how those operations affect the state,

00:14:29,949 --> 00:14:33,800
and then you put in your assertions: what must be true at any state.

00:14:33,800 --> 00:14:37,620
And I'm going to walk you through how hypothesis models this idea.

00:14:38,700 --> 00:14:40,819
But when you do this, what you're effectively building

00:14:40,819 --> 00:14:44,639
is a vessel for hypothesis to go out,

00:14:44,640 --> 00:14:46,880
search the search space, and bring you back bugs.

00:14:46,880 --> 00:14:51,300
"Find me bugs, test suite. Bring them back."

00:14:51,300 --> 00:14:53,660
And here's what that looks like. So I got an example here.

00:14:53,670 --> 00:14:56,920
This is a max-heap. A little bit of CS primer.

00:14:56,920 --> 00:14:59,920
The root node of this tree is the max of the entire tree,

00:14:59,920 --> 00:15:02,820
and for every subelement of that tree, that property holds.

00:15:02,820 --> 00:15:05,700
So, if I go down the 19, it's the max of that subtree.

00:15:05,700 --> 00:15:09,060
If I go to 36, it's the max of that subtree, so on, so forth.

00:15:09,060 --> 00:15:11,580
That's the main property being tested here.

00:15:12,060 --> 00:15:14,060
We have a few operations we can run on our heap:

00:15:14,069 --> 00:15:17,349
the creation of the heap, pushing elements onto the heap,

00:15:17,349 --> 00:15:19,819
popping elements off the heap (in other words, popping off that root

00:15:19,819 --> 00:15:23,050
and making sure the tree stays balanced), and then merging two trees.

00:15:23,050 --> 00:15:24,970
In other words, I got two heaps.

00:15:24,970 --> 00:15:27,540
Put them together to create a new heap,

00:15:27,540 --> 00:15:29,380
keeping that property.

00:15:29,700 --> 00:15:33,000
So in order to test this, what we do is we create a data store of heaps.

00:15:33,000 --> 00:15:34,900
And what we're going to do is we're going to throw heaps in there

00:15:34,900 --> 00:15:37,820
that have been generated to be used for other conditions.

00:15:37,820 --> 00:15:40,279
And we have a cloud of integers, which is basically that given property

00:15:40,279 --> 00:15:42,979
from before; in other words, pull from here and get an integer.

00:15:44,200 --> 00:15:48,200
So, in __init__, we construct a heap and put it into the data structure.

00:15:48,200 --> 00:15:50,079
Pretty basic.

00:15:50,080 --> 00:15:52,700
For push, we grab a heap that we generated earlier,

00:15:52,700 --> 00:15:56,880
we grab an integer out of the cloud, add that to the heap,

00:15:56,880 --> 00:15:59,740
therefore modifying the heap in that structure.

00:16:00,600 --> 00:16:03,540
Merge takes two heaps out of our data structure,

00:16:03,540 --> 00:16:05,720
puts them together to create a new tree,

00:16:05,730 --> 00:16:09,080
and then puts that into the heap structure --

00:16:09,080 --> 00:16:12,720
in other words, creating another thing that we can pull from later for tests.

00:16:12,720 --> 00:16:15,640
And then finally, pop: grab any heap that we've generated

00:16:15,649 --> 00:16:18,180
and put in that structure, pop up the main element,

00:16:18,180 --> 00:16:20,080
scan the tree looking for the max, and then make sure

00:16:20,080 --> 00:16:22,889
when we call pop, we get that same max.

00:16:22,889 --> 00:16:26,429
In other words, this is the property we want to be true no matter what.

00:16:26,429 --> 00:16:28,360
And what we've done here is we've created a system

00:16:28,360 --> 00:16:30,579
that allows hypothesis or any framework you're using

00:16:30,580 --> 00:16:34,860
to scan the search space by trying these different operations out.

00:16:34,860 --> 00:16:39,080
And here's what this looks like in code, in case my diagrams didn't clarify.

00:16:39,080 --> 00:16:42,120
We create a machine, we define our data structure --

00:16:42,120 --> 00:16:45,400
that's the green little database- looking thing I created earlier.

00:16:45,880 --> 00:16:50,340
We have a rule to create a new heap, which is: it creates a new heap,

00:16:50,340 --> 00:16:53,640
throws it into the target, which is our heap data structure.

00:16:53,640 --> 00:16:56,680
We do heap push, which grabs a heap out of our heaps,

00:16:56,680 --> 00:17:00,180
grabs a value out of the integer cloud, modifies the heap,

00:17:00,180 --> 00:17:02,780
therefore modifying it in our structure.

00:17:03,140 --> 00:17:05,940
Then we have the merge operations which grabs the two heaps,

00:17:05,940 --> 00:17:07,820
puts them together to make a new heap,

00:17:07,820 --> 00:17:10,520
and then puts that result back in our structure.

00:17:10,520 --> 00:17:14,240
And finally we have pop: grab a heap that's not empty,

00:17:14,240 --> 00:17:16,380
scan it looking for the max value,

00:17:16,380 --> 00:17:19,340
call pop on it, and verify the result's the same.

00:17:19,820 --> 00:17:22,680
Even if none of that made sense to you, that's fine.

00:17:22,680 --> 00:17:26,700
Just, like, take this point away: when you run hypothesis,

00:17:26,700 --> 00:17:31,200
what you'll find is it will go out and it will try to find you a bug.

00:17:31,200 --> 00:17:33,400
But not only will it come back with a bug, it will not say,

00:17:33,400 --> 00:17:37,000
"Sir, madam, I have only -- I have found a bug."

00:17:37,000 --> 00:17:39,780
It's like, well, I can't do anything with an assertion error, right?

00:17:39,780 --> 00:17:41,860
What it'll bring you back is far more interesting

00:17:41,860 --> 00:17:45,200
than an assertion error: it'll bring you back a program.

00:17:45,760 --> 00:17:48,040
By creating all these steps and defining all these steps,

00:17:48,040 --> 00:17:51,260
it will spit out what steps it ran in order to create the bug.

00:17:51,260 --> 00:17:53,920
It said, "After running all these steps,

00:17:53,920 --> 00:17:56,720
"then that last pop, the assertion failed.

00:17:56,720 --> 00:17:59,500
"I did not get the max element like I expected."

00:17:59,500 --> 00:18:01,660
And I'm not lying to you, I swear!

00:18:01,660 --> 00:18:04,700
This is me running in a terminal with a different bug.

00:18:04,700 --> 00:18:07,400
See on the bottom there? You know how nice that is to see

00:18:07,400 --> 00:18:09,700
when you're dealing with a complex system?

00:18:09,700 --> 00:18:12,500
Steps! Reproducibility!

00:18:12,500 --> 00:18:14,660
[laughter]

00:18:15,500 --> 00:18:20,660
[applause]

00:18:20,660 --> 00:18:24,180
Sometimes I have trouble getting that out of bug reports, you know?

00:18:24,180 --> 00:18:26,100
[laughter]

00:18:27,100 --> 00:18:30,280
So, just to summarize: property-based testing:

00:18:30,280 --> 00:18:33,340
describe the arguments, describe the result,

00:18:33,340 --> 00:18:35,800
have the computer try to prove you wrong.

00:18:36,480 --> 00:18:38,460
Now, the call to action, because now it's time for you

00:18:38,460 --> 00:18:40,280
to do something for me.

00:18:40,960 --> 00:18:43,940
Download the library. I recommend hypothesis.

00:18:43,940 --> 00:18:45,900
I'm not going to say it's the only library out there

00:18:45,900 --> 00:18:48,440
but it seems to be the best in the Python world.

00:18:48,440 --> 00:18:51,340
Use it. I want you to all use it,

00:18:51,350 --> 00:18:55,310
and then share how you used it and find more of these patterns.

00:18:55,310 --> 00:18:57,360
Find ways to use it, especially if you can get me

00:18:57,370 --> 00:18:59,240
more examples of the stateful testing.

00:18:59,240 --> 00:19:03,280
I know mercurial uses it, and I know that hypothesis uses it internally,

00:19:03,280 --> 00:19:05,480
and I know PyPy also has used it.

00:19:05,480 --> 00:19:08,020
So it's got some real world usage, but I want more on this

00:19:08,020 --> 00:19:10,220
because, quite frankly, I'm still learning,

00:19:10,220 --> 00:19:12,280
and I just want more people do it.

00:19:12,280 --> 00:19:14,240
And that's all I got for you today.

00:19:14,240 --> 00:19:16,820
Here are some resources over there,

00:19:16,820 --> 00:19:19,320
and get the slides later.

00:19:19,330 --> 00:19:22,210
I got other things you can look at to learn more about it.

00:19:22,210 --> 00:19:24,270
And that's all I got.

00:19:24,270 --> 00:19:33,160
[applause]

00:19:33,160 --> 00:19:35,640
(host) OK, we have about 10 minutes for questions.

00:19:35,640 --> 00:19:38,400
Let me run to you with the mic

00:19:38,400 --> 00:19:41,600
so that everybody and the recordings can hear it.

00:19:41,820 --> 00:19:43,740
(audience member) Thanks, Matt. Great talk.

00:19:43,740 --> 00:19:48,760
You had an example of the -- your function decorator example.

00:19:48,770 --> 00:19:51,740
Does that go inside the given when you're doing that or is that --

00:19:51,740 --> 00:19:53,880
you put that on top of your test?

00:19:53,880 --> 00:19:55,800
(Matt Bachmann) You put the decorator

00:19:55,800 --> 00:19:57,700
on top of your test function, yeah.

00:20:05,100 --> 00:20:07,220
(audience member) If I wanted unit tests to be

00:20:07,230 --> 00:20:10,350
deterministic for a given run,

00:20:10,350 --> 00:20:13,420
is this something I can ensure with hypothesis?

00:20:13,420 --> 00:20:15,360
(Matt Bachmann) This is an advantage of hypothesis.

00:20:15,360 --> 00:20:17,860
It stores its generated examples in a test database,

00:20:17,860 --> 00:20:19,900
so when it finds a failure example, as long as you haven't

00:20:19,909 --> 00:20:21,850
wiped out that database for some reason,

00:20:21,850 --> 00:20:24,730
when you run it again, that same failure will pop up.

00:20:26,640 --> 00:20:28,160
(audience member) Every time you run it,

00:20:28,160 --> 00:20:29,600
how many samples does it do?

00:20:29,600 --> 00:20:31,100
(Matt Bachmann) I forget the default.

00:20:31,100 --> 00:20:32,960
I think it's roughly 100, but it's configurable.

00:20:32,960 --> 00:20:36,100
So you can configure it by the test, you can configure it globally.

00:20:36,100 --> 00:20:38,020
I actually recommend if you're using it for development

00:20:38,020 --> 00:20:39,920
to keep that number fairly low.

00:20:39,920 --> 00:20:43,120
Like, I use sometimes as low as 20, but then when you run it in CI,

00:20:43,120 --> 00:20:46,100
you can bump that number really high if you want to spend the extra time

00:20:46,100 --> 00:20:48,400
trying to find more obscure examples.

00:20:49,980 --> 00:20:52,720
(audience member) So I see you're using Pytest.

00:20:52,720 --> 00:20:57,230
How does that mix otherwise with fixtures and so forth, noticing that --

00:20:57,230 --> 00:20:59,940
(Matt Bachmann) In my experience, it works fine.

00:20:59,940 --> 00:21:02,080
The property -- the arguments get filled up

00:21:02,080 --> 00:21:04,900
and whatever don't are assumed to be fixtures.

00:21:04,900 --> 00:21:09,180
It works great in Pytest, and it works in other frameworks just fine.

00:21:13,120 --> 00:21:16,020
(audience member) Hi. Have you tried testing it in...

00:21:16,020 --> 00:21:19,720
Like, most of our code is generally dependent on other pieces of functions.

00:21:19,720 --> 00:21:23,289
Like, you'll call a function A, which will call B with some arguments,

00:21:23,289 --> 00:21:25,100
which will call C with some arguments.

00:21:25,100 --> 00:21:27,440
So generally when you're testing, say, B, you kind of mock out

00:21:27,440 --> 00:21:32,440
what A calls it, but then what is it passing C?

00:21:32,440 --> 00:21:36,080
Have you had cases where you had to test this kind of middle-level function

00:21:36,080 --> 00:21:39,220
which is interrelated as part of the call tree?

00:21:39,220 --> 00:21:40,760
(Matt Bachmann) So this is where I'm getting in the

00:21:40,760 --> 00:21:42,620
"I'm still learning how to use this thing."

00:21:42,620 --> 00:21:44,500
Those kinds of examples get trickier and trickier.

00:21:44,500 --> 00:21:48,860
But unless you -- it's a challenging way to think about it, right?

00:21:48,870 --> 00:21:51,750
If you can describe what the final state will be,

00:21:51,750 --> 00:21:53,990
that tends to be how you'll work. If you want to test, like,

00:21:53,990 --> 00:21:57,100
a middle function, you try to find tests and write it directly.

00:21:57,100 --> 00:22:00,700
But once you start talking about mocking, I think it's much more complicated

00:22:00,700 --> 00:22:04,200
to, say, mock in a general way that doesn't depend on data.

00:22:05,520 --> 00:22:07,420
(audience member) Have you ever combined this

00:22:07,420 --> 00:22:10,840
with any coverage tools to kind of close the loop,

00:22:10,840 --> 00:22:12,760
and do you have any thoughts on that?

00:22:12,760 --> 00:22:14,640
(Matt Bachmann) So, my experience is that this does work

00:22:14,640 --> 00:22:17,970
with coverage.py, but I will say at times

00:22:17,970 --> 00:22:21,990
it can be slightly unpredictable because the testing is fairly random.

00:22:21,990 --> 00:22:24,720
If you bump the examples high enough, you'll probably get as much coverage

00:22:24,720 --> 00:22:27,060
as you're gonna get, but it is not necessarily predictable,

00:22:27,060 --> 00:22:29,780
so you might see some weird results in your coverage reports.

00:22:30,460 --> 00:22:32,480
(audience member) So I'm curious how well this works

00:22:32,480 --> 00:22:34,800
with asserting error conditions.

00:22:34,800 --> 00:22:38,420
So, if I input these three things, I expect this exception to happen

00:22:38,429 --> 00:22:41,189
or I expect this failure case to occur.

00:22:41,189 --> 00:22:45,029
(Matt Bachmann) Yep, so that's --

00:22:45,029 --> 00:22:48,120
that's basically what your test framework handles for you.

00:22:48,120 --> 00:22:52,860
So, in your test you can do things like "I expect an error here."

00:22:52,860 --> 00:22:56,640
If you're testing for error conditions, I would try to --

00:22:56,649 --> 00:22:59,429
I would try to separate those tests.

00:22:59,429 --> 00:23:02,320
If you want to write a test that just is expecting errors

00:23:02,320 --> 00:23:05,860
in certain conditions, you can do checks on the data that was generated.

00:23:05,860 --> 00:23:08,539
Like, "If i get an error and the data looks like this,

00:23:08,539 --> 00:23:10,939
"don't fail. It's cool." That kind of thing.

00:23:10,940 --> 00:23:14,540
But, you know, then the test starts getting complicated.

00:23:15,660 --> 00:23:17,560
(audience member) In the example that you showed

00:23:17,560 --> 00:23:19,800
with the dog class,

00:23:19,800 --> 00:23:23,020
I can imagine having that sort of pattern

00:23:23,029 --> 00:23:25,429
all over your tests would get kind of, like, long.

00:23:25,429 --> 00:23:29,570
Is there a way to define those sorts of fixtures separately

00:23:29,570 --> 00:23:31,820
so they can just be reused really easily?

00:23:31,820 --> 00:23:33,820
(Matt Bachmann) Short answer: yes.

00:23:33,820 --> 00:23:38,500
You can basically create custom strategies that can be pulled from.

00:23:47,900 --> 00:23:49,960
(audience member) So, I imagine you end up

00:23:49,960 --> 00:23:53,180
writing some traditional unit tests in addition.

00:23:53,180 --> 00:23:56,100
Do you kind of commingle those, or do you regard this

00:23:56,110 --> 00:23:58,380
as a completely separate process?

00:23:58,380 --> 00:24:00,460
(Matt Bachmann) That's really up to you to decide.

00:24:00,460 --> 00:24:02,980
I think a separate process is probably ideal,

00:24:02,980 --> 00:24:05,420
simply because these tests tend to run a little longer

00:24:05,429 --> 00:24:07,700
because they're running so many examples.

00:24:07,700 --> 00:24:10,159
In fact, hypothesis will punish you for writing slow tests

00:24:10,160 --> 00:24:13,640
because it's running them hundreds of potentially thousands of times.

00:24:13,640 --> 00:24:16,919
So if you're doing a CI system, I totally recommend breaking them up,

00:24:16,919 --> 00:24:19,241
doing your fast unit test, then doing your property-based test

00:24:19,241 --> 00:24:21,321
and moving on from there.

00:24:29,000 --> 00:24:30,900
(audience member) Forgive me if this was asked and answered,

00:24:30,900 --> 00:24:32,800
because I heard talk about mocks.

00:24:32,800 --> 00:24:36,480
How well -- or is it possible for this to handle responses

00:24:36,480 --> 00:24:40,560
from subsystems which would traditionally be mocked?

00:24:40,560 --> 00:24:43,180
(Matt Bachmann) So, once again this comes into,

00:24:43,180 --> 00:24:44,940
"I'm still learning how to deal with this,"

00:24:44,950 --> 00:24:46,720
and this is kind of why I'm giving the talk:

00:24:46,720 --> 00:24:49,260
in order to encourage people to explore these ideas.

00:24:49,260 --> 00:24:54,340
Mocking gets weird, just because usually what you do is, I spit out this result.

00:24:54,340 --> 00:24:56,620
Mocking in a general way is a challenging problem,

00:24:56,620 --> 00:24:59,720
and I'm not necessarily sure how to fit that into this system.

00:24:59,720 --> 00:25:01,920
And this comes down to: it's not a magic bullet.

00:25:01,929 --> 00:25:03,880
it's a tool in the toolbox.

00:25:03,880 --> 00:25:06,520
Sometimes you can reach for it, sometimes it's hard to reach for it.

00:25:06,520 --> 00:25:08,700
But if you find a way to work with it with mocks,

00:25:08,700 --> 00:25:12,640
please blog about it, share about it, tell people.

00:25:12,640 --> 00:25:14,660
Nice.

00:25:20,860 --> 00:25:22,800
(audience member) If you're testing an API,

00:25:22,800 --> 00:25:26,480
I guess it doesn't matter if you use quickcheck or, like, this tool,

00:25:26,480 --> 00:25:28,720
because you're really -- the language doesn't even matter.

00:25:28,720 --> 00:25:30,980
Is -- am I thinking -- is that correct thinking?

00:25:30,980 --> 00:25:32,720
(Matt Bachmann) You are completely correct.

00:25:32,720 --> 00:25:35,460
If you're comfortable with quickcheck, you can use it to test your API.

00:25:35,460 --> 00:25:37,980
I just know that, you know, people like staying with the language

00:25:37,980 --> 00:25:40,140
they wrote the system in, but there's no --

00:25:40,140 --> 00:25:42,540
if you're doing some like an API test that's actually going over the wire,

00:25:42,549 --> 00:25:45,590
no problem, but you can also imagine --

00:25:45,590 --> 00:25:47,600
this is one case where you could, in theory, generally mock,

00:25:47,600 --> 00:25:49,830
in the sense of don't literally make an API call,

00:25:49,830 --> 00:25:51,980
but just make the mock API call to your system

00:25:51,980 --> 00:25:54,420
which would be easier to do if you stayed in Python.

00:25:55,400 --> 00:25:57,680
(audience member) Hey, thanks so much. This is so cool.

00:25:57,680 --> 00:26:00,460
So I work in education and I feel -- I've been trying to get more testing

00:26:00,460 --> 00:26:03,940
into the university where I work. It's a process.

00:26:03,940 --> 00:26:05,940
So I feel like this has a lot of potential for helping students

00:26:05,940 --> 00:26:08,500
really think about, like, the correctness of their code.

00:26:08,500 --> 00:26:10,420
And I'm really surprised I didn't know about this.

00:26:10,420 --> 00:26:12,300
Can you talk a little bit about the history of this?

00:26:12,300 --> 00:26:14,700
Like, how widely used is this? How new is this?

00:26:14,700 --> 00:26:16,600
(Matt Bachmann) So I'm gonna step a little bit

00:26:16,600 --> 00:26:18,500
out of my knowledge, since I'm fairly new to this stuff as well.

00:26:18,500 --> 00:26:21,020
Just a reminder: I did not write hypothesis.

00:26:21,020 --> 00:26:24,200
But if you go to hypothesis.works, he talks a little bit about this.

00:26:24,200 --> 00:26:26,360
But my understanding is it started originally in the Ha--

00:26:26,360 --> 00:26:29,920
in the functional world with Haskell's quickcheck.

00:26:29,920 --> 00:26:32,960
And that was a situation where that shrinking is very easy to do

00:26:32,960 --> 00:26:35,140
when you have a powerful, strong type system.

00:26:35,140 --> 00:26:37,320
One of the very interesting things about hypothesis

00:26:37,330 --> 00:26:39,770
is that it does the shrinking in Python.

00:26:39,770 --> 00:26:43,190
But it started in the functional world. It's been ported over a lot of places.

00:26:43,190 --> 00:26:45,770
A lot of the success stories you'll see will be in those worlds,

00:26:45,770 --> 00:26:50,630
mostly Haskell, and Erlang, you'll find examples of.

00:26:50,630 --> 00:26:52,740
But as far as, like, other languages,

00:26:52,740 --> 00:26:54,860
like, I have not seen a strong version of Java for this.

00:26:54,860 --> 00:26:57,740
Although, if you're a Java shop that's interested in property-based testing,

00:26:57,750 --> 00:27:00,960
go to his website; he wants someone to pay him to write the Java version.

00:27:00,960 --> 00:27:04,200
He's got a prototype. Plug. Sorry.

00:27:04,200 --> 00:27:06,120
But yeah, that's all I really know.

00:27:06,120 --> 00:27:09,220
It started in the functional world and it sort of went from there.

00:27:12,300 --> 00:27:14,380
(host) Let's see, are there any more questions?

00:27:14,390 --> 00:27:16,380
I think -- I think that's everybody.

00:27:16,380 --> 00:27:18,780
(Matt Bachmann) All right. I survived!

00:27:18,780 --> 00:27:22,220
(host) That was great. I really liked that.

00:27:22,220 --> 00:27:23,920

YouTube URL: https://www.youtube.com/watch?v=jvwfDdgg93E


