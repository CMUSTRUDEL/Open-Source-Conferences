Title: Scott Sanderson, Joe Jevnik - Playing with Python Bytecode - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speakers: Scott Sanderson, Joe Jevnik

Ever wondered what Python is actually doing when it executes your code?  Want to learn to hand-craft artisanal Python bytecode?  In this talk, we explain CPython's internal code representation, and we demonstrate techniques for modifying code objects for fun and profit.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:00,240 --> 00:00:04,780
Welcome. Please help me welcome Scott Sanderson and Joe Jevnik

00:00:04,780 --> 00:00:08,020
for their presentation, Playing with Python Bytecode.

00:00:08,020 --> 00:00:13,580
[applause]

00:00:17,900 --> 00:00:20,080
Hey everybody. Thank you all for coming out today.

00:00:20,080 --> 00:00:23,560
I know you were all really excited to see Scott and Joe come here

00:00:23,560 --> 00:00:25,980
and talk about Playing with Python Bytecode.

00:00:25,980 --> 00:00:28,480
Unfortunately I have a little bit of bad news today.

00:00:28,480 --> 00:00:30,300
Scott and Joe actually couldn't make it.

00:00:30,300 --> 00:00:33,440
They just texted us saying they were involved in a freak scheduling accident.

00:00:33,440 --> 00:00:37,140
But right before they texted us, they also sent us their outline.

00:00:37,140 --> 00:00:40,040
So I know everyone here was really excited to learn about bytecode,

00:00:40,050 --> 00:00:43,470
so I'm going to try to do my best to give the talk in their place.

00:00:43,470 --> 00:00:46,170
So their outline said that they were going to talk about

00:00:46,170 --> 00:00:48,790
CPython's internal code representation.

00:00:48,790 --> 00:00:50,600
They were going to demonstrate some techniques

00:00:50,600 --> 00:00:55,020
for creating code objects from scratch, whatever that means.

00:00:55,020 --> 00:00:58,380
And they were going to show some techniques for manipulating

00:00:58,380 --> 00:01:02,240
and inspecting code objects and making code from new code.

00:01:03,000 --> 00:01:05,020
So I guess if this is going to be a talk, you know,

00:01:05,020 --> 00:01:07,700
about manipulating functions and bytecode at runtime,

00:01:07,700 --> 00:01:10,720
we probably need some functions and bytecode to manipulate.

00:01:10,720 --> 00:01:16,760
So maybe we want to start with, like, a "def add(a, b):".

00:01:16,760 --> 00:01:18,640
And just very simple function.

00:01:18,640 --> 00:01:22,640
We'll "return a + b".

00:01:23,560 --> 00:01:26,220
And we'll just call that and make sure that works.

00:01:27,060 --> 00:01:29,700
All right. So far so good.

00:01:29,700 --> 00:01:31,700
So I guess, you know, we've got a function here

00:01:31,700 --> 00:01:33,760
and we want to somehow get at its bytecode.

00:01:33,760 --> 00:01:36,380
Everything that's sort of secret or interesting in CPython

00:01:36,380 --> 00:01:40,100
starts with a double underscore, so maybe we can try to find that here.

00:01:40,100 --> 00:01:43,980
So we've got __annotations__, __call__,

00:01:43,980 --> 00:01:47,220
__class__, __closure__...

00:01:47,220 --> 00:01:50,680
I don't see anything about bytecode but we got a __code__.

00:01:50,680 --> 00:01:52,600
If I was going to put a code object on a function,

00:01:52,600 --> 00:01:54,520
__code__ is probably where I would put it.

00:01:54,520 --> 00:01:56,400
Right, so we've got a code object.

00:01:56,400 --> 00:01:58,420
So this is code at some memory address.

00:01:58,420 --> 00:02:02,800
It was created by file "<ipython-input-six-gibberish>",

00:02:02,800 --> 00:02:04,720
but we really want -- we want bytecode here.

00:02:04,720 --> 00:02:06,840
So maybe we need to dig a little bit further.

00:02:06,840 --> 00:02:10,100
So, dot -- we've got a whole bunch of attributes here.

00:02:10,100 --> 00:02:12,520
So we've got co_argcount.

00:02:12,520 --> 00:02:15,580
So that's 2, so I guess co_argcount is just the number of arguments

00:02:15,580 --> 00:02:17,500
to this function.

00:02:17,500 --> 00:02:22,460
How about -- let's see, so we've got co_cellvars, co_consts.

00:02:25,900 --> 00:02:28,900
Yeah, well, maybe we'll try to figure out that together here.

00:02:28,900 --> 00:02:33,320
So co_consts on this I guess is just the constant --

00:02:33,320 --> 00:02:35,260
or the tuple containing None.

00:02:35,260 --> 00:02:38,300
So maybe we'll figure out what that means a little bit later.

00:02:38,300 --> 00:02:41,100
Bytecode...hmm...bytecode...

00:02:41,100 --> 00:02:43,740
All right, well, there's a co_code here.

00:02:43,740 --> 00:02:46,080
And if we look at that, this is a byte string.

00:02:46,080 --> 00:02:48,060
So this is co_code. It's a bytes.

00:02:48,060 --> 00:02:50,260
My guess is this is probably the bytecode.

00:02:50,260 --> 00:02:52,500
So I guess the bytecode for add is

00:02:52,500 --> 00:02:56,720
|\x00\x00|\x01\x00\x17S.

00:02:57,540 --> 00:03:00,420
I think that makes sense to everyone, right?

00:03:02,100 --> 00:03:04,540
All right, sweet.

00:03:04,540 --> 00:03:07,160
OK, well, so this is a non-printing string, right?

00:03:07,160 --> 00:03:08,920
There's all these characters we can't see.

00:03:08,920 --> 00:03:10,860
So probably a better way to understand this

00:03:10,860 --> 00:03:13,760
is to just look at the raw integers in that bytes object.

00:03:13,760 --> 00:03:16,000
So, you know, if we do

00:03:16,000 --> 00:03:20,900
"list(add.__code__.co_code)",

00:03:20,900 --> 00:03:23,380
there's definitely a little bit more structure here, right.

00:03:23,380 --> 00:03:29,340
So I've got 124, 0, 0, 124, 1, 0, 23, 83.

00:03:29,340 --> 00:03:32,040
So, you know, there's definitely kind of a repeating pattern here.

00:03:32,040 --> 00:03:35,360
So maybe the first 124 corresponds to the first variable,

00:03:35,360 --> 00:03:37,540
124, 1 corresponds to the second variable,

00:03:37,540 --> 00:03:42,380
and then 23 and 83 definitely means something.

00:03:44,360 --> 00:03:48,460
I was really thinking this might be a little bit easier.

00:03:48,460 --> 00:03:51,180
You know, I've got an idea. We're here. We're at PyCon.

00:03:51,180 --> 00:03:54,260
We're surrounded by some of the best, most knowledgeable programmers

00:03:54,260 --> 00:03:56,180
who know about Python around.

00:03:56,180 --> 00:03:58,180
Surely there's someone here in the audience

00:03:58,180 --> 00:04:00,380
who has worked with bytecode, who understands bytecode,

00:04:00,380 --> 00:04:03,500
who maybe could come up and help me, you know, teach everyone interactively

00:04:03,510 --> 00:04:06,120
about how bytecode is supposed to work, so is there anyone here

00:04:06,120 --> 00:04:09,220
who knows about bytecode or has worked with bytecode?

00:04:09,220 --> 00:04:10,960
(presenter 2) Well, I'm actually

00:04:10,960 --> 00:04:13,640
a PSF-certified bytecode expert.

00:04:13,640 --> 00:04:17,440
[laughter, applause]

00:04:17,440 --> 00:04:19,260
(presenter 1) Well, ladies and gentlemen,

00:04:19,260 --> 00:04:21,799
we have a PSF-certified bytecode expert here among us.

00:04:21,799 --> 00:04:23,949
Come up on stage. Can we get a microphone for him?

00:04:23,949 --> 00:04:25,400
(presenter 2) No need. I brought my own.

00:04:25,400 --> 00:04:27,020
(presenter 1) Wait, you brought your own microphone

00:04:27,020 --> 00:04:28,280
to somebody else's --

00:04:28,280 --> 00:04:29,500
(presenter 2) Let's get back on track here.

00:04:29,500 --> 00:04:31,240
You had the right idea with that code object,

00:04:31,250 --> 00:04:33,680
but you're not going to get very far looking at it that way.

00:04:33,680 --> 00:04:36,380
Luckily, Python provides a module to help look at this.

00:04:36,380 --> 00:04:38,600
Why don't you try "import dis"?

00:04:38,600 --> 00:04:40,620
(presenter 1) OK, "import this"?

00:04:40,620 --> 00:04:42,800
All right, "The Zen of Python, by Tim Peters."

00:04:42,800 --> 00:04:45,760
(presenter 2) No, no, "import dis" with a D.

00:04:45,770 --> 00:04:47,400
It's the disassembly module.

00:04:47,400 --> 00:04:49,920
(presenter 1) Ah, OK. "Import dis".

00:04:49,920 --> 00:04:52,240
All right, I've imported dis. What do I do with dis?

00:04:52,240 --> 00:04:54,620
(presenter 2) We're going to call dis.dis(add).

00:04:54,620 --> 00:04:57,980
(presenter 1) All right, dis.dis(add).

00:04:57,980 --> 00:04:59,640
All right, well, that's definitely way better

00:04:59,640 --> 00:05:01,440
than just that, you know, list of integers.

00:05:01,440 --> 00:05:04,120
Maybe i'll put that back up there so we can see the difference.

00:05:04,120 --> 00:05:06,040
All right, well, can you tell us a little bit more

00:05:06,040 --> 00:05:07,820
about what this this table means?

00:05:07,820 --> 00:05:09,660
(presenter 2) Sure. So, while we have 8 bytes

00:05:09,660 --> 00:05:12,479
in our bytecode, we actually only have four instructions.

00:05:12,479 --> 00:05:17,259
We have a LOAD_FAST, another LOAD_FAST, a BINARY_ADD, and a RETURN_VALUE.

00:05:17,260 --> 00:05:21,040
So the 124, 0, 0 represents that first LOAD_FAST.

00:05:21,050 --> 00:05:24,360
The 124, 1, 0 represents the second LOAD_FAST.

00:05:24,360 --> 00:05:28,680
Then the 23 and 83 are the BINARY_ADD and RETURN_VALUE respectively.

00:05:28,680 --> 00:05:32,620
(presenter 1) OK, so 124, 0, 0 actually means LOAD_FAST.

00:05:32,620 --> 00:05:34,960
Why does LOAD_FAST take up three bytes in the bytecode

00:05:34,960 --> 00:05:37,700
when BINARY_ADD and RETURN_VALUE only take up one?

00:05:37,700 --> 00:05:39,860
(presenter 2) LOAD_FAST says to load a local variable,

00:05:39,860 --> 00:05:42,440
but it needs to know which local variable to load.

00:05:42,440 --> 00:05:44,600
So the second two bytes there are the argument

00:05:44,610 --> 00:05:47,330
which says which local variable we will be loading.

00:05:47,330 --> 00:05:51,910
The 124 is the opcode, and then 0, 0 says "load local variable 0."

00:05:51,910 --> 00:05:55,600
Then we have 124, 1, 0, which says "load local variable 1."

00:05:55,600 --> 00:05:57,160
(presenter 1) Wait, we're loading 1 and 0?

00:05:57,160 --> 00:05:58,680
I thought we wanted to load A and B.

00:05:58,680 --> 00:06:00,840
(presenter 2) Ah, the argument is encoded

00:06:00,849 --> 00:06:03,180
as a 16-bit little endian integer,

00:06:03,180 --> 00:06:06,080
which is an index into an array of local variables.

00:06:06,080 --> 00:06:08,879
So dis helps us out on the right

00:06:08,880 --> 00:06:11,040
by showing the numeric value of that argument,

00:06:11,040 --> 00:06:14,160
but that actually means we're going to load local variable A.

00:06:14,160 --> 00:06:16,659
Then on the second line we will see that the numeric value

00:06:16,659 --> 00:06:20,779
of the argument is 1, but that actually means "load local variable B."

00:06:20,780 --> 00:06:23,940
(presenter 1) OK, so 124, 0, 0

00:06:23,940 --> 00:06:29,200
represents LOAD_FAST of 0, but that actually means LOAD_FAST of A.

00:06:29,200 --> 00:06:32,160
Where exactly are we loading A and B to here?

00:06:32,160 --> 00:06:34,080
(presenter 2) Load instructions load variables

00:06:34,080 --> 00:06:38,220
to a shared stack so that they may be manipulated by other instructions later.

00:06:38,220 --> 00:06:42,040
As we can see, the BINARY_ADD does not have an argument in the bytecode

00:06:42,050 --> 00:06:44,970
because it will just pop the top two values off the stack,

00:06:44,970 --> 00:06:48,280
add them together, and then push the result back onto the stack.

00:06:48,280 --> 00:06:50,280
(presenter 1) OK, let me make sure I understand here.

00:06:50,280 --> 00:06:52,820
At the start of this function we're gonna have an empty stack.

00:06:52,820 --> 00:06:56,040
We're going to do a LOAD_FAST of 0, which pushes A onto the stack.

00:06:56,040 --> 00:06:59,140
Then we're going to do a LOAD_FAST of 1, which pushes B onto the stack.

00:06:59,140 --> 00:07:02,360
We're going to do a BINARY_ADD, which will pop both values off the stack,

00:07:02,360 --> 00:07:05,100
add them together, and push the results back onto the stack.

00:07:05,100 --> 00:07:07,580
And then finally, we're going to execute a return value instruction

00:07:07,580 --> 00:07:09,159
which will pop the top value off the stack

00:07:09,159 --> 00:07:10,839
and return it to the calling stack frame?

00:07:10,840 --> 00:07:12,000
(presenter 2) Exactly.

00:07:12,000 --> 00:07:13,720
(presenter 1) OK, I think I understand

00:07:13,720 --> 00:07:17,160
the right-hand side of this table. How about this set of integers

00:07:17,160 --> 00:07:19,880
running down next to the instruction names? What do those mean?

00:07:19,880 --> 00:07:21,420
(presenter 2) Those are the bytecode offsets

00:07:21,420 --> 00:07:23,140
where those instructions appear.

00:07:23,140 --> 00:07:25,879
So of course, the first instruction starts at index 0.

00:07:25,879 --> 00:07:28,679
However, the second instruction starts at index 3,

00:07:28,680 --> 00:07:32,540
because indices 1 and 2 are occupied by the arguments to our LOAD_FAST.

00:07:32,540 --> 00:07:35,020
(presenter 1) OK, and then BINARY_ADD is at index 6

00:07:35,020 --> 00:07:38,940
because indices 4 and 5 hold the arguments to the second LOAD_FAST.

00:07:39,340 --> 00:07:41,100
OK, I think I understand that.

00:07:41,100 --> 00:07:43,700
What is this "2" up in the top left-hand corner here?

00:07:43,700 --> 00:07:45,520
(presenter 2) That's the line number in our source code

00:07:45,529 --> 00:07:47,280
where these instructions appear.

00:07:47,280 --> 00:07:50,100
This would be a little easier if we tried a function with more than one line.

00:07:50,100 --> 00:07:51,980
(presenter 1) OK, well how about

00:07:51,980 --> 00:07:57,680
just def add_with_assign, and we'll still do A and B.

00:07:57,689 --> 00:08:03,150
But then we'll do X = A + B, and then we'll return X.

00:08:03,150 --> 00:08:07,780
And then we'll do dis.dis(add_with_assign).

00:08:07,780 --> 00:08:10,420
And, OK, so what this says is

00:08:10,430 --> 00:08:13,069
the first four instructions of our code object

00:08:13,069 --> 00:08:16,700
correspond to the second line of our cell, where we're doing X = A + B.

00:08:16,700 --> 00:08:19,300
And the last two instructions of the code object

00:08:19,309 --> 00:08:22,480
correspond to the third line of our cell, where we're doing a return X.

00:08:22,480 --> 00:08:24,360
(presenter 2) Yeah, I think you're getting the hang of this.

00:08:24,360 --> 00:08:27,200
Why don't we try a function that's a little more difficult?

00:08:27,200 --> 00:08:31,780
(presenter 1) OK, maybe like an absolute value function?

00:08:31,789 --> 00:08:35,709
So if we do def abs, take a single argument X,

00:08:35,709 --> 00:08:41,109
and then we'll say, if X is greater than 0, we'll return X.

00:08:41,109 --> 00:08:43,140
Oops, return X.

00:08:43,140 --> 00:08:46,200
Else, we'll return negative X.

00:08:47,200 --> 00:08:51,820
And then we'll do dis.dis(abs).

00:08:51,820 --> 00:08:53,740
It's got a nice ring to it.

00:08:53,740 --> 00:08:55,720
OK, I think I've got this one.

00:08:55,730 --> 00:08:58,410
So at the start of this function, we're going to do a LOAD_FAST of 0,

00:08:58,410 --> 00:09:01,100
but that actually means LOAD_FAST of X.

00:09:01,100 --> 00:09:03,100
Then we're going to do a LOAD_CONST of 1.

00:09:03,100 --> 00:09:05,880
So I guess that means there are different kinds of load instructions.

00:09:05,880 --> 00:09:08,220
We're going to a LOAD_CONST of 1, but that actually means

00:09:08,220 --> 00:09:10,940
"load the constant value 0."

00:09:10,940 --> 00:09:13,139
Then we're going to do a COMPARE_OP of four,

00:09:13,139 --> 00:09:15,379
which means..."greater than"?

00:09:15,380 --> 00:09:18,060
How to CPython know that 4 means "greater than"?

00:09:18,060 --> 00:09:19,780
(presenter 2) Well, not all arguments

00:09:19,780 --> 00:09:21,660
are just some index into some array.

00:09:21,660 --> 00:09:23,680
Here, the argument is actually an enum

00:09:23,680 --> 00:09:26,740
representing which comparison we want to perform.

00:09:26,740 --> 00:09:29,120
So there are entries in this enum for all the comparison operators

00:09:29,120 --> 00:09:31,820
like greater than, less than, or equals.

00:09:31,820 --> 00:09:33,340
(presenter 1) OK, and then after that, we're --

00:09:33,340 --> 00:09:35,020
(presenter 2) How about I take the next instruction?

00:09:35,020 --> 00:09:36,580
It's a little difficult.

00:09:36,580 --> 00:09:39,080
The POP_JUMP_IF_FALSE does exactly what it says it will do.

00:09:39,080 --> 00:09:41,100
It pops the top value off the stack.

00:09:41,100 --> 00:09:43,700
If it's true, it continues execution like normal.

00:09:43,709 --> 00:09:46,561
However, if it's false, it will jump to the bytecode offset

00:09:46,561 --> 00:09:48,561
specified in this argument.

00:09:48,561 --> 00:09:50,420
(presenter 1) OK, so if the result of COMPARE_OP

00:09:50,430 --> 00:09:54,930
is truthy, we're just going to continue executing to the LOAD_FAST at index 12,

00:09:54,930 --> 00:09:58,720
but if it's falsy, we're going to jump to the instruction in index 16.

00:09:58,720 --> 00:10:00,400
(presenter 1) If you see those arrows,

00:10:00,400 --> 00:10:04,440
that's dis's hint to the non-experts that that instruction is a jump target.

00:10:04,440 --> 00:10:05,840
(presenter 2) OK.

00:10:05,840 --> 00:10:07,880
Let me make sure I can walk through this one more time.

00:10:07,880 --> 00:10:09,760
So if X is greater than 0,

00:10:09,760 --> 00:10:11,480
we're going to jump to these two instructions,

00:10:11,480 --> 00:10:13,591
execute a LOAD_FAST and RETURN_VALUE.

00:10:13,600 --> 00:10:16,080
If it's less than 0, then we're going to do a LOAD_FAST,

00:10:16,080 --> 00:10:20,260
then do a UNARY_NEGATIVE to negate X and then return that value.

00:10:20,260 --> 00:10:22,560
It looks like there's two instructions at the bottom of this function

00:10:22,569 --> 00:10:25,000
that can never be hit. Why are those even here?

00:10:25,000 --> 00:10:26,520
(presenter 2) You're right.

00:10:26,520 --> 00:10:28,100
Those instructions are actually dead code.

00:10:28,100 --> 00:10:30,660
CPython has a pretty simple code generation algorithm,

00:10:30,660 --> 00:10:34,079
and one of the rules is that if a function doesn't end in a return statement,

00:10:34,079 --> 00:10:37,379
an implicit "LOAD_CONST of none, RETURN_VALUE" is added.

00:10:37,380 --> 00:10:39,640
So it may appear like this function ends in a return

00:10:39,649 --> 00:10:43,429
because both branches end in a return, from CPython's perspective,

00:10:43,429 --> 00:10:45,570
this function actually ends in an "if" statement.

00:10:45,570 --> 00:10:47,320
So those dummy instructions will be added

00:10:47,320 --> 00:10:49,000
even though they can never be executed.

00:10:49,000 --> 00:10:50,780
(presenter 1) That seems kind of wasteful, don't you think?

00:10:50,780 --> 00:10:52,480
(presenter 2) Well, it's only four bytes,

00:10:52,480 --> 00:10:54,360
which is half a pointer. It's not really worth

00:10:54,360 --> 00:10:57,620
the added complexity to the compiler to remove them.

00:10:57,620 --> 00:10:59,540
(presenter 1) OK, but say we really cared

00:10:59,540 --> 00:11:02,780
about those four bytes. Is there some way that we could remove them?

00:11:02,780 --> 00:11:04,880
(presenter 2) Well, you don't have to use the compiler

00:11:04,880 --> 00:11:06,560
to create a code object.

00:11:06,560 --> 00:11:08,940
You can just create one like any other object in Python.

00:11:08,940 --> 00:11:10,959
(presenter 1) OK, well, let's write our own abs function.

00:11:10,959 --> 00:11:12,399
(presenter 2) Hold on there, killer.

00:11:12,400 --> 00:11:14,360
How about I start you off with a function

00:11:14,360 --> 00:11:16,960
a little more your speed; maybe addone?

00:11:17,360 --> 00:11:19,140
(presenter 1) Yeah, I feel like we could have done

00:11:19,140 --> 00:11:21,260
something a little more complicated than addone, but fine.

00:11:21,260 --> 00:11:23,880
OK, so if we're going to try to write addone,

00:11:23,890 --> 00:11:25,740
we probably should write the Python equivalent

00:11:25,740 --> 00:11:27,520
so we know what we're trying to do.

00:11:27,520 --> 00:11:30,899
So I guess we're going to have addone(X).

00:11:30,899 --> 00:11:36,819
And this will just return X + 1.

00:11:36,820 --> 00:11:40,900
Addone(5) is 6. All right.

00:11:41,460 --> 00:11:44,360
OK, so you just said that I can create a code object

00:11:44,370 --> 00:11:46,420
just like any other Python object.

00:11:46,420 --> 00:11:49,580
And any other Python object I construct by calling its type.

00:11:49,580 --> 00:11:51,880
So where do I find the type for a code object?

00:11:51,880 --> 00:11:53,760
(presenter 2) Ah, that would be the types module.

00:11:53,760 --> 00:11:55,680
(presenter 1) OK, I guess that makes sense.

00:11:56,000 --> 00:11:59,120
And what am I importing from the types module?

00:11:59,120 --> 00:12:02,560
(presenter 2) CodeType. It's the type of code.

00:12:03,720 --> 00:12:07,000
(presenter 1) All right. "from types import CodeType".

00:12:07,000 --> 00:12:09,580
And let's see what the docs say about code types.

00:12:09,580 --> 00:12:14,500
So we'll do "print(CodeType.__doc__)".

00:12:15,300 --> 00:12:18,240
All right. OK, we've got a billion arguments here.

00:12:18,240 --> 00:12:20,120
Argcount, kwonlyargcount...

00:12:20,120 --> 00:12:23,660
All right, "Create a code object. Not for the faint of heart."

00:12:24,140 --> 00:12:26,900
All right, well fortunately for us we've got a bytecode expert here

00:12:26,900 --> 00:12:30,760
to guide us through this, so I guess we'd better get started.

00:12:31,440 --> 00:12:38,580
Well, all right, so we'll do "my_code = CodeType" of --

00:12:38,580 --> 00:12:42,440
well, argcount, that's just 1. We've only got one argument.

00:12:42,440 --> 00:12:46,360
Kwonlyargcount, I guess that's "keyword only argument,"

00:12:46,360 --> 00:12:48,680
so that's probably just 0.

00:12:48,680 --> 00:12:51,460
Nlocals. We've only got one local variable in this function,

00:12:51,460 --> 00:12:54,140
which is X, so that's probably just 1.

00:12:54,140 --> 00:12:56,780
Stacksize. I'm going to throw this over to you, Mr. Bytecode Expert.

00:12:56,780 --> 00:12:58,280
What is stacksize?

00:12:58,280 --> 00:13:00,020
(presenter 2) Stacksize tells Python how much space

00:13:00,029 --> 00:13:02,089
to allocate for variables on the stack.

00:13:02,089 --> 00:13:04,839
So we need enough slots to hold the maximum number of elements

00:13:04,839 --> 00:13:07,539
that will ever appear on the stack at any given time.

00:13:07,540 --> 00:13:09,460
(presenter 1) OK, well, the largest the stack

00:13:09,460 --> 00:13:13,120
is ever going to be in this function is right before we execute the BINARY_ADD,

00:13:13,120 --> 00:13:15,900
when we've got both X and 1 on the stack.

00:13:15,900 --> 00:13:18,140
So the stack size here should be 2.

00:13:18,140 --> 00:13:21,600
All right, next up we've got the flags argument. What are the flags?

00:13:21,600 --> 00:13:23,440
(presenter 2) Flags is a bit mask representing

00:13:23,440 --> 00:13:25,840
a set of various options this code object could have.

00:13:25,840 --> 00:13:28,720
There's a lot of these, so I went ahead and prepared some material ahead of time.

00:13:28,720 --> 00:13:30,040
(presenter 1) Wait, you prepared --

00:13:30,040 --> 00:13:31,360
(presenter 2) Could you be so kind as to hit

00:13:31,360 --> 00:13:32,660
the down arrow on the keyboard?

00:13:32,660 --> 00:13:34,199
(presenter 1) What -- how did you even get these here?

00:13:34,199 --> 00:13:36,179
(presenter 2) Let's get back on track here.

00:13:36,180 --> 00:13:38,460
The first flag here is CO_OPTIMIZED.

00:13:38,460 --> 00:13:40,360
This says that certain optimizations can be made

00:13:40,370 --> 00:13:42,260
when executing this code object.

00:13:42,260 --> 00:13:44,519
In practice, this means that this code object

00:13:44,519 --> 00:13:47,919
comes from a function and not a class body or a module.

00:13:47,920 --> 00:13:49,860
The next flag is CO_NEWLOCALS.

00:13:49,860 --> 00:13:52,319
This says that a new locals dictionary should be created

00:13:52,319 --> 00:13:54,439
every time we execute this code object.

00:13:54,440 --> 00:13:58,020
Again, this just means that it's a function and not a class or a module.

00:13:58,020 --> 00:14:00,340
(presenter 1) OK, I'm guessing that CO_VARARGS

00:14:00,340 --> 00:14:02,240
means we take *args in our function,

00:14:02,240 --> 00:14:05,080
and co var keywords says that we take **kwargs?

00:14:05,080 --> 00:14:06,540
(presenter 2) Exactly.

00:14:06,540 --> 00:14:09,019
The next flag we care about is CO_NOFREE.

00:14:09,019 --> 00:14:12,029
Co nofree says this code object does not share any variables

00:14:12,029 --> 00:14:15,440
with any other code objects through a closure.

00:14:15,440 --> 00:14:17,320
(presenter 1) Al right, and then last up here

00:14:17,320 --> 00:14:19,800
we've got CO_COROUTINE and CO_ITERABLE_COROUTINE.

00:14:19,800 --> 00:14:22,800
What's the difference between a coroutine and an iterable coroutine?

00:14:22,800 --> 00:14:24,920
(presenter 2) These flags were added in Python 3.5

00:14:24,930 --> 00:14:29,230
to support the async def or types.coroutine decorator.

00:14:29,230 --> 00:14:33,050
So CO_COROUTINE is set when a function is declared with async def,

00:14:33,050 --> 00:14:36,620
but ITERABLE_COROUTINE is when a function is an old-style coroutine

00:14:36,629 --> 00:14:38,920
decorated with types.coroutine.

00:14:38,920 --> 00:14:40,400
(presenter 1) All right, well, there were

00:14:40,400 --> 00:14:41,780
definitely a lot of those flags.

00:14:41,780 --> 00:14:43,520
I guess we should try to get back to that original function.

00:14:43,520 --> 00:14:45,080
And there's more flags, OK.

00:14:45,080 --> 00:14:46,760
(presenter 2) These are the flags enabled

00:14:46,760 --> 00:14:49,160
when you do a from __future__ import statement.

00:14:49,160 --> 00:14:51,820
For example, from __future__ import division.

00:14:51,820 --> 00:14:53,900
(presenter 1) OK, I think I've seen ABSOLUTE_IMPORT,

00:14:53,910 --> 00:14:56,510
WITH_STATEMENT, PRINT_FUNCTION, UNICODE_LITERALS...

00:14:56,510 --> 00:14:59,020
What's CO_FUTURE_BARRY_AS_BDFL?

00:14:59,020 --> 00:15:00,820
(presenter 2) Ah, that says that the user

00:15:00,820 --> 00:15:04,040
has enabled enhanced inequality syntax.

00:15:04,040 --> 00:15:06,080
(presenter 1) Naturally. Okay, well I --

00:15:06,080 --> 00:15:09,060
all right, I've got to imagine that's the last of the flags.

00:15:09,060 --> 00:15:11,019
So can we just get back to that function that I was running?

00:15:11,019 --> 00:15:12,299
Why did you reformat all of this?

00:15:12,300 --> 00:15:13,780
(presenter 2) You'll see, I've selected the flags

00:15:13,780 --> 00:15:17,400
that we need here: CO_OPTIMIZED, CO_NEWLOCALS, and CO_NOFREE.

00:15:17,400 --> 00:15:19,140
(presenter 1) I am so changing all of my passwords

00:15:19,140 --> 00:15:21,100
when this is over.

00:15:21,100 --> 00:15:23,860
OK, so we've done argcount, kwonlyargcount,

00:15:23,860 --> 00:15:26,340
nlocals, stacksize, flags.

00:15:26,340 --> 00:15:29,440
Next up is codestring, and I don't see anything else about bytecode,

00:15:29,440 --> 00:15:32,500
so I'm guessing this is our main event. So we're going to want a "bytes,"

00:15:32,500 --> 00:15:35,900
and then probably it's easiest to just write these as integers.

00:15:35,900 --> 00:15:38,320
So we need the actual op codes for our bytecode.

00:15:38,320 --> 00:15:39,800
So what do we need here?

00:15:39,800 --> 00:15:43,360
(presenter 2) Ah, we will need 124, 0, 0,

00:15:43,360 --> 00:15:47,880
100, 0, 0, 23 83.

00:15:48,560 --> 00:15:51,880
[laughter]

00:15:51,880 --> 00:15:53,510
(presenter 1) Care to explain any of that

00:15:53,510 --> 00:15:54,900
for the rest of us here?

00:15:54,900 --> 00:15:56,920
(presenter 2) Yes, what this function needs to do

00:15:56,930 --> 00:16:00,450
is load X onto the stack, then load 1 onto the stack,

00:16:00,450 --> 00:16:02,650
perform a BINARY_ADD to add them together,

00:16:02,650 --> 00:16:05,450
and then a RETURN_VALUE to return this value to the caller.

00:16:05,450 --> 00:16:09,720
So we start with 124, which is the opcode for the LOAD_FAST instruction.

00:16:09,730 --> 00:16:13,240
We only have one local variable, so we can store it at index 0.

00:16:13,240 --> 00:16:17,600
Next, we will emit 100, which is the opcode for the LOAD_CONST instruction.

00:16:17,600 --> 00:16:20,960
We only have one constant, so we can store that in index 0.

00:16:20,960 --> 00:16:23,240
Finally, we have 23 and 83,

00:16:23,250 --> 00:16:27,340
which are the opcodes for BINARY_ADD and RETURN_VALUE, as we saw earlier.

00:16:27,340 --> 00:16:29,620
(presenter 1) OK, I guess that's not that bad.

00:16:29,620 --> 00:16:31,900
All right, next up we've got constants.

00:16:31,900 --> 00:16:34,080
Well, you just said we're only going to have one constant,

00:16:34,089 --> 00:16:37,669
so this is just the tuple containing 1 for our addone.

00:16:37,669 --> 00:16:39,969
Now we've got names and varnames.

00:16:39,969 --> 00:16:42,440
What's the difference between a name and a varname?

00:16:42,440 --> 00:16:44,420
(presenter 2) Names is a tuple containing the names

00:16:44,420 --> 00:16:48,000
of any global variables or attributes that will be referenced in this function.

00:16:48,000 --> 00:16:50,320
Since we don't have any, we can just use an empty tuple.

00:16:50,320 --> 00:16:52,580
(presenter 1) All right, one empty tuple coming right up.

00:16:52,589 --> 00:16:54,249
(presenter 2) The varnames are the names

00:16:54,249 --> 00:16:55,920
of all of the local variables of this function.

00:16:55,930 --> 00:16:58,540
So this can just be the tuple containing the string X.

00:16:58,540 --> 00:17:01,340
(presenter 1) All right, got a tuple containing X.

00:17:01,340 --> 00:17:03,020
(presenter 2) The next four arguments

00:17:03,020 --> 00:17:06,060
don't really mean much if we create a code object from scratch like this.

00:17:06,060 --> 00:17:10,180
So the filename is the name of the file of source where this function came from.

00:17:10,180 --> 00:17:12,940
We don't have one so you can pick your favorite string.

00:17:12,940 --> 00:17:16,000
Next is the name, which is the name of this code object.

00:17:16,000 --> 00:17:18,330
This should just be addone.

00:17:18,330 --> 00:17:20,780
Then we have the firstlineno, which is the first line

00:17:20,780 --> 00:17:23,380
in the source file where this code object appears.

00:17:23,380 --> 00:17:25,620
This can just be your favorite integer.

00:17:25,620 --> 00:17:29,340
Finally we have the lnotab, which stands for the line number table.

00:17:29,340 --> 00:17:31,620
This is a mapping between bytecode offsets

00:17:31,620 --> 00:17:33,550
to line offsets in the file.

00:17:33,550 --> 00:17:36,280
We don't have any lines, so this should just be an empty bytes object.

00:17:36,280 --> 00:17:38,380
(presenter 1) All right, I can do that.

00:17:38,380 --> 00:17:44,100
All right, and then last but not least, we've got the freevars and cellvars.

00:17:44,100 --> 00:17:45,940
(presenter 2) these are the names of any variables

00:17:45,940 --> 00:17:48,180
that we share with other code objects through a closure.

00:17:48,180 --> 00:17:50,980
Because we don't share any variables and we set CO_NOFREE,

00:17:50,980 --> 00:17:52,620
these both better be empty.

00:17:52,620 --> 00:17:54,660
(presenter 1) All right, two more empty tuples.

00:17:54,660 --> 00:17:56,520
All right. So that's all the arguments.

00:17:56,520 --> 00:17:58,900
So I guess if we make -- if we call this thing,

00:17:58,900 --> 00:18:01,980
then we should have ourselves some executable code.

00:18:01,980 --> 00:18:04,440
All right, that didn't crash, so I guess we should try it, right?

00:18:04,440 --> 00:18:09,820
My_code(5), and this should give us -- hey, what gives?

00:18:09,830 --> 00:18:11,840
I thought you said you were some kind of bytecode expert.

00:18:11,840 --> 00:18:13,740
(presenter 2) We don't normally call code objects,

00:18:13,740 --> 00:18:17,200
do we? No, we work with function objects.

00:18:17,720 --> 00:18:20,080
(presenter 1) OK, well, I bet you I know

00:18:20,080 --> 00:18:22,590
what you're going to say next is that I can make a function object

00:18:22,590 --> 00:18:26,850
just like any other type in Python, which means I need to call its type,

00:18:26,850 --> 00:18:30,140
which means I need to get FunctionType.

00:18:30,140 --> 00:18:35,080
So "from types import FunctionType".

00:18:35,080 --> 00:18:37,580
All right, well, that worked well enough.

00:18:37,580 --> 00:18:40,820
Let's see what the docs say about FunctionType.

00:18:40,820 --> 00:18:44,420
FunctionType.__doc__.

00:18:44,940 --> 00:18:46,900
This is way easier than the code object.

00:18:46,900 --> 00:18:50,800
So this says, "Create a function object from a code object and a dictionary."

00:18:50,800 --> 00:18:53,520
Well, I've got a code object and I know how to make a dictionary,

00:18:53,520 --> 00:18:55,480
so I think we've got this one.

00:18:55,480 --> 00:19:04,480
All right, so I can do my_addone = FunctionType(my_code

00:19:04,480 --> 00:19:06,380
and an empty dict.

00:19:07,040 --> 00:19:09,120
All right, that didn't crash.

00:19:09,120 --> 00:19:14,460
All right moment of truth: my_addone(5)... gives me 6!

00:19:14,460 --> 00:19:20,300
[applause]

00:19:20,300 --> 00:19:23,140
All right, I guess we don't even need the CPython compiler anymore.

00:19:23,140 --> 00:19:26,200
But I suppose we should see if we generated the same thing.

00:19:26,210 --> 00:19:29,750
So let's do dis.dis(addone),

00:19:29,750 --> 00:19:33,460
and then we'll just print a separator to --

00:19:33,460 --> 00:19:36,000
the addone here is CPython's version

00:19:36,000 --> 00:19:40,440
and then I'll do dis.dis(my_addone) so we can see the difference.

00:19:40,440 --> 00:19:44,600
All right, well, LOAD_FAST, LOAD_CONST, BINARY_ADD, RETURN_VALUE.

00:19:44,600 --> 00:19:46,380
LOAD_FAST, LOAD_CONST, BINARY_ADD, RETURN_VALUE.

00:19:46,380 --> 00:19:49,340
Other than those nonsense line numbers, I think we've got exactly the same thing.

00:19:49,340 --> 00:19:50,980
(presenter 2) Well, not quite.

00:19:50,980 --> 00:19:53,340
You'll notice ours has a LOAD_CONST of 0

00:19:53,340 --> 00:19:56,540
but the compiler gave us a LOAD_CONST of 1.

00:19:56,540 --> 00:19:58,660
(presenter 1) Hey yeah, that's kind of interesting.

00:19:58,669 --> 00:20:01,989
Why is C python's version doing a LOAD_CONST of 1?

00:20:01,989 --> 00:20:11,949
All right, well we'll do print(my_addone.__code.__c_consts).

00:20:11,949 --> 00:20:14,059
That's just our tuple containing 1. That's what we should expect.

00:20:14,059 --> 00:20:16,159
What did C Python generate?

00:20:17,120 --> 00:20:21,900
print(addone.__code__.co_consts).

00:20:21,900 --> 00:20:25,220
We got None -- why is None in the co_consts from C Python?

00:20:25,220 --> 00:20:26,960
Nothing uses None here.

00:20:26,960 --> 00:20:28,980
(presenter 2) That's just a quirk of the compiler.

00:20:28,980 --> 00:20:32,280
None will always be at index 0 for the co_consts.

00:20:32,280 --> 00:20:34,040
(presenter 1) Wait, so are you saying

00:20:34,040 --> 00:20:37,000
that our handcrafted artisanal organic bytecode

00:20:37,000 --> 00:20:40,360
is actually more sleek and optimized than what C Python generates?

00:20:40,360 --> 00:20:42,760
(presenter 2) In a way that does not matter at all.

00:20:42,770 --> 00:20:45,330
[laughter]

00:20:46,000 --> 00:20:47,720
(presenter 1) I don't know. That None,

00:20:47,720 --> 00:20:50,900
that could be the difference. OK, we -- wait a second.

00:20:50,909 --> 00:20:55,620
So if CPython is just looking up values out of this constants tuple,

00:20:55,620 --> 00:20:58,060
does that mean I can just switch that out on a function

00:20:58,060 --> 00:20:59,940
and change its behavior?

00:20:59,940 --> 00:21:09,100
What happens if I do my_addone.__code__.co_consts = (2,)?

00:21:09,100 --> 00:21:12,020
Can I change my_addone into my_add -- oh, man.

00:21:12,020 --> 00:21:13,740
(presenter 2) Luckily, Python blocks

00:21:13,740 --> 00:21:15,500
these kinds of shenanigans.

00:21:15,500 --> 00:21:17,540
If you were able to execute that line,

00:21:17,540 --> 00:21:21,800
anyone who had a reference to my_addone just got a reference to my_addtwo.

00:21:21,800 --> 00:21:23,680
(presenter 1) My_addtwo sounds great.

00:21:23,680 --> 00:21:25,620
I don't know why you wouldn't want that.

00:21:25,620 --> 00:21:28,560
Actually, I guess I can imagine some scenarios where you might want,

00:21:28,570 --> 00:21:30,310
you know, numbers to stay the same.

00:21:30,310 --> 00:21:33,980
OK, so if mutating code objects in place is a bad idea,

00:21:33,989 --> 00:21:36,340
does that mean there's no way for us to take a code object

00:21:36,340 --> 00:21:38,000
and turn it into something else?

00:21:38,000 --> 00:21:39,940
(presenter 2) Well, we can't mutate it in place,

00:21:39,940 --> 00:21:41,980
but we can always just make a new code object

00:21:41,980 --> 00:21:44,000
by copying all the attributes off our old one

00:21:44,010 --> 00:21:45,920
and changing any parameters.

00:21:45,920 --> 00:21:48,180
(presenter 1) OK, so you're saying that what we need

00:21:48,180 --> 00:21:54,160
is like a function that performs a functional update on a function.

00:21:54,960 --> 00:21:56,760
All right, I think I can write that.

00:21:56,760 --> 00:21:58,180
(presenter 2) I also went ahead

00:21:58,180 --> 00:21:59,580
and wrote this one for you.

00:21:59,580 --> 00:22:02,600
It's a little complicated, you know. Save some time.

00:22:02,600 --> 00:22:04,460
(presenter 1) All right, so what you're saying

00:22:04,460 --> 00:22:08,800
this function does is it takes a function f and **kwds,

00:22:08,800 --> 00:22:11,600
and what it does is grab the code off of the old f

00:22:11,610 --> 00:22:13,500
and then constructs a new code object

00:22:13,500 --> 00:22:16,140
by copying all the attributes from the old code object

00:22:16,140 --> 00:22:19,440
but overriding any attributes that were passed into this,

00:22:19,440 --> 00:22:21,780
and then wrapping that up in a new FunctionType

00:22:21,789 --> 00:22:24,280
with all the other attributes of the function copy.

00:22:24,280 --> 00:22:28,100
So that means that I should be able to do update of --

00:22:28,100 --> 00:22:30,740
Let me make sure I executed that.

00:22:31,780 --> 00:22:33,560
All right, you're saying that this means I should be able

00:22:33,560 --> 00:22:40,720
to do update(my_addone, co_consts = (2,)_,

00:22:40,720 --> 00:22:44,260
And this should give me a new function that instead of adding 1 adds 2.

00:22:44,260 --> 00:22:47,380
So this will be my_addtwo.

00:22:47,380 --> 00:22:49,360
All right, still didn't crash.

00:22:49,360 --> 00:22:54,180
My_addtwo(5). Bam, we get 7!

00:22:54,180 --> 00:22:59,380
[applause]

00:22:59,380 --> 00:23:02,400
I guess we're all well on our way to becoming bytecode experts too.

00:23:02,400 --> 00:23:04,360
(presenter 2) You know, that that's cute and all,

00:23:04,360 --> 00:23:06,760
but you'll only get so far updating the metadata.

00:23:06,760 --> 00:23:09,220
The real meat is in that bytecode.

00:23:09,220 --> 00:23:10,760
(presenter 1) OK, well,

00:23:10,760 --> 00:23:13,320
co_code is just another attribute of the bytecode, right?

00:23:13,320 --> 00:23:16,800
If I can update co_consts, I can just as well update co_code.

00:23:16,800 --> 00:23:18,520
(presenter 2) Now you're cooking with gas!

00:23:18,520 --> 00:23:21,400
Why don't we write a function that updates all the 23s with 20

00:23:21,400 --> 00:23:22,920
in that co_code?

00:23:22,920 --> 00:23:25,060
(presenter 1) Wait, 23s and 20s?

00:23:25,060 --> 00:23:28,200
(presenter 2) Oh, BINARY_ADD and BINARY_MULTIPLY.

00:23:29,560 --> 00:23:31,220
(presenter 1) OK, so you're saying

00:23:31,220 --> 00:23:36,700
that what we should write is like def add_to_mul

00:23:36,700 --> 00:23:40,360
that's going to take a function and then it will grab its __code__.

00:23:40,360 --> 00:23:44,900
So we'll do old = f.__code__.co_code.

00:23:44,900 --> 00:23:46,940
And then we want to do is take this bytes object

00:23:46,940 --> 00:23:50,060
and replace all the 23 bytes with 20s, which should replace

00:23:50,060 --> 00:23:53,120
all the binary add instructions with binary multiplies.

00:23:53,130 --> 00:23:57,340
So we'll do new = old.replace,

00:23:57,340 --> 00:24:03,880
and we'll do bytes([23]) and then bytes([20]).

00:24:04,560 --> 00:24:07,320
And then finally I'm going to take that bytes object

00:24:07,320 --> 00:24:09,100
and wrap it back up in a new function.

00:24:09,100 --> 00:24:16,500
So I'm going to return update(f, co_code=new).

00:24:16,500 --> 00:24:26,940
And then if I do add_to_mul(my_addtwo),

00:24:26,940 --> 00:24:31,060
we didn't change the name, but if I do add_to_mul(my_addtwo),

00:24:31,060 --> 00:24:33,720
then I should get my_multwo.

00:24:35,240 --> 00:24:38,360
And if I call my_multwo --

00:24:38,360 --> 00:24:42,060
move that up a little bit -- of 5, I get 10.

00:24:42,060 --> 00:24:46,240
[applause]

00:24:46,240 --> 00:24:48,360
(presenter 2) See, bytecode hacking isn't so hard

00:24:48,360 --> 00:24:50,260
when you know how everything works.

00:24:50,260 --> 00:24:52,820
[laughter]

00:24:55,660 --> 00:24:58,860
(presenter 1) You know, I think there's actually a bug

00:24:58,860 --> 00:25:00,779
in this generation algorithm you gave me.

00:25:00,779 --> 00:25:02,419
(presenter 2) No I don't write bugs.

00:25:02,420 --> 00:25:04,220
How could there be a bug?

00:25:04,220 --> 00:25:07,100
All we did was replace the binary adds with binary multiplies.

00:25:07,100 --> 00:25:08,700
(presenter 1) Well, no,

00:25:08,700 --> 00:25:11,580
we replaced all the 23s with 20s,

00:25:11,580 --> 00:25:15,460
and you told me not a moment ago that not all the instructions

00:25:15,470 --> 00:25:19,250
in the byte -- er, not all the bytes in the bytecode are instructions.

00:25:19,250 --> 00:25:21,020
Some of them are arguments.

00:25:21,020 --> 00:25:24,920
(presenter 2) Yeah, but I mean, 23 means add, like --

00:25:24,920 --> 00:25:28,460
23 is never going to be an argument...

00:25:29,860 --> 00:25:31,460
...right?

00:25:31,740 --> 00:25:34,120
(presenter 1) Well, what if we had a function

00:25:34,120 --> 00:25:35,960
that had 23 local variables?

00:25:35,960 --> 00:25:37,340
(presenter 2) No one's going to write a function

00:25:37,340 --> 00:25:38,700
with 23 local variables.

00:25:38,710 --> 00:25:40,180
(presenter 1) Well, now that you mention it,

00:25:40,180 --> 00:25:41,660
I actually have a function --

00:25:41,660 --> 00:25:46,900
[laughter and applause]

00:25:46,900 --> 00:25:51,940
I actually have a function right here that takes 26 local variables.

00:25:51,940 --> 00:25:54,080
So this is my get_x function.

00:25:54,080 --> 00:25:57,840
And, you know, you can pass it all the alphabet and it returns X.

00:25:57,840 --> 00:26:00,880
And X, in case you haven't noticed, is the 23rd letter of the alphabet.

00:26:00,880 --> 00:26:08,100
So if I do get_x(*ascii_lowercase), which is just all the lower case letters,

00:26:08,100 --> 00:26:09,980
then I get x.

00:26:10,780 --> 00:26:12,920
And I'm not doing any addition or multiplication

00:26:12,929 --> 00:26:15,669
or any fancy math stuff here, I'm just returning a value here.

00:26:15,669 --> 00:26:19,440
So add_to_mul should just be a null op on get_x, right?

00:26:19,440 --> 00:26:20,920
(presenter 2) Yeah...

00:26:20,920 --> 00:26:22,460
[laughter]

00:26:22,460 --> 00:26:24,140
(presenter 1) But add_to_mul is going to replace

00:26:24,140 --> 00:26:26,460
all the 23s with 20s, which means

00:26:26,460 --> 00:26:29,460
instead of loading the local variable at index 23,

00:26:29,470 --> 00:26:31,980
I'm going to load the local variable index 20.

00:26:31,980 --> 00:26:36,780
And that means that add_to_mul(get_x)

00:26:36,780 --> 00:26:39,240
is going to turn it into get_u.

00:26:41,640 --> 00:26:49,380
[laughter, applause]

00:26:49,380 --> 00:26:52,210
And you know, now that I think about it, this actually could have been a lot worse.

00:26:52,210 --> 00:26:54,590
I mean, at least there was a local variable at index 20

00:26:54,590 --> 00:26:57,320
for us to load here, right? I mean, what would have happened

00:26:57,320 --> 00:26:59,950
if we had, you know, swapped out the index entirely

00:26:59,950 --> 00:27:02,270
so that it wasn't even a valid value in range?

00:27:02,270 --> 00:27:07,980
Like, say we did update(my_addone),

00:27:07,980 --> 00:27:11,720
and we just did co_consts = an empty tuple.

00:27:11,720 --> 00:27:16,780
That would turn my_addone into some sort of, like... baddone.

00:27:17,900 --> 00:27:21,220
And if I do baddone(5)...

00:27:22,740 --> 00:27:24,320
Ooh.

00:27:24,320 --> 00:27:31,500
[laughter, applause]

00:27:31,500 --> 00:27:33,280
(presenter 2) I think you segfaulted

00:27:33,280 --> 00:27:35,140
the interpreter there.

00:27:35,140 --> 00:27:36,920
Oh, you know, now that I think about it,

00:27:36,920 --> 00:27:39,480
I think this bug also manifests in those jumps.

00:27:39,480 --> 00:27:42,620
You know, we were just going to jump to the bytecode offset in that argument,

00:27:42,620 --> 00:27:46,020
but if that wasn't a valid instruction or out of range entirely,

00:27:46,030 --> 00:27:47,860
like, who knows what would happen?

00:27:47,860 --> 00:27:49,720
(presenter 1) Yeah, and now that I think about jumps

00:27:49,720 --> 00:27:52,260
a little bit more, those jumps are just, you know,

00:27:52,260 --> 00:27:54,520
going to some particular offset into the bytecode,

00:27:54,529 --> 00:27:57,730
which means we could never insert or delete any instructions.

00:27:57,730 --> 00:28:00,600
We would change all those jump offsets. They would never work, right?

00:28:00,600 --> 00:28:02,120
(presenter 2) Yeah, we would need some way

00:28:02,120 --> 00:28:03,680
to recalculate all those jump offsets.

00:28:03,680 --> 00:28:05,180
(presenter 1) That seems like a lot of work.

00:28:05,180 --> 00:28:06,600
(presenter 2) Yeah.

00:28:06,600 --> 00:28:08,300
(presenter 1) Hmm, this bytecode hacking thing

00:28:08,300 --> 00:28:10,160
feels harder than I thought.

00:28:10,160 --> 00:28:12,140
(presenter 2) Didn't you say earlier that Joe and Scott

00:28:12,140 --> 00:28:13,980
had worked on a library to help with some of this?

00:28:13,980 --> 00:28:15,540
(presenter 1) Oh yeah, codetransformer.

00:28:15,540 --> 00:28:17,279
I actually downloaded it right before the talk.

00:28:17,279 --> 00:28:19,250
I was thinking, you know, maybe if we got far enough

00:28:19,250 --> 00:28:20,760
we could look at it a little bit.

00:28:20,760 --> 00:28:24,680
Maybe they've got some ideas for how to solve some of these problems.

00:28:24,690 --> 00:28:30,870
So let's do from codetransformer. --

00:28:30,870 --> 00:28:33,830
all right, what do we got here? Code, CodeTransformer --

00:28:33,830 --> 00:28:36,490
I guess that makes sense, there's a CodeTransformer class --

00:28:36,490 --> 00:28:41,710
decompiler, display, instructions, option, patterns, tests --

00:28:41,710 --> 00:28:46,700
they've got tests -- they've got transformers, import --

00:28:46,700 --> 00:28:49,029
Joe and Scott imported -- er, implemented add2mul.

00:28:49,029 --> 00:28:51,640
I guess great minds really do think alike.

00:28:51,640 --> 00:28:53,860
All right, well let's see what's in add2mul here.

00:28:53,870 --> 00:28:56,340
Add2mul. Oh, it's a module.

00:28:56,340 --> 00:29:00,220
So I guess we should probably go try to look at the source for this.

00:29:00,220 --> 00:29:02,059
OK, well, add2mul.

00:29:02,059 --> 00:29:05,559
So add2mul is "a transformer that replaces BINARY_ADD instructions

00:29:05,559 --> 00:29:07,899
"with BINARY_MULTIPLY instructions."

00:29:07,900 --> 00:29:09,780
And it looks like what's happening here is

00:29:09,780 --> 00:29:14,140
we're doing from codetransformer, import CodeTransformer, and pattern.

00:29:14,140 --> 00:29:16,600
And then from codetransformer.instructions,

00:29:16,600 --> 00:29:19,000
we're importing BINARY_ADD and BINARY_MULTIPLY.

00:29:19,010 --> 00:29:22,130
So there must be some sort of instruction objects being used here.

00:29:22,130 --> 00:29:24,110
That that seems a lot nicer than just memorizing

00:29:24,110 --> 00:29:26,010
23 and 20 all over the place, right?

00:29:26,010 --> 00:29:27,760
(presenter 2) Maybe.

00:29:27,760 --> 00:29:29,480
(presenter 1) OK, and then we're going to make

00:29:29,480 --> 00:29:31,340
a CodeTransformer class.

00:29:31,340 --> 00:29:33,580
And we've got a method decorated with a pattern.

00:29:33,580 --> 00:29:35,420
So it looks like what's happening here is

00:29:35,420 --> 00:29:38,420
we're specifying patterns of instructions to match,

00:29:38,420 --> 00:29:42,540
and then we write generators that yield replacements for those instructions.

00:29:42,540 --> 00:29:46,420
So here what's happening is we're saying "Match the pattern BINARY_ADD,"

00:29:46,420 --> 00:29:48,140
and whenever we see that pattern,

00:29:48,140 --> 00:29:51,340
just yield a BINARY_MULTIPLY as a replacement for it.

00:29:51,340 --> 00:29:53,100
(presenter 2) What's that steal method do?

00:29:53,100 --> 00:29:54,660
(presenter 1) Well, let's see.

00:29:54,660 --> 00:29:57,180
Through the magic of Emacs, we can find out.

00:29:57,180 --> 00:30:00,440
Steal says "Steal the jump index off of 'instr'.

00:30:00,440 --> 00:30:02,600
"This makes anything that would have jumped to 'instr'

00:30:02,600 --> 00:30:04,440
"jump to this Instruction instead."

00:30:04,440 --> 00:30:06,980
So I guess this is some technique for dealing with some of those

00:30:06,980 --> 00:30:09,160
jump resolution issues that we thought about a moment ago.

00:30:09,160 --> 00:30:10,600
(presenter 2) Yeah, that sounds a lot nicer.

00:30:10,600 --> 00:30:11,600
(presenter 1) Yeah.

00:30:11,600 --> 00:30:12,600
(presenter 2) You know,

00:30:12,600 --> 00:30:16,460
we built some interesting tools today, but they weren't particularly useful.

00:30:16,460 --> 00:30:20,240
Maybe there are some useful tools built into CodeTransformer itself.

00:30:20,240 --> 00:30:22,180
(presenter 1) Well, let's see what we've got here.

00:30:22,180 --> 00:30:24,220
So we've got transformers import.

00:30:24,220 --> 00:30:27,980
We've got asconstants, bytearray_literals, decimal_literals,

00:30:27,980 --> 00:30:30,500
frozenset, interpolated_strings.

00:30:30,500 --> 00:30:33,820
How about ordereddict_literarls? That sounds kind of interesting.

00:30:33,820 --> 00:30:35,740
So I think I actually read in the documentation

00:30:35,750 --> 00:30:37,540
that these are supposed to be used as decorators.

00:30:37,540 --> 00:30:42,640
So if I do @ordereddict_literals, and then I do def make_dict,

00:30:42,640 --> 00:30:45,080
let's say take A, B, C,

00:30:45,080 --> 00:30:51,320
and then we'll do return 'A' mapped to A,

00:30:51,320 --> 00:30:55,820
and 'B' maps to B, and 'C' maps to C.

00:30:55,830 --> 00:31:01,920
All right, and then if I call this, do make_dict(1, 2, 3)...

00:31:01,920 --> 00:31:04,900
hey, look at that. I get an ordered dict instead of a regular dict.

00:31:04,900 --> 00:31:06,640
That's pretty neat.

00:31:07,700 --> 00:31:11,760
All right, let's see if we can find one more to go through here.

00:31:11,760 --> 00:31:13,200
Whoops.

00:31:13,200 --> 00:31:16,400
We've got haskell_strs... all right, interpolated_strings.

00:31:16,400 --> 00:31:18,580
I think this is for those of us who were too impatient

00:31:18,580 --> 00:31:22,580
to wait for the new f-strings feature in Python 3.6.

00:31:22,580 --> 00:31:28,460
So if I do @interpolated_strings and I do def inter,

00:31:28,460 --> 00:31:34,560
say we'll take an A and a B, and we'll just return a bytes.

00:31:35,280 --> 00:31:39,880
That returns A and B.

00:31:40,400 --> 00:31:42,260
And if you're used to something like Ruby

00:31:42,260 --> 00:31:44,000
or languages that do string interpolation,

00:31:44,000 --> 00:31:48,520
I think what should happen here is, if I call that with 1, 2,

00:31:48,520 --> 00:31:51,600
it just magically gets interpolated into my string.

00:31:53,720 --> 00:31:56,900
[laughter]

00:31:56,900 --> 00:31:59,800
So, I mean, I guess there -- maybe there are some, you know,

00:31:59,800 --> 00:32:02,940
non-insane uses for this.

00:32:02,940 --> 00:32:06,540
But I actually think that's just about all the time we have here.

00:32:06,549 --> 00:32:10,770
So to recap a little bit, you know, I know you guys were all really excited

00:32:10,770 --> 00:32:14,470
to see Joe and Scott come out and talk about bytecode here today.

00:32:14,470 --> 00:32:17,880
But I hope, you know, thank you to my bytecode expert friend

00:32:17,890 --> 00:32:21,290
for coming up on short notice with no planning whatsoever.

00:32:21,290 --> 00:32:23,220
[laughter]

00:32:23,220 --> 00:32:26,460
And just to recap a little bit what we talked about today,

00:32:26,460 --> 00:32:29,540
we looked at CPython's internal code representation.

00:32:29,540 --> 00:32:32,920
We saw some techniques for constructing code objects from scratch.

00:32:32,920 --> 00:32:35,400
We looked at various ways that we could swap out attributes

00:32:35,409 --> 00:32:37,469
of code objects to change their behavior.

00:32:37,469 --> 00:32:39,940
But we also saw a lot of the dangers of, you know, playing God

00:32:39,940 --> 00:32:42,520
with the CPython compiler for ourselves.

00:32:42,520 --> 00:32:44,560
And maybe at the end here we saw a few techniques

00:32:44,570 --> 00:32:47,350
for trying to mitigate some of those dangers.

00:32:47,350 --> 00:32:49,700
But yeah, again, I want to thank you all for coming out here.

00:32:49,700 --> 00:32:51,800
I hope you all have a great PyCon.

00:32:51,800 --> 00:33:06,060
[applause]

00:33:06,060 --> 00:33:10,440
So in case you guys haven't figured it out by now, I'm Scott.

00:33:10,440 --> 00:33:12,640
(presenter 2) I'm Joe.

00:33:12,640 --> 00:33:15,540
(Scott Sanderson) We wrote a library called codetransformer

00:33:15,540 --> 00:33:18,280
that's for doing this kind of bytecode manipulation.

00:33:18,280 --> 00:33:21,500
We think it's kind of a silly and whimsical talk -- er, topic,

00:33:21,500 --> 00:33:24,080
so we wanted to do a sort of silly and whimsical talk

00:33:24,080 --> 00:33:26,140
that went with that theme.

00:33:26,140 --> 00:33:28,300
In real life when we're not doing things like this,

00:33:28,300 --> 00:33:30,240
we work at a company called Quantopian

00:33:30,240 --> 00:33:34,340
that builds tools for people who do algorithmic trading in Python.

00:33:34,340 --> 00:33:36,700
We do not use any of the techniques that you just saw there

00:33:36,700 --> 00:33:38,200
to trade other people's money.

00:33:38,200 --> 00:33:39,721
(Joe Jevnik) Or anywhere else on the platform,

00:33:39,721 --> 00:33:41,360
for that matter.

00:33:41,360 --> 00:33:43,200
(Scott Sanderson) You can find us both on GitHub.

00:33:43,210 --> 00:33:45,500
I'm github.com/ssanderson.

00:33:45,500 --> 00:33:47,180
(Joe Jevnik) And I'm a barcode.

00:33:47,180 --> 00:33:49,040
(Scott Sanderson) What Joe means by that is

00:33:49,040 --> 00:33:51,080
he's github.com slash ten lowercase L's.

00:33:51,080 --> 00:33:52,560
[laughter]

00:33:52,560 --> 00:33:56,440
And on Twitter you can again find me at the reasonable name of @ssanderson.

00:33:56,440 --> 00:33:58,960
(Joe Jevnik) And I'm @__qualname__.

00:33:58,960 --> 00:34:00,880
(Scott Sanderson) So if we've got time to do questions,

00:34:00,890 --> 00:34:03,470
we'd be happy to take questions in whatever time we've got left.

00:34:03,470 --> 00:34:05,440
(host) Absolutely. Please raise your hand

00:34:05,440 --> 00:34:07,520
if you'd like to ask a question.

00:34:08,920 --> 00:34:10,960
(Scott Sanderson) We've got one down in the front here.

00:34:15,600 --> 00:34:18,300
(audience member) Hi, thanks for the awesome talk.

00:34:18,300 --> 00:34:20,140
Well, I have two questions.

00:34:20,140 --> 00:34:24,240
The first is, you said that this is only CPython-specific.

00:34:24,240 --> 00:34:28,000
Is this the Python's model of [indistinct]?

00:34:28,000 --> 00:34:30,339
(Scott Sanderson) No, so all of the bytecode stuff

00:34:30,339 --> 00:34:32,379
we saw here is very specific to CPython

00:34:32,380 --> 00:34:35,040
and even down to minor versions of CPython.

00:34:35,040 --> 00:34:38,990
So the bytecode format is not in any way, like, standardized

00:34:38,990 --> 00:34:40,860
or guaranteed to be stable across versions.

00:34:40,860 --> 00:34:44,940
So bytecode from Python 3.42 to 3.43 would not even necessarily be the same.

00:34:44,940 --> 00:34:46,760
(audience member) I mean, I understand that the bytecode

00:34:46,760 --> 00:34:53,180
is not the same, but doesn't Jython for example have the same code model?

00:34:53,180 --> 00:34:55,580
(Scott Sanderson) But Jython's generating, like, Java,

00:34:55,580 --> 00:34:58,440
jvm bytecode. It's a totally different format with totally different semantics.

00:34:58,440 --> 00:35:01,000
So like, I don't think there even is a dis module in Jython

00:35:01,010 --> 00:35:03,840
or pypy for example, or if it does, it's just for compat.

00:35:03,840 --> 00:35:06,260
(audience member) All right, and my second question is,

00:35:06,260 --> 00:35:09,960
can you jump into the middle of the instructions?

00:35:09,960 --> 00:35:11,531
(Scott Sanderson) Can you jump into the middle

00:35:11,540 --> 00:35:12,900
of an instruction?

00:35:12,900 --> 00:35:14,740
(audience member) Right. Like, if your instruction is 3 bytes,

00:35:14,740 --> 00:35:16,500
can you jump into the second byte?

00:35:16,500 --> 00:35:18,320
(Joe Jevnik) The compiler does no validation

00:35:18,329 --> 00:35:20,060
on the bytecode at run time.

00:35:20,060 --> 00:35:23,600
So it assumes that the compiler has generated sane code.

00:35:23,600 --> 00:35:27,220
You can feed anything you want there and it will just run.

00:35:27,220 --> 00:35:30,700
But there's no guarantee that will do anything other than segfault.

00:35:30,700 --> 00:35:32,960
(Scott Sanderson) Yeah, so you can, but almost certainly,

00:35:32,960 --> 00:35:34,800
terrible terrible things will happen to your machine.

00:35:34,800 --> 00:35:36,480
(Joe Jevnik) And just so people know,

00:35:36,480 --> 00:35:38,400
all of these examples were done on Python 3.5.

00:35:38,400 --> 00:35:40,480
Like, when we say there are changes between versions,

00:35:40,480 --> 00:35:42,480
like, 3.5 added new instructions.

00:35:42,480 --> 00:35:44,600
On 3.6 head of default right now.

00:35:44,600 --> 00:35:47,280
There's word code which changes the size of all of these instructions.

00:35:47,280 --> 00:35:50,520
So this is truly an implementation detail.

00:35:50,520 --> 00:35:58,220
[audience member inaudible, speaking far from microphone]

00:35:58,220 --> 00:36:00,740
(host) Pardon me. Please raise your hand

00:36:00,740 --> 00:36:03,860
and have the microphone come to you so we can get that in the recording.

00:36:03,860 --> 00:36:07,220
Thanks. This young lady had a question.

00:36:07,980 --> 00:36:10,620
(audience member) The LOAD_FAST instruction,

00:36:10,620 --> 00:36:16,540
it looks like it ended and it was actually 3 bytes.

00:36:17,100 --> 00:36:19,100
What -- then the last one was 0.

00:36:19,100 --> 00:36:22,020
So I was just wondering what that signified.

00:36:22,020 --> 00:36:23,560
(Scott Sanderson) You're asking about --

00:36:23,560 --> 00:36:26,660
(Joe Jevnik) It's the 124, like 1, 0 or 0, 0?

00:36:26,660 --> 00:36:27,660
(audience member) Yeah.

00:36:27,660 --> 00:36:29,640
(Joe Jevnik) So the 124 is the opcode which says

00:36:29,640 --> 00:36:33,480
this instruction is a LOAD_FAST and it's going to load a local variable.

00:36:33,480 --> 00:36:35,900
And when it sees the 124 in the interpreter loop,

00:36:35,900 --> 00:36:39,720
it will then read the next two bytes as a short or a little endian integer.

00:36:39,720 --> 00:36:43,640
And it will use that to index into the fast locals,

00:36:43,650 --> 00:36:47,810
which is a field in an array, and use that to load a local variable out.

00:36:47,810 --> 00:36:50,260
So it's 1, 0 because it's little endian

00:36:50,260 --> 00:36:53,140
and the least significant byte is first.

00:36:57,140 --> 00:36:58,880
(Scott Sanderson) Do we want to get that question

00:36:58,880 --> 00:37:00,620
on microphone?

00:37:02,100 --> 00:37:03,840
(audience member) So you're saying you're working on

00:37:03,840 --> 00:37:06,460
Python 3.5, 3.6, was it?

00:37:06,460 --> 00:37:09,040
Your interpreted -- interpolated strings,

00:37:09,040 --> 00:37:11,960
you used a bytecode object to return that.

00:37:11,960 --> 00:37:14,500
But the result we saw was a Unicode string.

00:37:14,500 --> 00:37:15,500
(Scott and Joe) Yes.

00:37:15,500 --> 00:37:16,940
(audience member) Does it actually decode?

00:37:16,940 --> 00:37:19,079
(Scott Sanderson) Yeah, so I sort of glossed over this,

00:37:19,079 --> 00:37:21,020
actually. You notice that when I decorated that,

00:37:21,020 --> 00:37:24,980
I called it instead of just decorating directly.

00:37:24,980 --> 00:37:27,980
So one of the things that that interpolated strings decorator does

00:37:27,980 --> 00:37:32,380
is say which -- if I can get back -- there we go.

00:37:32,380 --> 00:37:35,020
It takes keyword arguments to say which kind of string literals

00:37:35,030 --> 00:37:37,630
that should apply this to, so by default it will --

00:37:37,630 --> 00:37:41,040
basically it lets you use bytes -- like, byte strings as f-strings,

00:37:41,040 --> 00:37:44,100
rather than as Unicode strings, and you can pass a flag that says

00:37:44,100 --> 00:37:46,619
"also do this for Unicode strings" or "don't use it for bytes."

00:37:46,619 --> 00:37:48,609
But it's really just using that as a signifier,

00:37:48,609 --> 00:37:50,540
and under the hood this is essentially getting rewritten

00:37:50,540 --> 00:37:56,700
into something like the literal .decode UTF-8 .format **locals.

00:37:56,700 --> 00:37:58,580
(Joe Jevnik) So we just use bytes because it's

00:37:58,580 --> 00:38:01,580
less common to see bytes literals than Unicode literals.

00:38:01,580 --> 00:38:03,380
So that's more of just a marker

00:38:03,380 --> 00:38:06,120
that says we're going to do something special with it.

00:38:07,760 --> 00:38:09,600
(host) Any more questions?

00:38:10,280 --> 00:38:12,060
(Scott Sanderson) We've got one here.

00:38:17,460 --> 00:38:19,260
(audience member) How many times did you guys go through

00:38:19,260 --> 00:38:21,620
this awesome talk and practice your dry run?

00:38:22,220 --> 00:38:24,400
(Scott Sanderson) We've probably rehearsed it,

00:38:24,400 --> 00:38:26,980
start to finish, 15, 20 times now.

00:38:26,980 --> 00:38:36,180
[applause]

00:38:47,880 --> 00:38:50,980
(audience member) So I'm just wondering if you're familiar with

00:38:50,980 --> 00:38:53,660
kind of broader practical applications of this,

00:38:53,660 --> 00:38:58,880
like using it to write directly to hardware,

00:38:58,880 --> 00:39:02,180
or, you know, places where eliminating a few lines

00:39:02,180 --> 00:39:04,020
here and there actually could be useful,

00:39:04,020 --> 00:39:06,720
and if you know of anybody that's done that type of stuff.

00:39:06,720 --> 00:39:10,180
(Joe Jevnik) In terms of practical applications,

00:39:10,180 --> 00:39:13,060
there aren't many because this is truly implementation-specific,

00:39:13,060 --> 00:39:15,940
and like, no guarantees that any of this will work.

00:39:15,940 --> 00:39:19,460
I have seen some interesting things with a project called pyrasite,

00:39:19,460 --> 00:39:23,140
which lets you hook into a running Python process and inject code.

00:39:23,140 --> 00:39:25,880
And someone had told me they were working on a project,

00:39:25,890 --> 00:39:30,069
I think it works totally, where they could hook a function at runtime

00:39:30,069 --> 00:39:34,490
to add break points so that they could attach a break point to a running server

00:39:34,490 --> 00:39:37,350
and then you'd hit a route and then it would hit their break point.

00:39:37,350 --> 00:39:40,220
And then when they were done, they could just strip those break points out

00:39:40,220 --> 00:39:42,780
and there was no trace that they were there.

00:39:42,780 --> 00:39:44,740
(Scott Sanderson) That's sort of -- we talk about, like,

00:39:44,740 --> 00:39:47,240
everyone who had an addone suddenly got an addtwo.

00:39:47,250 --> 00:39:49,280
For something like "I want to inject a debugger in there,"

00:39:49,280 --> 00:39:52,840
it's actually a case where you might truly want to suddenly globally change

00:39:52,840 --> 00:39:54,380
everyone's behavior.

00:39:54,380 --> 00:39:56,500
Another example of something that's kind of in the same vein

00:39:56,500 --> 00:39:59,420
although much more extreme than this is there's a project

00:39:59,420 --> 00:40:02,700
in the Numerical community from Continuum Analytics called Numba.

00:40:02,700 --> 00:40:05,040
And so here what we were doing was taking bytecode

00:40:05,040 --> 00:40:07,300
and sort of rewriting it into different bytecode.

00:40:07,300 --> 00:40:10,380
What Numba does is take your bytecode and just throw it in the trash

00:40:10,390 --> 00:40:13,150
and replace it with lvm intermediate representation

00:40:13,150 --> 00:40:16,650
so that you can -- it takes your Python and tries to transliterate it

00:40:16,650 --> 00:40:19,380
into a much more low-level machine-specific language.

00:40:19,380 --> 00:40:22,400
And it's, like, numpy-aware and does some other fancy things.

00:40:22,400 --> 00:40:24,780
So that's sort of like the logical extreme of this

00:40:24,780 --> 00:40:27,120
if you're trying to do it for something like performance.

00:40:30,240 --> 00:40:32,000
(host) Other questions?

00:40:44,120 --> 00:40:45,960
(audience member) So if I was reading the example

00:40:45,960 --> 00:40:47,700
with a simple function and the LOAD_FAST,

00:40:47,700 --> 00:40:51,160
it seems to mean that I can't have a function

00:40:51,160 --> 00:40:54,910
with more than 64k local variables. Is that right?

00:40:54,910 --> 00:40:57,910
(Joe Jevnik) There's actually a pseudo-instruction

00:40:57,910 --> 00:40:59,620
called extended_arg.

00:40:59,620 --> 00:41:02,200
And it has an opcode followed by two arguments.

00:41:02,200 --> 00:41:04,940
And then that would precede an instruction

00:41:04,940 --> 00:41:06,900
that also took a short as its argument,

00:41:06,900 --> 00:41:09,820
and it would merge those together to get a wider argument.

00:41:09,830 --> 00:41:13,030
So I believe those will be emitted for a LOAD_FAST.

00:41:13,030 --> 00:41:15,190
I'm not positive. I haven't tried that.

00:41:15,190 --> 00:41:19,400
I'm sure codetransformer has a test somewhere that does that, but --

00:41:19,400 --> 00:41:21,260
(Scott Sanderson) If you want to see some examples

00:41:21,260 --> 00:41:23,380
of, like, truly horrific code or strange code,

00:41:23,380 --> 00:41:25,700
look at the codetransformer tests we did.

00:41:25,700 --> 00:41:27,380
[laughter]

00:41:29,060 --> 00:41:30,940
(host) Other questions?

00:41:32,220 --> 00:41:35,260
Well, please help me in thanking these guys for a great talk.

00:41:35,260 --> 00:41:50,200

YouTube URL: https://www.youtube.com/watch?v=mxjv9KqzwjI


