Title: David Baumgold - Prototyping New APIs with Flask - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: David Baumgold

You need to build a new API, but which tools do you use? Flask is a microframework that makes web development a snap, and an ecosystem of extensions and other tools has grown around it to make it perfect for prototyping APIs. In this talk, we'll see how to get started with Flask, and learn the best parts of its ecosystem for API development. 

Slides can be found at: https://speakerdeck.com/singingwolfboy/prototyping-apis-with-flask and there is a GitHub repository for the code here: https://github.com/singingwolfboy/build-a-flask-api

https://us.pycon.org/2016/schedule/presentation/1694/
Captions: 
	00:00:00,638 --> 00:00:03,288
(MC) So, we're gonna go ahead and get started

00:00:03,288 --> 00:00:05,269
This is David Baumgold

00:00:05,269 --> 00:00:09,493
the name in the printed handout was a mistake

00:00:09,493 --> 00:00:11,206
So this is the real guy

00:00:11,206 --> 00:00:14,619
and we're gonna learn about Flask!

00:00:14,619 --> 00:00:15,860
Take it away!

00:00:15,860 --> 00:00:20,100
(clapping)

00:00:22,863 --> 00:00:23,329
(David) So hi,

00:00:23,329 --> 00:00:24,554
my name is David Baumgold

00:00:24,554 --> 00:00:26,002
I'm a freelance web developer

00:00:26,002 --> 00:00:26,854
in the Boston area

00:00:26,854 --> 00:00:29,097
and I've been building APIs in Flask for a long time

00:00:29,097 --> 00:00:31,200
wanted to share the basics of what I know.

00:00:31,200 --> 00:00:32,601
So I assume that if you're here

00:00:32,601 --> 00:00:34,794
you already know more or less what an API is

00:00:34,794 --> 00:00:35,935
and you know why they're really cool

00:00:35,935 --> 00:00:38,489
They allow different companies and people

00:00:38,489 --> 00:00:40,586
to mash up different pieces of information together

00:00:40,586 --> 00:00:42,643
and build some really cool results

00:00:42,643 --> 00:00:44,381
out of the blend.

00:00:44,381 --> 00:00:46,397
And they're so hot right now.

00:00:46,763 --> 00:00:49,972
So, given all that, let's learn how to build an API!

00:00:49,972 --> 00:00:52,048
Oh except your boss has told you

00:00:52,048 --> 00:00:54,417
that you only have about a week to spend on this

00:00:54,417 --> 00:00:58,946
and you have to start from zero and figure out how to do everything

00:00:58,946 --> 00:01:01,845
So, great! We'll build one really, really fast.

00:01:01,845 --> 00:01:04,286
It'll be awesome. It'll be fantastic!

00:01:04,286 --> 00:01:06,247
So before we get started,

00:01:06,247 --> 00:01:09,005
let's define what we actually want to build

00:01:09,005 --> 00:01:09,882
and what we care about.

00:01:09,882 --> 00:01:13,126
For a very simple prototype API,

00:01:13,126 --> 00:01:15,159
I'd say probably the things we care about the most are

00:01:15,159 --> 00:01:16,672
a JSON data format

00:01:16,672 --> 00:01:18,870
because that's what all the cool kids are using these days,

00:01:18,870 --> 00:01:20,656
CRUD operations,

00:01:20,656 --> 00:01:23,889
which is create, read, update, and delete

00:01:23,889 --> 00:01:25,420
for those of you who are not database weenies,

00:01:25,420 --> 00:01:26,946
REST semantics,

00:01:26,946 --> 00:01:29,374
which is a structure of an API that allows you

00:01:29,374 --> 00:01:31,341
to treat individual objects as resources

00:01:31,341 --> 00:01:33,266
and do operations onto them

00:01:33,266 --> 00:01:35,549
and probably the most important thing

00:01:35,549 --> 00:01:37,702
is that we want our API to be very flexible

00:01:37,702 --> 00:01:39,813
because we don't quite know what we want yet

00:01:39,813 --> 00:01:42,433
we want to play around and have our code be able to respond

00:01:42,433 --> 00:01:43,507
easily and quickly.

00:01:43,507 --> 00:01:46,446
And although there are many things we do care about,

00:01:46,446 --> 00:01:49,985
there are a couple of things I want to say we don't care about in this presentation.

00:01:49,985 --> 00:01:51,735
We don't care about stability and testing,

00:01:51,735 --> 00:01:53,800
we don't care about long-term maintainability,

00:01:53,800 --> 00:01:54,782
or edge-cases,

00:01:54,782 --> 00:01:57,689
and we certainly don't care about operations and deployment,

00:01:57,689 --> 00:02:00,343
because this is only a prototype.

00:02:00,343 --> 00:02:02,986
The goal of this is about flexibility of coding,

00:02:02,986 --> 00:02:05,329
not about building something that is

00:02:05,329 --> 00:02:07,600
stable and maintainable over a long period.

00:02:07,600 --> 00:02:09,426
That is a different talk.

00:02:09,426 --> 00:02:11,621
So let's get started!

00:02:11,621 --> 00:02:14,929
My favorite tool for building web applications and APIs

00:02:14,929 --> 00:02:17,067
is Flask, because it has a really shallow learning curve,

00:02:17,067 --> 00:02:18,213
and it's easy to get started.

00:02:18,213 --> 00:02:21,141
So let's start with the "Hello, World" example

00:02:21,141 --> 00:02:23,012
that you can find on the Flask website.

00:02:23,012 --> 00:02:23,986
Short and sweet.

00:02:23,986 --> 00:02:25,447
And when you visit it in the browser,

00:02:25,447 --> 00:02:26,595
you get a "Hello, World!"

00:02:26,595 --> 00:02:28,489
Now the first step is to modify this

00:02:28,489 --> 00:02:29,733
to get some JSON information

00:02:29,733 --> 00:02:33,458
so Flask actually has a built-in function called "jsonify"

00:02:33,458 --> 00:02:36,837
and if you pass data to that jsonify function

00:02:36,837 --> 00:02:40,266
it'll return it as a JSON-formatted piece of information

00:02:40,266 --> 00:02:42,720
So basically what we have here right now

00:02:42,720 --> 00:02:44,597
is we have our very first API.

00:02:44,597 --> 00:02:46,086
It's read-only,

00:02:46,086 --> 00:02:48,354
it just returns the string "Hello, World!",

00:02:48,354 --> 00:02:49,322
but it's something.

00:02:49,322 --> 00:02:52,109
But it's not really what we want to get to.

00:02:52,109 --> 00:02:55,979
So let's think of some idea that we can put into our API

00:02:55,979 --> 00:02:57,541
that makes it a little bit more compelling.

00:02:57,541 --> 00:02:58,675
And I don't know about you,

00:02:58,675 --> 00:03:00,506
but I love puppies.

00:03:00,506 --> 00:03:02,096
They're super cute,

00:03:02,096 --> 00:03:04,269
and there are way too many kitties on the internet

00:03:04,269 --> 00:03:05,447
and not enough puppies.

00:03:05,447 --> 00:03:06,996
So we're gonna build a puppy API

00:03:06,996 --> 00:03:08,534
and it's gonna be fantastic.

00:03:08,534 --> 00:03:11,559
So here is our basic puppy API.

00:03:11,559 --> 00:03:13,618
It's gonna return some information about Rover

00:03:13,618 --> 00:03:15,841
we've got his name, and we've got a URL

00:03:15,841 --> 00:03:18,218
where the user can visit to get a picture of Rover

00:03:18,218 --> 00:03:19,921
and as we've seen, he's very cute.

00:03:19,921 --> 00:03:22,429
So here's our basic API,

00:03:22,429 --> 00:03:25,482
but again, it's not really as much as we're looking for

00:03:25,482 --> 00:03:27,727
because this is an API that only returns information

00:03:27,727 --> 00:03:29,248
about one specific puppy,

00:03:29,248 --> 00:03:31,067
and there are lots of puppies in the world

00:03:31,067 --> 00:03:32,988
and we want to hug all of them.

00:03:32,988 --> 00:03:34,922
(laughter)

00:03:34,922 --> 00:03:36,686
So now, we have a data structure

00:03:36,686 --> 00:03:39,473
that's going to define multiple puppies in our codebase.

00:03:39,473 --> 00:03:40,607
This is a list of puppies

00:03:40,607 --> 00:03:42,335
that has two entries in it.

00:03:42,335 --> 00:03:45,185
And we've changed the URL route as well

00:03:45,185 --> 00:03:47,964
so that now, when you visit this API

00:03:47,964 --> 00:03:50,954
you have to specify an index into this list.

00:03:50,954 --> 00:03:52,644
You're actually going to visit, you know,

00:03:52,644 --> 00:03:54,492
puppyapi.com slash one,

00:03:54,492 --> 00:03:57,787
or puppyapi.com slash fifteen, or whatever.

00:03:57,787 --> 00:03:59,277
It's gonna index into that list,

00:03:59,277 --> 00:04:00,696
and try to find the puppy,

00:04:00,696 --> 00:04:04,202
and put that out using the jsonify method.

00:04:04,202 --> 00:04:07,720
If it can't find it, it's gonna return a 404 exception: not found.

00:04:07,720 --> 00:04:08,617
Which is what we expect.

00:04:08,617 --> 00:04:10,488
And now if you visit this in the browser,

00:04:10,488 --> 00:04:11,848
we'll get something like this.

00:04:11,848 --> 00:04:13,560
Go to slash zero, and you've got Rover.

00:04:13,560 --> 00:04:15,204
Go to slash one, you've got Spot.

00:04:15,204 --> 00:04:18,493
And if you go to slash two, then, well, there's no puppies there.

00:04:18,493 --> 00:04:19,064
Sorry.

00:04:19,064 --> 00:04:25,425
But zero, one, and two aren't really very friendly URLs either.

00:04:25,425 --> 00:04:27,812
You know, we wanna hug these puppies, not count them.

00:04:27,812 --> 00:04:30,993
So we can modify this pretty easily

00:04:30,993 --> 00:04:35,316
to say instead of a list of puppies we're gonna have a dictionary of puppies.

00:04:35,316 --> 00:04:38,074
And what I have for the keys of this dictionary

00:04:38,074 --> 00:04:39,857
is something that's called a "slug".

00:04:39,857 --> 00:04:41,683
And that is actually a publishing term,

00:04:41,683 --> 00:04:44,112
I'm not sure where the term "slug" itself comes from,

00:04:44,112 --> 00:04:46,233
but all it means is that it's a

00:04:46,233 --> 00:04:50,412
short, usually lower-case, ASCII letter version of

00:04:50,412 --> 00:04:52,444
whatever object you're trying to find.

00:04:52,444 --> 00:04:56,014
And that allows you to uniquely identify a specific object,

00:04:56,014 --> 00:04:58,579
while also having a human-friendly name.

00:04:58,579 --> 00:05:01,854
And we've had to change very little in our method as well,

00:05:01,854 --> 00:05:03,216
to make it so that you can

00:05:03,216 --> 00:05:05,305
look up puppies by slug instead of by number,

00:05:05,305 --> 00:05:06,569
basically all we've had to do

00:05:06,569 --> 00:05:09,255
is specify that slug can be a string instead of an integer,

00:05:09,255 --> 00:05:13,244
and check for a KeyError instead of an IndexError.

00:05:13,244 --> 00:05:16,565
And now you can go to slash rover and get information about Rover,

00:05:16,565 --> 00:05:19,103
you can go to slash spot and get information about Spot,

00:05:19,103 --> 00:05:20,411
and if you're looking for Lassie,

00:05:20,411 --> 00:05:23,173
well sorry, she's rescuing Timmy down the well again.

00:05:23,173 --> 00:05:24,606
Poor Timmy.

00:05:24,606 --> 00:05:27,107
So end of day one.

00:05:27,107 --> 00:05:31,000
And the result is, it works. We have a working JSON API.

00:05:31,000 --> 00:05:33,775
But the bad news is, it's still not enough.

00:05:33,775 --> 00:05:35,805
All we have is static data.

00:05:35,805 --> 00:05:39,236
And if you want to modify the puppies that are available in this API,

00:05:39,236 --> 00:05:42,546
you actually have to go into the codebase and rewrite it.

00:05:42,546 --> 00:05:46,924
So let's start day two with adding another piece of complexity

00:05:46,924 --> 00:05:48,123
to our codebase. We're gonna use

00:05:48,123 --> 00:05:49,730
another Flask extension,

00:05:49,730 --> 00:05:51,942
and this one is called Flask-SQLAlchemy.

00:05:51,942 --> 00:05:53,594
Now the general idea of what we're doing

00:05:53,594 --> 00:05:55,723
is we want to separate our concerns.

00:05:55,723 --> 00:06:00,708
We want to have the Python code operate on the views.

00:06:00,708 --> 00:06:03,050
We want to have the data outside of the Python code

00:06:03,050 --> 00:06:04,930
and put that into a database.

00:06:04,930 --> 00:06:06,870
Databases are great for holding data,

00:06:06,870 --> 00:06:07,873
it's what they're built for,

00:06:07,873 --> 00:06:11,398
and also allows you to modify the data that this API can represent

00:06:11,398 --> 00:06:13,561
without modifying the Python code.

00:06:13,561 --> 00:06:15,903
So to do that, we're gonna use SQLAlchemy,

00:06:15,903 --> 00:06:18,046
which is an object relational mapper.

00:06:18,046 --> 00:06:20,480
Briefly, what an object relational mapper does,

00:06:20,480 --> 00:06:24,648
it allows you to query and update data in a database,

00:06:24,648 --> 00:06:27,066
without having to write straight SQL,

00:06:27,066 --> 00:06:30,910
but instead, it allows you to treat it in a more Pythonic fashion.

00:06:30,910 --> 00:06:34,052
So let me give you an example of what I mean.

00:06:34,052 --> 00:06:38,041
Here is a model that we're going to use for our puppy API.

00:06:38,041 --> 00:06:39,797
As you can see, we're just importing something from

00:06:39,797 --> 00:06:41,404
the Flask-SQLAlchemy module,

00:06:41,404 --> 00:06:42,689
we're initializing it,

00:06:42,689 --> 00:06:45,070
and then we're creating our Puppy class

00:06:45,070 --> 00:06:46,579
which is a subclass of Model.

00:06:46,579 --> 00:06:50,260
And this class has four pieces of information attached to it.

00:06:50,260 --> 00:06:52,749
It has a numerical ID, which is used by the database

00:06:52,749 --> 00:06:54,392
to keep track of which puppy is which,

00:06:54,392 --> 00:06:57,243
it has a slug, which is a more human-friendly way

00:06:57,243 --> 00:06:58,313
of doing the same-thing,

00:06:58,313 --> 00:07:00,324
and it has a name and image_url,

00:07:00,324 --> 00:07:01,532
which we're familiar with.

00:07:01,532 --> 00:07:03,662
There are a couple other things I want to call out here.

00:07:03,662 --> 00:07:07,420
I've added an index=True attribute on the slug field

00:07:07,420 --> 00:07:10,862
so that the database will index this field

00:07:10,862 --> 00:07:13,023
and allow us to look up puppies very quickly by specifying a slug.

00:07:13,023 --> 00:07:16,310
And I've also specified that the name and the image_url

00:07:16,310 --> 00:07:17,348
are not optional.

00:07:17,348 --> 00:07:19,295
That in order to create a puppy,

00:07:19,295 --> 00:07:21,776
you have to have a name and you have to have an image_url.

00:07:21,776 --> 00:07:25,628
Which prevents us from having puppies that are nameless and unloved.

00:07:25,628 --> 00:07:29,331
So I'm also going to go over very briefly

00:07:29,331 --> 00:07:31,247
how to use SQLAlchemy.

00:07:31,247 --> 00:07:34,535
Briefly, you want to create a Puppy object

00:07:34,535 --> 00:07:36,585
and add it to your database session.

00:07:36,585 --> 00:07:39,402
You can add multiple Puppy objects to that session,

00:07:39,402 --> 00:07:40,561
and then when you're ready,

00:07:40,561 --> 00:07:42,169
you can call session dot commit,

00:07:42,169 --> 00:07:47,108
which will actually take those objects and save them to the database permanently.

00:07:47,108 --> 00:07:48,228
Once you've done that,

00:07:48,228 --> 00:07:50,040
then you can query the database,

00:07:50,040 --> 00:07:52,029
and get that data back out,

00:07:52,029 --> 00:07:55,354
on the same request, or on subsequent API requests as well.

00:07:55,354 --> 00:07:57,770
So you can do puppy dot query dot all,

00:07:57,770 --> 00:07:59,983
and that will return to you a list of all the puppies that exist

00:07:59,983 --> 00:08:01,185
in the database.

00:08:01,185 --> 00:08:03,727
You can also filter down on that query

00:08:03,727 --> 00:08:08,194
and specify limitations on which puppy should be returned.

00:08:08,194 --> 00:08:12,243
And then you can call dot first to get, instead of a list of all the results,

00:08:12,243 --> 00:08:13,822
you can just get the first result.

00:08:13,822 --> 00:08:16,835
So now we're getting only Spot from the database,

00:08:16,835 --> 00:08:18,651
even though both Spot and Rover are in there.

00:08:18,651 --> 00:08:21,660
You can also use the dot filter_by method

00:08:21,660 --> 00:08:23,240
as sort of a shortcut,

00:08:23,240 --> 00:08:27,124
so that you don't have to specify exactly which slug you're referring to

00:08:27,124 --> 00:08:29,699
if it's very clear from the query itself

00:08:29,699 --> 00:08:31,576
that you're only dealing with one model.

00:08:31,576 --> 00:08:34,100
And if you don't get any matches in your query,

00:08:34,100 --> 00:08:36,107
it's just gonna return the None object.

00:08:36,107 --> 00:08:38,642
Which sort of makes sense in a Pythonic way.

00:08:38,642 --> 00:08:41,975
You can also update a database by getting a puppy object,

00:08:41,975 --> 00:08:44,364
modifying attributes on that object,

00:08:44,364 --> 00:08:46,776
and then passing it back into the database session

00:08:46,776 --> 00:08:48,121
and committing that session.

00:08:48,121 --> 00:08:50,843
Once you query the database again, it'll be updated

00:08:50,843 --> 00:08:53,711
and you can also delete from the database

00:08:53,711 --> 00:08:57,583
by calling db dot session dot delete on the model object.

00:08:57,583 --> 00:09:01,011
Basically, this allows you to do all of your

00:09:01,011 --> 00:09:02,321
standard database operations,

00:09:02,321 --> 00:09:05,729
without leaving the comfort and familiarity of Python.

00:09:05,729 --> 00:09:07,804
There's a lot more that you can do with SQLAlchemy,

00:09:07,804 --> 00:09:09,908
but I don't want to go too deep into it in this talk,

00:09:09,908 --> 00:09:12,761
because again, that is it's own separate talk,

00:09:12,761 --> 00:09:15,164
so if you want to learn more, you can check out the documentation.

00:09:15,164 --> 00:09:18,903
So we've already defined the model for our puppy object,

00:09:18,903 --> 00:09:20,595
I did that a couple slides ago,

00:09:20,595 --> 00:09:23,728
so here we're going to integrate that model into

00:09:23,728 --> 00:09:25,089
the view that we already have.

00:09:25,089 --> 00:09:26,229
Just importing it,

00:09:26,229 --> 00:09:29,017
setting up a little bit of configuration to say that we want to use a

00:09:29,017 --> 00:09:30,045
sqlite database,

00:09:30,045 --> 00:09:33,452
you can use MySQL or Postgres or Oracle or many different options

00:09:33,452 --> 00:09:35,290
that SQLAlchemy supports.

00:09:35,290 --> 00:09:39,250
And then we re-write our get_puppy view just a little bit

00:09:39,250 --> 00:09:41,620
so that it does a database query

00:09:41,620 --> 00:09:45,818
instead of pulling out from the dictionary that used to be in the code.

00:09:45,818 --> 00:09:49,326
Now another thing I wanted to call out is this first_or_404 method.

00:09:49,326 --> 00:09:52,567
And that's something that's added by Flask-SQLAlchemy

00:09:52,567 --> 00:09:55,023
that's like the integration layer between the two of them.

00:09:55,023 --> 00:09:57,614
And that's a really nice shortcut that says,

00:09:57,614 --> 00:10:01,478
get the first item that this query returns, and if you can't find it,

00:10:01,478 --> 00:10:04,510
then just return a 404 exception.

00:10:04,510 --> 00:10:09,540
So we do that, and we try to run it, and we get an internal server error.

00:10:09,540 --> 00:10:11,302
What went wrong?

00:10:11,302 --> 00:10:13,623
Turns out that you have to actually initialize the database,

00:10:13,623 --> 00:10:16,442
before you can actually use the database.

00:10:16,442 --> 00:10:19,436
You have to tell the database what structure the data should be in.

00:10:19,436 --> 00:10:22,432
And for that, you can use the db dot create_all method.

00:10:22,432 --> 00:10:24,908
So I've just added something to the section at the end,

00:10:24,908 --> 00:10:28,215
where I can run this code and say create the database,

00:10:28,215 --> 00:10:32,405
and it'll contact my sqlite file and create the structure.

00:10:32,405 --> 00:10:34,513
And if I try to run it again?

00:10:34,513 --> 00:10:36,712
Well, now we get a 404.

00:10:36,712 --> 00:10:39,684
And that's because we need to seed data into the database

00:10:39,684 --> 00:10:43,678
before we can pull it out in the views as well.

00:10:43,678 --> 00:10:47,927
So you can't query the database if there's nothing in there to query.

00:10:47,927 --> 00:10:50,776
Now if I were doing this in a more production-ready manner,

00:10:50,776 --> 00:10:53,387
I would probably have separate scripts for this,

00:10:53,387 --> 00:10:55,295
like in Django you can use manage.py,

00:10:55,295 --> 00:10:58,554
and in Flask you can use something very similar using Flask-Script

00:10:58,554 --> 00:11:02,238
or using the very recently release Flask 0.11,

00:11:02,238 --> 00:11:06,000
you can actually define scripts using the click integration framework,

00:11:06,000 --> 00:11:08,686
but I'm not going into that, because again this is just a prototype.

00:11:08,686 --> 00:11:11,937
Anyway, once you've done all these things,

00:11:11,937 --> 00:11:15,023
we have exactly the same result as we had before.

00:11:15,023 --> 00:11:16,906
We can go to slash rover and get Rover,

00:11:16,906 --> 00:11:18,508
we can go to slash spot and get Spot,

00:11:18,508 --> 00:11:21,342
and Lassie is still conspicuously missing.

00:11:21,342 --> 00:11:25,091
However, now that we have an actual database,

00:11:25,091 --> 00:11:27,457
we can do some more interesting features.

00:11:27,457 --> 00:11:30,787
So here's a method to not just view information in the database,

00:11:30,787 --> 00:11:33,219
but actually create new information.

00:11:33,219 --> 00:11:36,590
I have a create_puppy method, and what this will do,

00:11:36,590 --> 00:11:39,932
is it will get information from the incoming HTTP request,

00:11:39,932 --> 00:11:44,007
it'll validate it, and make sure the puppy has a name and an image_url,

00:11:44,007 --> 00:11:46,949
and if it does, it'll create it in the database,

00:11:46,949 --> 00:11:53,383
and return an HTTP response indicating that the puppy was successfully created.

00:11:53,383 --> 00:11:56,925
It'll also find the URL to where you can find more information about that puppy

00:11:56,925 --> 00:11:57,413
and return that.

00:11:57,413 --> 00:11:57,663
All of this is using variables that we've seen before, except for a few.

00:11:57,663 --> 00:12:05,804
"request" and "url_for" are things that are built into Flask,

00:12:05,804 --> 00:12:09,593
and "slugify" is a third-party module that I've installed,

00:12:09,593 --> 00:12:13,106
which just allows me to take a normal name, and convert it into

00:12:13,106 --> 00:12:16,962
a short, lower-case, standard slugifed version of it.

00:12:16,962 --> 00:12:19,571
So now if you try to use this method,

00:12:19,571 --> 00:12:22,672
you can use curl to generate a POST request,

00:12:22,672 --> 00:12:24,640
and the end result is you're going to get

00:12:24,640 --> 00:12:27,833
a response that looks exactly like how we expect it to

00:12:27,833 --> 00:12:29,671
for a JSON REST-ful API.

00:12:29,671 --> 00:12:31,192
We get a "201 Created" response,

00:12:31,192 --> 00:12:33,656
and we get this really-nice "Location" header,

00:12:33,656 --> 00:12:38,657
which is standard in the HTTP definitions as well

00:12:38,657 --> 00:12:41,625
to indicate, if you want to learn more about this object you just created,

00:12:41,625 --> 00:12:43,759
you can request it at this URL.

00:12:43,759 --> 00:12:47,642
Great! Now we have dynamic data.

00:12:47,642 --> 00:12:51,907
But the bad news is, our code is still kind of verbose.

00:12:51,907 --> 00:12:54,429
And the views are reaching into the models,

00:12:54,429 --> 00:12:57,494
which means that our data isn't as well separated as we'd like.

00:12:57,494 --> 00:13:00,403
This is an example of what I mean by reaching into the models.

00:13:00,403 --> 00:13:04,055
We've defined the database structure in the models,

00:13:04,055 --> 00:13:07,576
but in the view, it still needs to know which attributes of the model

00:13:07,576 --> 00:13:09,550
to pull out into JSON.

00:13:09,550 --> 00:13:13,623
So we're gonna add a little bit more complexity for the sake of flexibility

00:13:13,623 --> 00:13:16,953
and we're going to a new module called Flask-Marshmallow.

00:13:16,953 --> 00:13:20,218
Now what what Flask-Marshmallow does is it's a data transformer.

00:13:20,218 --> 00:13:24,623
It allows you to convert between an internal representation

00:13:24,623 --> 00:13:28,744
of a resource, and an external representation of a resource.

00:13:28,744 --> 00:13:30,179
So the database holds the data,

00:13:30,179 --> 00:13:34,523
the Marshmallow transforms from the internal data to what we want to views

00:13:34,523 --> 00:13:40,588
in the API, and Flask only has to take that data and render it in JSON.

00:13:40,588 --> 00:13:43,967
So here's an example of a schema that we're using.

00:13:43,967 --> 00:13:46,588
It's pretty simple, because Marshmallow actually has great support

00:13:46,588 --> 00:13:49,216
both for Flask and for SQLAlchemy.

00:13:49,216 --> 00:13:51,243
So we can say we're gonna make a Puppy schema,

00:13:51,243 --> 00:13:54,673
and the model that it should use is the same Puppy model

00:13:54,673 --> 00:13:56,938
that we defined before, and that's all we need to say.

00:13:56,938 --> 00:14:00,110
And then we can create instances of the Puppy schema,

00:14:00,110 --> 00:14:03,093
both an individual puppy, and for a list of puppies,

00:14:03,093 --> 00:14:06,131
which will be important if you want to have an API method that returns

00:14:06,131 --> 00:14:07,760
a list of puppies.

00:14:07,760 --> 00:14:10,833
So now that we have this schema,

00:14:10,833 --> 00:14:14,094
our views become even simpler than they were before.

00:14:14,094 --> 00:14:16,380
You can import the schema,

00:14:16,380 --> 00:14:19,247
you can set up Marshmallow with the Flask application,

00:14:19,247 --> 00:14:24,327
and now, our get_puppy method becomes just two lines long of Python.

00:14:24,327 --> 00:14:26,420
The first line is doing a database query

00:14:26,420 --> 00:14:29,652
to get the internal representation of a Puppy object,

00:14:29,652 --> 00:14:33,806
and the second line is transforming that internal representation

00:14:33,806 --> 00:14:36,282
into what we want to display on the output.

00:14:36,282 --> 00:14:40,096
Now because we haven't told Marshmallow anything about how that should display,

00:14:40,096 --> 00:14:41,618
it's just going to display everything,

00:14:41,618 --> 00:14:46,018
including the id and the slug, which we haven't really care about in the past.

00:14:46,018 --> 00:14:47,873
So let's go back to how we used to be.

00:14:47,873 --> 00:14:49,928
All we have we have to do is tell Marshmallow, hey,

00:14:49,928 --> 00:14:51,781
the internal and the external representation

00:14:51,781 --> 00:14:53,554
are slightly different, in that

00:14:53,554 --> 00:14:57,419
the external representation doesn't include an id or a slug.

00:14:57,419 --> 00:15:00,742
And that simple change will change it

00:15:00,742 --> 00:15:02,673
so that when you output a puppy,

00:15:02,673 --> 00:15:05,170
it'll only have the image_url and the name.

00:15:05,170 --> 00:15:07,769
And that's gonna give us more flexibility down the line,

00:15:07,769 --> 00:15:09,640
as I'll mention as well later on.

00:15:09,640 --> 00:15:13,563
In order to create a puppy, this becomes dramatically simpler as well,

00:15:13,563 --> 00:15:15,628
because now that we have a schema

00:15:15,628 --> 00:15:20,108
that defines how the representation should be in JSON,

00:15:20,108 --> 00:15:23,642
we can simply load it from the variables

00:15:23,642 --> 00:15:25,726
that are passed in the HTTP request.

00:15:25,726 --> 00:15:29,838
And Marshmallow will take care of all the data validation for us.

00:15:29,838 --> 00:15:33,521
So we can check and see if there were any errors, and if so, just output them.

00:15:33,521 --> 00:15:38,566
We also can add new methods for editing and deleting puppies

00:15:38,566 --> 00:15:41,372
and editing is super similar.

00:15:41,372 --> 00:15:43,132
It's almost exactly the same as creating,

00:15:43,132 --> 00:15:44,922
all we have to do is that first line,

00:15:44,922 --> 00:15:47,911
we're checking to see if the puppy already exists in the database,

00:15:47,911 --> 00:15:50,751
and if it does, then we're just going to pass it

00:15:50,751 --> 00:15:53,361
to the second line as an instance.

00:15:53,361 --> 00:15:56,744
And now, Marshmallow knows that instead of creating a new Puppy object,

00:15:56,744 --> 00:16:00,550
it should update the values that its already found on that instance.

00:16:00,550 --> 00:16:03,798
And just for clarity for the user who's using this API,

00:16:03,798 --> 00:16:05,549
we've also modified the response message

00:16:05,549 --> 00:16:08,177
to say that it's been updated, instead of created.

00:16:08,177 --> 00:16:09,842
And to delete a puppy,

00:16:09,842 --> 00:16:13,633
we're just going to say we're going to take a "DELETE" HTTP verb,

00:16:13,633 --> 00:16:16,385
and we're going to find that puppy in the database,

00:16:16,385 --> 00:16:18,961
and we're going to pass it to db dot session dot delete.

00:16:18,961 --> 00:16:20,226
Super easy.

00:16:20,226 --> 00:16:22,577
And here's an example of using that delete method.

00:16:22,577 --> 00:16:23,877
You can see the first time that I do it,

00:16:23,877 --> 00:16:26,549
I get that nice friendly JSON message

00:16:26,549 --> 00:16:27,723
saying that the puppy was deleted,

00:16:27,723 --> 00:16:28,867
and the second time,

00:16:28,867 --> 00:16:32,322
I'm gonna get this sort of unfriendly 404 error,

00:16:32,322 --> 00:16:34,094
so let's change that.

00:16:34,094 --> 00:16:36,730
Flask actually has integrated error handlers,

00:16:36,730 --> 00:16:39,299
so that you can say if you get a 404 exception,

00:16:39,299 --> 00:16:41,881
this is how it should look, instead of the default.

00:16:41,881 --> 00:16:44,333
And now, if I try to delete a puppy that isn't there,

00:16:44,333 --> 00:16:46,269
I'm going to get a jsonified error message,

00:16:46,269 --> 00:16:49,825
which is great for prototyping an API.

00:16:49,825 --> 00:16:53,200
We can also make a simple view to list all the puppies

00:16:53,200 --> 00:16:54,384
in the database as well,

00:16:54,384 --> 00:16:56,050
and that's super easy as well,

00:16:56,050 --> 00:16:57,694
just get all the puppies in the database

00:16:57,694 --> 00:16:59,146
and dump them out.

00:16:59,146 --> 00:17:00,775
And you can see each individual puppy

00:17:00,775 --> 00:17:04,687
is going to be output the same way that that schema has already defined.

00:17:04,687 --> 00:17:07,179
And because we're using Marshmallow,

00:17:07,179 --> 00:17:09,454
we get data flexibility, which is fantastic.

00:17:09,454 --> 00:17:12,268
We can add new fields to our models,

00:17:12,268 --> 00:17:14,977
and they'll be instantly and automatically

00:17:14,977 --> 00:17:16,931
represented in our data output

00:17:16,931 --> 00:17:18,070
because we've told Marshmallow

00:17:18,070 --> 00:17:20,437
just output everything except those two fields we don't care about

00:17:20,437 --> 00:17:23,768
so if I add an age field, it's already there in the API.

00:17:23,768 --> 00:17:25,236
Super fast, super easy.

00:17:25,236 --> 00:17:28,272
And as I mentioned, we get full data validation

00:17:28,272 --> 00:17:30,020
automatically, for free.

00:17:30,020 --> 00:17:33,315
So if you try to create a puppy without specifying any information,

00:17:33,315 --> 00:17:35,577
it'll tell you all of the things that you need,

00:17:35,577 --> 00:17:37,434
and it'll tell you the data types as well

00:17:37,434 --> 00:17:38,468
if you get them wrong.

00:17:38,468 --> 00:17:41,781
So previously we were checking them one at a time,

00:17:41,781 --> 00:17:42,931
and if any of them are missing,

00:17:42,931 --> 00:17:44,296
we would just throw an error and say

00:17:44,296 --> 00:17:45,167
you need this,

00:17:45,167 --> 00:17:47,459
and then if the user provided it, we would also say

00:17:47,459 --> 00:17:48,515
oh, you also need that.

00:17:48,515 --> 00:17:51,367
With Marshmallow, you can get all the errors up front.

00:17:51,367 --> 00:17:53,542
So it's much easier to use the API.

00:17:53,542 --> 00:17:57,135
So great! We have flexibility and we have validation.

00:17:57,135 --> 00:17:58,943
The bad news is, the boss has come back

00:17:58,943 --> 00:18:00,649
and said actually it's not enough,

00:18:00,649 --> 00:18:02,573
we also need API users,

00:18:02,573 --> 00:18:05,364
so that we can track who's using our API and why.

00:18:05,364 --> 00:18:09,687
So now we're going to integrate with another piece of Flask extension,

00:18:09,687 --> 00:18:10,606
called Flask-Login.

00:18:10,606 --> 00:18:12,815
And this is used for handling user support.

00:18:12,815 --> 00:18:14,935
So the real question here is

00:18:14,935 --> 00:18:15,899
when you're talking about an API,

00:18:15,899 --> 00:18:18,441
how do you determine who the active user is?

00:18:18,441 --> 00:18:19,851
Because with a normal API request

00:18:19,851 --> 00:18:22,310
you don't really get any information about who's who.

00:18:22,310 --> 00:18:24,140
So the standard way of doing this

00:18:24,140 --> 00:18:25,607
is to provide some sort of

00:18:25,607 --> 00:18:27,722
information in the API request,

00:18:27,722 --> 00:18:30,291
to identify who it is that's making that request

00:18:30,291 --> 00:18:32,319
and you can do that with an Authorized header

00:18:32,319 --> 00:18:33,509
or however you'd like.

00:18:33,509 --> 00:18:35,108
So what I'm doing here is

00:18:35,108 --> 00:18:37,923
I'm making a new model in my SQLAlchemy database,

00:18:37,923 --> 00:18:39,334
just a User model,

00:18:39,334 --> 00:18:41,250
the user has an id and a name,

00:18:41,250 --> 00:18:43,084
and it also has an API key,

00:18:43,084 --> 00:18:44,974
which will be used to look up

00:18:44,974 --> 00:18:47,626
which key references which user.

00:18:47,626 --> 00:18:49,909
And then I'm using Flask-Login

00:18:49,909 --> 00:18:55,235
to set up a login manager

00:18:55,235 --> 00:18:57,444
and when a request comes in,

00:18:57,444 --> 00:18:59,042
it's going to automatically load

00:18:59,042 --> 00:19:01,146
the user from the Authorization header

00:19:01,146 --> 00:19:03,024
if that user exists.

00:19:03,024 --> 00:19:05,746
So the nice thing about this is

00:19:05,746 --> 00:19:07,789
once we've set up Flask-Login in this way,

00:19:07,789 --> 00:19:11,036
we can use some of the nice utilities that it provides as well.

00:19:11,036 --> 00:19:13,545
Such as there's a "current_user" pointer.

00:19:13,545 --> 00:19:16,079
So I've created a new route here,

00:19:16,079 --> 00:19:17,580
that is just "who am I?",

00:19:17,580 --> 00:19:19,440
and if you access this route

00:19:19,440 --> 00:19:21,082
it will tell you who you are,

00:19:21,082 --> 00:19:22,535
or if you're an anonymous user.

00:19:22,535 --> 00:19:25,145
And I've just created this "Jack London" user in my database

00:19:25,145 --> 00:19:26,226
for simplicity.

00:19:26,226 --> 00:19:30,190
You can also use "login_required" and other decorators

00:19:30,190 --> 00:19:31,421
provided by this module,

00:19:31,421 --> 00:19:33,887
so if there are certain APIs that are sensitive,

00:19:33,887 --> 00:19:36,419
that you only want to be accessible by certain users

00:19:36,419 --> 00:19:38,074
or only by logged in users in general

00:19:38,074 --> 00:19:39,531
rather than anonymous users,

00:19:39,531 --> 00:19:41,513
you can just apply this simple decorator

00:19:41,513 --> 00:19:43,930
and if you try to access that API

00:19:43,930 --> 00:19:45,718
without providing an Authorization header,

00:19:45,718 --> 00:19:48,405
it'll give you a 401 Unauthorized exception.

00:19:48,405 --> 00:19:51,276
Except that this is also sort of an ugly exception,

00:19:51,276 --> 00:19:54,866
because it's HTML instead of JSON,

00:19:54,866 --> 00:19:57,259
so we can do exactly the same thing as we did before,

00:19:57,259 --> 00:20:00,465
to convert that HTML exception into a JSON one,

00:20:00,465 --> 00:20:05,148
Just show that it's an Unauthorized error instead of a Not Found error.

00:20:05,148 --> 00:20:06,743
It's the same basic idea,

00:20:06,743 --> 00:20:08,095
Flask is pretty consistent.

00:20:08,095 --> 00:20:11,531
And I'd love to go on and tell you more

00:20:11,531 --> 00:20:13,499
about some of the awesome things you can do with Flask,

00:20:13,499 --> 00:20:16,075
such as pagination, rate-limiting,

00:20:16,075 --> 00:20:19,840
and even doing documentation for your API using Flask-APISpec,

00:20:19,840 --> 00:20:22,779
but unfortunately, I'm about out of time.

00:20:22,779 --> 00:20:25,063
So there's lots more that you can do with Flask,

00:20:25,063 --> 00:20:26,657
there's a whole ecosystem out there,

00:20:26,657 --> 00:20:28,135
and if you have any questions,

00:20:28,135 --> 00:20:29,465
I'd be happy to take them.

00:20:30,643 --> 00:20:37,677
(clapping)

00:20:37,677 --> 00:20:40,232
(MC) So we actually have about ten minutes for questions,

00:20:40,232 --> 00:20:41,902
if you would hold your hand up

00:20:41,902 --> 00:20:43,627
so that I can bring you the microphone,

00:20:43,627 --> 00:20:45,849
that way the recordings will capture it.

00:20:47,452 --> 00:20:48,631
Ah, here we go.

00:20:54,859 --> 00:20:57,135
(Questioner 1) Hey, probably a quick question.

00:20:59,474 --> 00:21:00,196
Over here.

00:21:00,196 --> 00:21:00,911
(David) Ah, thank you.

00:21:00,911 --> 00:21:04,368
(Questioner 1) With Flask-Marshmallow, if you have different fields

00:21:04,368 --> 00:21:05,604
you want to return,

00:21:05,604 --> 00:21:09,070
if it's a list versus if it's one item from the list,

00:21:09,070 --> 00:21:10,980
is that supported natively in there?

00:21:10,980 --> 00:21:15,197
(David) So with the Marshmallow schema that I was using,

00:21:15,197 --> 00:21:16,898
you can specify multiple equals true,

00:21:16,898 --> 00:21:18,386
when initializing your schema,

00:21:18,386 --> 00:21:20,926
and then it'll know that you're intending to return

00:21:20,926 --> 00:21:23,698
a list of multiple objects,

00:21:23,698 --> 00:21:25,567
instead of just a single one.

00:21:25,567 --> 00:21:27,635
(MC) Back here.

00:21:38,185 --> 00:21:40,400
(Questioner 2) So related to Flask-Marshmallow,

00:21:40,400 --> 00:21:42,939
if you ever have a relational database

00:21:42,939 --> 00:21:45,235
between your ORM stuff,

00:21:45,235 --> 00:21:46,645
can it handle that?

00:21:46,645 --> 00:21:50,319
Can you return data from multiple different tables, if there's

00:21:50,319 --> 00:21:51,771
a relation between them?

00:21:51,771 --> 00:21:54,913
(David) So Flask-SQLAlchemy natively supports

00:21:54,913 --> 00:21:56,941
working with multiple databases

00:21:56,941 --> 00:21:59,300
so you don't even have to have that as a layer in between

00:21:59,300 --> 00:22:00,778
SQLAlchemy and Marshmallow.

00:22:00,778 --> 00:22:04,541
You can actually set that up in your SQLAlchemy models itself.

00:22:04,541 --> 00:22:08,174
As I said, SQLAlchemy is an incredibly powerful

00:22:08,174 --> 00:22:09,241
and incredibly useful tool,

00:22:09,241 --> 00:22:10,278
and there's lots of great documentation

00:22:10,278 --> 00:22:11,438
on how to use it well.

00:22:11,438 --> 00:22:12,939
So that's what I would recommend.

00:22:12,939 --> 00:22:15,339
(Questioner 3) Hello, thanks for the talk.

00:22:15,339 --> 00:22:18,889
Have you considered using Flask-RESTful,

00:22:18,889 --> 00:22:20,732
or have you used it in the past,

00:22:20,732 --> 00:22:22,181
and what are your thoughts on it?

00:22:22,181 --> 00:22:24,586
(David) I have used Flask-RESTful in the past,

00:22:24,586 --> 00:22:26,854
and it's been a useful tool,

00:22:26,854 --> 00:22:29,417
however the problems I've had with it

00:22:29,417 --> 00:22:33,742
is that it's not as good at handling the intermediate representations

00:22:33,742 --> 00:22:37,028
between internal data and external data

00:22:37,028 --> 00:22:41,729
and I find that the way that you have to define your RESTful outputs,

00:22:41,729 --> 00:22:45,702
for whatever reason it doesn't really work with the way that my head thinks,

00:22:45,702 --> 00:22:49,335
I prefer being able to define each individual route by itself.

00:22:49,335 --> 00:22:50,974
There's also I believe,

00:22:50,974 --> 00:22:53,547
the same author of Marshmallow

00:22:53,547 --> 00:22:58,100
has written a couple of other pieces to work with it as well,

00:22:58,100 --> 00:22:58,981
I think it was originally called

00:22:58,981 --> 00:23:00,004
Flask-Smore,

00:23:00,004 --> 00:23:02,260
because it was an extension of Marshmallow,

00:23:02,260 --> 00:23:04,806
which does the same sort of thing that Flask-RESTful does,

00:23:04,806 --> 00:23:06,227
but I'll be honest, I've never used it.

00:23:06,227 --> 00:23:09,536
So I don't really have a very good

00:23:09,536 --> 00:23:10,423
answer to that question,

00:23:10,423 --> 00:23:11,804
aside from I've used RESTful in the past,

00:23:11,804 --> 00:23:14,040
it was fine, but it's not as nice

00:23:14,040 --> 00:23:15,484
as these things that I've demoed here,

00:23:15,484 --> 00:23:16,487
in my opinion.

00:23:16,487 --> 00:23:21,838
(MC) OK, anything else? No, I think we're done.

00:23:21,838 --> 00:23:23,371
Thanks David, that was great.

00:23:23,371 --> 00:23:24,471
(clapping)

00:23:24,471 --> 00:23:26,122

YouTube URL: https://www.youtube.com/watch?v=6RdZNiyISVU


