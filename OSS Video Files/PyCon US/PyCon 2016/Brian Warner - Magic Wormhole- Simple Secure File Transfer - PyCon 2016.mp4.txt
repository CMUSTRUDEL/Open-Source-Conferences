Title: Brian Warner - Magic Wormhole- Simple Secure File Transfer - PyCon 2016.mp4
Publication date: 2016-06-20
Playlist: PyCon 2016
Description: 
	"Speaker: Brian Warner

 ""magic-wormhole"" is a simple tool to move files from one computer to another, like ""scp"" but without the setup. By telling the recipient just a few secret words, the file is safely encrypted and delivered directly to the correct machine. The talk will explain the security mechanics, the cryptography (NaCl and SPAKE2), and how to use the underlying open-source library in your own applications.


Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides"
Captions: 
	00:00:00,240 --> 00:00:02,120
[applause]

00:00:02,120 --> 00:00:04,040
(Brian Warner) Hey everybody.

00:00:04,040 --> 00:00:06,000
Thank you so much for coming out today.

00:00:06,720 --> 00:00:09,300
Everybody, thanks for coming out today. My name is Brian Warner.

00:00:09,300 --> 00:00:11,320
I'm going to be talking about a file transfer project

00:00:11,320 --> 00:00:13,380
I've been working on called Magic Wormhole.

00:00:13,380 --> 00:00:17,560
If you go to magic-wormhole.io, that will take you to the Github page.

00:00:17,560 --> 00:00:19,900
There's a copy of the slides if you want to follow along.

00:00:19,900 --> 00:00:21,920
You can take a look at all the code.

00:00:23,000 --> 00:00:26,120
The obligatory biography: I've been working in Python

00:00:26,130 --> 00:00:28,809
for about 15 years or so. I created Buildbot

00:00:28,809 --> 00:00:31,880
a long, long time ago, in case you've heard of that one.

00:00:31,880 --> 00:00:35,100
The most recent thing I've put together that is getting some more usage

00:00:35,100 --> 00:00:37,060
is called Versioneer, so a little package

00:00:37,060 --> 00:00:39,920
to update your version every time you do a git commit.

00:00:39,920 --> 00:00:42,620
At a startup called AllMyData, I helped build a system

00:00:42,620 --> 00:00:45,940
called Tahoe-LAFS, a distributed encrypted data storage system

00:00:45,940 --> 00:00:47,949
that's getting a little bit of traction.

00:00:47,949 --> 00:00:50,649
At Mozilla I worked on Persona. I worked on the add-on SDK.

00:00:50,649 --> 00:00:52,620
I worked on the original version of Firefox Sync,

00:00:52,620 --> 00:00:55,400
and fans of the JPEG process there will probably recognize

00:00:55,400 --> 00:00:57,400
a few things in this project.

00:00:57,400 --> 00:00:59,440
And these days I'm working on Magic Wormhole.

00:00:59,449 --> 00:01:01,850
You can follow me on Twitter, Lotharrr with a triple R,

00:01:01,850 --> 00:01:03,840
or GitHub, warner.

00:01:04,610 --> 00:01:06,760
So Magic Wormhole is a file transfer program.

00:01:06,760 --> 00:01:09,200
This is about moving a file or a directory

00:01:09,200 --> 00:01:11,940
or some little bit of string from one machine to another.

00:01:11,940 --> 00:01:13,960
I bet everybody in this room has done this

00:01:13,960 --> 00:01:16,100
at least a dozen times in the last 24 hours.

00:01:16,100 --> 00:01:18,060
It's something that we do all the time.

00:01:18,060 --> 00:01:20,580
You might have used SSH to copy it from one place to another.

00:01:20,580 --> 00:01:24,040
You might have attached it in an email message.

00:01:24,040 --> 00:01:25,800
You might have put it into a shared directory

00:01:25,800 --> 00:01:27,600
where your co-workers could get to it.

00:01:27,600 --> 00:01:29,960
The use case for this is any of those -- you know,

00:01:29,960 --> 00:01:31,760
if you've got a cat video on your computer

00:01:31,760 --> 00:01:33,580
and you really want to give it to the person next to you,

00:01:33,580 --> 00:01:37,840
it should be easy to get it there in a safe, secure, simple fashion.

00:01:37,840 --> 00:01:40,840
I'm hoping to convince you that this tool is both easier and safer

00:01:40,840 --> 00:01:43,040
than all of the other tools -- all the other techniques

00:01:43,040 --> 00:01:44,960
that are typically used for this kind of thing,

00:01:44,960 --> 00:01:46,980
especially when there's not already a relationship

00:01:46,980 --> 00:01:48,740
between those two machines.

00:01:48,740 --> 00:01:51,100
So, you know, you two are sitting next to each other.

00:01:51,100 --> 00:01:52,980
The humans know each other but the computers

00:01:52,980 --> 00:01:54,700
don't yet know about each other.

00:01:54,700 --> 00:01:56,500
That's a use case that is usually solved

00:01:56,500 --> 00:01:59,960
with tools that I think are harder and less secure than this one.

00:01:59,960 --> 00:02:01,720
So what does it look like?

00:02:01,720 --> 00:02:03,660
First off, you do pip install magic wormhole.

00:02:03,660 --> 00:02:05,960
Please do that into a virtualenv. You saw Glyph's talk yesterday

00:02:05,960 --> 00:02:09,440
about why doing this into your root is a bad idea.

00:02:09,440 --> 00:02:12,000
Then on the sender side, there's a command-line tool,

00:02:12,000 --> 00:02:15,520
and you run 'wormhole send' and you give it the file name.

00:02:15,520 --> 00:02:18,700
That gives you a wormhole code, the string that prints out,

00:02:18,700 --> 00:02:20,700
the '7-guitarist-revenge'.

00:02:20,700 --> 00:02:23,590
You transcribe that. You get that to your recipient.

00:02:23,590 --> 00:02:26,500
So as one human to another, you give them this string.

00:02:26,500 --> 00:02:28,600
The other person runs 'wormhole receive'.

00:02:28,600 --> 00:02:30,500
They type in that string.

00:02:30,500 --> 00:02:33,180
Given that, the two programs can find each other.

00:02:33,180 --> 00:02:36,480
They can negotiate a shared, strong session key.

00:02:36,480 --> 00:02:39,500
They can encrypt the file, figure out how to get bytes

00:02:39,500 --> 00:02:41,660
from one side to the other, transfer it over,

00:02:41,660 --> 00:02:43,900
check the hash, acknowledge it.

00:02:43,900 --> 00:02:46,540
The kind of fanciful way I like to think about this

00:02:46,549 --> 00:02:50,660
is two wizards who are standing on hilltops on far sides of the planet

00:02:50,660 --> 00:02:53,439
and they speak the same magic spell into the air at the same time

00:02:53,439 --> 00:02:56,049
and someone goes, "Seven guitarist revenge!"

00:02:56,049 --> 00:02:59,200
And that causes this wormhole, this portal to pop open between them.

00:02:59,200 --> 00:03:01,600
And then they can kind of throw files and stuff through it.

00:03:01,600 --> 00:03:03,420
Things pop out of the other side.

00:03:03,420 --> 00:03:06,140
So think of that and you'll understand Magic Wormhole.

00:03:07,100 --> 00:03:10,400
So the wormhole code is kind of the key to this.

00:03:10,400 --> 00:03:13,540
It's a string that goes from the sending computer

00:03:13,540 --> 00:03:15,340
up to the sending human.

00:03:15,340 --> 00:03:17,400
The sending human reads that off the screen.

00:03:17,400 --> 00:03:19,200
The sending human transcribes that over

00:03:19,200 --> 00:03:21,000
to the receiving human via some channel.

00:03:21,000 --> 00:03:23,860
They can speak it, they can IM it, they can send it by email, whatever.

00:03:23,860 --> 00:03:26,540
And then the receiving human types that into the computer.

00:03:26,540 --> 00:03:30,940
So this is, at its heart, a way of getting two computers to meet each other

00:03:30,940 --> 00:03:34,140
via these two humans that have already met each other.

00:03:35,220 --> 00:03:37,760
So the human's job in this is to get that code

00:03:37,760 --> 00:03:40,600
from one machine off to the other.

00:03:41,160 --> 00:03:43,900
Now, you might think that file transfer is a solved problem.

00:03:43,900 --> 00:03:46,920
I mean, FTP, the, you know --

00:03:46,920 --> 00:03:49,520
everybody here has probably used FTP at one point or another.

00:03:49,520 --> 00:03:51,300
Or you're too young to have been born

00:03:51,300 --> 00:03:54,300
when the FTP RFC was actually published in 1980.

00:03:54,300 --> 00:03:57,280
You know, this has been around for so, so long.

00:03:57,280 --> 00:03:59,160
What's wrong with that? What's wrong with the tools

00:03:59,160 --> 00:04:01,060
that we're currently using for this?

00:04:01,580 --> 00:04:05,540
So, you can characterize these different tools

00:04:05,540 --> 00:04:09,460
by the amount of data that one human has to transcribe to the other.

00:04:09,460 --> 00:04:12,900
That's kind of the limiting factor in a UX thing.

00:04:12,900 --> 00:04:15,100
And I argue that all the common tools we have

00:04:15,100 --> 00:04:18,480
actually take more work and are less secure than this approach.

00:04:18,480 --> 00:04:21,690
So if -- the most obvious thing I might reach for

00:04:21,690 --> 00:04:24,460
is to include this file as an email attachment to you.

00:04:24,460 --> 00:04:26,780
In order for me to send you a file that way,

00:04:26,780 --> 00:04:30,120
I have to start by getting you to tell me your email address.

00:04:30,120 --> 00:04:32,700
So this email address has to travel in the opposite direction,

00:04:32,700 --> 00:04:35,940
and you have a transcription problem: I have to hear what you're saying

00:04:35,940 --> 00:04:37,889
and figure out how to type it accurately.

00:04:37,889 --> 00:04:39,820
And in the best case, you have an email address

00:04:39,820 --> 00:04:41,930
that's easy to spell and easy to understand

00:04:41,930 --> 00:04:44,480
and it's at some popular short-named provider.

00:04:44,480 --> 00:04:47,380
But in the worst case -- you know, most email addresses

00:04:47,380 --> 00:04:49,520
tend to be big and long and random because you're fighting

00:04:49,520 --> 00:04:53,340
for this contentious namespace at one of these providers.

00:04:53,340 --> 00:04:55,560
Another approach is to upload it to a server.

00:04:55,560 --> 00:04:57,700
If I have a server ready to go

00:04:57,700 --> 00:05:01,780
and I can think of a unique path on that server and I upload it,

00:05:01,780 --> 00:05:04,700
then I can dictate to you an even longer string.

00:05:04,710 --> 00:05:06,830
I have to tell you the domain name of my server and the path

00:05:06,830 --> 00:05:09,060
that I've allocated on that.

00:05:09,060 --> 00:05:11,060
You can upload it to something like Dropbox,

00:05:11,060 --> 00:05:14,500
which is a nice easy way of getting a file into a particular URL.

00:05:14,500 --> 00:05:16,780
But the URLs there are even longer because they have

00:05:16,780 --> 00:05:19,080
an even more difficult contention problem.

00:05:19,080 --> 00:05:22,840
You have a longer, more random string that's not human-selected.

00:05:22,840 --> 00:05:24,720
And the problem with all of those cases

00:05:24,720 --> 00:05:27,320
is that there's all these intermediaries that get to have

00:05:27,320 --> 00:05:30,460
access to the file that really don't need any access to the file.

00:05:30,460 --> 00:05:32,360
So the server that you put it on,

00:05:32,360 --> 00:05:35,820
the network links in between you and your recipient,

00:05:35,820 --> 00:05:38,140
if it's protected by TLS, great, but you're still vulnerable

00:05:38,140 --> 00:05:41,260
to the certificate authorities in the PKI world.

00:05:42,060 --> 00:05:44,480
You could transfer this over on a USB drive

00:05:44,480 --> 00:05:47,100
if you happen to be sitting right next to each other.

00:05:47,100 --> 00:05:49,940
But USB drives are kind of hard to erase.

00:05:49,940 --> 00:05:52,080
Flash memory, you know, doesn't forget

00:05:52,080 --> 00:05:53,980
quite as well as you would like it to.

00:05:53,980 --> 00:05:57,260
So now in terms of the security aspect, you have to think about

00:05:57,260 --> 00:05:59,400
what you're going to do with that USB drive next.

00:05:59,400 --> 00:06:01,620
And in addition, it's a little bit sketchy

00:06:01,620 --> 00:06:04,260
to take other people's USB drives and put them into your computer.

00:06:04,260 --> 00:06:06,159
There are enough bugs in the kernel drivers these days.

00:06:06,159 --> 00:06:09,560
You don't know what's going to happen to your system when you do that.

00:06:09,560 --> 00:06:12,400
Using SSH takes care of the security problems

00:06:12,400 --> 00:06:16,160
but transforms the UX problem into getting your public key

00:06:16,160 --> 00:06:18,000
onto that other person's machine.

00:06:18,000 --> 00:06:20,320
You know, if you've got a cat video and you wanted to give it to him,

00:06:20,320 --> 00:06:22,920
they have to give you an entire account on their machine.

00:06:22,920 --> 00:06:24,920
And then you have to get that entire public key

00:06:24,920 --> 00:06:28,440
over to their machine, and that's far too long to actually dictate.

00:06:28,440 --> 00:06:30,780
So nobody does that and you end up using

00:06:30,780 --> 00:06:33,920
some funky password thing for that bootstrapping part.

00:06:33,920 --> 00:06:36,620
In contrast to all of those, in Magic Wormhole, you send

00:06:36,620 --> 00:06:38,680
a very short string that's carefully designed

00:06:38,680 --> 00:06:44,100
to be transcribable and dictatable from the sender to the recipient.

00:06:44,100 --> 00:06:47,420
And that one string is the entire security --

00:06:47,420 --> 00:06:49,200
the entire accessibility path.

00:06:49,200 --> 00:06:51,440
You know, anybody in the world, any wizard on that hilltop that says

00:06:51,440 --> 00:06:54,360
that same Magic Wormhole code at the same time

00:06:54,360 --> 00:06:57,620
gets that one file, and nobody else.

00:06:58,900 --> 00:07:01,379
So if I've convinced you now that this is the easiest

00:07:01,380 --> 00:07:04,040
and safest way to move a file from one machine to another,

00:07:04,040 --> 00:07:06,140
then you probably want to know how it works.

00:07:06,140 --> 00:07:08,300
There are a couple of different phases to the protocol.

00:07:08,300 --> 00:07:11,420
It starts with a message exchange so the two nodes

00:07:11,420 --> 00:07:14,460
can just find each other and start exchanging messages at all.

00:07:14,460 --> 00:07:17,540
Then there's a key agreement phase where they use an algorithm called PAKE

00:07:17,540 --> 00:07:19,560
that I'll be telling you about in a little bit

00:07:19,560 --> 00:07:21,760
that lets them agree on a session key.

00:07:21,760 --> 00:07:24,419
Then they try and exchange their IP addresses.

00:07:24,420 --> 00:07:26,280
They try and use different techniques

00:07:26,280 --> 00:07:28,840
to get a direct connection between the two of them.

00:07:28,840 --> 00:07:30,760
Once they have that connection, they can run

00:07:30,760 --> 00:07:33,100
an encrypted data transfer protocol over that,

00:07:33,100 --> 00:07:36,040
move the file over, get the acknowledgement back.

00:07:37,960 --> 00:07:41,000
So, the clients exchange their initial messages

00:07:41,000 --> 00:07:43,900
through a rendezvous server. This is a simple relay

00:07:43,900 --> 00:07:45,940
that accepts messages from one side,

00:07:45,940 --> 00:07:48,740
hands them out to somebody who asked for them on the other side.

00:07:48,740 --> 00:07:53,820
This is something that I run for this particular program.

00:07:53,820 --> 00:07:57,220
The rendezvous server doesn't participate in this conversation.

00:07:57,220 --> 00:07:59,200
It's just facilitating it.

00:07:59,200 --> 00:08:01,319
And it's necessary because when this starts,

00:08:01,320 --> 00:08:04,660
the two clients don't know anything about each other other than

00:08:04,660 --> 00:08:08,180
there's somebody else out there using the same wormhole code.

00:08:08,180 --> 00:08:11,780
So the first part of that wormhole code is the channel ID --

00:08:11,780 --> 00:08:14,319
in this example, channel #1, but the numbers

00:08:14,320 --> 00:08:17,700
are just short integers. The server allocates those.

00:08:18,200 --> 00:08:24,260
The channel ID tells the server which -- two clients coming together

00:08:24,260 --> 00:08:28,000
using the same channel ID get messages from each other.

00:08:28,000 --> 00:08:32,120
The wormhole codes in general can be short because they cheat.

00:08:32,120 --> 00:08:35,480
You know, the URL for this service is baked into the client.

00:08:35,480 --> 00:08:38,280
Any two applications that are using the same wormhole mechanism

00:08:38,280 --> 00:08:40,380
will use the same server.

00:08:40,380 --> 00:08:42,740
And so you don't have to include it in the wormhole code.

00:08:42,740 --> 00:08:46,040
So in a lot of those other examples like uploading it to an FTP server,

00:08:46,040 --> 00:08:47,940
uploading it to a Dropbox thing, you have to include

00:08:47,940 --> 00:08:50,920
your domain name there to provide that context.

00:08:50,920 --> 00:08:54,580
The clients make a WebSocket connection to this machine

00:08:54,580 --> 00:08:56,900
and they exchange three or four, maybe five messages

00:08:56,900 --> 00:08:58,820
by the time that they're done.

00:08:59,940 --> 00:09:01,980
Now here's the really fun crypto part.

00:09:01,980 --> 00:09:04,639
So the first message they send across this connection

00:09:04,640 --> 00:09:06,760
that's being facilitated by the relay server

00:09:06,760 --> 00:09:09,140
is using a protocol called PAKE.

00:09:09,140 --> 00:09:12,520
PAKE stands for password authenticated key exchange.

00:09:12,520 --> 00:09:14,460
It is actually a family of protocols.

00:09:14,460 --> 00:09:16,440
There are a bunch of different ones that have been developed.

00:09:16,440 --> 00:09:19,500
The first one came out in the early '90s.

00:09:19,500 --> 00:09:22,460
SRP is probably the best known one, but the security proof on that

00:09:22,460 --> 00:09:24,260
is not really very good.

00:09:24,260 --> 00:09:27,100
It was kind of before we knew how to design protocols well.

00:09:27,100 --> 00:09:31,200
There's one called J-PAKE that we used in the first version of Firefox Sync.

00:09:31,200 --> 00:09:33,560
But these days, the one that is preferred by the community

00:09:33,560 --> 00:09:37,600
is called SPAKE2 which was made in 2005.

00:09:37,600 --> 00:09:41,800
These protocols allow two parties to turn a weak shared secret

00:09:41,800 --> 00:09:44,410
into a strong shared session key.

00:09:44,410 --> 00:09:46,340
So it's basically a box on one side

00:09:46,340 --> 00:09:48,620
and you put something like a password into it

00:09:48,620 --> 00:09:51,800
and it gets to exchange messages with its peer on the other side.

00:09:51,800 --> 00:09:55,060
And then at the end of the day, what pops out is a session key.

00:09:55,060 --> 00:10:00,720
And the rule is that if both sides put the same password in,

00:10:00,720 --> 00:10:03,460
then both sides get the same key out.

00:10:03,460 --> 00:10:05,800
And if the passwords are different, then they get keys out

00:10:05,800 --> 00:10:09,040
that are random and completely unrelated to each other.

00:10:09,040 --> 00:10:12,620
So this is a protocol that lets you take any short string

00:10:12,620 --> 00:10:16,070
and expand it into something larger

00:10:16,070 --> 00:10:19,240
that you can use for subsequent messages.

00:10:20,480 --> 00:10:22,680
So, SPAKE2, I'm not going to go into a great amount of detail

00:10:22,680 --> 00:10:24,440
on the math here.

00:10:24,440 --> 00:10:27,360
Feel free to talk to me later if you want some more details.

00:10:27,360 --> 00:10:32,680
But if you're familiar with Diffie-Hellman key exchange,

00:10:32,680 --> 00:10:35,820
key agreement, two parties agree upon a shared key,

00:10:35,820 --> 00:10:37,900
where you have one side sending g to the x,

00:10:37,900 --> 00:10:40,640
and the other side -- er, g to the a, and the other side sends g to the b

00:10:40,640 --> 00:10:43,620
and then you compute g to the a to the b or g to the b to the a,

00:10:43,620 --> 00:10:46,080
and because of commutative, those two things are the same.

00:10:46,080 --> 00:10:48,900
It's like that, except that the message that you send

00:10:48,900 --> 00:10:52,480
gets blinded by a factor drive from the password before you send it.

00:10:52,480 --> 00:10:55,840
So that u to the pw is the blinding factor that Alice puts on,

00:10:55,840 --> 00:10:58,180
and then Bob divides by u to the pw

00:10:58,180 --> 00:11:01,139
to take that blinding factor off before he uses it.

00:11:01,140 --> 00:11:04,020
So if the two sides are using the same blinding factors,

00:11:04,020 --> 00:11:06,580
then this behaves just like regular Diffie-Hellman,

00:11:06,580 --> 00:11:10,060
but you know that you could only come to the same key if the other person

00:11:10,060 --> 00:11:12,040
had exactly the same blinding factor.

00:11:12,040 --> 00:11:15,600
And because of the way that exponents work

00:11:15,600 --> 00:11:19,340
inside this kind of modular field, this is a random mapping

00:11:19,340 --> 00:11:22,540
and there's no way of knowing what that g to the a was

00:11:22,540 --> 00:11:25,660
unless you happen to have that same blinding factor.

00:11:25,660 --> 00:11:30,040
So this is super cool. I really love this algorithm.

00:11:30,040 --> 00:11:32,540
I wrote a pure Python implementation of this.

00:11:32,540 --> 00:11:36,220
It's using the Ed25519 curve so that it's pretty fast

00:11:36,220 --> 00:11:38,520
even though it's in pure Python.

00:11:38,520 --> 00:11:42,640
It has nice short keys and is super secure.

00:11:42,640 --> 00:11:45,340
And this one takes about 14 milliseconds to run.

00:11:45,340 --> 00:11:48,160
If we used the C implementation of this, you could probably improve that

00:11:48,160 --> 00:11:50,800
by a factor of ten, maybe a hundred.

00:11:50,800 --> 00:11:53,580
But it's good enough for an application like this

00:11:53,580 --> 00:11:55,460
where most of the time you're blocked

00:11:55,460 --> 00:11:57,640
waiting on the user to type in the thing.

00:11:58,360 --> 00:12:00,580
So PAKE is pretty awesome.

00:12:00,580 --> 00:12:03,100
It means that with a weak secret and some interaction,

00:12:03,100 --> 00:12:05,100
you can get to a strong secret.

00:12:05,100 --> 00:12:08,220
And it's basically trading off -- it's adding --

00:12:08,220 --> 00:12:12,380
it's spending interaction in order to prevent offline attacks.

00:12:12,380 --> 00:12:16,080
A passive eavesdropper who's watching your messages go by

00:12:16,080 --> 00:12:19,100
gets zero information about what your session key is.

00:12:19,100 --> 00:12:21,800
An active man in the middle, the best they can do

00:12:21,800 --> 00:12:24,200
is try to pretend to be Alice,

00:12:24,200 --> 00:12:26,300
try to pretend to be your conversation partner

00:12:26,300 --> 00:12:28,760
and try to guess what that key is.

00:12:28,760 --> 00:12:30,900
And if they succeed, then they can get in the middle,

00:12:30,900 --> 00:12:34,980
they can see your messages, but if they fail, you know that they failed.

00:12:34,980 --> 00:12:37,140
And they only get one guess.

00:12:37,140 --> 00:12:40,300
So this is great because even a short string --

00:12:40,300 --> 00:12:43,320
you can afford to allow somebody a one-in-a-million chance

00:12:43,320 --> 00:12:45,760
of guessing something if they only get one guess at it.

00:12:45,760 --> 00:12:50,060
And that's not true for offline things like encryption keys or passwords.

00:12:51,380 --> 00:12:54,700
The wormhole codes are the input to PAKE.

00:12:54,700 --> 00:12:57,440
So the wormhole code is generated

00:12:57,440 --> 00:13:00,140
by taking the channel ID that you allocated from the server.

00:13:00,140 --> 00:13:03,220
There's a word list. I'm using the PGP word list

00:13:03,220 --> 00:13:05,760
that I think was used for PGP phone or Zphone.

00:13:05,760 --> 00:13:08,960
And it's a list of words designed to be phonetically distinct

00:13:08,960 --> 00:13:13,300
so you can recognize them when they're coming over an audio channel.

00:13:13,300 --> 00:13:17,140
There are 256 words in there; os.urandom, choose one, choose one.

00:13:17,140 --> 00:13:19,300
So the default configuration is using two words

00:13:19,300 --> 00:13:21,820
and then this whole thing is fed into PAKE.

00:13:22,900 --> 00:13:27,300
That configuration gives us a 16-bit secret.

00:13:27,300 --> 00:13:30,480
You can change that. There's an option to use more words if you feel like it.

00:13:30,480 --> 00:13:36,520
But that means that there are 65,000 codes. These are single-use.

00:13:36,520 --> 00:13:39,720
So each time you send a file, you get a new code.

00:13:39,720 --> 00:13:42,960
Every time -- if you want to send a new file, you get a new code.

00:13:42,960 --> 00:13:45,480
You establish that new connection.

00:13:45,480 --> 00:13:49,160
And it has this really nice property here where the user --

00:13:49,160 --> 00:13:52,460
each time an attacker tries to guess this and fails,

00:13:52,460 --> 00:13:57,200
the user sees the failure screen. So they see a message like this, where:

00:13:57,200 --> 00:14:00,620
"I've tried to send your file. Something didn't go right.

00:14:00,620 --> 00:14:03,220
"Either you or your correspondent mistyped the code,

00:14:03,220 --> 00:14:05,400
"or somebody tried to attack you and they lost.

00:14:05,400 --> 00:14:07,360
"They guessed and they guessed wrong.

00:14:07,360 --> 00:14:09,940
"You can try again. That's going to give both you

00:14:09,940 --> 00:14:12,860
"and the attacker a second chance at this."

00:14:12,860 --> 00:14:17,880
So, because the size of the key space

00:14:17,880 --> 00:14:21,120
is large enough to keep the attacker

00:14:21,120 --> 00:14:23,600
from getting a good chance of getting through,

00:14:23,600 --> 00:14:26,940
the user has to be really, really, really patient

00:14:26,940 --> 00:14:29,460
and run this over and over and over again to give

00:14:29,460 --> 00:14:32,000
the attacker a better chance of going through.

00:14:32,000 --> 00:14:35,860
So you'd have to rerun this protocol and re-transcribe this string

00:14:35,860 --> 00:14:38,500
to your friend 650 times before the attacker

00:14:38,500 --> 00:14:40,960
has even a 1% chance of breaking through.

00:14:40,960 --> 00:14:43,240
And it's this nice and relatively rare situation

00:14:43,240 --> 00:14:46,540
where the laziness of the user improves the security.

00:14:46,540 --> 00:14:49,620
Their unwillingness to continue in the face of constant errors

00:14:49,620 --> 00:14:51,660
is a good thing.

00:14:51,660 --> 00:14:55,320
It's like, I had to reload the foot gun multiple times.

00:14:56,200 --> 00:14:58,160
OK, so that's enough about PAKE.

00:14:58,160 --> 00:14:59,960
Once the session key is established

00:14:59,960 --> 00:15:01,860
and they both have the same shared session key,

00:15:01,860 --> 00:15:03,790
then they can encrypt all of their subsequent messages.

00:15:03,790 --> 00:15:06,000
So everything else in this protocol gets encrypted from a key

00:15:06,000 --> 00:15:08,260
derived from that first one that comes out of PAKE.

00:15:08,260 --> 00:15:10,120
And this is kind of where the network plumbing aspect

00:15:10,120 --> 00:15:11,900
of the project comes -- takes over.

00:15:11,900 --> 00:15:15,580
So, after that phase is done, then the two sides use ifconfig

00:15:15,580 --> 00:15:19,220
to find out all their local IP addresses. And they listen on a TCP port.

00:15:19,220 --> 00:15:21,779
And then they send a message encrypted with a session key

00:15:21,780 --> 00:15:24,020
to say, "Hey, I'm listening here and here and here."

00:15:24,020 --> 00:15:26,200
And Bob says, "I'm listening here and here and here."

00:15:26,200 --> 00:15:28,260
And they try to connect to all of those.

00:15:28,260 --> 00:15:30,400
And the first connection that goes through

00:15:30,400 --> 00:15:32,980
and successfully answers an encrypted handshake,

00:15:32,980 --> 00:15:35,840
also derived from that PAKE key, is the winner

00:15:35,840 --> 00:15:38,020
and it stops using all of the other ones.

00:15:39,020 --> 00:15:41,000
This works out okay

00:15:41,000 --> 00:15:44,260
as long as one of the two sides has a public IP address --

00:15:44,260 --> 00:15:46,460
so like, one is a server that you're connecting to --

00:15:46,460 --> 00:15:49,140
or both sides are sitting on the same local network.

00:15:49,140 --> 00:15:51,540
So, two people sitting next to each other that want to exchange cat videos.

00:15:51,540 --> 00:15:54,060
They're both on the PyCon network. Their local addresses,

00:15:54,060 --> 00:15:57,340
their 10. or 192.168, will be able to see each other.

00:15:57,340 --> 00:16:00,060
And if you're moving something server, they can see that one.

00:16:00,060 --> 00:16:04,460
But if you have two people -- say you are calling my dad on the phone

00:16:04,460 --> 00:16:07,440
to say, "I want to send you this file, the code is" blah blah blah.

00:16:07,440 --> 00:16:10,280
He and I are both at home, both behind our NAT boxes.

00:16:10,280 --> 00:16:12,720
Those machines can't get to each other directly.

00:16:12,720 --> 00:16:15,320
So in this case, the client falls back

00:16:15,320 --> 00:16:18,080
to a relay server that I also run here.

00:16:18,080 --> 00:16:20,080
If you're familiar with STUN and TURN,

00:16:20,080 --> 00:16:22,080
this is the moral equivalent of a TURN server.

00:16:22,080 --> 00:16:24,980
It's again just a data relay that accepts two TCP connections

00:16:24,980 --> 00:16:27,980
that want to talk to each other and it glues them together.

00:16:28,860 --> 00:16:31,600
It's called the transit relay. This is not ideal.

00:16:31,600 --> 00:16:35,380
I'm working on adding techniques to do NAT hole punching

00:16:35,380 --> 00:16:38,380
to increase the frequency of connections -- the probability

00:16:38,380 --> 00:16:40,340
that a connection will be able to make a direct connection

00:16:40,340 --> 00:16:42,140
instead of going through this relay.

00:16:42,140 --> 00:16:44,020
But for the kind of traffic volume I'm expecting here,

00:16:44,020 --> 00:16:45,940
I don't expect this will be a big problem.

00:16:45,940 --> 00:16:48,700
And I just run this on a VPS somewhere off in the cloud.

00:16:49,940 --> 00:16:52,540
Once that handshake is complete,

00:16:52,540 --> 00:16:56,020
then the actual file data gets sent through an encrypted record pipe.

00:16:56,020 --> 00:16:58,660
So this is using the NaCl SecretBox.

00:16:58,660 --> 00:17:02,820
This is using libsodium, the Python bindings to that.

00:17:02,820 --> 00:17:06,420
Each record gets encrypted by a unique nonce, gets sent.

00:17:06,420 --> 00:17:08,940
There are different keys in each direction.

00:17:08,940 --> 00:17:12,820
All these keys are derived from that same original PAKE master key.

00:17:12,820 --> 00:17:17,480
And as the data gets sent over, it gets hashed.

00:17:17,480 --> 00:17:20,240
The receiving end is hashing all of those bytes.

00:17:20,240 --> 00:17:22,080
And then the acknowledgement message says,

00:17:22,080 --> 00:17:23,920
"Here's the hash of everything that I have received from you."

00:17:23,920 --> 00:17:26,500
So that's a good strong way to making sure our record didn't get dropped

00:17:26,500 --> 00:17:30,700
or some funky network error caused something to get dropped.

00:17:30,700 --> 00:17:35,000
The secret box function is an authenticated encryption cypher.

00:17:35,000 --> 00:17:37,880
So flipping bits -- an attacker trying to flip the bits along the way,

00:17:37,880 --> 00:17:41,140
that gets detected as soon as a single record goes by.

00:17:43,180 --> 00:17:45,000
So that's how the application works.

00:17:45,000 --> 00:17:47,020
This is built on top of an API

00:17:47,020 --> 00:17:49,520
that you can use in your own applications.

00:17:49,520 --> 00:17:52,360
You -- each application that wants to use this

00:17:52,360 --> 00:17:57,300
has an application identifier that scopes the channel IDs

00:17:57,309 --> 00:18:00,280
so that two different applications using different identifiers

00:18:00,280 --> 00:18:04,260
aren't fighting for each other for the short, easy-to-transcribe codes.

00:18:04,260 --> 00:18:07,320
There's a relay URL that you pass into the application

00:18:07,320 --> 00:18:11,360
and the one that I run that people are free to use is in a file.

00:18:11,360 --> 00:18:15,180
It's just a constant definition inside the package.

00:18:15,180 --> 00:18:17,520
You then set the code.

00:18:17,520 --> 00:18:20,920
You can also ask the wormhole to allocate for you a brand new code

00:18:20,920 --> 00:18:23,120
and that'll go to the server and find a channel.

00:18:23,120 --> 00:18:27,020
You can actually have -- let's see, there's another call called input code

00:18:27,020 --> 00:18:29,440
that does Tab completion on the words as you type them in.

00:18:29,440 --> 00:18:31,400
So when I'm typing in "7-guitarist-revenge,"

00:18:31,400 --> 00:18:34,100
I only actually have to hit Tab and it goes to the server

00:18:34,100 --> 00:18:36,020
and says, "There's only one channel allocated right now

00:18:36,020 --> 00:18:38,100
"and that's 7, so let me fill that in for you."

00:18:38,100 --> 00:18:41,200
And then I type "GU" and I hit tab and there's a couple of words

00:18:41,200 --> 00:18:43,980
that start with "G-U" in the list and it shows me what they are.

00:18:43,980 --> 00:18:47,400
So it's actually really fast to go and type these things in.

00:18:47,400 --> 00:18:49,659
And if you think about it from an information theory point of view,

00:18:49,660 --> 00:18:51,840
you're only entering in 16 bits of data.

00:18:51,840 --> 00:18:53,620
So obviously, you should be able to do that

00:18:53,620 --> 00:18:55,440
with a very small number of keystrokes.

00:18:55,440 --> 00:18:57,280
But it makes it something nice and easy to transcribe

00:18:57,280 --> 00:19:00,100
and easy to pronounce. Then you send a binary.

00:19:00,100 --> 00:19:02,820
You send byte strings and you get byte strings back.

00:19:02,820 --> 00:19:07,040
This works in both Python 2, Python 3.3, 3.4, 3.5,

00:19:07,040 --> 00:19:09,580
maybe PyPy. I'm not sure.

00:19:09,580 --> 00:19:13,300
The library -- the API handles all the network protocols, all the encryption.

00:19:13,300 --> 00:19:17,120
All that is taken care of under the covers.

00:19:17,120 --> 00:19:19,200
And by the end of the sprints, I will have

00:19:19,200 --> 00:19:21,820
both the blocking interface to this and the Twisted interface to this.

00:19:21,820 --> 00:19:23,720
I broke the blocking interface about a week ago

00:19:23,720 --> 00:19:25,740
when I was making some major changes.

00:19:26,960 --> 00:19:29,740
So, the direction that I want to take this, there --

00:19:29,740 --> 00:19:33,180
I definitely want to have a nice easy GUI application for this.

00:19:33,180 --> 00:19:36,320
This is calling out for something better than a command-line tool.

00:19:36,320 --> 00:19:38,631
And you should be able to drag and drop a file onto it.

00:19:38,640 --> 00:19:40,560
It shows you the code. You should be able to click a button

00:19:40,560 --> 00:19:44,720
and type in the code and a file pops out into your downloads folder.

00:19:44,720 --> 00:19:47,060
I think it'd be great to have a browser extension for this,

00:19:47,060 --> 00:19:51,080
probably even a web-deployed webpage form of this.

00:19:51,080 --> 00:19:55,420
The protocol is speaking WebSockets to the relay rendezvous server

00:19:55,420 --> 00:19:58,860
specifically so that I can then have a web-based form of this

00:19:58,860 --> 00:20:01,540
interoperate with a command-line base.

00:20:01,540 --> 00:20:05,180
I'm looking to add to the range of transports that it can do.

00:20:05,180 --> 00:20:08,080
Two browser-based implementations could totally use web RTC

00:20:08,080 --> 00:20:11,120
to connect to each other and avoid having to use my relay server.

00:20:11,120 --> 00:20:13,120
Other people smarter than me have already figured out

00:20:13,120 --> 00:20:16,240
all of the STUN/TURN, STUN/ICE kinds of stuff,

00:20:16,240 --> 00:20:18,580
so we should be able to take advantage of that.

00:20:18,580 --> 00:20:23,090
Running this over a Tor Onion service is a great way of bypassing the NATs,

00:20:23,090 --> 00:20:25,080
the NAT barriers.

00:20:25,080 --> 00:20:28,620
I'm hoping to try and get the SPAKE2 algorithm added to libsodium,

00:20:28,620 --> 00:20:31,640
and that will make it easier to extend this to other languages,

00:20:31,640 --> 00:20:34,420
so that there are lots of -- there are Go bindings

00:20:34,420 --> 00:20:37,140
and Rust bindings and JavaScript bindings to libsodium.

00:20:37,140 --> 00:20:39,220
And this would make it easier to write a client for this

00:20:39,220 --> 00:20:41,120
in those other languages.

00:20:41,440 --> 00:20:44,660
And then I'm really interested in seeing this used beyond file transfer.

00:20:44,660 --> 00:20:46,600
I want people to think of this as a tool

00:20:46,600 --> 00:20:48,600
that they can use in their applications

00:20:48,600 --> 00:20:52,580
anytime you need to deliver a credential from one place to another.

00:20:52,580 --> 00:20:56,100
So, think about -- you have your mobile app,

00:20:56,100 --> 00:20:58,780
and to attach that mobile app to your --

00:20:58,780 --> 00:21:02,600
to an account on some server, it needs to have some token.

00:21:02,600 --> 00:21:05,220
Or you have two client devices and they want to go

00:21:05,220 --> 00:21:07,480
and talk to each other, some kind of messaging thing.

00:21:07,480 --> 00:21:09,860
And you need a way of getting a key from one of those machines

00:21:09,860 --> 00:21:11,780
to the other so they know about each other.

00:21:11,780 --> 00:21:14,500
A lot of this comes down to that same introduction task,

00:21:14,500 --> 00:21:16,700
where there are two humans that know about each other

00:21:16,700 --> 00:21:18,520
and they have their devices.

00:21:18,520 --> 00:21:21,060
And the humans are introducing the devices to each other.

00:21:21,060 --> 00:21:23,090
It's like, "Hi there, Bob, this is my computer."

00:21:23,090 --> 00:21:25,640
And it's more like, "Hi there, Bob's computer, this is my computer."

00:21:25,640 --> 00:21:27,920
And you want to connect those.

00:21:27,929 --> 00:21:31,730
So provisioning a client in this sort of world would --

00:21:31,730 --> 00:21:37,580
the old way, the typical way this is done is to go to a website,

00:21:37,580 --> 00:21:40,720
create an account, type in a password to that account,

00:21:40,720 --> 00:21:42,780
remember the password, deal with the fact

00:21:42,780 --> 00:21:45,020
that people generate really lousy passwords.

00:21:45,020 --> 00:21:47,960
It's just outstanding how bad passwords are

00:21:47,960 --> 00:21:49,780
from a usability point of view.

00:21:49,780 --> 00:21:51,600
And then you install the mobile app

00:21:51,600 --> 00:21:53,640
and you type the same password into that.

00:21:53,640 --> 00:21:55,880
So, passwords are bad.

00:21:55,880 --> 00:21:58,360
Remembering passwords is a hassle.

00:21:58,960 --> 00:22:01,120
Another approach if you have a tool like this

00:22:01,120 --> 00:22:03,020
is that you go to the server and you say,

00:22:03,020 --> 00:22:05,640
"I'd like to add a new device.

00:22:05,640 --> 00:22:08,400
"Tell me an invitation code for it. Tell me a wormhole code for it."

00:22:08,400 --> 00:22:10,420
And then you type that into your phone.

00:22:10,420 --> 00:22:12,340
That runs this protocol and it gets a token

00:22:12,340 --> 00:22:16,480
dedicated to that one device, and now you're done.

00:22:16,480 --> 00:22:19,080
You know, you could set it up so that you ask the server

00:22:19,080 --> 00:22:21,160
to email you a code.

00:22:21,160 --> 00:22:23,360
A nice thing about these codes that I forgot to mention before

00:22:23,360 --> 00:22:25,220
is that they're forward-secure.

00:22:25,220 --> 00:22:28,160
Once you finish that PAKE message, once you exchange those two messages,

00:22:28,160 --> 00:22:30,640
you can reveal the code and not lose any security.

00:22:30,650 --> 00:22:32,909
So it's a single use and it's not secret

00:22:32,909 --> 00:22:35,630
outside that really narrow window from the time you start that process

00:22:35,630 --> 00:22:38,720
to the time that the other side sends their message.

00:22:38,720 --> 00:22:41,900
So the fact that this code is still sitting around an email

00:22:41,900 --> 00:22:44,400
for a long period of time doesn't hurt you.

00:22:44,400 --> 00:22:47,540
Same reason that you'd never email password resets.

00:22:47,540 --> 00:22:49,940
You never send the new password out in email.

00:22:49,940 --> 00:22:53,420
You send a token that can get used a single time to go and reset it.

00:22:53,980 --> 00:22:56,260
In a messaging app, something like Signal --

00:22:56,260 --> 00:22:58,980
so the crypto in Signal is great.

00:22:58,980 --> 00:23:03,240
But the way that it works is that when I want to talk to Bob,

00:23:03,240 --> 00:23:06,840
I ask the central Signal server for Bob's public key.

00:23:06,840 --> 00:23:08,600
And then I start using that.

00:23:08,600 --> 00:23:11,720
There are some hidden options in there to let you verify the key.

00:23:11,720 --> 00:23:14,200
If you meet Bob in person, you can compare your keys.

00:23:14,200 --> 00:23:16,620
But fundamentally you're depending upon that server

00:23:16,620 --> 00:23:19,340
to give you the right key. And the model that I'd like to see

00:23:19,340 --> 00:23:22,630
is where I'm standing next to somebody right now

00:23:22,630 --> 00:23:25,260
and I want to get our two machines to know about each other.

00:23:25,260 --> 00:23:28,090
So I should be able to go to my device and go to the address book

00:23:28,090 --> 00:23:29,940
and say, "Plus," you know, "invite somebody."

00:23:29,940 --> 00:23:32,940
And it says, "Here's the code." And they type in that code

00:23:32,940 --> 00:23:35,039
or, I don't know, a QR code, something --

00:23:35,040 --> 00:23:37,780
the two devices have that physical proximity right now.

00:23:37,780 --> 00:23:40,620
They can leverage that to transfer something small across,

00:23:40,620 --> 00:23:42,560
and then use this protocol to ask each other

00:23:42,560 --> 00:23:46,370
for the full-blown public key so that you're not vulnerable

00:23:46,370 --> 00:23:49,900
to anybody outside of this ecosystem other than those two programs.

00:23:50,720 --> 00:23:55,280
So, my -- the real reason that I'm building this tool

00:23:55,280 --> 00:23:59,280
is because PAKE is a really interesting cryptographic tool

00:23:59,280 --> 00:24:02,140
that is a primitive that we should be able to use

00:24:02,140 --> 00:24:04,059
and is not yet in our toolbox.

00:24:04,060 --> 00:24:08,980
The history of cryptography and of techniques

00:24:08,980 --> 00:24:11,060
has this really long lag time.

00:24:11,060 --> 00:24:13,760
You know, symmetric encryption is something that I'd say,

00:24:13,760 --> 00:24:15,620
you know, maybe half the developers that I talk to

00:24:15,620 --> 00:24:17,940
are comfortable using that in a product.

00:24:17,940 --> 00:24:20,420
Some of them think it's a little bit, you know, out there.

00:24:20,420 --> 00:24:23,260
But it's been around since, what, Julius Caesar days, right,

00:24:23,260 --> 00:24:26,650
like 800 BC, what?

00:24:26,650 --> 00:24:31,820
So there's a set of tools that are slowly coming into general use.

00:24:31,820 --> 00:24:34,960
Hashes: most people are comfortable with hashes at this point.

00:24:34,960 --> 00:24:38,360
Digital signatures: that's showing up in a lot of applications.

00:24:38,360 --> 00:24:41,820
Public key cryptography: it's been around for 50 years

00:24:41,820 --> 00:24:45,140
and it's still just becoming something that people are comfortable using.

00:24:45,150 --> 00:24:47,100
PAKE has been around since the '90s.

00:24:47,100 --> 00:24:49,480
It enables a lot of really interesting use cases

00:24:49,480 --> 00:24:51,840
and really a lot of interesting operational modes.

00:24:51,840 --> 00:24:54,300
But I think to get it into the hands of developers,

00:24:54,300 --> 00:24:58,960
you need to have some clear examples, some clear --

00:24:58,960 --> 00:25:01,860
the academic community needs to say, "This algorithm is good.

00:25:01,860 --> 00:25:04,040
"Use this and it'll do what you expect it to do."

00:25:04,040 --> 00:25:07,000
You need libraries that are easy to use.

00:25:07,000 --> 00:25:10,080
You need applications that use it so you can feel comfortable,

00:25:10,080 --> 00:25:12,720
you can say, "I'm not going this alone. That person over there is doing it.

00:25:12,720 --> 00:25:15,580
"Everybody's doing it. Maybe it's okay for me to do it too."

00:25:15,580 --> 00:25:18,640
So, file transfer -- it's a kind of pedestrian application.

00:25:18,640 --> 00:25:20,520
I found it to be really handy myself, actually,

00:25:20,520 --> 00:25:23,100
more convenient than SSH in some cases,

00:25:23,100 --> 00:25:25,360
just moving files between my own servers.

00:25:25,360 --> 00:25:28,800
But it's not exactly an exciting use case.

00:25:28,800 --> 00:25:30,700
But it is kind of a foot in the door.

00:25:30,700 --> 00:25:33,400
You know, being able to use PAKE, being able to use a short secret

00:25:33,400 --> 00:25:36,180
to bootstrap to a larger secret is the rest of the stuff

00:25:36,180 --> 00:25:38,120
that I want people have access to.

00:25:38,120 --> 00:25:42,440
So of the stuff in your toolbox, let's add PAKE to that list.

00:25:42,880 --> 00:25:45,540
So that's the project. If you go to magic-wormhole.io,

00:25:45,540 --> 00:25:47,440
that will bounce you over to the GitHub page

00:25:47,440 --> 00:25:51,180
where you can take a look at a copy of these slides, the code.

00:25:51,180 --> 00:25:53,039
Pip install magic wormhole is how you get it.

00:25:53,040 --> 00:25:55,600
That gets you the wormhole binary. And you can send me email

00:25:55,600 --> 00:25:57,920
or contact me on Twitter, Lotharrr with the triple r.

00:25:57,920 --> 00:25:59,880
Thank you very much.

00:25:59,880 --> 00:26:01,880
[applause]

00:26:01,880 --> 00:26:04,280
Oh! And I have stickers.

00:26:05,420 --> 00:26:07,800
I'll take questions and I'll throw out stickers.

00:26:08,920 --> 00:26:10,840
And if you want questions, please come to the microphones

00:26:10,840 --> 00:26:12,640
in the two aisles there.

00:26:13,320 --> 00:26:15,220
(audience member) I have a question, sir.

00:26:15,220 --> 00:26:17,440
For that initial relay, right?

00:26:17,440 --> 00:26:19,200
(Brian Warner) The initial relay? Yeah.

00:26:19,200 --> 00:26:21,520
(audience member) I have a NAP ID which I imagine

00:26:21,520 --> 00:26:25,880
is not private information. It's kind of public. It's stored.

00:26:25,880 --> 00:26:28,060
It's shared with your clients and whatnot.

00:26:28,060 --> 00:26:30,140
Then I have a channel ID,

00:26:30,140 --> 00:26:34,380
which is meant to be private. And then the two words, right?

00:26:34,380 --> 00:26:38,440
What stops a malicious third party from just spamming your relay server

00:26:38,440 --> 00:26:41,720
with the same NAP ID and random channel IDs?

00:26:41,720 --> 00:26:43,580
(Brian Warner) Nothing.

00:26:43,580 --> 00:26:46,260
One problem with this approach, with this protocol,

00:26:46,260 --> 00:26:49,860
is that it's kind of vulnerable to denial of service attacks.

00:26:49,860 --> 00:26:51,860
Because there's so little information somebody needs

00:26:51,860 --> 00:26:54,560
to participate in it, there's not a very high barrier

00:26:54,560 --> 00:26:56,820
to prevent somebody from participating in it.

00:26:56,830 --> 00:26:59,320
So my thoughts for that are to add a layer on top

00:26:59,320 --> 00:27:02,320
where you have to get -- there's some sort of rate-limiting thing, right?

00:27:02,320 --> 00:27:04,320
It's like, I have to go to some central server

00:27:04,320 --> 00:27:07,240
to get a ticket that allows me to submit a message

00:27:07,240 --> 00:27:09,120
to that rendezvous server.

00:27:09,120 --> 00:27:11,900
And the person who's trying to do the denial of service attack

00:27:11,900 --> 00:27:13,880
runs up against some rate-limiting boundary.

00:27:13,880 --> 00:27:15,620
Maybe you do a Captcha thing.

00:27:15,620 --> 00:27:18,039
Maybe you have to be signed into some other service

00:27:18,040 --> 00:27:20,300
and they can count how many tickets people are requesting

00:27:20,300 --> 00:27:22,480
and then terminate that as an abuse thing.

00:27:22,480 --> 00:27:25,280
So it'll be something in that category, I think.

00:27:25,840 --> 00:27:27,240
Yeah?

00:27:27,240 --> 00:27:30,060
(audience member) Is it correct that the PAKE process

00:27:30,060 --> 00:27:32,000
to derive the session key

00:27:32,000 --> 00:27:34,860
requires real-time communication between the sender and receiver?

00:27:34,860 --> 00:27:38,360
(Brian Warner) Yes, it doesn't -- not strictly real time

00:27:38,360 --> 00:27:40,909
but it requires a couple of messages to be exchanged.

00:27:40,909 --> 00:27:43,780
So PAKE emits one message and then waits for one message

00:27:43,780 --> 00:27:47,080
coming from the other side before you have the shared session key.

00:27:47,080 --> 00:27:49,860
Then there's a key confirmation message to make sure that somebody

00:27:49,860 --> 00:27:52,340
really did get the right session key and not something else.

00:27:52,340 --> 00:27:54,480
And then you send all of your regular messages.

00:27:54,480 --> 00:27:57,320
I'm working on a mode of this that's more persistent.

00:27:57,320 --> 00:28:00,960
So at the moment, it makes that WebSocket connection.

00:28:00,960 --> 00:28:04,480
If that drops, then the server abandons the channel and you have to start again.

00:28:04,480 --> 00:28:06,620
So these two programs have to be running concurrently

00:28:06,620 --> 00:28:09,080
for at least a couple of seconds in order to make this work.

00:28:09,080 --> 00:28:12,060
The persistent mode that I'm working on would be more "store and forward

00:28:12,060 --> 00:28:14,680
"and come back again later," so that in a longer-running,

00:28:14,680 --> 00:28:17,860
like a messaging application, it could be "start the process,

00:28:17,860 --> 00:28:20,440
"shut down, turn on again tomorrow, get the receive --

00:28:20,440 --> 00:28:23,360
"get the receipt, send the next message, do it again there."

00:28:24,680 --> 00:28:27,700
(audience member) So my question comes from the Tab complete.

00:28:27,700 --> 00:28:34,340
So, say there's only one channel, 7, and you put in the G.

00:28:34,340 --> 00:28:36,300
You can now Tab complete and see the things.

00:28:36,300 --> 00:28:39,020
Doesn't that make it easier to guess? Or -- because maybe

00:28:39,020 --> 00:28:41,160
there's only five keywords that are currently in use.

00:28:41,160 --> 00:28:43,340
(Brian Warner) Yeah, but you're not revealing

00:28:43,340 --> 00:28:46,580
to the attacker what you hit before you hit Tab.

00:28:46,580 --> 00:28:49,780
So it's your local agent that knows the fixed list of words

00:28:49,780 --> 00:28:51,640
that the codes were chosen from.

00:28:51,649 --> 00:28:56,399
And then it's just an easier affordance to get to that word faster.

00:28:56,400 --> 00:28:59,460
The total amount of information you're typing in is still 16 bits.

00:28:59,460 --> 00:29:03,600
And you can almost think of it like "G, Tab" is like Huffman encoding

00:29:03,600 --> 00:29:05,920
when you have a fixed alphabet.

00:29:05,920 --> 00:29:08,920
One thing I'm looking to add to it is a way to have alternate word lists.

00:29:08,920 --> 00:29:12,899
So when you get the channel, when the client goes to the server

00:29:12,900 --> 00:29:14,860
and says, "Hey, I want to use channel 7,"

00:29:14,860 --> 00:29:17,120
it can say, "Oh, I got this hint from the other side

00:29:17,120 --> 00:29:20,120
"that we are using Dutch for this particular word list.

00:29:20,120 --> 00:29:22,420
"So switch to that alternate word list."

00:29:22,420 --> 00:29:25,140
And then you're not losing any more information

00:29:25,140 --> 00:29:27,440
than you would if you didn't reveal that,

00:29:27,440 --> 00:29:30,620
because you were only using 256 words in any given list anyway.

00:29:30,620 --> 00:29:32,640
(audience member) Gotcha. This is a cool package.

00:29:32,640 --> 00:29:34,400
(Brian Warner) Thank you.

00:29:35,160 --> 00:29:38,800
(audience member) So, 16 bits of entropy, and it's time bound.

00:29:38,800 --> 00:29:41,040
(Brian Warner) Yeah. And single-use bound.

00:29:41,040 --> 00:29:43,120
(audience member) Single-use bound for one file; that's cool.

00:29:43,120 --> 00:29:45,500
However, you're providing a library.

00:29:45,500 --> 00:29:47,480
Developers are going to use this

00:29:47,480 --> 00:29:49,960
for all sorts of things that you didn't expect.

00:29:49,960 --> 00:29:52,480
I'm imagining someone building, like, a backup software.

00:29:52,480 --> 00:29:56,020
So I transfer the contents of my whole hard drive to the server.

00:29:56,020 --> 00:29:58,300
Now we're talking half a million files.

00:29:58,300 --> 00:30:01,300
That seems like a much bigger attack surface

00:30:01,300 --> 00:30:05,320
than you are anticipating in your example use case.

00:30:05,320 --> 00:30:07,540
Have you thought about that? How do you want to mitigate it?

00:30:07,540 --> 00:30:11,600
(Brian Warner) Yeah. The way to characterize

00:30:11,600 --> 00:30:16,540
the attack rate is going to be: an attacker chooses to attack

00:30:16,540 --> 00:30:19,100
some percentage, some fraction of all the connections

00:30:19,100 --> 00:30:21,260
that are going through there. They're going to be successful

00:30:21,260 --> 00:30:24,520
with some other fraction of those attempts,

00:30:24,520 --> 00:30:26,520
depending on how long that word length is.

00:30:26,520 --> 00:30:29,700
And then they'll be successful with whatever -- you know,

00:30:29,700 --> 00:30:31,700
if somebody attacks every single connection once --

00:30:31,700 --> 00:30:33,630
the worst-case attack here is probably where somebody

00:30:33,630 --> 00:30:35,500
is camped out on your server.

00:30:35,500 --> 00:30:37,400
They watch all the connections going through.

00:30:37,400 --> 00:30:40,100
And for every single attack they do,

00:30:40,100 --> 00:30:43,260
they attack once, and if they fail, then they don't touch that ever again.

00:30:43,260 --> 00:30:46,640
So any individual user is protected by that laziness thing

00:30:46,640 --> 00:30:48,540
because nobody's ever going to rerun this program

00:30:48,540 --> 00:30:51,200
enough times to be seriously vulnerable to it.

00:30:51,200 --> 00:30:54,220
But if they only ever attack any given person once, then maybe

00:30:54,220 --> 00:30:56,860
people will just be convinced that this program is kind of buggy

00:30:56,860 --> 00:30:58,800
and you have to do it a couple times to make it work.

00:30:58,800 --> 00:31:00,820
And then the attacker will successfully manage

00:31:00,820 --> 00:31:04,560
to get, you know, one out of every 65,000 of those people.

00:31:04,570 --> 00:31:07,789
The mitigations for that would be, first you're using this

00:31:07,789 --> 00:31:09,700
to establish a relationship.

00:31:09,700 --> 00:31:13,220
I'm looking to add a mode where once you have connected to --

00:31:13,220 --> 00:31:15,220
once you've transferred a file over there once,

00:31:15,220 --> 00:31:17,770
then it remembers the strong session key and uses that for next time.

00:31:17,770 --> 00:31:20,220
So that reduces the rate at which you're creating these things.

00:31:20,220 --> 00:31:22,639
You can also add extra words to this.

00:31:22,640 --> 00:31:26,400
You can say 'wormhole send --words=4' and get a bigger code space.

00:31:26,400 --> 00:31:29,360
And there are some post-connection verification options.

00:31:29,360 --> 00:31:32,720
'Wormhole send --verify' will show you a hash of the session key afterwards

00:31:32,720 --> 00:31:36,020
and you can verify those yourself before you continue forward.

00:31:36,020 --> 00:31:38,490
(audience member) OK. So it sounds like for --

00:31:38,490 --> 00:31:40,540
you're not really protecting against developers

00:31:40,540 --> 00:31:44,040
that are using this to send many, many of these

00:31:44,040 --> 00:31:46,880
at one time against a determined adversary?

00:31:46,880 --> 00:31:48,740
(Brian Warner) I am expecting that this is

00:31:48,740 --> 00:31:51,840
the kind of thing that is being run at human scale,

00:31:51,840 --> 00:31:55,060
like, there is a person driving this each time.

00:31:55,060 --> 00:31:56,980
If you have a machine driving it, then you can get

00:31:56,980 --> 00:31:59,720
a longer-term stronger key and keep on using that.

00:31:59,720 --> 00:32:01,580
So yeah, I think you're right.

00:32:01,580 --> 00:32:03,320
(audience member) Cool, thank you.

00:32:03,320 --> 00:32:05,200
(audience member) I have a totally different kind of question.

00:32:05,200 --> 00:32:07,540
And that is, I was just wondering who supports, you know,

00:32:07,540 --> 00:32:09,840
your work on this? Is that the Navy? Is it the State Department?

00:32:09,840 --> 00:32:11,620
(Brian Warner) This is me.

00:32:11,620 --> 00:32:13,500
This is just me because I wanted to see this protocol

00:32:13,500 --> 00:32:16,410
and this technique made available in more places.

00:32:16,410 --> 00:32:19,340
So I'm totally willing to spend the $20 a month to run the VPS to --

00:32:19,340 --> 00:32:21,520
(audience member) Yeah, I mean, but your time is just --

00:32:21,520 --> 00:32:23,460
(Brian Warner) Well, I am recommending that if people

00:32:23,460 --> 00:32:25,420
use this in a serious application, you may not want to depend

00:32:25,420 --> 00:32:28,120
upon me running this thing, and so the server that backs this

00:32:28,120 --> 00:32:30,360
is part of the same distribution.

00:32:30,360 --> 00:32:32,540
(audience member) But your development time is just --

00:32:32,540 --> 00:32:34,460
(Brian Warner) Yeah. This is totally a side project.

00:32:34,460 --> 00:32:36,360
(audience member) Yeah, I mean like, as somebody

00:32:36,360 --> 00:32:38,660
who could potentially use this, like this is the kind of basic research

00:32:38,660 --> 00:32:40,800
we as a community need to be supporting.

00:32:40,800 --> 00:32:43,300
(Brian Warner) Yeah. Last question?

00:32:44,540 --> 00:32:50,280
(audience member) So the attacker scenario you're looking at

00:32:50,280 --> 00:32:53,360
is more like eavesdropping and getting information.

00:32:53,360 --> 00:32:58,420
But what about just an attacker trying to execute denial of service?

00:32:58,420 --> 00:33:00,340
(Brian Warner) Yeah, yeah. Like I was saying earlier,

00:33:00,340 --> 00:33:02,240
its kind of vulnerable to that. Somebody can go through

00:33:02,240 --> 00:33:05,820
and just try to claim every single channel and just block other people's use of it.

00:33:05,820 --> 00:33:07,820
And so the best I can think of is Captcha of some sort

00:33:07,820 --> 00:33:10,180
to kind of slow that down.

00:33:10,180 --> 00:33:12,580
Thank you, everybody. Come on up. I got some cool stickers.

00:33:12,580 --> 00:33:19,880

YouTube URL: https://www.youtube.com/watch?v=oFrTqQw0_3c


