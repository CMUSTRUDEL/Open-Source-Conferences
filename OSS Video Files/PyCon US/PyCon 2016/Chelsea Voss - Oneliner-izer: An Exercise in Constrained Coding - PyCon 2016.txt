Title: Chelsea Voss - Oneliner-izer: An Exercise in Constrained Coding - PyCon 2016
Publication date: 2016-06-01
Playlist: PyCon 2016
Description: 
	Speaker: Chelsea Voss

We'll describe the ideas and implementation behind Oneliner-izer, a ""compiler"" which can convert most Python 2 programs into one line of code. As we discuss how to construct each language feature within this unorthodox constraint, we'll explore the boundaries of what Python permits and encounter some gems of functional programming – lambda calculus, continuations, and the Y combinator.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:01,460 --> 00:00:03,560
(moderator) Welcome, everyone.

00:00:05,360 --> 00:00:07,900
All right, we have now Chelsea Voss

00:00:07,900 --> 00:00:10,900
who's going to tell us all about Oneliner-izer.

00:00:12,340 --> 00:00:17,540
[applause]

00:00:17,540 --> 00:00:21,040
Thanks, is this on? Cool.

00:00:21,040 --> 00:00:24,300
Yeah, how many of you have programmed in Lisp

00:00:24,300 --> 00:00:27,180
or a similar functional programming language?

00:00:27,180 --> 00:00:31,900
Okay, you'll enjoy this, I hope.

00:00:31,900 --> 00:00:34,120
So this talk is about Oneliner-izer.

00:00:34,120 --> 00:00:38,239
Oneliner-izer is a compiler that converts Python programs

00:00:38,239 --> 00:00:41,710
into single lines, or one-liners.

00:00:41,710 --> 00:00:44,989
So in this talk I'm going to talk about how we do that,

00:00:44,989 --> 00:00:47,809
what kind of transformations we need to make on Python code

00:00:47,809 --> 00:00:49,660
in order for that to work,

00:00:49,660 --> 00:00:52,440
and I'll talk about building the compiler

00:00:52,440 --> 00:00:56,809
and hopefully give you an understanding of how this works.

00:00:56,809 --> 00:00:59,960
And we'll see some obscure details of Python along the way

00:00:59,960 --> 00:01:03,170
that maybe you wouldn't otherwise have had cause to learn.

00:01:03,170 --> 00:01:05,120
So I hope this will be fun.

00:01:05,960 --> 00:01:11,600
Let me give you an understanding of why I went about this.

00:01:11,610 --> 00:01:14,920
So there's this thing called the Python Bee at MIT.

00:01:14,920 --> 00:01:18,040
The Python Bee is this event that's held once every year

00:01:18,040 --> 00:01:23,250
where you have a bunch of people competing to spell out Python programs

00:01:23,250 --> 00:01:25,000
character by character.

00:01:25,000 --> 00:01:28,000
So you'll be given this problem --

00:01:28,000 --> 00:01:30,430
this is an example of a problem that appeared once --

00:01:30,430 --> 00:01:32,820
and you have to stand in front of the projector,

00:01:32,820 --> 00:01:38,860
not looking at your code, and spell out "d e f, space, f, dot dot dot."

00:01:41,100 --> 00:01:43,760
So that's fun, and a lot of people enjoy it.

00:01:43,760 --> 00:01:45,800
Here's an example of a program that you might spell out

00:01:45,810 --> 00:01:48,380
to solve something like this.

00:01:48,380 --> 00:01:52,610
So when I was doing this, I didn't really want to get hung up

00:01:52,610 --> 00:01:54,580
with newlines and tabs

00:01:54,580 --> 00:01:56,490
because one of the things that can really kill you

00:01:56,490 --> 00:02:02,430
is doing a newline and then doing the wrong number of tabs in your code.

00:02:02,430 --> 00:02:04,720
So what if I solved it in one line?

00:02:06,240 --> 00:02:10,940
You can do this in one line, like so, with a list comprehension

00:02:10,950 --> 00:02:14,140
and checking if false is in the list comprehension.

00:02:14,140 --> 00:02:17,920
By the way, this is equivalent if you weren't aware of all built-in.

00:02:17,920 --> 00:02:19,820
So that's pretty fun.

00:02:19,820 --> 00:02:23,040
But as the contest goes along, you get more and more difficult problems.

00:02:23,040 --> 00:02:25,230
Here is an example of a problem that might happen

00:02:25,230 --> 00:02:27,610
in some of the later stages.

00:02:27,610 --> 00:02:29,480
So this is something you might have to do.

00:02:29,480 --> 00:02:31,620
Estimate pi via random numbers.

00:02:33,820 --> 00:02:38,840
Okay, you can write your nice, imperative solution to this.

00:02:38,840 --> 00:02:42,090
Can you write a one-line solution to this?

00:02:42,090 --> 00:02:47,500
It turns out that you can, like so.

00:02:47,500 --> 00:02:49,970
A bit more complicated than the one before.

00:02:49,970 --> 00:02:53,690
So this begs the question, if I can write this

00:02:53,690 --> 00:02:55,640
as a one-line Python program,

00:02:55,640 --> 00:02:59,020
can I write anything as a one-line Python program?

00:03:01,120 --> 00:03:06,340
The answer to this question is yes, because --

00:03:06,340 --> 00:03:09,120
[laughter]

00:03:09,120 --> 00:03:12,140
-- as you just saw, you can convert it to a string and then exec it.

00:03:12,140 --> 00:03:14,200
We're done!

00:03:14,600 --> 00:03:17,700
You can also do something like this, with semicolons.

00:03:17,700 --> 00:03:22,150
These aren't quite what I want to get at, though.

00:03:22,150 --> 00:03:25,330
These aren't as fun as using lambdas and list comprehensions.

00:03:25,330 --> 00:03:27,980
So I'm going to define some rules for this challenge.

00:03:29,670 --> 00:03:33,700
We want to use list comprehensions as much as possible.

00:03:33,700 --> 00:03:36,000
List comprehensions, if you aren't aware of them yet --

00:03:36,000 --> 00:03:41,680
you can make mutations to values in your list and filter over them.

00:03:41,680 --> 00:03:45,060
Lambda expressions allow you to define functions inline.

00:03:45,070 --> 00:03:49,130
So my rules are going to be: I have one line, no newlines.

00:03:49,130 --> 00:03:52,880
I have no semicolons in this line either.

00:03:52,880 --> 00:03:56,940
I'm not using exec or similar tricks.

00:03:56,950 --> 00:04:01,380
And that's kind of what encapsulates the aesthetic that I want to get out of this,

00:04:01,380 --> 00:04:04,200
where I'm abusing lambda and list comprehensions

00:04:04,200 --> 00:04:06,260
as much as possible.

00:04:06,260 --> 00:04:08,599
By the way, yes, this is terrible.

00:04:08,600 --> 00:04:11,660
Do not do this in your code in case that weren't already obvious.

00:04:11,660 --> 00:04:13,800
Yeah, do you want help with this?

00:04:18,320 --> 00:04:20,220
Thanks.

00:04:20,220 --> 00:04:22,920
Yeah, so this is what we're going to try to do.

00:04:22,940 --> 00:04:24,900
And this is terrible, but it's going to be fun

00:04:24,900 --> 00:04:27,000
and we're going to learn things along the way.

00:04:27,009 --> 00:04:29,680
So some of the takeaways that we're going to get out of this.

00:04:29,680 --> 00:04:34,140
This challenge is solvable; you can actually do it.

00:04:34,140 --> 00:04:37,020
Lambda calculus is one of the things that allows us to do it,

00:04:37,020 --> 00:04:40,220
and some of the obscure Python features that we're going to see help as well.

00:04:42,460 --> 00:04:44,620
I've built a compiler that implements this

00:04:44,620 --> 00:04:46,520
called Oneliner-izer.

00:04:46,520 --> 00:04:49,419
And finally, as another reminder, do not use this

00:04:49,420 --> 00:04:51,560
as a software engineering paradigm.

00:04:54,100 --> 00:04:56,080
All right, so from here on out, I'm going to teach you

00:04:56,080 --> 00:04:58,360
about how we implement each of the features.

00:04:58,360 --> 00:05:02,639
So we'll have simple code blocks, we'll have some control flow structures,

00:05:02,640 --> 00:05:06,220
and then we'll have some of Python's other features like import and try-except.

00:05:08,180 --> 00:05:11,219
Okay, so as a first challenge,

00:05:11,220 --> 00:05:14,060
how can you convert this into a single line?

00:05:15,080 --> 00:05:17,240
You can think about this for a second.

00:05:19,560 --> 00:05:24,560
One initial way you might think is to just replace everything inline.

00:05:24,569 --> 00:05:27,719
Replace z with y plus y, replace y with x plus x.

00:05:27,719 --> 00:05:32,629
And then you get this giant 1 + 1 + 1 + 1 thing.

00:05:32,629 --> 00:05:36,770
This is suboptimal not only because of the exponential blowup,

00:05:36,770 --> 00:05:40,110
but also because of what happens if x equals raw input.

00:05:40,110 --> 00:05:42,580
For example, where we're calling it multiple times.

00:05:42,580 --> 00:05:44,920
So this won't be something that we want.

00:05:44,920 --> 00:05:47,660
Instead, this is what I'm going to do.

00:05:48,860 --> 00:05:52,580
What we want is to print z plus z, but before that,

00:05:52,589 --> 00:05:56,650
we need to know the value of z, so we enclose that in a lambda.

00:05:56,650 --> 00:05:58,990
Before that, we need to know the value of y,

00:05:58,990 --> 00:06:02,759
so we enclose y with a lambda for that.

00:06:02,759 --> 00:06:05,619
And then lastly, we get our value of x.

00:06:05,620 --> 00:06:07,540
And by the way, there's an alternative method

00:06:07,540 --> 00:06:10,599
of doing this assignment to variables, written down below.

00:06:10,599 --> 00:06:14,439
If you don't want to use a lambda you can also use a list comprehension

00:06:14,439 --> 00:06:17,990
to set the value of z and then only take

00:06:17,990 --> 00:06:20,560
that single element of the list comprehension.

00:06:22,800 --> 00:06:28,580
All right, so now we have assignments and we have some simple sequential code.

00:06:28,580 --> 00:06:30,420
What about functions?

00:06:30,420 --> 00:06:32,480
What if we have function definitions in our code?

00:06:32,490 --> 00:06:36,279
So here we have f, for example, being defined, and then later on

00:06:36,279 --> 00:06:41,830
we go and use f in some computations; how can we do this?

00:06:41,830 --> 00:06:45,280
This is actually pretty simple as well.

00:06:45,280 --> 00:06:48,610
We just need to set the value of f, and the value of f is a function.

00:06:48,610 --> 00:06:51,690
And we can construct that function with its own lambda,

00:06:51,690 --> 00:06:54,529
using kind of the same techniques to build out that lambda

00:06:54,529 --> 00:06:57,740
if there is more code in there besides just the return statement.

00:06:57,740 --> 00:07:00,260
So that works, and by the way,

00:07:00,260 --> 00:07:04,260
this also works with *args and **kwargs, just as is.

00:07:04,260 --> 00:07:06,520
You can feed them into the lambda and it works right.

00:07:07,740 --> 00:07:12,980
Another thing that we might want to do is functions that don't assign

00:07:12,980 --> 00:07:14,760
anything to a variable.

00:07:14,760 --> 00:07:16,720
So far we've been assigning things to variables.

00:07:16,720 --> 00:07:20,220
Say do_something() is this function that has a side effect.

00:07:20,220 --> 00:07:22,119
What can we do here?

00:07:22,760 --> 00:07:28,200
Well, one of the things that we can do is to take the return value of do_something()

00:07:28,210 --> 00:07:30,349
and funnel it to an unused variable.

00:07:30,349 --> 00:07:32,960
So we get something like this, where the value of do_something()

00:07:32,960 --> 00:07:34,780
goes to underscore,

00:07:34,780 --> 00:07:36,820
whether it's none or whether it's something else.

00:07:36,820 --> 00:07:38,620
That also works.

00:07:38,620 --> 00:07:41,460
A second technique that we might use.

00:07:41,460 --> 00:07:45,439
Here we have a tuple where do_something() as the first element of the tuple,

00:07:45,439 --> 00:07:47,710
and then the return value is the second element of the tuple

00:07:47,710 --> 00:07:50,080
and we only take the second element of the tuple.

00:07:50,080 --> 00:07:53,149
This will also work and it will correctly discard the data

00:07:53,149 --> 00:07:55,740
that we don't need from do_something(), its return value.

00:07:57,220 --> 00:08:03,840
Okay, so the final thing in this simple code blocks section --

00:08:03,840 --> 00:08:08,610
Oh, by the way, all of my examples so far have been finagled

00:08:08,610 --> 00:08:10,780
so that there's a print statement at the end.

00:08:10,780 --> 00:08:14,020
Now that we can do functions with side effects,

00:08:14,020 --> 00:08:17,689
we can define our own print function and use it in the same way

00:08:17,689 --> 00:08:20,029
that we're using do_something() here.

00:08:20,029 --> 00:08:23,610
So we want to get a function for print.

00:08:23,610 --> 00:08:27,839
In Python 3 this is easy because Python 3 already has its print function,

00:08:27,839 --> 00:08:31,650
and we can use it in the same way and this will work just fine.

00:08:31,650 --> 00:08:35,430
In Python 2 it's going to be a bit more complicated

00:08:35,430 --> 00:08:38,240
because we don't have that built-in print function.

00:08:38,240 --> 00:08:42,469
And if we try to insert a print statement into an expression,

00:08:42,469 --> 00:08:45,069
that's going to be a syntax error.

00:08:45,069 --> 00:08:49,670
In order to get this print function, you might think that we can do

00:08:49,670 --> 00:08:52,910
from __future__ import print_function, and actually later I'll show

00:08:52,910 --> 00:08:57,480
how we can do imports in this one-line code.

00:08:57,480 --> 00:09:01,670
But this won't actually work because this isn't an import statement.

00:09:01,670 --> 00:09:05,069
It's a compiler directive and it has to have exactly that form

00:09:05,069 --> 00:09:08,100
in order for the compiler to read it correctly.

00:09:08,100 --> 00:09:12,380
Instead, what we can do is use the dunder built-ins

00:09:12,380 --> 00:09:15,060
and take the value of print from dunder built-ins

00:09:15,060 --> 00:09:19,160
and feed it to this dunder print that I'm defining.

00:09:19,160 --> 00:09:21,580
And so from here on out, I'll be able to have a print function.

00:09:24,640 --> 00:09:27,320
Okay, the last thing in this simple code block section is classes.

00:09:27,320 --> 00:09:29,750
Classes are other things that we might want to define

00:09:29,750 --> 00:09:32,520
as we're going through our code.

00:09:32,520 --> 00:09:34,660
This can be done using type.

00:09:34,660 --> 00:09:37,670
So I can set the value of the variable capital person

00:09:37,670 --> 00:09:43,589
to this type, which has a name, and I specify what things it derives from.

00:09:43,589 --> 00:09:46,160
I specify its built-in methods and so on.

00:09:48,200 --> 00:09:53,040
Cool, and if we put it all together, a reminder of how this flows,

00:09:53,040 --> 00:09:54,920
we work from the bottom up.

00:09:54,920 --> 00:09:59,870
So first I have something that has setting the value of y,

00:09:59,870 --> 00:10:03,050
and it also uses the return value of this entire block.

00:10:03,050 --> 00:10:06,110
In this case, this entire block returns none.

00:10:06,110 --> 00:10:10,490
And then I go up from there, adding each of the statements.

00:10:10,490 --> 00:10:15,019
So I have the print, I have the definition of f,

00:10:15,019 --> 00:10:18,520
and I have the definition of x, and so on and so forth.

00:10:18,520 --> 00:10:23,180
So this allows us to take big, long series of statements

00:10:23,180 --> 00:10:26,420
and convert them into one line; so far so good.

00:10:29,810 --> 00:10:35,180
But all of our code is not going to be just these single lines of statements.

00:10:35,190 --> 00:10:38,490
Python has control flow, and control flow is useful.

00:10:38,490 --> 00:10:44,460
So let's talk about what we can do in order to implement if-else statements.

00:10:44,460 --> 00:10:46,200
So we have if-else statements.

00:10:46,200 --> 00:10:48,920
You have a branch, you have a Boolean at the top.

00:10:48,920 --> 00:10:50,740
Each of the branches might do something,

00:10:50,740 --> 00:10:52,980
they might call functions, they might modify state.

00:10:52,990 --> 00:10:56,420
And at the end they return to the same line of computation

00:10:56,420 --> 00:10:59,920
and carry out some more stuff, in this case a print statement.

00:11:01,640 --> 00:11:04,339
You can think for a bit about what we might do

00:11:04,340 --> 00:11:06,280
in order to get this to work.

00:11:08,440 --> 00:11:11,610
The solution is going to use conditional expressions.

00:11:11,610 --> 00:11:15,340
So we have Python's _ if _ else _,

00:11:15,340 --> 00:11:17,360
and then we're also going to use continuation passing.

00:11:17,360 --> 00:11:20,750
I'll explain the continuation passing part in a second.

00:11:20,750 --> 00:11:23,120
As for the if-else, what we're going to do is

00:11:23,120 --> 00:11:25,480
have one expression for the first code block,

00:11:25,480 --> 00:11:27,399
and another expression for the second code block,

00:11:27,399 --> 00:11:30,630
and then choose between them just like this.

00:11:30,630 --> 00:11:35,000
To figure out the code blocks, they have to be different things.

00:11:35,000 --> 00:11:38,520
So we're going to have to make each of them return

00:11:38,520 --> 00:11:42,860
to the end of the if-else at the end, so you might have something like this,

00:11:42,860 --> 00:11:46,240
where you have x = 5, print x * 100 for the first,

00:11:46,240 --> 00:11:49,540
x = 10, print x *100 for the second.

00:11:49,540 --> 00:11:52,019
That's what we want them to do.

00:11:52,019 --> 00:11:56,240
We can't just write this though, because this again is code duplication.

00:11:56,240 --> 00:11:58,529
And code duplication is going to cause exponential blowup

00:11:58,529 --> 00:12:02,199
and make our programs really big if we have only a linear number

00:12:02,200 --> 00:12:04,220
of if-else statements.

00:12:05,540 --> 00:12:09,560
So in order to fix this, I'm going to take the duplicated part

00:12:09,560 --> 00:12:15,089
and abstract it out into its own function, which I'll call the continuation function.

00:12:15,089 --> 00:12:18,779
So here we have the continuation which takes in all of the state

00:12:18,779 --> 00:12:21,689
that's been modified and does some stuff.

00:12:21,689 --> 00:12:25,779
And then each of our if-elses delegate out to the continuation

00:12:25,780 --> 00:12:27,640
once they're done.

00:12:29,200 --> 00:12:32,680
So the final result of this applying the transformations

00:12:32,690 --> 00:12:35,470
that we've been seeing so far is something like this.

00:12:35,470 --> 00:12:37,520
This is our if-else statement.

00:12:41,209 --> 00:12:44,040
And I want to draw your attention to what this looks like

00:12:44,050 --> 00:12:51,410
side by side with this control flow graph way of visualizing how if-elses work.

00:12:51,410 --> 00:12:54,160
We have two different branches, we delegate out to one or the other,

00:12:54,160 --> 00:12:58,460
and then we return to the same point, and that point is our continuation function.

00:13:01,010 --> 00:13:05,000
The next thing to talk about is while loops.

00:13:05,009 --> 00:13:08,310
So I have a while loop; this is an example of a while loop.

00:13:08,310 --> 00:13:10,100
We have some initial stuff.

00:13:10,100 --> 00:13:12,000
There's some stuff that's in the while loop,

00:13:12,000 --> 00:13:14,400
and then there's some stuff that's after the while loop.

00:13:14,400 --> 00:13:16,520
What if we want to convert this to a single line?

00:13:18,280 --> 00:13:22,160
The answer for how to implement this is going to be conditional expressions

00:13:22,160 --> 00:13:24,630
and continuation passing, just like with if and else,

00:13:24,630 --> 00:13:27,180
but there's going to be some tricks.

00:13:27,180 --> 00:13:33,279
So if you look at the control flow graph for a while loop, it's kind of reminiscent

00:13:33,279 --> 00:13:35,019
of the one for an if-else.

00:13:35,019 --> 00:13:39,759
You have these two branches and one has to go to the end --

00:13:39,759 --> 00:13:42,290
that's the false branch -- but then this true branch

00:13:42,290 --> 00:13:46,279
has to wrap back around to the place that you started at.

00:13:46,280 --> 00:13:50,160
So the while loop needs to be its own continuation.

00:13:50,160 --> 00:13:52,079
We're going to have this recursive structure

00:13:52,079 --> 00:13:54,860
where we have a function while_loop.

00:13:54,860 --> 00:13:58,560
And if the guard on the while loop is true, we call it.

00:13:58,560 --> 00:14:01,260
Otherwise we carry on with the stuff at the end.

00:14:01,260 --> 00:14:05,160
So this while loop function needs to be recursive.

00:14:05,160 --> 00:14:09,740
This is problematic though, because we've been using lambda functions,

00:14:09,740 --> 00:14:11,740
and lambda functions don't receive names

00:14:11,740 --> 00:14:13,810
until after they're defined.

00:14:13,810 --> 00:14:17,600
But we want this while loop function to be able to call itself.

00:14:17,600 --> 00:14:21,620
It doesn't have a reference to itself to point to.

00:14:21,620 --> 00:14:27,060
So there's a way to solve this, which is to use the Y combinator,

00:14:27,069 --> 00:14:30,240
which is a combinator that you can use in order to implement recursion

00:14:30,240 --> 00:14:33,920
on these anonymous functions or lambda functions.

00:14:33,920 --> 00:14:37,110
The Y combinator is also called the fixed point combinator

00:14:37,110 --> 00:14:41,880
because if you take YF, it returns you some value

00:14:41,880 --> 00:14:46,740
such that that value is equal to f of that value.

00:14:46,740 --> 00:14:50,050
So, YF equals FYF.

00:14:50,050 --> 00:14:54,700
And this is what enables us to create a function that can call itself.

00:14:56,040 --> 00:15:00,340
Here is an implementation of the Y combinator in Python.

00:15:00,340 --> 00:15:04,959
And here is an implementation of this while loop

00:15:04,960 --> 00:15:08,400
in its final form using the Y combinator.

00:15:09,980 --> 00:15:11,740
This is kind of tricky.

00:15:11,740 --> 00:15:16,360
You need to pass to the Y combinator a function that has two arguments.

00:15:16,360 --> 00:15:19,879
The first one is a putative value of the while loop,

00:15:19,879 --> 00:15:24,769
which will be called later on in the recursive part.

00:15:24,769 --> 00:15:27,870
And then the next value is whatever the function should take in.

00:15:27,870 --> 00:15:31,220
If you want a good walk through of how this works,

00:15:31,220 --> 00:15:33,420
I recommend this Wikipedia article to you.

00:15:33,420 --> 00:15:35,280
It's pretty good to read.

00:15:36,840 --> 00:15:38,640
So that's while loops.

00:15:38,640 --> 00:15:40,560
So now we have if-else, we have while loops,

00:15:40,560 --> 00:15:43,130
we're doing pretty good on the control flow front.

00:15:43,130 --> 00:15:46,889
One note that I want to make is that so far we've been storing state

00:15:46,889 --> 00:15:50,020
using this lambda trick that I showed you earlier.

00:15:51,140 --> 00:15:54,640
This is problematic once we start to define while loops though,

00:15:54,649 --> 00:15:58,240
because our continuations need to take in as input

00:15:58,240 --> 00:16:01,220
everything that's been modified so far.

00:16:01,220 --> 00:16:05,279
And if you have a while loop that modifies a bunch of variables,

00:16:05,279 --> 00:16:10,389
or if you have an if-else construction where one of the branches modifies

00:16:10,389 --> 00:16:14,670
a bunch of variables, your continuation is going to need to take in

00:16:14,670 --> 00:16:17,280
all of those variables that were modified.

00:16:17,280 --> 00:16:20,420
So you have x, y, z, and the rest of the kitchen sink.

00:16:20,420 --> 00:16:24,170
In order to make this smaller, we're actually going to use

00:16:24,170 --> 00:16:30,439
that list comprehension trick instead, and we're going to use a dictionary

00:16:30,439 --> 00:16:34,189
to store the values that were modified.

00:16:34,189 --> 00:16:41,480
Fun fact: you can use a position in a dictionary as a thing

00:16:41,480 --> 00:16:46,730
in your list comprehension like this, but you can't do that with the lambda.

00:16:46,730 --> 00:16:49,259
So we can modify in place the value of the dictionary

00:16:49,260 --> 00:16:51,380
in this list comprehension.

00:16:51,380 --> 00:16:55,600
This allows us to store state in a dictionary.

00:16:55,610 --> 00:16:58,529
So instead we'll have something like this.

00:16:58,529 --> 00:17:01,280
And we'll mutate the dictionary as we go through.

00:17:01,280 --> 00:17:03,540
And then I can initialize the value of the dictionary

00:17:03,550 --> 00:17:09,210
using locals to make sure that it has all of the local values.

00:17:09,210 --> 00:17:13,339
And a bonus of this is that if we're mutating locals directly,

00:17:13,340 --> 00:17:17,180
now you can import from one-line programs.

00:17:17,180 --> 00:17:19,060
So you'll have this ridiculous one-line program

00:17:19,060 --> 00:17:20,840
that's like a bunch of lambdas.

00:17:20,840 --> 00:17:24,500
It doesn't look like something that you can import from at all,

00:17:24,500 --> 00:17:26,060
but you're able to import from it.

00:17:26,060 --> 00:17:28,200
[laughter]

00:17:28,200 --> 00:17:30,240
Preserves functionality.

00:17:30,240 --> 00:17:32,400
[laughter]

00:17:33,560 --> 00:17:36,460
Next thing after while loops is for loops.

00:17:36,460 --> 00:17:40,840
Maybe we have something like this where we're going through an iterable.

00:17:40,840 --> 00:17:44,740
An important thing to note about this is that you can't always index

00:17:44,750 --> 00:17:49,410
into the iterable at some particular value "I",

00:17:49,410 --> 00:17:52,890
but you will be able to consume the values one by one.

00:17:52,890 --> 00:17:55,880
For example, if I have an iterator that's a set,

00:17:55,880 --> 00:17:59,910
I can loop through that set just fine and it'll print out the values.

00:17:59,910 --> 00:18:04,590
But I won't be able to access a particular value of that iterable.

00:18:04,590 --> 00:18:08,380
So in order to implement a for loop, we're going to need to take this into account.

00:18:08,380 --> 00:18:12,480
The solution for the for loop is something like this,

00:18:12,490 --> 00:18:16,650
where we use the next function in order to get the next value

00:18:16,650 --> 00:18:18,760
out of an interval.

00:18:18,760 --> 00:18:21,270
And we also use a sentinel

00:18:21,270 --> 00:18:25,760
so that once you reach the end of the iterable you won't throw an error,

00:18:25,760 --> 00:18:31,450
because we don't have try-except implemented so far in this presentation.

00:18:31,450 --> 00:18:35,700
So this allows us to do that without having to catch errors.

00:18:35,700 --> 00:18:38,910
So now we've reduced the problem of for to some stuff that we've already talked about.

00:18:38,910 --> 00:18:41,540
We have while, we have if -- we're done; it's good.

00:18:43,660 --> 00:18:48,160
Okay, let's talk about some stuff kind of beyond, like other Python features.

00:18:48,170 --> 00:18:52,020
Let's talk about imports; so, imports are important.

00:18:52,020 --> 00:18:54,590
You want to be able to import modules into your program,

00:18:54,590 --> 00:18:56,860
use things like random or math or whatever library it is

00:18:56,860 --> 00:18:59,590
that you're using in this file that for some reason

00:18:59,590 --> 00:19:02,480
you want to convert to one line.

00:19:04,080 --> 00:19:05,960
We can do this.

00:19:05,960 --> 00:19:10,900
You can use the dunder import function in order to import a module by name,

00:19:10,900 --> 00:19:12,820
like so.

00:19:12,820 --> 00:19:15,920
And set that to the variable name that you want the module to be at,

00:19:15,920 --> 00:19:18,090
and then this will work.

00:19:18,090 --> 00:19:21,360
Import itself doesn't need to be imported.

00:19:21,360 --> 00:19:23,180
Raising errors.

00:19:23,180 --> 00:19:27,000
This is also something that we can do on one line as a Python expression.

00:19:27,000 --> 00:19:29,850
So say we want to raise the error Bad.

00:19:29,850 --> 00:19:34,400
It turns out that generators have this convenient method throw.

00:19:34,400 --> 00:19:39,740
[laughter]

00:19:39,740 --> 00:19:42,880
So that works.

00:19:42,880 --> 00:19:45,700
Similarly if you want to do an assert statement,

00:19:45,710 --> 00:19:48,310
where you assert something and then you carry on afterwards,

00:19:48,310 --> 00:19:52,030
this is just an if where,

00:19:52,030 --> 00:19:54,080
if that's correct, then you carry on.

00:19:54,080 --> 00:19:56,860
Otherwise you throw the assertion error.

00:19:56,860 --> 00:19:58,820
So that's good.

00:19:59,560 --> 00:20:01,560
Try-except.

00:20:01,560 --> 00:20:03,940
Now we're getting really into the nitty-gritty of things,

00:20:03,940 --> 00:20:06,080
and this is actually a PyCon exclusive.

00:20:06,080 --> 00:20:08,780
This was not implemented the first time that this appeared

00:20:08,780 --> 00:20:10,770
on the internet and people saw it.

00:20:10,770 --> 00:20:12,960
So try-except is kind of new.

00:20:14,400 --> 00:20:18,320
So we have try, we want to carry out some function.

00:20:18,320 --> 00:20:21,860
Except Bad, that's like some error that might be thrown

00:20:21,870 --> 00:20:26,090
if we want to handle the exception using the function bar.

00:20:26,090 --> 00:20:27,840
How can we do this in one line?

00:20:27,840 --> 00:20:29,660
This is pretty tricky.

00:20:29,660 --> 00:20:34,160
You just don't think of try-except as something that you can do in one line.

00:20:34,160 --> 00:20:36,220
There is a way to do this, though.

00:20:36,220 --> 00:20:38,280
And the way that we're going to do this --

00:20:38,280 --> 00:20:42,500
this only works in Python 2 because it was deprecated in Python 2.

00:20:42,500 --> 00:20:49,840
We're going to abuse the context manager protocol in order to try and except for our errors.

00:20:49,840 --> 00:20:53,630
So first thing I'm going to do is to define this handler

00:20:53,630 --> 00:20:57,460
that will handle the Bad error and carry out the function

00:20:57,460 --> 00:20:59,200
that we want to do on it.

00:20:59,200 --> 00:21:01,020
And then we have this with statement at the bottom

00:21:01,020 --> 00:21:06,040
that carries out the foo function with the handler attached.

00:21:06,040 --> 00:21:09,840
We haven't implemented with yet though, so I need to mess with that with statement

00:21:09,840 --> 00:21:11,900
in order to get it to be one line.

00:21:11,900 --> 00:21:17,550
So the first thing we're going to do is to move the foo function somewhere else.

00:21:17,550 --> 00:21:19,930
We're moving it to this other handler body.

00:21:19,930 --> 00:21:22,660
Both of these are contexts managers.

00:21:22,660 --> 00:21:24,780
And we carry out foo there.

00:21:26,860 --> 00:21:31,800
Next we're going to use contextlib.nested and combine handler and body together.

00:21:33,720 --> 00:21:36,220
If you want to know why foo is an exit instead of enter,

00:21:36,220 --> 00:21:38,500
you can look up Python issue 5251.

00:21:38,500 --> 00:21:40,660
[laughter]

00:21:40,660 --> 00:21:43,920
Finally, now that we've converted these to contextlib.nested,

00:21:43,920 --> 00:21:49,710
we've created a way to take these things and make them into a context manager,

00:21:49,710 --> 00:21:54,870
just one context manager, which we can then enter and exit manually.

00:21:54,870 --> 00:21:57,250
And at this point this is all stuff that we've seen how to do before.

00:21:57,250 --> 00:22:00,040
We can define classes, we can assign to ctx,

00:22:00,040 --> 00:22:02,980
and we can execute those methods on ctx.

00:22:02,980 --> 00:22:05,440
So, to convert this to one line,

00:22:05,440 --> 00:22:08,740
here's the stuff from before that you would carry out.

00:22:08,740 --> 00:22:11,000
And this is the final result.

00:22:12,820 --> 00:22:16,460
Also implemented are else and finally, but I won't talk about those here.

00:22:16,460 --> 00:22:22,480
[applause]

00:22:22,480 --> 00:22:25,610
Great, so I hopefully taught you a bunch of stuff

00:22:25,610 --> 00:22:31,270
about strange Python obscurities that you weren't necessarily aware of before.

00:22:31,270 --> 00:22:34,870
Things that are left, in case you want to try your hand at this:

00:22:34,870 --> 00:22:38,100
We haven't implemented from module import * yet.

00:22:38,100 --> 00:22:40,020
We haven't implemented yield

00:22:40,020 --> 00:22:42,280
and the associated generator functions that come with them.

00:22:42,280 --> 00:22:44,540
And we haven't implemented with statements.

00:22:46,180 --> 00:22:48,880
But we have built a compiler that carries out

00:22:48,880 --> 00:22:50,620
each of these transformations that I've shown you

00:22:50,620 --> 00:22:52,560
on actual Python files.

00:22:52,560 --> 00:22:56,340
It uses some of these packages in order to have its functionality.

00:22:56,340 --> 00:22:58,220
Most important of these are ast

00:22:58,220 --> 00:23:03,100
which is used to parse the Python files into syntax trees,

00:23:03,100 --> 00:23:07,120
and symtable which is used to figure out what scope

00:23:07,120 --> 00:23:09,230
some variables are supposed to be assigned to

00:23:09,230 --> 00:23:11,300
and prevent some very strange errors

00:23:11,300 --> 00:23:13,660
that might happen otherwise.

00:23:13,660 --> 00:23:16,620
And the code for this is here; this will also be at the end of the presentation.

00:23:16,620 --> 00:23:19,830
So you can play around with it, try to one-line your own files

00:23:19,830 --> 00:23:21,980
and import things from them.

00:23:23,060 --> 00:23:25,340
Some caveats to this.

00:23:25,340 --> 00:23:29,020
Because we're implementing while loops and if-else

00:23:29,030 --> 00:23:33,360
and stuff like that as nested lambdas, we run into the upper limit

00:23:33,360 --> 00:23:37,720
to the Python parser which is somewhere between 92 and 99.

00:23:37,720 --> 00:23:41,620
So if you try to execute a oneliner-ized Python file,

00:23:41,630 --> 00:23:44,300
you might get an error like this.

00:23:44,300 --> 00:23:46,740
This can be avoided by using PyPy.

00:23:46,740 --> 00:23:50,440
[laughter and applause]

00:23:50,440 --> 00:23:56,600
Another issue that you might come across, because we're implementing while loops

00:23:56,600 --> 00:23:58,640
using nested lambdas,

00:23:58,640 --> 00:24:01,980
not necessarily with tail recursion correctly built-in,

00:24:01,980 --> 00:24:04,330
you might run into maximum recursion depth exceeded

00:24:04,330 --> 00:24:06,760
when you have very long loops.

00:24:06,760 --> 00:24:11,420
If you really want to get around this, you can set the recursion limit to be deeper.

00:24:14,760 --> 00:24:17,320
Yeah, so we've built this compiler.

00:24:17,320 --> 00:24:19,800
Finally the last thing that you might think is,

00:24:19,810 --> 00:24:22,450
okay, you've written this compiler in Python.

00:24:22,450 --> 00:24:25,510
Can you convert your Python compiler to one line?

00:24:25,510 --> 00:24:27,460
The answer is yes.

00:24:27,460 --> 00:24:34,460
[laughter and applause]

00:24:35,140 --> 00:24:37,240
Yeah, and that's it.

00:24:37,240 --> 00:24:39,200
I'd like to thank the people who contributed code.

00:24:39,200 --> 00:24:42,000
In particular Anders Kaseorg contributed many of these features

00:24:42,000 --> 00:24:46,370
and also some of the slides, and other people on GitHub contributed code.

00:24:46,370 --> 00:24:48,680
And here are some links if you'd like to read about this more

00:24:48,680 --> 00:24:51,980
or try the demo, read about lambda calculus.

00:24:51,980 --> 00:24:53,700
Thanks.

00:24:53,700 --> 00:25:01,060
[applause]

00:25:01,060 --> 00:25:03,860
(moderator) Okay, we have time for some questions.

00:25:03,860 --> 00:25:06,740
Raise your hand and I'll bring the mic over to you.

00:25:11,500 --> 00:25:13,700
(audience member 1) Hi, thanks for a tremendous talk.

00:25:13,700 --> 00:25:16,480
I got only one question: why didn't you name it

00:25:16,480 --> 00:25:19,460
as Python to Lisp compiler?

00:25:20,380 --> 00:25:22,180
(Chelsea Voss) Why did I…?

00:25:22,180 --> 00:25:23,960
(audience member 1) Why didn't you name it

00:25:23,960 --> 00:25:25,740
as Python to Lisp compiler?

00:25:25,740 --> 00:25:28,620
(Chelsea Voss) Ahh, that would also be fun.

00:25:28,620 --> 00:25:32,140
It really needs some of the details of Python

00:25:32,140 --> 00:25:35,560
in order to actually work in Python though, thanks.

00:25:39,280 --> 00:25:41,120
(audience member 2) So I think I would actually consider

00:25:41,120 --> 00:25:45,020
the absence of wild card imports to be a feature.

00:25:45,020 --> 00:25:48,700
However, with that said, what's stopping you from using

00:25:48,700 --> 00:25:52,420
the dunder all attribute of modules and then just for each and that,

00:25:52,420 --> 00:25:54,200
import that from the module?

00:25:54,200 --> 00:25:56,970
Is it not defined in all modules or something?

00:25:56,970 --> 00:26:01,860
I think from whatever import star is actually quite tractable.

00:26:01,860 --> 00:26:05,320
It's just that nobody's bothered to implement it yet, so yeah.

00:26:05,320 --> 00:26:07,140
[laughter]

00:26:12,420 --> 00:26:15,800
(audience member 3) Thank you for the great talk; that was awesome.

00:26:15,800 --> 00:26:17,600
I have a question about your original constraints.

00:26:17,600 --> 00:26:19,400
(Chelsea Voss) Yeah.

00:26:19,400 --> 00:26:21,420
(audience member 3) So you said that you wanted to use comprehensions,

00:26:21,420 --> 00:26:24,000
but if you're coming at this from Lisp, why would you not use map?

00:26:24,000 --> 00:26:26,540
(Chelsea Voss) Why would I not use map?

00:26:26,540 --> 00:26:29,750
So actually, a story is that, originally I tried to implement for loops

00:26:29,750 --> 00:26:33,720
using reduce, where you would reduce over the iterable

00:26:33,720 --> 00:26:38,500
and apply the change to state to each step.

00:26:38,500 --> 00:26:41,890
That proved to eventually be removed

00:26:41,890 --> 00:26:46,680
when break and return inside loops were implemented.

00:26:46,680 --> 00:26:48,980
But yeah, map is pretty good.

00:26:48,980 --> 00:26:50,840
(audience member 3) Thank you.

00:26:59,420 --> 00:27:01,240
(moderator) Raise your hand higher.

00:27:01,240 --> 00:27:03,060
I can't see that well.

00:27:08,160 --> 00:27:10,180
(audience member 4) For other weird Python features,

00:27:10,180 --> 00:27:12,040
are metaclasses implemented?

00:27:12,040 --> 00:27:13,980
(Chelsea Voss) Metaclasses.

00:27:13,980 --> 00:27:17,320
[laughter]

00:27:17,960 --> 00:27:19,820
I'll have to check.

00:27:19,820 --> 00:27:21,660
(audience member 4) Okay.

00:27:21,660 --> 00:27:23,400
[laughs]

00:27:23,840 --> 00:27:25,640
(Chelsea Voss) Yeah.

00:27:30,800 --> 00:27:33,620
(audience member 5) So this would be cheating quite a lot,

00:27:33,620 --> 00:27:37,200
and Python version-specific, but could you implement the with statement

00:27:37,200 --> 00:27:40,900
by building a function using the compile modules

00:27:40,900 --> 00:27:43,740
and build it out of Python bytecodes?

00:27:43,740 --> 00:27:45,980
(Chelsea Voss) Using which module?

00:27:45,980 --> 00:27:47,980
(audience member 5) Compile it out of raw Python bytecodes

00:27:47,980 --> 00:27:49,720
and then call it.

00:27:49,720 --> 00:27:51,560
Since you can import those modules,

00:27:51,560 --> 00:27:53,240
it would be version specific, but we did have a talk

00:27:53,240 --> 00:27:56,340
earlier in the conference about bytecodes, so.

00:27:57,040 --> 00:27:59,380
(Chelsea Voss) Oh, is this for implementing something,

00:27:59,380 --> 00:28:01,300
implementing try-except in Python 3, or implementing with?

00:28:01,300 --> 00:28:04,120
(audience member 5) No, for implementing with statements

00:28:04,120 --> 00:28:07,540
in Python 2 or 3; seems like cheating, but...

00:28:07,540 --> 00:28:10,080
(Chelsea Voss) I think I might count that as executing strings.

00:28:10,080 --> 00:28:13,580
I guess it depends if you can do it without doing that.

00:28:16,420 --> 00:28:18,920
(audience member 6) Has this been useful in the Python Bee?

00:28:18,920 --> 00:28:22,060
[laughter]

00:28:22,060 --> 00:28:24,220
(Chelsea Voss) I won the Python Bee one year,

00:28:24,220 --> 00:28:28,260
but I did not execute code from this in order to do so.

00:28:28,260 --> 00:28:30,140
[laughter]

00:28:33,780 --> 00:28:35,520
(moderator) Any others?

00:28:35,520 --> 00:28:37,300
(Chelsea Voss) I would like to see that.

00:28:38,020 --> 00:28:39,820
(moderator) Okay, let's thank Chelsea for a great talk.

00:28:39,820 --> 00:28:42,640

YouTube URL: https://www.youtube.com/watch?v=DsUxuz_Rt8g


