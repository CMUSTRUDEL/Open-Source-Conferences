Title: Brett Slatkin - Refactoring Python: Why and how to restructure your code - PyCon 2016
Publication date: 2016-06-09
Playlist: PyCon 2016
Description: 
	Speaker: Brett Slatkin

As programs gain complexity, it becomes harder to add features and fix bugs. Reorganizing code is an effective way to make programs more manageable. This talk will show you Pythonic ways to do the most imporant ""refactorings"": Extract variables with __nonzero__; Change signatures with *args and **kwargs; Extract fields and classes with @property; Create stateful closures with __call__; and more!

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:00,719 --> 00:00:03,339
(presenter) This is Refactoring Python.

00:00:03,340 --> 00:00:05,340
Please welcome Brett Slatkin.

00:00:05,340 --> 00:00:08,060
He's the author of "Effective Python."

00:00:08,060 --> 00:00:10,200
Please give him a warm welcome.

00:00:10,200 --> 00:00:13,480
[applause]

00:00:13,480 --> 00:00:15,500
(Brett Slatkin) Alright.

00:00:17,180 --> 00:00:19,100
I'll start my timer

00:00:19,100 --> 00:00:21,920
or else I'll lose track of time.

00:00:21,920 --> 00:00:24,279
Hi everybody, I'm Brett Slatkin.

00:00:24,279 --> 00:00:27,079
Thank you very much for coming to my talk.

00:00:27,080 --> 00:00:29,740
Today I'm going to talk about refactoring Python,

00:00:29,750 --> 00:00:31,930
why and how you should do it.

00:00:32,340 --> 00:00:36,580
The agenda here is we're going to go into the hows and whys,

00:00:36,580 --> 00:00:38,700
then I'm going to go through some specific strategies

00:00:38,710 --> 00:00:41,200
that you can use to refactor your Python code.

00:00:41,200 --> 00:00:44,800
And then I have some follow-up, just things you should check out

00:00:44,800 --> 00:00:47,830
if this is interesting to you, things that you should go after

00:00:47,830 --> 00:00:49,910
after that to learn more.

00:00:49,910 --> 00:00:51,710
There's a bonus section here.

00:00:51,710 --> 00:00:53,520
I don't think I'm going to have time for it,

00:00:53,520 --> 00:00:55,320
but I really wanted to talk about that too.

00:00:55,320 --> 00:00:58,260
But I'm not going to get there, so you'll be able get the slides

00:00:58,260 --> 00:01:00,360
if you can check it out later.

00:01:01,740 --> 00:01:03,760
So this is a novice talk.

00:01:03,760 --> 00:01:08,120
Some of this stuff gets harder and harder as the talk goes on.

00:01:08,120 --> 00:01:10,060
If you are confused at all, you should come back

00:01:10,060 --> 00:01:11,820
and check out the slides,

00:01:11,820 --> 00:01:14,500
and I have a bunch of other detail.

00:01:14,500 --> 00:01:16,560
I'm going to try to explain things

00:01:16,560 --> 00:01:18,560
very simply here.

00:01:18,560 --> 00:01:21,120
The overall question is, "What is refactoring?"

00:01:21,120 --> 00:01:23,320
It is restructuring, reorganizing,

00:01:23,320 --> 00:01:25,780
rewriting your code until it's obvious to a reader.

00:01:25,780 --> 00:01:29,060
That obvious statement comes from a book called "Clean Code"

00:01:29,060 --> 00:01:31,280
by Uncle Bob, or Robert Martin.

00:01:31,280 --> 00:01:34,520
You probably heard of -- the obvious part of this is

00:01:34,520 --> 00:01:36,300
the most important thing because you already do this

00:01:36,300 --> 00:01:38,140
when you're writing code; you restructure things,

00:01:38,140 --> 00:01:39,920
you reorganize things, you rewrite things

00:01:39,920 --> 00:01:41,720
as you're going along.

00:01:41,720 --> 00:01:43,560
It's just part of what programming is.

00:01:43,560 --> 00:01:45,360
But the difference between programming

00:01:45,360 --> 00:01:47,120
and refactoring is really what you're optimizing for.

00:01:47,120 --> 00:01:49,120
When you're writing code, you're optimizing for the fact

00:01:49,120 --> 00:01:51,119
that it works, and when you're refactoring,

00:01:51,119 --> 00:01:53,099
you're optimizing for the fact that you can read it,

00:01:53,100 --> 00:01:55,160
and it's obvious; that's the difference.

00:01:55,160 --> 00:01:57,760
Programming is about functionally having your code do

00:01:57,760 --> 00:01:59,760
what it's supposed to do,

00:01:59,760 --> 00:02:01,780
and refactoring is about making it obvious to a new reader

00:02:01,780 --> 00:02:03,920
so it's very simple and easy to understand.

00:02:05,920 --> 00:02:08,720
So, what's the right time to refactor?

00:02:08,720 --> 00:02:10,979
When should you stop programming and start refactoring?

00:02:10,979 --> 00:02:12,939
When do you choose the right balance?

00:02:12,940 --> 00:02:15,840
A really good time to do it is if you know you're about to change

00:02:15,840 --> 00:02:17,860
the code to do something much more complicated

00:02:17,860 --> 00:02:19,800
than what it did before.

00:02:19,800 --> 00:02:22,080
In advance of adding features, you should refactor.

00:02:22,080 --> 00:02:24,040
If you're trying to write some tests,

00:02:24,040 --> 00:02:26,400
and it's hard to test code, that means that your test --

00:02:26,400 --> 00:02:28,450
your code needs to be refactored.

00:02:28,450 --> 00:02:30,440
All code should be easy to test.

00:02:30,440 --> 00:02:32,400
If it's hard to test, it's not because the problem's hard.

00:02:32,400 --> 00:02:34,700
It's because your code isn't written the right way.

00:02:34,700 --> 00:02:36,820
So everything should be easy to test.

00:02:36,820 --> 00:02:38,880
If you find yourself copying and pasting code,

00:02:38,880 --> 00:02:41,160
or you have a bunch of functions look the same way,

00:02:41,160 --> 00:02:43,440
that's a good time to refactor.

00:02:43,440 --> 00:02:45,220
Another one is brittleness.

00:02:45,220 --> 00:02:47,020
If every time you had one feature,

00:02:47,020 --> 00:02:48,860
you break the other five or whatever it is,

00:02:48,860 --> 00:02:50,600
then you should refactor.

00:02:50,600 --> 00:02:52,440
Things shouldn't be so closely coupled

00:02:52,440 --> 00:02:54,220
so that you're always breaking yourself.

00:02:54,220 --> 00:02:56,000
And then, just in general, when you're trying to read some code,

00:02:56,000 --> 00:02:58,020
you have some trouble -- it seems too complicated --

00:02:58,020 --> 00:03:00,280
that's when you should refactor to make it easier to read

00:03:00,290 --> 00:03:02,530
so that a newcomer to your codebase can really understand

00:03:02,530 --> 00:03:04,739
what you're talking about.

00:03:04,739 --> 00:03:06,919
Here's the "why" slide.

00:03:06,920 --> 00:03:09,880
This is not actually a graph based on data reality,

00:03:09,890 --> 00:03:11,860
so this is totally anecdotal.

00:03:11,860 --> 00:03:15,180
But, you know, writing code and being a programmer

00:03:15,190 --> 00:03:19,700
consists of three main activities, which is writing and testing your code,

00:03:19,700 --> 00:03:22,540
refactoring your code, and then style like PEP 8,

00:03:22,540 --> 00:03:24,500
docstrings, and that kind of stuff.

00:03:24,510 --> 00:03:26,660
The top here is what I -- my style usually,

00:03:26,660 --> 00:03:28,870
and anyone who's ever worked with me can probably agree with this --

00:03:28,870 --> 00:03:30,900
I just barely get the code to work,

00:03:30,900 --> 00:03:32,980
and then I'm done.

00:03:32,980 --> 00:03:35,140
Maybe I'll update the style a little bit.

00:03:35,840 --> 00:03:39,300
Yeah, so anyway, do what I say, not what I do.

00:03:39,300 --> 00:03:41,360
The next step is a good programmer.

00:03:41,360 --> 00:03:43,500
They spend a good amount of their time writing the code.

00:03:43,500 --> 00:03:47,960
Then they spend maybe the last bits refactoring it, reorganizing it,

00:03:47,960 --> 00:03:50,080
add really a lot of good style into it.

00:03:50,080 --> 00:03:52,200
But what I've noticed over time is that the great programmers,

00:03:52,200 --> 00:03:54,240
the people that you try to emulate and be like,

00:03:54,240 --> 00:03:56,080
"Wow this code makes so much sense.

00:03:56,080 --> 00:03:57,880
"It's so easy to understand."

00:03:57,880 --> 00:03:59,640
The reason is because they're spending

00:03:59,640 --> 00:04:01,680
almost half of their time refactoring.

00:04:01,680 --> 00:04:04,340
When at the point where I'm done, I've finished,

00:04:04,340 --> 00:04:06,340
it works functionally,

00:04:06,340 --> 00:04:08,980
the great programmer continues going on and refactors the codebase

00:04:08,989 --> 00:04:10,909
so that it's easy to understand,

00:04:10,909 --> 00:04:12,909
so that the code is actually obvious.

00:04:12,909 --> 00:04:14,940
And they do this because it provides a better foundation

00:04:14,940 --> 00:04:16,720
for the future.

00:04:16,720 --> 00:04:18,520
It makes the code easier to test.

00:04:18,520 --> 00:04:20,300
Over the long run, it actually saves you time

00:04:20,300 --> 00:04:22,760
to invest in refactoring up front.

00:04:22,760 --> 00:04:24,780
You know, some people say that you shouldn't try to future-proof,

00:04:24,780 --> 00:04:26,940
and there's a bunch of anti-patterns in that,

00:04:26,940 --> 00:04:30,180
but refactoring is really a good investment almost always.

00:04:31,180 --> 00:04:33,340
So that's why you should refactor.

00:04:34,140 --> 00:04:37,880
In terms of "how", it's really a very simple idea.

00:04:37,880 --> 00:04:40,020
Again, you're already doing this as a programmer,

00:04:40,020 --> 00:04:42,080
but you look through your codebase.

00:04:42,080 --> 00:04:44,340
You find things that could be better.

00:04:44,340 --> 00:04:46,660
You make them better.

00:04:46,660 --> 00:04:49,220
Of course you already had tests, so you run the tests to make sure

00:04:49,220 --> 00:04:51,560
that the code -- you haven't broken it in some way,

00:04:51,560 --> 00:04:54,020
and if you have, you go through and you fix it up.

00:04:54,020 --> 00:04:57,000
You add more tests that cover cases you didn't have before,

00:04:57,000 --> 00:04:59,860
and you repeat that over and over again until you're satisfied

00:04:59,860 --> 00:05:02,900
that the code that's left is obvious.

00:05:03,980 --> 00:05:07,880
In practice, what this really means is just a few things.

00:05:07,880 --> 00:05:11,240
So you rename and split and move things around,

00:05:11,240 --> 00:05:15,180
parameters, methods, you split functions apart,

00:05:15,180 --> 00:05:18,500
you split classes apart, you split modules apart --

00:05:18,500 --> 00:05:21,940
it's a lot of reorganization and editing; you simplify things.

00:05:21,940 --> 00:05:24,200
You take features away that you didn't need,

00:05:24,200 --> 00:05:28,100
or extensibility that wasn't necessary to accomplish the task.

00:05:28,100 --> 00:05:31,000
And then the hardest one is really redraw boundaries.

00:05:31,010 --> 00:05:33,660
If you have classes that relate to each other in some way,

00:05:33,660 --> 00:05:35,660
or modules that relate to each other in some way,

00:05:35,660 --> 00:05:39,000
you move the boundaries between those responsibilities.

00:05:39,000 --> 00:05:41,020
That's the really difficult one to understand

00:05:41,020 --> 00:05:43,280
that I'm going to get into.

00:05:44,740 --> 00:05:46,720
After you see this you say, "Okay, well I want to be

00:05:46,720 --> 00:05:48,720
"a great programmer.

00:05:48,720 --> 00:05:50,740
I want to learn all about this."

00:05:50,740 --> 00:05:52,980
This is the canonical reference on how to do this.

00:05:52,980 --> 00:05:56,080
It contains a lot of magical incantations

00:05:56,080 --> 00:05:59,120
that you can use in your codebase to improve the quality of it,

00:05:59,120 --> 00:06:01,160
and it's great.

00:06:01,160 --> 00:06:03,120
I really recommend reading it, but there's one very big problem

00:06:03,120 --> 00:06:05,100
which is that it's really for Java programmers.

00:06:05,100 --> 00:06:07,100
This is not a criticism of Java,

00:06:07,100 --> 00:06:09,140
it's just that it doesn't make any sense to a Python programmer.

00:06:09,150 --> 00:06:11,730
It's the way that you think about solving problems.

00:06:11,730 --> 00:06:13,970
It's very single paradigm; it's all about classes.

00:06:14,960 --> 00:06:18,479
There's a more recent version of this book,

00:06:18,479 --> 00:06:20,499
another "Refactoring" edition --

00:06:20,500 --> 00:06:23,960
same concepts, but it's for Ruby programmers,

00:06:23,960 --> 00:06:26,360
so we're still left out here.

00:06:26,360 --> 00:06:29,210
We don't know what to do.

00:06:29,210 --> 00:06:32,100
The goal of this talk is to talk about refactoring Python.

00:06:32,100 --> 00:06:34,130
I wrote a book called "Effective Python."

00:06:34,130 --> 00:06:35,970
It's not about refactoring in particular,

00:06:35,970 --> 00:06:37,750
but it's about the tools that you can use

00:06:37,750 --> 00:06:39,590
to write better Python.

00:06:39,590 --> 00:06:41,380
My goal here is to provide some kind of Rosetta Stone

00:06:41,380 --> 00:06:44,180
to take the lessons from refactoring

00:06:44,180 --> 00:06:46,889
and apply them to Python so that you have some takeaways

00:06:46,889 --> 00:06:49,320
that you can use to refactor your Python code.

00:06:49,320 --> 00:06:51,480
So that's what we're trying to do.

00:06:51,480 --> 00:06:53,420
I'm going to go through some specific strategies

00:06:53,430 --> 00:06:55,210
on refactoring Python.

00:06:55,210 --> 00:06:57,040
These are the three, I think, that matter.

00:06:57,040 --> 00:06:59,060
That book, "Refactoring," has tons of other ones,

00:06:59,060 --> 00:07:01,080
but these are really the only three

00:07:01,080 --> 00:07:03,020
that I think you need to know.

00:07:03,020 --> 00:07:05,400
Everything else kind of follows from these three.

00:07:05,400 --> 00:07:07,400
Before you try to refactor your code,

00:07:07,400 --> 00:07:09,260
there's a few prerequisites.

00:07:09,260 --> 00:07:11,060
You need to have tests.

00:07:11,060 --> 00:07:12,860
If you don't have tests, you don't have time to write tests,

00:07:12,860 --> 00:07:14,640
I can't help you,

00:07:14,640 --> 00:07:16,400
and maybe you should just leave the talk.

00:07:16,400 --> 00:07:18,440
I don't know if it's the right place for you to be.

00:07:18,440 --> 00:07:21,160
You need to have quick tests, so every time you change your code

00:07:21,160 --> 00:07:24,100
for refactoring, you're going to have to run the tests again.

00:07:24,110 --> 00:07:26,870
If your test suite takes 5 minutes or 10 minutes to run,

00:07:26,870 --> 00:07:28,840
you're going to have a bad time.

00:07:28,850 --> 00:07:30,670
The other thing is you need source control.

00:07:30,670 --> 00:07:32,420
You're going to make mistakes,

00:07:32,420 --> 00:07:34,260
and so every time you make a mistake,

00:07:34,260 --> 00:07:36,060
you need a way to back it out.

00:07:36,060 --> 00:07:37,860
It might be a few days later that you realize

00:07:37,860 --> 00:07:39,880
you've made a horrible mistake and you need to go all the way back.

00:07:39,880 --> 00:07:42,100
So get whatever tool you want to use.

00:07:42,100 --> 00:07:43,960
And the last thing is you just need to be willing

00:07:43,960 --> 00:07:45,720
to make mistakes.

00:07:45,720 --> 00:07:47,560
I think that some people are unwilling to refactor

00:07:47,560 --> 00:07:49,340
because they're like, "Well it already works,

00:07:49,340 --> 00:07:51,120
"I don't want to break it."

00:07:51,120 --> 00:07:52,920
And you have to get out of that mindset.

00:07:52,920 --> 00:07:54,740
Alright, so let's go through the first example here

00:07:54,740 --> 00:07:56,760
which is extract variable and extract function.

00:07:56,770 --> 00:07:58,730
These are the terms actually from the "Refactoring" book

00:07:58,730 --> 00:08:00,760
that they use.

00:08:00,760 --> 00:08:02,840
Okay, so we have some code here.

00:08:02,840 --> 00:08:04,860
From here on out it's just me reading a lot of code,

00:08:04,860 --> 00:08:07,060
so bear with me.

00:08:07,770 --> 00:08:09,730
I have a function that determines what you should be eating

00:08:09,730 --> 00:08:13,010
in which month, and so you pass a month into this,

00:08:13,010 --> 00:08:15,310
it checks to see if it ends with "r" or "ary".

00:08:15,310 --> 00:08:17,370
If it is, that's a good time to eat oysters.

00:08:17,370 --> 00:08:19,350
It's an old rule of thumb.

00:08:19,350 --> 00:08:21,320
If the month is sometime in the summer,

00:08:21,320 --> 00:08:23,840
you should be eating tomatoes, and otherwise it's probably asparagus.

00:08:23,840 --> 00:08:26,300
That's kind of my internal way of thinking about it.

00:08:27,280 --> 00:08:29,760
If you actually test this code, it works properly,

00:08:29,760 --> 00:08:31,840
so November you have oysters, July you have tomatoes,

00:08:31,840 --> 00:08:34,300
March you have asparagus, okay, so it works.

00:08:35,050 --> 00:08:37,459
The problem with this code is that a lot of these statements --

00:08:37,460 --> 00:08:39,280
the "if" statements get pretty complicated.

00:08:39,280 --> 00:08:41,000
There's a lot going on.

00:08:41,000 --> 00:08:42,800
It looks really simple at first, but what you can do is

00:08:42,800 --> 00:08:44,660
you take each of these kind of Boolean expressions

00:08:44,660 --> 00:08:48,840
and pull them up into variables at the top of the source,

00:08:48,840 --> 00:08:51,319
and when you do that you see that there actually were

00:08:51,319 --> 00:08:53,800
all these hidden variables in the code below

00:08:53,800 --> 00:08:56,340
that exposed how complicated this actually was.

00:08:56,340 --> 00:08:58,140
This doesn't look that complicated,

00:08:58,140 --> 00:09:00,060
but when you pull all the variables out to the top,

00:09:00,060 --> 00:09:02,120
you're like, "Wow, that's actually a lot of things going on in there.

00:09:02,120 --> 00:09:04,120
"I didn't realize that."

00:09:04,120 --> 00:09:06,160
So that's just extracting a variable.

00:09:06,160 --> 00:09:08,720
You make it more clear at each level

00:09:08,720 --> 00:09:10,540
what tests you're trying to do.

00:09:10,540 --> 00:09:12,540
In Python when you make any kind of expression,

00:09:12,540 --> 00:09:14,320
you're doing this anyway.

00:09:14,320 --> 00:09:16,180
There's really not a performance hit

00:09:16,180 --> 00:09:18,180
that you might expect, so there's no reason not to do this.

00:09:18,180 --> 00:09:20,320
Always prefer clarity if you can.

00:09:21,320 --> 00:09:23,400
But we can go a little bit further.

00:09:23,410 --> 00:09:25,810
So instead of extracting it into variables,

00:09:25,810 --> 00:09:27,870
we can extract them into functions.

00:09:27,870 --> 00:09:30,220
We can say, "Okay, let's actually have one function

00:09:30,230 --> 00:09:32,260
"that determines if the oysters are good,

00:09:32,260 --> 00:09:34,060
"and one function that determines

00:09:34,060 --> 00:09:35,839
"if tomatoes are good."

00:09:35,839 --> 00:09:38,399
And when we go back to the same code again,

00:09:38,399 --> 00:09:41,339
we have this complexity from before,

00:09:41,340 --> 00:09:43,780
and what we can do is we can replace

00:09:43,790 --> 00:09:45,550
each of these Boolean kind of statements

00:09:45,550 --> 00:09:47,360
with a call to the function.

00:09:47,360 --> 00:09:49,360
This is really easy to read; it's extremely obvious.

00:09:49,360 --> 00:09:51,320
If oysters are good, then you should eat oysters.

00:09:51,320 --> 00:09:53,360
If tomatoes are good, you should eat tomatoes,

00:09:53,360 --> 00:09:55,800
otherwise asparagus.

00:09:55,800 --> 00:09:59,319
But there's one overarching problem with this,

00:09:59,319 --> 00:10:02,399
which is that if the function that actually determines

00:10:02,399 --> 00:10:04,319
if "oysters are good to eat" is slow --

00:10:04,319 --> 00:10:06,359
for some reason it has to look things up

00:10:06,360 --> 00:10:08,640
in a database, you know, something like that --

00:10:08,640 --> 00:10:10,899
then calling it inline in the if statement like this

00:10:10,899 --> 00:10:14,179
is actually, maybe, could cause a performance problem.

00:10:14,180 --> 00:10:17,500
So you can combine these two ideas of extracting a function

00:10:17,510 --> 00:10:19,749
and extracting a variable by pulling out these functions

00:10:19,749 --> 00:10:22,170
at the top and then saying, "Okay, well, time for oysters

00:10:22,170 --> 00:10:25,460
"is this variable, based on this function call,

00:10:25,470 --> 00:10:27,400
"the return value from this function."

00:10:27,400 --> 00:10:29,780
Time for tomatoes, the same thing using down below.

00:10:29,780 --> 00:10:31,540
Now we have kind of the best of these two.

00:10:31,540 --> 00:10:33,340
We have the cached value,

00:10:33,340 --> 00:10:35,240
so we don't have to do computation multiple times,

00:10:35,240 --> 00:10:37,200
and we have clarity in the if statements

00:10:37,209 --> 00:10:39,200
at the bottom.

00:10:39,200 --> 00:10:41,220
Now, if you've ever written code like this,

00:10:41,220 --> 00:10:43,819
if statements always grow for some reason,

00:10:43,819 --> 00:10:47,019
and Boolean statements always grow as well.

00:10:47,019 --> 00:10:49,360
And so these functions right now are really simple,

00:10:49,360 --> 00:10:52,560
but then suddenly someone needs to have oysters

00:10:52,560 --> 00:10:54,980
in Argentina, and then it's a Southern Hemisphere,

00:10:54,990 --> 00:10:56,930
and so then the months all change.

00:10:56,930 --> 00:10:58,730
This function is going to get more complicated

00:10:58,730 --> 00:11:00,560
and complicated over time,

00:11:00,560 --> 00:11:03,380
and so extracting a function is useful and it's helpful,

00:11:03,380 --> 00:11:05,300
but if you start adding more and more conditions in here,

00:11:05,300 --> 00:11:08,079
it's going to be really hard to understand what this is doing

00:11:08,079 --> 00:11:10,019
and how to test it.

00:11:10,020 --> 00:11:13,080
When you get to that point, my recommendation is to extract

00:11:13,089 --> 00:11:15,029
a class from this.

00:11:15,029 --> 00:11:17,000
This is the same idea but instead of a function,

00:11:17,000 --> 00:11:19,000
it's a class.

00:11:19,000 --> 00:11:21,000
It takes a month just like the other code did,

00:11:21,009 --> 00:11:24,329
but the big difference is that it saves the value

00:11:24,329 --> 00:11:28,140
in this result attribute, so it has "self.r" is

00:11:28,140 --> 00:11:30,860
does it end in "r. ary", is does it end in "ary"?

00:11:30,869 --> 00:11:33,389
And then the result is a precomputed solution

00:11:33,389 --> 00:11:35,549
to the Boolean question.

00:11:37,140 --> 00:11:39,600
It caches the result of the computation.

00:11:39,600 --> 00:11:41,920
At the bottom here is this under under bool method.

00:11:41,920 --> 00:11:46,580
which basically returns the outcome of that computation later.

00:11:46,580 --> 00:11:48,959
In Python 2, this is known as nonzero,

00:11:48,959 --> 00:11:51,579
which it might be more well-known as.

00:11:52,540 --> 00:11:54,540
We can do the exact same thing for tomatoes.

00:11:54,540 --> 00:11:57,340
So we have this class that will cache this statement,

00:11:58,380 --> 00:12:00,360
and then when you want to use it, you take the functional version

00:12:00,360 --> 00:12:02,840
you had before, and you just switch it over

00:12:02,840 --> 00:12:04,600
to the class.

00:12:04,600 --> 00:12:06,640
I'm going to show you that one more time.

00:12:06,640 --> 00:12:08,760
That's all, it's like six characters of change; that's it.

00:12:08,760 --> 00:12:11,120
But the key thing here is that these if statements --

00:12:11,129 --> 00:12:13,949
because it's a class, and the class defines bool,

00:12:13,949 --> 00:12:16,739
Python will actually call the bool method as a special method

00:12:16,739 --> 00:12:19,979
on your class when it's being evaluated in an if statement.

00:12:19,980 --> 00:12:23,540
So this makes it really easy to hide this complexity

00:12:23,540 --> 00:12:26,820
of this boolean expression inside a class.

00:12:26,820 --> 00:12:29,040
You might ask, you know, "Why am I doing that?

00:12:29,050 --> 00:12:31,369
"The function works just fine."

00:12:31,369 --> 00:12:33,349
The reason is for testing.

00:12:33,349 --> 00:12:37,319
Later on, you can go through here, create the class on its own,

00:12:37,319 --> 00:12:39,359
and then test all of the sub conditions

00:12:39,360 --> 00:12:43,280
that actually cause oyster season to be the right time to eat oysters.

00:12:43,290 --> 00:12:46,249
You extract the class to maximize the testability,

00:12:46,249 --> 00:12:48,429
and that's why you do this refactoring.

00:12:49,240 --> 00:12:51,240
The things to remember is extracted variables

00:12:51,240 --> 00:12:53,400
and functions to improve readability,

00:12:53,410 --> 00:12:55,230
if you're having trouble testing,

00:12:55,230 --> 00:12:57,060
or you have complicated testing needs, use a class,

00:12:57,060 --> 00:12:59,040
and then bool; whenever you see under under bool,

00:12:59,040 --> 00:13:01,020
it almost always means that it's a paper trail.

00:13:01,020 --> 00:13:03,040
It's trying to, you know, point at some decision

00:13:03,040 --> 00:13:05,280
that was already made.

00:13:06,580 --> 00:13:09,720
Okay, going so far.

00:13:10,520 --> 00:13:12,340
Alright, so that was extracted variables

00:13:12,340 --> 00:13:14,160
and extracting functions.

00:13:14,160 --> 00:13:16,140
Think I'm still doing okay on time.

00:13:16,140 --> 00:13:18,199
The next one we're going to talk about is extract class

00:13:18,200 --> 00:13:20,240
and move fields.

00:13:20,240 --> 00:13:22,240
Um...

00:13:23,240 --> 00:13:25,600
This is another very important thing.

00:13:25,610 --> 00:13:27,739
You have pets; you need to keep track of them.

00:13:27,739 --> 00:13:32,019
Your pet has a name, and this is the beginning of your class.

00:13:32,019 --> 00:13:34,519
You have a pet, you name your pet; I have a pet.

00:13:34,520 --> 00:13:36,560
I don't actually have a pet,

00:13:36,560 --> 00:13:38,560
but I wish I had a pet named Gregory the Gila monster.

00:13:38,560 --> 00:13:43,340
This is a small, poisonous reptile from the Southwest.

00:13:43,350 --> 00:13:46,439
So I create a pet named Gregory, print out the name,

00:13:46,439 --> 00:13:48,819
it works as expected.

00:13:48,820 --> 00:13:50,820
Another thing about a pet is you know when you got your pet,

00:13:50,820 --> 00:13:54,340
so you kind of know the pet's age, something you save on the pet class.

00:13:54,340 --> 00:13:56,120
It's not rocket science.

00:13:56,120 --> 00:13:57,940
You've probably all done something like this.

00:13:57,940 --> 00:13:59,740
Again, I can convince you that this code works.

00:13:59,740 --> 00:14:02,699
You create a pet called Gregory the Gila, age of three,

00:14:02,699 --> 00:14:04,899
can print out the pet's name and age.

00:14:06,009 --> 00:14:08,749
Now, another really important thing about having a pet is

00:14:08,749 --> 00:14:10,789
you got to give it treats.

00:14:10,789 --> 00:14:12,960
That's just the next step after you have a name for it.

00:14:12,960 --> 00:14:15,060
So we want to keep a counter of how many treats

00:14:15,060 --> 00:14:17,600
we've given Gregory so we know, you know, how he's doing.

00:14:17,600 --> 00:14:19,660
I add a function for that that's going to keep track

00:14:19,660 --> 00:14:21,600
of the treats.

00:14:21,620 --> 00:14:23,820
This is not refactoring yet; we're not there.

00:14:24,620 --> 00:14:27,920
Again, I can prove to you that this code works as advertised.

00:14:29,980 --> 00:14:34,200
Now, over time, this class is going to get more and more things in it.

00:14:34,209 --> 00:14:36,629
You know, if you have a pet, you need to keep track of its needs.

00:14:36,629 --> 00:14:38,870
Depending on what kind of pet it is, it has different needs,

00:14:38,870 --> 00:14:42,040
so I've added some other methods to this class.

00:14:42,040 --> 00:14:43,880
Does it have scales?

00:14:43,880 --> 00:14:45,660
Does it lay eggs? Does it drink milk?

00:14:45,660 --> 00:14:47,680
These are all things I need to know

00:14:47,680 --> 00:14:49,640
in order to take care of the pet.

00:14:50,829 --> 00:14:54,419
I can add some additional helper methods in here

00:14:54,419 --> 00:14:56,779
to act on those attributes.

00:14:56,780 --> 00:14:59,180
While I've added the attributes at the bottom here --

00:14:59,180 --> 00:15:01,180
has scales, lays eggs, drinks milk --

00:15:01,180 --> 00:15:03,860
I can add a property to this pet class to say,

00:15:03,860 --> 00:15:05,900
"Hey, does Gregory the Gila monster need a heat lamp?

00:15:05,910 --> 00:15:08,919
"He's my pet, he's not living in the desert of the Southwest,

00:15:08,919 --> 00:15:11,099
he needs to stay warm, how do we do that?"

00:15:11,100 --> 00:15:13,360
This is a little property that just says,

00:15:13,360 --> 00:15:15,679
"Okay, if it has scales, and it lays eggs,

00:15:15,679 --> 00:15:18,110
"and it doesn't drink milk, it's probably a reptile;

00:15:18,110 --> 00:15:20,390
"it probably needs a heat lamp."

00:15:22,020 --> 00:15:25,280
Again I can show you that if I pass the correct parameters

00:15:25,290 --> 00:15:27,490
into the constructor pet, this works as advertised.

00:15:28,680 --> 00:15:31,840
Gregory the Gila monster definitely needs a heat lamp.

00:15:33,540 --> 00:15:36,720
Now, this is a trivial kind of made-up example,

00:15:36,720 --> 00:15:38,560
but this is already getting complicated.

00:15:38,560 --> 00:15:40,380
We have a bunch of fields in here.

00:15:40,380 --> 00:15:42,140
We have a bunch of concerns

00:15:42,140 --> 00:15:43,920
that are getting mixed together.

00:15:43,920 --> 00:15:45,960
When you see this behavior,

00:15:45,960 --> 00:15:47,980
where it becomes a classic kind of encompasses everything together,

00:15:47,980 --> 00:15:49,959
that's a great time to refactor.

00:15:49,959 --> 00:15:52,839
It's kind of a hint that it's time to refactor.

00:15:52,840 --> 00:15:56,560
In the case of a pet, you know there's the petness of this class:

00:15:56,560 --> 00:15:59,740
the name, the treats I'm giving it, when I got it.

00:15:59,740 --> 00:16:01,780
Then there's the animal parts of it,

00:16:01,780 --> 00:16:03,780
like the fact that it has scales and it lays eggs.

00:16:03,780 --> 00:16:07,820
In my mind, that's a really great boundary to refactor this on.

00:16:07,820 --> 00:16:11,740
So let's talk about what refactoring a boundary is.

00:16:13,580 --> 00:16:18,000
Before when we were refactoring, we just went through,

00:16:18,000 --> 00:16:19,840
found code that was bad, kind of rewrote it,

00:16:19,840 --> 00:16:21,620
retested it, and we were done.

00:16:21,620 --> 00:16:23,620
When you're trying to change boundaries

00:16:23,620 --> 00:16:25,620
like the relationships between classes, you got to do

00:16:25,620 --> 00:16:28,859
a lot more than that because the usage is more complicated,

00:16:28,859 --> 00:16:30,839
so you add a new interface,

00:16:30,840 --> 00:16:33,440
a better way of interacting with the class hierarchy.

00:16:33,440 --> 00:16:35,440
You maintain backwards compatibility

00:16:35,440 --> 00:16:37,440
with the code that was there before so you don't break everything,

00:16:37,440 --> 00:16:39,519
so you can keep testing and making forward progress.

00:16:39,520 --> 00:16:41,980
You issue warnings for any old usage,

00:16:41,989 --> 00:16:44,169
and I'll get to what that means in a second.

00:16:44,169 --> 00:16:47,209
Then you spend as much time as you can migrating

00:16:47,209 --> 00:16:49,359
all of the old usage into the new usage

00:16:49,359 --> 00:16:53,679
that you can get rid of the old code paths.

00:16:53,680 --> 00:16:55,680
Once you do the migration, you run tests,

00:16:55,680 --> 00:16:57,739
you verify they're working, you improve those tests.

00:16:57,739 --> 00:17:00,739
At the very end, you get to remove the code for the old interface.

00:17:00,739 --> 00:17:02,719
You've refactored everything, you're done,

00:17:02,720 --> 00:17:04,920
you can get rid of the second path.

00:17:06,920 --> 00:17:10,020
This is what I'm going to try to show you on that class.

00:17:10,780 --> 00:17:12,560
But before we go a little bit further,

00:17:12,560 --> 00:17:14,580
I just wanted to talk about warnings.

00:17:14,580 --> 00:17:16,560
Warnings are built into Python; it's a module, you can just import it.

00:17:16,560 --> 00:17:18,540
This is how you use it: you call warnings.warn,

00:17:18,540 --> 00:17:20,540
you give it a message.

00:17:20,540 --> 00:17:22,539
By default, it prints the message to standard error.

00:17:22,539 --> 00:17:24,870
If you're using various libraries, you probably see these already

00:17:24,870 --> 00:17:26,820
when you run the tests.

00:17:26,820 --> 00:17:28,899
There's a bunch of warnings printed as standard error.

00:17:28,899 --> 00:17:30,819
The reason that they're powerful is that you can run Python

00:17:30,820 --> 00:17:33,880
in a mode, and you can also do it by configuring the module itself,

00:17:33,880 --> 00:17:35,840
but you can run it in a mode

00:17:35,840 --> 00:17:37,800
so that all of these warnings become errors.

00:17:37,800 --> 00:17:39,820
That makes it really easy to say, "Okay, run this code,

00:17:39,820 --> 00:17:43,340
"run the tests, the tests all pass, great, run this code again,

00:17:43,340 --> 00:17:45,299
"but this time, every time you hit a warning,

00:17:45,299 --> 00:17:47,239
"raise an exception instead."

00:17:47,240 --> 00:17:49,000
That lets you pinpoint all of the various places

00:17:49,009 --> 00:17:50,809
in your code that you actually have to --

00:17:50,809 --> 00:17:52,689
that you're in the midst of refactoring,

00:17:52,689 --> 00:17:54,409
that you need to move over to the new usage.

00:17:54,409 --> 00:17:56,480
That's why you use warnings to do this.

00:17:56,480 --> 00:17:59,520
It's a tool to find the old ways so that you can replace them.

00:18:01,460 --> 00:18:03,760
Okay, so now I'm going to try to go through

00:18:03,769 --> 00:18:05,929
actually refactoring this thing.

00:18:07,600 --> 00:18:11,880
I'm going to extract this animal class from pet.

00:18:11,890 --> 00:18:14,100
This is pet before, this is animal after.

00:18:14,100 --> 00:18:17,380
It just pulls out the has scales, those other attributes.

00:18:17,380 --> 00:18:19,340
That's straightforward enough.

00:18:19,340 --> 00:18:21,380
It's a new class with the same attributes.

00:18:21,380 --> 00:18:23,460
The pet class before has a name and an age,

00:18:23,470 --> 00:18:25,410
and then all those other attributes.

00:18:25,410 --> 00:18:27,450
I'm going to pull all those other attributes out,

00:18:27,450 --> 00:18:30,920
and then I'm going to have pet take an animal instance instead.

00:18:31,520 --> 00:18:33,560
That's what I'm doing here.

00:18:33,560 --> 00:18:36,180
Now, you'll notice that the animal instance here

00:18:36,180 --> 00:18:38,100
starts off assigned to none.

00:18:38,100 --> 00:18:40,660
The reason I'm doing that is to make it so it's an optional parameter;

00:18:40,669 --> 00:18:43,849
it's not necessary to pass it.

00:18:43,849 --> 00:18:47,000
If the caller doesn't pass it, then they might have used the old usage,

00:18:47,010 --> 00:18:49,210
which I'll demonstrate to you in a second.

00:18:50,160 --> 00:18:51,980
Here's what the body of this looks like.

00:18:51,980 --> 00:18:53,740
Now this looks really intimidating,

00:18:53,740 --> 00:18:55,580
but it's really not that complicated.

00:18:55,580 --> 00:18:57,380
Let me just walk you through it.

00:18:57,380 --> 00:18:59,720
The top statement is saying, "Hey, if you pass both keyword arguments

00:18:59,730 --> 00:19:02,880
"like has scales, and you passed an animal instance,

00:19:02,880 --> 00:19:04,800
"then you're doing something wrong."

00:19:04,800 --> 00:19:06,840
You used both the old style and the new style at the same time,

00:19:06,850 --> 00:19:08,830
and you shouldn't do that.

00:19:08,830 --> 00:19:10,830
It's either the old way or the new way, not both.

00:19:10,830 --> 00:19:12,850
This raises a type error to specifically tell you

00:19:12,850 --> 00:19:16,070
to stop doing that, and that it's not an allowed usage.

00:19:16,640 --> 00:19:19,340
On the next line, the next gray block there,

00:19:19,340 --> 00:19:21,309
if the animal is none, then that's saying,

00:19:21,309 --> 00:19:23,539
"Hey, you used it the old way, the old class.

00:19:23,539 --> 00:19:25,600
"You didn't actually hand me an animal instance

00:19:25,600 --> 00:19:28,640
"as a positional argument, so I'm going to issue a warning

00:19:28,640 --> 00:19:30,460
"to you to say, 'Hey, you should use animal

00:19:30,460 --> 00:19:32,260
"instead of the old way,'

00:19:32,260 --> 00:19:34,060
"and then I'm going to construct an animal for you."

00:19:34,060 --> 00:19:35,840
That's the backwards compatibility part of this.

00:19:35,840 --> 00:19:37,860
That's that third gray block.

00:19:37,860 --> 00:19:40,520
The rest of the constructor just goes as normal.

00:19:40,520 --> 00:19:42,740
It takes the animal, pulls it in.

00:19:43,660 --> 00:19:47,080
Now you can see I can verify that this works as advertised.

00:19:47,080 --> 00:19:49,130
I create an animal instance, and then on this line,

00:19:49,130 --> 00:19:51,850
I pass both an animal and has scales to the function,

00:19:51,850 --> 00:19:53,890
and it freaks out, and it raises an exception.

00:19:53,890 --> 00:19:56,310
You can't do this; you can't mix old and new at the same time.

00:19:59,740 --> 00:20:02,160
Similarly, if I just create a pet,

00:20:02,160 --> 00:20:04,160
this continues to work.

00:20:04,160 --> 00:20:05,920
I don't have an animal instance in here at all.

00:20:05,920 --> 00:20:07,700
It's not even mentioned.

00:20:07,700 --> 00:20:09,520
I just pass in has scales and lays eggs.

00:20:09,520 --> 00:20:11,380
When you do that, you'll actually get a warning

00:20:11,380 --> 00:20:13,400
from Python which is "should use animal",

00:20:13,400 --> 00:20:15,380
so that you know that you're doing something wrong.

00:20:15,380 --> 00:20:17,560
You should migrate your code.

00:20:18,440 --> 00:20:21,440
If you use it correctly, then there are no warnings at all.

00:20:21,440 --> 00:20:23,460
You create an animal class,

00:20:23,460 --> 00:20:25,440
you hand the animal class to the pet class,

00:20:25,440 --> 00:20:27,460
everything works fine.

00:20:27,460 --> 00:20:30,260
That's just the constructors part of this.

00:20:30,260 --> 00:20:32,280
The next part of this is the fields.

00:20:32,280 --> 00:20:35,740
Pet has these fields has scales, lays eggs, drinks milk.

00:20:35,740 --> 00:20:38,940
We need to move those fields from pet into the animal,

00:20:40,160 --> 00:20:42,980
and what I mean by that is that any time someone accesses pet,

00:20:42,980 --> 00:20:45,640
I want them to continue to work the way they did,

00:20:45,640 --> 00:20:47,640
but they should access the animal fields

00:20:47,640 --> 00:20:49,659
instead of the pet fields.

00:20:49,659 --> 00:20:54,239
Python has this great property helper decorator that you can use.

00:20:54,240 --> 00:20:56,660
What you can do is you can intercept a call

00:20:56,660 --> 00:20:59,000
to the old attribute, like has scales here,

00:20:59,000 --> 00:21:01,940
and you can essentially forward that request for that attribute

00:21:01,940 --> 00:21:03,720
into the inner class.

00:21:03,720 --> 00:21:06,560
So pet can say, "Hey, thank you for asking for has scales.

00:21:06,560 --> 00:21:08,560
"I'm going to warn you that you shouldn't do that,

00:21:08,560 --> 00:21:10,500
"but I'm still going to give you the answer you need

00:21:10,500 --> 00:21:13,660
"by asking the internal animal class."

00:21:13,660 --> 00:21:15,640
That's what's happening here.

00:21:15,640 --> 00:21:17,640
You can do that for all of the properties

00:21:17,640 --> 00:21:19,840
that you're trying to keep backwards compatibility with.

00:21:21,240 --> 00:21:23,500
Indeed when we put this to the test, we can see

00:21:23,510 --> 00:21:26,730
that on this line with the gray, we're accessing the has scales.

00:21:26,730 --> 00:21:30,230
It works as advertised by yes, Gregory Gila has scales.

00:21:30,230 --> 00:21:32,210
But then it warns us that,

00:21:32,210 --> 00:21:34,200
"Hey, you should be using the animal attribute instead."

00:21:34,200 --> 00:21:36,320
If we use the correct usage here on animal,

00:21:36,320 --> 00:21:38,480
then we don't get a warning but we get the same result.

00:21:38,480 --> 00:21:40,680
You can see that's the only difference there, is that animal.

00:21:42,460 --> 00:21:44,680
The last bit of this is the helper class,

00:21:44,690 --> 00:21:46,620
or the helper method.

00:21:46,620 --> 00:21:51,899
The needs heat lamp, you know, we want to move this over as well.

00:21:51,899 --> 00:21:53,639
This is about the pet needing a heat lamp.

00:21:53,640 --> 00:21:55,440
It's not about the animal needing a heat lamp,

00:21:55,440 --> 00:21:57,240
because it has the sun in the desert.

00:21:57,240 --> 00:21:59,260
We're not actually going to move this method.

00:21:59,260 --> 00:22:01,540
We're just going to forward the attribute access.

00:22:01,540 --> 00:22:03,919
We just add animal to the inside of that,

00:22:03,919 --> 00:22:06,179
and then we consider this refactored.

00:22:07,580 --> 00:22:10,140
Then when we access that helper, it's not going to warn --

00:22:10,149 --> 00:22:11,909
there's no reason for it to warn.

00:22:11,909 --> 00:22:13,749
The usage is still okay, we just fixed the usage

00:22:13,749 --> 00:22:15,789
so there's no problem.

00:22:16,540 --> 00:22:18,840
Okay, so that's splitting a class.

00:22:18,850 --> 00:22:20,870
Things to remember here are to do that,

00:22:20,870 --> 00:22:22,860
you use optional arguments.

00:22:22,860 --> 00:22:24,820
That's the best way to split a class.

00:22:24,820 --> 00:22:26,860
You use property to move methods and fields

00:22:26,860 --> 00:22:30,180
between the classes and inner classes.

00:22:30,180 --> 00:22:32,500
Then you can issue warnings to let you know,

00:22:32,509 --> 00:22:34,389
"Hey, this is where my code is having issues

00:22:34,389 --> 00:22:36,169
"with the old usage.

00:22:36,169 --> 00:22:37,989
"This is what I actually have to migrate over

00:22:37,989 --> 00:22:40,169
"to the new usage."

00:22:41,260 --> 00:22:43,200
So then I wanted to talk about some gotchas.

00:22:43,200 --> 00:22:45,400
If you actually try to apply this advice,

00:22:45,400 --> 00:22:47,400
you're going to get burned in a bunch of subtle ways

00:22:47,400 --> 00:22:51,140
that are unique to Python, and I want to go through those.

00:22:52,040 --> 00:22:55,860
So going back to the refactored state,

00:22:57,060 --> 00:22:59,020
let's say that we've refactored everything,

00:22:59,020 --> 00:23:01,720
and this is what we're left with: We have this animal and the pet.

00:23:01,720 --> 00:23:03,740
You know, is this really obvious? is the question.

00:23:03,740 --> 00:23:05,700
That's what you should always be asking yourself

00:23:05,700 --> 00:23:07,700
when you're refactoring.

00:23:07,700 --> 00:23:09,740
I would say no, because an age of a pet is actually

00:23:09,740 --> 00:23:12,120
more of an intrinsic property of the animal when it was born,

00:23:12,120 --> 00:23:14,440
its existence; it has nothing to do with it being your pet.

00:23:14,450 --> 00:23:16,650
You could say when you adopted it, but that's not its age.

00:23:16,650 --> 00:23:18,620
Those are different things.

00:23:18,620 --> 00:23:21,320
So I'm going to try to refactor the age attribute

00:23:21,320 --> 00:23:25,700
into the animal class to move the field.

00:23:27,180 --> 00:23:29,180
This is the general idea.

00:23:29,180 --> 00:23:31,180
I'm going to take age from down here,

00:23:31,180 --> 00:23:33,100
and I'm going to put it up there.

00:23:33,100 --> 00:23:35,700
To do this, first I take the animal class

00:23:35,700 --> 00:23:37,560
and I change its constructor.

00:23:37,560 --> 00:23:39,360
It's going to have the age property --

00:23:39,360 --> 00:23:41,160
it's optional because it defaults to none.

00:23:41,160 --> 00:23:43,100
Then I'm going to have this one if statement in there

00:23:43,100 --> 00:23:45,120
which is going to issue a warning, say "Hey, this is the old usage.

00:23:45,120 --> 00:23:47,740
"You didn't pass the age to animal, so I'm going to warn you

00:23:47,740 --> 00:23:50,740
"that you didn't do that; You should specify the age."

00:23:50,740 --> 00:23:52,900
The rest of it is really straightforward.

00:23:54,680 --> 00:23:57,640
On the pet side, things are going to get more complicated.

00:23:57,640 --> 00:23:59,600
Now I have this age parameter there.

00:23:59,600 --> 00:24:01,680
I don't want the age parameter there anymore.

00:24:01,680 --> 00:24:05,180
I want age to be backwards compatible only.

00:24:05,180 --> 00:24:07,600
In order to do that, I'm going to change this parameter,

00:24:07,600 --> 00:24:10,519
maybe age and maybe animal, and what this is saying is

00:24:10,519 --> 00:24:16,919
that you can pass two or three positional arguments to this method.

00:24:16,920 --> 00:24:21,840
Then I'm going to act on it depending on how many you passed me.

00:24:21,840 --> 00:24:25,419
The first if case here is if maybe animal's not none.

00:24:25,419 --> 00:24:27,479
That's saying, "If you pass me three parameters,

00:24:27,480 --> 00:24:29,440
"then I'm assuming you gave me the old usage

00:24:29,440 --> 00:24:31,420
"where it was the name of the animal,

00:24:31,420 --> 00:24:33,920
"the age of the animal, and the animal class itself.

00:24:33,920 --> 00:24:36,980
"If animal is not none that means you have the old usage.

00:24:36,980 --> 00:24:40,480
"I'm going to warn you, I'm going to save the animal instance,

00:24:40,480 --> 00:24:42,500
"and then I'm going to assign the animal age myself

00:24:42,510 --> 00:24:44,520
"for you for backwards compatibility."

00:24:44,520 --> 00:24:46,800
That's that second gray box.

00:24:46,800 --> 00:24:50,780
Otherwise, if you didn't pass animal, then animal is none.

00:24:50,789 --> 00:24:52,500
Then that means that the maybe age parameter,

00:24:52,500 --> 00:24:54,340
the second perameter, that just has to be the animal.

00:24:54,340 --> 00:24:56,140
So you call this with two parameters

00:24:56,140 --> 00:24:57,920
instead of three.

00:24:57,920 --> 00:25:00,120
I just assign it, pretty straightforward.

00:25:01,280 --> 00:25:05,500
Similarly, from before I used the property decorator

00:25:05,510 --> 00:25:08,640
to provide a forwarding of an internal field,

00:25:08,640 --> 00:25:10,440
I'll do the same thing here.

00:25:10,440 --> 00:25:12,220
I'll take age on pet, and I'll just forward that

00:25:12,220 --> 00:25:14,020
to the internal animal class instead.

00:25:14,020 --> 00:25:16,000
This is a backwards compatible.

00:25:16,000 --> 00:25:18,020
I'll warn about it, so if anyone is using it,

00:25:18,020 --> 00:25:22,060
I'll let them know so they have to migrate their usage.

00:25:22,060 --> 00:25:24,000
Now we can test this out.

00:25:24,000 --> 00:25:26,020
We can create an animal class in the old style

00:25:26,029 --> 00:25:27,840
where the animal has these attributes

00:25:27,840 --> 00:25:29,640
but the age is still on pet.

00:25:29,640 --> 00:25:31,400
This will issue a ton of warnings.

00:25:31,400 --> 00:25:33,260
On the animal class, it issues a warning

00:25:33,260 --> 00:25:35,000
because you didn't pass age.

00:25:35,000 --> 00:25:36,800
On the pet classes, it issues a warning

00:25:36,800 --> 00:25:38,620
because you did pass age.

00:25:38,620 --> 00:25:40,460
Then when you actually print out the age at the bottom here,

00:25:40,460 --> 00:25:42,480
that also issues a warning because you're accessing

00:25:42,480 --> 00:25:44,440
the attribute in the wrong place,

00:25:44,460 --> 00:25:46,480
but it still works.

00:25:46,480 --> 00:25:48,760
So you can migrate your code one piece at a time.

00:25:48,760 --> 00:25:52,120
The new usage on the other hand doesn't issue any warnings at all.

00:25:52,129 --> 00:25:54,490
You pass the age into animal,

00:25:54,490 --> 00:25:57,440
you access the age property on the animal when you print it out.

00:25:57,440 --> 00:26:00,640
You don't pass any age into the pet constructor, no problem.

00:26:03,600 --> 00:26:06,520
Now, one thing if you've had pets, what happens is --

00:26:06,529 --> 00:26:08,970
it's always like someone's pet is much older than they thought.

00:26:08,970 --> 00:26:10,950
This happens a lot of the time, and so you're going

00:26:10,950 --> 00:26:13,639
and so you're going to need to reassign the pet's age.

00:26:13,639 --> 00:26:16,660
This is going to happen at some point.

00:26:16,660 --> 00:26:18,640
You go in and you say, "Okay, I have this pet,

00:26:18,640 --> 00:26:20,680
"I'm going to reassign his age to five."

00:26:20,680 --> 00:26:23,020
You'd be surprised that when you try to do this

00:26:23,020 --> 00:26:25,340
you get an error of "can't set attribute".

00:26:25,340 --> 00:26:28,860
The reason is that you handled the read case of the age attribute,

00:26:28,860 --> 00:26:30,860
but you didn't handle the right case,

00:26:30,860 --> 00:26:32,840
the set or the get.

00:26:32,840 --> 00:26:35,060
So you actually need to use properties' extra bit here,

00:26:35,060 --> 00:26:37,240
called setter; again, it's built into Python,

00:26:37,250 --> 00:26:39,850
built into the property decorator,

00:26:39,850 --> 00:26:43,030
and you would add another compatibility property for set.

00:26:43,030 --> 00:26:46,650
That would take the new age that the pet has,

00:26:46,650 --> 00:26:48,670
and it would forward that assignment

00:26:48,670 --> 00:26:50,880
down into the inner class of the animal.

00:26:50,880 --> 00:26:52,899
It would also issue a warning.

00:26:52,899 --> 00:26:56,039
Now this code would work as advertised, as you'd expect

00:26:56,039 --> 00:26:58,130
based on the old style, but it would issue a warning

00:26:58,130 --> 00:27:00,350
when you do that, so you know you need to migrate it.

00:27:01,980 --> 00:27:04,640
If you do it the right way, then you don't get a warning.

00:27:06,400 --> 00:27:10,040
Finally, you have this animal class,

00:27:10,040 --> 00:27:11,820
age is in the right place.

00:27:11,820 --> 00:27:13,680
You have a pet class that has no concept of age.

00:27:13,680 --> 00:27:15,400
Everything's going great.

00:27:15,400 --> 00:27:17,240
Again, Gregory's older than you thought.

00:27:17,240 --> 00:27:19,240
You're trying to reassign this, and let's say that you interact

00:27:19,240 --> 00:27:21,260
with pet classes all the time so you're writing some code

00:27:21,260 --> 00:27:23,200
to assign the age to five.

00:27:23,200 --> 00:27:25,200
A question is, what's going to happen here?

00:27:25,200 --> 00:27:27,380
What do you expect to happen here?

00:27:27,760 --> 00:27:30,220
It's doubly broken.

00:27:30,220 --> 00:27:32,200
If in your mind you have muscle memory

00:27:32,200 --> 00:27:34,840
of how to use the pet class, you've assigned the age,

00:27:34,840 --> 00:27:36,840
you've done this refactoring, you moved the age property

00:27:36,840 --> 00:27:39,020
from pet into animal, when you do this assignment,

00:27:39,020 --> 00:27:42,320
Python, for better or worse, will just assign any property

00:27:42,320 --> 00:27:44,700
to any class just because you said so.

00:27:44,700 --> 00:27:47,539
You can hide errors in here where you didn't even realize

00:27:47,539 --> 00:27:50,239
that you were using the old usage.

00:27:50,240 --> 00:27:52,360
You assign the age to five, but you actually --

00:27:52,360 --> 00:27:54,180
it stays as three

00:27:54,180 --> 00:27:55,960
because those are actually different properties.

00:27:55,960 --> 00:27:57,740
One is on the animal, and one is on the pet.

00:27:57,740 --> 00:27:59,760
That's one of these big gotchas you'll get in Python refactoring,

00:27:59,760 --> 00:28:01,700
especially around assignable attributes.

00:28:01,700 --> 00:28:03,840
The only real way to defend against this --

00:28:03,840 --> 00:28:05,600
so yeah, no error.

00:28:05,600 --> 00:28:07,440
That's what I'm trying to say here.

00:28:07,440 --> 00:28:09,460
The only real way to defend against this is

00:28:09,460 --> 00:28:11,440
to leave tombstones around; these are attributes.

00:28:11,450 --> 00:28:13,440
The only goal of these properties is

00:28:13,440 --> 00:28:15,440
to raise exceptions when you do something wrong.

00:28:15,440 --> 00:28:17,480
So if you have code that's been used a certain way

00:28:17,480 --> 00:28:19,420
for a very long period of time, and now you're migrating it over

00:28:19,420 --> 00:28:22,140
to some new style, you should leave these around

00:28:22,149 --> 00:28:24,630
for a while because they'll catch really simple errors.

00:28:24,630 --> 00:28:27,990
They'll raise exceptions any time someone does it the wrong way.

00:28:27,990 --> 00:28:32,059
Wow, thank you for the -- let's see.

00:28:32,059 --> 00:28:33,879
I was worried that might happen.

00:28:33,880 --> 00:28:35,640
Alright, cool.

00:28:35,640 --> 00:28:37,900
Great, okay.

00:28:38,780 --> 00:28:40,700
So that's all I'm saying.

00:28:40,700 --> 00:28:42,740
You have these tombstone properties,

00:28:42,740 --> 00:28:45,820
so then if you actually try to access the pet age here,

00:28:45,820 --> 00:28:48,180
it'll throw an error immediately, and that's just a defensive thing.

00:28:48,190 --> 00:28:50,170
This is because of old habits dying hard.

00:28:50,170 --> 00:28:52,150
This will protect against it.

00:28:52,150 --> 00:28:54,170
Okay, so, things to remember.

00:28:54,170 --> 00:28:56,750
Use property setter if you're trying to move assignable fields.

00:28:56,750 --> 00:28:59,340
Use tombstone properties if you're trying to --

00:28:59,340 --> 00:29:01,409
if you want to prevent yourself from hurting yourself

00:29:01,409 --> 00:29:03,470
with those refactorings.

00:29:03,470 --> 00:29:06,330
That's the main stuff.

00:29:06,330 --> 00:29:09,140
For follow-up there's three good sources of information

00:29:09,140 --> 00:29:10,980
you should check out.

00:29:10,980 --> 00:29:12,780
One is Doug Hellmann has his Python module of the week.

00:29:12,780 --> 00:29:14,520
It's been ported to Python 3 now.

00:29:14,520 --> 00:29:16,360
It's great, there's tons of things in there.

00:29:16,360 --> 00:29:18,140
One is on warnings so if you want to understand

00:29:18,140 --> 00:29:19,980
all the different ways you can use warnings,

00:29:19,980 --> 00:29:21,720
check that out.

00:29:21,720 --> 00:29:23,580
There's a great talk by Jack Diederich,

00:29:23,580 --> 00:29:25,340
about stop using classes, which is kind of the opposite

00:29:25,340 --> 00:29:27,320
of this talk -- I'm telling you to use classes,

00:29:27,330 --> 00:29:29,190
he's telling you not to.

00:29:29,190 --> 00:29:30,980
I think somewhere between the two is really good,

00:29:30,980 --> 00:29:34,340
and that's a really good Python style and refactoring talk.

00:29:34,340 --> 00:29:37,909
Then Raymond Hettinger last year had this Beyond PEP 8 talk,

00:29:37,909 --> 00:29:40,629
which is all about the structure of code and the relationships

00:29:40,629 --> 00:29:43,769
that classes should have; that's worth checking out.

00:29:44,620 --> 00:29:46,500
If you want this talk's code and slides,

00:29:46,509 --> 00:29:48,929
it's on my GitHub on Python 2016.

00:29:50,000 --> 00:29:51,820
Again, I had this book that I wrote

00:29:51,820 --> 00:29:53,620
on EffectivePython.com.

00:29:53,620 --> 00:29:55,420
There's also a deal of the day during PyCon

00:29:55,420 --> 00:29:57,440
that you can actually get an eBook version of this

00:29:57,442 --> 00:30:00,062
at a discount, which is right there.

00:30:00,062 --> 00:30:02,240
If you'd like to talk to me more,

00:30:02,250 --> 00:30:04,010
this is where you can find me online.

00:30:04,010 --> 00:30:05,850
I'm totally out of time, so if you have any questions,

00:30:05,850 --> 00:30:08,590
I'm just going to standing -- I'll be here and then I'll be right outside.

00:30:08,590 --> 00:30:11,039
and I'm wearing red, so come and talk to me.

00:30:11,039 --> 00:30:13,099
And that's it!

00:30:13,099 --> 00:30:19,000

YouTube URL: https://www.youtube.com/watch?v=D_6ybDcU5gc


