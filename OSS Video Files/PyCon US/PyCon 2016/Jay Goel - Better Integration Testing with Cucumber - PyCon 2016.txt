Title: Jay Goel - Better Integration Testing with Cucumber - PyCon 2016
Publication date: 2016-05-31
Playlist: PyCon 2016
Description: 
	Speaker: Jay Goel

One of the hardest questions to answer is ""does my program help the user accomplish their goals?"" Whether that person is using our website or a programmer using our library, this talk will describe how to write automated tests which map to tasks our users are trying to accomplish. We will demonstrate specific Python testing libraries and evaluate the pros and cons of this approach to testing.

Slides can be found at: https://speakerdeck.com/pycon2016 and https://github.com/PyCon/2016-slides
Captions: 
	00:00:31,700 --> 00:00:33,440
(host) Hello everyone.

00:00:33,440 --> 00:00:35,380
Please welcome Jay Goel

00:00:35,380 --> 00:00:39,420
with his talk, Better Integration Testing with Cucumber.

00:00:39,420 --> 00:00:45,720
[applause]

00:00:47,040 --> 00:00:49,120
(Jay Goel) All right. Good evening.

00:00:49,120 --> 00:00:51,900
Thank you all for being here at the very last talk

00:00:51,910 --> 00:00:54,550
after an exhausting day here at PyCon.

00:00:54,550 --> 00:00:58,310
My name is Jay and I'm traveling here from Brooklyn, New York,

00:00:58,310 --> 00:01:00,920
and I work at a fashion company,

00:01:00,920 --> 00:01:04,320
which explains the suit and tie and everything, really have to represent.

00:01:04,320 --> 00:01:06,980
I work at a fashion company which does dress rentals.

00:01:06,980 --> 00:01:11,600
That is, we -- you know, if you have a really important event

00:01:11,600 --> 00:01:14,840
like a bridesmaids or an anniversary party

00:01:14,840 --> 00:01:19,740
then you can rent that $600 Herve Leger gown for $60.

00:01:20,260 --> 00:01:23,820
I promise this is not a talk about...

00:01:36,940 --> 00:01:40,480
OK. This is not a talk about fashion, I promise.

00:01:40,480 --> 00:01:43,640
But the nature of the work that I do

00:01:43,640 --> 00:01:46,340
lends itself to my motivation for this talk,

00:01:46,340 --> 00:01:48,840
Better Integration Testing with Cucumber.

00:01:48,840 --> 00:01:50,640
Because people are renting

00:01:50,640 --> 00:01:53,540
for these very high-stakes events, things that are very important,

00:01:53,549 --> 00:01:57,640
things that are really emotionally important to our customers,

00:01:57,640 --> 00:02:00,640
I was really trying to solve the problem of...

00:02:00,640 --> 00:02:03,360
Well, so, often we release new features

00:02:03,360 --> 00:02:05,950
and write new code and we release it

00:02:05,950 --> 00:02:09,620
and our users don't really understand how to use that feature.

00:02:09,620 --> 00:02:12,540
They don't really get the value that they want to,

00:02:12,540 --> 00:02:14,580
or at least that we thought that they would.

00:02:14,580 --> 00:02:17,380
And we would release things which occasionally did not

00:02:17,390 --> 00:02:21,980
relieve anxiety for our customers the way we wanted it to.

00:02:21,980 --> 00:02:23,800
And so I started thinking, OK, well,

00:02:23,800 --> 00:02:25,680
what can we do as part of our QA process

00:02:25,690 --> 00:02:28,680
and as part of our sort of release process

00:02:28,680 --> 00:02:30,740
to try and make that better,

00:02:30,740 --> 00:02:34,060
to close that gap between

00:02:34,060 --> 00:02:38,000
what our users are trying to accomplish in their lives

00:02:38,000 --> 00:02:41,820
and the software that we're writing which is supposed to support that?

00:02:42,300 --> 00:02:45,600
So, one of the tools in my toolbox

00:02:45,600 --> 00:02:49,400
is behavioral-driven development, or BDD.

00:02:49,400 --> 00:02:53,820
And so the topic of this talk is to describe what BDD is,

00:02:53,820 --> 00:02:56,130
some of the idioms associated with it,

00:02:56,130 --> 00:02:58,600
and how to use the libraries

00:02:58,600 --> 00:03:02,000
and how to think in this kind of way

00:03:02,000 --> 00:03:04,700
when we're designing software.

00:03:05,180 --> 00:03:08,980
I'm hoping that we will get three major takeaways

00:03:08,980 --> 00:03:12,120
out of -- you know, by the end of this talk.

00:03:12,120 --> 00:03:14,370
The first is, you know, I'm hoping that we will be able

00:03:14,370 --> 00:03:18,120
to increase the quality of our integration tests.

00:03:18,120 --> 00:03:23,640
I find that when I write software, the things that tend to break the most

00:03:23,640 --> 00:03:27,400
is not the code that I write, because the code that I write is perfect,

00:03:27,400 --> 00:03:32,100
but rather the way that my code interacts with other systems,

00:03:32,100 --> 00:03:34,340
either above or below the stack,

00:03:34,340 --> 00:03:37,360
or when I'm taking input from users or things like that.

00:03:37,370 --> 00:03:39,680
So I personally find integration tests

00:03:39,680 --> 00:03:43,160
to be among the most valuable in my test suite.

00:03:43,160 --> 00:03:47,620
And I find that Cucumber and the technologies we'll talk about today

00:03:47,629 --> 00:03:49,749
help me achieve that.

00:03:49,749 --> 00:03:54,260
And of course as we would expect with any good testing framework,

00:03:54,270 --> 00:03:56,230
my goal is always to reduce regressions

00:03:56,230 --> 00:03:58,080
so that I have confidence

00:03:58,080 --> 00:04:01,200
that the code for the new feature that I have released today

00:04:01,200 --> 00:04:04,520
will not break something that was working just yesterday.

00:04:05,260 --> 00:04:08,700
And the biggest takeaway that I hope to communicate

00:04:08,710 --> 00:04:12,849
by the end of this presentation is a shift in thinking

00:04:12,849 --> 00:04:15,989
from not just what is my code supposed to do

00:04:15,989 --> 00:04:18,029
or how does my software behave,

00:04:18,029 --> 00:04:21,809
but rather, what are my users trying to do,

00:04:21,809 --> 00:04:24,780
and how can I make sure that the software that I'm writing

00:04:24,780 --> 00:04:29,340
is actually helping my users accomplish what they want to accomplish?

00:04:29,340 --> 00:04:31,140
So let's get into it.

00:04:31,140 --> 00:04:34,700
When I think about testing, I sort of break down tests

00:04:34,710 --> 00:04:37,370
into three sort of parts of my test.

00:04:37,370 --> 00:04:40,260
There's the set that's got to happen before my test runs,

00:04:40,260 --> 00:04:42,860
the thing that I'm testing, and then making sure

00:04:42,860 --> 00:04:45,840
that whatever I just tested actually works.

00:04:45,840 --> 00:04:48,300
So here's an example that I lifted

00:04:48,300 --> 00:04:52,460
basically straight out of the Python documentation,

00:04:52,460 --> 00:04:56,940
and this is a basic unit test for string.split.

00:04:56,940 --> 00:04:58,940
And we do our setup,

00:04:58,940 --> 00:05:02,180
so we create the string that we want to test splitting,

00:05:02,190 --> 00:05:04,610
in this case "hello world."

00:05:04,610 --> 00:05:08,610
We then perform the split and store those token somewhere.

00:05:08,610 --> 00:05:11,480
And then we have an assertion to make sure that

00:05:11,490 --> 00:05:13,620
the return value of string.split

00:05:13,620 --> 00:05:16,840
actually gives us the results that we were expecting.

00:05:17,260 --> 00:05:21,220
And if I were to then create a Rosetta Stone

00:05:21,220 --> 00:05:25,820
of these steps of testing to how we --

00:05:25,820 --> 00:05:28,720
how we would typically implement them in a unit test,

00:05:28,720 --> 00:05:33,380
my preconditions are associated with my setup.

00:05:33,380 --> 00:05:38,160
Then I have my test methods, followed by some assertions.

00:05:38,160 --> 00:05:40,300
Nothing too controversial here.

00:05:41,980 --> 00:05:45,660
When we think about BDD,

00:05:45,660 --> 00:05:48,600
we are thinking about forming our tests

00:05:48,600 --> 00:05:53,020
not in the context of how the code is supposed to behave,

00:05:53,020 --> 00:05:56,340
but what users of our code are trying to accomplish.

00:05:56,340 --> 00:05:59,540
And to do this, we have a domain-specific language.

00:05:59,540 --> 00:06:02,300
Going back to our little Rosetta Stone,

00:06:02,300 --> 00:06:07,600
we express preconditions using clauses that begin with the words "given."

00:06:07,600 --> 00:06:11,100
So, given I have a string, "hello world,"

00:06:11,100 --> 00:06:15,100
or given I'm a user who is logged into my website.

00:06:15,980 --> 00:06:20,240
The thing that I'm testing is expressed using "when" clauses.

00:06:20,240 --> 00:06:22,720
So, when I split my string,

00:06:22,720 --> 00:06:28,520
or when I try to view my account information.

00:06:29,040 --> 00:06:34,940
And my verification is denoted by "then" statements.

00:06:34,940 --> 00:06:39,420
So, then I expect there to be two tokens, "hello" and "world,"

00:06:39,420 --> 00:06:43,780
or then I expect to see my, you know, account number

00:06:43,780 --> 00:06:45,820
or my order history.

00:06:46,780 --> 00:06:51,100
And so if I were to translate our existing test

00:06:51,100 --> 00:06:54,200
into this Cucumber domain-specific language

00:06:54,200 --> 00:06:56,660
which looks kind of like English -- it's not really English;

00:06:56,660 --> 00:07:00,560
it looks kind of like English -- then this is what it would look like.

00:07:01,400 --> 00:07:04,620
And I had these neat features here where, for example,

00:07:04,630 --> 00:07:08,930
because I'm expecting two tokens I can specify

00:07:08,930 --> 00:07:12,910
a list of things that I am expecting in an output.

00:07:15,780 --> 00:07:19,280
So far I've shown this English-looking thing,

00:07:19,280 --> 00:07:21,919
this domain-specific language which describes

00:07:21,919 --> 00:07:24,419
what the test is supposed to do,

00:07:24,420 --> 00:07:27,060
but it's not actually testing anything yet, right?

00:07:27,060 --> 00:07:30,009
Like, there's no actual code which is doing my string comparisons

00:07:30,009 --> 00:07:33,309
to make sure that that my code is behaving properly.

00:07:33,309 --> 00:07:35,140
We will get to that in a second.

00:07:35,140 --> 00:07:37,380
But I don't see that as the hardest part

00:07:37,380 --> 00:07:39,759
of this kind of shift in how we think about

00:07:39,759 --> 00:07:43,479
or describe what our software is supposed to do.

00:07:43,480 --> 00:07:47,140
So, even before that,

00:07:47,140 --> 00:07:50,320
some of the advantages that we have here, we have better descriptions

00:07:50,330 --> 00:07:54,320
of our test cases than maybe we did previously.

00:07:54,320 --> 00:07:57,000
In fact, this is something that we already do

00:07:57,009 --> 00:08:02,050
which is -- and I pulled these two examples from Flask and the Requests library

00:08:02,050 --> 00:08:05,150
where when we have a very complicated test that has a lot of steps,

00:08:05,150 --> 00:08:09,690
we try to be descriptive by having these really, really long method names

00:08:09,690 --> 00:08:14,310
that try to describe every little thing about the test's behavior.

00:08:14,310 --> 00:08:17,620
And by using this Cucumber language, at least we're being

00:08:17,620 --> 00:08:21,800
a little bit more explicit about what is happening in the tests.

00:08:21,800 --> 00:08:27,020
The other cool thing here is that when a test breaks,

00:08:27,020 --> 00:08:29,440
when something fails, we often ask ourselves,

00:08:29,449 --> 00:08:33,249
well, is it the test that's broken or is it my code that's broken?

00:08:33,249 --> 00:08:35,900
We've all been in that situation where we see a test that's failing

00:08:35,910 --> 00:08:39,430
and we go in and we fix the test, and then come to realize that,

00:08:39,430 --> 00:08:42,560
oh, fixing the test was actually the wrong thing to do,

00:08:42,560 --> 00:08:44,500
but it was easier at the time,

00:08:44,510 --> 00:08:46,770
and we end up, you know, actually having regressions.

00:08:46,770 --> 00:08:50,510
So when we see a failing test in this context,

00:08:50,510 --> 00:08:54,110
we know what our users were expecting before,

00:08:54,110 --> 00:08:56,390
what we were expecting to happen afterwards,

00:08:56,390 --> 00:08:58,760
and now as programmers we have context

00:08:58,770 --> 00:09:01,130
for how the software was supposed to behave

00:09:01,130 --> 00:09:04,330
so that we know where to look in the process of debugging.

00:09:05,160 --> 00:09:08,440
The other cool thing about this in more of like a business context

00:09:08,450 --> 00:09:10,950
or if you work with a lot of non-technical users

00:09:10,950 --> 00:09:15,130
is this kind of language forces our non-technical users,

00:09:15,130 --> 00:09:16,940
say our product managers,

00:09:16,940 --> 00:09:20,990
to create specifications for software

00:09:20,990 --> 00:09:23,750
and describe them using similar language

00:09:23,750 --> 00:09:28,730
that we will use when we eventually write automated tests for that software.

00:09:28,730 --> 00:09:33,890
So I find that this approach helps add rigor to specifications

00:09:33,890 --> 00:09:36,340
and makes them easier to test later down the line.

00:09:36,340 --> 00:09:39,100
So if we look at this

00:09:39,100 --> 00:09:42,260
using examples from different domains,

00:09:42,260 --> 00:09:46,340
if you're at Rent the Runway and we have our e-commerce website,

00:09:46,340 --> 00:09:50,880
and then maybe if you're a customer, you expect to go see a list of products

00:09:50,890 --> 00:09:54,670
and see pictures of dresses on our website.

00:09:55,300 --> 00:09:59,360
If you are implementing an authentication system,

00:09:59,360 --> 00:10:01,600
then this is, you know,

00:10:01,610 --> 00:10:06,860
how I would describe how a user would perform authentication.

00:10:06,860 --> 00:10:10,640
So in this case, I'm not talking about tokens.

00:10:10,640 --> 00:10:12,500
I'm not talking about encryption.

00:10:12,510 --> 00:10:15,690
I'm not talking about handshakes or any of that other stuff.

00:10:15,690 --> 00:10:18,240
All I'm talking about is, if I'm a user

00:10:18,250 --> 00:10:22,330
and I'm trying to log in somewhere, how do I expect the system to behave?

00:10:22,960 --> 00:10:26,740
Finally, let's say I am implementing a library,

00:10:26,740 --> 00:10:29,360
let's say the very excellent Requests library.

00:10:29,360 --> 00:10:34,600
Requests has this great feature where I can fetch a URL,

00:10:34,600 --> 00:10:36,680
which returns JSON

00:10:36,680 --> 00:10:40,620
and it will automatically serialize that JSON into a Python dictionary.

00:10:40,620 --> 00:10:44,640
So if I were implementing a library for another programmer to use,

00:10:44,640 --> 00:10:49,400
this is how I might describe the functionality

00:10:49,410 --> 00:10:52,310
in terms of how someone using my library

00:10:52,310 --> 00:10:54,410
would accomplish their goals,

00:10:54,410 --> 00:10:57,840
and Requests is a very easy example

00:10:57,840 --> 00:11:02,540
because the tagline of Requests is just "HTTP for humans."

00:11:03,540 --> 00:11:07,760
So with these different examples, the point that I want to drive home

00:11:07,760 --> 00:11:10,640
is that now we have a framework for asking ourselves

00:11:10,640 --> 00:11:14,960
and describing, well, what are our users actually trying to do?

00:11:16,160 --> 00:11:19,280
So now let's look at some code.

00:11:19,280 --> 00:11:22,480
I have found that there are a lot of libraries

00:11:22,490 --> 00:11:25,470
that implement this kind of Cucumber stuff.

00:11:25,470 --> 00:11:30,680
Two of them that seemed actively maintained and very popular

00:11:30,680 --> 00:11:33,180
as defined by lots of stars on Github

00:11:33,180 --> 00:11:37,500
are Behave, I guess a play on behavioral-driven development,

00:11:37,500 --> 00:11:40,840
and Lettuce, because I guess lettuce and cucumbers

00:11:40,840 --> 00:11:43,620
are both salad-related things.

00:11:43,620 --> 00:11:46,060
For the examples here, I'm going to use the Behave library.

00:11:46,060 --> 00:11:47,960
I flipped a coin.

00:11:48,880 --> 00:11:51,760
And these two libraries have very similar syntax.

00:11:51,760 --> 00:11:56,320
So, whichever one you use, it's not so different using one versus the other.

00:11:56,840 --> 00:11:58,700
So what I've done here is

00:11:58,700 --> 00:12:03,760
I've taken my string-splitting code

00:12:03,769 --> 00:12:07,920
and I've turned it into this file called strings.feature.

00:12:07,920 --> 00:12:11,180
.feature is a file extension.

00:12:11,180 --> 00:12:14,680
It has - you know, it is recognized by Github for syntax highlighting

00:12:14,680 --> 00:12:19,240
and the VI text editor, and I have --

00:12:19,250 --> 00:12:21,870
I've just written out in this file.

00:12:21,870 --> 00:12:23,720
And all of this stuff at the beginning,

00:12:23,720 --> 00:12:26,960
in order to play with Behave as beginners, we'll implement tests.

00:12:26,960 --> 00:12:29,809
This is not stuff that is actually executed,

00:12:29,809 --> 00:12:34,160
but it helps describe the context and what the test is supposed to do.

00:12:34,160 --> 00:12:36,900
And if I then run the Behave command

00:12:36,900 --> 00:12:40,660
with strings.feature as input,

00:12:40,660 --> 00:12:44,890
then this is my output. I see that I have a failed test.

00:12:44,890 --> 00:12:49,140
And Behave tries to execute the first line,

00:12:49,140 --> 00:12:52,620
"Given I have a string 'hello world.'"

00:12:52,620 --> 00:12:54,620
And it says, well, I don't know what this means.

00:12:54,620 --> 00:12:57,800
I don't have any code which is actually doing anything

00:12:57,800 --> 00:13:00,900
for my test about the string "hello world."

00:13:00,900 --> 00:13:03,239
It fails the test and it stops execution.

00:13:03,240 --> 00:13:05,899
It doesn't execute the rest of the steps.

00:13:05,899 --> 00:13:07,640
It doesn't even try.

00:13:07,640 --> 00:13:09,850
And it also does this cool thing where it will give you

00:13:09,850 --> 00:13:12,540
the actual code that you can copy and paste

00:13:12,540 --> 00:13:16,260
to fill in and actually implement those tests.

00:13:16,260 --> 00:13:20,320
So now that we have a failing test, let's try to make those tests pass.

00:13:20,880 --> 00:13:25,360
I am now implementing code

00:13:25,360 --> 00:13:30,140
to be associated with each of the steps of my test.

00:13:30,140 --> 00:13:34,520
So, given I have a string "hello world,"

00:13:34,529 --> 00:13:39,469
I am just assigning that string to this global variable called context.

00:13:39,469 --> 00:13:43,169
Context is a variable

00:13:43,170 --> 00:13:45,170
that exists for the duration of the test,

00:13:45,170 --> 00:13:47,970
so I can have information that I'm storing

00:13:47,970 --> 00:13:51,190
among multiple steps of my test, which I can then reference.

00:13:51,190 --> 00:13:54,060
And then when I try to split that string, here I'm actually doing

00:13:54,070 --> 00:13:57,130
the thing that I want to test: I'm splitting the string.

00:13:59,920 --> 00:14:02,480
Here I have implemented steps for expecting

00:14:02,490 --> 00:14:05,790
a certain number of tokens, in my case two tokens.

00:14:05,790 --> 00:14:08,010
And for each token, I want to make sure

00:14:08,010 --> 00:14:11,450
that I have "hello" and "world" in that order.

00:14:15,040 --> 00:14:19,960
When I run Behave again with this input, my tests pass.

00:14:19,960 --> 00:14:21,720
Everything is green.

00:14:22,500 --> 00:14:24,940
If my test fails,

00:14:24,940 --> 00:14:27,779
let's say I had an incorrect requirement

00:14:27,779 --> 00:14:32,239
where I'm expecting one token rather than two tokens,

00:14:32,240 --> 00:14:35,100
then...

00:14:36,040 --> 00:14:38,720
...the test would fail at that step,

00:14:38,720 --> 00:14:40,640
it would provide a traceback,

00:14:40,640 --> 00:14:44,080
and then I could look and see, hmm, well, what's the problem?

00:14:44,090 --> 00:14:46,470
It turns out in this case the problem is that I'm expecting

00:14:46,470 --> 00:14:49,000
the wrong number of tokens and my test is incorrect.

00:14:49,000 --> 00:14:52,440
But at least when I read this I know what the context is

00:14:52,449 --> 00:14:55,769
and what the right thing to modify would be.

00:14:56,960 --> 00:15:02,780
The analogy that I want to draw here is to routing in HTTP.

00:15:05,940 --> 00:15:09,880
If I had a route which displayed information

00:15:09,880 --> 00:15:12,660
about my user profile,

00:15:12,660 --> 00:15:14,840
I would define my route

00:15:14,850 --> 00:15:17,930
and I would associate that route with a method

00:15:17,930 --> 00:15:22,070
which is responsible for actually showing my user information.

00:15:22,070 --> 00:15:26,790
And the cool thing about this is now I get a clean, human-readable

00:15:26,790 --> 00:15:30,730
restful route for showing my user's information.

00:15:31,140 --> 00:15:35,900
And by analogy I have my human-readable requirement

00:15:35,910 --> 00:15:39,210
that is when I view my account information.

00:15:40,140 --> 00:15:43,500
And I am easily able to associate that

00:15:43,500 --> 00:15:47,320
with a piece of code which actually does the test.

00:15:51,580 --> 00:15:55,000
One of the biggest pitfalls that people make,

00:15:55,000 --> 00:15:58,279
that I see people make when they're starting out is

00:15:58,279 --> 00:16:01,479
they write tests which are really, really granular.

00:16:01,480 --> 00:16:04,220
That is, they list so many steps

00:16:04,220 --> 00:16:07,860
that each step basically corresponds to a piece of code

00:16:07,860 --> 00:16:12,120
which would be used on the back end to implement said test.

00:16:12,880 --> 00:16:16,260
And at this point, we've really missed the forest for the trees

00:16:16,269 --> 00:16:18,649
or missed trees for the forest or something like that.

00:16:18,649 --> 00:16:22,960
We have -- are not focusing on what our users are trying to accomplish.

00:16:22,960 --> 00:16:26,840
Instead, we have focused on how the code is supposed to behave

00:16:26,850 --> 00:16:28,760
at a very granular level.

00:16:28,760 --> 00:16:33,720
If I were to revise this, this is what it would look like instead,

00:16:33,720 --> 00:16:37,360
where all of the intermediary steps

00:16:37,360 --> 00:16:40,760
required to do an automated test here

00:16:40,760 --> 00:16:45,600
are abstracted away by these higher-level behaviors of our user.

00:16:46,600 --> 00:16:51,480
I think one of the biggest pieces of hype around this kind of stuff,

00:16:51,480 --> 00:16:54,520
this is the stuff that, like, Agile Consultants will come in and say,

00:16:54,529 --> 00:16:58,649
they'll say that, oh, all of your non-technical people can write tests.

00:16:58,649 --> 00:17:00,920
Your product managers can write these tests

00:17:00,920 --> 00:17:02,790
and write these specifications like Legos

00:17:02,790 --> 00:17:04,660
and it will all be polka dots and moonbeams.

00:17:04,660 --> 00:17:06,780
Do I think this is true?

00:17:06,780 --> 00:17:08,500
I say not really.

00:17:09,460 --> 00:17:12,600
We know, we all know that when we're writing tests,

00:17:12,600 --> 00:17:15,400
we try to write these reusable components.

00:17:15,400 --> 00:17:18,800
But obviously as our tests change and as the behavior changes,

00:17:18,810 --> 00:17:22,420
we need developers to go in and make changes to tests.

00:17:22,420 --> 00:17:24,360
But the advantage that we do get is that

00:17:24,360 --> 00:17:27,260
now we're at least using a similar language

00:17:27,260 --> 00:17:31,460
as our non-technical stakeholders

00:17:31,460 --> 00:17:33,260
or as our non-technical users

00:17:33,260 --> 00:17:37,620
to think about and describe how a system is supposed to behave.

00:17:37,620 --> 00:17:41,900
And I believe that we get advantages and better outcomes

00:17:41,900 --> 00:17:44,940
of closing that gap between what we actually want

00:17:44,940 --> 00:17:48,760
and the software that gets written by using similar language.

00:17:49,320 --> 00:17:52,240
I want to use a real example from Rent the Runway --

00:17:52,240 --> 00:17:55,480
this is highly proprietary code, so please, nobody tell anyone

00:17:55,490 --> 00:17:57,370
outside this room what I'm about to show you --

00:17:57,370 --> 00:18:00,370
of some actual scenarios that we have.

00:18:00,370 --> 00:18:02,340
These are things that have to run

00:18:02,340 --> 00:18:07,760
and they have to pass before you release any code to our website.

00:18:07,760 --> 00:18:11,660
And so we run these many, many times every day.

00:18:11,660 --> 00:18:14,720
This is actually -- and I copied it and pasted it from Github this morning --

00:18:14,730 --> 00:18:19,710
this is what the account creation scenario looks like

00:18:19,710 --> 00:18:21,950
in our integration tests.

00:18:22,500 --> 00:18:26,320
And the code on the back end -- now this is written in Ruby

00:18:26,330 --> 00:18:29,470
because our storefront code is written in Ruby --

00:18:29,470 --> 00:18:34,530
is what does the nitty-gritty work of,

00:18:34,530 --> 00:18:38,080
you know, filling in, we're using copy and borrow to fill in those login forms

00:18:38,080 --> 00:18:40,400
and actually affect that test.

00:18:40,920 --> 00:18:43,040
And we even have a Jenkins plugin

00:18:43,040 --> 00:18:46,580
which will aggregate all of those tests

00:18:46,580 --> 00:18:49,980
and tell us exactly what is passing and what is failing.

00:18:52,600 --> 00:18:57,700
So, you know, in terms of key takeaways,

00:18:57,710 --> 00:18:59,690
I think the biggest takeaway is that, well,

00:18:59,690 --> 00:19:02,080
we should focus on what users are trying to do,

00:19:02,080 --> 00:19:04,650
not what we want our code to do.

00:19:04,650 --> 00:19:08,440
I wanted to introduce this given/when/then idiom

00:19:08,440 --> 00:19:12,080
for describing the behavior of our software.

00:19:12,080 --> 00:19:15,200
We can construct these things in a way that are reusable.

00:19:15,200 --> 00:19:20,000
For example, the login functionality or creating a new account functionality

00:19:20,000 --> 00:19:24,100
is something that we can use across all of our tests.

00:19:24,100 --> 00:19:29,000
And it is helpful to think about actually implementing these things

00:19:29,000 --> 00:19:31,400
the same way we think about routing

00:19:31,400 --> 00:19:34,080
and how we have a separation of concerns there.

00:19:34,080 --> 00:19:36,500
And I find it tremendously helpful

00:19:36,510 --> 00:19:39,260
to be able to write my acceptance criteria

00:19:39,260 --> 00:19:42,100
and my tests and my specifications

00:19:42,100 --> 00:19:45,559
in a way which is more accessible to people who are non-technical.

00:19:45,559 --> 00:19:47,899
I find that that leads to better outcomes.

00:19:49,340 --> 00:19:51,760
So that is all I have.

00:19:51,760 --> 00:19:53,520
If you have questions

00:19:53,520 --> 00:19:57,020
or particularly hairy or difficult scenarios

00:19:57,020 --> 00:19:59,789
that you want to try to stump me on,

00:19:59,789 --> 00:20:02,920
to convert those into, you know, Cucumber scenarios,

00:20:02,920 --> 00:20:05,220
then I'm happy to take your questions.

00:20:05,220 --> 00:20:08,560
Otherwise I very much appreciate everyone coming out.

00:20:08,560 --> 00:20:11,400
(host) So yeah, we have a few minutes for questions.

00:20:11,400 --> 00:20:13,520
Please come to the microphone.

00:20:14,480 --> 00:20:21,480
[applause]

00:20:21,800 --> 00:20:23,800
(audience member) Well, thank you very much

00:20:23,800 --> 00:20:26,260
for the talk there, Jay. It's really good.

00:20:26,260 --> 00:20:30,060
I was just kind of interested to see that you're using Cucumber

00:20:30,060 --> 00:20:35,300
rather than going for something like Behave, which you showed there.

00:20:35,300 --> 00:20:39,500
What was the reason for using Cucumber rather than Behave?

00:20:40,340 --> 00:20:42,000
(Jay Goel) So, I didn't quite hear your question

00:20:42,000 --> 00:20:43,520
but tell me if I was correct.

00:20:43,520 --> 00:20:46,300
(audience member) So I was just saying, why did you use

00:20:46,300 --> 00:20:49,720
Cucumber rather than Behave as your test tool?

00:20:49,720 --> 00:20:54,530
I was just -- because obviously, Cucumber is written in Ruby,

00:20:54,530 --> 00:20:59,790
and I was wondering whether you preferred using Ruby for that,

00:20:59,790 --> 00:21:02,080
or what was the reason for not using Behave,

00:21:02,080 --> 00:21:04,860
because I'm looking at using Behave at the moment, and I'm...

00:21:04,860 --> 00:21:06,900
(Jay Goel) Sure, so the question is,

00:21:06,900 --> 00:21:10,020
so on the one hand Cucumber is already there as one library.

00:21:10,020 --> 00:21:12,620
And here I chose to use Behave as the library.

00:21:12,620 --> 00:21:14,540
What was the motivation for that?

00:21:14,540 --> 00:21:18,620
So I believe, if I'm not mistaken,

00:21:18,620 --> 00:21:23,660
the official Cucumber people who make that Cucumber package

00:21:23,660 --> 00:21:27,560
do not support Python as one of their languages;

00:21:27,570 --> 00:21:30,950
They support Ruby. I think they support a couple of different languages.

00:21:30,950 --> 00:21:35,020
So Behave is just one of the,

00:21:35,020 --> 00:21:37,280
I guess, unofficial Python implementations.

00:21:37,290 --> 00:21:39,270
(audience member) Yeah, it's a port, it's a port.

00:21:39,270 --> 00:21:40,750
(Jay Goel) Yes, yeah.

00:21:40,750 --> 00:21:43,170
(audience member) Oh, OK. So, yeah. OK.

00:21:53,320 --> 00:21:55,200
(audience member) Hi, thanks for your talk.

00:21:55,210 --> 00:22:00,620
Could you talk about -- so sometimes people implement this BDD

00:22:00,620 --> 00:22:04,690
and it ends up being, hey, we'll have our business analysts write all these tests,

00:22:04,690 --> 00:22:10,190
and it just ends up being the coders having to rewrite all these cases.

00:22:10,190 --> 00:22:15,510
And I'm wondering if you see that too,

00:22:15,510 --> 00:22:17,490
and if...

00:22:20,180 --> 00:22:24,140
...how this is better or how this sort of holds the hand

00:22:24,150 --> 00:22:27,940
with unit testing as a practice?

00:22:27,940 --> 00:22:29,740
(Jay Goel) And so I'll try to restate

00:22:29,740 --> 00:22:34,340
your first question, which is, you know, it feels like a little bit of a slog

00:22:34,350 --> 00:22:37,710
to have to implement all of these Cucumber tests

00:22:37,710 --> 00:22:42,210
for all of our features, especially if we're already using unit tests.

00:22:42,210 --> 00:22:45,880
So how do we reconcile that, and like, what is our strategy

00:22:45,880 --> 00:22:49,530
for implementing this without spending all of our time

00:22:49,530 --> 00:22:52,080
just writing tests? Is that --

00:22:52,080 --> 00:22:53,540
(audience member) Yes.

00:22:53,540 --> 00:22:57,920
(Jay Goel) So, my perspective on this is,

00:22:57,920 --> 00:23:00,240
you know, so often the case is

00:23:00,240 --> 00:23:03,180
this is something that's going to happen later in the process.

00:23:03,180 --> 00:23:06,380
You know, if everyone wrote their tests at the beginning of a project,

00:23:06,380 --> 00:23:08,840
then, you know, everything would be polka dots and moonbeams.

00:23:08,840 --> 00:23:11,760
So my approach to this is, you know,

00:23:11,760 --> 00:23:14,920
you can make a list of all of the different acceptance tests

00:23:14,920 --> 00:23:18,200
that you want to write, and then do some sort of division

00:23:18,200 --> 00:23:21,500
and do a certain number week-over-week.

00:23:21,540 --> 00:23:24,760
That feels very painful, so my approach is,

00:23:24,760 --> 00:23:27,520
let's focus on the happy paths first.

00:23:27,530 --> 00:23:30,930
So let's take some major uses of our software,

00:23:30,930 --> 00:23:33,040
let's not try to get all the edge cases,

00:23:33,040 --> 00:23:35,000
and prioritize doing those first.

00:23:35,000 --> 00:23:39,860
So basic login, you know, basic use cases.

00:23:39,860 --> 00:23:43,460
The second thing, then, is,

00:23:43,470 --> 00:23:49,490
as we create bugs -- which I never do -- but...

00:23:52,000 --> 00:23:56,280
We write failing tests for those bugs.

00:23:56,280 --> 00:23:58,920
So rather than trying to capture all of the edge cases

00:23:58,929 --> 00:24:01,260
and everything all at once, focus on flows

00:24:01,260 --> 00:24:04,880
which are really, really important, the critical paths to begin with.

00:24:04,880 --> 00:24:09,200
And then for subsequent changes and new features and bug fixes,

00:24:09,200 --> 00:24:13,460
then do those tests as we go along to decrease the pain.

00:24:13,460 --> 00:24:15,220
Does that answer your question?

00:24:16,500 --> 00:24:20,120
(audience member) Yes, I think that that does

00:24:20,120 --> 00:24:23,620
provide better -- I think that does provide context.

00:24:23,620 --> 00:24:28,070
I just worry that these are just going to end up --

00:24:28,070 --> 00:24:30,309
that it isn't the users or the business analysts

00:24:30,309 --> 00:24:34,060
that end up writing all this Gherkin language,

00:24:34,060 --> 00:24:38,820
the given/then/when, that it ends up being the programmers anyway,

00:24:38,820 --> 00:24:41,140
and that that's just another level of frustration

00:24:41,140 --> 00:24:43,160
when they could just be writing the unit tests in something

00:24:43,160 --> 00:24:46,980
that's sort of native in terms of their thinking process.

00:24:46,980 --> 00:24:50,960
(Jay Goel) Yeah, my experience has been

00:24:50,960 --> 00:24:56,440
that the frustration comes less from actually writing these tests.

00:24:56,440 --> 00:24:58,359
Because we're writing the same code,

00:24:58,360 --> 00:25:00,400
and whether I'm writing the code in a unit test method

00:25:00,400 --> 00:25:03,580
versus a Cucumber method doesn't really make a big difference.

00:25:03,580 --> 00:25:06,680
The pain is in working with that product person

00:25:06,680 --> 00:25:09,640
to figure out exactly what that syntax should be.

00:25:09,640 --> 00:25:12,200
And I think the argument that I'm making

00:25:12,200 --> 00:25:16,360
is that that pain is actually quite useful

00:25:16,370 --> 00:25:21,630
in making sure that we close that gap between what product wants

00:25:21,630 --> 00:25:25,080
and what developers are going to build way earlier in the process

00:25:25,080 --> 00:25:28,340
rather than after having implemented something which doesn't --

00:25:28,340 --> 00:25:32,020
which, you know, may not quite match what we were expecting.

00:25:32,020 --> 00:25:33,460
(audience member) Thank you.

00:25:33,460 --> 00:25:34,960
(Jay Goel) Thank you.

00:25:34,960 --> 00:25:37,200
(host) I'm sorry to interrupt.

00:25:37,200 --> 00:25:39,780
The lightning talks will be starting in three minutes.

00:25:39,780 --> 00:25:42,880
Thank you, Jay, for your talk, and everyone who has questions,

00:25:42,880 --> 00:25:45,060
please address them personally.

00:25:45,070 --> 00:25:46,960
(Jay Goel) I'll be down so if you want to catch me

00:25:46,960 --> 00:25:49,440

YouTube URL: https://www.youtube.com/watch?v=ZEZBZFi_e88


