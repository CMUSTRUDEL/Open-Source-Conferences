Title: Allison Kaptur: Import-ant Decisions - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Allison Kaptur

Suppose `import` didn't exist, and we had to invent it from scratch. We'll look at the problem - code sharing and reuse across modules - and different ways we could solve it. We'll come up with `import` from parallel universes and then reinvent python's actual implementation. Finally, we'll import - using python's design - without using the `import` keyword.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:03,560 --> 00:00:08,189
all right let's welcome Allison captor

00:00:07,170 --> 00:00:18,090
and she's going to be presenting on

00:00:08,189 --> 00:00:21,240
important decisions is the audio okay

00:00:18,090 --> 00:00:23,130
here great I'm Allison captor I'm a

00:00:21,240 --> 00:00:24,539
facilitator at hacker school writers

00:00:23,130 --> 00:00:26,010
retreat for programmers in New York City

00:00:24,539 --> 00:00:27,840
so if you have questions about hacker

00:00:26,010 --> 00:00:29,039
school come find me at any point in the

00:00:27,840 --> 00:00:31,410
weekend I'd love to talk to you about

00:00:29,039 --> 00:00:34,380
that I'm so with the 30 or so hacker

00:00:31,410 --> 00:00:36,149
schoolers who are here here are some

00:00:34,380 --> 00:00:37,980
places you can find me this is my github

00:00:36,149 --> 00:00:39,360
and Twitter if you don't get a chance to

00:00:37,980 --> 00:00:41,520
get your questions answered at the end

00:00:39,360 --> 00:00:45,390
of this talk feel free to tweet at me

00:00:41,520 --> 00:00:46,950
and I'll try to get back to you there so

00:00:45,390 --> 00:00:50,430
I want us to picture ourselves in

00:00:46,950 --> 00:00:54,050
Amsterdam in 1989 inventing Python for

00:00:50,430 --> 00:00:56,489
the next half hour we are the BDF l's

00:00:54,050 --> 00:00:58,620
now unfortunately I don't think we have

00:00:56,489 --> 00:01:00,149
time to invent all of Python in the next

00:00:58,620 --> 00:01:03,000
half an hour so we're just going to net

00:01:00,149 --> 00:01:04,470
one piece and that's import now our

00:01:03,000 --> 00:01:06,689
hypothetical here is that everything

00:01:04,470 --> 00:01:08,280
else in Python already exists so we can

00:01:06,689 --> 00:01:10,979
write code that we need to implement

00:01:08,280 --> 00:01:13,080
import we're going to start with a very

00:01:10,979 --> 00:01:15,030
simple and very limited solution and

00:01:13,080 --> 00:01:17,880
then we'll gradually look at problems as

00:01:15,030 --> 00:01:19,200
they arise and try to solve them we'll

00:01:17,880 --> 00:01:21,900
also look at some other decisions that

00:01:19,200 --> 00:01:23,490
we could have made and see how other

00:01:21,900 --> 00:01:27,240
languages choose to solve these problems

00:01:23,490 --> 00:01:29,579
as a side note import existed in it's

00:01:27,240 --> 00:01:31,350
essentially its current form in the

00:01:29,579 --> 00:01:35,009
first open source release of Python and

00:01:31,350 --> 00:01:36,630
around 90 91 so there's not a record of

00:01:35,009 --> 00:01:38,729
the decision making around the structure

00:01:36,630 --> 00:01:42,540
this is the days before mailing list

00:01:38,729 --> 00:01:46,290
before peps before the changelog even so

00:01:42,540 --> 00:01:49,140
the main source for actual history of

00:01:46,290 --> 00:01:52,439
import is Guido's brain and I'll come

00:01:49,140 --> 00:01:54,439
back to that a little bit later on so

00:01:52,439 --> 00:01:56,909
let's stay in our problem really clearly

00:01:54,439 --> 00:01:59,130
this is one of sharing and reusing code

00:01:56,909 --> 00:02:00,329
so to get some code up on the boat on

00:01:59,130 --> 00:02:02,700
the board here that we can talk about

00:02:00,329 --> 00:02:04,829
concretely suppose on the left hand side

00:02:02,700 --> 00:02:06,149
that we had written some function it was

00:02:04,829 --> 00:02:09,119
very hard work and it's a very useful

00:02:06,149 --> 00:02:10,800
function and sometime later on the right

00:02:09,119 --> 00:02:13,800
hand side we need to use that function

00:02:10,800 --> 00:02:14,020
again so what are we going to do in the

00:02:13,800 --> 00:02:16,840
app

00:02:14,020 --> 00:02:18,730
sense of import well the first thing we

00:02:16,840 --> 00:02:20,110
could do is the decision that the novice

00:02:18,730 --> 00:02:22,660
programmer would make someone who's very

00:02:20,110 --> 00:02:25,990
new to programming they would say this

00:02:22,660 --> 00:02:27,790
is way easy I can copy and paste now

00:02:25,990 --> 00:02:29,590
they're clearly a lot of disadvantages

00:02:27,790 --> 00:02:31,630
with the strategy but it's worth noting

00:02:29,590 --> 00:02:33,490
that there are advantages to for one

00:02:31,630 --> 00:02:35,890
thing it's very clear what we've done so

00:02:33,490 --> 00:02:38,050
if we're reading this function this file

00:02:35,890 --> 00:02:39,490
later a useful function is defined right

00:02:38,050 --> 00:02:43,030
there we don't have to go hunting for it

00:02:39,490 --> 00:02:44,920
somewhere oh there are lots of

00:02:43,030 --> 00:02:46,870
disadvantages and two of them are that

00:02:44,920 --> 00:02:48,610
this is annoying to do by hand and if we

00:02:46,870 --> 00:02:50,110
subsequently find a bug in a useful

00:02:48,610 --> 00:02:52,930
function we have to go fix it in two

00:02:50,110 --> 00:02:54,700
places so at a minimum we want an

00:02:52,930 --> 00:02:56,440
automatic solution that doesn't require

00:02:54,700 --> 00:02:58,000
manual copying and pasting that's

00:02:56,440 --> 00:03:00,850
probably not the best solution that we

00:02:58,000 --> 00:03:05,500
can come up with and we want the code to

00:03:00,850 --> 00:03:07,240
stay in sync if we make changes so let's

00:03:05,500 --> 00:03:09,610
imagine some kind of magical copy and

00:03:07,240 --> 00:03:11,320
paste so we've got a special symbol that

00:03:09,610 --> 00:03:13,270
copies and paste your code for you and

00:03:11,320 --> 00:03:14,890
we pass it in a file name or something

00:03:13,270 --> 00:03:16,810
like that and we can imagine

00:03:14,890 --> 00:03:19,120
implementing this without any knowledge

00:03:16,810 --> 00:03:21,280
of Python at all basically that just

00:03:19,120 --> 00:03:23,709
views our source code as text files and

00:03:21,280 --> 00:03:25,030
manipulates them as text files so we

00:03:23,709 --> 00:03:27,160
would look for this special symbol that

00:03:25,030 --> 00:03:30,730
gives us a file name we would go find

00:03:27,160 --> 00:03:32,920
that file and then replace the line in

00:03:30,730 --> 00:03:36,360
our the file writing today with the

00:03:32,920 --> 00:03:38,800
contents of that file that we found and

00:03:36,360 --> 00:03:40,420
right now this takes entire files to

00:03:38,800 --> 00:03:42,880
include so we could choose to be more

00:03:40,420 --> 00:03:44,950
specific to say we only want this range

00:03:42,880 --> 00:03:47,170
of line numbers paste it into the file

00:03:44,950 --> 00:03:48,490
or writing today that has a lot of

00:03:47,170 --> 00:03:50,080
problems as well we would have to keep

00:03:48,490 --> 00:03:52,840
the line numbers and sync that's

00:03:50,080 --> 00:03:55,450
probably not ideal but it's worth noting

00:03:52,840 --> 00:03:57,940
that this is an improvement we now have

00:03:55,450 --> 00:03:59,800
an automatic solution that's not manual

00:03:57,940 --> 00:04:01,660
copying and pasting and we don't have to

00:03:59,800 --> 00:04:04,480
fix bugs in two places our code stays in

00:04:01,660 --> 00:04:05,590
sync so there are lots of problems with

00:04:04,480 --> 00:04:06,790
the solution still and we'll look at

00:04:05,590 --> 00:04:09,220
four of those over the course of the

00:04:06,790 --> 00:04:10,989
next 20 or so minutes for one thing this

00:04:09,220 --> 00:04:12,880
is static we can't change the behavior

00:04:10,989 --> 00:04:15,070
while the program is running for another

00:04:12,880 --> 00:04:16,630
we have name collisions if we have two

00:04:15,070 --> 00:04:19,419
things with the same name we can't tell

00:04:16,630 --> 00:04:21,310
that that will happen we're executing

00:04:19,419 --> 00:04:22,810
our files multiple times which may be

00:04:21,310 --> 00:04:24,550
inefficient but has a much more serious

00:04:22,810 --> 00:04:25,630
problem of object identity and we'll

00:04:24,550 --> 00:04:27,700
spend a little more time on that later

00:04:25,630 --> 00:04:30,370
and it's very rigid there's current

00:04:27,700 --> 00:04:33,220
my only one way to do this so let's take

00:04:30,370 --> 00:04:35,560
these one at a time we are so far

00:04:33,220 --> 00:04:37,240
manipulating our Python files as if they

00:04:35,560 --> 00:04:39,820
are simply text files with no knowledge

00:04:37,240 --> 00:04:41,380
at all of Python or the fact that Python

00:04:39,820 --> 00:04:44,020
source code can be used to make python

00:04:41,380 --> 00:04:45,610
objects now we've invented this really

00:04:44,020 --> 00:04:47,830
great dynamic language where everything

00:04:45,610 --> 00:04:50,020
happens at runtime so presumably our

00:04:47,830 --> 00:04:54,130
include or import solution here should

00:04:50,020 --> 00:04:55,840
happen at runtime too so let's go one

00:04:54,130 --> 00:04:59,260
step better we can we can call a

00:04:55,840 --> 00:05:02,620
function to include a external source

00:04:59,260 --> 00:05:04,570
code so this function we're calling

00:05:02,620 --> 00:05:07,150
magical paste takes a file name as an

00:05:04,570 --> 00:05:09,130
argument goes and finds that file and

00:05:07,150 --> 00:05:11,740
opens it reads in the source code and

00:05:09,130 --> 00:05:14,590
then uses the exact keyword to execute

00:05:11,740 --> 00:05:16,540
that source code at the moment we're

00:05:14,590 --> 00:05:18,100
using exact in the simplest way the sort

00:05:16,540 --> 00:05:20,470
of regular way but I want to spend just

00:05:18,100 --> 00:05:22,140
a minute on this in part because exact

00:05:20,470 --> 00:05:23,980
is not something you often see in

00:05:22,140 --> 00:05:25,870
production code and in part because

00:05:23,980 --> 00:05:28,810
we're going to get more complex with it

00:05:25,870 --> 00:05:31,840
in just a minute so exact takes a string

00:05:28,810 --> 00:05:34,270
and execute it as Python code now it

00:05:31,840 --> 00:05:36,970
differs from eval in that eval is for

00:05:34,270 --> 00:05:39,280
evaluating expressions and exact is for

00:05:36,970 --> 00:05:40,660
any kind of Python code so here we're

00:05:39,280 --> 00:05:42,220
defining a function we're invoking that

00:05:40,660 --> 00:05:45,850
function it works just the way you

00:05:42,220 --> 00:05:50,290
expect it to so now we have a way to

00:05:45,850 --> 00:05:52,570
dynamically run Python code and this

00:05:50,290 --> 00:05:54,430
code as currently written will work we

00:05:52,570 --> 00:05:57,010
will have a useful function available to

00:05:54,430 --> 00:06:01,740
us by invoking our magical paste

00:05:57,010 --> 00:06:04,000
function so we can solve this problem of

00:06:01,740 --> 00:06:05,380
doing sort of static analysis of a

00:06:04,000 --> 00:06:10,620
dynamic language which was not a great

00:06:05,380 --> 00:06:12,820
idea by using a python native function

00:06:10,620 --> 00:06:15,130
let's look at the second problem of name

00:06:12,820 --> 00:06:17,830
collisions so suppose that we had

00:06:15,130 --> 00:06:20,440
another file that defined another

00:06:17,830 --> 00:06:21,970
function named a useful function one of

00:06:20,440 --> 00:06:23,740
those would supersede the other we would

00:06:21,970 --> 00:06:24,790
have to know that that would happen we

00:06:23,740 --> 00:06:26,260
couldn't tell that it would happen

00:06:24,790 --> 00:06:28,780
without reading all of the relevant

00:06:26,260 --> 00:06:32,080
source code so how are we going to solve

00:06:28,780 --> 00:06:35,380
this well luckily for us we have had one

00:06:32,080 --> 00:06:37,390
honking great idea we can use namespaces

00:06:35,380 --> 00:06:39,880
to avoid name collisions just as it's

00:06:37,390 --> 00:06:41,380
mentioned in the Zen of Python though

00:06:39,880 --> 00:06:41,590
since we're inventing namespaces let's

00:06:41,380 --> 00:06:44,020
spend

00:06:41,590 --> 00:06:46,090
talking about them we could have two

00:06:44,020 --> 00:06:47,860
objects that have the same name but

00:06:46,090 --> 00:06:50,110
point to different things so we could

00:06:47,860 --> 00:06:53,230
have Montreal a city in Canada and

00:06:50,110 --> 00:06:55,240
Montreal a town in France and when we're

00:06:53,230 --> 00:06:58,660
speaking English we would add extra

00:06:55,240 --> 00:07:00,340
information to disambiguate the two now

00:06:58,660 --> 00:07:02,140
maybe it's more convenient for us to

00:07:00,340 --> 00:07:03,910
flip the order to start with the larger

00:07:02,140 --> 00:07:06,730
container and then get more specific as

00:07:03,910 --> 00:07:08,920
we progressed and we have this idea of a

00:07:06,730 --> 00:07:11,050
container and that container would have

00:07:08,920 --> 00:07:12,760
some sort of boundary in our geographic

00:07:11,050 --> 00:07:14,850
example we have the country and the

00:07:12,760 --> 00:07:17,260
batteries are obvious on google maps

00:07:14,850 --> 00:07:19,510
will have to decide what defines the

00:07:17,260 --> 00:07:22,480
boundary of a namespace but now we have

00:07:19,510 --> 00:07:24,130
this mapping of names to objects so

00:07:22,480 --> 00:07:27,640
let's start using the word module for

00:07:24,130 --> 00:07:29,740
our container it's a module just another

00:07:27,640 --> 00:07:31,720
kind of an object like a class and we'll

00:07:29,740 --> 00:07:34,660
see this is the decision that is made in

00:07:31,720 --> 00:07:36,970
some other languages but for us let's

00:07:34,660 --> 00:07:38,350
make some some different choices will

00:07:36,970 --> 00:07:40,780
say that the boundaries of a module are

00:07:38,350 --> 00:07:43,720
one file you don't need to use an

00:07:40,780 --> 00:07:45,760
explicit keyword to create a module will

00:07:43,720 --> 00:07:47,830
also say that the module by default has

00:07:45,760 --> 00:07:49,720
the same name as the file containing its

00:07:47,830 --> 00:07:51,610
source code so we've got a direct

00:07:49,720 --> 00:07:53,680
mapping onto the file system which

00:07:51,610 --> 00:07:57,160
allows us to look up where modules live

00:07:53,680 --> 00:07:59,260
really easily the upshot of these two

00:07:57,160 --> 00:08:01,600
decisions is that every time a Python

00:07:59,260 --> 00:08:03,280
programmer writes any program she's

00:08:01,600 --> 00:08:04,960
written the module so we're sort of

00:08:03,280 --> 00:08:09,160
tricking novice programmers into using

00:08:04,960 --> 00:08:11,560
modules right off the bat so let's

00:08:09,160 --> 00:08:14,140
modify our function that uses exact so

00:08:11,560 --> 00:08:16,330
that it includes a namespace this is

00:08:14,140 --> 00:08:18,790
some syntax that is not terribly common

00:08:16,330 --> 00:08:20,770
so just to run through how it works we

00:08:18,790 --> 00:08:23,320
can create an empty dictionary to use as

00:08:20,770 --> 00:08:26,290
our name space and then exec our code in

00:08:23,320 --> 00:08:28,420
that namespace when we then inspect the

00:08:26,290 --> 00:08:30,430
keys of the namespace we see that we've

00:08:28,420 --> 00:08:32,350
picked up a reference to built-ins which

00:08:30,430 --> 00:08:35,260
happens when you exact any code in any

00:08:32,350 --> 00:08:37,150
context and we've also picked up a key

00:08:35,260 --> 00:08:40,330
hi that corresponds to our function

00:08:37,150 --> 00:08:42,550
object now if we try to invoke the

00:08:40,330 --> 00:08:44,530
function hi in the current scope in the

00:08:42,550 --> 00:08:46,300
rebel session we get a name error and

00:08:44,530 --> 00:08:48,550
this is exactly the behavior that we

00:08:46,300 --> 00:08:50,650
want we see that executing this code in

00:08:48,550 --> 00:08:52,630
another namespace has protected our

00:08:50,650 --> 00:08:55,030
current namespace from all of those

00:08:52,630 --> 00:08:56,980
names and objects

00:08:55,030 --> 00:08:59,530
we can then reach into the namespace

00:08:56,980 --> 00:09:01,450
using the key that it is that is the

00:08:59,530 --> 00:09:05,500
name and get the function object itself

00:09:01,450 --> 00:09:06,880
and then invoke it normally so our

00:09:05,500 --> 00:09:09,030
modifications to our magical paste

00:09:06,880 --> 00:09:10,930
function are to create this namespace

00:09:09,030 --> 00:09:12,670
execute our source code in that

00:09:10,930 --> 00:09:16,780
namespace and then return the namespace

00:09:12,670 --> 00:09:19,720
object itself so I'm cheating in one way

00:09:16,780 --> 00:09:21,340
on this slide by using module syntax

00:09:19,720 --> 00:09:23,350
instead of dictionary syntax which I

00:09:21,340 --> 00:09:25,570
should be using so if we make that

00:09:23,350 --> 00:09:28,930
change then we have valid code here we

00:09:25,570 --> 00:09:30,850
have this pseudo module idea that is a

00:09:28,930 --> 00:09:33,850
simple name space of a mapping of names

00:09:30,850 --> 00:09:35,830
to objects so we've solved our problem

00:09:33,850 --> 00:09:38,020
of name collisions we can use modules

00:09:35,830 --> 00:09:41,320
and we can use namespaces to avoid name

00:09:38,020 --> 00:09:43,300
collisions entirely let's look at this

00:09:41,320 --> 00:09:45,790
third problem of the code executing

00:09:43,300 --> 00:09:47,890
multiple times so this could be an

00:09:45,790 --> 00:09:49,720
efficient if we had a module that

00:09:47,890 --> 00:09:51,730
defined 100 functions instead of just

00:09:49,720 --> 00:09:54,730
one function we probably wouldn't want

00:09:51,730 --> 00:09:56,680
to run it more times than necessary our

00:09:54,730 --> 00:09:59,860
module could be side affecting in some

00:09:56,680 --> 00:10:03,100
way or we could suppose that module a

00:09:59,860 --> 00:10:06,310
requires b c and d module B requires C

00:10:03,100 --> 00:10:08,560
and D and so on so that as we step

00:10:06,310 --> 00:10:11,530
through this these series of modules the

00:10:08,560 --> 00:10:14,110
problem gets worse and worse in fact

00:10:11,530 --> 00:10:15,670
there's a more serious problem with our

00:10:14,110 --> 00:10:18,420
code executing multiple times and that's

00:10:15,670 --> 00:10:21,610
one of object identity in many cases

00:10:18,420 --> 00:10:23,890
even in most cases we don't want just an

00:10:21,610 --> 00:10:25,810
identical object or another copy of the

00:10:23,890 --> 00:10:28,390
object that we have we want the same

00:10:25,810 --> 00:10:31,660
object so we can imagine writing a

00:10:28,390 --> 00:10:33,400
module that sets up some object to

00:10:31,660 --> 00:10:35,650
control a server and then spins up that

00:10:33,400 --> 00:10:37,600
server if we include that module in

00:10:35,650 --> 00:10:39,970
another file we probably don't want

00:10:37,600 --> 00:10:41,260
another server object you know spun up

00:10:39,970 --> 00:10:44,230
and running somewhere we want a

00:10:41,260 --> 00:10:47,620
reference to the one we already have so

00:10:44,230 --> 00:10:49,000
how do we solve this problem so one way

00:10:47,620 --> 00:10:51,520
to fix this kind of problem is with

00:10:49,000 --> 00:10:54,250
memoization the idea behind memoization

00:10:51,520 --> 00:10:55,690
is that we keep a record of calculations

00:10:54,250 --> 00:10:57,400
that we've already done and we don't

00:10:55,690 --> 00:10:59,500
repeat calculations when we already know

00:10:57,400 --> 00:11:02,470
the answer so the classic example is the

00:10:59,500 --> 00:11:03,760
Fibonacci sequence and naively recurse

00:11:02,470 --> 00:11:06,310
mimoh tation will make two recursive

00:11:03,760 --> 00:11:08,710
calls for each function call and so

00:11:06,310 --> 00:11:09,170
calculating Fibonacci of n request to

00:11:08,710 --> 00:11:10,399
the

00:11:09,170 --> 00:11:11,959
function calls which is incredibly

00:11:10,399 --> 00:11:14,600
inefficient which shouldn't take more

00:11:11,959 --> 00:11:16,790
than N and so we can solve this problem

00:11:14,600 --> 00:11:20,240
by storing a cash here just a dictionary

00:11:16,790 --> 00:11:22,279
of mapping input to output essentially

00:11:20,240 --> 00:11:23,959
and if we've already calculated an

00:11:22,279 --> 00:11:26,720
answer then we just return it and we

00:11:23,959 --> 00:11:28,130
don't calculate again so we can use this

00:11:26,720 --> 00:11:30,949
strategy on our magical paste function

00:11:28,130 --> 00:11:33,860
will keep a mapping in a dictionary of

00:11:30,949 --> 00:11:35,690
file names to namespace objects and if

00:11:33,860 --> 00:11:39,350
we've already executed a filename then

00:11:35,690 --> 00:11:40,880
we won't execute it again so memoization

00:11:39,350 --> 00:11:44,779
solve this problem of object identity

00:11:40,880 --> 00:11:46,160
and also helps our efficiency our fourth

00:11:44,779 --> 00:11:47,930
problem is that this function is very

00:11:46,160 --> 00:11:49,220
rigid there's only one way to include

00:11:47,930 --> 00:11:52,519
other code and that's including an

00:11:49,220 --> 00:11:54,949
entire module so we could imagine adding

00:11:52,519 --> 00:11:57,350
lots of options but that doesn't get us

00:11:54,949 --> 00:11:59,180
very far and will also note that for

00:11:57,350 --> 00:12:01,850
example on line fourteen i have to say

00:11:59,180 --> 00:12:03,709
useful twice and we decided that modules

00:12:01,850 --> 00:12:05,570
by default have the same name as the

00:12:03,709 --> 00:12:07,339
file that contains their source code

00:12:05,570 --> 00:12:11,570
we're currently not implementing that

00:12:07,339 --> 00:12:13,250
idea at all so if we add options we

00:12:11,570 --> 00:12:15,140
could get some we can get more flexible

00:12:13,250 --> 00:12:16,790
behavior but we wouldn't solve this

00:12:15,140 --> 00:12:19,699
problem of having to say things twice

00:12:16,790 --> 00:12:21,170
and in fact there's not really a

00:12:19,699 --> 00:12:23,240
solution that uses a function that

00:12:21,170 --> 00:12:25,790
solves that problem because it would be

00:12:23,240 --> 00:12:28,550
very surprising if a function modified

00:12:25,790 --> 00:12:30,140
the namespace of its collar there's that

00:12:28,550 --> 00:12:32,510
that doesn't happen generally speaking

00:12:30,140 --> 00:12:35,750
for good reason so we don't want this to

00:12:32,510 --> 00:12:38,240
be ugly and we want to have more fine

00:12:35,750 --> 00:12:41,209
control over our name space so we can

00:12:38,240 --> 00:12:42,560
use keywords instead function calls the

00:12:41,209 --> 00:12:44,839
advantage that we get is that it's more

00:12:42,560 --> 00:12:46,550
flexible in syntax it's nicer looking

00:12:44,839 --> 00:12:48,050
aesthetically we don't have to remember

00:12:46,550 --> 00:12:50,600
all these parameters and what order they

00:12:48,050 --> 00:12:52,640
go in and so forth and we can modify the

00:12:50,600 --> 00:12:55,130
caller's name space without that being

00:12:52,640 --> 00:12:56,750
totally weird functions should not

00:12:55,130 --> 00:12:59,449
modify the college name space let's not

00:12:56,750 --> 00:13:01,100
change that implementing this is a

00:12:59,449 --> 00:13:04,190
keyword requires some more work from us

00:13:01,100 --> 00:13:05,720
we have to modify pythons grammar we

00:13:04,190 --> 00:13:08,300
have to teach the parser what it means

00:13:05,720 --> 00:13:12,230
to see magical paste but all of these

00:13:08,300 --> 00:13:13,699
are relatively straightforward so we can

00:13:12,230 --> 00:13:15,819
increase the flexibility of the solution

00:13:13,699 --> 00:13:18,529
by using key words instead of functions

00:13:15,819 --> 00:13:20,990
we're now relatively close to the actual

00:13:18,529 --> 00:13:23,120
import implementation now let's take a

00:13:20,990 --> 00:13:24,380
look at actual import of a given name

00:13:23,120 --> 00:13:26,570
and see where some of these ideas appear

00:13:24,380 --> 00:13:28,610
so in actual import the first step that

00:13:26,570 --> 00:13:30,320
the interpreter takes is to check system

00:13:28,610 --> 00:13:33,410
modules to see if the name is already

00:13:30,320 --> 00:13:35,510
imported if not it makes an empty module

00:13:33,410 --> 00:13:37,730
to use as a namespace then goes and

00:13:35,510 --> 00:13:39,680
finds the source code executes that

00:13:37,730 --> 00:13:42,290
source code in the context of that new

00:13:39,680 --> 00:13:44,810
empty namespace then inserts the module

00:13:42,290 --> 00:13:46,550
into cysts on modules and finally binds

00:13:44,810 --> 00:13:48,650
the given name in the collars namespace

00:13:46,550 --> 00:13:50,839
if at the first step we have already

00:13:48,650 --> 00:13:54,010
imported this module we skip all the

00:13:50,839 --> 00:13:56,060
rest of the steps and just find the name

00:13:54,010 --> 00:13:58,730
of course we're not all the way to

00:13:56,060 --> 00:14:01,220
actual import here's a abbreviated list

00:13:58,730 --> 00:14:03,140
of things that we have not done we

00:14:01,220 --> 00:14:04,550
haven't created real modules we're

00:14:03,140 --> 00:14:06,320
currently pretending that dictionary

00:14:04,550 --> 00:14:07,850
support attribute look up which of

00:14:06,320 --> 00:14:10,970
course they don't we haven't supported

00:14:07,850 --> 00:14:12,560
packages and in fact packages didn't get

00:14:10,970 --> 00:14:14,779
support until three or four years after

00:14:12,560 --> 00:14:18,130
the first release of Python it as open

00:14:14,779 --> 00:14:20,960
source we haven't worried about how our

00:14:18,130 --> 00:14:22,970
magical pasting finds the source code in

00:14:20,960 --> 00:14:24,980
in our example we just assumed that it

00:14:22,970 --> 00:14:26,779
lived in the same directory as the code

00:14:24,980 --> 00:14:27,800
that we were importing it into but

00:14:26,779 --> 00:14:31,100
that's an idea that obviously doesn't

00:14:27,800 --> 00:14:33,050
scale very well and we haven't worried

00:14:31,100 --> 00:14:34,279
at all about error handling so if

00:14:33,050 --> 00:14:36,529
something goes wrong in the course of

00:14:34,279 --> 00:14:40,190
executing source code we're not handle

00:14:36,529 --> 00:14:41,420
that gracefully in any way we could have

00:14:40,190 --> 00:14:42,650
made different decisions at all of these

00:14:41,420 --> 00:14:43,970
different points and let's take a quick

00:14:42,650 --> 00:14:47,870
look at some solutions and other

00:14:43,970 --> 00:14:49,580
languages that are instructive the first

00:14:47,870 --> 00:14:51,740
one to look at is pound include in C

00:14:49,580 --> 00:14:53,209
which was one of guidos inspirations and

00:14:51,740 --> 00:14:55,940
especially in terms of the path for

00:14:53,209 --> 00:14:57,470
loading it's somewhat similar to what we

00:14:55,940 --> 00:14:59,630
were calling magical copy and paste at

00:14:57,470 --> 00:15:01,730
the very beginning and pasting the code

00:14:59,630 --> 00:15:04,820
that is in the included file before

00:15:01,730 --> 00:15:06,440
compiling the main file now c avoids

00:15:04,820 --> 00:15:08,450
many of the downsides that we observe in

00:15:06,440 --> 00:15:10,130
python because c is not a dynamic

00:15:08,450 --> 00:15:12,410
language so it can use linkers and

00:15:10,130 --> 00:15:13,970
compiler optimizations and generally can

00:15:12,410 --> 00:15:15,980
have a much better idea of how the

00:15:13,970 --> 00:15:19,820
program is going to execute before we

00:15:15,980 --> 00:15:21,320
start running the program we just make

00:15:19,820 --> 00:15:23,360
some syntax decisions around modules

00:15:21,320 --> 00:15:25,190
that we touched on a bit in Ruby for

00:15:23,360 --> 00:15:27,110
example creating a module is very much

00:15:25,190 --> 00:15:29,120
like creating a class you do it

00:15:27,110 --> 00:15:31,400
explicitly you use a keyword of course

00:15:29,120 --> 00:15:33,950
an end at the end of it you can have

00:15:31,400 --> 00:15:35,240
more than one module in a file and you

00:15:33,950 --> 00:15:36,830
can name the module something different

00:15:35,240 --> 00:15:39,200
than the file name

00:15:36,830 --> 00:15:41,180
it's more explicit in some ways and less

00:15:39,200 --> 00:15:44,420
explicit in others we look for one we

00:15:41,180 --> 00:15:46,850
lose this mapping of file names to

00:15:44,420 --> 00:15:49,310
module names and so if we see require

00:15:46,850 --> 00:15:51,200
terrific elsewhere in our code we don't

00:15:49,310 --> 00:15:53,120
necessarily know where that lives we

00:15:51,200 --> 00:15:55,220
also lose this idea of tricking the

00:15:53,120 --> 00:15:58,070
novice programmer into programming this

00:15:55,220 --> 00:16:02,750
way and you have to sort of seek out

00:15:58,070 --> 00:16:04,460
this pattern and start using it in

00:16:02,750 --> 00:16:06,470
nineteen eighty nine modules warranted

00:16:04,460 --> 00:16:08,150
given and Guido has said that the

00:16:06,470 --> 00:16:10,220
language modular particularly modular

00:16:08,150 --> 00:16:12,410
too and later was a significant

00:16:10,220 --> 00:16:13,970
influence on his thinking that we can

00:16:12,410 --> 00:16:15,920
notice that at least in nineteen seventy

00:16:13,970 --> 00:16:17,720
six modules were so far from obvious

00:16:15,920 --> 00:16:20,660
that the module author chose to name the

00:16:17,720 --> 00:16:21,800
language after them no today I think

00:16:20,660 --> 00:16:24,110
it's fair to say that modular

00:16:21,800 --> 00:16:26,360
programming is pervasive most languages

00:16:24,110 --> 00:16:30,140
have native modules and those that don't

00:16:26,360 --> 00:16:31,610
are often looking to add them so here we

00:16:30,140 --> 00:16:34,970
have an explicit definition of what

00:16:31,610 --> 00:16:36,800
module meant in 1976 and we can see that

00:16:34,970 --> 00:16:41,270
we haven't moved very far from that idea

00:16:36,800 --> 00:16:42,680
in the current implantation so I want to

00:16:41,270 --> 00:16:45,680
spend just a minute on this theme of

00:16:42,680 --> 00:16:47,030
pervasive paradigms today and I'm sure

00:16:45,680 --> 00:16:49,580
many of you are familiar with this quote

00:16:47,030 --> 00:16:50,810
from David Foster Wallace knows there

00:16:49,580 --> 00:16:52,430
are these two young fish swimming along

00:16:50,810 --> 00:16:54,050
and they happen to meet an older fish

00:16:52,430 --> 00:16:55,880
swimming the other way who nods at them

00:16:54,050 --> 00:16:58,400
and says morning boys how's the water

00:16:55,880 --> 00:17:00,110
and the two young fish swim on for a bit

00:16:58,400 --> 00:17:01,790
and then eventually one of them looks

00:17:00,110 --> 00:17:05,390
over at the other and goes what the hell

00:17:01,790 --> 00:17:06,800
is water so I can now reveal the

00:17:05,390 --> 00:17:08,750
alternate title for this talk which is

00:17:06,800 --> 00:17:10,510
invisible blind spots of Python

00:17:08,750 --> 00:17:12,800
programmers when it comes to import

00:17:10,510 --> 00:17:14,270
python is a mature language today and

00:17:12,800 --> 00:17:16,970
unfortunately I think we've probably

00:17:14,270 --> 00:17:19,820
lost the opportunity to become BD fls at

00:17:16,970 --> 00:17:22,190
least in Python for those of us who are

00:17:19,820 --> 00:17:23,959
native speakers of Python meaning Python

00:17:22,190 --> 00:17:25,220
was our first programming language some

00:17:23,959 --> 00:17:26,990
of these decisions embedded in the

00:17:25,220 --> 00:17:29,090
language are so familiar to become

00:17:26,990 --> 00:17:30,890
invisible so as you go through the rest

00:17:29,090 --> 00:17:32,750
of the conference this weekend and as

00:17:30,890 --> 00:17:34,430
you continue to use Python I hope you'll

00:17:32,750 --> 00:17:38,000
keep an eye out for these decisions that

00:17:34,430 --> 00:17:40,780
are hidden by their familiarity and with

00:17:38,000 --> 00:17:40,780
that I will take your questions

00:17:47,500 --> 00:17:51,020
if you have a question come over to the

00:17:49,790 --> 00:17:52,250
microphone over here or if you're on

00:17:51,020 --> 00:17:56,870
that side raise your hand and all comes

00:17:52,250 --> 00:17:58,190
at you hi there one quick question have

00:17:56,870 --> 00:18:01,370
there been any discussions about

00:17:58,190 --> 00:18:03,620
versioned modules for example let's say

00:18:01,370 --> 00:18:06,169
that I know that I require module to be

00:18:03,620 --> 00:18:07,910
of a version 1.4 how you would define

00:18:06,169 --> 00:18:10,700
that whether that would be supported and

00:18:07,910 --> 00:18:14,270
are there any good reasons why not to

00:18:10,700 --> 00:18:15,830
allow that to you know my thinking would

00:18:14,270 --> 00:18:19,610
be it's good to catch those errors early

00:18:15,830 --> 00:18:21,679
on yeah absolutely I think this gets

00:18:19,610 --> 00:18:23,630
into the idea of the difference between

00:18:21,679 --> 00:18:25,820
a module and a package and I think it

00:18:23,630 --> 00:18:27,890
makes a lot of sense to do version

00:18:25,820 --> 00:18:30,799
versioning at the package level as

00:18:27,890 --> 00:18:32,720
opposed to at the at the module level so

00:18:30,799 --> 00:18:35,860
it allows us a little bit of a pure

00:18:32,720 --> 00:18:38,809
python view of modules while keeping

00:18:35,860 --> 00:18:41,330
package management and versioning in in

00:18:38,809 --> 00:18:49,870
the tools where there's already been a

00:18:41,330 --> 00:18:49,870
lot of work in that area anyone else

00:18:56,350 --> 00:19:00,010
so if you drop down and use exec for

00:18:58,360 --> 00:19:01,900
things this brings to mind all kinds of

00:19:00,010 --> 00:19:04,270
wonderful evil things you could do for

00:19:01,900 --> 00:19:05,620
example people often who are new to

00:19:04,270 --> 00:19:08,320
python ask me well how do i instantiate

00:19:05,620 --> 00:19:09,820
a new copy of that module well that's

00:19:08,320 --> 00:19:11,500
one evil thing can you think of some

00:19:09,820 --> 00:19:16,630
other pieces of evil we could perpetrate

00:19:11,500 --> 00:19:17,620
with this power some of the people in

00:19:16,630 --> 00:19:19,539
the audience here would tell you that I

00:19:17,620 --> 00:19:22,480
tend to specialize in bad ideas in

00:19:19,539 --> 00:19:27,190
Python which are the most fun in my

00:19:22,480 --> 00:19:28,840
opinion so in terms of ways to

00:19:27,190 --> 00:19:31,570
intentionally rien Stan Shih eight

00:19:28,840 --> 00:19:33,370
modules I would say just pull it out of

00:19:31,570 --> 00:19:37,120
system modules since that's the the

00:19:33,370 --> 00:19:42,730
check in turn and then in terms of other

00:19:37,120 --> 00:19:45,659
other bad ideas that you could have that

00:19:42,730 --> 00:19:47,830
the list is probably endless let's see

00:19:45,659 --> 00:19:50,559
one a one person I was working with

00:19:47,830 --> 00:19:53,620
recently chose to change the key word

00:19:50,559 --> 00:19:56,320
from import to something else to osseo

00:19:53,620 --> 00:19:57,730
for her Harry Potter themed Python she

00:19:56,320 --> 00:19:59,440
was overriding almost all of the

00:19:57,730 --> 00:20:01,570
built-ins but import you can't overwrite

00:19:59,440 --> 00:20:03,309
that easily so once you get down if the

00:20:01,570 --> 00:20:07,870
mechanics of this there's basically no

00:20:03,309 --> 00:20:10,179
limit so you talked a little bit of that

00:20:07,870 --> 00:20:12,370
had it like right import in Python and

00:20:10,179 --> 00:20:14,980
we like got part of the way there um in

00:20:12,370 --> 00:20:19,990
python is import really implemented in

00:20:14,980 --> 00:20:21,669
python and does it use exact i think i

00:20:19,990 --> 00:20:23,730
saw a tweet from the language summit or

00:20:21,669 --> 00:20:28,780
someone described python as you know

00:20:23,730 --> 00:20:30,159
1,500 files around exec in namespace so

00:20:28,780 --> 00:20:32,260
it depends a little bit on what you mean

00:20:30,159 --> 00:20:33,610
by really implemented in Python I'm so

00:20:32,260 --> 00:20:35,559
in Python 3 in particular you can look

00:20:33,610 --> 00:20:37,960
at like the import lib and the IMP

00:20:35,559 --> 00:20:40,840
module to see all of the Python level

00:20:37,960 --> 00:20:42,730
hooks and everything that the import

00:20:40,840 --> 00:20:44,919
keyword does is actually architected by

00:20:42,730 --> 00:20:46,780
the dunder import function so we just

00:20:44,919 --> 00:20:48,970
have this different interface to it

00:20:46,780 --> 00:20:51,460
essentially so in that sense it's really

00:20:48,970 --> 00:20:54,330
written in Python in sort of a lower

00:20:51,460 --> 00:20:54,330
level sense of course it's not

00:21:12,150 --> 00:21:19,900
any thoughts about reload sure lots of

00:21:16,270 --> 00:21:21,340
thoughts about reload so reload if

00:21:19,900 --> 00:21:23,320
you're not familiar is this is something

00:21:21,340 --> 00:21:26,740
that will will essentially re import a

00:21:23,320 --> 00:21:28,420
module and it's most often useful if

00:21:26,740 --> 00:21:30,940
you're sort of playing around in a rebel

00:21:28,420 --> 00:21:32,830
session and want to and make some

00:21:30,940 --> 00:21:36,670
changes in your in your source module

00:21:32,830 --> 00:21:38,050
and want to test out those changes the

00:21:36,670 --> 00:21:42,550
thing that I find most confusing about

00:21:38,050 --> 00:21:44,140
reload is that it if you've done it from

00:21:42,550 --> 00:21:46,180
important the beginning so like from my

00:21:44,140 --> 00:21:49,030
module import some object you can't

00:21:46,180 --> 00:21:52,240
reload by the module name and you also

00:21:49,030 --> 00:21:53,740
can't repeat your from import and so I

00:21:52,240 --> 00:21:55,900
think that can be very confusing

00:21:53,740 --> 00:21:59,050
especially for the new program are

00:21:55,900 --> 00:21:59,770
poking around in the rebel one of the

00:21:59,050 --> 00:22:02,170
things I think is particularly

00:21:59,770 --> 00:22:04,050
interesting about the way that import is

00:22:02,170 --> 00:22:06,880
structured is that that from import

00:22:04,050 --> 00:22:09,670
almost makes it look like the rest of a

00:22:06,880 --> 00:22:12,220
module is not executed when in fact it

00:22:09,670 --> 00:22:15,940
is so you the only step that differs in

00:22:12,220 --> 00:22:18,610
a from import is that binding no I'm

00:22:15,940 --> 00:22:21,070
sure there are I think it's useful to

00:22:18,610 --> 00:22:22,810
have an interface to reloading a module

00:22:21,070 --> 00:22:25,480
that's not you know mucking around using

00:22:22,810 --> 00:22:27,670
exec I think the implementation puts

00:22:25,480 --> 00:22:30,930
specifically with from is somewhat

00:22:27,670 --> 00:22:30,930
confusing to beginners

00:22:36,610 --> 00:22:40,629

YouTube URL: https://www.youtube.com/watch?v=aS5kXzbsLLQ


