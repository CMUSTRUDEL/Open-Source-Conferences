Title: Katharine Jarmul: Python Scraping Showdown: A performance and accuracy review - PyCon 2014
Publication date: 2014-04-12
Playlist: PyCon 2014
Description: 
	Speaker: Katharine Jarmul

Ever wondered how python web-scraping libraries compare in terms of speed and accuracy? I'll review lxml, html5lib, BeautifulSoup and scrapy with a series of sites evaluating how quickly they can parse pages and how accurately they can find data, particularly pieces of data that render after DOM loading and other pesky bits like hidden form data, internationalized data and mobile-compliant sites.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:06,680 --> 00:00:16,800
okay ready okay hello everybody up next

00:00:15,059 --> 00:00:18,660
we've got Katherine Jamal who's going to

00:00:16,800 --> 00:00:20,910
give us a performance and accuracy with

00:00:18,660 --> 00:00:29,699
you of the top Python scraping library

00:00:20,910 --> 00:00:31,619
soon please welcome her hi everybody I'm

00:00:29,699 --> 00:00:33,719
here for Python scraping showdown

00:00:31,619 --> 00:00:36,270
hopefully you are too if not please see

00:00:33,719 --> 00:00:38,730
the directory in the hallway my name is

00:00:36,270 --> 00:00:43,440
Katherine jarmel also known fondly as

00:00:38,730 --> 00:00:46,800
cage am a little bit about me I've been

00:00:43,440 --> 00:00:49,620
using scrapers since 2010 after a shish

00:00:46,800 --> 00:00:51,420
inspired me I went to his crib you

00:00:49,620 --> 00:00:53,340
tutorial if you get bored of this talk

00:00:51,420 --> 00:01:00,870
he's giving a rather fond talk with

00:00:53,340 --> 00:01:05,330
Karen over a couple rooms down evidently

00:01:00,870 --> 00:01:08,100
my google delay is a little delayed ah a

00:01:05,330 --> 00:01:10,530
little bit more about me as I am the PI

00:01:08,100 --> 00:01:12,659
ladies co-founder or one of the pie

00:01:10,530 --> 00:01:18,750
ladies co-founders I'm happy to see a

00:01:12,659 --> 00:01:21,680
lot of pie ladies here with me today try

00:01:18,750 --> 00:01:21,680
to move us along

00:01:25,130 --> 00:01:28,130
apologies

00:01:34,130 --> 00:01:43,190
evidently everybody is on the same

00:01:36,060 --> 00:01:43,190
network imagine that let me see if I can

00:02:06,640 --> 00:02:09,720
so maybe

00:02:17,160 --> 00:02:20,330
apologies again

00:02:32,650 --> 00:02:36,850
well Mac you have failed me

00:02:54,569 --> 00:03:00,140
not sure if there's a better way to go

00:02:57,930 --> 00:03:00,140
about this

00:03:12,160 --> 00:03:14,250
um

00:03:16,130 --> 00:03:29,599
yeah sure sorry everyone ok

00:04:03,370 --> 00:04:11,459
all right let us see if I have better

00:04:07,120 --> 00:04:11,459
luck here apologies again

00:04:28,840 --> 00:04:32,130
okay so

00:04:35,379 --> 00:04:42,430
yeah all right let's get started here

00:04:43,270 --> 00:04:50,620
apologies again for that delay hopefully

00:04:47,629 --> 00:04:56,960
I can speed us up a bit and get us going

00:04:50,620 --> 00:04:59,870
okay so I am a pilot ease co-founder I

00:04:56,960 --> 00:05:02,300
am relocating to Berlin in a couple of

00:04:59,870 --> 00:05:03,889
days so if you live in Berlin or know

00:05:02,300 --> 00:05:07,639
somebody who I should meet please come

00:05:03,889 --> 00:05:08,990
say hi so why scrape the web this is

00:05:07,639 --> 00:05:11,870
becoming more and more of a question

00:05:08,990 --> 00:05:15,289
there's a lot of public api's there's

00:05:11,870 --> 00:05:19,009
lots of rest or JSON enabled endpoints

00:05:15,289 --> 00:05:21,199
both public and not so public but easily

00:05:19,009 --> 00:05:23,449
found upon investigating websites

00:05:21,199 --> 00:05:27,139
there's also a lot of well maintained

00:05:23,449 --> 00:05:29,150
open-source API libraries so those you

00:05:27,139 --> 00:05:31,669
know again allow us to scrape Twitter

00:05:29,150 --> 00:05:35,389
Facebook whatever it is we're attempting

00:05:31,669 --> 00:05:38,270
to use without really using the

00:05:35,389 --> 00:05:40,400
traditional scraping libraries for

00:05:38,270 --> 00:05:42,409
Python selenium is still your best bet

00:05:40,400 --> 00:05:44,599
if you need anything that does

00:05:42,409 --> 00:05:47,509
JavaScript interaction or that's loaded

00:05:44,599 --> 00:05:49,099
after the Dom so you're kind of a little

00:05:47,509 --> 00:05:51,409
bit shackled there there's plenty of

00:05:49,099 --> 00:05:56,839
node libraries out there but in Python

00:05:51,409 --> 00:05:58,939
that's really all you have and i'll be

00:05:56,839 --> 00:06:00,469
it with all those caveats i still think

00:05:58,939 --> 00:06:02,089
that there's a lot of sites where you

00:06:00,469 --> 00:06:04,729
can build a traditional scraper and

00:06:02,089 --> 00:06:06,889
scrape content that way and i still find

00:06:04,729 --> 00:06:10,039
it very fun to build those for my own

00:06:06,889 --> 00:06:11,659
use so what this talk is going to cover

00:06:10,039 --> 00:06:13,699
I'm going to look at different

00:06:11,659 --> 00:06:17,270
performance within lxml vert and

00:06:13,699 --> 00:06:20,479
beautiful soup I'll go into a little bit

00:06:17,270 --> 00:06:22,879
more why I narrowed it down I'm going to

00:06:20,479 --> 00:06:25,069
talk about finding elements with

00:06:22,879 --> 00:06:26,960
selenium so a lot of us who've used

00:06:25,069 --> 00:06:28,520
selenium there's many options for

00:06:26,960 --> 00:06:30,860
finding elements I'm going to talk about

00:06:28,520 --> 00:06:33,589
which is the fastest and I'm going to

00:06:30,860 --> 00:06:35,930
take a look at scrapie or scrap hi I'm

00:06:33,589 --> 00:06:37,789
not quite sure the pronunciation and see

00:06:35,930 --> 00:06:40,099
how fast we can go with Python and

00:06:37,789 --> 00:06:42,019
scraping the web so a bit of a

00:06:40,099 --> 00:06:44,000
disclaimer when I first was putting

00:06:42,019 --> 00:06:46,159
together to the test for this I want to

00:06:44,000 --> 00:06:47,230
screw use quite a lot of scraping

00:06:46,159 --> 00:06:49,060
libraries

00:06:47,230 --> 00:06:50,410
I found as I began to look at it is a

00:06:49,060 --> 00:06:52,720
lot of them are using similar

00:06:50,410 --> 00:06:55,180
dependencies and so I decided that it

00:06:52,720 --> 00:06:57,580
might be best used to hone in on some of

00:06:55,180 --> 00:07:01,000
the most popular ones and most widely

00:06:57,580 --> 00:07:05,200
used ones which is what led me to lxml

00:07:01,000 --> 00:07:07,180
and beautiful suit I also in this I kind

00:07:05,200 --> 00:07:09,610
of wanted to find some broken pages I've

00:07:07,180 --> 00:07:12,010
been scraping using lxml for some years

00:07:09,610 --> 00:07:13,840
now and it often would happen to me

00:07:12,010 --> 00:07:16,210
where I'd come across a page where

00:07:13,840 --> 00:07:18,280
beautiful soup was truly my only option

00:07:16,210 --> 00:07:20,800
to accurately parse the page I think

00:07:18,280 --> 00:07:22,480
html5 is changing this landscape and

00:07:20,800 --> 00:07:25,000
hopefully allowing us to have more

00:07:22,480 --> 00:07:27,610
standardized web content which allows us

00:07:25,000 --> 00:07:29,950
to scrape the web utilizing the element

00:07:27,610 --> 00:07:33,070
tree api's and other things similar to

00:07:29,950 --> 00:07:35,500
that if you find of course broken pages

00:07:33,070 --> 00:07:38,320
beautifulsoup an html5 lib also have

00:07:35,500 --> 00:07:40,330
quite a lot of helpers for scraping you

00:07:38,320 --> 00:07:43,150
know truly broken pages that don't

00:07:40,330 --> 00:07:45,610
follow any sort of uniformity of tags

00:07:43,150 --> 00:07:47,950
and all of my code for this talk is

00:07:45,610 --> 00:07:51,300
available at my github so I created a

00:07:47,950 --> 00:07:55,390
repository I believe called web scraping

00:07:51,300 --> 00:07:57,760
speed comparison and you can please fork

00:07:55,390 --> 00:08:01,390
it download it play around with it prove

00:07:57,760 --> 00:08:03,880
me wrong with my own tests so I wanted

00:08:01,390 --> 00:08:05,650
to compare lxml and beautiful soup a lot

00:08:03,880 --> 00:08:08,230
of times these are you know the commonly

00:08:05,650 --> 00:08:10,480
and most popular used they use

00:08:08,230 --> 00:08:12,700
distinctly different methods to unpack

00:08:10,480 --> 00:08:16,390
and parse HTML so I wanted to kind of

00:08:12,700 --> 00:08:18,790
take a look at those methods and both of

00:08:16,390 --> 00:08:21,670
them I find to be tremendously accurate

00:08:18,790 --> 00:08:23,920
with the right level of detail so I feel

00:08:21,670 --> 00:08:26,680
like a lot of it is up to the developer

00:08:23,920 --> 00:08:28,180
the onus is on you to kind of write your

00:08:26,680 --> 00:08:30,550
scraper in such a way that you're

00:08:28,180 --> 00:08:32,349
accurately finding the data but I find

00:08:30,550 --> 00:08:36,460
them fairly easy to manipulate for this

00:08:32,349 --> 00:08:38,979
purpose and lxml utilizes both X pass

00:08:36,460 --> 00:08:41,590
and CSS select so I decided to compare

00:08:38,979 --> 00:08:43,660
those me myself being a developer being

00:08:41,590 --> 00:08:46,060
lazy a lot of times I'll just rely on

00:08:43,660 --> 00:08:48,310
CSS select rather than write out the

00:08:46,060 --> 00:08:51,690
entire XPath and I wanted to see whether

00:08:48,310 --> 00:08:51,690
I was losing a lot of time

00:08:54,740 --> 00:09:00,080
okay so what was my methodology first I

00:08:57,830 --> 00:09:02,630
wrote accurate scrapers as best I could

00:09:00,080 --> 00:09:04,580
and then I tried to find similar ways to

00:09:02,630 --> 00:09:07,550
parse it so with a lot of my functions I

00:09:04,580 --> 00:09:11,480
tried to follow a similar method of find

00:09:07,550 --> 00:09:14,450
and search so that I could continue to

00:09:11,480 --> 00:09:16,399
compare the libraries rather than my own

00:09:14,450 --> 00:09:18,560
code I'm fairly certain I could have

00:09:16,399 --> 00:09:21,200
written these parcels to be faster by

00:09:18,560 --> 00:09:23,330
employing different fast methods of the

00:09:21,200 --> 00:09:25,940
library but i found that maybe this

00:09:23,330 --> 00:09:28,640
might be the most accurate way then i

00:09:25,940 --> 00:09:31,250
used see profile and peace stats to kind

00:09:28,640 --> 00:09:34,880
of analyze how much it took for each

00:09:31,250 --> 00:09:37,120
function to run and then i did it over a

00:09:34,880 --> 00:09:39,890
number of trials ranging from 10 to 500

00:09:37,120 --> 00:09:42,230
so the first thing that i decided to do

00:09:39,890 --> 00:09:45,290
is I wanted to scrape the NHL scores I'm

00:09:42,230 --> 00:09:47,450
an avid hockey fan and we're about to

00:09:45,290 --> 00:09:48,950
enter playoffs and we're in Canada so I

00:09:47,450 --> 00:09:52,820
figured I might be amongst hockey

00:09:48,950 --> 00:09:56,930
fanatics and so I went to their scores

00:09:52,820 --> 00:09:59,029
page and I personally am big twins fan

00:09:56,930 --> 00:10:02,000
so I wanted to see how my goons were

00:09:59,029 --> 00:10:03,829
going to do in the playoffs this is the

00:10:02,000 --> 00:10:05,270
only code i'll show you and apologies

00:10:03,829 --> 00:10:07,730
again for trying to fit it all in one

00:10:05,270 --> 00:10:10,579
slide again the repos up on my github at

00:10:07,730 --> 00:10:13,490
k jam but basically you can see here I

00:10:10,579 --> 00:10:15,880
have my lxml with xpath lxml with CSS

00:10:13,490 --> 00:10:19,459
and beautiful soup and I attempted to

00:10:15,880 --> 00:10:21,230
employ similar ways of you know

00:10:19,459 --> 00:10:23,839
unpacking and wrapping the content

00:10:21,230 --> 00:10:25,730
finding the scores body then finding

00:10:23,839 --> 00:10:27,980
those game boxes and then going within

00:10:25,730 --> 00:10:31,940
the columns to find both the teen names

00:10:27,980 --> 00:10:34,880
and the scores and here's where my

00:10:31,940 --> 00:10:38,329
results so as you can see lxml with

00:10:34,880 --> 00:10:42,140
xpath was a clear winner here it was way

00:10:38,329 --> 00:10:44,570
under even point 06 / run as well as

00:10:42,140 --> 00:10:47,810
beautiful soup was the took the longest

00:10:44,570 --> 00:10:51,230
it was up to nearly point 24 seconds per

00:10:47,810 --> 00:10:54,560
run you can see that lxml with CSS was

00:10:51,230 --> 00:10:57,770
just a close second particularly as the

00:10:54,560 --> 00:11:00,290
averages got higher and we could take a

00:10:57,770 --> 00:11:02,450
little bit of a look here at why and

00:11:00,290 --> 00:11:05,930
where the speed might come from so we

00:11:02,450 --> 00:11:08,630
see lxml with xpath has 238 function

00:11:05,930 --> 00:11:10,430
calls far below the 200

00:11:08,630 --> 00:11:12,770
eighty-thousand that beautiful soup

00:11:10,430 --> 00:11:15,500
average so we can start to see maybe

00:11:12,770 --> 00:11:18,470
this is where some of the speed of xpath

00:11:15,500 --> 00:11:20,630
is coming into play again these varied

00:11:18,470 --> 00:11:25,100
by run but I didn't see a large

00:11:20,630 --> 00:11:28,420
disparity amongst runs and so then in an

00:11:25,100 --> 00:11:30,740
accuracy review all of the different

00:11:28,420 --> 00:11:32,720
scrapers were able to accurately find

00:11:30,740 --> 00:11:34,990
all of the game scores and just so that

00:11:32,720 --> 00:11:38,330
you can run these as well in the

00:11:34,990 --> 00:11:41,990
repository I also included the source of

00:11:38,330 --> 00:11:44,330
the initial pages I was scraping so the

00:11:41,990 --> 00:11:46,220
next thing I decided to do is I have a

00:11:44,330 --> 00:11:48,440
bit of an e-commerce background as well

00:11:46,220 --> 00:11:51,590
and ecommerce sites are notoriously

00:11:48,440 --> 00:11:54,140
messy and so I decided to scrape amazon

00:11:51,590 --> 00:11:55,940
deals so I can get my deal of the day in

00:11:54,140 --> 00:11:58,280
my email but what about these lightning

00:11:55,940 --> 00:12:01,040
deals across the bottom what I wanted to

00:11:58,280 --> 00:12:04,550
do is grab the title the link and the

00:12:01,040 --> 00:12:08,240
price and what I found in running it is

00:12:04,550 --> 00:12:11,210
again lxml with xpath was the winner but

00:12:08,240 --> 00:12:13,280
we see here that depending on the site

00:12:11,210 --> 00:12:15,110
content and how quickly it can be parsed

00:12:13,280 --> 00:12:18,590
beautiful soup was only several

00:12:15,110 --> 00:12:20,330
hundredths of a second slower so we can

00:12:18,590 --> 00:12:23,690
start to see hey you know what all of

00:12:20,330 --> 00:12:26,360
these are pretty fast options yes lxml

00:12:23,690 --> 00:12:28,040
with xpath is the fastest but we can

00:12:26,360 --> 00:12:31,030
start to see that depending on the page

00:12:28,040 --> 00:12:33,710
we're going to have a variety of times

00:12:31,030 --> 00:12:36,320
but again when i looked at the function

00:12:33,710 --> 00:12:40,130
calls i saw just far less overhead with

00:12:36,320 --> 00:12:45,110
xpath i'm even then with lxml using CSS

00:12:40,130 --> 00:12:47,480
select so in an accuracy review of this

00:12:45,110 --> 00:12:50,000
oddly enough beautiful soup was not able

00:12:47,480 --> 00:12:52,100
to properly parse using the same sort of

00:12:50,000 --> 00:12:54,380
syntax as the others I mean I actually

00:12:52,100 --> 00:12:56,270
was having a hard time even getting to

00:12:54,380 --> 00:12:59,090
that part of the page without using a

00:12:56,270 --> 00:13:01,880
whole family tree crawl and so what I

00:12:59,090 --> 00:13:03,620
determined or what i did is i modified

00:13:01,880 --> 00:13:05,990
it so it would find the top deal so it

00:13:03,620 --> 00:13:07,790
could be at least comparative I wasn't

00:13:05,990 --> 00:13:10,160
going to sit there and compare you know

00:13:07,790 --> 00:13:13,460
20 to 30 lines of beautiful soup with

00:13:10,160 --> 00:13:15,020
five lines of lxml but this is actually

00:13:13,460 --> 00:13:17,839
an interesting fine for me so I thought

00:13:15,020 --> 00:13:19,550
I'd share it the third and last case

00:13:17,839 --> 00:13:21,650
study that I did in terms of scraping

00:13:19,550 --> 00:13:22,460
was I looked at New York Times mobile

00:13:21,650 --> 00:13:24,020
site I def

00:13:22,460 --> 00:13:25,820
wanted to do a mobile site because

00:13:24,020 --> 00:13:27,470
mobile sites as we all know are

00:13:25,820 --> 00:13:31,220
generally more lightweight they load

00:13:27,470 --> 00:13:32,930
faster they usually have less JavaScript

00:13:31,220 --> 00:13:34,760
and other junk running on the page and

00:13:32,930 --> 00:13:36,440
what I did was I grabbed the headline

00:13:34,760 --> 00:13:38,540
the link and the blurb if it was

00:13:36,440 --> 00:13:43,100
available of the New York Times mobile

00:13:38,540 --> 00:13:45,200
home page and again I found that we had

00:13:43,100 --> 00:13:47,120
tremendous speed with all libraries if

00:13:45,200 --> 00:13:49,550
you can't see from across the back even

00:13:47,120 --> 00:13:52,550
beautiful soup is clocking in at four

00:13:49,550 --> 00:13:55,130
and a half hundredths of a second but

00:13:52,550 --> 00:14:01,400
lxml with xpath was just super super

00:13:55,130 --> 00:14:03,320
speedy and what I found here again with

00:14:01,400 --> 00:14:05,180
the average function calls xpath was a

00:14:03,320 --> 00:14:08,480
little bit more than I had expected

00:14:05,180 --> 00:14:13,340
given the other runs but regardless it

00:14:08,480 --> 00:14:15,710
still was much fewer calls than the

00:14:13,340 --> 00:14:18,260
others and again in accuracy they all

00:14:15,710 --> 00:14:20,060
found 17 articles and there was a null

00:14:18,260 --> 00:14:21,620
set at the bottom I'm assuming New York

00:14:20,060 --> 00:14:25,280
Times uses it for some sort of style

00:14:21,620 --> 00:14:28,100
divider so lxml with xpath is the clear

00:14:25,280 --> 00:14:29,930
winner here in terms of speed but at the

00:14:28,100 --> 00:14:33,530
end of the day it's really not by much

00:14:29,930 --> 00:14:35,090
so I would again I would caution against

00:14:33,530 --> 00:14:37,400
saying something like beautiful soup is

00:14:35,090 --> 00:14:39,980
slow that's just not true and I would

00:14:37,400 --> 00:14:42,350
caution against saying lxml the XPath is

00:14:39,980 --> 00:14:44,120
the fastest thing in the world but it is

00:14:42,350 --> 00:14:46,610
pretty fast and if you're looking at

00:14:44,120 --> 00:14:48,350
scraping quite a lot of data it would

00:14:46,610 --> 00:14:50,770
definitely be worth investigating right

00:14:48,350 --> 00:14:53,840
so I'm going to take a look at selenium

00:14:50,770 --> 00:14:56,510
selenium by far if you're using python

00:14:53,840 --> 00:14:58,820
is the best for page interactions or

00:14:56,510 --> 00:15:01,250
after download elements especially

00:14:58,820 --> 00:15:03,380
anything that has like login flows and

00:15:01,250 --> 00:15:06,650
things like that I find it's just really

00:15:03,380 --> 00:15:09,050
useful selenium also gives you a whole

00:15:06,650 --> 00:15:11,750
lot of ways to find elements on the page

00:15:09,050 --> 00:15:13,190
and I wonder to myself when I code

00:15:11,750 --> 00:15:15,080
silentium things I mean I'm already

00:15:13,190 --> 00:15:17,030
losing so much time loading a browser

00:15:15,080 --> 00:15:18,860
and clicking through things what's going

00:15:17,030 --> 00:15:21,920
to be the fastest in terms of finding

00:15:18,860 --> 00:15:25,010
elements and so I'm going to compare

00:15:21,920 --> 00:15:28,450
find element by tag name find element by

00:15:25,010 --> 00:15:30,890
class name and find element by xpath

00:15:28,450 --> 00:15:34,430
there were others to compare but I find

00:15:30,890 --> 00:15:36,070
that I use these the most so I decided

00:15:34,430 --> 00:15:38,560
to go to yahoo com

00:15:36,070 --> 00:15:40,510
wanted to find the search box and I

00:15:38,560 --> 00:15:42,970
wanted to find this little trending now

00:15:40,510 --> 00:15:45,340
section it's trending across yahoo i

00:15:42,970 --> 00:15:47,110
guess i was curious as to what was there

00:15:45,340 --> 00:15:50,080
what i thought is maybe this might be a

00:15:47,110 --> 00:15:53,110
good start script for going about and

00:15:50,080 --> 00:15:54,670
searching different search sites and

00:15:53,110 --> 00:15:57,610
seeing what they came up with how many

00:15:54,670 --> 00:15:59,350
results are similar or different this

00:15:57,610 --> 00:16:02,620
just will compare the find though and

00:15:59,350 --> 00:16:04,870
what i found is that again we're dealing

00:16:02,620 --> 00:16:07,360
with really hundredths of a second

00:16:04,870 --> 00:16:10,270
difference I found out with the shorter

00:16:07,360 --> 00:16:12,400
runs CSS sometimes beat expat this was

00:16:10,270 --> 00:16:15,340
one of the times that it did so I wanted

00:16:12,400 --> 00:16:18,940
to show that and but still we see that X

00:16:15,340 --> 00:16:21,700
path over the average of many runs comes

00:16:18,940 --> 00:16:23,110
Clarkson as the fastest and tag name

00:16:21,700 --> 00:16:25,330
actually ended up being the slowest

00:16:23,110 --> 00:16:27,610
which was surprising to me I assumed

00:16:25,330 --> 00:16:30,250
kind of that tag name used XPath

00:16:27,610 --> 00:16:32,320
underneath the covers but that might not

00:16:30,250 --> 00:16:34,360
be the case if somebody works on

00:16:32,320 --> 00:16:37,980
selenium or understand selenium better

00:16:34,360 --> 00:16:40,480
than I maybe you can best explain this

00:16:37,980 --> 00:16:42,790
but when I looked at the function calls

00:16:40,480 --> 00:16:45,100
i found that XPath had quite a lot more

00:16:42,790 --> 00:16:47,110
than I expected this probably has to do

00:16:45,100 --> 00:16:49,150
with the fact that selenium is most

00:16:47,110 --> 00:16:51,100
likely using a rendering engine more

00:16:49,150 --> 00:16:53,830
similar to the browser whereas fine with

00:16:51,100 --> 00:16:56,770
CSS had a very low number of function

00:16:53,830 --> 00:16:58,030
calls in comparison that made me think

00:16:56,770 --> 00:17:00,160
that if you're running quite a lot of

00:16:58,030 --> 00:17:02,620
selenium maybe CSS is going to be the

00:17:00,160 --> 00:17:06,730
best way tag name here was the clear

00:17:02,620 --> 00:17:09,400
loser CSS an XPath are both great tag is

00:17:06,730 --> 00:17:12,189
clearly slower and with more calls but

00:17:09,400 --> 00:17:14,500
similarly to my find with web scraping

00:17:12,189 --> 00:17:17,230
libraries it wasn't that huge of a

00:17:14,500 --> 00:17:19,360
difference and again you want to think

00:17:17,230 --> 00:17:21,280
about what you're comfortable with what

00:17:19,360 --> 00:17:23,740
your team is comfortable with and what

00:17:21,280 --> 00:17:26,380
is readable to you and use you know what

00:17:23,740 --> 00:17:30,670
makes the most sense for your script so

00:17:26,380 --> 00:17:33,460
I wanted to investigate scrapie it uses

00:17:30,670 --> 00:17:35,440
lxml XPath to find elements or as they

00:17:33,460 --> 00:17:37,900
call them within the library items and

00:17:35,440 --> 00:17:43,000
it uses twisted for asynchronous

00:17:37,900 --> 00:17:46,000
crawling so to me it seemed that it was

00:17:43,000 --> 00:17:47,620
going to be really speedy also scrapy

00:17:46,000 --> 00:17:49,740
I've seen it evolved a lot over the past

00:17:47,620 --> 00:17:53,320
two years I've kind of been fun

00:17:49,740 --> 00:17:55,630
watching it grow and it's just become

00:17:53,320 --> 00:17:57,610
quite powerful in terms of crawling and

00:17:55,630 --> 00:18:00,730
spy during the web if you haven't used

00:17:57,610 --> 00:18:03,010
it yet I you know cannot encourage you

00:18:00,730 --> 00:18:05,470
enough to go about building your own

00:18:03,010 --> 00:18:07,540
crawler they just have a lot of really

00:18:05,470 --> 00:18:10,360
robust functionality and helpers for you

00:18:07,540 --> 00:18:16,180
and so with our speed knowledge I was

00:18:10,360 --> 00:18:17,800
wondering how fast can we go so what I

00:18:16,180 --> 00:18:20,260
wanted to do is I was going to query

00:18:17,800 --> 00:18:22,810
Google with pagination for search

00:18:20,260 --> 00:18:25,480
results within those search results I

00:18:22,810 --> 00:18:27,940
would find the title the blurb and the

00:18:25,480 --> 00:18:29,740
link I didn't worry about saving it to

00:18:27,940 --> 00:18:31,780
disk or I didn't want any rights messing

00:18:29,740 --> 00:18:33,220
up my speed tests so again that's going

00:18:31,780 --> 00:18:36,910
to add some time depending on your

00:18:33,220 --> 00:18:40,570
script so I googled Python because I

00:18:36,910 --> 00:18:43,120
thought why not and so here's a bit of

00:18:40,570 --> 00:18:44,920
my stats you can see my see profile

00:18:43,120 --> 00:18:47,440
stats at the bottom but I was having to

00:18:44,920 --> 00:18:49,870
use a command line caller from within

00:18:47,440 --> 00:18:52,510
the scrapie library to get it running so

00:18:49,870 --> 00:18:55,870
but you can see the item scraped count

00:18:52,510 --> 00:18:58,060
is 306 if you look at the start time

00:18:55,870 --> 00:19:01,600
compared to the end time we're talking

00:18:58,060 --> 00:19:08,050
about slightly like a shave over three

00:19:01,600 --> 00:19:10,090
seconds to get 306 results so scraping

00:19:08,050 --> 00:19:12,790
google the spider was averaging almost

00:19:10,090 --> 00:19:14,410
100 results a second or around about

00:19:12,790 --> 00:19:16,540
sometimes a little over sometimes a

00:19:14,410 --> 00:19:18,190
little under to me that seemed

00:19:16,540 --> 00:19:20,830
tremendously fast and it was really

00:19:18,190 --> 00:19:25,300
exciting to see how powerful it could be

00:19:20,830 --> 00:19:27,160
also Google hates me so I caution you

00:19:25,300 --> 00:19:30,880
against running this script at home

00:19:27,160 --> 00:19:33,700
during off-hours I was captured to death

00:19:30,880 --> 00:19:35,230
but I found that if you run it during

00:19:33,700 --> 00:19:36,580
you know the busy times of the day in

00:19:35,230 --> 00:19:38,950
the morning hours whatever your time

00:19:36,580 --> 00:19:41,170
zone is maybe Google will hate you less

00:19:38,950 --> 00:19:45,430
a lot of times I could get through up to

00:19:41,170 --> 00:19:48,820
a 340 results and about the 360 mark or

00:19:45,430 --> 00:19:53,740
whichever one with twisted finished the

00:19:48,820 --> 00:19:55,690
last I would get captured and also

00:19:53,740 --> 00:19:58,270
scrapie has a bunch of different tools

00:19:55,690 --> 00:20:00,130
very similar to what we saw in the

00:19:58,270 --> 00:20:01,240
mechanized functionality for those of

00:20:00,130 --> 00:20:02,950
you that are familiar with the

00:20:01,240 --> 00:20:04,960
mechanized library

00:20:02,950 --> 00:20:07,360
to get around captcha blocks you can use

00:20:04,960 --> 00:20:09,550
different user agent strings you can use

00:20:07,360 --> 00:20:12,940
different IPS and other things like that

00:20:09,550 --> 00:20:15,370
so I for this test i wanted to rather

00:20:12,940 --> 00:20:17,830
than see how quickly i could fool google

00:20:15,370 --> 00:20:20,830
i wanted to see how quickly i could get

00:20:17,830 --> 00:20:23,410
the scraper running so but it's it's

00:20:20,830 --> 00:20:26,560
easily for cable or to write your own

00:20:23,410 --> 00:20:28,750
and use some of their logic to scrape

00:20:26,560 --> 00:20:34,390
google even faster and at more length

00:20:28,750 --> 00:20:37,210
during off-hours so in conclusion lxml

00:20:34,390 --> 00:20:40,930
using xpath is the clear winner when it

00:20:37,210 --> 00:20:43,300
comes to speed for readability and

00:20:40,930 --> 00:20:45,430
accuracy though both in the code and the

00:20:43,300 --> 00:20:47,650
content that you scrape you know it's

00:20:45,430 --> 00:20:49,930
really the time difference was not as

00:20:47,650 --> 00:20:52,510
amazing as I thought it was amazing

00:20:49,930 --> 00:20:54,730
enough that if you're parsing thousands

00:20:52,510 --> 00:20:56,740
of websites it's probably going to make

00:20:54,730 --> 00:20:58,750
a difference to you but if you're just

00:20:56,740 --> 00:21:01,690
writing a scraper at home for your

00:20:58,750 --> 00:21:03,870
favorite restaurant or finding local

00:21:01,690 --> 00:21:06,760
deals near you or whatever it might be

00:21:03,870 --> 00:21:08,170
then I don't think there's a big

00:21:06,760 --> 00:21:10,150
difference and it's going to end up

00:21:08,170 --> 00:21:12,040
being you know what is easiest for you

00:21:10,150 --> 00:21:15,640
to install what's easiest for your team

00:21:12,040 --> 00:21:17,500
to use and your code again might vary so

00:21:15,640 --> 00:21:19,540
there are ways to speed up beautiful

00:21:17,500 --> 00:21:22,030
soup depending on the way that the page

00:21:19,540 --> 00:21:24,610
is parsed and I would advise using those

00:21:22,030 --> 00:21:26,500
if you are set with a like a Windows

00:21:24,610 --> 00:21:29,350
operating system or something else where

00:21:26,500 --> 00:21:32,110
lxml becomes a big pain in the rear to

00:21:29,350 --> 00:21:34,090
install and then if xpath is too

00:21:32,110 --> 00:21:35,620
confusing or limiting if you're really

00:21:34,090 --> 00:21:37,840
into web scraping I strongly encourage

00:21:35,620 --> 00:21:40,270
you learn xpath it's really fun and

00:21:37,840 --> 00:21:42,190
super powerful but if it for some reason

00:21:40,270 --> 00:21:45,370
is too confusing or limiting or you're

00:21:42,190 --> 00:21:48,970
feeling lazy CSS select is obviously a

00:21:45,370 --> 00:21:51,940
close second choice so I would say to

00:21:48,970 --> 00:21:53,950
use that so I'd like to invite you to

00:21:51,940 --> 00:21:55,780
ask questions again thanks for staying

00:21:53,950 --> 00:21:58,960
with me apologies for my technical

00:21:55,780 --> 00:22:00,580
difficulties I am kgm on Twitter if

00:21:58,960 --> 00:22:03,070
you'd like to hit me up later if you

00:22:00,580 --> 00:22:06,100
want to explore the repository first I

00:22:03,070 --> 00:22:10,320
also idle on freenode as cage am and

00:22:06,100 --> 00:22:10,320
thank you so much for coming to my talk

00:22:13,100 --> 00:22:21,900
and if you have questions there's a

00:22:15,330 --> 00:22:24,120
microphone right there uh hi hi I guess

00:22:21,900 --> 00:22:26,670
this is kind of a comment and then a

00:22:24,120 --> 00:22:29,460
question okay um but I happen to use let

00:22:26,670 --> 00:22:32,100
him quite a bit my job oh um so I think

00:22:29,460 --> 00:22:33,150
that utilizing function calls as a way

00:22:32,100 --> 00:22:34,410
to determine what the performance of

00:22:33,150 --> 00:22:36,770
selenium looks like isn't actually a

00:22:34,410 --> 00:22:38,970
fair representation mainly because

00:22:36,770 --> 00:22:41,520
selenium is actually a protocol that

00:22:38,970 --> 00:22:43,770
communicates with browser and it's kind

00:22:41,520 --> 00:22:45,570
of language agnostic all the Python

00:22:43,770 --> 00:22:47,190
interfaces doing is just calling a

00:22:45,570 --> 00:22:49,980
remote interface that communicates with

00:22:47,190 --> 00:22:53,280
it so you probably wouldn't did you

00:22:49,980 --> 00:22:55,620
figure out why the performance is you

00:22:53,280 --> 00:22:59,550
know lacking or you know very performant

00:22:55,620 --> 00:23:01,280
that way okay um and also the various

00:22:59,550 --> 00:23:03,240
calls that webdriver actually

00:23:01,280 --> 00:23:06,810
incorporates webdriver is the underlying

00:23:03,240 --> 00:23:09,810
in Frinton face for a selenium sorry I

00:23:06,810 --> 00:23:12,210
know this is kind of but um it actually

00:23:09,810 --> 00:23:14,280
depends on how the browser chooses to

00:23:12,210 --> 00:23:15,810
implement that protocol okay I'm some

00:23:14,280 --> 00:23:18,540
use choose using existing JavaScript

00:23:15,810 --> 00:23:20,490
engine others utilize more built-in

00:23:18,540 --> 00:23:22,560
functionality do you have do you have

00:23:20,490 --> 00:23:26,100
advice on which driver is the fastest

00:23:22,560 --> 00:23:28,680
yeah it's fan MJS is actually a headless

00:23:26,100 --> 00:23:30,270
browser that works um and you can run

00:23:28,680 --> 00:23:32,160
you know thousands and processes that's

00:23:30,270 --> 00:23:34,740
what we do at my job and it tends to be

00:23:32,160 --> 00:23:35,820
a lot faster than I'm guessing I mean

00:23:34,740 --> 00:23:38,400
most people tend to use internet

00:23:35,820 --> 00:23:41,610
explorer or firefox and yeah it's we

00:23:38,400 --> 00:23:43,140
found yeah 10 times depending on what

00:23:41,610 --> 00:23:45,950
kind of testing running there's also a

00:23:43,140 --> 00:23:48,390
headless chrome now as well yes um

00:23:45,950 --> 00:23:51,120
headless what a headless chrome browser

00:23:48,390 --> 00:23:52,290
dry there yes nice I would I was

00:23:51,120 --> 00:23:53,820
wondering just if you knew the

00:23:52,290 --> 00:23:55,560
comparison between the headless chrome

00:23:53,820 --> 00:23:58,560
and the Phantom j/s I haven't tried that

00:23:55,560 --> 00:24:00,210
scroll um and I was curious what browser

00:23:58,560 --> 00:24:01,770
you chose to use for your selenium tests

00:24:00,210 --> 00:24:04,260
for the selenium tests i just used

00:24:01,770 --> 00:24:06,720
firefox so yeah it's fairly slow usually

00:24:04,260 --> 00:24:08,280
I use Chrome but I wanted an example

00:24:06,720 --> 00:24:12,900
that was easily portable for everyone

00:24:08,280 --> 00:24:15,720
gotcha all right thank you thank you hey

00:24:12,900 --> 00:24:18,390
thanks for the talk um just curious what

00:24:15,720 --> 00:24:23,220
was the most interesting and or useful

00:24:18,390 --> 00:24:26,669
and or cool I guess thank you scraped um

00:24:23,220 --> 00:24:29,309
all of my time scraping yeah um probably

00:24:26,669 --> 00:24:31,650
at one point in time I was using a

00:24:29,309 --> 00:24:34,169
service with my company we were

00:24:31,650 --> 00:24:37,559
utilizing a service to help us with some

00:24:34,169 --> 00:24:40,289
logging and I exposed basically a hidden

00:24:37,559 --> 00:24:42,299
API at some point in time I just pinged

00:24:40,289 --> 00:24:44,490
the dev team and said hey I found that I

00:24:42,299 --> 00:24:46,530
can go back like a year but if I wanted

00:24:44,490 --> 00:24:49,169
to go back more than a year what could I

00:24:46,530 --> 00:24:53,039
use and they wrote me back saying we're

00:24:49,169 --> 00:25:00,690
closing that API endpoints apologies I

00:24:53,039 --> 00:25:03,990
didn't mean to be evil any other

00:25:00,690 --> 00:25:07,460
question all right thank you so much and

00:25:03,990 --> 00:25:07,460

YouTube URL: https://www.youtube.com/watch?v=dWlhrL1l3QU


