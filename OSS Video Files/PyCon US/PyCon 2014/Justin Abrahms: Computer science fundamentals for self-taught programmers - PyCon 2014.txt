Title: Justin Abrahms: Computer science fundamentals for self-taught programmers - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Justin Abrahms

"When people talk about Big O notation do you go cross eyed? Do you not
 get the point of learning about implementing linked lists or depth
 first search? Join me as I introduce the CS fundamentals that helped
 me ace my Google interview, even though I didn't get a formal CS
 education."

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:00,740 --> 00:00:05,339
and welcome Justin Abraham's self-taught

00:00:03,899 --> 00:00:06,330
computer programmer he's going to share

00:00:05,339 --> 00:00:07,680
with his computer science for the

00:00:06,330 --> 00:00:15,269
self-taught programmer thank you very

00:00:07,680 --> 00:00:16,410
much hello everyone as he said I'm

00:00:15,269 --> 00:00:18,750
Justin Abrams and I'm going to talk

00:00:16,410 --> 00:00:23,430
about computer science for self-taught

00:00:18,750 --> 00:00:24,810
programmers a little bit about me I am a

00:00:23,430 --> 00:00:27,109
director of product engineering at a

00:00:24,810 --> 00:00:29,279
company called quick left we do

00:00:27,109 --> 00:00:30,990
consulting and also in a product that I

00:00:29,279 --> 00:00:33,300
work on called sprint Lee which is a

00:00:30,990 --> 00:00:34,350
project management app we're hiring so

00:00:33,300 --> 00:00:37,079
if you want to talk about that let me

00:00:34,350 --> 00:00:39,660
know I'm also the author of Imhotep

00:00:37,079 --> 00:00:42,930
which is a tool that will take static

00:00:39,660 --> 00:00:44,969
analysis stuff like pilant or J's hint

00:00:42,930 --> 00:00:46,969
and pipe that into github code review

00:00:44,969 --> 00:00:52,440
comments and you can find me online

00:00:46,969 --> 00:00:54,870
under the name Justin Abrams so an

00:00:52,440 --> 00:00:57,809
overview of this talk we're gonna talk

00:00:54,870 --> 00:01:00,239
about Big O notation how I learned about

00:00:57,809 --> 00:01:05,430
it what it is how do you do it and then

00:01:00,239 --> 00:01:08,520
some wisdom and resources around them so

00:01:05,430 --> 00:01:11,369
to start off I worked for a design

00:01:08,520 --> 00:01:15,600
agency in New York City several years

00:01:11,369 --> 00:01:17,909
ago and this was my first career job

00:01:15,600 --> 00:01:19,650
that where I was really working on

00:01:17,909 --> 00:01:21,810
things that were important and they were

00:01:19,650 --> 00:01:24,509
important to think to people and it was

00:01:21,810 --> 00:01:27,600
a product that mattered before that I

00:01:24,509 --> 00:01:30,360
worked for a newspaper and the the

00:01:27,600 --> 00:01:32,640
things that we did were very quick to

00:01:30,360 --> 00:01:34,799
start they had a limited shelf life and

00:01:32,640 --> 00:01:36,090
then they kind of trailed off and no one

00:01:34,799 --> 00:01:38,540
really it didn't really matter anymore

00:01:36,090 --> 00:01:40,650
so examples of that might be like

00:01:38,540 --> 00:01:43,320
someone's writing an article about AIDS

00:01:40,650 --> 00:01:44,820
and in various counties and they want a

00:01:43,320 --> 00:01:46,140
visualization so you build it and then

00:01:44,820 --> 00:01:48,149
the article publishes and then three

00:01:46,140 --> 00:01:50,149
weeks later no one has ever no-one's

00:01:48,149 --> 00:01:54,720
gonna visit that site anymore

00:01:50,149 --> 00:01:59,420
so I did some work for a ticket seller

00:01:54,720 --> 00:02:01,740
they sold Broadway tickets and my

00:01:59,420 --> 00:02:03,810
responsibilities were to kind of build

00:02:01,740 --> 00:02:06,090
the entire thing from kind of an

00:02:03,810 --> 00:02:10,830
architectural standpoint and I did the

00:02:06,090 --> 00:02:13,860
schema design and the to give an example

00:02:10,830 --> 00:02:16,800
of what a sane data model looks like

00:02:13,860 --> 00:02:19,080
you can see here you have a module and

00:02:16,800 --> 00:02:22,080
this module has dependencies on other

00:02:19,080 --> 00:02:25,380
modules and there are very clearly

00:02:22,080 --> 00:02:28,820
defined relationships and then here was

00:02:25,380 --> 00:02:30,930
our data model there was an erroneous

00:02:28,820 --> 00:02:32,700
requirement laid out which is that

00:02:30,930 --> 00:02:37,560
everything had to be related to

00:02:32,700 --> 00:02:39,330
everything which is unfortunate because

00:02:37,560 --> 00:02:41,430
we didn't just have three objects in our

00:02:39,330 --> 00:02:44,490
data model we had a lot of objects in

00:02:41,430 --> 00:02:46,110
our data model and and the unfortunate

00:02:44,490 --> 00:02:49,100
thing about this is that it was really

00:02:46,110 --> 00:02:51,090
slow when it came time to launch and

00:02:49,100 --> 00:02:53,209
this kind of represented one of the

00:02:51,090 --> 00:02:55,770
biggest failings I've had in my career

00:02:53,209 --> 00:02:58,020
and it and it boiled down to not

00:02:55,770 --> 00:03:00,270
questioning the requirements given and

00:02:58,020 --> 00:03:02,459
not really understanding the

00:03:00,270 --> 00:03:07,560
implications of what I was doing

00:03:02,459 --> 00:03:10,380
a co-worker of mine Igor came to the

00:03:07,560 --> 00:03:13,920
project after it was deemed very slow

00:03:10,380 --> 00:03:15,330
and he said he was like oh of course

00:03:13,920 --> 00:03:18,269
this is slow you're doing in plus one

00:03:15,330 --> 00:03:22,080
selects and I was like oh that sounds

00:03:18,269 --> 00:03:24,290
bad what is n plus one selects and so

00:03:22,080 --> 00:03:27,989
this is what n plus one selects are

00:03:24,290 --> 00:03:30,840
we're going to get a list of posts for

00:03:27,989 --> 00:03:32,519
this website then we're going to loop

00:03:30,840 --> 00:03:36,299
through those and then fetch them for

00:03:32,519 --> 00:03:38,459
that from the database so we make a

00:03:36,299 --> 00:03:40,709
sequel query to get some post IDs and

00:03:38,459 --> 00:03:42,570
then for each one of those we make

00:03:40,709 --> 00:03:44,670
another sequel query to get the rest of

00:03:42,570 --> 00:03:46,950
the information and this kind of this

00:03:44,670 --> 00:03:51,420
happened due to have abusing Django

00:03:46,950 --> 00:03:53,790
foreign generic foreign keys but this

00:03:51,420 --> 00:03:56,610
was kind of my first introduction into

00:03:53,790 --> 00:03:59,250
this like n plus one kind of syntax that

00:03:56,610 --> 00:04:01,620
I had never really heard before so I had

00:03:59,250 --> 00:04:03,420
a few questions which is how did I not

00:04:01,620 --> 00:04:05,040
know this how did I miss this thing how

00:04:03,420 --> 00:04:06,390
did he go or know about in plus one

00:04:05,040 --> 00:04:08,280
selects and I had never heard of n plus

00:04:06,390 --> 00:04:09,530
one selects and then how can I make sure

00:04:08,280 --> 00:04:13,620
this never happens again

00:04:09,530 --> 00:04:15,780
like I had it was very interesting

00:04:13,620 --> 00:04:21,780
because it identified a gap in high

00:04:15,780 --> 00:04:23,930
knowledge and so I guess that that begs

00:04:21,780 --> 00:04:26,610
the question of what is Big O notation

00:04:23,930 --> 00:04:27,630
well Big O notation describes limiting

00:04:26,610 --> 00:04:29,700
behavior

00:04:27,630 --> 00:04:31,860
as a function tends toward infinity

00:04:29,700 --> 00:04:33,720
using simpler functions which means

00:04:31,860 --> 00:04:35,610
absolutely knowing nothing to anyone

00:04:33,720 --> 00:04:39,270
unless you already know everything about

00:04:35,610 --> 00:04:43,800
Big O notation so Big O notation is how

00:04:39,270 --> 00:04:46,530
programmers talk about how the two

00:04:43,800 --> 00:04:50,190
pieces of code relate in terms of

00:04:46,530 --> 00:04:52,890
performance and this this was really

00:04:50,190 --> 00:04:56,310
important when I went to my interview at

00:04:52,890 --> 00:05:00,390
Google so in prepping for this interview

00:04:56,310 --> 00:05:02,130
there was a study list I had needed to

00:05:00,390 --> 00:05:04,050
know data structures and algorithms and

00:05:02,130 --> 00:05:06,330
system design and Java stuff and

00:05:04,050 --> 00:05:09,060
concurrency stuff and you'll know this

00:05:06,330 --> 00:05:12,780
that Big O is not on this list these are

00:05:09,060 --> 00:05:14,550
the Big O items no one no one sits you

00:05:12,780 --> 00:05:15,840
down in your interview and says here's a

00:05:14,550 --> 00:05:18,840
function what is the Big O notation of

00:05:15,840 --> 00:05:22,500
this function it's kind of assumed

00:05:18,840 --> 00:05:24,840
knowledge for these topics and this is

00:05:22,500 --> 00:05:28,650
kind of how you express your knowledge

00:05:24,840 --> 00:05:31,110
in those topics and so it's it's

00:05:28,650 --> 00:05:32,400
probably worth talking about a brief

00:05:31,110 --> 00:05:34,650
overview of data structures and

00:05:32,400 --> 00:05:37,560
algorithms a data structure is how you

00:05:34,650 --> 00:05:41,480
structure your data it is kind of how

00:05:37,560 --> 00:05:44,310
you organize things and and kind of an

00:05:41,480 --> 00:05:45,990
oversimplification would be if Python

00:05:44,310 --> 00:05:47,280
didn't give you lists and sets and

00:05:45,990 --> 00:05:50,280
dictionaries and it only gave you object

00:05:47,280 --> 00:05:53,880
how would you build lists and sets and

00:05:50,280 --> 00:05:57,870
all that other stuff that how is his

00:05:53,880 --> 00:06:00,810
data structures and algorithms are a

00:05:57,870 --> 00:06:05,490
step-by-step procedure for doing a thing

00:06:00,810 --> 00:06:06,600
so a an algorithm for making it peanut

00:06:05,490 --> 00:06:08,370
butter and jelly sandwich would be

00:06:06,600 --> 00:06:10,010
arrest just the recipe it's the

00:06:08,370 --> 00:06:13,470
instruction set of how you do a thing

00:06:10,010 --> 00:06:14,940
and algorithm is also one of those words

00:06:13,470 --> 00:06:16,310
that makes you sound super fancy to

00:06:14,940 --> 00:06:20,940
people who don't know that

00:06:16,310 --> 00:06:23,040
it just means recipe so let's talk about

00:06:20,940 --> 00:06:25,260
Big O notation this is kind of what Big

00:06:23,040 --> 00:06:29,940
O notation looks like there is an O

00:06:25,260 --> 00:06:31,800
function it is a Big O and it has a few

00:06:29,940 --> 00:06:35,640
things that can go inside the

00:06:31,800 --> 00:06:37,919
parenthesis so the types would be go

00:06:35,640 --> 00:06:40,940
that there are R oh of 1 which is how

00:06:37,919 --> 00:06:40,940
you read this o of 1

00:06:41,000 --> 00:06:47,750
which is called constant time o of log n

00:06:44,390 --> 00:06:50,120
is logarithmic o of n is linear o of N

00:06:47,750 --> 00:06:53,300
squared is quadratic and O in factorial

00:06:50,120 --> 00:06:55,940
is factorial and there are more than

00:06:53,300 --> 00:06:58,490
this these are the main ones that you're

00:06:55,940 --> 00:07:00,620
most likely to see I'm probably not

00:06:58,490 --> 00:07:04,010
going to talk about o if n factorial

00:07:00,620 --> 00:07:06,140
because it's a little you see it but

00:07:04,010 --> 00:07:08,000
it's not super easy to graph and I have

00:07:06,140 --> 00:07:10,780
a few graphs in here that make things

00:07:08,000 --> 00:07:12,890
make sense and if you're your math class

00:07:10,780 --> 00:07:15,410
was a little long ago like it has been

00:07:12,890 --> 00:07:18,380
for me you might not quite remember what

00:07:15,410 --> 00:07:23,420
these things look like so this is a

00:07:18,380 --> 00:07:25,280
graph of the various complexities which

00:07:23,420 --> 00:07:27,230
is kind of what you talk one time

00:07:25,280 --> 00:07:30,740
complexities which is kind of how we

00:07:27,230 --> 00:07:32,570
talk about Big O things so N squared is

00:07:30,740 --> 00:07:36,140
the line in blue that goes up really

00:07:32,570 --> 00:07:39,020
quickly o of N is red and kind of

00:07:36,140 --> 00:07:42,560
increases in a flat line to open to the

00:07:39,020 --> 00:07:45,919
right the green line that you can see

00:07:42,560 --> 00:07:49,400
just above the the orange line is log N

00:07:45,919 --> 00:07:52,610
and it doesn't it's it's it grows faster

00:07:49,400 --> 00:07:54,740
than constant time which is the yellow

00:07:52,610 --> 00:07:57,110
line but not by a lot and certainly not

00:07:54,740 --> 00:07:59,450
by as fast as everything else does so

00:07:57,110 --> 00:08:01,460
the axis actually is being involved here

00:07:59,450 --> 00:08:06,200
our time is the y-axis how long

00:08:01,460 --> 00:08:08,200
something takes and the x axis is the

00:08:06,200 --> 00:08:12,410
number of items input into the function

00:08:08,200 --> 00:08:14,390
so if you had five items and you gave it

00:08:12,410 --> 00:08:17,540
to a function that was oh of N squared

00:08:14,390 --> 00:08:19,250
which is the blue line you know you kind

00:08:17,540 --> 00:08:22,729
of track this up and you can see that

00:08:19,250 --> 00:08:25,040
it's maybe 35 units of time however we

00:08:22,729 --> 00:08:27,440
want to measure time but if you were to

00:08:25,040 --> 00:08:30,080
pass it to the same function on the on

00:08:27,440 --> 00:08:32,360
the orange it would be one unit because

00:08:30,080 --> 00:08:36,409
it is a constant amount of time no

00:08:32,360 --> 00:08:39,680
matter how many items you have so let's

00:08:36,409 --> 00:08:44,990
kind of go through some examples of

00:08:39,680 --> 00:08:47,810
these time complexities this is an oo of

00:08:44,990 --> 00:08:51,890
one function it is fetching something

00:08:47,810 --> 00:08:57,620
from a list from from an array

00:08:51,890 --> 00:08:59,780
by index and the reason this is constant

00:08:57,620 --> 00:09:04,310
time is because it doesn't matter if the

00:08:59,780 --> 00:09:06,170
index into the array is five items big

00:09:04,310 --> 00:09:08,480
and the item in the array is five items

00:09:06,170 --> 00:09:11,030
big or if it's 500 items big it takes

00:09:08,480 --> 00:09:13,100
the same amount of time and this this

00:09:11,030 --> 00:09:15,140
makes a little sense when you have a

00:09:13,100 --> 00:09:17,270
kind of conceptual understanding of how

00:09:15,140 --> 00:09:21,110
arrays work which is that they're all

00:09:17,270 --> 00:09:24,940
memory offsets in to some block of

00:09:21,110 --> 00:09:28,160
memory so to say and going from you know

00:09:24,940 --> 00:09:30,080
block 18 to block 20 is no different

00:09:28,160 --> 00:09:33,140
it's just it's the same it's the same

00:09:30,080 --> 00:09:39,830
physical operation in the machine

00:09:33,140 --> 00:09:42,820
oh if n is kind of canonically a for

00:09:39,830 --> 00:09:45,680
loop for loops mean it's an O of n thing

00:09:42,820 --> 00:09:47,870
or that that instruction is o of n where

00:09:45,680 --> 00:09:51,080
n is the size of the thing you're

00:09:47,870 --> 00:09:53,960
looping over so this is a function that

00:09:51,080 --> 00:09:57,950
checks whether something is contained in

00:09:53,960 --> 00:09:59,690
an unordered list so we loop over the

00:09:57,950 --> 00:10:01,790
list if the thing we're looking for is

00:09:59,690 --> 00:10:04,190
the thing that we have found in this

00:10:01,790 --> 00:10:07,220
current iteration of the loop we do

00:10:04,190 --> 00:10:09,610
return true otherwise we return false so

00:10:07,220 --> 00:10:11,930
you might be asking i see the for loop

00:10:09,610 --> 00:10:13,730
but wait a second there's other stuff

00:10:11,930 --> 00:10:15,320
going on in that function besides just a

00:10:13,730 --> 00:10:18,950
for loop what happened all that are we

00:10:15,320 --> 00:10:23,180
not counting it so let's let's kind of

00:10:18,950 --> 00:10:25,370
break down this function as I said the

00:10:23,180 --> 00:10:29,980
for loop means it's an O of n operation

00:10:25,370 --> 00:10:32,870
where n is the size of the LST variable

00:10:29,980 --> 00:10:35,120
checking whether an entry is equal to

00:10:32,870 --> 00:10:37,370
the item we're looking for is constant

00:10:35,120 --> 00:10:39,110
time you can kind of think of this as

00:10:37,370 --> 00:10:42,800
comparing two numbers that's the

00:10:39,110 --> 00:10:45,140
simplest version detecting whether one

00:10:42,800 --> 00:10:47,060
is equal to two should be the same speed

00:10:45,140 --> 00:10:49,730
as checking whether one is equal to two

00:10:47,060 --> 00:10:53,080
thousand so it's not dependent on the

00:10:49,730 --> 00:10:57,940
size of the thing you're giving it and

00:10:53,080 --> 00:10:59,960
then the return true is a constant thing

00:10:57,940 --> 00:11:04,940
it doesn't matter what you return it's

00:10:59,960 --> 00:11:08,240
the same same speed so that gives us Oh

00:11:04,940 --> 00:11:11,300
times o of 1 plus o of 1 right so we add

00:11:08,240 --> 00:11:14,090
up all those those things so the

00:11:11,300 --> 00:11:17,990
question the next question is why don't

00:11:14,090 --> 00:11:21,860
we just say o of n times o of 1 plus o

00:11:17,990 --> 00:11:25,520
of 1 and the answer is that that's

00:11:21,860 --> 00:11:27,290
really painful to say let's just say o

00:11:25,520 --> 00:11:33,200
that functions o of n times o of 1 plus

00:11:27,290 --> 00:11:35,240
L of 1 and and for a better answer we

00:11:33,200 --> 00:11:38,210
have to go back to a kind of the formal

00:11:35,240 --> 00:11:40,790
definition and if I were to translate

00:11:38,210 --> 00:11:43,910
that into non Matthew terms what that

00:11:40,790 --> 00:11:46,010
means is that if we plot our function we

00:11:43,910 --> 00:11:48,170
can also plot another function which is

00:11:46,010 --> 00:11:53,540
M which is some constant that we make up

00:11:48,170 --> 00:11:59,360
times the Big O of the function and all

00:11:53,540 --> 00:12:02,270
values to the right of that function we

00:11:59,360 --> 00:12:06,020
should should be under so we have two

00:12:02,270 --> 00:12:08,720
lines and those lines should never cross

00:12:06,020 --> 00:12:10,690
going further right after a certain

00:12:08,720 --> 00:12:13,600
point and I'll kind of break this down

00:12:10,690 --> 00:12:17,660
so the question is how do we plot Big O

00:12:13,600 --> 00:12:19,370
okay so we have Big O of n times o of 1

00:12:17,660 --> 00:12:25,040
plus o of 1 and we're going to plot

00:12:19,370 --> 00:12:27,670
something so o of n always means X in

00:12:25,040 --> 00:12:31,220
our graphing and that's because it

00:12:27,670 --> 00:12:33,890
increases over time and we want to see

00:12:31,220 --> 00:12:35,600
how this function changes it's the

00:12:33,890 --> 00:12:43,700
amount of time it takes changes over

00:12:35,600 --> 00:12:45,770
time so we substitute X for o of n o of

00:12:43,700 --> 00:12:47,000
1 is a constant its constant times so

00:12:45,770 --> 00:12:49,190
you can pick any constant

00:12:47,000 --> 00:12:53,570
I picked 5 and 9 because they make the

00:12:49,190 --> 00:12:56,720
graphs easier so now we have the two

00:12:53,570 --> 00:12:58,220
plot of x times 5 plus 9 which looks a

00:12:56,720 --> 00:13:04,070
bit like that just a straight line going

00:12:58,220 --> 00:13:08,420
to the right so if we were to if this is

00:13:04,070 --> 00:13:12,670
truly oh of N or then we should be able

00:13:08,420 --> 00:13:17,040
to multiply of n times some constant and

00:13:12,670 --> 00:13:20,820
this blue line should stay under the new

00:13:17,040 --> 00:13:22,620
and so here is plotting with the

00:13:20,820 --> 00:13:26,160
constant of 10 so this is a line

00:13:22,620 --> 00:13:27,900
plotting 10 X and you can see that the

00:13:26,160 --> 00:13:33,210
blue line is never going to cross that

00:13:27,900 --> 00:13:35,760
red line after about three so we can say

00:13:33,210 --> 00:13:41,220
that this function is o of n for all

00:13:35,760 --> 00:13:44,820
values greater than 3 so this that's how

00:13:41,220 --> 00:13:46,710
we know that o of n is correct so you

00:13:44,820 --> 00:13:50,310
might be curious of what some counter

00:13:46,710 --> 00:13:53,310
examples to this are so let's ask the

00:13:50,310 --> 00:13:57,150
question is this o of one o of one means

00:13:53,310 --> 00:13:58,589
or a constant time right constant time

00:13:57,150 --> 00:14:00,540
means that we should be able to plot

00:13:58,589 --> 00:14:05,100
some constant number that stays the same

00:14:00,540 --> 00:14:07,410
regardless of the x value where here X

00:14:05,100 --> 00:14:11,190
is equal to 15 so we're plotting the the

00:14:07,410 --> 00:14:15,300
line at 15 and you can see that the blue

00:14:11,190 --> 00:14:19,980
line is in fact above this red line and

00:14:15,300 --> 00:14:21,830
and because of that the we know that

00:14:19,980 --> 00:14:26,430
this is not a constant time function

00:14:21,830 --> 00:14:29,130
okay so the next question is is it the

00:14:26,430 --> 00:14:32,040
next higher complexity level is it o of

00:14:29,130 --> 00:14:34,260
N squared and you can see here for

00:14:32,040 --> 00:14:35,490
values greater than 7 that blue line is

00:14:34,260 --> 00:14:37,380
never going to cross this red line

00:14:35,490 --> 00:14:41,250
because that red line shoots up very

00:14:37,380 --> 00:14:43,980
quickly and so this is plotting X

00:14:41,250 --> 00:14:45,930
squares the red line and you can see

00:14:43,980 --> 00:14:47,400
that yeah actually four for values

00:14:45,930 --> 00:14:51,390
greater than 6

00:14:47,400 --> 00:14:54,660
this will never cross so it is true that

00:14:51,390 --> 00:14:57,209
this X times 5 plus 9 is an O of N

00:14:54,660 --> 00:15:00,600
squared operation it just also happens

00:14:57,209 --> 00:15:04,310
to be an O of n operation so that's to

00:15:00,600 --> 00:15:07,260
say that it is it is true to say that

00:15:04,310 --> 00:15:09,860
something is a higher degree of

00:15:07,260 --> 00:15:12,690
complexity it's just not the best answer

00:15:09,860 --> 00:15:15,089
so that would be like saying the number

00:15:12,690 --> 00:15:17,970
10 is greater than 5 yes but it's also

00:15:15,089 --> 00:15:23,490
greater than 7 and 9 it doesn't make any

00:15:17,970 --> 00:15:25,680
one less true but kind of gives you you

00:15:23,490 --> 00:15:27,540
you really want the the lower lowest

00:15:25,680 --> 00:15:29,360
number that you can that you can choose

00:15:27,540 --> 00:15:32,670
there

00:15:29,360 --> 00:15:35,579
so Big O is an approximation of

00:15:32,670 --> 00:15:39,139
algorithmic complexity which is which is

00:15:35,579 --> 00:15:41,610
to say that Big O is kind of how you

00:15:39,139 --> 00:15:43,380
approximate how complex something is or

00:15:41,610 --> 00:15:47,310
how much how much time or how many

00:15:43,380 --> 00:15:49,440
operations it will take so let's get

00:15:47,310 --> 00:15:51,630
back to the code we still have the same

00:15:49,440 --> 00:15:54,540
code as before but what if the list is

00:15:51,630 --> 00:15:56,279
empty it's that if the list is empty

00:15:54,540 --> 00:15:58,980
then we're going to return we're gonna

00:15:56,279 --> 00:16:00,540
return false immediately but Big O

00:15:58,980 --> 00:16:02,880
notation deals with the worst-case

00:16:00,540 --> 00:16:04,410
performance of something even if it's

00:16:02,880 --> 00:16:09,690
empty we want to know how bad it could

00:16:04,410 --> 00:16:12,149
be if it had 10 items in it and there

00:16:09,690 --> 00:16:14,490
are other Big O flavors for you know

00:16:12,149 --> 00:16:16,860
that don't deal with the best the worst

00:16:14,490 --> 00:16:18,660
case but we're not going to cover that

00:16:16,860 --> 00:16:23,120
because it's it's not really brought up

00:16:18,660 --> 00:16:23,120
as often in any kind of practical use

00:16:23,250 --> 00:16:30,440
ok so transitioning into oo of log n

00:16:27,019 --> 00:16:33,690
this is logarithmic time and a good

00:16:30,440 --> 00:16:35,220
we're gonna use kind of the same thing

00:16:33,690 --> 00:16:36,360
as before where we're gonna find

00:16:35,220 --> 00:16:38,069
something in a list but instead of it

00:16:36,360 --> 00:16:41,310
being an unsorted list we're going to

00:16:38,069 --> 00:16:43,079
sort the list and that allows for more

00:16:41,310 --> 00:16:46,290
efficient lookup to this sort of thing

00:16:43,079 --> 00:16:48,540
and let's kind of discuss why so we have

00:16:46,290 --> 00:16:50,699
this list of 10 integers and we want to

00:16:48,540 --> 00:16:52,680
see if the number 4 is in there how

00:16:50,699 --> 00:16:55,529
binary search works is we choose a

00:16:52,680 --> 00:16:57,180
center point in our list and then say is

00:16:55,529 --> 00:17:00,240
4 equal to 6

00:16:57,180 --> 00:17:01,440
well no 4 is not equal to 6 so because

00:17:00,240 --> 00:17:04,230
this is sorted we can rule out

00:17:01,440 --> 00:17:07,740
everything at an index higher than the

00:17:04,230 --> 00:17:09,630
index 6 was n so we can say that you

00:17:07,740 --> 00:17:11,520
know everything bigger than 6 is not

00:17:09,630 --> 00:17:17,669
going to have 4 in it because it's all

00:17:11,520 --> 00:17:20,459
sorted so we split again and we see is 4

00:17:17,669 --> 00:17:23,130
equal to 3 no it's not and so that

00:17:20,459 --> 00:17:26,520
leaves us two numbers and we check us 4

00:17:23,130 --> 00:17:28,799
equal to 4 and it is so yeah this is

00:17:26,520 --> 00:17:31,230
logarithmic because for every iteration

00:17:28,799 --> 00:17:34,350
this sample size that we have to operate

00:17:31,230 --> 00:17:38,640
on is a fraction of the size if that

00:17:34,350 --> 00:17:44,070
makes sense ok so the next one of these

00:17:38,640 --> 00:17:48,169
is o of N squared this will make a list

00:17:44,070 --> 00:17:52,260
of pairs in from an from a list

00:17:48,169 --> 00:17:54,870
so this is a doubly nested for loop and

00:17:52,260 --> 00:17:59,220
these are the Big O this is the Big O

00:17:54,870 --> 00:18:03,960
for that so as I said for loops are o of

00:17:59,220 --> 00:18:06,270
N and generating a list is we'll call

00:18:03,960 --> 00:18:11,280
that O of 1 and and returning of 1 and

00:18:06,270 --> 00:18:14,190
appending of one the once we add all

00:18:11,280 --> 00:18:16,620
these up kind of in algebra terms we get

00:18:14,190 --> 00:18:18,809
oh of 1 plus o of n times over then

00:18:16,620 --> 00:18:21,390
times o of 1 plus o of 1 which is again

00:18:18,809 --> 00:18:24,840
a pain to say so let's break this down a

00:18:21,390 --> 00:18:28,020
little bit so we can route let's

00:18:24,840 --> 00:18:29,970
rearrange this this Plus this plus of 1

00:18:28,020 --> 00:18:32,100
and move that to the end it makes things

00:18:29,970 --> 00:18:33,510
a little easier

00:18:32,100 --> 00:18:36,419
and then we'll plug in some numbers like

00:18:33,510 --> 00:18:38,159
we did before where O's of n become X's

00:18:36,419 --> 00:18:43,799
and then constants become numbers that

00:18:38,159 --> 00:18:46,200
we decide arbitrarily and that when once

00:18:43,799 --> 00:18:50,429
we simplify this this reduces to x

00:18:46,200 --> 00:18:52,830
squared plus 29 okay so now let's plot x

00:18:50,429 --> 00:18:57,120
squared plus 29 it looks kind of like

00:18:52,830 --> 00:18:59,970
this so if this is truly o of N squared

00:18:57,120 --> 00:19:02,700
we should be able to plot some constant

00:18:59,970 --> 00:19:05,400
times N squared and this function will

00:19:02,700 --> 00:19:08,850
never cross it so here we're plotting 10

00:19:05,400 --> 00:19:10,919
times x squared and you'll notice that

00:19:08,850 --> 00:19:14,610
the blue line will never cross this red

00:19:10,919 --> 00:19:18,809
line for values greater than 3 so this

00:19:14,610 --> 00:19:24,120
does in fact validate that this is an of

00:19:18,809 --> 00:19:28,110
n squared function so there are a few

00:19:24,120 --> 00:19:32,340
gotchas when it comes to to tracking the

00:19:28,110 --> 00:19:34,850
Big O of something and a big one is that

00:19:32,340 --> 00:19:39,590
the Big O of function might not matter

00:19:34,850 --> 00:19:42,630
if you have an O of N squared operation

00:19:39,590 --> 00:19:45,270
and you're the the size of the list that

00:19:42,630 --> 00:19:49,890
you're going to pass something is 5

00:19:45,270 --> 00:19:53,270
items 5 squared is 25 right so you're

00:19:49,890 --> 00:19:57,350
gonna do 25 operations

00:19:53,270 --> 00:20:00,740
the computers are pretty fast and 25

00:19:57,350 --> 00:20:03,440
operations are basically instant and so

00:20:00,740 --> 00:20:07,640
for really small sample sizes this is

00:20:03,440 --> 00:20:09,380
not as it can it can just not matter

00:20:07,640 --> 00:20:12,100
like your computer might be fast enough

00:20:09,380 --> 00:20:16,340
that you can just ignore the Big O of

00:20:12,100 --> 00:20:18,110
another gotcha is that the theoretical

00:20:16,340 --> 00:20:21,620
speed of something is different than the

00:20:18,110 --> 00:20:23,240
actual speed of something and as we've

00:20:21,620 --> 00:20:24,940
said that constants you could just to

00:20:23,240 --> 00:20:27,380
pick a number when you're graphing it

00:20:24,940 --> 00:20:30,020
the reality is that those numbers might

00:20:27,380 --> 00:20:32,390
be really large and so you might have a

00:20:30,020 --> 00:20:34,370
constant that always takes 200,000

00:20:32,390 --> 00:20:35,779
operations to do something but it

00:20:34,370 --> 00:20:40,120
doesn't matter how big the list is it

00:20:35,779 --> 00:20:42,740
just always takes 200,000 operations and

00:20:40,120 --> 00:20:45,460
so you could have constant time

00:20:42,740 --> 00:20:48,799
operations that are slower than your

00:20:45,460 --> 00:20:50,929
your o N squared operations because as

00:20:48,799 --> 00:20:53,630
we said in a sample sizes five you have

00:20:50,929 --> 00:20:57,590
twenty-five operations it's dramatically

00:20:53,630 --> 00:21:01,760
less than 200,000 so these numbers in

00:20:57,590 --> 00:21:03,230
practicality might not pan out and the

00:21:01,760 --> 00:21:06,140
other thing is that this is probably not

00:21:03,230 --> 00:21:07,760
going to make your app faster a lot of

00:21:06,140 --> 00:21:11,779
the the performance bottlenecks that

00:21:07,760 --> 00:21:14,330
come in in most applications are kind of

00:21:11,779 --> 00:21:15,950
tied to input/output operations so like

00:21:14,330 --> 00:21:18,590
speaking to a database writing to a file

00:21:15,950 --> 00:21:23,899
system those things will will often

00:21:18,590 --> 00:21:26,899
dwarf the the speed of any particular

00:21:23,899 --> 00:21:30,230
operation one exception of this is kind

00:21:26,899 --> 00:21:32,779
of CPU bound stuff and changing which

00:21:30,230 --> 00:21:34,750
data structures and algorithms are new

00:21:32,779 --> 00:21:36,799
user is probably gonna make that

00:21:34,750 --> 00:21:40,190
difference which is kind of where Big O

00:21:36,799 --> 00:21:42,049
comes in and while this is not going to

00:21:40,190 --> 00:21:44,270
make your app faster it is going to make

00:21:42,049 --> 00:21:46,250
your learning easier and it's going to

00:21:44,270 --> 00:21:47,659
make especially as you get into data

00:21:46,250 --> 00:21:50,149
structures and algorithms and that

00:21:47,659 --> 00:21:52,460
aspect and it's also going to make your

00:21:50,149 --> 00:21:55,880
code review criticisms more articulate

00:21:52,460 --> 00:21:58,070
so you can say that this is this is bad

00:21:55,880 --> 00:21:59,990
code and this is bad code because this

00:21:58,070 --> 00:22:01,970
is an open squared operation and you can

00:21:59,990 --> 00:22:05,250
instead use an O of n operation which is

00:22:01,970 --> 00:22:08,040
better so

00:22:05,250 --> 00:22:12,750
let's look at some resources that you

00:22:08,040 --> 00:22:15,390
can look at for continuing this is the

00:22:12,750 --> 00:22:19,370
algorithm design manual by skeena and it

00:22:15,390 --> 00:22:23,550
is a fantastic book it is the first

00:22:19,370 --> 00:22:25,020
quarter of the book is a an overview of

00:22:23,550 --> 00:22:28,200
Big O from a more mathematical

00:22:25,020 --> 00:22:30,120
perspective data structures and

00:22:28,200 --> 00:22:32,610
algorithms and the last three quarters

00:22:30,120 --> 00:22:35,430
of the book are so you have this problem

00:22:32,610 --> 00:22:36,990
you want to sort a list of integers well

00:22:35,430 --> 00:22:39,140
here are some ways you can do that these

00:22:36,990 --> 00:22:41,880
are the runtime complexities of them Oh

00:22:39,140 --> 00:22:43,110
are your numbers all less than 100 maybe

00:22:41,880 --> 00:22:44,490
you want to use this other algorithm

00:22:43,110 --> 00:22:46,590
instead which is a little faster if you

00:22:44,490 --> 00:22:48,630
have that one special case this is a

00:22:46,590 --> 00:22:52,500
really great book and I recommend

00:22:48,630 --> 00:22:56,130
everyone take a look there is a Coursera

00:22:52,500 --> 00:22:59,130
course run by Stanford called algorithms

00:22:56,130 --> 00:23:03,320
design and analysis and they go over a

00:22:59,130 --> 00:23:07,110
lot of this graphing things and how to

00:23:03,320 --> 00:23:12,840
kind of how to do that and it's it's a

00:23:07,110 --> 00:23:14,520
good course it has a lot of it has a lot

00:23:12,840 --> 00:23:15,870
of math stuff in there so when I was

00:23:14,520 --> 00:23:17,610
going through this course I also had to

00:23:15,870 --> 00:23:20,730
kind of read up on the math so it's a

00:23:17,610 --> 00:23:23,400
little slower but it's still a really

00:23:20,730 --> 00:23:24,720
great resource I'm also in the process

00:23:23,400 --> 00:23:27,740
of writing a book called computer

00:23:24,720 --> 00:23:30,840
science for self-taught programmers so

00:23:27,740 --> 00:23:34,110
that might be of use it's not released

00:23:30,840 --> 00:23:36,480
yet but if you message me I'm happy to

00:23:34,110 --> 00:23:39,480
let you know when it's when it'll be

00:23:36,480 --> 00:23:41,250
available so you might be asking how do

00:23:39,480 --> 00:23:43,050
I write my code differently now the

00:23:41,250 --> 00:23:43,920
answer is that knowing Big O doesn't

00:23:43,050 --> 00:23:47,130
make you write in your code any

00:23:43,920 --> 00:23:49,260
differently because let's face it were

00:23:47,130 --> 00:23:50,460
mostly coders in here and if you needed

00:23:49,260 --> 00:23:53,030
to know it to write your code better

00:23:50,460 --> 00:23:56,010
you'd probably already know it by now

00:23:53,030 --> 00:23:57,750
but the thing that is this is useful for

00:23:56,010 --> 00:23:59,250
is it's the baseline knowledge for data

00:23:57,750 --> 00:24:00,720
structures and algorithms and data

00:23:59,250 --> 00:24:03,030
structures and algorithms will make you

00:24:00,720 --> 00:24:04,950
write your code differently and also

00:24:03,030 --> 00:24:07,800
this is a communication tool similar to

00:24:04,950 --> 00:24:09,690
design patterns which you informally use

00:24:07,800 --> 00:24:10,650
but don't know what you're using you

00:24:09,690 --> 00:24:13,860
don't know what to call them it's a

00:24:10,650 --> 00:24:15,240
vocabulary that you can use to make your

00:24:13,860 --> 00:24:17,370
life easier in communication with other

00:24:15,240 --> 00:24:19,620
programmers better

00:24:17,370 --> 00:24:21,030
so to kind of recap big-oh is useful in

00:24:19,620 --> 00:24:24,630
communicating about the complexity of

00:24:21,030 --> 00:24:28,710
your code it is bit just basic algorithm

00:24:24,630 --> 00:24:30,900
basic arithmetic and algebra it's used

00:24:28,710 --> 00:24:33,090
in talking about algorithms and data

00:24:30,900 --> 00:24:37,950
structures and it's not as hard as it

00:24:33,090 --> 00:24:40,290
originally sounds so thanks I'm Justin

00:24:37,950 --> 00:24:42,420
if you want to hear more about this book

00:24:40,290 --> 00:24:44,460
I'm writing or Imhotep or a quick left

00:24:42,420 --> 00:24:45,750
email me tweet me find me at this

00:24:44,460 --> 00:25:24,510
conference and I'd love to talk to you

00:24:45,750 --> 00:25:26,400
about it thank you okay so I'll answer

00:25:24,510 --> 00:25:29,670
your second question first which is how

00:25:26,400 --> 00:25:32,429
different is an login compared to n or

00:25:29,670 --> 00:25:39,240
login so if you remember the graph from

00:25:32,429 --> 00:25:45,990
the beginning which lets go back there n

00:25:39,240 --> 00:25:47,820
log n is n times log in so n is this red

00:25:45,990 --> 00:25:49,320
line going up into the right login is

00:25:47,820 --> 00:25:53,429
this green line that barely increases

00:25:49,320 --> 00:25:57,350
above constant so it's a little slower

00:25:53,429 --> 00:26:01,130
than it's as the the difference between

00:25:57,350 --> 00:26:04,140
N and n log n is the difference between

00:26:01,130 --> 00:26:07,260
this constant time orange line and the

00:26:04,140 --> 00:26:09,020
login right so it's it's actually n

00:26:07,260 --> 00:26:11,520
Times log n

00:26:09,020 --> 00:26:13,710
it's almost n but not quite it's a

00:26:11,520 --> 00:26:16,290
little slower than that and the first

00:26:13,710 --> 00:26:19,010
question was how how do you know what

00:26:16,290 --> 00:26:19,010
numbers to plug in

00:26:28,880 --> 00:26:33,650
okay so the question is how do you know

00:26:31,110 --> 00:26:39,060
whether to add or multiply in in these

00:26:33,650 --> 00:26:40,230
items so this the Oh the first oh of one

00:26:39,060 --> 00:26:42,780
operation here

00:26:40,230 --> 00:26:46,530
if entry is equal two items is done once

00:26:42,780 --> 00:26:51,870
every time in for the for loop so it

00:26:46,530 --> 00:26:55,410
happens one time times the number of

00:26:51,870 --> 00:26:57,780
items in the list so you can kind of

00:26:55,410 --> 00:27:00,330
view everything that happens inside the

00:26:57,780 --> 00:27:03,090
for loop as being in parens and saying

00:27:00,330 --> 00:27:05,100
like this number the size of this for

00:27:03,090 --> 00:27:07,880
loop times the number the whatever is

00:27:05,100 --> 00:27:11,070
happening inside and then again if we

00:27:07,880 --> 00:27:15,750
kind of advanced up to the N squared

00:27:11,070 --> 00:27:19,350
operation we have this and this for loop

00:27:15,750 --> 00:27:23,490
with inside is another for loop so we

00:27:19,350 --> 00:27:26,880
have this n times n times 1 because the

00:27:23,490 --> 00:27:28,140
for I to enlist we do one constant time

00:27:26,880 --> 00:27:31,890
operation for each item in the list

00:27:28,140 --> 00:27:34,800
right and then we multiply that by the

00:27:31,890 --> 00:27:36,210
numbers in the first list so that's how

00:27:34,800 --> 00:27:44,580
you know where then where the numbers

00:27:36,210 --> 00:27:46,080
come in yes so that the beginning and

00:27:44,580 --> 00:27:48,560
the things that are just done one sir

00:27:46,080 --> 00:27:48,560
just added

00:27:53,039 --> 00:27:59,940
the Equality operator itself is another

00:27:56,080 --> 00:28:02,230
algorithm so that could have not a one

00:27:59,940 --> 00:28:04,270
operation time if it's a string for

00:28:02,230 --> 00:28:06,610
example it might be om or length or

00:28:04,270 --> 00:28:08,230
whatever that string is so your your

00:28:06,610 --> 00:28:10,059
integer example I think that's a 1 but

00:28:08,230 --> 00:28:11,940
for other object types that may not be

00:28:10,059 --> 00:28:16,090
yes that is true

00:28:11,940 --> 00:28:17,890
thank you I think it's probably worth

00:28:16,090 --> 00:28:22,289
mentioning that I'm by no means an

00:28:17,890 --> 00:28:24,580
expert in Big O notation this is kind of

00:28:22,289 --> 00:28:26,380
practical Big O there are there's a lot

00:28:24,580 --> 00:28:27,880
of intricacies and people who really

00:28:26,380 --> 00:28:30,130
know Big O well from a theoretical

00:28:27,880 --> 00:28:32,950
perspective might have some quibbles

00:28:30,130 --> 00:28:35,169
about how I presented it but the this is

00:28:32,950 --> 00:28:38,020
enough to pass a Google interview and

00:28:35,169 --> 00:28:40,740
enough to be able to speak about it in a

00:28:38,020 --> 00:28:44,890
way that makes you not seem crazy

00:28:40,740 --> 00:28:48,520
so hopefully that colors this a little

00:28:44,890 --> 00:28:49,900
bit better what's your favorite tool for

00:28:48,520 --> 00:28:54,490
actually evaluating the speed of the

00:28:49,900 --> 00:28:57,220
function IRC is my favorite tool and

00:28:54,490 --> 00:29:01,240
asking people I think this is this let's

00:28:57,220 --> 00:29:03,880
talk about it because it's I don't know

00:29:01,240 --> 00:29:07,510
of a tool that will just spit out the

00:29:03,880 --> 00:29:10,630
answer so it's a lot of looking at this

00:29:07,510 --> 00:29:13,510
and saying okay so pair list equals new

00:29:10,630 --> 00:29:15,010
array it's our new list what happens

00:29:13,510 --> 00:29:16,690
when we built a list well we probably

00:29:15,010 --> 00:29:19,179
allocate some memory and then that

00:29:16,690 --> 00:29:23,559
memory we allocate is probably the same

00:29:19,179 --> 00:29:28,179
size no matter what we do so I'll just

00:29:23,559 --> 00:29:30,700
call it constant and then so you you ask

00:29:28,179 --> 00:29:33,789
someone else and they'll tell you it

00:29:30,700 --> 00:29:35,320
really boils down to having a really

00:29:33,789 --> 00:29:37,059
solid understanding of what the heck

00:29:35,320 --> 00:29:38,230
your code is doing and so like when

00:29:37,059 --> 00:29:42,850
you're building an array what is

00:29:38,230 --> 00:29:44,440
actually happening the knowledge of data

00:29:42,850 --> 00:29:47,890
structures and algorithms help you

00:29:44,440 --> 00:29:51,669
because they will tell you oh you're

00:29:47,890 --> 00:29:53,679
doing an insert into an array well

00:29:51,669 --> 00:29:56,470
inserts into array have a worst-case

00:29:53,679 --> 00:29:57,549
performance of o of whatever and then

00:29:56,470 --> 00:29:58,690
you can say oh well I'm going to add

00:29:57,549 --> 00:30:00,280
something to an array let me look up in

00:29:58,690 --> 00:30:03,809
this data structures documentation

00:30:00,280 --> 00:30:03,809
what is the big notation of it

00:30:04,220 --> 00:30:09,100
let's give Justin another round of

00:30:06,259 --> 00:30:09,100

YouTube URL: https://www.youtube.com/watch?v=nEquiifH33w


