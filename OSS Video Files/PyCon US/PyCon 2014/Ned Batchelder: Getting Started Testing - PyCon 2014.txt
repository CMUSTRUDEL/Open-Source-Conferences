Title: Ned Batchelder: Getting Started Testing - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Ned Batchelder

If you've never written tests before, you probably know you *should*, but view the whole process as a bureaucratic paperwork nightmare to check off on your ready-to-ship checklist. This is the wrong way to approach testing. Tests are a solution to a problem that is important to you: does my code work? I'll show how Python tests are written, and why.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:03,610 --> 00:00:08,740
all right good afternoon everybody thank

00:00:06,700 --> 00:00:10,030
you for coming I'd like to introduce Ned

00:00:08,740 --> 00:00:18,580
Batchelder who's going to talk about

00:00:10,030 --> 00:00:22,090
getting started with testing hello

00:00:18,580 --> 00:00:23,980
everyone so this talk is starts at 1:40

00:00:22,090 --> 00:00:25,030
but the printed program says 1:55 so

00:00:23,980 --> 00:00:27,490
there's going to be some people coming

00:00:25,030 --> 00:00:29,440
in late and you can all make friends by

00:00:27,490 --> 00:00:31,210
piling up with them later and explaining

00:00:29,440 --> 00:00:33,460
what they missed in the first 15 minutes

00:00:31,210 --> 00:00:35,170
I'm going to have a lot of code on the

00:00:33,460 --> 00:00:37,030
screen it might be difficult to read

00:00:35,170 --> 00:00:38,800
your two options are to move forward or

00:00:37,030 --> 00:00:40,420
to use the bitly URL at the bottom which

00:00:38,800 --> 00:00:42,010
will take you to a page on my website

00:00:40,420 --> 00:00:43,720
which has all the slides in the code and

00:00:42,010 --> 00:00:47,860
even the text if you want to follow

00:00:43,720 --> 00:00:50,110
along so my goal here today is to show

00:00:47,860 --> 00:00:51,940
you a way to test your code I'm assuming

00:00:50,110 --> 00:00:54,880
that you have not written tests before

00:00:51,940 --> 00:00:57,130
and you are test curious let's say and

00:00:54,880 --> 00:00:59,079
that you want to figure out how to do it

00:00:57,130 --> 00:01:00,760
so I'm going to show you a way to test

00:00:59,079 --> 00:01:02,469
code there's lots of different ways to

00:01:00,760 --> 00:01:03,430
do it and if you talk to testing experts

00:01:02,469 --> 00:01:05,290
they're probably going to tell you that

00:01:03,430 --> 00:01:07,630
this is all the wrong way to do it maybe

00:01:05,290 --> 00:01:10,030
but this is a way to get you started I

00:01:07,630 --> 00:01:14,260
want to remove the mystery from writing

00:01:10,030 --> 00:01:18,310
tests first a little bit of philosophy

00:01:14,260 --> 00:01:20,369
about this why test testing automated

00:01:18,310 --> 00:01:23,740
testing is the best way we know to

00:01:20,369 --> 00:01:25,479
figure out if code works what I want to

00:01:23,740 --> 00:01:28,540
hope when I'm trying to show you in this

00:01:25,479 --> 00:01:30,250
talk is to look at tests as a solution

00:01:28,540 --> 00:01:32,200
to a very important problem that you

00:01:30,250 --> 00:01:33,580
have you have written some code and the

00:01:32,200 --> 00:01:35,500
problem you have is that you don't know

00:01:33,580 --> 00:01:36,159
if it works and tests are the solution

00:01:35,500 --> 00:01:39,520
to that problem

00:01:36,159 --> 00:01:41,560
some people approach tests as a checkoff

00:01:39,520 --> 00:01:43,240
on some sort of form that they need to

00:01:41,560 --> 00:01:44,740
complete before they can go home at the

00:01:43,240 --> 00:01:46,420
end of the day it's just sort of

00:01:44,740 --> 00:01:47,680
paperwork to get done and that's the

00:01:46,420 --> 00:01:49,650
wrong way to look at it you'll be very

00:01:47,680 --> 00:01:52,210
unhappy if you write tests that way

00:01:49,650 --> 00:01:53,950
testing is a very serious problem too

00:01:52,210 --> 00:01:55,450
it's a serious solution to a very

00:01:53,950 --> 00:01:57,880
serious problem and if you approach it

00:01:55,450 --> 00:01:59,560
as such as real engineering you'll get a

00:01:57,880 --> 00:02:01,570
lot of benefit from it it will save you

00:01:59,560 --> 00:02:03,610
time because you won't have to go back

00:02:01,570 --> 00:02:05,110
and fix problems later and it will give

00:02:03,610 --> 00:02:06,729
you better code because the tests will

00:02:05,110 --> 00:02:09,459
actually help you write better more

00:02:06,729 --> 00:02:11,950
modular code to begin with most

00:02:09,459 --> 00:02:13,450
importantly for me it removes fear from

00:02:11,950 --> 00:02:15,069
the development process if you've ever

00:02:13,450 --> 00:02:16,660
approached a large piece of code and had

00:02:15,069 --> 00:02:17,260
to change it and thought that you were

00:02:16,660 --> 00:02:19,930
certain

00:02:17,260 --> 00:02:20,760
 things up and make the code not

00:02:19,930 --> 00:02:23,019
work anymore

00:02:20,760 --> 00:02:25,030
testing is a way to make sure that you

00:02:23,019 --> 00:02:26,980
will not do that anymore it turns fear

00:02:25,030 --> 00:02:29,560
into boredom as a way that I've heard it

00:02:26,980 --> 00:02:31,150
put and the other way to think of it is

00:02:29,560 --> 00:02:33,340
that debugging is very hard but testing

00:02:31,150 --> 00:02:37,720
is easy so testing is a really good way

00:02:33,340 --> 00:02:39,760
to write really good code this is most

00:02:37,720 --> 00:02:42,659
developers first impression of testing

00:02:39,760 --> 00:02:45,190
they know that they should be doing it

00:02:42,659 --> 00:02:47,349
but they're not doing it and so they

00:02:45,190 --> 00:02:49,870
feel bad and and just like our poor

00:02:47,349 --> 00:02:51,909
developer here they are paralyzed by

00:02:49,870 --> 00:02:54,280
this feeling of inadequacy and

00:02:51,909 --> 00:02:56,470
uncertainty and doubt about what they

00:02:54,280 --> 00:03:00,329
should be doing and and and they feel

00:02:56,470 --> 00:03:02,980
bad and I don't want you to feel bad

00:03:00,329 --> 00:03:05,769
testing is hard it's a lot of work

00:03:02,980 --> 00:03:08,500
people and by people I mean you will not

00:03:05,769 --> 00:03:11,109
want to actually do it but it pays off

00:03:08,500 --> 00:03:12,819
so if you approach it as an engineering

00:03:11,109 --> 00:03:14,620
task to solve a problem that you really

00:03:12,819 --> 00:03:16,900
have and that you want to solve it will

00:03:14,620 --> 00:03:19,690
work out for you the reality is that the

00:03:16,900 --> 00:03:22,840
universe is a chaotic place so here's

00:03:19,690 --> 00:03:24,489
another poor developer she recognizes

00:03:22,840 --> 00:03:26,859
that the universe is full of chaos that

00:03:24,489 --> 00:03:28,389
is trying to attack her code okay

00:03:26,859 --> 00:03:30,250
you know how it is you write a program

00:03:28,389 --> 00:03:32,290
it seems to work great and a week later

00:03:30,250 --> 00:03:33,940
who knows what's happened to it

00:03:32,290 --> 00:03:35,859
some gremlin has gotten to it and it no

00:03:33,940 --> 00:03:38,099
longer works tests are the defense

00:03:35,859 --> 00:03:40,840
against this our developer here has a

00:03:38,099 --> 00:03:42,069
spear and a shield those are the tests

00:03:40,840 --> 00:03:44,230
that I'm going to teach you how to write

00:03:42,069 --> 00:03:46,000
them and use them alright our goal for

00:03:44,230 --> 00:03:50,739
this talk is to get these two developers

00:03:46,000 --> 00:03:52,209
happy and confident at the end so the

00:03:50,739 --> 00:03:54,010
road map there are three main parts that

00:03:52,209 --> 00:03:55,389
we're going to talk about today the

00:03:54,010 --> 00:03:57,010
first part was we're going to grow some

00:03:55,389 --> 00:03:59,470
tests organically we'll take some real

00:03:57,010 --> 00:04:01,150
code and we'll just start testing it's

00:03:59,470 --> 00:04:02,590
sort of ad hoc making up as we go along

00:04:01,150 --> 00:04:04,120
and talking about what we like and don't

00:04:02,590 --> 00:04:06,730
like about the way those tests are

00:04:04,120 --> 00:04:08,290
coming out and then we'll the main piece

00:04:06,730 --> 00:04:09,879
of the talk is talking about the unit

00:04:08,290 --> 00:04:12,129
test library in the standard mount in

00:04:09,879 --> 00:04:13,629
the standard library that is the way

00:04:12,129 --> 00:04:15,069
that the right way to write the tests

00:04:13,629 --> 00:04:17,799
and I'll show you the some bits and

00:04:15,069 --> 00:04:20,260
pieces of the unit test module and show

00:04:17,799 --> 00:04:22,120
you how to use them to build your tests

00:04:20,260 --> 00:04:24,580
and then I want to get into a kind of an

00:04:22,120 --> 00:04:26,050
advanced topic mocks which is something

00:04:24,580 --> 00:04:27,460
that you don't often see in a novice

00:04:26,050 --> 00:04:30,010
talk but it's a really really powerful

00:04:27,460 --> 00:04:31,979
tool for making your tests much more

00:04:30,010 --> 00:04:34,479
powerful and flex

00:04:31,979 --> 00:04:36,579
so let's start from first principles and

00:04:34,479 --> 00:04:38,139
grow some tests so here is our stock

00:04:36,579 --> 00:04:39,639
portfolio class and again if you can't

00:04:38,139 --> 00:04:42,849
read the code there is a bitly link at

00:04:39,639 --> 00:04:45,849
the bottom bitly slash PI test zero

00:04:42,849 --> 00:04:47,529
where you can see the code so this is a

00:04:45,849 --> 00:04:50,289
stock portfolio class it's very simple

00:04:47,529 --> 00:04:53,349
we define a class it keeps a list of

00:04:50,289 --> 00:04:54,969
tuples named shares price you can buy

00:04:53,349 --> 00:04:57,849
some shares for a certain amount which

00:04:54,969 --> 00:04:59,739
will append that stock lot to the list

00:04:57,849 --> 00:05:01,419
and then later you can ask what is the

00:04:59,739 --> 00:05:03,519
cost of the portfolio the original cost

00:05:01,419 --> 00:05:05,319
which is simply the sum of the shares

00:05:03,519 --> 00:05:08,409
times the price for all the stocks in

00:05:05,319 --> 00:05:11,049
our portfolio very simple code how do we

00:05:08,409 --> 00:05:12,129
test it well the first test is excuse me

00:05:11,049 --> 00:05:13,689
you just launch the interactive

00:05:12,129 --> 00:05:15,610
interpreter and you start filling around

00:05:13,689 --> 00:05:17,139
with it you make an empty portfolio and

00:05:15,610 --> 00:05:18,669
you can see that its cost is zero and

00:05:17,139 --> 00:05:20,860
then you can buy a hundred shares of IBM

00:05:18,669 --> 00:05:22,269
stock and you see that the cost is gone

00:05:20,860 --> 00:05:23,829
up and then you buy a hundred shares of

00:05:22,269 --> 00:05:25,659
HP stock and the couple the cost has

00:05:23,829 --> 00:05:27,610
gone up some more so this is really good

00:05:25,659 --> 00:05:29,199
so the good thing here is we're testing

00:05:27,610 --> 00:05:30,669
our code let's be honest there are

00:05:29,199 --> 00:05:33,849
developers who have not gotten this far

00:05:30,669 --> 00:05:35,110
right so right off the bat let's just

00:05:33,849 --> 00:05:37,479
congratulate ourselves that we are

00:05:35,110 --> 00:05:38,769
actually testing our code but the bad

00:05:37,479 --> 00:05:40,769
thing is that this is not a repeatable

00:05:38,769 --> 00:05:42,759
process if we change the implementation

00:05:40,769 --> 00:05:44,589
we're going to have to go and do this

00:05:42,759 --> 00:05:45,879
again and we won't remember what it is

00:05:44,589 --> 00:05:47,229
we test it and we'll probably miss a

00:05:45,879 --> 00:05:49,300
case and that's where the bug will be

00:05:47,229 --> 00:05:51,189
it's also labor intensive you have to

00:05:49,300 --> 00:05:52,329
type this out every time and you don't

00:05:51,189 --> 00:05:53,439
know if it's right you're going to get

00:05:52,329 --> 00:05:55,509
out your calculator and see if the

00:05:53,439 --> 00:05:57,789
arithmetic works out right so let's fix

00:05:55,509 --> 00:06:00,279
some of those problems the second test

00:05:57,789 --> 00:06:01,569
will write a Python file and we'll

00:06:00,279 --> 00:06:03,009
import our portfolio class will

00:06:01,569 --> 00:06:04,629
basically do the exact same things we

00:06:03,009 --> 00:06:06,519
just did in the interactive interpreter

00:06:04,629 --> 00:06:07,929
we'll print out what the cost is at the

00:06:06,519 --> 00:06:09,969
empty portfolio and then after we buy a

00:06:07,929 --> 00:06:11,589
hundred shares of IBM and that's good

00:06:09,969 --> 00:06:14,529
and we can see that you know this price

00:06:11,589 --> 00:06:17,139
has gone up for the IBM stock and then

00:06:14,529 --> 00:06:18,879
after we buy the HP stock it goes up so

00:06:17,139 --> 00:06:20,499
that's good we're testing the code it's

00:06:18,879 --> 00:06:22,419
now repeatable we can run that Python

00:06:20,499 --> 00:06:24,009
file anytime we like it's very low

00:06:22,419 --> 00:06:25,149
effort it doesn't take much to run that

00:06:24,009 --> 00:06:26,799
file but we still don't know if it's

00:06:25,149 --> 00:06:28,689
right we have to look at that output and

00:06:26,799 --> 00:06:30,249
you know is it right that it comes out

00:06:28,689 --> 00:06:32,559
two to one two six three you have to get

00:06:30,249 --> 00:06:34,959
out the calculator again all right let's

00:06:32,559 --> 00:06:37,059
add some more to our tests so now here

00:06:34,959 --> 00:06:39,249
what we've got is we've got a portfolio

00:06:37,059 --> 00:06:40,990
cost where we print out what it should

00:06:39,249 --> 00:06:42,159
be and then we can print out what it

00:06:40,990 --> 00:06:43,749
should be and we can print out what it

00:06:42,159 --> 00:06:44,829
should be and here we can see that it's

00:06:43,749 --> 00:06:46,749
printing those

00:06:44,829 --> 00:06:50,709
I apologize for this code going off the

00:06:46,749 --> 00:06:52,299
side of the screen now it's even better

00:06:50,709 --> 00:06:54,699
we've got repeatable tests with low

00:06:52,299 --> 00:06:56,739
effort we've got it's better it's better

00:06:54,699 --> 00:06:58,239
because we got explicit expected results

00:06:56,739 --> 00:07:00,039
we still have to check the results

00:06:58,239 --> 00:07:01,569
ourselves here the line of code if it

00:07:00,039 --> 00:07:03,129
were wrong we just have to look and see

00:07:01,569 --> 00:07:04,839
if the two numbers were the same or if

00:07:03,129 --> 00:07:06,219
they were different right the computer

00:07:04,839 --> 00:07:07,569
isn't telling us whether the number was

00:07:06,219 --> 00:07:10,319
right it's just showing us the actual

00:07:07,569 --> 00:07:12,579
result and the expected expected result

00:07:10,319 --> 00:07:15,069
so again let's add a little bit more to

00:07:12,579 --> 00:07:16,719
our tests keep in mind these are not the

00:07:15,069 --> 00:07:19,059
way you're supposed to write tests okay

00:07:16,719 --> 00:07:20,829
this is you exploring the problem of

00:07:19,059 --> 00:07:22,479
writing good tests I'm going to show you

00:07:20,829 --> 00:07:25,089
with unit tests how to do this the right

00:07:22,479 --> 00:07:26,919
way but here now what we've done is

00:07:25,089 --> 00:07:28,239
we've taken our cost and in addition to

00:07:26,919 --> 00:07:30,939
printing a message about what it should

00:07:28,239 --> 00:07:32,319
be we use an assert statement to assert

00:07:30,939 --> 00:07:33,579
that the cost should be zero if you

00:07:32,319 --> 00:07:35,349
haven't used the assert statement before

00:07:33,579 --> 00:07:37,389
it takes a condition and if the

00:07:35,349 --> 00:07:38,949
condition is true it simply carries on

00:07:37,389 --> 00:07:40,479
executing the next statement but if the

00:07:38,949 --> 00:07:43,719
condition is false it raises an

00:07:40,479 --> 00:07:47,039
exception so here we can make an

00:07:43,719 --> 00:07:49,239
assertion that the cost must be zero

00:07:47,039 --> 00:07:50,919
because our tests are passing the

00:07:49,239 --> 00:07:52,809
assertion never happens so now we have

00:07:50,919 --> 00:07:54,159
repeatable tests with low effort we have

00:07:52,809 --> 00:07:56,909
explicit expected results and the

00:07:54,159 --> 00:08:01,179
results are checked automatically good

00:07:56,909 --> 00:08:02,739
the problem is that if the test fails it

00:08:01,179 --> 00:08:06,489
will actually throw an assertion error

00:08:02,739 --> 00:08:07,659
and the tests will stop this blue code

00:08:06,489 --> 00:08:08,619
is actually incorrect there should be an

00:08:07,659 --> 00:08:11,799
assertion error there

00:08:08,619 --> 00:08:13,209
so if one of those assertion fails the

00:08:11,799 --> 00:08:15,399
entire program will stop and you won't

00:08:13,209 --> 00:08:16,599
run the rest of the tests so if you

00:08:15,399 --> 00:08:17,919
would this were a real program that

00:08:16,599 --> 00:08:19,749
we're doing many tests you'd have a

00:08:17,919 --> 00:08:21,639
hundred or a thousand or even 10,000

00:08:19,749 --> 00:08:23,439
checks to make if the second one failed

00:08:21,639 --> 00:08:24,849
you'd never find out about the rest of

00:08:23,439 --> 00:08:28,109
them what we'd really like is for each

00:08:24,849 --> 00:08:30,429
check to be run completely independently

00:08:28,109 --> 00:08:31,689
so as you can see this is getting

00:08:30,429 --> 00:08:33,759
complicated right if we wanted to

00:08:31,689 --> 00:08:35,259
approach that problem of how do we make

00:08:33,759 --> 00:08:37,389
the tests run independently of each

00:08:35,259 --> 00:08:39,849
other that would be yet more engineering

00:08:37,389 --> 00:08:41,469
to put into these tests that's going to

00:08:39,849 --> 00:08:43,149
grow it's going to become a real program

00:08:41,469 --> 00:08:44,470
with real engineering typically

00:08:43,149 --> 00:08:46,029
engineers when they find that they're

00:08:44,470 --> 00:08:47,230
encountering problems that other people

00:08:46,029 --> 00:08:48,519
have encountered they go and find a

00:08:47,230 --> 00:08:52,509
library to help them solve those

00:08:48,519 --> 00:08:54,309
problems that library is unit test and

00:08:52,509 --> 00:08:55,449
we'll get that to that in a second but

00:08:54,309 --> 00:08:57,340
first let's talk about the

00:08:55,449 --> 00:08:59,950
characteristics we want from tests

00:08:57,340 --> 00:09:01,060
we want our tests to be automated so

00:08:59,950 --> 00:09:02,500
that there will be low effort and

00:09:01,060 --> 00:09:03,910
they'll be repeatable because if they're

00:09:02,500 --> 00:09:05,320
too hard to run or if they're too

00:09:03,910 --> 00:09:07,930
confusing to run you're not going to run

00:09:05,320 --> 00:09:10,810
them we want them to be fast for the

00:09:07,930 --> 00:09:13,120
same reason we want them to be reliable

00:09:10,810 --> 00:09:14,650
remember the point of a test is you want

00:09:13,120 --> 00:09:16,810
to run it and have it tell you something

00:09:14,650 --> 00:09:18,550
you don't know if you doubt the test

00:09:16,810 --> 00:09:20,350
then you haven't really gained anything

00:09:18,550 --> 00:09:23,200
now you've simply moved the question

00:09:20,350 --> 00:09:24,970
from do mic just my code work to do my

00:09:23,200 --> 00:09:26,980
tests work and you haven't really solved

00:09:24,970 --> 00:09:29,260
anything so you need your tests to be

00:09:26,980 --> 00:09:30,850
reliable you need to you need to believe

00:09:29,260 --> 00:09:32,980
them when they say that something

00:09:30,850 --> 00:09:34,150
doesn't work and when they tell you it

00:09:32,980 --> 00:09:35,800
doesn't work you'd like them to be as

00:09:34,150 --> 00:09:37,360
informative as possible because if you

00:09:35,800 --> 00:09:39,100
think about the workflow the workflow is

00:09:37,360 --> 00:09:40,600
you run your tests and if any one of

00:09:39,100 --> 00:09:43,120
them fails you're going to immediately

00:09:40,600 --> 00:09:45,220
try and figure out what what is broken

00:09:43,120 --> 00:09:46,750
in your code and so the more clues you

00:09:45,220 --> 00:09:47,950
can get from your tests the better off

00:09:46,750 --> 00:09:50,200
you're going to be during that debugging

00:09:47,950 --> 00:09:52,900
exercise and lastly they should be

00:09:50,200 --> 00:09:54,910
focused your tests should exercise as

00:09:52,900 --> 00:09:56,500
little code as possible which is a

00:09:54,910 --> 00:09:58,900
little counterintuitive usually we want

00:09:56,500 --> 00:10:01,029
any line of code we write to do as much

00:09:58,900 --> 00:10:02,290
as possible but with tests we want each

00:10:01,029 --> 00:10:04,570
test to be as focused as possible

00:10:02,290 --> 00:10:06,700
because if it fails and you dive into

00:10:04,570 --> 00:10:09,220
your code to debug the problem the less

00:10:06,700 --> 00:10:12,190
code it runs the Morpha narrowly focused

00:10:09,220 --> 00:10:14,140
your debugging task is so this is what

00:10:12,190 --> 00:10:15,850
we want out of our tests and now we can

00:10:14,140 --> 00:10:21,280
talk about how unit tests actually gives

00:10:15,850 --> 00:10:22,810
us these properties so unit test is a

00:10:21,280 --> 00:10:26,830
lot module in the Python standard

00:10:22,810 --> 00:10:28,660
library it is the infrastructure that

00:10:26,830 --> 00:10:30,790
you use for well-structured tests and it

00:10:28,660 --> 00:10:34,150
is the lingua franca for tests it is

00:10:30,790 --> 00:10:37,600
based on the same patterns as J unit and

00:10:34,150 --> 00:10:38,800
n unit and CPP unit and a lot of testing

00:10:37,600 --> 00:10:41,230
libraries across many different

00:10:38,800 --> 00:10:43,660
languages for that reason unit test has

00:10:41,230 --> 00:10:45,490
kind of a java flavor to it which a lot

00:10:43,660 --> 00:10:46,900
of people pythonista is don't quite like

00:10:45,490 --> 00:10:48,459
which is why there are alternative ways

00:10:46,900 --> 00:10:50,170
of writing tests but we're going to talk

00:10:48,459 --> 00:10:52,180
about unit tests here because it is the

00:10:50,170 --> 00:10:53,860
it is the way everyone starts out

00:10:52,180 --> 00:10:58,810
writing tests and all the test runners

00:10:53,860 --> 00:11:01,510
and test tools support these tests so

00:10:58,810 --> 00:11:03,730
this is an actual unit test to write a

00:11:01,510 --> 00:11:07,450
unit test and by unit test by the way I

00:11:03,730 --> 00:11:09,339
just mean an automated test you import

00:11:07,450 --> 00:11:11,320
the unit test module you import your

00:11:09,339 --> 00:11:12,759
tests your code that's under test

00:11:11,320 --> 00:11:14,920
and then you're going to define a class

00:11:12,759 --> 00:11:17,199
and your class is derived from unit test

00:11:14,920 --> 00:11:19,060
test case so all of your tests will be

00:11:17,199 --> 00:11:22,480
in a class that derives from test case

00:11:19,060 --> 00:11:24,130
and the tests themselves will be methods

00:11:22,480 --> 00:11:25,630
will be methods in this class let's

00:11:24,130 --> 00:11:27,639
start with the word test so here we have

00:11:25,630 --> 00:11:29,560
a method called test buy one stock and

00:11:27,639 --> 00:11:31,509
it's going to do the test that we did

00:11:29,560 --> 00:11:33,880
before where we make an empty portfolio

00:11:31,509 --> 00:11:35,230
we buy a hundred shares of IBM and then

00:11:33,880 --> 00:11:38,259
we can make an assertion that the cost

00:11:35,230 --> 00:11:40,839
is what it should be the way you run

00:11:38,259 --> 00:11:42,880
tests with unit tests is that you use

00:11:40,839 --> 00:11:44,889
Python - M unit test if you haven't seen

00:11:42,880 --> 00:11:47,050
the - M flag it means instead of running

00:11:44,889 --> 00:11:48,550
Python code that you find in a file I'm

00:11:47,050 --> 00:11:50,319
going to name you're going to run Python

00:11:48,550 --> 00:11:52,810
code in a module I'm going to name and

00:11:50,319 --> 00:11:54,940
so by running you the unit test module

00:11:52,810 --> 00:11:56,470
as your main program it knows how to

00:11:54,940 --> 00:11:59,440
actually take the next argument test

00:11:56,470 --> 00:12:01,509
port 1 import that and find the tests in

00:11:59,440 --> 00:12:03,399
it so it will automatically find the

00:12:01,509 --> 00:12:06,399
test class on the test methods and run

00:12:03,399 --> 00:12:08,380
them this single dot means that it ran

00:12:06,399 --> 00:12:10,690
one test and then it tells you that it

00:12:08,380 --> 00:12:14,699
ran one test and everything went ok so

00:12:10,690 --> 00:12:14,699
that ran your test and the test passed

00:12:15,120 --> 00:12:20,079
behind the scenes what actually happens

00:12:17,500 --> 00:12:22,389
is unit tests instantiates your

00:12:20,079 --> 00:12:25,449
portfolio test class to get a test case

00:12:22,389 --> 00:12:28,300
object and then it runs the test method

00:12:25,449 --> 00:12:30,190
inside a try except block if it got an

00:12:28,300 --> 00:12:32,740
assertion error if your assertion failed

00:12:30,190 --> 00:12:34,959
then it records a failed test but

00:12:32,740 --> 00:12:36,790
otherwise it records a success test so

00:12:34,959 --> 00:12:38,199
conceptually it's very simple and this

00:12:36,790 --> 00:12:40,029
is perhaps how you might have approached

00:12:38,199 --> 00:12:41,500
the problem if you were building on the

00:12:40,029 --> 00:12:43,449
earlier examples and trying to solve

00:12:41,500 --> 00:12:45,430
this problem yourself wrap each assert

00:12:43,449 --> 00:12:46,569
in a try accept and catch the assertion

00:12:45,430 --> 00:12:48,399
error and print something out if it

00:12:46,569 --> 00:12:52,120
failed but unit tests will do all this

00:12:48,399 --> 00:12:54,550
for you alright let's add some more

00:12:52,120 --> 00:12:56,920
tests so here of course there's more

00:12:54,550 --> 00:12:58,899
conditions that we have to test so we'll

00:12:56,920 --> 00:13:00,970
also test the empty case the portfolio

00:12:58,899 --> 00:13:02,769
should be 0 here's the buy 1 stock that

00:13:00,970 --> 00:13:08,019
we had before and but we'll also test

00:13:02,769 --> 00:13:09,850
buying two stocks so we buy two stocks

00:13:08,019 --> 00:13:12,339
and assert the cost is that now you see

00:13:09,850 --> 00:13:14,199
we have a dot dot dot dot dot is not me

00:13:12,339 --> 00:13:16,329
leaving things out of this code example

00:13:14,199 --> 00:13:18,490
that is literally three dots that unit

00:13:16,329 --> 00:13:21,579
test prints ones for each test you get a

00:13:18,490 --> 00:13:23,290
dot for every past test some people who

00:13:21,579 --> 00:13:24,700
are really into tests talk about being

00:13:23,290 --> 00:13:25,810
dot addicted that

00:13:24,700 --> 00:13:28,150
just want to see lots and lots and lots

00:13:25,810 --> 00:13:30,040
of dots because every dot means the

00:13:28,150 --> 00:13:31,300
tests the past and then it tells you

00:13:30,040 --> 00:13:36,070
that ran three dots and it tells you

00:13:31,300 --> 00:13:38,110
that it went okay under the covers what

00:13:36,070 --> 00:13:40,210
happens again is it makes a test case

00:13:38,110 --> 00:13:42,550
object and then it runs a test method

00:13:40,210 --> 00:13:46,360
and then it makes a whole new test case

00:13:42,550 --> 00:13:49,510
object to run the second method and then

00:13:46,360 --> 00:13:50,710
it makes a third test case object to run

00:13:49,510 --> 00:13:52,540
the third method this is a very

00:13:50,710 --> 00:13:54,790
different way of using classes usually

00:13:52,540 --> 00:13:56,140
with classes you make one object to

00:13:54,790 --> 00:13:57,730
represent a thing and then you call many

00:13:56,140 --> 00:14:00,280
methods on it here we're going to make a

00:13:57,730 --> 00:14:02,560
class that has many methods each method

00:14:00,280 --> 00:14:05,530
gets called once on a separate object

00:14:02,560 --> 00:14:07,510
from each of every other method but you

00:14:05,530 --> 00:14:09,010
can see this gives us test isolation so

00:14:07,510 --> 00:14:10,870
not only do we have a try except block

00:14:09,010 --> 00:14:12,880
or out in every test method so they run

00:14:10,870 --> 00:14:14,590
independently but because each one of

00:14:12,880 --> 00:14:16,600
them is running in a brand new test case

00:14:14,590 --> 00:14:18,070
object it's very difficult to do

00:14:16,600 --> 00:14:19,870
anything in the first test that's going

00:14:18,070 --> 00:14:22,690
to affect the outcome of the second test

00:14:19,870 --> 00:14:25,360
test isolation is all about making sure

00:14:22,690 --> 00:14:26,950
that every test is independent of every

00:14:25,360 --> 00:14:30,400
other test if you do something in test

00:14:26,950 --> 00:14:32,920
one and it passes and you then but it's

00:14:30,400 --> 00:14:34,090
side effect is visible in test two how

00:14:32,920 --> 00:14:36,580
do you know that test two is really

00:14:34,090 --> 00:14:37,720
testing when it's supposed to test so

00:14:36,580 --> 00:14:39,670
the idea is to keep the tests

00:14:37,720 --> 00:14:41,320
independent of each other and to make

00:14:39,670 --> 00:14:43,240
sure that failure doesn't stop the next

00:14:41,320 --> 00:14:45,130
tests from happening so we keep them all

00:14:43,240 --> 00:14:47,560
completely isolated in theory you should

00:14:45,130 --> 00:14:49,870
be able to have a 10,000 test test suite

00:14:47,560 --> 00:14:52,630
and be able to run any single test out

00:14:49,870 --> 00:14:54,760
of it all by itself and have that test

00:14:52,630 --> 00:14:56,970
passed just as if it were run along with

00:14:54,760 --> 00:14:59,610
all of its 999,000

00:14:56,970 --> 00:15:03,970
however many it is brothers and sisters

00:14:59,610 --> 00:15:05,440
it's hard to do arithmetic on stage now

00:15:03,970 --> 00:15:08,140
what is failure look like so suppose we

00:15:05,440 --> 00:15:09,820
had either broken our test code or

00:15:08,140 --> 00:15:12,250
broken the test the product code itself

00:15:09,820 --> 00:15:14,290
when you run the tests you'll get

00:15:12,250 --> 00:15:16,720
instead of a dot you'll get an F the F

00:15:14,290 --> 00:15:18,310
means failure okay so here what we've

00:15:16,720 --> 00:15:20,380
done is we had an assertion that was

00:15:18,310 --> 00:15:22,420
wrong we had the wrong price in there or

00:15:20,380 --> 00:15:24,760
something and it raises an assertion

00:15:22,420 --> 00:15:26,410
error so what happens is all the tests

00:15:24,760 --> 00:15:28,420
run and you get an F for every failed

00:15:26,410 --> 00:15:30,850
test in a dot for every passing test and

00:15:28,420 --> 00:15:32,650
then at the end every failed test prints

00:15:30,850 --> 00:15:34,510
a stack trace so get a full stack trace

00:15:32,650 --> 00:15:36,340
it's not printed when it fails because

00:15:34,510 --> 00:15:38,170
that would interrupt the whole field of

00:15:36,340 --> 00:15:38,560
dots thing so you get all of the dots

00:15:38,170 --> 00:15:40,120
and

00:15:38,560 --> 00:15:42,310
and then you get all of the failure to

00:15:40,120 --> 00:15:43,720
trace backs and those trace backs are

00:15:42,310 --> 00:15:45,580
very useful because that's part of the

00:15:43,720 --> 00:15:51,130
debugging clues that helps you go and

00:15:45,580 --> 00:15:52,720
find out what product code has failed so

00:15:51,130 --> 00:15:55,300
this is better because the failed tests

00:15:52,720 --> 00:15:57,040
didn't stop the other tasks but it's bad

00:15:55,300 --> 00:15:58,390
because we don't actually know exactly

00:15:57,040 --> 00:16:01,600
what failed here right we can see that

00:15:58,390 --> 00:16:04,420
the the cost was not 17 648 but we don't

00:16:01,600 --> 00:16:05,529
know what the cost actually was right it

00:16:04,420 --> 00:16:10,180
could have been zero it could have been

00:16:05,529 --> 00:16:14,260
17 649 we don't have that information so

00:16:10,180 --> 00:16:16,870
instead of using an assert statement the

00:16:14,260 --> 00:16:19,029
unit's tests test case objects give you

00:16:16,870 --> 00:16:20,710
methods called assert equal for instance

00:16:19,029 --> 00:16:23,380
so here you can see that we've got our

00:16:20,710 --> 00:16:24,880
test by one stock method and instead of

00:16:23,380 --> 00:16:26,800
using an assert statement we've called a

00:16:24,880 --> 00:16:28,870
method on the test case object itself

00:16:26,800 --> 00:16:30,220
and instead of using an equality

00:16:28,870 --> 00:16:32,800
operator we've passed the two values

00:16:30,220 --> 00:16:34,570
into assert equal so this is kind of

00:16:32,800 --> 00:16:36,610
stylized compared to what you're used to

00:16:34,570 --> 00:16:39,250
but the advantage is that when the

00:16:36,610 --> 00:16:41,680
assertion fails it can actually print

00:16:39,250 --> 00:16:43,600
out the value it got and the value it

00:16:41,680 --> 00:16:46,630
expected so we can see the assertion

00:16:43,600 --> 00:16:50,530
failed because 17600 is not equal to 17

00:16:46,630 --> 00:16:52,300
648 and that's a clue 17 6 17 600 is the

00:16:50,530 --> 00:16:53,560
thing that went wrong we can now we have

00:16:52,300 --> 00:16:56,980
a piece of information that can help us

00:16:53,560 --> 00:16:58,690
diagnose and debug the problem so the

00:16:56,980 --> 00:17:01,240
unit tests module gives you a lot of

00:16:58,690 --> 00:17:02,440
cert helpers a cert equal and not equal

00:17:01,240 --> 00:17:04,780
assert that this is true this is false

00:17:02,440 --> 00:17:06,520
that that is in that that this is almost

00:17:04,780 --> 00:17:09,579
equal to that for floating points etc

00:17:06,520 --> 00:17:11,650
etc etc regex matching all sorts of

00:17:09,579 --> 00:17:14,110
interesting assertion helpers for you to

00:17:11,650 --> 00:17:17,280
write your tests in a way that the test

00:17:14,110 --> 00:17:17,280
Runner can give you lots of information

00:17:17,730 --> 00:17:22,720
one pro tip that large projects often

00:17:21,010 --> 00:17:25,060
get to but people rarely do at the very

00:17:22,720 --> 00:17:27,160
beginning make your own base class to

00:17:25,060 --> 00:17:28,540
drive all your test cases from so here

00:17:27,160 --> 00:17:30,520
what I've done is I've created a class

00:17:28,540 --> 00:17:32,530
called portfolio test case derived from

00:17:30,520 --> 00:17:34,000
test case it doesn't have any test

00:17:32,530 --> 00:17:36,370
methods and in itself a test method

00:17:34,000 --> 00:17:38,590
remember starts with test underscore but

00:17:36,370 --> 00:17:40,330
it has this helper assert cost equal and

00:17:38,590 --> 00:17:42,190
here instead of passing in two numbers

00:17:40,330 --> 00:17:44,200
to assert equal I can pass in a

00:17:42,190 --> 00:17:46,150
portfolio and a cost and then this

00:17:44,200 --> 00:17:47,410
method will assert that P dot cost is

00:17:46,150 --> 00:17:49,510
equal to the number that was passed in

00:17:47,410 --> 00:17:51,490
and so now I've raised the level of

00:17:49,510 --> 00:17:51,880
discourse up into my own domain instead

00:17:51,490 --> 00:17:53,830
of

00:17:51,880 --> 00:17:55,480
tests that assert to numbers are equal I

00:17:53,830 --> 00:17:57,040
can write tests that assert that the

00:17:55,480 --> 00:17:59,140
cost of a portfolio is equal to

00:17:57,040 --> 00:18:02,140
something so here can I can say a cert

00:17:59,140 --> 00:18:03,670
cost equal of P is equal to zero and I

00:18:02,140 --> 00:18:05,350
still get the nice assertion because I'm

00:18:03,670 --> 00:18:07,150
using assert equal under the covers and

00:18:05,350 --> 00:18:08,740
I get the assert cost equal method

00:18:07,150 --> 00:18:11,170
because I've derived from portfolio test

00:18:08,740 --> 00:18:13,090
case these base classes tend to grow

00:18:11,170 --> 00:18:14,830
over time and especially if you're

00:18:13,090 --> 00:18:16,330
focused on that kind of base class then

00:18:14,830 --> 00:18:18,730
you have an opportunity to write really

00:18:16,330 --> 00:18:20,560
good domain-specific helpers for

00:18:18,730 --> 00:18:22,240
instance it's very common in web testing

00:18:20,560 --> 00:18:24,490
to say I got a response back

00:18:22,240 --> 00:18:26,950
I want to assert both that it is a 200

00:18:24,490 --> 00:18:29,140
response it's successful and that it has

00:18:26,950 --> 00:18:30,970
this word in it well why not just have a

00:18:29,140 --> 00:18:33,340
method that says assert word in response

00:18:30,970 --> 00:18:34,480
and do the 200 check in there as well

00:18:33,340 --> 00:18:36,190
and you can have one line in each of

00:18:34,480 --> 00:18:38,020
your tests rather than two because your

00:18:36,190 --> 00:18:40,600
helper method has taken on some of that

00:18:38,020 --> 00:18:43,840
domain-specific knowledge that you're

00:18:40,600 --> 00:18:45,220
going to use over and over again this is

00:18:43,840 --> 00:18:47,080
one of the things I notice about tests

00:18:45,220 --> 00:18:49,630
is people approach them as wrote

00:18:47,080 --> 00:18:51,040
boilerplate rather than code to engineer

00:18:49,630 --> 00:18:52,660
as if it were really code you cared

00:18:51,040 --> 00:18:54,340
about you're allowed to refactor your

00:18:52,660 --> 00:18:56,200
tests and move common pieces into

00:18:54,340 --> 00:18:59,470
helpers and functions and classes to

00:18:56,200 --> 00:19:01,120
help you build those tests by the way

00:18:59,470 --> 00:19:04,720
there's a third possible outcome besides

00:19:01,120 --> 00:19:06,430
dot and F and that is an E and E happens

00:19:04,720 --> 00:19:08,860
if any exception other than assertion

00:19:06,430 --> 00:19:10,390
error comes up so here for example you

00:19:08,860 --> 00:19:12,550
see that for some reason in our test we

00:19:10,390 --> 00:19:14,860
call this by xx method which doesn't

00:19:12,550 --> 00:19:16,720
exist it doesn't have that attribute so

00:19:14,860 --> 00:19:18,340
it raised an attribute error that test

00:19:16,720 --> 00:19:20,500
ended with an E and the reason that's

00:19:18,340 --> 00:19:22,900
distinguished is a good test should

00:19:20,500 --> 00:19:24,730
either successfully pass or it should

00:19:22,900 --> 00:19:26,530
fail in an assertion if it fails in some

00:19:24,730 --> 00:19:29,170
other way that really means that the

00:19:26,530 --> 00:19:30,610
test dropped the ball right the test

00:19:29,170 --> 00:19:33,100
should have a thing in its hands and say

00:19:30,610 --> 00:19:34,780
it failed or it succeeded but if another

00:19:33,100 --> 00:19:36,670
exception happened then something is

00:19:34,780 --> 00:19:42,010
truly wrong with your test and you have

00:19:36,670 --> 00:19:44,830
to go and fix the test by the way this

00:19:42,010 --> 00:19:47,170
brings up one tricky thing for beginners

00:19:44,830 --> 00:19:48,580
which is negative testing let's say you

00:19:47,170 --> 00:19:51,220
want to call a function method a method

00:19:48,580 --> 00:19:53,710
and you want to test that it raises the

00:19:51,220 --> 00:19:55,390
exception you expected you can't just

00:19:53,710 --> 00:19:57,130
call the function here we are trying to

00:19:55,390 --> 00:19:58,870
call the by method with the wrong number

00:19:57,130 --> 00:20:00,790
of arguments so it should raise an

00:19:58,870 --> 00:20:04,090
exception if we wanted to test that we

00:20:00,790 --> 00:20:05,590
can't simply run this test method this

00:20:04,090 --> 00:20:07,510
way because that will actually raise

00:20:05,590 --> 00:20:09,130
the exception will actually get an error

00:20:07,510 --> 00:20:11,559
result because the type error will be

00:20:09,130 --> 00:20:12,850
raised by the by type error is exactly

00:20:11,559 --> 00:20:14,830
what we want to happen but we haven't

00:20:12,850 --> 00:20:16,029
managed to assert the exception happens

00:20:14,830 --> 00:20:19,029
we've simply managed to make the

00:20:16,029 --> 00:20:20,860
exception can happen unit test has a way

00:20:19,029 --> 00:20:23,500
to do this there's a self dot assert

00:20:20,860 --> 00:20:25,720
raises method that you can use as a

00:20:23,500 --> 00:20:28,360
context manager in a with statement so

00:20:25,720 --> 00:20:30,309
that you can put the P dot byline into

00:20:28,360 --> 00:20:32,380
the with statement and you can assert

00:20:30,309 --> 00:20:33,400
that it raises the type error and that

00:20:32,380 --> 00:20:36,190
with statement we'll catch that

00:20:33,400 --> 00:20:37,539
exception for you and it will check that

00:20:36,190 --> 00:20:39,730
the exception was actually the type

00:20:37,539 --> 00:20:47,110
error that you expected and the test

00:20:39,730 --> 00:20:49,120
will pass let's test the loud another

00:20:47,110 --> 00:20:50,770
method to our portfolio class we're

00:20:49,120 --> 00:20:52,570
going to add a cell method so the cell

00:20:50,770 --> 00:20:54,190
method is going to take a name in some

00:20:52,570 --> 00:20:56,620
shares and it's going to find that

00:20:54,190 --> 00:21:00,520
holding and it's going to subtract that

00:20:56,620 --> 00:21:01,929
many shares from the portfolio to test

00:21:00,520 --> 00:21:03,309
cell we're going to make a portfolio

00:21:01,929 --> 00:21:05,049
we're going to put some things in it to

00:21:03,309 --> 00:21:06,640
it we're going to try to sell 50 shares

00:21:05,049 --> 00:21:09,820
of Microsoft this cost should have gone

00:21:06,640 --> 00:21:11,260
down if we try to sell Microsoft but we

00:21:09,820 --> 00:21:13,000
trying to sell more than we had it's

00:21:11,260 --> 00:21:14,649
going to get a value error if we're

00:21:13,000 --> 00:21:15,940
trying to sell IBM and we haven't even

00:21:14,649 --> 00:21:17,830
bought IBM we're going to get a value

00:21:15,940 --> 00:21:20,140
error but notice there's a lot of

00:21:17,830 --> 00:21:21,730
repetition here and again just like any

00:21:20,140 --> 00:21:23,529
code that you write if you see

00:21:21,730 --> 00:21:25,360
repetitions if you can squint at code

00:21:23,529 --> 00:21:26,470
and you can see a repeating pattern that

00:21:25,360 --> 00:21:28,299
means that there's stuff that you can

00:21:26,470 --> 00:21:30,429
refactor and the same is true of your

00:21:28,299 --> 00:21:31,960
tests than of anything else just because

00:21:30,429 --> 00:21:32,770
you feel like your tests are boilerplate

00:21:31,960 --> 00:21:34,539
that doesn't mean they should be

00:21:32,770 --> 00:21:36,220
boilerplate you should make them as

00:21:34,539 --> 00:21:39,700
expressive as possible so we want to

00:21:36,220 --> 00:21:41,320
refactor all that code out luckily the

00:21:39,700 --> 00:21:43,779
unit test gives us a way to do this a

00:21:41,320 --> 00:21:46,000
class can define a setup method and the

00:21:43,779 --> 00:21:48,520
setup method is invoked before each test

00:21:46,000 --> 00:21:50,200
method so they hear the setup method is

00:21:48,520 --> 00:21:52,090
defining a self chief which is a

00:21:50,200 --> 00:21:54,490
portfolio object and we're going to buy

00:21:52,090 --> 00:21:56,799
the three stocks we want to buy and then

00:21:54,490 --> 00:21:58,870
we need within each of our test methods

00:21:56,799 --> 00:22:01,870
we can simply access the self dot P that

00:21:58,870 --> 00:22:03,460
was created by setup so here we can have

00:22:01,870 --> 00:22:05,940
much shorter tests that are much more

00:22:03,460 --> 00:22:07,990
descriptive of what they want to do

00:22:05,940 --> 00:22:10,120
what's happening under the covers is

00:22:07,990 --> 00:22:11,679
that for each time that we create a test

00:22:10,120 --> 00:22:14,230
case object we're going to call the

00:22:11,679 --> 00:22:16,360
setup method by the way it could fail

00:22:14,230 --> 00:22:18,429
and give you an e output but if it

00:22:16,360 --> 00:22:19,510
succeeds we'll call the test method will

00:22:18,429 --> 00:22:21,070
record the failure in the

00:22:19,510 --> 00:22:22,780
and success as always and by the way

00:22:21,070 --> 00:22:24,130
there's also a teardown method that will

00:22:22,780 --> 00:22:26,530
get invoked at the end of all of your

00:22:24,130 --> 00:22:28,270
tests to clean up whatever the setup did

00:22:26,530 --> 00:22:29,890
we didn't need one for the previous

00:22:28,270 --> 00:22:31,600
example because it was just creating in

00:22:29,890 --> 00:22:33,250
memory objects but if you were creating

00:22:31,600 --> 00:22:36,310
files on disk you could clean them up in

00:22:33,250 --> 00:22:37,810
the teardown method so setup and

00:22:36,310 --> 00:22:40,090
teardown also give us a great way to

00:22:37,810 --> 00:22:42,370
create isolated tests they establish

00:22:40,090 --> 00:22:44,170
context they are placed for common pre

00:22:42,370 --> 00:22:45,880
and post work to live and they give you

00:22:44,170 --> 00:22:47,380
isolation even with failures and as a

00:22:45,880 --> 00:22:49,270
pointer off to something else to look at

00:22:47,380 --> 00:22:51,340
if you find yourself creating lots and

00:22:49,270 --> 00:22:53,320
lots of big common data you want to look

00:22:51,340 --> 00:22:55,300
into a thing called fixtures which is a

00:22:53,320 --> 00:22:59,530
term of art and testing but it's also

00:22:55,300 --> 00:23:01,510
the name of a Python library again tests

00:22:59,530 --> 00:23:03,040
are real code you're going to have

00:23:01,510 --> 00:23:04,720
helper functions and classes they can

00:23:03,040 --> 00:23:06,910
become significant and by the way you're

00:23:04,720 --> 00:23:08,740
going to write tests for your test

00:23:06,910 --> 00:23:10,450
helpers because you want to know if your

00:23:08,740 --> 00:23:11,800
test helpers are working so that you can

00:23:10,450 --> 00:23:13,900
trust that your tests are working and

00:23:11,800 --> 00:23:15,490
you should not resent that that is a

00:23:13,900 --> 00:23:17,200
good sign that your project has grown to

00:23:15,490 --> 00:23:18,760
a level of maturity and a level of

00:23:17,200 --> 00:23:20,350
testing that you are a really good

00:23:18,760 --> 00:23:23,140
software engineer so pat yourself on the

00:23:20,350 --> 00:23:27,760
back all right let's talk for a bit

00:23:23,140 --> 00:23:29,620
about mocks as I mentioned before it's

00:23:27,760 --> 00:23:31,780
really important for your tests to test

00:23:29,620 --> 00:23:34,030
small amounts of code the less code each

00:23:31,780 --> 00:23:35,830
test tests the more narrowly focused

00:23:34,030 --> 00:23:40,930
your debugging task will be when that

00:23:35,830 --> 00:23:42,370
test fails but we always build systems

00:23:40,930 --> 00:23:43,660
so that components depend on each other

00:23:42,370 --> 00:23:45,820
right we're all used to building these

00:23:43,660 --> 00:23:47,260
towers of abstraction so that at the top

00:23:45,820 --> 00:23:49,270
level you've got all these things you're

00:23:47,260 --> 00:23:51,940
depending on right how can you test just

00:23:49,270 --> 00:23:53,440
one component in your code dependencies

00:23:51,940 --> 00:23:54,790
in your code are good because you're

00:23:53,440 --> 00:23:57,190
building on the work of others but

00:23:54,790 --> 00:23:59,110
dependencies and tests are bad because

00:23:57,190 --> 00:24:01,000
it puts more suspect code in each test

00:23:59,110 --> 00:24:02,980
in addition some of those components

00:24:01,000 --> 00:24:05,470
might be slow and remember we want our

00:24:02,980 --> 00:24:07,360
tests to be fast right the problem with

00:24:05,470 --> 00:24:08,860
testing missile-launching sites is that

00:24:07,360 --> 00:24:10,840
if your test really launches a missile

00:24:08,860 --> 00:24:14,170
that takes a long time you want your

00:24:10,840 --> 00:24:16,510
tests to go fast not only that but your

00:24:14,170 --> 00:24:18,010
tests might be unpredictable right if

00:24:16,510 --> 00:24:20,410
you have a flaky component that isn't

00:24:18,010 --> 00:24:21,610
really the focus of your test you want

00:24:20,410 --> 00:24:22,990
to get it out of the way so that you can

00:24:21,610 --> 00:24:25,030
test the code that you do want to test

00:24:22,990 --> 00:24:26,650
this is the wake systems are often built

00:24:25,030 --> 00:24:28,360
with a code under test as depending on

00:24:26,650 --> 00:24:29,890
all these modules which you want to do

00:24:28,360 --> 00:24:31,390
is you want to replace those little

00:24:29,890 --> 00:24:33,280
compose big components with little

00:24:31,390 --> 00:24:36,880
pieces so that you can reduce the amount

00:24:33,280 --> 00:24:38,170
of code in each test let's add a little

00:24:36,880 --> 00:24:39,610
bit more to our portfolio stock

00:24:38,170 --> 00:24:41,620
portfolios are only interesting because

00:24:39,610 --> 00:24:43,390
stock prices go up and down so let's add

00:24:41,620 --> 00:24:44,680
some code into our portfolio that's

00:24:43,390 --> 00:24:47,560
going to actually go out and talk to

00:24:44,680 --> 00:24:50,140
financial comm to get the actual price

00:24:47,560 --> 00:24:51,790
right now of our stocks so we can find

00:24:50,140 --> 00:24:55,120
out what the current value of our stocks

00:24:51,790 --> 00:24:56,470
is so this value method is very cool we

00:24:55,120 --> 00:24:58,360
can actually buy some stock and we can

00:24:56,470 --> 00:25:00,220
actually get the current prices for IBM

00:24:58,360 --> 00:25:01,780
and HP stock and write our current value

00:25:00,220 --> 00:25:03,820
is now think for a minute about how

00:25:01,780 --> 00:25:05,590
we're going to test this code we cannot

00:25:03,820 --> 00:25:07,780
write an assertion that says I assert

00:25:05,590 --> 00:25:09,490
that IBM is trading at $100 right now

00:25:07,780 --> 00:25:10,630
because we don't know what IBM is

00:25:09,490 --> 00:25:12,430
trading at that's the whole point of

00:25:10,630 --> 00:25:14,380
this code is to get information that we

00:25:12,430 --> 00:25:15,910
don't have how do we write a test the

00:25:14,380 --> 00:25:18,220
tests that this is working properly

00:25:15,910 --> 00:25:21,220
right it's live data it's unpredictable

00:25:18,220 --> 00:25:22,720
that's its entire point it's slow right

00:25:21,220 --> 00:25:24,820
it's actually pretty fast to go to

00:25:22,720 --> 00:25:26,350
Finance Yahoo comm and get a quote but

00:25:24,820 --> 00:25:28,210
it's probably slower than you'd want it

00:25:26,350 --> 00:25:29,560
to be maybe it's unavailable maybe Yahoo

00:25:28,210 --> 00:25:30,940
goes down right there trying to fix the

00:25:29,560 --> 00:25:32,230
heartbleed bug you can't run your test

00:25:30,940 --> 00:25:35,250
that day that's no good

00:25:32,230 --> 00:25:38,050
so the question should be for your code

00:25:35,250 --> 00:25:40,780
assuming Yahoo is working does my code

00:25:38,050 --> 00:25:42,880
work and the challenge now is how do we

00:25:40,780 --> 00:25:44,770
get Yahoo out of the picture right how

00:25:42,880 --> 00:25:46,210
do we remove that dependency on that

00:25:44,770 --> 00:25:47,620
server so that we can just be talking

00:25:46,210 --> 00:25:49,570
about the piece of code we actually care

00:25:47,620 --> 00:25:53,260
about we don't want to test all of Yahoo

00:25:49,570 --> 00:25:55,000
comm we want to test our code one way to

00:25:53,260 --> 00:25:58,000
do is to have a fake implementation of

00:25:55,000 --> 00:25:59,680
current prices so here is a test that we

00:25:58,000 --> 00:26:00,730
derive from test cases always and I'm

00:25:59,680 --> 00:26:02,710
going to have a method in here called

00:26:00,730 --> 00:26:04,330
fake current prices now if you remember

00:26:02,710 --> 00:26:06,430
from our product code current prices

00:26:04,330 --> 00:26:07,750
simply returns a dictionary with the

00:26:06,430 --> 00:26:09,490
keys or the names of stocks and the

00:26:07,750 --> 00:26:10,870
values of the prices and this is going

00:26:09,490 --> 00:26:13,330
to be a fake implementation of it that

00:26:10,870 --> 00:26:14,890
just returns some cans data and in my

00:26:13,330 --> 00:26:16,600
setup I'm going to make a portfolio I'm

00:26:14,890 --> 00:26:18,040
going to buy some stocks and then I'm

00:26:16,600 --> 00:26:19,900
going to actually monkey patch the

00:26:18,040 --> 00:26:22,990
portfolio to change its current prices

00:26:19,900 --> 00:26:24,460
method into my function and this works

00:26:22,990 --> 00:26:26,020
so this is a little odd and if you

00:26:24,460 --> 00:26:27,310
haven't dug really deep into Python

00:26:26,020 --> 00:26:28,780
internals you may be surprised to see

00:26:27,310 --> 00:26:31,000
that you can just replace methods like

00:26:28,780 --> 00:26:33,040
this on objects but it works and now

00:26:31,000 --> 00:26:35,050
when we run our test and we look at self

00:26:33,040 --> 00:26:36,850
dot P dot value it will actually call

00:26:35,050 --> 00:26:38,440
self dot P dot current prices which is

00:26:36,850 --> 00:26:40,210
our method fake current prices which

00:26:38,440 --> 00:26:42,970
will return that fixed dictionary and we

00:26:40,210 --> 00:26:44,260
haven't made any Network calls and we

00:26:42,970 --> 00:26:45,670
can assert that with the value is what

00:26:44,260 --> 00:26:47,320
we know it's going to be because we know

00:26:45,670 --> 00:26:49,330
what we what lies we told

00:26:47,320 --> 00:26:52,690
old about the prep current price of IBM

00:26:49,330 --> 00:26:55,330
and HP stock so good the test results

00:26:52,690 --> 00:26:56,830
are predictable the bad thing is that

00:26:55,330 --> 00:26:59,110
there's some code that isn't tested so

00:26:56,830 --> 00:27:01,060
here I've used the coverage tool which

00:26:59,110 --> 00:27:02,890
is a way of measuring what lines of code

00:27:01,060 --> 00:27:04,660
get executed when you run your tests

00:27:02,890 --> 00:27:05,860
it's a way of testing your tests the

00:27:04,660 --> 00:27:07,240
theory of your tests is that they're

00:27:05,860 --> 00:27:09,040
testing all the code you have how do you

00:27:07,240 --> 00:27:10,450
know you run coverage it tells you which

00:27:09,040 --> 00:27:12,250
lines of code you haven't actually run

00:27:10,450 --> 00:27:15,250
under your tests and here we can see the

00:27:12,250 --> 00:27:18,190
lines 53 53 through 56 have not been

00:27:15,250 --> 00:27:19,930
executed and 53 through 56 are exactly

00:27:18,190 --> 00:27:21,280
the lines of code we tried to snip out

00:27:19,930 --> 00:27:23,260
of the system which were the lines of

00:27:21,280 --> 00:27:25,150
code that talked to yahoo.com but this

00:27:23,260 --> 00:27:27,190
is code we wrote we need to test this

00:27:25,150 --> 00:27:28,810
code somehow right so we've got a good

00:27:27,190 --> 00:27:32,770
system here but it doesn't test all our

00:27:28,810 --> 00:27:34,390
code so we can try faking URL Lib you

00:27:32,770 --> 00:27:35,890
are L open instead so here what we do is

00:27:34,390 --> 00:27:38,830
we make a new object that's going to be

00:27:35,890 --> 00:27:41,340
a stand-in for your lib for us and it's

00:27:38,830 --> 00:27:43,990
got a method on it called URL open and

00:27:41,340 --> 00:27:45,460
in our setup we're going to save away

00:27:43,990 --> 00:27:48,670
we're going to we're going to jump right

00:27:45,460 --> 00:27:50,560
into the portfolio 3 module which is our

00:27:48,670 --> 00:27:52,420
product code and it has a reference to

00:27:50,560 --> 00:27:54,130
URL Lib we're going to save that away in

00:27:52,420 --> 00:27:55,960
our setup we're going to make an

00:27:54,130 --> 00:27:58,720
instance of our fake URL Lib and monkey

00:27:55,960 --> 00:28:00,940
patch it into our product module and now

00:27:58,720 --> 00:28:02,770
in our product module URL Lib refers to

00:28:00,940 --> 00:28:04,600
our class and therefore URL Lib that URL

00:28:02,770 --> 00:28:06,700
open refers to our method and when it

00:28:04,600 --> 00:28:08,830
gets called it's going to return the

00:28:06,700 --> 00:28:10,900
data that we want up here this URL Lib

00:28:08,830 --> 00:28:13,210
is returning a file like object which

00:28:10,900 --> 00:28:14,740
returns exactly the CSV data that Yahoo

00:28:13,210 --> 00:28:16,510
would have returned I know the details

00:28:14,740 --> 00:28:18,100
here don't worry about the details about

00:28:16,510 --> 00:28:19,930
the CSV and all that stuff there's no

00:28:18,100 --> 00:28:22,840
way to keep up with me right now just

00:28:19,930 --> 00:28:24,430
keep in mind the idea here is to make an

00:28:22,840 --> 00:28:26,110
object that works exactly like the

00:28:24,430 --> 00:28:28,060
component you don't want in your system

00:28:26,110 --> 00:28:29,650
any more and put it in place so that the

00:28:28,060 --> 00:28:31,360
product code will actually call your

00:28:29,650 --> 00:28:33,580
code instead of that code and by the

00:28:31,360 --> 00:28:36,160
time we get down here and we call self

00:28:33,580 --> 00:28:38,260
dot P dot value value calls our current

00:28:36,160 --> 00:28:40,540
prices module function our current

00:28:38,260 --> 00:28:42,340
prices function calls URL Lib dot URL

00:28:40,540 --> 00:28:43,750
open which it thinks is a standard

00:28:42,340 --> 00:28:45,760
library module it talks over the network

00:28:43,750 --> 00:28:47,590
but is in fact our fake object that we

00:28:45,760 --> 00:28:49,720
put in place it gets back that file

00:28:47,590 --> 00:28:51,100
object it parses the CSV it makes the

00:28:49,720 --> 00:28:51,940
dictionary it computes the value and

00:28:51,100 --> 00:28:53,770
then we get what we want

00:28:51,940 --> 00:28:56,050
and by the way at the end the teardown

00:28:53,770 --> 00:28:59,520
method is going to restore the real URL

00:28:56,050 --> 00:28:59,520
Lib it's going to unmark a patch things

00:29:00,350 --> 00:29:04,590
now all of our code is executed right

00:29:02,760 --> 00:29:06,240
we've got 100% test coverage all of our

00:29:04,590 --> 00:29:09,000
code is executed the standard lib is

00:29:06,240 --> 00:29:11,240
stubbed out and we've made no web access

00:29:09,000 --> 00:29:13,230
during our tests so this is really good

00:29:11,240 --> 00:29:15,060
the thing that's not so great is we've

00:29:13,230 --> 00:29:16,350
had to do a lot of sort of handcrafting

00:29:15,060 --> 00:29:17,850
of engineering there there's an even

00:29:16,350 --> 00:29:20,160
better way to do this which is a thing

00:29:17,850 --> 00:29:21,780
called mock objects mock objects are

00:29:20,160 --> 00:29:23,910
these amazing things that are I call

00:29:21,780 --> 00:29:25,620
them automatic chameleons they will act

00:29:23,910 --> 00:29:27,420
like anything you want them to act like

00:29:25,620 --> 00:29:29,190
here's an example where I from mock I

00:29:27,420 --> 00:29:31,470
import the mock class and they make a

00:29:29,190 --> 00:29:33,480
thing called funk which is a mock and I

00:29:31,470 --> 00:29:35,630
do all I say about it is the return

00:29:33,480 --> 00:29:38,100
value should be the string hello and

00:29:35,630 --> 00:29:41,760
then I call it as if it were a function

00:29:38,100 --> 00:29:43,650
and it returns hello right it did it

00:29:41,760 --> 00:29:45,510
just said I'll return that sure you told

00:29:43,650 --> 00:29:47,580
me to return that that's fine and by the

00:29:45,510 --> 00:29:48,990
way the 17 into something it just stored

00:29:47,580 --> 00:29:50,370
them away and later I can look at that

00:29:48,990 --> 00:29:52,410
and say funk what were you called with

00:29:50,370 --> 00:29:54,150
and it says oh I got called with 17 in

00:29:52,410 --> 00:29:55,800
something so this is great this is

00:29:54,150 --> 00:29:59,160
perfect for putting in place as a mock

00:29:55,800 --> 00:30:00,900
as a fake object and it's really easy to

00:29:59,160 --> 00:30:03,270
do because the mock library also has a

00:30:00,900 --> 00:30:06,300
patch decorate a patch context manager

00:30:03,270 --> 00:30:08,130
so here what we can do is we can say to

00:30:06,300 --> 00:30:10,350
the mock library I want you to mock out

00:30:08,130 --> 00:30:12,720
you are a live that URL open and give me

00:30:10,350 --> 00:30:14,130
the mock object that you made and then

00:30:12,720 --> 00:30:15,960
down here what we say is I'm going to

00:30:14,130 --> 00:30:19,650
make URL open have a return value of

00:30:15,960 --> 00:30:21,540
this fake Yahoo data and now when I call

00:30:19,650 --> 00:30:23,370
self dot P dot value it goes through all

00:30:21,540 --> 00:30:24,630
of our code it gets the URL open which

00:30:23,370 --> 00:30:26,790
hits the mock which gets the return

00:30:24,630 --> 00:30:28,200
value that we gave it and it gets that

00:30:26,790 --> 00:30:29,730
back that data and it comes back up and

00:30:28,200 --> 00:30:31,560
gives me the value on to now by the way

00:30:29,730 --> 00:30:33,900
down here I can say to you are all open

00:30:31,560 --> 00:30:35,760
I assert that you were called with these

00:30:33,900 --> 00:30:38,190
values because by the way in our

00:30:35,760 --> 00:30:39,810
previous example we didn't actually look

00:30:38,190 --> 00:30:41,310
at what our fake object got called with

00:30:39,810 --> 00:30:43,080
maybe the URL got broken in some

00:30:41,310 --> 00:30:44,460
refactoring and the actual code wouldn't

00:30:43,080 --> 00:30:46,050
would have failed where our mock would

00:30:44,460 --> 00:30:47,100
have succeeded here we can actually

00:30:46,050 --> 00:30:48,480
assert that we're getting called with

00:30:47,100 --> 00:30:51,930
the URL we thought we were being called

00:30:48,480 --> 00:30:53,790
with so now we've got mocking with no

00:30:51,930 --> 00:30:55,470
explicit set up we didn't have to write

00:30:53,790 --> 00:30:57,510
an implementation of something we simply

00:30:55,470 --> 00:30:59,790
had to make one out of this magic mock

00:30:57,510 --> 00:31:04,350
module and tell it what we wanted it to

00:30:59,790 --> 00:31:05,970
do the more the more comp of the the

00:31:04,350 --> 00:31:07,770
overarching term for all these things is

00:31:05,970 --> 00:31:09,450
test doubles which is kind of like stunt

00:31:07,770 --> 00:31:11,130
doubles in a movie if you take the star

00:31:09,450 --> 00:31:12,690
out and you put in some guy that you

00:31:11,130 --> 00:31:13,440
don't care about as much and let him do

00:31:12,690 --> 00:31:16,020
the hard work

00:31:13,440 --> 00:31:18,840
so this is very powerful it isolates our

00:31:16,020 --> 00:31:20,790
code right we've removed dependencies

00:31:18,840 --> 00:31:23,040
and focused in more and on smaller code

00:31:20,790 --> 00:31:24,570
it focuses our tests and it removes

00:31:23,040 --> 00:31:26,190
speed bumps and randomness a lot of

00:31:24,570 --> 00:31:27,660
times you'll take this do this approach

00:31:26,190 --> 00:31:28,920
not because it's not your code and you

00:31:27,660 --> 00:31:32,760
want to get it out but just because that

00:31:28,920 --> 00:31:34,380
code is slow the problem is it makes

00:31:32,760 --> 00:31:36,420
your tests fragile if you think about

00:31:34,380 --> 00:31:37,920
what we did the only reason our mocking

00:31:36,420 --> 00:31:39,660
worked is because we knew that the

00:31:37,920 --> 00:31:42,630
product code was calling URL Lib dot URL

00:31:39,660 --> 00:31:44,310
open if someone reef actors that product

00:31:42,630 --> 00:31:48,210
code to use the requests library instead

00:31:44,310 --> 00:31:49,620
these tests will all fail and by the way

00:31:48,210 --> 00:31:51,660
the product code will now be running out

00:31:49,620 --> 00:31:54,060
to yahoo.com to take a long time before

00:31:51,660 --> 00:31:55,590
it fails so we'll have lost all of the

00:31:54,060 --> 00:31:56,910
benefits so the only reason we could

00:31:55,590 --> 00:31:58,770
mock this stuff is because we knew

00:31:56,910 --> 00:32:00,660
enough about the implementation that we

00:31:58,770 --> 00:32:03,890
knew exactly how it worked inside and

00:32:00,660 --> 00:32:05,880
that's a dangerous situation to be in

00:32:03,890 --> 00:32:07,380
also by the way there's another way to

00:32:05,880 --> 00:32:10,500
do this called dependency injection

00:32:07,380 --> 00:32:11,970
which you should look into so there are

00:32:10,500 --> 00:32:13,680
too many things we can't talk up at them

00:32:11,970 --> 00:32:15,330
all testing is a big topic but I wanted

00:32:13,680 --> 00:32:16,500
to give you pointers and plant some

00:32:15,330 --> 00:32:18,960
words in your head about some other

00:32:16,500 --> 00:32:20,940
things add cleanup is a method on unit

00:32:18,960 --> 00:32:23,220
tests test case objects which is a nicer

00:32:20,940 --> 00:32:24,330
way to do things than teardown doc test

00:32:23,220 --> 00:32:26,070
is another thing you'll hear about in

00:32:24,330 --> 00:32:27,870
the standard library only use it for

00:32:26,070 --> 00:32:30,660
testing code that's already in your Docs

00:32:27,870 --> 00:32:31,950
if I hear about any one of you using doc

00:32:30,660 --> 00:32:33,330
tests or anything else I'm going to be

00:32:31,950 --> 00:32:35,520
mad because we've spent a lot of time

00:32:33,330 --> 00:32:39,540
here together and I expect you to listen

00:32:35,520 --> 00:32:41,130
to me knows and pee tests are better

00:32:39,540 --> 00:32:43,860
test runners that unit tests they have a

00:32:41,130 --> 00:32:45,600
lot of cool features like plugins DDT is

00:32:43,860 --> 00:32:47,250
a library lets you do data-driven tests

00:32:45,600 --> 00:32:48,840
so if you have one test method but you

00:32:47,250 --> 00:32:50,580
want to have 10 test cases out of it

00:32:48,840 --> 00:32:53,310
because of these different data it will

00:32:50,580 --> 00:32:54,980
do that for you coverage is a really

00:32:53,310 --> 00:32:57,120
awesome thing and you should use it

00:32:54,980 --> 00:32:59,250
selenium is the tool you'd use for in

00:32:57,120 --> 00:33:00,810
browser testing Jenkins and Travis are

00:32:59,250 --> 00:33:02,520
continuous integration servers which are

00:33:00,810 --> 00:33:03,930
way of having a place that you can push

00:33:02,520 --> 00:33:06,900
your code and it just runs your tests

00:33:03,930 --> 00:33:09,300
every time you make a change other

00:33:06,900 --> 00:33:11,970
topics TDD is writing tests before code

00:33:09,300 --> 00:33:13,410
which is very interesting BDD is a way

00:33:11,970 --> 00:33:14,760
of writing tests in a way that your

00:33:13,410 --> 00:33:16,460
business people can perhaps write your

00:33:14,760 --> 00:33:19,020
tests and focus on external behavior

00:33:16,460 --> 00:33:20,940
integration tests get at larger chunks

00:33:19,020 --> 00:33:23,220
of code which is a way of testing more

00:33:20,940 --> 00:33:24,690
realistic scenarios in your product load

00:33:23,220 --> 00:33:26,160
testing test about there's how much

00:33:24,690 --> 00:33:27,840
whether you have enough

00:33:26,160 --> 00:33:31,890
I see for your traffic and lots of other

00:33:27,840 --> 00:33:33,870
topics I'm sure so summing up how do we

00:33:31,890 --> 00:33:35,910
do we've learned that testing is

00:33:33,870 --> 00:33:38,370
complicated it's important but it's

00:33:35,910 --> 00:33:39,600
worthy and it's rewarding remember the

00:33:38,370 --> 00:33:40,710
two developers we had at the beginning

00:33:39,600 --> 00:33:44,460
of the talks we wanted them to be happy

00:33:40,710 --> 00:33:47,490
and confident here they are if you think

00:33:44,460 --> 00:33:49,110
testing is hard these drawings the two

00:33:47,490 --> 00:33:50,790
original drawings were drawn by my 16

00:33:49,110 --> 00:33:52,650
year old son if you think testing is

00:33:50,790 --> 00:33:59,450
hard try getting a 16 year old to draw

00:33:52,650 --> 00:33:59,450
you a third picture any questions

00:34:07,670 --> 00:34:14,030
how much time do we have questions about

00:34:09,620 --> 00:34:17,360
five minutes thank you for your talk

00:34:14,030 --> 00:34:21,190
what happens if finance EIU returns JSON

00:34:17,360 --> 00:34:21,190
instead of a CSV

00:34:21,290 --> 00:34:26,419
if Yahoo returns a gzip J'son instead of

00:34:23,990 --> 00:34:27,590
CSV oh well then that API has changed

00:34:26,419 --> 00:34:30,050
and your code is going to have to change

00:34:27,590 --> 00:34:31,450
okay so our days are going to pass but

00:34:30,050 --> 00:34:33,380
the applications are going to fail right

00:34:31,450 --> 00:34:34,790
exactly so that's one of the failures of

00:34:33,380 --> 00:34:36,919
the mock right is that we're assuming

00:34:34,790 --> 00:34:38,660
that we understand the interface to that

00:34:36,919 --> 00:34:40,400
mocked component well enough that we can

00:34:38,660 --> 00:34:42,410
replace it if that maths component

00:34:40,400 --> 00:34:44,210
changes in this case our product would

00:34:42,410 --> 00:34:45,950
also change so we're going to have to

00:34:44,210 --> 00:34:47,929
fix it either way but yeah there could

00:34:45,950 --> 00:34:49,040
be scenarios where it changes in a way

00:34:47,929 --> 00:34:51,260
that your product could would have been

00:34:49,040 --> 00:34:52,940
okay with but your test is now mimicking

00:34:51,260 --> 00:34:53,990
the old behavior and you've lost track

00:34:52,940 --> 00:34:58,340
of that that's one of the ways that

00:34:53,990 --> 00:35:00,770
mocks are really dangerous yeah thanks

00:34:58,340 --> 00:35:03,250
for the talk one of the things that I've

00:35:00,770 --> 00:35:07,190
run into as a barrier to get in is just

00:35:03,250 --> 00:35:10,730
into testing is getting all the pieces

00:35:07,190 --> 00:35:12,530
together and in the right place so a

00:35:10,730 --> 00:35:15,500
little bit blatant self-promotion I've

00:35:12,530 --> 00:35:18,080
made a github repo that has a Python

00:35:15,500 --> 00:35:19,520
unit test skeleton with dashes between

00:35:18,080 --> 00:35:21,260
them you can search for it that has a

00:35:19,520 --> 00:35:23,570
bunch of kind of boilerplate code you

00:35:21,260 --> 00:35:26,630
can take two to get up to speed much

00:35:23,570 --> 00:35:29,420
more quickly great so I find that super

00:35:26,630 --> 00:35:31,570
helpful to make the burden of getting

00:35:29,420 --> 00:35:33,920
into testing as small as possible

00:35:31,570 --> 00:35:38,780
fabulous Thanks Python unit test

00:35:33,920 --> 00:35:40,640
skeleton great all right so when I'm

00:35:38,780 --> 00:35:42,560
aiming for 100% coverage I often have

00:35:40,640 --> 00:35:44,750
trouble with the main method you have

00:35:42,560 --> 00:35:47,690
any advice on testing that make your

00:35:44,750 --> 00:35:49,550
main well first of all in the if dunder

00:35:47,690 --> 00:35:50,720
name equals dunder main yeah you should

00:35:49,550 --> 00:35:53,150
have one line of code in there which

00:35:50,720 --> 00:35:56,480
should be sistah exit of main of sistar

00:35:53,150 --> 00:35:58,580
V and then your main function is now a

00:35:56,480 --> 00:36:00,560
pure function that takes a list of

00:35:58,580 --> 00:36:02,690
arguments and returns a status code and

00:36:00,560 --> 00:36:04,310
you can test that right that just takes

00:36:02,690 --> 00:36:06,230
arguments and it takes a return value

00:36:04,310 --> 00:36:07,970
and then all of your connection to the

00:36:06,230 --> 00:36:10,000
external world happens in that one line

00:36:07,970 --> 00:36:12,710
and your dunder named under main and

00:36:10,000 --> 00:36:15,950
it's hard to mess up that line so you

00:36:12,710 --> 00:36:16,490
can just leave that alone that's my

00:36:15,950 --> 00:36:20,150
advice

00:36:16,490 --> 00:36:21,500
oh thanks two questions I've heard it

00:36:20,150 --> 00:36:25,070
said that dry doesn't apply to

00:36:21,500 --> 00:36:28,160
testing but when I see my co-worker just

00:36:25,070 --> 00:36:29,630
cut and paste one test to the next and I

00:36:28,160 --> 00:36:32,150
go back and something changes with the

00:36:29,630 --> 00:36:33,050
test it feels like it should be dry

00:36:32,150 --> 00:36:35,450
that's silly

00:36:33,050 --> 00:36:36,860
yeah well I have no idea why people

00:36:35,450 --> 00:36:39,920
would say that DRI shouldn't apply to

00:36:36,860 --> 00:36:41,840
testing i testing is one of those

00:36:39,920 --> 00:36:43,430
mysterious worlds where you will find

00:36:41,840 --> 00:36:45,590
experts and they will they will say

00:36:43,430 --> 00:36:48,380
things to you not me I can be trusted

00:36:45,590 --> 00:36:50,030
but there'll be other ones who will say

00:36:48,380 --> 00:36:51,200
these mysterious things and you will

00:36:50,030 --> 00:36:53,000
believe them because testing is

00:36:51,200 --> 00:36:54,650
mysterious but maybe they're wrong well

00:36:53,000 --> 00:36:57,170
I mean in one case where it makes sense

00:36:54,650 --> 00:36:59,330
to me is that once you start making your

00:36:57,170 --> 00:37:00,560
tests dry your tests become more complex

00:36:59,330 --> 00:37:02,000
and then don't you have to test your

00:37:00,560 --> 00:37:04,790
tests yeah you do

00:37:02,000 --> 00:37:06,890
right but testing all the way down yeah

00:37:04,790 --> 00:37:08,210
so I know why some temp of why they say

00:37:06,890 --> 00:37:09,980
they should be dry because some people

00:37:08,210 --> 00:37:11,630
like tests as sort of almost

00:37:09,980 --> 00:37:13,340
documentation of how things should work

00:37:11,630 --> 00:37:15,320
and they like a test case to be

00:37:13,340 --> 00:37:16,670
completely self-contained but if that

00:37:15,320 --> 00:37:19,160
means that you have the same ten lines

00:37:16,670 --> 00:37:20,930
setting up the same fixture that you're

00:37:19,160 --> 00:37:23,720
going to use in sixty tests that just

00:37:20,930 --> 00:37:25,730
seems silly to me okay and in the second

00:37:23,720 --> 00:37:27,920
part I still have problems with my

00:37:25,730 --> 00:37:29,570
reusable test data so I put some of it

00:37:27,920 --> 00:37:31,070
in the setup I put some of it in the

00:37:29,570 --> 00:37:32,870
individual tests and a little bit in

00:37:31,070 --> 00:37:34,310
fixtures which I see a lot of bad talk

00:37:32,870 --> 00:37:36,620
about fixtures and I experience that

00:37:34,310 --> 00:37:38,390
sometimes so any advice on where to put

00:37:36,620 --> 00:37:39,380
your reusable test data it's really

00:37:38,390 --> 00:37:42,680
going to depend I mean like I said

00:37:39,380 --> 00:37:44,270
testing is real engineering right if if

00:37:42,680 --> 00:37:46,790
I were talking up here talking about web

00:37:44,270 --> 00:37:48,050
performance people wouldn't say to me so

00:37:46,790 --> 00:37:49,340
what should I do to make my website fast

00:37:48,050 --> 00:37:51,440
right everyone knows that making

00:37:49,340 --> 00:37:52,550
websites fast is like serious work where

00:37:51,440 --> 00:37:54,650
you have to really consider all these

00:37:52,550 --> 00:37:56,270
complicated factors testing is exactly

00:37:54,650 --> 00:37:59,150
the same I don't know what your test

00:37:56,270 --> 00:38:00,230
data is or where you know I can't answer

00:37:59,150 --> 00:38:01,220
that question we're gonna have to sit

00:38:00,230 --> 00:38:02,630
down and really think about what

00:38:01,220 --> 00:38:04,820
problems you're facing and what the best

00:38:02,630 --> 00:38:06,320
solutions are in a well tested system

00:38:04,820 --> 00:38:09,260
it's not unusual to have more lines of

00:38:06,320 --> 00:38:11,060
tests than you have of product and why

00:38:09,260 --> 00:38:12,890
wouldn't that code be rich and complex

00:38:11,060 --> 00:38:14,030
and have thorny problems that you're not

00:38:12,890 --> 00:38:15,590
sure you solve the right way and you're

00:38:14,030 --> 00:38:17,150
going to go back and refactor etc etc

00:38:15,590 --> 00:38:20,090
it's engineering

00:38:17,150 --> 00:38:25,070
okay so JSON fixtures that's always

00:38:20,090 --> 00:38:27,830
gotta be there yeah it sounds great hi I

00:38:25,070 --> 00:38:30,080
have a pretty essential question you

00:38:27,830 --> 00:38:31,400
said that it's a good idea to reduce

00:38:30,080 --> 00:38:33,200
some of the modules that you're testing

00:38:31,400 --> 00:38:34,670
like if you've got eight that are all

00:38:33,200 --> 00:38:37,760
feeding into one test

00:38:34,670 --> 00:38:39,500
do you just mean to just stow the code

00:38:37,760 --> 00:38:41,810
somewhere else briefly and throw a pass

00:38:39,500 --> 00:38:42,560
in there so it'll just no go through a

00:38:41,810 --> 00:38:44,360
turn okay

00:38:42,560 --> 00:38:46,520
and the reason why is because that makes

00:38:44,360 --> 00:38:47,840
your tests hard to run right you don't

00:38:46,520 --> 00:38:49,430
want to have to edit your product code

00:38:47,840 --> 00:38:50,840
before you can run your tests you need

00:38:49,430 --> 00:38:52,610
to have an automated test that you can

00:38:50,840 --> 00:38:54,470
run it with the push of a button

00:38:52,610 --> 00:38:56,030
some people have it happen automatically

00:38:54,470 --> 00:38:57,320
when they save a file in their editor

00:38:56,030 --> 00:38:59,510
every time they there

00:38:57,320 --> 00:39:01,670
control s twitch comes in like the test

00:38:59,510 --> 00:39:03,530
is all run like what like Jenkins or

00:39:01,670 --> 00:39:05,540
Travis let you even know even more than

00:39:03,530 --> 00:39:08,150
that every time literally the file hits

00:39:05,540 --> 00:39:10,100
the disc their tests run so you want

00:39:08,150 --> 00:39:11,900
your tests to go as quickly as possible

00:39:10,100 --> 00:39:13,910
and as automatically as possible so when

00:39:11,900 --> 00:39:16,850
I say removing code I mean engineer the

00:39:13,910 --> 00:39:18,710
tests so that it reconfigures the system

00:39:16,850 --> 00:39:23,360
and finds just the code that it wants to

00:39:18,710 --> 00:39:24,620
test thank you but the test the session

00:39:23,360 --> 00:39:27,170
runner went away so we're going to be

00:39:24,620 --> 00:39:29,150
here all afternoon this was a very good

00:39:27,170 --> 00:39:31,160
talk thank you very much umm I saw a

00:39:29,150 --> 00:39:33,140
recording of a talk you gave a few years

00:39:31,160 --> 00:39:35,900
ago also on testing yes brought in the

00:39:33,140 --> 00:39:37,700
issue of testing the missile silo yeah

00:39:35,900 --> 00:39:40,460
what have you learned in the last few

00:39:37,700 --> 00:39:41,780
years about testing what have I learned

00:39:40,460 --> 00:39:43,610
I have learned if anything I've learned

00:39:41,780 --> 00:39:45,620
that it is even more complicated than I

00:39:43,610 --> 00:39:48,110
thought it was before that as your

00:39:45,620 --> 00:39:49,910
system gets complex your tests the tests

00:39:48,110 --> 00:39:52,670
seem to get complex faster than the

00:39:49,910 --> 00:39:54,950
system gets complex and that the more

00:39:52,670 --> 00:39:56,330
work you can put into attacking that

00:39:54,950 --> 00:39:59,090
problem early the better off you're

00:39:56,330 --> 00:40:04,660
going to be and I've learned about the

00:39:59,090 --> 00:40:06,740
downsides of mocking thank you sure okay

00:40:04,660 --> 00:40:08,480
I'm going to thanks like a great talk

00:40:06,740 --> 00:40:12,320
and thank you for the permission to

00:40:08,480 --> 00:40:14,630
refactor test to test tests yeah gotta

00:40:12,320 --> 00:40:17,900
try that as soon as possible yes I'm so

00:40:14,630 --> 00:40:19,400
uh my question is I've been starting to

00:40:17,900 --> 00:40:20,750
do unit testing and stuff and I've been

00:40:19,400 --> 00:40:23,330
and suddenly I've been forced into

00:40:20,750 --> 00:40:25,870
dependency injection land mm-hmm and so

00:40:23,330 --> 00:40:28,460
I wonder if you had any thoughts on

00:40:25,870 --> 00:40:29,780
mix-ins since we're in Python land here

00:40:28,460 --> 00:40:33,350
and we can have multiple inheritance

00:40:29,780 --> 00:40:36,140
versus dependency injection and what if

00:40:33,350 --> 00:40:37,880
you have any you know global thoughts on

00:40:36,140 --> 00:40:39,620
that whole concept well so dependency

00:40:37,880 --> 00:40:40,250
injection for for people who have an

00:40:39,620 --> 00:40:42,470
encounter the term

00:40:40,250 --> 00:40:44,240
means that the things you depend on like

00:40:42,470 --> 00:40:46,280
URL Lib that URL open that we used in

00:40:44,240 --> 00:40:47,930
the product code instead of it being an

00:40:46,280 --> 00:40:48,290
explicit reference to a module that we

00:40:47,930 --> 00:40:50,240
would

00:40:48,290 --> 00:40:52,520
keep patch by name it would be a thing

00:40:50,240 --> 00:40:54,620
passed in explicitly into the portfolio

00:40:52,520 --> 00:40:56,840
class on construction so the portfolio

00:40:54,620 --> 00:40:58,610
class when it was constructed would know

00:40:56,840 --> 00:40:59,990
when I need to talk to the network I

00:40:58,610 --> 00:41:01,190
have been given this thing and it will

00:40:59,990 --> 00:41:02,510
it's the thing I will use to talk to the

00:41:01,190 --> 00:41:03,920
network and that means that when you do

00:41:02,510 --> 00:41:05,210
your tests instead of doing weird monkey

00:41:03,920 --> 00:41:06,980
patching you can just pass in a

00:41:05,210 --> 00:41:08,990
different thing and you default it to

00:41:06,980 --> 00:41:10,730
URL URL open so that your real callers

00:41:08,990 --> 00:41:12,920
don't have to think about it

00:41:10,730 --> 00:41:14,360
the downside of dependency injection is

00:41:12,920 --> 00:41:15,860
that you're cluttering up the signatures

00:41:14,360 --> 00:41:17,420
of your methods with all sorts of weird

00:41:15,860 --> 00:41:19,160
stuff that starts with an underscore and

00:41:17,420 --> 00:41:20,720
the doc says don't we ever use this and

00:41:19,160 --> 00:41:23,720
weird stuff like that that's unfortunate

00:41:20,720 --> 00:41:24,950
and by the way it's hard to even get all

00:41:23,720 --> 00:41:26,990
of them and in a big system you don't

00:41:24,950 --> 00:41:29,000
want a hundred dependency injections

00:41:26,990 --> 00:41:31,010
makes sense I'm not sure how you'd use

00:41:29,000 --> 00:41:32,660
mix-ins for that because mix-ins are

00:41:31,010 --> 00:41:34,340
things that give you give you

00:41:32,660 --> 00:41:37,160
flexibility at the time you define a

00:41:34,340 --> 00:41:39,320
class but that means you'd have to

00:41:37,160 --> 00:41:41,740
define a different product class to get

00:41:39,320 --> 00:41:44,000
a mixin that has different dependencies

00:41:41,740 --> 00:41:45,560
so I guess we'd have to talk about how a

00:41:44,000 --> 00:41:46,760
mixin could solve that and maybe you can

00:41:45,560 --> 00:41:47,960
teach me something about it because I

00:41:46,760 --> 00:41:50,630
haven't encountered that as a way to

00:41:47,960 --> 00:41:52,280
solve the the dependency problem for

00:41:50,630 --> 00:41:54,200
during tests well for instance you you

00:41:52,280 --> 00:41:56,060
know you have your your hierarchy of the

00:41:54,200 --> 00:41:59,600
thing you're doing and then you just mix

00:41:56,060 --> 00:42:00,920
in URL live with it I see but and so but

00:41:59,600 --> 00:42:02,150
how do you get it out of it that's the

00:42:00,920 --> 00:42:04,700
thing that thing that you've derived

00:42:02,150 --> 00:42:06,770
from both your product code and URL open

00:42:04,700 --> 00:42:09,050
your a Lib now is the thing that you

00:42:06,770 --> 00:42:10,850
need to test or are you deriving a

00:42:09,050 --> 00:42:12,800
different thing that mixes in something

00:42:10,850 --> 00:42:14,840
else in which case you're creating new

00:42:12,800 --> 00:42:16,010
you're grading another right right so

00:42:14,840 --> 00:42:17,840
that's another way to do it right you

00:42:16,010 --> 00:42:20,000
could define a new class in your test

00:42:17,840 --> 00:42:24,100
which is your product code mixed in with

00:42:20,000 --> 00:42:26,240
the dependencies yes that sounds cool

00:42:24,100 --> 00:42:29,420
see you learn something that you do Mike

00:42:26,240 --> 00:42:31,430
on tox there's no one over there go

00:42:29,420 --> 00:42:34,220
alright it's mean it oh hi it's the

00:42:31,430 --> 00:42:36,080
runner yeah so we're out of time but I'd

00:42:34,220 --> 00:42:39,079
like to thank you thank you for a great

00:42:36,080 --> 00:42:41,140
talk and thank you to all our questions

00:42:39,079 --> 00:42:41,140

YouTube URL: https://www.youtube.com/watch?v=FxSsnHeWQBY


