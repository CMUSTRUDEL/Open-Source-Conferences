Title: Mike Bayer: Building the App - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Mike Bayer

"In this talk we'll illustrate a simple web application using SQLAlchemy, showing off the style of development that SQLAlchemy is most geared towards, the so-called ""foundational"" style which provides for development and maintainance of custom conventions which then service the needs of the model declarations and use case
 implementations."

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:04,319 --> 00:00:08,760
good afternoon everyone it's my pleasure

00:00:07,019 --> 00:00:11,490
to welcome Michael Baer a longtime

00:00:08,760 --> 00:00:12,959
speaker at PyCon and the creator of

00:00:11,490 --> 00:00:14,639
sequel alchemy he's going to be talking

00:00:12,959 --> 00:00:15,840
to us today about building apps web apps

00:00:14,639 --> 00:00:26,880
in seek welcome let's give him a big

00:00:15,840 --> 00:00:30,060
round of applause hi um I want to thank

00:00:26,880 --> 00:00:32,340
us we need Selina Declan and Jason Myers

00:00:30,060 --> 00:00:34,649
for doing great talks on psycho alchemy

00:00:32,340 --> 00:00:40,069
and el limbic right before me so we can

00:00:34,649 --> 00:00:44,699
pray for them it set me up to do the a

00:00:40,069 --> 00:00:46,559
the final talk for sequel alchemy um so

00:00:44,699 --> 00:00:47,909
it is called it's on the screen there

00:00:46,559 --> 00:00:54,929
look at that it's really big writing the

00:00:47,909 --> 00:00:57,389
app what does this talk about so this is

00:00:54,929 --> 00:01:00,059
about writing larger longer-lived

00:00:57,389 --> 00:01:02,999
applications with relational databases

00:01:00,059 --> 00:01:06,229
and sequel alchemy and how sequel

00:01:02,999 --> 00:01:09,810
alchemy deals with that kind of issue

00:01:06,229 --> 00:01:11,520
the foundation is what we call the the

00:01:09,810 --> 00:01:13,050
code that we write when we first plug in

00:01:11,520 --> 00:01:14,310
our foundation our frameworks and

00:01:13,050 --> 00:01:16,530
libraries so when you first start to

00:01:14,310 --> 00:01:18,000
write your app before you begin writing

00:01:16,530 --> 00:01:19,650
your use cases you have this thing that

00:01:18,000 --> 00:01:21,480
I call the foundation like your your

00:01:19,650 --> 00:01:23,970
data types that are special and other

00:01:21,480 --> 00:01:27,390
things to do with constraints and ORM

00:01:23,970 --> 00:01:29,940
patterns I think that having a healthy

00:01:27,390 --> 00:01:32,010
amount not too much of upfront code is a

00:01:29,940 --> 00:01:33,780
good thing rather than a failure of

00:01:32,010 --> 00:01:37,350
libraries and frameworks to do

00:01:33,780 --> 00:01:39,360
everything possible sequel alchemy is

00:01:37,350 --> 00:01:44,420
designed with being able to write these

00:01:39,360 --> 00:01:47,370
foundations in mind so how do we define

00:01:44,420 --> 00:01:49,140
what a foundation is and is not the

00:01:47,370 --> 00:01:50,550
foundation includes the technologies

00:01:49,140 --> 00:01:51,630
we're using like we're using flask or

00:01:50,550 --> 00:01:54,330
pyramid

00:01:51,630 --> 00:01:56,070
you know what libraries frameworks how

00:01:54,330 --> 00:01:59,670
we structure our directories name our

00:01:56,070 --> 00:02:02,100
files what kinds of architectural

00:01:59,670 --> 00:02:04,940
patterns we're going to be using how we

00:02:02,100 --> 00:02:09,599
build it out if we're using integrated

00:02:04,940 --> 00:02:10,979
testing configuration so the decisions

00:02:09,599 --> 00:02:13,889
we make when we do the foundation will

00:02:10,979 --> 00:02:15,150
determine when a new developer comes in

00:02:13,889 --> 00:02:16,680
the project what does that developer

00:02:15,150 --> 00:02:19,849
going to need to understand in order to

00:02:16,680 --> 00:02:19,849
add new features to your

00:02:20,070 --> 00:02:22,860
and it will kind of determine exactly

00:02:21,690 --> 00:02:24,000
what it's like when you start with hey

00:02:22,860 --> 00:02:25,860
the customer wants this new feature

00:02:24,000 --> 00:02:28,640
where do we start where do we do the

00:02:25,860 --> 00:02:32,280
middle and where do we end

00:02:28,640 --> 00:02:36,210
so here the italics around is or the

00:02:32,280 --> 00:02:38,250
foundation is it's the source files at

00:02:36,210 --> 00:02:39,960
the base of our application it's the the

00:02:38,250 --> 00:02:42,570
basis for patterns and idioms that we're

00:02:39,960 --> 00:02:45,980
going to repeat throughout the app it

00:02:42,570 --> 00:02:48,270
might be reusable in other applications

00:02:45,980 --> 00:02:49,830
and it represents kind of the way that

00:02:48,270 --> 00:02:52,110
we've adapted the frameworks and

00:02:49,830 --> 00:02:57,120
libraries we're using to the the task at

00:02:52,110 --> 00:03:00,140
hand is specific to what we're doing so

00:02:57,120 --> 00:03:05,400
the foundation is not a replacement for

00:03:00,140 --> 00:03:06,930
frameworks or libraries it's not the

00:03:05,400 --> 00:03:08,120
start of our company's new app platform

00:03:06,930 --> 00:03:09,720
it's not like we're writing our own

00:03:08,120 --> 00:03:11,430
amazing system that we're going to

00:03:09,720 --> 00:03:12,630
publish it's really meant to be specific

00:03:11,430 --> 00:03:14,610
to what you'll get what you're getting

00:03:12,630 --> 00:03:18,570
done it's about practicality versus

00:03:14,610 --> 00:03:22,200
trying to make some bigger thing not a

00:03:18,570 --> 00:03:24,060
reinvention of the wheel unless the

00:03:22,200 --> 00:03:27,540
wheels you have are terrible pretty

00:03:24,060 --> 00:03:29,520
obvious right so let's see a foundation

00:03:27,540 --> 00:03:34,890
and actually this slide is the plug for

00:03:29,520 --> 00:03:36,360
the pyramid web framework woohoo because

00:03:34,890 --> 00:03:38,850
we don't have any pyramid talks this

00:03:36,360 --> 00:03:40,770
year and then we have three sequel can

00:03:38,850 --> 00:03:42,060
we talk which is great but just I feel

00:03:40,770 --> 00:03:43,560
guilty that we have so many talks in

00:03:42,060 --> 00:03:45,210
pyramid has none so I actually like

00:03:43,560 --> 00:03:47,850
pyramid and the sample app we have here

00:03:45,210 --> 00:03:50,910
is a pyramid app I like about pyramid I

00:03:47,850 --> 00:03:52,500
really love the view renderer model this

00:03:50,910 --> 00:03:54,660
will you make up your View Function has

00:03:52,500 --> 00:03:56,640
a little decorator that says this view

00:03:54,660 --> 00:03:57,950
will talk to this template this kind of

00:03:56,640 --> 00:03:59,910
template you can actually have several

00:03:57,950 --> 00:04:03,510
renderer decorators I think that's

00:03:59,910 --> 00:04:06,300
really cool I think it's opinionated in

00:04:03,510 --> 00:04:10,020
the right places I like its emphasis on

00:04:06,300 --> 00:04:12,480
testability attention to detail and of

00:04:10,020 --> 00:04:15,330
course when I work with pyramid nothing

00:04:12,480 --> 00:04:16,709
ever works nothing ever breaks nothing

00:04:15,330 --> 00:04:19,140
ever does what you don't expect cuz

00:04:16,709 --> 00:04:21,420
pyramids components are like super duper

00:04:19,140 --> 00:04:24,140
industrial rock-solid and I always trust

00:04:21,420 --> 00:04:27,300
them 100% so which is really great and

00:04:24,140 --> 00:04:28,639
pyramid is of course curmudgeonly like

00:04:27,300 --> 00:04:31,300
me

00:04:28,639 --> 00:04:33,110
and then of course you don't have to use

00:04:31,300 --> 00:04:34,610
pyramid you know if you can write a

00:04:33,110 --> 00:04:41,060
foundation in any framework meaning you

00:04:34,610 --> 00:04:43,340
could also use flask all right so this

00:04:41,060 --> 00:04:45,379
is the link that I met just made public

00:04:43,340 --> 00:04:47,900
on bitbucket and hopefully that works so

00:04:45,379 --> 00:04:50,500
if you want to go so basically this talk

00:04:47,900 --> 00:04:52,250
if you want to go to this application

00:04:50,500 --> 00:04:53,689
everything I'm talking about is going to

00:04:52,250 --> 00:04:54,800
be in this app and you can download the

00:04:53,689 --> 00:04:56,270
app and you can run it and play with it

00:04:54,800 --> 00:04:58,189
and I'm going to have it up on the

00:04:56,270 --> 00:05:00,409
sequel alchemy site is kind of like the

00:04:58,189 --> 00:05:02,449
beginning of actually having sample apps

00:05:00,409 --> 00:05:07,189
like the pyramid tutorial has a sample

00:05:02,449 --> 00:05:09,020
app and this will be another one so I'm

00:05:07,189 --> 00:05:10,969
going to go to the next slide if you

00:05:09,020 --> 00:05:16,069
just go to my bit bucket Zeke you guys

00:05:10,969 --> 00:05:17,270
know the Zeke name right okay so an

00:05:16,069 --> 00:05:22,969
overview of what I'm going to try to

00:05:17,270 --> 00:05:26,449
cover the meta folder conventions and

00:05:22,969 --> 00:05:28,419
recipes session scoping which is the

00:05:26,449 --> 00:05:31,819
part that makes me nervous to talk about

00:05:28,419 --> 00:05:34,250
constraint naming a little bit on

00:05:31,819 --> 00:05:37,400
migrations not too much and then some

00:05:34,250 --> 00:05:38,930
thoughts I have on testing the meta

00:05:37,400 --> 00:05:42,319
folder is something that I got from

00:05:38,930 --> 00:05:43,580
first working with pylons when pylons

00:05:42,319 --> 00:05:47,419
would build out a project they'd have

00:05:43,580 --> 00:05:49,159
this file called meta py and I actually

00:05:47,419 --> 00:05:50,659
break it out into several files and I

00:05:49,159 --> 00:05:51,680
just from the from the minute I write

00:05:50,659 --> 00:05:54,020
the app I know there's going to be a

00:05:51,680 --> 00:05:57,349
metaphor which will have the foundation

00:05:54,020 --> 00:05:58,669
it'll have various files that are going

00:05:57,349 --> 00:06:01,819
to deal with the kinds of things I know

00:05:58,669 --> 00:06:03,500
that my app needs to worry about so the

00:06:01,819 --> 00:06:05,419
name of the app is HTM craf and it'll be

00:06:03,500 --> 00:06:06,830
like a model folder and then inside of

00:06:05,419 --> 00:06:08,379
model the first thing I put there is

00:06:06,830 --> 00:06:14,509
meta which is we're going to deal with

00:06:08,379 --> 00:06:16,759
database stuff in the abstract in there

00:06:14,509 --> 00:06:19,490
we have init py which provides names to

00:06:16,759 --> 00:06:21,589
import from the outside base py is

00:06:19,490 --> 00:06:25,099
fundamental units like your session your

00:06:21,589 --> 00:06:28,969
declarative base object relational

00:06:25,099 --> 00:06:32,210
mapping helpers a schema generation and

00:06:28,969 --> 00:06:35,919
definition helpers and then things to do

00:06:32,210 --> 00:06:35,919
with special datatypes

00:06:37,350 --> 00:06:44,130
so the first bars conventions / recipes

00:06:41,340 --> 00:06:45,390
I can't quite figure out the difference

00:06:44,130 --> 00:06:47,640
between a convention or recipe so

00:06:45,390 --> 00:06:50,310
they're kind of interchangeable the goal

00:06:47,640 --> 00:06:53,070
of a convention / recipe is to reduce as

00:06:50,310 --> 00:06:54,950
much repetition as possible in day to

00:06:53,070 --> 00:06:58,050
day code without taking it too far

00:06:54,950 --> 00:07:00,410
things we use for recipes or Python

00:06:58,050 --> 00:07:04,500
functions mix-ins sequel alchemy events

00:07:00,410 --> 00:07:05,790
compiles recipes custom types sequel

00:07:04,500 --> 00:07:07,050
alchemy is really oriented towards this

00:07:05,790 --> 00:07:08,580
kind of programming and constantly

00:07:07,050 --> 00:07:10,350
trying to make this system work better

00:07:08,580 --> 00:07:12,660
and more predictably it wasn't there in

00:07:10,350 --> 00:07:15,360
version 1 or 2 but as we've gone through

00:07:12,660 --> 00:07:19,020
version 7 8 9 it's getting more and more

00:07:15,360 --> 00:07:20,310
mature and predictable some recipes

00:07:19,020 --> 00:07:23,370
conventions become sequel alchemy

00:07:20,310 --> 00:07:24,750
features lots of them do why aren't

00:07:23,370 --> 00:07:27,600
these conventions in recipes part of

00:07:24,750 --> 00:07:28,920
sequel alchemy to start with well one

00:07:27,600 --> 00:07:31,680
place that we often draw the line is

00:07:28,920 --> 00:07:34,410
with naming things sequel alchemy really

00:07:31,680 --> 00:07:35,670
doesn't ever want to name anything it

00:07:34,410 --> 00:07:37,650
doesn't want to name your tables or your

00:07:35,670 --> 00:07:39,360
columns or your constraints so things to

00:07:37,650 --> 00:07:40,590
do with naming are typically not out of

00:07:39,360 --> 00:07:43,860
the box you've got to come up with some

00:07:40,590 --> 00:07:45,270
way to come up with names some

00:07:43,860 --> 00:07:49,260
conventions do become features or at

00:07:45,270 --> 00:07:51,810
least partially the project tries to uh

00:07:49,260 --> 00:07:52,950
you know we like features but we like to

00:07:51,810 --> 00:07:54,810
start with making something as a

00:07:52,950 --> 00:07:56,760
composable set of components that you

00:07:54,810 --> 00:07:58,950
can kind of build mix and match

00:07:56,760 --> 00:08:01,020
different things out of them rather than

00:07:58,950 --> 00:08:02,460
just a flag like do this we'd rather you

00:08:01,020 --> 00:08:04,020
come up with a recipe for like do this

00:08:02,460 --> 00:08:05,910
thing or maybe this or someone else

00:08:04,020 --> 00:08:08,550
could adapt it do that we think that's

00:08:05,910 --> 00:08:10,650
more flexible and open ended and the

00:08:08,550 --> 00:08:14,580
fullest the philosophy here is if you

00:08:10,650 --> 00:08:18,960
you know the famous proverb give someone

00:08:14,580 --> 00:08:20,610
a fish and feed them for a day or give

00:08:18,960 --> 00:08:24,300
someone an event listens for a fish

00:08:20,610 --> 00:08:26,520
available hook and then you can fish for

00:08:24,300 --> 00:08:32,030
all the applications you want or

00:08:26,520 --> 00:08:32,030
something like that more jokes to come

00:08:34,340 --> 00:08:38,630
this is a really really simple

00:08:35,920 --> 00:08:40,010
convention that I actually use it's it

00:08:38,630 --> 00:08:42,200
there are more complicated versions of

00:08:40,010 --> 00:08:43,340
this that are more flexible but this is

00:08:42,200 --> 00:08:46,070
a simple one you want all of your

00:08:43,340 --> 00:08:49,310
classes to have a primary key that's an

00:08:46,070 --> 00:08:51,820
integer surrogate ID sequel alchemy with

00:08:49,310 --> 00:08:54,860
declarative lets you make a mixing class

00:08:51,820 --> 00:08:56,780
that has ID so every if you any class

00:08:54,860 --> 00:08:59,180
that you apply surrogate PK to here will

00:08:56,780 --> 00:09:00,950
have an ID column and then any class

00:08:59,180 --> 00:09:03,650
that wants to refer to another surrogate

00:09:00,950 --> 00:09:05,270
pk can have a function you'll see in a

00:09:03,650 --> 00:09:07,340
second how to use this call a reference

00:09:05,270 --> 00:09:08,720
call that will make another column with

00:09:07,340 --> 00:09:11,240
a foreign key that points to your ID

00:09:08,720 --> 00:09:13,160
column and this is very obviously kind

00:09:11,240 --> 00:09:15,320
of hard-coded there's more flexible

00:09:13,160 --> 00:09:17,570
versions that are actually in the app if

00:09:15,320 --> 00:09:20,570
you do this surrogate PK reference call

00:09:17,570 --> 00:09:22,670
thing it looks like this so you might

00:09:20,570 --> 00:09:25,670
have a class excuse me called count

00:09:22,670 --> 00:09:28,430
balance that subclasses your declared a

00:09:25,670 --> 00:09:31,550
base and the surrogate PK and it has a

00:09:28,430 --> 00:09:33,230
table name and then you have a reference

00:09:31,550 --> 00:09:36,920
call to another table called balance

00:09:33,230 --> 00:09:38,840
type and then as a lot of you might know

00:09:36,920 --> 00:09:41,410
sequel alchemy has the relationships by

00:09:38,840 --> 00:09:43,460
default separate from the foreign keys

00:09:41,410 --> 00:09:44,810
so we have balance type is a

00:09:43,460 --> 00:09:47,410
relationship to the balance type class

00:09:44,810 --> 00:09:51,170
so this is a little bit better than

00:09:47,410 --> 00:09:53,120
having explicit ID equals column in the

00:09:51,170 --> 00:09:54,950
juror primary key equals true balance

00:09:53,120 --> 00:09:56,570
type ID equals column foreign key

00:09:54,950 --> 00:09:58,730
balance stays a little less verbose a

00:09:56,570 --> 00:10:00,830
little more repeatable and less things

00:09:58,730 --> 00:10:02,210
to type and and more importantly less

00:10:00,830 --> 00:10:05,600
things to change if you want to change

00:10:02,210 --> 00:10:07,070
how you do things this is a really

00:10:05,600 --> 00:10:09,710
really simple quick quick and dirty

00:10:07,070 --> 00:10:12,140
pattern the example app has this pattern

00:10:09,710 --> 00:10:13,430
which the implementation is a little bit

00:10:12,140 --> 00:10:16,330
more complicated so I don't want to put

00:10:13,430 --> 00:10:20,420
on a slide but this is the you know

00:10:16,330 --> 00:10:23,120
elusive many-to-one relationship so what

00:10:20,420 --> 00:10:25,520
many no one does is a function that does

00:10:23,120 --> 00:10:28,190
does basically what you see here which

00:10:25,520 --> 00:10:29,750
does basically what you see here so and

00:10:28,190 --> 00:10:31,730
I wrote a blog post about this years ago

00:10:29,750 --> 00:10:34,130
that sequel alchemy I called it magic a

00:10:31,730 --> 00:10:35,900
new ORM and it really wasn't a new era

00:10:34,130 --> 00:10:38,060
it was just using recipes on top of

00:10:35,900 --> 00:10:39,980
sequel alchemy to make it less verbose

00:10:38,060 --> 00:10:44,090
and and come up with recipes that work

00:10:39,980 --> 00:10:45,770
for your use case at hand and actually

00:10:44,090 --> 00:10:47,210
the many-to-one one-to-many I've come up

00:10:45,770 --> 00:10:48,260
with the recipe now that's so cool that

00:10:47,210 --> 00:10:50,000
I probably will edit this

00:10:48,260 --> 00:10:51,590
welcoming but you get the point is that

00:10:50,000 --> 00:10:53,150
you can if you think see Glock is

00:10:51,590 --> 00:10:55,430
verbose you should try to come up with

00:10:53,150 --> 00:10:59,480
patterns to kind of reduce how much

00:10:55,430 --> 00:11:01,250
typing based on the app at hand another

00:10:59,480 --> 00:11:02,780
example of conventions are when your

00:11:01,250 --> 00:11:05,210
database you're targeting more than one

00:11:02,780 --> 00:11:06,440
database or chart in just one database

00:11:05,210 --> 00:11:07,430
and they have some kind of sequel

00:11:06,440 --> 00:11:11,330
function that you want to just have a

00:11:07,430 --> 00:11:14,270
Python object that represents it like I

00:11:11,330 --> 00:11:18,290
often want to do the current time on a

00:11:14,270 --> 00:11:19,670
database but in UTC and if I'm targeting

00:11:18,290 --> 00:11:21,260
Postgres and sequel server they have

00:11:19,670 --> 00:11:23,720
completely different functions that do

00:11:21,260 --> 00:11:25,070
this and Postgres has as far as I know

00:11:23,720 --> 00:11:28,100
this you have to do this whole current

00:11:25,070 --> 00:11:29,570
timestamp at timezone UTC stuff so if

00:11:28,100 --> 00:11:31,400
you have things like this with your

00:11:29,570 --> 00:11:34,550
database you can make your own little

00:11:31,400 --> 00:11:36,380
quick ad hoc functions and use the C

00:11:34,550 --> 00:11:38,660
quality compiler extension which is

00:11:36,380 --> 00:11:40,610
documented on the site to come up with

00:11:38,660 --> 00:11:42,800
little functional things like this so

00:11:40,610 --> 00:11:45,710
that when you use the UTC now function

00:11:42,800 --> 00:11:47,600
it will resolve to the current timestamp

00:11:45,710 --> 00:11:50,720
at time zone on Postgres and it will

00:11:47,600 --> 00:11:52,130
resolve to get UTC date on sequel server

00:11:50,720 --> 00:11:54,710
and then if other databases are

00:11:52,130 --> 00:11:55,820
available by default it'll raise and

00:11:54,710 --> 00:11:59,300
then you have to implement how that

00:11:55,820 --> 00:12:00,830
would be done for other databases to UTC

00:11:59,300 --> 00:12:01,880
now is another function that maybe we

00:12:00,830 --> 00:12:03,860
should add the sequel because it's

00:12:01,880 --> 00:12:05,210
pretty common but the concept here is if

00:12:03,860 --> 00:12:07,310
you have some other weird function

00:12:05,210 --> 00:12:13,190
you're using you can you can use that as

00:12:07,310 --> 00:12:16,460
well using that recipe we can execute a

00:12:13,190 --> 00:12:18,380
select statement select UTC now we can

00:12:16,460 --> 00:12:20,630
use UTC now as the default in a column

00:12:18,380 --> 00:12:22,550
so like created at means that every time

00:12:20,630 --> 00:12:27,920
a row is inserted into orders you'll get

00:12:22,550 --> 00:12:29,930
a default timestamp and create adapt and

00:12:27,920 --> 00:12:34,460
then another way to do conventions is

00:12:29,930 --> 00:12:38,990
with events when you build up sequel

00:12:34,460 --> 00:12:41,090
alchemy metadata you attach the table

00:12:38,990 --> 00:12:43,160
and columns and metadata things together

00:12:41,090 --> 00:12:45,920
as those things are connected together

00:12:43,160 --> 00:12:49,090
sequel alchemy omits events that you can

00:12:45,920 --> 00:12:52,070
intercept and do things when they happen

00:12:49,090 --> 00:12:54,950
the most useful for in that regard is

00:12:52,070 --> 00:12:57,770
after parent attach it happens when you

00:12:54,950 --> 00:13:00,470
connect a column to a table or a table

00:12:57,770 --> 00:13:01,590
to a metadata and constraints to a table

00:13:00,470 --> 00:13:03,750
things like that

00:13:01,590 --> 00:13:06,480
this recipe will add columns to all the

00:13:03,750 --> 00:13:08,280
tables that will store the row they

00:13:06,480 --> 00:13:11,730
created at time for a row and the

00:13:08,280 --> 00:13:12,840
updated at time for a row and this is a

00:13:11,730 --> 00:13:15,270
way that instead of having all your

00:13:12,840 --> 00:13:16,950
tables have these columns explicitly you

00:13:15,270 --> 00:13:19,200
can use an event and just stick them on

00:13:16,950 --> 00:13:25,500
as each table gets created so that's a

00:13:19,200 --> 00:13:26,670
recipe custom types everyone well not

00:13:25,500 --> 00:13:27,900
everyone but a lot of people use custom

00:13:26,670 --> 00:13:29,250
types they're very handy for when you

00:13:27,900 --> 00:13:31,470
have some kind of special Python

00:13:29,250 --> 00:13:33,360
behavior to take effect for a value

00:13:31,470 --> 00:13:34,620
that's going to the database and often

00:13:33,360 --> 00:13:38,730
I'll use this one the bcrypt

00:13:34,620 --> 00:13:40,350
password type as data goes out to the

00:13:38,730 --> 00:13:43,290
database it is run through bcrypt

00:13:40,350 --> 00:13:45,240
first as data comes back from the

00:13:43,290 --> 00:13:47,670
database it is wrapped with a wrapper

00:13:45,240 --> 00:13:50,310
class called password that will do

00:13:47,670 --> 00:13:51,780
comparisons using bcrypt so this is you

00:13:50,310 --> 00:13:52,800
can try this out on the app as well and

00:13:51,780 --> 00:13:55,800
if you want to see what this thing looks

00:13:52,800 --> 00:13:57,900
like it means you can kind of add rows

00:13:55,800 --> 00:13:59,640
to the database without dealing with

00:13:57,900 --> 00:14:02,010
bcrypt at all you just put your secret

00:13:59,640 --> 00:14:04,020
I'm a secret and it will insert as a

00:14:02,010 --> 00:14:06,330
decrypted value and then when you query

00:14:04,020 --> 00:14:08,010
for a client record that has the

00:14:06,330 --> 00:14:12,600
identifier that we want snowflake in

00:14:08,010 --> 00:14:14,850
this case we can just compare the secret

00:14:12,600 --> 00:14:17,070
field which is actually the decrypted

00:14:14,850 --> 00:14:18,480
version you can't read it it's not

00:14:17,070 --> 00:14:22,110
plaintext at all the plaintext is gone

00:14:18,480 --> 00:14:23,670
to a plaintext password the Equality

00:14:22,110 --> 00:14:26,460
comparison here will actually run the

00:14:23,670 --> 00:14:28,560
I'm a secret token through bcrypt before

00:14:26,460 --> 00:14:29,580
doing the comparison so using a sequel

00:14:28,560 --> 00:14:32,400
alchemy custom type in a little

00:14:29,580 --> 00:14:35,100
ingenuity you can you can have this

00:14:32,400 --> 00:14:39,930
transparent encryption of passwords

00:14:35,100 --> 00:14:42,300
one-way encryption so that's the end of

00:14:39,930 --> 00:14:46,200
recipes and conventions there's more in

00:14:42,300 --> 00:14:48,930
the sample app to be looked at and then

00:14:46,200 --> 00:14:51,230
the part which is more concerning to me

00:14:48,930 --> 00:14:52,950
a session scoping because I'm just

00:14:51,230 --> 00:14:54,330
always trying to get people to

00:14:52,950 --> 00:14:56,310
understand session scoping it's just

00:14:54,330 --> 00:14:58,260
really hard to do so the sequel alchemy

00:14:56,310 --> 00:15:00,390
object relational mapper defines access

00:14:58,260 --> 00:15:03,360
through a central object known as the

00:15:00,390 --> 00:15:04,710
session and when we write a web

00:15:03,360 --> 00:15:06,560
application there's two things we need

00:15:04,710 --> 00:15:09,180
to really worry about with the session

00:15:06,560 --> 00:15:11,910
where do we get it when we handle a

00:15:09,180 --> 00:15:13,680
request and when the request is over or

00:15:11,910 --> 00:15:14,920
where does it where does it go and also

00:15:13,680 --> 00:15:19,660
how do we in this

00:15:14,920 --> 00:15:21,519
was it in the first place so the Pat

00:15:19,660 --> 00:15:23,620
does a lot of ways to do this I'm going

00:15:21,519 --> 00:15:26,620
to show three patterns for how to how to

00:15:23,620 --> 00:15:27,700
get the session during a request the

00:15:26,620 --> 00:15:29,350
method that most people are very

00:15:27,700 --> 00:15:32,649
familiar with and everyone uses is

00:15:29,350 --> 00:15:34,750
called the scope session the scope

00:15:32,649 --> 00:15:37,209
session is basically a wrapper around a

00:15:34,750 --> 00:15:38,920
Python thread-local which means that

00:15:37,209 --> 00:15:40,480
when you talk to scope session and you

00:15:38,920 --> 00:15:43,209
say hey mister scope session can I have

00:15:40,480 --> 00:15:45,459
a session please it will consult a

00:15:43,209 --> 00:15:46,920
Python thread local variable and return

00:15:45,459 --> 00:15:49,750
for you a session object that is

00:15:46,920 --> 00:15:50,829
specific to the current thread if you're

00:15:49,750 --> 00:15:53,079
in a different thread you'll get a

00:15:50,829 --> 00:15:55,420
different session and that's really all

00:15:53,079 --> 00:15:56,709
it does and this assumes that the web

00:15:55,420 --> 00:15:59,050
framework you're using is going to

00:15:56,709 --> 00:16:00,910
basically have one request per thread at

00:15:59,050 --> 00:16:02,350
a time meaning it won't work if you're

00:16:00,910 --> 00:16:04,690
using like tornado where you have

00:16:02,350 --> 00:16:10,410
multiple requests in one thread that are

00:16:04,690 --> 00:16:12,790
mixed up so if your web system a keys a

00:16:10,410 --> 00:16:14,920
request to threads you can use the scope

00:16:12,790 --> 00:16:16,630
session and just have a session as local

00:16:14,920 --> 00:16:18,310
to the thread and that will work fine

00:16:16,630 --> 00:16:20,709
and this is very common and I use this

00:16:18,310 --> 00:16:23,079
and everyone uses this is very common

00:16:20,709 --> 00:16:25,449
another variants on that is you can also

00:16:23,079 --> 00:16:30,730
use scope session not using a thread

00:16:25,449 --> 00:16:32,410
local at least not directly you can send

00:16:30,730 --> 00:16:34,660
the scope session a function called the

00:16:32,410 --> 00:16:36,490
scope func which is a function that will

00:16:34,660 --> 00:16:38,050
give the session the scope session

00:16:36,490 --> 00:16:41,350
registry some kind of token it can use

00:16:38,050 --> 00:16:43,630
to key to get the current session so

00:16:41,350 --> 00:16:45,360
with pyramid you can use a function that

00:16:43,630 --> 00:16:47,649
they provide called get current request

00:16:45,360 --> 00:16:49,300
which for it was still using a thread

00:16:47,649 --> 00:16:51,310
local but not within C clock me using it

00:16:49,300 --> 00:16:52,980
within pyramid which by the way they

00:16:51,310 --> 00:16:55,149
hate thread locals but this will work

00:16:52,980 --> 00:16:57,819
you can say from pyramid thread level

00:16:55,149 --> 00:16:59,740
import get current request please give

00:16:57,819 --> 00:17:01,870
me the request for the current thread

00:16:59,740 --> 00:17:03,250
and then please give me the session that

00:17:01,870 --> 00:17:05,319
scoped to that request so you can do

00:17:03,250 --> 00:17:07,809
this too and have Pyramid do the thread

00:17:05,319 --> 00:17:09,579
local stuff instead of you and if you

00:17:07,809 --> 00:17:12,640
had a web framework that didn't have a

00:17:09,579 --> 00:17:14,230
thread local request model this would

00:17:12,640 --> 00:17:16,360
also work like if you had a tornado

00:17:14,230 --> 00:17:17,949
function called get current request you

00:17:16,360 --> 00:17:19,720
could use scope session with tornado and

00:17:17,949 --> 00:17:22,360
this would probably work although I

00:17:19,720 --> 00:17:24,329
haven't tried it and then the third

00:17:22,360 --> 00:17:26,770
method is don't use scope session at all

00:17:24,329 --> 00:17:28,190
don't do any kind of global stuff like

00:17:26,770 --> 00:17:30,380
that you know when you work with pyramid

00:17:28,190 --> 00:17:34,280
is always a request object let's just

00:17:30,380 --> 00:17:36,440
put the session directly on to the

00:17:34,280 --> 00:17:38,330
pyramid request as an attribute because

00:17:36,440 --> 00:17:39,530
everything we do in our app is already

00:17:38,330 --> 00:17:40,460
has the request let's just skip the

00:17:39,530 --> 00:17:42,590
session from there and then there's no

00:17:40,460 --> 00:17:45,800
more thread-local anything and then you

00:17:42,590 --> 00:17:51,170
are on the good side of Chris mcdonoughs

00:17:45,800 --> 00:17:52,490
temper so yeah so you can say in pyramid

00:17:51,170 --> 00:17:53,750
they have an event called new request it

00:17:52,490 --> 00:17:55,250
gets fired every time as a new request

00:17:53,750 --> 00:17:56,650
so hey

00:17:55,250 --> 00:17:58,820
pyramid every time is a new request

00:17:56,650 --> 00:18:01,040
let's create a new sequel alchemy

00:17:58,820 --> 00:18:01,670
session and stick it on to your request

00:18:01,040 --> 00:18:02,900
and that's it

00:18:01,670 --> 00:18:04,940
that's how it works so you can do that

00:18:02,900 --> 00:18:07,070
too I like the thread-local thing

00:18:04,940 --> 00:18:08,630
because I don't feel like having being

00:18:07,070 --> 00:18:13,910
required to have the request everywhere

00:18:08,630 --> 00:18:15,470
all the time but suit yourself so after

00:18:13,910 --> 00:18:16,880
those three methods of acquiring the

00:18:15,470 --> 00:18:19,190
session how do we get rid of the session

00:18:16,880 --> 00:18:21,260
at the end every web framework has some

00:18:19,190 --> 00:18:24,950
kind of hook at the end of a request to

00:18:21,260 --> 00:18:27,140
clean things up this isn't a sequel

00:18:24,950 --> 00:18:30,020
alchemy Doc's I think everyone knows it

00:18:27,140 --> 00:18:33,410
when your request is over do a finished

00:18:30,020 --> 00:18:36,730
callback that we'll call session dot

00:18:33,410 --> 00:18:39,260
close or scoped session dot remove

00:18:36,730 --> 00:18:40,760
everyone should you know be aware this

00:18:39,260 --> 00:18:43,700
is in the docs it's like kind of web

00:18:40,760 --> 00:18:47,060
framework 101 and that's the end of the

00:18:43,700 --> 00:18:48,350
terrible session scoping section because

00:18:47,060 --> 00:18:50,750
it just says I think it's really simple

00:18:48,350 --> 00:18:53,510
and and it's just wow people have so

00:18:50,750 --> 00:18:55,310
much problems with that constraint

00:18:53,510 --> 00:18:57,650
naming some new features in seek

00:18:55,310 --> 00:19:01,970
Wakeeney database constraints like

00:18:57,650 --> 00:19:03,680
foreign keys indexes uniques etc have

00:19:01,970 --> 00:19:04,970
names so that you can target them in

00:19:03,680 --> 00:19:07,280
your migration scripts when you want to

00:19:04,970 --> 00:19:10,700
create new ones or drop existing ones

00:19:07,280 --> 00:19:11,750
and change what they have controlling

00:19:10,700 --> 00:19:13,130
these names like having all your

00:19:11,750 --> 00:19:14,380
constraints named explicitly is a good

00:19:13,130 --> 00:19:17,690
idea but it's very tedious to do

00:19:14,380 --> 00:19:19,130
manually and sequel alchemy as you know

00:19:17,690 --> 00:19:20,300
doesn't provide any names because Seco

00:19:19,130 --> 00:19:21,950
alchemy doesn't want to do names it

00:19:20,300 --> 00:19:24,860
doesn't want to tell your DBA is your

00:19:21,950 --> 00:19:27,020
grumpy DNA DBA is what to name their

00:19:24,860 --> 00:19:27,980
stuff so seek wants to do it but it

00:19:27,020 --> 00:19:30,830
doesn't want you to have a hard time

00:19:27,980 --> 00:19:32,030
it'll give you easier ways to do it we

00:19:30,830 --> 00:19:34,270
can make names automatically using

00:19:32,030 --> 00:19:37,400
schema events specifically that after

00:19:34,270 --> 00:19:40,310
DDL attach thing after parent attach

00:19:37,400 --> 00:19:42,170
event I showed you earlier um however

00:19:40,310 --> 00:19:43,610
sequel alchemy is now made

00:19:42,170 --> 00:19:45,490
there's a very common convention to use

00:19:43,610 --> 00:19:48,410
events to create names for your

00:19:45,490 --> 00:19:49,700
constraints and and other things we've

00:19:48,410 --> 00:19:52,100
added a new feature called naming

00:19:49,700 --> 00:19:53,990
convention which allows you to set up a

00:19:52,100 --> 00:19:56,780
naming convention up front with your

00:19:53,990 --> 00:19:58,700
metadata and that will do the event

00:19:56,780 --> 00:20:02,780
thing for you so now in sequel alchemy 0

00:19:58,700 --> 00:20:05,799
9 2 dash 0 9 4 meaning we fix the bugs

00:20:02,780 --> 00:20:08,780
with it as of 0 9 for most of the bugs

00:20:05,799 --> 00:20:10,670
you can make up this little dictionary

00:20:08,780 --> 00:20:12,559
with your metadata that has a bunch of

00:20:10,670 --> 00:20:15,320
string templates that will apply names

00:20:12,559 --> 00:20:16,700
to a lot of the common constraint

00:20:15,320 --> 00:20:20,210
objects like primary key foreign key

00:20:16,700 --> 00:20:21,830
uniques checks and indexes so when you

00:20:20,210 --> 00:20:23,500
use a convention like this one here and

00:20:21,830 --> 00:20:25,760
you can read the docs for how it works

00:20:23,500 --> 00:20:28,490
your create tables will look like this

00:20:25,760 --> 00:20:30,020
where you get all this handy you can see

00:20:28,490 --> 00:20:31,100
all the constraints are named explicitly

00:20:30,020 --> 00:20:33,559
and so when you write your Olympic

00:20:31,100 --> 00:20:35,360
migrations everything that you want to

00:20:33,559 --> 00:20:37,190
target has a name if you want to drop a

00:20:35,360 --> 00:20:39,160
primary key and recreate it you know the

00:20:37,190 --> 00:20:41,000
name the name isn't the weird

00:20:39,160 --> 00:20:43,730
auto-generated name that your back-end

00:20:41,000 --> 00:20:45,140
database might to you know and if you're

00:20:43,730 --> 00:20:46,490
switching between different backends

00:20:45,140 --> 00:20:47,780
different databases have different

00:20:46,490 --> 00:20:49,490
naming conventions built in so this is a

00:20:47,780 --> 00:20:49,940
way to override them does that make

00:20:49,490 --> 00:20:57,169
sense

00:20:49,940 --> 00:21:01,510
good if using Alembic this is a really

00:20:57,169 --> 00:21:03,830
squeaky stage can you hear that squeaky

00:21:01,510 --> 00:21:05,510
generate olympic migration uh we just

00:21:03,830 --> 00:21:08,950
had a great talk on olympic migration so

00:21:05,510 --> 00:21:11,419
i'm sure you all know olympic fully now

00:21:08,950 --> 00:21:13,429
create Olympic meaning what we're doing

00:21:11,419 --> 00:21:15,350
here is if you you can basically have a

00:21:13,429 --> 00:21:19,190
limbic look at your database as it

00:21:15,350 --> 00:21:20,809
exists right now and look at your class

00:21:19,190 --> 00:21:22,940
metadata as it exists and it will

00:21:20,809 --> 00:21:25,160
compare them and it will generate a new

00:21:22,940 --> 00:21:28,850
migration script based on the diff of

00:21:25,160 --> 00:21:30,740
those things this is a pretty it works

00:21:28,850 --> 00:21:32,090
well but not perfectly we want you to

00:21:30,740 --> 00:21:33,640
modify this we want you to check the

00:21:32,090 --> 00:21:36,320
script it's not perfect by any means but

00:21:33,640 --> 00:21:38,179
this now if you get the latest Olympic

00:21:36,320 --> 00:21:40,370
and two o'clock news here nine four it

00:21:38,179 --> 00:21:42,080
integrates with the naming convention

00:21:40,370 --> 00:21:44,150
feature very nicely so that you'll get a

00:21:42,080 --> 00:21:46,760
migration script with those naming

00:21:44,150 --> 00:21:51,080
conventions explicitly written out in

00:21:46,760 --> 00:21:53,330
your migration so the only pointer is

00:21:51,080 --> 00:21:54,980
that Olympic now integrates with the

00:21:53,330 --> 00:21:57,309
naming convention feature in a better

00:21:54,980 --> 00:21:59,899
way than it did before

00:21:57,309 --> 00:22:02,179
upcoming features for Olympic and Selena

00:21:59,899 --> 00:22:04,579
talked about this a little bit multiple

00:22:02,179 --> 00:22:06,919
version directories automatic branch

00:22:04,579 --> 00:22:10,039
resolution kind of like a merge and it's

00:22:06,919 --> 00:22:13,279
actually pretty easy to do the versions

00:22:10,039 --> 00:22:16,489
of Olympic right now are a linear list

00:22:13,279 --> 00:22:19,069
so it's like version a version B version

00:22:16,489 --> 00:22:20,719
scene is a straight linked list and now

00:22:19,069 --> 00:22:22,279
it's going to be is well when we do the

00:22:20,719 --> 00:22:24,319
feature it'll be more of a directed

00:22:22,279 --> 00:22:28,579
graph where any version file can have

00:22:24,319 --> 00:22:30,440
any number of parents and that's Alembic

00:22:28,579 --> 00:22:35,359
okay and once at the lightning round

00:22:30,440 --> 00:22:36,799
which is testing and I've come up with

00:22:35,359 --> 00:22:42,529
some interesting things about testing

00:22:36,799 --> 00:22:43,909
that I want to show you so for testing

00:22:42,529 --> 00:22:45,199
database enabled models there's two

00:22:43,909 --> 00:22:46,819
approaches now there's one approach that

00:22:45,199 --> 00:22:47,989
we've done for a long time which is the

00:22:46,819 --> 00:22:50,749
transactional approach that's in a

00:22:47,989 --> 00:22:53,359
sequel to me Docs and recently on the

00:22:50,749 --> 00:22:54,859
job I had a client who wanted to do a

00:22:53,359 --> 00:22:57,109
lot of tests that are against their

00:22:54,859 --> 00:22:58,459
model classes but they wanted to be able

00:22:57,109 --> 00:23:01,579
to run them without there being a

00:22:58,459 --> 00:23:03,319
database available so I worked up a new

00:23:01,579 --> 00:23:05,779
system which is called the mock approach

00:23:03,319 --> 00:23:08,179
and I think the mock approach is really

00:23:05,779 --> 00:23:10,749
neat it's a little more tedious but it's

00:23:08,179 --> 00:23:12,829
kind of cool and maybe next year I'll

00:23:10,749 --> 00:23:13,849
think mock is awesome I think right now

00:23:12,829 --> 00:23:17,569
it's interesting

00:23:13,849 --> 00:23:18,619
so transact and so basically the goal of

00:23:17,569 --> 00:23:21,499
testing here is we want to be able to

00:23:18,619 --> 00:23:23,209
test our model classes and the model

00:23:21,499 --> 00:23:25,879
classes really need to be able to query

00:23:23,209 --> 00:23:29,239
against the database to do things how do

00:23:25,879 --> 00:23:30,829
we test those classes so in the

00:23:29,239 --> 00:23:34,609
transactional model this is in our

00:23:30,829 --> 00:23:37,039
documentation what we do is we basically

00:23:34,609 --> 00:23:38,989
have the test run in a database

00:23:37,039 --> 00:23:41,479
transaction and when the test is

00:23:38,989 --> 00:23:43,579
complete and tears down the transaction

00:23:41,479 --> 00:23:44,359
is rolled back anything that happens

00:23:43,579 --> 00:23:47,389
within the test

00:23:44,359 --> 00:23:49,279
so the test can freely read and write

00:23:47,389 --> 00:23:51,019
from the database but everything it does

00:23:49,279 --> 00:23:52,519
is then rolled back so that the test

00:23:51,019 --> 00:23:56,209
Eltham Utley had no effect on the

00:23:52,519 --> 00:23:58,489
database so the simplified structure for

00:23:56,209 --> 00:24:00,109
that is that in your setup you want to

00:23:58,489 --> 00:24:02,299
make a connection to your database you

00:24:00,109 --> 00:24:05,149
want to begin a transaction and then you

00:24:02,299 --> 00:24:07,369
want to bind the session that you're

00:24:05,149 --> 00:24:09,800
using for your test to that connection

00:24:07,369 --> 00:24:11,780
that is now opened in transaction

00:24:09,800 --> 00:24:14,390
the way sequel alchemy does transactions

00:24:11,780 --> 00:24:15,320
is that session will say hey I'm a

00:24:14,390 --> 00:24:17,450
session I have a new connection I'm

00:24:15,320 --> 00:24:18,890
going to do some work to and begin a

00:24:17,450 --> 00:24:21,110
transaction then commit my transaction

00:24:18,890 --> 00:24:22,910
when session goes to commit the

00:24:21,110 --> 00:24:24,860
transaction it won't actually commit

00:24:22,910 --> 00:24:27,800
because it's part of a broader context

00:24:24,860 --> 00:24:30,020
that is scoped outside of the lifespan

00:24:27,800 --> 00:24:32,060
of that session and this was written

00:24:30,020 --> 00:24:34,300
this way very intentionally to support

00:24:32,060 --> 00:24:38,830
this kind of pattern where you can nest

00:24:34,300 --> 00:24:42,530
transactional containers so in this test

00:24:38,830 --> 00:24:44,960
in the fixture we want to basically just

00:24:42,530 --> 00:24:46,480
add data to the database freely just add

00:24:44,960 --> 00:24:48,620
whatever you want to test against and

00:24:46,480 --> 00:24:50,840
then in your test you can query the

00:24:48,620 --> 00:24:52,340
database freely and and just do your

00:24:50,840 --> 00:24:54,740
test and then if your session wants to

00:24:52,340 --> 00:24:58,130
commit data it's fine if your session

00:24:54,740 --> 00:24:59,570
wants to do a rollback that can be done

00:24:58,130 --> 00:25:01,430
as well I actually work that out with

00:24:59,570 --> 00:25:03,080
someone on Twitter this example will not

00:25:01,430 --> 00:25:04,700
do that but there is a way to add more

00:25:03,080 --> 00:25:07,070
events and more complexity such that if

00:25:04,700 --> 00:25:09,370
your unit test wants to also roll things

00:25:07,070 --> 00:25:11,330
back on the session without the

00:25:09,370 --> 00:25:13,100
enclosing transaction being affected

00:25:11,330 --> 00:25:14,990
that can be done as well with a little

00:25:13,100 --> 00:25:16,940
more work and then when the Trent the

00:25:14,990 --> 00:25:18,260
test is over we close the session we

00:25:16,940 --> 00:25:19,340
roll back the transaction then we close

00:25:18,260 --> 00:25:22,640
the connection returning it to the

00:25:19,340 --> 00:25:26,330
connection pool this is kind of seem

00:25:22,640 --> 00:25:28,010
familiar at least all right everyone

00:25:26,330 --> 00:25:31,160
here only one person is that yeah and

00:25:28,010 --> 00:25:32,840
then I'm like good great in practice it

00:25:31,160 --> 00:25:34,310
looks kind of like this you'll have a

00:25:32,840 --> 00:25:37,100
fixture that's going to create model

00:25:34,310 --> 00:25:39,050
objects and then in your test you'll be

00:25:37,100 --> 00:25:41,060
basically calling upon the fixture to

00:25:39,050 --> 00:25:43,130
get the data setup that you need and

00:25:41,060 --> 00:25:45,440
then you'll in this case we're testing a

00:25:43,130 --> 00:25:47,270
pyramid view pyramid has this awesome

00:25:45,440 --> 00:25:48,500
object called a dummy request I love it

00:25:47,270 --> 00:25:50,720
you make a dummy request you put

00:25:48,500 --> 00:25:52,850
whatever you need into it and then here

00:25:50,720 --> 00:25:58,310
we're asserting that this request raises

00:25:52,850 --> 00:26:00,260
a 403 error code based on the token that

00:25:58,310 --> 00:26:04,300
has a that's been timed out so it's kind

00:26:00,260 --> 00:26:04,300
of been game to work in that way so

00:26:04,810 --> 00:26:10,040
transactions advantage advantages of

00:26:06,830 --> 00:26:12,200
transactional testing it's easy I think

00:26:10,040 --> 00:26:13,460
it's easy I think it's well suited

00:26:12,200 --> 00:26:14,810
towards integration test integration

00:26:13,460 --> 00:26:17,030
test meaning you're testing kind of a

00:26:14,810 --> 00:26:18,260
broader scope of functionality all the

00:26:17,030 --> 00:26:19,700
way from your view all the way back to

00:26:18,260 --> 00:26:22,280
the database and back up again it's kind

00:26:19,700 --> 00:26:24,750
of your whole stack is happening it's

00:26:22,280 --> 00:26:26,830
really not as much of a unit test

00:26:24,750 --> 00:26:27,970
disadvantages or that it could be slow

00:26:26,830 --> 00:26:31,210
because you're doing a lot of database

00:26:27,970 --> 00:26:32,409
setup and teardown the test might be to

00:26:31,210 --> 00:26:34,990
generalize you want you might want to

00:26:32,409 --> 00:26:36,429
test a much you might not want to have

00:26:34,990 --> 00:26:38,950
all the database stuff happening within

00:26:36,429 --> 00:26:42,309
your test as well and you need a

00:26:38,950 --> 00:26:44,529
database so that's transactional testing

00:26:42,309 --> 00:26:47,260
so the other kind of testing is mock

00:26:44,529 --> 00:26:51,520
testing and if you're in the bitbucket

00:26:47,260 --> 00:26:53,289
repo this file mock session py shows a

00:26:51,520 --> 00:26:56,140
basically what looks like a sikh

00:26:53,289 --> 00:26:57,700
welcoming session but really this module

00:26:56,140 --> 00:27:00,610
uses almost no sequel walk me at all it

00:26:57,700 --> 00:27:01,299
uses the Python mock library I was

00:27:00,610 --> 00:27:03,370
talking to Michael

00:27:01,299 --> 00:27:06,220
Feuer Don Twitter he's the author of the

00:27:03,370 --> 00:27:08,559
Python mock library I love I really love

00:27:06,220 --> 00:27:12,429
the Python mock library I give it two

00:27:08,559 --> 00:27:16,360
thumbs up and this thing basically is

00:27:12,429 --> 00:27:19,390
99% out of the box mock with a couple of

00:27:16,360 --> 00:27:23,140
little twists to make it such that you

00:27:19,390 --> 00:27:25,090
can set up fake sequel alchemy queries

00:27:23,140 --> 00:27:26,980
that are parameterised meaning the

00:27:25,090 --> 00:27:29,710
different parameters you give it you can

00:27:26,980 --> 00:27:30,820
assign different return values to the

00:27:29,710 --> 00:27:32,230
mock how many people here are familiar

00:27:30,820 --> 00:27:33,970
with using mocks for testing in general

00:27:32,230 --> 00:27:36,429
just the idea that you have this mock

00:27:33,970 --> 00:27:37,659
which kind of acts like something but

00:27:36,429 --> 00:27:39,970
it's not really that's something it's

00:27:37,659 --> 00:27:41,020
just X it's an imposter it's like I'm

00:27:39,970 --> 00:27:43,659
only pretending to be the thing you

00:27:41,020 --> 00:27:45,159
think I am so this thing is not a sequel

00:27:43,659 --> 00:27:48,340
hugging session at all it's strictly

00:27:45,159 --> 00:27:50,679
just a mock but as you might be able to

00:27:48,340 --> 00:27:52,419
see here we can have different queries

00:27:50,679 --> 00:27:54,130
and plug them in with return values that

00:27:52,419 --> 00:27:56,080
are different and we can even plug in a

00:27:54,130 --> 00:27:59,200
side effect of no result found and then

00:27:56,080 --> 00:28:00,880
later when you go to query the calling

00:27:59,200 --> 00:28:02,289
code is assumed you have to basically

00:28:00,880 --> 00:28:04,299
build up these queries to be exactly

00:28:02,289 --> 00:28:05,799
what the calling code will be calling

00:28:04,299 --> 00:28:08,380
upon which is one of the reasons it's

00:28:05,799 --> 00:28:10,179
difficult and it'll get back data that

00:28:08,380 --> 00:28:13,210
looks just like it was hitting the

00:28:10,179 --> 00:28:14,620
database as you as you tell it so the

00:28:13,210 --> 00:28:16,149
simplified structure of mock testing is

00:28:14,620 --> 00:28:17,559
SuperDuper crazy easy

00:28:16,149 --> 00:28:19,600
there's no transaction there's no

00:28:17,559 --> 00:28:21,220
connect there's nothing you just get a

00:28:19,600 --> 00:28:22,870
mock session than the set up and that's

00:28:21,220 --> 00:28:24,940
it and you maybe plug your mock session

00:28:22,870 --> 00:28:26,679
into your into your scope session

00:28:24,940 --> 00:28:30,100
depending on it depends on what session

00:28:26,679 --> 00:28:32,950
scoping pattern you're using the fixture

00:28:30,100 --> 00:28:36,970
is just set up the mock session with

00:28:32,950 --> 00:28:37,539
some pre cans fake results and then the

00:28:36,970 --> 00:28:39,340
test is

00:28:37,539 --> 00:28:41,529
is call upon the fixture and then call a

00:28:39,340 --> 00:28:44,109
query as you need and you get the object

00:28:41,529 --> 00:28:46,779
back so that looks very easy but in

00:28:44,109 --> 00:28:49,059
practice is actually I have found it is

00:28:46,779 --> 00:28:50,350
more difficult because you have to

00:28:49,059 --> 00:28:51,909
basically go into the code that you're

00:28:50,350 --> 00:28:54,070
testing and look at all the queries that

00:28:51,909 --> 00:28:57,519
it's doing and you have to replicate

00:28:54,070 --> 00:29:00,279
every query it needs perfectly so that

00:28:57,519 --> 00:29:01,929
you you can anticipate what queries the

00:29:00,279 --> 00:29:03,009
function is going to call how they're

00:29:01,929 --> 00:29:05,590
going to look and what kind of return

00:29:03,009 --> 00:29:06,879
values so here this whole screen is just

00:29:05,590 --> 00:29:09,940
the fixture part which before was just

00:29:06,879 --> 00:29:11,590
like one row one line inserted a record

00:29:09,940 --> 00:29:13,149
and committed and you're done here we

00:29:11,590 --> 00:29:15,220
have to kind of anticipate what what the

00:29:13,149 --> 00:29:17,739
queries look like right does that make

00:29:15,220 --> 00:29:19,389
sense why we need to do that so you can

00:29:17,739 --> 00:29:21,309
see and this is and and the fixtures

00:29:19,389 --> 00:29:23,109
that are in the sample app you know go

00:29:21,309 --> 00:29:24,489
look at them you know you can see they

00:29:23,109 --> 00:29:27,099
get a little you know it was just more

00:29:24,489 --> 00:29:28,809
tedious to write these fixtures but the

00:29:27,099 --> 00:29:31,690
end result is you can still write the

00:29:28,809 --> 00:29:33,970
test usually looks exactly the same

00:29:31,690 --> 00:29:35,919
and even nicer you can sometimes you can

00:29:33,970 --> 00:29:38,590
look into the mock and make sure certain

00:29:35,919 --> 00:29:39,879
things recalled as you expect so the

00:29:38,590 --> 00:29:43,539
tests themselves look exactly the same

00:29:39,879 --> 00:29:45,609
or or better so that's the mock system

00:29:43,539 --> 00:29:47,080
and I found it to be very interesting

00:29:45,609 --> 00:29:48,729
once I got that mock session to work I

00:29:47,080 --> 00:29:51,749
was really like wow this is kind of a

00:29:48,729 --> 00:29:53,649
mind-blower but I'm still not sure

00:29:51,749 --> 00:29:56,769
advantages to mock testing that there's

00:29:53,649 --> 00:29:58,989
no database needed tests can be focused

00:29:56,769 --> 00:30:01,570
to smaller units because you know less

00:29:58,989 --> 00:30:02,889
of an integration and of course it

00:30:01,570 --> 00:30:05,320
encourages your code to be modular

00:30:02,889 --> 00:30:07,389
because now we've got to write these

00:30:05,320 --> 00:30:09,070
mocks that are matching all the sequel

00:30:07,389 --> 00:30:11,229
functions you really have to be on top

00:30:09,070 --> 00:30:14,639
of how your code is organized such that

00:30:11,229 --> 00:30:17,950
it's you know feasible to be mocked and

00:30:14,639 --> 00:30:23,109
it's fast there's no there's no setup or

00:30:17,950 --> 00:30:25,570
teardown really disadvantages to mocking

00:30:23,109 --> 00:30:28,809
is that the fixtures are really tedious

00:30:25,570 --> 00:30:30,940
to create it won't actually catch

00:30:28,809 --> 00:30:33,340
problems with your ORM if you're like if

00:30:30,940 --> 00:30:35,049
you're seek welcome to ORM mmm isn't

00:30:33,340 --> 00:30:36,909
configured correctly or your sequel

00:30:35,049 --> 00:30:38,859
queries aren't right it won't it will

00:30:36,909 --> 00:30:41,889
not actually catch that at all so you're

00:30:38,859 --> 00:30:43,149
testing less and then this is a problem

00:30:41,889 --> 00:30:44,289
with mocking in general I think people

00:30:43,149 --> 00:30:45,249
have done talks about this much better

00:30:44,289 --> 00:30:47,259
than me

00:30:45,249 --> 00:30:49,450
if you do too much mocking you're kind

00:30:47,259 --> 00:30:50,530
of you kind of end up writing a mirror

00:30:49,450 --> 00:30:51,820
of the

00:30:50,530 --> 00:30:55,180
of the code that you're testing in the

00:30:51,820 --> 00:30:57,220
first place so sometimes you're mocked

00:30:55,180 --> 00:30:59,470
out tests can end up just being tests

00:30:57,220 --> 00:31:00,730
that the code does what you told to do

00:30:59,470 --> 00:31:02,200
even though it's still the incorrect

00:31:00,730 --> 00:31:06,600
thing the mock won't actually know that

00:31:02,200 --> 00:31:11,680
so that's kind of a mocking issue and

00:31:06,600 --> 00:31:14,200
then for the final round we can look a

00:31:11,680 --> 00:31:15,760
little extra I mean the example app is

00:31:14,200 --> 00:31:17,680
I've gave you the link and and we have

00:31:15,760 --> 00:31:19,240
to put this the I have to send them the

00:31:17,680 --> 00:31:23,440
PDF of this so you can get them online

00:31:19,240 --> 00:31:24,490
and stuff what I will do is the sort so

00:31:23,440 --> 00:31:25,720
for the source code you can go up to

00:31:24,490 --> 00:31:28,300
that bucket and look at the source code

00:31:25,720 --> 00:31:29,850
please download it and what we'll do

00:31:28,300 --> 00:31:33,580
here is we'll run the pyramid app and

00:31:29,850 --> 00:31:34,990
run the quote-unquote client and here

00:31:33,580 --> 00:31:38,350
comes the part where this will be great

00:31:34,990 --> 00:31:42,340
if it works which it should so I have

00:31:38,350 --> 00:31:46,870
the pyramid app running in this window

00:31:42,340 --> 00:31:49,750
so it's just serving on a bit sexy oh

00:31:46,870 --> 00:31:53,620
it's actually a um a web service that

00:31:49,750 --> 00:31:56,010
acts like a miniature ATM machine for a

00:31:53,620 --> 00:31:59,170
bank so you can send deposits and of

00:31:56,010 --> 00:32:01,480
money into it and it'll basically store

00:31:59,170 --> 00:32:02,950
your account information how much money

00:32:01,480 --> 00:32:05,260
you've put in and then you can make it

00:32:02,950 --> 00:32:08,260
withdrawal you can withdraw money from

00:32:05,260 --> 00:32:10,510
different quote-unquote accounts and it

00:32:08,260 --> 00:32:14,170
you know has it maybe five or six tables

00:32:10,510 --> 00:32:16,150
and it's a cute little app and then over

00:32:14,170 --> 00:32:18,760
here is a java app that is actually

00:32:16,150 --> 00:32:21,250
going to be the client in this java app

00:32:18,760 --> 00:32:23,200
you'll see in a minute what it does it's

00:32:21,250 --> 00:32:26,620
a cert it's actually it's this just Java

00:32:23,200 --> 00:32:29,500
app is actually a client for the pyramid

00:32:26,620 --> 00:32:32,740
app but it is also a server for the

00:32:29,500 --> 00:32:38,680
client that I'm going to run and I don't

00:32:32,740 --> 00:32:47,200
know how much you can see so this should

00:32:38,680 --> 00:32:51,760
be awesome it works so this client is a

00:32:47,200 --> 00:32:53,880
program called minecraft this is also

00:32:51,760 --> 00:32:56,290
known as the gag at the end of the talk

00:32:53,880 --> 00:32:57,850
so like if the talk was terrible well at

00:32:56,290 --> 00:33:00,940
least you did that silly gag at the end

00:32:57,850 --> 00:33:04,870
no but school so

00:33:00,940 --> 00:33:08,710
oh it's nighttime okay so you guys can

00:33:04,870 --> 00:33:13,410
see the screen right fortunately our our

00:33:08,710 --> 00:33:16,450
ATM machine is open 24 hours yep and

00:33:13,410 --> 00:33:20,500
that is the Z there's a chicken in my

00:33:16,450 --> 00:33:22,930
bank okay so the idea here and you what

00:33:20,500 --> 00:33:25,060
you want to do is kind of watch the blue

00:33:22,930 --> 00:33:29,260
at this can you guys see the terminal on

00:33:25,060 --> 00:33:30,310
the side there yeah in Minecraft ATM

00:33:29,260 --> 00:33:34,450
machines are actually in the form of

00:33:30,310 --> 00:33:36,670
chests so if I hit the chest it actually

00:33:34,450 --> 00:33:40,510
made a web service call back to the

00:33:36,670 --> 00:33:42,720
pyramid app and what it did was it had

00:33:40,510 --> 00:33:45,850
it basically it has an auth token that's

00:33:42,720 --> 00:33:47,980
for my session so basically this this

00:33:45,850 --> 00:33:51,430
chest being open is like a set is a set

00:33:47,980 --> 00:33:54,880
is an open session to the server and the

00:33:51,430 --> 00:33:56,380
first thing that the ATM craft app

00:33:54,880 --> 00:33:59,830
wanted to say is oh you have six

00:33:56,380 --> 00:34:02,890
diamonds and six lapis blocks so there's

00:33:59,830 --> 00:34:04,420
those remind craft block codes so

00:34:02,890 --> 00:34:05,980
there's my inventory and I can actually

00:34:04,420 --> 00:34:08,050
take three diamonds out I can make it

00:34:05,980 --> 00:34:09,910
withdrawal move them down I put them

00:34:08,050 --> 00:34:13,360
here you can see something just happens

00:34:09,910 --> 00:34:14,530
and it basically said I withdrew three

00:34:13,360 --> 00:34:17,230
diamonds and you can see over here

00:34:14,530 --> 00:34:18,720
there's a withdraw call to the

00:34:17,230 --> 00:34:22,030
webservice

00:34:18,720 --> 00:34:24,340
you know and I can apply lapis box going

00:34:22,030 --> 00:34:27,970
to take some stone put the stone in the

00:34:24,340 --> 00:34:30,960
bank so I may deposit the stone and if

00:34:27,970 --> 00:34:34,860
you look at the terminal so basically

00:34:30,960 --> 00:34:34,860
that's what it does is an ATM machine

00:34:46,579 --> 00:34:51,929
so if anyone has questions for Mike in

00:34:49,919 --> 00:34:55,020
come on up I'm going to use my powers

00:34:51,929 --> 00:34:57,119
for evil and ask the first question you

00:34:55,020 --> 00:34:58,440
are talking about session scoping the

00:34:57,119 --> 00:35:00,530
thing that you didn't want to talk about

00:34:58,440 --> 00:35:02,400
so I apologize for going back to it but

00:35:00,530 --> 00:35:04,170
one thing that I have a countered a few

00:35:02,400 --> 00:35:05,579
times in problems I'm trying to solve is

00:35:04,170 --> 00:35:07,680
the idea of a long conversation where

00:35:05,579 --> 00:35:09,240
over multiple requests you want to

00:35:07,680 --> 00:35:10,950
maintain the same motion open session if

00:35:09,240 --> 00:35:12,089
you're manipulating a complex object

00:35:10,950 --> 00:35:13,829
that you want to do an undo or something

00:35:12,089 --> 00:35:15,630
are there any conventions that you would

00:35:13,829 --> 00:35:17,609
recommend using sequel alchemy for that

00:35:15,630 --> 00:35:20,640
or is it more your own is it a long

00:35:17,609 --> 00:35:23,160
transaction or the question was was the

00:35:20,640 --> 00:35:24,630
question is yeah so is it a long

00:35:23,160 --> 00:35:25,829
transaction that you're running yeah

00:35:24,630 --> 00:35:27,270
like let's say you have somebody who's

00:35:25,829 --> 00:35:28,890
making multiple Ajax requests because

00:35:27,270 --> 00:35:29,790
they're editing a complex object in

00:35:28,890 --> 00:35:30,960
their browser and you just want to be

00:35:29,790 --> 00:35:33,869
able to roll back well if it's in the

00:35:30,960 --> 00:35:35,099
browser the HTTP request is stateless so

00:35:33,869 --> 00:35:37,500
you wouldn't have the transaction open

00:35:35,099 --> 00:35:39,420
between requests so I mean there's

00:35:37,500 --> 00:35:40,829
different ways to do it I would use a

00:35:39,420 --> 00:35:42,930
different size for each request and just

00:35:40,829 --> 00:35:45,990
kind of resuscitate the state that you

00:35:42,930 --> 00:35:47,220
need each time um I wouldn't try to get

00:35:45,990 --> 00:35:47,670
too fancy with it that would be my

00:35:47,220 --> 00:35:51,900
advice

00:35:47,670 --> 00:35:53,640
thank you yeah is it possible to get the

00:35:51,900 --> 00:35:55,890
transactional rollbacks working with

00:35:53,640 --> 00:35:58,589
sequel Lite attempting that for awhile

00:35:55,890 --> 00:36:01,500
and into the transit do you mean like DD

00:35:58,589 --> 00:36:04,650
DL rollbacks or nested transactions and

00:36:01,500 --> 00:36:07,230
rolling back with sequel Lite for okay

00:36:04,650 --> 00:36:08,970
so nest is you mean savepoints yeah I

00:36:07,230 --> 00:36:12,380
guess they should work in sequel Lite

00:36:08,970 --> 00:36:17,339
okay safe points I believe are working

00:36:12,380 --> 00:36:20,099
okay yeah I had a question if you'd seen

00:36:17,339 --> 00:36:22,740
the talk stop mocking start testing from

00:36:20,099 --> 00:36:24,720
I believe the last two years ago at this

00:36:22,740 --> 00:36:26,520
Ganton what were your opinions on that

00:36:24,720 --> 00:36:27,690
especially with now this new mocking

00:36:26,520 --> 00:36:30,540
cemeteries elf I was just interesting

00:36:27,690 --> 00:36:31,829
your thought well well I didn't see the

00:36:30,540 --> 00:36:33,270
stop mocking start site but I knew the

00:36:31,829 --> 00:36:35,309
idea was kind of some of the things I

00:36:33,270 --> 00:36:36,809
was getting at right that it yeah I mean

00:36:35,309 --> 00:36:39,119
the thoughts those were my thoughts is

00:36:36,809 --> 00:36:40,710
that mocking I think it's really cool

00:36:39,119 --> 00:36:45,690
I've kind of been bitten by the mocking

00:36:40,710 --> 00:36:47,790
bug but I have yet to get bit by that

00:36:45,690 --> 00:36:49,859
bug you know painfully so yeah I know

00:36:47,790 --> 00:36:51,599
this caveats but I haven't been mocking

00:36:49,859 --> 00:36:52,710
at all so I'm kind of swinging from one

00:36:51,599 --> 00:36:57,130
side to the other

00:36:52,710 --> 00:36:59,740
yeah hi I was wondering if you thought

00:36:57,130 --> 00:37:03,850
about making a pyramid scaffold out of

00:36:59,740 --> 00:37:05,770
ATM craft um okay

00:37:03,850 --> 00:37:07,120
if I knew what a pyramid scaffold was

00:37:05,770 --> 00:37:09,280
and I could do that it's the like the

00:37:07,120 --> 00:37:10,360
template thing reading press like it's

00:37:09,280 --> 00:37:12,490
liking my page

00:37:10,360 --> 00:37:15,490
yeah you know what I think yeah so I

00:37:12,490 --> 00:37:16,630
yeah it's like a prepackaged template

00:37:15,490 --> 00:37:20,350
yeah I think that would be a good idea

00:37:16,630 --> 00:37:22,000
um I yeah we should have people look at

00:37:20,350 --> 00:37:24,730
what I did and make sure I did I mean it

00:37:22,000 --> 00:37:25,840
should use some more the way the ATM

00:37:24,730 --> 00:37:27,990
craft was written was very very

00:37:25,840 --> 00:37:29,620
simplistically it doesn't use the dope

00:37:27,990 --> 00:37:32,320
transaction stuff which you probably

00:37:29,620 --> 00:37:36,190
should use so it probably needs a little

00:37:32,320 --> 00:37:41,680
more stuff in it but yeah I think yeah

00:37:36,190 --> 00:37:44,350
that would be great yeah I've got one

00:37:41,680 --> 00:37:45,730
more sorry um one of the initial things

00:37:44,350 --> 00:37:47,890
that attracted me to sequel alchemy

00:37:45,730 --> 00:37:49,930
coming from hibernate was the ability to

00:37:47,890 --> 00:37:51,400
just use table mapping so that I could

00:37:49,930 --> 00:37:53,050
have my model objects be just plain old

00:37:51,400 --> 00:37:55,300
Python objects without having to inherit

00:37:53,050 --> 00:37:57,070
from some magical base class and then

00:37:55,300 --> 00:37:59,620
instead of MA keynote sessions I'd be

00:37:57,070 --> 00:38:01,630
able to abstract my data access to a

00:37:59,620 --> 00:38:03,940
repository or something how do you feel

00:38:01,630 --> 00:38:05,500
but I've not seen that much in my peers

00:38:03,940 --> 00:38:08,730
I was just curious about you well see

00:38:05,500 --> 00:38:12,280
quagga me so Seekonk me started out very

00:38:08,730 --> 00:38:13,690
inspired by hibernate and for the first

00:38:12,280 --> 00:38:17,470
three or four versions we didn't have

00:38:13,690 --> 00:38:21,760
declarative we had just map like your

00:38:17,470 --> 00:38:23,470
classes were pojos pete popo's sorry and

00:38:21,760 --> 00:38:24,970
then you have the table then you had the

00:38:23,470 --> 00:38:27,250
mapper and i just found one actually one

00:38:24,970 --> 00:38:29,070
to try to use that system it was really

00:38:27,250 --> 00:38:33,820
tedious

00:38:29,070 --> 00:38:35,410
some people do work that way but it just

00:38:33,820 --> 00:38:37,210
seems like from a pragmatic point of

00:38:35,410 --> 00:38:39,370
view it just works out more easily to

00:38:37,210 --> 00:38:41,290
have your classes in tables somewhat

00:38:39,370 --> 00:38:42,370
I'll sometimes use a certain style which

00:38:41,290 --> 00:38:44,710
is in the docs which is where you have

00:38:42,370 --> 00:38:46,930
your class laid out but instead of

00:38:44,710 --> 00:38:49,870
having the the table columns in line

00:38:46,930 --> 00:38:52,060
there'll be an inner attribute

00:38:49,870 --> 00:38:54,160
underscore table pointing to a complete

00:38:52,060 --> 00:38:58,150
a table by itself so also names do more

00:38:54,160 --> 00:38:59,230
of a hybrid approach but the separate I

00:38:58,150 --> 00:39:01,210
mean when I work with hibernate having

00:38:59,230 --> 00:39:04,150
those XML files was really just too much

00:39:01,210 --> 00:39:06,070
it's hard so yeah I I don't I don't have

00:39:04,150 --> 00:39:08,650
a golden rule there

00:39:06,070 --> 00:39:10,570
is why sea-fog me is always so agnostic

00:39:08,650 --> 00:39:16,450
about everything because I really want

00:39:10,570 --> 00:39:17,860
to be kind of open-ended thank you if

00:39:16,450 --> 00:39:19,330
there aren't any other questions you can

00:39:17,860 --> 00:39:22,020
sync up with Mike after the talk but

00:39:19,330 --> 00:39:22,020

YouTube URL: https://www.youtube.com/watch?v=5SSC6nU314c


