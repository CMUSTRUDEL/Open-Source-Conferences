Title: Graham Dumpleton: Advanced methods for creating decorators - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:00,000 --> 00:00:03,589
I hope you enjoyed your first full day

00:00:01,530 --> 00:00:07,230
of talks last talks a lot of this room

00:00:03,589 --> 00:00:09,179
I'd like to present Graham Dumbleton who

00:00:07,230 --> 00:00:11,309
generously offered to fill the slot on

00:00:09,179 --> 00:00:12,450
very short notice he's the author of

00:00:11,309 --> 00:00:15,330
some software you may have once he was

00:00:12,450 --> 00:00:16,859
called mod WSGI and he is currently a

00:00:15,330 --> 00:00:18,240
senior engineer at New Relic and he's

00:00:16,859 --> 00:00:19,770
going to be speaking to us tonight about

00:00:18,240 --> 00:00:30,990
advanced methods for creating decorators

00:00:19,770 --> 00:00:32,880
let's get more on welcome okay before I

00:00:30,990 --> 00:00:34,050
get started this is this is a talk I

00:00:32,880 --> 00:00:35,610
have done before which is why I've

00:00:34,050 --> 00:00:36,750
managed to just drop into the spot

00:00:35,610 --> 00:00:39,540
pretty quick

00:00:36,750 --> 00:00:43,590
I presented it New Zealand Python last

00:00:39,540 --> 00:00:45,420
year I had put dinners a proposal for

00:00:43,590 --> 00:00:48,090
this conference but I didn't get

00:00:45,420 --> 00:00:50,010
accepted and if you followed my blog you

00:00:48,090 --> 00:00:51,270
would have known I did a huge blogpost

00:00:50,010 --> 00:00:53,730
series at the beginning of the year

00:00:51,270 --> 00:00:55,760
about this topic so it's obviously

00:00:53,730 --> 00:00:58,260
something I'm quite passionate about and

00:00:55,760 --> 00:01:02,550
it's an interesting topic the reaction

00:00:58,260 --> 00:01:04,710
you get from it because I sort of go way

00:01:02,550 --> 00:01:08,520
beyond the normal way that people

00:01:04,710 --> 00:01:11,070
usually write decorators I sort of well

00:01:08,520 --> 00:01:12,750
when I'll lose people in what I'm

00:01:11,070 --> 00:01:13,740
describing because it's sort of much

00:01:12,750 --> 00:01:15,360
more complicated in what they were

00:01:13,740 --> 00:01:17,850
expecting and I get her a lot of

00:01:15,360 --> 00:01:19,740
reactions of why do I care about all

00:01:17,850 --> 00:01:23,430
this detail why do I need to know the

00:01:19,740 --> 00:01:25,350
way I do it now works well I don't quite

00:01:23,430 --> 00:01:28,950
think it does which is part of it what

00:01:25,350 --> 00:01:30,810
am i explaining so the thing to take

00:01:28,950 --> 00:01:34,439
away from it a guess is if you if you

00:01:30,810 --> 00:01:36,180
don't quite understand it what I think

00:01:34,439 --> 00:01:38,009
is really good about what I'm doing in

00:01:36,180 --> 00:01:40,290
this and what I doing in the blog is

00:01:38,009 --> 00:01:42,420
that I'm not doing what a lot of people

00:01:40,290 --> 00:01:44,009
do and they they talk about a topic like

00:01:42,420 --> 00:01:46,110
decorators you'll get a lot of blog

00:01:44,009 --> 00:01:47,909
posts they say hey look I went and

00:01:46,110 --> 00:01:49,890
understood decorators on the weekend

00:01:47,909 --> 00:01:51,509
this is what they are and I'll explain

00:01:49,890 --> 00:01:55,350
in a few paragraphs and I think that's

00:01:51,509 --> 00:01:58,860
all that's to it I like to go beyond

00:01:55,350 --> 00:02:03,930
that and I like to create a story about

00:01:58,860 --> 00:02:06,659
how I got to that solution of what for

00:02:03,930 --> 00:02:08,670
something from how it works so if you

00:02:06,659 --> 00:02:10,500
this is something like if you ever do

00:02:08,670 --> 00:02:12,569
blog posting yourself I really really

00:02:10,500 --> 00:02:15,120
encourage you to do that don't just say

00:02:12,569 --> 00:02:17,940
oh I work this out this a solution

00:02:15,120 --> 00:02:20,459
describe the journey you went on to get

00:02:17,940 --> 00:02:24,090
there because it's really interesting to

00:02:20,459 --> 00:02:26,459
read that when people come along and do

00:02:24,090 --> 00:02:27,660
it later and if you take anything away

00:02:26,459 --> 00:02:28,230
from that if you don't understand what

00:02:27,660 --> 00:02:30,900
I'm talking about

00:02:28,230 --> 00:02:36,120
please at least do that and I hope you

00:02:30,900 --> 00:02:37,769
enjoy my story on this one so I should

00:02:36,120 --> 00:02:40,200
mention that obviously Colton Meyers did

00:02:37,769 --> 00:02:41,970
to talk this morning on decorators so

00:02:40,200 --> 00:02:44,430
he's covered a lot of really basic stuff

00:02:41,970 --> 00:02:46,410
here but most of what he was talking

00:02:44,430 --> 00:02:48,629
about sort of that's my first three or

00:02:46,410 --> 00:02:51,360
four slides and then I get into the

00:02:48,629 --> 00:02:53,580
heart of stuff so this is just a quick

00:02:51,360 --> 00:02:55,680
recap of what Colton was talking about

00:02:53,580 --> 00:02:58,319
so even if you've never written your own

00:02:55,680 --> 00:03:00,510
decorator and I've only used them you

00:02:58,319 --> 00:03:03,110
would know that decorators from from the

00:03:00,510 --> 00:03:05,940
app symbol used to prefix their usage

00:03:03,110 --> 00:03:08,819
the app symbol here though is little

00:03:05,940 --> 00:03:10,800
more than syntactic sugar one can do the

00:03:08,819 --> 00:03:13,830
same thing invoking the decorator

00:03:10,800 --> 00:03:15,269
function explicitly parking passing in

00:03:13,830 --> 00:03:17,250
the function to be decorated and

00:03:15,269 --> 00:03:19,530
replacing the original with the result

00:03:17,250 --> 00:03:21,300
in fact this is what you had to do

00:03:19,530 --> 00:03:25,049
before the decorator syntax was

00:03:21,300 --> 00:03:27,060
introduced in Python 2.4 the decorator

00:03:25,049 --> 00:03:29,159
syntax is therefore just a shorthand way

00:03:27,060 --> 00:03:31,980
of being able to apply a wrapper around

00:03:29,159 --> 00:03:34,319
an existing function or otherwise

00:03:31,980 --> 00:03:36,480
modifying the existing function in place

00:03:34,319 --> 00:03:40,830
while the definition of the function is

00:03:36,480 --> 00:03:42,780
being set up the more illustrative way

00:03:40,830 --> 00:03:45,720
of showing how a wrapper works is to

00:03:42,780 --> 00:03:48,420
implement using a class object the class

00:03:45,720 --> 00:03:50,610
instance is initialized with and

00:03:48,420 --> 00:03:53,459
remembers the original function object

00:03:50,610 --> 00:03:55,530
when the now wrapped function is called

00:03:53,459 --> 00:03:57,569
it is actually the dunder score call

00:03:55,530 --> 00:04:00,390
method of the wrapper object which is

00:03:57,569 --> 00:04:04,200
invoked this in turn would then call the

00:04:00,390 --> 00:04:06,150
original wrapped function a pass through

00:04:04,200 --> 00:04:07,650
wrapper isn't particularly useful so

00:04:06,150 --> 00:04:09,540
normally you would actually want to do

00:04:07,650 --> 00:04:11,909
some work either before or after the

00:04:09,540 --> 00:04:13,980
wrapped function is called or you may

00:04:11,909 --> 00:04:15,659
want to modify the input arguments or

00:04:13,980 --> 00:04:19,470
the result as they pass through the

00:04:15,659 --> 00:04:21,239
wrapper using a class to implement the

00:04:19,470 --> 00:04:23,610
wrapper for a decorator isn't actually

00:04:21,239 --> 00:04:26,070
that popular instead a function closure

00:04:23,610 --> 00:04:28,140
is more often used

00:04:26,070 --> 00:04:30,420
this case a nested function is used as a

00:04:28,140 --> 00:04:33,210
wrapper and is that which is returned by

00:04:30,420 --> 00:04:35,490
the decorator when the now wrapped

00:04:33,210 --> 00:04:37,680
function is called the nested function

00:04:35,490 --> 00:04:40,050
is actually being called this in turn

00:04:37,680 --> 00:04:43,950
would again call then call the original

00:04:40,050 --> 00:04:45,570
wrapped function in this situation the

00:04:43,950 --> 00:04:47,250
nested function doesn't actually get

00:04:45,570 --> 00:04:49,680
passed the original wrapped function

00:04:47,250 --> 00:04:51,540
explicitly but it will still have access

00:04:49,680 --> 00:04:54,120
to it via the arguments given to the

00:04:51,540 --> 00:04:56,370
outer function call this does a way of

00:04:54,120 --> 00:04:58,260
the need to create a class to hold what

00:04:56,370 --> 00:05:00,390
was the wrapped function and thus why it

00:04:58,260 --> 00:05:04,230
is can convenient and generally more

00:05:00,390 --> 00:05:06,720
popular now when we talk about functions

00:05:04,230 --> 00:05:09,210
we expect them to specify properties

00:05:06,720 --> 00:05:09,800
which describe them as well as document

00:05:09,210 --> 00:05:12,510
what they do

00:05:09,800 --> 00:05:15,180
these included underscore name and

00:05:12,510 --> 00:05:17,700
underscore doc attributes when we use a

00:05:15,180 --> 00:05:19,680
wrapper though this no longer works as

00:05:17,700 --> 00:05:21,780
we expect as in the case of using a

00:05:19,680 --> 00:05:26,070
function closure the details of the

00:05:21,780 --> 00:05:28,500
nested function are returned if we use a

00:05:26,070 --> 00:05:30,240
class to implement the wrapper as class

00:05:28,500 --> 00:05:32,700
instances do not normally have ADD

00:05:30,240 --> 00:05:34,530
underscore name attribute attempting to

00:05:32,700 --> 00:05:36,300
access the name of the function will

00:05:34,530 --> 00:05:40,380
actually result in an attribute error

00:05:36,300 --> 00:05:42,000
exception the solution here when using a

00:05:40,380 --> 00:05:43,770
function closure is to copy the

00:05:42,000 --> 00:05:45,740
attributes of interest from the wrapped

00:05:43,770 --> 00:05:48,300
function to the nested wrapper function

00:05:45,740 --> 00:05:50,400
this will then result in the function

00:05:48,300 --> 00:05:54,720
name and the documentation strings been

00:05:50,400 --> 00:05:56,910
correct needing to manually copy the

00:05:54,720 --> 00:05:58,770
attributes is laborious and would need

00:05:56,910 --> 00:06:00,480
to be updated if any further special

00:05:58,770 --> 00:06:03,510
attributes were added which needed to be

00:06:00,480 --> 00:06:05,880
copied for example we should also copy

00:06:03,510 --> 00:06:08,100
the dunder score module attribute and in

00:06:05,880 --> 00:06:11,490
Python freed that underscore call name

00:06:08,100 --> 00:06:14,340
and underscore underscore annotations

00:06:11,490 --> 00:06:16,050
attributes were added to aid in getting

00:06:14,340 --> 00:06:18,570
this right the Python standard library

00:06:16,050 --> 00:06:21,620
provides the func tools dot wrap s

00:06:18,570 --> 00:06:24,510
decorator which does this task for you

00:06:21,620 --> 00:06:27,450
if using a class to implement the

00:06:24,510 --> 00:06:29,580
wrapper instead of the func tools wrap s

00:06:27,450 --> 00:06:33,990
decorator we would use the func tools

00:06:29,580 --> 00:06:36,150
dot update wrapper function instead so

00:06:33,990 --> 00:06:38,010
we've managed to fix up things so that

00:06:36,150 --> 00:06:39,660
the function name and any documentation

00:06:38,010 --> 00:06:41,100
string is correct

00:06:39,660 --> 00:06:44,040
but what if we want to query the

00:06:41,100 --> 00:06:46,140
argument specification this also fails

00:06:44,040 --> 00:06:48,030
and instead of returning the argument

00:06:46,140 --> 00:06:50,610
specification for the wrapped function

00:06:48,030 --> 00:06:53,160
it returns that of the wrapper in the

00:06:50,610 --> 00:06:55,800
case of using a function closure this is

00:06:53,160 --> 00:06:58,080
the nested function the decorator is

00:06:55,800 --> 00:07:02,820
therefore not what we call signature

00:06:58,080 --> 00:07:05,310
preserving a worse situation again

00:07:02,820 --> 00:07:07,590
occurs with the class wrapper this time

00:07:05,310 --> 00:07:09,360
we get an exception complaining that the

00:07:07,590 --> 00:07:12,450
wrapped function isn't actually a

00:07:09,360 --> 00:07:14,610
function as a result it isn't possible

00:07:12,450 --> 00:07:16,860
to derive an argument specification at

00:07:14,610 --> 00:07:21,300
all even though the wrap function is

00:07:16,860 --> 00:07:23,850
actually still callable now as well as

00:07:21,300 --> 00:07:26,820
normal functions decorators can also be

00:07:23,850 --> 00:07:28,350
applied to the methods of classes Python

00:07:26,820 --> 00:07:31,230
even includes a couple of special

00:07:28,350 --> 00:07:33,120
decorators called class method and

00:07:31,230 --> 00:07:35,430
Static method for converting normal

00:07:33,120 --> 00:07:38,040
instance methods into these special

00:07:35,430 --> 00:07:39,810
method types methods of classes do

00:07:38,040 --> 00:07:44,280
provide a number of potential problems

00:07:39,810 --> 00:07:46,470
though the first is that even if using

00:07:44,280 --> 00:07:48,960
func tools dot wrap s or func tools dot

00:07:46,470 --> 00:07:50,790
update wrapper in your decorator when

00:07:48,960 --> 00:07:52,800
the decorator is applied around class

00:07:50,790 --> 00:07:54,870
method or static method it will fail

00:07:52,800 --> 00:07:57,060
with an exception this is because the

00:07:54,870 --> 00:07:59,370
wrappers created by these do not have

00:07:57,060 --> 00:08:02,250
some of the attributes being copied by

00:07:59,370 --> 00:08:04,080
thank toolstrip s and update wrapper as

00:08:02,250 --> 00:08:06,540
it happens this is actually a Python to

00:08:04,080 --> 00:08:10,800
bug and it's fixed in Python free by

00:08:06,540 --> 00:08:12,510
ignoring missing attributes even when we

00:08:10,800 --> 00:08:14,880
run it under Python free we still hit

00:08:12,510 --> 00:08:16,980
troubler this is because both wrapper

00:08:14,880 --> 00:08:19,650
types assume that the wrapped function

00:08:16,980 --> 00:08:22,050
is directly callable this need not

00:08:19,650 --> 00:08:23,430
actually be the case a wrapped function

00:08:22,050 --> 00:08:25,890
can actually be what is called a

00:08:23,430 --> 00:08:28,290
descriptor meaning that in order to get

00:08:25,890 --> 00:08:33,510
back a callable the descriptor has to be

00:08:28,290 --> 00:08:35,250
bound correctly to the instance first so

00:08:33,510 --> 00:08:37,169
all our decorators using function

00:08:35,250 --> 00:08:39,000
closures or class wrappers may appear to

00:08:37,169 --> 00:08:41,460
solve the task can't they fail in

00:08:39,000 --> 00:08:43,020
various corner cases and also don't do a

00:08:41,460 --> 00:08:45,720
very good job at preserving the ability

00:08:43,020 --> 00:08:48,420
to do introspection the ladder is a

00:08:45,720 --> 00:08:50,310
problem for documentation tools IDs and

00:08:48,420 --> 00:08:52,709
also some performance monitoring or

00:08:50,310 --> 00:08:54,910
profiling tools

00:08:52,709 --> 00:08:57,399
so let's go back now and look at these

00:08:54,910 --> 00:09:00,190
descriptors as they turn out to be a key

00:08:57,399 --> 00:09:02,199
mechanism in all of this a descriptor is

00:09:00,190 --> 00:09:05,139
an object attribute with binding

00:09:02,199 --> 00:09:06,940
behavior one whose attribute access has

00:09:05,139 --> 00:09:09,310
been overridden by methods in the

00:09:06,940 --> 00:09:11,199
descriptive protocol these methods that

00:09:09,310 --> 00:09:13,089
underscore get the underscore set and

00:09:11,199 --> 00:09:15,579
underscore delete if any of those

00:09:13,089 --> 00:09:19,420
methods are defined for an object it is

00:09:15,579 --> 00:09:21,130
said to be a descriptor what this means

00:09:19,420 --> 00:09:22,839
is that if an attribute of a class has

00:09:21,130 --> 00:09:25,149
any of these special methods defined

00:09:22,839 --> 00:09:27,069
when the corresponding operation is

00:09:25,149 --> 00:09:29,350
performed on that attribute of class

00:09:27,069 --> 00:09:31,990
then those methods will be called

00:09:29,350 --> 00:09:34,120
instead of the yet default action this

00:09:31,990 --> 00:09:38,709
allows an attribute to override how

00:09:34,120 --> 00:09:40,420
those operations are going to work you

00:09:38,709 --> 00:09:43,240
may well be thinking that you never used

00:09:40,420 --> 00:09:44,740
made use of directives but fact is that

00:09:43,240 --> 00:09:49,540
function objects are actually

00:09:44,740 --> 00:09:51,160
descriptors I said they're wrong when a

00:09:49,540 --> 00:09:53,800
function is originally added to a class

00:09:51,160 --> 00:09:55,839
definition is a normal function when you

00:09:53,800 --> 00:09:58,060
access that function using a dotted

00:09:55,839 --> 00:10:00,459
attribute path you're invoking the

00:09:58,060 --> 00:10:02,949
dunder score get method to bind the

00:10:00,459 --> 00:10:07,389
function to the class instance turning

00:10:02,949 --> 00:10:09,130
it into a bound method of that object so

00:10:07,389 --> 00:10:10,990
when calling a method of a class it is

00:10:09,130 --> 00:10:12,880
not that underscore call method of the

00:10:10,990 --> 00:10:15,459
original function object that is called

00:10:12,880 --> 00:10:18,370
but the dundas call call method of the

00:10:15,459 --> 00:10:21,279
temporary object that is created as a

00:10:18,370 --> 00:10:23,649
result of accessing the function the

00:10:21,279 --> 00:10:25,540
problem with class method was that it is

00:10:23,649 --> 00:10:27,759
dependent on the descriptor protocol

00:10:25,540 --> 00:10:29,680
being applied as the dunder score call

00:10:27,759 --> 00:10:31,959
method only exists on the result

00:10:29,680 --> 00:10:36,339
returned by dunder score get when it's

00:10:31,959 --> 00:10:39,250
called the way to solve this is for

00:10:36,339 --> 00:10:41,500
wrappers to also be descriptors if the

00:10:39,250 --> 00:10:43,480
wrapper is applied to a normal function

00:10:41,500 --> 00:10:45,670
the dunder score call method of the

00:10:43,480 --> 00:10:47,139
wrapper is used if the wrapper is

00:10:45,670 --> 00:10:49,569
applied to a method of a class

00:10:47,139 --> 00:10:52,540
the dunder score get method is called

00:10:49,569 --> 00:10:55,029
which returns a new bound wrapper and

00:10:52,540 --> 00:10:57,699
the dundas call call method of that is

00:10:55,029 --> 00:10:59,800
invoked instead this allows our wrapper

00:10:57,699 --> 00:11:03,480
to be used around descriptors as it

00:10:59,800 --> 00:11:03,480
propagates the descriptor protocol

00:11:03,530 --> 00:11:07,760
so since using a function closure will

00:11:05,540 --> 00:11:09,440
ultimately fail if used around a

00:11:07,760 --> 00:11:11,780
decorator which is implemented as a

00:11:09,440 --> 00:11:14,210
descriptor the situation we therefore

00:11:11,780 --> 00:11:16,700
have is that if we want everything to

00:11:14,210 --> 00:11:19,130
work the decorators should always use

00:11:16,700 --> 00:11:23,000
this pattern the question now is how do

00:11:19,130 --> 00:11:25,490
we address the other issues we had we

00:11:23,000 --> 00:11:27,920
solved aiming using func tools wrappers

00:11:25,490 --> 00:11:30,410
and func tools update wrapper before but

00:11:27,920 --> 00:11:32,000
what do they do well wrappers just uses

00:11:30,410 --> 00:11:34,370
update wrapper so we just need to look

00:11:32,000 --> 00:11:36,170
at it I'll show what is in Python free

00:11:34,370 --> 00:11:37,100
dot free although that actually has an a

00:11:36,170 --> 00:11:38,780
bug in it as well

00:11:37,100 --> 00:11:42,470
which is fixed in part from three to

00:11:38,780 --> 00:11:44,000
four key thing to try and remember is we

00:11:42,470 --> 00:11:46,040
try and look at the body of the update

00:11:44,000 --> 00:11:48,050
wrapper function is what is in these

00:11:46,040 --> 00:11:51,260
default variables that get to pass as

00:11:48,050 --> 00:11:53,420
assigned and updated there isn't a sign

00:11:51,260 --> 00:11:56,450
of what we were originally manually

00:11:53,420 --> 00:11:59,180
assigning plus some extras the dunder

00:11:56,450 --> 00:12:00,230
score dipped in updates is something new

00:11:59,180 --> 00:12:03,470
though so we need to see what's

00:12:00,230 --> 00:12:05,500
happening with it looking at the body as

00:12:03,470 --> 00:12:07,940
a function free things are being done

00:12:05,500 --> 00:12:09,710
first off a reference to the wrapped

00:12:07,940 --> 00:12:12,140
function is saved at the underscore

00:12:09,710 --> 00:12:14,690
wrapped this is the barger so it should

00:12:12,140 --> 00:12:16,430
be done last the second is to copy those

00:12:14,690 --> 00:12:18,800
attributes such as dunder school name

00:12:16,430 --> 00:12:20,630
and underscore docx finally the third

00:12:18,800 --> 00:12:22,760
thing is to copy the contents of dunder

00:12:20,630 --> 00:12:24,800
score depth from the wrapped function

00:12:22,760 --> 00:12:26,870
into the wrapper which could actually

00:12:24,800 --> 00:12:30,200
result in quite a lot of objects needing

00:12:26,870 --> 00:12:33,080
to be copied if we are using a function

00:12:30,200 --> 00:12:34,970
closure or straight class wrapper this

00:12:33,080 --> 00:12:37,430
copying is able to be done at the point

00:12:34,970 --> 00:12:39,380
that the decorator is applied with the

00:12:37,430 --> 00:12:41,630
wrapper being a descriptor though it

00:12:39,380 --> 00:12:44,450
technically now also needs to be done in

00:12:41,630 --> 00:12:46,580
the bound wrapper as the bound wrapper

00:12:44,450 --> 00:12:48,589
is created every time the wrapper is

00:12:46,580 --> 00:12:51,530
called for a function bounds or class

00:12:48,589 --> 00:12:56,240
this is going to be too slow we need a

00:12:51,530 --> 00:12:57,589
more performant way of handling this the

00:12:56,240 --> 00:13:00,470
solution is what's called an object

00:12:57,589 --> 00:13:03,260
proxy this is a special wrapper class

00:13:00,470 --> 00:13:06,080
which looks and behaves like what it

00:13:03,260 --> 00:13:07,550
wraps is a complicated beast in its own

00:13:06,080 --> 00:13:10,070
right so I'm actually going to just

00:13:07,550 --> 00:13:12,320
gloss over a lot of details of this in

00:13:10,070 --> 00:13:14,060
short though it copies limited

00:13:12,320 --> 00:13:16,580
attributes from the wrapped object to

00:13:14,060 --> 00:13:17,329
itself and otherwise use a special

00:13:16,580 --> 00:13:20,540
method

00:13:17,329 --> 00:13:22,850
produce and underscore get Atta to fetch

00:13:20,540 --> 00:13:28,069
attributes from the wrapped object only

00:13:22,850 --> 00:13:30,410
when required what we now do is derive

00:13:28,069 --> 00:13:33,439
our wrapper class from the object proxy

00:13:30,410 --> 00:13:35,540
doing so attributes like dunder school

00:13:33,439 --> 00:13:37,399
name and underscore dot when crude from

00:13:35,540 --> 00:13:39,739
the wrapper return the values for the

00:13:37,399 --> 00:13:43,279
wrapped function News do calls like

00:13:39,739 --> 00:13:45,829
inspect get egg args big and inspect get

00:13:43,279 --> 00:13:49,970
source will also work and return what we

00:13:45,829 --> 00:13:51,679
expect so we have pattern now for

00:13:49,970 --> 00:13:53,839
implementing a decorator that appears to

00:13:51,679 --> 00:13:55,519
work correctly but needing to do all

00:13:53,839 --> 00:13:58,040
that each time is more work than we

00:13:55,519 --> 00:14:00,350
really want what we can do therefore is

00:13:58,040 --> 00:14:03,439
create a decorator to help us to create

00:14:00,350 --> 00:14:05,119
decorators this would reduce the code we

00:14:03,439 --> 00:14:08,029
need to write for each decorator to a

00:14:05,119 --> 00:14:09,230
single function as shown what would this

00:14:08,029 --> 00:14:12,649
decorator Factor need to look like

00:14:09,230 --> 00:14:14,720
though as it turns out our decorator

00:14:12,649 --> 00:14:16,929
factor is quite simple and it isn't

00:14:14,720 --> 00:14:19,309
really much different to using a partial

00:14:16,929 --> 00:14:21,499
combining our new wrapper function

00:14:19,309 --> 00:14:24,139
argument from when the decorator is

00:14:21,499 --> 00:14:26,269
defined with the wrapped function when

00:14:24,139 --> 00:14:30,649
the decorator is used and passing them

00:14:26,269 --> 00:14:32,720
into our function wrapper object the

00:14:30,649 --> 00:14:34,730
dunder score call method of our function

00:14:32,720 --> 00:14:37,309
wrapper for when the wrapper is used

00:14:34,730 --> 00:14:39,110
around a normal function now just calls

00:14:37,309 --> 00:14:42,259
the decorator wrapper function with the

00:14:39,110 --> 00:14:43,879
wrapped function and arguments leaving

00:14:42,259 --> 00:14:45,549
the calling of the wrapped function up

00:14:43,879 --> 00:14:49,069
to the decorator wrapper function

00:14:45,549 --> 00:14:52,279
totally losing at this point I guess in

00:14:49,069 --> 00:14:53,809
the case we're binding a function the

00:14:52,279 --> 00:15:07,249
wrapper is also passed as a bound

00:14:53,809 --> 00:15:08,259
wrapper I'll let you digest that one the

00:15:07,249 --> 00:15:10,089
bound wrap

00:15:08,259 --> 00:15:12,040
more or less the same with the Dundas

00:15:10,089 --> 00:15:14,679
core coal method delegating to the

00:15:12,040 --> 00:15:17,259
decorator wrapper function so we can

00:15:14,679 --> 00:15:20,049
make creating decorators easier using a

00:15:17,259 --> 00:15:21,699
factory let's see what we had how we

00:15:20,049 --> 00:15:22,809
solved those other problems we will see

00:15:21,699 --> 00:15:26,199
well let's see what other problems we

00:15:22,809 --> 00:15:28,419
can find the first such issue in

00:15:26,199 --> 00:15:31,569
creating decorators that can work on

00:15:28,419 --> 00:15:33,189
both normal functions and instance

00:15:31,569 --> 00:15:35,709
methods of class that's the first one we

00:15:33,189 --> 00:15:37,629
have to solve changing our decorator to

00:15:35,709 --> 00:15:39,639
print out the arguments pass for a

00:15:37,629 --> 00:15:43,689
normal function we obviously just get a

00:15:39,639 --> 00:15:45,579
couple of two arguments do the same for

00:15:43,689 --> 00:15:48,160
an instance method and the result is the

00:15:45,579 --> 00:15:49,989
same the problem here is what if the

00:15:48,160 --> 00:15:52,809
decorator wanted to know what the actual

00:15:49,989 --> 00:15:54,549
instance of the class was we have lost

00:15:52,809 --> 00:15:56,829
that information when the function was

00:15:54,549 --> 00:15:58,689
bound to the class it is now associated

00:15:56,829 --> 00:16:01,269
with the wrapped function passed in

00:15:58,689 --> 00:16:03,100
rather than the argument list and if

00:16:01,269 --> 00:16:05,889
you've used normal function closures

00:16:03,100 --> 00:16:07,779
over on a on a method of class you'll

00:16:05,889 --> 00:16:09,579
know what you usually happens is you get

00:16:07,779 --> 00:16:13,089
the self argument passed and explicitly

00:16:09,579 --> 00:16:15,100
so we don't have that in this case to

00:16:13,089 --> 00:16:17,319
solve this problem we can remember what

00:16:15,100 --> 00:16:20,109
the instance was that was passed to the

00:16:17,319 --> 00:16:22,269
dunder score get method when it was

00:16:20,109 --> 00:16:24,519
called to bind the function this can

00:16:22,269 --> 00:16:28,600
then be passed through to the bound

00:16:24,519 --> 00:16:30,970
wrapper when it is created in the

00:16:28,600 --> 00:16:32,589
boundary the instance pointer can then

00:16:30,970 --> 00:16:35,519
be passed through to the decorator

00:16:32,589 --> 00:16:37,869
wrapper function as an extra argument

00:16:35,519 --> 00:16:39,850
you may have missed it but on the

00:16:37,869 --> 00:16:41,739
previous slide just to be uniform for

00:16:39,850 --> 00:16:44,199
the case of a normal function in that

00:16:41,739 --> 00:16:46,660
top-level wrapper we passed none for

00:16:44,199 --> 00:16:50,379
this new instance of argument so down

00:16:46,660 --> 00:16:52,299
the bottom they were on the right this

00:16:50,379 --> 00:16:54,789
then allows us to be able to distinguish

00:16:52,299 --> 00:16:56,739
between a normal function call and an

00:16:54,789 --> 00:16:59,319
instance method call within the one

00:16:56,739 --> 00:17:00,699
decorator wrapper function the reference

00:16:59,319 --> 00:17:02,529
to the instance has even passed

00:17:00,699 --> 00:17:04,510
separately so we don't have to juggle

00:17:02,529 --> 00:17:08,769
with the arguments to move it out of the

00:17:04,510 --> 00:17:10,839
way for an instance method unfortunately

00:17:08,769 --> 00:17:14,500
we aren't done though as when calling an

00:17:10,839 --> 00:17:16,569
instance method via the class so passing

00:17:14,500 --> 00:17:18,399
in the instance as an argument the

00:17:16,569 --> 00:17:20,319
instance pass to the decorator function

00:17:18,399 --> 00:17:21,829
is none instead the reference to the

00:17:20,319 --> 00:17:25,699
instance gets passed through as the

00:17:21,829 --> 00:17:27,470
first argument the deal is this

00:17:25,699 --> 00:17:29,720
variation we can check for instance

00:17:27,470 --> 00:17:31,490
being none before calling the decorator

00:17:29,720 --> 00:17:33,860
wrapper function and pop the instance

00:17:31,490 --> 00:17:36,200
off the start of the argument list we

00:17:33,860 --> 00:17:38,899
then use a partial to bind the instance

00:17:36,200 --> 00:17:41,179
to the wrap function ourselves and call

00:17:38,899 --> 00:17:42,710
the decorator wrapper function we then

00:17:41,179 --> 00:17:44,210
get the same result no matter whether

00:17:42,710 --> 00:17:48,799
the instance methods are called by the

00:17:44,210 --> 00:17:50,480
class or not this fiddle does though

00:17:48,799 --> 00:17:53,210
upset things for when we have a class

00:17:50,480 --> 00:17:55,909
method also causing the same issue for a

00:17:53,210 --> 00:17:58,970
static method in both those cases the

00:17:55,909 --> 00:18:00,860
instance is also passed as none the

00:17:58,970 --> 00:18:03,019
result is that the first the real first

00:18:00,860 --> 00:18:06,980
argument ends up as the instance which

00:18:03,019 --> 00:18:08,570
is obviously going to be quite wrong we

00:18:06,980 --> 00:18:10,159
can handle that in the top-level wrapper

00:18:08,570 --> 00:18:13,340
by looking at the type of the wrapped

00:18:10,159 --> 00:18:16,010
function prior to doing binding if it is

00:18:13,340 --> 00:18:18,139
a class method or static method then we

00:18:16,010 --> 00:18:20,870
know anything else is likely to be an

00:18:18,139 --> 00:18:23,450
instance methods for a class or static

00:18:20,870 --> 00:18:25,279
method we used the original bounds and

00:18:23,450 --> 00:18:27,289
wrap up before the fiddle was added and

00:18:25,279 --> 00:18:28,789
moves the fiddle into a version of the

00:18:27,289 --> 00:18:32,480
wrapper specifically for instance

00:18:28,789 --> 00:18:35,240
methods we're still not quite there

00:18:32,480 --> 00:18:38,149
though the argument list is Right again

00:18:35,240 --> 00:18:40,250
but the instance is still not for a

00:18:38,149 --> 00:18:42,080
static method this is a problem probably

00:18:40,250 --> 00:18:44,659
quite reasonable since it isn't really

00:18:42,080 --> 00:18:46,340
much different to a normal function for

00:18:44,659 --> 00:18:48,110
a class method though it would be nice

00:18:46,340 --> 00:18:50,590
for the instance to actually be path

00:18:48,110 --> 00:18:52,700
they actually is a class type

00:18:50,590 --> 00:18:55,909
corresponding to the initial class

00:18:52,700 --> 00:18:57,230
argument for the class method the big

00:18:55,909 --> 00:19:00,860
question is where there is another way

00:18:57,230 --> 00:19:03,380
of getting this turns out there is a way

00:19:00,860 --> 00:19:05,809
of still getting the class getting the

00:19:03,380 --> 00:19:08,330
class for the getting mixed up your Mon

00:19:05,809 --> 00:19:10,250
own notes here I get this one right

00:19:08,330 --> 00:19:12,350
turns out there is a way of still

00:19:10,250 --> 00:19:15,769
getting the class the class method is

00:19:12,350 --> 00:19:17,779
bound this is by accessing a special @

00:19:15,769 --> 00:19:20,809
redundant under the underscore self of

00:19:17,779 --> 00:19:22,700
the bound function we therefore ignore

00:19:20,809 --> 00:19:24,799
the instance that underscore get method

00:19:22,700 --> 00:19:29,659
was passed and used ad underscore self

00:19:24,799 --> 00:19:31,730
attribute instead success finally we now

00:19:29,659 --> 00:19:34,070
have the instance argument for an

00:19:31,730 --> 00:19:35,220
instance method being the instance of

00:19:34,070 --> 00:19:37,260
the class

00:19:35,220 --> 00:19:39,750
for a class method it is the class

00:19:37,260 --> 00:19:43,710
itself and for a normal function the

00:19:39,750 --> 00:19:46,110
instance is none we have one more

00:19:43,710 --> 00:19:48,870
situation to consider though that is

00:19:46,110 --> 00:19:51,270
where we want to decorate a class what

00:19:48,870 --> 00:19:53,580
happens in in this case the instance is

00:19:51,270 --> 00:19:55,590
still none so from that we cannot

00:19:53,580 --> 00:19:58,080
distinguish it from a normal function if

00:19:55,590 --> 00:20:00,800
we also look at the wrap function though

00:19:58,080 --> 00:20:03,750
we will see that it is a class type

00:20:00,800 --> 00:20:05,720
whereas it would be a function in the

00:20:03,750 --> 00:20:08,160
case of a normal function being called

00:20:05,720 --> 00:20:10,470
so we luckily may have a way

00:20:08,160 --> 00:20:12,690
distinguished so this works out okay

00:20:10,470 --> 00:20:14,610
because we can look at the type of what

00:20:12,690 --> 00:20:16,710
is being wrapped in this case this means

00:20:14,610 --> 00:20:19,740
we can now have the ability to create a

00:20:16,710 --> 00:20:21,840
universal decorator that is a decorator

00:20:19,740 --> 00:20:24,240
that can determine what it is wrapping

00:20:21,840 --> 00:20:26,910
this does away with a need to create

00:20:24,240 --> 00:20:28,800
separate decorators for functions and

00:20:26,910 --> 00:20:33,480
instance methods which would otherwise

00:20:28,800 --> 00:20:36,030
do the same thing as a decorator so far

00:20:33,480 --> 00:20:37,790
did not allow arguments to be supplied

00:20:36,030 --> 00:20:40,110
when being applied to a function if

00:20:37,790 --> 00:20:42,210
arguments to the decorator are required

00:20:40,110 --> 00:20:44,190
the decorated definition can be nested

00:20:42,210 --> 00:20:46,890
within a function to create a function

00:20:44,190 --> 00:20:49,530
closure when the outer decorator factory

00:20:46,890 --> 00:20:52,020
function is used it returns the inner

00:20:49,530 --> 00:20:54,450
decorator function positional or keyword

00:20:52,020 --> 00:20:56,340
arguments could be used here but I have

00:20:54,450 --> 00:20:58,020
a preference for using kemah keyword

00:20:56,340 --> 00:20:59,910
arguments as possibly a better

00:20:58,020 --> 00:21:00,950
convention I will explain why in a

00:20:59,910 --> 00:21:04,380
moment

00:21:00,950 --> 00:21:06,390
so if arguments have default values the

00:21:04,380 --> 00:21:08,820
outer decorator Factory would take the

00:21:06,390 --> 00:21:11,190
wrap function as first argument with

00:21:08,820 --> 00:21:14,370
none as a default the decorator

00:21:11,190 --> 00:21:16,620
arguments follow decorator arguments

00:21:14,370 --> 00:21:19,380
would now be passed as keyword arguments

00:21:16,620 --> 00:21:21,690
on the first call wrapped will be none

00:21:19,380 --> 00:21:24,690
and a partial is used to return the

00:21:21,690 --> 00:21:27,480
decorator factory again on the second

00:21:24,690 --> 00:21:30,860
call wrapped is passed and this time it

00:21:27,480 --> 00:21:33,330
is wrapped with a decorator function

00:21:30,860 --> 00:21:35,310
because we have default arguments though

00:21:33,330 --> 00:21:37,590
we don't actually need to pass the

00:21:35,310 --> 00:21:39,840
arguments in which case the decorator

00:21:37,590 --> 00:21:41,510
factory is applied direct to the

00:21:39,840 --> 00:21:44,490
function being decorated

00:21:41,510 --> 00:21:47,070
because wrapped is not none when passed

00:21:44,490 --> 00:21:48,630
in the decorator is wrapped around the

00:21:47,070 --> 00:21:50,130
function immediately

00:21:48,630 --> 00:21:54,630
skipping the return of the factory a

00:21:50,130 --> 00:21:56,040
second time now why I said a convention

00:21:54,630 --> 00:21:58,230
of having keyword arguments it's

00:21:56,040 --> 00:22:00,210
probably a good idea is that Python free

00:21:58,230 --> 00:22:03,450
allows you to enforce it using the new

00:22:00,210 --> 00:22:05,100
keyword only argument syntax this way

00:22:03,450 --> 00:22:07,320
you avoid the problems of someone

00:22:05,100 --> 00:22:09,030
passing in a decorator argument as the

00:22:07,320 --> 00:22:12,360
positional argument for wrapped by

00:22:09,030 --> 00:22:14,460
mistake for consistency keyword only

00:22:12,360 --> 00:22:16,530
arguments can also be enforced for

00:22:14,460 --> 00:22:21,060
required arguments even though it isn't

00:22:16,530 --> 00:22:22,410
strictly necessary the final result is

00:22:21,060 --> 00:22:24,390
we now have a means of creating

00:22:22,410 --> 00:22:27,660
decorators that preserves the function

00:22:24,390 --> 00:22:29,880
name documentation strings argument

00:22:27,660 --> 00:22:32,880
specification and even retrieving a

00:22:29,880 --> 00:22:36,240
source code one decorator can be used on

00:22:32,880 --> 00:22:38,700
classes functions instance methods and

00:22:36,240 --> 00:22:41,070
class methods is also easy to support

00:22:38,700 --> 00:22:42,620
decorator arguments even allowing them

00:22:41,070 --> 00:22:47,340
to be optional if desired

00:22:42,620 --> 00:22:50,280
so one magic decorator so this has been

00:22:47,340 --> 00:22:52,020
a whirlwind tour of this topic as much

00:22:50,280 --> 00:22:54,300
as I covered it still doesn't actually

00:22:52,020 --> 00:22:56,520
cover everything I could and and since

00:22:54,300 --> 00:22:59,850
this is actually slide so I did last

00:22:56,520 --> 00:23:03,630
year some of the details of how I do it

00:22:59,850 --> 00:23:05,640
have changed a bit so the blog post

00:23:03,630 --> 00:23:07,710
series I did back at the beginning of

00:23:05,640 --> 00:23:10,230
the year if you want to know more about

00:23:07,710 --> 00:23:12,000
it go back and read those because they

00:23:10,230 --> 00:23:13,980
have the final solution I ended up with

00:23:12,000 --> 00:23:15,720
for this and it covers some more little

00:23:13,980 --> 00:23:19,080
caveats and corner cases which I found

00:23:15,720 --> 00:23:21,090
that I'm not covered in here so you can

00:23:19,080 --> 00:23:23,160
go to the blog so you actually may if

00:23:21,090 --> 00:23:24,930
you go to blogger blog post so it's it's

00:23:23,160 --> 00:23:27,570
blogger blogger is a pain I don't know

00:23:24,930 --> 00:23:29,880
if you ever used it so you may find it

00:23:27,570 --> 00:23:31,950
actually easier to go to my github repo

00:23:29,880 --> 00:23:34,140
for wrapped and under there you'll find

00:23:31,950 --> 00:23:36,060
a subdirectory called blog and there's

00:23:34,140 --> 00:23:37,500
an index in there of all of the blog

00:23:36,060 --> 00:23:39,720
person there in order rather than having

00:23:37,500 --> 00:23:42,330
to go through the mess of blogger now

00:23:39,720 --> 00:23:50,070
I'm up to blog post ten I think in that

00:23:42,330 --> 00:23:51,450
series I'm not done I actually wanna I

00:23:50,070 --> 00:23:53,100
still haven't even finish talking about

00:23:51,450 --> 00:23:55,800
the decorator spot and I want to talk

00:23:53,100 --> 00:23:58,530
next about how the decorator module does

00:23:55,800 --> 00:23:59,760
it which it tries to use some magic to

00:23:58,530 --> 00:24:02,290
try and solve this problem too but

00:23:59,760 --> 00:24:03,970
doesn't solve all the problems be

00:24:02,290 --> 00:24:07,210
that I want to talk about object proxies

00:24:03,970 --> 00:24:09,790
I want to then talk about the case of

00:24:07,210 --> 00:24:11,350
monkey monkey patching and function

00:24:09,790 --> 00:24:13,890
wrappers and how generally you use them

00:24:11,350 --> 00:24:17,140
because decorators in some respects is a

00:24:13,890 --> 00:24:19,180
subset of monkey pesci monkey patching

00:24:17,140 --> 00:24:22,900
is applying a function wrappers decorate

00:24:19,180 --> 00:24:25,450
is just a a sanitized version you can

00:24:22,900 --> 00:24:26,950
use in your own code manually so I want

00:24:25,450 --> 00:24:28,330
to talk about all that as well and I

00:24:26,950 --> 00:24:31,660
want to talk about some other topics to

00:24:28,330 --> 00:24:33,550
do with post import hooks so I could go

00:24:31,660 --> 00:24:40,120
another 10 posts yet so if you're

00:24:33,550 --> 00:24:42,790
interested people I have now so I should

00:24:40,120 --> 00:24:45,280
say this so if you did go to to Colton

00:24:42,790 --> 00:24:47,230
Meyers talk this morning okay decorators

00:24:45,280 --> 00:24:49,630
are easy they're easy as you can see by

00:24:47,230 --> 00:24:51,820
what explain well they're actually a bit

00:24:49,630 --> 00:24:53,290
more complicated than that now rather

00:24:51,820 --> 00:24:56,170
than go and try and duplicate everything

00:24:53,290 --> 00:24:58,720
I've done which could blow your mind a

00:24:56,170 --> 00:25:00,970
bit I do have I have done a listen to a

00:24:58,720 --> 00:25:05,860
package it's called wrapped its up on

00:25:00,970 --> 00:25:07,720
guitar picks up on pipe i and as I say

00:25:05,860 --> 00:25:09,190
it it's as you saw from Colton Meyers

00:25:07,720 --> 00:25:10,600
examples this morning if you saw that

00:25:09,190 --> 00:25:12,670
because I actually don't have a good

00:25:10,600 --> 00:25:17,350
example in here it simplifies the whole

00:25:12,670 --> 00:25:18,580
process if you're going to things way if

00:25:17,350 --> 00:25:21,040
you're going to write decorators for

00:25:18,580 --> 00:25:23,920
yourself you know you fall in the 90%

00:25:21,040 --> 00:25:25,720
where that using a function closure it

00:25:23,920 --> 00:25:27,790
probably I happily satisfy everything

00:25:25,720 --> 00:25:29,680
you need to do but if you need to make

00:25:27,790 --> 00:25:32,260
it work if you're going to provide a

00:25:29,680 --> 00:25:35,350
decorator and a library which has to be

00:25:32,260 --> 00:25:37,330
used by other people then try and use

00:25:35,350 --> 00:25:39,610
wrapped because you'll know then that it

00:25:37,330 --> 00:25:42,400
should work and not have all these funny

00:25:39,610 --> 00:25:45,010
caveats and corner cases so try it and

00:25:42,400 --> 00:25:47,290
see how you go now I'll move into

00:25:45,010 --> 00:25:49,380
questions in a sec but I will one more

00:25:47,290 --> 00:25:51,580
plug so I work for New Relic

00:25:49,380 --> 00:25:53,380
the reason I know about all this stuff

00:25:51,580 --> 00:25:57,700
is because we do horrible stuff with

00:25:53,380 --> 00:26:00,370
monkey patching we take your code which

00:25:57,700 --> 00:26:02,770
you run in production you trust as

00:26:00,370 --> 00:26:06,280
amazingly because I go in there and do

00:26:02,770 --> 00:26:09,130
lots and lots of nasty stuff to it this

00:26:06,280 --> 00:26:12,400
is why I worry about this stuff

00:26:09,130 --> 00:26:14,230
and make it sure it works because if I

00:26:12,400 --> 00:26:15,240
do something wrong and use a function

00:26:14,230 --> 00:26:16,770
closure

00:26:15,240 --> 00:26:18,510
there are lots of lots of cases we'll

00:26:16,770 --> 00:26:21,120
all break your code and you'll come

00:26:18,510 --> 00:26:22,620
screaming at us so that's why I'm

00:26:21,120 --> 00:26:26,010
interesting all this stuff anyway we've

00:26:22,620 --> 00:26:27,840
got taste of pie party on tonight so if

00:26:26,010 --> 00:26:31,380
you aren't already scooting off to some

00:26:27,840 --> 00:26:34,740
of the other restaurant more formal you

00:26:31,380 --> 00:26:36,210
know things please come along I guess

00:26:34,740 --> 00:26:38,160
there'll be a big congregation of people

00:26:36,210 --> 00:26:40,800
at some point we'll all head down so

00:26:38,160 --> 00:26:42,630
come along and enjoy that and I can talk

00:26:40,800 --> 00:26:43,800
to you later about any of this stuff but

00:26:42,630 --> 00:26:48,120
otherwise right now if you've got any

00:26:43,800 --> 00:26:49,140
questions so if you have questions you

00:26:48,120 --> 00:26:50,850
can just put up your hand do we have

00:26:49,140 --> 00:26:52,320
time for maybe one or two and I'll just

00:26:50,850 --> 00:26:53,250
run over to you and give you the mic so

00:26:52,320 --> 00:26:59,790
please raise your hand if you have a

00:26:53,250 --> 00:27:01,110
question for Graham I guess two two

00:26:59,790 --> 00:27:03,240
quick things not necessarily quite

00:27:01,110 --> 00:27:06,809
related you still have in the current

00:27:03,240 --> 00:27:09,270
version of pack of unwrapped the you do

00:27:06,809 --> 00:27:10,590
is is is instance of class method or

00:27:09,270 --> 00:27:13,110
static method so if somebody were to

00:27:10,590 --> 00:27:15,030
implement that that were to effectively

00:27:13,110 --> 00:27:18,059
remove some of the arguments but didn't

00:27:15,030 --> 00:27:22,470
subclass class method then it would

00:27:18,059 --> 00:27:23,910
still break sorry let me see if I found

00:27:22,470 --> 00:27:26,070
what you're asking if I were to

00:27:23,910 --> 00:27:28,200
implement class method myself yet as

00:27:26,070 --> 00:27:31,950
opposed to using the version that's part

00:27:28,200 --> 00:27:39,570
of standard Python would wrapped handle

00:27:31,950 --> 00:27:48,840
that correctly no it does look at the

00:27:39,570 --> 00:27:51,420
type is this a Mike store there's a stop

00:27:48,840 --> 00:27:53,400
working I don't hear the huge echoes

00:27:51,420 --> 00:27:56,660
coming back like I was before so it

00:27:53,400 --> 00:27:56,660
obviously you mustn't be working

00:28:01,620 --> 00:28:09,299
we might get a lot of echo now okay to

00:28:06,100 --> 00:28:12,549
quit the question was as I understand it

00:28:09,299 --> 00:28:16,840
the some of the magic that I explained

00:28:12,549 --> 00:28:19,950
there it was it worked by looking at

00:28:16,840 --> 00:28:23,970
whether you're using class method or

00:28:19,950 --> 00:28:26,289
static method decorators already and

00:28:23,970 --> 00:28:30,280
some of the magic was dependent upon

00:28:26,289 --> 00:28:34,510
that what that means is if that you were

00:28:30,280 --> 00:28:36,600
to go and implement class method or

00:28:34,510 --> 00:28:38,409
static method decorators yourself

00:28:36,600 --> 00:28:41,440
corrects what you're asking

00:28:38,409 --> 00:28:44,650
we'll wrap still work the answer is for

00:28:41,440 --> 00:28:47,830
those things no the trick though because

00:28:44,650 --> 00:28:49,720
I've tested this is if you really needed

00:28:47,830 --> 00:28:51,820
to do that for some reason to extend

00:28:49,720 --> 00:28:53,980
class method and static method and

00:28:51,820 --> 00:28:56,950
change it slightly for some reason you

00:28:53,980 --> 00:28:59,049
can actually derive from them and once

00:28:56,950 --> 00:29:01,360
you do that the is instance check for

00:28:59,049 --> 00:29:04,260
static method of classmates to works and

00:29:01,360 --> 00:29:04,260
wrap still works

00:29:13,269 --> 00:29:18,110
okay the question is whether I see this

00:29:16,460 --> 00:29:21,379
as something that could go into the

00:29:18,110 --> 00:29:25,490
standard library it's something that has

00:29:21,379 --> 00:29:27,200
been suggested at the minimum because

00:29:25,490 --> 00:29:28,820
you know wrapped is great wrapped is

00:29:27,200 --> 00:29:31,249
great to play with and I've got lots of

00:29:28,820 --> 00:29:33,289
ideas it's not just the function

00:29:31,249 --> 00:29:35,059
wrappers and the decorator Factory which

00:29:33,289 --> 00:29:37,330
I've explained now I've got stuff in

00:29:35,059 --> 00:29:40,369
there for function you post import hooks

00:29:37,330 --> 00:29:42,440
and monkey-patching functions and things

00:29:40,369 --> 00:29:44,389
like that so it goes a long way beyond

00:29:42,440 --> 00:29:46,610
that but one of the key things in the

00:29:44,389 --> 00:29:50,809
Rapf library is this magic object proxy

00:29:46,610 --> 00:29:54,590
which I totally didn't talk about there

00:29:50,809 --> 00:29:57,889
there is a a week rift proxy object

00:29:54,590 --> 00:30:00,169
which sort of is a object proxy but it's

00:29:57,889 --> 00:30:00,919
not because it's a special one related

00:30:00,169 --> 00:30:04,399
to week rifts

00:30:00,919 --> 00:30:05,749
so there's no just object proxy

00:30:04,399 --> 00:30:07,850
implementation in the standard library

00:30:05,749 --> 00:30:09,919
so one of the things that Malee's come

00:30:07,850 --> 00:30:11,210
out of this is that perhaps if once

00:30:09,919 --> 00:30:13,519
people verify that what I've done is

00:30:11,210 --> 00:30:15,619
right and not just insane it's that at

00:30:13,519 --> 00:30:17,419
least the object proxy could go into the

00:30:15,619 --> 00:30:19,759
standard library because I know it's

00:30:17,419 --> 00:30:21,470
something that Nick Coughlin had the

00:30:19,759 --> 00:30:22,639
idea of pushing that we should have

00:30:21,470 --> 00:30:24,470
something like that in the standard

00:30:22,639 --> 00:30:26,090
library number years back and nothing if

00:30:24,470 --> 00:30:29,559
it happened so I have had a big

00:30:26,090 --> 00:30:32,330
discussion on that for everything else

00:30:29,559 --> 00:30:34,789
yeah getting the actual decorator factor

00:30:32,330 --> 00:30:37,129
in there would be really nice but I feel

00:30:34,789 --> 00:30:39,259
like once I do that I've lost a bit of

00:30:37,129 --> 00:30:44,059
control to play with it so you see heavy

00:30:39,259 --> 00:30:45,259
care I think that's all we have time for

00:30:44,059 --> 00:30:47,499
so let's give Graham a big round of

00:30:45,259 --> 00:30:47,499

YouTube URL: https://www.youtube.com/watch?v=7jGtDGxgwEY


