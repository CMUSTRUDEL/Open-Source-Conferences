Title: Brandon Rhodes: The Day of the EXE Is Upon Us - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Brandon Rhodes

It was once quite painful to build your Python app as a single .exe file. Support forums filled with lamentations as users struggled with primitive tools. But today, two separate tools exist for compiling your Python to real machine language! Come learn about how one of the biggest problems in commercial and enterprise software has now been solved and how you can benefit from this achievement.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:02,240 --> 00:00:11,599
well welcome to the beginning of the end

00:00:04,859 --> 00:00:15,150
I see that that that uh the river are

00:00:11,599 --> 00:00:17,039
all tired I'm not saying you look tired

00:00:15,150 --> 00:00:20,490
I'm just saying that I can tell because

00:00:17,039 --> 00:00:22,800
I know you so well and we're almost near

00:00:20,490 --> 00:00:25,500
the end and you've hung in there this

00:00:22,800 --> 00:00:27,930
talk some lightning talks and we will

00:00:25,500 --> 00:00:31,019
all be done I'm Brandon Rhodes and I'm

00:00:27,930 --> 00:00:33,649
here to announce that the day of the exe

00:00:31,019 --> 00:00:39,750
is upon us

00:00:33,649 --> 00:00:42,000
old von Neumann dr. von Neumann he threw

00:00:39,750 --> 00:00:43,170
us a real curveball it used to be you

00:00:42,000 --> 00:00:45,300
knew what your computer would do you

00:00:43,170 --> 00:00:48,329
when you switched it on because before

00:00:45,300 --> 00:00:51,420
powering it up you disconnected and

00:00:48,329 --> 00:00:53,640
reconnected a bunch of wires to set up

00:00:51,420 --> 00:00:56,129
what computation the computer would do

00:00:53,640 --> 00:00:58,770
when you turned on and it was von

00:00:56,129 --> 00:01:01,530
Neumann that catapulted us into the

00:00:58,770 --> 00:01:03,979
computing age by suggesting that instead

00:01:01,530 --> 00:01:08,460
of having to set the computer up for a

00:01:03,979 --> 00:01:11,880
specific calculation you could just have

00:01:08,460 --> 00:01:14,880
a general-purpose machine called it that

00:01:11,880 --> 00:01:16,979
read instructions right out of memory

00:01:14,880 --> 00:01:20,220
just like computers had already been

00:01:16,979 --> 00:01:22,619
reading data the swept to the world so

00:01:20,220 --> 00:01:26,220
that by the time I grew up and learned

00:01:22,619 --> 00:01:30,360
machine language on the little colored

00:01:26,220 --> 00:01:33,240
computers to that my dad bought a hex 86

00:01:30,360 --> 00:01:37,070
sitting in memory what is it what does

00:01:33,240 --> 00:01:41,189
it mean what is that by going to do it

00:01:37,070 --> 00:01:43,740
depended it depended on whether you told

00:01:41,189 --> 00:01:46,020
the processor that it should run that as

00:01:43,740 --> 00:01:48,869
an instruction that it is a command it

00:01:46,020 --> 00:01:52,049
should obey or whether you simply treat

00:01:48,869 --> 00:01:55,890
it treated it as data but it looked

00:01:52,049 --> 00:01:58,770
exactly the same either way so if I saw

00:01:55,890 --> 00:02:01,320
86 86 sitting in memory it could mean

00:01:58,770 --> 00:02:05,310
the instruction load a value into

00:02:01,320 --> 00:02:07,350
register a and here's the number 134 x86

00:02:05,310 --> 00:02:10,140
that you are to load instruction and

00:02:07,350 --> 00:02:10,759
data scattered together in memory and

00:02:10,140 --> 00:02:15,319
you

00:02:10,759 --> 00:02:18,049
and tell the difference you can't tell

00:02:15,319 --> 00:02:19,220
just by looking at it you can guess but

00:02:18,049 --> 00:02:22,310
you don't know what's supposed to be

00:02:19,220 --> 00:02:25,569
code and what's supposed to be data some

00:02:22,310 --> 00:02:29,060
called dr. Von Neumanns idea ambiguous

00:02:25,569 --> 00:02:31,580
some people said that his ideas were

00:02:29,060 --> 00:02:32,780
dangerous but I prefer to look at it a

00:02:31,580 --> 00:02:34,549
bit differently when I walk into the

00:02:32,780 --> 00:02:36,230
coffee shop and am asked what

00:02:34,549 --> 00:02:38,660
programming language I'm using and I'm

00:02:36,230 --> 00:02:42,620
like oh it's it's really cool it's

00:02:38,660 --> 00:02:48,170
really really homo iconic even I can't

00:02:42,620 --> 00:02:51,620
tell my data from my code sometimes it's

00:02:48,170 --> 00:02:54,260
really bare metal it's a really really

00:02:51,620 --> 00:02:56,450
low level which is course is a complete

00:02:54,260 --> 00:03:01,359
lie did you know that Intel like a

00:02:56,450 --> 00:03:03,890
decade ago Intel got sick sick of x86

00:03:01,359 --> 00:03:05,480
machine language and they refused to

00:03:03,890 --> 00:03:06,709
implement it anymore

00:03:05,480 --> 00:03:08,720
they have engineers that write a

00:03:06,709 --> 00:03:10,849
translator that translates it into what

00:03:08,720 --> 00:03:12,500
they call micro ops which is a cleaner

00:03:10,849 --> 00:03:14,060
machine language that they're actually

00:03:12,500 --> 00:03:16,370
willing to implement on their own

00:03:14,060 --> 00:03:18,169
processors I tell them that if machine

00:03:16,370 --> 00:03:20,359
language is just going to be a JIT

00:03:18,169 --> 00:03:23,180
interpreted layer they need to do better

00:03:20,359 --> 00:03:25,450
marketing and just call it x86 dot J

00:03:23,180 --> 00:03:25,450
asked

00:03:28,400 --> 00:03:34,110
and I think that it would sell better so

00:03:32,340 --> 00:03:37,290
more chips and that everyone would then

00:03:34,110 --> 00:03:40,409
believe it was really bare-metal given

00:03:37,290 --> 00:03:44,340
von neumann's idea that code and data

00:03:40,409 --> 00:03:47,549
would all be numbers the idea this

00:03:44,340 --> 00:03:50,670
interesting recursive idea was invented

00:03:47,549 --> 00:03:54,269
of a compiler a piece of code that works

00:03:50,670 --> 00:03:55,769
hopefully and that writes new pieces of

00:03:54,269 --> 00:03:59,190
code for you

00:03:55,769 --> 00:04:03,260
that throws information over the fence

00:03:59,190 --> 00:04:05,519
from being data to being code now this

00:04:03,260 --> 00:04:08,849
architecture poses a problem for a

00:04:05,519 --> 00:04:10,859
language like Python that initially one

00:04:08,849 --> 00:04:13,500
person was writing by themselves

00:04:10,859 --> 00:04:16,709
targeting processors with machine code

00:04:13,500 --> 00:04:18,479
is a complex undertaking it's slow it's

00:04:16,709 --> 00:04:21,720
difficult you need a lot of specialized

00:04:18,479 --> 00:04:24,570
knowledge and Python just wants to run

00:04:21,720 --> 00:04:26,669
on every single processor without having

00:04:24,570 --> 00:04:29,550
a needing an intimate knowledge of each

00:04:26,669 --> 00:04:33,229
of them and so without having to know

00:04:29,550 --> 00:04:35,550
everything about every single processor

00:04:33,229 --> 00:04:38,430
how can we solve this problem

00:04:35,550 --> 00:04:41,070
how did Ito solve this problem what

00:04:38,430 --> 00:04:44,610
turns out there's this guy named David

00:04:41,070 --> 00:04:48,120
wheeler he once said that all problems

00:04:44,610 --> 00:04:51,150
in computer science can be solved by

00:04:48,120 --> 00:04:53,610
another level of indirection and so like

00:04:51,150 --> 00:04:55,410
many languages before and since the c

00:04:53,610 --> 00:04:58,199
python interpreter that you download

00:04:55,410 --> 00:05:01,110
from the website uses bytecode Python

00:04:58,199 --> 00:05:01,740
compiles in by a to a pretend machine

00:05:01,110 --> 00:05:04,770
language

00:05:01,740 --> 00:05:06,660
it's byte code that it runs inside of a

00:05:04,770 --> 00:05:11,070
little pretend processor that it

00:05:06,660 --> 00:05:14,010
implements so see Python does not by my

00:05:11,070 --> 00:05:16,740
earlier definition do actual compiling

00:05:14,010 --> 00:05:19,470
it turns some data into some other data

00:05:16,740 --> 00:05:21,090
but it never actually throws it over the

00:05:19,470 --> 00:05:24,300
fence to being something that the

00:05:21,090 --> 00:05:27,330
processor can be exposed to raw and know

00:05:24,300 --> 00:05:31,770
what to do with it your py file is read

00:05:27,330 --> 00:05:35,610
in as text C Python parses compiles it

00:05:31,770 --> 00:05:37,409
into bytecode which is another data

00:05:35,610 --> 00:05:39,750
structure another piece of information

00:05:37,409 --> 00:05:42,600
over there on the data side

00:05:39,750 --> 00:05:48,300
the house it also saves it out in a dot

00:05:42,600 --> 00:05:51,170
pyc file if in your dot profile you set

00:05:48,300 --> 00:05:54,780
Python don't write byte code equals one

00:05:51,170 --> 00:05:56,520
it won't write the py C file I share

00:05:54,780 --> 00:05:59,370
that with you just in case you've ever

00:05:56,520 --> 00:06:03,780
had a problem because a py C file was

00:05:59,370 --> 00:06:05,820
sitting around so the it compiles the

00:06:03,780 --> 00:06:07,680
text of your program to a code object

00:06:05,820 --> 00:06:11,220
which it optionally squirrels away in a

00:06:07,680 --> 00:06:14,220
py C file when it's time for your code

00:06:11,220 --> 00:06:17,130
to run when you call your function C

00:06:14,220 --> 00:06:18,780
Python reads that data structure to

00:06:17,130 --> 00:06:21,000
understand what your function is

00:06:18,780 --> 00:06:23,669
supposed to accomplish but at no point

00:06:21,000 --> 00:06:25,830
does your Python script ever leave the

00:06:23,669 --> 00:06:28,530
data structure side of the house to

00:06:25,830 --> 00:06:31,640
actually become machine code here's a

00:06:28,530 --> 00:06:34,710
simple little sum of squares routine

00:06:31,640 --> 00:06:38,070
bytecode is very much like an old RP n

00:06:34,710 --> 00:06:42,419
HP calculator also like the old computer

00:06:38,070 --> 00:06:45,440
language forth both use which is the

00:06:42,419 --> 00:06:48,479
basis of both a postscript in PDF and

00:06:45,440 --> 00:06:50,490
that little sum of squares comes out

00:06:48,479 --> 00:06:53,610
like this if you import the disassembly

00:06:50,490 --> 00:06:57,360
module and ask Python to disassemble its

00:06:53,610 --> 00:06:59,280
bytecode for you see Larry Hastings talk

00:06:57,360 --> 00:07:01,260
last year if you want all of the details

00:06:59,280 --> 00:07:04,560
of that little stack based language and

00:07:01,260 --> 00:07:08,160
see what's possible what Python does

00:07:04,560 --> 00:07:10,350
this is it's a C code is it has what we

00:07:08,160 --> 00:07:14,460
would call a while true loop in Python

00:07:10,350 --> 00:07:17,100
you say 4 semicolon semicolon in C it's

00:07:14,460 --> 00:07:19,350
a infinite loop that just reads new op

00:07:17,100 --> 00:07:21,930
codes and then as a switch statement a

00:07:19,350 --> 00:07:26,070
big if-else that when it figures out

00:07:21,930 --> 00:07:28,410
which opcode the new one matches runs in

00:07:26,070 --> 00:07:30,600
the case of a multiply that we just saw

00:07:28,410 --> 00:07:33,360
it runs something called PI number

00:07:30,600 --> 00:07:35,040
multiplied pi number multiply does not

00:07:33,360 --> 00:07:38,010
actually know how to multiply anything

00:07:35,040 --> 00:07:41,160
it goes and asks the type of initially

00:07:38,010 --> 00:07:45,270
the left argument do you know how do you

00:07:41,160 --> 00:07:47,280
understand this thing multiply and if

00:07:45,270 --> 00:07:50,310
it's a float as it was in my example

00:07:47,280 --> 00:07:52,500
then the float type says why yes I do

00:07:50,310 --> 00:07:53,400
have an implementation of dunder mul

00:07:52,500 --> 00:07:56,250
sitting in my

00:07:53,400 --> 00:07:58,050
type structure it looks like this and

00:07:56,250 --> 00:08:01,669
I'll bet you've forgotten by this point

00:07:58,050 --> 00:08:01,669
what we're trying to actually accomplish

00:08:01,729 --> 00:08:09,600
but look we actually multiply two

00:08:06,030 --> 00:08:13,590
numbers together thanks to all of that

00:08:09,600 --> 00:08:14,970
indirection so let's go back through

00:08:13,590 --> 00:08:17,910
that again you know just because it was

00:08:14,970 --> 00:08:19,530
so much fun this time thinking of code

00:08:17,910 --> 00:08:24,180
and data and I fit it into a single

00:08:19,530 --> 00:08:26,669
slide that infinite loop has to look at

00:08:24,180 --> 00:08:30,360
the data stored in memory in order to

00:08:26,669 --> 00:08:32,580
pull the next byte code out that helps

00:08:30,360 --> 00:08:34,500
it make a decision about what operation

00:08:32,580 --> 00:08:35,849
needs to be done next but it actually

00:08:34,500 --> 00:08:38,370
doesn't know what something like

00:08:35,849 --> 00:08:40,229
multiplied means integers and floats and

00:08:38,370 --> 00:08:43,080
complex numbers each implement that

00:08:40,229 --> 00:08:46,830
themselves so it has to do a second

00:08:43,080 --> 00:08:49,830
lookup in memory to ask the type do you

00:08:46,830 --> 00:08:53,580
have a multiply and add a divide

00:08:49,830 --> 00:08:57,540
operation all of which brings up a

00:08:53,580 --> 00:09:00,450
question python is slower than c c

00:08:57,540 --> 00:09:03,839
python at least is is python slow

00:09:00,450 --> 00:09:07,620
because it's interpreted or is python

00:09:03,839 --> 00:09:10,080
slow because it is dynamic in terms of

00:09:07,620 --> 00:09:13,200
our diagram is it the fact that pi code

00:09:10,080 --> 00:09:15,690
a python is a loop running over bytecode

00:09:13,200 --> 00:09:17,040
that slows us down the most or is it the

00:09:15,690 --> 00:09:19,110
fact that python doesn't know how to

00:09:17,040 --> 00:09:22,920
multiply that's really standing in the

00:09:19,110 --> 00:09:25,170
way of ultimate efficiency well what if

00:09:22,920 --> 00:09:27,690
we skip the interpretation step produced

00:09:25,170 --> 00:09:31,140
no bytecode and simply called multiply

00:09:27,690 --> 00:09:33,540
multiply and add on our own I tried that

00:09:31,140 --> 00:09:35,970
it turns out get about at best about a

00:09:33,540 --> 00:09:38,580
40 percent speed-up which might sound

00:09:35,970 --> 00:09:41,339
impressive it means that Site C Python

00:09:38,580 --> 00:09:45,350
occurs at worst about maybe 30 percent

00:09:41,339 --> 00:09:48,420
overhead from for a fact that it's a

00:09:45,350 --> 00:09:51,750
deferring to this list of byte codes to

00:09:48,420 --> 00:09:54,540
know what your function does but if we

00:09:51,750 --> 00:09:58,320
then take it all the way to the bare

00:09:54,540 --> 00:09:59,940
metal and skip allocating integer us or

00:09:58,320 --> 00:10:02,339
floating-point objects that have

00:09:59,940 --> 00:10:05,279
pointers to their types so that we know

00:10:02,339 --> 00:10:06,570
what multiply means and if we just do

00:10:05,279 --> 00:10:10,110
the multiplies

00:10:06,570 --> 00:10:15,270
ads if in other words we take the second

00:10:10,110 --> 00:10:18,390
dereference there at the bottom away 574

00:10:15,270 --> 00:10:20,940
percent speed up on my laptop earlier

00:10:18,390 --> 00:10:24,030
this week or last week that means

00:10:20,940 --> 00:10:25,890
cpython can spend after the dereference

00:10:24,030 --> 00:10:28,650
effort of reading the bytecode is done

00:10:25,890 --> 00:10:31,800
an additional 85 percent of its time

00:10:28,650 --> 00:10:33,390
simply dispatching simply figuring out

00:10:31,800 --> 00:10:37,140
for the type it's looking at what

00:10:33,390 --> 00:10:39,180
multiplication means the moral is that

00:10:37,140 --> 00:10:42,270
if you really want python to be fast

00:10:39,180 --> 00:10:46,550
you've got to fix dynamic fixing

00:10:42,270 --> 00:10:49,410
interpreted is just not that big a win

00:10:46,550 --> 00:10:52,490
how can you fix dynamic there are ways

00:10:49,410 --> 00:10:55,860
that you can do it directly in c python

00:10:52,490 --> 00:10:58,410
some of these approaches are explicit

00:10:55,860 --> 00:11:01,370
when you you ask for something to be

00:10:58,410 --> 00:11:04,380
faster and some of them are magic

00:11:01,370 --> 00:11:06,930
eyesight pi pi as the great example

00:11:04,380 --> 00:11:09,840
where you don't get to like tell it

00:11:06,930 --> 00:11:12,630
which parts to accelerate it just does

00:11:09,840 --> 00:11:15,000
it when it wants to and so your code is

00:11:12,630 --> 00:11:18,060
often much faster

00:11:15,000 --> 00:11:20,340
numbah looks like this you ask it to

00:11:18,060 --> 00:11:22,470
just in time compile a function that

00:11:20,340 --> 00:11:24,330
you've defined and you tell it what you

00:11:22,470 --> 00:11:26,880
expect the types of the arguments can be

00:11:24,330 --> 00:11:29,730
because only by promising it floats in

00:11:26,880 --> 00:11:31,800
this case do i exempt it from having to

00:11:29,730 --> 00:11:34,410
go look up information about the type

00:11:31,800 --> 00:11:36,420
objects see also if you're playing with

00:11:34,410 --> 00:11:38,400
little microcontrollers and if playing

00:11:36,420 --> 00:11:40,590
with a micro Python project it's not a

00:11:38,400 --> 00:11:42,960
full implementation of Python semantics

00:11:40,590 --> 00:11:47,160
but it has the same idea encased in a

00:11:42,960 --> 00:11:48,780
pair of decorators if you don't want to

00:11:47,160 --> 00:11:51,300
have to decorate the functions that you

00:11:48,780 --> 00:11:52,290
want fast and instead you want magic to

00:11:51,300 --> 00:11:54,150
happen

00:11:52,290 --> 00:11:55,710
there were several old projects of

00:11:54,150 --> 00:11:58,080
varying degrees of success

00:11:55,710 --> 00:12:00,660
the current raining solution very very

00:11:58,080 --> 00:12:03,450
powerful in this area is pi pi and just

00:12:00,660 --> 00:12:06,570
last week Dropbox announced that they

00:12:03,450 --> 00:12:08,610
want their own PI pi and so piston is

00:12:06,570 --> 00:12:12,780
now a going concern and you can find it

00:12:08,610 --> 00:12:15,000
on the internet so given the wonders of

00:12:12,780 --> 00:12:16,890
this ecosystem we can compile things

00:12:15,000 --> 00:12:19,040
when we need to and run fast otherwise

00:12:16,890 --> 00:12:23,270
we run interpreted

00:12:19,040 --> 00:12:26,090
would you need an exe file a big reason

00:12:23,270 --> 00:12:28,340
is distribution especially if you're

00:12:26,090 --> 00:12:30,260
distributing to customer computers this

00:12:28,340 --> 00:12:33,680
is what it looks like natively if you

00:12:30,260 --> 00:12:36,320
just want a Python application you have

00:12:33,680 --> 00:12:40,160
to have the interpreter of the Python

00:12:36,320 --> 00:12:43,220
files the dll's or shared objects and

00:12:40,160 --> 00:12:45,230
then some start script to run when they

00:12:43,220 --> 00:12:47,060
double click the icon that will start

00:12:45,230 --> 00:12:51,500
Python pointed correctly at the

00:12:47,060 --> 00:12:54,650
application Python though the can also

00:12:51,500 --> 00:12:57,110
import PI and pyc files automatically

00:12:54,650 --> 00:13:00,230
from a zip archive if one happens to be

00:12:57,110 --> 00:13:02,450
on the Python path and will execute main

00:13:00,230 --> 00:13:04,280
dot pi if it's given a zip file to run

00:13:02,450 --> 00:13:08,840
on the command line so we can eliminate

00:13:04,280 --> 00:13:12,260
all of the py files from that example by

00:13:08,840 --> 00:13:15,740
zipping them up into source zip naming

00:13:12,260 --> 00:13:18,530
your little startup routine dunder main

00:13:15,740 --> 00:13:21,530
PI and then your start dot bat just

00:13:18,530 --> 00:13:23,630
points python at that now there are

00:13:21,530 --> 00:13:26,720
other tricks I have seen I don't

00:13:23,630 --> 00:13:29,210
recommend them but on UNIX you can roll

00:13:26,720 --> 00:13:34,550
the source zip together with a startup

00:13:29,210 --> 00:13:35,240
script by shabang the zip file can you

00:13:34,550 --> 00:13:37,940
do that

00:13:35,240 --> 00:13:41,090
can you combine text and binary in the

00:13:37,940 --> 00:13:44,690
same file thanks to people like von

00:13:41,090 --> 00:13:48,220
Neumann you can you can because it's

00:13:44,690 --> 00:13:50,630
just bytes and so here you get to skip

00:13:48,220 --> 00:13:53,840
having your startup file separate from

00:13:50,630 --> 00:13:56,630
your source and everywhere even on

00:13:53,840 --> 00:13:59,180
Windows you can instead put source dot

00:13:56,630 --> 00:14:03,080
zip kind of hide it away by appending

00:13:59,180 --> 00:14:07,340
appending it to the Python dot exe file

00:14:03,080 --> 00:14:09,350
because by design zip files have their

00:14:07,340 --> 00:14:11,390
signature and info at the end of the

00:14:09,350 --> 00:14:13,190
file thus making them orthogonal to

00:14:11,390 --> 00:14:16,160
basically all other file formats that

00:14:13,190 --> 00:14:18,260
count from the front the Windows or UNIX

00:14:16,160 --> 00:14:20,300
won't even notice that there's a zip

00:14:18,260 --> 00:14:22,340
file hanging off the end because it

00:14:20,300 --> 00:14:24,770
determines it's a binary executable by

00:14:22,340 --> 00:14:26,360
looking at the first few bytes and so

00:14:24,770 --> 00:14:29,420
that eliminates another few files

00:14:26,360 --> 00:14:31,860
another trick is that you can throw into

00:14:29,420 --> 00:14:34,380
the mix a module that pipe

00:14:31,860 --> 00:14:36,990
on auto imports during startup why have

00:14:34,380 --> 00:14:39,810
a startup script just start the Python

00:14:36,990 --> 00:14:43,470
interpreter next to a site customize dot

00:14:39,810 --> 00:14:45,269
PI that subverts pythons desire to start

00:14:43,470 --> 00:14:46,980
up and look at its command line by

00:14:45,269 --> 00:14:49,079
having it just load and start your

00:14:46,980 --> 00:14:52,769
application instead I've seen this done

00:14:49,079 --> 00:14:58,170
I might even have done it before I won't

00:14:52,769 --> 00:15:01,200
say but having looked several tricks for

00:14:58,170 --> 00:15:03,209
combining code and executable if you're

00:15:01,200 --> 00:15:05,940
going to go to all this trouble why not

00:15:03,209 --> 00:15:08,700
just compile a new copy of the python

00:15:05,940 --> 00:15:10,829
interpreter that will auto start your

00:15:08,700 --> 00:15:12,870
app as a built-in feature and there's a

00:15:10,829 --> 00:15:16,350
whole stack of projects over the years

00:15:12,870 --> 00:15:18,420
that give you this tied up in a box

00:15:16,350 --> 00:15:21,029
most recently PI installer but I

00:15:18,420 --> 00:15:22,380
recently saw updates to CX freeze it

00:15:21,029 --> 00:15:25,170
still looks to be under development

00:15:22,380 --> 00:15:27,600
these rig a special Python interpreter

00:15:25,170 --> 00:15:29,220
that just wants to auto execute an app

00:15:27,600 --> 00:15:32,820
without being given any command-line

00:15:29,220 --> 00:15:35,130
arguments they recursively with varying

00:15:32,820 --> 00:15:37,320
degrees of success try to find all of

00:15:35,130 --> 00:15:40,140
your dependencies and get them loaded up

00:15:37,320 --> 00:15:42,420
as well and can even do a build step to

00:15:40,140 --> 00:15:45,930
put as much as can be fit together into

00:15:42,420 --> 00:15:47,480
a single exe file what's left once one

00:15:45,930 --> 00:15:51,240
of those tools has gone to work

00:15:47,480 --> 00:15:53,610
typically a standalone binary that

00:15:51,240 --> 00:15:56,490
really has your pyc files zipped up

00:15:53,610 --> 00:15:59,940
inside and then your binary dependencies

00:15:56,490 --> 00:16:01,470
your shared objects and the DLLs some

00:15:59,940 --> 00:16:03,390
people are annoyed that these have to be

00:16:01,470 --> 00:16:05,910
hanging out on the file system in your

00:16:03,390 --> 00:16:10,019
install directory some people just leave

00:16:05,910 --> 00:16:12,570
them there next to your python exe some

00:16:10,019 --> 00:16:14,579
people bundle them in and have the

00:16:12,570 --> 00:16:16,860
executable when it runs secretly

00:16:14,579 --> 00:16:18,329
unpacked them to a temp directory load

00:16:16,860 --> 00:16:22,589
them from there and then remove them

00:16:18,329 --> 00:16:28,370
before the user notices or if you are PI

00:16:22,589 --> 00:16:28,370
to eeks you can use this one weird trick

00:16:28,550 --> 00:16:35,790
the pie TX person author went and

00:16:32,970 --> 00:16:39,540
learned how Python loads dll's from

00:16:35,790 --> 00:16:42,750
files and emulated windows standard

00:16:39,540 --> 00:16:46,470
portable executable loader against the

00:16:42,750 --> 00:16:48,600
DLLs that it runs loads into ram so it

00:16:46,470 --> 00:16:51,030
doesn't even touch the file system no

00:16:48,600 --> 00:16:52,920
one's ever done this for Unix

00:16:51,030 --> 00:16:54,390
be-because needing everything in a

00:16:52,920 --> 00:16:57,150
single file is kind of against the

00:16:54,390 --> 00:17:01,230
culture there but it's been done before

00:16:57,150 --> 00:17:04,440
and when it works it doesn't always but

00:17:01,230 --> 00:17:07,290
when it works only PI to eeks provides a

00:17:04,440 --> 00:17:10,200
truly general single file bundle on the

00:17:07,290 --> 00:17:14,760
Windows platform thanks to this one

00:17:10,200 --> 00:17:16,470
weird trick the one or two road bumps

00:17:14,760 --> 00:17:19,860
you will run across with these products

00:17:16,470 --> 00:17:22,170
are inline files when text templates or

00:17:19,860 --> 00:17:24,690
images are sitting inside the directory

00:17:22,170 --> 00:17:26,910
tree of a package if a package uses a

00:17:24,690 --> 00:17:28,950
plain old open to try to get to the file

00:17:26,910 --> 00:17:29,970
sitting in with its source code you're

00:17:28,950 --> 00:17:32,310
either going to have to monkey patch

00:17:29,970 --> 00:17:35,040
open so that it knows to look in your

00:17:32,310 --> 00:17:37,770
zip file or just keep playing file

00:17:35,040 --> 00:17:39,510
sitting outside of the exe which might

00:17:37,770 --> 00:17:41,220
expose a little about your app that

00:17:39,510 --> 00:17:45,210
you're uncomfortable with but you can do

00:17:41,220 --> 00:17:46,800
it well behaved modules when you run

00:17:45,210 --> 00:17:49,710
across them this doesn't seem to be well

00:17:46,800 --> 00:17:51,840
known will always instead of opening a

00:17:49,710 --> 00:17:55,020
file sitting next to the dot py file

00:17:51,840 --> 00:17:56,790
will use get data and let Python which

00:17:55,020 --> 00:17:59,250
knows whether you're running from inside

00:17:56,790 --> 00:18:00,840
of a zip file or not make the decision

00:17:59,250 --> 00:18:04,500
and make the call about whether a date

00:18:00,840 --> 00:18:06,570
where that data comes from so that's the

00:18:04,500 --> 00:18:09,780
ecosystem as it existed a year or two

00:18:06,570 --> 00:18:12,330
ago we have great interpreters we have

00:18:09,780 --> 00:18:14,760
just-in-time compilation and we even

00:18:12,330 --> 00:18:16,770
have this like one weird trick for

00:18:14,760 --> 00:18:22,170
bundling everything up as a single piece

00:18:16,770 --> 00:18:25,230
of code who would need anything more you

00:18:22,170 --> 00:18:29,430
might have heard of this guy before name

00:18:25,230 --> 00:18:33,570
of Gandalf in about the year thirty

00:18:29,430 --> 00:18:36,360
eighteen in the Third Age he visited

00:18:33,570 --> 00:18:38,100
Frodo Baggins and in telling him a story

00:18:36,360 --> 00:18:39,530
about a ring that Frodo had come into

00:18:38,100 --> 00:18:46,100
possession of he said

00:18:39,530 --> 00:18:49,300
I myself dared to pass the doors of the

00:18:46,100 --> 00:18:53,960
necromancer indole Ghul door and

00:18:49,300 --> 00:18:56,990
secretly explored his ways well you

00:18:53,960 --> 00:19:08,530
might not know it about me but I once

00:18:56,990 --> 00:19:13,250
worked in the enterprise the enterprise

00:19:08,530 --> 00:19:16,540
sometimes demands exe s specifically and

00:19:13,250 --> 00:19:19,550
is very offended if any of your code

00:19:16,540 --> 00:19:22,490
persists as data rather than becoming

00:19:19,550 --> 00:19:24,860
real machine code core language

00:19:22,490 --> 00:19:26,900
developers on the other hand because

00:19:24,860 --> 00:19:30,740
Python doesn't come out of that world

00:19:26,900 --> 00:19:35,810
Python comes out of the UNIX Academy

00:19:30,740 --> 00:19:38,300
text file the environment core language

00:19:35,810 --> 00:19:40,640
developers see no point in merely

00:19:38,300 --> 00:19:43,400
eliminating interpretation they are

00:19:40,640 --> 00:19:45,440
targeting dispatch what's the point of

00:19:43,400 --> 00:19:47,390
eliminating a few bytecode lookups if

00:19:45,440 --> 00:19:48,020
you're still asking floats how to

00:19:47,390 --> 00:19:52,490
multiply

00:19:48,020 --> 00:19:55,430
in fact core language developers might

00:19:52,490 --> 00:19:58,220
publicly express dismay that you're even

00:19:55,430 --> 00:20:01,700
trying to merely eliminate that first

00:19:58,220 --> 00:20:04,010
step of interpretation that in other

00:20:01,700 --> 00:20:07,190
words getting rid of a bytecode and

00:20:04,010 --> 00:20:10,370
simply having pre-written out the sea

00:20:07,190 --> 00:20:13,070
calls that need to be made but in the

00:20:10,370 --> 00:20:15,920
enterprise that does not necessarily

00:20:13,070 --> 00:20:17,960
have zero value because of a very

00:20:15,920 --> 00:20:20,900
conservative culture a lookalike

00:20:17,960 --> 00:20:22,910
phenomenon of wanting your of not

00:20:20,900 --> 00:20:25,190
wanting to admit Python to the club

00:20:22,910 --> 00:20:28,820
unless it can produce the same kind of

00:20:25,190 --> 00:20:31,340
artifacts as other tools and sometimes a

00:20:28,820 --> 00:20:35,200
bit of a culture of secrecy around their

00:20:31,340 --> 00:20:38,300
source code and a fear that pyc files

00:20:35,200 --> 00:20:40,700
dangling in a zip archive off the end of

00:20:38,300 --> 00:20:43,309
an executable might be the target of D

00:20:40,700 --> 00:20:45,909
compilation which is its own little

00:20:43,309 --> 00:20:48,830
shadow world of the Python community a

00:20:45,909 --> 00:20:51,230
series of projects that start up that

00:20:48,830 --> 00:20:53,690
work with one version of Python ever and

00:20:51,230 --> 00:20:55,970
then disappear often into commercial

00:20:53,690 --> 00:20:58,759
projects the very first one that was

00:20:55,970 --> 00:21:00,980
open-source then disappeared behind a

00:20:58,759 --> 00:21:05,929
closed source website where you had to

00:21:00,980 --> 00:21:10,129
pay or run it has anyone here ever paid

00:21:05,929 --> 00:21:16,340
to decompile a pyc file I got a bit

00:21:10,129 --> 00:21:18,529
curious who does that so and I was

00:21:16,340 --> 00:21:21,139
curious I won't ask you specifically but

00:21:18,529 --> 00:21:24,619
I went online I looked up the reviews of

00:21:21,139 --> 00:21:26,749
this product thinking because if ok if I

00:21:24,619 --> 00:21:29,600
was doing espionage if I want to know

00:21:26,749 --> 00:21:31,639
how Dropbox works deep inside and I

00:21:29,600 --> 00:21:33,320
think that reading their source code is

00:21:31,639 --> 00:21:35,690
a good way to learn their secrets for my

00:21:33,320 --> 00:21:38,029
own project I wouldn't go pasting their

00:21:35,690 --> 00:21:41,210
pyc files up on someone else's

00:21:38,029 --> 00:21:46,090
commercial website who uses this so I

00:21:41,210 --> 00:21:46,090
went and I let speak into some reviews

00:22:15,289 --> 00:22:21,750
do I have to take back what I said about

00:22:17,820 --> 00:22:26,659
pyc files a few minutes ago maybe all of

00:22:21,750 --> 00:22:30,720
those pyc files are useful after all

00:22:26,659 --> 00:22:34,890
okay public service announcement is now

00:22:30,720 --> 00:22:38,520
necessary do not set Python don't write

00:22:34,890 --> 00:22:50,070
bytecode equal one if they are the only

00:22:38,520 --> 00:22:51,750
backup you have of your code and I'm

00:22:50,070 --> 00:22:53,490
just kidding I'm not going to let py see

00:22:51,750 --> 00:22:55,770
files off the hook because they caused

00:22:53,490 --> 00:22:57,360
the problem and are why the people were

00:22:55,770 --> 00:23:01,320
running remove all the time in their

00:22:57,360 --> 00:23:03,149
Python project the real PSA here is use

00:23:01,320 --> 00:23:05,070
some kind of version control even if

00:23:03,149 --> 00:23:06,929
it's a throw away repo that you'll

00:23:05,070 --> 00:23:09,149
delete at the end of the day have

00:23:06,929 --> 00:23:11,100
something sitting there or your editor

00:23:09,149 --> 00:23:13,500
open that you can go hit save in again

00:23:11,100 --> 00:23:16,620
never have just one copy of your source

00:23:13,500 --> 00:23:22,740
code use Dropbox it's written in Python

00:23:16,620 --> 00:23:24,990
so what if because of your environment

00:23:22,740 --> 00:23:28,140
or your situation you just really really

00:23:24,990 --> 00:23:31,830
need an exe not because you're shy about

00:23:28,140 --> 00:23:34,110
dispatched to the multiply operation not

00:23:31,830 --> 00:23:36,270
because you need incredible speed but

00:23:34,110 --> 00:23:40,320
because your environment demands the

00:23:36,270 --> 00:23:42,870
delivery of compilable code where where

00:23:40,320 --> 00:23:45,029
the artifact does not bytecode over on

00:23:42,870 --> 00:23:48,870
the heap but real executable machine

00:23:45,029 --> 00:23:51,720
code I am here to announce that it is

00:23:48,870 --> 00:23:55,500
now possible you can now accomplishment

00:23:51,720 --> 00:23:59,640
accomplish it the day of the exe is upon

00:23:55,500 --> 00:24:03,870
us and there are two competing solutions

00:23:59,640 --> 00:24:06,659
let me outline them quickly Nootka by KY

00:24:03,870 --> 00:24:09,000
hidin he's given a series of I believe

00:24:06,659 --> 00:24:11,669
two talks at subsequent Euro pythons

00:24:09,000 --> 00:24:13,679
about it I tried a number of different

00:24:11,669 --> 00:24:18,870
programs about it and for the most part

00:24:13,679 --> 00:24:22,080
it was compiling 2.6 2.7 3.2 and 3.3 and

00:24:18,870 --> 00:24:25,280
like PI 2 weeks it comes with a built-in

00:24:22,080 --> 00:24:28,490
bundler that after it's done compiling

00:24:25,280 --> 00:24:30,500
your Python code too real C code will

00:24:28,490 --> 00:24:33,470
bundle it all together into as much of a

00:24:30,500 --> 00:24:38,240
single exe file as it can manage without

00:24:33,470 --> 00:24:41,210
using the shady one weird trick I tried

00:24:38,240 --> 00:24:43,760
print hello world and it worked I got an

00:24:41,210 --> 00:24:48,080
executable without any evident byte code

00:24:43,760 --> 00:24:50,120
that I could find inside of it so I then

00:24:48,080 --> 00:24:53,210
thought all right that one time that I

00:24:50,120 --> 00:24:55,120
had to make that exe for a client and it

00:24:53,210 --> 00:24:57,980
didn't work that was because of those

00:24:55,120 --> 00:24:59,540
cryptography libraries so I first tried

00:24:57,980 --> 00:25:04,720
the one we did eventually get working

00:24:59,540 --> 00:25:07,970
with PI to exe PI crypto and it worked

00:25:04,720 --> 00:25:10,040
all right I then went to the one that we

00:25:07,970 --> 00:25:13,730
had had to throw away and rewrite

00:25:10,040 --> 00:25:18,610
because it didn't it could never get it

00:25:13,730 --> 00:25:23,270
to bundle into crypto compiled and

00:25:18,610 --> 00:25:26,210
worked this is amazing this means that

00:25:23,270 --> 00:25:28,580
in a wide variety of situations you can

00:25:26,210 --> 00:25:31,340
now with a little bit of work get your

00:25:28,580 --> 00:25:33,710
project to produce an exe where no

00:25:31,340 --> 00:25:36,860
compilation or bytecode interpretation

00:25:33,710 --> 00:25:39,560
happens at runtime you can bundle a

00:25:36,860 --> 00:25:41,630
dependency or just put it elsewhere on

00:25:39,560 --> 00:25:43,670
the Python path if it's your code you're

00:25:41,630 --> 00:25:46,160
trying to protect and you're not too shy

00:25:43,670 --> 00:25:48,110
about the customer seeing that m2 crypto

00:25:46,160 --> 00:25:51,770
is sitting next to you on the disk you

00:25:48,110 --> 00:25:56,120
have either option but Nootka also has a

00:25:51,770 --> 00:25:57,820
competitor psyphon which I had been led

00:25:56,120 --> 00:26:01,400
to believe was a domain-specific

00:25:57,820 --> 00:26:04,250
language to make it easy to let Python

00:26:01,400 --> 00:26:06,170
talk to see I assumed it was some little

00:26:04,250 --> 00:26:07,880
subset of the Python language that

00:26:06,170 --> 00:26:09,500
barely got you up and running so that

00:26:07,880 --> 00:26:12,890
you could then make calls in to C

00:26:09,500 --> 00:26:15,170
without having to use so that the

00:26:12,890 --> 00:26:18,350
translation between the two environments

00:26:15,170 --> 00:26:21,230
happened transparently and it was last

00:26:18,350 --> 00:26:24,020
year talking to one of those

00:26:21,230 --> 00:26:26,960
Python science people that they're that

00:26:24,020 --> 00:26:31,330
they're like yeah it's like Python plus

00:26:26,960 --> 00:26:33,550
you can make C calls and I was like wait

00:26:31,330 --> 00:26:36,580
you mean it's

00:26:33,550 --> 00:26:41,650
it's all of Python and they're like yeah

00:26:36,580 --> 00:26:42,790
but you can make sea calls and I was

00:26:41,650 --> 00:26:44,980
like wait a minute you guys have

00:26:42,790 --> 00:26:49,780
secretly come up with a way to compile

00:26:44,980 --> 00:26:53,920
Python generators functions classes to C

00:26:49,780 --> 00:26:59,080
code yeah to C code and you haven't told

00:26:53,920 --> 00:27:01,000
anyone like like people ask this on

00:26:59,080 --> 00:27:03,490
Stack Overflow every day and you've been

00:27:01,000 --> 00:27:06,760
keeping it a secret and they're like

00:27:03,490 --> 00:27:15,370
yeah but with with psyphon you can make

00:27:06,760 --> 00:27:19,030
calls to see max because then we'll have

00:27:15,370 --> 00:27:22,030
to free this space and so Nika and

00:27:19,030 --> 00:27:25,150
scythe on and Nootka and scythe on are

00:27:22,030 --> 00:27:27,429
the two solutions and with them you can

00:27:25,150 --> 00:27:31,260
bundle your project together as a single

00:27:27,429 --> 00:27:31,260
exe thank you very much

00:27:36,920 --> 00:27:45,830
I don't see anyone by the mics for one

00:27:43,010 --> 00:27:47,600
question in which case I will invite you

00:27:45,830 --> 00:27:48,770
to talk to the speaker in the open

00:27:47,600 --> 00:27:51,410
spaces or anywhere

00:27:48,770 --> 00:27:53,030
thank you again see me at the sprints if

00:27:51,410 --> 00:27:55,870
you want to play with some examples I've

00:27:53,030 --> 00:27:55,870

YouTube URL: https://www.youtube.com/watch?v=wsczq6j3_bA


