Title: Erik Rose: Designing Poetic APIs - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Erik Rose

The language you speak determines the thoughts you can think. Thus, API designers (and that includes you, if you've ever coined a function) have a great duty, as language inventors, to expand the mental canvases of those who come after. We'll concretize that into 7 hallmarks of good APIs, pulling examples (and bloopers) from popular Python libraries.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:00,000 --> 00:00:02,060
you

00:00:06,930 --> 00:00:13,080
good afternoon our next talk is

00:00:09,420 --> 00:00:15,119
designing poetic api's by Eric rose Eric

00:00:13,080 --> 00:00:17,190
works at Mozilla and by his own account

00:00:15,119 --> 00:00:27,510
right to way too many Python libraries

00:00:17,190 --> 00:00:28,710
please give a warm welcome wow thanks

00:00:27,510 --> 00:00:31,199
for packing it out in here guys as a

00:00:28,710 --> 00:00:33,030
fantastic well today we're going to take

00:00:31,199 --> 00:00:35,600
a look at psychology and anthropology

00:00:33,030 --> 00:00:37,739
and the history of our own field and

00:00:35,600 --> 00:00:40,649
hopefully figure out how to write more

00:00:37,739 --> 00:00:42,450
beautiful api's so before we get started

00:00:40,649 --> 00:00:45,149
I have a confession to make which is

00:00:42,450 --> 00:00:47,910
that I am NOT a poet unfortunately I

00:00:45,149 --> 00:00:50,340
know but poets and programmers we have a

00:00:47,910 --> 00:00:53,010
lot in common we both deal with very

00:00:50,340 --> 00:00:54,719
precisely formulated language and we

00:00:53,010 --> 00:00:56,130
both make up new terms in fact

00:00:54,719 --> 00:00:58,559
programmers do this all the time

00:00:56,130 --> 00:01:00,510
whenever you name a variable or coin new

00:00:58,559 --> 00:01:02,940
function you're essentially making up a

00:01:00,510 --> 00:01:04,739
new piece of language it's this

00:01:02,940 --> 00:01:07,500
invention of language and the mental

00:01:04,739 --> 00:01:10,590
processes that go on with it then a key

00:01:07,500 --> 00:01:12,049
to writing excellent ap is it's vital

00:01:10,590 --> 00:01:13,880
that we create new language with care

00:01:12,049 --> 00:01:15,869
because the language that you use

00:01:13,880 --> 00:01:18,420
influences the thoughts that you can

00:01:15,869 --> 00:01:20,369
think have you ever had anyone tell you

00:01:18,420 --> 00:01:21,840
you should go learn Lisp and go learn

00:01:20,369 --> 00:01:24,510
Haskell it'll change the way you think

00:01:21,840 --> 00:01:26,479
about programming yeah well there's

00:01:24,510 --> 00:01:30,659
something to that as it turns out

00:01:26,479 --> 00:01:32,990
there's this old psychological theory

00:01:30,659 --> 00:01:36,150
called the sapir-whorf hypothesis and

00:01:32,990 --> 00:01:38,700
how it goes is the language that you

00:01:36,150 --> 00:01:41,820
speak determines in limits the thoughts

00:01:38,700 --> 00:01:43,140
that you can think and assume is shaking

00:01:41,820 --> 00:01:45,210
your head there yes this has fallen out

00:01:43,140 --> 00:01:46,680
of fashion lately but there was some

00:01:45,210 --> 00:01:48,689
evidence or at least anecdotes in its

00:01:46,680 --> 00:01:51,390
favor for a while for example take the

00:01:48,689 --> 00:01:54,030
case of ildefonso a Mayan man who was

00:01:51,390 --> 00:01:55,680
born deaf into a poor family and so they

00:01:54,030 --> 00:01:57,930
didn't have a lot of resources to invest

00:01:55,680 --> 00:02:00,390
in things like sign language training or

00:01:57,930 --> 00:02:02,640
lip reading and so he was actually

00:02:00,390 --> 00:02:04,439
brought up without language he didn't

00:02:02,640 --> 00:02:07,259
acquire language until he was 27 years

00:02:04,439 --> 00:02:09,750
old and during this early period of his

00:02:07,259 --> 00:02:13,739
life he couldn't do math with quantities

00:02:09,750 --> 00:02:15,870
beyond 10 for obvious reasons but now

00:02:13,739 --> 00:02:18,599
that he has the language for and he's

00:02:15,870 --> 00:02:20,280
received training he can do just fine

00:02:18,599 --> 00:02:23,190
you can calculate with the best of him

00:02:20,280 --> 00:02:25,410
because he has the language for it now

00:02:23,190 --> 00:02:26,580
so this strong sapir-whorf hypothesis

00:02:25,410 --> 00:02:29,100
which I'm still getting bitter looks

00:02:26,580 --> 00:02:30,630
from sumana about has been disproved by

00:02:29,100 --> 00:02:31,500
counterexample and you can reconnect to

00:02:30,630 --> 00:02:34,110
do this just as a thought experiment

00:02:31,500 --> 00:02:36,720
here we are in Montreal a bilingual City

00:02:34,110 --> 00:02:38,819
and satisfying translations are possible

00:02:36,720 --> 00:02:40,410
when I came into the airport I wanted to

00:02:38,819 --> 00:02:42,030
grab a sandwich I got in late I went to

00:02:40,410 --> 00:02:44,550
subway the guy was making my sandwich

00:02:42,030 --> 00:02:46,160
spoke French I spoke English we used

00:02:44,550 --> 00:02:48,090
French words and English words and

00:02:46,160 --> 00:02:49,260
regardless of the language we used I

00:02:48,090 --> 00:02:53,459
would have gotten the same sandwich out

00:02:49,260 --> 00:02:56,430
afterwards pitkin Stein writes some some

00:02:53,459 --> 00:02:58,680
pretty down and dirty philosophy now you

00:02:56,430 --> 00:03:01,050
can translate that that very precise

00:02:58,680 --> 00:03:03,120
german into english and the arguments

00:03:01,050 --> 00:03:05,940
still make sense or at least the same

00:03:03,120 --> 00:03:07,500
amount of sense they did before but but

00:03:05,940 --> 00:03:09,780
they're still a flavor to each language

00:03:07,500 --> 00:03:11,730
right who hasn't accused a colleague of

00:03:09,780 --> 00:03:13,290
oh you're writing Java and Python knock

00:03:11,730 --> 00:03:16,230
it off you're writing Python in standard

00:03:13,290 --> 00:03:18,050
X or in standard ml Python naturally

00:03:16,230 --> 00:03:19,920
makes you reach for hash tables

00:03:18,050 --> 00:03:21,480
functional languages make you solve

00:03:19,920 --> 00:03:23,540
things in terms of map and fold

00:03:21,480 --> 00:03:27,560
JavaScript everything's a closure and

00:03:23,540 --> 00:03:29,579
this is the weak form of the sapir-whorf

00:03:27,560 --> 00:03:32,010
hypothesis which I dare you to say at

00:03:29,579 --> 00:03:35,730
five times fast and I think it does hold

00:03:32,010 --> 00:03:37,170
the language that you use influences the

00:03:35,730 --> 00:03:40,560
thoughts do you think now I'm getting

00:03:37,170 --> 00:03:42,780
nods thank you so the bounds of this

00:03:40,560 --> 00:03:45,420
influence have been marked out

00:03:42,780 --> 00:03:47,130
experimentally for example in English we

00:03:45,420 --> 00:03:50,310
don't have a whole lot of good words for

00:03:47,130 --> 00:03:51,570
colors in the red orange range now if

00:03:50,310 --> 00:03:53,190
you show an English speaker a bunch of

00:03:51,570 --> 00:03:56,549
color swatches they can certainly

00:03:53,190 --> 00:03:58,109
distinguish between them visually but if

00:03:56,549 --> 00:03:59,190
you then distract them with a card game

00:03:58,109 --> 00:04:02,100
or something and bring them back later

00:03:59,190 --> 00:04:04,019
they won't be able to remember a swatch

00:04:02,100 --> 00:04:06,390
you ask them to remember if it didn't

00:04:04,019 --> 00:04:07,680
have a handy name in their language so

00:04:06,390 --> 00:04:09,480
it seems that having a symbol for

00:04:07,680 --> 00:04:12,209
something a word for something makes it

00:04:09,480 --> 00:04:14,700
mentally lighter weight when you draw a

00:04:12,209 --> 00:04:18,269
symbol like red over a bunch of details

00:04:14,700 --> 00:04:20,190
like well 632 672 nanometers in

00:04:18,269 --> 00:04:22,500
wavelength it acts like a mental

00:04:20,190 --> 00:04:24,450
abstraction you can kick all the details

00:04:22,500 --> 00:04:25,919
out of your head and say that mental

00:04:24,450 --> 00:04:28,760
space for higher-level pursuits like

00:04:25,919 --> 00:04:31,470
building sentences with the word red

00:04:28,760 --> 00:04:33,750
abstracting out symbols is the root of

00:04:31,470 --> 00:04:36,520
all human language

00:04:33,750 --> 00:04:40,720
but it's also the root of all software

00:04:36,520 --> 00:04:42,340
engineering now the pointer software

00:04:40,720 --> 00:04:43,990
engineering what differentiates it from

00:04:42,340 --> 00:04:46,600
just hacking around with spaghetti code

00:04:43,990 --> 00:04:48,610
is making software intellectually

00:04:46,600 --> 00:04:51,100
intelligible by finding good

00:04:48,610 --> 00:04:54,100
abstractions so let's talk about api's

00:04:51,100 --> 00:04:56,440
in creating an API you make up your own

00:04:54,100 --> 00:04:58,810
symbols and their meanings functions

00:04:56,440 --> 00:05:00,250
variable names data structures and with

00:04:58,810 --> 00:05:02,890
the names and semantics that you choose

00:05:00,250 --> 00:05:05,890
you shape all future thought about that

00:05:02,890 --> 00:05:07,360
system remember ildefonso couldn't get

00:05:05,890 --> 00:05:09,670
above the number 10 until he had the

00:05:07,360 --> 00:05:11,470
words for it when you make a good API

00:05:09,670 --> 00:05:14,200
you give those who come after you

00:05:11,470 --> 00:05:16,660
including your future self those numbers

00:05:14,200 --> 00:05:19,240
after 10 letting people think the

00:05:16,660 --> 00:05:21,520
thoughts that they couldn't before for

00:05:19,240 --> 00:05:27,340
example let's take a look at your lib to

00:05:21,520 --> 00:05:28,990
vs. requests right so URL lib to is

00:05:27,340 --> 00:05:31,180
pretty horrendous labour boasts it's

00:05:28,990 --> 00:05:32,470
hard to do common things part of that is

00:05:31,180 --> 00:05:35,710
because it has a greater scope than just

00:05:32,470 --> 00:05:38,230
HTTP but I'm picking on it requests a

00:05:35,710 --> 00:05:40,090
third-party library has become a rapid

00:05:38,230 --> 00:05:42,600
de facto standard because it introduces

00:05:40,090 --> 00:05:46,900
this brilliant new symbol called the

00:05:42,600 --> 00:05:48,130
HTTP request and I think this is even

00:05:46,900 --> 00:05:49,210
more brilliant because apparently some

00:05:48,130 --> 00:05:50,560
people have already heard of this

00:05:49,210 --> 00:05:53,590
abstraction and had it in their heads

00:05:50,560 --> 00:05:56,050
already so one thing you can do is ask

00:05:53,590 --> 00:05:59,020
yourself what would a naive user imagine

00:05:56,050 --> 00:06:00,820
my API should look like if there are

00:05:59,020 --> 00:06:03,940
already existing symbols out there just

00:06:00,820 --> 00:06:05,770
make them work that's easy one now it's

00:06:03,940 --> 00:06:07,840
silly to try to turn good design into a

00:06:05,770 --> 00:06:10,120
process that you can follow or a formula

00:06:07,840 --> 00:06:12,640
you can apply but I've gone ahead and

00:06:10,120 --> 00:06:15,280
taken a swing at it anyway there's some

00:06:12,640 --> 00:06:16,900
requests code for comparison so today

00:06:15,280 --> 00:06:19,510
I'm going to give you seven rules of

00:06:16,900 --> 00:06:20,950
thumb that you can use as a checklist it

00:06:19,510 --> 00:06:22,840
may not give you a good design for free

00:06:20,950 --> 00:06:25,390
but it will guide you along and it will

00:06:22,840 --> 00:06:28,500
keep you from falling off all the worst

00:06:25,390 --> 00:06:30,970
cliffs so the first principle is

00:06:28,500 --> 00:06:34,240
something not to do don't be an

00:06:30,970 --> 00:06:36,220
architecture astronaut my first step in

00:06:34,240 --> 00:06:39,670
designing a new library is actually to

00:06:36,220 --> 00:06:41,770
not design a new library it's all well

00:06:39,670 --> 00:06:44,200
and good to try to do good design in the

00:06:41,770 --> 00:06:46,840
abstract but design is basically

00:06:44,200 --> 00:06:49,240
imagination and imagination is

00:06:46,840 --> 00:06:50,680
little more than hypothesizing and you

00:06:49,240 --> 00:06:52,419
know from history what happens when you

00:06:50,680 --> 00:06:54,160
hypothesize without continually bringing

00:06:52,419 --> 00:06:56,020
those hypotheses back down to earth and

00:06:54,160 --> 00:06:58,210
testing them against reality you end up

00:06:56,020 --> 00:07:01,330
with alchemy rather than chemistry right

00:06:58,210 --> 00:07:03,340
it can be academically interesting it

00:07:01,330 --> 00:07:05,800
can be visually impressive lots of

00:07:03,340 --> 00:07:07,030
sparks and bright colors but when it

00:07:05,800 --> 00:07:09,490
comes down to it it's just a

00:07:07,030 --> 00:07:11,169
self-consistent system of nonsense not

00:07:09,490 --> 00:07:13,600
of a lot of practical value they didn't

00:07:11,169 --> 00:07:16,000
get any gold out of that lid so to bring

00:07:13,600 --> 00:07:18,010
our efforts back and anchor them in the

00:07:16,000 --> 00:07:21,450
realm of science remember that the best

00:07:18,010 --> 00:07:25,150
libraries are extracted not invented

00:07:21,450 --> 00:07:27,460
what this means is you should have one

00:07:25,150 --> 00:07:30,040
hopefully even two or as many as you can

00:07:27,460 --> 00:07:32,500
can swing applications that already do

00:07:30,040 --> 00:07:34,479
what your library is going to do and

00:07:32,500 --> 00:07:37,060
then you take the bits of them there in

00:07:34,479 --> 00:07:40,000
common and you factor them up into your

00:07:37,060 --> 00:07:42,280
library for example i wrote a plug-in

00:07:40,000 --> 00:07:44,650
called knows progressive plugs into the

00:07:42,280 --> 00:07:46,479
popular test framework knows and its

00:07:44,650 --> 00:07:49,120
purpose in life is to display a progress

00:07:46,479 --> 00:07:52,060
bar and fancy trace backs and just

00:07:49,120 --> 00:07:53,620
generally make output easier to grok now

00:07:52,060 --> 00:07:55,600
it makes use of a lot of terminal escape

00:07:53,620 --> 00:07:57,370
codes for things like colors and bold

00:07:55,600 --> 00:08:00,039
and positioning and the code looks

00:07:57,370 --> 00:08:02,139
something like this there's lots of

00:08:00,039 --> 00:08:04,300
terminal set up kind of intertwined with

00:08:02,139 --> 00:08:07,050
the operative code lots of abbreviations

00:08:04,300 --> 00:08:10,060
for different term info strings and

00:08:07,050 --> 00:08:12,520
there are raw raw term cap names like

00:08:10,060 --> 00:08:13,930
sgr zero not very friendly things an RSC

00:08:12,520 --> 00:08:15,190
the f2 key of looking aside to the

00:08:13,930 --> 00:08:18,280
documentation to figure out what they

00:08:15,190 --> 00:08:20,650
mean every time I'd have to do some

00:08:18,280 --> 00:08:22,240
formatting I would think oil share was a

00:08:20,650 --> 00:08:23,289
decent abstraction around this so I

00:08:22,240 --> 00:08:26,380
would have to look at it all the time

00:08:23,289 --> 00:08:27,789
and this is the magic point when you

00:08:26,380 --> 00:08:30,130
have a real useful program with a

00:08:27,789 --> 00:08:31,690
library struggling to get out that you

00:08:30,130 --> 00:08:34,779
should come down from orbit and start

00:08:31,690 --> 00:08:37,150
thinking about library design in this

00:08:34,779 --> 00:08:38,890
case i ended up extracting the terminal

00:08:37,150 --> 00:08:40,779
handling into a library called blessings

00:08:38,890 --> 00:08:44,350
and i want to use it as the first

00:08:40,779 --> 00:08:45,760
example of our extraction process so the

00:08:44,350 --> 00:08:48,370
first thing to do is dump everything out

00:08:45,760 --> 00:08:50,380
of the workbench what sort of things out

00:08:48,370 --> 00:08:52,300
the library to do well we want to print

00:08:50,380 --> 00:08:53,709
some text it's formatted and we want to

00:08:52,300 --> 00:08:54,640
print some text maybe at a location like

00:08:53,709 --> 00:08:56,950
the bottom of the screen with the

00:08:54,640 --> 00:08:58,680
progress bar is and then snap back to

00:08:56,950 --> 00:09:00,460
what we were doing up by the trace backs

00:08:58,680 --> 00:09:02,200
what tools do we have

00:09:00,460 --> 00:09:04,420
well we've got everything that's native

00:09:02,200 --> 00:09:06,790
to the language we've got functions with

00:09:04,420 --> 00:09:09,970
optional herbs and positional args we've

00:09:06,790 --> 00:09:12,100
got decorators those are fun context

00:09:09,970 --> 00:09:15,460
managers and classes will let you do

00:09:12,100 --> 00:09:17,680
inheritance but we also have common

00:09:15,460 --> 00:09:18,640
patterns that come from the culture and

00:09:17,680 --> 00:09:21,090
from the things that the library

00:09:18,640 --> 00:09:23,020
encourages again week sapir-whorf

00:09:21,090 --> 00:09:27,160
sequences they can for loop around

00:09:23,020 --> 00:09:28,840
iterators and mappings then we shake the

00:09:27,160 --> 00:09:30,780
workbench up and we see if we can find

00:09:28,840 --> 00:09:35,730
some good pairings between these things

00:09:30,780 --> 00:09:38,320
what guides you in this consistency you

00:09:35,730 --> 00:09:40,510
have the entire technical and cultural

00:09:38,320 --> 00:09:42,250
weight of the language as well as the

00:09:40,510 --> 00:09:43,960
accumulated habits of influential

00:09:42,250 --> 00:09:46,330
libraries and the program or community

00:09:43,960 --> 00:09:47,740
behind you when we're designing websites

00:09:46,330 --> 00:09:49,210
we think of it this way people spend

00:09:47,740 --> 00:09:51,940
ninety percent of their time on other

00:09:49,210 --> 00:09:53,260
people's sites so yeah put your logo in

00:09:51,940 --> 00:09:54,820
the upper left to make it linked to your

00:09:53,260 --> 00:09:57,370
homepage put the login link in the upper

00:09:54,820 --> 00:09:59,650
right call your shopping cart shopping

00:09:57,370 --> 00:10:01,720
cart not take out basket make your links

00:09:59,650 --> 00:10:03,250
blue and so on now when you're writing

00:10:01,720 --> 00:10:05,470
an API you can use the same sort of

00:10:03,250 --> 00:10:08,680
thing user spend ninety percent of their

00:10:05,470 --> 00:10:10,240
time calling other people's api's so if

00:10:08,680 --> 00:10:12,430
you have to you can be weird and clever

00:10:10,240 --> 00:10:15,400
but if you can stick with conventions

00:10:12,430 --> 00:10:16,900
you'll get a lot of bonuses first of all

00:10:15,400 --> 00:10:19,240
you'll convey respect for your users

00:10:16,900 --> 00:10:21,100
you're not some outsider who's going to

00:10:19,240 --> 00:10:23,050
come in and make their code a mess of

00:10:21,100 --> 00:10:25,660
clashing Styles with bad case

00:10:23,050 --> 00:10:27,310
conventions and weird factoring how many

00:10:25,660 --> 00:10:29,230
times have you encountered a Java API

00:10:27,310 --> 00:10:32,710
masquerading as a Python one and thrown

00:10:29,230 --> 00:10:34,750
it away and discussed second you'll get

00:10:32,710 --> 00:10:36,130
learning speed and retention if it's the

00:10:34,750 --> 00:10:39,250
same as everything else there's less to

00:10:36,130 --> 00:10:41,410
learn and less to remember this is the

00:10:39,250 --> 00:10:43,690
brilliant thing about the early

00:10:41,410 --> 00:10:44,890
Macintosh project they had explicit

00:10:43,690 --> 00:10:47,410
written down human interface guidelines

00:10:44,890 --> 00:10:49,060
because very soon after hiring their

00:10:47,410 --> 00:10:52,240
first programmers they hired a whole

00:10:49,060 --> 00:10:54,430
bunch of technical writers every program

00:10:52,240 --> 00:10:56,440
had the same commands open closed quit

00:10:54,430 --> 00:10:57,910
copy paste and they all lived in the

00:10:56,440 --> 00:11:01,030
same menus and had the same keyboard

00:10:57,910 --> 00:11:02,650
shortcuts so in a very real sense when

00:11:01,030 --> 00:11:06,370
you learned one program you had learned

00:11:02,650 --> 00:11:09,790
them all now API design is the same in

00:11:06,370 --> 00:11:11,620
so many ways as UI design and we can

00:11:09,790 --> 00:11:13,660
apply a lot of the same principles like

00:11:11,620 --> 00:11:16,360
the principle of least astonishment

00:11:13,660 --> 00:11:19,300
so trying to surprise the user if you

00:11:16,360 --> 00:11:21,400
implement some kind of mapping type and

00:11:19,300 --> 00:11:24,430
you have something that acts a lot like

00:11:21,400 --> 00:11:26,890
a Python mapping you should call it gets

00:11:24,430 --> 00:11:28,570
get method get and it should take key

00:11:26,890 --> 00:11:30,900
and then default you shouldn't call it

00:11:28,570 --> 00:11:32,950
fetch and then reverse the arguments

00:11:30,900 --> 00:11:34,900
people will pick it up faster and

00:11:32,950 --> 00:11:37,120
remember it better if you use just plain

00:11:34,900 --> 00:11:40,480
old get plus you get polymorphism out of

00:11:37,120 --> 00:11:42,820
it right if you're consistent things can

00:11:40,480 --> 00:11:45,360
kind of luckily happen to you like oh I

00:11:42,820 --> 00:11:48,940
can just substitute a dict in for my

00:11:45,360 --> 00:11:50,500
reading mapping class and use it to mock

00:11:48,940 --> 00:11:52,840
some things out in my tests or i can

00:11:50,500 --> 00:11:54,820
even deploy small sites just using a big

00:11:52,840 --> 00:11:56,410
Ram resonant dictionary instead of

00:11:54,820 --> 00:12:00,730
talking over a socket and having that

00:11:56,410 --> 00:12:02,590
setup costs so coming back to our

00:12:00,730 --> 00:12:04,810
terminal formatting example how do we

00:12:02,590 --> 00:12:07,420
bang those tasks against our existing

00:12:04,810 --> 00:12:10,780
language features and conventions well

00:12:07,420 --> 00:12:11,950
here quantity over quality rules and

00:12:10,780 --> 00:12:13,540
this is the same kind of rule of thumb I

00:12:11,950 --> 00:12:15,610
use when I'm designing you I just get as

00:12:13,540 --> 00:12:17,560
many alternatives out there on the

00:12:15,610 --> 00:12:20,530
workbench as possible and I call these

00:12:17,560 --> 00:12:21,880
my sketches now for printing something

00:12:20,530 --> 00:12:25,480
at a location there are really only two

00:12:21,880 --> 00:12:26,950
choices both of these are okay but the

00:12:25,480 --> 00:12:29,080
second one gives us the flexibility of

00:12:26,950 --> 00:12:31,330
putting multiple statements inside loops

00:12:29,080 --> 00:12:33,970
even other calls out to other functions

00:12:31,330 --> 00:12:36,420
and then you could easily write print at

00:12:33,970 --> 00:12:39,640
the first one in terms of the second one

00:12:36,420 --> 00:12:41,890
so the second one is the winner here are

00:12:39,640 --> 00:12:43,450
the sketches for text formatting we've

00:12:41,890 --> 00:12:44,920
got some square brackets in there we've

00:12:43,450 --> 00:12:46,840
got some dots and some string

00:12:44,920 --> 00:12:48,820
concatenation a couple of function calls

00:12:46,840 --> 00:12:51,310
with keyword arguments some of

00:12:48,820 --> 00:12:53,020
positional required arguments now most

00:12:51,310 --> 00:12:54,730
of these separate the printing from the

00:12:53,020 --> 00:12:57,250
formatting which is generally good idea

00:12:54,730 --> 00:12:59,290
but the first one combines them together

00:12:57,250 --> 00:13:01,900
I have a couple of favorites here

00:12:59,290 --> 00:13:03,820
there's this one it gives you a very

00:13:01,900 --> 00:13:05,830
familiar nested function call syntax

00:13:03,820 --> 00:13:08,080
it's composable and frankly it looks a

00:13:05,830 --> 00:13:10,870
lot like HTML so probably familiar to a

00:13:08,080 --> 00:13:13,210
wide swath of your audience trouble is

00:13:10,870 --> 00:13:17,050
there didn't happen to be a portable way

00:13:13,210 --> 00:13:24,490
of turning off bold in terminals so that

00:13:17,050 --> 00:13:26,140
was kind of out now this this just uses

00:13:24,490 --> 00:13:27,340
attributes and saves us a great deal of

00:13:26,140 --> 00:13:29,320
complexity we

00:13:27,340 --> 00:13:30,940
whirlaway state or have any kind of a

00:13:29,320 --> 00:13:32,590
big staple object we're dragging around

00:13:30,940 --> 00:13:34,480
remembering if we had turned on bold so

00:13:32,590 --> 00:13:37,750
that we can omit the code later no we

00:13:34,480 --> 00:13:43,750
just admit omit the exact terminal codes

00:13:37,750 --> 00:13:46,330
as attributes on a terminal class now to

00:13:43,750 --> 00:13:48,310
support the nesting case oh I should

00:13:46,330 --> 00:13:52,300
mention notice that I'm using this with

00:13:48,310 --> 00:13:54,880
pythons built-in template formatting

00:13:52,300 --> 00:13:55,990
syntax so by being consistent with

00:13:54,880 --> 00:13:57,310
language features we get this for free

00:13:55,990 --> 00:13:58,900
we don't have to have our own templating

00:13:57,310 --> 00:14:02,800
language which so many terminal language

00:13:58,900 --> 00:14:04,180
terminal formatting libraries do now to

00:14:02,800 --> 00:14:06,520
support the nesting case we have this

00:14:04,180 --> 00:14:08,560
kind of mash it all together syntax red

00:14:06,520 --> 00:14:12,130
bold or we could have said red bold on

00:14:08,560 --> 00:14:14,410
white now it immediately this is a bit

00:14:12,130 --> 00:14:16,240
novel but I kept this example in the

00:14:14,410 --> 00:14:18,070
consistency section because I think it's

00:14:16,240 --> 00:14:20,320
really good to see that these principles

00:14:18,070 --> 00:14:22,120
are all about trade-offs we can't just

00:14:20,320 --> 00:14:23,380
turn all the knobs all the way up to 11

00:14:22,120 --> 00:14:25,000
or we would just do that all the time

00:14:23,380 --> 00:14:26,050
and we wouldn't need to think about this

00:14:25,000 --> 00:14:29,230
at all and I wouldn't be giving this

00:14:26,050 --> 00:14:31,870
talk so if you're going to do something

00:14:29,230 --> 00:14:34,180
a little bit weird at least be self

00:14:31,870 --> 00:14:36,820
consistent this mashed together

00:14:34,180 --> 00:14:39,730
multi-word syntax is used for everything

00:14:36,820 --> 00:14:41,830
in blessings formatting foreground color

00:14:39,730 --> 00:14:43,900
background color it's hard to get it

00:14:41,830 --> 00:14:46,450
wrong you can put the for matters in any

00:14:43,900 --> 00:14:48,160
order and it just works and there's

00:14:46,450 --> 00:14:49,810
caching for speed so you don't have to

00:14:48,160 --> 00:14:52,300
worry about using some favored

00:14:49,810 --> 00:14:54,190
representation so the user doesn't have

00:14:52,300 --> 00:14:57,010
to keep on making trips back to the docs

00:14:54,190 --> 00:14:58,720
they internalize one slightly weird idea

00:14:57,010 --> 00:15:01,240
and that carries them through all of

00:14:58,720 --> 00:15:02,500
their use cases another really

00:15:01,240 --> 00:15:04,720
straightforward example of this is

00:15:02,500 --> 00:15:07,060
Django's ORM syntax I've got those

00:15:04,720 --> 00:15:09,220
double underscores right nobody else

00:15:07,060 --> 00:15:11,530
does that but this is used consistently

00:15:09,220 --> 00:15:15,280
throughout the ORM you learn it once and

00:15:11,530 --> 00:15:17,080
you apply it everywhere so when you're

00:15:15,280 --> 00:15:22,780
evaluating your consistency watch out

00:15:17,080 --> 00:15:24,160
for these red flags if you find yourself

00:15:22,780 --> 00:15:26,320
frequently referencing your own

00:15:24,160 --> 00:15:27,990
documentation or the source code of your

00:15:26,320 --> 00:15:30,790
library your previously written as

00:15:27,990 --> 00:15:32,980
you're building the stuff why what I

00:15:30,790 --> 00:15:35,170
call that did I put the arguments in

00:15:32,980 --> 00:15:37,060
this order or that order maybe you

00:15:35,170 --> 00:15:40,030
should go back and try to clarify things

00:15:37,060 --> 00:15:41,080
if you feel like you're inventing novel

00:15:40,030 --> 00:15:43,250
syntax

00:15:41,080 --> 00:15:45,110
make sure you stop and check yourself

00:15:43,250 --> 00:15:46,760
use your judgement when you're doing

00:15:45,110 --> 00:15:50,900
novelty make sure that it pays off

00:15:46,760 --> 00:15:53,570
rather than just shows off our third

00:15:50,900 --> 00:15:56,090
rule today is brevity try to make common

00:15:53,570 --> 00:15:57,830
things short in tokens I mean but

00:15:56,090 --> 00:15:58,940
sometimes even in terms of characters if

00:15:57,830 --> 00:16:02,300
it doesn't hurt your readability too

00:15:58,940 --> 00:16:04,130
much here's our excerpt from earlier and

00:16:02,300 --> 00:16:07,100
now we'll go into why we use this mash

00:16:04,130 --> 00:16:09,410
together syntax a little bit more since

00:16:07,100 --> 00:16:10,970
formatting something and then resetting

00:16:09,410 --> 00:16:13,870
to plain text is the most common

00:16:10,970 --> 00:16:16,760
operation we try to make it a shortest

00:16:13,870 --> 00:16:19,310
here's a shortcut these two lines are

00:16:16,760 --> 00:16:21,440
equivalent you can actually use this as

00:16:19,310 --> 00:16:23,600
a string like above or you can just call

00:16:21,440 --> 00:16:26,870
it and it's equivalent but not

00:16:23,600 --> 00:16:28,370
everything has to be brief this for

00:16:26,870 --> 00:16:29,900
example is a way to get down and dirty

00:16:28,370 --> 00:16:31,610
and really control exactly that the

00:16:29,900 --> 00:16:32,780
bytes that you're admitting now most

00:16:31,610 --> 00:16:34,640
people don't need this they can do the

00:16:32,780 --> 00:16:37,100
easier thing above but if you want to

00:16:34,640 --> 00:16:38,900
get down and crazy and dirty this lower

00:16:37,100 --> 00:16:40,580
thing that lets you do it at the cost of

00:16:38,900 --> 00:16:42,020
just being a little bit longer the

00:16:40,580 --> 00:16:46,520
general principle is you should pay for

00:16:42,020 --> 00:16:48,170
what you eat ask yourself these

00:16:46,520 --> 00:16:50,390
questions about brevity do you find

00:16:48,170 --> 00:16:53,300
yourself copying chunks of code from

00:16:50,390 --> 00:16:56,510
your examples it's probably too hard to

00:16:53,300 --> 00:16:58,280
type that stuff do you find yourself

00:16:56,510 --> 00:16:59,750
typing something irrelevant and saying

00:16:58,280 --> 00:17:01,490
how do I have to pass true for this

00:16:59,750 --> 00:17:03,470
argument it's always true why can't you

00:17:01,490 --> 00:17:06,140
just assume that well that's a default

00:17:03,470 --> 00:17:10,250
right there another way this can

00:17:06,140 --> 00:17:12,560
manifest is very long argument lists you

00:17:10,250 --> 00:17:13,910
could be missing defaults maybe you just

00:17:12,560 --> 00:17:15,589
have very complex data and it'd be

00:17:13,910 --> 00:17:17,209
better encapsulated as a class that you

00:17:15,589 --> 00:17:22,040
can instantiate once and then call

00:17:17,209 --> 00:17:24,319
methods on composability making your

00:17:22,040 --> 00:17:26,060
abstractions composable means being able

00:17:24,319 --> 00:17:28,100
to reuse them in lots of different

00:17:26,060 --> 00:17:30,890
situations and plug them together in

00:17:28,100 --> 00:17:33,470
unforeseen ways now there are million

00:17:30,890 --> 00:17:36,950
ways to say this flexibility loose

00:17:33,470 --> 00:17:38,450
coupling small pieces loosely joined it

00:17:36,950 --> 00:17:41,210
all comes down to the minimization of

00:17:38,450 --> 00:17:44,500
assumptions now there are two ways you

00:17:41,210 --> 00:17:46,400
can go about this one of them wrong

00:17:44,500 --> 00:17:49,040
let's go back to another way we could

00:17:46,400 --> 00:17:52,700
have done blessings we could have jammed

00:17:49,040 --> 00:17:54,750
together printing and formatting on one

00:17:52,700 --> 00:17:56,370
go like this now my friend

00:17:54,750 --> 00:17:59,250
Jeff quast put together a really neat

00:17:56,370 --> 00:18:00,780
bulletin board system called x84 it's

00:17:59,250 --> 00:18:03,720
really old-school it works over telnet

00:18:00,780 --> 00:18:06,990
and it uses blessings in a multi-process

00:18:03,720 --> 00:18:08,370
design it's not like Apache it's got a

00:18:06,990 --> 00:18:09,930
server process for most of the action

00:18:08,370 --> 00:18:13,080
happens including the formatting and

00:18:09,930 --> 00:18:15,150
then it doles out to children processes

00:18:13,080 --> 00:18:18,180
which handle each socket each client

00:18:15,150 --> 00:18:21,000
connection so with the first line here

00:18:18,180 --> 00:18:23,330
there's no way to pass the output to the

00:18:21,000 --> 00:18:25,290
children in fact you neither of these

00:18:23,330 --> 00:18:27,330
first one first one let's go with first

00:18:25,290 --> 00:18:29,250
one because we assumed and there's that

00:18:27,330 --> 00:18:32,040
coupling that printing and formatting

00:18:29,250 --> 00:18:33,720
would happen all in one go now the wrong

00:18:32,040 --> 00:18:37,050
way to solve this would be line to add

00:18:33,720 --> 00:18:38,970
an option say pass in a file handle but

00:18:37,050 --> 00:18:40,950
now you've always got to instantiate

00:18:38,970 --> 00:18:41,970
some file handle or string il object

00:18:40,950 --> 00:18:44,610
even if you just wanted to keep that

00:18:41,970 --> 00:18:47,130
string in memory plus it makes the API

00:18:44,610 --> 00:18:50,190
more complicated you've got to document

00:18:47,130 --> 00:18:52,230
that option you've got to put a branch

00:18:50,190 --> 00:18:55,470
in your code for it and then you've got

00:18:52,230 --> 00:18:56,790
to write tests to test that branch every

00:18:55,470 --> 00:18:58,620
time I think about adding an option I

00:18:56,790 --> 00:19:02,250
look around for any other escape route

00:18:58,620 --> 00:19:03,750
first so a better way here is to break

00:19:02,250 --> 00:19:06,150
that coupling at the Assumption point

00:19:03,750 --> 00:19:09,870
dividing into two orthogonal pieces

00:19:06,150 --> 00:19:11,220
print and format now because we followed

00:19:09,870 --> 00:19:13,470
the composability rule of thumb and

00:19:11,220 --> 00:19:15,510
blessings like this Jeff was able to

00:19:13,470 --> 00:19:17,190
stick formatted strings into memory

00:19:15,510 --> 00:19:19,590
really easily and pass them off to his

00:19:17,190 --> 00:19:21,960
child processes and despite the fact

00:19:19,590 --> 00:19:23,880
that he started xat for ten years before

00:19:21,960 --> 00:19:25,200
blessings even existed and it made a lot

00:19:23,880 --> 00:19:27,420
of architectural commitments and

00:19:25,200 --> 00:19:29,310
decisions it was a really easy retrofit

00:19:27,420 --> 00:19:34,110
because it minimized the assumptions it

00:19:29,310 --> 00:19:37,200
made so watch out for these red flags

00:19:34,110 --> 00:19:39,240
and composability classes with lots of

00:19:37,200 --> 00:19:41,100
state make me think that there are

00:19:39,240 --> 00:19:42,810
multiple little classes inside just

00:19:41,100 --> 00:19:45,990
struggling to get out each serving a

00:19:42,810 --> 00:19:48,300
single purpose so the pie elasticsearch

00:19:45,990 --> 00:19:50,190
connection objects a library for talking

00:19:48,300 --> 00:19:52,380
to elasticsearch from python and it

00:19:50,190 --> 00:19:54,480
needed a penalty box for elasticsearch

00:19:52,380 --> 00:19:55,950
nodes that weren't responding I didn't

00:19:54,480 --> 00:19:56,970
want to keep on trying these nodes if

00:19:55,950 --> 00:20:00,000
they weren't responding you'll give them

00:19:56,970 --> 00:20:01,500
five or ten minutes to recover now I was

00:20:00,000 --> 00:20:04,260
tempted to add this directly to the

00:20:01,500 --> 00:20:06,360
connection object but I found out it was

00:20:04,260 --> 00:20:07,890
better in fact to separate them as a

00:20:06,360 --> 00:20:08,590
separate thing i can now reuse this in

00:20:07,890 --> 00:20:09,940
other projects

00:20:08,590 --> 00:20:11,260
and this doesn't even know this doesn't

00:20:09,940 --> 00:20:14,289
even assume that it's for connections

00:20:11,260 --> 00:20:16,330
all it happens to have in it is URLs

00:20:14,289 --> 00:20:17,799
they represent the nodes I could put in

00:20:16,330 --> 00:20:20,230
sin there it doesn't care all it knows

00:20:17,799 --> 00:20:22,000
is you can be a bunch of things you tell

00:20:20,230 --> 00:20:25,230
me which ones are dead and alive and I

00:20:22,000 --> 00:20:28,090
run a timer and give you one at random

00:20:25,230 --> 00:20:31,090
another thing to watch out for is deep

00:20:28,090 --> 00:20:32,860
inheritance hierarchies people say and

00:20:31,090 --> 00:20:34,929
they're right that composition is better

00:20:32,860 --> 00:20:38,409
than inheritance and here's why they say

00:20:34,929 --> 00:20:40,059
that if you inherit your object does get

00:20:38,409 --> 00:20:43,510
easy access to the functionality of the

00:20:40,059 --> 00:20:46,000
parent that much is true but it also

00:20:43,510 --> 00:20:48,850
inherits all the invariant baggage that

00:20:46,000 --> 00:20:51,370
the parent has and it's required to

00:20:48,850 --> 00:20:53,679
maintain those invariants what you've

00:20:51,370 --> 00:20:55,600
done now is just increase the attack

00:20:53,679 --> 00:20:57,309
surface if you like the amount of code

00:20:55,600 --> 00:21:06,730
that has the tiptoe around those

00:20:57,309 --> 00:21:08,860
invariants the law of Demeter now this

00:21:06,730 --> 00:21:12,700
says if you do choose to compose objects

00:21:08,860 --> 00:21:15,429
no cheating so if elasticsearch contains

00:21:12,700 --> 00:21:17,409
a penalty box object the elastic church

00:21:15,429 --> 00:21:20,049
object can call methods on that penalty

00:21:17,409 --> 00:21:23,110
box but it's not allowed to call methods

00:21:20,049 --> 00:21:25,210
on objects inside the penalty box so

00:21:23,110 --> 00:21:28,210
think of it as the one dot rule a dot B

00:21:25,210 --> 00:21:32,260
is fine a dot B dot c is less fine hey

00:21:28,210 --> 00:21:33,520
wat vcd is right out because if you just

00:21:32,260 --> 00:21:34,899
if you're reaching into everything like

00:21:33,520 --> 00:21:36,460
that you're making assumptions all over

00:21:34,899 --> 00:21:37,809
the place and there is no point in

00:21:36,460 --> 00:21:39,039
splitting up these objects to begin with

00:21:37,809 --> 00:21:43,330
you might of all might as well just all

00:21:39,039 --> 00:21:46,299
dumped it in one namespace mocking and

00:21:43,330 --> 00:21:48,460
tests I'm of two minds about mocking I

00:21:46,299 --> 00:21:50,559
think if you find yourself mocking out

00:21:48,460 --> 00:21:53,470
too many dependencies of your code your

00:21:50,559 --> 00:21:56,679
code has too many dependencies for

00:21:53,470 --> 00:21:59,890
example how would you test this you'd

00:21:56,679 --> 00:22:01,870
have to reach into cysts and mock out

00:21:59,890 --> 00:22:03,730
maybe standard out and then you remember

00:22:01,870 --> 00:22:05,230
to put it back afterwards you mocking

00:22:03,730 --> 00:22:08,409
library maybe to help you do that easily

00:22:05,230 --> 00:22:10,510
on the other hand this doesn't require

00:22:08,409 --> 00:22:11,970
any mocking just compare the return

00:22:10,510 --> 00:22:16,270
string and forget about printing

00:22:11,970 --> 00:22:18,669
testable code is decoupled code and then

00:22:16,270 --> 00:22:21,429
it finally Bolton options look out for

00:22:18,669 --> 00:22:22,550
those now another rule of thumb that

00:22:21,429 --> 00:22:27,340
helps with three years ability

00:22:22,550 --> 00:22:27,340
is plain data sort of native data types

00:22:27,640 --> 00:22:32,870
whenever possible your API should speak

00:22:30,590 --> 00:22:35,960
with its callers using simple built-in

00:22:32,870 --> 00:22:38,900
types sticks and in sand strings not big

00:22:35,960 --> 00:22:40,550
hairy custom data structures and the aim

00:22:38,900 --> 00:22:42,770
here which should be sounding eerily

00:22:40,550 --> 00:22:46,550
familiar now is to reduce barriers to

00:22:42,770 --> 00:22:48,410
reuse what's a barrier all a barrier is

00:22:46,550 --> 00:22:50,720
the config parser class out of the

00:22:48,410 --> 00:22:53,090
python standard lib and this is an

00:22:50,720 --> 00:22:56,360
excerpt of its API its purpose in life

00:22:53,090 --> 00:22:58,340
is to read windows style ini files now

00:22:56,360 --> 00:22:59,750
unfortunately config parser is not just

00:22:58,340 --> 00:23:02,240
a parser that does its job and

00:22:59,750 --> 00:23:03,800
translates the file into a string or a

00:23:02,240 --> 00:23:05,180
couple of dictionaries nested

00:23:03,800 --> 00:23:07,820
dictionaries or whatever and gets out of

00:23:05,180 --> 00:23:10,250
the way no it hangs around and you have

00:23:07,820 --> 00:23:12,980
to write your entire program in terms of

00:23:10,250 --> 00:23:15,530
its API and up with has option calls and

00:23:12,980 --> 00:23:19,970
get calls all over the place but they're

00:23:15,530 --> 00:23:21,680
not idiomatic python things get for

00:23:19,970 --> 00:23:24,230
example it's not your normal get its

00:23:21,680 --> 00:23:27,110
section option not key default that's a

00:23:24,230 --> 00:23:29,900
little confusing and you can imagine it

00:23:27,110 --> 00:23:32,060
even has option section option we could

00:23:29,900 --> 00:23:34,640
represent this whole thing as a nested

00:23:32,060 --> 00:23:38,720
map you know bracket section bracket

00:23:34,640 --> 00:23:40,850
option and away you go then later if you

00:23:38,720 --> 00:23:43,070
want to make your program more flexible

00:23:40,850 --> 00:23:45,500
and be pulling gamal configuration or

00:23:43,070 --> 00:23:47,240
something else you're still stuck to

00:23:45,500 --> 00:23:48,740
this API right you have to put ifs and

00:23:47,240 --> 00:23:50,090
your code each time you do configuration

00:23:48,740 --> 00:23:53,900
or you have to write your own

00:23:50,090 --> 00:23:55,220
abstraction layer on top of this so I'm

00:23:53,900 --> 00:23:58,430
let me pick on this a little bit more

00:23:55,220 --> 00:24:00,110
and like just a little bit about its API

00:23:58,430 --> 00:24:02,030
we're going to say has a read command

00:24:00,110 --> 00:24:06,080
which it does it takes a single file

00:24:02,030 --> 00:24:07,820
name which it actually doesn't this

00:24:06,080 --> 00:24:10,010
might feel like a convenience since

00:24:07,820 --> 00:24:13,190
config often comes out of files but

00:24:10,010 --> 00:24:15,920
actually it's a barrier a method should

00:24:13,190 --> 00:24:18,590
take what it needs and no more you need

00:24:15,920 --> 00:24:20,450
a string you don't need to file for any

00:24:18,590 --> 00:24:21,800
reason the config file is not 500

00:24:20,450 --> 00:24:23,240
megabytes you're not going to be seeking

00:24:21,800 --> 00:24:25,730
around in it there's no reason to need a

00:24:23,240 --> 00:24:27,320
file handle now if you want to add the

00:24:25,730 --> 00:24:29,210
convenience back that's fine you can add

00:24:27,320 --> 00:24:30,290
a helper function like file contents

00:24:29,210 --> 00:24:33,770
that can be used in combination with

00:24:30,290 --> 00:24:34,940
this string taking method or you can you

00:24:33,770 --> 00:24:36,380
can go ahead and add a convenience

00:24:34,940 --> 00:24:38,750
function also that does both part

00:24:36,380 --> 00:24:40,340
but make sure you also provide the core

00:24:38,750 --> 00:24:45,260
method that takes the minimum thing it

00:24:40,340 --> 00:24:47,750
needs even when you have an inherently

00:24:45,260 --> 00:24:49,400
more complicated data structure kind of

00:24:47,750 --> 00:24:52,100
expose as much of it as possible as

00:24:49,400 --> 00:24:54,230
built-in interfaces this is a little

00:24:52,100 --> 00:24:57,260
snippet from library that I'm working on

00:24:54,230 --> 00:25:01,150
called spider flunky and it does static

00:24:57,260 --> 00:25:04,400
analysis of JavaScript code now I was

00:25:01,150 --> 00:25:07,040
ashamed to find in my travels that I

00:25:04,400 --> 00:25:09,160
actually needed a doubly linked tree to

00:25:07,040 --> 00:25:11,570
represent the abstract syntax tree

00:25:09,160 --> 00:25:13,580
singly linked wasn't do it so I couldn't

00:25:11,570 --> 00:25:15,440
just have nested lists I need to be able

00:25:13,580 --> 00:25:18,860
to walk from the inner lists out to the

00:25:15,440 --> 00:25:21,680
outer lists or up the tree so I had to

00:25:18,860 --> 00:25:24,500
make this node class and it hurt my soul

00:25:21,680 --> 00:25:27,290
but there you have it but the first

00:25:24,500 --> 00:25:30,290
thing I did was to break back into the

00:25:27,290 --> 00:25:31,610
Python idiom by exposing things as kind

00:25:30,290 --> 00:25:35,600
of built-in language constructs in this

00:25:31,610 --> 00:25:39,350
case a transit up the tree as an

00:25:35,600 --> 00:25:40,670
iterator now because I then expose this

00:25:39,350 --> 00:25:42,890
as something that the language kind of

00:25:40,670 --> 00:25:44,540
gives preference to I could do pretty

00:25:42,890 --> 00:25:46,250
complicated things with sexy little

00:25:44,540 --> 00:25:49,100
one-liners like list comprehensions and

00:25:46,250 --> 00:25:52,190
generated expressions this finds me the

00:25:49,100 --> 00:25:53,750
scope of any JavaScript ast node just by

00:25:52,190 --> 00:25:56,410
walking on up and taking the first one

00:25:53,750 --> 00:25:58,340
that looks like a scope II kind of node

00:25:56,410 --> 00:26:02,720
so if you can't have plain data

00:25:58,340 --> 00:26:04,910
everywhere get back to it ASAP plenty of

00:26:02,720 --> 00:26:06,380
warning signs if your users take your

00:26:04,910 --> 00:26:08,360
output and immediately change it to

00:26:06,380 --> 00:26:12,170
something else public should have good

00:26:08,360 --> 00:26:13,880
one to something else if conversely you

00:26:12,170 --> 00:26:15,800
make them instantiate some massive

00:26:13,880 --> 00:26:18,020
custom object just to pass it to a

00:26:15,800 --> 00:26:19,580
routine of yours well maybe you should

00:26:18,020 --> 00:26:21,290
just take those individual things

00:26:19,580 --> 00:26:22,990
individually unless you see them we're

00:26:21,290 --> 00:26:25,970
using them a lot using the bundles and

00:26:22,990 --> 00:26:27,170
then if you find yourself rewriting

00:26:25,970 --> 00:26:29,900
things that the language already

00:26:27,170 --> 00:26:31,340
provides in different terms like config

00:26:29,900 --> 00:26:33,290
parser had that good thing it took a

00:26:31,340 --> 00:26:39,980
section and then a key where it's really

00:26:33,290 --> 00:26:42,170
just one key access to key accesses so I

00:26:39,980 --> 00:26:44,690
have this idea that users of my API

00:26:42,170 --> 00:26:47,300
should spend most of their time in the

00:26:44,690 --> 00:26:49,789
groove and I don't just mean performing

00:26:47,300 --> 00:26:51,259
well or doing their work easily

00:26:49,789 --> 00:26:54,409
I mean it in a more strictly physical

00:26:51,259 --> 00:26:58,249
sense so if you think of programming is

00:26:54,409 --> 00:27:00,259
walking like a cross a plane and there's

00:26:58,249 --> 00:27:01,820
this groove in the plane it's got it's a

00:27:00,259 --> 00:27:03,769
nice smooth path and it has kind of

00:27:01,820 --> 00:27:05,539
curvy sides that tend to keep you

00:27:03,769 --> 00:27:07,369
centered in the groove you can even

00:27:05,539 --> 00:27:08,749
close your eyes and walk through it

00:27:07,369 --> 00:27:10,940
because even if the groove is curving

00:27:08,749 --> 00:27:14,450
it's got these nice gently sloping sides

00:27:10,940 --> 00:27:16,070
that push you back into the center so

00:27:14,450 --> 00:27:17,600
even if there's nothing keeping you from

00:27:16,070 --> 00:27:19,279
stepping out of the groove and walking

00:27:17,600 --> 00:27:21,259
somewhere else the groove is very

00:27:19,279 --> 00:27:23,989
attractive and new users are drawn there

00:27:21,259 --> 00:27:29,179
first here are a couple ideas on how to

00:27:23,989 --> 00:27:31,879
cut grooves in your AP is avoid nonsense

00:27:29,179 --> 00:27:34,489
representations so let's talk about PI

00:27:31,879 --> 00:27:38,179
elasticsearch briefly again there are

00:27:34,489 --> 00:27:40,399
two ways to query elasticsearch you can

00:27:38,179 --> 00:27:42,919
pass it a big JSON blob very capable but

00:27:40,399 --> 00:27:44,960
complicated or you can pass it this more

00:27:42,919 --> 00:27:46,909
limited but tersh or string syntax

00:27:44,960 --> 00:27:48,379
there's no such thing as an elastic

00:27:46,909 --> 00:27:50,299
search query that uses both formats at

00:27:48,379 --> 00:27:53,119
once or neither format you have to

00:27:50,299 --> 00:27:55,609
choose one now here's what PI

00:27:53,119 --> 00:27:57,889
elasticsearch used to look like all its

00:27:55,609 --> 00:27:59,690
args are optional you could you have to

00:27:57,889 --> 00:28:01,609
pass in the string style queries using

00:27:59,690 --> 00:28:04,820
the queue argument and the JSON ones

00:28:01,609 --> 00:28:06,109
using the body argument of course this

00:28:04,820 --> 00:28:09,889
meant that nothing stopped you from

00:28:06,109 --> 00:28:12,229
doing this or even this both of which

00:28:09,889 --> 00:28:14,200
are complete nonsense and I'd say you

00:28:12,229 --> 00:28:16,129
shouldn't even be able to get that far

00:28:14,200 --> 00:28:17,479
you certainly shouldn't need code in

00:28:16,129 --> 00:28:20,299
your library to reject this kind of

00:28:17,479 --> 00:28:23,210
silliness which we used to need the new

00:28:20,299 --> 00:28:24,529
pile astok search looks like this we

00:28:23,210 --> 00:28:26,479
replaced that mess with a single

00:28:24,529 --> 00:28:28,639
required argument to which you can pass

00:28:26,479 --> 00:28:30,349
either a string or adjacent dictionary

00:28:28,639 --> 00:28:32,269
you can't go wrong because the

00:28:30,349 --> 00:28:35,599
interpreter won't let you it's much

00:28:32,269 --> 00:28:37,009
groovier now incidentally this turns up

00:28:35,599 --> 00:28:39,799
another principle which is to fail

00:28:37,009 --> 00:28:41,570
shallowly in languages that give you

00:28:39,799 --> 00:28:44,210
trace backs this is a very nice

00:28:41,570 --> 00:28:46,039
convenience but if heaven forbid using a

00:28:44,210 --> 00:28:48,229
language that doesn't like a lot of

00:28:46,039 --> 00:28:50,389
JavaScript implementations this is

00:28:48,229 --> 00:28:51,830
absolutely vital and this is one of the

00:28:50,389 --> 00:28:55,970
things that drives me nuts about Java

00:28:51,830 --> 00:28:57,799
scripts design you know Yun defines and

00:28:55,970 --> 00:28:59,989
man's can pop out of things and get

00:28:57,799 --> 00:29:02,269
squirreled away in data structures only

00:28:59,989 --> 00:29:03,530
to appear 500 function calls later and

00:29:02,269 --> 00:29:05,780
then you spend all afternoon trying to

00:29:03,530 --> 00:29:09,800
I swear these things came from fail

00:29:05,780 --> 00:29:15,260
shallowly another way to provide grooves

00:29:09,800 --> 00:29:18,050
is are aii this is a poppable balloon

00:29:15,260 --> 00:29:21,230
class but as you can see when you first

00:29:18,050 --> 00:29:22,700
construct one it has zero air in it now

00:29:21,230 --> 00:29:24,950
you can't pop a balloon that has no air

00:29:22,700 --> 00:29:27,800
right you might imagine seeing some

00:29:24,950 --> 00:29:29,300
documentation that says before popping

00:29:27,800 --> 00:29:32,690
the balloon make sure you fill it with

00:29:29,300 --> 00:29:34,550
air now that's broken design a papabile

00:29:32,690 --> 00:29:36,200
balloon class should be poppable all the

00:29:34,550 --> 00:29:37,460
time full stop right the user shouldn't

00:29:36,200 --> 00:29:40,220
have to head over to the docks to figure

00:29:37,460 --> 00:29:43,490
out what went wrong so a better way here

00:29:40,220 --> 00:29:44,870
is to require explicitness which we know

00:29:43,490 --> 00:29:47,300
is a good thing because we're Python

00:29:44,870 --> 00:29:49,850
Eustace a better ways to take the

00:29:47,300 --> 00:29:51,230
initial fill amount at construction the

00:29:49,850 --> 00:29:53,030
user is required to provide it gets an

00:29:51,230 --> 00:29:54,710
air if they don't and so there's no

00:29:53,030 --> 00:29:58,010
wandering later on why the balloon just

00:29:54,710 --> 00:30:00,440
wants squished when you pricked it Rai

00:29:58,010 --> 00:30:04,340
is just a more specific case of don't

00:30:00,440 --> 00:30:05,810
have invariance that aren't and then a

00:30:04,340 --> 00:30:08,420
final way of providing grooves is

00:30:05,810 --> 00:30:10,280
through compelling examples now these

00:30:08,420 --> 00:30:12,340
are the most overt sort of grooves the

00:30:10,280 --> 00:30:14,990
user knows that they're being advised

00:30:12,340 --> 00:30:16,550
this is a screenshot from Mac Paint 1

00:30:14,990 --> 00:30:19,220
point 0 who's actually seen this in the

00:30:16,550 --> 00:30:20,540
flesh on original hardware yeah we got a

00:30:19,220 --> 00:30:22,760
lot of lot of people as old as me in

00:30:20,540 --> 00:30:25,070
here is great palace are on the left

00:30:22,760 --> 00:30:26,690
menus around the top and it looks

00:30:25,070 --> 00:30:27,830
familiar to everybody in this room even

00:30:26,690 --> 00:30:30,260
those who didn't put their hand up

00:30:27,830 --> 00:30:32,000
because Photoshop and illustrator in the

00:30:30,260 --> 00:30:33,650
 and Pixelmator & Paint Shop Pro and

00:30:32,000 --> 00:30:36,040
ms paint have been slavish Lee following

00:30:33,650 --> 00:30:38,120
this pattern for the last 30 years

00:30:36,040 --> 00:30:40,880
another great example is Nintendo

00:30:38,120 --> 00:30:41,870
platformers right this is original stuff

00:30:40,880 --> 00:30:43,430
on this hardware I don't think anybody

00:30:41,870 --> 00:30:45,470
had done anything like this before but

00:30:43,430 --> 00:30:48,440
even today we're still jumping and

00:30:45,470 --> 00:30:50,630
running to the right if you set a good

00:30:48,440 --> 00:30:53,030
example people will happily follow it

00:30:50,630 --> 00:30:54,830
forever now I used to write my example

00:30:53,030 --> 00:30:56,960
code and really like didactic fashion

00:30:54,830 --> 00:31:00,610
long outrageous variable names in

00:30:56,960 --> 00:31:03,800
efficiency for you know traded

00:31:00,610 --> 00:31:05,240
efficiency trade it off for clarity and

00:31:03,800 --> 00:31:06,500
I ended up having to stop doing that

00:31:05,240 --> 00:31:08,780
because of people were doing was they

00:31:06,500 --> 00:31:09,800
would take my code the example code and

00:31:08,780 --> 00:31:11,930
like paste it into the production

00:31:09,800 --> 00:31:13,400
systems and they'd even leave the

00:31:11,930 --> 00:31:16,040
comments there out of the docs even if

00:31:13,400 --> 00:31:17,389
they didn't apply anymore so I had I had

00:31:16,040 --> 00:31:20,539
to actually drop down and

00:31:17,389 --> 00:31:22,279
that my users are docile they will do

00:31:20,539 --> 00:31:25,159
exactly what you tell them to do and

00:31:22,279 --> 00:31:27,919
it's not that they're not that they're

00:31:25,159 --> 00:31:29,539
not smart they're just not interested in

00:31:27,919 --> 00:31:30,589
solving that problem that you solved

00:31:29,539 --> 00:31:31,789
they want to get in get the

00:31:30,589 --> 00:31:33,019
functionality and get back to the

00:31:31,789 --> 00:31:35,450
interesting problem that they're trying

00:31:33,019 --> 00:31:40,639
to solve so be a good library citizen

00:31:35,450 --> 00:31:43,099
give good examples grooviness yeah so

00:31:40,639 --> 00:31:45,409
look out for representable states that

00:31:43,099 --> 00:31:49,009
are nonsense you should even be able to

00:31:45,409 --> 00:31:51,919
state nonsense look out for invariance

00:31:49,009 --> 00:31:53,539
that aren't invariant and watch new

00:31:51,919 --> 00:31:56,839
users and see if they don't know where

00:31:53,539 --> 00:31:58,339
to start the tech writers in the early

00:31:56,839 --> 00:31:59,659
Macintosh project would often come back

00:31:58,339 --> 00:32:02,419
to the programmers and say hey you know

00:31:59,659 --> 00:32:04,070
this UI is totally confusing I'm having

00:32:02,419 --> 00:32:06,619
to write all this documentation in order

00:32:04,070 --> 00:32:09,320
to explain it bad design becomes obvious

00:32:06,619 --> 00:32:11,239
when you try to document it if you're

00:32:09,320 --> 00:32:13,399
api's do hard to explain it's probably

00:32:11,239 --> 00:32:16,070
too complicated so let's go back and fix

00:32:13,399 --> 00:32:18,109
the design incidentally this is why I

00:32:16,070 --> 00:32:19,969
like to write the readme first thing

00:32:18,109 --> 00:32:24,799
before I write any code documentation

00:32:19,969 --> 00:32:28,639
driven design makes for a better UI now

00:32:24,799 --> 00:32:31,429
we get to the walls walls are to keep

00:32:28,639 --> 00:32:32,839
you from hurting yourself or others just

00:32:31,429 --> 00:32:35,599
as in the physical metaphor there's a

00:32:32,839 --> 00:32:36,950
continuum between grooves and walls the

00:32:35,599 --> 00:32:39,379
more damage you can do with a feature

00:32:36,950 --> 00:32:40,940
the higher the wall should be the more

00:32:39,379 --> 00:32:44,299
barbed wire should have in the meaner

00:32:40,940 --> 00:32:46,329
the dogs in front of it should be here

00:32:44,299 --> 00:32:48,440
is a horrible API with not enough walls

00:32:46,329 --> 00:32:51,859
is anybody see what's wrong with this

00:32:48,440 --> 00:32:53,029
maybe it's bitten you in the past who

00:32:51,859 --> 00:32:54,349
here is wiped out a whole database

00:32:53,029 --> 00:32:58,159
column because they forgot the where

00:32:54,349 --> 00:33:00,979
clause yeah a lot of money wasted in

00:32:58,159 --> 00:33:03,320
this room so one way we could have maybe

00:33:00,979 --> 00:33:05,359
fixed that is to require you to say all

00:33:03,320 --> 00:33:07,219
when you mean all a little less

00:33:05,359 --> 00:33:08,450
mathematically elegant but think of all

00:33:07,219 --> 00:33:11,499
the money and time and hair it would

00:33:08,450 --> 00:33:13,999
have saved since the advent of sequel

00:33:11,499 --> 00:33:17,029
here's another old chestnut this is a

00:33:13,999 --> 00:33:18,619
pretty common thing to do right trouble

00:33:17,029 --> 00:33:21,679
is to do it first you have to type this

00:33:18,619 --> 00:33:24,829
switch is seriously bad news don't hit

00:33:21,679 --> 00:33:26,929
return by accident now maybe we could

00:33:24,829 --> 00:33:28,639
require dash F for this sort of thing I

00:33:26,929 --> 00:33:31,080
think actually some shells I start doing

00:33:28,639 --> 00:33:33,390
this which is fantastic

00:33:31,080 --> 00:33:35,220
a very similar sort of thing happened in

00:33:33,390 --> 00:33:37,679
PI elasticsearch this is what the delete

00:33:35,220 --> 00:33:39,659
method used to look like pi

00:33:37,679 --> 00:33:42,600
elasticsearch can delete a document

00:33:39,659 --> 00:33:44,159
based on an ID but one of its faults is

00:33:42,600 --> 00:33:46,200
if you don't pass an ID it'll just

00:33:44,159 --> 00:33:51,299
delete all the documents thank you very

00:33:46,200 --> 00:33:55,529
convenient an ID here if you'll notice

00:33:51,299 --> 00:33:57,390
is optional I mean I can certainly

00:33:55,529 --> 00:33:59,519
imagine putting my end parentheses too

00:33:57,390 --> 00:34:01,019
soon or putting my ID in there but I

00:33:59,519 --> 00:34:02,840
forgot one of the other argh so it turns

00:34:01,019 --> 00:34:06,570
out to get doctype and not really an ID

00:34:02,840 --> 00:34:12,419
so we fixed that and here's how it looks

00:34:06,570 --> 00:34:14,520
now ID is mandatory pardon me and we

00:34:12,419 --> 00:34:15,899
introduced a separate delete all method

00:34:14,520 --> 00:34:17,399
for that weird case where you want to

00:34:15,899 --> 00:34:18,780
delete all the documents so you can't

00:34:17,399 --> 00:34:22,950
possibly screw that up by accident you

00:34:18,780 --> 00:34:24,300
can only screw it up on purpose the

00:34:22,950 --> 00:34:26,250
other thing to consider is how to report

00:34:24,300 --> 00:34:29,280
errors and you have two choices most of

00:34:26,250 --> 00:34:30,570
the time and throwing an exception is a

00:34:29,280 --> 00:34:33,359
lot better than returning something

00:34:30,570 --> 00:34:36,980
because as we all know from see it's way

00:34:33,359 --> 00:34:36,980
too easy to ignore a return value

00:34:37,669 --> 00:34:42,780
warning signs for safety if you back to

00:34:41,159 --> 00:34:44,270
the docs again if you're reading your

00:34:42,780 --> 00:34:48,770
docs and you see that you're saying a

00:34:44,270 --> 00:34:50,760
remember to or make sure you do this

00:34:48,770 --> 00:34:53,010
maybe you should make it so you don't

00:34:50,760 --> 00:34:54,540
have to remember to or if it's a make

00:34:53,010 --> 00:34:56,970
sure you do this before or make sure you

00:34:54,540 --> 00:34:58,710
do this after consider context managers

00:34:56,970 --> 00:35:02,250
that's a really great way in Python of

00:34:58,710 --> 00:35:04,470
wrapping things second ask yourself

00:35:02,250 --> 00:35:06,330
what's the most dangerous thing I can do

00:35:04,470 --> 00:35:07,950
with my library and then make sure

00:35:06,330 --> 00:35:11,849
they're barking dogs in front of that

00:35:07,950 --> 00:35:13,770
you can't do that by accident be aware

00:35:11,849 --> 00:35:16,589
that most people won't self-report

00:35:13,770 --> 00:35:18,060
safety issues there's a still a culture

00:35:16,589 --> 00:35:19,950
of blaming the user that goes on in

00:35:18,060 --> 00:35:22,380
programming I'd we have to work to stomp

00:35:19,950 --> 00:35:24,030
this out so users are embarrassed and

00:35:22,380 --> 00:35:25,410
reticent to admit that they made what

00:35:24,030 --> 00:35:27,750
they see as a mistake which is actually

00:35:25,410 --> 00:35:29,609
designed mistake right if you have an

00:35:27,750 --> 00:35:31,500
electrified doorknob it's not you didn't

00:35:29,609 --> 00:35:33,000
go get the asbestos mitt first a

00:35:31,500 --> 00:35:34,290
non-conductive MIT it's that you

00:35:33,000 --> 00:35:36,869
shouldn't have an electrified doorknob

00:35:34,290 --> 00:35:39,140
what are you doing so you need to

00:35:36,869 --> 00:35:41,460
actively watch out for users and solicit

00:35:39,140 --> 00:35:45,000
solicit mistakes people mistakes people

00:35:41,460 --> 00:35:46,620
have made those are my seven

00:35:45,000 --> 00:35:48,930
principles and here I've compiled them

00:35:46,620 --> 00:35:50,340
into a nice little checklist and if you

00:35:48,930 --> 00:35:51,540
bang your api's against them while

00:35:50,340 --> 00:35:54,810
you're designing them you should avoid

00:35:51,540 --> 00:35:57,390
the most common pitfalls but let me get

00:35:54,810 --> 00:35:59,700
meta for a second you may have noticed

00:35:57,390 --> 00:36:01,290
there were no big black lines between

00:35:59,700 --> 00:36:03,570
these some of these principles they kind

00:36:01,290 --> 00:36:06,330
of bleed into each other like plane data

00:36:03,570 --> 00:36:07,680
helps composability and brevity aids

00:36:06,330 --> 00:36:10,530
grooviness because it's easy to remember

00:36:07,680 --> 00:36:12,840
things so I began to wonder does any

00:36:10,530 --> 00:36:15,750
order arise out of the relationships

00:36:12,840 --> 00:36:19,140
between these and it turns out that it

00:36:15,750 --> 00:36:20,790
does if you lay them all out and you

00:36:19,140 --> 00:36:23,520
draw arrows between them that indicate

00:36:20,790 --> 00:36:25,200
this one contributes to that one you see

00:36:23,520 --> 00:36:28,320
them kind of divided almost perfectly

00:36:25,200 --> 00:36:30,180
into two clusters the left cluster is

00:36:28,320 --> 00:36:32,520
things that kind of Eve aid a

00:36:30,180 --> 00:36:34,560
quantitative definition compactness and

00:36:32,520 --> 00:36:36,390
grooviness these are more for human

00:36:34,560 --> 00:36:38,910
comprehension while the things on the

00:36:36,390 --> 00:36:40,560
right are more calculable things you

00:36:38,910 --> 00:36:42,570
could imagine having an absolute impact

00:36:40,560 --> 00:36:44,670
on the number of lines of code in the

00:36:42,570 --> 00:36:48,450
system ignoring human comprehensibility

00:36:44,670 --> 00:36:54,510
if you like the left is lingual and the

00:36:48,450 --> 00:36:55,800
right is mathematical now I've often

00:36:54,510 --> 00:36:57,330
thought that you can approach computer

00:36:55,800 --> 00:36:59,910
science from either of these directions

00:36:57,330 --> 00:37:03,420
as if its language or if it's math I

00:36:59,910 --> 00:37:06,390
didn't like math in school I was okay at

00:37:03,420 --> 00:37:07,560
it but I didn't love it I still argue

00:37:06,390 --> 00:37:08,940
with people who say the programming is

00:37:07,560 --> 00:37:12,000
essentially math because I'm a lingual

00:37:08,940 --> 00:37:13,350
thinker but both of these things are

00:37:12,000 --> 00:37:16,500
necessary to get anything to actually

00:37:13,350 --> 00:37:18,120
work right so the spotlight spotlights

00:37:16,500 --> 00:37:20,070
the things that the programming

00:37:18,120 --> 00:37:23,550
languages have over ordinary human

00:37:20,070 --> 00:37:25,260
languages programs are alive they not

00:37:23,550 --> 00:37:29,160
only mean things when people read them

00:37:25,260 --> 00:37:31,620
but they actually do things when run so

00:37:29,160 --> 00:37:35,930
very literally a program with carefully

00:37:31,620 --> 00:37:39,740
chosen symbols is poetry in motion

00:37:35,930 --> 00:37:39,740
pretty neat thank you very much

00:37:54,440 --> 00:37:59,430
mike is on there we are sure um your

00:37:57,930 --> 00:38:06,210
talk is good and you should feel good

00:37:59,430 --> 00:38:08,790
thank you thank you glad you enjoyed it

00:38:06,210 --> 00:38:10,350
and I say I mean basically you agree

00:38:08,790 --> 00:38:12,390
with my belief so we boast about thee

00:38:10,350 --> 00:38:14,880
but we must both be right speak slowly

00:38:12,390 --> 00:38:17,730
cuz he echoes all over the place oh okay

00:38:14,880 --> 00:38:21,690
um I'm just flattering you that's all um

00:38:17,730 --> 00:38:25,020
I wanted to mention a couple of

00:38:21,690 --> 00:38:27,450
additional resources for people who came

00:38:25,020 --> 00:38:31,410
out of this talk and said where's more

00:38:27,450 --> 00:38:33,000
good um in the book making software what

00:38:31,410 --> 00:38:35,730
really works and why we believe it

00:38:33,000 --> 00:38:39,210
edited by Greg Wilson who's here and

00:38:35,730 --> 00:38:41,940
Andy orem there's a chapter about API

00:38:39,210 --> 00:38:44,940
usability and there's a chapter about

00:38:41,940 --> 00:38:46,619
what different languages cause people to

00:38:44,940 --> 00:38:48,840
think when trying to do the same

00:38:46,619 --> 00:38:51,540
exercise what data structures they reach

00:38:48,840 --> 00:38:53,640
for and stuff like that because case

00:38:51,540 --> 00:38:56,490
studies that be fascinating exactly and

00:38:53,640 --> 00:39:00,480
um your design philosophy seems to

00:38:56,490 --> 00:39:03,720
accord with that proposed in restful Web

00:39:00,480 --> 00:39:07,410
API is the book my spouse wrote and how

00:39:03,720 --> 00:39:10,080
he made beautiful soup the witch you

00:39:07,410 --> 00:39:11,609
know I sort of watched him do so thank

00:39:10,080 --> 00:39:12,900
you very much i agree with all of your

00:39:11,609 --> 00:39:16,230
ideas thank you you're quite welcome

00:39:12,900 --> 00:39:18,180
thank you soo min that hi Eric thank you

00:39:16,230 --> 00:39:21,359
I just want to know what's the API for

00:39:18,180 --> 00:39:23,430
popping the poppable balloon what is the

00:39:21,359 --> 00:39:25,980
API for popping the balloon I suppose

00:39:23,430 --> 00:39:28,590
what have a pop method but it is in Java

00:39:25,980 --> 00:39:31,530
you construct a pin factory factory and

00:39:28,590 --> 00:39:33,200
then apply it to but but if it's a pop

00:39:31,530 --> 00:39:35,220
method than what you end up with a

00:39:33,200 --> 00:39:40,109
papabile balloon that you can't pop

00:39:35,220 --> 00:39:42,840
anymore yes that's representative all

00:39:40,109 --> 00:39:50,460
nonsense ah sorry the echo is really bad

00:39:42,840 --> 00:39:52,859
in here any others so you said if you

00:39:50,460 --> 00:39:53,790
have to mark so many dependencies you

00:39:52,859 --> 00:39:56,340
shouldn't

00:39:53,790 --> 00:39:57,810
have those dependencies what if you have

00:39:56,340 --> 00:39:58,770
to have those dependencies what if you

00:39:57,810 --> 00:40:00,720
have to have a whole bunch of

00:39:58,770 --> 00:40:05,010
dependencies do you still believe in

00:40:00,720 --> 00:40:07,350
walking or not well if you so this is a

00:40:05,010 --> 00:40:09,690
whole separate talk on testing if you

00:40:07,350 --> 00:40:12,360
have to mock a little then you have to

00:40:09,690 --> 00:40:13,710
mock a little sometimes you're limited

00:40:12,360 --> 00:40:15,660
by your framework and you can't refactor

00:40:13,710 --> 00:40:17,070
things how you want to there's also

00:40:15,660 --> 00:40:18,630
trade off to be made and testing between

00:40:17,070 --> 00:40:21,140
what's an integration test and what's a

00:40:18,630 --> 00:40:23,340
unit test in which do you value more

00:40:21,140 --> 00:40:25,410
myself if I'm not making something super

00:40:23,340 --> 00:40:27,600
complex where I need those tests to

00:40:25,410 --> 00:40:29,130
prove things to prove my way up I'll

00:40:27,600 --> 00:40:30,540
tend to reach for integration tests

00:40:29,130 --> 00:40:33,390
first just because they do test the

00:40:30,540 --> 00:40:34,980
whole system and even though they won't

00:40:33,390 --> 00:40:37,650
tell me specifically what went wrong if

00:40:34,980 --> 00:40:39,450
something breaks and integration tests

00:40:37,650 --> 00:40:42,450
are often more coupled than unit tests

00:40:39,450 --> 00:40:43,770
and useless mocking so you could bend

00:40:42,450 --> 00:40:45,810
that way if you wanted to just to avoid

00:40:43,770 --> 00:40:49,860
the mocking but mocking is not

00:40:45,810 --> 00:40:54,840
intrinsically evil it's a smell things

00:40:49,860 --> 00:40:58,500
change they mock so your mods could be

00:40:54,840 --> 00:41:00,810
old but yeah thank you your talk is very

00:40:58,500 --> 00:41:04,440
good thank you for coming get right up

00:41:00,810 --> 00:41:07,260
to the mic yeah so I am curious what you

00:41:04,440 --> 00:41:09,810
think from your lingual vs. math sort of

00:41:07,260 --> 00:41:13,290
dichotomy on how you name classes or

00:41:09,810 --> 00:41:16,140
model things as real-world ish versus

00:41:13,290 --> 00:41:21,210
sort of more compute abstract and sort

00:41:16,140 --> 00:41:22,950
of the truck versus car yes bade I like

00:41:21,210 --> 00:41:25,920
my code to read like it was English

00:41:22,950 --> 00:41:28,080
prose and something I've started doing

00:41:25,920 --> 00:41:31,320
lately is instead of naming my functions

00:41:28,080 --> 00:41:34,410
after verbs you know sort whatever I'll

00:41:31,320 --> 00:41:36,420
start naming them after nouns so you

00:41:34,410 --> 00:41:38,190
know sorted for example is a good

00:41:36,420 --> 00:41:39,750
example out of the standard library so

00:41:38,190 --> 00:41:41,700
then I can just kind of read across and

00:41:39,750 --> 00:41:45,690
say well this is the sort of thing of

00:41:41,700 --> 00:41:47,160
the red thing and the stacked thing the

00:41:45,690 --> 00:41:48,630
nice thing about that is it's consistent

00:41:47,160 --> 00:41:51,360
with the purpose of making functions and

00:41:48,630 --> 00:41:52,950
abstractions at all which is to hide the

00:41:51,360 --> 00:41:54,660
details I don't really care that it's

00:41:52,950 --> 00:41:56,580
doing a quick sort I just want it sorted

00:41:54,660 --> 00:41:59,850
the details might change later on right

00:41:56,580 --> 00:42:01,700
so you know as far as naming goes don't

00:41:59,850 --> 00:42:03,780
put anything in the name that isn't

00:42:01,700 --> 00:42:06,050
shouldn't be cared about at the call

00:42:03,780 --> 00:42:06,050
site

00:42:07,640 --> 00:42:13,080
um so I know there are a lot of other

00:42:10,860 --> 00:42:14,820
kind of really good API design

00:42:13,080 --> 00:42:16,410
principles that I guess fall a bit more

00:42:14,820 --> 00:42:20,070
on the technical side like no global

00:42:16,410 --> 00:42:21,030
state or or inject your dependencies and

00:42:20,070 --> 00:42:23,010
things like that do you think those

00:42:21,030 --> 00:42:23,820
necessarily follow from these principles

00:42:23,010 --> 00:42:25,530
or do you think they're kind of a

00:42:23,820 --> 00:42:27,000
separate set of principles well the no

00:42:25,530 --> 00:42:28,470
global state thing is a matter of

00:42:27,000 --> 00:42:29,640
decoupling if you have a global state

00:42:28,470 --> 00:42:31,890
everywhere everybody sharing it and are

00:42:29,640 --> 00:42:33,710
coupled at that point I'm pennis today

00:42:31,890 --> 00:42:36,650
what's your dependency injection one um

00:42:33,710 --> 00:42:39,960
dependency injection just the idea of

00:42:36,650 --> 00:42:41,760
castings in instead of sharing them

00:42:39,960 --> 00:42:43,710
behind the scene again at the decoupling

00:42:41,760 --> 00:42:46,500
again is local state exactly a

00:42:43,710 --> 00:42:48,140
decoupling has it's what you call it

00:42:46,500 --> 00:42:50,340
tendrils in a lot of different places

00:42:48,140 --> 00:42:52,500
you can see how it connects to so many

00:42:50,340 --> 00:42:58,950
different things cool grass by the way

00:42:52,500 --> 00:43:00,840
thank you give me my circles back um I

00:42:58,950 --> 00:43:03,600
thought your point about the elastic

00:43:00,840 --> 00:43:05,220
search api with the with deletion was

00:43:03,600 --> 00:43:08,100
especially interesting as if i recall

00:43:05,220 --> 00:43:10,380
correctly on the actual elasticsearch

00:43:08,100 --> 00:43:14,460
REST API does require you to explicitly

00:43:10,380 --> 00:43:17,220
say all doesn't it it didn't as of point

00:43:14,460 --> 00:43:18,480
nine d point something or other they

00:43:17,220 --> 00:43:20,340
might have fixed that one pointer that

00:43:18,480 --> 00:43:21,840
would be a breaking change that was a

00:43:20,340 --> 00:43:24,540
really good breaking change if they did

00:43:21,840 --> 00:43:28,170
it I i believe they they at least allow

00:43:24,540 --> 00:43:30,090
you to say all now um it do that with

00:43:28,170 --> 00:43:33,300
index as i know i found that a

00:43:30,090 --> 00:43:35,460
interesting example of how you can sort

00:43:33,300 --> 00:43:38,220
of hang yourself by when when

00:43:35,460 --> 00:43:41,880
translating between as it were different

00:43:38,220 --> 00:43:44,490
languages here on it looked like what

00:43:41,880 --> 00:43:46,770
happened was that an API that was safe

00:43:44,490 --> 00:43:48,300
on one side had become unsafe by

00:43:46,770 --> 00:43:51,060
applying in other languages principles

00:43:48,300 --> 00:43:53,130
to it oh really I mean in this case we

00:43:51,060 --> 00:43:54,990
wrapped it with a safer API because it

00:43:53,130 --> 00:43:57,210
was just too crazy version where ever

00:43:54,990 --> 00:44:01,500
you could simply provide a nun and have

00:43:57,210 --> 00:44:02,910
it delete everything yeah I'm not sure

00:44:01,500 --> 00:44:04,860
if the wrapping introduced that I mean

00:44:02,910 --> 00:44:06,960
the original REST API was like that if

00:44:04,860 --> 00:44:10,860
you type less you delete more kind of

00:44:06,960 --> 00:44:12,000
like the RM yeah star thing yes and now

00:44:10,860 --> 00:44:14,310
that I'm now that you mention it I do

00:44:12,000 --> 00:44:16,410
know that elasticsearch one point 0 has

00:44:14,310 --> 00:44:18,420
the same problem with indices if you say

00:44:16,410 --> 00:44:20,400
delete indexes and say nothing it'll

00:44:18,420 --> 00:44:20,880
delete them all oh really yeah it's bad

00:44:20,400 --> 00:44:22,890
news

00:44:20,880 --> 00:44:25,740
now there's a server setting you can set

00:44:22,890 --> 00:44:27,599
to not let that work which says it's the

00:44:25,740 --> 00:44:28,950
opposite of V of the question I was

00:44:27,599 --> 00:44:30,539
trying to ask of the perils of

00:44:28,950 --> 00:44:35,960
translation in this case translation

00:44:30,539 --> 00:44:37,920
adding safety yes at it when you can

00:44:35,960 --> 00:44:39,119
which brings up another interesting

00:44:37,920 --> 00:44:41,940
question actually your mention of

00:44:39,119 --> 00:44:43,559
breaking changes like do you think how

00:44:41,940 --> 00:44:46,259
do you think change management and api's

00:44:43,559 --> 00:44:48,779
fits into this framework is it like is

00:44:46,259 --> 00:44:50,549
it just is it mostly just a matter of

00:44:48,779 --> 00:44:51,900
like I mean I know there are some people

00:44:50,549 --> 00:44:54,599
who are advocating the philosophy of

00:44:51,900 --> 00:44:57,299
never break anything but then there are

00:44:54,599 --> 00:45:00,299
some people who are they I like to do

00:44:57,299 --> 00:45:03,299
that voice but um there but then but or

00:45:00,299 --> 00:45:05,279
is it a matter of you have to you have

00:45:03,299 --> 00:45:08,099
to balance whether it's a really big

00:45:05,279 --> 00:45:10,769
important change versus a just a minor

00:45:08,099 --> 00:45:12,390
thing that like so like say you realize

00:45:10,769 --> 00:45:14,880
later I have a better way to do

00:45:12,390 --> 00:45:17,160
something sure but it's not necessarily

00:45:14,880 --> 00:45:18,779
a dangerous thing like taking away like

00:45:17,160 --> 00:45:20,700
requiring a special delete all method

00:45:18,779 --> 00:45:21,960
it's just a better way to do it but a

00:45:20,700 --> 00:45:23,759
breaking change on the list started

00:45:21,960 --> 00:45:25,710
breaking change sure yeah compatibility

00:45:23,759 --> 00:45:27,230
is actually one of my skipped slides

00:45:25,710 --> 00:45:31,769
here they didn't quite make the cut and

00:45:27,230 --> 00:45:36,000
compatibility well my basic philosophy

00:45:31,769 --> 00:45:37,109
is use semantic versioning first of all

00:45:36,000 --> 00:45:40,349
if you're really going to change

00:45:37,109 --> 00:45:43,170
something compatibility is a place where

00:45:40,349 --> 00:45:46,500
I can be prevailed upon to actually bolt

00:45:43,170 --> 00:45:48,869
on an argument now if I've designed an

00:45:46,500 --> 00:45:51,079
API in a decoupled way like I was going

00:45:48,869 --> 00:45:53,970
to have this elastic search api that

00:45:51,079 --> 00:45:55,170
took a had a bulk index method but then

00:45:53,970 --> 00:45:56,759
instead of taking a whole bunch of

00:45:55,170 --> 00:45:58,589
different options i'd have a bunch of

00:45:56,759 --> 00:46:00,960
helper procedures which i could use to

00:45:58,589 --> 00:46:03,029
build a big data structure bulk you know

00:46:00,960 --> 00:46:05,819
many documents and pass that into bulk

00:46:03,029 --> 00:46:07,920
index those things i could then obsolete

00:46:05,819 --> 00:46:09,630
individually deprecated them and add new

00:46:07,920 --> 00:46:11,579
ones here use this one instead and pass

00:46:09,630 --> 00:46:14,069
it to bulk index without changing bulk

00:46:11,579 --> 00:46:15,690
indexes signature that's one way to do

00:46:14,069 --> 00:46:19,230
it through decoupling again everything

00:46:15,690 --> 00:46:21,000
is decoupling right the other thing is

00:46:19,230 --> 00:46:22,740
compatibility adds another dimension to

00:46:21,000 --> 00:46:24,630
this it puts us in four-dimensional

00:46:22,740 --> 00:46:27,960
space and so then you start thinking

00:46:24,630 --> 00:46:30,180
about coupling between time periods and

00:46:27,960 --> 00:46:32,809
that I haven't thought about but it

00:46:30,180 --> 00:46:32,809
would make a great talk

00:46:35,510 --> 00:46:41,210
so with the elastic search example how

00:46:38,640 --> 00:46:43,830
do you think about the trade off between

00:46:41,210 --> 00:46:46,800
kind of having a more transparent layer

00:46:43,830 --> 00:46:49,050
between the library and the thing you're

00:46:46,800 --> 00:46:51,390
communicating with versus building up

00:46:49,050 --> 00:46:53,550
kind of your own API that more matches

00:46:51,390 --> 00:46:55,410
the language or your idea of how it

00:46:53,550 --> 00:46:57,620
should work and then making a lot of

00:46:55,410 --> 00:47:00,360
translations between that and the

00:46:57,620 --> 00:47:02,550
service that you're talking to exactly

00:47:00,360 --> 00:47:06,050
let's see if i can't find this as fast

00:47:02,550 --> 00:47:08,700
as i thought i could well there is a

00:47:06,050 --> 00:47:13,940
there is what you say a very one-to-one

00:47:08,700 --> 00:47:16,860
API hiding inside pi elastic search and

00:47:13,940 --> 00:47:17,880
see send requests I guess I'm not gonna

00:47:16,860 --> 00:47:19,740
go get that into the correct monitor

00:47:17,880 --> 00:47:22,050
there's actually there is a thin API

00:47:19,740 --> 00:47:24,390
inside pile astok search the API that we

00:47:22,050 --> 00:47:26,970
then expose publicly active both public

00:47:24,390 --> 00:47:28,110
but the one we advocate is a little bit

00:47:26,970 --> 00:47:30,240
more of a layer gets rid of the

00:47:28,110 --> 00:47:33,930
dangerous things put some walls up and

00:47:30,240 --> 00:47:35,220
then on top of pie elasticsearch there

00:47:33,930 --> 00:47:38,370
are even friendlier libraries like

00:47:35,220 --> 00:47:40,140
elastic utils that let you do a kind of

00:47:38,370 --> 00:47:42,240
Django are I'm like things under under

00:47:40,140 --> 00:47:43,680
filter and that kind of thing I see so

00:47:42,240 --> 00:47:45,270
the way around it is actually to build

00:47:43,680 --> 00:47:47,070
more abstract exactly there's another

00:47:45,270 --> 00:47:48,900
skip slide that I enough time for called

00:47:47,070 --> 00:47:51,180
fractal pneus which I think an API

00:47:48,900 --> 00:47:52,890
should be usable at any level of

00:47:51,180 --> 00:47:54,480
abstraction you care for simple cases

00:47:52,890 --> 00:48:02,610
higher level but you can drill down as

00:47:54,480 --> 00:48:04,100
far as you care to sure thank you thanks

00:48:02,610 --> 00:48:06,160
for skipping lunch

00:48:04,100 --> 00:48:06,160

YouTube URL: https://www.youtube.com/watch?v=JQYnFyG7A8c


