Title: Benjamin Peterson: Garbage Collection in Python - PyCon 2014
Publication date: 2014-04-24
Playlist: PyCon 2014
Description: 
	Speaker: Benjamin Peterson

This talk will explore how garbage collection is implemented in CPython and PyPy. See how CPython deals reference counting's shortcomings with a special GC for cycle collection. Then dive into PyPy's sophisticated and high-performing GC implementations. The particularly thorny issue of finalizers in reference cycles will also be addressed.

Slides can be found at: https://speakerdeck.com/pycon2014 and https://github.com/PyCon/2014-slides
Captions: 
	00:00:00,000 --> 00:00:06,930
one it's 11:30 time to start the next

00:00:04,980 --> 00:00:09,240
talk I'd like to welcome Benjamin

00:00:06,930 --> 00:00:12,200
Peterson gonna tell us all about garbage

00:00:09,240 --> 00:00:12,200
collection and Python

00:00:16,609 --> 00:00:22,320
thank you guys I'm happy to be here

00:00:19,189 --> 00:00:24,090
we're in the big room today I always

00:00:22,320 --> 00:00:26,160
tried to read something into where the

00:00:24,090 --> 00:00:27,420
PyCon organizers put me and I assumed

00:00:26,160 --> 00:00:28,680
that they put me in the big room so they

00:00:27,420 --> 00:00:28,890
can Barriss me you wouldn't no one shows

00:00:28,680 --> 00:00:30,630
up

00:00:28,890 --> 00:00:34,649
but you guys are proving them wrong me

00:00:30,630 --> 00:00:37,140
them wrong thank you so what am I gonna

00:00:34,649 --> 00:00:39,239
cover in this talk well mainly I'd like

00:00:37,140 --> 00:00:42,090
to talk about how we actually implement

00:00:39,239 --> 00:00:44,670
garbage collection in two of the main

00:00:42,090 --> 00:00:48,000
Python implementations namely C Python

00:00:44,670 --> 00:00:51,059
and pi PI and in particular in the case

00:00:48,000 --> 00:00:54,239
of pi PI I'd like to address the issue

00:00:51,059 --> 00:00:57,739
of optimizations and what sort of

00:00:54,239 --> 00:01:00,329
patterns we see in Python which lead to

00:00:57,739 --> 00:01:02,550
the need for certain optimizations and

00:01:00,329 --> 00:01:03,989
what how pi PI does that and finally I'd

00:01:02,550 --> 00:01:07,920
like to spend a few minutes talking

00:01:03,989 --> 00:01:09,659
about various issues which within the

00:01:07,920 --> 00:01:11,610
intersection of language design and

00:01:09,659 --> 00:01:13,320
garbage collection where garbage

00:01:11,610 --> 00:01:14,939
collection that actually causes us to

00:01:13,320 --> 00:01:18,659
have to think about the semantics of

00:01:14,939 --> 00:01:20,880
Python and how we want to edit B okay so

00:01:18,659 --> 00:01:24,030
where I'll start with some implication

00:01:20,880 --> 00:01:25,860
basics and and as I said I'm only going

00:01:24,030 --> 00:01:27,930
to talk about pi PI and C Python and

00:01:25,860 --> 00:01:30,689
that's mostly because those are the only

00:01:27,930 --> 00:01:34,290
two which I have worked on and have

00:01:30,689 --> 00:01:36,060
knowledge on I I do not want to say

00:01:34,290 --> 00:01:39,390
anything bad about the ironpython

00:01:36,060 --> 00:01:41,729
or json GCS but they inherit them from

00:01:39,390 --> 00:01:43,590
their language implementations and not

00:01:41,729 --> 00:01:49,320
written specifically for python unlike

00:01:43,590 --> 00:01:50,579
the c python and pi PI so the most basic

00:01:49,320 --> 00:01:52,710
question we can ask is what do we mean

00:01:50,579 --> 00:01:55,229
by garbage collection in any language

00:01:52,710 --> 00:01:57,000
and more specifically Python well we

00:01:55,229 --> 00:01:59,909
usually think is that objects which are

00:01:57,000 --> 00:02:01,920
no longer reachable by our program will

00:01:59,909 --> 00:02:05,460
be de-allocated and the resources

00:02:01,920 --> 00:02:08,550
they're using cleaned up so new objects

00:02:05,460 --> 00:02:11,340
can take their place somewhat subtle

00:02:08,550 --> 00:02:13,349
question is when are we going to get our

00:02:11,340 --> 00:02:13,770
objects cleaned up and the Python

00:02:13,349 --> 00:02:15,300
language

00:02:13,770 --> 00:02:18,270
reference which is sort of the standard

00:02:15,300 --> 00:02:19,940
is very cagey about this it says objects

00:02:18,270 --> 00:02:22,080
will eventually be cleaned up or never

00:02:19,940 --> 00:02:24,030
so in theory you can make a Python

00:02:22,080 --> 00:02:26,670
implementation which just called exit at

00:02:24,030 --> 00:02:27,750
the end and the kernel cleaned up

00:02:26,670 --> 00:02:30,270
everything for you

00:02:27,750 --> 00:02:32,250
but that probably would not not not pass

00:02:30,270 --> 00:02:35,990
muster and what we'd really like is that

00:02:32,250 --> 00:02:39,860
objects are cleaned up at some point

00:02:35,990 --> 00:02:41,160
well before we run out of memory so

00:02:39,860 --> 00:02:44,780
cpython

00:02:41,160 --> 00:02:47,430
venerable old reference implementation

00:02:44,780 --> 00:02:51,180
probably the primary primary garbage

00:02:47,430 --> 00:02:53,820
collection is reference counting the

00:02:51,180 --> 00:02:55,860
idea is very simple basically be a lot

00:02:53,820 --> 00:02:59,220
alive the objects which are reachable in

00:02:55,860 --> 00:03:00,960
your program have a count which says how

00:02:59,220 --> 00:03:02,970
many people want them to still be alive

00:03:00,960 --> 00:03:05,550
as how many people are expecting to be

00:03:02,970 --> 00:03:08,280
able to use them other objects that is

00:03:05,550 --> 00:03:11,250
and so when you first create an object

00:03:08,280 --> 00:03:12,990
is one one piece of code or one other

00:03:11,250 --> 00:03:15,540
object will be reference it and so have

00:03:12,990 --> 00:03:17,550
a reference count of one and then that

00:03:15,540 --> 00:03:20,459
will go up and down as other parts of

00:03:17,550 --> 00:03:23,490
the program use it and finally when the

00:03:20,459 --> 00:03:25,500
object reaches the ref count of zero we

00:03:23,490 --> 00:03:28,280
know it can be safely de-allocated so

00:03:25,500 --> 00:03:31,110
here's my diagram with how that works

00:03:28,280 --> 00:03:34,740
and we're gonna imagine that these

00:03:31,110 --> 00:03:36,030
objects here are preexisting and during

00:03:34,740 --> 00:03:38,640
the course of the program will allocate

00:03:36,030 --> 00:03:41,160
another object called object C and since

00:03:38,640 --> 00:03:45,360
it's a new object it will have ref count

00:03:41,160 --> 00:03:47,610
of 1 and then say if object B now gets a

00:03:45,360 --> 00:03:50,070
reference to object C then the ref count

00:03:47,610 --> 00:03:53,850
at our UC will become 2 because it has

00:03:50,070 --> 00:03:56,790
two links in the graph here and then if

00:03:53,850 --> 00:04:01,140
if another object is allocated and

00:03:56,790 --> 00:04:04,110
handed two objects and object D gets a

00:04:01,140 --> 00:04:06,990
or object C gets a reference to the new

00:04:04,110 --> 00:04:09,570
object D then once again object you will

00:04:06,990 --> 00:04:13,560
have a ref get at one now what happens

00:04:09,570 --> 00:04:17,370
when object C is no longer accessible

00:04:13,560 --> 00:04:19,680
from the live program well the links are

00:04:17,370 --> 00:04:21,720
broken and so each time a link is broken

00:04:19,680 --> 00:04:24,300
the ref count is decremented by one and

00:04:21,720 --> 00:04:25,480
since there are no no longer any links

00:04:24,300 --> 00:04:28,060
here

00:04:25,480 --> 00:04:30,520
the ref count lucio and will realize

00:04:28,060 --> 00:04:32,710
that the object can be cleaned up and in

00:04:30,520 --> 00:04:35,110
the process of its cleanup it will

00:04:32,710 --> 00:04:37,570
remove all the references it has to

00:04:35,110 --> 00:04:39,430
object D and so object D will also

00:04:37,570 --> 00:04:42,880
become a dead object and they can be

00:04:39,430 --> 00:04:45,490
reclaimed so if you ever looked at the

00:04:42,880 --> 00:04:48,550
cpython source it's littered with these

00:04:45,490 --> 00:04:50,710
macros pi ink ref and pi deck ref so

00:04:48,550 --> 00:04:53,020
here's an example and these are the

00:04:50,710 --> 00:04:56,170
operations which actually do reference

00:04:53,020 --> 00:04:58,810
counting in C Python I put in a

00:04:56,170 --> 00:05:03,040
simplified example of how this works so

00:04:58,810 --> 00:05:05,410
this is the code which sets items in a

00:05:03,040 --> 00:05:06,940
list just a normal Python list so this

00:05:05,410 --> 00:05:08,920
is the list which you're setting in this

00:05:06,940 --> 00:05:10,420
is the index which your of the i/o

00:05:08,920 --> 00:05:13,270
you're setting and this is what you're

00:05:10,420 --> 00:05:15,940
actually Willie setting and so you see

00:05:13,270 --> 00:05:18,250
the way the list takes a reference to

00:05:15,940 --> 00:05:19,570
the V which is the object where you're

00:05:18,250 --> 00:05:22,450
putting into the list because the list

00:05:19,570 --> 00:05:24,580
is now going to own it it this is the

00:05:22,450 --> 00:05:27,550
code which actually puts the item at the

00:05:24,580 --> 00:05:29,500
index you expect and then finally it

00:05:27,550 --> 00:05:31,750
decrements the old value which was

00:05:29,500 --> 00:05:34,660
holding in that in that that index in

00:05:31,750 --> 00:05:36,610
the list so it could be cleaned up if

00:05:34,660 --> 00:05:39,100
because the list is no longer reference

00:05:36,610 --> 00:05:41,530
in one subtlety in this piece of code

00:05:39,100 --> 00:05:44,200
may notice is that we've very carefully

00:05:41,530 --> 00:05:46,510
put the new item in the list before we D

00:05:44,200 --> 00:05:48,480
allocate or decrement the ref count of

00:05:46,510 --> 00:05:52,300
the old value and that's because if you

00:05:48,480 --> 00:05:54,670
decremented the ref count of the old

00:05:52,300 --> 00:05:56,890
value before you had put the new item in

00:05:54,670 --> 00:05:59,770
the list it's possible that some Python

00:05:56,890 --> 00:06:01,750
code could run which would touch the

00:05:59,770 --> 00:06:06,600
list and would see an uninitialized

00:06:01,750 --> 00:06:10,390
value at that place index in the list

00:06:06,600 --> 00:06:13,540
okay so reference counting is an OL idea

00:06:10,390 --> 00:06:15,970
and it works pretty well is the main

00:06:13,540 --> 00:06:17,680
garbage collection in C Python but it

00:06:15,970 --> 00:06:20,380
has a major flaw which is that if you

00:06:17,680 --> 00:06:22,750
have references return cycles reference

00:06:20,380 --> 00:06:24,430
they will stay alive forever with pure

00:06:22,750 --> 00:06:27,130
reference counting and so what happens

00:06:24,430 --> 00:06:29,410
if going back to our example is that if

00:06:27,130 --> 00:06:30,970
you have an object here C and I have two

00:06:29,410 --> 00:06:32,770
here D and they both reference each

00:06:30,970 --> 00:06:35,620
other well the number of links going

00:06:32,770 --> 00:06:37,090
into object C are 2 and because there's

00:06:35,620 --> 00:06:38,320
one coming from B and one coming from

00:06:37,090 --> 00:06:40,510
the older objects

00:06:38,320 --> 00:06:42,460
and object D has a ref counts of one and

00:06:40,510 --> 00:06:44,230
even now if we drop the link from the

00:06:42,460 --> 00:06:47,650
pre-existing objects so it's no longer

00:06:44,230 --> 00:06:48,910
referenced in our program then both of

00:06:47,650 --> 00:06:52,780
these objects will still have a positive

00:06:48,910 --> 00:06:53,800
ref count because they still reference

00:06:52,780 --> 00:06:58,300
each other even if they're not

00:06:53,800 --> 00:07:00,520
accessible for the program so see python

00:06:58,300 --> 00:07:03,730
has a separate garbage cloud here called

00:07:00,520 --> 00:07:08,410
the cyclic GC which detects reference

00:07:03,730 --> 00:07:10,360
cycles and removes them and so unlike

00:07:08,410 --> 00:07:12,220
reference County where you immediately

00:07:10,360 --> 00:07:14,590
know once an object is unreachable that

00:07:12,220 --> 00:07:18,580
you could be allocated thus the cyclic

00:07:14,590 --> 00:07:20,860
GC runs every once in a while to detect

00:07:18,580 --> 00:07:22,360
and deallocate cycles and this is what

00:07:20,860 --> 00:07:26,500
you're actually invoking when you run GC

00:07:22,360 --> 00:07:29,920
collect on C Python and the operation of

00:07:26,500 --> 00:07:32,410
the cyclic GC is very simple basically

00:07:29,920 --> 00:07:34,900
it looks for all cycles in the program

00:07:32,410 --> 00:07:37,480
and then it decrements the internal

00:07:34,900 --> 00:07:39,970
references of the cycles so that's

00:07:37,480 --> 00:07:42,610
what's happened here if it's in during

00:07:39,970 --> 00:07:44,740
the cyclic garbage collection the the

00:07:42,610 --> 00:07:46,930
internal references in cycles are

00:07:44,740 --> 00:07:49,300
decremented and then if the objects in

00:07:46,930 --> 00:07:51,540
the cycles reached zero then you know

00:07:49,300 --> 00:07:54,880
that it's a cycle which is not reachable

00:07:51,540 --> 00:07:58,450
because the references were only due to

00:07:54,880 --> 00:08:01,360
internal cyclic ones so we're able to

00:07:58,450 --> 00:08:03,070
deallocate it ok now I'm going to switch

00:08:01,360 --> 00:08:04,450
to the what I consider the more

00:08:03,070 --> 00:08:09,550
interesting part of the talk which is pi

00:08:04,450 --> 00:08:13,960
PI so let me briefly review the basics

00:08:09,550 --> 00:08:16,180
of pi PI so pi PI is written in a

00:08:13,960 --> 00:08:19,450
restricted subset of Python called our

00:08:16,180 --> 00:08:21,220
Python and the our Python can be

00:08:19,450 --> 00:08:25,570
translated to a low-level language right

00:08:21,220 --> 00:08:28,750
now that's primarily C and since the

00:08:25,570 --> 00:08:31,420
interpreter is written in Python it's

00:08:28,750 --> 00:08:33,040
actually has garbage collection our

00:08:31,420 --> 00:08:36,010
Python is a garbage collected language

00:08:33,040 --> 00:08:38,289
so as the our Python is being lowered to

00:08:36,010 --> 00:08:40,599
see garbage collection has to be added

00:08:38,289 --> 00:08:43,690
and so what that means is that the

00:08:40,599 --> 00:08:46,330
interpreter is actually abstracted away

00:08:43,690 --> 00:08:48,940
from the garbage collection

00:08:46,330 --> 00:08:51,610
implementation unlike C Python which is

00:08:48,940 --> 00:08:54,470
littered with artifacts of ref counting

00:08:51,610 --> 00:08:57,440
so that means you can change the garbage

00:08:54,470 --> 00:08:59,360
collection implementation at translation

00:08:57,440 --> 00:09:05,120
time which is the lowering of our Python

00:08:59,360 --> 00:09:07,610
to see so as I said the pi PI GC is just

00:09:05,120 --> 00:09:11,960
another low-level transformation of the

00:09:07,610 --> 00:09:13,400
our Python object graph and the garbage

00:09:11,960 --> 00:09:16,010
collection invitation is actually

00:09:13,400 --> 00:09:17,210
written in our Python itself so it's you

00:09:16,010 --> 00:09:19,370
could you can go look at the source code

00:09:17,210 --> 00:09:23,270
it's it's it's very strange to see this

00:09:19,370 --> 00:09:25,250
is our Python code which is actually

00:09:23,270 --> 00:09:27,260
working with raw memory once it's

00:09:25,250 --> 00:09:28,910
translated to see and also means it can

00:09:27,260 --> 00:09:30,980
be tested in Python you can run it on

00:09:28,910 --> 00:09:32,630
the Python interpreter and you'll get

00:09:30,980 --> 00:09:35,390
normal exceptions when it's not

00:09:32,630 --> 00:09:38,000
translated to C and so there have been

00:09:35,390 --> 00:09:39,860
quite a lot of pi PI garbage collection

00:09:38,000 --> 00:09:42,650
implementations over the years the

00:09:39,860 --> 00:09:46,970
current one is called mini mark and it's

00:09:42,650 --> 00:09:49,850
what I'll be discussing the basics of so

00:09:46,970 --> 00:09:52,040
pi pi does not use reference counting by

00:09:49,850 --> 00:09:55,250
default and so it uses a more

00:09:52,040 --> 00:09:56,270
traditional garbage collections scheme I

00:09:55,250 --> 00:09:59,300
guess you could say called

00:09:56,270 --> 00:10:02,810
mark-and-sweep but the idea is also very

00:09:59,300 --> 00:10:04,940
simple basically you start with objects

00:10:02,810 --> 00:10:07,820
which you know are alive in the garbage

00:10:04,940 --> 00:10:11,750
collection phase and then you walk their

00:10:07,820 --> 00:10:13,310
references all the way out and then you

00:10:11,750 --> 00:10:16,310
and while you're doing that you

00:10:13,310 --> 00:10:18,050
carefully mark them to say oh I know

00:10:16,310 --> 00:10:19,250
this object is alive and then after

00:10:18,050 --> 00:10:21,440
doing that you move to something called

00:10:19,250 --> 00:10:22,760
the sweet phase where you walk all the

00:10:21,440 --> 00:10:24,350
objects which you know about in the

00:10:22,760 --> 00:10:26,630
program and if they're not marked you

00:10:24,350 --> 00:10:27,740
know that can be dowdy allocated and so

00:10:26,630 --> 00:10:30,260
this has no problem with reference

00:10:27,740 --> 00:10:32,570
cycles because there's no reference

00:10:30,260 --> 00:10:36,340
counting and you will just see the cycle

00:10:32,570 --> 00:10:39,140
as not reachable so here's the

00:10:36,340 --> 00:10:41,510
visualization of this so again we have

00:10:39,140 --> 00:10:43,160
our newly allocated objects here and

00:10:41,510 --> 00:10:44,540
we're now we're in the marking phase who

00:10:43,160 --> 00:10:47,240
are assuming that we know these objects

00:10:44,540 --> 00:10:49,060
are alive object a and B and the garbage

00:10:47,240 --> 00:10:51,890
collector will traverse these links

00:10:49,060 --> 00:10:54,890
it'll see object C it will mark

00:10:51,890 --> 00:10:56,800
obviously who knows it's alive and then

00:10:54,890 --> 00:10:59,630
in the next phase of garbage collection

00:10:56,800 --> 00:11:02,120
sweeping it will walk all these objects

00:10:59,630 --> 00:11:03,810
will see object a B and C are marked so

00:11:02,120 --> 00:11:07,320
we they are alive

00:11:03,810 --> 00:11:11,760
but object D is not marked so we know it

00:11:07,320 --> 00:11:15,570
can be Dalit de-allocated so what's

00:11:11,760 --> 00:11:19,440
really interesting is how we can use

00:11:15,570 --> 00:11:22,410
parts of what things observations of

00:11:19,440 --> 00:11:24,060
Python language usage patterns to

00:11:22,410 --> 00:11:27,210
optimize garbage collector

00:11:24,060 --> 00:11:31,020
implementation so one of the primary

00:11:27,210 --> 00:11:33,390
observations of Python and indeed most

00:11:31,020 --> 00:11:35,790
dynamic languages is that you are often

00:11:33,390 --> 00:11:37,170
allocating lots of objects which are

00:11:35,790 --> 00:11:40,350
soon thrown away so I've put a few

00:11:37,170 --> 00:11:42,120
examples up here so traditionally you'll

00:11:40,350 --> 00:11:43,860
be allocating a lots of intermediate

00:11:42,120 --> 00:11:46,380
float objects in this simple average

00:11:43,860 --> 00:11:49,110
which will be thrown away before they're

00:11:46,380 --> 00:11:51,480
stored in a variable and for example if

00:11:49,110 --> 00:11:52,920
you have a every time you iterate over

00:11:51,480 --> 00:11:54,540
something in Python you iterate an

00:11:52,920 --> 00:11:55,980
iterator object it's very it's very

00:11:54,540 --> 00:12:00,720
transparent but you do actually have to

00:11:55,980 --> 00:12:02,460
allocate it internally and any time you

00:12:00,720 --> 00:12:04,440
call an object on a method you have to

00:12:02,460 --> 00:12:07,770
allocate a bound method which actually

00:12:04,440 --> 00:12:09,750
binds the self object to the method so

00:12:07,770 --> 00:12:13,110
you don't have to pass self and then

00:12:09,750 --> 00:12:15,930
another common pattern in Python is long

00:12:13,110 --> 00:12:18,089
strings of replacements so like this

00:12:15,930 --> 00:12:21,180
this is some code which I found in Jinja

00:12:18,089 --> 00:12:22,500
to do HTML escaping and so each one of

00:12:21,180 --> 00:12:23,790
these things creates an intermediate

00:12:22,500 --> 00:12:26,339
string object which is then immediately

00:12:23,790 --> 00:12:30,270
not used after it you move to the next

00:12:26,339 --> 00:12:31,800
replace call and so in the GC garbage

00:12:30,270 --> 00:12:34,170
collection community this goes by the

00:12:31,800 --> 00:12:41,490
rather macabre title high infant

00:12:34,170 --> 00:12:43,620
mortality basically expressing the idea

00:12:41,490 --> 00:12:48,450
that you have many young objects which

00:12:43,620 --> 00:12:51,150
do not live very long so continuing the

00:12:48,450 --> 00:12:55,070
dark metaphor we the optimization we use

00:12:51,150 --> 00:12:59,130
to help with this is called the nursery

00:12:55,070 --> 00:13:01,410
and so the idea in the nursery is that

00:12:59,130 --> 00:13:03,560
you whenever you allocate a new object

00:13:01,410 --> 00:13:06,360
you put in this small little buffer and

00:13:03,560 --> 00:13:09,060
then you just garbage collect the

00:13:06,360 --> 00:13:11,780
nursery very often much more than you

00:13:09,060 --> 00:13:14,550
collect the entire object graph and so

00:13:11,780 --> 00:13:16,320
once and if an object survives a nursery

00:13:14,550 --> 00:13:16,880
collection then you move it into an

00:13:16,320 --> 00:13:18,380
older

00:13:16,880 --> 00:13:20,210
generation which is not garbage

00:13:18,380 --> 00:13:23,510
collected so much under the assumption

00:13:20,210 --> 00:13:24,950
that it will live longer than the things

00:13:23,510 --> 00:13:27,680
which are garbage collected in the

00:13:24,950 --> 00:13:29,870
nursery and so this seems pretty simple

00:13:27,680 --> 00:13:31,940
but there's one settle point is that is

00:13:29,870 --> 00:13:34,730
you actually have to be moving objects

00:13:31,940 --> 00:13:38,120
around in memory to implement this and

00:13:34,730 --> 00:13:40,760
so what that means is that pi pi has GC

00:13:38,120 --> 00:13:42,760
has the ability to move objects that is

00:13:40,760 --> 00:13:46,790
copy them to different parts of the RAM

00:13:42,760 --> 00:13:49,580
while also updating the internal

00:13:46,790 --> 00:13:51,890
pointers to which other objects might

00:13:49,580 --> 00:13:55,190
have to that new object and so that's

00:13:51,890 --> 00:13:57,320
very very much so cases of flexibility

00:13:55,190 --> 00:14:00,530
of the pi PI model because when we have

00:13:57,320 --> 00:14:02,510
the entire interpreter being translated

00:14:00,530 --> 00:14:04,370
see we can see which objects will have

00:14:02,510 --> 00:14:06,340
internal references to other objects so

00:14:04,370 --> 00:14:10,430
the garbage collector can perfectly

00:14:06,340 --> 00:14:12,530
update internal references another thing

00:14:10,430 --> 00:14:16,220
which PI pi tries to address is GC

00:14:12,530 --> 00:14:18,950
pauses so basically in a traditional

00:14:16,220 --> 00:14:20,330
garbage collector and cpython cyclic

00:14:18,950 --> 00:14:22,610
garsh when the garbage collector is

00:14:20,330 --> 00:14:24,350
running your program is not running it

00:14:22,610 --> 00:14:26,990
just stops the program so it can safely

00:14:24,350 --> 00:14:28,460
walk to the object graph and so

00:14:26,990 --> 00:14:32,120
sometimes people will have massive

00:14:28,460 --> 00:14:34,760
servers with a lot of objects allocated

00:14:32,120 --> 00:14:38,180
and the GC will stop their program for

00:14:34,760 --> 00:14:40,190
like half a second which is bad and but

00:14:38,180 --> 00:14:41,420
this becomes especially prevalent if

00:14:40,190 --> 00:14:43,370
you're trying to do real tile things

00:14:41,420 --> 00:14:45,080
like video processing of course no one

00:14:43,370 --> 00:14:46,640
tried to do video processing with Python

00:14:45,080 --> 00:14:48,950
before pi pi came along and made it

00:14:46,640 --> 00:14:50,960
actually reasonable to do that sort of

00:14:48,950 --> 00:14:56,030
computational stuff with is just-in-time

00:14:50,960 --> 00:14:58,070
compiler but now it's actually become a

00:14:56,030 --> 00:15:01,850
possibility and so GC pauses to become

00:14:58,070 --> 00:15:05,440
more of a problem so pi pi has something

00:15:01,850 --> 00:15:08,990
called an incremental garbage collector

00:15:05,440 --> 00:15:13,400
and what that means is that instead of

00:15:08,990 --> 00:15:15,560
doing the whole Marc suite process in in

00:15:13,400 --> 00:15:18,530
one go stopping the program completely

00:15:15,560 --> 00:15:20,390
it can do a Marcus well it can do a

00:15:18,530 --> 00:15:22,790
small part of the marking process and

00:15:20,390 --> 00:15:24,170
then let the program run some more and

00:15:22,790 --> 00:15:26,720
then doing the next part of the marking

00:15:24,170 --> 00:15:29,970
process and as you can imagine that's

00:15:26,720 --> 00:15:34,079
not terribly simple to do because

00:15:29,970 --> 00:15:35,730
you it's easier when you assume that the

00:15:34,079 --> 00:15:39,180
program is being stopped and you won't

00:15:35,730 --> 00:15:41,610
be mutating other objects but according

00:15:39,180 --> 00:15:43,529
to the pipe I blog post where Armin and

00:15:41,610 --> 00:15:47,629
magic implemented this it was actually

00:15:43,529 --> 00:15:51,360
relatively painless to do so go Python

00:15:47,629 --> 00:15:53,100
and so this means that you can break

00:15:51,360 --> 00:15:54,629
down the garbage collection time it's

00:15:53,100 --> 00:15:58,350
just a few milliseconds which shouldn't

00:15:54,629 --> 00:16:03,660
be noticeable in real time processing

00:15:58,350 --> 00:16:06,569
kind of applications so in summary the

00:16:03,660 --> 00:16:08,339
attributes if someone asks you what is

00:16:06,569 --> 00:16:10,079
great about the pipe igc you should tell

00:16:08,339 --> 00:16:13,860
them well you can choose what kind of

00:16:10,079 --> 00:16:17,459
garbage collector you want and it also

00:16:13,860 --> 00:16:21,000
has a nursery generate a generational

00:16:17,459 --> 00:16:22,649
garbage collector is one which has the

00:16:21,000 --> 00:16:25,410
objects in different categories based on

00:16:22,649 --> 00:16:27,930
how long they've been alive you can say

00:16:25,410 --> 00:16:32,089
it's incremental and it's also

00:16:27,930 --> 00:16:32,089
integrated with the gist Nick I'm Pilar

00:16:32,959 --> 00:16:38,850
so the last few minutes I'd like to

00:16:36,000 --> 00:16:42,170
spend talking about some subtleties of

00:16:38,850 --> 00:16:44,939
garbage collection semantics

00:16:42,170 --> 00:16:50,250
specifically I'd like to talk about

00:16:44,939 --> 00:16:53,100
under under del which I think anybody

00:16:50,250 --> 00:16:56,189
who's been in Python for a little while

00:16:53,100 --> 00:16:59,490
will have bad experiences with del and

00:16:56,189 --> 00:17:02,160
so the main problem with with under

00:16:59,490 --> 00:17:04,860
under del is that when objects are

00:17:02,160 --> 00:17:06,780
de-allocated it can be a fairly

00:17:04,860 --> 00:17:09,870
arbitrary point in your in the program

00:17:06,780 --> 00:17:11,730
and so if you start running our baterry

00:17:09,870 --> 00:17:13,589
Python code in an arbitrary probably any

00:17:11,730 --> 00:17:16,650
program stuff might not be initialized

00:17:13,589 --> 00:17:20,900
or you might be in some weird part and

00:17:16,650 --> 00:17:25,100
shutdown so that's one part of the

00:17:20,900 --> 00:17:28,289
unsafe napot is that if you have

00:17:25,100 --> 00:17:30,360
finalize errs which are in a cycle then

00:17:28,289 --> 00:17:34,919
it's hard to know which one to

00:17:30,360 --> 00:17:37,169
deallocate first because the final so in

00:17:34,919 --> 00:17:40,289
this example the finalizer an object c

00:17:37,169 --> 00:17:42,660
could the object c has a reference to

00:17:40,289 --> 00:17:45,780
object d so it could try to

00:17:42,660 --> 00:17:49,320
fetch attributes of object D or call a

00:17:45,780 --> 00:17:51,360
method on it and the same thing is true

00:17:49,320 --> 00:17:53,850
of object D and so you don't know which

00:17:51,360 --> 00:17:55,470
one is safe to call first because they

00:17:53,850 --> 00:17:59,150
might be trying to use the attributes of

00:17:55,470 --> 00:18:04,980
each other so it's it's a tangled web

00:17:59,150 --> 00:18:07,500
and so the the solution to this in C

00:18:04,980 --> 00:18:10,160
Python for a long time has been to just

00:18:07,500 --> 00:18:12,900
not not run finalized errs which are in

00:18:10,160 --> 00:18:16,169
which are in cycles and what actually

00:18:12,900 --> 00:18:18,240
means is that objects cycles which were

00:18:16,169 --> 00:18:20,340
which contained fine liars we get moved

00:18:18,240 --> 00:18:22,559
to this list in the garbage collection

00:18:20,340 --> 00:18:25,260
module called GC garbage and so it would

00:18:22,559 --> 00:18:26,820
essentially leak them and in theory you

00:18:25,260 --> 00:18:28,860
could like sift through this list and

00:18:26,820 --> 00:18:30,120
deallocate them safely but a lot of

00:18:28,860 --> 00:18:32,130
people didn't know this so if they

00:18:30,120 --> 00:18:44,070
suddenly had finalized errs and cycles

00:18:32,130 --> 00:18:46,440
then they would essentially be lost but

00:18:44,070 --> 00:18:49,650
this problem has been addressed in C

00:18:46,440 --> 00:18:52,080
Python 3.4 with something called pet 442

00:18:49,650 --> 00:18:54,120
I'll talk about it in a second and pi PI

00:18:52,080 --> 00:18:56,640
has always tried to run the final Liars

00:18:54,120 --> 00:18:59,010
in a reasonable order and reasonable in

00:18:56,640 --> 00:19:01,320
this case means you do roughly do a

00:18:59,010 --> 00:19:03,570
topological sort of the object graph and

00:19:01,320 --> 00:19:06,600
so you try it you try to run the ones

00:19:03,570 --> 00:19:08,490
which have the least dependencies first

00:19:06,600 --> 00:19:10,409
but at the end you pretty much just have

00:19:08,490 --> 00:19:11,730
to pick an arbitrary finalizer to run it

00:19:10,409 --> 00:19:15,200
because the garbage collector does not

00:19:11,730 --> 00:19:19,100
know which one is safe to run so

00:19:15,200 --> 00:19:23,130
specifically in come on

00:19:19,100 --> 00:19:26,070
ok specifically in pet 442 in C Python

00:19:23,130 --> 00:19:31,049
this is the work of a C Python developer

00:19:26,070 --> 00:19:32,909
named Antwon Petro it proposed slightly

00:19:31,049 --> 00:19:36,539
modifying the cyclic garbage collector

00:19:32,909 --> 00:19:40,080
in C Python and the way it works now is

00:19:36,539 --> 00:19:46,640
that you detect all the cycles in the

00:19:40,080 --> 00:19:49,530
program and then you

00:19:46,640 --> 00:19:51,660
you run finalized errs on them and then

00:19:49,530 --> 00:19:52,920
you see if the finalized errs resurrect

00:19:51,660 --> 00:19:54,330
the objects because that's also

00:19:52,920 --> 00:20:00,120
something you can do in a finalizar

00:19:54,330 --> 00:20:03,180
and then if the the objects continue to

00:20:00,120 --> 00:20:06,420
be dead and do not add themselves to the

00:20:03,180 --> 00:20:09,990
alive part of the program then you can

00:20:06,420 --> 00:20:11,490
safely clear them so this allows cycles

00:20:09,990 --> 00:20:13,350
with finalized errs to finally be

00:20:11,490 --> 00:20:15,840
allocated and removed in an annoying

00:20:13,350 --> 00:20:21,240
source of quasi tweaks in cpython

00:20:15,840 --> 00:20:24,600
programs okay so coming coming to the

00:20:21,240 --> 00:20:25,620
end of my talk let me remind you of what

00:20:24,600 --> 00:20:28,110
what's something which I'd like to

00:20:25,620 --> 00:20:31,800
across is that the garbage collection

00:20:28,110 --> 00:20:34,800
can be very subtle and difficult topic

00:20:31,800 --> 00:20:38,100
but also garbage collectors are awesome

00:20:34,800 --> 00:20:41,940
and especially pipe eyes so she used

00:20:38,100 --> 00:20:45,990
pipe I'm and with that I will conclude

00:20:41,940 --> 00:20:48,170
my talk and if anyone would like to line

00:20:45,990 --> 00:20:52,550
up for questions let me point you to

00:20:48,170 --> 00:20:54,900
some other sources of information I've

00:20:52,550 --> 00:20:57,900
there's this is a big topic and I have

00:20:54,900 --> 00:20:59,250
not covered all the many things which

00:20:57,900 --> 00:21:00,810
are interesting to talk about for

00:20:59,250 --> 00:21:03,990
example I did not talk about weak refs

00:21:00,810 --> 00:21:05,690
weak references at all and you can

00:21:03,990 --> 00:21:10,020
always look at the Wikipedia article

00:21:05,690 --> 00:21:14,780
and/or the source is always the

00:21:10,020 --> 00:21:14,780
authoritative source of truth all right

00:21:23,030 --> 00:21:29,700
okay okay so you've got your nursery and

00:21:27,450 --> 00:21:31,890
your nursery has all the fresh objects

00:21:29,700 --> 00:21:33,360
that you're making and you're keeping

00:21:31,890 --> 00:21:36,690
track of all the pointers you're making

00:21:33,360 --> 00:21:39,870
into that nursery is there an explicit

00:21:36,690 --> 00:21:41,790
way to say make a new nursery and if

00:21:39,870 --> 00:21:44,730
you're halfway through then go actually

00:21:41,790 --> 00:21:46,410
you know what discard this nursery ie

00:21:44,730 --> 00:21:50,730
software transactional memory is anyone

00:21:46,410 --> 00:21:52,530
been looking into that so there's not a

00:21:50,730 --> 00:21:56,910
way to control this with a Python

00:21:52,530 --> 00:21:58,680
program I I'm not quite sure with how

00:21:56,910 --> 00:22:02,100
garbage collection works in the software

00:21:58,680 --> 00:22:03,870
transactional memory it's I I I've not

00:22:02,100 --> 00:22:06,660
been working on that so you'd have to

00:22:03,870 --> 00:22:08,370
ask Arman who's been working on that but

00:22:06,660 --> 00:22:10,230
I do know that the garbage collector has

00:22:08,370 --> 00:22:12,030
very deep integration with a software

00:22:10,230 --> 00:22:19,140
transactional memory implication in

00:22:12,030 --> 00:22:20,850
pipeline hey thanks for the talk one of

00:22:19,140 --> 00:22:23,190
the things that I've noticed is most of

00:22:20,850 --> 00:22:25,080
the like more recent developments and

00:22:23,190 --> 00:22:26,400
garbage collection all assumed that the

00:22:25,080 --> 00:22:28,260
garbage collection process is

00:22:26,400 --> 00:22:30,480
asynchronous so it happened that some

00:22:28,260 --> 00:22:34,980
arbitrary point in time after the object

00:22:30,480 --> 00:22:36,870
becomes collectible is there any like an

00:22:34,980 --> 00:22:39,270
ax pluggable part of pi PI is there any

00:22:36,870 --> 00:22:40,500
way to implement a garbage collector

00:22:39,270 --> 00:22:43,080
that would have like a more synchronous

00:22:40,500 --> 00:22:44,700
behavior that's closer to like the

00:22:43,080 --> 00:22:48,750
reference counts has reached zero clean

00:22:44,700 --> 00:22:50,850
it up now yeah so pi pi has actually had

00:22:48,750 --> 00:22:53,190
a reference counting garbage collection

00:22:50,850 --> 00:22:55,980
implementation just to show that you

00:22:53,190 --> 00:22:58,530
could do it it was pretty inefficient so

00:22:55,980 --> 00:23:03,210
it's certainly possible to do but I

00:22:58,530 --> 00:23:04,980
think the the common the common feeling

00:23:03,210 --> 00:23:08,370
among most garbage collection

00:23:04,980 --> 00:23:11,460
researchers is that asynchronous garbage

00:23:08,370 --> 00:23:15,360
collectors allow for a lot more power

00:23:11,460 --> 00:23:17,130
and flexibility in optimizing them so

00:23:15,360 --> 00:23:19,890
it's it's certainly possible in PI PI's

00:23:17,130 --> 00:23:22,850
model but I don't it's probably not

00:23:19,890 --> 00:23:22,850
something you would actually want to use

00:23:23,030 --> 00:23:29,040
hi thanks for the talk

00:23:25,350 --> 00:23:31,590
I was just wondering the pi PI nursery

00:23:29,040 --> 00:23:32,160
sounds like the exact same thing as the

00:23:31,590 --> 00:23:34,640
java

00:23:32,160 --> 00:23:36,950
eden space is there some notable

00:23:34,640 --> 00:23:38,870
difference that I'm missing I know that

00:23:36,950 --> 00:23:42,530
I think they're very soon I mean they

00:23:38,870 --> 00:23:44,330
differ in small details but a lot of

00:23:42,530 --> 00:23:45,710
this stuff was I mean a lot of

00:23:44,330 --> 00:23:47,210
everything which we've been implementing

00:23:45,710 --> 00:23:50,780
and dynamic languages now is like in

00:23:47,210 --> 00:23:52,670
scheming turbos in the 80s so we're just

00:23:50,780 --> 00:23:55,430
deploying I mean and this also shares a

00:23:52,670 --> 00:23:58,250
lot of stuff with modern JavaScript

00:23:55,430 --> 00:24:00,500
garbage collectors like v8 and spider

00:23:58,250 --> 00:24:02,120
monkey also do this kind of so it's it's

00:24:00,500 --> 00:24:03,920
very as I was saying it's a very common

00:24:02,120 --> 00:24:06,800
idea in the implication of dynamic

00:24:03,920 --> 00:24:09,050
languages okay and then also I was

00:24:06,800 --> 00:24:12,650
taking some notes I'm gonna miss this is

00:24:09,050 --> 00:24:14,810
there to survival spaces like what the

00:24:12,650 --> 00:24:17,120
Java garbage collector has for young

00:24:14,810 --> 00:24:19,790
generation stuff or do I do something

00:24:17,120 --> 00:24:23,540
else so in the in the current

00:24:19,790 --> 00:24:24,770
implementation there's they're sort of -

00:24:23,540 --> 00:24:29,750
there's the nursery and then there's a

00:24:24,770 --> 00:24:30,980
ten-year generation but there's and one

00:24:29,750 --> 00:24:33,620
of the other garbage collectors you can

00:24:30,980 --> 00:24:35,810
have more generations in fact in the

00:24:33,620 --> 00:24:43,190
cpython cyclic garbage collector has

00:24:35,810 --> 00:24:48,490
three generations I think now okay hey

00:24:43,190 --> 00:24:52,670
so building on the the previous question

00:24:48,490 --> 00:24:55,010
there are a lot of languages in the

00:24:52,670 --> 00:24:58,370
bigger family tree that Python belongs

00:24:55,010 --> 00:25:01,280
to all the way from small talks various

00:24:58,370 --> 00:25:03,920
incarnations to self and E as well as

00:25:01,280 --> 00:25:06,890
JavaScript and I was wondering if there

00:25:03,920 --> 00:25:09,110
are amongst the many different generator

00:25:06,890 --> 00:25:12,290
not generated sorry the many different

00:25:09,110 --> 00:25:14,690
GCS that pi PI has if there are any new

00:25:12,290 --> 00:25:16,250
research directions for object based

00:25:14,690 --> 00:25:23,680
languages that you have been exploring

00:25:16,250 --> 00:25:23,680
that nobody else has hit upon yet um

00:25:24,100 --> 00:25:28,940
let's see it I have to admit something

00:25:27,500 --> 00:25:30,530
which is it's been it's been a while

00:25:28,940 --> 00:25:32,600
since I've worked intensely on the PI

00:25:30,530 --> 00:25:35,690
garbage collector so you you might have

00:25:32,600 --> 00:25:38,720
to ask Arman or there's another guy

00:25:35,690 --> 00:25:40,910
named Carl Friedrich Bowles about about

00:25:38,720 --> 00:25:42,050
that I I can't think of anything off the

00:25:40,910 --> 00:25:45,360
top my head sorry

00:25:42,050 --> 00:25:49,679
I always thank you very much

00:25:45,360 --> 00:25:50,670
I for both cpython and Popeye how do the

00:25:49,679 --> 00:25:55,530
garbage collectors deal with a

00:25:50,670 --> 00:25:57,420
fragmentation ah yes so another cpython

00:25:55,530 --> 00:26:01,559
once he allocate an object is there

00:25:57,420 --> 00:26:04,640
forever so it it's it's pretty much a

00:26:01,559 --> 00:26:08,880
function of how good your your heap

00:26:04,640 --> 00:26:11,010
allocator is your your underlying memory

00:26:08,880 --> 00:26:12,900
allocator well it kind of actually

00:26:11,010 --> 00:26:17,730
depends on the platform so see python

00:26:12,900 --> 00:26:22,320
has its own memory allocation sort of

00:26:17,730 --> 00:26:24,179
saying called ab malloc which in theory

00:26:22,320 --> 00:26:27,299
should reduce the fragmentation and be

00:26:24,179 --> 00:26:28,919
faster for python programs but you're

00:26:27,299 --> 00:26:30,480
kind of you're kind of stuck where you

00:26:28,919 --> 00:26:31,530
put the object and you can write

00:26:30,480 --> 00:26:35,160
programs which cause a lot of

00:26:31,530 --> 00:26:37,080
fragmentation in pi PI since you can

00:26:35,160 --> 00:26:38,669
move the objects around one of the

00:26:37,080 --> 00:26:39,960
things you can do is kind of compact all

00:26:38,669 --> 00:26:42,980
the objects into one part of the memory

00:26:39,960 --> 00:26:46,710
too in order to reduce fragmentation so

00:26:42,980 --> 00:26:49,040
pi PI can certainly address that cool

00:26:46,710 --> 00:26:49,040
thanks

00:26:49,549 --> 00:26:53,000

YouTube URL: https://www.youtube.com/watch?v=iHVs_HkjdmI


