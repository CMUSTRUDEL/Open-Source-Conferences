Title: So you want to write an interpreter?
Publication date: 2013-03-20
Playlist: PyCon 2013
Description: 
	Alex Gaynor
You're a programmer, you use interpreter and compilers every day (and twice on Sundays!). But how do these things work? Could you build one yourself? What would it take? Where would you start? This talk takes you through the process, from
Captions: 
	00:00:01,520 --> 00:00:06,000
welcome everyone I'd like to please help

00:00:04,470 --> 00:00:14,580
me welcome Alex Gaynor it's going to

00:00:06,000 --> 00:00:15,990
talk about writing an interpreter so hi

00:00:14,580 --> 00:00:19,170
everyone thank you guys so much for

00:00:15,990 --> 00:00:21,990
coming out so we're here to talk about

00:00:19,170 --> 00:00:23,490
how to write interpreter and this is

00:00:21,990 --> 00:00:26,189
going to go pretty quickly writing

00:00:23,490 --> 00:00:27,449
interpreter is a big topic if you study

00:00:26,189 --> 00:00:29,970
this in university you might have spent

00:00:27,449 --> 00:00:31,349
a whole semester on it so we're trying

00:00:29,970 --> 00:00:33,329
to cover a lot of the basics level

00:00:31,349 --> 00:00:34,920
concepts you need to understand and get

00:00:33,329 --> 00:00:36,870
to the place where hopefully after this

00:00:34,920 --> 00:00:38,129
talk you'll be really excited and you'll

00:00:36,870 --> 00:00:41,250
be ready to go forward and write your

00:00:38,129 --> 00:00:42,600
own and learn some more so don't worry

00:00:41,250 --> 00:00:45,149
about copying every single thing on

00:00:42,600 --> 00:00:47,610
every slide down so first one thank my

00:00:45,149 --> 00:00:49,890
employer are do we screaming Internet

00:00:47,610 --> 00:00:51,480
music we're hiring you should come talk

00:00:49,890 --> 00:00:55,289
to us thank you very much for having me

00:00:51,480 --> 00:00:57,539
here so Who am I I been around Python

00:00:55,289 --> 00:00:59,730
for a while I work on pi PI and C Python

00:00:57,539 --> 00:01:01,440
both interpreters which is kind of where

00:00:59,730 --> 00:01:03,660
I got my love of this I also work on

00:01:01,440 --> 00:01:06,840
Django so in a sort of former present

00:01:03,660 --> 00:01:08,909
life I was a web developer and recently

00:01:06,840 --> 00:01:11,790
I created topaz which is a Ruby

00:01:08,909 --> 00:01:13,770
interpreter written in Python so really

00:01:11,790 --> 00:01:15,299
love this whole interpreter thing so

00:01:13,770 --> 00:01:17,100
sort of started one tell you guys a

00:01:15,299 --> 00:01:18,390
story a lot of people ask me how I got

00:01:17,100 --> 00:01:20,729
involved in writing interpreters

00:01:18,390 --> 00:01:22,950
compilers it's kind of an obscure branch

00:01:20,729 --> 00:01:24,930
of programming not a lot of people are

00:01:22,950 --> 00:01:29,070
involvement they think of it as a black

00:01:24,930 --> 00:01:31,439
art so four years ago at a PyCon in 2009

00:01:29,070 --> 00:01:33,060
I believe unladen swallow was announced

00:01:31,439 --> 00:01:35,280
it was it was this new effort from

00:01:33,060 --> 00:01:38,070
Google to try to speed up Python and

00:01:35,280 --> 00:01:40,259
their target was five times faster in a

00:01:38,070 --> 00:01:42,570
year and I thought like this sounds

00:01:40,259 --> 00:01:43,619
incredible five times faster you know it

00:01:42,570 --> 00:01:45,450
sounds like a really cool thing that's

00:01:43,619 --> 00:01:46,860
going to be awesome Google's doing it so

00:01:45,450 --> 00:01:48,630
you know I signed up for the mailing

00:01:46,860 --> 00:01:51,060
list I got every commit that happened

00:01:48,630 --> 00:01:52,590
sent to my inbox and like at first I had

00:01:51,060 --> 00:01:55,020
no idea what I was reading every single

00:01:52,590 --> 00:01:58,229
thing I saw was basically just nonsense

00:01:55,020 --> 00:01:58,920
to me over time kind of a learned what

00:01:58,229 --> 00:02:00,930
was going on

00:01:58,920 --> 00:02:02,189
learned learned what all these commits

00:02:00,930 --> 00:02:03,810
were eventually even got to a point

00:02:02,189 --> 00:02:06,840
where I was able to help out myself

00:02:03,810 --> 00:02:10,110
then when online swallows sort of faded

00:02:06,840 --> 00:02:11,900
away and went into arrest and by that

00:02:10,110 --> 00:02:13,610
point I was totally enamored with

00:02:11,900 --> 00:02:15,349
interpreters and performance and all

00:02:13,610 --> 00:02:16,760
this stuff so I jumped up right over to

00:02:15,349 --> 00:02:19,489
pi PI because they were doing all this

00:02:16,760 --> 00:02:20,689
other awesome work so it is totally an

00:02:19,489 --> 00:02:24,230
approachable thing and you can totally

00:02:20,689 --> 00:02:26,840
learn it so start with up from the top

00:02:24,230 --> 00:02:29,000
what is an interpreter so you know what

00:02:26,840 --> 00:02:30,950
is a program even while a program is a

00:02:29,000 --> 00:02:32,900
thing that takes some input and it does

00:02:30,950 --> 00:02:36,590
some stuff and maybe it has some output

00:02:32,900 --> 00:02:38,000
or does some computations and maybe it

00:02:36,590 --> 00:02:39,859
runs forever maybe it runs for five

00:02:38,000 --> 00:02:42,170
seconds or all programs so an

00:02:39,859 --> 00:02:44,000
interpreter is just a program it's a

00:02:42,170 --> 00:02:46,459
program that is a pretty pretty cool

00:02:44,000 --> 00:02:49,099
behavior though its behavior is that its

00:02:46,459 --> 00:02:51,920
input is some program in some language

00:02:49,099 --> 00:02:54,170
and its output is what would happen if

00:02:51,920 --> 00:02:54,889
you ran that program so the Python

00:02:54,170 --> 00:02:57,319
interpreter

00:02:54,889 --> 00:02:59,930
it's a program its input is your Python

00:02:57,319 --> 00:03:02,659
files and its output is what happens

00:02:59,930 --> 00:03:04,280
according to the sort of magical Python

00:03:02,659 --> 00:03:06,439
machine if you ran it and it's an

00:03:04,280 --> 00:03:07,790
implementation of the Python machine you

00:03:06,439 --> 00:03:09,500
could imagine we could build a Python

00:03:07,790 --> 00:03:12,650
machine out of raw hardware if we wanted

00:03:09,500 --> 00:03:14,180
we could wire up wires and hook them all

00:03:12,650 --> 00:03:16,489
up and we could build a Python machine

00:03:14,180 --> 00:03:18,019
and so the Python interpreter is

00:03:16,489 --> 00:03:20,720
software that implements this

00:03:18,019 --> 00:03:22,819
hypothetical machine so sort of none of

00:03:20,720 --> 00:03:24,560
this is magic this is this is just a

00:03:22,819 --> 00:03:27,079
program that's got a really cool

00:03:24,560 --> 00:03:28,849
behavior and why would you want to write

00:03:27,079 --> 00:03:30,560
an interpreter well there's a couple

00:03:28,849 --> 00:03:32,780
good reasons first of all is maybe you

00:03:30,560 --> 00:03:34,280
want to build your own language you've

00:03:32,780 --> 00:03:35,629
got a design you thinking build

00:03:34,280 --> 00:03:37,099
something better than Python or better

00:03:35,629 --> 00:03:39,169
than maybe whatever you use at your day

00:03:37,099 --> 00:03:40,750
job and you want to build your own for

00:03:39,169 --> 00:03:43,940
fun because you think you can do better

00:03:40,750 --> 00:03:45,859
I personally I like implementing

00:03:43,940 --> 00:03:48,769
existing languages I don't really have

00:03:45,859 --> 00:03:50,389
any skill for language design I'm sort

00:03:48,769 --> 00:03:51,500
of in awe of what python is Grudge

00:03:50,389 --> 00:03:53,540
because I would have never come up with

00:03:51,500 --> 00:03:55,609
some of the the great ideas I love today

00:03:53,540 --> 00:03:57,799
so I like I like just looking at the

00:03:55,609 --> 00:04:00,019
engineering side of it here's a design

00:03:57,799 --> 00:04:02,269
for a thing can we find a better way to

00:04:00,019 --> 00:04:04,010
build it and of course I think the best

00:04:02,269 --> 00:04:05,989
reason to build interpreter is it's a

00:04:04,010 --> 00:04:08,659
ton of fun it's a super cool software

00:04:05,989 --> 00:04:10,190
engineering project and you know you can

00:04:08,659 --> 00:04:12,139
sort of scale the problem from as small

00:04:10,190 --> 00:04:14,269
as you want to say fit in the 45-minute

00:04:12,139 --> 00:04:17,329
talk or to a thing that you could spend

00:04:14,269 --> 00:04:19,220
your lifetime working on so an

00:04:17,329 --> 00:04:21,469
interpreter like most programs is

00:04:19,220 --> 00:04:23,540
comprised of a bunch of parts so an

00:04:21,469 --> 00:04:25,730
interpreter is basically six parts

00:04:23,540 --> 00:04:28,670
we start with a Luxor we have a parser

00:04:25,730 --> 00:04:30,440
we have an ast with a bytecode compiler

00:04:28,670 --> 00:04:32,270
and we bytecode interpreter and then a

00:04:30,440 --> 00:04:33,680
runtime and we're going to sort of walk

00:04:32,270 --> 00:04:35,480
through what each of these components

00:04:33,680 --> 00:04:37,340
look like what each of them does what

00:04:35,480 --> 00:04:38,780
you need to know about them and one of

00:04:37,340 --> 00:04:41,240
the cool things about an interpreter is

00:04:38,780 --> 00:04:43,310
that basically each stage feeds right

00:04:41,240 --> 00:04:45,350
into the next stage so you start with a

00:04:43,310 --> 00:04:47,060
program then you feed it to your lexer

00:04:45,350 --> 00:04:50,180
you feed the result of your Luxor to

00:04:47,060 --> 00:04:51,890
your parser your parser spits out an AST

00:04:50,180 --> 00:04:54,650
you feed the AST to the bytecode

00:04:51,890 --> 00:04:57,260
compiler each one of these stages just

00:04:54,650 --> 00:05:00,100
runs right into the next one so it's a

00:04:57,260 --> 00:05:02,750
very cool machine very cool pipeline so

00:05:00,100 --> 00:05:04,040
basically the rest of this talk we're

00:05:02,750 --> 00:05:06,920
going to look at what does it look like

00:05:04,040 --> 00:05:09,110
to build an interpreter from scratch for

00:05:06,920 --> 00:05:11,930
our own language which is basically a

00:05:09,110 --> 00:05:14,750
tiny tiny subset of JavaScript just a

00:05:11,930 --> 00:05:15,650
few small things and one small addition

00:05:14,750 --> 00:05:18,020
it's going to it's going to be pretty

00:05:15,650 --> 00:05:19,670
cool I think so this is our language

00:05:18,020 --> 00:05:21,920
we've got out we've got assignments

00:05:19,670 --> 00:05:24,530
we've got we've got comparisons we've

00:05:21,920 --> 00:05:26,330
got if statements we have a we have a

00:05:24,530 --> 00:05:28,520
print statement which you know it's not

00:05:26,330 --> 00:05:30,200
a JavaScript thing but it turns out IO

00:05:28,520 --> 00:05:33,350
is like useful and we don't want to

00:05:30,200 --> 00:05:35,030
emulate having an entire browser so yeah

00:05:33,350 --> 00:05:36,770
this is our language small little thing

00:05:35,030 --> 00:05:39,050
looks like a real language and it's

00:05:36,770 --> 00:05:41,990
totally an awesome building block so

00:05:39,050 --> 00:05:43,880
yeah small couple small pieces you know

00:05:41,990 --> 00:05:45,790
to sort of in terms of data types we

00:05:43,880 --> 00:05:49,310
have numbers and we have strings and

00:05:45,790 --> 00:05:51,110
sort of what we're working with so this

00:05:49,310 --> 00:05:54,530
our ply is a toolkit we're going to be

00:05:51,110 --> 00:05:57,380
working with if you used apply Python

00:05:54,530 --> 00:05:59,720
Lexy ak from David Beasley it's a very

00:05:57,380 --> 00:06:02,420
similar basically a new API for a lot of

00:05:59,720 --> 00:06:03,770
the same concepts so when you're working

00:06:02,420 --> 00:06:07,460
through these slides you can install it

00:06:03,770 --> 00:06:09,200
and use it so first step is writing a

00:06:07,460 --> 00:06:11,570
Luxor Luxor is basically the first step

00:06:09,200 --> 00:06:13,970
you might also know Luxor as a tokenizer

00:06:11,570 --> 00:06:16,940
if you've ever looked at this before so

00:06:13,970 --> 00:06:19,010
a Luxor is a prote eight is a basically

00:06:16,940 --> 00:06:21,470
a thing that takes your program as a big

00:06:19,010 --> 00:06:23,660
old string say something you read right

00:06:21,470 --> 00:06:26,630
out of file and it turns it into a list

00:06:23,660 --> 00:06:29,210
of tokens and what's a token a token is

00:06:26,630 --> 00:06:31,010
basically the name of some sort of

00:06:29,210 --> 00:06:33,190
symbol some type of thing that occurs in

00:06:31,010 --> 00:06:35,050
a program as well as it's bad

00:06:33,190 --> 00:06:36,400
what was the what did it look like in

00:06:35,050 --> 00:06:39,370
the program we'll have an example this

00:06:36,400 --> 00:06:41,380
in a second as well as maybe its

00:06:39,370 --> 00:06:42,820
position where did it occur which is you

00:06:41,380 --> 00:06:45,210
know it turns out really useful for

00:06:42,820 --> 00:06:48,430
debugging to know where things occurred

00:06:45,210 --> 00:06:51,850
so if we look at our example program we

00:06:48,430 --> 00:06:54,820
can see that these are 1 2 3 4 5 6 7

00:06:51,850 --> 00:06:57,130
lines of code become tons and tons of

00:06:54,820 --> 00:06:59,710
tokens so if we sort of look through

00:06:57,130 --> 00:07:02,320
them the first token is a name which

00:06:59,710 --> 00:07:04,560
that's the the name of the symbol name

00:07:02,320 --> 00:07:07,930
of the token we have and its values a

00:07:04,560 --> 00:07:09,250
obviously a named token put a tons of

00:07:07,930 --> 00:07:11,370
different values you did write whatever

00:07:09,250 --> 00:07:14,920
variable name you wanted in this program

00:07:11,370 --> 00:07:17,440
and then we have other tokens like equal

00:07:14,920 --> 00:07:19,030
whose value is an equal sign an equal

00:07:17,440 --> 00:07:21,120
token would always have an equal sign

00:07:19,030 --> 00:07:23,350
there's only one way to represent equal

00:07:21,120 --> 00:07:25,060
so you can sort of look through it some

00:07:23,350 --> 00:07:27,220
of the key things to notice here is

00:07:25,060 --> 00:07:28,840
there's a if you look through the tokens

00:07:27,220 --> 00:07:31,060
you won't see any white space anywhere

00:07:28,840 --> 00:07:34,780
our language white space is not

00:07:31,060 --> 00:07:38,890
significant so it's just emitted emitted

00:07:34,780 --> 00:07:41,380
sorry we also there's also things like L

00:07:38,890 --> 00:07:43,930
brace R brace you know really just

00:07:41,380 --> 00:07:44,919
representing every symbol here except

00:07:43,930 --> 00:07:47,590
the white space everything that's

00:07:44,919 --> 00:07:49,860
important all the key words if else

00:07:47,590 --> 00:07:53,470
print they're all becoming their own

00:07:49,860 --> 00:07:55,690
token so yeah this is basically output

00:07:53,470 --> 00:07:57,910
so how do we build this well you know

00:07:55,690 --> 00:07:59,620
thankfully the kind folks at xkcd have

00:07:57,910 --> 00:08:02,230
explained this for us regular

00:07:59,620 --> 00:08:04,180
expressions it turns out each token can

00:08:02,230 --> 00:08:07,030
basically represented as a regular

00:08:04,180 --> 00:08:10,000
expression so here is how we build our

00:08:07,030 --> 00:08:11,620
entire Luxor so we have this Luxor

00:08:10,000 --> 00:08:13,210
generator object and first thing we tell

00:08:11,620 --> 00:08:15,880
we want to ignore all whitespace

00:08:13,210 --> 00:08:17,470
whitespace is not significant and then

00:08:15,880 --> 00:08:19,330
we tell it sort of the list of rules

00:08:17,470 --> 00:08:21,790
that we want to know about so we have

00:08:19,330 --> 00:08:24,190
the if token and to match it you just

00:08:21,790 --> 00:08:27,340
look for the string I app every I F in

00:08:24,190 --> 00:08:30,580
the program begins an if token every

00:08:27,340 --> 00:08:34,089
screen else becomes else every print

00:08:30,580 --> 00:08:35,919
becomes print every opening parenthesis

00:08:34,089 --> 00:08:37,479
because an opening parenthesis closed in

00:08:35,919 --> 00:08:39,849
parenthesis becomes a closing

00:08:37,479 --> 00:08:41,919
parenthesis braces become braces equals

00:08:39,849 --> 00:08:45,150
become equals greater equal becomes

00:08:41,919 --> 00:08:47,430
greater equal semicolons numbers

00:08:45,150 --> 00:08:49,560
we actually have an semi exciting

00:08:47,430 --> 00:08:51,510
regular expression here we have you know

00:08:49,560 --> 00:08:53,400
multiple numbers in a row it turns out

00:08:51,510 --> 00:08:55,380
make up a number and you know we could

00:08:53,400 --> 00:08:57,150
see how would we expand this to also

00:08:55,380 --> 00:08:59,370
match floating-point numbers for example

00:08:57,150 --> 00:09:01,710
well we might want a separate rule that

00:08:59,370 --> 00:09:02,940
included decimal points you think about

00:09:01,710 --> 00:09:04,740
what does our language look like in

00:09:02,940 --> 00:09:06,510
Python it turns out your if you're

00:09:04,740 --> 00:09:09,030
writing a decimal number you're allowed

00:09:06,510 --> 00:09:10,770
to omit either the leading 0 so you can

00:09:09,030 --> 00:09:14,400
straight point one to mean zero point

00:09:10,770 --> 00:09:16,500
one or one point to represent 1.0 does

00:09:14,400 --> 00:09:18,570
javascript have a honestly I don't know

00:09:16,500 --> 00:09:20,100
but if we were designing you know a more

00:09:18,570 --> 00:09:21,600
complete lecture we would think about

00:09:20,100 --> 00:09:24,210
those problems and try to express them

00:09:21,600 --> 00:09:26,460
here and maybe the most exciting a token

00:09:24,210 --> 00:09:29,640
name we can see it's something that

00:09:26,460 --> 00:09:32,850
starts with a letter uppercase number K

00:09:29,640 --> 00:09:34,980
uppercase lowercase or an underscore and

00:09:32,850 --> 00:09:36,600
then can be followed by any number of

00:09:34,980 --> 00:09:39,000
uppercase lowercase numbers or

00:09:36,600 --> 00:09:41,610
underscores and then we actually take a

00:09:39,000 --> 00:09:43,650
final step we call a LG our lexer

00:09:41,610 --> 00:09:46,590
generator build and we get a lexer a--

00:09:43,650 --> 00:09:48,050
object out the back so how does this

00:09:46,590 --> 00:09:52,260
look like

00:09:48,050 --> 00:09:54,510
so we import our lexer and then we we

00:09:52,260 --> 00:09:56,550
passed a string and we get this token

00:09:54,510 --> 00:09:58,950
stream back and basically a token stream

00:09:56,550 --> 00:10:01,320
just emits tokens as we have them so we

00:09:58,950 --> 00:10:04,140
call the next method we get we get our

00:10:01,320 --> 00:10:06,930
first name token with my VAR string we

00:10:04,140 --> 00:10:09,870
call next again we get the equals token

00:10:06,930 --> 00:10:12,180
we call next again we get our 23 number

00:10:09,870 --> 00:10:14,370
we call next again we get none were out

00:10:12,180 --> 00:10:16,560
of tokens so it's just giving us tokens

00:10:14,370 --> 00:10:19,320
one at a time which turns out is exactly

00:10:16,560 --> 00:10:21,180
how our parser wants them so now we have

00:10:19,320 --> 00:10:22,800
our parser our parser at this point is

00:10:21,180 --> 00:10:24,900
going to know nothing about the original

00:10:22,800 --> 00:10:26,880
string for the program all it's going to

00:10:24,900 --> 00:10:28,740
know about is this token stream this

00:10:26,880 --> 00:10:32,610
thing that gives us tokens one at a time

00:10:28,740 --> 00:10:34,140
and so now we want to actually do

00:10:32,610 --> 00:10:36,420
something with that list of tokens what

00:10:34,140 --> 00:10:38,490
does the parser responsible for a parser

00:10:36,420 --> 00:10:40,380
takes this list of tokens and tries to

00:10:38,490 --> 00:10:41,250
figure out what is the structure of your

00:10:40,380 --> 00:10:43,110
program

00:10:41,250 --> 00:10:45,510
what are those if statements refer to

00:10:43,110 --> 00:10:47,790
how does this all work so we're taking

00:10:45,510 --> 00:10:49,470
this this big list of tokens we have and

00:10:47,790 --> 00:10:52,710
we're turning it into what's called an

00:10:49,470 --> 00:10:54,900
abstract syntax tree so it's this

00:10:52,710 --> 00:10:57,010
basically this big thing of nested

00:10:54,900 --> 00:10:58,870
objects that contains all the parts

00:10:57,010 --> 00:11:01,390
program so if we look at the topmost

00:10:58,870 --> 00:11:03,280
level we have a block what is the block

00:11:01,390 --> 00:11:05,290
a block is basically a list of other

00:11:03,280 --> 00:11:06,670
parts of the program so you can see that

00:11:05,290 --> 00:11:08,410
the first item in the block is an

00:11:06,670 --> 00:11:10,900
assignment we're assigning to the

00:11:08,410 --> 00:11:12,400
variable a we're assigning the number 3

00:11:10,900 --> 00:11:13,720
which you know if we look at our

00:11:12,400 --> 00:11:17,230
original program is basically what we

00:11:13,720 --> 00:11:19,800
have now we look at the next item in our

00:11:17,230 --> 00:11:24,130
block next thing is an if statement so

00:11:19,800 --> 00:11:26,260
an if statement basically has three

00:11:24,130 --> 00:11:28,420
parts it has what is the condition when

00:11:26,260 --> 00:11:30,760
does this if statement occur what

00:11:28,420 --> 00:11:32,590
happens if the if statement is true and

00:11:30,760 --> 00:11:36,780
what happens if if the if statement is

00:11:32,590 --> 00:11:40,030
false so the first parameter if is a

00:11:36,780 --> 00:11:42,850
this condition what is the condition and

00:11:40,030 --> 00:11:44,830
that's turns out it's a comparison it's

00:11:42,850 --> 00:11:49,270
the greater than equals comparison and

00:11:44,830 --> 00:11:52,540
the left-hand side is the name a and the

00:11:49,270 --> 00:11:55,150
right-hand side is the number 2 the

00:11:52,540 --> 00:11:56,620
second part of an if statement is a what

00:11:55,150 --> 00:11:57,970
happens if it's true and this is another

00:11:56,620 --> 00:12:00,340
block because you can do multiple things

00:11:57,970 --> 00:12:02,350
you have multiple statements if an if

00:12:00,340 --> 00:12:04,630
statement evaluates to true so it's a

00:12:02,350 --> 00:12:06,370
block and in it we have a the only thing

00:12:04,630 --> 00:12:08,830
that happens if the if statement is true

00:12:06,370 --> 00:12:10,510
is we have a print and the puts the

00:12:08,830 --> 00:12:13,960
print printing it's printing the string

00:12:10,510 --> 00:12:17,560
a is big and then finally we have the

00:12:13,960 --> 00:12:19,210
else clause on the if what is that again

00:12:17,560 --> 00:12:21,130
it's another block because we can have

00:12:19,210 --> 00:12:24,310
multiple things that happen and it's

00:12:21,130 --> 00:12:27,370
print name a so you can sort of see

00:12:24,310 --> 00:12:29,230
every one of these nodes in this

00:12:27,370 --> 00:12:32,170
industry it's comprised of multiple

00:12:29,230 --> 00:12:35,500
child nodes or is a sort of a leaf node

00:12:32,170 --> 00:12:38,680
it has it has no children so number name

00:12:35,500 --> 00:12:40,750
these have no children they refer to a

00:12:38,680 --> 00:12:42,700
specific value or a specific sort of

00:12:40,750 --> 00:12:44,770
things so we don't know what value and

00:12:42,700 --> 00:12:46,960
name has but want to find it out when we

00:12:44,770 --> 00:12:48,520
run our program we know exactly what

00:12:46,960 --> 00:12:52,300
value a number has and it will never

00:12:48,520 --> 00:12:55,090
change when we say a equals 2 it will be

00:12:52,300 --> 00:12:57,130
sorry 3 it will be 3 for the rest of our

00:12:55,090 --> 00:13:00,430
program that that's what the code says

00:12:57,130 --> 00:13:03,430
so a becomes 3 there whereas the if

00:13:00,430 --> 00:13:05,290
statement for example what it does it

00:13:03,430 --> 00:13:08,650
depends it depends on what that

00:13:05,290 --> 00:13:10,270
condition evaluates to so what are these

00:13:08,650 --> 00:13:12,910
ast nodes look like there

00:13:10,270 --> 00:13:14,530
they're pretty unexcited so we have a

00:13:12,910 --> 00:13:17,560
node-based class that gives us some

00:13:14,530 --> 00:13:19,990
simple helpers for equals and not equals

00:13:17,560 --> 00:13:21,970
extraordinarily exciting and then we

00:13:19,990 --> 00:13:24,340
have we have a couple modes so we have a

00:13:21,970 --> 00:13:26,500
we have a block node which you know just

00:13:24,340 --> 00:13:28,480
takes a list of statements we have a

00:13:26,500 --> 00:13:29,890
statement node we'll talk more about why

00:13:28,480 --> 00:13:31,090
that exists in a bit

00:13:29,890 --> 00:13:34,240
this statement is basically an

00:13:31,090 --> 00:13:36,130
expression we have a number and numbers

00:13:34,240 --> 00:13:37,510
got a specific value and you know we can

00:13:36,130 --> 00:13:37,810
imagine what does the name node look

00:13:37,510 --> 00:13:40,390
like

00:13:37,810 --> 00:13:42,430
well it's got its got one attribute and

00:13:40,390 --> 00:13:44,770
it's the it's the name it is we can

00:13:42,430 --> 00:13:47,170
imagine what is a comparison H me look

00:13:44,770 --> 00:13:49,840
like it's got what is the operation what

00:13:47,170 --> 00:13:52,960
is the if clause and what is the else

00:13:49,840 --> 00:13:54,820
clause so we can imagine what is what a

00:13:52,960 --> 00:13:55,960
writing all those things look like so

00:13:54,820 --> 00:13:57,790
now we have to get to the question of

00:13:55,960 --> 00:14:00,460
how do we construct them we need

00:13:57,790 --> 00:14:03,790
actually build a thing so our ply is

00:14:00,460 --> 00:14:05,800
kind of a similar API as for building

00:14:03,790 --> 00:14:08,020
Luxor's is does for building parse so we

00:14:05,800 --> 00:14:11,470
can see there's a couple parts first we

00:14:08,020 --> 00:14:13,330
construct a a parser generator and the

00:14:11,470 --> 00:14:15,010
first argument is a list of tokens so

00:14:13,330 --> 00:14:16,510
we're going to start really simple we're

00:14:15,010 --> 00:14:18,430
just going to start writing about

00:14:16,510 --> 00:14:19,990
numbers and semicolons that you know the

00:14:18,430 --> 00:14:23,530
most simple program you could possibly

00:14:19,990 --> 00:14:25,420
imagine just basically just numbers and

00:14:23,530 --> 00:14:34,390
it also takes a cash ID which is

00:14:25,420 --> 00:14:38,050
entirely unacceptable the parser we

00:14:34,390 --> 00:14:40,300
would do a PG bill very very similar and

00:14:38,050 --> 00:14:42,550
so the first parses are basically built

00:14:40,300 --> 00:14:44,140
of what's called basically rules rules

00:14:42,550 --> 00:14:46,810
are generally called productions and

00:14:44,140 --> 00:14:49,060
parsers and basically how this works is

00:14:46,810 --> 00:14:51,100
you have the production which is a sort

00:14:49,060 --> 00:14:53,110
of this small little mini language for

00:14:51,100 --> 00:14:55,270
describing what the rules are and then

00:14:53,110 --> 00:14:57,910
you have an action you perform when you

00:14:55,270 --> 00:14:59,920
when you run this rule so the simplest

00:14:57,910 --> 00:15:02,470
rule is the main so the first rule

00:14:59,920 --> 00:15:04,930
that's registered with the parser

00:15:02,470 --> 00:15:07,270
generator becomes the top-level thing

00:15:04,930 --> 00:15:10,150
this is what is your entire program and

00:15:07,270 --> 00:15:14,020
so name it main here so the syntax is

00:15:10,150 --> 00:15:17,020
basically rule name colon set of things

00:15:14,020 --> 00:15:19,630
that that rule is so it turns out main

00:15:17,020 --> 00:15:20,300
is statements where does statements

00:15:19,630 --> 00:15:23,060
statement

00:15:20,300 --> 00:15:26,090
they elicit of is it's basically a block

00:15:23,060 --> 00:15:30,830
so in what rule do we perform when we

00:15:26,090 --> 00:15:33,620
actually evaluate this block we we just

00:15:30,830 --> 00:15:36,740
return s Sub Zero what is what is s here

00:15:33,620 --> 00:15:39,530
basically acts as a list where each item

00:15:36,740 --> 00:15:41,420
is something from the right-hand side of

00:15:39,530 --> 00:15:42,770
the colon so in this case we have one

00:15:41,420 --> 00:15:43,940
thing on the right hand side of our call

00:15:42,770 --> 00:15:46,340
and we'll see some examples where we

00:15:43,940 --> 00:15:48,470
have more and so we're just returning

00:15:46,340 --> 00:15:50,570
the statements so tell you now

00:15:48,470 --> 00:15:54,140
statements is one of those block objects

00:15:50,570 --> 00:15:56,150
and so we're evaluating an entire

00:15:54,140 --> 00:15:59,300
program the top-level thing is a block

00:15:56,150 --> 00:16:00,830
and to be honest I consider writing

00:15:59,300 --> 00:16:02,660
parsers and this whole sort of rule

00:16:00,830 --> 00:16:04,900
thing to be the single most complicated

00:16:02,660 --> 00:16:07,010
part of a writing a compiler

00:16:04,900 --> 00:16:09,170
whereas I know many people find it

00:16:07,010 --> 00:16:10,910
entirely intuitive and find the rest of

00:16:09,170 --> 00:16:12,800
this talk extraordinarily confusing so

00:16:10,910 --> 00:16:14,750
do not worry about what you find

00:16:12,800 --> 00:16:17,360
confusing I found that no two people

00:16:14,750 --> 00:16:20,570
find the same thing confusing so this is

00:16:17,360 --> 00:16:22,750
now sort of set of more complex rules so

00:16:20,570 --> 00:16:25,670
the the first rule is what is statements

00:16:22,750 --> 00:16:29,270
statements are statements followed by a

00:16:25,670 --> 00:16:31,610
statement so we sort of dive right in

00:16:29,270 --> 00:16:35,000
super confusing like massively recursive

00:16:31,610 --> 00:16:37,280
thing so maybe it's easier if we look at

00:16:35,000 --> 00:16:39,230
the second rule first a statements can

00:16:37,280 --> 00:16:41,240
also be a single statement and you can

00:16:39,230 --> 00:16:42,950
see what we do if it's that then we

00:16:41,240 --> 00:16:47,870
build a block that has a list with a

00:16:42,950 --> 00:16:49,130
single item pretty simple you know if

00:16:47,870 --> 00:16:51,140
our statements is a single statement

00:16:49,130 --> 00:16:55,040
while it's a list with up one item of

00:16:51,140 --> 00:16:57,770
course and so then if we look back to

00:16:55,040 --> 00:17:00,860
our first rule statements is statements

00:16:57,770 --> 00:17:02,720
followed by statement you know how does

00:17:00,860 --> 00:17:04,850
that work it turns out this parser

00:17:02,720 --> 00:17:06,980
generator thing knows how to read these

00:17:04,850 --> 00:17:09,620
all these rules and basically figure it

00:17:06,980 --> 00:17:11,210
out so if we look at the rule for what a

00:17:09,620 --> 00:17:14,540
statement is it becomes I think a little

00:17:11,210 --> 00:17:17,390
clearer so what happens if when we see a

00:17:14,540 --> 00:17:19,670
statements that has many statements we

00:17:17,390 --> 00:17:21,740
take the the list that we get from the

00:17:19,670 --> 00:17:23,960
first item and we combine it with the

00:17:21,740 --> 00:17:26,240
list or with a single item for that

00:17:23,960 --> 00:17:28,580
single statement from the second item

00:17:26,240 --> 00:17:31,010
and we we combine them to return a new

00:17:28,580 --> 00:17:31,350
block so basically this parser generator

00:17:31,010 --> 00:17:33,660
to

00:17:31,350 --> 00:17:35,490
all will know how to basically handle

00:17:33,660 --> 00:17:38,549
this recursion for us and do everything

00:17:35,490 --> 00:17:40,860
for us so our third rule is uh what is

00:17:38,549 --> 00:17:43,110
the statement well one example the

00:17:40,860 --> 00:17:44,760
statement is an expression so in Python

00:17:43,110 --> 00:17:47,910
for example you can write the expression

00:17:44,760 --> 00:17:51,299
3 that's whole line that's a statement

00:17:47,910 --> 00:17:53,549
with the statement 3 a new value as an

00:17:51,299 --> 00:17:55,500
expression in JavaScript and in our

00:17:53,549 --> 00:17:57,660
little mini JavaScript we follow

00:17:55,500 --> 00:18:00,720
expressions with a semicolon we want

00:17:57,660 --> 00:18:02,910
them to become statements so you can see

00:18:00,720 --> 00:18:05,220
what do we do there we return a

00:18:02,910 --> 00:18:06,299
statement object and then what does this

00:18:05,220 --> 00:18:07,559
statement have in it it has an

00:18:06,299 --> 00:18:09,419
expression it has the value of that

00:18:07,559 --> 00:18:11,309
expression and we totally ignore the

00:18:09,419 --> 00:18:12,090
semicolon we're not required to do

00:18:11,309 --> 00:18:13,830
anything about it

00:18:12,090 --> 00:18:16,110
one thing you might have noticed we have

00:18:13,830 --> 00:18:18,049
a bit of a naming convention lowercase

00:18:16,110 --> 00:18:21,059
things refer to other rules and

00:18:18,049 --> 00:18:23,429
uppercase things refer to tokens so

00:18:21,059 --> 00:18:25,799
semicolon there gets its name from what

00:18:23,429 --> 00:18:28,530
is the token that our lexer emitted

00:18:25,799 --> 00:18:31,080
whereas X forgets its name from the rule

00:18:28,530 --> 00:18:34,169
we define write below so in our world

00:18:31,080 --> 00:18:36,570
simplest parser what is an axe per well

00:18:34,169 --> 00:18:39,480
it's a number and the number is that

00:18:36,570 --> 00:18:41,039
token and you can see in JavaScript it

00:18:39,480 --> 00:18:44,280
happens to be that all numbers are

00:18:41,039 --> 00:18:46,200
floats so what is the rule there we we

00:18:44,280 --> 00:18:49,230
create a number instance and its value

00:18:46,200 --> 00:18:53,010
is converting the number token to a

00:18:49,230 --> 00:18:55,530
float and we can imagine what do we need

00:18:53,010 --> 00:18:58,080
to do to add more operations our our

00:18:55,530 --> 00:18:59,760
thing as more expressions than just a

00:18:58,080 --> 00:19:01,710
number that would be an extraordinarily

00:18:59,760 --> 00:19:05,010
boring computer programming language I

00:19:01,710 --> 00:19:08,070
imagine so here is a slightly more

00:19:05,010 --> 00:19:10,950
exciting rule so what is an expression

00:19:08,070 --> 00:19:13,830
an expression is a number an expression

00:19:10,950 --> 00:19:16,919
is also an expression plus some other

00:19:13,830 --> 00:19:18,900
expression so again we have this sort of

00:19:16,919 --> 00:19:21,090
immensely confusing sort of recursive

00:19:18,900 --> 00:19:22,799
thing but if we just sort of imagine

00:19:21,090 --> 00:19:24,480
what is the simplest thing so we want to

00:19:22,799 --> 00:19:27,150
we want to run the program 1 plus 2

00:19:24,480 --> 00:19:29,400
semicolon and I don't know about you

00:19:27,150 --> 00:19:31,650
guys I I write quite a bit of Python for

00:19:29,400 --> 00:19:34,830
my day job whenever I'm writing a tasks

00:19:31,650 --> 00:19:37,289
for these many languages I so I run my

00:19:34,830 --> 00:19:38,909
tests I write 1 plus 2 and I get a parse

00:19:37,289 --> 00:19:40,980
error I'm just going to tell you now

00:19:38,909 --> 00:19:42,870
you're going to forget I know I assume I

00:19:40,980 --> 00:19:45,210
forget you can add the semicolon

00:19:42,870 --> 00:19:49,680
you get a syntax error pretty cool

00:19:45,210 --> 00:19:52,920
languages so the program 1 plus 2

00:19:49,680 --> 00:19:56,760
semicolon so what happened what is the

00:19:52,920 --> 00:19:59,400
parser see ok first it sees a one so it

00:19:56,760 --> 00:20:01,580
it goes through and basically it matches

00:19:59,400 --> 00:20:04,260
it figures out that's a number so we

00:20:01,580 --> 00:20:06,360
number becomes an expression so it puts

00:20:04,260 --> 00:20:10,800
that somewhere what is the next thing we

00:20:06,360 --> 00:20:13,290
see now we see a plus and a plus now it

00:20:10,800 --> 00:20:16,050
knows ok so I've got a number which is

00:20:13,290 --> 00:20:17,820
an expression followed by a plus so I

00:20:16,050 --> 00:20:20,250
know I want to I know I want to find

00:20:17,820 --> 00:20:22,110
some sort of plus thing and then it sees

00:20:20,250 --> 00:20:25,920
another number it sees number two and

00:20:22,110 --> 00:20:28,980
now we've got 1 plus 2 and it knows okay

00:20:25,920 --> 00:20:30,720
I know this matches the rule X / it this

00:20:28,980 --> 00:20:33,540
is an expression so I'll run this rule

00:20:30,720 --> 00:20:36,030
so now we've got the expression which is

00:20:33,540 --> 00:20:38,790
this addition thing and then it sees a

00:20:36,030 --> 00:20:40,170
semicolon and it knows okay I have an

00:20:38,790 --> 00:20:43,320
expression followed by a semicolon

00:20:40,170 --> 00:20:45,360
that's a statement and then it sees I

00:20:43,320 --> 00:20:47,460
have a statement okay that becomes a

00:20:45,360 --> 00:20:49,440
statements now I'm at the end of my

00:20:47,460 --> 00:20:51,929
program I have a statements statements

00:20:49,440 --> 00:20:54,210
becomes main that's my old thing I now

00:20:51,929 --> 00:20:58,770
have a program with a block that is one

00:20:54,210 --> 00:21:00,020
item which is addition so you know

00:20:58,770 --> 00:21:02,309
here's we have another note here

00:21:00,020 --> 00:21:04,679
obviously we didn't write it out we have

00:21:02,309 --> 00:21:06,300
a binary operator 1 it turns out that

00:21:04,679 --> 00:21:09,540
all the binary operators whether it's

00:21:06,300 --> 00:21:11,280
plus x division subtraction they all

00:21:09,540 --> 00:21:13,110
need basically the same node so they

00:21:11,280 --> 00:21:14,520
need what is their operator what is the

00:21:13,110 --> 00:21:18,240
left-hand side what is the right-hand

00:21:14,520 --> 00:21:20,580
side and they need to keep track of this

00:21:18,240 --> 00:21:22,230
if you look at sort of think of what are

00:21:20,580 --> 00:21:24,750
the problems about adding more operators

00:21:22,230 --> 00:21:27,420
most exciting one probably operator

00:21:24,750 --> 00:21:29,100
precedence it turns out if you write 1

00:21:27,420 --> 00:21:31,020
plus 2 times 3

00:21:29,100 --> 00:21:33,720
it doesn't just evaluate left to right

00:21:31,020 --> 00:21:36,150
it evaluates the 2 times 3 first and

00:21:33,720 --> 00:21:39,420
then the addition so we get 7 instead of

00:21:36,150 --> 00:21:42,540
9 if we had more time we would go deeper

00:21:39,420 --> 00:21:44,460
into that so the next bit we have is we

00:21:42,540 --> 00:21:46,110
want to talk about the compiler so now

00:21:44,460 --> 00:21:48,540
we managed to build these abstract

00:21:46,110 --> 00:21:50,670
syntax trees we have this AST we have

00:21:48,540 --> 00:21:53,490
this block node we have these if nodes

00:21:50,670 --> 00:21:54,660
we have all these things we want to

00:21:53,490 --> 00:21:56,429
actually do something with them

00:21:54,660 --> 00:21:58,769
something for the interpreter so

00:21:56,429 --> 00:22:00,419
look at what is byte code if you've ever

00:21:58,769 --> 00:22:02,399
played around with the disk module in

00:22:00,419 --> 00:22:05,039
Python you've probably seen some byte

00:22:02,399 --> 00:22:07,529
code if you've ever seen a dot pyc file

00:22:05,039 --> 00:22:11,009
those are byte code for Python putting

00:22:07,529 --> 00:22:12,840
on disk so what is byte code byte code

00:22:11,009 --> 00:22:15,299
is a sequence of instructions for this

00:22:12,840 --> 00:22:17,070
machine we're building sometimes byte

00:22:15,299 --> 00:22:19,230
codes have arguments and for our

00:22:17,070 --> 00:22:21,809
language it's going to be stack based

00:22:19,230 --> 00:22:24,809
what does this mean so it means the

00:22:21,809 --> 00:22:27,629
program 1 plus 21 it's going to be these

00:22:24,809 --> 00:22:31,860
4 byte codes it's going to be load Const

00:22:27,629 --> 00:22:34,350
load Const binary add pop top what on

00:22:31,860 --> 00:22:38,279
earth are these so first thing to notice

00:22:34,350 --> 00:22:42,360
load Const has an argument 0 or 1

00:22:38,279 --> 00:22:45,509
binary Add and pop top do not so how

00:22:42,360 --> 00:22:47,789
exactly is this working so we have a we

00:22:45,509 --> 00:22:49,799
have a program and basically load can't

00:22:47,789 --> 00:22:54,090
see row refers to the first constant

00:22:49,799 --> 00:22:55,980
that we see so it's it's 1 so 0 is some

00:22:54,090 --> 00:22:57,659
sort of reference somewhere to an array

00:22:55,980 --> 00:23:01,139
of constants a list of constants we have

00:22:57,659 --> 00:23:04,230
so the zeroth constant is a 1 and then

00:23:01,139 --> 00:23:07,860
we have load constant force 2 21 it's

00:23:04,230 --> 00:23:11,240
the second or first index English has no

00:23:07,860 --> 00:23:15,119
good way of referring to index things so

00:23:11,240 --> 00:23:16,649
21 is 1 here and then we have an

00:23:15,119 --> 00:23:19,409
addition we have this operation we want

00:23:16,649 --> 00:23:20,999
to do with them and then this program

00:23:19,409 --> 00:23:24,210
doesn't do anything with the result of 1

00:23:20,999 --> 00:23:25,559
+ 21 it just throws it away so we we pop

00:23:24,210 --> 00:23:29,100
that away we throw them together so

00:23:25,559 --> 00:23:30,419
let's sort of step through this so we're

00:23:29,100 --> 00:23:31,919
going to have a stack which is going to

00:23:30,419 --> 00:23:33,539
be basically what are the values the

00:23:31,919 --> 00:23:36,360
program is sort of working with right

00:23:33,539 --> 00:23:39,450
now so from the top at the beginning we

00:23:36,360 --> 00:23:40,769
have an empty stack no items on it so

00:23:39,450 --> 00:23:44,759
we're going to start we're going to run

00:23:40,769 --> 00:23:46,169
the first construction which load Kanzi

00:23:44,759 --> 00:23:47,639
row so that's gonna that's going to find

00:23:46,169 --> 00:23:49,919
the one it's going to find the 0th

00:23:47,639 --> 00:23:52,169
constant and it's going to put it on the

00:23:49,919 --> 00:23:54,240
stack we're not we're going to run

00:23:52,169 --> 00:23:56,279
forward now we're going to see a we run

00:23:54,240 --> 00:24:01,289
load cons 1 now we have two items on the

00:23:56,279 --> 00:24:03,809
stack so we have 1 21 and basically the

00:24:01,289 --> 00:24:04,730
the bottom most thing is referred to as

00:24:03,809 --> 00:24:06,799
a

00:24:04,730 --> 00:24:08,780
the top of stack or the bottom of stack

00:24:06,799 --> 00:24:10,820
depending some people think of the stack

00:24:08,780 --> 00:24:12,740
is growing top to bottom other people

00:24:10,820 --> 00:24:14,990
think of the growing bottom to top so

00:24:12,740 --> 00:24:17,240
pretty confusing a language

00:24:14,990 --> 00:24:19,940
unfortunately especially with how I

00:24:17,240 --> 00:24:23,530
wrote top to bottom and then said bottom

00:24:19,940 --> 00:24:26,630
of top of stack very confusing I'm sorry

00:24:23,530 --> 00:24:29,240
so the the next operator a binary ad

00:24:26,630 --> 00:24:31,520
what does it do well we didn't tell it

00:24:29,240 --> 00:24:33,410
where what things were adding how does

00:24:31,520 --> 00:24:35,090
it know where to find them it looks at

00:24:33,410 --> 00:24:37,549
what the two topmost things are on the

00:24:35,090 --> 00:24:40,940
stack and it pops them off so we see one

00:24:37,549 --> 00:24:43,220
in 21 are now gone from the stack and it

00:24:40,940 --> 00:24:46,130
adds them it computes the result and it

00:24:43,220 --> 00:24:48,590
puts the number 22 at the top of the

00:24:46,130 --> 00:24:49,940
stack so it basically replaces those two

00:24:48,590 --> 00:24:53,270
items with the result of doing

00:24:49,940 --> 00:24:55,340
computation if we wanted one or 21 again

00:24:53,270 --> 00:24:57,140
we would have to do load cons ero or

00:24:55,340 --> 00:24:59,929
load Const 1 again to get that value

00:24:57,140 --> 00:25:01,640
back and finally we're not doing

00:24:59,929 --> 00:25:05,500
anything with the result so we pop it

00:25:01,640 --> 00:25:08,110
off we get we just discard that result

00:25:05,500 --> 00:25:11,660
so how do we go about implementing these

00:25:08,110 --> 00:25:14,360
so this is sort of where wire statements

00:25:11,660 --> 00:25:15,740
important that I mentioned for where it

00:25:14,360 --> 00:25:17,900
comes in a statement is basically

00:25:15,740 --> 00:25:19,970
responsible for throwing the result away

00:25:17,900 --> 00:25:22,160
of the expression if it's unused so

00:25:19,970 --> 00:25:25,070
we're now adding sort of these compile

00:25:22,160 --> 00:25:28,429
methods to our nodes and what does

00:25:25,070 --> 00:25:30,080
compile think it takes a context and a

00:25:28,429 --> 00:25:32,110
basically context is responsible for

00:25:30,080 --> 00:25:35,179
keeping track of what we've compiled

00:25:32,110 --> 00:25:38,830
sorry we should be 45 minutes so we have

00:25:35,179 --> 00:25:41,780
time I think sorry about that

00:25:38,830 --> 00:25:43,610
yes so we have this context it's just

00:25:41,780 --> 00:25:46,429
keeping track of what we've compiled and

00:25:43,610 --> 00:25:48,440
we can see so the statement is really

00:25:46,429 --> 00:25:50,330
simple it compiles its expression it

00:25:48,440 --> 00:25:51,740
just calls the compile method and then

00:25:50,330 --> 00:25:54,020
throws away the result that adds this

00:25:51,740 --> 00:25:56,150
pop top method what does it mid do I

00:25:54,020 --> 00:25:59,900
mean is basically just depend on its

00:25:56,150 --> 00:26:02,419
internal data entirely unexcited what is

00:25:59,900 --> 00:26:05,780
a what is a numbers compilation do well

00:26:02,419 --> 00:26:09,530
it first thing you adds the load

00:26:05,780 --> 00:26:11,240
constant that's you know the constant we

00:26:09,530 --> 00:26:13,220
defined somewhere that refers to what is

00:26:11,240 --> 00:26:16,620
load Const and then what is the argument

00:26:13,220 --> 00:26:19,559
it's a this context new constant

00:26:16,620 --> 00:26:22,559
and this and that takes this j/s number

00:26:19,559 --> 00:26:24,029
object so somewhere in our program we

00:26:22,559 --> 00:26:26,760
need to decide how do we represent

00:26:24,029 --> 00:26:29,400
objects in our language so javascript

00:26:26,760 --> 00:26:31,169
has numbers are many fake JavaScript has

00:26:29,400 --> 00:26:33,360
numbers so we have we basically a number

00:26:31,169 --> 00:26:34,830
object somewhere and it contains all the

00:26:33,360 --> 00:26:35,690
behaviors for numbers as you might

00:26:34,830 --> 00:26:38,400
expect

00:26:35,690 --> 00:26:40,919
what is this context that new kant's

00:26:38,400 --> 00:26:43,080
thing basically our bytecode is

00:26:40,919 --> 00:26:44,850
basically made up of numbers only it

00:26:43,080 --> 00:26:47,130
doesn't have any direct referenced

00:26:44,850 --> 00:26:49,770
objects soloq on zero load Const one

00:26:47,130 --> 00:26:54,390
they know that somewhere there is a 0

00:26:49,770 --> 00:26:56,909
and a 1 constant what is new constitu

00:26:54,390 --> 00:26:58,919
basically keeps track of what all the

00:26:56,909 --> 00:27:01,409
constants are and returns you the number

00:26:58,919 --> 00:27:02,690
you're at now so your first number new

00:27:01,409 --> 00:27:05,909
Const

00:27:02,690 --> 00:27:08,490
and puts it away somewhere your second

00:27:05,909 --> 00:27:11,370
number returns one puts it away

00:27:08,490 --> 00:27:13,350
somewhere for later so these are pretty

00:27:11,370 --> 00:27:16,049
simple what is uh what does by not do

00:27:13,350 --> 00:27:18,149
well by nup we know has can have a bunch

00:27:16,049 --> 00:27:20,190
of different operations so first it

00:27:18,149 --> 00:27:22,679
compiles the left-hand side then it

00:27:20,190 --> 00:27:24,000
compiles the right-hand side you know

00:27:22,679 --> 00:27:26,279
it's important which order we compile

00:27:24,000 --> 00:27:28,500
them in generally we expect things to

00:27:26,279 --> 00:27:31,140
run approximately left to right minus

00:27:28,500 --> 00:27:33,120
plus or minus the precedence issues so

00:27:31,140 --> 00:27:35,039
it compiles left-hand side then it

00:27:33,120 --> 00:27:36,960
compiles its right-hand side then it

00:27:35,039 --> 00:27:39,419
just figures out what operation was so

00:27:36,960 --> 00:27:41,250
we keep we have our OP as an attribute

00:27:39,419 --> 00:27:44,010
it is a you know just the original

00:27:41,250 --> 00:27:46,380
symbol plus minus times divided and now

00:27:44,010 --> 00:27:48,149
we map it to this binary ad and we don't

00:27:46,380 --> 00:27:52,289
need to tell binary ad where anything is

00:27:48,149 --> 00:27:54,149
because we know the left left compile is

00:27:52,289 --> 00:27:55,980
going to put something on the top and

00:27:54,149 --> 00:27:57,960
then right dot compile is going to put

00:27:55,980 --> 00:27:59,490
something right above it and so we'll

00:27:57,960 --> 00:28:02,940
end up with these two top things on the

00:27:59,490 --> 00:28:04,620
stack are our left and our right hand

00:28:02,940 --> 00:28:06,500
side and then we'll put binary ad there

00:28:04,620 --> 00:28:10,200
and it'll figure out what something is

00:28:06,500 --> 00:28:11,820
so for me the absolute most exciting

00:28:10,200 --> 00:28:14,700
part of implementing a language is the

00:28:11,820 --> 00:28:17,039
object model what do we deal with Python

00:28:14,700 --> 00:28:18,779
has an incredibly rich object model we

00:28:17,039 --> 00:28:20,820
have lists we have dictionaries we have

00:28:18,779 --> 00:28:23,279
user created objects we have type

00:28:20,820 --> 00:28:25,049
objects and we can create any of these

00:28:23,279 --> 00:28:27,779
on the fly we can add methods

00:28:25,049 --> 00:28:31,230
we have just a rich Richard rich set of

00:28:27,779 --> 00:28:32,879
object types and behaviors this language

00:28:31,230 --> 00:28:38,340
we're defining as a relatively boring

00:28:32,879 --> 00:28:40,200
set so we have a a je s object that's

00:28:38,340 --> 00:28:42,330
sort of the base everything in our

00:28:40,200 --> 00:28:44,850
program at this lowest level is a je s I

00:28:42,330 --> 00:28:46,649
do some sort and then we have a je s

00:28:44,850 --> 00:28:49,769
number and it's got a constructor and it

00:28:46,649 --> 00:28:51,929
takes a value so that's really boring it

00:28:49,769 --> 00:28:54,600
all that lets it do is pass stuff around

00:28:51,929 --> 00:28:58,440
so we can create the je s numbers we saw

00:28:54,600 --> 00:29:01,499
in a number dot compile let's add some

00:28:58,440 --> 00:29:03,179
behavior so let's add an ad to je s

00:29:01,499 --> 00:29:05,249
number numbers know how to add

00:29:03,179 --> 00:29:06,929
themselves exclusively to numbers in our

00:29:05,249 --> 00:29:08,369
program so we're going to a simple

00:29:06,929 --> 00:29:11,399
assert make sure the other side is a

00:29:08,369 --> 00:29:13,799
number what does that do it takes self

00:29:11,399 --> 00:29:15,749
dot value gets the value of itself gets

00:29:13,799 --> 00:29:18,359
the other sides value ABS them together

00:29:15,749 --> 00:29:20,789
and returns a new number you can imagine

00:29:18,359 --> 00:29:23,369
this is almost exactly what that

00:29:20,789 --> 00:29:25,230
under-under ad does so under under add

00:29:23,369 --> 00:29:27,899
implements the plus operator in Python

00:29:25,230 --> 00:29:30,239
you have three plus four it's basically

00:29:27,899 --> 00:29:32,940
in a call under under add combine them

00:29:30,239 --> 00:29:34,139
return a new integer object this is

00:29:32,940 --> 00:29:35,609
basically what our program is doing

00:29:34,139 --> 00:29:39,210
besides the fact that we have you know

00:29:35,609 --> 00:29:41,009
very terrible error handling so final

00:29:39,210 --> 00:29:43,289
part we started with this premise we

00:29:41,009 --> 00:29:45,299
want to write an interpreter now we need

00:29:43,289 --> 00:29:47,309
to actually you know right if that's the

00:29:45,299 --> 00:29:51,210
came in to do all these other stuff is

00:29:47,309 --> 00:29:53,190
just busy work so we have the basically

00:29:51,210 --> 00:29:55,769
score we have an interpreter runs the

00:29:53,190 --> 00:29:57,570
bytecode for forever until it knows to

00:29:55,769 --> 00:29:59,639
exit it runs the bytecode from start to

00:29:57,570 --> 00:30:02,730
finish so this is probably the world's

00:29:59,639 --> 00:30:04,859
simplest interpreter PC stands for

00:30:02,730 --> 00:30:06,840
program code and it basically tells you

00:30:04,859 --> 00:30:09,029
where in the bytecode are you what

00:30:06,840 --> 00:30:10,320
what's your position we've been we wrote

00:30:09,029 --> 00:30:13,049
all this bytecode out inside our

00:30:10,320 --> 00:30:16,409
compiler now we have to do stuff so

00:30:13,049 --> 00:30:19,799
while the program counter is less than

00:30:16,409 --> 00:30:22,019
the length of our bytecode we need to do

00:30:19,799 --> 00:30:24,419
stuff so first we find out what's the

00:30:22,019 --> 00:30:26,879
what is the opcode so we read it out of

00:30:24,419 --> 00:30:28,710
there we get what's what's our current

00:30:26,879 --> 00:30:30,600
position we figure out what opcode we're

00:30:28,710 --> 00:30:33,649
at then we get the the name of the

00:30:30,600 --> 00:30:37,109
opcode from some map we built somewhere

00:30:33,649 --> 00:30:38,050
and then we call the method we just call

00:30:37,109 --> 00:30:40,780
this as a method

00:30:38,050 --> 00:30:44,620
so let's look at a load Const it's

00:30:40,780 --> 00:30:46,390
fairly simple so what happens first we

00:30:44,620 --> 00:30:47,830
we sort of fish around in our bytecode

00:30:46,390 --> 00:30:49,990
we want to know what arguing we got we

00:30:47,830 --> 00:30:52,210
don't want to know are we are we load

00:30:49,990 --> 00:30:55,270
count zero or we load counts 1 are we

00:30:52,210 --> 00:30:56,800
load counts 10 so we fish around we just

00:30:55,270 --> 00:30:58,990
put that argument right after the

00:30:56,800 --> 00:31:01,660
current position so it's at a self up

00:30:58,990 --> 00:31:04,480
bytecodes a b c plus 1 and then we use

00:31:01,660 --> 00:31:07,540
or because bytecode is a a string so we

00:31:04,480 --> 00:31:10,630
use Ord to convert it to an integer and

00:31:07,540 --> 00:31:12,370
then we keep self constant which is that

00:31:10,630 --> 00:31:14,800
list of constants we had earlier and

00:31:12,370 --> 00:31:17,020
then we we find that we find that

00:31:14,800 --> 00:31:18,880
constant then we do a self dot push what

00:31:17,020 --> 00:31:21,130
is push it just adds a thing to the top

00:31:18,880 --> 00:31:23,200
of the US or bottom of the stack I

00:31:21,130 --> 00:31:26,260
should say so you know it's basically

00:31:23,200 --> 00:31:27,310
self set stack dot append and then what

00:31:26,260 --> 00:31:30,070
is our new position

00:31:27,310 --> 00:31:33,730
well it's PC plus 2 where did that come

00:31:30,070 --> 00:31:35,530
from we increase PC by one we read one

00:31:33,730 --> 00:31:37,480
thing to find out what opcode we were

00:31:35,530 --> 00:31:39,520
and then we read another thing to get

00:31:37,480 --> 00:31:44,020
our argument so our new position is

00:31:39,520 --> 00:31:46,540
where we were and two paces farther so

00:31:44,020 --> 00:31:48,850
that's that's how we get numbers on our

00:31:46,540 --> 00:31:52,260
stack now how do we do something with

00:31:48,850 --> 00:31:55,150
them so we have a binary add operation

00:31:52,260 --> 00:31:58,240
what does it do it pops the top two

00:31:55,150 --> 00:32:01,330
things off so what is pop it's basically

00:31:58,240 --> 00:32:03,670
self dot stack pop simplest operations

00:32:01,330 --> 00:32:06,100
so the first thing we pop is our right

00:32:03,670 --> 00:32:07,660
hand side because if you recall we

00:32:06,100 --> 00:32:09,550
compiled the left hand side then the

00:32:07,660 --> 00:32:11,710
right hand side so the left hand side

00:32:09,550 --> 00:32:13,600
thing one at the top the right hand side

00:32:11,710 --> 00:32:15,790
thing went on the bottom of it now we're

00:32:13,600 --> 00:32:17,590
binary ads so the bottom most thing is

00:32:15,790 --> 00:32:20,080
the right hand side first we pop that

00:32:17,590 --> 00:32:22,210
off and then we pop the left hand side

00:32:20,080 --> 00:32:24,120
offices we are getting the values and

00:32:22,210 --> 00:32:27,850
then we're removing them from the stack

00:32:24,120 --> 00:32:30,570
finally next or next I should say we do

00:32:27,850 --> 00:32:33,370
the addition we call left add right

00:32:30,570 --> 00:32:35,350
which you know probably calls Jas number

00:32:33,370 --> 00:32:37,510
or maybe if we have strings we know how

00:32:35,350 --> 00:32:39,580
to add strings or anything like that and

00:32:37,510 --> 00:32:42,130
then finally we push this result back

00:32:39,580 --> 00:32:46,930
onto our stack and binary ad didn't have

00:32:42,130 --> 00:32:50,850
an argument so we we only need to move

00:32:46,930 --> 00:32:53,220
one place forward so some things

00:32:50,850 --> 00:32:55,500
we didn't cover our we didn't cover how

00:32:53,220 --> 00:32:57,240
to actually implement a compilation or

00:32:55,500 --> 00:32:59,490
parsing or any other bits with if for a

00:32:57,240 --> 00:33:01,950
while we didn't actually put any other

00:32:59,490 --> 00:33:03,750
types in this program besides strings we

00:33:01,950 --> 00:33:06,480
didn't really we didn't do any

00:33:03,750 --> 00:33:08,370
operations besides addition there's tons

00:33:06,480 --> 00:33:09,630
of pieces left to our language that we'd

00:33:08,370 --> 00:33:12,600
like to add we didn't even add the print

00:33:09,630 --> 00:33:14,760
statement please please come and find me

00:33:12,600 --> 00:33:16,800
come and find any of the other pi PI

00:33:14,760 --> 00:33:18,390
folks we would love to talk to you about

00:33:16,800 --> 00:33:20,640
this help you get excited about writing

00:33:18,390 --> 00:33:22,560
interpreters because we have nefarious

00:33:20,640 --> 00:33:26,010
purposes we want to recruit you to help

00:33:22,560 --> 00:33:27,870
out with Wi-Fi and c python and topaz

00:33:26,010 --> 00:33:30,180
what we want you to come hack on all

00:33:27,870 --> 00:33:33,210
these things with us here are some

00:33:30,180 --> 00:33:35,430
useful references topaz's interpreter it

00:33:33,210 --> 00:33:39,150
sounds scary because you know Ruby giant

00:33:35,430 --> 00:33:40,950
language but topaz is actually I think

00:33:39,150 --> 00:33:42,930
an incredibly clean source code very

00:33:40,950 --> 00:33:45,690
easy to get started with there's the

00:33:42,930 --> 00:33:48,660
Kermit example interpreter that pi PI

00:33:45,690 --> 00:33:51,420
maintains please come by pound pi PI

00:33:48,660 --> 00:33:55,440
pound topes on freenode come chat with

00:33:51,420 --> 00:33:57,510
us and sort of recap we have a with the

00:33:55,440 --> 00:34:00,360
Luxor which takes our original program

00:33:57,510 --> 00:34:03,150
returns to us a list of tokens each of

00:34:00,360 --> 00:34:05,430
which says what it is what the value was

00:34:03,150 --> 00:34:07,080
and where it is in the program we have

00:34:05,430 --> 00:34:09,630
the parser which takes this list of

00:34:07,080 --> 00:34:11,310
tokens and it turns into a tree which

00:34:09,630 --> 00:34:14,390
says what is our what is our entire

00:34:11,310 --> 00:34:18,270
program what is it from top to bottom

00:34:14,390 --> 00:34:20,340
I never turns that as an ast the ast

00:34:18,270 --> 00:34:24,540
then knows how to compile itself to

00:34:20,340 --> 00:34:26,430
bytecode using the compiler and then we

00:34:24,540 --> 00:34:27,720
have this object model which says what

00:34:26,430 --> 00:34:30,180
are all the what are all the types of

00:34:27,720 --> 00:34:32,550
objects in my program and what can they

00:34:30,180 --> 00:34:34,980
do and finally we have the interpreter

00:34:32,550 --> 00:34:37,860
that runs this mini bytecode that we

00:34:34,980 --> 00:34:40,410
have and that's that's the interpreter

00:34:37,860 --> 00:34:44,010
from from top to bottom basically so

00:34:40,410 --> 00:34:45,630
please go forth have fun I really hope

00:34:44,010 --> 00:34:48,120
you enjoy hacking on these things as

00:34:45,630 --> 00:34:50,490
much as I have and thank you guys enough

00:34:48,120 --> 00:34:52,620
please I hope everyone isn't an amazing

00:34:50,490 --> 00:34:54,540
PyCon we'll be taking our questions

00:34:52,620 --> 00:34:56,750
please go up to the mic thank you guys

00:34:54,540 --> 00:34:56,750
so much

00:35:02,270 --> 00:35:07,530
all right thank you very much that my

00:35:05,240 --> 00:35:08,640
what I'm trying to understand is so

00:35:07,530 --> 00:35:10,650
everything you showed us

00:35:08,640 --> 00:35:13,320
thank you for us all was written in

00:35:10,650 --> 00:35:17,040
Python so you have a Python interpreter

00:35:13,320 --> 00:35:18,660
to run your interpreter how can you

00:35:17,040 --> 00:35:20,520
explain a little bit about how sort of

00:35:18,660 --> 00:35:21,780
the very first program that ever might

00:35:20,520 --> 00:35:24,480
have been written would be run is it

00:35:21,780 --> 00:35:26,970
that the compiler when you don't have an

00:35:24,480 --> 00:35:29,790
existing sort of set of software to

00:35:26,970 --> 00:35:33,090
write your interpreter in how does that

00:35:29,790 --> 00:35:34,830
get written and run on hardware sure so

00:35:33,090 --> 00:35:36,600
the other question was we wrote this

00:35:34,830 --> 00:35:39,030
interpreter in our Python which is a

00:35:36,600 --> 00:35:41,580
very nice language what how was the

00:35:39,030 --> 00:35:44,520
first interpreter written so when ghee

00:35:41,580 --> 00:35:46,980
dosa Bet said sat down to write a hika

00:35:44,520 --> 00:35:50,970
or a Python many many years ago he wrote

00:35:46,980 --> 00:35:52,860
in C so C Python is by and large the

00:35:50,970 --> 00:35:55,680
interpreter the compiler all these

00:35:52,860 --> 00:35:57,600
pieces are written in C so there C

00:35:55,680 --> 00:36:01,920
programs look kind of like this but you

00:35:57,600 --> 00:36:03,450
know uglier because it's C may be a more

00:36:01,920 --> 00:36:06,480
exciting questions how was the first C

00:36:03,450 --> 00:36:08,040
compiler written and it was not written

00:36:06,480 --> 00:36:09,960
in C or any other exciting language it

00:36:08,040 --> 00:36:12,119
was written in assembly language and

00:36:09,960 --> 00:36:13,740
it's actually really cool someone

00:36:12,119 --> 00:36:15,869
recently did some nice software

00:36:13,740 --> 00:36:20,070
archaeology and found one of the very

00:36:15,869 --> 00:36:22,560
earliest C compilers from Dave Ritchie I

00:36:20,070 --> 00:36:24,720
think and so if you go online and you

00:36:22,560 --> 00:36:26,310
search for like very early C compiler

00:36:24,720 --> 00:36:28,260
you can actually find this original

00:36:26,310 --> 00:36:30,390
source since it turns out writing

00:36:28,260 --> 00:36:32,640
assemblies a real pain so you try to

00:36:30,390 --> 00:36:34,350
write the smallest language possible so

00:36:32,640 --> 00:36:37,020
that you can start writing your compiler

00:36:34,350 --> 00:36:38,940
in in your own language because writing

00:36:37,020 --> 00:36:41,460
assemblies in kaneen so we have the

00:36:38,940 --> 00:36:44,130
small assembly program and we get a

00:36:41,460 --> 00:36:46,320
binary out of it and I know we can use

00:36:44,130 --> 00:36:49,170
that hopefully to compile our new C

00:36:46,320 --> 00:36:52,050
program and then for forever as long as

00:36:49,170 --> 00:36:55,520
you have the previous C compiler that

00:36:52,050 --> 00:37:00,480
you just built you can build a new one

00:36:55,520 --> 00:37:03,650
hi I'm I see that you are using bytecode

00:37:00,480 --> 00:37:06,510
and for the purposes of doing simple

00:37:03,650 --> 00:37:09,600
languages isn't it possible to skip that

00:37:06,510 --> 00:37:11,890
step and just interpret the AC directly

00:37:09,600 --> 00:37:14,410
sure so another strategy

00:37:11,890 --> 00:37:17,109
for writing interpreters is what's

00:37:14,410 --> 00:37:19,269
called an ast Walker and basically your

00:37:17,109 --> 00:37:21,309
nodes don't compile themselves to a

00:37:19,269 --> 00:37:24,609
bytecode they execute themselves

00:37:21,309 --> 00:37:27,490
directly one of the advantage this is

00:37:24,609 --> 00:37:29,079
it's generally slightly simpler one of

00:37:27,490 --> 00:37:32,500
the disadvantages it's generally slower

00:37:29,079 --> 00:37:35,470
the the reason I went with a compilation

00:37:32,500 --> 00:37:37,690
of bytecode for this talk was that's how

00:37:35,470 --> 00:37:41,019
C Python that's how pipe I that's how

00:37:37,690 --> 00:37:42,789
topaz that's how most interpreters work

00:37:41,019 --> 00:37:44,650
and so I think it's it's useful to get

00:37:42,789 --> 00:37:46,599
used to that idea because it will help

00:37:44,650 --> 00:37:51,309
you make it easier to read

00:37:46,599 --> 00:37:53,849
bigger more complete interpreters any

00:37:51,309 --> 00:37:53,849
other questions

00:38:00,079 --> 00:38:05,279
how would you go about writing a tour

00:38:03,449 --> 00:38:08,910
rather what were the differences between

00:38:05,279 --> 00:38:11,189
a highly functional language and highly

00:38:08,910 --> 00:38:13,140
liked sequential language how would you

00:38:11,189 --> 00:38:16,439
go about writing a lexer for something

00:38:13,140 --> 00:38:18,390
like that so the question was what are

00:38:16,439 --> 00:38:20,549
the differences between writing an

00:38:18,390 --> 00:38:22,410
interpreter for something like a highly

00:38:20,549 --> 00:38:25,140
functional language like say scheme

00:38:22,410 --> 00:38:26,699
versus a writing for something like

00:38:25,140 --> 00:38:30,420
JavaScript which is a more imperative

00:38:26,699 --> 00:38:33,959
language and uh most of these steps are

00:38:30,420 --> 00:38:36,059
actually very similar so scheme it turns

00:38:33,959 --> 00:38:37,920
out in other lisps turns out are

00:38:36,059 --> 00:38:40,430
incredibly easy to write Luxor's for it

00:38:37,920 --> 00:38:43,229
turns out nested parentheses for forever

00:38:40,430 --> 00:38:45,359
while in my opinion very annoying for

00:38:43,229 --> 00:38:48,630
humans to read are really easy for

00:38:45,359 --> 00:38:49,829
machines to read so it turns out if you

00:38:48,630 --> 00:38:51,269
look around the internet there's all

00:38:49,829 --> 00:38:53,430
sorts of posts about how to write a

00:38:51,269 --> 00:38:56,339
scheme interpreter in like 20 lines of

00:38:53,430 --> 00:38:59,130
Python so the lexer and the parser are

00:38:56,339 --> 00:39:00,420
very very similar if not a little bit

00:38:59,130 --> 00:39:02,819
simpler

00:39:00,420 --> 00:39:05,549
the interpreter often shares basically

00:39:02,819 --> 00:39:07,589
the exact same design so the design we

00:39:05,549 --> 00:39:09,869
were looking at for this this javascript

00:39:07,589 --> 00:39:12,539
interpreter it turns out is exactly the

00:39:09,869 --> 00:39:15,269
same as the design I used for the Topaz

00:39:12,539 --> 00:39:17,279
interpreter for Ruby and which was in

00:39:15,269 --> 00:39:21,089
turn the exact same as the design that

00:39:17,279 --> 00:39:22,410
pi PI and C Python used for Python so it

00:39:21,089 --> 00:39:25,579
turns out all these languages can have

00:39:22,410 --> 00:39:27,689
very similar interpreter designs and

00:39:25,579 --> 00:39:29,699
even though they look like incredibly

00:39:27,689 --> 00:39:33,709
different languages on the surface it

00:39:29,699 --> 00:39:33,709
can be very very similar under the hood

00:39:35,420 --> 00:39:39,299
just to tack something onto your

00:39:37,529 --> 00:39:40,410
explanation of my bytecode is good it

00:39:39,299 --> 00:39:42,209
also gives you another layer of

00:39:40,410 --> 00:39:44,099
abstraction there so you can go and

00:39:42,209 --> 00:39:45,689
optimize your bytecode executors and you

00:39:44,099 --> 00:39:46,920
don't to go mess with it necessarily if

00:39:45,689 --> 00:39:49,319
you had a new construct to your language

00:39:46,920 --> 00:39:51,839
yeah that's a great point

00:39:49,319 --> 00:39:54,029
sort of use saying that it gives you

00:39:51,839 --> 00:39:55,650
another level of abstraction personally

00:39:54,029 --> 00:39:56,999
I'm a giant testing nut so one of the

00:39:55,650 --> 00:39:59,579
things I love about writing an

00:39:56,999 --> 00:40:02,400
interpreter it turns out each layer is

00:39:59,579 --> 00:40:04,109
really easy to test so you test your

00:40:02,400 --> 00:40:05,309
lecture you test it you get you give it

00:40:04,109 --> 00:40:08,339
a string you test you get the right

00:40:05,309 --> 00:40:10,890
output you test your parser you test

00:40:08,339 --> 00:40:12,269
that you give it a token stream and you

00:40:10,890 --> 00:40:14,429
get the right

00:40:12,269 --> 00:40:16,439
ast out of it you can then test it

00:40:14,429 --> 00:40:18,419
you're a estie's compilation gives you

00:40:16,439 --> 00:40:20,699
the right bytecode and finally that your

00:40:18,419 --> 00:40:23,129
interpreter executes your bytecode and

00:40:20,699 --> 00:40:25,859
gives you the correct result so this is

00:40:23,129 --> 00:40:28,859
for me is a testing that a really nice

00:40:25,859 --> 00:40:30,569
thing I think we're just about out of

00:40:28,859 --> 00:40:33,829
time now so thank you guys so much

00:40:30,569 --> 00:40:33,829

YouTube URL: https://www.youtube.com/watch?v=LCslqgM48D4


