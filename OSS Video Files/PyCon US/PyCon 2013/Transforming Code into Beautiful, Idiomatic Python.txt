Title: Transforming Code into Beautiful, Idiomatic Python
Publication date: 2013-04-29
Playlist: PyCon 2013
Description: 
	Raymond Hettinger
Learn to take better advantage of Python's best features and improve existing code through a series of code transformations, "When you see this, do that instead."
Captions: 
	00:00:00,030 --> 00:00:03,090
you can be sure you're getting the

00:00:01,589 --> 00:00:05,879
straight story or they will correct me

00:00:03,090 --> 00:00:08,220
all right in the middle so this was

00:00:05,879 --> 00:00:10,019
labeled a novice taught an intermediate

00:00:08,220 --> 00:00:13,200
talk and an advanced talk altogether

00:00:10,019 --> 00:00:14,639
I've put some of each in its got a lot

00:00:13,200 --> 00:00:17,010
of code in it you don't have to memorize

00:00:14,639 --> 00:00:18,270
it as it goes by I'll actually give you

00:00:17,010 --> 00:00:20,160
all my slides they're already uploaded

00:00:18,270 --> 00:00:21,689
they are actually meant to be something

00:00:20,160 --> 00:00:23,820
to take back to work and use immediately

00:00:21,689 --> 00:00:25,590
go through all your code base and find

00:00:23,820 --> 00:00:27,840
everywhere I said don't do this do this

00:00:25,590 --> 00:00:30,420
instead and swap it and your code will

00:00:27,840 --> 00:00:32,820
be beautiful faster more idiomatic and

00:00:30,420 --> 00:00:34,860
more pythonic and less like C Java C++

00:00:32,820 --> 00:00:36,510
and other languages not that those

00:00:34,860 --> 00:00:40,320
languages are bad they just have

00:00:36,510 --> 00:00:41,969
different idioms than we have oh I'm

00:00:40,320 --> 00:00:45,530
curious how many people in the audience

00:00:41,969 --> 00:00:49,110
have taken a class from me at one point

00:00:45,530 --> 00:00:51,360
Wow I've taught over a thousand

00:00:49,110 --> 00:00:52,800
engineers in the last year and I've

00:00:51,360 --> 00:00:54,329
gained an appreciation for what things

00:00:52,800 --> 00:00:56,550
are really beautiful in Python what

00:00:54,329 --> 00:00:58,109
works great for people so it looks like

00:00:56,550 --> 00:01:00,809
I've got a number of former students

00:00:58,109 --> 00:01:03,899
here how many prospective students none

00:01:00,809 --> 00:01:05,400
oh ok a lot of them good enough and as

00:01:03,899 --> 00:01:07,409
all of my students know practically

00:01:05,400 --> 00:01:09,750
every example starts out with Raymond

00:01:07,409 --> 00:01:11,430
equal read Rachel equal blue Matthew

00:01:09,750 --> 00:01:12,840
equal yellow in case you're wondering

00:01:11,430 --> 00:01:16,020
who they are they're right at the back

00:01:12,840 --> 00:01:17,820
door right there the lovely lady and

00:01:16,020 --> 00:01:21,350
little boy that is Matthew and our

00:01:17,820 --> 00:01:21,350
Rachel all right

00:01:22,880 --> 00:01:29,030
I was supposed to introduce myself

00:01:25,939 --> 00:01:31,460
Ravin Hettinger Python core developer if

00:01:29,030 --> 00:01:33,110
you would like to have fun of doing this

00:01:31,460 --> 00:01:35,509
we can play a game whenever I put up a

00:01:33,110 --> 00:01:39,049
construct and say this is awesome clap

00:01:35,509 --> 00:01:40,880
if you know whether or not I wrote it ok

00:01:39,049 --> 00:01:42,500
so I get to talk about some of the

00:01:40,880 --> 00:01:44,180
things I created there are some awesome

00:01:42,500 --> 00:01:46,280
things in there I didn't create your

00:01:44,180 --> 00:01:48,170
game is to decide which one so clap if

00:01:46,280 --> 00:01:49,789
you think you saw one that is neat and

00:01:48,170 --> 00:01:51,560
is something I wrote

00:01:49,789 --> 00:01:54,560
the other interesting thing on this

00:01:51,560 --> 00:01:56,240
slide is the at Raymond H I use my

00:01:54,560 --> 00:01:58,310
Twitter account differently than other

00:01:56,240 --> 00:02:00,259
people I try and teach Python through

00:01:58,310 --> 00:02:01,759
Twitter I don't tweet when I arrived at

00:02:00,259 --> 00:02:04,310
an airport or when I left or anything

00:02:01,759 --> 00:02:05,179
like that it is technical tweets and so

00:02:04,310 --> 00:02:07,759
I don't waste your time

00:02:05,179 --> 00:02:09,350
I teach Python in little 140 characters

00:02:07,759 --> 00:02:11,330
at a time which is a very interesting

00:02:09,350 --> 00:02:12,590
challenge because you can get one little

00:02:11,330 --> 00:02:15,019
example and sure enough someone will

00:02:12,590 --> 00:02:18,620
tweet back but in Python 3 it does are

00:02:15,019 --> 00:02:20,000
in version 2.4 it's 140 characters you

00:02:18,620 --> 00:02:22,640
don't get to put all the footnotes just

00:02:20,000 --> 00:02:25,160
saying so without further ado let's

00:02:22,640 --> 00:02:27,500
start at the beginning the novice part

00:02:25,160 --> 00:02:29,600
and work our way up pretty much in every

00:02:27,500 --> 00:02:33,230
other language I've used you use indices

00:02:29,600 --> 00:02:35,239
quite a bit to do array lookups pretty

00:02:33,230 --> 00:02:37,519
much when you use an index in Python

00:02:35,239 --> 00:02:39,350
unless it's a fairly exotic circumstance

00:02:37,519 --> 00:02:40,970
you're almost always doing it wrong

00:02:39,350 --> 00:02:42,980
we've worked really hard to see if there

00:02:40,970 --> 00:02:45,799
to make better ways to do it so you

00:02:42,980 --> 00:02:47,030
don't have to manipulate indices I'm

00:02:45,799 --> 00:02:48,620
also going to show you something more

00:02:47,030 --> 00:02:50,750
advanced very few of you probably know

00:02:48,620 --> 00:02:51,709
about the else clause on for loops I'll

00:02:50,750 --> 00:02:53,660
show you what it's for

00:02:51,709 --> 00:02:56,390
very few of you probably know that the

00:02:53,660 --> 00:02:58,730
inner built-in function can take two

00:02:56,390 --> 00:03:02,390
arguments I'll show it what what is for

00:02:58,730 --> 00:03:03,590
but overall our goal is to aim for fast

00:03:02,390 --> 00:03:06,049
clean idiomatic

00:03:03,590 --> 00:03:08,540
Python how do you loop over a range of

00:03:06,049 --> 00:03:10,700
numbers simple enough you make a list

00:03:08,540 --> 00:03:12,890
and loop over the list what is important

00:03:10,700 --> 00:03:14,900
about that example pythons 4 is not the

00:03:12,890 --> 00:03:16,670
same as it is in other languages if you

00:03:14,900 --> 00:03:18,530
someone comes to my class and says I

00:03:16,670 --> 00:03:20,720
know what a for loop does because I know

00:03:18,530 --> 00:03:22,190
see that is not what this does we

00:03:20,720 --> 00:03:23,989
probably should have named hours for

00:03:22,190 --> 00:03:25,400
each what it does is leap over

00:03:23,989 --> 00:03:27,769
collections it uses the iterator

00:03:25,400 --> 00:03:30,019
protocol it is in no way like the

00:03:27,769 --> 00:03:32,780
forward that you grew up with is there a

00:03:30,019 --> 00:03:34,639
better way well we can use the range

00:03:32,780 --> 00:03:35,970
function the range function the output

00:03:34,639 --> 00:03:37,830
of it is that list up

00:03:35,970 --> 00:03:40,620
above in other words these two things

00:03:37,830 --> 00:03:43,020
were do the same thing in exactly the

00:03:40,620 --> 00:03:44,310
same way many people come to Python see

00:03:43,020 --> 00:03:46,290
the second one and say to themselves

00:03:44,310 --> 00:03:49,350
it's the same as the for-loop that I

00:03:46,290 --> 00:03:51,810
learned in see our basic or some other

00:03:49,350 --> 00:03:53,760
language it's not what happens here is

00:03:51,810 --> 00:03:56,130
range produces that list then the for

00:03:53,760 --> 00:03:58,980
loop loops over the list I know what

00:03:56,130 --> 00:04:00,660
you're thinking if I do range 1 million

00:03:58,980 --> 00:04:02,880
that list is going to be kind of big and

00:04:00,660 --> 00:04:04,800
in fact on a 64-bit bill that will

00:04:02,880 --> 00:04:08,490
consume 32 megabytes of memory is that

00:04:04,800 --> 00:04:11,340
awesome do not awesome so there must be

00:04:08,490 --> 00:04:14,040
a better way it's called X range X range

00:04:11,340 --> 00:04:16,620
creates an iterator over the range

00:04:14,040 --> 00:04:20,370
producing the values one at a time which

00:04:16,620 --> 00:04:25,050
is better range or X range X range which

00:04:20,370 --> 00:04:27,240
is ugly X range X range is a horrific ly

00:04:25,050 --> 00:04:29,520
bad name we didn't know how bad until

00:04:27,240 --> 00:04:31,290
Python 3 came along in Python 3 we got

00:04:29,520 --> 00:04:33,540
rid of the old range and renamed X

00:04:31,290 --> 00:04:35,130
raised to range so I started going

00:04:33,540 --> 00:04:37,169
through my programs where I used X range

00:04:35,130 --> 00:04:39,270
everywhere and I took off the X and they

00:04:37,169 --> 00:04:41,640
were profoundly more beautiful I didn't

00:04:39,270 --> 00:04:43,470
know how ugly the X was until I got rid

00:04:41,640 --> 00:04:45,870
of it you'll like Python 3 better it

00:04:43,470 --> 00:04:48,840
looks better remember beautiful is

00:04:45,870 --> 00:04:52,410
better than ugly looping over a

00:04:48,840 --> 00:04:54,660
collection how would a see programmer do

00:04:52,410 --> 00:04:57,150
it well they would say for I equals 0 I

00:04:54,660 --> 00:04:58,890
listened in I plus plus look up the 8th

00:04:57,150 --> 00:05:00,660
color then they get to Python and say

00:04:58,890 --> 00:05:03,690
how do you do that in Python they do it

00:05:00,660 --> 00:05:04,950
this way some of you already know this

00:05:03,690 --> 00:05:07,500
how are you supposed to use this

00:05:04,950 --> 00:05:09,120
information you're supposed to after

00:05:07,500 --> 00:05:11,100
this talk go back and look through your

00:05:09,120 --> 00:05:14,040
entire code base and do a grep for that

00:05:11,100 --> 00:05:16,830
whenever you see that don't do that do

00:05:14,040 --> 00:05:18,750
this instead even in professional code

00:05:16,830 --> 00:05:20,220
bases with really good programmers as I

00:05:18,750 --> 00:05:21,900
go from company to company looking at

00:05:20,220 --> 00:05:24,419
their code I see the first one all over

00:05:21,900 --> 00:05:27,300
the place just fix it it's simpler

00:05:24,419 --> 00:05:31,470
easier to read better and in Python it's

00:05:27,300 --> 00:05:32,970
faster how to loop backwards oh by the

00:05:31,470 --> 00:05:36,360
way somebody clap for X range that

00:05:32,970 --> 00:05:38,490
predates me I go back almost 13 years as

00:05:36,360 --> 00:05:41,070
a 12 years as a core developer somewhere

00:05:38,490 --> 00:05:44,580
in there X range was just before me I'm

00:05:41,070 --> 00:05:46,710
not responsible for the X ok how to loop

00:05:44,580 --> 00:05:49,450
backwards a C programmer knows how to do

00:05:46,710 --> 00:05:52,480
this for I equal n minus 1

00:05:49,450 --> 00:05:54,340
I greater than minus one count down by

00:05:52,480 --> 00:05:56,500
minus ones that translates directly into

00:05:54,340 --> 00:05:58,720
Python the idiom that you learned on the

00:05:56,500 --> 00:06:01,690
first day of class in C works exactly

00:05:58,720 --> 00:06:03,460
well in Python and it's grotesque it's

00:06:01,690 --> 00:06:05,980
horrific and it's what we had to do

00:06:03,460 --> 00:06:08,380
until we introduced a better way the

00:06:05,980 --> 00:06:10,290
better way is to use reverse which is

00:06:08,380 --> 00:06:13,420
faster the first one or the second one

00:06:10,290 --> 00:06:15,130
second one which one's more beautiful so

00:06:13,420 --> 00:06:18,700
I get one which do I see in a lot of

00:06:15,130 --> 00:06:20,890
code bases first why why would people do

00:06:18,700 --> 00:06:23,320
that the answer is they're gravitating

00:06:20,890 --> 00:06:25,270
toward back toward the mothership in the

00:06:23,320 --> 00:06:27,880
mothership that is where they came from

00:06:25,270 --> 00:06:29,860
prior to Python that was the way to loop

00:06:27,880 --> 00:06:32,080
backwards in almost every other language

00:06:29,860 --> 00:06:34,120
you know and because you've learned it

00:06:32,080 --> 00:06:35,590
you gravitate toward it you use indices

00:06:34,120 --> 00:06:38,920
all over the place and you try and write

00:06:35,590 --> 00:06:40,930
to for loops as if pythons form it the

00:06:38,920 --> 00:06:42,940
same thing I bet if we renamed it for

00:06:40,930 --> 00:06:44,860
each it wouldn't be as pretty but

00:06:42,940 --> 00:06:47,910
everybody would use it correctly that's

00:06:44,860 --> 00:06:50,910
how you look backwards I heard no claps

00:06:47,910 --> 00:06:54,250
what's special about reverse I did that

00:06:50,910 --> 00:06:56,140
okay looping over a collection and the

00:06:54,250 --> 00:06:57,730
indices at the same time see programmer

00:06:56,140 --> 00:07:01,510
have no problem because they are already

00:06:57,730 --> 00:07:05,050
looping over I they can print the ayahs

00:07:01,510 --> 00:07:07,840
ition and the ice color so the output of

00:07:05,050 --> 00:07:10,270
this would be zero red one green to blue

00:07:07,840 --> 00:07:12,310
three yellow how do you do it in Python

00:07:10,270 --> 00:07:16,150
without indices the answer is used to

00:07:12,310 --> 00:07:16,810
numerate good call Larry he wins I did a

00:07:16,150 --> 00:07:19,120
numerator

00:07:16,810 --> 00:07:21,310
so enumerate is a simple clean way to do

00:07:19,120 --> 00:07:22,930
it it's fast it's beautiful and it saves

00:07:21,310 --> 00:07:24,970
you from tracking the individual indices

00:07:22,930 --> 00:07:26,560
and incrementing them what's the Q here

00:07:24,970 --> 00:07:28,390
whenever you're manipulating indices

00:07:26,560 --> 00:07:31,000
directly you're probably doing it wrong

00:07:28,390 --> 00:07:32,980
just say it go scan your codebase you'll

00:07:31,000 --> 00:07:34,810
find this somewhere take it out replace

00:07:32,980 --> 00:07:37,000
it with enumerate it's fast and

00:07:34,810 --> 00:07:40,450
beautiful and readable how to loop over

00:07:37,000 --> 00:07:42,040
to collections that uh once every C

00:07:40,450 --> 00:07:43,480
programmer knows what to do take the

00:07:42,040 --> 00:07:45,340
shorter of the two lists the minimum of

00:07:43,480 --> 00:07:47,380
the links loop over the indices and look

00:07:45,340 --> 00:07:49,030
up the ice name in the ice color why

00:07:47,380 --> 00:07:50,470
would they do such a thing because it

00:07:49,030 --> 00:07:51,270
works in every other language they've

00:07:50,470 --> 00:07:55,030
ever learned

00:07:51,270 --> 00:07:56,950
what's the Python way zip I said really

00:07:55,030 --> 00:07:58,330
the Python way actually it goes back 50

00:07:56,950 --> 00:08:01,060
years it was in the very first version

00:07:58,330 --> 00:08:02,340
of Lisp if you read the original paper

00:08:01,060 --> 00:08:04,350
that came out on Lisp

00:08:02,340 --> 00:08:06,840
it was in there zip has a deep history

00:08:04,350 --> 00:08:10,260
it is a proven winning performer it's

00:08:06,840 --> 00:08:11,850
what you want he is do you love it yeah

00:08:10,260 --> 00:08:14,520
I think it's clean and beautiful

00:08:11,850 --> 00:08:15,000
so anything wrong with it what's wrong

00:08:14,520 --> 00:08:19,169
with it

00:08:15,000 --> 00:08:21,810
a creek to loop over this it manifests a

00:08:19,169 --> 00:08:23,490
we took start of a to list it manifest a

00:08:21,810 --> 00:08:25,229
third list in memory that third list

00:08:23,490 --> 00:08:27,000
consists of tuples each of which is its

00:08:25,229 --> 00:08:29,040
own separate object with pointers back

00:08:27,000 --> 00:08:30,949
to the original in other words it takes

00:08:29,040 --> 00:08:34,289
far more memory than the original two

00:08:30,949 --> 00:08:37,710
lists combined this is no fun it doesn't

00:08:34,289 --> 00:08:40,020
scale what's this whole scaling and

00:08:37,710 --> 00:08:41,880
speed thing it used to be if you ask me

00:08:40,020 --> 00:08:43,800
how to make Python how to make any

00:08:41,880 --> 00:08:45,779
program go fast I teach you about loop

00:08:43,800 --> 00:08:47,910
unrolling and remembering previous

00:08:45,779 --> 00:08:51,180
calculations and whatnot but on modern

00:08:47,910 --> 00:08:54,000
processors only one thing matters is the

00:08:51,180 --> 00:08:55,529
code running in l1 cache because if it's

00:08:54,000 --> 00:08:57,060
a you have a cache miss the Intel

00:08:55,529 --> 00:08:58,950
optimization guide has this horrifying

00:08:57,060 --> 00:09:01,710
line in it that says the cost of a cache

00:08:58,950 --> 00:09:03,960
miss is that simple move becomes as

00:09:01,710 --> 00:09:06,570
expensive as a floating-point divide it

00:09:03,960 --> 00:09:08,940
can go from a half clock cycle to 400 to

00:09:06,570 --> 00:09:10,650
600 clock cycles you can lose two and a

00:09:08,940 --> 00:09:13,170
half orders of magnitude by not being in

00:09:10,650 --> 00:09:14,850
cache if these lists are really big do

00:09:13,170 --> 00:09:17,220
you think that zip is going to fit into

00:09:14,850 --> 00:09:19,790
cache I don't think so

00:09:17,220 --> 00:09:23,160
there must be a better way and it is

00:09:19,790 --> 00:09:26,910
izip so I zip is better yep that was me

00:09:23,160 --> 00:09:28,380
I did that one I got in in just the

00:09:26,910 --> 00:09:30,240
right time yet a Raiders have just been

00:09:28,380 --> 00:09:32,130
created I like I'll make an iterator out

00:09:30,240 --> 00:09:34,350
of everything like wow it was really

00:09:32,130 --> 00:09:37,140
smart like no cuido made the iterators I

00:09:34,350 --> 00:09:39,480
just put them everywhere so it was his a

00:09:37,140 --> 00:09:41,010
brilliant idea and it's gone very far

00:09:39,480 --> 00:09:44,040
it's one of the things that makes Python

00:09:41,010 --> 00:09:46,770
beautiful and fast looping in sorted

00:09:44,040 --> 00:09:48,630
order so we can loop over collection by

00:09:46,770 --> 00:09:51,060
doing sorted colors it's pretty easy to

00:09:48,630 --> 00:09:52,410
take any for loop and just drop sorted

00:09:51,060 --> 00:09:55,459
in it and now you loop over it and

00:09:52,410 --> 00:09:55,459
sorted order

00:09:55,970 --> 00:10:04,470
Mertz okay yes I did sorted too okay so

00:10:01,250 --> 00:10:06,900
how to loop backwards reverse equal true

00:10:04,470 --> 00:10:08,910
simple enough how do you do a custom

00:10:06,900 --> 00:10:10,829
sort order this was the traditional way

00:10:08,910 --> 00:10:13,050
you made a custom comparison function

00:10:10,829 --> 00:10:14,580
that compared two keys and returned

00:10:13,050 --> 00:10:16,200
either minus one one

00:10:14,580 --> 00:10:19,170
our zero depending on whether it's less

00:10:16,200 --> 00:10:20,910
than equal greater Harold is just Graham

00:10:19,170 --> 00:10:22,860
missing but there's others who are not

00:10:20,910 --> 00:10:24,420
grimacing there's others say that's the

00:10:22,860 --> 00:10:27,149
way I learned it in C that's the way Q

00:10:24,420 --> 00:10:29,190
sort works and those of you who are

00:10:27,149 --> 00:10:30,510
older who you learned with Q sort and

00:10:29,190 --> 00:10:32,310
comparison functions you're going to

00:10:30,510 --> 00:10:33,959
have a hard time letting go of this in

00:10:32,310 --> 00:10:35,790
fact you'll fight with me you'll come

00:10:33,959 --> 00:10:37,620
with me over and you will try and invent

00:10:35,790 --> 00:10:41,490
examples of where you have to have a

00:10:37,620 --> 00:10:42,720
custom comparison function and you might

00:10:41,490 --> 00:10:44,279
not even listen to me when I tell you

00:10:42,720 --> 00:10:46,320
this horrifyingly slow it's no fun to

00:10:44,279 --> 00:10:47,760
write a function like that you can write

00:10:46,320 --> 00:10:51,180
one the shorter this gets the job done

00:10:47,760 --> 00:10:53,339
and how many times will this function be

00:10:51,180 --> 00:10:56,250
called well if you have a million items

00:10:53,339 --> 00:10:58,290
in a list and you're doing a sort the

00:10:56,250 --> 00:11:00,870
number of our comparisons is in log in a

00:10:58,290 --> 00:11:03,180
log of a million base 2 is 20 so that's

00:11:00,870 --> 00:11:05,610
20 million comparisons is there a better

00:11:03,180 --> 00:11:07,260
way so that's 20 million calls to that

00:11:05,610 --> 00:11:10,320
compare function which is long and slow

00:11:07,260 --> 00:11:12,570
here's a better way sorted colors key

00:11:10,320 --> 00:11:14,850
equal lengths the key function gets

00:11:12,570 --> 00:11:17,910
called exactly once per key which is

00:11:14,850 --> 00:11:20,130
better 20 million or 1 million 1 million

00:11:17,910 --> 00:11:24,270
is the function shorter for key it's

00:11:20,130 --> 00:11:25,950
almost always shorter oh so those of you

00:11:24,270 --> 00:11:28,140
who grew up on comparison functions will

00:11:25,950 --> 00:11:29,610
probably argue with me and say I can

00:11:28,140 --> 00:11:31,709
invent a comparison function where you

00:11:29,610 --> 00:11:33,270
can't make a key function and if you get

00:11:31,709 --> 00:11:36,420
really creative and work really really

00:11:33,270 --> 00:11:38,310
hard at it after a hundred tries you're

00:11:36,420 --> 00:11:40,230
going to find one that I can't do I

00:11:38,310 --> 00:11:41,910
can't do easily although I do have a

00:11:40,230 --> 00:11:44,250
function that will convert back if

00:11:41,910 --> 00:11:46,829
necessary how do we know that key

00:11:44,250 --> 00:11:49,170
functions are sufficient who likes to

00:11:46,829 --> 00:11:50,279
sort all the time SQL people they sort

00:11:49,170 --> 00:11:52,079
all the time they're ordered by this

00:11:50,279 --> 00:11:54,089
that in the other do they passing custom

00:11:52,079 --> 00:11:56,010
compare functions you they have key

00:11:54,089 --> 00:11:58,860
functions ordered by some of relative

00:11:56,010 --> 00:12:00,720
frequency order by this field plus that

00:11:58,860 --> 00:12:02,760
field if they can get by with key

00:12:00,720 --> 00:12:06,149
functions you can to this code is

00:12:02,760 --> 00:12:08,310
shorter more beautiful faster and should

00:12:06,149 --> 00:12:09,959
you abandon your key key comparison

00:12:08,310 --> 00:12:11,550
functions absolutely

00:12:09,959 --> 00:12:12,600
in fact I've abandoned them for you and

00:12:11,550 --> 00:12:16,550
I ripped them out and they're no longer

00:12:12,600 --> 00:12:16,550
in Python 3 good by comparison functions

00:12:18,490 --> 00:12:25,790
I'll live how many of you knew all of

00:12:22,160 --> 00:12:27,170
that stuff already okay let's see if I

00:12:25,790 --> 00:12:29,990
can take you to someplace you haven't

00:12:27,170 --> 00:12:32,570
been before the traditional way to do a

00:12:29,990 --> 00:12:34,399
loop over of a function call that has a

00:12:32,570 --> 00:12:36,830
sentinel is you do a while true loop

00:12:34,399 --> 00:12:38,720
when we do an F read reading a block of

00:12:36,830 --> 00:12:40,610
32 bytes at a time

00:12:38,720 --> 00:12:43,279
eventually we run out of data and when

00:12:40,610 --> 00:12:45,740
we do the what F read returns is a

00:12:43,279 --> 00:12:47,480
sentinel value an empty string whenever

00:12:45,740 --> 00:12:49,310
it's an empty string you can break out

00:12:47,480 --> 00:12:52,040
of the lip so we append the build the

00:12:49,310 --> 00:12:53,750
block so one at a time by the way how

00:12:52,040 --> 00:12:56,839
should you what you've the output of

00:12:53,750 --> 00:12:59,630
that is a big list of strings how should

00:12:56,839 --> 00:13:01,000
you connect them together join how

00:12:59,630 --> 00:13:04,370
should you not connect them together

00:13:01,000 --> 00:13:05,990
plus oh hey you guys are all on top of

00:13:04,370 --> 00:13:07,940
it so this is the traditional way you

00:13:05,990 --> 00:13:09,890
will see this code all over the place

00:13:07,940 --> 00:13:11,870
did you know that the inner function can

00:13:09,890 --> 00:13:13,310
take two arguments where the first

00:13:11,870 --> 00:13:14,750
argument is a function that you call

00:13:13,310 --> 00:13:17,330
over and over again and the second

00:13:14,750 --> 00:13:20,209
argument is a sentinel value the single

00:13:17,330 --> 00:13:21,320
value this says it will call read 32

00:13:20,209 --> 00:13:23,240
over and over again

00:13:21,320 --> 00:13:25,010
looping one block at a time we get to

00:13:23,240 --> 00:13:26,899
use four lips which should have been

00:13:25,010 --> 00:13:29,450
called for each which are fast and

00:13:26,899 --> 00:13:30,680
beautiful instead of the while now some

00:13:29,450 --> 00:13:32,750
people would argue because I had to use

00:13:30,680 --> 00:13:35,060
a partial in here that is slightly less

00:13:32,750 --> 00:13:36,680
readable than the original but remember

00:13:35,060 --> 00:13:39,200
what I made here I didn't just have to

00:13:36,680 --> 00:13:41,720
hand it to a for loop you know the first

00:13:39,200 --> 00:13:44,120
one these two are equivalent in terms of

00:13:41,720 --> 00:13:45,800
what they do but I didn't have to use

00:13:44,120 --> 00:13:47,450
this with a for loop the moment you've

00:13:45,800 --> 00:13:49,370
made something interval you've done

00:13:47,450 --> 00:13:51,200
something magic with your code what have

00:13:49,370 --> 00:13:52,880
you done with your code as soon as

00:13:51,200 --> 00:13:55,820
something is iterable you can feed it to

00:13:52,880 --> 00:13:59,209
set you can feed it to sort it min max

00:13:55,820 --> 00:14:01,790
heap queue some many of the tools in

00:13:59,209 --> 00:14:03,920
Python consume iterators as soon as

00:14:01,790 --> 00:14:05,660
you've made something interval it works

00:14:03,920 --> 00:14:07,579
with all the rest of the Python toolkit

00:14:05,660 --> 00:14:09,589
so the part to concentrate on is not the

00:14:07,579 --> 00:14:11,690
for loop part it is the to argument form

00:14:09,589 --> 00:14:13,760
of itter add that to your toolkit if

00:14:11,690 --> 00:14:16,520
you've not seen it before it's a good

00:14:13,760 --> 00:14:18,980
time to learn in order to make it work

00:14:16,520 --> 00:14:20,750
you the first function has to be a

00:14:18,980 --> 00:14:24,890
function of no arguments how many

00:14:20,750 --> 00:14:27,949
arguments does f read take 1 how do you

00:14:24,890 --> 00:14:29,300
go from 1 to 0 partial partial take some

00:14:27,949 --> 00:14:30,240
function of many arguments to a function

00:14:29,300 --> 00:14:31,980
of fewer

00:14:30,240 --> 00:14:33,240
arguments if you haven't tried this

00:14:31,980 --> 00:14:34,770
before go home and play with it and

00:14:33,240 --> 00:14:37,230
learn something new welcome to the world

00:14:34,770 --> 00:14:39,360
of functional programming and the magic

00:14:37,230 --> 00:14:42,330
of this is there are lots and lots of

00:14:39,360 --> 00:14:44,250
functions and especially in older AP is

00:14:42,330 --> 00:14:45,270
that are intended to be called over and

00:14:44,250 --> 00:14:47,100
over again until they give you a

00:14:45,270 --> 00:14:50,130
sentinel value it's called a control

00:14:47,100 --> 00:14:52,350
break style of programming it used to be

00:14:50,130 --> 00:14:53,880
very widely our practice until there was

00:14:52,350 --> 00:14:55,680
a certain little hiccup there was an

00:14:53,880 --> 00:14:59,010
insurance company that's processing big

00:14:55,680 --> 00:15:01,950
decks of punch cards for insurance

00:14:59,010 --> 00:15:03,390
claims and they brentd the deck and then

00:15:01,950 --> 00:15:04,709
they stick in another deck more claims

00:15:03,390 --> 00:15:06,330
in other decks and at some point they

00:15:04,709 --> 00:15:08,459
needed to tell it to stop so they put in

00:15:06,330 --> 00:15:10,860
a control brake field a sentinel value

00:15:08,459 --> 00:15:12,149
that told it when to stop one day they

00:15:10,860 --> 00:15:13,620
ran through a deck of cards and stopped

00:15:12,149 --> 00:15:15,149
right in the middle they reran the deck

00:15:13,620 --> 00:15:17,850
stop right in the middle I stopped at

00:15:15,149 --> 00:15:20,520
the same card every time this is a true

00:15:17,850 --> 00:15:23,520
story I got it from programming pearls

00:15:20,520 --> 00:15:26,670
the cause was the claim came from

00:15:23,520 --> 00:15:29,370
Ecuador the capital is Quito and quit

00:15:26,670 --> 00:15:31,399
was the control Blake symbol and when it

00:15:29,370 --> 00:15:33,240
hit the city and said quit it did

00:15:31,399 --> 00:15:34,950
there's a reason we don't do this

00:15:33,240 --> 00:15:36,930
anymore it's the same reason that we

00:15:34,950 --> 00:15:38,459
don't terminate our strings with nulls

00:15:36,930 --> 00:15:40,890
anymore because sometimes with my stick

00:15:38,459 --> 00:15:43,110
nulls inside the string fair enough but

00:15:40,890 --> 00:15:44,910
if you encounter an API like that the

00:15:43,110 --> 00:15:46,770
two argument form of itter takes it out

00:15:44,910 --> 00:15:49,940
of the old world and into the new world

00:15:46,770 --> 00:15:52,700
of iterators who learned something new

00:15:49,940 --> 00:15:54,959
all right

00:15:52,700 --> 00:15:57,390
distinguishing multiple exit points in

00:15:54,959 --> 00:15:59,399
loops I didn't come up with this cuido

00:15:57,390 --> 00:16:00,959
didn't come up with this this goes back

00:15:59,399 --> 00:16:04,350
to the go to our Wars

00:16:00,959 --> 00:16:06,540
lots of people hung on to go to and

00:16:04,350 --> 00:16:09,300
wouldn't let it go until every unknown

00:16:06,540 --> 00:16:11,550
use case could be replaced so Donald

00:16:09,300 --> 00:16:14,070
Knuth sat down and I to Mies the most

00:16:11,550 --> 00:16:15,839
common use cases of the go twos and he

00:16:14,070 --> 00:16:17,550
came up with some structured equivalent

00:16:15,839 --> 00:16:19,860
that would do the same and so one

00:16:17,550 --> 00:16:21,360
problem was uh when you do a is

00:16:19,860 --> 00:16:24,180
something like a for loop you need a

00:16:21,360 --> 00:16:26,370
flag variable to say is something been

00:16:24,180 --> 00:16:28,290
found or not found now keep in mind this

00:16:26,370 --> 00:16:29,579
example one we already have a built in

00:16:28,290 --> 00:16:31,440
fine so you don't need this code to

00:16:29,579 --> 00:16:35,220
begin with number two I could have

00:16:31,440 --> 00:16:36,870
exited out early with a return so I know

00:16:35,220 --> 00:16:40,170
it's a little simplistic although it is

00:16:36,870 --> 00:16:42,660
newest example his point was typically

00:16:40,170 --> 00:16:44,160
code like this occurs intermeshed with

00:16:42,660 --> 00:16:45,629
other more complex code in

00:16:44,160 --> 00:16:47,970
their operations so that there is not a

00:16:45,629 --> 00:16:49,709
shortcut out the usual solution to the

00:16:47,970 --> 00:16:51,540
problem is to put in flag variables

00:16:49,709 --> 00:16:52,259
which slows down your code and makes it

00:16:51,540 --> 00:16:54,569
less readable

00:16:52,259 --> 00:16:57,600
we'll start with found equal false if we

00:16:54,569 --> 00:17:00,360
find the target value is true we will

00:16:57,600 --> 00:17:02,759
change the flag and then act on the F

00:17:00,360 --> 00:17:05,189
flag at the end there's a better way a

00:17:02,759 --> 00:17:06,449
way that is shocking and jarring to most

00:17:05,189 --> 00:17:07,829
people coming from other programming

00:17:06,449 --> 00:17:10,799
languages because they've never seen it

00:17:07,829 --> 00:17:14,189
before and it was nice ideas not quito's

00:17:10,799 --> 00:17:16,500
and now we actually have else clauses on

00:17:14,189 --> 00:17:18,270
for lips remember the for loop has

00:17:16,500 --> 00:17:20,309
essentially got an if inside and it's

00:17:18,270 --> 00:17:22,620
saying if I haven't finished the loop

00:17:20,309 --> 00:17:24,270
keep doing the body if I haven't

00:17:22,620 --> 00:17:26,309
finished the loop keep doing the body

00:17:24,270 --> 00:17:30,059
what construct is normally associated

00:17:26,309 --> 00:17:32,340
with if-else so what the else means is I

00:17:30,059 --> 00:17:34,890
finished the body is there any more of

00:17:32,340 --> 00:17:36,450
the body of the loop to do no else so

00:17:34,890 --> 00:17:39,809
you can think of it that way inside

00:17:36,450 --> 00:17:41,580
every for internally there's a an if and

00:17:39,809 --> 00:17:43,620
go to and this is the else associated

00:17:41,580 --> 00:17:45,570
with that if some people have a hard

00:17:43,620 --> 00:17:47,100
time remembering that way if I could go

00:17:45,570 --> 00:17:48,900
back in time and talk to cuido if you

00:17:47,100 --> 00:17:50,940
give me the keys to the chyme machine I

00:17:48,900 --> 00:17:53,909
would say back when you first made this

00:17:50,940 --> 00:17:55,710
language else was exactly the right term

00:17:53,909 --> 00:17:58,289
because it's what Knuth used and people

00:17:55,710 --> 00:18:00,120
knew at that time all fours had embedded

00:17:58,289 --> 00:18:02,760
and if and go to underneath and they

00:18:00,120 --> 00:18:04,110
expected the else but in the future no

00:18:02,760 --> 00:18:06,150
one will know that because we're all

00:18:04,110 --> 00:18:09,510
using for structured programming already

00:18:06,150 --> 00:18:11,039
so why don't you call it no break if it

00:18:09,510 --> 00:18:13,289
was called no break everybody would know

00:18:11,039 --> 00:18:15,240
what it did there are two ways to exit

00:18:13,289 --> 00:18:17,640
this loop you can finish it normally or

00:18:15,240 --> 00:18:19,679
you can break out search search to your

00:18:17,640 --> 00:18:21,510
house file for the keys there are two

00:18:19,679 --> 00:18:23,039
outcomes you find the keys and come out

00:18:21,510 --> 00:18:24,960
or you search all the rooms and they're

00:18:23,039 --> 00:18:26,730
no more two possible outcomes they're

00:18:24,960 --> 00:18:28,950
distinguished with the else if that was

00:18:26,730 --> 00:18:30,929
caused called no break even know what it

00:18:28,950 --> 00:18:33,330
did if we finish the loop and didn't

00:18:30,929 --> 00:18:35,520
encounter a break return minus one if we

00:18:33,330 --> 00:18:37,830
finish the loop normally return I who

00:18:35,520 --> 00:18:38,400
learned something new now you know where

00:18:37,830 --> 00:18:40,440
it came from

00:18:38,400 --> 00:18:42,270
Donald Knuth guess what Cueto was a

00:18:40,440 --> 00:18:44,309
reading when he came up with this Donald

00:18:42,270 --> 00:18:46,289
Knuth guess what whether he was thinking

00:18:44,309 --> 00:18:47,820
about the future knew he would have

00:18:46,289 --> 00:18:49,590
called it a no break at which point

00:18:47,820 --> 00:18:51,390
everyone would know what it did just

00:18:49,590 --> 00:18:54,440
like if we called lambda make function

00:18:51,390 --> 00:18:58,640
no one would say what is lambda do

00:18:54,440 --> 00:19:01,100
it would be called make function alright

00:18:58,640 --> 00:19:02,840
dictionary skills those have you been in

00:19:01,100 --> 00:19:04,040
my classes before you know I start out

00:19:02,840 --> 00:19:05,150
with dictionaries at the beginning and

00:19:04,040 --> 00:19:07,100
covering them the second day the third

00:19:05,150 --> 00:19:08,360
day and the last day because there's two

00:19:07,100 --> 00:19:10,160
kinds of people in the world people

00:19:08,360 --> 00:19:12,620
who've mastered dictionaries and total

00:19:10,160 --> 00:19:14,060
goobers all right they are the

00:19:12,620 --> 00:19:15,590
fundamental tools for expressing

00:19:14,060 --> 00:19:17,270
relationships linking counting and

00:19:15,590 --> 00:19:20,120
grouping here's your core dictionary

00:19:17,270 --> 00:19:25,550
skills how to loop over the keys for K

00:19:20,120 --> 00:19:27,560
and D nobody clapped I didn't do that

00:19:25,550 --> 00:19:30,380
one cuido did that one but I got two he

00:19:27,560 --> 00:19:31,940
was sitting on the wire what should the

00:19:30,380 --> 00:19:34,970
for loop would do with the dictionary

00:19:31,940 --> 00:19:36,680
half of the people wanted the for loop

00:19:34,970 --> 00:19:38,750
to return the key and the value at the

00:19:36,680 --> 00:19:40,850
same time the other half just wanted the

00:19:38,750 --> 00:19:42,620
key I went and researched what other

00:19:40,850 --> 00:19:46,610
programming languages did went back into

00:19:42,620 --> 00:19:48,890
small talk a grip through a lot of

00:19:46,610 --> 00:19:50,630
existing code doing counts and see what

00:19:48,890 --> 00:19:52,160
people most needed most of the time when

00:19:50,630 --> 00:19:54,350
they looped over I looked to see what

00:19:52,160 --> 00:19:57,860
was consistent with if you wanted to

00:19:54,350 --> 00:20:01,430
treat a list as a dictionary the indices

00:19:57,860 --> 00:20:03,050
of a list are parallel to the keys in a

00:20:01,430 --> 00:20:05,660
dictionary and I kind of laid out a

00:20:03,050 --> 00:20:09,380
argument and leave a tip the scales and

00:20:05,660 --> 00:20:11,150
that's why it's for K and D these are

00:20:09,380 --> 00:20:12,650
another way to loop over the keys yes

00:20:11,150 --> 00:20:14,450
you could just ask for the keys and loop

00:20:12,650 --> 00:20:16,310
over when should you do the second not

00:20:14,450 --> 00:20:18,260
the first it's when you're mutating out

00:20:16,310 --> 00:20:20,000
the dictionary and the first way if you

00:20:18,260 --> 00:20:21,410
want to mutate the dictionary you can't

00:20:20,000 --> 00:20:23,300
do that while you're iterating over in

00:20:21,410 --> 00:20:25,070
fact in any programming language for the

00:20:23,300 --> 00:20:27,050
most part if you mutate something while

00:20:25,070 --> 00:20:28,520
you're writing over it you're living in

00:20:27,050 --> 00:20:30,270
a state of sin and you deserve whatever

00:20:28,520 --> 00:20:34,020
happens to you

00:20:30,270 --> 00:20:35,820
in this case though DDOT Keys calls the

00:20:34,020 --> 00:20:37,260
keys argument it makes a copy of all the

00:20:35,820 --> 00:20:38,970
keys and stores them in the list at

00:20:37,260 --> 00:20:40,920
which point it is you are free to go

00:20:38,970 --> 00:20:44,340
mutate the dictionary and delete all the

00:20:40,920 --> 00:20:45,960
keys that's a start with our leaving

00:20:44,340 --> 00:20:48,000
just Matthew that's kind of the way it

00:20:45,960 --> 00:20:49,380
is around the house all the keys that

00:20:48,000 --> 00:20:50,040
started with Oregon and now it's just

00:20:49,380 --> 00:20:51,960
Matthew

00:20:50,040 --> 00:20:57,900
I brought him to Pike on people just

00:20:51,960 --> 00:21:00,720
come up to me and oh and they look it

00:20:57,900 --> 00:21:05,640
right at the baby I deleted all the keys

00:21:00,720 --> 00:21:09,390
starting with our okay next one more

00:21:05,640 --> 00:21:11,640
ways to stand quite forward if I pitched

00:21:09,390 --> 00:21:13,200
forward you'll know what happened okay

00:21:11,640 --> 00:21:15,540
looping over to the keys and values at

00:21:13,200 --> 00:21:17,790
the same time one way is to loop over

00:21:15,540 --> 00:21:21,270
the key and then look up the value it's

00:21:17,790 --> 00:21:24,000
it very fast no because it has to rehash

00:21:21,270 --> 00:21:26,040
every key and go do a look-up on it if

00:21:24,000 --> 00:21:29,280
you actually need the values there's a

00:21:26,040 --> 00:21:31,800
better way my items and so we're using

00:21:29,280 --> 00:21:33,270
tupple unpacking here if you need both

00:21:31,800 --> 00:21:35,430
loop over them directly

00:21:33,270 --> 00:21:38,430
no lookups are involved is there a

00:21:35,430 --> 00:21:42,150
better way yeah because items makes a

00:21:38,430 --> 00:21:44,190
big huge list the better way is enter

00:21:42,150 --> 00:21:45,900
items so iterate on so we'll return an

00:21:44,190 --> 00:21:49,710
iterator you might clap on the I didn't

00:21:45,900 --> 00:21:51,630
do that I think that one was berry berry

00:21:49,710 --> 00:21:55,470
Warsaw okay

00:21:51,630 --> 00:21:59,040
yay for berry okay another berry looping

00:21:55,470 --> 00:22:01,800
over the dictionary of in that's a from

00:21:59,040 --> 00:22:04,680
pairs in pairs but to loop over them

00:22:01,800 --> 00:22:05,550
together oh constructing a dictionary

00:22:04,680 --> 00:22:08,730
yes

00:22:05,550 --> 00:22:10,110
so zip is fantastic because as it

00:22:08,730 --> 00:22:11,760
assembles the pairs the dictionary

00:22:10,110 --> 00:22:13,650
constructor you might not have known

00:22:11,760 --> 00:22:15,960
will accept a list of pairs or any

00:22:13,650 --> 00:22:17,730
iterable of pairs so the easiest way to

00:22:15,960 --> 00:22:19,980
assemble these two into a dictionary is

00:22:17,730 --> 00:22:23,070
to i zip them together if you marvel at

00:22:19,980 --> 00:22:24,540
this one and I think you should the

00:22:23,070 --> 00:22:26,460
thing to the thought to go away with is

00:22:24,540 --> 00:22:28,350
the parts in Python fit beautifully

00:22:26,460 --> 00:22:29,550
together how do you take two lists and

00:22:28,350 --> 00:22:31,920
join them together seamlessly and

00:22:29,550 --> 00:22:34,410
construct a dictionary it is one two

00:22:31,920 --> 00:22:36,990
three four words of Python it doesn't

00:22:34,410 --> 00:22:38,580
get much more beautiful than that look

00:22:36,990 --> 00:22:39,990
back through how you're building up your

00:22:38,580 --> 00:22:42,150
dictionaries if you already have the

00:22:39,990 --> 00:22:42,720
inputs available izip is a fantastic way

00:22:42,150 --> 00:22:44,039
to do it

00:22:42,720 --> 00:22:48,029
let's i zip a better way

00:22:44,039 --> 00:22:51,479
do this then zip yes now it still has to

00:22:48,029 --> 00:22:54,419
make a couple in each iteration right no

00:22:51,479 --> 00:22:56,399
I went in put it inside I checked the

00:22:54,419 --> 00:22:58,619
reference counter after the dictionary

00:22:56,399 --> 00:23:00,210
has consumed the tupple we loop back

00:22:58,619 --> 00:23:01,649
around to make the next level we reuse

00:23:00,210 --> 00:23:04,529
the previous one so it can actually

00:23:01,649 --> 00:23:07,559
build this without entering any inter

00:23:04,529 --> 00:23:09,539
meaning intervening calls to the

00:23:07,559 --> 00:23:11,309
allocator it just takes one top one

00:23:09,539 --> 00:23:14,009
raises it over and over again in other

00:23:11,309 --> 00:23:15,809
words is this fast yeah absolutely

00:23:14,009 --> 00:23:17,960
well I still got 15 minutes left that's

00:23:15,809 --> 00:23:20,249
great how to count with a dictionary you

00:23:17,960 --> 00:23:22,229
guys probably know a number of ways to

00:23:20,249 --> 00:23:25,080
count when you teach people Python

00:23:22,229 --> 00:23:27,389
dictionaries show them get first oh and

00:23:25,080 --> 00:23:29,190
show them the most basic methods first

00:23:27,389 --> 00:23:30,749
so these are the most basic ways to loop

00:23:29,190 --> 00:23:32,729
over a dictionary loop over the colors

00:23:30,749 --> 00:23:37,259
check to see if the colors not there if

00:23:32,729 --> 00:23:39,629
it's not there adding since now a square

00:23:37,259 --> 00:23:41,249
bracket lookup is conditional it can

00:23:39,629 --> 00:23:43,019
fail if the key is not there

00:23:41,249 --> 00:23:45,629
raising a key here but in this case

00:23:43,019 --> 00:23:47,549
we've just put the key in so we know

00:23:45,629 --> 00:23:48,389
it's there this will this last line will

00:23:47,549 --> 00:23:50,429
always succeed

00:23:48,389 --> 00:23:52,529
this is a simple basic way to count

00:23:50,429 --> 00:23:53,879
everyone should know how to do it don't

00:23:52,529 --> 00:23:55,559
immediately start them with the most

00:23:53,879 --> 00:23:58,049
advanced thing because if a person can't

00:23:55,559 --> 00:23:59,279
do this they will be helpless on any

00:23:58,049 --> 00:24:01,559
more complex problem with our

00:23:59,279 --> 00:24:04,109
dictionaries should you start them right

00:24:01,559 --> 00:24:06,869
away with default dicks and whatnot you

00:24:04,109 --> 00:24:08,249
start them this way what's the next

00:24:06,869 --> 00:24:09,690
level of improvement over this if I

00:24:08,249 --> 00:24:13,099
don't want to use anything exotic and I

00:24:09,690 --> 00:24:15,389
want to use the core dictionary API

00:24:13,099 --> 00:24:16,859
those of you in my classes I threaten

00:24:15,389 --> 00:24:18,419
you all the time with math you will

00:24:16,859 --> 00:24:20,609
remain fatherless unless you know this

00:24:18,419 --> 00:24:21,749
particular method I threatened to keep

00:24:20,609 --> 00:24:25,109
people an extra day if they don't know

00:24:21,749 --> 00:24:27,179
this the method is get yeah set default

00:24:25,109 --> 00:24:29,700
sets in the case of accounting all we

00:24:27,179 --> 00:24:31,979
need is I get and so the code up above

00:24:29,700 --> 00:24:34,259
simplifies to this we get the color the

00:24:31,979 --> 00:24:36,539
colors missing return zero and add one

00:24:34,259 --> 00:24:38,549
to it we don't need a set default all we

00:24:36,539 --> 00:24:42,029
need is the zero we need to look up to

00:24:38,549 --> 00:24:47,159
not fail is there a more modern way yeah

00:24:42,029 --> 00:24:49,499
what is it default date when I answer a

00:24:47,159 --> 00:24:50,909
question on Stack Overflow and I put one

00:24:49,499 --> 00:24:53,039
of these first two please don't

00:24:50,909 --> 00:24:54,720
immediately go change it to default dick

00:24:53,039 --> 00:24:56,340
all you're doing is taking somebody who

00:24:54,720 --> 00:24:57,140
couldn't count in the first place and

00:24:56,340 --> 00:24:58,370
then

00:24:57,140 --> 00:24:59,870
into where they have to import the

00:24:58,370 --> 00:25:01,580
collections learn the distinction

00:24:59,870 --> 00:25:03,770
between a regular dictionary and default

00:25:01,580 --> 00:25:05,630
dictionary they have to know that about

00:25:03,770 --> 00:25:08,060
factory functions they have to know the

00:25:05,630 --> 00:25:11,690
int because no arguments producing the

00:25:08,060 --> 00:25:13,340
value of 0 oh and then when they get

00:25:11,690 --> 00:25:14,930
something back it's not actually a

00:25:13,340 --> 00:25:16,520
dictionary it's a default ticked and

00:25:14,930 --> 00:25:18,620
needs to be converted back for some use

00:25:16,520 --> 00:25:20,870
cases in other words if you hand this to

00:25:18,620 --> 00:25:22,670
a beginner you usually made them worse

00:25:20,870 --> 00:25:25,760
off make sure they know the first idioms

00:25:22,670 --> 00:25:28,340
of before they drive on but that said

00:25:25,760 --> 00:25:31,580
what I use is this or I use collections

00:25:28,340 --> 00:25:34,340
I'll counter okay how to group with the

00:25:31,580 --> 00:25:36,470
dictionaries this is an example I've

00:25:34,340 --> 00:25:38,540
used over and over again how do i group

00:25:36,470 --> 00:25:40,340
these names together I forgot what I've

00:25:38,540 --> 00:25:42,890
grouped them by their length of their

00:25:40,340 --> 00:25:44,870
first letter the traditional way use

00:25:42,890 --> 00:25:46,700
that a person should learn first is

00:25:44,870 --> 00:25:47,930
start with an empty dictionary the key

00:25:46,700 --> 00:25:50,660
of the dictionary is what you're

00:25:47,930 --> 00:25:52,820
grouping by so Raymond is of length 7

00:25:50,660 --> 00:25:54,560
that will be the key and the value will

00:25:52,820 --> 00:25:56,690
be a list of all of the names of a

00:25:54,560 --> 00:25:59,030
length 7 if you'd like to accumulate a

00:25:56,690 --> 00:26:00,710
lot of points on stackoverflow know this

00:25:59,030 --> 00:26:02,920
because this question get asked gets

00:26:00,710 --> 00:26:05,330
asked about once a week

00:26:02,920 --> 00:26:07,070
what should you immediately take them to

00:26:05,330 --> 00:26:10,910
when someone wants to group the

00:26:07,070 --> 00:26:13,700
collections module mu how about show

00:26:10,910 --> 00:26:15,830
them set set default so this one the

00:26:13,700 --> 00:26:18,260
output of it by the way is Roger has

00:26:15,830 --> 00:26:20,570
five letters a Raymond Matthew Melissa

00:26:18,260 --> 00:26:23,840
and Charlie all have seven Rachel Anna

00:26:20,570 --> 00:26:25,310
juditha have six by the way if you're

00:26:23,840 --> 00:26:27,500
grouping by anything else you only need

00:26:25,310 --> 00:26:29,840
to change the key line maybe the key is

00:26:27,500 --> 00:26:33,080
name zero that will group people by the

00:26:29,840 --> 00:26:35,420
first letter name minus one key could be

00:26:33,080 --> 00:26:37,400
the number of e's in the name you can

00:26:35,420 --> 00:26:39,170
group by just in almost anything using

00:26:37,400 --> 00:26:41,660
this idiom there's a better way though

00:26:39,170 --> 00:26:43,070
it's set default we actually need set

00:26:41,660 --> 00:26:44,840
default because we want to return the

00:26:43,070 --> 00:26:47,030
list so we can append to it but we also

00:26:44,840 --> 00:26:48,470
need it to be inserted in set default is

00:26:47,030 --> 00:26:51,080
just like get but it has a side-effect

00:26:48,470 --> 00:26:53,270
of inserting a missing key for a long

00:26:51,080 --> 00:26:55,370
time this was the idiom for grouping in

00:26:53,270 --> 00:26:58,730
Python I think it is not particularly

00:26:55,370 --> 00:27:01,940
beautiful Python though how the word set

00:26:58,730 --> 00:27:03,440
default is really bad and everybody

00:27:01,940 --> 00:27:05,240
thinks it's awful but no one can think

00:27:03,440 --> 00:27:07,610
of a better name every other name we've

00:27:05,240 --> 00:27:09,020
ever experimented with had like about 50

00:27:07,610 --> 00:27:10,190
letters in - well this goes into a

00:27:09,020 --> 00:27:11,000
dictionary it looks to see if a keys

00:27:10,190 --> 00:27:13,340
there if it's not

00:27:11,000 --> 00:27:14,840
it takes the default value and sorts it

00:27:13,340 --> 00:27:16,580
into and returns it so you can group

00:27:14,840 --> 00:27:20,030
with it that would actually be the best

00:27:16,580 --> 00:27:23,059
name but it's a little long and now the

00:27:20,030 --> 00:27:25,970
modern way transferred your transform

00:27:23,059 --> 00:27:28,130
your code into this default dict list

00:27:25,970 --> 00:27:30,110
that will create a new list and it is

00:27:28,130 --> 00:27:33,799
far more beautiful than this original

00:27:30,110 --> 00:27:35,330
six lines and slow four lines and fast

00:27:33,799 --> 00:27:37,340
that is the new idiom for how to group

00:27:35,330 --> 00:27:39,650
things in Python you must know how to do

00:27:37,340 --> 00:27:41,539
it but only must you know how to do it

00:27:39,650 --> 00:27:43,520
my presentation is intended is a

00:27:41,539 --> 00:27:44,960
checklist for you when you go back check

00:27:43,520 --> 00:27:46,669
out your code base and find out

00:27:44,960 --> 00:27:50,270
look where everywhere you're doing this

00:27:46,669 --> 00:27:51,620
or this replace it with this if you do

00:27:50,270 --> 00:27:54,110
all the replacements in my slide deck

00:27:51,620 --> 00:27:56,059
it'll narrow speed up your code quite a

00:27:54,110 --> 00:27:59,330
bit it'll make it more maintainable and

00:27:56,059 --> 00:28:02,150
more beautiful Oh an interesting one is

00:27:59,330 --> 00:28:03,830
a pop item how you might clap on this

00:28:02,150 --> 00:28:06,289
one or might not I can't remember what I

00:28:03,830 --> 00:28:07,970
made either pop or I made pop item but

00:28:06,289 --> 00:28:10,490
I'm not sure which one it was a long

00:28:07,970 --> 00:28:12,350
time ago it was my first or second

00:28:10,490 --> 00:28:14,539
contribution to Python was putting in

00:28:12,350 --> 00:28:16,039
Python it must have been the second

00:28:14,539 --> 00:28:18,020
because the first contribution was I

00:28:16,039 --> 00:28:19,370
volunteered to put Doc's drinks in all

00:28:18,020 --> 00:28:21,799
bunch of modules do you guys use any

00:28:19,370 --> 00:28:23,419
dark strings yeah I put ma I put about

00:28:21,799 --> 00:28:26,840
half of them in there originally they

00:28:23,419 --> 00:28:29,270
just were mostly empty is that a good

00:28:26,840 --> 00:28:31,789
way to join an open-source project yes

00:28:29,270 --> 00:28:33,770
if you go through putting doc strings

00:28:31,789 --> 00:28:35,240
everywhere one people love you for it -

00:28:33,770 --> 00:28:36,799
you make the code more usable but as a

00:28:35,240 --> 00:28:39,169
side-effect you actually learn what

00:28:36,799 --> 00:28:40,850
every module does or you can start

00:28:39,169 --> 00:28:42,770
another way how about you take the most

00:28:40,850 --> 00:28:44,780
popular important data structure a

00:28:42,770 --> 00:28:46,280
dictionary and mangle it and transform

00:28:44,780 --> 00:28:47,929
it into some radical way and changes

00:28:46,280 --> 00:28:50,980
performance characteristics this a good

00:28:47,929 --> 00:28:53,270
way to start now someone recently did I

00:28:50,980 --> 00:28:56,750
growled at them earlier is the only

00:28:53,270 --> 00:28:58,970
person I growled at at PyCon ok so a pop

00:28:56,750 --> 00:29:01,880
item I might or might not have put in it

00:28:58,970 --> 00:29:03,740
removes an arbitrary item the

00:29:01,880 --> 00:29:05,840
interesting thing about it is is atomic

00:29:03,740 --> 00:29:07,400
so you don't have to put locks around it

00:29:05,840 --> 00:29:09,559
so it can be used between threads to

00:29:07,400 --> 00:29:12,049
atomically pull out a task who learned

00:29:09,559 --> 00:29:14,809
something new all right

00:29:12,049 --> 00:29:16,820
linking dictionaries together this kind

00:29:14,809 --> 00:29:19,250
of code is reasonably common we have one

00:29:16,820 --> 00:29:23,240
dictionary which has some default values

00:29:19,250 --> 00:29:24,559
for some parameters in addition we coart

00:29:23,240 --> 00:29:26,149
parse and

00:29:24,559 --> 00:29:28,700
ferb are some command-line arguments

00:29:26,149 --> 00:29:31,610
that are optional so a user can specify

00:29:28,700 --> 00:29:34,370
the command-line the user our color or

00:29:31,610 --> 00:29:37,879
they cannot specify it and lastly I have

00:29:34,370 --> 00:29:40,549
a third dictionary which is not showing

00:29:37,879 --> 00:29:42,200
here the third dictionary is OS environ

00:29:40,549 --> 00:29:44,210
which is not really a dictionary but it

00:29:42,200 --> 00:29:46,429
looks like one which gets environment

00:29:44,210 --> 00:29:48,649
variables it is common to want to chain

00:29:46,429 --> 00:29:50,330
these together and the traditional way

00:29:48,649 --> 00:29:52,909
to do it one that I actually found in

00:29:50,330 --> 00:29:54,980
the standard library was you copy the

00:29:52,909 --> 00:29:57,110
dictionary full of defaults then you do

00:29:54,980 --> 00:29:59,360
an update from the environment that way

00:29:57,110 --> 00:30:00,950
you have some standard defaults and then

00:29:59,360 --> 00:30:03,169
if someone specifies an environment

00:30:00,950 --> 00:30:04,549
variable it overrides environment

00:30:03,169 --> 00:30:06,830
variables take precedence over the

00:30:04,549 --> 00:30:08,419
internal defaults but a command-line

00:30:06,830 --> 00:30:10,129
argument should take precedence over the

00:30:08,419 --> 00:30:11,690
environment variables this kind of code

00:30:10,129 --> 00:30:14,419
is very common how many of you have

00:30:11,690 --> 00:30:15,409
written some code like this ever is it

00:30:14,419 --> 00:30:17,720
the right way to do it

00:30:15,409 --> 00:30:19,580
well a copies data like crazy if you

00:30:17,720 --> 00:30:21,980
want your code to be fast don't copy

00:30:19,580 --> 00:30:25,490
like crazy so chain map has been

00:30:21,980 --> 00:30:26,990
introduced into Python 3 and it links

00:30:25,490 --> 00:30:28,309
them all together it leaves the three

00:30:26,990 --> 00:30:30,080
independent dictionaries and just looks

00:30:28,309 --> 00:30:32,269
up in the first one command line if it

00:30:30,080 --> 00:30:33,529
doesn't fault do it there it looks in

00:30:32,269 --> 00:30:35,629
the environment if it doesn't find it

00:30:33,529 --> 00:30:37,759
there it falls back to defaults this way

00:30:35,629 --> 00:30:39,919
is fast and beautiful and it's my config

00:30:37,759 --> 00:30:41,350
parser is no longer slow thanks for the

00:30:39,919 --> 00:30:44,090
applause alone that was me

00:30:41,350 --> 00:30:45,919
improving clarity I have so few minutes

00:30:44,090 --> 00:30:47,179
left but I have some leave 5 minutes for

00:30:45,919 --> 00:30:50,029
Q&A do you guys want to blow off your

00:30:47,179 --> 00:30:51,889
Q&A and get more of these slides cool no

00:30:50,029 --> 00:30:54,409
questions you don't even have time for a

00:30:51,889 --> 00:30:55,940
yes all right wherever you have

00:30:54,409 --> 00:30:57,289
positional arguments and indices that's

00:30:55,940 --> 00:30:59,809
nice you can do that in any language

00:30:57,289 --> 00:31:01,369
keywords and names are better the first

00:30:59,809 --> 00:31:03,379
way where you're using indices that's

00:31:01,369 --> 00:31:06,139
convenient for the computer and fast in

00:31:03,379 --> 00:31:08,720
the language like C but the naming

00:31:06,139 --> 00:31:11,840
things is how humans think so a way to

00:31:08,720 --> 00:31:14,360
improve your oh did we start with the

00:31:11,840 --> 00:31:17,960
answer on that one there we go oh that

00:31:14,360 --> 00:31:19,490
we're out of order then so the top one

00:31:17,960 --> 00:31:21,529
is the kind of code that I see all over

00:31:19,490 --> 00:31:25,129
the pace in client-side customer bases

00:31:21,529 --> 00:31:26,869
it calls a Twitter search Obama falls 20

00:31:25,129 --> 00:31:29,480
and true raising the question what is

00:31:26,869 --> 00:31:31,429
the 20 the false and the true 2 you

00:31:29,480 --> 00:31:33,070
would have to have memorize the argument

00:31:31,429 --> 00:31:35,179
signature in order to check that a

00:31:33,070 --> 00:31:37,009
simple way to improve the readability of

00:31:35,179 --> 00:31:38,360
your code is to go find everywhere where

00:31:37,009 --> 00:31:39,620
you're making an obscure call like

00:31:38,360 --> 00:31:41,420
and just replace it with keyword

00:31:39,620 --> 00:31:43,310
arguments it's an easy thing to do it

00:31:41,420 --> 00:31:45,310
slows down your code just a little bit

00:31:43,310 --> 00:31:47,720
but really what are you trying to save

00:31:45,310 --> 00:31:50,510
microseconds are hours of a programmer

00:31:47,720 --> 00:31:53,510
time hours of programmer time those are

00:31:50,510 --> 00:31:55,460
the ones that cost you so this is a

00:31:53,510 --> 00:31:56,840
simple transformation in fact if you're

00:31:55,460 --> 00:31:58,160
a junior programmer just starting out

00:31:56,840 --> 00:32:00,350
you would like to improve your company's

00:31:58,160 --> 00:32:02,960
entire code base go through and do this

00:32:00,350 --> 00:32:04,700
everywhere make sure you don't do it in

00:32:02,960 --> 00:32:06,590
a middle of a tight loop but mostly

00:32:04,700 --> 00:32:09,050
everywhere and it will make the code

00:32:06,590 --> 00:32:11,270
better profoundly better and who will be

00:32:09,050 --> 00:32:12,620
the first consumer of this you because

00:32:11,270 --> 00:32:13,940
you're the new person to the company and

00:32:12,620 --> 00:32:16,250
don't know the code base you'll know it

00:32:13,940 --> 00:32:18,260
really well after you've done this it's

00:32:16,250 --> 00:32:21,320
an easy way to improve quote quality

00:32:18,260 --> 00:32:24,740
name tuples it used to be if you call

00:32:21,320 --> 00:32:26,270
doc test test mod it returns zero for at

00:32:24,740 --> 00:32:29,000
the tupple is that a good thing or a bad

00:32:26,270 --> 00:32:32,240
thing are you happy or sad when you get

00:32:29,000 --> 00:32:34,940
0 for you don't know that is what it

00:32:32,240 --> 00:32:36,830
returned for most of its existence now

00:32:34,940 --> 00:32:38,420
it returns test results failed equals

00:32:36,830 --> 00:32:41,660
zero attempted equal for are you happy

00:32:38,420 --> 00:32:43,190
or sad which is a better output is the

00:32:41,660 --> 00:32:45,650
second output substitutable for the

00:32:43,190 --> 00:32:47,540
first sure name tuples are a subclass of

00:32:45,650 --> 00:32:49,340
tuples so they've they still work like a

00:32:47,540 --> 00:32:51,230
regular couple they just tell you what

00:32:49,340 --> 00:32:52,970
they say and how the way you make the

00:32:51,230 --> 00:32:54,590
name couple is simple you just say we're

00:32:52,970 --> 00:32:56,630
defining test results as having two

00:32:54,590 --> 00:32:58,760
fields failed and attempted easy enough

00:32:56,630 --> 00:33:01,340
this is a very easy way to improve your

00:32:58,760 --> 00:33:03,350
code base basically all over the place

00:33:01,340 --> 00:33:05,600
go put named tuples and now all of your

00:33:03,350 --> 00:33:07,820
output messages an error messages will

00:33:05,600 --> 00:33:11,390
be much more readable the person who

00:33:07,820 --> 00:33:14,020
benefits from this will be you there we

00:33:11,390 --> 00:33:17,720
go all right now is the name couple guy

00:33:14,020 --> 00:33:20,980
unpacking a sequences Raymond heading

00:33:17,720 --> 00:33:20,980
sure who's a young man in hex

00:33:21,530 --> 00:33:26,590
I can pull out the fields this way why

00:33:24,560 --> 00:33:29,360
would you do it this first way the

00:33:26,590 --> 00:33:30,830
answer is that's what you do in almost

00:33:29,360 --> 00:33:33,110
every other programming language that

00:33:30,830 --> 00:33:35,810
you know give yourself another five

00:33:33,110 --> 00:33:38,030
minutes for Q&A time there okay so

00:33:35,810 --> 00:33:39,590
people do this mainly because it works

00:33:38,030 --> 00:33:40,970
in all other programming languages and

00:33:39,590 --> 00:33:43,880
they do it out of habit the better way

00:33:40,970 --> 00:33:46,460
is the ones listed here septuple

00:33:43,880 --> 00:33:48,110
unpacking and it pulls out the four

00:33:46,460 --> 00:33:51,410
fields for you the second ones more

00:33:48,110 --> 00:33:52,910
readable and it's faster this is an easy

00:33:51,410 --> 00:33:54,710
change to make it's an easy thing to

00:33:52,910 --> 00:33:56,780
grep for everywhere you see bracket 0

00:33:54,710 --> 00:33:58,310
brackets 1 brackets 2 brackets 3 you

00:33:56,780 --> 00:34:00,050
know what's going on replace it with

00:33:58,310 --> 00:34:03,290
unpacking your code is better and faster

00:34:00,050 --> 00:34:07,100
easy change so how do you do

00:34:03,290 --> 00:34:09,710
simultaneous data updates the

00:34:07,100 --> 00:34:12,710
traditional way to write the Fibonacci

00:34:09,710 --> 00:34:15,950
is to take a temporary variable for Y

00:34:12,710 --> 00:34:18,649
add up your new Y and then I use your

00:34:15,950 --> 00:34:20,690
temporary variable I hate this code I've

00:34:18,649 --> 00:34:23,330
written code like it a lot of times

00:34:20,690 --> 00:34:25,460
because I started with a 1967 version of

00:34:23,330 --> 00:34:27,800
Dartmouth basic and it was all I had

00:34:25,460 --> 00:34:31,429
but there's a better way you can use the

00:34:27,800 --> 00:34:32,929
topo packing and unpacking don't

00:34:31,429 --> 00:34:34,820
overlook how important it is it's

00:34:32,929 --> 00:34:37,340
profoundly important the problem with

00:34:34,820 --> 00:34:39,110
that ok well first I'll show you the

00:34:37,340 --> 00:34:40,490
correct solution the correct solution

00:34:39,110 --> 00:34:43,940
the way you'll often see it written is

00:34:40,490 --> 00:34:46,879
with simultaneous variable updates the Y

00:34:43,940 --> 00:34:49,790
and the X plus y use the old values of x

00:34:46,879 --> 00:34:51,649
and y to build the double then they get

00:34:49,790 --> 00:34:53,840
unpacked and stored in the variables the

00:34:51,649 --> 00:34:55,940
X and Y are state the state should be

00:34:53,840 --> 00:34:57,350
updated all at once if you don't update

00:34:55,940 --> 00:34:59,750
the state all at once and put it on

00:34:57,350 --> 00:35:01,940
multiple lines derp in between those

00:34:59,750 --> 00:35:05,900
lines the state is currently mismatched

00:35:01,940 --> 00:35:08,690
at one point x ry is the new Y and X is

00:35:05,900 --> 00:35:10,790
the old X this is a very common source

00:35:08,690 --> 00:35:12,650
of problems and plus the ordering

00:35:10,790 --> 00:35:15,140
matters here if I make up the order of

00:35:12,650 --> 00:35:17,720
these three it breaks the code and it's

00:35:15,140 --> 00:35:19,640
a hard error to see the last thing I

00:35:17,720 --> 00:35:23,060
don't like about it besides the risk of

00:35:19,640 --> 00:35:24,770
our order is it's too low level it's on

00:35:23,060 --> 00:35:26,300
the next slide I'll talk about taking an

00:35:24,770 --> 00:35:28,520
atom and breaking it into subatomic

00:35:26,300 --> 00:35:30,800
particles this has been broken into some

00:35:28,520 --> 00:35:33,620
atomic particles what does this say this

00:35:30,800 --> 00:35:34,940
says take wine store T X plus y 2 y and

00:35:33,620 --> 00:35:36,890
T 2 X

00:35:34,940 --> 00:35:38,690
the second one says update these

00:35:36,890 --> 00:35:41,480
variables according to those equations

00:35:38,690 --> 00:35:43,849
and so you transform one to the other

00:35:41,480 --> 00:35:46,460
the second way is a higher-level way of

00:35:43,849 --> 00:35:49,400
thinking it doesn't risk getting the

00:35:46,460 --> 00:35:52,369
order wrong and it's fast and up I

00:35:49,400 --> 00:35:55,040
thought please transfer warm code like

00:35:52,369 --> 00:35:56,900
that into this lest I let that go it's

00:35:55,040 --> 00:35:59,329
got a whole additional slide and a half

00:35:56,900 --> 00:36:00,560
okay two slides file for this this is

00:35:59,329 --> 00:36:03,980
such an important product don't

00:36:00,560 --> 00:36:05,780
underestimate the advantages for this if

00:36:03,980 --> 00:36:08,510
you break this out into a pieces you

00:36:05,780 --> 00:36:11,089
risk ordering problems also you are

00:36:08,510 --> 00:36:13,609
making it to atomic you are losing the

00:36:11,089 --> 00:36:15,380
ability to chunk the your thoughts and

00:36:13,609 --> 00:36:17,599
to think higher level thoughts for

00:36:15,380 --> 00:36:20,000
example a problem I give when I teach a

00:36:17,599 --> 00:36:22,280
scientist is I give them the function

00:36:20,000 --> 00:36:24,200
influence that influence of one planet

00:36:22,280 --> 00:36:26,569
over another all they have to do is plot

00:36:24,200 --> 00:36:28,760
the orbit of the planet and you have

00:36:26,569 --> 00:36:30,079
some people get nice elliptical orbits

00:36:28,760 --> 00:36:32,510
and other people where it just kind of

00:36:30,079 --> 00:36:34,609
zig zags away the ones who get it wrong

00:36:32,510 --> 00:36:36,470
are the ones who wrote exactly this code

00:36:34,609 --> 00:36:38,270
except they didn't use the temporary

00:36:36,470 --> 00:36:40,579
variables if the first thing they wrote

00:36:38,270 --> 00:36:43,250
is X is equal to X plus D X plus T

00:36:40,579 --> 00:36:45,680
they're toast at that point why they've

00:36:43,250 --> 00:36:48,260
updated the X and now this one gets

00:36:45,680 --> 00:36:50,420
computed with the new X rather than the

00:36:48,260 --> 00:36:51,560
old X is a very common problem the other

00:36:50,420 --> 00:36:53,780
half of the people who write these

00:36:51,560 --> 00:36:54,380
temporary variables how do they know to

00:36:53,780 --> 00:36:55,940
do that

00:36:54,380 --> 00:36:58,190
the answer is they've all been burned by

00:36:55,940 --> 00:37:01,490
this problem before the correct answer

00:36:58,190 --> 00:37:03,920
is this do the calculations on the right

00:37:01,490 --> 00:37:06,890
with the old values of the variable the

00:37:03,920 --> 00:37:09,440
old x the old Y the old DX old DX dy

00:37:06,890 --> 00:37:12,109
take their partials and then only then

00:37:09,440 --> 00:37:13,490
update all of the variables this is a

00:37:12,109 --> 00:37:15,079
profound importance not just for

00:37:13,490 --> 00:37:16,730
scientific computing I can give other

00:37:15,079 --> 00:37:18,920
examples where people are doing a simple

00:37:16,730 --> 00:37:20,900
mortgage calculation with the principal

00:37:18,920 --> 00:37:22,190
and interest and whatnot and it's a very

00:37:20,900 --> 00:37:24,079
first thing they do is update the

00:37:22,190 --> 00:37:25,819
principal by principle minus equal

00:37:24,079 --> 00:37:27,920
payment they're toast because their

00:37:25,819 --> 00:37:29,960
interest payments going to be raw the

00:37:27,920 --> 00:37:32,270
interesting thing to me is not that they

00:37:29,960 --> 00:37:34,190
get it wrong when they program in any

00:37:32,270 --> 00:37:35,839
language the interesting thing is I can

00:37:34,190 --> 00:37:38,420
give them the same problem in Excel and

00:37:35,839 --> 00:37:40,220
they always get it right why is it that

00:37:38,420 --> 00:37:42,230
people get it right in Excel and wrong

00:37:40,220 --> 00:37:45,020
in programming languages the answer is

00:37:42,230 --> 00:37:47,300
in Excel you take all the state on each

00:37:45,020 --> 00:37:48,830
row on month one here's the current

00:37:47,300 --> 00:37:51,140
principal interest in

00:37:48,830 --> 00:37:53,600
but not all months - it's this and

00:37:51,140 --> 00:37:55,160
people naturally refer to the they take

00:37:53,600 --> 00:37:57,650
their formulas and they refer up to the

00:37:55,160 --> 00:37:59,780
previous row all Excel people do this

00:37:57,650 --> 00:38:02,420
essentially they are doing exactly this

00:37:59,780 --> 00:38:03,890
operation you could view this as what's

00:38:02,420 --> 00:38:05,630
on the right is referring to the

00:38:03,890 --> 00:38:08,720
previous row and what's on the left is

00:38:05,630 --> 00:38:10,160
the new row and that gets I iterated in

00:38:08,720 --> 00:38:11,810
other words it's a very natural style of

00:38:10,160 --> 00:38:14,540
thinking please don't write code like

00:38:11,810 --> 00:38:15,980
that write code like that this is a big

00:38:14,540 --> 00:38:17,630
deal that we've got it in this language

00:38:15,980 --> 00:38:18,800
it will save you from a lot of trouble

00:38:17,630 --> 00:38:21,110
I've got one minute

00:38:18,800 --> 00:38:22,930
efficiency I'll do a fishin C fast

00:38:21,110 --> 00:38:27,080
basically just don't move data around

00:38:22,930 --> 00:38:28,730
unnecessarily concatenated strings in my

00:38:27,080 --> 00:38:30,800
classes I tell an Aggie choke or aw

00:38:28,730 --> 00:38:32,420
around this in order to hammer home this

00:38:30,800 --> 00:38:36,470
is quadratic behavior don't add your

00:38:32,420 --> 00:38:37,610
strings this way instead join them it

00:38:36,470 --> 00:38:39,740
sound like most of you knew that already

00:38:37,610 --> 00:38:42,410
go check your code base and see if your

00:38:39,740 --> 00:38:47,000
code base no set just saying updating

00:38:42,410 --> 00:38:49,550
sequences if you see a dill zero a pop

00:38:47,000 --> 00:38:52,250
zero or insert zero you're doing it

00:38:49,550 --> 00:38:53,570
wrong I go into a customer sites they

00:38:52,250 --> 00:38:55,100
say here's a million lines of code and

00:38:53,570 --> 00:38:56,750
it runs really slow can you make it go

00:38:55,100 --> 00:38:59,090
fast and see if I'm going to be able to

00:38:56,750 --> 00:39:00,350
read a million lines of code but 15

00:38:59,090 --> 00:39:01,550
minutes later I come back said have sped

00:39:00,350 --> 00:39:04,490
up your code what did I do

00:39:01,550 --> 00:39:06,260
I grabbed for these three things pretty

00:39:04,490 --> 00:39:08,810
much everywhere they did a Dell name

00:39:06,260 --> 00:39:10,310
zero a pop zero or insert zero they were

00:39:08,810 --> 00:39:15,590
using the wrong data structure what's

00:39:10,310 --> 00:39:18,110
the correct data structure deck yeah I

00:39:15,590 --> 00:39:18,860
did that anyway a deck well let's you do

00:39:18,110 --> 00:39:21,320
a UH

00:39:18,860 --> 00:39:24,160
you can delete names zero efficiently a

00:39:21,320 --> 00:39:27,140
pop left efficiently are a up and left

00:39:24,160 --> 00:39:29,870
efficiently decorators and context

00:39:27,140 --> 00:39:32,240
managers I have no seconds left but

00:39:29,870 --> 00:39:34,280
we're going into a break time of five

00:39:32,240 --> 00:39:35,990
minutes whoa we got we have time for

00:39:34,280 --> 00:39:38,360
decorators and context managers which

00:39:35,990 --> 00:39:40,370
completely Rock we're out of a novice

00:39:38,360 --> 00:39:42,020
territory and into really good stuff

00:39:40,370 --> 00:39:45,080
these are fantastic tools for

00:39:42,020 --> 00:39:47,240
refactoring your code but good naming is

00:39:45,080 --> 00:39:49,610
essential because it provides macro like

00:39:47,240 --> 00:39:51,470
capability meaning you can hide all

00:39:49,610 --> 00:39:54,230
kinds of awful actions behind the macro

00:39:51,470 --> 00:39:55,940
or you can be very clear so remember the

00:39:54,230 --> 00:39:59,660
Spider Man rule with great power comes

00:39:55,940 --> 00:40:02,690
great responsibility all right so I want

00:39:59,660 --> 00:40:05,180
to factor out some administrative

00:40:02,690 --> 00:40:07,460
logic the business logic here is opening

00:40:05,180 --> 00:40:09,530
a URL and returning a web page the

00:40:07,460 --> 00:40:11,599
administrative logic is I'm cashing it

00:40:09,530 --> 00:40:13,040
in a dictionary that way if I go look at

00:40:11,599 --> 00:40:14,930
the same web page over and over again I

00:40:13,040 --> 00:40:16,460
just simply remember it you'll see code

00:40:14,930 --> 00:40:17,930
like this all over the place in Python

00:40:16,460 --> 00:40:20,180
which trauma was trying to catch through

00:40:17,930 --> 00:40:22,160
lookups what I don't like about it is it

00:40:20,180 --> 00:40:24,890
mixes the admin logic with the business

00:40:22,160 --> 00:40:30,319
logic and it's not reusable simple fix

00:40:24,890 --> 00:40:32,450
at cache it's actually the LRU cache in

00:40:30,319 --> 00:40:34,190
Python 3 I have back ported it for

00:40:32,450 --> 00:40:36,560
people who want to scan for the back

00:40:34,190 --> 00:40:38,750
port you can start using it today that

00:40:36,560 --> 00:40:41,450
said these things are pretty easy to

00:40:38,750 --> 00:40:43,099
write on your own so I really want to

00:40:41,450 --> 00:40:44,839
demonstrate the decorators here less

00:40:43,099 --> 00:40:47,150
than what I've written with this is

00:40:44,839 --> 00:40:48,950
reusable I can put at cache in front of

00:40:47,150 --> 00:40:50,599
any pure function a pure function being

00:40:48,950 --> 00:40:53,300
one that returns the same value every

00:40:50,599 --> 00:40:55,430
time you call it random dot random is

00:40:53,300 --> 00:40:56,750
that a pure function nope because it

00:40:55,430 --> 00:40:58,880
gives it a different value every time

00:40:56,750 --> 00:41:00,020
you call it pal is that a pure function

00:40:58,880 --> 00:41:02,569
yep

00:41:00,020 --> 00:41:04,250
same answers every time the business

00:41:02,569 --> 00:41:06,380
logic has been separated from the admin

00:41:04,250 --> 00:41:08,480
logic and I've gotten reusability the

00:41:06,380 --> 00:41:11,089
way I write it is with a simple caching

00:41:08,480 --> 00:41:12,800
a decorator it only takes a few lines I

00:41:11,089 --> 00:41:14,810
would like for your utilities

00:41:12,800 --> 00:41:17,569
directories to be full of little tools

00:41:14,810 --> 00:41:20,050
like this so that elsewhere new code you

00:41:17,569 --> 00:41:23,420
put egg cache in the problem is solved

00:41:20,050 --> 00:41:25,819
factoring out temporary contexts for

00:41:23,420 --> 00:41:28,550
decimal so we get a we copied the

00:41:25,819 --> 00:41:30,500
context change the decimal precision to

00:41:28,550 --> 00:41:33,530
52 a calculation and restore the old

00:41:30,500 --> 00:41:35,180
context this is saving the old we're

00:41:33,530 --> 00:41:37,910
storing the new that happens over and

00:41:35,180 --> 00:41:40,190
over again there's a better way with the

00:41:37,910 --> 00:41:41,960
local context the context manager here

00:41:40,190 --> 00:41:44,060
makes a copy of the context puts it in

00:41:41,960 --> 00:41:45,650
place does the calculation restore it

00:41:44,060 --> 00:41:48,920
which is easier to get right the first

00:41:45,650 --> 00:41:50,839
or the second succulent it has reusable

00:41:48,920 --> 00:41:52,819
logic they are pretty much anytime

00:41:50,839 --> 00:41:54,680
you're set up logic and teardown logic

00:41:52,819 --> 00:41:56,780
or get repeated in your code you want a

00:41:54,680 --> 00:41:58,280
context manager to improve it it can

00:41:56,780 --> 00:41:59,720
profoundly clean up your codebase

00:41:58,280 --> 00:42:00,970
especially if you're doing this sort of

00:41:59,720 --> 00:42:04,069
thing all over the place

00:42:00,970 --> 00:42:06,079
ok the traditional way to open and close

00:42:04,069 --> 00:42:07,550
files P everybody knew they were

00:42:06,079 --> 00:42:10,160
supposed to do it they wouldn't do it

00:42:07,550 --> 00:42:12,950
you had to do the try finally C Python

00:42:10,160 --> 00:42:15,170
closes for you anyway but the simple way

00:42:12,950 --> 00:42:16,310
the new way is beautiful what did the

00:42:15,170 --> 00:42:18,590
with statement factor out

00:42:16,310 --> 00:42:20,360
for us it factored out the setup logic

00:42:18,590 --> 00:42:22,160
and teardown log it's set up the try

00:42:20,360 --> 00:42:24,830
final leg for us most of you knew that

00:42:22,160 --> 00:42:28,490
one already does your code base note go

00:42:24,830 --> 00:42:30,020
fix it how to use locks simple way to

00:42:28,490 --> 00:42:32,240
make a walk the old way it's acquired

00:42:30,020 --> 00:42:35,240
the lock do a try finally do you have to

00:42:32,240 --> 00:42:37,310
use a try finally absolutely if you

00:42:35,240 --> 00:42:39,980
don't you don't release the lock under

00:42:37,310 --> 00:42:41,450
some situation where an error happens in

00:42:39,980 --> 00:42:45,290
here what happens if you don't read the

00:42:41,450 --> 00:42:49,760
lock release a lock do puppies die every

00:42:45,290 --> 00:42:51,230
time dead puppies so that's what you're

00:42:49,760 --> 00:42:53,480
supposed to do but you had to indent

00:42:51,230 --> 00:42:54,740
twice pill up finally put colons people

00:42:53,480 --> 00:42:57,110
knew they were supposed to do it and

00:42:54,740 --> 00:42:58,820
probably wouldn't the new way is with

00:42:57,110 --> 00:43:01,310
walk I've actually separated the

00:42:58,820 --> 00:43:04,280
administration logic of getting the lock

00:43:01,310 --> 00:43:06,380
separate from the print statement I

00:43:04,280 --> 00:43:07,670
don't know who came up with context

00:43:06,380 --> 00:43:10,750
managers I need to go find them and

00:43:07,670 --> 00:43:13,460
thank them because they are wonderful ow

00:43:10,750 --> 00:43:15,380
factoring out temporary context by the

00:43:13,460 --> 00:43:18,140
way most of you guys knew with lock

00:43:15,380 --> 00:43:18,380
already right and you already knew this

00:43:18,140 --> 00:43:20,810
uh

00:43:18,380 --> 00:43:24,050
the way to close open and close files

00:43:20,810 --> 00:43:25,970
here's one you didn't know I would do an

00:43:24,050 --> 00:43:27,980
OS remove to file and then I catch an

00:43:25,970 --> 00:43:29,420
error there's another way to do this of

00:43:27,980 --> 00:43:30,860
course you can check and see if the file

00:43:29,420 --> 00:43:32,900
exists before you do it is that the

00:43:30,860 --> 00:43:35,330
right way no because it has a race

00:43:32,900 --> 00:43:37,430
condition in it and so this is the

00:43:35,330 --> 00:43:40,360
correct way it's also irritating

00:43:37,430 --> 00:43:42,950
here's a better way with ignored oh

00:43:40,360 --> 00:43:45,170
you've never seen ignored it says do

00:43:42,950 --> 00:43:46,670
this code how come you haven't seen

00:43:45,170 --> 00:43:47,810
ignored aren't you while watching my

00:43:46,670 --> 00:43:50,870
check-ins I made this check in a few

00:43:47,810 --> 00:43:53,330
days ago you guys aren't working off the

00:43:50,870 --> 00:43:54,740
head on Python three four yeah anyway if

00:43:53,330 --> 00:43:55,610
you want your own I put it on the next

00:43:54,740 --> 00:43:57,740
slide

00:43:55,610 --> 00:44:00,890
you put those handful of lines in your

00:43:57,740 --> 00:44:02,690
code hey it's like ten words of Python

00:44:00,890 --> 00:44:05,030
stick that new utils directory and you

00:44:02,690 --> 00:44:07,880
two can ignore exceptions it gets rid of

00:44:05,030 --> 00:44:10,610
the idiom for try except pass who

00:44:07,880 --> 00:44:12,980
learned something too cool alright more

00:44:10,610 --> 00:44:16,070
new things factored out temporary

00:44:12,980 --> 00:44:19,100
context did you know that help since

00:44:16,070 --> 00:44:20,270
it's helped to standard output so you're

00:44:19,100 --> 00:44:21,770
going to have to cut and paste it to

00:44:20,270 --> 00:44:24,620
sort in a file that's irritating

00:44:21,770 --> 00:44:27,770
can't we just redirect it sure you what

00:44:24,620 --> 00:44:29,940
you can do is open I off a file redirect

00:44:27,770 --> 00:44:32,040
standard output temporarily assign it

00:44:29,940 --> 00:44:34,500
to try finally on the help and then

00:44:32,040 --> 00:44:36,240
after you've done the help capturing the

00:44:34,500 --> 00:44:40,410
output to the file store it is this any

00:44:36,240 --> 00:44:42,150
fun new better way with redirect

00:44:40,410 --> 00:44:44,430
standard out to the file this time

00:44:42,150 --> 00:44:45,990
pretty much you can get back in the

00:44:44,430 --> 00:44:47,369
business of writing your functions with

00:44:45,990 --> 00:44:49,410
print statements and then wrap them with

00:44:47,369 --> 00:44:50,849
widths to send them to files and up to

00:44:49,410 --> 00:44:53,040
standard error send them somewhere else

00:44:50,849 --> 00:44:56,790
this restores the beauty of using our

00:44:53,040 --> 00:44:58,470
print everywhere and this is the context

00:44:56,790 --> 00:45:00,690
manager for if you don't have this and

00:44:58,470 --> 00:45:01,950
of course you don't because I haven't

00:45:00,690 --> 00:45:06,089
checked that one in yet that'll probably

00:45:01,950 --> 00:45:08,460
go in on Monday so Nick and I have to

00:45:06,089 --> 00:45:10,650
have a couple words about he's a very

00:45:08,460 --> 00:45:12,930
happy with this part what we are unsure

00:45:10,650 --> 00:45:16,710
of is whether we should say in fact you

00:45:12,930 --> 00:45:19,380
guys can just vote the proposal is if

00:45:16,710 --> 00:45:22,020
file object is equal to none how about

00:45:19,380 --> 00:45:25,050
we automatically create for you a string

00:45:22,020 --> 00:45:28,619
IO object capture the string so that you

00:45:25,050 --> 00:45:32,130
can do with a redirect standard out no

00:45:28,619 --> 00:45:36,810
arguments as s and then do a s get value

00:45:32,130 --> 00:45:39,920
and capture the string you want that all

00:45:36,810 --> 00:45:43,760
right Nick has decided

00:45:39,920 --> 00:45:47,460
okay Nick is the Nick is the man for

00:45:43,760 --> 00:45:48,780
context a lip so we negotiate everything

00:45:47,460 --> 00:45:51,020
there just like somebody wants something

00:45:48,780 --> 00:45:53,280
in collections they have to come to me

00:45:51,020 --> 00:45:58,020
they want something in Turtles they come

00:45:53,280 --> 00:46:00,869
to me alright for Jack he came to me and

00:45:58,020 --> 00:46:02,790
said no he tried to alter one of my

00:46:00,869 --> 00:46:06,060
combinatorics I'm now wishing I had said

00:46:02,790 --> 00:46:09,690
yes though alright so concise expressive

00:46:06,060 --> 00:46:11,220
one-liners this is the very last one but

00:46:09,690 --> 00:46:13,170
it's an interesting thought when people

00:46:11,220 --> 00:46:15,060
first come to Python we teach don't put

00:46:13,170 --> 00:46:16,230
too much stuff on one line there's an

00:46:15,060 --> 00:46:18,359
infinite amount of vertical space

00:46:16,230 --> 00:46:20,600
available to you in your code take

00:46:18,359 --> 00:46:24,390
advantage of that on the other hand

00:46:20,600 --> 00:46:26,580
don't take single units of thought and

00:46:24,390 --> 00:46:27,810
break them into subatomic particles so

00:46:26,580 --> 00:46:30,060
it actually makes your code harder

00:46:27,810 --> 00:46:32,070
generally I understand every single line

00:46:30,060 --> 00:46:35,130
but yes do you understand the gestalt of

00:46:32,070 --> 00:46:36,930
that my rule for what goes on one line

00:46:35,130 --> 00:46:39,840
in one logical line do you remember

00:46:36,930 --> 00:46:41,940
earlier when we did the couple unpacking

00:46:39,840 --> 00:46:43,619
with the planet positions that was one

00:46:41,940 --> 00:46:46,859
logical line even though I actually

00:46:43,619 --> 00:46:49,440
typed it on four so one logical line

00:46:46,859 --> 00:46:51,690
means one statement so my rule is what

00:46:49,440 --> 00:46:54,420
goes in one line is what you can express

00:46:51,690 --> 00:46:56,609
in a single English sentence give me the

00:46:54,420 --> 00:47:00,390
sum of the squares of all the numbers up

00:46:56,609 --> 00:47:01,890
to ten this is one way to do it you

00:47:00,390 --> 00:47:03,900
start with an empty list this is the way

00:47:01,890 --> 00:47:05,790
we used to do it in the olden times when

00:47:03,900 --> 00:47:08,460
I first came to Python

00:47:05,790 --> 00:47:09,750
I'd have you clap on some butts Alex put

00:47:08,460 --> 00:47:12,480
some in there I'm the one who made

00:47:09,750 --> 00:47:14,100
something go fast though so well I put

00:47:12,480 --> 00:47:16,170
all the optimizations in so it doesn't

00:47:14,100 --> 00:47:17,910
create a new object at every iteration

00:47:16,170 --> 00:47:22,140
it actually just keeps a running total

00:47:17,910 --> 00:47:25,050
in C there is a better way which is to

00:47:22,140 --> 00:47:26,869
use of the square brackets and put this

00:47:25,050 --> 00:47:29,220
in one line why is that better

00:47:26,869 --> 00:47:32,580
well the first one tells you exactly

00:47:29,220 --> 00:47:33,960
what to do step by step the second one

00:47:32,580 --> 00:47:35,550
says what you want it's more declarative

00:47:33,960 --> 00:47:37,109
it just says I want the sum of this I

00:47:35,550 --> 00:47:39,990
read it left-to-right I want the sum of

00:47:37,109 --> 00:47:41,280
the squares of I taken from one to ten

00:47:39,990 --> 00:47:43,500
the same way you would write it in

00:47:41,280 --> 00:47:45,240
mathematics ican't in the second way is

00:47:43,500 --> 00:47:47,100
better because it's a single unit of

00:47:45,240 --> 00:47:48,840
thought and the first one is too busy

00:47:47,100 --> 00:47:50,100
telling you how to do it and not what

00:47:48,840 --> 00:47:53,270
it's doing fair enough

00:47:50,100 --> 00:48:01,410
oh is there a better way

00:47:53,270 --> 00:48:06,180
take out the brackets generator

00:48:01,410 --> 00:48:08,430
expressions I did those yeah so yeah my

00:48:06,180 --> 00:48:10,320
contribution to Python I came along and

00:48:08,430 --> 00:48:13,470
saw these square brackets and I took

00:48:10,320 --> 00:48:15,120
have an eraser and I erased them and it

00:48:13,470 --> 00:48:16,800
made everything go a lot faster that

00:48:15,120 --> 00:48:18,360
creates a generator version of this

00:48:16,800 --> 00:48:19,980
instead of filling up memory making it

00:48:18,360 --> 00:48:22,760
go fast did you guys have a good time

00:48:19,980 --> 00:48:22,760
cool

00:48:33,080 --> 00:48:39,750
thank you all for coming to the

00:48:36,120 --> 00:48:41,550
presentation and do me an honor get take

00:48:39,750 --> 00:48:44,160
these slides go back to work and have

00:48:41,550 --> 00:48:45,360
somebody if not yourself look at every

00:48:44,160 --> 00:48:46,980
one of these find them in your codebase

00:48:45,360 --> 00:48:48,840
and put them in it'll make your code

00:48:46,980 --> 00:48:51,200
faster better and more beautiful thank

00:48:48,840 --> 00:48:51,200

YouTube URL: https://www.youtube.com/watch?v=OSGv2VnC0go


