Title: Dynamic Code Patterns: Extending Your Applications with Plugins
Publication date: 2013-04-03
Playlist: PyCon 2013
Description: 
	Doug Hellmann
Python makes loading code dynamically easy, allowing you to configure and extend your application by discovering and loading extensions at runtime. This presentation will discuss the techniques for dynamic code loading used in several w
Captions: 
	00:00:00,030 --> 00:00:05,549
right thank you all for coming out this

00:00:01,650 --> 00:00:06,839
afternoon as Marco said my name is Doug

00:00:05,549 --> 00:00:07,440
Hellman I'm a senior developer at

00:00:06,839 --> 00:00:10,410
DreamHost

00:00:07,440 --> 00:00:12,840
and I'm going to talk today about some

00:00:10,410 --> 00:00:14,190
work that I did over the past year and

00:00:12,840 --> 00:00:16,139
actually the past several years looking

00:00:14,190 --> 00:00:18,090
at the architectures of different

00:00:16,139 --> 00:00:20,400
programs that use dynamic code loading

00:00:18,090 --> 00:00:24,420
and how they used plugins in different

00:00:20,400 --> 00:00:26,820
ways and then what we did with that on

00:00:24,420 --> 00:00:29,760
some work on a project for OpenStack

00:00:26,820 --> 00:00:31,759
over the past year and a that I've

00:00:29,760 --> 00:00:34,770
released as well

00:00:31,759 --> 00:00:36,600
so from my analysis that the research

00:00:34,770 --> 00:00:39,420
that I did I counted any application or

00:00:36,600 --> 00:00:41,640
framework that loads code dynamically at

00:00:39,420 --> 00:00:43,640
runtime to be using plugins so I'm not

00:00:41,640 --> 00:00:45,690
talking about things like delayed

00:00:43,640 --> 00:00:47,010
execution of import statements that are

00:00:45,690 --> 00:00:48,989
embedded in functions and things like

00:00:47,010 --> 00:00:51,270
that I'm talking about actually

00:00:48,989 --> 00:00:54,059
dynamically discovering code finding the

00:00:51,270 --> 00:00:56,850
module and loading it in most cases the

00:00:54,059 --> 00:00:58,050
name of the location of the code wasn't

00:00:56,850 --> 00:01:00,960
known to the application or the

00:00:58,050 --> 00:01:02,640
framework at at the beginning that it

00:01:00,960 --> 00:01:05,670
was given to it through some sort of

00:01:02,640 --> 00:01:07,770
external configuration before we talk

00:01:05,670 --> 00:01:09,330
about how to use plugins we should talk

00:01:07,770 --> 00:01:11,040
a little bit about why to use plugins in

00:01:09,330 --> 00:01:13,500
your applications and there's lots of

00:01:11,040 --> 00:01:16,650
good reasons first the main one is

00:01:13,500 --> 00:01:18,689
keeping a separation between the core of

00:01:16,650 --> 00:01:22,979
your application and the extensions to

00:01:18,689 --> 00:01:26,150
your application it might cut out okay

00:01:22,979 --> 00:01:28,350
sorry I stopped being able to hear

00:01:26,150 --> 00:01:30,210
encourages you to build it in such a way

00:01:28,350 --> 00:01:32,729
that you use better abstractions within

00:01:30,210 --> 00:01:34,860
your application so building an

00:01:32,729 --> 00:01:36,990
extensible program like that can take

00:01:34,860 --> 00:01:39,090
more work and maybe a little more time

00:01:36,990 --> 00:01:40,920
and resources than hardwiring everything

00:01:39,090 --> 00:01:42,180
together but in the long run it pays off

00:01:40,920 --> 00:01:44,810
because you end up with something that's

00:01:42,180 --> 00:01:47,310
more flexible and more maintainable

00:01:44,810 --> 00:01:49,470
Packaging extension separately also

00:01:47,310 --> 00:01:52,890
reduces dependency bloat on your main

00:01:49,470 --> 00:01:54,960
application so it makes deployment

00:01:52,890 --> 00:01:56,670
easier to manage because you can control

00:01:54,960 --> 00:01:58,229
which dependencies have to be installed

00:01:56,670 --> 00:02:01,469
based on which plugins you actually care

00:01:58,229 --> 00:02:03,060
about using plugins are also a good way

00:02:01,469 --> 00:02:05,490
to implement things like device drivers

00:02:03,060 --> 00:02:08,129
and other occurrences of the strategy

00:02:05,490 --> 00:02:10,080
pattern they let you put your core logic

00:02:08,129 --> 00:02:13,290
in the application where it's easily

00:02:10,080 --> 00:02:16,409
reusable and then let the plugins focus

00:02:13,290 --> 00:02:19,049
on talking to a device or an API or

00:02:16,409 --> 00:02:21,480
something like that and they also

00:02:19,049 --> 00:02:23,790
provide a convenient way to extend the

00:02:21,480 --> 00:02:25,980
features of your application by hooking

00:02:23,790 --> 00:02:28,349
new code in and well defined extension

00:02:25,980 --> 00:02:29,909
points so you'll find as I have in a few

00:02:28,349 --> 00:02:31,500
cases that people use your application

00:02:29,909 --> 00:02:33,390
in ways that you would never have

00:02:31,500 --> 00:02:35,610
expected but because you've built it

00:02:33,390 --> 00:02:39,030
with extension extension points they can

00:02:35,610 --> 00:02:40,560
do whatever they want with it and

00:02:39,030 --> 00:02:43,319
finally having an extensible system

00:02:40,560 --> 00:02:45,060
makes it easier for other developers to

00:02:43,319 --> 00:02:48,480
contribute to your project by building

00:02:45,060 --> 00:02:51,180
those extra packages and distributing

00:02:48,480 --> 00:02:52,349
them indirectly so you don't have to

00:02:51,180 --> 00:02:55,560
have all of that code in your core

00:02:52,349 --> 00:02:57,389
repository which makes code reviews and

00:02:55,560 --> 00:02:58,680
accepting patches and that sort of thing

00:02:57,389 --> 00:03:01,319
easier because they can just sort of

00:02:58,680 --> 00:03:03,150
manage their own thing so I've spent a

00:03:01,319 --> 00:03:05,030
fair bit of time over the past couple of

00:03:03,150 --> 00:03:07,170
years studying plugin based on architect

00:03:05,030 --> 00:03:08,639
architectures and especially over the

00:03:07,170 --> 00:03:10,650
last year while helping to create

00:03:08,639 --> 00:03:13,620
selamat or the new metering component

00:03:10,650 --> 00:03:15,450
for OpenStack selamat er measures the

00:03:13,620 --> 00:03:17,340
resources being used in a cloud

00:03:15,450 --> 00:03:19,560
deployment so that we can build a

00:03:17,340 --> 00:03:21,599
tenant's for those resources so we

00:03:19,560 --> 00:03:23,940
collect data like what you would expect

00:03:21,599 --> 00:03:26,699
lifetimes of instances the amount of

00:03:23,940 --> 00:03:28,019
disk space that's been used Network IO

00:03:26,699 --> 00:03:30,930
that sort of thing

00:03:28,019 --> 00:03:32,489
however the type and number of things

00:03:30,930 --> 00:03:34,109
that a given cloud deployment will want

00:03:32,489 --> 00:03:36,660
to measure and we'll want to Bill for

00:03:34,109 --> 00:03:39,510
will vary from deployment to deployment

00:03:36,660 --> 00:03:41,459
so we wanted a flexible system to make

00:03:39,510 --> 00:03:45,329
taking all of those measurements easy to

00:03:41,459 --> 00:03:46,769
extend and easy to control we need to

00:03:45,329 --> 00:03:49,560
allow deployers to write their own

00:03:46,769 --> 00:03:50,819
plug-ins for a couple of different

00:03:49,560 --> 00:03:52,049
reasons they may have things that they

00:03:50,819 --> 00:03:54,269
want to measure that we haven't

00:03:52,049 --> 00:03:55,650
implemented yet in the core or they may

00:03:54,269 --> 00:03:58,260
have things that they need to measure in

00:03:55,650 --> 00:03:59,639
some sort of custom way which is a case

00:03:58,260 --> 00:04:01,500
that we have a dream host where it's not

00:03:59,639 --> 00:04:04,799
something reusable it's a deployment

00:04:01,500 --> 00:04:06,480
implementation detail for our cloud so

00:04:04,799 --> 00:04:08,940
we're expecting a lot of developers who

00:04:06,480 --> 00:04:10,590
don't interact with us directly to be

00:04:08,940 --> 00:04:12,269
building these plugins so another key

00:04:10,590 --> 00:04:15,359
thing for us was to make it easy to

00:04:12,269 --> 00:04:17,070
document the API for each plug-in set so

00:04:15,359 --> 00:04:18,989
that they had clear instructions for

00:04:17,070 --> 00:04:21,090
what they needed to do to create plugins

00:04:18,989 --> 00:04:23,099
so with all of these things in mind we

00:04:21,090 --> 00:04:24,840
designed selamat ER to be flexible in

00:04:23,099 --> 00:04:26,900
several different areas and this is a

00:04:24,840 --> 00:04:30,229
diagram that explains what the

00:04:26,900 --> 00:04:32,150
openstack system sort of looks like it's

00:04:30,229 --> 00:04:33,380
a collection of components that

00:04:32,150 --> 00:04:35,990
cooperate to provide

00:04:33,380 --> 00:04:38,270
infrastructure-as-a-service features for

00:04:35,990 --> 00:04:40,100
a cloud each component manages a

00:04:38,270 --> 00:04:41,810
different aspect of the cloud and then

00:04:40,100 --> 00:04:43,970
uses a message bus to communicate

00:04:41,810 --> 00:04:45,560
between the components all of the

00:04:43,970 --> 00:04:47,780
components generate notification

00:04:45,560 --> 00:04:49,160
messages when events happen so when you

00:04:47,780 --> 00:04:50,360
create an instance or when you delete an

00:04:49,160 --> 00:04:52,639
instance that sort of thing and

00:04:50,360 --> 00:04:54,530
capturing those messages was the first

00:04:52,639 --> 00:04:56,210
source of data for selamat err because

00:04:54,530 --> 00:04:58,160
it triggered an event we knew exactly

00:04:56,210 --> 00:04:59,289
you know this is something we care about

00:04:58,160 --> 00:05:02,270
we want to measure this

00:04:59,289 --> 00:05:03,889
however the notifications are formatted

00:05:02,270 --> 00:05:05,600
in a way they contain different metadata

00:05:03,889 --> 00:05:07,910
depending on the resource that triggered

00:05:05,600 --> 00:05:10,760
the event so we needed a set of plugins

00:05:07,910 --> 00:05:12,889
in the event listener to translate those

00:05:10,760 --> 00:05:16,190
notification messages into a standard

00:05:12,889 --> 00:05:18,110
format for our metering system there

00:05:16,190 --> 00:05:21,380
aren't events for all of the things that

00:05:18,110 --> 00:05:23,000
we care about measuring for example CPU

00:05:21,380 --> 00:05:25,340
utilization that doesn't really trigger

00:05:23,000 --> 00:05:27,560
events we just need to pull for that so

00:05:25,340 --> 00:05:31,099
we created a separate set of Polster

00:05:27,560 --> 00:05:31,820
plugins to pull for data we check

00:05:31,099 --> 00:05:33,289
periodically

00:05:31,820 --> 00:05:34,789
you know all sorts of different things

00:05:33,289 --> 00:05:38,620
that don't trigger events but that are

00:05:34,789 --> 00:05:38,620
sort of run long running kinds of things

00:05:39,880 --> 00:05:44,720
some of the other pollsters that don't

00:05:42,650 --> 00:05:46,880
run on the hypervisor directly run in a

00:05:44,720 --> 00:05:49,490
central node where they can pull other

00:05:46,880 --> 00:05:52,550
services within OpenStack in in for

00:05:49,490 --> 00:05:57,800
similar sorts of measurements where

00:05:52,550 --> 00:06:00,289
there again no events happening all of

00:05:57,800 --> 00:06:02,240
the salaah meter services use a separate

00:06:00,289 --> 00:06:04,580
message bus to deliver data to a

00:06:02,240 --> 00:06:07,250
collector process and then the collector

00:06:04,580 --> 00:06:10,250
process uses a storage driver to write

00:06:07,250 --> 00:06:12,770
them to a database and the the storage

00:06:10,250 --> 00:06:14,030
driver API supports relational and

00:06:12,770 --> 00:06:15,979
non-relational databases we've

00:06:14,030 --> 00:06:17,510
abstracted out the events that are the

00:06:15,979 --> 00:06:19,639
the operations that have to happen at

00:06:17,510 --> 00:06:21,110
that layer so that the deployer has the

00:06:19,639 --> 00:06:22,729
option to deploy something that they're

00:06:21,110 --> 00:06:24,169
comfortable with and if there's anything

00:06:22,729 --> 00:06:25,820
that we've learned with OpenStack is

00:06:24,169 --> 00:06:27,340
that no two deployments are the same in

00:06:25,820 --> 00:06:29,630
any real way

00:06:27,340 --> 00:06:31,430
so this architecture that we came up

00:06:29,630 --> 00:06:33,830
with resulted in five different sets of

00:06:31,430 --> 00:06:35,810
plug-ins for selamat err OpenStack

00:06:33,830 --> 00:06:39,590
includes a message bus abstraction layer

00:06:35,810 --> 00:06:40,280
already so including drivers for AMQP

00:06:39,590 --> 00:06:42,290
and zero

00:06:40,280 --> 00:06:43,610
q so that part was implemented we didn't

00:06:42,290 --> 00:06:45,470
really have to touch that or do anything

00:06:43,610 --> 00:06:47,240
with that but the other four sets of

00:06:45,470 --> 00:06:48,980
plugins we created from scratch so we

00:06:47,240 --> 00:06:51,620
have plugins for processing those

00:06:48,980 --> 00:06:53,990
notification messages polster's for the

00:06:51,620 --> 00:06:58,820
compute nodes and for the central nodes

00:06:53,990 --> 00:07:00,830
and then the storage drivers the designs

00:06:58,820 --> 00:07:03,770
that we came up we use patterns that we

00:07:00,830 --> 00:07:06,500
found by examining other applications

00:07:03,770 --> 00:07:08,030
and frameworks so during my research I

00:07:06,500 --> 00:07:09,889
looked at a few projects that I was

00:07:08,030 --> 00:07:11,389
already familiar with and I looked at

00:07:09,889 --> 00:07:13,490
several that I hadn't actually used

00:07:11,389 --> 00:07:16,430
before but that I knew used plugins and

00:07:13,490 --> 00:07:17,840
this is a short list I'm sure that there

00:07:16,430 --> 00:07:19,520
I know that there are other applications

00:07:17,840 --> 00:07:21,260
and frameworks out there that have

00:07:19,520 --> 00:07:23,419
different kinds of plug-in systems but

00:07:21,260 --> 00:07:25,220
this list gave us enough information to

00:07:23,419 --> 00:07:28,220
come up with some designs that were

00:07:25,220 --> 00:07:30,470
reusable for us blog of file and Sphinx

00:07:28,220 --> 00:07:32,630
are two different apps for working with

00:07:30,470 --> 00:07:34,460
different forms of text and for

00:07:32,630 --> 00:07:36,320
publishing and they use extensions

00:07:34,460 --> 00:07:38,750
primarily to add new content processing

00:07:36,320 --> 00:07:40,340
features mercurial is a command line app

00:07:38,750 --> 00:07:42,650
that can be extended with new sub

00:07:40,340 --> 00:07:45,050
commands and cliff is a library that I

00:07:42,650 --> 00:07:46,870
wrote that is used for building

00:07:45,050 --> 00:07:49,160
applications in the same sort of way so

00:07:46,870 --> 00:07:51,740
where you have sub commands for a main

00:07:49,160 --> 00:07:53,150
application a virtual end wrapper is a

00:07:51,740 --> 00:07:55,040
command another kind of command line

00:07:53,150 --> 00:07:56,510
tool that uses hooks in a little bit of

00:07:55,040 --> 00:07:58,970
a different way most of the hooks for a

00:07:56,510 --> 00:08:00,530
virtual line wrapper extend the features

00:07:58,970 --> 00:08:04,010
of the commands themselves without

00:08:00,530 --> 00:08:05,330
adding new commands nose and track are

00:08:04,010 --> 00:08:07,850
common developer tools you've probably

00:08:05,330 --> 00:08:08,990
seen or use those it's much more likely

00:08:07,850 --> 00:08:10,250
that you've used them that you've

00:08:08,990 --> 00:08:12,229
written then that you've written an

00:08:10,250 --> 00:08:15,590
extension for them but they do both use

00:08:12,229 --> 00:08:17,720
plugins Django Pyramid and sequel

00:08:15,590 --> 00:08:20,539
alchemy our developer libraries that use

00:08:17,720 --> 00:08:23,930
plugins or at least load code

00:08:20,539 --> 00:08:26,120
dynamically at runtime Dimond is a

00:08:23,930 --> 00:08:28,850
monitoring app with an extensive set of

00:08:26,120 --> 00:08:30,860
plugins and it does some things similar

00:08:28,850 --> 00:08:33,770
to what selamat ER does but in a sort of

00:08:30,860 --> 00:08:35,330
sort of different it looks at it from a

00:08:33,770 --> 00:08:37,490
different perspective so we were

00:08:35,330 --> 00:08:39,140
building some similar things but we

00:08:37,490 --> 00:08:41,409
wanted to look at their architecture but

00:08:39,140 --> 00:08:44,390
we couldn't really use what they had

00:08:41,409 --> 00:08:47,120
Nova is the primary component for

00:08:44,390 --> 00:08:49,040
OpenStack and it relies on a large

00:08:47,120 --> 00:08:50,540
number of drivers for managing all the

00:08:49,040 --> 00:08:52,920
different aspects in the configurable

00:08:50,540 --> 00:08:56,020
ways that you can deploy opens

00:08:52,920 --> 00:08:58,840
so I looked at all of this code over the

00:08:56,020 --> 00:09:02,200
course of a few months to derive ideas

00:08:58,840 --> 00:09:05,740
for how plugins should be used in the

00:09:02,200 --> 00:09:08,590
right way and to design the way that we

00:09:05,740 --> 00:09:09,970
would use plugins within selamat er so

00:09:08,590 --> 00:09:11,410
while some of what I might say today

00:09:09,970 --> 00:09:13,060
will sound a little critical of the

00:09:11,410 --> 00:09:15,190
other applications keep in mind that I

00:09:13,060 --> 00:09:17,650
have the benefit of looking at not only

00:09:15,190 --> 00:09:20,440
all of the code all at the same time and

00:09:17,650 --> 00:09:21,430
in hindsight but also probably different

00:09:20,440 --> 00:09:24,100
requirements that some of these

00:09:21,430 --> 00:09:26,170
applications had and we made a few

00:09:24,100 --> 00:09:28,990
choices differently than almost all of

00:09:26,170 --> 00:09:31,690
these programs so all right so let's

00:09:28,990 --> 00:09:32,950
talk about how plugins work so the first

00:09:31,690 --> 00:09:35,470
thing that you have to do with a plug-in

00:09:32,950 --> 00:09:37,660
is to find it so the tools that I looked

00:09:35,470 --> 00:09:39,880
at were split between some sort of

00:09:37,660 --> 00:09:43,840
explicit definition of what plugins were

00:09:39,880 --> 00:09:46,480
to be used or scanning the installed set

00:09:43,840 --> 00:09:48,340
of code to look for plugins and each of

00:09:46,480 --> 00:09:51,910
those sets was then further divided

00:09:48,340 --> 00:09:54,130
between what was being listed or scanned

00:09:51,910 --> 00:09:57,010
so some were looking for files you know

00:09:54,130 --> 00:10:00,370
dot py or dot p YC files and some were

00:09:57,010 --> 00:10:03,460
looking for Python import references so

00:10:00,370 --> 00:10:06,130
that's either a reference to a module or

00:10:03,460 --> 00:10:08,050
something within a module the explicit

00:10:06,130 --> 00:10:11,950
import reference category here is just

00:10:08,050 --> 00:10:14,800
basically there's an import string in a

00:10:11,950 --> 00:10:16,630
config file somewhere and then the scan

00:10:14,800 --> 00:10:19,839
import reference category means that

00:10:16,630 --> 00:10:21,910
there's a registry of all of the things

00:10:19,839 --> 00:10:25,630
that they the plugins could be loaded

00:10:21,910 --> 00:10:27,820
from and in this in all the cases where

00:10:25,630 --> 00:10:29,890
that happened all of them use setup

00:10:27,820 --> 00:10:33,040
tools and packaged resources with entry

00:10:29,890 --> 00:10:35,140
points so after the app finds a plug-in

00:10:33,040 --> 00:10:37,570
the next step is to decide whether to

00:10:35,140 --> 00:10:39,160
load it and use it most of the

00:10:37,570 --> 00:10:41,260
applications and frameworks use an

00:10:39,160 --> 00:10:42,820
explicit step to configure extensions

00:10:41,260 --> 00:10:44,050
and there are a lot of times in this

00:10:42,820 --> 00:10:46,180
makes sense when you're doing something

00:10:44,050 --> 00:10:47,470
with developer tools like Django it

00:10:46,180 --> 00:10:49,360
makes a lot of sense because you're

00:10:47,470 --> 00:10:50,620
really hard wiring things together it's

00:10:49,360 --> 00:10:52,900
just that the framework doesn't know

00:10:50,620 --> 00:10:54,700
about the things that you're loading the

00:10:52,900 --> 00:10:58,089
extensions to sequel alchemy are all

00:10:54,700 --> 00:10:59,800
enabled when you load the library but it

00:10:58,089 --> 00:11:01,450
decides which one to load based on your

00:10:59,800 --> 00:11:02,770
database connection string so that makes

00:11:01,450 --> 00:11:05,110
sense there's no reason to load drivers

00:11:02,770 --> 00:11:05,560
you're not going to use however some of

00:11:05,110 --> 00:11:07,960
the you

00:11:05,560 --> 00:11:10,810
or applications like blaga file

00:11:07,960 --> 00:11:12,370
mercurial and tract in addition to

00:11:10,810 --> 00:11:14,470
installing the plugin you have to take

00:11:12,370 --> 00:11:18,130
an extra step to configure it and enable

00:11:14,470 --> 00:11:19,360
it and that seemed like something that

00:11:18,130 --> 00:11:22,620
could really be skipped so when I

00:11:19,360 --> 00:11:25,300
created virtual and wrapper and cliff I

00:11:22,620 --> 00:11:27,730
decided to use installation as a trigger

00:11:25,300 --> 00:11:30,220
for activation because I wanted to avoid

00:11:27,730 --> 00:11:32,529
any opportunity for the user to make a

00:11:30,220 --> 00:11:34,000
mistake in that configuration as long as

00:11:32,529 --> 00:11:37,690
they could get the code on the system it

00:11:34,000 --> 00:11:41,470
would be available and it would work and

00:11:37,690 --> 00:11:43,390
that's knows works in a similar way as

00:11:41,470 --> 00:11:46,570
soon as you install the plug-in it's

00:11:43,390 --> 00:11:48,130
available and you can use it whether or

00:11:46,570 --> 00:11:49,750
not it's actually turned on depends on

00:11:48,130 --> 00:11:52,240
what kind of command line flags you pass

00:11:49,750 --> 00:11:53,740
to know is when you call it this oh all

00:11:52,240 --> 00:11:55,360
right after the application decides

00:11:53,740 --> 00:11:57,130
whether or not to load a plug-in the

00:11:55,360 --> 00:11:59,440
next step is to actually do the loading

00:11:57,130 --> 00:12:01,120
and get the code all of the examples

00:11:59,440 --> 00:12:03,760
that I looked at used two different

00:12:01,120 --> 00:12:05,710
techniques either calling import

00:12:03,760 --> 00:12:08,500
explicitly either through the built-in

00:12:05,710 --> 00:12:10,570
dunder import function or using the IMP

00:12:08,500 --> 00:12:13,270
module or import live or something like

00:12:10,570 --> 00:12:16,300
that or by using packaged resources to

00:12:13,270 --> 00:12:18,280
get entry points some of you will have

00:12:16,300 --> 00:12:20,500
maybe fast readers will have noticed

00:12:18,280 --> 00:12:23,440
that the nose sequel alchemy and blog a

00:12:20,500 --> 00:12:25,690
file are all listed on both sides of the

00:12:23,440 --> 00:12:27,010
table there and that's not a mistake all

00:12:25,690 --> 00:12:29,290
three of those actually use both

00:12:27,010 --> 00:12:31,150
techniques to load their plugins so nose

00:12:29,290 --> 00:12:33,550
falls back to a custom importer if

00:12:31,150 --> 00:12:36,430
package resources is not installed and

00:12:33,550 --> 00:12:38,980
not available sequel alchemy uses a

00:12:36,430 --> 00:12:41,110
custom importer for extensions

00:12:38,980 --> 00:12:43,030
distributed with the core application or

00:12:41,110 --> 00:12:44,980
library but then it uses package

00:12:43,030 --> 00:12:47,560
resources to load things that are not

00:12:44,980 --> 00:12:50,470
distributed with core and blaga file

00:12:47,560 --> 00:12:52,150
uses package resources to find plugins

00:12:50,470 --> 00:12:53,860
and then it manually scans the

00:12:52,150 --> 00:12:56,500
directories containing the plugins to

00:12:53,860 --> 00:12:58,230
find things inside the plugins so things

00:12:56,500 --> 00:13:00,970
like templates and that sort of thing so

00:12:58,230 --> 00:13:03,610
if I discount the packages that I

00:13:00,970 --> 00:13:06,000
created myself that are in italics there

00:13:03,610 --> 00:13:10,390
there's a pretty clear bias towards

00:13:06,000 --> 00:13:14,470
scanning the files or sorry importing

00:13:10,390 --> 00:13:18,880
with the custom import code that route

00:13:14,470 --> 00:13:21,310
seems easy at first but every example

00:13:18,880 --> 00:13:22,870
in every application I was able to find

00:13:21,310 --> 00:13:25,180
a problem just with simple code

00:13:22,870 --> 00:13:27,670
inspections so not even actually running

00:13:25,180 --> 00:13:29,370
the code and I'll talk a little bit more

00:13:27,670 --> 00:13:31,480
about that later

00:13:29,370 --> 00:13:33,670
all right after the code for the

00:13:31,480 --> 00:13:35,139
extension is imported the next step is

00:13:33,670 --> 00:13:37,480
to integrate it with the rest of the app

00:13:35,139 --> 00:13:39,040
and that's the step where you configure

00:13:37,480 --> 00:13:41,410
any hooks in the application that need

00:13:39,040 --> 00:13:43,209
to know about the plug-in and then maybe

00:13:41,410 --> 00:13:44,730
you pass some state into the plug-in so

00:13:43,209 --> 00:13:47,050
that it knows about the application I

00:13:44,730 --> 00:13:49,540
looked at this step along two different

00:13:47,050 --> 00:13:51,459
axes again first I considered the

00:13:49,540 --> 00:13:54,610
granularity of the plug-in interface and

00:13:51,459 --> 00:13:57,250
I counted anything that was using a

00:13:54,610 --> 00:13:59,889
single class or function as being fine

00:13:57,250 --> 00:14:03,759
grained plug-in so the the plug-in was a

00:13:59,889 --> 00:14:05,829
standalone bit of code and the the

00:14:03,759 --> 00:14:08,319
application loaded that bit of code into

00:14:05,829 --> 00:14:11,290
memory directly for more coarse-grained

00:14:08,319 --> 00:14:13,269
cases a single plug-in might include

00:14:11,290 --> 00:14:18,459
hooks into multiple parts of the

00:14:13,269 --> 00:14:21,190
application that are all loaded by the

00:14:18,459 --> 00:14:23,709
application or probed for by the

00:14:21,190 --> 00:14:25,720
application differently and the other

00:14:23,709 --> 00:14:27,399
access related integration looks at how

00:14:25,720 --> 00:14:29,470
the code provided by the plug-in is

00:14:27,399 --> 00:14:32,319
brought into the application and I found

00:14:29,470 --> 00:14:34,509
two techniques for doing that first the

00:14:32,319 --> 00:14:36,130
application can instruct the plug-in to

00:14:34,509 --> 00:14:38,019
integrate itself so that's usually the

00:14:36,130 --> 00:14:39,790
case like with Sphinx where you have a

00:14:38,019 --> 00:14:42,279
setup function and it's passed an

00:14:39,790 --> 00:14:43,839
application context and then setup is

00:14:42,279 --> 00:14:46,180
responsible for calling methods on the

00:14:43,839 --> 00:14:50,319
application context to integrate itself

00:14:46,180 --> 00:14:52,089
with the application that can also be

00:14:50,319 --> 00:14:53,829
done implicitly if you're using a

00:14:52,089 --> 00:14:56,560
library like soap dot interface where

00:14:53,829 --> 00:14:58,120
just the act of importing things causes

00:14:56,560 --> 00:15:00,610
them to be integrated in the same way

00:14:58,120 --> 00:15:02,800
and the other way to do it is app the

00:15:00,610 --> 00:15:05,680
application can load the plug-in and

00:15:02,800 --> 00:15:07,420
then interrogate it so it can look at

00:15:05,680 --> 00:15:09,310
its properties or call methods on it to

00:15:07,420 --> 00:15:13,149
discover what the plug-in wants to do or

00:15:09,310 --> 00:15:15,610
what it needs one common issue with

00:15:13,149 --> 00:15:18,220
dynamically loaded code is enforcing the

00:15:15,610 --> 00:15:20,259
plug-in API at runtime and this is

00:15:18,220 --> 00:15:22,329
always a potential issue with dynamic

00:15:20,259 --> 00:15:23,920
languages but it comes up frequently

00:15:22,329 --> 00:15:25,329
with plugins because they're typically

00:15:23,920 --> 00:15:27,610
written by someone other than the core

00:15:25,329 --> 00:15:28,899
application developers and especially if

00:15:27,610 --> 00:15:31,120
they're distributed separately you have

00:15:28,899 --> 00:15:32,649
the opportunity for things like the API

00:15:31,120 --> 00:15:35,829
to drift a little bit and then

00:15:32,649 --> 00:15:38,980
plugins no longer compatible I saw two

00:15:35,829 --> 00:15:41,079
basic techniques being used to help

00:15:38,980 --> 00:15:43,329
developers get their plugins right on

00:15:41,079 --> 00:15:45,430
the left are the applications that rely

00:15:43,329 --> 00:15:47,290
on some conventions either naming

00:15:45,430 --> 00:15:49,059
conventions or locations of files or

00:15:47,290 --> 00:15:51,629
that sort of thing and many of these

00:15:49,059 --> 00:15:54,279
also had coarse-grained API interfaces

00:15:51,629 --> 00:15:55,629
on the right are applications where the

00:15:54,279 --> 00:15:58,569
plug-in uses some sort of a class

00:15:55,629 --> 00:16:00,249
hierarchy and in the case of nose that

00:15:58,569 --> 00:16:02,889
base class is optional so it's kind of a

00:16:00,249 --> 00:16:05,170
quasi interface track on the other hand

00:16:02,889 --> 00:16:07,600
uses formal interfaces with zouk dot

00:16:05,170 --> 00:16:09,279
interface and diamond actually enforces

00:16:07,600 --> 00:16:13,240
a strict sub classing so you have to

00:16:09,279 --> 00:16:15,550
subclass from there collector class so

00:16:13,240 --> 00:16:17,949
for cliff I chose to use the ABC module

00:16:15,550 --> 00:16:19,809
which is the abstract based class module

00:16:17,949 --> 00:16:22,480
in the standard library but I stuck with

00:16:19,809 --> 00:16:24,040
duck typing for the actual application

00:16:22,480 --> 00:16:25,449
so the application doesn't check that

00:16:24,040 --> 00:16:27,730
you've subclass stick correctly and that

00:16:25,449 --> 00:16:29,679
means that the developer can use the

00:16:27,730 --> 00:16:31,300
base class if they want to to get some

00:16:29,679 --> 00:16:33,089
hints but they don't absolutely have to

00:16:31,300 --> 00:16:35,410
if it's inconvenient for some reason and

00:16:33,089 --> 00:16:37,899
the final dimension that I looked at was

00:16:35,410 --> 00:16:39,790
how the plug-in was actually used at

00:16:37,899 --> 00:16:42,610
runtime and there were three different

00:16:39,790 --> 00:16:46,179
primary patterns for invoking the plugin

00:16:42,610 --> 00:16:47,499
that I found drivers are look typically

00:16:46,179 --> 00:16:50,679
loaded one at a time and invoked

00:16:47,499 --> 00:16:52,870
directly then the the some apps use a

00:16:50,679 --> 00:16:55,240
dispatcher pattern where they load all

00:16:52,870 --> 00:16:56,860
of the extensions but then based on what

00:16:55,240 --> 00:16:59,379
event or data they have they decide

00:16:56,860 --> 00:17:01,540
which ones to call at runtime and then

00:16:59,379 --> 00:17:03,490
other apps use an iterator pattern where

00:17:01,540 --> 00:17:04,899
they load all of the extensions and all

00:17:03,490 --> 00:17:07,510
of the events or all of the data is

00:17:04,899 --> 00:17:12,880
given to all of the plugins so that they

00:17:07,510 --> 00:17:14,649
can participate in the processing all

00:17:12,880 --> 00:17:15,870
right so after all of that analysis what

00:17:14,649 --> 00:17:18,579
have we end up doing with selamat err

00:17:15,870 --> 00:17:20,140
for finding and loading we decided to

00:17:18,579 --> 00:17:21,610
use entry points because they were just

00:17:20,140 --> 00:17:23,439
the simplest solution all around I

00:17:21,610 --> 00:17:26,230
mentioned that the apps that we're doing

00:17:23,439 --> 00:17:27,699
their own custom import code whether

00:17:26,230 --> 00:17:29,200
they were using import strings or

00:17:27,699 --> 00:17:32,230
whether they were loading files by

00:17:29,200 --> 00:17:33,850
munging the import path every every one

00:17:32,230 --> 00:17:37,860
of them had some sort of edge case error

00:17:33,850 --> 00:17:40,240
or weirdness that just don't do that

00:17:37,860 --> 00:17:41,950
entry points are easier to install and

00:17:40,240 --> 00:17:43,539
configure because your user doesn't have

00:17:41,950 --> 00:17:45,250
to know where your code is they don't

00:17:43,539 --> 00:17:46,390
have to know what file something is in

00:17:45,250 --> 00:17:48,100
they just have to know the name

00:17:46,390 --> 00:17:51,910
the thing that they want to use or turn

00:17:48,100 --> 00:17:53,470
on and they're also easier for packagers

00:17:51,910 --> 00:17:55,570
because they support multiple formats

00:17:53,470 --> 00:17:57,670
you can distribute the metadata as part

00:17:55,570 --> 00:18:00,750
of a platform package as well so it

00:17:57,670 --> 00:18:03,430
doesn't even have to be a Python package

00:18:00,750 --> 00:18:05,560
we used package resources but there are

00:18:03,430 --> 00:18:08,140
alternate implementations of entry point

00:18:05,560 --> 00:18:11,680
like systems in other libraries none of

00:18:08,140 --> 00:18:13,360
them are as widely used by far and so we

00:18:11,680 --> 00:18:14,980
just decided to go with the tried and

00:18:13,360 --> 00:18:18,160
trued version and package resources

00:18:14,980 --> 00:18:19,870
because we could trust it and then to

00:18:18,160 --> 00:18:21,460
further simplify the implementation we

00:18:19,870 --> 00:18:23,200
decided to always use entry points for

00:18:21,460 --> 00:18:25,270
all of our plugins so no mixing and

00:18:23,200 --> 00:18:28,330
matching different techniques and no

00:18:25,270 --> 00:18:30,820
special cases we came up with a somewhat

00:18:28,330 --> 00:18:33,400
novel solution for managing which

00:18:30,820 --> 00:18:34,960
plug-in is enabled at runtime for

00:18:33,400 --> 00:18:36,930
selamat err for collecting the data we

00:18:34,960 --> 00:18:39,880
wanted to default to collect everything

00:18:36,930 --> 00:18:41,800
but then allow deployers to disable

00:18:39,880 --> 00:18:44,680
certain plugins if they just knew they

00:18:41,800 --> 00:18:46,450
weren't going to use that data the

00:18:44,680 --> 00:18:48,550
solution we came up with was to use an

00:18:46,450 --> 00:18:50,020
explicit configuration file but then to

00:18:48,550 --> 00:18:51,760
invert it from what you would normally

00:18:50,020 --> 00:18:53,050
do so instead of listing what they want

00:18:51,760 --> 00:18:57,310
enabled they list what they want

00:18:53,050 --> 00:19:00,160
disabled so we load every plugin that we

00:18:57,310 --> 00:19:05,620
find and then unless it's disabled in

00:19:00,160 --> 00:19:07,870
that configuration file alright so

00:19:05,620 --> 00:19:09,360
lammeter plugins also have a chance in

00:19:07,870 --> 00:19:11,980
addition to that configuration file to

00:19:09,360 --> 00:19:13,450
automatically disable themselves which

00:19:11,980 --> 00:19:15,760
is useful in some of those Polster

00:19:13,450 --> 00:19:17,110
plugins for example if they're loaded on

00:19:15,760 --> 00:19:18,610
a system where they don't talk to that

00:19:17,110 --> 00:19:20,800
kind of hypervisor there's really no

00:19:18,610 --> 00:19:22,210
sense in polling them repeatedly and

00:19:20,800 --> 00:19:24,130
just getting warning messages or error

00:19:22,210 --> 00:19:25,990
message from them so the plug-in API

00:19:24,130 --> 00:19:28,960
actually has a method that asks the

00:19:25,990 --> 00:19:30,400
plug-in whether it should be enabled for

00:19:28,960 --> 00:19:33,160
our integration pattern we went with

00:19:30,400 --> 00:19:35,410
fine-grained api using inspection

00:19:33,160 --> 00:19:37,390
there's a separate namespace for each

00:19:35,410 --> 00:19:40,030
type of plug-in and each plug-in

00:19:37,390 --> 00:19:41,860
instance refers to a single class the

00:19:40,030 --> 00:19:43,660
application loads and instantiates the

00:19:41,860 --> 00:19:45,670
class and then calls methods on it to

00:19:43,660 --> 00:19:46,600
figure out what notifications it wants

00:19:45,670 --> 00:19:48,790
or what

00:19:46,600 --> 00:19:51,610
meter data it's going to provide and

00:19:48,790 --> 00:19:54,070
this lets us have the repetitious setup

00:19:51,610 --> 00:19:55,930
code in each plug-in and implemented by

00:19:54,070 --> 00:19:57,520
each of the plugin authors and instead

00:19:55,930 --> 00:19:59,530
the plug-in provides a little bit of

00:19:57,520 --> 00:20:00,250
metadata with simple returning lists of

00:19:59,530 --> 00:20:01,720
strings and I

00:20:00,250 --> 00:20:04,240
sort of thing so it's very easy for the

00:20:01,720 --> 00:20:06,100
plug-in authors the instances of the

00:20:04,240 --> 00:20:07,690
plugins don't know about the application

00:20:06,100 --> 00:20:09,400
they're not given that the application

00:20:07,690 --> 00:20:10,210
context and they don't know about each

00:20:09,400 --> 00:20:12,850
other at all

00:20:10,210 --> 00:20:14,620
and they only run when the application

00:20:12,850 --> 00:20:16,000
actively invokes them they're not

00:20:14,620 --> 00:20:17,170
supposed to start threads or run in the

00:20:16,000 --> 00:20:19,390
background or anything like that and

00:20:17,170 --> 00:20:22,600
that makes them very easy to isolate in

00:20:19,390 --> 00:20:24,970
a test framework to define the API

00:20:22,600 --> 00:20:26,770
itself for each set of plugins we

00:20:24,970 --> 00:20:29,530
created a separate abstract based class

00:20:26,770 --> 00:20:31,900
using the ABC module as I mentioned this

00:20:29,530 --> 00:20:33,970
gives us a way to document the plug-in

00:20:31,900 --> 00:20:36,220
API in a single place with that class

00:20:33,970 --> 00:20:37,420
and then developers who use the class as

00:20:36,220 --> 00:20:38,530
their base class get a little bit of

00:20:37,420 --> 00:20:41,290
help for free to make sure they've

00:20:38,530 --> 00:20:43,270
implemented the full API since we don't

00:20:41,290 --> 00:20:45,130
enforce the class hierarchy though we

00:20:43,270 --> 00:20:46,660
also watch for any unexpected errors any

00:20:45,130 --> 00:20:48,730
time we call into the plugin so we're

00:20:46,660 --> 00:20:49,290
trapping all the exceptions and dealing

00:20:48,730 --> 00:20:51,850
with them

00:20:49,290 --> 00:20:54,520
we used all three of the invocation

00:20:51,850 --> 00:20:56,380
patterns in different places we only use

00:20:54,520 --> 00:20:58,900
one storage system at a time so we treat

00:20:56,380 --> 00:21:00,850
that like a driver we load all of the

00:20:58,900 --> 00:21:03,310
notification plugins but then dispatch

00:21:00,850 --> 00:21:05,230
messages to them based on what events

00:21:03,310 --> 00:21:07,360
they want to see and then we load all of

00:21:05,230 --> 00:21:09,250
the Polster plugins and iterate through

00:21:07,360 --> 00:21:11,920
them on a regular basis in the in that

00:21:09,250 --> 00:21:14,110
agent so after we had all of this

00:21:11,920 --> 00:21:15,910
working inside selamat er I extracted

00:21:14,110 --> 00:21:18,790
some of the code into a standalone

00:21:15,910 --> 00:21:20,620
library called stevedore and it wraps

00:21:18,790 --> 00:21:22,540
package resources with a series of

00:21:20,620 --> 00:21:24,310
manager classes that provides a little

00:21:22,540 --> 00:21:27,550
bit of a nicer API as well as some

00:21:24,310 --> 00:21:29,320
caching each manager takes a namespace

00:21:27,550 --> 00:21:31,270
as an argument for loading the entry

00:21:29,320 --> 00:21:33,370
points and then it works with the

00:21:31,270 --> 00:21:35,980
plugins depending on the nature of the

00:21:33,370 --> 00:21:38,050
manager so for example the named

00:21:35,980 --> 00:21:39,970
extension manager only loads the plugins

00:21:38,050 --> 00:21:41,620
that you have explicitly told it to load

00:21:39,970 --> 00:21:45,100
so it'll find all of them but it'll only

00:21:41,620 --> 00:21:47,530
load some of them and that's useful if

00:21:45,100 --> 00:21:50,140
you have an explicit activation sort of

00:21:47,530 --> 00:21:52,570
configuration style now most of the

00:21:50,140 --> 00:21:54,910
managers have a map method that lets you

00:21:52,570 --> 00:21:56,320
eliminate for loops in your code where

00:21:54,910 --> 00:21:58,240
you would loop over the list of all of

00:21:56,320 --> 00:22:00,430
the managers and you basically pass a

00:21:58,240 --> 00:22:03,220
closure into the map function or the map

00:22:00,430 --> 00:22:05,410
method along with some some data if you

00:22:03,220 --> 00:22:06,880
need it and then the manager takes care

00:22:05,410 --> 00:22:09,910
of calling it trapping all of the errors

00:22:06,880 --> 00:22:12,100
and that sort of thing the enabled

00:22:09,910 --> 00:22:14,210
extension manager uses a test function

00:22:12,100 --> 00:22:16,070
to check whether the plug-in

00:22:14,210 --> 00:22:18,470
should be used after it has been loaded

00:22:16,070 --> 00:22:19,790
so we use this in selamat er where we

00:22:18,470 --> 00:22:22,910
want to give the plugins a chance to

00:22:19,790 --> 00:22:25,870
disable themself so the manager takes

00:22:22,910 --> 00:22:28,100
care of calling the right API for us and

00:22:25,870 --> 00:22:29,660
basically it loads the code but it

00:22:28,100 --> 00:22:32,030
ignores the plug-in after that if it's

00:22:29,660 --> 00:22:34,250
not going to be used the dispatch

00:22:32,030 --> 00:22:36,920
extension manager uses a test function

00:22:34,250 --> 00:22:38,900
as an argument to map to figure out

00:22:36,920 --> 00:22:42,110
which plug-in needs to receive whatever

00:22:38,900 --> 00:22:43,490
data and be called so that makes it

00:22:42,110 --> 00:22:45,530
again easy to load all of your

00:22:43,490 --> 00:22:48,170
extensions but pass the right data to

00:22:45,530 --> 00:22:50,390
the ones that expect it and then the

00:22:48,170 --> 00:22:51,980
driver manager operates on a single

00:22:50,390 --> 00:22:55,250
plug-in and gives the caller direct

00:22:51,980 --> 00:22:57,110
access to the the driver the plug-in

00:22:55,250 --> 00:23:01,400
itself instead of hiding it behind the

00:22:57,110 --> 00:23:02,870
map call stevedores part of or it's used

00:23:01,400 --> 00:23:05,180
in OpenStack but it doesn't depend on

00:23:02,870 --> 00:23:06,530
any of the other OpenStack libraries so

00:23:05,180 --> 00:23:08,590
it can be used in any of your

00:23:06,530 --> 00:23:11,210
applications if you're considering using

00:23:08,590 --> 00:23:12,800
extensible architectures like this so if

00:23:11,210 --> 00:23:15,020
you're interested in adding plugins I

00:23:12,800 --> 00:23:17,720
hope you'll take a look at it and that's

00:23:15,020 --> 00:23:20,230
it so if you have any questions I'll be

00:23:17,720 --> 00:23:20,230
happy to take them

00:23:37,440 --> 00:23:41,630
and I think they're working on right oh

00:23:39,180 --> 00:23:41,630
yeah

00:23:43,100 --> 00:23:47,539
could you just elaborate on like what

00:23:45,289 --> 00:23:51,919
some of those edge cases for doing the

00:23:47,539 --> 00:23:53,929
custom imports right so if you if you

00:23:51,919 --> 00:23:55,460
add a bunch of extra directories to your

00:23:53,929 --> 00:23:57,769
import path and this was something that

00:23:55,460 --> 00:24:00,710
I think I found a diamond you can't name

00:23:57,769 --> 00:24:04,070
your plugins in a way that uses the same

00:24:00,710 --> 00:24:05,539
file name because you have to worry it's

00:24:04,070 --> 00:24:08,029
the same thing as having two top-level

00:24:05,539 --> 00:24:09,739
packages installed insight packages with

00:24:08,029 --> 00:24:10,970
the same name the importer doesn't know

00:24:09,739 --> 00:24:13,309
which one to load you'll get the wrong

00:24:10,970 --> 00:24:15,710
one so that that's an example but

00:24:13,309 --> 00:24:17,509
there's lots of little things like files

00:24:15,710 --> 00:24:19,700
being in different places or not having

00:24:17,509 --> 00:24:22,970
them configure correctly that sort of

00:24:19,700 --> 00:24:25,100
thing howdy

00:24:22,970 --> 00:24:26,720
I think it's kind of unfortunate that

00:24:25,100 --> 00:24:29,590
people are talking over QA but it can't

00:24:26,720 --> 00:24:34,999
be helped as a warm-up are you familiar

00:24:29,590 --> 00:24:36,350
offhand with pet 302 I probably should

00:24:34,999 --> 00:24:39,710
be but the number is not ringing about

00:24:36,350 --> 00:24:42,440
it hep 302 is the meta import hook and

00:24:39,710 --> 00:24:47,059
machinery so it is allowed it is a way

00:24:42,440 --> 00:24:50,330
for a Python program to identify the way

00:24:47,059 --> 00:24:52,239
that it imports ok the way that the

00:24:50,330 --> 00:24:55,369
import statement functions at all levels

00:24:52,239 --> 00:24:56,450
and I mentioned this because I have a

00:24:55,369 --> 00:25:01,249
feeling you're not familiar with a

00:24:56,450 --> 00:25:03,859
library called XO set X is set oh yeah

00:25:01,249 --> 00:25:06,080
yeah that was the punch line access set

00:25:03,859 --> 00:25:08,480
is a library that modifies the way the

00:25:06,080 --> 00:25:11,600
Python imports things such that you can

00:25:08,480 --> 00:25:13,159
ask access set to load a module without

00:25:11,600 --> 00:25:15,619
technically importing it it doesn't

00:25:13,159 --> 00:25:17,179
appear in system modules and if that

00:25:15,619 --> 00:25:19,759
module that you have loaded tries to

00:25:17,179 --> 00:25:21,559
import things Exocet may choose to deny

00:25:19,759 --> 00:25:23,749
them or it may choose to replace them

00:25:21,559 --> 00:25:26,480
with things that are not actually the

00:25:23,749 --> 00:25:27,909
things that I wanted to import so for

00:25:26,480 --> 00:25:30,139
example you could create a synthetic

00:25:27,909 --> 00:25:32,269
import there's only available to that

00:25:30,139 --> 00:25:34,249
plug-in you can prevent the plug-in from

00:25:32,269 --> 00:25:35,869
doing things like importing threading

00:25:34,249 --> 00:25:38,779
importing multi processing important

00:25:35,869 --> 00:25:40,700
inspect etc and I was just curious as to

00:25:38,779 --> 00:25:43,039
what your opinion is on this style since

00:25:40,700 --> 00:25:45,919
you didn't appear to review any packages

00:25:43,039 --> 00:25:48,409
that use this kind of it's not aware of

00:25:45,919 --> 00:25:51,289
Exocet so thank you for that

00:25:48,409 --> 00:25:53,299
it sounds like something I would not

00:25:51,289 --> 00:25:54,960
want to use because it changes the way

00:25:53,299 --> 00:25:59,100
the behavior of

00:25:54,960 --> 00:26:01,740
ecosystem works it's intriguing but as a

00:25:59,100 --> 00:26:03,870
developer of a plug-in I wouldn't want

00:26:01,740 --> 00:26:04,980
that sort of restriction so I'm not sure

00:26:03,870 --> 00:26:06,840
that I would want to place that

00:26:04,980 --> 00:26:09,990
restriction on my plugin authors either

00:26:06,840 --> 00:26:11,400
okay but you did say that you generally

00:26:09,990 --> 00:26:14,250
don't want people to write ill-behaved

00:26:11,400 --> 00:26:14,880
plugins yeah but we're all consenting

00:26:14,250 --> 00:26:17,910
adults

00:26:14,880 --> 00:26:19,710
so yeah I mean I I figure we're writing

00:26:17,910 --> 00:26:21,360
a bunch of plugins ourselves and if the

00:26:19,710 --> 00:26:23,760
deployer writes some bad code then

00:26:21,360 --> 00:26:25,830
that's up to them to deal with seems

00:26:23,760 --> 00:26:27,330
reasonable thank you thank you I'll take

00:26:25,830 --> 00:26:36,140
a look at exercise that sounds cool

00:26:27,330 --> 00:26:36,140

YouTube URL: https://www.youtube.com/watch?v=7K72DPDOhWo


