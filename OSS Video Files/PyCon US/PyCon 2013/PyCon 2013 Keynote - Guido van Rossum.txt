Title: PyCon 2013 Keynote - Guido van Rossum
Publication date: 2013-05-11
Playlist: PyCon 2013
Description: 
	In this keynote Guido van Rossum, Python's Benevelent Dictator for Life, presents a new, interoperable approach to asynchronous I/O that is being developed for inclusion in Python 3.4.
Captions: 
	00:00:00,060 --> 00:00:05,009
so I don't really think we need to do

00:00:02,460 --> 00:00:19,050
anything else except welcome guido van

00:00:05,009 --> 00:00:23,160
rossum ladies and gentlemen hello can

00:00:19,050 --> 00:00:27,750
you hear me well this is amazing okay

00:00:23,160 --> 00:00:29,160
I'm gonna try to be very technical so if

00:00:27,750 --> 00:00:31,219
you're if you're not feeling very

00:00:29,160 --> 00:00:35,190
technical this morning still a little

00:00:31,219 --> 00:00:41,489
tired from last night's party it's okay

00:00:35,190 --> 00:00:44,190
if you leave so not too long ago

00:00:41,489 --> 00:00:49,430
actually about half year ago on Python

00:00:44,190 --> 00:00:52,260
ideas someone innocently asked or

00:00:49,430 --> 00:00:55,140
started proposing making some changes to

00:00:52,260 --> 00:00:58,969
a sink or under the wonderful title a

00:00:55,140 --> 00:01:02,579
sink or included batteries don't fit I

00:00:58,969 --> 00:01:04,890
think I have the first page of the

00:01:02,579 --> 00:01:11,580
message here this was very quickly

00:01:04,890 --> 00:01:13,290
evolved into a Santa thread I was piqued

00:01:11,580 --> 00:01:17,040
by the topic

00:01:13,290 --> 00:01:18,689
I knew that async stuff was sort of

00:01:17,040 --> 00:01:22,650
controversial there were lots of ways of

00:01:18,689 --> 00:01:25,740
doing it and I decided to dive in and

00:01:22,650 --> 00:01:27,780
and sort of what prompted me to dive in

00:01:25,740 --> 00:01:31,619
well I had just done a whole bunch of

00:01:27,780 --> 00:01:35,460
asynchronous stuff including novel async

00:01:31,619 --> 00:01:39,540
API design for Google App Engine and so

00:01:35,460 --> 00:01:41,280
I felt that unless unlike previous times

00:01:39,540 --> 00:01:43,409
when asynchronous stuff came up I

00:01:41,280 --> 00:01:46,470
actually had some understanding of why

00:01:43,409 --> 00:01:50,280
people cared about async api's and why

00:01:46,470 --> 00:01:53,240
it's also why it was so controversial so

00:01:50,280 --> 00:01:53,240
let's take a deep breath

00:01:53,270 --> 00:02:00,390
what is asynchronous i/o well deep down

00:01:57,659 --> 00:02:02,460
at the bottom it's whenever you're

00:02:00,390 --> 00:02:05,340
waiting for i/o and you're also doing

00:02:02,460 --> 00:02:07,979
something else which is as opposed to

00:02:05,340 --> 00:02:10,020
the normal sort of default operation of

00:02:07,979 --> 00:02:13,030
Python and most other programming

00:02:10,020 --> 00:02:15,670
languages where you say input

00:02:13,030 --> 00:02:17,560
and then your program is not capable of

00:02:15,670 --> 00:02:21,310
doing anything until the user actually

00:02:17,560 --> 00:02:24,120
typed a line of text a thinker is I

00:02:21,310 --> 00:02:28,720
always actually as old as computers

00:02:24,120 --> 00:02:30,580
because back in 1945 the input devices

00:02:28,720 --> 00:02:33,640
that they had were also much slower than

00:02:30,580 --> 00:02:36,700
the central processing unit so there are

00:02:33,640 --> 00:02:39,670
lots of approaches interrupts that

00:02:36,700 --> 00:02:43,300
callbacks events and we'll get back to

00:02:39,670 --> 00:02:46,060
more about what sort of different ways

00:02:43,300 --> 00:02:48,040
of dealing with this let's first look a

00:02:46,060 --> 00:02:51,730
little bit of why why do you want a

00:02:48,040 --> 00:02:53,860
synchronous i/o why do people say we

00:02:51,730 --> 00:02:55,780
need asynchronous i/o in the standard

00:02:53,860 --> 00:02:59,650
library where does it come from well as

00:02:55,780 --> 00:03:03,010
I said I always slow and since the CPU

00:02:59,650 --> 00:03:05,709
is mostly not needed for handling I have

00:03:03,010 --> 00:03:07,360
any of that if you have a bunch of

00:03:05,709 --> 00:03:09,310
different things that you all need to be

00:03:07,360 --> 00:03:11,470
done it would be great if you could keep

00:03:09,310 --> 00:03:13,630
doing some of the things that do use the

00:03:11,470 --> 00:03:16,390
CPU while you're also waiting for it for

00:03:13,630 --> 00:03:19,570
your i/o and then at some point when the

00:03:16,390 --> 00:03:20,320
i/o is actually done you can start doing

00:03:19,570 --> 00:03:23,380
more i/o

00:03:20,320 --> 00:03:25,600
or get the results out of that one

00:03:23,380 --> 00:03:26,769
example that's is kind of a different

00:03:25,600 --> 00:03:28,360
approach that doesn't have to do so much

00:03:26,769 --> 00:03:31,780
with doing lots of things once but

00:03:28,360 --> 00:03:33,070
keeping user interface between apps and

00:03:31,780 --> 00:03:34,600
safe is your outlet area knowing if now

00:03:33,070 --> 00:03:43,239
you get to people animals or verifying

00:03:34,600 --> 00:03:44,829
Excel it was very good there are reasons

00:03:43,239 --> 00:03:46,989
awesome parties and it's actually that

00:03:44,829 --> 00:03:48,310
you have multiple things of i/o that you

00:03:46,989 --> 00:03:51,250
all need to do and they're independent

00:03:48,310 --> 00:03:55,620
like fetching ten things from the web or

00:03:51,250 --> 00:03:58,209
handling a thousand incoming connections

00:03:55,620 --> 00:04:00,730
so there are lots of reasons why people

00:03:58,209 --> 00:04:03,880
want to use asynchronous i/o and what

00:04:00,730 --> 00:04:08,260
what is this sort of the most common

00:04:03,880 --> 00:04:10,510
tool that people go for is threads so

00:04:08,260 --> 00:04:12,610
why not just sort of say well let's

00:04:10,510 --> 00:04:17,890
let's use threads because that's are

00:04:12,610 --> 00:04:19,720
actually a pretty common paradigm there

00:04:17,890 --> 00:04:22,630
you're well understood they're supported

00:04:19,720 --> 00:04:24,550
by all operating systems and the nice

00:04:22,630 --> 00:04:25,540
thing of threads is that you can still

00:04:24,550 --> 00:04:27,450
write this

00:04:25,540 --> 00:04:30,640
simple synchronous code where you say

00:04:27,450 --> 00:04:35,740
input and you're justyou're your thread

00:04:30,640 --> 00:04:37,810
is just blocking for some input to

00:04:35,740 --> 00:04:40,090
happen for the user to enter a line or

00:04:37,810 --> 00:04:42,070
for a server to give you a packet or

00:04:40,090 --> 00:04:46,720
something but your other threads will

00:04:42,070 --> 00:04:50,590
still run my voice is doing funny things

00:04:46,720 --> 00:04:52,380
I'm going to lubricate it a little bit

00:04:50,590 --> 00:04:57,460
maybe that helps

00:04:52,380 --> 00:04:59,890
so unfortunately threads have their

00:04:57,460 --> 00:05:01,420
limits operating system threads as they

00:04:59,890 --> 00:05:04,480
currently exist in modern operating

00:05:01,420 --> 00:05:07,510
systems are wonderful things but they

00:05:04,480 --> 00:05:09,760
are kind of costly if you have 10

00:05:07,510 --> 00:05:12,880
threads great if you have a hundred

00:05:09,760 --> 00:05:14,620
threads depending on how powerful your

00:05:12,880 --> 00:05:17,740
machine is you might get little worried

00:05:14,620 --> 00:05:20,530
if you have a thousand threads you're

00:05:17,740 --> 00:05:22,960
probably already using your your sort of

00:05:20,530 --> 00:05:25,570
your asynchronous i/o system for

00:05:22,960 --> 00:05:27,370
handling lots of socket connections for

00:05:25,570 --> 00:05:29,530
example when you're in a server that

00:05:27,370 --> 00:05:31,750
just deals with lots of clients and

00:05:29,530 --> 00:05:35,440
maybe the clients are very slow or maybe

00:05:31,750 --> 00:05:39,520
you're intentionally sort of HTTP long

00:05:35,440 --> 00:05:41,500
polling them the number of sockets you

00:05:39,520 --> 00:05:43,480
mean operating system kernels impose

00:05:41,500 --> 00:05:44,920
limits on how much of everything you can

00:05:43,480 --> 00:05:46,690
have you can now have so many file

00:05:44,920 --> 00:05:48,520
descriptors there are only so many bytes

00:05:46,690 --> 00:05:51,040
of memory available you can only have so

00:05:48,520 --> 00:05:52,930
many processors you can also have only a

00:05:51,040 --> 00:05:54,670
certain number of sockets open at the

00:05:52,930 --> 00:05:56,770
time the kernel will just run out of

00:05:54,670 --> 00:05:58,780
space for them and the maximum number of

00:05:56,770 --> 00:06:01,720
threads like one or two orders of

00:05:58,780 --> 00:06:03,460
magnitude so if you want to get the sort

00:06:01,720 --> 00:06:06,220
of the most out of your server machine

00:06:03,460 --> 00:06:08,350
and be able to handle as many

00:06:06,220 --> 00:06:10,300
connections as you can you can't have a

00:06:08,350 --> 00:06:11,680
single you can't have a thread per

00:06:10,300 --> 00:06:13,150
connection because you'll run out of

00:06:11,680 --> 00:06:17,890
threads way before you run out of

00:06:13,150 --> 00:06:20,410
sockets finally of course a big problem

00:06:17,890 --> 00:06:22,900
with operating system threads the way

00:06:20,410 --> 00:06:26,590
they work is that they have pre-emptive

00:06:22,900 --> 00:06:29,320
thread scheduling which means that at

00:06:26,590 --> 00:06:31,960
any time when your thread is running

00:06:29,320 --> 00:06:33,670
even if it's not blocking for i/o the

00:06:31,960 --> 00:06:35,230
scheduler can decide that you've run

00:06:33,670 --> 00:06:36,000
long enough that some other thread will

00:06:35,230 --> 00:06:37,740
run

00:06:36,000 --> 00:06:39,570
and so now this means that if you have

00:06:37,740 --> 00:06:41,220
two statements running in one thread and

00:06:39,570 --> 00:06:43,650
two statements running in another thread

00:06:41,220 --> 00:06:46,230
and they're somehow reading or writing

00:06:43,650 --> 00:06:49,020
the same global variable or shared

00:06:46,230 --> 00:06:51,420
variable in general there are I don't

00:06:49,020 --> 00:06:56,540
know four or six different ways that

00:06:51,420 --> 00:06:59,430
those statements can be interleaved and

00:06:56,540 --> 00:07:00,930
you probably don't hit every single

00:06:59,430 --> 00:07:05,490
combination when you're writing your

00:07:00,930 --> 00:07:08,340
tests so you end up with race conditions

00:07:05,490 --> 00:07:11,250
where the scheduler hits you at just the

00:07:08,340 --> 00:07:13,650
wrong moment when you have two global

00:07:11,250 --> 00:07:15,510
variables that need to be in lockstep

00:07:13,650 --> 00:07:17,510
and one of them has been updated the

00:07:15,510 --> 00:07:20,400
other the other one hasn't hasn't yet

00:07:17,510 --> 00:07:23,700
something like this of course we now we

00:07:20,400 --> 00:07:25,980
add locks to our program and if we're

00:07:23,700 --> 00:07:28,650
really good at sort of using locks

00:07:25,980 --> 00:07:30,270
well now suddenly the program doesn't

00:07:28,650 --> 00:07:32,450
run very fast because everything's

00:07:30,270 --> 00:07:35,070
constantly waiting for that lock so

00:07:32,450 --> 00:07:36,080
there there are other ways even though

00:07:35,070 --> 00:07:38,490
there also

00:07:36,080 --> 00:07:40,500
some people have proven that you can

00:07:38,490 --> 00:07:41,880
actually get quite far with threads in

00:07:40,500 --> 00:07:44,580
sort of the most modern operating

00:07:41,880 --> 00:07:47,790
systems it's not it's not a completely

00:07:44,580 --> 00:07:49,650
decided answer that threads are always

00:07:47,790 --> 00:07:51,900
worse than asynchronous i/o but they

00:07:49,650 --> 00:07:55,950
each have their sort of their pluses and

00:07:51,900 --> 00:07:59,510
minuses so how do you do asynchronous

00:07:55,950 --> 00:08:02,400
i/o with threads sorry without threads

00:07:59,510 --> 00:08:05,310
their system calls like select and pull

00:08:02,400 --> 00:08:08,660
and a few others that only exist on

00:08:05,310 --> 00:08:12,840
certain platforms like eople and KQ

00:08:08,660 --> 00:08:15,770
their higher-level API is on top of that

00:08:12,840 --> 00:08:20,370
in Python like async or which

00:08:15,770 --> 00:08:22,770
unfortunately was invented over 15 years

00:08:20,370 --> 00:08:25,590
ago and is really showing its age it's

00:08:22,770 --> 00:08:29,400
sort of using sub classing as an api

00:08:25,590 --> 00:08:31,470
style and it's not very extensible in

00:08:29,400 --> 00:08:33,810
the right direction and so on and so

00:08:31,470 --> 00:08:35,430
forth so most people ignore that and

00:08:33,810 --> 00:08:38,190
write their own things straight on top

00:08:35,430 --> 00:08:39,750
of select and Paul there are a bunch of

00:08:38,190 --> 00:08:42,110
things that you can get wrong but it's

00:08:39,750 --> 00:08:45,690
also not rocket science

00:08:42,110 --> 00:08:47,670
drum Kohan who is a master of internet

00:08:45,690 --> 00:08:48,930
protocols always writes his own because

00:08:47,670 --> 00:08:53,010
he always get get

00:08:48,930 --> 00:08:55,350
better results that he claims or you can

00:08:53,010 --> 00:08:57,240
use an asynchronous framework there are

00:08:55,350 --> 00:08:59,490
plenty of frameworks to choose from that

00:08:57,240 --> 00:09:06,270
support asynchronous IO like twisted

00:08:59,490 --> 00:09:08,399
tornado something called 0 mq or you can

00:09:06,270 --> 00:09:10,320
wrap existing c libraries there are a

00:09:08,399 --> 00:09:12,000
number of competing c libraries that

00:09:10,320 --> 00:09:14,820
that solve this problem for C

00:09:12,000 --> 00:09:16,920
programmers and they've all gotten at

00:09:14,820 --> 00:09:18,630
least one Python wrapper as well so

00:09:16,920 --> 00:09:21,060
there's Libby fan which I think is the

00:09:18,630 --> 00:09:24,660
original and has since evolved into lib

00:09:21,060 --> 00:09:28,320
event - but there's also LED Eevee which

00:09:24,660 --> 00:09:30,360
was sort of a better live event and then

00:09:28,320 --> 00:09:33,029
there was live UV which is an even

00:09:30,360 --> 00:09:36,750
better live Eevee and I think live UV is

00:09:33,029 --> 00:09:38,360
popular and powerful because it's used

00:09:36,750 --> 00:09:41,070
by nodejs

00:09:38,360 --> 00:09:45,149
but when you wrap those you end up with

00:09:41,070 --> 00:09:47,850
a rather see like API style they're also

00:09:45,149 --> 00:09:49,680
completely different approaches I think

00:09:47,850 --> 00:09:55,200
Christian peers were started this with

00:09:49,680 --> 00:09:56,610
stackless and then G's and sort of built

00:09:55,200 --> 00:10:00,360
that out in a slightly different

00:09:56,610 --> 00:10:03,330
direction based on I think Green let's

00:10:00,360 --> 00:10:04,980
Arman rigo's magical tricks and there's

00:10:03,330 --> 00:10:06,180
also something called the event list and

00:10:04,980 --> 00:10:08,550
there's probably a couple of more and

00:10:06,180 --> 00:10:10,589
almost all of them have the event let's

00:10:08,550 --> 00:10:13,529
say sorry have the greenland's at the

00:10:10,589 --> 00:10:18,690
bottom of them there's also some overlap

00:10:13,529 --> 00:10:20,640
here so none of these alternative

00:10:18,690 --> 00:10:23,820
approaches even though they all solve

00:10:20,640 --> 00:10:25,200
the problem of race conditions and you

00:10:23,820 --> 00:10:26,550
want more sockets then you can have

00:10:25,200 --> 00:10:29,790
threads and stuff like that

00:10:26,550 --> 00:10:31,620
they all have their downsides one of the

00:10:29,790 --> 00:10:36,029
downsides is actually there are too many

00:10:31,620 --> 00:10:38,910
different ones both of them are in some

00:10:36,029 --> 00:10:41,520
way based on callbacks the stackless G's

00:10:38,910 --> 00:10:44,760
and family excluded and nobody likes

00:10:41,520 --> 00:10:46,620
callbacks well at least when I say I

00:10:44,760 --> 00:10:49,700
don't like callbacks everybody always

00:10:46,620 --> 00:10:49,700
goes here here

00:10:50,490 --> 00:10:55,899
because you can't really get around some

00:10:53,500 --> 00:10:59,139
level of callbacks the api's are usually

00:10:55,899 --> 00:11:01,569
pretty complicated and the standard

00:10:59,139 --> 00:11:05,759
library is of very little use once

00:11:01,569 --> 00:11:08,500
you're using an asynchronous framework

00:11:05,759 --> 00:11:10,810
and now of course everybody who knows

00:11:08,500 --> 00:11:14,440
anything about G Fant is say yes but

00:11:10,810 --> 00:11:19,089
chief and solves all that and yet G

00:11:14,440 --> 00:11:21,040
event is somehow to me it doesn't do it

00:11:19,089 --> 00:11:23,889
it has released carry implementation

00:11:21,040 --> 00:11:26,709
details in the green 'lets level it's

00:11:23,889 --> 00:11:30,459
pretty much C Python specific it's Intel

00:11:26,709 --> 00:11:32,500
x86 specific it's actually really hacky

00:11:30,459 --> 00:11:35,579
C code that copies the stack and certain

00:11:32,500 --> 00:11:39,339
the C stack in certain situations

00:11:35,579 --> 00:11:41,620
there's also a monkey-patching approach

00:11:39,339 --> 00:11:44,290
to make the standard libraries sort of

00:11:41,620 --> 00:11:46,089
work so you won't get patched the

00:11:44,290 --> 00:11:49,089
standard library and then you start

00:11:46,089 --> 00:11:51,970
using existing standard library

00:11:49,089 --> 00:11:54,670
operations like URL Lib or HTTP Lib and

00:11:51,970 --> 00:11:56,500
you hope that it actually works because

00:11:54,670 --> 00:12:01,000
you never know with this monkey-patching

00:11:56,500 --> 00:12:04,870
stuff and unfortunately you're still not

00:12:01,000 --> 00:12:08,069
completely clear of the problem that the

00:12:04,870 --> 00:12:10,689
scheduler could as a random moment

00:12:08,069 --> 00:12:13,990
interrupt your task and switch to a

00:12:10,689 --> 00:12:15,639
different one now if you talk to G vent

00:12:13,990 --> 00:12:17,290
and Greenland people they always say oh

00:12:15,639 --> 00:12:19,120
you know exactly when it switches

00:12:17,290 --> 00:12:21,250
because there's a very specific call

00:12:19,120 --> 00:12:26,589
into the greenlab API you have to make

00:12:21,250 --> 00:12:29,920
that switches unfortunately any function

00:12:26,589 --> 00:12:32,439
you call can also make that call and any

00:12:29,920 --> 00:12:35,290
function that you call today that

00:12:32,439 --> 00:12:38,620
somehow today you happen to know that it

00:12:35,290 --> 00:12:40,959
never switches tomorrow someone could

00:12:38,620 --> 00:12:43,990
add a logging statement or a lazy

00:12:40,959 --> 00:12:47,350
caching or consulting of a settings file

00:12:43,990 --> 00:12:49,209
or who knows what kind of extra optional

00:12:47,350 --> 00:12:54,160
feature and every once in a while that

00:12:49,209 --> 00:12:55,540
function does block and suddenly so

00:12:54,160 --> 00:12:58,870
you're you're basically you're in the

00:12:55,540 --> 00:13:01,130
same situation as with classic OS

00:12:58,870 --> 00:13:07,460
threads that you cannot really

00:13:01,130 --> 00:13:09,920
trust when you will be switched and when

00:13:07,460 --> 00:13:12,260
you won't be switched and the worst part

00:13:09,920 --> 00:13:14,240
is that if you're if you're not careful

00:13:12,260 --> 00:13:16,460
you can still run into the situation

00:13:14,240 --> 00:13:19,730
where you don't switch enough and one

00:13:16,460 --> 00:13:23,420
one stupid thread that somehow sitting

00:13:19,730 --> 00:13:25,610
in a tight loop can completely use of

00:13:23,420 --> 00:13:28,550
all the CPU and all the other threads

00:13:25,610 --> 00:13:32,710
with tasks waiting for IO won't do it so

00:13:28,550 --> 00:13:35,240
I can't help it but I would like a a

00:13:32,710 --> 00:13:38,620
system where I can actually tell whether

00:13:35,240 --> 00:13:40,970
a particular line of code is is possibly

00:13:38,620 --> 00:13:46,180
suspending the current task of thread or

00:13:40,970 --> 00:13:46,180
not so what are we going to do

00:13:46,210 --> 00:13:52,700
courtesy randall of course we're going

00:13:50,660 --> 00:13:54,680
to introduce yet another standard

00:13:52,700 --> 00:14:01,330
framework that's going to replace all

00:13:54,680 --> 00:14:01,330
the other standard frameworks seriously

00:14:06,950 --> 00:14:12,300
let's finally standardize that event

00:14:09,690 --> 00:14:16,350
loop because at the bottom of all of

00:14:12,300 --> 00:14:19,380
these including GE events there is an

00:14:16,350 --> 00:14:21,570
event loop and sort of there aren't too

00:14:19,380 --> 00:14:27,390
many choices in how you implement an

00:14:21,570 --> 00:14:28,800
event loop an event loops sort of date

00:14:27,390 --> 00:14:30,420
there is a certain amount of

00:14:28,800 --> 00:14:31,980
functionality that they have to have

00:14:30,420 --> 00:14:34,410
they have to manage your callbacks they

00:14:31,980 --> 00:14:36,060
have to manage your file descriptors you

00:14:34,410 --> 00:14:40,110
have to tell at which file descriptors

00:14:36,060 --> 00:14:42,660
you care about and one way or another

00:14:40,110 --> 00:14:44,520
they're all sort of doing more or less

00:14:42,660 --> 00:14:47,580
the same things but sort of how you

00:14:44,520 --> 00:14:49,740
write what you want the event loop to do

00:14:47,580 --> 00:14:56,850
is vastly different for each of these

00:14:49,740 --> 00:14:59,250
systems so why why is the event loop so

00:14:56,850 --> 00:15:01,290
special because on the one hand the

00:14:59,250 --> 00:15:03,810
event loop is the thing that serializes

00:15:01,290 --> 00:15:05,730
things the event loop is the thing that

00:15:03,810 --> 00:15:08,100
guarantees that while your code is

00:15:05,730 --> 00:15:10,350
running no other code will also be

00:15:08,100 --> 00:15:12,210
running and given that Python has a

00:15:10,350 --> 00:15:14,760
global interpreter lock there's not

00:15:12,210 --> 00:15:16,350
actually all that much advantage in

00:15:14,760 --> 00:15:17,880
having other code running while your

00:15:16,350 --> 00:15:20,180
code is running because you're not

00:15:17,880 --> 00:15:23,070
making more progress together

00:15:20,180 --> 00:15:25,410
so this serializing of events is a very

00:15:23,070 --> 00:15:27,540
powerful mechanism if if it's done right

00:15:25,410 --> 00:15:29,640
because it gives you the knowledge that

00:15:27,540 --> 00:15:31,680
no one else is going to mess with the

00:15:29,640 --> 00:15:33,930
global state or the shared state until

00:15:31,680 --> 00:15:37,290
you say that you're done with it so you

00:15:33,930 --> 00:15:39,210
have sort of implicit locking of course

00:15:37,290 --> 00:15:41,940
in order for this to work you can only

00:15:39,210 --> 00:15:43,860
have one event loop and this is why the

00:15:41,940 --> 00:15:46,380
event loop is so special and why it's

00:15:43,860 --> 00:15:48,180
important to sort of move the standard

00:15:46,380 --> 00:15:50,370
event the event loop into the standard

00:15:48,180 --> 00:15:52,650
library and sort of take ownership of

00:15:50,370 --> 00:15:55,200
that thing because there shouldn't there

00:15:52,650 --> 00:15:57,060
should really be only one event loop you

00:15:55,200 --> 00:16:00,260
can't have the twisted event loop and

00:15:57,060 --> 00:16:04,380
the G event loop in a single process

00:16:00,260 --> 00:16:08,730
because there's they would just be sort

00:16:04,380 --> 00:16:10,800
of competing for for who is the only one

00:16:08,730 --> 00:16:12,950
that's currently running and sort of

00:16:10,800 --> 00:16:15,490
switching switching between them

00:16:12,950 --> 00:16:18,129
carefully it's not very effective

00:16:15,490 --> 00:16:19,660
so because each framework has its own

00:16:18,129 --> 00:16:25,059
event loop they don't really cool

00:16:19,660 --> 00:16:26,649
interoperate very well so I went back

00:16:25,059 --> 00:16:29,110
and I looked at a whole bunch of

00:16:26,649 --> 00:16:31,179
different frameworks and specifically at

00:16:29,110 --> 00:16:33,040
their event loops and I also talked to a

00:16:31,179 --> 00:16:35,740
bunch of people thank you glyph thank

00:16:33,040 --> 00:16:39,610
you Ben Darnell

00:16:35,740 --> 00:16:42,490
thank you various other people what you

00:16:39,610 --> 00:16:44,649
have is there's an event loop it runs or

00:16:42,490 --> 00:16:48,730
it doesn't run usually there are ways to

00:16:44,649 --> 00:16:52,119
start it and to stop it occasionally the

00:16:48,730 --> 00:16:53,679
event loop is just always running but

00:16:52,119 --> 00:16:55,350
you have to usually you have to somehow

00:16:53,679 --> 00:16:59,800
manage it you also have to access it

00:16:55,350 --> 00:17:01,660
then a very fundamental thing is here's

00:16:59,800 --> 00:17:04,120
a function I want this function called

00:17:01,660 --> 00:17:06,880
at some point in the future that point

00:17:04,120 --> 00:17:09,069
in the future maybe like right now like

00:17:06,880 --> 00:17:11,709
right after the current event handler is

00:17:09,069 --> 00:17:13,480
finished or it might be at a specific

00:17:11,709 --> 00:17:16,179
number of seconds or milliseconds in the

00:17:13,480 --> 00:17:17,860
future there's a variant there where you

00:17:16,179 --> 00:17:21,130
say well here's a function that I would

00:17:17,860 --> 00:17:24,179
like to call every two seconds or so and

00:17:21,130 --> 00:17:27,549
the final piece of functionality is I

00:17:24,179 --> 00:17:30,429
have a file descriptor or maybe some

00:17:27,549 --> 00:17:33,399
other object that represents IO activity

00:17:30,429 --> 00:17:35,830
to the operating system and there's so

00:17:33,399 --> 00:17:39,610
much asynchronous i/o going on on that

00:17:35,830 --> 00:17:41,620
file descriptor or that IO object and I

00:17:39,610 --> 00:17:44,559
want to know when that is ready and

00:17:41,620 --> 00:17:48,909
depending on which paradigm you're use

00:17:44,559 --> 00:17:52,330
you're using on UNIX it's usually sort

00:17:48,909 --> 00:17:54,580
of when is the thing ready so I can

00:17:52,330 --> 00:17:58,539
start reading at least start attempting

00:17:54,580 --> 00:18:00,460
to read or write Windows iocp has a

00:17:58,539 --> 00:18:03,100
different model where you say I want to

00:18:00,460 --> 00:18:05,230
do this please this type of i/o and then

00:18:03,100 --> 00:18:06,850
you want to know when is the i/o done so

00:18:05,230 --> 00:18:09,549
ready and done are two different

00:18:06,850 --> 00:18:11,380
paradigms and we'll get back to that but

00:18:09,549 --> 00:18:13,899
that's that's about all you need in an

00:18:11,380 --> 00:18:15,399
event loop and you need it to sort of

00:18:13,899 --> 00:18:20,260
abstract over the different

00:18:15,399 --> 00:18:22,029
possibilities for for actually asking

00:18:20,260 --> 00:18:24,279
the operating system to multiplex the

00:18:22,029 --> 00:18:26,710
i/o so you want to have an intelligent

00:18:24,279 --> 00:18:27,940
switch between select and hole and a

00:18:26,710 --> 00:18:33,759
pole and

00:18:27,940 --> 00:18:36,730
everything else so hopefully with some

00:18:33,759 --> 00:18:38,440
luck a univer unified event loop could

00:18:36,730 --> 00:18:40,389
actually solve the problem that the

00:18:38,440 --> 00:18:43,149
frameworks that currently exist

00:18:40,389 --> 00:18:45,220
don't interrupt rate very well now

00:18:43,149 --> 00:18:46,899
actually why would why is it so

00:18:45,220 --> 00:18:48,899
important that the frameworks can

00:18:46,899 --> 00:18:51,429
interoperate well the reason is that

00:18:48,899 --> 00:18:53,919
every framework has its strengths and

00:18:51,429 --> 00:18:56,470
its weaknesses if you want to have good

00:18:53,919 --> 00:18:59,289
implementations of esoteric internet

00:18:56,470 --> 00:19:01,750
protocols that have been debugged for a

00:18:59,289 --> 00:19:06,700
long time a twisted is your friend if

00:19:01,750 --> 00:19:09,279
you want to do web server stuff maybe

00:19:06,700 --> 00:19:11,259
tornado is what you want

00:19:09,279 --> 00:19:14,259
having tornado when twisted work

00:19:11,259 --> 00:19:16,870
together at least when tornado

00:19:14,259 --> 00:19:19,450
originally came out was impossible I've

00:19:16,870 --> 00:19:22,450
heard I have not verified that tornado

00:19:19,450 --> 00:19:27,009
now has a separate adapter that says you

00:19:22,450 --> 00:19:28,419
can actually use tornado in combination

00:19:27,009 --> 00:19:30,970
with twisted so for that particular

00:19:28,419 --> 00:19:33,370
pairwise combination Interop has being

00:19:30,970 --> 00:19:34,960
solved on the other hand there's no way

00:19:33,370 --> 00:19:37,299
that you could run twist it with the

00:19:34,960 --> 00:19:39,580
tornado main loop so the tornado people

00:19:37,299 --> 00:19:45,639
just sort of give up and say use this

00:19:39,580 --> 00:19:47,679
other main event loop and adapt it there

00:19:45,639 --> 00:19:50,799
are a few others of those but it's easy

00:19:47,679 --> 00:19:53,409
to find sort of pairs of frameworks that

00:19:50,799 --> 00:19:55,000
have no way to interoperate or you'd

00:19:53,409 --> 00:19:56,500
have to run one in one thread and

00:19:55,000 --> 00:20:00,659
another in another thread and then you

00:19:56,500 --> 00:20:00,659
lose a lot of the advantages

00:20:01,019 --> 00:20:07,870
so this is where pep 3156 came in and a

00:20:05,110 --> 00:20:10,149
reminder unfortunately we're violating

00:20:07,870 --> 00:20:12,039
this wonderful directive of not trying

00:20:10,149 --> 00:20:13,929
to solve the problem of too many

00:20:12,039 --> 00:20:17,110
standards by adding one we're still

00:20:13,929 --> 00:20:18,610
adding one but this one can actually be

00:20:17,110 --> 00:20:21,419
called standard because it will be in

00:20:18,610 --> 00:20:21,419
the standard library

00:20:22,360 --> 00:20:30,159
yes I really no this is madness everyone

00:20:27,200 --> 00:20:33,769
has their favorite framework let's just

00:20:30,159 --> 00:20:36,080
move to the first response actually to

00:20:33,769 --> 00:20:38,360
that long and well-thought-out message

00:20:36,080 --> 00:20:41,149
about fixing a sink or the first

00:20:38,360 --> 00:20:43,730
response was a one-liner that said why

00:20:41,149 --> 00:20:45,289
don't we do that I think it said so you

00:20:43,730 --> 00:20:48,259
just want twisted in the standard

00:20:45,289 --> 00:20:54,350
library and there was a lot of

00:20:48,259 --> 00:20:58,429
disagreement that after that yeah if we

00:20:54,350 --> 00:21:02,450
if we sort of if I personally believe in

00:20:58,429 --> 00:21:04,340
GE vent we could put that in the

00:21:02,450 --> 00:21:06,200
standard library and say everything in

00:21:04,340 --> 00:21:08,269
the standard library is always using G

00:21:06,200 --> 00:21:10,779
events that probably would leave a large

00:21:08,269 --> 00:21:15,080
number of people unhappy nevertheless

00:21:10,779 --> 00:21:17,480
also I mean if the right way to do that

00:21:15,080 --> 00:21:20,690
would probably to go back even further

00:21:17,480 --> 00:21:23,899
in history and sort of adopt stackless

00:21:20,690 --> 00:21:26,600
python which was always intended to be

00:21:23,899 --> 00:21:29,269
eventually become a part of standard

00:21:26,600 --> 00:21:31,429
Python and I've always held off on that

00:21:29,269 --> 00:21:34,759
for reasons similar to what I mentioned

00:21:31,429 --> 00:21:41,620
about G events so I'm still not doing

00:21:34,759 --> 00:21:44,929
that yeah why not grab one of the

00:21:41,620 --> 00:21:46,820
industry standards that live exist at

00:21:44,929 --> 00:21:49,309
the sea level well okay there's still

00:21:46,820 --> 00:21:51,380
too many to choose so I just made up my

00:21:49,309 --> 00:21:55,070
own

00:21:51,380 --> 00:21:57,500
I did but I didn't completely make it up

00:21:55,070 --> 00:22:02,300
I actually looked around and and sort of

00:21:57,500 --> 00:22:04,190
I I felt what sort of what are the

00:22:02,300 --> 00:22:08,270
problems that everyone needs to solve

00:22:04,190 --> 00:22:10,820
like there's this thing with you need to

00:22:08,270 --> 00:22:12,770
be able to everything needs to work

00:22:10,820 --> 00:22:15,350
regardless of whether underneath you're

00:22:12,770 --> 00:22:17,420
using select or Paul or equal or KQ

00:22:15,350 --> 00:22:20,060
those things need to be completely

00:22:17,420 --> 00:22:22,760
abstracted away because they're just all

00:22:20,060 --> 00:22:27,310
different ways of doing exactly the same

00:22:22,760 --> 00:22:29,860
thing which is asking a UNIX kernel or

00:22:27,310 --> 00:22:32,150
some flavor of Unix

00:22:29,860 --> 00:22:34,280
giving it a bunch of file descriptors

00:22:32,150 --> 00:22:39,080
and ask when some of them are ready for

00:22:34,280 --> 00:22:41,630
i/o again other things that sort of are

00:22:39,080 --> 00:22:45,910
obvious is the callbacks I mentioned

00:22:41,630 --> 00:22:49,450
timed callbacks all those things so I

00:22:45,910 --> 00:22:52,850
looked around I came up with my own

00:22:49,450 --> 00:22:55,880
minimal version my originally my minimal

00:22:52,850 --> 00:23:00,790
version was truly minimal everything was

00:22:55,880 --> 00:23:03,980
in one file it only worked on on UNIX

00:23:00,790 --> 00:23:06,860
then I started comparing notes with

00:23:03,980 --> 00:23:09,350
other frameworks I looked at the tornado

00:23:06,860 --> 00:23:11,810
frame the tornado we can't look and it

00:23:09,350 --> 00:23:15,110
looked pretty similar so I thought okay

00:23:11,810 --> 00:23:16,640
well I guess even if I start in a vacuum

00:23:15,110 --> 00:23:18,230
I can come up with something that's

00:23:16,640 --> 00:23:21,800
pretty close to what other people have

00:23:18,230 --> 00:23:24,410
come up with - but there were some

00:23:21,800 --> 00:23:26,180
differences and there were some tricks

00:23:24,410 --> 00:23:29,750
that I had missed and there were also

00:23:26,180 --> 00:23:32,030
some dubious design choices that I

00:23:29,750 --> 00:23:34,220
decided not to copy and then I looked to

00:23:32,030 --> 00:23:35,990
look to twist it and I couldn't actually

00:23:34,220 --> 00:23:38,500
find where the code was so I called

00:23:35,990 --> 00:23:38,500
glyph and

00:23:39,240 --> 00:23:44,890
we had a bunch of very productive

00:23:42,400 --> 00:23:48,130
meetings where he completely brainwashed

00:23:44,890 --> 00:23:53,500
me and now I'm a twisted fan but not

00:23:48,130 --> 00:23:56,460
really there's something inside twisted

00:23:53,500 --> 00:23:59,770
that I really like and that's

00:23:56,460 --> 00:24:03,040
abstractions that are slightly higher

00:23:59,770 --> 00:24:04,780
level than select based because of

00:24:03,040 --> 00:24:07,690
Windows there's this thing called iocp

00:24:04,780 --> 00:24:10,450
that works very differently I've been

00:24:07,690 --> 00:24:12,550
mentioning that a few times and so the

00:24:10,450 --> 00:24:17,650
importance of that was really rubbed in

00:24:12,550 --> 00:24:20,880
by the meetings with cliff and also the

00:24:17,650 --> 00:24:22,870
importance of having abstractions

00:24:20,880 --> 00:24:25,750
corresponding roughly to what twisted

00:24:22,870 --> 00:24:27,640
calls transports and protocols and I

00:24:25,750 --> 00:24:29,590
figured those were great names why not

00:24:27,640 --> 00:24:31,600
call them transports and protocols

00:24:29,590 --> 00:24:34,870
although they don't have exactly the

00:24:31,600 --> 00:24:36,760
same API as twisted Lawrenceville

00:24:34,870 --> 00:24:39,250
Houghton had also a few years ago

00:24:36,760 --> 00:24:40,990
written something called the async pap

00:24:39,250 --> 00:24:44,050
it's pepped three one five three

00:24:40,990 --> 00:24:46,870
actually this path is three one five six

00:24:44,050 --> 00:24:50,740
because I wanted to sort of honor

00:24:46,870 --> 00:24:54,940
Lawrence's path by having a nearby

00:24:50,740 --> 00:25:03,070
number otherwise I could have being kept

00:24:54,940 --> 00:25:05,260
400 or so so I started iterating and

00:25:03,070 --> 00:25:12,250
then people started contributing and and

00:25:05,260 --> 00:25:14,380
reviewing and I wrote a pap and now it's

00:25:12,250 --> 00:25:16,960
it's perhaps a little confusing what

00:25:14,380 --> 00:25:19,060
what is the what is Pepsi one five six

00:25:16,960 --> 00:25:21,220
and what is chew it because I use the

00:25:19,060 --> 00:25:23,350
codename to live for the the code if I'm

00:25:21,220 --> 00:25:27,370
writing with I'm using Pep three one

00:25:23,350 --> 00:25:30,700
five six six for the interface so the

00:25:27,370 --> 00:25:33,210
PAP is a proposal to adopt a certain

00:25:30,700 --> 00:25:37,180
standard interface for event loops and

00:25:33,210 --> 00:25:38,890
to also have a default implementation of

00:25:37,180 --> 00:25:43,450
that interface in the standard library

00:25:38,890 --> 00:25:46,090
in Python 3.4 julep is my implementation

00:25:43,450 --> 00:25:49,570
of that standard event loop interface

00:25:46,090 --> 00:25:51,520
it's also the prototype where I sort of

00:25:49,570 --> 00:25:54,070
experiment if I think Oh May

00:25:51,520 --> 00:25:55,660
I should change the names of all these

00:25:54,070 --> 00:25:57,820
methods to be a little different or

00:25:55,660 --> 00:26:03,040
maybe the signature are of this group of

00:25:57,820 --> 00:26:05,230
methods needs to be changed I coded up

00:26:03,040 --> 00:26:07,090
into lit first and then if it works I

00:26:05,230 --> 00:26:09,700
update the path to match what I wrote

00:26:07,090 --> 00:26:11,740
there's also stuff in tulip that's not

00:26:09,700 --> 00:26:13,300
meant to be part of the pep not meant to

00:26:11,740 --> 00:26:16,540
be part of the standard library but

00:26:13,300 --> 00:26:19,420
which is application codes where I try

00:26:16,540 --> 00:26:21,850
to sort of use the use all this stuff

00:26:19,420 --> 00:26:24,250
from the perspective of an application

00:26:21,850 --> 00:26:29,230
developer and so I go in sort of

00:26:24,250 --> 00:26:33,070
application user mode using using tulip

00:26:29,230 --> 00:26:36,550
without writing tulip and I try to write

00:26:33,070 --> 00:26:39,190
a I wrote little web crawler I wrote

00:26:36,550 --> 00:26:42,730
little webserver and I sort of try to

00:26:39,190 --> 00:26:44,500
feel is this actually a nice way of

00:26:42,730 --> 00:26:47,110
writing an application and usually I

00:26:44,500 --> 00:26:48,910
come back with oh yeah yeah there's a

00:26:47,110 --> 00:26:51,730
bunch of missing stuff in tulip and in

00:26:48,910 --> 00:26:54,730
the path that I need to add so

00:26:51,730 --> 00:26:58,200
eventually I hope that tulip will be the

00:26:54,730 --> 00:27:00,760
reference implementation and

00:26:58,200 --> 00:27:07,270
incorporated under a better name into

00:27:00,760 --> 00:27:10,600
the standard library it may also forever

00:27:07,270 --> 00:27:12,520
after become a repository for additional

00:27:10,600 --> 00:27:15,190
functionality that doesn't belong in the

00:27:12,520 --> 00:27:16,450
standard library or is sort of where

00:27:15,190 --> 00:27:19,590
there are too many different choices

00:27:16,450 --> 00:27:24,160
where tulips choice is just one of the

00:27:19,590 --> 00:27:26,020
possible choices and in addition tulip

00:27:24,160 --> 00:27:28,900
will be what you can use to use all

00:27:26,020 --> 00:27:31,120
these new asynchronous i/o stuff with by

00:27:28,900 --> 00:27:37,390
50.3 where it's not yet in the standard

00:27:31,120 --> 00:27:41,680
library and of course I'm running out of

00:27:37,390 --> 00:27:45,010
time much sooner than anticipated

00:27:41,680 --> 00:27:48,040
it is my wand so I'll try to speed up so

00:27:45,010 --> 00:27:49,930
the PAP does not just propose an event

00:27:48,040 --> 00:27:53,680
loop even though the event loop is that

00:27:49,930 --> 00:27:56,550
sort of the building block for

00:27:53,680 --> 00:27:56,550
interoperability

00:27:56,950 --> 00:28:02,419
in order to sort of encourage

00:28:00,169 --> 00:28:05,929
interoperability the PEM also has a

00:28:02,419 --> 00:28:07,760
small API to change the event loop

00:28:05,929 --> 00:28:09,470
there's a way where you can say set the

00:28:07,760 --> 00:28:13,870
event loop to this particular object

00:28:09,470 --> 00:28:19,159
that implements the standard API and

00:28:13,870 --> 00:28:21,860
there are a few quirks there so that is

00:28:19,159 --> 00:28:27,980
sort of another framework can plug in

00:28:21,860 --> 00:28:32,090
there their event loop through an

00:28:27,980 --> 00:28:34,279
adapter and all the chulip application

00:28:32,090 --> 00:28:39,679
level code that just uses the standard

00:28:34,279 --> 00:28:43,760
API will still work so now you can have

00:28:39,679 --> 00:28:48,320
chulip code or random user code written

00:28:43,760 --> 00:28:50,360
against a new standard and gee vent code

00:28:48,320 --> 00:28:54,830
that uses the Jeevan paradigm in the

00:28:50,360 --> 00:28:57,169
same application and you could do the

00:28:54,830 --> 00:29:00,110
same thing with julep and twisted or

00:28:57,169 --> 00:29:02,570
julep and tornado and hopefully even

00:29:00,110 --> 00:29:05,360
with multiple of these because

00:29:02,570 --> 00:29:08,390
eventually I hope that the various

00:29:05,360 --> 00:29:11,149
frameworks will also make an effort to

00:29:08,390 --> 00:29:13,700
adapt the standard event loop API to

00:29:11,149 --> 00:29:16,940
dare paired and so that it would be

00:29:13,700 --> 00:29:19,190
great if even 80% of the twisted

00:29:16,940 --> 00:29:21,679
protocol implementations actually worked

00:29:19,190 --> 00:29:23,649
with the standard julep event loop

00:29:21,679 --> 00:29:28,340
rather than with the twisted event loop

00:29:23,649 --> 00:29:31,370
adapted to the standard protocol but

00:29:28,340 --> 00:29:34,010
there's more to the pep and people have

00:29:31,370 --> 00:29:38,270
suggested that I should split it in two

00:29:34,010 --> 00:29:40,610
peps which is still an option on the

00:29:38,270 --> 00:29:44,720
other hand the two the two paired up the

00:29:40,610 --> 00:29:47,210
two things are quite related so let's

00:29:44,720 --> 00:29:52,580
get back you know let's not get back yet

00:29:47,210 --> 00:29:55,429
to the new paradigm for writing

00:29:52,580 --> 00:29:57,350
asynchronous code let's first say a bit

00:29:55,429 --> 00:29:59,000
more about the event loop I think I

00:29:57,350 --> 00:30:01,159
already mentioned a bunch of this so I

00:29:59,000 --> 00:30:05,390
have had some of the people who are

00:30:01,159 --> 00:30:07,870
stakeholders in this world review it I'm

00:30:05,390 --> 00:30:12,010
gonna sprint on it Monday and Tuesday

00:30:07,870 --> 00:30:15,279
and that could include ripping out parts

00:30:12,010 --> 00:30:20,679
of the pep and rewriting them and all

00:30:15,279 --> 00:30:22,299
that nice stuff the event Lopez has sort

00:30:20,679 --> 00:30:23,860
of a bunch of different groups of

00:30:22,299 --> 00:30:25,270
methods and maybe I'll just race through

00:30:23,860 --> 00:30:28,029
this because this is getting pretty

00:30:25,270 --> 00:30:30,549
detailed so there's ways to manage the

00:30:28,029 --> 00:30:34,630
loop basic callbacks callbacks are

00:30:30,549 --> 00:30:37,659
related to i/o there's some stuff

00:30:34,630 --> 00:30:39,460
necessary to interact with feds there's

00:30:37,659 --> 00:30:41,350
even stuff necessary to interact with

00:30:39,460 --> 00:30:43,809
unique signals although clearly when

00:30:41,350 --> 00:30:47,260
you're when signals don't work on your

00:30:43,809 --> 00:30:50,230
OS then they don't work then there are

00:30:47,260 --> 00:30:51,669
some sockets there's some socket stuff

00:30:50,230 --> 00:30:54,840
that's mostly used for trample

00:30:51,669 --> 00:30:57,610
transports and eventual higher net level

00:30:54,840 --> 00:31:01,539
socket operations that I hope will be

00:30:57,610 --> 00:31:03,309
popular among application programmers so

00:31:01,539 --> 00:31:06,399
to start the loop there are way too many

00:31:03,309 --> 00:31:10,539
run functions and to stop it there as a

00:31:06,399 --> 00:31:16,210
stop function will probably refactor

00:31:10,539 --> 00:31:19,929
this API basic callbacks call soon call

00:31:16,210 --> 00:31:22,890
later which is takes it takes a delay

00:31:19,929 --> 00:31:25,570
call repeatedly which sets up a timer

00:31:22,890 --> 00:31:27,429
called call soon theft safe is when

00:31:25,570 --> 00:31:30,190
you're in a different thread and you

00:31:27,429 --> 00:31:32,919
went to add a callback to an event loop

00:31:30,190 --> 00:31:36,220
loop running in another thread that's

00:31:32,919 --> 00:31:39,460
kind of esoteric all these return an

00:31:36,220 --> 00:31:41,230
object which I call a handler which may

00:31:39,460 --> 00:31:45,010
not be the best name but it's also not

00:31:41,230 --> 00:31:46,539
the worst name for a while it was called

00:31:45,010 --> 00:31:47,649
callback but that was too confusing

00:31:46,539 --> 00:31:50,140
there were too many things named

00:31:47,649 --> 00:31:52,330
callback already that handler the main

00:31:50,140 --> 00:31:56,340
purpose of returning a handler is is so

00:31:52,330 --> 00:31:59,559
that we don't have to have explicit

00:31:56,340 --> 00:32:02,260
methods that revoke all these callbacks

00:31:59,559 --> 00:32:04,330
you'll just say cancel cancel on the

00:32:02,260 --> 00:32:06,580
handler and then your callback is no

00:32:04,330 --> 00:32:08,470
longer going to run and so if you call

00:32:06,580 --> 00:32:12,100
canceled after it already ran well

00:32:08,470 --> 00:32:13,659
that's too late unless it was a timer on

00:32:12,100 --> 00:32:16,240
the other hand if you call cancel before

00:32:13,659 --> 00:32:18,520
it actually has gotten a chance to run

00:32:16,240 --> 00:32:21,070
then it will never run

00:32:18,520 --> 00:32:25,510
so there's callbacks for IO and these

00:32:21,070 --> 00:32:29,140
rep the abstractions that take care of

00:32:25,510 --> 00:32:32,170
using select or pull and so on add a

00:32:29,140 --> 00:32:36,040
reader callback at a writer callback or

00:32:32,170 --> 00:32:38,620
remove them exactly what is a file

00:32:36,040 --> 00:32:41,429
descriptor here there's some there's

00:32:38,620 --> 00:32:44,110
some fuzziness then that's intentional

00:32:41,429 --> 00:32:49,200
for example on Windows if you're using

00:32:44,110 --> 00:32:53,679
select it can only be a socket because

00:32:49,200 --> 00:32:57,040
even though both sockets and disk files

00:32:53,679 --> 00:32:58,929
have things called file descriptors in

00:32:57,040 --> 00:33:00,990
this sort of the simulated UNIX

00:32:58,929 --> 00:33:03,550
environment that we use on Windows

00:33:00,990 --> 00:33:08,470
they're actually completely incompatible

00:33:03,550 --> 00:33:10,240
objects and this select the Select call

00:33:08,470 --> 00:33:11,500
only works with sockets so that's a

00:33:10,240 --> 00:33:14,620
Windows restriction though the other

00:33:11,500 --> 00:33:17,440
hands on UNIX you could use a pipe or a

00:33:14,620 --> 00:33:19,360
suit of TTY or a few other things I

00:33:17,440 --> 00:33:22,059
wouldn't recommend using a disk file

00:33:19,360 --> 00:33:27,280
because the typical UNIX kernel says

00:33:22,059 --> 00:33:29,140
that the disk file is always ready but

00:33:27,280 --> 00:33:31,170
sort of that's that's more about the

00:33:29,140 --> 00:33:33,670
semantics of select than anything else

00:33:31,170 --> 00:33:35,620
it could also be an object that has a

00:33:33,670 --> 00:33:37,870
file known method because all the poll

00:33:35,620 --> 00:33:41,530
and select functions support that so

00:33:37,870 --> 00:33:45,340
there's a way to deal with signals not

00:33:41,530 --> 00:33:48,220
recommended there's a way to say well I

00:33:45,340 --> 00:33:50,559
have a function that unfortunately is

00:33:48,220 --> 00:33:52,330
going to make blocking i/o calls and

00:33:50,559 --> 00:33:56,350
have no way to reimplemented

00:33:52,330 --> 00:33:58,120
a good example is get other info in the

00:33:56,350 --> 00:34:01,440
socket module which is the fundamental

00:33:58,120 --> 00:34:04,120
way of making a DNF doing a DNS lookup

00:34:01,440 --> 00:34:05,950
that's called sync that function is

00:34:04,120 --> 00:34:08,740
synchronous and it can certainly block

00:34:05,950 --> 00:34:10,810
for IO because it itself wraps other

00:34:08,740 --> 00:34:13,720
abstractions in the C library that might

00:34:10,810 --> 00:34:15,879
do i/o so there's no way to avoid that

00:34:13,720 --> 00:34:17,470
so you you basically either you can't

00:34:15,879 --> 00:34:19,440
use it or you have to run it in a

00:34:17,470 --> 00:34:21,659
different thread so we chose to actually

00:34:19,440 --> 00:34:25,770
accept that this is a useful function

00:34:21,659 --> 00:34:28,960
that cannot live completely in the nice

00:34:25,770 --> 00:34:31,220
asynchronous il paradigm and so we run

00:34:28,960 --> 00:34:37,210
it in something called an executor

00:34:31,220 --> 00:34:40,849
which is essentially a thread pool and

00:34:37,210 --> 00:34:45,560
it returns a future that you can wait

00:34:40,849 --> 00:34:47,960
for the result then there's a bunch of

00:34:45,560 --> 00:34:50,510
low-level socket IO operations that the

00:34:47,960 --> 00:34:53,000
only transport should use then there are

00:34:50,510 --> 00:34:55,010
high-level network operations like : get

00:34:53,000 --> 00:34:57,079
other info is actually a method on the

00:34:55,010 --> 00:34:59,990
event loop because the event loop

00:34:57,079 --> 00:35:01,369
certified technologist that most likely

00:34:59,990 --> 00:35:04,910
you're going to do lots of socket IO

00:35:01,369 --> 00:35:06,710
with it's looking up host imports

00:35:04,910 --> 00:35:08,359
without actually attempting to connect

00:35:06,710 --> 00:35:10,579
is sometimes a useful thing you could

00:35:08,359 --> 00:35:12,470
also do a reverse lookup and so then

00:35:10,579 --> 00:35:17,150
there's create connection which sets up

00:35:12,470 --> 00:35:19,460
a TCP connection to a remote server and

00:35:17,150 --> 00:35:22,010
there is start surfing which does the

00:35:19,460 --> 00:35:25,250
opposite it says sort of it sets of sets

00:35:22,010 --> 00:35:28,790
you up as a server accepting incoming

00:35:25,250 --> 00:35:29,829
connections I'll get back to that a

00:35:28,790 --> 00:35:32,150
little later

00:35:29,829 --> 00:35:34,339
so these are the things that you would

00:35:32,150 --> 00:35:37,819
use in sort of application code or

00:35:34,339 --> 00:35:42,410
encode that is implementing new internet

00:35:37,819 --> 00:35:43,970
protocols like HTTP or SMTP so you

00:35:42,410 --> 00:35:49,369
noticed ever mentioned futures a few

00:35:43,970 --> 00:35:51,619
times a future is that actually it's a

00:35:49,369 --> 00:35:57,980
pretty generic concept it represents a

00:35:51,619 --> 00:35:59,780
value that hasn't been computed yet but

00:35:57,980 --> 00:36:04,970
if you wait for it you will get the

00:35:59,780 --> 00:36:07,339
value if you do in Python 3 to 2 we

00:36:04,970 --> 00:36:09,829
introduced the standard future class and

00:36:07,339 --> 00:36:14,240
a standard API for futures in the

00:36:09,829 --> 00:36:16,160
standard library 3 1 for 8 this is a

00:36:14,240 --> 00:36:20,869
summary of the API I'm not going to read

00:36:16,160 --> 00:36:22,640
it but we can't really use the exactly

00:36:20,869 --> 00:36:24,550
that future class because that future

00:36:22,640 --> 00:36:28,280
class is designed to work with threads

00:36:24,550 --> 00:36:33,800
so when you call result it just suspends

00:36:28,280 --> 00:36:35,390
the current thread until the value is

00:36:33,800 --> 00:36:41,780
ready and that's exactly the opposite of

00:36:35,390 --> 00:36:44,240
what you want and very second yeah so I

00:36:41,780 --> 00:36:45,020
adapted futures to work with something

00:36:44,240 --> 00:36:47,660
called code

00:36:45,020 --> 00:36:52,030
teens and I'll get back to code teens in

00:36:47,660 --> 00:36:54,620
a minute but first okay what is a future

00:36:52,030 --> 00:36:57,200
okay I'm sorry this looks like a

00:36:54,620 --> 00:36:59,210
duplicate slide I'm not gonna say again

00:36:57,200 --> 00:37:02,750
what the future is basically it has a

00:36:59,210 --> 00:37:04,790
result which blocks or a and then gives

00:37:02,750 --> 00:37:07,550
you the result or give it raises an

00:37:04,790 --> 00:37:11,930
exception so an exception is also

00:37:07,550 --> 00:37:15,440
considered a result so it's not the same

00:37:11,930 --> 00:37:19,910
class but then it doesn't even have

00:37:15,440 --> 00:37:23,680
exactly the same API but it's clear that

00:37:19,910 --> 00:37:27,290
they they sort of are close cousins but

00:37:23,680 --> 00:37:29,450
when DEP 3148 blocks and sort of

00:37:27,290 --> 00:37:33,670
suspends the current OS thread we must

00:37:29,450 --> 00:37:33,670
use drumroll please

00:37:37,829 --> 00:37:47,440
field from thanks to Greg Ewing who

00:37:44,170 --> 00:37:50,470
proposed this first when it was on time

00:37:47,440 --> 00:37:52,510
to incorporate it in Python to seven

00:37:50,470 --> 00:37:56,230
unfortunately we got distracted by an

00:37:52,510 --> 00:37:58,809
extended bike shed and then we got stuck

00:37:56,230 --> 00:38:01,299
in the Python freed up to feature free

00:37:58,809 --> 00:38:05,170
so in Python fleet of three finally

00:38:01,299 --> 00:38:08,829
yield from is part of the language this

00:38:05,170 --> 00:38:12,730
is an incredibly cool but also brain

00:38:08,829 --> 00:38:14,920
exploding thing so unfortunately I mean

00:38:12,730 --> 00:38:16,990
I want to emphasize the importance of it

00:38:14,920 --> 00:38:19,180
but I'm not going to try and teach you

00:38:16,990 --> 00:38:21,369
how it works what you can do with it

00:38:19,180 --> 00:38:23,109
exactly but you could write code like

00:38:21,369 --> 00:38:26,740
this where you say sort of create a

00:38:23,109 --> 00:38:31,900
socket and then yield from this this

00:38:26,740 --> 00:38:33,790
actually uses all those low-level API so

00:38:31,900 --> 00:38:37,109
that I said not to use except when

00:38:33,790 --> 00:38:37,109
you're implementing and transport

00:38:39,839 --> 00:38:44,609
basically the way to think about this is

00:38:47,460 --> 00:38:54,540
yield from is sort of this medic magic

00:38:51,400 --> 00:38:57,190
thing that you put in a code team to

00:38:54,540 --> 00:38:59,170
block without blocking because you're

00:38:57,190 --> 00:39:01,630
coding blocks you co-routine is

00:38:59,170 --> 00:39:04,059
suspended but your thread your event

00:39:01,630 --> 00:39:05,770
loop is not blocked other tasks that are

00:39:04,059 --> 00:39:10,440
managed by the same event of will now

00:39:05,770 --> 00:39:13,119
run and you're suspended co-routine gets

00:39:10,440 --> 00:39:16,660
resumed as soon as whatever thing you

00:39:13,119 --> 00:39:19,119
are waiting for which is usually either

00:39:16,660 --> 00:39:23,369
another future or sorry eat another code

00:39:19,119 --> 00:39:26,260
routine or a future gets is ready and

00:39:23,369 --> 00:39:29,170
most of the time the best way to to

00:39:26,260 --> 00:39:32,670
think about this is actually squinting

00:39:29,170 --> 00:39:36,940
and pretending that it's not even there

00:39:32,670 --> 00:39:38,859
if you're familiar with c-sharp there is

00:39:36,940 --> 00:39:42,819
something called a sink and a weight in

00:39:38,859 --> 00:39:45,130
c-sharp 5.0 and as far as I can tell

00:39:42,819 --> 00:39:48,460
except that they sort of have the

00:39:45,130 --> 00:39:49,900
compiler dive check it it is exactly the

00:39:48,460 --> 00:39:53,170
same concept

00:39:49,900 --> 00:39:55,270
so there there there async is our

00:39:53,170 --> 00:39:57,640
co-routine and there await is our yield

00:39:55,270 --> 00:39:59,530
from and it would have added a weight

00:39:57,640 --> 00:40:03,300
keyword to the language accepted adding

00:39:59,530 --> 00:40:03,300
your keywords is such an incredible pain

00:40:03,570 --> 00:40:11,680
so futures what what's the way to think

00:40:07,840 --> 00:40:15,580
about futures try to forget that there

00:40:11,680 --> 00:40:19,210
there is usually the best approach if

00:40:15,580 --> 00:40:21,100
you see code that says yield from some

00:40:19,210 --> 00:40:24,430
function and that function returns the

00:40:21,100 --> 00:40:26,140
future then sort of the yield from and

00:40:24,430 --> 00:40:29,500
the fact that it's a future cancel each

00:40:26,140 --> 00:40:33,550
other out and the result value that ends

00:40:29,500 --> 00:40:35,980
up in your assignment on left is just

00:40:33,550 --> 00:40:38,740
what you'd expect from just calling the

00:40:35,980 --> 00:40:41,050
equivalent blocking function which just

00:40:38,740 --> 00:40:43,420
gave you the data so if you if you if

00:40:41,050 --> 00:40:46,450
you start with a function say a read

00:40:43,420 --> 00:40:49,450
function read takes an integer count and

00:40:46,450 --> 00:40:52,540
it returns a byte string of up to that

00:40:49,450 --> 00:40:55,030
many bytes and it may block your current

00:40:52,540 --> 00:40:56,710
thread so there is there's an

00:40:55,030 --> 00:41:01,050
asynchronous read somewhere and it

00:40:56,710 --> 00:41:04,900
returns a future and when you yield from

00:41:01,050 --> 00:41:08,620
that read call what comes out of the

00:41:04,900 --> 00:41:09,940
yield from is exactly the byte string

00:41:08,620 --> 00:41:12,160
that you would expect if it was a

00:41:09,940 --> 00:41:15,190
synchronous call that's the best I can

00:41:12,160 --> 00:41:17,390
sort of say it without bursting out in

00:41:15,190 --> 00:41:20,280
tears

00:41:17,390 --> 00:41:22,110
the nice thing is that in this in all

00:41:20,280 --> 00:41:24,000
the cases where the synchronous function

00:41:22,110 --> 00:41:26,220
would raise an exception the yield from

00:41:24,000 --> 00:41:29,760
will also raise the accept exact same

00:41:26,220 --> 00:41:32,910
exception and even cooler part and why I

00:41:29,760 --> 00:41:35,990
am such sort of I am so pushing for

00:41:32,910 --> 00:41:38,730
using yield from rather than yield which

00:41:35,990 --> 00:41:40,500
if you write a different scheduler you

00:41:38,730 --> 00:41:43,020
could just use yield instead of yield

00:41:40,500 --> 00:41:46,050
from the reason I'm pushing yield from

00:41:43,020 --> 00:41:48,390
is that with yield from you change your

00:41:46,050 --> 00:41:50,820
coat your Cheney chain your co-routines

00:41:48,390 --> 00:41:53,010
in such a way that when an exception

00:41:50,820 --> 00:41:55,470
bubbles up through a bunch of co-routine

00:41:53,010 --> 00:41:58,980
calls all linked to a field from you get

00:41:55,470 --> 00:42:01,170
a completely natural trace back when

00:41:58,980 --> 00:42:05,480
that exception finally hits the top

00:42:01,170 --> 00:42:08,730
level well with with the yield approach

00:42:05,480 --> 00:42:10,380
the stack of calls that sort of defer to

00:42:08,730 --> 00:42:12,480
each other is all maintained by the

00:42:10,380 --> 00:42:14,130
scheduler and it's a major pain for the

00:42:12,480 --> 00:42:16,470
scheduler to get the trace backs right

00:42:14,130 --> 00:42:19,530
and usually you see sort of spurious

00:42:16,470 --> 00:42:22,490
frames you get the trace back appears to

00:42:19,530 --> 00:42:25,410
come from a completely unexpected place

00:42:22,490 --> 00:42:27,810
and so the other thing is that the whole

00:42:25,410 --> 00:42:29,910
API of huge should effect that it has a

00:42:27,810 --> 00:42:32,700
result method and an exception method

00:42:29,910 --> 00:42:34,530
and call it even has callbacks you can

00:42:32,700 --> 00:42:36,270
completely forget that because in

00:42:34,530 --> 00:42:38,970
practice you just call existing

00:42:36,270 --> 00:42:40,980
functions that return futures and you

00:42:38,970 --> 00:42:43,380
yield you use yield from to wait for the

00:42:40,980 --> 00:42:47,010
result and that sort of replaces using

00:42:43,380 --> 00:42:50,040
result or exception so as I mentioned

00:42:47,010 --> 00:42:51,390
futures can also raise exceptions and so

00:42:50,040 --> 00:42:54,750
you can catch that exception with a

00:42:51,390 --> 00:42:56,550
standard try accept so in in the

00:42:54,750 --> 00:42:58,860
callback world you've often sometimes

00:42:56,550 --> 00:43:01,080
have systems that design API is where

00:42:58,860 --> 00:43:03,870
there's a callback when things go well

00:43:01,080 --> 00:43:07,380
and then her back when things don't go

00:43:03,870 --> 00:43:10,080
well and various ways to sort of channel

00:43:07,380 --> 00:43:13,530
those callbacks and urbex two together

00:43:10,080 --> 00:43:16,230
and splice them apart you can write

00:43:13,530 --> 00:43:18,120
wonderful convoluted logic with that and

00:43:16,230 --> 00:43:18,900
you can solve all the use cases that you

00:43:18,120 --> 00:43:21,810
run into

00:43:18,900 --> 00:43:25,200
but with try except you can use the

00:43:21,810 --> 00:43:28,050
existing system this existing syntax and

00:43:25,200 --> 00:43:30,180
mechanisms built into the language for

00:43:28,050 --> 00:43:31,320
sort of controlling which exceptions you

00:43:30,180 --> 00:43:34,200
handle

00:43:31,320 --> 00:43:35,580
and it's sort of all uses stuff that you

00:43:34,200 --> 00:43:42,980
already know because you already know

00:43:35,580 --> 00:43:42,980
try try except OS error so co-routines

00:43:43,820 --> 00:43:50,130
co-routine really is just the generator

00:43:45,960 --> 00:43:53,160
yield from translates to a complicated

00:43:50,130 --> 00:43:55,620
piece of code that involves a yield so

00:43:53,160 --> 00:43:58,830
it must be inside a generator we have

00:43:55,620 --> 00:44:01,320
this aapko routine decorator but

00:43:58,830 --> 00:44:03,330
actually in chulip currently fqo routine

00:44:01,320 --> 00:44:05,310
is an empty decorator it doesn't do

00:44:03,330 --> 00:44:07,620
anything to the decorated function at

00:44:05,310 --> 00:44:12,750
all we're probably going to introduce a

00:44:07,620 --> 00:44:14,370
debug co-routine decorator that checks

00:44:12,750 --> 00:44:16,380
that you're actually using the futures

00:44:14,370 --> 00:44:18,150
correctly and if you're not accidentally

00:44:16,380 --> 00:44:20,460
using yield where you should be using

00:44:18,150 --> 00:44:23,370
yield from but sort of in normal

00:44:20,460 --> 00:44:25,350
operation that's actually the code

00:44:23,370 --> 00:44:27,810
routine decorator is purely there so

00:44:25,350 --> 00:44:29,790
that the human reader of the code gets

00:44:27,810 --> 00:44:31,830
warned this code is going to use the

00:44:29,790 --> 00:44:34,410
asynchronous paradigm and when you see

00:44:31,830 --> 00:44:36,540
yield from it means blocking for

00:44:34,410 --> 00:44:41,910
something else that returns a future or

00:44:36,540 --> 00:44:44,070
a KO routine now a code teen is not

00:44:41,910 --> 00:44:46,260
really a sinkers code by itself

00:44:44,070 --> 00:44:50,190
Colten is just some code that only runs

00:44:46,260 --> 00:44:52,200
when you apply yield from to it so

00:44:50,190 --> 00:44:56,630
co-routines by themselves don't give you

00:44:52,200 --> 00:45:00,660
concurrency or parallelism and in fact a

00:44:56,630 --> 00:45:02,430
KO routine that you that you start but

00:45:00,660 --> 00:45:03,810
then you don't use yield from on it it

00:45:02,430 --> 00:45:06,570
just sits there it doesn't make any

00:45:03,810 --> 00:45:08,850
progress it's it's not not going even

00:45:06,570 --> 00:45:11,340
going to initiate the IO that it might

00:45:08,850 --> 00:45:13,110
be waiting for so you really have to

00:45:11,340 --> 00:45:16,070
assert if you can use these code teens

00:45:13,110 --> 00:45:20,370
to break up your program into various

00:45:16,070 --> 00:45:22,620
abstract components it's a very nice way

00:45:20,370 --> 00:45:25,050
of refactoring a large hairy piece of

00:45:22,620 --> 00:45:27,000
logic into various sub subroutines

00:45:25,050 --> 00:45:30,570
because you just linked them all

00:45:27,000 --> 00:45:31,170
together with those with yield from and

00:45:30,570 --> 00:45:33,720
co-routines

00:45:31,170 --> 00:45:35,160
but if you want autonomous task is you

00:45:33,720 --> 00:45:38,119
actually want things to happen in

00:45:35,160 --> 00:45:40,819
parallel you use a task

00:45:38,119 --> 00:45:43,999
a task is actually a co lutein wrapped

00:45:40,819 --> 00:45:45,799
inside the future the task as soon as

00:45:43,999 --> 00:45:48,200
you start the task the co routine

00:45:45,799 --> 00:45:50,029
actually starts running and it keeps

00:45:48,200 --> 00:45:55,099
running until it hits a point where it

00:45:50,029 --> 00:45:56,960
actually needs to block for IO they're

00:45:55,099 --> 00:46:00,170
actually two ways to create tasks you

00:45:56,960 --> 00:46:01,670
can just use the task decorator instead

00:46:00,170 --> 00:46:03,109
of the co routine decorator then

00:46:01,670 --> 00:46:05,450
whenever you call that function it

00:46:03,109 --> 00:46:07,400
automatically creates a task the nice

00:46:05,450 --> 00:46:09,319
thing is that that task you can still

00:46:07,400 --> 00:46:11,140
use yield from to wait for it

00:46:09,319 --> 00:46:14,029
immediately because it's also a future

00:46:11,140 --> 00:46:16,190
you can also take an existing co-routine

00:46:14,029 --> 00:46:18,319
that wasn't itself meant to be parallel

00:46:16,190 --> 00:46:20,930
and say I want this particular operation

00:46:18,319 --> 00:46:23,509
to run in a separate as a separate task

00:46:20,930 --> 00:46:25,789
you can still of course later come back

00:46:23,509 --> 00:46:27,589
and ask for its result but one one thing

00:46:25,789 --> 00:46:30,349
you do suppose you have ten URLs that

00:46:27,589 --> 00:46:32,960
you need to fetch you create ten tasks

00:46:30,349 --> 00:46:34,880
for them each fetching one of them and

00:46:32,960 --> 00:46:37,309
then at the end you just yield use yield

00:46:34,880 --> 00:46:39,589
from to wait for all of them until you

00:46:37,309 --> 00:46:41,150
have all the data now the nice thing is

00:46:39,589 --> 00:46:44,269
that the function that actually fetches

00:46:41,150 --> 00:46:46,460
one URL doesn't have to be a task itself

00:46:44,269 --> 00:46:48,440
it can just be a Co routine because you

00:46:46,460 --> 00:46:52,849
can use the explicit wrapping of attica

00:46:48,440 --> 00:46:55,009
routine inside a task so this all works

00:46:52,849 --> 00:46:56,450
because a task is a subclass of a future

00:46:55,009 --> 00:46:58,130
but who knows about keeping the core

00:46:56,450 --> 00:47:04,970
routine alive and talking to the event

00:46:58,130 --> 00:47:06,170
loop so while I'm in over time I have a

00:47:04,970 --> 00:47:11,930
little bit to say about those

00:47:06,170 --> 00:47:14,390
higher-level Network operations you can

00:47:11,930 --> 00:47:16,700
use this to create a TCP connection and

00:47:14,390 --> 00:47:17,809
it returns a future that only returns

00:47:16,700 --> 00:47:20,210
when the connection is actually

00:47:17,809 --> 00:47:22,130
succeeded and what did what you get at

00:47:20,210 --> 00:47:24,859
that point is a transport in a protocol

00:47:22,130 --> 00:47:27,739
and the protocol is whatever this

00:47:24,859 --> 00:47:31,849
factory function returns because it's

00:47:27,739 --> 00:47:34,789
really a protocol Factory and so this is

00:47:31,849 --> 00:47:36,170
where I had this is the last point in

00:47:34,789 --> 00:47:38,259
the talk where I really have to admit

00:47:36,170 --> 00:47:43,390
yes I have been brainwashed by a glyph

00:47:38,259 --> 00:47:43,390
and bless his soul

00:47:44,700 --> 00:47:49,660
there was actually so there was this

00:47:46,780 --> 00:47:52,360
async pep that also explained why that

00:47:49,660 --> 00:47:54,670
was but they had never really gotten it

00:47:52,360 --> 00:47:56,530
until I got glyph to explain it to me

00:47:54,670 --> 00:47:59,740
personally so this might this might

00:47:56,530 --> 00:48:03,940
explain why not everybody likes twist it

00:47:59,740 --> 00:48:06,400
because you sort of you have to to have

00:48:03,940 --> 00:48:12,160
it explained to you by the master before

00:48:06,400 --> 00:48:14,530
you really get it I'm gonna skip all

00:48:12,160 --> 00:48:18,550
this you can read up on transports and

00:48:14,530 --> 00:48:21,940
protocols in the peps now there's one

00:48:18,550 --> 00:48:24,790
more thing below the event loop there is

00:48:21,940 --> 00:48:26,530
this thing that interfaces with select

00:48:24,790 --> 00:48:28,600
and pull and sort of abstracts away the

00:48:26,530 --> 00:48:32,020
differences between Paul and eat Paul

00:48:28,600 --> 00:48:35,350
and KQ there's a very sad story where

00:48:32,020 --> 00:48:38,619
select and I Paul take a timeout in

00:48:35,350 --> 00:48:43,000
seconds and Paul takes a timeout in

00:48:38,619 --> 00:48:48,609
milliseconds endless number of program

00:48:43,000 --> 00:48:51,550
bugs have been caused by that someone

00:48:48,609 --> 00:48:53,619
actually contributed a bunch of nice

00:48:51,550 --> 00:48:56,830
classes that abstract all that way for

00:48:53,619 --> 00:48:58,450
inclusion in the standard library and in

00:48:56,830 --> 00:49:02,320
order to test whether they were any good

00:48:58,450 --> 00:49:04,119
I copied his code into truly been

00:49:02,320 --> 00:49:06,100
started using that instead of my own

00:49:04,119 --> 00:49:10,090
feeble attempt at the same abstractions

00:49:06,100 --> 00:49:11,830
and so far they work very well but this

00:49:10,090 --> 00:49:13,570
will be pushed back into the standard

00:49:11,830 --> 00:49:15,730
library without being part of the path

00:49:13,570 --> 00:49:17,920
there's also something called the pro

00:49:15,730 --> 00:49:20,640
actor which works with iocp which does

00:49:17,920 --> 00:49:24,490
not implement the same interface because

00:49:20,640 --> 00:49:26,200
iocp fundamentally has done callback

00:49:24,490 --> 00:49:31,090
semantics instead of ready callback

00:49:26,200 --> 00:49:34,180
semantics so there's a lot more but as I

00:49:31,090 --> 00:49:38,920
said I'm out of time so about that

00:49:34,180 --> 00:49:42,040
miracle okay well there's more stuff

00:49:38,920 --> 00:49:44,770
there is a file object or stream object

00:49:42,040 --> 00:49:46,570
that has methods like read line that

00:49:44,770 --> 00:49:48,880
return futures

00:49:46,570 --> 00:49:50,800
there's work on the Datagram protocol

00:49:48,880 --> 00:49:53,750
there are actually some locks although

00:49:50,800 --> 00:49:56,990
there probably won't be used much

00:49:53,750 --> 00:50:00,410
there's a guy in Russia who's writing

00:49:56,990 --> 00:50:04,670
HTTP client and server implementation

00:50:00,410 --> 00:50:09,309
and has been contributing a lot to tulip

00:50:04,670 --> 00:50:12,380
actually there's also thought of maybe

00:50:09,309 --> 00:50:16,869
modeling the whole API after requests

00:50:12,380 --> 00:50:16,869
HTTP for humans I think as its called

00:50:19,569 --> 00:50:27,799
man I'm glad wedge that into the slide

00:50:23,980 --> 00:50:31,880
and we're also working on handling sub

00:50:27,799 --> 00:50:33,799
processes so the interrupt because the

00:50:31,880 --> 00:50:35,539
interrupt story is really the most

00:50:33,799 --> 00:50:37,579
important part I mean there are lots of

00:50:35,539 --> 00:50:39,349
cool features that julep will have and

00:50:37,579 --> 00:50:41,750
that pip three one five six will push

00:50:39,349 --> 00:50:44,720
into the standard library but if the

00:50:41,750 --> 00:50:46,670
interrupt story fails I still consider

00:50:44,720 --> 00:50:50,680
it a failure because then really it is

00:50:46,670 --> 00:50:55,339
just an example of that xkcd cartoon so

00:50:50,680 --> 00:50:58,569
what I'm hoping is that over time and it

00:50:55,339 --> 00:51:04,339
may take a few Python three releases

00:50:58,569 --> 00:51:08,750
various frameworks will throw away their

00:51:04,339 --> 00:51:13,190
own event loop and start using the

00:51:08,750 --> 00:51:15,140
default standard event loop API and they

00:51:13,190 --> 00:51:17,569
can do that in stages they can sort of

00:51:15,140 --> 00:51:21,049
start by writing an adapter for their

00:51:17,569 --> 00:51:23,150
their own existing event loop and use

00:51:21,049 --> 00:51:25,430
that inside their own code but sort of

00:51:23,150 --> 00:51:29,059
use it to be able to cooperate with

00:51:25,430 --> 00:51:31,490
chulip standard code but eventually if

00:51:29,059 --> 00:51:33,799
the event is the standard event loop is

00:51:31,490 --> 00:51:35,240
similar enough to their own event loop

00:51:33,799 --> 00:51:37,309
there's no reason for them to keep

00:51:35,240 --> 00:51:39,109
maintaining their own event loop so

00:51:37,309 --> 00:51:41,059
expect that the only twist that will end

00:51:39,109 --> 00:51:43,700
up still having its own reactors because

00:51:41,059 --> 00:51:47,750
their reactors are sort of special there

00:51:43,700 --> 00:51:50,240
they do other stuff sometimes but most

00:51:47,750 --> 00:51:54,250
of twisted I hope will actually also

00:51:50,240 --> 00:51:57,770
work with with the standard event loop

00:51:54,250 --> 00:52:00,289
so just this this sort of I really hope

00:51:57,770 --> 00:52:02,450
that this will help us move to a world

00:52:00,289 --> 00:52:03,220
where we can actually all get long and

00:52:02,450 --> 00:52:06,010
you can

00:52:03,220 --> 00:52:08,319
have interoperability between G's and

00:52:06,010 --> 00:52:11,079
and twisted and sort of if as an

00:52:08,319 --> 00:52:13,150
application developer you find a really

00:52:11,079 --> 00:52:14,619
cool piece of code that uses twisted

00:52:13,150 --> 00:52:17,230
then you want to import that and you

00:52:14,619 --> 00:52:19,510
have a really cool piece of G's and code

00:52:17,230 --> 00:52:21,400
that you want to import as well and they

00:52:19,510 --> 00:52:23,440
they solve different problems in your

00:52:21,400 --> 00:52:26,920
large application that you can actually

00:52:23,440 --> 00:52:29,800
do that without having to mess with

00:52:26,920 --> 00:52:37,150
multiple processes or rewrite it all or

00:52:29,800 --> 00:52:39,400
just forget it if you are writing an

00:52:37,150 --> 00:52:41,770
event loop and you don't like the the

00:52:39,400 --> 00:52:45,310
yield from paradigm you can use these

00:52:41,770 --> 00:52:48,730
futures completely without ever creating

00:52:45,310 --> 00:52:51,250
a KO routine or using yield from you can

00:52:48,730 --> 00:52:54,520
just use add done call back and set

00:52:51,250 --> 00:52:56,290
result and you will be called that your

00:52:54,520 --> 00:53:00,160
callback will be called when the future

00:52:56,290 --> 00:53:02,109
is ready and you can use result an

00:53:00,160 --> 00:53:04,780
exception to find out what the result

00:53:02,109 --> 00:53:07,290
was and so this is I how I expected at

00:53:04,780 --> 00:53:10,780
least twisted will adapt the event loop

00:53:07,290 --> 00:53:13,089
so when can you have it well you could

00:53:10,780 --> 00:53:15,069
check out the code repo today but they

00:53:13,089 --> 00:53:17,849
don't really recommend that except if

00:53:15,069 --> 00:53:21,010
you want to help contribute or test it

00:53:17,849 --> 00:53:23,619
it's very much in flux it's very much

00:53:21,010 --> 00:53:25,390
undocumented there are some dog strings

00:53:23,619 --> 00:53:28,720
obviously there's the PAP the pep

00:53:25,390 --> 00:53:32,589
doesn't always match the code the PAP

00:53:28,720 --> 00:53:35,319
has not been sufficiently reviewed that

00:53:32,589 --> 00:53:37,150
will take some time I hope to get

00:53:35,319 --> 00:53:41,069
several more rounds of feedback from

00:53:37,150 --> 00:53:44,410
various stakeholders and potential users

00:53:41,069 --> 00:53:47,260
I've given myself time until November

00:53:44,410 --> 00:53:49,390
23rd which according to the Python 3.4

00:53:47,260 --> 00:53:54,849
release schedule is the cutoff date for

00:53:49,390 --> 00:53:55,750
beta 1 by that time you should also be

00:53:54,849 --> 00:53:58,690
able to download

00:53:55,750 --> 00:54:00,609
xiulet from PI pi as a third party

00:53:58,690 --> 00:54:03,250
package that works with vanilla Python

00:54:00,609 --> 00:54:07,270
free and we'll keep that around for a

00:54:03,250 --> 00:54:09,099
couple releases so that if you just like

00:54:07,270 --> 00:54:10,690
tulip and you don't care about the

00:54:09,099 --> 00:54:12,579
version in the standard library you can

00:54:10,690 --> 00:54:16,500
use that and we don't have a name for it

00:54:12,579 --> 00:54:18,240
yet so suggestions so what to do about

00:54:16,500 --> 00:54:22,250
rest of the standard library there is

00:54:18,240 --> 00:54:25,080
all these old interfaces URL HTTP live

00:54:22,250 --> 00:54:26,970
socket server I don't know what to do

00:54:25,080 --> 00:54:29,580
about those yet and I don't want to sort

00:54:26,970 --> 00:54:31,680
of make that fixing that to prerequisite

00:54:29,580 --> 00:54:33,840
so we're gonna think about that

00:54:31,680 --> 00:54:35,720
after all this stuff is in the standard

00:54:33,840 --> 00:54:39,450
library so for a while that will be did

00:54:35,720 --> 00:54:42,210
the classics legacy synchronous api's

00:54:39,450 --> 00:54:44,340
and the new asynchronous API is and will

00:54:42,210 --> 00:54:47,220
will have some way of merging them

00:54:44,340 --> 00:54:48,410
together eventually and that will take

00:54:47,220 --> 00:54:54,450
years

00:54:48,410 --> 00:54:56,430
I'm very similar so if you want to use

00:54:54,450 --> 00:54:59,840
an older version you're pretty much out

00:54:56,430 --> 00:55:04,730
of luck you could think about

00:54:59,840 --> 00:55:07,700
implementing the standard API again and

00:55:04,730 --> 00:55:11,430
making it available as a third-party

00:55:07,700 --> 00:55:14,070
module but I'm not going to sort of dumb

00:55:11,430 --> 00:55:16,080
down the tulip implementation to also

00:55:14,070 --> 00:55:18,990
support older versions of Python because

00:55:16,080 --> 00:55:21,090
I really want to write Python 3.3 code

00:55:18,990 --> 00:55:23,190
which is so incredibly crisp and clean

00:55:21,090 --> 00:55:24,870
and there's so many silly things in

00:55:23,190 --> 00:55:28,800
older versions of the language that I'm

00:55:24,870 --> 00:55:31,590
so glad to be getting rid of so consider

00:55:28,800 --> 00:55:36,210
is a carrot to start transit

00:55:31,590 --> 00:55:40,920
transitioning to Python 3 3 and lots of

00:55:36,210 --> 00:55:43,530
acknowledgments Greg Ewing of course but

00:55:40,920 --> 00:55:46,470
I'll just let you read this and so I'm

00:55:43,530 --> 00:55:49,230
sprinting tomorrow and Tuesday so if

00:55:46,470 --> 00:55:52,070
anyone wants help just drop in email

00:55:49,230 --> 00:55:52,070
Guido at python.org

00:56:04,280 --> 00:56:07,580
thank you very much Guido always

00:56:06,050 --> 00:56:09,940
illuminating to hear what you have to

00:56:07,580 --> 00:56:09,940

YouTube URL: https://www.youtube.com/watch?v=sOQLVm0-8Yg


