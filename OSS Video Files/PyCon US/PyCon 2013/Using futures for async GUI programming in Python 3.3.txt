Title: Using futures for async GUI programming in Python 3.3
Publication date: 2013-03-25
Playlist: PyCon 2013
Description: 
	Dino Viehland
In Python 3.2 a new feature was added for concurrent programming - futures. In Python 3.3 generators have been extended to allow returning from a generator with a value. In this talk we'll show how these features can be combined to crea
Captions: 
	00:00:05,960 --> 00:00:12,660
so thank you for coming out everyone

00:00:09,469 --> 00:00:16,379
so this talk will be about using futures

00:00:12,660 --> 00:00:17,490
for developing Python programming and in

00:00:16,379 --> 00:00:20,130
particular we're going to be talking

00:00:17,490 --> 00:00:22,410
about is there's this new pep out by

00:00:20,130 --> 00:00:26,369
Guido that's all about doing async

00:00:22,410 --> 00:00:28,650
development and it's kind of interesting

00:00:26,369 --> 00:00:30,990
before Guido started talking about this

00:00:28,650 --> 00:00:34,020
on Python ideas we were actually looking

00:00:30,990 --> 00:00:35,670
into doing async development for GUI

00:00:34,020 --> 00:00:37,920
programming which is completely

00:00:35,670 --> 00:00:40,670
different from what the pep is really

00:00:37,920 --> 00:00:43,290
about the pep is kind of all about doing

00:00:40,670 --> 00:00:45,840
async programming for doing low-level

00:00:43,290 --> 00:00:49,110
networking IO and getting high

00:00:45,840 --> 00:00:51,120
performance there so my team I work at

00:00:49,110 --> 00:00:52,649
Microsoft and we kind of whenever

00:00:51,120 --> 00:00:54,539
there's some cool new technology that

00:00:52,649 --> 00:00:58,020
Microsoft is doing we kind of like to

00:00:54,539 --> 00:01:01,170
come at it and see what we can do with

00:00:58,020 --> 00:01:02,910
that technology and with Python and so

00:01:01,170 --> 00:01:04,739
when the big new things that has come

00:01:02,910 --> 00:01:08,400
out recently is of course Windows 8 and

00:01:04,739 --> 00:01:10,830
Windows 8 has an entire brand-new GUI

00:01:08,400 --> 00:01:12,479
programming framework and a huge amount

00:01:10,830 --> 00:01:15,030
of that framework is actually all built

00:01:12,479 --> 00:01:17,369
around async interactions and that's so

00:01:15,030 --> 00:01:19,500
that the GUI never blocks it always

00:01:17,369 --> 00:01:21,630
remains responsive and the users never

00:01:19,500 --> 00:01:23,759
really feeling that frustrated feeling

00:01:21,630 --> 00:01:26,189
when their program kind of locks up and

00:01:23,759 --> 00:01:28,670
becomes non-responsive and so we were

00:01:26,189 --> 00:01:31,619
curious how would we do this with Python

00:01:28,670 --> 00:01:34,619
one of our goals was to not change

00:01:31,619 --> 00:01:37,049
anything about Python itself we wanted

00:01:34,619 --> 00:01:38,729
to work on an existing version of Python

00:01:37,049 --> 00:01:41,310
we didn't want to have to drive new

00:01:38,729 --> 00:01:43,200
language features into Python in order

00:01:41,310 --> 00:01:46,110
make that happen and so we were really

00:01:43,200 --> 00:01:48,090
kind of thrilled that with the new

00:01:46,110 --> 00:01:50,520
features that already arrived in Python

00:01:48,090 --> 00:01:53,009
3.3 that we were able to accomplish that

00:01:50,520 --> 00:01:55,530
and Guido came at it from a completely

00:01:53,009 --> 00:01:58,740
separate direction and it's kind of

00:01:55,530 --> 00:02:00,990
eerie how similar the two solutions are

00:01:58,740 --> 00:02:01,740
so I'll talk a little bit about the

00:02:00,990 --> 00:02:04,320
differences

00:02:01,740 --> 00:02:07,140
Guido's implementation is called tulip

00:02:04,320 --> 00:02:09,270
and our implementation is called waddle

00:02:07,140 --> 00:02:12,170
and it was mostly written by my coworker

00:02:09,270 --> 00:02:15,770
Steve who is here and had a

00:02:12,170 --> 00:02:19,060
small talk earlier and did a lot of

00:02:15,770 --> 00:02:21,530
debating on Python ideas with Guido and

00:02:19,060 --> 00:02:23,300
we kind of flushed out the idea from our

00:02:21,530 --> 00:02:26,240
side and it's it's great that it all

00:02:23,300 --> 00:02:28,160
worked out that this one new feature

00:02:26,240 --> 00:02:31,580
that will hopefully end up in Python 3.4

00:02:28,160 --> 00:02:33,770
will work I believe not only for Network

00:02:31,580 --> 00:02:39,470
applications but also for GUI

00:02:33,770 --> 00:02:41,120
applications so you know why async this

00:02:39,470 --> 00:02:43,100
might be obvious to some people

00:02:41,120 --> 00:02:47,150
first off everyone's doing it it seems

00:02:43,100 --> 00:02:49,490
to be the new rage of course C++ has

00:02:47,150 --> 00:02:52,400
this stood promise which is basically a

00:02:49,490 --> 00:02:55,220
future by another name javascript has

00:02:52,400 --> 00:02:57,410
always been very async by nature and web

00:02:55,220 --> 00:02:58,700
frameworks you in web programming you

00:02:57,410 --> 00:03:00,860
have lots of callbacks because

00:02:58,700 --> 00:03:02,780
javascript is single threaded and you're

00:03:00,860 --> 00:03:04,459
going off and doing web requests and you

00:03:02,780 --> 00:03:07,850
don't want those to block the UI and

00:03:04,459 --> 00:03:10,070
that kind of works great you have all

00:03:07,850 --> 00:03:12,440
these inline anonymous functions that

00:03:10,070 --> 00:03:14,270
you use for the callbacks and some

00:03:12,440 --> 00:03:17,660
people like that style some people hate

00:03:14,270 --> 00:03:19,430
that style with c-sharp which is a

00:03:17,660 --> 00:03:22,730
language I spend a lot of time in

00:03:19,430 --> 00:03:25,489
there's this new async feature in dotnet

00:03:22,730 --> 00:03:28,730
4/5 which is very similar to what I'll

00:03:25,489 --> 00:03:30,560
show you today and I think it offers the

00:03:28,730 --> 00:03:34,250
best programming model for doing async

00:03:30,560 --> 00:03:35,630
development users hate blocking I kind

00:03:34,250 --> 00:03:37,459
of mentioned that a little bit before

00:03:35,630 --> 00:03:39,050
you know it's very frustrating when your

00:03:37,459 --> 00:03:42,560
apps not responding you don't know

00:03:39,050 --> 00:03:44,420
what's going on it's not updating and

00:03:42,560 --> 00:03:48,140
you just want to get your work done and

00:03:44,420 --> 00:03:50,690
it's in the way but async programming is

00:03:48,140 --> 00:03:53,000
also kind of difficult you know if

00:03:50,690 --> 00:03:55,040
you're you have your GUI app it has its

00:03:53,000 --> 00:03:57,080
single thread which is processing all

00:03:55,040 --> 00:03:58,880
the messages which is typical for just

00:03:57,080 --> 00:04:01,550
about every single GUI framework that's

00:03:58,880 --> 00:04:03,380
out there and if you go and do something

00:04:01,550 --> 00:04:05,239
that's going to take a long time it's

00:04:03,380 --> 00:04:07,370
going to block the GUI thread and the

00:04:05,239 --> 00:04:09,769
apps going to become non-responsive and

00:04:07,370 --> 00:04:11,570
the way you work around that is you take

00:04:09,769 --> 00:04:14,000
code and you run it on another thread

00:04:11,570 --> 00:04:15,590
and you have some signal that you post

00:04:14,000 --> 00:04:19,729
back to your event loop when it

00:04:15,590 --> 00:04:21,799
completes and then you need to bounce

00:04:19,729 --> 00:04:23,180
back to the UI thread to update it and

00:04:21,799 --> 00:04:25,010
keep bouncing back and forth between

00:04:23,180 --> 00:04:25,700
these threads if you have one

00:04:25,010 --> 00:04:27,980
long-running

00:04:25,700 --> 00:04:30,620
that's kind of okay it's not

00:04:27,980 --> 00:04:32,960
particularly terrible but if you're kind

00:04:30,620 --> 00:04:34,670
of have a series of cascading

00:04:32,960 --> 00:04:37,310
long-running operations where you're

00:04:34,670 --> 00:04:39,680
going to a website getting some data and

00:04:37,310 --> 00:04:41,300
then updating the UI a little bit and

00:04:39,680 --> 00:04:43,730
then doing something with that data

00:04:41,300 --> 00:04:47,360
going off to a website again it really

00:04:43,730 --> 00:04:49,520
starts to get pretty painful on the

00:04:47,360 --> 00:04:51,050
networking side of things a sync is

00:04:49,520 --> 00:04:53,870
great because it helps people create

00:04:51,050 --> 00:04:56,060
highly scalable applications and that's

00:04:53,870 --> 00:04:58,430
kind of the angle that Guido has been

00:04:56,060 --> 00:05:01,420
coming at it and so twisted developers

00:04:58,430 --> 00:05:05,240
should be pretty happy with the new pep

00:05:01,420 --> 00:05:06,680
it you see it a lot in nodejs where you

00:05:05,240 --> 00:05:08,870
have JavaScript running on the server

00:05:06,680 --> 00:05:14,030
again using callbacks that some people

00:05:08,870 --> 00:05:15,560
love and hate and so it's it's good for

00:05:14,030 --> 00:05:18,980
that too but I won't really talk about

00:05:15,560 --> 00:05:20,900
that anymore at all so I think the best

00:05:18,980 --> 00:05:23,870
way to start this off is trying to give

00:05:20,900 --> 00:05:26,180
a quick demo of what the usual

00:05:23,870 --> 00:05:27,410
experience looks like today and what it

00:05:26,180 --> 00:05:30,470
will look like in the future

00:05:27,410 --> 00:05:31,880
so I mentioned 1/8 at the beginning and

00:05:30,470 --> 00:05:34,310
I don't have anything more to say about

00:05:31,880 --> 00:05:37,340
1/8 and so today my demo is going to

00:05:34,310 --> 00:05:39,190
actually be using TK it's the one GUI

00:05:37,340 --> 00:05:41,180
framework that ships with Python so

00:05:39,190 --> 00:05:42,650
anyone should be able to pick up this

00:05:41,180 --> 00:05:44,630
code I'll have a link to it at the end

00:05:42,650 --> 00:05:46,430
for the sample code but what I'm going

00:05:44,630 --> 00:05:48,530
to show you will actually work with just

00:05:46,430 --> 00:05:51,230
about any single GUI framework that

00:05:48,530 --> 00:05:53,240
you're using whether it's WX pie side or

00:05:51,230 --> 00:05:55,610
whatever and I'll actually kind of have

00:05:53,240 --> 00:05:57,380
little pieces of information sprinkled

00:05:55,610 --> 00:05:58,640
through and if you'd like to go off and

00:05:57,380 --> 00:06:02,530
try to make this with your GUI framework

00:05:58,640 --> 00:06:02,530
I don't think it'll be too difficult so

00:06:03,460 --> 00:06:09,680
this is my app it's running on Python

00:06:05,930 --> 00:06:11,870
3.3 so the tool up implementation will

00:06:09,680 --> 00:06:14,270
land in 3/4 but there's no new language

00:06:11,870 --> 00:06:17,600
features that are needed to make it work

00:06:14,270 --> 00:06:20,390
all my app does here is it has some code

00:06:17,600 --> 00:06:23,210
that's going to read in a very large

00:06:20,390 --> 00:06:25,340
text file it's going to run through that

00:06:23,210 --> 00:06:27,440
text file and sort out the things that

00:06:25,340 --> 00:06:29,660
are just plain words it's going to

00:06:27,440 --> 00:06:31,070
account all of the words and then it's

00:06:29,660 --> 00:06:33,250
going to sort all of the words to get

00:06:31,070 --> 00:06:36,620
the top 10 words there in the text file

00:06:33,250 --> 00:06:39,140
not a very complex thing but it's four

00:06:36,620 --> 00:06:39,729
distinct stages where we need to do some

00:06:39,140 --> 00:06:41,559
work

00:06:39,729 --> 00:06:45,759
and wait for the result and then

00:06:41,559 --> 00:06:48,279
continue on so if I click on if I look

00:06:45,759 --> 00:06:49,569
here first off you can see I've got the

00:06:48,279 --> 00:06:51,759
console running I'm printing out some

00:06:49,569 --> 00:06:53,110
information as this goes along you can

00:06:51,759 --> 00:06:55,689
kind of see this in the background as it

00:06:53,110 --> 00:06:57,909
runs I'm printing out the thread IDs and

00:06:55,689 --> 00:06:59,889
they'll you'll see why that's kind of

00:06:57,909 --> 00:07:00,999
interesting a little bit but as I run

00:06:59,889 --> 00:07:03,129
this you'll see that I'm going to be

00:07:00,999 --> 00:07:05,589
staying on the entire thread so I click

00:07:03,129 --> 00:07:08,710
on count words and you can see my codes

00:07:05,589 --> 00:07:11,110
running but you know obviously my window

00:07:08,710 --> 00:07:13,059
is not doing anything and now it's

00:07:11,110 --> 00:07:16,719
ghosted and I've got the not responding

00:07:13,059 --> 00:07:19,240
here and as a user I'm rather frustrated

00:07:16,719 --> 00:07:20,979
it eventually completes and my UI

00:07:19,240 --> 00:07:22,990
updates with kind of everything that

00:07:20,979 --> 00:07:25,089
happened along the way we were actually

00:07:22,990 --> 00:07:27,039
trying to update along the UI along the

00:07:25,089 --> 00:07:29,469
way we're sending all of the updates to

00:07:27,039 --> 00:07:32,529
the UI but none of them showed until the

00:07:29,469 --> 00:07:35,439
code completed and the event loop got a

00:07:32,529 --> 00:07:39,460
run again so that is just not a very

00:07:35,439 --> 00:07:43,810
good experience at all so the way I

00:07:39,460 --> 00:07:45,490
might solve this usually is with this

00:07:43,810 --> 00:07:47,740
function here and this could potentially

00:07:45,490 --> 00:07:49,689
be one of the worse ways to go about

00:07:47,740 --> 00:07:51,129
solving it you could probably write some

00:07:49,689 --> 00:07:53,469
helper functions that might make it a

00:07:51,129 --> 00:07:55,360
little bit easier but what I'm going to

00:07:53,469 --> 00:07:57,759
do is I'm going to spin up a thread pool

00:07:55,360 --> 00:08:00,999
I'm going to submit some work to the

00:07:57,759 --> 00:08:04,080
thread pool and then I'm going to add a

00:08:00,999 --> 00:08:08,919
done call back for when that completes

00:08:04,080 --> 00:08:11,379
so far kind of simple it completes I'm

00:08:08,919 --> 00:08:12,399
going to output the thread here so this

00:08:11,379 --> 00:08:14,259
is where the throwing gets kind of

00:08:12,399 --> 00:08:16,569
interesting I get the result from the

00:08:14,259 --> 00:08:19,930
future and now we need to update the UI

00:08:16,569 --> 00:08:22,449
but I'm on the wrong thread so the next

00:08:19,930 --> 00:08:24,339
thing I'm going to do is post some work

00:08:22,449 --> 00:08:28,300
back onto the UI thread where I can

00:08:24,339 --> 00:08:29,979
actually go and update the UI and this

00:08:28,300 --> 00:08:34,209
continues right so now I can update the

00:08:29,979 --> 00:08:37,719
UI here and now I want to clean the

00:08:34,209 --> 00:08:41,139
words so I'm going to submit that back

00:08:37,719 --> 00:08:42,339
to the thread pool threat and guess what

00:08:41,139 --> 00:08:45,250
happens when the thread pool threads

00:08:42,339 --> 00:08:47,680
done it has a done callback and I need

00:08:45,250 --> 00:08:50,069
to get back to the UI and so I'm just I

00:08:47,680 --> 00:08:53,809
have all these horribly nested functions

00:08:50,069 --> 00:08:57,079
my code isn't reading very well at all

00:08:53,809 --> 00:08:58,519
it's getting scrolled off my screen you

00:08:57,079 --> 00:09:00,679
know maybe I didn't have to use nested

00:08:58,519 --> 00:09:02,569
functions maybe I could have had these

00:09:00,679 --> 00:09:04,279
as top-level class functions or had

00:09:02,569 --> 00:09:06,050
another class to flow my state between

00:09:04,279 --> 00:09:08,869
them and stuff capturing them in

00:09:06,050 --> 00:09:10,490
closures but this is kind of a fairly

00:09:08,869 --> 00:09:14,869
straightforward way to do it even if

00:09:10,490 --> 00:09:17,809
it's super painful so let's look at that

00:09:14,869 --> 00:09:21,110
one running real quick I'm going to

00:09:17,809 --> 00:09:24,199
replace the handler there hit f5 and run

00:09:21,110 --> 00:09:27,050
it again again we can see we start on

00:09:24,199 --> 00:09:29,149
the UI thread I click count words we see

00:09:27,050 --> 00:09:31,759
cleaning pops up so my status is being

00:09:29,149 --> 00:09:34,519
maintained my app is running its

00:09:31,759 --> 00:09:36,350
remaining responsive and you can see

00:09:34,519 --> 00:09:38,269
through here you know words loaded

00:09:36,350 --> 00:09:40,249
completed on a different thread and then

00:09:38,269 --> 00:09:41,629
we've loaded the words and we're

00:09:40,249 --> 00:09:42,050
bouncing back and forth between the

00:09:41,629 --> 00:09:44,689
threads

00:09:42,050 --> 00:09:47,119
so I've solved my problem and my users

00:09:44,689 --> 00:09:48,679
happy but I don't want to maintain that

00:09:47,119 --> 00:09:50,420
code I don't even want to think about

00:09:48,679 --> 00:09:52,100
that code when I look at that code it's

00:09:50,420 --> 00:09:54,980
very hard to understand what's going on

00:09:52,100 --> 00:09:56,350
so I'd like a much much simpler way to

00:09:54,980 --> 00:10:01,670
deal with this

00:09:56,350 --> 00:10:02,799
so let's undo that change so we're going

00:10:01,670 --> 00:10:06,049
to do count again

00:10:02,799 --> 00:10:09,980
let's pretend that painful do account

00:10:06,049 --> 00:10:12,350
doesn't exist and I'm going to go ahead

00:10:09,980 --> 00:10:14,480
and decorate this with a task decorator

00:10:12,350 --> 00:10:22,420
which is going to turn this into a tulip

00:10:14,480 --> 00:10:22,420
task whoops the next thing I do is

00:10:22,509 --> 00:10:29,329
transform my long-running calls here

00:10:25,189 --> 00:10:32,899
into these yield from async calls this

00:10:29,329 --> 00:10:34,490
async method is just a little helper

00:10:32,899 --> 00:10:36,529
which is taking another call and its

00:10:34,490 --> 00:10:40,549
arguments and it's going to go off and

00:10:36,529 --> 00:10:43,759
run that on the thread pool thread just

00:10:40,549 --> 00:10:45,819
because it's a little verbose to send it

00:10:43,759 --> 00:10:50,809
to the thread pool thread

00:10:45,819 --> 00:10:52,490
via a tool up so and I can pop down and

00:10:50,809 --> 00:10:53,959
look at that real quick and so that's

00:10:52,490 --> 00:10:55,490
all this is doing is it's getting the

00:10:53,959 --> 00:10:57,980
current event loop for tool up and

00:10:55,490 --> 00:11:01,129
running executors goes off and runs that

00:10:57,980 --> 00:11:04,160
on a thread pull thread there's one more

00:11:01,129 --> 00:11:06,590
change I need to make so usually with

00:11:04,160 --> 00:11:09,920
any GUI framework you start the event

00:11:06,590 --> 00:11:13,340
somehow by calling some method with

00:11:09,920 --> 00:11:17,600
tulip we get a new event loop which is

00:11:13,340 --> 00:11:19,670
pythons event loop and normally in tulip

00:11:17,600 --> 00:11:22,190
this is just something which is

00:11:19,670 --> 00:11:23,720
processing Network events but here we're

00:11:22,190 --> 00:11:26,000
setting up the event loop which will let

00:11:23,720 --> 00:11:27,560
the tulip Framework know what the

00:11:26,000 --> 00:11:29,270
current event loop is so that we can get

00:11:27,560 --> 00:11:32,000
it back out later from arbitrary code

00:11:29,270 --> 00:11:36,560
and then it's just going to go into TK

00:11:32,000 --> 00:11:38,990
and run its normal event loop so that's

00:11:36,560 --> 00:11:43,190
a pretty simple set of changes right and

00:11:38,990 --> 00:11:44,839
my code reads almost exactly like I

00:11:43,190 --> 00:11:46,820
wanted my code to read it's very

00:11:44,839 --> 00:11:49,339
straightforward if I wanted to use loops

00:11:46,820 --> 00:11:51,050
in here or exception handling or any of

00:11:49,339 --> 00:11:54,260
the normal programming constructs I just

00:11:51,050 --> 00:11:56,890
write them how I'm used to and I can

00:11:54,260 --> 00:11:59,930
reason about this code so now I hit f5

00:11:56,890 --> 00:12:02,960
you'll see we start on thread two nine

00:11:59,930 --> 00:12:05,540
six eight we count the words cleaning

00:12:02,960 --> 00:12:07,940
shows up my apps responsive it's

00:12:05,540 --> 00:12:10,390
beautiful wonderful not only are my

00:12:07,940 --> 00:12:16,400
users happy but I'm happy too so

00:12:10,390 --> 00:12:18,200
everyone wins and yeah so that completes

00:12:16,400 --> 00:12:20,360
one of the interesting things here is

00:12:18,200 --> 00:12:22,160
that we're automatically bouncing

00:12:20,360 --> 00:12:24,470
between the UI threads and the worker

00:12:22,160 --> 00:12:26,360
threads in the thread pool so you can

00:12:24,470 --> 00:12:28,100
see whenever I'm running my code I'm

00:12:26,360 --> 00:12:31,130
automatically coming back to the UI

00:12:28,100 --> 00:12:33,470
thread and so I'm not violating my GUI

00:12:31,130 --> 00:12:36,560
frameworks single threaded conventions

00:12:33,470 --> 00:12:38,950
and that's great too so my program isn't

00:12:36,560 --> 00:12:38,950
broken

00:12:39,820 --> 00:12:45,470
so that's why I think this stuff is

00:12:42,110 --> 00:12:47,120
really cool so there are a few core

00:12:45,470 --> 00:12:51,920
concepts in there we saw the task

00:12:47,120 --> 00:12:54,620
decorator and all that thing does is

00:12:51,920 --> 00:12:56,660
it'll drive forward our state machine

00:12:54,620 --> 00:12:58,010
which is doing the yielding we saw the

00:12:56,660 --> 00:13:00,380
event loop that I added at the bottom

00:12:58,010 --> 00:13:03,320
and you might the title of my talk

00:13:00,380 --> 00:13:05,330
includes futures but strangely we didn't

00:13:03,320 --> 00:13:08,690
see a single feature anywhere within the

00:13:05,330 --> 00:13:10,339
code other than the submit to the thread

00:13:08,690 --> 00:13:11,839
pool you didn't really see the future

00:13:10,339 --> 00:13:15,950
there but that thing actually returned a

00:13:11,839 --> 00:13:17,540
future and the way this works is in my

00:13:15,950 --> 00:13:19,820
generator function which is what I

00:13:17,540 --> 00:13:20,130
turned that into by using the yield from

00:13:19,820 --> 00:13:23,970
Zen

00:13:20,130 --> 00:13:26,900
futures are being yielded out and it

00:13:23,970 --> 00:13:29,970
happens very transparently to the user

00:13:26,900 --> 00:13:32,580
so the top-level task is pretty

00:13:29,970 --> 00:13:35,070
important it kicks everything off and

00:13:32,580 --> 00:13:38,730
it's called just like any other normal

00:13:35,070 --> 00:13:41,280
function and it gets tasks yielded to it

00:13:38,730 --> 00:13:43,380
but the key thing about it is that it

00:13:41,280 --> 00:13:45,870
automatically steps forward as those

00:13:43,380 --> 00:13:48,030
futures complete so the future is

00:13:45,870 --> 00:13:50,220
yielded out and that future has a method

00:13:48,030 --> 00:13:50,940
called add done call back on it and so

00:13:50,220 --> 00:13:52,920
the task

00:13:50,940 --> 00:13:54,870
it calls add done call back on the

00:13:52,920 --> 00:13:57,420
future that's yielded to it and whenever

00:13:54,870 --> 00:13:59,820
that task completes or whenever that

00:13:57,420 --> 00:14:01,770
future completes its going to call back

00:13:59,820 --> 00:14:04,080
onto the task and it's going to

00:14:01,770 --> 00:14:06,000
reschedule the generator which is going

00:14:04,080 --> 00:14:09,390
to go off and run on the UI thread again

00:14:06,000 --> 00:14:12,390
automatically and so that just lets this

00:14:09,390 --> 00:14:13,860
all just magically step forward as the

00:14:12,390 --> 00:14:15,720
features that you're yielding complete

00:14:13,860 --> 00:14:18,270
you can get futures from the thread pool

00:14:15,720 --> 00:14:21,840
you can get futures by doing IO with

00:14:18,270 --> 00:14:23,910
tulip and you could use your own futures

00:14:21,840 --> 00:14:26,040
to go off and do work in an async manner

00:14:23,910 --> 00:14:28,020
on your own and just set the result

00:14:26,040 --> 00:14:30,210
whenever it completes whether that's

00:14:28,020 --> 00:14:32,310
using your own threads that you're

00:14:30,210 --> 00:14:36,120
creating or whatever it just gives this

00:14:32,310 --> 00:14:38,790
nice composable model and so this is

00:14:36,120 --> 00:14:40,530
kind of what the task looks like so it's

00:14:38,790 --> 00:14:42,660
just a simple decorator it's going to

00:14:40,530 --> 00:14:44,100
call the generator and that's going to

00:14:42,660 --> 00:14:46,820
give us the co-routine back and it's

00:14:44,100 --> 00:14:49,950
going to create a new task with that

00:14:46,820 --> 00:14:52,380
co-routine the first thing that's going

00:14:49,950 --> 00:14:54,360
to do is it's going to schedule that

00:14:52,380 --> 00:14:55,950
into the event loop with this step

00:14:54,360 --> 00:14:58,680
method here and that's what actually

00:14:55,950 --> 00:15:03,360
drives the event loop forward so each

00:14:58,680 --> 00:15:05,970
time step gets called it's going to run

00:15:03,360 --> 00:15:13,380
one step and go through the code until

00:15:05,970 --> 00:15:15,600
it yields out some some values again so

00:15:13,380 --> 00:15:17,460
the futures I kind of describe them a

00:15:15,600 --> 00:15:19,500
little bit but whenever you need to do

00:15:17,460 --> 00:15:21,480
some async work you can produce a future

00:15:19,500 --> 00:15:23,970
the thread pool already supports

00:15:21,480 --> 00:15:26,210
features in tulip there's a new future

00:15:23,970 --> 00:15:28,500
class which is separate from the

00:15:26,210 --> 00:15:31,290
existing future classes shipped in

00:15:28,500 --> 00:15:32,820
previous versions of Python but you can

00:15:31,290 --> 00:15:33,379
use either one within the tulip

00:15:32,820 --> 00:15:35,149
framework

00:15:33,379 --> 00:15:37,849
you can yield out one of the old-style

00:15:35,149 --> 00:15:41,509
futures or you can yield out one of the

00:15:37,849 --> 00:15:43,220
new tulip features and as I said we call

00:15:41,509 --> 00:15:46,459
add done call back on the future and

00:15:43,220 --> 00:15:48,499
when it completes we move that along and

00:15:46,459 --> 00:15:52,489
continue running the task on the UI

00:15:48,499 --> 00:15:54,589
thread so the first time through the

00:15:52,489 --> 00:15:56,389
first time we call step we'll see if

00:15:54,589 --> 00:15:58,129
it's a future which it has to be

00:15:56,389 --> 00:16:00,829
basically there's more code here that

00:15:58,129 --> 00:16:04,729
I've avoided and we'll add the done

00:16:00,829 --> 00:16:06,409
callback and the wakeup function we'll

00:16:04,729 --> 00:16:07,789
see what's going on if we got an

00:16:06,409 --> 00:16:10,609
exception from the future because

00:16:07,789 --> 00:16:12,889
something off on the thread pool aired

00:16:10,609 --> 00:16:14,179
out or if we got a value from the future

00:16:12,889 --> 00:16:16,609
because something completed successfully

00:16:14,179 --> 00:16:19,609
we'll go into step and that will then

00:16:16,609 --> 00:16:24,439
re-raise either the exception or it'll

00:16:19,609 --> 00:16:28,129
give us the value back the event loops

00:16:24,439 --> 00:16:30,199
so this is kind of core to tulip and

00:16:28,129 --> 00:16:34,909
it's one of the big differences that we

00:16:30,199 --> 00:16:36,649
had between tulip and waddle so for the

00:16:34,909 --> 00:16:38,199
GUI programming the event loop mainly

00:16:36,649 --> 00:16:41,059
knows how to get back to the UI thread

00:16:38,199 --> 00:16:44,629
it also knows how to do a ton of i/o

00:16:41,059 --> 00:16:47,119
related stuff and we don't care about

00:16:44,629 --> 00:16:49,339
that too much for GUI programming in

00:16:47,119 --> 00:16:52,189
theory we could just replace it all with

00:16:49,339 --> 00:16:53,239
work on the thread pool but we can

00:16:52,189 --> 00:16:54,529
actually do a little bit better than

00:16:53,239 --> 00:16:57,339
that with event loops as well and I'll

00:16:54,529 --> 00:17:01,220
talk about that in a minute

00:16:57,339 --> 00:17:03,470
so tool mainly includes event loops

00:17:01,220 --> 00:17:05,059
which work with i/o so it includes kind

00:17:03,470 --> 00:17:08,750
of two built-in event loops one for

00:17:05,059 --> 00:17:11,299
Windows and one for UNIX the Windows one

00:17:08,750 --> 00:17:16,009
uses IO completion ports the Linux one

00:17:11,299 --> 00:17:17,829
uses select eople Capel etc other

00:17:16,009 --> 00:17:21,230
frameworks are likely to ship their own

00:17:17,829 --> 00:17:23,059
event loops which are going to schedule

00:17:21,230 --> 00:17:25,850
thing into scheduled work into their

00:17:23,059 --> 00:17:28,490
existing framework so that you can start

00:17:25,850 --> 00:17:31,460
using yield from with those frameworks

00:17:28,490 --> 00:17:34,730
and/or create nice async code instead of

00:17:31,460 --> 00:17:37,460
using functions which are passed in as

00:17:34,730 --> 00:17:40,960
callbacks and so on right now there's no

00:17:37,460 --> 00:17:43,759
pre-existing GUI event loops but I have

00:17:40,960 --> 00:17:46,730
the key k1 and they're not really hard

00:17:43,759 --> 00:17:48,830
to create as we'll see and

00:17:46,730 --> 00:17:51,440
I think this lines up very nicely

00:17:48,830 --> 00:17:53,419
between the two because what Guido has

00:17:51,440 --> 00:17:56,540
tried to do with tulip is keep this very

00:17:53,419 --> 00:17:58,220
single threaded world where there isn't

00:17:56,540 --> 00:18:00,290
a lot of contention between multiple

00:17:58,220 --> 00:18:02,390
threads which are slowing the overall

00:18:00,290 --> 00:18:04,429
system down and GUI frameworks kind of

00:18:02,390 --> 00:18:06,140
work the same way where you have a

00:18:04,429 --> 00:18:12,320
single thread which is all processing

00:18:06,140 --> 00:18:15,770
the GUI events so this is the tulip

00:18:12,320 --> 00:18:17,990
event loop API and you can see it's got

00:18:15,770 --> 00:18:21,590
a bunch of random stuff in it it's got a

00:18:17,990 --> 00:18:23,120
huge amount of i/o stuff over here you

00:18:21,590 --> 00:18:24,830
don't have to really worry about all

00:18:23,120 --> 00:18:26,870
this stuff if you wanted to make an

00:18:24,830 --> 00:18:30,200
event loop those api's are actually

00:18:26,870 --> 00:18:32,510
optional so it's you know not too bad

00:18:30,200 --> 00:18:34,910
but for GUI programming you can actually

00:18:32,510 --> 00:18:37,070
do a lot better and I think those are

00:18:34,910 --> 00:18:40,130
kind of the only API is that you really

00:18:37,070 --> 00:18:41,809
need to create a GUI event loop and all

00:18:40,130 --> 00:18:44,570
these other api's can actually be

00:18:41,809 --> 00:18:46,010
implemented by delegating to another

00:18:44,570 --> 00:18:49,100
event loop which is running on another

00:18:46,010 --> 00:18:50,870
threat and so if you're on Windows for

00:18:49,100 --> 00:18:52,610
example you can have a bunch of i/o

00:18:50,870 --> 00:18:54,470
that's that you're doing and that's

00:18:52,610 --> 00:18:56,150
completing with i/o completion ports

00:18:54,470 --> 00:18:57,620
using the normal event loop kind of

00:18:56,150 --> 00:19:00,049
nicely on one thread or if you're on

00:18:57,620 --> 00:19:02,990
UNIX it's completing with select on a

00:19:00,049 --> 00:19:04,490
single thread and so all of your i/o is

00:19:02,990 --> 00:19:06,470
kind of nicely isolated and being

00:19:04,490 --> 00:19:08,570
processed by that single thread and your

00:19:06,470 --> 00:19:11,090
gooeys remaining responsive as well and

00:19:08,570 --> 00:19:13,580
so I have some sample code I have a link

00:19:11,090 --> 00:19:15,890
to it at the end here which is kind of a

00:19:13,580 --> 00:19:17,750
base gooey event loop implementation and

00:19:15,890 --> 00:19:20,750
it actually implements all of this stuff

00:19:17,750 --> 00:19:24,080
so if you wanted to go off and write an

00:19:20,750 --> 00:19:26,059
event loop for WX Python you just have

00:19:24,080 --> 00:19:28,460
to implement these run forever run one

00:19:26,059 --> 00:19:31,850
stop call later and call soon api's and

00:19:28,460 --> 00:19:33,679
you get everything else for free so

00:19:31,850 --> 00:19:37,940
these are actually really pretty easy

00:19:33,679 --> 00:19:40,220
api's to implement for your event loop

00:19:37,940 --> 00:19:42,559
because they really line up very closely

00:19:40,220 --> 00:19:46,190
with primitives that almost every single

00:19:42,559 --> 00:19:49,010
GUI framework has so run forever well

00:19:46,190 --> 00:19:53,990
that's just your main event loop so you

00:19:49,010 --> 00:19:57,600
can do app dot main loop and TK WX

00:19:53,990 --> 00:20:03,450
it's really different app dot main loop

00:19:57,600 --> 00:20:05,550
and pie side apt exact so run once you

00:20:03,450 --> 00:20:07,260
know it's pretty typical for GUI

00:20:05,550 --> 00:20:09,870
programming frameworks to have a way for

00:20:07,260 --> 00:20:11,960
you to pump messages so you can you know

00:20:09,870 --> 00:20:15,240
have all the problems of reinsurance e

00:20:11,960 --> 00:20:17,370
in t K that's app dot update I couldn't

00:20:15,240 --> 00:20:19,680
quite track down what it was and the

00:20:17,370 --> 00:20:21,810
other web frameworks if there's any

00:20:19,680 --> 00:20:26,760
dotnet WinForms programmers its

00:20:21,810 --> 00:20:29,880
application do events and you know so

00:20:26,760 --> 00:20:32,280
those all exist I'm sure there's one for

00:20:29,880 --> 00:20:34,080
WX and pi side as well I just I'm not a

00:20:32,280 --> 00:20:36,690
WX or PI site developer so I couldn't

00:20:34,080 --> 00:20:39,780
find it stopping your app every app

00:20:36,690 --> 00:20:41,910
every Windows GUI application has a way

00:20:39,780 --> 00:20:43,470
to quit right so if you want to stop

00:20:41,910 --> 00:20:48,150
your event loop there's some way to do

00:20:43,470 --> 00:20:49,470
it so app quit on TK if you use other

00:20:48,150 --> 00:20:52,980
frameworks I'm sure you know what it is

00:20:49,470 --> 00:20:55,380
and then the two final AP is our call

00:20:52,980 --> 00:20:58,470
soon and call later and so this is to

00:20:55,380 --> 00:21:01,710
post work back into the gooeys event

00:20:58,470 --> 00:21:03,510
loop call soon just means kind of run me

00:21:01,710 --> 00:21:05,130
as soon as possible right and so it's

00:21:03,510 --> 00:21:09,150
just sending a message to the event loop

00:21:05,130 --> 00:21:12,270
and in TK you can do that with a delay

00:21:09,150 --> 00:21:14,370
pretty naturally and you just pass in a

00:21:12,270 --> 00:21:15,960
call 'evil in WX there's a call after

00:21:14,370 --> 00:21:16,910
method which schedules the work on the

00:21:15,960 --> 00:21:20,070
UI thread

00:21:16,910 --> 00:21:20,930
call later can potentially be a little

00:21:20,070 --> 00:21:23,970
more interesting

00:21:20,930 --> 00:21:26,340
TK actually has a way to do it or you

00:21:23,970 --> 00:21:29,820
can pass in that delay so it's very easy

00:21:26,340 --> 00:21:32,310
to do 40 k WX and pi side both have

00:21:29,820 --> 00:21:34,140
timer classes that you can use and those

00:21:32,310 --> 00:21:38,310
timers can have intervals and they can

00:21:34,140 --> 00:21:40,020
be scheduled pretty regularly there's we

00:21:38,310 --> 00:21:43,320
go back there's also this call

00:21:40,020 --> 00:21:46,650
repeatedly API that can be built on top

00:21:43,320 --> 00:21:49,530
of call later pretty easily where you

00:21:46,650 --> 00:21:52,620
schedule the work to run later and it

00:21:49,530 --> 00:21:54,660
runs and then you reschedule it to run

00:21:52,620 --> 00:21:57,180
in the same interval later you can do

00:21:54,660 --> 00:21:58,470
slightly better on W X or PI side where

00:21:57,180 --> 00:22:03,660
you actually have these timers which

00:21:58,470 --> 00:22:07,290
will run repeatedly so that's kind of

00:22:03,660 --> 00:22:09,089
the basics of how it all works how you

00:22:07,290 --> 00:22:12,659
can build an event loop

00:22:09,089 --> 00:22:15,659
and how you consume it but I wanted to

00:22:12,659 --> 00:22:18,359
talk about the internals of it and what

00:22:15,659 --> 00:22:19,859
it builds on in Python itself because I

00:22:18,359 --> 00:22:21,689
think that's kind of one of the really

00:22:19,859 --> 00:22:23,399
cool things here is that this is

00:22:21,689 --> 00:22:25,079
basically done without changing the

00:22:23,399 --> 00:22:28,889
language at all and just using the

00:22:25,079 --> 00:22:33,049
existing features in the language so the

00:22:28,889 --> 00:22:35,219
first thing that uses is generators an

00:22:33,049 --> 00:22:36,839
important thing here is that generators

00:22:35,219 --> 00:22:38,519
kind of moist everything into a state

00:22:36,839 --> 00:22:40,469
machine for you and they move all of

00:22:38,519 --> 00:22:42,929
your locals off the stack which and see

00:22:40,469 --> 00:22:46,199
python is kind of already done anyway

00:22:42,929 --> 00:22:48,959
but you know it conceptually does that

00:22:46,199 --> 00:22:52,109
and it allows you to suspend and resume

00:22:48,959 --> 00:22:53,729
the execution of the function and it

00:22:52,109 --> 00:22:57,109
just turns out that Python generators

00:22:53,729 --> 00:22:59,189
are just super super powerful they're

00:22:57,109 --> 00:23:00,929
you know I don't know of another

00:22:59,189 --> 00:23:03,929
language that has generators that are

00:23:00,929 --> 00:23:07,379
nearly as powerful so the first building

00:23:03,929 --> 00:23:11,009
block here is the fact that generators

00:23:07,379 --> 00:23:14,189
got the send method in 2005 and so that

00:23:11,009 --> 00:23:17,069
lets a generator actually get a value

00:23:14,189 --> 00:23:22,079
back from a statement has been yielded

00:23:17,069 --> 00:23:24,089
so if I call this generator and call

00:23:22,079 --> 00:23:28,469
next on it then I can send a value in

00:23:24,089 --> 00:23:30,779
and that lets me use these expressions

00:23:28,469 --> 00:23:34,439
get values back so when I have a future

00:23:30,779 --> 00:23:36,449
that's returning a value back that value

00:23:34,439 --> 00:23:40,589
comes via this same mechanism that has

00:23:36,449 --> 00:23:42,719
existed you know for eight years now one

00:23:40,589 --> 00:23:44,819
of the most important things though is a

00:23:42,719 --> 00:23:48,779
rather recent development which is in

00:23:44,819 --> 00:23:51,169
Python 3.3 we got yield from and we got

00:23:48,779 --> 00:23:53,579
generators that can return values and

00:23:51,169 --> 00:23:55,259
the way this works is when the stop

00:23:53,579 --> 00:23:57,059
iteration exception is raised it's

00:23:55,259 --> 00:24:02,339
actually raised with a value that's

00:23:57,059 --> 00:24:04,139
coming back before Python 3.3 it was an

00:24:02,339 --> 00:24:08,939
error to return a value from a generator

00:24:04,139 --> 00:24:12,209
so this lets us actually write functions

00:24:08,939 --> 00:24:15,329
which are tasks or Co routines and have

00:24:12,209 --> 00:24:17,639
this return 23 come back from that value

00:24:15,329 --> 00:24:18,929
so that I can very naturally write

00:24:17,639 --> 00:24:21,210
something that's both yielding out

00:24:18,929 --> 00:24:26,309
values and suspending itself and

00:24:21,210 --> 00:24:29,490
producing values and then finally

00:24:26,309 --> 00:24:30,419
there's yield from so yield from was

00:24:29,490 --> 00:24:33,630
kind of one of the big differences

00:24:30,419 --> 00:24:38,909
between tulip and Waddell we were just

00:24:33,630 --> 00:24:40,799
using yield and in tool up its using

00:24:38,909 --> 00:24:43,080
yield from pretty consistently

00:24:40,799 --> 00:24:45,240
everywhere you can actually get away

00:24:43,080 --> 00:24:47,100
with just using yield if you just wanted

00:24:45,240 --> 00:24:49,049
to yield a future but you probably want

00:24:47,100 --> 00:24:50,779
to forget that and just remember to

00:24:49,049 --> 00:24:52,950
always use yield from everywhere

00:24:50,779 --> 00:24:55,200
features are interval so you can do

00:24:52,950 --> 00:24:57,360
yield from on them and you just have to

00:24:55,200 --> 00:24:59,309
know this one concept and not have to

00:24:57,360 --> 00:25:05,240
get confused about do I use yield or

00:24:59,309 --> 00:25:08,429
yield from here and then futures so

00:25:05,240 --> 00:25:12,059
Python ship features before they've been

00:25:08,429 --> 00:25:14,610
in the thread pool but Pat three one

00:25:12,059 --> 00:25:16,679
five six adds a new future class it's

00:25:14,610 --> 00:25:18,690
got the same basic API as the existing

00:25:16,679 --> 00:25:20,760
feature class there's some few

00:25:18,690 --> 00:25:23,520
differences you can't wait on the new

00:25:20,760 --> 00:25:25,919
features but you can set the result get

00:25:23,520 --> 00:25:27,480
the result and it's you know it's if

00:25:25,919 --> 00:25:31,679
you've used the old features you'll be

00:25:27,480 --> 00:25:33,419
pretty familiar with the new futures the

00:25:31,679 --> 00:25:34,980
old features were also a little tied to

00:25:33,419 --> 00:25:37,529
the thread pool they had some internal

00:25:34,980 --> 00:25:40,500
API is to kind of set some initial state

00:25:37,529 --> 00:25:42,570
on them and the thread pool inter

00:25:40,500 --> 00:25:44,460
operated with those internal api so the

00:25:42,570 --> 00:25:46,860
new features are kind of much cleaner in

00:25:44,460 --> 00:25:48,690
that respect and that there are simpler

00:25:46,860 --> 00:25:51,659
api and they don't have these internal

00:25:48,690 --> 00:25:54,029
details the key thing about features is

00:25:51,659 --> 00:25:57,270
this add done callback so whenever a

00:25:54,029 --> 00:25:59,460
future completes you call set result or

00:25:57,270 --> 00:26:02,250
set exception on it or you can cancel it

00:25:59,460 --> 00:26:03,690
and that will then go back and look at

00:26:02,250 --> 00:26:06,029
all the callbacks that are registered

00:26:03,690 --> 00:26:11,399
with the future and run them and that

00:26:06,029 --> 00:26:13,980
lets us continue on and we register with

00:26:11,399 --> 00:26:20,159
the add done callback and your generator

00:26:13,980 --> 00:26:25,529
continue stepping automatically so

00:26:20,159 --> 00:26:26,940
that's most of what i had i have some

00:26:25,529 --> 00:26:31,139
sample code up which you can download

00:26:26,940 --> 00:26:32,820
that includes a GUI event loop you can

00:26:31,139 --> 00:26:34,700
get tool up as well and try this out on

00:26:32,820 --> 00:26:39,809
python

00:26:34,700 --> 00:26:43,950
3.3 today the GUI event loop looks like

00:26:39,809 --> 00:26:45,990
this so if you have a framework that

00:26:43,950 --> 00:26:48,000
you'd like to light up and try this

00:26:45,990 --> 00:26:49,980
stuff out with you can take this GUI

00:26:48,000 --> 00:26:52,049
event loop and then all you have to do

00:26:49,980 --> 00:26:54,710
is derive from it and implement those

00:26:52,049 --> 00:26:58,290
few methods that I've mentioned before

00:26:54,710 --> 00:27:02,330
run run forever run one stop and you can

00:26:58,290 --> 00:27:05,340
see this is really not difficult at all

00:27:02,330 --> 00:27:07,860
the only marginally difficult thing is

00:27:05,340 --> 00:27:14,100
maybe cancelling events if you wanted to

00:27:07,860 --> 00:27:15,870
support that by its you know sixty two

00:27:14,100 --> 00:27:19,919
lines of code to implement an event loop

00:27:15,870 --> 00:27:21,660
for TK so while one might not exist for

00:27:19,919 --> 00:27:28,040
your Rudd framework I'm sure you can

00:27:21,660 --> 00:27:28,040
code one up in no time at all questions

00:27:34,770 --> 00:27:45,020
hi you implemented geeky event loop yeah

00:27:40,320 --> 00:27:49,020
which process only Tiki events yeah

00:27:45,020 --> 00:27:53,010
usually per Harmon need to process

00:27:49,020 --> 00:27:58,830
Network events also in the same main

00:27:53,010 --> 00:28:01,020
thread both GUI events and network

00:27:58,830 --> 00:28:03,390
activity yeah

00:28:01,020 --> 00:28:07,110
how do it is there a reason why you

00:28:03,390 --> 00:28:14,630
needed to in the same thread no just

00:28:07,110 --> 00:28:24,510
because usually I have signal processing

00:28:14,630 --> 00:28:28,740
units see house and often mine loop I

00:28:24,510 --> 00:28:34,470
see Network look assumed to be executed

00:28:28,740 --> 00:28:36,390
in main loop not in just x-rays right so

00:28:34,470 --> 00:28:38,490
that's kind of difficult because the GUI

00:28:36,390 --> 00:28:40,500
framework would need some support for

00:28:38,490 --> 00:28:42,390
processing those events right which

00:28:40,500 --> 00:28:44,520
really for that to work means that the

00:28:42,390 --> 00:28:47,010
GUI event loop would have to be based

00:28:44,520 --> 00:28:50,640
upon select or a polar cable and Linux

00:28:47,010 --> 00:28:53,010
or on the Windows Event windows

00:28:50,640 --> 00:28:54,510
I don't even particularly know how you'd

00:28:53,010 --> 00:28:58,679
combine those two on Windows into a

00:28:54,510 --> 00:29:01,320
single event loop if you could get off

00:28:58,679 --> 00:29:04,230
the other thread the way you would

00:29:01,320 --> 00:29:08,370
actually do this is you'd be using this

00:29:04,230 --> 00:29:10,650
other API here so there's get a door

00:29:08,370 --> 00:29:13,080
info for example which returns a future

00:29:10,650 --> 00:29:15,080
and so you can yield from to the current

00:29:13,080 --> 00:29:18,420
event loops get a tour info

00:29:15,080 --> 00:29:20,250
implementation and the GUI event loop is

00:29:18,420 --> 00:29:22,500
actually going to defer to the i/o event

00:29:20,250 --> 00:29:24,720
loop and it's going to run off on

00:29:22,500 --> 00:29:26,280
another thread and when it completes

00:29:24,720 --> 00:29:29,730
it's going to come back to the UI thread

00:29:26,280 --> 00:29:32,130
so I don't know exactly why you would be

00:29:29,730 --> 00:29:35,190
bound to needing to do all the i/o

00:29:32,130 --> 00:29:37,530
events on the same thread but this it

00:29:35,190 --> 00:29:39,240
would almost it would seem logically

00:29:37,530 --> 00:29:41,820
like they were running on the same

00:29:39,240 --> 00:29:43,500
thread even though the blocking on the

00:29:41,820 --> 00:29:45,150
i/o would actually happen on another

00:29:43,500 --> 00:29:46,980
thread but it give you a very

00:29:45,150 --> 00:29:48,300
straightforward programming model so if

00:29:46,980 --> 00:29:50,760
you could somehow move that

00:29:48,300 --> 00:29:53,850
off of the GUI thread then this would

00:29:50,760 --> 00:30:01,590
simplify things for you but I don't know

00:29:53,850 --> 00:30:04,770
if you will be able to do that you

00:30:01,590 --> 00:30:07,590
mentioned several toolkits GUI toolkits

00:30:04,770 --> 00:30:10,590
just like WX cootie and all these things

00:30:07,590 --> 00:30:17,430
yep did you also make some tests with by

00:30:10,590 --> 00:30:20,340
OpenGL no I did not very interesting

00:30:17,430 --> 00:30:22,650
talk by the way thank you so my question

00:30:20,340 --> 00:30:25,380
is and this is more of a tulip our

00:30:22,650 --> 00:30:27,810
futures and general question is how

00:30:25,380 --> 00:30:30,000
tight is it two threads as the

00:30:27,810 --> 00:30:32,910
concurrency primitive can you build

00:30:30,000 --> 00:30:37,230
something like tulip or use tulip for

00:30:32,910 --> 00:30:39,090
something like gee event or processes or

00:30:37,230 --> 00:30:42,090
some other concurrency primitives

00:30:39,090 --> 00:30:45,840
besides threads I think so

00:30:42,090 --> 00:30:48,420
so it is you know the API single

00:30:45,840 --> 00:30:50,640
threaded as it's documented and so it

00:30:48,420 --> 00:30:53,040
isn't too concerned with threads itself

00:30:50,640 --> 00:30:55,170
it has one API which is like call soon

00:30:53,040 --> 00:30:58,410
thread safe which is the only thing that

00:30:55,170 --> 00:30:59,880
really gets close to threads the

00:30:58,410 --> 00:31:02,670
difficulty there you know there's a

00:30:59,880 --> 00:31:04,170
bunch of these Io related api's that are

00:31:02,670 --> 00:31:06,270
going to take sockets and things like

00:31:04,170 --> 00:31:09,090
that and so if you wanted to go multi

00:31:06,270 --> 00:31:11,370
processing that's probably not going to

00:31:09,090 --> 00:31:14,010
work so well unless you invent your own

00:31:11,370 --> 00:31:18,720
system of handles between the processes

00:31:14,010 --> 00:31:23,190
and things like that but conceptually

00:31:18,720 --> 00:31:25,140
you could probably do that you know you

00:31:23,190 --> 00:31:27,000
could have Sauk connect implemented in

00:31:25,140 --> 00:31:29,220
your event loop I would think that

00:31:27,000 --> 00:31:32,550
returns something that is represents a

00:31:29,220 --> 00:31:36,180
socket in another process and then when

00:31:32,550 --> 00:31:37,920
someone goes soft receive you can handle

00:31:36,180 --> 00:31:41,160
that yourself right

00:31:37,920 --> 00:31:42,600
so tulip uses transports and handlers

00:31:41,160 --> 00:31:44,970
and things like that to actually

00:31:42,600 --> 00:31:45,540
abstract away kind of a little low-level

00:31:44,970 --> 00:31:48,540
details

00:31:45,540 --> 00:31:50,550
I hear Guido's keynote will be more

00:31:48,540 --> 00:31:52,290
about tulip so you might want to attend

00:31:50,550 --> 00:31:56,790
that as well thank you very much no

00:31:52,290 --> 00:31:58,500
problem I'm sorry if I missed it but in

00:31:56,790 --> 00:32:00,250
the standard library that is concurrent

00:31:58,500 --> 00:32:04,570
about futures and

00:32:00,250 --> 00:32:06,850
so NC any reference sought the dual and

00:32:04,570 --> 00:32:09,010
build on top of it are like so what's

00:32:06,850 --> 00:32:12,159
the difference it's a brand new features

00:32:09,010 --> 00:32:14,169
class it looks almost identical the

00:32:12,159 --> 00:32:16,659
concurrent features is a little tied to

00:32:14,169 --> 00:32:19,929
the thread pool and so it isn't

00:32:16,659 --> 00:32:21,940
perfectly reusable for this purpose so

00:32:19,929 --> 00:32:26,530
there will actually be two classes

00:32:21,940 --> 00:32:35,700
called future in Python 3.4 when the pep

00:32:26,530 --> 00:32:38,970
is all done apparently so nothing else

00:32:35,700 --> 00:32:38,970

YouTube URL: https://www.youtube.com/watch?v=oJQdX_w1vXY


