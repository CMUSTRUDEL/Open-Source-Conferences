Title: Python 3.3: Trust Me, It's Better than 2.7
Publication date: 2013-05-11
Playlist: PyCon 2013
Description: 
	Brett Cannon
In this talk I will try to convince you that Python 3.3 is superior to Python 2.7 by going over the differences between Python 2.7 and Python 3.3 along with benchmark information to show where Python 3.3 shines in comparison to Python 2.
Captions: 
	00:00:00,000 --> 00:00:03,300
everyone sitting I was going to

00:00:01,920 --> 00:00:05,700
introduce myself my name is Brett cannon

00:00:03,300 --> 00:00:08,670
I've been a core developer on Python for

00:00:05,700 --> 00:00:11,670
a decade come next month which scares

00:00:08,670 --> 00:00:12,929
the crap out of me if you want to follow

00:00:11,670 --> 00:00:15,570
me on any of the social network stuff

00:00:12,929 --> 00:00:17,250
I'm on Twitter I'm on G+ you can just go

00:00:15,570 --> 00:00:19,619
to about dot me slash Brett cannon to

00:00:17,250 --> 00:00:21,930
get the proper names so I don't have to

00:00:19,619 --> 00:00:25,380
fill my slide with us

00:00:21,930 --> 00:00:28,680
so this talk Python 33.3 where I

00:00:25,380 --> 00:00:31,289
consider it better than Python 2.7 I'm

00:00:28,680 --> 00:00:32,969
obviously biased having been a core

00:00:31,289 --> 00:00:35,489
developer for a long time I played a

00:00:32,969 --> 00:00:39,540
role in trying to make Python 3 come to

00:00:35,489 --> 00:00:41,520
fruition and shape it as it is so I'm

00:00:39,540 --> 00:00:44,129
just being upfront I do have my biases

00:00:41,520 --> 00:00:46,190
but other people do agree with me so

00:00:44,129 --> 00:00:49,230
this is not just some crazy man up here

00:00:46,190 --> 00:00:51,989
my hope is by then this talk if you

00:00:49,230 --> 00:00:53,670
already know Python 3 but don't know all

00:00:51,989 --> 00:00:55,199
the details of Python 3.3 you'll at

00:00:53,670 --> 00:00:57,360
least know what was added in that

00:00:55,199 --> 00:00:59,370
version if you don't know anything about

00:00:57,360 --> 00:01:01,829
Python 3 you always have an idea of what

00:00:59,370 --> 00:01:03,809
you will get when you upgrade and if

00:01:01,829 --> 00:01:05,790
you're still on 2.7 just here to heckle

00:01:03,809 --> 00:01:07,500
I am happy to take the heck clean and

00:01:05,790 --> 00:01:09,270
just say you're wrong

00:01:07,500 --> 00:01:10,530
but hopefully I'll change your mind by

00:01:09,270 --> 00:01:13,860
the end but if not that's fine

00:01:10,530 --> 00:01:15,689
everyone's up to your their opinion but

00:01:13,860 --> 00:01:17,310
I this is divided into two parts one is

00:01:15,689 --> 00:01:20,189
the feature set and then one is a

00:01:17,310 --> 00:01:21,570
performance discussion and I'm hoping to

00:01:20,189 --> 00:01:23,250
leave about ten minutes for questions if

00:01:21,570 --> 00:01:24,750
I'm lucky so I'm going to try to get

00:01:23,250 --> 00:01:27,570
through this so that everyone can get

00:01:24,750 --> 00:01:30,659
their questions answered so without

00:01:27,570 --> 00:01:32,369
further ado the feature set so we're

00:01:30,659 --> 00:01:35,159
going to go all the way from Python 3.0

00:01:32,369 --> 00:01:38,040
through 3.3 through at least the key

00:01:35,159 --> 00:01:40,680
points there is some stuff though that

00:01:38,040 --> 00:01:42,540
if you're on 2.7 or even possibly 2.6

00:01:40,680 --> 00:01:45,090
you can use today that have become the

00:01:42,540 --> 00:01:47,070
standard in Python 3 some things require

00:01:45,090 --> 00:01:49,439
future statement to use for instance

00:01:47,070 --> 00:01:51,329
absolute imports which make it so that

00:01:49,439 --> 00:01:52,950
you don't accidentally import the string

00:01:51,329 --> 00:01:54,180
module in your local directory when you

00:01:52,950 --> 00:01:56,880
actually one of the string module from

00:01:54,180 --> 00:01:58,229
the standard library Unicode literal so

00:01:56,880 --> 00:02:01,110
that every string literal you have is

00:01:58,229 --> 00:02:03,210
automatically assumed to be Unicode new

00:02:01,110 --> 00:02:07,320
division such as if you 3 divided by 2

00:02:03,210 --> 00:02:09,390
at least to 1.5 and not 1 the print

00:02:07,320 --> 00:02:11,430
function instead of statement which I

00:02:09,390 --> 00:02:13,260
know trips everyone up because we all

00:02:11,430 --> 00:02:13,740
got muscle memory to not have

00:02:13,260 --> 00:02:16,680
parentheses

00:02:13,740 --> 00:02:18,900
use but trust me it's better you also

00:02:16,680 --> 00:02:23,130
get set literals which is nice you get

00:02:18,900 --> 00:02:25,500
set indict comprehensions in 2.7 which

00:02:23,130 --> 00:02:26,820
do exactly what you think we have

00:02:25,500 --> 00:02:28,470
multiple context managers which

00:02:26,820 --> 00:02:31,680
basically means you don't necessarily

00:02:28,470 --> 00:02:32,730
need the context Lib nested function

00:02:31,680 --> 00:02:35,580
anymore

00:02:32,730 --> 00:02:37,950
there are the i/o library in 2.7 got

00:02:35,580 --> 00:02:40,980
completely rewritten in C so it's a lot

00:02:37,950 --> 00:02:43,680
faster that was a big change between 3.0

00:02:40,980 --> 00:02:45,690
and 3.1 by the way memory views came

00:02:43,680 --> 00:02:47,520
into existence and in Python 3.3 they

00:02:45,690 --> 00:02:49,260
actually got heavily rewritten so if you

00:02:47,520 --> 00:02:51,150
looked at those before 3.3 you might

00:02:49,260 --> 00:02:52,710
want to have another look there's a

00:02:51,150 --> 00:02:54,450
module called future built-ins which

00:02:52,710 --> 00:02:56,850
gives you built-ins the way they are and

00:02:54,450 --> 00:02:58,920
Python 3 so for instance map returns an

00:02:56,850 --> 00:03:00,990
iterator instead of a list so you get

00:02:58,920 --> 00:03:03,380
that nice lazy evaluation you don't blow

00:03:00,990 --> 00:03:05,790
your memory if you have a massive list

00:03:03,380 --> 00:03:07,590
exceptions the syntax got a little

00:03:05,790 --> 00:03:09,780
cleaned up so now it's except exception

00:03:07,590 --> 00:03:11,850
as Exe or whatever variable you choose

00:03:09,780 --> 00:03:14,310
instead of a comma so it's just a little

00:03:11,850 --> 00:03:17,430
cleaner to read aster dot format came

00:03:14,310 --> 00:03:20,040
into being in 2.6 and in 2.7 and python

00:03:17,430 --> 00:03:22,610
3 we have auto numbering in the fields

00:03:20,040 --> 00:03:25,470
and just one key little point on this

00:03:22,610 --> 00:03:27,510
pipe i actually makes stirred-up format

00:03:25,470 --> 00:03:30,180
run faster than the module string

00:03:27,510 --> 00:03:31,680
interpolation so don't think it's

00:03:30,180 --> 00:03:34,290
necessary going to be slower to do it

00:03:31,680 --> 00:03:35,520
that way than the old way just so you

00:03:34,290 --> 00:03:37,590
know because i hear that complaint

00:03:35,520 --> 00:03:39,540
sometimes we also added the numbers

00:03:37,590 --> 00:03:43,280
module which helps give a proper

00:03:39,540 --> 00:03:46,650
classification of numbers inches

00:03:43,280 --> 00:03:48,090
integers to floats to imaginary to all

00:03:46,650 --> 00:03:49,920
that stuff if you're a more

00:03:48,090 --> 00:03:51,270
mathematician scientific person you

00:03:49,920 --> 00:03:55,830
probably care a lot more about that than

00:03:51,270 --> 00:03:59,010
I do but people like it so that's what

00:03:55,830 --> 00:04:00,480
you can already get in 2.6 and 2.7 in

00:03:59,010 --> 00:04:02,160
terms of minor features that are

00:04:00,480 --> 00:04:04,920
exclusive to Python 3

00:04:02,160 --> 00:04:08,070
we have dict views so basically when you

00:04:04,920 --> 00:04:09,900
call items keys values you actually get

00:04:08,070 --> 00:04:11,160
back an object that has a view back on

00:04:09,900 --> 00:04:12,300
the dictionary so there's some space

00:04:11,160 --> 00:04:15,090
savings and you ought to worry about

00:04:12,300 --> 00:04:17,160
mutations underneath you comparison

00:04:15,090 --> 00:04:18,780
between disparate types is now a type

00:04:17,160 --> 00:04:20,549
error so you can't accidentally compare

00:04:18,780 --> 00:04:21,870
between an antenna string and actually

00:04:20,549 --> 00:04:23,310
get a true false you will get an

00:04:21,870 --> 00:04:24,870
exception so you don't make that error

00:04:23,310 --> 00:04:27,540
anymore

00:04:24,870 --> 00:04:29,340
the old way of doing exceptions

00:04:27,540 --> 00:04:31,160
by raising with a comma for the argument

00:04:29,340 --> 00:04:33,990
is now no no so we cleaned up the syntax

00:04:31,160 --> 00:04:35,160
for exceptions that way metaclasses

00:04:33,990 --> 00:04:37,650
became a little easier to work with

00:04:35,160 --> 00:04:39,420
there's now a meta class class argument

00:04:37,650 --> 00:04:41,240
keyword that you can now use to specify

00:04:39,420 --> 00:04:44,790
instead of the unknown or meta class

00:04:41,240 --> 00:04:46,800
setting for that object the under

00:04:44,790 --> 00:04:48,270
prepare attribute came about which

00:04:46,800 --> 00:04:48,720
basically allows you to use an order

00:04:48,270 --> 00:04:50,100
dict

00:04:48,720 --> 00:04:51,360
for the creation of your objects

00:04:50,100 --> 00:04:53,000
actually keep track of the declaration

00:04:51,360 --> 00:04:55,530
order of things in a class if you want

00:04:53,000 --> 00:04:57,720
the starred library cleanup which I led

00:04:55,530 --> 00:04:59,790
occurred so a lot of modules now have

00:04:57,720 --> 00:05:01,590
much more reasonable names and things

00:04:59,790 --> 00:05:03,330
are much more pest structured into

00:05:01,590 --> 00:05:06,780
packages so it's a little easier to

00:05:03,330 --> 00:05:07,860
navigate logging now uses dictionaries

00:05:06,780 --> 00:05:09,480
for configuration which is a little

00:05:07,860 --> 00:05:10,680
easier to read the Whiskey spec got a

00:05:09,480 --> 00:05:13,880
little update it'll be a little more

00:05:10,680 --> 00:05:18,990
clear super no longer requires arguments

00:05:13,880 --> 00:05:20,550
yes my new favorite quote for this is

00:05:18,990 --> 00:05:23,940
Jacob kept of masses every time he uses

00:05:20,550 --> 00:05:26,130
he gets irrationally excited it is very

00:05:23,940 --> 00:05:27,870
handy we unify an integer so there's no

00:05:26,130 --> 00:05:29,430
longer an int long distinction it's all

00:05:27,870 --> 00:05:33,180
just longer the hood and we just call it

00:05:29,430 --> 00:05:34,920
int and you know only to find the next

00:05:33,180 --> 00:05:36,360
method as just the name next when you're

00:05:34,920 --> 00:05:37,920
dealing with generators and iterators

00:05:36,360 --> 00:05:40,020
and such it's just under under next so

00:05:37,920 --> 00:05:42,060
it matches the overall format of all

00:05:40,020 --> 00:05:46,350
other kind of magic method names and

00:05:42,060 --> 00:05:48,030
there's now an X built in in terms of

00:05:46,350 --> 00:05:51,960
those things that we added that are just

00:05:48,030 --> 00:05:53,370
specific to Python 3.3 the i/o and OS

00:05:51,960 --> 00:05:56,670
exception hierarchy was completely

00:05:53,370 --> 00:05:59,190
reworked so now there's a not found file

00:05:56,670 --> 00:06:01,350
error exception so no longer do you have

00:05:59,190 --> 00:06:02,700
to catch il error and check that err no

00:06:01,350 --> 00:06:04,410
attribute you can actually catch a

00:06:02,700 --> 00:06:06,390
specific exception so it's a lot easier

00:06:04,410 --> 00:06:08,550
to read and all longer those one little

00:06:06,390 --> 00:06:11,310
liners to try to do with if check pass

00:06:08,550 --> 00:06:12,150
or raise blah blah that's all gone it's

00:06:11,310 --> 00:06:15,600
very nice

00:06:12,150 --> 00:06:20,610
modules we added the lzma module which

00:06:15,600 --> 00:06:22,770
does the X's add Russian format we head

00:06:20,610 --> 00:06:25,890
to the IP address module which does ipv4

00:06:22,770 --> 00:06:26,970
and ipv6 address parsing the fault

00:06:25,890 --> 00:06:29,100
handler module helps you deal with

00:06:26,970 --> 00:06:30,990
interrupts the email package got

00:06:29,100 --> 00:06:32,880
completely rewritten for headers so now

00:06:30,990 --> 00:06:35,120
it's a little more sane and completely

00:06:32,880 --> 00:06:37,320
unicode aware and usable

00:06:35,120 --> 00:06:38,910
dictionaries now share their keys which

00:06:37,320 --> 00:06:41,129
in our story encode is a big deal

00:06:38,910 --> 00:06:42,809
because remember every object

00:06:41,129 --> 00:06:45,300
Python has under under dick twitch

00:06:42,809 --> 00:06:48,419
mandals manages the objects namespace

00:06:45,300 --> 00:06:50,909
right so to creating a billion objects

00:06:48,419 --> 00:06:53,249
that all have an attribute named blah

00:06:50,909 --> 00:06:54,959
this now means there's only one blog

00:06:53,249 --> 00:06:56,639
being used between those billion objects

00:06:54,959 --> 00:06:58,709
instead of the billion uses of blah so

00:06:56,639 --> 00:07:00,209
there's going to be big temperature 20%

00:06:58,709 --> 00:07:04,349
memory savings without any performance

00:07:00,209 --> 00:07:06,659
loss okay so those are the simple

00:07:04,349 --> 00:07:08,879
quickie you guys concept from a bullet

00:07:06,659 --> 00:07:10,860
point get now we're gonna get some more

00:07:08,879 --> 00:07:12,110
fancy stuff that needs a little more

00:07:10,860 --> 00:07:17,929
explanation

00:07:12,110 --> 00:07:21,599
so to start non-local if you've used any

00:07:17,929 --> 00:07:23,990
scoped closures before the baby notes is

00:07:21,599 --> 00:07:25,979
a little hard to try to mutate

00:07:23,990 --> 00:07:28,439
attributes I mean the old trick used to

00:07:25,979 --> 00:07:30,209
be here's a list that has a single

00:07:28,439 --> 00:07:32,789
object in it I will reference it and

00:07:30,209 --> 00:07:34,439
then mutate that single index value in

00:07:32,789 --> 00:07:37,019
the list kind of like the old trick to

00:07:34,439 --> 00:07:40,139
having mutate able default argument to

00:07:37,019 --> 00:07:42,059
functions or methods well when we added

00:07:40,139 --> 00:07:43,409
a non-local that did away with that so

00:07:42,059 --> 00:07:45,839
now you can declare a variable as either

00:07:43,409 --> 00:07:47,429
global or non-local and this way you can

00:07:45,839 --> 00:07:49,199
make sure you can actually mutate

00:07:47,429 --> 00:07:51,479
objects at the correct scope level that

00:07:49,199 --> 00:07:53,189
you care about so in this example for

00:07:51,479 --> 00:07:55,409
instance by declaring higher scoped is

00:07:53,189 --> 00:07:57,929
non-local that variable the top-level

00:07:55,409 --> 00:07:59,879
function can actually be mutated in the

00:07:57,929 --> 00:08:00,469
closure and properly do what you would

00:07:59,879 --> 00:08:02,879
expect

00:08:00,469 --> 00:08:06,179
so basically closures are normal go read

00:08:02,879 --> 00:08:10,289
only for the captured variables is now

00:08:06,179 --> 00:08:12,179
read or write extended or iterable

00:08:10,289 --> 00:08:14,399
unpacking this is a nice little handy

00:08:12,179 --> 00:08:17,219
thing basically when you do variable

00:08:14,399 --> 00:08:18,809
assignments you can now use an asterisk

00:08:17,219 --> 00:08:21,269
to mark that something is supposed to

00:08:18,809 --> 00:08:23,279
collect all the extra arguments out of

00:08:21,269 --> 00:08:25,679
an iterable and basically everything

00:08:23,279 --> 00:08:28,409
else gets unpacked so the first example

00:08:25,679 --> 00:08:30,419
first comma star rest equals range 5 as

00:08:28,409 --> 00:08:31,619
you can see first get 0 and all the rest

00:08:30,419 --> 00:08:34,979
of what's supposed to come out of that

00:08:31,619 --> 00:08:36,029
interval gets set to rest now the really

00:08:34,979 --> 00:08:38,490
cool thing is you can actually put this

00:08:36,029 --> 00:08:40,620
in the middle of a list or in a list but

00:08:38,490 --> 00:08:42,719
sequence variable names so that you can

00:08:40,620 --> 00:08:44,730
actually pack specific amounts on either

00:08:42,719 --> 00:08:46,199
side of the sequence and have everything

00:08:44,730 --> 00:08:47,250
else kind of like get packed up in the

00:08:46,199 --> 00:08:49,439
middle if you want so as you can see

00:08:47,250 --> 00:08:51,779
here the B variable in the middle is

00:08:49,439 --> 00:08:54,209
actually what gets the variable amount

00:08:51,779 --> 00:08:54,930
of values in the list while a and C

00:08:54,209 --> 00:09:00,540
specifically only

00:08:54,930 --> 00:09:03,420
want value a big thing for you extension

00:09:00,540 --> 00:09:07,380
developers we defined a stable ABI in

00:09:03,420 --> 00:09:09,270
Python 3 basically according from I

00:09:07,380 --> 00:09:12,089
think the pep I don't remember I got

00:09:09,270 --> 00:09:15,330
these squats basically we define a

00:09:12,089 --> 00:09:16,470
stable set of api's at the sea level and

00:09:15,330 --> 00:09:18,120
basically we guarantee those will be

00:09:16,470 --> 00:09:20,520
available for the rest of the lifetime

00:09:18,120 --> 00:09:22,260
in Python 3 so what this means is is if

00:09:20,520 --> 00:09:24,570
you develop your C extensions to the

00:09:22,260 --> 00:09:26,339
stable ABI you don't have to necessarily

00:09:24,570 --> 00:09:28,350
recompile for every single verse on

00:09:26,339 --> 00:09:30,420
Python because something that the ABI

00:09:28,350 --> 00:09:31,890
level changed right it's going to be

00:09:30,420 --> 00:09:33,810
stable you don't have to worry about it

00:09:31,890 --> 00:09:36,420
will always just work you don't have to

00:09:33,810 --> 00:09:39,089
do updates on every single version I'll

00:09:36,420 --> 00:09:41,279
talk about a new feature in the few

00:09:39,089 --> 00:09:43,560
slides later that'll show that you don't

00:09:41,279 --> 00:09:45,029
have to recompile ever for anything you

00:09:43,560 --> 00:09:46,500
can do it just once if you do it right

00:09:45,029 --> 00:09:51,450
and it'll just keep working for Python

00:09:46,500 --> 00:09:53,339
three concurrent off futures this is

00:09:51,450 --> 00:09:55,290
kind of a cool little thing that we got

00:09:53,339 --> 00:09:57,089
into the standard library for any of you

00:09:55,290 --> 00:09:59,580
who want really dead simple ways to take

00:09:57,089 --> 00:10:01,890
embarrass lis very singly parallel work

00:09:59,580 --> 00:10:05,760
and just shove it off to threads or

00:10:01,890 --> 00:10:08,640
processes you can do it really easily so

00:10:05,760 --> 00:10:12,060
if you look at this example it takes six

00:10:08,640 --> 00:10:14,580
seconds to calculate numbers 0 to 19 to

00:10:12,060 --> 00:10:16,640
the power of a million but if you

00:10:14,580 --> 00:10:19,440
basically just add an import line a

00:10:16,640 --> 00:10:21,810
context manager that uses processes and

00:10:19,440 --> 00:10:24,450
change one map call to an executor map

00:10:21,810 --> 00:10:26,670
it all happens in a second that's all it

00:10:24,450 --> 00:10:28,410
takes to use as many processes as you

00:10:26,670 --> 00:10:31,620
need to do this calculation in parallel

00:10:28,410 --> 00:10:32,640
it's really nice really simple and as I

00:10:31,620 --> 00:10:35,220
said for those embarrassingly parallel

00:10:32,640 --> 00:10:36,600
workloads this is great it's almost just

00:10:35,220 --> 00:10:39,620
a drop-in replacement for where you

00:10:36,600 --> 00:10:42,720
would just use math to do something

00:10:39,620 --> 00:10:45,360
decimal got completely implemented in C

00:10:42,720 --> 00:10:48,209
and Python 3.3 those numbers are not

00:10:45,360 --> 00:10:51,270
typos literally things using decimal are

00:10:48,209 --> 00:10:54,570
now often times 30 percent 30 times not

00:10:51,270 --> 00:10:56,459
percent 30 times faster we've actually

00:10:54,570 --> 00:10:58,529
seen numbers as high as 80 times faster

00:10:56,459 --> 00:11:00,149
so if you do any work with the decimal

00:10:58,529 --> 00:11:02,610
module you seriously we should look at

00:11:00,149 --> 00:11:07,630
using Python 3.3 your workloads will be

00:11:02,610 --> 00:11:11,529
significantly faster it's ridiculous

00:11:07,630 --> 00:11:14,110
okay qualified names we cleaned up the

00:11:11,529 --> 00:11:16,000
way things are now named such that on an

00:11:14,110 --> 00:11:18,699
object's if you look at the under qual

00:11:16,000 --> 00:11:20,490
name it now includes four methods in the

00:11:18,699 --> 00:11:22,870
name of the class as well as the method

00:11:20,490 --> 00:11:24,970
so if you use under under name which is

00:11:22,870 --> 00:11:27,490
scope from the global namespace for the

00:11:24,970 --> 00:11:28,779
module and take that onto under under

00:11:27,490 --> 00:11:31,480
call name you can now get the fully

00:11:28,779 --> 00:11:33,579
qualified name in your overall namespace

00:11:31,480 --> 00:11:37,149
of where something came from right so in

00:11:33,579 --> 00:11:39,759
this example class C defines a method F

00:11:37,149 --> 00:11:42,040
as you can see the old under under name

00:11:39,759 --> 00:11:45,339
on the method F was just F but the call

00:11:42,040 --> 00:11:47,769
name is actually C F and if you module

00:11:45,339 --> 00:11:49,540
innate was foo and just tack that on you

00:11:47,769 --> 00:11:52,630
could have said food C F with that

00:11:49,540 --> 00:11:55,600
little zipper to code up there so number

00:11:52,630 --> 00:11:56,800
one what F is this I don't know just use

00:11:55,600 --> 00:12:00,910
qual name is dead and can actually

00:11:56,800 --> 00:12:02,440
figure it out yield from you will care

00:12:00,910 --> 00:12:04,810
about this things to Guido which I'm

00:12:02,440 --> 00:12:06,670
sure he will talk about on Sunday

00:12:04,810 --> 00:12:09,910
but basically it's a new thing in Python

00:12:06,670 --> 00:12:14,500
three point three that makes a really

00:12:09,910 --> 00:12:15,850
easy to factor out generators so I'll go

00:12:14,500 --> 00:12:17,529
over the example real quick and it'll be

00:12:15,850 --> 00:12:18,610
a little more obvious let's say you

00:12:17,529 --> 00:12:19,720
literally had a function that did

00:12:18,610 --> 00:12:21,939
nothing more than just yielded three

00:12:19,720 --> 00:12:25,050
times right how would you factor out

00:12:21,939 --> 00:12:27,610
those last two yields cleanly before

00:12:25,050 --> 00:12:29,889
yield from you probably factor it out to

00:12:27,610 --> 00:12:33,130
another generator right and then you'd

00:12:29,889 --> 00:12:37,300
have a for loop we would just go for X

00:12:33,130 --> 00:12:38,680
in the generator yield whatever right so

00:12:37,300 --> 00:12:41,189
you'd stick in this for loop to try to

00:12:38,680 --> 00:12:43,540
constantly yield and pass it up well

00:12:41,189 --> 00:12:45,220
that's now gone with yield from it's a

00:12:43,540 --> 00:12:47,410
single keyword that is the yielding

00:12:45,220 --> 00:12:48,880
straight up now fancier than just a for

00:12:47,410 --> 00:12:50,560
loop though you have to realize that the

00:12:48,880 --> 00:12:53,170
way this works is it will send

00:12:50,560 --> 00:12:54,790
everything all the way down the stack to

00:12:53,170 --> 00:12:57,069
the end so that lets say you have

00:12:54,790 --> 00:12:59,500
stacked yield from x' and you do a send

00:12:57,069 --> 00:13:01,029
on your generator that will fall through

00:12:59,500 --> 00:13:03,459
all the yield frames all the way down to

00:13:01,029 --> 00:13:04,569
the bottom so you don't have so it's a

00:13:03,459 --> 00:13:06,639
little fancier than just a for loop

00:13:04,569 --> 00:13:08,829
don't you can think of it that way in

00:13:06,639 --> 00:13:10,839
terms of refactoring of generators out

00:13:08,829 --> 00:13:12,399
separate generators but you realize

00:13:10,839 --> 00:13:15,120
there's a little bit more behind it than

00:13:12,399 --> 00:13:17,350
just syntactic sugar for a for loop so

00:13:15,120 --> 00:13:19,870
it's really handy though and it's going

00:13:17,350 --> 00:13:21,279
to come into play Python 3.4 because

00:13:19,870 --> 00:13:24,490
Guido has been working on an eight

00:13:21,279 --> 00:13:26,499
sink event loop system and it completely

00:13:24,490 --> 00:13:27,670
runs off of yield from and he's

00:13:26,499 --> 00:13:29,170
completely tied to into yield from

00:13:27,670 --> 00:13:31,300
because he likes that way of doing async

00:13:29,170 --> 00:13:32,620
so this will become a key thing in the

00:13:31,300 --> 00:13:38,110
future of Python in terms of a sequence

00:13:32,620 --> 00:13:40,689
workloads then so this is new in Python

00:13:38,110 --> 00:13:49,660
3.3 we've essentially just added virtual

00:13:40,689 --> 00:13:51,279
M to Python yes it's a good thing so as

00:13:49,660 --> 00:13:53,589
I said it's basically virtual amp it's

00:13:51,279 --> 00:13:56,470
just built in you can either use the

00:13:53,589 --> 00:13:58,089
venn modules with the - m to create a

00:13:56,470 --> 00:14:00,639
new virtual environment or we now

00:13:58,089 --> 00:14:02,559
include a PI ven script that will do the

00:14:00,639 --> 00:14:04,209
exact same thing because it's now

00:14:02,559 --> 00:14:05,379
directly integrated into Python a lot of

00:14:04,209 --> 00:14:06,819
the edge cases you might be used to

00:14:05,379 --> 00:14:08,949
hitting with virtual lamp is now gone

00:14:06,819 --> 00:14:11,589
because it's a directly supported thing

00:14:08,949 --> 00:14:13,329
and environment now it can be nothing

00:14:11,589 --> 00:14:16,149
more than a copy of the binding or even

00:14:13,329 --> 00:14:18,220
just a simile on the right OS a little

00:14:16,149 --> 00:14:19,540
config file and a site stash packages

00:14:18,220 --> 00:14:21,399
directory and that's it it's really

00:14:19,540 --> 00:14:23,350
lightweight and Python now completely

00:14:21,399 --> 00:14:25,480
supports it all the way through and it's

00:14:23,350 --> 00:14:27,160
fantastic no more downloading virtual

00:14:25,480 --> 00:14:30,519
lamp every single project it's just

00:14:27,160 --> 00:14:32,949
there I love it

00:14:30,519 --> 00:14:34,449
ok so those are things that needed a

00:14:32,949 --> 00:14:37,600
slide now these are things that needs

00:14:34,449 --> 00:14:43,180
lots of slides this is more thematic but

00:14:37,600 --> 00:14:45,069
still need to cover them so exceptions

00:14:43,180 --> 00:14:46,120
we did a lot of work in trying to make

00:14:45,069 --> 00:14:48,189
sure exceptions we're a little cleaned

00:14:46,120 --> 00:14:52,350
up in terms of syntax and how they works

00:14:48,189 --> 00:14:55,120
now everything kind of tied together so

00:14:52,350 --> 00:14:57,189
first thing we now include the trace

00:14:55,120 --> 00:15:00,040
back with the exception so you might be

00:14:57,189 --> 00:15:01,569
used to having to look and do the Syst

00:15:00,040 --> 00:15:03,009
module defining what the current trace

00:15:01,569 --> 00:15:05,529
back was playing with the trace back

00:15:03,009 --> 00:15:06,639
module and all that stuff well it's not

00:15:05,529 --> 00:15:08,290
as they require done right you can use

00:15:06,639 --> 00:15:09,939
the trace back module to do clean

00:15:08,290 --> 00:15:11,139
printing and stuff but to actually get

00:15:09,939 --> 00:15:13,149
to the trace back of the current

00:15:11,139 --> 00:15:15,339
exception it's just there is under under

00:15:13,149 --> 00:15:16,809
trace back so no more having to dig it

00:15:15,339 --> 00:15:21,100
out or anywhere it's just carried along

00:15:16,809 --> 00:15:23,589
with the exception we also added

00:15:21,100 --> 00:15:25,720
exception chaining both implicit and

00:15:23,589 --> 00:15:27,429
explicit so with implicit exception

00:15:25,720 --> 00:15:29,829
chaining let's say you've raised an

00:15:27,429 --> 00:15:31,329
exception you catch that active

00:15:29,829 --> 00:15:33,429
exception and then you raise another one

00:15:31,329 --> 00:15:34,630
well what happens is we set this

00:15:33,429 --> 00:15:38,259
attribute called under under

00:15:34,630 --> 00:15:40,660
context on the new raise exception which

00:15:38,259 --> 00:15:42,579
contains the previous exception so that

00:15:40,660 --> 00:15:46,870
way there's no loss of data at all if

00:15:42,579 --> 00:15:48,190
you forgot to specify that oh this

00:15:46,870 --> 00:15:49,329
exception trigger this other exception

00:15:48,190 --> 00:15:51,130
or whatever you don't need to it's all

00:15:49,329 --> 00:15:52,120
completely implicit and we will say

00:15:51,130 --> 00:15:54,040
during the handling of the above

00:15:52,120 --> 00:15:56,050
exception another exception happened to

00:15:54,040 --> 00:15:57,310
occur so there's no loss of actual trace

00:15:56,050 --> 00:15:59,230
back data when you raise an exception

00:15:57,310 --> 00:16:02,019
whether you explicitly wanted to or not

00:15:59,230 --> 00:16:03,639
so it really makes exceptions a lot

00:16:02,019 --> 00:16:05,740
cleaner and easier to work with because

00:16:03,639 --> 00:16:08,560
there's just no loss of data anymore in

00:16:05,740 --> 00:16:09,819
terms of what you need for debugging but

00:16:08,560 --> 00:16:11,829
let's say you want to be very explicit

00:16:09,819 --> 00:16:13,300
about this and really say ok this

00:16:11,829 --> 00:16:14,709
exception really really did happen

00:16:13,300 --> 00:16:16,540
because of this other exception not just

00:16:14,709 --> 00:16:17,709
oh I caught an attribute error and I

00:16:16,540 --> 00:16:19,329
want to raise the value err it's like

00:16:17,709 --> 00:16:20,920
alright this value I specifically

00:16:19,329 --> 00:16:23,940
happened because of this attribute error

00:16:20,920 --> 00:16:27,459
well we now have a under under Clause

00:16:23,940 --> 00:16:29,860
attribute and in Python 3.3 you can

00:16:27,459 --> 00:16:31,649
suppress it with adding the from none

00:16:29,860 --> 00:16:34,779
but basically the syntax is raise

00:16:31,649 --> 00:16:36,519
exception from the other exception and

00:16:34,779 --> 00:16:37,930
it's much like implicit exception

00:16:36,519 --> 00:16:39,850
chaining except the wording is a little

00:16:37,930 --> 00:16:41,620
different than the attributes different

00:16:39,850 --> 00:16:43,630
so here as we say the above exception

00:16:41,620 --> 00:16:45,790
was the direct cause of the form of

00:16:43,630 --> 00:16:47,110
exception so as I said one is implicit

00:16:45,790 --> 00:16:49,209
where you just do a raise we kind of

00:16:47,110 --> 00:16:50,110
just implicitly say okay this happened

00:16:49,209 --> 00:16:51,819
and then this happens so they're

00:16:50,110 --> 00:16:54,160
probably connected this one is you

00:16:51,819 --> 00:16:57,160
explicitly state for the user this

00:16:54,160 --> 00:16:58,750
happened because of this once again it's

00:16:57,160 --> 00:17:00,550
very nice because there's no more loss

00:16:58,750 --> 00:17:01,839
of any exception information if you're

00:17:00,550 --> 00:17:07,390
struggling between multiple exceptions

00:17:01,839 --> 00:17:09,760
chaining along import so part of this is

00:17:07,390 --> 00:17:13,470
my fault

00:17:09,760 --> 00:17:16,929
so import lib for those you don't know I

00:17:13,470 --> 00:17:19,240
rewrote import in pure Python and made

00:17:16,929 --> 00:17:22,959
the import Lib library added that in

00:17:19,240 --> 00:17:25,419
Python 3 point 1 2 1 2 somewhere in

00:17:22,959 --> 00:17:27,789
there but I happen to Python 3 point 3

00:17:25,419 --> 00:17:28,299
it is now the actual implementation for

00:17:27,789 --> 00:17:31,690
import

00:17:28,299 --> 00:17:34,260
so all that C code is now gone it's all

00:17:31,690 --> 00:17:36,610
actually implemented in Python itself

00:17:34,260 --> 00:17:38,470
the big deal about this is the goal is

00:17:36,610 --> 00:17:40,330
all the VMS will be now using the exact

00:17:38,470 --> 00:17:41,740
same implementation of import for any of

00:17:40,330 --> 00:17:43,120
you who have ever had to deal with a

00:17:41,740 --> 00:17:45,190
weird import problem because of the

00:17:43,120 --> 00:17:47,440
different VMS it should hopefully go all

00:17:45,190 --> 00:17:48,220
away in python 3.3 once they all support

00:17:47,440 --> 00:17:49,870
it

00:17:48,220 --> 00:17:52,210
it's also easier to customize and blah

00:17:49,870 --> 00:17:53,800
blah blah I got a talk on Sunday about

00:17:52,210 --> 00:17:56,680
how import works and I'll cover all this

00:17:53,800 --> 00:17:59,940
but basically if you do any fancy import

00:17:56,680 --> 00:17:59,940
stuff this make your lives a lot easier

00:18:00,490 --> 00:18:05,980
we also tweaked the import lock which

00:18:03,430 --> 00:18:07,840
any of you who had deadlock in threads

00:18:05,980 --> 00:18:10,540
doing imports on whatever you should be

00:18:07,840 --> 00:18:12,820
very happy now basically what happened

00:18:10,540 --> 00:18:15,280
is in Python 3.3 we added a fine-grained

00:18:12,820 --> 00:18:19,960
import lock per module instead of per

00:18:15,280 --> 00:18:22,420
process so what this means is previously

00:18:19,960 --> 00:18:24,700
if you did an import that some in

00:18:22,420 --> 00:18:26,140
trigger to thread as side-effect and

00:18:24,700 --> 00:18:28,300
then in that thread it did its own

00:18:26,140 --> 00:18:30,220
import that would deadlock the

00:18:28,300 --> 00:18:32,350
interpreter this could happen if for

00:18:30,220 --> 00:18:33,670
instance you imported a module it

00:18:32,350 --> 00:18:35,410
launched a thread and this thread called

00:18:33,670 --> 00:18:37,270
some code that in the meth in the

00:18:35,410 --> 00:18:38,590
function itself actually did an import

00:18:37,270 --> 00:18:40,900
and this can have been like in the OS

00:18:38,590 --> 00:18:42,370
module some of the functions now

00:18:40,900 --> 00:18:44,650
Westmarch will actually import things as

00:18:42,370 --> 00:18:47,800
a side effect of being called for

00:18:44,650 --> 00:18:49,600
start-up reasons this is a way with that

00:18:47,800 --> 00:18:54,760
problem so you will no longer get that

00:18:49,600 --> 00:18:57,910
deadlock excuse me the other side effect

00:18:54,760 --> 00:18:59,380
in perk of this is threads now block

00:18:57,910 --> 00:19:01,240
until they complete so if you have

00:18:59,380 --> 00:19:04,420
circular import problems it can possibly

00:19:01,240 --> 00:19:06,250
help because it allow modules to not be

00:19:04,420 --> 00:19:07,870
fully initialized to continue the import

00:19:06,250 --> 00:19:09,400
so as long as your dependencies don't

00:19:07,870 --> 00:19:11,350
fall in a certain way you have at least

00:19:09,400 --> 00:19:12,670
a chance for a circular import

00:19:11,350 --> 00:19:14,890
dependency to actually continue on and

00:19:12,670 --> 00:19:17,110
actually finish and actually succeed I

00:19:14,890 --> 00:19:18,310
doesn't solve it completely you might

00:19:17,110 --> 00:19:20,290
still have to restructure order and

00:19:18,310 --> 00:19:23,200
stuff to make circular imports work but

00:19:20,290 --> 00:19:27,520
at least it can help the key thing is no

00:19:23,200 --> 00:19:29,830
more dead locks an input the other thing

00:19:27,520 --> 00:19:32,050
in Python 3 I believe this is winning

00:19:29,830 --> 00:19:36,580
three point one or two I can't remember

00:19:32,050 --> 00:19:38,560
um is the under PI cache directory so

00:19:36,580 --> 00:19:40,000
I'm sure all of us are used to Python to

00:19:38,560 --> 00:19:42,100
where we end up with the directory that

00:19:40,000 --> 00:19:43,390
has a bunch of nice clean PI files and

00:19:42,100 --> 00:19:44,710
suddenly we run our code and something

00:19:43,390 --> 00:19:46,720
we've doubled the number of files we

00:19:44,710 --> 00:19:48,220
have today oh I see I know let's run

00:19:46,720 --> 00:19:50,110
with that show and now we've added

00:19:48,220 --> 00:19:52,750
another set so now we've got three times

00:19:50,110 --> 00:19:54,700
as many files in a directory I hate it

00:19:52,750 --> 00:19:56,470
I'm sure you all hate it it's not a

00:19:54,700 --> 00:19:58,000
problem anymore so in Python 3 what

00:19:56,470 --> 00:19:59,470
happens is all those files get dumped

00:19:58,000 --> 00:20:01,639
into a directory called under under PI

00:19:59,470 --> 00:20:03,829
cache now the really nice thing about

00:20:01,639 --> 00:20:08,359
this is every single WIC file now has a

00:20:03,829 --> 00:20:10,849
pre as a suffix of the interpreter and

00:20:08,359 --> 00:20:13,639
the version used for python so what this

00:20:10,849 --> 00:20:17,089
means is is for instance if your code

00:20:13,639 --> 00:20:19,609
runs on Python 3 Python 2 python

00:20:17,089 --> 00:20:20,599
bazillion and a half it will all go in

00:20:19,609 --> 00:20:22,609
the same directory and they won't

00:20:20,599 --> 00:20:24,049
overwrite each other right so you not

00:20:22,609 --> 00:20:25,820
only have to worry about other versions

00:20:24,049 --> 00:20:27,379
of Python running on that code and

00:20:25,820 --> 00:20:29,329
overwriting that py C file and having to

00:20:27,379 --> 00:20:30,529
regenerate every single time because

00:20:29,329 --> 00:20:32,959
you're running your tests or whatever

00:20:30,529 --> 00:20:34,279
and having to take that overhead the

00:20:32,959 --> 00:20:36,559
other nice thing is if you test against

00:20:34,279 --> 00:20:38,559
multiple VMs or something VMs can also

00:20:36,559 --> 00:20:40,609
write their own version of a WIC file

00:20:38,559 --> 00:20:41,809
and then take advantage of that and then

00:20:40,609 --> 00:20:45,079
once again it won't overwrite anyone

00:20:41,809 --> 00:20:48,529
else's code um you can still distribute

00:20:45,079 --> 00:20:51,200
only WIC without the source if you want

00:20:48,529 --> 00:20:52,639
to does this does not take that away I'm

00:20:51,200 --> 00:20:54,169
going to say unfortunately but I am

00:20:52,639 --> 00:20:56,359
biased and I really don't like that but

00:20:54,169 --> 00:20:57,559
teach their own but you can still do

00:20:56,359 --> 00:20:58,639
that and we did not take that away it

00:20:57,559 --> 00:21:01,039
just really keeps it's really nice to

00:20:58,639 --> 00:21:03,139
have just when you import all the code

00:21:01,039 --> 00:21:05,329
just have a new directory and then all

00:21:03,139 --> 00:21:06,950
your PI YC file all your not py files

00:21:05,329 --> 00:21:08,359
are just there and just the directory as

00:21:06,950 --> 00:21:10,399
I said instead of tripling the number of

00:21:08,359 --> 00:21:14,539
files potentially it makes a lot easier

00:21:10,399 --> 00:21:16,249
to work with a biggie that at least the

00:21:14,539 --> 00:21:18,889
links vendors have really been wanting

00:21:16,249 --> 00:21:21,889
our namespace packages this is new and

00:21:18,889 --> 00:21:23,419
python 3.3 basically if you have a

00:21:21,889 --> 00:21:27,889
directory that does not have an under

00:21:23,419 --> 00:21:30,320
under init file to define a package but

00:21:27,889 --> 00:21:32,479
the directory name matches what will

00:21:30,320 --> 00:21:34,519
happen is is that will get collected as

00:21:32,479 --> 00:21:36,169
a possible entry in a namespace package

00:21:34,519 --> 00:21:37,849
and then the search will continue

00:21:36,169 --> 00:21:39,739
through sis top path and what have you

00:21:37,849 --> 00:21:41,749
and it will just keep collecting

00:21:39,739 --> 00:21:43,789
directories that have that name as long

00:21:41,749 --> 00:21:45,950
as there's no under under in it file and

00:21:43,789 --> 00:21:48,190
at the end if no specific file has been

00:21:45,950 --> 00:21:50,450
found whether it's a need module or

00:21:48,190 --> 00:21:52,070
package with an under under net all

00:21:50,450 --> 00:21:53,719
those directories will get packaged up

00:21:52,070 --> 00:21:55,249
that'll get set as the under under path

00:21:53,719 --> 00:21:57,979
on a module and you'll now have a

00:21:55,249 --> 00:22:00,459
namespace package so the common examples

00:21:57,979 --> 00:22:02,479
let's say you have soap and you've got

00:22:00,459 --> 00:22:05,209
three different packages in three

00:22:02,479 --> 00:22:06,799
different directories well if you have

00:22:05,209 --> 00:22:08,869
them on three different directories but

00:22:06,799 --> 00:22:10,339
they all have a soap directory at the

00:22:08,869 --> 00:22:11,690
top right offices top ass

00:22:10,339 --> 00:22:12,919
those three directories will all get

00:22:11,690 --> 00:22:13,980
packaged up and they'll all become a

00:22:12,919 --> 00:22:16,770
single soap

00:22:13,980 --> 00:22:19,650
package so allow you to actually

00:22:16,770 --> 00:22:21,179
distribute your projects as separate

00:22:19,650 --> 00:22:23,520
things as long as they all have the same

00:22:21,179 --> 00:22:26,010
top level directory so you can divvy it

00:22:23,520 --> 00:22:27,690
up and ship three four five whatever

00:22:26,010 --> 00:22:29,130
packages everyone can sell them

00:22:27,690 --> 00:22:31,350
individually as long as that key top

00:22:29,130 --> 00:22:34,410
directory has no under under in it but

00:22:31,350 --> 00:22:35,669
that's what gets put on the syste Python

00:22:34,410 --> 00:22:38,240
three point three will collect them all

00:22:35,669 --> 00:22:42,990
up and treat them as a single package

00:22:38,240 --> 00:22:46,650
yeah it's a very very nice feature and

00:22:42,990 --> 00:22:50,250
the other nice thing is is if anything

00:22:46,650 --> 00:22:52,230
changes above it so this top path or the

00:22:50,250 --> 00:22:54,870
under path of a higher level package

00:22:52,230 --> 00:22:56,910
directory or package it'll actually be

00:22:54,870 --> 00:22:58,080
recalculate on-the-fly so you don't have

00:22:56,910 --> 00:23:01,559
to worry about if you suddenly add

00:22:58,080 --> 00:23:03,630
another entry into the parent package

00:23:01,559 --> 00:23:05,429
whether it's just a path or higher up in

00:23:03,630 --> 00:23:07,860
the package having that not get picked

00:23:05,429 --> 00:23:09,660
up and carried down through the packages

00:23:07,860 --> 00:23:13,830
itself it'll actually recalculate and

00:23:09,660 --> 00:23:15,120
dynamically start using it functions

00:23:13,830 --> 00:23:17,610
function has also got a nice bunch of

00:23:15,120 --> 00:23:19,830
updates in Python three one really

00:23:17,610 --> 00:23:21,720
fantastic thing I use constantly and I'm

00:23:19,830 --> 00:23:25,350
so glad we added were keyword only

00:23:21,720 --> 00:23:27,720
arguments so if you add an asterisk and

00:23:25,350 --> 00:23:30,120
nothing else and they had things

00:23:27,720 --> 00:23:33,059
afterwards or like star args then a

00:23:30,120 --> 00:23:34,799
comma and then some arguments those

00:23:33,059 --> 00:23:36,270
become keyword or only arguments which

00:23:34,799 --> 00:23:39,809
means you can only call them when you

00:23:36,270 --> 00:23:40,830
use their name in the function call this

00:23:39,809 --> 00:23:43,320
is fantastic

00:23:40,830 --> 00:23:45,630
for expanding pre-existing api's because

00:23:43,320 --> 00:23:47,100
the old way of let's say I take three

00:23:45,630 --> 00:23:48,510
arguments like bacon spam and then you

00:23:47,100 --> 00:23:49,740
want to add a different argument if you

00:23:48,510 --> 00:23:51,390
just tacked on different than the old

00:23:49,740 --> 00:23:52,559
way you could potentially call the

00:23:51,390 --> 00:23:53,640
function with three arguments by

00:23:52,559 --> 00:23:55,620
accident and not really is you're

00:23:53,640 --> 00:23:57,299
certainly turning some functionality on

00:23:55,620 --> 00:24:00,059
the new API because you suddenly set

00:23:57,299 --> 00:24:01,470
different you can't do that accidentally

00:24:00,059 --> 00:24:03,809
anymore you have to now say in a

00:24:01,470 --> 00:24:06,179
function call different equals true or

00:24:03,809 --> 00:24:08,220
false or four or whatever you want but

00:24:06,179 --> 00:24:09,690
you have to explicitly add it now so if

00:24:08,220 --> 00:24:10,620
you expand an epi now you can just say

00:24:09,690 --> 00:24:12,960
alright if you want to turn this new

00:24:10,620 --> 00:24:15,090
functionality you have to explicitly use

00:24:12,960 --> 00:24:17,220
a named argument no longer accidentally

00:24:15,090 --> 00:24:21,240
overflowing into some new argument by

00:24:17,220 --> 00:24:23,610
accident function annotations

00:24:21,240 --> 00:24:26,250
this basically as you take any parameter

00:24:23,610 --> 00:24:27,510
in a function and return value and kind

00:24:26,250 --> 00:24:30,380
of add an object

00:24:27,510 --> 00:24:32,940
acts as an annotation for that function

00:24:30,380 --> 00:24:36,480
lots of people think of this as a weight

00:24:32,940 --> 00:24:38,670
of adding type annotations for functions

00:24:36,480 --> 00:24:39,780
which you can do but it's not explicitly

00:24:38,670 --> 00:24:41,640
meant for that it's just a way to

00:24:39,780 --> 00:24:43,950
annotate things in any way possible

00:24:41,640 --> 00:24:46,080
it could be documentation it can be a

00:24:43,950 --> 00:24:47,880
type it could be whatever you want and

00:24:46,080 --> 00:24:50,220
actually the standard library explicitly

00:24:47,880 --> 00:24:51,420
does not use function annotations so

00:24:50,220 --> 00:24:52,560
that the community can decide however

00:24:51,420 --> 00:24:55,020
they want and they don't feel like

00:24:52,560 --> 00:24:56,250
you're being boxed dancing you have to

00:24:55,020 --> 00:24:59,370
use it for types or you have to use it

00:24:56,250 --> 00:25:01,530
for Docs or whatever actually putting

00:24:59,370 --> 00:25:03,360
code myself that you specify types and

00:25:01,530 --> 00:25:04,410
Ravin hedge or tuck it right out so

00:25:03,360 --> 00:25:07,470
you're not supposed to do that naughty

00:25:04,410 --> 00:25:09,480
Brett so do you do whatever you want

00:25:07,470 --> 00:25:10,380
with them but the kind of Handy and it's

00:25:09,480 --> 00:25:16,190
kind of a neat way to do in

00:25:10,380 --> 00:25:18,200
documentation signature objects okay

00:25:16,190 --> 00:25:21,890
this is my fault

00:25:18,200 --> 00:25:24,090
somewhat so these are new in Python 3.3

00:25:21,890 --> 00:25:28,140
basically it's an object representation

00:25:24,090 --> 00:25:30,230
of cobbles so any of you've ever used

00:25:28,140 --> 00:25:32,940
the inspect module and use like get full

00:25:30,230 --> 00:25:35,970
get full arcs back I think is

00:25:32,940 --> 00:25:37,740
functioning to try to query an object of

00:25:35,970 --> 00:25:39,480
callable to find out what are the

00:25:37,740 --> 00:25:42,540
arguments how many there are setter

00:25:39,480 --> 00:25:44,700
etcetera it gives you bunch of lists and

00:25:42,540 --> 00:25:46,530
tuples and stuff and it's not really

00:25:44,700 --> 00:25:48,630
easy to work with this gives you an

00:25:46,530 --> 00:25:50,250
actual object to query telling you all

00:25:48,630 --> 00:25:52,290
right here the number parameter

00:25:50,250 --> 00:25:53,490
positional arguments the number keyword

00:25:52,290 --> 00:25:55,740
only arguments here the default

00:25:53,490 --> 00:25:57,960
arguments here are the annotations

00:25:55,740 --> 00:26:00,360
etcetera etcetera etc it's much easier

00:25:57,960 --> 00:26:02,640
to work with it obviously only works

00:26:00,360 --> 00:26:05,280
with Python code although if Larry

00:26:02,640 --> 00:26:07,020
Hastings or another proposal gets into

00:26:05,280 --> 00:26:09,060
Python 3.4 we might actually be able to

00:26:07,020 --> 00:26:10,950
automatically generate this for G code

00:26:09,060 --> 00:26:12,540
and so this is make it really easy to

00:26:10,950 --> 00:26:14,010
query objects to figure out how good

00:26:12,540 --> 00:26:16,860
things bind how many arguments does this

00:26:14,010 --> 00:26:22,470
require and do a lot of dynamic call but

00:26:16,860 --> 00:26:24,180
building Unicode Unicode Unicode as I'm

00:26:22,470 --> 00:26:26,430
sure you all know the big big

00:26:24,180 --> 00:26:28,950
controversy in Python 3 was meeting

00:26:26,430 --> 00:26:30,510
everything worked with Unicode because

00:26:28,950 --> 00:26:33,270
we all love the world and we don't want

00:26:30,510 --> 00:26:36,420
to be exclusive to ask you but basically

00:26:33,270 --> 00:26:40,500
Unicode now pervades Python at every

00:26:36,420 --> 00:26:41,580
level you can think of unicode now

00:26:40,500 --> 00:26:44,310
exists while you go

00:26:41,580 --> 00:26:46,620
a skis no longer the defaults codec for

00:26:44,310 --> 00:26:51,000
code is now utf-8 and for those of you

00:26:46,620 --> 00:26:52,680
that are not coding in a language that

00:26:51,000 --> 00:26:54,720
can actually be represented by ASCII or

00:26:52,680 --> 00:26:58,470
such you can now use non ASCII

00:26:54,720 --> 00:27:00,210
identifiers so you can now code in not

00:26:58,470 --> 00:27:01,590
all of Unicode but a good chunk of it

00:27:00,210 --> 00:27:03,510
you have to read the pep to know the

00:27:01,590 --> 00:27:06,060
exact things because I'm not a Unicode

00:27:03,510 --> 00:27:08,190
expert so it's not all gampy but it's a

00:27:06,060 --> 00:27:10,760
good subset and chances are you can

00:27:08,190 --> 00:27:15,960
write in your native language now using

00:27:10,760 --> 00:27:17,190
identifiers that way we now obviously

00:27:15,960 --> 00:27:20,970
have multiple ways for you to specify a

00:27:17,190 --> 00:27:24,120
Unicode string literals in part 7 3.3 we

00:27:20,970 --> 00:27:29,400
actually added back in support for the u

00:27:24,120 --> 00:27:30,840
prefix yeah now you can add bits if we

00:27:29,400 --> 00:27:32,670
did this to make it easier to port code

00:27:30,840 --> 00:27:35,070
mainly so the idea is if you already

00:27:32,670 --> 00:27:37,260
have Python code in up to six to seven

00:27:35,070 --> 00:27:38,730
or whatever what you can do is prefix

00:27:37,260 --> 00:27:41,400
all your strings with you and then all

00:27:38,730 --> 00:27:42,570
your bike strings with B and now once

00:27:41,400 --> 00:27:44,280
you've got that all straightened out it

00:27:42,570 --> 00:27:45,360
can also run right through two thousand

00:27:44,280 --> 00:27:48,150
three point three and the meaning won't

00:27:45,360 --> 00:27:50,100
change the other thing is is some people

00:27:48,150 --> 00:27:52,500
really worry about this for performance

00:27:50,100 --> 00:27:55,860
so there's no kind of because of this

00:27:52,500 --> 00:27:58,110
three concepts of thrones there's a

00:27:55,860 --> 00:28:00,630
native string which has no label on it

00:27:58,110 --> 00:28:02,790
so in Python 2.7 it'll be the stur type

00:28:00,630 --> 00:28:04,110
and in Python 3 point 3 is the ster type

00:28:02,790 --> 00:28:06,780
so it's just whatever the native ster

00:28:04,110 --> 00:28:09,720
type is you should only use that though

00:28:06,780 --> 00:28:11,370
if you can guarantee 100% and swear on

00:28:09,720 --> 00:28:13,680
your own children's mother's

00:28:11,370 --> 00:28:15,930
grandparents lives that it stays ASCII

00:28:13,680 --> 00:28:17,160
and then you're okay otherwise you're

00:28:15,930 --> 00:28:20,970
going to shoot yourself in the foot and

00:28:17,160 --> 00:28:23,010
I'm serious being really don't just

00:28:20,970 --> 00:28:24,660
assume this is how people get shot in

00:28:23,010 --> 00:28:26,490
the foot when they try to port code if

00:28:24,660 --> 00:28:29,070
you can guarantee it'll say ASCII you

00:28:26,490 --> 00:28:31,260
can leave off the label if not you

00:28:29,070 --> 00:28:32,790
should use the U prefix if you're only

00:28:31,260 --> 00:28:34,500
talking to you for n3 and later you can

00:28:32,790 --> 00:28:36,000
do that and your 2.7 code at least in

00:28:34,500 --> 00:28:38,280
terms of string literals we'll just go

00:28:36,000 --> 00:28:41,010
ahead and work between 2.7 3.3 and

00:28:38,280 --> 00:28:43,230
obviously the B prefix for getting your

00:28:41,010 --> 00:28:45,300
bytes literal and then of course there's

00:28:43,230 --> 00:28:46,590
always the under future import Unicode

00:28:45,300 --> 00:28:48,750
literals if you don't want to worry

00:28:46,590 --> 00:28:52,170
about that and just assume all non-b

00:28:48,750 --> 00:28:53,340
prefix strings are unicode as i said

00:28:52,170 --> 00:28:54,600
this is the biggest hurdle people tend

00:28:53,340 --> 00:28:54,960
to run into if you've been a little

00:28:54,600 --> 00:28:57,330
sloppy

00:28:54,960 --> 00:28:59,910
with what Speights versus strings if you

00:28:57,330 --> 00:29:03,150
haven't been it's really not that hard I

00:28:59,910 --> 00:29:07,440
know that's kind of the rumor out on the

00:29:03,150 --> 00:29:09,750
internet but their nets wrong which we

00:29:07,440 --> 00:29:10,950
all know happens as long as you've been

00:29:09,750 --> 00:29:12,570
very clear about glinting what is

00:29:10,950 --> 00:29:14,910
strings and water bytes it's not a big

00:29:12,570 --> 00:29:16,830
thing but if you not worried about that

00:29:14,910 --> 00:29:19,290
because you could get away with it that

00:29:16,830 --> 00:29:20,730
will bite you in the bump but just be

00:29:19,290 --> 00:29:24,300
clearing your api's and what is what and

00:29:20,730 --> 00:29:26,450
you'll be fine and you get better

00:29:24,300 --> 00:29:28,770
Unicode use during execution on Python

00:29:26,450 --> 00:29:32,430
we now internally source strings is

00:29:28,770 --> 00:29:34,440
either latin-1 utf-16 or utf-32 and what

00:29:32,430 --> 00:29:37,200
this means is no more narrow versus wide

00:29:34,440 --> 00:29:39,840
built yes exactly the extension

00:29:37,200 --> 00:29:42,180
developers know I'm talking about so you

00:29:39,840 --> 00:29:44,970
only need one build and I'll cover any

00:29:42,180 --> 00:29:48,180
Unicode character add with that the

00:29:44,970 --> 00:29:52,140
stable ABI you can now do one compile

00:29:48,180 --> 00:29:54,540
for Python three and four these four 3.3

00:29:52,140 --> 00:29:56,730
and farther you only do it once per OS

00:29:54,540 --> 00:29:58,110
and as long as nothing shifts in terms

00:29:56,730 --> 00:29:59,430
what your needs you don't have to

00:29:58,110 --> 00:30:03,590
recompile for every single version of

00:29:59,430 --> 00:30:07,170
Python thereafter it's very nice

00:30:03,590 --> 00:30:10,860
so that's a big thing you can also save

00:30:07,170 --> 00:30:12,870
my memory doing this so when Martin

00:30:10,860 --> 00:30:15,120
fellows did this work he used a jingo

00:30:12,870 --> 00:30:18,390
benchmark that if you use an arrow build

00:30:15,120 --> 00:30:21,540
compared to 2.7 Python 3.3 used a little

00:30:18,390 --> 00:30:24,330
less than 8% more memory but if used a

00:30:21,540 --> 00:30:28,050
wide build Python 3.3 was actually

00:30:24,330 --> 00:30:30,270
smaller by over 9% so if you're doing

00:30:28,050 --> 00:30:31,770
internal internationalized code where

00:30:30,270 --> 00:30:33,780
you need to care about Unicode usage

00:30:31,770 --> 00:30:35,160
you'll probably get a lot more you'll

00:30:33,780 --> 00:30:37,050
actually save memory if you switch to

00:30:35,160 --> 00:30:38,370
Python 3 point 3 so if you know as

00:30:37,050 --> 00:30:40,530
python 3 point 3 has a lot of stuff

00:30:38,370 --> 00:30:43,800
added to help help you with memory usage

00:30:40,530 --> 00:30:45,750
such as the key sharing in this so if

00:30:43,800 --> 00:30:50,280
you've been having memory issues python

00:30:45,750 --> 00:30:57,030
3.3 will help you with that okay the big

00:30:50,280 --> 00:31:00,060
thing who's faster so obviously a big

00:30:57,030 --> 00:31:02,430
question everyone asks so I ran my own

00:31:00,060 --> 00:31:04,770
benchmarks basically I checked out the

00:31:02,430 --> 00:31:09,150
code on the same day I've compiled 2.7

00:31:04,770 --> 00:31:10,980
3.3 right off right off pythons trunk

00:31:09,150 --> 00:31:11,970
I could download the binaries bars so

00:31:10,980 --> 00:31:14,400
you're going to end up wearing the exact

00:31:11,970 --> 00:31:17,610
same code that is so I didn't want to do

00:31:14,400 --> 00:31:20,720
it because I'm lazy I did use a wide

00:31:17,610 --> 00:31:23,220
build because that equals out the

00:31:20,720 --> 00:31:27,090
abilities if you don't like that

00:31:23,220 --> 00:31:28,260
tough so the results are all relative

00:31:27,090 --> 00:31:29,750
between two binaries because they use

00:31:28,260 --> 00:31:32,790
them Layton swallow benchmark suite

00:31:29,750 --> 00:31:34,890
which is part of this work I also merged

00:31:32,790 --> 00:31:36,240
in the pipe I benchmark suite and move

00:31:34,890 --> 00:31:38,940
to name benchmarks as I could over to

00:31:36,240 --> 00:31:41,460
Python 3 some of the benchmarks I used

00:31:38,940 --> 00:31:44,250
aren't public in the a million swallow

00:31:41,460 --> 00:31:45,990
benchmark suite because I use libraries

00:31:44,250 --> 00:31:48,740
that have not released Python 3 support

00:31:45,990 --> 00:31:51,150
yet but it's in their trunk code I

00:31:48,740 --> 00:31:52,020
believe like HTML 5 libs supports it in

00:31:51,150 --> 00:31:56,760
trunk but they have a tunnel release

00:31:52,020 --> 00:31:57,900
with it but I included it all here so

00:31:56,760 --> 00:31:59,610
that's how I did the benchmarking for

00:31:57,900 --> 00:32:01,890
these numbers you can reproduce if you

00:31:59,610 --> 00:32:04,830
want but basically if you sorted all the

00:32:01,890 --> 00:32:09,030
benchmarks and took the median they're

00:32:04,830 --> 00:32:11,059
exactly the same which is fantastic I

00:32:09,030 --> 00:32:11,059
think

00:32:13,570 --> 00:32:18,770
now this actually sped up when I did

00:32:16,250 --> 00:32:21,380
this for pike on Argentina Python three

00:32:18,770 --> 00:32:23,840
point three was five percent slower but

00:32:21,380 --> 00:32:25,070
if you track down Thomas waters he can

00:32:23,840 --> 00:32:28,910
tell you he did some experiments at

00:32:25,070 --> 00:32:30,590
Google where basically five percent you

00:32:28,910 --> 00:32:33,170
can get with just tweaking how you

00:32:30,590 --> 00:32:34,820
compiler runs easily so it's still

00:32:33,170 --> 00:32:37,100
complete within the realm of just

00:32:34,820 --> 00:32:38,660
compiler flags so it's a wash

00:32:37,100 --> 00:32:40,280
basically now you might be saying oh

00:32:38,660 --> 00:32:42,080
median who cares you got all these other

00:32:40,280 --> 00:32:44,750
benchmarks it might not equal out well

00:32:42,080 --> 00:32:47,920
I'll get to that but to be upfront the

00:32:44,750 --> 00:32:51,560
slowest benchmark is start up with - s

00:32:47,920 --> 00:32:53,120
it's 73 percent slower now this is

00:32:51,560 --> 00:32:56,300
actually faster than it was in Python

00:32:53,120 --> 00:32:58,910
3.2 one of the perks of import live is

00:32:56,300 --> 00:33:00,890
it caches some things in terms of stack

00:32:58,910 --> 00:33:03,380
calls and such so it's actually start up

00:33:00,890 --> 00:33:04,880
faster than 3.2 but because unicode now

00:33:03,380 --> 00:33:06,770
pervades everything there's a lot more

00:33:04,880 --> 00:33:10,460
to import important coatings and all

00:33:06,770 --> 00:33:12,710
this other stuff so it starts up slower

00:33:10,460 --> 00:33:16,730
I'm hoping for Python 3.4 devil look at

00:33:12,710 --> 00:33:19,400
this but that is the slowest bit telco

00:33:16,730 --> 00:33:21,830
which uses decimal is forty six point

00:33:19,400 --> 00:33:23,810
nine six times faster that's not forty

00:33:21,830 --> 00:33:26,360
six percent that's forty six times I was

00:33:23,810 --> 00:33:30,980
not kidding the C new severs a decimal

00:33:26,360 --> 00:33:33,440
is extremely fast here all the

00:33:30,980 --> 00:33:36,260
benchmarks except for the two extremes

00:33:33,440 --> 00:33:40,100
to keep the scale reasonable sorted and

00:33:36,260 --> 00:33:42,650
as you can see it's close to being just

00:33:40,100 --> 00:33:44,870
split down the middle it's it really

00:33:42,650 --> 00:33:45,710
just you can choose one benchmark and I

00:33:44,870 --> 00:33:47,360
can show you another one on the other

00:33:45,710 --> 00:33:49,930
side that's faster or slower it's just

00:33:47,360 --> 00:33:52,310
like it really just is a complete wash

00:33:49,930 --> 00:33:53,780
if you want to be picky zeg all right

00:33:52,310 --> 00:33:55,730
those increase micro benchmarks what

00:33:53,780 --> 00:33:57,880
about real-world stuff well here are the

00:33:55,730 --> 00:34:00,290
macro benchmarks in the benchmark suite

00:33:57,880 --> 00:34:02,870
you can have one like path lab which is

00:34:00,290 --> 00:34:04,640
really slow though admittedly it doesn't

00:34:02,870 --> 00:34:06,440
want more Python 3 because of extra

00:34:04,640 --> 00:34:10,399
support in the West module and such so

00:34:06,440 --> 00:34:12,740
analyst 10 on top of it but like Makos

00:34:10,399 --> 00:34:15,440
real and kimchi's real jane goes there

00:34:12,740 --> 00:34:18,169
on one point 5.0 and it's only 5% slower

00:34:15,440 --> 00:34:21,110
as I said 5% is within compiler flags

00:34:18,169 --> 00:34:23,659
but then html5 Lib 2 to 3 and chameleon

00:34:21,110 --> 00:34:27,230
all run faster and python 3.3 by a good

00:34:23,659 --> 00:34:29,570
amount right I mean that's 12% so really

00:34:27,230 --> 00:34:30,800
you can argue based on your load it's

00:34:29,570 --> 00:34:32,659
going to be faster or slower but either

00:34:30,800 --> 00:34:35,060
way chances are faster slower within

00:34:32,659 --> 00:34:39,079
spitting distance so it really is not a

00:34:35,060 --> 00:34:41,599
big thing and these numbers have

00:34:39,079 --> 00:34:44,060
actually improved as I said when I did

00:34:41,599 --> 00:34:46,429
this for pike on Argentina basically the

00:34:44,060 --> 00:34:47,990
exact same it's just gotten a little

00:34:46,429 --> 00:34:49,159
faster for Python three point three so

00:34:47,990 --> 00:34:51,050
this is not going to get worse it's just

00:34:49,159 --> 00:34:53,899
going to get better so performance is

00:34:51,050 --> 00:34:54,950
really not a problem and with that you

00:34:53,899 --> 00:34:57,129
can stare at my cat while I take

00:34:54,950 --> 00:34:57,129
questions

00:34:57,240 --> 00:35:01,750
[Applause]

00:35:05,350 --> 00:35:13,370
yes I think their mics yeah

00:35:10,750 --> 00:35:18,080
there's the mic there do we have any

00:35:13,370 --> 00:35:26,080
other mics set the one mic okay I just

00:35:18,080 --> 00:35:26,080
keep my neck craned to the right so

00:35:30,230 --> 00:35:36,390
hello okay how does super work without

00:35:34,710 --> 00:35:38,400
arguments isn't magic like how does it

00:35:36,390 --> 00:35:42,210
know what it's referring to it's pixie

00:35:38,400 --> 00:35:43,440
dust um basically so the question is how

00:35:42,210 --> 00:35:45,360
does super with no arguments actually

00:35:43,440 --> 00:35:46,940
work technically under the hood

00:35:45,360 --> 00:35:48,570
basically what happens is we cache

00:35:46,940 --> 00:35:51,810
specifically what the arguments would

00:35:48,570 --> 00:35:53,700
have been in the basically the closure

00:35:51,810 --> 00:35:57,360
space of that function and we just

00:35:53,700 --> 00:36:01,890
magically just add it so yes it's kind

00:35:57,360 --> 00:36:04,200
of magic over now the dictionaries share

00:36:01,890 --> 00:36:06,720
keys huh is that using in turn under the

00:36:04,200 --> 00:36:08,130
hood the big question is do they

00:36:06,720 --> 00:36:09,930
disappear when the ref count drops to

00:36:08,130 --> 00:36:11,730
zero or do they stay in the in turn no

00:36:09,930 --> 00:36:13,110
this Disney this is not tweaking turning

00:36:11,730 --> 00:36:14,940
so in turn sticks around and all that

00:36:13,110 --> 00:36:16,430
it's just the way the keys point to

00:36:14,940 --> 00:36:19,050
things in such in the struct underneath

00:36:16,430 --> 00:36:20,730
are a lot smaller and lot simpler and

00:36:19,050 --> 00:36:22,650
just do a lot more indirection

00:36:20,730 --> 00:36:27,450
okay if you want the real details ask

00:36:22,650 --> 00:36:31,140
mark Shannon he wrote it okay anyone

00:36:27,450 --> 00:36:33,630
else or did I sell Python that well all

00:36:31,140 --> 00:36:36,630
right well okay I do have one more if no

00:36:33,630 --> 00:36:40,020
one else has one they're going um so the

00:36:36,630 --> 00:36:42,480
yield from supposing I wanted to yield

00:36:40,020 --> 00:36:44,580
ten from something like the next ten

00:36:42,480 --> 00:36:47,340
from this generator I normally would

00:36:44,580 --> 00:36:49,680
make a loop range ten and yield that

00:36:47,340 --> 00:36:51,030
many times we want to strict it to only

00:36:49,680 --> 00:36:52,830
ten where it could be potentially more

00:36:51,030 --> 00:36:54,480
right yeah you'll from won't help you

00:36:52,830 --> 00:36:56,220
with that case what's that you'll run

00:36:54,480 --> 00:36:58,020
will not allow you to specify that it's

00:36:56,220 --> 00:37:00,810
yield completely until exhaustion

00:36:58,020 --> 00:37:02,340
there's no much less Philemon I have

00:37:00,810 --> 00:37:05,160
another one too sure

00:37:02,340 --> 00:37:09,630
so one of the big no no's in Python 3

00:37:05,160 --> 00:37:11,520
was I think it was Python 3 was you

00:37:09,630 --> 00:37:15,270
cannot rear A's an exception from

00:37:11,520 --> 00:37:16,770
outside of the except block is that

00:37:15,270 --> 00:37:21,030
something that you can now do with that

00:37:16,770 --> 00:37:23,490
under under context alright don't know

00:37:21,030 --> 00:37:26,480
I've never done it ok do it give it a

00:37:23,490 --> 00:37:26,480
shot let me know I will

00:37:27,990 --> 00:37:33,120
after virtualenv is there a plan to add

00:37:31,530 --> 00:37:35,610
one of the installers people is

00:37:33,120 --> 00:37:37,080
installed also know you can talk to Nick

00:37:35,610 --> 00:37:38,670
Coughlin but specifically no we have

00:37:37,080 --> 00:37:39,840
absolutely zero plans to do that we're

00:37:38,670 --> 00:37:41,820
actually going to clean it up such that

00:37:39,840 --> 00:37:42,099
you have a dead simple Installer to make

00:37:41,820 --> 00:37:44,200
it

00:37:42,099 --> 00:37:45,999
to get pip or build-out or bent or

00:37:44,200 --> 00:37:48,369
whatever builder install you want and

00:37:45,999 --> 00:37:50,499
you just run run with them we've

00:37:48,369 --> 00:37:51,460
realized we are not the best people to

00:37:50,499 --> 00:37:53,680
manage this it's better let the

00:37:51,460 --> 00:37:56,170
ecosystem choose and grow and go faster

00:37:53,680 --> 00:38:02,650
than the side Lib so no we're not going

00:37:56,170 --> 00:38:04,749
down that road one quick piece came up

00:38:02,650 --> 00:38:06,279
before is help going to start using the

00:38:04,749 --> 00:38:08,410
new signature soon because right now

00:38:06,279 --> 00:38:11,470
help ignores when you set reset

00:38:08,410 --> 00:38:12,940
signatures ah it can there's no specific

00:38:11,470 --> 00:38:13,930
rewards it can't so much this house

00:38:12,940 --> 00:38:19,359
right the code okay

00:38:13,930 --> 00:38:21,579
yeah patches welcome exactly okay sorry

00:38:19,359 --> 00:38:23,829
yeah classic mistake I make it with

00:38:21,579 --> 00:38:25,059
using source control is I remove a

00:38:23,829 --> 00:38:26,920
directory and then I change to a

00:38:25,059 --> 00:38:28,839
different branch and I run it and I'll

00:38:26,920 --> 00:38:31,269
keep the pyc files around and I'll

00:38:28,839 --> 00:38:33,460
import a module that's the py file is in

00:38:31,269 --> 00:38:35,619
there PI caches will check write free

00:38:33,460 --> 00:38:37,239
existence of the py file and clear out

00:38:35,619 --> 00:38:39,130
and get solve all my problems I had the

00:38:37,239 --> 00:38:40,479
py file has to exist and then the old py

00:38:39,130 --> 00:38:41,109
C files will just sit there and nothing

00:38:40,479 --> 00:38:43,630
will happen to him

00:38:41,109 --> 00:38:45,460
second question do py C files really

00:38:43,630 --> 00:38:48,910
help because they're always a problem

00:38:45,460 --> 00:38:51,460
like they helped some basically they

00:38:48,910 --> 00:38:53,589
save you the the parse and the ast

00:38:51,460 --> 00:38:55,359
compilation step and that's roughly it

00:38:53,589 --> 00:38:57,969
so there's definitely help it I mean it

00:38:55,359 --> 00:39:01,809
kind of depends on your situation but ya

00:38:57,969 --> 00:39:04,630
know they're definitely awful with the

00:39:01,809 --> 00:39:06,549
metaclass keyword being added as a class

00:39:04,630 --> 00:39:09,519
keyword instead of doe underbar medical

00:39:06,549 --> 00:39:12,219
asks is there any way of backwards like

00:39:09,519 --> 00:39:13,390
adding to the futures module for 2.7 so

00:39:12,219 --> 00:39:14,739
that we could actually have metaclasses

00:39:13,390 --> 00:39:19,140
the keyword there because I have to

00:39:14,739 --> 00:39:23,109
maintain to do different core bases I I

00:39:19,140 --> 00:39:25,210
think there is a if there no there's

00:39:23,109 --> 00:39:27,400
what the six package there's the six

00:39:25,210 --> 00:39:29,049
pack project has a way to deal with meta

00:39:27,400 --> 00:39:31,299
classes I don't know how they get around

00:39:29,049 --> 00:39:32,619
it I think you have to inherit from a

00:39:31,299 --> 00:39:34,509
specific class and then they do the

00:39:32,619 --> 00:39:36,460
right thing under the hood so if you

00:39:34,509 --> 00:39:37,599
need help porting I should mention if

00:39:36,460 --> 00:39:39,489
you need help porting there's going to

00:39:37,599 --> 00:39:42,789
be a porting clinic Saturday and Sunday

00:39:39,489 --> 00:39:44,710
being run by Barry Wausau and yarko

00:39:42,789 --> 00:39:45,460
where you can get some help from them

00:39:44,710 --> 00:39:47,079
and some other people who have

00:39:45,460 --> 00:39:49,239
experience on the by answer questions

00:39:47,079 --> 00:39:51,969
but one things I'll probably suggest is

00:39:49,239 --> 00:39:54,130
use the six project and it has hoping

00:39:51,969 --> 00:39:55,910
there to help you do a common way to do

00:39:54,130 --> 00:40:00,680
meta classes but

00:39:55,910 --> 00:40:02,269
between the two anywhere else all right

00:40:00,680 --> 00:40:03,500
well I'm tall I'm sure you can see me

00:40:02,269 --> 00:40:06,170
around the conference feel free to stop

00:40:03,500 --> 00:40:09,420
me ask questions and thanks everyone

00:40:06,170 --> 00:40:09,420

YouTube URL: https://www.youtube.com/watch?v=f_6vDi7ywuA


