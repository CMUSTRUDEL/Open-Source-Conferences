Title: Talk: Łukasz Langa - AsyncIO + Music
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Łukasz Langa

Can Python help a musician play hardware instruments? Is there anything specific about AsyncIO that makes it well suited to the task? Come see how AsyncIO can be used to aid music production and realtime performance through MIDI processing.

We will cover transformations of incoming MIDI signal, driving hardware instruments with a shared clock, as well as generative music. All production-grade.

If you’re curious about AsyncIO and wanted to see it in action in a unique setting, this talk is for you! Music theory knowledge not required.
Captions: 
	00:00:12,520 --> 00:00:15,990
[Music]

00:00:12,870 --> 00:00:15,990
[Applause]

00:00:17,560 --> 00:00:21,779
[Music]

00:00:18,510 --> 00:00:21,779
[Applause]

00:00:42,030 --> 00:00:46,930
hi my name is mukesh lanka and what

00:00:44,770 --> 00:00:49,450
you've just heard were too hard with

00:00:46,930 --> 00:00:51,730
synthesizers being played by a sink I oh

00:00:49,450 --> 00:00:54,250
I was just twiddling some knobs to make

00:00:51,730 --> 00:00:55,780
this maybe a bit more interesting I come

00:00:54,250 --> 00:00:57,879
from Poznan Poland

00:00:55,780 --> 00:01:00,010
friendly city in Central Europe come

00:00:57,879 --> 00:01:01,720
visit when all of this is over it's

00:01:00,010 --> 00:01:03,190
located very close to Berlin now so

00:01:01,720 --> 00:01:05,470
Warsaw I think the connections are

00:01:03,190 --> 00:01:07,330
pretty good in the meantime feel free to

00:01:05,470 --> 00:01:09,640
reach out to me online to talk about

00:01:07,330 --> 00:01:12,130
Python music production role-playing

00:01:09,640 --> 00:01:14,800
games or muscle cars this picture is

00:01:12,130 --> 00:01:18,580
from back when we still had her stylists

00:01:14,800 --> 00:01:21,670
crazy times busy times today though

00:01:18,580 --> 00:01:24,040
we're gonna discover how async iro can

00:01:21,670 --> 00:01:27,820
be used to process MIDI to drive

00:01:24,040 --> 00:01:30,009
hardware synthesizers and to make things

00:01:27,820 --> 00:01:32,860
a little more interesting we're gonna do

00:01:30,009 --> 00:01:34,450
a life or we were supposed to do a life

00:01:32,860 --> 00:01:36,210
but now you're on YouTube watching this

00:01:34,450 --> 00:01:39,940
video so to keep things interesting

00:01:36,210 --> 00:01:41,560
we're gonna do it from scratch so we're

00:01:39,940 --> 00:01:43,360
going to talk about synthesizers there's

00:01:41,560 --> 00:01:45,430
very many kinds of them this particular

00:01:43,360 --> 00:01:47,979
one is a modular synthesizer meaning it

00:01:45,430 --> 00:01:51,550
consists of many independent modules

00:01:47,979 --> 00:01:53,890
connected together by wires every single

00:01:51,550 --> 00:01:55,840
module has a very specific role and

00:01:53,890 --> 00:01:58,440
connecting all of them together creates

00:01:55,840 --> 00:02:00,970
unique instruments this probably no to

00:01:58,440 --> 00:02:03,849
Joule synthesizers are exactly the same

00:02:00,970 --> 00:02:06,700
and the two modules that you can see on

00:02:03,849 --> 00:02:08,530
the bottom are produced by Moog some of

00:02:06,700 --> 00:02:10,959
the modules on the top were either

00:02:08,530 --> 00:02:12,910
bought or assembled by me and the

00:02:10,959 --> 00:02:16,030
ornament and crime in particular with a

00:02:12,910 --> 00:02:18,459
nice squiggly LCD screen runs a filmer

00:02:16,030 --> 00:02:20,590
that I modified myself so it's actually

00:02:18,459 --> 00:02:24,010
a very interesting hobby for programmers

00:02:20,590 --> 00:02:28,300
because you have very low level very end

00:02:24,010 --> 00:02:30,700
to end kind of influence on what the

00:02:28,300 --> 00:02:32,980
music is going to sound like before we

00:02:30,700 --> 00:02:35,470
get to this kind of advanced stuff

00:02:32,980 --> 00:02:37,420
though let's focus on a different kind

00:02:35,470 --> 00:02:40,660
of instrument what we're going to use

00:02:37,420 --> 00:02:43,150
today is an ovation circuit it's a

00:02:40,660 --> 00:02:46,930
groove box meaning it is an entire small

00:02:43,150 --> 00:02:49,959
music studio all on its own you can

00:02:46,930 --> 00:02:53,079
create full musical two Tunes just with

00:02:49,959 --> 00:02:55,250
this particular piece of hardware but

00:02:53,079 --> 00:02:58,790
its production grade actual musicians do

00:02:55,250 --> 00:03:00,830
this do use it for live acts and in fact

00:02:58,790 --> 00:03:02,990
innovation hardware is being used by FX

00:03:00,830 --> 00:03:05,060
to end so this is legit but at the same

00:03:02,990 --> 00:03:06,590
time it is a very fun instrument what

00:03:05,060 --> 00:03:08,810
you can do with it is you can take it

00:03:06,590 --> 00:03:11,420
anywhere you like it actually runs on

00:03:08,810 --> 00:03:13,250
batteries as well as has its own puny

00:03:11,420 --> 00:03:15,050
speaker so you really don't need

00:03:13,250 --> 00:03:17,780
anything else than just the circuit to

00:03:15,050 --> 00:03:21,380
make music for today we're gonna be

00:03:17,780 --> 00:03:23,840
using this groov box as a drum machine

00:03:21,380 --> 00:03:26,660
but it will be a bit boring to just have

00:03:23,840 --> 00:03:29,720
drums a drum sounds in our presentation

00:03:26,660 --> 00:03:31,760
so we're also going to use the Novation

00:03:29,720 --> 00:03:34,220
circuit mono station this is a

00:03:31,760 --> 00:03:37,489
monophonic analog bass synthesizer and

00:03:34,220 --> 00:03:39,680
what that means it's it plays bass low

00:03:37,489 --> 00:03:42,440
frequency sounds it is monophonic

00:03:39,680 --> 00:03:44,390
meaning it plays one sound at a time

00:03:42,440 --> 00:03:47,090
and it's analog meaning there is

00:03:44,390 --> 00:03:49,010
literally an electric oscillator that

00:03:47,090 --> 00:03:51,530
creates sound that through some path

00:03:49,010 --> 00:03:55,310
that we can control with the knobs ends

00:03:51,530 --> 00:03:58,100
up in your speaker so having an analog

00:03:55,310 --> 00:04:00,290
electric synthesizer makes it imperfect

00:03:58,100 --> 00:04:03,080
it is vulnerable to changes in

00:04:00,290 --> 00:04:05,090
temperature and humidity there is always

00:04:03,080 --> 00:04:07,489
some electric and magnetic bleed-through

00:04:05,090 --> 00:04:09,950
between the different electric circuits

00:04:07,489 --> 00:04:12,350
that are in a synthesizer like this so

00:04:09,950 --> 00:04:15,200
it's imperfect but that's actually a

00:04:12,350 --> 00:04:17,419
good thing very often people like analog

00:04:15,200 --> 00:04:20,090
synthesizers specifically for their

00:04:17,419 --> 00:04:22,370
warmth and richness of the sound which

00:04:20,090 --> 00:04:25,760
is created with this you know kind of

00:04:22,370 --> 00:04:27,979
inherent randomness of the environment

00:04:25,760 --> 00:04:29,900
you're in so we're gonna be using those

00:04:27,979 --> 00:04:32,300
two and they're gonna provide us with

00:04:29,900 --> 00:04:33,979
plenty of musical opportunities already

00:04:32,300 --> 00:04:35,630
there's gonna be a drum machine and a

00:04:33,979 --> 00:04:36,530
bass synthesizer drum and bass even

00:04:35,630 --> 00:04:37,760
though we're not going to be

00:04:36,530 --> 00:04:40,640
particularly interested in that

00:04:37,760 --> 00:04:43,850
particular music genre so I was ready to

00:04:40,640 --> 00:04:45,680
present all of this to you live but it

00:04:43,850 --> 00:04:48,970
turns out since this is impossible I

00:04:45,680 --> 00:04:52,400
need to record the video now and this is

00:04:48,970 --> 00:04:54,890
what I am looking at right now so the

00:04:52,400 --> 00:04:57,860
entire setup to make a video is quite

00:04:54,890 --> 00:04:59,330
different from just giving a talk I was

00:04:57,860 --> 00:05:02,419
surprised to discover that it is

00:04:59,330 --> 00:05:04,789
actually quite a more work to do this

00:05:02,419 --> 00:05:07,250
effectively and kind of you have higher

00:05:04,789 --> 00:05:08,380
expectations for yourself in terms of a

00:05:07,250 --> 00:05:10,480
delivery as well

00:05:08,380 --> 00:05:13,390
one of the things I planned for the

00:05:10,480 --> 00:05:17,970
presentation but I decided not to overdo

00:05:13,390 --> 00:05:21,670
was to make a little intro to async IO

00:05:17,970 --> 00:05:24,130
like while doing all this however it

00:05:21,670 --> 00:05:26,830
turns out that that would be rushing

00:05:24,130 --> 00:05:28,660
through things and I wouldn't be very

00:05:26,830 --> 00:05:30,910
satisfied with this and neither would

00:05:28,660 --> 00:05:33,130
you if you are you to async IO you would

00:05:30,910 --> 00:05:35,680
feel like that way that went way too

00:05:33,130 --> 00:05:37,900
fast like it explains very little so

00:05:35,680 --> 00:05:40,990
instead what I'm suggesting you do is

00:05:37,900 --> 00:05:43,540
you can direct yourself to the edge DPS

00:05:40,990 --> 00:05:46,120
our YouTube channel where we created a

00:05:43,540 --> 00:05:50,200
series of videos that introduce async IO

00:05:46,120 --> 00:05:52,780
in our manner that is catered towards

00:05:50,200 --> 00:05:55,720
people who are new to both async IO and

00:05:52,780 --> 00:05:57,670
asynchronous programming so it takes its

00:05:55,720 --> 00:06:01,270
time there's multiple episodes that go

00:05:57,670 --> 00:06:03,610
through all sorts of parts of the

00:06:01,270 --> 00:06:06,580
Eastern Kyoto both framework and the

00:06:03,610 --> 00:06:09,670
style of programming that it encourages

00:06:06,580 --> 00:06:12,280
that it supports so to subscribe just go

00:06:09,670 --> 00:06:14,490
to hp.com slash YouTube you can watch

00:06:12,280 --> 00:06:17,320
some of those videos there already I

00:06:14,490 --> 00:06:19,960
highly highly encourage you to do so

00:06:17,320 --> 00:06:21,820
like right now if you haven't seen a

00:06:19,960 --> 00:06:23,440
single yet you can just pause this video

00:06:21,820 --> 00:06:26,350
right thank you know that's one

00:06:23,440 --> 00:06:29,140
advantage of doing it this way in the

00:06:26,350 --> 00:06:33,880
meantime if you already use async IO or

00:06:29,140 --> 00:06:36,670
let me just do a very quick recap so we

00:06:33,880 --> 00:06:38,890
are using coroutines in async IO which

00:06:36,670 --> 00:06:41,350
behave pretty much like regular

00:06:38,890 --> 00:06:43,570
functions you can read them from top to

00:06:41,350 --> 00:06:45,820
bottom and they execute instructions a

00:06:43,570 --> 00:06:48,340
very special instruction that we see is

00:06:45,820 --> 00:06:50,740
the await instruction that means we're

00:06:48,340 --> 00:06:54,190
waiting for something external and in

00:06:50,740 --> 00:06:56,800
this time Python is able to use that

00:06:54,190 --> 00:06:58,600
time to do something else you know in

00:06:56,800 --> 00:07:01,720
the meantime done now that we're still

00:06:58,600 --> 00:07:03,460
waiting so coatings compose together in

00:07:01,720 --> 00:07:05,500
what is called cooperative multitasking

00:07:03,460 --> 00:07:07,360
and thanks to this

00:07:05,500 --> 00:07:09,910
thanks to this availability in this

00:07:07,360 --> 00:07:12,130
particular slide you see that we can

00:07:09,910 --> 00:07:14,170
await on async I'll sleep however the

00:07:12,130 --> 00:07:16,180
main core routine still says how it go

00:07:14,170 --> 00:07:19,650
back 1 how it all back to how it go back

00:07:16,180 --> 00:07:21,660
3 so it will execute from top to bottom

00:07:19,650 --> 00:07:23,850
one

00:07:21,660 --> 00:07:25,710
instruction after the other but with a

00:07:23,850 --> 00:07:28,350
sink I oh we have special powers we can

00:07:25,710 --> 00:07:30,780
make those things happen at the same

00:07:28,350 --> 00:07:33,180
time to do this you use the gather

00:07:30,780 --> 00:07:35,880
function to tell async IO that please

00:07:33,180 --> 00:07:38,250
start executing all of those three core

00:07:35,880 --> 00:07:40,380
routines right now and gather the

00:07:38,250 --> 00:07:43,680
results as fast as possible and present

00:07:40,380 --> 00:07:46,350
to me like as soon as you have them so

00:07:43,680 --> 00:07:47,900
that's pretty much the extent of async

00:07:46,350 --> 00:07:51,060
air that we're going to be using today

00:07:47,900 --> 00:07:55,370
now we also need a little bit of music

00:07:51,060 --> 00:07:57,120
theory not much just enough to get by so

00:07:55,370 --> 00:08:00,390
music is all about

00:07:57,120 --> 00:08:02,520
pitch and rhythm pitch means you know

00:08:00,390 --> 00:08:05,580
how high the sound that we are hearing

00:08:02,520 --> 00:08:09,060
like voice or a synthesizer sounds right

00:08:05,580 --> 00:08:11,400
so like typical female voices are gonna

00:08:09,060 --> 00:08:14,160
be higher pitched are gonna sound higher

00:08:11,400 --> 00:08:16,500
and are and typical male voices or bass

00:08:14,160 --> 00:08:19,380
synthesizers are gonna be lower pitched

00:08:16,500 --> 00:08:22,500
they're gonna sound lower in this

00:08:19,380 --> 00:08:25,110
particular slide you see grand piano a

00:08:22,500 --> 00:08:27,990
keyboard where sounds go from lower

00:08:25,110 --> 00:08:29,940
pitch to higher pitch and the sheet

00:08:27,990 --> 00:08:31,200
music notation equivalent like don't

00:08:29,940 --> 00:08:32,760
worry about the sheet music notation

00:08:31,200 --> 00:08:34,590
we're not gonna be using it I just

00:08:32,760 --> 00:08:37,320
wanted to show you that this is just an

00:08:34,590 --> 00:08:40,740
alphabet a way to describe what

00:08:37,320 --> 00:08:42,840
particular note you mean so if I were to

00:08:40,740 --> 00:08:46,230
actually play the notes that you can see

00:08:42,840 --> 00:08:47,820
here c d e f g a b c that would sound

00:08:46,230 --> 00:08:48,570
something like this on the synthesizers

00:08:47,820 --> 00:08:52,399
i have with me

00:08:48,570 --> 00:08:52,399
[Music]

00:08:52,440 --> 00:08:56,980
you can see this is not exactly a grand

00:08:55,210 --> 00:08:59,350
piano keyboard but there is some

00:08:56,980 --> 00:09:01,180
resemblance of how all of this looks

00:08:59,350 --> 00:09:03,970
like right like that row would be the

00:09:01,180 --> 00:09:07,150
white is and this shape right here like

00:09:03,970 --> 00:09:09,910
a remind us of the Black Keys on the

00:09:07,150 --> 00:09:12,070
grand piano keyboard so the only thing

00:09:09,910 --> 00:09:14,980
that we need to add here is that every

00:09:12,070 --> 00:09:17,800
fourth notes here on the sheet music

00:09:14,980 --> 00:09:20,170
notation you see a vertical bar that

00:09:17,800 --> 00:09:22,000
little e denotes that there is an end of

00:09:20,170 --> 00:09:25,060
a bar of music an entire note has been

00:09:22,000 --> 00:09:26,950
played every note that we have in the

00:09:25,060 --> 00:09:31,000
shape that we have here is a quarter

00:09:26,950 --> 00:09:32,770
note so four quarter notes is our you

00:09:31,000 --> 00:09:35,890
know kind of timing that we are using

00:09:32,770 --> 00:09:37,810
for this particular piece of music so

00:09:35,890 --> 00:09:40,270
that is useful because you can have not

00:09:37,810 --> 00:09:42,490
just quarters but it's or 16s which go

00:09:40,270 --> 00:09:45,040
faster you can fit more of them in the

00:09:42,490 --> 00:09:47,410
same bar and whatnot this is essentially

00:09:45,040 --> 00:09:49,900
it or the music theory the most

00:09:47,410 --> 00:09:52,950
interesting part now is how all of this

00:09:49,900 --> 00:09:56,890
to get connects together with middle

00:09:52,950 --> 00:09:59,250
MIDI is one of the few examples that I

00:09:56,890 --> 00:10:04,300
know of in history where there was a

00:09:59,250 --> 00:10:06,880
protocol invented by a bunch of music

00:10:04,300 --> 00:10:10,600
hardware vendors in the early 80s and

00:10:06,880 --> 00:10:14,290
that standard is actually very good and

00:10:10,600 --> 00:10:18,190
very well supported across the entire

00:10:14,290 --> 00:10:21,370
industry so you can buy different kinds

00:10:18,190 --> 00:10:23,410
of music hardware today and they pretty

00:10:21,370 --> 00:10:25,600
much all of them if they are electronic

00:10:23,410 --> 00:10:27,120
support MIDI to some extent course

00:10:25,600 --> 00:10:30,310
there's going to be differences between

00:10:27,120 --> 00:10:32,140
implementations and some of the vendors

00:10:30,310 --> 00:10:33,940
are going to use some more advanced

00:10:32,140 --> 00:10:36,070
functionality and that as much

00:10:33,940 --> 00:10:38,620
functionality might differ between the

00:10:36,070 --> 00:10:40,990
two devices of different vendors or even

00:10:38,620 --> 00:10:42,580
within the same vendor ah again

00:10:40,990 --> 00:10:46,240
different models can behave other

00:10:42,580 --> 00:10:48,700
differently but the basics like keeping

00:10:46,240 --> 00:10:50,980
the same tempo like playing notes or

00:10:48,700 --> 00:10:54,280
stopping to play notes and so on and so

00:10:50,980 --> 00:10:57,730
on like that is very well supported by

00:10:54,280 --> 00:11:00,340
each producer but by each vendor and

00:10:57,730 --> 00:11:02,980
what is great about this is that you can

00:11:00,340 --> 00:11:06,010
pretty much expect that if you have a

00:11:02,980 --> 00:11:08,920
digital audio workstation like logic

00:11:06,010 --> 00:11:11,770
cubase or Ableton Live you will be able

00:11:08,920 --> 00:11:14,200
to use any hardware that you buy with

00:11:11,770 --> 00:11:18,430
that audio workstation which is pretty

00:11:14,200 --> 00:11:21,100
sweet historically we've used din five

00:11:18,430 --> 00:11:23,560
cables that you can see below me on the

00:11:21,100 --> 00:11:26,200
picture but the thing is like those were

00:11:23,560 --> 00:11:28,780
vulnerable to like the cable length you

00:11:26,200 --> 00:11:31,510
know causing a corruption of the data

00:11:28,780 --> 00:11:33,940
that is being sent each cable was just a

00:11:31,510 --> 00:11:35,710
single directional or in other words you

00:11:33,940 --> 00:11:38,260
need directional you could only send the

00:11:35,710 --> 00:11:41,470
data from point A to B not the other way

00:11:38,260 --> 00:11:44,290
around so to connect two devices in both

00:11:41,470 --> 00:11:45,610
directions you needed two cables you

00:11:44,290 --> 00:11:48,130
know connecting even more than two

00:11:45,610 --> 00:11:50,290
devices made a complicated mess of

00:11:48,130 --> 00:11:52,990
cables so we're not doing this anymore

00:11:50,290 --> 00:11:54,730
but we're using these days our USB

00:11:52,990 --> 00:11:57,130
cables and in fact the synthesizer that

00:11:54,730 --> 00:11:59,290
we have here I have this as well like

00:11:57,130 --> 00:12:02,320
you can see the yellow cable right here

00:11:59,290 --> 00:12:05,230
is the USB MIDI cable for the mono

00:12:02,320 --> 00:12:09,010
station and the blue cable here is the

00:12:05,230 --> 00:12:10,990
USB MIDI cable for the circuit in fact

00:12:09,010 --> 00:12:13,600
now that I'm talking to you I am

00:12:10,990 --> 00:12:16,570
recording what is happening in the mic

00:12:13,600 --> 00:12:18,220
that our gathers my voice as well as the

00:12:16,570 --> 00:12:21,520
instruments that we are going to be

00:12:18,220 --> 00:12:24,780
playing in three tracks in Ableton Live

00:12:21,520 --> 00:12:27,280
so if I play a note on as a blue circuit

00:12:24,780 --> 00:12:29,530
you will see in a second that it

00:12:27,280 --> 00:12:32,649
actually appears in the wave and same

00:12:29,530 --> 00:12:34,449
with the mono station

00:12:32,649 --> 00:12:37,300
you will see that and I was actually up

00:12:34,449 --> 00:12:40,119
here peoples in life is used to mix this

00:12:37,300 --> 00:12:42,369
so I can actually gather all of the

00:12:40,119 --> 00:12:44,740
events that are happening and then kind

00:12:42,369 --> 00:12:46,959
of overlay them over the video but I'm

00:12:44,740 --> 00:12:50,050
not doing any more trickery right like

00:12:46,959 --> 00:12:51,550
there are no sequencers of Brahm ables

00:12:50,050 --> 00:12:54,610
in life that we're gonna be using there

00:12:51,550 --> 00:12:57,040
is no musical post-processing or like

00:12:54,610 --> 00:12:58,869
you know any other overdubs everything

00:12:57,040 --> 00:13:01,899
that you're going to be hearing comes

00:12:58,869 --> 00:13:05,259
directly from the instruments themselves

00:13:01,899 --> 00:13:08,189
and is sequenced by Python so coming

00:13:05,259 --> 00:13:10,809
back to our presentation right here MIDI

00:13:08,189 --> 00:13:13,269
amazing we can use it but how does it

00:13:10,809 --> 00:13:17,079
look like well fortunately the protocol

00:13:13,269 --> 00:13:19,809
is amazingly simple it is a synchronous

00:13:17,079 --> 00:13:22,569
protocol meaning that if you have points

00:13:19,809 --> 00:13:25,990
a and B connected as soon as you send

00:13:22,569 --> 00:13:27,639
information a note on when the

00:13:25,990 --> 00:13:29,529
instrument receives that message it

00:13:27,639 --> 00:13:31,389
should play the note if there's no

00:13:29,529 --> 00:13:33,759
scheduling there's no saying please do

00:13:31,389 --> 00:13:35,410
it in the next bar or on Tuesday or

00:13:33,759 --> 00:13:37,839
whatever else like it's synchronous you

00:13:35,410 --> 00:13:41,769
should react to messages that you get as

00:13:37,839 --> 00:13:45,069
soon as they arrive it is still a

00:13:41,769 --> 00:13:47,529
unidirectional protocol meaning the USB

00:13:45,069 --> 00:13:51,670
MIDI cable has virtual midi in and

00:13:47,529 --> 00:13:54,519
immediate ports so any single cable you

00:13:51,670 --> 00:13:57,550
can pretty much rely on the fact that

00:13:54,519 --> 00:13:59,679
nothing it has to happen in two

00:13:57,550 --> 00:14:01,480
directions and everything that does

00:13:59,679 --> 00:14:03,999
happen needs to happen as fast as

00:14:01,480 --> 00:14:06,550
possible so if you need something to

00:14:03,999 --> 00:14:09,850
happen later on you just wait and send

00:14:06,550 --> 00:14:12,399
the thing later on there are different

00:14:09,850 --> 00:14:16,029
kinds of messages that you can send so

00:14:12,399 --> 00:14:20,019
note on would mean that in we if we have

00:14:16,029 --> 00:14:22,449
a keyboard like press the key on the

00:14:20,019 --> 00:14:26,100
keyboard right note off would mean raise

00:14:22,449 --> 00:14:29,170
your finger from the keyboard right so

00:14:26,100 --> 00:14:31,360
typically the longer you keep a note the

00:14:29,170 --> 00:14:33,459
more sustain you have if you keep your

00:14:31,360 --> 00:14:37,059
finger off the e or the you know the

00:14:33,459 --> 00:14:40,809
note is going to die off you can also

00:14:37,059 --> 00:14:43,809
use different notes of C 1 e 2 F 1 and

00:14:40,809 --> 00:14:45,939
whatnot they're numbered because there's

00:14:43,809 --> 00:14:46,520
different octaves so there's more than

00:14:45,939 --> 00:14:48,950
just two

00:14:46,520 --> 00:14:51,290
of notes see one is going to be

00:14:48,950 --> 00:14:53,330
lower-pitched and see two is twelve

00:14:51,290 --> 00:14:55,340
notes up and see three is gonna be

00:14:53,330 --> 00:14:55,820
another full of notes up and so on and

00:14:55,340 --> 00:14:58,520
so on

00:14:55,820 --> 00:15:00,260
velocity is how hard you hit the key

00:14:58,520 --> 00:15:03,860
right so typically that means the more

00:15:00,260 --> 00:15:05,660
velocity the higher volume of that

00:15:03,860 --> 00:15:08,930
particular sound generated by that

00:15:05,660 --> 00:15:11,780
particular synthesizer the last thing

00:15:08,930 --> 00:15:14,630
that you can see on the picture here is

00:15:11,780 --> 00:15:17,450
the channels right so many instruments

00:15:14,630 --> 00:15:19,820
can support more than one sound at a

00:15:17,450 --> 00:15:24,200
time this is great because that means

00:15:19,820 --> 00:15:26,690
you can either have multiple instruments

00:15:24,200 --> 00:15:29,810
you know kind of in the analog sense

00:15:26,690 --> 00:15:32,030
playing together or you can say I just

00:15:29,810 --> 00:15:33,410
want to do drums here and I guess on

00:15:32,030 --> 00:15:35,840
grand piano right there

00:15:33,410 --> 00:15:37,940
so drums are typically on channel 10 and

00:15:35,840 --> 00:15:41,420
the other channels depending on the

00:15:37,940 --> 00:15:44,000
instrument so how do we agree on how

00:15:41,420 --> 00:15:47,900
fast we should be playing together well

00:15:44,000 --> 00:15:52,580
we do this by a clock signal the clock

00:15:47,900 --> 00:15:55,370
signal is sent 24 pulses per quarter

00:15:52,580 --> 00:15:56,720
note what that means is that the quarter

00:15:55,370 --> 00:16:00,110
note that you saw in the sheet music

00:15:56,720 --> 00:16:03,470
notation on the music theory slide it

00:16:00,110 --> 00:16:05,660
has like 24 signals that denote you know

00:16:03,470 --> 00:16:08,060
how fast this thing is going that is

00:16:05,660 --> 00:16:11,540
plenty of resolution to make sure that

00:16:08,060 --> 00:16:13,580
the entire like you know ensemble of

00:16:11,540 --> 00:16:17,090
your synthesizers hardware and software

00:16:13,580 --> 00:16:19,400
play synchronized at that same speed

00:16:17,090 --> 00:16:22,550
right so there are like a very good band

00:16:19,400 --> 00:16:25,370
they're gonna be in sync playing

00:16:22,550 --> 00:16:28,310
together in fact the intro music that I

00:16:25,370 --> 00:16:31,130
showed to you was being played by our

00:16:28,310 --> 00:16:33,230
MIDI program other the kind of program

00:16:31,130 --> 00:16:34,790
that we're going to right now and that

00:16:33,230 --> 00:16:39,620
program is still running right here you

00:16:34,790 --> 00:16:42,530
can see that 248 is the particular byte

00:16:39,620 --> 00:16:44,270
number or the clock signal so there's 24

00:16:42,530 --> 00:16:46,760
of those like you know there is a stream

00:16:44,270 --> 00:16:48,350
of them coming very quickly this way

00:16:46,760 --> 00:16:51,020
we're not actually going to be using the

00:16:48,350 --> 00:16:53,110
intro program anymore so let me use this

00:16:51,020 --> 00:16:55,510
opportunity to just close it off

00:16:53,110 --> 00:16:59,500
all right it's aborted it is shut down

00:16:55,510 --> 00:17:01,149
at this point so you already seen a

00:16:59,500 --> 00:17:03,579
console so you're probably excitable

00:17:01,149 --> 00:17:06,100
actually you know me stopping talking

00:17:03,579 --> 00:17:08,709
and introducing some code so what we're

00:17:06,100 --> 00:17:12,490
gonna do next we're gonna actually make

00:17:08,709 --> 00:17:16,179
Python tell the both instruments I have

00:17:12,490 --> 00:17:20,199
with me what sounds to play and when to

00:17:16,179 --> 00:17:23,140
do this to achieve this we will be using

00:17:20,199 --> 00:17:25,809
some clock right we need to agree how

00:17:23,140 --> 00:17:30,669
fast we should be going and we could

00:17:25,809 --> 00:17:32,559
either make just um async IO beat the

00:17:30,669 --> 00:17:34,299
clock count you know how fast we're

00:17:32,559 --> 00:17:37,270
going but is actually more interesting

00:17:34,299 --> 00:17:39,400
to explain to you and to show you how we

00:17:37,270 --> 00:17:42,190
can use one of those instruments as a

00:17:39,400 --> 00:17:45,250
clock source what that means is we're

00:17:42,190 --> 00:17:46,809
not going to be clock sources internally

00:17:45,250 --> 00:17:51,370
in that program but we're going to react

00:17:46,809 --> 00:17:53,950
to an external tempo and just adapt to

00:17:51,370 --> 00:17:55,900
it this is actually very important

00:17:53,950 --> 00:17:58,270
because this makes the program that

00:17:55,900 --> 00:18:00,220
we're gonna write not a toy it's

00:17:58,270 --> 00:18:03,250
something that you can use in actual

00:18:00,220 --> 00:18:05,740
music production because you will for

00:18:03,250 --> 00:18:07,630
sure want something else and not your

00:18:05,740 --> 00:18:09,970
puny Python program to be the clock

00:18:07,630 --> 00:18:12,130
source typically is going to be some

00:18:09,970 --> 00:18:14,620
kind of digital audio workstation like a

00:18:12,130 --> 00:18:16,419
built in life but if you are into

00:18:14,620 --> 00:18:18,040
Hardware synthesizers you know like the

00:18:16,419 --> 00:18:21,299
modular synthesizer I'm building and

00:18:18,040 --> 00:18:24,760
whatnot you could make some of those

00:18:21,299 --> 00:18:27,370
modules the clock source for you and a

00:18:24,760 --> 00:18:31,000
Python program would only be following

00:18:27,370 --> 00:18:33,160
that clock so in our case the Novation

00:18:31,000 --> 00:18:35,410
circuit as I said a full grown and

00:18:33,160 --> 00:18:38,380
groove box is going to be our clock

00:18:35,410 --> 00:18:41,110
source we're gonna feed it to Python so

00:18:38,380 --> 00:18:44,200
python knows how fast it should be going

00:18:41,110 --> 00:18:48,160
and then thanks to this we will be able

00:18:44,200 --> 00:18:51,460
to sequence to generate notes in a given

00:18:48,160 --> 00:18:54,820
sequence both of the instruments alright

00:18:51,460 --> 00:18:56,860
so that's it for the slides part like

00:18:54,820 --> 00:19:01,750
let's move on to the more interesting

00:18:56,860 --> 00:19:04,750
things are to be done so actual visual

00:19:01,750 --> 00:19:06,340
studio our and our coding this

00:19:04,750 --> 00:19:07,960
particular screen

00:19:06,340 --> 00:19:09,940
year like it's not very interesting

00:19:07,960 --> 00:19:11,110
because that was the example that I

00:19:09,940 --> 00:19:15,299
started with

00:19:11,110 --> 00:19:18,340
intro music let's go ahead and switch to

00:19:15,299 --> 00:19:21,580
some starting point that we will be

00:19:18,340 --> 00:19:23,350
using to recreate a program like this

00:19:21,580 --> 00:19:25,779
we're going to be going from scratch so

00:19:23,350 --> 00:19:28,960
that you understand what is going on and

00:19:25,779 --> 00:19:31,929
how we achieved the design that we are

00:19:28,960 --> 00:19:33,880
actually finishing with so let's just

00:19:31,929 --> 00:19:36,610
say we're gonna be starting with p0

00:19:33,880 --> 00:19:39,399
which is PI cons zeroth starting point

00:19:36,610 --> 00:19:42,010
right now okay by the way if you would

00:19:39,399 --> 00:19:43,210
like to actually follow me with your own

00:19:42,010 --> 00:19:44,710
program in your own hardware

00:19:43,210 --> 00:19:47,399
synthesizers at home

00:19:44,710 --> 00:19:51,669
you're absolutely invited to do this ah

00:19:47,399 --> 00:19:55,570
the entire code lives in I get a repo on

00:19:51,669 --> 00:19:59,049
github under my account a and B V the

00:19:55,570 --> 00:20:02,140
project's names a IO tone so all of this

00:19:59,049 --> 00:20:04,809
is available for you if you are ready to

00:20:02,140 --> 00:20:08,230
dabble with this yourself but now we are

00:20:04,809 --> 00:20:11,559
starting at p0 really sterling with a

00:20:08,230 --> 00:20:15,250
file that is just some of not this some

00:20:11,559 --> 00:20:17,200
very very simple boilerplate as you can

00:20:15,250 --> 00:20:20,440
see is just a bunch of lines it doesn't

00:20:17,200 --> 00:20:22,570
do anything yet the only thing that I

00:20:20,440 --> 00:20:27,279
don't want to start like Tipton totally

00:20:22,570 --> 00:20:30,490
from scratch is a MIDI py file that

00:20:27,279 --> 00:20:33,809
pretty much consists consists of some

00:20:30,490 --> 00:20:37,120
mappings between the names of bytes and

00:20:33,809 --> 00:20:39,399
the byte values right so obviously MIDI

00:20:37,120 --> 00:20:41,640
on the wire is just a bunch of numbers

00:20:39,399 --> 00:20:44,950
like anything else in computer science

00:20:41,640 --> 00:20:47,320
but it is just more natural for humans

00:20:44,950 --> 00:20:49,059
to kind of assign names to them so I

00:20:47,320 --> 00:20:52,120
already did that for us we're not gonna

00:20:49,059 --> 00:20:54,279
have to you know come up and find the

00:20:52,120 --> 00:20:56,440
name in the numbers and the names for

00:20:54,279 --> 00:20:59,950
them later on you already have all this

00:20:56,440 --> 00:21:03,549
and then some boilerplate to just get

00:20:59,950 --> 00:21:05,649
the MIDI ports for our Python use and

00:21:03,549 --> 00:21:07,059
we're going to be using our t-midi to

00:21:05,649 --> 00:21:09,630
actually do the heavy lifting

00:21:07,059 --> 00:21:13,510
of sending things and receiving things

00:21:09,630 --> 00:21:15,100
from the MIDI hardware instruments so

00:21:13,510 --> 00:21:17,049
like you know as you can see on the side

00:21:15,100 --> 00:21:19,299
this is actually not like you know the

00:21:17,049 --> 00:21:19,840
most complicated code out there but you

00:21:19,299 --> 00:21:22,570
know it

00:21:19,840 --> 00:21:25,510
be written so we already have the rapper

00:21:22,570 --> 00:21:27,880
right here which is going to do it for

00:21:25,510 --> 00:21:29,919
us that is not very interesting the more

00:21:27,880 --> 00:21:33,220
interesting thing is definitely the ad

00:21:29,919 --> 00:21:38,740
under main file which contains you know

00:21:33,220 --> 00:21:40,360
whoa or will contain our sequencer so at

00:21:38,740 --> 00:21:42,429
this particular stage nothing

00:21:40,360 --> 00:21:45,370
interesting is happening yet right we

00:21:42,429 --> 00:21:49,330
have our main function that we are

00:21:45,370 --> 00:21:52,600
calling if this is being called as a

00:21:49,330 --> 00:21:55,450
script but that main function is already

00:21:52,600 --> 00:21:58,179
a click command and why do I do this if

00:21:55,450 --> 00:22:01,539
I don't have any arm arguments to parse

00:21:58,179 --> 00:22:04,240
well click is something I use every time

00:22:01,539 --> 00:22:05,649
that I'm doing some script that is going

00:22:04,240 --> 00:22:08,529
to be invoked from the command line

00:22:05,649 --> 00:22:11,380
because it is much more than just online

00:22:08,529 --> 00:22:13,450
argument parsing but it's also doing it

00:22:11,380 --> 00:22:15,820
provides you a sensible way to echo

00:22:13,450 --> 00:22:17,950
things on the console irregardless of

00:22:15,820 --> 00:22:20,529
the console's configuration in this

00:22:17,950 --> 00:22:22,659
particular example here is already a

00:22:20,529 --> 00:22:24,909
styled echo so what it enables us to do

00:22:22,659 --> 00:22:27,100
is also call our things like you know

00:22:24,909 --> 00:22:30,070
say that this this foreground should be

00:22:27,100 --> 00:22:33,340
red and this should go to standard error

00:22:30,070 --> 00:22:36,640
and not to standard out so I like click

00:22:33,340 --> 00:22:39,279
a lot and use it a lot or more reasons

00:22:36,640 --> 00:22:41,350
than just a command line argument

00:22:39,279 --> 00:22:44,919
parsing we can also like raise up words

00:22:41,350 --> 00:22:47,320
which will generate nicer exit messages

00:22:44,919 --> 00:22:50,320
than just a full trace back of things

00:22:47,320 --> 00:22:52,600
that can happen right so that's 4 click

00:22:50,320 --> 00:22:54,669
and now the only thing that we need to

00:22:52,600 --> 00:22:58,270
do is use the a Sicario framework to run

00:22:54,669 --> 00:23:01,480
function to use our async main the

00:22:58,270 --> 00:23:04,570
eating main async function so far

00:23:01,480 --> 00:23:08,380
doesn't do anything much it just it gets

00:23:04,570 --> 00:23:10,690
the ports or the circuit and for the

00:23:08,380 --> 00:23:14,919
mono station so it would be actually and

00:23:10,690 --> 00:23:16,360
maybe better to just I have it actually

00:23:14,919 --> 00:23:19,510
do something interesting

00:23:16,360 --> 00:23:22,480
so my first attempt at recording this

00:23:19,510 --> 00:23:24,880
video were me typing everything out and

00:23:22,480 --> 00:23:28,360
explaining as I was going through it

00:23:24,880 --> 00:23:30,789
but I found this to be both too slow and

00:23:28,360 --> 00:23:33,070
too awkward whenever I did made a type

00:23:30,789 --> 00:23:33,820
or whatever so this time we're still

00:23:33,070 --> 00:23:37,030
gonna be doing

00:23:33,820 --> 00:23:39,610
some typing but most of the kind of less

00:23:37,030 --> 00:23:43,270
gradual changes are going to just happen

00:23:39,610 --> 00:23:46,120
by me checking out another tag from the

00:23:43,270 --> 00:23:48,760
repo so that there is something more for

00:23:46,120 --> 00:23:51,580
me to talk about and less opportunity to

00:23:48,760 --> 00:23:53,350
you know show you how bad I am at typing

00:23:51,580 --> 00:23:55,060
so there's the first thing that I wanted

00:23:53,350 --> 00:23:58,060
to show you is that you should be using

00:23:55,060 --> 00:24:00,940
a more interesting event loop right you

00:23:58,060 --> 00:24:03,820
can already see a Visual Studio code

00:24:00,940 --> 00:24:05,920
helpfully highlighting the changes that

00:24:03,820 --> 00:24:07,660
just happened here in green so you can

00:24:05,920 --> 00:24:10,570
see that those are just the two lines of

00:24:07,660 --> 00:24:12,850
change so UV loop I'm importing

00:24:10,570 --> 00:24:15,010
something and installing it but it

00:24:12,850 --> 00:24:17,080
doesn't explain what that is yet ah so

00:24:15,010 --> 00:24:19,330
let me do that for you the event loop

00:24:17,080 --> 00:24:21,580
that SNK op is using is a reference one

00:24:19,330 --> 00:24:24,280
it is written in Python and it is

00:24:21,580 --> 00:24:26,560
designed for correctness and ease of

00:24:24,280 --> 00:24:28,720
explanation right so you can Lily go

00:24:26,560 --> 00:24:30,700
inside the event loops code and

00:24:28,720 --> 00:24:33,100
understand how a sinker works internally

00:24:30,700 --> 00:24:35,590
this is also great for debugging when

00:24:33,100 --> 00:24:37,540
things internally in async i/o are not

00:24:35,590 --> 00:24:39,070
working correctly it is easier to kind

00:24:37,540 --> 00:24:41,320
of step through things as they happen

00:24:39,070 --> 00:24:43,120
and understand what went wrong however

00:24:41,320 --> 00:24:45,970
when you're running things in production

00:24:43,120 --> 00:24:48,940
what you want is maximal speed you want

00:24:45,970 --> 00:24:51,670
maximum performance so for this we're

00:24:48,940 --> 00:24:54,850
going to be using a URI sullivan of CUV

00:24:51,670 --> 00:24:56,980
loop library which wraps libuv

00:24:54,850 --> 00:24:59,560
that same event loop library that is

00:24:56,980 --> 00:25:02,740
used by node.js and allows it to be used

00:24:59,560 --> 00:25:05,830
by a sink i/o you don't actually have to

00:25:02,740 --> 00:25:07,870
do any hard setup to make that happen

00:25:05,830 --> 00:25:10,690
the only thing that you need to do is

00:25:07,870 --> 00:25:12,880
call UV loop install and you're done so

00:25:10,690 --> 00:25:15,640
having this out of the way let's move

00:25:12,880 --> 00:25:21,070
and see the next thing the next thing is

00:25:15,640 --> 00:25:23,980
this we have our callback that we need

00:25:21,070 --> 00:25:27,220
to set whenever we want to get MIDI

00:25:23,980 --> 00:25:31,030
information from a MIDI import you can

00:25:27,220 --> 00:25:34,810
see in lines 14 and 15 that we got pairs

00:25:31,030 --> 00:25:37,960
of ports for both the circuit and the

00:25:34,810 --> 00:25:40,090
mono station right so the from circuit

00:25:37,960 --> 00:25:43,390
is actually information coming from the

00:25:40,090 --> 00:25:45,760
instruments right and two circuits is an

00:25:43,390 --> 00:25:46,220
opportunity for us to send it notes and

00:25:45,760 --> 00:25:48,679
other

00:25:46,220 --> 00:25:50,390
vents ourselves same with brahmano

00:25:48,679 --> 00:25:52,940
station information that we were getting

00:25:50,390 --> 00:25:55,250
from a montemagno station and to manna

00:25:52,940 --> 00:25:58,190
station our notes that we can send to it

00:25:55,250 --> 00:26:00,980
in our particular case what we want to

00:25:58,190 --> 00:26:03,409
do is we want to receive the clock

00:26:00,980 --> 00:26:06,380
signal from the circuit so we will need

00:26:03,409 --> 00:26:08,419
to register a callback to make sure that

00:26:06,380 --> 00:26:11,330
every event that comes from the

00:26:08,419 --> 00:26:14,419
instrument is being received on the

00:26:11,330 --> 00:26:16,130
Python side from mono station we are in

00:26:14,419 --> 00:26:18,020
fact closing we're not interested in

00:26:16,130 --> 00:26:20,600
anything that comes from this particular

00:26:18,020 --> 00:26:23,210
instrument this is important because our

00:26:20,600 --> 00:26:27,230
t-midi has its own internal buffer and

00:26:23,210 --> 00:26:29,840
if we actually did not close the port it

00:26:27,230 --> 00:26:32,450
would quickly fill up and our t-midi

00:26:29,840 --> 00:26:35,960
would be unhappy with us that the buffer

00:26:32,450 --> 00:26:39,140
is full and we never started on getting

00:26:35,960 --> 00:26:41,510
information from it so here we are

00:26:39,140 --> 00:26:43,850
setting the callback and we're closing

00:26:41,510 --> 00:26:45,919
the other port everything is good right

00:26:43,850 --> 00:26:49,429
well except for the fact that there is

00:26:45,919 --> 00:26:52,789
actually not a MIDI callback function

00:26:49,429 --> 00:26:55,429
yet we didn't implement it yet so we

00:26:52,789 --> 00:26:57,380
need to fix this we should probably also

00:26:55,429 --> 00:26:58,970
fix the name of the MIDI callback

00:26:57,380 --> 00:27:01,700
because it's super non-descriptive

00:26:58,970 --> 00:27:04,309
doesn't have it doesn't say what it'll

00:27:01,700 --> 00:27:06,830
do it just says what role it's our

00:27:04,309 --> 00:27:08,750
fulfills which is a rather poor name but

00:27:06,830 --> 00:27:10,669
let's stick with it we only need one for

00:27:08,750 --> 00:27:13,700
this particular demo so this is not a

00:27:10,669 --> 00:27:17,240
big problem in our particular case so

00:27:13,700 --> 00:27:23,419
the MIDI callback that we will will use

00:27:17,240 --> 00:27:26,059
here is in fact taking a MIDI message in

00:27:23,419 --> 00:27:28,520
the format of a MIDI packet and an event

00:27:26,059 --> 00:27:29,929
Delta some other optional data that

00:27:28,520 --> 00:27:31,909
we're not interested in in this

00:27:29,929 --> 00:27:34,250
particular example it doesn't return

00:27:31,909 --> 00:27:36,230
anything but you can do whatever you

00:27:34,250 --> 00:27:39,289
want in this particular scenario right

00:27:36,230 --> 00:27:41,659
like you have a MIDI message which

00:27:39,289 --> 00:27:43,549
already says us whether it's a clock or

00:27:41,659 --> 00:27:46,490
it's a note on or it's a note off and

00:27:43,549 --> 00:27:50,000
the deltas saying how much time they'd

00:27:46,490 --> 00:27:53,570
pass between the last MIDI message and

00:27:50,000 --> 00:27:55,760
the current MIDI message right so um the

00:27:53,570 --> 00:27:58,159
nice descriptive names that we see here

00:27:55,760 --> 00:27:59,800
are actually by me I just decided to

00:27:58,159 --> 00:28:03,340
apply

00:27:59,800 --> 00:28:05,560
human descriptive names - raw types that

00:28:03,340 --> 00:28:07,900
are in fact used over the wire because

00:28:05,560 --> 00:28:10,390
typing is for people right you are using

00:28:07,900 --> 00:28:12,010
it in as a form of documentation just so

00:28:10,390 --> 00:28:13,870
that you can understand what is

00:28:12,010 --> 00:28:16,060
happening when you're returning to your

00:28:13,870 --> 00:28:17,470
own program six months from now or if

00:28:16,060 --> 00:28:19,540
you're working in a bigger team

00:28:17,470 --> 00:28:22,030
everybody can agree it's like oh okay

00:28:19,540 --> 00:28:24,220
even though this is a float and this is

00:28:22,030 --> 00:28:25,990
a float this particular one is an event

00:28:24,220 --> 00:28:28,720
Delta and this particular one is a

00:28:25,990 --> 00:28:30,780
timestamp about the current time so this

00:28:28,720 --> 00:28:34,630
is in fact what we're going to be

00:28:30,780 --> 00:28:36,580
receiving prom of the MIDI from Artie

00:28:34,630 --> 00:28:38,530
MIDI right a callback is always going to

00:28:36,580 --> 00:28:40,120
get those arguments so we can do

00:28:38,530 --> 00:28:43,330
something with them in this particular

00:28:40,120 --> 00:28:46,080
example like we are building this as we

00:28:43,330 --> 00:28:49,990
go so there's nothing happening yet I

00:28:46,080 --> 00:28:52,060
only recreated the MIDI packet and even

00:28:49,990 --> 00:28:55,690
Delta unpacking the tuple that we are

00:28:52,060 --> 00:28:58,660
getting here and already sent I set the

00:28:55,690 --> 00:29:01,210
send time to the current time we're

00:28:58,660 --> 00:29:03,190
gonna be using this as a a MIDI message

00:29:01,210 --> 00:29:05,650
in the next step

00:29:03,190 --> 00:29:07,990
like now flick it is actually unhappy

00:29:05,650 --> 00:29:09,940
with me I'm not using sense time yet

00:29:07,990 --> 00:29:15,030
don't worry if like it we're getting

00:29:09,940 --> 00:29:17,110
there real soon now so switching to p4

00:29:15,030 --> 00:29:19,150
you can see that there's already

00:29:17,110 --> 00:29:22,230
something that is happening like what is

00:29:19,150 --> 00:29:25,300
happening now is we introduced a queue

00:29:22,230 --> 00:29:27,670
why did we introduce a queue let's

00:29:25,300 --> 00:29:30,850
switch away from the code for a second

00:29:27,670 --> 00:29:33,280
to talk about how RT MIDI does the

00:29:30,850 --> 00:29:35,290
callbacks and why we need something like

00:29:33,280 --> 00:29:36,030
a queue to process those things with

00:29:35,290 --> 00:29:42,160
Eason ko

00:29:36,030 --> 00:29:45,100
so when an instrument like the circuit

00:29:42,160 --> 00:29:47,520
sends information to us to a port what

00:29:45,100 --> 00:29:50,350
is actually happening is that the

00:29:47,520 --> 00:29:53,440
harbour driver of that particular port

00:29:50,350 --> 00:29:55,450
is getting its data and just publishes

00:29:53,440 --> 00:29:57,460
it on the operating system for any

00:29:55,450 --> 00:29:59,710
subscriber to connect so if you're

00:29:57,460 --> 00:30:02,110
subscribed at a giving any given moment

00:29:59,710 --> 00:30:05,830
to those messages you're gonna get them

00:30:02,110 --> 00:30:07,360
so RT MIDI through our port opening when

00:30:05,830 --> 00:30:11,110
we're saying we want the circuit board

00:30:07,360 --> 00:30:12,010
it subscribes to this stream of messages

00:30:11,110 --> 00:30:15,670
right

00:30:12,010 --> 00:30:18,910
and the thread of our t-midi which is

00:30:15,670 --> 00:30:22,900
written in C++ is reacting to new

00:30:18,910 --> 00:30:26,080
messages and has to somehow allow Python

00:30:22,900 --> 00:30:27,790
to get those messages in Python code and

00:30:26,080 --> 00:30:29,320
this is why we were setting up the

00:30:27,790 --> 00:30:31,150
callback write the callback is

00:30:29,320 --> 00:30:34,090
essentially is a function that we gave

00:30:31,150 --> 00:30:37,390
to just say that hey whenever there's an

00:30:34,090 --> 00:30:41,560
event run this Python code but callbacks

00:30:37,390 --> 00:30:43,450
are rather weak unwieldy to use with you

00:30:41,560 --> 00:30:45,190
know more complex programs like so

00:30:43,450 --> 00:30:47,680
really designing more complex programs

00:30:45,190 --> 00:30:51,190
on callbacks is a rather hard problem

00:30:47,680 --> 00:30:54,000
more importantly the C++ thread where

00:30:51,190 --> 00:30:57,010
all of this receiving is happening is a

00:30:54,000 --> 00:30:59,710
separate thread from the rest of Python

00:30:57,010 --> 00:31:02,380
for us so we don't actually want to do

00:30:59,710 --> 00:31:05,140
any heavy computation there we would

00:31:02,380 --> 00:31:06,970
prefer to do this in a separate Python

00:31:05,140 --> 00:31:09,550
thread that we see here in that

00:31:06,970 --> 00:31:12,790
particular Python thread and nicely runs

00:31:09,550 --> 00:31:16,060
our async IO event loop and on that end

00:31:12,790 --> 00:31:18,550
on the event loops event loops and we're

00:31:16,060 --> 00:31:20,920
just gonna run queue get to get the

00:31:18,550 --> 00:31:24,010
information from the queue as it goes if

00:31:20,920 --> 00:31:26,320
we are waiting on that cube get if the

00:31:24,010 --> 00:31:29,200
queue is empty that is going to block

00:31:26,320 --> 00:31:32,260
until either is something new available

00:31:29,200 --> 00:31:34,780
so whenever C++ puts information there

00:31:32,260 --> 00:31:36,790
for us the queue is going to get more

00:31:34,780 --> 00:31:39,340
elements and python is going to get

00:31:36,790 --> 00:31:42,580
those elements out to be able to process

00:31:39,340 --> 00:31:45,010
them so that's essentially the design of

00:31:42,580 --> 00:31:49,420
the flow right you know in a nice slide

00:31:45,010 --> 00:31:51,970
but it is not super kind of verbose in

00:31:49,420 --> 00:31:54,010
code either you can see that here

00:31:51,970 --> 00:31:56,200
essentially what we're doing is the

00:31:54,010 --> 00:31:59,560
information that we got we format it as

00:31:56,200 --> 00:32:01,480
a MIDI message that agrees with this

00:31:59,560 --> 00:32:03,550
particular MIDI message type that we

00:32:01,480 --> 00:32:05,890
defined here and the only thing that we

00:32:03,550 --> 00:32:08,770
need to do is put that message on the

00:32:05,890 --> 00:32:11,950
queue right so how do we make anything

00:32:08,770 --> 00:32:13,840
happen any music play we also need to

00:32:11,950 --> 00:32:16,240
await on some music consumer and that

00:32:13,840 --> 00:32:18,640
MIDI consumer is going to also use that

00:32:16,240 --> 00:32:21,310
same cue that we defined here it's a

00:32:18,640 --> 00:32:23,170
queue of MIDI messages right and it's

00:32:21,310 --> 00:32:25,350
gonna consume whatever comes on that

00:32:23,170 --> 00:32:27,630
queue how does a MIDI consumer wear

00:32:25,350 --> 00:32:31,440
how does it look like it is literally

00:32:27,630 --> 00:32:31,919
something that just loops over or ever I

00:32:31,440 --> 00:32:35,549
know

00:32:31,919 --> 00:32:39,809
while true and while looping it is going

00:32:35,549 --> 00:32:42,660
to await on cue get as I promised right

00:32:39,809 --> 00:32:44,400
and once there is a new message only you

00:32:42,660 --> 00:32:46,410
it can do something with it

00:32:44,400 --> 00:32:48,030
in this particular a piece of code the

00:32:46,410 --> 00:32:51,390
only thing that we're doing is printing

00:32:48,030 --> 00:32:54,450
out whatever we got so as as a form of

00:32:51,390 --> 00:32:56,460
debugging right so we're printing out

00:32:54,450 --> 00:32:58,320
the packet and we're printing out the

00:32:56,460 --> 00:33:00,120
event Delta it's a flawed server

00:32:58,320 --> 00:33:03,179
formatting it just a bit so that it's

00:33:00,120 --> 00:33:05,760
not super unwieldy saying with latency

00:33:03,179 --> 00:33:08,490
and latency is measured in our case by

00:33:05,760 --> 00:33:11,640
the difference between the current time

00:33:08,490 --> 00:33:15,360
and at the time at which the element was

00:33:11,640 --> 00:33:17,880
put in the queue the latency is just

00:33:15,360 --> 00:33:20,549
fine for our purposes I'm in fact

00:33:17,880 --> 00:33:22,950
showing this explicitly just so that you

00:33:20,549 --> 00:33:26,429
can relax and see that I think I was

00:33:22,950 --> 00:33:31,020
plenty fast for MIDI applications um so

00:33:26,429 --> 00:33:33,390
this is the main flow of information

00:33:31,020 --> 00:33:36,419
that we're gonna see from the circuit um

00:33:33,390 --> 00:33:38,580
but it is a bit naive now and I if I try

00:33:36,419 --> 00:33:41,730
to execute this right now like weird

00:33:38,580 --> 00:33:43,740
things would happen so to make things a

00:33:41,730 --> 00:33:48,270
little less naive what I will have to do

00:33:43,740 --> 00:33:50,190
is to run p5 and now you can see that

00:33:48,270 --> 00:33:53,460
there are in fact a little bit of

00:33:50,190 --> 00:33:55,679
changes here and we received our async

00:33:53,460 --> 00:33:58,860
i/o event loop what did we do that for

00:33:55,679 --> 00:34:01,289
well - instead of just saying Hugh put

00:33:58,860 --> 00:34:04,530
no weight with our MIDI message we are

00:34:01,289 --> 00:34:06,690
saying a loop hole soon so as soon as

00:34:04,530 --> 00:34:09,600
you're ready call soon thread-safe

00:34:06,690 --> 00:34:11,970
queue put no wait why is that thread

00:34:09,600 --> 00:34:14,010
safe here as well it's a variant of call

00:34:11,970 --> 00:34:16,260
soon which can be called from other

00:34:14,010 --> 00:34:19,379
threads and if you remember correctly

00:34:16,260 --> 00:34:21,389
the C++ thread in which our Committee is

00:34:19,379 --> 00:34:24,179
listening to messages from the circuit

00:34:21,389 --> 00:34:26,970
is separate from the main Python thread

00:34:24,179 --> 00:34:29,970
in which our async i/o application is

00:34:26,970 --> 00:34:33,030
running so we need to use call soon

00:34:29,970 --> 00:34:36,000
thread safe or everything to stay sane

00:34:33,030 --> 00:34:39,300
for everything to stay stable on our

00:34:36,000 --> 00:34:42,179
midi consumer side

00:34:39,300 --> 00:34:45,929
thing much has changed yet so we can

00:34:42,179 --> 00:34:49,130
attempt at running this right now let's

00:34:45,929 --> 00:34:53,400
see how we do this so this is in da AO

00:34:49,130 --> 00:34:56,160
tone package it's called dunder main so

00:34:53,400 --> 00:34:59,730
what we can do is just say Python m io

00:34:56,160 --> 00:35:04,230
tone and run the application and you can

00:34:59,730 --> 00:35:08,130
already see a stream of events in async

00:35:04,230 --> 00:35:10,680
ro are processed by our midi consumer

00:35:08,130 --> 00:35:14,550
even though they are received in a

00:35:10,680 --> 00:35:17,090
separate c++ thread by RT midi so our

00:35:14,550 --> 00:35:20,940
callback every time is responsible for

00:35:17,090 --> 00:35:24,060
receiving this information and totally

00:35:20,940 --> 00:35:26,850
separately this information is gathered

00:35:24,060 --> 00:35:29,250
from a queue and processed event by

00:35:26,850 --> 00:35:32,870
event so that looks good let me try to

00:35:29,250 --> 00:35:35,340
shut the application down that shut down

00:35:32,870 --> 00:35:37,710
everything is good but if we try to do

00:35:35,340 --> 00:35:39,510
this a few times we might sometimes see

00:35:37,710 --> 00:35:42,660
that you know there are there might be

00:35:39,510 --> 00:35:44,190
actually exceptions or other weird

00:35:42,660 --> 00:35:46,230
things happening in this particular

00:35:44,190 --> 00:35:47,730
example of course as I'm trying to

00:35:46,230 --> 00:35:50,340
demonstrate this that will never happen

00:35:47,730 --> 00:35:52,190
but believe me this is not how a

00:35:50,340 --> 00:35:55,560
production application should look yet

00:35:52,190 --> 00:35:58,110
so let's introduce some form of error

00:35:55,560 --> 00:36:02,100
handling there needs to be just a little

00:35:58,110 --> 00:36:06,360
of that so let's see what we changed now

00:36:02,100 --> 00:36:10,200
again hopefully um a Visual Studio code

00:36:06,360 --> 00:36:13,290
will show us what lines changed so here

00:36:10,200 --> 00:36:17,870
we just wrapped the coulson thread safe

00:36:13,290 --> 00:36:20,790
in a try except a block we are actually

00:36:17,870 --> 00:36:22,470
looking for base exceptions because one

00:36:20,790 --> 00:36:25,020
of the very typical ones is going to be

00:36:22,470 --> 00:36:27,570
a cancellation error and other things

00:36:25,020 --> 00:36:29,850
that can happen when our Python thread

00:36:27,570 --> 00:36:32,910
already shutdown the async i/o event

00:36:29,850 --> 00:36:35,010
loop and whatnot whereas the MIDI

00:36:32,910 --> 00:36:37,140
callback running from a C++ thread

00:36:35,010 --> 00:36:39,420
doesn't know about this yet and tries to

00:36:37,140 --> 00:36:41,250
execute our Python code so we're

00:36:39,420 --> 00:36:43,590
wrapping it just saying hey callback

00:36:41,250 --> 00:36:45,210
failed like we couldn't call that thing

00:36:43,590 --> 00:36:49,710
soon we could it schedule that callback

00:36:45,210 --> 00:36:52,800
anymore um on the consumer end what we

00:36:49,710 --> 00:36:56,400
want to do is when things get canceled

00:36:52,800 --> 00:36:59,580
we will ensure that the C++ thread on

00:36:56,400 --> 00:37:02,220
registers or MIDI call back if we didn't

00:36:59,580 --> 00:37:04,430
do this it would just keep sending

00:37:02,220 --> 00:37:07,050
information to us and that would

00:37:04,430 --> 00:37:10,320
sometimes call the exception that I

00:37:07,050 --> 00:37:12,750
tried and failed to show you we are also

00:37:10,320 --> 00:37:15,840
using some magic silenced functions on

00:37:12,750 --> 00:37:18,870
both of the two ports they kind of

00:37:15,840 --> 00:37:22,590
already are there for our future use but

00:37:18,870 --> 00:37:25,260
to explain why they are there as you saw

00:37:22,590 --> 00:37:28,740
as you saw before there are separate to

00:37:25,260 --> 00:37:30,840
note on and the note off messages so if

00:37:28,740 --> 00:37:33,270
we stop our application in the very

00:37:30,840 --> 00:37:36,540
worst moment by just saying a note on

00:37:33,270 --> 00:37:38,340
and now we stop that note would be

00:37:36,540 --> 00:37:40,440
playing forever which would be super

00:37:38,340 --> 00:37:43,350
annoying to anybody it will be actually

00:37:40,440 --> 00:37:47,760
quite tricky to make this stop playing

00:37:43,350 --> 00:37:49,650
so we want whenever our async main is

00:37:47,760 --> 00:37:51,660
cancelled and is going to be cancelled

00:37:49,650 --> 00:37:53,940
for example when we control C our

00:37:51,660 --> 00:37:56,070
application we wanted to make sure that

00:37:53,940 --> 00:37:58,680
we are canceling the callback at the

00:37:56,070 --> 00:38:00,630
same time and we are silencing both

00:37:58,680 --> 00:38:05,220
instruments right so if there were any

00:38:00,630 --> 00:38:09,120
note on events we will counteract them

00:38:05,220 --> 00:38:11,910
by saying stop playing and all notes off

00:38:09,120 --> 00:38:15,030
on all channels please alright so this

00:38:11,910 --> 00:38:17,700
is going to do this for us so that is

00:38:15,030 --> 00:38:19,890
actually enough right here and again if

00:38:17,700 --> 00:38:21,870
I executed this now it would look pretty

00:38:19,890 --> 00:38:24,480
much the same even though we're getting

00:38:21,870 --> 00:38:27,630
information from the circuit nothing

00:38:24,480 --> 00:38:30,030
interesting is happening yet so let's

00:38:27,630 --> 00:38:32,370
finally make some sounds happen like

00:38:30,030 --> 00:38:34,860
we're recording for like a good 35

00:38:32,370 --> 00:38:37,950
minutes already let's make something

00:38:34,860 --> 00:38:42,900
sound from the program that we're

00:38:37,950 --> 00:38:47,520
writing it with now so if we get MIDI

00:38:42,900 --> 00:38:49,140
messages from that put MIDI port from

00:38:47,520 --> 00:38:51,630
the circuit there's going to be many

00:38:49,140 --> 00:38:54,690
kinds of them and we can process them by

00:38:51,630 --> 00:38:56,640
type right we can check what kind of

00:38:54,690 --> 00:38:59,190
MIDI message we're going to encounter

00:38:56,640 --> 00:39:02,070
and in this particular example the clock

00:38:59,190 --> 00:39:05,410
message the 24 pulses per quarter note

00:39:02,070 --> 00:39:08,920
is the particular example that we

00:39:05,410 --> 00:39:11,080
to keep things in sync so what are we

00:39:08,920 --> 00:39:13,990
trying to keep in sync well first of all

00:39:11,080 --> 00:39:16,540
we need this clock for our Python Python

00:39:13,990 --> 00:39:18,940
sequencer but also we have two hardware

00:39:16,540 --> 00:39:22,210
synthesizers the circuit already knows

00:39:18,940 --> 00:39:24,310
what its own internal clock is but the

00:39:22,210 --> 00:39:26,560
mono station is a separate hardware

00:39:24,310 --> 00:39:29,110
synthesizer it doesn't know what tempo

00:39:26,560 --> 00:39:31,180
it should follow so here whenever we

00:39:29,110 --> 00:39:34,510
have a clock message we also want to

00:39:31,180 --> 00:39:35,410
send it to the mono station to the bass

00:39:34,510 --> 00:39:38,050
synthesizer

00:39:35,410 --> 00:39:40,630
same with start playing and stop playing

00:39:38,050 --> 00:39:43,300
messages we also would like those

00:39:40,630 --> 00:39:45,520
messages to be forwarded to the mono

00:39:43,300 --> 00:39:48,010
station but wait a minute if we actually

00:39:45,520 --> 00:39:50,500
save the file right now you will see

00:39:48,010 --> 00:39:54,400
that flake eight is unhappy with us that

00:39:50,500 --> 00:39:56,800
this bass variable doesn't exist there

00:39:54,400 --> 00:39:58,600
was no base argument but if you're

00:39:56,800 --> 00:40:00,700
already thinking for you're gonna see

00:39:58,600 --> 00:40:03,010
that there's not only gonna be a bass

00:40:00,700 --> 00:40:04,600
synthesizer is gonna be the mono adder

00:40:03,010 --> 00:40:07,180
circuit and there's also going to be

00:40:04,600 --> 00:40:10,450
probably more data more information that

00:40:07,180 --> 00:40:13,870
we will need to make our program tick

00:40:10,450 --> 00:40:16,450
and annoyingly we could just keep adding

00:40:13,870 --> 00:40:18,280
more arguments to our function but soon

00:40:16,450 --> 00:40:21,040
enough like that would be unwieldy and

00:40:18,280 --> 00:40:24,300
very big so instead what we are gonna be

00:40:21,040 --> 00:40:28,780
doing here is we're gonna introduce a

00:40:24,300 --> 00:40:30,610
class to keep our state and sis since

00:40:28,780 --> 00:40:33,040
that state describes our live

00:40:30,610 --> 00:40:36,460
performance we're just gonna use a name

00:40:33,040 --> 00:40:40,690
performance for our class so that class

00:40:36,460 --> 00:40:42,520
for now only has two attributes so we're

00:40:40,690 --> 00:40:45,730
using a data class for it so that we

00:40:42,520 --> 00:40:48,550
don't need to write an under init method

00:40:45,730 --> 00:40:50,320
and the under-represent you know

00:40:48,550 --> 00:40:52,660
equality comparisons and anything else

00:40:50,320 --> 00:40:55,660
but in fact we are using the pro version

00:40:52,660 --> 00:40:57,580
of data classes which are adders you can

00:40:55,660 --> 00:41:00,220
just you know pip install adders to get

00:40:57,580 --> 00:41:01,720
those as well so behaves pretty much the

00:41:00,220 --> 00:41:03,340
same but has plenty of other

00:41:01,720 --> 00:41:07,030
functionality some of which we're gonna

00:41:03,340 --> 00:41:08,980
even be meaning right right now so cool

00:41:07,030 --> 00:41:12,040
we have a performance object that our

00:41:08,980 --> 00:41:14,800
holds for example our MIDI outputs for

00:41:12,040 --> 00:41:16,870
now so the only thing that we need to

00:41:14,800 --> 00:41:19,240
use that is to instantiate the

00:41:16,870 --> 00:41:22,119
performance object right here so our

00:41:19,240 --> 00:41:23,650
are going to be our MIDI out port to the

00:41:22,119 --> 00:41:25,930
circuit that's going to be on draw

00:41:23,650 --> 00:41:29,260
machine and the bass is going to be

00:41:25,930 --> 00:41:31,420
where mono stations out port so that's

00:41:29,260 --> 00:41:35,109
it we only need to pass it to the MIDI

00:41:31,420 --> 00:41:37,030
consumer right here and now placate as

00:41:35,109 --> 00:41:37,869
happy there is nothing crazy happening

00:41:37,030 --> 00:41:40,180
here anymore

00:41:37,869 --> 00:41:44,530
we can performance-based send message

00:41:40,180 --> 00:41:46,390
right start playing so in fact we can

00:41:44,530 --> 00:41:49,660
already demonstrate that this does

00:41:46,390 --> 00:41:51,700
something let me show you so here you

00:41:49,660 --> 00:41:53,560
can see you know two octaves of the

00:41:51,700 --> 00:41:56,109
instruments we can change the view just

00:41:53,560 --> 00:41:59,260
a little so that we see just one octave

00:41:56,109 --> 00:42:01,690
at a time and when we do you can see

00:41:59,260 --> 00:42:04,359
that those instruments also have their

00:42:01,690 --> 00:42:07,630
own internal sequencer so it has sixteen

00:42:04,359 --> 00:42:11,170
steps you can see them as well if we run

00:42:07,630 --> 00:42:15,010
our application right now with again -

00:42:11,170 --> 00:42:17,500
mal tone the clock is ticking that's

00:42:15,010 --> 00:42:20,020
this clock right here if we start

00:42:17,500 --> 00:42:22,720
playing here right you will notice that

00:42:20,020 --> 00:42:25,510
both instruments started playing we did

00:42:22,720 --> 00:42:29,530
that our code did that we are now a

00:42:25,510 --> 00:42:31,930
forwarding of clock messages and the

00:42:29,530 --> 00:42:34,510
start and the stop messages between the

00:42:31,930 --> 00:42:36,520
two synthesizers so if we stop you're

00:42:34,510 --> 00:42:38,740
gonna see that both of them stopped if

00:42:36,520 --> 00:42:40,630
they're going there started at the same

00:42:38,740 --> 00:42:42,220
time and they're going to be stopping at

00:42:40,630 --> 00:42:45,040
the same time like you can actually see

00:42:42,220 --> 00:42:47,320
that the play button here gets bright

00:42:45,040 --> 00:42:49,510
green when it plays and so does this one

00:42:47,320 --> 00:42:52,420
even though I'm not pressing it right so

00:42:49,510 --> 00:42:54,099
they are in fact in perfect sync which

00:42:52,420 --> 00:42:57,160
is great in fact you can change the

00:42:54,099 --> 00:43:01,030
tempo right here like 1:30 in this kind

00:42:57,160 --> 00:43:03,910
of lo-fi in display here composed of

00:43:01,030 --> 00:43:07,119
those buttons can be changed to be not

00:43:03,910 --> 00:43:10,000
just 1:30 we can make it 1 you know or

00:43:07,119 --> 00:43:12,670
240 you can see that this sequenza right

00:43:10,000 --> 00:43:15,640
here now it goes faster and if we go

00:43:12,670 --> 00:43:18,280
back and just do a very slow tempo you

00:43:15,640 --> 00:43:21,160
will see that the sequence advances way

00:43:18,280 --> 00:43:23,349
slower so this is great we are in fact

00:43:21,160 --> 00:43:25,480
already doing productive network

00:43:23,349 --> 00:43:27,780
programming with just MIDI right which

00:43:25,480 --> 00:43:31,000
is a very simple networking protocol

00:43:27,780 --> 00:43:33,849
using Python but interacting with actual

00:43:31,000 --> 00:43:37,599
music hardware but still I promised you

00:43:33,849 --> 00:43:42,550
sound and there were no sounds let's fix

00:43:37,599 --> 00:43:45,400
that so now finally we are introducing a

00:43:42,550 --> 00:43:48,520
very low-level time halting drum a

00:43:45,400 --> 00:43:50,320
machine it doesn't have any tempo sync

00:43:48,520 --> 00:43:52,780
yet because that would be a little too

00:43:50,320 --> 00:43:55,359
much for just the right moment to

00:43:52,780 --> 00:43:57,609
explain this we're gonna be building on

00:43:55,359 --> 00:44:00,400
top of what we have now just in a second

00:43:57,609 --> 00:44:03,010
so what is the drum machine well if we

00:44:00,400 --> 00:44:06,190
press play the start message is being

00:44:03,010 --> 00:44:08,470
sent right so we already had this code

00:44:06,190 --> 00:44:11,740
in this code and this code there already

00:44:08,470 --> 00:44:15,550
to synchronize our clock with the other

00:44:11,740 --> 00:44:20,050
synthesizer power we also do now as a

00:44:15,550 --> 00:44:22,599
new feat is to create a task for the

00:44:20,050 --> 00:44:26,609
drum machine if no task was created yet

00:44:22,599 --> 00:44:30,339
and if we stress stop we would like the

00:44:26,609 --> 00:44:33,910
task to be cancelled the drum set to

00:44:30,339 --> 00:44:36,130
none and again just as if we cancelled

00:44:33,910 --> 00:44:37,510
the entire program we want to silence

00:44:36,130 --> 00:44:40,420
the drum machine

00:44:37,510 --> 00:44:43,630
so that is actually how you would

00:44:40,420 --> 00:44:45,300
schedule tasks the background tasks to

00:44:43,630 --> 00:44:48,160
run on isn't caio

00:44:45,300 --> 00:44:50,109
regardless of application so if you have

00:44:48,160 --> 00:44:52,240
networking applications you would do the

00:44:50,109 --> 00:44:54,280
same if you want to do sub processing in

00:44:52,240 --> 00:44:57,550
the background you would do the same so

00:44:54,280 --> 00:45:01,030
this is a reusable our technique right

00:44:57,550 --> 00:45:03,280
now create a task that task is just a

00:45:01,030 --> 00:45:05,170
core routine and if you're done with it

00:45:03,280 --> 00:45:08,170
and it's actually running forever you

00:45:05,170 --> 00:45:10,450
can cancel it but some tasks are going

00:45:08,170 --> 00:45:12,190
to actually have a natural end you would

00:45:10,450 --> 00:45:14,650
expect them to return some value or what

00:45:12,190 --> 00:45:17,170
not in this case you can just join those

00:45:14,650 --> 00:45:19,720
tasks wait for them are with other async

00:45:17,170 --> 00:45:22,900
i/o functions to gather the results that

00:45:19,720 --> 00:45:24,720
they received so create task what does

00:45:22,900 --> 00:45:26,970
it actually create

00:45:24,720 --> 00:45:30,270
some background loop that we are using

00:45:26,970 --> 00:45:32,160
here that background loop is very simple

00:45:30,270 --> 00:45:36,150
even though there's a few just a few

00:45:32,160 --> 00:45:38,760
lines here the lines are kind of

00:45:36,150 --> 00:45:41,100
required because there is a note on

00:45:38,760 --> 00:45:44,070
event and there is a note off event

00:45:41,100 --> 00:45:47,310
right we always want to lift our finger

00:45:44,070 --> 00:45:49,980
from whatever keyboard we're using so in

00:45:47,310 --> 00:45:53,520
this particular example we are playing a

00:45:49,980 --> 00:45:55,920
note on event on a given channel of a

00:45:53,520 --> 00:45:57,480
given note with a given volume then we

00:45:55,920 --> 00:45:59,820
are going to wait for some time and

00:45:57,480 --> 00:46:01,980
we're going to lift our finger again

00:45:59,820 --> 00:46:04,200
with the same configuration and again

00:46:01,980 --> 00:46:08,700
wait some time just so that the events

00:46:04,200 --> 00:46:10,350
are kind of spaced out evenly the

00:46:08,700 --> 00:46:12,750
channel that we're playing on is MIDI

00:46:10,350 --> 00:46:15,630
channel 10 it's 9 because it's numbered

00:46:12,750 --> 00:46:18,210
from 0 that's usually drums like a

00:46:15,630 --> 00:46:21,810
pretty much in any MIDI implementation

00:46:18,210 --> 00:46:27,090
out there right now note 60 so numbers

00:46:21,810 --> 00:46:30,170
are just you know from 0 to 127 note 60

00:46:27,090 --> 00:46:33,300
is just a bass drum on my particular

00:46:30,170 --> 00:46:35,190
drum machine those numbers actually will

00:46:33,300 --> 00:46:37,110
be different between different drum

00:46:35,190 --> 00:46:39,840
machines you pretty much have to try

00:46:37,110 --> 00:46:42,750
this out yourself or read the manual but

00:46:39,840 --> 00:46:45,600
who does that are to learn which drum is

00:46:42,750 --> 00:46:48,180
which note in this particular case 60 is

00:46:45,600 --> 00:46:50,790
going to be our base drum bowling 127

00:46:48,180 --> 00:46:53,160
pretty loud ok excited to actually hear

00:46:50,790 --> 00:46:56,820
how it sounds like I am let's do it

00:46:53,160 --> 00:46:59,010
ok nothing is happening why because this

00:46:56,820 --> 00:47:01,610
thing controls our performance we need

00:46:59,010 --> 00:47:01,610
to press play

00:47:02,390 --> 00:47:10,250
so partial success we can hear that

00:47:06,710 --> 00:47:13,250
there is a bass drum sound and uniform

00:47:10,250 --> 00:47:15,410
speed but that speed is not really the

00:47:13,250 --> 00:47:18,200
same as the speed of the sequence right

00:47:15,410 --> 00:47:21,140
and if we change the tempo here that

00:47:18,200 --> 00:47:23,780
does nothing actually you can see that

00:47:21,140 --> 00:47:27,170
the temple should be changing but our

00:47:23,780 --> 00:47:28,970
coroutine so far is ignoring the changes

00:47:27,170 --> 00:47:32,480
that we're doing so let me just go to

00:47:28,970 --> 00:47:35,240
one authority right here why is the

00:47:32,480 --> 00:47:37,280
tempo not changing well because we're

00:47:35,240 --> 00:47:40,070
just sleeping here for half a second

00:47:37,280 --> 00:47:42,500
pretty much ignoring the clock signals

00:47:40,070 --> 00:47:44,600
for our purposes the only thing that

00:47:42,500 --> 00:47:47,420
we're doing with the clock message

00:47:44,600 --> 00:47:50,090
whenever it comes is to just forward it

00:47:47,420 --> 00:47:53,000
to the other synthesizer what we would

00:47:50,090 --> 00:47:57,200
like to do instead is to actually make

00:47:53,000 --> 00:48:01,820
use of it in our code so the simplest

00:47:57,200 --> 00:48:05,990
way to do this would be to just record

00:48:01,820 --> 00:48:12,830
the time that happens between our two

00:48:05,990 --> 00:48:15,560
clock messages and doing this kind of

00:48:12,830 --> 00:48:18,590
recorded Delta which is going to help us

00:48:15,560 --> 00:48:20,360
our calculated attempt before we get

00:48:18,590 --> 00:48:23,210
there the one thing that I did here I

00:48:20,360 --> 00:48:27,800
see is I extracted this rather

00:48:23,210 --> 00:48:30,470
cumbersome you know four line way to

00:48:27,800 --> 00:48:34,040
process a single note with a note on and

00:48:30,470 --> 00:48:35,900
note off to a method on the performance

00:48:34,040 --> 00:48:38,750
class because we're going to be playing

00:48:35,900 --> 00:48:41,780
very many notes very soon from now so it

00:48:38,750 --> 00:48:44,960
would be annoying to have to always set

00:48:41,780 --> 00:48:47,270
it up you know using four lines every

00:48:44,960 --> 00:48:51,500
time it would just look very busy

00:48:47,270 --> 00:48:54,860
instead by extracting those two methods

00:48:51,500 --> 00:48:58,430
right here what we are able to do is to

00:48:54,860 --> 00:49:02,450
sequence notes with a single line each

00:48:58,430 --> 00:49:05,360
that is way better okay but let's go get

00:49:02,450 --> 00:49:09,770
back to talking about the timing of

00:49:05,360 --> 00:49:11,300
events so to make use of the clock

00:49:09,770 --> 00:49:14,630
signal that we are already receiving

00:49:11,300 --> 00:49:18,320
from the circuit what we need to do is

00:49:14,630 --> 00:49:20,780
just listen to the clock messages if

00:49:18,320 --> 00:49:23,150
there were two consecutive clock

00:49:20,780 --> 00:49:26,000
messages then our t-midi already

00:49:23,150 --> 00:49:28,040
calculated the timing between them that

00:49:26,000 --> 00:49:30,770
is the timing without any latency in

00:49:28,040 --> 00:49:33,530
python so that is good timing and we can

00:49:30,770 --> 00:49:36,440
just save this as the pulse Delta right

00:49:33,530 --> 00:49:38,930
so that is the Delta between two clock

00:49:36,440 --> 00:49:42,170
signals that is cool we already know

00:49:38,930 --> 00:49:44,840
that there's 24 pulses per quarter note

00:49:42,170 --> 00:49:47,930
so we can start thinking and musical

00:49:44,840 --> 00:49:52,130
terms now um we are going to be using

00:49:47,930 --> 00:49:55,250
this post Delta right here to make sure

00:49:52,130 --> 00:49:55,970
that we are waiting for a given amount

00:49:55,250 --> 00:49:59,000
of time

00:49:55,970 --> 00:50:01,550
every time so let's see if that

00:49:59,000 --> 00:50:05,170
particular pulse Delta does anything

00:50:01,550 --> 00:50:10,750
interesting in our particular program

00:50:05,170 --> 00:50:13,089
so hey I uptown the other idea sounds

00:50:10,750 --> 00:50:17,200
faster so that is probably a good thing

00:50:13,089 --> 00:50:19,299
and we change the tempo right here we

00:50:17,200 --> 00:50:21,970
can actually you should be able to see

00:50:19,299 --> 00:50:26,440
this as well all right we're changing

00:50:21,970 --> 00:50:31,930
the tempo and our coroutine speeds up

00:50:26,440 --> 00:50:34,690
the notes or slows them down that is

00:50:31,930 --> 00:50:36,599
good that is exactly what we needed so

00:50:34,690 --> 00:50:40,000
now we are ready to actually start

00:50:36,599 --> 00:50:42,579
typing some more interesting things into

00:50:40,000 --> 00:50:45,099
our sequencer is it actually fun to use

00:50:42,579 --> 00:50:48,520
is it very cumbersome to write any

00:50:45,099 --> 00:50:51,819
musical code with it well let's see in

00:50:48,520 --> 00:50:54,730
my opinion it's actually very easy ah so

00:50:51,819 --> 00:50:57,040
how would you actually add more notes to

00:50:54,730 --> 00:50:59,710
it well how about we just add another

00:50:57,040 --> 00:51:02,829
one right here since we already have

00:50:59,710 --> 00:51:05,440
some helper variables right there let's

00:51:02,829 --> 00:51:08,049
say snare drum or closed hi-hat or open

00:51:05,440 --> 00:51:11,740
hi-hat we can already do something like

00:51:08,049 --> 00:51:14,559
say snare drum and play for another 24

00:51:11,740 --> 00:51:17,650
pulses right um you know I hopefully

00:51:14,559 --> 00:51:19,480
name this poses here so maybe let's redo

00:51:17,650 --> 00:51:23,200
this so that we still know what is going

00:51:19,480 --> 00:51:25,329
on so this should already sound a bit a

00:51:23,200 --> 00:51:29,799
tiny bit more interesting than the last

00:51:25,329 --> 00:51:31,930
time in fact that's exactly what is

00:51:29,799 --> 00:51:35,940
happening we hear a bass drum a snare

00:51:31,930 --> 00:51:35,940
drum a bass drum a snare drum

00:51:35,970 --> 00:51:43,510
so can we make this even more

00:51:38,820 --> 00:51:45,910
complicated yes and without much kind of

00:51:43,510 --> 00:51:47,680
additional work so one particular thing

00:51:45,910 --> 00:51:50,200
that our dance music very often

00:51:47,680 --> 00:51:52,810
implements is that the bass drum always

00:51:50,200 --> 00:51:55,510
hits with on every quarter note here we

00:51:52,810 --> 00:51:57,370
are just hitting the snare drum and not

00:51:55,510 --> 00:51:59,800
hitting the bass drum in that particular

00:51:57,370 --> 00:52:02,410
moment we would need to fix this like

00:51:59,800 --> 00:52:05,380
how about we made the bass drum always

00:52:02,410 --> 00:52:08,350
hit and the snare drum always hit like

00:52:05,380 --> 00:52:10,540
well just hit every second note so we

00:52:08,350 --> 00:52:13,420
would want to just have two while loops

00:52:10,540 --> 00:52:15,700
right like one right here and one that

00:52:13,420 --> 00:52:20,440
would actually be waiting for us

00:52:15,700 --> 00:52:24,010
ah for quite a bit and later on play the

00:52:20,440 --> 00:52:25,690
snare drum so to achieve this ah we

00:52:24,010 --> 00:52:27,880
actually cannot write these two loops

00:52:25,690 --> 00:52:29,890
like this one because the first one is

00:52:27,880 --> 00:52:31,870
going to just play forever we're not

00:52:29,890 --> 00:52:34,600
gonna get to the other one but what we

00:52:31,870 --> 00:52:37,680
can do is just create another async to

00:52:34,600 --> 00:52:42,849
have all this the bass drum

00:52:37,680 --> 00:52:50,220
and create yet another one async deaf

00:52:42,849 --> 00:52:53,609
snare drum and this one will both a

00:52:50,220 --> 00:52:57,670
weight on that quarter note but also

00:52:53,609 --> 00:53:00,280
performance weight so just wait 24

00:52:57,670 --> 00:53:03,250
ounces for us so that it hits every

00:53:00,280 --> 00:53:05,920
other note whereas this bass drum is

00:53:03,250 --> 00:53:08,740
going to hit always right one thing that

00:53:05,920 --> 00:53:11,859
now the code is going to be unhappy

00:53:08,740 --> 00:53:15,280
about is that performance does not have

00:53:11,859 --> 00:53:18,430
an attribute oh wait we need to extract

00:53:15,280 --> 00:53:21,010
it so now what we were using here is

00:53:18,430 --> 00:53:23,980
async I'll sleep directly but we also

00:53:21,010 --> 00:53:26,530
want the ability to just rest and wait

00:53:23,980 --> 00:53:28,990
for a given amount of pauses so it would

00:53:26,530 --> 00:53:32,109
be good to extract this so let's just

00:53:28,990 --> 00:53:35,020
stash our changes in the sequencer for

00:53:32,109 --> 00:53:39,490
now and switch to yet another class

00:53:35,020 --> 00:53:44,290
right here and pop the stuff changes so

00:53:39,490 --> 00:53:47,380
now what we have in our code is both the

00:53:44,290 --> 00:53:50,520
weight method and the bass drum and

00:53:47,380 --> 00:53:53,410
snare drum that we implemented now um

00:53:50,520 --> 00:53:55,869
kind of my PI is happy but the only

00:53:53,410 --> 00:53:58,299
thing that we forgot to do nothing would

00:53:55,869 --> 00:54:03,099
happen if we didn't fix that is that now

00:53:58,299 --> 00:54:06,540
we have to await on async IO gather to

00:54:03,099 --> 00:54:12,030
make both the bass drum and snare drum

00:54:06,540 --> 00:54:12,030
play together let's see if that doesn't

00:54:14,280 --> 00:54:19,109
okay you can already hear both the bass

00:54:17,410 --> 00:54:22,240
drum and the snare drum playing together

00:54:19,109 --> 00:54:23,960
but they're playing together but not

00:54:22,240 --> 00:54:26,090
really insane

00:54:23,960 --> 00:54:28,930
this doesn't sound like a good drummer

00:54:26,090 --> 00:54:31,550
it sound like a bad drummer actually

00:54:28,930 --> 00:54:33,770
there's sometimes in sync and sometimes

00:54:31,550 --> 00:54:36,350
they just get out of sync you don't

00:54:33,770 --> 00:54:40,040
really know why so let's think about

00:54:36,350 --> 00:54:41,900
this why would that be well and to

00:54:40,040 --> 00:54:45,710
answer this question we need to talk for

00:54:41,900 --> 00:54:47,420
just a second on clock skew so what

00:54:45,710 --> 00:54:49,040
happens in Hardware instruments very

00:54:47,420 --> 00:54:51,860
often in sometimes that's even in

00:54:49,040 --> 00:54:53,390
production professional vendored

00:54:51,860 --> 00:54:58,240
instruments that you're going to be on

00:54:53,390 --> 00:55:02,510
buying is that if there is a agreed-upon

00:54:58,240 --> 00:55:05,930
tempo right unlike 125 beats per minute

00:55:02,510 --> 00:55:08,600
if that tempo is agreed upon but we

00:55:05,930 --> 00:55:10,910
never agreed on synchronizing when the

00:55:08,600 --> 00:55:13,700
first beat should be playing those

00:55:10,910 --> 00:55:15,790
things can go out of phase and on top of

00:55:13,700 --> 00:55:21,590
this there's gonna be micro changes

00:55:15,790 --> 00:55:23,780
between the what is meant by 125 BPM in

00:55:21,590 --> 00:55:27,350
one hardware instrument versus another

00:55:23,780 --> 00:55:30,290
so on top of the phase shift you can

00:55:27,350 --> 00:55:34,940
also just have things getting in and out

00:55:30,290 --> 00:55:36,740
of sync kind of randomly to the musical

00:55:34,940 --> 00:55:39,230
you know a kind of ear that we are

00:55:36,740 --> 00:55:42,860
having so this is not very good what we

00:55:39,230 --> 00:55:45,620
need here is a way to synchronize the

00:55:42,860 --> 00:55:49,220
first beat to make sure that we are

00:55:45,620 --> 00:55:52,040
going to get you know perfect sync with

00:55:49,220 --> 00:55:54,140
us can we do this yes this is actually

00:55:52,040 --> 00:55:57,140
not very hard again and we are going to

00:55:54,140 --> 00:56:00,590
be using a very fundamental piece of a

00:55:57,140 --> 00:56:04,340
sync IO that piece is called future so

00:56:00,590 --> 00:56:08,380
looking at futures they are a way to

00:56:04,340 --> 00:56:12,320
promise somebody that there's gonna be a

00:56:08,380 --> 00:56:15,350
result for us in the future right not

00:56:12,320 --> 00:56:17,450
not yet for example if two core routines

00:56:15,350 --> 00:56:19,480
like doing the left line and the right

00:56:17,450 --> 00:56:21,860
line in the pictures right there

00:56:19,480 --> 00:56:23,870
interact with one another and the first

00:56:21,860 --> 00:56:27,620
one and doesn't have the result yet it

00:56:23,870 --> 00:56:29,660
can give somebody a future instead then

00:56:27,620 --> 00:56:33,530
the other coding can await on that

00:56:29,660 --> 00:56:36,230
future so as long as there is no result

00:56:33,530 --> 00:56:39,440
already yet we are awaiting time

00:56:36,230 --> 00:56:42,290
down right we are awaiting and if the

00:56:39,440 --> 00:56:45,980
first quarantine finally has a result it

00:56:42,290 --> 00:56:48,380
calls set result and then async IO stops

00:56:45,980 --> 00:56:51,500
waiting on F it already knows oh there's

00:56:48,380 --> 00:56:53,840
a result so it assigns the result to the

00:56:51,500 --> 00:56:55,730
result variable right here and we can

00:56:53,840 --> 00:56:58,880
use it right so in this particular

00:56:55,730 --> 00:57:00,859
example we can see the design of a

00:56:58,880 --> 00:57:03,609
future or what we actually will want

00:57:00,859 --> 00:57:06,740
from futures for our purpose is

00:57:03,609 --> 00:57:09,830
something like this instead of just

00:57:06,740 --> 00:57:11,810
having a wait are just randomly without

00:57:09,830 --> 00:57:14,150
consulting anybody isn't kind of

00:57:11,810 --> 00:57:17,300
sleeping or the number of pulses what

00:57:14,150 --> 00:57:20,869
we're going to be asking for is please

00:57:17,300 --> 00:57:24,859
count for pulses for me right and our

00:57:20,869 --> 00:57:28,520
kind of metronome functionality will say

00:57:24,859 --> 00:57:31,160
okay fine I will count for pulses for

00:57:28,520 --> 00:57:33,950
you return in a future and now our

00:57:31,160 --> 00:57:37,850
synthesizer our sequencer is going to

00:57:33,950 --> 00:57:41,510
wait and it will only receive the result

00:57:37,850 --> 00:57:44,690
which we kind of ignore here when four

00:57:41,510 --> 00:57:48,050
counts passed right so the count is zero

00:57:44,690 --> 00:57:49,820
right now so our counter is going to set

00:57:48,050 --> 00:57:51,730
the result of the future the future

00:57:49,820 --> 00:57:54,670
resolved

00:57:51,730 --> 00:57:56,680
so that's essentially the design that we

00:57:54,670 --> 00:57:59,589
need to do so using futures for

00:57:56,680 --> 00:58:02,290
synchronization ah and this is a rather

00:57:59,589 --> 00:58:04,510
nice technique to make sure things

00:58:02,290 --> 00:58:06,700
happen in unison they obviously don't

00:58:04,510 --> 00:58:09,280
happen exactly at the same time but with

00:58:06,700 --> 00:58:12,520
the async i/o event loops resolution

00:58:09,280 --> 00:58:17,380
that's plenty enough for our purposes

00:58:12,520 --> 00:58:20,079
with coding right so let me just switch

00:58:17,380 --> 00:58:25,000
you to the screen where you can see the

00:58:20,079 --> 00:58:29,109
code cool let's replace our naive

00:58:25,000 --> 00:58:32,230
implementation of you know poles Delta

00:58:29,109 --> 00:58:35,730
with the metronome that I described to

00:58:32,230 --> 00:58:40,680
you so again let's stash our wonderful

00:58:35,730 --> 00:58:44,589
very complicated sequence of drums and

00:58:40,680 --> 00:58:48,400
switch to another step which already is

00:58:44,589 --> 00:58:50,890
using the metronome so the metronome is

00:58:48,400 --> 00:58:53,020
something that is going to take a tick

00:58:50,890 --> 00:58:54,730
from us whenever a clock is happening

00:58:53,020 --> 00:58:57,550
the only other thing that we need to do

00:58:54,730 --> 00:58:59,470
is to reset it whenever we press start

00:58:57,550 --> 00:59:01,960
so that everybody knows that we plus

00:58:59,470 --> 00:59:04,630
start right now so now is the first note

00:59:01,960 --> 00:59:08,109
we should be starting from this moment

00:59:04,630 --> 00:59:10,450
so it is some metronome class right

00:59:08,109 --> 00:59:13,660
let's see how this is implemented it is

00:59:10,450 --> 00:59:15,220
just a metronome every object of

00:59:13,660 --> 00:59:20,020
performance that we're creating is

00:59:15,220 --> 00:59:22,119
getting one automatically due to the use

00:59:20,020 --> 00:59:24,670
of the factory a functionality of

00:59:22,119 --> 00:59:26,710
patters and that is essentially

00:59:24,670 --> 00:59:29,140
everything that we need to do but here

00:59:26,710 --> 00:59:31,270
the weight a method now instead of

00:59:29,140 --> 00:59:35,349
running async I of sleep naively

00:59:31,270 --> 00:59:37,839
it is running this wait for exposes the

00:59:35,349 --> 00:59:40,180
architecture of the wait for exposes you

00:59:37,839 --> 00:59:42,790
have already seen that is exactly what I

00:59:40,180 --> 00:59:46,420
showed you on the slide with you know

00:59:42,790 --> 00:59:49,270
the kind of the design for counting for

00:59:46,420 --> 00:59:51,940
is that before pulses and resetting a

00:59:49,270 --> 00:59:54,700
result on the future in fact we can see

00:59:51,940 --> 00:59:57,849
this clicking through to it right here

00:59:54,700 --> 01:00:01,170
so for waiting for X pulses we're

00:59:57,849 --> 01:00:04,750
creating a lock a countdown right and

01:00:01,170 --> 01:00:05,140
just a weight on it so when those kinds

01:00:04,750 --> 01:00:08,740
of

01:00:05,140 --> 01:00:13,269
those numbers of bosses you know passed

01:00:08,740 --> 01:00:15,309
we're gonna return and in turn this how

01:00:13,269 --> 01:00:17,380
it is going to return so everything

01:00:15,309 --> 01:00:19,599
composes very well together everything

01:00:17,380 --> 01:00:22,150
now works perfectly fine so the

01:00:19,599 --> 01:00:24,690
countdown is a subclass of future that

01:00:22,150 --> 01:00:29,049
does this functionality of just you know

01:00:24,690 --> 01:00:31,089
counting down with each tick finally

01:00:29,049 --> 01:00:33,250
when the value is zero let's just set

01:00:31,089 --> 01:00:35,349
the result and we're done right the

01:00:33,250 --> 01:00:39,160
metronome is kind of like a multi

01:00:35,349 --> 01:00:41,950
countdown in by which I mean that it has

01:00:39,160 --> 01:00:45,010
all the countdowns in our application so

01:00:41,950 --> 01:00:47,859
we can multiplex this right so there is

01:00:45,010 --> 01:00:50,920
going to be the clock signal sent from

01:00:47,859 --> 01:00:53,829
the circuit our and just received by us

01:00:50,920 --> 01:00:56,289
once and we tick the metronome but

01:00:53,829 --> 01:00:59,529
doesn't matter how many countdowns are

01:00:56,289 --> 01:01:01,869
currently active with the tick we are

01:00:59,529 --> 01:01:03,430
going through all the countdowns and if

01:01:01,869 --> 01:01:06,039
a given countdown is done we're just

01:01:03,430 --> 01:01:08,319
removing it from the currently happening

01:01:06,039 --> 01:01:10,630
once and that's it like you know that's

01:01:08,319 --> 01:01:12,789
something that enables us to just tick

01:01:10,630 --> 01:01:15,160
in one place but wait in very many

01:01:12,789 --> 01:01:16,390
places so it's a rather short class you

01:01:15,160 --> 01:01:18,309
can see it on github if you're

01:01:16,390 --> 01:01:21,460
interested in more details about it but

01:01:18,309 --> 01:01:25,950
that's all the magic that we need here

01:01:21,460 --> 01:01:29,349
to make sure that our program now is

01:01:25,950 --> 01:01:32,710
fully in a sink this is already going to

01:01:29,349 --> 01:01:36,960
be something that you know kind of past

01:01:32,710 --> 01:01:40,690
production level synchronization so

01:01:36,960 --> 01:01:43,259
let's see if that actually works to any

01:01:40,690 --> 01:01:43,259
extent

01:01:43,760 --> 01:01:51,890
okay just one place right now the snare

01:01:47,550 --> 01:01:55,620
is not playing because we forgot to

01:01:51,890 --> 01:01:58,170
unstitch our change and by we of course

01:01:55,620 --> 01:02:00,030
I mean me but I love to share

01:01:58,170 --> 01:02:01,860
responsibility for my failures with

01:02:00,030 --> 01:02:04,530
others so it's your responsibility as

01:02:01,860 --> 01:02:06,870
well now okay now we have the snare drum

01:02:04,530 --> 01:02:11,280
as well so that's my success because I

01:02:06,870 --> 01:02:14,100
did that let's go okay they're playing

01:02:11,280 --> 01:02:17,850
can we actually go and speed this up and

01:02:14,100 --> 01:02:21,270
see their song I think they're in

01:02:17,850 --> 01:02:31,880
perfect sync even up to 40 beats per

01:02:21,270 --> 01:02:35,880
minute they're in perfect sing alright

01:02:31,880 --> 01:02:38,910
so that's it for production level clock

01:02:35,880 --> 01:02:42,450
synchronization that solves the clock

01:02:38,910 --> 01:02:46,080
skew but we still have flick eight being

01:02:42,450 --> 01:02:48,390
unhappy with our sad closed and open

01:02:46,080 --> 01:02:51,570
hi-hat so let's just make it happy

01:02:48,390 --> 01:02:55,680
finally and just create some high hats

01:02:51,570 --> 01:02:59,580
for it let's go flick eight we will make

01:02:55,680 --> 01:03:04,200
you stop complaining right now so let's

01:02:59,580 --> 01:03:06,780
await on performance play drum closed

01:03:04,200 --> 01:03:09,870
hi-hat just for six pulses so that's

01:03:06,780 --> 01:03:13,170
gonna be pretty fast do this twice and

01:03:09,870 --> 01:03:16,110
now a little longer we're gonna go with

01:03:13,170 --> 01:03:18,210
an open hat nothing would happen if we

01:03:16,110 --> 01:03:20,300
weren't gathering that thing too so

01:03:18,210 --> 01:03:25,730
let's get that's what

01:03:20,300 --> 01:03:29,390
what do you have here okay a very very

01:03:25,730 --> 01:03:33,650
typical dance way of interacting with

01:03:29,390 --> 01:03:36,710
high hats but you know what I'm annoyed

01:03:33,650 --> 01:03:39,650
at I like this the stream of event notes

01:03:36,710 --> 01:03:42,560
which are mostly just clock signals lets

01:03:39,650 --> 01:03:44,570
us kind of lose information about any

01:03:42,560 --> 01:03:47,330
other particular interesting event that

01:03:44,570 --> 01:03:50,390
is happening so I don't want that let's

01:03:47,330 --> 01:03:54,500
make a little change to make this a

01:03:50,390 --> 01:03:57,370
little more kind of graphically pleasing

01:03:54,500 --> 01:04:00,410
and kind of show us more good

01:03:57,370 --> 01:04:04,370
information at the same time so see how

01:04:00,410 --> 01:04:08,060
we're just you know kind of very easily

01:04:04,370 --> 01:04:10,430
naively echoing whatever event is

01:04:08,060 --> 01:04:13,820
happening right now what we could do

01:04:10,430 --> 01:04:16,340
instead is to recognize that if we had

01:04:13,820 --> 01:04:18,470
two consecutive clock signals see you

01:04:16,340 --> 01:04:20,300
use this naively before two counting

01:04:18,470 --> 01:04:24,740
post Delta but we can use that same

01:04:20,300 --> 01:04:26,750
thing to say oh if we are in a cop Delta

01:04:24,740 --> 01:04:28,580
and the other was a cocktail Tower let's

01:04:26,750 --> 01:04:32,210
not advance to a new line but just

01:04:28,580 --> 01:04:34,610
overwrite on the same line and we if we

01:04:32,210 --> 01:04:36,920
actually pop the stash right now and

01:04:34,610 --> 01:04:38,299
start our program what are we going to

01:04:36,920 --> 01:04:41,689
get

01:04:38,299 --> 01:04:44,599
that looks way nicer now we don't lose

01:04:41,689 --> 01:04:47,599
our place that easily we're gonna always

01:04:44,599 --> 01:04:50,029
see the clock signal just right there as

01:04:47,599 --> 01:04:52,459
one event unless there is another event

01:04:50,029 --> 01:04:58,249
so if I actually played a few notes for

01:04:52,459 --> 01:05:00,319
you see like those notes appear as nice

01:04:58,249 --> 01:05:02,179
events and now you can actually decipher

01:05:00,319 --> 01:05:04,969
them before they would just kind of

01:05:02,179 --> 01:05:07,880
flower float away very quickly so now if

01:05:04,969 --> 01:05:10,789
we start you will also see a 250 and 250

01:05:07,880 --> 01:05:17,709
- message being sent

01:05:10,789 --> 01:05:17,709
so yeah 250 let's start 250 - lets stop

01:05:18,400 --> 01:05:23,839
way nicer this is going to make our

01:05:21,170 --> 01:05:25,880
later experiments much easier

01:05:23,839 --> 01:05:27,890
let's just stop the process right here

01:05:25,880 --> 01:05:31,099
and just kind of play with this for a

01:05:27,890 --> 01:05:33,650
second so whenever I play with advanced

01:05:31,099 --> 01:05:39,289
Python programs very often I end up I

01:05:33,650 --> 01:05:42,309
will both importing itertools and random

01:05:39,289 --> 01:05:45,979
so let's just do both like right away

01:05:42,309 --> 01:05:48,439
and use them somehow so one thing that

01:05:45,979 --> 01:05:51,469
we didn't do yet but we can now and we

01:05:48,439 --> 01:05:55,309
will is kind of play with the volume of

01:05:51,469 --> 01:06:00,109
the play drum so here the volume r is

01:05:55,309 --> 01:06:02,679
always so 127 if we don't specify it but

01:06:00,109 --> 01:06:05,900
what if we actually had some kind of

01:06:02,679 --> 01:06:13,670
volume specified right here so we could

01:06:05,900 --> 01:06:15,859
have for example 127 on 95 and 63 so

01:06:13,670 --> 01:06:19,999
those are just three and to make this

01:06:15,859 --> 01:06:22,190
actually do a thing we can now do a

01:06:19,999 --> 01:06:27,910
volume

01:06:22,190 --> 01:06:33,430
equals itertools cycle through volumes

01:06:27,910 --> 01:06:33,430
so just having them cycle already

01:06:34,150 --> 01:06:39,770
already causes us to have issues because

01:06:37,520 --> 01:06:42,440
I need to put this obviously as an

01:06:39,770 --> 01:06:46,880
iterator it's itertools so we need a

01:06:42,440 --> 01:06:49,819
volume in a little cycle that's the

01:06:46,880 --> 01:06:51,859
danger of narrating and coding at the

01:06:49,819 --> 01:06:53,450
same time like you are skipping steps

01:06:51,859 --> 01:06:55,670
that's why I didn't want to do the

01:06:53,450 --> 01:06:59,420
entire presentation like this that would

01:06:55,670 --> 01:07:02,349
be very annoying to you as a witness to

01:06:59,420 --> 01:07:06,470
that failure anyway that is already

01:07:02,349 --> 01:07:09,339
cycling through volumes let's see how

01:07:06,470 --> 01:07:09,339
that sounds

01:07:10,340 --> 01:07:22,610
[Music]

01:07:18,340 --> 01:07:24,680
so it already creates this kind of echo

01:07:22,610 --> 01:07:27,470
effect every three notes for us but

01:07:24,680 --> 01:07:32,060
it'll probably be easier to hear if it's

01:07:27,470 --> 01:07:34,250
also out of synch with the snare drum

01:07:32,060 --> 01:07:36,800
notes what that is typically called is

01:07:34,250 --> 01:07:38,390
polyrhythm so the different kinds of

01:07:36,800 --> 01:07:41,240
tracks that you're having the different

01:07:38,390 --> 01:07:44,690
are you know instruments are going to be

01:07:41,240 --> 01:07:47,390
playing in different meters now on but

01:07:44,690 --> 01:07:49,910
what they will agree on is the clock so

01:07:47,390 --> 01:07:57,980
that actually already sounds rather rich

01:07:49,910 --> 01:08:00,350
with very minimal changes that's already

01:07:57,980 --> 01:08:02,750
pretty interesting right there's some

01:08:00,350 --> 01:08:06,260
richness to what we're doing and we can

01:08:02,750 --> 01:08:09,620
add even more to it if we slow down the

01:08:06,260 --> 01:08:12,620
snare drum twice right so having it not

01:08:09,620 --> 01:08:17,839
rush as it did now crease this kind of

01:08:12,620 --> 01:08:22,609
trappy you know drum track for some kind

01:08:17,839 --> 01:08:29,420
of musical tune right so now it already

01:08:22,609 --> 01:08:31,910
floats a bit slower with very little

01:08:29,420 --> 01:08:35,150
code we could obviously just tweak this

01:08:31,910 --> 01:08:40,190
further we could for example just decide

01:08:35,150 --> 01:08:43,280
that we might randomly either keep doing

01:08:40,190 --> 01:08:45,650
this here like you noticed or either

01:08:43,280 --> 01:08:47,480
skip it or just you know rest for a

01:08:45,650 --> 01:08:51,710
while so for example we could just

01:08:47,480 --> 01:08:54,680
choose like if random random it's bigger

01:08:51,710 --> 01:08:56,950
than half right so half the time we will

01:08:54,680 --> 01:08:59,930
be doing this and half the time we won't

01:08:56,950 --> 01:09:04,280
we will wait how long should we be

01:08:59,930 --> 01:09:07,609
waiting for example since this is 24 12

01:09:04,280 --> 01:09:11,240
and 12 we can just wait for say half of

01:09:07,609 --> 01:09:13,299
that so just twelve to reorder the

01:09:11,240 --> 01:09:24,279
hi-hat somehow

01:09:13,299 --> 01:09:26,620
let's see how that works now yeah so

01:09:24,279 --> 01:09:29,799
this already kind of gives us some

01:09:26,620 --> 01:09:33,250
richness of the drum track with very

01:09:29,799 --> 01:09:35,500
minimal code but it's just the drugs and

01:09:33,250 --> 01:09:39,640
the mono station stays here like a

01:09:35,500 --> 01:09:41,710
router board not doing much yes I agree

01:09:39,640 --> 01:09:44,260
with you this is not perfect we need to

01:09:41,710 --> 01:09:48,069
make use of it so to make use of it

01:09:44,260 --> 01:09:50,560
let's get to the next step let's stash

01:09:48,069 --> 01:09:55,300
our wonderful sequence right now

01:09:50,560 --> 01:09:59,460
stash and move to the next step that's

01:09:55,300 --> 01:10:03,400
gonna be the 15th step and probably the

01:09:59,460 --> 01:10:07,270
final of our play with git now we're

01:10:03,400 --> 01:10:10,120
only going to do some more coding right

01:10:07,270 --> 01:10:13,960
here in Visual Studio so we already have

01:10:10,120 --> 01:10:17,290
ia baseline let me just restore our drum

01:10:13,960 --> 01:10:21,580
track so I don't forget in having that

01:10:17,290 --> 01:10:23,650
what changed first of all we had a play

01:10:21,580 --> 01:10:26,440
a drum a high level function

01:10:23,650 --> 01:10:28,840
I created a place base a function that

01:10:26,440 --> 01:10:30,550
we can use as well so that it is just a

01:10:28,840 --> 01:10:33,880
single line that we can use to make

01:10:30,550 --> 01:10:37,300
sounds happen so that already works and

01:10:33,880 --> 01:10:39,400
now whenever we are getting our start

01:10:37,300 --> 01:10:41,770
and stop signals before we were just

01:10:39,400 --> 01:10:44,560
creating a task for the drum machine now

01:10:41,770 --> 01:10:47,830
we are also creating a task for the

01:10:44,560 --> 01:10:50,890
baseline as well and similarly when we

01:10:47,830 --> 01:10:52,990
are stopping we will be starting the

01:10:50,890 --> 01:10:55,590
drum machine canceling the drum machine

01:10:52,990 --> 01:10:58,480
and canceling the bassline now as well

01:10:55,590 --> 01:11:01,000
also silencing it so that is it

01:10:58,480 --> 01:11:03,280
essentially now the task is called

01:11:01,000 --> 01:11:06,430
analog synth because it is an analog

01:11:03,280 --> 01:11:08,680
synth and so far it doesn't do much just

01:11:06,430 --> 01:11:13,480
as our drum machine didn't do much at

01:11:08,680 --> 01:11:17,020
first it just plays one C two note every

01:11:13,480 --> 01:11:19,570
two quarter so every half note with some

01:11:17,020 --> 01:11:21,460
decay of half which is the default but

01:11:19,570 --> 01:11:24,310
we can play with that to see how that

01:11:21,460 --> 01:11:25,930
changes so there's gonna be some music

01:11:24,310 --> 01:11:26,829
intervals here that I'm gonna be using

01:11:25,930 --> 01:11:28,809
right now

01:11:26,829 --> 01:11:31,780
but don't worry if you're not not you

01:11:28,809 --> 01:11:34,179
know familiar with music theory behind

01:11:31,780 --> 01:11:36,489
this that is something that we can kind

01:11:34,179 --> 01:11:39,449
of talk over later on if you're

01:11:36,489 --> 01:11:42,219
interested I can explain in a separate

01:11:39,449 --> 01:11:44,080
communication channel so now let's see

01:11:42,219 --> 01:11:51,659
what this does

01:11:44,080 --> 01:11:51,659
[Music]

01:11:52,510 --> 01:11:58,340
okay

01:11:54,170 --> 01:12:00,770
place every second note as promised not

01:11:58,340 --> 01:12:02,480
much is happening for because of the

01:12:00,770 --> 01:12:05,160
filter or that I can play with it's

01:12:02,480 --> 01:12:08,229
already pretty rich

01:12:05,160 --> 01:12:08,229
[Music]

01:12:11,350 --> 01:12:17,890
okay but we're here to code Python so

01:12:14,770 --> 01:12:20,890
let's make the base line a bit more

01:12:17,890 --> 01:12:24,580
interesting instead so we have the base

01:12:20,890 --> 01:12:27,420
line right here just in a while loop Sol

01:12:24,580 --> 01:12:30,910
and since it's a monophonic synthesizer

01:12:27,420 --> 01:12:34,150
you might be thinking well there might

01:12:30,910 --> 01:12:37,210
not be much that we can do with this but

01:12:34,150 --> 01:12:39,760
in fact that's not exactly right what we

01:12:37,210 --> 01:12:42,220
can do is we can change the decay here

01:12:39,760 --> 01:12:44,740
to 1.0 which is something that the real

01:12:42,220 --> 01:12:47,800
musicians in real instruments are unable

01:12:44,740 --> 01:12:50,590
to do you you cannot really just you

01:12:47,800 --> 01:12:52,870
know press a note and hold it for 100%

01:12:50,590 --> 01:12:54,850
of a quarter note and switch immediately

01:12:52,870 --> 01:12:57,850
to another quarter note this will just

01:12:54,850 --> 01:13:00,160
not work for us but these are computers

01:12:57,850 --> 01:13:03,160
and we can actually do this so what we

01:13:00,160 --> 01:13:07,390
can do is again cycle through a bunch of

01:13:03,160 --> 01:13:09,580
notes and by out doing this achieve some

01:13:07,390 --> 01:13:12,850
RPG ation right like those things are

01:13:09,580 --> 01:13:14,920
usually called RPG readers so the notes

01:13:12,850 --> 01:13:17,920
that we would be interested in would be

01:13:14,920 --> 01:13:20,680
say the C one at first but later we can

01:13:17,920 --> 01:13:24,270
just say let's just add some intervals

01:13:20,680 --> 01:13:27,360
to it so if I switch for a second here

01:13:24,270 --> 01:13:31,360
if you look at the notes right there

01:13:27,360 --> 01:13:33,940
this is gonna be one C note if we add a

01:13:31,360 --> 01:13:35,600
perfect five to it we're gonna get to a

01:13:33,940 --> 01:13:37,670
note like this

01:13:35,600 --> 01:13:40,250
it's gonna be G right if we add 12

01:13:37,670 --> 01:13:42,989
instead we're gonna go from here to here

01:13:40,250 --> 01:13:45,769
it's an octave

01:13:42,989 --> 01:13:49,710
and same if we add an octave and a

01:13:45,769 --> 01:13:52,420
perfect 5 we're going to get to here

01:13:49,710 --> 01:13:55,269
so we we can do sequences like those

01:13:52,420 --> 01:13:57,400
[Music]

01:13:55,269 --> 01:14:00,519
and this is something that synthesizers

01:13:57,400 --> 01:14:03,550
are known for their very often used in

01:14:00,519 --> 01:14:05,349
combination with an RPG Haider because

01:14:03,550 --> 01:14:07,329
then you can kind of make a lot of

01:14:05,349 --> 01:14:09,760
richness just happen on the filtering

01:14:07,329 --> 01:14:12,130
and envelope side of things

01:14:09,760 --> 01:14:14,650
so let's attempt something like this we

01:14:12,130 --> 01:14:21,190
can actually add another octave right

01:14:14,650 --> 01:14:25,300
here and we can add an octave and pour

01:14:21,190 --> 01:14:31,360
here perfect for and we can an add an

01:14:25,300 --> 01:14:33,400
octave and a perfect five here and then

01:14:31,360 --> 01:14:36,999
we can just add the perfect five so it's

01:14:33,400 --> 01:14:40,420
going to be an octave perfect an octave

01:14:36,999 --> 01:14:42,969
lower than the previous one this is also

01:14:40,420 --> 01:14:44,769
kind of exciting because those are five

01:14:42,969 --> 01:14:48,460
notes so again this is going to be a

01:14:44,769 --> 01:14:54,809
polyrhythm if we cycle through it while

01:14:48,460 --> 01:14:58,510
note a note well or note in itertools

01:14:54,809 --> 01:15:02,289
cycle notes and the note they were gonna

01:14:58,510 --> 01:15:07,469
play is just note let's just make them

01:15:02,289 --> 01:15:07,469
very quick instant and see what happens

01:15:07,679 --> 01:15:11,639
again we need to start

01:15:13,460 --> 01:15:21,040
[Music]

01:15:27,330 --> 01:15:44,720
[Music]

01:15:48,380 --> 01:15:54,180
pretty cool and just one thing happens

01:15:51,330 --> 01:15:57,330
at the same time but even monophonic

01:15:54,180 --> 01:16:00,450
synthesizers can actually allow you to

01:15:57,330 --> 01:16:04,080
play a note and then play things over it

01:16:00,450 --> 01:16:07,530
so if we play a bass note right here and

01:16:04,080 --> 01:16:09,360
keep pressing the note on oh now it

01:16:07,530 --> 01:16:12,400
doesn't work because I disable sustain

01:16:09,360 --> 01:16:14,890
but if I keep sustain

01:16:12,400 --> 01:16:17,350
it keeps playing and I can play other

01:16:14,890 --> 01:16:20,110
notes over it and then stop playing them

01:16:17,350 --> 01:16:21,690
in which case it will return to the play

01:16:20,110 --> 01:16:25,250
a first to note that was being played

01:16:21,690 --> 01:16:25,250
[Music]

01:16:27,110 --> 01:16:35,150
so we can actually do this now with the

01:16:30,429 --> 01:16:39,829
RPG leader that we worked in here just

01:16:35,150 --> 01:16:42,349
again a half some coroutine for the bass

01:16:39,829 --> 01:16:46,520
note right so it's going to be the bass

01:16:42,349 --> 01:16:49,809
kind of it sounds the same but I meant a

01:16:46,520 --> 01:16:53,239
different word bass note right here and

01:16:49,809 --> 01:16:59,179
this is going to play just our bass note

01:16:53,239 --> 01:17:07,340
every say 96 pulses so performance play

01:16:59,179 --> 01:17:10,340
bass c1 every 96 pulses with the K of

01:17:07,340 --> 01:17:12,920
say like let's just leave the one point

01:17:10,340 --> 01:17:15,980
also that we hold on to it for a long

01:17:12,920 --> 01:17:21,190
long time now and now the arpeggiator

01:17:15,980 --> 01:17:23,989
that we have here they sing def our

01:17:21,190 --> 01:17:28,610
picky eater it's going to be a separate

01:17:23,989 --> 01:17:31,790
quality but since we already play C one

01:17:28,610 --> 01:17:34,250
as well here what we can do is just to

01:17:31,790 --> 01:17:37,639
make sure that there's a bit fewer of

01:17:34,250 --> 01:17:41,920
the C ones in fact we maybe want to add

01:17:37,639 --> 01:17:44,480
two octaves here and here we want to add

01:17:41,920 --> 01:17:49,190
maybe another two octaves

01:17:44,480 --> 01:17:51,020
and to keep this out of sync so that

01:17:49,190 --> 01:17:55,699
something more interesting is happening

01:17:51,020 --> 01:17:59,150
I can just add this one octave yeah so

01:17:55,699 --> 01:18:02,030
it's five and now this is going to play

01:17:59,150 --> 01:18:03,590
but if I play it with full decay that

01:18:02,030 --> 01:18:05,869
would actually not do anything

01:18:03,590 --> 01:18:08,030
interesting so let me play with half of

01:18:05,869 --> 01:18:12,170
the a so we're going to be coming back

01:18:08,030 --> 01:18:14,540
to the bass note every half and maybe

01:18:12,170 --> 01:18:19,309
interestingly if we had another note

01:18:14,540 --> 01:18:21,429
that would be say none right so rest we

01:18:19,309 --> 01:18:23,559
will not play anything so to play now

01:18:21,429 --> 01:18:27,889
thank you

01:18:23,559 --> 01:18:32,719
thank you my pine if there is no note so

01:18:27,889 --> 01:18:35,480
if note is none we don't play we want to

01:18:32,719 --> 01:18:39,860
wait so we're gonna be waiting for six

01:18:35,480 --> 01:18:40,440
but otherwise we will be able to play a

01:18:39,860 --> 01:18:42,980
note

01:18:40,440 --> 01:18:48,030
so see now my pie is happy we have

01:18:42,980 --> 01:18:50,340
successfully used the known value in a

01:18:48,030 --> 01:18:52,680
conditional so we will never get a nun

01:18:50,340 --> 01:18:55,560
right here good job

01:18:52,680 --> 01:18:58,140
cool so again if we just leave it like

01:18:55,560 --> 01:19:02,430
this nothing would play because we need

01:18:58,140 --> 01:19:09,620
a sink I own gather to do the base note

01:19:02,430 --> 01:19:14,430
and do the are PGA Tour as well cool so

01:19:09,620 --> 01:19:18,710
let me start this and start our thing

01:19:14,430 --> 01:19:18,710
and to see how this is gonna sound

01:19:29,040 --> 01:19:34,870
[Music]

01:19:31,320 --> 01:19:37,260
if there is no sustain the bass note is

01:19:34,870 --> 01:19:37,260
no plane

01:19:39,800 --> 01:19:50,760
[Music]

01:19:47,659 --> 01:19:53,460
and now interestingly we can also do

01:19:50,760 --> 01:19:55,619
stuff like and add some kind of legalize

01:19:53,460 --> 01:19:58,190
between the nodes which the synthesizer

01:19:55,619 --> 01:19:58,190
support

01:20:10,980 --> 01:20:14,040
[Music]

01:20:15,030 --> 01:20:20,800
right pretty sweet but well I would

01:20:19,030 --> 01:20:23,170
still like to show you is that this can

01:20:20,800 --> 01:20:25,750
be interactive in more than just a sense

01:20:23,170 --> 01:20:29,400
that I can just twiddle the knobs here I

01:20:25,750 --> 01:20:32,710
can actually do like influence our

01:20:29,400 --> 01:20:35,230
sequencer from code as well by playing

01:20:32,710 --> 01:20:37,389
some other keyboard like you know this

01:20:35,230 --> 01:20:39,610
particular instrument also has another

01:20:37,389 --> 01:20:42,790
sense that the silence - now right synth

01:20:39,610 --> 01:20:45,849
one it's the pink one so I can just use

01:20:42,790 --> 01:20:48,280
it as a keyboard and it would be great

01:20:45,849 --> 01:20:52,239
if that keyboard influenced what is

01:20:48,280 --> 01:20:54,489
happening on our sequencer here so let's

01:20:52,239 --> 01:20:57,909
attempt this right let's do something

01:20:54,489 --> 01:21:00,849
with that so let me first remove maybe

01:20:57,909 --> 01:21:04,480
this particular octave right here I like

01:21:00,849 --> 01:21:09,489
that perfect for but instead of just

01:21:04,480 --> 01:21:11,230
having the C C note right here like

01:21:09,489 --> 01:21:14,110
would be great if we just got whatever

01:21:11,230 --> 01:21:17,170
note I am playing on a keyboard right

01:21:14,110 --> 01:21:19,330
here so to achieve this the only thing

01:21:17,170 --> 01:21:24,219
that we need to do like fortunately is

01:21:19,330 --> 01:21:26,199
to react to another kind of message

01:21:24,219 --> 01:21:29,139
right so to do this

01:21:26,199 --> 01:21:31,480
I'll let me just type it in right here

01:21:29,139 --> 01:21:34,599
rather quickly so the thing that we need

01:21:31,480 --> 01:21:36,820
is to react to a note on event right

01:21:34,599 --> 01:21:40,840
just as you would kind of expect

01:21:36,820 --> 01:21:43,389
probably so note on and what are we

01:21:40,840 --> 01:21:46,300
gonna do with this note in this receiver

01:21:43,389 --> 01:21:48,520
well we don't actually have any access

01:21:46,300 --> 01:21:51,940
to the sequencers but we have the access

01:21:48,520 --> 01:21:54,310
to the performance object that is good

01:21:51,940 --> 01:21:58,570
enough like let's just store the last

01:21:54,310 --> 01:22:02,710
play note in that object so performance

01:21:58,570 --> 01:22:05,710
last note would be the first message

01:22:02,710 --> 01:22:08,650
editable that the other bite of that a

01:22:05,710 --> 01:22:10,810
MIDI message right so cool but now our

01:22:08,650 --> 01:22:14,940
Maya isn't happy with me because

01:22:10,810 --> 01:22:17,040
performance does not have a last note

01:22:14,940 --> 01:22:20,400
attribute yet

01:22:17,040 --> 01:22:23,910
good job then let's do that let's use

01:22:20,400 --> 01:22:27,210
our last note as just an integer here

01:22:23,910 --> 01:22:30,810
and to avoid having to you know kind of

01:22:27,210 --> 01:22:32,400
either make it optional or to deal with

01:22:30,810 --> 01:22:34,200
this when we're creating the performance

01:22:32,400 --> 01:22:38,070
object let's just say that the last node

01:22:34,200 --> 01:22:40,020
initially was zero right on uh or in

01:22:38,070 --> 01:22:43,500
fact maybe we can just say it was the

01:22:40,020 --> 01:22:48,210
same note as we had on the base C so

01:22:43,500 --> 01:22:51,330
what c1 again c1 is 36 so let's just set

01:22:48,210 --> 01:22:54,320
that to 36 like initially just so that

01:22:51,330 --> 01:22:56,700
there is some sensible about so now

01:22:54,320 --> 01:22:59,040
you're not using perfect force that is

01:22:56,700 --> 01:23:03,750
true enough about we can instead of

01:22:59,040 --> 01:23:06,980
playing c1 we can play the last note

01:23:03,750 --> 01:23:11,210
being played so we can for example do

01:23:06,980 --> 01:23:13,710
performance last note but to be able to

01:23:11,210 --> 01:23:18,330
influence this a bit faster than just

01:23:13,710 --> 01:23:22,440
every 96 pulses let's just do 24 so we

01:23:18,330 --> 01:23:24,270
can make changes more often okay so now

01:23:22,440 --> 01:23:27,690
we're playing the last note here and

01:23:24,270 --> 01:23:30,180
maybe here we can also just set up one

01:23:27,690 --> 01:23:34,290
of those notes not both like let's just

01:23:30,180 --> 01:23:38,580
ah set up one of those notes so instead

01:23:34,290 --> 01:23:45,690
of c1 we're gonna say performance last

01:23:38,580 --> 01:23:49,130
note bull so now let's check what is

01:23:45,690 --> 01:23:49,130
going to happen when we're playing

01:23:55,670 --> 01:24:05,420
[Music]

01:24:01,330 --> 01:24:07,190
we are influencing the one thing that is

01:24:05,420 --> 01:24:09,320
kind of annoying though is that at the

01:24:07,190 --> 01:24:11,600
first start of the sequence we would

01:24:09,320 --> 01:24:14,510
like to hear the bass note and not some

01:24:11,600 --> 01:24:17,170
random RPG eater so what I would like to

01:24:14,510 --> 01:24:21,380
do is to make sure that when we are

01:24:17,170 --> 01:24:25,940
iterating over our iteration like every

01:24:21,380 --> 01:24:28,130
four notes right so in the in sequence

01:24:25,940 --> 01:24:30,230
of what is playing musically we would

01:24:28,130 --> 01:24:33,050
like this to just always wait just so

01:24:30,230 --> 01:24:36,680
that we can have an opportunity to hear

01:24:33,050 --> 01:24:39,380
the main and bass sound clearly so this

01:24:36,680 --> 01:24:41,120
is interestingly again a rather simple

01:24:39,380 --> 01:24:43,280
to implement with Python because you

01:24:41,120 --> 01:24:46,190
need to just enumerate over whatever is

01:24:43,280 --> 01:24:52,550
happening here now you're gonna get an

01:24:46,190 --> 01:24:54,440
array right here and now the only

01:24:52,550 --> 01:24:58,160
that we need to do is make sure that if

01:24:54,440 --> 01:25:00,830
I we're gonna get those notes every six

01:24:58,160 --> 01:25:03,020
so there's gonna be four per quarter so

01:25:00,830 --> 01:25:08,480
if we want to do the first quarter is

01:25:03,020 --> 01:25:12,140
going to be ninety six divided by six so

01:25:08,480 --> 01:25:18,770
if we have that current if the if the

01:25:12,140 --> 01:25:24,680
note is nine or my modulo our ninety six

01:25:18,770 --> 01:25:26,780
by six ninety six by six then we're

01:25:24,680 --> 01:25:31,010
waiting otherwise we're gonna be playing

01:25:26,780 --> 01:25:32,720
our nice in our appreciation in fact we

01:25:31,010 --> 01:25:34,940
can we can actually maybe just remove

01:25:32,720 --> 01:25:38,660
that or from here so that always there's

01:25:34,940 --> 01:25:45,550
going to be some RPG ation not when we

01:25:38,660 --> 01:25:45,550
are playing okay let's see

01:26:17,760 --> 01:26:21,739
[Music]

01:26:28,940 --> 01:26:35,330
[Music]

01:26:41,040 --> 01:27:01,520
[Music]

01:26:58,040 --> 01:27:06,210
pretty cool right so the thing is this

01:27:01,520 --> 01:27:09,030
this particular thing took us an hour to

01:27:06,210 --> 01:27:11,670
write right like with an explanation so

01:27:09,030 --> 01:27:14,070
probably you know you could you could

01:27:11,670 --> 01:27:15,600
get it at the same time while trying to

01:27:14,070 --> 01:27:19,680
figure things out when they don't work

01:27:15,600 --> 01:27:21,930
and now the sequence here here is you

01:27:19,680 --> 01:27:24,630
know both for the analog synthesizer and

01:27:21,930 --> 01:27:27,390
for the drum machine fitting a single

01:27:24,630 --> 01:27:29,670
screen of code they are very easy to

01:27:27,390 --> 01:27:32,400
understand like from the perspective of

01:27:29,670 --> 01:27:35,370
an async a programmer and very hackable

01:27:32,400 --> 01:27:38,490
so you can do sequences of notes that

01:27:35,370 --> 01:27:40,710
will do some interesting are relations

01:27:38,490 --> 01:27:43,200
between intervals and between the

01:27:40,710 --> 01:27:45,180
rhythms and whatnot like with minimal

01:27:43,200 --> 01:27:48,300
trouble as a Python programmer so with

01:27:45,180 --> 01:27:51,660
this you can make self-generating music

01:27:48,300 --> 01:27:53,700
that is going to be different for hours

01:27:51,660 --> 01:27:56,360
on end you can create sessions that will

01:27:53,700 --> 01:27:59,730
not be boring but still will remain

01:27:56,360 --> 01:28:03,450
musical for hours on end so it's a very

01:27:59,730 --> 01:28:06,480
powerful technique to do programming

01:28:03,450 --> 01:28:08,550
like this so just for me to not lose

01:28:06,480 --> 01:28:12,660
what I just wrote so that you can

01:28:08,550 --> 01:28:17,010
actually use this like yourself let me

01:28:12,660 --> 01:28:21,180
just see what we're changed yes I am out

01:28:17,010 --> 01:28:27,290
on main let me just comment this for you

01:28:21,180 --> 01:28:35,790
so final stage having that Comet cool

01:28:27,290 --> 01:28:39,000
that's on that's on the PyCon branch

01:28:35,790 --> 01:28:41,940
like we can actually move to the main

01:28:39,000 --> 01:28:43,110
branch that I have here just to show you

01:28:41,940 --> 01:28:44,930
one more thing

01:28:43,110 --> 01:28:47,550
this is deleted now and it actually

01:28:44,930 --> 01:28:49,620
annoyingly maybe change to black because

01:28:47,550 --> 01:28:52,560
that's how I usually code when I'm not

01:28:49,620 --> 01:28:55,860
recording videos but I wanted to show

01:28:52,560 --> 01:28:58,620
you is that there are two things here

01:28:55,860 --> 01:29:02,700
like there is the circuits module that

01:28:58,620 --> 01:29:05,270
is doing what we were discussing here in

01:29:02,700 --> 01:29:10,099
this video butters also our red-blue

01:29:05,270 --> 01:29:13,799
module and that module in particular is

01:29:10,099 --> 01:29:15,749
enabling me to interact with my mo

01:29:13,799 --> 01:29:19,499
synthesizers that I showed you in the

01:29:15,749 --> 01:29:22,769
slide before in a ways that would be

01:29:19,499 --> 01:29:24,499
otherwise very hard to do so I already

01:29:22,769 --> 01:29:28,529
told you that a monophonic synthesizer

01:29:24,499 --> 01:29:31,439
only plays one note at a time if you

01:29:28,529 --> 01:29:33,149
have more than one of those you could

01:29:31,439 --> 01:29:35,879
actually make them switch between each

01:29:33,149 --> 01:29:38,929
other and achieve polyphony this is

01:29:35,879 --> 01:29:41,429
exactly what I did with my mock mother

01:29:38,929 --> 01:29:44,669
synthesizers that I have the modules at

01:29:41,429 --> 01:29:47,609
Edward black in the picture so just to

01:29:44,669 --> 01:29:49,349
get there you know I just named one of

01:29:47,609 --> 01:29:51,419
them red and the other blue because

01:29:49,349 --> 01:29:54,329
that's the colors of the MIDI cables I

01:29:51,419 --> 01:29:56,819
had for them and you could now use this

01:29:54,329 --> 01:29:59,699
as an instrument that you know just

01:29:56,819 --> 01:30:02,429
multiplexes MIDI messages coming from a

01:29:59,699 --> 01:30:04,769
MIDI keyboard and does very interesting

01:30:02,429 --> 01:30:06,119
musical effects as a single instrument

01:30:04,769 --> 01:30:08,339
even though you're interacting with

01:30:06,119 --> 01:30:10,619
multiple Hardware synthesizers at the

01:30:08,339 --> 01:30:15,179
same time I'm using this all the time in

01:30:10,619 --> 01:30:19,949
my and my music alright so at this point

01:30:15,179 --> 01:30:22,049
we are at the conclusion of our

01:30:19,949 --> 01:30:25,739
particular talk I hope this was useful

01:30:22,049 --> 01:30:29,389
that went way over time in terms of my

01:30:25,739 --> 01:30:33,689
45 minute slot that I would get in

01:30:29,389 --> 01:30:36,179
Pittsburgh and even though there I also

01:30:33,689 --> 01:30:38,819
wanted to teach you a Sakaya at the same

01:30:36,179 --> 01:30:42,139
time but I hope that through going

01:30:38,819 --> 01:30:46,199
slowly through the process of creating

01:30:42,139 --> 01:30:48,449
all of this from scratch it became much

01:30:46,199 --> 01:30:51,179
more natural to you so there are no

01:30:48,449 --> 01:30:53,969
magical moments in it and you understand

01:30:51,179 --> 01:30:56,669
how the pieces connect together and even

01:30:53,969 --> 01:30:59,639
if the particular synthesizers that you

01:30:56,669 --> 01:31:01,679
have on your own in your own setup are

01:30:59,639 --> 01:31:03,629
different there it might be not the

01:31:01,679 --> 01:31:06,119
Novation circuit and the mono station

01:31:03,629 --> 01:31:08,669
you can still take the code that we just

01:31:06,119 --> 01:31:11,219
wrote and use it for your own musical

01:31:08,669 --> 01:31:14,099
purposes at the same time I do hope that

01:31:11,219 --> 01:31:17,099
this was a good way of explaining how

01:31:14,099 --> 01:31:20,660
async i/o works I always found it kind

01:31:17,099 --> 01:31:24,320
of ingenious and maybe a bit annoying if

01:31:20,660 --> 01:31:26,450
you just had dry examples like time

01:31:24,320 --> 01:31:29,080
sleep becoming a sink il sleep

01:31:26,450 --> 01:31:31,700
because they are very far from any

01:31:29,080 --> 01:31:33,590
sensible reasonable use case that you

01:31:31,700 --> 01:31:35,690
might have in the future and if you're

01:31:33,590 --> 01:31:38,780
using a sink IO for a web development

01:31:35,690 --> 01:31:42,380
for you know a rest framework or for

01:31:38,780 --> 01:31:45,440
graph QL or anything else you would be

01:31:42,380 --> 01:31:48,440
able to maybe imagine that oh yes this

01:31:45,440 --> 01:31:51,350
will handle 10,000 clients at the same

01:31:48,440 --> 01:31:54,710
time but it's hard to actually hear

01:31:51,350 --> 01:31:57,800
things right or see things happen at the

01:31:54,710 --> 01:32:00,470
same time and understand what that means

01:31:57,800 --> 01:32:04,310
for us here you could see that there

01:32:00,470 --> 01:32:08,060
were multiple very easy coroutines which

01:32:04,310 --> 01:32:10,580
were executed concurrently using async

01:32:08,060 --> 01:32:13,190
i/o and they were doing very many things

01:32:10,580 --> 01:32:15,530
for us just the drums those were three

01:32:13,190 --> 01:32:18,830
tracks right we had the bass drum the

01:32:15,530 --> 01:32:20,960
snare drum and the hi-hat just going

01:32:18,830 --> 01:32:22,670
freely out of saying you know we're

01:32:20,960 --> 01:32:25,460
using poly rhythms they were using

01:32:22,670 --> 01:32:27,500
something like rather advanced to just

01:32:25,460 --> 01:32:29,990
type in manually that was self

01:32:27,500 --> 01:32:32,510
generating and same for the bassline we

01:32:29,990 --> 01:32:36,920
had an rather advanced RPG reader right

01:32:32,510 --> 01:32:38,600
there that the Dead respond to our like

01:32:36,920 --> 01:32:42,440
notes that we were playing and

01:32:38,600 --> 01:32:46,880
sequencing in real time so kind of a

01:32:42,440 --> 01:32:49,250
good presentation in terms of tactile

01:32:46,880 --> 01:32:52,160
feedback right you could see those

01:32:49,250 --> 01:32:54,050
things actually happen as I was showing

01:32:52,160 --> 01:32:56,330
you the synthesizer is pressing two

01:32:54,050 --> 01:32:59,330
notes playing with the filter and

01:32:56,330 --> 01:33:02,540
whatnot and whatnot so thanks for

01:32:59,330 --> 01:33:06,500
actually getting through to the very end

01:33:02,540 --> 01:33:09,940
of this rather long video I hope that

01:33:06,500 --> 01:33:12,530
you won't be late for your next talk

01:33:09,940 --> 01:33:14,720
that's it for now my name is Mukesh

01:33:12,530 --> 01:33:17,110
lanka find me on the internet see you

01:33:14,720 --> 01:33:17,110
next time

01:33:22,760 --> 01:33:24,820

YouTube URL: https://www.youtube.com/watch?v=02CLD-42VdI


