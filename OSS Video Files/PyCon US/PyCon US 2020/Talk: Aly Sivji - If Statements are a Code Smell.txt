Title: Talk: Aly Sivji - If Statements are a Code Smell
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Aly Sivji

if statements are elements of a programming language that allow us to control what statements are executed. By chaining together a series of if statements, we can solve any problem we can think of. But code with too many if statements is hard to read and even harder to change. Workarounds that once allowed us to move fast, now get in the way when we go in to make modifications. It doesnâ€™t have to be this way!

This talk demonstrates HOWTO handle complex conditional logic with simple Python classes. The material will be presented in the context of a code refactor for an open-source project: we examine the initial solution featuring duplicate if statements, show how hard it is to make a change, and walk through the process of refactoring if blocks into polymorphic classes. The case study has been simplified to illustrate concepts you can apply to your own code.

After this talk, you will be able to identify situations where an object-oriented solution can be used to improve software design. You will also be exposed to tradeoffs we need to think about before refactoring to higher-level abstractions.




Talk slides: http://bit.ly/code-smell-if-statements
Talk resources:: https://github.com/alysivji/talks/
Captions: 
	00:00:13,960 --> 00:00:19,210
I want to thank the Python organizers as

00:00:16,600 --> 00:00:22,540
well as everybody on the Python Software

00:00:19,210 --> 00:00:24,760
Foundation staff putting on a conference

00:00:22,540 --> 00:00:26,619
as a lot of hard work and you all have

00:00:24,760 --> 00:00:29,590
done a great job moving PyCon from

00:00:26,619 --> 00:00:31,599
Pittsburgh to online I really appreciate

00:00:29,590 --> 00:00:33,730
having this opportunity to share my

00:00:31,599 --> 00:00:35,890
knowledge with the community and to

00:00:33,730 --> 00:00:37,870
everybody out there watching thanks for

00:00:35,890 --> 00:00:41,200
tuning in to hear me rant about if

00:00:37,870 --> 00:00:43,329
statements we're gonna have some fun my

00:00:41,200 --> 00:00:47,170
name is Elise MJ you can find me on

00:00:43,329 --> 00:00:49,480
Twitter I am at Caius save Jess I'm one

00:00:47,170 --> 00:00:51,879
of the organizers of the chicago python

00:00:49,480 --> 00:00:54,010
users group we call ourselves chippie

00:00:51,879 --> 00:00:55,839
chippie is one of the largest python

00:00:54,010 --> 00:00:58,929
communities in the world we have around

00:00:55,839 --> 00:01:01,960
6,000 members and every month we hold

00:00:58,929 --> 00:01:04,030
four to six events normally I'd invite

00:01:01,960 --> 00:01:05,950
you all to come out to Chicago to hit up

00:01:04,030 --> 00:01:08,920
a chippy event but we've had to cancel

00:01:05,950 --> 00:01:11,890
all of our in-person meetups until it's

00:01:08,920 --> 00:01:13,690
safe to meet in large groups but we have

00:01:11,890 --> 00:01:17,320
been engaging our community through

00:01:13,690 --> 00:01:18,759
various online platforms a few weeks ago

00:01:17,320 --> 00:01:21,430
chippie started live-streaming our

00:01:18,759 --> 00:01:24,310
events to our YouTube channel subscribe

00:01:21,430 --> 00:01:26,170
to our channel hit that Bell icon to get

00:01:24,310 --> 00:01:30,700
notified of our upcoming live streams

00:01:26,170 --> 00:01:32,770
hope to see you all there this talk is

00:01:30,700 --> 00:01:35,560
titled is statements or a coat smell

00:01:32,770 --> 00:01:37,570
it's a bit incendiary but I want to

00:01:35,560 --> 00:01:39,369
start off by saying I'm not here to

00:01:37,570 --> 00:01:41,590
attack anybody I'm not here to attack

00:01:39,369 --> 00:01:44,170
anybody's code I just want to share my

00:01:41,590 --> 00:01:45,850
experience using a pattern to help me

00:01:44,170 --> 00:01:47,770
write code that's a little bit more

00:01:45,850 --> 00:01:51,659
readable and code that's a little bit

00:01:47,770 --> 00:01:54,159
more testable so what's an if statement

00:01:51,659 --> 00:01:55,960
if statements are elements of a

00:01:54,159 --> 00:01:58,079
programming language that allow us to

00:01:55,960 --> 00:02:00,670
control what statements are executed

00:01:58,079 --> 00:02:03,520
usually when we're running a program we

00:02:00,670 --> 00:02:06,490
execute it from top to bottom executing

00:02:03,520 --> 00:02:08,350
one line after another when we're

00:02:06,490 --> 00:02:10,360
hitting an if statement with that

00:02:08,350 --> 00:02:11,950
condition being true we're gonna execute

00:02:10,360 --> 00:02:14,110
a certain block of code and then

00:02:11,950 --> 00:02:15,730
continue but if that conditions false

00:02:14,110 --> 00:02:18,100
we're gonna skip over that block of code

00:02:15,730 --> 00:02:21,370
and continue like nothing ever happened

00:02:18,100 --> 00:02:24,460
so let's make this a bit more concrete

00:02:21,370 --> 00:02:26,750
here's some Python our code here is

00:02:24,460 --> 00:02:29,390
checking to see if the variable today

00:02:26,750 --> 00:02:31,130
is equal to the users birthday if it is

00:02:29,390 --> 00:02:33,680
we're gonna print a happy birthday

00:02:31,130 --> 00:02:35,870
message if not we're gonna skip over

00:02:33,680 --> 00:02:38,140
that and continue like nothing ever

00:02:35,870 --> 00:02:38,140
happened

00:02:38,170 --> 00:02:42,830
so with if statements we have the

00:02:41,270 --> 00:02:45,470
ability to tell a computer to do

00:02:42,830 --> 00:02:48,170
whatever we want when a given condition

00:02:45,470 --> 00:02:50,270
is true and by chaining together a

00:02:48,170 --> 00:02:52,130
series of if statements we can

00:02:50,270 --> 00:02:54,620
accomplish any kind of task we can think

00:02:52,130 --> 00:02:57,110
of and this is a really powerful concept

00:02:54,620 --> 00:02:59,450
and there's a reason that if statements

00:02:57,110 --> 00:03:01,520
are a fundamental building block in most

00:02:59,450 --> 00:03:03,770
programming languages but if you have

00:03:01,520 --> 00:03:05,840
code with too many if statements it

00:03:03,770 --> 00:03:09,890
makes things hard to follow and even

00:03:05,840 --> 00:03:13,310
harder to modify what does it mean to

00:03:09,890 --> 00:03:15,350
have code that's hard to follow this

00:03:13,310 --> 00:03:17,630
could be spaghetti logic and here we get

00:03:15,350 --> 00:03:19,670
to be scrolling up and down tapping

00:03:17,630 --> 00:03:21,560
between multiple modules trying to

00:03:19,670 --> 00:03:24,950
follow the thread of the code to know

00:03:21,560 --> 00:03:27,500
what's going on code that's hard to

00:03:24,950 --> 00:03:30,440
follow is also long functions that do

00:03:27,500 --> 00:03:32,690
many different types of things it could

00:03:30,440 --> 00:03:35,750
also be related functions that are not

00:03:32,690 --> 00:03:38,360
logically grouped together and if we do

00:03:35,750 --> 00:03:40,820
a bad job in translating our solution

00:03:38,360 --> 00:03:42,769
into our code it could be really hard to

00:03:40,820 --> 00:03:45,440
follow this could be something like poor

00:03:42,769 --> 00:03:47,030
variable names or poor function names or

00:03:45,440 --> 00:03:48,880
we could be doing something in a linear

00:03:47,030 --> 00:03:53,120
manner versus using a higher-order

00:03:48,880 --> 00:03:56,600
abstraction what does it mean to have

00:03:53,120 --> 00:03:58,519
code that's difficult to modify well we

00:03:56,600 --> 00:04:00,850
make a change we have to go and touch

00:03:58,519 --> 00:04:03,500
many different parts of our code base

00:04:00,850 --> 00:04:06,200
when we're adding a new feature we have

00:04:03,500 --> 00:04:10,010
to modify code we've already written to

00:04:06,200 --> 00:04:12,230
make this new feature fit code that's

00:04:10,010 --> 00:04:14,150
difficult to modify can have duplicate

00:04:12,230 --> 00:04:16,519
logic sprinkled throughout the codebase

00:04:14,150 --> 00:04:18,380
when we have to go and make a change are

00:04:16,519 --> 00:04:21,829
we sure that we changed every single

00:04:18,380 --> 00:04:24,140
part we needed to and when we have no

00:04:21,829 --> 00:04:26,419
tests code is really difficult to modify

00:04:24,140 --> 00:04:29,180
how do we know that the change we made

00:04:26,419 --> 00:04:31,070
were expected how do we know that the

00:04:29,180 --> 00:04:35,990
change we made didn't break existing

00:04:31,070 --> 00:04:38,300
functionality we have no idea we have

00:04:35,990 --> 00:04:40,310
code that's hard to understand and code

00:04:38,300 --> 00:04:42,920
that's difficult to modify weak

00:04:40,310 --> 00:04:45,110
that a coat smell and this refers to a

00:04:42,920 --> 00:04:47,690
programming pattern that might indicate

00:04:45,110 --> 00:04:49,790
that something's wrong and I want to

00:04:47,690 --> 00:04:51,800
reiterate that coat smells might

00:04:49,790 --> 00:04:53,000
indicate that something's wrong it

00:04:51,800 --> 00:04:55,820
doesn't mean that there's a problem

00:04:53,000 --> 00:04:57,740
there for sure if something's difficult

00:04:55,820 --> 00:05:00,500
to understand is there we can simplify

00:04:57,740 --> 00:05:02,600
that logic if changes are taking too

00:05:00,500 --> 00:05:06,830
long to make can we modify your design

00:05:02,600 --> 00:05:08,060
so we can move faster going forward the

00:05:06,830 --> 00:05:11,830
first type of coat smell we're gonna

00:05:08,060 --> 00:05:14,800
talk about is the compound if statement

00:05:11,830 --> 00:05:18,200
we have one if statement in your code

00:05:14,800 --> 00:05:20,840
it's fairly readable we have a compound

00:05:18,200 --> 00:05:24,200
in statement things become slightly hard

00:05:20,840 --> 00:05:26,330
in a parse and the more complexity we

00:05:24,200 --> 00:05:30,440
have inside of our conditionals the

00:05:26,330 --> 00:05:32,900
harder our logic is to understand one

00:05:30,440 --> 00:05:34,880
suggestion I like to make is to refactor

00:05:32,900 --> 00:05:37,780
your conditionals into a boolean

00:05:34,880 --> 00:05:40,700
variable or into a boolean function

00:05:37,780 --> 00:05:43,400
going back to that if statement that has

00:05:40,700 --> 00:05:45,350
two conditionals we can refactor that

00:05:43,400 --> 00:05:47,570
conditional into a variable that has a

00:05:45,350 --> 00:05:49,360
descriptive name and then we can reuse

00:05:47,570 --> 00:05:54,230
that variable with the descriptive name

00:05:49,360 --> 00:05:56,420
inside of our if condition and with that

00:05:54,230 --> 00:05:59,690
even more complex conditional that has

00:05:56,420 --> 00:06:01,820
that same value over and over again we

00:05:59,690 --> 00:06:11,960
can refactor that to a function to make

00:06:01,820 --> 00:06:13,580
our code more readable another type of

00:06:11,960 --> 00:06:17,810
pattern that makes our code hard to read

00:06:13,580 --> 00:06:20,360
is nested if statements when we have a

00:06:17,810 --> 00:06:23,020
series of nested if statements it makes

00:06:20,360 --> 00:06:25,520
our code take the shape of an arrow and

00:06:23,020 --> 00:06:27,560
there are some problems with arrow code

00:06:25,520 --> 00:06:29,900
first of all arrow code has high

00:06:27,560 --> 00:06:31,820
cyclomatic complexity and this is a

00:06:29,900 --> 00:06:34,430
measure of the number of distinct paths

00:06:31,820 --> 00:06:36,740
through a code base code that has high

00:06:34,430 --> 00:06:40,180
cyclomatic complexity it's hard to

00:06:36,740 --> 00:06:43,580
understand and it's even harder to test

00:06:40,180 --> 00:06:45,290
also when we have deeply nested if

00:06:43,580 --> 00:06:47,240
statements it really limits the

00:06:45,290 --> 00:06:49,040
characters we could use per line we're

00:06:47,240 --> 00:06:51,190
wasting all of our character count on

00:06:49,040 --> 00:06:54,080
whitespace

00:06:51,190 --> 00:06:58,699
the second refactor type I have

00:06:54,080 --> 00:07:00,650
is to flatten arrow code in Chicago we

00:06:58,699 --> 00:07:03,740
have a bike share program with a public

00:07:00,650 --> 00:07:05,479
API and in my apartment I have a

00:07:03,740 --> 00:07:07,659
dashboard that lets me know how many

00:07:05,479 --> 00:07:09,530
bikes are left to my closest station

00:07:07,659 --> 00:07:13,849
let's walk through that code that

00:07:09,530 --> 00:07:16,129
generates that dashboard we're going to

00:07:13,849 --> 00:07:19,310
use the request library to hit the API

00:07:16,129 --> 00:07:21,800
we're gonna get a response back if that

00:07:19,310 --> 00:07:24,590
response is a 200 we're gonna grab that

00:07:21,800 --> 00:07:27,819
station data we're going to loop through

00:07:24,590 --> 00:07:31,280
each of the stations inside of that

00:07:27,819 --> 00:07:34,280
station payload until we find the one

00:07:31,280 --> 00:07:37,250
that we care about and if the number of

00:07:34,280 --> 00:07:39,050
bikes at that station is less than or

00:07:37,250 --> 00:07:41,000
equal to our threshold here the

00:07:39,050 --> 00:07:43,430
threshold three we're gonna return a

00:07:41,000 --> 00:07:44,840
message if it's greater than three we're

00:07:43,430 --> 00:07:47,690
gonna return a different kind of message

00:07:44,840 --> 00:07:49,969
and then finally if that response from

00:07:47,690 --> 00:07:52,479
the top is not at 200 or you get or

00:07:49,969 --> 00:07:55,639
maybe raise an exception in return and

00:07:52,479 --> 00:07:58,879
this right here it should raise some red

00:07:55,639 --> 00:08:02,509
flags it's really far away from the code

00:07:58,879 --> 00:08:04,219
that it's related to and there are many

00:08:02,509 --> 00:08:07,490
ways we can think about flattening arrow

00:08:04,219 --> 00:08:09,949
code the main idea is that we want to

00:08:07,490 --> 00:08:11,779
return as soon as possible in our

00:08:09,949 --> 00:08:14,539
example we're gonna write something call

00:08:11,779 --> 00:08:17,240
on guard Clause and this is gonna turn

00:08:14,539 --> 00:08:21,110
our positive check into our negative

00:08:17,240 --> 00:08:22,909
check so going back to that code here we

00:08:21,110 --> 00:08:25,639
get a right of guard Clause that's

00:08:22,909 --> 00:08:28,069
checks to see if the status code the

00:08:25,639 --> 00:08:30,289
risk of the response is not a 200 if

00:08:28,069 --> 00:08:33,440
that's the case it's gonna exit early

00:08:30,289 --> 00:08:37,219
this leaves the rest of her logic unmess

00:08:33,440 --> 00:08:39,019
'td inside of our module I also want to

00:08:37,219 --> 00:08:43,209
call out that I removed the else and

00:08:39,019 --> 00:08:45,800
then block since I really didn't need it

00:08:43,209 --> 00:08:47,360
the third and final type of code smell

00:08:45,800 --> 00:08:49,339
we're going to talk about is when we

00:08:47,360 --> 00:08:51,500
have duplicate if statements sprinkled

00:08:49,339 --> 00:08:53,000
throughout our code base one of the

00:08:51,500 --> 00:08:55,430
first two types of code smells we talked

00:08:53,000 --> 00:08:57,949
about they're easy to identify and

00:08:55,430 --> 00:09:00,529
they're fairly easy to fix this type of

00:08:57,949 --> 00:09:01,850
coat smell it's easy to identify but it

00:09:00,529 --> 00:09:03,620
requires more knowledge about the

00:09:01,850 --> 00:09:08,180
problem before we can go and design a

00:09:03,620 --> 00:09:10,640
solution we've all seen code like

00:09:08,180 --> 00:09:12,310
this before where we had this same check

00:09:10,640 --> 00:09:15,170
litter throughout the codebase and

00:09:12,310 --> 00:09:17,270
honestly this really isn't that much of

00:09:15,170 --> 00:09:19,310
a problem if we never have to change

00:09:17,270 --> 00:09:21,980
this code but if we have to go in and

00:09:19,310 --> 00:09:24,890
change this code or go in and at least

00:09:21,980 --> 00:09:28,450
read this code it might makes sense to

00:09:24,890 --> 00:09:32,390
explore a different kind of abstraction

00:09:28,450 --> 00:09:34,130
so what pattern should we use as I

00:09:32,390 --> 00:09:35,690
mentioned we need to have a deeper

00:09:34,130 --> 00:09:38,570
understanding of the problem before we

00:09:35,690 --> 00:09:40,370
can design our solution let's explore

00:09:38,570 --> 00:09:44,480
duplicate if statements with the case

00:09:40,370 --> 00:09:46,700
study in the chicago python slack we

00:09:44,480 --> 00:09:49,580
have a community engagement bot called

00:09:46,700 --> 00:09:51,770
busy beaver and one of the ways busy

00:09:49,580 --> 00:09:54,500
beaver engages our community is by

00:09:51,770 --> 00:09:58,149
sharing public in of activity in a

00:09:54,500 --> 00:10:00,800
designated channel for registered users

00:09:58,149 --> 00:10:05,270
how do we go about generating that daily

00:10:00,800 --> 00:10:07,370
summary recall we can chain together a

00:10:05,270 --> 00:10:10,970
series of if statements to accomplish

00:10:07,370 --> 00:10:13,070
any kind of task we can think of what's

00:10:10,970 --> 00:10:16,550
the algorithm to generate summary text

00:10:13,070 --> 00:10:20,630
first single github user we're going to

00:10:16,550 --> 00:10:22,580
start by grabbing data from our API next

00:10:20,630 --> 00:10:26,450
we're going to collect events by their

00:10:22,580 --> 00:10:28,130
type for each of those event types we're

00:10:26,450 --> 00:10:30,680
going to calculate some event statistics

00:10:28,130 --> 00:10:34,730
and then finally we're going to generate

00:10:30,680 --> 00:10:36,350
some summary text for a Minimum Viable

00:10:34,730 --> 00:10:38,990
Product we're only going to want to

00:10:36,350 --> 00:10:40,970
track two event types we only care about

00:10:38,990 --> 00:10:43,930
all the commits a user makes as well as

00:10:40,970 --> 00:10:45,830
all the repositories I use their stars

00:10:43,930 --> 00:10:48,860
let's what are the steps we've just

00:10:45,830 --> 00:10:50,480
talked about in our code we're going to

00:10:48,860 --> 00:10:54,589
start by grabbing data from the github

00:10:50,480 --> 00:10:56,930
API and here's the code to do that we're

00:10:54,589 --> 00:10:59,029
gonna start by setting headers we're

00:10:56,930 --> 00:11:01,970
gonna hit that API and then we get a

00:10:59,029 --> 00:11:06,440
return our JSON payload fairly standard

00:11:01,970 --> 00:11:08,390
use of the request library next we can

00:11:06,440 --> 00:11:11,470
extract events of interest from that

00:11:08,390 --> 00:11:13,670
JSON payload here's the code to do that

00:11:11,470 --> 00:11:15,890
we're going to loop through each event

00:11:13,670 --> 00:11:17,839
from our payload we're going to collect

00:11:15,890 --> 00:11:19,910
events by their type inside of a

00:11:17,839 --> 00:11:21,650
dictionary and then finally we're gonna

00:11:19,910 --> 00:11:23,210
return that dictionary

00:11:21,650 --> 00:11:26,089
this dictionary is going to have a key

00:11:23,210 --> 00:11:28,370
of the event type and the value is going

00:11:26,089 --> 00:11:33,020
to be a list of all the events of that

00:11:28,370 --> 00:11:35,060
type and finally we're going to generate

00:11:33,020 --> 00:11:37,670
a summary text for all the events that

00:11:35,060 --> 00:11:39,440
we care about and this function it

00:11:37,670 --> 00:11:41,390
generates a get up summary for a single

00:11:39,440 --> 00:11:43,520
user so we're gonna start by creating

00:11:41,390 --> 00:11:46,070
our header we're going to go through

00:11:43,520 --> 00:11:49,220
each key value pair from our dictionary

00:11:46,070 --> 00:11:52,070
and then we're gonna update our text

00:11:49,220 --> 00:11:54,440
based on the event type and finally

00:11:52,070 --> 00:11:58,279
we're gonna return that summary text we

00:11:54,440 --> 00:12:00,410
just generated this is perfect we

00:11:58,279 --> 00:12:02,480
created our MVP we can get into the

00:12:00,410 --> 00:12:06,230
hands of our customers and start that

00:12:02,480 --> 00:12:08,900
learning process fortunately for us in

00:12:06,230 --> 00:12:11,150
Chicago everybody loved busy beaver and

00:12:08,900 --> 00:12:15,050
they wanted to start tracking additional

00:12:11,150 --> 00:12:16,700
event types so let's modify our code so

00:12:15,050 --> 00:12:19,040
we can start tracking an additional

00:12:16,700 --> 00:12:21,170
event type and we're gonna add all the

00:12:19,040 --> 00:12:24,500
new pull requests a user creates to our

00:12:21,170 --> 00:12:27,290
github summary feature looking at that

00:12:24,500 --> 00:12:29,360
perform function from earlier we're only

00:12:27,290 --> 00:12:32,839
gonna have to go and modify these two

00:12:29,360 --> 00:12:35,180
cell functions in the extract events of

00:12:32,839 --> 00:12:37,459
interest function we're going to add

00:12:35,180 --> 00:12:40,010
another conditional block to our series

00:12:37,459 --> 00:12:42,290
of if else's and here we're gonna check

00:12:40,010 --> 00:12:44,839
to see if the event type is a pull

00:12:42,290 --> 00:12:47,390
request event and the event payload has

00:12:44,839 --> 00:12:49,339
the action that is open remember we only

00:12:47,390 --> 00:12:52,880
care about new poll requests a user

00:12:49,339 --> 00:12:55,580
makes and in the generate summary from

00:12:52,880 --> 00:12:57,740
events function we're gonna add some

00:12:55,580 --> 00:13:00,529
logic that generates pull requests

00:12:57,740 --> 00:13:02,360
summary information like before we're

00:13:00,529 --> 00:13:06,470
just gonna add another block to our

00:13:02,360 --> 00:13:08,690
series of if else's that was fairly

00:13:06,470 --> 00:13:13,310
straightforward Python makes things easy

00:13:08,690 --> 00:13:14,810
or was it the generate summary function

00:13:13,310 --> 00:13:17,660
it's already starting to get hard to

00:13:14,810 --> 00:13:19,850
read yes I know this is on a slide we're

00:13:17,660 --> 00:13:22,279
only using two spaces versus four spaces

00:13:19,850 --> 00:13:24,740
but things are really hard to follow and

00:13:22,279 --> 00:13:27,050
currently we're only tracking three

00:13:24,740 --> 00:13:29,209
event types our users they want to

00:13:27,050 --> 00:13:30,860
subtract additional event types you can

00:13:29,209 --> 00:13:32,050
start to see how this is gonna get out

00:13:30,860 --> 00:13:35,580
of hand

00:13:32,050 --> 00:13:38,940
also what about our tests

00:13:35,580 --> 00:13:42,630
we look at the dip between our tests for

00:13:38,940 --> 00:13:45,690
MVP versus our test for MVP with this

00:13:42,630 --> 00:13:48,510
new functionality we can see that we

00:13:45,690 --> 00:13:51,390
have to write a test to check this PR

00:13:48,510 --> 00:13:53,220
functionality works as intended but we

00:13:51,390 --> 00:13:55,530
have to go back and modify tests we've

00:13:53,220 --> 00:13:58,680
already written to ensure this feature

00:13:55,530 --> 00:14:00,240
doesn't get triggered and this is

00:13:58,680 --> 00:14:02,640
because the functionality that we're

00:14:00,240 --> 00:14:04,620
testing this function does many

00:14:02,640 --> 00:14:06,630
different types of things it's trying to

00:14:04,620 --> 00:14:09,690
generate a summary for many different

00:14:06,630 --> 00:14:11,730
types of kin of events so every time we

00:14:09,690 --> 00:14:14,670
add functionality we're increasing the

00:14:11,730 --> 00:14:16,590
size of our test code and this function

00:14:14,670 --> 00:14:20,220
has a larger surface area and it means

00:14:16,590 --> 00:14:23,220
we have more complicated tests so if you

00:14:20,220 --> 00:14:25,530
ever find yourself having to modify code

00:14:23,220 --> 00:14:27,840
in multiple locations to add a new

00:14:25,530 --> 00:14:30,020
feature or you're modifying tests you've

00:14:27,840 --> 00:14:32,820
already written to add new functionality

00:14:30,020 --> 00:14:40,890
you might have some Toth smells inside

00:14:32,820 --> 00:14:43,710
of your repository this was me last

00:14:40,890 --> 00:14:45,540
December we just released our slack bot

00:14:43,710 --> 00:14:48,420
and her customers wanted us to add more

00:14:45,540 --> 00:14:50,700
additional features but I found myself

00:14:48,420 --> 00:14:54,570
sliding the program design I already had

00:14:50,700 --> 00:14:56,970
to make these new features fit around

00:14:54,570 --> 00:14:59,850
that same time I started reading the

00:14:56,970 --> 00:15:02,460
book clean code by Robert Martin he's

00:14:59,850 --> 00:15:05,160
affectionately known as Uncle Bob in the

00:15:02,460 --> 00:15:06,960
developer community and this book it has

00:15:05,160 --> 00:15:09,180
a lot of great advice on how you can

00:15:06,960 --> 00:15:12,630
write better code following a series of

00:15:09,180 --> 00:15:15,060
prescribed best practices and one of the

00:15:12,630 --> 00:15:17,520
things that this book recommended was to

00:15:15,060 --> 00:15:21,570
refactor your conditionals using

00:15:17,520 --> 00:15:24,330
polymorphic classes yeah I'm not really

00:15:21,570 --> 00:15:26,400
too sure either so let's take a step

00:15:24,330 --> 00:15:34,680
back and talk about object-oriented

00:15:26,400 --> 00:15:36,690
programming in Python object-oriented

00:15:34,680 --> 00:15:39,060
programming is a paradigm that's based

00:15:36,690 --> 00:15:42,390
around objects we try to model

00:15:39,060 --> 00:15:44,400
real-world things as objects and we

00:15:42,390 --> 00:15:47,040
design a solution it involves a

00:15:44,400 --> 00:15:48,480
collection of collaborating objects that

00:15:47,040 --> 00:15:50,720
communicate with each other by sending

00:15:48,480 --> 00:15:55,009
mess

00:15:50,720 --> 00:15:57,360
objects have data along with behavior an

00:15:55,009 --> 00:15:59,329
object-oriented programming allows us to

00:15:57,360 --> 00:16:02,399
think at a higher level of abstraction

00:15:59,329 --> 00:16:04,500
we can create objects with set data and

00:16:02,399 --> 00:16:06,779
set behavior and then we can start

00:16:04,500 --> 00:16:08,250
performing actions on those objects to

00:16:06,779 --> 00:16:10,410
accomplish a task we're trying to do

00:16:08,250 --> 00:16:15,360
versus doing things in a sequential

00:16:10,410 --> 00:16:17,730
linear manner in object-oriented

00:16:15,360 --> 00:16:21,750
programming we have classes and we have

00:16:17,730 --> 00:16:24,240
objects a class it's a template that

00:16:21,750 --> 00:16:27,420
allows it to create objects we can also

00:16:24,240 --> 00:16:30,269
say that we initialized an object from a

00:16:27,420 --> 00:16:32,880
class I really like this cookie cutter

00:16:30,269 --> 00:16:35,459
analogy our cookie cutter it's like a

00:16:32,880 --> 00:16:39,660
class and each instance or each cookie

00:16:35,459 --> 00:16:42,209
is like an object in object-oriented

00:16:39,660 --> 00:16:44,130
programming we have four main principles

00:16:42,209 --> 00:16:46,199
there's encapsulation there's

00:16:44,130 --> 00:16:50,389
abstraction there's inheritance and

00:16:46,199 --> 00:16:53,910
there's polymorphism encapsulation

00:16:50,389 --> 00:16:56,810
bundles data and behavior into a single

00:16:53,910 --> 00:16:59,730
logical unit which we call an object

00:16:56,810 --> 00:17:01,889
with the cancellation we're able to hide

00:16:59,730 --> 00:17:06,299
the internal representation of our

00:17:01,889 --> 00:17:08,699
object abstraction allows us to hide a

00:17:06,299 --> 00:17:11,419
complexity inside of our internal

00:17:08,699 --> 00:17:14,400
implementation inside of these objects

00:17:11,419 --> 00:17:16,260
it's also recommended that when objects

00:17:14,400 --> 00:17:20,100
communicate with each other they do so

00:17:16,260 --> 00:17:21,780
by calling their public methods with

00:17:20,100 --> 00:17:24,299
abstraction we're able to hide

00:17:21,780 --> 00:17:27,299
complexity we're also able to isolate

00:17:24,299 --> 00:17:29,640
the impact of changes we want to change

00:17:27,299 --> 00:17:31,380
the underlying implementation we don't

00:17:29,640 --> 00:17:33,809
have to go out and change our calling

00:17:31,380 --> 00:17:39,540
code once we change our implementation

00:17:33,809 --> 00:17:41,309
the calling code knows what to do often

00:17:39,540 --> 00:17:44,760
we have objects that are similar but

00:17:41,309 --> 00:17:47,220
they're not entirely the same with

00:17:44,760 --> 00:17:50,309
inheritance we're able to extract common

00:17:47,220 --> 00:17:53,340
data and common behavior into our base

00:17:50,309 --> 00:17:55,650
object and then we can use this base

00:17:53,340 --> 00:17:58,290
object to create children objects and

00:17:55,650 --> 00:18:00,720
these children objects can reuse all the

00:17:58,290 --> 00:18:03,240
data and all the behavior from the

00:18:00,720 --> 00:18:04,980
parents they can also override

00:18:03,240 --> 00:18:07,049
based methods to enable distinct

00:18:04,980 --> 00:18:10,200
functionality from the parents or from

00:18:07,049 --> 00:18:12,570
each other and these two objects can

00:18:10,200 --> 00:18:14,820
also implement their own data and their

00:18:12,570 --> 00:18:18,750
own behavior that's not any way related

00:18:14,820 --> 00:18:21,120
to parent objects with the inheritance

00:18:18,750 --> 00:18:22,970
were able to eliminate all redundant

00:18:21,120 --> 00:18:26,490
code

00:18:22,970 --> 00:18:29,549
finally with polymorphism were able to

00:18:26,490 --> 00:18:33,210
present the same kind of interface for

00:18:29,549 --> 00:18:35,309
many different types of objects imagine

00:18:33,210 --> 00:18:38,370
we have a collection of children objects

00:18:35,309 --> 00:18:40,590
we can use our parent objects implement

00:18:38,370 --> 00:18:44,820
in our interface to run each child

00:18:40,590 --> 00:18:46,770
objects implementation with polymorphism

00:18:44,820 --> 00:18:49,799
we're able to convert our conditional

00:18:46,770 --> 00:18:51,330
blocks into distinct objects one our

00:18:49,799 --> 00:18:54,450
program using when we're programming

00:18:51,330 --> 00:18:56,970
using the procedural paradigm we have to

00:18:54,450 --> 00:18:59,010
use conditionals to selectively execute

00:18:56,970 --> 00:19:00,870
certain blocks of code when we're

00:18:59,010 --> 00:19:03,570
programming using the object-oriented

00:19:00,870 --> 00:19:06,570
paradigm we embed our conditional logic

00:19:03,570 --> 00:19:08,549
into our program structure itself into

00:19:06,570 --> 00:19:11,070
our objects when we're running

00:19:08,549 --> 00:19:14,070
object-oriented code the type of object

00:19:11,070 --> 00:19:17,640
defines what behaviors should be run

00:19:14,070 --> 00:19:20,039
what code should be executed this is a

00:19:17,640 --> 00:19:22,710
diagram I pulled from martin fowler's

00:19:20,039 --> 00:19:24,440
book called refactoring you can sort of

00:19:22,710 --> 00:19:28,520
see how we can turn conditional logic

00:19:24,440 --> 00:19:31,380
into a class or an object hierarchy

00:19:28,520 --> 00:19:34,679
let's dig into polymorphism with a

00:19:31,380 --> 00:19:37,169
concrete example let's say we have a

00:19:34,679 --> 00:19:39,720
parent class called animal the animal

00:19:37,169 --> 00:19:42,659
class implements an interface that

00:19:39,720 --> 00:19:44,610
defines a method called speak and when

00:19:42,659 --> 00:19:47,309
we call speak on any of our children

00:19:44,610 --> 00:19:50,340
objects it produces a different behavior

00:19:47,309 --> 00:19:52,230
depending on that objects type so if we

00:19:50,340 --> 00:19:54,600
do a cat dot speak it's gonna produce a

00:19:52,230 --> 00:19:58,260
meow a dog dot speak it's gonna produce

00:19:54,600 --> 00:20:00,690
a woof this is that same object

00:19:58,260 --> 00:20:02,880
relationship in Python so we're gonna

00:20:00,690 --> 00:20:05,130
start by creating an animal we're gonna

00:20:02,880 --> 00:20:06,809
initialize that with the name we're

00:20:05,130 --> 00:20:09,299
gonna implement an interface with a

00:20:06,809 --> 00:20:11,340
function called speak and no here's that

00:20:09,299 --> 00:20:13,620
I'm just gonna define this function to

00:20:11,340 --> 00:20:15,450
raise a not implemented error since I

00:20:13,620 --> 00:20:16,110
just wanted to let people know that it's

00:20:15,450 --> 00:20:19,230
an interface

00:20:16,110 --> 00:20:21,600
it's not actually being used now we're

00:20:19,230 --> 00:20:24,120
gonna create a cat class that has animal

00:20:21,600 --> 00:20:26,370
as its base class we're gonna override

00:20:24,120 --> 00:20:29,130
that speak functionality and return meow

00:20:26,370 --> 00:20:30,390
which is distinct for cats and we're

00:20:29,130 --> 00:20:32,880
also going to create a dog class

00:20:30,390 --> 00:20:35,100
override speak and return woof and

00:20:32,880 --> 00:20:39,240
that's distinct functionality for dog

00:20:35,100 --> 00:20:41,429
objects and now we call this feat method

00:20:39,240 --> 00:20:43,500
depending on the type of object we're

00:20:41,429 --> 00:20:46,049
talking to a different behavior is going

00:20:43,500 --> 00:20:48,360
to be produced this way if we ever

00:20:46,049 --> 00:20:50,370
wanted to add a new animal say we want

00:20:48,360 --> 00:20:53,370
to add a duck we could create a duck

00:20:50,370 --> 00:20:55,590
class have animal as its base and

00:20:53,370 --> 00:20:58,980
override that speak functionality and

00:20:55,590 --> 00:21:02,429
return quack to produce that distinct

00:20:58,980 --> 00:21:04,169
functionality going back to that case

00:21:02,429 --> 00:21:12,090
study how can we start replacing

00:21:04,169 --> 00:21:14,040
conditionals with polymorphism when we

00:21:12,090 --> 00:21:16,440
first hack together a solution that's

00:21:14,040 --> 00:21:18,960
exactly what we did we designed it over

00:21:16,440 --> 00:21:20,640
a weekend hackathon he was really about

00:21:18,960 --> 00:21:22,650
getting something into the hands of our

00:21:20,640 --> 00:21:25,980
customers so we can start that learning

00:21:22,650 --> 00:21:27,179
process but now that we have an idea or

00:21:25,980 --> 00:21:29,400
the problem that we're actually trying

00:21:27,179 --> 00:21:31,620
to solve we can focus on the details

00:21:29,400 --> 00:21:36,150
that actually matter and design a better

00:21:31,620 --> 00:21:39,120
solution so let's take a step back what

00:21:36,150 --> 00:21:42,020
is this bot trying to do once we have a

00:21:39,120 --> 00:21:44,610
list of all the events that a user had

00:21:42,020 --> 00:21:47,790
we want to start collecting them by

00:21:44,610 --> 00:21:49,470
their event type and then for each of

00:21:47,790 --> 00:21:50,910
those event types we're gonna want to

00:21:49,470 --> 00:21:53,549
generate some summary text

00:21:50,910 --> 00:21:56,720
it sounds like an event type or maybe an

00:21:53,549 --> 00:21:59,220
event list would make a good base class

00:21:56,720 --> 00:22:01,110
let's walk through the process of how we

00:21:59,220 --> 00:22:04,799
would refactor duplicate if statements

00:22:01,110 --> 00:22:06,750
and two polymorphic classes first I want

00:22:04,799 --> 00:22:10,340
to want to identify our duplicate

00:22:06,750 --> 00:22:12,750
conditional blocks there they are

00:22:10,340 --> 00:22:15,530
next we're gonna identify what each of

00:22:12,750 --> 00:22:18,960
these blocks does functionality-wise on

00:22:15,530 --> 00:22:21,960
the top we're trying to match events to

00:22:18,960 --> 00:22:24,059
an event type and on the bottom we're

00:22:21,960 --> 00:22:26,910
trying to generate a summary for each of

00:22:24,059 --> 00:22:30,070
those event types next we're going to

00:22:26,910 --> 00:22:31,870
want to create a base class to model our

00:22:30,070 --> 00:22:34,120
and so we're going to create an events

00:22:31,870 --> 00:22:39,310
list class that has some data it has

00:22:34,120 --> 00:22:40,870
some behavior for the data we're gonna

00:22:39,310 --> 00:22:44,650
want to keep track of all the events

00:22:40,870 --> 00:22:46,330
inside of a list and for the behavior

00:22:44,650 --> 00:22:48,130
we're gonna be able to get the size of

00:22:46,330 --> 00:22:50,650
the list we're gonna be able to append

00:22:48,130 --> 00:22:53,590
items to that list and we also have a

00:22:50,650 --> 00:22:55,450
function that returns true or false if a

00:22:53,590 --> 00:22:57,730
given event matches the event type that

00:22:55,450 --> 00:23:00,220
word we care about and there's also a

00:22:57,730 --> 00:23:03,490
function that generates summary text for

00:23:00,220 --> 00:23:05,980
a particular event type and since this

00:23:03,490 --> 00:23:07,540
is our parent class it's just defining

00:23:05,980 --> 00:23:10,300
our implementation I'm sorry it's

00:23:07,540 --> 00:23:12,250
defining our interface I'm raising the

00:23:10,300 --> 00:23:16,630
not implemented error that's just the

00:23:12,250 --> 00:23:18,700
way I like doing things next we're gonna

00:23:16,630 --> 00:23:21,520
want to extract functionality form our

00:23:18,700 --> 00:23:23,650
conditional blocks into our child class

00:23:21,520 --> 00:23:26,470
so here we're going to create a commits

00:23:23,650 --> 00:23:29,380
class that matches events that have the

00:23:26,470 --> 00:23:31,950
type push events and we're also going to

00:23:29,380 --> 00:23:33,730
generate a summary that we expect to see

00:23:31,950 --> 00:23:35,560
next we're gonna want to extract

00:23:33,730 --> 00:23:38,470
functionality from our conditional

00:23:35,560 --> 00:23:41,320
blocks into a child class for all the

00:23:38,470 --> 00:23:42,250
repositories by user stars and then

00:23:41,320 --> 00:23:44,050
finally we're gonna extract

00:23:42,250 --> 00:23:47,200
functionality from our conditional

00:23:44,050 --> 00:23:50,260
blocks into a child class for newly open

00:23:47,200 --> 00:23:52,600
PRS we're gonna also want to create a

00:23:50,260 --> 00:23:54,640
class that runs the process of

00:23:52,600 --> 00:23:58,200
generating a github summary for a single

00:23:54,640 --> 00:24:01,150
user I normally call this a driver class

00:23:58,200 --> 00:24:03,550
so this class it takes in a github user

00:24:01,150 --> 00:24:10,600
name it gets a list of events and it

00:24:03,550 --> 00:24:12,430
classifies them by type and this these

00:24:10,600 --> 00:24:15,220
are the only places I have an if

00:24:12,430 --> 00:24:17,950
statement in my code what we're

00:24:15,220 --> 00:24:20,110
classifying event we need to check that

00:24:17,950 --> 00:24:21,910
the event that we're classifying matches

00:24:20,110 --> 00:24:23,560
an event we care about if it does we'll

00:24:21,910 --> 00:24:25,630
add it to that event types list

00:24:23,560 --> 00:24:28,300
if not we'll continue like nothing ever

00:24:25,630 --> 00:24:30,400
happened and the second if statement is

00:24:28,300 --> 00:24:35,290
to generate some rays only when a user

00:24:30,400 --> 00:24:36,820
has greater at least one event and then

00:24:35,290 --> 00:24:38,830
finally we're gonna have to update that

00:24:36,820 --> 00:24:42,910
perform function from earlier to use

00:24:38,830 --> 00:24:43,510
this new higher-order abstraction the

00:24:42,910 --> 00:24:45,490
last time

00:24:43,510 --> 00:24:47,710
we try to add new functionality it was a

00:24:45,490 --> 00:24:49,300
little bit painful let's try to use

00:24:47,710 --> 00:24:51,550
let's really use this new

00:24:49,300 --> 00:24:54,880
object-oriented design and see how

00:24:51,550 --> 00:24:57,130
painful it is to add a new type to our

00:24:54,880 --> 00:25:00,190
github summary this time we're gonna

00:24:57,130 --> 00:25:04,120
track all the issues a user creates to

00:25:00,190 --> 00:25:06,190
that github summary output we're gonna

00:25:04,120 --> 00:25:08,860
start off by creating a class this is

00:25:06,190 --> 00:25:11,430
going to be called issues opened and the

00:25:08,860 --> 00:25:14,380
base class is going to be events list

00:25:11,430 --> 00:25:16,990
we're gonna add a function that matches

00:25:14,380 --> 00:25:20,590
all the issues events with the payload

00:25:16,990 --> 00:25:22,240
having the action that it is opened and

00:25:20,590 --> 00:25:24,190
we're gonna also have some code that

00:25:22,240 --> 00:25:27,160
generates the text that we expect to see

00:25:24,190 --> 00:25:28,390
and then finally we're gonna go to we're

00:25:27,160 --> 00:25:31,180
gonna have to go back to that driver

00:25:28,390 --> 00:25:33,610
class and update the list of events that

00:25:31,180 --> 00:25:36,340
we care about by adding this one type to

00:25:33,610 --> 00:25:41,320
that list again this seems pretty

00:25:36,340 --> 00:25:43,720
straightforward but was it looking at

00:25:41,320 --> 00:25:46,480
the diff between our tests for object

00:25:43,720 --> 00:25:48,400
orientation versus our tests for object

00:25:46,480 --> 00:25:50,950
oriented solution with this new feature

00:25:48,400 --> 00:25:53,650
we could see that we have to add a test

00:25:50,950 --> 00:25:55,870
that checks this new functionality in

00:25:53,650 --> 00:25:58,210
contrast to a previous design we had to

00:25:55,870 --> 00:26:00,300
modify tests we've already written to

00:25:58,210 --> 00:26:03,040
ensure this feature didn't get triggered

00:26:00,300 --> 00:26:10,720
so yeah I think this is a little bit

00:26:03,040 --> 00:26:12,730
better design but like everything else

00:26:10,720 --> 00:26:16,540
in programming there are some things for

00:26:12,730 --> 00:26:18,460
us to consider first of all we made our

00:26:16,540 --> 00:26:20,740
program design a little bit more complex

00:26:18,460 --> 00:26:22,630
anytime somebody goes into this codebase

00:26:20,740 --> 00:26:24,910
they have more concepts they need to

00:26:22,630 --> 00:26:27,070
understand maybe this kind of additional

00:26:24,910 --> 00:26:30,250
design complexity is something we don't

00:26:27,070 --> 00:26:32,710
want inside of a repository so it's

00:26:30,250 --> 00:26:35,320
really worth thinking about how often is

00:26:32,710 --> 00:26:37,570
our code changed if this is something

00:26:35,320 --> 00:26:39,520
that's modified a lot or at least read a

00:26:37,570 --> 00:26:43,600
lot it might be worth taking some time

00:26:39,520 --> 00:26:45,790
to refactor to a better abstraction this

00:26:43,600 --> 00:26:47,980
is why I really like following the rule

00:26:45,790 --> 00:26:51,480
of three and again I pull this from

00:26:47,980 --> 00:26:53,350
Martin Fowler's book called refactoring

00:26:51,480 --> 00:26:55,000
when you're doing something for the

00:26:53,350 --> 00:26:56,840
first time you're really just learning

00:26:55,000 --> 00:26:59,679
how to solve the problem

00:26:56,840 --> 00:27:02,539
figure out how to do it and do the job

00:26:59,679 --> 00:27:04,789
if it's the second time you do something

00:27:02,539 --> 00:27:05,960
and you feel that pain you're really

00:27:04,789 --> 00:27:08,960
still learning how to solve that problem

00:27:05,960 --> 00:27:11,720
just wince duplicate your code it's not

00:27:08,960 --> 00:27:13,490
a problem at this stage but if it's the

00:27:11,720 --> 00:27:15,740
third time you do something and you feel

00:27:13,490 --> 00:27:20,929
that pain it might be worth taking some

00:27:15,740 --> 00:27:23,270
time to find a better abstraction recall

00:27:20,929 --> 00:27:25,940
from the zen of python that flat is

00:27:23,270 --> 00:27:28,190
better than nested when we're using

00:27:25,940 --> 00:27:30,080
inheritance we want to be sure that we

00:27:28,190 --> 00:27:32,210
don't design program structures there

00:27:30,080 --> 00:27:35,990
are too many levels of inheritance

00:27:32,210 --> 00:27:38,000
hierarchy deep this means that our code

00:27:35,990 --> 00:27:40,429
is going to be overtly complicated and

00:27:38,000 --> 00:27:42,529
overtly rigid instead of having to

00:27:40,429 --> 00:27:44,029
understand several layers of nested if

00:27:42,529 --> 00:27:46,159
statements we're now having to

00:27:44,029 --> 00:27:48,200
understand several layers of inheritance

00:27:46,159 --> 00:27:51,820
hierarchy so we just traded one set of

00:27:48,200 --> 00:27:51,820
problems for another set of problems

00:27:51,909 --> 00:27:56,299
they always say that when we're writing

00:27:54,230 --> 00:28:00,110
object-oriented code we should prefer

00:27:56,299 --> 00:28:02,870
composition to inheritance with

00:28:00,110 --> 00:28:05,299
inheritance we're saying is an object is

00:28:02,870 --> 00:28:07,970
a type of another object with

00:28:05,299 --> 00:28:10,789
composition we say an object has these

00:28:07,970 --> 00:28:13,580
type of behaviors so it's a esse vs.

00:28:10,789 --> 00:28:15,950
that has our relationship personally I

00:28:13,580 --> 00:28:18,260
feel that inheritance is not that bad as

00:28:15,950 --> 00:28:22,309
long as you don't go to many levels of

00:28:18,260 --> 00:28:25,340
inheritance hierarchy deep in a lot of

00:28:22,309 --> 00:28:26,899
cases it's a lot more preferable to

00:28:25,340 --> 00:28:29,659
solve your problem by duplicating your

00:28:26,899 --> 00:28:31,940
code with copy and paste than it is to

00:28:29,659 --> 00:28:34,880
use the wrong abstraction there's a

00:28:31,940 --> 00:28:37,429
fantastic talk about this by Sandi Metz

00:28:34,880 --> 00:28:40,370
from ruby cough a few years ago really

00:28:37,429 --> 00:28:42,080
recommend y'all go check it out and I

00:28:40,370 --> 00:28:44,630
also wanted to give a shout out to my

00:28:42,080 --> 00:28:47,480
test suite I was able to refactor my

00:28:44,630 --> 00:28:49,429
program design as I had set a high level

00:28:47,480 --> 00:28:54,620
tests to ensure things worked as

00:28:49,429 --> 00:28:56,690
expected let's recap we can use if

00:28:54,620 --> 00:28:59,990
statements to solve any kind of problem

00:28:56,690 --> 00:29:02,059
we can think of but if we have code with

00:28:59,990 --> 00:29:05,620
too many if statements it makes things

00:29:02,059 --> 00:29:08,149
hard to follow and even harder to modify

00:29:05,620 --> 00:29:10,840
we talked about a five step process

00:29:08,149 --> 00:29:13,019
which we can use to refactor duplic

00:29:10,840 --> 00:29:15,909
if statements into polymorphic classes

00:29:13,019 --> 00:29:18,009
we remember it's not worth wasting our

00:29:15,909 --> 00:29:21,159
time to refactor unless the payoffs

00:29:18,009 --> 00:29:23,919
actually worth it now you know how to

00:29:21,159 --> 00:29:26,379
use polymorphism tip bed conditional

00:29:23,919 --> 00:29:29,679
logic so go forth refactor your code

00:29:26,379 --> 00:29:32,499
make sure you do it responsibly these

00:29:29,679 --> 00:29:36,429
are all the resources I found coming up

00:29:32,499 --> 00:29:38,470
with this talk if you do have questions

00:29:36,429 --> 00:29:40,990
please ask them in the comment section

00:29:38,470 --> 00:29:42,730
down below over the next few weeks to

00:29:40,990 --> 00:29:44,860
months I'm going to be periodically

00:29:42,730 --> 00:29:48,369
checking in to answer your questions to

00:29:44,860 --> 00:29:50,110
the best of my abilities I also want to

00:29:48,369 --> 00:29:52,570
make everybody aware that the project I

00:29:50,110 --> 00:29:54,580
talked about busy beaver which is the

00:29:52,570 --> 00:29:56,590
Chicago Python community engagement

00:29:54,580 --> 00:29:59,409
slack bot it's an open source project

00:29:56,590 --> 00:30:02,619
all of our code is on github if you're

00:29:59,409 --> 00:30:04,389
an organizer of community and you have a

00:30:02,619 --> 00:30:06,879
slack Borg space you want to engage

00:30:04,389 --> 00:30:07,629
please reach out we are open for

00:30:06,879 --> 00:30:11,440
multi-tenancy

00:30:07,629 --> 00:30:13,450
and are looking for beta testers I also

00:30:11,440 --> 00:30:15,879
want to give a shout out to the Chicago

00:30:13,450 --> 00:30:18,429
Python users group I would not be where

00:30:15,879 --> 00:30:19,960
I am as a developer or really as a

00:30:18,429 --> 00:30:24,759
person without that fantastic

00:30:19,960 --> 00:30:27,340
organization thanks so much for your

00:30:24,759 --> 00:30:30,090
time and I'll see you all in Pittsburgh

00:30:27,340 --> 00:30:30,090
next year

00:30:36,530 --> 00:30:38,590

YouTube URL: https://www.youtube.com/watch?v=P0kfKqMHioQ


