Title: Talk: Deepak Kumar Gupta - Saved by In-Memory NoSQL
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	If you’ve ever heard about or experienced a scenario where a production python bug can’t be fixed because we’re not able to reproduce the same, sometimes even after adding additional logs, then this session is for you.

Black box debugging is an idea where we add low footprint and encoded debug logs in the production code which drastically increases the chances of detecting the cause of a bug without requiring a recurrence with additional logs (read Debug Logs).

Traditionally, we tend to include a limited amount of logs in the production code because writing the logs on the disk is a costly affair and can potentially impact the performances, but at the same time if something goes wrong, then we need the logs to debug the system.

So what if I tell you that you can have debug logs in the production code without impacting the performance of the code…!!! I bet you’ll be pleasantly surprised.

Welcome to the world of harnessing an unexpected and unintended benefit of In-Memory NoSQL databases which revolutionized the way we write debug logs for our python code.

In this talk, I’ll talk about how we use In-Memory NoSQL with python code and get persistent logs without impacting the performance of the production code.
Captions: 
	00:00:12,290 --> 00:00:16,850
hello everyone welcome to this icon 2020

00:00:15,650 --> 00:00:19,039
talk tight

00:00:16,850 --> 00:00:21,279
to buy in memory no sequel or hitchhiker

00:00:19,039 --> 00:00:24,710
guide to black box debugging of Python

00:00:21,279 --> 00:00:26,720
production core sorry about long title

00:00:24,710 --> 00:00:28,880
but I believe by the end of this talk

00:00:26,720 --> 00:00:31,310
you will understand all of it

00:00:28,880 --> 00:00:33,320
so before we go ahead something about me

00:00:31,310 --> 00:00:35,269
my name is Deepak Gupta I am I take

00:00:33,320 --> 00:00:36,920
consultant and software crafter I'm

00:00:35,269 --> 00:00:39,559
working in this industry for more than

00:00:36,920 --> 00:00:42,680
20 years and these are some social media

00:00:39,559 --> 00:00:44,930
handles where you can reach out to me so

00:00:42,680 --> 00:00:47,809
let's go ahead and start let's first

00:00:44,930 --> 00:00:50,120
talk about black box now whenever you

00:00:47,809 --> 00:00:52,219
hear the term black box what comes to

00:00:50,120 --> 00:00:54,410
your mind the picture of an airplane

00:00:52,219 --> 00:00:57,350
because black boxes are generally

00:00:54,410 --> 00:01:00,260
associated with airplane and black box

00:00:57,350 --> 00:01:03,050
debugging is actually inspired by black

00:01:00,260 --> 00:01:05,930
boxes that are there in an airplane so

00:01:03,050 --> 00:01:08,440
the airplane black boxes are extremely

00:01:05,930 --> 00:01:12,080
durable hardware it is made to survive

00:01:08,440 --> 00:01:13,940
extremely harsh conditions it has all

00:01:12,080 --> 00:01:16,670
the information about the running system

00:01:13,940 --> 00:01:18,950
in real time and those informations are

00:01:16,670 --> 00:01:21,430
encoded in nature which means that if

00:01:18,950 --> 00:01:23,810
someone gets the black box it is not

00:01:21,430 --> 00:01:25,790
possible for that person to take the

00:01:23,810 --> 00:01:27,080
black box and decode all the information

00:01:25,790 --> 00:01:29,570
and that's the reason we have

00:01:27,080 --> 00:01:32,840
specialized labs across the world to

00:01:29,570 --> 00:01:35,840
decode these informations and the reason

00:01:32,840 --> 00:01:37,729
for existence of black box is this in

00:01:35,840 --> 00:01:39,770
software this can happen quite often

00:01:37,729 --> 00:01:42,140
that you know something goes wrong in

00:01:39,770 --> 00:01:43,970
the production system and we are trying

00:01:42,140 --> 00:01:46,100
to find the root cause of it we are not

00:01:43,970 --> 00:01:47,960
able to find it we patched the

00:01:46,100 --> 00:01:50,630
production system with additional logs

00:01:47,960 --> 00:01:53,000
within the area which we feel that is

00:01:50,630 --> 00:01:55,729
the root cause of the problem and we

00:01:53,000 --> 00:01:57,740
expect the problem to reoccur again so

00:01:55,729 --> 00:01:59,869
that we can get more information and we

00:01:57,740 --> 00:02:02,390
just believe that these logs will be

00:01:59,869 --> 00:02:04,880
able to help us in finding the root

00:02:02,390 --> 00:02:07,399
cause that option is not there in an

00:02:04,880 --> 00:02:09,170
airplane so in black box debugging we

00:02:07,399 --> 00:02:12,579
wanted to come up with something similar

00:02:09,170 --> 00:02:14,900
where we rarely need to patch the

00:02:12,579 --> 00:02:17,660
existing production system to find the

00:02:14,900 --> 00:02:19,400
root cause of a problem and here is how

00:02:17,660 --> 00:02:21,739
the black box architecture looks like

00:02:19,400 --> 00:02:23,720
it's extremely simple there is a

00:02:21,739 --> 00:02:25,790
separate entity called black box which

00:02:23,720 --> 00:02:27,829
is totally separate and it doesn't

00:02:25,790 --> 00:02:28,870
impact the performance of any of the

00:02:27,829 --> 00:02:31,360
existing component

00:02:28,870 --> 00:02:33,940
it just get the data get the real-time

00:02:31,360 --> 00:02:35,860
data about component performance like

00:02:33,940 --> 00:02:37,959
there are thousands of components in an

00:02:35,860 --> 00:02:39,879
airplane they put their real-time data

00:02:37,959 --> 00:02:43,510
into the black path their functionality

00:02:39,879 --> 00:02:45,640
is not dependent upon the black box so

00:02:43,510 --> 00:02:48,340
let's talk about how come python and

00:02:45,640 --> 00:02:50,349
black box comes into picture so we were

00:02:48,340 --> 00:02:52,299
building a system with complex set of

00:02:50,349 --> 00:02:54,909
state machines with hundreds of states

00:02:52,299 --> 00:02:56,680
events and transitions so if you are

00:02:54,909 --> 00:02:59,079
building a system like this you know

00:02:56,680 --> 00:03:01,870
that there is no happy path happy path

00:02:59,079 --> 00:03:04,180
means these are not set of states that

00:03:01,870 --> 00:03:06,359
will happen most of the time it depends

00:03:04,180 --> 00:03:08,829
totally upon the end user behavior and

00:03:06,359 --> 00:03:10,540
environmental circumstances and the

00:03:08,829 --> 00:03:13,930
permutation and combination of these

00:03:10,540 --> 00:03:15,730
state events and transitions are kind of

00:03:13,930 --> 00:03:18,400
limitless you know it's very difficult

00:03:15,730 --> 00:03:21,220
to understand when something happened in

00:03:18,400 --> 00:03:23,109
this state or because of this event what

00:03:21,220 --> 00:03:25,450
leads through triggering of this state

00:03:23,109 --> 00:03:28,060
and how many things happen and what

00:03:25,450 --> 00:03:30,040
leads to this particular state that's

00:03:28,060 --> 00:03:32,470
the reason we wanted to have a black box

00:03:30,040 --> 00:03:34,450
like feature so that each and every

00:03:32,470 --> 00:03:37,209
state activity events and transitions

00:03:34,450 --> 00:03:39,040
are actually recorded and with the

00:03:37,209 --> 00:03:41,440
recorded log we wanted to generate a

00:03:39,040 --> 00:03:43,690
visual sequence an activity diagram for

00:03:41,440 --> 00:03:45,549
the complete system so that it can help

00:03:43,690 --> 00:03:47,620
us in understanding what happened within

00:03:45,549 --> 00:03:50,079
the system and of course the tool would

00:03:47,620 --> 00:03:52,389
be sophisticated so that if we tell them

00:03:50,079 --> 00:03:55,930
to generate visual diagram from this to

00:03:52,389 --> 00:03:57,989
this time frame or top level or detailed

00:03:55,930 --> 00:04:00,910
level it will be able to do that and

00:03:57,989 --> 00:04:03,099
these logs will be released as part of

00:04:00,910 --> 00:04:05,799
production builds now it's a general

00:04:03,099 --> 00:04:07,569
practice that when we add logs we have

00:04:05,799 --> 00:04:10,299
different types of log like info log

00:04:07,569 --> 00:04:12,760
debug log critical logs and it's also a

00:04:10,299 --> 00:04:14,799
general practice that when we are giving

00:04:12,760 --> 00:04:16,660
the system to production we just enable

00:04:14,799 --> 00:04:19,840
critical logs of course because of the

00:04:16,660 --> 00:04:22,030
performance regions and we do not enable

00:04:19,840 --> 00:04:24,940
info and debug logs okay

00:04:22,030 --> 00:04:26,830
now let's talk about the code which we

00:04:24,940 --> 00:04:28,900
were writing the state machine it's a

00:04:26,830 --> 00:04:30,940
very miniature version of my state

00:04:28,900 --> 00:04:33,099
machine and I just wanted to give you a

00:04:30,940 --> 00:04:36,099
taste of the system how it looks like so

00:04:33,099 --> 00:04:37,810
we had state an event as an abstract

00:04:36,099 --> 00:04:40,240
base classes and we had a state machine

00:04:37,810 --> 00:04:41,390
this is not the original code this is

00:04:40,240 --> 00:04:44,030
just a miniature

00:04:41,390 --> 00:04:46,130
a state machine just to give you an idea

00:04:44,030 --> 00:04:48,470
how this was actually working so state

00:04:46,130 --> 00:04:50,240
machine starts with state it transition

00:04:48,470 --> 00:04:52,220
to next state there were multiple state

00:04:50,240 --> 00:04:54,170
machine inner state machines and all

00:04:52,220 --> 00:04:56,690
those complexities were built into the

00:04:54,170 --> 00:04:58,280
system so to understand the working of

00:04:56,690 --> 00:05:01,310
the system let's talk about a very

00:04:58,280 --> 00:05:03,590
simple real time example so we are in a

00:05:01,310 --> 00:05:05,930
happy state right now happy state is

00:05:03,590 --> 00:05:06,380
also in state and we received an event

00:05:05,930 --> 00:05:08,510
called

00:05:06,380 --> 00:05:11,180
lost money god forbid but we received

00:05:08,510 --> 00:05:13,490
this event and we moved to sad state

00:05:11,180 --> 00:05:15,590
we again received an event called gain

00:05:13,490 --> 00:05:18,020
money and we moved back to happy state

00:05:15,590 --> 00:05:20,810
so this is the very simple description

00:05:18,020 --> 00:05:23,090
of how state machine worked but when we

00:05:20,810 --> 00:05:24,800
generated the log we didn't wanted to

00:05:23,090 --> 00:05:26,930
write in love that you know I mean happy

00:05:24,800 --> 00:05:29,750
state I lost money I am moving to sad

00:05:26,930 --> 00:05:32,150
state I'm inside state again money I am

00:05:29,750 --> 00:05:34,220
moving to happy state know what we

00:05:32,150 --> 00:05:36,920
wanted to do is something similar to

00:05:34,220 --> 00:05:38,990
what black boxes does is that we wanted

00:05:36,920 --> 00:05:41,360
to have a encoded information in coded

00:05:38,990 --> 00:05:42,980
locks and for that we created a mapping

00:05:41,360 --> 00:05:44,720
table something very similar to this

00:05:42,980 --> 00:05:46,850
like you know happy state will be

00:05:44,720 --> 00:05:48,560
represented by a one side by two gained

00:05:46,850 --> 00:05:52,070
and lost money will be represented by

00:05:48,560 --> 00:05:54,050
Roman one and two and once the log file

00:05:52,070 --> 00:05:56,660
will be generated here is how the log

00:05:54,050 --> 00:06:00,010
file will look like it will be a jumbled

00:05:56,660 --> 00:06:02,600
sequence of some characters numbers and

00:06:00,010 --> 00:06:05,870
nobody will be able to make any sense of

00:06:02,600 --> 00:06:07,730
it because they cannot decode it and

00:06:05,870 --> 00:06:10,220
that was extremely beneficial for us

00:06:07,730 --> 00:06:12,410
because we are generating lots in a

00:06:10,220 --> 00:06:15,140
production system and even if someone

00:06:12,410 --> 00:06:17,420
accidentally or deliberately get access

00:06:15,140 --> 00:06:20,450
to these logs it is not possible for

00:06:17,420 --> 00:06:22,220
them to decode it the other benefit is

00:06:20,450 --> 00:06:23,870
that you know it reduces the log size

00:06:22,220 --> 00:06:27,140
instead of writing plain text if you

00:06:23,870 --> 00:06:30,740
write jumbled encoded short information

00:06:27,140 --> 00:06:33,380
it will reduce the log size so this is

00:06:30,740 --> 00:06:35,780
how locks will be generated but to do a

00:06:33,380 --> 00:06:38,360
black box debugging just generating

00:06:35,780 --> 00:06:40,610
locks are not enough we need a complete

00:06:38,360 --> 00:06:42,620
infrastructure at our end we need data

00:06:40,610 --> 00:06:44,390
structure storage format mapping table

00:06:42,620 --> 00:06:46,700
decoding logic visualization tool

00:06:44,390 --> 00:06:49,910
basically we have to build a complete

00:06:46,700 --> 00:06:52,400
system at our end where we can freedom

00:06:49,910 --> 00:06:53,770
locks and we get the sequence and

00:06:52,400 --> 00:06:56,830
activity diagrams

00:06:53,770 --> 00:06:58,750
out of it okay so we needed to build a

00:06:56,830 --> 00:07:01,750
complete system it was complex but it

00:06:58,750 --> 00:07:03,370
was kind of one-time job but we needed

00:07:01,750 --> 00:07:05,080
to build something to be able to see

00:07:03,370 --> 00:07:08,110
these lofts otherwise it's very

00:07:05,080 --> 00:07:11,650
difficult to manually decode it and try

00:07:08,110 --> 00:07:14,319
to get sense of it so that was the

00:07:11,650 --> 00:07:16,569
complete idea of blackbox debugging I

00:07:14,319 --> 00:07:19,300
know you might be thinking it's a smart

00:07:16,569 --> 00:07:21,879
idea and you also know that it will work

00:07:19,300 --> 00:07:24,520
if we get all the information it will be

00:07:21,879 --> 00:07:26,889
easy for us to reconstruct based on the

00:07:24,520 --> 00:07:29,560
information which we already have but as

00:07:26,889 --> 00:07:31,509
the saying goes ideas are good execution

00:07:29,560 --> 00:07:34,270
is everything when we thought about

00:07:31,509 --> 00:07:35,830
blackbox tbling the biggest question

00:07:34,270 --> 00:07:38,229
that came to our mind is about

00:07:35,830 --> 00:07:40,150
performance you might have also guessed

00:07:38,229 --> 00:07:44,560
that performance would be a huge issue

00:07:40,150 --> 00:07:46,719
and we needed disk rights to happen to

00:07:44,560 --> 00:07:49,210
be able to persist the lock whether it

00:07:46,719 --> 00:07:51,190
is a file right or database right we

00:07:49,210 --> 00:07:54,009
needed to write it onto the disk and

00:07:51,190 --> 00:07:56,440
it's a huge performance issue especially

00:07:54,009 --> 00:07:59,620
when we want to write such a huge amount

00:07:56,440 --> 00:08:02,219
of logs now we also looked into some of

00:07:59,620 --> 00:08:05,620
the existing logging strategies used by

00:08:02,219 --> 00:08:07,479
various systems and people some of them

00:08:05,620 --> 00:08:10,120
are called the ring buffer a circular

00:08:07,479 --> 00:08:12,550
buffer where locks are actually kept in

00:08:10,120 --> 00:08:13,990
memory before writing it on to that is

00:08:12,550 --> 00:08:16,900
so which means that if you have a

00:08:13,990 --> 00:08:19,240
circular buffer for let's say 1m besides

00:08:16,900 --> 00:08:22,509
you will wait for 1 MB to fail before

00:08:19,240 --> 00:08:25,150
writing it into the disk but for us this

00:08:22,509 --> 00:08:28,419
was a problem we cannot do that because

00:08:25,150 --> 00:08:30,759
to be able to behave like black boxes we

00:08:28,419 --> 00:08:34,029
needed real-time logs especially for

00:08:30,759 --> 00:08:36,339
state transition and events so if an

00:08:34,029 --> 00:08:38,589
event is being triggered we need to

00:08:36,339 --> 00:08:40,959
write that log because if something goes

00:08:38,589 --> 00:08:43,719
wrong at that time we will lose that

00:08:40,959 --> 00:08:46,360
information which means that we need

00:08:43,719 --> 00:08:48,610
some of the things to be written in real

00:08:46,360 --> 00:08:50,890
time of course there were a few things

00:08:48,610 --> 00:08:54,339
which can hold on for a while but state

00:08:50,890 --> 00:08:57,190
transition and receiving an event is

00:08:54,339 --> 00:08:59,230
something you need it to be present in

00:08:57,190 --> 00:09:01,600
real time so here is how the

00:08:59,230 --> 00:09:03,870
architecture of our blackbox debugging

00:09:01,600 --> 00:09:06,529
looks like we had a totally different

00:09:03,870 --> 00:09:09,350
dedicated server reachable via TC

00:09:06,529 --> 00:09:11,269
II for the logging and we had our

00:09:09,350 --> 00:09:13,129
production code running in a different

00:09:11,269 --> 00:09:15,019
place so that different place could be

00:09:13,129 --> 00:09:17,149
our own servers or some of the servers

00:09:15,019 --> 00:09:19,639
in the cloud they are in a totally

00:09:17,149 --> 00:09:23,029
different space in this dedicated log

00:09:19,639 --> 00:09:24,829
server is in a different space so far so

00:09:23,029 --> 00:09:26,629
good but we where is really skeptical

00:09:24,829 --> 00:09:29,269
whether this code works so what we did

00:09:26,629 --> 00:09:31,189
is that you know we gave it a first try

00:09:29,269 --> 00:09:33,680
with file right I mean receiving that

00:09:31,189 --> 00:09:36,439
ECP socket buffer and writing it into a

00:09:33,680 --> 00:09:38,600
file and as you might have guessed it

00:09:36,439 --> 00:09:42,559
took lots of time and it was expected

00:09:38,600 --> 00:09:44,329
also second was SQL database right and

00:09:42,559 --> 00:09:47,389
of course it was better than file writes

00:09:44,329 --> 00:09:49,490
because it totally depends upon how you

00:09:47,389 --> 00:09:52,610
create the schema whether you can huge

00:09:49,490 --> 00:09:54,639
async and other options now one thing

00:09:52,610 --> 00:09:57,589
for us reading was not an issue so

00:09:54,639 --> 00:09:59,600
creation of joins to read data was not

00:09:57,589 --> 00:10:02,449
an issue for us because we didn't want

00:09:59,600 --> 00:10:04,670
it to read in real time for us

00:10:02,449 --> 00:10:07,490
writing the locks was the biggest thing

00:10:04,670 --> 00:10:09,579
it was better but is still not up to the

00:10:07,490 --> 00:10:12,290
mark as far as performance is concerned

00:10:09,579 --> 00:10:14,870
so we gave it a third try with a no

00:10:12,290 --> 00:10:17,329
sequel database right it was generally

00:10:14,870 --> 00:10:19,399
better but not always so again it

00:10:17,329 --> 00:10:23,300
depends upon the type of data you want

00:10:19,399 --> 00:10:25,550
to use and depends upon how you put the

00:10:23,300 --> 00:10:28,459
data how Zuria is the data so basically

00:10:25,550 --> 00:10:30,920
data engineering matters over here now I

00:10:28,459 --> 00:10:32,930
am NOT taking the name of sequel and no

00:10:30,920 --> 00:10:34,750
sequel databases because we are not

00:10:32,930 --> 00:10:37,579
judging the database we are not

00:10:34,750 --> 00:10:39,949
benchmarking them what we had is a

00:10:37,579 --> 00:10:42,079
different kind of problem which we were

00:10:39,949 --> 00:10:44,300
trying to solve it has nothing to do

00:10:42,079 --> 00:10:47,420
with the capability or usability of a

00:10:44,300 --> 00:10:50,000
database so this is how it looks like

00:10:47,420 --> 00:10:52,970
but still the performance version issue

00:10:50,000 --> 00:10:55,189
now the performance impact was still

00:10:52,970 --> 00:10:57,920
beyond acceptable limit so we were

00:10:55,189 --> 00:10:59,540
inverse of discarding this idea before

00:10:57,920 --> 00:11:02,240
that we thought of trying no sequel

00:10:59,540 --> 00:11:04,009
in-memory database types so in memory

00:11:02,240 --> 00:11:06,559
databases we're not the first choice

00:11:04,009 --> 00:11:09,679
because it is limited by the memory of

00:11:06,559 --> 00:11:12,350
the system which is much much lesser as

00:11:09,679 --> 00:11:14,660
compared to disk space of the system so

00:11:12,350 --> 00:11:16,370
it was not possible for us to store all

00:11:14,660 --> 00:11:18,740
the data in the memory so we came up

00:11:16,370 --> 00:11:20,600
with a trick what we did is that you

00:11:18,740 --> 00:11:23,480
know we in out

00:11:20,600 --> 00:11:25,880
no sequel in-memory database to listen

00:11:23,480 --> 00:11:28,220
to the TCP connection and receive all

00:11:25,880 --> 00:11:31,520
the locks and store it and what we did

00:11:28,220 --> 00:11:33,170
is that we run a bad system behind the

00:11:31,520 --> 00:11:35,600
scenes which will trigger after some

00:11:33,170 --> 00:11:38,570
time or when the memory usage goes

00:11:35,600 --> 00:11:41,300
beyond as acceptable limit it will run

00:11:38,570 --> 00:11:44,110
it will put the data into a persistent

00:11:41,300 --> 00:11:48,260
disks or so in that way this was working

00:11:44,110 --> 00:11:51,560
so finally this gave us some of the

00:11:48,260 --> 00:11:54,650
acceptable performance limit now one

00:11:51,560 --> 00:11:56,660
caveat if you just replace your you know

00:11:54,650 --> 00:11:59,000
this database with in-memory database

00:11:56,660 --> 00:12:01,070
and expect a huge performance gain this

00:11:59,000 --> 00:12:03,650
is not going to happen you need to

00:12:01,070 --> 00:12:06,200
engineer how you want to store data in a

00:12:03,650 --> 00:12:08,330
memory database also because data

00:12:06,200 --> 00:12:10,760
structures if they start taking more

00:12:08,330 --> 00:12:13,460
time it will negate the benefits of

00:12:10,760 --> 00:12:16,160
in-memory database so we didn't got

00:12:13,460 --> 00:12:18,650
perfect results in first goal we had to

00:12:16,160 --> 00:12:20,990
do some kind of data engineering now

00:12:18,650 --> 00:12:22,790
this was in acceptable limits but we

00:12:20,990 --> 00:12:25,310
thought that you know can we improve the

00:12:22,790 --> 00:12:27,710
performance bit more we came up with an

00:12:25,310 --> 00:12:30,020
idea and it actually indeed improved the

00:12:27,710 --> 00:12:31,790
performance so the optimization is that

00:12:30,020 --> 00:12:33,860
our production code is running in two

00:12:31,790 --> 00:12:35,860
different servers maybe in cloud maybe

00:12:33,860 --> 00:12:38,810
in our one premise

00:12:35,860 --> 00:12:41,180
what we did is that we created us in

00:12:38,810 --> 00:12:44,210
strengths of in memory Debbie within

00:12:41,180 --> 00:12:46,070
that server itself so logs will be

00:12:44,210 --> 00:12:47,930
written in this in memory Debbie within

00:12:46,070 --> 00:12:50,210
that server where the production code is

00:12:47,930 --> 00:12:52,040
running and there will be a bad job

00:12:50,210 --> 00:12:55,400
which will take the data from this in

00:12:52,040 --> 00:12:58,010
memory and transfer it into a physical

00:12:55,400 --> 00:13:01,490
database so this bad job will be running

00:12:58,010 --> 00:13:03,260
in each and every server now I would

00:13:01,490 --> 00:13:06,260
like to share one observation and that's

00:13:03,260 --> 00:13:08,420
a very important information so we know

00:13:06,260 --> 00:13:11,300
server the communication will be fast

00:13:08,420 --> 00:13:13,670
but if we replaced any memory DB with

00:13:11,300 --> 00:13:16,130
another disk TB the performance

00:13:13,670 --> 00:13:18,530
difference is sometimes negligible and

00:13:16,130 --> 00:13:20,360
it exactly depends upon that kind of

00:13:18,530 --> 00:13:22,730
data via writing amount of data we are

00:13:20,360 --> 00:13:25,750
writing especially if we are using some

00:13:22,730 --> 00:13:28,280
SS states the performance difference is

00:13:25,750 --> 00:13:31,610
non-countable for a small amount of data

00:13:28,280 --> 00:13:32,750
but we had to end up using in-memory DB

00:13:31,610 --> 00:13:35,389
because you know in it is

00:13:32,750 --> 00:13:37,730
Phoebe you need to write it on the disk

00:13:35,389 --> 00:13:40,100
as well as read from the disk so that

00:13:37,730 --> 00:13:43,490
your bad job can transfer it onto a

00:13:40,100 --> 00:13:45,769
physical DB in in-memory DB you have to

00:13:43,490 --> 00:13:48,050
read from the memory itself which is

00:13:45,769 --> 00:13:51,949
again bit faster so overall it turned

00:13:48,050 --> 00:13:54,019
out to be faster so that's all what we

00:13:51,949 --> 00:13:56,720
did and I hope that I was able to

00:13:54,019 --> 00:13:58,850
explain you in this particular talk now

00:13:56,720 --> 00:14:02,389
before I close some caution about

00:13:58,850 --> 00:14:04,370
blackbox debugging it's generally a very

00:14:02,389 --> 00:14:06,819
complex undertaking so you are just

00:14:04,370 --> 00:14:10,250
creating a sort lave a small project

00:14:06,819 --> 00:14:12,980
maybe it's not a best idea to use this

00:14:10,250 --> 00:14:16,220
particular thing it is good for long

00:14:12,980 --> 00:14:18,079
term of critical system again even if

00:14:16,220 --> 00:14:18,589
you are writing in memory it will take

00:14:18,079 --> 00:14:20,990
some time

00:14:18,589 --> 00:14:23,209
even if nanosecond millisecond but it

00:14:20,990 --> 00:14:25,759
will take some time and if you can

00:14:23,209 --> 00:14:29,089
afford that it's a good idea to write

00:14:25,759 --> 00:14:31,730
all those logs it will help you not only

00:14:29,089 --> 00:14:34,459
in understanding the problems in the

00:14:31,730 --> 00:14:36,350
production system but will also help you

00:14:34,459 --> 00:14:38,660
in understanding the behavior of the

00:14:36,350 --> 00:14:41,540
system which you can look and think

00:14:38,660 --> 00:14:43,879
about optimizing it third and final

00:14:41,540 --> 00:14:46,279
thing this is not limited to just Python

00:14:43,879 --> 00:14:48,680
you can use this particular idea of

00:14:46,279 --> 00:14:50,959
black box by beginning almost any

00:14:48,680 --> 00:14:54,529
programming language and all the

00:14:50,959 --> 00:14:56,329
database provides trival to write in it

00:14:54,529 --> 00:14:59,870
from any other programming language

00:14:56,329 --> 00:15:01,670
including in-memory database so that's

00:14:59,870 --> 00:15:04,339
all I had for this particular talk

00:15:01,670 --> 00:15:06,290
thanks a lot for listening thank you

00:15:04,339 --> 00:15:09,319
Pike on 20/20 for providing this

00:15:06,290 --> 00:15:11,559
opportunity thanks a lot good day take

00:15:09,319 --> 00:15:11,559

YouTube URL: https://www.youtube.com/watch?v=NjMTf2UWPsw


