Title: Talk: Conor Hoekstra - Beautiful Python Refactoring
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Conor Hoekstra

Refactoring can lead to absolutely beautiful code. Not only this, but the refactoring itself can be a thing of beauty. This talk demonstrates taking an example with a double-digit number of lines of code down to a single-digit number of lines of code. This talk will show how to identify certain anti-patterns that can be replaced with more expressive and declarative code. This is a simple talk that can be understood by all, but when applied to oneâ€™s daily work can make a significant difference.


Talk slides and code: https://github.com/codereport/Talks/tree/master/2020-04-PyCon/BeautifulPythonRefactoring
Captions: 
	00:00:04,810 --> 00:00:10,240
welcome to my PyCon 2020 talk entitled

00:00:08,020 --> 00:00:12,370
beautiful Python refactoring my name is

00:00:10,240 --> 00:00:14,530
Connor Hoekstra and I go by code

00:00:12,370 --> 00:00:17,350
underscore reports on Twitter and

00:00:14,530 --> 00:00:19,690
YouTube a little bit about me before we

00:00:17,350 --> 00:00:22,180
hop into the talk I'm a senior library

00:00:19,690 --> 00:00:25,330
software engineer working for nvidia on

00:00:22,180 --> 00:00:27,940
the rapids AI team our team is

00:00:25,330 --> 00:00:30,040
developing a end end data science

00:00:27,940 --> 00:00:31,180
pipeline that runs on the GPU so if

00:00:30,040 --> 00:00:33,190
you're interested in checking that out

00:00:31,180 --> 00:00:36,160
check us out at rapid a I

00:00:33,190 --> 00:00:39,960
I am a programming language enthusiast

00:00:36,160 --> 00:00:42,879
so my majority of my experience is in

00:00:39,960 --> 00:00:46,780
C++ and Python but I'm actively learning

00:00:42,879 --> 00:00:48,760
several other languages at all times the

00:00:46,780 --> 00:00:52,480
team that I work on primarily uses C++

00:00:48,760 --> 00:00:55,030
14 and Python 3 I love algorithms and

00:00:52,480 --> 00:00:58,269
beautiful code I have a youtube channel

00:00:55,030 --> 00:01:00,670
at youtube.com slash code report where I

00:00:58,269 --> 00:01:04,120
solve competitive programming problems

00:01:00,670 --> 00:01:05,800
in a variety of different languages so

00:01:04,120 --> 00:01:09,009
if you're interested check that out and

00:01:05,800 --> 00:01:10,990
as I mentioned before I a liason line is

00:01:09,009 --> 00:01:12,340
code underscore reports so if you're

00:01:10,990 --> 00:01:15,490
trying to search me sometimes that's

00:01:12,340 --> 00:01:19,000
easier than searching my name so why am

00:01:15,490 --> 00:01:21,579
I giving this talk approximately half a

00:01:19,000 --> 00:01:23,259
year ago or maybe later depending on

00:01:21,579 --> 00:01:25,979
when you're watching this talk online I

00:01:23,259 --> 00:01:30,070
joined the Nvidia rapids team

00:01:25,979 --> 00:01:31,990
specifically I work on the ku DF library

00:01:30,070 --> 00:01:35,200
so there are multiple libraries that

00:01:31,990 --> 00:01:36,880
exist within the rapids organization or

00:01:35,200 --> 00:01:40,390
that the rapids organization is working

00:01:36,880 --> 00:01:43,630
on and I work on the ku DF library so

00:01:40,390 --> 00:01:45,579
the COO in each of these libraries comes

00:01:43,630 --> 00:01:47,950
from CUDA which is the parallel

00:01:45,579 --> 00:01:49,810
programming platform and programming

00:01:47,950 --> 00:01:52,000
model or at least that's what the online

00:01:49,810 --> 00:01:55,030
website says I like to think of cuda as

00:01:52,000 --> 00:02:00,939
the programming language that you can

00:01:55,030 --> 00:02:03,640
use to do GPU computing and the DF and

00:02:00,939 --> 00:02:06,939
qu D F stands for data frame so there

00:02:03,640 --> 00:02:10,750
are typically two data frames that I

00:02:06,939 --> 00:02:12,760
know of obviously the ku DF library

00:02:10,750 --> 00:02:15,190
because that's the one that I work on or

00:02:12,760 --> 00:02:17,769
the team that I work on develops and the

00:02:15,190 --> 00:02:18,540
other more widely known data frame

00:02:17,769 --> 00:02:20,640
library

00:02:18,540 --> 00:02:23,250
pandas so if you're not familiar with

00:02:20,640 --> 00:02:25,230
pandas the one-line description from

00:02:23,250 --> 00:02:27,209
their website is pandas is a fast

00:02:25,230 --> 00:02:28,680
powerful flexible and easy to use

00:02:27,209 --> 00:02:31,140
open-source data analysis and

00:02:28,680 --> 00:02:32,959
manipulation tool built on top of the

00:02:31,140 --> 00:02:36,659
Python programming language and the

00:02:32,959 --> 00:02:39,359
one-line description of Kuh DF is that

00:02:36,659 --> 00:02:41,159
Kuh DF provides a pandas like API that

00:02:39,359 --> 00:02:43,439
will be familiar to data engineers and

00:02:41,159 --> 00:02:45,209
data scientists so they can use it to

00:02:43,439 --> 00:02:47,250
easily accelerate their workflows

00:02:45,209 --> 00:02:51,030
without going into the details of CUDA

00:02:47,250 --> 00:02:55,859
programming so the data frame Python API

00:02:51,030 --> 00:02:58,169
is modeled very closely on the pandas

00:02:55,859 --> 00:02:59,730
API so that data scientists that are

00:02:58,169 --> 00:03:03,329
familiar with working with pandas will

00:02:59,730 --> 00:03:05,519
find it very easy to transition to the

00:03:03,329 --> 00:03:08,069
kudiye for rapid data frame library if

00:03:05,519 --> 00:03:10,829
they need to accelerate the data science

00:03:08,069 --> 00:03:13,230
that they are doing so when I started

00:03:10,829 --> 00:03:15,230
back in October I thought that it would

00:03:13,230 --> 00:03:18,150
be good to familiarize myself with the

00:03:15,230 --> 00:03:21,389
pandas library so I decided that I was

00:03:18,150 --> 00:03:23,669
going to work on a small toy project

00:03:21,389 --> 00:03:26,579
that could use pandas to manipulate some

00:03:23,669 --> 00:03:27,989
data or analyze some data so that I

00:03:26,579 --> 00:03:31,109
could get familiar with pandas so I

00:03:27,989 --> 00:03:34,680
decided that what I was going to do was

00:03:31,109 --> 00:03:37,280
analyze the data that is on one of the

00:03:34,680 --> 00:03:39,629
competitive programming websites that I

00:03:37,280 --> 00:03:41,870
occasionally compete on and cover on my

00:03:39,629 --> 00:03:44,669
youtube channel that is code forces and

00:03:41,870 --> 00:03:46,379
they give you data on the number of

00:03:44,669 --> 00:03:49,139
submissions whether they're successful

00:03:46,379 --> 00:03:52,019
or they fail and what I was most curious

00:03:49,139 --> 00:03:54,540
about which was the language that you

00:03:52,019 --> 00:03:56,250
are submitting it in so the question

00:03:54,540 --> 00:03:58,079
that I came up with was what are the

00:03:56,250 --> 00:04:00,870
most popular programming languages used

00:03:58,079 --> 00:04:02,459
on sites like code forces so for this

00:04:00,870 --> 00:04:04,829
talk I'm basically going to show the

00:04:02,459 --> 00:04:07,590
steps that I went through to get that

00:04:04,829 --> 00:04:10,349
code working and throughout that process

00:04:07,590 --> 00:04:12,840
I ended up refactoring a lot of code

00:04:10,349 --> 00:04:15,810
that I had pulled off of a website and

00:04:12,840 --> 00:04:17,400
in from a blog in particular and I think

00:04:15,810 --> 00:04:19,109
it is going to be really illustrative

00:04:17,400 --> 00:04:21,060
and hopefully you'll find it educational

00:04:19,109 --> 00:04:23,729
and be able to learn from a few of the

00:04:21,060 --> 00:04:24,930
refactorings that I did and improve the

00:04:23,729 --> 00:04:27,240
quality of the code that you're writing

00:04:24,930 --> 00:04:29,159
on a day to day basis so how do we go

00:04:27,240 --> 00:04:31,860
about doing this it's really only two

00:04:29,159 --> 00:04:34,110
steps the first step is to scrape the

00:04:31,860 --> 00:04:36,509
jemelle data from the code force's

00:04:34,110 --> 00:04:39,300
website with pandas and the second step

00:04:36,509 --> 00:04:41,310
is to analyze that data with pandas and

00:04:39,300 --> 00:04:44,699
once we're done those steps we're done

00:04:41,310 --> 00:04:46,680
so for the duration of this talk 90% of

00:04:44,699 --> 00:04:48,389
it will take place in step number one

00:04:46,680 --> 00:04:50,909
because that is where all of the

00:04:48,389 --> 00:04:52,650
refactorings that I did occurred but I

00:04:50,909 --> 00:04:54,870
also spend the last 10% of the talk

00:04:52,650 --> 00:04:57,389
showing you the analysis with pandas

00:04:54,870 --> 00:04:59,909
just to motivate why you might be

00:04:57,389 --> 00:05:02,490
interested in picking up pandas or a

00:04:59,909 --> 00:05:05,009
library like ku DF so how do we go about

00:05:02,490 --> 00:05:07,229
scraping HTML with pandas I had no idea

00:05:05,009 --> 00:05:10,529
so what does any engineer do when they

00:05:07,229 --> 00:05:12,150
have no idea they go to Google and they

00:05:10,529 --> 00:05:15,330
type in what they'd like to do is scrape

00:05:12,150 --> 00:05:17,490
HTML with pandas I did this and in the

00:05:15,330 --> 00:05:19,379
second results I found web scraping HTML

00:05:17,490 --> 00:05:22,289
tables with Python that had a reference

00:05:19,379 --> 00:05:25,289
to the pandas dataframe in it so I open

00:05:22,289 --> 00:05:27,840
that up and I got to the following blog

00:05:25,289 --> 00:05:30,599
and this blog takes you step-by-step

00:05:27,840 --> 00:05:31,889
through how to set up a piece of code

00:05:30,599 --> 00:05:34,289
that will basically scrape the

00:05:31,889 --> 00:05:37,740
information that you want from an HTML

00:05:34,289 --> 00:05:40,349
table so I went through this and at the

00:05:37,740 --> 00:05:42,000
end of it it's about 60 plus lines of

00:05:40,349 --> 00:05:45,330
code depending on how you look at it and

00:05:42,000 --> 00:05:47,039
we're gonna quickly go through and sort

00:05:45,330 --> 00:05:48,810
of highlights each of the sections of

00:05:47,039 --> 00:05:52,129
that code that they sort of break apart

00:05:48,810 --> 00:05:54,389
in the blog so the first section is the

00:05:52,129 --> 00:05:55,860
imports which is pretty straightforward

00:05:54,389 --> 00:06:00,389
nothing really we need to talk about

00:05:55,860 --> 00:06:03,060
here requests is for getting the HTML LX

00:06:00,389 --> 00:06:06,120
ml is for being able to parse and read

00:06:03,060 --> 00:06:07,319
the HTML and then pandas is for the data

00:06:06,120 --> 00:06:10,500
frame that we're going to set up at the

00:06:07,319 --> 00:06:12,719
end the second section is initializing

00:06:10,500 --> 00:06:14,300
the page doc and T are elements that

00:06:12,719 --> 00:06:17,430
we're going to use to do the scraping

00:06:14,300 --> 00:06:20,610
after that we have our first for loop

00:06:17,430 --> 00:06:23,339
which is used to extract the titles from

00:06:20,610 --> 00:06:26,279
each of the columns in our table that is

00:06:23,339 --> 00:06:29,069
on the code forces website the second

00:06:26,279 --> 00:06:31,800
piece of code that involves for loops is

00:06:29,069 --> 00:06:35,279
two nested for-loops which is used for

00:06:31,800 --> 00:06:38,009
basically extracting the contents of our

00:06:35,279 --> 00:06:40,709
HTML HTML table in each of the columns

00:06:38,009 --> 00:06:43,729
of the table and then at the very end we

00:06:40,709 --> 00:06:45,689
construct a data frame from a dictionary

00:06:43,729 --> 00:06:48,599
that is constructed

00:06:45,689 --> 00:06:51,659
using a dictionary comprehension so the

00:06:48,599 --> 00:06:55,349
first piece of code that we are going to

00:06:51,659 --> 00:06:59,899
look at is going to be the first for

00:06:55,349 --> 00:07:02,669
loop that we showed you so here we have

00:06:59,899 --> 00:07:06,119
initialization of an empty list Co L and

00:07:02,669 --> 00:07:07,799
an index I and then we have a for loop

00:07:06,119 --> 00:07:10,229
that goes through each one reads

00:07:07,799 --> 00:07:13,529
something from each element of our TR

00:07:10,229 --> 00:07:15,659
elements data structure and then it pens

00:07:13,529 --> 00:07:18,899
it at the very end so we're gonna remove

00:07:15,659 --> 00:07:21,869
the comments here one primarily just to

00:07:18,899 --> 00:07:23,879
make the text bigger but two because

00:07:21,869 --> 00:07:26,459
these comments are a little bit

00:07:23,879 --> 00:07:29,249
redundant we don't really need a comment

00:07:26,459 --> 00:07:32,009
to tell us that we are constructing or

00:07:29,249 --> 00:07:34,679
initializing an empty list here so we

00:07:32,009 --> 00:07:36,929
remove the comments and the first thing

00:07:34,679 --> 00:07:39,059
that we notice about this code is the

00:07:36,929 --> 00:07:41,759
following pattern we are initializing an

00:07:39,059 --> 00:07:45,149
index I then looping through each of the

00:07:41,759 --> 00:07:47,399
elements in our TR elements first row

00:07:45,149 --> 00:07:51,360
and then right after that we're doing an

00:07:47,399 --> 00:07:52,529
increment to our index if you ever have

00:07:51,360 --> 00:07:55,919
this pattern where you're initializing

00:07:52,529 --> 00:07:57,839
an index outside a loop and then inside

00:07:55,919 --> 00:07:59,550
your loop incrementing it there is a

00:07:57,839 --> 00:08:02,729
function or an algorithm for this in

00:07:59,550 --> 00:08:04,769
Python called enumerate so using

00:08:02,729 --> 00:08:06,449
enumerate we can basically remove the

00:08:04,769 --> 00:08:09,479
initialization of our index and the

00:08:06,449 --> 00:08:11,879
incrementing of our index and pass our

00:08:09,479 --> 00:08:14,249
TR elements first row to enumerate and

00:08:11,879 --> 00:08:17,699
then using D structuring we can D

00:08:14,249 --> 00:08:20,939
structure the now zipped indexed with

00:08:17,699 --> 00:08:24,479
each of our elements in TR elements into

00:08:20,939 --> 00:08:26,579
int so I will be our index and T will be

00:08:24,479 --> 00:08:29,189
the elements that we were originally

00:08:26,579 --> 00:08:31,979
getting from our TR elements first row

00:08:29,189 --> 00:08:33,539
so this is an algorithm that's known by

00:08:31,979 --> 00:08:35,639
a couple different names in different

00:08:33,539 --> 00:08:38,939
languages if you found yourself at this

00:08:35,639 --> 00:08:41,519
video is a not a Python programmer so

00:08:38,939 --> 00:08:44,610
it's primarily known as enumerates in

00:08:41,519 --> 00:08:46,350
languages like Python rust and D but in

00:08:44,610 --> 00:08:48,540
other languages it's also known as with

00:08:46,350 --> 00:08:52,589
index and Ruby common and elixir and

00:08:48,540 --> 00:08:54,179
also as indexed in racket in Haskell so

00:08:52,589 --> 00:08:56,699
this is a very very useful algorithm

00:08:54,179 --> 00:08:59,000
I've seen this pattern many times where

00:08:56,699 --> 00:09:01,730
people are initializing an index out

00:08:59,000 --> 00:09:02,810
a range bass for loop that doesn't give

00:09:01,730 --> 00:09:05,540
you the index and then they're

00:09:02,810 --> 00:09:07,610
incrementing it inside the for loop if

00:09:05,540 --> 00:09:09,680
you can if your language has it and

00:09:07,610 --> 00:09:12,110
python does try to make use of this

00:09:09,680 --> 00:09:15,379
enumerate so the second thing that I

00:09:12,110 --> 00:09:17,029
noticed was that the index that we are

00:09:15,379 --> 00:09:19,189
now getting from enumerate is actually

00:09:17,029 --> 00:09:21,379
only used in one place and that's in

00:09:19,189 --> 00:09:23,180
this print statement I'm not exactly

00:09:21,379 --> 00:09:25,220
sure what the initial purpose of this

00:09:23,180 --> 00:09:28,670
print statement was probably for

00:09:25,220 --> 00:09:30,769
debugging purposes it's supposed to be

00:09:28,670 --> 00:09:33,139
sort of a teaching blog so my guess is

00:09:30,769 --> 00:09:35,779
this was to make it easier to understand

00:09:33,139 --> 00:09:37,550
for the individual putting this code

00:09:35,779 --> 00:09:39,620
together but at the end of the day you

00:09:37,550 --> 00:09:41,600
don't actually need this print statement

00:09:39,620 --> 00:09:43,970
so the second refactoring that we can do

00:09:41,600 --> 00:09:46,069
is just to delete the print and then the

00:09:43,970 --> 00:09:48,610
enumerate that we just added and that

00:09:46,069 --> 00:09:51,170
will look as follows and at this point

00:09:48,610 --> 00:09:54,500
we can start to see that we can actually

00:09:51,170 --> 00:09:57,319
probably change this for loop into a

00:09:54,500 --> 00:10:00,529
list comprehension so if we get rid of

00:09:57,319 --> 00:10:03,759
the name variable and put the T dot text

00:10:00,529 --> 00:10:07,970
content directly inside the append call

00:10:03,759 --> 00:10:09,860
you can see that this is really doable

00:10:07,970 --> 00:10:12,740
in a list comprehension which is going

00:10:09,860 --> 00:10:14,449
to be our third change so list

00:10:12,740 --> 00:10:16,579
comprehensions give you the ability to

00:10:14,449 --> 00:10:19,879
basically construct a list in place

00:10:16,579 --> 00:10:23,569
without having to violate what I call

00:10:19,879 --> 00:10:25,430
the ITM anti-pattern which is my least

00:10:23,569 --> 00:10:29,059
favorite anti-pattern that i see all the

00:10:25,430 --> 00:10:30,769
time in code so once again i TM this is

00:10:29,059 --> 00:10:32,839
an anti-pattern that you should try to

00:10:30,769 --> 00:10:34,790
avoid at all costs and it is my

00:10:32,839 --> 00:10:37,279
asportation that if you can avoid this

00:10:34,790 --> 00:10:40,160
anti-pattern your code will become more

00:10:37,279 --> 00:10:43,279
readable more made more maintainable and

00:10:40,160 --> 00:10:45,649
just better in general so I TM it stands

00:10:43,279 --> 00:10:47,629
for initialized then modify we've seen

00:10:45,649 --> 00:10:50,120
it twice already the first example was

00:10:47,629 --> 00:10:52,579
when we had the code that could be

00:10:50,120 --> 00:10:55,250
replaced by a call to enumerate here

00:10:52,579 --> 00:10:57,050
we're initializing the index I and then

00:10:55,250 --> 00:10:59,899
inside the form loop immediately

00:10:57,050 --> 00:11:01,730
modifying it we can avoid this by using

00:10:59,899 --> 00:11:04,189
enumerate and in my opinion it makes the

00:11:01,730 --> 00:11:07,100
code easier to read the second example

00:11:04,189 --> 00:11:08,829
where we saw this was in the code that

00:11:07,100 --> 00:11:11,420
we just saw where we're initializing

00:11:08,829 --> 00:11:12,410
column and then immediately inside our

00:11:11,420 --> 00:11:15,140
for loop

00:11:12,410 --> 00:11:17,240
calling the append method on that list

00:11:15,140 --> 00:11:18,890
for every iteration of our for loop we

00:11:17,240 --> 00:11:21,320
can avoid this as I just said with a

00:11:18,890 --> 00:11:24,560
list comprehension so if you can try to

00:11:21,320 --> 00:11:28,250
avoid the ITM anti-pattern it leads like

00:11:24,560 --> 00:11:32,260
I said to in general better and more

00:11:28,250 --> 00:11:34,310
readable code so moving on to our second

00:11:32,260 --> 00:11:37,310
set of four loops that we're going to

00:11:34,310 --> 00:11:39,640
look at and refactor this is the code

00:11:37,310 --> 00:11:43,100
that is responsible for basically

00:11:39,640 --> 00:11:45,650
extracting the data from the columns of

00:11:43,100 --> 00:11:48,650
each of our tables so we're gonna look

00:11:45,650 --> 00:11:50,150
at this nested for loop bit by bit

00:11:48,650 --> 00:11:53,210
and the first bit we're gonna look at is

00:11:50,150 --> 00:11:55,520
this if statement sort of on the third

00:11:53,210 --> 00:11:59,360
and fourth line so here it says that if

00:11:55,520 --> 00:12:01,640
the row size is not of size ten that

00:11:59,360 --> 00:12:03,830
means that it's not from our table when

00:12:01,640 --> 00:12:05,690
I ran this on the pokemons dataset that

00:12:03,830 --> 00:12:07,820
originally came with this blog I didn't

00:12:05,690 --> 00:12:09,320
run into this and I'm definitely not

00:12:07,820 --> 00:12:11,990
going to have this issue with the code

00:12:09,320 --> 00:12:14,150
forces data so we're able to just delete

00:12:11,990 --> 00:12:16,490
this if statement this won't always be

00:12:14,150 --> 00:12:18,950
the case when you're refactoring but for

00:12:16,490 --> 00:12:21,320
your use case if you find that this is

00:12:18,950 --> 00:12:23,200
the case you can definitely just remove

00:12:21,320 --> 00:12:25,310
redundant code that's not doing anything

00:12:23,200 --> 00:12:28,460
the second change that we're gonna make

00:12:25,310 --> 00:12:30,950
to these nested for-loops is by taking a

00:12:28,460 --> 00:12:34,610
look at the first two lines of our first

00:12:30,950 --> 00:12:38,480
for loop so here we have for J in range

00:12:34,610 --> 00:12:42,260
1 to the length of our TR elements list

00:12:38,480 --> 00:12:45,590
and we're then using that J which is

00:12:42,260 --> 00:12:50,120
going to be an index to assign T to be

00:12:45,590 --> 00:12:51,890
the J element of our TR elements so this

00:12:50,120 --> 00:12:54,530
was a bit confusing to me when I first

00:12:51,890 --> 00:12:58,810
looked at it because I thought why

00:12:54,530 --> 00:13:01,700
aren't you just looping over the

00:12:58,810 --> 00:13:03,860
second-to-last elements of TR elements

00:13:01,700 --> 00:13:07,610
but I figured that would be because we

00:13:03,860 --> 00:13:09,860
actually need TR elements again however

00:13:07,610 --> 00:13:11,540
when I looked at where T out TR elements

00:13:09,860 --> 00:13:14,420
gets used it's only in the first two

00:13:11,540 --> 00:13:15,830
lines so it became obvious that we're

00:13:14,420 --> 00:13:18,890
able to use something called slicing

00:13:15,830 --> 00:13:21,320
here in order to avoid having to use the

00:13:18,890 --> 00:13:23,570
range function calculate an index and

00:13:21,320 --> 00:13:26,150
then indexing into TR elements to set T

00:13:23,570 --> 00:13:28,940
we can just use slicing to a media

00:13:26,150 --> 00:13:31,940
we set T in our for loop so that looks

00:13:28,940 --> 00:13:34,220
as follows we use slicing to basically

00:13:31,940 --> 00:13:36,410
drop the first element of our TR

00:13:34,220 --> 00:13:40,040
elements list and this is going to give

00:13:36,410 --> 00:13:42,140
us the second to last elements in our

00:13:40,040 --> 00:13:45,110
list TR elements so this is exactly what

00:13:42,140 --> 00:13:47,000
we want and we are able to avoid not

00:13:45,110 --> 00:13:49,250
only a second line of code but also a

00:13:47,000 --> 00:13:52,070
call to the function range which is

00:13:49,250 --> 00:13:55,070
fantastic the next thing we're going to

00:13:52,070 --> 00:13:56,930
look at is a pattern that we've seen

00:13:55,070 --> 00:13:59,230
before hopefully you were able to

00:13:56,930 --> 00:14:01,400
identify it we're setting an index I

00:13:59,230 --> 00:14:03,080
inside of and then inside of for loop

00:14:01,400 --> 00:14:04,760
incrementing this index for each

00:14:03,080 --> 00:14:06,800
iteration of the for loop hopefully you

00:14:04,760 --> 00:14:08,930
remember what we did earlier and that is

00:14:06,800 --> 00:14:10,910
making use of the enumerate function I

00:14:08,930 --> 00:14:13,280
said it before but I see this pattern

00:14:10,910 --> 00:14:14,930
all the time and when you're in a

00:14:13,280 --> 00:14:17,990
language like Python that has this

00:14:14,930 --> 00:14:19,910
algorithm or function it is a godsend in

00:14:17,990 --> 00:14:21,740
certain languages like go they actually

00:14:19,910 --> 00:14:23,330
have it built into their range base for

00:14:21,740 --> 00:14:25,220
loops which is a really really

00:14:23,330 --> 00:14:28,190
interesting design choice for the

00:14:25,220 --> 00:14:30,560
language but yes use this one you can it

00:14:28,190 --> 00:14:32,390
makes your code much more readable like

00:14:30,560 --> 00:14:34,730
I said and it avoids the ITM

00:14:32,390 --> 00:14:36,680
anti-pattern the next change that we're

00:14:34,730 --> 00:14:39,260
gonna make is taking a look at another

00:14:36,680 --> 00:14:41,840
if statement once again this if

00:14:39,260 --> 00:14:46,400
statement says check if the row is empty

00:14:41,840 --> 00:14:48,530
I ran this on the Pokemon data set

00:14:46,400 --> 00:14:50,150
didn't run into any of these cases and

00:14:48,530 --> 00:14:52,490
also it's not going to be an issue for

00:14:50,150 --> 00:14:54,890
my code forces data so this can be

00:14:52,490 --> 00:14:57,490
removed as we the same as we remove the

00:14:54,890 --> 00:14:59,470
previous if statement

00:14:57,490 --> 00:15:01,240
the next piece of code that we're gonna

00:14:59,470 --> 00:15:03,850
look at are the four lines in the middle

00:15:01,240 --> 00:15:06,640
that are the try and accept and if we

00:15:03,850 --> 00:15:08,770
read the comment above these four lines

00:15:06,640 --> 00:15:12,970
of code it says convert any numerical

00:15:08,770 --> 00:15:14,020
value to an integer I don't think that

00:15:12,970 --> 00:15:17,440
this is the best way that we could be

00:15:14,020 --> 00:15:19,600
doing this I try to avoid try and accept

00:15:17,440 --> 00:15:21,700
statements when possible so the way that

00:15:19,600 --> 00:15:23,410
we can improve this piece of code is to

00:15:21,700 --> 00:15:26,320
use something called a conditional

00:15:23,410 --> 00:15:27,370
expression in many other languages you

00:15:26,320 --> 00:15:29,020
can get the same effect by using

00:15:27,370 --> 00:15:30,790
something called a ternary operator

00:15:29,020 --> 00:15:33,430
which is typically the question mark

00:15:30,790 --> 00:15:35,800
combined with the colon but in Python it

00:15:33,430 --> 00:15:39,940
looks as follows it basically enables

00:15:35,800 --> 00:15:43,480
you to assign do assignment based on a

00:15:39,940 --> 00:15:45,490
conditional statement but it combines it

00:15:43,480 --> 00:15:47,950
with sort of an if and an else so it

00:15:45,490 --> 00:15:50,220
becomes an expression so the way that it

00:15:47,950 --> 00:15:52,930
reads is basically value one if

00:15:50,220 --> 00:15:54,910
conditional else value two so if the

00:15:52,930 --> 00:15:57,070
conditional is true it uses value one

00:15:54,910 --> 00:15:57,640
otherwise it uses value two so here to

00:15:57,070 --> 00:15:59,920
set the data

00:15:57,640 --> 00:16:02,140
we're basically casting our data to an

00:15:59,920 --> 00:16:04,510
integer if the data is numeric otherwise

00:16:02,140 --> 00:16:05,890
just using the piece of data so I like

00:16:04,510 --> 00:16:08,560
this better than the previous code

00:16:05,890 --> 00:16:10,510
because one it's a single line but two

00:16:08,560 --> 00:16:12,760
it avoids the try and accept which I

00:16:10,510 --> 00:16:17,980
think you should try to avoid if

00:16:12,760 --> 00:16:20,230
possible and once again I just really

00:16:17,980 --> 00:16:22,600
like avoiding the ITM anti-pattern

00:16:20,230 --> 00:16:25,329
technically we are modifying the data

00:16:22,600 --> 00:16:27,940
here but in the next couple of changes

00:16:25,329 --> 00:16:30,490
we're going to avoid that as well so the

00:16:27,940 --> 00:16:32,140
next change is to remove the redundant

00:16:30,490 --> 00:16:34,930
comments so if we read the two comments

00:16:32,140 --> 00:16:37,480
here the first one is to iterate through

00:16:34,930 --> 00:16:39,850
each element of the row I think any

00:16:37,480 --> 00:16:41,050
comment above a for loop that is just

00:16:39,850 --> 00:16:43,779
saying we're iterating through each

00:16:41,050 --> 00:16:46,089
element of insert what we're through

00:16:43,779 --> 00:16:47,860
this isn't really adding any value as a

00:16:46,089 --> 00:16:50,589
comment similar to the second comment

00:16:47,860 --> 00:16:52,630
append the data to the empty list of the

00:16:50,589 --> 00:16:55,930
ID column this is pretty

00:16:52,630 --> 00:16:57,279
self-explanatory by just reading the

00:16:55,930 --> 00:17:00,040
fact that we have a two-dimensional list

00:16:57,279 --> 00:17:02,680
and we are appending to the ayth column

00:17:00,040 --> 00:17:05,589
so we can remove both of these and also

00:17:02,680 --> 00:17:08,530
like I said remove the second assignment

00:17:05,589 --> 00:17:09,839
to data and just put that code in the

00:17:08,530 --> 00:17:13,169
append method

00:17:09,839 --> 00:17:17,039
that we are invoking here and at this

00:17:13,169 --> 00:17:19,289
point we are going to stop and just see

00:17:17,039 --> 00:17:21,120
how far we've come so if we go back to

00:17:19,289 --> 00:17:23,759
what we originally started with we had

00:17:21,120 --> 00:17:27,659
roughly 60-plus lines of code and at

00:17:23,759 --> 00:17:31,320
this point we're down to about 20 so

00:17:27,659 --> 00:17:34,110
we've eliminated 2/3 of our code if we

00:17:31,320 --> 00:17:36,299
reformat the comments on the first four

00:17:34,110 --> 00:17:39,840
lines we can even get this a little bit

00:17:36,299 --> 00:17:41,820
more compact which I prefer and at this

00:17:39,840 --> 00:17:44,039
point we have all of our code on a

00:17:41,820 --> 00:17:46,139
single slide which makes it a little bit

00:17:44,039 --> 00:17:48,659
easier or a lot easier to reason about

00:17:46,139 --> 00:17:51,450
holistically and we can start to notice

00:17:48,659 --> 00:17:54,059
something about the code structurally

00:17:51,450 --> 00:18:00,029
and that is that we are initializing our

00:17:54,059 --> 00:18:04,049
list of tuples col2 initially have the

00:18:00,029 --> 00:18:06,240
title of our column as the first element

00:18:04,049 --> 00:18:08,669
of each of the tuples in our list and

00:18:06,240 --> 00:18:10,889
the second element is just initially

00:18:08,669 --> 00:18:14,100
empty and then in our nested for-loops

00:18:10,889 --> 00:18:16,529
below we filled the contents of these

00:18:14,100 --> 00:18:19,620
empty lists with the contents of each of

00:18:16,529 --> 00:18:21,929
the corresponding columns which we can

00:18:19,620 --> 00:18:25,049
see with this you know call bracket I

00:18:21,929 --> 00:18:27,509
bracket bracket 1 bracket however if we

00:18:25,049 --> 00:18:29,909
look at what we do with this list of

00:18:27,509 --> 00:18:31,860
tuples immediately after in this

00:18:29,909 --> 00:18:34,980
dictionary comprehension we immediately

00:18:31,860 --> 00:18:38,490
D structure it which begs the question

00:18:34,980 --> 00:18:40,259
why are we bundling these together in a

00:18:38,490 --> 00:18:42,480
list of tuples why can't we just have

00:18:40,259 --> 00:18:45,629
two separate lists because it's a little

00:18:42,480 --> 00:18:48,389
bit awkward to have to index into our

00:18:45,629 --> 00:18:50,580
column to then append to sort of an

00:18:48,389 --> 00:18:54,269
empty list when we could just have a

00:18:50,580 --> 00:18:56,460
list of Lists for the column data and a

00:18:54,269 --> 00:18:58,320
single list for the column titles so

00:18:56,460 --> 00:19:00,840
that's exactly what we're going to do so

00:18:58,320 --> 00:19:05,820
the first step is to basically get rid

00:19:00,840 --> 00:19:07,740
of the tuple in our list call and rename

00:19:05,820 --> 00:19:09,179
this to be titles and then once we've

00:19:07,740 --> 00:19:11,879
done that we've broken this code down

00:19:09,179 --> 00:19:16,289
here so we need to add a second what

00:19:11,879 --> 00:19:18,510
will be a list of Lists and so we can

00:19:16,289 --> 00:19:20,190
construct this list and we'll call it

00:19:18,510 --> 00:19:22,049
CLS for columns

00:19:20,190 --> 00:19:23,070
initialize it to be the number of

00:19:22,049 --> 00:19:25,350
columns that we need

00:19:23,070 --> 00:19:28,500
and now instead of having to do two

00:19:25,350 --> 00:19:31,860
indexing into this data structure we can

00:19:28,500 --> 00:19:33,899
just do a single one and the next change

00:19:31,860 --> 00:19:36,000
we can make is to sort of factor out

00:19:33,899 --> 00:19:38,909
this transformation that we're

00:19:36,000 --> 00:19:41,730
performing on the data that is T dot

00:19:38,909 --> 00:19:44,340
text content so we can factor this out

00:19:41,730 --> 00:19:47,399
into a lambda and at this point we can

00:19:44,340 --> 00:19:51,090
pretty clearly see that we can transform

00:19:47,399 --> 00:19:52,559
this nested for loop into a list

00:19:51,090 --> 00:19:53,789
comprehension because we have the

00:19:52,559 --> 00:19:57,720
pattern once again we're initializing

00:19:53,789 --> 00:20:01,200
our list outside here and then inside

00:19:57,720 --> 00:20:04,139
that we are calling append for every

00:20:01,200 --> 00:20:05,490
iteration of our nested for-loops which

00:20:04,139 --> 00:20:09,210
whenever you see this you should think

00:20:05,490 --> 00:20:11,220
list comprehension so the equivalent

00:20:09,210 --> 00:20:12,899
list comprehension is as follows if

00:20:11,220 --> 00:20:14,460
you're not used to lip list

00:20:12,899 --> 00:20:16,200
comprehension syntax this might be a

00:20:14,460 --> 00:20:17,669
little bit confusing but once you get

00:20:16,200 --> 00:20:19,110
used to it it's no more difficult to

00:20:17,669 --> 00:20:21,480
read than the nested for-loops were

00:20:19,110 --> 00:20:25,470
originally so we're basically

00:20:21,480 --> 00:20:27,090
constructing a list for each T in TR

00:20:25,470 --> 00:20:29,940
from the second element to the last

00:20:27,090 --> 00:20:32,610
element and we are calling the format

00:20:29,940 --> 00:20:36,149
function on each of the T dot text

00:20:32,610 --> 00:20:38,279
contents for the T's in the T dot eater

00:20:36,149 --> 00:20:41,250
children and note that we're also making

00:20:38,279 --> 00:20:43,289
a call which is a bit tricky to this

00:20:41,250 --> 00:20:45,990
function called zip and then we're also

00:20:43,289 --> 00:20:48,389
using an asterisk at the beginning this

00:20:45,990 --> 00:20:51,179
is the equivalent of a transpose in many

00:20:48,389 --> 00:20:54,120
other languages so if we take a look at

00:20:51,179 --> 00:20:55,740
our huugle translate sort of function or

00:20:54,120 --> 00:20:57,690
algorithm comparison you can see that in

00:20:55,740 --> 00:20:59,730
almost every single language and library

00:20:57,690 --> 00:21:00,809
this is called transposed only in a

00:20:59,730 --> 00:21:01,820
couple do they call it something

00:21:00,809 --> 00:21:04,440
slightly different

00:21:01,820 --> 00:21:06,950
so yes unfortunate in Python that they

00:21:04,440 --> 00:21:09,840
don't have an explicitly named transform

00:21:06,950 --> 00:21:11,879
transpose function but you can get the

00:21:09,840 --> 00:21:14,009
same behavior by just calling zip

00:21:11,879 --> 00:21:17,610
parentheses Asterix and then your

00:21:14,009 --> 00:21:21,360
two-dimensional collection and then in

00:21:17,610 --> 00:21:24,509
parentheses so at this point we're done

00:21:21,360 --> 00:21:27,269
we've reduced our code from 60 plus

00:21:24,509 --> 00:21:29,399
lines down to depending on how you look

00:21:27,269 --> 00:21:32,580
on it you know roughly ten lines which

00:21:29,399 --> 00:21:34,169
is great the question is are we done can

00:21:32,580 --> 00:21:36,239
we do better

00:21:34,169 --> 00:21:38,489
and some of you might have noticed that

00:21:36,239 --> 00:21:41,700
I have made a really really big mistake

00:21:38,489 --> 00:21:43,739
and that mistake is that I didn't paying

00:21:41,700 --> 00:21:45,749
close enough attention when I was

00:21:43,739 --> 00:21:48,389
googling some of you might have been

00:21:45,749 --> 00:21:51,480
thinking even I didn't do any of my HDL

00:21:48,389 --> 00:21:53,279
HTML scraping with pandas I didn't use

00:21:51,480 --> 00:21:54,809
pandas until I was constructing the data

00:21:53,279 --> 00:21:57,629
frame from the dictionary comprehension

00:21:54,809 --> 00:21:59,159
at the very end and if I had been paying

00:21:57,629 --> 00:22:01,679
more close attention I would have seen

00:21:59,159 --> 00:22:05,940
that right below this result there was a

00:22:01,679 --> 00:22:08,129
panda's dot read HTML method and if we

00:22:05,940 --> 00:22:11,600
make use of this method it turns these

00:22:08,129 --> 00:22:11,600
roughly ten lines of code

00:22:12,100 --> 00:22:18,400
into five or three lines of code

00:22:15,280 --> 00:22:20,980
depending on how you look at it so this

00:22:18,400 --> 00:22:24,940
is extremely important if you've seen

00:22:20,980 --> 00:22:26,560
any of my other talks about algorithms I

00:22:24,940 --> 00:22:29,500
echo the point that has been made by

00:22:26,560 --> 00:22:31,090
several other individuals in other

00:22:29,500 --> 00:22:33,190
programming communities that you should

00:22:31,090 --> 00:22:34,840
know your algorithms but not only should

00:22:33,190 --> 00:22:36,460
you know your algorithms you should know

00:22:34,840 --> 00:22:39,100
your collections and you should know

00:22:36,460 --> 00:22:40,870
your libraries too I think all of the

00:22:39,100 --> 00:22:44,080
work that I did refactoring the code

00:22:40,870 --> 00:22:46,270
that I worked on it was useful it was a

00:22:44,080 --> 00:22:49,660
useful learning exercise and it's

00:22:46,270 --> 00:22:51,580
hopefully going to be useful some of the

00:22:49,660 --> 00:22:53,890
things that I mentioned in this talk but

00:22:51,580 --> 00:22:57,220
I could have avoided all of that if I

00:22:53,890 --> 00:22:59,410
had just known the pandas API better and

00:22:57,220 --> 00:23:01,600
I was just starting out with it so I

00:22:59,410 --> 00:23:03,820
didn't know so you know it's okay that

00:23:01,600 --> 00:23:05,920
we make these mistakes but over time we

00:23:03,820 --> 00:23:07,870
should try to use our libraries and our

00:23:05,920 --> 00:23:09,490
collections and our algorithms as much

00:23:07,870 --> 00:23:11,290
as possible to avoid writing all this

00:23:09,490 --> 00:23:13,570
unnecessary code whether it be ten lines

00:23:11,290 --> 00:23:14,830
of code or sixty lines of code ideally

00:23:13,570 --> 00:23:16,270
if there's a library with a single

00:23:14,830 --> 00:23:19,270
method that does exactly what you want

00:23:16,270 --> 00:23:21,460
that's what you should be using so if

00:23:19,270 --> 00:23:23,860
you want to go check out all of the step

00:23:21,460 --> 00:23:25,450
by step changes there were nine of them

00:23:23,860 --> 00:23:26,890
that I explicitly mentioned and then two

00:23:25,450 --> 00:23:28,450
of them at the end that I implicitly

00:23:26,890 --> 00:23:30,400
mentioned you can check out the link at

00:23:28,450 --> 00:23:33,340
the end of this talk on my github page I

00:23:30,400 --> 00:23:35,560
have a file that has a git commit

00:23:33,340 --> 00:23:36,850
history with all of the explicit changes

00:23:35,560 --> 00:23:40,300
if you want to see them sort of in the

00:23:36,850 --> 00:23:43,240
github file diff mode so we finished

00:23:40,300 --> 00:23:46,060
step one onto step two this one's a lot

00:23:43,240 --> 00:23:47,710
shorter than the first step as I said

00:23:46,060 --> 00:23:50,110
this is only going to be about 10% of

00:23:47,710 --> 00:23:52,570
the talk and so first we need to look at

00:23:50,110 --> 00:23:53,890
what does the HTML table that I've been

00:23:52,570 --> 00:23:55,780
referring to this whole time look like

00:23:53,890 --> 00:23:59,110
so on the code force's website for each

00:23:55,780 --> 00:24:01,170
contest you can go to the status of each

00:23:59,110 --> 00:24:03,880
of the submissions and it will show you

00:24:01,170 --> 00:24:06,760
all of the languages whether they passed

00:24:03,880 --> 00:24:09,670
or failed and for which problem in the

00:24:06,760 --> 00:24:12,070
contest they were submitted for and so

00:24:09,670 --> 00:24:14,560
primarily we're interested in the column

00:24:12,070 --> 00:24:16,180
title laying short front language but

00:24:14,560 --> 00:24:18,790
one thing you'll notice is that they

00:24:16,180 --> 00:24:21,190
don't just have a single submission

00:24:18,790 --> 00:24:22,810
option if you are submitting in C++ you

00:24:21,190 --> 00:24:25,300
can choose several different compilers

00:24:22,810 --> 00:24:27,220
C++ 11 1714

00:24:25,300 --> 00:24:29,800
for Python they have the option to

00:24:27,220 --> 00:24:32,820
submit Python 3 or Python 2 there are

00:24:29,800 --> 00:24:36,430
various different sort of mappings from

00:24:32,820 --> 00:24:37,810
inputs or submission method compared to

00:24:36,430 --> 00:24:41,680
language so the first thing we need to

00:24:37,810 --> 00:24:43,720
do is create a dictionary that map's all

00:24:41,680 --> 00:24:45,520
of the different submission options to

00:24:43,720 --> 00:24:48,700
the language that is being submitted in

00:24:45,520 --> 00:24:50,740
once we do that we have a very short

00:24:48,700 --> 00:24:53,920
piece of code for lines we're importing

00:24:50,740 --> 00:24:56,950
pandas were initializing and declaring

00:24:53,920 --> 00:24:59,350
our dictionary mapping once we've

00:24:56,950 --> 00:25:01,390
executed the code that we created in

00:24:59,350 --> 00:25:03,880
step one and stored it to a CSV we can

00:25:01,390 --> 00:25:06,550
just load this as such I was doing this

00:25:03,880 --> 00:25:08,740
for code forces educational code contest

00:25:06,550 --> 00:25:10,960
74 and then once we have our data frame

00:25:08,740 --> 00:25:13,990
we can access a single column in that

00:25:10,960 --> 00:25:17,020
data frame by going dot Lang and then we

00:25:13,990 --> 00:25:18,550
can call the algorithm or method replace

00:25:17,020 --> 00:25:22,930
which is basically going to do that

00:25:18,550 --> 00:25:25,060
transformation of mapping each of these

00:25:22,930 --> 00:25:27,310
submission methods to the corresponding

00:25:25,060 --> 00:25:29,560
language and then we make a final call

00:25:27,310 --> 00:25:32,050
to value counts so if you're familiar

00:25:29,560 --> 00:25:34,120
with the collection counter in Python

00:25:32,050 --> 00:25:35,820
value counts is very similar it

00:25:34,120 --> 00:25:38,920
basically is going to give you a

00:25:35,820 --> 00:25:43,090
frequency count of the unique elements

00:25:38,920 --> 00:25:47,050
that exists in a series or a list so in

00:25:43,090 --> 00:25:49,600
pandas and the rapids Python API this is

00:25:47,050 --> 00:25:51,700
called value counts in the two Lisp

00:25:49,600 --> 00:25:53,920
dialects closure and racket this is

00:25:51,700 --> 00:25:56,350
called frequency and as mentioned before

00:25:53,920 --> 00:25:57,880
in Python it's not an algorithm but it's

00:25:56,350 --> 00:26:00,490
a collection but it has a very similar

00:25:57,880 --> 00:26:02,170
behavior this is called counter and so

00:26:00,490 --> 00:26:05,050
once we do this we get the following

00:26:02,170 --> 00:26:07,540
output so you can see there are 41

00:26:05,050 --> 00:26:09,910
thousand submissions in C++ two and a

00:26:07,540 --> 00:26:11,350
half thousand in Python just under two

00:26:09,910 --> 00:26:13,240
thousand in Java and if we visualize

00:26:11,350 --> 00:26:15,880
this it looks as follows so

00:26:13,240 --> 00:26:17,380
overwhelmingly the language of choice at

00:26:15,880 --> 00:26:18,910
least for this contest but it's

00:26:17,380 --> 00:26:21,550
typically the case for most contest was

00:26:18,910 --> 00:26:24,340
C++ with 89 percent of the submissions

00:26:21,550 --> 00:26:26,860
if we get rid of C++ we can see that the

00:26:24,340 --> 00:26:29,200
next top three our Python with six

00:26:26,860 --> 00:26:31,570
percent Java with four percent and C

00:26:29,200 --> 00:26:33,850
with one percent and for what I will

00:26:31,570 --> 00:26:35,230
call the fringe languages any language

00:26:33,850 --> 00:26:37,930
that had less than one percent of the

00:26:35,230 --> 00:26:38,570
submissions the rankings are as follows

00:26:37,930 --> 00:26:42,169
C char

00:26:38,570 --> 00:26:47,929
pascale Kotlin javascript rust go pearl

00:26:42,169 --> 00:26:50,210
d haskell PHP and Ruby and second to

00:26:47,929 --> 00:26:53,600
last thing I want to mention is that if

00:26:50,210 --> 00:26:55,669
you are looking to accelerate your data

00:26:53,600 --> 00:26:57,740
science work that you are working on and

00:26:55,669 --> 00:27:00,019
you have a bottleneck when it comes to

00:26:57,740 --> 00:27:02,179
performance a lot of the times when

00:27:00,019 --> 00:27:03,919
you're using pandas you can simply drop

00:27:02,179 --> 00:27:06,049
and replace cootie F which is the

00:27:03,919 --> 00:27:09,350
library that the in videos rapid team

00:27:06,049 --> 00:27:12,559
works on and your code will work so this

00:27:09,350 --> 00:27:15,639
work this code works exactly the same as

00:27:12,559 --> 00:27:17,840
it did in pandas it works in CUDA F and

00:27:15,639 --> 00:27:19,700
it's just gonna be a lot more

00:27:17,840 --> 00:27:22,039
performance if you're working with a lot

00:27:19,700 --> 00:27:25,100
of data and you have the GPUs to run

00:27:22,039 --> 00:27:26,450
this on so if you're if you're sort of

00:27:25,100 --> 00:27:27,379
wondering well you know pandas works for

00:27:26,450 --> 00:27:29,480
me

00:27:27,379 --> 00:27:31,429
that's great keep using pandas but if if

00:27:29,480 --> 00:27:33,740
you do have a performance bottleneck

00:27:31,429 --> 00:27:35,690
kudi F can be a great alternative and

00:27:33,740 --> 00:27:37,610
coincidentally while I was on my run

00:27:35,690 --> 00:27:39,769
today I typically like to listen to

00:27:37,610 --> 00:27:42,169
podcasts these were the five that I was

00:27:39,769 --> 00:27:43,850
listening to and one of them that I

00:27:42,169 --> 00:27:45,620
listened to just happened to be an

00:27:43,850 --> 00:27:48,169
interview with an individual by the name

00:27:45,620 --> 00:27:49,879
of Kyle Nicholson who works at Capital

00:27:48,169 --> 00:27:52,460
One and apparently they're using Rapids

00:27:49,879 --> 00:27:54,110
and he mentioned in the podcast that for

00:27:52,460 --> 00:27:56,419
the sort of code that they were working

00:27:54,110 --> 00:27:58,039
with the code base or the the training

00:27:56,419 --> 00:28:01,340
model that they were working with they

00:27:58,039 --> 00:28:04,669
had a roughly 30x reduction in cost and

00:28:01,340 --> 00:28:06,649
a roughly a hundred X

00:28:04,669 --> 00:28:09,620
speed-up in the time to train their

00:28:06,649 --> 00:28:11,929
model so it's extremely impressive the

00:28:09,620 --> 00:28:14,659
things that you can do with this rapid

00:28:11,929 --> 00:28:17,149
squiddy F library if performance is a

00:28:14,659 --> 00:28:18,529
bottleneck for you and if you're

00:28:17,149 --> 00:28:20,000
interested check us out at rapid day I

00:28:18,529 --> 00:28:22,549
and the last thing that I want to

00:28:20,000 --> 00:28:23,809
mention randomly is a blog that was

00:28:22,549 --> 00:28:26,929
mentioned on a podcast called Python

00:28:23,809 --> 00:28:28,250
bites this blog was entitled eight

00:28:26,929 --> 00:28:30,259
coolest Python programming language

00:28:28,250 --> 00:28:33,350
features the reason I'm mentioning it is

00:28:30,259 --> 00:28:35,269
that five of the eight features either

00:28:33,350 --> 00:28:38,629
directly or indirectly were referenced

00:28:35,269 --> 00:28:40,340
in this talk which I thought was kind of

00:28:38,629 --> 00:28:42,169
coincidental so the first one was list

00:28:40,340 --> 00:28:43,549
comprehensions which we used multiple

00:28:42,169 --> 00:28:46,309
times to refactor

00:28:43,549 --> 00:28:48,049
for loops generator expressions weren't

00:28:46,309 --> 00:28:49,659
directly mentioned but their go

00:28:48,049 --> 00:28:52,130
hand-in-hand with list comprehensions

00:28:49,659 --> 00:28:54,140
slice assignment we didn't use but we

00:28:52,130 --> 00:28:56,540
did you slicing to remove that one

00:28:54,140 --> 00:28:59,210
assignment to tea and the call to the

00:28:56,540 --> 00:29:01,610
range function iterable iterable

00:28:59,210 --> 00:29:04,550
unpacking this is what I refer to as D

00:29:01,610 --> 00:29:07,070
structuring where you are taking a tuple

00:29:04,550 --> 00:29:08,990
or a list and D structuring it into its

00:29:07,070 --> 00:29:10,640
individual components and then

00:29:08,990 --> 00:29:12,830
dictionary comprehensions was being used

00:29:10,640 --> 00:29:15,740
at the end to construct our dictionary

00:29:12,830 --> 00:29:18,560
that we were passing to create a data

00:29:15,740 --> 00:29:21,350
frame so a great article I definitely

00:29:18,560 --> 00:29:24,380
recommend you checking it out and yeah

00:29:21,350 --> 00:29:25,850
hopefully you found this useful thanks

00:29:24,380 --> 00:29:27,590
for watching I know it's a bit odd

00:29:25,850 --> 00:29:29,290
without having an audience and me tis

00:29:27,590 --> 00:29:31,880
recording this by myself and

00:29:29,290 --> 00:29:34,040
unfortunately there is an opportunity to

00:29:31,880 --> 00:29:37,070
ask live questions they which is why

00:29:34,040 --> 00:29:38,990
there is an asterisks next to this but

00:29:37,070 --> 00:29:40,580
if you do have questions leave them in

00:29:38,990 --> 00:29:43,460
the comment section down below or if you

00:29:40,580 --> 00:29:45,230
want you can tweet them at me at code

00:29:43,460 --> 00:29:47,120
underscore report I will do my best to

00:29:45,230 --> 00:29:50,170
monitor the youtube comments section and

00:29:47,120 --> 00:29:53,510
to reply to any questions you have and

00:29:50,170 --> 00:29:55,340
last but not least all of these slides

00:29:53,510 --> 00:29:58,940
and the code that I've shown in this

00:29:55,340 --> 00:30:02,200
talk are posted on my github page so if

00:29:58,940 --> 00:30:02,200

YouTube URL: https://www.youtube.com/watch?v=W-lZttZhsUY


