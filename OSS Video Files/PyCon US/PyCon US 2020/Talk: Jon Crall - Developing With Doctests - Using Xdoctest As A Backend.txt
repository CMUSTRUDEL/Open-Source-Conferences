Title: Talk: Jon Crall - Developing With Doctests - Using Xdoctest As A Backend
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Jon Crall

This talk is about doctests — a way to embed examples and unit tests in docstrings. I describe what they are, how to write them, and interesting ways in which they can be used. Doctests make it easy to interactively develop code by defining “demo” inputs which can be copied into IPython. The side effect is a unit test. This is test-driven-development at its best. I explain the technical details of doctest syntax, directives, parsing, and execution.

Unfortunately, Python’s builtin doctest module has a restrictive syntax, which makes it difficult to use. In the second part of the talk I introduce an alternative: Xdoctest, a new, but stable package for parsing and running doctests (with optional pytest integration). I explain why doctest’s regex-based parser is fundamentally limited and how xdoctest’s ast-based parser is the remedy. I demonstrate how to use xdoctest and discuss its advantages and disadvantages. By the end of this talk you feel confident in writing, running, and developing with doctests.




Talk resources:
- https://github.com/Erotemic/xdoctest
- https://github.com/Erotemic/ubelt
Captions: 
	00:00:04,620 --> 00:00:10,990
hello PyCon my name is John crawl and

00:00:07,960 --> 00:00:12,849
today I'm here to talk about developing

00:00:10,990 --> 00:00:15,280
with Doc tests I'm going to talk about

00:00:12,849 --> 00:00:16,750
what doc tests are why you should care

00:00:15,280 --> 00:00:18,520
about them and how you can better

00:00:16,750 --> 00:00:21,669
utilize them using a package that I

00:00:18,520 --> 00:00:23,410
wrote called X doc tests before we get

00:00:21,669 --> 00:00:25,989
into it let me give a quick personal

00:00:23,410 --> 00:00:28,509
introduction my name is John crawl you

00:00:25,989 --> 00:00:30,759
can find me online at arrow teamuk I

00:00:28,509 --> 00:00:32,230
have a PhD in computer vision and I'm

00:00:30,759 --> 00:00:35,079
currently working at a company called

00:00:32,230 --> 00:00:36,760
cat where in addition to mathematics

00:00:35,079 --> 00:00:38,680
deep learning computer vision any sort

00:00:36,760 --> 00:00:40,630
of things I'm also interested in

00:00:38,680 --> 00:00:42,730
test-driven design in the Python

00:00:40,630 --> 00:00:45,100
programming language which is why I

00:00:42,730 --> 00:00:47,500
wrote the package X dot test but I'm

00:00:45,100 --> 00:00:49,630
here to talk to you about today so

00:00:47,500 --> 00:00:53,680
before we talk about X doc test let's

00:00:49,630 --> 00:00:56,110
just talk about doc tests so what are

00:00:53,680 --> 00:00:58,300
doc tests if you're familiar with Python

00:00:56,110 --> 00:01:00,820
you probably know how to write a

00:00:58,300 --> 00:01:02,680
function and you also probably know that

00:01:00,820 --> 00:01:05,409
if you put a string directly after a

00:01:02,680 --> 00:01:06,759
function that's a doc string in a doc

00:01:05,409 --> 00:01:09,190
string you can put any sort of

00:01:06,759 --> 00:01:11,890
documentation that you want so one

00:01:09,190 --> 00:01:14,170
really useful thing to do is to

00:01:11,890 --> 00:01:16,270
demonstrate how to use the function that

00:01:14,170 --> 00:01:18,940
you've written so you can put some code

00:01:16,270 --> 00:01:21,430
in here and if you prefix that code with

00:01:18,940 --> 00:01:23,380
three chevrons in a space that's a doc

00:01:21,430 --> 00:01:25,690
test I've highlighted the doc test in

00:01:23,380 --> 00:01:28,600
this example you can see that we create

00:01:25,690 --> 00:01:31,540
some demo inputs we show how to pass

00:01:28,600 --> 00:01:33,670
those inputs to the function itself and

00:01:31,540 --> 00:01:36,220
we assert that the output looks

00:01:33,670 --> 00:01:38,590
reasonable in addition to helping new

00:01:36,220 --> 00:01:41,590
developers learn how to use your code if

00:01:38,590 --> 00:01:43,930
you can extract this code and test it in

00:01:41,590 --> 00:01:46,090
your continuous integration suite you

00:01:43,930 --> 00:01:47,860
can not only increase your coverage but

00:01:46,090 --> 00:01:50,549
be more confident that the code that

00:01:47,860 --> 00:01:53,950
you've written is correct

00:01:50,549 --> 00:01:57,159
so what else conduct tests do how do you

00:01:53,950 --> 00:02:00,729
develop with dog tests well as an

00:01:57,159 --> 00:02:02,710
example whenever I read a class I like

00:02:00,729 --> 00:02:05,320
to create a class method called demo

00:02:02,710 --> 00:02:07,030
before I write any of the functionality

00:02:05,320 --> 00:02:09,009
and I might call this demo data or

00:02:07,030 --> 00:02:12,159
random depending on the circumstance but

00:02:09,009 --> 00:02:14,169
the basic idea is I want to create an

00:02:12,159 --> 00:02:16,689
example of the inputs that I'm

00:02:14,169 --> 00:02:17,950
interested in manipulating I then open

00:02:16,689 --> 00:02:20,950
my Python curry

00:02:17,950 --> 00:02:22,930
instances of these inputs and I start

00:02:20,950 --> 00:02:24,880
playing with them and as I'm playing

00:02:22,930 --> 00:02:26,349
with them I eventually converge upon the

00:02:24,880 --> 00:02:28,660
functionality that I'm interested in

00:02:26,349 --> 00:02:30,250
implementing but that's not that's not

00:02:28,660 --> 00:02:32,470
the only thing that I've been doing in

00:02:30,250 --> 00:02:34,270
my Python I've also been writing checks

00:02:32,470 --> 00:02:36,250
to make sure things are going as I

00:02:34,270 --> 00:02:38,050
expect them to so instead of just

00:02:36,250 --> 00:02:39,250
exiting ipython and letting all those

00:02:38,050 --> 00:02:41,530
checks go to waste

00:02:39,250 --> 00:02:43,690
why not also copy those back into the

00:02:41,530 --> 00:02:44,050
source file and what better place to put

00:02:43,690 --> 00:02:47,170
them

00:02:44,050 --> 00:02:49,209
than inside a doc test this means that

00:02:47,170 --> 00:02:50,709
as a natural byproduct of the

00:02:49,209 --> 00:02:52,150
development cycle you've not only

00:02:50,709 --> 00:02:54,340
written the functionality that you're

00:02:52,150 --> 00:02:57,459
interested in but the tests for it as

00:02:54,340 --> 00:03:00,340
well in the tests this is key are

00:02:57,459 --> 00:03:02,080
coupled with the code this means that if

00:03:00,340 --> 00:03:04,540
you have to refactor your Maj we'll move

00:03:02,080 --> 00:03:07,870
it from one package to another the tests

00:03:04,540 --> 00:03:10,299
always come with it additionally when

00:03:07,870 --> 00:03:12,700
you develop with doc test you get entry

00:03:10,299 --> 00:03:15,730
points everywhere where you have a doc

00:03:12,700 --> 00:03:17,980
test a doc test always allows you a way

00:03:15,730 --> 00:03:19,720
to create the inputs that you need so

00:03:17,980 --> 00:03:21,670
you can step through a piece of code

00:03:19,720 --> 00:03:24,010
line by line without any other

00:03:21,670 --> 00:03:25,959
prerequisites this is very useful if you

00:03:24,010 --> 00:03:27,070
have a long-running stack of code that

00:03:25,959 --> 00:03:29,170
my error

00:03:27,070 --> 00:03:31,810
perhaps in a function that has a doc

00:03:29,170 --> 00:03:34,120
test instead of rerunning that code

00:03:31,810 --> 00:03:37,359
perhaps you can use the demo inputs in

00:03:34,120 --> 00:03:40,600
it to reproduce that error and perhaps

00:03:37,359 --> 00:03:44,530
fix it without having to rerun that

00:03:40,600 --> 00:03:46,630
long-running stack too many times so now

00:03:44,530 --> 00:03:49,299
that we know what a doc test is and how

00:03:46,630 --> 00:03:51,489
you might develop with doc tests let's

00:03:49,299 --> 00:03:54,579
talk about specifically how to write the

00:03:51,489 --> 00:03:57,459
doc test and most importantly how to run

00:03:54,579 --> 00:03:59,859
them first to write a doc test you

00:03:57,459 --> 00:04:03,220
simply have a function and you write a

00:03:59,859 --> 00:04:05,470
test for the function then you prefix

00:04:03,220 --> 00:04:08,260
your test with three chevrons and a

00:04:05,470 --> 00:04:11,560
space and then you simply insert this

00:04:08,260 --> 00:04:14,380
block of text into the function doc

00:04:11,560 --> 00:04:17,229
string and with some minor exceptions

00:04:14,380 --> 00:04:20,440
that's essentially all you need to do to

00:04:17,229 --> 00:04:23,650
write a doc test now to actually run a

00:04:20,440 --> 00:04:26,229
doc test it's a little trickier and to

00:04:23,650 --> 00:04:30,190
go over why that is I want to talk about

00:04:26,229 --> 00:04:31,420
a few case studies so as a first case

00:04:30,190 --> 00:04:34,120
study I want to talk

00:04:31,420 --> 00:04:35,350
about this function paragraph the idea

00:04:34,120 --> 00:04:36,940
of this function is we're going to take

00:04:35,350 --> 00:04:38,830
in a block of text and we're going to

00:04:36,940 --> 00:04:40,720
just remove all the extra and new lines

00:04:38,830 --> 00:04:43,810
and spaces and then we're going to

00:04:40,720 --> 00:04:46,720
return the output so to test this let's

00:04:43,810 --> 00:04:48,550
create some input text let's use the

00:04:46,720 --> 00:04:50,140
triple quotes which means the text will

00:04:48,550 --> 00:04:52,900
be filled with extra new lines and

00:04:50,140 --> 00:04:55,360
spaces that we might not want let's pass

00:04:52,900 --> 00:04:57,460
the text through a paragraph get the

00:04:55,360 --> 00:04:59,530
output and then we can assert that there

00:04:57,460 --> 00:05:01,420
is a newline character in the original

00:04:59,530 --> 00:05:03,430
text but there is not a newline

00:05:01,420 --> 00:05:07,330
character in the output text seems like

00:05:03,430 --> 00:05:08,260
a reasonable test so let's create this

00:05:07,330 --> 00:05:11,560
as a doc test

00:05:08,260 --> 00:05:14,530
we'll make a file talk come on I'll put

00:05:11,560 --> 00:05:16,780
the function in the file and then I will

00:05:14,530 --> 00:05:20,110
insert the doc test into the doc string

00:05:16,780 --> 00:05:22,990
I'll preface with the appropriate three

00:05:20,110 --> 00:05:23,860
shove rise and let's use the built in

00:05:22,990 --> 00:05:26,380
Python

00:05:23,860 --> 00:05:28,930
doc test module to run this that's right

00:05:26,380 --> 00:05:32,500
Python actually ships with a doc test

00:05:28,930 --> 00:05:35,320
module to run the main block of this doc

00:05:32,500 --> 00:05:37,720
test module we can use Python - M - M

00:05:35,320 --> 00:05:40,090
means run the main block of a module and

00:05:37,720 --> 00:05:41,920
as an argument we'll give it the file

00:05:40,090 --> 00:05:43,750
that we want to run the doc tests in

00:05:41,920 --> 00:05:46,210
this will run all the doc tests in the

00:05:43,750 --> 00:05:51,580
file so let's do this let's see what we

00:05:46,210 --> 00:05:54,640
get errors what happened we I thought

00:05:51,580 --> 00:05:55,960
the the test looked pretty reasonable

00:05:54,640 --> 00:05:58,840
there didn't seem to be any syntax

00:05:55,960 --> 00:06:00,280
errors in there what's going on it says

00:05:58,840 --> 00:06:03,670
we have a syntax error that isn't

00:06:00,280 --> 00:06:07,090
unexpected and a file while parsing well

00:06:03,670 --> 00:06:09,130
what happened is that doc tests can't

00:06:07,090 --> 00:06:14,650
handle multi-line statements without

00:06:09,130 --> 00:06:17,170
help we can fix this by taking all of

00:06:14,650 --> 00:06:19,420
the extra lines after a multi-line

00:06:17,170 --> 00:06:22,270
statement and replacing the first three

00:06:19,420 --> 00:06:25,440
chevrons with dot dot dot if we rerun

00:06:22,270 --> 00:06:28,900
the dot test module with this new edited

00:06:25,440 --> 00:06:31,690
test we see that it works it's a little

00:06:28,900 --> 00:06:37,290
annoying that we have to tell Python how

00:06:31,690 --> 00:06:40,270
to parse it sound code but we got there

00:06:37,290 --> 00:06:42,100
so let's go over another case study this

00:06:40,270 --> 00:06:44,200
time let's look at the function all the

00:06:42,100 --> 00:06:46,900
same the idea is we're going to take

00:06:44,200 --> 00:06:49,800
an iterable and we're gonna determine if

00:06:46,900 --> 00:06:52,600
all the items in the edible are the same

00:06:49,800 --> 00:06:55,290
we're going to use a feature of donek

00:06:52,600 --> 00:06:57,940
tests that I haven't talked about if you

00:06:55,290 --> 00:07:01,180
execute a function and it returns a

00:06:57,940 --> 00:07:03,190
value you can actually in the next line

00:07:01,180 --> 00:07:05,890
give a string representation of the

00:07:03,190 --> 00:07:09,370
value that you expect to get I'm gonna

00:07:05,890 --> 00:07:11,410
call this a got watch string you got

00:07:09,370 --> 00:07:13,780
something by calling this function and

00:07:11,410 --> 00:07:17,620
you want something by passing it a

00:07:13,780 --> 00:07:20,440
string here so if we run all same on one

00:07:17,620 --> 00:07:23,440
one one one we expect to get true

00:07:20,440 --> 00:07:25,510
all same on an empty list we also expect

00:07:23,440 --> 00:07:27,910
to get true one and zero they're

00:07:25,510 --> 00:07:30,160
definitely not the same so false let's

00:07:27,910 --> 00:07:31,750
make sure that it works on intervals we

00:07:30,160 --> 00:07:33,910
can create an interval that do not have

00:07:31,750 --> 00:07:35,560
the same elements we can pop off the

00:07:33,910 --> 00:07:38,080
first one and then check to make sure

00:07:35,560 --> 00:07:42,010
that it works on the rest of them 1 1 1

00:07:38,080 --> 00:07:44,020
to be the same so true and so on so

00:07:42,010 --> 00:07:47,470
let's take this doc test put it in our

00:07:44,020 --> 00:07:49,720
talk top py file and let's run the doc

00:07:47,470 --> 00:07:52,480
test using the built-in Python doc test

00:07:49,720 --> 00:07:54,720
module there's no multi-line statements

00:07:52,480 --> 00:07:58,500
so this seems like it would work right

00:07:54,720 --> 00:08:01,750
errors again all right what happened

00:07:58,500 --> 00:08:04,720
let's see we we failed on the next

00:08:01,750 --> 00:08:09,700
iterable line we expected nothing but we

00:08:04,720 --> 00:08:11,470
got 0 well if you remember we popped off

00:08:09,700 --> 00:08:13,270
the first element of that iterable

00:08:11,470 --> 00:08:15,940
because we wanted to test it herbals and

00:08:13,270 --> 00:08:17,950
we didn't give it something to expect

00:08:15,940 --> 00:08:20,410
because we didn't give it something and

00:08:17,950 --> 00:08:22,690
we got something the built-in doc test

00:08:20,410 --> 00:08:26,110
module is going to error because it

00:08:22,690 --> 00:08:30,250
forces you to put values in for anything

00:08:26,110 --> 00:08:31,540
that you want so ok we can fix this we

00:08:30,250 --> 00:08:33,160
can fix this actually using another

00:08:31,540 --> 00:08:36,880
feature of doc tests that I haven't

00:08:33,160 --> 00:08:39,940
talked about yet directives by passing

00:08:36,880 --> 00:08:43,630
by putting a comment with doc test :

00:08:39,940 --> 00:08:46,330
plus ellipses at the end of this line we

00:08:43,630 --> 00:08:48,400
enabled the ellipses feature of doc test

00:08:46,330 --> 00:08:50,450
that means if we give it a dot dot dot

00:08:48,400 --> 00:08:53,150
that will match anything that come

00:08:50,450 --> 00:08:54,860
out of this statement this will

00:08:53,150 --> 00:08:56,780
effectively prevent us prevent us from

00:08:54,860 --> 00:08:58,370
needing to care about what's going on

00:08:56,780 --> 00:09:01,360
here because for the purposes of the

00:08:58,370 --> 00:09:06,050
test we don't so if we run this again

00:09:01,360 --> 00:09:07,910
this will work well at least I thought

00:09:06,050 --> 00:09:10,610
it would work it turns out it actually

00:09:07,910 --> 00:09:13,250
doesn't but let's just skip ahead

00:09:10,610 --> 00:09:17,060
because running doc test seems to be

00:09:13,250 --> 00:09:19,850
harder than it needs to be so I want to

00:09:17,060 --> 00:09:23,090
pose a question why aren't doc tests

00:09:19,850 --> 00:09:25,970
everywhere they seem really useful but

00:09:23,090 --> 00:09:29,900
as we saw they're kind of tricky to run

00:09:25,970 --> 00:09:33,290
and you sort of do see them a lot in the

00:09:29,900 --> 00:09:35,780
wild but the issue with them is a lot of

00:09:33,290 --> 00:09:38,120
times the code that is supposed to be

00:09:35,780 --> 00:09:40,940
providing an example of how to use a

00:09:38,120 --> 00:09:42,800
module it doesn't work anymore because

00:09:40,940 --> 00:09:45,110
the codes changed since it was written

00:09:42,800 --> 00:09:46,970
and because people aren't running their

00:09:45,110 --> 00:09:50,360
doc tests in their continuous

00:09:46,970 --> 00:09:53,330
integration and servers they don't catch

00:09:50,360 --> 00:09:55,280
these errors and it makes sense that

00:09:53,330 --> 00:09:58,130
they're not because running doc tests as

00:09:55,280 --> 00:10:00,590
we saw is tricky so it'd be really nice

00:09:58,130 --> 00:10:03,290
if there was a way to make running doc

00:10:00,590 --> 00:10:05,270
tests less of a hassle and that brings

00:10:03,290 --> 00:10:08,920
us to the package that I want to talk

00:10:05,270 --> 00:10:08,920
about today X doc tests

00:10:08,950 --> 00:10:16,160
so X doc test is a most fee backwards

00:10:12,380 --> 00:10:19,280
compatible module the key features is it

00:10:16,160 --> 00:10:21,440
has more permissive long strings it uses

00:10:19,280 --> 00:10:23,330
static parsing to parse out your doc

00:10:21,440 --> 00:10:25,730
tests unlike the dynamic parsing of the

00:10:23,330 --> 00:10:27,950
built-in one and it has an enhanced

00:10:25,730 --> 00:10:32,960
runner the output messages are a little

00:10:27,950 --> 00:10:35,300
bit better it has a cleaner CLI but by

00:10:32,960 --> 00:10:37,910
far the most important feature to vex

00:10:35,300 --> 00:10:41,420
doc tests is it has simpler doc test

00:10:37,910 --> 00:10:44,780
syntax instead of having to prefix your

00:10:41,420 --> 00:10:47,480
code with either Chevron's or dot dot

00:10:44,780 --> 00:10:50,360
dots depending on if it's a multi-line

00:10:47,480 --> 00:10:52,460
statement or not X doc test has one rule

00:10:50,360 --> 00:10:56,990
put three chevrons in front of

00:10:52,460 --> 00:10:59,510
everything and be done with it so how is

00:10:56,990 --> 00:11:02,510
this possible why does the built-in

00:10:59,510 --> 00:11:03,850
Python doc test module have such syntax

00:11:02,510 --> 00:11:06,430
restrictions but

00:11:03,850 --> 00:11:07,990
excellent test doesn't will to

00:11:06,430 --> 00:11:11,650
understand this we need to take a quick

00:11:07,990 --> 00:11:13,390
aside into formal languages on the Left

00:11:11,650 --> 00:11:16,270
I have something called Chomsky

00:11:13,390 --> 00:11:20,410
hierarchy which sort of ranks the

00:11:16,270 --> 00:11:22,780
complexity of languages both in terms of

00:11:20,410 --> 00:11:25,720
how expressive they are and how easy it

00:11:22,780 --> 00:11:28,270
is to ask questions about them so on the

00:11:25,720 --> 00:11:31,330
very bottom we have regular languages

00:11:28,270 --> 00:11:34,270
which are the least expressive but the

00:11:31,330 --> 00:11:36,450
most easy to ask questions about above

00:11:34,270 --> 00:11:38,760
that we have context-free languages

00:11:36,450 --> 00:11:41,650
above that stills concept

00:11:38,760 --> 00:11:43,330
context-sensitive and at the very top we

00:11:41,650 --> 00:11:45,160
have recursive all recursively

00:11:43,330 --> 00:11:46,930
enumerable languages which are

00:11:45,160 --> 00:11:49,240
equivalent to Turing machines hence the

00:11:46,930 --> 00:11:51,640
image of our friend Alan Turing now the

00:11:49,240 --> 00:11:54,040
Chomsky hierarchy is a simplification of

00:11:51,640 --> 00:11:55,810
former languages and automata theory so

00:11:54,040 --> 00:11:59,320
on the right I have a more complete

00:11:55,810 --> 00:12:01,240
version you can look up on Wikipedia if

00:11:59,320 --> 00:12:03,790
you are interested in that but for the

00:12:01,240 --> 00:12:06,340
purposes of our talk we really need to

00:12:03,790 --> 00:12:09,430
understand the regular languages and the

00:12:06,340 --> 00:12:14,530
context-free languages so that's the

00:12:09,430 --> 00:12:17,650
theory now let's go into the practice so

00:12:14,530 --> 00:12:20,290
where does Python sit on this Chomsky

00:12:17,650 --> 00:12:22,570
hierarchy for the purposes of our talk

00:12:20,290 --> 00:12:25,300
we're going to classify Python as a

00:12:22,570 --> 00:12:26,980
context-free language now if you go

00:12:25,300 --> 00:12:29,800
online you'll quickly find that Python

00:12:26,980 --> 00:12:33,430
is not context-free but this is mainly

00:12:29,800 --> 00:12:36,220
due to the indentation scoping and if

00:12:33,430 --> 00:12:37,960
you were to abstract this away you would

00:12:36,220 --> 00:12:41,140
actually get a context-free language so

00:12:37,960 --> 00:12:42,910
it's close enough for our purposes now

00:12:41,140 --> 00:12:44,380
Python has two modules that I'm

00:12:42,910 --> 00:12:46,300
interested in right here we have the

00:12:44,380 --> 00:12:49,420
regular expression module which parses

00:12:46,300 --> 00:12:51,850
regular languages and we have the ast

00:12:49,420 --> 00:12:57,370
module which parses the Python

00:12:51,850 --> 00:13:00,160
context-free language so the issue with

00:12:57,370 --> 00:13:03,160
the duck test module is that it tries to

00:13:00,160 --> 00:13:05,620
parse your dog tests using regular

00:13:03,160 --> 00:13:09,970
expressions now doc tests are just

00:13:05,620 --> 00:13:13,300
Python code so it's trying to parse a

00:13:09,970 --> 00:13:16,670
language that is context-free using a

00:13:13,300 --> 00:13:19,440
library that is meant for regularly

00:13:16,670 --> 00:13:21,360
so python is just too complex to be

00:13:19,440 --> 00:13:24,240
parsed by regular expressions you can't

00:13:21,360 --> 00:13:26,970
mathematically do it which is why in

00:13:24,240 --> 00:13:28,680
extonic test i have replaced the rst

00:13:26,970 --> 00:13:31,200
module the

00:13:28,680 --> 00:13:34,290
the regular expression module with the

00:13:31,200 --> 00:13:38,310
AST or abstract syntax tree module and

00:13:34,290 --> 00:13:40,670
that's how I extract which lines belong

00:13:38,310 --> 00:13:43,380
to which statements in X Doc tests

00:13:40,670 --> 00:13:48,630
essentially doc tests are Python code

00:13:43,380 --> 00:13:50,730
and we need to treat them as such so now

00:13:48,630 --> 00:13:52,920
that we're a little familiar with X doc

00:13:50,730 --> 00:13:55,710
tests let's go back and revisit our case

00:13:52,920 --> 00:13:58,080
studies let's rerun the paragraph doc

00:13:55,710 --> 00:14:01,680
test instead of using the doc test

00:13:58,080 --> 00:14:05,450
module we'll use Python - M X doc test

00:14:01,680 --> 00:14:08,190
we'll pass it the talk py file and

00:14:05,450 --> 00:14:11,070
additionally extonic tests allows you to

00:14:08,190 --> 00:14:13,710
specify the name of the function which

00:14:11,070 --> 00:14:17,070
you want to run the doc tests of so we

00:14:13,710 --> 00:14:20,010
run this and it works there's no problem

00:14:17,070 --> 00:14:23,070
X doc test is able to handle the

00:14:20,010 --> 00:14:25,560
indentation and perfect scene regardless

00:14:23,070 --> 00:14:29,570
of whether a statement is a multi line

00:14:25,560 --> 00:14:31,890
or a single line additionally with

00:14:29,570 --> 00:14:34,470
multi-line strings sometimes having

00:14:31,890 --> 00:14:35,940
those chevron prefixes is a little

00:14:34,470 --> 00:14:38,160
annoying because the purpose of

00:14:35,940 --> 00:14:39,630
multi-line strings is you don't have to

00:14:38,160 --> 00:14:41,600
prefix them with anything you can just

00:14:39,630 --> 00:14:44,250
write the text down as you need to

00:14:41,600 --> 00:14:47,430
extract s can also handle this case

00:14:44,250 --> 00:14:49,830
because it parses your doc tests like

00:14:47,430 --> 00:14:54,270
their code it doesn't need to know which

00:14:49,830 --> 00:14:57,150
line belongs to which statement so you

00:14:54,270 --> 00:14:59,790
can actually omit these Chevron's for a

00:14:57,150 --> 00:15:01,910
multi-line statement if you want to but

00:14:59,790 --> 00:15:04,860
you don't have to

00:15:01,910 --> 00:15:08,130
so now let's revisit case study number

00:15:04,860 --> 00:15:10,500
two if we remember last time the this

00:15:08,130 --> 00:15:12,480
next iterable line was causing us

00:15:10,500 --> 00:15:14,250
problems because it returns something

00:15:12,480 --> 00:15:17,520
and we didn't tell it that we were

00:15:14,250 --> 00:15:21,180
expecting anything so let's run Python -

00:15:17,520 --> 00:15:24,450
M X doc tests on the top ey file and

00:15:21,180 --> 00:15:28,770
let's test function all same again now

00:15:24,450 --> 00:15:29,470
this works as well X doc test is built

00:15:28,770 --> 00:15:34,120
such

00:15:29,470 --> 00:15:37,210
by default if a statement produces a

00:15:34,120 --> 00:15:39,910
value and you don't give it anything to

00:15:37,210 --> 00:15:42,400
check it assumes that you didn't care

00:15:39,910 --> 00:15:44,980
about checking that value you will still

00:15:42,400 --> 00:15:47,230
fail if you provide it a once and the

00:15:44,980 --> 00:15:50,710
thing that you've got is different but

00:15:47,230 --> 00:15:55,440
in cases where you don't care it doesn't

00:15:50,710 --> 00:16:00,130
care either again X doc test is flexible

00:15:55,440 --> 00:16:02,800
X doc test is also easier to run with

00:16:00,130 --> 00:16:04,870
the original built in doc test module

00:16:02,800 --> 00:16:07,390
you can only give it a file path and

00:16:04,870 --> 00:16:10,510
it's gonna run all of the doc tests that

00:16:07,390 --> 00:16:12,460
it can find in that file X doc tests on

00:16:10,510 --> 00:16:16,390
the other hand you can pass it either a

00:16:12,460 --> 00:16:20,650
module name or a module path if the

00:16:16,390 --> 00:16:23,200
module name or path is a package it will

00:16:20,650 --> 00:16:26,080
recursively check all the files in that

00:16:23,200 --> 00:16:28,690
package for doc tests you can also give

00:16:26,080 --> 00:16:32,410
it a command like lists all of the doc

00:16:28,690 --> 00:16:35,500
tests in my package or run all of the

00:16:32,410 --> 00:16:38,350
doc tests in my package or you can pass

00:16:35,500 --> 00:16:41,200
a specific function or class to run the

00:16:38,350 --> 00:16:43,810
doc tests of even more specifically if

00:16:41,200 --> 00:16:46,780
your functional class has multiple doc

00:16:43,810 --> 00:16:50,080
tests in it you can use this colon index

00:16:46,780 --> 00:16:55,450
syntax to specify which of the doc tests

00:16:50,080 --> 00:16:58,780
you want to run x toc tests also has

00:16:55,450 --> 00:17:01,780
better output if you run X doc tests on

00:16:58,780 --> 00:17:03,970
a package or module any of the doc tests

00:17:01,780 --> 00:17:06,760
that failed will be listed at the bottom

00:17:03,970 --> 00:17:08,710
not only will be baby listed but they'll

00:17:06,760 --> 00:17:11,230
be listed in such a way that it gives

00:17:08,710 --> 00:17:13,750
you a command that you can use to

00:17:11,230 --> 00:17:16,720
re-execute that failed dog test and

00:17:13,750 --> 00:17:19,030
perhaps debugging X doc test gives you

00:17:16,720 --> 00:17:22,540
not only the line number where failures

00:17:19,030 --> 00:17:25,870
happen with respects to the doc test

00:17:22,540 --> 00:17:28,960
itself but where that doc test is in the

00:17:25,870 --> 00:17:31,570
file and lastly we use pigments to

00:17:28,960 --> 00:17:35,590
colorize the output and make everything

00:17:31,570 --> 00:17:38,620
just a little bit more readable X dog

00:17:35,590 --> 00:17:40,270
test has better directives we talked a

00:17:38,620 --> 00:17:42,820
little bit about the directives that

00:17:40,270 --> 00:17:45,730
exist in the built-in doc test module

00:17:42,820 --> 00:17:49,389
specifically the ellipses directive but

00:17:45,730 --> 00:17:52,870
also has a bunch more some of them i've

00:17:49,389 --> 00:17:54,669
found less useful than others and extact

00:17:52,870 --> 00:17:58,139
test actually doesn't have these

00:17:54,669 --> 00:18:01,149
implemented if you want these you can

00:17:58,139 --> 00:18:03,309
send a PR and i'll probably accept it

00:18:01,149 --> 00:18:06,429
but in the wild i really haven't seen

00:18:03,309 --> 00:18:08,889
these used too often more interestingly

00:18:06,429 --> 00:18:15,210
x doc test has some new directives

00:18:08,889 --> 00:18:18,309
namely skip ignore want and requires so

00:18:15,210 --> 00:18:20,129
skip what that does is that essentially

00:18:18,309 --> 00:18:24,009
skips the line that you're on and

00:18:20,129 --> 00:18:26,379
requires will conditionally skip the

00:18:24,009 --> 00:18:28,659
line that you're on based on either a

00:18:26,379 --> 00:18:32,139
command-line argument in this case this

00:18:28,659 --> 00:18:34,179
line will not run unless - - show exists

00:18:32,139 --> 00:18:37,509
on the command line you can also

00:18:34,179 --> 00:18:40,029
condition on even module exists and is

00:18:37,509 --> 00:18:43,289
important in this case we check to see

00:18:40,029 --> 00:18:45,820
if the numpy module exists or you can

00:18:43,289 --> 00:18:48,340
condition on the operating system and

00:18:45,820 --> 00:18:50,559
you can look in the documentation for

00:18:48,340 --> 00:18:54,610
more examples of what conditionals are

00:18:50,559 --> 00:18:57,370
possible so let's look at an example of

00:18:54,610 --> 00:18:59,799
these directives something i didn't

00:18:57,370 --> 00:19:02,470
mention is that in the original doc test

00:18:59,799 --> 00:19:04,779
module directives can only be applied in

00:19:02,470 --> 00:19:06,610
line essentially you can only put them

00:19:04,779 --> 00:19:08,799
after a single line of code and they

00:19:06,610 --> 00:19:11,379
only apply to that particular line of

00:19:08,799 --> 00:19:13,750
code in X doc test it's a little

00:19:11,379 --> 00:19:17,019
different if you have a directive and

00:19:13,750 --> 00:19:19,299
it's the only statement on the line then

00:19:17,019 --> 00:19:22,720
that directive is applied to everything

00:19:19,299 --> 00:19:24,940
below that line otherwise if it's on the

00:19:22,720 --> 00:19:28,120
same line and works as it used to in

00:19:24,940 --> 00:19:30,820
this case we have an in line directive

00:19:28,120 --> 00:19:33,190
followed by a multi-line directive

00:19:30,820 --> 00:19:35,830
followed by another multi-line directive

00:19:33,190 --> 00:19:39,039
notice the minus here instead of the

00:19:35,830 --> 00:19:42,340
plus the minus disables the directive

00:19:39,039 --> 00:19:44,679
whereas the plus enables it so if we

00:19:42,340 --> 00:19:49,750
actually go when we run this test using

00:19:44,679 --> 00:19:51,500
X doc test we see that the X doc test

00:19:49,750 --> 00:19:54,890
prints out at the source code

00:19:51,500 --> 00:19:58,190
test and we can see the output that we

00:19:54,890 --> 00:20:00,230
get we see this is run because it's the

00:19:58,190 --> 00:20:03,140
first line there's no directive applied

00:20:00,230 --> 00:20:06,470
yet then the next line is not run

00:20:03,140 --> 00:20:08,660
neither are the next three lines because

00:20:06,470 --> 00:20:10,910
we've been able to skip directive but if

00:20:08,660 --> 00:20:16,100
we disable the skip directive the final

00:20:10,910 --> 00:20:19,610
line does exist X dot test ships with a

00:20:16,100 --> 00:20:21,740
PI test plugin pi test actually comes

00:20:19,610 --> 00:20:24,680
with a built in block test plugin by

00:20:21,740 --> 00:20:28,040
default but if we pip install X dock

00:20:24,680 --> 00:20:30,710
test and we give PI test the - - X dot

00:20:28,040 --> 00:20:33,410
test command line flag that will tell it

00:20:30,710 --> 00:20:36,380
to disable its built in dock tests

00:20:33,410 --> 00:20:39,380
plug-in and enable the X dock test

00:20:36,380 --> 00:20:43,670
plugin this will add all of your dock

00:20:39,380 --> 00:20:45,800
tests to your testing suite so what

00:20:43,670 --> 00:20:49,400
happens when your dock tests are working

00:20:45,800 --> 00:20:51,860
if you use the X dock test runner

00:20:49,400 --> 00:20:54,470
instead of the PI test one what happens

00:20:51,860 --> 00:20:56,840
is that it tells you how many tests it

00:20:54,470 --> 00:20:59,600
found and how many tests will run it

00:20:56,840 --> 00:21:01,280
then shows you the source code of the

00:20:59,600 --> 00:21:04,010
test that it's about to run and then

00:21:01,280 --> 00:21:06,370
displays the output and finally at the

00:21:04,010 --> 00:21:10,160
end it tells you how many tests pass

00:21:06,370 --> 00:21:12,710
verses how many tests there were so in

00:21:10,160 --> 00:21:15,110
the more useful case what happens when

00:21:12,710 --> 00:21:17,360
it dock tests fail went over this a

00:21:15,110 --> 00:21:20,570
little bit before but let's let's look

00:21:17,360 --> 00:21:22,910
at the details so again X dock tests

00:21:20,570 --> 00:21:24,950
print how many tests are gonna run it

00:21:22,910 --> 00:21:27,770
prints the source code and the outputs

00:21:24,950 --> 00:21:30,560
and what the result is but at the end it

00:21:27,770 --> 00:21:33,890
tells you a list of which tests failed

00:21:30,560 --> 00:21:36,020
and it tells you a command line that you

00:21:33,890 --> 00:21:38,450
can put it into your shell to reproduce

00:21:36,020 --> 00:21:41,120
that test let's so reproduce one of

00:21:38,450 --> 00:21:44,450
these failing tests here I'm going to

00:21:41,120 --> 00:21:47,420
reproduce demo 3 and you can see that it

00:21:44,450 --> 00:21:50,000
just runs the one test that failed it

00:21:47,420 --> 00:21:54,830
again prints out that this is the failed

00:21:50,000 --> 00:21:57,410
test and we can debug this to try and

00:21:54,830 --> 00:22:02,120
fix it we see that the dock test source

00:21:57,410 --> 00:22:02,880
is print demo 5 and we pass a one string

00:22:02,120 --> 00:22:07,050
of

00:22:02,880 --> 00:22:08,580
three so we got demo five and then we

00:22:07,050 --> 00:22:12,360
see that there's a failure and the

00:22:08,580 --> 00:22:15,330
reason is a god want exception so we

00:22:12,360 --> 00:22:18,090
expected to get demo three but we got

00:22:15,330 --> 00:22:19,680
demo five and then it gives us a little

00:22:18,090 --> 00:22:22,530
bit of a representation difference in

00:22:19,680 --> 00:22:25,230
the strings and thus our dot test failed

00:22:22,530 --> 00:22:27,810
so we can go and fix that and hopefully

00:22:25,230 --> 00:22:30,060
make our doc tests work so that's a

00:22:27,810 --> 00:22:32,040
basic overview of X doc test provides an

00:22:30,060 --> 00:22:34,260
easier way to run your dark tests I

00:22:32,040 --> 00:22:36,690
didn't go over everything that it can do

00:22:34,260 --> 00:22:38,210
there's some miscellaneous features and

00:22:36,690 --> 00:22:40,650
some other things I haven't talked about

00:22:38,210 --> 00:22:42,600
one miscellaneous feature I'll just

00:22:40,650 --> 00:22:45,480
quickly touch on is that there is a zero

00:22:42,600 --> 00:22:47,790
arch runner in the spirit of having

00:22:45,480 --> 00:22:51,210
entered points everywhere I've often

00:22:47,790 --> 00:22:53,670
found myself sort of abusing X doc tests

00:22:51,210 --> 00:22:57,240
to run functions that actually don't

00:22:53,670 --> 00:23:00,630
have doc tests as long as a function

00:22:57,240 --> 00:23:03,090
doesn't have any arguments there's no

00:23:00,630 --> 00:23:04,980
reason that you can't just run the

00:23:03,090 --> 00:23:07,830
source code so X doc test has the

00:23:04,980 --> 00:23:08,640
ability to if you specify the function

00:23:07,830 --> 00:23:11,520
explicitly

00:23:08,640 --> 00:23:13,560
it will run any function that doesn't

00:23:11,520 --> 00:23:16,680
have any arguments or any arguments that

00:23:13,560 --> 00:23:19,740
I can't introspect there's also a lot of

00:23:16,680 --> 00:23:23,070
nice utilities in the X doc test package

00:23:19,740 --> 00:23:26,100
a lot of these utilities have actually

00:23:23,070 --> 00:23:28,440
made it into my utility package called

00:23:26,100 --> 00:23:31,620
you belt and something I want to

00:23:28,440 --> 00:23:34,710
highlight is in writing you belt I've

00:23:31,620 --> 00:23:38,370
been able to use X doc tests to achieve

00:23:34,710 --> 00:23:40,620
100% test coverage on the code base that

00:23:38,370 --> 00:23:46,530
sort of serves as a testament to how

00:23:40,620 --> 00:23:49,790
useful doc tests can be so X doc test

00:23:46,530 --> 00:23:52,680
isn't perfect there are some limitations

00:23:49,790 --> 00:23:54,810
one it's slightly slower than the

00:23:52,680 --> 00:23:58,050
original module but that's mainly

00:23:54,810 --> 00:24:01,920
because I'm using abstract syntax trees

00:23:58,050 --> 00:24:05,550
instead of regular expressions and kind

00:24:01,920 --> 00:24:07,200
of hard to get around that but even in

00:24:05,550 --> 00:24:08,460
that case there's probably still things

00:24:07,200 --> 00:24:11,160
that could be done a little bit more

00:24:08,460 --> 00:24:13,660
efficiently it's not slow by any means

00:24:11,160 --> 00:24:16,660
but it is slower than

00:24:13,660 --> 00:24:19,570
and doc test module the other limitation

00:24:16,660 --> 00:24:22,390
is it's not 100% backwards compatible

00:24:19,570 --> 00:24:24,460
it's mostly there we but we have those

00:24:22,390 --> 00:24:26,590
directives that are implemented as well

00:24:24,460 --> 00:24:28,840
as I've tweaked some of the defaults of

00:24:26,590 --> 00:24:31,780
these directives to essentially be more

00:24:28,840 --> 00:24:35,080
permissive and make it more likely that

00:24:31,780 --> 00:24:37,630
a doc test will actually execute without

00:24:35,080 --> 00:24:42,340
having to cause the programmer too many

00:24:37,630 --> 00:24:44,620
headaches so let's wrap up we've talked

00:24:42,340 --> 00:24:47,080
about doc tests and how they can be used

00:24:44,620 --> 00:24:49,930
using the original doc test module as

00:24:47,080 --> 00:24:51,910
well as X doc tests and there are some

00:24:49,930 --> 00:24:54,010
differences between these two the

00:24:51,910 --> 00:24:56,830
original doc test module is built into

00:24:54,010 --> 00:25:00,880
the standard library it uses regular

00:24:56,830 --> 00:25:04,180
expressions to parse the Python code as

00:25:00,880 --> 00:25:05,950
a restrictive syntax the output is sort

00:25:04,180 --> 00:25:09,550
of terse and hard to read and it can

00:25:05,950 --> 00:25:11,680
only run one file at a time but it has

00:25:09,550 --> 00:25:13,000
massive amounts of nourishing behind it

00:25:11,680 --> 00:25:15,850
because it's part of the standard

00:25:13,000 --> 00:25:19,060
library on the other hand we have X doc

00:25:15,850 --> 00:25:21,520
test which is an external pip install

00:25:19,060 --> 00:25:24,970
double module that uses abstract syntax

00:25:21,520 --> 00:25:27,580
trees to correctly parse Python code it

00:25:24,970 --> 00:25:30,820
has a more relaxed syntax with better

00:25:27,580 --> 00:25:33,430
directives and colored arguably more

00:25:30,820 --> 00:25:36,100
readable output it's mostly backwards

00:25:33,430 --> 00:25:40,000
compatible it runs quite well and a lot

00:25:36,100 --> 00:25:42,910
of the existing packages that use doc

00:25:40,000 --> 00:25:44,680
tests that I've tested on it can run

00:25:42,910 --> 00:25:47,650
either single functions or entire

00:25:44,680 --> 00:25:50,710
modules and I have tested X doc test on

00:25:47,650 --> 00:25:54,070
all Python C Python versions two point

00:25:50,710 --> 00:25:57,000
seven plus as well as pipeline but it

00:25:54,070 --> 00:26:00,160
only has three four stars on github

00:25:57,000 --> 00:26:03,940
despite having three point four thousand

00:26:00,160 --> 00:26:06,280
downloads every month so if you want to

00:26:03,940 --> 00:26:09,190
contribute to X doc test you can find it

00:26:06,280 --> 00:26:12,520
online at github comm slash arrow team

00:26:09,190 --> 00:26:14,200
and slash X doc test I've shown a image

00:26:12,520 --> 00:26:16,630
of the readme and the right

00:26:14,200 --> 00:26:18,400
the main areas for contribution are

00:26:16,630 --> 00:26:20,710
again the the person could be a little

00:26:18,400 --> 00:26:22,990
bit faster as well as the external

00:26:20,710 --> 00:26:24,910
documentation could be better it's not

00:26:22,990 --> 00:26:25,860
terrible I've actually put a lot of work

00:26:24,910 --> 00:26:28,260
into it in the past

00:26:25,860 --> 00:26:30,120
few months but it could use some eyes

00:26:28,260 --> 00:26:32,670
that aren't so closely tied to the

00:26:30,120 --> 00:26:34,710
project another contribution is maybe

00:26:32,670 --> 00:26:37,200
implementing those other directives that

00:26:34,710 --> 00:26:40,170
I haven't done yet if you want to build

00:26:37,200 --> 00:26:41,820
on top of exon test there's a lot of

00:26:40,170 --> 00:26:45,210
useful static analysis tools that I've

00:26:41,820 --> 00:26:47,100
written to make it possible and I think

00:26:45,210 --> 00:26:49,320
there's a lot of cool refactoring tools

00:26:47,100 --> 00:26:55,110
that could be built on top of these

00:26:49,320 --> 00:26:57,809
utilities so to conclude we've learned

00:26:55,110 --> 00:26:58,620
about doc tests what they are and why

00:26:57,809 --> 00:27:00,870
they're awesome

00:26:58,620 --> 00:27:03,000
we've talked about the built-in doc test

00:27:00,870 --> 00:27:06,059
module with its strengths and weaknesses

00:27:03,000 --> 00:27:08,040
as well as the new X doc test module

00:27:06,059 --> 00:27:10,410
with its improvements over the built-in

00:27:08,040 --> 00:27:13,080
its limitations as well as some cool

00:27:10,410 --> 00:27:14,790
stuff and if you remember nothing else

00:27:13,080 --> 00:27:17,669
from this talk please remember what

00:27:14,790 --> 00:27:20,730
Thomas key says regular expressions are

00:27:17,669 --> 00:27:24,270
for tokens abstract syntax trees are for

00:27:20,730 --> 00:27:28,410
Python code so please please please

00:27:24,270 --> 00:27:30,870
please do not use regular expressions to

00:27:28,410 --> 00:27:33,870
attempt to parse Python code it's

00:27:30,870 --> 00:27:36,030
mathematically impossible now I take

00:27:33,870 --> 00:27:39,120
questions but it's a little hard to do

00:27:36,030 --> 00:27:41,460
that in this format if you're watching

00:27:39,120 --> 00:27:43,110
this on YouTube leave all the questions

00:27:41,460 --> 00:27:46,830
in the comments and I'll do my best to

00:27:43,110 --> 00:27:48,540
address them so that's it that's the end

00:27:46,830 --> 00:27:52,429
you can pick install a tech stock test

00:27:48,540 --> 00:27:52,429

YouTube URL: https://www.youtube.com/watch?v=CUjCqOw_oFk


