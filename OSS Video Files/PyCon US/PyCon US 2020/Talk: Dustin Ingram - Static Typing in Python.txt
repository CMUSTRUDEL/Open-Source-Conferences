Title: Talk: Dustin Ingram - Static Typing in Python
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Dustin Ingram

Python is well-known as a programming language without static types. This means that you don’t need to say what a given variable will hold, or whether your function will return a string or an integer (or sometimes one, and sometimes another!). This has historically made Python a very flexible and beginner-friendly language.

In this talk, we’ll discuss the advantages and disadvantages to a static type system, as well as recent efforts to introduce static typing to Python via optional “type hints” and various tools to aid in adding types to Python code. We’ll see what this means for Python, for Python programmers, and what the future has in store for Python’s type system.
Captions: 
	00:00:04,740 --> 00:00:08,500
hi I'm Dustin I'm a developer advocate

00:00:07,660 --> 00:00:10,540
at Google

00:00:08,500 --> 00:00:12,459
I'm also the organizer for PI Texas

00:00:10,540 --> 00:00:14,920
conference which is will be in Austin

00:00:12,459 --> 00:00:16,660
Texas October 24th or 25th this year if

00:00:14,920 --> 00:00:18,790
you want to come I also work on a bunch

00:00:16,660 --> 00:00:20,860
of Python things including Python

00:00:18,790 --> 00:00:22,960
package index but I'm not here to talk

00:00:20,860 --> 00:00:24,250
to you about any of that today instead

00:00:22,960 --> 00:00:25,720
I'm here to talk to you about static

00:00:24,250 --> 00:00:29,259
typing and I wanna start with a pop quiz

00:00:25,720 --> 00:00:32,020
so is Python dynamically or statically

00:00:29,259 --> 00:00:33,820
typed so maybe you think yeah Python is

00:00:32,020 --> 00:00:36,280
a dynamically typed language so it's

00:00:33,820 --> 00:00:38,170
dynamically typed maybe you think this

00:00:36,280 --> 00:00:40,960
is a talk about static typing in Python

00:00:38,170 --> 00:00:42,910
it's probably statically typed or maybe

00:00:40,960 --> 00:00:45,430
you think this is actually a trick

00:00:42,910 --> 00:00:47,470
question and it is this is a trick

00:00:45,430 --> 00:00:49,240
question so the answer is that Python

00:00:47,470 --> 00:00:51,490
can be dynamically typed but can

00:00:49,240 --> 00:00:53,500
optionally be as statically typed as you

00:00:51,490 --> 00:00:54,850
want it to be and that answer might not

00:00:53,500 --> 00:00:56,290
make sense to you and if it doesn't

00:00:54,850 --> 00:00:58,570
that's okay you're watching the right

00:00:56,290 --> 00:01:00,280
talk this steps to understand answer to

00:00:58,570 --> 00:01:02,739
that question are first we need to talk

00:01:00,280 --> 00:01:04,839
about types in Python then type systems

00:01:02,739 --> 00:01:07,420
in general dynamic typing in Python

00:01:04,839 --> 00:01:08,860
static typing in Python and then once we

00:01:07,420 --> 00:01:11,229
understand that we can talk about how to

00:01:08,860 --> 00:01:12,970
use static typing when you should use

00:01:11,229 --> 00:01:15,370
static typing and also maybe when you

00:01:12,970 --> 00:01:16,990
shouldn't use static typing so let's

00:01:15,370 --> 00:01:19,300
talk about types and let's specifically

00:01:16,990 --> 00:01:22,750
talk about the type built-in in Python

00:01:19,300 --> 00:01:25,030
so imply that if I type type of 42 I get

00:01:22,750 --> 00:01:27,700
a response class int I can do type

00:01:25,030 --> 00:01:30,370
before T 2.0 I'll get a class float type

00:01:27,700 --> 00:01:32,590
of foo is class string and type of foo

00:01:30,370 --> 00:01:34,810
and bar is a class list and you might

00:01:32,590 --> 00:01:36,820
say oh I recognize these these are the

00:01:34,810 --> 00:01:38,950
built-ins that I can use to change one

00:01:36,820 --> 00:01:40,600
type into another type and you'd be

00:01:38,950 --> 00:01:43,600
right right we could set a variable a

00:01:40,600 --> 00:01:46,570
equals 42 and we can change it into a

00:01:43,600 --> 00:01:48,729
float by calling float on it and cast it

00:01:46,570 --> 00:01:51,520
to a string and then we can cast it to a

00:01:48,729 --> 00:01:53,290
really ugly list so maybe you've had a

00:01:51,520 --> 00:01:54,880
weird bug where a string actually got

00:01:53,290 --> 00:01:57,549
turned into a list that looks like this

00:01:54,880 --> 00:01:59,560
guess what that is a type error you are

00:01:57,549 --> 00:02:01,210
in the right place it would seem like

00:01:59,560 --> 00:02:03,729
these are just the only types available

00:02:01,210 --> 00:02:05,409
to us right in float string but these

00:02:03,729 --> 00:02:07,030
are actually just classes that have

00:02:05,409 --> 00:02:08,319
corresponding built-ins in Python

00:02:07,030 --> 00:02:09,519
so basically we're doing class matching

00:02:08,319 --> 00:02:12,519
here when we do something like is

00:02:09,519 --> 00:02:14,319
instance 42 in we're seeing it 42 is an

00:02:12,519 --> 00:02:16,299
instance of the int class int is just a

00:02:14,319 --> 00:02:18,319
built-in here there are other type

00:02:16,299 --> 00:02:20,450
classes too that don't correspond

00:02:18,319 --> 00:02:21,799
- built-ins like for example none type

00:02:20,450 --> 00:02:23,510
I'm sure we've got them that a lot in

00:02:21,799 --> 00:02:25,310
our Python code all right none type is

00:02:23,510 --> 00:02:27,530
the type of none but we don't use none

00:02:25,310 --> 00:02:30,109
type to describe it similarly there's a

00:02:27,530 --> 00:02:33,019
function type but we don't use function

00:02:30,109 --> 00:02:35,269
to define function we say death func etc

00:02:33,019 --> 00:02:37,430
etc there's also lots of other ones like

00:02:35,269 --> 00:02:39,620
the ellipses type and these all don't

00:02:37,430 --> 00:02:41,239
correspond directly to built-ins the

00:02:39,620 --> 00:02:43,519
place we get them from is what if we

00:02:41,239 --> 00:02:45,379
import types we can get this giant list

00:02:43,519 --> 00:02:47,090
of all the types that are available to

00:02:45,379 --> 00:02:49,700
us many of them live in the types module

00:02:47,090 --> 00:02:52,189
and all these can actually be used to

00:02:49,700 --> 00:02:53,510
instantiate a new type so for example a

00:02:52,189 --> 00:02:56,449
function we could instantiate a new

00:02:53,510 --> 00:02:57,829
function with the function type open

00:02:56,449 --> 00:02:59,389
close friends with some arguments in

00:02:57,829 --> 00:03:00,859
there but we don't really do that and

00:02:59,389 --> 00:03:02,599
it's for a good reason it would end up

00:03:00,859 --> 00:03:05,810
looking really messy instead we'll do it

00:03:02,599 --> 00:03:07,639
the normal way with def function name so

00:03:05,810 --> 00:03:10,189
when we say the python has a dynamically

00:03:07,639 --> 00:03:11,810
typed language it means a few things it

00:03:10,189 --> 00:03:13,189
means first of all that variables can be

00:03:11,810 --> 00:03:14,989
any type and that the type of the

00:03:13,189 --> 00:03:17,269
variable can change over the course of

00:03:14,989 --> 00:03:19,519
the runtime of your program so for

00:03:17,269 --> 00:03:21,469
example here I can import random and set

00:03:19,519 --> 00:03:23,599
a equal to the value of random choice

00:03:21,469 --> 00:03:26,150
that contains a list of three things the

00:03:23,599 --> 00:03:28,549
integer 42 the flow 42 and the string 42

00:03:26,150 --> 00:03:30,979
now if I call type a on the result of

00:03:28,549 --> 00:03:32,389
that variable what type is a and the

00:03:30,979 --> 00:03:34,250
answer is that we don't know this is

00:03:32,389 --> 00:03:36,019
determined non-deterministic it could be

00:03:34,250 --> 00:03:37,549
a string it could be an integer or it

00:03:36,019 --> 00:03:39,979
could be a float depends on what Ram

00:03:37,549 --> 00:03:42,409
that choice decided to choose dynamic

00:03:39,979 --> 00:03:44,120
typing also means that the arguments and

00:03:42,409 --> 00:03:46,340
the return types of a function can be

00:03:44,120 --> 00:03:48,349
any type as well in Python if we write a

00:03:46,340 --> 00:03:51,049
function like this from negate of ABC

00:03:48,349 --> 00:03:52,400
and returns a plus B plus C if we've

00:03:51,049 --> 00:03:54,049
read a function like this how do we know

00:03:52,400 --> 00:03:55,970
that we're getting the types that we're

00:03:54,049 --> 00:03:58,220
expecting so if you solve this function

00:03:55,970 --> 00:03:59,720
and you didn't know what it does what

00:03:58,220 --> 00:04:02,180
would you expect the argument and return

00:03:59,720 --> 00:04:04,310
types to be so you might guess that

00:04:02,180 --> 00:04:06,079
they're integers and that would work

00:04:04,310 --> 00:04:08,359
right we could call fraud negate with

00:04:06,079 --> 00:04:10,359
one two and three and returned the

00:04:08,359 --> 00:04:13,159
result of the sum of those three numbers

00:04:10,359 --> 00:04:15,439
but so it strings endless and basically

00:04:13,159 --> 00:04:17,000
anything else this supports the addition

00:04:15,439 --> 00:04:18,289
operator here too right we could pass it

00:04:17,000 --> 00:04:20,000
three strings and it would eventually

00:04:18,289 --> 00:04:22,280
just concatenate all these three strings

00:04:20,000 --> 00:04:24,440
together and return that value what we

00:04:22,280 --> 00:04:26,690
can't do here is mix integers and

00:04:24,440 --> 00:04:29,000
strings together so we can't pass one

00:04:26,690 --> 00:04:31,400
two as integers and foo as a string

00:04:29,000 --> 00:04:32,210
because that's a type error we can't use

00:04:31,400 --> 00:04:35,060
the plus op

00:04:32,210 --> 00:04:36,979
to combine integers and strings all

00:04:35,060 --> 00:04:39,800
right so that function is confusing how

00:04:36,979 --> 00:04:42,380
could we possibly fix it one thing we

00:04:39,800 --> 00:04:45,350
could do is this we could write really

00:04:42,380 --> 00:04:47,000
long and detailed dock strings describe

00:04:45,350 --> 00:04:49,160
what the parameters and the return type

00:04:47,000 --> 00:04:50,750
of the function are so if you do this I

00:04:49,160 --> 00:04:52,160
would ask yourself a shirt company

00:04:50,750 --> 00:04:54,470
paying you enough to do this because

00:04:52,160 --> 00:04:56,300
this is a lot of work and at the end of

00:04:54,470 --> 00:04:57,740
the day this doesn't actually even have

00:04:56,300 --> 00:04:59,690
any control over the runtime of our

00:04:57,740 --> 00:05:01,130
program right this is just documentation

00:04:59,690 --> 00:05:03,350
it doesn't ensure that our developers

00:05:01,130 --> 00:05:04,490
are actually calling this function with

00:05:03,350 --> 00:05:07,160
the correct parameters that you

00:05:04,490 --> 00:05:09,050
described in the doc string another

00:05:07,160 --> 00:05:11,210
thing we could do is we could assert on

00:05:09,050 --> 00:05:12,500
the the argument types and the return

00:05:11,210 --> 00:05:14,449
type of everything that's passed our

00:05:12,500 --> 00:05:16,099
function so for each of the parameters

00:05:14,449 --> 00:05:18,080
we assert that the type is the type that

00:05:16,099 --> 00:05:20,360
we're expecting we do our business logic

00:05:18,080 --> 00:05:23,419
and then we're assert a certain on the

00:05:20,360 --> 00:05:24,320
return type and then return it so we

00:05:23,419 --> 00:05:25,699
don't do this either

00:05:24,320 --> 00:05:27,199
and actually I gave this talk once

00:05:25,699 --> 00:05:29,240
before and I said nobody does this at

00:05:27,199 --> 00:05:31,280
all and someone in the audience is well

00:05:29,240 --> 00:05:32,570
yeah actually we do do this and so while

00:05:31,280 --> 00:05:33,650
this is valid right and this is type

00:05:32,570 --> 00:05:36,199
checking there are some problems with it

00:05:33,650 --> 00:05:37,909
first of all there's a little bit of

00:05:36,199 --> 00:05:39,979
overhead here every year certian that we

00:05:37,909 --> 00:05:42,139
have to do here it slows down our

00:05:39,979 --> 00:05:43,580
program just a little bit and you can

00:05:42,139 --> 00:05:45,860
optimize that out at runtime but it's

00:05:43,580 --> 00:05:47,870
not that common the other problem here

00:05:45,860 --> 00:05:50,240
is that what if you forget to write an

00:05:47,870 --> 00:05:53,210
assertion right then your your program

00:05:50,240 --> 00:05:55,570
is missing some some type checking so we

00:05:53,210 --> 00:05:58,610
don't do this what do we do instead

00:05:55,570 --> 00:06:00,919
instead what we do is called duck typing

00:05:58,610 --> 00:06:02,900
duck typing means that if it walks like

00:06:00,919 --> 00:06:04,639
a duck and it quacks like a duck it is

00:06:02,900 --> 00:06:07,099
probably a duck so this means that we

00:06:04,639 --> 00:06:09,979
determine the types of a function or a

00:06:07,099 --> 00:06:11,750
variable based on how it's used in each

00:06:09,979 --> 00:06:13,520
of these you can kind of guess what foo

00:06:11,750 --> 00:06:15,770
and bar are based on what's being done

00:06:13,520 --> 00:06:17,270
with it so in the first example bar is

00:06:15,770 --> 00:06:19,820
some kind of iterable it might be a list

00:06:17,270 --> 00:06:21,889
or a string or not possibly even a dict

00:06:19,820 --> 00:06:22,909
and foo is a list comprehension so

00:06:21,889 --> 00:06:26,090
that's going to come out and being a

00:06:22,909 --> 00:06:27,409
list in the second example bar is being

00:06:26,090 --> 00:06:29,720
compared to zero so it's probably

00:06:27,409 --> 00:06:31,759
something like an int or float and in

00:06:29,720 --> 00:06:33,590
the last example it's a little bit

00:06:31,759 --> 00:06:35,690
ambiguous actually right is bar a

00:06:33,590 --> 00:06:37,580
function or class like what is foo gonna

00:06:35,690 --> 00:06:40,070
be here it actually could end up being

00:06:37,580 --> 00:06:42,169
anything so now let's talk about static

00:06:40,070 --> 00:06:43,940
typing stack typing meaning as in it a

00:06:42,169 --> 00:06:45,590
variable type is defined and is not

00:06:43,940 --> 00:06:45,980
going to change and there are actually

00:06:45,590 --> 00:06:48,200
lots

00:06:45,980 --> 00:06:49,790
statically typed languages here's some

00:06:48,200 --> 00:06:53,030
examples of the same function we're just

00:06:49,790 --> 00:06:56,300
looking at in those languages so here is

00:06:53,030 --> 00:06:58,130
an example of from making in C here it

00:06:56,300 --> 00:07:00,400
is in Java it's a dead giveaway with a

00:06:58,130 --> 00:07:03,350
public static int blah blah blah blah

00:07:00,400 --> 00:07:04,670
this one is rust you can store tell it's

00:07:03,350 --> 00:07:06,320
rust because rust has really

00:07:04,670 --> 00:07:08,330
fine-grained control of the integer

00:07:06,320 --> 00:07:12,050
types the u8 here is an unsigned 8-bit

00:07:08,330 --> 00:07:14,420
integer and this last one is typescript

00:07:12,050 --> 00:07:16,160
javascript itself doesn't have types but

00:07:14,420 --> 00:07:17,960
typescript is an implementation of type

00:07:16,160 --> 00:07:20,360
javascript and this is a dead giveaway

00:07:17,960 --> 00:07:23,270
that is typescript or javascript because

00:07:20,360 --> 00:07:24,650
in JavaScript everything is all all

00:07:23,270 --> 00:07:27,140
numbers with just the same type they are

00:07:24,650 --> 00:07:29,090
a number so we can kind of put languages

00:07:27,140 --> 00:07:30,650
into two categories first dynamically

00:07:29,090 --> 00:07:32,150
typed languages and statically typed

00:07:30,650 --> 00:07:33,710
languages and we got to put a little

00:07:32,150 --> 00:07:35,330
asterisk here next to python because

00:07:33,710 --> 00:07:38,030
that's the content of this talk and

00:07:35,330 --> 00:07:39,650
technically ruby is gonna get optional

00:07:38,030 --> 00:07:42,230
static type checking when ruby 3 comes

00:07:39,650 --> 00:07:44,690
out later this year but I'm gonna leave

00:07:42,230 --> 00:07:47,120
it off the list for now so earlier I

00:07:44,690 --> 00:07:48,950
said Python is dynamically typed but can

00:07:47,120 --> 00:07:51,080
optionally be as statically typed as you

00:07:48,950 --> 00:07:54,140
want to be now the thing to note here is

00:07:51,080 --> 00:07:56,240
that this wasn't always true and the

00:07:54,140 --> 00:07:57,740
story of static typing in Python is also

00:07:56,240 --> 00:08:00,530
kind of the story of static typing at

00:07:57,740 --> 00:08:01,970
Dropbox Dropbox is a little company with

00:08:00,530 --> 00:08:04,130
millions and millions of lines of Python

00:08:01,970 --> 00:08:06,620
code and basically at some point in

00:08:04,130 --> 00:08:08,660
their history they decided that having

00:08:06,620 --> 00:08:10,190
that much untyped Python code was

00:08:08,660 --> 00:08:11,870
actually a liability right it was

00:08:10,190 --> 00:08:13,520
slowing down their developers and making

00:08:11,870 --> 00:08:15,280
things harder for them to create new

00:08:13,520 --> 00:08:17,000
features and do the actual development

00:08:15,280 --> 00:08:18,290
but there were some other things that

00:08:17,000 --> 00:08:20,930
led up to it as well and I'll talk about

00:08:18,290 --> 00:08:23,660
those here the first was pept 3107

00:08:20,930 --> 00:08:26,060
function annotations we got this in 2006

00:08:23,660 --> 00:08:29,360
with Python 3 and this let us write a

00:08:26,060 --> 00:08:32,120
function like this and add some extra

00:08:29,360 --> 00:08:34,610
metadata to annotate the arguments in

00:08:32,120 --> 00:08:36,380
the return value of the function so the

00:08:34,610 --> 00:08:37,700
thing to note here is that this has zero

00:08:36,380 --> 00:08:40,370
effect on the execution of the function

00:08:37,700 --> 00:08:42,590
and we can put whatever we want in as

00:08:40,370 --> 00:08:44,660
these annotations all of this gives us

00:08:42,590 --> 00:08:46,250
is an attribute on the function called

00:08:44,660 --> 00:08:47,660
dunder annotations that gives us the

00:08:46,250 --> 00:08:50,540
result of evaluating all of these

00:08:47,660 --> 00:08:52,940
annotations so here it would be X beYOU

00:08:50,540 --> 00:08:54,770
be the sum of 5 and 6 and 11 seem to be

00:08:52,940 --> 00:08:58,040
the empty list and the return type would

00:08:54,770 --> 00:08:59,660
be 9 so anything compiling this function

00:08:58,040 --> 00:09:02,750
or interpreting this function has

00:08:59,660 --> 00:09:04,760
access these annotations but they're not

00:09:02,750 --> 00:09:06,740
this isn't maybe super useful and the

00:09:04,760 --> 00:09:10,070
pep itself sort of listed a whole lot of

00:09:06,740 --> 00:09:12,110
uses for this annotation thing they

00:09:10,070 --> 00:09:13,550
basically all boil down to we can do

00:09:12,110 --> 00:09:15,800
something that looks like static typing

00:09:13,550 --> 00:09:17,450
with this and also maybe we could stick

00:09:15,800 --> 00:09:19,070
some documentation but basically the

00:09:17,450 --> 00:09:20,720
purpose was let's do something that

00:09:19,070 --> 00:09:22,250
looks like static typing so if we think

00:09:20,720 --> 00:09:23,660
about this through the lens of saiping

00:09:22,250 --> 00:09:25,970
we could write annotations like this

00:09:23,660 --> 00:09:28,160
where the annotation itself is the type

00:09:25,970 --> 00:09:30,080
of the argument that we're expecting and

00:09:28,160 --> 00:09:32,060
the type of the return type but still

00:09:30,080 --> 00:09:34,310
this doesn't give us any way to actually

00:09:32,060 --> 00:09:36,320
evaluate whether this function is being

00:09:34,310 --> 00:09:37,100
used correctly elsewhere it's still just

00:09:36,320 --> 00:09:38,990
metadata

00:09:37,100 --> 00:09:40,940
it also doesn't give us a way to imitate

00:09:38,990 --> 00:09:43,610
variables we can only annotate functions

00:09:40,940 --> 00:09:45,950
their arguments and return types so

00:09:43,610 --> 00:09:49,550
around the same time as this pet was

00:09:45,950 --> 00:09:51,440
authored a you collect Oslo a PhD

00:09:49,550 --> 00:09:53,750
candidate at University of Cambridge was

00:09:51,440 --> 00:09:55,880
doing his PhD research and his research

00:09:53,750 --> 00:09:57,500
was on the unification of statically

00:09:55,880 --> 00:10:00,560
typed and dynamically typed languages

00:09:57,500 --> 00:10:02,450
sounds pretty interesting he wanted to

00:10:00,560 --> 00:10:04,670
use the same language for everything

00:10:02,450 --> 00:10:07,520
from a very tiny script to a sprawling

00:10:04,670 --> 00:10:10,040
multi-line code base and his researchers

00:10:07,520 --> 00:10:11,540
also focused on the gradual growth from

00:10:10,040 --> 00:10:13,190
an untyped prototype to a statically

00:10:11,540 --> 00:10:14,630
typed product meaning you don't have to

00:10:13,190 --> 00:10:16,790
do it all one so you could start with

00:10:14,630 --> 00:10:19,130
some small parts of your code base

00:10:16,790 --> 00:10:20,710
statically typed and slowly grow and add

00:10:19,130 --> 00:10:23,510
static typing to the rest your code base

00:10:20,710 --> 00:10:25,700
sounds pretty cool so he published his

00:10:23,510 --> 00:10:27,920
research in 2011 and his thesis was

00:10:25,700 --> 00:10:29,600
basically this adding a static type

00:10:27,920 --> 00:10:31,490
system to a dynamically typed language

00:10:29,600 --> 00:10:33,350
can be an evasive change that would

00:10:31,490 --> 00:10:35,240
require coordinated modification of the

00:10:33,350 --> 00:10:37,910
existing programs virtual machines and

00:10:35,240 --> 00:10:39,710
development tools however optional

00:10:37,910 --> 00:10:41,780
pluggable type systems do not affect the

00:10:39,710 --> 00:10:43,790
runtime semantics of programs and thus

00:10:41,780 --> 00:10:46,220
they can be added to a language without

00:10:43,790 --> 00:10:49,850
affecting existing code and tools this

00:10:46,220 --> 00:10:53,000
sounds really great so a Pike on us in

00:10:49,850 --> 00:10:54,530
2013 you can introduced mypie and if

00:10:53,000 --> 00:10:56,300
you've heard of my pie before this is

00:10:54,530 --> 00:10:58,190
probably not what you're thinking of in

00:10:56,300 --> 00:11:00,560
his abstract you could describe some my

00:10:58,190 --> 00:11:02,300
pie as an experimental variant of Python

00:11:00,560 --> 00:11:04,040
that supports writing programs that

00:11:02,300 --> 00:11:05,810
seamlessly mix dynamic and Static typing

00:11:04,040 --> 00:11:07,820
this is not really true when we talk

00:11:05,810 --> 00:11:09,890
about my pie today in his research he

00:11:07,820 --> 00:11:11,270
didn't really wasn't able to use an

00:11:09,890 --> 00:11:13,760
existing language to determine how to do

00:11:11,270 --> 00:11:15,110
this he couldn't use Python the way what

00:11:13,760 --> 00:11:16,940
what he did was he created his own

00:11:15,110 --> 00:11:19,910
language instead which isn't really that

00:11:16,940 --> 00:11:21,589
crazy for theoretical research and this

00:11:19,910 --> 00:11:23,240
is what the variant looked like it could

00:11:21,589 --> 00:11:24,529
be compiled to Python and it kinda

00:11:23,240 --> 00:11:26,930
actually looked a little like Python if

00:11:24,529 --> 00:11:28,760
you squint at it the issue is even with

00:11:26,930 --> 00:11:29,959
function annotations which existed in

00:11:28,760 --> 00:11:31,700
Python the time I thought couldn't

00:11:29,959 --> 00:11:33,730
support everything that was necessary to

00:11:31,700 --> 00:11:35,899
be completely statically typed itself

00:11:33,730 --> 00:11:38,240
Yuka said he eventually presented his

00:11:35,899 --> 00:11:39,740
project at PyCon and afterwards he

00:11:38,240 --> 00:11:41,810
talked to Geetha there awesome about it

00:11:39,740 --> 00:11:43,670
PDF elf Python and Guiteau convinced him

00:11:41,810 --> 00:11:45,200
to drop the custom syntax and just stick

00:11:43,670 --> 00:11:47,570
to straight Python three let's just do

00:11:45,200 --> 00:11:49,190
this in Python three so my PI also

00:11:47,570 --> 00:11:51,020
included a static type checker for this

00:11:49,190 --> 00:11:52,760
Python variant which was modified to

00:11:51,020 --> 00:11:54,800
check Python instead and that's when we

00:11:52,760 --> 00:11:56,750
actually think of as myapi today the

00:11:54,800 --> 00:11:58,610
next thing that happened in 2014 was we

00:11:56,750 --> 00:12:00,620
got pet 483 which is a theory of

00:11:58,610 --> 00:12:02,240
type-ins this was Guiteau putting down

00:12:00,620 --> 00:12:04,160
some ideas about how static typing

00:12:02,240 --> 00:12:06,050
should work in python one thing this pet

00:12:04,160 --> 00:12:07,670
describes is optional typing which means

00:12:06,050 --> 00:12:09,470
that adding annotations shouldn't affect

00:12:07,670 --> 00:12:11,060
the runtime of your program an annotated

00:12:09,470 --> 00:12:13,040
function should run the same as an

00:12:11,060 --> 00:12:14,360
undated function and I think this sort

00:12:13,040 --> 00:12:16,399
of comes from some lessons we learned

00:12:14,360 --> 00:12:18,649
from the Python two-to-three migration

00:12:16,399 --> 00:12:21,350
basically adding static typing shouldn't

00:12:18,649 --> 00:12:22,670
get in the way of your program another

00:12:21,350 --> 00:12:24,709
thing describes is gradual typing

00:12:22,670 --> 00:12:26,600
basically the idea let's not try to do

00:12:24,709 --> 00:12:28,940
this all at once gradual typing allows

00:12:26,600 --> 00:12:31,160
one to ante only a part of a program and

00:12:28,940 --> 00:12:32,990
does leverage the desirable aspects of

00:12:31,160 --> 00:12:33,709
both dynamic and static typing at the

00:12:32,990 --> 00:12:35,390
same time

00:12:33,709 --> 00:12:37,070
in addition and describes a way to do

00:12:35,390 --> 00:12:37,910
variable annotations building on pet

00:12:37,070 --> 00:12:39,709
00:12:37,910 --> 00:12:41,810
to give us a way to annotate more than

00:12:39,709 --> 00:12:43,670
just functions so this means that with

00:12:41,810 --> 00:12:45,890
our original function we could add a

00:12:43,670 --> 00:12:47,930
type annotation to the actual bhisma's

00:12:45,890 --> 00:12:49,430
variable here it introduced type hinting

00:12:47,930 --> 00:12:51,230
for Python - because functional

00:12:49,430 --> 00:12:53,060
annotations didn't exist before Python 3

00:12:51,230 --> 00:12:55,490
but even those stuck in the past Khan

00:12:53,060 --> 00:12:56,930
deserve static typing so in Python 3 we

00:12:55,490 --> 00:12:59,300
can write a nice slow function like this

00:12:56,930 --> 00:13:01,579
where all the argument types return type

00:12:59,300 --> 00:13:03,649
are annotated but in Python 2 we have a

00:13:01,579 --> 00:13:06,050
way to write the same function same type

00:13:03,649 --> 00:13:08,329
annotation but just use type comments

00:13:06,050 --> 00:13:10,339
instead finally it also introduced some

00:13:08,329 --> 00:13:12,170
special type constructs so these are

00:13:10,339 --> 00:13:14,660
fundamental building blocks that we need

00:13:12,170 --> 00:13:16,550
to do static typing and these build on

00:13:14,660 --> 00:13:19,220
the existing types like int float string

00:13:16,550 --> 00:13:21,380
none type to give us some new types like

00:13:19,220 --> 00:13:21,529
any which is consistent with any type at

00:13:21,380 --> 00:13:23,510
all

00:13:21,529 --> 00:13:25,670
Union which would be the combination of

00:13:23,510 --> 00:13:26,750
one or more types optional which is an

00:13:25,670 --> 00:13:29,480
alias for the union of

00:13:26,750 --> 00:13:31,310
type and nun type a tuple which would be

00:13:29,480 --> 00:13:34,790
you know a couple whose items have those

00:13:31,310 --> 00:13:36,650
types callable etc so this lets us write

00:13:34,790 --> 00:13:38,960
a function like this where from decay

00:13:36,650 --> 00:13:41,510
takes first an integer then an integer

00:13:38,960 --> 00:13:42,980
and then the third argument here could

00:13:41,510 --> 00:13:44,870
be an integer or it could be a float

00:13:42,980 --> 00:13:46,760
depends on how the user calls it the pep

00:13:44,870 --> 00:13:48,200
also gives us container types container

00:13:46,760 --> 00:13:50,150
classes are things like lists and

00:13:48,200 --> 00:13:51,950
dictionaries that contain other objects

00:13:50,150 --> 00:13:53,330
so container types are really important

00:13:51,950 --> 00:13:55,490
because they let us define the type

00:13:53,330 --> 00:13:57,020
inside of the container class so for

00:13:55,490 --> 00:13:58,670
example I could create a user as

00:13:57,020 --> 00:14:00,290
variable here that it's typed as

00:13:58,670 --> 00:14:02,180
containing only integers I can add

00:14:00,290 --> 00:14:04,220
integers to it and that's fine but if I

00:14:02,180 --> 00:14:06,350
try to append something like a string it

00:14:04,220 --> 00:14:08,240
will fail and similarly for a dictionary

00:14:06,350 --> 00:14:10,610
I can type the key and the value

00:14:08,240 --> 00:14:13,340
so here examples contains keys of

00:14:10,610 --> 00:14:15,530
strings values of integers so I can set

00:14:13,340 --> 00:14:18,020
some guy equal to 42 and that's fine but

00:14:15,530 --> 00:14:19,670
I can't use the key of an integer this

00:14:18,020 --> 00:14:21,230
pepp also gives us generic types for

00:14:19,670 --> 00:14:23,390
when a class or function behaves in a

00:14:21,230 --> 00:14:25,460
generic manner so if I wanted to type a

00:14:23,390 --> 00:14:27,230
function as taking an iterable and I

00:14:25,460 --> 00:14:28,700
don't care if it's a string or a list or

00:14:27,230 --> 00:14:32,170
basically anything that can iterate over

00:14:28,700 --> 00:14:34,580
I can use the interval generic here and

00:14:32,170 --> 00:14:37,070
finally we have type Alice's which allow

00:14:34,580 --> 00:14:38,540
us to be more succinct with our types so

00:14:37,070 --> 00:14:40,400
this means that if we wanted to be more

00:14:38,540 --> 00:14:42,230
like JavaScript we could create a number

00:14:40,400 --> 00:14:43,970
type that's the union of all number

00:14:42,230 --> 00:14:46,040
types available to us and we can

00:14:43,970 --> 00:14:48,260
annotate our function with it the next

00:14:46,040 --> 00:14:51,200
prep we get is pet 484 which is type int

00:14:48,260 --> 00:14:53,990
in 2014 and this standardizes everything

00:14:51,200 --> 00:14:55,820
in pet 483 and my PI's behavior it

00:14:53,990 --> 00:14:57,410
introduces the typing module to provide

00:14:55,820 --> 00:14:58,940
standard definitions fundamental

00:14:57,410 --> 00:15:00,589
building blocks and tools it also

00:14:58,940 --> 00:15:02,960
introduces a lot of details about edge

00:15:00,589 --> 00:15:04,850
cases and specific use cases essentially

00:15:02,960 --> 00:15:06,800
it's how to build a type checker in

00:15:04,850 --> 00:15:08,630
Python and it leans really heavily on

00:15:06,800 --> 00:15:12,080
what my PI is already doing at this time

00:15:08,630 --> 00:15:15,890
in Python 35 we got pet 484 support and

00:15:12,080 --> 00:15:18,170
the typing module in 2016 we got pet 526

00:15:15,890 --> 00:15:20,089
syntax for variable annotations so the

00:15:18,170 --> 00:15:21,890
existing comment style annotations was

00:15:20,089 --> 00:15:23,780
great for python 2 but not great

00:15:21,890 --> 00:15:26,089
elsewhere so this lets us take a comment

00:15:23,780 --> 00:15:27,980
style annotation like this and move it

00:15:26,089 --> 00:15:30,020
actually into part of the variable

00:15:27,980 --> 00:15:31,520
declaration one of the problems with

00:15:30,020 --> 00:15:33,200
common style annotations was that we

00:15:31,520 --> 00:15:36,680
couldn't define a type for a variable

00:15:33,200 --> 00:15:38,990
and not specify an initial type so here

00:15:36,680 --> 00:15:39,810
now with pet 526 we can just say the

00:15:38,990 --> 00:15:41,760
captive variable

00:15:39,810 --> 00:15:43,950
string and has no initial value and

00:15:41,760 --> 00:15:46,050
similarly for class variables we can now

00:15:43,950 --> 00:15:48,660
do those in line like this so with

00:15:46,050 --> 00:15:50,580
Python 36 we got pet 526 support and we

00:15:48,660 --> 00:15:52,590
almost had everything to do static type

00:15:50,580 --> 00:15:54,570
checking and Python except for a type

00:15:52,590 --> 00:15:57,510
checker now there are two types of type

00:15:54,570 --> 00:15:59,040
checkers static and dynamic static type

00:15:57,510 --> 00:16:00,930
checkers don't actually run your code

00:15:59,040 --> 00:16:03,210
they look at it at rest when it's not

00:16:00,930 --> 00:16:04,350
being evaluated dynamic checkers however

00:16:03,210 --> 00:16:06,029
would check types of while your

00:16:04,350 --> 00:16:07,770
application is actually running so at

00:16:06,029 --> 00:16:10,050
this point my PI had transitioned from

00:16:07,770 --> 00:16:11,730
being a Python variant to just a type

00:16:10,050 --> 00:16:13,740
checker and it was available on PI bi

00:16:11,730 --> 00:16:15,930
you could just pip install it so you

00:16:13,740 --> 00:16:18,210
could pip install my PI you could write

00:16:15,930 --> 00:16:19,620
some type annotated function and you

00:16:18,210 --> 00:16:22,890
would run it and my PI would tell you if

00:16:19,620 --> 00:16:24,330
you are using your types incorrectly so

00:16:22,890 --> 00:16:26,670
there are actually a bunch of type

00:16:24,330 --> 00:16:28,560
checkers besides my PI at this point

00:16:26,670 --> 00:16:31,140
my PI is mostly owned by Dropbox Google

00:16:28,560 --> 00:16:33,390
has PI type Facebook has PI are

00:16:31,140 --> 00:16:35,190
Microsoft has PI right pycharm actually

00:16:33,390 --> 00:16:37,350
has a type checker built into it and

00:16:35,190 --> 00:16:39,540
really most of these can be integrated

00:16:37,350 --> 00:16:41,580
with your editor so you can sort of mix

00:16:39,540 --> 00:16:43,260
and choose as you'd like there are also

00:16:41,580 --> 00:16:45,330
others that don't support the pet 44

00:16:43,260 --> 00:16:47,430
spec and also a bunch of dynamic type

00:16:45,330 --> 00:16:49,380
checkers that run at runtime so

00:16:47,430 --> 00:16:51,030
disclaimer I work at Google and the

00:16:49,380 --> 00:16:53,640
inevitable question that I get here is

00:16:51,030 --> 00:16:54,630
if they all support pet 484 what's the

00:16:53,640 --> 00:16:56,790
difference between them why would I

00:16:54,630 --> 00:16:58,650
choose one over the other so I've mostly

00:16:56,790 --> 00:17:00,530
used my PI and PI type so let's talk

00:16:58,650 --> 00:17:02,910
about the differences between those two

00:17:00,530 --> 00:17:05,010
the differences between my PI and PI

00:17:02,910 --> 00:17:07,079
type come down to sort of two areas one

00:17:05,010 --> 00:17:08,699
is cross function inference and the

00:17:07,079 --> 00:17:11,040
other is runtime lenient and I'll talk

00:17:08,699 --> 00:17:12,689
about these in a little more detail so

00:17:11,040 --> 00:17:14,339
this is what I'm talking about with a

00:17:12,689 --> 00:17:16,199
cross function inference here we have a

00:17:14,339 --> 00:17:17,850
function G and when we call that

00:17:16,199 --> 00:17:20,610
function it's calling another function f

00:17:17,850 --> 00:17:22,020
now if we try to run this example we'll

00:17:20,610 --> 00:17:24,660
get a type error because we're trying to

00:17:22,020 --> 00:17:26,579
combine a string and an integer if we

00:17:24,660 --> 00:17:28,230
run this with my PI it doesn't produce

00:17:26,579 --> 00:17:30,210
an error and the reason is because my

00:17:28,230 --> 00:17:31,860
pike doesn't have the ability to infer

00:17:30,210 --> 00:17:33,750
types across multiple function calls

00:17:31,860 --> 00:17:35,970
like this whereas if we run this with PI

00:17:33,750 --> 00:17:37,080
type we'll get the error that we expect

00:17:35,970 --> 00:17:38,480
and we'll see that this is going to

00:17:37,080 --> 00:17:40,830
produce a runtime error

00:17:38,480 --> 00:17:42,240
the other difference runtime lenience

00:17:40,830 --> 00:17:44,910
sort of comes down to a difference in

00:17:42,240 --> 00:17:46,560
velocity between these two tools so pi

00:17:44,910 --> 00:17:48,420
type is going to allow any operation

00:17:46,560 --> 00:17:51,510
that will succeed at runtime and doesn't

00:17:48,420 --> 00:17:53,150
contradict any existing annotations so

00:17:51,510 --> 00:17:54,770
here we have a function f the

00:17:53,150 --> 00:17:56,809
Annotated is returning a list of strings

00:17:54,770 --> 00:17:58,730
and in that function we create a list

00:17:56,809 --> 00:18:00,350
that contains a string we add an integer

00:17:58,730 --> 00:18:02,390
to it which would be sort of like mixing

00:18:00,350 --> 00:18:04,580
types but then we do return a list of

00:18:02,390 --> 00:18:05,330
strings if we run this we get the answer

00:18:04,580 --> 00:18:07,130
to expect

00:18:05,330 --> 00:18:09,620
there's no runtime type error we get

00:18:07,130 --> 00:18:11,600
Python 2020 if we were honest with Pi

00:18:09,620 --> 00:18:12,980
type it says that there's no errors this

00:18:11,600 --> 00:18:15,470
isn't going to produce a type error at

00:18:12,980 --> 00:18:17,600
runtime but if we run this with my PI it

00:18:15,470 --> 00:18:19,040
says that we're trying to append an

00:18:17,600 --> 00:18:22,940
integer to a list that's supposed to

00:18:19,040 --> 00:18:24,800
have types of strings and this fails so

00:18:22,940 --> 00:18:27,290
you might be saying why though when and

00:18:24,800 --> 00:18:28,670
why should I use static typing and first

00:18:27,290 --> 00:18:30,770
I'll say when you shouldn't use static

00:18:28,670 --> 00:18:32,570
typing and the answer is basically never

00:18:30,770 --> 00:18:34,640
you should use static typing liberally

00:18:32,570 --> 00:18:36,830
as much as possible it's never really

00:18:34,640 --> 00:18:39,080
gonna hurt one thing I will say is that

00:18:36,830 --> 00:18:40,850
sag typing is not a replacement for unit

00:18:39,080 --> 00:18:42,620
tests and there is a bit of an argument

00:18:40,850 --> 00:18:44,000
here because sometimes when you look at

00:18:42,620 --> 00:18:45,260
unit tests they kind of just look like

00:18:44,000 --> 00:18:48,920
you're just testing the input and output

00:18:45,260 --> 00:18:50,360
types of your function but really unit

00:18:48,920 --> 00:18:52,040
tests are kind of bad replacement for

00:18:50,360 --> 00:18:53,720
our type system and in reality you

00:18:52,040 --> 00:18:56,300
probably actually just need both unit

00:18:53,720 --> 00:18:58,309
tests and static typing so when should

00:18:56,300 --> 00:18:59,059
you use static typing basically as much

00:18:58,309 --> 00:19:00,890
as possible

00:18:59,059 --> 00:19:03,470
you should use static typing when you're

00:19:00,890 --> 00:19:04,910
millions lines of scale so if your

00:19:03,470 --> 00:19:06,260
Dropbox Google Facebook you've probably

00:19:04,910 --> 00:19:07,970
already invested a lot of money in

00:19:06,260 --> 00:19:09,530
static typing because it's the lack of

00:19:07,970 --> 00:19:11,240
static typing like I said before is a

00:19:09,530 --> 00:19:13,610
serious liability for Python the scale

00:19:11,240 --> 00:19:15,500
yuccas said at Dropbox is scale which

00:19:13,610 --> 00:19:17,210
had millions of lines of Python the

00:19:15,500 --> 00:19:18,890
dynamic typing and python made code

00:19:17,210 --> 00:19:20,950
needlessly hard to understand and

00:19:18,890 --> 00:19:23,450
started to seriously impact productivity

00:19:20,950 --> 00:19:26,000
so I made a little graph for you here as

00:19:23,450 --> 00:19:28,490
the lines of code in your codebase

00:19:26,000 --> 00:19:30,320
increase your desired annotations is

00:19:28,490 --> 00:19:31,850
also going to increase but the ease of

00:19:30,320 --> 00:19:35,660
adding type annotations is going to go

00:19:31,850 --> 00:19:37,910
down so you're probably here this is

00:19:35,660 --> 00:19:38,960
kind of where you should migrate this is

00:19:37,910 --> 00:19:41,150
probably actually where you're gonna

00:19:38,960 --> 00:19:42,620
migrate so keep that in mind you should

00:19:41,150 --> 00:19:44,450
use static typing when your code is

00:19:42,620 --> 00:19:46,400
confusing so let's be honest we've all

00:19:44,450 --> 00:19:48,170
written confusing code you can kind of

00:19:46,400 --> 00:19:50,090
think of annotations as machine verified

00:19:48,170 --> 00:19:51,950
documentation so if you feel the need to

00:19:50,090 --> 00:19:53,330
document the input and the output of a

00:19:51,950 --> 00:19:56,120
function that you're writing you should

00:19:53,330 --> 00:19:57,320
probably just be statically typed you

00:19:56,120 --> 00:19:59,150
should also use static typing when your

00:19:57,320 --> 00:20:01,700
code is for public consumption for

00:19:59,150 --> 00:20:03,290
example if it's a module on pi PI adding

00:20:01,700 --> 00:20:05,750
type annotations helps developers know

00:20:03,290 --> 00:20:06,260
how to use your API and helps IDs know

00:20:05,750 --> 00:20:08,570
how to

00:20:06,260 --> 00:20:10,160
soon your ApS also if your users are

00:20:08,570 --> 00:20:12,050
already using static typing they will

00:20:10,160 --> 00:20:13,940
love you for it you should use static

00:20:12,050 --> 00:20:16,370
typing before migrating or doing a big

00:20:13,940 --> 00:20:17,870
refactor basically add static types to

00:20:16,370 --> 00:20:20,180
all the mission critical parts of your

00:20:17,870 --> 00:20:21,710
application and then go and do your

00:20:20,180 --> 00:20:23,240
migration refactor and see if any of

00:20:21,710 --> 00:20:25,070
your type annotations start to fail

00:20:23,240 --> 00:20:27,320
that'd be a place where you probably

00:20:25,070 --> 00:20:29,150
find some bugs you can also use static

00:20:27,320 --> 00:20:31,790
typing to just experiment with static

00:20:29,150 --> 00:20:33,890
typing it doesn't hurt start with some

00:20:31,790 --> 00:20:34,940
small dusty corner your code base or

00:20:33,890 --> 00:20:37,940
start with the most mission-critical

00:20:34,940 --> 00:20:39,650
part of your entire application add a

00:20:37,940 --> 00:20:42,050
little bit static typing add a static

00:20:39,650 --> 00:20:43,880
type trigger and see what happens so how

00:20:42,050 --> 00:20:46,370
do use static typing in Python in just

00:20:43,880 --> 00:20:47,930
five easy steps step one migrate to a

00:20:46,370 --> 00:20:50,330
Python greater than equal to three point

00:20:47,930 --> 00:20:52,460
six this is optional you can do type

00:20:50,330 --> 00:20:53,630
comments in any version of Python but

00:20:52,460 --> 00:20:56,780
you should probably migrate anyways

00:20:53,630 --> 00:20:58,220
let's be honest step two install a type

00:20:56,780 --> 00:20:59,960
checker locally and integrate it into

00:20:58,220 --> 00:21:01,490
your editor I don't care which one and

00:20:59,960 --> 00:21:03,800
you can even install more than life if

00:21:01,490 --> 00:21:05,810
you really wanted to step three start

00:21:03,800 --> 00:21:07,220
optionally typing your code base start

00:21:05,810 --> 00:21:09,290
with your hairiest files ordered the

00:21:07,220 --> 00:21:10,820
easiest to type files don't try to do it

00:21:09,290 --> 00:21:12,920
all at once and remember it's gradual

00:21:10,820 --> 00:21:15,200
for a reason pick critical areas and

00:21:12,920 --> 00:21:17,300
then start there for run type checker

00:21:15,200 --> 00:21:18,830
with your linting and run linting in CI

00:21:17,300 --> 00:21:21,650
which you should probably be doing

00:21:18,830 --> 00:21:23,480
anyways and five convince all your

00:21:21,650 --> 00:21:25,250
co-workers to join you if you need help

00:21:23,480 --> 00:21:27,530
convincing them you can just show them

00:21:25,250 --> 00:21:29,390
this talk on youtube thanks for watching

00:21:27,530 --> 00:21:31,850
you can follow me on twitter at di

00:21:29,390 --> 00:21:34,430
underscore codes i also want to give a

00:21:31,850 --> 00:21:35,330
huge thank you to the PyCon staff for

00:21:34,430 --> 00:21:36,410
everything they've dealt with and

00:21:35,330 --> 00:21:38,540
everything they've done to bring this

00:21:36,410 --> 00:21:40,310
conference online they absolutely

00:21:38,540 --> 00:21:42,050
deserve your thanks as well so be sure

00:21:40,310 --> 00:21:44,180
to let them know you appreciate all the

00:21:42,050 --> 00:21:46,450
hard work that they're doing see you

00:21:44,180 --> 00:21:46,450

YouTube URL: https://www.youtube.com/watch?v=ST33zDM9vOE


