Title: Talk: Reuven M. Lerner - Function dissection lab -- learn how functions
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Reuven M. Lerner

When you invoke a function, how does it know how many arguments to expect? How does it distinguish between local and global (and enclosing) variables? How does it know that you defined the function with args and/or *kwargs? And where does it store such things as docstrings, annotations, and defaults?

The short answer is that Python functions are objects – no different from integers, strings, and dicts. And like all other bjects,
functions have attributes. It turns out that those attributes are the source of functions’ power.

In this talk, we’ll peek into function attributes, gaining an understanding of (and appreciation for) the way in which functions are built. We’ll also see the relationship between attributes, functions, and Python bytecodes. And while we’ll be dissecting many functions, I can assure you that none of them will be harmed in our quest for deeper understanding.




Talk resources: http://FunctionDissectionLab.com
Captions: 
	00:00:11,900 --> 00:00:17,490
hi I'm Ruben Lerner welcome to my PI con

00:00:15,450 --> 00:00:19,710
talk function dissection lab where we

00:00:17,490 --> 00:00:21,750
are going to learn about functions by

00:00:19,710 --> 00:00:25,079
taking them apart few words about myself

00:00:21,750 --> 00:00:27,000
I am a full time Python trainer most

00:00:25,079 --> 00:00:29,130
days I am in a different city different

00:00:27,000 --> 00:00:30,990
country different company teaching

00:00:29,130 --> 00:00:32,279
Python everything from Python for

00:00:30,990 --> 00:00:34,920
non-programmers all the way up to

00:00:32,279 --> 00:00:36,540
advanced Python workshops lately I have

00:00:34,920 --> 00:00:38,489
not been traveling so much but I'm still

00:00:36,540 --> 00:00:40,650
doing lots of training via WebEx and

00:00:38,489 --> 00:00:43,050
zoom I also have a bunch of courses on

00:00:40,650 --> 00:00:45,629
my site about Python data science and

00:00:43,050 --> 00:00:47,460
get including weekly Python exercise a

00:00:45,629 --> 00:00:49,800
family of courses to level up your

00:00:47,460 --> 00:00:52,379
Python skills I also just published a

00:00:49,800 --> 00:00:54,719
book called Python workout with 50

00:00:52,379 --> 00:00:56,309
Python exercises with Manning and my

00:00:54,719 --> 00:00:59,399
better developers list goes out to about

00:00:56,309 --> 00:01:01,519
15,000 developers every week with python

00:00:59,399 --> 00:01:04,769
tips and hints but enough about me let's

00:01:01,519 --> 00:01:07,470
write some code and then we will take it

00:01:04,769 --> 00:01:11,759
apart so let's consider this code I've

00:01:07,470 --> 00:01:14,580
got x equals 10 20 30 so i'm defining a

00:01:11,759 --> 00:01:16,319
list and then d equals a 1 B 2 C 3 so

00:01:14,580 --> 00:01:18,030
I'm defining a dict and then I'm also

00:01:16,319 --> 00:01:21,539
going to define a function hello name

00:01:18,030 --> 00:01:23,670
return hello name and we look at this

00:01:21,539 --> 00:01:25,830
and we figure ok I'm defining two

00:01:23,670 --> 00:01:27,810
variables and I'm defining a function

00:01:25,830 --> 00:01:29,399
but Python thinks about it very

00:01:27,810 --> 00:01:31,590
differently Python actually sees these

00:01:29,399 --> 00:01:33,509
as roughly equivalent and we can see

00:01:31,590 --> 00:01:36,030
that most easily with a Python tutor

00:01:33,509 --> 00:01:38,789
site that Philip Ava's written and so we

00:01:36,030 --> 00:01:41,729
see here 3 global variables X refers to

00:01:38,789 --> 00:01:44,789
the list 10 20 30 D refers to the

00:01:41,729 --> 00:01:48,209
dictionary a 1 B 2 C 3 and hello refers

00:01:44,789 --> 00:01:49,739
to the function object hello and if

00:01:48,209 --> 00:01:50,190
function object sounds a little funny to

00:01:49,739 --> 00:01:52,020
you

00:01:50,190 --> 00:01:53,759
yeah function objects are kind of weird

00:01:52,020 --> 00:01:56,369
because they make us think about

00:01:53,759 --> 00:01:58,739
functions as not just verbs that we can

00:01:56,369 --> 00:02:02,250
execute and run but also as nouns that

00:01:58,739 --> 00:02:03,690
we can use so when you use def to create

00:02:02,250 --> 00:02:04,950
a function you're actually doing two

00:02:03,690 --> 00:02:06,840
separate things you're creating a

00:02:04,950 --> 00:02:09,629
function object and then you're

00:02:06,840 --> 00:02:11,489
assigning it to a variable so what's the

00:02:09,629 --> 00:02:12,959
advantage of knowing about and thinking

00:02:11,489 --> 00:02:14,580
about function objects actually there's

00:02:12,959 --> 00:02:16,319
quite a bit once we start thinking about

00:02:14,580 --> 00:02:19,050
functions as objects we can remember

00:02:16,319 --> 00:02:21,390
that functions like all objects can be

00:02:19,050 --> 00:02:23,060
assigned to other names so if I already

00:02:21,390 --> 00:02:25,610
have my hello function I

00:02:23,060 --> 00:02:28,099
also say hello to equals hello and now

00:02:25,610 --> 00:02:31,209
both of these variables hello and hello

00:02:28,099 --> 00:02:34,580
to refer to exactly the same function

00:02:31,209 --> 00:02:37,069
okay but I can also pass a function as

00:02:34,580 --> 00:02:39,200
an argument to another function or to a

00:02:37,069 --> 00:02:40,599
method or to an object constructor this

00:02:39,200 --> 00:02:43,580
is a fun line I can say hello

00:02:40,599 --> 00:02:46,250
parenthesis hello and in this example I

00:02:43,580 --> 00:02:48,830
am executing the hello function I'm

00:02:46,250 --> 00:02:51,410
using as a verb but I'm also passing it

00:02:48,830 --> 00:02:54,080
hello the same function as a noun to

00:02:51,410 --> 00:02:55,459
itself so we can pass functions as

00:02:54,080 --> 00:02:58,730
arguments it's not a problem something

00:02:55,459 --> 00:03:00,980
we do all the time I can also remember

00:02:58,730 --> 00:03:03,950
that all objects in Python have

00:03:00,980 --> 00:03:06,019
attributes attributes are these like

00:03:03,950 --> 00:03:08,900
private dictionaries that every object

00:03:06,019 --> 00:03:11,299
has so if you have a dot b b is an

00:03:08,900 --> 00:03:13,970
attribute belonging to a it's not a

00:03:11,299 --> 00:03:16,430
local variable we use them all the time

00:03:13,970 --> 00:03:18,349
and an attribute can contain any kind of

00:03:16,430 --> 00:03:19,760
object and indeed we're gonna see they

00:03:18,349 --> 00:03:21,739
contain lots of interesting objects in

00:03:19,760 --> 00:03:23,660
just a little bit we can get a list of

00:03:21,739 --> 00:03:26,120
all the attributes on an object with

00:03:23,660 --> 00:03:27,680
Derr Derr of hello will then return all

00:03:26,120 --> 00:03:29,630
the attributes on our function object

00:03:27,680 --> 00:03:32,030
okay that's nice and interesting at all

00:03:29,630 --> 00:03:34,130
but how does Python use of functions

00:03:32,030 --> 00:03:36,290
attributes well let's define a function

00:03:34,130 --> 00:03:38,720
again deaf alone a return f string hello

00:03:36,290 --> 00:03:41,480
name and let's now run it so if I call

00:03:38,720 --> 00:03:43,370
hello with world as an attribute as an

00:03:41,480 --> 00:03:46,430
argument what happens when we get back

00:03:43,370 --> 00:03:48,799
the string hello world so far so good

00:03:46,430 --> 00:03:51,980
what happens if I call the function with

00:03:48,799 --> 00:03:54,590
no arguments hello parentheses well then

00:03:51,980 --> 00:03:56,989
we get an error and the error says that

00:03:54,590 --> 00:04:00,380
hello is missing one required positional

00:03:56,989 --> 00:04:03,410
argument name and my question is how do

00:04:00,380 --> 00:04:05,299
Python know how did it know that we were

00:04:03,410 --> 00:04:07,100
missing one positional argument how did

00:04:05,299 --> 00:04:09,440
it know that that positional argument is

00:04:07,100 --> 00:04:12,109
called name and the answer is attributes

00:04:09,440 --> 00:04:14,720
the most important attribute on a

00:04:12,109 --> 00:04:16,880
function object is dunder code under

00:04:14,720 --> 00:04:19,250
under code under under this is sort of

00:04:16,880 --> 00:04:21,680
the heart the soul the brains wherever

00:04:19,250 --> 00:04:24,500
you wish to describe it of a function

00:04:21,680 --> 00:04:26,720
object it contains the byte codes and

00:04:24,500 --> 00:04:28,100
all sorts of hints to the interpreter

00:04:26,720 --> 00:04:29,450
about our function now if you're not

00:04:28,100 --> 00:04:31,159
sure what byte codes are remember that

00:04:29,450 --> 00:04:34,070
python is not an interpreted language

00:04:31,159 --> 00:04:36,200
when we define a function the function

00:04:34,070 --> 00:04:36,900
is actually compiled into an

00:04:36,200 --> 00:04:39,450
intermediate

00:04:36,900 --> 00:04:40,800
bytecodes those are stored inside the

00:04:39,450 --> 00:04:43,020
function object and when we run a

00:04:40,800 --> 00:04:45,480
function the functions byte codes are

00:04:43,020 --> 00:04:48,060
used to execute it and we'll talk more

00:04:45,480 --> 00:04:50,370
about the byte codes in a little bit so

00:04:48,060 --> 00:04:53,370
how does Python know how many arguments

00:04:50,370 --> 00:04:55,290
our function takes well the code object

00:04:53,370 --> 00:04:57,330
under code has its own attributes

00:04:55,290 --> 00:05:00,090
because it's an object in all objects in

00:04:57,330 --> 00:05:02,310
Python have attributes and so cor count

00:05:00,090 --> 00:05:04,650
is always in ticketed going to contain

00:05:02,310 --> 00:05:06,270
an integer indicating how many arguments

00:05:04,650 --> 00:05:09,570
the function takes

00:05:06,270 --> 00:05:11,700
so hello dunder code CLR count shows us

00:05:09,570 --> 00:05:14,400
one that's right the function takes one

00:05:11,700 --> 00:05:16,530
argument and so when we run the function

00:05:14,400 --> 00:05:19,170
when we run hello world Python says okay

00:05:16,530 --> 00:05:22,890
CLR count says we need one argument the

00:05:19,170 --> 00:05:24,690
user passed one argument all is good but

00:05:22,890 --> 00:05:27,930
what about when we call the function

00:05:24,690 --> 00:05:30,150
with zero arguments what's gonna happen

00:05:27,930 --> 00:05:32,130
well Python is gonna say cor count says

00:05:30,150 --> 00:05:34,950
we need one argument we didn't pass any

00:05:32,130 --> 00:05:38,970
arguments error that's why we get the

00:05:34,950 --> 00:05:42,630
error now what about this name how does

00:05:38,970 --> 00:05:44,220
Python know that our argument was

00:05:42,630 --> 00:05:46,170
supposed to be assigned to the parameter

00:05:44,220 --> 00:05:48,570
name well you won't be surprised to hear

00:05:46,170 --> 00:05:49,560
that there is another attribute involved

00:05:48,570 --> 00:05:51,900
we're gonna be talking about lots of

00:05:49,560 --> 00:05:54,480
attributes here and that attribute is C

00:05:51,900 --> 00:05:56,820
of our names parameters are local

00:05:54,480 --> 00:05:58,800
variables they're not defined inside of

00:05:56,820 --> 00:06:00,210
the function body but they are still

00:05:58,800 --> 00:06:02,010
defined they are still local variables

00:06:00,210 --> 00:06:04,950
and CFR names is always going to be a

00:06:02,010 --> 00:06:07,020
tuple of strings each string being the

00:06:04,950 --> 00:06:08,850
name of one of the local variables so if

00:06:07,020 --> 00:06:10,710
we look here at CEO of our names we're

00:06:08,850 --> 00:06:14,040
gonna see that it's a tuple with one

00:06:10,710 --> 00:06:16,020
element one string name so Python now

00:06:14,040 --> 00:06:18,630
knows that the function requires one

00:06:16,020 --> 00:06:22,620
argument they require and that argument

00:06:18,630 --> 00:06:25,380
is going to be assigned to name and if

00:06:22,620 --> 00:06:28,320
we get no arguments the name is missing

00:06:25,380 --> 00:06:30,810
a value and sure enough when we run

00:06:28,320 --> 00:06:33,000
hello without any arguments we get the

00:06:30,810 --> 00:06:35,750
error message hello is missing one

00:06:33,000 --> 00:06:38,570
required positional argument called name

00:06:35,750 --> 00:06:41,040
what if I function has two parameters

00:06:38,570 --> 00:06:42,780
def low first and last return hello

00:06:41,040 --> 00:06:45,540
first and last well we look at our

00:06:42,780 --> 00:06:47,250
account it's going to be two and we look

00:06:45,540 --> 00:06:49,060
at C of our names it's going to be first

00:06:47,250 --> 00:06:51,460
and last and so

00:06:49,060 --> 00:06:53,350
messages use this information we see it

00:06:51,460 --> 00:06:55,720
all the time if I call hello now with

00:06:53,350 --> 00:06:57,640
this to argument version hello with

00:06:55,720 --> 00:06:59,320
Ruben I'm gonna get the error message

00:06:57,640 --> 00:07:01,270
saying no no hello is still missing one

00:06:59,320 --> 00:07:04,270
required positional argument called last

00:07:01,270 --> 00:07:06,130
and what if I call I try to be a smart

00:07:04,270 --> 00:07:07,690
aleck about it right and I don't just

00:07:06,130 --> 00:07:08,680
pass a positional argue I pass it as a

00:07:07,690 --> 00:07:10,660
keyword argument

00:07:08,680 --> 00:07:12,460
hello last equals learner well it's

00:07:10,660 --> 00:07:14,470
gonna say no no you're still missing one

00:07:12,460 --> 00:07:16,990
positional argument called first and

00:07:14,470 --> 00:07:20,170
what if I try calling the function with

00:07:16,990 --> 00:07:21,610
ABC three different arguments because

00:07:20,170 --> 00:07:23,350
they know no you can't do that because

00:07:21,610 --> 00:07:26,110
hello takes two positional arguments and

00:07:23,350 --> 00:07:28,510
you provided three by the way what if I

00:07:26,110 --> 00:07:30,130
define a local variable as well so let's

00:07:28,510 --> 00:07:31,660
just change our function a little bit so

00:07:30,130 --> 00:07:33,370
now instead of returning the string

00:07:31,660 --> 00:07:36,220
right away we've signed it to a local

00:07:33,370 --> 00:07:37,900
variable s well I look at art count Co

00:07:36,220 --> 00:07:40,090
art count it's gonna show me that CLR

00:07:37,900 --> 00:07:42,940
count is still gonna be two we're still

00:07:40,090 --> 00:07:45,490
only taking two arguments but VAR names

00:07:42,940 --> 00:07:49,270
now contains three elements first and

00:07:45,490 --> 00:07:52,090
last and s so the parameters to a

00:07:49,270 --> 00:07:56,020
function are always going to be the

00:07:52,090 --> 00:07:59,550
first few elements of C of our names how

00:07:56,020 --> 00:08:01,690
few whatever it says in Co art count

00:07:59,550 --> 00:08:02,680
yeah but we have some other kinds of

00:08:01,690 --> 00:08:04,420
parameters that we haven't really

00:08:02,680 --> 00:08:08,020
described with this system for example

00:08:04,420 --> 00:08:09,610
what about splat barks splat args as you

00:08:08,020 --> 00:08:11,920
might know takes any additional

00:08:09,610 --> 00:08:14,140
positional arguments that no one else

00:08:11,920 --> 00:08:16,420
wanted so here if I define hello

00:08:14,140 --> 00:08:18,550
first last splat args it's always gonna

00:08:16,420 --> 00:08:21,370
be a tuple and so here if I call hello

00:08:18,550 --> 00:08:22,990
of ABCDE a is gonna be assigned at first

00:08:21,370 --> 00:08:24,550
B is gonna be assigned to last and all

00:08:22,990 --> 00:08:26,740
the rest of them are gonna be assigned

00:08:24,550 --> 00:08:28,840
as a tuple to arms that's really

00:08:26,740 --> 00:08:30,210
convenient and so if I look now at CL

00:08:28,840 --> 00:08:34,750
aren't count what am I gonna see

00:08:30,210 --> 00:08:37,120
actually - it doesn't see args as a

00:08:34,750 --> 00:08:39,250
regular parameter but if we look at CL

00:08:37,120 --> 00:08:40,990
our names so our X is a variable it is a

00:08:39,250 --> 00:08:43,120
local variable it's just not as part of

00:08:40,990 --> 00:08:46,210
the argument count so what's going on

00:08:43,120 --> 00:08:47,200
how does Python actually know that it's

00:08:46,210 --> 00:08:49,120
supposed to be doing this sort of

00:08:47,200 --> 00:08:52,210
assignment well here we have a little

00:08:49,120 --> 00:08:53,860
bit of magic so there is a variable

00:08:52,210 --> 00:08:57,310
called or I should say an attribute

00:08:53,860 --> 00:08:59,230
called Co flags and Co flags is an

00:08:57,310 --> 00:09:01,150
integer but it's not just any integer

00:08:59,230 --> 00:09:01,880
it's an integer that we treat as a set

00:09:01,150 --> 00:09:04,130
of

00:09:01,880 --> 00:09:06,860
feels so if you imagine it to be a

00:09:04,130 --> 00:09:08,720
binary number each of the bits each of

00:09:06,860 --> 00:09:10,730
the binary digits can be either 1 or 0

00:09:08,720 --> 00:09:14,780
and it indicates whether something is

00:09:10,730 --> 00:09:16,700
true or false on or off so for example

00:09:14,780 --> 00:09:18,800
two of these are always going to be on

00:09:16,700 --> 00:09:20,060
optimize the new locals these have been

00:09:18,800 --> 00:09:21,650
on for years and years and years in

00:09:20,060 --> 00:09:23,720
Python they indicate something that was

00:09:21,650 --> 00:09:27,320
done a long time ago but then we have

00:09:23,720 --> 00:09:31,520
splat args so if the third bit from the

00:09:27,320 --> 00:09:33,230
right there is one then the function has

00:09:31,520 --> 00:09:35,270
flat args and if it's 0 that doesn't

00:09:33,230 --> 00:09:38,180
have splat arcs similarly if the fourth

00:09:35,270 --> 00:09:40,310
bit from the right is set on then the

00:09:38,180 --> 00:09:43,130
function takes keyword arguments kW args

00:09:40,310 --> 00:09:44,750
and if not then not nested functions if

00:09:43,130 --> 00:09:47,000
I define a function inside of another

00:09:44,750 --> 00:09:48,590
function then this nested function is

00:09:47,000 --> 00:09:50,480
going to be that that is going to be

00:09:48,590 --> 00:09:52,100
turned on and finally if you've ever

00:09:50,480 --> 00:09:53,900
wondered how Python can tell the

00:09:52,100 --> 00:09:56,180
difference between a regular function

00:09:53,900 --> 00:09:57,560
and a generator function how does it

00:09:56,180 --> 00:10:00,800
know whether it should execute the

00:09:57,560 --> 00:10:02,810
function or return a generator there's a

00:10:00,800 --> 00:10:04,610
generator bit there if that's on then

00:10:02,810 --> 00:10:07,160
it's a generator function so we can

00:10:04,610 --> 00:10:08,900
think of these as bits here it's way

00:10:07,160 --> 00:10:11,240
easier in many ways to think about in

00:10:08,900 --> 00:10:14,090
hex so I can just think of these numbers

00:10:11,240 --> 00:10:16,130
in this way X 1 X 2 X 4 X 8 and then if

00:10:14,090 --> 00:10:18,500
I want to find out if a particular bit

00:10:16,130 --> 00:10:22,040
field has been set I just use bitwise

00:10:18,500 --> 00:10:24,800
and and compare so if I want to know hey

00:10:22,040 --> 00:10:29,660
does hello take splat args I'm gonna

00:10:24,800 --> 00:10:31,910
take Co flags use bitwise and with hex 0

00:10:29,660 --> 00:10:33,590
for sure enough I get back the same

00:10:31,910 --> 00:10:36,890
value hex here for that means that the

00:10:33,590 --> 00:10:39,200
bit was set by contrast if I check hey

00:10:36,890 --> 00:10:39,920
was KW arg set do we take doubles black

00:10:39,200 --> 00:10:42,680
KW argh

00:10:39,920 --> 00:10:44,480
the answer is no we get zero back what

00:10:42,680 --> 00:10:46,880
if I flip it around what if I redefine

00:10:44,480 --> 00:10:49,580
hello so that it does take doubles black

00:10:46,880 --> 00:10:51,230
kW args but does not take splat argh so

00:10:49,580 --> 00:10:52,790
now I'm gonna check hey does it take

00:10:51,230 --> 00:10:56,840
splat args I'm gonna do this sort of

00:10:52,790 --> 00:10:59,770
bitwise and nope not there but what if I

00:10:56,840 --> 00:11:03,260
check hex 0 8 sure enough it is there

00:10:59,770 --> 00:11:06,170
now this is a really annoying dirty

00:11:03,260 --> 00:11:08,900
gross way to look at these bit flags

00:11:06,170 --> 00:11:11,480
there is a better way and that is to use

00:11:08,900 --> 00:11:13,190
the dis module that comes with a Python

00:11:11,480 --> 00:11:14,780
standard library and disk 4 like

00:11:13,190 --> 00:11:15,980
disassemble has all sorts of functions

00:11:14,780 --> 00:11:18,260
that make it easy

00:11:15,980 --> 00:11:20,480
sort of peek into the byte codes of your

00:11:18,260 --> 00:11:23,900
function object and so if I use dis stop

00:11:20,480 --> 00:11:25,550
show code we're gonna see that the hello

00:11:23,900 --> 00:11:26,720
function has all sorts of interesting

00:11:25,550 --> 00:11:28,490
information we're not gonna look at all

00:11:26,720 --> 00:11:30,140
of it right now but among other things

00:11:28,490 --> 00:11:31,730
that shows us the flags and it says here

00:11:30,140 --> 00:11:34,370
optimize new locals that they're always

00:11:31,730 --> 00:11:36,260
gonna be set var keywords that is

00:11:34,370 --> 00:11:38,840
pythons internal way of talking about

00:11:36,260 --> 00:11:42,020
splat args our function takes I'm sorry

00:11:38,840 --> 00:11:44,480
double select kW ARBs for keywords kW RS

00:11:42,020 --> 00:11:46,670
right and no free for whatever reason it

00:11:44,480 --> 00:11:48,890
indicates this that were not in a nested

00:11:46,670 --> 00:11:50,060
function okay fine there's also

00:11:48,890 --> 00:11:53,060
something kind of weird here called

00:11:50,060 --> 00:11:54,410
constants and what are the constants the

00:11:53,060 --> 00:11:56,630
constants are when you write your

00:11:54,410 --> 00:11:59,390
functions translate into byte code any

00:11:56,630 --> 00:12:00,740
of the literal strings or integers or

00:11:59,390 --> 00:12:02,750
other objects that are there are not

00:12:00,740 --> 00:12:04,880
actually stored along with the byte code

00:12:02,750 --> 00:12:06,380
they're stored separately in constants

00:12:04,880 --> 00:12:08,540
and then in the byte code they're

00:12:06,380 --> 00:12:11,090
referred to constant one constant two

00:12:08,540 --> 00:12:14,480
constant three these are always stored

00:12:11,090 --> 00:12:16,400
in Co costs that's always going to be

00:12:14,480 --> 00:12:19,130
another attribute on our function object

00:12:16,400 --> 00:12:21,500
now the zeroeth element the item at

00:12:19,130 --> 00:12:22,760
index 0 in the CL Const is always going

00:12:21,500 --> 00:12:25,130
to be none which means that none is

00:12:22,760 --> 00:12:26,360
always available to every function you

00:12:25,130 --> 00:12:28,370
don't need to do anything special for

00:12:26,360 --> 00:12:30,200
but everything else is also stored there

00:12:28,370 --> 00:12:32,570
I also find it interesting that F

00:12:30,200 --> 00:12:34,430
strings are broken up into parts so

00:12:32,570 --> 00:12:36,470
hello which came before the curly braces

00:12:34,430 --> 00:12:38,330
and exclamation point which came after

00:12:36,470 --> 00:12:40,190
the curly braces are stored a separate

00:12:38,330 --> 00:12:42,860
constants and then the byte codes they

00:12:40,190 --> 00:12:44,720
just refer to by index number so what

00:12:42,860 --> 00:12:48,500
about the byte codes themselves well we

00:12:44,720 --> 00:12:50,210
can look at those in Co code CL code is

00:12:48,500 --> 00:12:51,650
a byte string I guess it's appropriate

00:12:50,210 --> 00:12:52,910
right byte codes and byte strings and

00:12:51,650 --> 00:12:55,340
this is what it looks like for a

00:12:52,910 --> 00:12:59,330
function now if that's not super

00:12:55,340 --> 00:13:02,180
readable to you I understand um so let's

00:12:59,330 --> 00:13:03,920
use this dot dis another function from

00:13:02,180 --> 00:13:06,410
the dis module to look at and this

00:13:03,920 --> 00:13:08,270
breaks apart the byte codes and shows us

00:13:06,410 --> 00:13:11,510
what's going on so it's saying load

00:13:08,270 --> 00:13:14,000
constant load constant 1 it's looking at

00:13:11,510 --> 00:13:18,260
Co cons and retrieving the item at index

00:13:14,000 --> 00:13:20,630
1 load fast load fast means use a local

00:13:18,260 --> 00:13:23,000
variable format value that's a format

00:13:20,630 --> 00:13:24,950
string load cause exclamation point so

00:13:23,000 --> 00:13:26,570
it's piecing together the strength build

00:13:24,950 --> 00:13:28,790
string as we can see and then return

00:13:26,570 --> 00:13:31,350
value so it's going to return the string

00:13:28,790 --> 00:13:33,509
well as you probably know functions can

00:13:31,350 --> 00:13:34,800
have all sorts of additional types of

00:13:33,509 --> 00:13:37,949
parameters for example what about

00:13:34,800 --> 00:13:41,250
defaults so if I say def fellow name

00:13:37,949 --> 00:13:44,190
equals world now my name parameter has a

00:13:41,250 --> 00:13:46,920
default value I don't need to call the

00:13:44,190 --> 00:13:49,139
function with an argument but what is

00:13:46,920 --> 00:13:50,699
happy to Co are count their turns let's

00:13:49,139 --> 00:13:52,889
see how our count remains exactly the

00:13:50,699 --> 00:13:54,329
same so our function looks just like

00:13:52,889 --> 00:13:55,560
before but we know that we can call

00:13:54,329 --> 00:13:57,720
without arguments so how's this going to

00:13:55,560 --> 00:13:59,399
work well there's another attribute and

00:13:57,720 --> 00:14:01,980
this attribute is called dunder defaults

00:13:59,399 --> 00:14:04,259
and it is not under dunder code rather

00:14:01,980 --> 00:14:07,470
it's part of the function object so it's

00:14:04,259 --> 00:14:09,120
worth parallel with undercoat and so all

00:14:07,470 --> 00:14:10,889
of the defaults are there so let's take

00:14:09,120 --> 00:14:13,920
a look what is hello dunder defaults

00:14:10,889 --> 00:14:15,779
look like world meaning the under

00:14:13,920 --> 00:14:17,310
defaults is always going to be a tuple

00:14:15,779 --> 00:14:18,930
if there are no defaults then it's an

00:14:17,310 --> 00:14:21,000
empty to bowl and the tuple containing

00:14:18,930 --> 00:14:23,850
whatever defaults you set in the

00:14:21,000 --> 00:14:26,430
function definition so we can summarize

00:14:23,850 --> 00:14:28,350
this a bit that when Python calls a

00:14:26,430 --> 00:14:29,970
function it compares the arguments the

00:14:28,350 --> 00:14:32,069
number of arguments with seal are count

00:14:29,970 --> 00:14:33,810
and if the number matches great pass the

00:14:32,069 --> 00:14:36,569
arguments call the function all is done

00:14:33,810 --> 00:14:38,010
if they're not enough arguments then we

00:14:36,569 --> 00:14:40,380
check to see if dunder defaults can

00:14:38,010 --> 00:14:42,510
close the gap and if so we're gonna use

00:14:40,380 --> 00:14:45,029
enough values from dunder defaults to

00:14:42,510 --> 00:14:46,649
get to CLR count what if we have too

00:14:45,029 --> 00:14:49,589
many arguments well then we're gonna

00:14:46,649 --> 00:14:51,899
check Co flags and see is splat args

00:14:49,589 --> 00:14:53,100
defined and if so we're just gonna refer

00:14:51,899 --> 00:14:55,980
we're gonna assign the remaining

00:14:53,100 --> 00:14:57,630
arguments to splat arcs or whatever

00:14:55,980 --> 00:15:01,110
variables name didn't see all of our

00:14:57,630 --> 00:15:03,389
names at CL our count let's look at

00:15:01,110 --> 00:15:05,579
something that works a lot of people

00:15:03,389 --> 00:15:08,130
about defaults though so consider this

00:15:05,579 --> 00:15:10,680
function deff add one of X X dot append

00:15:08,130 --> 00:15:13,350
of one so we're gonna define a list here

00:15:10,680 --> 00:15:17,880
my list 10 20 30 and then I'm gonna call

00:15:13,350 --> 00:15:20,880
add one on my list what happens now if I

00:15:17,880 --> 00:15:24,120
print my list I'm gonna get back 10 20

00:15:20,880 --> 00:15:26,579
31 why because I passed the list my list

00:15:24,120 --> 00:15:28,230
to the function the function ran append

00:15:26,579 --> 00:15:31,139
it added one element to the list and

00:15:28,230 --> 00:15:33,060
then great the list has changed and if I

00:15:31,139 --> 00:15:36,089
do this again if I call add one again

00:15:33,060 --> 00:15:37,560
then I'm gonna get here print I'm gonna

00:15:36,089 --> 00:15:39,510
print my list and we're gonna get ten

00:15:37,560 --> 00:15:41,310
twenty thirty one one you

00:15:39,510 --> 00:15:43,470
every time we call the function with my

00:15:41,310 --> 00:15:46,140
list we're gonna add one more one

00:15:43,470 --> 00:15:48,900
integer to the end of it so far so good

00:15:46,140 --> 00:15:51,960
but let's now add a default and this

00:15:48,900 --> 00:15:54,960
default is going to be an empty list and

00:15:51,960 --> 00:15:56,730
the assumption is then many people have

00:15:54,960 --> 00:15:59,820
this assumption that now if I call the

00:15:56,730 --> 00:16:02,430
function add one with no arguments we'll

00:15:59,820 --> 00:16:05,010
get an empty list assigned to X and then

00:16:02,430 --> 00:16:06,240
the value we get back is one so far so

00:16:05,010 --> 00:16:09,150
good let's do it again

00:16:06,240 --> 00:16:12,980
print add one value we get back is 1 1

00:16:09,150 --> 00:16:17,010
if we do it again the value is 1 1 1

00:16:12,980 --> 00:16:19,230
what's going on so many many people

00:16:17,010 --> 00:16:22,050
think that when we define a function

00:16:19,230 --> 00:16:25,770
like this what we are telling Python is

00:16:22,050 --> 00:16:27,960
if we don't pass an argument for X then

00:16:25,770 --> 00:16:30,120
X should be assigned to an empty list

00:16:27,960 --> 00:16:32,130
but that's not how Python thinks about a

00:16:30,120 --> 00:16:34,470
problem thinks of it as if we don't pass

00:16:32,130 --> 00:16:36,960
an argument then it should use this

00:16:34,470 --> 00:16:39,150
empty list that's right it puts this

00:16:36,960 --> 00:16:40,740
empty list into dunder defaults when the

00:16:39,150 --> 00:16:42,480
function is created remembered under

00:16:40,740 --> 00:16:44,910
default is populated when the function

00:16:42,480 --> 00:16:47,010
is created when it's defined and so this

00:16:44,910 --> 00:16:49,620
list is then retrieved each and every

00:16:47,010 --> 00:16:52,020
time that we call the function without

00:16:49,620 --> 00:16:53,610
an argument and it can change maybe

00:16:52,020 --> 00:16:55,530
dunder defaults as a tuple and cannot

00:16:53,610 --> 00:16:59,390
change but the elements within it can

00:16:55,530 --> 00:17:03,180
change so the conclusion is never use

00:16:59,390 --> 00:17:04,949
mutable defaults big bad probably should

00:17:03,180 --> 00:17:07,410
not do it and if you're using any sort

00:17:04,949 --> 00:17:09,570
of modern editor or ID it will warn you

00:17:07,410 --> 00:17:11,640
about this and if you use pile int at

00:17:09,570 --> 00:17:13,020
the command line it will also tell you

00:17:11,640 --> 00:17:15,570
that it'll say hey you have a dangerous

00:17:13,020 --> 00:17:18,570
default value empty list here don't do

00:17:15,570 --> 00:17:20,310
it there's one last kind of argument I

00:17:18,570 --> 00:17:21,930
want to look at and that's keyword only

00:17:20,310 --> 00:17:24,180
arguments and these are relatively new

00:17:21,930 --> 00:17:26,070
in Python and the idea was what if you

00:17:24,180 --> 00:17:28,530
want to have a default value for a

00:17:26,070 --> 00:17:30,660
parameter but you also want to have

00:17:28,530 --> 00:17:32,160
splat args and in earlier versions of

00:17:30,660 --> 00:17:33,990
Python you couldn't do this so we had

00:17:32,160 --> 00:17:37,290
now our keyword only arguments meaning

00:17:33,990 --> 00:17:40,680
set here in our function has a default

00:17:37,290 --> 00:17:43,020
value of space if we don't explicitly

00:17:40,680 --> 00:17:45,060
specify it when we call the function

00:17:43,020 --> 00:17:47,040
hello then it will always have that

00:17:45,060 --> 00:17:49,080
default and sure enough if we call hello

00:17:47,040 --> 00:17:51,270
of ABC its hello of ABC with spaces

00:17:49,080 --> 00:17:53,850
between them if I call hello of ABC with

00:17:51,270 --> 00:17:56,460
set echo asterisk then we'll uh hello

00:17:53,850 --> 00:17:58,980
ABC with stars between them so we're

00:17:56,460 --> 00:18:00,720
just Python keep track of that it's not

00:17:58,980 --> 00:18:03,960
counted with the other arguments CLR

00:18:00,720 --> 00:18:06,030
count is 0 here 0 because flat args is

00:18:03,960 --> 00:18:08,309
not part of cor count and 0 because our

00:18:06,030 --> 00:18:10,289
set is not part of CLR Keung where is it

00:18:08,309 --> 00:18:13,230
it's in a separate attribute altogether

00:18:10,289 --> 00:18:15,630
CEO kW only our account and it shows

00:18:13,230 --> 00:18:17,250
that we have one there so we see them

00:18:15,630 --> 00:18:20,520
that Python is checking in many many

00:18:17,250 --> 00:18:21,510
places for our arguments Co our count it

00:18:20,520 --> 00:18:23,490
checks the number of mandatory

00:18:21,510 --> 00:18:25,230
positional arguments dunder default

00:18:23,490 --> 00:18:27,840
these are extra values that make CLR

00:18:25,230 --> 00:18:30,059
account flexible Co Flags tells us

00:18:27,840 --> 00:18:31,770
should we assign extra positional

00:18:30,059 --> 00:18:33,090
arguments to splat args and should we

00:18:31,770 --> 00:18:35,880
assign extra keyword arguments this

00:18:33,090 --> 00:18:37,799
doubles like KW RS and finally we have

00:18:35,880 --> 00:18:41,730
kW only our count which is the number of

00:18:37,799 --> 00:18:42,990
keyword only arguments ok switching

00:18:41,730 --> 00:18:46,230
topics a little bit let's talk about

00:18:42,990 --> 00:18:47,940
scoping and if I define X equals 100

00:18:46,230 --> 00:18:49,320
global variable and I define this

00:18:47,940 --> 00:18:52,230
function deff func

00:18:49,320 --> 00:18:53,850
print in func x equals x let's call this

00:18:52,230 --> 00:18:56,070
function but first let's print out what

00:18:53,850 --> 00:18:58,140
is the value of x before we call it and

00:18:56,070 --> 00:19:01,200
then we'll call func and then we'll

00:18:58,140 --> 00:19:03,929
print it so when we call the function

00:19:01,200 --> 00:19:08,309
when we call print here we are looking

00:19:03,929 --> 00:19:10,380
for the value of X well X basically

00:19:08,309 --> 00:19:12,539
Python says is X a global variable the

00:19:10,380 --> 00:19:14,270
answer is yes we retrieve the value 100

00:19:12,539 --> 00:19:18,600
we print it out and we get 100 back

00:19:14,270 --> 00:19:21,630
fantastic so we get back on dread but

00:19:18,600 --> 00:19:26,640
when we call our function what happens

00:19:21,630 --> 00:19:28,500
well X now is XL ocol variable and now

00:19:26,640 --> 00:19:30,030
python needs to go through its scoping

00:19:28,500 --> 00:19:34,460
rules and these scoping rules are

00:19:30,030 --> 00:19:38,419
hard-coded in the language l e.g be

00:19:34,460 --> 00:19:41,159
local and closing Global's and built-ins

00:19:38,419 --> 00:19:43,980
python will always always look through

00:19:41,159 --> 00:19:46,289
all of these here and so python is going

00:19:43,980 --> 00:19:48,990
to look and say is x a local variable

00:19:46,289 --> 00:19:50,190
the answer is no so it says ok we don't

00:19:48,990 --> 00:19:52,919
have a function within a function we'll

00:19:50,190 --> 00:19:55,110
ignore that is X a global variable that

00:19:52,919 --> 00:19:56,700
serves yes and as you can see we get 100

00:19:55,110 --> 00:19:58,230
back so far so good

00:19:56,700 --> 00:20:01,770
and then afterwards of course we get 100

00:19:58,230 --> 00:20:05,250
back as well okay but how does Python

00:20:01,770 --> 00:20:07,049
know that X isn't a local variable well

00:20:05,250 --> 00:20:07,559
it checks in the attributes it checks

00:20:07,049 --> 00:20:08,850
and Co

00:20:07,559 --> 00:20:10,799
my name's we've already seen this

00:20:08,850 --> 00:20:13,710
basically Python could just take that

00:20:10,799 --> 00:20:16,080
that X as a string and say he's X the

00:20:13,710 --> 00:20:17,909
string and then CEO of our names and if

00:20:16,080 --> 00:20:20,759
so it's a local variable but if not if

00:20:17,909 --> 00:20:22,080
CEO of our names is empty no so because

00:20:20,759 --> 00:20:24,059
X is not in CEO of our names

00:20:22,080 --> 00:20:25,379
it's not a local variable let's make

00:20:24,059 --> 00:20:28,919
things a little more complex though

00:20:25,379 --> 00:20:32,249
let's say X equals 100 as before but now

00:20:28,919 --> 00:20:34,320
def func x equals 200 and we're going to

00:20:32,249 --> 00:20:38,460
print the value so what's going on here

00:20:34,320 --> 00:20:41,309
well when we compile our function when

00:20:38,460 --> 00:20:43,139
we define our function Python notes to

00:20:41,309 --> 00:20:44,490
itself that X is a local variable sees

00:20:43,139 --> 00:20:47,639
that we have that X equal there and

00:20:44,490 --> 00:20:50,039
notice of AHA X is local and so when we

00:20:47,639 --> 00:20:52,710
run print before x equals x 2 then func

00:20:50,039 --> 00:20:55,139
and then print python is again gonna do

00:20:52,710 --> 00:20:57,600
its le gb so outside of a function it's

00:20:55,139 --> 00:21:00,119
gonna say is this global yes there is a

00:20:57,600 --> 00:21:02,369
global X its value is 100 and then we're

00:21:00,119 --> 00:21:04,559
gonna run func what happens then what

00:21:02,369 --> 00:21:07,200
it's gonna say who this X here is it

00:21:04,559 --> 00:21:09,090
local yes it is it is a local variable

00:21:07,200 --> 00:21:11,519
how does it know because in CEO of our

00:21:09,090 --> 00:21:14,399
names X is listed so it retrieves the

00:21:11,519 --> 00:21:17,009
local X which is 200 and then finally it

00:21:14,399 --> 00:21:18,779
comes back the local variable is gone we

00:21:17,009 --> 00:21:20,700
have just the global and that's fine and

00:21:18,779 --> 00:21:23,669
as we can see here we look at CL VAR

00:21:20,700 --> 00:21:24,419
names sure enough X is defined inside of

00:21:23,669 --> 00:21:27,629
CEO of our names

00:21:24,419 --> 00:21:29,580
that's how Python knows notice CEO of

00:21:27,629 --> 00:21:33,570
our names is populated at compile time

00:21:29,580 --> 00:21:35,369
not at run time so what if we change our

00:21:33,570 --> 00:21:37,139
function a little bit exactly the same

00:21:35,369 --> 00:21:39,119
as before except I'm going to swap these

00:21:37,139 --> 00:21:40,889
two lines first I'm going to print the

00:21:39,119 --> 00:21:43,350
value of X and then I'm going to assign

00:21:40,889 --> 00:21:45,389
to be 200 so here I'm gonna once again

00:21:43,350 --> 00:21:47,669
print func and print and what is the

00:21:45,389 --> 00:21:51,600
output I get well it says before x

00:21:47,669 --> 00:21:54,539
equals 100 and then I get this what is

00:21:51,600 --> 00:21:56,100
going on here unbound local error local

00:21:54,539 --> 00:21:58,820
variable X is referenced before

00:21:56,100 --> 00:22:02,610
assignment what's going on

00:21:58,820 --> 00:22:04,080
well we define our function and Python

00:22:02,610 --> 00:22:05,879
notice when we defined our function that

00:22:04,080 --> 00:22:07,289
we have x equals in the function if

00:22:05,879 --> 00:22:09,600
there's an x equals that means that X

00:22:07,289 --> 00:22:11,460
must be a local variable x equals

00:22:09,600 --> 00:22:14,129
anywhere in the function makes it a

00:22:11,460 --> 00:22:16,379
local variable and so when we run the

00:22:14,129 --> 00:22:19,259
function we get to that first line with

00:22:16,379 --> 00:22:21,210
print Python says is X a local variable

00:22:19,259 --> 00:22:25,610
the answer is yes and was its

00:22:21,210 --> 00:22:27,750
you oh I'm down local air

00:22:25,610 --> 00:22:30,179
binding is a fancy way of saying

00:22:27,750 --> 00:22:32,730
assigning like to assign to a variable

00:22:30,179 --> 00:22:33,929
name and so unbound local basically

00:22:32,730 --> 00:22:36,210
means you have a local variable without

00:22:33,929 --> 00:22:37,500
a value and this is weird because in

00:22:36,210 --> 00:22:40,799
Python we're not used to having

00:22:37,500 --> 00:22:42,120
variables without values and yet here we

00:22:40,799 --> 00:22:45,029
have it we've sort of gotten to a bit of

00:22:42,120 --> 00:22:46,710
a corner and a bit of a fix now you

00:22:45,029 --> 00:22:48,330
might be saying okay who is gonna print

00:22:46,710 --> 00:22:50,490
a value and then assign to it later

00:22:48,330 --> 00:22:51,870
you'd be surprised but a more common

00:22:50,490 --> 00:22:53,760
version of this problem is if I say x

00:22:51,870 --> 00:22:56,159
equals 100 and now I'm going to define

00:22:53,760 --> 00:22:58,289
the function look I have your X plus

00:22:56,159 --> 00:22:59,850
equal one way at the top of the function

00:22:58,289 --> 00:23:03,299
and many people would say oh we're going

00:22:59,850 --> 00:23:05,039
to take the value the global X 100 add

00:23:03,299 --> 00:23:07,350
one to an assigned to a local X but no

00:23:05,039 --> 00:23:09,990
this is the same as saying x equals x

00:23:07,350 --> 00:23:12,480
plus one python is going to notice the X

00:23:09,990 --> 00:23:14,899
equal and it will say AHA X is a local

00:23:12,480 --> 00:23:18,149
variable and it's going to note that in

00:23:14,899 --> 00:23:21,120
Co VAR names and then when it comes time

00:23:18,149 --> 00:23:24,419
to run the function it's gonna look up X

00:23:21,120 --> 00:23:26,730
plus one what is X is a local yes what's

00:23:24,419 --> 00:23:29,730
its value we don't have it unbound local

00:23:26,730 --> 00:23:32,460
air now another thing we could do is use

00:23:29,730 --> 00:23:36,710
the global declaration what does that do

00:23:32,460 --> 00:23:40,380
it basically says we don't want to note

00:23:36,710 --> 00:23:42,270
X in CEO of our names we don't want to

00:23:40,380 --> 00:23:43,980
list it as a local variable so when we

00:23:42,270 --> 00:23:46,950
run this it's gonna be one hundred two

00:23:43,980 --> 00:23:49,440
hundred because we have assigned 200 but

00:23:46,950 --> 00:23:51,960
then it's gonna also say 200 why because

00:23:49,440 --> 00:23:53,760
now there is no local X so when I sign

00:23:51,960 --> 00:23:56,250
to X from within the function I'm really

00:23:53,760 --> 00:23:58,470
assigned to a global variable by the way

00:23:56,250 --> 00:24:01,020
even if it did not exist before is a

00:23:58,470 --> 00:24:02,370
global variable and sure enough we can

00:24:01,020 --> 00:24:05,070
see if we look at the CEO of our names

00:24:02,370 --> 00:24:07,169
it's empty so python uses le gb to look

00:24:05,070 --> 00:24:08,990
for X but it can't find in the local so

00:24:07,169 --> 00:24:11,640
we'll just go to Global's which is fine

00:24:08,990 --> 00:24:13,890
let's use disc just to break apart these

00:24:11,640 --> 00:24:16,980
functions and see both a non global and

00:24:13,890 --> 00:24:19,080
the global version so with a local

00:24:16,980 --> 00:24:22,380
version of X without the global scope

00:24:19,080 --> 00:24:24,630
without the global statement we can see

00:24:22,380 --> 00:24:27,120
that the bytecodes includes store fast

00:24:24,630 --> 00:24:30,659
and load fast store fast and load fast

00:24:27,120 --> 00:24:33,419
mean local variables but when we include

00:24:30,659 --> 00:24:34,659
the global declaration in our function

00:24:33,419 --> 00:24:35,859
notice now

00:24:34,659 --> 00:24:39,779
has changed the bike codes have changed

00:24:35,859 --> 00:24:41,889
to be store global and load global

00:24:39,779 --> 00:24:45,309
alright time to get even more

00:24:41,889 --> 00:24:47,590
complicated let's talk about enclosing

00:24:45,309 --> 00:24:49,629
functions or enclosing scopes or nested

00:24:47,590 --> 00:24:51,369
scopes and functions meaning I'm going

00:24:49,629 --> 00:24:52,509
to define a function and inside of that

00:24:51,369 --> 00:24:56,649
function I'm going to define another

00:24:52,509 --> 00:24:58,749
function so my outer function called

00:24:56,649 --> 00:25:01,059
outer quite appropriately it has two

00:24:58,749 --> 00:25:03,429
local variables run counter in total and

00:25:01,059 --> 00:25:05,830
what I'm going to do is I'm going to add

00:25:03,429 --> 00:25:08,019
each time I run the inner function I'm

00:25:05,830 --> 00:25:10,590
going to add to run counter and I'm

00:25:08,019 --> 00:25:13,210
gonna add to the total pretty great huh

00:25:10,590 --> 00:25:15,489
now this is sometimes known as a closure

00:25:13,210 --> 00:25:17,529
basically if I run out or I'm going to

00:25:15,489 --> 00:25:19,419
get back in or I'm gonna get that

00:25:17,529 --> 00:25:21,669
function object back and I can assign it

00:25:19,419 --> 00:25:22,239
as I do here to func and then I can run

00:25:21,669 --> 00:25:25,929
func

00:25:22,239 --> 00:25:27,039
and func will get an argument X and then

00:25:25,929 --> 00:25:28,149
we'll add to the run counter and we'll

00:25:27,039 --> 00:25:29,470
print everything and everything will be

00:25:28,149 --> 00:25:33,399
great and when I run and I get an

00:25:29,470 --> 00:25:35,619
unbound local error why well we just go

00:25:33,399 --> 00:25:37,779
back for a moment you'll see that run

00:25:35,619 --> 00:25:39,309
counter plus equal 1 total plus equal s

00:25:37,779 --> 00:25:41,590
is exactly what a stopped talking about

00:25:39,309 --> 00:25:45,220
a few minutes ago that basically that

00:25:41,590 --> 00:25:47,109
plus equal 1 sets us up for failure just

00:25:45,220 --> 00:25:50,590
run through these things ok so what can

00:25:47,109 --> 00:25:54,220
we do instead we can use non local non

00:25:50,590 --> 00:25:57,220
local tells Python don't list these as

00:25:54,220 --> 00:25:59,169
local variables but do realize they're

00:25:57,220 --> 00:26:01,809
not Global's either they're actually in

00:25:59,169 --> 00:26:03,249
the outer functions scope these are

00:26:01,809 --> 00:26:06,749
local variables belonging to the outer

00:26:03,249 --> 00:26:09,279
function and so when you modify them

00:26:06,749 --> 00:26:11,320
don't modify them locally here don't

00:26:09,279 --> 00:26:12,940
look for Global's but modify the local

00:26:11,320 --> 00:26:14,200
variables in the outer function now if

00:26:12,940 --> 00:26:16,690
this sounds weird let's go back to the

00:26:14,200 --> 00:26:17,710
Python tutor and we'll see a little bit

00:26:16,690 --> 00:26:21,159
of how this works

00:26:17,710 --> 00:26:23,499
so we have here outer a global variable

00:26:21,159 --> 00:26:25,659
pointing to the outer function and we

00:26:23,499 --> 00:26:28,479
even see a stack frame a time that we're

00:26:25,659 --> 00:26:30,249
an outer and got back inner which we

00:26:28,479 --> 00:26:33,129
have then assigned a func so we're an

00:26:30,249 --> 00:26:34,989
outer write that function object and

00:26:33,129 --> 00:26:38,409
then we got back this function object

00:26:34,989 --> 00:26:41,289
which has it's referred to by func and

00:26:38,409 --> 00:26:42,849
we also have inner referring to it it

00:26:41,289 --> 00:26:46,330
refers back to the scope in which it was

00:26:42,849 --> 00:26:48,130
defined how does this work how does it

00:26:46,330 --> 00:26:51,580
keep track of the variables

00:26:48,130 --> 00:26:55,060
that outerscope well it has an attribute

00:26:51,580 --> 00:26:58,150
Co free VARs and Co free VARs contains

00:26:55,060 --> 00:26:59,740
two elements run counter in total the

00:26:58,150 --> 00:27:02,980
two variables that we declared with

00:26:59,740 --> 00:27:05,620
non-local but it's not a one directional

00:27:02,980 --> 00:27:08,940
relationship it turns out that the outer

00:27:05,620 --> 00:27:11,560
function also knows and its selves ours

00:27:08,940 --> 00:27:13,110
attribute it knows which variables have

00:27:11,560 --> 00:27:15,490
been defined and are referring to it

00:27:13,110 --> 00:27:17,410
okay what have we learned first of all

00:27:15,490 --> 00:27:19,750
we see the death does two things it

00:27:17,410 --> 00:27:21,640
defines a function object and it defines

00:27:19,750 --> 00:27:24,310
the function object assigns the function

00:27:21,640 --> 00:27:26,380
object to a variable secondly function

00:27:24,310 --> 00:27:28,300
objects contain attributes and these

00:27:26,380 --> 00:27:30,130
attributes both contain the byte codes

00:27:28,300 --> 00:27:32,680
that were compiled for our function and

00:27:30,130 --> 00:27:35,050
the hints to Python for running the

00:27:32,680 --> 00:27:36,460
function finally attributes dictate

00:27:35,050 --> 00:27:38,350
behavior we take for granted we don't

00:27:36,460 --> 00:27:40,210
think much about arguments we don't

00:27:38,350 --> 00:27:42,250
think it much about scoping but the fact

00:27:40,210 --> 00:27:44,200
is these are really important to our

00:27:42,250 --> 00:27:45,970
functions and they're all controlled by

00:27:44,200 --> 00:27:48,370
these function objects and by these

00:27:45,970 --> 00:27:49,570
attributes if you have any questions or

00:27:48,370 --> 00:27:52,240
comments I would be delighted to hear

00:27:49,570 --> 00:27:54,820
from you on email or on Twitter and I

00:27:52,240 --> 00:27:58,050
hope to see you next year in Pittsburgh

00:27:54,820 --> 00:27:58,050

YouTube URL: https://www.youtube.com/watch?v=QR9W81P7yTw


