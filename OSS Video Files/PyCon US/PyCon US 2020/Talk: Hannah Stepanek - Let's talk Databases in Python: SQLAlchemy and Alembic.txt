Title: Talk: Hannah Stepanek - Let's talk Databases in Python: SQLAlchemy and Alembic
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Hannah Stepanek

What’s an ORM? Is there a way to write database queries so that they are compatible with multiple types of databases? How do you make database changes (such as adding a new table or a new column) safely? What is a connection pool and why is it useful? What are some things that can go wrong when operating at scale? Is lazy loading slowing you down? In this talk we’ll take a deep dive into how the Python libraries SQLAlchemy and Alembic make managing production databases simple, efficient, and painless so you can get back to feature development.




Talk slides: http://bit.ly/lets-talk-databases-python
Captions: 
	00:00:11,940 --> 00:00:18,210
it's my talk let's talk databases in

00:00:14,400 --> 00:00:20,490
Python but first before we get started a

00:00:18,210 --> 00:00:23,610
little bit about me why am I giving this

00:00:20,490 --> 00:00:26,250
talk I started out my career working at

00:00:23,610 --> 00:00:29,430
Intel on a flask application for data

00:00:26,250 --> 00:00:33,030
analysis and there it talked to my suit

00:00:29,430 --> 00:00:35,010
well next i worked at hypothesis

00:00:33,030 --> 00:00:38,129
building a pyramid to react application

00:00:35,010 --> 00:00:41,160
for annotating web pages and it talked

00:00:38,129 --> 00:00:42,690
to Postgres sequel currently I work at

00:00:41,160 --> 00:00:46,140
New Relic as an application developer

00:00:42,690 --> 00:00:48,030
for the security team and there we also

00:00:46,140 --> 00:00:52,999
have a flask application that talks to

00:00:48,030 --> 00:00:56,129
progress sequel a little extra tidbit I

00:00:52,999 --> 00:00:59,519
gave a talk at PyCon last year as well

00:00:56,129 --> 00:01:01,079
on the pandas library and something that

00:00:59,519 --> 00:01:04,290
came out of that which I'm super excited

00:01:01,079 --> 00:01:06,590
about is I will soon be a published

00:01:04,290 --> 00:01:09,300
author of the book thinking and pentas

00:01:06,590 --> 00:01:11,040
which is based on that talk so if you

00:01:09,300 --> 00:01:12,590
enjoyed that talk last year or you're at

00:01:11,040 --> 00:01:15,870
all interested in learning pandas

00:01:12,590 --> 00:01:17,220
definitely check that out it's published

00:01:15,870 --> 00:01:21,960
by a press and should be coming out in

00:01:17,220 --> 00:01:25,650
June sometime so jumping right in what

00:01:21,960 --> 00:01:28,890
is an ORM so our M stands for object

00:01:25,650 --> 00:01:32,450
relational mapper so the idea is we have

00:01:28,890 --> 00:01:37,530
our objects over here on the right and

00:01:32,450 --> 00:01:40,650
those map to tables in our relational

00:01:37,530 --> 00:01:44,850
database over here on the left and so

00:01:40,650 --> 00:01:48,150
the an ORM is responsible for building

00:01:44,850 --> 00:01:50,310
that mapping between the two and so what

00:01:48,150 --> 00:01:53,370
overruns are available to us in Python

00:01:50,310 --> 00:01:56,310
we have sequel alchemy Django or wimpy

00:01:53,370 --> 00:02:00,750
we Pony ORM sequel object tortoise or

00:01:56,310 --> 00:02:03,330
OEM there are a lot of them but today

00:02:00,750 --> 00:02:06,510
I'm gonna be talking to you about how to

00:02:03,330 --> 00:02:10,590
use sequel alchemy it's seen as a very

00:02:06,510 --> 00:02:14,580
nice or M by the Python community it has

00:02:10,590 --> 00:02:19,769
a good generalized abstraction and query

00:02:14,580 --> 00:02:22,440
language that's database agnostic but it

00:02:19,769 --> 00:02:24,830
also allows you to do database specific

00:02:22,440 --> 00:02:28,670
things if you need to

00:02:24,830 --> 00:02:31,580
so let's look at an example so we have

00:02:28,670 --> 00:02:33,350
are a bunch of what I will refer to you

00:02:31,580 --> 00:02:36,910
in the rest of this presentation as

00:02:33,350 --> 00:02:39,110
models which are the sequel alchemy

00:02:36,910 --> 00:02:41,180
classes which represent our tables in

00:02:39,110 --> 00:02:43,100
our database and so here let's take a

00:02:41,180 --> 00:02:46,880
look at what the user model looks like

00:02:43,100 --> 00:02:48,200
so here's our user model class its

00:02:46,880 --> 00:02:52,010
inheriting from this base class that

00:02:48,200 --> 00:02:54,790
I'll talk about in the next slide it has

00:02:52,010 --> 00:02:57,680
so here we're providing the table name

00:02:54,790 --> 00:02:59,720
user and then we have several columns so

00:02:57,680 --> 00:03:01,940
we have an ID we have an email a

00:02:59,720 --> 00:03:04,790
username a password and a last login

00:03:01,940 --> 00:03:08,480
date so in here you can see we can do

00:03:04,790 --> 00:03:10,070
things like set the primary key and auto

00:03:08,480 --> 00:03:11,540
increment the primary key which what

00:03:10,070 --> 00:03:13,040
that means is sequel alchemy is gonna

00:03:11,540 --> 00:03:15,980
take care of this for us it's just gonna

00:03:13,040 --> 00:03:19,150
start the ID out at zero and then keep

00:03:15,980 --> 00:03:23,600
incrementing it over time automatically

00:03:19,150 --> 00:03:26,690
we also have an email address that is

00:03:23,600 --> 00:03:29,989
unique and it's indexed and it is not

00:03:26,690 --> 00:03:32,870
knowable all right which means it can't

00:03:29,989 --> 00:03:34,640
you have to define it and then we of

00:03:32,870 --> 00:03:37,130
course have a username and a password

00:03:34,640 --> 00:03:38,570
those are pretty standard we also have

00:03:37,130 --> 00:03:40,010
this last login date and something

00:03:38,570 --> 00:03:42,650
that's kind of interesting about that is

00:03:40,010 --> 00:03:45,050
if you look down there in the definition

00:03:42,650 --> 00:03:48,850
you see this server default equals si

00:03:45,050 --> 00:03:51,560
funk now and what that is doing is it is

00:03:48,850 --> 00:03:55,310
going to go all the way to the database

00:03:51,560 --> 00:03:57,440
without having set this timestamp and

00:03:55,310 --> 00:03:59,630
it's going to actually set the timestamp

00:03:57,440 --> 00:04:02,269
on the database at the time that we

00:03:59,630 --> 00:04:04,220
write the user to the database so that's

00:04:02,269 --> 00:04:07,040
really nice it's also kind of like a

00:04:04,220 --> 00:04:09,320
best practice is to be very consistent

00:04:07,040 --> 00:04:10,310
about where you set your time stamps and

00:04:09,320 --> 00:04:14,420
generally you want to do that on the

00:04:10,310 --> 00:04:16,400
database side um so let's take a look at

00:04:14,420 --> 00:04:19,040
that common base class that the user

00:04:16,400 --> 00:04:21,049
model is inheriting from this is also

00:04:19,040 --> 00:04:22,310
pretty standard stuff it's pulled

00:04:21,049 --> 00:04:25,390
directly from sequel alchemy

00:04:22,310 --> 00:04:27,260
documentation so here we're just

00:04:25,390 --> 00:04:28,820
providing some kind of like standard

00:04:27,260 --> 00:04:31,310
naming conventions for the columns here

00:04:28,820 --> 00:04:37,130
so we have IX meaning index column

00:04:31,310 --> 00:04:40,070
unique etc and then we're imported

00:04:37,130 --> 00:04:42,680
this declarative base class sorry

00:04:40,070 --> 00:04:45,140
declared a base function which will make

00:04:42,680 --> 00:04:46,820
our base class for us so we passed in

00:04:45,140 --> 00:04:48,230
the metadata and then sequel alchemy

00:04:46,820 --> 00:04:51,790
generates this base class which we'll

00:04:48,230 --> 00:04:55,700
use for all of our models that we built

00:04:51,790 --> 00:04:59,540
you can also do a validation inside of

00:04:55,700 --> 00:05:02,090
these models so here for example we are

00:04:59,540 --> 00:05:04,240
validating that the user name is within

00:05:02,090 --> 00:05:06,620
a certain length and that it also

00:05:04,240 --> 00:05:08,060
contains certain characters or doesn't

00:05:06,620 --> 00:05:11,330
contain certain characters this case may

00:05:08,060 --> 00:05:13,510
be um you do have to be a little bit

00:05:11,330 --> 00:05:17,390
careful about this remember that

00:05:13,510 --> 00:05:19,310
validation at the database level or at

00:05:17,390 --> 00:05:22,190
the sequel alchemy model level is kind

00:05:19,310 --> 00:05:25,250
of like a latched ditch validation

00:05:22,190 --> 00:05:27,470
before it enters the database so this

00:05:25,250 --> 00:05:29,540
may or may not be the best example which

00:05:27,470 --> 00:05:31,640
is why I chose it because this is kind

00:05:29,540 --> 00:05:32,990
of talking about like the great areas

00:05:31,640 --> 00:05:34,880
and the design decisions that you mean

00:05:32,990 --> 00:05:39,740
it may need to make for your application

00:05:34,880 --> 00:05:42,500
and your models so here um this may not

00:05:39,740 --> 00:05:46,420
be the best place to do this validation

00:05:42,500 --> 00:05:48,590
as my point um something like checking

00:05:46,420 --> 00:05:50,600
the user name for certain characters

00:05:48,590 --> 00:05:52,520
that's probably something you would want

00:05:50,600 --> 00:05:54,230
to catch before it reaches the database

00:05:52,520 --> 00:05:55,700
probably on the front end like it's

00:05:54,230 --> 00:05:56,630
something where the user but nature

00:05:55,700 --> 00:05:58,160
their username and they would

00:05:56,630 --> 00:05:59,870
immediately get feedback and it would

00:05:58,160 --> 00:06:01,400
say hey like these characters are not

00:05:59,870 --> 00:06:02,420
allowed in your username you wouldn't

00:06:01,400 --> 00:06:04,670
necessarily want to go all the way to

00:06:02,420 --> 00:06:07,160
write into the data or almost writing to

00:06:04,670 --> 00:06:10,250
the database before this error pops up

00:06:07,160 --> 00:06:11,570
right um but anyways it can't do

00:06:10,250 --> 00:06:13,790
validation for you which can be really

00:06:11,570 --> 00:06:15,410
nice as like a safe garden like a last

00:06:13,790 --> 00:06:19,250
ditch like hey oh no don't write that

00:06:15,410 --> 00:06:21,500
I'm sort of thing so anyways um we can

00:06:19,250 --> 00:06:23,600
also define relationships between our

00:06:21,500 --> 00:06:26,420
tables so for example here we have a

00:06:23,600 --> 00:06:31,880
relationship between the user model and

00:06:26,420 --> 00:06:35,530
to the group model so here um the group

00:06:31,880 --> 00:06:38,960
has a creator ID which points to the a

00:06:35,530 --> 00:06:42,200
row in the U and an ID of a row in the

00:06:38,960 --> 00:06:44,150
user table and so how we define that in

00:06:42,200 --> 00:06:47,090
sequel alchemy we have this Creator ID

00:06:44,150 --> 00:06:50,300
column and that's set to be a foreign

00:06:47,090 --> 00:06:53,770
key of user ID and then we also have

00:06:50,300 --> 00:06:56,180
this Creator relationship to user which

00:06:53,770 --> 00:06:57,770
will allow us to do things like query a

00:06:56,180 --> 00:07:01,370
group out of the database and then say

00:06:57,770 --> 00:07:04,759
group creator dot and get any column

00:07:01,370 --> 00:07:07,370
name or field off of the user object so

00:07:04,759 --> 00:07:09,139
we don't just have the user ID we

00:07:07,370 --> 00:07:13,190
actually have like full access to the

00:07:09,139 --> 00:07:18,080
user object if we want we can also do

00:07:13,190 --> 00:07:21,500
unique constraints so for example we

00:07:18,080 --> 00:07:25,729
might not just want to have a unique

00:07:21,500 --> 00:07:28,129
email or a unique authority but like a

00:07:25,729 --> 00:07:30,349
unique email authority combination and

00:07:28,129 --> 00:07:33,050
in this case Authority is really domain

00:07:30,349 --> 00:07:37,599
so we're saying for each like Authority

00:07:33,050 --> 00:07:41,419
or domain the user email must be unique

00:07:37,599 --> 00:07:45,099
I'm sorry the user email and the

00:07:41,419 --> 00:07:49,310
combination of the domain must be unique

00:07:45,099 --> 00:07:53,360
we can also do define a multi column

00:07:49,310 --> 00:07:56,539
index and what that means is we would

00:07:53,360 --> 00:07:58,940
like to pull a single user out of the

00:07:56,539 --> 00:08:00,259
database a unique user and so our Cruz

00:07:58,940 --> 00:08:03,020
may look something like this where we

00:08:00,259 --> 00:08:05,840
say where username equals user and

00:08:03,020 --> 00:08:07,340
authority equals some Authority we might

00:08:05,840 --> 00:08:13,430
also do queries just based on the

00:08:07,340 --> 00:08:15,440
username itself however we never do this

00:08:13,430 --> 00:08:17,659
this bottom query which is just query

00:08:15,440 --> 00:08:20,719
based on the authority because the

00:08:17,659 --> 00:08:23,090
authority is not narrow enough to give

00:08:20,719 --> 00:08:27,259
us back just a unique user and this is

00:08:23,090 --> 00:08:28,610
very important in the order for this is

00:08:27,259 --> 00:08:31,069
very important so notice where you have

00:08:28,610 --> 00:08:33,500
user name and then authority actors

00:08:31,069 --> 00:08:35,149
because we're saying like we make were

00:08:33,500 --> 00:08:36,500
uniquely on the user name and query

00:08:35,149 --> 00:08:38,270
uniquely on the user name and authority

00:08:36,500 --> 00:08:40,579
combination but we don't query uniquely

00:08:38,270 --> 00:08:43,339
on the authority and so we're just

00:08:40,579 --> 00:08:47,570
creating a unique index to that we can

00:08:43,339 --> 00:08:50,630
also do personal indexing so in this

00:08:47,570 --> 00:08:54,769
application they we did something called

00:08:50,630 --> 00:08:58,459
shadow banning which is where we have a

00:08:54,769 --> 00:08:59,600
user like a user may violate the

00:08:58,459 --> 00:09:00,480
Community Guidelines

00:08:59,600 --> 00:09:04,230
and in this

00:09:00,480 --> 00:09:07,320
example the user did just that they're

00:09:04,230 --> 00:09:09,570
using annotations for for selling their

00:09:07,320 --> 00:09:12,810
product advertising and that's not

00:09:09,570 --> 00:09:14,100
allowed and so how we shadow band then

00:09:12,810 --> 00:09:17,040
I'm like what that is is it's basically

00:09:14,100 --> 00:09:19,139
this is what they see everything looks

00:09:17,040 --> 00:09:21,510
fine to them but this is what the rest

00:09:19,139 --> 00:09:24,209
of the world sees they see nothing there

00:09:21,510 --> 00:09:32,730
their annotations have been shadow

00:09:24,209 --> 00:09:34,589
banned and so how we may how we present

00:09:32,730 --> 00:09:36,389
the annotations and filter them out

00:09:34,589 --> 00:09:39,329
filter out all the shadow band

00:09:36,389 --> 00:09:41,310
annotations is we do a query for all the

00:09:39,329 --> 00:09:43,079
annotations and then we filter them

00:09:41,310 --> 00:09:44,760
after the fact so we do a separate query

00:09:43,079 --> 00:09:46,889
and get all the shadow band users and

00:09:44,760 --> 00:09:48,720
then remove or strip out all their

00:09:46,889 --> 00:09:52,709
annotations before we send them to the

00:09:48,720 --> 00:09:54,959
front end and so in that situation in

00:09:52,709 --> 00:09:59,250
order to make that grab all the shadow

00:09:54,959 --> 00:10:01,560
band users query efficient we have this

00:09:59,250 --> 00:10:03,510
nips of field which it when true it

00:10:01,560 --> 00:10:07,740
means it's a shadow band user and we

00:10:03,510 --> 00:10:09,959
just create a partial index where nip

00:10:07,740 --> 00:10:12,300
set is true and we index all the nips of

00:10:09,959 --> 00:10:17,790
true users so that they're very quick to

00:10:12,300 --> 00:10:20,819
look up and find we can also define dear

00:10:17,790 --> 00:10:23,310
do a functional expression indexing so

00:10:20,819 --> 00:10:25,290
what this is is we have a thread of

00:10:23,310 --> 00:10:27,690
annotation so you can write a root

00:10:25,290 --> 00:10:28,980
annotation and then make a reply to that

00:10:27,690 --> 00:10:32,819
initiation and it reply to the

00:10:28,980 --> 00:10:35,190
Republican right and so how we define

00:10:32,819 --> 00:10:40,319
that in the database is we have this

00:10:35,190 --> 00:10:43,560
references list which is a which

00:10:40,319 --> 00:10:47,339
contains the parent annotation the the

00:10:43,560 --> 00:10:49,290
annotations parents and so on this route

00:10:47,339 --> 00:10:52,740
annotation for example the references is

00:10:49,290 --> 00:10:56,370
empty on this reply to that route

00:10:52,740 --> 00:10:59,220
annotation the references list points

00:10:56,370 --> 00:11:04,470
the route right and on this reply to the

00:10:59,220 --> 00:11:06,779
reply the reference points to the route

00:11:04,470 --> 00:11:12,209
annotation and then the replied to the

00:11:06,779 --> 00:11:13,889
route annotation and so we in order to

00:11:12,209 --> 00:11:16,939
find the annotations base

00:11:13,889 --> 00:11:18,989
like what we do is we grab all of the

00:11:16,939 --> 00:11:20,790
route annotations that we wanted to

00:11:18,989 --> 00:11:22,139
display on the page and then we run a

00:11:20,790 --> 00:11:24,179
separate query and grab all of the

00:11:22,139 --> 00:11:25,949
replies to that route annotation so we

00:11:24,179 --> 00:11:27,689
want to so we might do something like

00:11:25,949 --> 00:11:30,179
this where references of 0 equals the

00:11:27,689 --> 00:11:32,160
route annotation and we want to make

00:11:30,179 --> 00:11:35,699
that look up very fast right we want to

00:11:32,160 --> 00:11:38,309
index that lookup and so notice that

00:11:35,699 --> 00:11:41,489
we're doing like references of 0 right

00:11:38,309 --> 00:11:43,529
so we need to index that route

00:11:41,489 --> 00:11:47,730
annotation or that like index of 0

00:11:43,529 --> 00:11:50,309
annotation and so how we do that is we

00:11:47,730 --> 00:11:53,399
use the functional expression index and

00:11:50,309 --> 00:11:56,040
we index the references of one in this

00:11:53,399 --> 00:11:58,199
case and it's 1 because we're in

00:11:56,040 --> 00:12:03,299
Postgres and Postgres uses one based

00:11:58,199 --> 00:12:04,679
array indexing so it's 1 and not 0 all

00:12:03,299 --> 00:12:07,019
right so we've talked about some ways to

00:12:04,679 --> 00:12:08,720
index and improve our queries make them

00:12:07,019 --> 00:12:11,429
more efficient using sequel alchemy

00:12:08,720 --> 00:12:13,169
let's dive into you actually connecting

00:12:11,429 --> 00:12:18,179
to the database and grabbing some data

00:12:13,169 --> 00:12:20,489
so how we do this is quite simple um you

00:12:18,179 --> 00:12:22,019
import the create engine function from

00:12:20,489 --> 00:12:23,610
sequel alchemy and then you create an

00:12:22,019 --> 00:12:25,889
engine which you basically just pass in

00:12:23,610 --> 00:12:27,480
the URL to the database and it creates

00:12:25,889 --> 00:12:31,799
an engine for you and then you bind that

00:12:27,480 --> 00:12:34,470
engine to a session and so here we have

00:12:31,799 --> 00:12:37,739
this session maker which again is

00:12:34,470 --> 00:12:39,199
dumping out a session class for us to

00:12:37,739 --> 00:12:43,709
use which is why it's capitalized there

00:12:39,199 --> 00:12:46,110
and so how we use that class as we

00:12:43,709 --> 00:12:49,230
instantiate an instance of it and then

00:12:46,110 --> 00:12:51,059
say we make a user object we add that

00:12:49,230 --> 00:12:53,509
user objects we commit that user Racha

00:12:51,059 --> 00:12:55,470
tickets written to the database and then

00:12:53,509 --> 00:12:57,809
don't forget to close your connection

00:12:55,470 --> 00:13:00,269
afterwards this is very important and so

00:12:57,809 --> 00:13:02,579
in order to kind of like facilitate this

00:13:00,269 --> 00:13:05,519
opening and closing of connections and

00:13:02,579 --> 00:13:07,410
remembering to do all these steps we

00:13:05,519 --> 00:13:09,239
could also create a context manager to

00:13:07,410 --> 00:13:11,480
do that for us so this is what that

00:13:09,239 --> 00:13:14,639
looks like we instantiate this session

00:13:11,480 --> 00:13:18,869
and then we yield the session and that

00:13:14,639 --> 00:13:20,279
is where we that's that first part of

00:13:18,869 --> 00:13:22,350
the whip statement so now we've entered

00:13:20,279 --> 00:13:24,449
the with statement so we're we peeled at

00:13:22,350 --> 00:13:26,740
the session to the internals of the with

00:13:24,449 --> 00:13:28,750
statement it's going to add the user

00:13:26,740 --> 00:13:31,270
commit the user and that's my field back

00:13:28,750 --> 00:13:33,339
into the session manager if an exception

00:13:31,270 --> 00:13:34,899
was raised for whatever reason we're

00:13:33,339 --> 00:13:36,370
going to clean ourselves up so we're

00:13:34,899 --> 00:13:39,700
gonna roll back the session and re-raise

00:13:36,370 --> 00:13:41,529
the error otherwise we're just gonna

00:13:39,700 --> 00:13:44,410
close the session because everything

00:13:41,529 --> 00:13:46,810
worked great and so yeah in the scenario

00:13:44,410 --> 00:13:49,330
kind of like I'm doing like file i/o

00:13:46,810 --> 00:13:50,770
using a context manager I don't have to

00:13:49,330 --> 00:13:52,440
worry about opening and closing it kind

00:13:50,770 --> 00:13:56,620
of handles that for us which is nice uh

00:13:52,440 --> 00:13:59,410
which leads me to my next point uh when

00:13:56,620 --> 00:14:01,839
should her how should you scope your

00:13:59,410 --> 00:14:03,610
sessions right um what'swhat's the

00:14:01,839 --> 00:14:05,350
scoping of this thing so in a web

00:14:03,610 --> 00:14:07,330
application a session should follow the

00:14:05,350 --> 00:14:09,940
life cycle of the request what does that

00:14:07,330 --> 00:14:11,740
mean it means when the request comes

00:14:09,940 --> 00:14:14,740
into your application that's when you

00:14:11,740 --> 00:14:19,540
open a session when your response is

00:14:14,740 --> 00:14:21,880
sent back from the web application

00:14:19,540 --> 00:14:23,410
that's when you close the session and

00:14:21,880 --> 00:14:28,420
that is how your sessions are to be code

00:14:23,410 --> 00:14:30,910
scoped so you might think that a session

00:14:28,420 --> 00:14:32,610
is establishing a database connection in

00:14:30,910 --> 00:14:34,930
each time that is in fact not the case

00:14:32,610 --> 00:14:36,760
and we'll talk about why that is in a

00:14:34,930 --> 00:14:38,230
second but this is what it looks like to

00:14:36,760 --> 00:14:44,290
establish it out of a connection it's

00:14:38,230 --> 00:14:47,050
very slow um it first since a sin and to

00:14:44,290 --> 00:14:49,300
the database and then it sends us an act

00:14:47,050 --> 00:14:51,160
back from the database and then it sends

00:14:49,300 --> 00:14:52,959
an acknowledgment to the database so

00:14:51,160 --> 00:14:55,810
this is like three times back and forth

00:14:52,959 --> 00:14:57,490
across the network it's very slow very

00:14:55,810 --> 00:15:00,370
time consuming we really don't want to

00:14:57,490 --> 00:15:02,070
be opening and closing database

00:15:00,370 --> 00:15:05,140
connections each time we want a request

00:15:02,070 --> 00:15:07,450
so luckily for us sequel alchemy is

00:15:05,140 --> 00:15:09,579
smart enough and it magically handles

00:15:07,450 --> 00:15:12,130
this force how it uses something called

00:15:09,579 --> 00:15:14,829
connection pools and what a connection

00:15:12,130 --> 00:15:17,079
pool is is it is a pool of connections

00:15:14,829 --> 00:15:18,279
shockingly so these connections stay

00:15:17,079 --> 00:15:19,839
open

00:15:18,279 --> 00:15:22,510
they've been once they've been

00:15:19,839 --> 00:15:24,490
established they do not close they just

00:15:22,510 --> 00:15:27,850
go back in the pool so when we create a

00:15:24,490 --> 00:15:29,890
session we're not actually creating a

00:15:27,850 --> 00:15:31,270
database connection we're just grabbing

00:15:29,890 --> 00:15:33,250
one out of the pool it's already been

00:15:31,270 --> 00:15:34,600
established we use it and then we put it

00:15:33,250 --> 00:15:36,720
back in the pool for somebody else to

00:15:34,600 --> 00:15:36,720
use

00:15:39,360 --> 00:15:52,439
so in when Mike you generate are when we

00:15:47,639 --> 00:15:55,920
build our engine we can we have some

00:15:52,439 --> 00:15:58,670
options for the the pool settings so

00:15:55,920 --> 00:16:01,350
here you can see you have the pool size

00:15:58,670 --> 00:16:05,819
max overflow timeout

00:16:01,350 --> 00:16:07,769
use LIFO or not these are I think that's

00:16:05,819 --> 00:16:09,629
like the default options that I that I

00:16:07,769 --> 00:16:12,329
wrote here but you have control over

00:16:09,629 --> 00:16:14,249
them so what this is saying is we would

00:16:12,329 --> 00:16:17,249
like a pool of connection of five

00:16:14,249 --> 00:16:18,749
connections with a maximum overflow of

00:16:17,249 --> 00:16:20,660
two connections so what that means it's

00:16:18,749 --> 00:16:24,179
like if all five connections are in use

00:16:20,660 --> 00:16:26,970
then it will create two more connections

00:16:24,179 --> 00:16:28,379
when a session is requested but it won't

00:16:26,970 --> 00:16:30,329
keep those alive it will close those

00:16:28,379 --> 00:16:33,959
down actually they're no longer needed

00:16:30,329 --> 00:16:35,730
and then we also have a timeout of 30

00:16:33,959 --> 00:16:38,249
seconds on any of those connections so

00:16:35,730 --> 00:16:40,980
if we don't receive any data for 30

00:16:38,249 --> 00:16:44,149
seconds or like if no one's used it in

00:16:40,980 --> 00:16:47,519
awhile then it just closes by itself um

00:16:44,149 --> 00:16:49,619
we also have this option use LIFO so

00:16:47,519 --> 00:16:52,470
what that stands for is lastin first-out

00:16:49,619 --> 00:16:54,509
so what that's saying and the default is

00:16:52,470 --> 00:16:57,929
false the week is that it's true and if

00:16:54,509 --> 00:17:00,119
we do what that's doing is it's the

00:16:57,929 --> 00:17:01,439
connection that goes that was most

00:17:00,119 --> 00:17:03,899
recently used and put back in the pool

00:17:01,439 --> 00:17:06,389
is the same one that comes back out of

00:17:03,899 --> 00:17:08,699
the pool immediately the next time

00:17:06,389 --> 00:17:11,970
somebody requested requests a session

00:17:08,699 --> 00:17:14,449
and so what that's gonna do is it's

00:17:11,970 --> 00:17:17,250
basically gonna let old connections die

00:17:14,449 --> 00:17:20,279
and so this is kind of like a way to

00:17:17,250 --> 00:17:22,230
scale your traffic up and down and get

00:17:20,279 --> 00:17:27,000
rid of connections that you no longer

00:17:22,230 --> 00:17:29,580
need so what this looks like as far as a

00:17:27,000 --> 00:17:32,309
connection pool is concerned is the

00:17:29,580 --> 00:17:34,500
connections that aren't used slowly died

00:17:32,309 --> 00:17:37,620
and and this is a common problem as well

00:17:34,500 --> 00:17:41,429
they just kind of start start dying if

00:17:37,620 --> 00:17:44,850
they're not used in awhile and that's

00:17:41,429 --> 00:17:46,649
very unfortunate for us because if you

00:17:44,850 --> 00:17:48,380
don't or if you are not constantly

00:17:46,649 --> 00:17:49,850
receiving traffic

00:17:48,380 --> 00:17:54,770
then your connections are gonna die and

00:17:49,850 --> 00:17:57,470
then your the next time my request comes

00:17:54,770 --> 00:17:58,340
in and queries the database then you're

00:17:57,470 --> 00:18:00,140
gonna have to re-establish that

00:17:58,340 --> 00:18:01,430
connection and you don't want to do that

00:18:00,140 --> 00:18:03,200
like you want to keep your connections

00:18:01,430 --> 00:18:05,960
alive and you want to keep your

00:18:03,200 --> 00:18:07,580
application always responsive and so in

00:18:05,960 --> 00:18:10,280
order to do that we can actually specify

00:18:07,580 --> 00:18:12,440
some tcp keepalive settings in our

00:18:10,280 --> 00:18:14,330
connections so that our connection will

00:18:12,440 --> 00:18:18,860
ping the database and keep itself alive

00:18:14,330 --> 00:18:19,940
every 60 seconds in this scenario and so

00:18:18,860 --> 00:18:22,490
now tada

00:18:19,940 --> 00:18:27,470
our connections are always alive always

00:18:22,490 --> 00:18:32,780
happy so we can also do according with

00:18:27,470 --> 00:18:35,660
with our sequel alchemy session so just

00:18:32,780 --> 00:18:38,300
like before or inside the context

00:18:35,660 --> 00:18:40,760
manager of the session we query for the

00:18:38,300 --> 00:18:42,350
user so we're just grabbing the user out

00:18:40,760 --> 00:18:45,200
of the database in this case and we

00:18:42,350 --> 00:18:47,120
specify a qualifier on that query one or

00:18:45,200 --> 00:18:50,030
none so what that's saying is we expect

00:18:47,120 --> 00:18:52,400
to get one user back or no users and

00:18:50,030 --> 00:18:54,590
there are many of these qualifier

00:18:52,400 --> 00:18:56,660
functions that we could use all count

00:18:54,590 --> 00:18:58,700
delete distinct exists first those are

00:18:56,660 --> 00:19:00,650
jo-ann limit buh-buh-buh-buh-buh and

00:18:58,700 --> 00:19:06,860
there's a bunch more of them in the docs

00:19:00,650 --> 00:19:10,610
that I have a link to there so um you

00:19:06,860 --> 00:19:14,270
can also if you desire print out the

00:19:10,610 --> 00:19:18,260
exact select statement that is used to

00:19:14,270 --> 00:19:20,210
core your database via this guy here so

00:19:18,260 --> 00:19:23,210
user statement compile pass on your

00:19:20,210 --> 00:19:24,590
engine and it'll spit out what the exact

00:19:23,210 --> 00:19:27,680
select statement was that was sent to

00:19:24,590 --> 00:19:30,920
the database which can be useful for

00:19:27,680 --> 00:19:32,780
debug another thing that I don't have on

00:19:30,920 --> 00:19:35,300
this slide that's also useful for debug

00:19:32,780 --> 00:19:37,100
is you may find yourself in a situation

00:19:35,300 --> 00:19:39,530
where you have some sort of monitoring

00:19:37,100 --> 00:19:43,220
in place and you're monitoring tells you

00:19:39,530 --> 00:19:44,990
that your you have a certain query in a

00:19:43,220 --> 00:19:48,470
request that's slow and it doesn't

00:19:44,990 --> 00:19:51,590
necessarily tell you which line in your

00:19:48,470 --> 00:19:53,720
code that query is coming from but it

00:19:51,590 --> 00:19:56,630
gives you the Select statement that it

00:19:53,720 --> 00:19:58,130
used so something you might do in

00:19:56,630 --> 00:20:00,320
development to kind of figure out where

00:19:58,130 --> 00:20:01,850
that line is coming from is if you turn

00:20:00,320 --> 00:20:03,500
the sequel alchemy

00:20:01,850 --> 00:20:06,380
about option on then it will print out

00:20:03,500 --> 00:20:08,900
all of your select statements that are

00:20:06,380 --> 00:20:10,190
used and run and so from there you can

00:20:08,900 --> 00:20:12,410
kind of like narrow it down it and find

00:20:10,190 --> 00:20:16,370
where that particular slow select

00:20:12,410 --> 00:20:20,720
statement is coming from and fix it so

00:20:16,370 --> 00:20:22,309
here um normally you do want to work in

00:20:20,720 --> 00:20:24,559
this way you don't necessarily want to

00:20:22,309 --> 00:20:27,260
start with a database that already has

00:20:24,559 --> 00:20:29,240
tables in it it's preferable to start

00:20:27,260 --> 00:20:30,620
with an empty database and you see who

00:20:29,240 --> 00:20:33,200
else we you should generate your tables

00:20:30,620 --> 00:20:35,210
although you don't have to and that's

00:20:33,200 --> 00:20:37,419
just to make sure that your models

00:20:35,210 --> 00:20:40,580
exactly match what's in your database

00:20:37,419 --> 00:20:43,940
but anyway so if we want to do that we

00:20:40,580 --> 00:20:47,090
import our models and then we use that

00:20:43,940 --> 00:20:48,970
base class and say base metadata create

00:20:47,090 --> 00:20:51,799
all and that will create all of our

00:20:48,970 --> 00:20:55,850
models as tables in our side our

00:20:51,799 --> 00:20:58,130
database so we've talked a lot about how

00:20:55,850 --> 00:21:02,809
to use sequel alchemy now let's talk

00:20:58,130 --> 00:21:05,480
about how to migrate data and so what is

00:21:02,809 --> 00:21:07,190
a data migration it's when we make or

00:21:05,480 --> 00:21:09,500
delete a new table I had to remove

00:21:07,190 --> 00:21:12,890
columns in a table modify existing data

00:21:09,500 --> 00:21:15,679
in a table and why is it important like

00:21:12,890 --> 00:21:21,020
why would we want to use a migration

00:21:15,679 --> 00:21:22,780
tool rather than just running a sequel

00:21:21,020 --> 00:21:26,840
statement directing on our database

00:21:22,780 --> 00:21:31,730
there are several reasons for this one

00:21:26,840 --> 00:21:35,299
is it allows us it prevents human errors

00:21:31,730 --> 00:21:38,140
so when once we write the script we

00:21:35,299 --> 00:21:41,210
write it in a script we know that it's

00:21:38,140 --> 00:21:42,559
correct we can test it locally to make

00:21:41,210 --> 00:21:46,070
sure that it works we can have our

00:21:42,559 --> 00:21:48,679
fellow developers review it before we

00:21:46,070 --> 00:21:52,990
run it and then when we run it on

00:21:48,679 --> 00:21:52,990
production we have some sort of

00:21:53,380 --> 00:21:58,760
guarantee that it's it's going to work

00:21:56,570 --> 00:22:01,490
as expected or at least that we have

00:21:58,760 --> 00:22:04,100
tested as much as we can and are more

00:22:01,490 --> 00:22:05,840
confident that it will work it also

00:22:04,100 --> 00:22:09,289
allows us to go out for a bit if it

00:22:05,840 --> 00:22:13,100
doesn't work migrate it back it gives us

00:22:09,289 --> 00:22:15,540
a path to revert that change so when you

00:22:13,100 --> 00:22:17,610
write a migration script the idea is

00:22:15,540 --> 00:22:20,490
but it is backwards and forward

00:22:17,610 --> 00:22:22,230
compatible meaning we can migrate to a

00:22:20,490 --> 00:22:24,780
new revision and we can also migrate

00:22:22,230 --> 00:22:26,550
back to your previous revision and so in

00:22:24,780 --> 00:22:29,130
that sense it is considered more safe

00:22:26,550 --> 00:22:36,480
because it doesn't work we can just roll

00:22:29,130 --> 00:22:38,690
it back um yeah so what database

00:22:36,480 --> 00:22:41,760
migration libraries are available to us

00:22:38,690 --> 00:22:44,160
we have Alembic Jenko migrations yo-yo

00:22:41,760 --> 00:22:45,750
database integration migrate seek

00:22:44,160 --> 00:22:47,940
welcome you migrate sequa migrate runner

00:22:45,750 --> 00:22:49,530
I'm sure there are more but today I'm

00:22:47,940 --> 00:22:53,340
gonna talk to you about Olympic it's

00:22:49,530 --> 00:22:54,990
pretty popular very and most people most

00:22:53,340 --> 00:22:59,190
Python developers I know unless they're

00:22:54,990 --> 00:23:02,310
using Django used olymic um so how to

00:22:59,190 --> 00:23:04,560
configure it's very simple um you can

00:23:02,310 --> 00:23:06,540
choose to or not provide a script

00:23:04,560 --> 00:23:14,480
location where your migration scripts

00:23:06,540 --> 00:23:18,120
will live and you also specify your

00:23:14,480 --> 00:23:22,590
database connection URL here and that's

00:23:18,120 --> 00:23:25,640
that's basically it you're done so let's

00:23:22,590 --> 00:23:28,080
take a look at an example so commonly

00:23:25,640 --> 00:23:31,380
database migrations just like when

00:23:28,080 --> 00:23:34,830
you're developing a feature they may

00:23:31,380 --> 00:23:37,980
take multiple PRS to get there or in

00:23:34,830 --> 00:23:41,040
this case multiple migrations to make or

00:23:37,980 --> 00:23:45,630
reach that final change or desired state

00:23:41,040 --> 00:23:48,720
so here for example we're adding a new

00:23:45,630 --> 00:23:50,460
organization table and the concept of

00:23:48,720 --> 00:23:52,410
organizations into our database and

00:23:50,460 --> 00:23:54,720
that's going to require several steps

00:23:52,410 --> 00:23:58,650
first we need to add the organization

00:23:54,720 --> 00:24:01,260
table into our database and then we need

00:23:58,650 --> 00:24:04,530
to define a relationship between the

00:24:01,260 --> 00:24:06,720
existing groups table and the new

00:24:04,530 --> 00:24:13,350
organization table and then finally

00:24:06,720 --> 00:24:16,860
we're going to default or define for all

00:24:13,350 --> 00:24:18,630
of our existing groups an organization

00:24:16,860 --> 00:24:21,450
that they belong to so basically no

00:24:18,630 --> 00:24:26,580
group is allowed to be without an

00:24:21,450 --> 00:24:28,200
organization and so let's get started um

00:24:26,580 --> 00:24:30,090
it's very simple to create a migration

00:24:28,200 --> 00:24:32,190
script we just do an Olympic revision

00:24:30,090 --> 00:24:33,630
and then we have the stashin this is

00:24:32,190 --> 00:24:35,760
basically the same thing as you would

00:24:33,630 --> 00:24:37,650
provide if you were doing a get commit

00:24:35,760 --> 00:24:39,780
it's just a simple little like

00:24:37,650 --> 00:24:42,420
description of the change that you're

00:24:39,780 --> 00:24:46,200
making and so that will spit out our

00:24:42,420 --> 00:24:49,230
hash of our revision number basically of

00:24:46,200 --> 00:24:51,500
our migration and then that simple

00:24:49,230 --> 00:24:54,240
little description of what it's doing

00:24:51,500 --> 00:24:55,470
into a Python file and let's take a look

00:24:54,240 --> 00:24:58,050
that Python file what does it look like

00:24:55,470 --> 00:24:59,730
so here it just provides your necks

00:24:58,050 --> 00:25:01,140
little template so we have an upgrade

00:24:59,730 --> 00:25:03,000
function and we have a downgrade

00:25:01,140 --> 00:25:05,850
function and those are left empty for us

00:25:03,000 --> 00:25:08,130
to fill out and then we also have this

00:25:05,850 --> 00:25:10,320
revision information at the top so we

00:25:08,130 --> 00:25:12,330
have revision which is the current

00:25:10,320 --> 00:25:13,920
revision of this particular migration

00:25:12,330 --> 00:25:15,060
and then we have it down revision so

00:25:13,920 --> 00:25:17,190
that's gonna point back to the previous

00:25:15,060 --> 00:25:18,780
revision which in this case is none

00:25:17,190 --> 00:25:21,690
because there aren't any previous

00:25:18,780 --> 00:25:23,820
revisions and so what this is gonna look

00:25:21,690 --> 00:25:25,320
like after we upgrade is the HUD

00:25:23,820 --> 00:25:27,260
revision is now going to point at our

00:25:25,320 --> 00:25:29,600
current revision and assuming we

00:25:27,260 --> 00:25:31,680
continue writing our migrations

00:25:29,600 --> 00:25:35,460
eventually you know the head will point

00:25:31,680 --> 00:25:39,270
at some later revision so let's fill out

00:25:35,460 --> 00:25:41,520
that function for adding a organization

00:25:39,270 --> 00:25:45,060
table into our database so what this

00:25:41,520 --> 00:25:48,780
looks like is we import Olympic and then

00:25:45,060 --> 00:25:51,060
we call create table and we provide the

00:25:48,780 --> 00:25:54,090
following information it's gonna have an

00:25:51,060 --> 00:25:55,770
ID a name and logo column and then of

00:25:54,090 --> 00:26:00,020
course on downgrade what do we want to

00:25:55,770 --> 00:26:03,390
do we just want to delete that table so

00:26:00,020 --> 00:26:05,010
one thing don't forget don't forget to

00:26:03,390 --> 00:26:08,250
you add you go or sequel alchemy model

00:26:05,010 --> 00:26:10,170
for this right um we migrated our

00:26:08,250 --> 00:26:11,340
database but we also want to add that

00:26:10,170 --> 00:26:15,990
model into our code so that we can

00:26:11,340 --> 00:26:18,810
actually use it so running the script um

00:26:15,990 --> 00:26:19,440
we're just say LM back upgrade head and

00:26:18,810 --> 00:26:22,940
tada

00:26:19,440 --> 00:26:26,240
it is pointing at our latest revision

00:26:22,940 --> 00:26:29,790
but oh my gosh everything is broken ah

00:26:26,240 --> 00:26:32,250
it's okay because we can downgrade it

00:26:29,790 --> 00:26:35,820
very simple and tada

00:26:32,250 --> 00:26:38,810
we're safe we have avoided major

00:26:35,820 --> 00:26:38,810
problems in production

00:26:39,660 --> 00:26:44,730
so let's do the next migration here

00:26:42,840 --> 00:26:50,250
which is we're going to modify the

00:26:44,730 --> 00:26:54,030
existing group table and in this

00:26:50,250 --> 00:26:56,100
situation the group is going to point to

00:26:54,030 --> 00:26:57,570
or belong to an organization right so

00:26:56,100 --> 00:27:00,150
we're defining relationship between the

00:26:57,570 --> 00:27:01,290
group and organization tables and so

00:27:00,150 --> 00:27:03,960
what does that look like in terms of

00:27:01,290 --> 00:27:06,300
code we're going to add a column to the

00:27:03,960 --> 00:27:08,220
group table called organization ID

00:27:06,300 --> 00:27:11,130
that's going to be a foreign key of

00:27:08,220 --> 00:27:13,470
organization dot ID and what do we want

00:27:11,130 --> 00:27:18,540
to do or me downgrade it we just want to

00:27:13,470 --> 00:27:20,700
drop that column and of course don't

00:27:18,540 --> 00:27:24,900
forget to add guests relationship into

00:27:20,700 --> 00:27:27,990
your group model all right and finally

00:27:24,900 --> 00:27:30,210
we are going to modify data on

00:27:27,990 --> 00:27:33,540
production a terrifying but it's gonna

00:27:30,210 --> 00:27:35,040
be great um so we're just gonna take all

00:27:33,540 --> 00:27:37,980
of our existing groups that we have in

00:27:35,040 --> 00:27:41,010
production and migrate then to belong to

00:27:37,980 --> 00:27:42,630
a default organization so if the group

00:27:41,010 --> 00:27:43,860
doesn't already belong to a default or

00:27:42,630 --> 00:27:46,950
it doesn't already belong to an

00:27:43,860 --> 00:27:50,370
organization then we're going to grab it

00:27:46,950 --> 00:27:53,430
and we're going to set the organization

00:27:50,370 --> 00:27:55,980
to our default organization and notice

00:27:53,430 --> 00:27:59,250
that we've left our downgrade function

00:27:55,980 --> 00:28:02,880
empty in this case this is a little

00:27:59,250 --> 00:28:04,590
tricky um but this is kind of one of

00:28:02,880 --> 00:28:07,200
those migrations that's going to be very

00:28:04,590 --> 00:28:08,460
difficult to undo later on because

00:28:07,200 --> 00:28:10,920
murmur groups are going to be added

00:28:08,460 --> 00:28:13,260
they're going to belong to perhaps an

00:28:10,920 --> 00:28:15,390
evil organization perhaps not so if we

00:28:13,260 --> 00:28:17,670
really wanted to downgrade this properly

00:28:15,390 --> 00:28:19,320
what we would have to do is when the

00:28:17,670 --> 00:28:21,390
script ran on production we would have

00:28:19,320 --> 00:28:23,790
to log and keep track of all the groups

00:28:21,390 --> 00:28:26,880
that we modified and set to a default

00:28:23,790 --> 00:28:30,480
organization and then add those into the

00:28:26,880 --> 00:28:32,670
downgrade function and then that would

00:28:30,480 --> 00:28:36,510
define our downgrade and then we would

00:28:32,670 --> 00:28:38,640
truly be able to undo this change but in

00:28:36,510 --> 00:28:41,790
this situation elected not to do that

00:28:38,640 --> 00:28:43,200
wasn't really necessary the way we would

00:28:41,790 --> 00:28:45,630
kind of like undo this change of who

00:28:43,200 --> 00:28:48,510
we're gonna do it is basically just wipe

00:28:45,630 --> 00:28:51,900
out all the groups belonging to an

00:28:48,510 --> 00:28:52,710
organization but something to point out

00:28:51,900 --> 00:28:57,570
here is

00:28:52,710 --> 00:28:59,429
um we are using models here we're using

00:28:57,570 --> 00:29:01,409
the organization model and we're also

00:28:59,429 --> 00:29:02,520
using the group model and so what you

00:29:01,409 --> 00:29:05,220
might be tempted as you do is something

00:29:02,520 --> 00:29:07,950
like this where we just import from our

00:29:05,220 --> 00:29:09,450
existing models in our code but that is

00:29:07,950 --> 00:29:12,000
a big mistake you don't want to do that

00:29:09,450 --> 00:29:13,500
and that's because those models may

00:29:12,000 --> 00:29:17,539
change over time right those are not

00:29:13,500 --> 00:29:21,510
necessarily static and this migration

00:29:17,539 --> 00:29:23,010
assumes that those models look a certain

00:29:21,510 --> 00:29:26,039
way it assumes that they have certain

00:29:23,010 --> 00:29:27,870
columns and in two years from now those

00:29:26,039 --> 00:29:29,940
columns might not actually exist in

00:29:27,870 --> 00:29:32,309
those models and we always want our

00:29:29,940 --> 00:29:34,470
migration or migration script should

00:29:32,309 --> 00:29:38,490
work for years to come we should be able

00:29:34,470 --> 00:29:42,299
to two years from now revert this

00:29:38,490 --> 00:29:50,220
migration if we want to and so in order

00:29:42,299 --> 00:29:52,169
to do that um we define instead define

00:29:50,220 --> 00:29:55,770
our models inside of this migration and

00:29:52,169 --> 00:29:59,299
this will ensure that we can run this

00:29:55,770 --> 00:29:59,299
migration script in two or three years

00:30:00,020 --> 00:30:03,690
all right

00:30:01,370 --> 00:30:06,210
lastly I wanted to just talk about a

00:30:03,690 --> 00:30:07,890
couple issues you might encounter

00:30:06,210 --> 00:30:11,309
receivable alchemy in the real world

00:30:07,890 --> 00:30:15,080
um and one of these is lazy loading so

00:30:11,309 --> 00:30:21,919
what is lazy loading okay say loading

00:30:15,080 --> 00:30:26,970
looks like this so we say we pull a

00:30:21,919 --> 00:30:29,970
group out of our database and then this

00:30:26,970 --> 00:30:31,830
group has a list of members on it and so

00:30:29,970 --> 00:30:34,200
that list of members are a bunch of user

00:30:31,830 --> 00:30:36,179
objects and so then we might do

00:30:34,200 --> 00:30:41,460
something like this with the group

00:30:36,179 --> 00:30:45,630
members where we grab the name from each

00:30:41,460 --> 00:30:48,870
one of those members and so you might

00:30:45,630 --> 00:30:50,130
expect that this would just go ahead and

00:30:48,870 --> 00:30:52,470
grab all those members in the first

00:30:50,130 --> 00:30:53,870
query and so you might expect this to

00:30:52,470 --> 00:30:56,130
just be a single query to the database

00:30:53,870 --> 00:31:00,570
but in fact what this actually looks

00:30:56,130 --> 00:31:03,149
like is it received alchemy lazily loads

00:31:00,570 --> 00:31:04,179
things so it doesn't query for extra

00:31:03,149 --> 00:31:06,730
stuff until it

00:31:04,179 --> 00:31:11,230
says that you need it and so this has

00:31:06,730 --> 00:31:13,119
the unfortunate symptom of running the

00:31:11,230 --> 00:31:15,490
initial quarry for the group and then

00:31:13,119 --> 00:31:17,619
when you actually need the members then

00:31:15,490 --> 00:31:20,799
quarry ating for those members and so

00:31:17,619 --> 00:31:23,830
what this actually results in is a the

00:31:20,799 --> 00:31:25,690
the number of queries blows up so

00:31:23,830 --> 00:31:28,720
instead of having a single query to the

00:31:25,690 --> 00:31:30,220
database now we have one plus the number

00:31:28,720 --> 00:31:31,600
of member queries to the database and

00:31:30,220 --> 00:31:33,460
you can imagine that if we have a

00:31:31,600 --> 00:31:37,629
hundred members this is going to be very

00:31:33,460 --> 00:31:40,990
very very bad and so how we come back to

00:31:37,629 --> 00:31:43,889
this problem is we use this join load

00:31:40,990 --> 00:31:47,619
function and sequel alchemy we just say

00:31:43,889 --> 00:31:51,580
grab those members upfront and join them

00:31:47,619 --> 00:31:53,200
with with this initial query and so then

00:31:51,580 --> 00:31:55,539
in this situation and see Gwaltney it's

00:31:53,200 --> 00:31:56,889
gonna go okay I see that you really do

00:31:55,539 --> 00:31:58,779
you want me to query for all those

00:31:56,889 --> 00:32:01,659
members in this initial query and it

00:31:58,779 --> 00:32:06,009
goes ahead and populates that members

00:32:01,659 --> 00:32:07,389
list with the user objects so another

00:32:06,009 --> 00:32:09,519
problem you might encounter in the wild

00:32:07,389 --> 00:32:11,830
although this is very rare it does

00:32:09,519 --> 00:32:14,740
sometimes happen occasionally sequel

00:32:11,830 --> 00:32:17,369
alchemy will unexpectedly generate a

00:32:14,740 --> 00:32:20,470
query that you did not intend it to do

00:32:17,369 --> 00:32:23,830
which in some situations can be a very

00:32:20,470 --> 00:32:25,779
not performance quarry so here basically

00:32:23,830 --> 00:32:29,820
we're just trying to count up all the

00:32:25,779 --> 00:32:32,259
annotations that a user has created and

00:32:29,820 --> 00:32:34,869
unfortunately in the situation this

00:32:32,259 --> 00:32:37,119
quarry ends up looking like a nested

00:32:34,869 --> 00:32:41,740
Select statement which is very not

00:32:37,119 --> 00:32:45,279
performant and so instead what we would

00:32:41,740 --> 00:32:49,899
like to do we have to tell sequel

00:32:45,279 --> 00:32:52,059
alchemy to do something a little

00:32:49,899 --> 00:32:54,639
different so we import this funk count

00:32:52,059 --> 00:32:57,399
and then we tell it to count all the

00:32:54,639 --> 00:32:58,869
annotations IDs and then we can see that

00:32:57,399 --> 00:33:00,369
our select statement is as we would

00:32:58,869 --> 00:33:02,740
expect it to be and it's a nice

00:33:00,369 --> 00:33:05,259
performance select statement so in

00:33:02,740 --> 00:33:07,149
review things we have covered building

00:33:05,259 --> 00:33:08,590
models types of indexing connecting to

00:33:07,149 --> 00:33:10,899
the database connection pools keep a

00:33:08,590 --> 00:33:13,059
lives building queries database

00:33:10,899 --> 00:33:15,450
migrations and some gotchas with sequel

00:33:13,059 --> 00:33:17,409
alchemy I hope this talk has been

00:33:15,450 --> 00:33:17,710
beneficial to you and that you've

00:33:17,409 --> 00:33:19,510
learned

00:33:17,710 --> 00:33:21,820
something if you have any questions

00:33:19,510 --> 00:33:24,929
leave them in the comments and I will

00:33:21,820 --> 00:33:24,929

YouTube URL: https://www.youtube.com/watch?v=36yw8VC3KU8


