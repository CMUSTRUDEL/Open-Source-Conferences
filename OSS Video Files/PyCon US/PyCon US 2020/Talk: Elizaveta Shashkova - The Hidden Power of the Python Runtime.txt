Title: Talk: Elizaveta Shashkova - The Hidden Power of the Python Runtime
Publication date: 2021-05-05
Playlist: PyCon US 2020
Description: 
	Presented by:
Elizaveta Shashkova

Many people like Python for its simplicity and beauty. But every statement in Python, even the simple one, produces a lot of events during the program execution. These events are usually hidden from a user, so it helps developers to skip low-level implementation details and focus on bigger things.

At the same time many parts of this hidden information are very useful and interesting to examine. The good news is that the Python Runtime allows to retrieve it really simply, so there is no need to configure additional libraries or pass additional parameters to interpreter. Everybody can do it right inside their Python code.

During this talk we will learn how Python allows to inspect current program state during the execution. We will learn about Python memory model, variables, frame objects and about useful information they store. After that we will discuss several powerful tools which are based on the runtime information and which can be very helpful for any Python programmer in their everyday life.

Slides: https://speakerdeck.com/elizaveta239/the-hidden-power-of-the-python-runtime
Examples source code: https://github.com/Elizaveta239/PyRuntimeTricks
Captions: 
	00:00:11,900 --> 00:00:18,779
hi my name is Elizabeth Kola and today I

00:00:16,350 --> 00:00:22,560
would like to present my dog the hidden

00:00:18,779 --> 00:00:24,450
power of the Pythian rant I am a

00:00:22,560 --> 00:00:27,599
software developer and working on

00:00:24,450 --> 00:00:29,460
jetbrains on the by term IDE I've been

00:00:27,599 --> 00:00:32,009
working on debugger for several years

00:00:29,460 --> 00:00:33,559
and now I'm focused on scientific

00:00:32,009 --> 00:00:36,270
features in biter

00:00:33,559 --> 00:00:39,059
currently I'm located in the Russian

00:00:36,270 --> 00:00:44,030
cities st. Petersburg and recording this

00:00:39,059 --> 00:00:46,650
talk right from my home so let's start

00:00:44,030 --> 00:00:49,350
by the language is very simple and

00:00:46,650 --> 00:00:52,080
beautiful but we're a big part of the

00:00:49,350 --> 00:00:54,690
language power is hidden from user and

00:00:52,080 --> 00:00:55,740
available on the at runtime on line

00:00:54,690 --> 00:00:58,829
during execution

00:00:55,740 --> 00:01:01,920
you might even don't know about it but

00:00:58,829 --> 00:01:05,689
you already use this hidden power every

00:01:01,920 --> 00:01:09,329
day for example we run tests every day

00:01:05,689 --> 00:01:11,759
let's compare two popular ways to do it

00:01:09,329 --> 00:01:15,440
in Python standard module unit tests or

00:01:11,759 --> 00:01:17,670
very popular test framework by tests

00:01:15,440 --> 00:01:20,070
biggest way to see the difference

00:01:17,670 --> 00:01:23,970
between them is to execute assert

00:01:20,070 --> 00:01:26,729
statements in case of failure unit tests

00:01:23,970 --> 00:01:29,040
will report assertion exception and will

00:01:26,729 --> 00:01:33,630
show you a place where it happened just

00:01:29,040 --> 00:01:36,240
like any other exception button but by

00:01:33,630 --> 00:01:38,930
test will show you detailed information

00:01:36,240 --> 00:01:41,700
about values we should try to compare

00:01:38,930 --> 00:01:46,440
where did fighters get this information

00:01:41,700 --> 00:01:49,110
of course from the runtime and today in

00:01:46,440 --> 00:01:51,690
this talk we will learn how Python

00:01:49,110 --> 00:01:54,299
runtime works how Python allows to

00:01:51,690 --> 00:01:56,340
inspect current program State and how

00:01:54,299 --> 00:01:59,100
runtime information can be used in

00:01:56,340 --> 00:02:03,600
different development tools including

00:01:59,100 --> 00:02:06,090
biased assertion errors reporting let's

00:02:03,600 --> 00:02:08,819
start with learning about fundamental

00:02:06,090 --> 00:02:12,230
concepts of Python runtime

00:02:08,819 --> 00:02:15,689
there is popular popular phrase that

00:02:12,230 --> 00:02:18,870
everything is an object in viola that

00:02:15,689 --> 00:02:21,269
means that every variable even isn't

00:02:18,870 --> 00:02:23,879
just a simple piece of memory but a

00:02:21,269 --> 00:02:28,709
complicated entity with barriers and

00:02:23,879 --> 00:02:31,230
associated operations this object base

00:02:28,709 --> 00:02:34,109
nature is true not only for core types

00:02:31,230 --> 00:02:36,359
like numbers or strings or collections

00:02:34,109 --> 00:02:39,030
or something else but it's also true for

00:02:36,359 --> 00:02:43,109
program unit objects like functions

00:02:39,030 --> 00:02:45,290
classes and even modules all this types

00:02:43,109 --> 00:02:48,569
of objects are declared explicitly

00:02:45,290 --> 00:02:51,060
interpreter creates your object when you

00:02:48,569 --> 00:02:53,159
use assignment statement or when you

00:02:51,060 --> 00:02:56,669
declare your function with DEF keyword

00:02:53,159 --> 00:03:00,060
or when you declare new class with class

00:02:56,669 --> 00:03:02,629
keyword but during the program execution

00:03:00,060 --> 00:03:05,219
by the interpreter creates not only

00:03:02,629 --> 00:03:08,459
objects which you defined explicitly in

00:03:05,219 --> 00:03:10,469
your code it also creates a lot of util

00:03:08,459 --> 00:03:14,790
objects representing execution process

00:03:10,469 --> 00:03:17,879
and one of the key objects among them is

00:03:14,790 --> 00:03:21,180
a stack frame staggering object

00:03:17,879 --> 00:03:22,799
represents a program scope invite this

00:03:21,180 --> 00:03:26,549
object contains information about

00:03:22,799 --> 00:03:29,400
current execution state like code object

00:03:26,549 --> 00:03:32,699
to local and global variables and a lot

00:03:29,400 --> 00:03:35,280
of other data frames are stored in a

00:03:32,699 --> 00:03:37,470
stack like structure the bottom was

00:03:35,280 --> 00:03:39,989
framed sometimes called a model frame

00:03:37,470 --> 00:03:42,689
represent a threat and Morial from which

00:03:39,989 --> 00:03:45,299
execution was started in this example

00:03:42,689 --> 00:03:50,159
execution process is from the line 7 and

00:03:45,299 --> 00:03:52,319
it's going to call function flow when by

00:03:50,159 --> 00:03:55,349
the interpreter enters new scope during

00:03:52,319 --> 00:03:59,280
execution it creates new frame object

00:03:55,349 --> 00:04:03,689
and then puts it onto the stack on top

00:03:59,280 --> 00:04:06,719
on other frames when execution process

00:04:03,689 --> 00:04:09,900
leaves the scope in our example returns

00:04:06,719 --> 00:04:12,900
from function foo interpreter removes

00:04:09,900 --> 00:04:16,889
frame object from the top and passes

00:04:12,900 --> 00:04:19,590
some data to the previous Ray Allen tech

00:04:16,889 --> 00:04:21,690
security previous frame continuous and

00:04:19,590 --> 00:04:26,530
goes to the line 8

00:04:21,690 --> 00:04:29,650
and and that's it this is a very rough

00:04:26,530 --> 00:04:33,340
description but the main idea looks like

00:04:29,650 --> 00:04:36,250
this in fact these runtime machinery and

00:04:33,340 --> 00:04:38,500
the concept of whole stack are the same

00:04:36,250 --> 00:04:41,680
for many other programming languages but

00:04:38,500 --> 00:04:44,590
the major difference between them and by

00:04:41,680 --> 00:04:47,800
them is that not so many languages

00:04:44,590 --> 00:04:51,639
contain this runtime information out of

00:04:47,800 --> 00:04:54,330
the box in Python frame objects can be

00:04:51,639 --> 00:04:56,500
accessed as a usual Python objects

00:04:54,330 --> 00:04:58,210
writing your program and you can

00:04:56,500 --> 00:05:00,240
retrieve a lot of interesting

00:04:58,210 --> 00:05:03,580
information from it

00:05:00,240 --> 00:05:06,580
the next part we will learn how we can

00:05:03,580 --> 00:05:10,270
do it how we can inspect internal

00:05:06,580 --> 00:05:12,250
execution state as we discussed in the

00:05:10,270 --> 00:05:14,860
previous part the key concept of the

00:05:12,250 --> 00:05:16,659
execution process is a stack frame in

00:05:14,860 --> 00:05:18,969
any place of your program you can get

00:05:16,659 --> 00:05:21,610
the current stack frame by calling

00:05:18,969 --> 00:05:25,000
function get frame from standard module

00:05:21,610 --> 00:05:27,069
sis this function returns a frame object

00:05:25,000 --> 00:05:29,740
from the call stack what a current

00:05:27,069 --> 00:05:32,949
thread it has an optional argument depth

00:05:29,740 --> 00:05:36,370
which determines adapt in a stack that

00:05:32,949 --> 00:05:38,710
is a number of calls below the top so if

00:05:36,370 --> 00:05:42,969
you pass zero to this function you get

00:05:38,710 --> 00:05:45,639
the current frame object let's check

00:05:42,969 --> 00:05:49,180
which information is stored inside frame

00:05:45,639 --> 00:05:51,430
object first of all frame object

00:05:49,180 --> 00:05:53,860
contains the dictionary with local

00:05:51,430 --> 00:05:56,440
variables of the current scope if you

00:05:53,860 --> 00:05:59,199
define some variable you can access it

00:05:56,440 --> 00:06:01,659
by its name it's just a usual dictionary

00:05:59,199 --> 00:06:04,150
you can iterate over it but you can't

00:06:01,659 --> 00:06:08,529
update it from Python code it's possible

00:06:04,150 --> 00:06:10,779
to do only from C API also frame object

00:06:08,529 --> 00:06:12,639
gives you access to global variables

00:06:10,779 --> 00:06:15,039
dictionary when we are talking about

00:06:12,639 --> 00:06:18,219
global variables we mean global

00:06:15,039 --> 00:06:20,710
variables for the current model now we

00:06:18,219 --> 00:06:25,870
know how to get information about

00:06:20,710 --> 00:06:28,090
defined variables qu but to be honest we

00:06:25,870 --> 00:06:30,370
don't need frame object to get this

00:06:28,090 --> 00:06:32,680
information because there are built-in

00:06:30,370 --> 00:06:36,460
functions locals and Global's which

00:06:32,680 --> 00:06:37,930
return exactly the same dictionaries the

00:06:36,460 --> 00:06:39,940
good news is that for a boss

00:06:37,930 --> 00:06:43,289
dictionaries isn't the only interesting

00:06:39,940 --> 00:06:46,270
information stored inside frame object

00:06:43,289 --> 00:06:48,669
the second interesting thing is a code

00:06:46,270 --> 00:06:52,599
object which is also stored as a frame

00:06:48,669 --> 00:06:54,880
attribute code object represents a chunk

00:06:52,599 --> 00:06:57,580
of executable code but it differs from

00:06:54,880 --> 00:06:59,229
function object because it doesn't

00:06:57,580 --> 00:07:02,500
contain reference to the global

00:06:59,229 --> 00:07:05,020
execution environment the easiest way to

00:07:02,500 --> 00:07:08,560
create code object is to call a built-in

00:07:05,020 --> 00:07:10,899
function compile compile code object can

00:07:08,560 --> 00:07:13,389
also be evaluated by passing it to

00:07:10,899 --> 00:07:15,520
built-in function eval you can see here

00:07:13,389 --> 00:07:20,169
an example we've alleged value of our

00:07:15,520 --> 00:07:22,779
code object C code object contains a lot

00:07:20,169 --> 00:07:24,699
of information as well it's a file name

00:07:22,779 --> 00:07:28,570
where this code object was created a

00:07:24,699 --> 00:07:31,690
name of a function or Morial where it

00:07:28,570 --> 00:07:35,199
was defined a list of variables names

00:07:31,690 --> 00:07:37,990
which were used inside this code it also

00:07:35,199 --> 00:07:40,570
contains a byte code object a sequence

00:07:37,990 --> 00:07:42,399
of executable statements with the help

00:07:40,570 --> 00:07:45,099
of function disks from the standard

00:07:42,399 --> 00:07:47,860
module disk you can even disassemble it

00:07:45,099 --> 00:07:50,770
and read comments which were generated

00:07:47,860 --> 00:07:53,440
by the interpreter called object

00:07:50,770 --> 00:07:57,060
contains much more attributes but these

00:07:53,440 --> 00:08:00,310
are the most important for us today

00:07:57,060 --> 00:08:02,440
let's return to a frame object in

00:08:00,310 --> 00:08:05,169
addition to variables and code object

00:08:02,440 --> 00:08:06,819
frame also stores information about

00:08:05,169 --> 00:08:09,399
current line number which is being

00:08:06,819 --> 00:08:12,069
executed it stores a tracing function

00:08:09,399 --> 00:08:14,919
which helps to trace advance in the

00:08:12,069 --> 00:08:18,339
current prop frame and which we will

00:08:14,919 --> 00:08:22,120
discuss later and it also tours a link

00:08:18,339 --> 00:08:24,669
to the previously as you remember frames

00:08:22,120 --> 00:08:27,219
are stored in a stack like data

00:08:24,669 --> 00:08:29,770
structure and the easiest way to inspect

00:08:27,219 --> 00:08:32,770
state of the current frames is to

00:08:29,770 --> 00:08:35,649
iterate over them with the link to the

00:08:32,770 --> 00:08:38,319
previous frame this is exactly how

00:08:35,649 --> 00:08:40,689
exception trains backwards one exception

00:08:38,319 --> 00:08:42,880
was raised in your program and if it

00:08:40,689 --> 00:08:45,250
wasn't handled then prints these

00:08:42,880 --> 00:08:48,009
beautiful trace bags into

00:08:45,250 --> 00:08:49,600
good so you can understand how you reach

00:08:48,009 --> 00:08:53,350
these places

00:08:49,600 --> 00:08:55,720
frame objects and links between them is

00:08:53,350 --> 00:09:00,759
a mechanism which helps to get this

00:08:55,720 --> 00:09:02,680
information and show it to you unless

00:09:00,759 --> 00:09:05,620
it's only the most important information

00:09:02,680 --> 00:09:08,319
stored in a frame object but not all the

00:09:05,620 --> 00:09:11,500
information many useful functions are

00:09:08,319 --> 00:09:14,529
implemented in inspect standard module

00:09:11,500 --> 00:09:16,899
it has a whole separate group of

00:09:14,529 --> 00:09:20,170
functions for examining the interpreter

00:09:16,899 --> 00:09:22,149
stack but one important thing which you

00:09:20,170 --> 00:09:25,240
should remember when you work with frame

00:09:22,149 --> 00:09:27,250
variable is that you shouldn't forget to

00:09:25,240 --> 00:09:30,100
delete this variable when you're leaving

00:09:27,250 --> 00:09:32,769
the scope otherwise you can create a

00:09:30,100 --> 00:09:36,310
reference cycles and these objects will

00:09:32,769 --> 00:09:39,490
stay live much longer it can lead to the

00:09:36,310 --> 00:09:44,199
late objects destruction and even memory

00:09:39,490 --> 00:09:46,990
consumptions okay in this part we've

00:09:44,199 --> 00:09:49,000
learned that when we write an execute

00:09:46,990 --> 00:09:51,009
our Python code we might even don't

00:09:49,000 --> 00:09:54,220
think about how many interesting objects

00:09:51,009 --> 00:09:58,269
were implicitly generated by our source

00:09:54,220 --> 00:10:00,540
code that's great but how can we use it

00:09:58,269 --> 00:10:04,240
in our everyday lives

00:10:00,540 --> 00:10:05,889
the next part will learn how different

00:10:04,240 --> 00:10:08,439
development tools use this information

00:10:05,889 --> 00:10:13,329
to help you to become more productive

00:10:08,439 --> 00:10:15,490
when you are working with Python code as

00:10:13,329 --> 00:10:17,680
you remember in the beginning of this

00:10:15,490 --> 00:10:20,769
talk we've learned that violence can

00:10:17,680 --> 00:10:23,889
show a certain error with exact values

00:10:20,769 --> 00:10:26,139
which were compared now we have enough

00:10:23,889 --> 00:10:28,990
knowledge to understand how it was

00:10:26,139 --> 00:10:30,910
implemented let's create our own tool

00:10:28,990 --> 00:10:34,329
which will be showing values of

00:10:30,910 --> 00:10:37,509
variables which were used inside a third

00:10:34,329 --> 00:10:40,540
statement cover exceptional object

00:10:37,509 --> 00:10:43,329
stores a traceback object in dunder

00:10:40,540 --> 00:10:45,160
trees back attribute and trace back

00:10:43,329 --> 00:10:49,389
contains the most important for us

00:10:45,160 --> 00:10:51,910
object frame object and we already know

00:10:49,389 --> 00:10:54,579
you have access to frame object we know

00:10:51,910 --> 00:10:58,420
everything about program state

00:10:54,579 --> 00:11:00,480
and our function will look like this it

00:10:58,420 --> 00:11:03,489
takes exception object as an argument

00:11:00,480 --> 00:11:06,489
from exception object we can get trace

00:11:03,489 --> 00:11:09,939
back and free drawn frame we can get

00:11:06,489 --> 00:11:13,389
code object and from code object we can

00:11:09,939 --> 00:11:16,499
get everything for example a source code

00:11:13,389 --> 00:11:20,259
we know line um where exception happened

00:11:16,499 --> 00:11:22,929
we have a source code so with the help

00:11:20,259 --> 00:11:26,110
of standard module a steep we can get

00:11:22,929 --> 00:11:28,989
variables names used exactly on this

00:11:26,110 --> 00:11:31,689
line I don't show you this function here

00:11:28,989 --> 00:11:34,329
you can find its source code in my

00:11:31,689 --> 00:11:38,679
repository with examples I'll share the

00:11:34,329 --> 00:11:43,839
link in the end of my talk but we in get

00:11:38,679 --> 00:11:45,850
names of these variables we can that

00:11:43,839 --> 00:11:49,029
means that we can find variables values

00:11:45,850 --> 00:11:51,670
for these names because we have a

00:11:49,029 --> 00:11:55,569
dictionary with local variables inside

00:11:51,670 --> 00:11:58,209
our frame object and this is how it

00:11:55,569 --> 00:12:00,309
works we can use our function the

00:11:58,209 --> 00:12:03,759
following way and during exception

00:12:00,309 --> 00:12:06,910
handling we should pass exception object

00:12:03,759 --> 00:12:09,970
to our new function and it will print

00:12:06,910 --> 00:12:13,269
variables values to the output even

00:12:09,970 --> 00:12:16,089
without by rest it can be very helpful

00:12:13,269 --> 00:12:18,970
for example for logging if stack trace

00:12:16,089 --> 00:12:21,429
isn't enough you can optimally lock all

00:12:18,970 --> 00:12:25,480
the variables values used inside failed

00:12:21,429 --> 00:12:27,970
assertion statement and get all the all

00:12:25,480 --> 00:12:33,429
this information and of course it can be

00:12:27,970 --> 00:12:36,249
extended to any other exception type so

00:12:33,429 --> 00:12:38,259
as you can see with the knowledge about

00:12:36,249 --> 00:12:41,949
Python runtime you can create some

00:12:38,259 --> 00:12:44,410
really cool tools course our function is

00:12:41,949 --> 00:12:47,410
much less powerful than functions

00:12:44,410 --> 00:12:51,790
implemented and biased but the main idea

00:12:47,410 --> 00:12:54,339
is very very similar the second tool

00:12:51,790 --> 00:12:57,429
which have the relies on runtime is

00:12:54,339 --> 00:12:59,919
debugger as I've already sat in the

00:12:57,429 --> 00:13:01,869
beginning of my talk I've been working

00:12:59,919 --> 00:13:04,480
on my charms bugger for several years

00:13:01,869 --> 00:13:07,029
and the reason why I know so much

00:13:04,480 --> 00:13:08,720
information hidden inside frame object

00:13:07,029 --> 00:13:11,899
is that debuggers

00:13:08,720 --> 00:13:15,110
one of the main tools which use this

00:13:11,899 --> 00:13:17,600
information nowadays the buyers are

00:13:15,110 --> 00:13:20,269
based in one of two main functions

00:13:17,600 --> 00:13:23,149
tracing function and frame evaluation

00:13:20,269 --> 00:13:25,459
function when tracing frontier was set

00:13:23,149 --> 00:13:27,649
for the frame it will be called for

00:13:25,459 --> 00:13:30,980
every event which happens in the program

00:13:27,649 --> 00:13:31,600
it takes three arguments frame vant and

00:13:30,980 --> 00:13:34,699
Arg

00:13:31,600 --> 00:13:38,089
if tracing function was specified frame

00:13:34,699 --> 00:13:41,209
object stores a link to it in F trace

00:13:38,089 --> 00:13:43,040
attribute to buy based on tracing

00:13:41,209 --> 00:13:45,589
function analyzes surveillance in the

00:13:43,040 --> 00:13:48,319
program which arrived to tracing

00:13:45,589 --> 00:13:52,509
function and suspense the program in a

00:13:48,319 --> 00:13:55,399
place where user put their breakpoint

00:13:52,509 --> 00:13:58,459
frame evolution function has the

00:13:55,399 --> 00:14:02,029
following signature frame illusion

00:13:58,459 --> 00:14:05,750
function is being executed before the

00:14:02,029 --> 00:14:07,879
frame started to execute debugger based

00:14:05,750 --> 00:14:11,360
on frame evaluation function inserts

00:14:07,879 --> 00:14:14,779
breakpoints code write into frames code

00:14:11,360 --> 00:14:17,089
object we are not going to discuss its

00:14:14,779 --> 00:14:19,550
its internals now if you want to learn

00:14:17,089 --> 00:14:24,040
more about it feel free to watch my talk

00:14:19,550 --> 00:14:29,240
drum icon US 2017 debugging with python

00:14:24,040 --> 00:14:31,910
3.6 but what we are interested in now is

00:14:29,240 --> 00:14:35,120
that both of these functions take frame

00:14:31,910 --> 00:14:36,949
object as an argument and all the things

00:14:35,120 --> 00:14:40,550
we've learned in the previous part

00:14:36,949 --> 00:14:44,180
how do bugger to show information to

00:14:40,550 --> 00:14:46,670
user frame of jack how did the mugger to

00:14:44,180 --> 00:14:50,029
understand whether execution reached a

00:14:46,670 --> 00:14:54,079
breakpoint and highlight corresponding

00:14:50,029 --> 00:14:56,930
line in the editor / abel spain where

00:14:54,079 --> 00:15:01,339
you see values of the local variables is

00:14:56,930 --> 00:15:04,160
based on frame F locals dictionary and

00:15:01,339 --> 00:15:06,740
list of frames which is see during your

00:15:04,160 --> 00:15:09,860
debug session is also received from

00:15:06,740 --> 00:15:14,240
frame object by iterating over frame of

00:15:09,860 --> 00:15:17,959
back attributes as you can see

00:15:14,240 --> 00:15:20,720
information stored inside frames hug the

00:15:17,959 --> 00:15:22,460
buyer to work and show you information

00:15:20,720 --> 00:15:27,670
about current programs

00:15:22,460 --> 00:15:31,220
it but there are also some other tones

00:15:27,670 --> 00:15:33,620
another tool is a card coverage cork

00:15:31,220 --> 00:15:36,560
which helps you to understand which

00:15:33,620 --> 00:15:40,460
lines in your codebase were executed

00:15:36,560 --> 00:15:43,370
during run and check for example were

00:15:40,460 --> 00:15:45,080
they covered with tests or not it's a

00:15:43,370 --> 00:15:48,140
very important tool because it gives you

00:15:45,080 --> 00:15:52,250
a confidence that your codebase is well

00:15:48,140 --> 00:15:54,830
developed and maintained most popular

00:15:52,250 --> 00:15:58,160
popular library for code coverage is

00:15:54,830 --> 00:15:58,670
coverage data it has extremely cute

00:15:58,160 --> 00:16:02,390
mascot

00:15:58,670 --> 00:16:04,670
sleepy-bye coverage dot dot pi is based

00:16:02,390 --> 00:16:07,940
on the same tracing function which we've

00:16:04,670 --> 00:16:10,250
already seen in debugger and as you

00:16:07,940 --> 00:16:13,220
already know tracing function takes

00:16:10,250 --> 00:16:16,670
three arguments one of which is a frame

00:16:13,220 --> 00:16:18,530
object and again thanks to frame object

00:16:16,670 --> 00:16:21,170
coverage tool can collect information

00:16:18,530 --> 00:16:24,950
about file name and line number which

00:16:21,170 --> 00:16:29,960
will execute it store it and then show

00:16:24,950 --> 00:16:33,200
you inside your coverage report oh well

00:16:29,960 --> 00:16:36,830
we discussed debugger spy test code

00:16:33,200 --> 00:16:40,730
coverage but there is another group of

00:16:36,830 --> 00:16:44,030
tools based on runtime information they

00:16:40,730 --> 00:16:45,950
are runtime dalvik talks tools which

00:16:44,030 --> 00:16:48,470
collect a type information during

00:16:45,950 --> 00:16:51,560
program execution and then help you to

00:16:48,470 --> 00:16:54,830
generate type annotations right inside

00:16:51,560 --> 00:16:57,830
your source code I've found information

00:16:54,830 --> 00:17:01,580
about three tools doing this but there

00:16:57,830 --> 00:17:04,310
might be more of them by annotate by

00:17:01,580 --> 00:17:06,410
Dropbox collects types of function

00:17:04,310 --> 00:17:10,850
arguments and then inserts type

00:17:06,410 --> 00:17:13,310
annotations right into your code monkey

00:17:10,850 --> 00:17:15,830
tied by Instagram does something similar

00:17:13,310 --> 00:17:19,010
it collects information about types of

00:17:15,830 --> 00:17:22,339
your arguments and then generates stop

00:17:19,010 --> 00:17:25,910
files for your project based on this

00:17:22,339 --> 00:17:28,550
collected information the option collect

00:17:25,910 --> 00:17:32,690
runtime information available in Python

00:17:28,550 --> 00:17:35,150
ID does also something similar if this

00:17:32,690 --> 00:17:35,750
option is enabled the buyer starts to

00:17:35,150 --> 00:17:38,210
collect

00:17:35,750 --> 00:17:40,880
I have information about every funk and

00:17:38,210 --> 00:17:43,340
later if you would like to generate dog

00:17:40,880 --> 00:17:46,430
stream for some function by channel will

00:17:43,340 --> 00:17:50,330
use collected information during dog

00:17:46,430 --> 00:17:53,510
stream generation all these three tools

00:17:50,330 --> 00:17:57,890
use runtime information let's learn how

00:17:53,510 --> 00:18:02,600
they are implemented by annotate and

00:17:57,890 --> 00:18:05,240
monkey type I'm both based on C's dot

00:18:02,600 --> 00:18:08,000
set profile which works with profile

00:18:05,240 --> 00:18:10,640
function which is very similar to

00:18:08,000 --> 00:18:13,670
tracing culture it takes exactly the

00:18:10,640 --> 00:18:15,530
same three arguments but it isn't caught

00:18:13,670 --> 00:18:17,510
on every line of your code

00:18:15,530 --> 00:18:20,150
it's called only when you call some

00:18:17,510 --> 00:18:22,420
function or MANET and it's logical

00:18:20,150 --> 00:18:25,250
because for tracing function arguments

00:18:22,420 --> 00:18:30,620
you need to trends on the call events

00:18:25,250 --> 00:18:32,810
not every event in your program as I've

00:18:30,620 --> 00:18:36,200
already sad collect runtime information

00:18:32,810 --> 00:18:41,330
by John is integrated with debugger so

00:18:36,200 --> 00:18:44,240
it also has access to frame object so

00:18:41,330 --> 00:18:47,390
how can we get types of elements you

00:18:44,240 --> 00:18:49,430
will have access to frame object first

00:18:47,390 --> 00:18:50,890
of all we can get a list of argument

00:18:49,430 --> 00:18:53,810
names defined at the current frame

00:18:50,890 --> 00:18:56,870
because everything is stored inside a

00:18:53,810 --> 00:18:57,590
code object we've already seen this

00:18:56,870 --> 00:18:59,840
called

00:18:57,590 --> 00:19:04,130
objects attributes days in the beginning

00:18:59,840 --> 00:19:06,380
of my talk and as you remember we have a

00:19:04,130 --> 00:19:09,230
dictionary dictionary with local

00:19:06,380 --> 00:19:13,040
variables so we have accessed objects

00:19:09,230 --> 00:19:15,590
and therefore to their types so for each

00:19:13,040 --> 00:19:18,410
function we already know variables names

00:19:15,590 --> 00:19:21,470
their types and location where this

00:19:18,410 --> 00:19:24,770
function was defined we can store this

00:19:21,470 --> 00:19:29,150
information and use it later for type

00:19:24,770 --> 00:19:31,820
annotations generation and this is how

00:19:29,150 --> 00:19:34,490
all these tools are implemented with the

00:19:31,820 --> 00:19:39,050
help of frame object and corresponding

00:19:34,490 --> 00:19:40,820
code object we discussed several tools

00:19:39,050 --> 00:19:43,430
which are based on runtime information

00:19:40,820 --> 00:19:46,220
by them but all of them are quite

00:19:43,430 --> 00:19:49,770
complicated let's try to create

00:19:46,220 --> 00:19:52,020
something small but useful our own tool

00:19:49,770 --> 00:19:55,130
is also based on runtime information and

00:19:52,020 --> 00:19:58,790
which will help us to detect problems

00:19:55,130 --> 00:20:01,880
for example in concurrent execution

00:19:58,790 --> 00:20:04,610
there are two ways to execute tasks

00:20:01,880 --> 00:20:08,340
concurrently inside bond Python process

00:20:04,610 --> 00:20:10,560
threads and a synchronous tasks with the

00:20:08,340 --> 00:20:12,780
help of standard module threading you

00:20:10,560 --> 00:20:16,430
can start a new thread which will

00:20:12,780 --> 00:20:18,480
execute your function concurrently for

00:20:16,430 --> 00:20:21,810
synchronization between threads in

00:20:18,480 --> 00:20:24,450
Python there are synchronization objects

00:20:21,810 --> 00:20:28,080
and the most fundamental synchronization

00:20:24,450 --> 00:20:30,810
object is a lock project the rat can

00:20:28,080 --> 00:20:32,850
acquire lock object and that means that

00:20:30,810 --> 00:20:36,060
the following block of code will be

00:20:32,850 --> 00:20:39,740
executed by this and only by this thread

00:20:36,060 --> 00:20:42,390
until it will release this lock object

00:20:39,740 --> 00:20:45,990
Python lock objects are also context

00:20:42,390 --> 00:20:50,610
managers so you can work with them with

00:20:45,990 --> 00:20:53,010
keyword with running more than one

00:20:50,610 --> 00:20:55,770
thread and using lock objects sometimes

00:20:53,010 --> 00:20:56,340
can lead to a deadlock deadlock is a

00:20:55,770 --> 00:20:59,070
snake

00:20:56,340 --> 00:21:01,410
when state when several threads are

00:20:59,070 --> 00:21:04,050
waiting for resources which can't be

00:21:01,410 --> 00:21:06,780
released the easiest way to reproduce

00:21:04,050 --> 00:21:09,270
this situation is the following create

00:21:06,780 --> 00:21:11,490
two threads to lock objects and to

00:21:09,270 --> 00:21:15,090
acquire this lock objects in different

00:21:11,490 --> 00:21:17,430
orders first Fred acquires lock number

00:21:15,090 --> 00:21:20,820
one second thread quire's lock number

00:21:17,430 --> 00:21:24,300
two the first thread wants to acquire

00:21:20,820 --> 00:21:26,640
lock number one - what is unavailable so

00:21:24,300 --> 00:21:29,070
it starts to weight it second thread

00:21:26,640 --> 00:21:31,860
wants to acquire lock number one but

00:21:29,070 --> 00:21:34,280
it's also unavailable as you can see

00:21:31,860 --> 00:21:36,930
then situation can be resolved without

00:21:34,280 --> 00:21:39,900
program interruption because threads

00:21:36,930 --> 00:21:45,690
will be waiting for their work objects

00:21:39,900 --> 00:21:48,480
forever and this is very sad and if you

00:21:45,690 --> 00:21:51,000
have a really large code base it might

00:21:48,480 --> 00:21:54,960
be difficult to detect deadlock in your

00:21:51,000 --> 00:21:57,390
code and even static code analysis can't

00:21:54,960 --> 00:22:00,170
help you here because deadlock happens

00:21:57,390 --> 00:22:02,360
at run time during code execution

00:22:00,170 --> 00:22:05,540
but we already know a lot of cool things

00:22:02,360 --> 00:22:09,710
about Python runtime and we can try to

00:22:05,540 --> 00:22:12,860
apply them here we've already used C's

00:22:09,710 --> 00:22:15,560
dot get frame function which returns

00:22:12,860 --> 00:22:17,750
frame object for the current rate thread

00:22:15,560 --> 00:22:20,930
but there is also another useful

00:22:17,750 --> 00:22:24,170
function C's dot current frames which

00:22:20,930 --> 00:22:26,630
returns top most stack frame for every

00:22:24,170 --> 00:22:28,820
thread in the current Python process and

00:22:26,630 --> 00:22:31,370
the coolest thing about this function is

00:22:28,820 --> 00:22:34,850
that it works even with deadlocked

00:22:31,370 --> 00:22:37,400
threads without this function we can

00:22:34,850 --> 00:22:40,040
create our own tool which will be

00:22:37,400 --> 00:22:43,490
printing trace bugs for threads with

00:22:40,040 --> 00:22:46,510
some internal and will help us to find

00:22:43,490 --> 00:22:49,970
place where the Reds are talking doc

00:22:46,510 --> 00:22:54,530
that's it simple and powerful tool is

00:22:49,970 --> 00:22:56,930
ready but there is one problem this

00:22:54,530 --> 00:23:00,260
functionality is already implemented in

00:22:56,930 --> 00:23:02,930
standard library inside fault handler

00:23:00,260 --> 00:23:05,150
module it has a function which prints

00:23:02,930 --> 00:23:08,510
trace backs of all the run with registry

00:23:05,150 --> 00:23:13,910
file and it's implemented natively and

00:23:08,510 --> 00:23:16,760
in C code but not all the things who are

00:23:13,910 --> 00:23:18,830
implemented before us as you remember

00:23:16,760 --> 00:23:22,120
there is a second way to unsecure some

00:23:18,830 --> 00:23:24,170
code concurrently a synchronous tasks

00:23:22,120 --> 00:23:26,510
and there are very similar

00:23:24,170 --> 00:23:30,170
synchronization objects in a single

00:23:26,510 --> 00:23:32,840
module and therefore as simple as

00:23:30,170 --> 00:23:35,270
deadlock can appear in your guard that

00:23:32,840 --> 00:23:38,060
means that there is a place where we can

00:23:35,270 --> 00:23:40,760
apply our finish knowledge about Python

00:23:38,060 --> 00:23:44,420
runtime and create a synchronous version

00:23:40,760 --> 00:23:47,090
of fault hello several useful functions

00:23:44,420 --> 00:23:51,530
are already implemented inside a single

00:23:47,090 --> 00:23:54,020
module the first one is a single dot all

00:23:51,530 --> 00:23:56,930
tasks which returns all the running

00:23:54,020 --> 00:24:00,050
tasks in the loop and the second one is

00:23:56,930 --> 00:24:04,790
tasks method get stack which returns

00:24:00,050 --> 00:24:07,790
lists of frames for this task our simple

00:24:04,790 --> 00:24:10,460
fault handler will work like this in a

00:24:07,790 --> 00:24:11,570
separate thread we are running in a

00:24:10,460 --> 00:24:12,909
look-in

00:24:11,570 --> 00:24:15,519
in red

00:24:12,909 --> 00:24:19,419
and with a given time timeout we dump

00:24:15,519 --> 00:24:22,090
tasks trace backs now you with suspect

00:24:19,419 --> 00:24:24,519
that we have synchronous deadlock

00:24:22,090 --> 00:24:26,950
somewhere in our code we can quickly

00:24:24,519 --> 00:24:29,769
check it with our a synchronous fault

00:24:26,950 --> 00:24:33,729
handler and find a place where this

00:24:29,769 --> 00:24:36,129
deadlock appeared great women lament it

00:24:33,729 --> 00:24:40,509
simple but powerful tool for detecting

00:24:36,129 --> 00:24:44,499
dead logs with assiduous tasks and that

00:24:40,509 --> 00:24:47,409
was the last tool we were going to

00:24:44,499 --> 00:24:49,989
consider today from this part we've

00:24:47,409 --> 00:24:52,629
learned several tools which are based on

00:24:49,989 --> 00:24:54,999
programs runtime information I would

00:24:52,629 --> 00:24:57,369
like to emphasize it one more time that

00:24:54,999 --> 00:24:59,619
these tools collect information which is

00:24:57,369 --> 00:25:03,340
impossible to get just from the source

00:24:59,619 --> 00:25:06,099
code you can make some assumptions based

00:25:03,340 --> 00:25:08,349
on source code but on the at runtime we

00:25:06,099 --> 00:25:11,349
can get there real values of variables

00:25:08,349 --> 00:25:14,200
and the real program state and this is

00:25:11,349 --> 00:25:19,029
extremely cool feature of the runtime

00:25:14,200 --> 00:25:23,080
based development tools today we learned

00:25:19,029 --> 00:25:24,759
a lot about Python runtime as we've seen

00:25:23,080 --> 00:25:27,369
during the talk rant

00:25:24,759 --> 00:25:29,889
information can be used in any part of

00:25:27,369 --> 00:25:33,099
the development process during testing

00:25:29,889 --> 00:25:37,330
during debugging even during concurrent

00:25:33,099 --> 00:25:39,849
code execution I hope after this talk

00:25:37,330 --> 00:25:42,549
you'll start using runtime development

00:25:39,849 --> 00:25:45,820
tools more often because they really

00:25:42,549 --> 00:25:48,450
help to write more level code and for

00:25:45,820 --> 00:25:51,479
example fine boxing it much faster and

00:25:48,450 --> 00:25:54,700
maybe you'll even create your own

00:25:51,479 --> 00:25:57,099
YouTube after this talk you have enough

00:25:54,700 --> 00:26:01,989
information to do it that would be

00:25:57,099 --> 00:26:04,389
really great if you did if you decide to

00:26:01,989 --> 00:26:07,659
do experiments here are some links a

00:26:04,389 --> 00:26:10,570
repository with today's examples source

00:26:07,659 --> 00:26:12,489
code of course feel free to read by the

00:26:10,570 --> 00:26:16,389
official documentation about any

00:26:12,489 --> 00:26:18,309
standard module we yesterday and also

00:26:16,389 --> 00:26:20,679
I'll be happy to answer your questions

00:26:18,309 --> 00:26:24,820
in the comments of this video or by

00:26:20,679 --> 00:26:26,440
email or in my Twitter account thank you

00:26:24,820 --> 00:26:30,630
very much for what

00:26:26,440 --> 00:26:30,630

YouTube URL: https://www.youtube.com/watch?v=yr6E7FwK_Hw


