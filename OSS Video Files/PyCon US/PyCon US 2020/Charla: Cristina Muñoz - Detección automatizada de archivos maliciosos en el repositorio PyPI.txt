Title: Charla: Cristina Muñoz - Detección automatizada de archivos maliciosos en el repositorio PyPI
Publication date: 2021-03-10
Playlist: PyCon US 2020
Description: 
	Presented by:
Cristina Muñoz

En Septiembre 2019, la Fundación Python (Python Software Foundation) lanzó una Solicitud de Propuestas para el desarrollo de funcionalidades críticas de seguridad en el software del Python Packaging Index (PyPI). Esto se produjo en respuesta después de que Hackers distribuyeran contenido malicioso a través del repositorio PyPI.

Desde typosquatting a la ejecución de código arbitrario. En esta charla, vamos a revisar los vectores de ataque más populares utilizados por Hackers para confundir a los usuarios y aprovecharse de ellos. Teniendo en cuenta estos ataques, vamos a describir el nuevo sistema de detección automatizada integrado en el repositorio PyPI, y, en particular, los tipos de chequeos que ya se encuentran instrumentadas, concluyendo con una explicación de cómo usted puede combatir el malware en el repositorio PyPI.

Slides: https://docs.google.com/presentation/d/1vMfO2CbCkdIYLLXfM2UelWE6JfWrY9QB_AMIyX7flDM
Captions: 
	00:00:14,475 --> 00:00:16,315
Hi! I'm Cristina Muñoz.

00:00:16,765 --> 00:00:19,545
Today, I'm going to talk to you about automated malware detection

00:00:19,545 --> 00:00:22,545
in the Python Package Index.

00:00:23,225 --> 00:00:25,955
What is it? How does it work?

00:00:25,955 --> 00:00:28,855
Why am I giving this talk? Well, I'll explain.

00:00:28,855 --> 00:00:31,125
But first, let me tell you about how

00:00:31,125 --> 00:00:33,855
I became an expert on this subject.

00:00:34,675 --> 00:00:37,685
I spent the majority of the past decade developing

00:00:37,685 --> 00:00:40,665
software and working in information security

00:00:40,665 --> 00:00:41,925
in tech companies

00:00:41,925 --> 00:00:45,255
and consultancies in San Francisco and New York.

00:00:45,255 --> 00:00:48,295
I love to design systems and solve human problems

00:00:48,295 --> 00:00:50,925
with software tooling. My last job

00:00:50,925 --> 00:00:53,665
was at a Google X startup

00:00:53,665 --> 00:00:56,065
called Chronicle Security.

00:00:56,735 --> 00:00:59,735
The flagship product of Chronicle Security, called Backstory,

00:00:59,735 --> 00:01:02,375
was a new type of Security information and Event Management

00:01:02,375 --> 00:01:05,355
system (aka SIEM).

00:01:05,355 --> 00:01:08,225
Backstory ingests various types of security telemetry

00:01:08,225 --> 00:01:11,165
and scans them constantly to look for

00:01:11,165 --> 00:01:14,075
indicators of compromise,

00:01:14,075 --> 00:01:16,885
aka IoCs.

00:01:16,885 --> 00:01:19,755
Security engineers love abbreviations,

00:01:19,755 --> 00:01:22,365
and I apologize for my use of abbreviations in advanced.

00:01:22,985 --> 00:01:25,955
How does Backstory look for IoCs?

00:01:25,955 --> 00:01:28,975
Backstory is integrated with threat feeds

00:01:28,975 --> 00:01:32,115
and virus scanners. The marketing department

00:01:32,115 --> 00:01:35,385
envisioned Backstory as the single pane of glass

00:01:35,385 --> 00:01:37,265
for a Security Operations Center,

00:01:37,575 --> 00:01:39,325
aka SOC.

00:01:39,965 --> 00:01:42,945
Chronicle was officially acquired by Google Cloud

00:01:42,945 --> 00:01:45,885
in August 2019. This happened only

00:01:45,975 --> 00:01:49,045
3 months after we brought Backstory to market.

00:01:49,225 --> 00:01:51,885
After the acquisition,

00:01:51,885 --> 00:01:55,075
our new corporate overlords offered me a position,

00:01:55,335 --> 00:01:58,105
but their business strategy

00:01:58,105 --> 00:02:01,185
was not aligned with my personal values.

00:02:01,185 --> 00:02:03,525
I decided not to continue Chronicle

00:02:03,525 --> 00:02:04,695
and Google.

00:02:05,235 --> 00:02:08,305
I quit my job

00:02:08,305 --> 00:02:10,095
and went on vacation in Guatemala.

00:02:10,985 --> 00:02:13,535
Between swimming in waterfalls, and

00:02:13,535 --> 00:02:16,585
eating tamarindo raspados, I received and email

00:02:16,585 --> 00:02:19,225
from someone working with

00:02:19,225 --> 00:02:21,895
the Python Software Foundation. The email

00:02:21,895 --> 00:02:24,945
was about a Request for Proposals

00:02:24,945 --> 00:02:27,615
for the development of critical security features

00:02:27,615 --> 00:02:29,005
in the software of

00:02:29,795 --> 00:02:32,085
the Python Package Index,

00:02:32,085 --> 00:02:35,315
aka PyPI. I reviewed the requirements,

00:02:35,315 --> 00:02:38,285
and decided to write a proposal.

00:02:38,295 --> 00:02:40,655
Once I returned from my vacation,

00:02:40,655 --> 00:02:41,825
I started writing.

00:02:43,385 --> 00:02:46,205
If you're new to python,

00:02:46,205 --> 00:02:49,335
you might not know what the Python Package Index is.

00:02:49,465 --> 00:02:52,295
PyPI is simply the canonical repository for

00:02:52,295 --> 00:02:53,295
3rd-party software.

00:02:54,055 --> 00:02:56,965
pip is the package manager for Python.

00:02:56,965 --> 00:03:02,785
If you've ever executed this command, you've used PyPI.

00:03:02,785 --> 00:03:05,535
When someone installs packages from PyPI, how do they know

00:03:05,535 --> 00:03:08,625
that the packages aren't malware?

00:03:08,625 --> 00:03:12,505
The response is, unfortunately, they don't know.

00:03:12,855 --> 00:03:18,565
They don't know, because PyPI administrators don't know either.

00:03:19,000 --> 00:03:25,515
There are approximately 5,000 files uploaded to PyPI every day,

00:03:25,515 --> 00:03:28,795
and they don't have the bandwidth to manually review each one.

00:03:29,000 --> 00:03:34,495
The Python Software Foundation is a non-profit organization.

00:03:34,495 --> 00:03:37,465
They have 7 full-time employees,

00:03:37,465 --> 00:03:40,300
only one of which occupies a technical role.

00:03:40,565 --> 00:03:43,575
There are also many volunteers

00:03:43,575 --> 00:03:46,615
that dedicate their time to ensure the security of PyPI,

00:03:46,635 --> 00:03:49,645
but the scale of the problem

00:03:49,645 --> 00:03:52,595
is simply too large to resolve manually.

00:03:53,675 --> 00:03:57,025
It's clear that an automated approach is needed.

00:03:57,305 --> 00:04:00,365
Let's return to the RfP.

00:04:00,575 --> 00:04:03,575
The RfP described two milestones,

00:04:03,575 --> 00:04:06,645
with the purpose of strengthening the security of PyPI.

00:04:07,355 --> 00:04:08,955
The first goal

00:04:09,915 --> 00:04:13,185
deals with ensuring the security of files,

00:04:13,185 --> 00:04:15,645
and can be summarized as "Implement The Update Framework",

00:04:15,645 --> 00:04:18,005
aka TUF.

00:04:18,475 --> 00:04:21,555
TUF is an open source protocol

00:04:21,555 --> 00:04:25,125
that ensures that the files uploaded by contributors to PyPI

00:04:25,125 --> 00:04:28,235
are the same files that are downloaded by users,

00:04:28,235 --> 00:04:30,835
and that they haven't been manipulated in transit (man-in-the-middle).

00:04:31,685 --> 00:04:34,725
TUF has been adopted by a number of organizations:

00:04:34,725 --> 00:04:37,685
Cloudflare, Docker, and DigitalOcean, to name a few.

00:04:37,755 --> 00:04:40,885
You can find more details about TUF implementation

00:04:40,885 --> 00:04:46,100
in PEP-458.

00:04:46,175 --> 00:04:48,965
I submitted a proposal for the second milestone.

00:04:48,965 --> 00:04:52,015
Let's now closely review the requirements of this milestone.

00:04:53,345 --> 00:04:55,525
The system for automated malware detection

00:04:55,525 --> 00:04:58,555
needs to be extendable

00:04:58,555 --> 00:05:03,400
with the ability to integrate various types of security checks.

00:05:03,955 --> 00:05:06,945
It needs to be developed in accordance with

00:05:06,945 --> 00:05:09,635
open source software development practices.

00:05:09,635 --> 00:05:14,445
It needs storage infrastructure to store the results.

00:05:14,765 --> 00:05:19,600
The system needs an interface so that administrators can review results.

00:05:19,875 --> 00:05:26,300
This will serve as a single pane of glass for security events.

00:05:26,465 --> 00:05:34,000
Finally, it needs technical documentation that will support the development of new checks.

00:05:34,145 --> 00:05:37,055
Another way of interpreting these requirements is:

00:05:37,055 --> 00:05:39,815
they want to build a SIEM inside of PyPI.

00:05:39,985 --> 00:05:44,700
They want it to collect security-relevant telemetry,

00:05:44,800 --> 00:05:48,895
scan for IoCs with checks,

00:05:48,895 --> 00:05:52,115
surface these IoCs in a UI,

00:05:52,115 --> 00:05:56,535
and support the ability to add new checks for new threats.

00:05:56,905 --> 00:06:00,155
This functions fundamentally like a SIEM,

00:06:00,155 --> 00:06:03,085
and with my experience contributing to one previously,

00:06:03,085 --> 00:06:05,815
I immersed myself in the proposal.

00:06:06,215 --> 00:06:11,685
To offer more context, I've never written or submitted a proposal like this one.

00:06:11,685 --> 00:06:17,615
It was my first time. I'm an engineer, and I had to investigate the style and format of proposals.

00:06:17,795 --> 00:06:21,515
I spent more than an hour choosing the font.

00:06:22,195 --> 00:06:24,185
But in the end, I triumphed!

00:06:24,575 --> 00:06:30,595
This is the email that I received from Ernest, the director of infrastructure for the Python Software Foundation,

00:06:30,595 --> 00:06:35,075
where he notified me that they wanted to accept my proposal.

00:06:35,565 --> 00:06:39,895
Now that we've covered the "What?" and "Why?" of this system,

00:06:40,245 --> 00:06:44,525
let's change gears a bit and focus on the questions of "Where?" and "How?".

00:06:44,935 --> 00:06:48,335
In PyPI, there are 3 types of assets that we want to protect:

00:06:48,345 --> 00:06:51,345
Projects, Versions, and Files.

00:06:51,345 --> 00:06:57,495
A Project is the top-level organizational unit for packaging.

00:06:57,495 --> 00:07:03,535
Every project contains a name, description, one or more authors/maintainers,

00:07:03,540 --> 00:07:06,980
and most importantly, it contains Versions.

00:07:07,360 --> 00:07:10,360
Versions are exactly what they sound like:

00:07:10,360 --> 00:07:13,720
A unique number, code or name associated with a package,

00:07:13,880 --> 00:07:17,095
to designate it's level of development.

00:07:17,095 --> 00:07:18,855
Versions contain files.

00:07:20,225 --> 00:07:25,905
Files are the most atomic unit in the packaging ecosystem.

00:07:25,905 --> 00:07:29,065
Files contain the code that users download and execute.

00:07:29,095 --> 00:07:35,025
They are also the asset that antivirus systems focus on when we talk about malware detection.

00:07:35,205 --> 00:07:41,100
The system of automated malware detection operates principally on these 3 assets:

00:07:41,100 --> 00:07:44,000
Projects, Versions and Files.

00:07:44,140 --> 00:07:52,020
Each "verdict" is linked to exactly one of these assets via a foreign key.

00:07:52,200 --> 00:07:56,940
Now we will talk about different attack vectors

00:07:56,940 --> 00:08:03,820
used by hackers against these 3 types of assets, and checks that can help detect them.

00:08:04,000 --> 00:08:07,040
A common tactic used by hackers is

00:08:07,180 --> 00:08:12,060
to create a project with a familiar-sounding name, or misspelled by one letter.

00:08:12,240 --> 00:08:18,460
They used deliberate typographical errors that imitate popular projects, and

00:08:18,540 --> 00:08:25,640
are designed to confuse users, with the objective that users download the malicious package.

00:08:26,000 --> 00:08:33,700
These 2 projects are malware that steal SSH and GPG private keys, but they appear legitimate.

00:08:33,820 --> 00:08:38,475
The legitimate dateutil package is already compatible with Python 3.

00:08:38,475 --> 00:08:46,385
The malicious package jeIlyfish is spelled with an uppercase "i" instead of a lowercase "L".

00:08:47,660 --> 00:08:52,960
The spelling error is obvious in a monospace font.

00:08:54,700 --> 00:09:00,780
The malicious package python3-dateutil in PyPI is particularly insidious,

00:09:00,880 --> 00:09:08,400
due to the fact that there exists a legitimate package in the Debian package repository with this exact name.

00:09:08,400 --> 00:09:13,060
These two malicious projects were created by the same attacker.

00:09:13,060 --> 00:09:20,200
A German software engineer named Lukas Martini discovered the truth about these packages

00:09:20,200 --> 00:09:22,580
on Dec 1, 2019.

00:09:22,720 --> 00:09:29,755
He contacted the PyPI security team and they removed the packages on the same day.

00:09:30,265 --> 00:09:35,635
The python3-dateutil project was only served by PyPI for 2 days,

00:09:36,120 --> 00:09:41,340
but the jeIlyfish project was up for almost a year.

00:09:41,940 --> 00:09:47,700
It's very difficult to detect typosquatting because there are thousands of projects with names

00:09:47,745 --> 00:09:51,035
that are similar to the names of popular projects, and for legitimate reasons.

00:09:51,380 --> 00:09:57,920
To combat this problem, we need more advanced heuristics than simply edit-distance.

00:09:59,700 --> 00:10:02,960
Now we will talk about compromised versions.

00:10:03,020 --> 00:10:11,000
This is a story that took place in another programming language community: NodeJS.

00:10:11,060 --> 00:10:14,600
Consider this not-so-hypothetical situation:

00:10:14,820 --> 00:10:17,920
An anonymous developer gets in contact with a busy package developer,

00:10:17,920 --> 00:10:22,840
and they offer to help maintain their popular project.

00:10:22,840 --> 00:10:26,240
Let's say the project is called event-steam.

00:10:26,240 --> 00:10:31,335
The maintainer grants publishing permissions to the developer.

00:10:31,660 --> 00:10:36,420
The new contributor releases a new version that contains malware.

00:10:36,440 --> 00:10:40,860
When unsuspecting users upgrade their dependencies,

00:10:40,860 --> 00:10:42,940
they become infected with the malware.

00:10:42,940 --> 00:10:45,400
The result is thousands of compromised projects.

00:10:45,800 --> 00:10:51,740
The details of these events came to light in November 2018.

00:10:51,780 --> 00:10:55,735
The attacker, with the username right9control,

00:10:55,740 --> 00:11:02,000
offered to integrate a new dependency into event-stream.

00:11:02,100 --> 00:11:06,260
The new contributor released a new version of the package

00:11:06,260 --> 00:11:10,480
that added a malicious dependency which stole bitcoins.

00:11:10,480 --> 00:11:13,840
This resulted in chaos and this Github issue.

00:11:14,300 --> 00:11:17,875
Though this has not yet occurred in the Python ecosystem

00:11:17,880 --> 00:11:18,880
(that we know of)

00:11:19,260 --> 00:11:22,000
this doesn't mean that it can't or won't.

00:11:22,620 --> 00:11:29,495
Authors and maintainers of open source software form a large attack surface,

00:11:29,500 --> 00:11:34,300
which, in many cases, is easier to exploit than technical systems.

00:11:34,300 --> 00:11:40,340
In this case, the author gave access to the attacker voluntarily.

00:11:40,800 --> 00:11:46,200
Attackers also try to gain access to maintainer accounts through other means:

00:11:46,200 --> 00:11:51,220
credential stuffing and brute-force password attacks.

00:11:51,280 --> 00:11:55,880
Multi-factor authentication mitigates these attack vectors.

00:11:55,920 --> 00:12:03,720
In PyPI, the ability to enable 2-factor authentication has only , but been available for a year,

00:12:03,800 --> 00:12:06,040
but it's still not required.

00:12:07,460 --> 00:12:10,020
Finally, let's talk about files.

00:12:10,080 --> 00:12:16,525
In Python, there are two distribution formats for packages: built and source.

00:12:16,525 --> 00:12:20,560
Built distributions are pre-compiled.

00:12:20,560 --> 00:12:22,560
When someone downloads a built package,

00:12:22,560 --> 00:12:26,040
the files are moved to the correct location on the file system for execution,

00:12:26,040 --> 00:12:30,000
but they doesn't execute additional code locally during installation.

00:12:30,000 --> 00:12:33,840
"Wheel" is an example of a built distribution,

00:12:33,840 --> 00:12:37,580
and the current recommended format for package developers.

00:12:37,580 --> 00:12:42,300
Source distributions are an older packaging format,

00:12:42,300 --> 00:12:50,445
which require an additional pre-compilation step on the local system of users that download them.

00:12:50,835 --> 00:12:56,685
The execution instructions for this step are located in the required setup.py file.

00:12:56,940 --> 00:13:01,720
Package developers control the content of setup.py

00:13:01,720 --> 00:13:10,780
and can take advantage of this ability to automatically install malware during package installation.

00:13:11,200 --> 00:13:20,520
In the info sec industry, we call this attack vector "Remote Code Execution".

00:13:20,880 --> 00:13:23,200
Here we have an example of that.

00:13:23,200 --> 00:13:32,100
The author can hook into the install command to start a reverse shell and gain access to the user's system.

00:13:32,280 --> 00:13:40,180
The was the method used by the attacker in the first example, in the python3-dateutil and jellyfish packages.

00:13:40,740 --> 00:13:47,615
There's a hard-working army of volunteers trying to keep PyPI users safe,

00:13:47,620 --> 00:13:50,160
but the scale of the problem is enormous.

00:13:50,160 --> 00:13:52,840
We need to adopt a systematic approach.

00:13:53,900 --> 00:14:00,280
These examples can help us arrive to conclusions about how this system should work.

00:14:00,980 --> 00:14:07,140
The places that we want to investigate suspicious behavior are singular, discrete events,

00:14:07,140 --> 00:14:11,260
like when a file is uploaded or a project created,

00:14:11,260 --> 00:14:18,045
and at regular intervals, to consider a sequence of events or general patterns of behavior.

00:14:18,540 --> 00:14:23,100
Two cover these two scenarios, I proposed two types of checks:

00:14:23,100 --> 00:14:26,620
checks that are triggered by event hooks,

00:14:26,620 --> 00:14:29,800
and checks that run on a fixed schedule.

00:14:31,220 --> 00:14:38,480
Hooked checks are useful for low-context heuristics to identify malware.

00:14:38,480 --> 00:14:47,100
The moment a file is uploaded, we could, for example, send it to VirusTotal to scan it with anti-virus.

00:14:47,100 --> 00:14:51,755
We could integrate static or dynamic analysis.

00:14:51,755 --> 00:14:56,845
YARA rules are also useful for malware pattern matching.

00:14:57,235 --> 00:15:00,255
In fact, that's what we did.

00:15:00,260 --> 00:15:05,020
This check scans the setup.py file of every uploaded package with YARA rules to look for

00:15:05,020 --> 00:15:08,620
malicious code signatures.

00:15:08,620 --> 00:15:15,180
Our YARA rules report verdicts whenever they encounter new process spawns,

00:15:15,180 --> 00:15:21,180
matching commands like "exec", "eval" or the subprocess module.

00:15:21,180 --> 00:15:23,920
We create a verdict for internet connections

00:15:23,920 --> 00:15:27,515
because this is how malware behaves

00:15:27,520 --> 00:15:30,560
when it communicates with command and control servers.

00:15:30,560 --> 00:15:40,440
Deserialization refers to serialized or obfuscated code that could potentially contains a malicious payload.

00:15:40,440 --> 00:15:44,700
Metaprogramming is another obfuscation technique that we detect.

00:15:44,700 --> 00:15:50,100
The bad thing about YARA rules is that they are always an arms race.

00:15:50,100 --> 00:15:54,820
You can't write a YARA rule for a new or unknown attack vector.

00:15:54,820 --> 00:16:00,620
Also, there are a lot of legitimate reasons that someone would need to spawn a new process

00:16:00,860 --> 00:16:04,835
or establish an internet connection in setup.py.

00:16:05,440 --> 00:16:07,740
Here we have an example.

00:16:07,740 --> 00:16:17,340
This code is executed upon installation of the package psycopg, the official Python client library for Postgres.

00:16:17,340 --> 00:16:24,420
The system creates a verdict for this file because it uses the subprocess module in setup.py.

00:16:25,040 --> 00:16:31,480
Scheduled checks are useful to analyze actions and the context that surrounds them.

00:16:31,780 --> 00:16:35,960
For example, let's consider the following situations.

00:16:35,960 --> 00:16:45,320
A user with a recently-created account, and an IP address originating from a VPN,

00:16:45,320 --> 00:16:50,400
creates a new project with a name that is similar to an existing, popular project.

00:16:51,120 --> 00:16:58,295
The maintainer of a popular package deactivates multi-factor authentication for their account,

00:16:58,300 --> 00:17:01,320
and transfers ownership of their package to another user.

00:17:01,860 --> 00:17:05,260
These scenarios require further investigation.

00:17:05,900 --> 00:17:09,120
To detect this, we created the PackageTurnoverCheck.

00:17:09,120 --> 00:17:12,475
This check was implemented in an algorithmic way.

00:17:12,480 --> 00:17:14,380
It works like this.

00:17:14,380 --> 00:17:19,560
This check queries the database every 24 hours to look for new versions.

00:17:19,560 --> 00:17:25,140
and initiates further queries on the maintainers associated with those new versions

00:17:25,140 --> 00:17:27,700
to identify unusual behavior.

00:17:28,020 --> 00:17:32,200
This method provides a better signal than something like YARA rules.

00:17:33,300 --> 00:17:38,620
Now, let's look at integrating these checks into the software backend of PyPI,

00:17:38,620 --> 00:17:40,700
which is called warehouse.

00:17:40,700 --> 00:17:43,820
Warehouse is relatively new software.

00:17:44,180 --> 00:17:50,580
It was developed and released as the software backend of PyPI in Abril 2018.

00:17:50,580 --> 00:17:53,900
It's built on a web framework called Pyramid.

00:17:54,680 --> 00:18:02,435
It uses the ORM SQLAlchemy and a Postgres database.

00:18:02,740 --> 00:18:07,920
It's integrated with Celery, which is a distributed task queue.

00:18:07,960 --> 00:18:11,960
It's used to execute tasks asynchronously.

00:18:12,160 --> 00:18:20,155
This is needed so that long-running processes don't affect the experience of users of the HTTP interface.

00:18:20,740 --> 00:18:24,880
Warehouse uses Jinja2 templates on the frontend.

00:18:25,580 --> 00:18:32,640
The development environment consists of components packaged up as docker containers.

00:18:32,640 --> 00:18:36,780
The containers are managed by docker-compose.

00:18:37,080 --> 00:18:40,980
This is infrastructure that will house our SIEM.

00:18:41,580 --> 00:18:45,860
This is a diagram that I submitted with my initial proposal.

00:18:45,860 --> 00:18:51,700
It shows the execution workflow for a event-hook check.

00:18:51,700 --> 00:18:54,480
When a new project is created,

00:18:54,480 --> 00:19:01,520
an event listener in the SQLAlchemy session initiates a query to the database

00:19:01,520 --> 00:19:03,940
to load the checks to execute.

00:19:03,940 --> 00:19:08,520
When it loads them, it queues the tasks in celery.

00:19:08,520 --> 00:19:13,660
Upon completion, the tasks write their verdicts to the database.

00:19:13,660 --> 00:19:18,620
The verdicts are available via an administrative interface.

00:19:19,060 --> 00:19:23,700
Checks don't automatically trigger follow-up actions based on verdicts.

00:19:23,700 --> 00:19:28,300
They just generate verdicts for administrator review.

00:19:28,520 --> 00:19:36,000
An administrator makes the final decision about whether to leave up or remove a package from PyPI.

00:19:36,560 --> 00:19:41,320
Now, I'll guide you through the administrative interface.

00:19:41,620 --> 00:19:48,980
As a part of this work, we added two new sections to the administrative interface of warehouse:

00:19:48,980 --> 00:19:51,440
Checks and Verdict.

00:19:51,440 --> 00:19:56,580
The administrative Checks interface enables and administrator to

00:19:56,820 --> 00:20:04,640
enable, disable, evaluate, or completely wipe out a check.

00:20:17,160 --> 00:20:25,900
It also provides metadata about the check and offers the ability to initiate an evaluation run.

00:20:26,060 --> 00:20:30,860
The administrative Verdicts interface shows all the results

00:20:32,500 --> 00:20:36,820
generated by the checks.

00:20:36,820 --> 00:20:46,460
Since there are a lot of verdicts, the interface includes a filtering function to only show the most urgent verdicts.

00:20:57,440 --> 00:21:00,760
After reviewing a verdict,

00:21:09,000 --> 00:21:12,395
an administrator can mark it as "Benign".

00:21:12,400 --> 00:21:18,000
When this happens, the verdicts disappears from the default view.

00:21:25,940 --> 00:21:31,860
Since all of this is open source, we want the collaboration of the community in writing checks.

00:21:31,860 --> 00:21:35,600
It's easy to contribute new malware checks to PyPI.

00:21:35,600 --> 00:21:38,895
First, open a Github issue in the warehouse repository

00:21:38,900 --> 00:21:41,680
and describe the check that you want to implement.

00:21:41,680 --> 00:21:44,260
If the feedback from the community is positive,

00:21:44,260 --> 00:21:47,460
write the code and open a pull request.

00:21:47,460 --> 00:21:52,280
The administrators can then review the pull request and decide if they want to

00:21:52,280 --> 00:21:55,880
merge it, enable it, or not use it.

00:21:56,800 --> 00:21:59,660
Developing a new check is also easy.

00:21:59,660 --> 00:22:04,800
First, download the warehouse codebase and bring up the docker containers.

00:22:04,800 --> 00:22:09,440
Second, subclass the MalwareCheckBase class and write the check.

00:22:09,440 --> 00:22:17,260
To activate it, modify an environment variable and install the check with a script.

00:22:17,340 --> 00:22:22,460
Now, all that's left is enabling the check in the admin interface.

00:22:23,020 --> 00:22:26,235
You can find a summary of this talk,

00:22:26,240 --> 00:22:29,400
minus the details of my vacation in Guatemala,

00:22:29,400 --> 00:22:32,140
in the warehouse developer docs.

00:22:32,600 --> 00:22:40,820
I worked on the development of this system between December 2019 and February 2020.

00:22:40,820 --> 00:22:44,720
We shipped it on Feb 11 with this pull request,

00:22:44,720 --> 00:22:48,880
which consists of approximately 4,000 lines of code.

00:22:51,040 --> 00:22:53,660
Spanish is not my first language.

00:22:53,660 --> 00:22:58,300
As such, I'd like to acknowledge my friends Marco Palacios and Christian Navarrete.

00:22:58,300 --> 00:23:03,020
They helped me translate and correct the content of this talk,

00:23:03,020 --> 00:23:05,760
especially the technical vocabulary.

00:23:05,760 --> 00:23:09,440
I'd also like to thank Ernest,

00:23:09,440 --> 00:23:12,980
the Director of Infrastructure for the Python Software Foundation.

00:23:12,980 --> 00:23:17,620
He provided crucial feedback on the design of this system,

00:23:17,620 --> 00:23:22,180
and contributed code and code reviews at every stage of the project.

00:23:22,180 --> 00:23:25,440
William Woodruff also helped with code reviews,

00:23:25,460 --> 00:23:30,680
the implementation of the checks, and ideas to improve various elements of the system.

00:23:31,300 --> 00:23:33,040
That's a wrap!

00:23:33,040 --> 00:23:37,420
If you have any doubts, questions or comments, please get in touch

00:23:37,420 --> 00:23:38,580
in English or Spanish.

00:23:38,980 --> 00:23:43,980
I hope that you've been inspired to try new things, and above all

00:23:43,980 --> 00:23:49,200
apply your expertise to open source software, even if it intimidates you.

00:23:49,200 --> 00:23:52,660

YouTube URL: https://www.youtube.com/watch?v=Lluu64ri3Qg


