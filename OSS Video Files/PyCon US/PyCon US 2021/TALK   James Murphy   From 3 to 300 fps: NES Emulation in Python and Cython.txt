Title: TALK   James Murphy   From 3 to 300 fps: NES Emulation in Python and Cython
Publication date: 2021-05-29
Playlist: PyCon US 2021
Description: 
	It is sometimes asserted that “Python is a real bad choice for any kind of real-time system”. When I first got my Python NES emulator to boot, only for it to run at 2 frames per second, I felt like agreeing. But is it really true? After just a few days reworking the emulator’s operational core into Cython, the framerate is now above 300fps, proving that Python is a viable choice for emulator development and other performance-dependent projects. In this talk, I will outline the advantages and some challenges of using Cython to achieve realtime performance from an existing Python codebase.

Slides: https://docs.google.com/presentation/d/e/2PACX-1vTj4Y7KEy5hhOlYKqbSdUDbFLol4tw91Qvn7otLdFTb-rCwhP4kLKYieYUzhcDnV9OGtgxuraQV3-ep/pub?start=false&loop=false&delayms=3000
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:15,360 --> 00:00:18,640
hello i'm james murphy thank you for

00:00:16,800 --> 00:00:20,640
coming uh today i'm going to be talking

00:00:18,640 --> 00:00:22,480
about nes emulation in python

00:00:20,640 --> 00:00:23,760
and how to speed that up from three to

00:00:22,480 --> 00:00:26,720
300 frames per second

00:00:23,760 --> 00:00:28,000
using cython so what's going to be in

00:00:26,720 --> 00:00:29,039
the talk today

00:00:28,000 --> 00:00:30,880
i'm going to start off talking a little

00:00:29,039 --> 00:00:32,640
bit about the project which is emulating

00:00:30,880 --> 00:00:33,520
the nintendo entertainment system the

00:00:32,640 --> 00:00:36,559
nez

00:00:33,520 --> 00:00:38,079
um a little bit bit about emulation in

00:00:36,559 --> 00:00:39,520
general so why it's an interesting

00:00:38,079 --> 00:00:40,559
problem and a problem that's worth

00:00:39,520 --> 00:00:43,600
tackling

00:00:40,559 --> 00:00:44,960
um why python is not necessarily a

00:00:43,600 --> 00:00:46,079
conventional choice for writing an

00:00:44,960 --> 00:00:48,000
emulator

00:00:46,079 --> 00:00:50,320
um but why you know you can go and write

00:00:48,000 --> 00:00:52,640
an emulator from python and how to do it

00:00:50,320 --> 00:00:54,160
um and then a little bit about using

00:00:52,640 --> 00:00:56,399
syphon to make it go fast

00:00:54,160 --> 00:00:58,160
fast enough to be playable um some of

00:00:56,399 --> 00:00:59,920
the advantages of syphon

00:00:58,160 --> 00:01:02,559
and also some of its hazards and

00:00:59,920 --> 00:01:03,840
pitfalls that it can sort of open up

00:01:02,559 --> 00:01:05,280
finally i'm going to talk a little bit

00:01:03,840 --> 00:01:06,799
about lessons that i've taken away from

00:01:05,280 --> 00:01:10,799
this project for my day job

00:01:06,799 --> 00:01:10,799
which is as a data scientist

00:01:10,960 --> 00:01:14,560
so what is emulation well emulation is

00:01:13,600 --> 00:01:17,119
the process

00:01:14,560 --> 00:01:18,720
of recreating a historic computer system

00:01:17,119 --> 00:01:20,880
in this case the gray box of the

00:01:18,720 --> 00:01:23,200
nintendo entertainment system in the uh

00:01:20,880 --> 00:01:24,000
the top right corner here and turning

00:01:23,200 --> 00:01:26,159
that into

00:01:24,000 --> 00:01:27,280
a piece of software re-implementing the

00:01:26,159 --> 00:01:30,400
piece of hardware

00:01:27,280 --> 00:01:32,640
in a piece of software um

00:01:30,400 --> 00:01:34,079
and so that software has to implement

00:01:32,640 --> 00:01:35,280
all of the hardware behavior that was

00:01:34,079 --> 00:01:38,240
visible to software

00:01:35,280 --> 00:01:41,200
that ran on that piece of original

00:01:38,240 --> 00:01:42,640
computing hardware and behaving exactly

00:01:41,200 --> 00:01:44,240
the same way as the hardware would have

00:01:42,640 --> 00:01:45,840
done so the software running on the

00:01:44,240 --> 00:01:46,799
virtual machine that you create in your

00:01:45,840 --> 00:01:49,200
emulator

00:01:46,799 --> 00:01:50,399
doesn't realize that it's not running on

00:01:49,200 --> 00:01:52,960
a actual

00:01:50,399 --> 00:01:54,000
piece of original hardware so that

00:01:52,960 --> 00:01:55,520
involves recreating

00:01:54,000 --> 00:01:57,360
all of the programmers guide to all of

00:01:55,520 --> 00:01:59,520
the the functions that were documented

00:01:57,360 --> 00:02:02,640
by the manufacturer of the hardware

00:01:59,520 --> 00:02:03,759
for software writers um that told them

00:02:02,640 --> 00:02:04,479
how they could interact with the

00:02:03,759 --> 00:02:08,080
hardware

00:02:04,479 --> 00:02:10,000
but it also involves um recreating any

00:02:08,080 --> 00:02:12,640
well-known undocumented features

00:02:10,000 --> 00:02:13,920
so in particular for game systems uh

00:02:12,640 --> 00:02:15,840
undocumented features were often

00:02:13,920 --> 00:02:17,120
popularly kind of exploited to either

00:02:15,840 --> 00:02:18,959
make special effects

00:02:17,120 --> 00:02:20,800
or just drive a little bit of extra

00:02:18,959 --> 00:02:22,000
performance out of these systems which

00:02:20,800 --> 00:02:23,440
were quite limited

00:02:22,000 --> 00:02:24,720
and you know the programmers at the time

00:02:23,440 --> 00:02:25,040
were really trying to do everything they

00:02:24,720 --> 00:02:29,040
could

00:02:25,040 --> 00:02:29,040
to to maximize the performance

00:02:29,520 --> 00:02:34,640
and the aim of an emulator is for um

00:02:32,720 --> 00:02:36,560
original software that used to run on

00:02:34,640 --> 00:02:38,160
the hardware system to run um as if it

00:02:36,560 --> 00:02:39,599
was running on the real hardware produce

00:02:38,160 --> 00:02:41,920
the same outputs

00:02:39,599 --> 00:02:43,519
um you know with given the same set of

00:02:41,920 --> 00:02:44,800
inputs um

00:02:43,519 --> 00:02:46,959
essentially you're trying to trick the

00:02:44,800 --> 00:02:48,720
software into thinking that

00:02:46,959 --> 00:02:50,480
it's running on that original piece of

00:02:48,720 --> 00:02:52,720
hardware which is i think just a really

00:02:50,480 --> 00:02:54,959
fun thing to do

00:02:52,720 --> 00:02:56,720
so why emulate well emulation is all

00:02:54,959 --> 00:02:58,560
about allowing old software to continue

00:02:56,720 --> 00:03:01,599
to run on modern hardware

00:02:58,560 --> 00:03:02,480
and part of that is about preserving

00:03:01,599 --> 00:03:04,560
access to

00:03:02,480 --> 00:03:05,599
to this old software which you know as

00:03:04,560 --> 00:03:06,800
you can see from the advert on the

00:03:05,599 --> 00:03:08,800
right-hand side

00:03:06,800 --> 00:03:11,280
form part of people's childhoods but

00:03:08,800 --> 00:03:14,000
it's also a cultural artifact from the

00:03:11,280 --> 00:03:15,519
the era that it was made in and it's

00:03:14,000 --> 00:03:17,360
part of the history of

00:03:15,519 --> 00:03:18,720
say games development and it's very

00:03:17,360 --> 00:03:19,440
interesting to see how game design has

00:03:18,720 --> 00:03:21,760
changed from

00:03:19,440 --> 00:03:22,959
old games of this era to modern games

00:03:21,760 --> 00:03:26,799
now

00:03:22,959 --> 00:03:28,480
um eventually all of the

00:03:26,799 --> 00:03:30,000
the nintendo entertainment systems in

00:03:28,480 --> 00:03:31,680
the world are going to break

00:03:30,000 --> 00:03:32,879
um they they're getting older there's

00:03:31,680 --> 00:03:34,080
fewer and fewer of them around in

00:03:32,879 --> 00:03:36,640
working condition

00:03:34,080 --> 00:03:38,239
and slowly you know their the access to

00:03:36,640 --> 00:03:40,159
them is becoming more and more limited

00:03:38,239 --> 00:03:41,599
but if we have emulators that can run on

00:03:40,159 --> 00:03:42,480
modern commodity hardware that's

00:03:41,599 --> 00:03:44,400
everywhere

00:03:42,480 --> 00:03:45,760
everybody can still access this software

00:03:44,400 --> 00:03:48,080
and these these sort of pieces of

00:03:45,760 --> 00:03:50,080
cultural history

00:03:48,080 --> 00:03:51,680
it's also a really interesting um

00:03:50,080 --> 00:03:53,599
connection to the old hardware system

00:03:51,680 --> 00:03:55,920
itself essentially emulator development

00:03:53,599 --> 00:03:58,319
is rebuilding the hardware system

00:03:55,920 --> 00:03:59,840
in software and it kind of gives an

00:03:58,319 --> 00:04:01,040
insight into what the designers were

00:03:59,840 --> 00:04:02,879
doing when they built this

00:04:01,040 --> 00:04:04,159
this hardware the limitations that they

00:04:02,879 --> 00:04:06,159
were working under

00:04:04,159 --> 00:04:07,920
and it sometimes explains some of the

00:04:06,159 --> 00:04:09,120
the strange behavior or some of the the

00:04:07,920 --> 00:04:11,360
kind of um

00:04:09,120 --> 00:04:12,720
quirkiness of of games because you you

00:04:11,360 --> 00:04:14,000
sort of find out that it was it was

00:04:12,720 --> 00:04:15,599
running in a particular way

00:04:14,000 --> 00:04:17,680
to get around limitations of the

00:04:15,599 --> 00:04:19,519
hardware so it's very interesting to

00:04:17,680 --> 00:04:21,199
kind of see how the hardware and

00:04:19,519 --> 00:04:23,520
the game software that you saw actually

00:04:21,199 --> 00:04:26,320
interact with each other

00:04:23,520 --> 00:04:27,280
um it's also a really fun challenge

00:04:26,320 --> 00:04:29,280
emulators

00:04:27,280 --> 00:04:31,040
are quite difficult to write in some

00:04:29,280 --> 00:04:32,720
cases it's hard to get them working if

00:04:31,040 --> 00:04:34,479
you like debugging they're great because

00:04:32,720 --> 00:04:36,160
you know you inevitably come up on uh

00:04:34,479 --> 00:04:37,840
strange bugs and strange behavior that

00:04:36,160 --> 00:04:41,919
you have to try and figure out

00:04:37,840 --> 00:04:43,040
um they are small enough though that you

00:04:41,919 --> 00:04:43,520
can kind of tackle them as a hobby

00:04:43,040 --> 00:04:45,759
project

00:04:43,520 --> 00:04:47,759
so they're a really fun kind of hobby

00:04:45,759 --> 00:04:49,520
programming challenge

00:04:47,759 --> 00:04:51,120
and there's also a great community

00:04:49,520 --> 00:04:53,919
around emulation so

00:04:51,120 --> 00:04:55,280
things like emudev on reddit loads of

00:04:53,919 --> 00:04:56,400
really knowledgeable people with loads

00:04:55,280 --> 00:04:59,040
of great information

00:04:56,400 --> 00:04:59,680
and knowledge about old hardware systems

00:04:59,040 --> 00:05:01,039
and

00:04:59,680 --> 00:05:02,960
where you can find information about

00:05:01,039 --> 00:05:04,800
those and for this project

00:05:02,960 --> 00:05:06,080
nezdev is a phenomenal resource about

00:05:04,800 --> 00:05:07,680
the nes

00:05:06,080 --> 00:05:09,840
has a wiki which basically details all

00:05:07,680 --> 00:05:11,280
of the technical operation of the nes

00:05:09,840 --> 00:05:12,639
and then there's some great forums where

00:05:11,280 --> 00:05:14,160
people answer questions about the

00:05:12,639 --> 00:05:15,919
problems that you inevitably run into

00:05:14,160 --> 00:05:18,479
trying to build an emulator

00:05:15,919 --> 00:05:19,520
um it's incredible the work that goes

00:05:18,479 --> 00:05:21,440
into these sites

00:05:19,520 --> 00:05:22,960
you know is what makes building an

00:05:21,440 --> 00:05:24,080
emulator sort of in a reasonable amount

00:05:22,960 --> 00:05:26,160
of time as a hobby

00:05:24,080 --> 00:05:27,280
possible it's just incredible amount of

00:05:26,160 --> 00:05:29,199
work that's been done to

00:05:27,280 --> 00:05:31,199
to understand the behavior of these you

00:05:29,199 --> 00:05:31,759
know proprietary systems from back in

00:05:31,199 --> 00:05:34,000
the day

00:05:31,759 --> 00:05:34,880
so without them none of this would be

00:05:34,000 --> 00:05:37,840
possible

00:05:34,880 --> 00:05:38,479
so why emulate in python in many ways

00:05:37,840 --> 00:05:40,560
python

00:05:38,479 --> 00:05:41,919
is not considered sort of a natural

00:05:40,560 --> 00:05:42,880
language formulation it's actually

00:05:41,919 --> 00:05:45,919
rarely used

00:05:42,880 --> 00:05:47,360
for emulation and if you go on a forum

00:05:45,919 --> 00:05:48,960
like emudev

00:05:47,360 --> 00:05:50,479
you can find people expressing opinions

00:05:48,960 --> 00:05:52,800
like you know python's a really bad idea

00:05:50,479 --> 00:05:54,960
for real-time systems

00:05:52,800 --> 00:05:56,479
and the general consensus is that it's

00:05:54,960 --> 00:05:58,160
considered to be

00:05:56,479 --> 00:06:00,560
too slow really to do something like

00:05:58,160 --> 00:06:02,479
emulation which is pretty intensive

00:06:00,560 --> 00:06:03,600
because you're having to simulate all

00:06:02,479 --> 00:06:05,520
the functions of the

00:06:03,600 --> 00:06:07,759
computer right down to the internal

00:06:05,520 --> 00:06:09,759
operation of the microprocessor itself

00:06:07,759 --> 00:06:11,520
there's a lot going on and there's a lot

00:06:09,759 --> 00:06:12,960
of kind of individual tasks that have to

00:06:11,520 --> 00:06:14,319
be done which in electronics obviously

00:06:12,960 --> 00:06:16,160
can all happen in parallel

00:06:14,319 --> 00:06:17,600
but in software they have to happen kind

00:06:16,160 --> 00:06:20,800
of sequentially

00:06:17,600 --> 00:06:23,280
so python is uh

00:06:20,800 --> 00:06:24,000
generally within the emulation community

00:06:23,280 --> 00:06:27,840
the cena's

00:06:24,000 --> 00:06:30,800
on the slow side um but for me

00:06:27,840 --> 00:06:32,240
um python's my daily driver um it's a

00:06:30,800 --> 00:06:34,400
language i use at work

00:06:32,240 --> 00:06:36,319
i wasn't too keen to go and learn a new

00:06:34,400 --> 00:06:37,919
language i was also interested to see

00:06:36,319 --> 00:06:40,720
if this is something that could be done

00:06:37,919 --> 00:06:42,240
in python as well um

00:06:40,720 --> 00:06:43,759
python's great as well for a lot of

00:06:42,240 --> 00:06:44,560
reasons as i think everybody here

00:06:43,759 --> 00:06:47,520
probably knows

00:06:44,560 --> 00:06:49,120
um python's has loads of great tools and

00:06:47,520 --> 00:06:52,000
loads of great libraries available

00:06:49,120 --> 00:06:53,919
for it and that makes development very

00:06:52,000 --> 00:06:54,800
easy and very rapid and it's sort of

00:06:53,919 --> 00:06:58,160
enjoyable and

00:06:54,800 --> 00:06:59,520
um to build stuff in python

00:06:58,160 --> 00:07:02,560
because you get to see it kind of come

00:06:59,520 --> 00:07:03,280
together very quickly um and finally

00:07:02,560 --> 00:07:06,080
it's also

00:07:03,280 --> 00:07:07,520
a little platform independent um i have

00:07:06,080 --> 00:07:07,759
an asterisk here because i think some of

00:07:07,520 --> 00:07:09,680
the

00:07:07,759 --> 00:07:11,759
some of the stuff that i've done later

00:07:09,680 --> 00:07:12,960
to make it fast with cyphon has

00:07:11,759 --> 00:07:14,960
perhaps lessened the platform

00:07:12,960 --> 00:07:17,919
independence um

00:07:14,960 --> 00:07:19,440
but still um you can write python once

00:07:17,919 --> 00:07:22,160
and you can run it on a whole bunch of

00:07:19,440 --> 00:07:25,360
different platforms which is really nice

00:07:22,160 --> 00:07:28,479
so what does a nes look like emulated

00:07:25,360 --> 00:07:30,960
in python um well the nice thing

00:07:28,479 --> 00:07:31,680
is that particularly with old hardware

00:07:30,960 --> 00:07:34,240
components

00:07:31,680 --> 00:07:36,000
um emulators actually look in many ways

00:07:34,240 --> 00:07:37,759
very much like the physical device that

00:07:36,000 --> 00:07:38,240
they come from that they are emulating

00:07:37,759 --> 00:07:41,039
so

00:07:38,240 --> 00:07:42,960
on the left hand side here is a nes main

00:07:41,039 --> 00:07:44,800
board from 1987

00:07:42,960 --> 00:07:48,639
and on the right hand side is the

00:07:44,800 --> 00:07:51,680
software structure of my python emulator

00:07:48,639 --> 00:07:52,960
and you can see that there's modules um

00:07:51,680 --> 00:07:56,000
really corresponding to each of these

00:07:52,960 --> 00:07:59,440
physical chips so for example

00:07:56,000 --> 00:08:01,840
this here is the cpu this is a moss 6502

00:07:59,440 --> 00:08:02,560
cpu one of the the sort of two really

00:08:01,840 --> 00:08:04,879
big uh

00:08:02,560 --> 00:08:05,840
8-bit cpus along with the z80 from that

00:08:04,879 --> 00:08:09,039
era

00:08:05,840 --> 00:08:10,639
for like home systems um

00:08:09,039 --> 00:08:12,960
and emulating the cpu is really all

00:08:10,639 --> 00:08:14,080
about emulating all of the registers in

00:08:12,960 --> 00:08:15,680
the cpu

00:08:14,080 --> 00:08:17,280
and then a function for each of the

00:08:15,680 --> 00:08:19,840
instructions within it so

00:08:17,280 --> 00:08:21,680
that it manipulates the internal state

00:08:19,840 --> 00:08:23,680
of the the processor

00:08:21,680 --> 00:08:25,039
in the correct way the nice thing about

00:08:23,680 --> 00:08:26,160
a processor and it's a great place to

00:08:25,039 --> 00:08:29,280
start with emulator

00:08:26,160 --> 00:08:31,280
is that you can test it against

00:08:29,280 --> 00:08:34,479
known outputs and you can monitor its

00:08:31,280 --> 00:08:34,479
internal states very clear

00:08:36,240 --> 00:08:40,240
the second sort of piece of the emulator

00:08:39,519 --> 00:08:42,719
um

00:08:40,240 --> 00:08:44,159
is the the ram so here are two pieces of

00:08:42,719 --> 00:08:45,760
ram the nez actually only has two

00:08:44,159 --> 00:08:48,880
kilobytes of onboard ram

00:08:45,760 --> 00:08:52,560
um but onboard video ram and onboard

00:08:48,880 --> 00:08:54,880
um main memory um

00:08:52,560 --> 00:08:56,080
and in the in the nes um obviously ram

00:08:54,880 --> 00:08:57,920
itself is is pretty simple it's

00:08:56,080 --> 00:09:01,279
basically just an array

00:08:57,920 --> 00:09:03,600
uh but because of the way um the the nez

00:09:01,279 --> 00:09:05,519
addresses um pieces of hardware through

00:09:03,600 --> 00:09:07,360
memory map locations in the ram

00:09:05,519 --> 00:09:09,440
the memory controller actually becomes

00:09:07,360 --> 00:09:10,480
somewhat involved because it has to

00:09:09,440 --> 00:09:13,040
allocate

00:09:10,480 --> 00:09:14,320
any rights or reads to um specific

00:09:13,040 --> 00:09:16,000
memory mapped ports

00:09:14,320 --> 00:09:17,680
to the correct pieces of heart so it has

00:09:16,000 --> 00:09:19,600
to sort of route to the correct pieces

00:09:17,680 --> 00:09:22,640
of hardware

00:09:19,600 --> 00:09:23,279
um the next sort of big piece of the

00:09:22,640 --> 00:09:25,519
system

00:09:23,279 --> 00:09:26,399
uh to emulate uh to get things up and

00:09:25,519 --> 00:09:29,760
running is

00:09:26,399 --> 00:09:31,120
this guy here this is the um the ppu the

00:09:29,760 --> 00:09:34,399
picture processing unit

00:09:31,120 --> 00:09:37,279
um and this is really the first piece of

00:09:34,399 --> 00:09:37,920
uh i guess custom nintendo hardware on

00:09:37,279 --> 00:09:39,200
the board

00:09:37,920 --> 00:09:41,279
um that you come across when you're

00:09:39,200 --> 00:09:44,880
emulating so

00:09:41,279 --> 00:09:46,240
um this is unlike the 6502 which was an

00:09:44,880 --> 00:09:47,600
off-the-shelf processor this is much

00:09:46,240 --> 00:09:51,519
more of a custom

00:09:47,600 --> 00:09:53,040
chip which takes the inputs and

00:09:51,519 --> 00:09:56,240
turns them into the actual the actual

00:09:53,040 --> 00:09:58,480
video signal that you see um

00:09:56,240 --> 00:10:00,000
so there's a whole bunch of logic in

00:09:58,480 --> 00:10:02,160
here which is is maybe

00:10:00,000 --> 00:10:04,000
like a little less well documented than

00:10:02,160 --> 00:10:06,480
something like the 6502 which is

00:10:04,000 --> 00:10:07,839
kind of common um and all over the place

00:10:06,480 --> 00:10:08,959
but the nice thing about this is once

00:10:07,839 --> 00:10:11,200
you get it working

00:10:08,959 --> 00:10:12,640
you get to see um something come out and

00:10:11,200 --> 00:10:13,279
hopefully that looks something like a

00:10:12,640 --> 00:10:16,399
game or

00:10:13,279 --> 00:10:18,800
at least a game logo the software house

00:10:16,399 --> 00:10:22,480
logo that you might see at the beginning

00:10:18,800 --> 00:10:24,640
um another piece is the controllers

00:10:22,480 --> 00:10:25,519
um yeah this is where they plug into the

00:10:24,640 --> 00:10:27,120
board um

00:10:25,519 --> 00:10:28,320
they're relatively straightforward to

00:10:27,120 --> 00:10:28,959
implement they only get checked

00:10:28,320 --> 00:10:30,560
relatively

00:10:28,959 --> 00:10:32,720
infrequently so once per frame is

00:10:30,560 --> 00:10:34,720
adequate and so so they they can be

00:10:32,720 --> 00:10:35,839
a nice simple piece but what isn't

00:10:34,720 --> 00:10:38,880
simple on the nets

00:10:35,839 --> 00:10:38,880
is um

00:10:39,279 --> 00:10:44,640
is the cartridges so cartridges are kind

00:10:42,160 --> 00:10:45,839
of the bane of nes emulation because the

00:10:44,640 --> 00:10:48,959
cartridge

00:10:45,839 --> 00:10:51,680
actually plugs directly into um

00:10:48,959 --> 00:10:53,600
both the main processor memory bus and

00:10:51,680 --> 00:10:56,720
also the video memory bus

00:10:53,600 --> 00:11:00,000
and so that allows in addition to

00:10:56,720 --> 00:11:01,279
adding extra memory to the system um so

00:11:00,000 --> 00:11:01,920
cartridges can have their own memory

00:11:01,279 --> 00:11:04,720
video and

00:11:01,920 --> 00:11:06,079
and regular memory um which can be rom

00:11:04,720 --> 00:11:08,000
or ram

00:11:06,079 --> 00:11:09,360
but also uh some of the cartridges can

00:11:08,000 --> 00:11:11,040
do uh things like

00:11:09,360 --> 00:11:12,959
i hook directly into some of the memory

00:11:11,040 --> 00:11:13,360
lines uh one of them on the common ones

00:11:12,959 --> 00:11:16,399
hooks

00:11:13,360 --> 00:11:19,200
insert line a12 on the video bus

00:11:16,399 --> 00:11:20,640
um in order to count the number of lines

00:11:19,200 --> 00:11:23,200
that have gone past in a frame

00:11:20,640 --> 00:11:24,800
so so giving access games like scanline

00:11:23,200 --> 00:11:26,000
counters

00:11:24,800 --> 00:11:27,440
and that's really easy to implement in

00:11:26,000 --> 00:11:29,200
electronics of course because you just

00:11:27,440 --> 00:11:31,279
connect two wires together but

00:11:29,200 --> 00:11:32,480
um in software it can become a bit of a

00:11:31,279 --> 00:11:34,800
hassle when you're trying to sort of

00:11:32,480 --> 00:11:36,000
plug everything together and actually

00:11:34,800 --> 00:11:37,760
there's something like

00:11:36,000 --> 00:11:39,839
i mean there's hundreds i think of of

00:11:37,760 --> 00:11:43,120
cartridge types than there's although

00:11:39,839 --> 00:11:46,240
maybe the top 10 cover about 85 of the

00:11:43,120 --> 00:11:47,519
of the games um and so once you have all

00:11:46,240 --> 00:11:48,959
of these components you have to sort of

00:11:47,519 --> 00:11:50,160
plug them all together fit them together

00:11:48,959 --> 00:11:52,560
to actually build the system that's the

00:11:50,160 --> 00:11:55,360
system component here in the emulator

00:11:52,560 --> 00:11:57,040
and hopefully when you turn it on i've

00:11:55,360 --> 00:11:58,079
missed out the audio processor here but

00:11:57,040 --> 00:12:01,120
once you turn this on

00:11:58,079 --> 00:12:02,800
you should see it boot and the black

00:12:01,120 --> 00:12:04,880
screen turned into a game logo

00:12:02,800 --> 00:12:06,959
and a picture and eventually a game

00:12:04,880 --> 00:12:08,720
appear

00:12:06,959 --> 00:12:10,240
so if you go out and implement all of

00:12:08,720 --> 00:12:12,240
those things in python

00:12:10,240 --> 00:12:14,079
you end up with an as emulator which

00:12:12,240 --> 00:12:17,200
works hopefully

00:12:14,079 --> 00:12:20,800
um and you end up with this

00:12:17,200 --> 00:12:20,800
something which boots but

00:12:22,160 --> 00:12:26,639
it doesn't run very quickly um and so

00:12:25,200 --> 00:12:28,880
actually

00:12:26,639 --> 00:12:30,320
the first time testing i mean testing

00:12:28,880 --> 00:12:32,880
the system is kind of interesting

00:12:30,320 --> 00:12:34,399
um you sort of run it and it just it's a

00:12:32,880 --> 00:12:36,399
black screen because it's crashed in

00:12:34,399 --> 00:12:38,079
some way and so that happens

00:12:36,399 --> 00:12:39,440
over and over and over again when you're

00:12:38,079 --> 00:12:40,079
actually writing this thing is you just

00:12:39,440 --> 00:12:42,160
sort of

00:12:40,079 --> 00:12:43,440
boot it nothing happens and it's

00:12:42,160 --> 00:12:44,000
probably because it's crashed somewhere

00:12:43,440 --> 00:12:45,839
because

00:12:44,000 --> 00:12:47,680
some piece of behavior isn't properly

00:12:45,839 --> 00:12:49,120
implemented

00:12:47,680 --> 00:12:51,120
so that was what i was doing all the

00:12:49,120 --> 00:12:52,800
time when i was um

00:12:51,120 --> 00:12:55,360
was testing and sort of first trying to

00:12:52,800 --> 00:12:57,279
get the thing to boot um

00:12:55,360 --> 00:12:59,120
didn't actually manage to to get it to

00:12:57,279 --> 00:13:01,440
boot i thought for a really long time

00:12:59,120 --> 00:13:02,959
i was getting kind of frustrated and i

00:13:01,440 --> 00:13:04,480
think i was looking over the code again

00:13:02,959 --> 00:13:06,079
to try and figure out what was happening

00:13:04,480 --> 00:13:08,240
and why it wasn't working and then

00:13:06,079 --> 00:13:09,360
suddenly i'd obviously left it running

00:13:08,240 --> 00:13:11,200
the window in the background just

00:13:09,360 --> 00:13:11,680
displayed the donkey kong logo and i was

00:13:11,200 --> 00:13:14,959
like

00:13:11,680 --> 00:13:17,680
huh okay it's actually running

00:13:14,959 --> 00:13:18,320
it's just it turned out i didn't have

00:13:17,680 --> 00:13:20,480
the frame

00:13:18,320 --> 00:13:21,680
rate counter at that point um it just

00:13:20,480 --> 00:13:23,279
turned out it was running incredibly

00:13:21,680 --> 00:13:24,880
incredibly slowly about two

00:13:23,279 --> 00:13:26,399
between two and three frames a second so

00:13:24,880 --> 00:13:29,200
this like

00:13:26,399 --> 00:13:30,560
10 second or five second sort of loading

00:13:29,200 --> 00:13:32,240
screen time actually took

00:13:30,560 --> 00:13:33,920
you know a minute or something like that

00:13:32,240 --> 00:13:34,240
to actually get through and to display

00:13:33,920 --> 00:13:37,600
the

00:13:34,240 --> 00:13:40,079
the logo so how

00:13:37,600 --> 00:13:41,440
then do you fix that how do you how do

00:13:40,079 --> 00:13:42,560
you sort of go about making it faster

00:13:41,440 --> 00:13:45,680
and making it particularly

00:13:42,560 --> 00:13:48,160
making it fast enough to actually run so

00:13:45,680 --> 00:13:49,360
standard optimization gave pretty good

00:13:48,160 --> 00:13:51,440
results you know

00:13:49,360 --> 00:13:53,519
i kind of managed to get about two or

00:13:51,440 --> 00:13:55,440
two three times speed up the problem was

00:13:53,519 --> 00:13:56,160
it wasn't fast enough it needed to be

00:13:55,440 --> 00:13:59,920
about 20

00:13:56,160 --> 00:14:02,000
times faster than it started out and

00:13:59,920 --> 00:14:03,680
the problem i was also finding was that

00:14:02,000 --> 00:14:04,399
the further optimization i was doing was

00:14:03,680 --> 00:14:07,120
starting to

00:14:04,399 --> 00:14:08,880
distort the code structure um and i i

00:14:07,120 --> 00:14:09,279
kind of felt like once you start to get

00:14:08,880 --> 00:14:12,240
to

00:14:09,279 --> 00:14:13,760
the point where you know you're sort of

00:14:12,240 --> 00:14:15,519
doing stuff which is like

00:14:13,760 --> 00:14:17,040
very non-pythonic or like trying to

00:14:15,519 --> 00:14:20,320
avoid making classes

00:14:17,040 --> 00:14:21,360
or all kinds of stuff which you know you

00:14:20,320 --> 00:14:24,320
shouldn't really be doing

00:14:21,360 --> 00:14:25,040
um just to make it go faster you're kind

00:14:24,320 --> 00:14:27,040
of

00:14:25,040 --> 00:14:28,399
distorting the code structure so much

00:14:27,040 --> 00:14:30,240
that actually you're losing a lot of the

00:14:28,399 --> 00:14:31,760
benefits of a language like python which

00:14:30,240 --> 00:14:33,279
is quite a nice friendly readable

00:14:31,760 --> 00:14:35,680
language

00:14:33,279 --> 00:14:37,600
so what do you do now you have to go and

00:14:35,680 --> 00:14:42,800
re-implement everything

00:14:37,600 --> 00:14:44,320
in um go or c-plus plus or rust

00:14:42,800 --> 00:14:45,839
i wasn't too keen to do that i thought

00:14:44,320 --> 00:14:46,639
you know maybe that was inevitable i'd

00:14:45,839 --> 00:14:48,959
have to do that

00:14:46,639 --> 00:14:50,240
but um obviously it wasn't my preferred

00:14:48,959 --> 00:14:51,920
choice i had this big code base in

00:14:50,240 --> 00:14:53,279
python it was actually finally working

00:14:51,920 --> 00:14:56,079
for the first time which was

00:14:53,279 --> 00:14:57,760
was great so instead of rewriting

00:14:56,079 --> 00:14:59,120
everything in a different language uh

00:14:57,760 --> 00:15:01,360
the solution that i thought i would try

00:14:59,120 --> 00:15:04,560
at least before doing that was to

00:15:01,360 --> 00:15:07,199
give syphon a go so psython is

00:15:04,560 --> 00:15:08,240
an amazing tool for python which can

00:15:07,199 --> 00:15:11,199
compile python

00:15:08,240 --> 00:15:15,040
into c and therefore into native machine

00:15:11,199 --> 00:15:17,040
code for the platform that you're on

00:15:15,040 --> 00:15:18,560
it implements a superset of python so

00:15:17,040 --> 00:15:20,959
that you can take

00:15:18,560 --> 00:15:21,839
existing python code bases and compile

00:15:20,959 --> 00:15:23,920
them

00:15:21,839 --> 00:15:25,279
directly and that should the authors say

00:15:23,920 --> 00:15:26,800
give you about a 10 to 20

00:15:25,279 --> 00:15:28,399
speed up without really doing anything

00:15:26,800 --> 00:15:31,519
at all to your code

00:15:28,399 --> 00:15:32,880
um so that's really nice

00:15:31,519 --> 00:15:34,639
you know if you already have a big code

00:15:32,880 --> 00:15:36,079
base you can you can get started very

00:15:34,639 --> 00:15:39,680
easily with syphon

00:15:36,079 --> 00:15:40,720
um but the real benefit of siphon um

00:15:39,680 --> 00:15:43,279
and where it can offer really

00:15:40,720 --> 00:15:45,199
significant speedups is if you

00:15:43,279 --> 00:15:46,320
um do a little bit of type linting in

00:15:45,199 --> 00:15:49,040
your code

00:15:46,320 --> 00:15:50,160
in order to just tell the compiler give

00:15:49,040 --> 00:15:52,639
it some hints as to

00:15:50,160 --> 00:15:54,240
what the variables well really just the

00:15:52,639 --> 00:15:55,120
types of the variables and particularly

00:15:54,240 --> 00:15:58,480
in terms of c

00:15:55,120 --> 00:16:00,240
like native c types um and that lets the

00:15:58,480 --> 00:16:02,079
compiler

00:16:00,240 --> 00:16:03,360
turn past your code into incredibly

00:16:02,079 --> 00:16:04,880
quick c code

00:16:03,360 --> 00:16:06,639
it's really remarkable actually the

00:16:04,880 --> 00:16:09,360
benefits that you can get from it

00:16:06,639 --> 00:16:10,800
and the nice thing about um just having

00:16:09,360 --> 00:16:11,759
to do this type linting is it suits

00:16:10,800 --> 00:16:13,600
emulation

00:16:11,759 --> 00:16:15,440
really well because actually in in the

00:16:13,600 --> 00:16:17,040
case of emulators you're emulating a

00:16:15,440 --> 00:16:18,959
hardware system which is

00:16:17,040 --> 00:16:20,560
based on physical devices that have very

00:16:18,959 --> 00:16:22,079
well known types you know

00:16:20,560 --> 00:16:23,759
for example a register might be eight

00:16:22,079 --> 00:16:25,279
bits and so it's very clearly it can be

00:16:23,759 --> 00:16:27,759
mapped to an unsigned character or

00:16:25,279 --> 00:16:29,600
something like that

00:16:27,759 --> 00:16:31,839
so the nice thing about applying python

00:16:29,600 --> 00:16:32,480
to an existing code base is that it fits

00:16:31,839 --> 00:16:34,399
really well

00:16:32,480 --> 00:16:36,000
with what i've called the optimization

00:16:34,399 --> 00:16:39,680
principle you know only optimize

00:16:36,000 --> 00:16:42,480
what needs to be optimized it's easy to

00:16:39,680 --> 00:16:44,560
optimize uh correct code but it's it's

00:16:42,480 --> 00:16:46,320
very hard to correct optimize code so

00:16:44,560 --> 00:16:48,800
really the less code that you can

00:16:46,320 --> 00:16:49,680
optimize the better in a particular big

00:16:48,800 --> 00:16:51,120
project where you're looking for

00:16:49,680 --> 00:16:53,759
reliability

00:16:51,120 --> 00:16:55,199
and psythen lets you do that because you

00:16:53,759 --> 00:16:55,680
can keep all of your existing python

00:16:55,199 --> 00:16:57,519
code

00:16:55,680 --> 00:16:59,839
and only really apply that optimization

00:16:57,519 --> 00:17:01,199
effort and that synchronization

00:16:59,839 --> 00:17:04,240
to those parts of the code which are

00:17:01,199 --> 00:17:06,160
really hot so a sort of a very sort of

00:17:04,240 --> 00:17:08,400
simple example here is let's say you

00:17:06,160 --> 00:17:10,160
have this emulator which is based on

00:17:08,400 --> 00:17:11,600
these four or contains these four

00:17:10,160 --> 00:17:12,240
functions one of which is like loading a

00:17:11,600 --> 00:17:14,559
rom

00:17:12,240 --> 00:17:15,919
that happens only once per game check

00:17:14,559 --> 00:17:18,240
the controllers

00:17:15,919 --> 00:17:20,000
that maybe only happens once a frame um

00:17:18,240 --> 00:17:22,959
so 60 hertz

00:17:20,000 --> 00:17:24,319
uh decoding a pixel um that happens

00:17:22,959 --> 00:17:26,400
every pixel that's you know you're kind

00:17:24,319 --> 00:17:28,720
of getting up to 90 kilohertz here so

00:17:26,400 --> 00:17:30,720
so this is kind of getting hotter and

00:17:28,720 --> 00:17:32,559
then you might have something in the cpu

00:17:30,720 --> 00:17:33,919
where you're decoding an instruction and

00:17:32,559 --> 00:17:35,919
that's running you know in the kind of

00:17:33,919 --> 00:17:37,600
megahertz range

00:17:35,919 --> 00:17:39,280
so that's that's a sort of really hot

00:17:37,600 --> 00:17:41,280
bit and let's say your emulator here

00:17:39,280 --> 00:17:44,160
runs at five frames per second

00:17:41,280 --> 00:17:45,679
so now you can apply cyclonization you

00:17:44,160 --> 00:17:47,600
can go and syphonize

00:17:45,679 --> 00:17:49,200
you know just the the hottest bit of

00:17:47,600 --> 00:17:49,919
your code so in this case let's start

00:17:49,200 --> 00:17:52,960
off with the

00:17:49,919 --> 00:17:53,679
um the bit that's inside the processor

00:17:52,960 --> 00:17:55,919
itself like

00:17:53,679 --> 00:17:57,360
the real heart of the the cpu that's

00:17:55,919 --> 00:17:59,200
running every instruction so

00:17:57,360 --> 00:18:00,640
go and synchronize that you only have to

00:17:59,200 --> 00:18:03,840
add a little bit of type linting

00:18:00,640 --> 00:18:06,080
um and compile it

00:18:03,840 --> 00:18:07,760
um and then you know maybe that gives

00:18:06,080 --> 00:18:09,200
you a decent speed at 45 frames per

00:18:07,760 --> 00:18:10,559
second it's still not enough

00:18:09,200 --> 00:18:12,080
but it's certainly a big improvement

00:18:10,559 --> 00:18:13,919
over what you did have this is kind of

00:18:12,080 --> 00:18:15,280
the experience i actually had in in real

00:18:13,919 --> 00:18:17,520
life doing this

00:18:15,280 --> 00:18:19,280
um so then you can sort of move to the

00:18:17,520 --> 00:18:22,799
next layer out and go and optimize

00:18:19,280 --> 00:18:25,520
now let's say the uh the tile decoding

00:18:22,799 --> 00:18:27,360
so now if i go and syphonize that that

00:18:25,520 --> 00:18:29,039
maybe gets things up to 95 frames per

00:18:27,360 --> 00:18:30,720
second and that's good enough

00:18:29,039 --> 00:18:32,400
so all of the stuff with the controllers

00:18:30,720 --> 00:18:34,160
loading the roms that can just remain in

00:18:32,400 --> 00:18:36,000
the python that you originally wrote

00:18:34,160 --> 00:18:38,080
and so that's really nice because it

00:18:36,000 --> 00:18:39,760
means that big parts of this code base

00:18:38,080 --> 00:18:42,000
that you've already run and checked

00:18:39,760 --> 00:18:44,160
and tested don't have to be changed at

00:18:42,000 --> 00:18:44,160
all

00:18:44,320 --> 00:18:47,919
so version two of the emulator here it

00:18:47,600 --> 00:18:50,320
is

00:18:47,919 --> 00:18:51,760
um after maybe really only a couple of

00:18:50,320 --> 00:18:55,280
weekends of situating

00:18:51,760 --> 00:18:58,320
this code um and this

00:18:55,280 --> 00:18:59,600
really did run um over 100 times faster

00:18:58,320 --> 00:19:01,280
you can see it here i've taken off all

00:18:59,600 --> 00:19:03,280
of the synchronization so stop it

00:19:01,280 --> 00:19:05,280
limiting it to 60 frames per second

00:19:03,280 --> 00:19:06,640
so it's running at sort of full tilt and

00:19:05,280 --> 00:19:08,160
you can see that the the frame counter

00:19:06,640 --> 00:19:10,160
at the top is kind of

00:19:08,160 --> 00:19:11,600
steadily somewhere between three and

00:19:10,160 --> 00:19:13,840
four hundred frames a second

00:19:11,600 --> 00:19:15,120
um it turns out that mario is very hard

00:19:13,840 --> 00:19:16,320
to play at the speed i did try to get a

00:19:15,120 --> 00:19:16,720
little bit further through this level

00:19:16,320 --> 00:19:19,120
but

00:19:16,720 --> 00:19:20,880
it's basically impossible it's already

00:19:19,120 --> 00:19:21,520
uh i already find it quite difficult and

00:19:20,880 --> 00:19:24,080
uh

00:19:21,520 --> 00:19:26,559
yeah five six times it's it's regular

00:19:24,080 --> 00:19:29,360
speed it's uh too much too much for my

00:19:26,559 --> 00:19:30,240
limited mario skills but um yeah it's

00:19:29,360 --> 00:19:32,240
certainly uh

00:19:30,240 --> 00:19:33,520
psython kind of uh yeah made a huge

00:19:32,240 --> 00:19:35,120
difference here made the emulator

00:19:33,520 --> 00:19:38,160
actually playable and in fact

00:19:35,120 --> 00:19:39,120
this um this piece here is is this

00:19:38,160 --> 00:19:42,160
emulator here

00:19:39,120 --> 00:19:43,840
is running more code than the previous

00:19:42,160 --> 00:19:46,160
one because it's running uh the audio

00:19:43,840 --> 00:19:48,480
unit as well

00:19:46,160 --> 00:19:50,160
so clearly cython has been incredibly

00:19:48,480 --> 00:19:52,160
useful in this project it's allowed the

00:19:50,160 --> 00:19:54,160
emulator to run 100 times faster

00:19:52,160 --> 00:19:56,320
and made it playable and it's done that

00:19:54,160 --> 00:19:57,280
while still allowing a lot of the code

00:19:56,320 --> 00:19:59,200
to be retained

00:19:57,280 --> 00:20:00,720
and that's hugely sped up the

00:19:59,200 --> 00:20:02,480
development process here without having

00:20:00,720 --> 00:20:04,480
to do things like rewrite everything in

00:20:02,480 --> 00:20:06,000
c

00:20:04,480 --> 00:20:07,600
there are some challenges and there are

00:20:06,000 --> 00:20:08,640
some hazards that cycle introduces and

00:20:07,600 --> 00:20:10,320
so i just wanted to take a little bit of

00:20:08,640 --> 00:20:12,720
time to talk about those

00:20:10,320 --> 00:20:13,520
so one thing more an annoyance than a

00:20:12,720 --> 00:20:15,039
real challenge

00:20:13,520 --> 00:20:16,880
is that the code has to be compiled and

00:20:15,039 --> 00:20:18,480
so that just adds an extra step to the

00:20:16,880 --> 00:20:20,080
development process

00:20:18,480 --> 00:20:21,600
um something that's maybe a little more

00:20:20,080 --> 00:20:22,159
important is that it can it can

00:20:21,600 --> 00:20:23,600
sometimes

00:20:22,159 --> 00:20:25,520
uh make the distribution a little bit

00:20:23,600 --> 00:20:26,159
more difficult you end up with platform

00:20:25,520 --> 00:20:28,400
specific

00:20:26,159 --> 00:20:30,400
wheels that can go the distribution or

00:20:28,400 --> 00:20:31,120
relying on cycling compilation on

00:20:30,400 --> 00:20:33,760
install

00:20:31,120 --> 00:20:34,400
and that can be a problem in platforms

00:20:33,760 --> 00:20:36,080
where

00:20:34,400 --> 00:20:38,000
you know a c compiler isn't installed by

00:20:36,080 --> 00:20:40,400
default like windows

00:20:38,000 --> 00:20:42,240
um fast synchronizing of functions

00:20:40,400 --> 00:20:42,880
relying on dynamic length lists can be

00:20:42,240 --> 00:20:45,600
difficult

00:20:42,880 --> 00:20:47,280
um you can still use all of the python

00:20:45,600 --> 00:20:48,640
lists of course but in order to get that

00:20:47,280 --> 00:20:52,080
speed up you

00:20:48,640 --> 00:20:55,120
have to give syphon these type hints and

00:20:52,080 --> 00:20:58,080
it's hard to do that for dynamic lists

00:20:55,120 --> 00:20:59,600
and basic c types um so without sort of

00:20:58,080 --> 00:21:02,799
rewriting those yourself

00:20:59,600 --> 00:21:04,640
you kind of lose some of that advantage

00:21:02,799 --> 00:21:07,440
and again also in insightful objects

00:21:04,640 --> 00:21:09,520
multiple inheritance isn't supported so

00:21:07,440 --> 00:21:10,720
python objects are fine you can use all

00:21:09,520 --> 00:21:12,480
of your python objects as

00:21:10,720 --> 00:21:15,280
they are but if you want to move them

00:21:12,480 --> 00:21:17,120
across into cyto you lose some of that

00:21:15,280 --> 00:21:18,960
some of that flexibility that you might

00:21:17,120 --> 00:21:21,440
have relied on

00:21:18,960 --> 00:21:22,480
um and as well as some of those sort of

00:21:21,440 --> 00:21:23,840
challenges

00:21:22,480 --> 00:21:25,200
there are also some hazards that you can

00:21:23,840 --> 00:21:25,760
introduce by using siphon so you can

00:21:25,200 --> 00:21:29,039
definitely

00:21:25,760 --> 00:21:31,120
use it to create unsafe code

00:21:29,039 --> 00:21:32,240
you can create pointers now which is

00:21:31,120 --> 00:21:33,760
something obviously you can't do in

00:21:32,240 --> 00:21:35,440
python and that means that you can

00:21:33,760 --> 00:21:36,720
create all of the associated seg faults

00:21:35,440 --> 00:21:38,480
that go with those by reading and

00:21:36,720 --> 00:21:40,000
writing off their ends you know into

00:21:38,480 --> 00:21:41,919
memory you don't own

00:21:40,000 --> 00:21:43,440
you can allocate memory which is beyond

00:21:41,919 --> 00:21:46,640
the reach of the garbage collector

00:21:43,440 --> 00:21:48,159
um so potentially causing memory leaks

00:21:46,640 --> 00:21:49,679
and you can disable the global

00:21:48,159 --> 00:21:51,120
interpreter lock um

00:21:49,679 --> 00:21:53,039
which means that you can create unsafe

00:21:51,120 --> 00:21:54,640
concurrency potentially that's kind of a

00:21:53,039 --> 00:21:56,480
mixed blessing because sometimes

00:21:54,640 --> 00:21:57,600
it can be useful to disable that if

00:21:56,480 --> 00:21:58,000
you're going to do something which you

00:21:57,600 --> 00:21:59,679
know to

00:21:58,000 --> 00:22:00,960
be safe you can do some lightweight

00:21:59,679 --> 00:22:02,480
threading which can allow a little bit

00:22:00,960 --> 00:22:05,760
of parallelization

00:22:02,480 --> 00:22:09,280
which you can't manage ordinarily in

00:22:05,760 --> 00:22:11,919
python so cython is a great tool and

00:22:09,280 --> 00:22:13,679
i definitely plan to use psiphon in my

00:22:11,919 --> 00:22:15,280
day job which is as a data scientist and

00:22:13,679 --> 00:22:17,840
leading a data science team

00:22:15,280 --> 00:22:18,480
um for data science cycling has a ton of

00:22:17,840 --> 00:22:22,480
benefits

00:22:18,480 --> 00:22:23,200
um it is really easy to optimize hot

00:22:22,480 --> 00:22:25,919
functions

00:22:23,200 --> 00:22:26,240
um you know in your existing code base

00:22:25,919 --> 00:22:28,000
uh

00:22:26,240 --> 00:22:29,280
including potentially adding little bits

00:22:28,000 --> 00:22:31,200
of concurrency but

00:22:29,280 --> 00:22:32,799
but in particular just gives you access

00:22:31,200 --> 00:22:34,240
to um

00:22:32,799 --> 00:22:36,159
you know the ability to write performant

00:22:34,240 --> 00:22:38,559
code in a language which is sort of

00:22:36,159 --> 00:22:40,400
well-known and already uh used by a lot

00:22:38,559 --> 00:22:42,799
of ds teams um

00:22:40,400 --> 00:22:43,760
so you know a lot of tools already exist

00:22:42,799 --> 00:22:45,840
in um

00:22:43,760 --> 00:22:47,200
python that are heavily used by data

00:22:45,840 --> 00:22:50,400
science teams like numpy

00:22:47,200 --> 00:22:52,000
scipy and pandas and others

00:22:50,400 --> 00:22:54,159
they all work really well with with

00:22:52,000 --> 00:22:56,080
syphon and it interacts really nicely

00:22:54,159 --> 00:22:56,799
with all of those it's very easy to to

00:22:56,080 --> 00:22:59,760
use those

00:22:56,799 --> 00:23:01,120
with with syphon and potentially write

00:22:59,760 --> 00:23:02,799
very fast code

00:23:01,120 --> 00:23:05,039
without having to switch to a different

00:23:02,799 --> 00:23:06,640
language like c

00:23:05,039 --> 00:23:08,159
and also if you just want to write

00:23:06,640 --> 00:23:11,520
little tiny bits of python

00:23:08,159 --> 00:23:12,559
uh even for sort of um prototyping in

00:23:11,520 --> 00:23:13,919
jupiter notebooks

00:23:12,559 --> 00:23:15,600
slightly has cell level integration with

00:23:13,919 --> 00:23:18,080
jupiter's notebooks which is amazing

00:23:15,600 --> 00:23:19,600
um it allows you to just write little

00:23:18,080 --> 00:23:21,600
siphon functions and then

00:23:19,600 --> 00:23:22,960
um yeah use them use them in your

00:23:21,600 --> 00:23:26,240
notebooks

00:23:22,960 --> 00:23:28,320
um i'd say on the flip side of it

00:23:26,240 --> 00:23:29,679
uh the possibility of introducing

00:23:28,320 --> 00:23:30,640
dangerous code particularly for

00:23:29,679 --> 00:23:32,720
production code

00:23:30,640 --> 00:23:34,480
is a risk it's something i'd be sort of

00:23:32,720 --> 00:23:35,440
wary of before encouraging people to go

00:23:34,480 --> 00:23:36,799
and write loads of

00:23:35,440 --> 00:23:38,799
psych and production code because it

00:23:36,799 --> 00:23:40,400
does take away some of those really

00:23:38,799 --> 00:23:41,120
important guard rails that python

00:23:40,400 --> 00:23:42,960
provides

00:23:41,120 --> 00:23:44,400
um so there's definitely a hazard to be

00:23:42,960 --> 00:23:45,919
aware of and i think it's something that

00:23:44,400 --> 00:23:46,480
where you know perhaps if you're not so

00:23:45,919 --> 00:23:48,880
aware

00:23:46,480 --> 00:23:50,000
or cognizant of the risks that you

00:23:48,880 --> 00:23:51,760
introduce by

00:23:50,000 --> 00:23:53,919
using some of these these kind of

00:23:51,760 --> 00:23:55,279
riskier practices within syphon

00:23:53,919 --> 00:23:57,760
it can potentially lead to really hard

00:23:55,279 --> 00:24:00,799
to find bugs in large production systems

00:23:57,760 --> 00:24:02,320
so that's a potential downside

00:24:00,799 --> 00:24:05,200
so that's it thank you very much for

00:24:02,320 --> 00:24:06,080
listening here's the uh a link to the

00:24:05,200 --> 00:24:07,760
the repo

00:24:06,080 --> 00:24:09,360
for this emulator it's all the codes

00:24:07,760 --> 00:24:10,480
available both the python and the cyphon

00:24:09,360 --> 00:24:13,039
code

00:24:10,480 --> 00:24:13,679
pip installer with pip install nintendo

00:24:13,039 --> 00:24:15,600
and

00:24:13,679 --> 00:24:16,720
uh it also runs headlessly without pi

00:24:15,600 --> 00:24:17,919
game so if you want to

00:24:16,720 --> 00:24:20,559
use it for reinforcement learning

00:24:17,919 --> 00:24:23,120
projects or something like that um

00:24:20,559 --> 00:24:24,640
it's available and i would love to see

00:24:23,120 --> 00:24:25,520
people using it thank you very much for

00:24:24,640 --> 00:24:26,720
coming and

00:24:25,520 --> 00:24:33,840
i'd love to answer any questions that

00:24:26,720 --> 00:24:33,840
you have

00:25:59,279 --> 00:26:01,360

YouTube URL: https://www.youtube.com/watch?v=3of9pY2vovA


