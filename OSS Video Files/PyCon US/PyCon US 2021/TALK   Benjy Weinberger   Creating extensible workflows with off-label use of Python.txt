Title: TALK   Benjy Weinberger   Creating extensible workflows with off-label use of Python
Publication date: 2021-05-29
Playlist: PyCon US 2021
Description: 
	Workflow-oriented systems have many uses, including data processing and analysis, ETL, CI/CD, and more. But creating a programmatic interface to a workflow system is a delicate balancing act: we want the API to be flexible enough to support useful work, but also constrained enough that tasks run cooperatively within the larger system.

We faced this challenge when designing the task API for the Pants build system. We needed to allow custom task code to enjoy the benefits of complex features like caching, concurrency and remote execution, without every task author having to reason about them.

In this talk we'll show how we found the right balance through unconventional use of Python's type annotations, coroutines, and dataclasses. Combining these seemingly disparate features in the context of a workflow engine allows you to build elegant extensibility APIs with just the right amount of flexibility.

Slides: https://docs.google.com/presentation/d/1aWZjk3tZUp37RDmZZxy0j8OjbatzkuWLfuSh84Lzwfk/edit?usp=sharing
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:20,640 --> 00:00:23,680
hi

00:00:20,960 --> 00:00:24,720
everyone thanks for attending my talk my

00:00:23,680 --> 00:00:26,800
name is benji

00:00:24,720 --> 00:00:29,679
i'm one of the core contributors to the

00:00:26,800 --> 00:00:31,920
pants open source build system

00:00:29,679 --> 00:00:34,480
and today i'm going to be talking about

00:00:31,920 --> 00:00:38,320
how we used some cool python features

00:00:34,480 --> 00:00:40,160
in fairly unorthodox ways to create the

00:00:38,320 --> 00:00:43,040
extensible workflow system that is the

00:00:40,160 --> 00:00:44,640
core of the pant system

00:00:43,040 --> 00:00:46,399
and hopefully this may give you some

00:00:44,640 --> 00:00:47,120
ideas about how you could use similar

00:00:46,399 --> 00:00:50,640
techniques

00:00:47,120 --> 00:00:53,840
in your own systems before we get

00:00:50,640 --> 00:00:55,680
started uh just um a little about me

00:00:53,840 --> 00:00:57,600
i have a fair amount of experience as a

00:00:55,680 --> 00:01:00,719
software engineer

00:00:57,600 --> 00:01:02,960
many of that many of those years involve

00:01:00,719 --> 00:01:05,119
working on build systems

00:01:02,960 --> 00:01:06,720
i've had the good fortune to work at a

00:01:05,119 --> 00:01:08,080
bunch of cool companies

00:01:06,720 --> 00:01:09,920
i am as i mentioned one of the

00:01:08,080 --> 00:01:11,040
maintainers of the pants open source

00:01:09,920 --> 00:01:14,000
project

00:01:11,040 --> 00:01:14,400
and i am now the co-founder of toolchain

00:01:14,000 --> 00:01:18,479
which

00:01:14,400 --> 00:01:21,680
is a startup in the build system space

00:01:18,479 --> 00:01:21,680
so let's jump right in

00:01:21,759 --> 00:01:28,400
so first up what is a workflow

00:01:25,119 --> 00:01:30,079
so when i say workflow i'm talking about

00:01:28,400 --> 00:01:33,600
a sequence of tasks

00:01:30,079 --> 00:01:36,720
that processes data to produce

00:01:33,600 --> 00:01:39,119
a desired result and

00:01:36,720 --> 00:01:40,640
that's a fairly mundane definition i

00:01:39,119 --> 00:01:41,680
mean if you think about it that doesn't

00:01:40,640 --> 00:01:44,560
even require

00:01:41,680 --> 00:01:45,280
computers to be involved and in fact

00:01:44,560 --> 00:01:47,600
there is a whole

00:01:45,280 --> 00:01:48,640
category of software devoted to managing

00:01:47,600 --> 00:01:51,439
workflows

00:01:48,640 --> 00:01:52,799
where the tasks are performed by humans

00:01:51,439 --> 00:01:55,200
so for example

00:01:52,799 --> 00:01:55,920
the workflow for onboarding a new

00:01:55,200 --> 00:02:00,159
employee

00:01:55,920 --> 00:02:01,680
the actual tracking the tasks

00:02:00,159 --> 00:02:04,960
could be done by a computer but the

00:02:01,680 --> 00:02:07,600
tasks themselves are done by people

00:02:04,960 --> 00:02:09,280
but for the purpose of this talk we're

00:02:07,600 --> 00:02:11,599
more specifically talking about

00:02:09,280 --> 00:02:13,680
fully automated workflows where the

00:02:11,599 --> 00:02:15,760
tasks themselves are just computer

00:02:13,680 --> 00:02:19,200
processes

00:02:15,760 --> 00:02:21,280
and those workflows show up all over the

00:02:19,200 --> 00:02:22,160
place there are so many examples i've

00:02:21,280 --> 00:02:25,599
just listed

00:02:22,160 --> 00:02:26,000
a handful of them here but to give a

00:02:25,599 --> 00:02:29,040
little

00:02:26,000 --> 00:02:29,360
flavor of what i'm talking about let's

00:02:29,040 --> 00:02:32,560
look

00:02:29,360 --> 00:02:35,120
at a very simplified example of a

00:02:32,560 --> 00:02:37,360
workflow for processing uploaded images

00:02:35,120 --> 00:02:39,040
and again very oversimplified just to

00:02:37,360 --> 00:02:42,480
make a point

00:02:39,040 --> 00:02:44,800
so as you can see we have

00:02:42,480 --> 00:02:47,120
some image data that's being uploaded

00:02:44,800 --> 00:02:50,800
along with its file name

00:02:47,120 --> 00:02:54,000
and then we have some tasks that run

00:02:50,800 --> 00:02:55,120
to operate on that data and the end

00:02:54,000 --> 00:02:58,159
result

00:02:55,120 --> 00:03:01,599
is a database entry containing an

00:02:58,159 --> 00:03:03,840
image that we can then use so again very

00:03:01,599 --> 00:03:04,959
oversimplified but even in this simple

00:03:03,840 --> 00:03:06,560
example

00:03:04,959 --> 00:03:08,480
there are some instructive things to pay

00:03:06,560 --> 00:03:12,400
attention to

00:03:08,480 --> 00:03:14,959
so one thing to notice here is that the

00:03:12,400 --> 00:03:17,280
workflow consists of a set of tasks

00:03:14,959 --> 00:03:18,480
each one is performing some small

00:03:17,280 --> 00:03:23,360
self-contained

00:03:18,480 --> 00:03:27,200
action each task has a set of inputs

00:03:23,360 --> 00:03:29,280
and an output there are dependencies

00:03:27,200 --> 00:03:30,319
between these tasks so a task can

00:03:29,280 --> 00:03:33,840
require as

00:03:30,319 --> 00:03:36,640
input the output of some other task

00:03:33,840 --> 00:03:37,599
and that imposes a dependency

00:03:36,640 --> 00:03:40,879
relationship

00:03:37,599 --> 00:03:44,080
which form edges uh in this

00:03:40,879 --> 00:03:47,120
graph now there's a set of

00:03:44,080 --> 00:03:50,000
initial inputs to the entire workflow

00:03:47,120 --> 00:03:52,400
those are the nodes colored in green in

00:03:50,000 --> 00:03:54,239
this diagram

00:03:52,400 --> 00:03:56,080
and there is a final output to the

00:03:54,239 --> 00:03:59,120
entire workflow which is the node

00:03:56,080 --> 00:04:00,720
colored in blue in this diagram and so

00:03:59,120 --> 00:04:04,400
the workflow is literally a

00:04:00,720 --> 00:04:07,840
flow through a graph of tasks

00:04:04,400 --> 00:04:10,480
and that kind of structure where

00:04:07,840 --> 00:04:11,599
you have a set of tasks and dependencies

00:04:10,480 --> 00:04:14,239
between them

00:04:11,599 --> 00:04:15,120
and a set of initial inputs and a final

00:04:14,239 --> 00:04:16,880
output

00:04:15,120 --> 00:04:18,479
that's pretty much the structure of

00:04:16,880 --> 00:04:20,239
workflow that we

00:04:18,479 --> 00:04:21,519
are going to carry through the rest of

00:04:20,239 --> 00:04:26,080
this talk so

00:04:21,519 --> 00:04:26,080
kind of bookmark that in your mind

00:04:27,199 --> 00:04:30,479
so as i mentioned workflow is defined by

00:04:29,680 --> 00:04:33,840
a task

00:04:30,479 --> 00:04:37,120
graph which is a directed a cyclic graph

00:04:33,840 --> 00:04:38,479
in which the vertices are tasks and the

00:04:37,120 --> 00:04:42,000
edges are these direct

00:04:38,479 --> 00:04:44,320
data dependencies so to form this graph

00:04:42,000 --> 00:04:46,639
we need a set of functions that perform

00:04:44,320 --> 00:04:49,600
relevant tasks for the problem domain so

00:04:46,639 --> 00:04:50,800
image processing in that example and we

00:04:49,600 --> 00:04:53,199
need some knowledge about

00:04:50,800 --> 00:04:54,800
inputs and outputs and how they all map

00:04:53,199 --> 00:04:56,960
to each other

00:04:54,800 --> 00:04:58,160
and it's important to note that at

00:04:56,960 --> 00:05:00,160
runtime

00:04:58,160 --> 00:05:02,479
there may be many task instances

00:05:00,160 --> 00:05:05,120
invoking the same function code

00:05:02,479 --> 00:05:06,960
so for example we probably created that

00:05:05,120 --> 00:05:09,680
image processing workflow

00:05:06,960 --> 00:05:10,720
to process many uploaded images each in

00:05:09,680 --> 00:05:12,479
the same way

00:05:10,720 --> 00:05:14,000
using the same functions but on

00:05:12,479 --> 00:05:16,320
different input

00:05:14,000 --> 00:05:17,600
so a task at runtime is not just a

00:05:16,320 --> 00:05:20,080
function

00:05:17,600 --> 00:05:20,800
but a function in the context of a set

00:05:20,080 --> 00:05:25,840
of initial

00:05:20,800 --> 00:05:25,840
inputs again bookmark that in your mind

00:05:26,720 --> 00:05:31,199
and that brings us to the challenges of

00:05:29,680 --> 00:05:33,840
designing a system

00:05:31,199 --> 00:05:35,440
for running workflows and specifically

00:05:33,840 --> 00:05:37,280
we're going to talk about designing a

00:05:35,440 --> 00:05:39,600
task api

00:05:37,280 --> 00:05:41,360
so any non-trivial workflow system is

00:05:39,600 --> 00:05:42,400
going to need to give programmers a way

00:05:41,360 --> 00:05:45,600
to define

00:05:42,400 --> 00:05:49,039
the tasks that it runs those functions

00:05:45,600 --> 00:05:50,960
and that allows you to extend the system

00:05:49,039 --> 00:05:55,759
and add new logic and plug it

00:05:50,960 --> 00:05:58,160
in and the motivating example of this

00:05:55,759 --> 00:05:59,759
for the rest of this talk is software

00:05:58,160 --> 00:06:02,479
builds

00:05:59,759 --> 00:06:04,479
so as i mentioned pants is this scalable

00:06:02,479 --> 00:06:06,800
software build system

00:06:04,479 --> 00:06:08,400
it has a design emphasis on user

00:06:06,800 --> 00:06:11,520
friendliness

00:06:08,400 --> 00:06:15,120
and it implements a workflow in which

00:06:11,520 --> 00:06:16,880
the workflow engine which actually

00:06:15,120 --> 00:06:18,800
sequences and runs the tasks is

00:06:16,880 --> 00:06:21,199
implemented in rust and that's

00:06:18,800 --> 00:06:23,280
primarily for performance reasons but

00:06:21,199 --> 00:06:24,800
the tasks themselves are implemented in

00:06:23,280 --> 00:06:28,240
python

00:06:24,800 --> 00:06:29,759
because python is you know well-known

00:06:28,240 --> 00:06:31,360
fairly simple language that is a

00:06:29,759 --> 00:06:34,400
pleasure to write

00:06:31,360 --> 00:06:36,639
business logic in so

00:06:34,400 --> 00:06:38,639
we're going to look at how we designed

00:06:36,639 --> 00:06:40,880
the task api for pants

00:06:38,639 --> 00:06:44,160
by leveraging some python features in

00:06:40,880 --> 00:06:47,440
some interesting and unusual ways

00:06:44,160 --> 00:06:48,960
now when i talk about a workflow for

00:06:47,440 --> 00:06:52,720
software builds

00:06:48,960 --> 00:06:55,680
just to clarify the tasks are

00:06:52,720 --> 00:06:57,919
build steps such as running a linter or

00:06:55,680 --> 00:06:59,599
running tests or compiling code or

00:06:57,919 --> 00:07:01,759
building a package

00:06:59,599 --> 00:07:03,520
and so on you can think of many dozens

00:07:01,759 --> 00:07:06,560
of examples like that

00:07:03,520 --> 00:07:06,960
and it's also all the tasks along the

00:07:06,560 --> 00:07:09,919
way

00:07:06,960 --> 00:07:11,280
so there can be actually hundreds of

00:07:09,919 --> 00:07:13,599
these little

00:07:11,280 --> 00:07:16,160
tasks that do various self-contained

00:07:13,599 --> 00:07:19,680
bits of work in the system

00:07:16,160 --> 00:07:20,960
and dependencies in a workflow for

00:07:19,680 --> 00:07:24,160
software builds

00:07:20,960 --> 00:07:26,720
are what you'd expect they they would be

00:07:24,160 --> 00:07:28,160
so for example to run a test we first

00:07:26,720 --> 00:07:29,520
need to compile it if

00:07:28,160 --> 00:07:31,919
if we're dealing with a compiled

00:07:29,520 --> 00:07:34,960
language or you know in a more

00:07:31,919 --> 00:07:36,720
pythonic example to type check a file we

00:07:34,960 --> 00:07:37,280
first need to resolve its dependencies

00:07:36,720 --> 00:07:40,560
and so

00:07:37,280 --> 00:07:44,639
the tasks that do dependency resolution

00:07:40,560 --> 00:07:46,639
have to run first so

00:07:44,639 --> 00:07:48,160
if you think back to the diagram i asked

00:07:46,639 --> 00:07:50,800
you to bookmark in your mind

00:07:48,160 --> 00:07:51,680
there was also the concept of initial

00:07:50,800 --> 00:07:55,360
inputs

00:07:51,680 --> 00:07:58,319
and final outputs and so in this example

00:07:55,360 --> 00:08:00,160
the initial inputs are things like

00:07:58,319 --> 00:08:02,319
source files on disk

00:08:00,160 --> 00:08:03,520
and any configuration to the build

00:08:02,319 --> 00:08:05,840
system

00:08:03,520 --> 00:08:08,000
and the final outputs depend on what the

00:08:05,840 --> 00:08:11,199
user asked for on the command line

00:08:08,000 --> 00:08:13,199
so for example if the user

00:08:11,199 --> 00:08:14,720
says you know show me the results of

00:08:13,199 --> 00:08:17,039
running these tests

00:08:14,720 --> 00:08:18,240
then that creates a different final

00:08:17,039 --> 00:08:22,319
output to

00:08:18,240 --> 00:08:24,840
if the user said uh i want to build a

00:08:22,319 --> 00:08:27,440
you know a wheel for you know this

00:08:24,840 --> 00:08:28,879
package so

00:08:27,440 --> 00:08:30,400
the flow through the graph will be

00:08:28,879 --> 00:08:31,599
different depending on what the user

00:08:30,400 --> 00:08:34,959
asked for

00:08:31,599 --> 00:08:34,959
but the

00:08:35,519 --> 00:08:40,399
context of you know the initial inputs

00:08:38,800 --> 00:08:41,839
are things like you know the source

00:08:40,399 --> 00:08:43,680
files on disk

00:08:41,839 --> 00:08:45,760
in general and specifically the ones

00:08:43,680 --> 00:08:49,120
that user asked to act on

00:08:45,760 --> 00:08:52,240
and so on so

00:08:49,120 --> 00:08:53,920
we have in our minds what a

00:08:52,240 --> 00:08:55,440
workflow for software builds roughly

00:08:53,920 --> 00:08:58,640
looks like we've defined

00:08:55,440 --> 00:09:01,120
what are the vertices and the dependency

00:08:58,640 --> 00:09:03,120
edges in the

00:09:01,120 --> 00:09:04,959
task graph we've talked about what the

00:09:03,120 --> 00:09:06,839
initial inputs are and what the final

00:09:04,959 --> 00:09:10,720
outputs are

00:09:06,839 --> 00:09:13,279
so when we came to design the workflow

00:09:10,720 --> 00:09:14,240
engine for pants we had a set of design

00:09:13,279 --> 00:09:17,760
goals in mind

00:09:14,240 --> 00:09:21,279
and you can see them enumerated here

00:09:17,760 --> 00:09:22,880
now the first four of these

00:09:21,279 --> 00:09:25,040
design goals are really driven by

00:09:22,880 --> 00:09:26,880
performance concerns it's very important

00:09:25,040 --> 00:09:29,600
that as your code base grows

00:09:26,880 --> 00:09:31,120
you keep your build fast and stable and

00:09:29,600 --> 00:09:34,560
there are really

00:09:31,120 --> 00:09:35,200
two ways to do that one is to do less

00:09:34,560 --> 00:09:38,080
work

00:09:35,200 --> 00:09:39,839
and the other is to do more of the work

00:09:38,080 --> 00:09:42,640
at the same time

00:09:39,839 --> 00:09:43,680
so to do less work you need tasks to be

00:09:42,640 --> 00:09:46,880
fine-grained

00:09:43,680 --> 00:09:48,640
so that on changes less of the work gets

00:09:46,880 --> 00:09:50,640
invalidated

00:09:48,640 --> 00:09:52,240
and you want caching so that you don't

00:09:50,640 --> 00:09:54,240
repeat work that's been done before

00:09:52,240 --> 00:09:56,160
either by you or by someone else on your

00:09:54,240 --> 00:09:58,480
team

00:09:56,160 --> 00:10:00,800
so those first two design goals are

00:09:58,480 --> 00:10:03,839
really driven by the need to do

00:10:00,800 --> 00:10:06,000
as little work as possible the second

00:10:03,839 --> 00:10:08,959
two design goals are driven by the need

00:10:06,000 --> 00:10:11,360
to do more work at the same time you

00:10:08,959 --> 00:10:13,760
need concurrency support so you can know

00:10:11,360 --> 00:10:16,160
when two tasks can run in parallel

00:10:13,760 --> 00:10:17,519
because they don't depend on each other

00:10:16,160 --> 00:10:20,560
and you would like to have remote

00:10:17,519 --> 00:10:22,720
execution so that you can actually run

00:10:20,560 --> 00:10:24,000
more than a handful of tasks in parallel

00:10:22,720 --> 00:10:25,760
i mean running

00:10:24,000 --> 00:10:27,519
say eight tasks in parallel on your

00:10:25,760 --> 00:10:30,160
laptop because you have eight cores

00:10:27,519 --> 00:10:33,200
is great but running 100 tasks in

00:10:30,160 --> 00:10:35,920
parallel obviously a lot better

00:10:33,200 --> 00:10:36,240
so those first four goals again driven

00:10:35,920 --> 00:10:39,279
by

00:10:36,240 --> 00:10:42,720
design by performance concerns

00:10:39,279 --> 00:10:44,640
but that last one is really a must have

00:10:42,720 --> 00:10:46,959
extensibility is really important

00:10:44,640 --> 00:10:48,959
because there are so many possible build

00:10:46,959 --> 00:10:50,720
tasks multiple languages multiple

00:10:48,959 --> 00:10:52,480
underlying tools that can be invoked

00:10:50,720 --> 00:10:55,200
multiple frameworks

00:10:52,480 --> 00:10:56,800
all the in-house custom build steps that

00:10:55,200 --> 00:10:58,959
various organizations

00:10:56,800 --> 00:11:00,399
might have we need it to be really

00:10:58,959 --> 00:11:03,360
straightforward to add

00:11:00,399 --> 00:11:05,680
task logic so those first four design

00:11:03,360 --> 00:11:07,680
goals pull us towards complexity

00:11:05,680 --> 00:11:09,519
in the name of performance and then that

00:11:07,680 --> 00:11:11,760
fifth one tugs us back towards

00:11:09,519 --> 00:11:16,160
simplicity because we want it to be

00:11:11,760 --> 00:11:19,600
straightforward to write task code

00:11:16,160 --> 00:11:22,640
so to achieve these design goals

00:11:19,600 --> 00:11:24,880
they imply some important constraints

00:11:22,640 --> 00:11:26,399
so for example tasks cannot interfere

00:11:24,880 --> 00:11:29,279
with each other

00:11:26,399 --> 00:11:31,279
and they can neither cause side effects

00:11:29,279 --> 00:11:34,160
nor rely on side effects

00:11:31,279 --> 00:11:34,959
particularly this relates to the file

00:11:34,160 --> 00:11:37,760
system

00:11:34,959 --> 00:11:39,360
a task can't rely on some previous task

00:11:37,760 --> 00:11:41,200
having written a file to some

00:11:39,360 --> 00:11:42,880
you know well-known magic location

00:11:41,200 --> 00:11:45,600
because maybe those two tasks aren't

00:11:42,880 --> 00:11:48,720
even running on the same machine

00:11:45,600 --> 00:11:51,040
but we still for extensibility want

00:11:48,720 --> 00:11:53,680
tasks to be straightforward to write

00:11:51,040 --> 00:11:54,560
so we needed to find a way to balance

00:11:53,680 --> 00:11:56,320
these

00:11:54,560 --> 00:11:58,800
fairly strict limitations on the one

00:11:56,320 --> 00:12:01,519
hand without sacrificing

00:11:58,800 --> 00:12:02,320
the flexibility and the ease of use of a

00:12:01,519 --> 00:12:05,440
sensible

00:12:02,320 --> 00:12:08,639
task api and this is where

00:12:05,440 --> 00:12:10,959
python comes to the rescue it turned out

00:12:08,639 --> 00:12:14,160
that python has some powerful features

00:12:10,959 --> 00:12:17,200
that we were able to leverage and use in

00:12:14,160 --> 00:12:19,200
unconventional ways to find an

00:12:17,200 --> 00:12:21,200
interesting sweet spot

00:12:19,200 --> 00:12:22,880
of achieving those design goals without

00:12:21,200 --> 00:12:26,320
sacrificing ease of use

00:12:22,880 --> 00:12:28,560
by too much so

00:12:26,320 --> 00:12:30,399
the features that the python features

00:12:28,560 --> 00:12:30,720
that we are specifically referring to

00:12:30,399 --> 00:12:33,920
are

00:12:30,720 --> 00:12:37,040
type annotations async io

00:12:33,920 --> 00:12:38,880
and data classes and so now let's dive

00:12:37,040 --> 00:12:40,720
in and have a bit of a closer look at

00:12:38,880 --> 00:12:44,079
how we put those features to use

00:12:40,720 --> 00:12:47,600
in novel ways and we'll start with

00:12:44,079 --> 00:12:49,200
type annotations so

00:12:47,600 --> 00:12:51,600
we are going to start by introducing

00:12:49,200 --> 00:12:53,200
just a little bit of extra terminology

00:12:51,600 --> 00:12:54,959
so remember again i asked you to

00:12:53,200 --> 00:12:56,480
bookmark this in your minds that we

00:12:54,959 --> 00:12:58,959
distinguished between

00:12:56,480 --> 00:13:00,480
static task functions and their dynamic

00:12:58,959 --> 00:13:04,240
runtime invocations

00:13:00,480 --> 00:13:07,279
in the context of some

00:13:04,240 --> 00:13:09,120
initial inputs so you remember we can

00:13:07,279 --> 00:13:10,160
invoke the same functions many times on

00:13:09,120 --> 00:13:13,360
different inputs

00:13:10,160 --> 00:13:15,839
so just to avoid confusion we refer to

00:13:13,360 --> 00:13:18,000
the static function as a rule

00:13:15,839 --> 00:13:19,680
and the runtime invocation of a rule is

00:13:18,000 --> 00:13:23,519
a task

00:13:19,680 --> 00:13:25,839
so the core definition of a rule

00:13:23,519 --> 00:13:27,760
is a pure function that maps a set of

00:13:25,839 --> 00:13:28,480
statically declared input types to a

00:13:27,760 --> 00:13:31,120
statically

00:13:28,480 --> 00:13:32,720
declared output type and how do we

00:13:31,120 --> 00:13:36,240
statically declare types

00:13:32,720 --> 00:13:38,720
in python we use type annotations

00:13:36,240 --> 00:13:39,680
and so here's an example of a task

00:13:38,720 --> 00:13:43,040
definition

00:13:39,680 --> 00:13:44,720
in the pants task api so you can see

00:13:43,040 --> 00:13:48,560
that this is a fairly normal

00:13:44,720 --> 00:13:50,639
looking python function uh the at rule

00:13:48,560 --> 00:13:51,040
annotation has to do with registration

00:13:50,639 --> 00:13:53,440
and

00:13:51,040 --> 00:13:55,760
we can just ignore it for now the more

00:13:53,440 --> 00:13:59,040
interesting thing to note here

00:13:55,760 --> 00:14:03,040
is that all the inputs to the function

00:13:59,040 --> 00:14:06,560
are type annotated and it declares

00:14:03,040 --> 00:14:08,320
the type of its output and the example

00:14:06,560 --> 00:14:09,440
here is a simplified version of the

00:14:08,320 --> 00:14:12,560
function

00:14:09,440 --> 00:14:13,279
that takes a file containing python

00:14:12,560 --> 00:14:16,720
tests

00:14:13,279 --> 00:14:19,839
and some configuration and runs pi test

00:14:16,720 --> 00:14:22,240
on that test file and yields a test

00:14:19,839 --> 00:14:22,240
result

00:14:22,320 --> 00:14:28,560
so given

00:14:26,000 --> 00:14:29,600
a set of rules we can construct a rule

00:14:28,560 --> 00:14:32,320
graph

00:14:29,600 --> 00:14:32,880
by introspecting those type annotations

00:14:32,320 --> 00:14:35,760
so

00:14:32,880 --> 00:14:36,240
we can say well there's a dependency

00:14:35,760 --> 00:14:40,000
edge

00:14:36,240 --> 00:14:43,519
from b to a if b has a's output

00:14:40,000 --> 00:14:45,839
type as one of its input types

00:14:43,519 --> 00:14:46,639
and this is related to but a little bit

00:14:45,839 --> 00:14:48,320
different

00:14:46,639 --> 00:14:51,279
than the task graph which we talked

00:14:48,320 --> 00:14:53,760
about earlier the task graph is dynamic

00:14:51,279 --> 00:14:56,000
it maps between invocations of functions

00:14:53,760 --> 00:14:57,279
in the context of a specific initial

00:14:56,000 --> 00:14:59,839
input

00:14:57,279 --> 00:15:00,720
the rule graph here is static it maps

00:14:59,839 --> 00:15:04,000
types not

00:15:00,720 --> 00:15:04,000
instances of those types

00:15:04,720 --> 00:15:09,120
but that allows us to statically

00:15:07,440 --> 00:15:11,519
validate the rules and make sure that

00:15:09,120 --> 00:15:13,440
there's no ambiguity

00:15:11,519 --> 00:15:14,800
and that all the rules are reachable and

00:15:13,440 --> 00:15:18,320
that

00:15:14,800 --> 00:15:19,680
all of the queries you might want to run

00:15:18,320 --> 00:15:21,199
through this workflow system are

00:15:19,680 --> 00:15:22,880
satisfiable

00:15:21,199 --> 00:15:24,240
and of course you can just write your

00:15:22,880 --> 00:15:28,399
own rules and plug them

00:15:24,240 --> 00:15:30,000
in and you don't need to wire them in so

00:15:28,399 --> 00:15:31,839
an interesting point here is that the

00:15:30,000 --> 00:15:32,560
names of the rules the names of those

00:15:31,839 --> 00:15:34,480
functions

00:15:32,560 --> 00:15:36,399
are immaterial because rules don't

00:15:34,480 --> 00:15:39,120
reference each other by name

00:15:36,399 --> 00:15:40,959
the workflow system itself knits

00:15:39,120 --> 00:15:43,839
together the call sequences

00:15:40,959 --> 00:15:44,720
by analyzing transitions from here's a

00:15:43,839 --> 00:15:47,839
set of types

00:15:44,720 --> 00:15:48,560
that i have two here is a type that i

00:15:47,839 --> 00:15:50,320
need

00:15:48,560 --> 00:15:52,839
so those names are just used to provide

00:15:50,320 --> 00:15:55,759
helpful error messages

00:15:52,839 --> 00:15:59,600
and in case this feels familiar

00:15:55,759 --> 00:16:02,959
this is basically dependency injection

00:15:59,600 --> 00:16:05,759
so it's similar in some ways to

00:16:02,959 --> 00:16:06,839
say you may be familiar with a fixture

00:16:05,759 --> 00:16:09,680
injection in pi

00:16:06,839 --> 00:16:11,199
test the difference is that pi test does

00:16:09,680 --> 00:16:15,600
fixture injection by

00:16:11,199 --> 00:16:18,480
name while here we do it by types

00:16:15,600 --> 00:16:20,000
and so this knitting together of all of

00:16:18,480 --> 00:16:20,800
these rules without having to make

00:16:20,000 --> 00:16:24,240
explicit

00:16:20,800 --> 00:16:26,240
calls from one to the other is

00:16:24,240 --> 00:16:28,880
enabled by unconventional use of

00:16:26,240 --> 00:16:30,079
standard python type annotations

00:16:28,880 --> 00:16:32,240
and you may ask well what's

00:16:30,079 --> 00:16:34,880
unconventional about it

00:16:32,240 --> 00:16:36,560
if you think about the purpose of type

00:16:34,880 --> 00:16:38,800
annotations

00:16:36,560 --> 00:16:39,600
they exist primarily to make code more

00:16:38,800 --> 00:16:41,680
readable

00:16:39,600 --> 00:16:43,759
and to support like my pi to support

00:16:41,680 --> 00:16:45,920
static type checking which helps enforce

00:16:43,759 --> 00:16:49,759
the correctness of your code

00:16:45,920 --> 00:16:54,880
so they are metadata about your code

00:16:49,759 --> 00:16:56,880
that helps with the craft of programming

00:16:54,880 --> 00:16:59,120
but we're using the type annotations as

00:16:56,880 --> 00:17:01,199
an actual runtime language feature

00:16:59,120 --> 00:17:02,880
that for purposes that have nothing to

00:17:01,199 --> 00:17:06,640
do with code hygiene or

00:17:02,880 --> 00:17:09,760
code correctness so

00:17:06,640 --> 00:17:12,400
we've seen how of you know those

00:17:09,760 --> 00:17:14,400
five design goals that we had type

00:17:12,400 --> 00:17:17,039
annotations when used in this

00:17:14,400 --> 00:17:18,799
unusual way uh provide us with

00:17:17,039 --> 00:17:21,039
fine-grained tasks

00:17:18,799 --> 00:17:23,439
and they provide us with extensibility

00:17:21,039 --> 00:17:26,319
you can just write these functions

00:17:23,439 --> 00:17:26,880
provide type annotations add that at

00:17:26,319 --> 00:17:30,799
rule

00:17:26,880 --> 00:17:32,400
uh annotation and you're good to go

00:17:30,799 --> 00:17:34,559
the system will plug it in in the right

00:17:32,400 --> 00:17:37,200
place for you

00:17:34,559 --> 00:17:38,160
so having talked about type annotations

00:17:37,200 --> 00:17:43,120
let's move on

00:17:38,160 --> 00:17:45,600
to async io a major python 3 feature

00:17:43,120 --> 00:17:47,039
so here i need to admit that i cheated a

00:17:45,600 --> 00:17:49,360
little

00:17:47,039 --> 00:17:51,280
for didactic purposes on my previous

00:17:49,360 --> 00:17:53,760
definition of a rule

00:17:51,280 --> 00:17:54,640
uh it's actually not a pure function it

00:17:53,760 --> 00:17:58,160
is a pure

00:17:54,640 --> 00:17:59,840
co-routine so same definition as before

00:17:58,160 --> 00:18:02,480
but we now emphasize

00:17:59,840 --> 00:18:03,039
that the rule is a co-routine and this

00:18:02,480 --> 00:18:06,080
means

00:18:03,039 --> 00:18:09,919
that it can yield back to

00:18:06,080 --> 00:18:13,520
the workflow engine in mid-execution

00:18:09,919 --> 00:18:14,240
so the definition is identical to the

00:18:13,520 --> 00:18:17,120
one before

00:18:14,240 --> 00:18:17,919
except you see the use of the async

00:18:17,120 --> 00:18:21,360
keyword

00:18:17,919 --> 00:18:24,400
and what that enables is

00:18:21,360 --> 00:18:27,440
that as a rule runs if it

00:18:24,400 --> 00:18:29,440
realizes at runtime based on inputs that

00:18:27,440 --> 00:18:31,679
are only available at runtime

00:18:29,440 --> 00:18:33,520
that it needs some extra input it can

00:18:31,679 --> 00:18:34,960
yield back to the workflow engine so you

00:18:33,520 --> 00:18:39,360
can see this

00:18:34,960 --> 00:18:42,880
standard await async i o syntax

00:18:39,360 --> 00:18:46,240
one important thing to note here is

00:18:42,880 --> 00:18:49,280
that the thing that you await on is this

00:18:46,240 --> 00:18:50,640
uh object called a get which is a type

00:18:49,280 --> 00:18:53,919
in the system

00:18:50,640 --> 00:18:56,720
um and

00:18:53,919 --> 00:18:59,360
you can't await arbitrary python

00:18:56,720 --> 00:19:02,480
awaitables and the reason for that

00:18:59,360 --> 00:19:06,400
is that the event loop

00:19:02,480 --> 00:19:09,520
that is implied by you know the async io

00:19:06,400 --> 00:19:10,160
paradigm is run by that rust engine that

00:19:09,520 --> 00:19:13,200
i mentioned

00:19:10,160 --> 00:19:14,640
and not by the async i o run and so if

00:19:13,200 --> 00:19:16,320
you were wondering well what is off

00:19:14,640 --> 00:19:18,880
label about this

00:19:16,320 --> 00:19:20,320
uh the answer is the we're using the

00:19:18,880 --> 00:19:23,360
async await

00:19:20,320 --> 00:19:26,160
syntax but we're not using the standard

00:19:23,360 --> 00:19:27,760
async i o event loop we're actually

00:19:26,160 --> 00:19:30,240
running an event loop from outside of

00:19:27,760 --> 00:19:31,840
python entirely

00:19:30,240 --> 00:19:33,280
but because python is so good about

00:19:31,840 --> 00:19:37,840
letting you

00:19:33,280 --> 00:19:38,880
introspect it we can use the async await

00:19:37,840 --> 00:19:41,200
as

00:19:38,880 --> 00:19:42,000
interaction points between rust and

00:19:41,200 --> 00:19:45,200
python

00:19:42,000 --> 00:19:49,840
in a way that is

00:19:45,200 --> 00:19:53,200
transparent to the author of these um

00:19:49,840 --> 00:19:56,480
rules you just write fairly

00:19:53,200 --> 00:19:58,720
idiomatic async i o code

00:19:56,480 --> 00:19:58,720
now

00:20:01,039 --> 00:20:04,480
code routines are very powerful because

00:20:02,960 --> 00:20:06,640
as i mentioned

00:20:04,480 --> 00:20:07,760
the rule application the path through

00:20:06,640 --> 00:20:10,640
the graph

00:20:07,760 --> 00:20:12,320
is determined dynamically on the fly

00:20:10,640 --> 00:20:14,640
rather than

00:20:12,320 --> 00:20:16,159
statically that means you can use

00:20:14,640 --> 00:20:19,200
runtime information

00:20:16,159 --> 00:20:20,880
to inform how the build will unfold but

00:20:19,200 --> 00:20:26,000
you still get that static

00:20:20,880 --> 00:20:29,200
checking being able to yield back to

00:20:26,000 --> 00:20:31,120
the engine sort of

00:20:29,200 --> 00:20:32,960
at runtime means that you can apply a

00:20:31,120 --> 00:20:34,799
natural control flow so you can do

00:20:32,960 --> 00:20:37,520
things like looping and branching

00:20:34,799 --> 00:20:39,919
but still have the static validation but

00:20:37,520 --> 00:20:41,440
even more importantly

00:20:39,919 --> 00:20:43,520
co routines make it easy for you to

00:20:41,440 --> 00:20:45,520
express concurrency

00:20:43,520 --> 00:20:48,000
so if you look at this little code

00:20:45,520 --> 00:20:50,400
snippet now we're not awaiting a get

00:20:48,000 --> 00:20:52,000
we're awaiting an entire iterable of

00:20:50,400 --> 00:20:53,280
gets wrapped in a thing called a

00:20:52,000 --> 00:20:54,960
multi-get

00:20:53,280 --> 00:20:56,880
and the engine will execute these

00:20:54,960 --> 00:21:00,159
concurrently

00:20:56,880 --> 00:21:03,600
and because

00:21:00,159 --> 00:21:05,919
the engine is implemented in rust and so

00:21:03,600 --> 00:21:06,720
outside the global interpreter lock

00:21:05,919 --> 00:21:08,799
these will

00:21:06,720 --> 00:21:09,919
frequently execute in parallel like

00:21:08,799 --> 00:21:13,600
these can

00:21:09,919 --> 00:21:14,799
execute um with um

00:21:13,600 --> 00:21:17,440
you know particularly if they involve

00:21:14,799 --> 00:21:20,080
things like i o and process execution

00:21:17,440 --> 00:21:22,559
then they will actually execute in

00:21:20,080 --> 00:21:22,559
parallel

00:21:22,960 --> 00:21:26,640
the other great thing about core

00:21:24,159 --> 00:21:29,600
routines is they help us

00:21:26,640 --> 00:21:31,919
avoid side effects so for remote

00:21:29,600 --> 00:21:33,760
execution for example to work

00:21:31,919 --> 00:21:35,440
as we mentioned rules cannot have side

00:21:33,760 --> 00:21:36,080
effects and they cannot rely on side

00:21:35,440 --> 00:21:38,559
effects

00:21:36,080 --> 00:21:39,520
so it's important that you don't make

00:21:38,559 --> 00:21:41,679
system calls

00:21:39,520 --> 00:21:43,679
you ask the engine to make them for you

00:21:41,679 --> 00:21:46,320
so that they can do it in a safe

00:21:43,679 --> 00:21:48,080
manner so for example you can see an

00:21:46,320 --> 00:21:51,360
example here of

00:21:48,080 --> 00:21:52,400
instead of just directly accessing the

00:21:51,360 --> 00:21:55,440
file system

00:21:52,400 --> 00:21:56,960
you await for an object called a

00:21:55,440 --> 00:21:58,640
snapshot that represents a little

00:21:56,960 --> 00:21:59,120
portion of the file system and the

00:21:58,640 --> 00:22:01,760
engine

00:21:59,120 --> 00:22:02,720
presents that to you or instead of

00:22:01,760 --> 00:22:05,600
running

00:22:02,720 --> 00:22:06,559
processes directly using the sub-process

00:22:05,600 --> 00:22:10,799
module

00:22:06,559 --> 00:22:12,480
you again yield back to

00:22:10,799 --> 00:22:14,480
the engine and say please run this

00:22:12,480 --> 00:22:16,320
process for me and it will return a

00:22:14,480 --> 00:22:19,600
process result

00:22:16,320 --> 00:22:21,440
so you're probably realizing that there

00:22:19,600 --> 00:22:24,480
have to be some side effects because

00:22:21,440 --> 00:22:26,000
otherwise the user gets nothing so the

00:22:24,480 --> 00:22:28,240
outermost rule that computes

00:22:26,000 --> 00:22:30,080
the final result is allowed to have

00:22:28,240 --> 00:22:31,760
certain side effects so it can emit to

00:22:30,080 --> 00:22:33,360
the console or it can write results to

00:22:31,760 --> 00:22:35,120
local disk it can actually

00:22:33,360 --> 00:22:37,200
do the side effecting that is the thing

00:22:35,120 --> 00:22:40,240
the user asked for in the first place

00:22:37,200 --> 00:22:42,240
but extra special care is taken that

00:22:40,240 --> 00:22:43,679
those side effects are always replayed

00:22:42,240 --> 00:22:44,480
even if everything leading up to them

00:22:43,679 --> 00:22:48,080
say was

00:22:44,480 --> 00:22:51,280
satisfied from cash or run remotely

00:22:48,080 --> 00:22:53,520
so we've seen that this

00:22:51,280 --> 00:22:54,400
unconventional use of co routines

00:22:53,520 --> 00:22:56,720
provides

00:22:54,400 --> 00:22:57,840
natural control points for concurrency

00:22:56,720 --> 00:23:01,200
and for

00:22:57,840 --> 00:23:04,720
remote execution which leads us

00:23:01,200 --> 00:23:07,200
on to data classes

00:23:04,720 --> 00:23:08,559
so this is all about cache ability for

00:23:07,200 --> 00:23:11,039
caching to work

00:23:08,559 --> 00:23:12,080
rule input types have to be immutable

00:23:11,039 --> 00:23:14,000
and hashable

00:23:12,080 --> 00:23:15,760
and i think it should be fairly obvious

00:23:14,000 --> 00:23:17,200
why that is the case

00:23:15,760 --> 00:23:18,799
you have to be able to compute a key and

00:23:17,200 --> 00:23:20,320
you have to know that that key always

00:23:18,799 --> 00:23:23,120
refers to

00:23:20,320 --> 00:23:24,480
equal objects and python has an out of

00:23:23,120 --> 00:23:26,640
the box solution for this which is

00:23:24,480 --> 00:23:29,840
frozen data classes

00:23:26,640 --> 00:23:32,080
so here's an example of

00:23:29,840 --> 00:23:34,159
a frozen data class that represents the

00:23:32,080 --> 00:23:35,919
configuration that you need for

00:23:34,159 --> 00:23:37,840
running pi test at a certain version

00:23:35,919 --> 00:23:40,400
with a certain set of plugins

00:23:37,840 --> 00:23:41,840
it's really trivial to make this type

00:23:40,400 --> 00:23:43,919
cacheable and so

00:23:41,840 --> 00:23:45,600
frozen data classes are ubiquitous

00:23:43,919 --> 00:23:47,520
throughout the api

00:23:45,600 --> 00:23:48,880
and all of those input and output types

00:23:47,520 --> 00:23:51,679
that you annotated

00:23:48,880 --> 00:23:53,200
earlier those just have to be frozen

00:23:51,679 --> 00:23:55,679
data classes

00:23:53,200 --> 00:23:57,279
and simply by requiring that we get

00:23:55,679 --> 00:24:00,799
well-defined fingerprints

00:23:57,279 --> 00:24:04,480
for all these runtime tasks which allows

00:24:00,799 --> 00:24:05,440
caching to work and what's off label

00:24:04,480 --> 00:24:08,320
about this

00:24:05,440 --> 00:24:09,200
well to be honest nothing data classes

00:24:08,320 --> 00:24:11,520
are just very cool

00:24:09,200 --> 00:24:13,039
and an absolutely wonderful way to avoid

00:24:11,520 --> 00:24:16,240
boilerplate and bugs

00:24:13,039 --> 00:24:16,880
and i really wanted to show how we use

00:24:16,240 --> 00:24:21,360
them

00:24:16,880 --> 00:24:24,159
to great effect so

00:24:21,360 --> 00:24:25,360
as we've shown using data classes and

00:24:24,159 --> 00:24:28,000
async io

00:24:25,360 --> 00:24:28,559
and type annotations together in ways

00:24:28,000 --> 00:24:30,400
perhaps

00:24:28,559 --> 00:24:32,799
beyond those they were directly designed

00:24:30,400 --> 00:24:34,480
for gives us a powerful

00:24:32,799 --> 00:24:36,320
framework and a powerful api for

00:24:34,480 --> 00:24:38,799
building extensible

00:24:36,320 --> 00:24:41,360
workflows we've achieved all of our

00:24:38,799 --> 00:24:44,640
design goals here

00:24:41,360 --> 00:24:48,240
so i think this is a testament

00:24:44,640 --> 00:24:49,440
to the design of python 3. python i

00:24:48,240 --> 00:24:52,400
think

00:24:49,440 --> 00:24:54,640
python 3 particularly recent versions

00:24:52,400 --> 00:24:57,200
really occupies a sweet spot on the

00:24:54,640 --> 00:24:58,240
simplicity versus power trade-off curve

00:24:57,200 --> 00:25:02,320
and we were able

00:24:58,240 --> 00:25:04,240
to leverage that to hopefully occupy a

00:25:02,320 --> 00:25:04,960
similar sweet spot on the simplicity

00:25:04,240 --> 00:25:08,400
versus

00:25:04,960 --> 00:25:10,080
power curve in a system

00:25:08,400 --> 00:25:11,919
where you know you write fairly

00:25:10,080 --> 00:25:15,360
idiomatic uh

00:25:11,919 --> 00:25:17,120
async i o python code and complicated

00:25:15,360 --> 00:25:18,559
things like caching and concurrency and

00:25:17,120 --> 00:25:21,760
remote execution

00:25:18,559 --> 00:25:23,120
just fall out of the system

00:25:21,760 --> 00:25:25,440
and you don't have to do anything

00:25:23,120 --> 00:25:26,880
special as a rule author in order to get

00:25:25,440 --> 00:25:28,159
them

00:25:26,880 --> 00:25:30,559
so i want to thank you so much for

00:25:28,159 --> 00:25:34,320
listening i'm happy to take

00:25:30,559 --> 00:25:36,640
any questions and um

00:25:34,320 --> 00:25:37,679
you can find us in startup row you can

00:25:36,640 --> 00:25:40,240
find my company there

00:25:37,679 --> 00:25:42,000
if you would like to virtually swing by

00:25:40,240 --> 00:25:44,720
and of course you can find out more

00:25:42,000 --> 00:25:46,080
about the work that i've talked about at

00:25:44,720 --> 00:25:57,840
this url

00:25:46,080 --> 00:25:57,840
so thanks again

00:26:59,279 --> 00:27:01,360

YouTube URL: https://www.youtube.com/watch?v=HA5gzP4Ncao


