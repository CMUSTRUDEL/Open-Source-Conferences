Title: TALK   Maggie Moss   Gradual Typing in Practice
Publication date: 2021-05-30
Playlist: PyCon US 2021
Description: 
	Type coverage in Python improves readability, finds bugs and supports tooling to improve security and improve developer efficiency. However, driving for type adoption on a rapidly changing codebase under active development can pose several challenges. This presentation will focus on how you can get meaningful results from Pyre as you move from just a few annotations to a fully typed codebase, and the guarantees we can make along the way. Then, I will discuss the approaches and tools we use to increase type coverage and “strictify” the Instagram codebase, one of the largest active Python projects.

Slides: https://docs.google.com/presentation/d/1CbADIfFJhXIJxwEiQp8VOfJJBRtroQ2M9P9lVpAX0KM/edit?usp=sharing
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:14,639 --> 00:00:20,000
welcome to gradual typing and practice

00:00:18,160 --> 00:00:21,840
my name is maggie and i'm a software

00:00:20,000 --> 00:00:23,760
engineer at facebook and for the past

00:00:21,840 --> 00:00:25,760
two years i've been working on pyre

00:00:23,760 --> 00:00:27,680
which is a python type checker

00:00:25,760 --> 00:00:29,920
prior to that i was working on the hack

00:00:27,680 --> 00:00:32,320
team if you're not familiar with hacc

00:00:29,920 --> 00:00:34,719
it's facebook's version of typed php

00:00:32,320 --> 00:00:36,239
so essentially for the last three years

00:00:34,719 --> 00:00:38,160
i've been working on adding types to

00:00:36,239 --> 00:00:39,600
dynamic programming languages

00:00:38,160 --> 00:00:41,280
and building tools to help make that

00:00:39,600 --> 00:00:43,360
process smoother

00:00:41,280 --> 00:00:45,039
and when i tell people that i work on

00:00:43,360 --> 00:00:45,920
adding types to dynamic programming

00:00:45,039 --> 00:00:49,039
languages

00:00:45,920 --> 00:00:51,840
i get a very simple question in response

00:00:49,039 --> 00:00:53,199
why would you do that and it's a fair

00:00:51,840 --> 00:00:54,640
question

00:00:53,199 --> 00:00:56,239
i'm assuming that because you're here at

00:00:54,640 --> 00:00:57,920
pycon you know that there are many

00:00:56,239 --> 00:01:00,239
benefits to building with a flexible

00:00:57,920 --> 00:01:01,920
dynamic programming language like python

00:01:00,239 --> 00:01:03,840
but the reality is is that it does

00:01:01,920 --> 00:01:05,439
create room for bugs and errors that

00:01:03,840 --> 00:01:07,680
aren't possible in a statically typed

00:01:05,439 --> 00:01:09,439
language like c or java

00:01:07,680 --> 00:01:11,360
so no matter how many unit tests you

00:01:09,439 --> 00:01:12,000
write you're probably still finding type

00:01:11,360 --> 00:01:14,720
errors in your

00:01:12,000 --> 00:01:16,720
logs and as your project grows these

00:01:14,720 --> 00:01:18,400
issues can become amplified

00:01:16,720 --> 00:01:20,240
and it can be a frustrating spot to be

00:01:18,400 --> 00:01:21,840
in you want the type safety of a static

00:01:20,240 --> 00:01:24,560
language without giving up all of the

00:01:21,840 --> 00:01:26,400
benefits from a language like python

00:01:24,560 --> 00:01:28,159
and one solution gets suggested at this

00:01:26,400 --> 00:01:29,759
point is well why don't we just rewrite

00:01:28,159 --> 00:01:31,200
our project in an entirely different

00:01:29,759 --> 00:01:32,799
language and that will solve all of our

00:01:31,200 --> 00:01:34,320
problems

00:01:32,799 --> 00:01:36,560
and this is often an unrealistic

00:01:34,320 --> 00:01:38,720
solution for many reasons

00:01:36,560 --> 00:01:40,479
rewriting an entire code base requires a

00:01:38,720 --> 00:01:42,479
massive investment

00:01:40,479 --> 00:01:44,240
is there any way to get this without

00:01:42,479 --> 00:01:46,079
changing languages and rewriting an

00:01:44,240 --> 00:01:48,640
entire code base

00:01:46,079 --> 00:01:50,320
so the answer is yes and facebook has

00:01:48,640 --> 00:01:51,840
done this in the past and we converted

00:01:50,320 --> 00:01:53,520
code from php to hack

00:01:51,840 --> 00:01:55,119
and then we've done it again by using a

00:01:53,520 --> 00:01:58,479
type checker for python code

00:01:55,119 --> 00:02:00,159
both at facebook and instagram and

00:01:58,479 --> 00:02:01,920
having a typed code base has increased

00:02:00,159 --> 00:02:03,119
our productivity we can make changes

00:02:01,920 --> 00:02:04,799
with more confidence

00:02:03,119 --> 00:02:07,119
write more focused unit tests and have

00:02:04,799 --> 00:02:08,720
fewer bugs reach production

00:02:07,119 --> 00:02:10,479
and we're not the only company that's

00:02:08,720 --> 00:02:11,680
done this stripe has built a type

00:02:10,479 --> 00:02:13,599
checker for ruby

00:02:11,680 --> 00:02:15,120
and if you've used typescript and flow

00:02:13,599 --> 00:02:16,879
they're designed to tackle this same

00:02:15,120 --> 00:02:18,720
problem in javascript

00:02:16,879 --> 00:02:20,720
and the benefits of gradual types aren't

00:02:18,720 --> 00:02:22,720
limited to large projects with millions

00:02:20,720 --> 00:02:23,760
of lines of code and large development

00:02:22,720 --> 00:02:25,520
teams

00:02:23,760 --> 00:02:28,319
small projects can benefit from using a

00:02:25,520 --> 00:02:28,319
type checker too

00:02:29,040 --> 00:02:33,360
so what we'll first go over today is

00:02:31,200 --> 00:02:37,840
what is gradual typing and what does it

00:02:33,360 --> 00:02:37,840
look like in python specifically

00:02:38,000 --> 00:02:41,280
we'll talk about why you should add

00:02:39,760 --> 00:02:44,480
types to your python code and what

00:02:41,280 --> 00:02:44,480
benefits you'll get out of it

00:02:44,560 --> 00:02:48,560
what tools and strategies did we use to

00:02:46,800 --> 00:02:49,280
get engineers to invest time in adding

00:02:48,560 --> 00:02:50,959
types

00:02:49,280 --> 00:02:53,280
so what were the steps we actually took

00:02:50,959 --> 00:02:55,599
to get from almost no types to a fully

00:02:53,280 --> 00:02:57,200
typed python code base

00:02:55,599 --> 00:02:58,480
and finally we'll go over some of the

00:02:57,200 --> 00:03:00,159
trickier code patterns that we've

00:02:58,480 --> 00:03:04,159
encountered and what new features are

00:03:00,159 --> 00:03:05,440
coming to the python type system before

00:03:04,159 --> 00:03:07,040
we get started with discussing

00:03:05,440 --> 00:03:09,040
strategies for typing your python

00:03:07,040 --> 00:03:10,000
project we first need to establish what

00:03:09,040 --> 00:03:12,400
gradual typing

00:03:10,000 --> 00:03:13,440
is so let's go back to basics for a

00:03:12,400 --> 00:03:15,440
second

00:03:13,440 --> 00:03:17,280
in general we can think of a type as

00:03:15,440 --> 00:03:18,800
something that describes a set of values

00:03:17,280 --> 00:03:19,360
that have a bunch of operations in

00:03:18,800 --> 00:03:21,599
common

00:03:19,360 --> 00:03:23,280
for example the type int describes a set

00:03:21,599 --> 00:03:25,360
of numbers that support operations like

00:03:23,280 --> 00:03:27,519
addition and subtraction

00:03:25,360 --> 00:03:29,440
and a type error happens when we try to

00:03:27,519 --> 00:03:30,400
apply an operation to a value of the

00:03:29,440 --> 00:03:31,599
wrong type

00:03:30,400 --> 00:03:35,519
like if we tried to subtract a

00:03:31,599 --> 00:03:35,519
dictionary from an int for example

00:03:35,920 --> 00:03:39,040
if you've written in languages like java

00:03:37,920 --> 00:03:41,200
c or rust

00:03:39,040 --> 00:03:42,720
you're familiar with static types in

00:03:41,200 --> 00:03:44,640
statically typed languages

00:03:42,720 --> 00:03:46,480
some or even all type errors are caught

00:03:44,640 --> 00:03:47,519
by a type checker prior to running the

00:03:46,480 --> 00:03:49,200
program

00:03:47,519 --> 00:03:51,120
and usually this type checker is part of

00:03:49,200 --> 00:03:52,480
the compiler and it's automatically run

00:03:51,120 --> 00:03:54,959
during compilation

00:03:52,480 --> 00:03:56,319
so in this example here our variable x

00:03:54,959 --> 00:03:58,879
is defined as having a type

00:03:56,319 --> 00:04:01,360
integer and we'd get an error if we

00:03:58,879 --> 00:04:03,120
tried to reassign it to be a string

00:04:01,360 --> 00:04:05,439
so not only would our variables need

00:04:03,120 --> 00:04:08,560
annotations but so do parameters return

00:04:05,439 --> 00:04:10,959
types and attributes

00:04:08,560 --> 00:04:12,640
in python we're familiar with dynamic

00:04:10,959 --> 00:04:14,000
typing where we don't have to add

00:04:12,640 --> 00:04:16,959
annotations to every single

00:04:14,000 --> 00:04:17,280
variable in this example we can reassign

00:04:16,959 --> 00:04:19,919
foo

00:04:17,280 --> 00:04:21,680
to be an integer or even a dictionary

00:04:19,919 --> 00:04:23,520
and it just works

00:04:21,680 --> 00:04:25,919
so the values have types but the

00:04:23,520 --> 00:04:28,080
variables and the functions do not

00:04:25,919 --> 00:04:29,600
in in a dynamically typed language type

00:04:28,080 --> 00:04:30,400
checking is performed during program

00:04:29,600 --> 00:04:32,160
execution

00:04:30,400 --> 00:04:34,560
immediately before the application of

00:04:32,160 --> 00:04:36,400
each operation and this makes it easy to

00:04:34,560 --> 00:04:38,880
deal with situations where the type of a

00:04:36,400 --> 00:04:40,479
value depends on runtime information

00:04:38,880 --> 00:04:43,120
but the downside is that sometimes we

00:04:40,479 --> 00:04:46,320
get type errors that look like this

00:04:43,120 --> 00:04:47,919
or maybe like this and i'm sure you've

00:04:46,320 --> 00:04:50,160
had an experience where you've

00:04:47,919 --> 00:04:52,080
written some code added a bunch of unit

00:04:50,160 --> 00:04:53,680
tests confidently shipped it

00:04:52,080 --> 00:04:57,440
only to find error messages that look

00:04:53,680 --> 00:04:59,840
like this in your logs

00:04:57,440 --> 00:05:01,680
so what is a gradual type system it's a

00:04:59,840 --> 00:05:02,479
type system where not every expression

00:05:01,680 --> 00:05:04,160
is typed

00:05:02,479 --> 00:05:06,080
it allows parts of a program to be

00:05:04,160 --> 00:05:07,440
dynamically typed and other parts to be

00:05:06,080 --> 00:05:08,960
statically typed

00:05:07,440 --> 00:05:10,880
you control which part is which by

00:05:08,960 --> 00:05:13,680
either leaving out type annotations or

00:05:10,880 --> 00:05:13,680
by adding them in

00:05:14,000 --> 00:05:18,400
so what does this look like in python

00:05:16,560 --> 00:05:18,800
untyped expressions are assumed to be

00:05:18,400 --> 00:05:20,560
type

00:05:18,800 --> 00:05:22,000
any which is defined as having every

00:05:20,560 --> 00:05:24,800
attribute and being a sub

00:05:22,000 --> 00:05:26,400
and super type of every other known type

00:05:24,800 --> 00:05:27,120
and the key thing to remember with types

00:05:26,400 --> 00:05:28,960
in python

00:05:27,120 --> 00:05:31,199
is that only annotated functions are

00:05:28,960 --> 00:05:34,320
type checked so in this example

00:05:31,199 --> 00:05:36,080
foo has a return annotation of type int

00:05:34,320 --> 00:05:38,000
so the body of this function will be

00:05:36,080 --> 00:05:40,639
type checked in contrast

00:05:38,000 --> 00:05:41,120
bar has no return annotation so the body

00:05:40,639 --> 00:05:44,080
of it

00:05:41,120 --> 00:05:46,080
won't be type checked at all unannotated

00:05:44,080 --> 00:05:48,720
functions are assumed to take any

00:05:46,080 --> 00:05:50,479
and return any what this means is that

00:05:48,720 --> 00:05:52,320
you can add static types where you can

00:05:50,479 --> 00:05:54,320
and where you need type checking and as

00:05:52,320 --> 00:05:56,000
you add more annotations to your code

00:05:54,320 --> 00:05:58,240
in other words you increase type

00:05:56,000 --> 00:06:00,479
adoption python type checkers will

00:05:58,240 --> 00:06:02,160
surface more and more type errors

00:06:00,479 --> 00:06:03,759
this means you can slowly add types to

00:06:02,160 --> 00:06:06,479
your code but still get meaningful

00:06:03,759 --> 00:06:08,319
results as you go

00:06:06,479 --> 00:06:09,919
there are several different python type

00:06:08,319 --> 00:06:10,960
checkers that you can choose to use in

00:06:09,919 --> 00:06:13,360
your project

00:06:10,960 --> 00:06:14,960
this is just a few of them and alt type

00:06:13,360 --> 00:06:15,919
checkers implement the same typing

00:06:14,960 --> 00:06:19,039
specific peps

00:06:15,919 --> 00:06:20,720
like pep 484 for example the general

00:06:19,039 --> 00:06:22,080
workflow is that you write some code and

00:06:20,720 --> 00:06:23,680
then you run your type checker

00:06:22,080 --> 00:06:26,080
and this can be done via a command line

00:06:23,680 --> 00:06:28,400
tool but often python type checkers will

00:06:26,080 --> 00:06:29,840
also surface errors in your ide

00:06:28,400 --> 00:06:31,680
and you'll want to set your type checker

00:06:29,840 --> 00:06:32,880
up in your ci job so that it's run on

00:06:31,680 --> 00:06:34,639
every pull request

00:06:32,880 --> 00:06:35,919
this will help keep your project in a

00:06:34,639 --> 00:06:37,360
clean type checking state

00:06:35,919 --> 00:06:39,280
and if it's in a clean type checking

00:06:37,360 --> 00:06:42,479
state the type errors that are surfaced

00:06:39,280 --> 00:06:42,479
are going to be high signal

00:06:43,520 --> 00:06:47,280
i happen to work on pyre so parts of

00:06:45,919 --> 00:06:48,720
this talk will mention some pirate

00:06:47,280 --> 00:06:50,400
specific features or tools

00:06:48,720 --> 00:06:52,240
but most type checkers have implemented

00:06:50,400 --> 00:06:53,759
something similar so the advice and

00:06:52,240 --> 00:06:55,599
approaches that we'll talk about can be

00:06:53,759 --> 00:06:58,960
implemented no matter what python type

00:06:55,599 --> 00:07:01,120
checker you happen to be using

00:06:58,960 --> 00:07:02,880
so why should you take time out of your

00:07:01,120 --> 00:07:04,479
busy development schedule to add types

00:07:02,880 --> 00:07:06,160
to your code base

00:07:04,479 --> 00:07:07,759
to illustrate this let's pretend that

00:07:06,160 --> 00:07:08,479
we're starting our first day on a new

00:07:07,759 --> 00:07:11,120
project

00:07:08,479 --> 00:07:12,960
we're building a small online store our

00:07:11,120 --> 00:07:16,479
task is to fix some bugs and some code

00:07:12,960 --> 00:07:18,080
that displays products on the home page

00:07:16,479 --> 00:07:19,680
and as we're digging around in the code

00:07:18,080 --> 00:07:22,319
we need to answer the question

00:07:19,680 --> 00:07:23,680
does this function return none and of

00:07:22,319 --> 00:07:25,440
course you could say well why don't we

00:07:23,680 --> 00:07:28,000
just check if it returns none when we

00:07:25,440 --> 00:07:29,759
call it and then we can handle this here

00:07:28,000 --> 00:07:31,280
and this would work but it does have the

00:07:29,759 --> 00:07:32,319
potential to get a little bit messy

00:07:31,280 --> 00:07:33,840
after a while

00:07:32,319 --> 00:07:36,400
so let's go back to our function

00:07:33,840 --> 00:07:36,400
definition

00:07:36,560 --> 00:07:39,919
there are three return statements in our

00:07:38,160 --> 00:07:41,599
function and we decided to use the

00:07:39,919 --> 00:07:44,319
process of elimination to try and

00:07:41,599 --> 00:07:46,000
answer this question so we check out the

00:07:44,319 --> 00:07:47,919
function definition for get latest

00:07:46,000 --> 00:07:49,120
products and we're pretty confident that

00:07:47,919 --> 00:07:51,440
that one doesn't return

00:07:49,120 --> 00:07:53,360
nut but when we go to check out the

00:07:51,440 --> 00:07:56,240
function definitions for get holiday

00:07:53,360 --> 00:07:58,000
products and get similar products

00:07:56,240 --> 00:07:59,599
we find that those functions have

00:07:58,000 --> 00:08:01,199
multiple return statements and then

00:07:59,599 --> 00:08:02,000
those methods have multiple return

00:08:01,199 --> 00:08:04,639
statements and

00:08:02,000 --> 00:08:06,240
they're all kind of complex and suddenly

00:08:04,639 --> 00:08:07,680
answering this question becomes time

00:08:06,240 --> 00:08:09,199
consuming and tricky

00:08:07,680 --> 00:08:10,879
we can go read all of these function

00:08:09,199 --> 00:08:12,160
bodies but it becomes difficult to say

00:08:10,879 --> 00:08:14,240
for certain that

00:08:12,160 --> 00:08:15,199
no combination of states or inputs

00:08:14,240 --> 00:08:17,919
result in none

00:08:15,199 --> 00:08:21,360
being returned from this function so

00:08:17,919 --> 00:08:21,360
what happens if we add types

00:08:21,520 --> 00:08:24,560
so here we've added two type annotations

00:08:23,520 --> 00:08:26,560
to our function

00:08:24,560 --> 00:08:28,400
the first is for a parameter type cart

00:08:26,560 --> 00:08:30,639
and the second for our return type which

00:08:28,400 --> 00:08:32,479
is going to be a list of products

00:08:30,639 --> 00:08:33,760
and now all we have to do is run our

00:08:32,479 --> 00:08:35,519
type checker

00:08:33,760 --> 00:08:38,000
and we might see an error that looks

00:08:35,519 --> 00:08:40,719
like this incompatible return type

00:08:38,000 --> 00:08:41,039
expected a list of products but got none

00:08:40,719 --> 00:08:42,719
so

00:08:41,039 --> 00:08:44,880
using a type checker we were able to

00:08:42,719 --> 00:08:47,200
answer this question fairly quickly

00:08:44,880 --> 00:08:48,240
yes this function does return none and

00:08:47,200 --> 00:08:49,680
now we know what

00:08:48,240 --> 00:08:52,560
return types we need to handle when

00:08:49,680 --> 00:08:55,519
we're working with this function

00:08:52,560 --> 00:08:57,519
so we've only really made two small

00:08:55,519 --> 00:08:58,720
changes to our code we've added two type

00:08:57,519 --> 00:09:00,720
annotations

00:08:58,720 --> 00:09:02,560
and using a type checker allows us to be

00:09:00,720 --> 00:09:03,839
more confident about making changes in

00:09:02,560 --> 00:09:05,519
shipping code quickly

00:09:03,839 --> 00:09:07,200
we have a guarantee in place about the

00:09:05,519 --> 00:09:08,399
inputs and return types that we need to

00:09:07,200 --> 00:09:10,480
handle

00:09:08,399 --> 00:09:12,320
whenever we add an annotation we get the

00:09:10,480 --> 00:09:14,560
type checker to do the work of reading

00:09:12,320 --> 00:09:16,160
and understanding the code flow for us

00:09:14,560 --> 00:09:18,240
we tell the type checker what we expect

00:09:16,160 --> 00:09:19,839
this function to do and it guarantees

00:09:18,240 --> 00:09:21,680
that this doesn't come in conflict with

00:09:19,839 --> 00:09:23,200
our expectations for any other function

00:09:21,680 --> 00:09:24,480
or object

00:09:23,200 --> 00:09:26,560
this means that when we go to write our

00:09:24,480 --> 00:09:28,320
unit tests we can focus on the use cases

00:09:26,560 --> 00:09:29,839
that pass in these types without

00:09:28,320 --> 00:09:30,959
worrying about writing tests where this

00:09:29,839 --> 00:09:34,480
function would get something

00:09:30,959 --> 00:09:36,560
other than an art cart as an argument

00:09:34,480 --> 00:09:38,640
the added benefit is that this works as

00:09:36,560 --> 00:09:40,320
built-in up-to-date documentation

00:09:38,640 --> 00:09:42,399
one simply has to look at the function

00:09:40,320 --> 00:09:45,680
signature and know what types to pass in

00:09:42,399 --> 00:09:46,640
and what types they'll get back as we've

00:09:45,680 --> 00:09:48,880
said earlier

00:09:46,640 --> 00:09:51,839
types function as built-in upstate

00:09:48,880 --> 00:09:51,839
documentation

00:09:52,080 --> 00:09:55,120
they help you catch bugs before they

00:09:53,519 --> 00:09:57,120
reach production

00:09:55,120 --> 00:09:58,160
and we can actually eliminate a whole

00:09:57,120 --> 00:09:59,839
category of bugs

00:09:58,160 --> 00:10:01,519
maybe where the wrong type is passed in

00:09:59,839 --> 00:10:04,720
as an argument which can make your unit

00:10:01,519 --> 00:10:06,880
test simpler and more focused

00:10:04,720 --> 00:10:08,560
most python type checkers have an ide

00:10:06,880 --> 00:10:09,760
integration which means you can actually

00:10:08,560 --> 00:10:11,839
catch these type errors

00:10:09,760 --> 00:10:13,680
as you're writing code and they often

00:10:11,839 --> 00:10:16,160
come with more powerful features like

00:10:13,680 --> 00:10:18,079
autocomplete

00:10:16,160 --> 00:10:20,399
a typed code base makes it easier to

00:10:18,079 --> 00:10:23,440
leverage development tools like libcst

00:10:20,399 --> 00:10:24,320
and pisa libcst is a codemod tool and

00:10:23,440 --> 00:10:25,440
pisa

00:10:24,320 --> 00:10:29,040
can help you find security

00:10:25,440 --> 00:10:29,040
vulnerabilities in your code

00:10:31,680 --> 00:10:35,600
so now that you understand the benefits

00:10:33,440 --> 00:10:38,480
of adding types to your python projects

00:10:35,600 --> 00:10:39,120
how do you actually get started our

00:10:38,480 --> 00:10:40,880
advice

00:10:39,120 --> 00:10:42,560
is to start adding types to your most

00:10:40,880 --> 00:10:44,720
used modules first

00:10:42,560 --> 00:10:45,920
and our second is that once you have

00:10:44,720 --> 00:10:47,680
types in your code base

00:10:45,920 --> 00:10:50,320
you want to prevent against type quality

00:10:47,680 --> 00:10:50,320
regressions

00:10:50,399 --> 00:10:53,440
so let's pretend this is our most used

00:10:52,079 --> 00:10:56,880
module it has

00:10:53,440 --> 00:10:57,519
one function foo takes in a list of

00:10:56,880 --> 00:11:00,480
items

00:10:57,519 --> 00:11:02,480
and returns a list of their ids so in

00:11:00,480 --> 00:11:04,959
order to type this we only need two type

00:11:02,480 --> 00:11:07,279
annotations

00:11:04,959 --> 00:11:08,079
so this looks great and we go to run our

00:11:07,279 --> 00:11:10,240
type checker

00:11:08,079 --> 00:11:11,360
and we see a bunch of errors that look

00:11:10,240 --> 00:11:13,600
like this

00:11:11,360 --> 00:11:16,959
incompatible parameter type expected a

00:11:13,600 --> 00:11:18,959
list of items but got a list of strings

00:11:16,959 --> 00:11:20,959
and the first couple times that this

00:11:18,959 --> 00:11:22,399
happens it's a bit confusing

00:11:20,959 --> 00:11:24,079
because it's likely that these type

00:11:22,399 --> 00:11:26,079
errors are going to come from files that

00:11:24,079 --> 00:11:28,800
you haven't touched yet

00:11:26,079 --> 00:11:30,160
so why is this happening well if we open

00:11:28,800 --> 00:11:31,600
up one of these files we might see

00:11:30,160 --> 00:11:33,040
something like this

00:11:31,600 --> 00:11:35,600
we're importing from our most used

00:11:33,040 --> 00:11:36,079
module and bar has a return annotation

00:11:35,600 --> 00:11:37,519
so

00:11:36,079 --> 00:11:39,760
this function has always been type

00:11:37,519 --> 00:11:41,519
checked but we do see that it's passing

00:11:39,760 --> 00:11:42,399
in a list of strings instead of a list

00:11:41,519 --> 00:11:44,800
of items

00:11:42,399 --> 00:11:46,160
but why is this error only popping up

00:11:44,800 --> 00:11:48,240
now

00:11:46,160 --> 00:11:50,560
if you remember earlier we said that any

00:11:48,240 --> 00:11:52,399
untyped expression in python is assumed

00:11:50,560 --> 00:11:54,720
to be type any

00:11:52,399 --> 00:11:56,399
which is compatible with a list of

00:11:54,720 --> 00:11:57,839
strings but now that we have our more

00:11:56,399 --> 00:12:00,399
specific type annotation

00:11:57,839 --> 00:12:01,040
on our parameter for foo it's a list of

00:12:00,399 --> 00:12:02,560
items

00:12:01,040 --> 00:12:04,880
and that's not compatible with the list

00:12:02,560 --> 00:12:05,440
of strings so our type checker is going

00:12:04,880 --> 00:12:07,440
to start

00:12:05,440 --> 00:12:09,519
raising error which is good we're going

00:12:07,440 --> 00:12:11,839
to catch more type errors

00:12:09,519 --> 00:12:13,760
and this happens like a network effect

00:12:11,839 --> 00:12:16,480
so we have our modules

00:12:13,760 --> 00:12:18,720
and they have their dependencies and we

00:12:16,480 --> 00:12:20,639
add types to one of them

00:12:18,720 --> 00:12:22,639
and then we start to see type errors pop

00:12:20,639 --> 00:12:23,839
up all over the code base

00:12:22,639 --> 00:12:25,839
and this is why you want to add

00:12:23,839 --> 00:12:26,399
annotations to your most used module

00:12:25,839 --> 00:12:27,600
first

00:12:26,399 --> 00:12:31,279
because you're going to get the most

00:12:27,600 --> 00:12:33,200
type errors from the fewest annotations

00:12:31,279 --> 00:12:34,560
type coverage is non-linear in its

00:12:33,200 --> 00:12:36,720
benefits and guarantees

00:12:34,560 --> 00:12:39,040
so typing these popular modules first is

00:12:36,720 --> 00:12:40,959
going to give you the most type coverage

00:12:39,040 --> 00:12:42,959
it's probably more beneficial to spend

00:12:40,959 --> 00:12:44,560
time typing class that's imported

00:12:42,959 --> 00:12:46,639
all over your project than it would be

00:12:44,560 --> 00:12:50,399
to maybe type a script that you run

00:12:46,639 --> 00:12:52,240
once or twice a year so now that we've

00:12:50,399 --> 00:12:52,959
added a few annotations to our most used

00:12:52,240 --> 00:12:54,880
module

00:12:52,959 --> 00:12:56,800
we have a bunch of type errors which is

00:12:54,880 --> 00:12:58,480
great we know where more of the type

00:12:56,800 --> 00:13:00,240
errors in our project are

00:12:58,480 --> 00:13:02,399
but we might not have time to sit down

00:13:00,240 --> 00:13:04,800
and fix each one right away

00:13:02,399 --> 00:13:05,440
so python's type system allows you to

00:13:04,800 --> 00:13:07,839
suppress

00:13:05,440 --> 00:13:09,600
errors and the way that you do this is

00:13:07,839 --> 00:13:10,160
just with a comment that says type

00:13:09,600 --> 00:13:13,279
ignore

00:13:10,160 --> 00:13:15,279
and this will ignore any type error from

00:13:13,279 --> 00:13:17,360
the following line

00:13:15,279 --> 00:13:18,720
the idea here is not to suppress every

00:13:17,360 --> 00:13:19,600
type error that your type checker

00:13:18,720 --> 00:13:21,279
surfaces

00:13:19,600 --> 00:13:23,839
that would defeat the point of using a

00:13:21,279 --> 00:13:25,920
type checker but it allows you to make

00:13:23,839 --> 00:13:27,040
incremental progress in annotating large

00:13:25,920 --> 00:13:28,720
code bases

00:13:27,040 --> 00:13:31,200
so they're designed to be a temporary

00:13:28,720 --> 00:13:33,839
fix until you have time to come back

00:13:31,200 --> 00:13:35,680
and fix the underlying issue in the

00:13:33,839 --> 00:13:36,079
meantime they function as warnings to

00:13:35,680 --> 00:13:38,639
you

00:13:36,079 --> 00:13:41,199
and other engineers that hey there's an

00:13:38,639 --> 00:13:41,199
issue here

00:13:42,160 --> 00:13:45,920
when you first get started and you turn

00:13:44,399 --> 00:13:47,600
on type checking in your project

00:13:45,920 --> 00:13:49,120
you'll probably have a bunch of type

00:13:47,600 --> 00:13:50,560
errors even before you've added your

00:13:49,120 --> 00:13:52,240
first annotation

00:13:50,560 --> 00:13:53,680
so we recommend that you set up your

00:13:52,240 --> 00:13:55,360
project and then suppress

00:13:53,680 --> 00:13:56,800
all of these initial errors so that your

00:13:55,360 --> 00:13:57,760
project is in a clean type checking

00:13:56,800 --> 00:13:59,760
state

00:13:57,760 --> 00:14:02,800
the new errors that you introduced will

00:13:59,760 --> 00:14:04,160
be high signal this way

00:14:02,800 --> 00:14:06,320
we actually have a tool that will do

00:14:04,160 --> 00:14:09,839
this for you so prior upgrade will

00:14:06,320 --> 00:14:11,440
suppress any type errors in your project

00:14:09,839 --> 00:14:13,279
and it will also remove type ignores

00:14:11,440 --> 00:14:15,600
that are no longer needed

00:14:13,279 --> 00:14:17,279
so if you pip install prior check pire

00:14:15,600 --> 00:14:19,199
upgrade comes with it

00:14:17,279 --> 00:14:21,279
again they're not meant to be there

00:14:19,199 --> 00:14:23,360
forever and a part of getting to a fully

00:14:21,279 --> 00:14:24,959
typed code base is removing them

00:14:23,360 --> 00:14:27,120
but they're a great tool to help you

00:14:24,959 --> 00:14:30,399
move from having no annotations to a

00:14:27,120 --> 00:14:32,480
fully typed code base

00:14:30,399 --> 00:14:34,240
our second piece of advice was to

00:14:32,480 --> 00:14:35,920
prevent type quality regressions in

00:14:34,240 --> 00:14:37,040
modules that have already been fully

00:14:35,920 --> 00:14:38,800
typed

00:14:37,040 --> 00:14:41,360
so what do we mean by a type quality

00:14:38,800 --> 00:14:43,600
regression if you have a file where

00:14:41,360 --> 00:14:45,920
every function has a return annotation

00:14:43,600 --> 00:14:47,680
and every parameter is annotated and so

00:14:45,920 --> 00:14:49,600
is every attribute in global

00:14:47,680 --> 00:14:50,720
and someone comes along and removes some

00:14:49,600 --> 00:14:52,720
of these annotations

00:14:50,720 --> 00:14:54,800
or adds a bunch of code that has no

00:14:52,720 --> 00:14:55,360
annotations we would call that a type

00:14:54,800 --> 00:14:59,199
quality

00:14:55,360 --> 00:15:01,120
regression so how do you prevent this

00:14:59,199 --> 00:15:03,279
most python type checkers have options

00:15:01,120 --> 00:15:05,040
to configure various strictness settings

00:15:03,279 --> 00:15:07,199
for this next section i'm going to talk

00:15:05,040 --> 00:15:08,880
about how pyr has implemented this

00:15:07,199 --> 00:15:11,360
but you could do something similar if

00:15:08,880 --> 00:15:14,800
you're using a different type checker

00:15:11,360 --> 00:15:16,880
pyr has two modes strict and default

00:15:14,800 --> 00:15:18,000
and we've implemented this on a per file

00:15:16,880 --> 00:15:20,000
basis

00:15:18,000 --> 00:15:21,519
so you're going to start with all of

00:15:20,000 --> 00:15:23,440
your files in default mode

00:15:21,519 --> 00:15:25,920
and in default mode functions that are

00:15:23,440 --> 00:15:27,040
missing parameter or return annotations

00:15:25,920 --> 00:15:30,079
are okay

00:15:27,040 --> 00:15:30,880
just a reminder functions without return

00:15:30,079 --> 00:15:34,240
annotations

00:15:30,880 --> 00:15:36,079
are not type checked in python if you do

00:15:34,240 --> 00:15:37,600
have a return annotation the body of

00:15:36,079 --> 00:15:38,959
that function will be type checked as

00:15:37,600 --> 00:15:40,560
expected

00:15:38,959 --> 00:15:42,399
and if you have an annotation that

00:15:40,560 --> 00:15:46,000
contains an explicit any

00:15:42,399 --> 00:15:48,160
that's allowed once you get a file

00:15:46,000 --> 00:15:51,440
close to being fully typed you'll want

00:15:48,160 --> 00:15:55,920
to flip the mode to pyrestrict

00:15:51,440 --> 00:15:58,639
in strict mode functions that have

00:15:55,920 --> 00:16:00,959
a missing annotation will be an error as

00:15:58,639 --> 00:16:04,160
will parameters attributes and globals

00:16:00,959 --> 00:16:04,160
that are missing annotations

00:16:04,320 --> 00:16:08,079
functions with return annotations are

00:16:06,000 --> 00:16:10,240
type checked as expected

00:16:08,079 --> 00:16:12,160
but if those annotations happen to

00:16:10,240 --> 00:16:15,839
contain an explicit any

00:16:12,160 --> 00:16:15,839
you'll also get an error there as well

00:16:16,560 --> 00:16:20,160
so what you'll want to do is start with

00:16:18,320 --> 00:16:22,320
all of your files in default mode

00:16:20,160 --> 00:16:23,839
and then as you get those files close to

00:16:22,320 --> 00:16:25,759
or completely typed you'll want to

00:16:23,839 --> 00:16:26,800
protect that progress by switching them

00:16:25,759 --> 00:16:28,720
into strict mode

00:16:26,800 --> 00:16:30,880
and that way engineers will get errors

00:16:28,720 --> 00:16:34,639
if they try and remove annotations or

00:16:30,880 --> 00:16:34,639
add unannotated code to them

00:16:34,720 --> 00:16:37,839
once you make progress typing your

00:16:36,320 --> 00:16:39,839
project you can actually switch

00:16:37,839 --> 00:16:42,160
strict mode to be the default and this

00:16:39,839 --> 00:16:42,959
means that if anyone adds a new file to

00:16:42,160 --> 00:16:46,560
your project

00:16:42,959 --> 00:16:48,079
they'll have to add types to it as well

00:16:46,560 --> 00:16:50,320
this prevents regression after the

00:16:48,079 --> 00:16:51,680
initial types are added as we've said

00:16:50,320 --> 00:16:54,079
you would see an error if you were to

00:16:51,680 --> 00:16:55,600
remove annotations or add unannotated

00:16:54,079 --> 00:16:57,680
code

00:16:55,600 --> 00:17:00,079
and it also makes all changes required

00:16:57,680 --> 00:17:02,000
for a fully typed code base explicit

00:17:00,079 --> 00:17:04,880
so you can look at your project and say

00:17:02,000 --> 00:17:06,959
30 of our files in strict mode and 70

00:17:04,880 --> 00:17:08,640
are in default mode and know what you

00:17:06,959 --> 00:17:11,039
have to do to get to a fully typed

00:17:08,640 --> 00:17:11,039
project

00:17:12,160 --> 00:17:15,520
at facebook and instagram we've

00:17:13,679 --> 00:17:16,319
converted several large projects from

00:17:15,520 --> 00:17:18,640
having almost

00:17:16,319 --> 00:17:19,520
no tapes to being nearly or completely

00:17:18,640 --> 00:17:21,360
typed

00:17:19,520 --> 00:17:22,880
and in doing this we found that some

00:17:21,360 --> 00:17:25,199
approaches are more effective than

00:17:22,880 --> 00:17:25,199
others

00:17:25,360 --> 00:17:29,200
so the first thing that you'll want to

00:17:26,959 --> 00:17:30,240
do is get your teams and your engineers

00:17:29,200 --> 00:17:31,520
on board

00:17:30,240 --> 00:17:33,760
and this involves explaining the

00:17:31,520 --> 00:17:35,520
benefits of a typed code base so

00:17:33,760 --> 00:17:37,280
maybe you could start with its built-in

00:17:35,520 --> 00:17:39,520
up-to-date documentation you'll have

00:17:37,280 --> 00:17:40,720
less errors reach production the list

00:17:39,520 --> 00:17:42,960
goes on

00:17:40,720 --> 00:17:43,919
and the second part is to set and

00:17:42,960 --> 00:17:46,400
communicate

00:17:43,919 --> 00:17:48,080
type goals clearly so we found that

00:17:46,400 --> 00:17:49,919
goals like we're going to type all of

00:17:48,080 --> 00:17:52,160
our python projects

00:17:49,919 --> 00:17:53,039
we didn't really have much success with

00:17:52,160 --> 00:17:55,039
but if we said

00:17:53,039 --> 00:17:56,160
50 of our functions are going to have a

00:17:55,039 --> 00:17:59,039
return annotation

00:17:56,160 --> 00:17:59,760
by may 15th we were much more successful

00:17:59,039 --> 00:18:01,600
with those

00:17:59,760 --> 00:18:03,200
so setting clear goals that are

00:18:01,600 --> 00:18:06,720
actionable and time-based

00:18:03,200 --> 00:18:07,360
are essential the second thing that we

00:18:06,720 --> 00:18:10,000
did was

00:18:07,360 --> 00:18:11,760
recognize contributions so we actually

00:18:10,000 --> 00:18:13,440
have a dashboard that tracks individual

00:18:11,760 --> 00:18:15,120
contributions to type coverage

00:18:13,440 --> 00:18:16,640
and it's been a good way to introduce a

00:18:15,120 --> 00:18:18,720
little bit of competition between

00:18:16,640 --> 00:18:20,240
engineers or between teams

00:18:18,720 --> 00:18:22,559
and it resulted in more types in our

00:18:20,240 --> 00:18:24,480
code base

00:18:22,559 --> 00:18:26,320
we also ran what we called code love

00:18:24,480 --> 00:18:27,679
days where we set aside time for

00:18:26,320 --> 00:18:29,520
engineers to

00:18:27,679 --> 00:18:31,840
add types to our code base and in

00:18:29,520 --> 00:18:33,600
exchange we gave them boba

00:18:31,840 --> 00:18:35,840
we also discovered that the pyre team

00:18:33,600 --> 00:18:38,080
can be motivated

00:18:35,840 --> 00:18:40,000
with really anything involving pokemon

00:18:38,080 --> 00:18:43,520
so find what works for your team

00:18:40,000 --> 00:18:45,280
and then use it as well

00:18:43,520 --> 00:18:47,919
we onboard new engineers with typing

00:18:45,280 --> 00:18:49,840
tasks almost every engineer i've met at

00:18:47,919 --> 00:18:51,840
facebook has done a typing task in their

00:18:49,840 --> 00:18:53,919
first few weeks at the company

00:18:51,840 --> 00:18:55,919
they range from removing a type ignore

00:18:53,919 --> 00:18:57,200
or switching a file to strict mode

00:18:55,919 --> 00:18:59,520
they're a really good way to

00:18:57,200 --> 00:19:01,360
get to know your way around a code base

00:18:59,520 --> 00:19:03,520
and we've also had a lot of success with

00:19:01,360 --> 00:19:03,520
them

00:19:05,360 --> 00:19:08,480
i've mentioned that setting goals for

00:19:06,880 --> 00:19:10,480
type coverage is a key part of

00:19:08,480 --> 00:19:12,320
successfully typing a code base

00:19:10,480 --> 00:19:14,400
and we have some recommendations for the

00:19:12,320 --> 00:19:15,840
order in which you tackle this

00:19:14,400 --> 00:19:18,240
the first thing that you'll want to go

00:19:15,840 --> 00:19:20,880
on is reducing the number of functions

00:19:18,240 --> 00:19:22,640
without return annotations and this

00:19:20,880 --> 00:19:24,400
often comes at the expense of adding

00:19:22,640 --> 00:19:24,960
type ignore comments to your code at

00:19:24,400 --> 00:19:28,160
first

00:19:24,960 --> 00:19:30,799
but this is okay it can be accomplished

00:19:28,160 --> 00:19:32,240
two ways one you add a bunch of return

00:19:30,799 --> 00:19:35,120
annotations to your code

00:19:32,240 --> 00:19:36,320
or two you delete a bunch of unannotated

00:19:35,120 --> 00:19:37,600
code

00:19:36,320 --> 00:19:40,480
both will reduce the number of

00:19:37,600 --> 00:19:42,000
unannotated functions in your project

00:19:40,480 --> 00:19:44,000
as you continue to increase type

00:19:42,000 --> 00:19:46,640
coverage you'll want to then focus on

00:19:44,000 --> 00:19:48,480
strictifying as many files as possible

00:19:46,640 --> 00:19:50,080
and as this continues to improve you'll

00:19:48,480 --> 00:19:53,280
then want to set a goal to flip the

00:19:50,080 --> 00:19:55,280
default to strict

00:19:53,280 --> 00:19:56,880
as you move closer to a fully typed code

00:19:55,280 --> 00:19:58,799
base then you'll want to start setting

00:19:56,880 --> 00:20:00,559
goals on driving down the number of

00:19:58,799 --> 00:20:03,440
ignores in your code

00:20:00,559 --> 00:20:04,480
and then finally removing annotations or

00:20:03,440 --> 00:20:07,840
sources of any

00:20:04,480 --> 00:20:07,840
in your code

00:20:08,159 --> 00:20:12,640
so once you've set these goals you'll

00:20:10,720 --> 00:20:14,559
also want to measure your progress

00:20:12,640 --> 00:20:15,840
and when working with teams to add type

00:20:14,559 --> 00:20:17,520
coverage to their projects

00:20:15,840 --> 00:20:19,120
feedback we got is that it's difficult

00:20:17,520 --> 00:20:20,480
to push for type adoption without

00:20:19,120 --> 00:20:24,000
metrics

00:20:20,480 --> 00:20:26,159
so if you pip install prior check

00:20:24,000 --> 00:20:27,840
you can then run prior statistics and

00:20:26,159 --> 00:20:28,240
this will give you information about how

00:20:27,840 --> 00:20:30,799
many

00:20:28,240 --> 00:20:32,559
return annotations parameter annotations

00:20:30,799 --> 00:20:34,480
attribute annotations and global

00:20:32,559 --> 00:20:36,559
annotations you have in your code

00:20:34,480 --> 00:20:38,720
it will also tell you how many files are

00:20:36,559 --> 00:20:40,320
in default versus strict mode

00:20:38,720 --> 00:20:42,320
and how many type ignores are in your

00:20:40,320 --> 00:20:44,640
project so

00:20:42,320 --> 00:20:46,320
we actually run this nightly at facebook

00:20:44,640 --> 00:20:48,000
and we log the data so that we can

00:20:46,320 --> 00:20:50,240
continuously track type coverage

00:20:48,000 --> 00:20:52,159
over time in our projects and we can

00:20:50,240 --> 00:20:54,240
compare our goals

00:20:52,159 --> 00:20:55,919
say if we wanted 50 of our functions to

00:20:54,240 --> 00:20:57,520
have a return annotation

00:20:55,919 --> 00:20:59,280
we can then see if we're on track to

00:20:57,520 --> 00:21:00,720
meet it if we're ahead or behind of

00:20:59,280 --> 00:21:02,400
schedule

00:21:00,720 --> 00:21:04,400
we also use the output of prior

00:21:02,400 --> 00:21:07,360
statistics for other things

00:21:04,400 --> 00:21:08,799
so since it tells us which files are in

00:21:07,360 --> 00:21:10,159
default mode we can use it to

00:21:08,799 --> 00:21:12,799
auto-generate tasks

00:21:10,159 --> 00:21:14,840
to flip files into strict mode we can

00:21:12,799 --> 00:21:17,840
also do the same thing for removing type

00:21:14,840 --> 00:21:17,840
ignores

00:21:18,000 --> 00:21:22,559
i would be lying if i said that every

00:21:20,320 --> 00:21:24,880
type annotation in a python project

00:21:22,559 --> 00:21:26,240
facebook or instagram was manually added

00:21:24,880 --> 00:21:28,000
by an engineer

00:21:26,240 --> 00:21:29,840
we've also leveraged a few tools that

00:21:28,000 --> 00:21:31,600
will automatically apply types to our

00:21:29,840 --> 00:21:33,679
projects for us

00:21:31,600 --> 00:21:34,880
so pyrin fur is one of those and it

00:21:33,679 --> 00:21:37,840
comes when you

00:21:34,880 --> 00:21:39,679
just install pyrocheck it uses static

00:21:37,840 --> 00:21:40,799
type analysis to infer types in your

00:21:39,679 --> 00:21:42,640
project and then

00:21:40,799 --> 00:21:44,640
automatically apply them to your code

00:21:42,640 --> 00:21:45,600
and we actually have a script that will

00:21:44,640 --> 00:21:47,679
run this daily

00:21:45,600 --> 00:21:48,960
on our python projects on just one or

00:21:47,679 --> 00:21:51,760
two files and generate

00:21:48,960 --> 00:21:53,360
a small easy to review pull request and

00:21:51,760 --> 00:21:55,039
it's a really great way to

00:21:53,360 --> 00:21:58,159
continuously move the needle on type

00:21:55,039 --> 00:22:00,240
coverage with minimal effort

00:21:58,159 --> 00:22:01,919
we've also used monkey type which adds

00:22:00,240 --> 00:22:02,640
types based on what the value was at the

00:22:01,919 --> 00:22:04,640
runtime

00:22:02,640 --> 00:22:06,559
so you can run monkeytype on your tests

00:22:04,640 --> 00:22:08,240
or runtime sampling and then it will

00:22:06,559 --> 00:22:09,840
take those types and apply them back to

00:22:08,240 --> 00:22:12,000
your code

00:22:09,840 --> 00:22:13,280
pi annotate is another open source tool

00:22:12,000 --> 00:22:15,360
that you can use and it

00:22:13,280 --> 00:22:17,280
inserts annotations into your code based

00:22:15,360 --> 00:22:20,240
on call arguments and return types

00:22:17,280 --> 00:22:20,240
observed at runtime

00:22:21,120 --> 00:22:24,640
we've made a lot of progress typing our

00:22:23,120 --> 00:22:27,760
project facebook and

00:22:24,640 --> 00:22:30,000
instagram but like python itself types

00:22:27,760 --> 00:22:31,840
in python are continually evolving

00:22:30,000 --> 00:22:33,520
and there are several peps being written

00:22:31,840 --> 00:22:35,200
and proposals being made about how to

00:22:33,520 --> 00:22:38,000
make types easier to read

00:22:35,200 --> 00:22:39,520
and make python code easier to type

00:22:38,000 --> 00:22:41,200
there's a few code patterns that we've

00:22:39,520 --> 00:22:42,880
noticed cause friction when typing

00:22:41,200 --> 00:22:43,280
projects and you might encounter these

00:22:42,880 --> 00:22:46,640
two

00:22:43,280 --> 00:22:48,960
as you get started in your own work

00:22:46,640 --> 00:22:50,080
so empty containers can be a source of

00:22:48,960 --> 00:22:53,360
implicit annie's

00:22:50,080 --> 00:22:55,760
so this is implicitly typed as list any

00:22:53,360 --> 00:22:57,200
and the solution is just to always add a

00:22:55,760 --> 00:22:59,280
type annotation

00:22:57,200 --> 00:23:00,880
when you initialize an empty container

00:22:59,280 --> 00:23:03,120
and some python type checkers will

00:23:00,880 --> 00:23:05,600
actually error if you try and initialize

00:23:03,120 --> 00:23:07,360
without that annotation refining

00:23:05,600 --> 00:23:08,480
optional attributes can also pose a

00:23:07,360 --> 00:23:10,799
challenge

00:23:08,480 --> 00:23:12,799
so here we can't blindly infer that the

00:23:10,799 --> 00:23:13,360
type of attribute is not optional after

00:23:12,799 --> 00:23:15,200
the check

00:23:13,360 --> 00:23:16,559
since any interleaving call might set

00:23:15,200 --> 00:23:18,720
the attribute to none

00:23:16,559 --> 00:23:20,320
so the solution would be to assign your

00:23:18,720 --> 00:23:23,120
attribute to a local variable

00:23:20,320 --> 00:23:24,400
and then do the check however this is a

00:23:23,120 --> 00:23:26,960
little bit verbose

00:23:24,400 --> 00:23:28,720
so in python 3.9 you can use the walrus

00:23:26,960 --> 00:23:31,200
operator to help make this check a lot

00:23:28,720 --> 00:23:31,200
simpler

00:23:33,120 --> 00:23:36,880
it's common to pass around dictionaries

00:23:35,120 --> 00:23:38,000
of data with an unclear structure in

00:23:36,880 --> 00:23:39,360
python

00:23:38,000 --> 00:23:41,120
but often json types are

00:23:39,360 --> 00:23:43,440
self-referencing which isn't currently

00:23:41,120 --> 00:23:45,679
supported with types in python

00:23:43,440 --> 00:23:47,520
and django endpoint responses can be

00:23:45,679 --> 00:23:48,880
huge dictionaries with a variety of

00:23:47,520 --> 00:23:51,120
types as the value

00:23:48,880 --> 00:23:52,080
and this is harder than a standard type

00:23:51,120 --> 00:23:53,440
dictionary because

00:23:52,080 --> 00:23:56,880
any number of these values can be

00:23:53,440 --> 00:23:59,120
optional so as a result

00:23:56,880 --> 00:24:00,080
this is an exception to the rule that

00:23:59,120 --> 00:24:02,480
annie's are not

00:24:00,080 --> 00:24:03,360
allowed in strict mode so even though

00:24:02,480 --> 00:24:06,240
dict string

00:24:03,360 --> 00:24:09,760
any contains an explicit any it's a

00:24:06,240 --> 00:24:11,760
valid annotation in strict mode

00:24:09,760 --> 00:24:13,039
as i said earlier types in python are

00:24:11,760 --> 00:24:14,559
continually evolving

00:24:13,039 --> 00:24:16,400
there are currently a few proposals

00:24:14,559 --> 00:24:18,960
about how to simplify type syntax and

00:24:16,400 --> 00:24:20,799
make annotations less verbose and easier

00:24:18,960 --> 00:24:22,880
to read

00:24:20,799 --> 00:24:24,320
one of these is new syntax for union

00:24:22,880 --> 00:24:26,159
types

00:24:24,320 --> 00:24:27,919
instead of having to import from typing

00:24:26,159 --> 00:24:30,840
you can just use the pipe operator

00:24:27,919 --> 00:24:32,000
and this will be available in python

00:24:30,840 --> 00:24:34,880
3.10.

00:24:32,000 --> 00:24:37,200
is also a proposal in a similar vein to

00:24:34,880 --> 00:24:39,039
improve the syntax for optional types

00:24:37,200 --> 00:24:40,480
this one is still in the early stages

00:24:39,039 --> 00:24:42,080
and there's no guarantee that it will

00:24:40,480 --> 00:24:43,600
make it into the language but it's a

00:24:42,080 --> 00:24:45,120
good example of some of the work that's

00:24:43,600 --> 00:24:46,240
currently being done to improve types in

00:24:45,120 --> 00:24:48,000
python

00:24:46,240 --> 00:24:49,440
there are also proposals about new

00:24:48,000 --> 00:24:51,520
syntax for callables

00:24:49,440 --> 00:24:52,559
and new features or keywords for type

00:24:51,520 --> 00:24:54,400
dictionaries

00:24:52,559 --> 00:24:58,480
so there's a lot of work being done to

00:24:54,400 --> 00:24:58,480
continually approve types in python

00:24:59,440 --> 00:25:03,120
so before we wrap up let's recap some of

00:25:01,840 --> 00:25:06,640
the things we've learned about

00:25:03,120 --> 00:25:07,919
gradual typing in practice so gradual

00:25:06,640 --> 00:25:08,880
types can act as up-to-date

00:25:07,919 --> 00:25:10,400
documentation

00:25:08,880 --> 00:25:14,240
and reduce the amount of type errors

00:25:10,400 --> 00:25:15,760
that reach production

00:25:14,240 --> 00:25:17,520
in order to type your project you'll

00:25:15,760 --> 00:25:21,600
first want to get your teams on board

00:25:17,520 --> 00:25:21,600
and set clear time-based goals

00:25:21,760 --> 00:25:24,880
as you get started type your most used

00:25:23,760 --> 00:25:26,840
modules first

00:25:24,880 --> 00:25:28,720
and make sure that you measure your

00:25:26,840 --> 00:25:30,000
progress

00:25:28,720 --> 00:25:32,640
if you're interested in learning more

00:25:30,000 --> 00:25:33,440
about types in python specifically at

00:25:32,640 --> 00:25:35,360
facebook

00:25:33,440 --> 00:25:37,600
several facebook engineers have done

00:25:35,360 --> 00:25:40,080
talks about typed python so

00:25:37,600 --> 00:25:40,880
carl did type check python peter has

00:25:40,080 --> 00:25:43,440
done types

00:25:40,880 --> 00:25:45,279
deeper static analysis and you and

00:25:43,440 --> 00:25:47,600
shannon did leveraging the type system

00:25:45,279 --> 00:25:49,279
to write secure applications

00:25:47,600 --> 00:25:57,840
i look forward to answering some of your

00:25:49,279 --> 00:25:57,840
questions thanks

00:26:51,360 --> 00:26:53,440

YouTube URL: https://www.youtube.com/watch?v=Lj_9TyT3V98


