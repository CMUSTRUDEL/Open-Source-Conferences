Title: TALK   Tobias Kohn   The Road to Pattern Matching in Python
Publication date: 2021-05-30
Playlist: PyCon US 2021
Description: 
	Pattern matching is a great and proven tool for programmers. However, can we also assimilate and integrate it into Python? This talk tries to give an answer and discusses the rationale and ideas behind the recent "pattern matching" PEPs.

Processing structured data has sparked ever more powerful programming tools. Python's objects and classes, for instance, have proven themselves to be particularly versatile and form part of the backbone of the language. Constructing or building new objects---including built-ins such as lists, tuples or dictionaries---abounds in any Python code. In contrast, testing the structure of data and extracting specific elements is often rather cumbersome, requiring the frequent use of built-in functions like isinstance, len and getattr.

Pattern matching addresses this issue by introducing a new paradigm to de-construct data, complementing existing tools. It can be thought of as an extension of Python's iterable unpacking to arbitrary objects. However, it does so in a 'safe' way, ensuring that objects have the necessary structure to proceed with unpacking elements and attributes.

The objective of this talk is to give you an overview of why pattern matching matters and what it really is. You will gain a deeper understanding of the core concepts that make up pattern matching, as well as the design decisions and ideas behind the recent "pattern matching" PEPs. However, this talk will not provide an introduction on how to use pattern matching in your code, nor is it about the intricacies of the implementation. If you are a Python programmer, have heard of the new pattern matching features and are wondering what it is all about, then this talk is for you.
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:14,320 --> 00:00:17,199
pattern matching

00:00:15,360 --> 00:00:19,119
an exciting new feature that's coming to

00:00:17,199 --> 00:00:20,960
python 3.10

00:00:19,119 --> 00:00:22,720
but what is pattern matching and why

00:00:20,960 --> 00:00:24,560
should you care about it

00:00:22,720 --> 00:00:25,760
let me take you on a journey where we

00:00:24,560 --> 00:00:28,240
explore some of the

00:00:25,760 --> 00:00:31,439
thoughts and ideas that led to the

00:00:28,240 --> 00:00:33,600
design of pattern matching in python

00:00:31,439 --> 00:00:36,640
my name is tobias corn and i'm going to

00:00:33,600 --> 00:00:38,800
be your guide tonight

00:00:36,640 --> 00:00:40,480
it is surprisingly hard to give a clear

00:00:38,800 --> 00:00:42,320
cut definition of what pattern matching

00:00:40,480 --> 00:00:44,640
is that works for all the varieties of

00:00:42,320 --> 00:00:46,239
pattern matching out there in the wild

00:00:44,640 --> 00:00:47,920
but since pattern matching is a threat

00:00:46,239 --> 00:00:50,320
that holds all this talk together

00:00:47,920 --> 00:00:52,239
let me try anyways and for that i want

00:00:50,320 --> 00:00:53,680
to focus on the three main tasks of

00:00:52,239 --> 00:00:56,399
pattern matching

00:00:53,680 --> 00:00:58,160
it first checks the structured type or

00:00:56,399 --> 00:00:59,520
shape or whatever you want to name it of

00:00:58,160 --> 00:01:02,480
the data that you feed in

00:00:59,520 --> 00:01:03,760
of your object parameter variable or

00:01:02,480 --> 00:01:06,320
whatever

00:01:03,760 --> 00:01:07,200
it then selects code based on this shape

00:01:06,320 --> 00:01:10,640
or type

00:01:07,200 --> 00:01:14,080
of your object of your data say

00:01:10,640 --> 00:01:16,080
you want to run code for if your object

00:01:14,080 --> 00:01:17,680
is an integer and that might be

00:01:16,080 --> 00:01:18,320
different from the code that you want to

00:01:17,680 --> 00:01:21,439
run if

00:01:18,320 --> 00:01:24,720
you have a string or a tuple or list

00:01:21,439 --> 00:01:26,479
or an object anyways and it finally

00:01:24,720 --> 00:01:27,439
extracts the relevant pieces of

00:01:26,479 --> 00:01:30,159
information

00:01:27,439 --> 00:01:31,119
automatically from your object or input

00:01:30,159 --> 00:01:33,200
data

00:01:31,119 --> 00:01:35,200
and provides them in local variables for

00:01:33,200 --> 00:01:38,000
further processing

00:01:35,200 --> 00:01:39,119
so you have a sequence and you're only

00:01:38,000 --> 00:01:42,240
interested in the first

00:01:39,119 --> 00:01:43,520
and last elements of this sequence then

00:01:42,240 --> 00:01:45,840
there's no need to keep

00:01:43,520 --> 00:01:46,640
all the rest you just take these two

00:01:45,840 --> 00:01:48,560
elements

00:01:46,640 --> 00:01:50,399
store them in local variables and you

00:01:48,560 --> 00:01:52,720
continue the processing

00:01:50,399 --> 00:01:55,600
that's the idea of pattern matching or

00:01:52,720 --> 00:01:58,399
the extraction part of pattern matching

00:01:55,600 --> 00:02:00,560
let me illustrate all that with a very

00:01:58,399 --> 00:02:03,040
simple example

00:02:00,560 --> 00:02:05,280
let's assume we have two classes the

00:02:03,040 --> 00:02:08,560
first class is to handle order

00:02:05,280 --> 00:02:09,280
to represent circles the second class

00:02:08,560 --> 00:02:12,640
represents

00:02:09,280 --> 00:02:15,760
rectangles now each of these classes

00:02:12,640 --> 00:02:17,760
has attributes for the position x and y

00:02:15,760 --> 00:02:19,840
as well as the size which is the radius

00:02:17,760 --> 00:02:21,280
for circles width and height for the

00:02:19,840 --> 00:02:24,400
rectangles

00:02:21,280 --> 00:02:26,959
and your task is now to write a function

00:02:24,400 --> 00:02:28,160
area to compute the area of either of

00:02:26,959 --> 00:02:29,840
these objects

00:02:28,160 --> 00:02:31,440
so you're giving it an instance of

00:02:29,840 --> 00:02:33,440
either circle or rectangle

00:02:31,440 --> 00:02:37,120
and your function returns the area of

00:02:33,440 --> 00:02:39,040
that how would you do that

00:02:37,120 --> 00:02:40,640
your code might perhaps look something

00:02:39,040 --> 00:02:43,120
like this

00:02:40,640 --> 00:02:44,640
so you have this area function you're

00:02:43,120 --> 00:02:47,040
given some shape

00:02:44,640 --> 00:02:48,640
and first you check is it an instance of

00:02:47,040 --> 00:02:52,400
circle is it an instance

00:02:48,640 --> 00:02:53,840
of rectangle next you then extract the

00:02:52,400 --> 00:02:56,480
relevant information

00:02:53,840 --> 00:02:58,319
from your object that you're given in

00:02:56,480 --> 00:03:00,400
case of the circle that's the radius

00:02:58,319 --> 00:03:01,360
in case of the rectangle that's width

00:03:00,400 --> 00:03:04,080
and height

00:03:01,360 --> 00:03:05,200
which you store in local variables to

00:03:04,080 --> 00:03:07,599
then apply

00:03:05,200 --> 00:03:10,800
the mathematical formulas to compute the

00:03:07,599 --> 00:03:12,640
area and return them back

00:03:10,800 --> 00:03:15,200
now here's the pattern matching version

00:03:12,640 --> 00:03:18,319
of the very same code

00:03:15,200 --> 00:03:18,800
you can see how this selection of the

00:03:18,319 --> 00:03:22,080
right

00:03:18,800 --> 00:03:25,280
code this checking of what structure

00:03:22,080 --> 00:03:28,239
what type does the input shape have

00:03:25,280 --> 00:03:29,760
correlates with the extraction of the

00:03:28,239 --> 00:03:31,760
relevant pieces of information and

00:03:29,760 --> 00:03:34,879
storing them in local variables

00:03:31,760 --> 00:03:38,560
so this one line case circle

00:03:34,879 --> 00:03:42,000
underline underline radius says

00:03:38,560 --> 00:03:44,319
kind of run select this code if you have

00:03:42,000 --> 00:03:45,440
something of type circle where i don't

00:03:44,319 --> 00:03:48,480
care about the

00:03:45,440 --> 00:03:51,599
position but i want the radius extracted

00:03:48,480 --> 00:03:53,599
and stored in a local variable radius

00:03:51,599 --> 00:03:55,280
in the case of the rectangle we still

00:03:53,599 --> 00:03:57,120
don't care about the position

00:03:55,280 --> 00:03:58,640
but we want the width and height

00:03:57,120 --> 00:04:02,080
extracted and stored

00:03:58,640 --> 00:04:04,239
in local variables wd and ht

00:04:02,080 --> 00:04:06,159
and then the rest is the same as before

00:04:04,239 --> 00:04:08,319
you apply the mathematical formulas and

00:04:06,159 --> 00:04:10,159
return the area that you computed for

00:04:08,319 --> 00:04:11,920
either shape

00:04:10,159 --> 00:04:13,200
since checking to type and selecting

00:04:11,920 --> 00:04:15,040
code based on the type

00:04:13,200 --> 00:04:16,720
is usually one the same we could say

00:04:15,040 --> 00:04:17,919
that pattern matching does two things

00:04:16,720 --> 00:04:20,959
for you

00:04:17,919 --> 00:04:23,759
it selects some specialized code

00:04:20,959 --> 00:04:26,639
to handle and process data of a specific

00:04:23,759 --> 00:04:29,199
kind of a specific type or structure

00:04:26,639 --> 00:04:30,800
and it automatically extracts relevant

00:04:29,199 --> 00:04:33,199
data or attributes

00:04:30,800 --> 00:04:34,160
information from the object that you

00:04:33,199 --> 00:04:36,800
provide

00:04:34,160 --> 00:04:39,520
so that you can go ahead and concentrate

00:04:36,800 --> 00:04:41,440
on what's really important

00:04:39,520 --> 00:04:43,199
pattern matching is by no means a new

00:04:41,440 --> 00:04:44,960
feature but has been around for about

00:04:43,199 --> 00:04:47,360
half a century give or take

00:04:44,960 --> 00:04:48,560
and is certainly older than python it

00:04:47,360 --> 00:04:50,479
just seems to be

00:04:48,560 --> 00:04:53,440
new to python now that we introduce this

00:04:50,479 --> 00:04:55,040
feature so let's have a brief look

00:04:53,440 --> 00:04:56,960
at the early beginnings of pattern

00:04:55,040 --> 00:04:58,000
matching and how it evolved to become

00:04:56,960 --> 00:04:59,919
one of the most

00:04:58,000 --> 00:05:01,600
popular feature in modern programming

00:04:59,919 --> 00:05:03,680
languages

00:05:01,600 --> 00:05:06,639
in the very beginning pattern matching

00:05:03,680 --> 00:05:08,960
was some form of tuple unpacking

00:05:06,639 --> 00:05:11,280
sounds familiar of course super

00:05:08,960 --> 00:05:12,960
unpacking is already part of python's

00:05:11,280 --> 00:05:15,120
very fundamental core

00:05:12,960 --> 00:05:17,520
and as such you could argue that pattern

00:05:15,120 --> 00:05:19,919
matching is nothing new to python

00:05:17,520 --> 00:05:22,880
which is extending those capabilities to

00:05:19,919 --> 00:05:25,520
be more powerful more versatile now

00:05:22,880 --> 00:05:27,039
but let's go back to our history lesson

00:05:25,520 --> 00:05:30,639
and look back at how tuple

00:05:27,039 --> 00:05:32,639
packing actually started the goal was to

00:05:30,639 --> 00:05:35,440
create a minimalistic language

00:05:32,639 --> 00:05:37,199
a functional language with strong static

00:05:35,440 --> 00:05:37,759
types where the compiler could figure

00:05:37,199 --> 00:05:39,759
out

00:05:37,759 --> 00:05:42,720
the type of every little piece of your

00:05:39,759 --> 00:05:44,080
code the problem was however how to deal

00:05:42,720 --> 00:05:46,639
with tuples

00:05:44,080 --> 00:05:47,440
a tuple can have elements of different

00:05:46,639 --> 00:05:49,360
types

00:05:47,440 --> 00:05:51,199
in example on a screen we have an

00:05:49,360 --> 00:05:52,000
integer for the first field and we have

00:05:51,199 --> 00:05:56,160
a string for the

00:05:52,000 --> 00:05:57,039
second if we now use some item access

00:05:56,160 --> 00:05:59,919
here so

00:05:57,039 --> 00:06:01,600
we know that tuple 0 has type in touch

00:05:59,919 --> 00:06:04,960
tuple 1 has type string

00:06:01,600 --> 00:06:06,720
but if we look at tuple i

00:06:04,960 --> 00:06:08,000
we could not figure out the type of

00:06:06,720 --> 00:06:09,759
tuple i

00:06:08,000 --> 00:06:12,319
uh whether it is an int or string

00:06:09,759 --> 00:06:16,000
without knowing exactly what value i

00:06:12,319 --> 00:06:18,319
has so this item access

00:06:16,000 --> 00:06:20,240
poses a problem to the compiler if it

00:06:18,319 --> 00:06:23,680
wants to figure out what kind of

00:06:20,240 --> 00:06:26,080
of type every element in your code has

00:06:23,680 --> 00:06:28,000
and the solution was to do away with

00:06:26,080 --> 00:06:31,120
this item access altogether

00:06:28,000 --> 00:06:33,120
and use tuplan packing instead

00:06:31,120 --> 00:06:34,319
however if we're now dealing with

00:06:33,120 --> 00:06:37,440
dynamic

00:06:34,319 --> 00:06:39,759
data types there is to say with trees or

00:06:37,440 --> 00:06:43,280
linked lists or something like that

00:06:39,759 --> 00:06:44,240
we have another problem in order for a

00:06:43,280 --> 00:06:47,199
linked list

00:06:44,240 --> 00:06:48,319
we kind of link these different tuples

00:06:47,199 --> 00:06:51,840
together

00:06:48,319 --> 00:06:53,440
in python that looks as if the tuples

00:06:51,840 --> 00:06:57,039
following the first one

00:06:53,440 --> 00:06:59,680
are enclosed in the first tuple

00:06:57,039 --> 00:07:01,280
however even if you look in python the

00:06:59,680 --> 00:07:03,440
memory layout is a

00:07:01,280 --> 00:07:05,919
number of tuples that refer to each

00:07:03,440 --> 00:07:09,520
other in kind of a linked list

00:07:05,919 --> 00:07:10,639
variant anyway the problem that we have

00:07:09,520 --> 00:07:14,160
to deal with

00:07:10,639 --> 00:07:16,240
is that we have an end marker we have a

00:07:14,160 --> 00:07:17,919
non-field at the very end which is not a

00:07:16,240 --> 00:07:20,800
tool anymore

00:07:17,919 --> 00:07:22,560
that is if we just use tuplan packing

00:07:20,800 --> 00:07:23,039
like you see at the very bottom of this

00:07:22,560 --> 00:07:26,639
slide

00:07:23,039 --> 00:07:29,120
so we say x comma rest equals my list

00:07:26,639 --> 00:07:31,759
we have the problem that if my list

00:07:29,120 --> 00:07:34,000
finally ends up to be none

00:07:31,759 --> 00:07:36,000
it doesn't really unpack into acts and

00:07:34,000 --> 00:07:38,080
rest so we have a problem there we have

00:07:36,000 --> 00:07:41,520
an error we have kind of

00:07:38,080 --> 00:07:44,240
we can't unpack none to be two elements

00:07:41,520 --> 00:07:46,639
how do we deal with that the solution

00:07:44,240 --> 00:07:48,720
was to introduce conditional unpacking

00:07:46,639 --> 00:07:50,800
rather than just saying xcom arrest

00:07:48,720 --> 00:07:54,160
equals my list or tuple

00:07:50,800 --> 00:07:57,680
whatever i offer two cases

00:07:54,160 --> 00:08:00,800
the first one uncommon rest applies if

00:07:57,680 --> 00:08:01,520
the given my list data structure really

00:08:00,800 --> 00:08:05,520
can be

00:08:01,520 --> 00:08:10,840
unpacked into an n and a rest element

00:08:05,520 --> 00:08:12,160
otherwise the case none statement is

00:08:10,840 --> 00:08:14,000
executed

00:08:12,160 --> 00:08:16,000
it was discovered fairly quickly that

00:08:14,000 --> 00:08:18,800
patterns could be nested so as to

00:08:16,000 --> 00:08:20,960
express and represent special cases

00:08:18,800 --> 00:08:22,960
which could then be handled separately

00:08:20,960 --> 00:08:24,879
as you can see here on the screen where

00:08:22,960 --> 00:08:25,440
we have linked lists with exactly two

00:08:24,879 --> 00:08:28,720
elements

00:08:25,440 --> 00:08:30,879
m and n followed by the end marker

00:08:28,720 --> 00:08:33,200
if you then go one step further and try

00:08:30,879 --> 00:08:35,839
to handle arbitrary objects

00:08:33,200 --> 00:08:37,919
and classes rather than just tuples you

00:08:35,839 --> 00:08:39,120
arrive at pattern matching in its modern

00:08:37,919 --> 00:08:41,200
powerful form

00:08:39,120 --> 00:08:43,839
and how it is also included in python

00:08:41,200 --> 00:08:46,959
3.10 now

00:08:43,839 --> 00:08:50,160
to summarize pattern matching started as

00:08:46,959 --> 00:08:52,240
a feature for tuple and packing and with

00:08:50,160 --> 00:08:53,360
the desire to handle dynamic data

00:08:52,240 --> 00:08:55,360
structures

00:08:53,360 --> 00:08:56,399
now tube line packing and dynamic data

00:08:55,360 --> 00:08:58,399
structures

00:08:56,399 --> 00:08:59,839
really sound like something that's right

00:08:58,399 --> 00:09:02,320
up python's alley

00:08:59,839 --> 00:09:02,320
isn't it

00:09:03,040 --> 00:09:06,640
with a basic understanding of what

00:09:04,959 --> 00:09:07,279
pattern matching is and where it comes

00:09:06,640 --> 00:09:09,360
from

00:09:07,279 --> 00:09:11,040
we now face the challenge of properly

00:09:09,360 --> 00:09:12,399
incorporating pattern matching into

00:09:11,040 --> 00:09:14,480
python

00:09:12,399 --> 00:09:16,080
despite the similarities between pattern

00:09:14,480 --> 00:09:17,120
matching and some of python's core

00:09:16,080 --> 00:09:18,880
features

00:09:17,120 --> 00:09:20,160
we still need to be aware that we're

00:09:18,880 --> 00:09:23,440
introducing

00:09:20,160 --> 00:09:26,800
a new paradigm of writing code

00:09:23,440 --> 00:09:28,720
and hence dreadlightly there are three

00:09:26,800 --> 00:09:32,160
key aspects that i want to bring

00:09:28,720 --> 00:09:35,600
bring up in this context first

00:09:32,160 --> 00:09:37,680
the new future needs to be isolated

00:09:35,600 --> 00:09:39,040
the new pattern matching should not

00:09:37,680 --> 00:09:41,760
affect any code

00:09:39,040 --> 00:09:43,680
outside match statement everything

00:09:41,760 --> 00:09:46,240
pattern matching related

00:09:43,680 --> 00:09:47,440
should be constrained to and limited to

00:09:46,240 --> 00:09:51,440
the match statement

00:09:47,440 --> 00:09:54,240
not affect any code outside of that

00:09:51,440 --> 00:09:56,160
second it should be familiar to python

00:09:54,240 --> 00:09:58,240
programmers but also to those

00:09:56,160 --> 00:10:00,160
who already know pattern matching from

00:09:58,240 --> 00:10:01,760
some other language

00:10:00,160 --> 00:10:03,839
there's an entire world of pattern

00:10:01,760 --> 00:10:06,160
matching out there that we want to tap

00:10:03,839 --> 00:10:08,320
into and we want to make sure that

00:10:06,160 --> 00:10:09,360
there's a smooth transition between

00:10:08,320 --> 00:10:11,839
pattern matching

00:10:09,360 --> 00:10:12,880
in the large and pattern matching use in

00:10:11,839 --> 00:10:14,959
python

00:10:12,880 --> 00:10:16,560
whether you come from from python you've

00:10:14,959 --> 00:10:16,959
learned pattern matching here and want

00:10:16,560 --> 00:10:18,640
to

00:10:16,959 --> 00:10:22,160
apply it and use it in a different

00:10:18,640 --> 00:10:24,399
language or you go the other direction

00:10:22,160 --> 00:10:28,560
for that we want to use established

00:10:24,399 --> 00:10:31,040
syntax and conventions wherever possible

00:10:28,560 --> 00:10:32,640
but we also want to use this established

00:10:31,040 --> 00:10:35,440
syntax and conventions from

00:10:32,640 --> 00:10:36,160
python and honor patents traditions and

00:10:35,440 --> 00:10:39,600
culture

00:10:36,160 --> 00:10:41,760
to to whatever is possible this means

00:10:39,600 --> 00:10:43,440
unavoidably that sometimes the two

00:10:41,760 --> 00:10:45,920
worlds will clash

00:10:43,440 --> 00:10:46,959
and we need to find some compromise and

00:10:45,920 --> 00:10:49,360
trade-off

00:10:46,959 --> 00:10:52,240
in order to find a solution that works

00:10:49,360 --> 00:10:54,240
as good as possible

00:10:52,240 --> 00:10:56,000
but we also acknowledge that this will

00:10:54,240 --> 00:10:58,560
probably not be

00:10:56,000 --> 00:11:00,000
the best solution for everyone out there

00:10:58,560 --> 00:11:03,120
and some people will probably

00:11:00,000 --> 00:11:05,839
not be too happy with it

00:11:03,120 --> 00:11:08,000
finally we also want this new pattern

00:11:05,839 --> 00:11:10,480
matching feature to be compatible with

00:11:08,000 --> 00:11:12,880
code that's already out there

00:11:10,480 --> 00:11:14,720
you should not need to rewrite your

00:11:12,880 --> 00:11:17,279
entire code base

00:11:14,720 --> 00:11:18,880
or all your libraries in order to for

00:11:17,279 --> 00:11:20,399
them to work with the new pattern

00:11:18,880 --> 00:11:23,920
matching feature

00:11:20,399 --> 00:11:27,440
rather we aim for a gradual introduction

00:11:23,920 --> 00:11:29,920
where by and by you write new code

00:11:27,440 --> 00:11:30,480
using pattern matching where it really

00:11:29,920 --> 00:11:34,399
shines

00:11:30,480 --> 00:11:37,120
and makes sense this leads to some

00:11:34,399 --> 00:11:40,800
direct and immediate consequences

00:11:37,120 --> 00:11:43,839
first we need to introduce a new keyword

00:11:40,800 --> 00:11:45,920
match for this pattern matching syntax

00:11:43,839 --> 00:11:46,880
so that the compiler has a chance to

00:11:45,920 --> 00:11:49,120
recognize

00:11:46,880 --> 00:11:50,560
at which point we are switching to this

00:11:49,120 --> 00:11:53,600
pattern matching world

00:11:50,560 --> 00:11:56,399
where we really want to use it and

00:11:53,600 --> 00:11:57,920
if you don't use this match statement

00:11:56,399 --> 00:12:01,120
match keyword

00:11:57,920 --> 00:12:03,040
it will not affect anything you do this

00:12:01,120 --> 00:12:05,839
means secondly of course that match and

00:12:03,040 --> 00:12:08,639
case need to be soft keywords

00:12:05,839 --> 00:12:09,040
they're not keywords if you're outside

00:12:08,639 --> 00:12:11,360
this

00:12:09,040 --> 00:12:12,079
match statement and you can continue

00:12:11,360 --> 00:12:14,240
using them

00:12:12,079 --> 00:12:16,560
as variable names function names or

00:12:14,240 --> 00:12:18,639
whatever you want to

00:12:16,560 --> 00:12:20,800
there are also some things that come up

00:12:18,639 --> 00:12:23,600
from python's culture side

00:12:20,800 --> 00:12:25,519
so with purple unpacking or iterable

00:12:23,600 --> 00:12:27,760
unpacking in python

00:12:25,519 --> 00:12:31,040
the syntax using lists with square

00:12:27,760 --> 00:12:34,320
brackets or tuples with round brackets

00:12:31,040 --> 00:12:36,880
for targets of iterable unpacking

00:12:34,320 --> 00:12:38,240
are both equivalent and we want to keep

00:12:36,880 --> 00:12:40,240
something like that

00:12:38,240 --> 00:12:42,000
even though it slightly restricts what

00:12:40,240 --> 00:12:44,639
we can do with patterns in the new

00:12:42,000 --> 00:12:47,279
pattern matching feature

00:12:44,639 --> 00:12:49,519
and finally although pattern matching is

00:12:47,279 --> 00:12:51,200
in most cases used in functional

00:12:49,519 --> 00:12:52,320
languages where everything is an

00:12:51,200 --> 00:12:56,720
expression

00:12:52,320 --> 00:12:59,920
in python match must be a statement

00:12:56,720 --> 00:13:01,399
as much as different case things as

00:12:59,920 --> 00:13:03,200
python is fundamentally a

00:13:01,399 --> 00:13:07,200
statement-oriented language

00:13:03,200 --> 00:13:08,959
not an expression-oriented one

00:13:07,200 --> 00:13:10,959
there are some issues that can

00:13:08,959 --> 00:13:12,800
inherently never be fully resolved

00:13:10,959 --> 00:13:13,760
because the conflict lies in the very

00:13:12,800 --> 00:13:15,839
nature

00:13:13,760 --> 00:13:18,240
of what we're trying to do or how we

00:13:15,839 --> 00:13:22,000
look at things or how we interpret

00:13:18,240 --> 00:13:24,240
things differently depending on context

00:13:22,000 --> 00:13:25,360
let me illustrate this with the example

00:13:24,240 --> 00:13:28,160
of how we use

00:13:25,360 --> 00:13:30,240
names in patterns to express different

00:13:28,160 --> 00:13:33,279
things

00:13:30,240 --> 00:13:36,320
usually we would think of using a name

00:13:33,279 --> 00:13:38,480
in a pattern as an assignment target

00:13:36,320 --> 00:13:40,160
however if you look at the example

00:13:38,480 --> 00:13:41,279
that's provided here on the left hand

00:13:40,160 --> 00:13:43,279
side

00:13:41,279 --> 00:13:46,000
you can see that the intention was

00:13:43,279 --> 00:13:49,600
probably something different

00:13:46,000 --> 00:13:51,519
so if we look at case pi here from a

00:13:49,600 --> 00:13:54,160
compiler's perspective

00:13:51,519 --> 00:13:55,680
we would think that pi is local variable

00:13:54,160 --> 00:13:59,360
and we want to assign the

00:13:55,680 --> 00:14:01,519
value of x to this pi here however

00:13:59,360 --> 00:14:02,720
if we look at the entire code we can

00:14:01,519 --> 00:14:04,720
assume that

00:14:02,720 --> 00:14:06,320
probably the intention of the program

00:14:04,720 --> 00:14:08,800
here was to load

00:14:06,320 --> 00:14:09,920
pi from the math module and then have

00:14:08,800 --> 00:14:13,279
this first k

00:14:09,920 --> 00:14:17,120
succeed if x actually has a value that

00:14:13,279 --> 00:14:20,560
coincides with pi the question then is

00:14:17,120 --> 00:14:24,639
how do it how do we interpret this case

00:14:20,560 --> 00:14:27,760
do we match only if x equals pi

00:14:24,639 --> 00:14:31,120
that is to say do we do a comparison

00:14:27,760 --> 00:14:33,760
between pi and x or do we match anything

00:14:31,120 --> 00:14:34,399
and set the variable pi to the value of

00:14:33,760 --> 00:14:37,680
x

00:14:34,399 --> 00:14:40,160
so do we find pi

00:14:37,680 --> 00:14:42,320
these two semantics clearly clash and

00:14:40,160 --> 00:14:44,160
it's very difficult for the compiler or

00:14:42,320 --> 00:14:46,320
interpreter to figure out which one to

00:14:44,160 --> 00:14:48,880
choose

00:14:46,320 --> 00:14:49,440
if we have a language with declarations

00:14:48,880 --> 00:14:52,079
so

00:14:49,440 --> 00:14:53,120
where we have to say var x equals

00:14:52,079 --> 00:14:56,160
something or we

00:14:53,120 --> 00:14:57,760
say in acts or whatever

00:14:56,160 --> 00:14:59,600
in order to make sure that we are

00:14:57,760 --> 00:15:03,279
introducing a new variable

00:14:59,600 --> 00:15:05,199
at this point we can then differentiate

00:15:03,279 --> 00:15:07,600
and clearly state do we want to

00:15:05,199 --> 00:15:10,720
introduce new variable at this point

00:15:07,600 --> 00:15:11,120
or do we want to use an existing value

00:15:10,720 --> 00:15:14,720
and

00:15:11,120 --> 00:15:17,040
com perform a comparison at this point

00:15:14,720 --> 00:15:18,160
other languages distinguish based on a

00:15:17,040 --> 00:15:20,639
spelling

00:15:18,160 --> 00:15:22,800
if we use an all lowercase pi for

00:15:20,639 --> 00:15:23,920
instance that means that we want to bind

00:15:22,800 --> 00:15:27,519
it to the value of

00:15:23,920 --> 00:15:29,600
x whereas using a capital p in pi

00:15:27,519 --> 00:15:33,519
means that we want to use the existing

00:15:29,600 --> 00:15:36,320
value and do a comparison instead

00:15:33,519 --> 00:15:37,279
another approach is to just find local

00:15:36,320 --> 00:15:40,320
names

00:15:37,279 --> 00:15:41,360
and say that if pi as such it's just a

00:15:40,320 --> 00:15:44,240
local variable

00:15:41,360 --> 00:15:45,199
we bind it to the veil a leota x has had

00:15:44,240 --> 00:15:48,880
a point

00:15:45,199 --> 00:15:51,519
whereas if we write math.pi

00:15:48,880 --> 00:15:55,279
what we mean is to use the value that's

00:15:51,519 --> 00:15:56,800
provided by this external symbol

00:15:55,279 --> 00:15:59,920
by a symbol that's from a different

00:15:56,800 --> 00:16:02,160
module or namespace or whatever

00:15:59,920 --> 00:16:04,320
and finally we could just say we make

00:16:02,160 --> 00:16:07,040
all names binding targets

00:16:04,320 --> 00:16:08,320
so irrespective of whether we write pi

00:16:07,040 --> 00:16:11,519
or math.pi

00:16:08,320 --> 00:16:14,880
or anything else we always bind

00:16:11,519 --> 00:16:16,959
that symbol to the value that x has at a

00:16:14,880 --> 00:16:19,440
point

00:16:16,959 --> 00:16:21,040
clearly none of these alternatives is

00:16:19,440 --> 00:16:24,240
really appealing and

00:16:21,040 --> 00:16:24,639
resolves our problem however we believe

00:16:24,240 --> 00:16:27,600
that

00:16:24,639 --> 00:16:28,720
the third here is probably the most

00:16:27,600 --> 00:16:32,079
pythonic

00:16:28,720 --> 00:16:34,160
and the thing that kind of fits best

00:16:32,079 --> 00:16:36,959
into what we already have and think

00:16:34,160 --> 00:16:39,680
about in python

00:16:36,959 --> 00:16:40,160
nonetheless we fully acknowledge that

00:16:39,680 --> 00:16:43,360
this

00:16:40,160 --> 00:16:45,920
kind of issue is still exists

00:16:43,360 --> 00:16:46,800
is unresolved and probably not really

00:16:45,920 --> 00:16:50,079
resolvable

00:16:46,800 --> 00:16:52,720
in the first case

00:16:50,079 --> 00:16:53,680
of a very different nature is issue

00:16:52,720 --> 00:16:56,560
where we have

00:16:53,680 --> 00:16:59,279
two names occurring in the same pattern

00:16:56,560 --> 00:17:02,399
like here in the first case statement

00:16:59,279 --> 00:17:05,600
case x comma x now

00:17:02,399 --> 00:17:07,679
if we approach it naively that is to say

00:17:05,600 --> 00:17:09,039
perhaps a beginner who's not too

00:17:07,679 --> 00:17:12,319
familiar with all of

00:17:09,039 --> 00:17:15,039
python's features and intricacies

00:17:12,319 --> 00:17:15,360
we could fairly assume or rightly assume

00:17:15,039 --> 00:17:18,000
that

00:17:15,360 --> 00:17:18,640
means that we expect a sequence of two

00:17:18,000 --> 00:17:21,520
elements

00:17:18,640 --> 00:17:22,000
which coincide so francis is tuple where

00:17:21,520 --> 00:17:24,000
the first

00:17:22,000 --> 00:17:25,520
and second element in the tuple are

00:17:24,000 --> 00:17:28,559
equal

00:17:25,520 --> 00:17:30,880
however if you know python and

00:17:28,559 --> 00:17:31,679
iterable unpacking you might know that

00:17:30,880 --> 00:17:34,960
if you write

00:17:31,679 --> 00:17:37,360
x comma x equals some expression

00:17:34,960 --> 00:17:39,200
what will happen is that the first

00:17:37,360 --> 00:17:40,880
element of this expression is assigned

00:17:39,200 --> 00:17:42,400
to x first

00:17:40,880 --> 00:17:44,880
and then the second element of this

00:17:42,400 --> 00:17:48,080
expression is assigned to x

00:17:44,880 --> 00:17:49,919
so x only retains the second element of

00:17:48,080 --> 00:17:52,960
the expression provided

00:17:49,919 --> 00:17:55,679
and the first one is just discarded

00:17:52,960 --> 00:17:57,039
which one should we use in this case the

00:17:55,679 --> 00:18:00,000
one that's perhaps

00:17:57,039 --> 00:18:01,120
arguably more readable or obvious or the

00:18:00,000 --> 00:18:03,360
one that close

00:18:01,120 --> 00:18:06,080
more closely follows python's existing

00:18:03,360 --> 00:18:06,080
semantics

00:18:08,320 --> 00:18:13,200
kind of the opposite problem occurs in

00:18:11,200 --> 00:18:16,799
the second case statement here

00:18:13,200 --> 00:18:19,120
where we have 2 or n

00:18:16,799 --> 00:18:20,400
now if we consider that we have a value

00:18:19,120 --> 00:18:22,240
that is 2

00:18:20,400 --> 00:18:23,919
and we look at this pattern then the

00:18:22,240 --> 00:18:26,960
first part is the 2

00:18:23,919 --> 00:18:29,679
equals 2 so this will already work

00:18:26,960 --> 00:18:31,919
and the pattern succeeds the code below

00:18:29,679 --> 00:18:34,960
is executed and run

00:18:31,919 --> 00:18:38,400
however if the value provided is not to

00:18:34,960 --> 00:18:39,600
say 3.5 for instance it will be assigned

00:18:38,400 --> 00:18:43,039
to n

00:18:39,600 --> 00:18:45,039
and then the code will be run below

00:18:43,039 --> 00:18:47,280
the issue that we have in this case is

00:18:45,039 --> 00:18:50,720
that and might be undefined

00:18:47,280 --> 00:18:53,840
if the original value provided was a 2

00:18:50,720 --> 00:18:56,320
otherwise and will be defined and have a

00:18:53,840 --> 00:18:58,640
specific value so

00:18:56,320 --> 00:18:59,760
in this case it's not quite clear what

00:18:58,640 --> 00:19:03,280
do we do

00:18:59,760 --> 00:19:05,440
and could the program below even test

00:19:03,280 --> 00:19:08,320
whether n is defined or not in a

00:19:05,440 --> 00:19:10,640
meaningful way

00:19:08,320 --> 00:19:11,840
our solution to these two problems was

00:19:10,640 --> 00:19:15,039
to say that

00:19:11,840 --> 00:19:18,080
each alternative in a pattern

00:19:15,039 --> 00:19:21,360
needs to bind or define

00:19:18,080 --> 00:19:23,600
exactly the same set of variables

00:19:21,360 --> 00:19:25,520
and each variable needs to be bound

00:19:23,600 --> 00:19:28,480
exactly once

00:19:25,520 --> 00:19:30,000
so the first case segment here is

00:19:28,480 --> 00:19:33,200
actually outlawed because

00:19:30,000 --> 00:19:36,320
we would find two different

00:19:33,200 --> 00:19:39,520
values or kind of of bind to x

00:19:36,320 --> 00:19:43,440
two times whereas the second one

00:19:39,520 --> 00:19:46,000
would be outlaw because either we bind

00:19:43,440 --> 00:19:47,360
no variable at all or we bind to the

00:19:46,000 --> 00:19:50,320
variable n

00:19:47,360 --> 00:19:51,360
whereas both alternatives would have to

00:19:50,320 --> 00:19:54,400
to kind of

00:19:51,360 --> 00:19:55,039
define the same set of variables in

00:19:54,400 --> 00:19:58,960
order

00:19:55,039 --> 00:19:58,960
for this entire thing to make sense

00:19:59,120 --> 00:20:03,520
all in all if we look at names in

00:20:02,320 --> 00:20:06,159
patterns

00:20:03,520 --> 00:20:08,240
we basically came up with these three

00:20:06,159 --> 00:20:11,120
simple rules

00:20:08,240 --> 00:20:13,440
first all simple names are binding

00:20:11,120 --> 00:20:15,760
targets

00:20:13,440 --> 00:20:17,760
attributes on the other hand provide

00:20:15,760 --> 00:20:21,360
value constraints

00:20:17,760 --> 00:20:24,320
this is to say if you write math dot pi

00:20:21,360 --> 00:20:25,120
you use the pi value there in order to

00:20:24,320 --> 00:20:28,159
compare it

00:20:25,120 --> 00:20:29,840
to the value that's given by the subject

00:20:28,159 --> 00:20:33,360
of the pattern matching

00:20:29,840 --> 00:20:35,840
whereas if you just write pi or anything

00:20:33,360 --> 00:20:37,120
it will be bound to whatever value is

00:20:35,840 --> 00:20:40,400
provided

00:20:37,120 --> 00:20:43,520
and finally the set of binding targets

00:20:40,400 --> 00:20:44,320
needs to be deterministic you just look

00:20:43,520 --> 00:20:48,480
at a

00:20:44,320 --> 00:20:52,080
pattern and you know exactly which

00:20:48,480 --> 00:20:55,520
variable will be kind of assigned to

00:20:52,080 --> 00:20:58,720
will have a specific value if this

00:20:55,520 --> 00:20:58,720
pattern succeeds

00:20:59,919 --> 00:21:05,360
for this last part let's briefly express

00:21:02,799 --> 00:21:07,520
a possible vision of the future

00:21:05,360 --> 00:21:09,520
of pad matching in python how this

00:21:07,520 --> 00:21:12,000
language feature might evolve

00:21:09,520 --> 00:21:14,400
and become even more powerful versatile

00:21:12,000 --> 00:21:16,880
and malleable than it already is

00:21:14,400 --> 00:21:18,559
by introducing custom or bespoke

00:21:16,880 --> 00:21:20,480
patterns

00:21:18,559 --> 00:21:22,880
let's all dissolve by remarking that

00:21:20,480 --> 00:21:25,360
objects are complex piece

00:21:22,880 --> 00:21:27,840
there's more than one way to look at the

00:21:25,360 --> 00:21:30,480
structure of an object or to decide

00:21:27,840 --> 00:21:31,919
which attributes properties or fields

00:21:30,480 --> 00:21:35,280
really make up the core

00:21:31,919 --> 00:21:37,200
the essence of an object are important

00:21:35,280 --> 00:21:39,360
that also means that we have more than

00:21:37,200 --> 00:21:41,520
our one obvious way

00:21:39,360 --> 00:21:44,080
how to match a given object due to

00:21:41,520 --> 00:21:46,400
various patterns

00:21:44,080 --> 00:21:48,799
and that leaves us some wiggly room

00:21:46,400 --> 00:21:49,760
where we can try and figure out how can

00:21:48,799 --> 00:21:52,400
we deal

00:21:49,760 --> 00:21:52,960
with these possible different views of

00:21:52,400 --> 00:21:56,400
one

00:21:52,960 --> 00:21:58,400
and the very same object let's look at a

00:21:56,400 --> 00:22:01,039
concrete example

00:21:58,400 --> 00:22:02,960
a complex number is something that we

00:22:01,039 --> 00:22:06,400
can think of like a number

00:22:02,960 --> 00:22:07,840
in in the plane in 2d and we might

00:22:06,400 --> 00:22:11,120
express as you can see

00:22:07,840 --> 00:22:12,159
here on the left hand side say that this

00:22:11,120 --> 00:22:15,919
number here

00:22:12,159 --> 00:22:16,320
is four plus three i but we could also

00:22:15,919 --> 00:22:19,679
say

00:22:16,320 --> 00:22:20,559
that it has a distance of five to the

00:22:19,679 --> 00:22:24,799
origin

00:22:20,559 --> 00:22:28,320
and a angle of uh 33.9 degrees

00:22:24,799 --> 00:22:30,640
so there's two absolutely equivalent

00:22:28,320 --> 00:22:33,440
different ways of expressing the very

00:22:30,640 --> 00:22:36,159
same object or the same number

00:22:33,440 --> 00:22:37,919
and we might want to say in our pattern

00:22:36,159 --> 00:22:40,880
matching that we have a pattern

00:22:37,919 --> 00:22:42,960
for rectangular complex numbers where we

00:22:40,880 --> 00:22:46,000
use the numbers x and y

00:22:42,960 --> 00:22:48,960
for the coordinates or we use a c

00:22:46,000 --> 00:22:50,799
polar version where we have the radius

00:22:48,960 --> 00:22:54,000
the distance to the origin

00:22:50,799 --> 00:22:56,880
together with an angle

00:22:54,000 --> 00:22:57,760
this case however these wrecked and

00:22:56,880 --> 00:23:00,480
polar

00:22:57,760 --> 00:23:02,559
things are not really class classes as

00:23:00,480 --> 00:23:06,240
such but rather views

00:23:02,559 --> 00:23:07,360
of one and the same object and what we

00:23:06,240 --> 00:23:10,400
might introduce

00:23:07,360 --> 00:23:11,520
in future versions is that we let a

00:23:10,400 --> 00:23:14,559
class define

00:23:11,520 --> 00:23:18,480
a specialized match function

00:23:14,559 --> 00:23:19,679
or match method that allows it to decide

00:23:18,480 --> 00:23:22,880
given any

00:23:19,679 --> 00:23:25,520
object as whether it's kind of

00:23:22,880 --> 00:23:26,559
matching that one or not so in this case

00:23:25,520 --> 00:23:29,200
for instance

00:23:26,559 --> 00:23:30,320
c rect might say if i'm given a complex

00:23:29,200 --> 00:23:33,200
number i return

00:23:30,320 --> 00:23:35,360
yes this is kind of something that i

00:23:33,200 --> 00:23:37,280
recognize as that's a rectangular

00:23:35,360 --> 00:23:40,400
complex number

00:23:37,280 --> 00:23:41,279
but i might also be given a com a 2d

00:23:40,400 --> 00:23:44,159
vector

00:23:41,279 --> 00:23:45,039
where i extract these two elements from

00:23:44,159 --> 00:23:47,279
the vector

00:23:45,039 --> 00:23:48,400
create a new complex number number and

00:23:47,279 --> 00:23:51,520
return yes

00:23:48,400 --> 00:23:52,400
i can view this thing as a complex

00:23:51,520 --> 00:23:54,640
number

00:23:52,400 --> 00:23:56,320
that's kind of in in plain and i can

00:23:54,640 --> 00:23:59,360
compete with that

00:23:56,320 --> 00:24:02,080
and if there's anything else i return no

00:23:59,360 --> 00:24:04,559
i don't know what this is or how to deal

00:24:02,080 --> 00:24:08,000
with that and if we

00:24:04,559 --> 00:24:10,400
introduce kind of of this flexibility

00:24:08,000 --> 00:24:11,520
then there's a lot of additional things

00:24:10,400 --> 00:24:14,240
that we can do

00:24:11,520 --> 00:24:15,840
with pattern matching and it really

00:24:14,240 --> 00:24:19,840
becomes a very powerful

00:24:15,840 --> 00:24:19,840
very exciting tool

00:24:20,240 --> 00:24:24,720
pattern matching is based on some very

00:24:22,320 --> 00:24:27,279
simple and obvious principles

00:24:24,720 --> 00:24:29,039
but don't let yourself be fooled by that

00:24:27,279 --> 00:24:31,039
because they quickly lead to a very

00:24:29,039 --> 00:24:34,240
versatile and powerful tool

00:24:31,039 --> 00:24:37,520
that lets you write readable succinct

00:24:34,240 --> 00:24:38,000
and efficient code of course using that

00:24:37,520 --> 00:24:41,120
tool

00:24:38,000 --> 00:24:42,000
can become arbitrary complex too the

00:24:41,120 --> 00:24:44,559
real trick

00:24:42,000 --> 00:24:46,640
of course is how to fit pattern matching

00:24:44,559 --> 00:24:48,559
neatly into python and its existing

00:24:46,640 --> 00:24:51,120
culture

00:24:48,559 --> 00:24:53,039
i hope this presentation was able to

00:24:51,120 --> 00:24:53,760
give you some glimpse into the design

00:24:53,039 --> 00:24:56,320
process

00:24:53,760 --> 00:24:58,559
that led to the pattern matching feature

00:24:56,320 --> 00:25:00,960
coming to python 3.10

00:24:58,559 --> 00:25:03,120
some of the involved trade-offs but also

00:25:00,960 --> 00:25:05,200
some of the possibilities it opens up

00:25:03,120 --> 00:25:07,039
for future application development in

00:25:05,200 --> 00:25:09,600
python

00:25:07,039 --> 00:25:11,679
and with that we come to the end of our

00:25:09,600 --> 00:25:15,840
journey tonight

00:25:11,679 --> 00:25:15,840
thank you

00:26:19,440 --> 00:26:21,520

YouTube URL: https://www.youtube.com/watch?v=NYUXNRswe6k


