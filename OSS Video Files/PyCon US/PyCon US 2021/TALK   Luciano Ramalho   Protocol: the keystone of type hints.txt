Title: TALK   Luciano Ramalho   Protocol: the keystone of type hints
Publication date: 2021-05-30
Playlist: PyCon US 2021
Description: 
	The static type system supporting type hints in Python is becoming more expressive with each new PEP, but PEP 544--Protocols: Structural subtyping (static duck typing) is the most important enhancement since type hints were first introduced. The typing.Protocol special class lets you define types in terms of the interface implemented by objects, regardless of type hierarchies, in the spirit of duck typing--but in a way that can be verified by static type checkers and IDEs.

Without typing.Protocol, it was impossible to correctly annotate many APIs considered Pythonic, including many functions in the standard library itself. In this talk you will learn the concepts and benefits of static duck typing, through actual examples of increasing complexity taken from type hints of standard library functions in the official typeshed project.

Slides: https://speakerdeck.com/ramalho/protocol-keystone-of-python-type-hints
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:14,080 --> 00:00:18,160
hello everyone

00:00:15,759 --> 00:00:19,039
my name is luciano jamalio and i'm here

00:00:18,160 --> 00:00:21,359
to present

00:00:19,039 --> 00:00:24,560
a typing protocol the keystone of

00:00:21,359 --> 00:00:26,480
python's static type system

00:00:24,560 --> 00:00:28,400
first of all i want to thank you for

00:00:26,480 --> 00:00:32,000
being for watching this

00:00:28,400 --> 00:00:34,800
i want to thank the pycon organizers for

00:00:32,000 --> 00:00:35,200
organizing this great conference and for

00:00:34,800 --> 00:00:38,160
i

00:00:35,200 --> 00:00:39,520
also want to thank thoughtworks my

00:00:38,160 --> 00:00:43,280
employer

00:00:39,520 --> 00:00:46,000
who is sponsoring me as i prepare and

00:00:43,280 --> 00:00:48,320
deliver this talk

00:00:46,000 --> 00:00:50,000
so you may know me as the author of

00:00:48,320 --> 00:00:52,079
fluent python

00:00:50,000 --> 00:00:55,120
the first edition was published in nine

00:00:52,079 --> 00:00:58,399
languages i'm super happy about that

00:00:55,120 --> 00:01:01,199
and i am finishing the second edition

00:00:58,399 --> 00:01:02,320
it has more than 100 pages about type

00:01:01,199 --> 00:01:04,720
hints

00:01:02,320 --> 00:01:06,479
including lots of annotated examples

00:01:04,720 --> 00:01:09,280
about two-thirds of the examples in the

00:01:06,479 --> 00:01:11,840
book are annotated

00:01:09,280 --> 00:01:13,520
there is new async await content the

00:01:11,840 --> 00:01:15,600
draft is already available

00:01:13,520 --> 00:01:17,280
in the o'reilly learning platform and

00:01:15,600 --> 00:01:20,400
the print book will be available

00:01:17,280 --> 00:01:22,159
at the end of the year so in this talk

00:01:20,400 --> 00:01:26,159
we are going to be learning about

00:01:22,159 --> 00:01:27,119
protocols and also understanding type

00:01:26,159 --> 00:01:30,720
shed

00:01:27,119 --> 00:01:33,920
so type shed is a repository in the

00:01:30,720 --> 00:01:36,799
python organization on github that has

00:01:33,920 --> 00:01:38,079
stub files stub files are files that

00:01:36,799 --> 00:01:40,640
have only

00:01:38,079 --> 00:01:42,240
type hints for functions that are

00:01:40,640 --> 00:01:44,560
defined elsewhere

00:01:42,240 --> 00:01:47,280
in the case of type sheds the main

00:01:44,560 --> 00:01:49,840
mission of type shed is to maintain

00:01:47,280 --> 00:01:52,479
the annotations the type hints for the

00:01:49,840 --> 00:01:55,680
functions in the python standard library

00:01:52,479 --> 00:01:59,439
okay and as i was studying this subject

00:01:55,680 --> 00:02:02,560
uh to write chapter eight of my book

00:01:59,439 --> 00:02:04,640
i found this bug which then i helped fix

00:02:02,560 --> 00:02:06,320
and while doing it i learned a lot about

00:02:04,640 --> 00:02:06,960
protocols and that's what i'm gonna

00:02:06,320 --> 00:02:09,840
share

00:02:06,960 --> 00:02:12,479
with you but first let's talk about some

00:02:09,840 --> 00:02:12,479
principles

00:02:13,280 --> 00:02:16,959
i guess you should all be familiar with

00:02:15,280 --> 00:02:18,480
the concepts of static typing and

00:02:16,959 --> 00:02:21,520
dynamic typing

00:02:18,480 --> 00:02:24,879
and this actually has to do with when

00:02:21,520 --> 00:02:26,400
type checks happen instead static typing

00:02:24,879 --> 00:02:29,120
is designed to allow

00:02:26,400 --> 00:02:31,599
static checking that is a tool like a

00:02:29,120 --> 00:02:35,280
compile the front end of a compiler

00:02:31,599 --> 00:02:37,519
or a linter or a standalone type checker

00:02:35,280 --> 00:02:38,080
like my pi can look at the source code

00:02:37,519 --> 00:02:40,879
and and

00:02:38,080 --> 00:02:41,840
and find type errors without running the

00:02:40,879 --> 00:02:45,280
program

00:02:41,840 --> 00:02:48,000
so that's what static typing allows

00:02:45,280 --> 00:02:48,400
dynamic typing on the other hand is when

00:02:48,000 --> 00:02:50,480
the

00:02:48,400 --> 00:02:52,239
the type checking only happens at

00:02:50,480 --> 00:02:54,800
runtime

00:02:52,239 --> 00:02:57,120
so it has the downside that you want to

00:02:54,800 --> 00:02:59,680
catch bugs later but it has but it also

00:02:57,120 --> 00:03:04,720
provides a lot of flexibility and it

00:02:59,680 --> 00:03:07,920
also makes languages easier to learn

00:03:04,720 --> 00:03:11,040
another dimension is that

00:03:07,920 --> 00:03:15,200
issue of duck typing so

00:03:11,040 --> 00:03:16,560
wikipedia mentions this message by alex

00:03:15,200 --> 00:03:19,599
martelly

00:03:16,560 --> 00:03:23,280
in the uh python maiming lists

00:03:19,599 --> 00:03:25,360
in which he wrote in the year 2000 that

00:03:23,280 --> 00:03:27,599
you shouldn't check whether an object is

00:03:25,360 --> 00:03:29,360
a duck but whether it quarks like a duck

00:03:27,599 --> 00:03:31,599
or walks like a duck

00:03:29,360 --> 00:03:32,799
depending on what subset of duck like

00:03:31,599 --> 00:03:36,159
behavior you need

00:03:32,799 --> 00:03:38,000
the subset here is key when you're doing

00:03:36,159 --> 00:03:39,599
duct typing you're only interested in

00:03:38,000 --> 00:03:42,720
that particular method on

00:03:39,599 --> 00:03:43,200
or those particular few methods that you

00:03:42,720 --> 00:03:46,640
need

00:03:43,200 --> 00:03:48,239
to operate on the object right now you

00:03:46,640 --> 00:03:49,519
don't care about the whole interface of

00:03:48,239 --> 00:03:51,440
the object only

00:03:49,519 --> 00:03:54,080
about the behaviors that are relevant to

00:03:51,440 --> 00:03:56,560
a particular piece of code

00:03:54,080 --> 00:03:59,120
so that's the idea of duck typing so

00:03:56,560 --> 00:04:02,720
this introduces another dimension

00:03:59,120 --> 00:04:03,360
to our graph which the vertical

00:04:02,720 --> 00:04:05,120
dimension

00:04:03,360 --> 00:04:06,799
the top is structural types and the

00:04:05,120 --> 00:04:08,799
bottom is nominal type so

00:04:06,799 --> 00:04:10,239
structural types means the types are

00:04:08,799 --> 00:04:15,200
defined by the

00:04:10,239 --> 00:04:17,759
by specific methods that the

00:04:15,200 --> 00:04:18,400
objects provide no it doesn't matter

00:04:17,759 --> 00:04:20,400
what the

00:04:18,400 --> 00:04:21,680
class of the object is named what is the

00:04:20,400 --> 00:04:23,919
class hierarchy

00:04:21,680 --> 00:04:25,440
nothing of that is relevant what's

00:04:23,919 --> 00:04:28,160
relevant is the

00:04:25,440 --> 00:04:30,000
the methods that the object provides

00:04:28,160 --> 00:04:33,199
only that

00:04:30,000 --> 00:04:37,759
and the opposite is nominal types

00:04:33,199 --> 00:04:41,199
which is when the type checker

00:04:37,759 --> 00:04:44,320
is looking at declared types

00:04:41,199 --> 00:04:46,320
types that are explicitly declared or

00:04:44,320 --> 00:04:48,000
sometimes inferred but anyway

00:04:46,320 --> 00:04:49,840
there are there there are there appear

00:04:48,000 --> 00:04:52,960
in the source code

00:04:49,840 --> 00:04:53,360
explicitly somewhere uh if this was a

00:04:52,960 --> 00:04:55,759
map

00:04:53,360 --> 00:04:59,600
we we could call them the northeast

00:04:55,759 --> 00:05:02,960
python land in the southwest is javelin

00:04:59,600 --> 00:05:04,800
however there's also the southeast

00:05:02,960 --> 00:05:07,280
which is goose tapping a term also

00:05:04,800 --> 00:05:09,680
invented by alex martelly

00:05:07,280 --> 00:05:11,520
and this is supported by abstract based

00:05:09,680 --> 00:05:13,199
classes in python i don't have time to

00:05:11,520 --> 00:05:15,919
talk about this

00:05:13,199 --> 00:05:17,840
the focus of this talk is static duct

00:05:15,919 --> 00:05:20,960
typing which is when you have

00:05:17,840 --> 00:05:24,720
static checking of structural types

00:05:20,960 --> 00:05:29,919
okay and i didn't make up this name

00:05:24,720 --> 00:05:34,160
the term is actually used in pep544 the

00:05:29,919 --> 00:05:34,160
pep that introduced the protocol

00:05:34,400 --> 00:05:40,800
feature in python and it is also used in

00:05:38,880 --> 00:05:43,199
the go community to talk about

00:05:40,800 --> 00:05:45,120
their type system with interfaces which

00:05:43,199 --> 00:05:48,639
is very similar to what we now have

00:05:45,120 --> 00:05:52,000
in python with protocols okay

00:05:48,639 --> 00:05:54,880
so uh python has a

00:05:52,000 --> 00:05:56,000
very powerful function called max a

00:05:54,880 --> 00:05:59,280
muting function

00:05:56,000 --> 00:06:02,560
probably everybody knows about it it

00:05:59,280 --> 00:06:03,759
accepts a a single argument that can be

00:06:02,560 --> 00:06:05,840
admittable

00:06:03,759 --> 00:06:07,120
and then it will return the largest

00:06:05,840 --> 00:06:09,759
member of the iterable

00:06:07,120 --> 00:06:10,319
or you can pass it several arguments and

00:06:09,759 --> 00:06:12,319
then we

00:06:10,319 --> 00:06:14,160
will give you the largest of those

00:06:12,319 --> 00:06:17,520
arguments

00:06:14,160 --> 00:06:19,360
there are other optional arguments that

00:06:17,520 --> 00:06:22,720
you can pass

00:06:19,360 --> 00:06:23,520
but we don't have time to talk about

00:06:22,720 --> 00:06:27,039
that

00:06:23,520 --> 00:06:30,160
let's consider

00:06:27,039 --> 00:06:32,880
a simplified max or a simplified

00:06:30,160 --> 00:06:34,080
usage of max where i only pass two

00:06:32,880 --> 00:06:38,639
arguments

00:06:34,080 --> 00:06:41,600
okay so and but this even this is

00:06:38,639 --> 00:06:42,400
difficult to annotate uh with type hints

00:06:41,600 --> 00:06:46,000
because

00:06:42,400 --> 00:06:47,039
you have floats as the arguments the

00:06:46,000 --> 00:06:48,639
second example is

00:06:47,039 --> 00:06:50,800
integers the third example is two

00:06:48,639 --> 00:06:53,919
fractions the fourth example is two

00:06:50,800 --> 00:06:57,599
strings and then lists and then

00:06:53,919 --> 00:07:01,039
sets and each time

00:06:57,599 --> 00:07:04,800
the result has to do with how those

00:07:01,039 --> 00:07:08,000
objects of the of the type compare right

00:07:04,800 --> 00:07:11,039
and the the issue

00:07:08,000 --> 00:07:14,560
that started this story for me

00:07:11,039 --> 00:07:18,800
was that uh somebody reported

00:07:14,560 --> 00:07:20,400
uh this issue on my pie

00:07:18,800 --> 00:07:22,800
and the issue was that this person

00:07:20,400 --> 00:07:24,479
declared the variable tops in the middle

00:07:22,800 --> 00:07:27,120
of his code there

00:07:24,479 --> 00:07:28,560
the variable top of of type optional

00:07:27,120 --> 00:07:31,039
inks

00:07:28,560 --> 00:07:32,160
which meant that it could be either an 8

00:07:31,039 --> 00:07:35,120
or

00:07:32,160 --> 00:07:36,960
an or none and then he assigned none to

00:07:35,120 --> 00:07:40,240
it and then he called prince

00:07:36,960 --> 00:07:43,120
okay that print max 5 top

00:07:40,240 --> 00:07:43,919
will fail because python cannot compare

00:07:43,120 --> 00:07:48,240
five with them

00:07:43,919 --> 00:07:50,160
with none so that fails at runtime

00:07:48,240 --> 00:07:52,000
but the issue was filed on my pie

00:07:50,160 --> 00:07:55,280
because the the

00:07:52,000 --> 00:07:58,080
the poster wanted would like for my pi

00:07:55,280 --> 00:07:58,639
to warn about a problem like that and

00:07:58,080 --> 00:08:01,599
then

00:07:58,639 --> 00:08:03,520
jelly zeus who is one of the biggest

00:08:01,599 --> 00:08:05,919
contributors to type shed

00:08:03,520 --> 00:08:07,599
commented that this was not really a my

00:08:05,919 --> 00:08:10,639
pi problem but more a type

00:08:07,599 --> 00:08:13,759
type shared problem because

00:08:10,639 --> 00:08:16,240
on type shed the annotation for max

00:08:13,759 --> 00:08:17,360
was to open at this at the time we

00:08:16,240 --> 00:08:19,199
basically accepted

00:08:17,360 --> 00:08:21,120
arguments of type any which could be

00:08:19,199 --> 00:08:23,840
anything right

00:08:21,120 --> 00:08:25,280
so uh i'm gonna develop a solution to

00:08:23,840 --> 00:08:27,120
this problem the solution that i

00:08:25,280 --> 00:08:28,800
eventually presented

00:08:27,120 --> 00:08:30,720
and i'm going to show you but we're

00:08:28,800 --> 00:08:31,199
going to start simple okay let's talk

00:08:30,720 --> 00:08:35,120
about

00:08:31,199 --> 00:08:38,959
numbers first and talking about numbers

00:08:35,120 --> 00:08:38,959
i have these three examples right

00:08:39,279 --> 00:08:45,760
floats integers or fractions

00:08:42,959 --> 00:08:46,240
so how do we do with floats this is the

00:08:45,760 --> 00:08:48,320
most

00:08:46,240 --> 00:08:50,480
the simplest thing that we could do is

00:08:48,320 --> 00:08:51,120
to add annotations to max and here's the

00:08:50,480 --> 00:08:53,839
thing

00:08:51,120 --> 00:08:54,959
max in the in the in the standard

00:08:53,839 --> 00:08:57,760
library is written in

00:08:54,959 --> 00:08:59,760
c i wrote a version in python this is

00:08:57,760 --> 00:09:02,080
just the first iteration then it's it

00:08:59,760 --> 00:09:03,760
has more code to deal with all the cases

00:09:02,080 --> 00:09:05,440
that max handles

00:09:03,760 --> 00:09:07,839
and i did that because it was easy for

00:09:05,440 --> 00:09:10,480
me to test and see the corner cases of

00:09:07,839 --> 00:09:12,959
the different types of arguments

00:09:10,480 --> 00:09:13,600
but anyway if i wanted to write a max

00:09:12,959 --> 00:09:16,000
function

00:09:13,600 --> 00:09:17,920
i would annotate you know that delts

00:09:16,000 --> 00:09:18,800
only with floats i would annotate it

00:09:17,920 --> 00:09:22,160
like that

00:09:18,800 --> 00:09:22,640
right a is of type float b is of type

00:09:22,160 --> 00:09:25,680
float

00:09:22,640 --> 00:09:29,040
and the return type is float okay

00:09:25,680 --> 00:09:29,760
and this uh i know i wrote tests and the

00:09:29,040 --> 00:09:33,360
tests

00:09:29,760 --> 00:09:36,880
pass but

00:09:33,360 --> 00:09:39,680
there is a painting issue given this

00:09:36,880 --> 00:09:39,680
example here

00:09:42,240 --> 00:09:48,560
when i analyze it with my pie

00:09:46,320 --> 00:09:49,600
here's the thing my pie doesn't find

00:09:48,560 --> 00:09:51,680
problems with

00:09:49,600 --> 00:09:52,880
my implementations of my max see the

00:09:51,680 --> 00:09:56,640
first line of the

00:09:52,880 --> 00:10:00,560
console at the bottom i i ran my pi

00:09:56,640 --> 00:10:03,600
on my max dot py which is the package

00:10:00,560 --> 00:10:06,800
with my max function and also

00:10:03,600 --> 00:10:08,959
my max test but

00:10:06,800 --> 00:10:10,720
he didn't find any uh my pi didn't find

00:10:08,959 --> 00:10:12,959
any problem but it did find problem with

00:10:10,720 --> 00:10:15,440
this pending dot py because

00:10:12,959 --> 00:10:18,079
the problem here and you if you can see

00:10:15,440 --> 00:10:19,519
it's complaining about line 22 on line

00:10:18,079 --> 00:10:22,399
22 you see

00:10:19,519 --> 00:10:23,519
over there i have result equals it's

00:10:22,399 --> 00:10:27,120
where i call

00:10:23,519 --> 00:10:30,000
result equals my max a

00:10:27,120 --> 00:10:31,279
comma b right and the problem is a and b

00:10:30,000 --> 00:10:33,519
are fractions

00:10:31,279 --> 00:10:34,560
and what my pi is saying is that a

00:10:33,519 --> 00:10:36,640
fraction is not

00:10:34,560 --> 00:10:38,560
compatible with float which is the type

00:10:36,640 --> 00:10:41,920
that i declared in the function

00:10:38,560 --> 00:10:45,600
right so that's

00:10:41,920 --> 00:10:46,640
a problem uh so what is a possible

00:10:45,600 --> 00:10:49,839
solution

00:10:46,640 --> 00:10:52,720
so python has a number

00:10:49,839 --> 00:10:53,920
abc in the standard library since python

00:10:52,720 --> 00:10:56,160
three

00:10:53,920 --> 00:10:58,560
this is actually a misstep i included a

00:10:56,160 --> 00:11:01,120
few mid steps here because i think

00:10:58,560 --> 00:11:03,040
they help you i hope they will help you

00:11:01,120 --> 00:11:06,959
understand a little bit better how

00:11:03,040 --> 00:11:09,200
the pythons static type system works

00:11:06,959 --> 00:11:10,079
so the implementation of this failed

00:11:09,200 --> 00:11:13,440
attempt

00:11:10,079 --> 00:11:15,200
is to use the the number abc from the

00:11:13,440 --> 00:11:16,399
numbers package in the standard library

00:11:15,200 --> 00:11:21,440
to annotate

00:11:16,399 --> 00:11:24,000
their parameters a b and the return type

00:11:21,440 --> 00:11:25,360
and if i do that my pi immediately

00:11:24,000 --> 00:11:28,560
complains

00:11:25,360 --> 00:11:30,399
that i cannot use c on line five

00:11:28,560 --> 00:11:32,959
it's where i do the comparison between a

00:11:30,399 --> 00:11:34,959
and b i cannot use that operand with

00:11:32,959 --> 00:11:37,200
number

00:11:34,959 --> 00:11:39,120
and why not because if you go look at

00:11:37,200 --> 00:11:43,200
the implementation

00:11:39,120 --> 00:11:46,640
or the declaration of the number abc

00:11:43,200 --> 00:11:49,120
in the numbers package it has no methods

00:11:46,640 --> 00:11:49,839
so this is only useful for runtime type

00:11:49,120 --> 00:11:53,440
checking

00:11:49,839 --> 00:11:57,680
using is instance or esub class

00:11:53,440 --> 00:11:59,920
for uh uh

00:11:57,680 --> 00:12:01,279
objects in the standard library and for

00:11:59,920 --> 00:12:02,480
classes in the center library that are

00:12:01,279 --> 00:12:04,399
registered

00:12:02,480 --> 00:12:06,560
as virtual subclasses of number but it

00:12:04,399 --> 00:12:08,079
doesn't work with static typing because

00:12:06,560 --> 00:12:10,240
static typing

00:12:08,079 --> 00:12:11,600
needs to know what operations i can do

00:12:10,240 --> 00:12:14,800
with the object

00:12:11,600 --> 00:12:15,279
given its type if i give if i tell my pi

00:12:14,800 --> 00:12:17,440
that

00:12:15,279 --> 00:12:18,880
an object is of type number it can do

00:12:17,440 --> 00:12:22,399
anything with it

00:12:18,880 --> 00:12:23,200
this is a deep issue and if you want to

00:12:22,399 --> 00:12:25,200
understand the

00:12:23,200 --> 00:12:27,519
the questions around it take a look at

00:12:25,200 --> 00:12:31,120
this issue on my pie with it so

00:12:27,519 --> 00:12:32,000
it's too open four years later it is not

00:12:31,120 --> 00:12:36,959
a number

00:12:32,000 --> 00:12:40,160
okay issue 3186 on my pie is a good read

00:12:36,959 --> 00:12:44,000
to understand the problems around using

00:12:40,160 --> 00:12:45,360
the numbers abcs a second attempt that

00:12:44,000 --> 00:12:47,680
also will not work

00:12:45,360 --> 00:12:48,399
would be to use a numeric union let's

00:12:47,680 --> 00:12:52,000
see how

00:12:48,399 --> 00:12:56,399
that would be and why it doesn't work

00:12:52,000 --> 00:12:59,760
so the idea is in this case on line five

00:12:56,399 --> 00:13:03,040
i declare my own type

00:12:59,760 --> 00:13:05,600
this is a type alias i am telling

00:13:03,040 --> 00:13:06,079
my pi that numeric is the name i'm going

00:13:05,600 --> 00:13:08,160
to give

00:13:06,079 --> 00:13:09,519
to the union of float decimal and

00:13:08,160 --> 00:13:12,240
fraction

00:13:09,519 --> 00:13:13,760
right so anything that's either a float

00:13:12,240 --> 00:13:15,440
a decimal or a fraction will be

00:13:13,760 --> 00:13:19,519
considered a numeric

00:13:15,440 --> 00:13:22,959
so on line 8 i use the numeric

00:13:19,519 --> 00:13:27,920
type alias that i just created and this

00:13:22,959 --> 00:13:30,639
satisfies my pi you see

00:13:27,920 --> 00:13:31,440
because all three of those types

00:13:30,639 --> 00:13:36,399
implement

00:13:31,440 --> 00:13:36,399
the greater than or equal to operator

00:13:36,880 --> 00:13:44,079
so that's fine now the problem is that

00:13:40,480 --> 00:13:46,160
the test doesn't work as expected in

00:13:44,079 --> 00:13:48,160
this example on line 19

00:13:46,160 --> 00:13:50,560
i am passing a and b which are both

00:13:48,160 --> 00:13:52,079
floats and i know that the result will

00:13:50,560 --> 00:13:54,399
be a float because the result will be

00:13:52,079 --> 00:13:56,560
one of them

00:13:54,399 --> 00:13:58,480
so that's how i declare it but then my

00:13:56,560 --> 00:14:00,320
pi tells me that

00:13:58,480 --> 00:14:02,910
i the union of float decimal and

00:14:00,320 --> 00:14:05,120
fraction is not compatible with float

00:14:02,910 --> 00:14:07,120
[Music]

00:14:05,120 --> 00:14:09,279
so the problem is that the return type

00:14:07,120 --> 00:14:13,519
is too broad

00:14:09,279 --> 00:14:16,399
to be useful and

00:14:13,519 --> 00:14:17,360
additionally if for instance in this

00:14:16,399 --> 00:14:19,760
case

00:14:17,360 --> 00:14:20,880
i am passing two fractions and so i know

00:14:19,760 --> 00:14:24,160
that the result will be

00:14:20,880 --> 00:14:28,000
a fraction right however

00:14:24,160 --> 00:14:32,160
if i try on 925 to access the numerator

00:14:28,000 --> 00:14:34,720
my pi complaints that uh

00:14:32,160 --> 00:14:36,320
some of those types in the union don't

00:14:34,720 --> 00:14:38,560
implement numerator

00:14:36,320 --> 00:14:40,959
so it would be incorrect like to try an

00:14:38,560 --> 00:14:43,519
access numerator or denominator

00:14:40,959 --> 00:14:44,959
right and then the second part here is

00:14:43,519 --> 00:14:47,440
if type checking

00:14:44,959 --> 00:14:50,240
type checking is a constant that is only

00:14:47,440 --> 00:14:51,600
true when your program is not running

00:14:50,240 --> 00:14:53,279
it's funny it's something that was

00:14:51,600 --> 00:14:55,760
invented to support

00:14:53,279 --> 00:14:57,199
the static type static type checker so

00:14:55,760 --> 00:14:59,839
the static type checker

00:14:57,199 --> 00:15:00,720
consider this as true when it's reading

00:14:59,839 --> 00:15:03,440
your program

00:15:00,720 --> 00:15:05,600
and then it will evaluate what's inside

00:15:03,440 --> 00:15:06,320
and inside is this review type function

00:15:05,600 --> 00:15:09,920
which is

00:15:06,320 --> 00:15:11,120
also something magical of static type

00:15:09,920 --> 00:15:13,680
checking

00:15:11,120 --> 00:15:15,199
that is a function that my pi knows

00:15:13,680 --> 00:15:17,839
about you don't import it

00:15:15,199 --> 00:15:19,680
anywhere and my pi you you use it for

00:15:17,839 --> 00:15:20,720
debugging basically what's doing there

00:15:19,680 --> 00:15:23,920
it's showing that

00:15:20,720 --> 00:15:27,920
the types of abn results are see

00:15:23,920 --> 00:15:30,399
on the console down the notes in

00:15:27,920 --> 00:15:31,839
in purple the the first one is a

00:15:30,399 --> 00:15:33,199
fraction the second one is a fraction

00:15:31,839 --> 00:15:37,040
the third is a union

00:15:33,199 --> 00:15:40,079
right so it tells you what the types

00:15:37,040 --> 00:15:41,680
are according to the analysis that my pi

00:15:40,079 --> 00:15:45,120
did of your code

00:15:41,680 --> 00:15:49,199
okay so a good solution

00:15:45,120 --> 00:15:52,959
actually to the numeric max

00:15:49,199 --> 00:15:56,560
would be using a restricted type var

00:15:52,959 --> 00:15:57,600
so how does that work so instead of a

00:15:56,560 --> 00:16:00,320
union

00:15:57,600 --> 00:16:02,079
i declare a type var so type var is a

00:16:00,320 --> 00:16:02,959
special class that you import from

00:16:02,079 --> 00:16:05,040
typing

00:16:02,959 --> 00:16:06,800
and then you declare type var and then

00:16:05,040 --> 00:16:08,800
the name of the type of r which is in

00:16:06,800 --> 00:16:11,759
this case number three is a string

00:16:08,800 --> 00:16:14,240
and then afterwards you can list

00:16:11,759 --> 00:16:17,279
different arguments that are the types

00:16:14,240 --> 00:16:18,079
that will be acceptable for this type of

00:16:17,279 --> 00:16:21,519
r

00:16:18,079 --> 00:16:24,880
okay so what happens in this case

00:16:21,519 --> 00:16:28,720
is uh when when uh

00:16:24,880 --> 00:16:31,440
when i declare the arguments of max

00:16:28,720 --> 00:16:32,800
of as being of type number t this is the

00:16:31,440 --> 00:16:36,079
convention to use the t

00:16:32,800 --> 00:16:39,839
at the end for type vars so when i say

00:16:36,079 --> 00:16:42,800
that a b and the result are number t

00:16:39,839 --> 00:16:43,759
and my pi is analyzing a specific call

00:16:42,800 --> 00:16:45,440
of max

00:16:43,759 --> 00:16:46,959
let's say i'm calling max with the

00:16:45,440 --> 00:16:49,279
decimal

00:16:46,959 --> 00:16:50,240
then with the first argument as a

00:16:49,279 --> 00:16:53,279
decimal

00:16:50,240 --> 00:16:56,320
then at that time python or

00:16:53,279 --> 00:16:58,880
my pi will decide that okay

00:16:56,320 --> 00:16:59,519
a decimal is acceptable because it's one

00:16:58,880 --> 00:17:03,199
of the

00:16:59,519 --> 00:17:06,400
types listed in the type of r definition

00:17:03,199 --> 00:17:08,640
and from now on it's going to consider

00:17:06,400 --> 00:17:09,839
the other occurrences of the same

00:17:08,640 --> 00:17:12,959
variable

00:17:09,839 --> 00:17:13,520
in this call the same type variable in

00:17:12,959 --> 00:17:15,679
this call

00:17:13,520 --> 00:17:16,640
will be considered the same as the first

00:17:15,679 --> 00:17:18,640
one so

00:17:16,640 --> 00:17:19,679
b will have to be a decimal and the

00:17:18,640 --> 00:17:23,919
result will be

00:17:19,679 --> 00:17:27,039
assumed to be a decimal as well okay

00:17:23,919 --> 00:17:29,440
so uh this

00:17:27,039 --> 00:17:30,559
works the tests work actually the tests

00:17:29,440 --> 00:17:31,919
have always

00:17:30,559 --> 00:17:33,840
worked the problem with these

00:17:31,919 --> 00:17:37,039
implementations have never been

00:17:33,840 --> 00:17:40,480
the runtime behavior but more

00:17:37,039 --> 00:17:43,520
the problem of type checking and now uh

00:17:40,480 --> 00:17:46,880
type uh my pi is satisfied and shows

00:17:43,520 --> 00:17:50,400
that that you know it correctly

00:17:46,880 --> 00:17:54,320
infers the types of the three variables

00:17:50,400 --> 00:17:59,039
the a b and the result okay so how about

00:17:54,320 --> 00:18:02,000
deck typing all right so

00:17:59,039 --> 00:18:02,480
we need what we did now was using a type

00:18:02,000 --> 00:18:04,640
var

00:18:02,480 --> 00:18:06,559
we were able to solve the problem of max

00:18:04,640 --> 00:18:10,320
with different numeric types

00:18:06,559 --> 00:18:10,320
at least those three numeric types

00:18:10,960 --> 00:18:14,640
there are more numeric track types than

00:18:13,039 --> 00:18:17,919
that for instance

00:18:14,640 --> 00:18:21,360
numpy has lots of other numeric types

00:18:17,919 --> 00:18:24,240
but in addition even in python

00:18:21,360 --> 00:18:25,360
extender library we often use macs with

00:18:24,240 --> 00:18:29,840
strings and with

00:18:25,360 --> 00:18:32,720
lists and sets and so how do we do that

00:18:29,840 --> 00:18:34,480
we need to use a protocol but my first

00:18:32,720 --> 00:18:38,080
attempt to use a protocol

00:18:34,480 --> 00:18:40,320
is also a misstep

00:18:38,080 --> 00:18:42,400
so the first attempt is this but this is

00:18:40,320 --> 00:18:43,120
useful at least to show you the syntax

00:18:42,400 --> 00:18:46,240
of

00:18:43,120 --> 00:18:48,559
creating a protocol so on line 4 there

00:18:46,240 --> 00:18:52,160
you see that i import

00:18:48,559 --> 00:18:52,640
the class i mean i import online when i

00:18:52,160 --> 00:18:56,000
import

00:18:52,640 --> 00:18:58,720
the the class protocol from typing

00:18:56,000 --> 00:19:00,080
and on line 4 i create a subclass of

00:18:58,720 --> 00:19:03,919
that

00:19:00,080 --> 00:19:06,720
and this subclasses i write

00:19:03,919 --> 00:19:08,480
one or more methods protocols usually

00:19:06,720 --> 00:19:10,559
should have few methods and often they

00:19:08,480 --> 00:19:12,799
have only one method

00:19:10,559 --> 00:19:14,320
uh in this case is the then the lt

00:19:12,799 --> 00:19:16,640
method which means

00:19:14,320 --> 00:19:17,440
the last then and there's this

00:19:16,640 --> 00:19:20,240
convention

00:19:17,440 --> 00:19:21,600
when a protocol implements or defines

00:19:20,240 --> 00:19:24,720
only one method

00:19:21,600 --> 00:19:27,840
that you uh call it supports

00:19:24,720 --> 00:19:31,120
that method supports that method name

00:19:27,840 --> 00:19:33,039
so what i'm saying here is the protocol

00:19:31,120 --> 00:19:36,080
supports less than

00:19:33,039 --> 00:19:39,760
is a type that is valid for

00:19:36,080 --> 00:19:43,360
every object that supports

00:19:39,760 --> 00:19:46,480
that implements that then the lt method

00:19:43,360 --> 00:19:51,200
with that signature returning a boolean

00:19:46,480 --> 00:19:54,720
okay and so this is how you declare

00:19:51,200 --> 00:19:57,360
a protocol oh you see those

00:19:54,720 --> 00:19:58,320
ellipses the the three dots after the

00:19:57,360 --> 00:20:00,400
bull

00:19:58,320 --> 00:20:01,919
that's where the body of the method

00:20:00,400 --> 00:20:03,679
would be but you don't specify the

00:20:01,919 --> 00:20:05,440
method this is kind of kind of like an

00:20:03,679 --> 00:20:09,039
abstract

00:20:05,440 --> 00:20:13,200
method right so instead of using paths

00:20:09,039 --> 00:20:15,919
the convention on in

00:20:13,200 --> 00:20:17,039
in the static type system is to use

00:20:15,919 --> 00:20:19,679
three dots

00:20:17,039 --> 00:20:20,880
which is the ellipsis construct of

00:20:19,679 --> 00:20:23,520
python

00:20:20,880 --> 00:20:25,760
so that's syntactically valid and it

00:20:23,520 --> 00:20:27,600
means

00:20:25,760 --> 00:20:29,120
you know whatever it doesn't matter what

00:20:27,600 --> 00:20:31,600
the body is the only

00:20:29,120 --> 00:20:32,640
thing that matters is the signature of

00:20:31,600 --> 00:20:35,760
the method

00:20:32,640 --> 00:20:36,559
okay and so now i declare the function

00:20:35,760 --> 00:20:39,679
like that

00:20:36,559 --> 00:20:41,280
so a is anything that supports less than

00:20:39,679 --> 00:20:42,799
b is anything that supports less than

00:20:41,280 --> 00:20:43,919
and the result will be something that

00:20:42,799 --> 00:20:46,480
supports less than

00:20:43,919 --> 00:20:49,120
as well i have to do a change in the

00:20:46,480 --> 00:20:53,360
body of the function because

00:20:49,120 --> 00:20:56,159
before i was using if a greater than and

00:20:53,360 --> 00:20:58,080
greater than or equal to b but what i

00:20:56,159 --> 00:21:00,320
just said

00:20:58,080 --> 00:21:02,960
was that support less than means to

00:21:00,320 --> 00:21:05,360
implement the less than operator

00:21:02,960 --> 00:21:06,799
and why did i pick that one it was

00:21:05,360 --> 00:21:07,679
because i did some research and i

00:21:06,799 --> 00:21:10,640
discovered that

00:21:07,679 --> 00:21:11,679
in the python standard library

00:21:10,640 --> 00:21:14,840
everything that

00:21:11,679 --> 00:21:16,000
that does sorting or ordering or

00:21:14,840 --> 00:21:19,919
comparison

00:21:16,000 --> 00:21:22,880
of greater than small as well

00:21:19,919 --> 00:21:23,840
less than or so on they actually use

00:21:22,880 --> 00:21:27,120
less than

00:21:23,840 --> 00:21:29,280
as the core methods the others are

00:21:27,120 --> 00:21:32,559
variations of that

00:21:29,280 --> 00:21:36,159
right so uh

00:21:32,559 --> 00:21:38,320
that's the the one that matters uh

00:21:36,159 --> 00:21:40,400
but anyway since i declare supports land

00:21:38,320 --> 00:21:44,000
to implement only that

00:21:40,400 --> 00:21:47,200
i have to uh

00:21:44,000 --> 00:21:50,559
only use that inside the body of the

00:21:47,200 --> 00:21:54,159
of the max function on line nine

00:21:50,559 --> 00:21:57,840
right and so now

00:21:54,159 --> 00:22:00,880
uh my pi uh the test path and my pi

00:21:57,840 --> 00:22:03,919
also likes my tests and my

00:22:00,880 --> 00:22:05,039
package and no problem the problem is

00:22:03,919 --> 00:22:09,039
when i use it

00:22:05,039 --> 00:22:11,360
so the problem when i use it and here i

00:22:09,039 --> 00:22:13,600
the errors are about two different tests

00:22:11,360 --> 00:22:16,960
but if you look at the code on the top

00:22:13,600 --> 00:22:18,640
left here on the top right what we have

00:22:16,960 --> 00:22:22,480
is

00:22:18,640 --> 00:22:25,520
uh online uh

00:22:22,480 --> 00:22:29,600
38 i try to take the result

00:22:25,520 --> 00:22:31,600
and call upper on it i i know

00:22:29,600 --> 00:22:33,200
it will have upper because i passed two

00:22:31,600 --> 00:22:34,080
strings so the result will be one of

00:22:33,200 --> 00:22:36,559
those strings

00:22:34,080 --> 00:22:37,919
but since i declared the result type as

00:22:36,559 --> 00:22:40,400
supports less than

00:22:37,919 --> 00:22:42,960
my pi doesn't accept that i use the

00:22:40,400 --> 00:22:45,440
upper method on the result

00:22:42,960 --> 00:22:46,080
okay so that's the problem and now

00:22:45,440 --> 00:22:49,360
finally

00:22:46,080 --> 00:22:51,360
we come to the solution

00:22:49,360 --> 00:22:52,880
so the solution is to use a protocol

00:22:51,360 --> 00:22:56,640
plus a bound

00:22:52,880 --> 00:22:58,559
type var and that's why we had the tour

00:22:56,640 --> 00:22:59,120
to talk about typewires before and we

00:22:58,559 --> 00:23:01,200
also had

00:22:59,120 --> 00:23:02,799
the tour to talk about protocol just now

00:23:01,200 --> 00:23:03,840
because the combination of those two

00:23:02,799 --> 00:23:06,640
things

00:23:03,840 --> 00:23:08,159
brings us the solution so the the

00:23:06,640 --> 00:23:11,679
protocol definition is

00:23:08,159 --> 00:23:14,960
like before the type of r here is

00:23:11,679 --> 00:23:18,799
new the type bar here uses

00:23:14,960 --> 00:23:21,360
bounds equals support less than

00:23:18,799 --> 00:23:22,000
so that's different from the other one

00:23:21,360 --> 00:23:25,280
the other one

00:23:22,000 --> 00:23:26,320
was the type var had a had several

00:23:25,280 --> 00:23:28,799
arguments

00:23:26,320 --> 00:23:30,960
it was called the restricted type var so

00:23:28,799 --> 00:23:34,000
it was restricted to be one of those

00:23:30,960 --> 00:23:35,360
types in this case this is called a

00:23:34,000 --> 00:23:38,559
bounded

00:23:35,360 --> 00:23:40,960
type var a bounded type var can have any

00:23:38,559 --> 00:23:44,720
type that is

00:23:40,960 --> 00:23:48,240
that type or a subtype of that okay

00:23:44,720 --> 00:23:52,080
and when python when my pi analyzes it

00:23:48,240 --> 00:23:55,760
it keeps the original type

00:23:52,080 --> 00:23:56,320
so for instance when let's say i pass to

00:23:55,760 --> 00:24:00,480
max

00:23:56,320 --> 00:24:05,039
here uh the first argument is a string

00:24:00,480 --> 00:24:08,159
and then so uh my pi will say okay

00:24:05,039 --> 00:24:10,320
less t is defined like that a string is

00:24:08,159 --> 00:24:11,840
acceptable because it's a subtype of

00:24:10,320 --> 00:24:14,559
supports less than because

00:24:11,840 --> 00:24:16,240
strings do implement the then the lt

00:24:14,559 --> 00:24:19,520
method

00:24:16,240 --> 00:24:22,799
and then now the the variable is

00:24:19,520 --> 00:24:24,559
bound to string which means it will

00:24:22,799 --> 00:24:25,360
understand that b has to be a string and

00:24:24,559 --> 00:24:28,000
the result

00:24:25,360 --> 00:24:28,559
will be a string as well and that means

00:24:28,000 --> 00:24:32,400
that

00:24:28,559 --> 00:24:33,679
the test pass my pi is happy everything

00:24:32,400 --> 00:24:37,440
works

00:24:33,679 --> 00:24:40,240
the actual solution of max is a bit

00:24:37,440 --> 00:24:41,919
more complicated because of all of the

00:24:40,240 --> 00:24:44,480
variations in the in

00:24:41,919 --> 00:24:45,520
in the signatures the combination of the

00:24:44,480 --> 00:24:48,880
different types

00:24:45,520 --> 00:24:52,000
and the different signatures

00:24:48,880 --> 00:24:53,600
force force does to write six overloads

00:24:52,000 --> 00:24:54,720
i don't have time to explain this but

00:24:53,600 --> 00:24:58,840
this is basically

00:24:54,720 --> 00:25:01,520
alternative type hints for the same

00:24:58,840 --> 00:25:04,880
function

00:25:01,520 --> 00:25:07,760
it turned out that supports

00:25:04,880 --> 00:25:08,960
less than was useful it's now used in

00:25:07,760 --> 00:25:12,240
the

00:25:08,960 --> 00:25:12,240
type hints for 14

00:25:12,720 --> 00:25:20,240
functions in the standard library

00:25:15,919 --> 00:25:23,360
and to wrap up so this is why i consider

00:25:20,240 --> 00:25:25,039
protocols uh the keystone

00:25:23,360 --> 00:25:27,679
of python's type hints because as

00:25:25,039 --> 00:25:31,039
initially proposed the type hints

00:25:27,679 --> 00:25:33,039
were okay but limited python to a java

00:25:31,039 --> 00:25:35,279
style of programming

00:25:33,039 --> 00:25:36,799
because they didn't allow us to annotate

00:25:35,279 --> 00:25:40,000
code that used uh

00:25:36,799 --> 00:25:40,320
duck typing and now with par with pap

00:25:40,000 --> 00:25:43,360
four

00:25:40,320 --> 00:25:46,559
five four four i think we have a solid

00:25:43,360 --> 00:25:48,000
and complete and useful uh

00:25:46,559 --> 00:25:49,760
type system of course it's always

00:25:48,000 --> 00:25:51,120
possible to evolve it but now i think

00:25:49,760 --> 00:25:54,880
it's very usable

00:25:51,120 --> 00:25:56,960
okay to finish i'm gonna quote allen k

00:25:54,880 --> 00:25:58,799
who said that i'm not against types but

00:25:56,960 --> 00:26:00,640
i don't know of any type systems that

00:25:58,799 --> 00:26:02,240
aren't a complete pain so i still like

00:26:00,640 --> 00:26:04,080
dynamic typing

00:26:02,240 --> 00:26:05,520
i don't think python's type system is a

00:26:04,080 --> 00:26:07,600
complete pain but

00:26:05,520 --> 00:26:09,279
it is painful sometimes and there are

00:26:07,600 --> 00:26:10,240
things that are very complicated to

00:26:09,279 --> 00:26:11,520
annotate

00:26:10,240 --> 00:26:13,279
and some things that are still

00:26:11,520 --> 00:26:15,440
impossible to annotate because the

00:26:13,279 --> 00:26:16,799
the language is more expressive than the

00:26:15,440 --> 00:26:19,840
type system

00:26:16,799 --> 00:26:23,039
okay so let's please

00:26:19,840 --> 00:26:24,799
embrace the fact that what we have in

00:26:23,039 --> 00:26:27,840
python

00:26:24,799 --> 00:26:28,880
is gradual typing python is not a

00:26:27,840 --> 00:26:30,799
statically typed

00:26:28,880 --> 00:26:32,240
language or a dynamically typed language

00:26:30,799 --> 00:26:34,320
only it's

00:26:32,240 --> 00:26:36,720
actually a gradually typed language

00:26:34,320 --> 00:26:39,679
which means that we can use as much

00:26:36,720 --> 00:26:40,960
or as little of static type hints as we

00:26:39,679 --> 00:26:43,039
like

00:26:40,960 --> 00:26:45,039
or is make sense in the different

00:26:43,039 --> 00:26:48,559
contexts okay

00:26:45,039 --> 00:26:51,200
and so please let's embrace

00:26:48,559 --> 00:26:53,360
and celebrate the fact that python is a

00:26:51,200 --> 00:26:56,720
gradually typed language

00:26:53,360 --> 00:26:59,440
and let's not try and make every code

00:26:56,720 --> 00:27:01,520
base 100 type check because if we do

00:26:59,440 --> 00:27:04,320
that we are not going to be leveraging

00:27:01,520 --> 00:27:06,000
all the power that python has to offer

00:27:04,320 --> 00:27:08,880
all right

00:27:06,000 --> 00:27:09,440
so thank you very much please get in

00:27:08,880 --> 00:27:14,480
touch

00:27:09,440 --> 00:27:14,480
and we are going to go for q a now thank

00:27:18,840 --> 00:27:21,840
you

00:28:12,640 --> 00:28:14,720

YouTube URL: https://www.youtube.com/watch?v=kDDCKwP7QgQ


