Title: TALK   John Belmonte   Your app is async so take advantage of it for development!
Publication date: 2021-05-30
Playlist: PyCon US 2021
Description: 
	So your Python application is running under asyncio or similar framework-- congratulations! But what does that mean to you? More efficient use of compute resources? Simpler program structure and avoiding callbacks? It should mean even more. Cooperative multitasking opens new doors for inspecting the state of a program at runtime, which has valuable development uses.

This talk covers how Python's async is useful for "development views"-- visualizing and interacting with the state of your running app-- and gives some working examples that run concurrently and don't require intrusive changes to program structure:

remote REPL - open one or more interpreter sessions over HTTP to
inspect and modify internal state of your app while it's running
graphical visualizations - view custom graphical representations of
state remotely from a web browser. These are written alongside the
code being visualized, and have zero overhead when not observed.
Keyboard and mouse input is possible too.
What kind of visualizations? For a Python app embedded in a home robot, these might include a local map of obstacles; display of orientation, speed, power usage; low res. camera or depth camera feeds; representations of internal state machines deciding behavior; etc.

Slides: https://docs.google.com/presentation/d/e/2PACX-1vQqzFgzYqKinBkIBMpe20Jv_6pyYN1iTkKrDrOQRlqoMSBg4SyWQRnkGc0hBgTxQN_UteHdDe_Cge5h/pub
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:14,639 --> 00:00:18,160
wouldn't it be great if

00:00:16,080 --> 00:00:20,160
as developers we could inspect and

00:00:18,160 --> 00:00:23,680
modify internal state

00:00:20,160 --> 00:00:23,680
without pausing our application

00:00:23,920 --> 00:00:27,439
if your app is async this kind of thing

00:00:26,000 --> 00:00:29,039
is already possible

00:00:27,439 --> 00:00:30,640
so let's take advantage of it for

00:00:29,039 --> 00:00:32,239
development

00:00:30,640 --> 00:00:34,160
it's an area that hasn't been explored

00:00:32,239 --> 00:00:36,559
much

00:00:34,160 --> 00:00:39,040
async in the context of python means

00:00:36,559 --> 00:00:42,239
we're using cooperative multitasking

00:00:39,040 --> 00:00:43,840
and typically there's only one os thread

00:00:42,239 --> 00:00:47,440
and you're being careful not to block

00:00:43,840 --> 00:00:49,520
that threat for any length of time

00:00:47,440 --> 00:00:52,000
so let's dive into the land of no

00:00:49,520 --> 00:00:52,000
pausing

00:00:53,920 --> 00:00:59,359
my name is john belmonte and i'm happy

00:00:56,320 --> 00:01:01,039
to present at pycon this year

00:00:59,359 --> 00:01:02,960
i'm someone who likes to talk with my

00:01:01,039 --> 00:01:03,760
hands so i'll be waving this laser

00:01:02,960 --> 00:01:07,520
pointer around

00:01:03,760 --> 00:01:09,360
during the talk i'd also like to

00:01:07,520 --> 00:01:11,840
introduce love it

00:01:09,360 --> 00:01:12,640
love it's a companion robot and that

00:01:11,840 --> 00:01:15,520
project has

00:01:12,640 --> 00:01:18,400
inspired a lot of the tools and methods

00:01:15,520 --> 00:01:20,320
that i'll present in this talk

00:01:18,400 --> 00:01:21,439
it's been developed by a company called

00:01:20,320 --> 00:01:23,439
groovex

00:01:21,439 --> 00:01:27,040
and has been on the market in japan for

00:01:23,439 --> 00:01:28,720
over a year now and not only is python

00:01:27,040 --> 00:01:30,799
running inside the robot but

00:01:28,720 --> 00:01:32,159
it's at the top level of the software

00:01:30,799 --> 00:01:34,640
stack

00:01:32,159 --> 00:01:36,560
and it's in charge of managing all the

00:01:34,640 --> 00:01:37,520
concurrency going on in the robot so all

00:01:36,560 --> 00:01:40,720
the

00:01:37,520 --> 00:01:41,439
sensor inputs and servo outputs deciding

00:01:40,720 --> 00:01:45,200
what

00:01:41,439 --> 00:01:45,200
behaviors to run and things like that

00:01:46,960 --> 00:01:50,799
and this is oreo he's the development

00:01:49,920 --> 00:01:53,600
bot that

00:01:50,799 --> 00:01:55,200
lives at home with me working day to day

00:01:53,600 --> 00:01:55,680
and he's got a nice gig because at the

00:01:55,200 --> 00:01:58,079
end of

00:01:55,680 --> 00:02:00,719
a day of hard work he can relax and play

00:01:58,079 --> 00:02:00,719
with the family

00:02:01,759 --> 00:02:06,000
so most programs have interesting things

00:02:04,240 --> 00:02:09,119
going on inside

00:02:06,000 --> 00:02:12,160
there's probably a lot of state machines

00:02:09,119 --> 00:02:12,160
algorithms happening

00:02:13,599 --> 00:02:18,160
so for a developer it's important to

00:02:16,400 --> 00:02:22,239
understand that state

00:02:18,160 --> 00:02:23,920
and it's used when you're trying to

00:02:22,239 --> 00:02:25,680
debug a problem

00:02:23,920 --> 00:02:29,360
and also when you're just trying to

00:02:25,680 --> 00:02:31,680
iterate and enhance the program

00:02:29,360 --> 00:02:33,360
but we don't we don't always want to

00:02:31,680 --> 00:02:37,840
pause the program in order to

00:02:33,360 --> 00:02:37,840
to do that kind of inspection

00:02:38,000 --> 00:02:42,480
so for example the program might have a

00:02:39,920 --> 00:02:45,680
ui that users are

00:02:42,480 --> 00:02:47,760
actively engaged with or

00:02:45,680 --> 00:02:49,760
it's connected to services that might

00:02:47,760 --> 00:02:51,840
have a

00:02:49,760 --> 00:02:55,760
communication so the service is

00:02:51,840 --> 00:02:55,760
expecting a reply from the application

00:02:56,640 --> 00:03:00,400
or especially for our robot the

00:02:59,040 --> 00:03:03,599
application might have a

00:03:00,400 --> 00:03:05,680
strong connection to the physical world

00:03:03,599 --> 00:03:07,599
so the robot has all these light and

00:03:05,680 --> 00:03:09,760
sound sensors

00:03:07,599 --> 00:03:10,640
and it's got a physical body that has to

00:03:09,760 --> 00:03:13,760
deal with

00:03:10,640 --> 00:03:15,120
inertia and momentum so it's not always

00:03:13,760 --> 00:03:17,280
convenient to just

00:03:15,120 --> 00:03:19,360
say stop the world because we want to

00:03:17,280 --> 00:03:23,040
inspect our program

00:03:19,360 --> 00:03:26,080
and what we want isn't always available

00:03:23,040 --> 00:03:29,760
developer display so how do we

00:03:26,080 --> 00:03:32,879
go about surfacing a display like that

00:03:29,760 --> 00:03:33,920
here are a few approaches so you've got

00:03:32,879 --> 00:03:36,959
your

00:03:33,920 --> 00:03:38,879
incredible and awesome application

00:03:36,959 --> 00:03:40,480
one obvious way to is to do something

00:03:38,879 --> 00:03:42,799
with the console

00:03:40,480 --> 00:03:44,720
and the console can actually display

00:03:42,799 --> 00:03:48,400
some simple graphics if you use a

00:03:44,720 --> 00:03:52,000
library like and curses

00:03:48,400 --> 00:03:54,959
so this works but it's not always easy

00:03:52,000 --> 00:03:56,799
to get access to the console

00:03:54,959 --> 00:04:00,560
and the console might be used for other

00:03:56,799 --> 00:04:02,640
things like like logging

00:04:00,560 --> 00:04:04,159
well if your application has a gui how

00:04:02,640 --> 00:04:06,560
about making

00:04:04,159 --> 00:04:08,720
kind of a hidden developer view as part

00:04:06,560 --> 00:04:13,040
of that gui

00:04:08,720 --> 00:04:16,160
so this this will work gui apis are

00:04:13,040 --> 00:04:18,479
often complex however and

00:04:16,160 --> 00:04:19,519
not all applications will have a gui

00:04:18,479 --> 00:04:21,199
some embedded

00:04:19,519 --> 00:04:23,600
applications might not even have a

00:04:21,199 --> 00:04:23,600
display

00:04:26,160 --> 00:04:31,199
so we're starting to assemble kind of uh

00:04:29,520 --> 00:04:33,280
some desirable properties we're looking

00:04:31,199 --> 00:04:36,320
for it'd be nice if we can do

00:04:33,280 --> 00:04:39,840
uh remote access ahead and had a nice

00:04:36,320 --> 00:04:42,160
graphical display and if this developer

00:04:39,840 --> 00:04:43,280
viewer decoupled from the normal

00:04:42,160 --> 00:04:46,560
operation of the

00:04:43,280 --> 00:04:48,960
console and the gui so basically

00:04:46,560 --> 00:04:51,520
decoupled from whatever else is going on

00:04:48,960 --> 00:04:51,520
in the program

00:04:52,160 --> 00:04:58,800
so let's explore some avenues in detail

00:04:56,000 --> 00:05:00,639
so we have a read eval print loop which

00:04:58,800 --> 00:05:03,840
everyone's familiar with

00:05:00,639 --> 00:05:07,840
and this is nice let's say i've got my

00:05:03,840 --> 00:05:10,639
my robot and i want to

00:05:07,840 --> 00:05:11,199
check the imu sensor to get a reading on

00:05:10,639 --> 00:05:15,039
the

00:05:11,199 --> 00:05:16,639
tilt of the robot so that works nicely

00:05:15,039 --> 00:05:18,240
and i could use the repo not only to

00:05:16,639 --> 00:05:22,080
inspect state but also to

00:05:18,240 --> 00:05:25,600
modify the program so here i'm

00:05:22,080 --> 00:05:29,680
changing the mode of the eyelid

00:05:25,600 --> 00:05:31,520
blinking rebels are nice because

00:05:29,680 --> 00:05:33,440
you can just make these general queries

00:05:31,520 --> 00:05:36,160
it doesn't they don't require

00:05:33,440 --> 00:05:36,720
lots of upfront development and thought

00:05:36,160 --> 00:05:38,080
for

00:05:36,720 --> 00:05:40,080
what you want to display and how you

00:05:38,080 --> 00:05:42,560
want to display it

00:05:40,080 --> 00:05:44,800
but again really we in my case i don't

00:05:42,560 --> 00:05:48,080
want to stop the robot to

00:05:44,800 --> 00:05:49,199
to execute these statements so all right

00:05:48,080 --> 00:05:51,280
let's just wave our hand

00:05:49,199 --> 00:05:54,479
and say we can have a repo like this

00:05:51,280 --> 00:05:54,479
without pausing the program

00:05:55,600 --> 00:05:59,039
but there's still something missing uh

00:05:57,520 --> 00:06:01,440
we'd like to be able to

00:05:59,039 --> 00:06:02,800
connect to this ruffle on demand

00:06:01,440 --> 00:06:05,759
depending on the situation

00:06:02,800 --> 00:06:06,240
say the robot is suddenly exhibiting a

00:06:05,759 --> 00:06:09,440
bug

00:06:06,240 --> 00:06:12,800
and now i want to go explore the program

00:06:09,440 --> 00:06:14,000
and see what's going on so what we want

00:06:12,800 --> 00:06:15,759
is a remote access

00:06:14,000 --> 00:06:18,240
so let's say i'm going to use a web

00:06:15,759 --> 00:06:21,600
browser connect to my local device

00:06:18,240 --> 00:06:25,039
and have access to this window

00:06:21,600 --> 00:06:26,639
uh one limitation of repple is it's uh

00:06:25,039 --> 00:06:28,560
it's not going to show us a cust

00:06:26,639 --> 00:06:31,120
customize or visual display

00:06:28,560 --> 00:06:33,360
so let's see what we can do as far as

00:06:31,120 --> 00:06:33,360
that

00:06:33,600 --> 00:06:37,199
the print function is actually something

00:06:35,759 --> 00:06:42,000
i use often to

00:06:37,199 --> 00:06:43,840
surface internal states in real time

00:06:42,000 --> 00:06:46,000
and i'll show an example of how i do

00:06:43,840 --> 00:06:49,599
this for a certain state machine

00:06:46,000 --> 00:06:52,639
that's controlling the the servo

00:06:49,599 --> 00:06:53,440
for inserting it and instruc extracting

00:06:52,639 --> 00:06:55,360
the real

00:06:53,440 --> 00:06:57,680
rear wheel uh this happens kind of like

00:06:55,360 --> 00:06:59,440
a landing gear on a plane

00:06:57,680 --> 00:07:01,199
and we do this so that when you pick up

00:06:59,440 --> 00:07:04,400
and hug or hug the robot

00:07:01,199 --> 00:07:05,520
the wheels won't be in the way so we

00:07:04,400 --> 00:07:08,240
want to decide

00:07:05,520 --> 00:07:10,000
when to have the servo on or off we

00:07:08,240 --> 00:07:13,599
don't want the servo on all the time

00:07:10,000 --> 00:07:13,599
because it will exhaust the battery

00:07:15,440 --> 00:07:21,039
so we've got a leg state class

00:07:18,800 --> 00:07:22,240
and what i would do in this case is i

00:07:21,039 --> 00:07:25,039
would drop a print

00:07:22,240 --> 00:07:27,360
into the update call of the state

00:07:25,039 --> 00:07:27,360
machine

00:07:28,400 --> 00:07:31,520
so for example i've got my state machine

00:07:30,800 --> 00:07:35,759
inputs

00:07:31,520 --> 00:07:35,759
and internal variables and output

00:07:36,240 --> 00:07:40,240
and this is what i would see on the

00:07:37,599 --> 00:07:41,360
console now if the update is called 30

00:07:40,240 --> 00:07:45,199
times a second

00:07:41,360 --> 00:07:47,360
this will be scrolling wildly so

00:07:45,199 --> 00:07:50,000
in that case i'll use this trick of the

00:07:47,360 --> 00:07:51,440
end parameter of the print function

00:07:50,000 --> 00:07:53,120
and you can do some simple cursor

00:07:51,440 --> 00:07:54,160
control so here i'm doing a carriage

00:07:53,120 --> 00:07:56,240
return

00:07:54,160 --> 00:07:57,759
and so after this print happens we send

00:07:56,240 --> 00:07:58,000
the cursor back to the beginning of the

00:07:57,759 --> 00:08:00,160
line

00:07:58,000 --> 00:08:01,599
for the next print so then you get just

00:08:00,160 --> 00:08:03,199
one nice

00:08:01,599 --> 00:08:05,599
continuously updating line on your

00:08:03,199 --> 00:08:05,599
console

00:08:06,319 --> 00:08:09,840
so this works well enough everyone knows

00:08:08,240 --> 00:08:13,039
how to use print

00:08:09,840 --> 00:08:14,879
it's quite informal because your

00:08:13,039 --> 00:08:18,319
each developer is deciding on the

00:08:14,879 --> 00:08:20,479
display format they'd like to use

00:08:18,319 --> 00:08:21,840
very importantly it's localized so

00:08:20,479 --> 00:08:24,840
you're putting this print

00:08:21,840 --> 00:08:27,840
very near the code that you're trying to

00:08:24,840 --> 00:08:27,840
display

00:08:28,240 --> 00:08:31,840
and it can be optional so often what i

00:08:30,160 --> 00:08:34,320
do is

00:08:31,840 --> 00:08:35,440
after i'm done developing this code i'll

00:08:34,320 --> 00:08:38,080
comment it out

00:08:35,440 --> 00:08:39,120
and actually merge it into our code base

00:08:38,080 --> 00:08:41,039
because in the future

00:08:39,120 --> 00:08:42,880
another developer might want to

00:08:41,039 --> 00:08:45,040
re-enable the code and

00:08:42,880 --> 00:08:47,600
use use this display to learn about the

00:08:45,040 --> 00:08:47,600
state machine

00:08:50,160 --> 00:08:55,279
so a few drawbacks using print isn't

00:08:53,519 --> 00:08:57,120
this way is not very composable

00:08:55,279 --> 00:08:59,680
because it assumes that it has complete

00:08:57,120 --> 00:09:02,800
control of the console

00:08:59,680 --> 00:09:04,959
and again observers need to get

00:09:02,800 --> 00:09:09,040
the terminal access somehow so how did

00:09:04,959 --> 00:09:10,720
how did they do that

00:09:09,040 --> 00:09:13,200
now let's consider something more

00:09:10,720 --> 00:09:13,200
graphical

00:09:13,600 --> 00:09:20,000
so this is our leg leg visualization

00:09:17,519 --> 00:09:21,440
and it includes a lot of the same

00:09:20,000 --> 00:09:25,519
information i had

00:09:21,440 --> 00:09:27,120
in the print function so here's the

00:09:25,519 --> 00:09:28,959
output of the state machine whether the

00:09:27,120 --> 00:09:32,640
server is on or off

00:09:28,959 --> 00:09:33,920
this white dotted line is the requested

00:09:32,640 --> 00:09:35,839
position of the leg

00:09:33,920 --> 00:09:39,360
and the blue line is the feedback

00:09:35,839 --> 00:09:39,360
position coming from the servo

00:09:39,839 --> 00:09:44,160
but we're able to show since this is a

00:09:41,839 --> 00:09:49,040
rich display even more information

00:09:44,160 --> 00:09:51,120
so this colored bar is telling us when

00:09:49,040 --> 00:09:52,160
the wheel is either kind of in the air

00:09:51,120 --> 00:09:54,000
and unloaded

00:09:52,160 --> 00:09:55,440
and when it's actually starting to push

00:09:54,000 --> 00:09:59,839
against the ground

00:09:55,440 --> 00:09:59,839
and dealing with the forces of gravity

00:10:00,480 --> 00:10:03,680
but we can take this even further and

00:10:02,160 --> 00:10:05,920
say well

00:10:03,680 --> 00:10:08,480
this can be interactive as well so let's

00:10:05,920 --> 00:10:10,959
say i can have a manual control mode

00:10:08,480 --> 00:10:11,839
where i can drag this white dotted line

00:10:10,959 --> 00:10:14,959
and

00:10:11,839 --> 00:10:16,959
set the requested lake position

00:10:14,959 --> 00:10:20,720
and basically tinker with my state

00:10:16,959 --> 00:10:20,720
machine and see how it responds this way

00:10:22,079 --> 00:10:26,720
and in this case as well ideally we'd

00:10:24,720 --> 00:10:27,519
like to have remote access so we can

00:10:26,720 --> 00:10:32,560
just

00:10:27,519 --> 00:10:36,560
pop up this display on demand let's take

00:10:32,560 --> 00:10:36,560
a look at this working in action

00:10:44,880 --> 00:10:48,320
so next i'm going to insert the leg

00:10:46,560 --> 00:10:50,800
again but put my hand in the way to

00:10:48,320 --> 00:10:54,720
interfere with the insertion

00:10:50,800 --> 00:10:54,720
so the state machine enters a stuck mode

00:10:55,120 --> 00:11:02,240
and then eventually it will retry

00:11:00,320 --> 00:11:03,680
next i'll put it into manual control

00:11:02,240 --> 00:11:07,680
mode

00:11:03,680 --> 00:11:07,680
and drag around the white dotted line

00:11:13,200 --> 00:11:16,640
and then release the manual mode

00:11:20,640 --> 00:11:25,760
so this is great but there's

00:11:23,839 --> 00:11:27,279
something we have to consider there with

00:11:25,760 --> 00:11:31,200
this how difficult

00:11:27,279 --> 00:11:31,200
is it to code visualizations like this

00:11:32,959 --> 00:11:40,399
the people coding on our project include

00:11:36,079 --> 00:11:43,440
designers and animators and researchers

00:11:40,399 --> 00:11:46,880
and each person is bringing their own

00:11:43,440 --> 00:11:48,160
experience and insight to the project so

00:11:46,880 --> 00:11:51,600
it's really important that we keep

00:11:48,160 --> 00:11:51,600
development accessible

00:11:53,040 --> 00:11:57,839
so how do we make coding these

00:11:54,399 --> 00:11:57,839
visualizations easy

00:11:58,079 --> 00:12:01,839
well we could do something like this

00:12:00,079 --> 00:12:05,360
we've got our leg state

00:12:01,839 --> 00:12:08,839
class let's have it derived from a

00:12:05,360 --> 00:12:10,079
mix in that provides a one of these web

00:12:08,839 --> 00:12:12,880
views

00:12:10,079 --> 00:12:14,639
and as part of that contract we have to

00:12:12,880 --> 00:12:18,560
implement a draw method that takes

00:12:14,639 --> 00:12:18,560
a graphical context

00:12:18,800 --> 00:12:22,399
so now we're making graphic function

00:12:21,440 --> 00:12:25,760
calls

00:12:22,399 --> 00:12:27,519
and we're accessing some of the local

00:12:25,760 --> 00:12:30,399
attributes of our

00:12:27,519 --> 00:12:30,399
class instance

00:12:33,920 --> 00:12:39,680
so this checks off a lot of the same

00:12:35,680 --> 00:12:42,320
boxes we had with the print function

00:12:39,680 --> 00:12:42,959
it's still fairly simple and it's

00:12:42,320 --> 00:12:45,279
informal

00:12:42,959 --> 00:12:46,320
so each developer decides how they want

00:12:45,279 --> 00:12:49,519
to just

00:12:46,320 --> 00:12:49,519
display the information

00:12:49,680 --> 00:12:53,279
and importantly again it's localized so

00:12:52,639 --> 00:12:56,800
we've got

00:12:53,279 --> 00:13:00,240
our we're using python code to do the

00:12:56,800 --> 00:13:02,079
the draw functions right next to

00:13:00,240 --> 00:13:06,079
the statement machine implementation

00:13:02,079 --> 00:13:07,839
that we're trying to display

00:13:06,079 --> 00:13:09,760
and it's optional because whatever

00:13:07,839 --> 00:13:13,040
infrastructure is ultimately

00:13:09,760 --> 00:13:15,680
calling this draw method can decide

00:13:13,040 --> 00:13:16,639
uh if if the visualization is actually

00:13:15,680 --> 00:13:21,519
being viewed or not

00:13:16,639 --> 00:13:24,160
and so make the call conditionally

00:13:21,519 --> 00:13:25,760
and we get more because this is a rich

00:13:24,160 --> 00:13:27,920
display

00:13:25,760 --> 00:13:30,480
it can be interactive we can access it

00:13:27,920 --> 00:13:30,480
remotely

00:13:33,519 --> 00:13:37,600
there's a subtlety however which is when

00:13:36,399 --> 00:13:40,880
is the draw method

00:13:37,600 --> 00:13:42,880
called because in the print example

00:13:40,880 --> 00:13:44,160
we just put print into the state

00:13:42,880 --> 00:13:47,519
machines update

00:13:44,160 --> 00:13:50,399
method but withdraw we might

00:13:47,519 --> 00:13:50,959
not want to call it as frequently

00:13:50,399 --> 00:13:53,600
because

00:13:50,959 --> 00:13:54,160
it's it might be a little bit heavier

00:13:53,600 --> 00:13:56,320
and

00:13:54,160 --> 00:13:58,399
uh so basically what this means is we

00:13:56,320 --> 00:14:00,240
would like to to decouple this draw

00:13:58,399 --> 00:14:00,839
function from the normal operation of

00:14:00,240 --> 00:14:04,079
our

00:14:00,839 --> 00:14:08,480
program and this is where

00:14:04,079 --> 00:14:08,480
async becomes important

00:14:10,079 --> 00:14:14,160
so how do we leverage async in our

00:14:11,680 --> 00:14:14,160
solution

00:14:15,600 --> 00:14:20,000
it does provide a way to have an

00:14:18,079 --> 00:14:22,240
efficient http server

00:14:20,000 --> 00:14:24,639
and such inside of our application and

00:14:22,240 --> 00:14:27,040
this is important for the remote aspect

00:14:24,639 --> 00:14:27,040
of things

00:14:27,519 --> 00:14:31,199
but there's something much more

00:14:29,440 --> 00:14:35,040
important that

00:14:31,199 --> 00:14:35,040
cooperative multitasking provides

00:14:36,480 --> 00:14:40,079
so the nature of cooperative

00:14:37,760 --> 00:14:42,720
multitasking is that

00:14:40,079 --> 00:14:44,320
tasks only yield explicitly when they're

00:14:42,720 --> 00:14:46,480
at a good stopping point

00:14:44,320 --> 00:14:48,240
so that means we've got a natural place

00:14:46,480 --> 00:14:49,279
to go and inspect the state of our

00:14:48,240 --> 00:14:52,320
program

00:14:49,279 --> 00:14:55,360
and in most cases we'll get a coherent

00:14:52,320 --> 00:14:58,399
consistent view of things

00:14:55,360 --> 00:14:59,920
so as an example let's say we've got a

00:14:58,399 --> 00:15:03,680
list of animals

00:14:59,920 --> 00:15:06,079
and we also want to maintain a

00:15:03,680 --> 00:15:08,320
count of the number of times each animal

00:15:06,079 --> 00:15:10,800
appears in the list

00:15:08,320 --> 00:15:12,560
and so an invariant of the program is

00:15:10,800 --> 00:15:15,600
that these two collections are

00:15:12,560 --> 00:15:18,079
always consistent and when we add a

00:15:15,600 --> 00:15:21,440
zebra to the list we also need to

00:15:18,079 --> 00:15:24,800
increment the zebra count by one

00:15:21,440 --> 00:15:27,600
so with cooperative multitasking

00:15:24,800 --> 00:15:29,680
we're sure that basically these these

00:15:27,600 --> 00:15:32,720
two operations are atomic

00:15:29,680 --> 00:15:35,759
and it's only when an await statement

00:15:32,720 --> 00:15:36,399
is executed that there is a context

00:15:35,759 --> 00:15:39,440
switch

00:15:36,399 --> 00:15:42,880
so between any of the await statements

00:15:39,440 --> 00:15:44,399
it's basically like a atomic section of

00:15:42,880 --> 00:15:47,040
code

00:15:44,399 --> 00:15:47,759
and so we're taking advantage of this

00:15:47,040 --> 00:15:50,639
and

00:15:47,759 --> 00:15:52,160
uh we'll know that the replace eval

00:15:50,639 --> 00:15:54,800
would never

00:15:52,160 --> 00:15:57,360
see an inconsistent view of these two

00:15:54,800 --> 00:15:57,360
collections

00:16:01,199 --> 00:16:06,880
so on our project we introduced the tool

00:16:04,240 --> 00:16:08,959
to do this kind of visualization about

00:16:06,880 --> 00:16:11,440
three years ago

00:16:08,959 --> 00:16:12,959
to our program and it's worked out

00:16:11,440 --> 00:16:15,279
really well

00:16:12,959 --> 00:16:16,959
it's been widely adopted by our

00:16:15,279 --> 00:16:20,079
development team

00:16:16,959 --> 00:16:20,959
and i would say really importantly it's

00:16:20,079 --> 00:16:23,199
a way for

00:16:20,959 --> 00:16:25,759
the developers to communicate what's

00:16:23,199 --> 00:16:28,959
going on in the components they create

00:16:25,759 --> 00:16:31,759
to other people on the team and to

00:16:28,959 --> 00:16:34,000
newcomers to the team or say sometimes

00:16:31,759 --> 00:16:37,199
we have guest developers

00:16:34,000 --> 00:16:39,040
they're able to go and learn about the

00:16:37,199 --> 00:16:42,240
real-time operation of some of the

00:16:39,040 --> 00:16:45,199
pieces of the program

00:16:42,240 --> 00:16:46,240
and we use this this tool very heavily

00:16:45,199 --> 00:16:48,480
so i would say

00:16:46,240 --> 00:16:49,759
good portions of our development and

00:16:48,480 --> 00:16:51,600
quality assurance

00:16:49,759 --> 00:16:54,240
would literally just stop if we didn't

00:16:51,600 --> 00:16:56,639
have this tool

00:16:54,240 --> 00:16:58,320
and guest developers on our team have

00:16:56,639 --> 00:17:02,320
even contributed

00:16:58,320 --> 00:17:02,320
visualizations and that speaks to

00:17:02,720 --> 00:17:08,160
having enough simplicity there for for

00:17:05,679 --> 00:17:08,160
doing that

00:17:09,039 --> 00:17:14,880
so our implementation is called pura

00:17:12,959 --> 00:17:16,079
and it provides these remote canvas

00:17:14,880 --> 00:17:19,520
visualizations

00:17:16,079 --> 00:17:22,559
as well as the rupple

00:17:19,520 --> 00:17:25,919
it's liberally licensed so you can

00:17:22,559 --> 00:17:25,919
embed it into your program

00:17:26,559 --> 00:17:31,360
an important principle of pura is if a

00:17:29,679 --> 00:17:34,320
visualization doesn't have an

00:17:31,360 --> 00:17:35,840
observer there's no runtime overhead and

00:17:34,320 --> 00:17:38,000
that's very important you don't want to

00:17:35,840 --> 00:17:41,120
interfere with the normal

00:17:38,000 --> 00:17:45,200
production behavior of your application

00:17:41,120 --> 00:17:45,200
so let's jump into a demo of pera

00:17:45,760 --> 00:17:49,360
so i've got an example program running

00:17:47,600 --> 00:17:49,840
in the background and i'm just going to

00:17:49,360 --> 00:17:53,919
connect

00:17:49,840 --> 00:17:53,919
to it on pera's main port

00:17:56,559 --> 00:18:01,280
so here's a hello example and this drop

00:17:59,840 --> 00:18:03,200
down lets me pick

00:18:01,280 --> 00:18:06,000
any of the other available

00:18:03,200 --> 00:18:06,000
visualizations

00:18:06,480 --> 00:18:10,640
this is a faster than real time clock

00:18:11,440 --> 00:18:17,200
and the mini physics chain

00:18:14,559 --> 00:18:17,200
simulation

00:18:21,760 --> 00:18:24,960
so i'm going to go to another browser

00:18:23,520 --> 00:18:27,360
client and open

00:18:24,960 --> 00:18:29,760
up another connection so this is a

00:18:27,360 --> 00:18:31,360
connection to the same running program

00:18:29,760 --> 00:18:34,559
so now we're displaying two

00:18:31,360 --> 00:18:34,559
visualizations at once

00:18:38,160 --> 00:18:46,080
and then a third window

00:18:43,200 --> 00:18:48,320
now with this follow example you'll see

00:18:46,080 --> 00:18:48,320
that

00:18:48,480 --> 00:18:53,360
the views are mirroring each other so

00:18:51,039 --> 00:18:56,000
the program only has

00:18:53,360 --> 00:18:57,120
one internal representation of the state

00:18:56,000 --> 00:18:59,039
of this chain

00:18:57,120 --> 00:19:00,880
and i happen to be manipulating that

00:18:59,039 --> 00:19:02,960
state in

00:19:00,880 --> 00:19:04,080
one of the clients and it's just getting

00:19:02,960 --> 00:19:11,840
broadcast to the other

00:19:04,080 --> 00:19:11,840
so that's what's going on there

00:19:16,880 --> 00:19:20,400
let me open up a ruffle

00:19:22,400 --> 00:19:26,720
so i've got tap completion to explore

00:19:25,360 --> 00:19:29,200
what variables are

00:19:26,720 --> 00:19:29,200
available

00:19:32,799 --> 00:19:37,200
and there's a this clock object which is

00:19:35,679 --> 00:19:39,840
the object that's running the clock

00:19:37,200 --> 00:19:39,840
visualization

00:19:40,640 --> 00:19:46,160
so this actually has a little 12 hour

00:19:44,080 --> 00:19:49,120
alarm that you can set

00:19:46,160 --> 00:19:50,400
and so we can expect inspect the current

00:19:49,120 --> 00:19:54,720
alarm time

00:19:50,400 --> 00:19:57,440
from the rupple and we could set it to

00:19:54,720 --> 00:19:57,440
another time

00:20:00,240 --> 00:20:06,159
there we go another thing i want to show

00:20:03,280 --> 00:20:08,960
is what happens if we

00:20:06,159 --> 00:20:08,960
stop the program

00:20:10,480 --> 00:20:14,080
so all of these status lights change

00:20:12,880 --> 00:20:17,039
from blue to red

00:20:14,080 --> 00:20:20,960
showing that we lost our connection and

00:20:17,039 --> 00:20:23,600
i'll start the program back up

00:20:20,960 --> 00:20:25,200
and what happens is each visualization

00:20:23,600 --> 00:20:26,960
reconnects

00:20:25,200 --> 00:20:28,720
to the server automatically so this is

00:20:26,960 --> 00:20:35,840
nice for a typical

00:20:28,720 --> 00:20:35,840
development flow and that is pura

00:20:36,880 --> 00:20:40,960
so just one interesting point about

00:20:38,960 --> 00:20:45,039
perez design

00:20:40,960 --> 00:20:45,039
so here's that hello example again

00:20:45,679 --> 00:20:49,200
a decision we made was not to be in the

00:20:48,159 --> 00:20:51,600
business of

00:20:49,200 --> 00:20:53,440
creating a graphics api that's been done

00:20:51,600 --> 00:20:56,799
many times before

00:20:53,440 --> 00:20:59,039
so we actually borrowed the api from

00:20:56,799 --> 00:21:00,400
a framework called processing so

00:20:59,039 --> 00:21:04,320
processing is a

00:21:00,400 --> 00:21:07,360
graphics library and ide that's uh

00:21:04,320 --> 00:21:08,240
popular with students and graphic

00:21:07,360 --> 00:21:10,240
artists

00:21:08,240 --> 00:21:12,480
and animators for just working with

00:21:10,240 --> 00:21:14,640
graphics and

00:21:12,480 --> 00:21:15,679
interactivity with mouse and keyboard

00:21:14,640 --> 00:21:19,280
and things

00:21:15,679 --> 00:21:22,320
so by using the processing api

00:21:19,280 --> 00:21:22,960
we're also able to take advantage of the

00:21:22,320 --> 00:21:26,080
existing

00:21:22,960 --> 00:21:29,200
docs and examples and expertise in that

00:21:26,080 --> 00:21:30,480
community such as forums and books and

00:21:29,200 --> 00:21:33,919
actually the

00:21:30,480 --> 00:21:36,880
the follow example that we just saw

00:21:33,919 --> 00:21:39,360
was one of the official processing

00:21:36,880 --> 00:21:39,360
examples

00:21:41,520 --> 00:21:44,799
and then a quick look at architecture

00:21:43,440 --> 00:21:47,310
all presentations

00:21:44,799 --> 00:21:48,799
need to have an architecture slide so

00:21:47,310 --> 00:21:51,200
[Music]

00:21:48,799 --> 00:21:52,720
the main thing is pro will have this

00:21:51,200 --> 00:21:53,840
webview server component in your

00:21:52,720 --> 00:21:56,080
application

00:21:53,840 --> 00:21:58,880
and you'll register your visualizations

00:21:56,080 --> 00:22:01,520
with that component

00:21:58,880 --> 00:22:02,400
and then i'll just skip ahead here the

00:22:01,520 --> 00:22:06,000
interesting part

00:22:02,400 --> 00:22:06,559
is that it's not until one of the web

00:22:06,000 --> 00:22:09,200
clients

00:22:06,559 --> 00:22:10,400
makes a specific web socket to a

00:22:09,200 --> 00:22:13,280
visualization

00:22:10,400 --> 00:22:15,039
that the corresponding draw function

00:22:13,280 --> 00:22:18,320
will be called periodically

00:22:15,039 --> 00:22:18,320
say like 10 times a second

00:22:18,480 --> 00:22:21,760
and what happens what that draw function

00:22:20,799 --> 00:22:23,440
is doing

00:22:21,760 --> 00:22:25,360
as you're make calling those those

00:22:23,440 --> 00:22:29,679
python functions they're actually

00:22:25,360 --> 00:22:32,000
assembling some javascript html5

00:22:29,679 --> 00:22:35,840
canvas code and then that eventually

00:22:32,000 --> 00:22:35,840
gets shipped back to the client in eval

00:22:36,880 --> 00:22:41,360
so we've got uh we pull up a second

00:22:38,880 --> 00:22:42,799
visualization

00:22:41,360 --> 00:22:44,480
and then another instance of that

00:22:42,799 --> 00:22:47,600
visualization and

00:22:44,480 --> 00:22:50,640
an interesting point here is that

00:22:47,600 --> 00:22:52,320
each frame the follow draw method will

00:22:50,640 --> 00:22:53,760
only be called one time

00:22:52,320 --> 00:22:55,520
and then that javascript will be

00:22:53,760 --> 00:22:57,760
broadcast to

00:22:55,520 --> 00:23:01,600
all of the clients watching that

00:22:57,760 --> 00:23:01,600
visualization so it's quite efficient

00:23:02,480 --> 00:23:07,120
and then there's the uh terminal the um

00:23:05,520 --> 00:23:09,039
the reply is a little bit different

00:23:07,120 --> 00:23:12,799
because the client is running a

00:23:09,039 --> 00:23:15,840
terminal emulator and

00:23:12,799 --> 00:23:16,720
every every connection to the to the

00:23:15,840 --> 00:23:19,679
webview server

00:23:16,720 --> 00:23:23,840
gets its own rebel instance so that

00:23:19,679 --> 00:23:23,840
they're not shared

00:23:24,720 --> 00:23:28,080
i'd just like to conclude today with

00:23:26,559 --> 00:23:31,360
some ideas for

00:23:28,080 --> 00:23:33,679
future work as i said i think this is a

00:23:31,360 --> 00:23:34,960
pretty rich area to explore and i'm sure

00:23:33,679 --> 00:23:38,159
others have some

00:23:34,960 --> 00:23:38,159
ideas i'd like to hear them

00:23:38,559 --> 00:23:44,000
so one is uh debuggers typically have a

00:23:42,159 --> 00:23:46,640
variable display

00:23:44,000 --> 00:23:47,039
but again you have to pause your program

00:23:46,640 --> 00:23:49,520
to

00:23:47,039 --> 00:23:51,200
inspect the variables what if we can

00:23:49,520 --> 00:23:53,120
just

00:23:51,200 --> 00:23:54,480
do that while the program's running and

00:23:53,120 --> 00:23:57,600
all these values would just be

00:23:54,480 --> 00:23:57,600
continuously updating

00:23:58,080 --> 00:24:02,799
another thing we could do is have a way

00:24:00,400 --> 00:24:06,080
to explore the long-running

00:24:02,799 --> 00:24:09,919
tasks in our program and this is just

00:24:06,080 --> 00:24:12,080
uh that would be a way to discover

00:24:09,919 --> 00:24:13,520
variables you're interested in and look

00:24:12,080 --> 00:24:16,799
at all the levels of the

00:24:13,520 --> 00:24:19,120
program stack so that too could be

00:24:16,799 --> 00:24:21,440
done in real time as your program's

00:24:19,120 --> 00:24:21,440
running

00:24:24,240 --> 00:24:28,480
thank you very much for your time if

00:24:26,480 --> 00:24:30,480
you're interested in

00:24:28,480 --> 00:24:34,240
trying the approach shown here please

00:24:30,480 --> 00:24:36,480
check out the prayer library

00:24:34,240 --> 00:24:38,320
also if you're interested interested in

00:24:36,480 --> 00:24:40,640
software concurrency

00:24:38,320 --> 00:24:42,720
i've got a talk on productive

00:24:40,640 --> 00:24:44,000
concurrency from pycon japan a few years

00:24:42,720 --> 00:24:46,799
ago

00:24:44,000 --> 00:24:50,080
as well as an article about the notion

00:24:46,799 --> 00:24:50,080
of structured concurrency

00:24:50,720 --> 00:24:54,480
this talk has a webca webpage that will

00:24:53,039 --> 00:24:56,720
have these links

00:24:54,480 --> 00:24:59,200
as well as addendum and other

00:24:56,720 --> 00:25:01,760
information

00:24:59,200 --> 00:25:03,039
and finally i would just like to give a

00:25:01,760 --> 00:25:04,799
big thank you to

00:25:03,039 --> 00:25:07,039
friends and colleagues who gave me

00:25:04,799 --> 00:25:08,480
feedback on the early versions of this

00:25:07,039 --> 00:25:11,360
presentation

00:25:08,480 --> 00:25:12,840
and also thank you to my family for

00:25:11,360 --> 00:25:17,120
understanding my

00:25:12,840 --> 00:25:29,840
preoccupation in the past many weeks

00:25:17,120 --> 00:25:29,840
goodbye until next time

00:26:18,880 --> 00:26:20,960

YouTube URL: https://www.youtube.com/watch?v=olT7ejlv0uE


