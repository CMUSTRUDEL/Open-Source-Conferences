Title: TALK   Åukasz Langa   Generate buzz with realtime FM audio synthesis
Publication date: 2021-06-05
Playlist: PyCon US 2021
Description: 
	
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:15,510 --> 00:00:21,680
[Music]

00:00:20,960 --> 00:00:23,439
hi

00:00:21,680 --> 00:00:25,680
my name is lukas langa today we're going

00:00:23,439 --> 00:00:26,560
to talk about fm audio synthesis and in

00:00:25,680 --> 00:00:29,679
particular

00:00:26,560 --> 00:00:32,719
about real time fm audio synthesis in

00:00:29,679 --> 00:00:35,280
python you might know me for releasing a

00:00:32,719 --> 00:00:36,239
python for you or for creating the black

00:00:35,280 --> 00:00:38,960
code formatter

00:00:36,239 --> 00:00:39,920
but i'm also pretty invested in the

00:00:38,960 --> 00:00:42,399
music industry

00:00:39,920 --> 00:00:43,520
in fact i'm collaborating with poli and

00:00:42,399 --> 00:00:46,800
a polish company

00:00:43,520 --> 00:00:48,879
on a bunch of their devices right now

00:00:46,800 --> 00:00:50,879
this one that you see on the picture is

00:00:48,879 --> 00:00:52,239
medusa that's a hybrid synthesizer

00:00:50,879 --> 00:00:55,440
meaning it combines

00:00:52,239 --> 00:00:58,079
both analog and digital synthesis

00:00:55,440 --> 00:00:58,879
and in particular i was contracted to

00:00:58,079 --> 00:01:01,920
add

00:00:58,879 --> 00:01:02,559
digital fm synthesis to that device bear

00:01:01,920 --> 00:01:05,840
in mind

00:01:02,559 --> 00:01:07,520
this re-implementation is in c plus but

00:01:05,840 --> 00:01:09,760
the concepts that we're gonna be

00:01:07,520 --> 00:01:10,640
discussing are pretty much exactly the

00:01:09,760 --> 00:01:13,840
same

00:01:10,640 --> 00:01:15,759
it all started in 1983

00:01:13,840 --> 00:01:18,240
when one of the best selling

00:01:15,759 --> 00:01:19,840
synthesizers in history was released the

00:01:18,240 --> 00:01:22,560
yamaha dx7

00:01:19,840 --> 00:01:24,080
it was based on john chowning's research

00:01:22,560 --> 00:01:27,119
at stanford university

00:01:24,080 --> 00:01:28,720
on frequency modulation um it's been

00:01:27,119 --> 00:01:31,920
pretty cheap so it's been

00:01:28,720 --> 00:01:34,640
uh widely used in 1980s music

00:01:31,920 --> 00:01:35,520
from michael jackson aha whitney houston

00:01:34,640 --> 00:01:38,320
phil collins

00:01:35,520 --> 00:01:38,880
anya sting you essentially you name it

00:01:38,320 --> 00:01:42,560
it's been

00:01:38,880 --> 00:01:43,520
the sound of the 80s but even across the

00:01:42,560 --> 00:01:46,960
90s

00:01:43,520 --> 00:01:49,759
up to today it's being widely used by

00:01:46,960 --> 00:01:52,320
many bands for some of the sounds uh

00:01:49,759 --> 00:01:54,159
that are very unique to this instrument

00:01:52,320 --> 00:01:57,119
um like it's known um

00:01:54,159 --> 00:01:59,439
to be used by the pesh mode the cure and

00:01:57,119 --> 00:02:00,880
nine inch nails in fact like the picture

00:01:59,439 --> 00:02:04,560
that you're seeing here

00:02:00,880 --> 00:02:07,680
um is from a hardrock cafe in veroswap

00:02:04,560 --> 00:02:10,239
where i took it let's hear how

00:02:07,680 --> 00:02:12,000
that particular code that we're going to

00:02:10,239 --> 00:02:14,640
be writing today

00:02:12,000 --> 00:02:15,280
actually can sound like this will

00:02:14,640 --> 00:02:17,599
probably

00:02:15,280 --> 00:02:18,400
allow you to be a little more patient

00:02:17,599 --> 00:02:20,720
with

00:02:18,400 --> 00:02:21,680
whatever we have to do to actually make

00:02:20,720 --> 00:02:26,800
the code work

00:02:21,680 --> 00:02:26,800
so here it is this is how the end result

00:02:29,170 --> 00:02:34,030
[Music]

00:02:34,840 --> 00:02:40,400
sounds

00:02:37,280 --> 00:02:42,800
all right back to our code so

00:02:40,400 --> 00:02:44,239
signal flow that we're going to be using

00:02:42,800 --> 00:02:47,360
is going to be as follows

00:02:44,239 --> 00:02:50,160
python is going to be listening to

00:02:47,360 --> 00:02:51,120
musicians notes being played on a midi

00:02:50,160 --> 00:02:53,680
controller

00:02:51,120 --> 00:02:54,560
is going to synthesize sound in real

00:02:53,680 --> 00:02:57,840
time

00:02:54,560 --> 00:03:00,080
and you using the mini audio library

00:02:57,840 --> 00:03:01,200
is going to take this raw data there's

00:03:00,080 --> 00:03:04,159
going to be a bunch of

00:03:01,200 --> 00:03:05,040
integer arrays and send it to an output

00:03:04,159 --> 00:03:08,800
device

00:03:05,040 --> 00:03:11,680
this output device could be

00:03:08,800 --> 00:03:13,519
any sound card in fact or an audio

00:03:11,680 --> 00:03:15,519
interface as they're called

00:03:13,519 --> 00:03:16,800
in the industry but we're going to be

00:03:15,519 --> 00:03:19,120
using black hole

00:03:16,800 --> 00:03:20,720
which is a piece of software it's a

00:03:19,120 --> 00:03:23,760
virtual audio driver

00:03:20,720 --> 00:03:27,440
that acts as a virtual output device

00:03:23,760 --> 00:03:30,080
this allows us to route signal from

00:03:27,440 --> 00:03:31,040
our python code to an actual audio

00:03:30,080 --> 00:03:33,599
workstation

00:03:31,040 --> 00:03:35,040
and we're going to be using ableton live

00:03:33,599 --> 00:03:37,040
for this purpose

00:03:35,040 --> 00:03:38,080
this allows ableton live to take data

00:03:37,040 --> 00:03:41,200
from black hole

00:03:38,080 --> 00:03:42,560
as input and we can then record it apply

00:03:41,200 --> 00:03:46,080
effects to it

00:03:42,560 --> 00:03:48,879
um you know multi-track it mix it

00:03:46,080 --> 00:03:49,760
this actually makes it industry great

00:03:48,879 --> 00:03:52,799
all right

00:03:49,760 --> 00:03:55,680
so mini audio is a pretty cute

00:03:52,799 --> 00:03:56,239
single file library that allows for

00:03:55,680 --> 00:03:58,720
cross

00:03:56,239 --> 00:04:00,799
platform audio playback and this is

00:03:58,720 --> 00:04:04,439
exactly what we're going to be using it

00:04:00,799 --> 00:04:07,680
for today and it's got very good

00:04:04,439 --> 00:04:10,319
cffi bindings for python so we're going

00:04:07,680 --> 00:04:13,599
to be using those as well

00:04:10,319 --> 00:04:16,000
black hole is mac os specific but if you

00:04:13,599 --> 00:04:18,880
have windows there is an equivalent

00:04:16,000 --> 00:04:19,280
virtual audio driver and on linux i

00:04:18,880 --> 00:04:21,919
believe

00:04:19,280 --> 00:04:23,600
pulse audio has this functionality built

00:04:21,919 --> 00:04:26,720
in

00:04:23,600 --> 00:04:28,000
so that's ableton live our digital audio

00:04:26,720 --> 00:04:30,560
workstation of choice for

00:04:28,000 --> 00:04:32,080
today we can see an audio track here and

00:04:30,560 --> 00:04:33,199
a midi track we're going to be using

00:04:32,080 --> 00:04:35,600
both today

00:04:33,199 --> 00:04:36,320
to actually make it all work we need to

00:04:35,600 --> 00:04:39,840
tell

00:04:36,320 --> 00:04:42,639
ableton live to treat black hole as our

00:04:39,840 --> 00:04:43,520
audio input device today and this allows

00:04:42,639 --> 00:04:46,160
us now

00:04:43,520 --> 00:04:47,040
to just select any of its external

00:04:46,160 --> 00:04:50,080
inputs

00:04:47,040 --> 00:04:52,720
and record it or just monitor them so

00:04:50,080 --> 00:04:54,240
meaning listening to them this sort of

00:04:52,720 --> 00:04:57,520
thing so we're going to be using

00:04:54,240 --> 00:05:00,400
that so those are our components right

00:04:57,520 --> 00:05:01,360
python mini audio black hole and ableton

00:05:00,400 --> 00:05:03,520
live

00:05:01,360 --> 00:05:05,039
let's start filling in the python part

00:05:03,520 --> 00:05:08,320
but before you get

00:05:05,039 --> 00:05:11,280
all nervous about not being able to

00:05:08,320 --> 00:05:11,680
follow along don't worry all of this is

00:05:11,280 --> 00:05:15,199
on

00:05:11,680 --> 00:05:18,240
github you can pretty much just

00:05:15,199 --> 00:05:19,360
clone it and look at it at your own

00:05:18,240 --> 00:05:22,320
convenience

00:05:19,360 --> 00:05:23,520
the comments in that particular demo

00:05:22,320 --> 00:05:26,560
repository

00:05:23,520 --> 00:05:27,280
are roughly in the order that we are

00:05:26,560 --> 00:05:30,400
doing

00:05:27,280 --> 00:05:31,919
things today so you can just check out a

00:05:30,400 --> 00:05:34,160
particular comment to see

00:05:31,919 --> 00:05:36,560
the state of the code at that particular

00:05:34,160 --> 00:05:40,000
moment in time i hope they are

00:05:36,560 --> 00:05:42,400
described clearly enough so let's start

00:05:40,000 --> 00:05:43,840
by looking at what audio devices my

00:05:42,400 --> 00:05:45,919
computer even has

00:05:43,840 --> 00:05:48,000
let's use be python as the reply and

00:05:45,919 --> 00:05:49,039
rich to 3d print built-in data

00:05:48,000 --> 00:05:51,840
structures

00:05:49,039 --> 00:05:54,320
so now we're importing devices from many

00:05:51,840 --> 00:05:56,639
audio which allows us to enumerate them

00:05:54,320 --> 00:05:58,080
and in particular to enumerate the ones

00:05:56,639 --> 00:05:59,840
that allow playback

00:05:58,080 --> 00:06:01,520
there's a bunch of them here including

00:05:59,840 --> 00:06:04,080
useless ones like

00:06:01,520 --> 00:06:04,880
the one in my display or the one in my

00:06:04,080 --> 00:06:07,039
thunderbolt

00:06:04,880 --> 00:06:08,400
dock but the one that is important is

00:06:07,039 --> 00:06:10,720
this black hole one

00:06:08,400 --> 00:06:13,199
we're going to be using this one as you

00:06:10,720 --> 00:06:14,400
can see comparing with the macbook pro

00:06:13,199 --> 00:06:17,360
speakers below

00:06:14,400 --> 00:06:18,400
it doesn't actually look any different

00:06:17,360 --> 00:06:21,600
um

00:06:18,400 --> 00:06:23,600
so this is sort of the point that now

00:06:21,600 --> 00:06:25,120
it doesn't matter whether we are sending

00:06:23,600 --> 00:06:28,800
signals straight

00:06:25,120 --> 00:06:30,080
to some physical output or to black hole

00:06:28,800 --> 00:06:32,240
to route it to

00:06:30,080 --> 00:06:33,759
ableton live or any other digital audio

00:06:32,240 --> 00:06:36,560
workstation

00:06:33,759 --> 00:06:39,039
so our code uses the same functionality

00:06:36,560 --> 00:06:41,840
to enumerate over all devices

00:06:39,039 --> 00:06:43,919
choose the one with a matching name and

00:06:41,840 --> 00:06:46,639
build a playback device object

00:06:43,919 --> 00:06:48,000
from it with that we can stream some

00:06:46,639 --> 00:06:50,400
audio

00:06:48,000 --> 00:06:51,680
let's say we're going to be streaming

00:06:50,400 --> 00:06:55,280
some cowbell sound

00:06:51,680 --> 00:06:58,479
okay note that

00:06:55,280 --> 00:07:02,400
the playback device that we have here

00:06:58,479 --> 00:07:04,960
produced online 29 is used as a context

00:07:02,400 --> 00:07:06,240
manager and streaming happens in fact in

00:07:04,960 --> 00:07:09,759
a background thread

00:07:06,240 --> 00:07:12,080
so for now we need to use time.sleep to

00:07:09,759 --> 00:07:15,120
ensure the application doesn't finish

00:07:12,080 --> 00:07:17,840
before the sound finished playing so

00:07:15,120 --> 00:07:17,840
let's run it

00:07:19,120 --> 00:07:24,479
beautiful a classic roland 808 cowbell

00:07:22,160 --> 00:07:24,479
sound

00:07:24,560 --> 00:07:30,400
that's the same sound in ableton live

00:07:26,400 --> 00:07:34,000
let's add some reverb

00:07:30,400 --> 00:07:34,000
cool maybe some delay

00:07:36,319 --> 00:07:41,759
all right nice this shows why using a

00:07:39,440 --> 00:07:44,240
digital audio workstation is so powerful

00:07:41,759 --> 00:07:45,599
but we don't want to just play samples

00:07:44,240 --> 00:07:48,960
we want to synthesize

00:07:45,599 --> 00:07:52,240
our own sound to do this we'll use

00:07:48,960 --> 00:07:54,560
low-level numeric arrays 16-bit signed

00:07:52,240 --> 00:07:56,000
integer arrays to be exact as this is

00:07:54,560 --> 00:07:57,599
very popular for audio

00:07:56,000 --> 00:08:00,800
i already prepared a function that

00:07:57,599 --> 00:08:03,759
generates a single cycle of a sine wave

00:08:00,800 --> 00:08:05,360
of a given sample length that single

00:08:03,759 --> 00:08:08,319
cycle is very very short

00:08:05,360 --> 00:08:08,879
so now let's make a generator that will

00:08:08,319 --> 00:08:11,840
loop

00:08:08,879 --> 00:08:13,840
over this single cycle forever to

00:08:11,840 --> 00:08:16,560
produce actual sound

00:08:13,840 --> 00:08:17,520
for this we are already using the api of

00:08:16,560 --> 00:08:20,080
mini audio

00:08:17,520 --> 00:08:20,879
which likes to use generators for

00:08:20,080 --> 00:08:23,280
everything

00:08:20,879 --> 00:08:23,919
but they're very specific generators

00:08:23,280 --> 00:08:27,840
meaning

00:08:23,919 --> 00:08:30,960
mini audio will send uh to the generator

00:08:27,840 --> 00:08:31,520
information about how many frames it

00:08:30,960 --> 00:08:34,959
wants

00:08:31,520 --> 00:08:36,880
us to send back so this is essentially

00:08:34,959 --> 00:08:40,080
what we're going to be doing right now

00:08:36,880 --> 00:08:43,519
there are loops that are

00:08:40,080 --> 00:08:47,600
just putting the right amount of frames

00:08:43,519 --> 00:08:51,200
in an array object and yielding it back

00:08:47,600 --> 00:08:52,880
asking for how many more frames does

00:08:51,200 --> 00:08:54,720
many audio want from us

00:08:52,880 --> 00:08:56,000
so there's essentially very little

00:08:54,720 --> 00:08:57,680
complication here

00:08:56,000 --> 00:08:59,360
the only thing we need to remember is

00:08:57,680 --> 00:09:02,320
what index we finished at

00:08:59,360 --> 00:09:03,760
and to loop over when we reached the end

00:09:02,320 --> 00:09:06,800
of the sample

00:09:03,760 --> 00:09:07,600
so now we can replace our cowbell with a

00:09:06,800 --> 00:09:10,560
stream

00:09:07,600 --> 00:09:12,240
of the our endless sign the one weird

00:09:10,560 --> 00:09:15,440
thing that we need to do

00:09:12,240 --> 00:09:18,640
is to have a single

00:09:15,440 --> 00:09:21,680
pull from the generator first before we

00:09:18,640 --> 00:09:24,480
pass it to many audio why is that

00:09:21,680 --> 00:09:25,200
well looking at our generator function

00:09:24,480 --> 00:09:28,160
we see

00:09:25,200 --> 00:09:29,440
that this there's some setup before the

00:09:28,160 --> 00:09:32,720
first yield

00:09:29,440 --> 00:09:36,240
so before the first value is

00:09:32,720 --> 00:09:39,040
um received from external

00:09:36,240 --> 00:09:41,200
um you know controllers i don't know

00:09:39,040 --> 00:09:42,720
callers of the generator

00:09:41,200 --> 00:09:44,800
there is already some code that is

00:09:42,720 --> 00:09:45,920
running and this is the code that we're

00:09:44,800 --> 00:09:48,800
running by

00:09:45,920 --> 00:09:50,000
uh running this first bear next if we

00:09:48,800 --> 00:09:52,560
tried to already

00:09:50,000 --> 00:09:54,720
pass a value during this first next by

00:09:52,560 --> 00:09:57,040
just using dot send

00:09:54,720 --> 00:09:59,120
python would not be very happy with us

00:09:57,040 --> 00:09:59,519
because you cannot really send values

00:09:59,120 --> 00:10:02,640
yet

00:09:59,519 --> 00:10:05,920
when a generator is not running yet

00:10:02,640 --> 00:10:09,040
so now you might be wondering why we are

00:10:05,920 --> 00:10:11,279
even um yielding full

00:10:09,040 --> 00:10:12,079
arrays of values we might have just as

00:10:11,279 --> 00:10:14,480
well just

00:10:12,079 --> 00:10:16,160
yielded single values that would make

00:10:14,480 --> 00:10:19,279
everything much simpler

00:10:16,160 --> 00:10:22,000
and you'd be correct but it would also

00:10:19,279 --> 00:10:22,880
overwhelm python generating sound in

00:10:22,000 --> 00:10:25,839
chunks is

00:10:22,880 --> 00:10:26,480
a very smart compromise here so let's

00:10:25,839 --> 00:10:29,200
hear our

00:10:26,480 --> 00:10:29,200
endless sign

00:10:30,320 --> 00:10:33,839
nice is that some reverb

00:10:35,120 --> 00:10:39,839
cool sounds fuller and now some delay

00:10:43,040 --> 00:10:50,959
all right pretty good 100 samples at

00:10:47,000 --> 00:10:51,519
44.1 kilohertz is very close to 440

00:10:50,959 --> 00:10:55,200
hertz

00:10:51,519 --> 00:10:57,200
the standard pitch of a4 if we asked for

00:10:55,200 --> 00:10:58,240
a longer sine wave it would produce

00:10:57,200 --> 00:11:00,640
lower nodes

00:10:58,240 --> 00:11:02,399
if we generated a shorter sine wave it

00:11:00,640 --> 00:11:06,640
would produce higher nodes

00:11:02,399 --> 00:11:09,360
so let's see our sound on a spectrogram

00:11:06,640 --> 00:11:10,480
while the scale here is logarithmic we

00:11:09,360 --> 00:11:14,079
can see that it's

00:11:10,480 --> 00:11:17,200
440 hertz indeed by way

00:11:14,079 --> 00:11:20,880
what are those unhappy pops at the start

00:11:17,200 --> 00:11:21,519
and here at the end let's look at our

00:11:20,880 --> 00:11:25,519
samples

00:11:21,519 --> 00:11:27,600
in time so at the start of the sound

00:11:25,519 --> 00:11:29,440
the upward slope starts pretty

00:11:27,600 --> 00:11:31,120
aggressively

00:11:29,440 --> 00:11:33,920
if i insert some silence at the

00:11:31,120 --> 00:11:36,880
beginning this this is easier to see

00:11:33,920 --> 00:11:39,040
the sharp angle here causes a pop it's

00:11:36,880 --> 00:11:41,680
not a particularly bad pop

00:11:39,040 --> 00:11:44,000
but it's there at the end of the sound

00:11:41,680 --> 00:11:46,959
though the situation is more severe

00:11:44,000 --> 00:11:49,040
we don't actually end the sound exactly

00:11:46,959 --> 00:11:52,399
at the end of the full cycle

00:11:49,040 --> 00:11:56,399
so this sharp angle here produces an

00:11:52,399 --> 00:11:59,200
even louder pop ideally

00:11:56,399 --> 00:12:00,639
we'd like our sound to decay gently and

00:11:59,200 --> 00:12:03,040
on the attack side

00:12:00,639 --> 00:12:04,320
also have a short while to get to full

00:12:03,040 --> 00:12:07,200
volume that way

00:12:04,320 --> 00:12:08,880
you avoid those sorts of clicks and pops

00:12:07,200 --> 00:12:12,000
we can achieve this by

00:12:08,880 --> 00:12:12,959
using an amplitude envelope the way we

00:12:12,000 --> 00:12:15,680
will use this

00:12:12,959 --> 00:12:16,959
is we will wrap our endless sign stream

00:12:15,680 --> 00:12:19,440
with a new envelope

00:12:16,959 --> 00:12:20,399
function which is also a generator that

00:12:19,440 --> 00:12:24,160
also takes an

00:12:20,399 --> 00:12:26,880
envelope object which is essentially

00:12:24,160 --> 00:12:27,519
an object to calculate us the current

00:12:26,880 --> 00:12:30,240
state

00:12:27,519 --> 00:12:32,079
of the envelope we could almost use just

00:12:30,240 --> 00:12:35,120
a single generator for this

00:12:32,079 --> 00:12:38,560
but we need to be able to reset it

00:12:35,120 --> 00:12:41,680
to play another sound before we

00:12:38,560 --> 00:12:44,560
look at it a small detail i added an

00:12:41,680 --> 00:12:46,399
audio type alias which is going to be

00:12:44,560 --> 00:12:48,639
very useful for our program it's going

00:12:46,399 --> 00:12:51,680
to be very popular here as a type

00:12:48,639 --> 00:12:52,399
so now on to the envelope object looks

00:12:51,680 --> 00:12:54,800
like

00:12:52,399 --> 00:12:56,720
a lot of lines but in truth it's only a

00:12:54,800 --> 00:12:57,279
single function that advances the

00:12:56,720 --> 00:12:59,839
envelope

00:12:57,279 --> 00:13:00,959
by a single sample and returns its

00:12:59,839 --> 00:13:03,200
current value

00:13:00,959 --> 00:13:04,880
the envelope that we're using here is an

00:13:03,200 --> 00:13:08,000
attack decay

00:13:04,880 --> 00:13:10,800
envelope meaning it has takes some time

00:13:08,000 --> 00:13:11,839
for it to raise to full volume and then

00:13:10,800 --> 00:13:14,800
it takes some time

00:13:11,839 --> 00:13:16,800
to get back to zero it's a linear

00:13:14,800 --> 00:13:19,839
envelope

00:13:16,800 --> 00:13:21,680
so by setting the samples advanced back

00:13:19,839 --> 00:13:23,839
to zero we can restart the envelope

00:13:21,680 --> 00:13:26,880
that's going to be useful later

00:13:23,839 --> 00:13:29,040
the envelope generator right here

00:13:26,880 --> 00:13:30,639
contains the same boilerplate setup as

00:13:29,040 --> 00:13:34,399
we've already seen

00:13:30,639 --> 00:13:37,519
and the meat is the loop line 62

00:13:34,399 --> 00:13:38,800
and 63 where we apply the envelope's

00:13:37,519 --> 00:13:41,839
current value

00:13:38,800 --> 00:13:44,079
to the incoming data so how does this

00:13:41,839 --> 00:13:44,079
sound

00:13:45,600 --> 00:13:49,839
nice add some reverb

00:13:50,320 --> 00:13:54,160
same deal and some delay

00:13:56,399 --> 00:14:00,880
nice so this is just an enveloped sign

00:13:58,959 --> 00:14:02,480
but it's already quite musical have you

00:14:00,880 --> 00:14:05,360
noticed

00:14:02,480 --> 00:14:06,639
so thanks to mini audio working in a

00:14:05,360 --> 00:14:09,519
background thread

00:14:06,639 --> 00:14:10,399
we can replace this useless time sleep

00:14:09,519 --> 00:14:12,880
with an

00:14:10,399 --> 00:14:14,480
async i o event loop to handle incoming

00:14:12,880 --> 00:14:16,560
midi data

00:14:14,480 --> 00:14:18,320
today we don't have time to talk about

00:14:16,560 --> 00:14:20,560
how that part works

00:14:18,320 --> 00:14:21,600
but fortunately i gave a sister talk to

00:14:20,560 --> 00:14:24,160
this one at

00:14:21,600 --> 00:14:25,279
pycon us last year that focuses

00:14:24,160 --> 00:14:29,199
exclusively

00:14:25,279 --> 00:14:31,760
on this subject the important thing for

00:14:29,199 --> 00:14:32,240
us is that a midi controller will send

00:14:31,760 --> 00:14:35,839
us

00:14:32,240 --> 00:14:39,920
note on messages handled by the method

00:14:35,839 --> 00:14:42,320
online 116 and that will allow

00:14:39,920 --> 00:14:44,880
the synthesizer to play a given note at

00:14:42,320 --> 00:14:48,480
a given volume we want to be

00:14:44,880 --> 00:14:51,600
able to play multiple notes at once so

00:14:48,480 --> 00:14:53,760
i made a voice object that combines the

00:14:51,600 --> 00:14:55,040
previous endless sign logic with the

00:14:53,760 --> 00:14:56,720
envelope function

00:14:55,040 --> 00:14:58,560
its biggest difference compared to the

00:14:56,720 --> 00:15:01,199
previous state is that now

00:14:58,560 --> 00:15:02,560
we can actually change the pitch of the

00:15:01,199 --> 00:15:05,440
played waveform

00:15:02,560 --> 00:15:07,519
um using that same array we don't

00:15:05,440 --> 00:15:10,639
recreate the array all the time

00:15:07,519 --> 00:15:14,079
that happens on line 109

00:15:10,639 --> 00:15:17,680
and 110. so we're hopping every

00:15:14,079 --> 00:15:19,839
w underscore i indexes of our waveform

00:15:17,680 --> 00:15:22,000
to achieve higher pitches

00:15:19,839 --> 00:15:23,120
now that's interesting how does that

00:15:22,000 --> 00:15:26,399
work

00:15:23,120 --> 00:15:28,800
instead of playing every sample in

00:15:26,399 --> 00:15:29,680
the array that we have we're hopping

00:15:28,800 --> 00:15:32,720
over a few

00:15:29,680 --> 00:15:35,360
in effect the sound has higher pitch

00:15:32,720 --> 00:15:36,160
the more indexes we hop over the higher

00:15:35,360 --> 00:15:38,880
the pitch

00:15:36,160 --> 00:15:40,880
now you might have noticed that in this

00:15:38,880 --> 00:15:44,160
example every second hop

00:15:40,880 --> 00:15:47,120
finds itself in the middle between

00:15:44,160 --> 00:15:48,000
two samples right what to do in this

00:15:47,120 --> 00:15:49,759
case

00:15:48,000 --> 00:15:51,680
well for the purpose of this talk we're

00:15:49,759 --> 00:15:52,480
simply choosing the nearest neighbor

00:15:51,680 --> 00:15:55,600
index

00:15:52,480 --> 00:15:57,680
but for higher fidelity audio you'd want

00:15:55,600 --> 00:15:59,920
to consult the sampling theorem

00:15:57,680 --> 00:16:01,600
and choose a more fancy interpolation

00:15:59,920 --> 00:16:02,320
method the one that we're going to be

00:16:01,600 --> 00:16:04,880
using today

00:16:02,320 --> 00:16:06,480
causes some aliasing meaning essentially

00:16:04,880 --> 00:16:09,199
noise

00:16:06,480 --> 00:16:09,759
combining back uh coming back to our

00:16:09,199 --> 00:16:11,839
code

00:16:09,759 --> 00:16:13,279
we also introduce a high level

00:16:11,839 --> 00:16:16,560
synthesizer object

00:16:13,279 --> 00:16:18,320
that can hold a bunch of voices meaning

00:16:16,560 --> 00:16:20,240
now our synthesizer is going to be

00:16:18,320 --> 00:16:23,440
polyphonic it's going to play

00:16:20,240 --> 00:16:25,839
many sounds at the same time so the

00:16:23,440 --> 00:16:26,160
synthesizer object selects one to play

00:16:25,839 --> 00:16:29,199
when

00:16:26,160 --> 00:16:29,519
a note on message is received you can

00:16:29,199 --> 00:16:33,600
see

00:16:29,519 --> 00:16:36,000
its own note on message on line 70

00:16:33,600 --> 00:16:36,639
and it's doing this very important job

00:16:36,000 --> 00:16:39,040
to some

00:16:36,639 --> 00:16:40,240
output of all the voices it contains

00:16:39,040 --> 00:16:42,959
into a single

00:16:40,240 --> 00:16:44,720
mixed down output signal the mix down

00:16:42,959 --> 00:16:47,360
used here is the most basic one

00:16:44,720 --> 00:16:47,839
we turn down the volume of each voice by

00:16:47,360 --> 00:16:50,240
enough

00:16:47,839 --> 00:16:51,040
so that there's no distortion even if

00:16:50,240 --> 00:17:05,839
all of them

00:16:51,040 --> 00:17:05,839
play simultaneously

00:17:07,439 --> 00:17:14,559
this is how a midi sequence in

00:17:10,720 --> 00:17:17,520
ableton live of our synthesizer

00:17:14,559 --> 00:17:18,480
sounds in fact thanks to how all of this

00:17:17,520 --> 00:17:21,839
connects together

00:17:18,480 --> 00:17:24,720
we are able to uh not only play

00:17:21,839 --> 00:17:26,480
this instrument live but to use a

00:17:24,720 --> 00:17:29,520
digital audio workstation

00:17:26,480 --> 00:17:30,720
to uh synthesize well to sequence on

00:17:29,520 --> 00:17:34,000
melodies for us

00:17:30,720 --> 00:17:34,960
as i've done right now but the most

00:17:34,000 --> 00:17:36,640
important thing is

00:17:34,960 --> 00:17:38,480
that's pretty pleasant to the ear

00:17:36,640 --> 00:17:42,080
already right and this is

00:17:38,480 --> 00:17:42,960
only a sine wave that we've synthesized

00:17:42,080 --> 00:17:44,559
for now

00:17:42,960 --> 00:17:46,080
but it's already real time it's high

00:17:44,559 --> 00:17:49,120
fidelity and

00:17:46,080 --> 00:17:52,080
it's in pure python so let's

00:17:49,120 --> 00:17:53,280
make it frequency modulated let's look

00:17:52,080 --> 00:17:56,400
at the example

00:17:53,280 --> 00:18:01,039
of sample pitching again

00:17:56,400 --> 00:18:03,679
even though our sine wave table has some

00:18:01,039 --> 00:18:05,840
air quotes natural pitch we can pitch it

00:18:03,679 --> 00:18:06,640
up by hopping through many indexes in a

00:18:05,840 --> 00:18:08,880
table

00:18:06,640 --> 00:18:10,480
and this hopping results in waveform

00:18:08,880 --> 00:18:12,400
cycles of higher frequency

00:18:10,480 --> 00:18:14,480
right because we're choosing fewer

00:18:12,400 --> 00:18:16,799
indexes and putting them out

00:18:14,480 --> 00:18:18,880
in other words there is a way to

00:18:16,799 --> 00:18:20,240
calculate how many indexes we should be

00:18:18,880 --> 00:18:25,039
hopping over to achieve

00:18:20,240 --> 00:18:27,600
any pitch we want now if our hopping

00:18:25,039 --> 00:18:29,280
changes over time the rate of hopping i

00:18:27,600 --> 00:18:31,520
guess changes over time

00:18:29,280 --> 00:18:32,559
so will the frequency of the resulting

00:18:31,520 --> 00:18:34,640
waveform

00:18:32,559 --> 00:18:36,320
if that change over time is done in a

00:18:34,640 --> 00:18:38,000
controlled manner as you can see in the

00:18:36,320 --> 00:18:38,640
example clearly there's some pattern

00:18:38,000 --> 00:18:41,679
here

00:18:38,640 --> 00:18:42,559
we call that modulation frequency

00:18:41,679 --> 00:18:46,000
modulation

00:18:42,559 --> 00:18:47,039
and voila this is how the end result

00:18:46,000 --> 00:18:50,000
looks like graphed

00:18:47,039 --> 00:18:51,280
out let me just kill myself here if our

00:18:50,000 --> 00:18:53,919
raw blue signal

00:18:51,280 --> 00:18:54,559
is frequency modulated with another sign

00:18:53,919 --> 00:18:57,600
the

00:18:54,559 --> 00:19:00,160
uh orange one the end result in green

00:18:57,600 --> 00:19:00,799
ends up being a pretty complex waveform

00:19:00,160 --> 00:19:04,080
producing

00:19:00,799 --> 00:19:06,640
very interesting timbres

00:19:04,080 --> 00:19:08,160
now we can make those timers even more

00:19:06,640 --> 00:19:10,880
interesting if we apply

00:19:08,160 --> 00:19:12,960
amplitude enveloping so here we envelope

00:19:10,880 --> 00:19:14,480
the carrier signal with some attack and

00:19:12,960 --> 00:19:16,320
as long as you decay

00:19:14,480 --> 00:19:17,840
and you can already see that this

00:19:16,320 --> 00:19:21,520
essentially appears

00:19:17,840 --> 00:19:22,160
in the end result but we can also apply

00:19:21,520 --> 00:19:24,480
enveloping

00:19:22,160 --> 00:19:25,520
to the modulator signal decreasing the

00:19:24,480 --> 00:19:27,600
amount of

00:19:25,520 --> 00:19:28,880
frequency modulation over time in this

00:19:27,600 --> 00:19:31,039
example

00:19:28,880 --> 00:19:32,799
it's an important insight to realize

00:19:31,039 --> 00:19:34,880
that there is no difference

00:19:32,799 --> 00:19:36,240
between the carry signal and the

00:19:34,880 --> 00:19:39,120
modulator signal

00:19:36,240 --> 00:19:40,160
their role is assumed only when the two

00:19:39,120 --> 00:19:42,799
are connected

00:19:40,160 --> 00:19:44,400
so for example i can reverse them if i

00:19:42,799 --> 00:19:46,000
reverse the role of the carrier and

00:19:44,400 --> 00:19:49,360
modulation in this graph

00:19:46,000 --> 00:19:52,559
we will get this cool

00:19:49,360 --> 00:19:54,960
now the fun begins when you realize that

00:19:52,559 --> 00:19:56,640
there is nothing stopping us from using

00:19:54,960 --> 00:19:59,520
frequency modulation

00:19:56,640 --> 00:20:00,640
on a modulator and that now this

00:19:59,520 --> 00:20:03,280
modulator will

00:20:00,640 --> 00:20:04,480
further modulate something else and this

00:20:03,280 --> 00:20:07,200
is the basic

00:20:04,480 --> 00:20:08,080
basis of commercial fm synthesis as we

00:20:07,200 --> 00:20:10,640
know it

00:20:08,080 --> 00:20:11,919
for example medusa supports five such

00:20:10,640 --> 00:20:14,960
combinations

00:20:11,919 --> 00:20:17,360
chonin came up with the term operator

00:20:14,960 --> 00:20:18,000
for each of those pitched sine waves

00:20:17,360 --> 00:20:21,280
that have

00:20:18,000 --> 00:20:24,159
an attached envelope generator

00:20:21,280 --> 00:20:25,280
in particular when an operator is at the

00:20:24,159 --> 00:20:27,600
end of the chain

00:20:25,280 --> 00:20:29,760
and it produces sound it's called a

00:20:27,600 --> 00:20:31,600
carrier as we've seen in the graphs

00:20:29,760 --> 00:20:33,280
and if it modulates another operator

00:20:31,600 --> 00:20:36,880
it's called the modulator

00:20:33,280 --> 00:20:40,320
so chouning called the combinations of

00:20:36,880 --> 00:20:40,880
the operators algorithms now there's

00:20:40,320 --> 00:20:43,679
another

00:20:40,880 --> 00:20:45,919
synthesizer that um is very popular

00:20:43,679 --> 00:20:48,960
these days in fm synthesis called

00:20:45,919 --> 00:20:51,760
korg op6 this one uses

00:20:48,960 --> 00:20:52,720
uses six operators per algorithm which

00:20:51,760 --> 00:20:55,120
allows for

00:20:52,720 --> 00:20:57,120
way more combinations note that some of

00:20:55,120 --> 00:21:00,159
those even have a loop around them

00:20:57,120 --> 00:21:00,720
meaning um they can feed their own

00:21:00,159 --> 00:21:02,799
signal

00:21:00,720 --> 00:21:04,159
back to themselves and that feedback

00:21:02,799 --> 00:21:07,440
actually produces

00:21:04,159 --> 00:21:09,600
pretty nice fm distorted sounds

00:21:07,440 --> 00:21:11,919
but three operators are less cpu

00:21:09,600 --> 00:21:12,400
intensive and easier to demonstrate for

00:21:11,919 --> 00:21:16,480
now

00:21:12,400 --> 00:21:18,799
so we'll focus on that for this talk

00:21:16,480 --> 00:21:20,320
so we are going to be renaming our voice

00:21:18,799 --> 00:21:23,039
into operator

00:21:20,320 --> 00:21:23,919
since this is the terminology as we've

00:21:23,039 --> 00:21:25,919
learned

00:21:23,919 --> 00:21:27,120
and more importantly we're going to be

00:21:25,919 --> 00:21:29,840
refactoring our

00:21:27,120 --> 00:21:31,520
output that now is a single

00:21:29,840 --> 00:21:35,840
non-modulated output

00:21:31,520 --> 00:21:35,840
into a version that actually

00:21:36,000 --> 00:21:42,480
listens to external modulation and

00:21:39,039 --> 00:21:45,600
applies it to itself so i changed

00:21:42,480 --> 00:21:48,880
the result the return

00:21:45,600 --> 00:21:51,760
type to fm audio that only means

00:21:48,880 --> 00:21:52,559
that it accepts now an entire array

00:21:51,760 --> 00:21:55,120
being sent

00:21:52,559 --> 00:21:56,960
to the generator instead of just how

00:21:55,120 --> 00:21:59,200
many frames do we want

00:21:56,960 --> 00:22:00,320
the reason why we accept an array of

00:21:59,200 --> 00:22:03,360
audio is that

00:22:00,320 --> 00:22:03,679
now we are in fact using it to modulate

00:22:03,360 --> 00:22:06,159
our

00:22:03,679 --> 00:22:08,559
modulate our own signal the magic

00:22:06,159 --> 00:22:12,799
happens in line 114

00:22:08,559 --> 00:22:16,720
where we use the mod underscore scaled

00:22:12,799 --> 00:22:18,880
variable to affect our index hopping

00:22:16,720 --> 00:22:20,480
and that variable comes from the

00:22:18,880 --> 00:22:23,600
external input

00:22:20,480 --> 00:22:26,640
so now the operator is fully functional

00:22:23,600 --> 00:22:29,919
we can move on to the synthesizer object

00:22:26,640 --> 00:22:32,559
it is not using the voice object anymore

00:22:29,919 --> 00:22:33,520
we don't have those anymore it is using

00:22:32,559 --> 00:22:36,400
a new one called

00:22:33,520 --> 00:22:37,200
face modulator phase modulators are

00:22:36,400 --> 00:22:40,240
going to

00:22:37,200 --> 00:22:43,760
be the objects that combine

00:22:40,240 --> 00:22:46,240
several operators are using an algorithm

00:22:43,760 --> 00:22:49,440
into some complex sound so let's see

00:22:46,240 --> 00:22:52,960
that phase modulator right now

00:22:49,440 --> 00:22:56,720
the phase modulator is another pretty uh

00:22:52,960 --> 00:22:59,440
simple data class in terms of its shape

00:22:56,720 --> 00:23:00,080
um but it has those three operators that

00:22:59,440 --> 00:23:03,200
we've seen

00:23:00,080 --> 00:23:06,640
and three rates what are those rates

00:23:03,200 --> 00:23:09,919
it's mostly musical when the frequencies

00:23:06,640 --> 00:23:12,640
of our three operators still have

00:23:09,919 --> 00:23:13,440
some relation between them if they would

00:23:12,640 --> 00:23:15,200
just be

00:23:13,440 --> 00:23:18,000
random frequencies that you know

00:23:15,200 --> 00:23:21,200
whenever we choose another note to play

00:23:18,000 --> 00:23:24,240
they don't really have um you know

00:23:21,200 --> 00:23:27,120
uh logical relationship they would

00:23:24,240 --> 00:23:28,559
you know sound dissonant uh so to have

00:23:27,120 --> 00:23:32,880
consonants to have like

00:23:28,559 --> 00:23:36,720
nice sounds there uh we use um

00:23:32,880 --> 00:23:40,559
rates that allow us to build complex

00:23:36,720 --> 00:23:43,200
numbers uh that are still very musical

00:23:40,559 --> 00:23:44,799
so here on this screen we only see how

00:23:43,200 --> 00:23:46,799
all of this is being set up

00:23:44,799 --> 00:23:50,000
uh when you create a new new phase

00:23:46,799 --> 00:23:53,360
modulation object phase modulator object

00:23:50,000 --> 00:23:56,240
the note on and now actually has to play

00:23:53,360 --> 00:23:57,440
all of the operators but the money shot

00:23:56,240 --> 00:24:00,720
is here

00:23:57,440 --> 00:24:03,120
that the most complex output

00:24:00,720 --> 00:24:04,480
generator of all but it's not very

00:24:03,120 --> 00:24:07,440
complex um

00:24:04,480 --> 00:24:08,720
in fact it only takes so long because we

00:24:07,440 --> 00:24:12,159
have three operators

00:24:08,720 --> 00:24:14,480
to initialize and we have our five

00:24:12,159 --> 00:24:16,799
algorithms that we implemented and let's

00:24:14,480 --> 00:24:20,799
see if they are readable

00:24:16,799 --> 00:24:23,440
if we look at line 179 we see that the

00:24:20,799 --> 00:24:26,159
first algorithm what it does is it takes

00:24:23,440 --> 00:24:28,960
the output from the third operator

00:24:26,159 --> 00:24:29,600
puts it in operator 2. and in turn it

00:24:28,960 --> 00:24:32,080
takes

00:24:29,600 --> 00:24:33,520
the output of operator two and puts it

00:24:32,080 --> 00:24:36,480
in operator one

00:24:33,520 --> 00:24:38,000
and operator one is our output it's our

00:24:36,480 --> 00:24:40,880
career for now

00:24:38,000 --> 00:24:41,840
so that's in fact this chain uh that

00:24:40,880 --> 00:24:46,559
we've seen

00:24:41,840 --> 00:24:49,919
that is a very typical um fm algorithm

00:24:46,559 --> 00:24:50,960
that pretty much reads as what it does

00:24:49,919 --> 00:24:53,520
like i find that

00:24:50,960 --> 00:24:54,000
tremendously readable let's try another

00:24:53,520 --> 00:24:57,440
one

00:24:54,000 --> 00:25:00,640
so for example this algorithm 2 has

00:24:57,440 --> 00:25:01,279
output of operator 3 being applied to

00:25:00,640 --> 00:25:04,320
both

00:25:01,279 --> 00:25:06,799
operator 2 and operator 1.

00:25:04,320 --> 00:25:09,039
and now since both of them are carriers

00:25:06,799 --> 00:25:13,200
we have to mix them together

00:25:09,039 --> 00:25:16,240
to yield our output pretty cool right

00:25:13,200 --> 00:25:18,559
so that is essentially what uh face

00:25:16,240 --> 00:25:19,600
modulation what our frequency modulation

00:25:18,559 --> 00:25:22,640
does

00:25:19,600 --> 00:25:24,640
and we can now see how this

00:25:22,640 --> 00:25:26,080
sounds on the sequence that we've

00:25:24,640 --> 00:25:28,320
already heard

00:25:26,080 --> 00:25:38,520
on simple sine waves

00:25:28,320 --> 00:25:38,520
[Music]

00:25:40,960 --> 00:25:47,520
cool so as you can see um

00:25:44,159 --> 00:25:48,480
the difference in code is maybe 100

00:25:47,520 --> 00:25:52,159
lines

00:25:48,480 --> 00:25:55,919
but the result sounds much more rich

00:25:52,159 --> 00:25:57,039
this one patch in particular is a very

00:25:55,919 --> 00:26:01,520
typical

00:25:57,039 --> 00:26:04,320
80s power ballad glass electric piano

00:26:01,520 --> 00:26:05,760
but there are very many sounds you can

00:26:04,320 --> 00:26:08,080
accomplish with this

00:26:05,760 --> 00:26:09,760
synthesizer engine in fact if you are

00:26:08,080 --> 00:26:13,520
interested in like hearing

00:26:09,760 --> 00:26:18,000
more possibilities i released an ep

00:26:13,520 --> 00:26:20,880
using just medusa's synthesizer engine

00:26:18,000 --> 00:26:21,200
to show how many possibilities there are

00:26:20,880 --> 00:26:24,320
for

00:26:21,200 --> 00:26:24,880
this so that essentially closes our talk

00:26:24,320 --> 00:26:27,360
for today

00:26:24,880 --> 00:26:28,240
i hope i would have more time to explain

00:26:27,360 --> 00:26:31,279
how all of this

00:26:28,240 --> 00:26:33,840
uh combines um like if

00:26:31,279 --> 00:26:35,600
you are interested in this you probably

00:26:33,840 --> 00:26:38,880
want to invest more time

00:26:35,600 --> 00:26:42,320
to make the sound better by

00:26:38,880 --> 00:26:44,640
decreasing aliasing with

00:26:42,320 --> 00:26:47,200
replacing our nearest neighbor hopping

00:26:44,640 --> 00:26:49,679
algorithm with some better one

00:26:47,200 --> 00:26:50,880
you might use psython to achieve some

00:26:49,679 --> 00:26:53,760
better performance

00:26:50,880 --> 00:26:54,880
in fact i will be uh talking about this

00:26:53,760 --> 00:26:58,080
very subject

00:26:54,880 --> 00:26:58,640
at montreal python later this month and

00:26:58,080 --> 00:27:01,600
you can

00:26:58,640 --> 00:27:03,440
make our envelope more complex like we

00:27:01,600 --> 00:27:06,080
only use the simple aed

00:27:03,440 --> 00:27:07,520
envelope but you might just as well use

00:27:06,080 --> 00:27:11,679
a full adsr

00:27:07,520 --> 00:27:14,240
meaning attack decay sustain release

00:27:11,679 --> 00:27:15,039
even with exponential slopes which sound

00:27:14,240 --> 00:27:18,159
more

00:27:15,039 --> 00:27:21,919
natural the code is

00:27:18,159 --> 00:27:23,440
available on github so don't hesitate to

00:27:21,919 --> 00:27:24,480
ask me for details if you didn't

00:27:23,440 --> 00:27:27,360
understand a

00:27:24,480 --> 00:27:35,840
particular bit here thanks for watching

00:27:27,360 --> 00:27:35,840
see you next time

00:28:35,200 --> 00:28:37,279

YouTube URL: https://www.youtube.com/watch?v=eKEjkB2bXK4


