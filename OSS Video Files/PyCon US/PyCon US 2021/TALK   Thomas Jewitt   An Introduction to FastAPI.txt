Title: TALK   Thomas Jewitt   An Introduction to FastAPI
Publication date: 2021-05-30
Playlist: PyCon US 2021
Description: 
	With the skyrocketing popularity of Python as a language for web development, a wide array of tools now exist for the creation and documentation of REST APIs. Enter FastAPI, a quick, modern and extensible solution for rapidly creating RESTful services. This talk will explain the features, advantages, and utility of the FastAPI framework for developing comprehensive and useful APIs.
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:14,559 --> 00:00:17,840
hello everyone my name is thomas stewart

00:00:16,800 --> 00:00:21,760
and this is

00:00:17,840 --> 00:00:24,640
an introduction to fast api for pycon us

00:00:21,760 --> 00:00:26,720
00:00:24,640 --> 00:00:28,720
i want to start with a brief outline of

00:00:26,720 --> 00:00:31,199
how this talk is going to progress

00:00:28,720 --> 00:00:32,719
starting with an overview of what fast

00:00:31,199 --> 00:00:35,360
api is

00:00:32,719 --> 00:00:37,040
a little about how it works and why i'm

00:00:35,360 --> 00:00:39,120
doing this talk

00:00:37,040 --> 00:00:41,920
then i'm going to move into some

00:00:39,120 --> 00:00:44,640
practical examples of what a fast api

00:00:41,920 --> 00:00:45,440
application looks like we'll go through

00:00:44,640 --> 00:00:47,920
some code

00:00:45,440 --> 00:00:49,200
line by line see how an application is

00:00:47,920 --> 00:00:51,120
written

00:00:49,200 --> 00:00:52,239
and afterwards i'll move into talking

00:00:51,120 --> 00:00:55,039
about some features

00:00:52,239 --> 00:00:56,719
that highlight fast api's extensibility

00:00:55,039 --> 00:01:00,480
as a framework

00:00:56,719 --> 00:01:03,359
finally i will finish up by going over

00:01:00,480 --> 00:01:06,559
some of the main points of this talk

00:01:03,359 --> 00:01:06,559
during the wrap up

00:01:06,720 --> 00:01:10,320
so as i said earlier my name is thomas

00:01:09,520 --> 00:01:12,720
jewett

00:01:10,320 --> 00:01:14,400
i'm a full stack developer based out of

00:01:12,720 --> 00:01:16,240
dayton ohio

00:01:14,400 --> 00:01:18,000
i've worked on a number of web-based

00:01:16,240 --> 00:01:21,119
projects before both front-end

00:01:18,000 --> 00:01:23,200
and back-end and a majority of them have

00:01:21,119 --> 00:01:24,799
incorporated python in one way or

00:01:23,200 --> 00:01:28,159
another

00:01:24,799 --> 00:01:31,920
typically using django rest framework or

00:01:28,159 --> 00:01:31,920
flask on the back end

00:01:32,799 --> 00:01:36,720
and so a little background about fast

00:01:35,360 --> 00:01:39,600
api itself

00:01:36,720 --> 00:01:40,240
fast api is a python based framework for

00:01:39,600 --> 00:01:43,840
building

00:01:40,240 --> 00:01:48,240
rest apis that was created in 2019

00:01:43,840 --> 00:01:50,799
by sebastian ramirez tiangalo on github

00:01:48,240 --> 00:01:53,439
it was initially built as a way to

00:01:50,799 --> 00:01:54,159
streamline a number of issues with api

00:01:53,439 --> 00:01:57,520
development

00:01:54,159 --> 00:01:58,320
and over time it became a very popular

00:01:57,520 --> 00:02:01,439
solution

00:01:58,320 --> 00:02:03,840
for lightweight and performant api

00:02:01,439 --> 00:02:03,840
design

00:02:04,399 --> 00:02:09,440
so why am i doing this talk on fast api

00:02:07,920 --> 00:02:11,680
as opposed to

00:02:09,440 --> 00:02:14,160
any other python web framework why am i

00:02:11,680 --> 00:02:17,440
doing it on fast api instead of

00:02:14,160 --> 00:02:20,840
flask or django

00:02:17,440 --> 00:02:22,160
and for me it really boils down to three

00:02:20,840 --> 00:02:24,800
reasons

00:02:22,160 --> 00:02:25,920
the first reason is that fast api is a

00:02:24,800 --> 00:02:28,800
very batteries

00:02:25,920 --> 00:02:30,319
included framework it contains a lot of

00:02:28,800 --> 00:02:32,560
features that help to

00:02:30,319 --> 00:02:34,959
streamline the process of developing and

00:02:32,560 --> 00:02:37,440
documenting your api

00:02:34,959 --> 00:02:40,400
meaning that it's a fantastic solution

00:02:37,440 --> 00:02:42,640
for rapid application development

00:02:40,400 --> 00:02:44,160
so you may already see some interesting

00:02:42,640 --> 00:02:47,440
things on this list

00:02:44,160 --> 00:02:48,959
automatic json serialization generated

00:02:47,440 --> 00:02:52,400
documentation

00:02:48,959 --> 00:02:53,840
easy data validation each of these i'm

00:02:52,400 --> 00:02:54,480
going to go into a little bit more

00:02:53,840 --> 00:02:57,920
detail

00:02:54,480 --> 00:03:00,720
over the course of this talk

00:02:57,920 --> 00:03:03,040
the second reason is that out of a lot

00:03:00,720 --> 00:03:05,440
of the other frameworks i've used

00:03:03,040 --> 00:03:07,120
i feel that fast api is one of the most

00:03:05,440 --> 00:03:09,280
pythonic

00:03:07,120 --> 00:03:10,159
so if you've read the zen of python

00:03:09,280 --> 00:03:13,280
before

00:03:10,159 --> 00:03:16,239
you'll know that python highlights flow

00:03:13,280 --> 00:03:17,200
explicitness and readability as things

00:03:16,239 --> 00:03:19,760
to strive for

00:03:17,200 --> 00:03:20,800
in design and practice and what you'll

00:03:19,760 --> 00:03:23,920
see with a lot of

00:03:20,800 --> 00:03:27,920
fast dip api applications is

00:03:23,920 --> 00:03:28,640
that those sorts of principles will sort

00:03:27,920 --> 00:03:31,680
of flow

00:03:28,640 --> 00:03:34,239
automatically from the way that we write

00:03:31,680 --> 00:03:37,519
fast api functions

00:03:34,239 --> 00:03:38,480
sparseness simplicity and readability

00:03:37,519 --> 00:03:41,760
are sort of

00:03:38,480 --> 00:03:44,640
baked into the framework and

00:03:41,760 --> 00:03:45,440
lastly probably because of the previous

00:03:44,640 --> 00:03:48,879
two points

00:03:45,440 --> 00:03:50,799
i believe the fast api is uh great for

00:03:48,879 --> 00:03:52,080
both those who are new to api

00:03:50,799 --> 00:03:55,439
development

00:03:52,080 --> 00:03:58,400
as well as advanced api developers

00:03:55,439 --> 00:04:00,959
so i feel that even if you don't stick

00:03:58,400 --> 00:04:02,560
with fast api as a tool

00:04:00,959 --> 00:04:04,720
it allows you to get a better

00:04:02,560 --> 00:04:05,680
understanding of how apis are put

00:04:04,720 --> 00:04:10,000
together

00:04:05,680 --> 00:04:10,000
and how they can be used in practice

00:04:10,080 --> 00:04:14,159
and so there are a couple of main

00:04:11,760 --> 00:04:17,680
factors that go into how fast api

00:04:14,159 --> 00:04:20,639
works i've illustrated a couple here

00:04:17,680 --> 00:04:22,960
on top is starlet which is an

00:04:20,639 --> 00:04:26,639
asynchronous server gateway interface

00:04:22,960 --> 00:04:29,120
that fast api uses to

00:04:26,639 --> 00:04:29,680
interface directly with the web it uses

00:04:29,120 --> 00:04:32,639
it to

00:04:29,680 --> 00:04:33,520
become a web application essentially and

00:04:32,639 --> 00:04:36,320
pedantic

00:04:33,520 --> 00:04:37,840
of which we use for some more advanced

00:04:36,320 --> 00:04:41,360
to data validation

00:04:37,840 --> 00:04:42,160
and the creation of schemas that we will

00:04:41,360 --> 00:04:45,759
use

00:04:42,160 --> 00:04:48,800
in our fast api application and

00:04:45,759 --> 00:04:52,400
of course i would be remiss to mention

00:04:48,800 --> 00:04:54,320
the open api specification

00:04:52,400 --> 00:04:56,800
this is actually one of the most

00:04:54,320 --> 00:04:59,199
important factors of fast api

00:04:56,800 --> 00:05:00,320
as nearly every facet of the framework

00:04:59,199 --> 00:05:04,000
serves to build out

00:05:00,320 --> 00:05:08,000
an open api schema that can be

00:05:04,000 --> 00:05:12,479
used for documentation portability

00:05:08,000 --> 00:05:18,080
and generally creating a very

00:05:12,479 --> 00:05:18,080
cohesive and well-documented api

00:05:18,400 --> 00:05:21,919
now i'm going to step into some code

00:05:20,080 --> 00:05:24,160
examples for fast api

00:05:21,919 --> 00:05:25,520
uh to both show how the tool looks in

00:05:24,160 --> 00:05:27,520
practice and to

00:05:25,520 --> 00:05:30,400
highlight some of the points i made

00:05:27,520 --> 00:05:32,560
earlier in the introduction

00:05:30,400 --> 00:05:34,800
i'm going to start with how every fast

00:05:32,560 --> 00:05:37,919
api application starts

00:05:34,800 --> 00:05:40,080
simply by importing a fast api object

00:05:37,919 --> 00:05:44,080
and instantiating it

00:05:40,080 --> 00:05:47,120
this just creates a blank

00:05:44,080 --> 00:05:49,120
application and open api schema that

00:05:47,120 --> 00:05:52,639
will be able to build out further

00:05:49,120 --> 00:05:55,919
with the code we write

00:05:52,639 --> 00:05:59,440
so very briefly this

00:05:55,919 --> 00:06:00,560
is what most fast api endpoints are

00:05:59,440 --> 00:06:04,720
going to look like

00:06:00,560 --> 00:06:06,720
as code if you've ever used flask before

00:06:04,720 --> 00:06:08,160
this will look very familiar to you

00:06:06,720 --> 00:06:11,680
especially with the

00:06:08,160 --> 00:06:15,199
function decorator at the top um

00:06:11,680 --> 00:06:18,560
fast api has taken a little bit of

00:06:15,199 --> 00:06:21,199
inspiration from flask in this respect

00:06:18,560 --> 00:06:23,199
but for the most part this is just

00:06:21,199 --> 00:06:26,080
simple python code

00:06:23,199 --> 00:06:27,039
um but there are a few features here

00:06:26,080 --> 00:06:30,240
that i want to dig

00:06:27,039 --> 00:06:30,720
into because they show up consistently

00:06:30,240 --> 00:06:34,160
within

00:06:30,720 --> 00:06:37,600
fast api applications so

00:06:34,160 --> 00:06:40,960
the first one is the request method

00:06:37,600 --> 00:06:44,560
as you can see here circled in red

00:06:40,960 --> 00:06:47,199
it is the it corresponds to the

00:06:44,560 --> 00:06:48,639
http request used to access this

00:06:47,199 --> 00:06:52,080
resource

00:06:48,639 --> 00:06:53,919
so in this case a get request fast api

00:06:52,080 --> 00:06:55,759
has support for each of the standard

00:06:53,919 --> 00:06:59,919
http request methods

00:06:55,759 --> 00:07:01,599
so get post put and delete

00:06:59,919 --> 00:07:02,960
as well as some of the less commonly

00:07:01,599 --> 00:07:07,199
used ones like head and

00:07:02,960 --> 00:07:08,479
options and secondly we have the route

00:07:07,199 --> 00:07:12,800
this is going to show

00:07:08,479 --> 00:07:16,319
where relative to our you root url

00:07:12,800 --> 00:07:18,800
this resource will be located so we have

00:07:16,319 --> 00:07:19,759
we also have a path parameter here which

00:07:18,800 --> 00:07:22,479
is enclosed

00:07:19,759 --> 00:07:24,319
in the curly braces the recipe

00:07:22,479 --> 00:07:27,759
underscore id

00:07:24,319 --> 00:07:30,960
this syntax allows fast api to know to

00:07:27,759 --> 00:07:33,280
use this information the below method

00:07:30,960 --> 00:07:35,520
and as you can see in the method itself

00:07:33,280 --> 00:07:38,080
the recipe underscore id

00:07:35,520 --> 00:07:39,360
is repeated underneath as an argument

00:07:38,080 --> 00:07:42,800
and following

00:07:39,360 --> 00:07:44,639
that argument is the

00:07:42,800 --> 00:07:46,720
type hint to indicate the path

00:07:44,639 --> 00:07:49,199
parameters type

00:07:46,720 --> 00:07:51,680
in most python programs type hints are

00:07:49,199 --> 00:07:54,400
more of a documentation feature

00:07:51,680 --> 00:07:57,440
meant to show what type parameters are

00:07:54,400 --> 00:07:59,280
expected to be when we call a function

00:07:57,440 --> 00:08:01,680
but we won't be the ones really calling

00:07:59,280 --> 00:08:04,800
the function as developers

00:08:01,680 --> 00:08:05,440
that's more going to be exported out to

00:08:04,800 --> 00:08:09,120
people who

00:08:05,440 --> 00:08:13,360
aren't going to know what this entire

00:08:09,120 --> 00:08:16,160
interface looks like so this exists

00:08:13,360 --> 00:08:17,919
not for us to call these functions but

00:08:16,160 --> 00:08:19,039
rather to validate the data that's

00:08:17,919 --> 00:08:22,240
coming into them

00:08:19,039 --> 00:08:25,520
in this way fast api uses type hints

00:08:22,240 --> 00:08:27,280
as more of a functional tool if we were

00:08:25,520 --> 00:08:29,599
to

00:08:27,280 --> 00:08:31,919
send a request to this route but the

00:08:29,599 --> 00:08:33,279
recipe id was a string rather than an

00:08:31,919 --> 00:08:36,959
integer

00:08:33,279 --> 00:08:36,959
it would throw an error

00:08:37,120 --> 00:08:44,240
and so that was a good example of

00:08:40,560 --> 00:08:45,279
a route with a path parameter but what

00:08:44,240 --> 00:08:48,000
if we wanted to

00:08:45,279 --> 00:08:49,600
access a resource using something like a

00:08:48,000 --> 00:08:52,399
query string

00:08:49,600 --> 00:08:53,519
rather than having it just included

00:08:52,399 --> 00:08:56,640
within the url

00:08:53,519 --> 00:08:58,959
path and we can actually

00:08:56,640 --> 00:09:01,279
do this very easily by simply not

00:08:58,959 --> 00:09:03,519
including a path parameter in the

00:09:01,279 --> 00:09:06,160
initial route argument

00:09:03,519 --> 00:09:06,720
fast api will detect that the recipe id

00:09:06,160 --> 00:09:10,000
argument

00:09:06,720 --> 00:09:13,200
has no has no equivalence

00:09:10,000 --> 00:09:15,279
in the route and it will determine that

00:09:13,200 --> 00:09:19,440
this needs to be included within

00:09:15,279 --> 00:09:21,600
the query string and as you can see

00:09:19,440 --> 00:09:23,279
both of these methods will return the

00:09:21,600 --> 00:09:25,440
same results from our data source

00:09:23,279 --> 00:09:27,600
but the way that they are reached is

00:09:25,440 --> 00:09:29,360
different the one on top

00:09:27,600 --> 00:09:30,880
using the path parameter and the one on

00:09:29,360 --> 00:09:34,240
the bottom using the

00:09:30,880 --> 00:09:36,240
query parameter but both methods have

00:09:34,240 --> 00:09:39,200
the ability to use multiple path or

00:09:36,240 --> 00:09:39,200
query parameters

00:09:39,279 --> 00:09:43,040
now those examples showed using python

00:09:42,240 --> 00:09:45,680
type hints

00:09:43,040 --> 00:09:46,720
for data validation and this works well

00:09:45,680 --> 00:09:49,440
if we only have

00:09:46,720 --> 00:09:52,000
one or two variables to validate but

00:09:49,440 --> 00:09:54,160
what if a user wants to add or update a

00:09:52,000 --> 00:09:57,040
recipe to this api

00:09:54,160 --> 00:09:59,600
that would require validating a whole

00:09:57,040 --> 00:10:02,560
recipe object you know name description

00:09:59,600 --> 00:10:05,600
calories and this is actually where

00:10:02,560 --> 00:10:09,200
pedantic comes in

00:10:05,600 --> 00:10:13,200
so pedantic allows us to make schemas

00:10:09,200 --> 00:10:15,440
which sort of type everything out every

00:10:13,200 --> 00:10:16,720
variable within a schema is associated

00:10:15,440 --> 00:10:18,640
with a type

00:10:16,720 --> 00:10:20,560
this is an example of a schema we

00:10:18,640 --> 00:10:21,680
created to fill the role of a recipe

00:10:20,560 --> 00:10:24,880
object

00:10:21,680 --> 00:10:27,519
using pidentic space model class and so

00:10:24,880 --> 00:10:29,200
as you can see it uses the same sort of

00:10:27,519 --> 00:10:31,360
type hints that we saw

00:10:29,200 --> 00:10:32,720
earlier in the arguments for our get

00:10:31,360 --> 00:10:34,560
functions

00:10:32,720 --> 00:10:36,560
but now they're serving to build out a

00:10:34,560 --> 00:10:38,240
model of what a recipe is going to look

00:10:36,560 --> 00:10:41,200
like

00:10:38,240 --> 00:10:42,560
so roughly speaking this is comparable

00:10:41,200 --> 00:10:46,160
to something we would do

00:10:42,560 --> 00:10:47,519
in django where we would define models

00:10:46,160 --> 00:10:50,160
for our data

00:10:47,519 --> 00:10:51,120
the only difference being this doesn't

00:10:50,160 --> 00:10:54,320
really require

00:10:51,120 --> 00:10:55,040
an external data store like sqlite this

00:10:54,320 --> 00:10:59,200
is more

00:10:55,040 --> 00:11:00,959
just defining what the data should look

00:10:59,200 --> 00:11:02,800
like

00:11:00,959 --> 00:11:05,440
the application of these schemas is

00:11:02,800 --> 00:11:08,640
actually very similar to how fast api

00:11:05,440 --> 00:11:12,000
used primitives for type checking before

00:11:08,640 --> 00:11:14,640
we simply have a type hint set up for

00:11:12,000 --> 00:11:16,000
the recipe type rather than any

00:11:14,640 --> 00:11:19,519
primitive

00:11:16,000 --> 00:11:21,680
and when we specify a when we specify a

00:11:19,519 --> 00:11:24,240
function like this

00:11:21,680 --> 00:11:25,279
fast api is automatically configured to

00:11:24,240 --> 00:11:27,920
check the request

00:11:25,279 --> 00:11:31,680
body for this information rather than

00:11:27,920 --> 00:11:31,680
the path or the query string

00:11:31,760 --> 00:11:35,600
and because the query body and path

00:11:34,800 --> 00:11:37,680
parameters

00:11:35,600 --> 00:11:40,480
all have a unique way of being referred

00:11:37,680 --> 00:11:42,399
to within the functions themselves

00:11:40,480 --> 00:11:44,160
you can actually safely mix these

00:11:42,399 --> 00:11:47,120
parameters within a function

00:11:44,160 --> 00:11:50,480
and fast api will automatically detect

00:11:47,120 --> 00:11:53,200
where each parameter is coming from

00:11:50,480 --> 00:11:54,800
so for instance here's an example of a

00:11:53,200 --> 00:11:56,320
function that will allow a user to

00:11:54,800 --> 00:11:59,839
update a recipe

00:11:56,320 --> 00:12:03,120
it takes just two arguments a recipe id

00:11:59,839 --> 00:12:05,120
and a recipe object and

00:12:03,120 --> 00:12:06,320
just from this information alone fast

00:12:05,120 --> 00:12:08,959
api

00:12:06,320 --> 00:12:10,399
knows to interpret the recipe id as a

00:12:08,959 --> 00:12:13,040
query parameter

00:12:10,399 --> 00:12:15,440
and the recipe object as a body

00:12:13,040 --> 00:12:18,240
parameter

00:12:15,440 --> 00:12:20,320
fast api also gives us tools to validate

00:12:18,240 --> 00:12:24,000
these parameters using more than just

00:12:20,320 --> 00:12:25,839
python type hints so for each

00:12:24,000 --> 00:12:27,600
of the parameter types that we talked

00:12:25,839 --> 00:12:29,760
about fast api

00:12:27,600 --> 00:12:32,079
also includes a dedicated class to

00:12:29,760 --> 00:12:35,600
represent these parameters

00:12:32,079 --> 00:12:38,160
this example shows using the query class

00:12:35,600 --> 00:12:40,959
for a query parameter to further

00:12:38,160 --> 00:12:43,839
validate one of our get methods

00:12:40,959 --> 00:12:45,760
in this case we want to ensure that the

00:12:43,839 --> 00:12:46,639
user isn't entering a number less than

00:12:45,760 --> 00:12:49,040
one

00:12:46,639 --> 00:12:51,360
so we specify the default for the recipe

00:12:49,040 --> 00:12:54,880
id argument to be a query parameter

00:12:51,360 --> 00:12:58,000
that is greater than one if you try

00:12:54,880 --> 00:12:58,480
and access this resource with a recipe

00:12:58,000 --> 00:13:01,839
id

00:12:58,480 --> 00:13:04,560
that's say negative one this will also

00:13:01,839 --> 00:13:04,560
throw an error

00:13:05,040 --> 00:13:09,519
and so this is the swagger ui that was

00:13:07,440 --> 00:13:10,399
created when we first instantiated our

00:13:09,519 --> 00:13:12,880
fast api

00:13:10,399 --> 00:13:14,160
app you can see each of the endpoints

00:13:12,880 --> 00:13:16,880
that i talked about

00:13:14,160 --> 00:13:18,880
uh listed underneath and this

00:13:16,880 --> 00:13:20,720
documentation was sort of generated

00:13:18,880 --> 00:13:22,800
in the background just from defining

00:13:20,720 --> 00:13:24,560
those methods earlier

00:13:22,800 --> 00:13:26,240
this interface not only shows the

00:13:24,560 --> 00:13:28,959
endpoints and schemas

00:13:26,240 --> 00:13:31,200
that we've defined but also allows

00:13:28,959 --> 00:13:32,320
developers to run tests on each of these

00:13:31,200 --> 00:13:34,160
functions

00:13:32,320 --> 00:13:35,600
to make sure that they're working

00:13:34,160 --> 00:13:38,639
properly

00:13:35,600 --> 00:13:40,320
now this is good on its own but this is

00:13:38,639 --> 00:13:41,760
just what we've generated with the code

00:13:40,320 --> 00:13:43,519
that's already been written

00:13:41,760 --> 00:13:45,920
uh what did what if we wanted to

00:13:43,519 --> 00:13:47,760
document this api further

00:13:45,920 --> 00:13:50,320
um and we're going to look at the

00:13:47,760 --> 00:13:53,120
functionality that allows us to do that

00:13:50,320 --> 00:13:55,040
uh each fast api method can have

00:13:53,120 --> 00:13:55,839
arguments entered into their decorator

00:13:55,040 --> 00:13:58,959
function

00:13:55,839 --> 00:14:01,120
to further document each endpoint

00:13:58,959 --> 00:14:02,880
so in this example i've changed the

00:14:01,120 --> 00:14:05,120
summary of the endpoint

00:14:02,880 --> 00:14:07,920
and added a description to it to be

00:14:05,120 --> 00:14:09,680
displayed in the documentation page

00:14:07,920 --> 00:14:11,839
this is actually just inserting the

00:14:09,680 --> 00:14:13,760
metadata straight into the open api

00:14:11,839 --> 00:14:16,560
schema that we've been building

00:14:13,760 --> 00:14:17,199
so any documentation entered here will

00:14:16,560 --> 00:14:19,680
persist

00:14:17,199 --> 00:14:23,040
in the application itself regardless of

00:14:19,680 --> 00:14:24,880
if we export the schema elsewhere

00:14:23,040 --> 00:14:26,399
and as you can see when we go back into

00:14:24,880 --> 00:14:28,240
the open api docs

00:14:26,399 --> 00:14:29,440
when we expand this endpoint in

00:14:28,240 --> 00:14:31,760
particular

00:14:29,440 --> 00:14:32,720
the extra documentation that we just

00:14:31,760 --> 00:14:36,480
entered

00:14:32,720 --> 00:14:38,399
is now included for this end point

00:14:36,480 --> 00:14:40,480
and this process can be repeated for

00:14:38,399 --> 00:14:43,040
other parts of fast api

00:14:40,480 --> 00:14:45,519
the fast api object itself can receive

00:14:43,040 --> 00:14:47,680
arguments such as title and description

00:14:45,519 --> 00:14:50,079
and those will be seen at the top of the

00:14:47,680 --> 00:14:52,880
interactive documentation when you

00:14:50,079 --> 00:14:58,079
save the source code for it as you can

00:14:52,880 --> 00:15:00,079
see there we've got example recipe api

00:14:58,079 --> 00:15:01,120
now i'm going to step into some features

00:15:00,079 --> 00:15:03,360
of fast api

00:15:01,120 --> 00:15:05,760
that while not going to be used in every

00:15:03,360 --> 00:15:08,079
case are still useful enough to api

00:15:05,760 --> 00:15:09,519
developers that they weren't mentioning

00:15:08,079 --> 00:15:11,360
and i'm going to start with some

00:15:09,519 --> 00:15:13,279
different response types

00:15:11,360 --> 00:15:14,959
the examples you've already seen were

00:15:13,279 --> 00:15:16,160
functions that returned python

00:15:14,959 --> 00:15:18,240
dictionaries

00:15:16,160 --> 00:15:20,240
and fast api was automatically

00:15:18,240 --> 00:15:23,760
serializing those dictionaries to

00:15:20,240 --> 00:15:25,519
json but fast api also includes a number

00:15:23,760 --> 00:15:26,399
of classes that allow us to create

00:15:25,519 --> 00:15:29,519
responses

00:15:26,399 --> 00:15:29,519
in other formats

00:15:29,920 --> 00:15:33,519
this is an example of a function using

00:15:31,920 --> 00:15:36,639
an html response

00:15:33,519 --> 00:15:38,240
as opposed to a json response the class

00:15:36,639 --> 00:15:38,639
that allows for the different response

00:15:38,240 --> 00:15:41,120
type

00:15:38,639 --> 00:15:42,959
is entered in through the decorator

00:15:41,120 --> 00:15:44,880
function like how the documentation from

00:15:42,959 --> 00:15:47,759
before was entered

00:15:44,880 --> 00:15:48,959
this allows us to serve our alternative

00:15:47,759 --> 00:15:51,600
response class

00:15:48,959 --> 00:15:52,720
as opposed to the default json response

00:15:51,600 --> 00:15:55,120
class

00:15:52,720 --> 00:15:56,320
when a user visits this route in our app

00:15:55,120 --> 00:15:59,440
the data will be

00:15:56,320 --> 00:15:59,440
in html

00:16:00,399 --> 00:16:04,480
fast api has a support for a number of

00:16:02,560 --> 00:16:06,639
other response types which allow your

00:16:04,480 --> 00:16:07,680
application to enable streaming binary

00:16:06,639 --> 00:16:10,560
data

00:16:07,680 --> 00:16:12,480
serve files to users and even standard

00:16:10,560 --> 00:16:14,800
web pages

00:16:12,480 --> 00:16:17,199
it also includes an extendable response

00:16:14,800 --> 00:16:18,639
class which allows you to customize the

00:16:17,199 --> 00:16:21,040
format of the data

00:16:18,639 --> 00:16:22,079
that you're sending so for instance if

00:16:21,040 --> 00:16:25,440
you have a legacy

00:16:22,079 --> 00:16:28,480
api that you need to maintain and you

00:16:25,440 --> 00:16:31,279
want to send your data in xml

00:16:28,480 --> 00:16:34,480
rather than json you can extend out the

00:16:31,279 --> 00:16:38,079
response class to provide that data

00:16:34,480 --> 00:16:38,639
so fast api also has built-in websocket

00:16:38,079 --> 00:16:40,720
support

00:16:38,639 --> 00:16:42,399
for two-way communication between

00:16:40,720 --> 00:16:44,800
clients and servers

00:16:42,399 --> 00:16:46,560
uh the way we would declare a websocket

00:16:44,800 --> 00:16:47,519
is actually very similar to the way that

00:16:46,560 --> 00:16:50,959
we would declare

00:16:47,519 --> 00:16:53,519
an http endpoint simply creating a

00:16:50,959 --> 00:16:56,560
function using the websocket decorator

00:16:53,519 --> 00:16:58,800
and passing in a websocket object as its

00:16:56,560 --> 00:17:01,279
only argument

00:16:58,800 --> 00:17:03,279
this enables real-time data to be set

00:17:01,279 --> 00:17:05,199
between the client and the server

00:17:03,279 --> 00:17:06,799
enabling features like push

00:17:05,199 --> 00:17:10,480
notifications or events

00:17:06,799 --> 00:17:11,280
to be sent to the client so i'd also

00:17:10,480 --> 00:17:13,679
like to mention

00:17:11,280 --> 00:17:15,280
some very useful third-party tools that

00:17:13,679 --> 00:17:18,640
are available to augment

00:17:15,280 --> 00:17:21,919
fast api's functionality

00:17:18,640 --> 00:17:24,559
so first the fast api code generator

00:17:21,919 --> 00:17:26,319
this greatly enhances the open api

00:17:24,559 --> 00:17:28,720
aspect of fast api

00:17:26,319 --> 00:17:31,200
as it allows you to take any open api

00:17:28,720 --> 00:17:31,679
schema and generate an entire project

00:17:31,200 --> 00:17:35,200
from it

00:17:31,679 --> 00:17:38,640
including endpoints object schemas

00:17:35,200 --> 00:17:38,640
and documentation

00:17:38,720 --> 00:17:43,840
pedantic sql alchemy now this one is

00:17:41,520 --> 00:17:45,600
less third-party than the others because

00:17:43,840 --> 00:17:47,039
it is also developed by sebastian

00:17:45,600 --> 00:17:48,880
ramirez

00:17:47,039 --> 00:17:51,360
but i feel that it's useful enough that

00:17:48,880 --> 00:17:53,280
it warrants pudding here

00:17:51,360 --> 00:17:54,559
this library allows you to create

00:17:53,280 --> 00:17:57,600
pedantic models

00:17:54,559 --> 00:17:58,480
straight from sql alchemy models if

00:17:57,600 --> 00:18:01,600
you're using a

00:17:58,480 --> 00:18:04,160
sql database for your data store

00:18:01,600 --> 00:18:06,320
this makes the process of using fast api

00:18:04,160 --> 00:18:09,440
to represent those resources

00:18:06,320 --> 00:18:09,440
much much easier

00:18:09,760 --> 00:18:14,559
fast api pagination and the closest

00:18:12,880 --> 00:18:16,960
thing to compare this one to

00:18:14,559 --> 00:18:18,160
is django rest framework style

00:18:16,960 --> 00:18:19,760
pagination

00:18:18,160 --> 00:18:21,600
uh where you would have pagination

00:18:19,760 --> 00:18:24,880
pagination classes

00:18:21,600 --> 00:18:26,720
and a number of results to limit from

00:18:24,880 --> 00:18:29,280
each json response

00:18:26,720 --> 00:18:32,080
and this can become very useful if you

00:18:29,280 --> 00:18:33,840
have a very large data store with a

00:18:32,080 --> 00:18:36,640
large number of objects that you are

00:18:33,840 --> 00:18:38,640
going to be serving to the user as it

00:18:36,640 --> 00:18:43,039
limits the amount of resources going to

00:18:38,640 --> 00:18:46,559
be used by your server at any one time

00:18:43,039 --> 00:18:49,600
and finally i want to mention

00:18:46,559 --> 00:18:52,400
awesome fast api which is a list

00:18:49,600 --> 00:18:55,440
of third-party tools and resources

00:18:52,400 --> 00:18:57,919
curated by michael herman on github

00:18:55,440 --> 00:19:01,919
on which you can find the source for

00:18:57,919 --> 00:19:04,160
many of these including the three above

00:19:01,919 --> 00:19:06,799
and now i'd like to wrap up by going

00:19:04,160 --> 00:19:09,039
over some of the key points of the talk

00:19:06,799 --> 00:19:11,200
this talk tried to cover a lot of ground

00:19:09,039 --> 00:19:13,840
but there are a few important things

00:19:11,200 --> 00:19:17,039
that are worth restating here

00:19:13,840 --> 00:19:20,400
the first is that fast api is built on

00:19:17,039 --> 00:19:22,320
open api starlet and pedantic

00:19:20,400 --> 00:19:24,320
each of these tools are very lightweight

00:19:22,320 --> 00:19:27,280
and provide features necessary

00:19:24,320 --> 00:19:29,600
for fast api to create apis quickly and

00:19:27,280 --> 00:19:32,400
easily

00:19:29,600 --> 00:19:33,360
secondly the features of open api allow

00:19:32,400 --> 00:19:35,840
the use of

00:19:33,360 --> 00:19:37,440
built-in documentation the features of

00:19:35,840 --> 00:19:40,400
pedantic allow for

00:19:37,440 --> 00:19:42,720
ease easy data validation when sending

00:19:40,400 --> 00:19:46,400
json to the api

00:19:42,720 --> 00:19:47,919
and fast api itself serializes and

00:19:46,400 --> 00:19:50,960
outputs json from

00:19:47,919 --> 00:19:53,679
standard python dictionaries

00:19:50,960 --> 00:19:54,320
all of these advantages add up to fast

00:19:53,679 --> 00:19:57,200
api

00:19:54,320 --> 00:19:58,960
being a very performant pythonic and

00:19:57,200 --> 00:20:01,280
accessible framework

00:19:58,960 --> 00:20:04,159
fast api allows developers to do

00:20:01,280 --> 00:20:07,520
previously very complicated tasks

00:20:04,159 --> 00:20:10,240
very quickly because of this

00:20:07,520 --> 00:20:11,919
fast api uses the type hints introduced

00:20:10,240 --> 00:20:13,760
in python 3.6

00:20:11,919 --> 00:20:17,039
in order to perform simple data

00:20:13,760 --> 00:20:18,960
validation on parameters used by the api

00:20:17,039 --> 00:20:21,360
and this allows us to easily and

00:20:18,960 --> 00:20:22,400
reliably validate data with a very low

00:20:21,360 --> 00:20:25,919
code footprint

00:20:22,400 --> 00:20:28,080
compared to alternate methods

00:20:25,919 --> 00:20:29,440
these type hints are also used within

00:20:28,080 --> 00:20:32,080
pedantic schemas

00:20:29,440 --> 00:20:33,840
allowing us to validate json objects

00:20:32,080 --> 00:20:35,039
supplied through post requests to our

00:20:33,840 --> 00:20:37,440
api

00:20:35,039 --> 00:20:38,640
this also creates a schema definition

00:20:37,440 --> 00:20:41,360
within open api

00:20:38,640 --> 00:20:44,320
allowing us to document more information

00:20:41,360 --> 00:20:47,200
on our application

00:20:44,320 --> 00:20:49,360
and since fast api handles each type of

00:20:47,200 --> 00:20:51,919
parameter in a different way

00:20:49,360 --> 00:20:52,720
every parameter type can be freely mixed

00:20:51,919 --> 00:20:55,760
together without

00:20:52,720 --> 00:20:58,480
needing to add any extra code to ensure

00:20:55,760 --> 00:21:00,400
compatibility

00:20:58,480 --> 00:21:02,240
and since all of this information is

00:21:00,400 --> 00:21:05,840
automatically inserted into

00:21:02,240 --> 00:21:07,679
by fast api into the open api schema

00:21:05,840 --> 00:21:10,640
interactive documentation can be

00:21:07,679 --> 00:21:13,280
generated just from the code we write

00:21:10,640 --> 00:21:14,880
we can also add manual documentation to

00:21:13,280 --> 00:21:17,520
the api

00:21:14,880 --> 00:21:19,840
each endpoint and each schema that we

00:21:17,520 --> 00:21:19,840
build

00:21:20,480 --> 00:21:24,000
fast api has many response classes that

00:21:23,120 --> 00:21:27,039
allow us to

00:21:24,000 --> 00:21:30,640
customize the type of ap api we want to

00:21:27,039 --> 00:21:34,240
build or design and allows serving files

00:21:30,640 --> 00:21:36,960
streaming data and html stuff that

00:21:34,240 --> 00:21:37,840
isn't typically included within an api

00:21:36,960 --> 00:21:40,320
but

00:21:37,840 --> 00:21:41,760
fast api has the flexibility to provide

00:21:40,320 --> 00:21:43,840
us

00:21:41,760 --> 00:21:46,480
fast api also allows us to use

00:21:43,840 --> 00:21:48,320
websockets enabling real-time two-way

00:21:46,480 --> 00:21:50,080
communication between the client and

00:21:48,320 --> 00:21:52,720
server

00:21:50,080 --> 00:21:54,720
and fast api also has a great amount of

00:21:52,720 --> 00:21:56,799
developer support behind it in the form

00:21:54,720 --> 00:22:00,159
of third-party libraries that exist

00:21:56,799 --> 00:22:03,520
to enhance its functionality

00:22:00,159 --> 00:22:05,440
so in conclusion fast api leverages the

00:22:03,520 --> 00:22:08,880
features of python to create

00:22:05,440 --> 00:22:11,120
fast intuitive apis with very little

00:22:08,880 --> 00:22:13,600
code needed

00:22:11,120 --> 00:22:15,440
this in turn makes fast api a great

00:22:13,600 --> 00:22:17,360
choice for projects that incorporate

00:22:15,440 --> 00:22:19,280
rapid application development

00:22:17,360 --> 00:22:23,039
as it minimizes the time needed to

00:22:19,280 --> 00:22:25,280
create a viable application

00:22:23,039 --> 00:22:27,840
i hope that i've done a good job of

00:22:25,280 --> 00:22:29,120
explaining what fast api's benefits are

00:22:27,840 --> 00:22:31,200
how it can be used to build out

00:22:29,120 --> 00:22:32,480
applications and how to start coding

00:22:31,200 --> 00:22:35,919
with it

00:22:32,480 --> 00:22:38,320
and the rest is up to you

00:22:35,919 --> 00:22:39,440
so thanks to everybody that made this

00:22:38,320 --> 00:22:41,200
possible

00:22:39,440 --> 00:22:43,520
i'd like to give a special thanks to the

00:22:41,200 --> 00:22:46,400
python software foundation

00:22:43,520 --> 00:22:46,799
sebastian ramirez for creating fast api

00:22:46,400 --> 00:22:49,280
uh

00:22:46,799 --> 00:22:50,880
fast api contributors for contributing

00:22:49,280 --> 00:22:52,880
to fast api

00:22:50,880 --> 00:22:56,400
michael herrmann for curating the list

00:22:52,880 --> 00:22:59,520
on third party fast api libraries

00:22:56,400 --> 00:23:09,840
and you for attending this talk

00:22:59,520 --> 00:23:09,840
have a great con everybody

00:24:02,000 --> 00:24:04,080

YouTube URL: https://www.youtube.com/watch?v=_jh4Wc3CE38


