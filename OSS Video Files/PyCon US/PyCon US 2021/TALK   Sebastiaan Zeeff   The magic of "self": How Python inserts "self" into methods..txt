Title: TALK   Sebastiaan Zeeff   The magic of "self": How Python inserts "self" into methods.
Publication date: 2021-05-29
Playlist: PyCon US 2021
Description: 
	A phrase that I hear a lot is "Python is easy to learn, but hard to master". In a way that's true: Python is easy to learn because its high level of abstraction allows you to focus on the business logic of what you're trying to do instead of the lower-level implementation details.

At the same time, Python's abstraction isn't magical: Its versatile data model allows you to hook into almost every part of the language to implement objects that behave just as Python's built-in objects do, enabling you to create similarly high-leveled interfaces for your own objects. That's where "hard to master" comes in: There is so much to learn that you're never done learning.

In this talk, I want to entice you to look beyond Python's high-level interface into the wonderful landscape of its data model. I'll do that by explaining one of Python's most "magical" features: The automatic insertion of self into methods. Often, to beginners, the insertion of the instance as the first argument to methods is explained as something that Python just does for you: "Don't worry about it, it just happens!". More intermediate Python programmers typically get so used to self that they hardly notice it anymore in their function signatures, let alone wonder about what's powering it.

To explain this bit of Python magic, I’ll give you an informal introduction to something called descriptors. To be sure, this talk isn’t going to be an in-depth discussion of the finer details of the descriptor protocol. Rather, it’s aimed at advanced beginners and intermediate Python developers who are eager to get an idea of what lies beneath the surface of Python. With this talk, I hope to pique your curiosity about the more advanced features of the Python programming language and hopefully give you a glimpse of all the things that are possible.

Slides: https://sebastiaanzeeff.nl/pycon
Captions: 
	00:00:04,170 --> 00:00:11,869
[Music]

00:00:17,039 --> 00:00:20,000
hello

00:00:17,680 --> 00:00:22,240
let's talk about magic in python because

00:00:20,000 --> 00:00:24,080
there's a lot of magic in python

00:00:22,240 --> 00:00:25,760
there are layers and layers of magical

00:00:24,080 --> 00:00:27,359
abstractions and functionality

00:00:25,760 --> 00:00:29,599
that make python to the high level

00:00:27,359 --> 00:00:32,079
programming language that it is

00:00:29,599 --> 00:00:33,680
in fact recently some people started

00:00:32,079 --> 00:00:35,440
complaining that too much magic was

00:00:33,680 --> 00:00:37,200
being added to the language

00:00:35,440 --> 00:00:39,280
to which hiro van ghosen replied on

00:00:37,200 --> 00:00:40,879
twitter that there's been a lot of magic

00:00:39,280 --> 00:00:42,960
in python from the beginning

00:00:40,879 --> 00:00:44,800
and that it's there to quietly help us

00:00:42,960 --> 00:00:47,600
the users of python

00:00:44,800 --> 00:00:48,079
and it's true that magic is here to help

00:00:47,600 --> 00:00:50,559
you

00:00:48,079 --> 00:00:51,600
and me focus on the business logic of

00:00:50,559 --> 00:00:54,480
our code

00:00:51,600 --> 00:00:56,160
on what we actually want to do instead

00:00:54,480 --> 00:00:59,120
of the lower level details

00:00:56,160 --> 00:01:00,480
that we'd otherwise need to take care of

00:00:59,120 --> 00:01:02,559
at the same time

00:01:00,480 --> 00:01:04,239
using the word magic makes it sounds

00:01:02,559 --> 00:01:06,159
like that we have no hopes

00:01:04,239 --> 00:01:07,840
of ever understanding the mechanisms

00:01:06,159 --> 00:01:09,520
behind this magic

00:01:07,840 --> 00:01:11,360
that we just have to get used to the

00:01:09,520 --> 00:01:13,520
fact that things are done for us

00:01:11,360 --> 00:01:15,119
without ever hoping that we can truly

00:01:13,520 --> 00:01:18,320
understand how it happens

00:01:15,119 --> 00:01:20,479
or even how to make magic of our own

00:01:18,320 --> 00:01:22,240
in this talk i hope to show you that

00:01:20,479 --> 00:01:24,080
that's not true

00:01:22,240 --> 00:01:25,520
a lot of the magic is the kind of magic

00:01:24,080 --> 00:01:29,119
that you and i

00:01:25,520 --> 00:01:31,439
can perform as well to do that

00:01:29,119 --> 00:01:33,920
we're going to look into what i feel is

00:01:31,439 --> 00:01:37,360
one of the most magical things in python

00:01:33,920 --> 00:01:39,200
the insertion of self into methods

00:01:37,360 --> 00:01:42,399
to do that we're going to encounter

00:01:39,200 --> 00:01:45,439
something called the descriptor protocol

00:01:42,399 --> 00:01:54,000
but before diving into self

00:01:45,439 --> 00:01:56,560
i'd like to briefly introduce myself

00:01:54,000 --> 00:01:58,159
name is sebastian i'm 35 years old and i

00:01:56,560 --> 00:02:00,240
live in the netherlands

00:01:58,159 --> 00:02:01,840
i like playing guitar which is something

00:02:00,240 --> 00:02:04,000
that you'll notice later in this talk

00:02:01,840 --> 00:02:06,479
but i also like playing board games or

00:02:04,000 --> 00:02:08,640
going for a walk with my girlfriend

00:02:06,479 --> 00:02:10,239
i work as a python developer for ordina

00:02:08,640 --> 00:02:11,280
which is a consultancy company in the

00:02:10,239 --> 00:02:13,440
netherlands

00:02:11,280 --> 00:02:15,440
i've not been working there for long i

00:02:13,440 --> 00:02:17,840
think it's about six months or so

00:02:15,440 --> 00:02:19,760
but i really enjoy it so far they have a

00:02:17,840 --> 00:02:21,120
really strong python unit and i always

00:02:19,760 --> 00:02:22,879
learn the most from working with other

00:02:21,120 --> 00:02:24,319
great developers

00:02:22,879 --> 00:02:26,560
i'm also one of the three owners of

00:02:24,319 --> 00:02:28,480
python discord an online community of

00:02:26,560 --> 00:02:30,959
python enthusiasts

00:02:28,480 --> 00:02:32,080
we mainly focus on python education and

00:02:30,959 --> 00:02:33,920
python discussion

00:02:32,080 --> 00:02:35,760
but we also organize python related

00:02:33,920 --> 00:02:37,280
events

00:02:35,760 --> 00:02:39,840
in addition since we have a lot of

00:02:37,280 --> 00:02:40,640
motivated volunteers we also try to help

00:02:39,840 --> 00:02:43,280
other

00:02:40,640 --> 00:02:45,200
organizations in the python ecosystem

00:02:43,280 --> 00:02:49,440
think of organizations like the psf

00:02:45,200 --> 00:02:50,800
or pi week or various python conferences

00:02:49,440 --> 00:02:52,160
the last thing that i'd like to mention

00:02:50,800 --> 00:02:54,239
about myself is that i'm also a

00:02:52,160 --> 00:02:55,680
volunteer for europe python

00:02:54,239 --> 00:02:57,440
and the reason that i'd like to mention

00:02:55,680 --> 00:02:59,200
euro python specifically

00:02:57,440 --> 00:03:02,000
is because this year it will be the 20th

00:02:59,200 --> 00:03:04,319
anniversary edition of euro python

00:03:02,000 --> 00:03:05,840
since it's being held online and we're

00:03:04,319 --> 00:03:06,480
trying to accommodate for different time

00:03:05,840 --> 00:03:08,480
zones

00:03:06,480 --> 00:03:10,239
it should be really easy to then to

00:03:08,480 --> 00:03:13,200
attend this anniversary edition

00:03:10,239 --> 00:03:14,400
so you may want to check it out anyway

00:03:13,200 --> 00:03:19,840
that's enough about me

00:03:14,400 --> 00:03:19,840
let's talk about self

00:03:21,680 --> 00:03:25,280
when talking about self and python i

00:03:23,599 --> 00:03:26,640
think it's important to first go back to

00:03:25,280 --> 00:03:28,319
the basics

00:03:26,640 --> 00:03:30,239
one of the reasons for that is that it's

00:03:28,319 --> 00:03:32,239
easy to get used to self

00:03:30,239 --> 00:03:34,319
to not notice the magic that is going on

00:03:32,239 --> 00:03:34,640
anymore especially if you've been broken

00:03:34,319 --> 00:03:37,840
and

00:03:34,640 --> 00:03:39,519
programming in python for a while now i

00:03:37,840 --> 00:03:40,879
also want to go back to the basics to

00:03:39,519 --> 00:03:41,599
make sure that we're all on the same

00:03:40,879 --> 00:03:43,360
page

00:03:41,599 --> 00:03:45,040
regardless of the level of experience

00:03:43,360 --> 00:03:47,120
that we may have

00:03:45,040 --> 00:03:48,720
i'm going to do that by creating a

00:03:47,120 --> 00:03:50,239
simple guitar class

00:03:48,720 --> 00:03:51,840
one that i could use to keep track of

00:03:50,239 --> 00:03:53,439
all the guitars that i've collected over

00:03:51,840 --> 00:03:55,920
the years

00:03:53,439 --> 00:03:57,200
as you can see it's very simple you can

00:03:55,920 --> 00:03:59,360
give a guitar a name

00:03:57,200 --> 00:04:00,560
and the dunder init method will assign

00:03:59,360 --> 00:04:02,799
the attribute name

00:04:00,560 --> 00:04:04,640
to the name you gave it but that's about

00:04:02,799 --> 00:04:06,560
it

00:04:04,640 --> 00:04:08,480
for those of you who are unfamiliar with

00:04:06,560 --> 00:04:08,879
classes this means that we can now

00:04:08,480 --> 00:04:12,000
create

00:04:08,879 --> 00:04:12,400
individual instances of guitars in this

00:04:12,000 --> 00:04:14,159
case

00:04:12,400 --> 00:04:17,440
i'm creating an instance for my favorite

00:04:14,159 --> 00:04:19,600
bass guitar my warwick streamer

00:04:17,440 --> 00:04:21,199
after we created that instance we can

00:04:19,600 --> 00:04:23,040
look up that name attribute

00:04:21,199 --> 00:04:26,560
and we can see that it's really assigned

00:04:23,040 --> 00:04:26,560
to the name that i've given the guitar

00:04:27,199 --> 00:04:31,840
this obviously isn't very interesting

00:04:29,520 --> 00:04:34,720
yet so i'm going to add a method

00:04:31,840 --> 00:04:36,479
this new method play note expects an

00:04:34,720 --> 00:04:37,199
argument the note that the guitar should

00:04:36,479 --> 00:04:39,120
play

00:04:37,199 --> 00:04:40,840
and then it will print a simple message

00:04:39,120 --> 00:04:42,160
saying that the guitar is playing that

00:04:40,840 --> 00:04:44,560
note

00:04:42,160 --> 00:04:46,080
so when i call the method like this

00:04:44,560 --> 00:04:48,720
giving it a musical note c

00:04:46,080 --> 00:04:50,880
sharp as an argument python will print

00:04:48,720 --> 00:04:53,759
my warwick streamer plays the note

00:04:50,880 --> 00:04:55,680
c sharp while this doesn't really look

00:04:53,759 --> 00:04:56,160
magical on its own there is something

00:04:55,680 --> 00:04:58,960
interesting

00:04:56,160 --> 00:05:00,800
going on here if you zoom in on the

00:04:58,960 --> 00:05:01,520
function definition of the plain node

00:05:00,800 --> 00:05:03,840
method

00:05:01,520 --> 00:05:05,680
and the parameter list in specific

00:05:03,840 --> 00:05:07,440
you'll see that the function expects two

00:05:05,680 --> 00:05:10,880
arguments

00:05:07,440 --> 00:05:12,560
for two parameters self and note

00:05:10,880 --> 00:05:14,080
but if you then look at how i've called

00:05:12,560 --> 00:05:16,400
the method you can see that i

00:05:14,080 --> 00:05:17,520
only gave it one argument the note c

00:05:16,400 --> 00:05:19,840
sharp

00:05:17,520 --> 00:05:21,520
it's obvious that the c sharp ended up

00:05:19,840 --> 00:05:23,280
with the parameter note

00:05:21,520 --> 00:05:25,919
but where's the value for self coming

00:05:23,280 --> 00:05:28,800
from why isn't python complaining that

00:05:25,919 --> 00:05:31,199
it's missing one positional argument

00:05:28,800 --> 00:05:32,639
and this is the magic of self when you

00:05:31,199 --> 00:05:34,400
call a method like this

00:05:32,639 --> 00:05:36,479
python will take care of the of

00:05:34,400 --> 00:05:38,639
inserting the instance for you

00:05:36,479 --> 00:05:40,880
what python has done is that it hasn't

00:05:38,639 --> 00:05:42,639
sorted asserted warwick the specific

00:05:40,880 --> 00:05:45,520
guitar we've called the method on

00:05:42,639 --> 00:05:47,759
as the first argument for the function

00:05:45,520 --> 00:05:49,759
to understand the special bit of magic

00:05:47,759 --> 00:05:53,840
we'll have to look at what methods are

00:05:49,759 --> 00:05:53,840
and how they relate to functions

00:05:56,479 --> 00:05:59,919
to look at what methods are and how they

00:05:58,319 --> 00:06:01,280
relate to normal functions

00:05:59,919 --> 00:06:04,240
we need to look at what happens when you

00:06:01,280 --> 00:06:05,680
define a class with methods

00:06:04,240 --> 00:06:07,600
and that's why i'm going to discuss what

00:06:05,680 --> 00:06:09,520
python does when it reads the definition

00:06:07,600 --> 00:06:11,680
of the guitar class

00:06:09,520 --> 00:06:13,199
since everything in python is an object

00:06:11,680 --> 00:06:14,639
including classes

00:06:13,199 --> 00:06:16,319
one thing we know is that we're going to

00:06:14,639 --> 00:06:18,560
end up with a class object

00:06:16,319 --> 00:06:20,000
an instance of type to represent the

00:06:18,560 --> 00:06:21,759
guitar class

00:06:20,000 --> 00:06:24,319
i've drawn this box to represent that

00:06:21,759 --> 00:06:25,840
class object

00:06:24,319 --> 00:06:27,520
now let's zoom in on what happens when

00:06:25,840 --> 00:06:29,120
python reads the definition of the play

00:06:27,520 --> 00:06:30,880
note method

00:06:29,120 --> 00:06:32,880
some people think that because this

00:06:30,880 --> 00:06:35,840
function definition statement

00:06:32,880 --> 00:06:37,520
the def plane node and so on is located

00:06:35,840 --> 00:06:39,280
within the body of a class

00:06:37,520 --> 00:06:40,639
this means that we're creating a special

00:06:39,280 --> 00:06:44,080
kind of object here

00:06:40,639 --> 00:06:45,520
a method object but this is not the case

00:06:44,080 --> 00:06:48,080
this is just a regular function

00:06:45,520 --> 00:06:51,360
definition statement just like the one

00:06:48,080 --> 00:06:53,280
you use outside of classes

00:06:51,360 --> 00:06:54,639
so when python reads this function

00:06:53,280 --> 00:06:56,400
definition statement

00:06:54,639 --> 00:06:57,680
it's going to create a regular function

00:06:56,400 --> 00:06:59,520
object in memory

00:06:57,680 --> 00:07:00,880
there's nothing special going on here

00:06:59,520 --> 00:07:03,199
yet

00:07:00,880 --> 00:07:05,680
but what is important is that a function

00:07:03,199 --> 00:07:08,400
definition statement also assigns a name

00:07:05,680 --> 00:07:10,160
to the function object this option this

00:07:08,400 --> 00:07:12,080
obviously makes sense because we need a

00:07:10,160 --> 00:07:14,400
name to be able to refer to that object

00:07:12,080 --> 00:07:16,080
later

00:07:14,400 --> 00:07:18,960
since we're defining something within a

00:07:16,080 --> 00:07:21,520
class that name will be assigned

00:07:18,960 --> 00:07:22,560
within the namespace of that class more

00:07:21,520 --> 00:07:24,240
specifically

00:07:22,560 --> 00:07:26,400
we're going to assign an attribute of

00:07:24,240 --> 00:07:29,360
the guitar class plain note

00:07:26,400 --> 00:07:30,080
to the function object in memory and

00:07:29,360 --> 00:07:32,560
this is an

00:07:30,080 --> 00:07:34,479
important first piece of the puzzle

00:07:32,560 --> 00:07:38,000
we've assigned the class attribute

00:07:34,479 --> 00:07:40,319
to the function object so in short

00:07:38,000 --> 00:07:41,599
by defining a function within a class

00:07:40,319 --> 00:07:43,840
you're not creating

00:07:41,599 --> 00:07:46,160
a special kind of object yet you're just

00:07:43,840 --> 00:07:48,479
creating a regular function

00:07:46,160 --> 00:07:51,280
but what is important is that it assigns

00:07:48,479 --> 00:07:53,199
a class attribute to the function

00:07:51,280 --> 00:07:54,720
we'll find out why this is important

00:07:53,199 --> 00:07:56,080
when we look at what happens when we try

00:07:54,720 --> 00:07:59,840
to get that function

00:07:56,080 --> 00:07:59,840
using an attribute

00:08:02,080 --> 00:08:06,160
all right let me pull up my python shell

00:08:04,319 --> 00:08:07,919
to demonstrate the magic that happens

00:08:06,160 --> 00:08:09,280
when you access the function using

00:08:07,919 --> 00:08:11,360
attributes

00:08:09,280 --> 00:08:12,800
first i'm going to access the function

00:08:11,360 --> 00:08:16,240
using the class attribute

00:08:12,800 --> 00:08:18,000
guitar dot play note when i hit enter

00:08:16,240 --> 00:08:20,400
you can see that this just returns the

00:08:18,000 --> 00:08:21,840
function itself there's no special magic

00:08:20,400 --> 00:08:24,479
going on yet

00:08:21,840 --> 00:08:25,680
but in python this isn't the only way

00:08:24,479 --> 00:08:27,919
that you can access class

00:08:25,680 --> 00:08:30,879
attributes you can also access them

00:08:27,919 --> 00:08:32,959
using an instance of the class

00:08:30,879 --> 00:08:35,039
so that's why i'm going to recreate my

00:08:32,959 --> 00:08:37,279
warwick instance

00:08:35,039 --> 00:08:38,479
and then i'm going to access the class

00:08:37,279 --> 00:08:40,320
attribute play node

00:08:38,479 --> 00:08:41,519
as if it were an attribute of the

00:08:40,320 --> 00:08:44,000
instance

00:08:41,519 --> 00:08:46,080
now if you think about it this is a bit

00:08:44,000 --> 00:08:48,000
weird my warwick instance doesn't even

00:08:46,080 --> 00:08:50,720
have an attribute called plain note

00:08:48,000 --> 00:08:51,920
this is an attribute of the class but as

00:08:50,720 --> 00:08:54,560
we'll see in a moment

00:08:51,920 --> 00:08:56,399
this just works what roughly happens is

00:08:54,560 --> 00:08:56,880
that python looks for the attribute play

00:08:56,399 --> 00:08:59,120
note

00:08:56,880 --> 00:09:00,320
on the warwick instance and when it

00:08:59,120 --> 00:09:02,880
doesn't find it

00:09:00,320 --> 00:09:04,640
it moves on to look at the class the

00:09:02,880 --> 00:09:05,839
actual lookup sequence is a bit more

00:09:04,640 --> 00:09:08,000
complicated than that

00:09:05,839 --> 00:09:10,000
but this is what roughly happens and

00:09:08,000 --> 00:09:10,720
this is the kind of detail we need right

00:09:10,000 --> 00:09:13,200
now

00:09:10,720 --> 00:09:14,560
all right let's hit enter and see what

00:09:13,200 --> 00:09:17,279
it gets us

00:09:14,560 --> 00:09:19,279
all right it worked but there's also

00:09:17,279 --> 00:09:20,880
something interesting going on here

00:09:19,279 --> 00:09:23,279
instead of getting the raw function

00:09:20,880 --> 00:09:23,760
object back we now get something called

00:09:23,279 --> 00:09:26,560
a

00:09:23,760 --> 00:09:27,760
bound method and this is very much where

00:09:26,560 --> 00:09:29,839
the magic happens

00:09:27,760 --> 00:09:31,279
when you look up attributes in python

00:09:29,839 --> 00:09:32,560
instead of just looking up those

00:09:31,279 --> 00:09:34,720
attributes directly

00:09:32,560 --> 00:09:36,399
as if they were labels you can actually

00:09:34,720 --> 00:09:38,720
hook into that lookup process

00:09:36,399 --> 00:09:39,760
by using something called the descriptor

00:09:38,720 --> 00:09:41,680
protocol

00:09:39,760 --> 00:09:42,959
and python's functions use this

00:09:41,680 --> 00:09:45,600
descriptor protocol

00:09:42,959 --> 00:09:48,240
to bind an instance method whenever you

00:09:45,600 --> 00:09:50,800
use the instance to access that function

00:09:48,240 --> 00:09:52,720
so in this case since we accessed the

00:09:50,800 --> 00:09:53,440
method as an attribute of the warwick

00:09:52,720 --> 00:09:55,519
instance

00:09:53,440 --> 00:09:57,519
the warwick instance was bound to the

00:09:55,519 --> 00:09:59,120
function to create something called a

00:09:57,519 --> 00:10:01,519
bound method

00:09:59,120 --> 00:10:03,120
in this bound method warwick is already

00:10:01,519 --> 00:10:03,760
inserted as the first positional

00:10:03,120 --> 00:10:05,200
argument

00:10:03,760 --> 00:10:07,440
the one that will end up with the

00:10:05,200 --> 00:10:09,120
parameter self

00:10:07,440 --> 00:10:11,040
and this is why you don't have to insert

00:10:09,120 --> 00:10:13,120
the instance yourself anymore

00:10:11,040 --> 00:10:15,040
whenever you use a bound method the

00:10:13,120 --> 00:10:16,720
instance has already been inserted for

00:10:15,040 --> 00:10:19,200
you

00:10:16,720 --> 00:10:20,800
ok now since i'm not a magician i'm

00:10:19,200 --> 00:10:21,600
going to reveal the trick behind this

00:10:20,800 --> 00:10:24,000
bit of magic

00:10:21,600 --> 00:10:24,720
by introducing the descriptor protocol

00:10:24,000 --> 00:10:26,320
mind you

00:10:24,720 --> 00:10:28,000
this isn't going to be a thorough

00:10:26,320 --> 00:10:28,800
in-depth discussion of the entire

00:10:28,000 --> 00:10:30,399
protocol

00:10:28,800 --> 00:10:33,839
but it should at least give you a taste

00:10:30,399 --> 00:10:33,839
of how it works

00:10:36,399 --> 00:10:40,959
alright let's talk about descriptors

00:10:39,360 --> 00:10:42,959
when i first heard that term

00:10:40,959 --> 00:10:44,880
i thought it sounded quite difficult at

00:10:42,959 --> 00:10:46,959
least it wasn't quite obvious to me what

00:10:44,880 --> 00:10:47,920
the term meant or what descriptors would

00:10:46,959 --> 00:10:49,600
do

00:10:47,920 --> 00:10:51,200
now that i've been using descriptors for

00:10:49,600 --> 00:10:53,680
a while i still think they're not the

00:10:51,200 --> 00:10:55,279
easiest thing to learn in python

00:10:53,680 --> 00:10:56,959
there are just quite a few details to

00:10:55,279 --> 00:10:58,160
learn and python design principles to

00:10:56,959 --> 00:10:59,279
master if you want to use them

00:10:58,160 --> 00:11:01,440
effectively

00:10:59,279 --> 00:11:03,200
at the same time i don't think it's that

00:11:01,440 --> 00:11:05,200
difficult to get a general understanding

00:11:03,200 --> 00:11:06,640
of what descriptors are

00:11:05,200 --> 00:11:09,200
and that's what i'm going to focus on

00:11:06,640 --> 00:11:10,560
here now i want to give you a rough idea

00:11:09,200 --> 00:11:12,240
of what descriptors are

00:11:10,560 --> 00:11:14,720
and only zoom in on the parts that we

00:11:12,240 --> 00:11:17,680
need to understand self

00:11:14,720 --> 00:11:19,519
so what are descriptors descriptors are

00:11:17,680 --> 00:11:22,160
objects that modify what happens when we

00:11:19,519 --> 00:11:24,320
do something with an attribute in python

00:11:22,160 --> 00:11:26,560
more specifically descriptors can

00:11:24,320 --> 00:11:28,720
customize how we look up attributes

00:11:26,560 --> 00:11:31,040
how we assign to attributes and how we

00:11:28,720 --> 00:11:33,040
delete attributes

00:11:31,040 --> 00:11:35,839
descriptors do this by implementing the

00:11:33,040 --> 00:11:37,920
descriptor protocol

00:11:35,839 --> 00:11:39,040
there are three special or double

00:11:37,920 --> 00:11:42,480
underscore methods

00:11:39,040 --> 00:11:44,959
that descriptors can implement the first

00:11:42,480 --> 00:11:46,880
is the dunder get method which can be

00:11:44,959 --> 00:11:50,800
used to customize what happens

00:11:46,880 --> 00:11:53,760
when you get or look up an attribute

00:11:50,800 --> 00:11:55,440
the second is the dunder set method it

00:11:53,760 --> 00:11:57,600
allows you to modify what happens when

00:11:55,440 --> 00:11:59,200
you assign something to an attribute

00:11:57,600 --> 00:12:00,880
like we're assigning something to play

00:11:59,200 --> 00:12:03,200
note here

00:12:00,880 --> 00:12:03,920
and finally there's the dunder delete

00:12:03,200 --> 00:12:06,079
method

00:12:03,920 --> 00:12:07,680
and as the name implies it allows you to

00:12:06,079 --> 00:12:10,079
customize what happens when someone

00:12:07,680 --> 00:12:12,160
tries to delete an attribute

00:12:10,079 --> 00:12:13,680
as you've probably already guessed all

00:12:12,160 --> 00:12:16,720
functions in python are such

00:12:13,680 --> 00:12:17,360
descriptors now descriptors don't have

00:12:16,720 --> 00:12:19,839
to implement

00:12:17,360 --> 00:12:21,360
all three methods and in fact functions

00:12:19,839 --> 00:12:23,839
only implement one of them

00:12:21,360 --> 00:12:25,440
the dunder get method and that's why

00:12:23,839 --> 00:12:27,680
we're going to focus on a dunder get

00:12:25,440 --> 00:12:29,519
method in the remainder of this talk

00:12:27,680 --> 00:12:33,200
we'll start by implementing a descriptor

00:12:29,519 --> 00:12:33,200
with a dunder get method of our own

00:12:36,160 --> 00:12:39,600
the descriptor that i want to implement

00:12:37,839 --> 00:12:41,279
is one that's going to help me identify

00:12:39,600 --> 00:12:42,880
my favorite guitar

00:12:41,279 --> 00:12:45,600
the goal is that i can create a class

00:12:42,880 --> 00:12:47,680
attribute called is my favorite

00:12:45,600 --> 00:12:49,440
that i assign to my descriptor let's

00:12:47,680 --> 00:12:52,720
call it favorite descriptor

00:12:49,440 --> 00:12:54,399
and then when i access that attribute on

00:12:52,720 --> 00:12:56,320
a guitar instance

00:12:54,399 --> 00:12:57,440
it will tell me if that instance is my

00:12:56,320 --> 00:12:59,920
favorite guitar

00:12:57,440 --> 00:13:00,800
or not it's not going to do anything

00:12:59,920 --> 00:13:02,320
complicated

00:13:00,800 --> 00:13:04,240
it's just going to compare the name

00:13:02,320 --> 00:13:05,040
attribute of the guitar to warwick

00:13:04,240 --> 00:13:07,680
streamer

00:13:05,040 --> 00:13:09,279
that's currently my favorite guitar so

00:13:07,680 --> 00:13:09,680
if i create a guitar instance with the

00:13:09,279 --> 00:13:12,639
name

00:13:09,680 --> 00:13:13,120
warwick streamer like this and i then

00:13:12,639 --> 00:13:16,320
print

00:13:13,120 --> 00:13:20,000
warwick dot is my favorite we should see

00:13:16,320 --> 00:13:22,399
true as a counter example if i create an

00:13:20,000 --> 00:13:25,279
instance for my fender jazz bass

00:13:22,399 --> 00:13:26,240
and then printfender dot is my favorite

00:13:25,279 --> 00:13:28,959
it should print

00:13:26,240 --> 00:13:30,720
pulse and that's all it's not going to

00:13:28,959 --> 00:13:32,800
be configurable it's not going to have

00:13:30,720 --> 00:13:34,320
options

00:13:32,800 --> 00:13:36,399
and it's just going to check against the

00:13:34,320 --> 00:13:37,760
static name warwick streamer

00:13:36,399 --> 00:13:39,920
and this is to make it easy for

00:13:37,760 --> 00:13:41,519
demonstration now some of you may be

00:13:39,920 --> 00:13:42,399
wondering why i'm not simply using a

00:13:41,519 --> 00:13:44,639
property

00:13:42,399 --> 00:13:45,920
which is the normal way to do this but

00:13:44,639 --> 00:13:48,000
the goal here is to

00:13:45,920 --> 00:13:49,760
implement the descriptor manually

00:13:48,000 --> 00:13:51,199
properties also use the descriptor

00:13:49,760 --> 00:13:52,959
protocol under the hood

00:13:51,199 --> 00:13:54,560
but the point here is to show you how

00:13:52,959 --> 00:13:56,000
the get method works

00:13:54,560 --> 00:13:57,920
not to show you the best and most

00:13:56,000 --> 00:14:01,040
pythonic way to do this and that's why

00:13:57,920 --> 00:14:03,519
we're going to do it manually here

00:14:01,040 --> 00:14:04,240
to write a descriptor you simply write a

00:14:03,519 --> 00:14:05,680
class and

00:14:04,240 --> 00:14:07,839
implement the descriptor methods that

00:14:05,680 --> 00:14:09,360
you need in our case

00:14:07,839 --> 00:14:11,440
we only want to do something when we

00:14:09,360 --> 00:14:13,760
access the attribute so we only need to

00:14:11,440 --> 00:14:15,360
implement a dunder get method

00:14:13,760 --> 00:14:18,000
we don't really need to do anything else

00:14:15,360 --> 00:14:21,040
here a dunder get method has

00:14:18,000 --> 00:14:22,399
three parameters self instance and the

00:14:21,040 --> 00:14:24,320
owner

00:14:22,399 --> 00:14:25,600
the instance parameter will receive the

00:14:24,320 --> 00:14:27,839
instance that you

00:14:25,600 --> 00:14:29,920
access the attribute on in our example

00:14:27,839 --> 00:14:31,040
above we access the attribute on the

00:14:29,920 --> 00:14:33,920
fender instance

00:14:31,040 --> 00:14:35,600
so instance will receive defender the

00:14:33,920 --> 00:14:37,279
owner parameter will receive the class

00:14:35,600 --> 00:14:40,000
that owns the attribute

00:14:37,279 --> 00:14:41,839
in our case since is my favorite is an

00:14:40,000 --> 00:14:45,279
attribute of the class guitar

00:14:41,839 --> 00:14:47,600
we would get guitar as as a value for

00:14:45,279 --> 00:14:47,600
owner

00:14:47,680 --> 00:14:51,360
now the first thing that we need to do

00:14:49,279 --> 00:14:53,120
within our dunder get method

00:14:51,360 --> 00:14:54,880
is account for the possibility that

00:14:53,120 --> 00:14:56,480
instance is none

00:14:54,880 --> 00:14:58,160
this can happen when you access the

00:14:56,480 --> 00:15:01,040
descriptor directly on the class

00:14:58,160 --> 00:15:03,040
so like class that is my favorite and

00:15:01,040 --> 00:15:06,000
then there's obviously no instance yet

00:15:03,040 --> 00:15:07,600
so instance will get none one common way

00:15:06,000 --> 00:15:08,480
to handle this is by checking if the

00:15:07,600 --> 00:15:10,320
instance is none

00:15:08,480 --> 00:15:12,880
and then simply returning the descriptor

00:15:10,320 --> 00:15:14,800
itself by returning self

00:15:12,880 --> 00:15:16,480
this is also what functions in python 3

00:15:14,800 --> 00:15:18,560
do

00:15:16,480 --> 00:15:20,720
once we make it past that if block we

00:15:18,560 --> 00:15:23,120
know that we're dealing with an instance

00:15:20,720 --> 00:15:24,160
we can simply compare the name attribute

00:15:23,120 --> 00:15:26,240
of the instance

00:15:24,160 --> 00:15:28,240
to warwick streamer and return the

00:15:26,240 --> 00:15:29,759
result of that

00:15:28,240 --> 00:15:31,279
now there are obviously several ways to

00:15:29,759 --> 00:15:33,040
improve the code here

00:15:31,279 --> 00:15:34,959
like not just assuming that the instance

00:15:33,040 --> 00:15:38,320
will always have a name attribute

00:15:34,959 --> 00:15:39,920
but this is fine for our demonstration

00:15:38,320 --> 00:15:42,320
the final thing that i'd like to do is

00:15:39,920 --> 00:15:44,160
to show the descriptor in action

00:15:42,320 --> 00:15:45,519
so first i create an instance for my

00:15:44,160 --> 00:15:47,440
warwick streamer

00:15:45,519 --> 00:15:48,560
and then when i access the is my

00:15:47,440 --> 00:15:51,360
favorite attribute

00:15:48,560 --> 00:15:52,399
you'll see that it returns true if i do

00:15:51,360 --> 00:15:54,399
the opposite

00:15:52,399 --> 00:15:55,519
so if i create an instance for my fender

00:15:54,399 --> 00:15:57,600
jazz bass

00:15:55,519 --> 00:15:59,759
and i then access the attribute you'll

00:15:57,600 --> 00:16:01,759
see that it returns false

00:15:59,759 --> 00:16:03,440
now to test the first if block we can

00:16:01,759 --> 00:16:05,040
also look at what happens when we

00:16:03,440 --> 00:16:08,560
access the attribute directly on the

00:16:05,040 --> 00:16:10,079
class so guitar dot is my favorite

00:16:08,560 --> 00:16:12,320
and we see that it just returns the

00:16:10,079 --> 00:16:13,839
descriptor itself

00:16:12,320 --> 00:16:15,360
right now that we've seen an

00:16:13,839 --> 00:16:16,880
implementation of a descriptor

00:16:15,360 --> 00:16:18,880
we've seen an implementation of the

00:16:16,880 --> 00:16:20,560
dunder get method i think it's time to

00:16:18,880 --> 00:16:23,839
look at the implementation for functions

00:16:20,560 --> 00:16:23,839
in python

00:16:28,079 --> 00:16:31,440
so this is the implementation of the get

00:16:30,000 --> 00:16:33,519
method of functions

00:16:31,440 --> 00:16:36,000
or at least a python version of it

00:16:33,519 --> 00:16:38,160
because the original was written in c

00:16:36,000 --> 00:16:39,199
still this byte inversion is roughly

00:16:38,160 --> 00:16:40,959
equivalent

00:16:39,199 --> 00:16:43,040
the c version just has to do something

00:16:40,959 --> 00:16:46,560
additional with the reference count

00:16:43,040 --> 00:16:48,880
because it operates on a lower level

00:16:46,560 --> 00:16:50,800
what it does is fairly straightforward

00:16:48,880 --> 00:16:51,519
it will first check if the instance is

00:16:50,800 --> 00:16:53,680
none

00:16:51,519 --> 00:16:56,959
if so it will just return the function

00:16:53,680 --> 00:16:59,360
itself it won't make a bound method

00:16:56,959 --> 00:17:01,120
now remember this happens when you

00:16:59,360 --> 00:17:01,680
access the descriptor using a class

00:17:01,120 --> 00:17:03,920
attribute

00:17:01,680 --> 00:17:05,439
instead of an instance attribute this

00:17:03,920 --> 00:17:08,880
means that if i do

00:17:05,439 --> 00:17:10,480
guitar dot play note

00:17:08,880 --> 00:17:12,880
i'm just getting the function itself

00:17:10,480 --> 00:17:14,799
back and not a bound method

00:17:12,880 --> 00:17:16,079
this obviously makes sense because there

00:17:14,799 --> 00:17:19,039
is no instance yet

00:17:16,079 --> 00:17:20,559
there is nothing to bind here yet to

00:17:19,039 --> 00:17:22,799
really hammer the point home

00:17:20,559 --> 00:17:24,799
we can also manually call the get method

00:17:22,799 --> 00:17:28,240
with none for the instance

00:17:24,799 --> 00:17:30,559
if i do guitar dot play note

00:17:28,240 --> 00:17:31,600
which gets me the function and then i

00:17:30,559 --> 00:17:34,799
add the call

00:17:31,600 --> 00:17:37,520
get none guitar

00:17:34,799 --> 00:17:39,039
i should get back the function and yes

00:17:37,520 --> 00:17:41,600
we do

00:17:39,039 --> 00:17:44,480
so if the instance is none we just get

00:17:41,600 --> 00:17:46,799
the function back

00:17:44,480 --> 00:17:48,480
if the instance isn't none we will make

00:17:46,799 --> 00:17:50,160
it past that if statement

00:17:48,480 --> 00:17:52,880
and that's when we actually create a

00:17:50,160 --> 00:17:54,480
bound method and return it

00:17:52,880 --> 00:17:56,240
we can see this in action by first

00:17:54,480 --> 00:17:58,799
creating a guitar instance

00:17:56,240 --> 00:18:01,039
my warwick here and then by manually

00:17:58,799 --> 00:18:05,039
calling the get method

00:18:01,039 --> 00:18:07,120
now providing warwick instead of none

00:18:05,039 --> 00:18:09,120
and as you can see we now get a bound

00:18:07,120 --> 00:18:11,280
method instead of the function

00:18:09,120 --> 00:18:12,799
and this really is the magic of self

00:18:11,280 --> 00:18:15,039
functions are descriptors

00:18:12,799 --> 00:18:16,240
that bind the instance whenever you get

00:18:15,039 --> 00:18:19,039
them as an attribute

00:18:16,240 --> 00:18:19,039
of an instance

00:18:21,440 --> 00:18:25,280
there are also some other descriptors

00:18:23,039 --> 00:18:27,120
related to methods built into python

00:18:25,280 --> 00:18:28,799
you are probably already quite familiar

00:18:27,120 --> 00:18:30,480
with them

00:18:28,799 --> 00:18:32,720
a good example is the class method

00:18:30,480 --> 00:18:34,720
descriptor it is typically used as a

00:18:32,720 --> 00:18:37,760
decorator decorating a method

00:18:34,720 --> 00:18:39,440
as in the example below

00:18:37,760 --> 00:18:40,799
what it does is wrap the function in a

00:18:39,440 --> 00:18:43,200
class method object

00:18:40,799 --> 00:18:44,320
to provide an alternative dunder get

00:18:43,200 --> 00:18:46,720
method

00:18:44,320 --> 00:18:47,840
this dunder get method also creates a

00:18:46,720 --> 00:18:49,440
bound method

00:18:47,840 --> 00:18:51,679
but one that binds the function to the

00:18:49,440 --> 00:18:53,360
class instead of the instance

00:18:51,679 --> 00:18:54,880
this happens both when you access it

00:18:53,360 --> 00:18:56,559
directly on the class

00:18:54,880 --> 00:18:59,120
as well as when you access it on the

00:18:56,559 --> 00:19:01,760
instance you always get a method bound

00:18:59,120 --> 00:19:01,760
to the class

00:19:01,919 --> 00:19:06,480
similarly there's also the static method

00:19:04,160 --> 00:19:07,200
class which you typically also use as a

00:19:06,480 --> 00:19:09,679
decorator

00:19:07,200 --> 00:19:11,039
see the example below it also wraps

00:19:09,679 --> 00:19:12,559
around the function to provide an

00:19:11,039 --> 00:19:14,559
alternative get method

00:19:12,559 --> 00:19:15,840
but this time one that always returns

00:19:14,559 --> 00:19:18,799
the function as it is

00:19:15,840 --> 00:19:20,400
without binding anything to it so

00:19:18,799 --> 00:19:22,000
regardless of whether you access the

00:19:20,400 --> 00:19:22,720
static method object directly on the

00:19:22,000 --> 00:19:24,640
class

00:19:22,720 --> 00:19:26,640
or on an instance of the class you

00:19:24,640 --> 00:19:29,679
always get the raw function back

00:19:26,640 --> 00:19:29,679
not a bound method

00:19:30,880 --> 00:19:34,400
the last decorator that i'd like to

00:19:32,320 --> 00:19:36,160
mention is the property class

00:19:34,400 --> 00:19:37,760
this one is also typically used as a

00:19:36,160 --> 00:19:39,280
decorator but

00:19:37,760 --> 00:19:41,200
as is true for all the ones that i

00:19:39,280 --> 00:19:42,000
mentioned you don't have to use it as a

00:19:41,200 --> 00:19:44,080
decorator

00:19:42,000 --> 00:19:46,000
as mentioned earlier properties allow

00:19:44,080 --> 00:19:48,640
you to very easily add getters

00:19:46,000 --> 00:19:50,640
setters and deleters to attributes one

00:19:48,640 --> 00:19:52,240
interesting aspect of properties

00:19:50,640 --> 00:19:53,840
is that they allow you to implement such

00:19:52,240 --> 00:19:55,120
gathers and setters later on in the

00:19:53,840 --> 00:19:57,120
lifetime of your project

00:19:55,120 --> 00:19:58,240
without changing the public interface of

00:19:57,120 --> 00:19:59,760
the attribute

00:19:58,240 --> 00:20:01,679
this means that you can start out with

00:19:59,760 --> 00:20:03,280
exposing the attribute directly

00:20:01,679 --> 00:20:04,960
and you only have to add the gathers and

00:20:03,280 --> 00:20:07,120
setters when you actually need custom

00:20:04,960 --> 00:20:08,960
lookup and assignment logic

00:20:07,120 --> 00:20:10,559
this is one big advantage of properties

00:20:08,960 --> 00:20:14,480
in python something that you

00:20:10,559 --> 00:20:14,480
don't see in other languages

00:20:16,880 --> 00:20:20,080
alright we're nearly at the end of this

00:20:18,720 --> 00:20:22,480
talk i hope you've enjoyed

00:20:20,080 --> 00:20:23,919
it to summarize we've seen how the

00:20:22,480 --> 00:20:26,640
descriptor protocol allows you to

00:20:23,919 --> 00:20:28,240
customize how attributes work in python

00:20:26,640 --> 00:20:30,480
they let you do cool things behind the

00:20:28,240 --> 00:20:33,039
scenes when you access assign to

00:20:30,480 --> 00:20:34,320
or delete an attribute functions are

00:20:33,039 --> 00:20:36,480
such descriptors

00:20:34,320 --> 00:20:38,240
and this is the magic behind self

00:20:36,480 --> 00:20:38,799
whenever you access a function as a

00:20:38,240 --> 00:20:41,200
method

00:20:38,799 --> 00:20:43,039
the descriptor magic kicks in to insert

00:20:41,200 --> 00:20:44,000
the instance for you so you don't have

00:20:43,039 --> 00:20:45,840
to

00:20:44,000 --> 00:20:47,280
we've seen a few other cool descriptors

00:20:45,840 --> 00:20:49,120
in python that allow you to influence

00:20:47,280 --> 00:20:51,600
how methods behave

00:20:49,120 --> 00:20:52,640
things like properties class methods and

00:20:51,600 --> 00:20:54,480
static methods

00:20:52,640 --> 00:20:56,400
they wrap around the function object to

00:20:54,480 --> 00:20:58,559
provide a custom thundercat method

00:20:56,400 --> 00:21:00,480
that behaves differently these tools are

00:20:58,559 --> 00:21:01,919
all very powerful and allow you to focus

00:21:00,480 --> 00:21:04,480
on other things than worrying about how

00:21:01,919 --> 00:21:06,320
it all works under the hood

00:21:04,480 --> 00:21:07,840
at the same time there are also a lot of

00:21:06,320 --> 00:21:09,039
things related to descriptors that i've

00:21:07,840 --> 00:21:10,880
skipped over

00:21:09,039 --> 00:21:12,400
while i did mention them i didn't

00:21:10,880 --> 00:21:14,320
explain how they done their set

00:21:12,400 --> 00:21:15,919
and the donor delete methods work and

00:21:14,320 --> 00:21:17,120
how they differed from the dunder get

00:21:15,919 --> 00:21:19,280
method

00:21:17,120 --> 00:21:21,120
this is an interesting topic but maybe

00:21:19,280 --> 00:21:24,080
something for another talk in the future

00:21:21,120 --> 00:21:26,640
who knows then there's the difference

00:21:24,080 --> 00:21:28,880
between data and non-data descriptors

00:21:26,640 --> 00:21:30,480
or as fluent python calls them

00:21:28,880 --> 00:21:31,600
overriding and non-overriding

00:21:30,480 --> 00:21:33,919
descriptors

00:21:31,600 --> 00:21:35,600
this has to do with the specific lookup

00:21:33,919 --> 00:21:36,320
order of instance versus class

00:21:35,600 --> 00:21:37,840
attributes

00:21:36,320 --> 00:21:39,760
but it's a thing that you need to wrap

00:21:37,840 --> 00:21:41,280
your head around i think it's much

00:21:39,760 --> 00:21:41,760
better to learn that different using a

00:21:41,280 --> 00:21:43,919
book

00:21:41,760 --> 00:21:45,039
or a good tutorial and your editor on

00:21:43,919 --> 00:21:46,720
the side

00:21:45,039 --> 00:21:48,320
i can personally highly recommend to

00:21:46,720 --> 00:21:49,840
book fluent python for that

00:21:48,320 --> 00:21:51,120
i think a new edition of that book will

00:21:49,840 --> 00:21:51,679
come out somewhere in the next few

00:21:51,120 --> 00:21:55,120
months

00:21:51,679 --> 00:21:57,039
so be sure to grab one alternatively

00:21:55,120 --> 00:21:58,640
there's a very good tutorial written by

00:21:57,039 --> 00:21:59,840
raymond hettinger in the python

00:21:58,640 --> 00:22:01,600
documentation

00:21:59,840 --> 00:22:03,520
and real python also has plenty of

00:22:01,600 --> 00:22:05,760
resources on the subject

00:22:03,520 --> 00:22:07,039
finally there's this handy method called

00:22:05,760 --> 00:22:08,480
dunder set name

00:22:07,039 --> 00:22:10,799
that's often used together with the

00:22:08,480 --> 00:22:14,159
descriptor methods it may be worth it

00:22:10,799 --> 00:22:14,159
for you to look it up sometime

00:22:17,360 --> 00:22:20,480
i'd like to conclude this talk with a

00:22:19,039 --> 00:22:23,520
quote from lee sigel

00:22:20,480 --> 00:22:27,840
a magician i'm writing a book of magic

00:22:23,520 --> 00:22:30,480
i explain and i'm asked real magic

00:22:27,840 --> 00:22:32,720
by real magic people mean miracles

00:22:30,480 --> 00:22:34,159
thumaturgical acts and supernatural

00:22:32,720 --> 00:22:37,360
powers

00:22:34,159 --> 00:22:38,640
now i answer conjuring tricks not real

00:22:37,360 --> 00:22:41,360
magic

00:22:38,640 --> 00:22:43,039
real magic in other words refers to the

00:22:41,360 --> 00:22:45,600
magic that is not real

00:22:43,039 --> 00:22:46,880
while the magic that is real that can

00:22:45,600 --> 00:22:50,799
actually be done

00:22:46,880 --> 00:22:50,799
is not real magic

00:22:51,039 --> 00:22:54,640
in python those dunder methods we've

00:22:53,120 --> 00:22:57,200
seen are sometimes called

00:22:54,640 --> 00:22:58,720
magic methods as if they allow you to do

00:22:57,200 --> 00:23:00,880
magical things

00:22:58,720 --> 00:23:02,720
not everyone is happy with that name

00:23:00,880 --> 00:23:03,760
they claim that python is adverse to

00:23:02,720 --> 00:23:06,240
magic

00:23:03,760 --> 00:23:07,280
that saying that something is magical is

00:23:06,240 --> 00:23:09,360
to say that we

00:23:07,280 --> 00:23:10,720
mere mortals would never be able to

00:23:09,360 --> 00:23:12,240
harness that power

00:23:10,720 --> 00:23:13,760
and that python is specifically a

00:23:12,240 --> 00:23:14,159
language that does allow you to do

00:23:13,760 --> 00:23:16,080
almost

00:23:14,159 --> 00:23:17,840
everything that the interpreter can do

00:23:16,080 --> 00:23:19,600
as well

00:23:17,840 --> 00:23:21,039
so they say that calling it magic is

00:23:19,600 --> 00:23:23,600
wrong

00:23:21,039 --> 00:23:25,440
i like the term magic i think that

00:23:23,600 --> 00:23:27,360
there's a lot of magic in python

00:23:25,440 --> 00:23:29,039
that typically allows us to focus on our

00:23:27,360 --> 00:23:30,320
business logic the higher level

00:23:29,039 --> 00:23:33,120
abstractions

00:23:30,320 --> 00:23:35,280
and just like lisigol i think the real

00:23:33,120 --> 00:23:37,520
magic is the magic that we can touch

00:23:35,280 --> 00:23:38,320
that we can use that we have the spell

00:23:37,520 --> 00:23:41,840
books for

00:23:38,320 --> 00:23:43,520
and in python we have those so i hope

00:23:41,840 --> 00:23:44,720
this talk gave you a taste of the magic

00:23:43,520 --> 00:23:46,799
of python

00:23:44,720 --> 00:23:48,400
and i hope you'll now want to go out and

00:23:46,799 --> 00:23:50,480
learn more of it

00:23:48,400 --> 00:23:53,600
and that's it for me thank you for

00:23:50,480 --> 00:23:53,600
staying with me to the end

00:24:02,840 --> 00:24:05,840
goodbye

00:25:04,320 --> 00:25:06,400

YouTube URL: https://www.youtube.com/watch?v=ANLjBsWHshc


