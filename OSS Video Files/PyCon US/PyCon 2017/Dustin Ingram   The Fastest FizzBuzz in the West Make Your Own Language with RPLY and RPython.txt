Title: Dustin Ingram   The Fastest FizzBuzz in the West Make Your Own Language with RPLY and RPython
Publication date: 2017-05-21
Playlist: PyCon 2017
Description: 
	"Speaker: Dustin Ingram

In this talk, you'll learn how I built DIVSPL (Dustin Ingram's Very Special Programming Language), a tongue-in-cheek domain-specific language, which is particularly good for implementing FizzBuzz -- as quickly as possible.

We'll build DIVSPL with RPLY, an implementation of David Beazley's PLY (but with a ""cooler"" API) and make it compatible with RPython, a restricted subset of the Python programming language. Along the way, you'll learn about lexers, parsers, and grammars, and in the end, you'll know how to build your own language.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:13,400 --> 00:00:24,359
welcome back high-energy everything's

00:00:19,020 --> 00:00:26,130
not on fire it's okay um yet um we have

00:00:24,359 --> 00:00:34,680
Justin and we're going to learn some ups

00:00:26,130 --> 00:00:38,969
and fizzbuzz yay hi everybody my name is

00:00:34,680 --> 00:00:40,230
Dustin I'm di on github and I work for a

00:00:38,969 --> 00:00:42,510
company called prompt works which is a

00:00:40,230 --> 00:00:45,780
software consultancy in Philadelphia and

00:00:42,510 --> 00:00:48,930
this talk is called the fastest fizzbuzz

00:00:45,780 --> 00:00:49,530
in the West but I have to tell you

00:00:48,930 --> 00:00:52,110
something first

00:00:49,530 --> 00:00:54,780
this talk is not actually about sis buzz

00:00:52,110 --> 00:00:57,270
however physical is kind of the like so

00:00:54,780 --> 00:00:58,739
motivation for this talk so in order to

00:00:57,270 --> 00:01:00,809
get started I actually I can't believe

00:00:58,739 --> 00:01:02,460
I'm about to say this I need to explain

00:01:00,809 --> 00:01:03,539
fizzbuzz to all of you because if you

00:01:02,460 --> 00:01:04,199
don't know if is buzz it's not going to

00:01:03,539 --> 00:01:06,270
make any sense

00:01:04,199 --> 00:01:08,549
so fizzbuzz is kind of this mythical

00:01:06,270 --> 00:01:10,080
interview question that you might get

00:01:08,549 --> 00:01:11,610
asked when working on a white board and

00:01:10,080 --> 00:01:13,110
the general idea is that you need to

00:01:11,610 --> 00:01:14,909
write a function the Princeton umbers

00:01:13,110 --> 00:01:16,740
one through n but if the number is

00:01:14,909 --> 00:01:19,320
divisible by three instead of the number

00:01:16,740 --> 00:01:21,299
you print fizz instead of five you would

00:01:19,320 --> 00:01:23,159
if the numbers divisible by five you'd

00:01:21,299 --> 00:01:26,280
print buzz and if it's divisible by both

00:01:23,159 --> 00:01:28,770
three and five you prints is buzz so

00:01:26,280 --> 00:01:30,630
I've never actually been asked to do the

00:01:28,770 --> 00:01:33,060
fizzbuzz problem and an interview for a

00:01:30,630 --> 00:01:34,860
software job but at various stages of my

00:01:33,060 --> 00:01:37,049
career I've always kind of like Santa

00:01:34,860 --> 00:01:38,790
sized what it would be like if someone

00:01:37,049 --> 00:01:40,619
did like if I was sitting across the

00:01:38,790 --> 00:01:43,369
table from this guy and he said ah right

00:01:40,619 --> 00:01:46,530
Dustin let's do fizzbuzz what would i do

00:01:43,369 --> 00:01:49,530
so very early in my career I'd write

00:01:46,530 --> 00:01:52,350
something like this so this basically

00:01:49,530 --> 00:01:54,840
prompt takes from a range from 1 to N it

00:01:52,350 --> 00:01:56,969
is visible by 15 prints is buzz says

00:01:54,840 --> 00:02:00,090
buzz else it prints the number this is

00:01:56,969 --> 00:02:01,500
like basics as buzz right here and this

00:02:00,090 --> 00:02:03,930
would have totally sufficed right you

00:02:01,500 --> 00:02:06,780
run this and you get 1/2 fizz for buzz

00:02:03,930 --> 00:02:09,030
et cetera et cetera but I like to do

00:02:06,780 --> 00:02:10,709
things a little overkill so after a

00:02:09,030 --> 00:02:12,720
little while I got really interested in

00:02:10,709 --> 00:02:13,710
very terse programming and I found this

00:02:12,720 --> 00:02:15,030
one liner

00:02:13,710 --> 00:02:17,520
this actually is a perfect

00:02:15,030 --> 00:02:18,900
implementation of fizzbuzz as well so I

00:02:17,520 --> 00:02:20,550
memorize this thing and that's great if

00:02:18,900 --> 00:02:21,690
someone asked since but this is what I'm

00:02:20,550 --> 00:02:24,210
going to do it's really going to blow

00:02:21,690 --> 00:02:26,730
their mind but in my imagination there

00:02:24,210 --> 00:02:28,800
was never really a limit on what

00:02:26,730 --> 00:02:32,280
language my solution could be in right

00:02:28,800 --> 00:02:33,930
didn't have to be Python I could I could

00:02:32,280 --> 00:02:35,550
learn Fortran and I could do it in

00:02:33,930 --> 00:02:39,270
Fortran that would really be funny right

00:02:35,550 --> 00:02:41,430
or I could learn this language and this

00:02:39,270 --> 00:02:43,980
is a valid fizzbuzz implementation too

00:02:41,430 --> 00:02:46,700
and I thought maybe I could like somehow

00:02:43,980 --> 00:02:49,860
memorize all that but I never did but I

00:02:46,700 --> 00:02:51,390
was always really curious and I was

00:02:49,860 --> 00:02:53,640
intrigued like where could I draw the

00:02:51,390 --> 00:02:55,620
line in this hypothetical interview

00:02:53,640 --> 00:02:58,500
question could I make my own language

00:02:55,620 --> 00:03:00,450
and then use it to solve the problem if

00:02:58,500 --> 00:03:02,250
I did I'd call it did spill which

00:03:00,450 --> 00:03:03,990
obviously stands for dust and Ingram's

00:03:02,250 --> 00:03:05,970
very special programming language and

00:03:03,990 --> 00:03:08,610
the number one priority of this language

00:03:05,970 --> 00:03:11,430
is going to be able to implement SIDS

00:03:08,610 --> 00:03:12,750
buzz as quickly as possible so since

00:03:11,430 --> 00:03:15,240
it's my own language I can make the

00:03:12,750 --> 00:03:16,560
syntax anything I want right and I sort

00:03:15,240 --> 00:03:18,780
of thought let's make this really simple

00:03:16,560 --> 00:03:20,670
let's make it just the minimum amount of

00:03:18,780 --> 00:03:23,640
information necessary to encapsulate a

00:03:20,670 --> 00:03:26,250
certain fizzbuzz problem right so the

00:03:23,640 --> 00:03:27,930
first thing in this bill did spill would

00:03:26,250 --> 00:03:29,310
be a range of integers that you want to

00:03:27,930 --> 00:03:31,920
print and then you have these like

00:03:29,310 --> 00:03:34,440
assignment like things saying fizz is 3

00:03:31,920 --> 00:03:37,590
buzz is 5 and this this is it right this

00:03:34,440 --> 00:03:41,250
is what I imagined to be a Fizbo just

00:03:37,590 --> 00:03:42,900
limitation so the goal for this talk is

00:03:41,250 --> 00:03:44,310
to show you how we can take this syntax

00:03:42,900 --> 00:03:47,190
and actually turn it into something that

00:03:44,310 --> 00:03:49,710
will solve the fizzbuzz problem and I

00:03:47,190 --> 00:03:52,670
have to say that dr. vanderplatt says

00:03:49,710 --> 00:03:55,500
talk really show me that I need to

00:03:52,670 --> 00:03:58,050
acknowledge my giant so digital is built

00:03:55,500 --> 00:04:00,290
on the shoulder of giants as well much

00:03:58,050 --> 00:04:02,190
bigger Giants than itself obviously so

00:04:00,290 --> 00:04:04,320
some tools that we're going to use to

00:04:02,190 --> 00:04:06,300
build old-school is our apply and our

00:04:04,320 --> 00:04:09,290
Python and these are built on other

00:04:06,300 --> 00:04:12,270
giants etc apply lex and yak which are

00:04:09,290 --> 00:04:15,060
lex on the neck or old UNIX tools that

00:04:12,270 --> 00:04:16,440
are used to generate lexical analyzers

00:04:15,060 --> 00:04:18,090
and parser generation we'll get to that

00:04:16,440 --> 00:04:19,500
a little bit later and real quickly I

00:04:18,090 --> 00:04:20,850
want to tell you about our Python

00:04:19,500 --> 00:04:22,860
because not everyone is very familiar

00:04:20,850 --> 00:04:25,270
with what our Python is it's a

00:04:22,860 --> 00:04:29,710
restricted subset of Python so

00:04:25,270 --> 00:04:31,150
Oh in plain old great normal Python it's

00:04:29,710 --> 00:04:33,280
dynamically typed which means that we

00:04:31,150 --> 00:04:35,080
can set a variable X set it to be a

00:04:33,280 --> 00:04:36,400
string hello and then later on we can

00:04:35,080 --> 00:04:37,000
change it to be an integer and that's

00:04:36,400 --> 00:04:39,610
totally fine

00:04:37,000 --> 00:04:40,569
Python is totally cool with that and we

00:04:39,610 --> 00:04:41,889
can do the same thing with functions

00:04:40,569 --> 00:04:44,139
right like we can write a function and

00:04:41,889 --> 00:04:46,270
in some cases it'll return a string in

00:04:44,139 --> 00:04:48,580
other cases a return integer dynamically

00:04:46,270 --> 00:04:51,099
typed it doesn't care what it is our

00:04:48,580 --> 00:04:52,870
Python the main restrictions that it

00:04:51,099 --> 00:04:55,479
gives you is that it's mostly on the

00:04:52,870 --> 00:04:57,729
limit on the ability to mix types and

00:04:55,479 --> 00:05:00,520
kind of arbitrary ways so if we wrote

00:04:57,729 --> 00:05:02,530
this function in our Python it would

00:05:00,520 --> 00:05:03,940
blow up and it would say a huge error

00:05:02,530 --> 00:05:06,220
message saying that's ascending

00:05:03,940 --> 00:05:07,599
annotation some string and some integer

00:05:06,220 --> 00:05:10,210
right these are incompatible types to

00:05:07,599 --> 00:05:11,470
return from this function together so if

00:05:10,210 --> 00:05:13,930
you see me doing some kind of like weird

00:05:11,470 --> 00:05:16,150
looking Python stuff later as we get on

00:05:13,930 --> 00:05:20,110
this is why because I'm trying to be

00:05:16,150 --> 00:05:22,419
compatible with our pythons weirdness so

00:05:20,110 --> 00:05:23,800
let's design a language right and first

00:05:22,419 --> 00:05:26,110
I want to talk about some parallels to

00:05:23,800 --> 00:05:27,789
written human language so let's say that

00:05:26,110 --> 00:05:29,440
I told you that this is the sentence and

00:05:27,789 --> 00:05:31,120
I've removed the spaces from it and I'm

00:05:29,440 --> 00:05:33,400
going to tell to you one character at a

00:05:31,120 --> 00:05:34,960
time right so as you're parsing this

00:05:33,400 --> 00:05:36,190
sentence you would sort of get one

00:05:34,960 --> 00:05:37,870
character time and you would try to

00:05:36,190 --> 00:05:39,039
figure out what the end of the sentence

00:05:37,870 --> 00:05:40,389
is going to be and what the meaning is

00:05:39,039 --> 00:05:42,219
going to be at the end of it so you

00:05:40,389 --> 00:05:43,419
might say I and then I'll say it s and

00:05:42,219 --> 00:05:44,770
you say okay that's the word is and

00:05:43,419 --> 00:05:46,360
you'll go along until you get to the end

00:05:44,770 --> 00:05:48,219
and I say all right we're done and you

00:05:46,360 --> 00:05:50,560
say all right this sentence is clearly I

00:05:48,219 --> 00:05:52,539
saw a man you sort of can insert those

00:05:50,560 --> 00:05:54,039
spaces because you have a section air in

00:05:52,539 --> 00:05:59,650
your mind of what our valid English

00:05:54,039 --> 00:06:01,360
words like is awake Psalm and etc so if

00:05:59,650 --> 00:06:03,009
I have a sentence like this luckily we

00:06:01,360 --> 00:06:05,080
have spaces right I can say I saw a

00:06:03,009 --> 00:06:08,680
man-eating chicken and you kind of break

00:06:05,080 --> 00:06:10,569
this up in your mind into tokens tokens

00:06:08,680 --> 00:06:11,830
being either the words or being the

00:06:10,569 --> 00:06:13,150
spaces so you take the stream of

00:06:11,830 --> 00:06:14,770
characters and you break it up so you

00:06:13,150 --> 00:06:16,930
can say I saw a man-eating chicken and

00:06:14,770 --> 00:06:18,969
then the next thing that we do is we

00:06:16,930 --> 00:06:20,710
sort of can group now I'm not a linguist

00:06:18,969 --> 00:06:22,990
so this isn't totally accurate and

00:06:20,710 --> 00:06:25,300
perfect but we kind of Group words

00:06:22,990 --> 00:06:26,979
together into different expressions so

00:06:25,300 --> 00:06:29,259
this is like old school grammar school

00:06:26,979 --> 00:06:31,569
right like I saw I saw what I saw a man

00:06:29,259 --> 00:06:33,219
I saw men doing what eating chicken you

00:06:31,569 --> 00:06:35,560
can sort of break up the image into

00:06:33,219 --> 00:06:37,029
these subcategories and then you

00:06:35,560 --> 00:06:38,990
evaluate this whole sentence and you get

00:06:37,029 --> 00:06:42,050
this mental picture in your mind right

00:06:38,990 --> 00:06:43,460
eating chicken but this sort of an

00:06:42,050 --> 00:06:45,590
alternative way to parse the sentence

00:06:43,460 --> 00:06:47,510
also right like what if I grouped man

00:06:45,590 --> 00:06:49,910
and eating together and I get a

00:06:47,510 --> 00:06:51,560
different interpretation of the sentence

00:06:49,910 --> 00:06:53,150
and then my mental picture is totally

00:06:51,560 --> 00:06:55,270
different right it's it's not a man

00:06:53,150 --> 00:06:57,800
eating chicken it's a man eating chicken

00:06:55,270 --> 00:07:00,530
so luckily we have things like dashes in

00:06:57,800 --> 00:07:03,440
our language to disambiguate some ways

00:07:00,530 --> 00:07:04,970
that we can parse sentences so these are

00:07:03,440 --> 00:07:06,110
going to be our steps to interpreting a

00:07:04,970 --> 00:07:09,020
language the first thing we're going to

00:07:06,110 --> 00:07:10,970
do is break a stream of characters into

00:07:09,020 --> 00:07:12,650
tokens then we're going to combine these

00:07:10,970 --> 00:07:14,960
tokens which would be the letters an

00:07:12,650 --> 00:07:16,820
English alphabet into expressions like

00:07:14,960 --> 00:07:18,740
words and then we're going to evaluate

00:07:16,820 --> 00:07:20,150
the expressions so multiple words

00:07:18,740 --> 00:07:21,410
together are going to give us different

00:07:20,150 --> 00:07:23,480
mental images and we bring them all

00:07:21,410 --> 00:07:26,660
together we get the final result so

00:07:23,480 --> 00:07:29,360
let's look back at my proposed digital

00:07:26,660 --> 00:07:31,760
syntax we have a couple different types

00:07:29,360 --> 00:07:35,690
of tokens in this language the first is

00:07:31,760 --> 00:07:38,030
numbers so this would be like 115 3 & 5

00:07:35,690 --> 00:07:38,960
and note that I'm saying 15 and not 105

00:07:38,030 --> 00:07:42,140
that's going to be we're going to

00:07:38,960 --> 00:07:44,330
consider that one number we have periods

00:07:42,140 --> 00:07:46,040
but I'm going to say that three periods

00:07:44,330 --> 00:07:48,920
after each others actually the ellipsis

00:07:46,040 --> 00:07:52,940
token and we have words like fizz and

00:07:48,920 --> 00:07:54,200
Buzz and we have the equal symbol we

00:07:52,940 --> 00:07:57,250
also have white space but we're going to

00:07:54,200 --> 00:08:00,710
ignore it because it doesn't matter here

00:07:57,250 --> 00:08:02,480
so let's make a lexer and the lexer is

00:08:00,710 --> 00:08:04,490
what is going to take this stream of

00:08:02,480 --> 00:08:06,140
characters and turn them into tokens in

00:08:04,490 --> 00:08:08,090
our language what it's going to do is

00:08:06,140 --> 00:08:10,040
give us an iterator that we can call

00:08:08,090 --> 00:08:11,810
Nexon and we can get the new token each

00:08:10,040 --> 00:08:14,690
time as it consumes some characters from

00:08:11,810 --> 00:08:16,640
our our language so from our apply we're

00:08:14,690 --> 00:08:18,140
going to import a lexer generator and

00:08:16,640 --> 00:08:19,700
we're going to initialize it and then

00:08:18,140 --> 00:08:21,680
we're going to start adding named

00:08:19,700 --> 00:08:23,930
regular expressions so I'm going to say

00:08:21,680 --> 00:08:26,570
that the ellipsis and this is the string

00:08:23,930 --> 00:08:28,070
is just to name the token the list this

00:08:26,570 --> 00:08:30,200
is this regular expression which is

00:08:28,070 --> 00:08:33,230
three periods separated by three periods

00:08:30,200 --> 00:08:36,860
one after another similarly a number is

00:08:33,230 --> 00:08:41,510
just going to be any continuous stream

00:08:36,860 --> 00:08:42,620
of numeric characters equal sign is just

00:08:41,510 --> 00:08:46,100
going to be a regular expression

00:08:42,620 --> 00:08:48,650
matching the equal sign a word is any

00:08:46,100 --> 00:08:52,100
lower case alphabetic character a

00:08:48,650 --> 00:08:53,720
through z one or more times

00:08:52,100 --> 00:08:55,880
and because we're really cool we're

00:08:53,720 --> 00:08:58,820
going to ignore whitespace entirely and

00:08:55,880 --> 00:09:00,470
we're going to also ignore comments

00:08:58,820 --> 00:09:02,930
because we're good developers and while

00:09:00,470 --> 00:09:04,790
comments in the code so we'll build our

00:09:02,930 --> 00:09:06,350
lexer and then we have this lexer object

00:09:04,790 --> 00:09:07,940
and this knows about only the tokens

00:09:06,350 --> 00:09:09,470
that we've told it and what we can do

00:09:07,940 --> 00:09:11,780
with it is we can give it a stream of

00:09:09,470 --> 00:09:13,490
characters and get an iterator back and

00:09:11,780 --> 00:09:16,670
then call next on it and see what tokens

00:09:13,490 --> 00:09:20,420
it's picked up from this stream so if I

00:09:16,670 --> 00:09:22,310
Lex the string through 42 Hut equals

00:09:20,420 --> 00:09:24,380
sign I can say Next on it and get an

00:09:22,310 --> 00:09:26,180
ellipsis call next again and get a word

00:09:24,380 --> 00:09:27,440
and so each time it's giving us a token

00:09:26,180 --> 00:09:29,420
back that matches one of the ones we've

00:09:27,440 --> 00:09:31,790
previously defined and then the second

00:09:29,420 --> 00:09:33,310
sort of part the second part of the

00:09:31,790 --> 00:09:35,900
token here is the value so these are the

00:09:33,310 --> 00:09:39,020
strings or characters that it's consumed

00:09:35,900 --> 00:09:40,370
to match that token continue we get

00:09:39,020 --> 00:09:41,870
number 42

00:09:40,370 --> 00:09:43,790
notice that 42 is a string here because

00:09:41,870 --> 00:09:45,370
we're just consuming string still word

00:09:43,790 --> 00:09:48,740
Hut

00:09:45,370 --> 00:09:51,260
so if our stream has invalid tokens it

00:09:48,740 --> 00:09:52,910
continues to work until we need to

00:09:51,260 --> 00:09:55,280
consume a token that we haven't told our

00:09:52,910 --> 00:09:56,600
lexer how to analyze so if I call next

00:09:55,280 --> 00:09:58,610
on this it doesn't we never told

00:09:56,600 --> 00:10:00,500
anything about the bang and exclamation

00:09:58,610 --> 00:10:02,180
point so it just blows up it says I

00:10:00,500 --> 00:10:05,030
don't know this doesn't match any tokens

00:10:02,180 --> 00:10:08,210
and I know about so if we give our lexer

00:10:05,030 --> 00:10:10,100
our entire fizzbuzz implementation in

00:10:08,210 --> 00:10:11,240
digital it gives us these tokens back

00:10:10,100 --> 00:10:12,830
right and you can see how these

00:10:11,240 --> 00:10:14,450
correspond we have a number ellipsis a

00:10:12,830 --> 00:10:16,010
number and this just goes along until it

00:10:14,450 --> 00:10:17,690
finishes consuming the whole string and

00:10:16,010 --> 00:10:20,240
then we get all of our tokens back out

00:10:17,690 --> 00:10:21,470
of this so that's the first part of

00:10:20,240 --> 00:10:22,670
interpreting a language we break the

00:10:21,470 --> 00:10:24,500
characters in the tokens and we're

00:10:22,670 --> 00:10:26,930
calling this flexing or using a lexer

00:10:24,500 --> 00:10:29,960
the next thing we need to do is combine

00:10:26,930 --> 00:10:33,710
tokens into expressions so let's make a

00:10:29,960 --> 00:10:35,720
parser the parser is going to take this

00:10:33,710 --> 00:10:37,040
token stream so this iterator that can

00:10:35,720 --> 00:10:38,780
call next on over and over again and

00:10:37,040 --> 00:10:40,400
separate and analyze the tokens

00:10:38,780 --> 00:10:42,350
according to some set of production

00:10:40,400 --> 00:10:43,460
rules that we're going to define so the

00:10:42,350 --> 00:10:46,160
first thing we need to do is sort of

00:10:43,460 --> 00:10:50,270
break up some patterns of tokens within

00:10:46,160 --> 00:10:52,280
our language so my lovely diagram this

00:10:50,270 --> 00:10:53,600
is our implementation and I'm going to

00:10:52,280 --> 00:10:55,730
start to draw some boxes around

00:10:53,600 --> 00:10:57,470
different expressions in our language so

00:10:55,730 --> 00:10:59,090
the first I'm going to call an int box

00:10:57,470 --> 00:11:01,580
and these are just integers in the

00:10:59,090 --> 00:11:03,110
language we also have a word box these

00:11:01,580 --> 00:11:05,149
are just words and these are sort of the

00:11:03,110 --> 00:11:07,410
boundaries that encapsulate those tokens

00:11:05,149 --> 00:11:10,500
the next is a range box and this is

00:11:07,410 --> 00:11:12,630
going to be sort of a combination of

00:11:10,500 --> 00:11:14,670
tokens which is an integer and ellipses

00:11:12,630 --> 00:11:16,860
and another integer and similarly we

00:11:14,670 --> 00:11:20,310
have assignments which is a word equal

00:11:16,860 --> 00:11:22,050
sign and integer and then we're going to

00:11:20,310 --> 00:11:24,630
have the support for multiple

00:11:22,050 --> 00:11:26,310
assignments so assignments box plural is

00:11:24,630 --> 00:11:28,529
going to contain multiple assignments

00:11:26,310 --> 00:11:29,880
and then finally our whole programs will

00:11:28,529 --> 00:11:31,440
be wrapped up in what I'll call a main

00:11:29,880 --> 00:11:33,660
box and that's going to start with a

00:11:31,440 --> 00:11:36,240
range box and end with an assignment box

00:11:33,660 --> 00:11:38,190
so all together kind of looks crazy like

00:11:36,240 --> 00:11:40,500
this but you can sort of see how they

00:11:38,190 --> 00:11:43,170
nest together we get what I'll call a

00:11:40,500 --> 00:11:45,180
parse tree so at the top of the main box

00:11:43,170 --> 00:11:48,000
and it contains range and assignments

00:11:45,180 --> 00:11:53,490
and so on down below it so let's define

00:11:48,000 --> 00:11:56,040
our boxes first an inbox we're going to

00:11:53,490 --> 00:11:57,360
implement the base box from our ply and

00:11:56,040 --> 00:12:00,149
we're going to neutralize it with a

00:11:57,360 --> 00:12:02,250
value and that value is going to be the

00:12:00,149 --> 00:12:05,639
result the token that gets sent to this

00:12:02,250 --> 00:12:07,529
box so all we need to do is specify a

00:12:05,639 --> 00:12:09,209
function on this called get int that's

00:12:07,529 --> 00:12:11,339
going to turn that those series of

00:12:09,209 --> 00:12:14,130
strings which we've consumed into an

00:12:11,339 --> 00:12:16,889
integer so all this does is cast a value

00:12:14,130 --> 00:12:19,410
get string to an integer so we can use

00:12:16,889 --> 00:12:21,660
it like this we give it a token we give

00:12:19,410 --> 00:12:23,190
the token to inbox we get a box we call

00:12:21,660 --> 00:12:25,889
get in on it we get the integer result

00:12:23,190 --> 00:12:27,750
of that range box is going to be

00:12:25,889 --> 00:12:30,300
somewhat similar range box is going to

00:12:27,750 --> 00:12:33,089
take two int boxes instead low and a

00:12:30,300 --> 00:12:36,120
high and it's going to return a range is

00:12:33,089 --> 00:12:38,839
just Python range function inclusive of

00:12:36,120 --> 00:12:41,880
these two values so similarly we can

00:12:38,839 --> 00:12:44,010
instantiate a range box give it to int

00:12:41,880 --> 00:12:47,850
boxes and we can call get range on it

00:12:44,010 --> 00:12:49,139
and it will give us a range word box is

00:12:47,850 --> 00:12:50,430
going to be the simplest one since

00:12:49,139 --> 00:12:51,810
they're already strings we don't need to

00:12:50,430 --> 00:12:53,310
do anything special with it and we'll

00:12:51,810 --> 00:12:58,850
just return the result of a gift string

00:12:53,310 --> 00:13:00,630
and it looks just like this obviously

00:12:58,850 --> 00:13:02,189
next we're going to get a little more

00:13:00,630 --> 00:13:03,720
complex so the assignment box is going

00:13:02,189 --> 00:13:04,680
to do kind of a funny thing and this is

00:13:03,720 --> 00:13:07,829
what's going to let us implement

00:13:04,680 --> 00:13:10,079
fizzbuzz with this language assignments

00:13:07,829 --> 00:13:11,910
box when we account encounter that

00:13:10,079 --> 00:13:14,040
expression in our language it's going to

00:13:11,910 --> 00:13:15,360
have an eval with function and eval with

00:13:14,040 --> 00:13:17,639
is going to be called with an integer

00:13:15,360 --> 00:13:18,780
and what it does is something kind of

00:13:17,639 --> 00:13:20,580
funny if

00:13:18,780 --> 00:13:22,530
the integer that it's called with is

00:13:20,580 --> 00:13:26,100
divisible by the number that it was

00:13:22,530 --> 00:13:27,720
initialized it returned or if it's not

00:13:26,100 --> 00:13:30,840
divisible it returns an empty string if

00:13:27,720 --> 00:13:33,510
it is divisible it returns the word that

00:13:30,840 --> 00:13:34,650
it was undersized with instead so the

00:13:33,510 --> 00:13:37,280
behavior kind of looks like this if we

00:13:34,650 --> 00:13:39,810
initialize it with a word and an integer

00:13:37,280 --> 00:13:42,090
we can eval with a number that is not

00:13:39,810 --> 00:13:44,400
divisible by 3 and get an empty string

00:13:42,090 --> 00:13:47,160
back or we can evaluate a number that is

00:13:44,400 --> 00:13:50,400
divisible by 3 and we get the word that

00:13:47,160 --> 00:13:52,260
we assign to it so in order to support

00:13:50,400 --> 00:13:53,940
multiple assignments after another we

00:13:52,260 --> 00:13:55,920
sort of have this thing called

00:13:53,940 --> 00:13:57,510
assignments box which is plural and this

00:13:55,920 --> 00:13:59,700
is imagine this is kind of like a linked

00:13:57,510 --> 00:14:01,620
list you're going to have an assignment

00:13:59,700 --> 00:14:03,180
box and this is going to contain a

00:14:01,620 --> 00:14:04,920
single assignment and then it's going to

00:14:03,180 --> 00:14:06,840
point to another list of assignments

00:14:04,920 --> 00:14:09,630
boxes so it's sort of like a recursive

00:14:06,840 --> 00:14:11,370
box in this way and this is going to

00:14:09,630 --> 00:14:12,840
have a function called get lists on it

00:14:11,370 --> 00:14:14,520
so we initialize it with a list of

00:14:12,840 --> 00:14:16,890
assignments and a single assignment and

00:14:14,520 --> 00:14:19,830
get list is going to sort of take this

00:14:16,890 --> 00:14:21,360
other assignments box get the list from

00:14:19,830 --> 00:14:22,890
that and concatenate it with a single

00:14:21,360 --> 00:14:24,930
assignment we have so this is going to

00:14:22,890 --> 00:14:30,270
basically turn multiple assignments into

00:14:24,930 --> 00:14:32,010
a list of assignments so we initialize

00:14:30,270 --> 00:14:36,120
it like this we can either say it has no

00:14:32,010 --> 00:14:37,470
arguments or it has an assignment and we

00:14:36,120 --> 00:14:41,850
can call get list on it and it gives us

00:14:37,470 --> 00:14:43,050
an assignment singular box back we can

00:14:41,850 --> 00:14:44,400
build it up like this so this is two

00:14:43,050 --> 00:14:45,720
assignments one after another and you

00:14:44,400 --> 00:14:48,000
can sort of see how they're nested in

00:14:45,720 --> 00:14:51,210
each other this gives us the two

00:14:48,000 --> 00:14:53,250
assignments back and then the last thing

00:14:51,210 --> 00:14:55,350
we need to do is the main box and this

00:14:53,250 --> 00:15:00,390
is like I said before this is the range

00:14:55,350 --> 00:15:01,980
and the assignments plural and this does

00:15:00,390 --> 00:15:03,540
a slightly more complex thing so it

00:15:01,980 --> 00:15:05,160
takes the all of the integers in the

00:15:03,540 --> 00:15:06,900
range and it goes through all the

00:15:05,160 --> 00:15:08,790
assignments that it knows about and it

00:15:06,900 --> 00:15:12,090
starts to build up a line for each of

00:15:08,790 --> 00:15:14,390
the integers in the range and for all

00:15:12,090 --> 00:15:17,520
the assignments if we evaluate whether

00:15:14,390 --> 00:15:18,690
in empty string or fizz or Buzz or

00:15:17,520 --> 00:15:21,210
whatever the word for the assignment is

00:15:18,690 --> 00:15:23,430
back we append it to line and at the end

00:15:21,210 --> 00:15:25,260
we see if line contains anything or not

00:15:23,430 --> 00:15:26,850
if it contains something that means that

00:15:25,260 --> 00:15:28,830
that number that we're looking at that

00:15:26,850 --> 00:15:30,900
particular point in time was divisible

00:15:28,830 --> 00:15:31,450
by the integer that we're looking at

00:15:30,900 --> 00:15:35,110
right now

00:15:31,450 --> 00:15:37,330
so we append that two lines otherwise we

00:15:35,110 --> 00:15:39,910
just cast the integer to a string and

00:15:37,330 --> 00:15:42,400
that adds the number two lines so that

00:15:39,910 --> 00:15:44,950
is a little hard to parse but we put it

00:15:42,400 --> 00:15:46,660
all together we call a main box with a

00:15:44,950 --> 00:15:48,640
range and assignments box and we call

00:15:46,660 --> 00:15:51,040
eval on it we get this string at the

00:15:48,640 --> 00:15:53,440
bottom that's joined with new lines that

00:15:51,040 --> 00:15:55,930
looks kind of like fizzbuzz the output

00:15:53,440 --> 00:15:57,400
for fizzbuzz and you can see how that

00:15:55,930 --> 00:16:00,370
sort of falls into this parse tree here

00:15:57,400 --> 00:16:02,260
like did we show before so next thing we

00:16:00,370 --> 00:16:04,660
need to do is define productions so this

00:16:02,260 --> 00:16:07,600
is going to turn a pattern of tokens

00:16:04,660 --> 00:16:12,160
into one of our boxes so again here is

00:16:07,600 --> 00:16:13,540
our syntax thanks our productions are

00:16:12,160 --> 00:16:14,830
going to be like this range is going to

00:16:13,540 --> 00:16:16,990
be a number followed by ellipses and a

00:16:14,830 --> 00:16:19,240
number assignment is a word equals

00:16:16,990 --> 00:16:21,310
number assignments plural is an

00:16:19,240 --> 00:16:23,130
assignment it's multiple assignments

00:16:21,310 --> 00:16:25,210
followed by a single assignment but

00:16:23,130 --> 00:16:26,560
assignments can also be an empty string

00:16:25,210 --> 00:16:29,140
so this allows us to have multiple

00:16:26,560 --> 00:16:31,860
assignments and finally a main is a

00:16:29,140 --> 00:16:34,840
range followed by multiple assignments

00:16:31,860 --> 00:16:36,580
so we're going to instantiate a parser

00:16:34,840 --> 00:16:38,740
generator from our ply and tell it about

00:16:36,580 --> 00:16:39,880
the tokens that we know about and then

00:16:38,740 --> 00:16:41,770
we're going to write these production so

00:16:39,880 --> 00:16:44,800
the production is a decorator takes a

00:16:41,770 --> 00:16:48,040
string corresponding to the name of the

00:16:44,800 --> 00:16:50,380
production and number and returns a box

00:16:48,040 --> 00:16:52,510
so here the number box would return an

00:16:50,380 --> 00:16:57,010
in the number production would return an

00:16:52,510 --> 00:16:59,020
inbox a word returns a word box a range

00:16:57,010 --> 00:17:01,690
is going to have three tokens in a

00:16:59,020 --> 00:17:03,310
number ellipsis and a number and we sort

00:17:01,690 --> 00:17:04,660
of throw the ellipsis away so we only

00:17:03,310 --> 00:17:06,130
need to pass the number each of the

00:17:04,660 --> 00:17:08,620
numbers to the range box in order for it

00:17:06,130 --> 00:17:12,100
to work so a range box just takes those

00:17:08,620 --> 00:17:13,600
two arguments assignment is similar just

00:17:12,100 --> 00:17:17,350
sake of what we throw the equals away in

00:17:13,600 --> 00:17:19,210
the middle assignments plural we return

00:17:17,350 --> 00:17:20,590
the assignments box with the multiple

00:17:19,210 --> 00:17:23,290
assignments and the singular assignment

00:17:20,590 --> 00:17:25,360
and finally we support the empty string

00:17:23,290 --> 00:17:28,660
by just returning an assignment box with

00:17:25,360 --> 00:17:30,010
nothing initialized and then this is the

00:17:28,660 --> 00:17:32,500
main box which is the range in the

00:17:30,010 --> 00:17:35,980
assignments okay so we build our parser

00:17:32,500 --> 00:17:38,680
and what we get back is an object that

00:17:35,980 --> 00:17:40,570
we can pass the token stream from the

00:17:38,680 --> 00:17:43,030
lexer into the parser so what we get

00:17:40,570 --> 00:17:45,210
back from that is main box and we can

00:17:43,030 --> 00:17:46,770
call eval on it and get our

00:17:45,210 --> 00:17:50,640
the string back the goal of the whole

00:17:46,770 --> 00:17:52,350
thing so this is combining tokens into

00:17:50,640 --> 00:17:54,090
expressions which we'll call parsing and

00:17:52,350 --> 00:17:57,840
the last thing to do is evaluate the

00:17:54,090 --> 00:17:59,400
expressions so let's make an interpreter

00:17:57,840 --> 00:18:02,570
and this is going to be quick all this

00:17:59,400 --> 00:18:05,880
is is something that reads a file from

00:18:02,570 --> 00:18:08,090
the file system as a as an argument

00:18:05,880 --> 00:18:10,620
provided provided to the executable

00:18:08,090 --> 00:18:12,600
reads it takes a token stream hands it

00:18:10,620 --> 00:18:14,670
to the lexer the lexer takes that hands

00:18:12,600 --> 00:18:18,570
it to the parser and we get a result we

00:18:14,670 --> 00:18:22,220
call result eval and we print it that's

00:18:18,570 --> 00:18:24,900
it that's interpreter so let's code I

00:18:22,220 --> 00:18:27,180
can write a file fizzbuzz dot digital it

00:18:24,900 --> 00:18:30,780
looks like this I can in pip install

00:18:27,180 --> 00:18:32,490
dips pill to get executable and I can

00:18:30,780 --> 00:18:36,540
say digital fizzle if that dips pill

00:18:32,490 --> 00:18:38,640
there's my output that works so let's

00:18:36,540 --> 00:18:41,280
review real quick we defined this

00:18:38,640 --> 00:18:43,530
language and this produced this set of

00:18:41,280 --> 00:18:45,210
tokens in order and then we took those

00:18:43,530 --> 00:18:48,300
tokens we handed them to a parser and

00:18:45,210 --> 00:18:49,740
produce this parse tree all nested in

00:18:48,300 --> 00:18:51,450
each other and then we called eval on

00:18:49,740 --> 00:18:53,160
the result of all that and each of them

00:18:51,450 --> 00:18:55,620
eval their children until they came out

00:18:53,160 --> 00:18:58,100
with this result and then we printed

00:18:55,620 --> 00:19:04,020
this result to the terminal and we got

00:18:58,100 --> 00:19:06,240
this fizzbuzz implementation so let's

00:19:04,020 --> 00:19:07,800
take it one step further if this is the

00:19:06,240 --> 00:19:09,720
original fizzbuzz problem where we are

00:19:07,800 --> 00:19:11,880
checking for divisible by three and five

00:19:09,720 --> 00:19:14,160
what if we wanted to add another problem

00:19:11,880 --> 00:19:16,350
to we end them to add divisibility by

00:19:14,160 --> 00:19:18,840
seven as well right in our initial

00:19:16,350 --> 00:19:20,430
implementation this would balloon pretty

00:19:18,840 --> 00:19:22,560
quickly to a lot of multiple cases to

00:19:20,430 --> 00:19:24,480
support divisibility by 7 but in

00:19:22,560 --> 00:19:26,070
disability need to do is change the

00:19:24,480 --> 00:19:28,560
range to an appropriately large number

00:19:26,070 --> 00:19:30,600
and add one more assignment at the end

00:19:28,560 --> 00:19:32,400
and this works I can do the same thing

00:19:30,600 --> 00:19:36,540
this will print all the way up this is

00:19:32,400 --> 00:19:38,640
buzz fuzz okay I have some questions

00:19:36,540 --> 00:19:40,080
that I was anticipating I'm going to go

00:19:38,640 --> 00:19:41,880
ahead and answer for you guys so the

00:19:40,080 --> 00:19:44,700
first thing is why would I ever want to

00:19:41,880 --> 00:19:46,890
do this so if you're talking about div

00:19:44,700 --> 00:19:48,630
school is obviously really only good for

00:19:46,890 --> 00:19:51,150
one thing which is implementing fizzbuzz

00:19:48,630 --> 00:19:53,460
so if you ever meet this guy make sure

00:19:51,150 --> 00:19:56,160
that you break it out and show it off to

00:19:53,460 --> 00:19:57,180
him but if really your question is why

00:19:56,160 --> 00:19:58,440
would I ever want to make my own

00:19:57,180 --> 00:20:00,450
language

00:19:58,440 --> 00:20:01,710
that's the valid question right Python

00:20:00,450 --> 00:20:03,270
is pretty good why would I want to make

00:20:01,710 --> 00:20:04,710
another one so I didn't really have a

00:20:03,270 --> 00:20:07,170
great answer to this but yesterday I was

00:20:04,710 --> 00:20:09,480
in James's talk next level testing and

00:20:07,170 --> 00:20:12,150
one of his examples he talks about his

00:20:09,480 --> 00:20:13,910
tool James Pat and in his talk I learned

00:20:12,150 --> 00:20:16,710
two things first I learned that this

00:20:13,910 --> 00:20:18,720
module is called James path which means

00:20:16,710 --> 00:20:20,820
he named after himself and clearly I

00:20:18,720 --> 00:20:22,710
will approve of that but the second

00:20:20,820 --> 00:20:25,110
thing is that it uses something called a

00:20:22,710 --> 00:20:27,450
james path expression so here it

00:20:25,110 --> 00:20:29,250
provides a API called search you can

00:20:27,450 --> 00:20:30,750
provide a sort of a query and a

00:20:29,250 --> 00:20:32,850
dictionary and you get the result from

00:20:30,750 --> 00:20:34,620
that dictionary and this is going to get

00:20:32,850 --> 00:20:36,600
really complex right like he has this

00:20:34,620 --> 00:20:39,090
thing where you can get the name and

00:20:36,600 --> 00:20:40,440
sort it and join it with other things so

00:20:39,090 --> 00:20:41,970
this is actually like a pretty complex

00:20:40,440 --> 00:20:43,980
languages query language for james path

00:20:41,970 --> 00:20:45,510
and how do you think he's doing it right

00:20:43,980 --> 00:20:47,880
like so if you look at the source for

00:20:45,510 --> 00:20:50,100
james path he's got a lexer and a parser

00:20:47,880 --> 00:20:51,990
in here now he's not using our ply or

00:20:50,100 --> 00:20:53,940
ply and I don't really know enough about

00:20:51,990 --> 00:20:55,080
it to say if he could but this is a

00:20:53,940 --> 00:20:56,910
really great example of one you might

00:20:55,080 --> 00:20:58,650
want to just make your own language so

00:20:56,910 --> 00:21:02,070
here's another question I'm anticipating

00:20:58,650 --> 00:21:03,690
is is it faster again this kind of

00:21:02,070 --> 00:21:05,820
depends on what you mean right like if

00:21:03,690 --> 00:21:07,500
you mean is it faster to implement CID

00:21:05,820 --> 00:21:09,030
buzz then yes obviously it's like

00:21:07,500 --> 00:21:11,190
super-short you could put it in a tweet

00:21:09,030 --> 00:21:14,570
it's really tiny and you still have room

00:21:11,190 --> 00:21:17,460
for like hash tags and handclaps right

00:21:14,570 --> 00:21:19,650
and by the way I made our social media

00:21:17,460 --> 00:21:22,740
guy tweet that so if you guys go and

00:21:19,650 --> 00:21:24,180
retweet it he'd really appreciate it but

00:21:22,740 --> 00:21:25,560
it's what if you were here to come to

00:21:24,180 --> 00:21:28,080
see some like really high performance

00:21:25,560 --> 00:21:30,450
this buzzing you might be asking is it

00:21:28,080 --> 00:21:34,080
faster to evaluates as buzz and again

00:21:30,450 --> 00:21:35,760
this I think is kind of yes so as long

00:21:34,080 --> 00:21:37,920
as you get past the amount of time it

00:21:35,760 --> 00:21:40,680
takes for our Python to I don't use the

00:21:37,920 --> 00:21:43,730
word compile but sort of annotate our

00:21:40,680 --> 00:21:45,810
program and look full of rainbows too

00:21:43,730 --> 00:21:47,730
this takes quite a while this takes like

00:21:45,810 --> 00:21:50,040
43 seconds so for everything I just

00:21:47,730 --> 00:21:52,110
showed you guys but I wrote some

00:21:50,040 --> 00:21:54,360
benchmarks very unscientifically where I

00:21:52,110 --> 00:21:56,640
printed sis was up to a million this is

00:21:54,360 --> 00:21:58,980
our naive method and this is fizzbuzz

00:21:56,640 --> 00:22:00,750
implementation and I just ran time like

00:21:58,980 --> 00:22:02,280
three times for each one and it kind of

00:22:00,750 --> 00:22:04,380
looks like dibbles a little bit faster

00:22:02,280 --> 00:22:08,070
so I'd say yeah it's actually faster in

00:22:04,380 --> 00:22:09,630
both senses of the word okay so I'm

00:22:08,070 --> 00:22:11,520
about to wrap up I have some links for

00:22:09,630 --> 00:22:11,760
you guys the first is my github where I

00:22:11,520 --> 00:22:13,380
have

00:22:11,760 --> 00:22:15,440
you things I have full digital

00:22:13,380 --> 00:22:18,600
implementation and it's also on pi PI

00:22:15,440 --> 00:22:20,010
and I also have a tox repository so you

00:22:18,600 --> 00:22:22,290
can see all the source for this talks

00:22:20,010 --> 00:22:23,490
including the proposals that I wrote to

00:22:22,290 --> 00:22:25,320
get this talk accepted if you're

00:22:23,490 --> 00:22:28,310
interested in doing your own PyCon talk

00:22:25,320 --> 00:22:30,300
and also the prop works website is there

00:22:28,310 --> 00:22:32,360
so I want to say thanks to a few people

00:22:30,300 --> 00:22:34,980
on to say thanks to prompt works for

00:22:32,360 --> 00:22:37,050
sending me here and helping me do this

00:22:34,980 --> 00:22:38,760
work and all my other open-source work I

00:22:37,050 --> 00:22:40,950
wanna say thanks to David easily and

00:22:38,760 --> 00:22:42,540
Alice gainer who who are giants and

00:22:40,950 --> 00:22:44,610
created some of the tools that I used to

00:22:42,540 --> 00:22:46,740
do this bike on staff and volunteers and

00:22:44,610 --> 00:22:49,160
also thanks to all of you for coming and

00:22:46,740 --> 00:22:49,160
listening

00:22:53,010 --> 00:22:57,420
I think we have maybe five minutes for

00:22:56,220 --> 00:23:00,770
questions if anyone has a question we

00:22:57,420 --> 00:23:00,770
have seven minutes for questions

00:23:07,370 --> 00:23:14,220
hi what does our Python actually do in

00:23:12,210 --> 00:23:16,920
your example is it

00:23:14,220 --> 00:23:17,580
what interprets or you can build parsers

00:23:16,920 --> 00:23:20,360
or what

00:23:17,580 --> 00:23:23,760
so our Python is a framework for

00:23:20,360 --> 00:23:26,490
describing languages with Python

00:23:23,760 --> 00:23:27,720
basically so what I use it for here it's

00:23:26,490 --> 00:23:29,640
not actually necessary that I do this

00:23:27,720 --> 00:23:31,200
make it compatible with our Python but

00:23:29,640 --> 00:23:32,700
because our ply is designed to be

00:23:31,200 --> 00:23:35,580
compiled with our Python it was sort of

00:23:32,700 --> 00:23:37,350
an exercise to see if I could do it and

00:23:35,580 --> 00:23:39,780
so what it gives us is it allows us to

00:23:37,350 --> 00:23:42,120
take the Python code to be right and

00:23:39,780 --> 00:23:43,860
make something a bit like a binary just

00:23:42,120 --> 00:23:45,330
an executable that we can run which is

00:23:43,860 --> 00:23:47,280
what the digital command that was

00:23:45,330 --> 00:23:49,200
running was if you're interested in our

00:23:47,280 --> 00:23:51,300
Python that's what they used to build pi

00:23:49,200 --> 00:23:52,920
PI which is so close to Python and you

00:23:51,300 --> 00:23:54,480
can look into it most people unless

00:23:52,920 --> 00:23:56,640
you're designing and writing languages

00:23:54,480 --> 00:24:03,930
you're not going to use our Python okay

00:23:56,640 --> 00:24:05,760
thanks yeah and after you took up the

00:24:03,930 --> 00:24:07,410
entire interview with the clueless

00:24:05,760 --> 00:24:11,730
manager they ask you to implement

00:24:07,410 --> 00:24:13,530
fizzbuzz did he offer you the job like I

00:24:11,730 --> 00:24:16,080
said that is the hypothetical situation

00:24:13,530 --> 00:24:18,000
so I think you know if someone asks you

00:24:16,080 --> 00:24:19,350
fizzbuzz in an interview and you use

00:24:18,000 --> 00:24:21,240
digital to solve it you're probably

00:24:19,350 --> 00:24:28,680
doing yourself a favor and it might not

00:24:21,240 --> 00:24:30,180
hire you play any other question okay

00:24:28,680 --> 00:24:36,269
thanks everybody

00:24:30,180 --> 00:24:36,269

YouTube URL: https://www.youtube.com/watch?v=ApgUrtCrmV8


