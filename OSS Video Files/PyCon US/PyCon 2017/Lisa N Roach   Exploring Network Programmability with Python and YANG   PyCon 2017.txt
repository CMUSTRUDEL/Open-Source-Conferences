Title: Lisa N Roach   Exploring Network Programmability with Python and YANG   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Lisa N Roach

Recently, networking vendors and Silicon Valley giants have been putting forth a concerted effort to build standardized models for networking devices. These models allow for building reusable and versatile scripts with predictable, standardized data. Without such models, the wide variety of inputs and outputs required by different devices and vendors made scripting a tedious and challenging endeavor. The modeling language in use is called YANG, and a variety of standards have emerged. A vendor agnostic standard called OpenConfig has lately become stable enough to begin programming devices with it. Using Python, YANG is surprisingly easy to work with, and extremely powerful applications can be written with basic knowledge of JSON or XML and RPCs. 

The talk will start with use-cases for programming networking devices, and will detail a specific, trivial, use case that will be used in the talk. Next, we will discuss the ‘legacy’ way of programming devices (SSH and screenscraping), and highlight the challenges, such as complex regular expressions, slow responses, and lack of reusability between devices. From there we will dive into YANG, focusing on OpenConfig models. A YANG model is essentially a template, and JSON or XML can be mapped to the YANG template. This makes it perfect for Pythonic manipulation. In the use case there will be a GET RPC returning a YANG representation of the box’s state in JSON, which we will search for the relevant health indicator by drilling down in the JSON dictionary. A simple change to the dictionary will remediate the problem, and a PATCH RPC merges the new configuration onto the box. Since open, standard models are in use, this script could be run on many devices across a network to achieve the same effect with no changes needed. We will finish up with the pros and cons of YANG before opening the talk for Q&A.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:00,000 --> 00:00:03,870
which exploring network programmability

00:00:02,010 --> 00:00:12,179
with python and yang please give our

00:00:03,870 --> 00:00:14,549
hand so hi everybody again my name is

00:00:12,179 --> 00:00:16,529
Lisa Roach I'm really excited to be here

00:00:14,549 --> 00:00:18,930
today to talk to you about how we can

00:00:16,529 --> 00:00:21,150
program and automate networks using

00:00:18,930 --> 00:00:23,519
Python and a modeling language called

00:00:21,150 --> 00:00:24,930
yang this talk is going to be relatively

00:00:23,519 --> 00:00:26,730
basic in terms of the networking

00:00:24,930 --> 00:00:28,470
concepts that we cover so if you're a

00:00:26,730 --> 00:00:30,330
Python developer who's not super

00:00:28,470 --> 00:00:32,070
familiar with networking don't worry

00:00:30,330 --> 00:00:33,540
about it I'm really hoping to be able to

00:00:32,070 --> 00:00:35,790
speak to developers who are interested

00:00:33,540 --> 00:00:37,290
in getting involved in networking but

00:00:35,790 --> 00:00:41,910
maybe don't have a ton of experience

00:00:37,290 --> 00:00:43,649
right now so Who am I previously I was a

00:00:41,910 --> 00:00:44,309
software assistance engineer at Cisco

00:00:43,649 --> 00:00:46,050
Systems

00:00:44,309 --> 00:00:48,239
hence my background and interest in

00:00:46,050 --> 00:00:50,039
networking currently I'm a production

00:00:48,239 --> 00:00:52,590
engineer at Facebook actually doing

00:00:50,039 --> 00:00:54,510
back-end security so this talk isn't

00:00:52,590 --> 00:00:55,949
going to be about what Facebook does but

00:00:54,510 --> 00:00:57,539
if you're interested in what Facebook

00:00:55,949 --> 00:00:59,190
does for their networking I definitely

00:00:57,539 --> 00:01:00,870
encourage you to go check out online

00:00:59,190 --> 00:01:02,579
they've open sourced a ton of their

00:01:00,870 --> 00:01:06,540
documentation so it may answer any

00:01:02,579 --> 00:01:08,729
questions you have so what can we

00:01:06,540 --> 00:01:10,890
program what do I mean by a networking

00:01:08,729 --> 00:01:12,360
device well I'm not talking about the

00:01:10,890 --> 00:01:14,100
Linksys routers that are in your home

00:01:12,360 --> 00:01:15,960
office I'm talking about the big

00:01:14,100 --> 00:01:17,729
switches and routers that you would find

00:01:15,960 --> 00:01:20,340
in your corporate data centers or your

00:01:17,729 --> 00:01:23,220
corporate backbone lands so those

00:01:20,340 --> 00:01:26,759
devices typically are configured using a

00:01:23,220 --> 00:01:28,350
CLI manually line by line which can be a

00:01:26,759 --> 00:01:30,509
little bit slow and challenging

00:01:28,350 --> 00:01:33,930
especially once you start reaching scale

00:01:30,509 --> 00:01:36,689
you can definitely manage a number of

00:01:33,930 --> 00:01:38,820
devices using CLI pretty easily but once

00:01:36,689 --> 00:01:41,280
you start growing from 10 devices to a

00:01:38,820 --> 00:01:44,159
hundred devices or a hundred devices to

00:01:41,280 --> 00:01:46,799
thousands of devices you really have to

00:01:44,159 --> 00:01:49,439
start automating so what kind of stuff

00:01:46,799 --> 00:01:51,720
do we want to automate well a huge one

00:01:49,439 --> 00:01:53,790
is configuration management if we're

00:01:51,720 --> 00:01:56,520
opening up a brand-new data center with

00:01:53,790 --> 00:01:59,369
a thousand switches we realistically

00:01:56,520 --> 00:02:00,719
can't go through the CLI of every single

00:01:59,369 --> 00:02:02,939
one of those and apply a new

00:02:00,719 --> 00:02:05,340
configuration what we want to do instead

00:02:02,939 --> 00:02:07,229
is have software that can run and apply

00:02:05,340 --> 00:02:10,140
the configuration on every single device

00:02:07,229 --> 00:02:13,800
at once this can take a new data center

00:02:10,140 --> 00:02:16,020
turn up time from weeks down to days

00:02:13,800 --> 00:02:17,480
after our datacenter is up we want to

00:02:16,020 --> 00:02:20,670
keep track of the health of our devices

00:02:17,480 --> 00:02:21,960
currently this is done using SNMP but

00:02:20,670 --> 00:02:23,760
some of the ways that I'm going to talk

00:02:21,960 --> 00:02:26,550
about today actually can gather more

00:02:23,760 --> 00:02:29,190
data more quickly than SNMP this allows

00:02:26,550 --> 00:02:31,170
us to do automatic problem remediation

00:02:29,190 --> 00:02:35,010
or include monitoring and alarming

00:02:31,170 --> 00:02:38,010
systems for our IT workers now these are

00:02:35,010 --> 00:02:39,870
two kind of basic must-haves but if we

00:02:38,010 --> 00:02:42,330
truly can program a networking device

00:02:39,870 --> 00:02:44,190
say if we have access to the routing

00:02:42,330 --> 00:02:45,780
tables on the device we can start

00:02:44,190 --> 00:02:48,660
getting a little bit more interesting we

00:02:45,780 --> 00:02:51,240
can start making custom protocols so if

00:02:48,660 --> 00:02:53,310
you know your application so well you

00:02:51,240 --> 00:02:54,990
know exactly what paths you wanted to

00:02:53,310 --> 00:02:57,840
take in the network you can actually

00:02:54,990 --> 00:02:59,760
start adding custom protocols instead of

00:02:57,840 --> 00:03:02,460
the protocols that come by default on

00:02:59,760 --> 00:03:05,250
box and those custom protocols can be

00:03:02,460 --> 00:03:07,260
whatever is perfect for your application

00:03:05,250 --> 00:03:09,510
so it's making your network a lot more

00:03:07,260 --> 00:03:11,460
efficient there's more things I could go

00:03:09,510 --> 00:03:13,500
into but these are just some of the more

00:03:11,460 --> 00:03:14,880
interesting examples that you can apply

00:03:13,500 --> 00:03:19,260
the concepts I'm going to talk about

00:03:14,880 --> 00:03:21,330
today's - so how can we program

00:03:19,260 --> 00:03:22,590
networking devices there's currently

00:03:21,330 --> 00:03:25,830
really three ways to do it

00:03:22,590 --> 00:03:27,780
the first way is with AP is a lot of

00:03:25,830 --> 00:03:30,780
data center devices nowadays ship with

00:03:27,780 --> 00:03:32,880
an API on box this is probably the

00:03:30,780 --> 00:03:34,530
easiest way to program a device if I'm

00:03:32,880 --> 00:03:37,170
going to be honest they usually work

00:03:34,530 --> 00:03:40,800
really well there's documentation gotta

00:03:37,170 --> 00:03:42,930
love them but API is if I have a brand

00:03:40,800 --> 00:03:45,600
new data center with a thousand switches

00:03:42,930 --> 00:03:47,670
all those switches probably don't have

00:03:45,600 --> 00:03:51,350
the same API on every single one of them

00:03:47,670 --> 00:03:53,850
so I can't do a one script to up to

00:03:51,350 --> 00:03:56,280
apply my configuration to all my devices

00:03:53,850 --> 00:03:58,830
and when I want to talk about today is

00:03:56,280 --> 00:04:01,650
ways we can program our entire network

00:03:58,830 --> 00:04:03,570
not just a single box so be aware that

00:04:01,650 --> 00:04:05,300
api's are available but I'm not really

00:04:03,570 --> 00:04:09,090
going to talk about them too much today

00:04:05,300 --> 00:04:11,280
the second way is via SSH every

00:04:09,090 --> 00:04:13,190
networking device has SSH on it I'm

00:04:11,280 --> 00:04:15,630
pretty sure

00:04:13,190 --> 00:04:18,630
SSH as long as you've got a library like

00:04:15,630 --> 00:04:21,720
param Eco like P expects like NAT miko

00:04:18,630 --> 00:04:24,060
you can send those CLI commands directly

00:04:21,720 --> 00:04:26,800
to the box over SSH you can screen

00:04:24,060 --> 00:04:28,449
scrape the output use regex

00:04:26,800 --> 00:04:30,610
is a common way that people have been

00:04:28,449 --> 00:04:32,560
doing for a long time so I'm sure lots

00:04:30,610 --> 00:04:35,560
of people here are familiar with the

00:04:32,560 --> 00:04:38,680
joys of working with SSH on a networking

00:04:35,560 --> 00:04:40,030
device the third way of course is what

00:04:38,680 --> 00:04:42,250
I'm going to be talking about which is

00:04:40,030 --> 00:04:44,860
using yang models and remote procedural

00:04:42,250 --> 00:04:46,780
calls the way this talk is set up is I'm

00:04:44,860 --> 00:04:48,610
going to introduce a networking scenario

00:04:46,780 --> 00:04:51,250
where something is broken on a switch

00:04:48,610 --> 00:04:53,319
and we will first use SSH to try to

00:04:51,250 --> 00:04:55,750
diagnose that problem and then fix it

00:04:53,319 --> 00:04:57,699
and then we'll use yang models in our PC

00:04:55,750 --> 00:04:58,990
to diagnose the problems and fix it so

00:04:57,699 --> 00:05:02,250
you can compare and contrast the

00:04:58,990 --> 00:05:05,650
differences between the two techniques

00:05:02,250 --> 00:05:08,139
so here's our scenario we have switch a

00:05:05,650 --> 00:05:10,240
trying to talk to switch beep for some

00:05:08,139 --> 00:05:12,280
reason switch a cannot send its packets

00:05:10,240 --> 00:05:15,159
two gigabit ethernet zero zero zero zero

00:05:12,280 --> 00:05:17,020
we suspect somebody has fat-fingered the

00:05:15,159 --> 00:05:18,879
interface and has accidentally shut it

00:05:17,020 --> 00:05:22,719
down so the interface is just not on

00:05:18,879 --> 00:05:25,180
super basic how can we diagnose this

00:05:22,719 --> 00:05:28,090
without yang or api's well this would be

00:05:25,180 --> 00:05:29,710
using SSH personally I like using the

00:05:28,090 --> 00:05:31,810
paramiku library so that's what I'm

00:05:29,710 --> 00:05:34,180
doing here today the first thing we want

00:05:31,810 --> 00:05:35,110
to do is connect to the box then I have

00:05:34,180 --> 00:05:37,389
a hard-coded

00:05:35,110 --> 00:05:39,340
CLI command this is the exact CLI

00:05:37,389 --> 00:05:41,969
command I would be sending to the box if

00:05:39,340 --> 00:05:44,949
I was manually typing on the CLI I

00:05:41,969 --> 00:05:46,990
screen scrape the output and then I do a

00:05:44,949 --> 00:05:50,319
regex search to see if my Gigabit

00:05:46,990 --> 00:05:52,509
Ethernet zero zero zero is up now this

00:05:50,319 --> 00:05:54,940
script works but it has a problem and

00:05:52,509 --> 00:05:56,979
that problem is these hard-coded

00:05:54,940 --> 00:05:59,379
commands and the hard-coded output

00:05:56,979 --> 00:06:01,509
screen screen now I could take the

00:05:59,379 --> 00:06:03,190
interface out make it a little bit more

00:06:01,509 --> 00:06:06,520
intelligent to have the interface be a

00:06:03,190 --> 00:06:09,969
variable but taking out show interface

00:06:06,520 --> 00:06:12,610
and is up is a lot more complicated if I

00:06:09,969 --> 00:06:14,500
have my thousand switches and within

00:06:12,610 --> 00:06:17,349
those thousand switches maybe I have 10

00:06:14,500 --> 00:06:18,940
different operating systems and if those

00:06:17,349 --> 00:06:21,759
10 different operating systems don't

00:06:18,940 --> 00:06:23,889
expect the exact words show interface in

00:06:21,759 --> 00:06:26,529
that order we have to rewrite this

00:06:23,889 --> 00:06:28,750
script or somehow program intelligence

00:06:26,529 --> 00:06:30,699
to sense what OS were on and figure out

00:06:28,750 --> 00:06:32,949
what exact words we need to put there

00:06:30,699 --> 00:06:35,080
instead so instead of show interface

00:06:32,949 --> 00:06:38,289
maybe it's show IP interface or whatever

00:06:35,080 --> 00:06:40,630
it is so this code is not repeatable

00:06:38,289 --> 00:06:41,890
without a large amount of work

00:06:40,630 --> 00:06:43,540
that we need to put into it for

00:06:41,890 --> 00:06:47,170
something that's so simple and that's

00:06:43,540 --> 00:06:49,210
really frustrating and I do want to

00:06:47,170 --> 00:06:52,480
point out networks are heavily mixed

00:06:49,210 --> 00:06:55,090
it's maybe unheard of to actually have a

00:06:52,480 --> 00:06:57,540
network at scale that uses all one

00:06:55,090 --> 00:06:59,950
operating system or even all one vendor

00:06:57,540 --> 00:07:02,560
typically operating system are typically

00:06:59,950 --> 00:07:04,990
networks have multiple vendors multiple

00:07:02,560 --> 00:07:06,610
operating systems so it was almost a

00:07:04,990 --> 00:07:08,620
guarantee I would have to be rewriting

00:07:06,610 --> 00:07:10,630
the script over and over again or

00:07:08,620 --> 00:07:12,430
developing some complicated framework to

00:07:10,630 --> 00:07:17,460
handle all of the differences that could

00:07:12,430 --> 00:07:20,320
happen so this leads us to yahng yahng

00:07:17,460 --> 00:07:24,340
stands for yet another next generation

00:07:20,320 --> 00:07:26,290
it is a data modeling language used to

00:07:24,340 --> 00:07:28,830
describe configuration and state

00:07:26,290 --> 00:07:30,910
hierarchical data of networking devices

00:07:28,830 --> 00:07:33,190
so I'll highlight a couple things in

00:07:30,910 --> 00:07:35,530
that sentence it is a language some

00:07:33,190 --> 00:07:37,720
people kind of gloss over that when they

00:07:35,530 --> 00:07:40,870
hear about yangyang itself is a language

00:07:37,720 --> 00:07:43,750
that builds models it describes both

00:07:40,870 --> 00:07:45,760
configuration and operational state data

00:07:43,750 --> 00:07:48,010
so we can see everything that we've

00:07:45,760 --> 00:07:50,350
configured on our device as well as

00:07:48,010 --> 00:07:52,930
operational data like how many packets

00:07:50,350 --> 00:07:54,700
were seeing even grant really granular

00:07:52,930 --> 00:07:56,980
stuff like what's the temperature of my

00:07:54,700 --> 00:07:58,900
CPU right now so you can do some really

00:07:56,980 --> 00:08:01,810
interesting telemetry with with yang

00:07:58,900 --> 00:08:04,420
operational models and then finally how

00:08:01,810 --> 00:08:07,420
can yang help well yank gives us the

00:08:04,420 --> 00:08:09,520
opportunity to have a consistent model

00:08:07,420 --> 00:08:12,520
for configuring our networking devices

00:08:09,520 --> 00:08:15,610
and grabbing operational state data off

00:08:12,520 --> 00:08:19,060
those devices so the really important

00:08:15,610 --> 00:08:21,700
word there is consistent if every single

00:08:19,060 --> 00:08:23,920
operating system does not apply the same

00:08:21,700 --> 00:08:26,290
yang model then we have the same problem

00:08:23,920 --> 00:08:28,390
that we just saw with SSH yang doesn't

00:08:26,290 --> 00:08:32,200
really solve that problem inherently

00:08:28,390 --> 00:08:34,960
yang needs to be standardized and that

00:08:32,200 --> 00:08:38,169
we all know how fun standard making can

00:08:34,960 --> 00:08:41,289
be so I really like this xkcd comic

00:08:38,169 --> 00:08:43,180
where the stick figure jokes there's

00:08:41,289 --> 00:08:44,680
fourteen standards that's ridiculous we

00:08:43,180 --> 00:08:46,960
should just make one standard that

00:08:44,680 --> 00:08:51,310
covers all use cases and you end up with

00:08:46,960 --> 00:08:54,400
15 standards so yang doesn't quite have

00:08:51,310 --> 00:08:58,240
15 but I think I counted at least

00:08:54,400 --> 00:08:59,980
I've one is ietf so the internet

00:08:58,240 --> 00:09:02,680
Engineering Task Force which actually

00:08:59,980 --> 00:09:04,750
published the yang RFC they are creating

00:09:02,680 --> 00:09:06,700
their own standard model but it's been a

00:09:04,750 --> 00:09:09,190
little bit slow Yang's been around for

00:09:06,700 --> 00:09:12,310
seven years and it hasn't quite covered

00:09:09,190 --> 00:09:13,660
a lot of use cases so Google decided hey

00:09:12,310 --> 00:09:16,300
we're going to come along we're going to

00:09:13,660 --> 00:09:18,430
speed this up Google made their own

00:09:16,300 --> 00:09:20,830
standard called open config which is

00:09:18,430 --> 00:09:23,500
open source to the community and has a

00:09:20,830 --> 00:09:25,720
really wide range of support I would say

00:09:23,500 --> 00:09:27,970
it's probably the most well adopted of

00:09:25,720 --> 00:09:31,120
standards so I'm going to be using open

00:09:27,970 --> 00:09:35,020
config in my talk there's also I Triple

00:09:31,120 --> 00:09:37,270
E standards a broadband standards more

00:09:35,020 --> 00:09:39,400
standards on standards but if I'm going

00:09:37,270 --> 00:09:41,560
to recommend a standard today just use

00:09:39,400 --> 00:09:45,210
open config and if we all use open

00:09:41,560 --> 00:09:48,730
config then it'll all work out okay

00:09:45,210 --> 00:09:50,560
there's also vendor specific standards

00:09:48,730 --> 00:09:53,440
but that makes sense it's really

00:09:50,560 --> 00:09:55,750
impossible to create one standard that's

00:09:53,440 --> 00:09:58,300
going to cover every vendors feature set

00:09:55,750 --> 00:09:59,820
ever so we want to be able to allow

00:09:58,300 --> 00:10:01,810
vendors to have competitive

00:09:59,820 --> 00:10:04,450
differentiating features that they can

00:10:01,810 --> 00:10:07,270
add to yang models so you can actually

00:10:04,450 --> 00:10:09,460
extend open config yang models with

00:10:07,270 --> 00:10:11,230
vendor specific yang models so that way

00:10:09,460 --> 00:10:13,120
you can still use open config for

00:10:11,230 --> 00:10:14,830
everything that's standardized but if

00:10:13,120 --> 00:10:16,840
you have something specific you can

00:10:14,830 --> 00:10:19,120
extend it with the feature that you want

00:10:16,840 --> 00:10:21,100
you can also choose to just use

00:10:19,120 --> 00:10:25,120
completely that vendors model and not

00:10:21,100 --> 00:10:27,550
open config at all so what does yang

00:10:25,120 --> 00:10:30,160
look like yang is all about data

00:10:27,550 --> 00:10:32,440
hierarchy and defining exactly what

00:10:30,160 --> 00:10:35,380
order our data should be in and what

00:10:32,440 --> 00:10:37,750
type of data it should be at the top of

00:10:35,380 --> 00:10:39,850
every yang module is the name of the

00:10:37,750 --> 00:10:41,650
name of the module today I'm interested

00:10:39,850 --> 00:10:44,080
in interfaces and I want to use open

00:10:41,650 --> 00:10:47,230
config so I'm using the open config

00:10:44,080 --> 00:10:49,450
interfaces module the modules contain

00:10:47,230 --> 00:10:51,250
containers in this case we're interested

00:10:49,450 --> 00:10:54,310
in the container that contains my

00:10:51,250 --> 00:10:56,740
interfaces within there I have a list of

00:10:54,310 --> 00:10:58,780
interfaces and within the interface I

00:10:56,740 --> 00:11:01,180
have data nodes and in this case that's

00:10:58,780 --> 00:11:03,280
just the name of my interface so that's

00:11:01,180 --> 00:11:06,970
where we will actually see our data will

00:11:03,280 --> 00:11:08,230
be the value of name now these can get

00:11:06,970 --> 00:11:10,030
to be a little bit

00:11:08,230 --> 00:11:12,940
are complicated you might be able to see

00:11:10,030 --> 00:11:14,790
that this container is grouped and the

00:11:12,940 --> 00:11:17,950
other container config at the bottom is

00:11:14,790 --> 00:11:20,320
using a grouping now this makes it

00:11:17,950 --> 00:11:22,540
really flexible but it also makes yen

00:11:20,320 --> 00:11:25,090
models nonlinear when you're trying to

00:11:22,540 --> 00:11:26,470
read them which is not a lot of fun if

00:11:25,090 --> 00:11:29,020
I'm trying to figure out what should be

00:11:26,470 --> 00:11:32,020
nested because you have to jump all over

00:11:29,020 --> 00:11:34,030
the model and sometimes you even have to

00:11:32,020 --> 00:11:35,920
jump to different models to try to find

00:11:34,030 --> 00:11:38,410
the grouping that's using it can be a

00:11:35,920 --> 00:11:41,170
little frustrating but there are tools

00:11:38,410 --> 00:11:43,750
to help so there's a tool called pying

00:11:41,170 --> 00:11:44,950
which includes and it's a whole bunch of

00:11:43,750 --> 00:11:46,630
stuff you can do one of the things

00:11:44,950 --> 00:11:47,560
that's it includes is a tree

00:11:46,630 --> 00:11:49,810
functionality

00:11:47,560 --> 00:11:51,760
so if tree I can print out the whole

00:11:49,810 --> 00:11:53,110
yang model the whole hierarchy including

00:11:51,760 --> 00:11:55,600
readwrite data

00:11:53,110 --> 00:11:57,370
read-only data would be that operational

00:11:55,600 --> 00:11:59,590
data I was talking about so just the

00:11:57,370 --> 00:12:06,040
state of the box as well as metadata

00:11:59,590 --> 00:12:09,010
like types etc so how can we use yang if

00:12:06,040 --> 00:12:10,900
we picture data on a box it's just being

00:12:09,010 --> 00:12:11,980
an unstructured blobs don't worry you're

00:12:10,900 --> 00:12:13,750
not supposed to be able to read this

00:12:11,980 --> 00:12:17,020
slide it's just a blob of data

00:12:13,750 --> 00:12:19,570
if that's how boxes are without yang

00:12:17,020 --> 00:12:21,810
when we take Yang and we apply it to a

00:12:19,570 --> 00:12:24,040
box we're structuring that data

00:12:21,810 --> 00:12:27,100
according to the way that the model has

00:12:24,040 --> 00:12:28,900
specified so our data is now all laid

00:12:27,100 --> 00:12:32,500
out in the order and the types that the

00:12:28,900 --> 00:12:35,110
yang model said it should be once we

00:12:32,500 --> 00:12:36,970
have our yang of fide data we want to

00:12:35,110 --> 00:12:39,280
have an RPC server running on our

00:12:36,970 --> 00:12:41,980
networking device yang itself was

00:12:39,280 --> 00:12:45,040
originally written for the net cough RPC

00:12:41,980 --> 00:12:47,050
server so if you're reading the yang RFC

00:12:45,040 --> 00:12:49,330
you'll see tons of references to Netcom

00:12:47,050 --> 00:12:53,290
specific stuff but nowadays there's

00:12:49,330 --> 00:12:57,880
other RPC ins available there's G RPC

00:12:53,290 --> 00:13:01,330
rest comp Apache thrift and I think

00:12:57,880 --> 00:13:01,960
that's it and well in the net comp that

00:13:01,330 --> 00:13:06,100
was the other one

00:13:01,960 --> 00:13:08,320
so neck comp uses a data encoding of XML

00:13:06,100 --> 00:13:09,670
and you'll even find in the yang RFC

00:13:08,320 --> 00:13:12,640
that there's a whole section dedicated

00:13:09,670 --> 00:13:15,250
just to how do I convert yang models to

00:13:12,640 --> 00:13:18,580
XML data and that conversion process is

00:13:15,250 --> 00:13:20,860
called in so you can do yang to Yen kind

00:13:18,580 --> 00:13:22,150
of a cute little name and the pieing

00:13:20,860 --> 00:13:23,830
tool that I just showed you

00:13:22,150 --> 00:13:26,410
actually has a functionality to do that

00:13:23,830 --> 00:13:28,750
conversion for you automatically but I

00:13:26,410 --> 00:13:30,490
don't really like working with XML if I

00:13:28,750 --> 00:13:32,710
had to choose I would much rather work

00:13:30,490 --> 00:13:35,560
with JSON data so instead of using

00:13:32,710 --> 00:13:38,920
Netcom I wanted to use the G RPC server

00:13:35,560 --> 00:13:42,760
which is a superfast RPC and have it

00:13:38,920 --> 00:13:45,550
send me JSON data so how can I use this

00:13:42,760 --> 00:13:48,130
G RPC server well if I have my RPC

00:13:45,550 --> 00:13:50,290
client all I need to do is do a get

00:13:48,130 --> 00:13:52,000
request from my server so I can get

00:13:50,290 --> 00:13:54,310
operational data or I can get

00:13:52,000 --> 00:13:57,490
configuration data and it'll send me

00:13:54,310 --> 00:14:00,820
that step back in my JSON format or my

00:13:57,490 --> 00:14:03,340
XML format whatever I've requested now

00:14:00,820 --> 00:14:05,680
you can be done here or if I want to

00:14:03,340 --> 00:14:07,900
make it change to my configuration I can

00:14:05,680 --> 00:14:10,330
just sort of tweak that configuration

00:14:07,900 --> 00:14:12,940
that I got back from the box and make my

00:14:10,330 --> 00:14:15,010
update send it back to the RPC server

00:14:12,940 --> 00:14:17,230
and the RPC server handles the

00:14:15,010 --> 00:14:19,090
application of the new configuration all

00:14:17,230 --> 00:14:24,640
for me so it takes a new configuration

00:14:19,090 --> 00:14:27,130
and applies it so how do we map yang to

00:14:24,640 --> 00:14:31,870
JSON there's not a cute name like yang

00:14:27,130 --> 00:14:35,650
to Yin but there is an RFC RFC 7950 one

00:14:31,870 --> 00:14:38,200
almost as cute and it tells you exactly

00:14:35,650 --> 00:14:40,750
how we can map yang to JSON and this is

00:14:38,200 --> 00:14:44,590
a completely lossless conversion

00:14:40,750 --> 00:14:45,940
reversible and pretty simple first

00:14:44,590 --> 00:14:48,010
things first is we want to create our

00:14:45,940 --> 00:14:49,840
top-level key that's a unique key

00:14:48,010 --> 00:14:52,120
because it's a combination of the module

00:14:49,840 --> 00:14:53,260
title as well as the first container

00:14:52,120 --> 00:14:55,300
that we're interested in

00:14:53,260 --> 00:14:58,030
so our top-level key becomes open config

00:14:55,300 --> 00:14:59,370
interfaces interfaces now if I didn't

00:14:58,030 --> 00:15:01,840
want to narrow down to a specific

00:14:59,370 --> 00:15:04,480
interface I'm pretty much done here I

00:15:01,840 --> 00:15:07,090
could set the value of this to be a

00:15:04,480 --> 00:15:10,000
bracket null and then I would get all

00:15:07,090 --> 00:15:11,770
interfaces data or technically all data

00:15:10,000 --> 00:15:15,060
that's located in that container

00:15:11,770 --> 00:15:17,950
interfaces but I want to narrow it down

00:15:15,060 --> 00:15:20,230
so I'm going to go into the next key

00:15:17,950 --> 00:15:21,970
which is interface interface you'll see

00:15:20,230 --> 00:15:24,790
is a list so you can see we go from

00:15:21,970 --> 00:15:26,740
brackets we go to bracket brace instead

00:15:24,790 --> 00:15:30,340
of just straight to breeze our lease

00:15:26,740 --> 00:15:32,230
name is name and then we want to fill in

00:15:30,340 --> 00:15:34,690
our data here and that data is the

00:15:32,230 --> 00:15:35,350
Gigabit Ethernet 0 0 0 0 because that's

00:15:34,690 --> 00:15:37,450
the interface

00:15:35,350 --> 00:15:40,600
interested in so this is essentially how

00:15:37,450 --> 00:15:42,820
we map yang to JSON and again that

00:15:40,600 --> 00:15:44,680
pieing tool will do this mapping for you

00:15:42,820 --> 00:15:47,050
although it's a two-step process because

00:15:44,680 --> 00:15:49,890
they make you first convert to XML and

00:15:47,050 --> 00:15:55,000
then you convert to JSON from there

00:15:49,890 --> 00:15:58,090
let's fix our switch back to SSH we've

00:15:55,000 --> 00:16:00,790
determined that our interface is off how

00:15:58,090 --> 00:16:03,130
we fix this is SSH is we check or we

00:16:00,790 --> 00:16:05,110
reconnect to the box we invoke an

00:16:03,130 --> 00:16:07,240
interactive shell because we're going to

00:16:05,110 --> 00:16:10,540
be sending a bunch of commands this time

00:16:07,240 --> 00:16:13,240
not just one command we wait for that

00:16:10,540 --> 00:16:15,280
shell to be ready to receive data we

00:16:13,240 --> 00:16:17,800
send a bunch of hard-coded commands and

00:16:15,280 --> 00:16:19,660
then we sleep to see if they work make

00:16:17,800 --> 00:16:20,950
sure that they all get committed so we

00:16:19,660 --> 00:16:22,600
got to take a little take a little

00:16:20,950 --> 00:16:25,390
breather while that all goes on in the

00:16:22,600 --> 00:16:28,240
background so there's a few problems

00:16:25,390 --> 00:16:29,200
with this you may have picked out one I

00:16:28,240 --> 00:16:31,780
have to reconnect

00:16:29,200 --> 00:16:33,430
I'd already reconnected once but my

00:16:31,780 --> 00:16:36,730
connection was dropped after my command

00:16:33,430 --> 00:16:38,800
finished executing then I have this busy

00:16:36,730 --> 00:16:41,200
while loop that's not doing anything

00:16:38,800 --> 00:16:43,630
it's just waiting for data to be ready

00:16:41,200 --> 00:16:46,390
to be sent into this shell and that

00:16:43,630 --> 00:16:48,610
takes more time that I think you would

00:16:46,390 --> 00:16:50,620
think it might it can take maybe up to a

00:16:48,610 --> 00:16:53,410
second as you'll see in the timing as we

00:16:50,620 --> 00:16:55,930
go through then of course we have these

00:16:53,410 --> 00:16:57,940
hard-coded commands again if I were to

00:16:55,930 --> 00:16:59,770
try to use this on a different box these

00:16:57,940 --> 00:17:02,800
wouldn't work I would have to program

00:16:59,770 --> 00:17:05,260
for a lot of tiny detail changes in

00:17:02,800 --> 00:17:08,440
these commands and then finally the

00:17:05,260 --> 00:17:10,270
sleep the sleep is an indicator of a

00:17:08,440 --> 00:17:13,330
couple of problems you experience with

00:17:10,270 --> 00:17:16,030
SSH there are some operating systems

00:17:13,330 --> 00:17:17,830
some servers that will send back to your

00:17:16,030 --> 00:17:19,510
paramiku script that they have

00:17:17,830 --> 00:17:21,940
successfully executed that they've

00:17:19,510 --> 00:17:24,480
successfully taken all your data this

00:17:21,940 --> 00:17:27,850
operating system does not send that flag

00:17:24,480 --> 00:17:30,130
so this is a problem in a couple ways

00:17:27,850 --> 00:17:31,960
one I didn't know it wasn't going to

00:17:30,130 --> 00:17:33,850
send that flag so originally when I

00:17:31,960 --> 00:17:35,680
wrote the script I just had an infinite

00:17:33,850 --> 00:17:38,530
loop that was waiting forever for a

00:17:35,680 --> 00:17:40,390
signal that never came the only reason I

00:17:38,530 --> 00:17:42,580
found out that that wasn't working is

00:17:40,390 --> 00:17:45,040
because it just ran forever and I had to

00:17:42,580 --> 00:17:46,930
trial and error my way to figuring out

00:17:45,040 --> 00:17:48,360
that this sleep is the only thing that I

00:17:46,930 --> 00:17:51,059
could get to work

00:17:48,360 --> 00:17:53,429
I also had a trial-and-error how long

00:17:51,059 --> 00:17:55,530
does sleep takes this sleep took one

00:17:53,429 --> 00:17:57,690
second but I was doing a relatively

00:17:55,530 --> 00:17:58,950
simple command if I was trying to

00:17:57,690 --> 00:18:01,559
configure something much more

00:17:58,950 --> 00:18:03,720
complicated one second probably isn't

00:18:01,559 --> 00:18:05,760
enough time so there's a lot of

00:18:03,720 --> 00:18:08,490
variability when writing these scripts

00:18:05,760 --> 00:18:10,170
and there's usually not documentation

00:18:08,490 --> 00:18:11,610
out there that's going to say this

00:18:10,170 --> 00:18:14,070
command will take three seconds to

00:18:11,610 --> 00:18:16,290
execute so you kind of have to guess

00:18:14,070 --> 00:18:20,040
which is not my favorite way of

00:18:16,290 --> 00:18:22,890
programming so how do we do this the

00:18:20,040 --> 00:18:24,900
yang way well first you want to

00:18:22,890 --> 00:18:26,700
formulate a get request to our RPC

00:18:24,900 --> 00:18:28,230
server and we've pretty much done all

00:18:26,700 --> 00:18:31,410
the work for that already in our

00:18:28,230 --> 00:18:34,320
conversion from yang to JSON so we have

00:18:31,410 --> 00:18:36,960
this JSON output if we put that into a

00:18:34,320 --> 00:18:40,200
Python variable then I'm going to

00:18:36,960 --> 00:18:42,059
instantiate my G RPC clients this G RPC

00:18:40,200 --> 00:18:44,370
client is an open source client that you

00:18:42,059 --> 00:18:47,820
can find the last slide of my

00:18:44,370 --> 00:18:49,919
presentation has links science fancy MIG

00:18:47,820 --> 00:18:52,110
RPC client and do a simple get config

00:18:49,919 --> 00:18:53,970
and that's going to get me back all the

00:18:52,110 --> 00:18:56,490
data that was located within that

00:18:53,970 --> 00:19:00,960
container specifically for the interface

00:18:56,490 --> 00:19:03,450
name Gigabit Ethernet 0 0 0 we can see

00:19:00,960 --> 00:19:07,080
that when we take that object we loads

00:19:03,450 --> 00:19:08,940
it we get a response object and we dump

00:19:07,080 --> 00:19:11,520
it out and we can see all this data we

00:19:08,940 --> 00:19:13,320
get and I've cut off a ton of it these

00:19:11,520 --> 00:19:15,840
the amount of data you can get back from

00:19:13,320 --> 00:19:17,460
yang oftentimes is even more data than

00:19:15,840 --> 00:19:19,559
what you would see in a show command so

00:19:17,460 --> 00:19:22,230
you can get a lot of information out of

00:19:19,559 --> 00:19:24,330
this one thing really important to

00:19:22,230 --> 00:19:26,429
highlight here though is that we need to

00:19:24,330 --> 00:19:29,640
make sure that our json dictionary stays

00:19:26,429 --> 00:19:32,429
ordered as I said before yang is really

00:19:29,640 --> 00:19:35,640
important with the order hierarchy of

00:19:32,429 --> 00:19:38,250
your data and if I accidentally change

00:19:35,640 --> 00:19:40,169
the order of some of my keys and try to

00:19:38,250 --> 00:19:42,150
reapply it to the box I would get an

00:19:40,169 --> 00:19:44,370
error saying this isn't matching yang

00:19:42,150 --> 00:19:46,320
specifications so you always need to be

00:19:44,370 --> 00:19:49,620
careful when you're using JSON to ensure

00:19:46,320 --> 00:19:52,110
you keep the order now if we squint

00:19:49,620 --> 00:19:53,910
really hard we can see within all this

00:19:52,110 --> 00:19:56,520
data that we got we can find a

00:19:53,910 --> 00:19:59,400
configuration container that has an

00:19:56,520 --> 00:20:01,620
enabled false set and so this is telling

00:19:59,400 --> 00:20:03,390
us that our box has turned

00:20:01,620 --> 00:20:05,640
off that interface it's the same as an

00:20:03,390 --> 00:20:07,410
OSHA as a shutdown so if we can change

00:20:05,640 --> 00:20:11,100
that to true we're going to turn the

00:20:07,410 --> 00:20:12,900
interface back on manipulating the data

00:20:11,100 --> 00:20:15,120
is pretty simple if you've ever

00:20:12,900 --> 00:20:17,490
manipulated a dictionary in Python you

00:20:15,120 --> 00:20:20,730
already know how to do this so we take

00:20:17,490 --> 00:20:22,770
our response object drill down through

00:20:20,730 --> 00:20:24,870
the first couple of keys open config

00:20:22,770 --> 00:20:28,230
interfaces interfaces and then interface

00:20:24,870 --> 00:20:30,150
we know interface gives us a list but in

00:20:28,230 --> 00:20:31,620
our scenario we only requested one

00:20:30,150 --> 00:20:33,900
interface so there's only going to be

00:20:31,620 --> 00:20:35,910
one item in the list we can safely grab

00:20:33,900 --> 00:20:38,460
just the first and only index that's

00:20:35,910 --> 00:20:41,040
available this gets us a little bit

00:20:38,460 --> 00:20:43,110
closer to config enabled false now all

00:20:41,040 --> 00:20:45,540
we need to do is get from config to

00:20:43,110 --> 00:20:49,290
enabled and set it to true which we can

00:20:45,540 --> 00:20:51,900
do really simply if we do a dumps we can

00:20:49,290 --> 00:20:54,030
see on our response object the response

00:20:51,900 --> 00:20:56,520
object has been updated to enabled true

00:20:54,030 --> 00:20:58,410
the only thing left to do is send this

00:20:56,520 --> 00:21:02,010
back to the RPC client and have it

00:20:58,410 --> 00:21:04,800
merged that configuration for us this

00:21:02,010 --> 00:21:07,440
again is a simple process we dump the

00:21:04,800 --> 00:21:09,480
object to update it config and then do

00:21:07,440 --> 00:21:12,330
call our merge config function and this

00:21:09,480 --> 00:21:14,130
is going to handle any messiness on the

00:21:12,330 --> 00:21:16,830
back end all for us this is all we need

00:21:14,130 --> 00:21:18,150
to do we can get back an error so if

00:21:16,830 --> 00:21:20,340
something has gone wrong if you

00:21:18,150 --> 00:21:22,320
unordered your dictionary then you would

00:21:20,340 --> 00:21:24,630
get an error quest back all the error

00:21:22,320 --> 00:21:26,700
messages are defined in the yank RFC so

00:21:24,630 --> 00:21:28,679
you can go look them up if you want you

00:21:26,700 --> 00:21:30,360
would also have gotten an error back if

00:21:28,679 --> 00:21:32,880
you try to request an interface it

00:21:30,360 --> 00:21:36,570
doesn't exist so definitely look into

00:21:32,880 --> 00:21:38,610
the errors if you ever get confused just

00:21:36,570 --> 00:21:40,710
a quick check we can do another get

00:21:38,610 --> 00:21:42,960
request on our box to see if this

00:21:40,710 --> 00:21:46,290
applied and we can see that enabled is

00:21:42,960 --> 00:21:49,200
indeed set to true so this fix is our

00:21:46,290 --> 00:21:51,030
switch in fact both ways fix our switch

00:21:49,200 --> 00:21:54,809
but there were some issues that we saw

00:21:51,030 --> 00:21:56,460
with SSH we saw that SSH is challenging

00:21:54,809 --> 00:21:59,220
to work with because it's difficult to

00:21:56,460 --> 00:22:01,950
write repeatable code it requires a lot

00:21:59,220 --> 00:22:03,690
of complexity to be able to write SSH

00:22:01,950 --> 00:22:06,480
scripts that will run on even two

00:22:03,690 --> 00:22:08,850
different OSS the second thing of course

00:22:06,480 --> 00:22:10,590
is it's slow we have we had a lot of

00:22:08,850 --> 00:22:12,450
timing issues which I'll show you in the

00:22:10,590 --> 00:22:14,279
next time in extra the next slide and

00:22:12,450 --> 00:22:15,539
actual timing breakdown

00:22:14,279 --> 00:22:17,849
and then the third thing was it was

00:22:15,539 --> 00:22:19,440
unpredictable I wasn't sure that I had

00:22:17,849 --> 00:22:21,840
to put a sleep there I wasn't sure how

00:22:19,440 --> 00:22:23,700
long the sleep had to be some operating

00:22:21,840 --> 00:22:25,649
systems it wouldn't be a sleep it may be

00:22:23,700 --> 00:22:27,629
something different so it's kind of hard

00:22:25,649 --> 00:22:29,219
to predict and if anybody's worked with

00:22:27,629 --> 00:22:33,149
SSH I'm sure you've had these

00:22:29,219 --> 00:22:34,859
frustrations before so just a quick look

00:22:33,149 --> 00:22:36,840
at the timings I think it's kind of fun

00:22:34,859 --> 00:22:39,509
to see how drastic did this the

00:22:36,840 --> 00:22:42,719
difference actually is that SSA screen

00:22:39,509 --> 00:22:46,200
scrape script took 2.8 real seconds to

00:22:42,719 --> 00:22:48,179
run or the difference of almost 2.3

00:22:46,200 --> 00:22:50,639
seconds between using and gangue model

00:22:48,179 --> 00:22:53,639
which only took half a second two

00:22:50,639 --> 00:22:55,889
seconds is pretty long for most small

00:22:53,639 --> 00:22:58,229
scripts of this size but it's really

00:22:55,889 --> 00:23:00,450
long if we start scaling out to a

00:22:58,229 --> 00:23:03,479
thousand devices or more than a thousand

00:23:00,450 --> 00:23:07,799
devices this adds up really quickly so

00:23:03,479 --> 00:23:10,710
the speed of yang is a huge benefit but

00:23:07,799 --> 00:23:11,999
there are drawbacks so what are the

00:23:10,710 --> 00:23:15,029
drawbacks is it's not a hundred percent

00:23:11,999 --> 00:23:17,249
stable it's still kind of newish in the

00:23:15,029 --> 00:23:19,619
industry people are still getting their

00:23:17,249 --> 00:23:21,059
feet wet I looked up the open config

00:23:19,619 --> 00:23:23,909
models and they seemed to change about

00:23:21,059 --> 00:23:27,509
once a month not significant changes but

00:23:23,909 --> 00:23:29,789
sometimes significant so all yang models

00:23:27,509 --> 00:23:31,950
can be found on github what I would

00:23:29,789 --> 00:23:33,479
recommend you do is just subscribe to

00:23:31,950 --> 00:23:35,429
the yang models that you're working with

00:23:33,479 --> 00:23:37,619
and then if it change occurs you'll be

00:23:35,429 --> 00:23:39,210
aware that a change has happened so just

00:23:37,619 --> 00:23:40,830
something to keep an eye out for if your

00:23:39,210 --> 00:23:42,749
scripts suddenly start breaking you

00:23:40,830 --> 00:23:46,019
probably updated your operating system

00:23:42,749 --> 00:23:48,690
and the yang models were changed it's

00:23:46,019 --> 00:23:50,940
not largely available yet so it's coming

00:23:48,690 --> 00:23:52,889
out on a number of vendor devices and

00:23:50,940 --> 00:23:55,320
when you go on the github page for yang

00:23:52,889 --> 00:23:57,149
you'll see a bunch of different vendors

00:23:55,320 --> 00:24:00,450
are listed there with their particular

00:23:57,149 --> 00:24:03,239
models many major vendors have it like

00:24:00,450 --> 00:24:06,479
Cisco Arista juniper are all starting to

00:24:03,239 --> 00:24:08,059
support this but it's not on all their

00:24:06,479 --> 00:24:12,499
boxes it's I don't think it's on

00:24:08,059 --> 00:24:15,629
anyone's entire suite of boxes and it's

00:24:12,499 --> 00:24:17,369
maybe not guaranteed to ever be on every

00:24:15,629 --> 00:24:19,229
device this is still something that's

00:24:17,369 --> 00:24:21,059
new still something that the industry is

00:24:19,229 --> 00:24:23,129
trying to figure out if they want to

00:24:21,059 --> 00:24:25,109
adopt so right now you really have to

00:24:23,129 --> 00:24:27,889
check to see if your operating system

00:24:25,109 --> 00:24:27,889
supports yang

00:24:27,900 --> 00:24:33,630
the third one's a big one devices are

00:24:30,270 --> 00:24:35,159
blocking yang itself and RPC calls don't

00:24:33,630 --> 00:24:37,820
have anything that would make them

00:24:35,159 --> 00:24:40,230
blocking but network network devices

00:24:37,820 --> 00:24:42,059
usually do not allow more than one

00:24:40,230 --> 00:24:44,760
configuration change to be happening at

00:24:42,059 --> 00:24:46,890
the same time so if I were to write a

00:24:44,760 --> 00:24:48,870
script that was automating my device and

00:24:46,890 --> 00:24:51,210
it was making a lot of changes on the

00:24:48,870 --> 00:24:53,250
back end and I was an IT worker or a

00:24:51,210 --> 00:24:56,010
network operator trying to make a change

00:24:53,250 --> 00:24:57,929
on my box I would never be able to the

00:24:56,010 --> 00:24:59,970
script is going to be running so fast

00:24:57,929 --> 00:25:01,649
that I keep getting locked out of it

00:24:59,970 --> 00:25:04,169
because I just can't be faster than a

00:25:01,649 --> 00:25:06,330
computer so if you're going to fully

00:25:04,169 --> 00:25:08,669
commit to automating your network you

00:25:06,330 --> 00:25:10,500
really need to fully commit you need to

00:25:08,669 --> 00:25:12,630
have a queuing system enabled so that

00:25:10,500 --> 00:25:15,149
way you can ensure that your scripts are

00:25:12,630 --> 00:25:17,190
always running one at a time not

00:25:15,149 --> 00:25:19,710
overwriting each other and not trying to

00:25:17,190 --> 00:25:24,419
run at the same time so just something

00:25:19,710 --> 00:25:26,580
to be aware of last thing the tooling

00:25:24,419 --> 00:25:29,370
and the documentation it's still not

00:25:26,580 --> 00:25:31,980
fully there pieing is a great option to

00:25:29,370 --> 00:25:35,549
look at I just saw today that pying has

00:25:31,980 --> 00:25:37,590
added support for Haiyang bind which

00:25:35,549 --> 00:25:40,230
will actually convert yang models to

00:25:37,590 --> 00:25:42,539
Python classes so like there's cool

00:25:40,230 --> 00:25:44,520
stuff coming out but it's all just

00:25:42,539 --> 00:25:47,039
coming out it's all still pretty new

00:25:44,520 --> 00:25:49,020
it's not fully fleshed out so definitely

00:25:47,039 --> 00:25:50,730
something that hopefully in the next few

00:25:49,020 --> 00:25:52,289
years will be there it'll be easier to

00:25:50,730 --> 00:25:55,860
get started on right now it's a little

00:25:52,289 --> 00:25:57,600
challenging that's it at the end of my

00:25:55,860 --> 00:26:01,020
presentation that these slides will be

00:25:57,600 --> 00:26:04,710
uploaded I have examples and links the

00:26:01,020 --> 00:26:06,570
RFC is on there the yang page on github

00:26:04,710 --> 00:26:08,159
that you want to go and check that your

00:26:06,570 --> 00:26:10,320
operating system supports this yang

00:26:08,159 --> 00:26:12,450
model is on there I've included a couple

00:26:10,320 --> 00:26:14,610
projects I worked on that are like proof

00:26:12,450 --> 00:26:18,299
of concept applications that could show

00:26:14,610 --> 00:26:20,340
a little bit more exciting examples the

00:26:18,299 --> 00:26:22,350
G RPC client I talked about is on there

00:26:20,340 --> 00:26:26,039
and then finally napalm is on there

00:26:22,350 --> 00:26:29,279
napalm is a library that supports SSH as

00:26:26,039 --> 00:26:31,380
well as yang so if you're in a typical

00:26:29,279 --> 00:26:34,110
environment that has mixed support for

00:26:31,380 --> 00:26:36,899
yang I definitely encourage looking into

00:26:34,110 --> 00:26:39,149
napalm where you can use SSH as well as

00:26:36,899 --> 00:26:40,419
yang to write one script that will

00:26:39,149 --> 00:26:43,379
monitor your entire network

00:26:40,419 --> 00:26:43,379
automate your entire network

00:26:44,500 --> 00:26:54,139
[Applause]

00:26:52,460 --> 00:27:02,360
I'll be taking questions if anybody has

00:26:54,139 --> 00:27:04,840
any hi hi this is an awesome talk thank

00:27:02,360 --> 00:27:08,360
you um explained everything really well

00:27:04,840 --> 00:27:09,889
I was just wondering and so this looks

00:27:08,360 --> 00:27:11,299
like it works really well for like

00:27:09,889 --> 00:27:13,909
routers and network devices like that

00:27:11,299 --> 00:27:16,190
and I'm wondering if there are

00:27:13,909 --> 00:27:17,720
applications to use it for devices that

00:27:16,190 --> 00:27:19,759
are on a network so if you wanted to

00:27:17,720 --> 00:27:22,970
monitor like phones or printers things

00:27:19,759 --> 00:27:24,080
like that right now there's no support

00:27:22,970 --> 00:27:26,179
for something like that

00:27:24,080 --> 00:27:28,999
yang is currently really only mapped to

00:27:26,179 --> 00:27:30,860
switches and routers it there's no

00:27:28,999 --> 00:27:32,149
reason it couldn't be in the future but

00:27:30,860 --> 00:27:34,730
right now it's only working on

00:27:32,149 --> 00:27:36,169
networking devices well do you know of

00:27:34,730 --> 00:27:38,210
anything that does work for that sort of

00:27:36,169 --> 00:27:41,629
thing for monitoring like songs and

00:27:38,210 --> 00:27:43,580
printers and stuff yeah ah not off the

00:27:41,629 --> 00:27:48,559
top of my head unfortunately sorry

00:27:43,580 --> 00:27:51,049
no no that's awesome thanks thanks hey

00:27:48,559 --> 00:27:52,909
I've got a quick question about the yang

00:27:51,049 --> 00:27:54,980
models is there been any work done to

00:27:52,909 --> 00:27:56,990
create those models based on log files

00:27:54,980 --> 00:27:59,749
from devices if the log files themselves

00:27:56,990 --> 00:28:02,690
are representative of a connection to

00:27:59,749 --> 00:28:06,499
the like this config to your shows show

00:28:02,690 --> 00:28:07,369
configuration um I don't I'm not a

00:28:06,499 --> 00:28:09,440
hundred percent sure if I'm

00:28:07,369 --> 00:28:11,659
understanding your question entirely but

00:28:09,440 --> 00:28:14,179
if we're using yang you could

00:28:11,659 --> 00:28:16,309
potentially not need log files because

00:28:14,179 --> 00:28:18,889
if we're constantly pulling operational

00:28:16,309 --> 00:28:19,940
state data that's kind of like the same

00:28:18,889 --> 00:28:23,029
as a log file

00:28:19,940 --> 00:28:24,769
at least that's but forget it I see what

00:28:23,029 --> 00:28:26,360
you're saying but in a situation where I

00:28:24,769 --> 00:28:27,740
don't have access to devices but I want

00:28:26,360 --> 00:28:31,129
to work with object models from the

00:28:27,740 --> 00:28:33,110
devices where I have their files yang

00:28:31,129 --> 00:28:35,210
make it compulsory to connect to a

00:28:33,110 --> 00:28:37,639
device or would I be able to drive that

00:28:35,210 --> 00:28:40,159
object model from a flat file you know I

00:28:37,639 --> 00:28:42,769
don't think it's I've never seen a case

00:28:40,159 --> 00:28:45,769
where they're actually storing yang like

00:28:42,769 --> 00:28:48,350
data like as a log on the device so I

00:28:45,769 --> 00:28:50,749
don't think that they and not that I

00:28:48,350 --> 00:28:52,460
have seen I haven't it may will be

00:28:50,749 --> 00:28:54,379
somewhere but as of right now I only

00:28:52,460 --> 00:28:56,690
know that it's more of a pull model like

00:28:54,379 --> 00:28:59,059
I have to say retrieve this data right

00:28:56,690 --> 00:29:01,629
now I don't think it's saving it's the

00:28:59,059 --> 00:29:01,629
state anywhere

00:29:04,560 --> 00:29:10,690
Hey so that's never quick questions so

00:29:07,090 --> 00:29:12,760
in the aspects of we're natively we're

00:29:10,690 --> 00:29:15,610
four we for example like Cisco has

00:29:12,760 --> 00:29:18,550
native SDKs for UCS or whatever and

00:29:15,610 --> 00:29:19,900
using that with building custom and

00:29:18,550 --> 00:29:21,870
simple modules are just natively using

00:29:19,900 --> 00:29:24,160
Python is there benefits to using

00:29:21,870 --> 00:29:25,900
something like this versus that as far

00:29:24,160 --> 00:29:27,910
as the speed thing or is it going to be

00:29:25,900 --> 00:29:29,860
a difference in that I mean obviously I

00:29:27,910 --> 00:29:31,510
know not every company is making SDKs

00:29:29,860 --> 00:29:33,910
but what's the benefit of them building

00:29:31,510 --> 00:29:35,200
this versus just natively making an SDK

00:29:33,910 --> 00:29:37,960
for their product I guess my question

00:29:35,200 --> 00:29:41,170
well I guess maybe it's the matter of

00:29:37,960 --> 00:29:45,400
opinion but if I were using an SDK that

00:29:41,170 --> 00:29:47,260
is Cisco specific and I only have Cisco

00:29:45,400 --> 00:29:49,420
devices I think I would probably just

00:29:47,260 --> 00:29:51,280
use that SDK because hopefully it's

00:29:49,420 --> 00:29:53,320
better or hopefully it's well documented

00:29:51,280 --> 00:29:56,170
and I can call tack or whatever if

00:29:53,320 --> 00:29:58,240
something breaks but since most networks

00:29:56,170 --> 00:30:00,310
would have a multitude of different

00:29:58,240 --> 00:30:02,200
vendors and different operating systems

00:30:00,310 --> 00:30:05,650
that's where something like this becomes

00:30:02,200 --> 00:30:08,110
more powerful because if I had just two

00:30:05,650 --> 00:30:10,600
vendors with two individual SDKs I would

00:30:08,110 --> 00:30:12,280
still have to write two separate but not

00:30:10,600 --> 00:30:13,930
in the ansible module I guess that's my

00:30:12,280 --> 00:30:16,510
question if you already have that and

00:30:13,930 --> 00:30:18,130
you already either have ansible modules

00:30:16,510 --> 00:30:20,170
or you're you know familiar enough to

00:30:18,130 --> 00:30:22,060
build the ansible libraries yourself if

00:30:20,170 --> 00:30:24,370
you already have the SSA hey I guess

00:30:22,060 --> 00:30:26,050
what's the benefit to something like

00:30:24,370 --> 00:30:27,310
this versus that I guess because I think

00:30:26,050 --> 00:30:29,020
that's a question I'm just curious like

00:30:27,310 --> 00:30:30,880
from a speed perspective you know how

00:30:29,020 --> 00:30:33,100
that would work I guess yeah I guess I

00:30:30,880 --> 00:30:35,230
can't speak to exactly speed differences

00:30:33,100 --> 00:30:37,810
between ansible and between using our

00:30:35,230 --> 00:30:39,610
pcs plus it would depend on what RPC you

00:30:37,810 --> 00:30:42,250
implement some our pcs are faster than

00:30:39,610 --> 00:30:44,260
others but I can't say using ansible for

00:30:42,250 --> 00:30:46,210
configuration would work but ansible

00:30:44,260 --> 00:30:49,150
isn't typically used for any monitoring

00:30:46,210 --> 00:30:51,760
so if I were to pick out a benefit yang

00:30:49,150 --> 00:30:53,680
has the whole operational state data and

00:30:51,760 --> 00:30:55,870
that's kind of one of the positives that

00:30:53,680 --> 00:30:58,090
it has that Ansel doesn't have in terms

00:30:55,870 --> 00:31:00,130
of applying a configuration both would

00:30:58,090 --> 00:31:02,320
work and I don't know in enough

00:31:00,130 --> 00:31:03,730
granularity about speed differences to

00:31:02,320 --> 00:31:06,940
say one is better than the other

00:31:03,730 --> 00:31:09,420
was this true sticky all right I think

00:31:06,940 --> 00:31:16,729
that's it for time thank you everybody

00:31:09,420 --> 00:31:16,729

YouTube URL: https://www.youtube.com/watch?v=hKxbO4rRlpg


