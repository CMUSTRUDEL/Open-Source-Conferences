Title: Brandon Rhodes   The Dictionary Even Mightier   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Brandon Rhodes

Since my “Mighty Dictionary” talk at PyCon 2010, the Python dictionary has evolved dramatically. Come learn about all of the the improvements, up to and including the re-architecture that has just landed with Python 3.6! The talk will discuss iterable views, the dictionary’s dedicated comprehension syntax, random key ordering, the special key-sharing dictionary designed to underlie object collections, and, most famously of all, the new “compact dictionary” that cuts dictionary storage substantially — and carries a fascinating side-effect.

Each new feature that the talk discusses will be motivated by considering the trade-offs inherent in hash table data structure design, and followed up with hints about how you can now use the dictionary even more effectively in your own code!


Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:57,430 --> 00:01:03,140
ladies and gentlemen as we know

00:01:01,280 --> 00:01:06,080
dictionary is very powerful and useful

00:01:03,140 --> 00:01:09,470
tools in Python and in Python point 3.6

00:01:06,080 --> 00:01:11,690
a lot of new features I added and it is

00:01:09,470 --> 00:01:12,230
very mighty and put even mightier than

00:01:11,690 --> 00:01:14,480
you thought

00:01:12,230 --> 00:01:24,230
let's welcome Brandon wrote to give his

00:01:14,480 --> 00:01:26,510
talk the dictionary even might hear well

00:01:24,230 --> 00:01:31,190
thank you everyone this as many of you

00:01:26,510 --> 00:01:36,080
will have guessed is a follow-up to my

00:01:31,190 --> 00:01:38,510
2010 several years ago PyCon talk

00:01:36,080 --> 00:01:41,119
the mighty dictionary in which I try to

00:01:38,510 --> 00:01:44,840
explain the operation benefits but

00:01:41,119 --> 00:01:48,340
dangers of a hash table to a PyCon

00:01:44,840 --> 00:01:50,869
audience a lot has happened since then

00:01:48,340 --> 00:01:55,759
none of which tempted me to do a

00:01:50,869 --> 00:01:57,650
follow-up talk until Python 3.6 which

00:01:55,759 --> 00:02:00,140
Rayment Ettinger is famously said is the

00:01:57,650 --> 00:02:03,740
first version he specifically said 361

00:02:00,140 --> 00:02:05,869
that's a better language in 2.7 so it's

00:02:03,740 --> 00:02:07,910
clearly time that we talk about where

00:02:05,869 --> 00:02:10,970
the dictionary has gone in the last

00:02:07,910 --> 00:02:12,590
several years I chose it turns out in

00:02:10,970 --> 00:02:14,210
retrospect an interesting moment to do

00:02:12,590 --> 00:02:16,850
the original mighty dictionary talk

00:02:14,210 --> 00:02:21,860
February of right at the beginning of

00:02:16,850 --> 00:02:24,350
2010 right before months before 2.7 went

00:02:21,860 --> 00:02:26,270
final and came out that means that my

00:02:24,350 --> 00:02:27,860
original talk purely looked at the

00:02:26,270 --> 00:02:30,620
dynamics of the hash table didn't talk

00:02:27,860 --> 00:02:34,430
at all about the improvements that were

00:02:30,620 --> 00:02:38,390
just about to arrive as Python 2.7 the

00:02:34,430 --> 00:02:41,690
last Harrah the two series shove quickly

00:02:38,390 --> 00:02:44,240
pulled in several innovations from the

00:02:41,690 --> 00:02:47,150
Python 3 series to make them at the last

00:02:44,240 --> 00:02:50,450
minute available in the last version of

00:02:47,150 --> 00:02:52,510
2 so none of those were covered in my

00:02:50,450 --> 00:02:54,920
original talk and will be covered now

00:02:52,510 --> 00:02:57,350
we'll be covering several things that

00:02:54,920 --> 00:02:59,030
we're back ported to to 7 then we'll

00:02:57,350 --> 00:03:01,640
move ahead and look at things that you

00:02:59,030 --> 00:03:03,020
cannot take advantage of into seven and

00:03:01,640 --> 00:03:07,700
that you have to have a modern version

00:03:03,020 --> 00:03:09,140
of Python to take advantage of all right

00:03:07,700 --> 00:03:10,510
many of you will already have seen I

00:03:09,140 --> 00:03:13,480
believe they were already being talked

00:03:10,510 --> 00:03:15,879
about at the conference dictionary

00:03:13,480 --> 00:03:18,209
comprehensions change that are into

00:03:15,879 --> 00:03:21,879
peppermints baited in men was was a

00:03:18,209 --> 00:03:24,879
resolved the list comprehension had been

00:03:21,879 --> 00:03:27,340
around since Python - it was an

00:03:24,879 --> 00:03:30,129
innovation when python went from one six

00:03:27,340 --> 00:03:31,659
I think was the last one to 2.0 and it

00:03:30,129 --> 00:03:34,480
was a big deal you'd always had to make

00:03:31,659 --> 00:03:38,049
an empty list append append append to it

00:03:34,480 --> 00:03:39,730
before finally producing a a completed

00:03:38,049 --> 00:03:42,159
list with the list comprehension

00:03:39,730 --> 00:03:46,000
borrowed from several other languages

00:03:42,159 --> 00:03:47,859
you could instead put the for logic the

00:03:46,000 --> 00:03:49,599
looping logic inside of those square

00:03:47,859 --> 00:03:54,819
brackets and had the list created for

00:03:49,599 --> 00:03:56,560
you that was great for lists it gave us

00:03:54,819 --> 00:03:58,930
a way to build dictionaries but the way

00:03:56,560 --> 00:04:02,349
was slightly roundabout you had to build

00:03:58,930 --> 00:04:04,030
tuples key and value and it didn't look

00:04:02,349 --> 00:04:05,319
very much like a dictionary and of

00:04:04,030 --> 00:04:07,420
course it was slower because you had to

00:04:05,319 --> 00:04:09,340
make a tuple per item that was then

00:04:07,420 --> 00:04:12,250
thrown away once they were inserted into

00:04:09,340 --> 00:04:14,409
the dictionary generators came along and

00:04:12,250 --> 00:04:16,269
Python 2.4 at least you could take the

00:04:14,409 --> 00:04:18,459
angle brackets off but you were treating

00:04:16,269 --> 00:04:20,109
one inefficiency for another the

00:04:18,459 --> 00:04:22,360
generator you're not having to create an

00:04:20,109 --> 00:04:23,860
intermediate data structure a list but

00:04:22,360 --> 00:04:26,530
you're constantly having to thrash

00:04:23,860 --> 00:04:29,229
between running another bit of bytecode

00:04:26,530 --> 00:04:30,789
or C code in the generator and then

00:04:29,229 --> 00:04:35,169
running it another little bit of the

00:04:30,789 --> 00:04:37,150
dictionaries in it logic to absorb item

00:04:35,169 --> 00:04:39,250
by item the tuples that were being

00:04:37,150 --> 00:04:41,169
generated you're still creating and

00:04:39,250 --> 00:04:43,150
freeing tuples and you have the

00:04:41,169 --> 00:04:47,560
disadvantage of swapping between two

00:04:43,150 --> 00:04:49,389
different call stacks so often wound up

00:04:47,560 --> 00:04:51,340
not really being any faster though it

00:04:49,389 --> 00:04:56,199
was more conceptually convenient and

00:04:51,340 --> 00:04:57,789
saved a pair of angle brackets you don't

00:04:56,199 --> 00:04:59,440
have either of those problems of course

00:04:57,789 --> 00:05:02,500
once you introduce the dictionary

00:04:59,440 --> 00:05:04,419
comprehension it looks like a dictionary

00:05:02,500 --> 00:05:05,919
it has a colon as one would expect it

00:05:04,419 --> 00:05:07,960
doesn't create needless intermediate

00:05:05,919 --> 00:05:11,070
data structures lists or tunable it's

00:05:07,960 --> 00:05:13,330
readable it's smaller it's faster and

00:05:11,070 --> 00:05:17,260
what I think is its greatest feature it

00:05:13,330 --> 00:05:20,139
rarely gets mentioned it has it brings

00:05:17,260 --> 00:05:23,740
to Python a great symmetry if you ever

00:05:20,139 --> 00:05:28,990
talk Python 2.6 and for awhile I taught

00:05:23,740 --> 00:05:31,319
Python professionally when students

00:05:28,990 --> 00:05:34,419
learn the list comprehension

00:05:31,319 --> 00:05:39,370
some of them some students have

00:05:34,419 --> 00:05:43,060
imagination and will suddenly think wait

00:05:39,370 --> 00:05:46,389
a minute if you can put the four inside

00:05:43,060 --> 00:05:49,539
of the square brackets can you put it

00:05:46,389 --> 00:05:51,880
inside of the angle brackets and Python

00:05:49,539 --> 00:05:54,759
2.6 would pop them on the heads and say

00:05:51,880 --> 00:05:56,380
no lists are special and as you know

00:05:54,759 --> 00:05:58,060
everything in a language that's special

00:05:56,380 --> 00:06:02,500
and different is an obstacle to the

00:05:58,060 --> 00:06:07,500
learner this means the old 2.6 syntax it

00:06:02,500 --> 00:06:10,120
didn't allow this it meant that Python

00:06:07,500 --> 00:06:13,990
wasn't a language at least in this area

00:06:10,120 --> 00:06:15,340
where you could learn by extrapolating I

00:06:13,990 --> 00:06:17,889
did this the other day

00:06:15,340 --> 00:06:20,169
so it's proud of myself I deduced the

00:06:17,889 --> 00:06:21,690
existence of an object that I had never

00:06:20,169 --> 00:06:24,690
thought of or seen before

00:06:21,690 --> 00:06:29,979
springtime hedges are starting to grow

00:06:24,690 --> 00:06:32,320
also I'm facing and dig the big reel of

00:06:29,979 --> 00:06:34,449
power cord out of the garage get it

00:06:32,320 --> 00:06:37,509
plugged in and then like loop it around

00:06:34,449 --> 00:06:39,310
myself in such a way that I can trim the

00:06:37,509 --> 00:06:43,659
hedges without cutting the cord into or

00:06:39,310 --> 00:06:49,810
electrocuting myself and suddenly I knew

00:06:43,659 --> 00:06:53,819
I owned a cordless drill I owned a

00:06:49,810 --> 00:06:56,229
corded hedge trimmer and I was suddenly

00:06:53,819 --> 00:07:00,130
absolutely certain that the universe I

00:06:56,229 --> 00:07:02,090
lived in included cordless hedge

00:07:00,130 --> 00:07:05,870
trimmers

00:07:02,090 --> 00:07:08,810
and you understand I was absolutely

00:07:05,870 --> 00:07:10,639
certain that they existed the moment

00:07:08,810 --> 00:07:12,950
that you know this is one of those

00:07:10,639 --> 00:07:16,570
moments were like I have introspected

00:07:12,950 --> 00:07:21,470
the universe and deduced a fact about it

00:07:16,570 --> 00:07:23,210
through the power of my mind and it was

00:07:21,470 --> 00:07:27,050
like this great moment it was just the

00:07:23,210 --> 00:07:29,810
QED to do the Amazon search and start

00:07:27,050 --> 00:07:32,660
reading reviews of the indeed existent

00:07:29,810 --> 00:07:35,330
concept of a battery-operated hedge

00:07:32,660 --> 00:07:37,940
trimmer it's wonderful when languages

00:07:35,330 --> 00:07:40,550
when systems when api's are set up where

00:07:37,940 --> 00:07:42,650
you can guess some behaviors from others

00:07:40,550 --> 00:07:44,540
where you learn the square brackets let

00:07:42,650 --> 00:07:46,340
you get it items in a list the same

00:07:44,540 --> 00:07:48,800
square brackets let you get to the items

00:07:46,340 --> 00:07:50,870
in a dictionary and what I love most

00:07:48,800 --> 00:07:54,410
about dictionary comprehensions is they

00:07:50,870 --> 00:07:56,270
allow our learners to extrapolate a

00:07:54,410 --> 00:07:58,750
corner of a language that they might

00:07:56,270 --> 00:08:02,150
suddenly guess in there indeed after

00:07:58,750 --> 00:08:03,889
Python taboo argued against it for

00:08:02,150 --> 00:08:07,039
several years was finally added to the

00:08:03,889 --> 00:08:11,270
language added in three dot o backported

00:08:07,039 --> 00:08:13,340
22.7 really beautiful construct and then

00:08:11,270 --> 00:08:15,020
as sort of the last thing right as

00:08:13,340 --> 00:08:17,990
Python three was being invented was

00:08:15,020 --> 00:08:19,640
dictionary views this was again came

00:08:17,990 --> 00:08:23,000
right out of the gate in Python 3 Oh

00:08:19,640 --> 00:08:24,680
added 2 to 7 previously originally we'd

00:08:23,000 --> 00:08:27,020
had keys values and items that built

00:08:24,680 --> 00:08:29,570
ancillary data structures lists eater

00:08:27,020 --> 00:08:31,280
keys inner values inner items were added

00:08:29,570 --> 00:08:34,460
to the language when iterators were and

00:08:31,280 --> 00:08:36,440
they don't spin up a separate list but

00:08:34,460 --> 00:08:39,550
let you get to all the keys or all of

00:08:36,440 --> 00:08:42,710
the values and in the dictionaries order

00:08:39,550 --> 00:08:45,680
without having them copied in there into

00:08:42,710 --> 00:08:47,030
an intermediate structure and I honestly

00:08:45,680 --> 00:08:48,980
I kind of wasn't paying a lot of

00:08:47,030 --> 00:08:50,420
attention to the Python 3 transition

00:08:48,980 --> 00:08:56,890
since I still don't get to use it at

00:08:50,420 --> 00:08:56,890
work and the method who does

00:08:56,910 --> 00:09:04,570
the I kind of had thought when I saw

00:09:01,440 --> 00:09:04,990
weekís isn't a list anymore values isn't

00:09:04,570 --> 00:09:06,640
a list

00:09:04,990 --> 00:09:09,760
I thought they had just changed the

00:09:06,640 --> 00:09:13,060
itter versions and renamed them two keys

00:09:09,760 --> 00:09:15,610
values and items and then if I wanted if

00:09:13,060 --> 00:09:17,380
we want a list in Python 3 you asked for

00:09:15,610 --> 00:09:20,160
a list very pythonic because you're

00:09:17,380 --> 00:09:23,670
being explicit asking for what you want

00:09:20,160 --> 00:09:26,260
it turns out that's not what they did

00:09:23,670 --> 00:09:29,410
they asked an interesting question what

00:09:26,260 --> 00:09:31,149
if you just want to ask if something is

00:09:29,410 --> 00:09:33,310
present in the keys or present in the

00:09:31,149 --> 00:09:36,220
values the dictionary could answer is

00:09:33,310 --> 00:09:38,649
this value in the values with a quick

00:09:36,220 --> 00:09:40,480
loop over the values but there was no

00:09:38,649 --> 00:09:42,820
way to get to that information without

00:09:40,480 --> 00:09:45,160
creating a list of the values and

00:09:42,820 --> 00:09:49,350
looking through that or a setters as

00:09:45,160 --> 00:09:51,459
appropriate and so they thought

00:09:49,350 --> 00:09:54,279
shouldn't there be an object that

00:09:51,459 --> 00:09:57,070
implements contains four keys values and

00:09:54,279 --> 00:09:59,589
items that just can answer that question

00:09:57,070 --> 00:10:01,510
is X in Y by just looking directly at

00:09:59,589 --> 00:10:04,990
the interior structure of the dictionary

00:10:01,510 --> 00:10:07,779
in fact if we had such an object Y

00:10:04,990 --> 00:10:10,959
stopped it contains we could have it do

00:10:07,779 --> 00:10:13,959
all of the basic set operations for the

00:10:10,959 --> 00:10:16,510
keys you could ask questions like does

00:10:13,959 --> 00:10:18,850
this dictionary and this dictionary have

00:10:16,510 --> 00:10:21,209
any keys in common do they have any keys

00:10:18,850 --> 00:10:23,020
in the disjoint set between them and

00:10:21,209 --> 00:10:26,770
while you're at it you could of course

00:10:23,020 --> 00:10:29,260
add the ability to call thunder it her

00:10:26,770 --> 00:10:30,880
and also throw in the ability to loop

00:10:29,260 --> 00:10:33,579
over dictionaries which is all we really

00:10:30,880 --> 00:10:35,589
do anyway this was inspired by the Java

00:10:33,579 --> 00:10:38,800
collections framework these are called

00:10:35,589 --> 00:10:43,510
views as Y used v is the place holder

00:10:38,800 --> 00:10:46,660
there when you call keys values items

00:10:43,510 --> 00:10:49,270
these days you get a tiny little object

00:10:46,660 --> 00:10:51,040
with no storage of its own all it has is

00:10:49,270 --> 00:10:53,320
the address of its type in the address

00:10:51,040 --> 00:10:55,899
of the dictionary that it will use to go

00:10:53,320 --> 00:10:58,000
answer questions for you when you do set

00:10:55,899 --> 00:11:04,449
like operations or membership like

00:10:58,000 --> 00:11:08,430
operations on the view so keys values

00:11:04,449 --> 00:11:12,000
and items in Python 3 are view objects

00:11:08,430 --> 00:11:14,310
that is what was backported two to seven

00:11:12,000 --> 00:11:16,470
under these three methods I honestly had

00:11:14,310 --> 00:11:19,530
completely missed at the time and have

00:11:16,470 --> 00:11:22,620
never seen used view keys view values

00:11:19,530 --> 00:11:24,120
and view items on the one hand they put

00:11:22,620 --> 00:11:26,010
iteration which is typically what you

00:11:24,120 --> 00:11:28,020
want to do one step further away you can

00:11:26,010 --> 00:11:29,790
no longer say it her items you now have

00:11:28,020 --> 00:11:33,060
to say dot items and you're given this

00:11:29,790 --> 00:11:35,370
tiny little object that is the view and

00:11:33,060 --> 00:11:38,790
then you have to say Oh for loop over it

00:11:35,370 --> 00:11:40,650
and it calls it ER and creates the

00:11:38,790 --> 00:11:41,700
second object the iterator that had

00:11:40,650 --> 00:11:43,890
knows how far through the dictionary

00:11:41,700 --> 00:11:45,870
it's gotten so far so on the one hand

00:11:43,890 --> 00:11:48,210
the one thing you ever really want to do

00:11:45,870 --> 00:11:50,190
is a step further away but it's so

00:11:48,210 --> 00:11:51,720
conceptually clean and it enables a

00:11:50,190 --> 00:11:57,930
number of operations that otherwise

00:11:51,720 --> 00:12:00,150
aren't possible so the this is decided

00:11:57,930 --> 00:12:03,060
this was how through what would work

00:12:00,150 --> 00:12:05,520
where it's two layer first you get the

00:12:03,060 --> 00:12:07,260
view by saying keys or values then if

00:12:05,520 --> 00:12:09,630
you want to you get an iterator by

00:12:07,260 --> 00:12:11,460
trying to iterate that was backported

00:12:09,630 --> 00:12:12,990
two to seven but again under those

00:12:11,460 --> 00:12:14,550
different method names so that you

00:12:12,990 --> 00:12:21,540
weren't opted into a different behavior

00:12:14,550 --> 00:12:24,920
until your code was ready I'll burn a

00:12:21,540 --> 00:12:30,000
slide on the order dick sticked it was a

00:12:24,920 --> 00:12:31,920
proposed and accepted and kept 372 not

00:12:30,000 --> 00:12:33,330
added until 3-1 so we're moving a little

00:12:31,920 --> 00:12:36,180
further ahead in history here back

00:12:33,330 --> 00:12:38,790
ported 2 to 7 it preserves insertion

00:12:36,180 --> 00:12:40,800
order it's bigger slower in fact was

00:12:38,790 --> 00:12:43,680
implementing a linked list in Python I

00:12:40,800 --> 00:12:46,440
believe until 3.4 when someone then

00:12:43,680 --> 00:12:49,620
rewrote it in 3.5 just in time almost

00:12:46,440 --> 00:12:52,980
for it to be obsolete and it's

00:12:49,620 --> 00:12:55,230
interesting so we had since 3 1 to 7 if

00:12:52,980 --> 00:12:59,310
you needed it a the order dictate

00:12:55,230 --> 00:13:02,100
dictionary but it never tempted us to

00:12:59,310 --> 00:13:04,650
close the to open peps involving the

00:13:02,100 --> 00:13:08,940
order of dictionaries one kept said

00:13:04,650 --> 00:13:11,790
shouldn't keywords come be delivered to

00:13:08,940 --> 00:13:14,220
the collie in the same order they were

00:13:11,790 --> 00:13:17,490
written shouldn't a class dictionary

00:13:14,220 --> 00:13:20,160
have a natural order those two peps each

00:13:17,490 --> 00:13:22,180
require some kind of high-performance

00:13:20,160 --> 00:13:23,260
ordered dictionary ty

00:13:22,180 --> 00:13:25,360
because you don't want to slow down

00:13:23,260 --> 00:13:27,520
keyword arguments I mean those get

00:13:25,360 --> 00:13:30,339
passed all the time and you don't want

00:13:27,520 --> 00:13:32,560
to slow down the dicks that become the

00:13:30,339 --> 00:13:34,540
namespace of a class or the dunder dict

00:13:32,560 --> 00:13:38,709
that sits behind an object's attributes

00:13:34,540 --> 00:13:39,940
so we had order in a dictionary but even

00:13:38,709 --> 00:13:44,920
in the language we didn't use it for

00:13:39,940 --> 00:13:47,140
anything serious we kept the arbitrarily

00:13:44,920 --> 00:13:49,630
ordered a traditional dictionary instead

00:13:47,140 --> 00:13:52,390
because we just needed the speed so it

00:13:49,630 --> 00:13:53,770
exists but it's used for corner cases

00:13:52,390 --> 00:13:58,480
where people know that they care about

00:13:53,770 --> 00:14:01,750
order all right we're now moving out

00:13:58,480 --> 00:14:04,870
beyond the things ever available in

00:14:01,750 --> 00:14:06,670
Python to we're now heading into the

00:14:04,870 --> 00:14:09,490
middle years between now and then

00:14:06,670 --> 00:14:12,100
original talk first we'll talk about the

00:14:09,490 --> 00:14:18,149
key sharing dictionary proposed in Pepa

00:14:12,100 --> 00:14:22,300
412 added to the language as Python 3.3

00:14:18,149 --> 00:14:24,610
this answers a question of space imagine

00:14:22,300 --> 00:14:27,550
a small class whose dunder init accepts

00:14:24,610 --> 00:14:29,860
the name a port and a protocol and saves

00:14:27,550 --> 00:14:32,080
them each as attributes so the little

00:14:29,860 --> 00:14:34,240
dunder dict that sits behind the object

00:14:32,080 --> 00:14:37,900
has to store some value under each of

00:14:34,240 --> 00:14:40,180
those three keys here from mighty

00:14:37,900 --> 00:14:42,820
dictionary talk in 2010 is our friend

00:14:40,180 --> 00:14:46,540
the hash table an array index does all

00:14:42,820 --> 00:14:50,709
arrays are in RAM by an integer index

00:14:46,540 --> 00:14:52,360
and the rule is that because we are

00:14:50,709 --> 00:14:55,959
being given keys that are not themselves

00:14:52,360 --> 00:14:58,810
integers and if they are integers maybe

00:14:55,959 --> 00:15:00,640
not successive integers giving to be

00:14:58,810 --> 00:15:03,459
being given natan nonsense like the

00:15:00,640 --> 00:15:05,250
straight name how do I find the place in

00:15:03,459 --> 00:15:10,450
memory that's named the string name well

00:15:05,250 --> 00:15:14,589
the hash tables get that value whatever

00:15:10,450 --> 00:15:17,140
it is and they fish it which is kind of

00:15:14,589 --> 00:15:22,560
this act of violence where you clobber

00:15:17,140 --> 00:15:22,560
the value and just smash it

00:15:23,910 --> 00:15:30,970
into a bunch of bits 32 bits however big

00:15:28,030 --> 00:15:33,370
or small the value was you get out 32

00:15:30,970 --> 00:15:36,820
bits no 32-bit platform and 64 on a

00:15:33,370 --> 00:15:39,790
64-bit platform and you now if you need

00:15:36,820 --> 00:15:42,870
an integer index have as many bits as

00:15:39,790 --> 00:15:46,480
you could want for forming one this

00:15:42,870 --> 00:15:49,690
simple dictionary that's not at all

00:15:46,480 --> 00:15:51,250
visible on there isn't hmm I might fix

00:15:49,690 --> 00:15:57,250
that in a minute if I feel like live

00:15:51,250 --> 00:16:00,640
coding the we have as you can see eight

00:15:57,250 --> 00:16:02,710
slots ready to be populated and so eight

00:16:00,640 --> 00:16:05,620
slots we will need three bits in order

00:16:02,710 --> 00:16:07,960
to distinguish them we choose the 1 0 0

00:16:05,620 --> 00:16:10,540
slot as the one that will hold the key

00:16:07,960 --> 00:16:13,180
name and whatever its value is and so

00:16:10,540 --> 00:16:16,540
that gets written into the dictionary we

00:16:13,180 --> 00:16:17,950
now arrive at our second one hashing the

00:16:16,540 --> 00:16:21,430
key port

00:16:17,950 --> 00:16:25,750
end of its hash is 101 so it takes the

00:16:21,430 --> 00:16:28,380
slot it happens next door and now this

00:16:25,750 --> 00:16:31,420
was a big topic in the original talk

00:16:28,380 --> 00:16:33,760
what happens if the third key happens to

00:16:31,420 --> 00:16:36,010
have a hash that's already been used 1 0

00:16:33,760 --> 00:16:38,470
0 in this case and you'll remember that

00:16:36,010 --> 00:16:40,660
there's the technical term collision for

00:16:38,470 --> 00:16:43,990
what happens when we try to store proto

00:16:40,660 --> 00:16:46,840
and run smack into the fact that name is

00:16:43,990 --> 00:16:48,790
already taking that slot so we do some

00:16:46,840 --> 00:16:51,550
math involving the other bits and choose

00:16:48,790 --> 00:16:53,320
an emergency backup slot that it can

00:16:51,550 --> 00:16:55,650
live in as well so here it goes we're

00:16:53,320 --> 00:16:58,720
going to try to store proto I've

00:16:55,650 --> 00:17:01,090
collided and so it has to go somewhere

00:16:58,720 --> 00:17:03,190
else it's now a little more expensive to

00:17:01,090 --> 00:17:05,350
look up or to reset and the other values

00:17:03,190 --> 00:17:07,120
name and port you'll find right where

00:17:05,350 --> 00:17:09,520
you look for them proto you'll find

00:17:07,120 --> 00:17:11,530
after running into every time you look

00:17:09,520 --> 00:17:17,260
for it the fact that it's not sitting at

00:17:11,530 --> 00:17:19,720
the slot you'd expect imagine now that

00:17:17,260 --> 00:17:26,020
you have your second object of this type

00:17:19,720 --> 00:17:28,900
you store name you store port proto

00:17:26,020 --> 00:17:32,650
comes in collides and has to move to its

00:17:28,900 --> 00:17:35,550
separate slot someone named mark Shannon

00:17:32,650 --> 00:17:39,840
looked at this picture and

00:17:35,550 --> 00:17:43,560
said Wow over there on the left-hand

00:17:39,840 --> 00:17:47,100
side the first column in the second

00:17:43,560 --> 00:17:49,260
column are absolutely identical they

00:17:47,100 --> 00:17:52,020
look exactly the same we're storing

00:17:49,260 --> 00:17:55,290
exactly the same five blank spots and

00:17:52,020 --> 00:18:00,030
three hashes and exactly the same five

00:17:55,290 --> 00:18:03,630
blank spots and 3-game three um keys in

00:18:00,030 --> 00:18:08,150
both of these object thunder

00:18:03,630 --> 00:18:12,450
dictionaries I should mention that the

00:18:08,150 --> 00:18:14,550
the strings are not really inside the

00:18:12,450 --> 00:18:15,930
dictionary the integer 53 isn't in the

00:18:14,550 --> 00:18:17,310
dictionary what the dictionary really

00:18:15,930 --> 00:18:18,600
stores if you can imagine that you're

00:18:17,310 --> 00:18:21,470
looking at the matrix where it all

00:18:18,600 --> 00:18:25,860
becomes code what it actually stores our

00:18:21,470 --> 00:18:28,380
addresses of the string object that says

00:18:25,860 --> 00:18:31,730
name or port or the integer object that

00:18:28,380 --> 00:18:34,470
says 53 so whenever in my dictionaries I

00:18:31,730 --> 00:18:36,630
put a little string or integer I really

00:18:34,470 --> 00:18:39,930
mean the eight bytes always the same

00:18:36,630 --> 00:18:41,820
size in a 64-bit machine that tell you

00:18:39,930 --> 00:18:45,660
where in memory to go find the object

00:18:41,820 --> 00:18:47,580
but the weather proto is a string or the

00:18:45,660 --> 00:18:51,270
address of it it's the same top and

00:18:47,580 --> 00:18:55,320
bottom and mark Shannon thought about

00:18:51,270 --> 00:18:57,480
this class has just been created what if

00:18:55,320 --> 00:19:01,110
we wait for the first ever call to that

00:18:57,480 --> 00:19:02,880
classes dunder init it will create an

00:19:01,110 --> 00:19:07,500
instance of the object that looks like

00:19:02,880 --> 00:19:09,720
this what if we then go in and split

00:19:07,500 --> 00:19:15,150
apart and store in separate areas of

00:19:09,720 --> 00:19:19,650
memory the hashes and the keys and keep

00:19:15,150 --> 00:19:22,020
them forever and with the objects dunder

00:19:19,650 --> 00:19:23,580
dict only store the values because that

00:19:22,020 --> 00:19:26,430
first object created might go away

00:19:23,580 --> 00:19:30,600
sometime but we keep forever linked to

00:19:26,430 --> 00:19:34,140
the class that frozen set of hashes and

00:19:30,600 --> 00:19:36,990
keys so that as someone then creates a

00:19:34,140 --> 00:19:39,780
second instance of the object as someone

00:19:36,990 --> 00:19:45,390
then creates a third instance of the

00:19:39,780 --> 00:19:47,400
object you're only burning the space for

00:19:45,390 --> 00:19:50,910
storing the values

00:19:47,400 --> 00:19:53,520
you're only burning 1/3 the space and

00:19:50,910 --> 00:19:55,440
getting 2/3 savings because you're not

00:19:53,520 --> 00:19:58,230
over and over and over again in every

00:19:55,440 --> 00:20:00,960
object repeating the hash repeating the

00:19:58,230 --> 00:20:03,270
key when in so many classes they're

00:20:00,960 --> 00:20:05,550
exactly the same every time

00:20:03,270 --> 00:20:08,850
memory savings even on a tiny object

00:20:05,550 --> 00:20:11,250
that fits inside of an eighth entry five

00:20:08,850 --> 00:20:13,860
of which can be populated Python

00:20:11,250 --> 00:20:16,559
dictionary you're saving a hundred 28

00:20:13,860 --> 00:20:18,270
bytes for every object if there's

00:20:16,559 --> 00:20:21,420
thousands or millions that adds up to

00:20:18,270 --> 00:20:23,790
real measurable savings now you do burn

00:20:21,420 --> 00:20:26,429
a little space because every dictionary

00:20:23,790 --> 00:20:28,380
ever created now needs 8 extra bytes so

00:20:26,429 --> 00:20:31,200
that if it is stored in split fashion it

00:20:28,380 --> 00:20:32,640
knows where to get to the values array

00:20:31,200 --> 00:20:33,240
that's separate in that case from the

00:20:32,640 --> 00:20:35,640
keys

00:20:33,240 --> 00:20:38,970
but when measurements were done the

00:20:35,640 --> 00:20:42,540
extra 8 bytes was easily made up for by

00:20:38,970 --> 00:20:44,270
the savings for common objects with

00:20:42,540 --> 00:20:46,920
repeated attributes in fact

00:20:44,270 --> 00:20:48,360
object-oriented programs I mean normal

00:20:46,920 --> 00:20:51,120
lists and dictionaries don't care about

00:20:48,360 --> 00:20:53,760
this so if a program uses a lot of numpy

00:20:51,120 --> 00:20:55,710
arrays or lists it doesn't benefit but

00:20:53,760 --> 00:20:59,070
object-oriented programs with lots of

00:20:55,710 --> 00:21:02,040
objects often use 10 to 20 percent less

00:20:59,070 --> 00:21:05,280
memory because of this innovation key

00:21:02,040 --> 00:21:06,929
sharing Python 3.3 what do you care

00:21:05,280 --> 00:21:09,350
about because of course you can't turn

00:21:06,929 --> 00:21:12,630
this on or off it's just going to happen

00:21:09,350 --> 00:21:15,240
yeah and only if you're on 3.3 or later

00:21:12,630 --> 00:21:18,179
the takeaway for you is that in your

00:21:15,240 --> 00:21:20,250
objects make sure that dunder init

00:21:18,179 --> 00:21:22,320
assigns every attribute you're ever

00:21:20,250 --> 00:21:23,730
going to use set them to none if you

00:21:22,320 --> 00:21:25,559
need to or to the empty string or

00:21:23,730 --> 00:21:28,380
whatever makes sense but yet the men

00:21:25,559 --> 00:21:30,210
because if you don't and during its

00:21:28,380 --> 00:21:34,800
lifetime one of your objects tries using

00:21:30,210 --> 00:21:37,320
a new attribute then its values will

00:21:34,800 --> 00:21:39,150
have to be thrown away a fold under dict

00:21:37,320 --> 00:21:41,400
will a traditional dictionary will have

00:21:39,150 --> 00:21:44,370
to be allocated for it and all of its

00:21:41,400 --> 00:21:46,620
attributes copied over if a single key

00:21:44,370 --> 00:21:50,640
single attribute is added it's not in

00:21:46,620 --> 00:21:53,880
that original prototypical set of keys

00:21:50,640 --> 00:21:56,100
then you lose the sharing but this is a

00:21:53,880 --> 00:21:58,170
habit you should already have had pi pi

00:21:56,100 --> 00:21:59,970
can't do a lot of optimizations if

00:21:58,170 --> 00:22:00,960
attributes come and go randomly they

00:21:59,970 --> 00:22:02,970
also recommend

00:22:00,960 --> 00:22:05,669
setting them all and under Annette so

00:22:02,970 --> 00:22:07,649
and it's good documentation I can read

00:22:05,669 --> 00:22:09,299
your dunder init function and know all

00:22:07,649 --> 00:22:12,179
of the attributes and not be very

00:22:09,299 --> 00:22:14,130
surprised later when I see one appear in

00:22:12,179 --> 00:22:16,350
the middle of a method so this was

00:22:14,130 --> 00:22:18,270
already a best practice this best

00:22:16,350 --> 00:22:21,059
practice now care is the additional

00:22:18,270 --> 00:22:24,330
benefit in Python three three key

00:22:21,059 --> 00:22:25,620
sharing all right for the next few

00:22:24,330 --> 00:22:27,720
minutes we get to delve into the

00:22:25,620 --> 00:22:29,850
exciting world of computer security of

00:22:27,720 --> 00:22:33,049
dealing with people who want to break

00:22:29,850 --> 00:22:37,320
your application this next thing

00:22:33,049 --> 00:22:40,049
randomly seeded hashes was not a pet it

00:22:37,320 --> 00:22:43,669
only warranted an issue in the Python

00:22:40,049 --> 00:22:47,520
bug tracker and it has to do with this

00:22:43,669 --> 00:22:49,770
how fast does a dictionary normally fill

00:22:47,520 --> 00:22:51,390
let's say I have five things I need to

00:22:49,770 --> 00:22:57,620
put in let's kind of watch the speed

00:22:51,390 --> 00:23:00,600
here stone bowl Oh collide cat doh eagle

00:22:57,620 --> 00:23:02,039
notice that sometimes a dictionary key

00:23:00,600 --> 00:23:04,380
takes a little longer to make it in

00:23:02,039 --> 00:23:06,149
because of the collision but winged

00:23:04,380 --> 00:23:08,940
collisions don't take place which on

00:23:06,149 --> 00:23:12,059
average isn't very often notice that the

00:23:08,940 --> 00:23:15,299
last two entities DOE and Eagle made it

00:23:12,059 --> 00:23:17,640
in as fast as the first ones new

00:23:15,299 --> 00:23:19,679
insertions unless they collide don't

00:23:17,640 --> 00:23:22,020
take any longer than the first one as we

00:23:19,679 --> 00:23:25,020
talked about in my original version of

00:23:22,020 --> 00:23:27,090
this talk the thousand or million item

00:23:25,020 --> 00:23:29,039
added to a dictionary should insert just

00:23:27,090 --> 00:23:34,130
as quickly as the first one which is the

00:23:29,039 --> 00:23:37,799
magic of a dictionary stone Oh OOP cat

00:23:34,130 --> 00:23:41,490
doh eagle that's the magic of the

00:23:37,799 --> 00:23:43,860
dictionary it turns out if the person

00:23:41,490 --> 00:23:48,289
using your web application isn't your

00:23:43,860 --> 00:23:50,429
friend they can take that benefit away

00:23:48,289 --> 00:23:52,409
what if they were to come up with a

00:23:50,429 --> 00:23:55,590
series of words and they have all the

00:23:52,409 --> 00:23:58,169
time in the world to do this before they

00:23:55,590 --> 00:24:00,029
hit your website where the second value

00:23:58,169 --> 00:24:02,100
is guaranteed to collide with the first

00:24:00,029 --> 00:24:03,960
and then the third is going to collide

00:24:02,100 --> 00:24:06,029
with the first two and then the fourth

00:24:03,960 --> 00:24:09,389
with the first three and so on maybe

00:24:06,029 --> 00:24:12,630
through thousands of potential keys then

00:24:09,389 --> 00:24:13,650
the rhythm doe cat eagle goes something

00:24:12,630 --> 00:24:29,670
like this

00:24:13,650 --> 00:24:32,070
a back buying cabbed deal ah easels that

00:24:29,670 --> 00:24:35,520
wasn't exactly the snappy rhythm that we

00:24:32,070 --> 00:24:37,050
saw before was it uh have you is what

00:24:35,520 --> 00:24:39,930
happens at a keyboard if you're loading

00:24:37,050 --> 00:24:42,060
information to do a database and instead

00:24:39,930 --> 00:24:44,160
of going you know first thousand people

00:24:42,060 --> 00:24:46,740
second thousand third thousand four

00:24:44,160 --> 00:24:50,430
thousand I remember once I was loading a

00:24:46,740 --> 00:24:57,750
table and it went first thousand second

00:24:50,430 --> 00:24:59,430
thousand third thousand and was like

00:24:57,750 --> 00:25:01,740
then two minutes before the four

00:24:59,430 --> 00:25:05,330
thousand were done because I'd declared

00:25:01,740 --> 00:25:08,370
a column unique but not added in index

00:25:05,330 --> 00:25:10,860
to let the dictionary as more and more

00:25:08,370 --> 00:25:14,100
people were added quickly check all the

00:25:10,860 --> 00:25:17,340
previous people for a duplicate if

00:25:14,100 --> 00:25:19,560
somebody chooses a set of keys where the

00:25:17,340 --> 00:25:22,230
fifth one takes five times as long and

00:25:19,560 --> 00:25:25,980
the tenth one takes ten times as long as

00:25:22,230 --> 00:25:31,910
the first insert then I am suddenly in a

00:25:25,980 --> 00:25:34,980
situation called accidentally quadratic

00:25:31,910 --> 00:25:37,560
where the amount of time I take will

00:25:34,980 --> 00:25:39,930
vary with the square of the number of

00:25:37,560 --> 00:25:42,570
items entered meaning thousand items

00:25:39,930 --> 00:25:45,630
should take about a million moments of

00:25:42,570 --> 00:25:49,730
work and there's actually a blog about

00:25:45,630 --> 00:25:54,420
this I highly recommend to you all

00:25:49,730 --> 00:25:57,000
accidentally quadratic tumblr.com it is

00:25:54,420 --> 00:25:59,910
an entertaining blog of one or two posts

00:25:57,000 --> 00:26:01,560
a month about all kinds of high end

00:25:59,910 --> 00:26:05,220
professionally designed software

00:26:01,560 --> 00:26:08,670
projects that it turns out in their

00:26:05,220 --> 00:26:11,510
corners have quadratic rather than

00:26:08,670 --> 00:26:15,210
linear or logarithmic behavior things

00:26:11,510 --> 00:26:17,520
browsers servers that it turns out you

00:26:15,210 --> 00:26:20,000
can make instead of going one two three

00:26:17,520 --> 00:26:22,680
four five through a set of items of work

00:26:20,000 --> 00:26:26,620
give you that sinking feeling by going

00:26:22,680 --> 00:26:30,140
one two three

00:26:26,620 --> 00:26:33,730
door and so forth how many of you have

00:26:30,140 --> 00:26:37,010
ever run something that had exactly that

00:26:33,730 --> 00:26:38,300
pattern it's it's I always know what's

00:26:37,010 --> 00:26:42,110
gone wrong typically when you see

00:26:38,300 --> 00:26:44,780
something slowing down like that so we

00:26:42,110 --> 00:26:46,790
had to fix the hash function how does a

00:26:44,780 --> 00:26:48,470
hash function work well one version of

00:26:46,790 --> 00:26:53,060
Python this is one that we used for a

00:26:48,470 --> 00:26:55,040
long time we in the main loop have the

00:26:53,060 --> 00:26:58,580
hash of the string so far as we're

00:26:55,040 --> 00:27:00,590
partway through it hashing it and to

00:26:58,580 --> 00:27:03,980
absorb the next character of information

00:27:00,590 --> 00:27:07,370
we multiply the current hash by a

00:27:03,980 --> 00:27:11,480
million and three magic number million

00:27:07,370 --> 00:27:13,820
and three and then we exclusive or in

00:27:11,480 --> 00:27:15,770
the next character of the string to slip

00:27:13,820 --> 00:27:17,840
in the lower byte whichever bits are set

00:27:15,770 --> 00:27:19,490
in the incoming character so we're

00:27:17,840 --> 00:27:21,440
feeding characters in each time

00:27:19,490 --> 00:27:24,800
multiplying by a million three and then

00:27:21,440 --> 00:27:27,920
pulling in 8 bits more of information

00:27:24,800 --> 00:27:30,950
from the next character you'll

00:27:27,920 --> 00:27:33,560
understand a bit about how this is is

00:27:30,950 --> 00:27:36,410
filling the complete 32-bit or 64-bit

00:27:33,560 --> 00:27:38,690
hash with information if you ever played

00:27:36,410 --> 00:27:41,390
around with multiplication as a kid

00:27:38,690 --> 00:27:42,950
either by hand or on a calculator where

00:27:41,390 --> 00:27:45,620
you might have discovered that by making

00:27:42,950 --> 00:27:47,300
a number yeah a thousand and one where

00:27:45,620 --> 00:27:49,580
all of the digits are just zeros or ones

00:27:47,300 --> 00:27:51,980
you could produce an output number that

00:27:49,580 --> 00:27:54,110
was kind of cool it was little copies of

00:27:51,980 --> 00:27:57,020
your original number trapped inside of

00:27:54,110 --> 00:27:59,210
this much much larger value for

00:27:57,020 --> 00:28:02,300
simplicity I will as they taught me in

00:27:59,210 --> 00:28:05,720
elementary school allied the rows that

00:28:02,300 --> 00:28:06,920
are just zeros for space here but you

00:28:05,720 --> 00:28:09,440
might have found that you could make

00:28:06,920 --> 00:28:11,480
even bigger numbers put some zeros and

00:28:09,440 --> 00:28:14,570
then another one and you now had another

00:28:11,480 --> 00:28:17,270
copy of your original number inside of

00:28:14,570 --> 00:28:20,090
the digits of the large output of the

00:28:17,270 --> 00:28:21,650
multiplication but you might have

00:28:20,090 --> 00:28:24,140
noticed that you can't put those ones

00:28:21,650 --> 00:28:25,850
too close together or all of a sudden

00:28:24,140 --> 00:28:27,830
the pretty little copies of your numbers

00:28:25,850 --> 00:28:30,320
start looking more interesting digits

00:28:27,830 --> 00:28:32,570
that aren't in the original will begin

00:28:30,320 --> 00:28:34,700
to show up all of a sudden you won't be

00:28:32,570 --> 00:28:37,170
able to predict what the next digit is

00:28:34,700 --> 00:28:41,430
because of course the ones care

00:28:37,170 --> 00:28:45,210
and move information leftward is

00:28:41,430 --> 00:28:47,250
interesting the asymmetry the ones

00:28:45,210 --> 00:28:50,070
carrying never bother the numbers to the

00:28:47,250 --> 00:28:51,990
right can make all kinds of assertions

00:28:50,070 --> 00:28:54,600
about the numbers to the right odd and

00:28:51,990 --> 00:28:58,650
even multiple five or not multiple of

00:28:54,600 --> 00:29:01,110
ten you can't do that facing leftward in

00:28:58,650 --> 00:29:04,740
the number because that carry that

00:29:01,110 --> 00:29:07,670
happens pushes new digits and chaos out

00:29:04,740 --> 00:29:10,410
of the direction of the higher order

00:29:07,670 --> 00:29:13,470
numbers when you add and therefore when

00:29:10,410 --> 00:29:17,220
you multiply which is simply a repeated

00:29:13,470 --> 00:29:19,380
addition so when we sit here repeatedly

00:29:17,220 --> 00:29:21,780
multiplying a number by a million three

00:29:19,380 --> 00:29:25,890
and then putting new bits in the bottom

00:29:21,780 --> 00:29:28,770
we are taking this number in binary and

00:29:25,890 --> 00:29:30,600
look at how it uses its ones two tucked

00:29:28,770 --> 00:29:32,310
in right at the bottom to make sure that

00:29:30,600 --> 00:29:35,460
two copies of the value that you've

00:29:32,310 --> 00:29:37,500
accumulated so far are just shifted by

00:29:35,460 --> 00:29:39,810
one bit and then forced to add with each

00:29:37,500 --> 00:29:42,150
other then a bit of a gap in the middle

00:29:39,810 --> 00:29:44,310
that's only sparsely populated with ones

00:29:42,150 --> 00:29:47,520
just bringing a few more copies of that

00:29:44,310 --> 00:29:49,680
number in and then four ones up at the

00:29:47,520 --> 00:29:52,320
top that make sure that four copies of

00:29:49,680 --> 00:29:55,290
the previous hash value are piled right

00:29:52,320 --> 00:29:57,480
next to each other in order to add and

00:29:55,290 --> 00:30:00,600
create all sorts of interesting carries

00:29:57,480 --> 00:30:03,420
and chaos as the bits slowly in the

00:30:00,600 --> 00:30:05,940
process of multiplication move leftward

00:30:03,420 --> 00:30:08,160
and that's of course why we or the

00:30:05,940 --> 00:30:10,560
incoming bytes into the bottom because

00:30:08,160 --> 00:30:12,870
the multiplication is constantly shoving

00:30:10,560 --> 00:30:14,490
upward into the high bits the entropy

00:30:12,870 --> 00:30:17,510
that we introduced by reading through

00:30:14,490 --> 00:30:20,310
the string in the lower bits that's

00:30:17,510 --> 00:30:22,350
katha mission since they learned we were

00:30:20,310 --> 00:30:25,500
interested in hash functions and

00:30:22,350 --> 00:30:27,690
computer scientists alike have done far

00:30:25,500 --> 00:30:29,370
more formal analyses than this kind of

00:30:27,690 --> 00:30:32,100
hand waving I'm doing to give you the

00:30:29,370 --> 00:30:34,140
feel of how a hash works we can now have

00:30:32,100 --> 00:30:36,030
a number of mathematical properties to

00:30:34,140 --> 00:30:38,460
rate hash functions and we can get

00:30:36,030 --> 00:30:41,010
things like Python - function and ask

00:30:38,460 --> 00:30:43,890
which properties it has how evenly

00:30:41,010 --> 00:30:46,320
distributes bits but this kind of idea

00:30:43,890 --> 00:30:48,000
of visualizing the multiplication

00:30:46,320 --> 00:30:48,650
hopefully will give you a little bit of

00:30:48,000 --> 00:30:51,230
an in

00:30:48,650 --> 00:30:53,420
dinked for how hash functions work and

00:30:51,230 --> 00:30:55,820
what the formalisms of improving that

00:30:53,420 --> 00:30:57,650
properties are about it's about whether

00:30:55,820 --> 00:30:59,690
the big crazy number you're using to

00:30:57,650 --> 00:31:02,120
shove information to the left does a

00:30:59,690 --> 00:31:04,610
good job of scattering around any

00:31:02,120 --> 00:31:09,440
patterns that might have been in the

00:31:04,610 --> 00:31:11,360
original values and this was a big

00:31:09,440 --> 00:31:13,100
problem with Python it always used this

00:31:11,360 --> 00:31:15,230
algorithm always started with the same

00:31:13,100 --> 00:31:17,600
value so if I knew you were using Python

00:31:15,230 --> 00:31:20,150
for your application I could sit at home

00:31:17,600 --> 00:31:23,350
and try to come up with values with

00:31:20,150 --> 00:31:25,850
strings that would have the same hash

00:31:23,350 --> 00:31:28,430
December we decayed this became famous

00:31:25,850 --> 00:31:32,780
in December of 2011 a security

00:31:28,430 --> 00:31:35,870
conference 28c three efficient denial of

00:31:32,780 --> 00:31:38,510
service attacks do s's on web

00:31:35,870 --> 00:31:40,460
application platforms platforms because

00:31:38,510 --> 00:31:44,210
python was not their big target I

00:31:40,460 --> 00:31:46,430
thought had this problem but so did

00:31:44,210 --> 00:31:48,410
almost every other language they in fact

00:31:46,430 --> 00:31:50,900
this is kind of fun it was 2011

00:31:48,410 --> 00:31:52,490
so they made a list of the web

00:31:50,900 --> 00:31:54,620
application technology as they were

00:31:52,490 --> 00:31:56,510
about to discuss and to know how

00:31:54,620 --> 00:31:59,390
important each of them were they went

00:31:56,510 --> 00:32:01,040
and found a website that ranked

00:31:59,390 --> 00:32:04,220
programming languages by their

00:32:01,040 --> 00:32:06,560
importance to the web you'll be happy to

00:32:04,220 --> 00:32:09,200
know that our vulnerability to

00:32:06,560 --> 00:32:13,310
deliberately created hashes only

00:32:09,200 --> 00:32:18,650
affected 0.2% of the web according to

00:32:13,310 --> 00:32:20,770
the numbers they had at the time Python

00:32:18,650 --> 00:32:25,280
hash function they said could be broken

00:32:20,770 --> 00:32:27,670
they didn't actually illustrate how to

00:32:25,280 --> 00:32:29,870
do this but they said it could be broken

00:32:27,670 --> 00:32:31,520
computationally looking for

00:32:29,870 --> 00:32:33,740
possibilities with what's called a meet

00:32:31,520 --> 00:32:36,050
in the middle attack they could only

00:32:33,740 --> 00:32:38,890
find reasonable sized attack strings for

00:32:36,050 --> 00:32:41,630
32-bit systems hadn't done it for 64

00:32:38,890 --> 00:32:47,270
they did a web search to find out what

00:32:41,630 --> 00:32:49,700
our web framework was plone so they

00:32:47,270 --> 00:32:51,980
found that it had a max size of one

00:32:49,700 --> 00:32:54,110
megabyte if you post form data to it

00:32:51,980 --> 00:32:56,030
it'll throw it out and not even look at

00:32:54,110 --> 00:32:58,550
it it's over a megabyte so they played

00:32:56,030 --> 00:32:59,680
around with megabyte payloads where all

00:32:58,550 --> 00:33:01,630
of the

00:32:59,680 --> 00:33:03,760
and values where all the names were

00:33:01,630 --> 00:33:07,090
going to collide they were able to make

00:33:03,760 --> 00:33:09,580
a plum site spend seven minutes of CPU

00:33:07,090 --> 00:33:12,670
in order to parse a single one megabyte

00:33:09,580 --> 00:33:15,720
request such a site once you learned the

00:33:12,670 --> 00:33:18,640
trick was a very easy site to bring down

00:33:15,720 --> 00:33:21,610
just two months ago if you're interested

00:33:18,640 --> 00:33:26,010
in the cryptography of hash functions a

00:33:21,610 --> 00:33:28,800
really really neat blog post appeared of

00:33:26,010 --> 00:33:33,130
someone who has published their work and

00:33:28,800 --> 00:33:34,240
has figured out how to produce 64-bit

00:33:33,130 --> 00:33:36,550
hash collisions

00:33:34,240 --> 00:33:38,710
not the little 32-bit collisions of the

00:33:36,550 --> 00:33:40,660
original research go look for that on

00:33:38,710 --> 00:33:42,940
medium.com if you want to see how

00:33:40,660 --> 00:33:44,650
someone Robert gross he's learning

00:33:42,940 --> 00:33:45,520
cryptography and to have a target to

00:33:44,650 --> 00:33:47,860
practice on

00:33:45,520 --> 00:33:50,040
he took pythons old hash function put it

00:33:47,860 --> 00:33:52,720
through the wringer and figured out in a

00:33:50,040 --> 00:33:55,270
moderate amount of computing time how to

00:33:52,720 --> 00:33:58,840
get some lists of hundreds at least of

00:33:55,270 --> 00:34:03,610
keys that even on a 64-bit system hash

00:33:58,840 --> 00:34:05,110
to the same value great article so the

00:34:03,610 --> 00:34:06,790
immediate response we had to do

00:34:05,110 --> 00:34:10,480
something quickly was to sprinkle a

00:34:06,790 --> 00:34:14,770
little randomness around this basic hash

00:34:10,480 --> 00:34:18,100
algorithm we also decided to dignify 1

00:34:14,770 --> 00:34:21,490
million and 3 with a pound defined

00:34:18,100 --> 00:34:24,040
statement apparently by adding a few

00:34:21,490 --> 00:34:27,010
random bits at the beginning every

00:34:24,040 --> 00:34:29,730
website every time Python launched would

00:34:27,010 --> 00:34:32,710
have a different way a different output

00:34:29,730 --> 00:34:36,970
for a given string so you could no

00:34:32,710 --> 00:34:39,280
longer count on your list of precomputed

00:34:36,970 --> 00:34:41,320
collisions working and then there was a

00:34:39,280 --> 00:34:44,140
bit of randomness a suffix added at the

00:34:41,320 --> 00:34:46,480
end or exclusive or 10 at the end that

00:34:44,140 --> 00:34:49,360
helped hide the prefix so it wasn't too

00:34:46,480 --> 00:34:51,550
easy to say if a site exposed its

00:34:49,360 --> 00:34:52,210
dictionary order in its jason return

00:34:51,550 --> 00:34:54,400
value

00:34:52,210 --> 00:34:56,950
made it harder to use that to guess what

00:34:54,400 --> 00:34:59,830
their secrets that particular server was

00:34:56,950 --> 00:35:02,950
using the main thing you'll notice is

00:34:59,830 --> 00:35:06,610
that your web applications can't easily

00:35:02,950 --> 00:35:10,450
be do s it's not a perfect solution but

00:35:06,610 --> 00:35:12,520
it makes it much much harder to create a

00:35:10,450 --> 00:35:13,330
situation where you just fall over doing

00:35:12,520 --> 00:35:17,740
seven minutes

00:35:13,330 --> 00:35:20,830
CPU work and your dictionary has always

00:35:17,740 --> 00:35:22,720
come out in a different order for

00:35:20,830 --> 00:35:25,330
exactly the same program exactly the

00:35:22,720 --> 00:35:28,320
same input suddenly the dictionary order

00:35:25,330 --> 00:35:30,820
goes random apparently in 3.3 and

00:35:28,320 --> 00:35:33,490
subsequent they made because this was a

00:35:30,820 --> 00:35:36,220
security issue bug-fix releases a two

00:35:33,490 --> 00:35:37,870
six seven three one and two but remember

00:35:36,220 --> 00:35:40,450
they're because they couldn't break

00:35:37,870 --> 00:35:42,970
existing tests and code you only get

00:35:40,450 --> 00:35:45,520
that protection against DLS attacks with

00:35:42,970 --> 00:35:47,170
the - capital R flag I believe there's

00:35:45,520 --> 00:35:52,630
also an environment variable that will

00:35:47,170 --> 00:35:55,420
turn on the randomness so they pointed

00:35:52,630 --> 00:35:58,330
out the useless uselessness of that the

00:35:55,420 --> 00:36:01,540
next year at the next instance of the

00:35:58,330 --> 00:36:03,340
same security conference at 29 C 3 they

00:36:01,540 --> 00:36:07,480
use it apparently successive integers

00:36:03,340 --> 00:36:10,600
hash flooding BOS reloaded was presented

00:36:07,480 --> 00:36:12,870
by three new researchers to outline how

00:36:10,600 --> 00:36:16,990
badly many languages had result

00:36:12,870 --> 00:36:20,500
responded to the original filing and

00:36:16,990 --> 00:36:24,790
complained they were not actually able I

00:36:20,500 --> 00:36:27,190
noticed two remotely watching a Python

00:36:24,790 --> 00:36:29,200
app figure out how to create collisions

00:36:27,190 --> 00:36:31,690
but they at least were able to recover

00:36:29,200 --> 00:36:34,030
the random key by calling hash in a

00:36:31,690 --> 00:36:36,880
Python program which suggested that

00:36:34,030 --> 00:36:38,650
information was being leaked that maybe

00:36:36,880 --> 00:36:41,290
could have been exploited remotely and

00:36:38,650 --> 00:36:43,990
more importantly these researchers

00:36:41,290 --> 00:36:47,320
solved the problem they did the work and

00:36:43,990 --> 00:36:49,860
introduced sip hash made it free for any

00:36:47,320 --> 00:36:52,630
language that wanted to use it which is

00:36:49,860 --> 00:36:55,270
is random each time you start the

00:36:52,630 --> 00:36:57,130
runtime up your get set of hashes you've

00:36:55,270 --> 00:37:00,490
ever seen before we'll never see again

00:36:57,130 --> 00:37:03,760
and no attacker should be able to

00:37:00,490 --> 00:37:07,480
reasonably guess what that secret is and

00:37:03,760 --> 00:37:10,560
generate collisions for you sip hash did

00:37:07,480 --> 00:37:13,200
earn a tap for 56 it was proposed

00:37:10,560 --> 00:37:15,850
everyone's that no because it's too slow

00:37:13,200 --> 00:37:17,950
Python devil await a minute if you do

00:37:15,850 --> 00:37:20,290
this to the bits if we combine this we

00:37:17,950 --> 00:37:21,970
do this many bytes at a time and finally

00:37:20,290 --> 00:37:22,840
we got it fast enough that they put it

00:37:21,970 --> 00:37:24,730
in and it

00:37:22,840 --> 00:37:27,250
is accepted as standard track for the

00:37:24,730 --> 00:37:30,640
language it's in three four three five

00:37:27,250 --> 00:37:33,880
three six you have default turned on all

00:37:30,640 --> 00:37:36,250
the time hard crypto protection so far

00:37:33,880 --> 00:37:41,080
as we know at the moment such things

00:37:36,250 --> 00:37:44,230
always change at the language level from

00:37:41,080 --> 00:37:45,750
those kind of do s attacks the

00:37:44,230 --> 00:37:48,760
lighter-weight

00:37:45,750 --> 00:37:52,120
sprinkle of randomness is there in three

00:37:48,760 --> 00:37:54,100
three and in many bug-fix releases of

00:37:52,120 --> 00:37:56,830
previous versions if you remember to

00:37:54,100 --> 00:38:01,060
turn them on with - capital R or an

00:37:56,830 --> 00:38:03,190
environment variable so that is why your

00:38:01,060 --> 00:38:07,840
dictionary suddenly went out of order if

00:38:03,190 --> 00:38:13,180
you were using Python 3 3 + 3 4 and 3 5

00:38:07,840 --> 00:38:14,620
will get 2 3 6 in a minute internal

00:38:13,180 --> 00:38:17,140
change that I'll just describe very

00:38:14,620 --> 00:38:19,420
briefly pepp 509 added a private version

00:38:17,140 --> 00:38:20,830
number every day they burned 8 more

00:38:19,420 --> 00:38:23,110
bytes in every one of all our

00:38:20,830 --> 00:38:24,640
dictionaries they wit in and every

00:38:23,110 --> 00:38:26,950
dictionary has a version number and they

00:38:24,640 --> 00:38:30,490
have elsewhere in memory a master

00:38:26,950 --> 00:38:33,010
version counter and when you go and

00:38:30,490 --> 00:38:34,600
change a dictionary the master counter

00:38:33,010 --> 00:38:36,820
is incremented from a million to a

00:38:34,600 --> 00:38:39,100
million and 1 and that value a million

00:38:36,820 --> 00:38:41,650
and one is written into the version

00:38:39,100 --> 00:38:42,910
number of that dictionary so what this

00:38:41,650 --> 00:38:44,770
means is you can come back later and

00:38:42,910 --> 00:38:46,720
know if it's been modified without

00:38:44,770 --> 00:38:48,850
reading all of its maybe hundreds of

00:38:46,720 --> 00:38:50,560
keys and values you just look and see if

00:38:48,850 --> 00:38:53,770
the version has increased since the last

00:38:50,560 --> 00:38:56,200
time you were there a lot of the pain of

00:38:53,770 --> 00:38:58,660
trying to optimize Python is that

00:38:56,200 --> 00:39:01,720
anything can change at any time some

00:38:58,660 --> 00:39:04,030
ones that decide to monkey patch so code

00:39:01,720 --> 00:39:07,120
that looks like it should be referencing

00:39:04,030 --> 00:39:09,160
a built in you use all the time could

00:39:07,120 --> 00:39:11,890
instead be intercepted by someone having

00:39:09,160 --> 00:39:14,800
ejected a function of that name at the

00:39:11,890 --> 00:39:17,770
module level or they could edit the

00:39:14,800 --> 00:39:19,300
built-in built-ins module someone

00:39:17,770 --> 00:39:22,690
writing an optimized version of a

00:39:19,300 --> 00:39:23,260
function can now check for that has the

00:39:22,690 --> 00:39:25,930
Global's

00:39:23,260 --> 00:39:27,580
of the module changed look at its

00:39:25,930 --> 00:39:29,530
version number hidden in that dictionary

00:39:27,580 --> 00:39:31,660
you'll know whether it's been touched

00:39:29,530 --> 00:39:33,610
and if it hasn't you can keep using the

00:39:31,660 --> 00:39:35,890
optimized version of a routine that has

00:39:33,610 --> 00:39:39,309
inlined the built-in

00:39:35,890 --> 00:39:41,559
has the built-ins dictionary changed

00:39:39,309 --> 00:39:43,930
look at its version number so all sorts

00:39:41,559 --> 00:39:45,910
of optimizations that pythons dynamic

00:39:43,930 --> 00:39:47,410
nature had made impossible because you

00:39:45,910 --> 00:39:49,630
never know when someone might replace a

00:39:47,410 --> 00:39:51,910
built-in with something else are now

00:39:49,630 --> 00:39:55,269
possible because the dictionaries that

00:39:51,910 --> 00:39:58,480
holds the built-ins that hold class name

00:39:55,269 --> 00:40:00,910
spaces and that hold module namespaces

00:39:58,480 --> 00:40:03,190
now along with all of our other

00:40:00,910 --> 00:40:04,809
dictionaries have a version number it's

00:40:03,190 --> 00:40:07,029
internal I haven't seen an interface for

00:40:04,809 --> 00:40:09,400
users to get to it but it's an

00:40:07,029 --> 00:40:13,210
implementation detail of Python and 3

00:40:09,400 --> 00:40:16,210
now to accelerate optimisation on that

00:40:13,210 --> 00:40:19,920
platform pepp 509 is where you can get

00:40:16,210 --> 00:40:26,319
more details I glossed over that quickly

00:40:19,920 --> 00:40:29,200
to talk about compact dictionaries the

00:40:26,319 --> 00:40:32,250
big big change in Python 3.6 that

00:40:29,200 --> 00:40:36,039
changes dictionaries forever a

00:40:32,250 --> 00:40:37,720
dictionary you'll recall fills up one

00:40:36,039 --> 00:40:39,970
item at a time there's collisions

00:40:37,720 --> 00:40:41,650
hopefully not on most of the values and

00:40:39,970 --> 00:40:45,039
at this point it's as full as it's going

00:40:41,650 --> 00:40:47,019
to get if you add another key to this

00:40:45,039 --> 00:40:50,109
dictionary that's more than two-thirds

00:40:47,019 --> 00:40:52,750
full so a new dictionary hash table is

00:40:50,109 --> 00:40:54,309
allocated of 16 twice as big and all the

00:40:52,750 --> 00:40:57,670
keys are reinserted before you're

00:40:54,309 --> 00:40:58,930
allowed to continue looking it back what

00:40:57,670 --> 00:41:01,569
it looked like when it just had five

00:40:58,930 --> 00:41:03,880
keys in it this is it this is as full as

00:41:01,569 --> 00:41:06,579
we're going to let it get and yet it

00:41:03,880 --> 00:41:09,940
still has noticeable blank space in it

00:41:06,579 --> 00:41:13,960
three of its rows are holding nothing 8

00:41:09,940 --> 00:41:16,390
bytes on a 64-bit system of hash 8 bytes

00:41:13,960 --> 00:41:20,559
of address for that key 8 bytes of

00:41:16,390 --> 00:41:23,890
address for that value 72 bytes are

00:41:20,559 --> 00:41:25,809
still empty when we declare it so full

00:41:23,890 --> 00:41:28,000
that we're throwing it out and starting

00:41:25,809 --> 00:41:32,410
over with a more sparse data structure

00:41:28,000 --> 00:41:34,000
in 2012 Rayment Ettinger had an idea he

00:41:32,410 --> 00:41:36,009
introduced it on Python dev and

00:41:34,000 --> 00:41:40,299
immediately some improvements to it were

00:41:36,009 --> 00:41:42,460
suggested every problem in computer

00:41:40,299 --> 00:41:45,039
science can be solved with an extra

00:41:42,460 --> 00:41:49,630
layer of indirection what if we don't

00:41:45,039 --> 00:41:52,990
use those big 24-bit rows

00:41:49,630 --> 00:41:56,049
to remember which hash locations we've

00:41:52,990 --> 00:42:00,910
used what if instead we were simply to

00:41:56,049 --> 00:42:04,269
use 8 bytes and when it's time to start

00:42:00,910 --> 00:42:06,910
adding items to the dictionary what if

00:42:04,269 --> 00:42:10,779
we simply remembered in a little-bitty

00:42:06,910 --> 00:42:14,890
array of 8 bytes the location in a

00:42:10,779 --> 00:42:18,059
bigger or a list of where we had put the

00:42:14,890 --> 00:42:22,119
hash the key and the value

00:42:18,059 --> 00:42:25,930
instead of a dictionary having to keep

00:42:22,119 --> 00:42:29,250
entire 24-bit slots free as it now has

00:42:25,930 --> 00:42:36,039
reached 5 items and needs to go to 8

00:42:29,250 --> 00:42:39,460
entries we instead can only have 3 bytes

00:42:36,039 --> 00:42:42,160
left free because of the eight bytes up

00:42:39,460 --> 00:42:45,849
at the top that we have available to

00:42:42,160 --> 00:42:49,390
remember the indexes of our keys we're

00:42:45,849 --> 00:42:52,809
only using five we're leaving three

00:42:49,390 --> 00:42:54,789
empty and so three bytes wind up empty

00:42:52,809 --> 00:42:57,430
wasted and unused right before the

00:42:54,789 --> 00:43:02,079
dictionary is ready to resize rather

00:42:57,430 --> 00:43:05,019
than I was at 72 so the old dictionary

00:43:02,079 --> 00:43:07,930
had lots of extra space the new one

00:43:05,019 --> 00:43:10,779
packs all of the keys and values into a

00:43:07,930 --> 00:43:13,289
short list that it grows and if it

00:43:10,779 --> 00:43:15,579
doubles in size then it simply

00:43:13,289 --> 00:43:19,930
reallocates all of the keys in a

00:43:15,579 --> 00:43:22,089
contiguous area 2015 they added this to

00:43:19,930 --> 00:43:23,950
pi pi which is allowed to do crazy

00:43:22,089 --> 00:43:26,170
things to be more efficient it's

00:43:23,950 --> 00:43:28,359
interesting a few things sped up

00:43:26,170 --> 00:43:30,700
significantly and four percent eight

00:43:28,359 --> 00:43:32,859
percent gains some benchmarks slowdown

00:43:30,700 --> 00:43:34,539
because we added a level of indirection

00:43:32,859 --> 00:43:36,220
which is the problem of solving problems

00:43:34,539 --> 00:43:40,329
in computer science it can make things

00:43:36,220 --> 00:43:42,460
slower some things got slightly slower

00:43:40,329 --> 00:43:46,059
slightly faster with one or two big wins

00:43:42,460 --> 00:43:48,279
but the big reason for doing this wasn't

00:43:46,059 --> 00:43:50,950
speed it was actually exciting that the

00:43:48,279 --> 00:43:53,619
speed had barely changed adding an extra

00:43:50,950 --> 00:43:56,740
level of indexes because we got much

00:43:53,619 --> 00:43:58,720
better memory usage another year late

00:43:56,740 --> 00:44:01,779
past and normal Python people couldn't

00:43:58,720 --> 00:44:02,380
benefit and Inaba Naoki I don't think

00:44:01,779 --> 00:44:05,320
I've met

00:44:02,380 --> 00:44:08,740
opened an issue with a patch that added

00:44:05,320 --> 00:44:11,350
it to Python three-point the moment

00:44:08,740 --> 00:44:13,750
three point five something he pained a

00:44:11,350 --> 00:44:15,760
whole month went by no one addressed the

00:44:13,750 --> 00:44:17,320
issue he kind of pinged and they said oh

00:44:15,760 --> 00:44:19,240
this is big it would have to be

00:44:17,320 --> 00:44:22,090
addressed on Python dev which often

00:44:19,240 --> 00:44:24,100
means it's not going to happen and then

00:44:22,090 --> 00:44:27,310
in September something magic happened

00:44:24,100 --> 00:44:29,860
for the first time the core Dez got

00:44:27,310 --> 00:44:33,160
together all in a room by themselves for

00:44:29,860 --> 00:44:35,950
a few days and had a core dev sprint and

00:44:33,160 --> 00:44:38,320
at the end of that a message suddenly

00:44:35,950 --> 00:44:40,690
appeared on this moribund issue we

00:44:38,320 --> 00:44:45,820
discussed a lot about your compact dick

00:44:40,690 --> 00:44:48,430
change and we all wanted in 2.6 but the

00:44:45,820 --> 00:44:50,830
code isn't ready yet well let's just

00:44:48,430 --> 00:44:53,080
push it into Python 2.3 before the

00:44:50,830 --> 00:44:56,410
deadline this weekend and we'll fix it

00:44:53,080 --> 00:44:58,210
up later they wanted it that bad and of

00:44:56,410 --> 00:45:01,150
course predictably immediately someone

00:44:58,210 --> 00:45:03,280
said isn't this premature who wasn't on

00:45:01,150 --> 00:45:05,290
the group of core devs but no they'd

00:45:03,280 --> 00:45:09,190
spent like an entire day talking it out

00:45:05,290 --> 00:45:11,050
how this affected the future and it made

00:45:09,190 --> 00:45:14,560
it in in Python to six the new

00:45:11,050 --> 00:45:16,630
dictionary is much faster iterations

00:45:14,560 --> 00:45:20,680
faster there aren't empty spaces to have

00:45:16,630 --> 00:45:23,890
to go past and it remembers the order

00:45:20,680 --> 00:45:27,760
because that big table it's adding to

00:45:23,890 --> 00:45:31,120
it's a simple append can you now depend

00:45:27,760 --> 00:45:33,340
on the order is the big question because

00:45:31,120 --> 00:45:36,040
they went ahead and for free got to

00:45:33,340 --> 00:45:39,970
accept a pet asking the key word args be

00:45:36,040 --> 00:45:42,610
ordered and asking that clastic be

00:45:39,970 --> 00:45:45,100
ordered and that metaclass inputs be

00:45:42,610 --> 00:45:48,280
ordered all those uses for dictionaries

00:45:45,100 --> 00:45:50,950
that had wanted order now had them they

00:45:48,280 --> 00:45:53,410
think the core devs I think often think

00:45:50,950 --> 00:45:55,540
that they're just helping users who

00:45:53,410 --> 00:45:57,340
might notice that dictionaries are now

00:45:55,540 --> 00:46:01,060
ordered but if you look on Stack

00:45:57,340 --> 00:46:04,480
Overflow order isn't something that

00:46:01,060 --> 00:46:06,250
people are going to stumble across it's

00:46:04,480 --> 00:46:09,450
something they already expect

00:46:06,250 --> 00:46:13,330
dictionaries to have the human mind

00:46:09,450 --> 00:46:14,370
naturally by its nature expects

00:46:13,330 --> 00:46:15,720
dictionary

00:46:14,370 --> 00:46:18,090
to have order if you've ever taught

00:46:15,720 --> 00:46:20,550
Python this is always a stumbling block

00:46:18,090 --> 00:46:23,460
Raymond thinks the guarantee might be

00:46:20,550 --> 00:46:26,340
almost inevitable but Beasley says this

00:46:23,460 --> 00:46:28,520
is permanent and I agree with him I say

00:46:26,340 --> 00:46:40,020
three point six is brought about

00:46:28,520 --> 00:46:41,700
dictionaries for humans I don't think

00:46:40,020 --> 00:46:43,920
they're ever rolling this one back

00:46:41,700 --> 00:46:46,140
because the normal programmer who

00:46:43,920 --> 00:46:48,210
doesn't even know about hash tables has

00:46:46,140 --> 00:46:50,910
always expected them to be ordered and

00:46:48,210 --> 00:46:53,970
will write code that depends on it I end

00:46:50,910 --> 00:46:56,490
with the wish slightly modified that I

00:46:53,970 --> 00:46:57,300
ended my last talk with may your hashes

00:46:56,490 --> 00:47:01,500
be unique

00:46:57,300 --> 00:47:05,040
your keys rarely collide and your

00:47:01,500 --> 00:47:07,700
dictionaries be forever ordered thank

00:47:05,040 --> 00:47:07,700
you very much

00:47:12,740 --> 00:47:15,490
hmm

00:47:15,800 --> 00:47:17,860

YouTube URL: https://www.youtube.com/watch?v=66P5FMkWoVU


