Title: Raymond Hettinger   Modern Python Dictionaries    A confluence of a dozen great ideas   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Raymond Hettinger

Python's dictionaries are stunningly good.  Over the years,
many great ideas have combined together to produce the
modern implementation in Python 3.6.

This fun talk uses pictures and little bits of pure python
code to explain all of the key ideas and how they evolved
over time.

Includes newer features such as key-sharing, compaction, and versioning.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:00,000 --> 00:00:05,629
now welcome Raymond head and gun alright

00:00:10,400 --> 00:00:17,010
welcome to my talk a brief history of

00:00:14,160 --> 00:00:21,240
time by Steven I mean Raymond headings

00:00:17,010 --> 00:00:22,490
are in the beginning the dinosaurs

00:00:21,240 --> 00:00:25,949
roamed the earth

00:00:22,490 --> 00:00:28,650
they died in became extinct because of

00:00:25,949 --> 00:00:31,170
their inadequate capabilities in the

00:00:28,650 --> 00:00:34,649
void that they left behind the mammals

00:00:31,170 --> 00:00:37,230
arose and intelligent life came to this

00:00:34,649 --> 00:00:42,480
planet and we invented Python

00:00:37,230 --> 00:00:46,890
dictionaries any questions would you

00:00:42,480 --> 00:00:49,050
like a few more details alright so uh my

00:00:46,890 --> 00:00:53,160
name is uh Raymond heading to the theme

00:00:49,050 --> 00:00:56,760
of my talk is lots of smart people over

00:00:53,160 --> 00:00:59,550
time thought about the dictionary

00:00:56,760 --> 00:01:02,760
problem very very deeply came up with

00:00:59,550 --> 00:01:04,710
some ideas presented their ideas the

00:01:02,760 --> 00:01:07,080
world accepted them and thought we had

00:01:04,710 --> 00:01:09,240
good dictionaries then someone else came

00:01:07,080 --> 00:01:10,830
along thought about it very deeply and

00:01:09,240 --> 00:01:12,720
had another innovation and another

00:01:10,830 --> 00:01:14,970
innovation and I think what we have

00:01:12,720 --> 00:01:18,330
today is the confluence of about a dozen

00:01:14,970 --> 00:01:21,150
graded ideas that span the course of

00:01:18,330 --> 00:01:23,400
about fifty years and so I'd like to

00:01:21,150 --> 00:01:25,950
take you from the dinosaur era up to the

00:01:23,400 --> 00:01:28,110
present and then slightly into the

00:01:25,950 --> 00:01:30,030
future there are those of you who know

00:01:28,110 --> 00:01:31,560
nothing about hash tables you will know

00:01:30,030 --> 00:01:33,450
everything about hash tables shortly

00:01:31,560 --> 00:01:35,490
there are those of you who learned about

00:01:33,450 --> 00:01:36,450
hash tables in school now you'll learn

00:01:35,490 --> 00:01:38,430
how they're done in real

00:01:36,450 --> 00:01:40,619
industrial-strength production code

00:01:38,430 --> 00:01:43,590
there are those of you who already knew

00:01:40,619 --> 00:01:46,799
that but don't know what's what the

00:01:43,590 --> 00:01:49,079
latest innovations are in Python we have

00:01:46,799 --> 00:01:51,149
propelled the future quite a bit forward

00:01:49,079 --> 00:01:52,799
in the last few years and I'd like to

00:01:51,149 --> 00:01:55,320
take you on this journey to where I

00:01:52,799 --> 00:01:57,329
think is a somewhat magnificent I'd call

00:01:55,320 --> 00:01:59,219
it an ending point but evolution never

00:01:57,329 --> 00:02:03,479
ceases shall we begin

00:01:59,219 --> 00:02:06,090
all right so one little thing about me

00:02:03,479 --> 00:02:09,660
what is my mission in life it is to

00:02:06,090 --> 00:02:11,730
Train thousands of Python programmers I

00:02:09,660 --> 00:02:13,650
personally trained about 5,000

00:02:11,730 --> 00:02:15,780
programmers my company

00:02:13,650 --> 00:02:18,590
mutable minds Inc I have a team of

00:02:15,780 --> 00:02:19,950
trainers and we have trained about

00:02:18,590 --> 00:02:22,230
13,000 people

00:02:19,950 --> 00:02:26,040
cumulatively so if you have an interest

00:02:22,230 --> 00:02:32,220
in such things call me and let's begin

00:02:26,040 --> 00:02:37,590
all right our journey the beginning and

00:02:32,220 --> 00:02:45,480
the end let's do the overview first

00:02:37,590 --> 00:02:47,849
which is is do not reprogram your keys

00:02:45,480 --> 00:02:50,760
just prior to a presentation there you

00:02:47,849 --> 00:02:53,370
go so the importance of a Python is

00:02:50,760 --> 00:02:55,260
built around dictionaries Global's or

00:02:53,370 --> 00:02:57,269
dictionaries locals were at one time

00:02:55,260 --> 00:02:58,980
actually dictionaries modules have

00:02:57,269 --> 00:03:00,540
dictionaries classes have dictionaries

00:02:58,980 --> 00:03:02,790
instances have dictionaries they are

00:03:00,540 --> 00:03:04,019
central to the language which means that

00:03:02,790 --> 00:03:07,109
they use everywhere and they're pretty

00:03:04,019 --> 00:03:10,019
darn important one example is we have

00:03:07,109 --> 00:03:12,359
instances so we have a class and we have

00:03:10,019 --> 00:03:15,359
several instance variables and I've

00:03:12,359 --> 00:03:20,639
chosen cuido saraberry Rachel and Tim

00:03:15,359 --> 00:03:23,400
all important people of in my life and a

00:03:20,639 --> 00:03:26,910
Reppert to show them we've made a three

00:03:23,400 --> 00:03:29,040
instances a color a set of cities a set

00:03:26,910 --> 00:03:31,079
of fruits so that we know Quito's

00:03:29,040 --> 00:03:33,269
favorite color is blue this favorite

00:03:31,079 --> 00:03:35,639
city is Austin and his favorite fruit is

00:03:33,269 --> 00:03:37,829
Apple I just made all of it up and we

00:03:35,639 --> 00:03:40,650
can loop over the instances and print

00:03:37,829 --> 00:03:42,750
them out common place every day Python

00:03:40,650 --> 00:03:45,389
code what I'd like to do is look what's

00:03:42,750 --> 00:03:47,819
behind it and look what it looks like so

00:03:45,389 --> 00:03:50,970
behind each of these three instances is

00:03:47,819 --> 00:03:54,659
addiction instance dictionary courtesy

00:03:50,970 --> 00:04:00,120
make big button this is my favorite

00:03:54,659 --> 00:04:02,370
button there we go okay so we've got

00:04:00,120 --> 00:04:04,139
three dictionaries cuido blue and in the

00:04:02,370 --> 00:04:06,510
next one quito's Austin and the next one

00:04:04,139 --> 00:04:08,040
cuido is Apple and so that's a

00:04:06,510 --> 00:04:10,889
consequence of help I've done is design

00:04:08,040 --> 00:04:13,019
instances have dictionaries behind them

00:04:10,889 --> 00:04:14,879
so what we'd like to do is see how these

00:04:13,019 --> 00:04:17,639
dictionaries are implemented over

00:04:14,879 --> 00:04:20,489
various versions of Python jumping right

00:04:17,639 --> 00:04:22,919
to the end to see where we ended up

00:04:20,489 --> 00:04:24,930
after all the evolution in Python to

00:04:22,919 --> 00:04:26,490
seven one of these two each one of these

00:04:24,930 --> 00:04:27,510
dictionaries to two hundred and eighty

00:04:26,490 --> 00:04:29,310
bytes each

00:04:27,510 --> 00:04:32,040
and the ordering of the dictionary was

00:04:29,310 --> 00:04:35,220
Sara would go first and cuido would go

00:04:32,040 --> 00:04:38,550
last and that is deterministic it is

00:04:35,220 --> 00:04:40,950
repeatable in Python 2 7 and we uh the

00:04:38,550 --> 00:04:42,480
keys are scrambled we actually say

00:04:40,950 --> 00:04:45,930
arbitrary because they're not Reis

00:04:42,480 --> 00:04:49,770
cranville 2 every time in Python 3 5

00:04:45,930 --> 00:04:51,420
something said uh changed by 3 5 the

00:04:49,770 --> 00:04:54,320
size of the dictionary had gotten down

00:04:51,420 --> 00:04:57,240
to 196 bytes which is very nice a

00:04:54,320 --> 00:04:58,890
compaction and this time the keys are

00:04:57,240 --> 00:05:01,200
actually randomized so that every time

00:04:58,890 --> 00:05:03,890
you rerun it you get a different key

00:05:01,200 --> 00:05:07,110
order so they were no longer

00:05:03,890 --> 00:05:10,860
deterministic then Python 3 6 came out

00:05:07,110 --> 00:05:13,230
it's the size a little bit smaller 112

00:05:10,860 --> 00:05:16,260
bytes raw which is pretty darn amazing

00:05:13,230 --> 00:05:17,700
and the key order is now deterministic

00:05:16,260 --> 00:05:20,790
and it's the order that you added the

00:05:17,700 --> 00:05:21,720
keys because after all in the beginning

00:05:20,790 --> 00:05:24,180
there was cuido

00:05:21,720 --> 00:05:28,290
and from cuido came everything that you

00:05:24,180 --> 00:05:30,510
see around you okay so cuido goes first

00:05:28,290 --> 00:05:33,180
always the ruler of the kingdom in the

00:05:30,510 --> 00:05:36,150
ordered dictionaries in the Python 3 5 I

00:05:33,180 --> 00:05:37,710
universe he was just another Schmo once

00:05:36,150 --> 00:05:40,140
in a while he'd get to be a benevolent

00:05:37,710 --> 00:05:41,520
dictator once in a while the rest of us

00:05:40,140 --> 00:05:43,740
would get to tell him what to do in

00:05:41,520 --> 00:05:46,140
Python 2:7 he was always on the bottom

00:05:43,740 --> 00:05:49,590
of the list and I called Timmy took

00:05:46,140 --> 00:05:51,840
priority but now he always gets to be a

00:05:49,590 --> 00:05:53,850
king and so that's where we're going to

00:05:51,840 --> 00:05:57,300
end up at the end of our journey is with

00:05:53,850 --> 00:05:58,710
a smaller dictionaries that are ordered

00:05:57,300 --> 00:06:01,590
by the way how many of you like small

00:05:58,710 --> 00:06:03,630
and order dictionaries this is a fine

00:06:01,590 --> 00:06:06,350
thing it's one of a your reasons to want

00:06:03,630 --> 00:06:08,910
to upgrade to Python 3 6 straightaway

00:06:06,350 --> 00:06:10,980
I'm not going to say that I was a Python

00:06:08,910 --> 00:06:13,460
3 holdout because I've been working on

00:06:10,980 --> 00:06:17,130
making it better for about 8 years

00:06:13,460 --> 00:06:19,200
that's it I believe Python 361 is the

00:06:17,130 --> 00:06:21,270
first of the Python 3 series that's

00:06:19,200 --> 00:06:25,320
actually better in many many many

00:06:21,270 --> 00:06:27,300
respects it is very very very good it is

00:06:25,320 --> 00:06:29,480
now time to really push hard on other

00:06:27,300 --> 00:06:32,100
people to go ahead and just switch over

00:06:29,480 --> 00:06:34,470
when I step back 2 to 7 which was a

00:06:32,100 --> 00:06:36,720
nearly perfect Python it feels like a

00:06:34,470 --> 00:06:39,810
dinosaur to me and you'll see part of

00:06:36,720 --> 00:06:41,249
the reason why coming up so let's start

00:06:39,810 --> 00:06:46,589
back in time with

00:06:41,249 --> 00:06:48,809
the dinosaurs okay so the dinosaurs were

00:06:46,589 --> 00:06:53,309
our parents and our grandparents who

00:06:48,809 --> 00:06:57,439
have this bright idea of using databases

00:06:53,309 --> 00:07:01,019
and in a database we had a rows and

00:06:57,439 --> 00:07:02,699
columns and the columns were each fields

00:07:01,019 --> 00:07:06,779
the name the color the city and the

00:07:02,699 --> 00:07:08,669
fruit now our forefathers were entirely

00:07:06,779 --> 00:07:11,249
clueless they came up the bright idea of

00:07:08,669 --> 00:07:13,829
indexing into this database so that you

00:07:11,249 --> 00:07:17,309
could do quick lookups for a berry but

00:07:13,829 --> 00:07:19,229
clearly our ancestors our parents and

00:07:17,309 --> 00:07:21,749
grandparents had no idea what they were

00:07:19,229 --> 00:07:23,249
doing back in the 1960s when they made

00:07:21,749 --> 00:07:26,699
databases like this I should actually

00:07:23,249 --> 00:07:30,749
say early 70s this design was from EF

00:07:26,699 --> 00:07:32,819
Cod in 1970 who announced onto the world

00:07:30,749 --> 00:07:37,289
all at once relational database theory

00:07:32,819 --> 00:07:39,809
so this is the state of the art in 1970

00:07:37,289 --> 00:07:41,729
the dinosaurs who died and became stink

00:07:39,809 --> 00:07:44,099
because their skills were inadequate in

00:07:41,729 --> 00:07:46,919
comparison to our awesome skills of

00:07:44,099 --> 00:07:50,629
today their parents were unequal to us

00:07:46,919 --> 00:07:55,189
they would shiver to see our modern cook

00:07:50,629 --> 00:07:57,299
just saying this we all know is true

00:07:55,189 --> 00:08:01,589
programming has advanced dramatically

00:07:57,299 --> 00:08:05,099
over 50 years do you believe me it was a

00:08:01,589 --> 00:08:07,999
trick question do you believe me do you

00:08:05,099 --> 00:08:11,309
believe me it's a trick question

00:08:07,999 --> 00:08:13,799
no okay so I've got a little setup here

00:08:11,309 --> 00:08:16,110
I've got some keys and values three sets

00:08:13,799 --> 00:08:18,329
of values I create a list of hashes a

00:08:16,110 --> 00:08:20,759
list of entries and combined entries

00:08:18,329 --> 00:08:22,799
that have the keys hashes and values

00:08:20,759 --> 00:08:25,679
these would be the data structures that

00:08:22,799 --> 00:08:27,719
I use to the rest of a talk so what is

00:08:25,679 --> 00:08:29,749
the database way of solving the problem

00:08:27,719 --> 00:08:33,209
in Python we would represent it as a

00:08:29,749 --> 00:08:35,519
list of tuples the problem with this is

00:08:33,209 --> 00:08:37,979
we have to do a linear search and so as

00:08:35,519 --> 00:08:40,050
it starts to scale the performance is

00:08:37,979 --> 00:08:42,149
really bad interestingly compared to

00:08:40,050 --> 00:08:44,850
modern dictionaries once you get to a

00:08:42,149 --> 00:08:47,370
list of size two you were not as good as

00:08:44,850 --> 00:08:48,899
a dictionary so we tend to think of

00:08:47,370 --> 00:08:50,699
scaling following 400 if you've got a

00:08:48,899 --> 00:08:52,800
million entries or dictionaries would be

00:08:50,699 --> 00:08:55,140
better but typically it's about two or

00:08:52,800 --> 00:08:57,570
three when dictionaries start

00:08:55,140 --> 00:09:01,500
win which is pretty amazing I know what

00:08:57,570 --> 00:09:05,060
you're thinking oh that was a trick -

00:09:01,500 --> 00:09:09,120
there must be a worse way than this

00:09:05,060 --> 00:09:11,250
there is unto them was born a crazy

00:09:09,120 --> 00:09:14,160
group of people notice list programmers

00:09:11,250 --> 00:09:17,250
and the saying was a list programmer

00:09:14,160 --> 00:09:19,470
knows the the value of everything and

00:09:17,250 --> 00:09:22,080
the price of nothing so a list

00:09:19,470 --> 00:09:24,300
programmer would does store what we're

00:09:22,080 --> 00:09:29,760
called association lists the key value

00:09:24,300 --> 00:09:31,200
pairs so in this case we have a list of

00:09:29,760 --> 00:09:33,360
tuples each one of them needs to be

00:09:31,200 --> 00:09:36,210
searched independently but you can see

00:09:33,360 --> 00:09:38,730
there's there's a linear search for each

00:09:36,210 --> 00:09:41,430
of these and we have multiple lists and

00:09:38,730 --> 00:09:44,280
there's redundancy inside wasting space

00:09:41,430 --> 00:09:46,230
like crazy like Lisp programmers are

00:09:44,280 --> 00:09:48,900
want to do just saying

00:09:46,230 --> 00:09:50,550
remember the dinosaurs are parents and

00:09:48,900 --> 00:09:52,230
grandparents were crazy people and

00:09:50,550 --> 00:09:56,220
didn't know all of the things that we

00:09:52,230 --> 00:09:58,590
know today that was a trick all right so

00:09:56,220 --> 00:10:00,540
what was the first innovation after the

00:09:58,590 --> 00:10:02,640
dinosaurs died off it was called

00:10:00,540 --> 00:10:05,190
separate training and the idea is

00:10:02,640 --> 00:10:07,620
instead of doing a linear search of a

00:10:05,190 --> 00:10:11,190
big list how about do smaller linear

00:10:07,620 --> 00:10:13,980
searches of smaller lists so the idea is

00:10:11,190 --> 00:10:16,020
take out that one big list we had before

00:10:13,980 --> 00:10:18,810
and divide it into two this is list

00:10:16,020 --> 00:10:21,270
number one and list number two now if

00:10:18,810 --> 00:10:23,310
you search list number one you either

00:10:21,270 --> 00:10:26,490
get one probe to find cuido or two

00:10:23,310 --> 00:10:29,310
probes to find quit Tim one for Sara

00:10:26,490 --> 00:10:32,790
two for Barry and three for Rachel this

00:10:29,310 --> 00:10:34,710
double sub performance of the lookups as

00:10:32,790 --> 00:10:36,750
long as you know which bucket to look in

00:10:34,710 --> 00:10:38,460
and you know which bucket to look in by

00:10:36,750 --> 00:10:40,710
hashing if somebody asks you for a

00:10:38,460 --> 00:10:43,320
simple summary of what hashing is it is

00:10:40,710 --> 00:10:45,030
reducing the size of the search space so

00:10:43,320 --> 00:10:47,570
if I was doing a linear search of this

00:10:45,030 --> 00:10:50,880
room I would have to go through 600

00:10:47,570 --> 00:10:53,100
people but if I know which cluster

00:10:50,880 --> 00:10:55,590
you're in cluster 1 cluster 2 or cluster

00:10:53,100 --> 00:10:59,430
3 I could search cut the search space by

00:10:55,590 --> 00:11:01,590
a factor of 3 easy enough that say one

00:10:59,430 --> 00:11:03,540
or two-sentence elevator pitch for hash

00:11:01,590 --> 00:11:06,150
tables what is a hash table something

00:11:03,540 --> 00:11:08,390
that reduces the search space by cutting

00:11:06,150 --> 00:11:10,040
it into smaller clusters which are

00:11:08,390 --> 00:11:14,050
or traditionally named buckets when

00:11:10,040 --> 00:11:14,050
talking about separate to a chaining

00:11:14,230 --> 00:11:20,120
this time it's better way okay there is

00:11:17,510 --> 00:11:22,310
a better way if two buckets is good four

00:11:20,120 --> 00:11:24,200
buckets would be even better so now I

00:11:22,310 --> 00:11:26,330
have four buckets and what's cool about

00:11:24,200 --> 00:11:28,580
that is the more buckets you have the

00:11:26,330 --> 00:11:30,470
more you produce the search so we have

00:11:28,580 --> 00:11:33,020
now for people who are found with one

00:11:30,470 --> 00:11:35,720
probe and Barry is a hash collision and

00:11:33,020 --> 00:11:37,760
it takes a second probe to find him so

00:11:35,720 --> 00:11:40,550
that means that on average the weighted

00:11:37,760 --> 00:11:43,910
number of probes across these of five

00:11:40,550 --> 00:11:45,890
people is 1.2 probes that's pretty darn

00:11:43,910 --> 00:11:47,480
good it's like most of the time you look

00:11:45,890 --> 00:11:49,280
for something it's always in the first

00:11:47,480 --> 00:11:51,670
place you look rather than in the last

00:11:49,280 --> 00:11:56,330
place pretty awesome

00:11:51,670 --> 00:11:56,900
if four buckets would be good what would

00:11:56,330 --> 00:11:59,840
be better

00:11:56,900 --> 00:12:02,060
eight buckets now eight buckets is kind

00:11:59,840 --> 00:12:04,700
of interesting we actually still end up

00:12:02,060 --> 00:12:06,410
with a collision cuido and Rachael are

00:12:04,700 --> 00:12:08,240
in the same bucket for these by the way

00:12:06,410 --> 00:12:10,100
these I've run actual code behind this

00:12:08,240 --> 00:12:12,980
so these are literally where the

00:12:10,100 --> 00:12:15,500
collisions are and using Python to seven

00:12:12,980 --> 00:12:17,990
hashing but if I get the buckets big

00:12:15,500 --> 00:12:19,700
enough eventually everybody will be in

00:12:17,990 --> 00:12:21,470
their own bucket which means I will find

00:12:19,700 --> 00:12:24,290
them right away the number of lookups is

00:12:21,470 --> 00:12:26,510
exactly one this is dramatically better

00:12:24,290 --> 00:12:29,270
than linear searching so does this sound

00:12:26,510 --> 00:12:31,280
like a really great idea I think so too

00:12:29,270 --> 00:12:33,920
but you'll notice little bits of wasted

00:12:31,280 --> 00:12:36,590
space in there but in exchange for

00:12:33,920 --> 00:12:39,620
wasted space you get very fast lookup

00:12:36,590 --> 00:12:41,390
this is the advantage of sparsity the

00:12:39,620 --> 00:12:43,370
problem is is this dictionary gets

00:12:41,390 --> 00:12:50,210
bigger and bigger even with size eight

00:12:43,370 --> 00:12:54,380
with eight buckets in 2000 and rive this

00:12:50,210 --> 00:12:55,940
computer here we go with eight buckets I

00:12:54,380 --> 00:12:57,710
put two thousand entries in it

00:12:55,940 --> 00:13:00,470
the average chain would it be about of

00:12:57,710 --> 00:13:04,280
length 250 and so as the dictionary gets

00:13:00,470 --> 00:13:08,660
slows down or as it gets bigger it slows

00:13:04,280 --> 00:13:11,810
down in fact there is a better way the

00:13:08,660 --> 00:13:13,670
solution is to periodically resize the

00:13:11,810 --> 00:13:15,740
dictionary so that's never more than

00:13:13,670 --> 00:13:18,710
two-thirds full essentially we copy out

00:13:15,740 --> 00:13:21,769
all the key value pairs then we loop

00:13:18,710 --> 00:13:23,239
back I set up a glutton

00:13:21,769 --> 00:13:25,160
bigger number of buckets than we had

00:13:23,239 --> 00:13:27,410
before and then we reinsert it

00:13:25,160 --> 00:13:29,809
so whenever eight buckets is not enough

00:13:27,410 --> 00:13:32,360
go and make sixteen buckets after

00:13:29,809 --> 00:13:34,220
sixteen buckets 32 and that way no

00:13:32,360 --> 00:13:36,160
matter how big the dictionary gets it

00:13:34,220 --> 00:13:38,449
retains its performance pretty awesome

00:13:36,160 --> 00:13:40,459
these some people in the beginning were

00:13:38,449 --> 00:13:43,069
thinkers and this is the way they teach

00:13:40,459 --> 00:13:44,959
it to you in school but they leave a lot

00:13:43,069 --> 00:13:46,519
of important things out in school like

00:13:44,959 --> 00:13:49,929
here's an important thing that you

00:13:46,519 --> 00:13:53,290
typically don't find in the textbooks

00:13:49,929 --> 00:13:56,749
which is that we cache the hash value

00:13:53,290 --> 00:13:58,279
the idea is instead of this narrow table

00:13:56,749 --> 00:14:01,939
up above we're going to add an

00:13:58,279 --> 00:14:03,860
additional column to it and that is to

00:14:01,939 --> 00:14:06,619
actually store the full hash value

00:14:03,860 --> 00:14:08,059
inside at first this appears crazy why

00:14:06,619 --> 00:14:11,749
do you need a hash value when you're

00:14:08,059 --> 00:14:13,999
inside the hash table well the problem

00:14:11,749 --> 00:14:16,399
is when you resize you have to go rehash

00:14:13,999 --> 00:14:18,619
every key and potentially hashing is

00:14:16,399 --> 00:14:20,389
very expensive for a key and you don't

00:14:18,619 --> 00:14:22,519
want to do it again the solution to the

00:14:20,389 --> 00:14:25,220
problem is cache it so we save it inside

00:14:22,519 --> 00:14:27,589
at that point the resize code becomes a

00:14:25,220 --> 00:14:29,929
little simpler it says loop over our

00:14:27,589 --> 00:14:33,230
keys and values and the known hash value

00:14:29,929 --> 00:14:35,689
and then reinsert it back into the new

00:14:33,230 --> 00:14:38,119
bucket in a larger bigger table

00:14:35,689 --> 00:14:41,029
so this is by the way this stuff is not

00:14:38,119 --> 00:14:43,339
pseudocode it all runs and I'll give you

00:14:41,029 --> 00:14:45,079
links to it although in the end I'll

00:14:43,339 --> 00:14:46,519
combine it together into one big recipe

00:14:45,079 --> 00:14:48,290
and hand it to everybody so that you can

00:14:46,519 --> 00:14:52,069
play with all of these things and the

00:14:48,290 --> 00:14:53,420
idea is in textbooks you don't see this

00:14:52,069 --> 00:14:55,730
because it isn't essential to the

00:14:53,420 --> 00:14:58,160
algorithm and it makes it use up extra

00:14:55,730 --> 00:15:00,860
space do you see this third column here

00:14:58,160 --> 00:15:04,040
okay so extra space but it makes sense

00:15:00,860 --> 00:15:05,990
is very very cheap I'm astonished by

00:15:04,040 --> 00:15:08,449
this even though I'm one of the

00:15:05,990 --> 00:15:10,790
maintainer zuv this code when I timed it

00:15:08,449 --> 00:15:12,919
I found that resizing a dictionary is

00:15:10,790 --> 00:15:15,410
about one-fifth as fast as a list copy

00:15:12,919 --> 00:15:15,949
it is essentially running at the speed

00:15:15,410 --> 00:15:18,139
of copy

00:15:15,949 --> 00:15:20,629
it makes no calls to equality it makes

00:15:18,139 --> 00:15:22,730
no calls to hash it essentially just

00:15:20,629 --> 00:15:25,220
says what is my current hash take it

00:15:22,730 --> 00:15:27,259
modulo some power of two and reinsert it

00:15:25,220 --> 00:15:29,509
into a new table and loops over the

00:15:27,259 --> 00:15:32,299
existing keys it's incredibly fast

00:15:29,509 --> 00:15:34,970
almost as fast as copying a list of keys

00:15:32,299 --> 00:15:35,930
who thinks that's kind of cool which is

00:15:34,970 --> 00:15:39,110
why we use

00:15:35,930 --> 00:15:41,480
this extra column all right so the next

00:15:39,110 --> 00:15:42,680
step up is faster matching this is

00:15:41,480 --> 00:15:45,260
something that they don't teach in

00:15:42,680 --> 00:15:48,080
school as well in school they say loop

00:15:45,260 --> 00:15:51,020
over the keys until you find a match if

00:15:48,080 --> 00:15:53,210
you don't find a match raise a key herb

00:15:51,020 --> 00:15:55,730
the problem is how do you know whether a

00:15:53,210 --> 00:16:00,320
keys matched you do an equality test

00:15:55,730 --> 00:16:01,880
does the key equal the target key that

00:16:00,320 --> 00:16:02,870
makes a lot of sense in textbooks

00:16:01,880 --> 00:16:04,960
because the thing that they're looking

00:16:02,870 --> 00:16:07,520
for is typically a number or something

00:16:04,960 --> 00:16:09,950
like that so equality tests are very

00:16:07,520 --> 00:16:12,440
cheap but in object-oriented languages

00:16:09,950 --> 00:16:13,430
any object can define a tender EQ that's

00:16:12,440 --> 00:16:16,010
very expensive

00:16:13,430 --> 00:16:18,200
for instance comparing two decimal

00:16:16,010 --> 00:16:19,790
objects involves a lot of steps because

00:16:18,200 --> 00:16:22,400
we have to line up the number of decimal

00:16:19,790 --> 00:16:25,250
places first it's not a just a direct

00:16:22,400 --> 00:16:27,170
comparison of values and so a lot of

00:16:25,250 --> 00:16:28,760
work can be done there potentially if

00:16:27,170 --> 00:16:30,500
you have a database record you have to

00:16:28,760 --> 00:16:32,570
compare every one of the fields in order

00:16:30,500 --> 00:16:35,030
to determine that their equality the

00:16:32,570 --> 00:16:36,920
mall is in an object-oriented language

00:16:35,030 --> 00:16:40,040
you can't assume that equality is fast

00:16:36,920 --> 00:16:41,840
it can be very very very slow and if

00:16:40,040 --> 00:16:45,020
it's slow you want to do it all the time

00:16:41,840 --> 00:16:47,590
or do you want to avoid it I would avoid

00:16:45,020 --> 00:16:50,900
it and so there's two fast early outs

00:16:47,590 --> 00:16:54,110
one of them is this notion that identity

00:16:50,900 --> 00:16:56,300
implies equality if we have two pointers

00:16:54,110 --> 00:16:58,220
to the same object two variable names

00:16:56,300 --> 00:16:59,810
pointing to identically the same object

00:16:58,220 --> 00:17:02,300
we don't even have to look at the object

00:16:59,810 --> 00:17:05,330
to know that they're equal you are equal

00:17:02,300 --> 00:17:07,910
to you doesn't that seem obvious to you

00:17:05,330 --> 00:17:10,670
if two there's two pointers to the same

00:17:07,910 --> 00:17:11,860
object it's the same object serve what's

00:17:10,670 --> 00:17:15,650
your name

00:17:11,860 --> 00:17:17,750
I'll Christian a person on the front row

00:17:15,650 --> 00:17:20,600
on the far right side what's your name

00:17:17,750 --> 00:17:22,490
oh I had two references to the same

00:17:20,600 --> 00:17:24,260
object did I have to ask him both time

00:17:22,490 --> 00:17:26,089
or if I knew the references were the

00:17:24,260 --> 00:17:27,080
same did I even have to ask to know it

00:17:26,089 --> 00:17:30,740
was the same guy

00:17:27,080 --> 00:17:32,240
identity implies equality it's a person

00:17:30,740 --> 00:17:34,040
sitting in that person sitting in that

00:17:32,240 --> 00:17:36,140
chair is the person who's sitting in

00:17:34,040 --> 00:17:38,510
that chair regardless of how I refer to

00:17:36,140 --> 00:17:41,650
other chair does that seem logical and

00:17:38,510 --> 00:17:43,730
obvious to you it does interestingly

00:17:41,650 --> 00:17:46,440
everything in the Python world is the

00:17:43,730 --> 00:17:50,320
subject of contentious debate

00:17:46,440 --> 00:17:52,780
in the world of floating-point numbers

00:17:50,320 --> 00:17:56,500
is the concept of an and not a number

00:17:52,780 --> 00:17:59,440
and the I Triple E 754 specification of

00:17:56,500 --> 00:18:01,420
Nan's defines Nan's is not being equal

00:17:59,440 --> 00:18:03,370
to themselves are you equal to yourself

00:18:01,420 --> 00:18:05,620
of course you are because you're not an

00:18:03,370 --> 00:18:08,830
an but if you were an an it would say no

00:18:05,620 --> 00:18:11,020
and so there's this thought that

00:18:08,830 --> 00:18:13,420
dictionaries break man's because if you

00:18:11,020 --> 00:18:15,040
use one as a key then we go back and we

00:18:13,420 --> 00:18:15,640
say oh I found that Keynes is I'm not

00:18:15,040 --> 00:18:19,060
really me

00:18:15,640 --> 00:18:21,160
at which point if a person who is a

00:18:19,060 --> 00:18:22,750
die-hard for Nan's let's say a Dan

00:18:21,160 --> 00:18:24,010
should not be look up a bull he should

00:18:22,750 --> 00:18:27,400
be able to put it in a dictionary but

00:18:24,010 --> 00:18:30,970
you'd never be able to find it later and

00:18:27,400 --> 00:18:35,890
then they hold up the specification I

00:18:30,970 --> 00:18:39,450
Triple E 754 arithmetic what what do I

00:18:35,890 --> 00:18:41,860
have that can trump an I Triple E 754

00:18:39,450 --> 00:18:43,780
specification something of greater

00:18:41,860 --> 00:18:47,500
weight than that something we care about

00:18:43,780 --> 00:18:49,030
more sin of Python I hold up the Zen a

00:18:47,500 --> 00:18:51,700
Python monkey oh okay me I say

00:18:49,030 --> 00:18:53,110
practicality beats purity if you put

00:18:51,700 --> 00:18:56,860
something in a dictionary and can't get

00:18:53,110 --> 00:18:58,750
it back out that's very impractical it's

00:18:56,860 --> 00:19:01,300
generally a bad thing it makes it

00:18:58,750 --> 00:19:03,400
impossible to reason about the container

00:19:01,300 --> 00:19:04,930
and if I make identity I implies the

00:19:03,400 --> 00:19:06,640
quality I can make dictionaries very

00:19:04,930 --> 00:19:08,290
fast if you want dictionaries that are

00:19:06,640 --> 00:19:11,170
fast and practical or do you want one

00:19:08,290 --> 00:19:14,650
that is makes it so you can put Nan's in

00:19:11,170 --> 00:19:16,690
and show your mama cute trick okay so I

00:19:14,650 --> 00:19:19,870
fight it with practicality beats purity

00:19:16,690 --> 00:19:21,940
periodically though once a year somebody

00:19:19,870 --> 00:19:23,680
comes back up and posts I put an in in a

00:19:21,940 --> 00:19:24,040
dictionary and later I was able to find

00:19:23,680 --> 00:19:26,830
it

00:19:24,040 --> 00:19:28,570
this is terrible and I have to fight the

00:19:26,830 --> 00:19:30,670
battle once again I'm afraid if I ever

00:19:28,570 --> 00:19:32,800
retire from Python core development this

00:19:30,670 --> 00:19:34,300
will disappear people will be able to

00:19:32,800 --> 00:19:38,260
put things in dictionaries and not get

00:19:34,300 --> 00:19:40,390
them back out and say I Triple E 754 and

00:19:38,260 --> 00:19:43,390
uncle Timmy would come back and haunt

00:19:40,390 --> 00:19:46,390
them from his grave at that time all

00:19:43,390 --> 00:19:49,810
right there is a the way hash tables

00:19:46,390 --> 00:19:51,940
work is I group all of you into clusters

00:19:49,810 --> 00:19:54,280
and I only have to search that cluster

00:19:51,940 --> 00:19:56,110
for you but if I'm mistaken about which

00:19:54,280 --> 00:19:56,680
cluster you're in I'm never going to

00:19:56,110 --> 00:19:58,630
find you

00:19:56,680 --> 00:20:00,130
this is cluster one closer to and

00:19:58,630 --> 00:20:02,020
cluster 3 if

00:20:00,130 --> 00:20:05,110
I go to look for you and cluster1 I'm

00:20:02,020 --> 00:20:07,180
not going to find you so we have a what

00:20:05,110 --> 00:20:09,190
is known as a hash invariant all hash

00:20:07,180 --> 00:20:10,870
tables require this if two objects are

00:20:09,190 --> 00:20:13,330
equal to each other then they have to

00:20:10,870 --> 00:20:15,310
have the same hash they have to be in

00:20:13,330 --> 00:20:17,200
the same cluster so that we can go find

00:20:15,310 --> 00:20:19,360
an object equal to that object does that

00:20:17,200 --> 00:20:21,370
make sense now I'm going to get

00:20:19,360 --> 00:20:23,430
mathematical and logical onion-like dr.

00:20:21,370 --> 00:20:27,970
Sheldon Cooper from the Big Bang Theory

00:20:23,430 --> 00:20:30,550
we will use modus tollens logics and I

00:20:27,970 --> 00:20:34,180
will express the contrapositive of this

00:20:30,550 --> 00:20:36,550
statement that's where you switch the if

00:20:34,180 --> 00:20:38,230
and the then and negate the bin it's

00:20:36,550 --> 00:20:40,600
called denying the antecedent the

00:20:38,230 --> 00:20:42,670
contact causative says if two objects

00:20:40,600 --> 00:20:44,800
have caches that are unequal if you were

00:20:42,670 --> 00:20:46,480
in two different clusters didn't means

00:20:44,800 --> 00:20:48,610
that you're not the same person you're

00:20:46,480 --> 00:20:50,140
not equal to each other so we flip it

00:20:48,610 --> 00:20:52,030
around to the contrapositive and it

00:20:50,140 --> 00:20:55,150
gives us a fast match algorithm

00:20:52,030 --> 00:20:57,430
internally dictionaries and sets he's a

00:20:55,150 --> 00:20:59,650
fast match first of all they check for

00:20:57,430 --> 00:21:01,930
identity are the two objects sitting in

00:20:59,650 --> 00:21:03,940
the same chair if the answer is yes we

00:21:01,930 --> 00:21:06,520
assume that they're equal identity

00:21:03,940 --> 00:21:09,130
implies equality this is extremely fast

00:21:06,520 --> 00:21:10,840
it's just a pointer comparison the next

00:21:09,130 --> 00:21:12,550
thing is we already know the hash of the

00:21:10,840 --> 00:21:16,450
object and we already know the hash

00:21:12,550 --> 00:21:18,580
stored in the hash table as a result of

00:21:16,450 --> 00:21:20,230
that if the hashes aren't equal we don't

00:21:18,580 --> 00:21:22,240
even have to test them for equality we

00:21:20,230 --> 00:21:25,270
know that they are not equal to each

00:21:22,240 --> 00:21:27,640
other and then all finally we have the

00:21:25,270 --> 00:21:29,980
slow test if these two early outs don't

00:21:27,640 --> 00:21:34,060
work we finally have to do an equality

00:21:29,980 --> 00:21:36,700
test too fast early out in front of a a

00:21:34,060 --> 00:21:39,400
slow test if you knock these two lines

00:21:36,700 --> 00:21:41,950
out of Python it cuts its speed by more

00:21:39,400 --> 00:21:44,260
than half these lines kind of important

00:21:41,950 --> 00:21:45,340
so you like identity applies in quality

00:21:44,260 --> 00:21:47,530
and you're not going to file a bug

00:21:45,340 --> 00:21:51,730
report about I Triple E 754 he says the

00:21:47,530 --> 00:21:57,070
world's not safe for Nan's I see how it

00:21:51,730 --> 00:21:59,110
is that is an interesting test this one

00:21:57,070 --> 00:22:01,000
though I've known about for very long

00:21:59,110 --> 00:22:02,560
time the full impact of it though didn't

00:22:01,000 --> 00:22:06,280
hit me until we started going to go to

00:22:02,560 --> 00:22:08,170
the 64-bit world what are the odds that

00:22:06,280 --> 00:22:09,760
two hashes are going to be equal to each

00:22:08,170 --> 00:22:13,000
other and the objects are not going to

00:22:09,760 --> 00:22:13,750
be equal to each other the answer is one

00:22:13,000 --> 00:22:17,110
and two

00:22:13,750 --> 00:22:21,100
the 64 that means that our with this

00:22:17,110 --> 00:22:23,170
test in place we never well almost never

00:22:21,100 --> 00:22:25,330
like never in your lifetime are in the

00:22:23,170 --> 00:22:27,730
lifetime of the universe we will never

00:22:25,330 --> 00:22:29,500
have a case where the key is equal to

00:22:27,730 --> 00:22:31,840
the target key we never do an

00:22:29,500 --> 00:22:34,120
unnecessary quality J so every

00:22:31,840 --> 00:22:36,790
dictionary and set lookup if it finds a

00:22:34,120 --> 00:22:39,070
match does exactly one equality test

00:22:36,790 --> 00:22:42,130
even if there are collisions who thinks

00:22:39,070 --> 00:22:43,930
that's kind of cool these odds are so

00:22:42,130 --> 00:22:46,420
great that I conducted an interesting

00:22:43,930 --> 00:22:49,750
and funky experiment I replace this line

00:22:46,420 --> 00:22:52,450
in Python with return true which said if

00:22:49,750 --> 00:22:54,880
the hashes are equal just assume they're

00:22:52,450 --> 00:22:56,020
the same object interestingly the entire

00:22:54,880 --> 00:22:59,200
test suite passed

00:22:56,020 --> 00:23:02,020
Django's test suite past numpy test

00:22:59,200 --> 00:23:04,390
suite pass in other words this is a very

00:23:02,020 --> 00:23:05,980
very very good at something how many of

00:23:04,390 --> 00:23:07,780
you think it would be safe if I just

00:23:05,980 --> 00:23:10,900
took out the Equality test and said if

00:23:07,780 --> 00:23:12,310
you don't think it'd be safe how many of

00:23:10,900 --> 00:23:13,930
you think it would be unsafe

00:23:12,310 --> 00:23:19,420
if I were to just take this slowly

00:23:13,930 --> 00:23:20,620
quality test out entirely really a lot

00:23:19,420 --> 00:23:22,300
of you think it would be in safe now

00:23:20,620 --> 00:23:25,080
I've got another poll question how many

00:23:22,300 --> 00:23:25,080
of you use git

00:23:26,500 --> 00:23:31,450
it does exactly this when it compares

00:23:29,410 --> 00:23:33,370
files it doesn't look at the file if the

00:23:31,450 --> 00:23:35,200
hashes are equal it believes that they

00:23:33,370 --> 00:23:38,320
are the same this is a really good idea

00:23:35,200 --> 00:23:40,120
until sha-1 started to look kind of weak

00:23:38,320 --> 00:23:42,400
of all eight so they're actively working

00:23:40,120 --> 00:23:44,710
on switching from sha-1 to a different

00:23:42,400 --> 00:23:48,040
hash where a person can't produce a

00:23:44,710 --> 00:23:49,840
collision easily on purpose all right so

00:23:48,040 --> 00:23:52,480
all of this was great but there's a

00:23:49,840 --> 00:23:56,680
problem separate chaining takes a great

00:23:52,480 --> 00:23:59,110
deal of a space by having all the

00:23:56,680 --> 00:24:01,990
pointers to many separate lists so

00:23:59,110 --> 00:24:03,790
what's the solution the solution is make

00:24:01,990 --> 00:24:06,220
the table more dense get rid of all the

00:24:03,790 --> 00:24:08,560
pointers and put all the buckets in one

00:24:06,220 --> 00:24:10,480
table the downside of this is you

00:24:08,560 --> 00:24:13,360
introduce a risk of collisions and the

00:24:10,480 --> 00:24:16,990
solution to it is using a linear probing

00:24:13,360 --> 00:24:19,390
so this is a pure Python code for doing

00:24:16,990 --> 00:24:22,300
linear probing it says look in position

00:24:19,390 --> 00:24:25,090
I and check to see if you found the

00:24:22,300 --> 00:24:27,370
value that you needed if not go switch

00:24:25,090 --> 00:24:28,930
to the next location and look there and

00:24:27,370 --> 00:24:31,840
look in the next place in the next place

00:24:28,930 --> 00:24:33,460
in the next place so with open

00:24:31,840 --> 00:24:36,520
addressing here's what the table looks

00:24:33,460 --> 00:24:38,740
like interestingly Kim was supposed to

00:24:36,520 --> 00:24:40,720
go in Sarah's slot but because it was

00:24:38,740 --> 00:24:44,230
already occupied he went to the next

00:24:40,720 --> 00:24:46,150
slot wrapping it around how this greatly

00:24:44,230 --> 00:24:49,240
improves the density of the table pretty

00:24:46,150 --> 00:24:53,230
good idea it is except for one problem

00:24:49,240 --> 00:24:56,830
later if we delete Sarah from the list

00:24:53,230 --> 00:24:59,740
Tim becomes unfindable by the way is Tim

00:24:56,830 --> 00:25:02,010
Peters here oh that's because Sarah got

00:24:59,740 --> 00:25:02,010
deleted

00:25:03,310 --> 00:25:09,200
in fact there is a better way

00:25:06,530 --> 00:25:11,540
the problem is removing a key leaves a

00:25:09,200 --> 00:25:15,200
hole the solution is to mark that with a

00:25:11,540 --> 00:25:17,900
dummy entry and the dummy entry says

00:25:15,200 --> 00:25:19,490
this space was used by some key when

00:25:17,900 --> 00:25:21,310
you're searching go ahead and skip past

00:25:19,490 --> 00:25:24,050
this and keep on looking until you find

00:25:21,310 --> 00:25:27,590
uncle Timmy and here's the pure Python

00:25:24,050 --> 00:25:31,910
code for that and you can see we are the

00:25:27,590 --> 00:25:33,770
idea is wow I'm going to speed up is it

00:25:31,910 --> 00:25:37,370
truly 15 to 15 minutes till questions

00:25:33,770 --> 00:25:40,610
are okay how many time people walk out

00:25:37,370 --> 00:25:43,940
the door 20 all right good enough

00:25:40,610 --> 00:25:46,100
all right so free slot is we track to

00:25:43,940 --> 00:25:48,860
see if we found any dummies as we do the

00:25:46,100 --> 00:25:52,340
search if we find a dummy we remember

00:25:48,860 --> 00:25:54,200
where it is later if we find a hole in

00:25:52,340 --> 00:25:56,150
the table will go back instead of using

00:25:54,200 --> 00:25:58,520
the hole we'll use the original free

00:25:56,150 --> 00:26:01,640
slot the the dummy that we found and let

00:25:58,520 --> 00:26:03,770
lets us all reuse the slots on the other

00:26:01,640 --> 00:26:05,840
hand if we find a key we can use that

00:26:03,770 --> 00:26:07,910
fast match that we just discussed with

00:26:05,840 --> 00:26:10,400
identity will apply quality in the hash

00:26:07,910 --> 00:26:11,900
table check in order to do a quick check

00:26:10,400 --> 00:26:14,660
and this is the core logic for

00:26:11,900 --> 00:26:17,360
dictionaries this is known as Knuth

00:26:14,660 --> 00:26:20,240
algorithm d and it was known right at

00:26:17,360 --> 00:26:21,650
the end of the 1960's it appears in the

00:26:20,240 --> 00:26:23,630
art of computer programming

00:26:21,650 --> 00:26:25,990
turns out our grandparents knew a thing

00:26:23,630 --> 00:26:28,550
or two after all

00:26:25,990 --> 00:26:29,900
multiple hashing the problem with linear

00:26:28,550 --> 00:26:32,870
probing is that we end up with a

00:26:29,900 --> 00:26:35,330
catastrophic linear pileup the solution

00:26:32,870 --> 00:26:38,360
is du saw every time you get a collision

00:26:35,330 --> 00:26:40,430
do a rehash so that they don't pile up

00:26:38,360 --> 00:26:43,070
in the same place so they split off in

00:26:40,430 --> 00:26:45,410
different directions and so there's two

00:26:43,070 --> 00:26:47,990
tricks there one is we use all the bits

00:26:45,410 --> 00:26:50,000
of a hash we've got a 64-bit hash and

00:26:47,990 --> 00:26:52,430
perhaps a table with only eight entries

00:26:50,000 --> 00:26:54,980
so we only need three bits at a time so

00:26:52,430 --> 00:26:57,950
we gradually fit shift in five at a time

00:26:54,980 --> 00:26:59,870
and that's called perturbing in addition

00:26:57,950 --> 00:27:02,060
there's a linear congruential random

00:26:59,870 --> 00:27:04,940
number generator that says take the

00:27:02,060 --> 00:27:06,980
current slot times five add one modulo

00:27:04,940 --> 00:27:09,350
the number of slots to find the next one

00:27:06,980 --> 00:27:12,110
what's cool about this is it provably

00:27:09,350 --> 00:27:14,180
eventually visits every slot it means

00:27:12,110 --> 00:27:15,290
that hash tables don't get caught in a

00:27:14,180 --> 00:27:18,050
loop when there's

00:27:15,290 --> 00:27:20,420
collisions I believe uncle Timmy came up

00:27:18,050 --> 00:27:21,560
with these ideas and so this code is

00:27:20,420 --> 00:27:23,870
uncle Timmy's good

00:27:21,560 --> 00:27:29,180
whenever you get a collision we print

00:27:23,870 --> 00:27:30,920
out we perturb the bits shifting and

00:27:29,180 --> 00:27:33,320
additional bits multiplied by five add

00:27:30,920 --> 00:27:36,500
one taken modulo and update the UH

00:27:33,320 --> 00:27:38,990
perturb so in this structure we end up

00:27:36,500 --> 00:27:41,660
with no claw are all of the here's the

00:27:38,990 --> 00:27:43,880
collisions that came out for this as is

00:27:41,660 --> 00:27:45,380
probing all of our round I may disappear

00:27:43,880 --> 00:27:47,890
Lee dents table and I picked these names

00:27:45,380 --> 00:27:52,850
on purpose to create a lot of collisions

00:27:47,890 --> 00:27:54,830
so wow that is an improvement on noose

00:27:52,850 --> 00:27:56,870
algorithm D are you trying to say that

00:27:54,830 --> 00:27:58,780
Kim uncle Timmy was able to come up with

00:27:56,870 --> 00:28:04,360
something that Donald Knuth didn't know

00:27:58,780 --> 00:28:08,240
pretty cool now an early out for a

00:28:04,360 --> 00:28:10,160
lookup sis Victor's dinner here so

00:28:08,240 --> 00:28:11,780
Victor Center is an awesome Python core

00:28:10,160 --> 00:28:14,990
developer who's been working very hard

00:28:11,780 --> 00:28:16,880
on improving the speed of Python ah one

00:28:14,990 --> 00:28:19,010
of his ideas is that internally in

00:28:16,880 --> 00:28:21,320
Python we use dictionaries a lot and

00:28:19,010 --> 00:28:22,910
we're often looking up method names and

00:28:21,320 --> 00:28:24,470
it's the same method name over and over

00:28:22,910 --> 00:28:26,870
again and we have to repeat the

00:28:24,470 --> 00:28:30,910
dictionary lookup every time because

00:28:26,870 --> 00:28:35,180
potentially the dictionary could mutate

00:28:30,910 --> 00:28:37,610
the better way is in pet 509 which

00:28:35,180 --> 00:28:39,470
appeared in Python 36 he added a private

00:28:37,610 --> 00:28:41,120
version number to the dictionary so

00:28:39,470 --> 00:28:43,220
every time we update the dictionary we

00:28:41,120 --> 00:28:46,910
update the version number that means

00:28:43,220 --> 00:28:49,010
that anything that wants to do a avoid

00:28:46,910 --> 00:28:50,090
repeated lookups can just keep track of

00:28:49,010 --> 00:28:51,740
the version number and say it's a

00:28:50,090 --> 00:28:53,840
version number the same I don't need to

00:28:51,740 --> 00:28:55,790
do the lookup again and just sped up the

00:28:53,840 --> 00:28:57,500
internals quite a bit are you trying to

00:28:55,790 --> 00:28:59,030
tell me that Victor's dinner came up

00:28:57,500 --> 00:29:00,350
with something the uncle Timmy couldn't

00:28:59,030 --> 00:29:02,150
who came up with something at Donald

00:29:00,350 --> 00:29:03,800
Knuth couldn't come up with which was

00:29:02,150 --> 00:29:08,090
better than the dinosaurs who used

00:29:03,800 --> 00:29:11,450
databases in fact that's the case there

00:29:08,090 --> 00:29:13,400
was a problem though with that design if

00:29:11,450 --> 00:29:15,500
you look at this table it's got these

00:29:13,400 --> 00:29:17,960
holes in it and the holes are quite wide

00:29:15,500 --> 00:29:22,050
it is all three fields and so there's an

00:29:17,960 --> 00:29:25,620
enormous amount of wasted space inside

00:29:22,050 --> 00:29:28,800
this is my big idea my big idea was the

00:29:25,620 --> 00:29:30,360
compact dict and essentially what I did

00:29:28,800 --> 00:29:33,240
was compress these down and got rid of

00:29:30,360 --> 00:29:35,760
all the holes so all of the hash values

00:29:33,240 --> 00:29:38,520
the keys and the values are stored in a

00:29:35,760 --> 00:29:41,010
dense fashion and there's a separate

00:29:38,520 --> 00:29:43,020
table of indexes that's a very narrow

00:29:41,010 --> 00:29:46,740
interestingly because we only have to

00:29:43,020 --> 00:29:49,590
have 8 possible slots the indexes can be

00:29:46,740 --> 00:29:52,050
stored in one by each so this index

00:29:49,590 --> 00:29:54,510
table is only 8 bytes it's actually

00:29:52,050 --> 00:29:59,370
smaller than the space it takes to store

00:29:54,510 --> 00:30:01,380
of Quito's name which i think is a

00:29:59,370 --> 00:30:02,670
pretty awesome they probably doesn't

00:30:01,380 --> 00:30:04,380
seem like that to you because Cleo has

00:30:02,670 --> 00:30:05,640
got five characters but string objects

00:30:04,380 --> 00:30:07,980
are bigger than that they have some

00:30:05,640 --> 00:30:10,710
overhead so the index table is

00:30:07,980 --> 00:30:14,160
essentially free in comparison to this

00:30:10,710 --> 00:30:15,720
no wasted space dictionaries are compact

00:30:14,160 --> 00:30:18,750
you've gotten the idea of how they got

00:30:15,720 --> 00:30:20,730
smaller in later versions of Python we

00:30:18,750 --> 00:30:21,930
got rid of all the wasted space are you

00:30:20,730 --> 00:30:23,640
telling me that I thought of an idea

00:30:21,930 --> 00:30:25,920
that Victor Center didn't think of the

00:30:23,640 --> 00:30:27,750
Tim Peterson think of that noosa didn't

00:30:25,920 --> 00:30:31,850
think of that the dinosaurs didn't think

00:30:27,750 --> 00:30:35,030
of ins of databases that is in fact true

00:30:31,850 --> 00:30:37,710
that said there was a terrible problem

00:30:35,030 --> 00:30:39,090
problem is with my dictionaries by the

00:30:37,710 --> 00:30:41,100
way I'm getting in history slightly out

00:30:39,090 --> 00:30:42,630
of order here to make it in awe easier

00:30:41,100 --> 00:30:45,840
to explain these things happened in a

00:30:42,630 --> 00:30:49,590
different order than I'm saying here but

00:30:45,840 --> 00:30:52,470
oh the problem is we had a dictionary

00:30:49,590 --> 00:30:54,270
for colors a dictionary for cities and a

00:30:52,470 --> 00:30:56,160
dictionary for fruits

00:30:54,270 --> 00:31:00,140
notice that all of these have exactly

00:30:56,160 --> 00:31:03,180
the same hash values exactly the same

00:31:00,140 --> 00:31:05,250
keys over and over again repeat it and

00:31:03,180 --> 00:31:06,690
if you have a thousand instances you

00:31:05,250 --> 00:31:09,030
have a thousand dictionaries where

00:31:06,690 --> 00:31:14,760
two-thirds of the space is completely

00:31:09,030 --> 00:31:16,440
redundant this can't be solved by people

00:31:14,760 --> 00:31:20,190
like me or Victor we're not smart enough

00:31:16,440 --> 00:31:23,940
no it came from a PhD Mark Shannon and

00:31:20,190 --> 00:31:25,740
Pep Bob 412 a key sharing dictionary the

00:31:23,940 --> 00:31:30,120
idea is we share the first two columns

00:31:25,740 --> 00:31:32,580
so all of that compacts down to this

00:31:30,120 --> 00:31:35,670
which means we've got four dictionaries

00:31:32,580 --> 00:31:37,410
in one little space here with no

00:31:35,670 --> 00:31:41,250
gaps in between do you see all these

00:31:37,410 --> 00:31:42,780
ideas dub to get together really well so

00:31:41,250 --> 00:31:44,190
let me take you in that's into the

00:31:42,780 --> 00:31:46,560
present let me take you into the future

00:31:44,190 --> 00:31:49,350
the future is something I'm working on

00:31:46,560 --> 00:31:51,540
right now what the sets because this

00:31:49,350 --> 00:31:54,210
part is so cheap it's only eight bytes

00:31:51,540 --> 00:31:56,730
would it cost me very much to make it

00:31:54,210 --> 00:32:00,920
bigger and to double the size of it and

00:31:56,730 --> 00:32:00,920
make it all less sparse the answer's no

00:32:03,410 --> 00:32:07,670
well I hear people clapping in the other

00:32:05,790 --> 00:32:11,910
room that's a bad sign

00:32:07,670 --> 00:32:15,150
okay and so the only difference here is

00:32:11,910 --> 00:32:17,760
not this data it is this index table is

00:32:15,150 --> 00:32:20,310
twice as big as it was before it's got

00:32:17,760 --> 00:32:23,040
16 entries which means it went from 8

00:32:20,310 --> 00:32:25,830
bytes to 16 bytes and it's still smaller

00:32:23,040 --> 00:32:28,080
than Quito's name it's the size of two

00:32:25,830 --> 00:32:30,120
of these hash values it's nothing in

00:32:28,080 --> 00:32:32,310
comparison to the total table but I've

00:32:30,120 --> 00:32:40,170
doubled the sparsity what's cool about

00:32:32,310 --> 00:32:42,510
this is I'll one second what's really

00:32:40,170 --> 00:32:44,520
nice about this structure is we've

00:32:42,510 --> 00:32:46,680
completely eliminated all of the

00:32:44,520 --> 00:32:48,510
collisions if you make the table sparse

00:32:46,680 --> 00:32:50,280
enough there's no collisions at all and

00:32:48,510 --> 00:32:52,440
it turns out we can now make them sparse

00:32:50,280 --> 00:32:54,840
essentially for free who learned

00:32:52,440 --> 00:32:56,340
something new so that's going to be in

00:32:54,840 --> 00:32:59,550
the future dictionaries will do even

00:32:56,340 --> 00:33:03,060
fewer steps to lookup and same is what

00:32:59,550 --> 00:33:06,560
set by the way have you seen anything

00:33:03,060 --> 00:33:06,560
that looks like this before

00:33:06,650 --> 00:33:13,880
really yes if it's up at the top of the

00:33:11,670 --> 00:33:13,880
page

00:33:14,810 --> 00:33:19,730
do you remember what those dinosaurs did

00:33:17,220 --> 00:33:19,730
a long time ago

00:33:31,650 --> 00:33:38,460
here in the third millennium we brie

00:33:34,330 --> 00:33:38,460
indented databases with indexes that

00:33:38,850 --> 00:33:44,049
said they're pretty badass they're

00:33:41,260 --> 00:33:45,880
compact they iterate faster and as a

00:33:44,049 --> 00:33:48,610
side effect of how we build them they

00:33:45,880 --> 00:33:53,100
preserve order so in Python 36 sticks

00:33:48,610 --> 00:33:56,320
are smaller and faster space efficient

00:33:53,100 --> 00:33:57,790
beautiful and key sharing and if you get

00:33:56,320 --> 00:34:00,400
a million instances with a million

00:33:57,790 --> 00:34:02,530
dictionaries none of this data over here

00:34:00,400 --> 00:34:05,049
these two columns are repeated at all in

00:34:02,530 --> 00:34:07,440
fact in the incremental space is just a

00:34:05,049 --> 00:34:11,609
space to store the values for that

00:34:07,440 --> 00:34:14,710
individual one who learned something new

00:34:11,609 --> 00:34:19,000
all right I had some odds and ends at

00:34:14,710 --> 00:34:21,159
the end let me just say a couple of them

00:34:19,000 --> 00:34:24,190
real quickly we still need a hip sip

00:34:21,159 --> 00:34:26,139
hash in Python the purpose of that is it

00:34:24,190 --> 00:34:27,940
turns out some people are diabolical and

00:34:26,139 --> 00:34:30,850
try and create keys that intentionally

00:34:27,940 --> 00:34:32,500
collide we fought back against them by

00:34:30,850 --> 00:34:34,629
putting a cryptographic hash that's

00:34:32,500 --> 00:34:36,280
receded every time time Python starts up

00:34:34,629 --> 00:34:39,700
so it's very difficult to come up with

00:34:36,280 --> 00:34:41,560
keys that collide also sets use a

00:34:39,700 --> 00:34:43,780
different strategy they use multiple

00:34:41,560 --> 00:34:44,950
chaining and linear probing because sets

00:34:43,780 --> 00:34:46,570
are about something different than

00:34:44,950 --> 00:34:48,429
dictionaries dictionaries are about

00:34:46,570 --> 00:34:49,690
looking something up sets are about

00:34:48,429 --> 00:34:51,700
determining whether something is

00:34:49,690 --> 00:34:53,290
actually there or not dictionaries you

00:34:51,700 --> 00:34:54,399
typically know the thing is there you

00:34:53,290 --> 00:34:56,830
just don't know what the value is

00:34:54,399 --> 00:34:59,800
different use cases a different balance

00:34:56,830 --> 00:35:01,600
of strategies a popular thing to talk

00:34:59,800 --> 00:35:04,450
about on hacker news now is cuckoo

00:35:01,600 --> 00:35:06,850
hashing and all a number of languages

00:35:04,450 --> 00:35:09,550
are using it how well does that mesh

00:35:06,850 --> 00:35:11,910
with this and the answer is nothing I've

00:35:09,550 --> 00:35:14,440
described conflicts with cuckoo hashing

00:35:11,910 --> 00:35:16,600
cuckoo hashing is simply a different

00:35:14,440 --> 00:35:18,490
arrangement of the index table but the

00:35:16,600 --> 00:35:20,580
rest of this could survive we could

00:35:18,490 --> 00:35:22,359
still do it I don't think we should

00:35:20,580 --> 00:35:24,520
because we have no need for

00:35:22,359 --> 00:35:27,010
densification at this point given that

00:35:24,520 --> 00:35:28,690
we've already reached a maximum identity

00:35:27,010 --> 00:35:30,430
and cuckoo hashing is all about

00:35:28,690 --> 00:35:32,650
increasing the number of collisions

00:35:30,430 --> 00:35:34,600
whereas making it sparse is all about

00:35:32,650 --> 00:35:36,480
decreasing it and I think that would be

00:35:34,600 --> 00:35:38,590
a step in the wrong direction

00:35:36,480 --> 00:35:43,210
additionally there's one other piece of

00:35:38,590 --> 00:35:44,560
logic inside of in a safe world someone

00:35:43,210 --> 00:35:45,910
mute loops over addiction

00:35:44,560 --> 00:35:47,980
and they don't change it while they're

00:35:45,910 --> 00:35:49,750
looping over it I like how the analogy

00:35:47,980 --> 00:35:51,730
is he put a ladder up on the side of a

00:35:49,750 --> 00:35:54,100
house you take out a saw and you cut out

00:35:51,730 --> 00:35:55,510
the ladder underneath you that's what

00:35:54,100 --> 00:35:57,580
happens when you mutate a structure

00:35:55,510 --> 00:35:59,350
while you're iterating and so we have

00:35:57,580 --> 00:36:01,150
logic to guard against that so that the

00:35:59,350 --> 00:36:03,280
dictionary's in sets won't segfault if

00:36:01,150 --> 00:36:06,070
you're interested when I post all these

00:36:03,280 --> 00:36:09,490
slides all of this combined together is

00:36:06,070 --> 00:36:11,620
in a single piece of code this was

00:36:09,490 --> 00:36:14,020
something that I posted about four years

00:36:11,620 --> 00:36:16,330
ago it is pure Python code it is a

00:36:14,020 --> 00:36:18,760
complete implementation of compact

00:36:16,330 --> 00:36:23,110
dictionaries from scratch and everything

00:36:18,760 --> 00:36:24,550
I showed you is in here somewhere the

00:36:23,110 --> 00:36:27,480
generation of the probes with Tim

00:36:24,550 --> 00:36:32,130
Peter's sequence the dummy entries the

00:36:27,480 --> 00:36:37,030
compact indices the resizing all logic

00:36:32,130 --> 00:36:39,310
the off fast matching all of that is in

00:36:37,030 --> 00:36:42,220
here and so I will post this shortly and

00:36:39,310 --> 00:36:43,840
in the end here's what we get this be

00:36:42,220 --> 00:36:46,000
the output of this is this beautiful

00:36:43,840 --> 00:36:50,370
little dictionary which is what I posted

00:36:46,000 --> 00:36:52,540
of to Python dev back in 2012

00:36:50,370 --> 00:36:54,150
congratulations welcome to the third

00:36:52,540 --> 00:36:57,429
millennium

00:36:54,150 --> 00:36:57,429
[Applause]

00:36:58,140 --> 00:37:05,279
okay so it looks like a bunch of you're

00:37:02,999 --> 00:37:06,690
going to lunch that's fine just be quiet

00:37:05,279 --> 00:37:08,489
while you're leaving the room there are

00:37:06,690 --> 00:37:09,779
plenty of people who are sticking around

00:37:08,489 --> 00:37:11,220
and probably want to ask some questions

00:37:09,779 --> 00:37:15,319
if you do have a question there are

00:37:11,220 --> 00:37:15,319
microphones in the in the aisles here

00:37:21,650 --> 00:37:28,880
sir thank you all right let's call it a

00:37:27,230 --> 00:37:30,580
day and go eat yeah everybody please

00:37:28,880 --> 00:37:34,099
thank right ahead and just

00:37:30,580 --> 00:37:34,099
[Applause]

00:37:34,750 --> 00:37:38,290

YouTube URL: https://www.youtube.com/watch?v=npw4s1QTmPg


