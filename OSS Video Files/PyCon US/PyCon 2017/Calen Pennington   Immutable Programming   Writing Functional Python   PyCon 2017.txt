Title: Calen Pennington   Immutable Programming   Writing Functional Python   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Calen Pennington

The world of Haskell and functional programming may seem like a distant place to many working Python developers, but some of the techniques used there are remarkably useful when developing in Python.

In this talk, I will cover some of the pitfalls of mutability that you may run into while writing Python programs, and some tools and techniques that Python has built in that will let you avoid them. You'll see namedtuples, enums and properties, and also some patterns for structuring immutable programs that will make them easier to build, extend, and test.


Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:26,970 --> 00:00:32,440
welcome to the second targeted slot it's

00:00:30,250 --> 00:00:34,060
going to be Kalyn Pennington immutable

00:00:32,440 --> 00:00:36,250
programming writing functional Python

00:00:34,060 --> 00:00:41,729
code please give them read

00:00:36,250 --> 00:00:41,729
[Applause]

00:01:02,650 --> 00:01:09,300
morning so aha so good morning

00:01:09,720 --> 00:01:18,400
wait we're also missing this projector

00:01:13,980 --> 00:01:21,040
that's it would be a bad time like lots

00:01:18,400 --> 00:01:25,450
of code it's hard to it's hard to talk

00:01:21,040 --> 00:01:31,630
through code without the code I mean

00:01:25,450 --> 00:01:34,020
double check it's not on mine oh and to

00:01:31,630 --> 00:01:41,710
the right there we go okay

00:01:34,020 --> 00:01:46,540
sorry about that right so Who am I I'm

00:01:41,710 --> 00:01:53,460
Cale Pennington yes like the vegetable

00:01:46,540 --> 00:01:57,460
but with the sea I work for EDX which is

00:01:53,460 --> 00:02:01,270
one of the is the leading open-source

00:01:57,460 --> 00:02:03,600
nonprofit education provider so we have

00:02:01,270 --> 00:02:06,700
we were founded by MIT and Harvard and

00:02:03,600 --> 00:02:08,679
we have universities that publish

00:02:06,700 --> 00:02:12,190
courses on our site from all over the

00:02:08,679 --> 00:02:14,890
world and really so if there is a thing

00:02:12,190 --> 00:02:19,390
you're looking to learn you can go at X

00:02:14,890 --> 00:02:24,100
org and and find a class there and so

00:02:19,390 --> 00:02:29,160
why am I here well EDX is a Django shop

00:02:24,100 --> 00:02:33,100
so I do Python by day but at night I

00:02:29,160 --> 00:02:36,459
also write Haskell for for fun not

00:02:33,100 --> 00:02:38,590
really for profit yet and there's

00:02:36,459 --> 00:02:41,050
patterns that I've picked up in Haskell

00:02:38,590 --> 00:02:45,910
that I think are really pretty useful

00:02:41,050 --> 00:02:48,700
for writing Python as well now the the

00:02:45,910 --> 00:02:52,000
biggest difference for between Python

00:02:48,700 --> 00:02:55,000
and Haskell in my mind is that Haskell

00:02:52,000 --> 00:03:03,030
is immutable by default and Python is

00:02:55,000 --> 00:03:03,030
not and that difference well film

00:03:06,150 --> 00:03:11,970
what the immutability that Haskell has

00:03:09,750 --> 00:03:14,579
and really forces on you means that it's

00:03:11,970 --> 00:03:16,409
much easier to think locally about what

00:03:14,579 --> 00:03:18,720
you're working with and not have to

00:03:16,409 --> 00:03:20,879
worry about its effect on other parts of

00:03:18,720 --> 00:03:23,040
the code and so I think using

00:03:20,879 --> 00:03:26,340
immutability and python really can give

00:03:23,040 --> 00:03:28,500
you that same advantage and I guess a

00:03:26,340 --> 00:03:30,180
way to think about that so when when if

00:03:28,500 --> 00:03:33,060
someone gives you a value in Python

00:03:30,180 --> 00:03:34,890
right you have a nice box and it's

00:03:33,060 --> 00:03:37,109
Python so the box is clear you can look

00:03:34,890 --> 00:03:39,329
in at the insides right you know there's

00:03:37,109 --> 00:03:41,909
not there's not Java style you know

00:03:39,329 --> 00:03:43,739
strict privacy rules um

00:03:41,909 --> 00:03:45,450
and there's probably some levers and

00:03:43,739 --> 00:03:48,510
some knobs on the box that you can use

00:03:45,450 --> 00:03:50,280
to make them to make it do the right

00:03:48,510 --> 00:03:52,200
thing do what you're looking at the

00:03:50,280 --> 00:03:54,060
problem is that that box probably also

00:03:52,200 --> 00:03:55,620
has strings attached right there are

00:03:54,060 --> 00:03:58,889
going to be things that they're going to

00:03:55,620 --> 00:04:01,290
references to that object or maybe the

00:03:58,889 --> 00:04:04,200
internals of that object and you don't

00:04:01,290 --> 00:04:06,810
know where those strings go on the other

00:04:04,200 --> 00:04:10,349
hand if someone hands you an immutable

00:04:06,810 --> 00:04:11,639
value it's basically a brick it's just

00:04:10,349 --> 00:04:13,049
going to sit there it might have some

00:04:11,639 --> 00:04:16,169
you know numbers painted on it or

00:04:13,049 --> 00:04:19,199
whatever but it's just solid there's

00:04:16,169 --> 00:04:20,940
nothing nothing can change and what that

00:04:19,199 --> 00:04:28,199
means is you can build on top of it

00:04:20,940 --> 00:04:30,720
safely so what is so I guess to start

00:04:28,199 --> 00:04:32,789
what what things in Python can you see

00:04:30,720 --> 00:04:35,550
that that are not may be signs of

00:04:32,789 --> 00:04:37,260
mutability really if you're assigning to

00:04:35,550 --> 00:04:39,210
an object's attribute if you're

00:04:37,260 --> 00:04:42,000
modifying an items an object to saya

00:04:39,210 --> 00:04:45,539
sorry if you're modifying items in a

00:04:42,000 --> 00:04:47,400
dictionary calling a method that

00:04:45,539 --> 00:04:50,220
modifies the object like adding an item

00:04:47,400 --> 00:04:52,260
to a set or even if an object is

00:04:50,220 --> 00:04:55,139
changing itself internally those are all

00:04:52,260 --> 00:04:58,639
really sort of signs of immutability and

00:04:55,139 --> 00:05:01,139
things that might bite you later

00:04:58,639 --> 00:05:02,820
immutability and python i mean you can

00:05:01,139 --> 00:05:07,650
you can assign new names to things

00:05:02,820 --> 00:05:09,990
that's certainly very useful you can

00:05:07,650 --> 00:05:14,849
read attributes off of objects you can

00:05:09,990 --> 00:05:18,450
read methods that are read-only most

00:05:14,849 --> 00:05:20,240
things in Python are mutable most things

00:05:18,450 --> 00:05:25,080
you can change

00:05:20,240 --> 00:05:26,160
lifts dick sets objects really any any

00:05:25,080 --> 00:05:29,220
of the sort of things that you're

00:05:26,160 --> 00:05:31,200
building up that you build up from build

00:05:29,220 --> 00:05:32,820
up to rather and it's really the

00:05:31,200 --> 00:05:37,080
primitives are the are the immutable

00:05:32,820 --> 00:05:41,100
values strings numbers frozen sets is a

00:05:37,080 --> 00:05:43,020
new one useful tuple nested tuples if

00:05:41,100 --> 00:05:47,790
you have an object inside a tuple you're

00:05:43,020 --> 00:05:49,700
back in sort of immutability zone but

00:05:47,790 --> 00:05:52,830
there are some other tools too so

00:05:49,700 --> 00:06:00,090
properties properties really give you

00:05:52,830 --> 00:06:02,490
the ability to it create that they give

00:06:00,090 --> 00:06:04,770
you they give you additional computation

00:06:02,490 --> 00:06:06,900
on immutable objects and we'll see some

00:06:04,770 --> 00:06:10,020
examples tuples and i'll talk about

00:06:06,900 --> 00:06:11,790
names tuples all of those things give

00:06:10,020 --> 00:06:13,860
you immutability and kind of tools for

00:06:11,790 --> 00:06:16,430
will to able being able to think locally

00:06:13,860 --> 00:06:19,500
about code rather than worrying about

00:06:16,430 --> 00:06:22,080
kind of a broader the broader having to

00:06:19,500 --> 00:06:23,280
worry about the broader context and then

00:06:22,080 --> 00:06:25,680
i'm also actually going to talk about

00:06:23,280 --> 00:06:28,440
the sort of the command the command

00:06:25,680 --> 00:06:30,720
pattern which lets you separate things

00:06:28,440 --> 00:06:33,990
that are inherently immutable like the

00:06:30,720 --> 00:06:36,090
world user input things like that from

00:06:33,990 --> 00:06:41,130
the core of your application which you

00:06:36,090 --> 00:06:43,470
can make more or less mutable and so i'm

00:06:41,130 --> 00:06:45,060
going to i'm going to do this this talk

00:06:43,470 --> 00:06:45,870
using the engine of a game of

00:06:45,060 --> 00:06:49,500
tic-tac-toe

00:06:45,870 --> 00:06:51,150
it's admittedly very simple but i think

00:06:49,500 --> 00:06:55,740
that's sort of ended that's kind of the

00:06:51,150 --> 00:06:57,240
plus you can you you probably would have

00:06:55,740 --> 00:06:59,370
written something very much like this if

00:06:57,240 --> 00:07:01,230
i asked you to write tech tech tow and

00:06:59,370 --> 00:07:02,730
it's got lots of mutability built right

00:07:01,230 --> 00:07:05,640
in right we're going to modify the board

00:07:02,730 --> 00:07:09,600
by assigning two elements of a

00:07:05,640 --> 00:07:12,350
dictionary of a list the taking an

00:07:09,600 --> 00:07:15,750
action on the board will will change it

00:07:12,350 --> 00:07:18,270
that's really so that's sort of that

00:07:15,750 --> 00:07:19,950
that's the set up this code actually

00:07:18,270 --> 00:07:21,510
already is using one of the sort of

00:07:19,950 --> 00:07:23,010
tools I mentioned it's got the proper

00:07:21,510 --> 00:07:25,080
it's using a property to compute the

00:07:23,010 --> 00:07:27,540
current player because the player is

00:07:25,080 --> 00:07:29,070
really just a function of what moves

00:07:27,540 --> 00:07:31,170
have already been played on the board if

00:07:29,070 --> 00:07:33,030
no moves have been played we can say

00:07:31,170 --> 00:07:33,730
it's player X's turn and otherwise we

00:07:33,030 --> 00:07:37,150
can say

00:07:33,730 --> 00:07:40,150
it's oh if player X has made more moves

00:07:37,150 --> 00:07:42,880
than player Oh has and that means that

00:07:40,150 --> 00:07:44,770
we don't have to worry about when at the

00:07:42,880 --> 00:07:47,980
point where we change the state of the

00:07:44,770 --> 00:07:49,660
board in in do move down there we don't

00:07:47,980 --> 00:07:52,690
have to worry about also modifying a

00:07:49,660 --> 00:07:54,280
self-taught player and that just again

00:07:52,690 --> 00:07:55,510
it keeps the number of things you have

00:07:54,280 --> 00:07:59,950
to think about when you're writing code

00:07:55,510 --> 00:08:01,800
a little bit smaller we can write some

00:07:59,950 --> 00:08:05,640
tests

00:08:01,800 --> 00:08:07,690
unfortunately the tests fail as written

00:08:05,640 --> 00:08:10,630
some of you may have already seen the

00:08:07,690 --> 00:08:12,580
bug that's okay I'm going to run through

00:08:10,630 --> 00:08:16,600
the you know okay we got this bug how do

00:08:12,580 --> 00:08:18,850
we how do we get past it so let's write

00:08:16,600 --> 00:08:22,570
a bigger test we're going to store the

00:08:18,850 --> 00:08:23,950
state of the board so that we know what

00:08:22,570 --> 00:08:26,620
it is before we make the move

00:08:23,950 --> 00:08:28,330
we'll do our move and then we'll store

00:08:26,620 --> 00:08:30,010
it again afterwards and we can compare

00:08:28,330 --> 00:08:33,460
them they're sets we can subtract them

00:08:30,010 --> 00:08:37,630
and see what values are different

00:08:33,460 --> 00:08:41,140
between before and after and when we run

00:08:37,630 --> 00:08:43,270
that test what we find is that after you

00:08:41,140 --> 00:08:46,510
make the first move you actually have an

00:08:43,270 --> 00:08:50,080
X in the first the entire first column

00:08:46,510 --> 00:08:53,080
of the of the game board that clearly

00:08:50,080 --> 00:08:57,220
not what we were trying to do so what's

00:08:53,080 --> 00:09:01,450
what's going on well the problem is in

00:08:57,220 --> 00:09:06,190
the set up the list the internal list so

00:09:01,450 --> 00:09:08,800
we're taking a list of a single a single

00:09:06,190 --> 00:09:11,020
note no player assigned we're making

00:09:08,800 --> 00:09:13,060
three copies of that list and then we're

00:09:11,020 --> 00:09:15,190
making well it turns out we're actually

00:09:13,060 --> 00:09:18,970
making three references to the internal

00:09:15,190 --> 00:09:20,770
list code like this will work that will

00:09:18,970 --> 00:09:23,560
give us the correct results because

00:09:20,770 --> 00:09:26,830
we're actually making three new lists to

00:09:23,560 --> 00:09:29,830
get you the three rows in the board but

00:09:26,830 --> 00:09:31,150
that's I mean I'll be honest I wrote I

00:09:29,830 --> 00:09:32,710
knew the first line was a bug because I

00:09:31,150 --> 00:09:35,290
wrote it while I was writing the code

00:09:32,710 --> 00:09:40,120
for the talk and had all of this failure

00:09:35,290 --> 00:09:44,890
happened live to me um it's kind of it's

00:09:40,120 --> 00:09:46,540
not obvious I often see this is this is

00:09:44,890 --> 00:09:47,350
spooky action at a distance right we

00:09:46,540 --> 00:09:50,740
made we

00:09:47,350 --> 00:09:53,950
one change to one row and actually made

00:09:50,740 --> 00:09:58,570
changes to all three rows and it makes

00:09:53,950 --> 00:10:00,820
me sad so what can we do about that

00:09:58,570 --> 00:10:02,590
what's what's the what's the sort of the

00:10:00,820 --> 00:10:05,440
way forward I mean we can we can write

00:10:02,590 --> 00:10:07,360
the safe code but we have to think about

00:10:05,440 --> 00:10:10,630
writing the safe code every time we run

00:10:07,360 --> 00:10:12,820
into something like this if we use

00:10:10,630 --> 00:10:16,060
tuples instead of lists so that they're

00:10:12,820 --> 00:10:17,980
immutable rather than being mutable like

00:10:16,060 --> 00:10:20,350
lists are we actually have the same

00:10:17,980 --> 00:10:24,310
three references to the same object but

00:10:20,350 --> 00:10:27,910
it doesn't matter because that object

00:10:24,310 --> 00:10:30,550
can't change so we can't modify the

00:10:27,910 --> 00:10:35,380
object there's no there can be no spooky

00:10:30,550 --> 00:10:37,870
action and we can see that so well okay

00:10:35,380 --> 00:10:41,920
so that's sort of the set up that's

00:10:37,870 --> 00:10:44,260
that's maybe a fix we can actually go

00:10:41,920 --> 00:10:46,960
further we can make the board the whole

00:10:44,260 --> 00:10:49,210
board state immutable and we can see

00:10:46,960 --> 00:10:51,400
that that cleans up the tests a lot too

00:10:49,210 --> 00:10:53,320
right if we have a board state that

00:10:51,400 --> 00:10:55,570
start will be initialized and then

00:10:53,320 --> 00:10:57,910
making a new move just gives us a new

00:10:55,570 --> 00:11:00,880
board state back and doesn't modify the

00:10:57,910 --> 00:11:05,470
original then we can just we can compare

00:11:00,880 --> 00:11:08,500
them that's that would be the sort of

00:11:05,470 --> 00:11:12,160
the modified code where we're going to

00:11:08,500 --> 00:11:14,410
create a new board state every time I

00:11:12,160 --> 00:11:15,910
mentioned before that named tuple was

00:11:14,410 --> 00:11:17,200
going to be something I'd talk about and

00:11:15,910 --> 00:11:18,670
this is this is actually one of my

00:11:17,200 --> 00:11:21,640
favorite ways of using named tuple

00:11:18,670 --> 00:11:24,670
because it gives you all of the kind of

00:11:21,640 --> 00:11:27,820
benefits of a class more or less for

00:11:24,670 --> 00:11:29,980
free but let me talk a little bit about

00:11:27,820 --> 00:11:32,410
what name tuple actually is first for

00:11:29,980 --> 00:11:34,630
anyone who hasn't hasn't seen it before

00:11:32,410 --> 00:11:37,900
so named tuple it's in the standard

00:11:34,630 --> 00:11:43,060
library in the collections Montand you

00:11:37,900 --> 00:11:45,040
can just use it to to create a new tuple

00:11:43,060 --> 00:11:46,510
class you create you're creating a new

00:11:45,040 --> 00:11:50,860
class with it when you call this

00:11:46,510 --> 00:11:53,470
function and that class takes takes per

00:11:50,860 --> 00:11:57,070
antics arguments whichever arguments you

00:11:53,470 --> 00:11:59,260
specify as the second the second

00:11:57,070 --> 00:12:00,940
parameter to the name tuple call and

00:11:59,260 --> 00:12:03,190
those attributes you

00:12:00,940 --> 00:12:05,590
access by name and it's derived from

00:12:03,190 --> 00:12:08,800
tuple which means that it is immutable

00:12:05,590 --> 00:12:12,000
and you get all of the nice class things

00:12:08,800 --> 00:12:14,980
for free you get dunder equals you get

00:12:12,000 --> 00:12:19,930
you can hash it you know it's it's sort

00:12:14,980 --> 00:12:22,720
of a nicely behaved a nicely behaved

00:12:19,930 --> 00:12:24,430
small object it doesn't give you default

00:12:22,720 --> 00:12:27,340
arguments so that's what this line is

00:12:24,430 --> 00:12:30,370
doing it just injects default arguments

00:12:27,340 --> 00:12:31,810
into the class it's a little bit I wish

00:12:30,370 --> 00:12:35,010
there were a cleaner interface for it

00:12:31,810 --> 00:12:35,010
but it is what it is

00:12:35,130 --> 00:12:42,190
so what is what is making the board

00:12:37,510 --> 00:12:44,920
state immutable do for the the move

00:12:42,190 --> 00:12:46,900
action it makes a little more

00:12:44,920 --> 00:12:48,970
complicated right we have to we need a

00:12:46,900 --> 00:12:50,980
helper function that is really just the

00:12:48,970 --> 00:12:55,120
it's sort of the tuple equivalent of

00:12:50,980 --> 00:12:56,740
assigning to an a value in a list by

00:12:55,120 --> 00:12:58,720
just taking the part start of the tuple

00:12:56,740 --> 00:13:01,150
in the end of the tuple and injecting

00:12:58,720 --> 00:13:04,570
your new value in the middle and then we

00:13:01,150 --> 00:13:06,430
can use that to swap in a new entry in

00:13:04,570 --> 00:13:08,620
the new row and then swaps a new row

00:13:06,430 --> 00:13:12,850
into the new board and construct a new

00:13:08,620 --> 00:13:14,350
board state to return now if the board

00:13:12,850 --> 00:13:15,700
if you've already someone has already

00:13:14,350 --> 00:13:18,850
played that move we can actually just

00:13:15,700 --> 00:13:20,920
return the current board and no one is

00:13:18,850 --> 00:13:23,050
it we could return a new board that's a

00:13:20,920 --> 00:13:24,250
copy but we because it's immutable we

00:13:23,050 --> 00:13:27,400
don't have to worry we can just return a

00:13:24,250 --> 00:13:32,040
new board with all the same sorry return

00:13:27,400 --> 00:13:34,290
the same board and the caller can

00:13:32,040 --> 00:13:37,660
essentially be none the wiser

00:13:34,290 --> 00:13:44,530
now I mentioned commands before so this

00:13:37,660 --> 00:13:46,390
is so this is the the the state of the

00:13:44,530 --> 00:13:48,730
main function after we've converted to

00:13:46,390 --> 00:13:51,250
an immutable board but it's got a lot of

00:13:48,730 --> 00:13:52,660
sort of mix a mix of things in here

00:13:51,250 --> 00:13:54,040
right mix a bunch of things are

00:13:52,660 --> 00:13:56,950
happening all at the same time we have

00:13:54,040 --> 00:14:01,840
input we're parsing the input and then

00:13:56,950 --> 00:14:03,690
we're modifying a set of states so this

00:14:01,840 --> 00:14:06,880
is lets us do things like undo and

00:14:03,690 --> 00:14:08,260
replay and things like that but we can

00:14:06,880 --> 00:14:10,990
actually separate that out so this is

00:14:08,260 --> 00:14:14,320
the command pattern so we can pull we

00:14:10,990 --> 00:14:14,690
can pull the input gathering parts into

00:14:14,320 --> 00:14:17,030
a funk

00:14:14,690 --> 00:14:18,590
and that takes a board state and just

00:14:17,030 --> 00:14:21,070
gives you back what view what does the

00:14:18,590 --> 00:14:23,570
user want to have happen to that board

00:14:21,070 --> 00:14:26,270
they want to undo something I want to

00:14:23,570 --> 00:14:27,800
switch to back to an old old old state

00:14:26,270 --> 00:14:34,250
or they want to make a new just make a

00:14:27,800 --> 00:14:36,290
new move those those objects again will

00:14:34,250 --> 00:14:39,110
make them named tuples or subclasses

00:14:36,290 --> 00:14:40,430
because they don't need to change

00:14:39,110 --> 00:14:41,900
they're not they don't need that don't

00:14:40,430 --> 00:14:45,920
need to be mutable so we may as well

00:14:41,900 --> 00:14:48,380
make them immutable by default and each

00:14:45,920 --> 00:14:50,720
of them can have the same interface to

00:14:48,380 --> 00:14:53,230
modify the states the state of the

00:14:50,720 --> 00:14:56,810
boards or the history of the boards and

00:14:53,230 --> 00:14:59,540
they can all just return that by

00:14:56,810 --> 00:15:02,450
separating those out into a standard set

00:14:59,540 --> 00:15:04,310
of classes we clean up well a we can

00:15:02,450 --> 00:15:06,740
test them right so now we've we don't

00:15:04,310 --> 00:15:08,630
have to validate user input we don't

00:15:06,740 --> 00:15:10,280
have to mock user input or anything else

00:15:08,630 --> 00:15:14,870
we need to validate that the commands

00:15:10,280 --> 00:15:19,660
work and it cleans up our main game loop

00:15:14,870 --> 00:15:22,430
we can I mean it's a lot shorter and

00:15:19,660 --> 00:15:24,050
it's very consistent between you know we

00:15:22,430 --> 00:15:26,360
get a new we get a new action from the

00:15:24,050 --> 00:15:30,080
player we apply that action and we

00:15:26,360 --> 00:15:31,580
repeat you'll notice up here we've got

00:15:30,080 --> 00:15:33,260
we actually have two different types of

00:15:31,580 --> 00:15:34,850
players so that's another advantage of

00:15:33,260 --> 00:15:37,280
using something like the command pattern

00:15:34,850 --> 00:15:47,000
is we can write a random bot that just

00:15:37,280 --> 00:15:49,850
returns a random move every time the so

00:15:47,000 --> 00:15:54,680
the last I guess thing I want to talk

00:15:49,850 --> 00:15:57,650
about is around so say you wanted to say

00:15:54,680 --> 00:15:59,660
iterate over all of the the board states

00:15:57,650 --> 00:16:02,660
in tic-tac-toe now admittedly again

00:15:59,660 --> 00:16:05,030
tic-tac-toe is simple maybe this isn't a

00:16:02,660 --> 00:16:07,220
huge interesting problem but I think we

00:16:05,030 --> 00:16:09,470
iterate over a lot of states of things

00:16:07,220 --> 00:16:10,790
while you're searching or while you have

00:16:09,470 --> 00:16:15,100
a lot of data that you're processing

00:16:10,790 --> 00:16:19,460
that's a pretty pretty common pattern

00:16:15,100 --> 00:16:21,410
the we can do it in the in the mutable

00:16:19,460 --> 00:16:23,240
version right so this is it this is back

00:16:21,410 --> 00:16:27,710
to our old mutable mutable version of

00:16:23,240 --> 00:16:28,370
code and we can see we can make a move

00:16:27,710 --> 00:16:30,830
we can

00:16:28,370 --> 00:16:32,000
yield the board well in fact we're going

00:16:30,830 --> 00:16:33,470
to yield we're going to yield the board

00:16:32,000 --> 00:16:37,610
and we're going to yield all successors

00:16:33,470 --> 00:16:39,260
of the board and then we can roll back

00:16:37,610 --> 00:16:41,000
the move afterwards right because we

00:16:39,260 --> 00:16:43,100
have to reset so that we can make the

00:16:41,000 --> 00:16:47,480
next move in the in our possible in our

00:16:43,100 --> 00:16:50,470
set of candidates but this code makes me

00:16:47,480 --> 00:16:54,050
sad the the spooky action a distance

00:16:50,470 --> 00:16:57,860
jumps up again if the caller of this

00:16:54,050 --> 00:17:00,260
method whose processing doing work on

00:16:57,860 --> 00:17:03,710
the boards that we're we're yielding if

00:17:00,260 --> 00:17:06,170
they make a move that will that will

00:17:03,710 --> 00:17:08,300
break the iteration right well loot will

00:17:06,170 --> 00:17:10,929
lose an entire swath of the search space

00:17:08,300 --> 00:17:13,970
because that move has already been made

00:17:10,929 --> 00:17:16,490
okay great we're we're we're smart we

00:17:13,970 --> 00:17:18,949
can fix that well store the whole the

00:17:16,490 --> 00:17:22,040
whole board state right before we before

00:17:18,949 --> 00:17:23,569
we yield well or before we make any

00:17:22,040 --> 00:17:27,559
moves will store the whole board state

00:17:23,569 --> 00:17:32,600
and then will revert after we yield the

00:17:27,559 --> 00:17:34,370
the rest of the iteration that's I mean

00:17:32,600 --> 00:17:36,050
it's better right it means the caller

00:17:34,370 --> 00:17:39,580
can't we make sure the iteration happens

00:17:36,050 --> 00:17:44,690
correctly but it makes a caller sad

00:17:39,580 --> 00:17:48,890
because with this what happens at the

00:17:44,690 --> 00:17:51,890
Sam say I want to find the five most

00:17:48,890 --> 00:17:53,360
interesting tic-tac-toe boards so I it

00:17:51,890 --> 00:17:55,790
aright overall the tic-tac-toe boards

00:17:53,360 --> 00:17:58,070
and I store them I find them of the most

00:17:55,790 --> 00:18:01,580
interesting size however you define

00:17:58,070 --> 00:18:03,230
interesting on tic-tac-toe the prop at

00:18:01,580 --> 00:18:05,870
the end of this I'm going to have five

00:18:03,230 --> 00:18:07,520
pointers to the same board that is at

00:18:05,870 --> 00:18:10,400
the state of the last point of the

00:18:07,520 --> 00:18:15,559
iteration because again this is mutating

00:18:10,400 --> 00:18:18,559
the same board over and over so that's

00:18:15,559 --> 00:18:20,720
not great either if we move to an

00:18:18,559 --> 00:18:24,500
immutable case where what we're we're

00:18:20,720 --> 00:18:26,330
yielding is states of the board neither

00:18:24,500 --> 00:18:29,390
we don't run to either of those problems

00:18:26,330 --> 00:18:31,670
and frankly we're not doing much more

00:18:29,390 --> 00:18:33,650
work than we were here because here

00:18:31,670 --> 00:18:35,780
we're having to copy every every we're

00:18:33,650 --> 00:18:37,550
having to copy the board every time just

00:18:35,780 --> 00:18:39,940
to keep from being messed up by

00:18:37,550 --> 00:18:39,940
everything else

00:18:40,259 --> 00:18:44,319
now we can go further actually and we

00:18:42,789 --> 00:18:48,279
can actually we can give the user some

00:18:44,319 --> 00:18:50,559
input into how to do this search let's

00:18:48,279 --> 00:18:53,559
say we wanted to find say we wanted to

00:18:50,559 --> 00:18:55,179
end the search after the board is epic

00:18:53,559 --> 00:18:57,969
aim is one right this one this search

00:18:55,179 --> 00:19:01,659
function will just it'll fill up the

00:18:57,969 --> 00:19:03,929
board in every way it can we can write a

00:19:01,659 --> 00:19:06,759
we can write a filter function that is

00:19:03,929 --> 00:19:10,809
going to take the states that we're

00:19:06,759 --> 00:19:13,869
about to iterate over and tell us what

00:19:10,809 --> 00:19:19,449
order to iterate them or what we want to

00:19:13,869 --> 00:19:21,909
do what what we should do next but again

00:19:19,449 --> 00:19:24,119
it can't other we're sort of providing a

00:19:21,909 --> 00:19:27,159
very narrow window for the user to

00:19:24,119 --> 00:19:29,409
affect the the iteration in an expected

00:19:27,159 --> 00:19:33,999
way so we don't have to worry about this

00:19:29,409 --> 00:19:35,499
you know the sad the problems this is

00:19:33,999 --> 00:19:36,999
the sort of the filter function I was

00:19:35,499 --> 00:19:38,979
mentioning before we can just check as

00:19:36,999 --> 00:19:41,199
the current board state as a winner and

00:19:38,979 --> 00:19:41,769
if it is we won't we won't iterate

00:19:41,199 --> 00:19:45,279
anymore

00:19:41,769 --> 00:19:47,889
and we can go through that actually run

00:19:45,279 --> 00:19:51,099
that code and my laptop will chug away

00:19:47,889 --> 00:19:53,190
for 30 seconds or whatever it is and get

00:19:51,099 --> 00:19:56,229
some stats about tic-tac-toe

00:19:53,190 --> 00:19:58,019
so I guess what is what is the thing I

00:19:56,229 --> 00:20:03,039
want you to take away from all this

00:19:58,019 --> 00:20:05,769
using immutability in your code can help

00:20:03,039 --> 00:20:07,389
you concentrate make it so that you can

00:20:05,769 --> 00:20:11,889
focus on the code you're writing right

00:20:07,389 --> 00:20:14,289
now and not what is someone going to do

00:20:11,889 --> 00:20:15,459
that might mess my code up or what am I

00:20:14,289 --> 00:20:17,559
going to be doing that is going to mess

00:20:15,459 --> 00:20:20,859
someone else's code up like what are the

00:20:17,559 --> 00:20:22,749
or some other threads code up like you

00:20:20,859 --> 00:20:27,069
it lets you just focus on the code

00:20:22,749 --> 00:20:31,169
you're writing right now and you can use

00:20:27,069 --> 00:20:34,409
these properties tuples and name tuples

00:20:31,169 --> 00:20:40,599
the command pattern all of those tools

00:20:34,409 --> 00:20:45,399
really get you the those those are sort

00:20:40,599 --> 00:20:48,519
of the key tools in my mind for getting

00:20:45,399 --> 00:20:50,709
that local thinking your code and I

00:20:48,519 --> 00:20:52,089
guess I didn't I'm I'm a few minutes

00:20:50,709 --> 00:20:54,989
early so we have lots of times requests

00:20:52,089 --> 00:20:54,989
lots of times for questions

00:21:02,059 --> 00:21:16,250
if you have questions just come up to

00:21:04,320 --> 00:21:16,250
the microphone please Mike

00:21:26,990 --> 00:21:32,370
all right so in your code there when you

00:21:30,210 --> 00:21:34,110
wanted to splice in a new value in the

00:21:32,370 --> 00:21:37,440
middle of a tuple there yeah yeah little

00:21:34,110 --> 00:21:39,420
helper yeah it kind of sucks yeah so in

00:21:37,440 --> 00:21:40,920
a lot of other languages you like purely

00:21:39,420 --> 00:21:42,390
functional languages you use them it may

00:21:40,920 --> 00:21:44,540
be a lens or something like that what

00:21:42,390 --> 00:21:49,200
what approaches do you have for that um

00:21:44,540 --> 00:21:51,929
I hadn't so I sort of took the text a

00:21:49,200 --> 00:21:55,020
helper method because it was the easy

00:21:51,929 --> 00:21:59,059
code is um it was the simplest thing

00:21:55,020 --> 00:22:05,280
like as I was just writing the talk um I

00:21:59,059 --> 00:22:06,900
could see I mean I think I think you

00:22:05,280 --> 00:22:10,140
could take so for two poles for instance

00:22:06,900 --> 00:22:12,860
I could imagine and I'm not sure I think

00:22:10,140 --> 00:22:16,110
I think you can return a value from

00:22:12,860 --> 00:22:19,110
setting a dict are setting an item in

00:22:16,110 --> 00:22:20,429
list not 100% sure but if it so you

00:22:19,110 --> 00:22:22,260
might be able to use set item to

00:22:20,429 --> 00:22:27,179
essentially make this helper a little

00:22:22,260 --> 00:22:28,559
bit more intuitive not sure about that I

00:22:27,179 --> 00:22:30,570
don't know I hadn't I hadn't thought

00:22:28,559 --> 00:22:33,860
through like what how would I clean up

00:22:30,570 --> 00:22:36,660
this especially in light of things like

00:22:33,860 --> 00:22:42,990
lenses you like you would use in another

00:22:36,660 --> 00:22:47,100
in another language hey you made it

00:22:42,990 --> 00:22:50,130
through without using the M word so in

00:22:47,100 --> 00:22:51,840
terms of immutable data structures is

00:22:50,130 --> 00:22:53,460
there a specific kind of immutable data

00:22:51,840 --> 00:23:00,870
structure that you'd like to see in the

00:22:53,460 --> 00:23:04,410
core language and and why I think as far

00:23:00,870 --> 00:23:13,770
as the the sort of bigger structures

00:23:04,410 --> 00:23:15,120
like lists and maps the I think those

00:23:13,770 --> 00:23:16,260
would be those would be useful I don't

00:23:15,120 --> 00:23:17,550
know if they need to be in the core

00:23:16,260 --> 00:23:20,760
language I mean I know there there are

00:23:17,550 --> 00:23:26,070
several there are several libraries out

00:23:20,760 --> 00:23:28,890
there for doing that have sort of all of

00:23:26,070 --> 00:23:32,100
the immutable data structures all of the

00:23:28,890 --> 00:23:36,950
standard data structures but written is

00:23:32,100 --> 00:23:36,950
in an immutable fashion

00:23:38,150 --> 00:23:42,110
I think if you take out like I guess I I

00:23:40,340 --> 00:23:44,570
don't actually think that you should you

00:23:42,110 --> 00:23:46,550
would want to take Python and turn it

00:23:44,570 --> 00:23:48,490
into Haskell right Haskell existant is

00:23:46,550 --> 00:23:51,230
useful I think having the tools

00:23:48,490 --> 00:23:52,970
available in Python so that you can use

00:23:51,230 --> 00:23:55,400
immutability when when you want and when

00:23:52,970 --> 00:23:56,660
it makes sense as I think the core thing

00:23:55,400 --> 00:24:01,250
for me and so that from that perspective

00:23:56,660 --> 00:24:05,630
I'm not sure immutability of say lists

00:24:01,250 --> 00:24:07,220
and and maps are huge I guess in a

00:24:05,630 --> 00:24:10,010
mutable dictionary would be probably the

00:24:07,220 --> 00:24:12,920
biggest thing because that doesn't exist

00:24:10,010 --> 00:24:15,230
so you're also on team frozen dict sorry

00:24:12,920 --> 00:24:18,170
team frozen dict we want frozen dict as

00:24:15,230 --> 00:24:22,490
well as frozen said right yes yes I

00:24:18,170 --> 00:24:26,690
think frozen dick would be helpful hi

00:24:22,490 --> 00:24:30,020
good talk interesting talk um have you

00:24:26,690 --> 00:24:33,860
in your work in this kind of in this

00:24:30,020 --> 00:24:36,710
topic how do you deal with you know

00:24:33,860 --> 00:24:39,590
agree as huge library ecosystem for

00:24:36,710 --> 00:24:42,020
Python and you know as much as like you

00:24:39,590 --> 00:24:44,240
say pythons Python it is what it is not

00:24:42,020 --> 00:24:45,640
Haskell another link and so it doesn't

00:24:44,240 --> 00:24:50,750
have all those little nice little

00:24:45,640 --> 00:24:52,520
mechanisms in there to help validate the

00:24:50,750 --> 00:24:53,810
immutability of our data structure yeah

00:24:52,520 --> 00:24:56,840
but oftentimes when we're dealing with

00:24:53,810 --> 00:24:58,160
other libraries you know like that's not

00:24:56,840 --> 00:25:00,200
necessarily something that they were

00:24:58,160 --> 00:25:02,780
pursuing or that they care about okay so

00:25:00,200 --> 00:25:04,160
I mean that's one of the things that I

00:25:02,780 --> 00:25:08,180
struggle with sometimes with Python is

00:25:04,160 --> 00:25:10,430
that you get this miasma of references

00:25:08,180 --> 00:25:14,630
that you have no way I'm keeping track

00:25:10,430 --> 00:25:16,640
of is that something that you've you

00:25:14,630 --> 00:25:19,120
know like given some thought to or how

00:25:16,640 --> 00:25:24,470
do you approach that sort of problem I

00:25:19,120 --> 00:25:26,900
think for me mostly the I will sort of

00:25:24,470 --> 00:25:28,580
make an effort to use immutable things

00:25:26,900 --> 00:25:30,880
when they are when they make sense and

00:25:28,580 --> 00:25:33,620
are useful in the code I'm writing I

00:25:30,880 --> 00:25:37,550
guess an upside is most Python doesn't

00:25:33,620 --> 00:25:40,070
expect to be able to modify like if

00:25:37,550 --> 00:25:44,660
you're passing an object into a into a

00:25:40,070 --> 00:25:46,370
library it's unless it needs to do

00:25:44,660 --> 00:25:48,620
mutation on the object like most

00:25:46,370 --> 00:25:51,850
libraries aren't setting random values

00:25:48,620 --> 00:25:51,850
on your on your things

00:25:52,340 --> 00:25:57,149
but yeah I mean as far as dealing with

00:25:54,359 --> 00:25:58,919
the all of the mutability coming at you

00:25:57,149 --> 00:26:03,419
I think I think it's more of a question

00:25:58,919 --> 00:26:08,279
of making a practice out of maintaining

00:26:03,419 --> 00:26:09,869
of not mutating things and sort of it

00:26:08,279 --> 00:26:11,429
you know if you can if you can use

00:26:09,869 --> 00:26:12,989
something like the command pattern or

00:26:11,429 --> 00:26:14,969
otherwise sort of have the immutable

00:26:12,989 --> 00:26:17,700
core of your application that things

00:26:14,969 --> 00:26:20,999
come into and go out of then you can at

00:26:17,700 --> 00:26:24,359
least kind of maintain that kind of keep

00:26:20,999 --> 00:26:27,389
keeping keeping the the code that you're

00:26:24,359 --> 00:26:28,859
focused on the package separately from

00:26:27,389 --> 00:26:30,690
like for instance the calls to your

00:26:28,859 --> 00:26:33,059
external libraries and whatnot yeah so

00:26:30,690 --> 00:26:35,279
you at least have control over the

00:26:33,059 --> 00:26:36,929
mutability of the structures that are

00:26:35,279 --> 00:26:38,999
coming into and out of here I mean I

00:26:36,929 --> 00:26:41,190
think that's a given sort of where

00:26:38,999 --> 00:26:42,419
python is and and and the fantastic

00:26:41,190 --> 00:26:43,649
libraries that we have and you want to

00:26:42,419 --> 00:26:45,149
be able to use that's kind of what I

00:26:43,649 --> 00:26:48,469
think that's all you all you really can

00:26:45,149 --> 00:26:48,469
do at this point thank you

00:26:48,869 --> 00:26:53,789
are there any performance issues around

00:26:51,450 --> 00:26:55,200
the fact that let's say in Haskell or

00:26:53,789 --> 00:26:57,389
other functional colleges that emphasize

00:26:55,200 --> 00:27:00,119
immutability presumably the language is

00:26:57,389 --> 00:27:01,950
designed in a way that you don't spend

00:27:00,119 --> 00:27:03,419
too much time making kind of like almost

00:27:01,950 --> 00:27:04,529
identical copy of something else while

00:27:03,419 --> 00:27:06,509
in Python there is no particular

00:27:04,529 --> 00:27:07,889
consideration or it actually works out

00:27:06,509 --> 00:27:08,969
fine and it's not an issue so what I'm

00:27:07,889 --> 00:27:10,379
saying is like if you make a copy it

00:27:08,969 --> 00:27:11,969
looks like you're almost making the

00:27:10,379 --> 00:27:13,679
quota this huge board and you just like

00:27:11,969 --> 00:27:15,269
change one cell and do it like over in a

00:27:13,679 --> 00:27:16,349
loop wouldn't that I mean I haven't

00:27:15,269 --> 00:27:17,489
thought about it carefully but wouldn't

00:27:16,349 --> 00:27:19,619
that cause a problem unless you have

00:27:17,489 --> 00:27:21,779
some special language support or I'm

00:27:19,619 --> 00:27:23,940
it's already ideal a big deal so yeah I

00:27:21,779 --> 00:27:25,889
didn't really get into a lot of the like

00:27:23,940 --> 00:27:29,549
immutable data structure type stuff in

00:27:25,889 --> 00:27:31,049
here but typically what happens with

00:27:29,549 --> 00:27:35,849
when you're using an immutable data

00:27:31,049 --> 00:27:39,029
structure is that you're you make you

00:27:35,849 --> 00:27:41,609
make you might replace like the

00:27:39,029 --> 00:27:43,379
top-level tuple but it's going to have

00:27:41,609 --> 00:27:44,909
references to all of the old so imagine

00:27:43,379 --> 00:27:47,070
a thousand by thousand board instead of

00:27:44,909 --> 00:27:49,320
a three by three right if you need to

00:27:47,070 --> 00:27:51,839
change one square in that you'll replace

00:27:49,320 --> 00:27:53,190
the one of one thousand length tuple at

00:27:51,839 --> 00:27:54,869
the top of the sort of the spine of the

00:27:53,190 --> 00:27:56,999
structure and you'll replace one

00:27:54,869 --> 00:27:58,830
thousand length tuple at the row but

00:27:56,999 --> 00:28:02,129
you're gonna have the same all of all

00:27:58,830 --> 00:28:04,019
other 999 tuples you're not going to

00:28:02,129 --> 00:28:05,580
touch and they're going to say it's

00:28:04,019 --> 00:28:07,740
you're really only making two

00:28:05,580 --> 00:28:09,990
essentially two new tuples every time

00:28:07,740 --> 00:28:12,270
you modify that board and that's sort of

00:28:09,990 --> 00:28:16,260
the typical pattern with immutable data

00:28:12,270 --> 00:28:18,630
structures is that they will have that

00:28:16,260 --> 00:28:20,790
notion of you know they're they're often

00:28:18,630 --> 00:28:23,640
based on pries and you can substance or

00:28:20,790 --> 00:28:26,250
tough out a small sub portion of it

00:28:23,640 --> 00:28:28,650
modifying kind of the spine of the data

00:28:26,250 --> 00:28:31,230
structure without having to create a new

00:28:28,650 --> 00:28:32,820
copy of everything and that can actually

00:28:31,230 --> 00:28:34,740
be a plus you know if you if you went

00:28:32,820 --> 00:28:36,990
back to the iteration where we had to

00:28:34,740 --> 00:28:39,540
save a copy of the board every time you

00:28:36,990 --> 00:28:42,300
can imagine if that were a thousand by a

00:28:39,540 --> 00:28:43,620
thousand board actually doing this the

00:28:42,300 --> 00:28:45,360
copy of that so that we could roll it

00:28:43,620 --> 00:28:47,130
back again we'd get expensive in the

00:28:45,360 --> 00:28:49,920
mutable case and is perhaps less

00:28:47,130 --> 00:28:52,170
expensive in the immutable case where

00:28:49,920 --> 00:28:54,390
you can just swap out the one you know

00:28:52,170 --> 00:28:55,770
the handful of the row in the column but

00:28:54,390 --> 00:28:57,330
it doesn't work as is the way you

00:28:55,770 --> 00:28:58,830
described is how it could be done but

00:28:57,330 --> 00:29:01,230
that's not what happens as of right now

00:28:58,830 --> 00:29:03,690
or it already have that that's happen

00:29:01,230 --> 00:29:05,130
your code right it that's what happens

00:29:03,690 --> 00:29:06,570
as that the code has written that

00:29:05,130 --> 00:29:08,850
replace function okay so it's really

00:29:06,570 --> 00:29:11,010
yeah I mean it's the replace function is

00:29:08,850 --> 00:29:12,300
doing a little bit of probably extra

00:29:11,010 --> 00:29:14,220
work because it creates you know like

00:29:12,300 --> 00:29:16,830
slices the tuple over here and it slices

00:29:14,220 --> 00:29:18,750
the tuple over here and so you're you're

00:29:16,830 --> 00:29:21,030
creating probably three or four tuples

00:29:18,750 --> 00:29:22,440
every time you call replace but it's

00:29:21,030 --> 00:29:24,690
still using references to all the other

00:29:22,440 --> 00:29:27,960
things in the original tuple thank you

00:29:24,690 --> 00:29:30,570
yeah I think you I think you've touched

00:29:27,960 --> 00:29:32,940
on this a little bit but I'm curious to

00:29:30,570 --> 00:29:34,620
what extent does the strategy work if

00:29:32,940 --> 00:29:41,430
you don't have immutable data structures

00:29:34,620 --> 00:29:43,320
at your disposal um I mean I think so

00:29:41,430 --> 00:29:45,840
yeah you're definitely if you if you're

00:29:43,320 --> 00:29:47,760
stuck with immutable objects you mostly

00:29:45,840 --> 00:29:50,880
can't do anything except try not to

00:29:47,760 --> 00:29:53,100
mutate it if you don't need to write or

00:29:50,880 --> 00:29:54,720
try and isolate the states the places in

00:29:53,100 --> 00:29:59,160
which you mutate it so that you have

00:29:54,720 --> 00:30:00,780
better control over it on the other hand

00:29:59,160 --> 00:30:02,550
if there are you know so like I was I

00:30:00,780 --> 00:30:05,400
think I mentioned earlier there is and

00:30:02,550 --> 00:30:06,600
not that I have used it so it was you

00:30:05,400 --> 00:30:09,170
know caveat emptor but there is a

00:30:06,600 --> 00:30:11,760
library for python implementations of

00:30:09,170 --> 00:30:14,100
immutable versions of data structures I

00:30:11,760 --> 00:30:16,290
was just told that actually Joe the

00:30:14,100 --> 00:30:18,420
previous speaker wrote a C

00:30:16,290 --> 00:30:19,260
implementation of named tuple so there's

00:30:18,420 --> 00:30:21,090
that

00:30:19,260 --> 00:30:24,840
that if you want to against of worry

00:30:21,090 --> 00:30:26,190
about performance stuff on that end but

00:30:24,840 --> 00:30:29,370
I think you just kind of have to manage

00:30:26,190 --> 00:30:31,590
the existing mutability is unfolding the

00:30:29,370 --> 00:30:33,090
unfortunate answer I think we kind of

00:30:31,590 --> 00:30:38,220
just have to work around it and do it

00:30:33,090 --> 00:30:39,780
you can to not use it so unfortunately

00:30:38,220 --> 00:30:40,980
we're out of time if you have further

00:30:39,780 --> 00:30:43,910
questions to have to the speaker

00:30:40,980 --> 00:30:47,839
directly and give them a hand again

00:30:43,910 --> 00:30:47,839

YouTube URL: https://www.youtube.com/watch?v=_OLEVvjrIj8


