Title: Katie Silverio   Decorators, unwrapped How do they work   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Katie Silverio

Decorators are a syntactically-pleasing way of modifying the behavior of functions in Python. However, they can be highly opaque to Python beginners. It took me a while to learn how to write one, and even after I was confident writing my own decorators, felt like they were magical. The goal of this talk is to demystify decorators by methodically stepping through how and why they work. Along the way we'll touch on closures, scopes, and how Python is compiled.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:24,240 --> 00:00:26,300
you

00:00:36,739 --> 00:00:43,980
ladies and gentlemen please be quiet and

00:00:39,329 --> 00:00:46,710
seated we just solve one of the mystery

00:00:43,980 --> 00:00:49,079
thing in Python which itself now we know

00:00:46,710 --> 00:00:52,110
the critter is do another amazing Python

00:00:49,079 --> 00:00:54,120
and even the most experienced user in

00:00:52,110 --> 00:00:56,760
Python probably not be able to solve all

00:00:54,120 --> 00:00:58,620
the things a critters today Kate Katie

00:00:56,760 --> 00:01:10,679
will lead us a journey to demystify

00:00:58,620 --> 00:01:13,649
decorators let's welcome her hi um I'm

00:01:10,679 --> 00:01:15,869
Katie thank you for coming out today in

00:01:13,649 --> 00:01:19,860
the midst of the fire alarm crisis of

00:01:15,869 --> 00:01:21,300
2617 I was exciting I heard Tom just

00:01:19,860 --> 00:01:24,929
like rolled right through because he's

00:01:21,300 --> 00:01:28,200
great presumably are here to listen to

00:01:24,929 --> 00:01:30,780
my decorator talk if not I would

00:01:28,200 --> 00:01:32,580
encourage you to stay anyway because it

00:01:30,780 --> 00:01:37,289
should be fun I hear Brandon's coming

00:01:32,580 --> 00:01:39,750
after me so this is clearly like the

00:01:37,289 --> 00:01:42,030
best room in the convention center right

00:01:39,750 --> 00:01:45,180
now I'm not going to be taking questions

00:01:42,030 --> 00:01:47,369
up here so if you have questions you

00:01:45,180 --> 00:01:51,119
want to ask me I'm going to leave my

00:01:47,369 --> 00:01:53,790
Twitter handle on the lower right corner

00:01:51,119 --> 00:01:57,409
of every slide feel free to tweet at me

00:01:53,790 --> 00:02:02,579
feel free to stop me at all after and

00:01:57,409 --> 00:02:05,280
yeah thanks for coming so I decided

00:02:02,579 --> 00:02:07,920
about two years ago that I wanted to

00:02:05,280 --> 00:02:10,560
give this talk and I wanted to give this

00:02:07,920 --> 00:02:14,250
talk because for a long time decorators

00:02:10,560 --> 00:02:16,500
just seem like magic to me I could use

00:02:14,250 --> 00:02:19,290
them I could write them the writing them

00:02:16,500 --> 00:02:20,850
mostly felt like performing a series of

00:02:19,290 --> 00:02:23,730
steps and a spell

00:02:20,850 --> 00:02:27,870
instead of like building something where

00:02:23,730 --> 00:02:31,410
I knew how it worked so that's the

00:02:27,870 --> 00:02:33,329
context of this talk I want to take you

00:02:31,410 --> 00:02:36,120
from a place where you know what

00:02:33,329 --> 00:02:39,570
decorators do and what they're for but

00:02:36,120 --> 00:02:41,030
not necessarily how they work to being

00:02:39,570 --> 00:02:44,579
able to explain to someone else

00:02:41,030 --> 00:02:46,940
how decorators work and how they might

00:02:44,579 --> 00:02:46,940
write one

00:02:47,900 --> 00:02:54,120
so we're going to get there in a few

00:02:50,070 --> 00:02:55,560
steps first of all I have read a lot

00:02:54,120 --> 00:02:57,960
about magic in my time

00:02:55,560 --> 00:03:00,210
perhaps my shirt will tell you and one

00:02:57,960 --> 00:03:01,890
thing about magic is that you need to

00:03:00,210 --> 00:03:05,390
know true names so we're going to start

00:03:01,890 --> 00:03:09,090
off by formally defining a decorator and

00:03:05,390 --> 00:03:12,360
after that we're going to deduce one way

00:03:09,090 --> 00:03:14,580
a decorator can be structured there's

00:03:12,360 --> 00:03:16,440
going to be some loose ends to tie up in

00:03:14,580 --> 00:03:20,640
regard to how that structure actually

00:03:16,440 --> 00:03:23,280
works and after that I'm going to go

00:03:20,640 --> 00:03:27,000
through some common tricks and gotchas

00:03:23,280 --> 00:03:28,650
surrounding decorate decorators I have

00:03:27,000 --> 00:03:32,340
said that word a lot in the past three

00:03:28,650 --> 00:03:34,440
days okay so when I'm trying to define

00:03:32,340 --> 00:03:37,290
something I like to start by thinking of

00:03:34,440 --> 00:03:39,510
examples and as someone who makes a

00:03:37,290 --> 00:03:42,360
living writing production code for a

00:03:39,510 --> 00:03:45,480
large app the first example that sprung

00:03:42,360 --> 00:03:49,770
to my mind of a useful decorator is a

00:03:45,480 --> 00:03:52,890
timer there's a lot of timing decorators

00:03:49,770 --> 00:03:56,250
and the idea behind them all is that you

00:03:52,890 --> 00:03:58,830
want your code to run as normal but we

00:03:56,250 --> 00:04:03,690
also want to know how long the code

00:03:58,830 --> 00:04:05,550
takes to run so what these odd all of

00:04:03,690 --> 00:04:07,800
the timer timing decorators do is they

00:04:05,550 --> 00:04:10,200
run the original code plus they log

00:04:07,800 --> 00:04:16,770
somewhere in this case to standard out

00:04:10,200 --> 00:04:18,239
how long that code took to run if you

00:04:16,770 --> 00:04:19,650
were here for Toms talk you may have

00:04:18,239 --> 00:04:22,860
heard about the class at the decorator

00:04:19,650 --> 00:04:25,440
and it's another common one and it's

00:04:22,860 --> 00:04:28,320
been a built in and Python for a very

00:04:25,440 --> 00:04:31,320
long time and what it does is it allows

00:04:28,320 --> 00:04:35,280
a method that's been defined on a class

00:04:31,320 --> 00:04:38,090
to be called without instantiating an

00:04:35,280 --> 00:04:40,620
instance of that class super useful and

00:04:38,090 --> 00:04:43,830
so what both of these examples do is

00:04:40,620 --> 00:04:45,990
they add behavior to an object both of

00:04:43,830 --> 00:04:48,330
these cases the object with behavior

00:04:45,990 --> 00:04:49,860
being added to it as a function without

00:04:48,330 --> 00:04:55,040
changing the source code of the

00:04:49,860 --> 00:04:55,040
functions themselves tada

00:04:55,190 --> 00:04:59,270
mystery odor eight decorators change the

00:04:57,660 --> 00:05:03,300
behavior of an object

00:04:59,270 --> 00:05:05,520
modifying the source code decorators are

00:05:03,300 --> 00:05:07,709
sometimes called rappers and as these

00:05:05,520 --> 00:05:09,929
names perhaps illuminate the concept

00:05:07,709 --> 00:05:12,330
here is that the added behavior whatever

00:05:09,929 --> 00:05:14,239
it may be is by and large separate from

00:05:12,330 --> 00:05:17,129
wrapped around the modified object

00:05:14,239 --> 00:05:20,369
whatever that may be

00:05:17,129 --> 00:05:22,139
so most function decorators can be

00:05:20,369 --> 00:05:25,139
applicable to arbitrary functions

00:05:22,139 --> 00:05:28,529
because function decorators shouldn't

00:05:25,139 --> 00:05:33,240
depend on what they wrap that is it can

00:05:28,529 --> 00:05:35,639
be reused let's just really hammer home

00:05:33,240 --> 00:05:38,129
the benefits of using a decorator to add

00:05:35,639 --> 00:05:39,839
extra behaviors to functions so imagine

00:05:38,129 --> 00:05:42,330
that you have a function that you'd like

00:05:39,839 --> 00:05:45,059
to time maybe you notice that it seems

00:05:42,330 --> 00:05:47,249
to perform much better with some inputs

00:05:45,059 --> 00:05:49,110
than others and what you want to be able

00:05:47,249 --> 00:05:51,539
to do is to run your functions with

00:05:49,110 --> 00:05:53,689
different inputs and say log to standard

00:05:51,539 --> 00:05:56,249
out the time spent in that function

00:05:53,689 --> 00:06:00,329
there are two different ways that I can

00:05:56,249 --> 00:06:04,789
think of of doing this and one way is to

00:06:00,329 --> 00:06:08,699
just add code to my function itself so

00:06:04,789 --> 00:06:11,119
you could import time get the time

00:06:08,699 --> 00:06:13,379
before anything happens in the function

00:06:11,119 --> 00:06:16,740
keep the original body of the function

00:06:13,379 --> 00:06:17,969
get the end time the time spent in that

00:06:16,740 --> 00:06:19,409
original body is going to be the

00:06:17,969 --> 00:06:21,719
difference between those times so you

00:06:19,409 --> 00:06:24,779
print those two standard out and then

00:06:21,719 --> 00:06:26,819
you return the original return value do

00:06:24,779 --> 00:06:29,309
this every time you run my function

00:06:26,819 --> 00:06:31,709
you'll print two standard out how long

00:06:29,309 --> 00:06:36,029
the original body takes to execute does

00:06:31,709 --> 00:06:38,429
what you want right alternatively you

00:06:36,029 --> 00:06:40,289
could use a timer decorator and I'm not

00:06:38,429 --> 00:06:42,449
going to show you the source code for my

00:06:40,289 --> 00:06:45,949
timer yet it's just a mystery for now

00:06:42,449 --> 00:06:48,869
but it does the same thing as adding

00:06:45,949 --> 00:06:52,619
timing and printing lines to the source

00:06:48,869 --> 00:06:54,240
code of my function it does also have

00:06:52,619 --> 00:06:56,639
the convenient benefit of making it

00:06:54,240 --> 00:06:59,399
really explicit that the timing behavior

00:06:56,639 --> 00:07:01,949
is extra it's not inherent to what might

00:06:59,399 --> 00:07:05,129
whatever my function is doing and more

00:07:01,949 --> 00:07:07,709
importantly the timing decorator can be

00:07:05,129 --> 00:07:09,719
reused to time additional functions

00:07:07,709 --> 00:07:11,579
which is not a thing that I could have

00:07:09,719 --> 00:07:12,470
done with a constructed timer on the

00:07:11,579 --> 00:07:15,290
last side

00:07:12,470 --> 00:07:17,840
had to cut and paste those lines of code

00:07:15,290 --> 00:07:22,640
into a bunch of other functions that's

00:07:17,840 --> 00:07:25,610
one way so in order to gain intuition

00:07:22,640 --> 00:07:27,410
for how a decorator works we first need

00:07:25,610 --> 00:07:29,410
to make some explicit statements about

00:07:27,410 --> 00:07:32,540
the objects that decorators are

00:07:29,410 --> 00:07:34,550
frequently applied to so technically

00:07:32,540 --> 00:07:37,670
decorators and Python can be applied to

00:07:34,550 --> 00:07:39,890
either functions or classes more on that

00:07:37,670 --> 00:07:43,190
later but stick with functions for now

00:07:39,890 --> 00:07:46,310
very simply in Python functions are

00:07:43,190 --> 00:07:50,090
first class objects and first class

00:07:46,310 --> 00:07:53,120
objects are entities that they can be

00:07:50,090 --> 00:07:56,360
assigned to variables first class

00:07:53,120 --> 00:07:57,860
objects can be passed to functions first

00:07:56,360 --> 00:08:03,190
class objects can be returned from

00:07:57,860 --> 00:08:06,800
functions and first class objects can be

00:08:03,190 --> 00:08:11,210
dynamically created within functions so

00:08:06,800 --> 00:08:14,660
the upshot of all of this is that well

00:08:11,210 --> 00:08:17,120
hang on the first up shot is that I can

00:08:14,660 --> 00:08:18,650
refactor that really really terrible

00:08:17,120 --> 00:08:22,160
constructed timer code I run a couple

00:08:18,650 --> 00:08:22,880
slides ago I got what I got like 23

00:08:22,160 --> 00:08:25,280
minutes left

00:08:22,880 --> 00:08:29,050
that code is really bad so just we're

00:08:25,280 --> 00:08:31,520
going to take a minute to fix it so

00:08:29,050 --> 00:08:34,760
specifically what really bothers me

00:08:31,520 --> 00:08:37,219
about the technique of adding extra

00:08:34,760 --> 00:08:38,690
functionality to a function by just

00:08:37,219 --> 00:08:40,810
sticking lines of code in there is

00:08:38,690 --> 00:08:43,099
twofold

00:08:40,810 --> 00:08:44,650
first of all that extra timing code

00:08:43,099 --> 00:08:46,970
distracts you from the function code

00:08:44,650 --> 00:08:48,980
there's a bug in there now there's like

00:08:46,970 --> 00:08:51,860
triple the lines of code that I have to

00:08:48,980 --> 00:08:54,320
parse right secondly the extra timing

00:08:51,860 --> 00:08:56,270
code will need to be copy pasted to be

00:08:54,320 --> 00:09:00,890
used anywhere else as I've alluded to

00:08:56,270 --> 00:09:03,740
before and so the refactor that I want

00:09:00,890 --> 00:09:05,480
to do right now given that functions are

00:09:03,740 --> 00:09:08,450
first class objects that can be passed

00:09:05,480 --> 00:09:11,510
in to other functions a first step

00:09:08,450 --> 00:09:15,020
towards improving the like constructed

00:09:11,510 --> 00:09:17,330
timer is to make a new function that

00:09:15,020 --> 00:09:21,260
gets passed the original function and

00:09:17,330 --> 00:09:25,160
it's argument like so

00:09:21,260 --> 00:09:28,520
I'm going to call this a timing wrapper

00:09:25,160 --> 00:09:30,990
and so timing rapper gets the start time

00:09:28,520 --> 00:09:35,040
runs the function argument it's passed

00:09:30,990 --> 00:09:37,100
with runs the function it is passed with

00:09:35,040 --> 00:09:39,570
the argument that is also passed to it

00:09:37,100 --> 00:09:42,180
gets the end time prints the difference

00:09:39,570 --> 00:09:44,850
between those times and returns the

00:09:42,180 --> 00:09:51,740
value that the function it was passed

00:09:44,850 --> 00:09:55,830
returns and so I can use this to time

00:09:51,740 --> 00:09:58,170
any function that takes one argument all

00:09:55,830 --> 00:09:59,940
I have to do is just call timing wrapper

00:09:58,170 --> 00:10:02,520
with both the functions

00:09:59,940 --> 00:10:06,510
I want a time and the argument I want to

00:10:02,520 --> 00:10:09,690
run that function with so it satisfies

00:10:06,510 --> 00:10:11,700
my goal of making the timing code usable

00:10:09,690 --> 00:10:14,420
on more than one function because I can

00:10:11,700 --> 00:10:16,530
pass in any one argument function there

00:10:14,420 --> 00:10:19,650
but it's also worse than the original

00:10:16,530 --> 00:10:22,470
code I'm not happy right now each call

00:10:19,650 --> 00:10:24,240
to a timer will function has to

00:10:22,470 --> 00:10:29,670
explicitly be wrapped with timing

00:10:24,240 --> 00:10:33,390
wrapper because this code is effectively

00:10:29,670 --> 00:10:36,000
adding the timing code at one time it's

00:10:33,390 --> 00:10:39,750
not timing until you want to call the

00:10:36,000 --> 00:10:41,880
function so in a large code base if you

00:10:39,750 --> 00:10:43,710
have many many many calls to my function

00:10:41,880 --> 00:10:45,120
this can be really annoying to have to

00:10:43,710 --> 00:10:47,250
search for every single call to my

00:10:45,120 --> 00:10:52,560
function and replace it with a call to

00:10:47,250 --> 00:10:55,440
timing wrapper instead terrible so that

00:10:52,560 --> 00:10:58,050
means that there's really an extra

00:10:55,440 --> 00:11:03,390
refactoring goal that was hitherto

00:10:58,050 --> 00:11:06,839
implicit what I really want to do is I

00:11:03,390 --> 00:11:09,630
still want to be able to time arbitrary

00:11:06,839 --> 00:11:12,089
functions I still want to combine that

00:11:09,630 --> 00:11:14,070
like feature of timing wrapper of being

00:11:12,089 --> 00:11:18,330
able to be used on any one argument

00:11:14,070 --> 00:11:20,580
function but I also want to preserve the

00:11:18,330 --> 00:11:22,770
feature of the original code which was

00:11:20,580 --> 00:11:26,570
that the timing functionality is baked

00:11:22,770 --> 00:11:29,280
in at definition time for that function

00:11:26,570 --> 00:11:31,230
so I added those lines to my function

00:11:29,280 --> 00:11:32,640
and then every single call to my

00:11:31,230 --> 00:11:33,060
function had the timing code that was

00:11:32,640 --> 00:11:34,260
great

00:11:33,060 --> 00:11:37,870
I want that

00:11:34,260 --> 00:11:42,220
so these first two refactoring Cole

00:11:37,870 --> 00:11:43,660
goals just to reiterate I did that by by

00:11:42,220 --> 00:11:46,960
wrapping the function that I wanted to

00:11:43,660 --> 00:11:48,670
time in another function that adds the

00:11:46,960 --> 00:11:54,150
timing code and has a callback to the

00:11:48,670 --> 00:11:56,230
original function and the third goal of

00:11:54,150 --> 00:11:59,140
having this functionality baked in a

00:11:56,230 --> 00:12:01,570
definition time that was achieved simply

00:11:59,140 --> 00:12:03,160
by including the timing code in the

00:12:01,570 --> 00:12:04,770
source code for this time function so

00:12:03,160 --> 00:12:09,100
these these two goals seem

00:12:04,770 --> 00:12:13,410
irreconcilable at this point I have 19

00:12:09,100 --> 00:12:13,410
minutes left maybe I should just give up

00:12:14,700 --> 00:12:21,339
but wait oayk point functions are first

00:12:18,160 --> 00:12:24,160
class objects so we can create them

00:12:21,339 --> 00:12:25,779
dynamically within another function and

00:12:24,160 --> 00:12:31,180
we can also return them from functions

00:12:25,779 --> 00:12:33,580
that's great so that means that I can

00:12:31,180 --> 00:12:36,460
dynamically create a new function that

00:12:33,580 --> 00:12:37,660
has timing code in it as well as a

00:12:36,460 --> 00:12:43,029
callback to the original function

00:12:37,660 --> 00:12:45,730
whatever it may be and that's a big step

00:12:43,029 --> 00:12:49,000
perhaps a big leap so I'm going to

00:12:45,730 --> 00:12:51,339
repeat it the refactor that I really

00:12:49,000 --> 00:12:55,470
want to do is to make a function that

00:12:51,339 --> 00:12:58,180
takes an arbitrary function and then

00:12:55,470 --> 00:13:01,060
inside this function should call my

00:12:58,180 --> 00:13:04,060
timer I'm going to create a new function

00:13:01,060 --> 00:13:05,830
that includes both timing code in its

00:13:04,060 --> 00:13:08,080
source as well as a callback to the

00:13:05,830 --> 00:13:10,060
original function and then I'm going to

00:13:08,080 --> 00:13:13,600
return that new function that I've

00:13:10,060 --> 00:13:15,520
created in my timer and again all of

00:13:13,600 --> 00:13:20,110
this I can do because functions are

00:13:15,520 --> 00:13:22,180
first class objects so if I want to

00:13:20,110 --> 00:13:25,029
create a timed version of my function

00:13:22,180 --> 00:13:27,820
the way I would do that is I would call

00:13:25,029 --> 00:13:30,100
my timer with my function as an argument

00:13:27,820 --> 00:13:32,230
that will give me a new function here

00:13:30,100 --> 00:13:33,610
I've named it time function and that

00:13:32,230 --> 00:13:37,320
function does everything my function

00:13:33,610 --> 00:13:37,320
does and also is timed

00:13:39,479 --> 00:13:46,059
so in terms of what that would actually

00:13:41,829 --> 00:13:49,350
look like I'm essentially going to put

00:13:46,059 --> 00:13:52,089
the timing wrapper intermediate step

00:13:49,350 --> 00:13:56,589
inside a function that takes a single

00:13:52,089 --> 00:13:59,319
argument and that single argument is the

00:13:56,589 --> 00:14:01,269
function to be timed the return value of

00:13:59,319 --> 00:14:02,949
my timer is this new wrapped function

00:14:01,269 --> 00:14:06,429
and that's actually what will get called

00:14:02,949 --> 00:14:08,949
in our code and what new wraps function

00:14:06,429 --> 00:14:11,739
is is it gets the start time it executes

00:14:08,949 --> 00:14:13,689
funk with an argument it gets the end

00:14:11,739 --> 00:14:16,329
time it logs that standard out and then

00:14:13,689 --> 00:14:20,289
it returns the value that funko would

00:14:16,329 --> 00:14:23,739
return at this point you're probably

00:14:20,289 --> 00:14:25,959
wondering how we have access to the name

00:14:23,739 --> 00:14:28,629
funk inside of new wraps function that's

00:14:25,959 --> 00:14:36,039
a great question I'm going to utterly

00:14:28,629 --> 00:14:38,679
ignore it for now and one last thing

00:14:36,039 --> 00:14:40,989
functions are first class objects so we

00:14:38,679 --> 00:14:44,019
can assign that return value to whatever

00:14:40,989 --> 00:14:48,429
we want on the previous slide I called

00:14:44,019 --> 00:14:50,589
it time function but we may as well as

00:14:48,429 --> 00:14:52,059
sign the return function to the name of

00:14:50,589 --> 00:14:56,649
the function that we want a time and

00:14:52,059 --> 00:14:59,199
just replace it we do this then after

00:14:56,649 --> 00:15:03,459
that line in which we replace who every

00:14:59,199 --> 00:15:05,439
single call to foo will have timing so I

00:15:03,459 --> 00:15:07,629
won't have to like search the entire

00:15:05,439 --> 00:15:11,949
code base and replace a bunch of calls

00:15:07,629 --> 00:15:14,379
with a new name and this is the state in

00:15:11,949 --> 00:15:18,369
which I'm going to leave this my final

00:15:14,379 --> 00:15:20,769
step in recurring as it is I can use

00:15:18,369 --> 00:15:22,659
this my timer function to add timing

00:15:20,769 --> 00:15:24,819
functionality to any one argument

00:15:22,659 --> 00:15:27,279
function immediately after that function

00:15:24,819 --> 00:15:31,509
is defined which fulfills all of my

00:15:27,279 --> 00:15:33,039
refactoring goals that's great I'm super

00:15:31,509 --> 00:15:39,729
happy so happy I'm going to take a drink

00:15:33,039 --> 00:15:41,289
of water but now now I have about 15

00:15:39,729 --> 00:15:43,509
minutes left so now we should really get

00:15:41,289 --> 00:15:47,189
back to decorators thank you for going

00:15:43,509 --> 00:15:50,769
on that tangent with me but wait

00:15:47,189 --> 00:15:51,910
replacing a function with the return

00:15:50,769 --> 00:15:53,500
value of a function

00:15:51,910 --> 00:15:55,960
called with the original function as an

00:15:53,500 --> 00:15:59,200
argument is in fact decorating that

00:15:55,960 --> 00:16:02,980
function and up until Python 2.4 that

00:15:59,200 --> 00:16:05,770
was how you decorated anything this is

00:16:02,980 --> 00:16:09,730
from the pep that proposed adding

00:16:05,770 --> 00:16:13,300
syntactic sugar for decorators this is

00:16:09,730 --> 00:16:17,770
an example of how prior to Python 2.4

00:16:13,300 --> 00:16:20,590
you would decorate a method as with the

00:16:17,770 --> 00:16:23,830
class class method decorator you would

00:16:20,590 --> 00:16:25,960
define foo and then on a new line you

00:16:23,830 --> 00:16:28,570
would replace foo with the result of

00:16:25,960 --> 00:16:31,470
class method called with foo and that's

00:16:28,570 --> 00:16:35,140
clunkier than like is really necessary

00:16:31,470 --> 00:16:37,090
so they were the pet to fix that and you

00:16:35,140 --> 00:16:40,780
may have guessed that the syntactic

00:16:37,090 --> 00:16:44,140
sugar decided on in path 318 was in fact

00:16:40,780 --> 00:16:45,910
that decorating function like this is

00:16:44,140 --> 00:16:48,400
going to be replaced with the @ sign

00:16:45,910 --> 00:16:52,320
followed by the name of the decorator on

00:16:48,400 --> 00:16:52,320
the line above the function definition

00:16:53,130 --> 00:16:59,440
so just to reiterate the add decorator

00:16:57,040 --> 00:17:02,500
syntax when used to decorate a function

00:16:59,440 --> 00:17:05,620
is just syntactic sugar for replacing

00:17:02,500 --> 00:17:07,780
that function with the return value of a

00:17:05,620 --> 00:17:15,670
callable object called with a decorated

00:17:07,780 --> 00:17:18,580
function as an argument that's it and so

00:17:15,670 --> 00:17:20,230
I can also come up with a more

00:17:18,580 --> 00:17:23,050
nuts-and-bolts definition of the Python

00:17:20,230 --> 00:17:24,760
decorator namely that it's a callable

00:17:23,050 --> 00:17:27,040
object that takes the function as an

00:17:24,760 --> 00:17:30,400
argument and replaces the decorated

00:17:27,040 --> 00:17:35,140
object with the decorators output when

00:17:30,400 --> 00:17:36,910
called with the following decorator

00:17:35,140 --> 00:17:38,440
object which changes the behavior of

00:17:36,910 --> 00:17:42,850
that object for all future calls to that

00:17:38,440 --> 00:17:46,390
object great in terms of how we'd

00:17:42,850 --> 00:17:47,410
actually write such a thing well as you

00:17:46,390 --> 00:17:51,430
may have guessed from all of that

00:17:47,410 --> 00:17:55,300
refactoring a common decorator anatomy

00:17:51,430 --> 00:17:59,170
looks a bit like this so working from

00:17:55,300 --> 00:18:01,990
the outside in our decorator is going to

00:17:59,170 --> 00:18:04,390
be a function which will be called with

00:18:01,990 --> 00:18:05,680
a function as an argument so it takes a

00:18:04,390 --> 00:18:08,530
single argument which i've

00:18:05,680 --> 00:18:12,220
called funk just hammer home that it's a

00:18:08,530 --> 00:18:16,720
function if you're trying to write a

00:18:12,220 --> 00:18:18,820
useful decorator it will probably create

00:18:16,720 --> 00:18:20,860
a new function and probably return that

00:18:18,820 --> 00:18:23,710
function which is going to replace the

00:18:20,860 --> 00:18:25,950
function that it decorates and in terms

00:18:23,710 --> 00:18:28,030
of what this new function looks like

00:18:25,950 --> 00:18:30,010
because it's going to replace the

00:18:28,030 --> 00:18:33,640
decorated function it needs to have the

00:18:30,010 --> 00:18:36,370
same signature as func so a common way

00:18:33,640 --> 00:18:40,600
of ensuring that is just to splat the

00:18:36,370 --> 00:18:43,780
arguments to the two new function that's

00:18:40,600 --> 00:18:47,140
what I've done here and then inside new

00:18:43,780 --> 00:18:49,960
function well the most common reason for

00:18:47,140 --> 00:18:51,460
writing a decorator is to extend the

00:18:49,960 --> 00:18:54,280
behavior of a function not to like

00:18:51,460 --> 00:18:57,220
replace it so probably what the wrapper

00:18:54,280 --> 00:18:58,140
function is going to do is probably call

00:18:57,220 --> 00:19:00,780
Zonk

00:18:58,140 --> 00:19:04,180
probably return the return value of func

00:19:00,780 --> 00:19:10,750
as well as probably containing some new

00:19:04,180 --> 00:19:13,230
code seems reasonable so I use the word

00:19:10,750 --> 00:19:15,850
probably a lot on that last slide

00:19:13,230 --> 00:19:18,430
because there's really quite a lot of

00:19:15,850 --> 00:19:22,540
leeway in terms of what decorators can

00:19:18,430 --> 00:19:25,120
do so really that the only requirement

00:19:22,540 --> 00:19:29,080
for the code to compile is that the

00:19:25,120 --> 00:19:31,930
decorator takes a single argument I

00:19:29,080 --> 00:19:35,490
don't actually have to define anything

00:19:31,930 --> 00:19:38,250
new in the decorator I could for example

00:19:35,490 --> 00:19:40,780
decorate a function with this no op

00:19:38,250 --> 00:19:42,850
decorator which just takes the function

00:19:40,780 --> 00:19:45,400
returns the same function so wouldn't

00:19:42,850 --> 00:19:47,170
change the thing that it decorates seems

00:19:45,400 --> 00:19:51,790
mostly useless but I could do it I had

00:19:47,170 --> 00:19:53,290
tested it in a rebel it works decorator

00:19:51,790 --> 00:19:56,830
doesn't have to actually call the

00:19:53,290 --> 00:20:00,300
function that it decorates so I could

00:19:56,830 --> 00:20:03,070
use sleight of hand to just replace

00:20:00,300 --> 00:20:05,800
whatever I decorate with something that

00:20:03,070 --> 00:20:10,180
always returns 42 don't know why I'd

00:20:05,800 --> 00:20:13,000
want to do that but I could and finally

00:20:10,180 --> 00:20:16,250
a decorator doesn't actually have to

00:20:13,000 --> 00:20:19,250
return a function in order to compile

00:20:16,250 --> 00:20:21,169
so in theory I could decorate something

00:20:19,250 --> 00:20:26,059
with this black hole that just returns

00:20:21,169 --> 00:20:27,679
none the code will compile if I were to

00:20:26,059 --> 00:20:30,769
say decorate something called foo with

00:20:27,679 --> 00:20:33,620
black hole yeah I'd have a slow object

00:20:30,769 --> 00:20:35,690
if I try and actually call foo I'll get

00:20:33,620 --> 00:20:37,759
a type error because none isn't callable

00:20:35,690 --> 00:20:41,450
and that'll be real confusing but I

00:20:37,759 --> 00:20:42,500
could do it so none of these are

00:20:41,450 --> 00:20:43,730
particularly helpful

00:20:42,500 --> 00:20:45,950
none of these are particularly useful

00:20:43,730 --> 00:20:49,340
unless your main goal is having bad

00:20:45,950 --> 00:20:52,100
ideas which is a good goal to have but

00:20:49,340 --> 00:20:54,740
they are all legal decorators according

00:20:52,100 --> 00:20:56,389
to pythons grammar could use all of

00:20:54,740 --> 00:20:58,009
these functions to decorate something

00:20:56,389 --> 00:21:03,500
else work fine

00:20:58,009 --> 00:21:07,789
I found definition of fine so now we're

00:21:03,500 --> 00:21:10,429
done right at this point we've worked

00:21:07,789 --> 00:21:13,340
through what the app syntactic sugar is

00:21:10,429 --> 00:21:16,490
like actually doing we've worked through

00:21:13,340 --> 00:21:19,970
one way of structuring a decorator that

00:21:16,490 --> 00:21:22,220
is useful we've even seen how you could

00:21:19,970 --> 00:21:24,340
write totally useless decorators but

00:21:22,220 --> 00:21:26,840
we're not actually done so I still

00:21:24,340 --> 00:21:30,169
haven't explained how the inner function

00:21:26,840 --> 00:21:32,960
that's created inside of a decorator has

00:21:30,169 --> 00:21:36,620
access to the function that's passed in

00:21:32,960 --> 00:21:40,850
as an argument to the decorator itself I

00:21:36,620 --> 00:21:44,629
haven't I haven't explained a lot of

00:21:40,850 --> 00:21:45,980
things so here are some more open

00:21:44,629 --> 00:21:49,820
questions that I can think of off the

00:21:45,980 --> 00:21:55,009
top of my head by which I mean when I

00:21:49,820 --> 00:21:56,779
prepared this talk so what is that that

00:21:55,009 --> 00:21:59,090
wraps decorator that makes appearances

00:21:56,779 --> 00:22:03,139
and decorator examples like so many

00:21:59,090 --> 00:22:05,149
people use at wraps why if you have a

00:22:03,139 --> 00:22:07,159
function that's decorated multiple times

00:22:05,149 --> 00:22:09,289
what order are the decorators resolved

00:22:07,159 --> 00:22:12,320
in it's kind of important for in a

00:22:09,289 --> 00:22:14,840
couple examples that I can think of and

00:22:12,320 --> 00:22:17,720
how does the app syntactic syntactic

00:22:14,840 --> 00:22:20,029
sugar actually work all of these are

00:22:17,720 --> 00:22:23,809
excellent questions I will answer most

00:22:20,029 --> 00:22:26,539
of them let's start with how the wrapper

00:22:23,809 --> 00:22:29,350
function accesses the function that is

00:22:26,539 --> 00:22:29,350
going to replace

00:22:30,530 --> 00:22:36,240
so when functions are created in Python

00:22:33,930 --> 00:22:39,390
they create a new scope for namespace

00:22:36,240 --> 00:22:42,180
for themselves and names namespaces

00:22:39,390 --> 00:22:45,000
store references that are accessible for

00:22:42,180 --> 00:22:47,610
this for that function so here for

00:22:45,000 --> 00:22:51,480
example we know that we can access some

00:22:47,610 --> 00:22:55,050
arg inside of my function printing it

00:22:51,480 --> 00:22:57,630
works so if I were to print the local

00:22:55,050 --> 00:23:00,240
scope of my function by using the

00:22:57,630 --> 00:23:02,640
built-in locals some Arg is going to

00:23:00,240 --> 00:23:07,410
appear there it's gonna say hey inside

00:23:02,640 --> 00:23:10,410
of my function some Arg is 1 so going a

00:23:07,410 --> 00:23:12,750
step further in Python it so happens

00:23:10,410 --> 00:23:16,050
that a function scope includes the

00:23:12,750 --> 00:23:17,460
scopes of functions enclosing it so if

00:23:16,050 --> 00:23:21,360
we write a function within a function

00:23:17,460 --> 00:23:24,750
who knows why we would ever do that such

00:23:21,360 --> 00:23:26,490
as here some Arg is actually still

00:23:24,750 --> 00:23:28,620
accessible from within inner function

00:23:26,490 --> 00:23:32,400
because it's present in my function

00:23:28,620 --> 00:23:35,010
scope there's a lot more that we could

00:23:32,400 --> 00:23:38,190
talk about regards to scope but in terms

00:23:35,010 --> 00:23:42,060
of decorators this is really all we need

00:23:38,190 --> 00:23:43,770
to know because the scope of an

00:23:42,060 --> 00:23:46,860
enclosing function is accessible from

00:23:43,770 --> 00:23:48,270
the function it encloses if some mark

00:23:46,860 --> 00:23:50,820
was in fact a function that you passed

00:23:48,270 --> 00:23:52,530
into my phone my function I could call

00:23:50,820 --> 00:23:59,360
it from within the inner function that'd

00:23:52,530 --> 00:24:02,610
be fine so now we've talked a lot about

00:23:59,360 --> 00:24:04,230
how good decorators are they let you

00:24:02,610 --> 00:24:06,630
wrap functions with extra behavior

00:24:04,230 --> 00:24:08,760
they're reusable they're fun you can use

00:24:06,630 --> 00:24:11,850
them for bad ideas etc etc etc they're

00:24:08,760 --> 00:24:14,070
great and now it's time to actually

00:24:11,850 --> 00:24:16,620
discuss a problem that they caused and

00:24:14,070 --> 00:24:21,480
how we can use another decorator to

00:24:16,620 --> 00:24:25,380
mitigate that problem so looking back in

00:24:21,480 --> 00:24:27,440
the implementation of my my timer we can

00:24:25,380 --> 00:24:30,240
see that the name of the function that

00:24:27,440 --> 00:24:34,320
we're going to replace on quiz is new

00:24:30,240 --> 00:24:36,510
wrapped function so that means that if

00:24:34,320 --> 00:24:38,400
we were to decorate a function with my

00:24:36,510 --> 00:24:40,020
timer and then use the dunder name

00:24:38,400 --> 00:24:42,900
attribute to get the name of that

00:24:40,020 --> 00:24:43,560
function we'd get new wrapped function

00:24:42,900 --> 00:24:45,930
instead of

00:24:43,560 --> 00:24:49,830
so which is what at least I would expect

00:24:45,930 --> 00:24:53,220
to see if I were to to access the dunder

00:24:49,830 --> 00:24:54,750
name attribute on foo and that's because

00:24:53,220 --> 00:24:58,440
what's actually happening here is the

00:24:54,750 --> 00:25:03,000
name foo points to a function whose name

00:24:58,440 --> 00:25:06,930
is new wrapped function this

00:25:03,000 --> 00:25:08,270
misdirection is I mean I think we can

00:25:06,930 --> 00:25:11,790
all agree that this is not great

00:25:08,270 --> 00:25:15,300
sometimes people write programs that

00:25:11,790 --> 00:25:17,160
rely on knowing function names for using

00:25:15,300 --> 00:25:19,680
my timer to decorate many functions and

00:25:17,160 --> 00:25:21,120
you're going to have like exponential

00:25:19,680 --> 00:25:26,130
things whose name our new wrapped

00:25:21,120 --> 00:25:29,010
function just it's bad so func tool

00:25:26,130 --> 00:25:31,020
solves this the rap's decorator from the

00:25:29,010 --> 00:25:34,230
func tools module mitigates that problem

00:25:31,020 --> 00:25:35,880
by first of all replacing the rapper's

00:25:34,230 --> 00:25:40,230
name with the name of the function it's

00:25:35,880 --> 00:25:41,820
decorating replacing the rapper's doc

00:25:40,230 --> 00:25:44,820
string with the doc string of the

00:25:41,820 --> 00:25:47,250
functions replacing and it's applied to

00:25:44,820 --> 00:25:51,450
the wrapper as you guessed it a

00:25:47,250 --> 00:25:52,650
decorator and that's why you have

00:25:51,450 --> 00:25:54,750
probably or at least hopefully

00:25:52,650 --> 00:25:58,080
frequently seen decorators that are

00:25:54,750 --> 00:26:00,510
written like this with the inner

00:25:58,080 --> 00:26:04,280
function decorated with the Raps

00:26:00,510 --> 00:26:06,480
decorator I'm going to leave

00:26:04,280 --> 00:26:12,600
implementing that decorator as an

00:26:06,480 --> 00:26:15,180
exercise for you so another common point

00:26:12,600 --> 00:26:16,470
of confusion is what order decorators

00:26:15,180 --> 00:26:18,780
are applied in when a function is

00:26:16,470 --> 00:26:20,130
decorated multiple times which other

00:26:18,780 --> 00:26:21,900
thing that I haven't even mentioned yet

00:26:20,130 --> 00:26:25,890
that functions can be decorated multiple

00:26:21,900 --> 00:26:27,540
times like here so my timer is a

00:26:25,890 --> 00:26:29,040
decorator that executes the function and

00:26:27,540 --> 00:26:32,610
then prints how long the function took

00:26:29,040 --> 00:26:36,810
to run and another decorator is another

00:26:32,610 --> 00:26:38,970
decorator that does something else there

00:26:36,810 --> 00:26:41,130
are situations in which the order these

00:26:38,970 --> 00:26:43,470
decorators are applied might matter to

00:26:41,130 --> 00:26:45,090
you like maybe you know that whatever is

00:26:43,470 --> 00:26:47,250
happening in another decorator takes a

00:26:45,090 --> 00:26:48,570
really long time and you don't care

00:26:47,250 --> 00:26:51,390
about timing it you only want to time

00:26:48,570 --> 00:26:54,720
foo so you want to make sure that

00:26:51,390 --> 00:26:57,620
another decorator is applied after my

00:26:54,720 --> 00:27:00,690
timer have you done it right

00:26:57,620 --> 00:27:03,780
well remembering that a decorator

00:27:00,690 --> 00:27:05,370
replaces what follows it with the result

00:27:03,780 --> 00:27:08,160
of the decorator called with the

00:27:05,370 --> 00:27:12,180
function following it our question is

00:27:08,160 --> 00:27:14,070
really does my timer replace foo and

00:27:12,180 --> 00:27:16,470
then in turn get replaced by another

00:27:14,070 --> 00:27:18,720
decorator or does another decorator

00:27:16,470 --> 00:27:22,230
replace foo and then get replaced by my

00:27:18,720 --> 00:27:23,670
timer and the role of the add sugar is

00:27:22,230 --> 00:27:27,780
that it replaces what immediately

00:27:23,670 --> 00:27:29,370
follows it so since my timer is on the

00:27:27,780 --> 00:27:31,890
line immediately above the definition of

00:27:29,370 --> 00:27:33,810
foo my timer replaces through first and

00:27:31,890 --> 00:27:36,870
then another decorator is called on the

00:27:33,810 --> 00:27:39,120
result of my timer called with foo and

00:27:36,870 --> 00:27:41,340
this actually makes me very happy

00:27:39,120 --> 00:27:43,140
because I came from math and science

00:27:41,340 --> 00:27:43,710
background and like that this looks

00:27:43,140 --> 00:27:47,970
normal

00:27:43,710 --> 00:27:49,470
looks normal to wrap this way also I

00:27:47,970 --> 00:27:50,370
like to think of stack decorators as

00:27:49,470 --> 00:27:53,070
layers of an onion

00:27:50,370 --> 00:27:54,990
so each decorator is going to wrap what

00:27:53,070 --> 00:27:58,790
comes below it and the higher in the

00:27:54,990 --> 00:27:58,790
stack you go the more it's going to wrap

00:28:00,950 --> 00:28:05,880
there are so many more questions so we

00:28:03,840 --> 00:28:08,790
can answer about decorators but I am

00:28:05,880 --> 00:28:10,920
running kind of low on time so I've told

00:28:08,790 --> 00:28:16,050
you what the absent tactic sugar is

00:28:10,920 --> 00:28:18,060
doing but not at all how it works that

00:28:16,050 --> 00:28:20,520
requires learning a kind of high-level

00:28:18,060 --> 00:28:25,950
the steps taken to turn Python code into

00:28:20,520 --> 00:28:28,170
executable machine instructions some

00:28:25,950 --> 00:28:29,490
decorators take arguments none of the

00:28:28,170 --> 00:28:33,510
ones that I have shown you in this talk

00:28:29,490 --> 00:28:34,160
do I'm not going to show you how that

00:28:33,510 --> 00:28:40,020
works

00:28:34,160 --> 00:28:43,050
sorry I've only addressed decorators

00:28:40,020 --> 00:28:45,030
that decorate functions but since Python

00:28:43,050 --> 00:28:49,200
2.4 decorators have been able to be

00:28:45,030 --> 00:28:51,050
applied to classes as well I haven't

00:28:49,200 --> 00:28:53,910
shown you how that works

00:28:51,050 --> 00:28:57,720
I've also only shown decorators that are

00:28:53,910 --> 00:29:00,030
functions but really what the syntactic

00:28:57,720 --> 00:29:03,210
sugar is doing is just calling the

00:29:00,030 --> 00:29:05,550
decorator so you could write a decorator

00:29:03,210 --> 00:29:07,870
as a class that has a dunder call method

00:29:05,550 --> 00:29:11,260
and that would work just fine

00:29:07,870 --> 00:29:13,780
um and finally I'm not going to

00:29:11,260 --> 00:29:16,530
implement that raps right now at PyCon

00:29:13,780 --> 00:29:18,250
in front of so many people not happening

00:29:16,530 --> 00:29:21,100
they don't really feel too bad about

00:29:18,250 --> 00:29:22,870
skipping any of this because these are

00:29:21,100 --> 00:29:25,390
all questions that you can hopefully

00:29:22,870 --> 00:29:28,860
answer for yourself armed with the

00:29:25,390 --> 00:29:33,460
knowledge that you have now in terms of

00:29:28,860 --> 00:29:36,280
how decorators work so next time

00:29:33,460 --> 00:29:42,040
somebody asks you this question just

00:29:36,280 --> 00:29:44,050
remember all the Python decorators do is

00:29:42,040 --> 00:29:45,700
replace whatever they decorate with the

00:29:44,050 --> 00:29:49,990
return value of the decorator called

00:29:45,700 --> 00:29:57,220
with that object and that's it no other

00:29:49,990 --> 00:29:59,050
rules so these are some blog posts that

00:29:57,220 --> 00:30:04,390
I found helpful when I was trying to

00:29:59,050 --> 00:30:08,110
frame how to run this explanation also

00:30:04,390 --> 00:30:12,210
there's a link to the pep that is pretty

00:30:08,110 --> 00:30:15,040
cool pretty fun read and that's

00:30:12,210 --> 00:30:17,740
basically all I got so thank you for

00:30:15,040 --> 00:30:20,679
coming thank you for braving the fire

00:30:17,740 --> 00:30:24,220
alarm thank you to everyone who liked

00:30:20,679 --> 00:30:28,900
proof read this and told me not to to

00:30:24,220 --> 00:30:30,810
talk about parsers and compilers very

00:30:28,900 --> 00:30:41,829
helpful feedback thank you

00:30:30,810 --> 00:30:41,829

YouTube URL: https://www.youtube.com/watch?v=UBSyD1RkOX0


