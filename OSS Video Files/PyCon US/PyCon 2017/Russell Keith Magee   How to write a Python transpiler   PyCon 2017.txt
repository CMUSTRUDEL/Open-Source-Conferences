Title: Russell Keith Magee   How to write a Python transpiler   PyCon 2017
Publication date: 2017-05-21
Playlist: PyCon 2017
Description: 
	"Speaker: Russell Keith-Magee

We all know Python is a powerful and expressive programming language. What you may not know is how much of the internals of Python itself is exposed for you to use and manipulate.

In this talk, you'll be introduced to the tools and libraries Python provides to manipulate the compilation and execution of Python code. You will also see how you can use those tools to target execution environments other than the CPython virtual machine.


Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:13,820 --> 00:00:23,670
good afternoon hello welcome to Portland

00:00:21,210 --> 00:00:25,140
two five four we have an amazing talk

00:00:23,670 --> 00:00:27,689
lined up three them in fact in this

00:00:25,140 --> 00:00:30,620
session our first up we have writing a

00:00:27,689 --> 00:00:35,960
transpiler by dr. Russell Keith McGee

00:00:30,620 --> 00:00:38,879
[Applause]

00:00:35,960 --> 00:00:41,550
well good morning afternoon as the case

00:00:38,879 --> 00:00:43,470
may be I'm Russell Keith McGee if you've

00:00:41,550 --> 00:00:44,820
heard my name before it's because I've

00:00:43,470 --> 00:00:47,220
been a member of the Jango Corps team

00:00:44,820 --> 00:00:48,420
for coming up on twelve years now and

00:00:47,220 --> 00:00:50,550
I've served on the technical review

00:00:48,420 --> 00:00:52,489
board for the everything from the 1.7

00:00:50,550 --> 00:00:55,050
through to the one point 11 releases

00:00:52,489 --> 00:00:56,670
however over the last couple of years

00:00:55,050 --> 00:00:58,739
I've been spending a lot more of my time

00:00:56,670 --> 00:01:00,930
working on the beware project beware is

00:00:58,739 --> 00:01:02,909
an open source collection of tools and

00:01:00,930 --> 00:01:05,700
libraries for creating native user

00:01:02,909 --> 00:01:07,799
interfaces in Python for desktops but

00:01:05,700 --> 00:01:10,370
also for iOS Android single page web

00:01:07,799 --> 00:01:13,320
apps and other new hardware platforms a

00:01:10,370 --> 00:01:15,090
big part of that work to date has been

00:01:13,320 --> 00:01:16,799
getting Python running in some

00:01:15,090 --> 00:01:20,009
interesting places most notably in the

00:01:16,799 --> 00:01:20,700
browser and on Android phones now and

00:01:20,009 --> 00:01:23,369
that's what I'm going to talk about

00:01:20,700 --> 00:01:25,079
today not about B where specifically but

00:01:23,369 --> 00:01:29,399
about the process of getting Python

00:01:25,079 --> 00:01:31,140
running in unusual locations one of the

00:01:29,399 --> 00:01:32,880
many reasons that I love Python is that

00:01:31,140 --> 00:01:35,579
it's an extremely reflective language

00:01:32,880 --> 00:01:37,259
you can use the Python language to

00:01:35,579 --> 00:01:40,320
interrogate things about the language

00:01:37,259 --> 00:01:42,030
itself as it's running so for example

00:01:40,320 --> 00:01:45,060
you can define a class one will be and

00:01:42,030 --> 00:01:47,729
declare an instance of that class called

00:01:45,060 --> 00:01:50,159
B and then ask that instance for the

00:01:47,729 --> 00:01:51,179
value of an attribute name okay

00:01:50,159 --> 00:01:52,829
nothing surprising there pretty much

00:01:51,179 --> 00:01:53,780
every programming language in the world

00:01:52,829 --> 00:01:57,450
will let you do that

00:01:53,780 --> 00:02:00,390
but Python also lets you ask whether an

00:01:57,450 --> 00:02:02,399
object has an attribute at all and as a

00:02:00,390 --> 00:02:04,829
critical detail it does that based upon

00:02:02,399 --> 00:02:06,329
a string and the value of that string

00:02:04,829 --> 00:02:08,460
can be stored in a variable which means

00:02:06,329 --> 00:02:11,430
you can then use that variable as part

00:02:08,460 --> 00:02:13,050
of the lookup process this ability to

00:02:11,430 --> 00:02:16,080
introspect is incredibly powerful

00:02:13,050 --> 00:02:19,050
languages like C C++ don't have this

00:02:16,080 --> 00:02:21,300
capability C imposes a hard line between

00:02:19,050 --> 00:02:22,890
the program that is running and the

00:02:21,300 --> 00:02:24,180
programming language that was used to

00:02:22,890 --> 00:02:25,470
write the program you can't ask

00:02:24,180 --> 00:02:28,440
questions about the

00:02:25,470 --> 00:02:29,700
that is running from inside the code now

00:02:28,440 --> 00:02:31,950
and to be clear this isn't a feature

00:02:29,700 --> 00:02:33,420
that is unique to Python many other

00:02:31,950 --> 00:02:35,310
languages are reflective in this way

00:02:33,420 --> 00:02:37,680
ruby is just as reflective as Python

00:02:35,310 --> 00:02:39,870
javascript is reflective but with an API

00:02:37,680 --> 00:02:41,310
that isn't always that helpful Java is

00:02:39,870 --> 00:02:43,230
extremely reflective but the reflection

00:02:41,310 --> 00:02:46,220
API is a bit messy to use and so it

00:02:43,230 --> 00:02:48,570
tends not to get used that heavily but

00:02:46,220 --> 00:02:50,970
pythons capabilities don't stop at

00:02:48,570 --> 00:02:52,620
introspecting the object at runtime they

00:02:50,970 --> 00:02:55,470
also extend to the compilation process

00:02:52,620 --> 00:02:56,880
itself if you've been adventurous with

00:02:55,470 --> 00:02:58,260
the Python shell you might know about

00:02:56,880 --> 00:03:01,980
two of those tools the built in methods

00:02:58,260 --> 00:03:04,680
xx and eval xx will take a single Python

00:03:01,980 --> 00:03:06,390
statement as a string and execute it

00:03:04,680 --> 00:03:08,790
give it a Python string that contains

00:03:06,390 --> 00:03:11,490
Python code it will run that code and

00:03:08,790 --> 00:03:12,900
give you back the result eval is similar

00:03:11,490 --> 00:03:14,580
but instead of taking a single statement

00:03:12,900 --> 00:03:16,230
it takes either it takes either a block

00:03:14,580 --> 00:03:18,870
of codes or multiple statements in a

00:03:16,230 --> 00:03:20,970
string or a code object the precompiled

00:03:18,870 --> 00:03:22,230
piece of Python code and then does the

00:03:20,970 --> 00:03:25,590
same thing it runs that code and gives

00:03:22,230 --> 00:03:27,510
you back a result but there are some

00:03:25,590 --> 00:03:29,130
less well-known options too and they're

00:03:27,510 --> 00:03:31,080
part of the Python standard library if

00:03:29,130 --> 00:03:32,970
you want to look at your code in a

00:03:31,080 --> 00:03:34,650
structured fashion you can use the ast

00:03:32,970 --> 00:03:37,470
module short for the abstract syntax

00:03:34,650 --> 00:03:39,630
tree the ast is the result that the

00:03:37,470 --> 00:03:41,580
pricing compiler has after the code has

00:03:39,630 --> 00:03:42,360
been parsed but before it's been

00:03:41,580 --> 00:03:44,850
compiled

00:03:42,360 --> 00:03:47,519
there's also pi compile that is a method

00:03:44,850 --> 00:03:50,970
that will take a Python file and compile

00:03:47,519 --> 00:03:53,280
it but won't run it so you'll get a py C

00:03:50,970 --> 00:03:55,709
file the compiled output of the Python

00:03:53,280 --> 00:03:57,989
compiler but the code itself won't have

00:03:55,709 --> 00:03:59,489
been executed this can be useful if the

00:03:57,989 --> 00:04:01,890
code that's being Co code that you're

00:03:59,489 --> 00:04:03,120
talking about has side effects or you

00:04:01,890 --> 00:04:05,880
just want to manipulate the bytecode

00:04:03,120 --> 00:04:08,310
without actually running it once the

00:04:05,880 --> 00:04:10,890
code has been compiled the disk module

00:04:08,310 --> 00:04:13,290
for short for disassemble will let you

00:04:10,890 --> 00:04:16,530
pull apart the compiled bytecode and see

00:04:13,290 --> 00:04:17,850
what was produced ok but why would you

00:04:16,530 --> 00:04:20,340
care why do you need to use these

00:04:17,850 --> 00:04:22,919
modules well the good news is a day to

00:04:20,340 --> 00:04:25,410
day Python user you probably don't but

00:04:22,919 --> 00:04:27,930
there are times when you do need to dig

00:04:25,410 --> 00:04:30,510
into internals and work out what exactly

00:04:27,930 --> 00:04:33,300
is going on and you can use these tools

00:04:30,510 --> 00:04:34,620
to transform Python into something else

00:04:33,300 --> 00:04:36,479
and then so we're going to look at today

00:04:34,620 --> 00:04:38,129
how to use these modules in particular

00:04:36,479 --> 00:04:40,770
decent ast to Train

00:04:38,129 --> 00:04:43,860
form Python code so that it can run in

00:04:40,770 --> 00:04:45,719
new environments which brings me back to

00:04:43,860 --> 00:04:48,059
my original problem I love paisa

00:04:45,719 --> 00:04:50,519
pythons are great that's not the problem

00:04:48,059 --> 00:04:53,099
the problem is that sometimes you can't

00:04:50,519 --> 00:04:55,499
run Python or at least you can't run C

00:04:53,099 --> 00:04:58,159
Python and that distinction between C

00:04:55,499 --> 00:05:01,319
Python and Python is an important one

00:04:58,159 --> 00:05:03,029
Python the language is an abstract thing

00:05:01,319 --> 00:05:04,409
it's a specification of syntax and

00:05:03,029 --> 00:05:06,119
semantics that describes how a

00:05:04,409 --> 00:05:08,129
particular sequence of human readable

00:05:06,119 --> 00:05:09,479
bytes will be interpreted by a computer

00:05:08,129 --> 00:05:10,019
to make the computer do something

00:05:09,479 --> 00:05:12,360
interesting

00:05:10,019 --> 00:05:14,399
then there's the Python the interpreter

00:05:12,360 --> 00:05:16,169
that you install and run when you tell

00:05:14,399 --> 00:05:17,819
someone to go to the Python web site and

00:05:16,169 --> 00:05:19,559
download the Installer you're not

00:05:17,819 --> 00:05:22,229
strictly talking about Python you're

00:05:19,559 --> 00:05:24,029
almost certainly talking about C Python

00:05:22,229 --> 00:05:25,830
which is the de-facto reference

00:05:24,029 --> 00:05:28,889
implementation of the Python language

00:05:25,830 --> 00:05:30,990
specification this separation between

00:05:28,889 --> 00:05:33,389
implementation and specification is

00:05:30,990 --> 00:05:35,699
valuable because it means that C Python

00:05:33,389 --> 00:05:38,009
isn't the only way that you can that

00:05:35,699 --> 00:05:40,499
Python code can be interpreted there are

00:05:38,009 --> 00:05:43,860
features of Python as experienced by end

00:05:40,499 --> 00:05:45,869
users that are features of C Python not

00:05:43,860 --> 00:05:47,610
the language itself the Gil is the

00:05:45,869 --> 00:05:49,199
classic example of that the global

00:05:47,610 --> 00:05:51,990
interpreter lock the perpetual bane of

00:05:49,199 --> 00:05:55,409
Python performance discussions is not an

00:05:51,990 --> 00:05:57,809
inherent feature of C Python it's a

00:05:55,409 --> 00:06:00,659
feature of the specific implementation

00:05:57,809 --> 00:06:02,429
of Python C Python and because of the

00:06:00,659 --> 00:06:04,740
way it's implemented it needs to have a

00:06:02,429 --> 00:06:07,709
gill or if Larry Hastings is awake maybe

00:06:04,740 --> 00:06:09,749
it doesn't other implementations of the

00:06:07,709 --> 00:06:12,240
Python language specification like jason

00:06:09,749 --> 00:06:13,619
pi pi stack 'less they don't have a gill

00:06:12,240 --> 00:06:15,569
because of the way they're implemented

00:06:13,619 --> 00:06:17,759
and if you're going to try and get

00:06:15,569 --> 00:06:18,689
python code running somewhere else then

00:06:17,759 --> 00:06:21,199
you're going to need a Python

00:06:18,689 --> 00:06:24,119
interpreter that supports that platform

00:06:21,199 --> 00:06:26,039
one way not the only way mind but one

00:06:24,119 --> 00:06:27,629
way is transformation the word

00:06:26,039 --> 00:06:30,059
transformation comes from transforming

00:06:27,629 --> 00:06:33,300
compiler a compiler that transforms code

00:06:30,059 --> 00:06:35,579
from one form to another form this

00:06:33,300 --> 00:06:36,719
usually means source code to source code

00:06:35,579 --> 00:06:38,719
depending upon what platform you're

00:06:36,719 --> 00:06:41,339
targeting there may be other options

00:06:38,719 --> 00:06:43,259
okay so what does this mean in practice

00:06:41,339 --> 00:06:46,199
you have some Python code we want to run

00:06:43,259 --> 00:06:48,329
that code without using C Python so

00:06:46,199 --> 00:06:50,939
let's take an example there's a case

00:06:48,329 --> 00:06:52,020
study is a simple Python function it

00:06:50,939 --> 00:06:54,570
sings you a little song

00:06:52,020 --> 00:06:56,400
it's a full loop over a descending range

00:06:54,570 --> 00:06:59,100
with a couple of print statements on

00:06:56,400 --> 00:07:01,590
every loop if we put all this code into

00:06:59,100 --> 00:07:05,100
example pie and then we run Python

00:07:01,590 --> 00:07:08,370
example Pi Python will parse and compile

00:07:05,100 --> 00:07:10,050
this code into byte code byte code is a

00:07:08,370 --> 00:07:12,240
little bit like high-level assembly

00:07:10,050 --> 00:07:13,650
language it's a stack based machine with

00:07:12,240 --> 00:07:15,180
basic primitives for pushing and

00:07:13,650 --> 00:07:17,700
positing values onto a stack and so on

00:07:15,180 --> 00:07:19,710
there's about 150 bytecode instructions

00:07:17,700 --> 00:07:21,780
the C Python virtual machine understands

00:07:19,710 --> 00:07:23,100
and the Python executable is essentially

00:07:21,780 --> 00:07:26,910
just a program for running and

00:07:23,100 --> 00:07:29,400
evaluating those 150 instructions Python

00:07:26,910 --> 00:07:31,260
then gives you the tools to inspect that

00:07:29,400 --> 00:07:32,490
bytecode the dis module which I

00:07:31,260 --> 00:07:34,740
mentioned earlier allows you to

00:07:32,490 --> 00:07:36,390
disassemble any function or class or

00:07:34,740 --> 00:07:38,940
whatever into its bytecode

00:07:36,390 --> 00:07:42,750
representation so if you run this over

00:07:38,940 --> 00:07:44,610
our sing method what do you get well you

00:07:42,750 --> 00:07:46,680
get the raw bytecode instructions this

00:07:44,610 --> 00:07:49,080
is the human readable interpretation of

00:07:46,680 --> 00:07:51,810
what is contained in the py C file it's

00:07:49,080 --> 00:07:54,150
a sequence of assembly like instructions

00:07:51,810 --> 00:07:55,980
we can complete art by configuring a

00:07:54,150 --> 00:07:58,380
loop setting the instruction offset for

00:07:55,980 --> 00:08:00,630
the bounds of the loop down to offset 47

00:07:58,380 --> 00:08:02,820
we load a global symbol called range

00:08:00,630 --> 00:08:04,680
that's the range built-in function we

00:08:02,820 --> 00:08:06,900
load three constants onto the stack we

00:08:04,680 --> 00:08:08,010
load 100 0 and minus 1 those are the

00:08:06,900 --> 00:08:10,140
three arguments that are going to go

00:08:08,010 --> 00:08:12,180
into range and then we invoke the

00:08:10,140 --> 00:08:13,380
function the call function we going to

00:08:12,180 --> 00:08:15,060
call has three positional arguments

00:08:13,380 --> 00:08:16,740
they're the three most recent argument

00:08:15,060 --> 00:08:18,300
values that have been pushed on load

00:08:16,740 --> 00:08:20,600
under the stack and the function we're

00:08:18,300 --> 00:08:23,400
going to call is the one before that

00:08:20,600 --> 00:08:25,260
so line 15

00:08:23,400 --> 00:08:28,130
although the offset 15 is effectively

00:08:25,260 --> 00:08:30,480
the call range 100 comma 0 comma minus 1

00:08:28,130 --> 00:08:33,450
that pushes the result back on to the

00:08:30,480 --> 00:08:35,790
stack which is an iterator so we ask for

00:08:33,450 --> 00:08:38,010
the evaluation of that iterator and then

00:08:35,790 --> 00:08:41,190
start the actual for loop and so on and

00:08:38,010 --> 00:08:43,470
so on ok so what can we do with that

00:08:41,190 --> 00:08:45,660
well option 1 we can implement a C

00:08:43,470 --> 00:08:47,370
Python bytecode machine and while that

00:08:45,660 --> 00:08:49,590
might seem like a daunting prospect it's

00:08:47,370 --> 00:08:51,390
actually not that difficult C Python

00:08:49,590 --> 00:08:54,240
bytecode like I said earlier only about

00:08:51,390 --> 00:08:55,890
150 instructions or so a good chunk of

00:08:54,240 --> 00:08:57,510
which are basic mathematical primitives

00:08:55,890 --> 00:08:59,000
just play addition subtraction

00:08:57,510 --> 00:09:00,930
multiplication division so

00:08:59,000 --> 00:09:04,080
re-implementing those doesn't actually

00:09:00,930 --> 00:09:05,850
take that much code how much code well a

00:09:04,080 --> 00:09:08,009
full Python interpreter

00:09:05,850 --> 00:09:10,350
in Python is the subject of chapter 12

00:09:08,009 --> 00:09:11,040
volume 4 of architecture open source in

00:09:10,350 --> 00:09:13,319
that chapter

00:09:11,040 --> 00:09:15,120
alison Kaptur presents a full pipe full

00:09:13,319 --> 00:09:17,310
implementation of a Python virtual

00:09:15,120 --> 00:09:20,250
machine written in pure Python and

00:09:17,310 --> 00:09:22,889
there's the subtitle suggests it's less

00:09:20,250 --> 00:09:24,540
than 500 lines of code the biggest

00:09:22,889 --> 00:09:26,730
complication is that C Python makes no

00:09:24,540 --> 00:09:29,940
guarantees of compatibility in byte code

00:09:26,730 --> 00:09:31,560
versions between 3.4 3.5 3.6 there have

00:09:29,940 --> 00:09:33,540
been several major changes in byte code

00:09:31,560 --> 00:09:35,279
formats and interpretations but you can

00:09:33,540 --> 00:09:37,339
stay on top of these it's not a major

00:09:35,279 --> 00:09:40,170
problem just kind of an annoyance and

00:09:37,339 --> 00:09:41,459
this is what Batavia does but Tavia is

00:09:40,170 --> 00:09:43,440
an implementation of the C Python

00:09:41,459 --> 00:09:45,089
virtual machine written in JavaScript

00:09:43,440 --> 00:09:47,459
and because it's written in JavaScript

00:09:45,089 --> 00:09:49,500
it can run in the browser if you ever

00:09:47,459 --> 00:09:51,149
seen projects like main a multiple

00:09:49,500 --> 00:09:53,130
arcade machine emulator or archive.org

00:09:51,149 --> 00:09:54,810
console living room these are doing

00:09:53,130 --> 00:09:57,060
exactly the same thing they take the

00:09:54,810 --> 00:09:59,459
cartridge images of classic games and

00:09:57,060 --> 00:10:01,290
provide an in software implementation of

00:09:59,459 --> 00:10:03,779
the hardware that used to run them the

00:10:01,290 --> 00:10:06,480
Atari 2600 Commodore 64 whatever else

00:10:03,779 --> 00:10:07,980
now this isn't transforming anything

00:10:06,480 --> 00:10:10,740
it's just providing an alternative

00:10:07,980 --> 00:10:13,250
alternative interpreter for the same

00:10:10,740 --> 00:10:15,420
compiled binary code you've always had

00:10:13,250 --> 00:10:18,000
okay so what else can you do well you

00:10:15,420 --> 00:10:20,550
can try transforming code at the

00:10:18,000 --> 00:10:22,170
compiled binary level let's go back to

00:10:20,550 --> 00:10:24,089
our example program we've written it in

00:10:22,170 --> 00:10:25,560
Python here but we could have written it

00:10:24,089 --> 00:10:26,750
in many other languages like for example

00:10:25,560 --> 00:10:29,730
Java

00:10:26,750 --> 00:10:31,079
okay so here's some Java in Java

00:10:29,730 --> 00:10:33,569
interpretation of exactly the same

00:10:31,079 --> 00:10:36,689
program we compile this with Java C and

00:10:33,569 --> 00:10:39,529
we'll get a single ask file and if we

00:10:36,689 --> 00:10:42,870
look into that class file what do we see

00:10:39,529 --> 00:10:45,779
well you see bytecode now okay it's

00:10:42,870 --> 00:10:49,500
different bytecode to python but it is a

00:10:45,779 --> 00:10:50,910
stack based a bytecode language and

00:10:49,500 --> 00:10:53,160
there are a lot of commonalities you

00:10:50,910 --> 00:10:54,870
push any button byte integer on to the

00:10:53,160 --> 00:10:56,339
stack store it as a variable loaded

00:10:54,870 --> 00:10:57,930
again jump to the end of a loop on a

00:10:56,339 --> 00:11:00,959
condition load a symbol allocate new

00:10:57,930 --> 00:11:03,660
objects invoke a method so if they're

00:11:00,959 --> 00:11:06,269
both bytecode and they're both stack

00:11:03,660 --> 00:11:09,720
based can you convert from one to the

00:11:06,269 --> 00:11:11,910
other well yeah you can it's not

00:11:09,720 --> 00:11:13,410
necessarily easy though for simple

00:11:11,910 --> 00:11:14,790
programs like this one it yet it's

00:11:13,410 --> 00:11:16,589
fairly straightforward our push is a

00:11:14,790 --> 00:11:19,080
push you just got a account for the

00:11:16,589 --> 00:11:20,730
change in language but when

00:11:19,080 --> 00:11:22,770
you get beyond really really simple

00:11:20,730 --> 00:11:24,930
programs it's not quite as simple as an

00:11:22,770 --> 00:11:25,950
instruction by instruction conversion we

00:11:24,930 --> 00:11:28,530
take something like exceptions for

00:11:25,950 --> 00:11:30,300
example Python has an explicit set of

00:11:28,530 --> 00:11:32,790
byte code operations for handling

00:11:30,300 --> 00:11:34,800
exceptions and block context Java

00:11:32,790 --> 00:11:37,890
bytecode doesn't have instructions for

00:11:34,800 --> 00:11:39,780
exceptions what it has is metadata

00:11:37,890 --> 00:11:41,550
attached to the code itself to set to

00:11:39,780 --> 00:11:44,750
give the description of the context in

00:11:41,550 --> 00:11:46,380
which certain exceptions may be handled

00:11:44,750 --> 00:11:49,500
excuse me

00:11:46,380 --> 00:11:51,630
it's not ambit so if you have nested

00:11:49,500 --> 00:11:53,100
loops in your Python code it can

00:11:51,630 --> 00:11:54,960
sometimes be difficult to tell the

00:11:53,100 --> 00:11:56,640
difference between the end of an inner

00:11:54,960 --> 00:11:58,080
loop and the end of an outer loop it's

00:11:56,640 --> 00:12:00,150
not ambiguous it's just kind of

00:11:58,080 --> 00:12:01,680
difficult to reverse engineer if you're

00:12:00,150 --> 00:12:04,170
trying to work out the equivalent code

00:12:01,680 --> 00:12:05,460
after all black code is the output of a

00:12:04,170 --> 00:12:07,230
compilation process and sometimes

00:12:05,460 --> 00:12:08,580
compilers will actually optimize things

00:12:07,230 --> 00:12:11,460
to remove stuff that's just getting in

00:12:08,580 --> 00:12:12,810
the way of a fast code path so you as a

00:12:11,460 --> 00:12:15,360
result of that optimization you lose

00:12:12,810 --> 00:12:17,090
some of the context around code that

00:12:15,360 --> 00:12:19,260
would make it easier to reverse engineer

00:12:17,090 --> 00:12:22,130
what you really need to be able to see

00:12:19,260 --> 00:12:24,780
is the code as it's being compiled and

00:12:22,130 --> 00:12:26,730
that's what the ast module is for the

00:12:24,780 --> 00:12:28,860
usage just as simple as this import the

00:12:26,730 --> 00:12:31,440
module call pars and what you get back

00:12:28,860 --> 00:12:34,020
is the root of the parse tree you give

00:12:31,440 --> 00:12:38,100
it a Python file a module and it gives

00:12:34,020 --> 00:12:39,990
you back a module now that module itself

00:12:38,100 --> 00:12:42,030
is not useful code it isn't the same

00:12:39,990 --> 00:12:43,620
module object you get from actually

00:12:42,030 --> 00:12:47,820
importing it's an in-memory

00:12:43,620 --> 00:12:50,010
representation of the past code and as

00:12:47,820 --> 00:12:53,070
the name abstract syntax tree suggests

00:12:50,010 --> 00:12:55,260
it's a tree the module is a single child

00:12:53,070 --> 00:12:56,910
the root node the body the body is a

00:12:55,260 --> 00:12:58,440
series of statements in our case a

00:12:56,910 --> 00:13:00,720
single statement a function definition

00:12:58,440 --> 00:13:02,310
that function definition has some

00:13:00,720 --> 00:13:04,200
attributes the name of the function the

00:13:02,310 --> 00:13:05,790
arguments to the function and it also

00:13:04,200 --> 00:13:08,760
has a body the statements of that

00:13:05,790 --> 00:13:11,250
function and so on and you can traverse

00:13:08,760 --> 00:13:12,930
this tree and respond to the various

00:13:11,250 --> 00:13:16,200
nodes of that tree and the attributes of

00:13:12,930 --> 00:13:18,060
the nodes of the tree as needed to make

00:13:16,200 --> 00:13:19,920
it even easier to walk the tree the ast

00:13:18,060 --> 00:13:22,500
module provides an implementation of the

00:13:19,920 --> 00:13:25,020
classic visitor pattern so you can hook

00:13:22,500 --> 00:13:28,470
into the passing process and use that as

00:13:25,020 --> 00:13:30,240
a trigger to stimulate activity what

00:13:28,470 --> 00:13:31,320
activity you stimulate depends upon what

00:13:30,240 --> 00:13:32,380
sort of transpiler you're trying to

00:13:31,320 --> 00:13:35,300
build

00:13:32,380 --> 00:13:37,430
now the simplest kind is a straight code

00:13:35,300 --> 00:13:39,290
to code transpiler this code here is a

00:13:37,430 --> 00:13:41,450
painfully naive start of a version that

00:13:39,290 --> 00:13:43,310
would output JavaScript but hopefully it

00:13:41,450 --> 00:13:46,100
demonstrates the idea whenever you see a

00:13:43,310 --> 00:13:48,440
function declaration a function deff you

00:13:46,100 --> 00:13:51,200
output as a string to the console the

00:13:48,440 --> 00:13:53,060
JavaScript function declaration and then

00:13:51,200 --> 00:13:54,740
the arguments the open brace the

00:13:53,060 --> 00:13:56,750
processing the child nodes and then the

00:13:54,740 --> 00:14:00,200
pro closing brace when you see a for

00:13:56,750 --> 00:14:02,270
loop visit for now you start outputting

00:14:00,200 --> 00:14:03,620
a JavaScript start for statement you ask

00:14:02,270 --> 00:14:05,300
the loop for the name of the loop

00:14:03,620 --> 00:14:06,940
variable interrogate the start values

00:14:05,300 --> 00:14:09,680
the itália the end conditions and so on

00:14:06,940 --> 00:14:11,810
now like I said this this implementation

00:14:09,680 --> 00:14:13,370
is very very naive it ignores function

00:14:11,810 --> 00:14:15,140
return values it doesn't handle keyword

00:14:13,370 --> 00:14:16,730
arguments it's most of the detail in

00:14:15,140 --> 00:14:18,950
converting an iterator based for and

00:14:16,730 --> 00:14:20,840
with C style for it also outputs the

00:14:18,950 --> 00:14:22,100
console rather than to a file I've

00:14:20,840 --> 00:14:24,200
skipped over the part where we convert

00:14:22,100 --> 00:14:26,750
pipe skipped over the part where we

00:14:24,200 --> 00:14:28,250
convert a Python style iterator into a c

00:14:26,750 --> 00:14:30,080
style for loop implementing those

00:14:28,250 --> 00:14:32,690
details is left as an exercise for the

00:14:30,080 --> 00:14:35,300
reader but there's also a deeper problem

00:14:32,690 --> 00:14:36,830
here let's take this as a really simple

00:14:35,300 --> 00:14:39,770
example these two code snippets are

00:14:36,830 --> 00:14:41,840
cosmetically the same modulo a language

00:14:39,770 --> 00:14:44,870
translation first one it's written in

00:14:41,840 --> 00:14:47,510
JavaScript call scope test X is X equal

00:14:44,870 --> 00:14:49,160
x times y call scope test and print the

00:14:47,510 --> 00:14:50,570
output second one's written in Python

00:14:49,160 --> 00:14:52,760
the function called scope test does x

00:14:50,570 --> 00:14:55,460
equals x times y call scope test print

00:14:52,760 --> 00:14:57,200
the output what happens when you run

00:14:55,460 --> 00:15:02,330
them what does the JavaScript out

00:14:57,200 --> 00:15:06,380
console output that puts 30 what about

00:15:02,330 --> 00:15:08,930
the Python well it outputs unbound local

00:15:06,380 --> 00:15:11,300
error because the local variable X has

00:15:08,930 --> 00:15:13,460
been referenced before assignment why

00:15:11,300 --> 00:15:16,070
because JavaScript language scoping

00:15:13,460 --> 00:15:17,810
rules put the X into global scope python

00:15:16,070 --> 00:15:20,720
scoping rules means X can be accessed

00:15:17,810 --> 00:15:23,420
for reading but not for modification now

00:15:20,720 --> 00:15:25,220
okay sure for the patterns if you use an

00:15:23,420 --> 00:15:27,530
es6 let and the javascript version or a

00:15:25,220 --> 00:15:29,930
global in the python version you'd get

00:15:27,530 --> 00:15:31,760
output parity this is an intentionally

00:15:29,930 --> 00:15:33,290
simple example to illustrate a point the

00:15:31,760 --> 00:15:34,640
problem gets a whole lot more complex

00:15:33,290 --> 00:15:38,360
when you have structures like closures

00:15:34,640 --> 00:15:40,970
involved and what's the native es6

00:15:38,360 --> 00:15:44,030
representation of a yield statement what

00:15:40,970 --> 00:15:45,470
about yield from if you have to deal

00:15:44,030 --> 00:15:46,100
with those problems the generator

00:15:45,470 --> 00:15:47,690
javascript

00:15:46,100 --> 00:15:49,490
code ends up being a lot more complex

00:15:47,690 --> 00:15:50,630
than just a straight you know walk the

00:15:49,490 --> 00:15:52,790
tree and output a slightly different

00:15:50,630 --> 00:15:54,259
variation of the language if you don't

00:15:52,790 --> 00:15:55,459
handle those those sort of problems you

00:15:54,259 --> 00:15:58,190
end up with something like CoffeeScript

00:15:55,459 --> 00:16:00,470
the language that is Python like but not

00:15:58,190 --> 00:16:02,269
actually Python and that may not matter

00:16:00,470 --> 00:16:03,290
it depends on your use case but you have

00:16:02,269 --> 00:16:05,060
to be clear about what it is you're

00:16:03,290 --> 00:16:07,699
trying to achieve with your compiled

00:16:05,060 --> 00:16:09,740
output okay so what other options do you

00:16:07,699 --> 00:16:12,199
have well you can also transpile

00:16:09,740 --> 00:16:14,800
directly to your final representation

00:16:12,199 --> 00:16:19,029
for example Java is a compiled language

00:16:14,800 --> 00:16:19,029
it compiles to Java

00:16:19,089 --> 00:16:23,000
the advantage of bytecode is that it's

00:16:21,560 --> 00:16:25,009
just a set of primitives there aren't

00:16:23,000 --> 00:16:26,600
any complex scoping rules here it's just

00:16:25,009 --> 00:16:28,519
some the same sort of basic push onto

00:16:26,600 --> 00:16:31,670
stack pop up a stack invoke function as

00:16:28,519 --> 00:16:34,100
primitive mechanisms Java will compile

00:16:31,670 --> 00:16:36,680
to take Java source code and compile

00:16:34,100 --> 00:16:39,199
through those primitives but so can any

00:16:36,680 --> 00:16:41,180
other language a class file at the end

00:16:39,199 --> 00:16:42,920
of the day is just bytes on disk and as

00:16:41,180 --> 00:16:44,810
long as you can generate bytes on disk

00:16:42,920 --> 00:16:47,089
in the right order you can produce a

00:16:44,810 --> 00:16:51,529
java virtual machine compatible class

00:16:47,089 --> 00:16:54,430
file to do this we retask our visitor to

00:16:51,529 --> 00:16:56,509
produce bytecode rather than source code

00:16:54,430 --> 00:16:58,790
effectively what you end up doing is a

00:16:56,509 --> 00:17:01,490
tree transformation transforming an AST

00:16:58,790 --> 00:17:04,069
of Python code to an AST of Java

00:17:01,490 --> 00:17:06,470
bytecode that is a representation of a

00:17:04,069 --> 00:17:08,929
Java class file and then as a final step

00:17:06,470 --> 00:17:10,850
outputting that Java class file a as -

00:17:08,929 --> 00:17:14,689
as Java that have a class but class file

00:17:10,850 --> 00:17:16,549
ast as bytes on disk the structure of a

00:17:14,689 --> 00:17:18,169
Java class file is extraordinarily well

00:17:16,549 --> 00:17:19,819
documented and it's very easy to break

00:17:18,169 --> 00:17:22,309
down into a tree like structure

00:17:19,819 --> 00:17:24,169
consisting of a symbol table and then

00:17:22,309 --> 00:17:25,579
class metadata and individual functions

00:17:24,169 --> 00:17:26,329
each of which have their own metadata

00:17:25,579 --> 00:17:28,370
descriptions

00:17:26,329 --> 00:17:30,200
something like added Java function

00:17:28,370 --> 00:17:31,909
pretty much Maps directly to a node

00:17:30,200 --> 00:17:33,590
inside the java class through a glass

00:17:31,909 --> 00:17:35,390
class file tree and if you make the

00:17:33,590 --> 00:17:36,919
visitor track context then you can

00:17:35,390 --> 00:17:39,020
establish whether you're inside a class

00:17:36,919 --> 00:17:40,549
or inside a global context and based

00:17:39,020 --> 00:17:42,500
upon that context you can make decisions

00:17:40,549 --> 00:17:46,010
like whether or not to set the static

00:17:42,500 --> 00:17:48,080
flag on the java method but what about

00:17:46,010 --> 00:17:49,610
something like add Java for well a for

00:17:48,080 --> 00:17:51,409
loop is really just a sequence of

00:17:49,610 --> 00:17:53,299
instructions some preamble and some post

00:17:51,409 --> 00:17:55,280
amble that sets up the conditions of the

00:17:53,299 --> 00:17:57,770
loop some internal code which is itself

00:17:55,280 --> 00:17:59,929
a sequence of instructions but in order

00:17:57,770 --> 00:18:03,440
to do that you need some additional tool

00:17:59,929 --> 00:18:04,940
if we go back to the bytecode version of

00:18:03,440 --> 00:18:06,799
our program there are three things worth

00:18:04,940 --> 00:18:09,799
noting the first is a declaration of max

00:18:06,799 --> 00:18:11,899
stack the JVM requires you to pre

00:18:09,799 --> 00:18:14,119
declare how deep your stack is going to

00:18:11,899 --> 00:18:15,590
be as a result of execution if your

00:18:14,119 --> 00:18:18,019
stack is too large you end up wasting

00:18:15,590 --> 00:18:19,580
memory if it's too small the JVM will

00:18:18,019 --> 00:18:22,519
crash because it hasn't allocated enough

00:18:19,580 --> 00:18:24,889
memory secondly there's max locals the

00:18:22,519 --> 00:18:26,659
JVM requires you to declare how many

00:18:24,889 --> 00:18:29,749
variables your stack based virtual

00:18:26,659 --> 00:18:32,509
machine is going to use Python stores in

00:18:29,749 --> 00:18:35,419
retrieves variables by name Java uses an

00:18:32,509 --> 00:18:37,779
index I store one means store the

00:18:35,419 --> 00:18:40,249
current top of the stack as variable one

00:18:37,779 --> 00:18:42,289
so you need to track how many variables

00:18:40,249 --> 00:18:44,029
are being used and what number you've

00:18:42,289 --> 00:18:46,070
allocated to which Python variable

00:18:44,029 --> 00:18:48,649
because if your Python code loads a

00:18:46,070 --> 00:18:52,340
symbol you need to know which Java local

00:18:48,649 --> 00:18:55,519
to load lastly the instruction offset

00:18:52,340 --> 00:18:57,860
for if GE 34 now that's a comparison of

00:18:55,519 --> 00:18:59,629
the value at the top of the stack and if

00:18:57,860 --> 00:19:01,850
it's greater than or equal to zero

00:18:59,629 --> 00:19:05,720
jump forward 34 bytes of instructions

00:19:01,850 --> 00:19:08,450
not to instruction 34 forward 34

00:19:05,720 --> 00:19:11,450
instructions to instruction 38 which is

00:19:08,450 --> 00:19:13,220
34 more than the car instruction so when

00:19:11,450 --> 00:19:14,869
you're processing the body content of

00:19:13,220 --> 00:19:16,940
your loop you need to keep track of the

00:19:14,869 --> 00:19:19,009
size of its instruction you add because

00:19:16,940 --> 00:19:22,129
you need to post process to set the

00:19:19,009 --> 00:19:24,139
offset of the if GE instruction so it's

00:19:22,129 --> 00:19:25,519
not just a tree representation of a

00:19:24,139 --> 00:19:27,230
class file we're vetting building here

00:19:25,519 --> 00:19:29,629
we need to have a bunch of accounting in

00:19:27,230 --> 00:19:31,779
place to track pythons variable usage

00:19:29,629 --> 00:19:34,519
the size of generated code and so on

00:19:31,779 --> 00:19:36,320
okay so we set up that tracking what

00:19:34,519 --> 00:19:39,289
about statements like yields how do you

00:19:36,320 --> 00:19:41,450
handle those Java the language doesn't

00:19:39,289 --> 00:19:42,320
have the concept of yielding and Java

00:19:41,450 --> 00:19:44,659
the bytecode

00:19:42,320 --> 00:19:46,999
is just a set of primitives well what

00:19:44,659 --> 00:19:49,249
you need to do is build the logic for a

00:19:46,999 --> 00:19:51,080
yield statement using the primitives

00:19:49,249 --> 00:19:52,399
that you have available but because

00:19:51,080 --> 00:19:54,139
you're dealing with primitives you don't

00:19:52,399 --> 00:19:57,049
have to think about what Java source

00:19:54,139 --> 00:19:58,789
code would produce this bytecode you can

00:19:57,049 --> 00:19:59,389
just write bytecode that does what you

00:19:58,789 --> 00:20:01,700
need it to

00:19:59,389 --> 00:20:05,139
and what's a yield well it's a function

00:20:01,700 --> 00:20:05,139
that knows how to resume itself Midway

00:20:05,289 --> 00:20:10,309
so here on the Left we've got a simple

00:20:08,450 --> 00:20:12,830
example of a generator called Jenny

00:20:10,309 --> 00:20:13,639
which yields we serve it to yield

00:20:12,830 --> 00:20:16,219
statements in it

00:20:13,639 --> 00:20:18,289
on the right is a sort of a Python II

00:20:16,219 --> 00:20:20,539
pseudo coded kind of interpretation of

00:20:18,289 --> 00:20:22,690
that function as not just a function

00:20:20,539 --> 00:20:26,450
it's a full class

00:20:22,690 --> 00:20:27,950
it's stateful when you initially invoke

00:20:26,450 --> 00:20:29,929
the generator in Python that's

00:20:27,950 --> 00:20:32,749
instantiating an instance of the

00:20:29,929 --> 00:20:34,450
generator and it stores the arguments

00:20:32,749 --> 00:20:38,359
that were used to invoke the generator

00:20:34,450 --> 00:20:40,759
when you call next to iterate on to the

00:20:38,359 --> 00:20:42,499
next value of the generator it's a

00:20:40,759 --> 00:20:46,129
normal method on the generator object

00:20:42,499 --> 00:20:47,899
now that John generator has state so it

00:20:46,129 --> 00:20:50,299
can track which yield point it was

00:20:47,899 --> 00:20:51,320
previously at and the generator if this

00:20:50,299 --> 00:20:53,479
are if the generators been yielded

00:20:51,320 --> 00:20:55,249
before it can jump forward use a go to

00:20:53,479 --> 00:20:57,829
effectively to jump forward of that line

00:20:55,249 --> 00:20:59,389
of code now this code doesn't make any

00:20:57,829 --> 00:21:01,399
sense in Java it doesn't make any sense

00:20:59,389 --> 00:21:03,909
in byte code but it's cursor in Python

00:21:01,399 --> 00:21:07,190
but it's completely legal Java bytecode

00:21:03,909 --> 00:21:09,619
because Java bytecode has a primitive to

00:21:07,190 --> 00:21:12,709
jump move the instruction forward

00:21:09,619 --> 00:21:14,570
expires if there's no current yield

00:21:12,709 --> 00:21:16,279
point we just keep executing the code as

00:21:14,570 --> 00:21:19,940
normal set of values start the loop and

00:21:16,279 --> 00:21:21,889
then we yield a yield is three things

00:21:19,940 --> 00:21:34,909
first we save the current state of the

00:21:21,889 --> 00:21:37,719
generator the Python ast code I didn't

00:21:34,909 --> 00:21:37,719
do it it wasn't me

00:21:42,789 --> 00:22:20,259
I mean I knew where this was hot content

00:22:01,869 --> 00:22:21,909
but still I was out here okay okay all

00:22:20,259 --> 00:22:23,889
right I can't can I work through this or

00:22:21,909 --> 00:22:25,809
is there is this going to be a problem a

00:22:23,889 --> 00:22:29,319
good guy all right on the next

00:22:25,809 --> 00:22:30,849
invocation where we we saved the current

00:22:29,319 --> 00:22:32,109
state of the generator the Python ast

00:22:30,849 --> 00:22:34,329
code knows what - varrett which

00:22:32,109 --> 00:22:36,249
variables are in use it knows which

00:22:34,329 --> 00:22:38,379
registers they should be in and we can

00:22:36,249 --> 00:22:40,449
explicitly copy all those values out of

00:22:38,379 --> 00:22:43,359
local storage and into the state of the

00:22:40,449 --> 00:22:45,309
generator second we can set the current

00:22:43,359 --> 00:22:46,809
yield point we just enumerate those the

00:22:45,309 --> 00:22:50,079
first one you come across on the code is

00:22:46,809 --> 00:22:51,549
yield point one now I represented the

00:22:50,079 --> 00:22:53,199
first three of these as function calls

00:22:51,549 --> 00:22:54,909
in pseudocode but you can't actually do

00:22:53,199 --> 00:22:56,949
a function call there as soon as you

00:22:54,909 --> 00:22:58,869
call a function the locals for that

00:22:56,949 --> 00:23:00,609
function pass out of scope so this

00:22:58,869 --> 00:23:02,499
actually has to be done in line in the

00:23:00,609 --> 00:23:05,499
method in the generator function as a

00:23:02,499 --> 00:23:08,049
series of calls at last we just return

00:23:05,499 --> 00:23:10,329
the value that we want to yield on the

00:23:08,049 --> 00:23:12,789
subsequent invocation we have a current

00:23:10,329 --> 00:23:14,829
yield point so we jump directly to that

00:23:12,789 --> 00:23:16,569
point of the code restore the state

00:23:14,829 --> 00:23:18,999
again reload all the values of the local

00:23:16,569 --> 00:23:21,190
variables from the generators store back

00:23:18,999 --> 00:23:22,599
into locals again this needs to be done

00:23:21,190 --> 00:23:25,089
in line to the chill loading the

00:23:22,599 --> 00:23:27,219
generators local scope and there you

00:23:25,089 --> 00:23:29,759
have it generators implemented in a

00:23:27,219 --> 00:23:33,369
language that doesn't support them a

00:23:29,759 --> 00:23:35,199
full ast visitor has a total of 54 entry

00:23:33,369 --> 00:23:37,899
points converts or responding to all the

00:23:35,199 --> 00:23:40,449
node types and language Thai language

00:23:37,899 --> 00:23:43,209
entry points that occur in Python code

00:23:40,449 --> 00:23:45,789
some of them like yields are quite

00:23:43,209 --> 00:23:48,190
complex but many of them are no visit

00:23:45,789 --> 00:23:50,889
paths for example doesn't take very much

00:23:48,190 --> 00:23:52,179
implementation and some of them things

00:23:50,889 --> 00:23:54,190
like list expressions dictionary

00:23:52,179 --> 00:23:56,470
expressions set expressions share a lot

00:23:54,190 --> 00:23:58,630
of commonality so the task of M

00:23:56,470 --> 00:24:01,270
lamenting a visitor that can visit all

00:23:58,630 --> 00:24:03,000
the Python programs or Python programs

00:24:01,270 --> 00:24:06,280
is in this daunting as it might seem

00:24:03,000 --> 00:24:08,770
this ast to bytecode translation process

00:24:06,280 --> 00:24:11,409
is exactly what vaak does Volk is a

00:24:08,770 --> 00:24:14,890
transpiler that converts python source

00:24:11,409 --> 00:24:16,750
code to Java bytecode the upshot of this

00:24:14,890 --> 00:24:20,080
is that when you define a class in

00:24:16,750 --> 00:24:22,150
Python and compile it with vaak it is a

00:24:20,080 --> 00:24:23,890
Java class file it's not some

00:24:22,150 --> 00:24:26,500
approximation or a wrapper it's

00:24:23,890 --> 00:24:28,539
indistinguishable from Java and as a

00:24:26,500 --> 00:24:31,450
result you can write Python code that

00:24:28,539 --> 00:24:33,400
talks directly to Java API s swing

00:24:31,450 --> 00:24:36,960
Android whatever it is you need and you

00:24:33,400 --> 00:24:40,750
can write Android applications in Python

00:24:36,960 --> 00:24:43,299
as an interesting historical footnote

00:24:40,750 --> 00:24:44,830
vaak actually started trying to do the

00:24:43,299 --> 00:24:46,929
black code the bytecode transformation

00:24:44,830 --> 00:24:49,210
that I described earlier on it's now an

00:24:46,929 --> 00:24:50,010
AST to bytecode transformation make of

00:24:49,210 --> 00:24:52,570
that what you will

00:24:50,010 --> 00:24:54,789
it's also a potentially a future

00:24:52,570 --> 00:24:57,789
direction for batavia the emergence of

00:24:54,789 --> 00:24:59,799
asm.js and wisdom means that it might be

00:24:57,789 --> 00:25:01,530
worth looking at doing the direct AST to

00:24:59,799 --> 00:25:03,669
bytecode translation for javascript

00:25:01,530 --> 00:25:06,280
bypassing the JavaScript language

00:25:03,669 --> 00:25:14,620
entirely targeting the VM or as close to

00:25:06,280 --> 00:25:16,720
the VM as you can get but but Python

00:25:14,620 --> 00:25:18,640
isn't just a language specification -

00:25:16,720 --> 00:25:20,530
comes batteries included it has a

00:25:18,640 --> 00:25:22,750
standard library to help you get stuff

00:25:20,530 --> 00:25:24,640
done the C Python standard library is

00:25:22,750 --> 00:25:26,500
made up of two parts there's a pure

00:25:24,640 --> 00:25:28,840
Python type and a part that's written in

00:25:26,500 --> 00:25:30,820
C if you've got a library written in

00:25:28,840 --> 00:25:32,350
Python it doesn't matter if it's part of

00:25:30,820 --> 00:25:33,970
the standard library or part of PI PRI

00:25:32,350 --> 00:25:36,039
you can just take that compile it and

00:25:33,970 --> 00:25:37,690
use it wholesale it's Python code so it

00:25:36,039 --> 00:25:39,640
compiles as python code and runs the

00:25:37,690 --> 00:25:41,110
same as everything else we can compile

00:25:39,640 --> 00:25:42,850
it to bytecode run it through a new

00:25:41,110 --> 00:25:44,260
virtual machine cross compile it to a

00:25:42,850 --> 00:25:45,880
new target platform and just run it on

00:25:44,260 --> 00:25:48,010
re-implemented Python whatever it is you

00:25:45,880 --> 00:25:49,270
happen to need but the bits that are

00:25:48,010 --> 00:25:50,919
written in C a little bit more

00:25:49,270 --> 00:25:52,570
complicated there are a couple of

00:25:50,919 --> 00:25:54,970
reasons why a module might be written in

00:25:52,570 --> 00:25:56,289
C first there are occasions where what

00:25:54,970 --> 00:25:58,210
we're doing is talking directly to

00:25:56,289 --> 00:26:00,370
system services if you're going to make

00:25:58,210 --> 00:26:02,470
a POSIX system call well you're going to

00:26:00,370 --> 00:26:04,809
need to have a method to call C the

00:26:02,470 --> 00:26:06,220
method to implement that call but there

00:26:04,809 --> 00:26:07,480
are also modules that are implemented as

00:26:06,220 --> 00:26:10,050
C modules because there are wrapper

00:26:07,480 --> 00:26:12,360
around some library whose implementation

00:26:10,050 --> 00:26:13,950
see visit to for example is a

00:26:12,360 --> 00:26:16,020
compression library the reference

00:26:13,950 --> 00:26:18,090
implementation is written in C sure you

00:26:16,020 --> 00:26:21,480
could rewrite it but why would you just

00:26:18,090 --> 00:26:22,710
implement it we busy to lastly there are

00:26:21,480 --> 00:26:24,120
parts of the standard library that are

00:26:22,710 --> 00:26:26,280
implemented in C for performance reasons

00:26:24,120 --> 00:26:28,350
for example the decimal module used to

00:26:26,280 --> 00:26:30,150
be implemented in pure Python for

00:26:28,350 --> 00:26:34,170
performance reasons it was ported to see

00:26:30,150 --> 00:26:35,550
in Python 3.5 and that's great for C

00:26:34,170 --> 00:26:37,290
Python as an implementation of Python

00:26:35,550 --> 00:26:39,000
nobody's going to complain about more

00:26:37,290 --> 00:26:40,020
performance but if you're looking at C

00:26:39,000 --> 00:26:42,210
Python as a reference implementation

00:26:40,020 --> 00:26:43,050
it's been annoying because it means that

00:26:42,210 --> 00:26:45,360
something you're going to have to

00:26:43,050 --> 00:26:47,310
re-implement natively what's really

00:26:45,360 --> 00:26:48,750
needed is a reference standard library

00:26:47,310 --> 00:26:50,490
an implementation of the Python standard

00:26:48,750 --> 00:26:52,320
library that's written entirely in pure

00:26:50,490 --> 00:26:54,480
Python except for a clearly detailed

00:26:52,320 --> 00:26:57,030
minimal interface to system services and

00:26:54,480 --> 00:26:58,560
that's what Ouroboros is for those that

00:26:57,030 --> 00:27:00,120
up in your mythology arroba Ross is the

00:26:58,560 --> 00:27:02,700
Greek symbol of a snake eating its own

00:27:00,120 --> 00:27:04,140
tail a robe Ross is very much a work in

00:27:02,700 --> 00:27:06,120
progress but it's an important part of

00:27:04,140 --> 00:27:07,710
the whole puzzle of Batavia and Bach and

00:27:06,120 --> 00:27:09,180
so on if we're going to make it easy to

00:27:07,710 --> 00:27:12,300
bring Python to as many platforms as

00:27:09,180 --> 00:27:14,040
possible now if you're interested in

00:27:12,300 --> 00:27:15,690
something other than JavaScript or Java

00:27:14,040 --> 00:27:17,730
as a target platform hopefully I've

00:27:15,690 --> 00:27:18,870
given you enough deeper detail to start

00:27:17,730 --> 00:27:21,030
down the part of writing your own

00:27:18,870 --> 00:27:23,130
transpiler if you do want to target

00:27:21,030 --> 00:27:25,290
JavaScript or Java which I've been using

00:27:23,130 --> 00:27:26,520
for the demos today the good news is you

00:27:25,290 --> 00:27:28,290
don't have to build your own transpiler

00:27:26,520 --> 00:27:30,210
from scratch a row bras are on with

00:27:28,290 --> 00:27:33,060
beware and Valk behavior invoke a part

00:27:30,210 --> 00:27:34,950
of the beware project and you can use

00:27:33,060 --> 00:27:36,860
those to deploy your Python code to the

00:27:34,950 --> 00:27:39,270
browser or to Android respectively

00:27:36,860 --> 00:27:41,430
details of those projects and more can

00:27:39,270 --> 00:27:43,020
be found on PI B org and if you're

00:27:41,430 --> 00:27:45,090
interested in writing user facing apps

00:27:43,020 --> 00:27:46,560
in Python targeting mobile phones and

00:27:45,090 --> 00:27:48,210
browsers I'd like to draw your attention

00:27:46,560 --> 00:27:50,790
in particular to two parts of the

00:27:48,210 --> 00:27:51,960
website first off beware as an open

00:27:50,790 --> 00:27:53,310
source project we're actively looking

00:27:51,960 --> 00:27:54,810
for contributors all levels of

00:27:53,310 --> 00:27:56,460
experience even if you've never

00:27:54,810 --> 00:27:57,480
contributed to open source before you

00:27:56,460 --> 00:27:59,850
think you haven't got enough skill

00:27:57,480 --> 00:28:01,380
you're wrong we want you we'll find

00:27:59,850 --> 00:28:02,880
something for you to do really easy to

00:28:01,380 --> 00:28:03,960
get started we have tutorials and

00:28:02,880 --> 00:28:05,430
walkthroughs for the contribution

00:28:03,960 --> 00:28:06,720
process and we've got an open offer de

00:28:05,430 --> 00:28:10,560
menthe or anybody who wants to get

00:28:06,720 --> 00:28:11,520
involved I will be in booth 103 for the

00:28:10,560 --> 00:28:12,900
rest of today if you haven't already

00:28:11,520 --> 00:28:16,500
come by and pledged your allegiance to

00:28:12,900 --> 00:28:18,630
team green you've still got time and

00:28:16,500 --> 00:28:21,500
thanks to Cogan you could win one of

00:28:18,630 --> 00:28:23,850
four Kogan Agora 4G Android phones

00:28:21,500 --> 00:28:25,289
I'll also be around along with

00:28:23,850 --> 00:28:27,030
a couple of members of the beware team

00:28:25,289 --> 00:28:28,710
until the end of the Sprint's working on

00:28:27,030 --> 00:28:30,000
beware thanks to revolution systems

00:28:28,710 --> 00:28:31,710
we've also got a stash of challenge

00:28:30,000 --> 00:28:32,850
coins which we give to anybody who

00:28:31,710 --> 00:28:34,860
contributes to the project

00:28:32,850 --> 00:28:36,539
thanks to github we also have a second

00:28:34,860 --> 00:28:38,190
challenge coin for yak herders people

00:28:36,539 --> 00:28:40,140
who commit who help other people commit

00:28:38,190 --> 00:28:42,000
patches thanks to stick amel we have

00:28:40,140 --> 00:28:44,190
plenty of ISO compliant hex stickers and

00:28:42,000 --> 00:28:45,840
Travis CI has given us plenty of

00:28:44,190 --> 00:28:47,669
capacity for running LCR testing during

00:28:45,840 --> 00:28:48,809
the sprints so if you load a coin or

00:28:47,669 --> 00:28:50,610
you'd like to get one or you want

00:28:48,809 --> 00:28:53,429
stickers come grab beam we can have a

00:28:50,610 --> 00:28:55,440
chat second point is an appeal to you

00:28:53,429 --> 00:28:57,000
the Python community to date

00:28:55,440 --> 00:28:58,919
beware development has been mostly a

00:28:57,000 --> 00:29:00,780
volunteer effort that seriously

00:28:58,919 --> 00:29:03,390
constrains the rate of development I'm

00:29:00,780 --> 00:29:06,390
also looking for a job but I think we

00:29:03,390 --> 00:29:07,919
can solve two problems at once for us

00:29:06,390 --> 00:29:09,870
kendall has a month you can join the

00:29:07,919 --> 00:29:11,010
beware project as a member if I can find

00:29:09,870 --> 00:29:13,289
a thousand people in the Python

00:29:11,010 --> 00:29:14,370
community who want you want these tools

00:29:13,289 --> 00:29:16,289
so willing to support their development

00:29:14,370 --> 00:29:18,600
financially I can start working on

00:29:16,289 --> 00:29:20,070
Beware full-time if I can find more than

00:29:18,600 --> 00:29:27,720
a thousand people then we can start to

00:29:20,070 --> 00:29:29,669
do some social good as well for some

00:29:27,720 --> 00:29:31,409
time I've had an open offer to mentor

00:29:29,669 --> 00:29:33,000
anybody who wants to get involved in the

00:29:31,409 --> 00:29:35,610
open-source contribution process I'd

00:29:33,000 --> 00:29:37,740
like to take the next step and start to

00:29:35,610 --> 00:29:39,210
hire and pay some junior developers

00:29:37,740 --> 00:29:40,770
given those developers the opportunity

00:29:39,210 --> 00:29:43,440
to advance their skills and their public

00:29:40,770 --> 00:29:44,340
profile and prioritize giving those that

00:29:43,440 --> 00:29:47,130
opportunity to people from

00:29:44,340 --> 00:29:48,539
underrepresented demographics it still

00:29:47,130 --> 00:29:50,580
very early days would be where financial

00:29:48,539 --> 00:29:52,530
support means faster progress best of

00:29:50,580 --> 00:29:54,870
all we can all get these great tools to

00:29:52,530 --> 00:29:56,070
use Python code and all the various

00:29:54,870 --> 00:29:57,960
places we might want to use Python

00:29:56,070 --> 00:30:00,210
without having to give up on our open

00:29:57,960 --> 00:30:02,100
source ideals I'm excited for what the

00:30:00,210 --> 00:30:04,140
future holds for be aware I hope you'll

00:30:02,100 --> 00:30:05,280
join me on this journey and with that I

00:30:04,140 --> 00:30:07,080
don't think we have time for questions

00:30:05,280 --> 00:30:11,990
because apparently the buildings on fire

00:30:07,080 --> 00:30:11,990
so thank you very much

00:30:16,600 --> 00:30:24,220
the building is not on fire it's okay

00:30:21,490 --> 00:30:26,860
we now a 10 minute changeover that was

00:30:24,220 --> 00:30:29,280
the all-clear so off to your next

00:30:26,860 --> 00:30:29,280

YouTube URL: https://www.youtube.com/watch?v=9c4DEYIXYCM


