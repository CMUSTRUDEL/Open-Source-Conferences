Title: David Wolever: When the abyss gazes back staring down Python's surprising internals   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	Speaker: David Wolever

Python's fantastic until it isn't.  This talk dives into some of the surprising implementation details of CPython, then explains exactly how they could be discovered from first principles.  

Attendees will leave with some dangerous Python trivia, and the tools they'll need to uncovery their own trivia when surprises strike.

The talk takes a deep dive into a StackOverflow question asking why `"x" in ("x", )` is faster than `"x" == "x"` (http://stackoverflow.com/questions/28885132/why-is-x-in-x-faster-than-x-x/28885213#28885213), including a discussion of `dis.disassemble`, the Pyhton stack machine, and reading the CPython source. If time permits, there will be other fun examples, a whirlwind tour of debugging, and a couple of homework assignments.

Slides: https://github.com/PyCon/2017-slides/tree/master/David%20Wolever%20-%20When%20The%20Abys%20Gazes%20Back
Captions: 
	00:00:00,000 --> 00:00:14,460
get to stare down license surprising

00:00:03,000 --> 00:00:15,750
internals please make him welcome Oh am

00:00:14,460 --> 00:00:18,539
I going to thank you all so much for

00:00:15,750 --> 00:00:20,400
coming this is especially exciting for

00:00:18,539 --> 00:00:22,320
me because for the last five or six

00:00:20,400 --> 00:00:24,090
years I've been working behind the

00:00:22,320 --> 00:00:26,400
scenes helping run the green room and

00:00:24,090 --> 00:00:27,930
make sure that speakers get to their

00:00:26,400 --> 00:00:29,640
tracks on time and they have everything

00:00:27,930 --> 00:00:30,960
that they need and this is going to be

00:00:29,640 --> 00:00:33,630
my first time up on stage actually

00:00:30,960 --> 00:00:39,059
giving a talk so I'm really excited you

00:00:33,630 --> 00:00:40,770
could all come pursuant to that if you

00:00:39,059 --> 00:00:42,210
wouldn't mind taking some great photos

00:00:40,770 --> 00:00:44,040
of me and tweeting them at me I would

00:00:42,210 --> 00:00:51,449
really appreciate that my twitter is

00:00:44,040 --> 00:00:53,399
just up there so overall Python's a

00:00:51,449 --> 00:00:55,860
pretty great language it's got you know

00:00:53,399 --> 00:00:59,820
a few decent packages a pretty fantastic

00:00:55,860 --> 00:01:06,240
community and overall it's it's not very

00:00:59,820 --> 00:01:09,030
surprising but only overall every now

00:01:06,240 --> 00:01:11,729
and then you run into some weird little

00:01:09,030 --> 00:01:13,740
problem something that you can't explain

00:01:11,729 --> 00:01:16,470
something that your co-workers can't

00:01:13,740 --> 00:01:18,750
explain and sometimes that really smart

00:01:16,470 --> 00:01:21,659
friend of yours from that Meetup even

00:01:18,750 --> 00:01:23,189
they can't explain and you know this is

00:01:21,659 --> 00:01:25,830
where this is where the rubber really

00:01:23,189 --> 00:01:27,540
hits the road this is when you draw on

00:01:25,830 --> 00:01:29,430
all those years of experience you have

00:01:27,540 --> 00:01:31,650
as a programmer those thousands of

00:01:29,430 --> 00:01:33,450
dollars you put into school and prove to

00:01:31,650 --> 00:01:37,790
yourself and to the world that you are

00:01:33,450 --> 00:01:37,790
in fact a real programmer

00:01:47,370 --> 00:01:57,630
[Applause]

00:01:54,350 --> 00:02:02,039
but I'm going to be here I'm here to

00:01:57,630 --> 00:02:04,649
tell you that there is another way it

00:02:02,039 --> 00:02:06,990
might not be a better way or even

00:02:04,649 --> 00:02:10,709
necessarily a very good way but it's

00:02:06,990 --> 00:02:12,269
definitely an interesting way so over

00:02:10,709 --> 00:02:14,069
this talk I'm going to be telling you

00:02:12,269 --> 00:02:15,810
the story of answering a stack overflow

00:02:14,069 --> 00:02:17,670
question about some strange performance

00:02:15,810 --> 00:02:19,200
characteristics and I'm going to be

00:02:17,670 --> 00:02:22,260
doing that working mostly from first

00:02:19,200 --> 00:02:24,900
principles I'm going to show you how to

00:02:22,260 --> 00:02:27,120
use this disk disassembled to read place

00:02:24,900 --> 00:02:29,250
on byte code talked a little bit about

00:02:27,120 --> 00:02:33,360
the place on virtual machine and then

00:02:29,250 --> 00:02:35,130
dive into python c implementation by the

00:02:33,360 --> 00:02:37,260
time we're done I hope that you're going

00:02:35,130 --> 00:02:40,319
to have some new trivia you can use to

00:02:37,260 --> 00:02:41,730
impress friends at parties and also some

00:02:40,319 --> 00:02:46,440
practical tools you can use in your

00:02:41,730 --> 00:02:49,230
day-to-day development now I'm going to

00:02:46,440 --> 00:02:50,579
be using Python 2.7 for this talk I've

00:02:49,230 --> 00:02:52,829
done I've gone through most of the

00:02:50,579 --> 00:02:54,599
examples in Python 3.6 they should

00:02:52,829 --> 00:02:56,130
mostly work and when there are

00:02:54,599 --> 00:02:58,560
differences like for instance discs

00:02:56,130 --> 00:02:59,730
discs instead of just disassembled I'm

00:02:58,560 --> 00:03:05,819
going to do my best to point those out

00:02:59,730 --> 00:03:09,299
so here's the stack overflow question

00:03:05,819 --> 00:03:10,829
that caught my eye you can see oh we

00:03:09,299 --> 00:03:15,420
can't really read that so the question

00:03:10,829 --> 00:03:18,359
is why is string acts in tuple of string

00:03:15,420 --> 00:03:21,600
acts faster than X string x equals

00:03:18,359 --> 00:03:23,670
equals string X and that seems really

00:03:21,600 --> 00:03:25,139
strange at first I mean come on equality

00:03:23,670 --> 00:03:27,750
is about the simplest thing you can do

00:03:25,139 --> 00:03:29,160
wear with a tuple membership we have to

00:03:27,750 --> 00:03:30,630
create a tuple we have to go test for

00:03:29,160 --> 00:03:32,040
membership and then at some point we

00:03:30,630 --> 00:03:33,780
also have to test for equality one

00:03:32,040 --> 00:03:36,959
should be a strict kind of superset of

00:03:33,780 --> 00:03:38,280
the other so of course being a good

00:03:36,959 --> 00:03:41,010
empiricist the first thing that I did

00:03:38,280 --> 00:03:43,400
was pull the die Python and verify that

00:03:41,010 --> 00:03:46,109
I could reproduce the results for myself

00:03:43,400 --> 00:03:47,400
now just as an aside we're going to be

00:03:46,109 --> 00:03:49,920
having a few asides here because I like

00:03:47,400 --> 00:03:52,319
asides if you haven't used a pythons

00:03:49,920 --> 00:03:54,989
percent time at magic it's incredibly

00:03:52,319 --> 00:03:56,400
useful it will automatically figure out

00:03:54,989 --> 00:03:57,959
how many iterations of the loop it

00:03:56,400 --> 00:03:59,700
should run to give you a reasonable

00:03:57,959 --> 00:04:03,630
result in also a reasonable amount of

00:03:59,700 --> 00:04:05,220
time so that you aren't waiting two

00:04:03,630 --> 00:04:05,910
years for a million iterations of

00:04:05,220 --> 00:04:12,300
opening a file

00:04:05,910 --> 00:04:15,150
an issue anyway getting back to our

00:04:12,300 --> 00:04:19,019
problem we found that we can reproduce

00:04:15,150 --> 00:04:22,250
the result but that raises the question

00:04:19,019 --> 00:04:26,360
if we're not going to be googling this

00:04:22,250 --> 00:04:26,360
what do we do where do we start

00:04:27,530 --> 00:04:31,200
the first thing that we do when we're

00:04:29,820 --> 00:04:32,430
digging into what Python is doing under

00:04:31,200 --> 00:04:34,680
the hood at least at the Python

00:04:32,430 --> 00:04:37,650
interpreter level is we use discs such

00:04:34,680 --> 00:04:40,380
as assemble disks that disassemble let's

00:04:37,650 --> 00:04:44,610
you take a disassembled Python code and

00:04:40,380 --> 00:04:46,500
see the underlying byte code now you've

00:04:44,610 --> 00:04:48,600
probably heard Python talked about as an

00:04:46,500 --> 00:04:51,990
interpreted language in contrast with

00:04:48,600 --> 00:04:54,720
compiled languages like C++ or Java but

00:04:51,990 --> 00:04:56,100
that isn't actually strictly true Python

00:04:54,720 --> 00:04:58,170
does have a compiler that runs

00:04:56,100 --> 00:04:59,850
automatically over every dot py file

00:04:58,170 --> 00:05:02,610
when it's first imported or first

00:04:59,850 --> 00:05:05,490
executed those are the doc UIC files you

00:05:02,610 --> 00:05:07,620
see a litter in your system that

00:05:05,490 --> 00:05:09,240
compiler takes the Python bytecode the

00:05:07,620 --> 00:05:14,670
stuff that you write and compiled it

00:05:09,240 --> 00:05:16,020
down to bytecode this thought

00:05:14,670 --> 00:05:17,550
disassemble is the module that's going

00:05:16,020 --> 00:05:19,650
to let us take that Python bytecode and

00:05:17,550 --> 00:05:22,080
see the specific Python virtual machine

00:05:19,650 --> 00:05:24,510
instructions that are being executed so

00:05:22,080 --> 00:05:25,740
here's a simple example there's a lot

00:05:24,510 --> 00:05:29,070
going on so I'm going to walk through it

00:05:25,740 --> 00:05:30,300
one step at a time the first two lines

00:05:29,070 --> 00:05:32,340
you're probably already seen before

00:05:30,300 --> 00:05:37,680
we're importing a module defining a

00:05:32,340 --> 00:05:38,700
variable defining a function the next

00:05:37,680 --> 00:05:40,230
line is where things start to get a bit

00:05:38,700 --> 00:05:44,730
interesting these are the call to disk

00:05:40,230 --> 00:05:46,740
disassemble and specifically we have

00:05:44,730 --> 00:05:50,910
this the function and the funk under

00:05:46,740 --> 00:05:55,260
code attribute now should note in Python

00:05:50,910 --> 00:05:57,120
3 it's actually dunder code but to

00:05:55,260 --> 00:05:59,130
understand what's going on here we need

00:05:57,120 --> 00:06:02,640
to dig into functions just a little bit

00:05:59,130 --> 00:06:04,380
more so just like everything else in

00:06:02,640 --> 00:06:06,180
Python functions are objects with a

00:06:04,380 --> 00:06:08,360
bunch of attributes and we can use the

00:06:06,180 --> 00:06:10,290
derp built-in to list those attributes

00:06:08,360 --> 00:06:12,780
there's a whole bunch of really really

00:06:10,290 --> 00:06:13,800
fascinating stuff in there and I'm going

00:06:12,780 --> 00:06:16,169
to be saying this a bunch during this

00:06:13,800 --> 00:06:17,820
talk after this talk you should really

00:06:16,169 --> 00:06:19,670
pull it and interpreter yourself and dig

00:06:17,820 --> 00:06:22,260
in and start seeing what's there

00:06:19,670 --> 00:06:24,510
at the moment though we're just going to

00:06:22,260 --> 00:06:29,760
be focusing on one attribute funk under

00:06:24,510 --> 00:06:31,620
code or in Python 3 dunder code funk

00:06:29,760 --> 00:06:33,540
under code is the object that describes

00:06:31,620 --> 00:06:35,190
the actual code associated with the

00:06:33,540 --> 00:06:37,650
function and it's got some interesting

00:06:35,190 --> 00:06:39,630
information it's got the function name

00:06:37,650 --> 00:06:42,830
the the file that the function was

00:06:39,630 --> 00:06:45,870
defined in and even the line number and

00:06:42,830 --> 00:06:47,550
again even within func code there's a

00:06:45,870 --> 00:06:49,110
whole bunch of really cool stuff and you

00:06:47,550 --> 00:06:51,420
can do some probably pretty disgusting

00:06:49,110 --> 00:06:55,710
tricks there I don't see Dave Weasley

00:06:51,420 --> 00:06:57,240
anywhere so we should be safe but for

00:06:55,710 --> 00:06:59,220
the moment we're going to be focusing on

00:06:57,240 --> 00:07:02,790
the CEO under code attribute and this

00:06:59,220 --> 00:07:04,950
one is actually the same in Python 3 CEO

00:07:02,790 --> 00:07:06,570
under code is a string byte string that

00:07:04,950 --> 00:07:08,460
contains the exact same compiled

00:07:06,570 --> 00:07:11,730
bytecode for that function that would

00:07:08,460 --> 00:07:14,130
appear in a dot pyc file this is the

00:07:11,730 --> 00:07:16,170
full implementation of the function and

00:07:14,130 --> 00:07:18,660
we can see that if we use this to

00:07:16,170 --> 00:07:20,520
disassemble it now notice that this is

00:07:18,660 --> 00:07:22,650
just about the same disassembly as

00:07:20,520 --> 00:07:24,840
before we're missing a bit of metadata

00:07:22,650 --> 00:07:29,700
like line numbers and variable names but

00:07:24,840 --> 00:07:30,690
the instructions are the same now for

00:07:29,700 --> 00:07:32,850
the more observant among you though

00:07:30,690 --> 00:07:34,350
you're going to notice that the hello

00:07:32,850 --> 00:07:36,450
format string doesn't appear anywhere in

00:07:34,350 --> 00:07:38,070
that byte code your first take home

00:07:36,450 --> 00:07:42,140
assignment is to figure out where is

00:07:38,070 --> 00:07:44,490
that hello format string stored anyway

00:07:42,140 --> 00:07:46,470
we're doing ok for time so I'm going to

00:07:44,490 --> 00:07:49,260
do one more little digression into

00:07:46,470 --> 00:07:53,040
function objects and that's the func

00:07:49,260 --> 00:07:55,320
closure attribute so if you haven't

00:07:53,040 --> 00:07:57,330
heard the word before closure is a fancy

00:07:55,320 --> 00:07:59,190
computer science term for a function

00:07:57,330 --> 00:08:02,520
that stores references to variables that

00:07:59,190 --> 00:08:05,070
aren't inside the function itself so for

00:08:02,520 --> 00:08:07,980
example this hello closure inner

00:08:05,070 --> 00:08:11,070
function that's defined inside the outer

00:08:07,980 --> 00:08:13,680
hello closure function makes reference

00:08:11,070 --> 00:08:15,600
to this message variable that message

00:08:13,680 --> 00:08:17,370
variable though isn't defined in the

00:08:15,600 --> 00:08:21,210
function itself it's defined outside the

00:08:17,370 --> 00:08:24,540
function so that when the hello closure

00:08:21,210 --> 00:08:26,670
inner function is returned sorry excuse

00:08:24,540 --> 00:08:30,450
me but when the hello function the hello

00:08:26,670 --> 00:08:32,160
closure inner function is returned it's

00:08:30,450 --> 00:08:33,360
still somehow is access to that variable

00:08:32,160 --> 00:08:34,760
now if you're used to place on

00:08:33,360 --> 00:08:36,779
might not seem like a surprising thing

00:08:34,760 --> 00:08:39,630
but if you've come from other languages

00:08:36,779 --> 00:08:41,279
like for instance C or older versions of

00:08:39,630 --> 00:08:48,709
Java this is actually quite a novel

00:08:41,279 --> 00:08:51,350
concept so how does that work well

00:08:48,709 --> 00:08:53,880
that's the funk under closure attribute

00:08:51,350 --> 00:08:55,380
funk under closure contains a tuple of

00:08:53,880 --> 00:08:57,570
all the different variables that are

00:08:55,380 --> 00:09:00,060
being closed over and now for the

00:08:57,570 --> 00:09:01,950
peasants in the room it's actually not

00:09:00,060 --> 00:09:03,750
the variables it's actually these

00:09:01,950 --> 00:09:05,100
objects called cells that reference the

00:09:03,750 --> 00:09:07,050
variables which mean that the outer

00:09:05,100 --> 00:09:08,310
function can change their value which is

00:09:07,050 --> 00:09:09,540
having to go and monkey with the tuple

00:09:08,310 --> 00:09:13,709
of all the inner functions and in size

00:09:09,540 --> 00:09:15,930
data but the important point is that

00:09:13,709 --> 00:09:17,339
each function actually stores along with

00:09:15,930 --> 00:09:19,589
it a reference to all the variables that

00:09:17,339 --> 00:09:22,079
is closed over and one of the kind of

00:09:19,589 --> 00:09:24,029
neat consequences of that is that it's

00:09:22,079 --> 00:09:25,920
actually possible to you know at least

00:09:24,029 --> 00:09:26,730
in theory to build a serializer that

00:09:25,920 --> 00:09:29,339
will be able to take one of these

00:09:26,730 --> 00:09:31,019
closures serialize it send it across the

00:09:29,339 --> 00:09:32,790
wire load it up and evaluate it on

00:09:31,019 --> 00:09:35,430
another computer exactly like it was now

00:09:32,790 --> 00:09:37,920
this is a bad idea and I really hope

00:09:35,430 --> 00:09:40,170
none of you do it and if you do buy

00:09:37,920 --> 00:09:41,730
something don't do it I definitely don't

00:09:40,170 --> 00:09:46,589
put it up on pi PI and definitely don't

00:09:41,730 --> 00:09:48,329
tweet about it anyway your your a little

00:09:46,589 --> 00:09:50,399
bit of homework from here is to figure

00:09:48,329 --> 00:09:52,560
out why even though there are actually

00:09:50,399 --> 00:09:55,500
two variables in scope at the time that

00:09:52,560 --> 00:09:57,209
hello close your inner was defined its

00:09:55,500 --> 00:09:59,310
func under closure attribute its func

00:09:57,209 --> 00:10:01,260
under closure tuple only has one element

00:09:59,310 --> 00:10:03,060
in it what happened to that other

00:10:01,260 --> 00:10:07,470
variable I don't know you have to figure

00:10:03,060 --> 00:10:10,579
it out anyway that was a nifty little

00:10:07,470 --> 00:10:13,589
digression but getting back on track so

00:10:10,579 --> 00:10:17,040
now we know kind of what it means to

00:10:13,589 --> 00:10:18,779
disassemble the function code so let's

00:10:17,040 --> 00:10:22,829
start looking at the output of the

00:10:18,779 --> 00:10:24,660
disassembly now even if you've never

00:10:22,829 --> 00:10:27,240
seen disassembled place on or just

00:10:24,660 --> 00:10:29,040
assembled anything before you should be

00:10:27,240 --> 00:10:30,390
able to make some reasonably educated

00:10:29,040 --> 00:10:34,920
guesses about what's going on here

00:10:30,390 --> 00:10:39,060
so first loading the string the format

00:10:34,920 --> 00:10:40,850
string second we're loading loading the

00:10:39,060 --> 00:10:43,680
value of a variable

00:10:40,850 --> 00:10:45,420
we're building a tuple where a plot

00:10:43,680 --> 00:10:47,100
we're applying the binary modulo

00:10:45,420 --> 00:10:47,390
operator and I hopefully you can see

00:10:47,100 --> 00:10:49,670
that

00:10:47,390 --> 00:10:51,350
well that's okay we're a pie we're

00:10:49,670 --> 00:10:53,089
applying that binary modulo operator now

00:10:51,350 --> 00:10:54,470
if you call the the modulo operator is

00:10:53,089 --> 00:10:56,720
normally used for getting the remainder

00:10:54,470 --> 00:10:58,579
of divisions but Python overloads it to

00:10:56,720 --> 00:11:00,079
also do string formatting which some

00:10:58,579 --> 00:11:03,190
people don't love but I'm going on

00:11:00,079 --> 00:11:05,510
record as saying I absolutely love and

00:11:03,190 --> 00:11:09,370
finally we're storing the result of that

00:11:05,510 --> 00:11:09,370
format back into the message variable

00:11:09,399 --> 00:11:14,810
next line we're loading the value of

00:11:11,899 --> 00:11:16,459
that message variable we're printing it

00:11:14,810 --> 00:11:17,420
and this is of course where Python 3

00:11:16,459 --> 00:11:19,640
would be a little bit different because

00:11:17,420 --> 00:11:21,350
in Python 2 per inch is its own opcode

00:11:19,640 --> 00:11:26,029
and python 3 it's you know just a

00:11:21,350 --> 00:11:27,620
regular function and then since the

00:11:26,029 --> 00:11:29,209
function didn't explicit your type birth

00:11:27,620 --> 00:11:31,480
back since the function didn't

00:11:29,209 --> 00:11:37,640
explicitly define a return variable

00:11:31,480 --> 00:11:39,140
we're returning none so to go into just

00:11:37,640 --> 00:11:45,079
a little bit more detail on what's going

00:11:39,140 --> 00:11:47,269
on here you've probably noticed with you

00:11:45,079 --> 00:11:48,740
too those gene instructions they're a

00:11:47,269 --> 00:11:51,589
simple instruction that just takes one

00:11:48,740 --> 00:11:54,320
argument so for instance the binary

00:11:51,589 --> 00:11:57,230
modulo it's it's one or one instruction

00:11:54,320 --> 00:11:58,910
with one argument modulo even though an

00:11:57,230 --> 00:12:01,779
actual like logically a modulus takes

00:11:58,910 --> 00:12:04,839
two arguments the left side right side

00:12:01,779 --> 00:12:07,339
so that's because the Python interpreter

00:12:04,839 --> 00:12:08,750
it's also called a virtual machine is a

00:12:07,339 --> 00:12:11,449
particular kind of virtual machine

00:12:08,750 --> 00:12:13,510
called a stack machine and in stack

00:12:11,449 --> 00:12:16,370
machines in general instructions

00:12:13,510 --> 00:12:18,560
instructions operate on values and pass

00:12:16,370 --> 00:12:20,779
values around by pushing them on to and

00:12:18,560 --> 00:12:22,940
popping them off from a stack now this

00:12:20,779 --> 00:12:25,160
is in contrast with register machine

00:12:22,940 --> 00:12:27,380
like an Intel or an arm or whatever

00:12:25,160 --> 00:12:29,660
that's in your laptop or in your phone

00:12:27,380 --> 00:12:31,490
and they have a whole wide variety of

00:12:29,660 --> 00:12:33,949
operators that can take all sorts of

00:12:31,490 --> 00:12:35,750
functions or all sorts of arguments and

00:12:33,949 --> 00:12:40,250
they can access memory and registers and

00:12:35,750 --> 00:12:42,529
all these different things directly so

00:12:40,250 --> 00:12:43,940
to explain what I mean I'm going to use

00:12:42,529 --> 00:12:46,550
the example of this simple math equation

00:12:43,940 --> 00:12:49,519
1 plus 2 times 3 in our little

00:12:46,550 --> 00:12:50,870
fictitious stack stack machine here the

00:12:49,519 --> 00:12:52,459
instructions that we would use we would

00:12:50,870 --> 00:12:54,500
use load 1 now that's going to put a 1

00:12:52,459 --> 00:12:56,510
onto the stack we'd load 2 under the

00:12:54,500 --> 00:12:58,250
stack and 3 onto the stack so now we

00:12:56,510 --> 00:12:59,490
have our stack is kind of a list of

00:12:58,250 --> 00:13:01,920
three items

00:12:59,490 --> 00:13:03,779
and when the multiply instruction comes

00:13:01,920 --> 00:13:05,490
around it's going to take it's going to

00:13:03,779 --> 00:13:07,230
pop those first two items off the stack

00:13:05,490 --> 00:13:09,089
the the two and the three multiply them

00:13:07,230 --> 00:13:12,660
together get six and put that back on

00:13:09,089 --> 00:13:15,179
top of stack next when the ad comes

00:13:12,660 --> 00:13:17,069
along it is going to take the next two

00:13:15,179 --> 00:13:19,470
items off the top of stack the one in

00:13:17,069 --> 00:13:23,639
the six add them together and put the

00:13:19,470 --> 00:13:25,800
result back on the stack stack machines

00:13:23,639 --> 00:13:27,689
are cool and they're used a lot because

00:13:25,800 --> 00:13:29,879
they're ridiculously simple like I just

00:13:27,689 --> 00:13:32,069
explained most of the things you need to

00:13:29,879 --> 00:13:33,480
know about them right here they're

00:13:32,069 --> 00:13:36,360
really easy to implement they're really

00:13:33,480 --> 00:13:37,470
easy to reason about and and importantly

00:13:36,360 --> 00:13:39,779
these days they're also really easy to

00:13:37,470 --> 00:13:42,779
optimize so in fact in addition to

00:13:39,779 --> 00:13:44,850
Python Java PostScript the

00:13:42,779 --> 00:13:46,679
cryptocurrency etherium and Rubinius

00:13:44,850 --> 00:13:49,040
which is a which is a Ruby interpreter

00:13:46,679 --> 00:13:53,910
are also implemented with stack machines

00:13:49,040 --> 00:13:55,529
whoo okay so that was a lot time to get

00:13:53,910 --> 00:13:58,559
back to to the problem we have at hand

00:13:55,529 --> 00:14:00,209
here so if you remember we're trying to

00:13:58,559 --> 00:14:03,949
figure out why this tuple membership is

00:14:00,209 --> 00:14:05,910
slightly faster than the Equality and

00:14:03,949 --> 00:14:07,639
the first thing we're going to do is

00:14:05,910 --> 00:14:11,519
we're going to use disk to disassemble

00:14:07,639 --> 00:14:13,799
two functions that both perform equality

00:14:11,519 --> 00:14:14,809
and membership and see what instructions

00:14:13,799 --> 00:14:18,449
are being executed

00:14:14,809 --> 00:14:25,079
so first the instruction is for

00:14:18,449 --> 00:14:26,490
membership second for equality and just

00:14:25,079 --> 00:14:29,279
by the way if you're wondering these

00:14:26,490 --> 00:14:32,610
members here are indexes into the

00:14:29,279 --> 00:14:35,839
function Co under constants to poll that

00:14:32,610 --> 00:14:39,299
you may remember from previous slides

00:14:35,839 --> 00:14:41,429
and when we compare the two side-by-side

00:14:39,299 --> 00:14:42,449
we can see that they are virtually

00:14:41,429 --> 00:14:44,009
identical the only two little

00:14:42,449 --> 00:14:45,899
differences here the one is obviously

00:14:44,009 --> 00:14:48,329
we're using a tuple in the second

00:14:45,899 --> 00:14:50,610
instead of a string and the second is

00:14:48,329 --> 00:14:53,399
that compare off that compare operation

00:14:50,610 --> 00:14:55,589
on number six which is in the first

00:14:53,399 --> 00:14:58,459
version equality and in second version

00:14:55,589 --> 00:14:58,459
in membership

00:15:01,620 --> 00:15:07,420
now to go any deeper that this is as

00:15:05,890 --> 00:15:09,010
deep as the Python interpreter itself

00:15:07,420 --> 00:15:11,470
can go to start seeing what's happening

00:15:09,010 --> 00:15:13,660
next we need to dive under the hood into

00:15:11,470 --> 00:15:15,610
Python itself so again I'm going to be

00:15:13,660 --> 00:15:17,260
using Python 2.7 because that's what I'm

00:15:15,610 --> 00:15:19,120
a little bit more familiar with I've

00:15:17,260 --> 00:15:20,800
gone through all this in Python 3 6 and

00:15:19,120 --> 00:15:24,490
it seems to be virtually identical if

00:15:20,800 --> 00:15:26,770
you're playing along at home yeah so

00:15:24,490 --> 00:15:29,380
we're gonna grab a tarball extract it

00:15:26,770 --> 00:15:32,590
and just do a simple search for compare

00:15:29,380 --> 00:15:33,790
op now when you do the search you're

00:15:32,590 --> 00:15:35,500
going to get a bunch of different hits

00:15:33,790 --> 00:15:37,750
and I'm going to in the interest of time

00:15:35,500 --> 00:15:41,380
narrow them down to two that I want to

00:15:37,750 --> 00:15:44,260
point out the first one is people dot

00:15:41,380 --> 00:15:46,390
see people that see is it's really

00:15:44,260 --> 00:15:48,220
really interesting it performs these in

00:15:46,390 --> 00:15:50,200
place micro optimizations on the Python

00:15:48,220 --> 00:15:52,750
bytecode for instance it'll transform

00:15:50,200 --> 00:15:56,620
the statement not a in B into the

00:15:52,750 --> 00:15:58,270
statement a not in B because a are not a

00:15:56,620 --> 00:15:59,980
and B is actually two instructions

00:15:58,270 --> 00:16:02,290
that's a it's a membership and then in

00:15:59,980 --> 00:16:04,780
negation we're a not in B is actually

00:16:02,290 --> 00:16:08,560
just one instruction a negated

00:16:04,780 --> 00:16:10,480
membership I obviously don't have time I

00:16:08,560 --> 00:16:12,970
wish I had time and understanding to go

00:16:10,480 --> 00:16:14,620
through and explain it all but Allison

00:16:12,970 --> 00:16:16,930
Kapoor has a really really good blog

00:16:14,620 --> 00:16:18,940
post on this if you google Python people

00:16:16,930 --> 00:16:24,940
dot C you'll find it and she goes into a

00:16:18,940 --> 00:16:26,020
lot of detail there in this case so the

00:16:24,940 --> 00:16:30,490
one that we're going to be interested in

00:16:26,020 --> 00:16:33,130
is C eval dot C and again before we dive

00:16:30,490 --> 00:16:34,390
into that just a quick refresher these

00:16:33,130 --> 00:16:36,220
are the two sets of instructions that

00:16:34,390 --> 00:16:37,420
we're comparing and specifically what

00:16:36,220 --> 00:16:41,290
we're going to be trying to figure out

00:16:37,420 --> 00:16:42,850
is what happens at that line six that

00:16:41,290 --> 00:16:48,580
compare up and why these two are

00:16:42,850 --> 00:16:54,160
different so now is when we pray to the

00:16:48,580 --> 00:16:57,120
gods of demos oh-ho look at that can I

00:16:54,160 --> 00:17:00,630
get some ZUP when this is big enough ah

00:16:57,120 --> 00:17:00,630
beautiful good

00:17:04,069 --> 00:17:09,000
so here's where we're going to be

00:17:06,569 --> 00:17:14,669
starting our journey this is C of L dot

00:17:09,000 --> 00:17:16,559
C which is the main the main evaluation

00:17:14,669 --> 00:17:17,699
loop in Python so if you go back if you

00:17:16,559 --> 00:17:18,630
think back to that byte code the byte

00:17:17,699 --> 00:17:21,270
code is just like a string of

00:17:18,630 --> 00:17:23,400
instructions and C of l dot C just has a

00:17:21,270 --> 00:17:25,260
massive loop which is read one

00:17:23,400 --> 00:17:26,610
instruction execute that instruction go

00:17:25,260 --> 00:17:29,370
on to the next instruction and we just

00:17:26,610 --> 00:17:30,900
keep doing that forever if you're a

00:17:29,370 --> 00:17:34,049
little bit familiar with C you'll know

00:17:30,900 --> 00:17:35,340
what a switch statement is and the point

00:17:34,049 --> 00:17:37,470
in the code that we're at right now is

00:17:35,340 --> 00:17:38,880
the massive switch statement which is

00:17:37,470 --> 00:17:41,610
branching on the instruction being

00:17:38,880 --> 00:17:43,500
performed and particular we're at the

00:17:41,610 --> 00:17:47,130
line that performs the compare operation

00:17:43,500 --> 00:17:49,919
now the reason you don't see the keyword

00:17:47,130 --> 00:17:52,740
case there is because the target macro

00:17:49,919 --> 00:17:54,750
expands to some nifty tricks but that

00:17:52,740 --> 00:17:56,370
let's become excuse me that let the

00:17:54,750 --> 00:17:58,080
computed go to optimizations that were

00:17:56,370 --> 00:18:00,210
put in place a few years back work again

00:17:58,080 --> 00:18:02,940
really super cool Google computer go to

00:18:00,210 --> 00:18:05,610
Python and you'll get the tycoon's

00:18:02,940 --> 00:18:07,740
really neat how that works but anyway if

00:18:05,610 --> 00:18:09,840
you're not if you're not that familiar

00:18:07,740 --> 00:18:11,850
with C all that you need to know is this

00:18:09,840 --> 00:18:15,049
is a bit of code that gets executed when

00:18:11,850 --> 00:18:16,890
we're performing a comparison in Python

00:18:15,049 --> 00:18:19,080
the first thing you're going to see here

00:18:16,890 --> 00:18:21,059
the pop and talk so remember we're on a

00:18:19,080 --> 00:18:23,070
stack so pop takes the top item from the

00:18:21,059 --> 00:18:25,890
stack that's in this case going to be

00:18:23,070 --> 00:18:30,350
one of the strings and top just peeks at

00:18:25,890 --> 00:18:32,250
it to grab it out rooting through

00:18:30,350 --> 00:18:34,110
without knowing anything more about

00:18:32,250 --> 00:18:35,669
what's going on in Python we can guess

00:18:34,110 --> 00:18:38,429
kind of based on the context here that

00:18:35,669 --> 00:18:41,450
this pi into check exact is I'm checking

00:18:38,429 --> 00:18:43,559
to see if this is exactly an integer

00:18:41,450 --> 00:18:45,270
which leads me to one of the things that

00:18:43,559 --> 00:18:47,010
I really love about digging through the

00:18:45,270 --> 00:18:48,390
Python or really any project source code

00:18:47,010 --> 00:18:50,130
is you get to learn all these neat

00:18:48,390 --> 00:18:51,210
little tricks that the maintainer is put

00:18:50,130 --> 00:18:53,190
in and then if you get really ambitious

00:18:51,210 --> 00:18:54,600
you can go through and get blame and

00:18:53,190 --> 00:18:56,970
find the exact commit and read all the

00:18:54,600 --> 00:18:58,290
messages around it and in this case what

00:18:56,970 --> 00:18:59,610
we're seeing is that there's an

00:18:58,290 --> 00:19:01,890
optimization in place so that if you're

00:18:59,610 --> 00:19:03,510
comparing two integers instead of going

00:19:01,890 --> 00:19:04,799
through all the complex logic that we're

00:19:03,510 --> 00:19:06,360
going to be seeing in a minute we're

00:19:04,799 --> 00:19:08,309
actually just shortcutting and doing the

00:19:06,360 --> 00:19:10,700
comparison right there in line so that

00:19:08,309 --> 00:19:10,700
can be much faster

00:19:12,350 --> 00:19:20,890
scrolling down though we're going to get

00:19:14,360 --> 00:19:25,220
to this line here this is the actual

00:19:20,890 --> 00:19:27,860
starting point of the comparison recall

00:19:25,220 --> 00:19:29,720
that opt argh-argh if you either going

00:19:27,860 --> 00:19:34,610
to be in equality or a membership and

00:19:29,720 --> 00:19:35,870
ahbar extends for opcode argument V is

00:19:34,610 --> 00:19:38,480
going to be the right-hand side of that

00:19:35,870 --> 00:19:40,549
comparison so the string the string or

00:19:38,480 --> 00:19:48,260
the tuple and W is going to be the

00:19:40,549 --> 00:19:50,480
string X we're going to pick arbitrarily

00:19:48,260 --> 00:19:52,780
to follow the equality case first and

00:19:50,480 --> 00:19:55,039
trace through to see what happens so

00:19:52,780 --> 00:19:56,630
we've got this switch statement here so

00:19:55,039 --> 00:19:58,909
which if you don't know C is kind of

00:19:56,630 --> 00:20:00,740
like a set of change if else's and it's

00:19:58,909 --> 00:20:04,940
going to say you know if the operation

00:20:00,740 --> 00:20:09,409
is is is not comp in we're going to

00:20:04,940 --> 00:20:12,230
scroll down we don't see an explicit PI

00:20:09,409 --> 00:20:13,730
comp under EQ which again is is the

00:20:12,230 --> 00:20:15,140
equality operation which if you were

00:20:13,730 --> 00:20:16,460
doing this on your own you would

00:20:15,140 --> 00:20:17,990
probably spend five minutes searching

00:20:16,460 --> 00:20:24,830
around the source code until you figured

00:20:17,990 --> 00:20:26,840
that one out and find that the PyCon PQ

00:20:24,830 --> 00:20:27,860
is handled here now one of the things

00:20:26,840 --> 00:20:29,750
you're going to see me doing is I'm

00:20:27,860 --> 00:20:32,059
flying through this code is jumping to

00:20:29,750 --> 00:20:34,730
definitions so I'm using vim and in vim

00:20:32,059 --> 00:20:36,799
I use ctrl and then close square brace

00:20:34,730 --> 00:20:38,450
to do that if you use sublime they have

00:20:36,799 --> 00:20:41,150
the go-to symbol in project with command

00:20:38,450 --> 00:20:42,590
shift are and I'm sure any other editor

00:20:41,150 --> 00:20:44,690
you're using will have similar

00:20:42,590 --> 00:20:46,400
functionality and now if the only thing

00:20:44,690 --> 00:20:48,860
you take away from this talk is how to

00:20:46,400 --> 00:20:51,140
do that you have it's been way worse or

00:20:48,860 --> 00:20:55,659
time but hopefully you'll get one or two

00:20:51,140 --> 00:20:58,730
more things so diving into rich compare

00:20:55,659 --> 00:21:00,460
we can see we're just going to read

00:20:58,730 --> 00:21:03,320
through you know make sure we're not

00:21:00,460 --> 00:21:04,850
doing too much recursion here and the

00:21:03,320 --> 00:21:09,470
first thing we get to is this if

00:21:04,850 --> 00:21:11,720
statement and we're going to go right to

00:21:09,470 --> 00:21:15,350
left here so the pie instance check so

00:21:11,720 --> 00:21:16,850
what's a pie instance check now it's

00:21:15,350 --> 00:21:19,520
used to distinguish between old style

00:21:16,850 --> 00:21:22,159
classes and new style classes if you're

00:21:19,520 --> 00:21:23,179
in Happyland of Python 3 you can close

00:21:22,159 --> 00:21:25,280
your ears for a little while - this

00:21:23,179 --> 00:21:26,279
isn't relevant to you but if you're like

00:21:25,280 --> 00:21:28,799
me and you're on Python 2

00:21:26,279 --> 00:21:30,090
seven you'll know that old-style classes

00:21:28,799 --> 00:21:32,399
are what happens when you forget the

00:21:30,090 --> 00:21:34,080
object in a class definition and they

00:21:32,399 --> 00:21:35,580
were introduced and this our new style

00:21:34,080 --> 00:21:38,609
classes with the object were introduced

00:21:35,580 --> 00:21:39,960
into seven or sar-21 when there was a

00:21:38,609 --> 00:21:43,590
bunch of updates to the object model

00:21:39,960 --> 00:21:45,029
that would be backwards incompatible so

00:21:43,590 --> 00:21:46,139
if you if you like what we're doing here

00:21:45,029 --> 00:21:46,619
and you want to kind of try something on

00:21:46,139 --> 00:21:48,599
your own

00:21:46,619 --> 00:21:50,700
I'd recommend trying to figure out

00:21:48,599 --> 00:21:54,659
exactly why the app property decorator

00:21:50,700 --> 00:21:57,659
doesn't work in old-style classes but

00:21:54,659 --> 00:21:59,190
anyway will suffice it to say that by

00:21:57,659 --> 00:22:02,039
instance check will return true because

00:21:59,190 --> 00:22:05,219
these classes are strings and then going

00:22:02,039 --> 00:22:07,320
to the left-hand side here we see the

00:22:05,219 --> 00:22:12,690
test to test to check whether the

00:22:07,320 --> 00:22:13,830
objects types are identical now in C the

00:22:12,690 --> 00:22:16,080
left hand sides are things called

00:22:13,830 --> 00:22:18,659
structures there for the purposes of

00:22:16,080 --> 00:22:20,639
this demonstration equivalent objects

00:22:18,659 --> 00:22:22,049
but they really aren't and I'm going to

00:22:20,639 --> 00:22:27,089
get lots of hate mail if I imply that

00:22:22,049 --> 00:22:28,589
they are so we know we know the two

00:22:27,089 --> 00:22:31,859
there are two strings that the same

00:22:28,589 --> 00:22:34,889
moving down the next thing we see here

00:22:31,859 --> 00:22:37,409
is this rich comparison so what is a

00:22:34,889 --> 00:22:40,379
rich comparison well again pre Python

00:22:37,409 --> 00:22:42,089
free Python two one you could only

00:22:40,379 --> 00:22:43,919
really define one comparison method that

00:22:42,089 --> 00:22:46,739
would return negative one zero or one

00:22:43,919 --> 00:22:49,109
for two objects the new style classes

00:22:46,739 --> 00:22:51,149
and Python two one let you define all

00:22:49,109 --> 00:22:56,330
these rich comparisons like dunder EQ

00:22:51,149 --> 00:22:58,619
dunder GT dunder and lgt whatever um and

00:22:56,330 --> 00:23:00,029
key peerage compares the is the

00:22:58,619 --> 00:23:06,719
function of the c-level that handles all

00:23:00,029 --> 00:23:07,889
that it's a little bit easy to miss it

00:23:06,719 --> 00:23:10,559
took me a couple times the first time I

00:23:07,889 --> 00:23:12,839
was reading but this is the line that

00:23:10,559 --> 00:23:16,049
we're actually interested in this F rich

00:23:12,839 --> 00:23:17,639
is the rich compare operation so that

00:23:16,049 --> 00:23:20,309
for the objects we're comparing in this

00:23:17,639 --> 00:23:21,269
case they're strings they're type again

00:23:20,309 --> 00:23:22,289
you would figure this out if you were

00:23:21,269 --> 00:23:24,690
doing it on your own but I'm going to

00:23:22,289 --> 00:23:27,659
tell you Saiki brevity is pie type

00:23:24,690 --> 00:23:29,669
string and we're going to be looking for

00:23:27,659 --> 00:23:32,509
the rich compare function so I'm going

00:23:29,669 --> 00:23:32,509
to jump to that definition

00:23:34,700 --> 00:23:39,090
at the sea-level you'll notice that

00:23:37,440 --> 00:23:41,370
instead of defining objects with like

00:23:39,090 --> 00:23:42,690
helpful keywords and whatnot we just

00:23:41,370 --> 00:23:44,400
have a big list of functions and

00:23:42,690 --> 00:23:45,900
somebody has had to go through and make

00:23:44,400 --> 00:23:49,890
sure they line up all these comments on

00:23:45,900 --> 00:23:51,450
the left-hand side these comments if you

00:23:49,890 --> 00:23:52,650
or these functions if you notice them

00:23:51,450 --> 00:23:54,480
you'll see that they're actually the

00:23:52,650 --> 00:23:56,400
same things as the dunder magic methods

00:23:54,480 --> 00:23:59,400
for the most part that you're used to in

00:23:56,400 --> 00:24:01,890
Python so for instance TP rapper is the

00:23:59,400 --> 00:24:04,740
same as under ever in this case that

00:24:01,890 --> 00:24:09,600
we're looking for rich compare and there

00:24:04,740 --> 00:24:10,740
it is so this is the function that

00:24:09,600 --> 00:24:12,299
you're going to get when you compare two

00:24:10,740 --> 00:24:16,250
strings anytime two strings are compared

00:24:12,299 --> 00:24:19,559
in Python to seven this is your function

00:24:16,250 --> 00:24:20,549
now before we read any further one of

00:24:19,559 --> 00:24:22,080
the things that I want to point out and

00:24:20,549 --> 00:24:24,000
remind you of is when we were looking

00:24:22,080 --> 00:24:27,150
when we were looking at the the

00:24:24,000 --> 00:24:29,669
disassembly the to load Const up codes

00:24:27,150 --> 00:24:31,290
had the same argument that meant they

00:24:29,669 --> 00:24:34,559
were actually loading exactly the same

00:24:31,290 --> 00:24:36,720
string and this is this is happening

00:24:34,559 --> 00:24:38,850
because when place on loads a module it

00:24:36,720 --> 00:24:41,190
actually goes through and D duplicates

00:24:38,850 --> 00:24:45,630
some of the strings now this is some of

00:24:41,190 --> 00:24:47,370
them there's lots of magic logic around

00:24:45,630 --> 00:24:48,510
that and it's that logic is fascinating

00:24:47,370 --> 00:24:50,850
and I would really encourage you to go

00:24:48,510 --> 00:24:53,100
check it out afterwards but for for the

00:24:50,850 --> 00:24:54,330
MOOC for the moment we're only going to

00:24:53,100 --> 00:25:00,480
be concerned with the strings that it is

00:24:54,330 --> 00:25:01,890
that it is interning and to show you an

00:25:00,480 --> 00:25:03,660
example of that in turning this re

00:25:01,890 --> 00:25:06,030
interning as a purses of deduplication

00:25:03,660 --> 00:25:09,059
you can see that if I have two variables

00:25:06,030 --> 00:25:10,470
that reference the same string they are

00:25:09,059 --> 00:25:13,500
they point to the same member they're

00:25:10,470 --> 00:25:15,240
identical values this is possible in

00:25:13,500 --> 00:25:16,830
place on because in Python strings are

00:25:15,240 --> 00:25:18,720
immutable but you'll notice that often

00:25:16,830 --> 00:25:20,730
languages like Ruby that have mutable

00:25:18,720 --> 00:25:25,410
strings often have a symbol type which

00:25:20,730 --> 00:25:26,460
is kind of like an immutable string so

00:25:25,410 --> 00:25:30,750
we go down we notice those two are

00:25:26,460 --> 00:25:32,880
identical and this is where we end this

00:25:30,750 --> 00:25:38,070
portion of the journey we're seeing we

00:25:32,880 --> 00:25:39,120
get the PI true return and well that's

00:25:38,070 --> 00:25:43,620
what happens when you compare two

00:25:39,120 --> 00:25:45,600
strings so we're gonna pop back up here

00:25:43,620 --> 00:25:47,400
and now go through that same journey

00:25:45,600 --> 00:25:50,610
again but comparing the in the

00:25:47,400 --> 00:25:52,860
membership so hikent outcome we know

00:25:50,610 --> 00:25:55,110
that auth this time is going to be PI

00:25:52,860 --> 00:26:04,140
comp in and it's explicitly called out

00:25:55,110 --> 00:26:06,500
here it uses PI sequence contains which

00:26:04,140 --> 00:26:09,450
again we're going to go goes through

00:26:06,500 --> 00:26:10,620
similarly to equality there we're

00:26:09,450 --> 00:26:15,059
checking the type to see if it supports

00:26:10,620 --> 00:26:19,530
this you know sequence membership the PI

00:26:15,059 --> 00:26:20,760
tuple type does and the chain of chain

00:26:19,530 --> 00:26:27,780
of attributes we're looking for is here

00:26:20,760 --> 00:26:32,309
so TPI sequence and look at that tuple

00:26:27,780 --> 00:26:33,600
contains so this is another thing that I

00:26:32,309 --> 00:26:35,670
love when I'm reading through like

00:26:33,600 --> 00:26:37,500
Python source code is it looks all big

00:26:35,670 --> 00:26:39,000
and fancy and like abstract but then you

00:26:37,500 --> 00:26:39,929
get like to the you know the rubber hits

00:26:39,000 --> 00:26:42,390
the road and this is where we're just

00:26:39,929 --> 00:26:47,490
doing a computer science 101 type for

00:26:42,390 --> 00:26:48,960
loop over the elements in a tuple the

00:26:47,490 --> 00:26:51,360
big difference though here is we see

00:26:48,960 --> 00:26:53,550
this PI optic rich compare but this time

00:26:51,360 --> 00:26:54,900
we're calling PI optic rich compare bool

00:26:53,550 --> 00:26:59,820
which is a slightly different function

00:26:54,900 --> 00:27:03,480
and the very first thing that it does

00:26:59,820 --> 00:27:05,580
here is that identity check and if you

00:27:03,480 --> 00:27:07,290
remember that interning well interning

00:27:05,580 --> 00:27:12,540
works the same for Strings in tuples as

00:27:07,290 --> 00:27:17,400
outside of tuples which means it returns

00:27:12,540 --> 00:27:18,840
immediately here and there's the story

00:27:17,400 --> 00:27:21,630
of what happens with the identity

00:27:18,840 --> 00:27:22,860
compare with with membership now if we

00:27:21,630 --> 00:27:25,170
were doing this properly we would go

00:27:22,860 --> 00:27:26,309
through and we'd see kind of trace it

00:27:25,170 --> 00:27:28,530
into high level of detail what

00:27:26,309 --> 00:27:30,090
instructions are being executed but I'm

00:27:28,530 --> 00:27:32,070
short on time and I've done this for you

00:27:30,090 --> 00:27:33,350
so I can tell you that these are the two

00:27:32,070 --> 00:27:36,059
sets of instructions that are executed

00:27:33,350 --> 00:27:37,320
when on the left hand side we have the

00:27:36,059 --> 00:27:39,690
membership on the right hand side we

00:27:37,320 --> 00:27:42,030
have equality and you can see that the

00:27:39,690 --> 00:27:44,280
one is significantly longer than the

00:27:42,030 --> 00:27:47,900
other and lo and behold it's also slower

00:27:44,280 --> 00:27:53,060
than the other now I realize that was

00:27:47,900 --> 00:27:54,740
this is somewhat anticlimactic but your

00:27:53,060 --> 00:28:02,420
programmers in your youth the computers

00:27:54,740 --> 00:28:04,490
being pretty dreary so hopefully though

00:28:02,420 --> 00:28:06,080
and I need my notes here for this so I'm

00:28:04,490 --> 00:28:09,110
just going to go from here you'll know

00:28:06,080 --> 00:28:10,580
that that Python isn't magic you can see

00:28:09,110 --> 00:28:12,980
that even though sometimes it does these

00:28:10,580 --> 00:28:14,450
kind of magic looking things it's always

00:28:12,980 --> 00:28:17,150
possible to peek under the hood and see

00:28:14,450 --> 00:28:18,350
what's going on and and while this might

00:28:17,150 --> 00:28:20,060
not be a problem you'll ever have

00:28:18,350 --> 00:28:22,070
hopefully you can see how you could take

00:28:20,060 --> 00:28:23,720
those same sorts of techniques and apply

00:28:22,070 --> 00:28:26,540
them to problems you will have like your

00:28:23,720 --> 00:28:29,150
Django model not saving or your lip tree

00:28:26,540 --> 00:28:31,550
not pooling connections properly oh and

00:28:29,150 --> 00:28:34,160
finally you remember this code from the

00:28:31,550 --> 00:28:36,950
beginning now you should be able to

00:28:34,160 --> 00:28:39,410
explain why it why it works because the

00:28:36,950 --> 00:28:41,600
tuple membership is shortcutting to

00:28:39,410 --> 00:28:43,400
identity now quickly in the last two

00:28:41,600 --> 00:28:46,190
minutes before chris kicks me offstage

00:28:43,400 --> 00:28:48,590
there's two those three things one is a

00:28:46,190 --> 00:28:50,830
piece of homework so you you know how

00:28:48,590 --> 00:28:54,620
you can override methods on an object

00:28:50,830 --> 00:29:01,040
but you can't override dunder Len secure

00:28:54,620 --> 00:29:03,380
why that is second thing I'm hiring ya

00:29:01,040 --> 00:29:05,090
like my company is called a kindy we we

00:29:03,380 --> 00:29:06,470
make scantron style bubble sheets that

00:29:05,090 --> 00:29:07,880
are a little bit less terrible teachers

00:29:06,470 --> 00:29:09,590
can print them from any printer scan

00:29:07,880 --> 00:29:14,810
from any scanner get all the results

00:29:09,590 --> 00:29:15,950
online if you're if you're in Toronto or

00:29:14,810 --> 00:29:17,960
thinking about moving there and that

00:29:15,950 --> 00:29:20,210
sound and making teachers lives less

00:29:17,960 --> 00:29:21,310
terrible sounds interesting come talk to

00:29:20,210 --> 00:29:25,580
me

00:29:21,310 --> 00:29:27,890
finally I'm super not and I'm going to

00:29:25,580 --> 00:29:33,290
be having an op off in at two o'clock

00:29:27,890 --> 00:29:34,700
in d2l 112 so if you're asked use me I'm

00:29:33,290 --> 00:29:35,870
going to be geeking out about knots I'm

00:29:34,700 --> 00:29:37,640
going to be showing you some of my

00:29:35,870 --> 00:29:40,220
favorites and hopefully learning some

00:29:37,640 --> 00:29:44,440
new ones so come on out to that it'll be

00:29:40,220 --> 00:29:46,470
a great time also got thank you

00:29:44,440 --> 00:29:46,470
Oh

00:29:48,510 --> 00:29:51,680
[Music]

00:29:52,630 --> 00:29:57,370
we have 10 minutes until the next talk

00:29:55,299 --> 00:29:59,049
and it looks like can we please stop

00:29:57,370 --> 00:30:00,490
people from walking in we have a full

00:29:59,049 --> 00:30:02,650
house who need to get out of here at the

00:30:00,490 --> 00:30:04,150
moment there's a big crowd outside so if

00:30:02,650 --> 00:30:06,690
you need to leave please make sure you

00:30:04,150 --> 00:30:06,690

YouTube URL: https://www.youtube.com/watch?v=s5_5XmmwMx8


