Title: Miguel Grinberg   Asynchronous Python for the Complete Beginner   PyCon 2017
Publication date: 2017-05-21
Playlist: PyCon 2017
Description: 
	"Speaker: Miguel Grinberg

With the introduction of the asyncio package in Python 3.4, you can hear lots of people talking about asynchronous programming, most in a favorable way, some not so much. In this talk, I will tell you what this async fever is about and what can it do for you that regular Python can't, not only with asyncio, but also with other frameworks that existed long before it.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:00,030 --> 00:00:04,910
good afternoon everybody and welcome to

00:00:01,920 --> 00:00:07,200
our next presentation at PyCon 2017

00:00:04,910 --> 00:00:09,059
before we get started I would very much

00:00:07,200 --> 00:00:11,130
like you to encourage your electronic

00:00:09,059 --> 00:00:15,139
devices to not make any sudden noises

00:00:11,130 --> 00:00:15,139
because when they do everyone's desi

00:00:15,199 --> 00:00:18,930
with that said I would like to introduce

00:00:17,400 --> 00:00:20,970
our next speaker his name is Miguel

00:00:18,930 --> 00:00:22,529
Greenberg and he will be talking about

00:00:20,970 --> 00:00:25,820
asynchronous Python for the complete

00:00:22,529 --> 00:00:32,719
beginner please make him feel welcome

00:00:25,820 --> 00:00:38,040
thank you thank you thank you very much

00:00:32,719 --> 00:00:41,969
full house no pressure right man

00:00:38,040 --> 00:00:43,350
why do I do this anyway uh so I'm gonna

00:00:41,969 --> 00:00:45,510
get something out of the way this is not

00:00:43,350 --> 00:00:46,350
a talk about flask right I'm not going

00:00:45,510 --> 00:00:48,420
to talk about flask

00:00:46,350 --> 00:00:52,289
I'm gonna mention flask less than 10

00:00:48,420 --> 00:00:54,420
times I'm going to try at least okay so

00:00:52,289 --> 00:00:56,070
great so something that maybe you don't

00:00:54,420 --> 00:00:58,440
know in addition to all the work I do

00:00:56,070 --> 00:00:59,670
with you know that framework that I

00:00:58,440 --> 00:01:03,239
cannot say

00:00:59,670 --> 00:01:05,189
I also have a an open source project

00:01:03,239 --> 00:01:08,400
that it's an asynchronous server for the

00:01:05,189 --> 00:01:10,650
socket IO protocol that started as an

00:01:08,400 --> 00:01:13,470
extension to that you know that set

00:01:10,650 --> 00:01:14,010
framework but then it grew on a life of

00:01:13,470 --> 00:01:16,080
its own

00:01:14,010 --> 00:01:18,990
and now you can use it stand alone or

00:01:16,080 --> 00:01:22,470
with other frameworks like Django etc so

00:01:18,990 --> 00:01:27,600
I see a lot of people having problems

00:01:22,470 --> 00:01:29,040
working with asynchronous code so I'm

00:01:27,600 --> 00:01:32,310
going to start with a question how many

00:01:29,040 --> 00:01:35,670
of you have heard people say that a

00:01:32,310 --> 00:01:39,750
think makes your code go fast or really

00:01:35,670 --> 00:01:42,390
very fast okay so out of those of you

00:01:39,750 --> 00:01:44,130
that heard this but one and a why or

00:01:42,390 --> 00:01:46,079
don't understand how's that possible

00:01:44,130 --> 00:01:47,549
so this is the table for you I'm going

00:01:46,079 --> 00:01:51,899
to try to explain it in very simple

00:01:47,549 --> 00:01:53,460
terms at least I'm going to try so I'm

00:01:51,899 --> 00:01:55,920
going to start with a super simple

00:01:53,460 --> 00:01:59,700
definition we're going to build on this

00:01:55,920 --> 00:02:01,860
later but I think and I mean it is in a

00:01:59,700 --> 00:02:04,200
generic term I'm not specifically

00:02:01,860 --> 00:02:08,310
talking about async IO that's not the

00:02:04,200 --> 00:02:10,950
only way to do a thing but that is one

00:02:08,310 --> 00:02:13,730
way to do concurrent programming which

00:02:10,950 --> 00:02:19,920
means doing many things at once

00:02:13,730 --> 00:02:21,840
okay so let's let's go through the you

00:02:19,920 --> 00:02:24,690
know the few ways that we have in Python

00:02:21,840 --> 00:02:27,989
to do multiple things at once so the

00:02:24,690 --> 00:02:30,780
most obvious way is to use multiple

00:02:27,989 --> 00:02:33,209
processes right you from the terminal

00:02:30,780 --> 00:02:35,310
you can start your script two three four

00:02:33,209 --> 00:02:36,930
ten times and then all the scripts are

00:02:35,310 --> 00:02:40,019
going to run independently or at the

00:02:36,930 --> 00:02:41,840
same time and the operating system

00:02:40,019 --> 00:02:44,370
that's underneath will take care of

00:02:41,840 --> 00:02:48,360
sharing your CPU resources among all

00:02:44,370 --> 00:02:49,980
those instances when you're using C

00:02:48,360 --> 00:02:51,569
Python right there the most popular

00:02:49,980 --> 00:02:53,880
Python that's actually the only way you

00:02:51,569 --> 00:02:58,080
can get to use more than one CPU at the

00:02:53,880 --> 00:03:01,260
same time right this is the only way so

00:02:58,080 --> 00:03:04,110
the next way to run multiple things at

00:03:01,260 --> 00:03:06,330
once is to use threads and a thread it's

00:03:04,110 --> 00:03:08,250
a line of execution pretty much like

00:03:06,330 --> 00:03:11,010
process but you can have multiple

00:03:08,250 --> 00:03:13,709
threads in the context of one process so

00:03:11,010 --> 00:03:15,989
they all share access to common

00:03:13,709 --> 00:03:19,799
resources right which is a headache

00:03:15,989 --> 00:03:21,480
that's why threads have such such a bad

00:03:19,799 --> 00:03:26,430
fame right it's difficult to write

00:03:21,480 --> 00:03:28,970
threading code so the operating system

00:03:26,430 --> 00:03:31,829
again is doing all the heavy lifting on

00:03:28,970 --> 00:03:33,510
sharing the CPU you don't have to worry

00:03:31,829 --> 00:03:37,440
about it when you write your Python code

00:03:33,510 --> 00:03:39,569
and of course you know that the global

00:03:37,440 --> 00:03:42,389
interpreter lock in Python this is a

00:03:39,569 --> 00:03:45,090
special special to Python when you have

00:03:42,389 --> 00:03:48,269
multiple threads running code the global

00:03:45,090 --> 00:03:50,430
interpreter lock allows only one to run

00:03:48,269 --> 00:03:51,989
Python code at a given time so basically

00:03:50,430 --> 00:03:55,280
you're running in a single core even

00:03:51,989 --> 00:03:58,739
though you may have two or four or more

00:03:55,280 --> 00:04:01,260
so the third one is the topic of this

00:03:58,739 --> 00:04:03,420
talk right a synchronous programming so

00:04:01,260 --> 00:04:05,730
to make the mystery even bigger I'm

00:04:03,420 --> 00:04:09,000
going to tell you that the OAS does not

00:04:05,730 --> 00:04:11,160
participate here the OS as far as the

00:04:09,000 --> 00:04:13,079
u.s. is concerned you are going to have

00:04:11,160 --> 00:04:15,930
one process and there's going to be a

00:04:13,079 --> 00:04:18,389
single thread within that process but

00:04:15,930 --> 00:04:22,710
yes we we can get multiple things done

00:04:18,389 --> 00:04:26,610
at once so what's the trick

00:04:22,710 --> 00:04:28,289
so to try to explain this I'm gonna go

00:04:26,610 --> 00:04:31,710
you know thinking completely out of the

00:04:28,289 --> 00:04:36,930
box I'm going to pull a real world

00:04:31,710 --> 00:04:40,320
scenario from the world of chess so this

00:04:36,930 --> 00:04:42,810
is a very old photo the the lady in this

00:04:40,320 --> 00:04:45,870
photo it's a unit polgÃ¡r it's one of the

00:04:42,810 --> 00:04:47,639
best chess players in the world and what

00:04:45,870 --> 00:04:50,639
she's doing here it's it's called a

00:04:47,639 --> 00:04:53,729
chess exhibition I'm not sure this is

00:04:50,639 --> 00:04:55,770
still being done you know these days but

00:04:53,729 --> 00:04:58,710
it was pretty popular before computers

00:04:55,770 --> 00:05:01,710
killed the fun out of chess by not being

00:04:58,710 --> 00:05:04,229
so good at it but you know when I was a

00:05:01,710 --> 00:05:05,699
kid this were pretty exciting as you

00:05:04,229 --> 00:05:09,210
know events if you if you were into

00:05:05,699 --> 00:05:11,340
chess so basically she shows up at the

00:05:09,210 --> 00:05:13,740
event and then she plays a game of chess

00:05:11,340 --> 00:05:15,389
against a lot of lots of people

00:05:13,740 --> 00:05:17,880
everybody normal people like you and I

00:05:15,389 --> 00:05:20,550
right and she usually wins all of them

00:05:17,880 --> 00:05:24,840
right but it's the whole idea is to play

00:05:20,550 --> 00:05:26,250
with a chess champion right so what I'm

00:05:24,840 --> 00:05:29,159
going to do is imagine you need to run

00:05:26,250 --> 00:05:31,229
this event right so I'm going to just go

00:05:29,159 --> 00:05:32,520
back of the envelope math here and I'm

00:05:31,229 --> 00:05:34,979
gonna just pull some numbers out of

00:05:32,520 --> 00:05:37,380
nowhere so let's say that there are 24

00:05:34,979 --> 00:05:41,039
people showing up for the event right so

00:05:37,380 --> 00:05:42,990
there are 24 games and you know you did

00:05:41,039 --> 00:05:44,490
folder she's pretty good right so she's

00:05:42,990 --> 00:05:47,310
going to come up with a move on average

00:05:44,490 --> 00:05:49,380
in five seconds and if the opponents are

00:05:47,310 --> 00:05:52,550
going to take 55 seconds so we get a

00:05:49,380 --> 00:05:55,020
round minute for a pair of moves and

00:05:52,550 --> 00:05:57,479
let's say that for the average game

00:05:55,020 --> 00:05:59,370
there are 30 moves which is a short game

00:05:57,479 --> 00:06:00,419
but she's going to cream everyone so you

00:05:59,370 --> 00:06:04,130
know it's going to be a short game

00:06:00,419 --> 00:06:06,449
anyway for for most of them are all so

00:06:04,130 --> 00:06:09,539
imagine you're going to do this the

00:06:06,449 --> 00:06:11,220
synchronous way so for each game is

00:06:09,539 --> 00:06:13,590
going to last 30 minutes right half an

00:06:11,220 --> 00:06:15,539
hour right so she needs to play 24 of

00:06:13,590 --> 00:06:18,000
these so she's going to be there playing

00:06:15,539 --> 00:06:21,870
for 12 hours right which is pretty bad

00:06:18,000 --> 00:06:24,330
right for her especially so in reality

00:06:21,870 --> 00:06:26,070
we see that events stop don't run like

00:06:24,330 --> 00:06:29,340
that right they do something else so

00:06:26,070 --> 00:06:31,969
what they do is they use a sink Rinna's

00:06:29,340 --> 00:06:34,770
mode and it works more or less like this

00:06:31,969 --> 00:06:36,550
she walks to the first game and makes

00:06:34,770 --> 00:06:39,280
her move so five seconds

00:06:36,550 --> 00:06:41,470
fake and then she leaves the opponent on

00:06:39,280 --> 00:06:44,860
that table thinking but she doesn't wait

00:06:41,470 --> 00:06:47,380
she's not waiting there for the opponent

00:06:44,860 --> 00:06:50,770
to make a move she immediately moves to

00:06:47,380 --> 00:06:53,260
the second table and she makes a move on

00:06:50,770 --> 00:06:55,450
the second table and she leaves that

00:06:53,260 --> 00:06:58,150
opponent also thinking and moves to the

00:06:55,450 --> 00:06:59,500
third and the fourth and so on right so

00:06:58,150 --> 00:07:02,730
she can go around the room and make a

00:06:59,500 --> 00:07:03,970
move on all 24 games in two minutes

00:07:02,730 --> 00:07:06,250
right

00:07:03,970 --> 00:07:08,830
so by that time she's back at the first

00:07:06,250 --> 00:07:10,930
game and the opponent at the first game

00:07:08,830 --> 00:07:13,420
had more than enough time to make a move

00:07:10,930 --> 00:07:16,330
so she can make it you know can her next

00:07:13,420 --> 00:07:20,650
move on that game without waiting right

00:07:16,330 --> 00:07:22,750
so if you do the math she can she can

00:07:20,650 --> 00:07:25,750
play you know that there are all 24

00:07:22,750 --> 00:07:29,800
games and win them in one hour versus 12

00:07:25,750 --> 00:07:31,420
on the synchronous case right so when

00:07:29,800 --> 00:07:34,360
when people talk about I think that's

00:07:31,420 --> 00:07:36,430
being really fast it's this kind of fast

00:07:34,360 --> 00:07:39,100
right what we're not putting an implant

00:07:36,430 --> 00:07:39,670
on you the polgÃ¡r to play chess faster

00:07:39,100 --> 00:07:42,550
right

00:07:39,670 --> 00:07:45,250
we're just optimizing her time so that

00:07:42,550 --> 00:07:46,390
she doesn't waste time waiting right

00:07:45,250 --> 00:07:48,580
make sense

00:07:46,390 --> 00:07:50,890
that's all that's that's a secret by the

00:07:48,580 --> 00:07:54,400
way that's the complete secret so that's

00:07:50,890 --> 00:07:56,320
how it works so in this analogy you the

00:07:54,400 --> 00:08:00,240
polgÃ¡r the the chess champion will be

00:07:56,320 --> 00:08:03,130
our CPU and the idea is that we want to

00:08:00,240 --> 00:08:04,990
make sure that the CPU doesn't wait or

00:08:03,130 --> 00:08:08,370
wait the least amount of time possible

00:08:04,990 --> 00:08:11,470
and it's always finding something to do

00:08:08,370 --> 00:08:13,810
so now I can tell you a more complete

00:08:11,470 --> 00:08:15,520
definition this is still mine and I'm

00:08:13,810 --> 00:08:17,050
just you know inventing these

00:08:15,520 --> 00:08:19,570
definitions I didn't take them from

00:08:17,050 --> 00:08:24,370
anywhere but a synchronous programming

00:08:19,570 --> 00:08:26,110
is it's a mode in which the the tasks

00:08:24,370 --> 00:08:28,810
that are running release the CPU when

00:08:26,110 --> 00:08:30,880
they enter a waiting period and and then

00:08:28,810 --> 00:08:33,700
that allows other tasks that need the

00:08:30,880 --> 00:08:38,370
CPU to run while the the first task

00:08:33,700 --> 00:08:40,510
waits and basically that's the secret

00:08:38,370 --> 00:08:42,910
but you probably want to know a little

00:08:40,510 --> 00:08:46,690
bit more right how can you do that with

00:08:42,910 --> 00:08:48,880
one process on one set right so you need

00:08:46,690 --> 00:08:49,990
two things basically the first thing

00:08:48,880 --> 00:08:52,690
that you need which sound

00:08:49,990 --> 00:08:54,580
it's awfully difficult is to have a

00:08:52,690 --> 00:08:58,060
function that can suspend and resume

00:08:54,580 --> 00:09:00,550
right we want the functions that are in

00:08:58,060 --> 00:09:03,760
our asynchronous program to suspend when

00:09:00,550 --> 00:09:05,200
they enter a wait and and then when when

00:09:03,760 --> 00:09:07,209
that condition that generated the way

00:09:05,200 --> 00:09:08,920
ends we we want to pursue those

00:09:07,209 --> 00:09:13,930
functions from the point where they they

00:09:08,920 --> 00:09:15,670
were suspended so up sounds difficult

00:09:13,930 --> 00:09:17,920
but they're actually I come up with four

00:09:15,670 --> 00:09:21,490
ways in which you can do this in Python

00:09:17,920 --> 00:09:23,620
without operating system help and those

00:09:21,490 --> 00:09:25,600
ways are called up functions which are

00:09:23,620 --> 00:09:27,310
gross I'm not going to even show an

00:09:25,600 --> 00:09:31,630
example of that because they're pretty

00:09:27,310 --> 00:09:33,430
gross but three ways are a little bit

00:09:31,630 --> 00:09:35,170
more decent are using generator

00:09:33,430 --> 00:09:37,779
functions which is a Python switch

00:09:35,170 --> 00:09:39,550
feature from you know from years it's

00:09:37,779 --> 00:09:43,029
been there for a long time

00:09:39,550 --> 00:09:45,760
in more recent Python 3.5 an app there's

00:09:43,029 --> 00:09:48,100
a a think await keywords that you can

00:09:45,760 --> 00:09:50,320
use for that and then finally there's a

00:09:48,100 --> 00:09:52,750
third-party package called green LED

00:09:50,320 --> 00:09:54,970
that actually implement this as a C

00:09:52,750 --> 00:09:57,550
extension to Python and you can install

00:09:54,970 --> 00:10:01,690
that the tip and gives you another way

00:09:57,550 --> 00:10:03,399
to suspend understand functions so so

00:10:01,690 --> 00:10:05,589
that's the first part right so now we

00:10:03,399 --> 00:10:07,420
can suspend and resume the next thing

00:10:05,589 --> 00:10:10,029
that we need is we need a piece of code

00:10:07,420 --> 00:10:12,700
that can decide how the CPU is shared

00:10:10,029 --> 00:10:15,339
how you know which function gets the CPU

00:10:12,700 --> 00:10:17,560
next right so we need a scheduler of

00:10:15,339 --> 00:10:20,560
sorts and in asynchronous programming

00:10:17,560 --> 00:10:22,839
this is called an event loop so we're

00:10:20,560 --> 00:10:24,880
going to have an event loop it will know

00:10:22,839 --> 00:10:28,120
all the tasks that are running or that

00:10:24,880 --> 00:10:30,130
want to run and then it'll select one it

00:10:28,120 --> 00:10:32,680
will get control to it and then that

00:10:30,130 --> 00:10:35,860
task is going to suspend when it needs

00:10:32,680 --> 00:10:37,300
to wait for something and control will

00:10:35,860 --> 00:10:39,370
go back to the loop and the loop will

00:10:37,300 --> 00:10:42,610
find another one and that's it will keep

00:10:39,370 --> 00:10:44,220
going that way until the script ends so

00:10:42,610 --> 00:10:48,070
this is called a cooperative

00:10:44,220 --> 00:10:50,170
multitasking it's a saying you know from

00:10:48,070 --> 00:10:51,820
many years ago I mean there did the very

00:10:50,170 --> 00:10:55,510
old versions of Microsoft Windows for

00:10:51,820 --> 00:10:59,160
example or Mac OS did this so it's an

00:10:55,510 --> 00:11:02,260
old idea so anyway that's how it works

00:10:59,160 --> 00:11:03,540
so I created a bunch of examples to show

00:11:02,260 --> 00:11:05,670
you how this looks in

00:11:03,540 --> 00:11:08,190
practice I'm not going to have time to

00:11:05,670 --> 00:11:10,529
show all of them but I if you go or say

00:11:08,190 --> 00:11:11,820
that link you can see more examples that

00:11:10,529 --> 00:11:14,040
I created that I'm not gonna have time

00:11:11,820 --> 00:11:17,940
to show here but I'm not sure with field

00:11:14,040 --> 00:11:20,220
here so this is a super simple test that

00:11:17,940 --> 00:11:22,709
I created let's say we want to write a

00:11:20,220 --> 00:11:26,730
little script that prints hello wait

00:11:22,709 --> 00:11:28,800
three seconds and then prints world okay

00:11:26,730 --> 00:11:31,589
so this is how we will do it in normal

00:11:28,800 --> 00:11:33,569
Python right you will print the first

00:11:31,589 --> 00:11:36,360
text then sleep for three seconds and

00:11:33,569 --> 00:11:39,569
then print the second one right so if I

00:11:36,360 --> 00:11:42,329
were to put a for loop on that hello at

00:11:39,569 --> 00:11:44,399
the bottom to run the clock hello 10

00:11:42,329 --> 00:11:46,560
times for example this is going to run

00:11:44,399 --> 00:11:48,990
not for three seconds but for thirty

00:11:46,560 --> 00:11:51,120
seconds right if you know each function

00:11:48,990 --> 00:11:55,470
invocation will run and they're going to

00:11:51,120 --> 00:11:59,880
run back-to-back so here are two

00:11:55,470 --> 00:12:01,529
examples that use async IO and you can

00:11:59,880 --> 00:12:04,350
see you know there's a little bit of

00:12:01,529 --> 00:12:07,290
boilerplate at the top to create one of

00:12:04,350 --> 00:12:09,870
these event loops and there's another

00:12:07,290 --> 00:12:11,910
little couple of lines of boilerplate at

00:12:09,870 --> 00:12:15,360
the bottom to run the asynchronous

00:12:11,910 --> 00:12:18,029
function but ignoring that you can see

00:12:15,360 --> 00:12:20,399
that in the function we have we have

00:12:18,029 --> 00:12:22,440
here two ways to do this

00:12:20,399 --> 00:12:24,990
suspension suspending a function and

00:12:22,440 --> 00:12:27,449
then resuming on the left I'm using a

00:12:24,990 --> 00:12:30,180
generator function so generators are

00:12:27,449 --> 00:12:32,850
these special functions that typically

00:12:30,180 --> 00:12:36,269
you use in python to generate sequences

00:12:32,850 --> 00:12:39,000
of items and the nice thing about them

00:12:36,269 --> 00:12:40,760
is that you don't have to pre generate

00:12:39,000 --> 00:12:44,100
all the entire sequence you can generate

00:12:40,760 --> 00:12:45,449
elements of that sequence as you know

00:12:44,100 --> 00:12:49,019
that the person calling the generator

00:12:45,449 --> 00:12:52,769
asks so you can repurpose that using

00:12:49,019 --> 00:12:55,050
this yield or yield from keywords and

00:12:52,769 --> 00:12:56,880
also use it for anything connect

00:12:55,050 --> 00:12:59,279
function and basically what we're saying

00:12:56,880 --> 00:13:02,910
on the example in the left when we reach

00:12:59,279 --> 00:13:05,819
the yield from or saying okay loop I'm

00:13:02,910 --> 00:13:09,089
done for now so I give you back control

00:13:05,819 --> 00:13:11,220
please run the function for me that the

00:13:09,089 --> 00:13:13,019
one that follows the yield from so they

00:13:11,220 --> 00:13:15,449
think I'll sleep for three seconds and

00:13:13,019 --> 00:13:16,529
then when that's done I'm ready to

00:13:15,449 --> 00:13:18,569
continue

00:13:16,529 --> 00:13:20,939
and the loop will keep take note of that

00:13:18,569 --> 00:13:23,029
and then manage everything because it's

00:13:20,939 --> 00:13:26,819
a scheduler that's what it does

00:13:23,029 --> 00:13:29,999
so if I were to call this this hello

00:13:26,819 --> 00:13:32,129
function ten times instead of running

00:13:29,999 --> 00:13:34,829
for 30 seconds you're going to see ten

00:13:32,129 --> 00:13:36,569
hellos and then you know a pause of

00:13:34,829 --> 00:13:38,819
about three seconds and then you're

00:13:36,569 --> 00:13:41,220
going to see ten worlds because you know

00:13:38,819 --> 00:13:42,839
during that three second wake the loop

00:13:41,220 --> 00:13:44,910
will find you know all the other nine

00:13:42,839 --> 00:13:47,180
right it run one first and then the

00:13:44,910 --> 00:13:49,129
other nine eventually will get to run

00:13:47,180 --> 00:13:53,309
okay

00:13:49,129 --> 00:13:55,850
so increase in pythons there's an

00:13:53,309 --> 00:13:58,740
improvement you get a much nicer syntax

00:13:55,850 --> 00:14:00,480
which you can see on the right but you

00:13:58,740 --> 00:14:04,430
know functionally these two are

00:14:00,480 --> 00:14:06,569
equivalent and you have the async depth

00:14:04,430 --> 00:14:10,050
declaration that's what you use to

00:14:06,569 --> 00:14:13,139
define a synchronous function and then

00:14:10,050 --> 00:14:15,410
if you use that syntax to declare the

00:14:13,139 --> 00:14:19,259
function then you get to use a wait for

00:14:15,410 --> 00:14:21,389
for the suspension and assuming so

00:14:19,259 --> 00:14:23,009
that's the point where things are

00:14:21,389 --> 00:14:25,139
suspended and one of the things that I

00:14:23,009 --> 00:14:27,389
think I oh I think it's great for is

00:14:25,139 --> 00:14:30,089
that it makes very explicit the points

00:14:27,389 --> 00:14:32,480
where what the code suspends under

00:14:30,089 --> 00:14:35,699
Toombs you know all those points where

00:14:32,480 --> 00:14:40,379
we're at Lisa this magic of multitasking

00:14:35,699 --> 00:14:42,059
can happen but I think is not the only

00:14:40,379 --> 00:14:43,649
one there are there are a bunch of

00:14:42,059 --> 00:14:45,420
others actually I don't have time to

00:14:43,649 --> 00:14:48,420
tell you about all of them but I wanted

00:14:45,420 --> 00:14:50,699
to mention the ones that are based on

00:14:48,420 --> 00:14:55,529
the greenlit package that I mentioned

00:14:50,699 --> 00:14:58,459
early and they these two this RG event

00:14:55,529 --> 00:15:00,509
on the left and I don't let on the right

00:14:58,459 --> 00:15:02,670
you're probably going to have trouble

00:15:00,509 --> 00:15:05,339
finding what the loop is in this code

00:15:02,670 --> 00:15:06,329
and actually you're probably going to

00:15:05,339 --> 00:15:07,740
have trouble finding what's the

00:15:06,329 --> 00:15:10,199
difference between this and the

00:15:07,740 --> 00:15:12,990
synchronous Python example right they

00:15:10,199 --> 00:15:14,399
look kind of the same I don't know if

00:15:12,990 --> 00:15:15,929
you noticed but the only difference is

00:15:14,399 --> 00:15:19,019
that the sleep function that I'm using

00:15:15,929 --> 00:15:21,300
on these two is it's not the sleep

00:15:19,019 --> 00:15:22,920
function from the Python library it's a

00:15:21,300 --> 00:15:24,839
different one that each framework

00:15:22,920 --> 00:15:27,209
provides but that's the only difference

00:15:24,839 --> 00:15:29,880
and the goal of these two frameworks

00:15:27,209 --> 00:15:32,570
which are very much like

00:15:29,880 --> 00:15:36,030
to make asynchronous programming

00:15:32,570 --> 00:15:37,820
transparent solos and that could be a

00:15:36,030 --> 00:15:41,670
blessing and it also to be occurs

00:15:37,820 --> 00:15:43,710
depends on how you look at it me as an

00:15:41,670 --> 00:15:45,780
open source developer I find that a lot

00:15:43,710 --> 00:15:47,250
of people get into this thinking that

00:15:45,780 --> 00:15:49,770
it's all the same right I'm going to

00:15:47,250 --> 00:15:51,900
start doing whatever I do always and and

00:15:49,770 --> 00:15:53,970
then things weird things happen because

00:15:51,900 --> 00:15:56,430
that they're not considering that this

00:15:53,970 --> 00:15:58,140
underneath is running a loop and you

00:15:56,430 --> 00:16:00,450
need to make sure that you never block

00:15:58,140 --> 00:16:04,380
because if you go if you block then

00:16:00,450 --> 00:16:07,070
you're blocking the whole thing which

00:16:04,380 --> 00:16:11,280
leads into the pitfalls this is this is

00:16:07,070 --> 00:16:12,710
actually I'm interested here in saying

00:16:11,280 --> 00:16:15,630
these things that I'm constantly

00:16:12,710 --> 00:16:18,180
answering on my on the issues on my

00:16:15,630 --> 00:16:22,080
github project because people always

00:16:18,180 --> 00:16:25,410
trip on these things and people number

00:16:22,080 --> 00:16:26,580
one is that what happens if you have you

00:16:25,410 --> 00:16:29,760
know we probably have an asynchronous

00:16:26,580 --> 00:16:32,460
program about maybe one task or a few of

00:16:29,760 --> 00:16:35,430
the tasks need to do some heavy CPU

00:16:32,460 --> 00:16:39,510
calculation right and the problem is if

00:16:35,430 --> 00:16:42,090
you use the CPU in your function for say

00:16:39,510 --> 00:16:44,070
one minute then during that minute

00:16:42,090 --> 00:16:47,520
nothing else will happen because this is

00:16:44,070 --> 00:16:50,190
a single thread right so all tasks need

00:16:47,520 --> 00:16:52,800
to to be you know nice to the remaining

00:16:50,190 --> 00:16:55,500
tasks and release the CPU often so if

00:16:52,800 --> 00:16:58,140
you have an opportunity to wait right

00:16:55,500 --> 00:17:00,270
nothing to wait for what do you do and

00:16:58,140 --> 00:17:03,060
what you do is to sleep basically you

00:17:00,270 --> 00:17:04,770
have to be nice and call sleep every

00:17:03,060 --> 00:17:07,860
once in a while in your function that's

00:17:04,770 --> 00:17:10,350
often as you can and if you're really

00:17:07,860 --> 00:17:11,850
greedy and you don't want to release you

00:17:10,350 --> 00:17:14,220
know you don't want to give up the time

00:17:11,850 --> 00:17:16,829
that you've got the best you can do is

00:17:14,220 --> 00:17:19,500
you can sleep for zero seconds which is

00:17:16,829 --> 00:17:20,939
basically telling the loop I'm going to

00:17:19,500 --> 00:17:23,189
sleep because I have to I don't want to

00:17:20,939 --> 00:17:25,439
but I have to but please give me control

00:17:23,189 --> 00:17:27,900
back as soon as possible because I wanna

00:17:25,439 --> 00:17:29,790
have used this video so basically you

00:17:27,900 --> 00:17:31,740
sleep zero and if you calculation has a

00:17:29,790 --> 00:17:35,010
loop which which is pretty common

00:17:31,740 --> 00:17:37,710
then you stick a sleep zero inside that

00:17:35,010 --> 00:17:41,070
loop so once per iteration you allow

00:17:37,710 --> 00:17:43,210
other tasks to continue running so this

00:17:41,070 --> 00:17:44,289
number one now the big

00:17:43,210 --> 00:17:47,950
and this is going to be a big surprise

00:17:44,289 --> 00:17:50,409
probably there's a bunch of things in

00:17:47,950 --> 00:17:53,500
the Python standard library that are

00:17:50,409 --> 00:17:55,210
designed as blocking functions right so

00:17:53,500 --> 00:17:57,190
everything that has to do with

00:17:55,210 --> 00:18:00,340
networking so reading writing from

00:17:57,190 --> 00:18:03,130
network sockets waiting on input or

00:18:00,340 --> 00:18:05,590
output from sockets anything to do with

00:18:03,130 --> 00:18:08,169
processes with threads the sleep

00:18:05,590 --> 00:18:10,149
function that we we've seen before you

00:18:08,169 --> 00:18:13,210
cannot use them so this is true for

00:18:10,149 --> 00:18:14,529
every async framework you cannot use

00:18:13,210 --> 00:18:16,840
these functions if you use these

00:18:14,529 --> 00:18:19,990
functions the thing is going to hang so

00:18:16,840 --> 00:18:22,440
don't use them okay it's very

00:18:19,990 --> 00:18:25,330
unfortunate people it's like they they

00:18:22,440 --> 00:18:28,510
they want me to tell them when when they

00:18:25,330 --> 00:18:32,950
ask about this you know I want to use

00:18:28,510 --> 00:18:35,850
them well you can't so you can't

00:18:32,950 --> 00:18:38,559
so all async frameworks provide

00:18:35,850 --> 00:18:40,360
replacements for these functions right

00:18:38,559 --> 00:18:42,549
and sometimes that kind of sucks because

00:18:40,360 --> 00:18:44,500
you have to learn a different way to do

00:18:42,549 --> 00:18:46,299
the things that you know how to do right

00:18:44,500 --> 00:18:49,860
all these very common things that you do

00:18:46,299 --> 00:18:52,809
with processes threads and networking

00:18:49,860 --> 00:18:56,919
unfortunate but it's true for async IO

00:18:52,809 --> 00:18:59,169
true for Evan Leedy event twisted curio

00:18:56,919 --> 00:19:01,059
you know all of them they all provide

00:18:59,169 --> 00:19:05,529
alternative ways to do these blocking

00:19:01,059 --> 00:19:07,779
things now you remember the sleep

00:19:05,529 --> 00:19:10,450
function in Evan let and G event that

00:19:07,779 --> 00:19:14,620
was coded you know almost or actually

00:19:10,450 --> 00:19:16,240
it's identical to the Python one so the

00:19:14,620 --> 00:19:19,750
the folks that developed level 8 and G

00:19:16,240 --> 00:19:22,510
event they went other way to create all

00:19:19,750 --> 00:19:24,370
these alternative versions very in a

00:19:22,510 --> 00:19:27,610
very compatible way to the ones in the

00:19:24,370 --> 00:19:30,100
Python library and they have both this

00:19:27,610 --> 00:19:33,240
option to monkey patch the standard

00:19:30,100 --> 00:19:36,850
library so basically they swap out the

00:19:33,240 --> 00:19:39,250
blocking functions from the Python

00:19:36,850 --> 00:19:41,860
library and they put their own instead

00:19:39,250 --> 00:19:43,830
in their place so then you can take any

00:19:41,860 --> 00:19:47,200
piece of code that was designed to run

00:19:43,830 --> 00:19:50,559
synchronously and somehow they inherit

00:19:47,200 --> 00:19:53,529
this asynchronous behavior and for many

00:19:50,559 --> 00:19:55,059
applications that that's enough to get a

00:19:53,529 --> 00:19:56,590
you know code that was assigned

00:19:55,059 --> 00:19:57,880
synchronously to work

00:19:56,590 --> 00:20:00,909
but you have to use have a letter G

00:19:57,880 --> 00:20:02,860
event now I'm going to say you guys time

00:20:00,909 --> 00:20:05,409
somebody who is going to come later in

00:20:02,860 --> 00:20:07,450
the question period and ask how do I do

00:20:05,409 --> 00:20:09,279
this for a sinc IO and I'm going to say

00:20:07,450 --> 00:20:10,900
no you can't you're not going to do this

00:20:09,279 --> 00:20:13,419
with a sink I think are you able to

00:20:10,900 --> 00:20:16,990
signed as an async framework that

00:20:13,419 --> 00:20:19,620
doesn't try to hide the asynchronously

00:20:16,990 --> 00:20:22,270
you know under the rug it wants you to

00:20:19,620 --> 00:20:24,909
design and write your code thinking

00:20:22,270 --> 00:20:26,710
asynchronously which is a different goal

00:20:24,909 --> 00:20:33,130
than these are these two I don't live in

00:20:26,710 --> 00:20:37,480
fear that so I'm gonna summarize this

00:20:33,130 --> 00:20:39,700
with a little table and it's probably

00:20:37,480 --> 00:20:42,159
going to be surprising to some of you so

00:20:39,700 --> 00:20:46,990
this compares processes threads and they

00:20:42,159 --> 00:20:49,630
think on a number of categories so maybe

00:20:46,990 --> 00:20:53,580
based on what I said so far you you

00:20:49,630 --> 00:20:55,899
think that these are super cool

00:20:53,580 --> 00:20:58,240
non-blocking not known you know doing

00:20:55,899 --> 00:21:02,220
something while a task waits it's

00:20:58,240 --> 00:21:04,419
exclusive to async and that is not true

00:21:02,220 --> 00:21:07,179
processes and threads can do that pretty

00:21:04,419 --> 00:21:08,830
well too and it's actually not Python

00:21:07,179 --> 00:21:11,860
doing it in that case it's the operating

00:21:08,830 --> 00:21:14,260
system doing it so there's no winner

00:21:11,860 --> 00:21:16,330
here right there's a slight difference

00:21:14,260 --> 00:21:19,179
in the processes and threads case it's

00:21:16,330 --> 00:21:21,460
the operating system doing it in the

00:21:19,179 --> 00:21:23,649
async case you have you know your async

00:21:21,460 --> 00:21:26,740
framework I think I LG event or so on

00:21:23,649 --> 00:21:30,340
they're doing it so it's cooperative for

00:21:26,740 --> 00:21:31,990
async but under pre-emptive which is

00:21:30,340 --> 00:21:33,340
called when the operating system Yanks

00:21:31,990 --> 00:21:37,120
the CPU out of you without you knowing

00:21:33,340 --> 00:21:38,850
it but all of them can do it so there's

00:21:37,120 --> 00:21:42,070
no winner in this category

00:21:38,850 --> 00:21:44,440
now I already told you that if you want

00:21:42,070 --> 00:21:46,750
to maximize your multiple cores in your

00:21:44,440 --> 00:21:48,190
computer then the only waste processes

00:21:46,750 --> 00:21:50,200
right so that there's clear winner

00:21:48,190 --> 00:21:52,299
processes is the only option that can do

00:21:50,200 --> 00:21:54,549
that and many times people combine

00:21:52,299 --> 00:21:56,919
processes with one of the other two so

00:21:54,549 --> 00:21:59,649
you run a multi-threaded on an async

00:21:56,919 --> 00:22:02,020
program and then they run it as many

00:21:59,649 --> 00:22:05,980
times as course you have which is

00:22:02,020 --> 00:22:09,039
actually a pretty good idea but the

00:22:05,980 --> 00:22:10,400
processes is the winner there so then we

00:22:09,039 --> 00:22:13,150
come to scalability

00:22:10,400 --> 00:22:15,800
and this is an interesting one because

00:22:13,150 --> 00:22:18,470
if you're running multiple processes

00:22:15,800 --> 00:22:20,480
each process will have a copy of the

00:22:18,470 --> 00:22:22,640
Python interpreter but all and all the

00:22:20,480 --> 00:22:24,650
resources that it uses plus a copy of

00:22:22,640 --> 00:22:26,990
your code your application plus all the

00:22:24,650 --> 00:22:29,300
resources that you use so all of that is

00:22:26,990 --> 00:22:32,180
going to be duplicated so if you start

00:22:29,300 --> 00:22:33,410
going crazy and start new instances

00:22:32,180 --> 00:22:35,090
you're going to find that you know

00:22:33,410 --> 00:22:36,320
pretty soon you're going to reach you

00:22:35,090 --> 00:22:39,440
know you're going to be a probably out

00:22:36,320 --> 00:22:42,260
of memory you can really run you cannot

00:22:39,440 --> 00:22:45,910
run a lot of Python processes on a

00:22:42,260 --> 00:22:48,320
normal computer so scalability preload

00:22:45,910 --> 00:22:51,920
you know I would say in the ones or the

00:22:48,320 --> 00:22:53,420
tens but not more than that if you go to

00:22:51,920 --> 00:22:57,410
threads that's a little bit more

00:22:53,420 --> 00:22:59,929
lightweight the processes so you can you

00:22:57,410 --> 00:23:02,809
can associate a much more threads and

00:22:59,929 --> 00:23:05,630
processes so that that's better you can

00:23:02,809 --> 00:23:09,050
scale a little bit better I would say in

00:23:05,630 --> 00:23:11,120
the hundreds if you go with async async

00:23:09,050 --> 00:23:12,800
it's all done in Python space there's no

00:23:11,120 --> 00:23:14,809
resources at the operating system level

00:23:12,800 --> 00:23:18,020
that I use so these are extremely

00:23:14,809 --> 00:23:21,020
lightweight so this is the clear winner

00:23:18,020 --> 00:23:23,900
they think can go into thousands or tens

00:23:21,020 --> 00:23:28,850
of thousands even so this this would be

00:23:23,900 --> 00:23:31,490
a good reason to go async now we have

00:23:28,850 --> 00:23:33,070
the bad news of the using the blocking

00:23:31,490 --> 00:23:35,929
functions in the Python standard library

00:23:33,070 --> 00:23:38,270
which processes and threads can do no

00:23:35,929 --> 00:23:40,850
problem because the operating system

00:23:38,270 --> 00:23:42,620
knows how to deal with those but when we

00:23:40,850 --> 00:23:44,270
lose the support of the operating system

00:23:42,620 --> 00:23:49,420
in a think we cannot use those functions

00:23:44,270 --> 00:23:52,940
and we need replacements and then last

00:23:49,420 --> 00:23:55,550
the global interpreter lock we know it

00:23:52,940 --> 00:23:58,610
causes some trouble with threads in my

00:23:55,550 --> 00:24:01,160
experience though it's not that bad when

00:23:58,610 --> 00:24:03,650
you have the types of applications that

00:24:01,160 --> 00:24:07,160
are good for also for async which are

00:24:03,650 --> 00:24:09,320
heavily i/o because unlike some people

00:24:07,160 --> 00:24:12,170
think if you have threads that are

00:24:09,320 --> 00:24:14,179
blocked on i/o that you don't hold the

00:24:12,170 --> 00:24:16,640
global interpreter lock so if a thread

00:24:14,179 --> 00:24:19,310
goes to wait then the operating system

00:24:16,640 --> 00:24:21,460
will give will access will be able to

00:24:19,310 --> 00:24:23,780
give access to another another thread

00:24:21,460 --> 00:24:28,010
without any problems

00:24:23,780 --> 00:24:29,510
so really it's not that great right I

00:24:28,010 --> 00:24:33,860
mean there aren't that many things are

00:24:29,510 --> 00:24:38,390
better for for a sink it's that right

00:24:33,860 --> 00:24:40,220
that's it so basically the closing

00:24:38,390 --> 00:24:44,780
statement that I would like to make is

00:24:40,220 --> 00:24:47,799
that really the best argument to go a

00:24:44,780 --> 00:24:51,320
sink is when you really need massive

00:24:47,799 --> 00:24:54,350
scaling right so this would be servers

00:24:51,320 --> 00:24:55,820
that are going to be very busy lots of

00:24:54,350 --> 00:24:58,490
clients want to handle lots of clients

00:24:55,820 --> 00:25:01,970
without you know going bankrupt in in

00:24:58,490 --> 00:25:03,320
buying a hosting right so async can do

00:25:01,970 --> 00:25:04,909
that really well you can go into

00:25:03,320 --> 00:25:07,880
thousands or the tens of thousands of

00:25:04,909 --> 00:25:10,789
connections and it's like nothing it's

00:25:07,880 --> 00:25:14,090
not a problem which threads cannot get

00:25:10,789 --> 00:25:16,970
there and even less processes any other

00:25:14,090 --> 00:25:18,440
any other categories it's not really you

00:25:16,970 --> 00:25:20,450
know clear that we should go I think

00:25:18,440 --> 00:25:22,789
unless you like it and then it's a

00:25:20,450 --> 00:25:24,650
totally valid framework to develop your

00:25:22,789 --> 00:25:25,940
applications right so if you like it you

00:25:24,650 --> 00:25:29,600
like it right there's nothing to say

00:25:25,940 --> 00:25:32,539
against that so this is pretty much all

00:25:29,600 --> 00:25:35,000
I have I looks like I did good time

00:25:32,539 --> 00:25:37,220
right so just going to be time for

00:25:35,000 --> 00:25:41,520
questions looks like okay

00:25:37,220 --> 00:25:44,680
[Music]

00:25:41,520 --> 00:25:48,010
Thank You Miguel are there any questions

00:25:44,680 --> 00:25:51,970
yes yep on here so my question is is it

00:25:48,010 --> 00:25:57,340
possible to schedule a synchronous

00:25:51,970 --> 00:26:00,550
operation from multiple threads you can

00:25:57,340 --> 00:26:03,280
run a loop in front of multiple loops

00:26:00,550 --> 00:26:04,900
right in different threads so it's like

00:26:03,280 --> 00:26:06,910
this first thread right correct they

00:26:04,900 --> 00:26:08,350
don't go together in the same bucket and

00:26:06,910 --> 00:26:10,380
then you know then you have to use

00:26:08,350 --> 00:26:12,610
normal threading you know

00:26:10,380 --> 00:26:14,650
synchronization mechanisms if you need

00:26:12,610 --> 00:26:17,470
you know the tasks that are running

00:26:14,650 --> 00:26:20,860
under one loop to somehow coordinate

00:26:17,470 --> 00:26:23,580
with the other it gets pretty nasty to

00:26:20,860 --> 00:26:26,410
be honest so pretty much you get

00:26:23,580 --> 00:26:28,690
affiliated to that thread the data

00:26:26,410 --> 00:26:30,870
correct the loading yes yes because most

00:26:28,690 --> 00:26:34,530
of times you have only one thread so yes

00:26:30,870 --> 00:26:37,120
thank you yep hi Miguel

00:26:34,530 --> 00:26:38,560
thank you for that talk I was hoping if

00:26:37,120 --> 00:26:40,780
you can give me some help trying to

00:26:38,560 --> 00:26:42,760
conceptualize this and like a stack

00:26:40,780 --> 00:26:45,180
frame all this magic that happens not

00:26:42,760 --> 00:26:47,320
necessarily just what they think but

00:26:45,180 --> 00:26:51,940
generators and everything in general

00:26:47,320 --> 00:26:54,580
ah well generators a Python feature

00:26:51,940 --> 00:26:56,380
right they already support the you know

00:26:54,580 --> 00:26:58,690
say in the context when when the

00:26:56,380 --> 00:27:01,900
generator function calls the yield or

00:26:58,690 --> 00:27:04,810
give from keyword it basically returns

00:27:01,900 --> 00:27:07,060
it does sort of a partial return returns

00:27:04,810 --> 00:27:10,090
the value and and control goes back to

00:27:07,060 --> 00:27:12,370
the loop and then the loop can call that

00:27:10,090 --> 00:27:14,440
again to you know to make that function

00:27:12,370 --> 00:27:15,970
to do a little bit more work which is

00:27:14,440 --> 00:27:18,670
exactly what you do when when you write

00:27:15,970 --> 00:27:20,140
a generator function you basically you

00:27:18,670 --> 00:27:22,330
have a function that returns partial

00:27:20,140 --> 00:27:23,950
values every time you call it it that's

00:27:22,330 --> 00:27:26,230
a little bit more work and returns

00:27:23,950 --> 00:27:28,240
another you know another value and as a

00:27:26,230 --> 00:27:30,610
result okay that makes an additional

00:27:28,240 --> 00:27:33,250
question game unit in a architecture

00:27:30,610 --> 00:27:37,420
where you spawned off multiple processes

00:27:33,250 --> 00:27:39,700
of the async workers in say for a server

00:27:37,420 --> 00:27:41,260
how do you like the socket binding how

00:27:39,700 --> 00:27:44,890
would that work across the different

00:27:41,260 --> 00:27:46,810
processing uh it's it's only one set

00:27:44,890 --> 00:27:49,450
that that will have a really large

00:27:46,810 --> 00:27:51,160
number of connections but if I have the

00:27:49,450 --> 00:27:53,320
same port that has to go through

00:27:51,160 --> 00:27:56,300
multiple processes

00:27:53,320 --> 00:27:59,570
after them have a single thread of async

00:27:56,300 --> 00:28:03,200
add the double to two ways to do it so

00:27:59,570 --> 00:28:06,320
for example you can have a something

00:28:03,200 --> 00:28:08,300
like nginx a reverse proxy in front so

00:28:06,320 --> 00:28:10,100
then your say you have four processes

00:28:08,300 --> 00:28:13,220
they could be listening on different

00:28:10,100 --> 00:28:15,590
ports right four ports say and then

00:28:13,220 --> 00:28:18,740
nginx you know consolidates that and

00:28:15,590 --> 00:28:21,650
then reverse proxies into all these that

00:28:18,740 --> 00:28:22,010
canned async processes that would be one

00:28:21,650 --> 00:28:27,160
way

00:28:22,010 --> 00:28:31,580
thank you that make sense how much more

00:28:27,160 --> 00:28:34,760
imprecise is an async sleep command than

00:28:31,580 --> 00:28:36,160
time dot sleep ah

00:28:34,760 --> 00:28:40,700
[Music]

00:28:36,160 --> 00:28:44,210
or could it be like seconds more or a

00:28:40,700 --> 00:28:46,790
 a couple Miller elegance so this

00:28:44,210 --> 00:28:49,880
is this is so cooperative right so you

00:28:46,790 --> 00:28:51,710
really your task depends on how the

00:28:49,880 --> 00:28:54,560
other tasks that are running at the same

00:28:51,710 --> 00:28:56,960
time behave right if you have a rogue

00:28:54,560 --> 00:28:59,540
task that you know that that's a lot of

00:28:56,960 --> 00:29:02,450
computation and that's an return to the

00:28:59,540 --> 00:29:05,330
loop a software X it should that's going

00:29:02,450 --> 00:29:06,800
to affect your timing so yes and that

00:29:05,330 --> 00:29:09,590
that's actually the the problem that I

00:29:06,800 --> 00:29:11,440
see most often is that you know people

00:29:09,590 --> 00:29:13,430
forget that they're doing a sink and

00:29:11,440 --> 00:29:15,620
there's some task that that's something

00:29:13,430 --> 00:29:18,740
that looks and that stops the whole

00:29:15,620 --> 00:29:20,630
thing for everybody so yes imprecise

00:29:18,740 --> 00:29:22,970
sure you need to make sure that all the

00:29:20,630 --> 00:29:26,870
tasks are well designed for I think we

00:29:22,970 --> 00:29:28,880
have time for one more short question so

00:29:26,870 --> 00:29:31,430
I guess my question is related to the

00:29:28,880 --> 00:29:34,100
one the gentleman asks previously so

00:29:31,430 --> 00:29:36,770
actually in in JavaScript one of the

00:29:34,100 --> 00:29:39,680
issues is we used to be say for 10

00:29:36,770 --> 00:29:42,710
second it's actually at least a 10

00:29:39,680 --> 00:29:45,170
second so I guess in Taichung they have

00:29:42,710 --> 00:29:47,390
the same issue when I want to sleep a

00:29:45,170 --> 00:29:50,030
certain callback for 10 seconds they

00:29:47,390 --> 00:29:53,120
still at least a 10 second mm-hmm

00:29:50,030 --> 00:29:56,300
they're right it it depends on which

00:29:53,120 --> 00:29:58,010
depends on the other item should as I

00:29:56,300 --> 00:29:59,630
said before the sleep function is going

00:29:58,010 --> 00:30:01,970
to be implemented by the a sync frame

00:29:59,630 --> 00:30:04,550
book framework that you use right so I

00:30:01,970 --> 00:30:06,230
think I owe implements sleep and then G

00:30:04,550 --> 00:30:07,100
event implements sleep in a different

00:30:06,230 --> 00:30:09,440
way right the wrong way

00:30:07,100 --> 00:30:12,080
and you know every framework does it in

00:30:09,440 --> 00:30:14,450
its own way and you can you know you're

00:30:12,080 --> 00:30:16,370
going to have to find the best async

00:30:14,450 --> 00:30:18,590
framework if you are concerned about

00:30:16,370 --> 00:30:22,279
that right you need to find the one that

00:30:18,590 --> 00:30:24,799
it's more accurate but in the end it's

00:30:22,279 --> 00:30:27,649
cooperative so it depends on all the

00:30:24,799 --> 00:30:29,269
tasks being nice to each other if you

00:30:27,649 --> 00:30:32,450
don't have that then this this doesn't

00:30:29,269 --> 00:30:34,460
work well I guess in JavaScript at least

00:30:32,450 --> 00:30:37,309
the guarantees there will be at least

00:30:34,460 --> 00:30:39,320
ten seconds yeah and you get a

00:30:37,309 --> 00:30:41,149
guaranteed you know of that sort but you

00:30:39,320 --> 00:30:43,820
know exact times are you know heavily

00:30:41,149 --> 00:30:45,740
dependent on how the tasks return to the

00:30:43,820 --> 00:30:46,970
loop I think this feels like I do thank

00:30:45,740 --> 00:30:47,779
you it could be continued out in the

00:30:46,970 --> 00:30:51,970
hallway please

00:30:47,779 --> 00:30:51,970
many thanks to Miguel thank you

00:30:53,270 --> 00:30:58,869

YouTube URL: https://www.youtube.com/watch?v=iG6fr81xHKA


