Title: Tom Christie   Level up! Rethinking the Web API framework    PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Tom Christie

Think there's nothing left to explore in how we design Web API frameworks? Think again.

The author of Django REST framework walks through how we might approach designing a new Python-based API framework from scratch, and looks at how we can start building smarter, more productive API tooling as a result.

You should come away from this talk with a better appreciation of:

* How best to provide API client libraries and API documentation to your users.
* How to build APIs that support both realtime and request/response interfaces.
* How to build APIs that are web-browsable.
* Why you might want to consider taking a schema-first approach to your API design.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:14,139 --> 00:00:16,880
good afternoon everyone

00:00:15,950 --> 00:00:20,529
our

00:00:16,880 --> 00:00:23,630
speaker is from Christie and he is

00:00:20,529 --> 00:00:25,250
talking about LevelUp rethinking the Web

00:00:23,630 --> 00:00:31,550
API framework so please welcome Tom

00:00:25,250 --> 00:00:34,879
Christine hey

00:00:31,550 --> 00:00:37,460
hello Portland okay so yeah my name is

00:00:34,879 --> 00:00:39,800
Tom Christie I'm most well known as

00:00:37,460 --> 00:00:41,809
being the author of Django rest

00:00:39,800 --> 00:00:44,449
framework which is an API framework for

00:00:41,809 --> 00:00:46,699
Django and surprisingly I'm fortunate

00:00:44,449 --> 00:00:49,400
enough these days to be in the position

00:00:46,699 --> 00:00:51,199
that I'm actually paid to work on open

00:00:49,400 --> 00:00:54,860
source we launched a collaborative

00:00:51,199 --> 00:00:57,470
funding model about 12 months ago and I

00:00:54,860 --> 00:01:00,170
was able to quit the day job we now have

00:00:57,470 --> 00:01:03,619
about 50 or 60 different companies all

00:01:00,170 --> 00:01:07,189
signed up as sponsors and that's what I

00:01:03,619 --> 00:01:10,579
do day-to-day in Brighton in the UK so

00:01:07,189 --> 00:01:13,369
I'm here here today to talk to you about

00:01:10,579 --> 00:01:15,560
some of the newer work that I've been

00:01:13,369 --> 00:01:18,530
doing it's not coupled to Django it's a

00:01:15,560 --> 00:01:21,799
new API framework that's being spurred

00:01:18,530 --> 00:01:23,450
on by some of the thinking that I've

00:01:21,799 --> 00:01:28,729
been doing around Django rest framework

00:01:23,450 --> 00:01:32,960
and how can we take a slightly new

00:01:28,729 --> 00:01:37,100
approach to building API frameworks in

00:01:32,960 --> 00:01:39,590
Python so this is the more verbose title

00:01:37,100 --> 00:01:41,240
of the talk how it can build powerfully

00:01:39,590 --> 00:01:43,069
expressive API using function

00:01:41,240 --> 00:01:44,479
allocations for dependency injection the

00:01:43,069 --> 00:01:46,909
tote system that couldn't declare our

00:01:44,479 --> 00:01:48,649
schema constraints and demonstrate what

00:01:46,909 --> 00:01:54,560
sort of benefits we get from doing so

00:01:48,649 --> 00:01:58,490
yeah in a in a nutshell it's all about

00:01:54,560 --> 00:02:04,520
thinking about how we can build meaning

00:01:58,490 --> 00:02:07,999
into our code base and write our api's

00:02:04,520 --> 00:02:13,010
in such a way that we're making

00:02:07,999 --> 00:02:15,380
information available to tooling that we

00:02:13,010 --> 00:02:19,069
can then use to do interesting things

00:02:15,380 --> 00:02:22,610
with our API so the way that I'm going

00:02:19,069 --> 00:02:30,500
to approach this is I want to start with

00:02:22,610 --> 00:02:34,190
a a simple API service that's written in

00:02:30,500 --> 00:02:38,600
in a Django like style and I'm going to

00:02:34,190 --> 00:02:41,360
iteratively propose a set of changes

00:02:38,600 --> 00:02:43,880
that we can make to how we write this

00:02:41,360 --> 00:02:46,430
and then once we've gone through all

00:02:43,880 --> 00:02:48,770
those changes demonstrate the benefits

00:02:46,430 --> 00:02:51,410
that we get from taking the slightly

00:02:48,770 --> 00:02:53,330
different approach okay so we've got a

00:02:51,410 --> 00:02:55,970
very simple service which is all about

00:02:53,330 --> 00:03:00,290
lovely kittens and it's got two

00:02:55,970 --> 00:03:03,350
different operations exposes to the user

00:03:00,290 --> 00:03:06,080
the first operation is the ability to

00:03:03,350 --> 00:03:09,200
add a new kitten to your favorites list

00:03:06,080 --> 00:03:10,630
and the second operation is to show all

00:03:09,200 --> 00:03:13,040
the kittens in your favorites list

00:03:10,630 --> 00:03:15,520
optionally filtering them down to just

00:03:13,040 --> 00:03:19,850
including kittens of a particular color

00:03:15,520 --> 00:03:22,340
so here's what our view function looks

00:03:19,850 --> 00:03:24,320
like to start with you don't

00:03:22,340 --> 00:03:28,130
particularly need to go into the details

00:03:24,320 --> 00:03:30,860
but this is our starting point and the

00:03:28,130 --> 00:03:34,340
first change that I'm going to propose

00:03:30,860 --> 00:03:38,120
that we make very simple one is to say

00:03:34,340 --> 00:03:42,170
well let's always think about writing

00:03:38,120 --> 00:03:46,670
our views in a way that we always split

00:03:42,170 --> 00:03:48,830
out individual HTTP methods so in a

00:03:46,670 --> 00:03:53,959
regular function based view in Django

00:03:48,830 --> 00:03:56,959
you would typically have a a URL route

00:03:53,959 --> 00:03:59,150
with points at the View and any HTTP

00:03:56,959 --> 00:04:01,310
methods on that URL route would get

00:03:59,150 --> 00:04:05,450
routed to that regardless of what the

00:04:01,310 --> 00:04:07,130
method is on that HTTP request so the

00:04:05,450 --> 00:04:11,630
first change I'm going to suggest is

00:04:07,130 --> 00:04:15,880
well let's always split out the views by

00:04:11,630 --> 00:04:18,229
different HTTP requests and the big

00:04:15,880 --> 00:04:22,729
benefit that we've got from making this

00:04:18,229 --> 00:04:24,290
simple change outlook is is just looking

00:04:22,729 --> 00:04:26,690
at the routing how the routing would

00:04:24,290 --> 00:04:28,850
look differently in the first case we'll

00:04:26,690 --> 00:04:31,520
route everything just based on the URL

00:04:28,850 --> 00:04:33,680
in the second case will explicitly

00:04:31,520 --> 00:04:35,840
filter out the different HTTP methods

00:04:33,680 --> 00:04:42,520
and the big benefits that that this

00:04:35,840 --> 00:04:44,120
already gives us is that we have more

00:04:42,520 --> 00:04:46,880
information if we

00:04:44,120 --> 00:04:48,340
to try and write automat if we want to

00:04:46,880 --> 00:04:51,110
automatically try and pull out

00:04:48,340 --> 00:04:53,300
documentation for our API so in the

00:04:51,110 --> 00:04:55,720
first case we've got a single URL that

00:04:53,300 --> 00:04:57,800
actually has two underlying operations

00:04:55,720 --> 00:05:01,490
different kinds of operations that can

00:04:57,800 --> 00:05:04,130
do in the second case we're able to say

00:05:01,490 --> 00:05:05,930
okay we've got two different docstrings

00:05:04,130 --> 00:05:07,760
for these two different functions and

00:05:05,930 --> 00:05:10,340
were able to pull each of those out

00:05:07,760 --> 00:05:13,400
separately and document the different

00:05:10,340 --> 00:05:16,630
types of operations that our API exposes

00:05:13,400 --> 00:05:20,630
so that's a simple change to start with

00:05:16,630 --> 00:05:23,660
let's go with something a bit more

00:05:20,630 --> 00:05:27,669
substantial next so the next change that

00:05:23,660 --> 00:05:30,919
I'm going to propose is rather than

00:05:27,669 --> 00:05:33,860
presenting the fundamental abstraction

00:05:30,919 --> 00:05:37,310
of the viewing space being a function

00:05:33,860 --> 00:05:42,410
that takes a request and return to

00:05:37,310 --> 00:05:45,919
response let's look at the view

00:05:42,410 --> 00:05:49,610
abstraction as being something that more

00:05:45,919 --> 00:05:53,810
fundamentally represents what is the

00:05:49,610 --> 00:05:56,270
interface that we're exposing so rather

00:05:53,810 --> 00:05:58,130
than let's have a function that takes

00:05:56,270 --> 00:06:01,639
this request here and returns a JSON

00:05:58,130 --> 00:06:04,940
response at the bottom let's put our

00:06:01,639 --> 00:06:07,460
actual input parameters of the actual

00:06:04,940 --> 00:06:11,360
query or the actual operation that the

00:06:07,460 --> 00:06:13,340
user is intending to do there in the

00:06:11,360 --> 00:06:15,590
function signature directly so we've got

00:06:13,340 --> 00:06:18,169
two different things that we've got the

00:06:15,590 --> 00:06:20,539
user the person making the request and

00:06:18,169 --> 00:06:23,150
we've got the name the name of the

00:06:20,539 --> 00:06:24,830
kitten that we want to add to our API at

00:06:23,150 --> 00:06:28,669
the bottom at the moment we're returning

00:06:24,830 --> 00:06:30,830
a JSON response well why don't we be a

00:06:28,669 --> 00:06:33,919
bit more fundamental about the interface

00:06:30,830 --> 00:06:36,800
and return the data that we're

00:06:33,919 --> 00:06:38,240
interested in and we'll we'll work at

00:06:36,800 --> 00:06:40,750
this level and we'll see why this is

00:06:38,240 --> 00:06:47,210
going to get interesting as we go along

00:06:40,750 --> 00:06:52,370
so if we're going to do that how do we

00:06:47,210 --> 00:06:56,060
have the framework know what these

00:06:52,370 --> 00:06:57,889
different input parameters are or make

00:06:56,060 --> 00:07:04,909
those available from the frame

00:06:57,889 --> 00:07:06,710
work to the view well there's actually

00:07:04,909 --> 00:07:07,789
really well-established platon for

00:07:06,710 --> 00:07:09,949
dealing with this sort of thing called

00:07:07,789 --> 00:07:13,009
dependency injection and a one really

00:07:09,949 --> 00:07:16,669
good place in Python land where this is

00:07:13,009 --> 00:07:19,639
already used is the PI test testing

00:07:16,669 --> 00:07:21,830
framework and they use dependency

00:07:19,639 --> 00:07:26,509
injection in order to write test

00:07:21,830 --> 00:07:28,789
functions in such a way that the

00:07:26,509 --> 00:07:32,210
arguments that you provide to the test

00:07:28,789 --> 00:07:38,120
function automatically get provided by

00:07:32,210 --> 00:07:39,830
the framework now in PI test the style

00:07:38,120 --> 00:07:43,969
that you use for providing those

00:07:39,830 --> 00:07:51,110
fixtures is you have a decorator and a

00:07:43,969 --> 00:07:56,300
function that returns the arguments the

00:07:51,110 --> 00:08:00,199
argument itself and the name of the

00:07:56,300 --> 00:08:05,210
argument is used to pick out which is

00:08:00,199 --> 00:08:11,180
the fixture that we want now rather than

00:08:05,210 --> 00:08:13,279
using this rather than using the names a

00:08:11,180 --> 00:08:16,699
different approach that we could take is

00:08:13,279 --> 00:08:20,469
to look at using Python threes type

00:08:16,699 --> 00:08:24,680
annotations and use the type annotations

00:08:20,469 --> 00:08:28,879
to describe what is the argument that we

00:08:24,680 --> 00:08:31,759
want to pass into this view so in our

00:08:28,879 --> 00:08:34,219
request response level that we're

00:08:31,759 --> 00:08:37,039
starting with here's how you type

00:08:34,219 --> 00:08:38,539
annotate the view you've got an HTTP

00:08:37,039 --> 00:08:44,000
request coming in and we're turning an

00:08:38,539 --> 00:08:47,000
HTTP response in as we start to look at

00:08:44,000 --> 00:08:49,339
moving away from request response and

00:08:47,000 --> 00:08:52,130
moving to this more fundamental level of

00:08:49,339 --> 00:08:55,779
the interface we can have particular

00:08:52,130 --> 00:08:59,180
type annotations that correspond to say

00:08:55,779 --> 00:09:03,140
just the user that is associated with

00:08:59,180 --> 00:09:05,810
the incoming request or a query

00:09:03,140 --> 00:09:10,730
parameter that is present in the

00:09:05,810 --> 00:09:11,810
incoming HTTP request and we can do a

00:09:10,730 --> 00:09:14,150
similar thing

00:09:11,810 --> 00:09:17,560
for the return type as well and say

00:09:14,150 --> 00:09:21,140
rather than returning an HTTP response

00:09:17,560 --> 00:09:25,790
I'd like to return some response data so

00:09:21,140 --> 00:09:31,250
an arbitrary data structure that is JSON

00:09:25,790 --> 00:09:35,260
serializable say now if we're going to

00:09:31,250 --> 00:09:40,940
do this we need to have a way of

00:09:35,260 --> 00:09:45,800
describing to the framework how should

00:09:40,940 --> 00:09:48,920
the individual components be created in

00:09:45,800 --> 00:09:52,000
order to pass them to the view it is an

00:09:48,920 --> 00:09:56,089
example of how we can do that is

00:09:52,000 --> 00:09:59,680
registering builder functions that other

00:09:56,089 --> 00:10:02,450
things that say if you've got a

00:09:59,680 --> 00:10:08,600
parameter of this type here's how it

00:10:02,450 --> 00:10:11,510
gets created okay so don't worry too

00:10:08,600 --> 00:10:13,400
much if it doesn't all fit together as

00:10:11,510 --> 00:10:15,440
things progress hopefully you'll just

00:10:13,400 --> 00:10:22,310
kind of get a good idea of what the big

00:10:15,440 --> 00:10:27,140
picture is so we can then once we have

00:10:22,310 --> 00:10:28,790
these components that are able to that

00:10:27,140 --> 00:10:31,400
the framework is able to know how to

00:10:28,790 --> 00:10:33,530
build each individual component we can

00:10:31,400 --> 00:10:40,580
just drop them each individual one that

00:10:33,530 --> 00:10:45,620
we need onto the view what's what starts

00:10:40,580 --> 00:10:48,589
to get interesting here then is we have

00:10:45,620 --> 00:10:50,390
this both dynamic style where we're

00:10:48,589 --> 00:10:52,040
actually able to work at lots of

00:10:50,390 --> 00:10:54,730
different levels of abstraction

00:10:52,040 --> 00:10:56,810
depending on what we actually need and

00:10:54,730 --> 00:11:00,500
request/response no longer becomes

00:10:56,810 --> 00:11:01,820
actually the primary abstraction but in

00:11:00,500 --> 00:11:05,060
fact you could work at lots of different

00:11:01,820 --> 00:11:07,550
levels of distraction if you need you

00:11:05,060 --> 00:11:10,360
could write a view which drops all the

00:11:07,550 --> 00:11:13,100
way down to the raw whiskey layer

00:11:10,360 --> 00:11:15,950
whiskey being the interface layer that

00:11:13,100 --> 00:11:17,839
exists between the server pulling the

00:11:15,950 --> 00:11:25,100
requests of the network and the

00:11:17,839 --> 00:11:25,930
application code and the the framework

00:11:25,100 --> 00:11:30,140
is able to

00:11:25,930 --> 00:11:32,750
build up exactly what it needs to run in

00:11:30,140 --> 00:11:40,300
order to satisfy the interface of the

00:11:32,750 --> 00:11:45,080
view where are written okay right so

00:11:40,300 --> 00:11:47,150
let's now add in our components into our

00:11:45,080 --> 00:11:52,580
kitten API and see what they look like

00:11:47,150 --> 00:11:54,530
so far and we've we're starting to have

00:11:52,580 --> 00:11:56,890
an interface that more meaningfully

00:11:54,530 --> 00:12:02,090
exposes what these operations actually

00:11:56,890 --> 00:12:04,250
actually are and one of the benefits is

00:12:02,090 --> 00:12:07,250
is of this is that it makes for more

00:12:04,250 --> 00:12:09,910
testable interfaces so for example if

00:12:07,250 --> 00:12:14,470
you want to test one of the operations

00:12:09,910 --> 00:12:18,050
directly you don't have to mock up an

00:12:14,470 --> 00:12:21,080
HTTP request pass that to your view

00:12:18,050 --> 00:12:23,300
function and then get back a response

00:12:21,080 --> 00:12:25,100
and decode the data in that and see if

00:12:23,300 --> 00:12:31,070
it's right instead you can just test the

00:12:25,100 --> 00:12:33,080
interface directly so this is an example

00:12:31,070 --> 00:12:35,660
of writing a test against the response

00:12:33,080 --> 00:12:39,740
ruler against the request response

00:12:35,660 --> 00:12:42,250
interface you can see we build up a

00:12:39,740 --> 00:12:44,420
request and pass it to the function

00:12:42,250 --> 00:12:51,470
instead we can just test the interface

00:12:44,420 --> 00:12:53,800
directly okay the next thing that I want

00:12:51,470 --> 00:12:57,910
to move on from here is to talk about

00:12:53,800 --> 00:13:03,320
how we can put more semantic information

00:12:57,910 --> 00:13:07,490
onto the input and output types in order

00:13:03,320 --> 00:13:10,760
to describe the data structures that our

00:13:07,490 --> 00:13:16,280
API expects both as inputs and as

00:13:10,760 --> 00:13:19,700
outputs of the API and as a starting

00:13:16,280 --> 00:13:26,830
point I'm going to take a look at JSON

00:13:19,700 --> 00:13:26,830
schema JSON schema is a very widely used

00:13:27,580 --> 00:13:37,090
representation for expressing the data

00:13:31,640 --> 00:13:37,090
structure and the constraints of

00:13:38,140 --> 00:13:46,360
of a structure of a JSON data structure

00:13:41,050 --> 00:13:49,210
and it's one of the things that's nice

00:13:46,360 --> 00:13:54,370
about it is it's an it's a format that

00:13:49,210 --> 00:13:55,840
allows you to express those constraints

00:13:54,370 --> 00:13:57,880
in a way that you can then use it with

00:13:55,840 --> 00:14:00,100
lots of different sorts of tooling it's

00:13:57,880 --> 00:14:01,870
something you can pass over the wire so

00:14:00,100 --> 00:14:03,460
you can run the same validation on the

00:14:01,870 --> 00:14:07,030
client side as you run on the server

00:14:03,460 --> 00:14:10,300
side and it can be used for

00:14:07,030 --> 00:14:15,520
documentation of documenting what the

00:14:10,300 --> 00:14:19,120
interfaces expect it allows you to

00:14:15,520 --> 00:14:23,950
express the all the basic primitives

00:14:19,120 --> 00:14:25,810
container types which types should be

00:14:23,950 --> 00:14:28,870
present within one of the container

00:14:25,810 --> 00:14:31,690
types so an array of integers an object

00:14:28,870 --> 00:14:34,630
which has various different properties

00:14:31,690 --> 00:14:37,090
on it and more complicated things as

00:14:34,630 --> 00:14:40,240
well such as unions saying the data

00:14:37,090 --> 00:14:44,860
structure should either be this style or

00:14:40,240 --> 00:14:47,140
that style or an array of either kittens

00:14:44,860 --> 00:14:50,620
or birds which each have different

00:14:47,140 --> 00:14:53,740
properties on them say here's a quick

00:14:50,620 --> 00:14:57,160
look at some of the sorts of things that

00:14:53,740 --> 00:15:01,120
you can do with JSON schema first

00:14:57,160 --> 00:15:06,240
example something that should look like

00:15:01,120 --> 00:15:09,970
a valid email address another example a

00:15:06,240 --> 00:15:15,730
number between these two bounds at this

00:15:09,970 --> 00:15:17,770
degree of precision and also composite

00:15:15,730 --> 00:15:20,830
types building up more complex data

00:15:17,770 --> 00:15:23,190
structures and expressing what those

00:15:20,830 --> 00:15:23,190
look like

00:15:27,300 --> 00:15:36,280
more of the same so how can we do

00:15:33,280 --> 00:15:38,460
something interesting and useful with

00:15:36,280 --> 00:15:38,460
this

00:15:41,119 --> 00:15:51,149
well one nice way to do this would be to

00:15:44,729 --> 00:15:53,099
create a type system for Python a type

00:15:51,149 --> 00:15:57,809
system that we'll be able to use in our

00:15:53,099 --> 00:16:03,809
type annotations that expressly maps on

00:15:57,809 --> 00:16:06,749
to JSON schema okay so we will have

00:16:03,809 --> 00:16:09,899
primitives that corresponds with the

00:16:06,749 --> 00:16:12,509
JSON schema primitives and attribution

00:16:09,899 --> 00:16:14,429
attributes on each of those that

00:16:12,509 --> 00:16:16,079
correspond to the various constraints

00:16:14,429 --> 00:16:23,129
that you can put on each of the

00:16:16,079 --> 00:16:27,329
different data types and once we have

00:16:23,129 --> 00:16:31,199
these basic datatypes we'd be able to

00:16:27,329 --> 00:16:34,949
instantiate them they'll act as a

00:16:31,199 --> 00:16:36,119
regular Python primitive object but

00:16:34,949 --> 00:16:38,579
we'll know that once we've got an

00:16:36,119 --> 00:16:41,569
instance of this thing that it's being

00:16:38,579 --> 00:16:44,789
validated for us we know that we've got

00:16:41,569 --> 00:16:49,889
data that fits the validation

00:16:44,789 --> 00:16:53,639
constraints of and what else have we got

00:16:49,889 --> 00:16:57,239
yeah there you go so the types will

00:16:53,639 --> 00:16:59,789
enforce our validation and we can build

00:16:57,239 --> 00:17:01,979
up more complex schemas as well

00:16:59,789 --> 00:17:05,009
so schemas that represent objects with

00:17:01,979 --> 00:17:12,299
various different properties or unions

00:17:05,009 --> 00:17:14,939
or any of those sorts of things and more

00:17:12,299 --> 00:17:19,769
complex types will enforce validation on

00:17:14,939 --> 00:17:22,919
their subtypes as well so once we once

00:17:19,769 --> 00:17:27,209
we have a type system a rich type system

00:17:22,919 --> 00:17:32,340
that expresses constraints on the style

00:17:27,209 --> 00:17:36,529
of the data we can use that within our

00:17:32,340 --> 00:17:39,570
we can use those as type annotations and

00:17:36,529 --> 00:17:42,809
once we're using those as type

00:17:39,570 --> 00:17:47,220
annotations we have really semantically

00:17:42,809 --> 00:17:49,649
rich set of information about what the

00:17:47,220 --> 00:17:52,789
inputs and the outputs of these

00:17:49,649 --> 00:17:52,789
functions look like

00:17:53,299 --> 00:18:00,989
which starts to give us some really

00:17:57,230 --> 00:18:04,320
which gives us a lot of leverage on to

00:18:00,989 --> 00:18:06,450
building tooling that can can do

00:18:04,320 --> 00:18:14,779
interesting things without right guys so

00:18:06,450 --> 00:18:19,169
for example we can more easily generate

00:18:14,779 --> 00:18:21,450
API schemas based on our views so for

00:18:19,169 --> 00:18:27,389
example swagger which is a document

00:18:21,450 --> 00:18:30,029
format for representing api's we have a

00:18:27,389 --> 00:18:31,980
very clear mapping between saying how do

00:18:30,029 --> 00:18:35,730
we build up a swagger document for our

00:18:31,980 --> 00:18:41,999
API based on our type annotations or we

00:18:35,730 --> 00:18:47,369
can do nice things like builds like

00:18:41,999 --> 00:18:49,799
build HTML forms that corresponds to the

00:18:47,369 --> 00:18:53,789
inputs on our functions and that have

00:18:49,799 --> 00:18:56,279
appropriate kinds of controls on them so

00:18:53,789 --> 00:18:57,720
for example if there's an enum on there

00:18:56,279 --> 00:18:59,909
that has a set of various different

00:18:57,720 --> 00:19:03,629
options presenting a drop down for those

00:18:59,909 --> 00:19:05,220
or if there's an email on one of the as

00:19:03,629 --> 00:19:11,129
one of the forum branches having an

00:19:05,220 --> 00:19:15,029
email form control so here's our API as

00:19:11,129 --> 00:19:17,279
it is at the moment now let's put on our

00:19:15,029 --> 00:19:19,340
take away the query parameter and the

00:19:17,279 --> 00:19:25,909
request date of the response data and

00:19:19,340 --> 00:19:32,570
instead ads are more richly expressed

00:19:25,909 --> 00:19:35,249
types onto there now at this point the

00:19:32,570 --> 00:19:37,350
framework is going to be responsible for

00:19:35,249 --> 00:19:39,269
figuring out which of these different

00:19:37,350 --> 00:19:42,450
components map onto which different

00:19:39,269 --> 00:19:43,830
aspects of the incoming requests so for

00:19:42,450 --> 00:19:45,989
example the framework needs to be

00:19:43,830 --> 00:19:47,700
responsible for figuring out that the

00:19:45,989 --> 00:19:55,080
kitten color should be a query parameter

00:19:47,700 --> 00:19:57,509
on there and hmm what can we what can we

00:19:55,080 --> 00:19:58,970
do with this why is why is any of this

00:19:57,509 --> 00:20:01,559
worthwhile doing

00:19:58,970 --> 00:20:05,679
answer right so

00:20:01,559 --> 00:20:08,020
if we build our api's in this sort of

00:20:05,679 --> 00:20:10,929
way one of the first things that we can

00:20:08,020 --> 00:20:14,730
do that's really beneficial is once we

00:20:10,929 --> 00:20:17,860
have declared our views and our schemas

00:20:14,730 --> 00:20:20,649
even before we've implemented anything

00:20:17,860 --> 00:20:25,570
else at all we would be able to run a

00:20:20,649 --> 00:20:29,020
mock API based on that information so we

00:20:25,570 --> 00:20:31,390
could start running this mock API and

00:20:29,020 --> 00:20:33,190
say to our front-end team hey we know

00:20:31,390 --> 00:20:34,240
what the style of this thing is going to

00:20:33,190 --> 00:20:36,909
look like we know what the data

00:20:34,240 --> 00:20:41,230
structures all look like you folks can

00:20:36,909 --> 00:20:42,820
get working against against this we're

00:20:41,230 --> 00:20:45,100
going to be filling in the blanks of the

00:20:42,820 --> 00:20:47,169
implementation details as we go and from

00:20:45,100 --> 00:20:53,620
day one your front-end team has

00:20:47,169 --> 00:20:57,580
something to start working against also

00:20:53,620 --> 00:21:00,240
promotes thinking about how you approach

00:20:57,580 --> 00:21:03,190
the design in a very API first way

00:21:00,240 --> 00:21:05,799
you're not thinking straight away okay

00:21:03,190 --> 00:21:08,020
what do the database representations

00:21:05,799 --> 00:21:10,809
look like which database are we going to

00:21:08,020 --> 00:21:12,730
use you know any of the implementation

00:21:10,809 --> 00:21:17,070
details at all you start thinking about

00:21:12,730 --> 00:21:20,529
the interface first up front and center

00:21:17,070 --> 00:21:23,350
another another thing that you can start

00:21:20,529 --> 00:21:26,110
to do with this is one of the things

00:21:23,350 --> 00:21:28,360
that well really the big driver for

00:21:26,110 --> 00:21:31,380
Django rest framework was the web

00:21:28,360 --> 00:21:34,390
browser ball API they introduced and

00:21:31,380 --> 00:21:36,940
weave in the way that we've built these

00:21:34,390 --> 00:21:41,130
views we now have really rich semantical

00:21:36,940 --> 00:21:41,130
information for being able to build up

00:21:41,370 --> 00:21:47,049
interactive modal's for interacting with

00:21:44,860 --> 00:21:48,279
your API directly in the browser and be

00:21:47,049 --> 00:21:53,850
able to bring up the right set of

00:21:48,279 --> 00:21:57,700
controls for each endpoint we can also

00:21:53,850 --> 00:22:01,799
use all of this information in order to

00:21:57,700 --> 00:22:04,330
build interactive API documentation

00:22:01,799 --> 00:22:06,220
we've got all this information both in

00:22:04,330 --> 00:22:08,710
the docstrings and in the type

00:22:06,220 --> 00:22:11,320
annotations to give us everything that

00:22:08,710 --> 00:22:14,620
we need to be able to automatically

00:22:11,320 --> 00:22:15,520
generate documentation for the API as a

00:22:14,620 --> 00:22:23,490
whole

00:22:15,520 --> 00:22:27,100
and no cast-iron guarantee know that our

00:22:23,490 --> 00:22:31,470
documentation is always in sync with our

00:22:27,100 --> 00:22:31,470
code base okay

00:22:35,110 --> 00:22:41,890
another really interesting thing that we

00:22:37,330 --> 00:22:48,010
can do is provide dynamic client

00:22:41,890 --> 00:22:52,030
libraries so a client library that uses

00:22:48,010 --> 00:22:55,740
the schemas that we can generate from

00:22:52,030 --> 00:22:59,380
this information in order to drive

00:22:55,740 --> 00:23:04,950
presenting to the user here's the

00:22:59,380 --> 00:23:07,540
interface that's available to you and in

00:23:04,950 --> 00:23:09,250
as a result of the work on Django rest

00:23:07,540 --> 00:23:12,190
framework we've already got client

00:23:09,250 --> 00:23:15,010
libraries for JavaScript and Python and

00:23:12,190 --> 00:23:17,680
datum online client that are written in

00:23:15,010 --> 00:23:20,020
this way of you point the command like

00:23:17,680 --> 00:23:23,560
blue you point the client library at the

00:23:20,020 --> 00:23:26,500
schema and it's then able to express

00:23:23,560 --> 00:23:29,650
that interface to the user in either

00:23:26,500 --> 00:23:32,500
JavaScript or Python so here's a quick

00:23:29,650 --> 00:23:35,530
look at how that would look this is

00:23:32,500 --> 00:23:37,540
using the command line clients you can

00:23:35,530 --> 00:23:41,080
see what we do to start with is we point

00:23:37,540 --> 00:23:43,420
it at the schema for the API and once

00:23:41,080 --> 00:23:48,300
and then we add some authentication

00:23:43,420 --> 00:23:50,950
information and once we've done that the

00:23:48,300 --> 00:23:58,330
interactions that are available from our

00:23:50,950 --> 00:24:01,330
API are available on that client another

00:23:58,330 --> 00:24:05,860
nice property is as well as being able

00:24:01,330 --> 00:24:07,450
to route HTTP commands onto our views we

00:24:05,860 --> 00:24:12,100
can route different kinds of interfaces

00:24:07,450 --> 00:24:15,100
onto them as well as HTTP most obvious

00:24:12,100 --> 00:24:19,090
one of those would be routing command

00:24:15,100 --> 00:24:24,190
line commands directly onto the same

00:24:19,090 --> 00:24:26,299
function that we're using to return HTTP

00:24:24,190 --> 00:24:31,039
responses

00:24:26,299 --> 00:24:39,049
so this little example shows with how we

00:24:31,039 --> 00:24:44,690
were roots both HTTP and cly commands

00:24:39,049 --> 00:24:51,289
onto the same view and what that would

00:24:44,690 --> 00:24:53,479
look like on the console you cannot you

00:24:51,289 --> 00:24:56,330
also start to have the possibility of

00:24:53,479 --> 00:25:00,679
doing even more interesting things such

00:24:56,330 --> 00:25:03,619
as routing a WebSocket route on to the

00:25:00,679 --> 00:25:06,440
exact same view that you're using for

00:25:03,619 --> 00:25:09,619
your HTTP because you're not at the

00:25:06,440 --> 00:25:13,719
request response level instead you're at

00:25:09,619 --> 00:25:21,529
here's our inputs and here's our outputs

00:25:13,719 --> 00:25:23,629
we can as things progress point these

00:25:21,529 --> 00:25:27,320
different types of protocol at the same

00:25:23,629 --> 00:25:31,669
view and the framework would then be

00:25:27,320 --> 00:25:35,089
responsible for handling the

00:25:31,669 --> 00:25:37,489
nitty-gritty details of okay for an HTTP

00:25:35,089 --> 00:25:39,320
request fine run the view return the

00:25:37,489 --> 00:25:43,879
data no problem for an incoming

00:25:39,320 --> 00:25:46,609
WebSocket request run the view return

00:25:43,879 --> 00:25:49,249
that data to the client and every time

00:25:46,609 --> 00:25:51,529
that the data has changed rerun the view

00:25:49,249 --> 00:25:53,209
get the diff between the last set of

00:25:51,529 --> 00:25:55,719
stuff that we returned to the client and

00:25:53,209 --> 00:26:01,369
the new set of data returned that diff

00:25:55,719 --> 00:26:05,169
to the client okay so that would be

00:26:01,369 --> 00:26:14,119
quite an exciting thing to be able to do

00:26:05,169 --> 00:26:16,489
so type annotations for dependency

00:26:14,119 --> 00:26:18,919
injection onto our view interfaces and a

00:26:16,489 --> 00:26:21,469
type system that gives us a rich way of

00:26:18,919 --> 00:26:23,479
expressing the validation constraints on

00:26:21,469 --> 00:26:28,789
the inputs and the data structure of the

00:26:23,479 --> 00:26:31,220
outputs gives us all of these good

00:26:28,789 --> 00:26:33,770
things now

00:26:31,220 --> 00:26:39,130
this is something that I've started

00:26:33,770 --> 00:26:43,460
working on I have an API framework that

00:26:39,130 --> 00:26:46,789
about two months old at the moment API

00:26:43,460 --> 00:26:49,340
star I've been working hard on this and

00:26:46,789 --> 00:26:52,250
I'm going to show you where we are at

00:26:49,340 --> 00:26:56,809
the moment with this just to give you a

00:26:52,250 --> 00:27:01,760
bit of a feel so this is my I don't want

00:26:56,809 --> 00:27:04,059
to do live coding anymore cuz I'm too

00:27:01,760 --> 00:27:04,059
chill

00:27:05,470 --> 00:27:11,780
so we've installed API star there's a

00:27:10,070 --> 00:27:18,590
little command that will give you a new

00:27:11,780 --> 00:27:21,140
project and let's run that so this is

00:27:18,590 --> 00:27:24,890
the API documentation that will give you

00:27:21,140 --> 00:27:27,530
out of the box and you can see that we

00:27:24,890 --> 00:27:35,929
have controls for interacting with the

00:27:27,530 --> 00:27:39,530
API we also have controls for choosing

00:27:35,929 --> 00:27:42,010
different authentication methods so at

00:27:39,530 --> 00:27:46,220
the moment it's got support in the

00:27:42,010 --> 00:27:51,289
documentation client for basic

00:27:46,220 --> 00:27:54,080
authentication or for or sit call we'll

00:27:51,289 --> 00:27:56,000
just say token authentication and also

00:27:54,080 --> 00:27:58,580
along the side what you can see there is

00:27:56,000 --> 00:28:01,280
the different client libraries are also

00:27:58,580 --> 00:28:03,380
documented using snippets to document

00:28:01,280 --> 00:28:05,179
them and we've got the Python the

00:28:03,380 --> 00:28:07,970
JavaScript and the command-line client

00:28:05,179 --> 00:28:11,559
at the moment so that's that that's

00:28:07,970 --> 00:28:13,700
where we are at the moment the

00:28:11,559 --> 00:28:15,830
functionality of being able to run mock

00:28:13,700 --> 00:28:19,010
api's there's not much work that's

00:28:15,830 --> 00:28:21,289
needed there that's probably the next

00:28:19,010 --> 00:28:24,049
big bit of functionality that I'll be

00:28:21,289 --> 00:28:25,850
putting in place we haven't yet got web

00:28:24,049 --> 00:28:29,510
browser below API so although we have

00:28:25,850 --> 00:28:34,340
the API documentation itself we don't

00:28:29,510 --> 00:28:37,640
yet have the go directly to the endpoint

00:28:34,340 --> 00:28:39,830
the API endpoint that you specifically

00:28:37,640 --> 00:28:41,450
want to interact with and have a web

00:28:39,830 --> 00:28:43,640
browser ball way of interacting with

00:28:41,450 --> 00:28:45,149
that directly and I don't have any of

00:28:43,640 --> 00:28:50,059
this funky real times

00:28:45,149 --> 00:28:50,059
I've been talking about just yet and

00:28:52,639 --> 00:29:05,249
perco so the way that the framework

00:29:00,440 --> 00:29:08,909
operates when you register one of the

00:29:05,249 --> 00:29:12,059
views as having a URL route that points

00:29:08,909 --> 00:29:17,369
towards it or a management command that

00:29:12,059 --> 00:29:19,559
points at it is the framework is able at

00:29:17,369 --> 00:29:21,299
the point that it's initialized to build

00:29:19,559 --> 00:29:23,940
up the chain of all the different

00:29:21,299 --> 00:29:26,909
functions that it needs to run in order

00:29:23,940 --> 00:29:29,549
to satisfy the interface of that view

00:29:26,909 --> 00:29:32,659
function and one of the interesting

00:29:29,549 --> 00:29:36,210
things about that is that means that if

00:29:32,659 --> 00:29:39,599
you want the framework to get out of

00:29:36,210 --> 00:29:43,019
your way then it can you can drop all

00:29:39,599 --> 00:29:47,969
the way down to the simplest possible

00:29:43,019 --> 00:29:50,789
level of don't give me any higher level

00:29:47,969 --> 00:29:55,339
abstractions and just return a whiskey

00:29:50,789 --> 00:29:57,599
response directly now this is kind of

00:29:55,339 --> 00:30:00,809
the kind of silly because this isn't

00:29:57,599 --> 00:30:04,469
actually a very typical use case but

00:30:00,809 --> 00:30:08,249
nonetheless it's a nice point of

00:30:04,469 --> 00:30:10,889
reference that you're using a framework

00:30:08,249 --> 00:30:13,700
that you know that if it needs to get

00:30:10,889 --> 00:30:16,769
out of your way it will so tech empower

00:30:13,700 --> 00:30:18,989
are a company who run benchmarking for

00:30:16,769 --> 00:30:23,489
lots of different application frameworks

00:30:18,989 --> 00:30:25,529
and we recently added they have about

00:30:23,489 --> 00:30:27,719
six different test types that they use

00:30:25,529 --> 00:30:30,570
that get progressively more realistic

00:30:27,719 --> 00:30:34,339
and they're little Jason hello world one

00:30:30,570 --> 00:30:36,690
is one of the least realistic but is

00:30:34,339 --> 00:30:41,309
also one of the simplest ones we've

00:30:36,690 --> 00:30:45,200
added support for that so far and out of

00:30:41,309 --> 00:30:48,019
all of the JavaScript go Ruby and Python

00:30:45,200 --> 00:30:51,529
frameworks that are out there

00:30:48,019 --> 00:30:55,529
API star is faster than anything else

00:30:51,529 --> 00:30:56,759
like I say it there's big providers onto

00:30:55,529 --> 00:30:58,860
that and as soon as you start doing

00:30:56,759 --> 00:31:00,990
other types of things in

00:30:58,860 --> 00:31:03,480
things were blocking operations you'd

00:31:00,990 --> 00:31:09,690
see different results but I think it's a

00:31:03,480 --> 00:31:15,980
nice starting point nonetheless I'm

00:31:09,690 --> 00:31:15,980
going to go and talk a little bit about

00:31:17,780 --> 00:31:22,950
some of the other types of components

00:31:20,370 --> 00:31:26,700
that you would put onto these view

00:31:22,950 --> 00:31:32,120
functions consider some of this just as

00:31:26,700 --> 00:31:32,120
as sketching out stuff at the moment so

00:31:32,600 --> 00:31:40,170
the style in which you are expected to

00:31:37,410 --> 00:31:47,210
write your view functions in API start

00:31:40,170 --> 00:31:47,210
is all about geared towards explicit

00:31:47,780 --> 00:31:53,550
explicit dependencies onto the view so

00:31:50,370 --> 00:31:56,820
for example if you want to be able to

00:31:53,550 --> 00:31:58,890
use the database in a view rather than

00:31:56,820 --> 00:32:02,460
having this style that say Django has

00:31:58,890 --> 00:32:05,550
where you just access one of the models

00:32:02,460 --> 00:32:08,180
and magically a database transaction has

00:32:05,550 --> 00:32:12,420
somehow being wrapped around all of that

00:32:08,180 --> 00:32:15,990
instead you should always be passing the

00:32:12,420 --> 00:32:18,000
database session to the view explicitly

00:32:15,990 --> 00:32:21,450
and the framework will take care of this

00:32:18,000 --> 00:32:23,760
for you but what it does mean is that

00:32:21,450 --> 00:32:27,030
because you're declaring I'm going to

00:32:23,760 --> 00:32:29,100
use the database here in those cases the

00:32:27,030 --> 00:32:30,810
framework can make sure that that view

00:32:29,100 --> 00:32:34,230
is wrapped up in a database transaction

00:32:30,810 --> 00:32:36,810
and in cases where you have a view that

00:32:34,230 --> 00:32:40,790
doesn't hit the database at all it won't

00:32:36,810 --> 00:32:40,790
bother doing that it doesn't need to

00:32:41,480 --> 00:32:48,810
other sorts of things that you would

00:32:43,980 --> 00:32:53,010
want to inject explicitly rather than

00:32:48,810 --> 00:32:56,100
just importing requests and calling the

00:32:53,010 --> 00:32:57,990
requests library directly I think that

00:32:56,100 --> 00:33:02,130
it makes more sense to have this style

00:32:57,990 --> 00:33:05,970
where you put explicitly on the view hey

00:33:02,130 --> 00:33:07,710
I'm going to use requests and then the

00:33:05,970 --> 00:33:11,010
nice property that that gives you is

00:33:07,710 --> 00:33:12,780
when you are when you're testing your

00:33:11,010 --> 00:33:15,270
API you

00:33:12,780 --> 00:33:18,600
make sure to say okay we're not actually

00:33:15,270 --> 00:33:20,610
going to pass the real requests library

00:33:18,600 --> 00:33:22,290
to this view we're going to make sure

00:33:20,610 --> 00:33:25,290
that you actually mock out what

00:33:22,290 --> 00:33:28,760
responses you're expecting so that your

00:33:25,290 --> 00:33:32,610
tests aren't actually hitting network

00:33:28,760 --> 00:33:34,890
also more just as interesting to think

00:33:32,610 --> 00:33:39,720
about rather than this is what we're

00:33:34,890 --> 00:33:43,290
doing right now things like date and

00:33:39,720 --> 00:33:45,780
time okay typically what you do in a

00:33:43,290 --> 00:33:48,780
Python function is just call date time

00:33:45,780 --> 00:33:51,750
directly but that's a pain when you're

00:33:48,780 --> 00:33:53,850
writing tests because you don't know

00:33:51,750 --> 00:33:57,270
what date or time you're going to get

00:33:53,850 --> 00:34:00,090
back now putting those as explicitly

00:33:57,270 --> 00:34:02,730
declared components on the view is nice

00:34:00,090 --> 00:34:07,170
because then when you're in test mode

00:34:02,730 --> 00:34:11,100
you can pass those in directly and this

00:34:07,170 --> 00:34:15,600
is just a little bit of flavor for how

00:34:11,100 --> 00:34:18,830
why you might want to do that so the

00:34:15,600 --> 00:34:23,790
framework would take care of by default

00:34:18,830 --> 00:34:33,950
providing date time to your now case and

00:34:23,790 --> 00:34:41,510
similarly for randomization stuff anyway

00:34:33,950 --> 00:34:44,970
let's go okay so ASCII ASCII is a

00:34:41,510 --> 00:34:48,290
something that has come along in the

00:34:44,970 --> 00:34:52,649
Django world specifically in order to

00:34:48,290 --> 00:34:58,380
support a deployment mode where Django

00:34:52,649 --> 00:35:02,160
can be used with things like WebSockets

00:34:58,380 --> 00:35:04,470
and not just be you know the deployment

00:35:02,160 --> 00:35:06,210
mode previously has always been whiskey

00:35:04,470 --> 00:35:08,400
and there's always being geared towards

00:35:06,210 --> 00:35:10,170
it's a framework that takes requests and

00:35:08,400 --> 00:35:14,870
returns responses well what do you do

00:35:10,170 --> 00:35:18,060
with other types of network events now

00:35:14,870 --> 00:35:21,330
just a bit of flavor about how we would

00:35:18,060 --> 00:35:25,350
add support for ascii alongside the

00:35:21,330 --> 00:35:26,550
existing whiskey support our component

00:35:25,350 --> 00:35:28,580
builder

00:35:26,550 --> 00:35:31,230
functions we'd be able to register

00:35:28,580 --> 00:35:39,270
multiple types of component builders

00:35:31,230 --> 00:35:42,960
that each have different different

00:35:39,270 --> 00:35:45,780
dependencies themselves and the

00:35:42,960 --> 00:35:49,920
framework will be able to take care of

00:35:45,780 --> 00:35:51,450
figuring out when I'm in this mode these

00:35:49,920 --> 00:35:54,960
other sets of things that are available

00:35:51,450 --> 00:35:57,420
I wasn't able to route the query from

00:35:54,960 --> 00:35:59,520
whiskey on to this view oh but wait a

00:35:57,420 --> 00:36:02,460
minute I was able to route the query

00:35:59,520 --> 00:36:06,090
from ASCII on to this view I know that's

00:36:02,460 --> 00:36:11,040
probably a bit fuzzy at the moment but

00:36:06,090 --> 00:36:13,080
just as flavor something that I brushed

00:36:11,040 --> 00:36:15,060
over a bit that are going to a little

00:36:13,080 --> 00:36:17,760
bit more detail about is how you could

00:36:15,060 --> 00:36:19,980
support both real-time interfaces and

00:36:17,760 --> 00:36:21,960
standard HTTP calls from the same view

00:36:19,980 --> 00:36:28,880
well one of the things that I brushed

00:36:21,960 --> 00:36:33,780
over was how do you inform the event of

00:36:28,880 --> 00:36:38,720
a WebSocket your view on to this data

00:36:33,780 --> 00:36:42,500
has been as changed so you would have

00:36:38,720 --> 00:36:48,210
components that give you that event

00:36:42,500 --> 00:36:50,100
interface and in the you have the kind

00:36:48,210 --> 00:36:52,950
of two sides of the coin the listener

00:36:50,100 --> 00:36:55,710
and the thing that pings it and if it's

00:36:52,950 --> 00:36:57,930
an HTTP request that's coming in your

00:36:55,710 --> 00:37:00,960
subscription stop subscribe would just

00:36:57,930 --> 00:37:03,330
be a no op but your subscription stop

00:37:00,960 --> 00:37:05,280
update in either case would always be

00:37:03,330 --> 00:37:07,790
let's send a whiskey message that's

00:37:05,280 --> 00:37:11,160
going to make sure that we update

00:37:07,790 --> 00:37:15,360
anything listening for real-time events

00:37:11,160 --> 00:37:19,320
on this view another thing that I'm

00:37:15,360 --> 00:37:21,530
planning to move into in the future is

00:37:19,320 --> 00:37:27,960
views that support both graph QL

00:37:21,530 --> 00:37:30,090
interfaces and HTTP interfaces so one of

00:37:27,960 --> 00:37:34,830
the considerations for if you want to be

00:37:30,090 --> 00:37:37,350
able to do this is watch

00:37:34,830 --> 00:37:39,990
good relationships between two different

00:37:37,350 --> 00:37:41,700
data types look like it in particular

00:37:39,990 --> 00:37:46,140
what what should they look like when

00:37:41,700 --> 00:37:52,800
you're just in regular restful HTTP API

00:37:46,140 --> 00:37:55,140
land in order to have a nice seamless

00:37:52,800 --> 00:37:58,170
way of also being able to map that into

00:37:55,140 --> 00:38:01,740
graph QL now in in rest framework we're

00:37:58,170 --> 00:38:06,120
very with a rich set of different ways

00:38:01,740 --> 00:38:09,420
of representing relationships and all of

00:38:06,120 --> 00:38:11,070
these are valid different ways to talk

00:38:09,420 --> 00:38:14,660
about I've got one object and it's

00:38:11,070 --> 00:38:14,660
related to this other thing over here

00:38:15,530 --> 00:38:27,510
hmm the the bit of the sensible thing to

00:38:24,930 --> 00:38:29,430
do if you want to be able to express

00:38:27,510 --> 00:38:31,710
these relationships in a way that either

00:38:29,430 --> 00:38:35,370
works well for graph QL or for standard

00:38:31,710 --> 00:38:38,070
rest queries is to always however simple

00:38:35,370 --> 00:38:40,830
your your relationship is even if it's

00:38:38,070 --> 00:38:43,050
just a primary key always nest that

00:38:40,830 --> 00:38:45,690
inside an object inside the top-level

00:38:43,050 --> 00:38:48,150
object in that way you can always extend

00:38:45,690 --> 00:38:53,010
it out to including other information as

00:38:48,150 --> 00:38:55,140
well if you need to and what this will

00:38:53,010 --> 00:38:56,940
end up meaning an API start is that

00:38:55,140 --> 00:39:00,330
we'll end up having something like a

00:38:56,940 --> 00:39:02,910
query components and when the query

00:39:00,330 --> 00:39:07,020
component is being routed to by an HTTP

00:39:02,910 --> 00:39:09,660
view will automatically provide a

00:39:07,020 --> 00:39:12,810
default layout for the representation

00:39:09,660 --> 00:39:17,400
and when it's being routed to for graph

00:39:12,810 --> 00:39:22,200
QL will provide the the full graph QL

00:39:17,400 --> 00:39:24,270
query that's hit that endpoint anyway I

00:39:22,200 --> 00:39:27,810
know this has been a little bit fuzzy in

00:39:24,270 --> 00:39:30,090
places but I've been really I'm really

00:39:27,810 --> 00:39:32,930
excited by API so it's coming along

00:39:30,090 --> 00:39:32,930
really really quickly

00:39:33,830 --> 00:39:39,300
- I think is in a really exciting

00:39:37,230 --> 00:39:44,400
position at the moment I haven't talked

00:39:39,300 --> 00:39:46,860
about a synchronicity in terms of the

00:39:44,400 --> 00:39:48,300
new async primitives that are in Python

00:39:46,860 --> 00:39:51,390
but the fact that Lybia

00:39:48,300 --> 00:39:54,510
UV has shown that python can be

00:39:51,390 --> 00:39:57,690
competitive against node and go on their

00:39:54,510 --> 00:40:00,090
terms and the fact that python is such a

00:39:57,690 --> 00:40:04,200
hugely expressive and productive

00:40:00,090 --> 00:40:07,980
language means that I think we are in

00:40:04,200 --> 00:40:09,960
the position the next set of API

00:40:07,980 --> 00:40:13,200
frameworks that come out of Python like

00:40:09,960 --> 00:40:16,680
land could be really really compelling

00:40:13,200 --> 00:40:20,190
and anyway I'm going to be sprinting on

00:40:16,680 --> 00:40:22,470
this on Monday and Tuesday I would love

00:40:20,190 --> 00:40:25,170
to talk to you any of you about anything

00:40:22,470 --> 00:40:27,060
that I've mentioned here and I guess

00:40:25,170 --> 00:40:27,350
that's about me thank you very much for

00:40:27,060 --> 00:40:37,760
listening

00:40:27,350 --> 00:40:37,760
[Applause]

00:40:45,809 --> 00:40:48,380

YouTube URL: https://www.youtube.com/watch?v=Rk6MHZdust4


