Title: David DB Baumgold   Looping Like a Pro in Python   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: David ""DB"" Baumgold

The humble loop: it's hard to write a program without it. Whether it's processing numbers in a sequence, lines in a text file, users in a database, or any other list of things, you use loops all the time. But did you know that Python has a lot of different ways to write loops? Reaching for the right looping tool can make your code cleaner, more readable, easier to test, and it can even make it run faster! By the end of this talk, you'll be looping like a pro, and your code will be better for it.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:22,690 --> 00:00:24,750
you

00:00:52,990 --> 00:00:58,370
welcome everyone please give a warm

00:00:55,460 --> 00:01:00,680
welcome to David vom gold he's a

00:00:58,370 --> 00:01:02,330
freelancer in the Boston area goes by DB

00:01:00,680 --> 00:01:11,000
and will be talking to us about looping

00:01:02,330 --> 00:01:12,170
like a pro in Python alright hi everyone

00:01:11,000 --> 00:01:13,610
before I start I want to say in the

00:01:12,170 --> 00:01:14,960
bottom right corner you can see there's

00:01:13,610 --> 00:01:16,430
a link so that you can view the slides

00:01:14,960 --> 00:01:19,310
online during the presentation or

00:01:16,430 --> 00:01:20,270
afterwards if you want to so hi I'm DB

00:01:19,310 --> 00:01:21,800
I'm going to start with a quick

00:01:20,270 --> 00:01:23,750
shameless plug as you mentioned I'm a

00:01:21,800 --> 00:01:25,430
freelancer in the Boston area and I also

00:01:23,750 --> 00:01:26,630
do corporate training so if you like

00:01:25,430 --> 00:01:28,160
what you hear today you'd like to learn

00:01:26,630 --> 00:01:31,970
more or if you'd like me to work for you

00:01:28,160 --> 00:01:34,280
get in touch so looping so let's start

00:01:31,970 --> 00:01:36,619
with the basics what exactly is a loop a

00:01:34,280 --> 00:01:38,660
loop is a method of programming that

00:01:36,619 --> 00:01:40,610
allows you to repeat the same action or

00:01:38,660 --> 00:01:43,310
idea over and over again without

00:01:40,610 --> 00:01:45,560
repeating code so again on a conceptual

00:01:43,310 --> 00:01:47,690
level let's see a program that doesn't

00:01:45,560 --> 00:01:49,369
use loops this is a program that prints

00:01:47,690 --> 00:01:51,560
out the word Python but it does so one

00:01:49,369 --> 00:01:53,300
letter at a time and you can see every

00:01:51,560 --> 00:01:55,759
line does the same thing over and over

00:01:53,300 --> 00:01:57,979
again it's much clearer and more concise

00:01:55,759 --> 00:02:00,020
to write the program like this we're

00:01:57,979 --> 00:02:03,319
doing the same thing we're still typing

00:02:00,020 --> 00:02:05,270
out py th o n but we're saying so in a

00:02:03,319 --> 00:02:07,190
way where we're looping over each letter

00:02:05,270 --> 00:02:09,380
of the word and operating on it one at a

00:02:07,190 --> 00:02:12,590
time while only expressing the display

00:02:09,380 --> 00:02:14,090
thing once so we also need to get into a

00:02:12,590 --> 00:02:15,790
little bit more vocabulary so we all

00:02:14,090 --> 00:02:19,310
know who what we're talking about in

00:02:15,790 --> 00:02:21,709
Python an iterable is anything that you

00:02:19,310 --> 00:02:23,599
can loop over so that might be a list of

00:02:21,709 --> 00:02:25,340
objects that might be a string where

00:02:23,599 --> 00:02:26,420
you're looping over the letters and the

00:02:25,340 --> 00:02:28,310
string one at a time

00:02:26,420 --> 00:02:30,800
could be a dictionary could be a set

00:02:28,310 --> 00:02:32,599
could be a database query anything where

00:02:30,800 --> 00:02:35,540
you do one operation at a time an

00:02:32,599 --> 00:02:37,880
iteration is one execution of that loop

00:02:35,540 --> 00:02:40,130
so in the string Python T is an

00:02:37,880 --> 00:02:43,670
iteration Y is another iteration and so

00:02:40,130 --> 00:02:45,470
on an index is a variable that you use

00:02:43,670 --> 00:02:47,180
keep track of which iteration you're

00:02:45,470 --> 00:02:49,910
currently on and we're going to come

00:02:47,180 --> 00:02:51,830
back to that a lot later I also should

00:02:49,910 --> 00:02:53,180
talk about truthiness and faultiness in

00:02:51,830 --> 00:02:55,819
Python if you're not familiar with this

00:02:53,180 --> 00:02:58,670
truthy is any value that is either the

00:02:55,819 --> 00:03:01,040
true boolean or coerces to true such as

00:02:58,670 --> 00:03:02,340
a positive number or really any number

00:03:01,040 --> 00:03:04,230
aside from zero

00:03:02,340 --> 00:03:07,319
string with content a list with content

00:03:04,230 --> 00:03:08,819
and so on fall see is anything that does

00:03:07,319 --> 00:03:10,980
not have content like the variable false

00:03:08,819 --> 00:03:14,220
the number zero and empty string the

00:03:10,980 --> 00:03:16,230
variable none and so on so with that all

00:03:14,220 --> 00:03:18,629
out of the way let's start talking about

00:03:16,230 --> 00:03:19,950
how we actually do loops in Python there

00:03:18,629 --> 00:03:21,870
are two different kinds of loops there

00:03:19,950 --> 00:03:23,489
are four loops and their while loops and

00:03:21,870 --> 00:03:25,470
they're both very useful but you

00:03:23,489 --> 00:03:27,209
generally want to use for when you know

00:03:25,470 --> 00:03:29,280
exactly how many times you want to loop

00:03:27,209 --> 00:03:31,110
and use while when you want to sort of

00:03:29,280 --> 00:03:33,480
keep on going until you figure out that

00:03:31,110 --> 00:03:34,739
it's time to stop we're going to start

00:03:33,480 --> 00:03:36,360
with going over while loops because

00:03:34,739 --> 00:03:37,890
they're a little bit simpler you can get

00:03:36,360 --> 00:03:39,900
much more complicated and much more

00:03:37,890 --> 00:03:42,870
fancy with for loops so we'll start

00:03:39,900 --> 00:03:45,150
simple this is how a for loop looks in

00:03:42,870 --> 00:03:46,829
Python yeah but sorry a while loop looks

00:03:45,150 --> 00:03:48,780
in Python we have the word while

00:03:46,829 --> 00:03:50,940
followed by a conditional which is just

00:03:48,780 --> 00:03:52,890
a fancy word for a test we're checking

00:03:50,940 --> 00:03:55,110
to see if it's time to continue with the

00:03:52,890 --> 00:03:56,910
loop or if it's time to stop after the

00:03:55,110 --> 00:03:58,650
conditional there's a colon and then

00:03:56,910 --> 00:04:00,900
there's the body of the loop which is

00:03:58,650 --> 00:04:02,730
indented and can be multiple lines the

00:04:00,900 --> 00:04:04,890
body of the loop is what happens while

00:04:02,730 --> 00:04:06,420
you're looping so let's take a look at a

00:04:04,890 --> 00:04:08,790
simple Python program that has a while

00:04:06,420 --> 00:04:12,329
loop in it how many of you like going on

00:04:08,790 --> 00:04:15,420
road trips especially with kids so this

00:04:12,329 --> 00:04:18,090
is a road trip program we're going to

00:04:15,420 --> 00:04:19,889
keep on going until we've arrived and as

00:04:18,090 --> 00:04:21,090
long as we haven't arrived the kids in

00:04:19,889 --> 00:04:23,970
the back seat are going to ask are we

00:04:21,090 --> 00:04:25,650
there yet are we there yet in this case

00:04:23,970 --> 00:04:27,539
I'm just using the random module to

00:04:25,650 --> 00:04:28,860
determine if there's a 10% chance that

00:04:27,539 --> 00:04:30,599
we've actually arrived but that's not

00:04:28,860 --> 00:04:32,700
important here the thing to look at is

00:04:30,599 --> 00:04:34,560
the structure of the loop here and I've

00:04:32,700 --> 00:04:37,050
circled the conditional in this case I'm

00:04:34,560 --> 00:04:39,470
using the not operator to transform the

00:04:37,050 --> 00:04:41,789
arrived variable into its inverse so

00:04:39,470 --> 00:04:44,130
normally we would check to see if the

00:04:41,789 --> 00:04:45,660
loop is done in this case we're by

00:04:44,130 --> 00:04:48,450
saying well not arrived we're saying

00:04:45,660 --> 00:04:50,820
keep on going until we have arrived and

00:04:48,450 --> 00:04:53,310
at that point the conditional will be

00:04:50,820 --> 00:04:56,400
false and it's time to proceed with the

00:04:53,310 --> 00:04:57,630
program so generally the conceptual

00:04:56,400 --> 00:04:59,310
model that you want to think about when

00:04:57,630 --> 00:05:02,130
you're dealing with while is first

00:04:59,310 --> 00:05:04,530
checks conditional if it's truth e which

00:05:02,130 --> 00:05:06,479
is again true or anything that coerces

00:05:04,530 --> 00:05:08,520
to true you want to evaluate the body

00:05:06,479 --> 00:05:09,930
and go right back to step one check

00:05:08,520 --> 00:05:13,080
again see if we want to continue

00:05:09,930 --> 00:05:15,750
otherwise skip the body and move on with

00:05:13,080 --> 00:05:17,730
the program so let's go

00:05:15,750 --> 00:05:20,370
a different example of a while loop here

00:05:17,730 --> 00:05:22,470
we have a simple task runner or a task

00:05:20,370 --> 00:05:24,180
queue worker and what this worker is

00:05:22,470 --> 00:05:26,730
going to do is it's going to get a task

00:05:24,180 --> 00:05:29,010
from the queue and then it's going to

00:05:26,730 --> 00:05:30,270
execute that task and get a new one and

00:05:29,010 --> 00:05:32,010
it's going to continue

00:05:30,270 --> 00:05:34,830
fetching tasks from the queue and

00:05:32,010 --> 00:05:36,600
executing them one at a time but if you

00:05:34,830 --> 00:05:39,600
look at this code there's actually a bug

00:05:36,600 --> 00:05:40,920
in it and that bug happens if get tasks

00:05:39,600 --> 00:05:42,450
ever returns none

00:05:40,920 --> 00:05:45,510
what if there's no task on the queue

00:05:42,450 --> 00:05:47,730
well none is a falsie value so that will

00:05:45,510 --> 00:05:48,990
cause the loop to exit which is not what

00:05:47,730 --> 00:05:51,300
we want to worker to do we want it to

00:05:48,990 --> 00:05:52,770
wait until there's a task available so

00:05:51,300 --> 00:05:55,560
I'm going to rewrite this code slightly

00:05:52,770 --> 00:05:57,840
and now it looks like this now it's

00:05:55,560 --> 00:06:00,240
going to continue getting tasks and if

00:05:57,840 --> 00:06:02,010
there's ever not the tasks available

00:06:00,240 --> 00:06:04,740
then it's going to sleep first I can

00:06:02,010 --> 00:06:07,830
then try again now you'll notice that

00:06:04,740 --> 00:06:10,410
I've done here a while true loop that

00:06:07,830 --> 00:06:12,210
means that the conditional will never be

00:06:10,410 --> 00:06:14,760
false it will always be true which

00:06:12,210 --> 00:06:16,320
results in an infinite loop infinite

00:06:14,760 --> 00:06:18,660
loops are usually bad in programming

00:06:16,320 --> 00:06:20,880
because by definition you can't really

00:06:18,660 --> 00:06:22,410
get out of them but fortunately Python

00:06:20,880 --> 00:06:23,910
gives us some language constructs to be

00:06:22,410 --> 00:06:26,340
able to customize how we deal with our

00:06:23,910 --> 00:06:28,020
looping there are two loop control

00:06:26,340 --> 00:06:31,110
statements in Python there's continued

00:06:28,020 --> 00:06:32,580
and there's break continue allows us to

00:06:31,110 --> 00:06:34,320
skip the rest of the body of the loop

00:06:32,580 --> 00:06:36,590
and go right back up to the top to

00:06:34,320 --> 00:06:39,390
continue on to the next iteration and

00:06:36,590 --> 00:06:41,280
break says you know what actually I'm

00:06:39,390 --> 00:06:42,960
done with this whole loop thing we're

00:06:41,280 --> 00:06:44,550
just going to break entirely out of this

00:06:42,960 --> 00:06:48,090
loop construct and keep on going with

00:06:44,550 --> 00:06:50,280
the program so let's take a look here is

00:06:48,090 --> 00:06:51,990
our task queue worker and this time the

00:06:50,280 --> 00:06:54,360
tasks you know that there are some tasks

00:06:51,990 --> 00:06:56,280
that it should not handle for whatever

00:06:54,360 --> 00:06:58,860
reason maybe there's special tasks that

00:06:56,280 --> 00:07:01,440
go to a special worker so in this case

00:06:58,860 --> 00:07:03,540
if the task should be skipped then we're

00:07:01,440 --> 00:07:06,090
going to print no thanks and run the

00:07:03,540 --> 00:07:07,860
continue statements and that causes the

00:07:06,090 --> 00:07:09,450
execution flow to go right back up to

00:07:07,860 --> 00:07:12,030
the top of the loop we're going to skip

00:07:09,450 --> 00:07:14,070
the execute task line and go right back

00:07:12,030 --> 00:07:16,380
up to the top and get a new task which

00:07:14,070 --> 00:07:18,479
is exactly what we want in this case by

00:07:16,380 --> 00:07:19,979
contrast what if we have a task queue

00:07:18,479 --> 00:07:22,050
worker this little superstitious and

00:07:19,979 --> 00:07:24,479
doesn't like the number 13 if you ever

00:07:22,050 --> 00:07:25,500
give it a task with ID number 13 then

00:07:24,479 --> 00:07:27,810
it's going to say I can't deal with

00:07:25,500 --> 00:07:29,099
these working conditions I quit and it's

00:07:27,810 --> 00:07:29,700
going to break entirely out of

00:07:29,099 --> 00:07:31,290
processing

00:07:29,700 --> 00:07:33,420
the tasks and just move on with the

00:07:31,290 --> 00:07:34,680
program outside of this and in this case

00:07:33,420 --> 00:07:36,720
since the program is very short it's

00:07:34,680 --> 00:07:38,940
actually going to exit so it is actually

00:07:36,720 --> 00:07:41,400
possible to write infinite loops in

00:07:38,940 --> 00:07:43,710
Python that actually still exit and are

00:07:41,400 --> 00:07:45,630
not actually infinite it depends on the

00:07:43,710 --> 00:07:47,730
structure of your program and you can

00:07:45,630 --> 00:07:51,300
use break to break out of an infinite

00:07:47,730 --> 00:07:53,370
loop so that's why loops you have a

00:07:51,300 --> 00:07:55,560
while followed by conditional and a body

00:07:53,370 --> 00:07:57,120
underneath we execute the body over and

00:07:55,560 --> 00:08:00,060
over again until the conditionals fall

00:07:57,120 --> 00:08:02,550
see we use continue to skip and go on to

00:08:00,060 --> 00:08:04,110
the next iteration and break to break

00:08:02,550 --> 00:08:05,850
out of the loop and continue on with the

00:08:04,110 --> 00:08:07,680
program that's everything you need to

00:08:05,850 --> 00:08:09,420
know about while loops now let's move on

00:08:07,680 --> 00:08:11,880
to four loops which are similar but a

00:08:09,420 --> 00:08:13,530
little more interesting a four loop

00:08:11,880 --> 00:08:16,350
looks like this we have the word for

00:08:13,530 --> 00:08:18,660
followed by a variable name followed by

00:08:16,350 --> 00:08:20,610
the word in followed by an iterable and

00:08:18,660 --> 00:08:22,500
remember an iterable is anything you can

00:08:20,610 --> 00:08:24,870
iterate over like a list a string a

00:08:22,500 --> 00:08:26,310
dictionary and so on and then we have

00:08:24,870 --> 00:08:27,720
our body which again can be multiple

00:08:26,310 --> 00:08:31,110
lines and again is indented it looks

00:08:27,720 --> 00:08:34,200
sort of similar so here's an example of

00:08:31,110 --> 00:08:36,840
a for loop we have for num in 1 2 3

00:08:34,200 --> 00:08:38,340
print num what this is going to do is

00:08:36,840 --> 00:08:40,560
it's going to print out the numbers 1 2

00:08:38,340 --> 00:08:42,540
& 3 and we have the variable which is

00:08:40,560 --> 00:08:45,720
the word num and we have the iterable

00:08:42,540 --> 00:08:48,030
which is the list 1 2 3 if we break this

00:08:45,720 --> 00:08:51,120
down it's going to first set the

00:08:48,030 --> 00:08:54,150
variable num to the value 1 and then run

00:08:51,120 --> 00:08:57,060
print num which is print 1 then set the

00:08:54,150 --> 00:08:59,850
variable num to the number 2 and run it

00:08:57,060 --> 00:09:02,190
again then set variable num to 3 and run

00:08:59,850 --> 00:09:05,130
it again to break it down even further

00:09:02,190 --> 00:09:07,470
what we've got here is the way the for

00:09:05,130 --> 00:09:08,940
the for construct works is we start by

00:09:07,470 --> 00:09:12,930
trying to get the next value from the

00:09:08,940 --> 00:09:14,790
iterable if we have a value then set the

00:09:12,930 --> 00:09:17,040
variable to that value execute the body

00:09:14,790 --> 00:09:18,870
and go back go right back up to the top

00:09:17,040 --> 00:09:21,120
and try again see if we can get the next

00:09:18,870 --> 00:09:23,550
value if we've reached the end of the

00:09:21,120 --> 00:09:25,200
list or the end of the string then the

00:09:23,550 --> 00:09:25,440
iterable is empty and we go right back

00:09:25,200 --> 00:09:28,260
down

00:09:25,440 --> 00:09:28,710
step 5 skip the body and move on with

00:09:28,260 --> 00:09:30,930
the program

00:09:28,710 --> 00:09:32,430
now those loop control statements that I

00:09:30,930 --> 00:09:34,530
mentioned earlier continue and break

00:09:32,430 --> 00:09:36,960
those work just fine with for loops as

00:09:34,530 --> 00:09:38,910
well so if we have our task key worker

00:09:36,960 --> 00:09:40,560
in this case instead of pulling tasks

00:09:38,910 --> 00:09:42,420
from the queue has a to-do list and

00:09:40,560 --> 00:09:44,970
we're operating one task

00:09:42,420 --> 00:09:46,620
time in that to-do list once again if

00:09:44,970 --> 00:09:48,810
there's some reason why this worker

00:09:46,620 --> 00:09:50,519
shouldn't operate on this task then it

00:09:48,810 --> 00:09:52,529
can use the continue statement to just

00:09:50,519 --> 00:09:54,420
continue on to the next iteration skip

00:09:52,529 --> 00:09:56,850
that task and if we have our

00:09:54,420 --> 00:09:59,490
superstitious task runner then it's

00:09:56,850 --> 00:10:01,290
going to use break to break out of the

00:09:59,490 --> 00:10:02,760
task execution then all the rest of the

00:10:01,290 --> 00:10:05,880
items on that to-do list will never get

00:10:02,760 --> 00:10:07,110
executed so there's one thing that I

00:10:05,880 --> 00:10:09,449
mentioned earlier that I haven't really

00:10:07,110 --> 00:10:11,790
mentioned yet and that is loop indexes

00:10:09,449 --> 00:10:13,740
if you remember an index is a variable

00:10:11,790 --> 00:10:14,839
that keeps track of which iteration

00:10:13,740 --> 00:10:18,389
you're currently on

00:10:14,839 --> 00:10:20,790
so some languages like C use an index

00:10:18,389 --> 00:10:22,410
variable in order to loop here's an

00:10:20,790 --> 00:10:24,570
example of what that sort of thing looks

00:10:22,410 --> 00:10:26,070
like in Python so you have a list of

00:10:24,570 --> 00:10:28,560
food so maybe you're going shopping and

00:10:26,070 --> 00:10:30,690
we'll create an index variable starting

00:10:28,560 --> 00:10:33,420
at zero and then we're going to say

00:10:30,690 --> 00:10:35,430
while I is less than three three because

00:10:33,420 --> 00:10:36,720
that's the length of the list and for

00:10:35,430 --> 00:10:38,699
every iteration of the list we're going

00:10:36,720 --> 00:10:40,350
to get the food that is at that index of

00:10:38,699 --> 00:10:43,260
the list and print it out and then

00:10:40,350 --> 00:10:46,769
increment the index variable don't do

00:10:43,260 --> 00:10:48,570
this this is a very common sort of

00:10:46,769 --> 00:10:50,820
programming style that I've seen from

00:10:48,570 --> 00:10:53,820
people coming from languages like C or

00:10:50,820 --> 00:10:56,029
PHP or JavaScript that don't really have

00:10:53,820 --> 00:10:58,709
a better looping construct than this a

00:10:56,029 --> 00:11:01,500
much better way to loop over a list like

00:10:58,709 --> 00:11:04,410
this is to just say for food in foods

00:11:01,500 --> 00:11:06,149
print food and the reason why you can do

00:11:04,410 --> 00:11:09,029
this is because Python will

00:11:06,149 --> 00:11:11,490
automatically bind that variable to each

00:11:09,029 --> 00:11:13,350
value in the list one at a time so you

00:11:11,490 --> 00:11:15,750
don't have to worry about managing an

00:11:13,350 --> 00:11:17,220
index variable yourself in fact this is

00:11:15,750 --> 00:11:19,649
actually going to be not only clearer

00:11:17,220 --> 00:11:22,110
but also faster when you execute the

00:11:19,649 --> 00:11:24,420
code so this is the way you want to do

00:11:22,110 --> 00:11:26,459
it now you might be thinking what

00:11:24,420 --> 00:11:28,380
happens if I need the list index in the

00:11:26,459 --> 00:11:30,709
body of the loop I guess I have to go

00:11:28,380 --> 00:11:32,579
back to the way that C does it nope

00:11:30,709 --> 00:11:35,160
Python gives you better ways of doing

00:11:32,579 --> 00:11:37,649
that as well so here's an example that

00:11:35,160 --> 00:11:40,949
uses that index variable and the result

00:11:37,649 --> 00:11:44,100
is you're going to get the 0 : bread 1 :

00:11:40,949 --> 00:11:45,959
milk and 2 : eggs so you're looking at

00:11:44,100 --> 00:11:47,579
this and you're thinking wait a minute

00:11:45,959 --> 00:11:49,079
there's two variables here with a comma

00:11:47,579 --> 00:11:51,600
and I don't know what this enumerate

00:11:49,079 --> 00:11:53,850
thing is and you're confusing me here so

00:11:51,600 --> 00:11:55,410
in order to explain all the things that

00:11:53,850 --> 00:11:56,310
are going on here I'm going to take

00:11:55,410 --> 00:11:58,260
another quick side

00:11:56,310 --> 00:12:01,080
our into another nifty feature of Python

00:11:58,260 --> 00:12:03,630
called tuple unpacking and tuple

00:12:01,080 --> 00:12:06,540
unpacking allows you to assign multiple

00:12:03,630 --> 00:12:08,520
variables in one statement by using a

00:12:06,540 --> 00:12:10,860
tuple on the right side of the

00:12:08,520 --> 00:12:13,920
assignment so in this case I'm saying X

00:12:10,860 --> 00:12:16,470
comma y equals the tuple of two three

00:12:13,920 --> 00:12:19,620
and when I check that I can see that X

00:12:16,470 --> 00:12:22,230
is two and Y is three now tuple

00:12:19,620 --> 00:12:24,990
assignment works just fine in the bot in

00:12:22,230 --> 00:12:28,350
the body of a loop as well so I can say

00:12:24,990 --> 00:12:31,830
for X comma Y in one comma two three

00:12:28,350 --> 00:12:33,570
comma four and Python knows that the

00:12:31,830 --> 00:12:35,100
first value of the tuple should be

00:12:33,570 --> 00:12:36,360
assigned to the first variable and the

00:12:35,100 --> 00:12:38,279
second value of the two people should be

00:12:36,360 --> 00:12:39,960
assigned to the second variable so we

00:12:38,279 --> 00:12:42,570
still get printing out one two three

00:12:39,960 --> 00:12:44,310
four in fact if we go back to that

00:12:42,570 --> 00:12:45,870
description of how four loops work this

00:12:44,310 --> 00:12:47,910
is exactly what I talked about earlier

00:12:45,870 --> 00:12:49,800
in step two we're just setting the

00:12:47,910 --> 00:12:54,900
variable or in this case variables

00:12:49,800 --> 00:12:56,850
plural to that value or values plural so

00:12:54,900 --> 00:12:59,190
the enumerate function that I mentioned

00:12:56,850 --> 00:13:01,830
earlier is a very simple function that

00:12:59,190 --> 00:13:04,770
will iterate through and add an index

00:13:01,830 --> 00:13:07,800
into each item of a list so if I have

00:13:04,770 --> 00:13:09,960
this list of foods bread milk eggs then

00:13:07,800 --> 00:13:12,839
what I call a numerate on it the result

00:13:09,960 --> 00:13:17,550
is a list of tuples and we have zero

00:13:12,839 --> 00:13:20,070
bread one milk 2 eggs and then we can

00:13:17,550 --> 00:13:22,680
run the program like this and the

00:13:20,070 --> 00:13:24,870
execution is set I to 0 and food to

00:13:22,680 --> 00:13:27,839
bread and then print out the string and

00:13:24,870 --> 00:13:30,180
do it again I to 1 food to milk print

00:13:27,839 --> 00:13:32,610
out the string I to 2 food eggs and

00:13:30,180 --> 00:13:33,930
print out the string it's actually the

00:13:32,610 --> 00:13:35,760
mark will be straightforward and the

00:13:33,930 --> 00:13:38,010
code is very concise and much more

00:13:35,760 --> 00:13:40,920
readable than having to keep track of

00:13:38,010 --> 00:13:42,810
your own index variables there are a

00:13:40,920 --> 00:13:44,850
bunch of useful built-in functions that

00:13:42,810 --> 00:13:47,640
will allow you to loop much more much

00:13:44,850 --> 00:13:49,470
more effectively and clearly in Python

00:13:47,640 --> 00:13:51,810
so innumerate is one we've already gone

00:13:49,470 --> 00:13:55,350
over there's also one called sorted

00:13:51,810 --> 00:13:58,110
which will sort a list or an iterable

00:13:55,350 --> 00:13:59,459
for you there's one called reverse that

00:13:58,110 --> 00:14:02,010
will I to go over the list backwards

00:13:59,459 --> 00:14:04,650
range gives you a list of numbers and

00:14:02,010 --> 00:14:07,830
that combines lists together so let's go

00:14:04,650 --> 00:14:10,140
through some of these sorted I have a

00:14:07,830 --> 00:14:11,010
list I call sorted on it in this case

00:14:10,140 --> 00:14:12,930
it's just going to sort it

00:14:11,010 --> 00:14:14,220
alphabetically but it will also sort

00:14:12,930 --> 00:14:16,260
based on numbers and you can even

00:14:14,220 --> 00:14:17,610
provide custom comparison functions to

00:14:16,260 --> 00:14:19,350
sort exactly the way you want

00:14:17,610 --> 00:14:21,720
check out the Python documentation for

00:14:19,350 --> 00:14:24,180
more reverse to does what it says

00:14:21,720 --> 00:14:26,100
instead of getting bread milk eggs we've

00:14:24,180 --> 00:14:29,399
got eggs milk bread pretty

00:14:26,100 --> 00:14:31,800
straightforward range is handy when you

00:14:29,399 --> 00:14:34,529
want to count up numbers so in this case

00:14:31,800 --> 00:14:38,940
I can say for num in range 5 and it will

00:14:34,529 --> 00:14:41,100
give me an iterable of 0 1 2 3 4 again

00:14:38,940 --> 00:14:42,390
you can customize this by saying where

00:14:41,100 --> 00:14:44,670
you want it to start where you want it

00:14:42,390 --> 00:14:46,680
to end you can even ask it to count by

00:14:44,670 --> 00:14:48,720
twos or by threes or whatever step you

00:14:46,680 --> 00:14:52,500
want check the Python documentation for

00:14:48,720 --> 00:14:55,230
more information so some of you might

00:14:52,500 --> 00:14:57,630
actually get into a situation like this

00:14:55,230 --> 00:15:00,329
as well if you've ever needed to loop

00:14:57,630 --> 00:15:02,339
over two lists simultaneously people

00:15:00,329 --> 00:15:05,250
often reach back for that sort of C

00:15:02,339 --> 00:15:07,260
indexing method and the reality is you

00:15:05,250 --> 00:15:09,870
don't need to do that because if you

00:15:07,260 --> 00:15:12,390
want to loop over multiple lists this is

00:15:09,870 --> 00:15:15,300
how a lot of people do it by saying I

00:15:12,390 --> 00:15:18,240
need to say Alice likes milk Bob likes

00:15:15,300 --> 00:15:20,790
eggs and Carol likes bread but you don't

00:15:18,240 --> 00:15:23,820
need to use this index variable instead

00:15:20,790 --> 00:15:25,980
you can use the zip built-in function to

00:15:23,820 --> 00:15:27,120
combine those two lists together and we

00:15:25,980 --> 00:15:28,920
get exactly the result that we're

00:15:27,120 --> 00:15:29,339
looking for Alice likes mouth what are

00:15:28,920 --> 00:15:32,160
they

00:15:29,339 --> 00:15:34,829
Alice likes milk Bob likes eggs and

00:15:32,160 --> 00:15:37,529
Carol likes bread the way that zip works

00:15:34,829 --> 00:15:39,209
is if you've given it if you give it

00:15:37,529 --> 00:15:41,399
multiple lists is going to combine them

00:15:39,209 --> 00:15:44,040
together like a zipper adding each

00:15:41,399 --> 00:15:45,420
element of the list into a tuple of all

00:15:44,040 --> 00:15:48,600
of the respective lists combined

00:15:45,420 --> 00:15:50,220
together so zip of people and foods is

00:15:48,600 --> 00:15:51,120
going to give you the combination of

00:15:50,220 --> 00:15:53,510
Alice and milk

00:15:51,120 --> 00:15:55,890
the combination of sorry Alice and bread

00:15:53,510 --> 00:15:58,140
combination of Bob and milk and the

00:15:55,890 --> 00:15:59,790
combination of carol and eggs you can

00:15:58,140 --> 00:16:01,350
even combine together more than two

00:15:59,790 --> 00:16:03,209
lists there's no limit it's just

00:16:01,350 --> 00:16:06,360
whichever lists you pop you pass into

00:16:03,209 --> 00:16:09,750
the zip function so that's before loop

00:16:06,360 --> 00:16:12,510
we have the structure is for variable in

00:16:09,750 --> 00:16:15,209
iterable followed by an indented body of

00:16:12,510 --> 00:16:17,880
as many lines as you want it's going to

00:16:15,209 --> 00:16:19,620
set the variable to the next value from

00:16:17,880 --> 00:16:21,540
the iterable and execute the body and

00:16:19,620 --> 00:16:22,440
continue doing that until the iterable

00:16:21,540 --> 00:16:25,110
is empty

00:16:22,440 --> 00:16:28,380
and you can also modify the iterable

00:16:25,110 --> 00:16:32,100
using functions such as enumerate sorted

00:16:28,380 --> 00:16:33,900
reversed range n zip so that's all the

00:16:32,100 --> 00:16:35,220
beginner stuff in this talk I'm going to

00:16:33,900 --> 00:16:38,880
get into a little bit more advanced

00:16:35,220 --> 00:16:40,860
stuff as well it's also the problem

00:16:38,880 --> 00:16:43,920
where you have to have multiple loops

00:16:40,860 --> 00:16:45,990
nested together so in this case we have

00:16:43,920 --> 00:16:48,420
a group of people and you want to have

00:16:45,990 --> 00:16:50,040
people greet each other from that list

00:16:48,420 --> 00:16:51,450
of people so this sounds like a good

00:16:50,040 --> 00:16:53,640
case for a nested list I'm going to have

00:16:51,450 --> 00:16:55,110
person one great person too but the

00:16:53,640 --> 00:16:56,730
problem with nested loops is that

00:16:55,110 --> 00:16:59,010
frequently the logic starts getting a

00:16:56,730 --> 00:17:00,920
bit more complicated so for example you

00:16:59,010 --> 00:17:03,900
can't have a person greet him or herself

00:17:00,920 --> 00:17:06,270
so I'll stick in some custom logic here

00:17:03,900 --> 00:17:09,300
to say just skip that that case just

00:17:06,270 --> 00:17:11,610
continue you might have people in the

00:17:09,300 --> 00:17:13,140
group who are antisocial and who they're

00:17:11,610 --> 00:17:14,579
willing to respond to someone else's

00:17:13,140 --> 00:17:16,140
greeting but they don't want to actively

00:17:14,579 --> 00:17:18,600
go out and greet someone else so I've

00:17:16,140 --> 00:17:21,240
got that logic in here too and then

00:17:18,600 --> 00:17:22,949
there's some people that just really

00:17:21,240 --> 00:17:24,959
can't be in the same room as each other

00:17:22,949 --> 00:17:26,699
and if they ever have any sort of social

00:17:24,959 --> 00:17:29,210
interaction a big argument breaks out

00:17:26,699 --> 00:17:31,770
and all communication in the room stops

00:17:29,210 --> 00:17:34,140
so we want to model that by using a

00:17:31,770 --> 00:17:36,330
break statement but the problem here is

00:17:34,140 --> 00:17:38,280
that this break will actually break out

00:17:36,330 --> 00:17:40,860
of the inner loop but not out of the

00:17:38,280 --> 00:17:44,190
outer loop so we have here a situation

00:17:40,860 --> 00:17:46,530
that we want to model in Python and this

00:17:44,190 --> 00:17:48,840
doesn't do it the way that we want how

00:17:46,530 --> 00:17:50,460
do we deal with that well to improve

00:17:48,840 --> 00:17:52,590
complicated nested loops you can

00:17:50,460 --> 00:17:54,630
actually use something called generators

00:17:52,590 --> 00:17:57,390
which are another handy feature built

00:17:54,630 --> 00:17:59,760
into Python now generators are its own

00:17:57,390 --> 00:18:01,230
talk all on its own and so I'm not going

00:17:59,760 --> 00:18:02,760
to get too far deep into them I just

00:18:01,230 --> 00:18:05,130
want to talk about how you can use them

00:18:02,760 --> 00:18:06,510
to refactor nested loops here's an

00:18:05,130 --> 00:18:08,610
example of using a generator to

00:18:06,510 --> 00:18:10,350
reconstruct that milk eggs bread list

00:18:08,610 --> 00:18:12,720
that we had before I'm using the yield

00:18:10,350 --> 00:18:15,390
statement to yield one value at a time

00:18:12,720 --> 00:18:18,150
and then in the loop that's below this

00:18:15,390 --> 00:18:20,670
I'm able to get each of those values one

00:18:18,150 --> 00:18:23,610
at a time from calling the grocery list

00:18:20,670 --> 00:18:26,190
function so this is just another way of

00:18:23,610 --> 00:18:29,850
designing iterables as I talked about

00:18:26,190 --> 00:18:32,280
earlier now in this case I can use a

00:18:29,850 --> 00:18:35,760
generator to separate the logic of my

00:18:32,280 --> 00:18:36,269
loop from the body logic so I've defined

00:18:35,760 --> 00:18:38,399
a new

00:18:36,269 --> 00:18:40,950
function called pairs which is going to

00:18:38,399 --> 00:18:43,229
yield pairs of people from this group

00:18:40,950 --> 00:18:45,089
and then below that I have my for loop

00:18:43,229 --> 00:18:48,589
where I'm processing person 1 and person

00:18:45,089 --> 00:18:51,599
2 and having them greet each other now I

00:18:48,589 --> 00:18:54,119
can take those same pieces of complexity

00:18:51,599 --> 00:18:57,599
and introduce them into the pair's

00:18:54,119 --> 00:18:59,909
function one at a time and the actual

00:18:57,599 --> 00:19:01,979
processing that happens stays separate

00:18:59,909 --> 00:19:04,830
it is much easier to understand where

00:19:01,979 --> 00:19:07,619
the separation is in addition you can

00:19:04,830 --> 00:19:09,539
use the return statement to break out of

00:19:07,619 --> 00:19:10,950
a generator early and that doesn't have

00:19:09,539 --> 00:19:13,499
the same limitations of the break

00:19:10,950 --> 00:19:15,599
statement when you run return that ends

00:19:13,499 --> 00:19:17,099
the generator entirely so that allows

00:19:15,599 --> 00:19:18,719
you to do the same sort of situation

00:19:17,099 --> 00:19:21,719
that I described earlier but wasn't able

00:19:18,719 --> 00:19:24,149
to do using the break the statement you

00:19:21,719 --> 00:19:26,639
can also use generators to avoid work

00:19:24,149 --> 00:19:28,619
generators are evaluated lazily only

00:19:26,639 --> 00:19:30,509
when the work is actually requested so

00:19:28,619 --> 00:19:31,859
if you have a lot of potential work to

00:19:30,509 --> 00:19:33,419
do and you only end up needing to do a

00:19:31,859 --> 00:19:36,089
little bit of it that can save you a lot

00:19:33,419 --> 00:19:37,739
of time and make your code run faster so

00:19:36,089 --> 00:19:40,169
here's an example where I'm using the

00:19:37,739 --> 00:19:43,559
range function to get the first 10

00:19:40,169 --> 00:19:46,109
million integers if I do it lazily and

00:19:43,559 --> 00:19:48,209
don't actually check those integers then

00:19:46,109 --> 00:19:49,979
it takes me less than a microsecond but

00:19:48,209 --> 00:19:52,109
if I actively evaluate all those you

00:19:49,979 --> 00:19:54,659
know all those integers it takes me 40

00:19:52,109 --> 00:19:57,539
milliseconds which is 10,000 times

00:19:54,659 --> 00:19:59,009
slower so if you think you might not be

00:19:57,539 --> 00:20:02,129
using all of your work in all of your

00:19:59,009 --> 00:20:03,989
generators then don't bother just let it

00:20:02,129 --> 00:20:06,929
happen lazily as I said those another

00:20:03,989 --> 00:20:09,629
talk about this similarly if you have a

00:20:06,929 --> 00:20:11,639
database query you can make sure that

00:20:09,629 --> 00:20:13,309
you only use the items from the database

00:20:11,639 --> 00:20:16,529
that you're actually going to process in

00:20:13,309 --> 00:20:18,869
this case the code will only load the

00:20:16,529 --> 00:20:20,279
first 10 users if you've got lazy

00:20:18,869 --> 00:20:22,619
database queries if you're using

00:20:20,279 --> 00:20:24,719
generators if you were to turn that into

00:20:22,619 --> 00:20:26,429
a Python list it would try to load every

00:20:24,719 --> 00:20:29,789
user in the database even though you're

00:20:26,429 --> 00:20:31,919
only using the first 10 you can also use

00:20:29,789 --> 00:20:33,929
generators to create infinite generators

00:20:31,919 --> 00:20:36,659
such as this road trip thing that we

00:20:33,929 --> 00:20:38,579
were talking about earlier this is

00:20:36,659 --> 00:20:40,079
actually occasionally useful and here's

00:20:38,579 --> 00:20:43,409
an example where you can use it if you

00:20:40,079 --> 00:20:45,809
have a paginate 'add HTTP api like what

00:20:43,409 --> 00:20:48,989
you might get from github then you can

00:20:45,809 --> 00:20:49,940
write a generator that will make HTTP

00:20:48,989 --> 00:20:52,519
requests for

00:20:49,940 --> 00:20:55,490
you in the background to load objects

00:20:52,519 --> 00:20:57,289
from the paginate API and your code that

00:20:55,490 --> 00:20:59,419
needs to use those objects can just

00:20:57,289 --> 00:21:00,559
treat it as an infinite generator it

00:20:59,419 --> 00:21:02,720
doesn't have to worry about all that

00:21:00,559 --> 00:21:05,720
complexity so you can just say for

00:21:02,720 --> 00:21:08,450
widget in get widgets process them so

00:21:05,720 --> 00:21:10,669
it's not only more efficient because it

00:21:08,450 --> 00:21:12,710
only loads the widgets that you need but

00:21:10,669 --> 00:21:15,799
it's simpler to understand as well which

00:21:12,710 --> 00:21:17,960
is great so generators are very useful

00:21:15,799 --> 00:21:20,330
for refactoring nested loops and for

00:21:17,960 --> 00:21:22,820
separating the iteration logic from the

00:21:20,330 --> 00:21:24,500
loop body they'll also give you

00:21:22,820 --> 00:21:26,450
performance improvements if you find

00:21:24,500 --> 00:21:28,820
yourself in a situation where you have

00:21:26,450 --> 00:21:30,350
more items in the back in the backlog

00:21:28,820 --> 00:21:32,269
than you actually need to process and

00:21:30,350 --> 00:21:34,159
the infinite generators can be

00:21:32,269 --> 00:21:35,769
occasionally useful particularly when

00:21:34,159 --> 00:21:38,090
you're dealing with patch native api's

00:21:35,769 --> 00:21:39,919
now there's one other thing that I want

00:21:38,090 --> 00:21:41,120
to go into this talk and I have very

00:21:39,919 --> 00:21:43,100
little time left so I'm going to try to

00:21:41,120 --> 00:21:44,809
cover quickly there's a module in the

00:21:43,100 --> 00:21:47,389
Python standard library called itertools

00:21:44,809 --> 00:21:50,179
which is amazing for doing advanced

00:21:47,389 --> 00:21:51,679
iteration techniques I can't go over all

00:21:50,179 --> 00:21:52,820
the things that native tools that make

00:21:51,679 --> 00:21:55,309
it really cool but I'm going to go over

00:21:52,820 --> 00:21:56,990
to remember that thing we talked about

00:21:55,309 --> 00:21:59,059
earlier with people greeting each other

00:21:56,990 --> 00:22:01,009
that is a mathematical construct called

00:21:59,059 --> 00:22:03,139
a permutation you have a group of people

00:22:01,009 --> 00:22:05,389
and you want to find every unique pair

00:22:03,139 --> 00:22:08,480
of people in that group inner tools

00:22:05,389 --> 00:22:10,879
hazards permutations and combinations

00:22:08,480 --> 00:22:13,009
support so in this case I can just say

00:22:10,879 --> 00:22:15,500
pairs equals itertools that combinations

00:22:13,009 --> 00:22:17,029
and it will do all of that logic for me

00:22:15,500 --> 00:22:18,559
although of course if I'm dealing with

00:22:17,029 --> 00:22:19,730
antisocial people or people who really

00:22:18,559 --> 00:22:21,320
can't be in the same room as each other

00:22:19,730 --> 00:22:24,379
I'll have to implement that separately

00:22:21,320 --> 00:22:25,850
but that's another matter there's also a

00:22:24,379 --> 00:22:29,029
really cool function called itertools

00:22:25,850 --> 00:22:30,710
group by which is really handy for cases

00:22:29,029 --> 00:22:32,899
where you want to display lists of

00:22:30,710 --> 00:22:35,210
people with headings of the different

00:22:32,899 --> 00:22:38,200
sorts in that list so let's say for

00:22:35,210 --> 00:22:39,980
example you have a database that has

00:22:38,200 --> 00:22:42,440
schoolchildren and you want to make a

00:22:39,980 --> 00:22:45,559
web page that lists all the kids in your

00:22:42,440 --> 00:22:47,690
school organized by grade level with a

00:22:45,559 --> 00:22:50,779
heading between each grade levels so you

00:22:47,690 --> 00:22:53,480
say you know grade one is Adam Bob Sally

00:22:50,779 --> 00:22:56,840
grade two is Frank grade three is Alice

00:22:53,480 --> 00:22:59,210
whatever so this would normally require

00:22:56,840 --> 00:23:01,070
doing that sort by grade level and then

00:22:59,210 --> 00:23:02,480
detecting where you get that change in

00:23:01,070 --> 00:23:03,660
between grades and stopping your

00:23:02,480 --> 00:23:06,210
iteration and sticking

00:23:03,660 --> 00:23:08,220
in a header to denote the difference

00:23:06,210 --> 00:23:10,830
there but with inner tools that group by

00:23:08,220 --> 00:23:12,990
you can do it much more succinctly so

00:23:10,830 --> 00:23:15,990
here's my database query to get all

00:23:12,990 --> 00:23:17,940
students ordered by grade level and now

00:23:15,990 --> 00:23:22,200
I'm going to use inner tools that group

00:23:17,940 --> 00:23:25,680
by to group this list by the grade level

00:23:22,200 --> 00:23:26,910
of each student so the output of just

00:23:25,680 --> 00:23:28,950
the database query would be a list of

00:23:26,910 --> 00:23:32,100
students but the output of itertools

00:23:28,950 --> 00:23:35,040
that group by is a list of tuples where

00:23:32,100 --> 00:23:39,000
each tuple is the grade level followed

00:23:35,040 --> 00:23:40,530
by the list of students in that grade so

00:23:39,000 --> 00:23:41,910
this means that when you get to the

00:23:40,530 --> 00:23:44,850
point in your code where you want to

00:23:41,910 --> 00:23:48,330
actually display this the logic is very

00:23:44,850 --> 00:23:50,550
simple you can just say for grade in

00:23:48,330 --> 00:23:52,500
grades or for grade comma students in

00:23:50,550 --> 00:23:54,870
students by grade and print out the

00:23:52,500 --> 00:23:56,550
heading and then do a nested loops to

00:23:54,870 --> 00:23:59,280
print out each student that's in that

00:23:56,550 --> 00:24:01,830
grade it becomes much easier to

00:23:59,280 --> 00:24:03,510
understand and faster as well because

00:24:01,830 --> 00:24:05,310
there's less logic to understand there's

00:24:03,510 --> 00:24:07,460
less logic to run and there's nothing

00:24:05,310 --> 00:24:10,710
faster than not running the code at all

00:24:07,460 --> 00:24:12,000
so I've gone over a fair amount these

00:24:10,710 --> 00:24:15,380
are all the topics that we talked about

00:24:12,000 --> 00:24:15,380
does anyone have any questions

00:24:17,690 --> 00:24:27,109
[Applause]

00:24:29,920 --> 00:24:35,090
okay hi so I'm new to Python I'm trying

00:24:33,350 --> 00:24:37,040
to be pythonic but I do come from the

00:24:35,090 --> 00:24:39,830
sea and even basic world and maybe

00:24:37,040 --> 00:24:42,770
Pascal you've ever heard of that and so

00:24:39,830 --> 00:24:44,510
it was beat into me not to do the break

00:24:42,770 --> 00:24:47,990
and like continue wasn't something I

00:24:44,510 --> 00:24:50,720
either ever learned or existed so do you

00:24:47,990 --> 00:24:53,300
say that break and continue is very

00:24:50,720 --> 00:24:54,890
pythonic is this the desired thing or is

00:24:53,300 --> 00:24:56,660
it a shortcut so we don't have to have a

00:24:54,890 --> 00:24:59,660
couple more lines of code with a flag to

00:24:56,660 --> 00:25:02,360
exit out of our loop break and continue

00:24:59,660 --> 00:25:04,400
are used to solve specific problems if

00:25:02,360 --> 00:25:06,740
you run into a case where you find

00:25:04,400 --> 00:25:08,030
yourself reaching for that tool then

00:25:06,740 --> 00:25:10,040
that may well be the tool that you need

00:25:08,030 --> 00:25:12,050
to use now if you find yourself

00:25:10,040 --> 00:25:13,940
littering your codebase with these

00:25:12,050 --> 00:25:16,400
statements then maybe you're actually

00:25:13,940 --> 00:25:17,720
making it harder to understand and maybe

00:25:16,400 --> 00:25:19,550
you should look into refactoring your

00:25:17,720 --> 00:25:20,360
code but in all the examples that I

00:25:19,550 --> 00:25:22,190
showed earlier

00:25:20,360 --> 00:25:23,810
breakin continues to end like the right

00:25:22,190 --> 00:25:25,550
tools to use and there's nothing wrong

00:25:23,810 --> 00:25:27,140
with using them they're not anti

00:25:25,550 --> 00:25:31,880
pythonic or anything like that it's just

00:25:27,140 --> 00:25:36,340
use the right tool for the job one of

00:25:31,880 --> 00:25:38,890
the question over here maybe anyone

00:25:36,340 --> 00:25:46,489
thank you dude sure

00:25:38,890 --> 00:25:46,489

YouTube URL: https://www.youtube.com/watch?v=u8g9scXeAcI


