Title: Al Sweigart   Yes, It's Time to Learn Regular Expressions   PyCon 2017
Publication date: 2017-05-21
Playlist: PyCon 2017
Description: 
	"Speaker: Al Sweigart

Regular expressions have a reputation as opaque and inscrutable. However, the basic concepts behind ""regex"" and text pattern recognition are simple to grasp. This talk is for any programmer who isn't familiar with Python's re module and its best practices. Stop putting it off, it's time to learn regular expressions!

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:04,009 --> 00:00:09,360
so good afternoon everyone

00:00:06,180 --> 00:00:10,530
we now have sy guard who will be talking

00:00:09,360 --> 00:00:14,210
on yes

00:00:10,530 --> 00:00:14,210
it's time to learn regular expressions

00:00:18,710 --> 00:00:24,869
hello hi I'm al Swaggart I'm probably

00:00:22,560 --> 00:00:26,939
best known for writing Python books

00:00:24,869 --> 00:00:28,890
including one called automate the boring

00:00:26,939 --> 00:00:30,330
stuff with Python which is released

00:00:28,890 --> 00:00:33,510
under a Creative Commons license so you

00:00:30,330 --> 00:00:35,370
can read this online for free you can

00:00:33,510 --> 00:00:37,860
check out the book and also my slides

00:00:35,370 --> 00:00:40,280
from bitly flash yes regex if you want

00:00:37,860 --> 00:00:42,600
to follow along with the slide deck I

00:00:40,280 --> 00:00:44,370
really encourage you to release your own

00:00:42,600 --> 00:00:46,020
content under an open license like

00:00:44,370 --> 00:00:47,910
Creative Commons one of the benefits

00:00:46,020 --> 00:00:50,190
that I have is that I can take a look at

00:00:47,910 --> 00:00:52,260
my web traffic and I notice that the

00:00:50,190 --> 00:00:54,629
regular expression chapter in this book

00:00:52,260 --> 00:00:57,510
has a lot of traffic so I thought hey

00:00:54,629 --> 00:01:00,570
this would be a good idea for a talk so

00:00:57,510 --> 00:01:03,719
regular expressions are kind of this

00:01:00,570 --> 00:01:06,210
intimidating topic a lot of software

00:01:03,719 --> 00:01:08,100
developers pretty much put off learning

00:01:06,210 --> 00:01:10,170
it for most of their careers

00:01:08,100 --> 00:01:11,970
it seems really cryptic there's a bunch

00:01:10,170 --> 00:01:13,590
of weird punctuation marks that have

00:01:11,970 --> 00:01:16,799
special meaning it can be kind of hard

00:01:13,590 --> 00:01:19,170
to learn in fact just 20 minutes before

00:01:16,799 --> 00:01:24,960
this talk I overheard somebody in the

00:01:19,170 --> 00:01:26,970
hallway say this quote and so I had to

00:01:24,960 --> 00:01:29,430
update my slides with that but in

00:01:26,970 --> 00:01:31,590
general their regular expressions are

00:01:29,430 --> 00:01:33,990
really powerful if you have to do text

00:01:31,590 --> 00:01:37,259
pattern matching and I really encourage

00:01:33,990 --> 00:01:40,140
you to learn them and so yes it's time

00:01:37,259 --> 00:01:42,240
for me to start this presentation which

00:01:40,140 --> 00:01:44,700
is entitled yes it's time to learn

00:01:42,240 --> 00:01:45,659
regular expressions so the first thing

00:01:44,700 --> 00:01:49,950
that you'll learn is that they're also

00:01:45,659 --> 00:01:53,220
called read checks for short so here's

00:01:49,950 --> 00:01:55,320
two numbers actually it's one number and

00:01:53,220 --> 00:01:58,079
one of these numbers is a phone number

00:01:55,320 --> 00:02:01,950
and the other is a is the population of

00:01:58,079 --> 00:02:04,200
Asia so which one is which well if

00:02:01,950 --> 00:02:06,119
you're like me you've memorized every

00:02:04,200 --> 00:02:08,129
single American phone number that exists

00:02:06,119 --> 00:02:10,800
and you can tell that that top number is

00:02:08,129 --> 00:02:12,720
one of them no that's not how you

00:02:10,800 --> 00:02:13,650
actually do that at all you know it's a

00:02:12,720 --> 00:02:15,209
phone number because

00:02:13,650 --> 00:02:17,010
you know a phone number when you see it

00:02:15,209 --> 00:02:19,110
and you know when you see it because you

00:02:17,010 --> 00:02:20,670
know there's a specific pattern that the

00:02:19,110 --> 00:02:22,769
phone them that all American phone

00:02:20,670 --> 00:02:25,110
numbers follow it's a few digits for the

00:02:22,769 --> 00:02:27,239
area code with dashes in the middle of

00:02:25,110 --> 00:02:29,909
it so that's what regular expressions do

00:02:27,239 --> 00:02:31,590
you can specify a pattern of text that

00:02:29,909 --> 00:02:34,200
you're looking for even if you don't

00:02:31,590 --> 00:02:37,560
know the exact numbers or the exact text

00:02:34,200 --> 00:02:39,480
that you're looking for and it's really

00:02:37,560 --> 00:02:41,489
easy Python makes this really simple

00:02:39,480 --> 00:02:43,049
it's just about three lines of code the

00:02:41,489 --> 00:02:45,060
first is to import the regular

00:02:43,049 --> 00:02:47,579
expression module which is import re

00:02:45,060 --> 00:02:49,200
then you want to call the compile

00:02:47,579 --> 00:02:50,579
function and pass it your regular

00:02:49,200 --> 00:02:52,319
expression pattern that you're looking

00:02:50,579 --> 00:02:54,840
for then you're going to call the search

00:02:52,319 --> 00:02:56,700
method on the regular expression object

00:02:54,840 --> 00:02:59,040
that that returns you'll pass it the

00:02:56,700 --> 00:03:01,019
haystack string I call it the haystack

00:02:59,040 --> 00:03:02,220
string if you're looking for one string

00:03:01,019 --> 00:03:04,290
instead of another I'd say you're

00:03:02,220 --> 00:03:06,030
looking for the needle string inside the

00:03:04,290 --> 00:03:08,549
haystack string and that's going to

00:03:06,030 --> 00:03:11,939
return a match object and you call the

00:03:08,549 --> 00:03:13,470
group method on that and that will print

00:03:11,939 --> 00:03:15,329
out the exact text that you're looking

00:03:13,470 --> 00:03:17,579
for so did I say three lines I meant

00:03:15,329 --> 00:03:21,030
four lines but it's still basically just

00:03:17,579 --> 00:03:25,440
three lines of text compile search and

00:03:21,030 --> 00:03:27,120
group and also if you're busy scrambling

00:03:25,440 --> 00:03:29,250
to write all of this down remember you

00:03:27,120 --> 00:03:33,120
can download these slides at bitly /yes

00:03:29,250 --> 00:03:34,859
regex so just calm down don't stop

00:03:33,120 --> 00:03:37,889
taking notes and listen to my soothing

00:03:34,859 --> 00:03:40,199
voice let's focus in on each one of

00:03:37,889 --> 00:03:42,720
these parts so starting with compile and

00:03:40,199 --> 00:03:45,030
this regular expression string of the

00:03:42,720 --> 00:03:48,120
pattern that you're sending to compile

00:03:45,030 --> 00:03:50,819
this is the main complicated part of

00:03:48,120 --> 00:03:52,949
pythons regular expressions figuring out

00:03:50,819 --> 00:03:55,560
the syntax for this so let's go back to

00:03:52,949 --> 00:03:57,959
that phone number example what exactly

00:03:55,560 --> 00:03:59,579
is a phone number how you know a phone

00:03:57,959 --> 00:04:02,699
number when you see it well it starts

00:03:59,579 --> 00:04:05,489
off with a digit character which is one

00:04:02,699 --> 00:04:08,040
of the ten numerals 0 through 9 followed

00:04:05,489 --> 00:04:10,739
by another digit character and another

00:04:08,040 --> 00:04:14,879
digit character and then a dash and so

00:04:10,739 --> 00:04:17,579
on so we need to translate this into a

00:04:14,879 --> 00:04:20,039
regular expression string in the regular

00:04:17,579 --> 00:04:21,659
expression syntax and that's what we're

00:04:20,039 --> 00:04:24,810
going to pass to compile remember

00:04:21,659 --> 00:04:26,940
there's compile search end group so

00:04:24,810 --> 00:04:27,460
we're going to use slash D which is the

00:04:26,940 --> 00:04:31,479
Reg

00:04:27,460 --> 00:04:33,009
expression syntax for a digit you want

00:04:31,479 --> 00:04:34,780
to really pass this as a raw string

00:04:33,009 --> 00:04:36,400
because otherwise if you don't have a

00:04:34,780 --> 00:04:38,020
raw string you're going to have to

00:04:36,400 --> 00:04:39,340
escape that slash and you're going to

00:04:38,020 --> 00:04:41,380
have all of these slashes in your

00:04:39,340 --> 00:04:45,039
regular expression string so I tend to

00:04:41,380 --> 00:04:47,680
like to send raw strings always to the

00:04:45,039 --> 00:04:49,900
compile function so this slash D will

00:04:47,680 --> 00:04:51,009
match a digit character and our phone

00:04:49,900 --> 00:04:53,800
numbers are going to have three of these

00:04:51,009 --> 00:04:56,979
for the for the area code followed by a

00:04:53,800 --> 00:04:59,380
dash and so on this is the regular

00:04:56,979 --> 00:05:02,440
expression string to match a phone

00:04:59,380 --> 00:05:04,870
number after that we get the regular

00:05:02,440 --> 00:05:07,419
expression object and we can call search

00:05:04,870 --> 00:05:08,860
on that and pass it our haystack string

00:05:07,419 --> 00:05:11,110
this is the string that we're searching

00:05:08,860 --> 00:05:14,830
for that pattern we're looking for and

00:05:11,110 --> 00:05:16,389
it will return a match object and it

00:05:14,830 --> 00:05:18,250
will return a match object if it finds

00:05:16,389 --> 00:05:20,409
the pattern otherwise it'll return none

00:05:18,250 --> 00:05:22,720
so we have to check if the match object

00:05:20,409 --> 00:05:26,110
is none or not and when we call group on

00:05:22,720 --> 00:05:28,690
that match object remember a compile

00:05:26,110 --> 00:05:31,570
search group that's going to print out

00:05:28,690 --> 00:05:33,039
the actual text that matches the the

00:05:31,570 --> 00:05:36,699
regular expression pattern that we were

00:05:33,039 --> 00:05:38,860
looking for just like that now this

00:05:36,699 --> 00:05:40,960
seems I know I said that oh it's a lot

00:05:38,860 --> 00:05:41,800
easier than you think this is still kind

00:05:40,960 --> 00:05:45,550
of complicated

00:05:41,800 --> 00:05:47,349
remembering compile search group if

00:05:45,550 --> 00:05:49,360
you're just calling the find string

00:05:47,349 --> 00:05:50,740
method that's a lot more straightforward

00:05:49,360 --> 00:05:52,960
it's just one line of code but imagine

00:05:50,740 --> 00:05:56,050
if you didn't have regular expressions

00:05:52,960 --> 00:05:57,009
to do this fine phone number example you

00:05:56,050 --> 00:06:01,150
would have to write Python code that

00:05:57,009 --> 00:06:03,250
looks like this which isn't that hard to

00:06:01,150 --> 00:06:07,599
follow but it's a lot of it and it's

00:06:03,250 --> 00:06:10,240
really gnarly and phone numbers are

00:06:07,599 --> 00:06:11,740
actually pretty simple patterns once you

00:06:10,240 --> 00:06:14,050
get into really much more complicated

00:06:11,740 --> 00:06:15,940
regular expressions the Python code that

00:06:14,050 --> 00:06:17,530
you would have to write to do the same

00:06:15,940 --> 00:06:20,139
thing as a small regular expression

00:06:17,530 --> 00:06:22,659
would just explode and across pages and

00:06:20,139 --> 00:06:25,120
pages of text and we don't want that so

00:06:22,659 --> 00:06:26,650
let's examine that /d thing that I was

00:06:25,120 --> 00:06:28,449
talking about earlier that that matches

00:06:26,650 --> 00:06:31,150
a digit this is something called a

00:06:28,449 --> 00:06:33,520
character class it's it represents a

00:06:31,150 --> 00:06:35,110
range of characters or a class of

00:06:33,520 --> 00:06:37,389
characters that you're looking for and

00:06:35,110 --> 00:06:39,130
/t is the one saying I'm looking for a

00:06:37,389 --> 00:06:40,710
digit one of the numbers there's a few

00:06:39,130 --> 00:06:43,980
other character classes there's

00:06:40,710 --> 00:06:45,900
w forward characters this is letters and

00:06:43,980 --> 00:06:48,930
numbers and I believe also the

00:06:45,900 --> 00:06:51,120
underscore character there /s for space

00:06:48,930 --> 00:06:54,390
characters like space and tab and

00:06:51,120 --> 00:06:56,580
newline and there's also the capitalized

00:06:54,390 --> 00:07:00,570
versions of these for everything that's

00:06:56,580 --> 00:07:03,000
not a digit or not a word or not a space

00:07:00,570 --> 00:07:06,270
character character classes are how you

00:07:03,000 --> 00:07:07,920
specify what exactly you're looking for

00:07:06,270 --> 00:07:10,770
so whenever you're searching through a

00:07:07,920 --> 00:07:13,320
string try not to think of the actual

00:07:10,770 --> 00:07:15,150
semantic meaning of whatever text you're

00:07:13,320 --> 00:07:17,880
looking for just consider that string to

00:07:15,150 --> 00:07:20,310
be a sequence of symbols that you're

00:07:17,880 --> 00:07:23,700
looking for and these character classes

00:07:20,310 --> 00:07:25,290
match a certain group of symbols you can

00:07:23,700 --> 00:07:26,970
also create your own character classes

00:07:25,290 --> 00:07:28,710
by putting a bunch of characters inside

00:07:26,970 --> 00:07:31,470
the square bracket so if we wanted to

00:07:28,710 --> 00:07:33,510
say create a character class that

00:07:31,470 --> 00:07:37,410
matched all the vowels in the English

00:07:33,510 --> 00:07:39,960
language we just type a e i o u in lower

00:07:37,410 --> 00:07:41,340
case and upper case inside the square

00:07:39,960 --> 00:07:44,700
brackets and now we have a character

00:07:41,340 --> 00:07:47,040
class matching vowel characters we can

00:07:44,700 --> 00:07:48,930
also do the same thing as the the

00:07:47,040 --> 00:07:51,330
uppercase version of those previous

00:07:48,930 --> 00:07:53,130
character classes by just adding a caret

00:07:51,330 --> 00:07:54,960
character to the very front of this

00:07:53,130 --> 00:07:57,120
character class and now this is matching

00:07:54,960 --> 00:07:58,980
everything that's not a vowel character

00:07:57,120 --> 00:08:01,080
so that's going to be consonants it'll

00:07:58,980 --> 00:08:03,180
also be something like punctuation marks

00:08:01,080 --> 00:08:04,590
or numbers that's something that you

00:08:03,180 --> 00:08:06,690
have to keep in mind it's everything

00:08:04,590 --> 00:08:09,750
that is literally not those 10

00:08:06,690 --> 00:08:11,820
characters and we can also have ranges

00:08:09,750 --> 00:08:15,660
of characters if you want to match say

00:08:11,820 --> 00:08:18,120
all 26 letters or all 10 numbers or all

00:08:15,660 --> 00:08:21,330
or both of those things you can just use

00:08:18,120 --> 00:08:23,850
a dash character to have say 0-9 and

00:08:21,330 --> 00:08:25,560
that's going to be all 10 characters and

00:08:23,850 --> 00:08:27,750
this character class basically does the

00:08:25,560 --> 00:08:29,640
same thing as the /w character class

00:08:27,750 --> 00:08:35,100
it's matching all the numbers and

00:08:29,640 --> 00:08:36,780
letters so in these examples we had the

00:08:35,100 --> 00:08:38,370
caret character at the very beginning or

00:08:36,780 --> 00:08:41,030
those dash characters we're not

00:08:38,370 --> 00:08:43,260
literally looking for those characters

00:08:41,030 --> 00:08:46,110
punctuation marks in regular expression

00:08:43,260 --> 00:08:50,250
syntax tends to have very specific

00:08:46,110 --> 00:08:52,440
meaning so if we're actually looking for

00:08:50,250 --> 00:08:53,540
any of these punctuation market

00:08:52,440 --> 00:08:55,730
characters

00:08:53,540 --> 00:08:58,820
be sure to add to escape them with a

00:08:55,730 --> 00:09:00,320
backslash in front of them so if say we

00:08:58,820 --> 00:09:03,410
wanted to create a character class that

00:09:00,320 --> 00:09:05,720
matches open and closing parentheses we

00:09:03,410 --> 00:09:07,310
can just add a slash character in front

00:09:05,720 --> 00:09:10,040
of those parentheses and now we have a

00:09:07,310 --> 00:09:11,990
character class that matches the set of

00:09:10,040 --> 00:09:15,199
parentheses either the opening or

00:09:11,990 --> 00:09:16,850
closing characters so character classes

00:09:15,199 --> 00:09:19,490
as I said this is what you're looking

00:09:16,850 --> 00:09:21,319
for inside of your regular expression

00:09:19,490 --> 00:09:23,120
that's how you tell Python I'm looking

00:09:21,319 --> 00:09:25,279
for these characters you can also

00:09:23,120 --> 00:09:26,779
specify a quantity of these characters

00:09:25,279 --> 00:09:29,930
we kind of did this with a phone number

00:09:26,779 --> 00:09:31,579
example just by repeating the slash DS

00:09:29,930 --> 00:09:33,500
over and over again but there's a

00:09:31,579 --> 00:09:36,560
shortcut for this you can use curly

00:09:33,500 --> 00:09:39,259
braces and a number in between the curly

00:09:36,560 --> 00:09:41,029
braces to say hey I'm looking for three

00:09:39,259 --> 00:09:43,639
of these digit characters followed by a

00:09:41,029 --> 00:09:45,889
dash and so on for the rest of the phone

00:09:43,639 --> 00:09:47,569
number example this matches the exact

00:09:45,889 --> 00:09:48,949
same thing as the previous regular

00:09:47,569 --> 00:09:51,319
expression but it's a bit more compact

00:09:48,949 --> 00:09:53,600
and here's the pattern that we're

00:09:51,319 --> 00:09:56,089
following right here we have slash key

00:09:53,600 --> 00:09:57,949
that's the character class that's what

00:09:56,089 --> 00:10:00,440
we're looking for coming first and then

00:09:57,949 --> 00:10:01,970
after that we have the quantity that

00:10:00,440 --> 00:10:04,550
we're looking for you're going to see

00:10:01,970 --> 00:10:06,589
this repeated over and over again what

00:10:04,550 --> 00:10:09,680
we're looking for and the quantity that

00:10:06,589 --> 00:10:11,720
we're looking for and that curly brace 3

00:10:09,680 --> 00:10:14,329
for matching three of the thing that it

00:10:11,720 --> 00:10:15,829
comes after is really handy but there's

00:10:14,329 --> 00:10:18,709
a bunch of these others and they're a

00:10:15,829 --> 00:10:20,959
huge list of punctuation marks you don't

00:10:18,709 --> 00:10:23,120
actually have to memorize these very few

00:10:20,959 --> 00:10:24,740
people do memorize these you'll just end

00:10:23,120 --> 00:10:26,540
up going back to a cheat sheet or

00:10:24,740 --> 00:10:27,680
looking them up in the documentation but

00:10:26,540 --> 00:10:30,170
you have all these punctuation marks

00:10:27,680 --> 00:10:32,329
that mean things like hey I have slash D

00:10:30,170 --> 00:10:34,160
I'm looking for a digit and the question

00:10:32,329 --> 00:10:36,230
mark which means I'm looking for zero or

00:10:34,160 --> 00:10:38,060
one of these digits or the plus sign

00:10:36,230 --> 00:10:40,760
that means I'm looking for one or more

00:10:38,060 --> 00:10:41,839
of these digit characters you can change

00:10:40,760 --> 00:10:43,130
the character class that you're looking

00:10:41,839 --> 00:10:44,930
for - and suddenly it's you know I'm

00:10:43,130 --> 00:10:48,110
looking for a zero or one space or I'm

00:10:44,930 --> 00:10:49,939
looking for one or more spaces or use

00:10:48,110 --> 00:10:51,680
your own character classes like we did

00:10:49,939 --> 00:10:54,350
with our Val example now we're looking

00:10:51,680 --> 00:10:56,899
for zero or one valve and one or more

00:10:54,350 --> 00:10:58,160
valves all those punctuation marks you

00:10:56,899 --> 00:11:00,560
don't have to memorize them right now

00:10:58,160 --> 00:11:01,910
just remember we have character classes

00:11:00,560 --> 00:11:05,560
at the first part that's what we're

00:11:01,910 --> 00:11:05,560
looking for followed by the quantity

00:11:05,649 --> 00:11:10,819
analysis I'm going to

00:11:07,279 --> 00:11:13,189
completely different so Japanese words

00:11:10,819 --> 00:11:15,920
are composed of letters and Japanese

00:11:13,189 --> 00:11:19,129
letters usually follow this consonant

00:11:15,920 --> 00:11:21,499
vowel combination so take a japanese

00:11:19,129 --> 00:11:23,629
word like sayonara it's made up of four

00:11:21,499 --> 00:11:25,639
letters each of those are a consonant

00:11:23,629 --> 00:11:27,319
and vowel it's a consonant vowel

00:11:25,639 --> 00:11:29,300
consonant vowel it's following that

00:11:27,319 --> 00:11:31,100
pattern we can create a regular

00:11:29,300 --> 00:11:33,620
expression that will then match this

00:11:31,100 --> 00:11:35,209
remember we have a character class for

00:11:33,620 --> 00:11:36,740
matching vowels and then we also have

00:11:35,209 --> 00:11:37,899
that caret one for matching that

00:11:36,740 --> 00:11:40,399
everything that's not a vowel

00:11:37,899 --> 00:11:43,009
technically this will match not just

00:11:40,399 --> 00:11:44,540
consonant letters but also numbers and

00:11:43,009 --> 00:11:45,019
punctuation marks we'll just ignore that

00:11:44,540 --> 00:11:47,259
for right now

00:11:45,019 --> 00:11:49,309
but anyway saying we wanted to match a

00:11:47,259 --> 00:11:51,110
japanese word which is made up of

00:11:49,309 --> 00:11:53,420
several of these japanese letters we can

00:11:51,110 --> 00:11:56,949
have the plus sign that means one or

00:11:53,420 --> 00:11:59,870
more of the thing that comes before it

00:11:56,949 --> 00:12:01,939
but technically this isn't going to work

00:11:59,870 --> 00:12:04,879
because remember it's just going to

00:12:01,939 --> 00:12:07,970
match only one of those consonant

00:12:04,879 --> 00:12:10,160
patterns we need to specify how many of

00:12:07,970 --> 00:12:11,959
those that we that we want to match but

00:12:10,160 --> 00:12:14,480
we also sort of want to group these

00:12:11,959 --> 00:12:16,160
together so this regular expression is

00:12:14,480 --> 00:12:22,850
going to end up matching something like

00:12:16,160 --> 00:12:25,160
ah but so it's a consonant character

00:12:22,850 --> 00:12:26,959
followed by a bunch of owls and it

00:12:25,160 --> 00:12:28,430
doesn't have to be the same valid can

00:12:26,959 --> 00:12:30,379
just be any Val that's the character

00:12:28,430 --> 00:12:32,720
class that we're looking for one or more

00:12:30,379 --> 00:12:35,629
vowel characters I'm not even going to

00:12:32,720 --> 00:12:37,430
attempt to pronounce this word but what

00:12:35,629 --> 00:12:39,230
we want to do is sort of just group

00:12:37,430 --> 00:12:41,300
together that consonant and vowel

00:12:39,230 --> 00:12:44,809
together and then have the plus sign

00:12:41,300 --> 00:12:46,430
mean one or more of these things so we

00:12:44,809 --> 00:12:49,399
can use parentheses to group these

00:12:46,430 --> 00:12:51,379
together in forms a sort of one giant

00:12:49,399 --> 00:12:52,970
character class out of all these other

00:12:51,379 --> 00:12:55,009
character classes it's still the same

00:12:52,970 --> 00:12:57,230
thing we're specifying what we want to

00:12:55,009 --> 00:12:59,059
look for followed by how many of them

00:12:57,230 --> 00:13:01,040
that we want to look for so this is

00:12:59,059 --> 00:13:03,470
going to match something like saw saw

00:13:01,040 --> 00:13:07,339
saw saw saw saw saw saw or it'll match

00:13:03,470 --> 00:13:08,899
an actual Japanese word like sayonara so

00:13:07,339 --> 00:13:12,110
this would be a pretty good point for me

00:13:08,899 --> 00:13:13,519
to somatically end my talk on sayonara

00:13:12,110 --> 00:13:15,230
but actually there's a little bit more

00:13:13,519 --> 00:13:18,259
we're going to go into just a small

00:13:15,230 --> 00:13:19,939
example right here with reg X's for a

00:13:18,259 --> 00:13:20,870
comma formatted number so if you're an

00:13:19,939 --> 00:13:22,850
American

00:13:20,870 --> 00:13:24,680
you usually split up your numbers into

00:13:22,850 --> 00:13:27,589
groups of three with a comma in between

00:13:24,680 --> 00:13:29,330
them in between them so let's create a

00:13:27,589 --> 00:13:32,089
regular expression for this we have to

00:13:29,330 --> 00:13:34,880
figure out what exactly it is that the

00:13:32,089 --> 00:13:36,140
pattern that we want to match here is so

00:13:34,880 --> 00:13:38,120
it's generally going to be something

00:13:36,140 --> 00:13:41,630
like one two three digits for the lead

00:13:38,120 --> 00:13:43,670
part and then followed by groups of the

00:13:41,630 --> 00:13:46,130
sort of comma and three digits

00:13:43,670 --> 00:13:48,200
afterwards and we'll have you know zero

00:13:46,130 --> 00:13:50,510
or more of those groups so a number like

00:13:48,200 --> 00:13:52,130
12 is going to have zero of those comma

00:13:50,510 --> 00:13:54,020
groups because there's no commas or a

00:13:52,130 --> 00:13:56,480
number like twelve thousand will have

00:13:54,020 --> 00:13:58,820
one of those groups and I could just sit

00:13:56,480 --> 00:14:00,170
here and show you the regular expression

00:13:58,820 --> 00:14:02,630
for this but there's actually a lot of

00:14:00,170 --> 00:14:05,570
nifty tools online that you can try out

00:14:02,630 --> 00:14:08,210
these are called regex buddy websites or

00:14:05,570 --> 00:14:09,320
regex tester websites and now I'm going

00:14:08,210 --> 00:14:11,540
to do something that is highly

00:14:09,320 --> 00:14:14,510
ill-advised for anybody doing a

00:14:11,540 --> 00:14:17,570
presentation and that is a live demo in

00:14:14,510 --> 00:14:21,560
which anything can go wrong especially

00:14:17,570 --> 00:14:24,410
one that requires using the Internet so

00:14:21,560 --> 00:14:27,170
hopefully the Wi-Fi is going to hold and

00:14:24,410 --> 00:14:29,779
I can just use this website so this is

00:14:27,170 --> 00:14:31,790
red jax-ur com

00:14:29,779 --> 00:14:33,680
technically it's using JavaScript style

00:14:31,790 --> 00:14:35,089
regular expressions but regular

00:14:33,680 --> 00:14:37,070
expressions across multiple programming

00:14:35,089 --> 00:14:38,810
languages are so similar that it's going

00:14:37,070 --> 00:14:42,230
to work for Python as well so let's

00:14:38,810 --> 00:14:50,930
let's try out let's say I have my text I

00:14:42,230 --> 00:14:52,100
have a 64 million year old egg we want

00:14:50,930 --> 00:14:55,850
to find a regular expression that

00:14:52,100 --> 00:14:59,240
matches let's see how much I can move

00:14:55,850 --> 00:15:00,980
this not that okay there we go

00:14:59,240 --> 00:15:02,480
I want to write write a regular

00:15:00,980 --> 00:15:04,940
expression that matches that comma

00:15:02,480 --> 00:15:08,209
delimited number so let's see what was

00:15:04,940 --> 00:15:10,160
this this was a digit and then I want

00:15:08,209 --> 00:15:14,089
between 1 and 3 of them so I'll try a

00:15:10,160 --> 00:15:15,980
curly brace 1 comma 3 and you can see as

00:15:14,089 --> 00:15:17,600
I'm typing in real time these websites

00:15:15,980 --> 00:15:20,060
are going to update and show you exactly

00:15:17,600 --> 00:15:21,950
what they're what they're matching so

00:15:20,060 --> 00:15:24,140
these are great if you're trying to

00:15:21,950 --> 00:15:25,970
construct a regular expression and you

00:15:24,140 --> 00:15:27,860
sort of want to just build it up step by

00:15:25,970 --> 00:15:30,200
step it's a lot easier than just running

00:15:27,860 --> 00:15:32,480
your code seeing what it matches and

00:15:30,200 --> 00:15:34,940
trying to go back and change it

00:15:32,480 --> 00:15:36,170
this is a much more direct method so let

00:15:34,940 --> 00:15:38,199
me finish this up let's see we're going

00:15:36,170 --> 00:15:40,190
to have that group of the comma

00:15:38,199 --> 00:15:46,540
three-digit thing so I'll need a nurse

00:15:40,190 --> 00:15:49,790
slash D and then a3 afterwards wait

00:15:46,540 --> 00:15:51,620
great and I can see well oh this isn't

00:15:49,790 --> 00:15:53,480
quite working because it's not matching

00:15:51,620 --> 00:15:56,750
everything right here and now remember

00:15:53,480 --> 00:15:59,389
oh right I wanted not one of these comma

00:15:56,750 --> 00:16:01,940
groups but zero or more so I'm going to

00:15:59,389 --> 00:16:03,949
add a star to mean zero war and I can

00:16:01,940 --> 00:16:07,790
see okay it matches the comma-delimited

00:16:03,949 --> 00:16:12,130
number all right hey I got through the

00:16:07,790 --> 00:16:20,300
entire live demo and nothing went wrong

00:16:12,130 --> 00:16:22,130
rude yes well I'm demo complete every

00:16:20,300 --> 00:16:24,680
time I do a live demo and I talk I feel

00:16:22,130 --> 00:16:26,630
like I'm like angering the live demo god

00:16:24,680 --> 00:16:28,760
who's going to start chasing me from

00:16:26,630 --> 00:16:30,740
conference to conference waiting for me

00:16:28,760 --> 00:16:36,970
to let my guard down and just ruin the

00:16:30,740 --> 00:16:36,970
next live demo I try right not today

00:16:37,630 --> 00:16:45,139
okay next pipes this is a way that you

00:16:41,630 --> 00:16:47,089
can sort of provide alternate groups to

00:16:45,139 --> 00:16:49,670
choose from and the example that I want

00:16:47,089 --> 00:16:52,160
to use is let's say we want to create a

00:16:49,670 --> 00:16:54,980
regular expression to match sentences of

00:16:52,160 --> 00:16:57,589
Monty Python words and Monty Python

00:16:54,980 --> 00:16:59,180
words I'm going to use underscores

00:16:57,589 --> 00:17:01,490
instead of spaces just make them more

00:16:59,180 --> 00:17:03,079
visible and just to make it easier and

00:17:01,490 --> 00:17:05,000
more consistent all the Monty Python

00:17:03,079 --> 00:17:06,530
words always end with an underscore but

00:17:05,000 --> 00:17:09,679
Monty Python words will be something

00:17:06,530 --> 00:17:12,470
like again spam or egg bacon and spam or

00:17:09,679 --> 00:17:15,500
egg bacon sausage and spam or spam eggs

00:17:12,470 --> 00:17:18,709
spam spam bacon and spam that one only

00:17:15,500 --> 00:17:20,329
has a little bit of spam in it so you

00:17:18,709 --> 00:17:21,799
might think okay let's create a regular

00:17:20,329 --> 00:17:23,929
expression we're going to call compile

00:17:21,799 --> 00:17:27,530
that's the first step of compile search

00:17:23,929 --> 00:17:29,750
group and let's see we'll put these in a

00:17:27,530 --> 00:17:32,600
group for each word and we'll have that

00:17:29,750 --> 00:17:34,610
plus sign to mean one or more of this so

00:17:32,600 --> 00:17:37,280
we're going to match one or more egg and

00:17:34,610 --> 00:17:39,200
one or more bacon except that's not

00:17:37,280 --> 00:17:41,250
going to quite work because what if

00:17:39,200 --> 00:17:44,130
bacon comes before the egg

00:17:41,250 --> 00:17:46,230
and what it's sausage comes before egg

00:17:44,130 --> 00:17:47,610
or bacon or something like that this

00:17:46,230 --> 00:17:50,040
isn't actually going to work as a

00:17:47,610 --> 00:17:53,250
regular expression we we just need some

00:17:50,040 --> 00:17:55,470
way of choosing one or another and we

00:17:53,250 --> 00:17:57,720
kind of do this if you think about it

00:17:55,470 --> 00:18:01,560
with character classes character classes

00:17:57,720 --> 00:18:05,340
say hey we're going to match a or E or I

00:18:01,560 --> 00:18:06,960
or o or you accept character classes

00:18:05,340 --> 00:18:09,960
only work with individual characters

00:18:06,960 --> 00:18:13,710
rather we want to match groups saying

00:18:09,960 --> 00:18:15,750
egg or bacon or sausage etc so we can do

00:18:13,710 --> 00:18:17,490
that with the pipe character which means

00:18:15,750 --> 00:18:19,950
or if you've ever programmed in a

00:18:17,490 --> 00:18:22,590
language like JavaScript or something

00:18:19,950 --> 00:18:24,780
else they also use the ORA character for

00:18:22,590 --> 00:18:26,670
the boolean or operator so it's a bit

00:18:24,780 --> 00:18:28,350
easier to remember that way so you can

00:18:26,670 --> 00:18:31,380
just put the pipe character in between

00:18:28,350 --> 00:18:35,820
these groups to say I want to match egg

00:18:31,380 --> 00:18:37,770
or bacon or sausage or and or spam and

00:18:35,820 --> 00:18:40,020
then put all of those groups into one

00:18:37,770 --> 00:18:42,330
giant group and then add a plus sign at

00:18:40,020 --> 00:18:43,440
the end so that it's matching one or

00:18:42,330 --> 00:18:45,570
more of those and that will match

00:18:43,440 --> 00:18:49,500
something like spam spam spam spam spam

00:18:45,570 --> 00:18:51,530
spam spam really stop something like a

00:18:49,500 --> 00:18:55,830
word if you say it over and over again

00:18:51,530 --> 00:18:58,350
and the last bit that I want to cover

00:18:55,830 --> 00:18:59,790
you actually this is pretty much all you

00:18:58,350 --> 00:19:03,230
need for the basics of regular

00:18:59,790 --> 00:19:07,050
expressions character classes quantities

00:19:03,230 --> 00:19:08,820
groups pipes that's essentially it

00:19:07,050 --> 00:19:10,830
this thing regular expressions that

00:19:08,820 --> 00:19:12,870
you've been putting off learning for

00:19:10,830 --> 00:19:14,250
years and years and years it's actually

00:19:12,870 --> 00:19:16,050
not that bad

00:19:14,250 --> 00:19:17,850
the rest of the stuff is just gravy but

00:19:16,050 --> 00:19:20,160
it's pretty cool I really love this the

00:19:17,850 --> 00:19:23,550
dot which basically means match any

00:19:20,160 --> 00:19:25,380
character except for the newline this is

00:19:23,550 --> 00:19:27,510
great because it's a great character

00:19:25,380 --> 00:19:29,580
class you can also set a flag so that

00:19:27,510 --> 00:19:32,070
also includes the newline but you can

00:19:29,580 --> 00:19:34,350
combine it with the star character from

00:19:32,070 --> 00:19:35,670
several slides back that means zero or

00:19:34,350 --> 00:19:38,430
more and when they're powers combined

00:19:35,670 --> 00:19:41,580
they form the dot star which just means

00:19:38,430 --> 00:19:44,160
match whatever there's a second one to

00:19:41,580 --> 00:19:46,260
this that is dot star question mark

00:19:44,160 --> 00:19:49,230
which means match the least amount of

00:19:46,260 --> 00:19:50,970
whatever because dot just means match

00:19:49,230 --> 00:19:52,650
whatever character and we're looking for

00:19:50,970 --> 00:19:55,110
zero or more of whatever so you can

00:19:52,650 --> 00:19:58,350
match whatever this is great you can you

00:19:55,110 --> 00:20:00,240
in a string like looking for text angle

00:19:58,350 --> 00:20:03,900
bracket in between the angle brackets

00:20:00,240 --> 00:20:05,670
angle bracket this looks a lot like HTML

00:20:03,900 --> 00:20:07,500
and so let's say we want to get a

00:20:05,670 --> 00:20:10,320
regular expression that matches this

00:20:07,500 --> 00:20:12,420
HTML like text that's pretty simple we

00:20:10,320 --> 00:20:14,850
can just have angle bracket dot star

00:20:12,420 --> 00:20:16,950
question mark angle bracket so we're

00:20:14,850 --> 00:20:19,020
just looking for whatever text in

00:20:16,950 --> 00:20:20,730
between angle brackets the least amount

00:20:19,020 --> 00:20:22,980
of it and then that would match a string

00:20:20,730 --> 00:20:25,380
that's sort of like angle bracket to

00:20:22,980 --> 00:20:27,000
serve humans angle bracket but remember

00:20:25,380 --> 00:20:28,740
there's the one with the question mark

00:20:27,000 --> 00:20:30,690
that's the least amount that's the non

00:20:28,740 --> 00:20:32,549
greedy version and then there's just dot

00:20:30,690 --> 00:20:34,530
star which is the greedy version it's

00:20:32,549 --> 00:20:36,630
going to try to match the longest bit of

00:20:34,530 --> 00:20:39,650
text and that's when you find out the

00:20:36,630 --> 00:20:42,179
dark secret that really the string was

00:20:39,650 --> 00:20:45,270
angle bracket to serve humans angle

00:20:42,179 --> 00:20:47,850
bracket for dinner angle bracket whew

00:20:45,270 --> 00:20:50,340
plot twist and the reason this happens

00:20:47,850 --> 00:20:52,500
is because dot star the greedy version

00:20:50,340 --> 00:20:54,390
is going to match the first part to

00:20:52,500 --> 00:20:56,040
serve humans and that technically

00:20:54,390 --> 00:20:57,600
matches the pattern that's looking for

00:20:56,040 --> 00:20:59,730
but dot star is going to continue

00:20:57,600 --> 00:21:01,679
looking forward to see if there's an

00:20:59,730 --> 00:21:03,390
even larger string that it can match so

00:21:01,679 --> 00:21:05,460
if you want to match the most amount of

00:21:03,390 --> 00:21:07,110
text for this pattern you can use dot

00:21:05,460 --> 00:21:09,720
star and the least amount you can use

00:21:07,110 --> 00:21:11,850
dot star question mark that's pretty

00:21:09,720 --> 00:21:13,799
much hit the you now have this solid

00:21:11,850 --> 00:21:15,690
foundation you can go into the Python

00:21:13,799 --> 00:21:17,520
documentation and sort of look up all

00:21:15,690 --> 00:21:18,990
the rest of the neat little tricks that

00:21:17,520 --> 00:21:21,360
you can do with regular expressions I

00:21:18,990 --> 00:21:23,700
kind of just want to end on some best

00:21:21,360 --> 00:21:25,710
practices some limitations to regular

00:21:23,700 --> 00:21:28,020
expressions the first of which is really

00:21:25,710 --> 00:21:30,600
important and that is don't ever parse

00:21:28,020 --> 00:21:33,450
HTML with regular expressions I know I

00:21:30,600 --> 00:21:35,850
went back into this slide and said hey

00:21:33,450 --> 00:21:38,070
that looks like HTML don't actually do

00:21:35,850 --> 00:21:39,390
that with regular expressions you'll end

00:21:38,070 --> 00:21:41,340
up creating a regular expression that

00:21:39,390 --> 00:21:43,679
sort of matches HTML and then you'll

00:21:41,340 --> 00:21:45,150
realize oh wait it also needs to be case

00:21:43,679 --> 00:21:46,590
insensitive so then you've changed it a

00:21:45,150 --> 00:21:48,179
little bit and then you realize oh wait

00:21:46,590 --> 00:21:49,770
there's some attribute that's out of

00:21:48,179 --> 00:21:50,850
order or something weird like that and

00:21:49,770 --> 00:21:53,610
you'll have to change the regular

00:21:50,850 --> 00:21:55,320
expression you'll end up making a

00:21:53,610 --> 00:21:57,960
regular expression that doesn't really

00:21:55,320 --> 00:21:59,669
match HTML instead what you should do is

00:21:57,960 --> 00:22:02,400
use an HTML parsing tool like

00:21:59,669 --> 00:22:04,620
beautifulsoup that module same thing

00:22:02,400 --> 00:22:08,820
with json you want to use a JSON parser

00:22:04,620 --> 00:22:10,769
to match json text the second thing is

00:22:08,820 --> 00:22:12,299
I used to use this as an interview

00:22:10,769 --> 00:22:14,009
question come up with a regular

00:22:12,299 --> 00:22:15,620
expression that matches a strong

00:22:14,009 --> 00:22:18,059
password you know something that has

00:22:15,620 --> 00:22:20,429
lowercase and uppercase letters and

00:22:18,059 --> 00:22:22,320
numbers and special characters the

00:22:20,429 --> 00:22:24,690
regular expression to do this turns out

00:22:22,320 --> 00:22:26,610
to be this huge giant thing especially

00:22:24,690 --> 00:22:28,409
because you have to get the all possible

00:22:26,610 --> 00:22:30,210
orderings of lowercase and uppercase and

00:22:28,409 --> 00:22:32,940
numbers and everything and it's really

00:22:30,210 --> 00:22:35,730
awful if your regular expression starts

00:22:32,940 --> 00:22:37,889
blowing up into this giant thing it's

00:22:35,730 --> 00:22:39,450
probably a good time to just break it up

00:22:37,889 --> 00:22:41,279
into smaller regular expressions you can

00:22:39,450 --> 00:22:43,320
just use multiple regular regular

00:22:41,279 --> 00:22:45,000
expressions on the same bit of text

00:22:43,320 --> 00:22:46,440
something that looks for a lowercase

00:22:45,000 --> 00:22:48,990
letter something that looks for an

00:22:46,440 --> 00:22:51,240
uppercase character and then finally

00:22:48,990 --> 00:22:53,460
this is kind of going into the computer

00:22:51,240 --> 00:22:56,820
science of regular expressions and

00:22:53,460 --> 00:22:59,129
regular languages matching nested

00:22:56,820 --> 00:23:01,529
parentheses regular expressions can't do

00:22:59,129 --> 00:23:03,059
this matching parentheses rely on having

00:23:01,529 --> 00:23:04,860
the same number of open and closed

00:23:03,059 --> 00:23:07,919
parentheses they have to be in a certain

00:23:04,860 --> 00:23:09,659
order and technically regular

00:23:07,919 --> 00:23:11,340
expressions aren't turing-complete

00:23:09,659 --> 00:23:13,470
which is a computer science term them

00:23:11,340 --> 00:23:15,570
just going to gloss over but you can

00:23:13,470 --> 00:23:17,490
think of this it has regular expressions

00:23:15,570 --> 00:23:20,370
aren't programming languages they don't

00:23:17,490 --> 00:23:21,870
have flow control or loops or variables

00:23:20,370 --> 00:23:23,730
or things like that and the reason I

00:23:21,870 --> 00:23:26,429
know this is because at my last job

00:23:23,730 --> 00:23:28,830
we're doing a code review for some web

00:23:26,429 --> 00:23:30,899
app and the user can type in a regular

00:23:28,830 --> 00:23:32,039
expression into the text field we wanted

00:23:30,899 --> 00:23:33,929
to validate that make sure they were

00:23:32,039 --> 00:23:35,730
typing in a valid regular expression and

00:23:33,929 --> 00:23:37,860
a co-worker said hey can you actually

00:23:35,730 --> 00:23:40,799
come up with a regular expression that

00:23:37,860 --> 00:23:43,110
matches regular expressions and I left

00:23:40,799 --> 00:23:45,600
forward and said no you can't because

00:23:43,110 --> 00:23:47,940
regular expression strings have groups

00:23:45,600 --> 00:23:50,639
which require nested parentheses and

00:23:47,940 --> 00:23:52,590
that requires a stacked data structure

00:23:50,639 --> 00:23:54,299
which means it means it requires a

00:23:52,590 --> 00:23:55,710
context-free grammar and that's beyond

00:23:54,299 --> 00:23:57,539
the capabilities of regular languages

00:23:55,710 --> 00:23:59,190
and I was so excited because it was the

00:23:57,539 --> 00:24:01,230
only time I've ever used my computer

00:23:59,190 --> 00:24:05,850
science degree for something in the real

00:24:01,230 --> 00:24:08,340
world but yeah so that's just some best

00:24:05,850 --> 00:24:09,840
practices with regular expressions they

00:24:08,340 --> 00:24:12,419
do have their limitations but they are

00:24:09,840 --> 00:24:14,399
so incredibly powerful and useful to

00:24:12,419 --> 00:24:16,320
have so I definitely encourage all of

00:24:14,399 --> 00:24:17,909
you to keep reading about it you can

00:24:16,320 --> 00:24:20,879
find more in the Python documentation I

00:24:17,909 --> 00:24:22,230
also have them in the in chapter in

00:24:20,879 --> 00:24:22,800
automate the boring stuff with Python

00:24:22,230 --> 00:24:25,560
which you can

00:24:22,800 --> 00:24:27,360
for free online but I really advise that

00:24:25,560 --> 00:24:28,710
you go ahead and whatever you do find

00:24:27,360 --> 00:24:31,320
out more about regular expressions and

00:24:28,710 --> 00:24:35,510
use them because yes it is time to learn

00:24:31,320 --> 00:24:35,510
regular expressions thank you very much

00:24:36,370 --> 00:24:43,619
[Music]

00:24:40,259 --> 00:24:47,850
so do we have time for questions yes I

00:24:43,619 --> 00:24:49,979
guess line up at the microphones so we

00:24:47,850 --> 00:24:51,359
do have time for some questions so if

00:24:49,979 --> 00:24:54,179
you have some questions please line up

00:24:51,359 --> 00:24:57,059
here and please keep the questions short

00:24:54,179 --> 00:25:06,029
and simple because we have only five

00:24:57,059 --> 00:25:08,489
minutes left so yep hello Hey

00:25:06,029 --> 00:25:13,859
I believe you have a good use case for a

00:25:08,489 --> 00:25:15,239
look ahead I do I remember so one of the

00:25:13,859 --> 00:25:17,609
fancy things that you can do with

00:25:15,239 --> 00:25:19,830
regular expressions wow I've been saying

00:25:17,609 --> 00:25:20,970
regular expressions a lot today one of

00:25:19,830 --> 00:25:25,039
the things that you can do with them is

00:25:20,970 --> 00:25:31,499
not only find but also find and replace

00:25:25,039 --> 00:25:36,210
so let me let's say you had some text

00:25:31,499 --> 00:25:39,899
like agent Alice told agent Bob the in

00:25:36,210 --> 00:25:41,399
the info so look Ahead's are basically

00:25:39,899 --> 00:25:44,009
when you want to use the pattern that

00:25:41,399 --> 00:25:47,700
you found in a regular expression later

00:25:44,009 --> 00:25:49,830
on in that same regular expression so

00:25:47,700 --> 00:25:52,349
let's say you wanted to do something

00:25:49,830 --> 00:25:55,700
where you want to find every case of the

00:25:52,349 --> 00:25:58,679
pattern the word agent followed by some

00:25:55,700 --> 00:26:00,779
some other name you know and then using

00:25:58,679 --> 00:26:02,340
this space as telling it when to stop

00:26:00,779 --> 00:26:04,830
and you want to replace it with just

00:26:02,340 --> 00:26:06,989
star star star but keeping that first

00:26:04,830 --> 00:26:08,789
letter so this is sort of redacting it

00:26:06,989 --> 00:26:11,099
with a find and replace using regular

00:26:08,789 --> 00:26:14,879
expressions this is the example that I

00:26:11,099 --> 00:26:16,379
use for using look Ahead's which I'm

00:26:14,879 --> 00:26:18,479
going to mess this up I know

00:26:16,379 --> 00:26:21,779
let's see you would basically be looking

00:26:18,479 --> 00:26:27,690
for agent and then let's see

00:26:21,779 --> 00:26:29,940
/w I guess one or more of these oh haha

00:26:27,690 --> 00:26:34,529
that's why everybody's looking at me

00:26:29,940 --> 00:26:35,999
weird there we go oh now I can't see

00:26:34,529 --> 00:26:38,789
there we go

00:26:35,999 --> 00:26:41,759
yeah we're looking for like agent Alice

00:26:38,789 --> 00:26:44,190
and we want to find this text and then

00:26:41,759 --> 00:26:45,690
replace it we can use that group that's

00:26:44,190 --> 00:26:48,359
the first group that we found so we

00:26:45,690 --> 00:26:52,590
would replace it with this text agent

00:26:48,359 --> 00:26:53,240
slash one I believe meaning just use the

00:26:52,590 --> 00:26:56,150
text

00:26:53,240 --> 00:26:59,450
of the first group oh oh wait no I would

00:26:56,150 --> 00:27:00,890
want that first character so that's in

00:26:59,450 --> 00:27:06,100
our group followed by the rest of that

00:27:00,890 --> 00:27:08,420
name let me see if I got this right and

00:27:06,100 --> 00:27:11,600
so this is called a look ahead is where

00:27:08,420 --> 00:27:13,460
you use flash 1/2 to refer to the groups

00:27:11,600 --> 00:27:15,800
of characters in your regular expression

00:27:13,460 --> 00:27:17,240
pattern that you've matched before yeah

00:27:15,800 --> 00:27:22,850
anyway let's move on to the next

00:27:17,240 --> 00:27:25,760
question so in in an API that I'm what

00:27:22,850 --> 00:27:29,080
my team's writing we we use legislations

00:27:25,760 --> 00:27:32,020
and we need negative look behind and

00:27:29,080 --> 00:27:35,630
python only seems to support fix with

00:27:32,020 --> 00:27:38,000
fixed with groups so in your pattern if

00:27:35,630 --> 00:27:39,620
you do like something and something or

00:27:38,000 --> 00:27:41,780
something or something they will have to

00:27:39,620 --> 00:27:45,320
be the same width which seems bizarre to

00:27:41,780 --> 00:27:47,900
us and so our our solution is to just

00:27:45,320 --> 00:27:49,850
shell out to get into it properly in a

00:27:47,900 --> 00:27:52,070
proper oh yeah proper regular expression

00:27:49,850 --> 00:27:55,700
yeah ocean so do you have any other

00:27:52,070 --> 00:27:57,320
ideas I mean that is one way of doing it

00:27:55,700 --> 00:27:59,120
there's so there's slight variations

00:27:57,320 --> 00:28:01,280
between different languages and

00:27:59,120 --> 00:28:03,170
different command-line tools in how they

00:28:01,280 --> 00:28:04,970
handle regular expressions especially

00:28:03,170 --> 00:28:08,030
the more advanced features like these

00:28:04,970 --> 00:28:09,980
booked ahead things it basically if you

00:28:08,030 --> 00:28:11,840
find something that Python can't do you

00:28:09,980 --> 00:28:14,420
could find other regular expression

00:28:11,840 --> 00:28:16,040
modules if you really really need that

00:28:14,420 --> 00:28:17,780
behavior there's other regular

00:28:16,040 --> 00:28:20,420
expression modules on PI P I that you

00:28:17,780 --> 00:28:26,570
can download do we have time for more

00:28:20,420 --> 00:28:28,430
questions or are we out oh hi this

00:28:26,570 --> 00:28:30,290
question may be again the general spirit

00:28:28,430 --> 00:28:33,580
of fiora talk to learn regular

00:28:30,290 --> 00:28:36,050
expression is there a tool that lets you

00:28:33,580 --> 00:28:37,670
accept a before version and after

00:28:36,050 --> 00:28:39,740
version of attacks and suggests the

00:28:37,670 --> 00:28:41,510
regular expression R suggests some of

00:28:39,740 --> 00:28:44,270
the regular expressions we could come up

00:28:41,510 --> 00:28:46,040
with to do that that's kind of big sort

00:28:44,270 --> 00:28:49,520
of the exact project that I wanted to

00:28:46,040 --> 00:28:51,490
work on during the sprints was this was

00:28:49,520 --> 00:28:53,360
going to be like a learning tool for

00:28:51,490 --> 00:28:54,710
where you can type in a regular

00:28:53,360 --> 00:28:57,050
expression and I'll just start spitting

00:28:54,710 --> 00:29:01,370
out some example strings of what it

00:28:57,050 --> 00:29:02,990
could potentially match I from the brief

00:29:01,370 --> 00:29:05,480
looks that I did around the internet for

00:29:02,990 --> 00:29:06,800
a tool like this I haven't been able to

00:29:05,480 --> 00:29:08,750
find anything

00:29:06,800 --> 00:29:10,730
does something like that but that's a

00:29:08,750 --> 00:29:12,590
great idea somebody should make that or

00:29:10,730 --> 00:29:15,890
you can help me make that during the

00:29:12,590 --> 00:29:18,170
sprints wait for that Thanks thanks uh

00:29:15,890 --> 00:29:21,140
do we have time for one more question

00:29:18,170 --> 00:29:24,050
yeah a plant Hey this is just this is a

00:29:21,140 --> 00:29:25,610
intellectual vandalism how would I

00:29:24,050 --> 00:29:27,590
handle though your thing it's not a

00:29:25,610 --> 00:29:29,870
question oh yeah okay we assign go ahead

00:29:27,590 --> 00:29:37,180
your last person how do I handle Unicode

00:29:29,870 --> 00:29:42,260
uh oh wait unit unit code Oh unicode

00:29:37,180 --> 00:29:44,690
right so later no so I think I've tested

00:29:42,260 --> 00:29:47,420
this out and pythons regular expression

00:29:44,690 --> 00:29:51,710
module does handle Unicode I think I

00:29:47,420 --> 00:29:53,900
know this because I have this LOD Exe

00:29:51,710 --> 00:29:57,770
program I made which copies the look of

00:29:53,900 --> 00:30:03,560
disapproval emoji to my clipboard so I

00:29:57,770 --> 00:30:05,300
can just paste it oh I've already erased

00:30:03,560 --> 00:30:07,190
that but I tried pacing unicode

00:30:05,300 --> 00:30:08,570
characters and just all sorts of weird

00:30:07,190 --> 00:30:13,010
stuff in and it seems to work just fine

00:30:08,570 --> 00:30:15,560
so Bravo Python yeah well I tested that

00:30:13,010 --> 00:30:18,620
in Python 3 anyway I'm not sure who

00:30:15,560 --> 00:30:21,050
knows with Python - but yeah anything

00:30:18,620 --> 00:30:28,630
else oh that's it alright thank you very

00:30:21,050 --> 00:30:28,630

YouTube URL: https://www.youtube.com/watch?v=abrcJ9MpF60


