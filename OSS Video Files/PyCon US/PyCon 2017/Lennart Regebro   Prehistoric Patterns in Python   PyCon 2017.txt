Title: Lennart Regebro   Prehistoric Patterns in Python   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Lennart Regebro

Why do some code use dictionaries that have None for all values? Is it true that you shouldn't concatenate strings with +? Will Python optimize constant calculations?

This talk will go through some patterns that used to be common in Python, but which now are regarded as outdated and see if they really are outdated and why. The results surprised me, maybe they'll surprise you.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:00,030 --> 00:00:06,060
well welcome to our second talk our

00:00:02,730 --> 00:00:07,980
presenter today is Leonard Raj Abreu and

00:00:06,060 --> 00:00:10,769
he is going to be telling us about

00:00:07,980 --> 00:00:20,130
prehistoric patterns in Python please

00:00:10,769 --> 00:00:23,340
make him welcome thank you yes my name

00:00:20,130 --> 00:00:25,949
is Leonard unpronounceable I've been

00:00:23,340 --> 00:00:29,029
working with Python full-time since 2001

00:00:25,949 --> 00:00:33,149
which is a fair bit of time and I've

00:00:29,029 --> 00:00:36,090
also written a book this is open source

00:00:33,149 --> 00:00:39,510
it exists on github you can fix bugs and

00:00:36,090 --> 00:00:42,059
add stuff to it if you want to I'm born

00:00:39,510 --> 00:00:46,050
in Sweden but I live in Poland with my

00:00:42,059 --> 00:00:48,270
wife daughter cats and fruit trees but I

00:00:46,050 --> 00:00:52,320
work for a company Boston called shoe

00:00:48,270 --> 00:00:54,239
box we make a web app that helps you

00:00:52,320 --> 00:00:56,820
with a lot of the legal documentation

00:00:54,239 --> 00:01:00,180
and the legal paperwork and all this

00:00:56,820 --> 00:01:02,340
kind of stuff for corporations you get

00:01:00,180 --> 00:01:04,650
the elevator pitch up there if you don't

00:01:02,340 --> 00:01:06,990
understand what it says don't worry your

00:01:04,650 --> 00:01:09,900
boss will understand it tell them about

00:01:06,990 --> 00:01:14,159
us we are apparently awesome everybody

00:01:09,900 --> 00:01:17,970
says self but enough about me this is

00:01:14,159 --> 00:01:22,049
old code patterns because Python has

00:01:17,970 --> 00:01:24,780
gained more features over the years and

00:01:22,049 --> 00:01:28,530
some things we used to do make no more

00:01:24,780 --> 00:01:30,720
sense and there's lots of old code out

00:01:28,530 --> 00:01:32,670
there so I'll try to explain why it

00:01:30,720 --> 00:01:35,460
looks like it does and all doesn't mean

00:01:32,670 --> 00:01:38,400
unmaintained if you wrote a library or

00:01:35,460 --> 00:01:40,200
framework that needed support Python 2.4

00:01:38,400 --> 00:01:46,110
you had to write things in a certain way

00:01:40,200 --> 00:01:48,060
and that code still works so therefore

00:01:46,110 --> 00:01:51,240
it doesn't get changed the test passes

00:01:48,060 --> 00:01:53,850
and everything so you may encounter some

00:01:51,240 --> 00:01:56,759
of these in maintained code as well

00:01:53,850 --> 00:01:58,950
there's also old tutorials and old books

00:01:56,759 --> 00:02:01,909
floating around on the internet that

00:01:58,950 --> 00:02:06,119
people still use so they end up using

00:02:01,909 --> 00:02:07,920
and learning these old patterns so if

00:02:06,119 --> 00:02:10,739
you're using these patterns don't feel

00:02:07,920 --> 00:02:13,280
bad I won't judge you let's start with

00:02:10,739 --> 00:02:15,690
dictionaries

00:02:13,280 --> 00:02:21,000
when it comes to dictionary the first

00:02:15,690 --> 00:02:24,750
thing is stop using hash key and in has

00:02:21,000 --> 00:02:26,550
been since 2.2 it's 15 years and if you

00:02:24,750 --> 00:02:30,290
think I'm silly for mentioning this

00:02:26,550 --> 00:02:34,440
because I thought I would be so to speak

00:02:30,290 --> 00:02:37,980
let me present to you a github search so

00:02:34,440 --> 00:02:40,380
when you search for hash key on its hub

00:02:37,980 --> 00:02:42,060
it tends to show up every few minutes or

00:02:40,380 --> 00:02:45,390
so in commits not that people actually

00:02:42,060 --> 00:02:47,940
type hash key and push that but that

00:02:45,390 --> 00:02:50,460
they are maintaining code and adding and

00:02:47,940 --> 00:02:55,080
changing files that is consistently

00:02:50,460 --> 00:02:58,700
using hash key on dictionaries so it's

00:02:55,080 --> 00:03:02,310
pretty common actually I even found this

00:02:58,700 --> 00:03:04,920
but don't worry the actual commit

00:03:02,310 --> 00:03:10,530
replaces hash key with in it's just the

00:03:04,920 --> 00:03:12,660
commit message that got backwards easy

00:03:10,530 --> 00:03:18,690
mistake to make especially if you're a

00:03:12,660 --> 00:03:20,340
dog I'm impressed in those gifts another

00:03:18,690 --> 00:03:22,650
thing you don't need to do is to use the

00:03:20,340 --> 00:03:24,570
keys method when you list over

00:03:22,650 --> 00:03:27,150
dictionaries I don't think this really

00:03:24,570 --> 00:03:29,310
is an old pattern unless maybe you

00:03:27,150 --> 00:03:32,010
needed to do it in Python 1.5 or

00:03:29,310 --> 00:03:33,750
something I don't know but I don't think

00:03:32,010 --> 00:03:35,850
you ever needed to do with in Python 2

00:03:33,750 --> 00:03:37,920
at least this is not as common as has

00:03:35,850 --> 00:03:40,680
keys but there's fair amount of matches

00:03:37,920 --> 00:03:43,800
on get up to this to just skip the keys

00:03:40,680 --> 00:03:46,530
call this code that I showed here that

00:03:43,800 --> 00:03:49,740
from the latest version of Django so you

00:03:46,530 --> 00:03:56,220
go like but it's from a test so it's

00:03:49,740 --> 00:03:58,530
okay this is also fairly common and in

00:03:56,220 --> 00:04:01,920
general if you end up using the keys

00:03:58,530 --> 00:04:05,220
method you're probably not doing it

00:04:01,920 --> 00:04:07,820
exactly right because this creates a

00:04:05,220 --> 00:04:10,860
list of keys which you sometimes need

00:04:07,820 --> 00:04:13,680
but in Python 3 it doesn't create a list

00:04:10,860 --> 00:04:16,620
it creates an iterator so what you

00:04:13,680 --> 00:04:20,190
should do is this this will always make

00:04:16,620 --> 00:04:22,169
a list and if you want to use an

00:04:20,190 --> 00:04:24,330
iterator you should do this but I don't

00:04:22,169 --> 00:04:25,860
know why you would because an iterator

00:04:24,330 --> 00:04:27,539
is for iterating over you

00:04:25,860 --> 00:04:31,139
can iterate over a dictionary without

00:04:27,539 --> 00:04:35,370
using a third film alright enough about

00:04:31,139 --> 00:04:38,879
dictionaries next up sets sets are

00:04:35,370 --> 00:04:44,280
useful they have they're very fast and

00:04:38,879 --> 00:04:47,280
the values have to be unique so that has

00:04:44,280 --> 00:04:49,770
its uses uses but it only appeared in

00:04:47,280 --> 00:04:53,280
Python 2.3 sets so what did you do

00:04:49,770 --> 00:04:58,159
before what do we have otherwise that is

00:04:53,280 --> 00:04:58,159
fast has unique values and faster cuts

00:04:58,340 --> 00:05:05,240
yes dictionary case exactly so I like

00:05:02,370 --> 00:05:09,449
this pattern is also about dictionaries

00:05:05,240 --> 00:05:12,659
this code here makes a list unique by

00:05:09,449 --> 00:05:15,960
putting it into a dictionary with values

00:05:12,659 --> 00:05:18,389
of none for all of the case and then it

00:05:15,960 --> 00:05:22,710
gets a list of keys back so now we have

00:05:18,389 --> 00:05:24,210
made the list unique very useful but

00:05:22,710 --> 00:05:28,620
today of course you would just make a

00:05:24,210 --> 00:05:30,900
set and another usage of dictionaries

00:05:28,620 --> 00:05:33,150
like this that are full of just non

00:05:30,900 --> 00:05:37,080
values is if you want to do very fast

00:05:33,150 --> 00:05:39,539
look ups if you have one list of values

00:05:37,080 --> 00:05:42,029
that we want to check is this list is

00:05:39,539 --> 00:05:46,169
this value in some sort of list of

00:05:42,029 --> 00:05:49,289
values using dictionaries there is

00:05:46,169 --> 00:05:52,979
between 35 and 60 times faster compared

00:05:49,289 --> 00:05:56,779
to lists and this is for a set of 200

00:05:52,979 --> 00:05:59,879
random integers so it's not that big

00:05:56,779 --> 00:06:02,039
selection is a way faster than lists and

00:05:59,879 --> 00:06:04,289
it used to be a pattern that if you

00:06:02,039 --> 00:06:06,479
needed to do this a lot you use the

00:06:04,289 --> 00:06:10,949
dictionary but now of course you would

00:06:06,479 --> 00:06:14,939
use a set so if you're making a lookup

00:06:10,949 --> 00:06:17,969
to see if value X is in a list in

00:06:14,939 --> 00:06:21,120
general you might consider to do is use

00:06:17,969 --> 00:06:22,439
a set instead of a list because sets are

00:06:21,120 --> 00:06:25,560
still faster than tickets

00:06:22,439 --> 00:06:30,800
don't worry okay enough

00:06:25,560 --> 00:06:34,680
now with dictionaries for wheels this is

00:06:30,800 --> 00:06:37,319
upload to github from 2016 I don't know

00:06:34,680 --> 00:06:39,150
if this also has happened in 2017 but

00:06:37,319 --> 00:06:41,610
these are the most relevant

00:06:39,150 --> 00:06:44,340
when you look for a certain bits of code

00:06:41,610 --> 00:06:46,170
when we look for keys and it's uploads

00:06:44,340 --> 00:06:49,620
of the Python cookbook and I checked

00:06:46,170 --> 00:06:53,580
it's not the current edition 3 I think

00:06:49,620 --> 00:06:57,900
it's the Edition 1 maybe 2 but the code

00:06:53,580 --> 00:06:59,700
is most definitely from 2002 so but

00:06:57,900 --> 00:07:03,360
people still use these tutorials

00:06:59,700 --> 00:07:07,590
apparently to me learn Python so the

00:07:03,360 --> 00:07:11,070
code looks like this and it takes a list

00:07:07,590 --> 00:07:14,730
of keys from OS environ sort that and

00:07:11,070 --> 00:07:17,460
prints it out and why would you make a

00:07:14,730 --> 00:07:19,940
list and then sort it well in 2002 this

00:07:17,460 --> 00:07:24,270
was the only way you could sort anything

00:07:19,940 --> 00:07:28,530
the sorted built-in came in 2.4 so now

00:07:24,270 --> 00:07:30,510
we just do this less lines means less

00:07:28,530 --> 00:07:33,450
buttons and this is also more robust

00:07:30,510 --> 00:07:35,700
because sorted can use any sort of uribl

00:07:33,450 --> 00:07:39,030
not just lists so it can take like a

00:07:35,700 --> 00:07:42,900
dictionary in this case or sets to both

00:07:39,030 --> 00:07:44,520
generators whatever even better would be

00:07:42,900 --> 00:07:46,140
if we could do this as a list

00:07:44,520 --> 00:07:49,220
comprehension of course but we can't

00:07:46,140 --> 00:07:52,590
because of the print statement or can we

00:07:49,220 --> 00:07:55,590
we can it's a it's a function in Python

00:07:52,590 --> 00:07:58,470
3 if you're stuck on top Python 2 Wow

00:07:55,590 --> 00:08:03,870
I'm just kidding you can do this in

00:07:58,470 --> 00:08:06,690
Python 2 as well yeah so sorted is

00:08:03,870 --> 00:08:08,850
preferred over using sort on a list

00:08:06,690 --> 00:08:10,950
unless you're absolutely sure it's a

00:08:08,850 --> 00:08:14,010
list it's slightly faster because sort

00:08:10,950 --> 00:08:18,510
that has to create a new list while the

00:08:14,010 --> 00:08:22,190
list sort method sorts in place but the

00:08:18,510 --> 00:08:25,050
difference is about one or two percents

00:08:22,190 --> 00:08:27,090
this sorting pattern however is all

00:08:25,050 --> 00:08:29,550
about speed and you're unlikely to

00:08:27,090 --> 00:08:31,290
therefore encounter it but if you do

00:08:29,550 --> 00:08:34,320
please fix it because your code is going

00:08:31,290 --> 00:08:36,600
to get much faster this is the code that

00:08:34,320 --> 00:08:38,760
is this code is from a book but I have

00:08:36,600 --> 00:08:40,470
anonymized it changed around and change

00:08:38,760 --> 00:08:42,180
the variables so you won't be able to

00:08:40,470 --> 00:08:46,140
find it because it's definitely not from

00:08:42,180 --> 00:08:50,130
2002 so it's a bit embarrassing it's

00:08:46,140 --> 00:08:51,780
sorting things with a key funk not with

00:08:50,130 --> 00:08:54,720
a comparison function

00:08:51,780 --> 00:08:57,510
so it has a lambda that takes two

00:08:54,720 --> 00:09:00,420
arguments and compares them with the

00:08:57,510 --> 00:09:03,050
built in CP function which returns one

00:09:00,420 --> 00:09:05,070
zero minus one to tell you which is

00:09:03,050 --> 00:09:07,680
larger and that's why it looks a little

00:09:05,070 --> 00:09:11,960
strange there and the Lamb that starts

00:09:07,680 --> 00:09:15,120
with a - this is to make a reverse sort

00:09:11,960 --> 00:09:17,190
but a comparison function it compares

00:09:15,120 --> 00:09:20,880
pairs and the longer the list is the

00:09:17,190 --> 00:09:23,910
more pairs there are so long list get

00:09:20,880 --> 00:09:26,490
very many calls per item for 40000 it's

00:09:23,910 --> 00:09:34,410
about eight and a half calls per item

00:09:26,490 --> 00:09:37,530
and it also has two get items so you get

00:09:34,410 --> 00:09:39,540
the six hundred eighty thousand calls to

00:09:37,530 --> 00:09:43,260
get item basically when you use a

00:09:39,540 --> 00:09:45,480
comparison function so in Python 2.4 a

00:09:43,260 --> 00:09:50,280
key function was introduced to both

00:09:45,480 --> 00:09:52,860
sorted and sort and the function now got

00:09:50,280 --> 00:09:54,540
much simpler here the key function is

00:09:52,860 --> 00:09:57,980
just half of the comparison function

00:09:54,540 --> 00:10:02,490
basically and you have a reverse flag

00:09:57,980 --> 00:10:05,670
and statistics is also very different

00:10:02,490 --> 00:10:08,370
you get exactly one call per item always

00:10:05,670 --> 00:10:11,760
so this means that with a comparison

00:10:08,370 --> 00:10:15,510
function on a list of 40,000 items we

00:10:11,760 --> 00:10:20,790
get around 17 times as many calls to get

00:10:15,510 --> 00:10:23,130
item so sorting for 2,000 items takes

00:10:20,790 --> 00:10:25,140
about five times as long with a compare

00:10:23,130 --> 00:10:30,510
function versus the key function so

00:10:25,140 --> 00:10:32,339
please switch to key CMP is generally

00:10:30,510 --> 00:10:34,740
deprecated the built-in was actually

00:10:32,339 --> 00:10:37,700
removed from python 3.0 but it was added

00:10:34,740 --> 00:10:41,880
back in because it does have some news

00:10:37,700 --> 00:10:43,890
so in that goes for dunder cmp as well

00:10:41,880 --> 00:10:47,490
it's deprecated now and ignored in

00:10:43,890 --> 00:10:49,470
python 2 and that we have rich

00:10:47,490 --> 00:10:52,339
comparison functions that are called so

00:10:49,470 --> 00:10:54,720
less than less than equal and so on

00:10:52,339 --> 00:10:57,930
there's plenty of reasons to use this

00:10:54,720 --> 00:11:00,120
instead of dunder CMP because for

00:10:57,930 --> 00:11:00,660
example things may be equal to each

00:11:00,120 --> 00:11:03,410
other

00:11:00,660 --> 00:11:07,790
but not actually sortable

00:11:03,410 --> 00:11:11,000
and then you need to do different kind

00:11:07,790 --> 00:11:14,480
of the implementations here but CMP has

00:11:11,000 --> 00:11:17,810
a big benefit it was only one method

00:11:14,480 --> 00:11:20,240
that under CMP this is six so people

00:11:17,810 --> 00:11:22,520
didn't use it very much so therefore

00:11:20,240 --> 00:11:23,180
they got func tools to come to the

00:11:22,520 --> 00:11:25,910
rescue

00:11:23,180 --> 00:11:28,550
there's a total ordering decorator and

00:11:25,910 --> 00:11:31,720
now you need to implement two equals or

00:11:28,550 --> 00:11:35,080
not equals and one of the other four and

00:11:31,720 --> 00:11:41,090
the this decorator will supply the other

00:11:35,080 --> 00:11:42,980
four methods this pattern is funny this

00:11:41,090 --> 00:11:47,240
is an old one that I've used a lot

00:11:42,980 --> 00:11:49,790
especially in a zpt templates and things

00:11:47,240 --> 00:11:51,800
like this so HTML templates where you

00:11:49,790 --> 00:11:54,980
needed to have an expression you

00:11:51,800 --> 00:11:57,230
couldn't write anything proper it looks

00:11:54,980 --> 00:12:02,120
like a logic expression but it isn't

00:11:57,230 --> 00:12:05,990
it's a sneaky conditional what it means

00:12:02,120 --> 00:12:09,350
to say is that if use blank is true then

00:12:05,990 --> 00:12:11,570
result should be blank value LS result

00:12:09,350 --> 00:12:12,530
should be default but this has a big

00:12:11,570 --> 00:12:15,500
problem

00:12:12,530 --> 00:12:18,530
if blank value is an argument and you

00:12:15,500 --> 00:12:22,460
pass in something that evaluates to

00:12:18,530 --> 00:12:25,610
false result will actually not become

00:12:22,460 --> 00:12:28,850
blank value even if use blank is true it

00:12:25,610 --> 00:12:31,010
will become a default anyway both use

00:12:28,850 --> 00:12:33,980
blank and blank view value has to

00:12:31,010 --> 00:12:36,350
evaluate to true for result to be set to

00:12:33,980 --> 00:12:39,110
blank value and that's a little

00:12:36,350 --> 00:12:42,920
confusing thing that has been many

00:12:39,110 --> 00:12:44,900
people including me so therefore we have

00:12:42,920 --> 00:12:48,470
of course one-line conditional

00:12:44,900 --> 00:12:50,780
expressions now it is result is blank

00:12:48,470 --> 00:12:53,630
value if use blank is true else it's

00:12:50,780 --> 00:12:55,640
default it's a bit confusing because the

00:12:53,630 --> 00:12:59,510
test comes in the middle that's not what

00:12:55,640 --> 00:13:01,490
you used used to but it's usable so this

00:12:59,510 --> 00:13:06,200
is what to do if you absolutely have to

00:13:01,490 --> 00:13:08,690
have a conditional expression okay onto

00:13:06,200 --> 00:13:13,700
something more complex resource handling

00:13:08,690 --> 00:13:15,360
this is a made-up example of a imaginary

00:13:13,700 --> 00:13:19,000
database handler

00:13:15,360 --> 00:13:21,040
just to show an example that is as clear

00:13:19,000 --> 00:13:23,410
as possible of how you had to do

00:13:21,040 --> 00:13:26,079
resource handling ones and it's not very

00:13:23,410 --> 00:13:28,480
readable and one of the big reasons it's

00:13:26,079 --> 00:13:31,329
not very readable is that it has a try

00:13:28,480 --> 00:13:34,959
accept statement inside of a try finally

00:13:31,329 --> 00:13:37,899
excited statement so therefore we start

00:13:34,959 --> 00:13:39,399
a transaction insert stuff commit and if

00:13:37,899 --> 00:13:41,379
something goes wrong we abort the

00:13:39,399 --> 00:13:43,240
transaction and finally we close the

00:13:41,379 --> 00:13:47,829
transaction no matter if it succeeded or

00:13:43,240 --> 00:13:50,410
not this is because in python 2.5 we got

00:13:47,829 --> 00:13:52,779
the change that you could do try accept

00:13:50,410 --> 00:13:55,180
finally before that you had to Ness them

00:13:52,779 --> 00:13:57,550
like this so this is already much better

00:13:55,180 --> 00:14:00,300
and much more readable but even better

00:13:57,550 --> 00:14:05,769
is of course to use a context manager

00:14:00,300 --> 00:14:08,350
that also arrived in python 2.5 so if

00:14:05,769 --> 00:14:11,769
you see these resource handling done

00:14:08,350 --> 00:14:13,389
with try accepts you this is a case

00:14:11,769 --> 00:14:16,810
where you might want to change it

00:14:13,389 --> 00:14:21,250
because this is more stable it's easier

00:14:16,810 --> 00:14:24,399
to get right another way to deallocate

00:14:21,250 --> 00:14:25,689
resources is to use dunder del and this

00:14:24,399 --> 00:14:27,850
was never a good idea

00:14:25,689 --> 00:14:31,029
partly or maybe mainly because vendor

00:14:27,850 --> 00:14:33,160
del is not guaranteed to be cold so that

00:14:31,029 --> 00:14:35,110
means that you can for example if the

00:14:33,160 --> 00:14:39,819
program crashes and things like this end

00:14:35,110 --> 00:14:41,589
up not deallocating the resource and for

00:14:39,819 --> 00:14:43,899
the reason that it was never a good idea

00:14:41,589 --> 00:14:46,059
i thought that the allocating things in

00:14:43,899 --> 00:14:51,360
dunder del would be unusual but I was

00:14:46,059 --> 00:14:54,279
wrong there's tons of dunder Del's in

00:14:51,360 --> 00:14:56,439
github if you search for them and I

00:14:54,279 --> 00:14:59,110
think it's Java and C++ people who start

00:14:56,439 --> 00:15:01,540
writing Python and they just assume that

00:14:59,110 --> 00:15:04,180
you should do the same thing because

00:15:01,540 --> 00:15:06,129
that makes sense but you should you

00:15:04,180 --> 00:15:08,079
should use a context manager if you use

00:15:06,129 --> 00:15:10,959
Gunter Dale that's one thing you should

00:15:08,079 --> 00:15:13,420
change on the topic of context managers

00:15:10,959 --> 00:15:16,569
I would like to mention that unit tests

00:15:13,420 --> 00:15:19,300
assert races that is always a little bit

00:15:16,569 --> 00:15:22,779
tricky to get right is a context manager

00:15:19,300 --> 00:15:25,089
in Python 2.7 and later so that's much

00:15:22,779 --> 00:15:27,910
nicer way to operating it much clearer

00:15:25,089 --> 00:15:30,889
or understanding what it does

00:15:27,910 --> 00:15:32,720
good way of using an context manager

00:15:30,889 --> 00:15:36,290
that doesn't actually deal with

00:15:32,720 --> 00:15:38,089
resources also temporary file and named

00:15:36,290 --> 00:15:40,759
temporary file icons the context

00:15:38,089 --> 00:15:42,619
managers in Python 2.7 never forget to

00:15:40,759 --> 00:15:45,589
delete the dev temporary file again and

00:15:42,619 --> 00:15:47,689
in Python 3.2 and later you also have

00:15:45,589 --> 00:15:51,069
temporary directory which we have here

00:15:47,689 --> 00:15:51,069
which is very nice

00:15:51,970 --> 00:16:01,610
next patterns are about generators

00:15:56,809 --> 00:16:04,040
I like generators when I worked with

00:16:01,610 --> 00:16:06,019
clone I sometimes needed to do

00:16:04,040 --> 00:16:09,860
migrations and the migration tool in

00:16:06,019 --> 00:16:12,439
flown is creating a long list of nested

00:16:09,860 --> 00:16:16,879
generators which is really fun to write

00:16:12,439 --> 00:16:19,999
but hard to debug but it's cool

00:16:16,879 --> 00:16:22,189
I like generators but you ended up

00:16:19,999 --> 00:16:24,499
writing a lot of this code right where

00:16:22,189 --> 00:16:26,089
you just delegate to sub generator and

00:16:24,499 --> 00:16:29,360
just field back to the code

00:16:26,089 --> 00:16:31,999
well in Python 3.3 and later you don't

00:16:29,360 --> 00:16:35,569
have to you can just do yield from which

00:16:31,999 --> 00:16:39,829
is very nice so once again slack on

00:16:35,569 --> 00:16:42,319
Python 2 but this is not the only thing

00:16:39,829 --> 00:16:45,170
that yield from does it also changes how

00:16:42,319 --> 00:16:46,999
you do use co-routines but co-routines

00:16:45,170 --> 00:16:49,220
really require their own talk and I'm

00:16:46,999 --> 00:16:51,019
not the right guy to do that the most

00:16:49,220 --> 00:16:54,199
important thing to know is that without

00:16:51,019 --> 00:16:57,019
yield from it's very hard to yield from

00:16:54,199 --> 00:16:58,670
a sub co-routine in a co routine it

00:16:57,019 --> 00:17:01,550
apparently crates

00:16:58,670 --> 00:17:03,470
needs a lot of code and I try to then

00:17:01,550 --> 00:17:05,870
bring up the old pattern here how you

00:17:03,470 --> 00:17:08,240
were supposed to do with before yield

00:17:05,870 --> 00:17:10,760
from but I can't find anything it's so

00:17:08,240 --> 00:17:13,189
hard that as soon as yield from appeared

00:17:10,760 --> 00:17:15,589
everybody who actually used co-routines

00:17:13,189 --> 00:17:19,760
switched to you in front so there's like

00:17:15,589 --> 00:17:21,799
no codecs that exists anymore but on the

00:17:19,760 --> 00:17:23,480
topic of generators and co-routines I

00:17:21,799 --> 00:17:28,399
should warn for a backwards incompatible

00:17:23,480 --> 00:17:31,360
change in Python 3.7 and for that I

00:17:28,399 --> 00:17:33,919
should explain anything about iterators

00:17:31,360 --> 00:17:35,840
iterators is any object with the next

00:17:33,919 --> 00:17:38,529
method you signal the end of the

00:17:35,840 --> 00:17:41,360
iteration by raising stop iteration it

00:17:38,529 --> 00:17:42,919
feels a bit weird to raising insects

00:17:41,360 --> 00:17:44,390
exception to do something that's not

00:17:42,919 --> 00:17:47,450
wrong but that's how it works

00:17:44,390 --> 00:17:49,429
and since generators are sort of fancy

00:17:47,450 --> 00:17:51,590
iterators you should brace stop

00:17:49,429 --> 00:17:56,929
iteration as well to stop the generator

00:17:51,590 --> 00:17:59,029
right wrong these works and there's

00:17:56,929 --> 00:18:02,779
plenty of code out there that's done it

00:17:59,029 --> 00:18:06,500
and I have done it myself because if you

00:18:02,779 --> 00:18:08,779
return from a generator with a value it

00:18:06,500 --> 00:18:10,250
says you can't return with the value and

00:18:08,779 --> 00:18:12,799
then something in your brain this

00:18:10,250 --> 00:18:14,450
happened not only to me but also to one

00:18:12,799 --> 00:18:16,190
of my company something in brain goes

00:18:14,450 --> 00:18:18,440
all you're not supposed to use return in

00:18:16,190 --> 00:18:26,000
generators but you are supposed to use

00:18:18,440 --> 00:18:30,320
return in generators to to six-piece so

00:18:26,000 --> 00:18:33,440
in Python three point seven generator

00:18:30,320 --> 00:18:36,289
with raising stock per iteration in it

00:18:33,440 --> 00:18:38,690
will cause a runtime error and you

00:18:36,289 --> 00:18:41,960
should use return instead this will

00:18:38,690 --> 00:18:44,720
actually return stop iteration so but

00:18:41,960 --> 00:18:47,600
there's magic pixie dust going on to be

00:18:44,720 --> 00:18:50,539
able to return values which you need to

00:18:47,600 --> 00:18:54,139
do when you do co-routines again so this

00:18:50,539 --> 00:18:56,870
is covert team pep 479 which flashed by

00:18:54,139 --> 00:19:00,889
there that's the details if you want to

00:18:56,870 --> 00:19:02,960
know more yeah so if you want to use

00:19:00,889 --> 00:19:06,309
coal routines you really need to be in

00:19:02,960 --> 00:19:09,470
Python 3 that's the end result of that

00:19:06,309 --> 00:19:12,139
and here is the prehistoric pattern that

00:19:09,470 --> 00:19:15,380
actually started this talk concatenating

00:19:12,139 --> 00:19:18,049
strings by joining an empty string this

00:19:15,380 --> 00:19:20,510
is an example from gendell I did a

00:19:18,049 --> 00:19:23,120
shorter version of this talk on Jenga

00:19:20,510 --> 00:19:26,149
cone EU in Warsaw several years ago and

00:19:23,120 --> 00:19:28,639
they fixed most of the things during

00:19:26,149 --> 00:19:31,490
that talk they actually changed it and

00:19:28,639 --> 00:19:33,350
committed so I was very happy to see

00:19:31,490 --> 00:19:35,600
that they didn't fix this this this

00:19:33,350 --> 00:19:36,399
thing exists it's in still in the latest

00:19:35,600 --> 00:19:38,750
version of jungle

00:19:36,399 --> 00:19:40,820
it's obviously old code they have a

00:19:38,750 --> 00:19:43,309
variable called bytes so it's from

00:19:40,820 --> 00:19:45,740
python 2.5 or earlier that's one way it

00:19:43,309 --> 00:19:48,889
was written so why aren't they just

00:19:45,740 --> 00:19:51,470
doing this well you used to hear people

00:19:48,889 --> 00:19:53,120
say that concatenating strings with Plus

00:19:51,470 --> 00:19:54,830
that slow don't do that

00:19:53,120 --> 00:19:59,360
to use it joint

00:19:54,830 --> 00:20:01,910
but after python 2.5 there's no

00:19:59,360 --> 00:20:05,270
optimizations so you can do Plus now

00:20:01,910 --> 00:20:08,480
that's what I was told in python 2.5 and

00:20:05,270 --> 00:20:12,680
2.6 times back in the old days but I

00:20:08,480 --> 00:20:14,600
benchmarked it and using plus was always

00:20:12,680 --> 00:20:16,520
faster than join which isn't strange

00:20:14,600 --> 00:20:19,280
because you have to create the whole a

00:20:16,520 --> 00:20:22,490
tuple or a list for this and then join

00:20:19,280 --> 00:20:25,190
it using join was never faster so what

00:20:22,490 --> 00:20:26,240
is this claim come from I think it's a

00:20:25,190 --> 00:20:29,450
misunderstanding

00:20:26,240 --> 00:20:32,300
this sort of code is slow you're looping

00:20:29,450 --> 00:20:34,790
over a list of strings and you're making

00:20:32,300 --> 00:20:38,330
a long list out of that list of strings

00:20:34,790 --> 00:20:43,100
in a loop or this it's much much faster

00:20:38,330 --> 00:20:46,330
it's around two times faster

00:20:43,100 --> 00:20:46,330
except on pi PI

00:20:48,820 --> 00:20:53,150
but I discovered something interesting

00:20:50,870 --> 00:20:55,669
here if you're actually generating the

00:20:53,150 --> 00:20:59,690
strings that you are adding into the

00:20:55,669 --> 00:21:01,760
loop versus creating a list and then

00:20:59,690 --> 00:21:04,250
joining that list which is what I've

00:21:01,760 --> 00:21:05,510
always been doing because join is faster

00:21:04,250 --> 00:21:09,880
when it's a long list

00:21:05,510 --> 00:21:12,169
well then plus is faster than join again

00:21:09,880 --> 00:21:13,669
which is really strange to me and I

00:21:12,169 --> 00:21:15,710
don't know why that is but that must be

00:21:13,669 --> 00:21:18,770
some sort of magic optimization but it

00:21:15,710 --> 00:21:21,020
was already thing and Python 2.4 but

00:21:18,770 --> 00:21:23,929
this is with native strings so it's byte

00:21:21,020 --> 00:21:27,919
strings on Python 2 unicode on python 3

00:21:23,929 --> 00:21:32,659
if we switch this around join is faster

00:21:27,919 --> 00:21:33,620
than + again a lot so this is fairly

00:21:32,659 --> 00:21:35,570
unintuitive

00:21:33,620 --> 00:21:39,110
and I think the conclusion of this is

00:21:35,570 --> 00:21:41,390
that you shouldn't do premature

00:21:39,110 --> 00:21:46,700
optimization always test your code

00:21:41,390 --> 00:21:48,890
that's really the conclusion and this

00:21:46,700 --> 00:21:50,840
pattern was suggested to me that I

00:21:48,890 --> 00:21:52,640
should bring up and I was gonna do it

00:21:50,840 --> 00:21:56,330
because it has to do with where you

00:21:52,640 --> 00:21:59,059
calculate constants in a loop because I

00:21:56,330 --> 00:22:01,220
thought it was silly but it isn't

00:21:59,059 --> 00:22:01,669
because I benchmark it and it's kind of

00:22:01,220 --> 00:22:04,760
funny

00:22:01,669 --> 00:22:07,010
so I'm calculating this constant outside

00:22:04,760 --> 00:22:08,899
of the loop instead of doing it inside

00:22:07,010 --> 00:22:10,880
of the loop and obviously that should be

00:22:08,899 --> 00:22:13,100
faster right because I don't need to do

00:22:10,880 --> 00:22:15,260
this calculation while the claim is that

00:22:13,100 --> 00:22:18,380
you don't have to bother about this

00:22:15,260 --> 00:22:20,450
anymore because C Python will find that

00:22:18,380 --> 00:22:22,370
this calculation is done that is

00:22:20,450 --> 00:22:25,549
constant and it will actually do it

00:22:22,370 --> 00:22:28,640
outside of the loop for you so I checked

00:22:25,549 --> 00:22:33,740
and indeed yes it does this is since

00:22:28,640 --> 00:22:36,049
python 2.5 it's it's now actually finds

00:22:33,740 --> 00:22:39,770
this and optimizes it away so is it an

00:22:36,049 --> 00:22:42,559
old pattern well maybe not because if

00:22:39,770 --> 00:22:46,880
you have a division Python 2.7 gets slow

00:22:42,559 --> 00:22:49,789
again python 3.6 will still find this

00:22:46,880 --> 00:22:51,590
and pi pi will find it but of course

00:22:49,789 --> 00:22:54,200
this is the stupid example right you

00:22:51,590 --> 00:22:55,670
could replace the code with Len of the

00:22:54,200 --> 00:23:00,430
iterable and times

00:22:55,670 --> 00:23:04,640
17 and a half which is 250 times as fast

00:23:00,430 --> 00:23:08,090
so mate we'll make some example that is

00:23:04,640 --> 00:23:12,530
not quite as tasked so the in this case

00:23:08,090 --> 00:23:15,260
the value that we add to result for

00:23:12,530 --> 00:23:19,000
every time is depending both on a local

00:23:15,260 --> 00:23:22,880
variable a var and on the loop variable

00:23:19,000 --> 00:23:27,050
each in this case so this is more

00:23:22,880 --> 00:23:29,480
realistic of what you would do and now

00:23:27,050 --> 00:23:33,860
the optimization also disappears on C

00:23:29,480 --> 00:23:37,520
Python 3 pi PI still succeeds in

00:23:33,860 --> 00:23:41,630
optimizing this unless you have a power

00:23:37,520 --> 00:23:44,060
in the calculation of the constant we're

00:23:41,630 --> 00:23:48,200
calculating it outside of the loop now

00:23:44,060 --> 00:23:52,910
gets to be a lot faster 30 times on pi

00:23:48,200 --> 00:23:54,710
pi 5.4 and on pi PI five point five it's

00:23:52,910 --> 00:23:58,130
just two times again which is really

00:23:54,710 --> 00:24:00,740
funny so this pattern turns out to not

00:23:58,130 --> 00:24:03,500
be prehistoric after all you should

00:24:00,740 --> 00:24:07,370
calculate constants out of the loop just

00:24:03,500 --> 00:24:10,610
as everybody assumes that you should and

00:24:07,370 --> 00:24:14,750
that's really my conclusion and my

00:24:10,610 --> 00:24:20,810
takeaway from this talk you should not

00:24:14,750 --> 00:24:24,500
only pop not prematurely optimize your

00:24:20,810 --> 00:24:27,800
code as one and two python is awesome

00:24:24,500 --> 00:24:30,800
because it's intuitive the code you

00:24:27,800 --> 00:24:34,130
think should be the fastest and most

00:24:30,800 --> 00:24:36,740
reasonable to do is generally the

00:24:34,130 --> 00:24:41,060
fastest and most recent reasonable to do

00:24:36,740 --> 00:24:44,960
with some few exceptions and the

00:24:41,060 --> 00:24:47,210
intuitiveness of Python is one of the

00:24:44,960 --> 00:24:50,720
things that I really like of it about it

00:24:47,210 --> 00:25:01,169
and makes it really really cool

00:24:50,720 --> 00:25:02,340
thank you that's all hello thanks Leno

00:25:01,169 --> 00:25:04,169
aye

00:25:02,340 --> 00:25:06,510
if you have a question for Lana please

00:25:04,169 --> 00:25:09,799
line up behind one of these microphones

00:25:06,510 --> 00:25:09,799
here in the aisle

00:25:14,899 --> 00:25:24,059
that's a no click it's over on my left

00:25:17,610 --> 00:25:28,470
ah there I can have the left microphone

00:25:24,059 --> 00:25:33,450
on play okay my favorite of these is for

00:25:28,470 --> 00:25:36,120
VAR in X range something and then you do

00:25:33,450 --> 00:25:38,760
something with var which almost always

00:25:36,120 --> 00:25:43,409
should be done elsewise is there a

00:25:38,760 --> 00:25:45,840
reason you didn't include this I I don't

00:25:43,409 --> 00:25:47,730
really understand with you or excuse me

00:25:45,840 --> 00:25:49,260
just a moment up people can we please

00:25:47,730 --> 00:25:52,760
not walking at the moment this talk is

00:25:49,260 --> 00:25:55,950
still finishing up thank you very much

00:25:52,760 --> 00:26:00,059
so if you do 4x range instead of doing

00:25:55,950 --> 00:26:03,690
range you mean no I mean almost always

00:26:00,059 --> 00:26:06,690
if you look at the code what they're

00:26:03,690 --> 00:26:10,980
doing with the constant is using it as

00:26:06,690 --> 00:26:12,630
an index and oh yeah right no I didn't

00:26:10,980 --> 00:26:17,250
include that because that's not really

00:26:12,630 --> 00:26:18,980
an old pattern as doing 4x in range of

00:26:17,250 --> 00:26:22,980
something and then doing a

00:26:18,980 --> 00:26:26,730
multiplication or using like using it in

00:26:22,980 --> 00:26:28,049
maths at least can usually be optimized

00:26:26,730 --> 00:26:30,179
the way that you can just do this

00:26:28,049 --> 00:26:32,700
calculation in some better way than

00:26:30,179 --> 00:26:34,500
looping over variable and quite often

00:26:32,700 --> 00:26:38,279
when it comes to indexes as well that

00:26:34,500 --> 00:26:40,649
you can you can maybe make a slice to

00:26:38,279 --> 00:26:42,659
get the things out to do some more

00:26:40,649 --> 00:26:45,590
something else yeah so that's not really

00:26:42,659 --> 00:26:49,019
an old pattern it's just a bad pattern

00:26:45,590 --> 00:26:51,000
so am i right here yeah all right so you

00:26:49,019 --> 00:26:55,220
mentioned the del isn't actually a

00:26:51,000 --> 00:26:59,580
destructor when is del called del is

00:26:55,220 --> 00:27:02,309
theoretically called when the object is

00:26:59,580 --> 00:27:04,200
D allocated that's that's when it's

00:27:02,309 --> 00:27:06,720
supposed to be called

00:27:04,200 --> 00:27:09,480
and I know that in early Python versions

00:27:06,720 --> 00:27:12,929
I was able to make Python not called

00:27:09,480 --> 00:27:14,369
Dell but in the latest versions I

00:27:12,929 --> 00:27:16,259
haven't been able to do that so I

00:27:14,369 --> 00:27:18,239
couldn't show code that consistently

00:27:16,259 --> 00:27:22,289
they or at least sometimes didn't call

00:27:18,239 --> 00:27:24,659
Dell but the recommendation was always a

00:27:22,289 --> 00:27:26,730
nice apparently always the Dell is not

00:27:24,659 --> 00:27:31,950
guaranteed to be cold so don't do things

00:27:26,730 --> 00:27:35,850
you have to do their follow-up to Jack's

00:27:31,950 --> 00:27:37,859
question Leslie so in the docs we

00:27:35,850 --> 00:27:39,929
actually suggest that people not use

00:27:37,859 --> 00:27:41,669
under Dell I've also heard that under

00:27:39,929 --> 00:27:43,739
Dell is also called when the ref count

00:27:41,669 --> 00:27:46,109
of the object goes to zero the truth

00:27:43,739 --> 00:27:48,179
basically well yeah that should probably

00:27:46,109 --> 00:27:50,549
be more or less the same thing yeah the

00:27:48,179 --> 00:27:52,169
rest count goes to zero it should be you

00:27:50,549 --> 00:27:54,659
call Dell and then the allocate the

00:27:52,169 --> 00:27:56,999
object that's how I understand it I

00:27:54,659 --> 00:27:59,100
haven't read that code so can I be

00:27:56,999 --> 00:28:01,590
hundred percent sure but that's the

00:27:59,100 --> 00:28:04,049
principle yeah okay now for my real

00:28:01,590 --> 00:28:06,029
question which is based on the

00:28:04,049 --> 00:28:07,710
performance measurements do you find any

00:28:06,029 --> 00:28:10,259
kind of difference when comparing off of

00:28:07,710 --> 00:28:12,809
a POSIX compliant system like Mac OS

00:28:10,259 --> 00:28:16,739
Linux vs. like Windows and something no

00:28:12,809 --> 00:28:21,840
I I didn't I don't have a good window

00:28:16,739 --> 00:28:24,450
system - sorry I only said with this

00:28:21,840 --> 00:28:28,289
unknown Linux yeah okay all right thank

00:28:24,450 --> 00:28:29,909
you last questions Thanks you showed

00:28:28,289 --> 00:28:31,679
that example of a list comprehension

00:28:29,909 --> 00:28:33,359
with print statements in it attack

00:28:31,679 --> 00:28:35,820
side-effects would you say that's a

00:28:33,359 --> 00:28:36,509
pattern we can now use now we're for

00:28:35,820 --> 00:28:38,609
debugging

00:28:36,509 --> 00:28:42,059
I was always going to almost gonna

00:28:38,609 --> 00:28:44,159
mention that but I didn't decide that I

00:28:42,059 --> 00:28:45,779
didn't have time yeah yeah you can you

00:28:44,159 --> 00:28:47,429
can do that if you want to debug but on

00:28:45,779 --> 00:28:51,629
the other hand you can do pretty print

00:28:47,429 --> 00:28:56,039
as well so it's not really a big thing

00:28:51,629 --> 00:28:59,149
um I I can't really think of a case

00:28:56,039 --> 00:29:02,220
where I would use it in production code

00:28:59,149 --> 00:29:04,769
because then I would use typically log

00:29:02,220 --> 00:29:08,429
instead to get the variables out to the

00:29:04,769 --> 00:29:10,350
right place yeah kou and that is all the

00:29:08,429 --> 00:29:13,249
time we have everybody please thank Lana

00:29:10,350 --> 00:29:13,249

YouTube URL: https://www.youtube.com/watch?v=V5-JH23Vk0I


