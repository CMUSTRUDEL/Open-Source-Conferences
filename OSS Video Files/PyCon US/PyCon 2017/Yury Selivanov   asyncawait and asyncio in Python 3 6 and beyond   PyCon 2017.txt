Title: Yury Selivanov   asyncawait and asyncio in Python 3 6 and beyond   PyCon 2017
Publication date: 2017-05-21
Playlist: PyCon 2017
Description: 
	"Speaker: Yury Selivanov

The talk overviews async/await, asynchronous generators and comprehensions in Python 3.6 and the asyncio module. We'll discuss when and how asyncio should be used in a modern applications and services, what is uvloop, and what asyncio frameworks and libraries one should use. I'll share our ideas about where asyncio is headed and what to expect in Python 3.7.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:02,300 --> 00:00:09,389
good afternoon everybody and welcome to

00:00:05,040 --> 00:00:10,920
this session of Pike on 2017 before we

00:00:09,389 --> 00:00:12,750
get started I would like to encourage

00:00:10,920 --> 00:00:14,969
everyone with a device that is capable

00:00:12,750 --> 00:00:18,000
of making noise to please have a chat

00:00:14,969 --> 00:00:19,410
with it and ask it not to because when

00:00:18,000 --> 00:00:21,029
it does everyone's going to stare at you

00:00:19,410 --> 00:00:23,180
and some people might be nasty to you on

00:00:21,029 --> 00:00:25,800
Twitter

00:00:23,180 --> 00:00:27,510
with that said I would like to introduce

00:00:25,800 --> 00:00:29,010
our next speaker his name is Yuri

00:00:27,510 --> 00:00:30,869
Sullivan off and you will be talking

00:00:29,010 --> 00:00:32,450
about a sink and a weight and a sink IO

00:00:30,869 --> 00:00:40,360
please make him welcome

00:00:32,450 --> 00:00:43,550
[Applause]

00:00:40,360 --> 00:00:46,010
hi I'm your reseller honest I'm from

00:00:43,550 --> 00:00:48,800
Toronto Canada today we're going to talk

00:00:46,010 --> 00:00:51,230
about async await and async i/o in

00:00:48,800 --> 00:00:55,640
Python 36 and beyond feel free to follow

00:00:51,230 --> 00:00:58,879
me on Twitter and email at why why at

00:00:55,640 --> 00:01:03,019
magic gotaga so quickly about me I'm

00:00:58,879 --> 00:01:05,449
core developers since 2013 worked on a

00:01:03,019 --> 00:01:08,509
number of peps mostly about async and

00:01:05,449 --> 00:01:11,780
the weight I maintain a sink I owe you a

00:01:08,509 --> 00:01:14,960
loop and a sink eg I work at magic

00:01:11,780 --> 00:01:19,880
stacks check out our website magic dot

00:01:14,960 --> 00:01:24,710
IO we do a lot of stuff with Python for

00:01:19,880 --> 00:01:27,380
Python and sometimes to Python pretty

00:01:24,710 --> 00:01:31,880
interesting so let's talk about async

00:01:27,380 --> 00:01:34,130
await and the first question is why do

00:01:31,880 --> 00:01:36,110
we even have it because there are so

00:01:34,130 --> 00:01:37,970
many other ways how you can do

00:01:36,110 --> 00:01:41,300
concurrency for instance you can do

00:01:37,970 --> 00:01:44,570
threads or you can code with callbacks

00:01:41,300 --> 00:01:47,420
and promises or maybe you can do G

00:01:44,570 --> 00:01:50,689
events or use event land or stackless

00:01:47,420 --> 00:01:54,229
python or maybe you could just use

00:01:50,689 --> 00:01:56,030
generators with guilt from syntax and

00:01:54,229 --> 00:01:58,789
the answer is readability

00:01:56,030 --> 00:02:00,700
it's an arguably better than cold books

00:01:58,789 --> 00:02:03,590
or promises I think anybody could try to

00:02:00,700 --> 00:02:05,990
debug will refactor some JavaScript or

00:02:03,590 --> 00:02:09,170
old Python code with a lot of nested

00:02:05,990 --> 00:02:12,130
callbacks can attest to that it's easier

00:02:09,170 --> 00:02:15,920
to reason about the async await code

00:02:12,130 --> 00:02:18,380
they just see all those explicit points

00:02:15,920 --> 00:02:21,530
in your code when you can switch context

00:02:18,380 --> 00:02:23,630
for i/o or for something else and it

00:02:21,530 --> 00:02:27,290
actually promotes very patterns like

00:02:23,630 --> 00:02:29,750
message passing and not having global

00:02:27,290 --> 00:02:32,150
shared data structures because no matter

00:02:29,750 --> 00:02:34,670
what you think about your ability to

00:02:32,150 --> 00:02:37,160
write multi-threading code you will

00:02:34,670 --> 00:02:41,769
inevitably end up having situation the

00:02:37,160 --> 00:02:45,109
right side any other reasons well

00:02:41,769 --> 00:02:48,210
efficiency since we have this little

00:02:45,109 --> 00:02:52,110
problem in Python called Gil

00:02:48,210 --> 00:02:54,660
traps aren't always the answer but even

00:02:52,110 --> 00:02:55,860
in the languages like C sharp where

00:02:54,660 --> 00:02:58,350
there is no Gil

00:02:55,860 --> 00:03:01,530
we still have Asian Kuwait why is

00:02:58,350 --> 00:03:03,720
because threads are a system resource

00:03:01,530 --> 00:03:07,800
you cannot have an infinite number of

00:03:03,720 --> 00:03:09,660
tails so with a think we can have we can

00:03:07,800 --> 00:03:12,090
handle thousands or hundreds of

00:03:09,660 --> 00:03:14,010
thousands or sometimes millions of open

00:03:12,090 --> 00:03:18,620
long lengths and connections on the

00:03:14,010 --> 00:03:22,380
server anyways what is async/await

00:03:18,620 --> 00:03:24,570
well obviously is a syntax we edit them

00:03:22,380 --> 00:03:26,910
first in PI template files and where the

00:03:24,570 --> 00:03:30,440
syntax to define co-routines or async

00:03:26,910 --> 00:03:33,510
functions syntax for asynchronous

00:03:30,440 --> 00:03:36,780
context managers asynchronous iterators

00:03:33,510 --> 00:03:37,710
and obviously a weight expression in

00:03:36,780 --> 00:03:40,200
three six

00:03:37,710 --> 00:03:43,080
we took it even further we now have a

00:03:40,200 --> 00:03:45,180
synchronous generators asynchronous list

00:03:43,080 --> 00:03:47,820
comprehensions and even asynchronous

00:03:45,180 --> 00:03:52,110
generator expressions and I'd say that

00:03:47,820 --> 00:03:54,240
at this point we have almost complete

00:03:52,110 --> 00:03:57,630
coverage of whatever you can do in

00:03:54,240 --> 00:04:01,110
Python synchronous mode you can do it

00:03:57,630 --> 00:04:03,360
with async await except one thing this

00:04:01,110 --> 00:04:06,270
is yield from yield from for a

00:04:03,360 --> 00:04:09,330
synchronous generators we might add

00:04:06,270 --> 00:04:10,680
syntax for yield from in three seven but

00:04:09,330 --> 00:04:14,520
this is not a top priority I'll be

00:04:10,680 --> 00:04:17,730
honest with you what else is facing is

00:04:14,520 --> 00:04:20,970
async await it's a protocol there is a

00:04:17,730 --> 00:04:23,190
common misconception that async await

00:04:20,970 --> 00:04:27,060
was created specifically for async i/o

00:04:23,190 --> 00:04:29,940
or only a think I can use it and this is

00:04:27,060 --> 00:04:32,400
not true in certainly async await based

00:04:29,940 --> 00:04:35,550
on the rated protocol we have a bunch of

00:04:32,400 --> 00:04:37,920
magic methods like Dondre weight which

00:04:35,550 --> 00:04:40,320
allows you to make an object of a table

00:04:37,920 --> 00:04:42,390
or using an await expression we have

00:04:40,320 --> 00:04:45,060
magic methods to define and create

00:04:42,390 --> 00:04:48,560
asynchronous iterators and asynchronous

00:04:45,060 --> 00:04:50,850
context managers so it's pretty generic

00:04:48,560 --> 00:04:54,060
you could totally write your own

00:04:50,850 --> 00:04:56,280
framework for async await but you

00:04:54,060 --> 00:04:58,730
probably shouldn't it's a lot of work

00:04:56,280 --> 00:05:01,440
unless you want to experiment of course

00:04:58,730 --> 00:05:02,429
so you take a look at modern async await

00:05:01,440 --> 00:05:05,610
application

00:05:02,429 --> 00:05:07,889
there is a stack and at the bottom of

00:05:05,610 --> 00:05:10,469
the stack is operating system of course

00:05:07,889 --> 00:05:12,479
then the COS Python interpreter and then

00:05:10,469 --> 00:05:16,879
we have a scene framework the tornado

00:05:12,479 --> 00:05:20,689
twisted fury trio or maybe a TKO and

00:05:16,879 --> 00:05:24,869
then we have a application framework

00:05:20,689 --> 00:05:25,169
maybe it's a HTTP or sanic or something

00:05:24,869 --> 00:05:28,319
else

00:05:25,169 --> 00:05:30,539
jungle flasks if they have ever eaten

00:05:28,319 --> 00:05:34,499
connect versions and only then you have

00:05:30,539 --> 00:05:36,719
your applications so what kind of

00:05:34,499 --> 00:05:40,619
frameworks do we have the good news is

00:05:36,719 --> 00:05:44,399
that twisted and tornado can use async

00:05:40,619 --> 00:05:47,519
await syntax today and twisted is

00:05:44,399 --> 00:05:51,029
actually model facing in Python are so

00:05:47,519 --> 00:05:53,759
much originated from twisted and I think

00:05:51,029 --> 00:05:57,449
no one even knows how all twisted is now

00:05:53,759 --> 00:06:00,059
but it can use async await now and both

00:05:57,449 --> 00:06:02,849
twisted and tornado have a big

00:06:00,059 --> 00:06:06,179
ecosystems and maybe what's even more

00:06:02,849 --> 00:06:08,279
important they have a big mind share so

00:06:06,179 --> 00:06:12,319
there are lots and lots of questions on

00:06:08,279 --> 00:06:12,319
Stack Overflow and sometimes answers

00:06:14,970 --> 00:06:21,879
tornado today and twist it very soon

00:06:18,970 --> 00:06:24,009
maybe tomorrow we'll be able to run on

00:06:21,879 --> 00:06:26,979
top of a Chevelle and what it means is

00:06:24,009 --> 00:06:30,849
that you can call a thinker libraries

00:06:26,979 --> 00:06:33,129
from your tornado code or maybe soon

00:06:30,849 --> 00:06:35,620
from your twisted code or maybe you'll

00:06:33,129 --> 00:06:37,690
be able to use twisted libraries you

00:06:35,620 --> 00:06:40,990
should have which we have a lot in your

00:06:37,690 --> 00:06:44,650
async code so this is this is quite good

00:06:40,990 --> 00:06:47,169
we also have Kurian trio those are two

00:06:44,650 --> 00:06:50,500
new kids on the block both try to

00:06:47,169 --> 00:06:53,020
explore in your approaches both try to

00:06:50,500 --> 00:06:58,569
make async easier and maybe sometimes

00:06:53,020 --> 00:07:00,729
safer to use and of course if they find

00:06:58,569 --> 00:07:02,650
something you were new useful patterns

00:07:00,729 --> 00:07:05,250
or good ideas will kill them and put

00:07:02,650 --> 00:07:10,389
them in Asian ko that that I can promise

00:07:05,250 --> 00:07:14,409
both are not mainstream yet cure is like

00:07:10,389 --> 00:07:17,919
here and a half years old trio is is a

00:07:14,409 --> 00:07:19,930
few months it's really good projects and

00:07:17,919 --> 00:07:21,849
I really encourage you to take a look at

00:07:19,930 --> 00:07:25,810
them and to explore how they are

00:07:21,849 --> 00:07:27,400
implemented in the inside it's quite an

00:07:25,810 --> 00:07:30,669
interesting take how you should do a

00:07:27,400 --> 00:07:34,380
sink or can do a sink but not mainstream

00:07:30,669 --> 00:07:37,779
yet anyways let's talk about a sink i/o

00:07:34,380 --> 00:07:41,080
so what is a single isn't clear is first

00:07:37,779 --> 00:07:45,729
of all a foundation it defines low level

00:07:41,080 --> 00:07:48,130
api's high level 18:08 DPI's it is here

00:07:45,729 --> 00:07:49,050
to stay and it has a pluggable event

00:07:48,130 --> 00:07:52,330
loop

00:07:49,050 --> 00:07:54,630
so what others low-level idea is that of

00:07:52,330 --> 00:07:58,300
course starts to schedule callbacks to

00:07:54,630 --> 00:08:01,029
write protocols with transfers to the

00:07:58,300 --> 00:08:04,599
network sub processes handle unique

00:08:01,029 --> 00:08:07,840
signals all callback based all very low

00:08:04,599 --> 00:08:09,789
level but this is actually a good thing

00:08:07,840 --> 00:08:11,919
to have because it allows us to

00:08:09,789 --> 00:08:14,349
integrate this other low level code

00:08:11,919 --> 00:08:18,430
written in languages like C C++ and

00:08:14,349 --> 00:08:21,159
others on top of that it has async/await

00:08:18,430 --> 00:08:22,630
to run co-routines and also to the

00:08:21,159 --> 00:08:23,889
streams and sockets the network

00:08:22,630 --> 00:08:26,319
programming

00:08:23,889 --> 00:08:28,919
subprocesses youth walks if you like

00:08:26,319 --> 00:08:31,330
deadlocks time out constellations

00:08:28,919 --> 00:08:34,810
everything that is handled in a Chicago

00:08:31,330 --> 00:08:38,019
it has all the tools it is mainstream

00:08:34,810 --> 00:08:40,360
starting with Python 3.6 it's no longer

00:08:38,019 --> 00:08:43,000
provisional it's under standard library

00:08:40,360 --> 00:08:44,410
and this is a promise from for

00:08:43,000 --> 00:08:46,450
development community from Python

00:08:44,410 --> 00:08:50,980
community that Asian kayo is a safe

00:08:46,450 --> 00:08:54,519
foundation to bet on it has a healthy

00:08:50,980 --> 00:08:56,350
ecosystem surprisingly we have a few

00:08:54,519 --> 00:08:58,420
frameworks right now to do HTTP in

00:08:56,350 --> 00:09:03,279
Python it's HTTP fennec and there are

00:08:58,420 --> 00:09:06,670
many others without database libraries

00:09:03,279 --> 00:09:09,850
like 18kg we have support from my sequel

00:09:06,670 --> 00:09:11,410
a mexico radius memcache did pretty much

00:09:09,850 --> 00:09:13,209
all of them are covered we have a swath

00:09:11,410 --> 00:09:16,269
of libraries and a religious

00:09:13,209 --> 00:09:19,589
organization on github so I'd say pretty

00:09:16,269 --> 00:09:22,269
much every major component of our

00:09:19,589 --> 00:09:26,769
systems have has some sort of

00:09:22,269 --> 00:09:28,360
async/await library around it and it has

00:09:26,769 --> 00:09:30,910
a pluggable event loop and this is

00:09:28,360 --> 00:09:33,220
something that was envisioned in the

00:09:30,910 --> 00:09:35,649
very beginning of aging day oh this is

00:09:33,220 --> 00:09:38,620
something that lets a think I will be

00:09:35,649 --> 00:09:42,279
integrated with frameworks like twisted

00:09:38,620 --> 00:09:45,370
or tornado but it also gives us the

00:09:42,279 --> 00:09:46,870
ability to switch the event loop and do

00:09:45,370 --> 00:09:50,110
something something fun with it like

00:09:46,870 --> 00:09:53,320
make it faster so there is this project

00:09:50,110 --> 00:09:56,440
called yuga loop and they it has this

00:09:53,320 --> 00:09:58,870
promise or a year to make a sequel to

00:09:56,440 --> 00:10:00,760
four times faster and it does in micro

00:09:58,870 --> 00:10:03,820
benchmarks but it's not it's not

00:10:00,760 --> 00:10:07,000
surprising to see 1523 and sometimes

00:10:03,820 --> 00:10:10,870
even 50% speed up in real production

00:10:07,000 --> 00:10:12,820
code so if you haven't seen you look

00:10:10,870 --> 00:10:15,430
before haven't tried it definitely give

00:10:12,820 --> 00:10:17,380
it a try I'd say that at this point of

00:10:15,430 --> 00:10:20,529
time it's stable and safe to use in

00:10:17,380 --> 00:10:23,589
production so try to do it and here is

00:10:20,529 --> 00:10:26,440
something else we call this Python iam 3

00:10:23,589 --> 00:10:30,370
oxide this is a new github group that we

00:10:26,440 --> 00:10:36,660
created just about two months ago and it

00:10:30,370 --> 00:10:38,280
explores a way to bring rust to Python

00:10:36,660 --> 00:10:41,610
so let's get back to this luggable event

00:10:38,280 --> 00:10:44,160
loop idea what if we could have an event

00:10:41,610 --> 00:10:49,590
loop an Asian guy event loop written in

00:10:44,160 --> 00:10:51,990
rust so that 18 ko becomes a breach from

00:10:49,590 --> 00:10:54,750
Python world to rust world what if you

00:10:51,990 --> 00:10:56,700
could call a quality in implemented in

00:10:54,750 --> 00:10:59,070
rust in Python with the timeout and

00:10:56,700 --> 00:11:02,310
cancel it later what if you could have

00:10:59,070 --> 00:11:04,680
an HTTP server or some protocol

00:11:02,310 --> 00:11:06,570
implemented in rust and then used in

00:11:04,680 --> 00:11:09,450
your high level code so this is the

00:11:06,570 --> 00:11:12,450
project that tries to explore that it's

00:11:09,450 --> 00:11:15,330
not there yet I think it implements most

00:11:12,450 --> 00:11:16,860
of the async i/o ap is right now but

00:11:15,330 --> 00:11:19,770
it's still incomplete and still

00:11:16,860 --> 00:11:24,420
experimental it's not as fast as usual

00:11:19,770 --> 00:11:26,100
right now but it will be there and one

00:11:24,420 --> 00:11:29,400
of the things that we actually want to

00:11:26,100 --> 00:11:32,340
focus here is safety because you remove

00:11:29,400 --> 00:11:36,420
and a lot of other accelerators are

00:11:32,340 --> 00:11:38,430
written inside and see and sometimes you

00:11:36,420 --> 00:11:40,710
find sexual sometimes sometimes you find

00:11:38,430 --> 00:11:42,360
bugs with rust you just don't have this

00:11:40,710 --> 00:11:45,090
this kind of problem and you affect

00:11:42,360 --> 00:11:46,950
performance and thrust this this new

00:11:45,090 --> 00:11:50,630
shiny thing it's everybody's favorite

00:11:46,950 --> 00:11:53,790
language even though nobody knows it so

00:11:50,630 --> 00:11:56,370
it's really cool and I really have high

00:11:53,790 --> 00:11:59,810
hopes for this new thing so definitely

00:11:56,370 --> 00:12:03,000
check it out it's on it's on github life

00:11:59,810 --> 00:12:04,830
so let's talk about what's next for a

00:12:03,000 --> 00:12:07,670
single what will happen with the single

00:12:04,830 --> 00:12:11,460
we have some goals we have some goals

00:12:07,670 --> 00:12:13,530
4037 specifically one of the first

00:12:11,460 --> 00:12:16,560
things that we want to make sure of is

00:12:13,530 --> 00:12:17,540
that we can run and use twisted code on

00:12:16,560 --> 00:12:20,910
18 Guyo

00:12:17,540 --> 00:12:23,130
there were some blockers to that but I

00:12:20,910 --> 00:12:25,530
think we kind of dress them all in three

00:12:23,130 --> 00:12:27,180
six and in any case so three seven this

00:12:25,530 --> 00:12:29,610
is one of the things that we want to do

00:12:27,180 --> 00:12:30,930
that we want to make sure that

00:12:29,610 --> 00:12:33,360
everything that was developed for

00:12:30,930 --> 00:12:34,760
Twitter there is a lot of good code that

00:12:33,360 --> 00:12:38,610
we can use it nation trail

00:12:34,760 --> 00:12:41,160
another question is maybe Curia and trio

00:12:38,610 --> 00:12:46,440
can they deal to be built on top of a

00:12:41,160 --> 00:12:48,270
Shinkai oh maybe this will let us fix

00:12:46,440 --> 00:12:50,030
bugs an async i/o because of the

00:12:48,270 --> 00:12:51,980
increased user base

00:12:50,030 --> 00:12:54,050
or maybe we will be able to have a

00:12:51,980 --> 00:12:56,960
compatibility between HTML code and

00:12:54,050 --> 00:12:59,840
Uriel code or trio code this is

00:12:56,960 --> 00:13:03,740
something to explore so this is another

00:12:59,840 --> 00:13:08,360
goal is to see if we have enough api's

00:13:03,740 --> 00:13:10,100
or if our api's are flexible enough to

00:13:08,360 --> 00:13:12,170
implement a new source of frameworks new

00:13:10,100 --> 00:13:15,710
async/await frameworks on top of a team

00:13:12,170 --> 00:13:18,460
bio and the trust loop so we have some

00:13:15,710 --> 00:13:21,560
problems right now in Tokyo

00:13:18,460 --> 00:13:24,110
for instance right now it's really hard

00:13:21,560 --> 00:13:26,240
to have a task or a corrosion and rust

00:13:24,110 --> 00:13:28,220
to be fully compatible with Python code

00:13:26,240 --> 00:13:30,590
there are some low-level details and can

00:13:28,220 --> 00:13:33,050
we work around it but we definitely want

00:13:30,590 --> 00:13:35,810
to make sure that in three seven is

00:13:33,050 --> 00:13:38,180
straightforward so maybe if you're

00:13:35,810 --> 00:13:40,220
writing your next event loop I don't

00:13:38,180 --> 00:13:42,110
know and pure assembly you will be able

00:13:40,220 --> 00:13:46,310
to lead the grid easily this async i/o

00:13:42,110 --> 00:13:48,620
37 the other thing that we want to focus

00:13:46,310 --> 00:13:51,500
in Python 3 7 is to improve usability

00:13:48,620 --> 00:13:55,040
and specifically to address the issue of

00:13:51,500 --> 00:14:01,340
documentation currently documentation of

00:13:55,040 --> 00:14:04,130
we think is is it's huge I say it's

00:14:01,340 --> 00:14:07,100
really hard to follow it it focuses too

00:14:04,130 --> 00:14:09,710
much on low-level details and sort of

00:14:07,100 --> 00:14:11,870
teach people how to use async i/o how to

00:14:09,710 --> 00:14:15,370
use it in an optimal way how to maintain

00:14:11,870 --> 00:14:17,510
code bases and facing trial how to write

00:14:15,370 --> 00:14:19,130
frameworks and protocols for its

00:14:17,510 --> 00:14:20,900
integral in an optimal way and the

00:14:19,130 --> 00:14:23,060
original documentation by the way it was

00:14:20,900 --> 00:14:24,710
written by Victor Skinner and I think he

00:14:23,060 --> 00:14:27,470
deserves some credit for it because he

00:14:24,710 --> 00:14:29,630
did it single-handedly when 18k wasn't

00:14:27,470 --> 00:14:32,630
such a big thing as it is right now he

00:14:29,630 --> 00:14:34,910
he written all of it and I think we kind

00:14:32,630 --> 00:14:37,910
of dropped the ball and we didn't update

00:14:34,910 --> 00:14:40,610
it we didn't really maintain it so this

00:14:37,910 --> 00:14:43,130
is one of the top priorities for 3:7 is

00:14:40,610 --> 00:14:43,670
to fix the documentation make it easy to

00:14:43,130 --> 00:14:46,130
learn

00:14:43,670 --> 00:14:47,960
add some tutorials to it so we'll be

00:14:46,130 --> 00:14:50,000
focusing on that and of course if you

00:14:47,960 --> 00:14:51,670
guys want to help you're welcome to do

00:14:50,000 --> 00:14:54,200
so

00:14:51,670 --> 00:14:56,530
usability now this is an interesting

00:14:54,200 --> 00:14:59,540
topic these are the functions that you

00:14:56,530 --> 00:15:01,940
that if you know this function these

00:14:59,540 --> 00:15:03,610
functions you can pretty much write any

00:15:01,940 --> 00:15:05,320
a single program

00:15:03,610 --> 00:15:07,510
this is this is all three think I owe

00:15:05,320 --> 00:15:09,580
that a couple of more but not not really

00:15:07,510 --> 00:15:14,670
important if you understand how these

00:15:09,580 --> 00:15:14,670
functions work you can do it but if you

00:15:15,540 --> 00:15:20,590
doesn't work anyways if you if you look

00:15:17,860 --> 00:15:22,930
at them you will see the some functions

00:15:20,590 --> 00:15:25,380
are prefixed with 18k oh and some

00:15:22,930 --> 00:15:29,740
functions are practiced with loop and

00:15:25,380 --> 00:15:31,540
this is another subtle problem of async

00:15:29,740 --> 00:15:34,180
IO and maybe it's also documentation

00:15:31,540 --> 00:15:37,120
issue the idea was that

00:15:34,180 --> 00:15:39,910
II think our programs try to always pass

00:15:37,120 --> 00:15:42,730
event loop explicitly in your program so

00:15:39,910 --> 00:15:45,910
you always carry the event loop object

00:15:42,730 --> 00:15:49,390
around you you cannot do things without

00:15:45,910 --> 00:15:51,220
it so I think o itself all of a single

00:15:49,390 --> 00:15:54,550
unit tests many of eighteen care

00:15:51,220 --> 00:15:58,090
packages they all accept loop argument

00:15:54,550 --> 00:16:00,850
they will expect you to pass it it's got

00:15:58,090 --> 00:16:03,930
a really suboptimal but in Python 3.6

00:16:00,850 --> 00:16:06,570
we've fixed get event loop method and

00:16:03,930 --> 00:16:09,130
now it behaves deterministically

00:16:06,570 --> 00:16:11,800
whenever you call from an async await

00:16:09,130 --> 00:16:14,980
code it will always return you the

00:16:11,800 --> 00:16:16,560
correct event loop so again so that is

00:16:14,980 --> 00:16:20,470
that you can have your high-level

00:16:16,560 --> 00:16:22,480
beautiful async await API and whenever

00:16:20,470 --> 00:16:24,700
you have to go a low-level in your

00:16:22,480 --> 00:16:27,700
implementation you always can get this

00:16:24,700 --> 00:16:31,140
event but you don't need the user to

00:16:27,700 --> 00:16:35,440
pass this event loop for you around so

00:16:31,140 --> 00:16:38,230
pretty much starting right now we start

00:16:35,440 --> 00:16:40,420
to encourage people to design their

00:16:38,230 --> 00:16:45,220
api's without explicit event loop in

00:16:40,420 --> 00:16:48,220
mind but for 3:7 we need to fix many of

00:16:45,220 --> 00:16:51,250
our API s and add new api's to promote

00:16:48,220 --> 00:16:53,440
this pattern so that KY level eating

00:16:51,250 --> 00:16:53,980
kayo programs don't even care about the

00:16:53,440 --> 00:16:56,110
eventful

00:16:53,980 --> 00:17:00,010
it's a low-level detail don't think

00:16:56,110 --> 00:17:02,910
about it don't bother with it you also

00:17:00,010 --> 00:17:07,510
need to do we also want to it do things

00:17:02,910 --> 00:17:09,880
one of them is a start CLS there are

00:17:07,510 --> 00:17:11,560
some protocols that start as a query

00:17:09,880 --> 00:17:13,660
text and then they suddenly need to

00:17:11,560 --> 00:17:17,100
upgrade and become secure and they need

00:17:13,660 --> 00:17:20,730
start CLS there is also

00:17:17,100 --> 00:17:23,730
a very frequently requested feature by

00:17:20,730 --> 00:17:26,610
our mineral eager to add call and task

00:17:23,730 --> 00:17:28,169
context api's perhaps he wants to green

00:17:26,610 --> 00:17:29,910
room and flask or something but this is

00:17:28,169 --> 00:17:33,480
quite a serious thing actually this is

00:17:29,910 --> 00:17:36,929
quite a serious issue for large

00:17:33,480 --> 00:17:38,940
applications if you have thousands of

00:17:36,929 --> 00:17:41,070
lines of code or hundreds of hundreds of

00:17:38,940 --> 00:17:43,890
thousands of code sometimes somewhere

00:17:41,070 --> 00:17:45,750
deep down below you've realized oh I

00:17:43,890 --> 00:17:48,059
need more context maybe I need the

00:17:45,750 --> 00:17:50,340
current request object or maybe I need

00:17:48,059 --> 00:17:52,440
the current host or port that I am

00:17:50,340 --> 00:17:54,210
connected to for logging or for

00:17:52,440 --> 00:17:56,370
something like that and without

00:17:54,210 --> 00:17:59,850
rewriting all of your code you pretty

00:17:56,370 --> 00:18:01,320
much can't do it you cannot use thread

00:17:59,850 --> 00:18:04,740
local objects because they don't work

00:18:01,320 --> 00:18:06,240
with async async' in a way you cannot

00:18:04,740 --> 00:18:11,039
use a global variable because it's a

00:18:06,240 --> 00:18:13,860
shared state so it's really hard and one

00:18:11,039 --> 00:18:16,350
of the last major thing is things is to

00:18:13,860 --> 00:18:19,350
add a single rebel so that you can just

00:18:16,350 --> 00:18:22,409
type Python - m18 Keio or maybe just

00:18:19,350 --> 00:18:24,419
Python and experiment and play with 18k

00:18:22,409 --> 00:18:26,580
or with its native syntax so that we can

00:18:24,419 --> 00:18:30,390
just write await something and it would

00:18:26,580 --> 00:18:31,320
do it for you and overall we need your

00:18:30,390 --> 00:18:34,400
help

00:18:31,320 --> 00:18:37,890
after you've asked for the new features

00:18:34,400 --> 00:18:39,929
you can use bugs pythons works for bug

00:18:37,890 --> 00:18:42,390
request those bug reports but you can

00:18:39,929 --> 00:18:44,610
also use it for feature requests we also

00:18:42,390 --> 00:18:49,260
have Python tulip mailing list to look

00:18:44,610 --> 00:18:51,270
is the original name of a Beijing ko but

00:18:49,260 --> 00:18:54,120
it's still quite active with Ariza and

00:18:51,270 --> 00:18:56,990
helps people a lot a lot of other Asian

00:18:54,120 --> 00:19:00,320
code developers faded but also on github

00:18:56,990 --> 00:19:02,429
C Python moved to github completely and

00:19:00,320 --> 00:19:03,780
everything now happens on give traffic

00:19:02,429 --> 00:19:06,929
an issue pull requests it's so much

00:19:03,780 --> 00:19:09,030
easier the whole idea of this migration

00:19:06,929 --> 00:19:12,659
was to involve more people in C Python

00:19:09,030 --> 00:19:15,690
and also in 18-karat development so help

00:19:12,659 --> 00:19:17,070
us guys I think I think async I of has a

00:19:15,690 --> 00:19:21,650
very bright future especially with

00:19:17,070 --> 00:19:24,120
things like a rough integration this

00:19:21,650 --> 00:19:26,669
this might enable us to do so much more

00:19:24,120 --> 00:19:28,710
in the near future that's it see if you

00:19:26,669 --> 00:19:31,070
guys have any questions at the capital

00:19:28,710 --> 00:19:31,070
Dresden

00:19:31,680 --> 00:19:41,200
Thank you Thank You Yuri if anyone has

00:19:39,580 --> 00:19:50,350
any questions please come up to one of

00:19:41,200 --> 00:19:50,680
the microphones in the aisles do you

00:19:50,350 --> 00:19:53,470
mind

00:19:50,680 --> 00:19:55,450
comparing the async i/o infrastructure

00:19:53,470 --> 00:19:57,330
to what's available in other languages

00:19:55,450 --> 00:19:59,710
like you know this JavaScript has

00:19:57,330 --> 00:20:01,390
promises announced in Kuwait and C sharp

00:19:59,710 --> 00:20:03,760
and just like at a high level just to

00:20:01,390 --> 00:20:05,440
get a feel of how like are they roughly

00:20:03,760 --> 00:20:06,490
doing the same thing or is it in here in

00:20:05,440 --> 00:20:07,600
difference between what different

00:20:06,490 --> 00:20:09,220
languages are doing since all of them

00:20:07,600 --> 00:20:10,990
seem to be moving to what's having a

00:20:09,220 --> 00:20:14,170
cynical wait at least but behind it it's

00:20:10,990 --> 00:20:15,670
probably not quite the same yes there

00:20:14,170 --> 00:20:20,370
are not quite the same but yes the idea

00:20:15,670 --> 00:20:22,750
is almost the same I'd say one of the

00:20:20,370 --> 00:20:25,660
problems in Python that we have with

00:20:22,750 --> 00:20:27,790
async i/o and async await is that the

00:20:25,660 --> 00:20:30,550
language itself originally was designed

00:20:27,790 --> 00:20:32,890
to be synchronous thing so a lot of API

00:20:30,550 --> 00:20:35,290
is can actually block so one of the

00:20:32,890 --> 00:20:38,110
ideas that we need to research in Python

00:20:35,290 --> 00:20:40,300
specifically is to find a way to see if

00:20:38,110 --> 00:20:43,150
your application is making some blocking

00:20:40,300 --> 00:20:46,270
system calls while while while I was

00:20:43,150 --> 00:20:48,370
doing it I think awaiting other than

00:20:46,270 --> 00:20:50,110
that I'd say bye to nation Kuwait

00:20:48,370 --> 00:20:52,570
implementation is quite similar to what

00:20:50,110 --> 00:20:53,740
you have an Java Script if you know how

00:20:52,570 --> 00:20:58,690
to use it in jealous because you know

00:20:53,740 --> 00:21:01,990
how to use it in Python if I say for

00:20:58,690 --> 00:21:04,780
instance this context sharing context

00:21:01,990 --> 00:21:07,060
object idea it kind of comes from

00:21:04,780 --> 00:21:09,730
c-sharp where where they solve this

00:21:07,060 --> 00:21:12,190
problem for a single code so it's we're

00:21:09,730 --> 00:21:14,560
at the point where we can borrow where

00:21:12,190 --> 00:21:17,050
we can copy good ideas from other

00:21:14,560 --> 00:21:19,630
languages and edit to Python and in many

00:21:17,050 --> 00:21:23,610
ways Python support of a think of weight

00:21:19,630 --> 00:21:27,070
is greater than in any other language I

00:21:23,610 --> 00:21:30,070
don't think that a lot of languages or

00:21:27,070 --> 00:21:32,320
any languages besides pythons have a

00:21:30,070 --> 00:21:37,270
synchronous context managers or a

00:21:32,320 --> 00:21:38,350
synchronous generators Python copies at

00:21:37,270 --> 00:21:39,940
least at first

00:21:38,350 --> 00:21:42,670
a Singh and a weight expression from

00:21:39,940 --> 00:21:44,560
c-sharp but we added so much more to

00:21:42,670 --> 00:21:51,860
make it useful

00:21:44,560 --> 00:21:54,020
thank you um I was wondering I guess

00:21:51,860 --> 00:21:56,450
kind of two questions one why isn't UV

00:21:54,020 --> 00:21:58,970
loop the standard loop if it's so much

00:21:56,450 --> 00:22:01,910
faster than the async IO one and then

00:21:58,970 --> 00:22:04,640
also are there any efforts to improve

00:22:01,910 --> 00:22:06,200
the like the steps to start the loop and

00:22:04,640 --> 00:22:08,000
register your function and everything

00:22:06,200 --> 00:22:09,320
seemed kind of cumbersome from a user

00:22:08,000 --> 00:22:11,090
standpoint are there are there any

00:22:09,320 --> 00:22:14,270
efforts to improve the usability there

00:22:11,090 --> 00:22:16,970
as well the first question is why you've

00:22:14,270 --> 00:22:19,190
a loop is faster or why isn't it best at

00:22:16,970 --> 00:22:21,950
the async i/o default you can vent loop

00:22:19,190 --> 00:22:26,270
uh you will look youthful EBV live V's

00:22:21,950 --> 00:22:29,180
the low-level library original developed

00:22:26,270 --> 00:22:30,830
for an old GS it's a large dependency

00:22:29,180 --> 00:22:33,410
since a big library it's a lot of code

00:22:30,830 --> 00:22:35,930
and we wouldn't follow

00:22:33,410 --> 00:22:39,020
we don't need C Python to depend on this

00:22:35,930 --> 00:22:41,030
library especially given how easy it is

00:22:39,020 --> 00:22:43,130
to install your loop and a sinker again

00:22:41,030 --> 00:22:45,470
it was it was envisioned from the

00:22:43,130 --> 00:22:48,380
beginning that such a thing should be

00:22:45,470 --> 00:22:51,830
possible so I guess there is not enough

00:22:48,380 --> 00:22:54,140
motivation to add a lot a lot of

00:22:51,830 --> 00:22:57,530
low-level sequel to point at this point

00:22:54,140 --> 00:22:59,750
of time the core functionality of racing

00:22:57,530 --> 00:23:03,650
guy right now is in pure pythons lot you

00:22:59,750 --> 00:23:06,020
easy to read it and then fix see it's

00:23:03,650 --> 00:23:08,660
just not that big of an issue as for the

00:23:06,020 --> 00:23:10,610
second question yes specifically we want

00:23:08,660 --> 00:23:14,000
to run to add to high-level functions

00:23:10,610 --> 00:23:16,220
Asian trail run and async a run forever

00:23:14,000 --> 00:23:18,290
the first one would accept a coercion

00:23:16,220 --> 00:23:20,150
and it would just rather this is like an

00:23:18,290 --> 00:23:22,460
entry point for a simple a scenario

00:23:20,150 --> 00:23:24,440
application if you have a complex a

00:23:22,460 --> 00:23:26,450
single application which spawns a lot of

00:23:24,440 --> 00:23:29,090
services sub processes and you kinda

00:23:26,450 --> 00:23:31,070
have to finalize and clear the state of

00:23:29,090 --> 00:23:32,660
a single program consistently you'll

00:23:31,070 --> 00:23:36,320
have the second method which actually

00:23:32,660 --> 00:23:38,270
accepts a asynchronous generator or an

00:23:36,320 --> 00:23:39,890
asynchronous context manager so the idea

00:23:38,270 --> 00:23:42,230
is that you enter your asynchronous

00:23:39,890 --> 00:23:44,660
state consistently in an asynchronous

00:23:42,230 --> 00:23:46,490
way and you can clean up your state in a

00:23:44,660 --> 00:23:49,250
synchronous way consistently and the

00:23:46,490 --> 00:23:51,800
whole machinery of creating loop

00:23:49,250 --> 00:23:53,510
clean up resources printing out debug

00:23:51,800 --> 00:23:57,049
information can be handled by this

00:23:53,510 --> 00:23:58,940
function but yes we definitely recognize

00:23:57,049 --> 00:24:01,159
is this problem that right now it's

00:23:58,940 --> 00:24:04,429
really it's a cumbersome process to

00:24:01,159 --> 00:24:06,379
bootstrap a sinker application so yes we

00:24:04,429 --> 00:24:08,749
have some solutions we I'll be working

00:24:06,379 --> 00:24:11,899
on a path on a new pipe for Python three

00:24:08,749 --> 00:24:14,149
seven pretty soon and my plans is to

00:24:11,899 --> 00:24:19,249
have the tab and have a library on

00:24:14,149 --> 00:24:20,749
github pull code a or next or a extras

00:24:19,249 --> 00:24:22,730
or something like that

00:24:20,749 --> 00:24:25,190
prototyping those things so that you

00:24:22,730 --> 00:24:27,409
guys can start using them and you give

00:24:25,190 --> 00:24:32,389
us some feedback before this lends to

00:24:27,409 --> 00:24:36,440
Python 3 seller I'm curious about the

00:24:32,389 --> 00:24:37,999
piyo 3 is it more about putting some

00:24:36,440 --> 00:24:40,909
Python in your roster putting some rust

00:24:37,999 --> 00:24:43,239
in your Python or just simplifying them

00:24:40,909 --> 00:24:48,679
both like what's sort of the use case of

00:24:43,239 --> 00:24:51,830
the actual pilot 3 pilot 3 library yes

00:24:48,679 --> 00:24:54,859
the use case is the first enable this

00:24:51,830 --> 00:24:57,379
integration because without C Python

00:24:54,859 --> 00:24:59,570
rust bindings which allows you to easily

00:24:57,379 --> 00:25:02,480
create by mix of frost code to the

00:24:59,570 --> 00:25:06,379
Python code but there is no way right

00:25:02,480 --> 00:25:08,869
now to have a an API to an asynchronous

00:25:06,379 --> 00:25:11,029
version of the API I'd say rascal

00:25:08,869 --> 00:25:13,669
doesn't know anything about Asian ko and

00:25:11,029 --> 00:25:16,460
asynchronous nothing about trust

00:25:13,669 --> 00:25:18,859
so a a thinker can be a bridge here the

00:25:16,460 --> 00:25:21,830
other thing is performance because yes

00:25:18,859 --> 00:25:23,960
you can write a low level let's say HTTP

00:25:21,830 --> 00:25:26,480
parsing library or low level Postgres

00:25:23,960 --> 00:25:29,480
driver in rust it will be very efficient

00:25:26,480 --> 00:25:31,999
until they probably safer them than a

00:25:29,480 --> 00:25:34,549
similar thing written in C so the idea

00:25:31,999 --> 00:25:37,700
is that to make it easier to reuse

00:25:34,549 --> 00:25:42,859
existing rust code in Python in a

00:25:37,700 --> 00:25:46,179
synchronous way we have time for one or

00:25:42,859 --> 00:25:46,179
two more questions if anyone has any

00:25:49,150 --> 00:26:02,359
thank you very much Yuri

00:25:50,670 --> 00:26:02,359

YouTube URL: https://www.youtube.com/watch?v=2ZFFv-wZ8_g


