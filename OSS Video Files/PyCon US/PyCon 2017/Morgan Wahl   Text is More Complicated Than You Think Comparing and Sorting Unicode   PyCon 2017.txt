Title: Morgan Wahl   Text is More Complicated Than You Think Comparing and Sorting Unicode   PyCon 2017
Publication date: 2017-05-20
Playlist: PyCon 2017
Description: 
	"Speaker: Morgan Wahl

Few people realize just how complicated text can be. Did you know sorting and even case-folding can depend on a user's locale? That different strings of characters can be semantically completely equivalent? That there are over a thousand Latin letters?

Legacy text encodings like ASCII made a lot of simplifying assumptions about how written languages work, and we all put up with them because it was cool to even have computers in the first place. Unicode removes many of those assumptions and provides the tools we need to write software that can just do the right thing regardless of what text users throw at it. Even if you don't translate your UI, getting the details of string comparison, sorting, and searching right can eliminate annoying surprises for you and your users.

Slides can be found at: https://speakerdeck.com/pycon2017 and https://github.com/PyCon/2017-slides"
Captions: 
	00:00:01,970 --> 00:00:07,230
hello everybody welcome to this

00:00:04,980 --> 00:00:10,290
afternoon's session I'm going to start

00:00:07,230 --> 00:00:12,540
with this afternoon with Morgan wall is

00:00:10,290 --> 00:00:13,710
going to be speaking on text is more

00:00:12,540 --> 00:00:18,090
complicated than you think

00:00:13,710 --> 00:00:20,900
comparing inserting Unicode code let's

00:00:18,090 --> 00:00:20,900
give them big hand please

00:00:24,050 --> 00:00:32,540
hi this is my first ever talk at a

00:00:28,470 --> 00:00:39,329
conference of any size so wish me luck

00:00:32,540 --> 00:00:42,050
thank changed the title slightly from

00:00:39,329 --> 00:00:45,570
what's in the program a little simpler

00:00:42,050 --> 00:00:48,809
so who's that guy my my name's Morgan

00:00:45,570 --> 00:00:53,100
wall I'm web developer using Django

00:00:48,809 --> 00:00:54,870
Python for about seven years now I work

00:00:53,100 --> 00:00:58,559
for an organization called add gene

00:00:54,870 --> 00:01:02,160
we're a library of DNA for molecular

00:00:58,559 --> 00:01:05,700
biologists that's the last one to talk

00:01:02,160 --> 00:01:10,950
about DNA I'm a bit of a linguistics

00:01:05,700 --> 00:01:15,439
enthusiast and learning all the details

00:01:10,950 --> 00:01:20,220
of how Unicode represents text digitally

00:01:15,439 --> 00:01:21,420
how we handle all the the ins and outs

00:01:20,220 --> 00:01:22,140
of all the written languages of the

00:01:21,420 --> 00:01:24,900
world

00:01:22,140 --> 00:01:26,549
in computers I find really interesting

00:01:24,900 --> 00:01:28,470
it's actually really interesting we'll

00:01:26,549 --> 00:01:34,710
learn about all the different written

00:01:28,470 --> 00:01:37,229
languages so what am I going to talk

00:01:34,710 --> 00:01:41,640
about first of all what is tax what is

00:01:37,229 --> 00:01:44,939
plain text in Python we certainly use it

00:01:41,640 --> 00:01:47,460
all the time although I didn't even know

00:01:44,939 --> 00:01:53,040
all the details until I had to write

00:01:47,460 --> 00:01:57,869
this up some basic concepts in just how

00:01:53,040 --> 00:01:59,430
we digitize written language and I'm

00:01:57,869 --> 00:02:03,920
going to talk about two things you might

00:01:59,430 --> 00:02:06,420
do with text compare it and sort it and

00:02:03,920 --> 00:02:08,640
specifically when you want to sort it

00:02:06,420 --> 00:02:09,989
and show it to humans how to do that in

00:02:08,640 --> 00:02:11,550
a way it's going to match their

00:02:09,989 --> 00:02:13,850
expectations and be the least surprising

00:02:11,550 --> 00:02:19,110
for them

00:02:13,850 --> 00:02:21,020
yeah not going to talk about all the

00:02:19,110 --> 00:02:25,050
details of translating your UI

00:02:21,020 --> 00:02:30,170
internationalisation actually where I

00:02:25,050 --> 00:02:32,100
work all of our UI is in English we're a

00:02:30,170 --> 00:02:33,960
most of our users are molecular

00:02:32,100 --> 00:02:36,900
biologists and like computer science

00:02:33,960 --> 00:02:39,300
like Python English is just the lingua

00:02:36,900 --> 00:02:41,640
franca all the big journals are in

00:02:39,300 --> 00:02:45,270
English we just expect our users to know

00:02:41,640 --> 00:02:49,110
English that said we can't act like the

00:02:45,270 --> 00:02:51,960
world is all asking most of our users

00:02:49,110 --> 00:02:53,640
are outside the US the majority of

00:02:51,960 --> 00:02:56,580
people who request DNA from us are

00:02:53,640 --> 00:02:58,620
outside the US they can type all sorts

00:02:56,580 --> 00:03:01,260
of stuff that we can't type generally

00:02:58,620 --> 00:03:03,840
developers and of course they can

00:03:01,260 --> 00:03:05,550
copy/paste anything so we still have to

00:03:03,840 --> 00:03:09,960
deal with all sorts of text coming into

00:03:05,550 --> 00:03:12,810
our system I'm not going to talk about

00:03:09,960 --> 00:03:14,580
how to render text how to go from some

00:03:12,810 --> 00:03:19,350
representation memory to pixels on a

00:03:14,580 --> 00:03:21,450
screen you'll see why in just a bit I'm

00:03:19,350 --> 00:03:23,550
definitely not gonna get into how you

00:03:21,450 --> 00:03:26,940
about editing that text the UI for that

00:03:23,550 --> 00:03:29,070
all even more complicated I'm not going

00:03:26,940 --> 00:03:31,290
to talk about fancy natural language

00:03:29,070 --> 00:03:32,730
search algorithms those are things that

00:03:31,290 --> 00:03:34,950
are built on top of what I'm talking

00:03:32,730 --> 00:03:38,600
about what we're going to go over is

00:03:34,950 --> 00:03:38,600
just the foundation for all of this

00:03:38,720 --> 00:03:42,450
you'd be forgiven for thinking this is

00:03:41,010 --> 00:03:46,380
to talk about Unicode because I'm going

00:03:42,450 --> 00:03:49,470
to talk a lot about Unicode um that's

00:03:46,380 --> 00:03:52,220
because it's really the standard for

00:03:49,470 --> 00:03:55,560
representing written language digitally

00:03:52,220 --> 00:03:56,760
it's the only real attempt to do that

00:03:55,560 --> 00:04:00,120
for all the written languages of the

00:03:56,760 --> 00:04:04,650
world in the past we had ASCII code page

00:04:00,120 --> 00:04:06,510
857 over id of encodings where they're

00:04:04,650 --> 00:04:08,820
pretty generally pretty simple because

00:04:06,510 --> 00:04:10,680
they would only want to support one

00:04:08,820 --> 00:04:13,709
maybe two written languages and I made a

00:04:10,680 --> 00:04:15,570
ton of simplifications that hated a

00:04:13,709 --> 00:04:18,090
bunch of problems in complexity of

00:04:15,570 --> 00:04:20,370
dealing with actual written language and

00:04:18,090 --> 00:04:23,030
Unicode can avoid that complexity it

00:04:20,370 --> 00:04:23,030
can't avoid those problems

00:04:23,440 --> 00:04:27,290
sometimes people get sort of annoyed

00:04:25,460 --> 00:04:29,960
that Unicode seems more complicated and

00:04:27,290 --> 00:04:32,510
ASCII that's just because text is

00:04:29,960 --> 00:04:34,310
complicated if you want to faithfully

00:04:32,510 --> 00:04:37,700
represent the way humans have used

00:04:34,310 --> 00:04:45,710
written language for a long time it's

00:04:37,700 --> 00:04:49,010
going to be a little complicated this is

00:04:45,710 --> 00:04:51,830
actually more than one Unicode Unicode

00:04:49,010 --> 00:04:56,180
versioned current version is nine-point

00:04:51,830 --> 00:04:58,400
0.0 each one you get to give is sort of

00:04:56,180 --> 00:05:01,669
another attempt to get it right

00:04:58,400 --> 00:05:03,440
there's always nobody's perfect there's

00:05:01,669 --> 00:05:07,160
always more things to address

00:05:03,440 --> 00:05:09,650
there's even novel ways of writing that

00:05:07,160 --> 00:05:13,730
have to be added most people think of

00:05:09,650 --> 00:05:16,100
emoji for example there's also the most

00:05:13,730 --> 00:05:18,260
recent version added osage which is a

00:05:16,100 --> 00:05:24,620
writing system that a script that didn't

00:05:18,260 --> 00:05:26,870
exist until the 21st century Unicode has

00:05:24,620 --> 00:05:29,270
stability guidelines if you read the

00:05:26,870 --> 00:05:31,370
standard itself even though it does

00:05:29,270 --> 00:05:33,229
change over time and it's versioned

00:05:31,370 --> 00:05:34,700
there's specific parts that are

00:05:33,229 --> 00:05:36,830
guaranteed to never change you can

00:05:34,700 --> 00:05:38,720
depend on the specific parts that may

00:05:36,830 --> 00:05:40,010
change and you need if you're writing

00:05:38,720 --> 00:05:42,110
algorithms that deal with that data you

00:05:40,010 --> 00:05:43,880
need to know which is which and how to

00:05:42,110 --> 00:05:50,180
deal with forwards compatibility and

00:05:43,880 --> 00:05:52,580
backwards compatibility unicode there's

00:05:50,180 --> 00:05:54,910
the standard itself which really lays

00:05:52,580 --> 00:06:00,500
out the basics like what is a character

00:05:54,910 --> 00:06:04,550
was a graphing cluster how do you what

00:06:00,500 --> 00:06:06,470
is whitespace really fundamental stuff

00:06:04,550 --> 00:06:09,530
what's the whole set of all the scripts

00:06:06,470 --> 00:06:11,270
we have to support there's a chapter on

00:06:09,530 --> 00:06:13,669
pretty much every script that gives you

00:06:11,270 --> 00:06:16,520
all of the nitty-gritty details how it's

00:06:13,669 --> 00:06:18,290
represented in unicode and then in

00:06:16,520 --> 00:06:20,660
addition to that there's standard

00:06:18,290 --> 00:06:21,710
annexes and technical standards it

00:06:20,660 --> 00:06:23,330
doesn't really matter the difference the

00:06:21,710 --> 00:06:25,220
point is these are extra standards in

00:06:23,330 --> 00:06:26,390
addition to the unicode one itself that

00:06:25,220 --> 00:06:28,400
are generally written by the same people

00:06:26,390 --> 00:06:29,900
they deal with one particular thing

00:06:28,400 --> 00:06:33,349
we're going to talk about a few of these

00:06:29,900 --> 00:06:34,760
we're gonna talk about normalization and

00:06:33,349 --> 00:06:37,340
also the collation algorithm just

00:06:34,760 --> 00:06:40,260
sorting basically

00:06:37,340 --> 00:06:42,810
they're all pretty interesting the

00:06:40,260 --> 00:06:44,880
there's also the common look how data

00:06:42,810 --> 00:06:47,670
repository which is a separate project

00:06:44,880 --> 00:06:50,970
it's sort of the modern equivalent of

00:06:47,670 --> 00:06:53,040
the old POSIX locales it's a whole big

00:06:50,970 --> 00:06:54,600
data curated database of how to do

00:06:53,040 --> 00:06:57,090
things in different written languages

00:06:54,600 --> 00:07:01,920
how do you format a number in German

00:06:57,090 --> 00:07:05,070
versus a Japanese it's its own project

00:07:01,920 --> 00:07:07,290
because it has a separate it's kind of

00:07:05,070 --> 00:07:08,730
its own organization but it's you'll see

00:07:07,290 --> 00:07:10,560
its website is part of the unicode

00:07:08,730 --> 00:07:16,950
website it's a lot of the same people

00:07:10,560 --> 00:07:19,140
work on both so what sex text in Python

00:07:16,950 --> 00:07:22,950
and really in general it's a sequence of

00:07:19,140 --> 00:07:26,400
code points code points are in the

00:07:22,950 --> 00:07:28,530
positive ends the biggest one is a

00:07:26,400 --> 00:07:29,880
hundred and ten thousand in hex but

00:07:28,530 --> 00:07:32,670
there's about a million of a little over

00:07:29,880 --> 00:07:35,640
a million of them some of those code

00:07:32,670 --> 00:07:37,350
points are assigned to characters most

00:07:35,640 --> 00:07:42,180
aren't the vast majority aren't as you

00:07:37,350 --> 00:07:43,470
can see from these numbers some the ones

00:07:42,180 --> 00:07:44,490
that say hundred twenty thousand

00:07:43,470 --> 00:07:46,320
characters those the ones that are

00:07:44,490 --> 00:07:48,630
assigned these characters are defined by

00:07:46,320 --> 00:07:49,890
the Unicode standard exactly what

00:07:48,630 --> 00:07:51,150
they're supposed to look like in

00:07:49,890 --> 00:07:53,940
different contexts others which behave

00:07:51,150 --> 00:07:56,070
there's also even more private use

00:07:53,940 --> 00:07:58,140
characters these are code points that

00:07:56,070 --> 00:07:59,540
are guaranteed to never be officially

00:07:58,140 --> 00:08:03,230
used for anything

00:07:59,540 --> 00:08:05,700
therefore yearly you'd use for your own

00:08:03,230 --> 00:08:08,580
whatever you want if you want to

00:08:05,700 --> 00:08:10,200
represent Klingon of the Unicode

00:08:08,580 --> 00:08:12,960
committee has said that they're not

00:08:10,200 --> 00:08:14,490
going to standardize that so but you can

00:08:12,960 --> 00:08:16,560
still use it you can use private use

00:08:14,490 --> 00:08:18,210
characters you can make a font that

00:08:16,560 --> 00:08:21,480
assigns glyphs to those characters so

00:08:18,210 --> 00:08:23,460
you can see it you can search it and as

00:08:21,480 --> 00:08:24,570
long as and you can exchange text with

00:08:23,460 --> 00:08:28,830
other people as long as they have the

00:08:24,570 --> 00:08:31,410
same assignments there's 65 non

00:08:28,830 --> 00:08:34,110
characters so these are things that

00:08:31,410 --> 00:08:37,229
aren't meant to be used for regular text

00:08:34,110 --> 00:08:40,020
but they are given specific uses within

00:08:37,229 --> 00:08:41,760
the different unicode standards and is

00:08:40,020 --> 00:08:43,229
also the circuits which are backwards

00:08:41,760 --> 00:08:45,360
compatibility and mechanism we're not

00:08:43,229 --> 00:08:47,040
going to get into the rest are

00:08:45,360 --> 00:08:50,930
technically called reserved a lot of

00:08:47,040 --> 00:08:50,930
times just come unassigned code points

00:08:51,140 --> 00:08:56,930
so how do we get to these code points

00:08:53,090 --> 00:08:59,670
well like anything you start with bytes

00:08:56,930 --> 00:09:03,000
and encoding the way Unicode defines it

00:08:59,670 --> 00:09:04,680
is a map is a way to go from bytes to

00:09:03,000 --> 00:09:07,860
sequence of code points and then back to

00:09:04,680 --> 00:09:12,540
bytes on the left here you see those

00:09:07,860 --> 00:09:13,830
utf-8 and there's also you - sixteen the

00:09:12,540 --> 00:09:15,810
bytes are completely different

00:09:13,830 --> 00:09:20,730
they represent the exact same sequence

00:09:15,810 --> 00:09:22,680
of code points sort of pet peeve of mine

00:09:20,730 --> 00:09:25,680
is occasionally people will say we need

00:09:22,680 --> 00:09:28,140
to convert something to Unicode when

00:09:25,680 --> 00:09:29,760
what they want is bytes this is just

00:09:28,140 --> 00:09:31,730
thing is just Unicode the standard

00:09:29,760 --> 00:09:34,470
itself to find seven different encodings

00:09:31,730 --> 00:09:37,110
in general you have to pick one you need

00:09:34,470 --> 00:09:38,730
to specify what it is just use utf-8

00:09:37,110 --> 00:09:42,390
would you find yourself in the situation

00:09:38,730 --> 00:09:45,420
of needing bytes utf-8 will work fine

00:09:42,390 --> 00:09:47,550
for you the other ones do exist for

00:09:45,420 --> 00:09:53,760
reasons if you need them you'll know

00:09:47,550 --> 00:09:56,580
that you need them yeah so code points

00:09:53,760 --> 00:09:59,070
they're more than just numbers Oh elves

00:09:56,580 --> 00:10:00,990
fermented you can see here there's a

00:09:59,070 --> 00:10:03,060
typical notation for code points the

00:10:00,990 --> 00:10:06,390
capital u and then plus sign and then

00:10:03,060 --> 00:10:08,580
some hex digits pad it out to four and

00:10:06,390 --> 00:10:11,360
here I've shown also the names for the

00:10:08,580 --> 00:10:14,280
characters of sign of these code points

00:10:11,360 --> 00:10:16,740
to give you a sense of what is encoded

00:10:14,280 --> 00:10:20,640
there and we'll see the string in a

00:10:16,740 --> 00:10:22,710
minute the points of properties so the

00:10:20,640 --> 00:10:25,110
more than just this is separate from the

00:10:22,710 --> 00:10:27,180
other ones you could standard also

00:10:25,110 --> 00:10:29,310
defines a whole slew of property there's

00:10:27,180 --> 00:10:33,240
over a hundred they don't all fit on

00:10:29,310 --> 00:10:35,940
this slide generally these properties

00:10:33,240 --> 00:10:38,490
all exist because there's some algorithm

00:10:35,940 --> 00:10:40,500
that needs to tell different sets of

00:10:38,490 --> 00:10:41,730
characters sets of characters apart and

00:10:40,500 --> 00:10:43,890
it's going to do that by just saying

00:10:41,730 --> 00:10:46,380
characters with this property babe this

00:10:43,890 --> 00:10:48,300
way this property behaved this way this

00:10:46,380 --> 00:10:50,010
is a future compatible f---ing thing

00:10:48,300 --> 00:10:51,450
where we can always add more characters

00:10:50,010 --> 00:10:53,870
and as long as we set their properties

00:10:51,450 --> 00:10:56,400
right the algorithm works fine

00:10:53,870 --> 00:10:59,130
oftentimes the same code will work fine

00:10:56,400 --> 00:11:01,410
you can just update your copy of the

00:10:59,130 --> 00:11:02,770
unicode character database which times

00:11:01,410 --> 00:11:04,270
all these properties

00:11:02,770 --> 00:11:09,430
and in theory a lot of stuff will just

00:11:04,270 --> 00:11:11,260
continue working in reality if you find

00:11:09,430 --> 00:11:12,730
yourself implementing an algorithm that

00:11:11,260 --> 00:11:14,980
needs these properties you're probably

00:11:12,730 --> 00:11:18,550
in reinventing the wheel

00:11:14,980 --> 00:11:20,530
you should find if somebody else has but

00:11:18,550 --> 00:11:22,900
it's still useful to know about them to

00:11:20,530 --> 00:11:24,640
know at least roughly what they mean can

00:11:22,900 --> 00:11:26,200
help you when you do have some problem

00:11:24,640 --> 00:11:27,850
you're trying to debug where some

00:11:26,200 --> 00:11:30,490
particular string has weird behavior you

00:11:27,850 --> 00:11:31,510
don't understand why understanding what

00:11:30,490 --> 00:11:34,420
these different properties mean can be

00:11:31,510 --> 00:11:36,550
helpful so let's look at a couple

00:11:34,420 --> 00:11:40,720
properties here's name and age we've

00:11:36,550 --> 00:11:44,320
already seen name age is what version of

00:11:40,720 --> 00:11:45,550
Unicode it was assigned 1.1 means it's

00:11:44,320 --> 00:11:51,700
old is dirt really there's nothing

00:11:45,550 --> 00:11:53,290
that's 101.1 is from 1993 so some of

00:11:51,700 --> 00:11:57,340
these assignments are older than people

00:11:53,290 --> 00:12:03,300
here probably you can see if there's

00:11:57,340 --> 00:12:05,740
another taco got added in 8.0 also

00:12:03,300 --> 00:12:07,930
notice the stability of Unicode names

00:12:05,740 --> 00:12:09,460
there's a typo in one of these names but

00:12:07,930 --> 00:12:11,800
that is the official name it will never

00:12:09,460 --> 00:12:14,080
ever change because the names are

00:12:11,800 --> 00:12:15,580
guaranteed to be stable they will know

00:12:14,080 --> 00:12:17,260
once the characters is assigned its name

00:12:15,580 --> 00:12:25,000
will never change even though it's

00:12:17,260 --> 00:12:28,210
called a brat cat and now the property's

00:12:25,000 --> 00:12:33,460
general category this is a stand-in for

00:12:28,210 --> 00:12:35,260
when we save letters and numbers in reg

00:12:33,460 --> 00:12:38,140
X's when you say we need to find

00:12:35,260 --> 00:12:40,600
character classes as digits this is how

00:12:38,140 --> 00:12:43,240
you pick which actual characters you're

00:12:40,600 --> 00:12:45,790
going to match again these are sort of

00:12:43,240 --> 00:12:47,320
these are open categories new thing new

00:12:45,790 --> 00:12:50,350
characters can be added in in later

00:12:47,320 --> 00:12:52,570
revisions of Unicode and when you're

00:12:50,350 --> 00:12:54,820
Reds engine updates it's sort of own

00:12:52,570 --> 00:12:58,990
little copy of the character database it

00:12:54,820 --> 00:13:00,250
will work with those new assignments and

00:12:58,990 --> 00:13:02,260
they're intentionally structured so that

00:13:00,250 --> 00:13:04,360
there's a general category and then a

00:13:02,260 --> 00:13:08,020
more specific one for most of these so

00:13:04,360 --> 00:13:09,250
all the letters have a letter category

00:13:08,020 --> 00:13:13,290
and then they're also subdivided into

00:13:09,250 --> 00:13:13,290
uppercase and lowercase and other

00:13:16,060 --> 00:13:19,330
here's a good example of a property

00:13:17,920 --> 00:13:23,290
that's really boring but it's very

00:13:19,330 --> 00:13:25,420
important the case holding property this

00:13:23,290 --> 00:13:27,010
tells you case holding so they were all

00:13:25,420 --> 00:13:31,060
familiar with I'm gonna talk about it in

00:13:27,010 --> 00:13:32,440
depth more later but the point here is

00:13:31,060 --> 00:13:34,930
the value of the property is just

00:13:32,440 --> 00:13:36,700
another code point and for all of these

00:13:34,930 --> 00:13:39,610
except for the first one it's the same

00:13:36,700 --> 00:13:41,440
code point you can write a pretty simple

00:13:39,610 --> 00:13:44,440
case folding algorithm by just taking

00:13:41,440 --> 00:13:47,470
this data and saying replace it with its

00:13:44,440 --> 00:13:51,700
case folding property and that will

00:13:47,470 --> 00:13:52,960
mostly just work alright so we haven't

00:13:51,700 --> 00:13:54,910
actually may feel like we haven't

00:13:52,960 --> 00:13:56,980
actually looked at this these strings

00:13:54,910 --> 00:13:59,050
yet

00:13:56,980 --> 00:14:01,330
and as we because you don't really see

00:13:59,050 --> 00:14:06,340
characters characters these abstract

00:14:01,330 --> 00:14:08,610
things Unicode gives them a very concise

00:14:06,340 --> 00:14:10,990
if somewhat philosophical definition of

00:14:08,610 --> 00:14:12,370
I can't even say it all right now but

00:14:10,990 --> 00:14:13,810
essentially it's if they make a

00:14:12,370 --> 00:14:16,240
meaningful difference then they're

00:14:13,810 --> 00:14:17,470
separate if it doesn't matter that they

00:14:16,240 --> 00:14:18,880
look different than they're the same

00:14:17,470 --> 00:14:20,350
that they always mean the same thing

00:14:18,880 --> 00:14:22,270
then the really the same character and

00:14:20,350 --> 00:14:24,070
it's just two different glyphs in

00:14:22,270 --> 00:14:26,920
general characters are what we deal with

00:14:24,070 --> 00:14:28,450
in text when you search through a

00:14:26,920 --> 00:14:30,520
document I don't mean like a fancy

00:14:28,450 --> 00:14:32,200
search like just control F in a document

00:14:30,520 --> 00:14:33,850
you're searching the characters you

00:14:32,200 --> 00:14:35,020
don't care what the fonts are in your

00:14:33,850 --> 00:14:37,180
matches you can care whether it's

00:14:35,020 --> 00:14:40,240
italicize how big it is that's all font

00:14:37,180 --> 00:14:41,950
stuff that's all glyphs fonts are

00:14:40,240 --> 00:14:44,560
essentially a bunch of glyphs and

00:14:41,950 --> 00:14:51,490
information and how to map from code

00:14:44,560 --> 00:14:55,330
points to those glyphs area a we have

00:14:51,490 --> 00:14:57,190
some actual glyphs now finally each row

00:14:55,330 --> 00:15:02,290
is the exact same sequence of code

00:14:57,190 --> 00:15:05,080
points each column is a font as you can

00:15:02,290 --> 00:15:08,980
see rendering is not perfect on the

00:15:05,080 --> 00:15:11,700
pinyon script one also Mengel accents

00:15:08,980 --> 00:15:14,860
aren't always put in the right place and

00:15:11,700 --> 00:15:17,350
more obviously most fonts don't have a

00:15:14,860 --> 00:15:18,730
glyphs for most characters you usually

00:15:17,350 --> 00:15:20,500
don't even notice because rendering

00:15:18,730 --> 00:15:22,840
systems which are very complicated

00:15:20,500 --> 00:15:23,980
I have fallback mechanisms where if they

00:15:22,840 --> 00:15:25,180
don't if they don't have a glyph in the

00:15:23,980 --> 00:15:27,830
font that they normally use they look

00:15:25,180 --> 00:15:29,690
for another font that does have a glyph

00:15:27,830 --> 00:15:31,940
and if they totally give up different

00:15:29,690 --> 00:15:33,790
ones do different things that might just

00:15:31,940 --> 00:15:37,370
put in a box it might not do anything

00:15:33,790 --> 00:15:38,810
that varies but generally if somebody

00:15:37,370 --> 00:15:40,430
sends you something and you can't see it

00:15:38,810 --> 00:15:42,650
it's probably because you don't have a

00:15:40,430 --> 00:15:45,320
font with a glyph for it like rainbow

00:15:42,650 --> 00:15:47,510
flag emoji here pretty new character I

00:15:45,320 --> 00:15:49,490
actually had to take a screenshot to put

00:15:47,510 --> 00:15:53,840
it in this table because it doesn't work

00:15:49,490 --> 00:15:54,020
on my browser is that another fun all

00:15:53,840 --> 00:15:58,070
right

00:15:54,020 --> 00:16:01,190
so text rendering here's seven code

00:15:58,070 --> 00:16:05,330
points when you render it and this is

00:16:01,190 --> 00:16:07,850
blown up to shown show detail when you

00:16:05,330 --> 00:16:12,500
render it a user might say there's only

00:16:07,850 --> 00:16:14,150
two things there how user what users

00:16:12,500 --> 00:16:19,250
think of as characters and his letters

00:16:14,150 --> 00:16:20,630
is very different from code points this

00:16:19,250 --> 00:16:22,850
is one of the many things that makes

00:16:20,630 --> 00:16:25,100
rendering complicated you can see here

00:16:22,850 --> 00:16:27,620
also the first code point is lowercase o

00:16:25,100 --> 00:16:29,360
after that is what's called a combining

00:16:27,620 --> 00:16:31,580
character

00:16:29,360 --> 00:16:33,830
it's just modifying the character before

00:16:31,580 --> 00:16:35,120
it the base character before it you can

00:16:33,830 --> 00:16:37,610
have whole sequences of combining

00:16:35,120 --> 00:16:39,110
characters they all modify whatever base

00:16:37,610 --> 00:16:41,270
character came before that whole

00:16:39,110 --> 00:16:45,560
sequence we'll see more examples that in

00:16:41,270 --> 00:16:48,020
a sec after that space is also those

00:16:45,560 --> 00:16:53,030
four code points give you rainbow flag

00:16:48,020 --> 00:16:55,760
emoji why is it for well first of all

00:16:53,030 --> 00:16:57,650
there's waving white flag white actually

00:16:55,760 --> 00:17:00,140
is a type of graphical term here it

00:16:57,650 --> 00:17:01,790
means the color of the background so it

00:17:00,140 --> 00:17:04,670
was laid out on a black background and

00:17:01,790 --> 00:17:06,430
white text would be a black flag but

00:17:04,670 --> 00:17:08,360
essentially it's a flag symbol a

00:17:06,430 --> 00:17:10,600
character called a variation selector

00:17:08,360 --> 00:17:14,030
which is kind of a sort of special

00:17:10,600 --> 00:17:15,170
combining character that for most of you

00:17:14,030 --> 00:17:16,940
you can ignore unless you're writing

00:17:15,170 --> 00:17:19,339
rendering software you can ignore this

00:17:16,940 --> 00:17:20,750
but it's requesting that the character

00:17:19,339 --> 00:17:22,790
before it be given an emoji

00:17:20,750 --> 00:17:25,970
representation usually means color

00:17:22,790 --> 00:17:28,459
instead of black and white there's a

00:17:25,970 --> 00:17:30,290
zero with Joyner this is a character

00:17:28,459 --> 00:17:32,330
that it's another kind of formatting

00:17:30,290 --> 00:17:35,120
character it's saying the two base

00:17:32,330 --> 00:17:37,040
characters on either side of it try to

00:17:35,120 --> 00:17:40,340
mash them together when you render this

00:17:37,040 --> 00:17:40,880
in that case it's a white flag with an

00:17:40,340 --> 00:17:43,070
emoji

00:17:40,880 --> 00:17:44,840
and a rainbow you stick them together

00:17:43,070 --> 00:17:46,130
and this is a standardized thing you

00:17:44,840 --> 00:17:50,000
stick them together and you get a

00:17:46,130 --> 00:17:52,370
rainbow flag it's done this way partly

00:17:50,000 --> 00:17:53,660
for backwards compatibility if you have

00:17:52,370 --> 00:17:55,760
a glyph rainbow flag you can actually

00:17:53,660 --> 00:17:56,840
end up with a flag and then a rainbow

00:17:55,760 --> 00:17:59,540
which you can count a piece together

00:17:56,840 --> 00:18:01,250
what was meant instead of just a box or

00:17:59,540 --> 00:18:05,720
whatever the fallback your rendering

00:18:01,250 --> 00:18:07,990
system uses yeah I picked this example

00:18:05,720 --> 00:18:10,070
because it's particularly complicated

00:18:07,990 --> 00:18:12,290
and you can see why we're not getting

00:18:10,070 --> 00:18:13,400
into the details of text rendering this

00:18:12,290 --> 00:18:17,150
is also why you should not implement

00:18:13,400 --> 00:18:18,740
text rendering yourself it may seem like

00:18:17,150 --> 00:18:20,270
it's simple you look at the code points

00:18:18,740 --> 00:18:22,820
you put some images next to each other

00:18:20,270 --> 00:18:26,420
it's always much much more complicated

00:18:22,820 --> 00:18:27,830
just don't do that unless you work on

00:18:26,420 --> 00:18:29,690
one of the libraries to do that in which

00:18:27,830 --> 00:18:35,690
case thank you very much because it's

00:18:29,690 --> 00:18:38,180
really it can get very complicated so

00:18:35,690 --> 00:18:40,340
it's an actual code finally this little

00:18:38,180 --> 00:18:42,830
function I'm going to use a few times to

00:18:40,340 --> 00:18:44,330
help us look at a string in Python and

00:18:42,830 --> 00:18:48,110
see what are the actual code points in

00:18:44,330 --> 00:18:51,530
there at the bottom it's showing hello

00:18:48,110 --> 00:18:54,020
world emoji you can see in the

00:18:51,530 --> 00:18:55,370
implementation I'm importing something

00:18:54,020 --> 00:18:58,610
called Unicode data is actually in the

00:18:55,370 --> 00:19:00,200
standard library it's a little it's not

00:18:58,610 --> 00:19:02,360
the whole unicode character database

00:19:00,200 --> 00:19:04,910
it's a little slice of it the python

00:19:02,360 --> 00:19:07,400
needs to implement a lot of the standard

00:19:04,910 --> 00:19:09,770
library features and it's also available

00:19:07,400 --> 00:19:12,050
for you use if you want to know what

00:19:09,770 --> 00:19:13,490
version of unicode it's based on there's

00:19:12,050 --> 00:19:18,530
a property on there to tell you that an

00:19:13,490 --> 00:19:20,210
attribute on there to tell you that so

00:19:18,530 --> 00:19:23,810
yeah and that's where we get the names

00:19:20,210 --> 00:19:25,670
for each one okay so you can see in the

00:19:23,810 --> 00:19:27,050
output of this function it's one line

00:19:25,670 --> 00:19:30,130
per code point not at the bottom you

00:19:27,050 --> 00:19:30,130
have the string itself rendered

00:19:31,730 --> 00:19:37,700
so this can be confusing remember what

00:19:36,260 --> 00:19:39,830
you see is just glyphs it's not code

00:19:37,700 --> 00:19:42,500
points these two strings look totally

00:19:39,830 --> 00:19:44,029
the same they compare not equal because

00:19:42,500 --> 00:19:49,519
they're different sequences of code

00:19:44,029 --> 00:19:50,990
points so what's going on here remember

00:19:49,519 --> 00:19:52,779
I said you can have multiple combining

00:19:50,990 --> 00:19:55,610
characters after the same base character

00:19:52,779 --> 00:19:57,710
if those combining characters are in the

00:19:55,610 --> 00:19:59,899
same spot so to speak because they're

00:19:57,710 --> 00:20:02,360
all if they all go on top of it they'll

00:19:59,899 --> 00:20:04,090
just stack up as you add them on and so

00:20:02,360 --> 00:20:06,260
the ordering is significant there if

00:20:04,090 --> 00:20:09,139
one's on top ones on bottom it doesn't

00:20:06,260 --> 00:20:10,880
really matter the ordering you can say e

00:20:09,139 --> 00:20:12,980
with a certain Plex accent and a dot

00:20:10,880 --> 00:20:16,490
below and there's some rendering sales

00:20:12,980 --> 00:20:18,500
here but the meaning is the same you can

00:20:16,490 --> 00:20:20,570
say e with a circumflex accent and a dot

00:20:18,500 --> 00:20:22,399
below or you can say e with a dot below

00:20:20,570 --> 00:20:24,559
and a certain Plex accent and it should

00:20:22,399 --> 00:20:27,260
always mean the exact same thing there's

00:20:24,559 --> 00:20:29,470
no semantic distinction here Unicode

00:20:27,260 --> 00:20:32,750
calls these canonical e equivalent

00:20:29,470 --> 00:20:34,549
basically we understand that we've by

00:20:32,750 --> 00:20:36,590
having combining characters it's

00:20:34,549 --> 00:20:38,389
possible to have two sequences of code

00:20:36,590 --> 00:20:42,049
points that mean the exact same thing

00:20:38,389 --> 00:20:46,100
even though they differ there's also a

00:20:42,049 --> 00:20:49,639
few characters that shouldn't have been

00:20:46,100 --> 00:20:51,100
encoded but are generally is because

00:20:49,639 --> 00:20:53,389
Unicode does have a requirement that

00:20:51,100 --> 00:20:55,429
anything in a legacy encoding has a

00:20:53,389 --> 00:20:58,279
one-to-one mapping to a Unicode

00:20:55,429 --> 00:20:59,360
character even if that legacy encoding

00:20:58,279 --> 00:21:02,510
doesn't have this nice thought-through

00:20:59,360 --> 00:21:05,330
definition of what a character is so

00:21:02,510 --> 00:21:07,250
some legacy encoding made angstrom sign

00:21:05,330 --> 00:21:09,409
a separate character from just a with a

00:21:07,250 --> 00:21:11,179
ring even though it doesn't really make

00:21:09,409 --> 00:21:13,190
sense we don't have characters for meter

00:21:11,179 --> 00:21:17,240
sign it's just mu just we'll use

00:21:13,190 --> 00:21:19,059
lowercase M so Unicode encodes it but

00:21:17,240 --> 00:21:21,110
it's always it has a canonical

00:21:19,059 --> 00:21:22,940
decomposition which is basically saying

00:21:21,110 --> 00:21:24,710
it's always exactly the same as this

00:21:22,940 --> 00:21:29,210
other sequence in this case a capital A

00:21:24,710 --> 00:21:30,500
with a ring above it so how do we

00:21:29,210 --> 00:21:34,669
actually deal with this in code if you

00:21:30,500 --> 00:21:36,799
want to compare strings and actually get

00:21:34,669 --> 00:21:38,450
in you always go on equals to actually

00:21:36,799 --> 00:21:40,010
give you something that makes sense to

00:21:38,450 --> 00:21:44,480
you and though and even when they've

00:21:40,010 --> 00:21:45,549
looked the same the way we do that is

00:21:44,480 --> 00:21:48,909
with what Unicode calls noir

00:21:45,549 --> 00:21:50,499
zatia there's two different

00:21:48,909 --> 00:21:52,480
normalization forms basically

00:21:50,499 --> 00:21:54,179
normalization is an algorithm you handed

00:21:52,480 --> 00:21:56,169
a string you get another string back

00:21:54,179 --> 00:21:59,619
most of the time you get the same string

00:21:56,169 --> 00:22:01,179
back if you hand it something that has a

00:21:59,619 --> 00:22:04,330
canonical decomposition you get the

00:22:01,179 --> 00:22:06,279
decomposition back there's two forms I'm

00:22:04,330 --> 00:22:08,080
not going to get into the difference I'm

00:22:06,279 --> 00:22:10,950
going to show normalization form D

00:22:08,080 --> 00:22:12,940
because that's simpler to understand

00:22:10,950 --> 00:22:15,090
normalization form sees the one you

00:22:12,940 --> 00:22:18,039
should actually use if you're doing this

00:22:15,090 --> 00:22:19,720
some rendering systems deal with it a

00:22:18,039 --> 00:22:22,350
little better if you're storing the the

00:22:19,720 --> 00:22:25,749
strings that you get from this algorithm

00:22:22,350 --> 00:22:28,690
so here you can see on the left side we

00:22:25,749 --> 00:22:32,889
have the same sequence e with a dot and

00:22:28,690 --> 00:22:34,389
a circumflex we hand it off to the

00:22:32,889 --> 00:22:36,519
normalized function that's from the

00:22:34,389 --> 00:22:39,580
standard library we have to tell it what

00:22:36,519 --> 00:22:42,669
normalization form we want NFD and we

00:22:39,580 --> 00:22:45,639
get a sequence out exactly the same on

00:22:42,669 --> 00:22:47,499
the right side we have the combining

00:22:45,639 --> 00:22:51,129
character switched when we normalize it

00:22:47,499 --> 00:22:52,509
switches them back the particular order

00:22:51,129 --> 00:22:53,019
it picks doesn't really matter it's

00:22:52,509 --> 00:22:54,850
arbitrary

00:22:53,019 --> 00:22:56,289
the point is if they're canonically

00:22:54,850 --> 00:22:57,609
equivalent then you get the same thing

00:22:56,289 --> 00:23:00,929
out when you normalize and then you can

00:22:57,609 --> 00:23:02,859
compare these and look them very cool

00:23:00,929 --> 00:23:06,700
same thing with something with a

00:23:02,859 --> 00:23:08,409
canonical decomposition by the way if

00:23:06,700 --> 00:23:10,840
you haven't seen the syntax before in

00:23:08,409 --> 00:23:12,519
Python where in a string literal you can

00:23:10,840 --> 00:23:14,590
do slash capital n I didn't even know

00:23:12,519 --> 00:23:17,139
about this till recently and then in

00:23:14,590 --> 00:23:19,649
curly brackets you put the name of the

00:23:17,139 --> 00:23:22,389
code point like the name Unicode assigns

00:23:19,649 --> 00:23:24,489
that's the same as saying slash u and

00:23:22,389 --> 00:23:25,239
then it's code point in hex only it's a

00:23:24,489 --> 00:23:28,389
little more readable

00:23:25,239 --> 00:23:32,470
it's although a lot longer so anyway so

00:23:28,389 --> 00:23:34,509
we take angstrom sign you can see it's

00:23:32,470 --> 00:23:37,210
just this one code point we normalize it

00:23:34,509 --> 00:23:39,850
and we get the canonical decomposition

00:23:37,210 --> 00:23:41,529
if we compare this to a string that's a

00:23:39,850 --> 00:23:45,460
with a ring above it they'll compare

00:23:41,529 --> 00:23:50,100
equal once we normalize it there's

00:23:45,460 --> 00:23:51,220
another sort of flavor of normalization

00:23:50,100 --> 00:23:54,450
called

00:23:51,220 --> 00:23:57,159
where we do compatibility decompositions

00:23:54,450 --> 00:23:58,610
these are more characters that they're

00:23:57,159 --> 00:24:01,220
in unicode even though they don't

00:23:58,610 --> 00:24:03,920
sit the definition of character mainly

00:24:01,220 --> 00:24:06,080
because some legacy encoding said they

00:24:03,920 --> 00:24:08,240
were separate and we don't want to break

00:24:06,080 --> 00:24:13,910
existing systems but we still want them

00:24:08,240 --> 00:24:15,380
to use Unicode these when you change

00:24:13,910 --> 00:24:18,200
them to their decomposition you can lose

00:24:15,380 --> 00:24:21,410
some meaning potentially in this case we

00:24:18,200 --> 00:24:23,510
have a superscript 5 Unicode recommends

00:24:21,410 --> 00:24:26,600
you not use the superscript characters

00:24:23,510 --> 00:24:28,460
if you want superscript use HTML use use

00:24:26,600 --> 00:24:30,500
a higher-level thing you can't nessam

00:24:28,460 --> 00:24:34,429
like this there's all sorts of problems

00:24:30,500 --> 00:24:37,850
just use HTML or text or math ml

00:24:34,429 --> 00:24:39,710
whatever makes sense for you but if you

00:24:37,850 --> 00:24:40,760
had existing data with this in there you

00:24:39,710 --> 00:24:43,970
would want to just convert it to five

00:24:40,760 --> 00:24:45,559
because maybe losing information but if

00:24:43,970 --> 00:24:47,150
all you care about is equivalence if you

00:24:45,559 --> 00:24:49,610
want to just say this is basically the

00:24:47,150 --> 00:24:52,360
same as five to me for my searching

00:24:49,610 --> 00:24:55,010
purposes or whatever you're using

00:24:52,360 --> 00:24:56,210
comparing strings for you can do that

00:24:55,010 --> 00:25:03,020
with normalization you'll get its

00:24:56,210 --> 00:25:05,150
compatibility decomposition so should

00:25:03,020 --> 00:25:06,770
you pass strings to normalize every time

00:25:05,150 --> 00:25:09,350
you want to compare them probably not

00:25:06,770 --> 00:25:13,760
that would be really tedious even if you

00:25:09,350 --> 00:25:14,929
have tractored out you what you really

00:25:13,760 --> 00:25:17,450
need to thing about is why are you

00:25:14,929 --> 00:25:19,179
comparing them in the first place can

00:25:17,450 --> 00:25:21,919
your database just do this for you if

00:25:19,179 --> 00:25:24,200
you have a text search engine like

00:25:21,919 --> 00:25:29,390
loosing or that's what elastic circ uses

00:25:24,200 --> 00:25:32,330
or as a peon or whoosh checking is Doc's

00:25:29,390 --> 00:25:37,010
does it do this normalization for you

00:25:32,330 --> 00:25:38,510
it really should be the main thing

00:25:37,010 --> 00:25:40,790
though is why are you comparing it most

00:25:38,510 --> 00:25:42,890
of the time it doesn't matter you don't

00:25:40,790 --> 00:25:44,540
have to normalize a lot of times when

00:25:42,890 --> 00:25:47,000
we're comparing string literals in

00:25:44,540 --> 00:25:50,540
actual code we're doing something like

00:25:47,000 --> 00:25:52,400
this we have a dictionary the keys are

00:25:50,540 --> 00:25:54,169
some internal values that we use maybe

00:25:52,400 --> 00:25:57,110
we use them as values in a database and

00:25:54,169 --> 00:26:00,049
then values the dictionary are our

00:25:57,110 --> 00:26:02,240
strings that we show to users and we're

00:26:00,049 --> 00:26:04,190
just doing a lookup these are just

00:26:02,240 --> 00:26:05,210
literals in our code we don't need to

00:26:04,190 --> 00:26:06,440
normalize them we know they're always

00:26:05,210 --> 00:26:08,860
going to be the same we don't need to

00:26:06,440 --> 00:26:08,860
worry about it

00:26:09,170 --> 00:26:12,350
if you're doing like a quick and dirty

00:26:11,210 --> 00:26:18,020
you just need to search through a bunch

00:26:12,350 --> 00:26:19,760
of strings then you may want to consider

00:26:18,020 --> 00:26:21,290
normalizing although you've started

00:26:19,760 --> 00:26:24,380
implementing a text search engine at

00:26:21,290 --> 00:26:28,460
this point so you should look into just

00:26:24,380 --> 00:26:30,620
using one of those instead if you want

00:26:28,460 --> 00:26:34,400
to do something like say make sure user

00:26:30,620 --> 00:26:38,270
names are unique think about why you

00:26:34,400 --> 00:26:40,370
want to do that most systems they end up

00:26:38,270 --> 00:26:41,960
restricting user names to a certain set

00:26:40,370 --> 00:26:43,670
of characters specifically because

00:26:41,960 --> 00:26:46,010
there's lots of different lists that

00:26:43,670 --> 00:26:47,150
look alike in different scripts if you

00:26:46,010 --> 00:26:49,640
look at internationalized domain names

00:26:47,150 --> 00:26:54,830
it's this problem in spades

00:26:49,640 --> 00:26:56,600
and it's very complicated to solve high

00:26:54,830 --> 00:26:59,170
case folding this isn't they were all

00:26:56,600 --> 00:27:02,000
familiar with because ask you does it

00:26:59,170 --> 00:27:06,380
the case folding code is littered

00:27:02,000 --> 00:27:09,680
throughout software from a Unicode

00:27:06,380 --> 00:27:13,850
respective there's simple case folding

00:27:09,680 --> 00:27:14,960
which is what Python 2 did the length of

00:27:13,850 --> 00:27:16,340
a string never changes you always

00:27:14,960 --> 00:27:18,200
replace one character with another

00:27:16,340 --> 00:27:19,700
character and we're just talking about

00:27:18,200 --> 00:27:22,490
folding when we just want to ignore

00:27:19,700 --> 00:27:25,340
casing distinctions we'll pull the two

00:27:22,490 --> 00:27:27,590
strings together and we'll expect

00:27:25,340 --> 00:27:31,240
well like to get the same string if that

00:27:27,590 --> 00:27:31,240
they don't if they differ only on casing

00:27:32,650 --> 00:27:38,990
Python three actually has what Unicode

00:27:35,600 --> 00:27:40,580
calls full case folding so you can see a

00:27:38,990 --> 00:27:44,480
few characters actually get a little

00:27:40,580 --> 00:27:46,460
longer this example is used in German

00:27:44,480 --> 00:27:48,680
but it's using the word for Street so

00:27:46,460 --> 00:27:50,180
you could very well if you take

00:27:48,680 --> 00:27:52,910
addresses you could very well have this

00:27:50,180 --> 00:27:55,100
character in your data Python 3 also

00:27:52,910 --> 00:27:56,630
adds a nice case fold method that is

00:27:55,100 --> 00:27:59,780
separate from having to pick lower or

00:27:56,630 --> 00:28:02,390
upper that makes there's certain edge

00:27:59,780 --> 00:28:04,610
cases that it handles correctly Python 3

00:28:02,390 --> 00:28:09,500
regex is still do the simple folding

00:28:04,610 --> 00:28:12,950
unfortunately apparently all right in

00:28:09,500 --> 00:28:18,230
general case casing isn't specific to

00:28:12,950 --> 00:28:20,450
language except turkish if you have a

00:28:18,230 --> 00:28:22,429
bunch of text that's Turkish or Azeri

00:28:20,450 --> 00:28:23,749
this viewer the languages that do this

00:28:22,429 --> 00:28:25,429
you have to case hold it a little

00:28:23,749 --> 00:28:28,129
differently if you want to match users

00:28:25,429 --> 00:28:29,149
expectations it's not too complicated I

00:28:28,129 --> 00:28:33,289
mean you can see the implementation

00:28:29,149 --> 00:28:35,240
right here essentially I with a dot is

00:28:33,289 --> 00:28:37,070
treated as its own thing whereas

00:28:35,240 --> 00:28:38,450
everyone else treats the dot on a

00:28:37,070 --> 00:28:42,350
lowercase I is weird

00:28:38,450 --> 00:28:43,970
optional lifting alright I mentioned in

00:28:42,350 --> 00:28:48,249
the talk description there are over a

00:28:43,970 --> 00:28:48,249
thousand latin letters here they are

00:28:48,879 --> 00:28:52,879
actually that's not quite true a few of

00:28:50,840 --> 00:28:56,809
these are numbers so let's color the

00:28:52,879 --> 00:28:59,799
numbers blue and the rest are all

00:28:56,809 --> 00:29:03,499
letters now a lot of these are

00:28:59,799 --> 00:29:04,639
canonically decomposable they're

00:29:03,499 --> 00:29:06,619
basically in there for round trip

00:29:04,639 --> 00:29:08,029
compatibility with legacy encodings so

00:29:06,619 --> 00:29:11,299
let's have those just disappear because

00:29:08,029 --> 00:29:13,970
we don't really care about those a lot

00:29:11,299 --> 00:29:16,340
of these are compatibility decomposable

00:29:13,970 --> 00:29:18,499
so let's just gray those out doesn't

00:29:16,340 --> 00:29:20,480
really matter that much to us all right

00:29:18,499 --> 00:29:22,460
now this is something kind of

00:29:20,480 --> 00:29:24,649
approaching all the Latin letters it's a

00:29:22,460 --> 00:29:26,869
lot more than you might expect

00:29:24,649 --> 00:29:28,850
they might look kind of strange but they

00:29:26,869 --> 00:29:31,129
are still a lot of them are letters that

00:29:28,850 --> 00:29:37,309
you can recognize you know it's like a D

00:29:31,129 --> 00:29:39,200
with a funny curly Q on it here we've

00:29:37,309 --> 00:29:40,879
ordered them a little assorted them a

00:29:39,200 --> 00:29:42,649
little differently to make it a little

00:29:40,879 --> 00:29:44,720
more obvious what's going on here you

00:29:42,649 --> 00:29:48,799
can see there's a B and then there's all

00:29:44,720 --> 00:29:50,720
different variants on B all the way down

00:29:48,799 --> 00:29:52,580
and sort of the ordering you'd expect

00:29:50,720 --> 00:29:54,139
even though you don't even recognize a

00:29:52,580 --> 00:29:58,100
lot of these this ordering is a little

00:29:54,139 --> 00:30:00,799
more intuitive than this one this one is

00:29:58,100 --> 00:30:02,139
code-point ordering you just look at the

00:30:00,799 --> 00:30:04,610
code points compare them as integers

00:30:02,139 --> 00:30:08,179
code point assignments are just an

00:30:04,610 --> 00:30:09,799
accident of history for English it's

00:30:08,179 --> 00:30:12,710
kind of annoying to use them for sorting

00:30:09,799 --> 00:30:15,850
for other languages it totally makes no

00:30:12,710 --> 00:30:18,740
sense to users whatsoever haha so I

00:30:15,850 --> 00:30:21,590
whereas this ordering actually is kind

00:30:18,740 --> 00:30:24,080
of intuitive and useful that brings us

00:30:21,590 --> 00:30:26,600
to collation and this is sorting

00:30:24,080 --> 00:30:28,070
specifically for display to humans if

00:30:26,600 --> 00:30:28,940
you just have an algorithm or sorting as

00:30:28,070 --> 00:30:30,049
a component of it

00:30:28,940 --> 00:30:31,389
it doesn't really matter how you sort

00:30:30,049 --> 00:30:35,490
you can sort by code point that's fine

00:30:31,389 --> 00:30:38,190
if you are showing a bunch of text to

00:30:35,490 --> 00:30:39,900
humans in your UI and you need to put it

00:30:38,190 --> 00:30:41,610
in an order of some sort this is how you

00:30:39,900 --> 00:30:44,460
should do it for people be able to find

00:30:41,610 --> 00:30:46,340
things in it sorting is sort of

00:30:44,460 --> 00:30:50,340
old-school search before those computers

00:30:46,340 --> 00:30:52,920
um in general you should use search to

00:30:50,340 --> 00:30:54,900
find stuff but that can be hard it can

00:30:52,920 --> 00:30:56,760
be hard to implement in whatever use

00:30:54,900 --> 00:30:59,220
case you have so a lot of times you do

00:30:56,760 --> 00:31:01,620
still end up with okay I've narrowed it

00:30:59,220 --> 00:31:03,150
down to this data now I need to show it

00:31:01,620 --> 00:31:04,110
to someone I need to show it to them in

00:31:03,150 --> 00:31:07,230
a way that they can find what they're

00:31:04,110 --> 00:31:11,010
looking for themselves so there's the

00:31:07,230 --> 00:31:14,010
Unicode collation algorithm by default

00:31:11,010 --> 00:31:16,280
it defines a pretty nice ordering that's

00:31:14,010 --> 00:31:18,900
what you saw on that previous slide

00:31:16,280 --> 00:31:22,350
collation believe it or not varies a lot

00:31:18,900 --> 00:31:25,410
how exactly you want to do it it varies

00:31:22,350 --> 00:31:27,660
by language of course even within a

00:31:25,410 --> 00:31:29,370
language it can vary German as to

00:31:27,660 --> 00:31:32,250
different orderings for phone books and

00:31:29,370 --> 00:31:34,410
dictionaries and even for individual

00:31:32,250 --> 00:31:36,600
users or individual programs it can vary

00:31:34,410 --> 00:31:38,700
you may have a preference about whether

00:31:36,600 --> 00:31:41,700
numbers come before letters whether

00:31:38,700 --> 00:31:45,000
upper case comes before lower case or if

00:31:41,700 --> 00:31:48,470
your user only uses Hebrew they probably

00:31:45,000 --> 00:31:53,400
want Hebrew to come first and not Latin

00:31:48,470 --> 00:31:55,970
so the the UCA in addition to a nice

00:31:53,400 --> 00:31:59,100
default ordering has a nice mechanism to

00:31:55,970 --> 00:32:01,620
define tailoring zuv that it's basically

00:31:59,100 --> 00:32:03,780
you're taking this existing thing which

00:32:01,620 --> 00:32:05,280
was a ton of work to come up with and

00:32:03,780 --> 00:32:10,620
you're just tweaking it to get the

00:32:05,280 --> 00:32:13,380
ordering you want in Python well first

00:32:10,620 --> 00:32:17,910
of all look at your database to see if

00:32:13,380 --> 00:32:19,530
it does this for you because that's a

00:32:17,910 --> 00:32:20,760
great place to be sorting text it's

00:32:19,530 --> 00:32:22,650
probably going to be faster than doing

00:32:20,760 --> 00:32:24,240
it in Python if you want to do it in

00:32:22,650 --> 00:32:27,900
Python there's a nice library called pi

00:32:24,240 --> 00:32:33,420
you see a by JK Tauber it's simple this

00:32:27,900 --> 00:32:35,100
is the API on the slide there's no way

00:32:33,420 --> 00:32:37,920
to really tailor it though it does work

00:32:35,100 --> 00:32:39,929
nice with them short you can give it a

00:32:37,920 --> 00:32:44,490
new data file where you have to define

00:32:39,929 --> 00:32:46,730
the ordering for everything yourself so

00:32:44,490 --> 00:32:48,290
that's not so great but when you

00:32:46,730 --> 00:32:50,900
want to put things in a better order

00:32:48,290 --> 00:32:53,330
than code-point order this is great on

00:32:50,900 --> 00:32:54,650
the left here you see punctuation it's

00:32:53,330 --> 00:32:57,650
kind of scattered around how it's

00:32:54,650 --> 00:33:00,290
handled is in sorting when this is using

00:32:57,650 --> 00:33:02,450
just code point ordering on the right

00:33:00,290 --> 00:33:04,070
you can see we zoom pie you see a and

00:33:02,450 --> 00:33:06,309
all the punctuation gets at the top all

00:33:04,070 --> 00:33:12,470
the single quotes are next to each other

00:33:06,309 --> 00:33:14,840
a lot more intuitive so let's look at

00:33:12,470 --> 00:33:18,320
some casing distinctions and also

00:33:14,840 --> 00:33:21,549
accents on characters what what is the

00:33:18,320 --> 00:33:23,990
sort order you would want these to be in

00:33:21,549 --> 00:33:25,549
is it that because that's a really nice

00:33:23,990 --> 00:33:28,340
sort I mean that's a really great

00:33:25,549 --> 00:33:29,929
collation if you want to know whether a

00:33:28,340 --> 00:33:31,730
particular string is in that list it's

00:33:29,929 --> 00:33:33,470
so much easier when you look at the list

00:33:31,730 --> 00:33:35,510
on the right

00:33:33,470 --> 00:33:39,410
getting there is a little complicated

00:33:35,510 --> 00:33:40,730
though and in order to do that we it's

00:33:39,410 --> 00:33:42,919
not just a matter of defining the sort

00:33:40,730 --> 00:33:45,490
key we need to define a multi-level sort

00:33:42,919 --> 00:33:48,260
key and that's what you see a does

00:33:45,490 --> 00:33:49,460
essentially were saying we're going to

00:33:48,260 --> 00:33:50,750
look at the most important differences

00:33:49,460 --> 00:33:53,150
first we're going to ignore case we're

00:33:50,750 --> 00:33:56,780
going to ignore accents and other things

00:33:53,150 --> 00:33:58,820
and if two strings are the same in at

00:33:56,780 --> 00:34:00,770
that level then we're going to look at

00:33:58,820 --> 00:34:02,690
the accents and use that to discern to

00:34:00,770 --> 00:34:04,460
distinguish them if it's still the same

00:34:02,690 --> 00:34:06,200
then you look at case and you fall back

00:34:04,460 --> 00:34:10,310
on looking at invisible control

00:34:06,200 --> 00:34:13,190
characters if you after so in general

00:34:10,310 --> 00:34:15,649
when you hand at UCA implementation a

00:34:13,190 --> 00:34:18,710
string what you get back is basically a

00:34:15,649 --> 00:34:20,929
topple events called weights and then

00:34:18,710 --> 00:34:23,899
that supple is what you then hand off to

00:34:20,929 --> 00:34:26,869
your actual sorting code here you can

00:34:23,899 --> 00:34:29,570
see a gets a primary secondary tertiary

00:34:26,869 --> 00:34:32,690
weight and when you concatenate the two

00:34:29,570 --> 00:34:34,399
strings the weights get interleaved now

00:34:32,690 --> 00:34:36,020
you can't just concatenate those sort

00:34:34,399 --> 00:34:37,399
keys together you have to give a new

00:34:36,020 --> 00:34:39,859
string you have to ask for a noose or

00:34:37,399 --> 00:34:41,330
key and this is how we get that nice

00:34:39,859 --> 00:34:44,109
ordering because we're looking at the

00:34:41,330 --> 00:34:44,109
primary weights first

00:34:45,880 --> 00:34:49,630
so let's look at actually customizing

00:34:47,770 --> 00:34:52,210
this collation a little bit it's not

00:34:49,630 --> 00:34:54,160
easy to do with pie you see a both we

00:34:52,210 --> 00:34:56,680
can with a lot with the Python bindings

00:34:54,160 --> 00:34:59,500
for the ICU library I don't if you've

00:34:56,680 --> 00:35:04,150
used the ICU library before it's sort of

00:34:59,500 --> 00:35:06,370
a behemoth from the C++ Java world it

00:35:04,150 --> 00:35:07,840
does have Python bindings though you can

00:35:06,370 --> 00:35:09,310
install it with tip you have to set a

00:35:07,840 --> 00:35:11,280
weird environment variable but it's

00:35:09,310 --> 00:35:14,250
doable

00:35:11,280 --> 00:35:17,080
there's the API documentation for Python

00:35:14,250 --> 00:35:19,180
it doesn't have any it tells you to look

00:35:17,080 --> 00:35:21,820
at the few poles post api's that's not

00:35:19,180 --> 00:35:22,750
great but it does do a lot and it's very

00:35:21,820 --> 00:35:24,610
useful

00:35:22,750 --> 00:35:29,800
despite its API invites and also being

00:35:24,610 --> 00:35:32,710
very ugly here you can see we made a KO

00:35:29,800 --> 00:35:34,660
later it's going to give us keys and

00:35:32,710 --> 00:35:36,970
here we've customized it a bit we've

00:35:34,660 --> 00:35:39,640
told it punctuation we've essentially

00:35:36,970 --> 00:35:41,860
told it punctuation matters to us less

00:35:39,640 --> 00:35:43,990
than everything else and that's how we

00:35:41,860 --> 00:35:46,990
get this great ordering where those

00:35:43,990 --> 00:35:51,430
quotes don't matter until it's a last

00:35:46,990 --> 00:35:54,630
resort so the word Punk gets sorted

00:35:51,430 --> 00:36:01,900
right after punking all sorts of quotes

00:35:54,630 --> 00:36:03,850
which is pretty nice alright so there's

00:36:01,900 --> 00:36:08,680
one more sort of caveat to using the UCA

00:36:03,850 --> 00:36:10,330
that's if you have tabular data you can

00:36:08,680 --> 00:36:12,250
imagine this is a tiny little slice of a

00:36:10,330 --> 00:36:14,400
database really anytime you have tabular

00:36:12,250 --> 00:36:14,400
data

00:36:23,220 --> 00:36:40,349
okay okay well we only have five more

00:36:37,390 --> 00:36:40,349
minutes I'm just gonna keep talking

00:36:42,509 --> 00:36:52,630
great all right okay

00:36:48,759 --> 00:36:54,789
anyway we want to sort these like you

00:36:52,630 --> 00:36:57,400
want to do first sort by column one then

00:36:54,789 --> 00:36:58,869
sort by column two you can't just sort

00:36:57,400 --> 00:37:02,950
by column one then two because you're

00:36:58,869 --> 00:37:04,450
going to end up with what you've said

00:37:02,950 --> 00:37:06,190
reminder distinctions in the first

00:37:04,450 --> 00:37:07,900
column like accents in casings they're

00:37:06,190 --> 00:37:09,509
going to swamp out more important

00:37:07,900 --> 00:37:12,819
distinctions to you in the second column

00:37:09,509 --> 00:37:15,249
here we want Fred and John to be next to

00:37:12,819 --> 00:37:20,289
each other because the first column only

00:37:15,249 --> 00:37:21,759
differs by accents in casing so yeah so

00:37:20,289 --> 00:37:23,440
here's why that's happening you're

00:37:21,759 --> 00:37:24,970
essentially looking at third level

00:37:23,440 --> 00:37:26,410
weights in that first column before

00:37:24,970 --> 00:37:30,819
you're looking at first level weights in

00:37:26,410 --> 00:37:32,229
the second column what you want to do is

00:37:30,819 --> 00:37:33,940
merge them together look at the first

00:37:32,229 --> 00:37:35,259
level weights in the in the first column

00:37:33,940 --> 00:37:36,849
look at the first level way from the

00:37:35,259 --> 00:37:37,960
second column then look at the second

00:37:36,849 --> 00:37:41,619
level weights in the first column and so

00:37:37,960 --> 00:37:42,880
on how do we do that what's kind of like

00:37:41,619 --> 00:37:44,049
when we concatenate the strings before

00:37:42,880 --> 00:37:47,319
so maybe we can concatenate them

00:37:44,049 --> 00:37:49,210
together that doesn't actually work it

00:37:47,319 --> 00:37:51,609
gives you a nice ordering but it also

00:37:49,210 --> 00:37:57,309
gives you a confusing ordering where the

00:37:51,609 --> 00:37:59,619
shorter strings got put after it so the

00:37:57,309 --> 00:38:00,700
cldr defines a whole bunch of stuff if

00:37:59,619 --> 00:38:03,099
you remember I said it's like a big

00:38:00,700 --> 00:38:05,049
database of locale data one of the

00:38:03,099 --> 00:38:06,819
things it does is it has its own default

00:38:05,049 --> 00:38:09,160
ordering that improves on the UCA a

00:38:06,819 --> 00:38:13,779
little bit one of the things that does

00:38:09,160 --> 00:38:16,839
is define a weight for this special code

00:38:13,779 --> 00:38:18,880
point FFF e this is a non character code

00:38:16,839 --> 00:38:21,039
point not shouldn't ever occur in text

00:38:18,880 --> 00:38:27,369
it's to use specifically for stuff like

00:38:21,039 --> 00:38:31,029
this the NICU uses the cldr data so it's

00:38:27,369 --> 00:38:33,039
default collation is the cldr one so if

00:38:31,029 --> 00:38:33,910
you join those strings with that special

00:38:33,039 --> 00:38:35,950
code point

00:38:33,910 --> 00:38:39,069
then you finally get the ordering you

00:38:35,950 --> 00:38:42,690
want where you're getting the first

00:38:39,069 --> 00:38:46,180
level distinctions on both columns and

00:38:42,690 --> 00:38:48,039
that's it I believe I have what a minute

00:38:46,180 --> 00:39:03,990
or two questions if you want to talk

00:38:48,039 --> 00:39:07,660
over a fire alarm no questions

00:39:03,990 --> 00:39:11,140
okay the slides will be on SlideShare

00:39:07,660 --> 00:39:12,910
under the pike on 2017 section and my

00:39:11,140 --> 00:39:15,020
references are all in the last one thank

00:39:12,910 --> 00:39:20,579
you

00:39:15,020 --> 00:39:20,579

YouTube URL: https://www.youtube.com/watch?v=bx3NOoroV-M


