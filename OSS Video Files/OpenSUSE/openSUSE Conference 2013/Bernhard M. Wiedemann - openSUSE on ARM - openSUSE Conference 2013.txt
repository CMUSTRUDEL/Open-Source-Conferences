Title: Bernhard M. Wiedemann - openSUSE on ARM - openSUSE Conference 2013
Publication date: 2013-07-22
Playlist: openSUSE Conference 2013
Description: 
	How to build with OBS

Normally it is a hard task to port a whole distribution to a new CPU platform, since not all packages allow for cross-compilation.
This is why openSUSE went a different way by building pseudo-native with qemu.
This presentation will be about how OBS, qemu and some other tools and tricks were used to efficiently build packages for ARM (aarch64, armv7l, armv5el).
Captions: 
	00:00:00,000 --> 00:00:08,250
which time for mr. bear heart video man

00:00:02,760 --> 00:00:11,580
to talk about opensuse own arm yes thank

00:00:08,250 --> 00:00:15,059
you very much for coming I'm from

00:00:11,580 --> 00:00:17,279
Lynbrook working for Souza and I have

00:00:15,059 --> 00:00:19,590
spent some time working on because I

00:00:17,279 --> 00:00:22,710
have some devices at home like an

00:00:19,590 --> 00:00:27,359
Raspberry Pi which I wanted to work with

00:00:22,710 --> 00:00:32,579
opensuse and so I will explain how we

00:00:27,359 --> 00:00:34,829
built armed with our blood servers how

00:00:32,579 --> 00:00:37,320
you can build your own software for arm

00:00:34,829 --> 00:00:41,460
even if you just have an Indian machine

00:00:37,320 --> 00:00:47,969
at home and maybe some more if you have

00:00:41,460 --> 00:00:50,039
questions so and we just start why we do

00:00:47,969 --> 00:00:52,590
or set up for the video which doesn't

00:00:50,039 --> 00:00:54,480
work on my laptop and others didn't have

00:00:52,590 --> 00:00:59,940
LibreOffice on it so it's a bit

00:00:54,480 --> 00:01:02,399
complicated today so um for the start we

00:00:59,940 --> 00:01:05,760
have the open boat service which is very

00:01:02,399 --> 00:01:08,280
nice software where you have one source

00:01:05,760 --> 00:01:12,890
code package with a description how to

00:01:08,280 --> 00:01:16,560
build it and how to install it and there

00:01:12,890 --> 00:01:21,930
we are during the last two years and

00:01:16,560 --> 00:01:26,130
support for arm and when you want to

00:01:21,930 --> 00:01:29,130
build for a new platform you usually try

00:01:26,130 --> 00:01:31,170
a cross compiling which means you run a

00:01:29,130 --> 00:01:33,329
compiler on an inter platform that

00:01:31,170 --> 00:01:39,090
produces binaries that are meant to run

00:01:33,329 --> 00:01:40,799
on arm and that works very well for a

00:01:39,090 --> 00:01:43,320
building a colonel and the G lipsy

00:01:40,799 --> 00:01:46,470
entering GCC because these packages are

00:01:43,320 --> 00:01:48,390
made to be cross compared this way but

00:01:46,470 --> 00:01:51,600
it does not work for all packages

00:01:48,390 --> 00:01:54,299
because some packages have a tool that

00:01:51,600 --> 00:01:57,180
is compiled during the time and that

00:01:54,299 --> 00:01:59,070
need that tool to be called during good

00:01:57,180 --> 00:02:01,469
time as well so you cannot build this

00:01:59,070 --> 00:02:03,979
tool for arm because then you can not

00:02:01,469 --> 00:02:07,920
run this binary on your implementing

00:02:03,979 --> 00:02:11,459
yeah and these packages are very hard to

00:02:07,920 --> 00:02:13,819
do usually so we did a trick for

00:02:11,459 --> 00:02:13,819
building

00:02:14,480 --> 00:02:33,870
what if half an hour today yep so we

00:02:29,010 --> 00:02:36,989
have some time left um yeah as a cross

00:02:33,870 --> 00:02:41,970
compiling yeah we did differencing using

00:02:36,989 --> 00:02:46,380
kuya qmo and IQ me can emulate the whole

00:02:41,970 --> 00:02:48,480
CPU so we set up a change food

00:02:46,380 --> 00:02:51,630
environment where we have all the arm

00:02:48,480 --> 00:02:54,750
packages in there and there we installed

00:02:51,630 --> 00:02:57,200
a compiler forearm and bash forearm and

00:02:54,750 --> 00:03:01,500
an RPM forearm and we built everything

00:02:57,200 --> 00:03:03,569
as arm binaries and the only downside of

00:03:01,500 --> 00:03:06,360
that is that it's very slow because it's

00:03:03,569 --> 00:03:09,569
emulating the arm CPU on into the host

00:03:06,360 --> 00:03:12,290
machine and when you want to compile it

00:03:09,569 --> 00:03:17,130
you spend a lot of CPU cycles compiling

00:03:12,290 --> 00:03:20,459
so it took maybe several months to get a

00:03:17,130 --> 00:03:26,299
factory package was built and that was

00:03:20,459 --> 00:03:31,829
too slow so we did some nice trick there

00:03:26,299 --> 00:03:36,959
which was codenamed Akuma axle and that

00:03:31,829 --> 00:03:41,519
involved a one tiny patch to Q me which

00:03:36,959 --> 00:03:51,890
was when a program in this change route

00:03:41,519 --> 00:03:51,890
ah ah we got slides better than mine

00:03:53,030 --> 00:04:01,260
yeah so this nice patch for Q me was

00:03:58,109 --> 00:04:04,410
that whenever there's an exit call in a

00:04:01,260 --> 00:04:09,450
program telling ok and now run this

00:04:04,410 --> 00:04:11,730
program like run use urban GCC it will

00:04:09,450 --> 00:04:17,639
check in another alternative pass under

00:04:11,730 --> 00:04:21,090
/ email / x86 64 if it has there a user

00:04:17,639 --> 00:04:23,640
pin GCC and if it has it runs this

00:04:21,090 --> 00:04:25,639
native binary was it a native libraries

00:04:23,640 --> 00:04:30,080
are next to it

00:04:25,639 --> 00:04:32,569
and then the compiler was much faster

00:04:30,080 --> 00:04:39,529
again because it's just a native GCC

00:04:32,569 --> 00:04:43,060
binary running and let's get up factory

00:04:39,529 --> 00:04:46,009
building by a factor of 5 46 maybe even

00:04:43,060 --> 00:04:49,689
so it only took a week to build a whole

00:04:46,009 --> 00:04:53,860
Factory treason was a queue my eccentric

00:04:49,689 --> 00:04:57,949
and as a second part of humor axial

00:04:53,860 --> 00:05:03,229
force a package that contains as

00:04:57,949 --> 00:05:06,580
cross-compiler another / in a pass so

00:05:03,229 --> 00:05:06,580
that it would be used by the

00:05:06,879 --> 00:05:15,169
acceleration layer so on finally when we

00:05:12,500 --> 00:05:18,169
had all those nice tricks that up there

00:05:15,169 --> 00:05:21,279
rife new hardware from Samsung which was

00:05:18,169 --> 00:05:26,360
called X who knows boards and they had a

00:05:21,279 --> 00:05:28,870
cortex a15 CPUs and these cortex a15 sea

00:05:26,360 --> 00:05:31,669
views were able to run kvm

00:05:28,870 --> 00:05:35,750
virtualization which is Halloween

00:05:31,669 --> 00:05:38,629
normally do building in OBS because of

00:05:35,750 --> 00:05:41,479
the separation so that the coatis this

00:05:38,629 --> 00:05:48,289
building cannot do any harm to the

00:05:41,479 --> 00:05:52,930
system and to the network so when we had

00:05:48,289 --> 00:05:56,449
at a hardware we could build arm

00:05:52,930 --> 00:06:03,649
natively on these arm boards on the

00:05:56,449 --> 00:06:08,529
Samsung Exynos BOTS and there's

00:06:03,649 --> 00:06:12,589
something yeah I don't know nevermind

00:06:08,529 --> 00:06:15,529
yeah so on cortex a15 we could use kvm

00:06:12,589 --> 00:06:18,020
to just build in a virtual machine for

00:06:15,529 --> 00:06:21,439
the separation and have a clean build

00:06:18,020 --> 00:06:24,409
ideas to have a clean build so no

00:06:21,439 --> 00:06:27,469
download link on the internet because

00:06:24,409 --> 00:06:28,849
otherwise someone takes a site down and

00:06:27,469 --> 00:06:31,939
you can't do it anymore and you don't

00:06:28,849 --> 00:06:37,099
want to set you want right ripred usable

00:06:31,939 --> 00:06:38,719
built in OBS so we are building from the

00:06:37,099 --> 00:06:39,289
source packages that we have there and

00:06:38,719 --> 00:06:41,899
from the pie

00:06:39,289 --> 00:06:45,439
reset we're good before like the binding

00:06:41,899 --> 00:06:48,469
GCC that's needed for building so

00:06:45,439 --> 00:06:53,629
meanwhile we have over a year maybe even

00:06:48,469 --> 00:06:56,599
two years or arm this morning you have

00:06:53,629 --> 00:06:58,879
opensuse trev 3am built completely

00:06:56,599 --> 00:07:06,139
forearm and released as part of the

00:06:58,879 --> 00:07:11,349
referee release and we have some arm v6

00:07:06,139 --> 00:07:16,309
for the Raspberry Pi especially which is

00:07:11,349 --> 00:07:18,379
currently getting better and I had made

00:07:16,309 --> 00:07:21,050
some only five images before for the

00:07:18,379 --> 00:07:22,879
Raspberry Pi which I have on my own

00:07:21,050 --> 00:07:26,889
servers because I didn't use the

00:07:22,879 --> 00:07:34,779
standard TV image building Michigan sins

00:07:26,889 --> 00:07:39,319
yeah and these legs it's like a hard um

00:07:34,779 --> 00:07:42,979
yeah so one thing I would have liked to

00:07:39,319 --> 00:07:46,699
show us how to do it um it's actually

00:07:42,979 --> 00:07:52,759
very easy you install the OSC package on

00:07:46,699 --> 00:07:57,259
your x86 64 machine and then you do a

00:07:52,759 --> 00:08:01,999
check out which is OC check out opensuse

00:07:57,259 --> 00:08:04,639
factory arm just opposite the Colin

00:08:01,999 --> 00:08:07,099
factories a cup of tea eff and Colin and

00:08:04,639 --> 00:08:10,189
arm so I'll kept to the address and then

00:08:07,099 --> 00:08:14,269
package name for example frozen bubble

00:08:10,189 --> 00:08:16,490
is a nice package and then it creates a

00:08:14,269 --> 00:08:19,789
check out of the source code then you

00:08:16,490 --> 00:08:23,899
change into this directory and call or

00:08:19,789 --> 00:08:27,399
see build and OC boot take some extra

00:08:23,899 --> 00:08:29,779
parameters behind to tell it which

00:08:27,399 --> 00:08:36,459
architecture you want to build and say

00:08:29,779 --> 00:08:38,930
you say for example arm v6 HL l v6 l

00:08:36,459 --> 00:08:42,769
whereas the first is a name of the

00:08:38,930 --> 00:08:44,899
repository which is just string and the

00:08:42,769 --> 00:08:48,889
second is actually is architecture to

00:08:44,899 --> 00:08:51,980
build so and then it will download all

00:08:48,889 --> 00:08:52,360
the binaries compilers beshte p.m. which

00:08:51,980 --> 00:08:55,240
in

00:08:52,360 --> 00:09:01,510
to build and it will install a change

00:08:55,240 --> 00:09:03,610
route under water buildroot and then it

00:09:01,510 --> 00:09:06,760
will change into the strange route and

00:09:03,610 --> 00:09:12,700
do all the building with a normal RPM

00:09:06,760 --> 00:09:16,510
bit processor and on your x 86 machine

00:09:12,700 --> 00:09:21,339
that will use humor with a nice with

00:09:16,510 --> 00:09:25,089
this magical there's a bin format miss

00:09:21,339 --> 00:09:27,670
Kyung magic where you can tell the

00:09:25,089 --> 00:09:30,430
colonel if you see a binary that slot

00:09:27,670 --> 00:09:34,269
was this string you need to use this

00:09:30,430 --> 00:09:38,350
emulator to call it and that's the

00:09:34,269 --> 00:09:42,610
script and setups ascona magic which is

00:09:38,350 --> 00:09:48,190
something like cumo bin format conf dot

00:09:42,610 --> 00:09:50,200
sh and i was this magic set up and you

00:09:48,190 --> 00:09:52,839
can just change food into this directory

00:09:50,200 --> 00:09:55,540
and when you then call a you named ash a

00:09:52,839 --> 00:09:58,180
it will tell you that you are an armed

00:09:55,540 --> 00:10:03,399
machine even yeah in reality were just

00:09:58,180 --> 00:10:05,170
into but simulation and does this so and

00:10:03,399 --> 00:10:07,470
in there's the splitting happens and

00:10:05,170 --> 00:10:12,399
it's and you just get a binary out here

00:10:07,470 --> 00:10:15,250
of the build process so what is it good

00:10:12,399 --> 00:10:18,250
for for example if you see some failure

00:10:15,250 --> 00:10:20,949
you see oh there is a package of failing

00:10:18,250 --> 00:10:25,360
only on arm but on x86 it's normally

00:10:20,949 --> 00:10:27,430
working you can do this check out a very

00:10:25,360 --> 00:10:31,029
fun in your local machine with Aussie

00:10:27,430 --> 00:10:35,290
boot where it's failing and analyze and

00:10:31,029 --> 00:10:37,959
the change route what is a real problem

00:10:35,290 --> 00:10:40,180
behind it and once you know what you do

00:10:37,959 --> 00:10:43,620
you fix and to a submit requests like

00:10:40,180 --> 00:10:49,529
you normally do contributing in factory

00:10:43,620 --> 00:10:55,740
and when the submit request is effect

00:10:49,529 --> 00:10:58,750
accepted to factory and it should be

00:10:55,740 --> 00:11:02,769
getting good automatically on the server

00:10:58,750 --> 00:11:06,349
side again and then

00:11:02,769 --> 00:11:09,199
it should be working and be better and

00:11:06,349 --> 00:11:12,949
everything will be heavy and nice

00:11:09,199 --> 00:11:15,019
afterwards yeah so we have a nice way to

00:11:12,949 --> 00:11:19,009
contribute to arm even if you don't have

00:11:15,019 --> 00:11:24,169
arm hardware right away that's a nice

00:11:19,009 --> 00:11:35,569
thing there with this simulation yeah so

00:11:24,169 --> 00:11:42,309
any questions yeah so I would you know

00:11:35,569 --> 00:11:54,199
how to build arm now yeah great huh

00:11:42,309 --> 00:11:57,259
there's a question um microphone show

00:11:54,199 --> 00:12:01,089
about compatibility if I have a package

00:11:57,259 --> 00:12:05,809
for x86 and I want to convert to arm

00:12:01,089 --> 00:12:08,949
what must i do to how much should i do

00:12:05,809 --> 00:12:11,029
it you need to recompile the source

00:12:08,949 --> 00:12:14,720
because it's a completely different

00:12:11,029 --> 00:12:17,089
architecture so you say takes a source

00:12:14,720 --> 00:12:21,949
code of your package the source app for

00:12:17,089 --> 00:12:24,559
example and yeah usually you will have

00:12:21,949 --> 00:12:29,359
this package in OBS already and then you

00:12:24,559 --> 00:12:33,049
just do an check out like osu check out

00:12:29,359 --> 00:12:37,309
this package from OBS and then you say

00:12:33,049 --> 00:12:39,199
oh it's a bit but if it's not in factory

00:12:37,309 --> 00:12:41,569
it's a bit more difficult because you

00:12:39,199 --> 00:12:45,499
have to give minus minus alternative

00:12:41,569 --> 00:12:47,359
project opensuse factory arm as an

00:12:45,499 --> 00:12:49,489
additional parameter to tell it that you

00:12:47,359 --> 00:12:52,999
wanted to build against that project

00:12:49,489 --> 00:12:55,809
with dependencies and we have a portal

00:12:52,999 --> 00:13:00,289
page on the envelope user dot org slash

00:12:55,809 --> 00:13:03,529
portal Colin arm and there's a link to

00:13:00,289 --> 00:13:08,059
how to build this identity of project

00:13:03,529 --> 00:13:10,759
mythology so so in general you takes

00:13:08,059 --> 00:13:13,249
your source code you built for armed

00:13:10,759 --> 00:13:15,049
with a compiler so it creates on

00:13:13,249 --> 00:13:18,769
binaries and then you have your arm

00:13:15,049 --> 00:13:21,489
package instead of an x86 package so you

00:13:18,769 --> 00:13:24,829
don't need to modify the source code

00:13:21,489 --> 00:13:27,249
normally not most packages just built

00:13:24,829 --> 00:13:31,549
and sometimes there are some problems

00:13:27,249 --> 00:13:35,239
for example if you have special types

00:13:31,549 --> 00:13:37,819
like character and on into a character

00:13:35,239 --> 00:13:42,049
is unsigned as the value between 0 and

00:13:37,819 --> 00:13:46,669
255 and on arm that's sign so it's a way

00:13:42,049 --> 00:13:49,369
you between minus 128 and plus 127 and

00:13:46,669 --> 00:13:52,369
these small differences between

00:13:49,369 --> 00:13:55,279
definitions and compilers can break

00:13:52,369 --> 00:13:58,839
things but normally it's ok and so it

00:13:55,279 --> 00:13:58,839
just works ok

00:14:00,110 --> 00:14:31,100
I have a question too what about if this

00:14:10,339 --> 00:14:34,610
also use some good okay so if you use

00:14:31,100 --> 00:14:41,209
some comets like a VX on the sorcerer

00:14:34,610 --> 00:14:47,120
what you build it for x86 it's easy to

00:14:41,209 --> 00:14:50,269
compile for armor than my gosh it's not

00:14:47,120 --> 00:14:55,640
so good yeah you usually it's nearly as

00:14:50,269 --> 00:15:11,170
easy like make make install so usual

00:14:55,640 --> 00:15:16,990
things I pump I binary stuff and the mix

00:15:11,170 --> 00:15:16,990
awkward ok not sure

00:15:20,720 --> 00:15:26,249
yeah you don't have special CPU

00:15:23,789 --> 00:15:30,839
instructions from into like mm aches or

00:15:26,249 --> 00:15:34,679
SSE on arm but arm has its own vector

00:15:30,839 --> 00:15:39,449
instructions called neon which is only

00:15:34,679 --> 00:15:42,569
available in your arms yeah but usually

00:15:39,449 --> 00:15:44,609
the compiler cares about that except if

00:15:42,569 --> 00:15:46,769
you have assembler code and if you have

00:15:44,609 --> 00:15:50,579
a seminal code that's specific to x86

00:15:46,769 --> 00:15:53,399
you have either to provide a generic see

00:15:50,579 --> 00:15:56,279
implementation that just does it an c

00:15:53,399 --> 00:16:00,329
code or provide armed assembler instead

00:15:56,279 --> 00:16:02,729
just very hard in the end because

00:16:00,329 --> 00:16:05,639
there's not just one arm platform but

00:16:02,729 --> 00:16:07,979
assam b5 and b6 are we serving this some

00:16:05,639 --> 00:16:11,999
extensions and some extensions are only

00:16:07,979 --> 00:16:16,169
optional because there's not a single

00:16:11,999 --> 00:16:20,189
arm cpu but there's an arm core and some

00:16:16,169 --> 00:16:25,649
arm extensions that silicon makers can

00:16:20,189 --> 00:16:28,739
or cannot add so it depends a bit yeah

00:16:25,649 --> 00:16:31,709
but usually you just say your compiler

00:16:28,739 --> 00:16:33,169
here's my C code and compile it and you

00:16:31,709 --> 00:16:41,639
don't want to use assembler these days

00:16:33,169 --> 00:16:43,679
except if you really really must okay if

00:16:41,639 --> 00:16:46,949
you are interested how it looks like how

00:16:43,679 --> 00:16:49,379
the port is done it's all done in the

00:16:46,949 --> 00:16:51,449
open field service and the the current

00:16:49,379 --> 00:16:55,949
development project is open to the

00:16:51,449 --> 00:16:58,139
factory colon arm so everybody can go

00:16:55,949 --> 00:17:00,539
see I can check what's the status is

00:16:58,139 --> 00:17:03,659
what's currently broken and there are

00:17:00,539 --> 00:17:09,539
also several projects which produces

00:17:03,659 --> 00:17:16,949
images for various hardware so time is

00:17:09,539 --> 00:17:22,079
up or one last question I would like to

00:17:16,949 --> 00:17:25,500
know is are you working on Colonel

00:17:22,079 --> 00:17:27,809
flavor forearm yes a multiple colonel

00:17:25,500 --> 00:17:30,929
flavors because every on board needs its

00:17:27,809 --> 00:17:31,980
own kernel because there's no pci bus

00:17:30,929 --> 00:17:35,520
where can vary

00:17:31,980 --> 00:17:37,830
what hardware is there but it's mostly

00:17:35,520 --> 00:17:40,740
one ship which has everything built in

00:17:37,830 --> 00:17:44,820
and you need to have a special kernel

00:17:40,740 --> 00:17:47,429
for this job usually why you can't have

00:17:44,820 --> 00:17:49,440
one cat knell for all our devices

00:17:47,429 --> 00:17:52,740
implement yeah it's a work in progress

00:17:49,440 --> 00:17:55,490
or a call that's that's the question

00:17:52,740 --> 00:17:59,040
what's the status of which is work yeah

00:17:55,490 --> 00:18:03,000
the code name is device tree and where

00:17:59,040 --> 00:18:07,230
you have some description for a certain

00:18:03,000 --> 00:18:11,549
layout of hardware but I just know it's

00:18:07,230 --> 00:18:15,240
improving but I think you can run five

00:18:11,549 --> 00:18:18,150
of six five six different ports with one

00:18:15,240 --> 00:18:21,000
colonel but you still have all the other

00:18:18,150 --> 00:18:24,390
old hardware with their especially the

00:18:21,000 --> 00:18:27,870
separate kernels and what is the status

00:18:24,390 --> 00:18:31,100
in opensuse is someone working on us i

00:18:27,870 --> 00:18:35,549
mean you know unification yeah of kernel

00:18:31,100 --> 00:18:40,020
or not to do the things you said are

00:18:35,549 --> 00:18:41,940
mostly done in upstream yes most of it

00:18:40,020 --> 00:18:45,419
happens upstream but we have one kernel

00:18:41,940 --> 00:18:47,100
package for multiple ports and then we

00:18:45,419 --> 00:18:49,770
have the special flavors which you

00:18:47,100 --> 00:18:54,480
recognized by the dash panel board or

00:18:49,770 --> 00:19:01,860
dash IM exam singh saw the chip specific

00:18:54,480 --> 00:19:08,940
extensions on the end thanks yeah any

00:19:01,860 --> 00:19:11,990
more questions from IRG oh ok so thank

00:19:08,940 --> 00:19:11,990
you all for attending

00:19:16,200 --> 00:19:19,440

YouTube URL: https://www.youtube.com/watch?v=X46mvaquQdw


