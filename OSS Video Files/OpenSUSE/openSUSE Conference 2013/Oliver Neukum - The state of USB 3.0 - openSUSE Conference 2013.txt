Title: Oliver Neukum - The state of USB 3.0 - openSUSE Conference 2013
Publication date: 2013-07-22
Playlist: openSUSE Conference 2013
Description: 
	This talk focuses on USB 3.0 compared to USB 2.0, its conceptual changes, new features and the state of the implementation in the kernel.

I'll do a short overview of the changes at the hardware level.
That includes the dropping of companion controllers, addressing done in hardware and the introduction of a new mid-level, which is called "function", into the device architecture.

The main new features covered are stream support and new features of power management at the function and link level.
The kernel API for streams is introduced and the extension to usbfs is discussed. The automatic link level power states are featured.

The state of the XHCI support in the kernel is described. How the device model fails to represent the function level is discussed.
Captions: 
	00:00:00,000 --> 00:00:11,370
Oliver a moment he talked to us about

00:00:03,000 --> 00:00:14,610
the state of USB 3.0 good morning from

00:00:11,370 --> 00:00:18,720
me again so I am going to talk about USB

00:00:14,610 --> 00:00:21,180
3 dot 0 today and I'll first talk about

00:00:18,720 --> 00:00:24,000
the new things in the standard then

00:00:21,180 --> 00:00:26,910
about what the host control

00:00:24,000 --> 00:00:29,640
implementation does if you related

00:00:26,910 --> 00:00:32,550
miscellaneous things that are too nice

00:00:29,640 --> 00:00:34,770
to miss out what your kernel can do for

00:00:32,550 --> 00:00:38,309
you and more importantly where it still

00:00:34,770 --> 00:00:41,579
needs your help and a short outlook

00:00:38,309 --> 00:00:48,059
about what is probably going to happen

00:00:41,579 --> 00:00:54,270
in USB land after 30 so let's begin with

00:00:48,059 --> 00:00:59,699
the standard itself well it features

00:00:54,270 --> 00:01:02,489
what you all like more speed as those

00:00:59,699 --> 00:01:04,890
things are growing in size our speed has

00:01:02,489 --> 00:01:07,710
to increase as well or at one point we

00:01:04,890 --> 00:01:12,659
would be unable to get our data on them

00:01:07,710 --> 00:01:15,509
or of them it improves power management

00:01:12,659 --> 00:01:20,100
so we can use less power although we

00:01:15,509 --> 00:01:23,159
increase speed it provides more power

00:01:20,100 --> 00:01:26,040
per port which is something very many

00:01:23,159 --> 00:01:29,250
people always keep asking about I want

00:01:26,040 --> 00:01:32,640
more power and it does quicker

00:01:29,250 --> 00:01:36,030
enumeration of devices this allows

00:01:32,640 --> 00:01:38,189
faster boot times obviously it's mostly

00:01:36,030 --> 00:01:43,759
done in hardware so I won't talk any

00:01:38,189 --> 00:01:49,070
more about it so speed improvements

00:01:43,759 --> 00:01:52,770
they're basically three major ways of

00:01:49,070 --> 00:01:56,189
increasing speed first and foremost we

00:01:52,770 --> 00:01:58,380
changed the wire protocol we've

00:01:56,189 --> 00:02:01,079
introduced a new feature called stream

00:01:58,380 --> 00:02:05,490
support about with which I will talk a

00:02:01,079 --> 00:02:08,840
bit in detail later and we've softened

00:02:05,490 --> 00:02:11,330
the concept of master and slave under

00:02:08,840 --> 00:02:16,250
USB 2 dot 0

00:02:11,330 --> 00:02:19,130
a device spoke only when spoken to this

00:02:16,250 --> 00:02:21,140
has the obvious advantage that there is

00:02:19,130 --> 00:02:25,250
no question of arbitration on the bus

00:02:21,140 --> 00:02:28,820
and has the necessary disadvantage that

00:02:25,250 --> 00:02:33,410
the host had to ask even if there was no

00:02:28,820 --> 00:02:36,920
data available which means bandwidth is

00:02:33,410 --> 00:02:41,930
wasted and power is wasted we don't do

00:02:36,920 --> 00:02:45,830
that anymore so the wire speed has gone

00:02:41,930 --> 00:02:48,200
to five gigabits per second that has

00:02:45,830 --> 00:02:52,520
basically been achieved by stealing the

00:02:48,200 --> 00:02:56,480
wire protocol from eSATA and the bus is

00:02:52,520 --> 00:02:59,240
now full duplex so in theory you can do

00:02:56,480 --> 00:03:03,110
10 gigabits per second only in theory

00:02:59,240 --> 00:03:05,750
and we now finally provide nine hundred

00:03:03,110 --> 00:03:10,450
milliamps per second for a socket not

00:03:05,750 --> 00:03:10,450
per second 1-ranked solutions / socket a

00:03:11,830 --> 00:03:18,410
major change in the architecture has

00:03:14,750 --> 00:03:22,489
happened it's big has become more

00:03:18,410 --> 00:03:27,860
complex a use beat as to dot 0 device

00:03:22,489 --> 00:03:32,030
was in principle quite simple the device

00:03:27,860 --> 00:03:34,310
itself had interfaces and the interfaces

00:03:32,030 --> 00:03:36,410
have endpoints the endpoints are not

00:03:34,310 --> 00:03:40,340
shown in this graphics it would have

00:03:36,410 --> 00:03:43,610
been too cluttered and i/o is done to

00:03:40,340 --> 00:03:45,110
the interfaces and anything related to

00:03:43,610 --> 00:03:47,680
management of the device power

00:03:45,110 --> 00:03:50,260
management resetting enumeration she's a

00:03:47,680 --> 00:03:55,100
choice of configuration and so on is

00:03:50,260 --> 00:03:59,150
done at the device level it was true

00:03:55,100 --> 00:04:01,010
there are association descriptors into

00:03:59,150 --> 00:04:04,670
the zero devices like in this one here

00:04:01,010 --> 00:04:06,830
it's mandatory in that case cell phones

00:04:04,670 --> 00:04:09,110
to have an interface Association booty

00:04:06,830 --> 00:04:10,730
between the control interface for the

00:04:09,110 --> 00:04:16,090
wireless network and the wireless

00:04:10,730 --> 00:04:21,789
network itself three dot zero has become

00:04:16,090 --> 00:04:24,980
Barack the devices have a thing called

00:04:21,789 --> 00:04:29,120
functions very badly

00:04:24,980 --> 00:04:32,510
the name but that it is the functions

00:04:29,120 --> 00:04:36,200
themselves have interfaces the

00:04:32,510 --> 00:04:39,800
interfaces like in 220 do have endpoints

00:04:36,200 --> 00:04:45,290
and the endpoints well some of them the

00:04:39,800 --> 00:04:48,500
bulk endpoints do have streams you can

00:04:45,290 --> 00:04:51,350
think about of the function ml or less

00:04:48,500 --> 00:04:54,050
as the descendant of the Association

00:04:51,350 --> 00:04:56,510
descriptor the major change in the

00:04:54,050 --> 00:04:59,840
device model is that the power

00:04:56,510 --> 00:05:04,160
management has been split and is done on

00:04:59,840 --> 00:05:06,220
the device and the function level I'll

00:05:04,160 --> 00:05:08,630
talk about that a little bit later io

00:05:06,220 --> 00:05:15,200
still goes on to the endpoints of

00:05:08,630 --> 00:05:18,500
interfaces well as I mentioned the i/o

00:05:15,200 --> 00:05:21,740
the power management function has been

00:05:18,500 --> 00:05:24,380
split it has been split at the location

00:05:21,740 --> 00:05:30,220
edit is done and at the functionality it

00:05:24,380 --> 00:05:33,530
provides we now can suspend the function

00:05:30,220 --> 00:05:35,540
a bit hard to understand but imagine for

00:05:33,530 --> 00:05:39,740
example you had a camera which can do

00:05:35,540 --> 00:05:42,140
images sound and has a card reader you'd

00:05:39,740 --> 00:05:45,350
take the card reader in one function and

00:05:42,140 --> 00:05:47,750
the image sensor and sound sensor in

00:05:45,350 --> 00:05:50,360
another and if you want to react sess

00:05:47,750 --> 00:05:53,720
the card reader you can shut down the

00:05:50,360 --> 00:05:58,610
imaging part or vice versa that helps to

00:05:53,720 --> 00:06:01,700
save power what more we can do is that

00:05:58,610 --> 00:06:06,590
we can now suspend the link to the

00:06:01,700 --> 00:06:11,390
device and leave the device itself on at

00:06:06,590 --> 00:06:18,170
five gigabytes the the amount of power

00:06:11,390 --> 00:06:20,830
the link itself draws can dwarf easily

00:06:18,170 --> 00:06:25,850
what the device in its function will

00:06:20,830 --> 00:06:29,570
consume the link power management itself

00:06:25,850 --> 00:06:34,220
was introduced into the 0 but rarely

00:06:29,570 --> 00:06:37,370
used and not very good in 30 we do have

00:06:34,220 --> 00:06:38,110
to sleep levels for the link power

00:06:37,370 --> 00:06:41,890
management

00:06:38,110 --> 00:06:45,670
u1 and u2 the only difference is again

00:06:41,890 --> 00:06:47,980
latency versus power saving it is done

00:06:45,670 --> 00:06:50,200
in hardware perhaps can do it to the

00:06:47,980 --> 00:06:53,170
attached devices and devices themselves

00:06:50,200 --> 00:06:55,930
can request that the link we put in the

00:06:53,170 --> 00:06:58,000
link power management state furthermore

00:06:55,930 --> 00:07:01,320
we have the latency tolerancing

00:06:58,000 --> 00:07:04,090
messaging which is more or less about

00:07:01,320 --> 00:07:05,950
devices telling the host how much power

00:07:04,090 --> 00:07:08,310
management they can cope with I'll have

00:07:05,950 --> 00:07:13,180
a separate slide for that and

00:07:08,310 --> 00:07:17,680
furthermore yes b220 was a broadcast bus

00:07:13,180 --> 00:07:19,540
anything the host said was attached at

00:07:17,680 --> 00:07:22,750
he booted with the device address and

00:07:19,540 --> 00:07:24,910
sent out to the bus everybody could

00:07:22,750 --> 00:07:30,130
listen on it and that also wasted power

00:07:24,910 --> 00:07:33,940
we don't do that anymore the stream

00:07:30,130 --> 00:07:38,710
support that is one of the frankly hyped

00:07:33,940 --> 00:07:43,720
features it has been specifically more

00:07:38,710 --> 00:07:48,090
or less created for storage devices come

00:07:43,720 --> 00:07:53,470
in come in I don't buy it oh thank you

00:07:48,090 --> 00:07:57,970
okay what is a stream a3 is an attribute

00:07:53,470 --> 00:08:01,930
of a bulk endpoint and more or less is

00:07:57,970 --> 00:08:08,200
just a means to multiplex traffic to the

00:08:01,930 --> 00:08:09,820
endpoint why would I do that after all I

00:08:08,200 --> 00:08:14,620
could just send more data to the

00:08:09,820 --> 00:08:19,240
endpoint itself it allows you and to

00:08:14,620 --> 00:08:22,180
give additional meaning to the data

00:08:19,240 --> 00:08:27,340
transfer it says you might have a

00:08:22,180 --> 00:08:31,180
protocol that connects function and a

00:08:27,340 --> 00:08:33,310
faction so bad word here purpose a with

00:08:31,180 --> 00:08:35,740
one stream ID and purpose be with

00:08:33,310 --> 00:08:38,650
another three muddy and you can cope

00:08:35,740 --> 00:08:41,080
with one endpoint that is a nice

00:08:38,650 --> 00:08:43,300
advantage because endpoints are limited

00:08:41,080 --> 00:08:45,280
in number you can have only 16 per

00:08:43,300 --> 00:08:50,020
device and changing that would have

00:08:45,280 --> 00:08:51,370
means changing all commands because the

00:08:50,020 --> 00:08:54,760
interface

00:08:51,370 --> 00:08:57,610
point ID is hard-coded and forbid on a

00:08:54,760 --> 00:09:01,120
technical level a stream is just a

00:08:57,610 --> 00:09:03,850
number 23 midi it's a 16-bit number and

00:09:01,120 --> 00:09:05,950
you tell the end point no this is not

00:09:03,850 --> 00:09:08,880
going to your default stream but to some

00:09:05,950 --> 00:09:13,779
other and the endpoints deals with this

00:09:08,880 --> 00:09:16,720
this feature itself is a part of the

00:09:13,779 --> 00:09:20,560
standard but devices can tell the host

00:09:16,720 --> 00:09:23,410
how many streams can I support and that

00:09:20,560 --> 00:09:28,779
number can be one so in that sense

00:09:23,410 --> 00:09:31,779
streams are optional I will have a slide

00:09:28,779 --> 00:09:39,430
for uas where it can tell you how this

00:09:31,779 --> 00:09:41,620
is actually used in practice now let us

00:09:39,430 --> 00:09:44,740
come to the extensible host controller

00:09:41,620 --> 00:09:46,900
interface the extensible host controller

00:09:44,740 --> 00:09:50,650
interface is the successor of the

00:09:46,900 --> 00:09:53,200
enhanced host control interface which

00:09:50,650 --> 00:09:56,620
explains why the abbreviation uses the X

00:09:53,200 --> 00:10:00,010
from the air coming coming from the

00:09:56,620 --> 00:10:06,910
inside of the word not de was already

00:10:00,010 --> 00:10:09,220
taken the x HC I is a new design and

00:10:06,910 --> 00:10:15,700
it's probably going to be the only one

00:10:09,220 --> 00:10:18,010
and it is already so complex that making

00:10:15,700 --> 00:10:23,350
an alternative implementation would be

00:10:18,010 --> 00:10:24,870
very very hard and at the speeds

00:10:23,350 --> 00:10:29,560
involved it needs to have some

00:10:24,870 --> 00:10:33,779
complexity so doing a real different

00:10:29,560 --> 00:10:40,800
implementation would not be me helpful

00:10:33,779 --> 00:10:45,720
it does have one major design trend

00:10:40,800 --> 00:10:48,180
functionality is put into the hardware

00:10:45,720 --> 00:10:51,130
under 2 dot 0 you tell the controller

00:10:48,180 --> 00:10:54,880
transfer please this amount of data

00:10:51,130 --> 00:10:58,209
taken from that buffer to an end point

00:10:54,880 --> 00:11:00,790
at a given device address and the

00:10:58,209 --> 00:11:03,760
controller does that without any regard

00:11:00,790 --> 00:11:04,840
for whether this device is actually on

00:11:03,760 --> 00:11:07,690
the bus it

00:11:04,840 --> 00:11:12,610
does have that endpoint or whatever it

00:11:07,690 --> 00:11:16,900
just follows orders under the xhci

00:11:12,610 --> 00:11:20,050
controller you need to first tell the

00:11:16,900 --> 00:11:22,210
controller there is this device and it

00:11:20,050 --> 00:11:24,540
has these endpoints and they are

00:11:22,210 --> 00:11:28,630
supposed to work at that data rate and

00:11:24,540 --> 00:11:32,860
so on all those features are tracked in

00:11:28,630 --> 00:11:35,890
hardware furthermore the bus addresses

00:11:32,860 --> 00:11:38,500
for 220 devices 320 devices don't

00:11:35,890 --> 00:11:43,390
actually have bus addresses in that

00:11:38,500 --> 00:11:45,550
sense are also assigned by the hardware

00:11:43,390 --> 00:11:47,860
you actually tell the controller give

00:11:45,550 --> 00:11:50,260
that device on a dress and it generates

00:11:47,860 --> 00:11:54,070
the commands itself puts them over the

00:11:50,260 --> 00:11:58,350
bus and so on and we do manage now the

00:11:54,070 --> 00:12:02,680
bandwidth of the bus in hardware well

00:11:58,350 --> 00:12:06,640
except Ivybridge I guess they didn't

00:12:02,680 --> 00:12:10,240
finish in time so for that controller we

00:12:06,640 --> 00:12:13,120
do have software implementation so why

00:12:10,240 --> 00:12:15,880
is all this done this is very unusual

00:12:13,120 --> 00:12:20,350
for Intel usual they make very spot and

00:12:15,880 --> 00:12:22,900
controllers it's done because all those

00:12:20,350 --> 00:12:28,510
features the bandwidth and the bus

00:12:22,900 --> 00:12:30,730
address are common to the whole bus so

00:12:28,510 --> 00:12:32,980
if you do that I'm hardware there has to

00:12:30,730 --> 00:12:35,530
be no controlling instance in software

00:12:32,980 --> 00:12:39,550
for the bus and virtualization becomes

00:12:35,530 --> 00:12:42,070
very easy you can take a device and

00:12:39,550 --> 00:12:44,560
assign it to one vm the other device to

00:12:42,070 --> 00:12:48,130
next vm and if that takes too much

00:12:44,560 --> 00:12:50,620
bandwidth well then the second vm gets

00:12:48,130 --> 00:12:54,990
an error but there needs to be no

00:12:50,620 --> 00:12:57,760
communication between the the VMS and

00:12:54,990 --> 00:13:02,110
there are even special commands to the

00:12:57,760 --> 00:13:06,340
controller for virtualization and for

00:13:02,110 --> 00:13:09,790
the same reason we have eliminated the

00:13:06,340 --> 00:13:12,730
companion controllers all traffic to

00:13:09,790 --> 00:13:17,420
even to the legacy devices to the 0 1

00:13:12,730 --> 00:13:19,600
dot 1 are handled by the xhci controller

00:13:17,420 --> 00:13:22,580
in Hardware you can usually buy some

00:13:19,600 --> 00:13:26,990
vendor specific registers switch over

00:13:22,580 --> 00:13:29,660
the ports between the eh di da xhci but

00:13:26,990 --> 00:13:34,670
you do not that on boot only and then

00:13:29,660 --> 00:13:38,630
its final as a further nice feature for

00:13:34,670 --> 00:13:41,150
the programmer you have a total scatter

00:13:38,630 --> 00:13:43,930
getha wherever you want in 64 bit and

00:13:41,150 --> 00:13:47,360
you have total control over interrupted

00:13:43,930 --> 00:13:49,580
generation and to make it even better

00:13:47,360 --> 00:13:51,740
the link power management is also done

00:13:49,580 --> 00:13:58,220
in hardware you just set the timeouts

00:13:51,740 --> 00:14:03,590
and that's it so I figured it might be

00:13:58,220 --> 00:14:11,630
beneficial to explain a bit how a USB

00:14:03,590 --> 00:14:18,890
controller is used in Hardware you come

00:14:11,630 --> 00:14:22,100
into a come in if you write a device

00:14:18,890 --> 00:14:26,900
driver you don't actually have to know

00:14:22,100 --> 00:14:28,940
this because the USB core will do it all

00:14:26,900 --> 00:14:33,110
for you but to understand the features

00:14:28,940 --> 00:14:36,200
of the controller it is helpful you just

00:14:33,110 --> 00:14:38,810
create a buffer in main memory fill it

00:14:36,200 --> 00:14:42,760
with your payload and you tell the

00:14:38,810 --> 00:14:46,820
controller to transfer it you do that by

00:14:42,760 --> 00:14:49,400
writing a sort of command into the main

00:14:46,820 --> 00:14:52,100
memory which contains the address and

00:14:49,400 --> 00:14:54,080
length of the buffer and the rudimentary

00:14:52,100 --> 00:14:58,520
description of what's to be done with it

00:14:54,080 --> 00:15:01,760
and the host controller then walks its

00:14:58,520 --> 00:15:05,240
list of commands execute them and if the

00:15:01,760 --> 00:15:08,120
bid for generating interrupt is set then

00:15:05,240 --> 00:15:10,850
it generates an interrupt and before it

00:15:08,120 --> 00:15:13,220
generates the interrupt it writes the

00:15:10,850 --> 00:15:16,220
result in yet another special data

00:15:13,220 --> 00:15:19,640
structure all in main memory the all in

00:15:16,220 --> 00:15:22,250
main memory is a crucial feature because

00:15:19,640 --> 00:15:27,980
it allows you to get away without PCI

00:15:22,250 --> 00:15:30,840
excesses and PCI exorcists are becoming

00:15:27,980 --> 00:15:34,890
more and more expensive in

00:15:30,840 --> 00:15:37,020
of performance and for us to be nice the

00:15:34,890 --> 00:15:39,270
buffer again as I mentioned can be

00:15:37,020 --> 00:15:42,240
anywhere in main memory it's got 64-bit

00:15:39,270 --> 00:15:48,840
pointers and you can segment your buffer

00:15:42,240 --> 00:15:51,120
where however you want so that was what

00:15:48,840 --> 00:15:59,120
was to be said about the implementation

00:15:51,120 --> 00:16:03,870
itself i'm now not coming to too well

00:15:59,120 --> 00:16:08,040
features us USB Attached ghazi and the

00:16:03,870 --> 00:16:11,790
support for USB in a CPI they are

00:16:08,040 --> 00:16:16,200
strictly speaking not part of USB 3 dot

00:16:11,790 --> 00:16:19,050
0 but they fit extremely well into the

00:16:16,200 --> 00:16:22,440
software framework as it is now done and

00:16:19,050 --> 00:16:24,960
they are a great example of how to use

00:16:22,440 --> 00:16:28,290
the features of ESP 30 especially

00:16:24,960 --> 00:16:33,960
streams features so I am going to say

00:16:28,290 --> 00:16:37,980
something about them right now hear the

00:16:33,960 --> 00:16:44,280
complaints we had why is my USB storage

00:16:37,980 --> 00:16:48,720
dongle so slow well it was not because

00:16:44,280 --> 00:16:52,680
you SP 2 dot 0 is slow it's 480 gigabit

00:16:48,720 --> 00:16:56,880
megabits per second that's still quite

00:16:52,680 --> 00:17:00,690
quite fast it was the fault of a

00:16:56,880 --> 00:17:03,300
protocol the protocol for USB storage

00:17:00,690 --> 00:17:10,350
was originally developed for floppies

00:17:03,300 --> 00:17:14,790
and that shows if you send a command to

00:17:10,350 --> 00:17:19,580
a storage device you send a command you

00:17:14,790 --> 00:17:23,280
sent the payload you retrieve the result

00:17:19,580 --> 00:17:26,940
you evaluate the result and then you go

00:17:23,280 --> 00:17:28,950
on again and of course while you

00:17:26,940 --> 00:17:30,780
evaluate the result you've missed the

00:17:28,950 --> 00:17:34,050
next time slot to sent the next command

00:17:30,780 --> 00:17:36,450
and it becomes even most law well what I

00:17:34,050 --> 00:17:39,870
was to tell you there is no command

00:17:36,450 --> 00:17:44,200
queuing you execute one command at a

00:17:39,870 --> 00:17:47,169
time that naturally means you execute

00:17:44,200 --> 00:17:49,990
to command in the order you sent them to

00:17:47,169 --> 00:17:51,850
the device how else could it be there is

00:17:49,990 --> 00:17:56,889
only one command for the device to

00:17:51,850 --> 00:17:59,320
execute and to make it even worse you

00:17:56,889 --> 00:18:02,350
cannot send the next command while the

00:17:59,320 --> 00:18:04,779
payload is under way no it all goes to

00:18:02,350 --> 00:18:07,419
the same set of endpoints so all three

00:18:04,779 --> 00:18:12,309
phases cannot overlap and have to be

00:18:07,419 --> 00:18:14,830
executed in that order and it's even

00:18:12,309 --> 00:18:17,919
worse we don't use the native error

00:18:14,830 --> 00:18:22,510
handling to be fair we can't it would

00:18:17,919 --> 00:18:27,130
disallow us from making skazhi to USB

00:18:22,510 --> 00:18:29,019
bridges but that means that actually the

00:18:27,130 --> 00:18:32,350
result has to be evaluated before the

00:18:29,019 --> 00:18:35,289
next command and to make matters even

00:18:32,350 --> 00:18:39,010
more worse we use a kernel threat and

00:18:35,289 --> 00:18:42,159
that gets us to scheduling delays so I

00:18:39,010 --> 00:18:47,200
guess you have now understood why our

00:18:42,159 --> 00:18:51,130
USB storage devices are so slow so what

00:18:47,200 --> 00:18:53,200
could be done we could eliminate the

00:18:51,130 --> 00:18:55,330
colonel threat yes but that would be a

00:18:53,200 --> 00:18:57,490
very major change for relatively little

00:18:55,330 --> 00:19:02,880
gaming because the protocol would still

00:18:57,490 --> 00:19:08,139
suck so we have USB Attached skazhi and

00:19:02,880 --> 00:19:12,760
it is fast mainly by allowing multiple

00:19:08,139 --> 00:19:16,620
commands and they can be executed out of

00:19:12,760 --> 00:19:19,720
order technically speaking this is

00:19:16,620 --> 00:19:22,299
governed by the rules of sa m4 from

00:19:19,720 --> 00:19:25,240
discussing standard and we've separated

00:19:22,299 --> 00:19:27,519
the endpoints so we can set the next

00:19:25,240 --> 00:19:31,740
command while we still retrieve a

00:19:27,519 --> 00:19:34,510
payload on the upload on another command

00:19:31,740 --> 00:19:39,669
there is one major drawback if you do

00:19:34,510 --> 00:19:42,870
such a thing you have to know for which

00:19:39,669 --> 00:19:46,510
command and I'm retrieving the result or

00:19:42,870 --> 00:19:50,820
sending the payload because if you mix

00:19:46,510 --> 00:19:50,820
them up then your disk is

00:19:51,950 --> 00:20:01,490
there is no nice word for this let's say

00:19:54,740 --> 00:20:06,169
irretrievable so we gave every command a

00:20:01,490 --> 00:20:11,269
number that is what attack just is it is

00:20:06,169 --> 00:20:14,779
unique and it is 16-bit and I mentioned

00:20:11,269 --> 00:20:17,950
this streams IDs are 16 bit so there you

00:20:14,779 --> 00:20:22,549
now see what we use two streams for a

00:20:17,950 --> 00:20:28,429
stream is just a command on the URS

00:20:22,549 --> 00:20:32,149
level so this was on Isaac for using

00:20:28,429 --> 00:20:34,820
streams for storage devices and there is

00:20:32,149 --> 00:20:38,380
another improvement as I so told you USB

00:20:34,820 --> 00:20:41,870
3 0 0 softens to strict master slave a

00:20:38,380 --> 00:20:45,820
device now can tell I have data please

00:20:41,870 --> 00:20:49,519
speak to me and the host will do so and

00:20:45,820 --> 00:21:00,039
that facilitates the out-of-order

00:20:49,519 --> 00:21:05,600
execution of commands River acpi and USB

00:21:00,039 --> 00:21:08,740
why do we need it because we do know

00:21:05,600 --> 00:21:11,480
nothing about our ports and we cannot

00:21:08,740 --> 00:21:14,630
switch off the power to ports on the

00:21:11,480 --> 00:21:18,139
main board we all know it is possible

00:21:14,630 --> 00:21:21,950
because our laptops cut power when we

00:21:18,139 --> 00:21:24,470
sleep but for some magic happening in

00:21:21,950 --> 00:21:27,769
bios they don't do this if we use USB

00:21:24,470 --> 00:21:31,190
devices is wake up sources so it must be

00:21:27,769 --> 00:21:36,980
possible what has happened there has

00:21:31,190 --> 00:21:41,529
been we have added support for USB and a

00:21:36,980 --> 00:21:45,340
CPI strictly speaking in a CPI 320 and

00:21:41,529 --> 00:21:48,710
how does it work in detail we have

00:21:45,340 --> 00:21:52,730
associated features with the ports on

00:21:48,710 --> 00:21:59,120
the motherboard firstly a port can be

00:21:52,730 --> 00:22:01,730
usable or unusable you know should ask

00:21:59,120 --> 00:22:05,750
why can they be unusable ports and

00:22:01,730 --> 00:22:08,690
you're put in your computer well the

00:22:05,750 --> 00:22:12,710
both ports in your chipset is set by the

00:22:08,690 --> 00:22:17,000
manufacturer but not every mainboard

00:22:12,710 --> 00:22:18,980
leads every port to the outside some of

00:22:17,000 --> 00:22:24,680
them are used for internal devices like

00:22:18,980 --> 00:22:27,080
your webcam your Bluetooth your card

00:22:24,680 --> 00:22:31,330
read on this laptop your fingerprint

00:22:27,080 --> 00:22:35,270
reader but some are simply left dangling

00:22:31,330 --> 00:22:38,330
they are marked in the bias as unused

00:22:35,270 --> 00:22:40,760
and because we can now cut power to

00:22:38,330 --> 00:22:42,800
ports on the main board we simply cut

00:22:40,760 --> 00:22:47,020
their power don't have to worry about

00:22:42,800 --> 00:22:49,760
them anymore and we don't use the power

00:22:47,020 --> 00:22:54,650
the second attribute is the pluggable

00:22:49,760 --> 00:22:57,890
versus unplug apple on an external port

00:22:54,650 --> 00:23:02,030
I can obviously put in a device that's

00:22:57,890 --> 00:23:06,920
its reason for existence but this is

00:23:02,030 --> 00:23:10,580
also possible for some internal ports my

00:23:06,920 --> 00:23:15,920
fingerprint reader is always a cable to

00:23:10,580 --> 00:23:18,160
the same port so is my webcam but not my

00:23:15,920 --> 00:23:21,530
bt USB device which does my bluetooth

00:23:18,160 --> 00:23:23,750
when I hit my rfkill key it will go away

00:23:21,530 --> 00:23:28,100
and if I hit it again it will come back

00:23:23,750 --> 00:23:30,140
so it is internal but pluggable I have

00:23:28,100 --> 00:23:33,890
to run the hot plug detection on it or I

00:23:30,140 --> 00:23:40,220
would miss D the unplug and replug

00:23:33,890 --> 00:23:43,070
events so what do we do with it we

00:23:40,220 --> 00:23:45,290
export these attributes to user space so

00:23:43,070 --> 00:23:49,040
the GUI can do something more or less

00:23:45,290 --> 00:23:52,040
sensible with and we extend the auto

00:23:49,040 --> 00:23:54,680
suspend mechanism you can tell the auto

00:23:52,040 --> 00:23:58,400
suspend whether to simply and nicely

00:23:54,680 --> 00:24:01,490
suspend your device or to cut power to

00:23:58,400 --> 00:24:04,180
the pot and if you cut power to the port

00:24:01,490 --> 00:24:06,350
there will be no more hot plug detection

00:24:04,180 --> 00:24:10,460
that is the trailer if you have to make

00:24:06,350 --> 00:24:13,070
a last but not least us be gained by

00:24:10,460 --> 00:24:14,720
tinggi recipes I standards methods for

00:24:13,070 --> 00:24:17,090
powering and D powering ports on the

00:24:14,720 --> 00:24:18,590
motherboard on haps we also could we

00:24:17,090 --> 00:24:25,010
already could do it that's about

00:24:18,590 --> 00:24:27,919
of the standard command set now the nice

00:24:25,010 --> 00:24:34,940
part what can your kernel do for you and

00:24:27,919 --> 00:24:38,330
what should you do for your kernel let

00:24:34,940 --> 00:24:44,659
me begin with what our kernel still

00:24:38,330 --> 00:24:48,200
cannot do because I hope but do not well

00:24:44,659 --> 00:24:53,510
I hope that some of you will add support

00:24:48,200 --> 00:24:56,870
for it what's missing the functions in

00:24:53,510 --> 00:24:59,990
the architecture they are they're part

00:24:56,870 --> 00:25:03,679
of the standard every USB 3 dot 0 device

00:24:59,990 --> 00:25:07,520
does have at least one function but we

00:25:03,679 --> 00:25:11,360
usually don't do something with it what

00:25:07,520 --> 00:25:15,700
does that mean if you draw write a

00:25:11,360 --> 00:25:18,679
driver for a USB device and the colonel

00:25:15,700 --> 00:25:21,440
you are not writing a driver for a

00:25:18,679 --> 00:25:25,820
device you are writing a driver for an

00:25:21,440 --> 00:25:28,640
interface there is also a driver for

00:25:25,820 --> 00:25:31,279
devices it's one driver it's called the

00:25:28,640 --> 00:25:33,890
generic driver which does very little

00:25:31,279 --> 00:25:39,710
but distributes events to the interface

00:25:33,890 --> 00:25:44,330
drivers for us to use this we would need

00:25:39,710 --> 00:25:48,289
a generic driver for functions it's not

00:25:44,330 --> 00:25:51,020
been done another nice little feature

00:25:48,289 --> 00:25:55,730
missing would be how to do I accuse

00:25:51,020 --> 00:25:57,950
without doing pci axis as i mentioned

00:25:55,730 --> 00:26:00,409
already in an earlier slide the

00:25:57,950 --> 00:26:02,210
controller does right the results of its

00:26:00,409 --> 00:26:05,330
operation in special event data

00:26:02,210 --> 00:26:08,390
structures we could evaluate them

00:26:05,330 --> 00:26:11,899
instead of the pci registers of the

00:26:08,390 --> 00:26:13,880
controller in case it's not an external

00:26:11,899 --> 00:26:16,610
event that triggered the interrupt which

00:26:13,880 --> 00:26:19,250
would not do it event eight destruction

00:26:16,610 --> 00:26:22,760
we could do with an hour without a pci

00:26:19,250 --> 00:26:28,340
access our speed would more than double

00:26:22,760 --> 00:26:32,149
in the interrupt handler what is done

00:26:28,340 --> 00:26:32,360
right now right now we are introducing a

00:26:32,149 --> 00:26:35,330
ling

00:26:32,360 --> 00:26:41,630
power management even for us be 20

00:26:35,330 --> 00:26:44,150
devices which will save some power what

00:26:41,630 --> 00:26:47,470
has been done recently is in three dot

00:26:44,150 --> 00:26:50,000
nine we finally got working us support

00:26:47,470 --> 00:26:52,670
working in that sense means it will

00:26:50,000 --> 00:26:58,549
survive the first error it didn't before

00:26:52,670 --> 00:27:01,520
that recently we did the acpi support I

00:26:58,549 --> 00:27:05,210
talked about but we're still missing a

00:27:01,520 --> 00:27:07,580
user space component we did latency

00:27:05,210 --> 00:27:10,570
tolerance tolerance messaging which the

00:27:07,580 --> 00:27:13,640
colonel now can do since three dot six

00:27:10,570 --> 00:27:17,750
again we are missing the user space

00:27:13,640 --> 00:27:19,549
component and a three dot five we edit

00:27:17,750 --> 00:27:24,169
the link power management support for

00:27:19,549 --> 00:27:28,730
USB devices and that is about what we

00:27:24,169 --> 00:27:35,360
added in the last 18 months so let me go

00:27:28,730 --> 00:27:37,520
to the details function support we do

00:27:35,360 --> 00:27:40,280
have a generic device model in the

00:27:37,520 --> 00:27:42,830
kernel which does have design that's the

00:27:40,280 --> 00:27:45,320
bus to which is attached the host

00:27:42,830 --> 00:27:49,580
controller to which is attached the

00:27:45,320 --> 00:27:53,059
device to which is attached the

00:27:49,580 --> 00:27:56,840
interface your generic driver as I

00:27:53,059 --> 00:28:00,130
mentioned is for the interface and there

00:27:56,840 --> 00:28:03,830
is a generic driver for the device which

00:28:00,130 --> 00:28:06,679
handles things like reset telling each

00:28:03,830 --> 00:28:08,900
device to prepare for a reset and then

00:28:06,679 --> 00:28:12,110
again we have reset the device now you

00:28:08,900 --> 00:28:15,080
can resume your function yup your

00:28:12,110 --> 00:28:19,299
interface sorry what we would need to do

00:28:15,080 --> 00:28:22,429
is to write this again for the function

00:28:19,299 --> 00:28:24,650
so that the device tells the function to

00:28:22,429 --> 00:28:28,730
do something at the function chelsea's

00:28:24,650 --> 00:28:31,940
interfaces this unfortunately means a

00:28:28,730 --> 00:28:34,549
rather extensive change in the generic

00:28:31,940 --> 00:28:41,059
driver model so we don't have done it

00:28:34,549 --> 00:28:44,390
right now because there has for now been

00:28:41,059 --> 00:28:46,310
little reason to do it we have not seen

00:28:44,390 --> 00:28:50,990
a multifunction device

00:28:46,310 --> 00:28:54,380
in the wild this is probably because USB

00:28:50,990 --> 00:28:56,750
2 dot 0 does not do functions and people

00:28:54,380 --> 00:29:00,620
want to maintain backwards and forwards

00:28:56,750 --> 00:29:04,030
compatibility so right now it is not

00:29:00,620 --> 00:29:06,440
being used but this is likely to change

00:29:04,030 --> 00:29:08,180
there we would need your support if

00:29:06,440 --> 00:29:10,940
there is any hacker for the generic

00:29:08,180 --> 00:29:20,570
device model here you know what you need

00:29:10,940 --> 00:29:23,120
to do yes I mean you what have we added

00:29:20,570 --> 00:29:25,910
there is the well the feature has no

00:29:23,120 --> 00:29:32,660
official name so I'm calling it the zero

00:29:25,910 --> 00:29:37,700
power auto suspend what does it do it

00:29:32,660 --> 00:29:40,040
switches off devices let me explain the

00:29:37,700 --> 00:29:42,710
reasoning behind it it may be a total

00:29:40,040 --> 00:29:47,150
logical conclusion here but you cannot

00:29:42,710 --> 00:29:49,610
use less than no power sounds paradox

00:29:47,150 --> 00:29:54,500
doesn't matter increase the invented the

00:29:49,610 --> 00:29:56,630
concept but that means if you can cut

00:29:54,500 --> 00:29:59,240
power to your device you do have

00:29:56,630 --> 00:30:05,150
ultimate power management you can't get

00:29:59,240 --> 00:30:08,900
any better so let us examine what do

00:30:05,150 --> 00:30:10,370
devices need powerful while they work of

00:30:08,900 --> 00:30:14,180
course they need power for the

00:30:10,370 --> 00:30:17,480
operations and the USB bus as a bus

00:30:14,180 --> 00:30:20,720
needs power to detect top flux has a

00:30:17,480 --> 00:30:22,790
device gonna come has it done on USB you

00:30:20,720 --> 00:30:24,860
need power for that there are bus

00:30:22,790 --> 00:30:28,460
systems which can optionally do it

00:30:24,860 --> 00:30:30,890
without power for example esata but USB

00:30:28,460 --> 00:30:37,010
is not among them you do need to power

00:30:30,890 --> 00:30:39,410
your port to detect odd blocks so which

00:30:37,010 --> 00:30:43,750
devices can live up without power of

00:30:39,410 --> 00:30:49,580
course not the operational devices but

00:30:43,750 --> 00:30:52,370
those who don't need hot plug as I

00:30:49,580 --> 00:30:55,940
mentioned we have now a CPI support with

00:30:52,370 --> 00:30:58,190
which tells us whether device can be hot

00:30:55,940 --> 00:30:59,660
plucked at all we use that information

00:30:58,190 --> 00:31:03,770
in the colonel

00:30:59,660 --> 00:31:08,240
if it is hot plucked then we cannot cut

00:31:03,770 --> 00:31:11,180
power or alternatively we export the

00:31:08,240 --> 00:31:12,830
attributes for power management and if

00:31:11,180 --> 00:31:17,680
the user tells us we don't care about

00:31:12,830 --> 00:31:22,150
hot black detection then we cut power

00:31:17,680 --> 00:31:27,140
furthermore devices need standby power

00:31:22,150 --> 00:31:31,160
we had this nice buck about the drive

00:31:27,140 --> 00:31:33,620
enclosures which lost data it turned out

00:31:31,160 --> 00:31:35,690
that they do have an internal cash and

00:31:33,620 --> 00:31:40,100
if you suspend the device they clean the

00:31:35,690 --> 00:31:41,870
cash great the fix was to issue a flash

00:31:40,100 --> 00:31:44,360
cash command on the scuzzy level before

00:31:41,870 --> 00:31:47,780
you suspend the device but this should

00:31:44,360 --> 00:31:50,330
illustrate that devices do need their

00:31:47,780 --> 00:31:57,020
standby power at least some devices do

00:31:50,330 --> 00:32:01,790
need it what can we do we made an

00:31:57,020 --> 00:32:04,100
educated guess if a device does do

00:32:01,790 --> 00:32:06,440
remote wake up for example your usual

00:32:04,100 --> 00:32:08,960
mouse does it if you press them a mouse

00:32:06,440 --> 00:32:11,200
button it can wake up the system then

00:32:08,960 --> 00:32:15,740
you need power it's an in distributive

00:32:11,200 --> 00:32:18,920
indisputable thing to do remote app can

00:32:15,740 --> 00:32:24,970
make you need to do to be able to do

00:32:18,920 --> 00:32:29,920
remote wake up you need power so you

00:32:24,970 --> 00:32:32,840
also need power to retain state but in

00:32:29,920 --> 00:32:38,210
the normal course of operation your

00:32:32,840 --> 00:32:41,420
system does already lose power it does

00:32:38,210 --> 00:32:46,100
so when you suspend to disk and USB

00:32:41,420 --> 00:32:50,720
devices do have a support function for

00:32:46,100 --> 00:32:54,770
suspending to disk it's called the reset

00:32:50,720 --> 00:32:59,570
resumed operation it's used for s4 so we

00:32:54,770 --> 00:33:04,100
figured if a device does not need

00:32:59,570 --> 00:33:07,850
hot-plug detection can deal with s4 and

00:33:04,100 --> 00:33:10,680
does not do remote wake up then we cut

00:33:07,850 --> 00:33:13,920
its power when it's suspended

00:33:10,680 --> 00:33:18,930
that is the heuristics we are using

00:33:13,920 --> 00:33:23,010
today it is quite new whether it will

00:33:18,930 --> 00:33:26,700
work in the future we need to see and we

00:33:23,010 --> 00:33:31,860
would like from you testing and some

00:33:26,700 --> 00:33:41,360
support for ignoring remote wake up or

00:33:31,860 --> 00:33:47,100
hot black events in the GUI LTM support

00:33:41,360 --> 00:33:50,850
let's say I have a USB microphone it's

00:33:47,100 --> 00:33:55,230
imaginary this is not then it has some

00:33:50,850 --> 00:33:58,470
internal buffer while we record that

00:33:55,230 --> 00:34:02,310
offer is filled and from time to time it

00:33:58,470 --> 00:34:05,010
has to be transferred to the host for

00:34:02,310 --> 00:34:07,770
power management we would like to do

00:34:05,010 --> 00:34:10,920
these transfers as rarely as possible

00:34:07,770 --> 00:34:14,370
because whenever we transfer the bus

00:34:10,920 --> 00:34:18,870
cannot be in a power suspend state so

00:34:14,370 --> 00:34:23,010
what do we need we need to know how

00:34:18,870 --> 00:34:25,170
large is the buffer that itself would

00:34:23,010 --> 00:34:27,570
not be a good information because we

00:34:25,170 --> 00:34:31,500
need would need to compute house how

00:34:27,570 --> 00:34:34,410
fast the device filtered buffer no we

00:34:31,500 --> 00:34:37,860
need to know how long can this device do

00:34:34,410 --> 00:34:42,120
without being serviced that's the

00:34:37,860 --> 00:34:45,750
latency tolerance messaging the device

00:34:42,120 --> 00:34:48,630
tells the host I can do for these many

00:34:45,750 --> 00:34:54,980
milliseconds without data transfer with

00:34:48,630 --> 00:34:57,990
you the host takes this information

00:34:54,980 --> 00:35:00,240
computes from it how long would it take

00:34:57,990 --> 00:35:02,400
to talk to this device this is not

00:35:00,240 --> 00:35:04,050
identical because there may be hops in

00:35:02,400 --> 00:35:07,050
between and you need to wake up the port

00:35:04,050 --> 00:35:11,880
on the on the main board and from that

00:35:07,050 --> 00:35:14,670
it computes a time for telling user

00:35:11,880 --> 00:35:18,600
space how long this device can do

00:35:14,670 --> 00:35:22,260
without i owe the colonel part of this

00:35:18,600 --> 00:35:24,060
feature is done we export those computed

00:35:22,260 --> 00:35:26,730
hints / Sisyphus

00:35:24,060 --> 00:35:29,460
what we would like to do would be the

00:35:26,730 --> 00:35:34,380
multimedia frameworks pulseaudio and its

00:35:29,460 --> 00:35:37,470
relatives to use them and schedule their

00:35:34,380 --> 00:35:47,460
i/o based on this it would help us save

00:35:37,470 --> 00:35:49,830
power so as I've talked a lot and ten

00:35:47,460 --> 00:35:52,800
minutes left or so let's make this quick

00:35:49,830 --> 00:35:55,230
it might interest you what comes after

00:35:52,800 --> 00:36:00,090
we're finished with what we are already

00:35:55,230 --> 00:36:03,600
doing and what are still missing so we

00:36:00,090 --> 00:36:07,080
are seeing that the logical kind of

00:36:03,600 --> 00:36:09,930
links are becoming divorced from the

00:36:07,080 --> 00:36:12,900
physical kind of links for USB you

00:36:09,930 --> 00:36:15,420
already have the physical port you have

00:36:12,900 --> 00:36:18,870
in your laptop a mini PCIe slot which

00:36:15,420 --> 00:36:22,770
already can do USB it now can be done

00:36:18,870 --> 00:36:27,390
over HDMI for other protocols you see

00:36:22,770 --> 00:36:30,450
the same we expect that we will see less

00:36:27,390 --> 00:36:32,400
kinds of interfaces in the future in my

00:36:30,450 --> 00:36:38,160
personal opinion for example firewires

00:36:32,400 --> 00:36:42,060
dead and what we've also found is that

00:36:38,160 --> 00:36:43,980
people don't like wires in every

00:36:42,060 --> 00:36:46,470
conference there is somebody cursing

00:36:43,980 --> 00:36:48,930
that while he can have Wi-Fi he cannot

00:36:46,470 --> 00:36:50,790
have wireless power I'm sorry to say

00:36:48,930 --> 00:36:54,240
that that problem is unlikely to be

00:36:50,790 --> 00:37:00,120
solved soon but he might have wireless

00:36:54,240 --> 00:37:04,590
USB wireless USB already exists but

00:37:00,120 --> 00:37:08,690
nobody's using it this is probably a

00:37:04,590 --> 00:37:12,300
result of nobody using ultra wideband

00:37:08,690 --> 00:37:16,040
ultra-wideband has its problems it needs

00:37:12,300 --> 00:37:19,110
a nap oh it needs its own controller

00:37:16,040 --> 00:37:20,520
that costs so we should use the

00:37:19,110 --> 00:37:24,200
controller that is already on the

00:37:20,520 --> 00:37:24,200
motherboard that's your Wi-Fi controller

00:37:24,500 --> 00:37:30,990
unfortunately right now we can't your

00:37:27,780 --> 00:37:32,460
Wi-Fi has a total schedule it's linked

00:37:30,990 --> 00:37:35,490
in the access point we can't deviate

00:37:32,460 --> 00:37:36,539
from that and it's too slow so what do

00:37:35,490 --> 00:37:40,079
we need

00:37:36,539 --> 00:37:42,630
fast link a link under own control so we

00:37:40,079 --> 00:37:44,429
can do real time I oh and we really

00:37:42,630 --> 00:37:48,479
would like somebody else to do our

00:37:44,429 --> 00:37:51,569
security stuff which means wife I would

00:37:48,479 --> 00:37:54,209
do the job if it would do have a

00:37:51,569 --> 00:37:59,900
dedicated channel and would be fast so

00:37:54,209 --> 00:38:03,689
now we are going to 800 800 2 dot 11 ad

00:37:59,900 --> 00:38:08,429
sorry this is a tongue twister which

00:38:03,689 --> 00:38:10,979
meets these requirements it allows to

00:38:08,429 --> 00:38:14,429
you to do something else but wireless

00:38:10,979 --> 00:38:17,400
LAN over the Wi-Fi link it provides its

00:38:14,429 --> 00:38:20,809
security like every form of Wi-Fi and it

00:38:17,400 --> 00:38:24,059
has a dedicated link between its notes

00:38:20,809 --> 00:38:27,209
it does have access points yes but you

00:38:24,059 --> 00:38:31,380
don't need to use them it operates at 60

00:38:27,209 --> 00:38:34,199
gigahertz it uses a directional antenna

00:38:31,380 --> 00:38:37,319
yes electronically you can

00:38:34,199 --> 00:38:40,890
electronically switch the beam by using

00:38:37,319 --> 00:38:44,130
a phased array antenna you can run a

00:38:40,890 --> 00:38:47,339
serial bus over it by an extension and

00:38:44,130 --> 00:38:49,229
we got indications that people are going

00:38:47,339 --> 00:38:53,969
to use it for docking stations which

00:38:49,229 --> 00:38:57,739
contain a USB hub that's our primary use

00:38:53,969 --> 00:38:57,739
case and will be the first

00:38:58,939 --> 00:39:05,099
implementation of this new standard it's

00:39:02,689 --> 00:39:08,130
unfortunately not yet fully public you

00:39:05,099 --> 00:39:12,599
can read about the existence of 811 ad

00:39:08,130 --> 00:39:15,150
in the standards bodies you can look up

00:39:12,599 --> 00:39:17,640
the wireless serial extension they will

00:39:15,150 --> 00:39:24,869
tell you it exists and it does this and

00:39:17,640 --> 00:39:30,059
that but not how sorry well we are Suzie

00:39:24,869 --> 00:39:33,329
we are great well I have to show this

00:39:30,059 --> 00:39:35,759
and if you like to work for us please do

00:39:33,329 --> 00:39:39,119
so we are cool and I haven't bitten

00:39:35,759 --> 00:39:43,579
anybody since April so don't fear come

00:39:39,119 --> 00:39:43,579
to us questions

00:39:52,560 --> 00:39:56,420
somebody will give you the microphone

00:40:03,130 --> 00:40:11,870
hello unplugging a USB device without

00:40:08,570 --> 00:40:17,030
having first unmounting door ejected

00:40:11,870 --> 00:40:23,000
through software it is dangerous for the

00:40:17,030 --> 00:40:27,920
device to damage its Hardware know what

00:40:23,000 --> 00:40:30,290
you can damage is your data if you

00:40:27,920 --> 00:40:32,570
unplug the device of course UD power it

00:40:30,290 --> 00:40:35,990
and if you have anything buffered that's

00:40:32,570 --> 00:40:38,510
gone but the specification tells you you

00:40:35,990 --> 00:40:44,470
can unplug a device at any time under

00:40:38,510 --> 00:40:44,470
any condition no problem thank you

00:40:54,690 --> 00:41:01,579
well any questions over the IRC channel

00:41:01,790 --> 00:41:08,270
no then I guess we'll finish with a few

00:41:06,569 --> 00:41:22,880
minutes to spare time to get a coffee

00:41:08,270 --> 00:41:22,880
thank you we still have a question sorry

00:41:28,610 --> 00:41:40,840
I would like to know if it is possible

00:41:31,550 --> 00:41:48,470
to use USB or accessing memory s

00:41:40,840 --> 00:41:55,510
firewall model part of our device closer

00:41:48,470 --> 00:41:59,620
a firewire bus is known to be exportable

00:41:55,510 --> 00:42:05,020
if it is possible to use USB this way if

00:41:59,620 --> 00:42:15,410
USB device can of anyhow effect which

00:42:05,020 --> 00:42:21,800
memory region will be read short answer

00:42:15,410 --> 00:42:27,200
no under fire via a device can request a

00:42:21,800 --> 00:42:32,680
transfer under USB it cannot do so the

00:42:27,200 --> 00:42:37,760
transfer has to be initiated by the host

00:42:32,680 --> 00:42:40,670
the only function a device has in that

00:42:37,760 --> 00:42:44,120
is that it indicates that it is ready to

00:42:40,670 --> 00:42:46,460
transfer and it can do that on its own

00:42:44,120 --> 00:42:49,640
initiative but it cannot start a

00:42:46,460 --> 00:42:52,340
transfer the buffer is still set up by

00:42:49,640 --> 00:42:55,700
the host and if the device sends an

00:42:52,340 --> 00:42:58,670
unsolicited it ready event then will be

00:42:55,700 --> 00:43:01,150
ignored so there is no danger in that

00:42:58,670 --> 00:43:01,150
regard

00:43:05,850 --> 00:43:33,400
so anybody still overlooked because this

00:43:13,960 --> 00:43:38,620
is embarrassing no I get this Thank You

00:43:33,400 --> 00:43:41,010
Oliver okay then let's have a coffee or

00:43:38,620 --> 00:43:41,010

YouTube URL: https://www.youtube.com/watch?v=NltE9XxqSso


