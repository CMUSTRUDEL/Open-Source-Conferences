Title: Building a Language Server for Salt States
Publication date: 2021-06-21
Playlist: openSUSE Virtual Conference 2021
Description: 
	The Language Server Protocol

A language server is a piece of software that speaks a JSON RPC protocol (called the Language Server Protocol, abbreviated LSP) to provide text editors with code completion, diagnostics, documentation, etc. There are several editors and numerous language servers already implementing this protocol. The advantage of the LSP this is, that each language server works independently of the used text editor/IDE and thereby makes all implemented features available to a wider audience.
Salt States

SaltStack is a configuration management software like Ansible or Puppet which allows you to configure your machines via so-called salt states. Salt states are YAML documents with support for Jinja2 templates:

mysql: pkg.installed: - name: mysql service.running: - name: mysql web_server: pkg.installed: {% if grains['os_family'] == 'RedHat' %} - name: httpd {% elif grains['os_family'] == 'Debian' %} - name: apache2 {% endif %}
The Salt States Language Server

During this year's hackweek #20 Cédric Bosdonnat and Dan Čermák built an initial prototype of a language server for salt states. It already supports rudimentary completion, go to definition, document symbols and it can show the documentation of salt modules.

This talk will give a brief overview over the current state of the language server, how we got there and which challenges and surprises we encountered along the way.



Subscribe ►http://bit.ly/1G2KKZl

Offical Website ►https://www.opensuse.org
Follow us on Twitter ► https://twitter.com/openSUSE
Like us on Facebook ► https://www.facebook.com/en.openSUSE
Captions: 
	00:00:02,080 --> 00:00:05,359
hello everyone

00:00:03,439 --> 00:00:07,839
welcome to my presentation about

00:00:05,359 --> 00:00:09,519
building a language server for salt

00:00:07,839 --> 00:00:12,440
state

00:00:09,519 --> 00:00:14,480
part of the opensuse virtual conference

00:00:12,440 --> 00:00:17,279
00:00:14,480 --> 00:00:19,520
my name is dan i am a software developer

00:00:17,279 --> 00:00:20,960
part of the developer engagement program

00:00:19,520 --> 00:00:24,320
at suzu

00:00:20,960 --> 00:00:27,199
i'm essentially responsible for

00:00:24,320 --> 00:00:27,920
building tools for other developers for

00:00:27,199 --> 00:00:29,920
example

00:00:27,920 --> 00:00:31,679
this one although this was just a hack

00:00:29,920 --> 00:00:35,440
week project but still

00:00:31,679 --> 00:00:36,239
so besides my day job at susa i'm also

00:00:35,440 --> 00:00:39,120
part of the

00:00:36,239 --> 00:00:41,600
open sourcer community where i'm a

00:00:39,120 --> 00:00:44,160
package maintainer of a few packages

00:00:41,600 --> 00:00:46,640
i'm also quite active in fedora i've

00:00:44,160 --> 00:00:49,120
been recently elected into fesco

00:00:46,640 --> 00:00:51,199
and i'm also there part of the i3

00:00:49,120 --> 00:00:55,199
special interest group where we

00:00:51,199 --> 00:00:57,039
ship the i3 spin for fedora 34

00:00:55,199 --> 00:00:59,039
and i'm also a package maintainer then

00:00:57,039 --> 00:01:01,440
contribute to a few upstream projects

00:00:59,039 --> 00:01:04,239
here and there

00:01:01,440 --> 00:01:06,320
so but without further ado let's take a

00:01:04,239 --> 00:01:09,119
look at today's outline

00:01:06,320 --> 00:01:10,799
so first i'd like to cover what is

00:01:09,119 --> 00:01:13,280
actually the language server protocol in

00:01:10,799 --> 00:01:16,880
case you have never heard about that

00:01:13,280 --> 00:01:19,680
then i also cover what is salt stack

00:01:16,880 --> 00:01:21,280
the why and when so why did we do this

00:01:19,680 --> 00:01:23,360
when did we do this what were the

00:01:21,280 --> 00:01:27,119
circumstances around that

00:01:23,360 --> 00:01:30,400
the architecture of this of this server

00:01:27,119 --> 00:01:34,159
and then we'll have a brief demo

00:01:30,400 --> 00:01:35,280
what it currently can do and finally i'd

00:01:34,159 --> 00:01:37,840
like to

00:01:35,280 --> 00:01:39,040
i'd like to showcase a few challenges

00:01:37,840 --> 00:01:42,479
that we faced

00:01:39,040 --> 00:01:44,320
and provide a brief outlook

00:01:42,479 --> 00:01:46,880
and with that let's take a look at what

00:01:44,320 --> 00:01:49,040
is the language server protocol actually

00:01:46,880 --> 00:01:51,680
so as you might have guessed that's a

00:01:49,040 --> 00:01:54,880
it's a protocol

00:01:51,680 --> 00:01:57,520
actually a json rpc protocol and

00:01:54,880 --> 00:01:58,320
it addresses this old problem so you

00:01:57,520 --> 00:02:00,640
have

00:01:58,320 --> 00:02:02,479
a whole ton of programming languages and

00:02:00,640 --> 00:02:03,280
you have a whole ton of different

00:02:02,479 --> 00:02:05,040
editors

00:02:03,280 --> 00:02:06,880
and they are all written in different

00:02:05,040 --> 00:02:10,720
programming languages have different

00:02:06,880 --> 00:02:13,840
apis if they have apis at all

00:02:10,720 --> 00:02:16,319
now if you have programming language a

00:02:13,840 --> 00:02:17,840
and you want to and you want to give

00:02:16,319 --> 00:02:20,239
your users

00:02:17,840 --> 00:02:20,959
so other developers you want to give

00:02:20,239 --> 00:02:24,000
them

00:02:20,959 --> 00:02:25,920
code completion documentation showing

00:02:24,000 --> 00:02:28,959
etc pp

00:02:25,920 --> 00:02:30,560
in five different editors you have to

00:02:28,959 --> 00:02:31,200
write a plugin for five different

00:02:30,560 --> 00:02:33,120
editors

00:02:31,200 --> 00:02:35,360
and that's a whole lot of work and every

00:02:33,120 --> 00:02:37,760
single person implementing

00:02:35,360 --> 00:02:40,239
uh something like that for their

00:02:37,760 --> 00:02:42,560
programming language has to do that

00:02:40,239 --> 00:02:44,640
and so that's there's a lot of

00:02:42,560 --> 00:02:46,720
duplication going on

00:02:44,640 --> 00:02:48,959
the language server protocol tries to

00:02:46,720 --> 00:02:52,800
address this in the following way

00:02:48,959 --> 00:02:55,280
so it defines a cut a common protocol

00:02:52,800 --> 00:02:56,239
for all these kinds of stuff that you

00:02:55,280 --> 00:02:58,480
for all these

00:02:56,239 --> 00:02:59,360
things that you want to have in an

00:02:58,480 --> 00:03:01,760
editor

00:02:59,360 --> 00:03:02,560
when working with programming languages

00:03:01,760 --> 00:03:06,159
like

00:03:02,560 --> 00:03:09,440
auto completion diagnostics

00:03:06,159 --> 00:03:10,720
documentation showing code formatting

00:03:09,440 --> 00:03:14,319
for instance

00:03:10,720 --> 00:03:18,159
um jump to definition jump to references

00:03:14,319 --> 00:03:21,360
refactoring etc etc and so

00:03:18,159 --> 00:03:23,519
the language server protocol defines how

00:03:21,360 --> 00:03:25,599
a language server which is some kind of

00:03:23,519 --> 00:03:27,200
backend program that analyzes your

00:03:25,599 --> 00:03:30,080
source code

00:03:27,200 --> 00:03:31,120
and the editor simply talks to this

00:03:30,080 --> 00:03:34,080
language server

00:03:31,120 --> 00:03:36,159
and says that hey i'm at this position

00:03:34,080 --> 00:03:38,560
in this file

00:03:36,159 --> 00:03:39,360
what can i autocomplete now or is this

00:03:38,560 --> 00:03:43,680
thing correct

00:03:39,360 --> 00:03:45,200
or um oh what's the current symbol at

00:03:43,680 --> 00:03:47,360
this point

00:03:45,200 --> 00:03:50,480
does it have a documentation where is it

00:03:47,360 --> 00:03:52,560
used and so on and so that's defined by

00:03:50,480 --> 00:03:53,680
the language server protocol and the

00:03:52,560 --> 00:03:58,080
cool thing about this

00:03:53,680 --> 00:03:59,040
is you as a developer of a programming

00:03:58,080 --> 00:04:01,280
language

00:03:59,040 --> 00:04:02,959
you only have to write this back-end

00:04:01,280 --> 00:04:05,840
server

00:04:02,959 --> 00:04:07,200
and you can talk to all you can provide

00:04:05,840 --> 00:04:09,519
all these nice

00:04:07,200 --> 00:04:11,760
these niceties to your users

00:04:09,519 --> 00:04:13,599
independently of the editor that they're

00:04:11,760 --> 00:04:14,000
using provided that it talks the

00:04:13,599 --> 00:04:16,720
language

00:04:14,000 --> 00:04:18,880
server protocol on the other hand if

00:04:16,720 --> 00:04:21,359
you're developing a new editor

00:04:18,880 --> 00:04:23,280
and you want your users to be able to be

00:04:21,359 --> 00:04:25,280
to have access to all these

00:04:23,280 --> 00:04:27,120
all these nice things you just have to

00:04:25,280 --> 00:04:29,360
implement the language server protocol

00:04:27,120 --> 00:04:30,240
and you can talk to all these backend

00:04:29,360 --> 00:04:32,160
processes

00:04:30,240 --> 00:04:34,320
to these all these backend servers and

00:04:32,160 --> 00:04:37,199
you have access to a whole

00:04:34,320 --> 00:04:38,400
to a whole ecosystem and that's pretty

00:04:37,199 --> 00:04:41,600
great

00:04:38,400 --> 00:04:42,000
so that's why we looked into it to

00:04:41,600 --> 00:04:44,720
improve

00:04:42,000 --> 00:04:46,320
the editor integration for solstack so

00:04:44,720 --> 00:04:48,720
what's saltstack

00:04:46,320 --> 00:04:49,680
saltstack is a configuration management

00:04:48,720 --> 00:04:53,360
software

00:04:49,680 --> 00:04:56,000
it's it's quite comparable to ansible

00:04:53,360 --> 00:04:56,479
in the regard that it runs in agentless

00:04:56,000 --> 00:04:59,840
mode

00:04:56,479 --> 00:05:02,960
but it also provides a server pull mode

00:04:59,840 --> 00:05:06,240
like you would know it from puppet

00:05:02,960 --> 00:05:08,400
um it's i would say it's more closely

00:05:06,240 --> 00:05:09,520
related to ansible since it's also

00:05:08,400 --> 00:05:12,720
written in python

00:05:09,520 --> 00:05:15,919
it's also it also uses ginger 2

00:05:12,720 --> 00:05:19,290
and yaml for for the

00:05:15,919 --> 00:05:20,720
for your main files and so what's

00:05:19,290 --> 00:05:23,199
[Music]

00:05:20,720 --> 00:05:24,720
what's also notable about saltstack it's

00:05:23,199 --> 00:05:26,560
the main comp

00:05:24,720 --> 00:05:28,000
it's the configuration management

00:05:26,560 --> 00:05:30,080
software behind uni

00:05:28,000 --> 00:05:31,520
which is the upstream project of suse

00:05:30,080 --> 00:05:35,199
manager

00:05:31,520 --> 00:05:37,840
uh so what you usually write in salt

00:05:35,199 --> 00:05:39,840
uh when using saltstack are so called

00:05:37,840 --> 00:05:42,160
salt states

00:05:39,840 --> 00:05:42,880
and these are essentially files that

00:05:42,160 --> 00:05:46,000
describe

00:05:42,880 --> 00:05:47,919
the desired state of a system so how

00:05:46,000 --> 00:05:49,280
does this look like so that's a mix of

00:05:47,919 --> 00:05:52,320
ginger 2

00:05:49,280 --> 00:05:55,120
for templating and yaml files

00:05:52,320 --> 00:05:56,880
and here you can see an example so here

00:05:55,120 --> 00:05:58,319
for instance we describe something that

00:05:56,880 --> 00:06:01,039
should be a web server

00:05:58,319 --> 00:06:02,880
and that in this case it means we want a

00:06:01,039 --> 00:06:04,160
package to be installed in this case

00:06:02,880 --> 00:06:07,199
apache

00:06:04,160 --> 00:06:09,600
and here we use ginger templates

00:06:07,199 --> 00:06:11,680
to distinguish the different package

00:06:09,600 --> 00:06:14,400
names for different distributions

00:06:11,680 --> 00:06:17,319
so for your red hat variants it's called

00:06:14,400 --> 00:06:21,680
the packages called http

00:06:17,319 --> 00:06:24,319
httpd and on your debian and derivatives

00:06:21,680 --> 00:06:27,919
it's called apache 2.

00:06:24,319 --> 00:06:29,199
and please keep in mind that in contrast

00:06:27,919 --> 00:06:31,919
to ansible

00:06:29,199 --> 00:06:33,120
the ginger templating is applied before

00:06:31,919 --> 00:06:36,160
feeding it into a

00:06:33,120 --> 00:06:39,039
into yammer which has the advantages

00:06:36,160 --> 00:06:41,280
you can you can really leverage the full

00:06:39,039 --> 00:06:45,280
power of ginger templates

00:06:41,280 --> 00:06:48,639
in um in ansible you can only use them

00:06:45,280 --> 00:06:52,400
really in yaml strings which has its

00:06:48,639 --> 00:06:56,000
upsides and its downsides

00:06:52,400 --> 00:06:59,759
so why did we do this and

00:06:56,000 --> 00:07:00,800
and when so the why is we found editor

00:06:59,759 --> 00:07:02,800
support for

00:07:00,800 --> 00:07:04,319
configuration management to be rather

00:07:02,800 --> 00:07:06,880
lacking so there is

00:07:04,319 --> 00:07:08,560
extensions for salt stack for various

00:07:06,880 --> 00:07:11,039
editors

00:07:08,560 --> 00:07:12,000
same goes for ansible but unfortunately

00:07:11,039 --> 00:07:15,919
these are all

00:07:12,000 --> 00:07:16,479
tied to certain editors and they are not

00:07:15,919 --> 00:07:19,599
really

00:07:16,479 --> 00:07:22,639
too powerful so usually they provide

00:07:19,599 --> 00:07:24,960
good completion

00:07:22,639 --> 00:07:26,720
excuse me so they provide good

00:07:24,960 --> 00:07:29,520
completion they provide use

00:07:26,720 --> 00:07:31,199
in certain places diagnostics and stuff

00:07:29,520 --> 00:07:34,720
like that but it's not really

00:07:31,199 --> 00:07:36,960
context where it's limited to one editor

00:07:34,720 --> 00:07:37,840
and configuration management is really

00:07:36,960 --> 00:07:40,080
becoming

00:07:37,840 --> 00:07:41,840
increasingly complex and especially if

00:07:40,080 --> 00:07:45,039
you have really powerful tools like

00:07:41,840 --> 00:07:47,360
saltstack like ansible

00:07:45,039 --> 00:07:48,560
you can it's becoming more like writing

00:07:47,360 --> 00:07:51,919
code but

00:07:48,560 --> 00:07:55,039
the the tools that you have as

00:07:51,919 --> 00:07:58,160
someone writing these writing this

00:07:55,039 --> 00:08:01,440
stuff they are not on par

00:07:58,160 --> 00:08:03,759
with your powerful ides and

00:08:01,440 --> 00:08:06,080
we wanted to take a look if we can

00:08:03,759 --> 00:08:07,280
really write a prototype of a language

00:08:06,080 --> 00:08:10,960
server

00:08:07,280 --> 00:08:14,560
that shows that it's possible to

00:08:10,960 --> 00:08:18,879
provide you with more and so

00:08:14,560 --> 00:08:21,280
we that's cedric boston and myself

00:08:18,879 --> 00:08:22,319
we sat down during this year's hack week

00:08:21,280 --> 00:08:25,199
00:08:22,319 --> 00:08:26,879
in march and we developed a prototype of

00:08:25,199 --> 00:08:30,160
this

00:08:26,879 --> 00:08:32,880
so and what did we do so

00:08:30,160 --> 00:08:34,959
we developed a language server and we

00:08:32,880 --> 00:08:37,360
wrote it in python

00:08:34,959 --> 00:08:38,560
we chose python a because we are both

00:08:37,360 --> 00:08:40,880
familiar with it

00:08:38,560 --> 00:08:42,800
and b because salt stack itself is

00:08:40,880 --> 00:08:43,120
written in python and that means we have

00:08:42,800 --> 00:08:46,959
some

00:08:43,120 --> 00:08:50,160
easy interoperability with it um

00:08:46,959 --> 00:08:53,200
for the language server protocol itself

00:08:50,160 --> 00:08:55,440
we leverage the pi gls library

00:08:53,200 --> 00:08:57,760
so that allows us to actually to really

00:08:55,440 --> 00:09:01,040
focus on just providing the data

00:08:57,760 --> 00:09:02,000
and and pi gls then takes care of all

00:09:01,040 --> 00:09:04,800
the actual

00:09:02,000 --> 00:09:06,880
protocol talking itself we don't have to

00:09:04,800 --> 00:09:10,160
take care of that

00:09:06,880 --> 00:09:13,040
we then use pi yaml for the yaml parsing

00:09:10,160 --> 00:09:15,360
so initially we really used pi ml cml

00:09:13,040 --> 00:09:17,279
passer then we briefly switched to ruama

00:09:15,360 --> 00:09:20,160
since it provided more features

00:09:17,279 --> 00:09:22,000
and switched back again to pi ammo and

00:09:20,160 --> 00:09:23,760
now we just use its scanner and have a

00:09:22,000 --> 00:09:25,279
custom state machine that cedric

00:09:23,760 --> 00:09:28,399
implemented

00:09:25,279 --> 00:09:30,240
so that we can parse broken yaml which

00:09:28,399 --> 00:09:32,720
is quite important in case the

00:09:30,240 --> 00:09:34,880
user is currently typing stuff and in

00:09:32,720 --> 00:09:37,839
the future we'd also like to use the

00:09:34,880 --> 00:09:40,640
ginger 2 for ginger templating but

00:09:37,839 --> 00:09:42,080
unfortunately we're not there yet

00:09:40,640 --> 00:09:44,880
[Music]

00:09:42,080 --> 00:09:47,839
really currently tiny component is the

00:09:44,880 --> 00:09:50,160
is the front end so essentially the

00:09:47,839 --> 00:09:51,600
the vs code and the emacs extension but

00:09:50,160 --> 00:09:53,680
these are really

00:09:51,600 --> 00:09:56,240
they don't do a whole time they just

00:09:53,680 --> 00:09:59,440
launch long language server and tell

00:09:56,240 --> 00:10:02,480
tell the editor hey if you edit

00:09:59,440 --> 00:10:04,399
sold stack files talk to this editor

00:10:02,480 --> 00:10:06,240
talk to this language server and that's

00:10:04,399 --> 00:10:08,480
about it

00:10:06,240 --> 00:10:10,000
and with that let's take a look how this

00:10:08,480 --> 00:10:10,880
how this currently looks like what it

00:10:10,000 --> 00:10:14,079
can do

00:10:10,880 --> 00:10:17,600
so what i have in here is vs code

00:10:14,079 --> 00:10:20,399
i have an example solid state file open

00:10:17,600 --> 00:10:22,560
and uh so first let's take a look at

00:10:20,399 --> 00:10:24,800
what we can do with in terms of our

00:10:22,560 --> 00:10:26,000
completion so one of the thing that sold

00:10:24,800 --> 00:10:28,959
stack has

00:10:26,000 --> 00:10:29,440
is these includes you can include you

00:10:28,959 --> 00:10:31,760
can

00:10:29,440 --> 00:10:33,440
tell salt to include the definitions

00:10:31,760 --> 00:10:35,760
from other files in here

00:10:33,440 --> 00:10:38,160
and what the language will provide you

00:10:35,760 --> 00:10:39,200
is potential other files that you can

00:10:38,160 --> 00:10:41,279
include

00:10:39,200 --> 00:10:43,440
so these are all the ones that this

00:10:41,279 --> 00:10:46,880
repository currently has

00:10:43,440 --> 00:10:49,680
and so you can just um you can just

00:10:46,880 --> 00:10:50,560
trigger completion here and let it

00:10:49,680 --> 00:10:54,560
include

00:10:50,560 --> 00:10:57,120
whatever you like so that's it

00:10:54,560 --> 00:10:58,560
that's one thing another thing that that

00:10:57,120 --> 00:11:01,839
it will complete

00:10:58,560 --> 00:11:04,880
is these uh is this uh

00:11:01,839 --> 00:11:06,240
is the sub module names where you can

00:11:04,880 --> 00:11:09,440
essentially

00:11:06,240 --> 00:11:12,160
um where it will take

00:11:09,440 --> 00:11:14,000
the uh it will find out what's the

00:11:12,160 --> 00:11:16,240
current module that you have here

00:11:14,000 --> 00:11:18,480
before the dot and it will provide you

00:11:16,240 --> 00:11:20,880
with the completion of the current

00:11:18,480 --> 00:11:22,640
of the correct sub modules so if you are

00:11:20,880 --> 00:11:25,839
familiar with this you see

00:11:22,640 --> 00:11:27,680
you will see it will only give you those

00:11:25,839 --> 00:11:30,320
that belong to the file module

00:11:27,680 --> 00:11:32,800
i for instance replace this with the git

00:11:30,320 --> 00:11:35,920
sub module it will only show you stuff

00:11:32,800 --> 00:11:41,120
of the github module um

00:11:35,920 --> 00:11:41,120
or for pkg and so on yeah

00:11:41,279 --> 00:11:45,040
good so that's what supported in terms

00:11:43,600 --> 00:11:47,760
of auto completion

00:11:45,040 --> 00:11:49,040
then what you can also see uh i hope at

00:11:47,760 --> 00:11:52,160
least in the recording

00:11:49,040 --> 00:11:53,920
are the breadcrumbs in here so these are

00:11:52,160 --> 00:11:56,079
also provided as docu

00:11:53,920 --> 00:11:57,519
these are so called document symbols in

00:11:56,079 --> 00:12:00,079
the back end

00:11:57,519 --> 00:12:01,760
and you can use these to jump around and

00:12:00,079 --> 00:12:02,720
it essentially means that the language

00:12:01,760 --> 00:12:05,920
server

00:12:02,720 --> 00:12:07,360
is kind of is aware of the structure of

00:12:05,920 --> 00:12:09,920
this document

00:12:07,360 --> 00:12:10,399
you can jump around in that you also saw

00:12:09,920 --> 00:12:13,040
some

00:12:10,399 --> 00:12:13,760
comp some documentation is shown up here

00:12:13,040 --> 00:12:17,200
so

00:12:13,760 --> 00:12:20,560
that could be also shown here in places

00:12:17,200 --> 00:12:21,680
and the last thing that we that's also

00:12:20,560 --> 00:12:25,120
supported

00:12:21,680 --> 00:12:25,440
is jump to definition so what sol stack

00:12:25,120 --> 00:12:28,800
has

00:12:25,440 --> 00:12:29,519
is these so-called requires it means

00:12:28,800 --> 00:12:33,279
that

00:12:29,519 --> 00:12:36,240
this if you want to that this state

00:12:33,279 --> 00:12:37,440
requires this other one and what you can

00:12:36,240 --> 00:12:40,720
do you just

00:12:37,440 --> 00:12:42,560
go right right mouse button go to

00:12:40,720 --> 00:12:44,720
definition and then it will jump to the

00:12:42,560 --> 00:12:47,839
correct place

00:12:44,720 --> 00:12:49,839
it works from other places or here we

00:12:47,839 --> 00:12:50,720
have other ones okay so here i require

00:12:49,839 --> 00:12:57,120
this

00:12:50,720 --> 00:13:00,320
jam jackal and boom i can jump in there

00:12:57,120 --> 00:13:03,440
so that should be about it for the demo

00:13:00,320 --> 00:13:06,320
then a few challenges that we faced so

00:13:03,440 --> 00:13:07,120
one of the one of the challenging parts

00:13:06,320 --> 00:13:08,639
is

00:13:07,120 --> 00:13:11,040
if you are currently typing in your

00:13:08,639 --> 00:13:14,320
editor then you don't really have valid

00:13:11,040 --> 00:13:15,920
ammo so we need to be we need to be able

00:13:14,320 --> 00:13:18,959
to parse broken yaml

00:13:15,920 --> 00:13:21,200
that's also why we only use yamas the

00:13:18,959 --> 00:13:23,040
pi ml scanner and have this custom state

00:13:21,200 --> 00:13:26,160
machine that cedric implemented

00:13:23,040 --> 00:13:29,839
so that we can really do that stuff

00:13:26,160 --> 00:13:32,880
um yeah meaningful testing is as usual

00:13:29,839 --> 00:13:34,240
as you as you might have guessed pretty

00:13:32,880 --> 00:13:37,279
challenging especially

00:13:34,240 --> 00:13:39,360
if you have different editors in place

00:13:37,279 --> 00:13:42,480
and the most challenging part at this

00:13:39,360 --> 00:13:45,440
point is really the ginger 2

00:13:42,480 --> 00:13:47,440
interpretation the really nasty part

00:13:45,440 --> 00:13:48,560
here is that the templating is applied

00:13:47,440 --> 00:13:52,480
before

00:13:48,560 --> 00:13:54,079
the yaml parsing which means extracting

00:13:52,480 --> 00:13:57,279
stuff from

00:13:54,079 --> 00:13:59,680
stuff from files like this is uh

00:13:57,279 --> 00:14:01,760
can be really tough because you can go

00:13:59,680 --> 00:14:05,120
really really crazy with

00:14:01,760 --> 00:14:09,519
with the ginger templating and so

00:14:05,120 --> 00:14:09,519
this is yet an unsolved problem

00:14:09,680 --> 00:14:13,040
um let's take a brief look into the

00:14:12,160 --> 00:14:15,199
future

00:14:13,040 --> 00:14:17,279
so unfortunately this is really just a

00:14:15,199 --> 00:14:19,040
side project for us and we don't have a

00:14:17,279 --> 00:14:21,760
whole ton of time to invest for

00:14:19,040 --> 00:14:24,000
into it so unfortunately progress has

00:14:21,760 --> 00:14:27,760
been a little bit slow

00:14:24,000 --> 00:14:29,040
um but the biggest thing that needs to

00:14:27,760 --> 00:14:32,560
be implemented in this

00:14:29,040 --> 00:14:34,240
is the is as i already said the ginger 2

00:14:32,560 --> 00:14:36,240
parsing

00:14:34,240 --> 00:14:37,600
and then there's a few other stuff

00:14:36,240 --> 00:14:40,480
things that we could implement

00:14:37,600 --> 00:14:41,279
for instance show show the documentation

00:14:40,480 --> 00:14:44,480
of

00:14:41,279 --> 00:14:47,040
of various elements integration with

00:14:44,480 --> 00:14:50,480
salt land to provide you with some

00:14:47,040 --> 00:14:53,199
with some linting of your document

00:14:50,480 --> 00:14:54,959
auto completion in more places and then

00:14:53,199 --> 00:14:57,279
as i showed you can jump to

00:14:54,959 --> 00:14:58,880
you can jump to these requisite nodes

00:14:57,279 --> 00:15:01,440
where they are defined whether

00:14:58,880 --> 00:15:03,760
defined it would be nice to be able to

00:15:01,440 --> 00:15:06,639
do it the other way around so to jump to

00:15:03,760 --> 00:15:07,920
where they are referenced here you can

00:15:06,639 --> 00:15:10,639
find a few links so

00:15:07,920 --> 00:15:12,560
to the source code to the extension in

00:15:10,639 --> 00:15:15,760
the vs code marketplace

00:15:12,560 --> 00:15:18,720
a blog post summary of the hack week the

00:15:15,760 --> 00:15:21,279
link to the slides are also on github

00:15:18,720 --> 00:15:24,000
and the lsp specifications

00:15:21,279 --> 00:15:26,000
the obligatory legal slide and with that

00:15:24,000 --> 00:15:29,920
i'd like to thank you for your attention

00:15:26,000 --> 00:15:29,920

YouTube URL: https://www.youtube.com/watch?v=_Llz3Md4gkE


