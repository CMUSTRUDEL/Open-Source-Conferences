Title: OSC15 - Michal Hrušecký  - Gentle introduction to ZeroMQ and friends
Publication date: 2015-05-04
Playlist: openSUSE Conference 2015
Description: 
	Short introduction to ZeroMQ stack and related tools. If you were ever interested in writing a network application and if you would like to see nice and easy way how to do so, come and see. Apart from ZeroMQ, we will take a look other related projects being developed under the same umbrella:
* CZMQ - high-level API for ZeroMQ
* zproto - protocol and state machine generator using GSL templating system
* malamute - simple broker based on top of ZeroMQ
Workshop about current video streaming and recording software and hardware tools:
What kind of software are we using and why (Its really all Open-source).
Quickly streaming or recording in full quality, how to deal with it.
Advantage and disadvantage of 3-partty streaming server.
Overview of our hardware equipment on OpenSUSE conference and talk about possible replacements.
Redesign our setup to be able work with new Video technologies. What need to be done and what to buy.
Forecast to future, when will be OpenSUSE in HD ?

Subscribe ►http://bit.ly/1G2KKZl

Offical Website ►https://www.opensuse.org
Follow us on Twitter ► https://twitter.com/openSUSE
Like us on Facebook ► https://www.facebook.com/en.openSUSE
Follow us on Google+ ► https://www.plus.google.com/openSUSE
Captions: 
	00:00:00,000 --> 00:00:06,620
oh hi everybody welcome here if you are

00:00:06,710 --> 00:00:12,469
if you are looking on this from the

00:00:09,150 --> 00:00:16,730
record and you missed it I'm sorry I

00:00:12,469 --> 00:00:22,859
also do know that it was moved here so

00:00:16,730 --> 00:00:25,650
yeah so let's talk about zeromq I will

00:00:22,859 --> 00:00:29,000
start with one quick poll in the

00:00:25,650 --> 00:00:31,679
audience how hope you already wrote some

00:00:29,000 --> 00:00:37,559
network application that has to

00:00:31,679 --> 00:00:44,510
communicate over the network ok so not

00:00:37,559 --> 00:00:54,030
so many people and did you enjoyed it

00:00:44,510 --> 00:00:58,730
not so much ok so so zeromq will be

00:00:54,030 --> 00:01:01,260
about writing network applications and

00:00:58,730 --> 00:01:03,270
it will be writing network applications

00:01:01,260 --> 00:01:06,769
in a way that I hope that you could

00:01:03,270 --> 00:01:06,769
enjoy in the end

00:01:08,710 --> 00:01:14,680
so let's see what are the obvious

00:01:12,190 --> 00:01:17,500
answers when you write the network

00:01:14,680 --> 00:01:21,460
applications there are these unique

00:01:17,500 --> 00:01:25,630
circuits that are quite low level it's

00:01:21,460 --> 00:01:27,850
hard to use if you ever tried it and you

00:01:25,630 --> 00:01:31,000
have to do pretty much everything by

00:01:27,850 --> 00:01:33,909
yourself it gives you quite some freedom

00:01:31,000 --> 00:01:37,540
in doing stuff but it's quite tiresome

00:01:33,909 --> 00:01:39,720
if you just want to make your

00:01:37,540 --> 00:01:42,899
application work over the network and

00:01:39,720 --> 00:01:46,420
you are not so interested in networking

00:01:42,899 --> 00:01:49,630
you just want to pass data from one end

00:01:46,420 --> 00:01:51,789
to the other and you don't care what's

00:01:49,630 --> 00:01:57,210
on there if there are some drawers

00:01:51,789 --> 00:02:02,520
running around then there are other

00:01:57,210 --> 00:02:07,539
options run of pretty well-known one is

00:02:02,520 --> 00:02:10,630
mq these are some message based it has

00:02:07,539 --> 00:02:14,650
plenty of patterns it well known in Java

00:02:10,630 --> 00:02:19,030
verte and mostly it's in Java and it has

00:02:14,650 --> 00:02:21,579
heavy broker and it's not so actually

00:02:19,030 --> 00:02:23,380
easy to start with it you need to read a

00:02:21,579 --> 00:02:25,959
lot of documentation before you can

00:02:23,380 --> 00:02:28,630
write your hello word applications so

00:02:25,959 --> 00:02:30,910
basically that's all I know about it

00:02:28,630 --> 00:02:34,209
because when I was trying to start with

00:02:30,910 --> 00:02:40,420
it I got discouraged before I finished

00:02:34,209 --> 00:02:44,860
my hello world application so what is 0

00:02:40,420 --> 00:02:48,790
mq it's easy to use it's fast a

00:02:44,860 --> 00:02:52,510
synchronous it's also message based so

00:02:48,790 --> 00:02:56,019
it's that's part of the being easy to

00:02:52,510 --> 00:02:59,920
use and you don't have to have a broker

00:02:56,019 --> 00:03:02,760
you can do all the fancy patterns but

00:02:59,920 --> 00:03:08,850
you can do them even without the broker

00:03:02,760 --> 00:03:12,160
and yeah it has quite active community

00:03:08,850 --> 00:03:16,570
project is on github they are emerging

00:03:12,160 --> 00:03:19,020
pull requests quite fast one of the

00:03:16,570 --> 00:03:22,930
philosophical

00:03:19,020 --> 00:03:28,300
ideas of one of the main guys behind

00:03:22,930 --> 00:03:34,290
zeromq is that master should be quite

00:03:28,300 --> 00:03:37,120
stable always and you shouldn't wait for

00:03:34,290 --> 00:03:40,570
pull request to get merged several days

00:03:37,120 --> 00:03:43,210
so everything gets merged quite fast and

00:03:40,570 --> 00:03:46,150
they are actually not breaking so much

00:03:43,210 --> 00:03:51,100
stuff and if they do they fix it quite

00:03:46,150 --> 00:03:53,020
quite fast as well and it has some other

00:03:51,100 --> 00:03:54,940
interesting features and it has some

00:03:53,020 --> 00:03:56,350
libraries around it that are also

00:03:54,940 --> 00:04:00,850
interesting we will talk about it later

00:03:56,350 --> 00:04:04,150
and it's not only available over the

00:04:00,850 --> 00:04:06,370
network you can use it as IPC protocol

00:04:04,150 --> 00:04:10,810
as well so you can communicate between

00:04:06,370 --> 00:04:14,200
processes on the local machine as well

00:04:10,810 --> 00:04:16,120
and when you grow and you no longer

00:04:14,200 --> 00:04:20,919
manage to do it on the single machine

00:04:16,120 --> 00:04:24,310
you just change the connection strings

00:04:20,919 --> 00:04:31,090
from IPC to TCP and you are ready to

00:04:24,310 --> 00:04:35,760
deploy in the network and one of the

00:04:31,090 --> 00:04:38,560
interesting stuff is here is a list of

00:04:35,760 --> 00:04:43,030
languages language bindings that are

00:04:38,560 --> 00:04:45,910
supported for your mq and for quite some

00:04:43,030 --> 00:04:49,890
of them they also have examples in the

00:04:45,910 --> 00:04:53,770
cookbook to help you get started so

00:04:49,890 --> 00:04:56,560
whatever language you like probably it's

00:04:53,770 --> 00:04:59,160
somewhere in there yeah there is a

00:04:56,560 --> 00:04:59,160
unesco

00:05:02,030 --> 00:05:16,349
no I haven't package I think none of

00:05:12,270 --> 00:05:26,340
them but my friend did some of them are

00:05:16,349 --> 00:05:31,199
mainly C and C++ okay so some general

00:05:26,340 --> 00:05:33,990
recommendations from the project if you

00:05:31,199 --> 00:05:38,990
are doing distributed systems so they

00:05:33,990 --> 00:05:42,720
are hard so one of the philosophical

00:05:38,990 --> 00:05:45,120
point of view behind zeromq is try to

00:05:42,720 --> 00:05:49,409
avoid complexity whenever it when i

00:05:45,120 --> 00:05:51,150
whenever it is possible so that's why it

00:05:49,409 --> 00:05:54,349
doesn't have a broker because it's

00:05:51,150 --> 00:05:58,169
single point of failure by default and

00:05:54,349 --> 00:06:00,630
yeah some if you want to do some type of

00:05:58,169 --> 00:06:03,080
patterns or some type of communications

00:06:00,630 --> 00:06:05,400
you cannot do them without the broker or

00:06:03,080 --> 00:06:09,139
it is much easier to do them without

00:06:05,400 --> 00:06:12,090
with a broker but you shouldn't put put

00:06:09,139 --> 00:06:15,750
much of the functionality inside the

00:06:12,090 --> 00:06:21,360
broker and another nice recommendation

00:06:15,750 --> 00:06:24,060
from them is it's much better and it

00:06:21,360 --> 00:06:27,949
will help you in the future to actually

00:06:24,060 --> 00:06:31,020
be prepared to recover from disasters

00:06:27,949 --> 00:06:36,000
when some of your notes or block will go

00:06:31,020 --> 00:06:38,849
down then to try to optimize not to have

00:06:36,000 --> 00:06:42,900
those disasters you cannot avoid some

00:06:38,849 --> 00:06:49,020
malfunctioning or something crashing but

00:06:42,900 --> 00:06:52,590
it's always good to have a plan for

00:06:49,020 --> 00:06:59,069
recovery and test that you can recover

00:06:52,590 --> 00:07:02,250
and actually 40 mq there is this low

00:06:59,069 --> 00:07:05,219
level 0 mq library but if you want to

00:07:02,250 --> 00:07:09,539
use it i would highly recommend using CZ

00:07:05,219 --> 00:07:12,409
mq which is also in c but it's much

00:07:09,539 --> 00:07:19,129
higher level and it's easier even

00:07:12,409 --> 00:07:20,959
you to use then zeromq itself and it has

00:07:19,129 --> 00:07:27,289
some other features we will talk about

00:07:20,959 --> 00:07:30,080
later and I said previously use it has

00:07:27,289 --> 00:07:34,489
some patterns that you can use similar

00:07:30,080 --> 00:07:36,399
to MU but you should try to use the

00:07:34,489 --> 00:07:39,709
simplest pattern that fits your needs

00:07:36,399 --> 00:07:42,889
because in the cookbook there are really

00:07:39,709 --> 00:07:47,449
complicated patterns and you could get

00:07:42,889 --> 00:07:50,539
really ducked down into all those

00:07:47,449 --> 00:07:53,869
patterns and ended up choosing between

00:07:50,539 --> 00:07:56,029
tens of them and implementing something

00:07:53,869 --> 00:07:58,189
that is really hard and has to change

00:07:56,029 --> 00:08:03,589
afterwards so try to keep it as simple

00:07:58,189 --> 00:08:07,969
as possible so now let's see some

00:08:03,589 --> 00:08:12,589
example this is some hello world example

00:08:07,969 --> 00:08:15,139
in unique sockets and I actually had to

00:08:12,589 --> 00:08:17,709
get rid of some of the error handling

00:08:15,139 --> 00:08:23,289
and stuff like that to fit it on once

00:08:17,709 --> 00:08:26,839
slide and i'm not sure where do you

00:08:23,289 --> 00:08:30,079
understand all of it but while probably

00:08:26,839 --> 00:08:35,269
with enough time you will but it's

00:08:30,079 --> 00:08:38,709
really unreadable and not so obvious i

00:08:35,269 --> 00:08:42,829
would say maybe for somebody its

00:08:38,709 --> 00:08:47,569
developers friendly but for me it's not

00:08:42,829 --> 00:08:52,759
so much so another have a word this time

00:08:47,569 --> 00:08:57,620
it in zeromq and here you see that we

00:08:52,759 --> 00:09:00,949
will just open zeromq socket with some

00:08:57,620 --> 00:09:05,180
type we will connect it and then we will

00:09:00,949 --> 00:09:07,939
send hello and we will wait we will

00:09:05,180 --> 00:09:12,129
receive something back and print it so

00:09:07,939 --> 00:09:15,889
the API is quite straightforward and

00:09:12,129 --> 00:09:23,449
quite simple

00:09:15,889 --> 00:09:28,209
and quite readable so I started with the

00:09:23,449 --> 00:09:28,209
type of socket what's going on

00:09:30,840 --> 00:09:51,440
I think it's getting somehow darker do

00:09:41,250 --> 00:09:55,880
you see it as well ah ok so strange you

00:09:51,440 --> 00:09:55,880
guys step on something no

00:09:58,440 --> 00:10:03,410
now no screensaver involved

00:10:15,190 --> 00:10:26,470
now but but something is better than

00:10:19,760 --> 00:10:29,510
nothing I would say ok so into example

00:10:26,470 --> 00:10:40,430
previously you saw that there was some

00:10:29,510 --> 00:10:44,350
magic constant zeit mq wreck and this

00:10:40,430 --> 00:10:53,630
specifies the pattern that we are using

00:10:44,350 --> 00:11:00,949
so let's see okay is it same on on your

00:10:53,630 --> 00:11:03,019
computer okay well okay so the simplest

00:11:00,949 --> 00:11:05,690
pattern that you can use his request

00:11:03,019 --> 00:11:07,279
reply you've got some client he requests

00:11:05,690 --> 00:11:11,360
something from the server and he will

00:11:07,279 --> 00:11:14,690
get replied back that's that simple but

00:11:11,360 --> 00:11:17,360
there's also add a pattern that is quite

00:11:14,690 --> 00:11:19,130
frequently used and that you might be

00:11:17,360 --> 00:11:21,709
interested in and that is more

00:11:19,130 --> 00:11:26,360
complicated and that is

00:11:21,709 --> 00:11:29,269
publish-subscribe and here you have one

00:11:26,360 --> 00:11:30,740
server and multiple of clients and all

00:11:29,269 --> 00:11:35,089
the clients are subscribed to the

00:11:30,740 --> 00:11:39,040
messages that server is pushing and in

00:11:35,089 --> 00:11:42,260
zeromq itself this pattern is a

00:11:39,040 --> 00:11:45,889
synchronous and you don't have

00:11:42,260 --> 00:11:48,290
guaranteed delivery so if you are

00:11:45,889 --> 00:11:51,110
pushing too many messages and there is a

00:11:48,290 --> 00:11:53,779
slow line somewhere in between the

00:11:51,110 --> 00:11:58,760
server and the client you can lose some

00:11:53,779 --> 00:12:00,980
of the messages but yeah it's quite nice

00:11:58,760 --> 00:12:04,910
if you need to subscribe multiple

00:12:00,980 --> 00:12:10,389
clients and if you need variable

00:12:04,910 --> 00:12:10,389
delivery then probably you need broker

00:12:12,080 --> 00:12:17,490
there are also other interesting parts

00:12:15,360 --> 00:12:19,800
of the easier mq stack that you can use

00:12:17,490 --> 00:12:25,490
there is something called detector

00:12:19,800 --> 00:12:30,060
that's a threat absorption library or

00:12:25,490 --> 00:12:31,800
object to help you with abstracting over

00:12:30,060 --> 00:12:35,910
the threads and it's actually used

00:12:31,800 --> 00:12:38,460
internally if you are dedicating some

00:12:35,910 --> 00:12:43,460
port or if you are dedicating some

00:12:38,460 --> 00:12:47,820
worker to process messages zette polar

00:12:43,460 --> 00:12:51,630
that's a another structure that iterates

00:12:47,820 --> 00:12:55,130
over several sockets and if you are

00:12:51,630 --> 00:12:58,890
listening on multiple boards on or

00:12:55,130 --> 00:13:03,240
multiple addresses then it will give you

00:12:58,890 --> 00:13:06,090
which one receive the message there are

00:13:03,240 --> 00:13:12,810
normal structures that can be useful

00:13:06,090 --> 00:13:16,980
like hash table lists linked lists other

00:13:12,810 --> 00:13:20,730
interesting features that are there is Z

00:13:16,980 --> 00:13:24,120
beacon and that gossip that beacon is

00:13:20,730 --> 00:13:27,900
used to discover other nodes inside the

00:13:24,120 --> 00:13:33,150
network it's using UDP and that gossip

00:13:27,900 --> 00:13:37,410
is gossip so basically you've got one

00:13:33,150 --> 00:13:39,480
now that has some some knowledge and it

00:13:37,410 --> 00:13:44,880
connects to another node and then they

00:13:39,480 --> 00:13:47,610
exchanged key value pairs and it tries

00:13:44,880 --> 00:13:51,060
to get all the network synchronized in

00:13:47,610 --> 00:13:55,470
the synchronized side by exchanging

00:13:51,060 --> 00:13:58,440
information between the beers and one of

00:13:55,470 --> 00:14:02,720
the new addition so which started last

00:13:58,440 --> 00:14:07,320
year is Mohammed and that's a simple

00:14:02,720 --> 00:14:13,270
broker focused on enterprise features

00:14:07,320 --> 00:14:18,970
that enterprises needs usually so

00:14:13,270 --> 00:14:21,940
a little bit about the broker yeah it

00:14:18,970 --> 00:14:25,800
supports some simple identification so

00:14:21,940 --> 00:14:28,360
you can have you can have a list of

00:14:25,800 --> 00:14:31,210
login names and passwords on the broker

00:14:28,360 --> 00:14:33,880
itself and it wouldn't let clients

00:14:31,210 --> 00:14:37,360
communicate unless you match these

00:14:33,880 --> 00:14:39,970
credentials but this identification is

00:14:37,360 --> 00:14:44,830
just a simple example of what can be

00:14:39,970 --> 00:14:49,630
done it doesn't support any ldap logins

00:14:44,830 --> 00:14:53,020
and stuff line air compared to pure

00:14:49,630 --> 00:14:56,830
zeromq it supports a reliable

00:14:53,020 --> 00:15:00,160
publish-subscribe pattern so even if

00:14:56,830 --> 00:15:02,860
there is a network problems between

00:15:00,160 --> 00:15:05,830
between your publisher and subscriber

00:15:02,860 --> 00:15:08,560
the broker will keep the queue of the

00:15:05,830 --> 00:15:12,400
messages and you will get it once you

00:15:08,560 --> 00:15:16,660
are a connected back so you are not

00:15:12,400 --> 00:15:18,580
losing any messages it supports simple

00:15:16,660 --> 00:15:21,340
request reply so you can communicate

00:15:18,580 --> 00:15:24,970
between the clients without knowing

00:15:21,340 --> 00:15:30,690
their physical address but by knowing

00:15:24,970 --> 00:15:30,690
just their name inside the system by day

00:15:30,990 --> 00:15:38,110
by the name that they present its to the

00:15:33,490 --> 00:15:42,190
broker and to make it wearable and

00:15:38,110 --> 00:15:44,860
working it spurts heart beating so when

00:15:42,190 --> 00:15:48,760
your client is no longer there it will

00:15:44,860 --> 00:15:52,990
disconnected and yeah you can reconnect

00:15:48,760 --> 00:15:55,150
back so messages don't get lost and it

00:15:52,990 --> 00:15:58,690
also supports something called services

00:15:55,150 --> 00:16:02,200
which is common queue for multiple

00:15:58,690 --> 00:16:05,140
workers imagine that you have multiple

00:16:02,200 --> 00:16:07,450
machines that can process requests and

00:16:05,140 --> 00:16:10,120
you are getting requests from the

00:16:07,450 --> 00:16:14,740
network and these requests are cute

00:16:10,120 --> 00:16:18,010
underwater on the bell curve and any of

00:16:14,740 --> 00:16:20,050
the workers can fetch the fish to

00:16:18,010 --> 00:16:22,470
request process it and send the response

00:16:20,050 --> 00:16:22,470
back

00:16:22,730 --> 00:16:31,730
so that's the third pattern that this

00:16:26,480 --> 00:16:33,800
simple build support but there are also

00:16:31,730 --> 00:16:38,149
some interesting some other interesting

00:16:33,800 --> 00:16:40,790
tools that we can use with zeromq one of

00:16:38,149 --> 00:16:44,449
the most interesting tools I would say

00:16:40,790 --> 00:16:49,399
is called Z Porter and it's code

00:16:44,449 --> 00:16:53,230
generator and it's unfortunately

00:16:49,399 --> 00:16:57,800
xml-based nobody likes to write xml but

00:16:53,230 --> 00:17:02,680
it's quite powerful it's based on gsl

00:16:57,800 --> 00:17:02,680
which is some code generation to and

00:17:03,069 --> 00:17:11,569
from this xml template it will generate

00:17:06,260 --> 00:17:14,000
you see cmq code and it can be used for

00:17:11,569 --> 00:17:15,439
example if you are developing some

00:17:14,000 --> 00:17:21,260
protocol that you want to communicate

00:17:15,439 --> 00:17:23,630
between your machines or processes then

00:17:21,260 --> 00:17:27,049
you just described the protocol and it

00:17:23,630 --> 00:17:29,720
will generate also handling functions to

00:17:27,049 --> 00:17:32,480
encode messages to decode messages to

00:17:29,720 --> 00:17:35,570
operate with them to send them over the

00:17:32,480 --> 00:17:38,210
network and stuff like that and apart

00:17:35,570 --> 00:17:40,970
from that it can also be used to

00:17:38,210 --> 00:17:45,250
describe statement state machine and

00:17:40,970 --> 00:17:49,130
then you can generate all your code and

00:17:45,250 --> 00:17:52,750
basically just hook up on the handling

00:17:49,130 --> 00:17:56,179
functions and avoid all the boring stuff

00:17:52,750 --> 00:17:58,970
that is involved in most of the

00:17:56,179 --> 00:18:03,970
programming like writing state machine

00:17:58,970 --> 00:18:03,970
from the scratch for the under times

00:18:04,270 --> 00:18:13,429
yeah it helps you get started much

00:18:08,840 --> 00:18:17,990
faster and you can throw away your coat

00:18:13,429 --> 00:18:20,690
and start from the scratch again so

00:18:17,990 --> 00:18:24,980
let's take a look at how it works this

00:18:20,690 --> 00:18:29,780
is example of message that could be

00:18:24,980 --> 00:18:33,020
described it it has some lame and it has

00:18:29,780 --> 00:18:34,110
some fields the fields can be under

00:18:33,020 --> 00:18:36,809
stirring or

00:18:34,110 --> 00:18:41,309
in this case it's dictionary so

00:18:36,809 --> 00:18:44,400
basically hash table or it can contain

00:18:41,309 --> 00:18:47,130
another message so you can create

00:18:44,400 --> 00:18:49,860
message and then put it inside another

00:18:47,130 --> 00:18:56,010
message and so long and so long and so

00:18:49,860 --> 00:19:00,030
long so this is pretty simple right yeah

00:18:56,010 --> 00:19:03,330
pretty obvious what what to do and then

00:19:00,030 --> 00:19:06,570
you write run code generator and you

00:19:03,330 --> 00:19:11,610
would get some API functions that you

00:19:06,570 --> 00:19:15,570
can use you can create a new message you

00:19:11,610 --> 00:19:19,860
can and encode it with all the fields

00:19:15,570 --> 00:19:24,419
filled or you can just set one of the

00:19:19,860 --> 00:19:30,299
fields for Strings you've got nice out

00:19:24,419 --> 00:19:33,299
paint f format so you don't have to a

00:19:30,299 --> 00:19:36,419
sprint it to some to some buffer and

00:19:33,299 --> 00:19:39,720
then put it there you can directly call

00:19:36,419 --> 00:19:43,020
this function which is very nice and

00:19:39,720 --> 00:19:47,070
convenient and there is also possibility

00:19:43,020 --> 00:19:50,280
to just buy to send it somewhere pass it

00:19:47,070 --> 00:19:57,049
the socket that you created and send it

00:19:50,280 --> 00:19:57,049
around so

00:19:57,240 --> 00:20:06,510
what else now this is a description of

00:20:03,180 --> 00:20:09,630
the state machine we've got some state

00:20:06,510 --> 00:20:13,500
we are connected and if somebody sends

00:20:09,630 --> 00:20:16,440
us subscribe message we will store it

00:20:13,500 --> 00:20:23,720
and we will reply yes you are subscribed

00:20:16,440 --> 00:20:23,720
and there is also another state which is

00:20:24,920 --> 00:20:32,100
inherited in all others and if somebody

00:20:29,790 --> 00:20:35,970
sends us a message that we are not

00:20:32,100 --> 00:20:39,300
handling then we apply that is invalid

00:20:35,970 --> 00:20:45,300
and if we got expired we will terminate

00:20:39,300 --> 00:20:48,450
the client so this is not so easy as the

00:20:45,300 --> 00:20:51,660
protocol itself but it's still quite

00:20:48,450 --> 00:20:54,420
understandable and if you run on

00:20:51,660 --> 00:21:00,020
generator you will get onions offline of

00:20:54,420 --> 00:21:05,820
quote which is much less readable and

00:21:00,020 --> 00:21:08,880
this is what you get you will actually

00:21:05,820 --> 00:21:11,610
get actor that is one of the abstraction

00:21:08,880 --> 00:21:15,180
that I spoke about earlier this great

00:21:11,610 --> 00:21:19,950
app section and you will just create a

00:21:15,180 --> 00:21:25,590
new server and tell it to bind somewhere

00:21:19,950 --> 00:21:28,350
and it started it's working it's it's

00:21:25,590 --> 00:21:31,410
listening for the connections and when

00:21:28,350 --> 00:21:33,240
it received the messages it will make it

00:21:31,410 --> 00:21:36,230
worse switch between the states and do

00:21:33,240 --> 00:21:40,260
whatever it is call it to do as you

00:21:36,230 --> 00:21:42,210
noticed in the previous slide we said

00:21:40,260 --> 00:21:45,170
that there is a some action like

00:21:42,210 --> 00:21:49,070
subscribe client

00:21:45,170 --> 00:21:52,430
yeah the generator doesn't know what we

00:21:49,070 --> 00:21:57,200
mean by that so it will just generate

00:21:52,430 --> 00:22:01,160
some stop functions which are by default

00:21:57,200 --> 00:22:04,610
empty then you can go and fill fill in

00:22:01,160 --> 00:22:07,550
those and during generations these are

00:22:04,610 --> 00:22:09,970
not going to be overrated so they will

00:22:07,550 --> 00:22:13,340
stay and you just fill in the

00:22:09,970 --> 00:22:16,040
functionality that is behind your

00:22:13,340 --> 00:22:19,490
application you fill the logic itself

00:22:16,040 --> 00:22:21,170
not the boring part about handling

00:22:19,490 --> 00:22:25,400
various states and switching between

00:22:21,170 --> 00:22:29,570
them and stuff like that you just handle

00:22:25,400 --> 00:22:39,440
the really important logic that machine

00:22:29,570 --> 00:22:42,100
cannot do for you so ah ok it

00:22:39,440 --> 00:22:42,100
disappeared again

00:22:47,070 --> 00:22:56,620
okay so there is something called zeit

00:22:50,800 --> 00:23:04,600
guide the URL is that guide dot 0 mq dot

00:22:56,620 --> 00:23:07,150
org or there is a github com / 0 mq you

00:23:04,600 --> 00:23:09,700
can go visit those sites the first one

00:23:07,150 --> 00:23:11,950
is quite a lengthy book describing

00:23:09,700 --> 00:23:15,430
various patterns that you can use with

00:23:11,950 --> 00:23:17,890
your mq it also contains examples it in

00:23:15,430 --> 00:23:22,780
quite some of the languages that were

00:23:17,890 --> 00:23:30,160
mentioned at the beginning on github / 0

00:23:22,780 --> 00:23:33,010
mq you can get CZ mq 0 mq other other

00:23:30,160 --> 00:23:37,660
bindings and other related projects like

00:23:33,010 --> 00:23:40,330
z proto there is also that project of

00:23:37,660 --> 00:23:43,179
the project is another interesting code

00:23:40,330 --> 00:23:45,190
generator but it generates see Meg and

00:23:43,179 --> 00:23:49,360
how to make file sick if you don't want

00:23:45,190 --> 00:23:53,770
to write them by hand so yeah check out

00:23:49,360 --> 00:23:56,679
those that guide to find some easy

00:23:53,770 --> 00:24:00,910
examples how to start playing with it

00:23:56,679 --> 00:24:02,800
and get help if you want to see some

00:24:00,910 --> 00:24:08,860
more interesting projects that are

00:24:02,800 --> 00:24:11,320
related so and that's all I've got now

00:24:08,860 --> 00:24:15,070
let's go to your questions and I will

00:24:11,320 --> 00:24:20,100
try to answer them and we will see if I

00:24:15,070 --> 00:24:20,100
will manage so who has a question first

00:24:24,639 --> 00:24:32,149
so is the 0 mq based on some standard

00:24:29,809 --> 00:24:38,809
message queuing protocol or is this

00:24:32,149 --> 00:24:41,539
highly implementation-specific it has

00:24:38,809 --> 00:24:44,750
its own protocol and basically you can

00:24:41,539 --> 00:24:48,710
generate your own the format is pretty

00:24:44,750 --> 00:24:53,600
simple you just stream of bytes and if

00:24:48,710 --> 00:24:56,509
you generate using zero-tau you can read

00:24:53,600 --> 00:24:59,929
the resulting world and it's really

00:24:56,509 --> 00:25:03,230
simple what's going on the wire one of

00:24:59,929 --> 00:25:06,049
the things that they proclaim as their

00:25:03,230 --> 00:25:09,710
advantage is that you can write a parser

00:25:06,049 --> 00:25:12,879
of zeromq messages quite easily so they

00:25:09,710 --> 00:25:17,259
are not complicated they are simple but

00:25:12,879 --> 00:25:17,259
not anything standard

00:25:26,490 --> 00:25:34,170
what protocols does it use yeah you can

00:25:31,440 --> 00:25:38,010
you can specify whether you want to use

00:25:34,170 --> 00:25:43,250
TCP UDP IPC IPC is not available on

00:25:38,010 --> 00:25:50,580
Windows it's also multi multi or wasting

00:25:43,250 --> 00:25:55,800
so yeah tcp UDP IPC and might be some

00:25:50,580 --> 00:26:01,760
others but this these are those that I

00:25:55,800 --> 00:26:01,760
practice okay

00:26:08,280 --> 00:26:14,830
so quick question about Python

00:26:12,100 --> 00:26:18,880
implementation i'm not using python

00:26:14,830 --> 00:26:23,250
myself but i have a friend who is really

00:26:18,880 --> 00:26:27,040
interested in patent and he wrote some

00:26:23,250 --> 00:26:30,790
code in Python to help him test what we

00:26:27,040 --> 00:26:37,380
built in Sea so he said that it was

00:26:30,790 --> 00:26:40,750
quite nice I think that API would be

00:26:37,380 --> 00:26:43,420
kind of similar to the sea one sees it

00:26:40,750 --> 00:26:45,510
mq-1 but there will be probably some

00:26:43,420 --> 00:26:48,130
differences based on the language I

00:26:45,510 --> 00:26:50,620
haven't seen it by myself but I know

00:26:48,130 --> 00:26:54,790
that it's quite simple and usable as

00:26:50,620 --> 00:26:58,560
well because we are this plant of mine

00:26:54,790 --> 00:26:58,560
really liked it so

00:27:06,820 --> 00:27:13,539
well if you are using the button you are

00:27:10,539 --> 00:27:15,460
using probably python bindings and those

00:27:13,539 --> 00:27:20,259
python bindings probably depends on

00:27:15,460 --> 00:27:23,700
zeromq c library but one of the one of

00:27:20,259 --> 00:27:28,990
the reasons that from what i understood

00:27:23,700 --> 00:27:30,850
using C as a language has big advantage

00:27:28,990 --> 00:27:33,519
that it's easy to write bindings in

00:27:30,850 --> 00:27:38,259
every other language for it so that's

00:27:33,519 --> 00:27:41,740
what they did but you don't have to

00:27:38,259 --> 00:27:43,929
touch c by yourself you can just install

00:27:41,740 --> 00:27:46,919
the python bindings and used to use them

00:27:43,929 --> 00:27:50,350
and by using python bindings you are

00:27:46,919 --> 00:27:52,269
still compliant well the messages that

00:27:50,350 --> 00:27:56,679
you will send will be still received

00:27:52,269 --> 00:28:01,110
well by other implementation of Caesar

00:27:56,679 --> 00:28:04,480
demq or that zeromq rewire on the a

00:28:01,110 --> 00:28:08,039
quest that happened in Brussels and

00:28:04,480 --> 00:28:14,889
there are plenty of guys riding in C C++

00:28:08,039 --> 00:28:17,139
scour bitin go and we all were able to

00:28:14,889 --> 00:28:22,649
communicate with each other without any

00:28:17,139 --> 00:28:22,649
problems yeah

00:28:25,309 --> 00:28:30,139
so some other question yep

00:28:31,620 --> 00:28:37,210
competing you know implementations you

00:28:35,380 --> 00:28:40,000
mentioned mq in the beginning for

00:28:37,210 --> 00:28:42,580
instance what about a cutie are there

00:28:40,000 --> 00:28:46,710
any particular advantages that zeromq

00:28:42,580 --> 00:28:46,710
has opened or you know

00:28:50,740 --> 00:28:59,240
so a question was regarding how to

00:28:56,180 --> 00:29:06,740
describe it in in regards with

00:28:59,240 --> 00:29:11,780
competition so yeah we I tried to look

00:29:06,740 --> 00:29:14,900
at mqp or mq and I found it quite

00:29:11,780 --> 00:29:19,870
difficult actually the guy that wrote

00:29:14,900 --> 00:29:23,870
this does mq most part of the mq

00:29:19,870 --> 00:29:26,000
standardization committee and he know

00:29:23,870 --> 00:29:32,270
what they did wrong so he tried to fix

00:29:26,000 --> 00:29:38,230
it by writing this the other MQTT that's

00:29:32,270 --> 00:29:42,950
the iot thing yeah that's quite new and

00:29:38,230 --> 00:29:47,630
I've seen some some high level overview

00:29:42,950 --> 00:29:51,320
but i have no no more knowledge about it

00:29:47,630 --> 00:29:58,090
i just know that its new iot thing he

00:29:51,320 --> 00:29:58,090
and we can do a bridge to our zeromq so

00:30:00,010 --> 00:30:08,900
rabbitmq I think it's similar s mq right

00:30:06,260 --> 00:30:13,060
is the same place it's the same protocol

00:30:08,900 --> 00:30:13,060
but the different implementation right

00:30:28,309 --> 00:30:35,730
yeah so the answer was for the video

00:30:31,740 --> 00:30:40,770
recording it's airline written we don't

00:30:35,730 --> 00:30:45,330
know much about it and it's eat mqp as

00:30:40,770 --> 00:30:47,010
well so yeah it's mqp as well and in

00:30:45,330 --> 00:30:50,010
airline it should be much easier than

00:30:47,010 --> 00:30:53,340
you have a bindings that I tried but

00:30:50,010 --> 00:30:56,360
probably is as it is mqp you still need

00:30:53,340 --> 00:31:03,299
the broker and it's quite complicated in

00:30:56,360 --> 00:31:07,140
inside and yeah same comment as the

00:31:03,299 --> 00:31:09,179
previous one applies this guy was the

00:31:07,140 --> 00:31:14,210
guy that wrote this was the guy that was

00:31:09,179 --> 00:31:17,100
working on a general m ub standard and

00:31:14,210 --> 00:31:18,900
he found out what what was wrong and he

00:31:17,100 --> 00:31:21,600
found out that it's impossible to change

00:31:18,900 --> 00:31:23,820
it in the standard anymore so he decided

00:31:21,600 --> 00:31:28,290
to drop it and write something from the

00:31:23,820 --> 00:31:30,540
scratch and yeah whole philosophy of

00:31:28,290 --> 00:31:35,100
this is keeping things as simple as

00:31:30,540 --> 00:31:38,070
possible to avoid now complexity because

00:31:35,100 --> 00:31:40,679
with complexity comes box and with box

00:31:38,070 --> 00:31:44,549
comes instability and it's getting

00:31:40,679 --> 00:31:49,380
harder and harder and with complexity

00:31:44,549 --> 00:31:52,830
comes also overhead so they said that

00:31:49,380 --> 00:31:55,650
they are much more faster than those

00:31:52,830 --> 00:31:57,830
solutions but haven't tested it by

00:31:55,650 --> 00:31:57,830
myself

00:32:08,600 --> 00:32:13,289
regarding okay question was whether

00:32:11,490 --> 00:32:18,450
there is some effort to create a new

00:32:13,289 --> 00:32:21,900
standard I don't know about effort to

00:32:18,450 --> 00:32:25,830
create the universal recognized standard

00:32:21,900 --> 00:32:30,090
but zeromq is developed around the

00:32:25,830 --> 00:32:32,910
github and around rfcs so they have our

00:32:30,090 --> 00:32:36,720
seats describing the protocol they have

00:32:32,910 --> 00:32:39,090
rfcs describing how the development

00:32:36,720 --> 00:32:41,360
model works so they have plenty of

00:32:39,090 --> 00:32:43,980
documentation which you can use to

00:32:41,360 --> 00:32:46,559
basically the implement it from scratch

00:32:43,980 --> 00:32:50,370
if you want or to inspect the protocol

00:32:46,559 --> 00:32:54,919
or do whatever you want so they have

00:32:50,370 --> 00:32:54,919
their own documentation in form of FCS

00:32:55,880 --> 00:33:03,059
okay

00:32:58,759 --> 00:33:08,580
does it support encryption yes there is

00:33:03,059 --> 00:33:11,700
this curve elliptic thingy that I don't

00:33:08,580 --> 00:33:17,220
understand at all but it is supposed to

00:33:11,700 --> 00:33:21,590
be quite secure it's it's using lip

00:33:17,220 --> 00:33:21,590
sodium library for for this

00:33:34,110 --> 00:33:41,429
and I haven't used it so I cannot answer

00:33:37,530 --> 00:33:44,340
answer the details of which parts of the

00:33:41,429 --> 00:33:47,520
messages are encrypted but I know that

00:33:44,340 --> 00:33:51,929
it is supported there and it should be

00:33:47,520 --> 00:33:54,299
easy to use I just haven't haven't had

00:33:51,929 --> 00:33:56,580
to need to do it yet because we are

00:33:54,299 --> 00:34:01,380
currently in development phase of our

00:33:56,580 --> 00:34:03,900
project and we are not doing final

00:34:01,380 --> 00:34:08,399
deployment yet so we don't need

00:34:03,900 --> 00:34:12,210
encryption yet but should be pretty easy

00:34:08,399 --> 00:34:15,750
I used our lip sodium to do some other

00:34:12,210 --> 00:34:21,889
education and their API sign seems

00:34:15,750 --> 00:34:27,510
really simple and use first ball okay

00:34:21,889 --> 00:34:29,899
anything else no then thank you for

00:34:27,510 --> 00:34:29,899

YouTube URL: https://www.youtube.com/watch?v=H1rNtRqq1qY


