Title: OSC15 - Oliver Neukum - How to implement power management in a kernel driver
Publication date: 2015-05-04
Playlist: openSUSE Conference 2015
Description: 
	We like to be able to run our devices for as long as possible on battery and to pay less for electricity.
For this to work device drivers need to manage the power their devices use. The kernel provides a generic model for devices and their interactions.
Drivers need to implement a small number of callbacks to enable proper support for power management. There are a number of issues which should be understood in these circumstances and are described in this talk.

If a driver is supposed to support runtime power management, idle states must be detected and reported to the driver model. Several models to do so exist and are demonstrated in this talk. A few pitfalls do exist and are discussed.

Finally a glance at the future of power management is included.
Captions: 
	00:00:04,490 --> 00:00:10,139
our batteries run out always sooner than

00:00:08,280 --> 00:00:13,230
we would like them to and we need to

00:00:10,139 --> 00:00:15,420
power pay our electricity bill now I

00:00:13,230 --> 00:00:17,279
have to talk about the basic

00:00:15,420 --> 00:00:20,550
misconception in case somebody's here

00:00:17,279 --> 00:00:23,490
for something else physically speaking

00:00:20,550 --> 00:00:26,519
power is the derivation of energy by

00:00:23,490 --> 00:00:28,220
time that's not what we are talking here

00:00:26,519 --> 00:00:31,349
about it we're talking about energy

00:00:28,220 --> 00:00:34,739
consumption as such there is a subsystem

00:00:31,349 --> 00:00:38,430
which controls power consumption it's

00:00:34,739 --> 00:00:42,000
called the RA PL it's new it's cool but

00:00:38,430 --> 00:00:44,789
not subject of this talk um power

00:00:42,000 --> 00:00:48,110
management in general involves the

00:00:44,789 --> 00:00:52,590
trade-off between a latency and power

00:00:48,110 --> 00:00:56,010
this is because we define the assist

00:00:52,590 --> 00:01:00,390
device to be in a power safe state when

00:00:56,010 --> 00:01:03,320
it is not capable or reduced capable

00:01:00,390 --> 00:01:06,299
only in a limited manner of doing I oh

00:01:03,320 --> 00:01:09,270
so it needs to be broken before it can

00:01:06,299 --> 00:01:12,540
operate and that takes time which we

00:01:09,270 --> 00:01:16,470
sacrifice for power saving there is also

00:01:12,540 --> 00:01:19,340
an API for specifying how much latency

00:01:16,470 --> 00:01:22,110
we are willing to sacrifice for power

00:01:19,340 --> 00:01:26,460
it's called the quality of service or

00:01:22,110 --> 00:01:29,490
qos API this is very much an advanced

00:01:26,460 --> 00:01:32,299
topic and really useful only in the most

00:01:29,490 --> 00:01:35,729
modern of systems or in specific systems

00:01:32,299 --> 00:01:38,490
because using it requires knowledge we

00:01:35,729 --> 00:01:43,140
usually don't have it's really unclear

00:01:38,490 --> 00:01:46,259
how long it will take to to resume a

00:01:43,140 --> 00:01:48,659
device you could add up the worst-case

00:01:46,259 --> 00:01:51,360
Layton sees but then you end up at

00:01:48,659 --> 00:01:56,460
fantasy x in the minutes or so so this

00:01:51,360 --> 00:01:59,490
is not useful what do I talk about or

00:01:56,460 --> 00:02:01,950
maybe I leave out something is the kinds

00:01:59,490 --> 00:02:04,229
of power minute we have the principles

00:02:01,950 --> 00:02:06,540
behind it the detection of idleness the

00:02:04,229 --> 00:02:09,270
AP is and the new stuff that is

00:02:06,540 --> 00:02:12,060
happening ok

00:02:09,270 --> 00:02:15,930
which devices do a cover I don't cover

00:02:12,060 --> 00:02:18,210
CPUs I don't cover networks and I don't

00:02:15,930 --> 00:02:22,440
cover a link power management like we

00:02:18,210 --> 00:02:26,490
have in SATA or USB the reason for this

00:02:22,440 --> 00:02:28,980
is that I am talking about devices which

00:02:26,490 --> 00:02:32,340
need software aid to do power management

00:02:28,980 --> 00:02:35,100
in the link power management this is

00:02:32,340 --> 00:02:39,300
usually not the case you switch it on

00:02:35,100 --> 00:02:41,700
like energy-efficient ethernet and the

00:02:39,300 --> 00:02:45,450
hardware will do what needs to be done

00:02:41,700 --> 00:02:48,390
by itself it needs no further software

00:02:45,450 --> 00:02:50,280
support that makes it easy to do but not

00:02:48,390 --> 00:02:54,300
interesting for the driver case so we

00:02:50,280 --> 00:02:56,850
disregard this here finally I am talking

00:02:54,300 --> 00:02:59,520
about only about the colonel stuff and I

00:02:56,850 --> 00:03:01,080
will come to the reason there needs to

00:02:59,520 --> 00:03:03,660
be some kernel involvement in power

00:03:01,080 --> 00:03:07,470
management but for now users based

00:03:03,660 --> 00:03:11,490
people can go elsewhere and you probably

00:03:07,470 --> 00:03:13,200
know that we distinguish two kinds of

00:03:11,490 --> 00:03:16,560
power management either the whole system

00:03:13,200 --> 00:03:19,830
sleeps or not in this case we are doing

00:03:16,560 --> 00:03:22,380
a runtime power management where we let

00:03:19,830 --> 00:03:27,900
go sleep as many as components as

00:03:22,380 --> 00:03:34,790
possible so the principle is always the

00:03:27,900 --> 00:03:38,220
same we trade capability for power use

00:03:34,790 --> 00:03:41,940
the colonel implements a generic model

00:03:38,220 --> 00:03:44,730
of suspension which only rather has two

00:03:41,940 --> 00:03:48,240
states either a device is suspended or

00:03:44,730 --> 00:03:52,560
not that is not what much hardware

00:03:48,240 --> 00:03:55,320
especially PCI does implement it knows

00:03:52,560 --> 00:03:58,050
several grades of suspension with a

00:03:55,320 --> 00:04:01,470
larger Layton sees and more and more

00:03:58,050 --> 00:04:04,680
reduced capabilities and loss of state

00:04:01,470 --> 00:04:07,320
for example the deepest PCI sleep state

00:04:04,680 --> 00:04:12,630
really cuts power which means a total

00:04:07,320 --> 00:04:14,450
loss of any state obviously as I told

00:04:12,630 --> 00:04:17,340
you

00:04:14,450 --> 00:04:19,950
the colonel detects when devices aren't

00:04:17,340 --> 00:04:23,100
needed this is done in an interaction

00:04:19,950 --> 00:04:26,130
between the generic device model and the

00:04:23,100 --> 00:04:29,880
drivers we do have an API for that and

00:04:26,130 --> 00:04:33,090
I'm going to cover that furthermore you

00:04:29,880 --> 00:04:38,880
might ask yourself why don't we do this

00:04:33,090 --> 00:04:41,540
power management in each driver there is

00:04:38,880 --> 00:04:45,710
a fundamental reason it can't be done

00:04:41,540 --> 00:04:48,540
devices depend on each other so we

00:04:45,710 --> 00:04:51,270
implement it when we still did power

00:04:48,540 --> 00:04:53,700
management in a only percept system move

00:04:51,270 --> 00:04:57,300
away power management for USB storage

00:04:53,700 --> 00:05:00,000
devices and for our little storage

00:04:57,300 --> 00:05:02,580
dongles that worked flawlessly it was a

00:05:00,000 --> 00:05:05,870
joy and then we tried it with the disk

00:05:02,580 --> 00:05:09,000
enclosure and bang it ate file systems

00:05:05,870 --> 00:05:12,090
the reason was rather simple we did it

00:05:09,000 --> 00:05:16,320
only on the USB level and that was just

00:05:12,090 --> 00:05:19,380
wrong you need to cover the whole chain

00:05:16,320 --> 00:05:21,540
from the PCI mud on the motherboard down

00:05:19,380 --> 00:05:24,450
to the USB level down to the drive

00:05:21,540 --> 00:05:27,450
enclosure which is a scuzzy device and

00:05:24,450 --> 00:05:29,970
you just cannot send a scuzzy devices

00:05:27,450 --> 00:05:33,120
into sleep state without preparation you

00:05:29,970 --> 00:05:37,080
need to flush the cache and we did not

00:05:33,120 --> 00:05:39,840
model that dependency and therefore it

00:05:37,080 --> 00:05:42,510
did not work so we now come to a

00:05:39,840 --> 00:05:44,880
dependency among the devices and the

00:05:42,510 --> 00:05:52,200
other reason is obvious we want to do to

00:05:44,880 --> 00:05:54,600
share a common code our devices in the

00:05:52,200 --> 00:05:56,970
kernel are in a tree well conceptually

00:05:54,600 --> 00:06:01,380
they are physically it's a linked list

00:05:56,970 --> 00:06:04,850
but anyway a list traversed from the

00:06:01,380 --> 00:06:07,710
beginning is traversed in the same

00:06:04,850 --> 00:06:11,610
direction as a tree from the truck would

00:06:07,710 --> 00:06:13,480
be traversed and the same is true for

00:06:11,610 --> 00:06:17,900
the inverse scanning

00:06:13,480 --> 00:06:21,560
the tree is built by a device edition

00:06:17,900 --> 00:06:24,260
that is at boot time or use your hot

00:06:21,560 --> 00:06:29,120
edition and hot removal but that does

00:06:24,260 --> 00:06:32,750
not interesting it and we suppose here

00:06:29,120 --> 00:06:36,560
that there is a top-down dependency from

00:06:32,750 --> 00:06:38,990
parent to child that means that no

00:06:36,560 --> 00:06:43,460
parent can be suspended while its

00:06:38,990 --> 00:06:45,880
children are awake that is no longer

00:06:43,460 --> 00:06:50,270
really true sense of you colonel

00:06:45,880 --> 00:06:53,930
releases we have the option to say for a

00:06:50,270 --> 00:06:56,140
spife is a specific device yes it can

00:06:53,930 --> 00:06:59,240
sleep although its children are awake

00:06:56,140 --> 00:07:03,350
but that is a specialized capability

00:06:59,240 --> 00:07:08,240
usually used only in embedded systems it

00:07:03,350 --> 00:07:13,400
has to further implication that letting

00:07:08,240 --> 00:07:18,350
go to sleep all a parents children has a

00:07:13,400 --> 00:07:21,410
further has a larger benefit then the

00:07:18,350 --> 00:07:24,020
added benefit because it now allows the

00:07:21,410 --> 00:07:26,360
parent to go to sleep so there is a

00:07:24,020 --> 00:07:33,710
positive synergy but you get it only

00:07:26,360 --> 00:07:35,990
with total success and our building this

00:07:33,710 --> 00:07:39,730
three on hot plug is not poorly

00:07:35,990 --> 00:07:44,630
arbitrary because there is a natural

00:07:39,730 --> 00:07:48,770
race condition between hot plugging and

00:07:44,630 --> 00:07:52,070
power management as soon as you add a

00:07:48,770 --> 00:07:55,550
child you would need to consider that

00:07:52,070 --> 00:07:58,330
child if you want to compute whether the

00:07:55,550 --> 00:08:01,250
all the parents children are asleep

00:07:58,330 --> 00:08:03,230
naturally that cannot work and we do

00:08:01,250 --> 00:08:06,830
have an API to handle this I will cover

00:08:03,230 --> 00:08:11,750
this later so there is a complication

00:08:06,830 --> 00:08:15,830
here the hardware dependencies like the

00:08:11,750 --> 00:08:17,449
shared power lines or clocks may not be

00:08:15,830 --> 00:08:20,210
the same as

00:08:17,449 --> 00:08:23,199
the detection dependency from the hot

00:08:20,210 --> 00:08:27,229
plugging that is very much the case in

00:08:23,199 --> 00:08:29,300
some embedded systems the kernel can

00:08:27,229 --> 00:08:34,669
handle this you need to define your own

00:08:29,300 --> 00:08:36,800
power domains for this but that is very

00:08:34,669 --> 00:08:39,829
much an advanced topic and if you really

00:08:36,800 --> 00:08:44,540
want to do this talk to the embedded

00:08:39,829 --> 00:08:49,040
systems folks what does a suspension

00:08:44,540 --> 00:08:52,279
mean as we are talking about a generic

00:08:49,040 --> 00:08:57,260
system the answer is a rather

00:08:52,279 --> 00:09:02,839
non-intuitive we don't care for us there

00:08:57,260 --> 00:09:04,490
is only a logical model that means

00:09:02,839 --> 00:09:08,690
either a device is fully operational

00:09:04,490 --> 00:09:12,550
than it is active or it is not fully

00:09:08,690 --> 00:09:16,399
operational then we counted as suspended

00:09:12,550 --> 00:09:21,680
so we manage devices which need to be

00:09:16,399 --> 00:09:24,500
managed okay you may say that we are

00:09:21,680 --> 00:09:28,370
here in a logical circle this is

00:09:24,500 --> 00:09:31,100
partially true but there are rational

00:09:28,370 --> 00:09:34,760
criteria for deciding when a desire wise

00:09:31,100 --> 00:09:39,290
needs to be managed the first one is the

00:09:34,760 --> 00:09:41,449
dependency I talked about here it turned

00:09:39,290 --> 00:09:46,430
out that we do not need to do anything

00:09:41,449 --> 00:09:49,100
more than our measures we had already

00:09:46,430 --> 00:09:51,649
taken for the USB storage power

00:09:49,100 --> 00:09:53,839
management we just needed to add the

00:09:51,649 --> 00:09:58,130
dependencies so that the skazhi power

00:09:53,839 --> 00:10:01,160
management can do its thing on the drive

00:09:58,130 --> 00:10:04,959
enclosed in the drive enclosure in these

00:10:01,160 --> 00:10:09,290
cases we have two rather unusual case of

00:10:04,959 --> 00:10:14,269
just linking two subsystems doing our

00:10:09,290 --> 00:10:17,779
job that is more and more the case as we

00:10:14,269 --> 00:10:20,029
have found out because obviously you

00:10:17,779 --> 00:10:23,540
cannot kill power to a pci device

00:10:20,029 --> 00:10:29,439
without really preparing all its

00:10:23,540 --> 00:10:29,439
children the other job

00:10:29,590 --> 00:10:36,890
we need power management in the core for

00:10:33,200 --> 00:10:40,940
our loss of capabilities if power

00:10:36,890 --> 00:10:43,640
management at some state in interferes

00:10:40,940 --> 00:10:47,720
with the duties of another device yes

00:10:43,640 --> 00:10:50,450
that needs to be modeled and the third

00:10:47,720 --> 00:10:54,680
reason we do need power management is

00:10:50,450 --> 00:10:58,070
that we consider the case where a device

00:10:54,680 --> 00:11:01,820
needs the 8th of software to dual power

00:10:58,070 --> 00:11:03,680
transition either in the case that you

00:11:01,820 --> 00:11:07,490
really physically need to do the

00:11:03,680 --> 00:11:10,580
transition triggered by software or that

00:11:07,490 --> 00:11:13,220
you need to prepare or recover your

00:11:10,580 --> 00:11:17,750
devices from the transition in power

00:11:13,220 --> 00:11:20,240
saving this was considered to be doable

00:11:17,750 --> 00:11:23,690
by saving the state and then restoring

00:11:20,240 --> 00:11:26,570
it it has turned out in practice that

00:11:23,690 --> 00:11:29,870
this is not so easy I will come to this

00:11:26,570 --> 00:11:36,590
rather a bit later when I'd talk about

00:11:29,870 --> 00:11:41,900
the API we have power management works

00:11:36,590 --> 00:11:46,700
by detecting by going into power safe

00:11:41,900 --> 00:11:51,830
when your device is idle if the

00:11:46,700 --> 00:11:56,140
transition effects the whole system who

00:11:51,830 --> 00:12:02,140
cares but for runtime power management

00:11:56,140 --> 00:12:08,240
we need to actually detect idleness and

00:12:02,140 --> 00:12:12,380
we do this rather from the behind we do

00:12:08,240 --> 00:12:16,210
not defined idleness or something but we

00:12:12,380 --> 00:12:22,180
look at what is required from the system

00:12:16,210 --> 00:12:26,420
if it doesn't need to do anything it

00:12:22,180 --> 00:12:30,170
cannot do in a suspended state then the

00:12:26,420 --> 00:12:34,790
device is idle this is probably

00:12:30,170 --> 00:12:37,529
counterintuitive but it leads to the

00:12:34,790 --> 00:12:43,230
best results

00:12:37,529 --> 00:12:46,019
hmm and the case we go for is it is idle

00:12:43,230 --> 00:12:50,449
but active then we are wasting energy

00:12:46,019 --> 00:12:50,449
and if we stop doing so we save energy

00:12:50,509 --> 00:13:02,759
that means that a things like the the

00:12:55,649 --> 00:13:06,089
hard drive power redundancy compromise

00:13:02,759 --> 00:13:09,259
you can you switch on with the HD power

00:13:06,089 --> 00:13:12,209
tool is not power management for us

00:13:09,259 --> 00:13:15,930
because they're the drive is fully

00:13:12,209 --> 00:13:18,509
operational only slower and software

00:13:15,930 --> 00:13:21,899
doesn't need to do anything but set that

00:13:18,509 --> 00:13:24,629
so this is not covered neither are

00:13:21,899 --> 00:13:27,839
abused for now because the problem is

00:13:24,629 --> 00:13:37,069
rather intricate and not solved in a

00:13:27,839 --> 00:13:40,529
generic manner so when are we idle this

00:13:37,069 --> 00:13:49,680
is a question which is hard to answer

00:13:40,529 --> 00:13:54,089
and as we are lazy people we like to do

00:13:49,680 --> 00:13:58,439
use an approximation and let somebody

00:13:54,089 --> 00:14:01,019
else solve the problem for us you could

00:13:58,439 --> 00:14:04,139
now go to the naive approach and say

00:14:01,019 --> 00:14:08,100
when we output something or wait for an

00:14:04,139 --> 00:14:10,980
input then the system is not idle your

00:14:08,100 --> 00:14:13,309
problem with this approach is well you

00:14:10,980 --> 00:14:18,360
know when you start outputting something

00:14:13,309 --> 00:14:21,809
but when is the queue drained in most

00:14:18,360 --> 00:14:27,209
cases you're not really able to tell

00:14:21,809 --> 00:14:30,360
that or at an efficient cost so what you

00:14:27,209 --> 00:14:33,600
can do is you take your clues from user

00:14:30,360 --> 00:14:37,949
space which leads us to the conservative

00:14:33,600 --> 00:14:41,429
approach we assume user space know what

00:14:37,949 --> 00:14:45,360
it knows what it's doing ok this may be

00:14:41,429 --> 00:14:48,149
yes but let's assume it and our common

00:14:45,360 --> 00:14:51,209
assumption is if user space opens the

00:14:48,149 --> 00:14:53,550
device note it does so for a reason

00:14:51,209 --> 00:14:56,670
and the reason probably is that the

00:14:53,550 --> 00:14:59,790
device is going to be needed so we say

00:14:56,670 --> 00:15:04,679
an open device is not idle and a closed

00:14:59,790 --> 00:15:07,079
device is idle that may be naive but

00:15:04,679 --> 00:15:10,889
consider most devices like for example

00:15:07,079 --> 00:15:14,179
your webcam if it's not opened it is

00:15:10,889 --> 00:15:20,009
idle the like would be for a joystick or

00:15:14,179 --> 00:15:24,149
a printer works there is a category of

00:15:20,009 --> 00:15:27,179
devices for which this does not work the

00:15:24,149 --> 00:15:30,209
most obviously would be a keyboard there

00:15:27,179 --> 00:15:34,199
is no user space the primary consumer of

00:15:30,209 --> 00:15:37,470
keyboard input is indeed the colonel you

00:15:34,199 --> 00:15:40,339
cannot close a keyboard if you can close

00:15:37,470 --> 00:15:43,769
a mouse if we are in on input devices

00:15:40,339 --> 00:15:48,269
but that's not really interesting not if

00:15:43,769 --> 00:15:54,439
you run X because you need to be able to

00:15:48,269 --> 00:15:59,819
see a mouse movement any time it happens

00:15:54,439 --> 00:16:04,679
so for these cases we do have a dynamic

00:15:59,819 --> 00:16:09,720
approach which has one main problem

00:16:04,679 --> 00:16:11,490
input output is something you know when

00:16:09,720 --> 00:16:13,499
it's going to happen because there is a

00:16:11,490 --> 00:16:17,730
write Siskel or its equivalent in

00:16:13,499 --> 00:16:23,189
networking input does not have this this

00:16:17,730 --> 00:16:26,480
property you just wait for it so you

00:16:23,189 --> 00:16:29,759
need a little bit of hardware support

00:16:26,480 --> 00:16:31,589
unless your user space is nice enough to

00:16:29,759 --> 00:16:35,160
tell you that it really doesn't care

00:16:31,589 --> 00:16:39,449
about input even though the device could

00:16:35,160 --> 00:16:44,399
do it but that's not really a common

00:16:39,449 --> 00:16:49,709
thing so most devices have the ability

00:16:44,399 --> 00:16:52,410
to tell you that i always need it when

00:16:49,709 --> 00:16:56,119
they are suspended they're just not

00:16:52,410 --> 00:16:58,290
capable of performing the actual i/o

00:16:56,119 --> 00:17:01,230
underused be this feature is called

00:16:58,290 --> 00:17:04,319
remote wake up you tell the device

00:17:01,230 --> 00:17:05,070
before you go to sleep yes please notify

00:17:04,319 --> 00:17:07,710
me of

00:17:05,070 --> 00:17:13,470
any requests to do I oh and the device

00:17:07,710 --> 00:17:18,180
will do so what you need to look at in

00:17:13,470 --> 00:17:21,120
these cases is that this capability is

00:17:18,180 --> 00:17:24,540
not universal to all sleep states a

00:17:21,120 --> 00:17:26,850
device has in use veal and there's the

00:17:24,540 --> 00:17:30,180
obvious case of us cutting power which

00:17:26,850 --> 00:17:32,880
we now can do obviously a power of

00:17:30,180 --> 00:17:35,970
device cannot do signaling unless it's

00:17:32,880 --> 00:17:40,200
over the go but okay doesn't matter the

00:17:35,970 --> 00:17:44,100
same is true for PCI so if a remote wake

00:17:40,200 --> 00:17:47,040
up is specified your sub system needs to

00:17:44,100 --> 00:17:50,340
pick the specific sleep state that is

00:17:47,040 --> 00:17:52,140
compatible with this this job can only

00:17:50,340 --> 00:17:59,010
be done at the subsystem level because

00:17:52,140 --> 00:18:01,950
how would a generic system know your job

00:17:59,010 --> 00:18:05,490
if you are doing a power management in a

00:18:01,950 --> 00:18:08,700
driver is to pick the model here that

00:18:05,490 --> 00:18:14,250
makes sense based on a specific use case

00:18:08,700 --> 00:18:18,240
for a joystick open and close does the

00:18:14,250 --> 00:18:20,940
job well very few people open their

00:18:18,240 --> 00:18:24,570
games and let them let them idle then

00:18:20,940 --> 00:18:28,260
that doesn't happen for things like a

00:18:24,570 --> 00:18:30,270
motion sensor or a keyboard this is very

00:18:28,260 --> 00:18:32,040
much not the case there you need to go

00:18:30,270 --> 00:18:34,860
to the dynamic approach because user

00:18:32,040 --> 00:18:42,150
space or even the colonel will use them

00:18:34,860 --> 00:18:48,300
continuously if you are using the

00:18:42,150 --> 00:18:51,120
conventional model you go for there is

00:18:48,300 --> 00:18:53,280
the possibility of i/o and I assuming it

00:18:51,120 --> 00:18:55,920
they're going to happen in the dynamic

00:18:53,280 --> 00:18:59,310
approach you don't care about

00:18:55,920 --> 00:19:03,230
possibilities you do care about actual

00:18:59,310 --> 00:19:07,490
io for the output case you detect that

00:19:03,230 --> 00:19:11,480
notify the common core

00:19:07,490 --> 00:19:14,750
and also need to know when your IO has

00:19:11,480 --> 00:19:19,340
finished and that is a rather hard case

00:19:14,750 --> 00:19:22,700
I will come to that and you should be

00:19:19,340 --> 00:19:26,030
ready to combine those approaches

00:19:22,700 --> 00:19:28,670
because you can in many cases go to a

00:19:26,030 --> 00:19:33,110
deeper sleep state if the conventional

00:19:28,670 --> 00:19:36,920
approach does turn out to be usable so

00:19:33,110 --> 00:19:39,110
if unexpectedly your mouse is actually

00:19:36,920 --> 00:19:45,200
closed then you can go to a deeper sleep

00:19:39,110 --> 00:19:51,559
state in some systems so how does the

00:19:45,200 --> 00:19:56,240
API work in the driver core there is a

00:19:51,559 --> 00:20:00,200
basic algorithm we do want our devices

00:19:56,240 --> 00:20:05,660
to go to a sleep state as long as

00:20:00,200 --> 00:20:07,760
possible but not too often because there

00:20:05,660 --> 00:20:10,730
is a cost associated with the power

00:20:07,760 --> 00:20:13,340
state transition which is larger than

00:20:10,730 --> 00:20:16,370
just letting it run although it wouldn't

00:20:13,340 --> 00:20:22,220
need to be running so we do use

00:20:16,370 --> 00:20:25,910
heuristics we assume that if a device

00:20:22,220 --> 00:20:30,440
hasn't been used for a certain time it

00:20:25,910 --> 00:20:32,660
won't be and on a contrary we assume

00:20:30,440 --> 00:20:35,420
that if it has been used in the recent

00:20:32,660 --> 00:20:39,530
past there's a great likelihood that it

00:20:35,420 --> 00:20:43,370
will be used again and we model this by

00:20:39,530 --> 00:20:45,320
using a timer which is set to two

00:20:43,370 --> 00:20:48,410
thousand milliseconds by default but

00:20:45,320 --> 00:20:54,050
that's a detail that can be changed to

00:20:48,410 --> 00:20:58,570
buy Sisyphus so if the core sees that

00:20:54,050 --> 00:21:01,820
it's timer has run out and that the

00:20:58,570 --> 00:21:05,270
conservative approach of notifying it

00:21:01,820 --> 00:21:10,730
that there is a potential of i/o is not

00:21:05,270 --> 00:21:15,120
used then the core will consider your

00:21:10,730 --> 00:21:18,780
device idle and request

00:21:15,120 --> 00:21:22,920
that a subsystem or the driver puts it

00:21:18,780 --> 00:21:27,390
into power safe at this stage you can

00:21:22,920 --> 00:21:30,750
still fail and notify the power core it

00:21:27,390 --> 00:21:39,290
will not be route to you it will just

00:21:30,750 --> 00:21:39,290
reach restart the timer and ask again so

00:21:40,040 --> 00:21:49,590
the device driver can talk to the core

00:21:44,300 --> 00:21:52,770
by two simple api's the get methods and

00:21:49,590 --> 00:21:55,800
to put methods there are some specific

00:21:52,770 --> 00:21:59,160
flavors here which can be used under

00:21:55,800 --> 00:22:01,770
specific circumstances it really doesn't

00:21:59,160 --> 00:22:05,340
matter this is subject to a little bit

00:22:01,770 --> 00:22:08,309
of change and I want you to get the

00:22:05,340 --> 00:22:11,309
reasoning behind this stuff not provide

00:22:08,309 --> 00:22:13,380
a cookbook here so if you use the

00:22:11,309 --> 00:22:15,630
conventional approach every time you

00:22:13,380 --> 00:22:18,440
notice a reason that your device

00:22:15,630 --> 00:22:21,420
shouldn't be put to sleep you call get

00:22:18,440 --> 00:22:26,400
and when that reason goes away you call

00:22:21,420 --> 00:22:28,140
put the only thing that you need to make

00:22:26,400 --> 00:22:31,140
sure of is that you don't mess up your

00:22:28,140 --> 00:22:33,090
counter say that would lead to a device

00:22:31,140 --> 00:22:36,210
that can never go to sleep again which

00:22:33,090 --> 00:22:41,550
is kind of sucks from power mentioning

00:22:36,210 --> 00:22:46,350
perspective if you're using the dynamic

00:22:41,550 --> 00:22:49,710
approach you're telling the runtime core

00:22:46,350 --> 00:22:56,990
I've been busy now please restart the

00:22:49,710 --> 00:23:00,120
counter or adjust it it does so and if

00:22:56,990 --> 00:23:03,270
for a sufficiently long time you don't

00:23:00,120 --> 00:23:07,380
report any further I oh it will try

00:23:03,270 --> 00:23:11,220
again and then the assumption may be

00:23:07,380 --> 00:23:15,480
true you drive a notes that the i/o has

00:23:11,220 --> 00:23:17,309
been finished then it should just do

00:23:15,480 --> 00:23:19,290
whatever it needs to do to power down

00:23:17,309 --> 00:23:23,279
the device if not it returns an error

00:23:19,290 --> 00:23:28,539
and to drive a car will again

00:23:23,279 --> 00:23:34,049
even this procedure is a bit involved so

00:23:28,539 --> 00:23:37,360
many subsystems encapsulate this for you

00:23:34,049 --> 00:23:48,759
doesn't really buy you much but it's

00:23:37,360 --> 00:23:54,580
there the encapsulation is a bit more

00:23:48,759 --> 00:24:01,629
sensible than the other way here the we

00:23:54,580 --> 00:24:04,059
have the API that the driver core uses

00:24:01,629 --> 00:24:08,980
to talk device drivers for the runtime

00:24:04,059 --> 00:24:11,590
power management as I told you and there

00:24:08,980 --> 00:24:16,720
is an intrinsic race condition between

00:24:11,590 --> 00:24:20,619
hot edition and sleeping because you

00:24:16,720 --> 00:24:24,429
need to know whether all a devices

00:24:20,619 --> 00:24:28,090
children are into are in the right state

00:24:24,429 --> 00:24:31,299
and thus that does mean that when you

00:24:28,090 --> 00:24:34,029
are doing this calculation you cannot

00:24:31,299 --> 00:24:36,369
allow more children to be added to a

00:24:34,029 --> 00:24:40,419
parent because there is a race condition

00:24:36,369 --> 00:24:46,480
that cannot be handled so if the driver

00:24:40,419 --> 00:24:49,779
core things that now all children are

00:24:46,480 --> 00:24:54,460
asleep it will iterate through the

00:24:49,779 --> 00:24:57,940
children but again and do so after it

00:24:54,460 --> 00:25:02,169
has given the prepare call which

00:24:57,940 --> 00:25:05,350
notifies a device which is a potential

00:25:02,169 --> 00:25:09,070
interior note in the device 3 that it

00:25:05,350 --> 00:25:13,539
may not initiate any hot addition events

00:25:09,070 --> 00:25:17,559
now and as soon it has done so it will

00:25:13,539 --> 00:25:20,289
go through the children again and ask it

00:25:17,559 --> 00:25:26,289
does so by the mean of the PM runtime

00:25:20,289 --> 00:25:32,200
idle question this is because if a

00:25:26,289 --> 00:25:35,320
device fails that question and the other

00:25:32,200 --> 00:25:37,510
devices had already been suspended

00:25:35,320 --> 00:25:41,080
those suspensions would have been in

00:25:37,510 --> 00:25:45,490
vain so we do a two-stage approach here

00:25:41,080 --> 00:25:49,240
we first asked by the PM runtime idle

00:25:45,490 --> 00:25:55,270
question and then do the runtime suspend

00:25:49,240 --> 00:25:58,900
call which really means do it and still

00:25:55,270 --> 00:26:01,810
at that take stage you may fail and but

00:25:58,900 --> 00:26:04,090
then the driver car really has to go

00:26:01,810 --> 00:26:06,970
through the other children of the device

00:26:04,090 --> 00:26:10,210
and resume them this is costly we don't

00:26:06,970 --> 00:26:13,030
want this and at the resume time you are

00:26:10,210 --> 00:26:18,460
given the resume call back as one would

00:26:13,030 --> 00:26:21,340
expect and if at that time an error

00:26:18,460 --> 00:26:23,830
happens hot-plug should be activated

00:26:21,340 --> 00:26:26,740
again obviously and after the sleep it

00:26:23,830 --> 00:26:33,700
would be nice also to do this we have

00:26:26,740 --> 00:26:37,840
the complete call back during system

00:26:33,700 --> 00:26:43,360
sleep this is a bit different because we

00:26:37,840 --> 00:26:45,880
assume that a device should basically be

00:26:43,360 --> 00:26:49,660
always ready to go to sleep when the

00:26:45,880 --> 00:26:52,000
system sleeps because it's devised a

00:26:49,660 --> 00:26:54,400
system that cannot be suspended is

00:26:52,000 --> 00:26:57,970
really a nuisance we don't want that so

00:26:54,400 --> 00:27:00,850
you should fail there only in emergency

00:26:57,970 --> 00:27:08,080
like Frances and corruption or something

00:27:00,850 --> 00:27:11,920
out of a similar magnitude in addition

00:27:08,080 --> 00:27:15,340
the process of sending a system to sleep

00:27:11,920 --> 00:27:19,930
is a bit more complex than in the

00:27:15,340 --> 00:27:22,540
runtime case processes are frozen there

00:27:19,930 --> 00:27:25,990
are several stages of the device tree

00:27:22,540 --> 00:27:29,490
walking more activity with interrupts

00:27:25,990 --> 00:27:35,650
activated and it drops off for example

00:27:29,490 --> 00:27:37,990
the exact details a bit still subject to

00:27:35,650 --> 00:27:41,950
state changes so they don't really

00:27:37,990 --> 00:27:44,760
matter what you need to know is your

00:27:41,950 --> 00:27:50,480
suspend callback will be called

00:27:44,760 --> 00:27:50,480
and then you should suspend your device

00:27:50,780 --> 00:27:59,280
not really at any cost but at

00:27:55,020 --> 00:28:03,000
considerable cost and if the you're

00:27:59,280 --> 00:28:06,060
coming back is a corresponding resume

00:28:03,000 --> 00:28:08,700
callback will be called that is the time

00:28:06,060 --> 00:28:15,200
you should save your device state and on

00:28:08,700 --> 00:28:20,130
resume restore it there is a caveat here

00:28:15,200 --> 00:28:22,740
the order your physicians your callbacks

00:28:20,130 --> 00:28:26,750
are called is dependent on the device

00:28:22,740 --> 00:28:30,390
tree and this cannot be changed

00:28:26,750 --> 00:28:34,200
therefore you do not know in which state

00:28:30,390 --> 00:28:36,780
the other devices are as we've learned a

00:28:34,200 --> 00:28:41,990
device that is suspended cannot do I oh

00:28:36,780 --> 00:28:45,210
and that includes your disk controllers

00:28:41,990 --> 00:28:50,670
that means that during the transition to

00:28:45,210 --> 00:28:55,740
power safe your virtual memory engine is

00:28:50,670 --> 00:29:01,370
only partially functional and more

00:28:55,740 --> 00:29:05,000
important your user space is asleep that

00:29:01,370 --> 00:29:08,430
gives you some strict limitations

00:29:05,000 --> 00:29:11,040
obviously you cannot do a callback to a

00:29:08,430 --> 00:29:19,410
user space that is asleep there is

00:29:11,040 --> 00:29:25,800
nothing which has an implication mainly

00:29:19,410 --> 00:29:29,130
your firmware has to be in RAM you

00:29:25,800 --> 00:29:32,280
cannot even do the call back to request

00:29:29,130 --> 00:29:34,470
the firmware during suspend because

00:29:32,280 --> 00:29:37,500
other device notes may have been

00:29:34,470 --> 00:29:42,960
suspended before you and that again

00:29:37,500 --> 00:29:45,780
includes you this controller the

00:29:42,960 --> 00:29:49,830
commonly accepted way really to handle

00:29:45,780 --> 00:29:53,090
firmware is to to store it on probe if

00:29:49,830 --> 00:29:58,330
you need it for power management

00:29:53,090 --> 00:30:01,160
that destroys a lot of the benefits of

00:29:58,330 --> 00:30:04,400
really ripping the firmware out of the

00:30:01,160 --> 00:30:06,560
kernel which we did many years ago but

00:30:04,400 --> 00:30:08,540
so be it it can't be avoided it's a

00:30:06,560 --> 00:30:11,690
principal rock problem that is a

00:30:08,540 --> 00:30:15,200
notifier chain you could use but that

00:30:11,690 --> 00:30:17,540
again increases complex complexity you

00:30:15,200 --> 00:30:20,570
don't really want that from where isn't

00:30:17,540 --> 00:30:23,650
that large in most cases in some it is

00:30:20,570 --> 00:30:26,270
but then you can do something and

00:30:23,650 --> 00:30:30,890
obviously your virtual memory Mangin

00:30:26,270 --> 00:30:33,070
does not work there is a trick for the

00:30:30,890 --> 00:30:35,960
only task that is running in that state

00:30:33,070 --> 00:30:42,890
that converts all of your memory

00:30:35,960 --> 00:30:46,520
allocations to gfp no I oh yes that

00:30:42,890 --> 00:30:49,100
works but you still cannot launder pages

00:30:46,520 --> 00:30:53,990
so be sparing with your memory

00:30:49,100 --> 00:30:59,290
allocations there and more important you

00:30:53,990 --> 00:31:04,520
must not communicate with another task

00:30:59,290 --> 00:31:07,250
that is not under this special fix up so

00:31:04,520 --> 00:31:10,760
that means you cannot cure a work to a

00:31:07,250 --> 00:31:14,810
work queue which does memory allocations

00:31:10,760 --> 00:31:17,180
with anything else but UFP no I oh so if

00:31:14,810 --> 00:31:19,640
you really need work used during suspend

00:31:17,180 --> 00:31:24,220
and resume you probably will need to

00:31:19,640 --> 00:31:24,220
allocate them especially for that reason

00:31:26,950 --> 00:31:37,150
one further step if you are writing a

00:31:31,220 --> 00:31:41,300
new character device driver you may be

00:31:37,150 --> 00:31:44,720
at the stage where you need to design

00:31:41,300 --> 00:31:46,580
your own API if you are driving it

00:31:44,720 --> 00:31:49,070
writing a new network driver or a new

00:31:46,580 --> 00:31:51,710
skazhi driver that's not the case they

00:31:49,070 --> 00:31:56,600
have a defined API do what you need to

00:31:51,710 --> 00:32:03,370
do but if you have a choice then you

00:31:56,600 --> 00:32:03,370
should avoid a certain amount I'm OSHA

00:32:07,250 --> 00:32:18,090
okay no problem okay I'll be fast open

00:32:14,700 --> 00:32:22,320
and close are your friends they deliver

00:32:18,090 --> 00:32:25,260
your information for free use them and

00:32:22,320 --> 00:32:29,090
what you should really avoid is having

00:32:25,260 --> 00:32:32,580
an API for starting something

00:32:29,090 --> 00:32:35,850
indeterminate and not knowing when it

00:32:32,580 --> 00:32:38,070
stops force feedback is notorious for

00:32:35,850 --> 00:32:40,740
this they have an API for start this

00:32:38,070 --> 00:32:46,669
effect how long will it take nobody

00:32:40,740 --> 00:32:50,280
knows sucks and then I told you your

00:32:46,669 --> 00:32:53,669
responsibility is to save and restore

00:32:50,280 --> 00:32:56,669
the device state that in practice is not

00:32:53,669 --> 00:32:58,620
possible most devices just do not spit

00:32:56,669 --> 00:33:01,530
out their device state in a usable way

00:32:58,620 --> 00:33:07,020
you will have to track any change to the

00:33:01,530 --> 00:33:08,760
device and repeat it upon resume problem

00:33:07,020 --> 00:33:11,520
here is you need to know what your

00:33:08,760 --> 00:33:15,120
actions mean if you have an API that

00:33:11,520 --> 00:33:19,140
says more or less sent this arbitrary

00:33:15,120 --> 00:33:22,770
string of bytes to the firmware well do

00:33:19,140 --> 00:33:25,230
I need to repeat this or not if it was

00:33:22,770 --> 00:33:27,900
the action for doing a beep then all

00:33:25,230 --> 00:33:30,030
your users will hate you if it was

00:33:27,900 --> 00:33:31,890
something for set the baud rate or

00:33:30,030 --> 00:33:38,160
something yes then you need to repeat it

00:33:31,890 --> 00:33:43,380
avoid this it sucks mmm okay what do we

00:33:38,160 --> 00:33:46,760
have now um when I will do this very

00:33:43,380 --> 00:33:49,820
shortly we have now the capability to

00:33:46,760 --> 00:33:52,790
remain in a runtime suspended state

00:33:49,820 --> 00:33:55,340
while the system goes to a system sleep

00:33:52,790 --> 00:33:58,950
this cannot be done for all devices

00:33:55,340 --> 00:34:00,870
because the preparations for system

00:33:58,950 --> 00:34:03,360
sleep and runtime sleep may be different

00:34:00,870 --> 00:34:05,669
in these cases you still need to wake up

00:34:03,360 --> 00:34:08,629
your devices before they go to sleep and

00:34:05,669 --> 00:34:11,960
resume them when you come back up and

00:34:08,629 --> 00:34:16,099
let the runtime stuff do its thing

00:34:11,960 --> 00:34:20,720
this is done by overloading the prepare

00:34:16,099 --> 00:34:22,730
call back you just give a new return

00:34:20,720 --> 00:34:24,770
value that means I'm a crane member at

00:34:22,730 --> 00:34:28,639
runtime suspended state you don't need

00:34:24,770 --> 00:34:31,280
to do anything and upon resumption you

00:34:28,639 --> 00:34:35,750
only get the complete and what you do

00:34:31,280 --> 00:34:39,710
with this is your problem one thing more

00:34:35,750 --> 00:34:42,530
how does this done is also up to you our

00:34:39,710 --> 00:34:45,649
device model is way too complicated we

00:34:42,530 --> 00:34:48,970
have classes buses domains and whatever

00:34:45,649 --> 00:34:51,889
and they're defined rules for which

00:34:48,970 --> 00:34:53,839
callback takes precedence so you have a

00:34:51,889 --> 00:34:57,109
choice where you can put this in or

00:34:53,839 --> 00:34:59,869
overwrite it or whatever nobody can

00:34:57,109 --> 00:35:05,710
remember the exact rules anybody has to

00:34:59,869 --> 00:35:08,570
look them up so this is up to you and

00:35:05,710 --> 00:35:11,810
you can put it either in the subsystem

00:35:08,570 --> 00:35:17,030
or in a specific driver so legalese any

00:35:11,810 --> 00:35:25,820
questions I'm sorry this was a bit hard

00:35:17,030 --> 00:35:28,070
obviously no quest oh yes to set a

00:35:25,820 --> 00:35:31,790
device in sleeping mode and then wake

00:35:28,070 --> 00:35:37,010
about I think this needs power to and in

00:35:31,790 --> 00:35:39,830
the Sun you will really save energy this

00:35:37,010 --> 00:35:44,240
is a complicated question that's why we

00:35:39,830 --> 00:35:48,349
have this heuristics a yes you need to

00:35:44,240 --> 00:35:50,960
to select your time out correctly this

00:35:48,349 --> 00:35:53,960
is a question which the colonel cannot

00:35:50,960 --> 00:35:57,099
answer because in the generic case we do

00:35:53,960 --> 00:36:01,310
not know the amounts of energy involved

00:35:57,099 --> 00:36:03,170
it is not specified and yes if you're

00:36:01,310 --> 00:36:09,369
writing a platform device then you know

00:36:03,170 --> 00:36:09,369
but in a generic case no sorry

00:36:13,630 --> 00:36:22,540

YouTube URL: https://www.youtube.com/watch?v=u3kFZTUnLf8


