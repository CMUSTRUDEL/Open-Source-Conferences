Title: OSC15 -  Andreas FÃ¤rber - ARM software development on openSUSE
Publication date: 2015-05-03
Playlist: openSUSE Conference 2015
Description: 
	A lot has been said already about how the openSUSE packages for ARM have been built in OBS. This talk will instead focus on how some of the tools in openSUSE 13.2 or Factory on your ARM system can be used not only to enable openSUSE running on more ARM devices, but also to develop software for ARM microcontrollers that cannot run openSUSE themselves. What can you do if no JeOS image is readily available for your device? What if not even the upstream kernel supports your device yet? What if your kernel starts to boot but shows no graphical output? How to get your code onto devices without external boot media? Don't despair, for many scenarios there's recipes that don't require you to take the device apart! Remaining obstacles and limitations will be discussed as well.
Captions: 
	00:00:00,170 --> 00:00:07,189
my name Andrea's sorry my name is

00:00:03,030 --> 00:00:10,920
andreas and my quest this morning is to

00:00:07,189 --> 00:00:12,990
introduce you to some more aspects of

00:00:10,920 --> 00:00:17,660
software development for the arm

00:00:12,990 --> 00:00:21,660
platform I'm going to start with some

00:00:17,660 --> 00:00:23,730
easy topics that will apply to any one

00:00:21,660 --> 00:00:25,350
of you that is involved in packaging

00:00:23,730 --> 00:00:30,109
stuff for opensuse and then I will

00:00:25,350 --> 00:00:30,109
gradually go into more advanced topics

00:00:31,340 --> 00:00:39,719
so as far as building software packages

00:00:36,200 --> 00:00:41,579
is concerned this is what you should

00:00:39,719 --> 00:00:43,739
know about the ARM architecture there is

00:00:41,579 --> 00:00:46,590
not just the ARM architecture there is a

00:00:43,739 --> 00:00:49,980
lot of versions and sub versions and a B

00:00:46,590 --> 00:00:53,399
is that we're using for four different

00:00:49,980 --> 00:00:55,949
platforms and the naming slightly varies

00:00:53,399 --> 00:01:00,210
between the different software packages

00:00:55,949 --> 00:01:03,719
involved here so the most important

00:01:00,210 --> 00:01:05,939
things to know is that we have three ARM

00:01:03,719 --> 00:01:08,130
architecture supported in opensuse at

00:01:05,939 --> 00:01:11,700
the moment if you look at the the build

00:01:08,130 --> 00:01:16,710
service those are called arm be 6l arm

00:01:11,700 --> 00:01:19,170
v7 l and AR 64 with a are 64 obviously

00:01:16,710 --> 00:01:22,530
being the 64-bit version and the other

00:01:19,170 --> 00:01:27,060
ones being different ABI is for 32-bit

00:01:22,530 --> 00:01:29,190
devices arm v6 is mostly for the

00:01:27,060 --> 00:01:31,910
Raspberry Pi and arm v7 is putting

00:01:29,190 --> 00:01:31,910
anything else

00:01:34,450 --> 00:01:41,170
now if you have your home repository or

00:01:38,200 --> 00:01:44,500
any development repository in the build

00:01:41,170 --> 00:01:47,850
service then you can add if you haven't

00:01:44,500 --> 00:01:51,640
already the open to the factory arm

00:01:47,850 --> 00:01:54,460
repository and once you've done so then

00:01:51,640 --> 00:01:56,799
there's a by default only on b7 enabled

00:01:54,460 --> 00:02:00,100
and you can additionally enable the

00:01:56,799 --> 00:02:03,219
64-bit builds and if you really have to

00:02:00,100 --> 00:02:05,079
the arm v6 builds but be aware that as

00:02:03,219 --> 00:02:09,009
was already indicated on the previous

00:02:05,079 --> 00:02:12,670
slide arm v6 is built using emulations

00:02:09,009 --> 00:02:16,900
that means it's pretty slow whereas I'm

00:02:12,670 --> 00:02:21,750
arm v7 and since recently also a are 64

00:02:16,900 --> 00:02:21,750
are built on native arm hardware

00:02:25,120 --> 00:02:31,520
for the spec files the most important

00:02:28,700 --> 00:02:34,400
bit to know is that because there's also

00:02:31,520 --> 00:02:37,790
been some name changes originally then

00:02:34,400 --> 00:02:40,700
you can use this macro represent arm to

00:02:37,790 --> 00:02:44,630
represent the two or if they were even

00:02:40,700 --> 00:02:46,520
three 32-bit architectures so that means

00:02:44,630 --> 00:02:50,540
that you can say for instance that a

00:02:46,520 --> 00:02:53,780
particular X driver is only for arm by

00:02:50,540 --> 00:02:56,840
saying exclusive arch percent arm and a

00:02:53,780 --> 00:03:00,709
art 64 to have it for both 32-bit and

00:02:56,840 --> 00:03:03,080
64-bit or if there's anything particular

00:03:00,709 --> 00:03:04,970
to 32 but unlike enabling certain

00:03:03,080 --> 00:03:07,459
options only for that platform you can

00:03:04,970 --> 00:03:11,870
use the iPod micro to do that

00:03:07,459 --> 00:03:16,580
specifically now when we're dealing with

00:03:11,870 --> 00:03:19,670
the emulated builds original that was

00:03:16,580 --> 00:03:22,310
the 64-bit on build but also as I

00:03:19,670 --> 00:03:25,190
mentioned the arm basics build for for

00:03:22,310 --> 00:03:29,660
the Raspberry Pi those are done using

00:03:25,190 --> 00:03:34,400
qmu using a user space ambulation inside

00:03:29,660 --> 00:03:37,670
an x86 kvm virtual machine and sometimes

00:03:34,400 --> 00:03:39,680
qm gia does not get maybe an instruction

00:03:37,670 --> 00:03:41,360
right or it is lacking you know some

00:03:39,680 --> 00:03:45,560
some users call that has to come up

00:03:41,360 --> 00:03:47,870
before and the most frequent way that

00:03:45,560 --> 00:03:50,870
we're seeing this is that I'm test

00:03:47,870 --> 00:03:53,989
Suites failed to run maybe because of

00:03:50,870 --> 00:03:56,299
also some single handling issues and if

00:03:53,989 --> 00:03:59,660
that is the case it is possible to check

00:03:56,299 --> 00:04:00,980
this macro can you use a space build to

00:03:59,660 --> 00:04:03,650
see if you're running in such an

00:04:00,980 --> 00:04:06,769
emulated build and to take decisions on

00:04:03,650 --> 00:04:11,930
that like disabling the trek phase of

00:04:06,769 --> 00:04:14,480
the RPM package obviously if you do so

00:04:11,930 --> 00:04:17,540
please don't silently do that everywhere

00:04:14,480 --> 00:04:20,180
just do it when necessary and in that

00:04:17,540 --> 00:04:22,490
case also please tell us so that someone

00:04:20,180 --> 00:04:25,840
can actually look into fixing the

00:04:22,490 --> 00:04:25,840
underlying issues if possible

00:04:26,690 --> 00:04:33,990
another thing to keep in mind is that a

00:04:30,380 --> 00:04:37,050
number of larger packages in the build

00:04:33,990 --> 00:04:40,289
servers have started to request things

00:04:37,050 --> 00:04:42,330
like four gigabyte of RAM when we have

00:04:40,289 --> 00:04:45,240
built workers for the 32-bit ones that

00:04:42,330 --> 00:04:47,310
are running mostly on arndale boards we

00:04:45,240 --> 00:04:49,680
only have two gigabyte of RAM in hold

00:04:47,310 --> 00:04:51,300
there and we're in you know taking part

00:04:49,680 --> 00:04:55,039
of that for for the system as well

00:04:51,300 --> 00:04:57,690
running the virtual machine so don't

00:04:55,039 --> 00:04:59,669
take two huge numbers just take what you

00:04:57,690 --> 00:05:03,870
really need in order to and get the

00:04:59,669 --> 00:05:06,419
package to build oh and if you've never

00:05:03,870 --> 00:05:10,169
seen this before this is like a small

00:05:06,419 --> 00:05:18,650
XML text file that is lying inside the

00:05:10,169 --> 00:05:24,870
the package in OBS Jones I mean now as

00:05:18,650 --> 00:05:28,080
far as getting arm packages into the

00:05:24,870 --> 00:05:29,610
opens with a distribution forearm if the

00:05:28,080 --> 00:05:31,199
package is already in factory then

00:05:29,610 --> 00:05:34,729
there's nothing to do they will simply

00:05:31,199 --> 00:05:37,639
be rebuilt forearm if you have your own

00:05:34,729 --> 00:05:41,490
package that you're currently working on

00:05:37,639 --> 00:05:42,780
be it an arm specific package like some

00:05:41,490 --> 00:05:45,930
library that that doesn't matter

00:05:42,780 --> 00:05:49,169
elsewhere or some package where you're

00:05:45,930 --> 00:05:51,030
one to test that it actually works for

00:05:49,169 --> 00:05:54,030
arm too in addition to the x86

00:05:51,030 --> 00:05:56,340
architecture then you can enable and the

00:05:54,030 --> 00:05:58,250
arm builds as described on one of the

00:05:56,340 --> 00:06:01,530
previous slides in your home repository

00:05:58,250 --> 00:06:04,009
and then you're going to see whether it

00:06:01,530 --> 00:06:06,599
you know fails or succeeds as usual and

00:06:04,009 --> 00:06:11,669
once you submit them to the devel

00:06:06,599 --> 00:06:13,650
project some develop projects and have

00:06:11,669 --> 00:06:17,940
actually enabled these are both some

00:06:13,650 --> 00:06:20,430
don't where necessary it might be a good

00:06:17,940 --> 00:06:22,289
idea to to actually activate that I've

00:06:20,430 --> 00:06:24,330
seen for instance that the security

00:06:22,289 --> 00:06:26,820
repository doesn't have didn't have arm

00:06:24,330 --> 00:06:28,740
built or not all armbands enabled that

00:06:26,820 --> 00:06:32,690
may be useful for catching things like

00:06:28,740 --> 00:06:32,690
lips I comp builds

00:06:33,230 --> 00:06:41,200
and as probably most if you know when

00:06:37,540 --> 00:06:44,080
the devel project gets submitted to the

00:06:41,200 --> 00:06:46,940
factory repository open to the factory

00:06:44,080 --> 00:06:50,150
then it goes to the staging process

00:06:46,940 --> 00:06:52,940
these days and however this staging

00:06:50,150 --> 00:06:57,080
process right now is only done for x86

00:06:52,940 --> 00:07:01,250
and for ppc64 le but not for arm that

00:06:57,080 --> 00:07:03,530
means that if the package failed to

00:07:01,250 --> 00:07:06,170
build or fail to build due to other

00:07:03,530 --> 00:07:08,240
packages that is not recognized until it

00:07:06,170 --> 00:07:11,180
actually hits factory and is then built

00:07:08,240 --> 00:07:17,720
for forearm so that's why I was

00:07:11,180 --> 00:07:19,730
suggesting to enable arm builds for for

00:07:17,720 --> 00:07:21,920
the respective develop and repository so

00:07:19,730 --> 00:07:24,080
that we can catch this early on and

00:07:21,920 --> 00:07:28,580
ideally fix it by the respective

00:07:24,080 --> 00:07:30,800
contributor obviously every rule has

00:07:28,580 --> 00:07:34,160
exceptions and the exception here is

00:07:30,800 --> 00:07:37,040
that opensuse factory arm does contain a

00:07:34,160 --> 00:07:39,140
few packages most notably the juice

00:07:37,040 --> 00:07:41,240
package juice as in just enough OS

00:07:39,140 --> 00:07:43,880
that's the images that we're using

00:07:41,240 --> 00:07:48,940
rather than either installation images

00:07:43,880 --> 00:07:51,350
for for the regular opensuse and a

00:07:48,940 --> 00:07:54,290
couple more like for instance we're

00:07:51,350 --> 00:07:56,450
using really annuity OMB aversion for

00:07:54,290 --> 00:08:00,020
the emulated bills then we have in in

00:07:56,450 --> 00:08:03,680
factory and if you have such a arm

00:08:00,020 --> 00:08:05,870
specific arm factory arm specific opens

00:08:03,680 --> 00:08:08,900
as a factory arm specific package and

00:08:05,870 --> 00:08:11,180
then the submission process will be to

00:08:08,900 --> 00:08:13,040
directly branch it from opensuse factory

00:08:11,180 --> 00:08:14,510
arm and submit if they are directly

00:08:13,040 --> 00:08:19,270
without going through other develop

00:08:14,510 --> 00:08:19,270
projects or the usual factory process

00:08:20,449 --> 00:08:28,999
now let's get on to kernel development

00:08:22,699 --> 00:08:34,459
if there is a juice image then you can

00:08:28,999 --> 00:08:36,740
just download an image file on zip it

00:08:34,459 --> 00:08:39,800
exceed whatever and write it to an SD

00:08:36,740 --> 00:08:43,519
card use B stick or whatever and power

00:08:39,800 --> 00:08:45,380
on the device and it should work but in

00:08:43,519 --> 00:08:48,320
many cases people don't all have the

00:08:45,380 --> 00:08:50,589
same boards and you boards come up come

00:08:48,320 --> 00:08:54,199
out you know like every month at least

00:08:50,589 --> 00:08:59,800
so it's it's very hard for us to to play

00:08:54,199 --> 00:09:05,120
catch-up and we rely on contributions by

00:08:59,800 --> 00:09:07,120
by users of our distribution and in

00:09:05,120 --> 00:09:10,010
particular when you compare the

00:09:07,120 --> 00:09:13,130
architectures that you've seen in the

00:09:10,010 --> 00:09:17,899
first section think about that there is

00:09:13,130 --> 00:09:21,579
not just the architectures as defined by

00:09:17,899 --> 00:09:24,050
the company arm but you have like two

00:09:21,579 --> 00:09:26,480
dozen at least vendors that are actually

00:09:24,050 --> 00:09:30,649
implementing those architectures and

00:09:26,480 --> 00:09:34,670
each one of those needs its specific

00:09:30,649 --> 00:09:37,399
code to actually boot up it has for all

00:09:34,670 --> 00:09:39,560
you know drivers starting from from

00:09:37,399 --> 00:09:42,199
cereal not even to mention graphics

00:09:39,560 --> 00:09:44,779
drivers they're all different between

00:09:42,199 --> 00:09:50,029
the vendors and there is no real common

00:09:44,779 --> 00:09:52,010
subset in particular for 32-bit as far

00:09:50,029 --> 00:09:55,760
as booting goes so you know for for x86

00:09:52,010 --> 00:09:57,740
you can assume that through bios a UEFI

00:09:55,760 --> 00:09:59,690
you can just put the CD into your drive

00:09:57,740 --> 00:10:01,730
and it will boot up and maybe you know

00:09:59,690 --> 00:10:03,079
sound or network or something is not

00:10:01,730 --> 00:10:05,899
going to work but it's going to work in

00:10:03,079 --> 00:10:10,220
general unfortunately that that's not as

00:10:05,899 --> 00:10:13,010
easy with arm these days now before you

00:10:10,220 --> 00:10:15,370
start messing with a colonel i already

00:10:13,010 --> 00:10:19,970
mentioned it there's the juice images

00:10:15,370 --> 00:10:21,829
here I've included some some links where

00:10:19,970 --> 00:10:23,360
you can actually check whether there is

00:10:21,829 --> 00:10:26,300
something for your board available

00:10:23,360 --> 00:10:28,160
there's also probably your first stop

00:10:26,300 --> 00:10:31,189
resource would be the opensuse Vicki

00:10:28,160 --> 00:10:32,620
it's not always fully up to date as far

00:10:31,189 --> 00:10:35,770
as the latest

00:10:32,620 --> 00:10:38,110
13 draw two or factory versions go but

00:10:35,770 --> 00:10:39,460
if it has a page on a particular device

00:10:38,110 --> 00:10:41,230
it means that someone has already

00:10:39,460 --> 00:10:43,510
started working on it or it might

00:10:41,230 --> 00:10:47,050
probably even be working and so you

00:10:43,510 --> 00:10:50,770
don't need to start from zero in some

00:10:47,050 --> 00:10:53,940
cases it's not possible to put the

00:10:50,770 --> 00:10:57,340
support for a particular arm device into

00:10:53,940 --> 00:11:00,070
open to the factory proper and because

00:10:57,340 --> 00:11:01,600
for instance and proprietary boot from

00:11:00,070 --> 00:11:03,850
Bray might be involved that's the case

00:11:01,600 --> 00:11:06,700
for the Raspberry Pi for instance also

00:11:03,850 --> 00:11:11,860
for most Samsung Exynos based and

00:11:06,700 --> 00:11:15,220
chipsets in those cases we have the

00:11:11,860 --> 00:11:17,950
devil are factory contrib plus some name

00:11:15,220 --> 00:11:20,830
such as well Chromebook Raspberry Pi

00:11:17,950 --> 00:11:24,550
whatever raspberry pi 2 where you can

00:11:20,830 --> 00:11:26,860
then find respective packages including

00:11:24,550 --> 00:11:32,410
the the images separately from the

00:11:26,860 --> 00:11:34,180
regular ones now if you don't have a

00:11:32,410 --> 00:11:37,780
juice image in either of the two

00:11:34,180 --> 00:11:40,510
locations the question is would it be

00:11:37,780 --> 00:11:46,300
very easy to actually add one so is

00:11:40,510 --> 00:11:49,270
there a DTS file in the kernel that

00:11:46,300 --> 00:11:51,460
we're already packaging and does the

00:11:49,270 --> 00:11:53,170
chipset support in terms of drivers

00:11:51,460 --> 00:11:58,060
already exist for that particular trip

00:11:53,170 --> 00:11:59,770
set if that is not the case well or at

00:11:58,060 --> 00:12:02,020
least first if that is the case then you

00:11:59,770 --> 00:12:04,500
can just simply branch the juice package

00:12:02,020 --> 00:12:07,170
add a few lines to into an ifdef

00:12:04,500 --> 00:12:09,700
generate a new spec file and you're good

00:12:07,170 --> 00:12:13,900
if not it's going to be slightly more

00:12:09,700 --> 00:12:16,570
complicated more on that later and the

00:12:13,900 --> 00:12:19,810
second thing to to ask yourself is how

00:12:16,570 --> 00:12:23,680
does the boot process work this is

00:12:19,810 --> 00:12:25,960
usually documented by the vendors

00:12:23,680 --> 00:12:27,970
providing the boards or by community

00:12:25,960 --> 00:12:31,240
sites documenting those things in some

00:12:27,970 --> 00:12:33,940
form of Vicki like UNIX onyx I blahnik

00:12:31,240 --> 00:12:36,730
sexiness and let's rock chip or some of

00:12:33,940 --> 00:12:42,390
those platforms as well as any linux org

00:12:36,730 --> 00:12:46,080
and if it's just about enabling the

00:12:42,390 --> 00:12:47,790
correct mostly you would binary to build

00:12:46,080 --> 00:12:49,950
we have a package that can be branched

00:12:47,790 --> 00:12:53,010
and also with the script simply have a

00:12:49,950 --> 00:12:55,380
conflict to that added and then be

00:12:53,010 --> 00:12:58,430
placed ad for instance a particular

00:12:55,380 --> 00:13:02,300
offset then that is possible otherwise

00:12:58,430 --> 00:13:07,860
you're going to be interested in the

00:13:02,300 --> 00:13:11,550
next steps so if there is no crawl to

00:13:07,860 --> 00:13:14,070
start from that simply assume that there

00:13:11,550 --> 00:13:16,980
is some support for it in the upstream

00:13:14,070 --> 00:13:21,410
Colonel be it in Blowing snitch or

00:13:16,980 --> 00:13:21,410
Lennox neck and licks dash max target

00:13:22,250 --> 00:13:28,200
you can use an existing armboard if you

00:13:26,040 --> 00:13:31,380
already have one if not obviously that's

00:13:28,200 --> 00:13:33,480
not in an option and you can instead use

00:13:31,380 --> 00:13:35,160
a change food using the same kmv

00:13:33,480 --> 00:13:40,110
emulation technologies that we're using

00:13:35,160 --> 00:13:43,740
in OBS there's also an ice cream cross

00:13:40,110 --> 00:13:45,240
compiler support in NGC see that you can

00:13:43,740 --> 00:13:50,850
install I believe that is you can part

00:13:45,240 --> 00:13:52,170
of a factory and as was outlined on the

00:13:50,850 --> 00:13:55,950
previous slides you can't just you know

00:13:52,170 --> 00:13:57,960
enable arm builds for for existing

00:13:55,950 --> 00:14:01,650
packages you can simply put a char ball

00:13:57,960 --> 00:14:03,030
for a random linux kernel into the build

00:14:01,650 --> 00:14:06,000
service as well and have it built there

00:14:03,030 --> 00:14:09,750
if you actually have the conflict for

00:14:06,000 --> 00:14:14,100
that if you don't have one yet you can

00:14:09,750 --> 00:14:16,500
create it using make arch equals arm or

00:14:14,100 --> 00:14:21,000
arm 64's was outlined on the very first

00:14:16,500 --> 00:14:22,650
slide and running old config menu config

00:14:21,000 --> 00:14:27,540
defcon take all these commands that you

00:14:22,650 --> 00:14:29,460
know from from x86 but there is no

00:14:27,540 --> 00:14:32,430
universal guide like i said this highly

00:14:29,460 --> 00:14:34,680
varies and based on both board and the

00:14:32,430 --> 00:14:36,390
chipset the board contains so you're

00:14:34,680 --> 00:14:38,450
going to need to rely on documentation

00:14:36,390 --> 00:14:41,430
provided by the respective vendors

00:14:38,450 --> 00:14:44,430
usually the maintainer of the lungs from

00:14:41,430 --> 00:14:47,040
upstream have a diff config for a

00:14:44,430 --> 00:14:49,500
particular family of chipsets so that's

00:14:47,040 --> 00:14:51,150
usually the recommended way to get

00:14:49,500 --> 00:14:55,920
started for instance there is a

00:14:51,150 --> 00:14:58,410
BCM 28-35 defconfig that you can use for

00:14:55,920 --> 00:15:01,950
for the raspberry pi 1 or they're like

00:14:58,410 --> 00:15:04,800
an Exynos defconfig for some others

00:15:01,950 --> 00:15:08,280
there's just around the generic multi v7

00:15:04,800 --> 00:15:13,830
defconfig which covers most of the RB 7

00:15:08,280 --> 00:15:17,970
devices in the market if you want to

00:15:13,830 --> 00:15:20,040
avoid messing with inert RDS simply and

00:15:17,970 --> 00:15:24,240
have all the drivers built in those

00:15:20,040 --> 00:15:28,860
mentioned like Exynos defconfig will do

00:15:24,240 --> 00:15:32,880
that automatically by default and 4 for

00:15:28,860 --> 00:15:35,820
32-bit builds you can prefer to build a

00:15:32,880 --> 00:15:37,980
Z image that Z image can be used and

00:15:35,820 --> 00:15:42,530
generically whereas some old you good

00:15:37,980 --> 00:15:46,560
versions want a Jew boo at you image

00:15:42,530 --> 00:15:49,320
binary which then also has the board or

00:15:46,560 --> 00:15:51,120
at least chipset specific memory

00:15:49,320 --> 00:15:54,360
location offsets in there so we can't

00:15:51,120 --> 00:15:58,740
really build that as a generic as a

00:15:54,360 --> 00:16:02,400
generic or curl package that's for

00:15:58,740 --> 00:16:05,660
32-bit for for 64-bit it's just called

00:16:02,400 --> 00:16:05,660
image or images add

00:16:08,370 --> 00:16:20,160
once you've compiled the colonel via

00:16:12,510 --> 00:16:22,230
those outlined ways there is again no

00:16:20,160 --> 00:16:24,330
generic way of how you actually install

00:16:22,230 --> 00:16:27,690
this an image to this that's kernel

00:16:24,330 --> 00:16:30,240
image to the system and then what you

00:16:27,690 --> 00:16:34,110
need to look into in that case is what

00:16:30,240 --> 00:16:35,490
bootloader is the board using and where

00:16:34,110 --> 00:16:38,610
is that bootloader is supposed to be

00:16:35,490 --> 00:16:41,790
located ideally it's in a separate flash

00:16:38,610 --> 00:16:43,680
and you can use like an SD card or

00:16:41,790 --> 00:16:46,410
something else or use piece take

00:16:43,680 --> 00:16:49,610
anything else for the colonel and the

00:16:46,410 --> 00:16:53,430
partition that open dude is providing

00:16:49,610 --> 00:16:57,210
for UEFI that's going to be and easiest

00:16:53,430 --> 00:17:00,420
that's the case with most of the 64-bit

00:16:57,210 --> 00:17:02,430
service that have started to emerge then

00:17:00,420 --> 00:17:04,170
you just need to run the grub to config

00:17:02,430 --> 00:17:06,420
and have it and add it to the config

00:17:04,170 --> 00:17:11,010
file and it'll all work it should all

00:17:06,420 --> 00:17:13,140
work if you're using you boot then

00:17:11,010 --> 00:17:15,829
things are a bit more complicated so

00:17:13,140 --> 00:17:18,990
either you may need to look at the

00:17:15,829 --> 00:17:21,089
environment that is and located possibly

00:17:18,990 --> 00:17:22,439
in flash there's a printf command where

00:17:21,089 --> 00:17:27,420
you can look at the boot args and

00:17:22,439 --> 00:17:29,730
possibly tweak them otherwise the

00:17:27,420 --> 00:17:31,950
process that we're using for for juice

00:17:29,730 --> 00:17:36,660
images is to have a file called in boot

00:17:31,950 --> 00:17:41,780
scr which is simply a small textual

00:17:36,660 --> 00:17:45,540
script with the commands for loading the

00:17:41,780 --> 00:17:48,990
colonel device tree and so on files from

00:17:45,540 --> 00:17:54,900
the respective brute medium usually from

00:17:48,990 --> 00:17:56,730
from MMC and in case of the z image that

00:17:54,900 --> 00:17:59,190
would be the boot z command otherwise

00:17:56,730 --> 00:18:04,110
it's the boot em command for you for you

00:17:59,190 --> 00:18:06,929
good image and that script gets a small

00:18:04,110 --> 00:18:10,429
binary header added that contains the

00:18:06,929 --> 00:18:15,120
the type of the data loaded and the

00:18:10,429 --> 00:18:17,310
length that is basically what this boot

00:18:15,120 --> 00:18:20,090
SDR file is and you can look at it

00:18:17,310 --> 00:18:25,070
simply and less because of that

00:18:20,090 --> 00:18:27,559
and another alternative bootloader

00:18:25,070 --> 00:18:30,140
that's come up is the so called an elk a

00:18:27,559 --> 00:18:33,610
little krunal that's what most Android

00:18:30,140 --> 00:18:37,789
devices use for for booting these days

00:18:33,610 --> 00:18:41,450
that one allows you to install the

00:18:37,789 --> 00:18:44,059
Android tools package and that has a

00:18:41,450 --> 00:18:46,850
command called fast food which allows

00:18:44,059 --> 00:18:49,429
you to transfer via a USB device cable

00:18:46,850 --> 00:18:52,070
I'm a colonel to the device which is M

00:18:49,429 --> 00:18:55,159
well to ram on the device and it will

00:18:52,070 --> 00:18:57,289
then boot it from from there the easiest

00:18:55,159 --> 00:18:59,690
way is to simply transfer the Z image

00:18:57,289 --> 00:19:03,260
that's why it's really handy or you can

00:18:59,690 --> 00:19:05,120
create a boot image that's what it's

00:19:03,260 --> 00:19:07,130
called that a special Android format

00:19:05,120 --> 00:19:11,000
that contains both the colonel the

00:19:07,130 --> 00:19:19,130
device tree and the inner door d+ also

00:19:11,000 --> 00:19:21,409
the colonel command line if the

00:19:19,130 --> 00:19:23,570
bootloader whichever it is is not

00:19:21,409 --> 00:19:26,690
located in a separate flash and you need

00:19:23,570 --> 00:19:29,120
to provide themselves then most in most

00:19:26,690 --> 00:19:31,370
cases and it is going to be an offset

00:19:29,120 --> 00:19:35,179
very early on the SD card before the

00:19:31,370 --> 00:19:37,190
real partition start and you're going to

00:19:35,179 --> 00:19:39,470
need to use them DD to simply write it

00:19:37,190 --> 00:19:44,960
there and make sure that your partitions

00:19:39,470 --> 00:19:49,220
don't start that early once you have

00:19:44,960 --> 00:19:53,149
that working hopefully the way to

00:19:49,220 --> 00:19:55,789
actually transition to using the

00:19:53,149 --> 00:19:57,740
official opensuse colonel would be to

00:19:55,789 --> 00:20:01,309
obviously make sure that all the drivers

00:19:57,740 --> 00:20:05,720
you need are in the upstream kernel that

00:20:01,309 --> 00:20:09,470
opensuse is currently using so make sure

00:20:05,720 --> 00:20:10,789
that the configs which are kept and

00:20:09,470 --> 00:20:14,120
maintained in the kernel source

00:20:10,789 --> 00:20:19,340
repository actually enable all the the

00:20:14,120 --> 00:20:21,020
drivers that your board needs where for

00:20:19,340 --> 00:20:22,640
for opensuse Colonel we're not using

00:20:21,020 --> 00:20:25,340
built-in drivers for everything so we

00:20:22,640 --> 00:20:28,669
need them for for you art for the serial

00:20:25,340 --> 00:20:30,679
convicts for for the clocks but for

00:20:28,669 --> 00:20:31,980
anything else pretty much we use modules

00:20:30,679 --> 00:20:33,480
to make

00:20:31,980 --> 00:20:35,850
and the kernel as small as possible

00:20:33,480 --> 00:20:42,570
while supporting as many devices as

00:20:35,850 --> 00:20:45,120
possible so at some point an automatic

00:20:42,570 --> 00:20:48,900
script runs every morning that transfers

00:20:45,120 --> 00:20:51,510
the configs from the that git repository

00:20:48,900 --> 00:20:55,080
into the kernel head package then it's

00:20:51,510 --> 00:20:56,940
going to be rebuilt and a couple or even

00:20:55,080 --> 00:21:00,600
many hours later we will hopefully have

00:20:56,940 --> 00:21:03,540
a successfully build colonel opensuse

00:21:00,600 --> 00:21:05,580
chrono and at some point that gets and

00:21:03,540 --> 00:21:06,840
transmitted to to the colonel stable

00:21:05,580 --> 00:21:08,700
repository and from calm stable

00:21:06,840 --> 00:21:12,480
repository to open to the factory and

00:21:08,700 --> 00:21:14,669
again once it's in in in factory then

00:21:12,480 --> 00:21:19,140
the arm flavor will also be and get

00:21:14,669 --> 00:21:22,309
built in open to the factory arm an

00:21:19,140 --> 00:21:25,880
additional thing to watch out is that if

00:21:22,309 --> 00:21:28,200
your board is using a device tree file

00:21:25,880 --> 00:21:31,290
you need to make sure that the device

00:21:28,200 --> 00:21:33,660
tree and the colonel are in sync which

00:21:31,290 --> 00:21:37,490
means that you need to not only install

00:21:33,660 --> 00:21:40,260
the colonel package but also a dtb and

00:21:37,490 --> 00:21:42,990
package which is specific to the

00:21:40,260 --> 00:21:49,460
respective chipset of your board which

00:21:42,990 --> 00:21:55,260
means that for instance there would be a

00:21:49,460 --> 00:21:58,650
dtb dash Tegra 124 package to use with

00:21:55,260 --> 00:22:02,970
the jets into k1 board as just one

00:21:58,650 --> 00:22:05,070
random example and depending on what arm

00:22:02,970 --> 00:22:08,669
trip you're using on that particular

00:22:05,070 --> 00:22:12,360
board and is it one that supports the

00:22:08,669 --> 00:22:14,850
large physical address extensions and we

00:22:12,360 --> 00:22:16,799
have a criminal LP flavor this one is

00:22:14,850 --> 00:22:20,820
necessary to actually run kvm

00:22:16,799 --> 00:22:23,220
virtualization otherwise for 64-bit

00:22:20,820 --> 00:22:27,020
servers or for the Raspberry Pi you can

00:22:23,220 --> 00:22:27,020
simply use the colonel default flavor

00:22:27,570 --> 00:22:33,690
and well last but not least again if

00:22:30,720 --> 00:22:36,270
you're using you boot the boot as the

00:22:33,690 --> 00:22:38,520
ARFF file does not only need to

00:22:36,270 --> 00:22:41,520
reference the kernel and the dtp file

00:22:38,520 --> 00:22:44,220
now but also the init rd to have all the

00:22:41,520 --> 00:22:47,550
drivers that are built as modules for

00:22:44,220 --> 00:22:52,290
the opensuse kernel and you might make

00:22:47,550 --> 00:23:01,470
to you might need to make sure that you

00:22:52,290 --> 00:23:02,820
might need to make sure that the forgot

00:23:01,470 --> 00:23:08,460
what I was going to say so and let's

00:23:02,820 --> 00:23:10,650
just move on if it's not working then

00:23:08,460 --> 00:23:12,720
you're going to need to use some moons

00:23:10,650 --> 00:23:16,260
house methods to to pull yourself out of

00:23:12,720 --> 00:23:18,600
that trouble and for instance as far as

00:23:16,260 --> 00:23:20,070
you can try not to put things or too

00:23:18,600 --> 00:23:22,350
much things into the internal flash

00:23:20,070 --> 00:23:24,750
because if the internal flash is somehow

00:23:22,350 --> 00:23:28,380
screwed you can no longer and easily

00:23:24,750 --> 00:23:30,000
access them so I'm use SD card initially

00:23:28,380 --> 00:23:31,710
if you have an SD card you can take it

00:23:30,000 --> 00:23:34,380
out plug it into your PC BIOS I'm

00:23:31,710 --> 00:23:36,120
adapter and then either tweak some links

00:23:34,380 --> 00:23:43,320
to point to a different kernel and dtb

00:23:36,120 --> 00:23:45,300
file or insert new ones to test before

00:23:43,320 --> 00:23:47,790
you update the colonel be it i'm

00:23:45,300 --> 00:23:49,770
installing the the one from from

00:23:47,790 --> 00:23:52,020
opensuse or a new one that you've

00:23:49,770 --> 00:23:57,150
compiled yourself always make backups of

00:23:52,020 --> 00:24:00,650
them it's very handy and don't expect

00:23:57,150 --> 00:24:03,300
everything to work at once so if you're

00:24:00,650 --> 00:24:05,880
if you have a serial console working

00:24:03,300 --> 00:24:07,470
that's already pretty good at times

00:24:05,880 --> 00:24:11,880
because arm unfortunately has a lot of

00:24:07,470 --> 00:24:13,980
regressions from time to time and don't

00:24:11,880 --> 00:24:15,780
despair if you don't see an image on

00:24:13,980 --> 00:24:17,550
hdmi the device might still be working

00:24:15,780 --> 00:24:19,110
and you need to be creative to for

00:24:17,550 --> 00:24:22,620
instance use a static IP address

00:24:19,110 --> 00:24:26,010
connected device over over ethernet and

00:24:22,620 --> 00:24:28,320
simply look at what the device has been

00:24:26,010 --> 00:24:32,880
out putting into the into the chronolog

00:24:28,320 --> 00:24:34,920
d message or another trick is if you're

00:24:32,880 --> 00:24:36,480
using a you boot there's a command to

00:24:34,920 --> 00:24:40,169
actually read memory so you have a

00:24:36,480 --> 00:24:45,359
chance of reading the in-memory log of

00:24:40,169 --> 00:24:47,669
or for the colonel now the more

00:24:45,359 --> 00:24:53,549
difficult part which I can't cover today

00:24:47,669 --> 00:24:55,379
is if you're bored first first board is

00:24:53,549 --> 00:25:00,659
not supported in the kernel of what you

00:24:55,379 --> 00:25:02,549
do then if you have usually a some pre

00:25:00,659 --> 00:25:04,830
installed system and you can look for

00:25:02,549 --> 00:25:06,929
instance at proc device tree to find out

00:25:04,830 --> 00:25:11,730
what hardware is wired up in which ways

00:25:06,929 --> 00:25:16,409
on that and there's a tools the the dtc

00:25:11,730 --> 00:25:20,779
package has options to reverse compile

00:25:16,409 --> 00:25:23,149
the binary dtp file into a DTS or other

00:25:20,779 --> 00:25:25,919
ways that you can actually read them and

00:25:23,149 --> 00:25:30,090
obviously the Lynch colonel usually has

00:25:25,919 --> 00:25:32,669
multiple at least one example / chipset

00:25:30,090 --> 00:25:33,960
that you can look at and compare what

00:25:32,669 --> 00:25:36,059
other boards have and simply use

00:25:33,960 --> 00:25:40,710
something as a template and play around

00:25:36,059 --> 00:25:45,350
from there to find out now I'm going to

00:25:40,710 --> 00:25:50,820
run very quickly through the next topic

00:25:45,350 --> 00:25:53,279
in this image there is a7 machines

00:25:50,820 --> 00:25:56,309
hidden that are actually running

00:25:53,279 --> 00:25:58,679
opensuse on the ARM architecture and

00:25:56,309 --> 00:26:01,080
then there's one device with the red

00:25:58,679 --> 00:26:04,379
circle and that is not running opensuse

00:26:01,080 --> 00:26:06,480
but still is an arm device that is this

00:26:04,379 --> 00:26:09,230
one over here it's a board that's often

00:26:06,480 --> 00:26:16,169
distributed at industry affairs with an

00:26:09,230 --> 00:26:18,379
stm32 chipset cortex m4 and I figured

00:26:16,169 --> 00:26:22,320
out that it is actually possible to use

00:26:18,379 --> 00:26:24,840
opensuse for developing for those mm

00:26:22,320 --> 00:26:27,299
euless devices not using the same

00:26:24,840 --> 00:26:30,840
architecture so here's an example of how

00:26:27,299 --> 00:26:34,049
you can actually compile code for accord

00:26:30,840 --> 00:26:37,649
XM 40 bytes the limitation to that is

00:26:34,049 --> 00:26:39,629
that you don't have the lib GCC I'm

00:26:37,649 --> 00:26:44,190
available for that particular sub

00:26:39,629 --> 00:26:45,899
architecture so you might run into in

00:26:44,190 --> 00:26:49,399
particular linker errors if you're

00:26:45,899 --> 00:26:52,320
compiling your own framework code but

00:26:49,399 --> 00:26:53,580
both the colonel and you would have a

00:26:52,320 --> 00:26:56,460
private copy of

00:26:53,580 --> 00:27:00,630
the relevance of GCC files that you can

00:26:56,460 --> 00:27:04,890
simply activate unable to to build them

00:27:00,630 --> 00:27:07,680
instead of that one you will need to

00:27:04,890 --> 00:27:09,840
have some information from the reference

00:27:07,680 --> 00:27:13,290
manuals about that hardware I'm in

00:27:09,840 --> 00:27:16,680
particular as far as memory goes so when

00:27:13,290 --> 00:27:19,170
you're using opensuse on on some Intel

00:27:16,680 --> 00:27:22,650
notebook then you're used to having

00:27:19,170 --> 00:27:24,510
gigabytes of memory if we're talking

00:27:22,650 --> 00:27:26,430
about in particularly the bootloader

00:27:24,510 --> 00:27:31,590
that does not have that many a memory

00:27:26,430 --> 00:27:34,920
available from the start so you might

00:27:31,590 --> 00:27:36,600
have you know like a megabyte four

00:27:34,920 --> 00:27:43,320
megabytes something in that magnitude

00:27:36,600 --> 00:27:45,000
available and the the different areas

00:27:43,320 --> 00:27:46,710
where memory is available need to

00:27:45,000 --> 00:27:49,740
describe separately in the linker script

00:27:46,710 --> 00:27:51,870
and the usual set up is that you have an

00:27:49,740 --> 00:27:55,580
initial boot loader that runs in the

00:27:51,870 --> 00:28:01,680
SRAM and then that boot loader copies

00:27:55,580 --> 00:28:06,750
code from from from the flash memory or

00:28:01,680 --> 00:28:09,000
other and storage medium into the SDRAM

00:28:06,750 --> 00:28:15,630
or whatever a mother Ram is available on

00:28:09,000 --> 00:28:18,390
the board and jumps into into the kernel

00:28:15,630 --> 00:28:19,740
in in memory they are in order to save

00:28:18,390 --> 00:28:23,310
memory because that is usually very

00:28:19,740 --> 00:28:26,460
limited on these boards it is possible

00:28:23,310 --> 00:28:28,200
to use the execute in place mode of the

00:28:26,460 --> 00:28:31,440
colonel so that means that you can

00:28:28,200 --> 00:28:33,900
execute part of the colonel from your

00:28:31,440 --> 00:28:36,900
flash memory and only have the ones

00:28:33,900 --> 00:28:41,760
where data is actually changing in in

00:28:36,900 --> 00:28:45,030
the ram so this is the example that i am

00:28:41,760 --> 00:28:49,140
already held up and another example that

00:28:45,030 --> 00:28:52,920
i'm currently working on is an FM for

00:28:49,140 --> 00:28:56,370
board this one over here the difference

00:28:52,920 --> 00:28:58,500
is that for for that STM bored people

00:28:56,370 --> 00:29:00,780
have already created the relevant

00:28:58,500 --> 00:29:02,730
conflicts and driver support them in

00:29:00,780 --> 00:29:05,760
order to flash it from or open to the

00:29:02,730 --> 00:29:06,970
distribution by a tool and here I'm

00:29:05,760 --> 00:29:10,690
still working on

00:29:06,970 --> 00:29:13,000
the flash driver now if things have gone

00:29:10,690 --> 00:29:17,020
really wrong beach with microcontrollers

00:29:13,000 --> 00:29:20,580
or with servers or other boards there is

00:29:17,020 --> 00:29:23,650
way to actually get things into a

00:29:20,580 --> 00:29:25,840
working state again so many boards have

00:29:23,650 --> 00:29:28,990
connectors like like these there is even

00:29:25,840 --> 00:29:31,270
many more variations of these jtech

00:29:28,990 --> 00:29:33,880
stands for a joint test action group and

00:29:31,270 --> 00:29:39,880
is a standard of how you can interface

00:29:33,880 --> 00:29:43,600
with chips or flash chips on the on

00:29:39,880 --> 00:29:46,179
boards there's also some use be based

00:29:43,600 --> 00:29:48,130
standards so these yenza stab that

00:29:46,179 --> 00:29:50,230
you're seeing down here is pretty much

00:29:48,130 --> 00:29:52,270
what the embed boards are using that

00:29:50,230 --> 00:29:58,900
Andrew is going to talk about in the

00:29:52,270 --> 00:30:01,600
afternoon and before I put up the slide

00:29:58,900 --> 00:30:04,030
about the software remember this is

00:30:01,600 --> 00:30:06,909
really about hardware so this is not all

00:30:04,030 --> 00:30:11,080
binary it means that some of those pins

00:30:06,909 --> 00:30:14,500
might be a 1.8 volt others might be 3.3

00:30:11,080 --> 00:30:16,390
5 volt or whatever so not all adapters

00:30:14,500 --> 00:30:18,640
can work with all voltages be aware of

00:30:16,390 --> 00:30:22,200
that there might be you know garbage and

00:30:18,640 --> 00:30:25,090
being read if if they don't match and

00:30:22,200 --> 00:30:26,980
just because it looks the same doesn't

00:30:25,090 --> 00:30:29,409
mean that it actually is the same so

00:30:26,980 --> 00:30:33,010
there's like sellings and and mary are

00:30:29,409 --> 00:30:36,130
using the same pin out but like a mirror

00:30:33,010 --> 00:30:40,480
image of the actual usage of the pins

00:30:36,130 --> 00:30:43,360
and that can vary as well and one handy

00:30:40,480 --> 00:30:45,760
a thing to know is that when you're not

00:30:43,360 --> 00:30:49,090
feeling like actually wiring the the

00:30:45,760 --> 00:30:51,460
particular wires yourself from from one

00:30:49,090 --> 00:30:53,350
adapter to to the actual board and

00:30:51,460 --> 00:30:55,990
there's lots of adapters like these so

00:30:53,350 --> 00:30:58,090
this is the 20 pin configuration going

00:30:55,990 --> 00:31:02,490
from this from the half-size inch to the

00:30:58,090 --> 00:31:06,070
full-size inch variation of one size or

00:31:02,490 --> 00:31:07,480
from this is 1m use the interface

00:31:06,070 --> 00:31:12,730
adapter they don't have to be really

00:31:07,480 --> 00:31:15,760
huge so you can go from about 50 euro to

00:31:12,730 --> 00:31:16,790
like probably 4,000 if you go for Lauda

00:31:15,760 --> 00:31:24,500
ba

00:31:16,790 --> 00:31:26,450
so the the software if we're not

00:31:24,500 --> 00:31:29,480
thinking about those professional

00:31:26,450 --> 00:31:31,400
devices of choice would be open OCD

00:31:29,480 --> 00:31:36,220
that's been gaining a lot of traction

00:31:31,400 --> 00:31:39,020
lately we have the 080 package new in 13

00:31:36,220 --> 00:31:42,380
2090 see one was submitted shortly

00:31:39,020 --> 00:31:44,120
before the the conference I've seen some

00:31:42,380 --> 00:31:47,210
warning and error messages actually

00:31:44,120 --> 00:31:49,670
flashing the this board again but it's

00:31:47,210 --> 00:31:51,740
actually still working so if anyone I'm

00:31:49,670 --> 00:31:55,580
has such adapters please try it out and

00:31:51,740 --> 00:31:59,060
report any regressions you have it is

00:31:55,580 --> 00:32:02,570
possible to add support for new boards

00:31:59,060 --> 00:32:08,270
at runtime as a simple script file text

00:32:02,570 --> 00:32:10,730
file i'm using TCL and as far as new USB

00:32:08,270 --> 00:32:14,510
adapters go if it's not ftdi trip based

00:32:10,730 --> 00:32:18,470
and then it needs a driver written in c

00:32:14,510 --> 00:32:22,850
same for internal flash memories used on

00:32:18,470 --> 00:32:25,850
the chip I believe I'm pretty much over

00:32:22,850 --> 00:32:28,520
time so any questions I think we'll have

00:32:25,850 --> 00:32:31,520
to delay to outside of this room thank

00:32:28,520 --> 00:32:34,340
you much for for your attention and if

00:32:31,520 --> 00:32:36,650
you want to get in touch with the people

00:32:34,340 --> 00:32:38,380
working on arm these are the IRC channel

00:32:36,650 --> 00:32:41,630
and the maleness dedicated to these

00:32:38,380 --> 00:32:47,110
efforts and the portal from which you

00:32:41,630 --> 00:32:47,110

YouTube URL: https://www.youtube.com/watch?v=-nPNjqlQ4HM


