Title: Andreas Färber: Getting Geeko some cross-compilers
Publication date: 2016-06-26
Playlist: openSUSE Conference 2016
Description: 
	https://media.ccc.de/v/918-getting-geeko-some-cross-compilers

openSUSE relies on native compilation today, resorting to QEMU linux-user emulation for non-native build targets. Here's a brief update of where we are with building real cross-compilers, including for non-Linux targets such as microcontrollers, from our SUSE-maintained GCC packages.

Andreas Färber
Captions: 
	00:00:07,550 --> 00:00:14,300
then it start my name is aunt gasps Baba

00:00:11,180 --> 00:00:17,660
still and next I'm going to talk about

00:00:14,300 --> 00:00:21,170
cross compilers for open to the

00:00:17,660 --> 00:00:22,580
tumbleweed and the current and status of

00:00:21,170 --> 00:00:24,410
that since in particular there's been

00:00:22,580 --> 00:00:27,710
recent developments here and this is

00:00:24,410 --> 00:00:31,669
intended as a very quick lightning talk

00:00:27,710 --> 00:00:34,970
only the GCC packages that we use for

00:00:31,669 --> 00:00:37,399
for the open to the distribution in

00:00:34,970 --> 00:00:40,430
particular in that context native builds

00:00:37,399 --> 00:00:43,820
are being developed in de Velde CC

00:00:40,430 --> 00:00:47,449
project by the two train team from from

00:00:43,820 --> 00:00:50,870
azusa mainly and then there's also some

00:00:47,449 --> 00:00:52,609
cross compilers in a specific cross to

00:00:50,870 --> 00:00:55,429
train repository there's a several of

00:00:52,609 --> 00:00:59,679
them like if you are recently someone

00:00:55,429 --> 00:01:05,570
started working on extends ax there's

00:00:59,679 --> 00:01:09,170
msp430 and some are the one that I can't

00:01:05,570 --> 00:01:12,430
think of right now at some point hack

00:01:09,170 --> 00:01:16,840
week 10 a colleague of mine Richard bina

00:01:12,430 --> 00:01:19,820
looked into building cross compilers for

00:01:16,840 --> 00:01:22,100
the opensuse distribution so not just

00:01:19,820 --> 00:01:23,870
that are available on the open to the

00:01:22,100 --> 00:01:25,280
distribution but for the architectures

00:01:23,870 --> 00:01:32,720
that opens use the user so that means

00:01:25,280 --> 00:01:37,070
for x86 PowerPC arm maybe also extra 90

00:01:32,720 --> 00:01:39,440
and those packages were reusing the g

00:01:37,070 --> 00:01:42,770
lipsy that was being already been built

00:01:39,440 --> 00:01:45,440
on the native workers via aggregation

00:01:42,770 --> 00:01:48,680
and what i have now been looking into is

00:01:45,440 --> 00:01:51,910
building pure cost compilers and that do

00:01:48,680 --> 00:01:55,310
not require to have an open souza

00:01:51,910 --> 00:02:00,890
already building natively such as in the

00:01:55,310 --> 00:02:04,430
previous presentation for mips also the

00:02:00,890 --> 00:02:06,890
one that originally inspired me to look

00:02:04,430 --> 00:02:09,349
into this was one of the arm boards that

00:02:06,890 --> 00:02:12,560
i was enabling and both for opensuse an

00:02:09,349 --> 00:02:15,770
upstream and they am the parallel upward

00:02:12,560 --> 00:02:19,160
not just has a dual core arm processor

00:02:15,770 --> 00:02:21,050
on it it's also got an fpga logical

00:02:19,160 --> 00:02:24,500
sorry a programmable logic

00:02:21,050 --> 00:02:27,680
which then is used to connect to the arm

00:02:24,500 --> 00:02:30,500
cores and epiphany coprocessor from

00:02:27,680 --> 00:02:35,180
adept Eva and this was being used kind

00:02:30,500 --> 00:02:39,500
of as a very low memory and mesh and

00:02:35,180 --> 00:02:41,990
computing type of yeah mostly maybe

00:02:39,500 --> 00:02:47,390
mathematical coprocessor for speeding up

00:02:41,990 --> 00:02:50,480
certain and calculations and of course

00:02:47,390 --> 00:02:53,450
you can for for many things you can

00:02:50,480 --> 00:02:56,270
download costs compilers from external

00:02:53,450 --> 00:02:58,240
websites be it in source code form with

00:02:56,270 --> 00:03:00,950
you know like scripts how to do that or

00:02:58,240 --> 00:03:03,950
binary like for instance you can get an

00:03:00,950 --> 00:03:06,680
arm cross compiler toolchains either

00:03:03,950 --> 00:03:10,130
from linaro or from some our launch pad

00:03:06,680 --> 00:03:14,450
side sometimes you will also be a

00:03:10,130 --> 00:03:17,240
reference to some what's called a source

00:03:14,450 --> 00:03:19,460
code sorcery and two trains that are

00:03:17,240 --> 00:03:21,710
available or in this case there were

00:03:19,460 --> 00:03:23,630
some being provided by by a Nutella

00:03:21,710 --> 00:03:26,000
pooped ever themselves but I was

00:03:23,630 --> 00:03:28,160
interested in having not just a binary

00:03:26,000 --> 00:03:29,870
download that I put onto my hard disk

00:03:28,160 --> 00:03:31,820
and that then bit Rudd's don't guess it

00:03:29,870 --> 00:03:35,290
doesn't get any updates but having a

00:03:31,820 --> 00:03:38,239
cross compiler to train that actually

00:03:35,290 --> 00:03:40,130
can draw from our package updating

00:03:38,239 --> 00:03:41,989
processes in being you know I'm

00:03:40,130 --> 00:03:45,410
something that I can just zip it up and

00:03:41,989 --> 00:03:48,440
have a newer version for latest fixes so

00:03:45,410 --> 00:03:51,590
how does if we're looking at this

00:03:48,440 --> 00:03:53,510
particular case oh I'm very sorry you

00:03:51,590 --> 00:03:55,160
should have seen the slide and for some

00:03:53,510 --> 00:03:59,959
reason this is never working the first

00:03:55,160 --> 00:04:07,090
time this is what I was talking about

00:03:59,959 --> 00:04:16,489
here now you see it very sorry for that

00:04:07,090 --> 00:04:19,820
so so in this particular case there is

00:04:16,489 --> 00:04:22,310
no linux running on this trip it's just

00:04:19,820 --> 00:04:24,140
code that the users would write

00:04:22,310 --> 00:04:26,230
themselves or that they would download

00:04:24,140 --> 00:04:28,760
from somewhere and then deploy to this

00:04:26,230 --> 00:04:31,250
chip for for doing particular em

00:04:28,760 --> 00:04:32,750
calculations offering like an API for

00:04:31,250 --> 00:04:36,170
those operations

00:04:32,750 --> 00:04:38,060
and as such they are not using the g

00:04:36,170 --> 00:04:42,470
Lipsky that we are using but new lip and

00:04:38,060 --> 00:04:44,900
so far we did not have new lip support

00:04:42,470 --> 00:04:48,370
in our GCC cost and our GCC compiler

00:04:44,900 --> 00:04:52,370
packages and I set out to change that

00:04:48,370 --> 00:04:56,030
what does this look like Tiger tries we

00:04:52,370 --> 00:04:59,840
would have a cross epiphany binutils

00:04:56,030 --> 00:05:02,870
package which contains the assembler and

00:04:59,840 --> 00:05:04,910
various tools that's kind of the easiest

00:05:02,870 --> 00:05:09,200
part pretty much anyone can just branch

00:05:04,910 --> 00:05:12,860
the binutils package define a new name

00:05:09,200 --> 00:05:15,530
maybe have some a bit of if if logic

00:05:12,860 --> 00:05:17,660
inside the inside the spec file and then

00:05:15,530 --> 00:05:19,970
usually if it's in the option menu test

00:05:17,660 --> 00:05:21,950
package it will just build and be

00:05:19,970 --> 00:05:26,380
available but well who wants to write

00:05:21,950 --> 00:05:28,910
assembler code all day these days now

00:05:26,380 --> 00:05:32,420
usually you would just use the vineyard

00:05:28,910 --> 00:05:35,210
hills package build your C library from

00:05:32,420 --> 00:05:39,770
there and then use the Builder build a

00:05:35,210 --> 00:05:44,710
compiler package but in this case what I

00:05:39,770 --> 00:05:47,960
was doing is I was inserting a special

00:05:44,710 --> 00:05:51,050
bootstrap stage that is this variable

00:05:47,960 --> 00:05:54,610
name here GCC lipsy bootstrap whenever

00:05:51,050 --> 00:05:58,460
this is set it means that not the full

00:05:54,610 --> 00:06:01,550
GCC is being built but only the host

00:05:58,460 --> 00:06:05,360
parts of GCC so ccc-come consists of

00:06:01,550 --> 00:06:10,520
like the and the GCC binary but it also

00:06:05,360 --> 00:06:12,800
comes with things like lib GCC and some

00:06:10,520 --> 00:06:14,840
other things that are being built for

00:06:12,800 --> 00:06:18,320
the target system and that in turn

00:06:14,840 --> 00:06:22,490
depend on having AC library as tenancy

00:06:18,320 --> 00:06:25,970
library available then with the host

00:06:22,490 --> 00:06:27,320
only compiler which by the way when you

00:06:25,970 --> 00:06:29,420
would build that just on your local

00:06:27,320 --> 00:06:31,160
machine you can just switch directories

00:06:29,420 --> 00:06:35,410
and then continue the build where you

00:06:31,160 --> 00:06:39,640
left here in the build service I added a

00:06:35,410 --> 00:06:43,439
separate package that I simply gave this

00:06:39,640 --> 00:06:46,360
suffix dash bootstrap

00:06:43,439 --> 00:06:50,740
this could then be used as the build

00:06:46,360 --> 00:06:54,219
dependency of a cross dash epiphany new

00:06:50,740 --> 00:06:57,879
lip devel package for building the new

00:06:54,219 --> 00:07:00,460
lip library and then once we have the

00:06:57,879 --> 00:07:02,500
new lip library built and packaged we

00:07:00,460 --> 00:07:06,219
can use that as build dependency again

00:07:02,500 --> 00:07:10,270
in case that the GCC lipsy bootstrap is

00:07:06,219 --> 00:07:14,789
not set and to build both the host and

00:07:10,270 --> 00:07:14,789
the target parts of the cross compiler

00:07:15,509 --> 00:07:25,539
since or okay so i'm originally i tried

00:07:22,330 --> 00:07:27,940
that for the following toolchains not

00:07:25,539 --> 00:07:31,270
just epiphany but i also try this for

00:07:27,940 --> 00:07:34,210
the renaissance rrx and the RL 78

00:07:31,270 --> 00:07:38,440
architectures originally i was using GCC

00:07:34,210 --> 00:07:41,529
49 then i switched over to GCC 5 and

00:07:38,440 --> 00:07:45,129
most recently with some help from from

00:07:41,529 --> 00:07:47,620
andis corporation i also tried a nds 32

00:07:45,129 --> 00:07:51,729
l he billed as the first one with the

00:07:47,620 --> 00:07:53,229
GCC 6 also there are a number of cross

00:07:51,729 --> 00:07:56,110
compiler tool chains which are not yet

00:07:53,229 --> 00:07:58,839
entirely upstream accepted in both when

00:07:56,110 --> 00:08:02,800
you tilt and an GCC and one of those is

00:07:58,839 --> 00:08:04,479
the new pro tool chain for the don't

00:08:02,800 --> 00:08:07,860
have one here unfortunately for the the

00:08:04,479 --> 00:08:10,240
BeagleBone black and that's like a also

00:08:07,860 --> 00:08:12,069
microcontroller for like real-time

00:08:10,240 --> 00:08:16,300
network processing and things on there

00:08:12,069 --> 00:08:18,729
that with appropriate linux kernel

00:08:16,300 --> 00:08:21,909
drivers can have some code loaded too

00:08:18,729 --> 00:08:24,669
and then use that for for whatever

00:08:21,909 --> 00:08:27,009
processing you want in that case i

00:08:24,669 --> 00:08:32,469
simply branch the packages as a proof of

00:08:27,009 --> 00:08:34,209
concept taking the the particular im git

00:08:32,469 --> 00:08:36,339
commit that the patches were based upon

00:08:34,209 --> 00:08:39,000
using that as a terrible instead of the

00:08:36,339 --> 00:08:41,560
one that we were usually packaging and

00:08:39,000 --> 00:08:42,969
indeed i'll GCC and putting those

00:08:41,560 --> 00:08:44,649
patches on top just to build that i

00:08:42,969 --> 00:08:46,810
think at the moment is broken but it

00:08:44,649 --> 00:08:48,279
should be relatively easily to you and

00:08:46,810 --> 00:08:50,350
get back to work again i think it was a

00:08:48,279 --> 00:08:56,590
new lip update that i did that

00:08:50,350 --> 00:08:59,410
broke some things there may be one or

00:08:56,590 --> 00:09:02,920
two weeks ago the Nuala package got

00:08:59,410 --> 00:09:05,620
accepted into into tumbleweed for now

00:09:02,920 --> 00:09:08,850
this is just a very basic package it's

00:09:05,620 --> 00:09:12,070
only the sources to actually use for

00:09:08,850 --> 00:09:17,260
building or deriving cross and compelled

00:09:12,070 --> 00:09:20,920
versions of you lib from the in theory

00:09:17,260 --> 00:09:23,440
it would be possible to build a 32-bit

00:09:20,920 --> 00:09:26,140
x86 shared version of new lib

00:09:23,440 --> 00:09:28,210
unfortunately I have failed to actually

00:09:26,140 --> 00:09:32,920
get that to build with the headers that

00:09:28,210 --> 00:09:34,900
we were using for for opensuse if anyone

00:09:32,920 --> 00:09:37,510
knows more about that particular topic

00:09:34,900 --> 00:09:41,440
they are very welcome to make that work

00:09:37,510 --> 00:09:43,300
as as a proof of concept but for now and

00:09:41,440 --> 00:09:46,360
the main point of that package is to

00:09:43,300 --> 00:09:53,380
have it as a starting point for having

00:09:46,360 --> 00:09:58,660
em linked spec files the GCC 5 package

00:09:53,380 --> 00:10:03,810
has successively been enhanced to have

00:09:58,660 --> 00:10:06,460
the necessary ifs for the the

00:10:03,810 --> 00:10:07,690
dependencies and conditionals for which

00:10:06,460 --> 00:10:13,300
parts are going to be built and

00:10:07,690 --> 00:10:16,510
installed Jesus c6 seem to be missing a

00:10:13,300 --> 00:10:18,520
few of the preparations that we had

00:10:16,510 --> 00:10:20,230
gotten into the GCC 5 packet that was in

00:10:18,520 --> 00:10:22,300
particular for which architectures to

00:10:20,230 --> 00:10:25,300
actually go into the the Mueller path

00:10:22,300 --> 00:10:29,590
but that's fairly minor and the that

00:10:25,300 --> 00:10:31,870
underscore build actually succeeded once

00:10:29,590 --> 00:10:35,200
i got those in so i'm hoping that things

00:10:31,870 --> 00:10:38,860
are ok there one thing to watch out is

00:10:35,200 --> 00:10:43,150
that just because something built does

00:10:38,860 --> 00:10:48,520
not mean that it works so it might be

00:10:43,150 --> 00:10:51,700
that some binary is our packaging the

00:10:48,520 --> 00:10:54,010
wrong location and this will only then

00:10:51,700 --> 00:10:58,019
be noticed once we actually have a

00:10:54,010 --> 00:11:00,629
package or a local test script that

00:10:58,019 --> 00:11:03,899
is using the compiler to compile a

00:11:00,629 --> 00:11:06,179
particular see file with certain include

00:11:03,899 --> 00:11:13,920
dependencies or something to to trigger

00:11:06,179 --> 00:11:16,769
the failure what's next for now it would

00:11:13,920 --> 00:11:18,809
be very nice if we could get some of the

00:11:16,769 --> 00:11:22,019
stuff not necessarily all of what I've

00:11:18,809 --> 00:11:24,779
been playing with into the official dbl

00:11:22,019 --> 00:11:29,279
jesusí repository as next step so

00:11:24,779 --> 00:11:31,259
basically use the base system and uhlet

00:11:29,279 --> 00:11:34,589
package and link it in 2d belches you

00:11:31,259 --> 00:11:36,329
see with appropriate either as new lip

00:11:34,589 --> 00:11:39,600
or directly as a cross compiled version

00:11:36,329 --> 00:11:42,809
and add the necessary architectures to

00:11:39,600 --> 00:11:44,610
the pre checkin script to to have new

00:11:42,809 --> 00:11:47,009
lip libraries for particular

00:11:44,610 --> 00:11:50,459
architectures I believe we already have

00:11:47,009 --> 00:11:58,350
been utils available for for epiphany

00:11:50,459 --> 00:12:00,299
for instance and then also beyond new

00:11:58,350 --> 00:12:01,889
lip of course that's not the only way

00:12:00,299 --> 00:12:06,839
that cost compilers can be built there

00:12:01,889 --> 00:12:09,569
is both you see lipsy I have an or at

00:12:06,839 --> 00:12:12,589
least I used to have a cross compiler

00:12:09,569 --> 00:12:16,439
tool chain in houma farber you see Linux

00:12:12,589 --> 00:12:19,170
that was using you see lipsy for a new

00:12:16,439 --> 00:12:21,949
mm you arm built what was formerly known

00:12:19,170 --> 00:12:24,959
as you see Linux or music Linux Roy and

00:12:21,949 --> 00:12:29,040
also i've been using a very similar

00:12:24,959 --> 00:12:30,569
concept for the Gypsy based open through

00:12:29,040 --> 00:12:38,339
the web sport that I was talking about

00:12:30,569 --> 00:12:41,639
earlier the question here is in theory

00:12:38,339 --> 00:12:44,959
we could go along and check which

00:12:41,639 --> 00:12:49,619
architectures are actually available in

00:12:44,959 --> 00:12:52,079
binutils which ones are available in GCC

00:12:49,619 --> 00:12:54,600
and simply them enable all of them

00:12:52,079 --> 00:12:56,519
however since GCC is a very core

00:12:54,600 --> 00:13:00,509
component of our architecture the more

00:12:56,519 --> 00:13:02,579
stuff that we don't need we enable the

00:13:00,509 --> 00:13:05,369
more likely the risk for for breakage

00:13:02,579 --> 00:13:08,100
that would interfere with submissions to

00:13:05,369 --> 00:13:10,420
two factories so we'll have to have a

00:13:08,100 --> 00:13:14,769
discussion about what the same said

00:13:10,420 --> 00:13:19,120
of of targets is and for instance since

00:13:14,769 --> 00:13:24,820
I mean opensuse we do not have tools to

00:13:19,120 --> 00:13:26,589
actually transfer our l78 binaries to

00:13:24,820 --> 00:13:28,990
some micro controller board for me that

00:13:26,589 --> 00:13:31,779
would be the first candidate not to put

00:13:28,990 --> 00:13:35,220
into md valdez you see initially whereas

00:13:31,779 --> 00:13:37,690
for the RX architecture there's like the

00:13:35,220 --> 00:13:39,990
secure aboard that's a small micro

00:13:37,690 --> 00:13:42,730
controller board in a very pink color

00:13:39,990 --> 00:13:45,639
that you can simply can connect to your

00:13:42,730 --> 00:13:48,820
pc as a USB mass storage device copy the

00:13:45,639 --> 00:13:52,690
file onto there and then run it revilla

00:13:48,820 --> 00:13:54,339
pressing a button or not even that so

00:13:52,690 --> 00:13:56,500
it's relatively easy to actually use

00:13:54,339 --> 00:13:59,199
from our Linux systems so I guess that

00:13:56,500 --> 00:14:05,050
would be one of the candidates for for

00:13:59,199 --> 00:14:06,790
actually having in there and one topic

00:14:05,050 --> 00:14:09,130
that I have not yet looked into myself

00:14:06,790 --> 00:14:11,260
is that there's obviously not only the

00:14:09,130 --> 00:14:14,589
compiler to compile code but once you

00:14:11,260 --> 00:14:16,209
actually have code compiled and deploy

00:14:14,589 --> 00:14:17,949
to some target or running under

00:14:16,209 --> 00:14:21,730
emulations then you might actually want

00:14:17,949 --> 00:14:24,279
to debug it so i do not have i have not

00:14:21,730 --> 00:14:28,060
yet looked into having cross versions of

00:14:24,279 --> 00:14:29,380
gdp built at the moment if anyone is

00:14:28,060 --> 00:14:31,899
interested or has looked into that

00:14:29,380 --> 00:14:35,560
before that might also be interesting to

00:14:31,899 --> 00:14:39,190
attendees now as a final slide i have a

00:14:35,560 --> 00:14:43,720
brief overview if you remember this

00:14:39,190 --> 00:14:52,740
slide here sorry here then we were

00:14:43,720 --> 00:14:56,170
seeing that obviously we have here it is

00:14:52,740 --> 00:14:58,180
we have the the bin utils as the base

00:14:56,170 --> 00:15:01,029
tools that we need for for building any

00:14:58,180 --> 00:15:04,480
and target code and then we had a

00:15:01,029 --> 00:15:08,199
bootstrap package and then the full

00:15:04,480 --> 00:15:11,260
package with them the library package in

00:15:08,199 --> 00:15:13,329
between and if we compare that to to

00:15:11,260 --> 00:15:15,620
juleps you get slightly more complicated

00:15:13,329 --> 00:15:17,750
so as a first step

00:15:15,620 --> 00:15:24,230
we need to package the Linux kernel

00:15:17,750 --> 00:15:30,170
heteros then for building g lipsy we

00:15:24,230 --> 00:15:34,010
need a just the same as beef sorry just

00:15:30,170 --> 00:15:37,310
the same as before we need a bootstrap

00:15:34,010 --> 00:15:44,230
variant of the GCC compiler in order to

00:15:37,310 --> 00:15:48,800
next build g lipsy then a julep CDL

00:15:44,230 --> 00:15:54,380
bootstrap package which then builds the

00:15:48,800 --> 00:16:02,120
or packages the Gypsy headers and an

00:15:54,380 --> 00:16:05,930
interim version of lipsy and that one we

00:16:02,120 --> 00:16:10,100
can then use in a second intermediate

00:16:05,930 --> 00:16:14,690
GCC built for actually building the lips

00:16:10,100 --> 00:16:16,880
GCC with this interim julep see and then

00:16:14,690 --> 00:16:19,330
which is kind of you know just a subset

00:16:16,880 --> 00:16:22,670
of binaries that are there to to please

00:16:19,330 --> 00:16:25,490
the build system and then we can

00:16:22,670 --> 00:16:28,100
actually once we've built lib GCC as

00:16:25,490 --> 00:16:30,920
part of this mini GC c 5 which cannot

00:16:28,100 --> 00:16:34,130
yet build built much more we then build

00:16:30,920 --> 00:16:36,589
the final version of G lipsy and once we

00:16:34,130 --> 00:16:39,220
have G lipsy finally build that we can

00:16:36,589 --> 00:16:42,650
then build the final GCC cross compiler

00:16:39,220 --> 00:16:47,240
you will note that i'm using GC 5 here

00:16:42,650 --> 00:16:49,339
that's simply because in the OBS server

00:16:47,240 --> 00:16:55,730
that I've been using for mips i still

00:16:49,339 --> 00:16:58,339
had this based on GCC 5 & 4 MGCCC 6 we

00:16:55,730 --> 00:17:02,209
may need to be doing a few additional

00:16:58,339 --> 00:17:03,950
ifs there and in particular one if you

00:17:02,209 --> 00:17:09,860
to keep in mind that when building those

00:17:03,950 --> 00:17:12,709
costs compilers is that we sometimes

00:17:09,860 --> 00:17:16,400
have a choice or kind of a conflict

00:17:12,709 --> 00:17:20,360
between installing em target files into

00:17:16,400 --> 00:17:23,420
the suits route which is the US are and

00:17:20,360 --> 00:17:25,460
then the triple name / this route for us

00:17:23,420 --> 00:17:30,050
or installing it into the root

00:17:25,460 --> 00:17:34,160
filesystem so we've kind of a think

00:17:30,050 --> 00:17:41,120
taken a quite hacky intermediate

00:17:34,160 --> 00:17:42,860
approach where we are installing target

00:17:41,120 --> 00:17:45,710
binaries into the zeus route where we

00:17:42,860 --> 00:17:49,360
definitely need them for forum for using

00:17:45,710 --> 00:17:53,780
them for for for cross builds but also

00:17:49,360 --> 00:17:57,650
having some things like the lip standard

00:17:53,780 --> 00:18:00,860
C++ headers be reused from the native

00:17:57,650 --> 00:18:05,570
GCC five package which means that we

00:18:00,860 --> 00:18:08,690
cannot have the the cross GCC five

00:18:05,570 --> 00:18:13,280
package install the same host files as

00:18:08,690 --> 00:18:14,840
the cross package so we need to not just

00:18:13,280 --> 00:18:16,580
install them to a different location but

00:18:14,840 --> 00:18:19,040
where they need to also move some files

00:18:16,580 --> 00:18:20,420
around but not others and delete some

00:18:19,040 --> 00:18:22,700
other files in order to make this file

00:18:20,420 --> 00:18:26,150
so this is a little fiddly and was guess

00:18:22,700 --> 00:18:28,240
the main reason why this was for for

00:18:26,150 --> 00:18:32,570
quite a long time not yet really being

00:18:28,240 --> 00:18:35,390
attacked for you to lip see it works

00:18:32,570 --> 00:18:38,530
quite similar although I admit that the

00:18:35,390 --> 00:18:44,900
the the current status that I have in

00:18:38,530 --> 00:18:47,480
the in my home repository and the the

00:18:44,900 --> 00:18:50,540
user Linux repository is a quite hackish

00:18:47,480 --> 00:18:53,630
it was using a random set of colonel

00:18:50,540 --> 00:18:57,440
headers that I am actually generated on

00:18:53,630 --> 00:19:00,320
my local machine whereas in this case as

00:18:57,440 --> 00:19:03,980
indicated above here am i was using some

00:19:00,320 --> 00:19:06,530
a bit of micro magic and tools in order

00:19:03,980 --> 00:19:08,390
to just get that from the latest version

00:19:06,530 --> 00:19:10,820
of the kernel source package available

00:19:08,390 --> 00:19:14,270
in that repository so basically we're

00:19:10,820 --> 00:19:16,340
using the the host squirrel headers in

00:19:14,270 --> 00:19:19,040
order to generate the target headers

00:19:16,340 --> 00:19:23,690
whether that is a good idea is up for

00:19:19,040 --> 00:19:26,690
discussion which is the next point of

00:19:23,690 --> 00:19:32,060
topic right now any questions comments

00:19:26,690 --> 00:19:34,960
or suggestions to the right in the front

00:19:32,060 --> 00:19:34,960
a microphone please

00:19:57,250 --> 00:20:02,750
if you could recall slide number five

00:20:00,230 --> 00:20:07,400
for a second play if you could recall

00:20:02,750 --> 00:20:09,680
slide number five for a second please so

00:20:07,400 --> 00:20:11,180
I'm answering the question which of all

00:20:09,680 --> 00:20:13,310
the possible targets to use this one

00:20:11,180 --> 00:20:16,700
there's a shameless plug I want to put

00:20:13,310 --> 00:20:20,510
any hair ends in since about for at

00:20:16,700 --> 00:20:22,760
least two years critters sterba and me

00:20:20,510 --> 00:20:28,280
included we have been somewhat working

00:20:22,760 --> 00:20:30,800
on the window is target which is where I

00:20:28,280 --> 00:20:34,760
think you can drawn quite some

00:20:30,800 --> 00:20:38,840
inspiration for spec files and cross

00:20:34,760 --> 00:20:44,510
compiling with and without GFC so that's

00:20:38,840 --> 00:20:47,150
one of the things to bring here so i

00:20:44,510 --> 00:20:50,110
admit that i have been using that also

00:20:47,150 --> 00:20:53,000
for cross compiling some some packages

00:20:50,110 --> 00:20:55,160
my understanding was that yes it was

00:20:53,000 --> 00:20:59,960
like also most of the other stuff in

00:20:55,160 --> 00:21:02,870
cross compiler so a cross toolchain then

00:20:59,960 --> 00:21:06,800
it was using totally separate source

00:21:02,870 --> 00:21:10,220
code packages is that correct it uses it

00:21:06,800 --> 00:21:12,830
uses one so for example the GCC uses one

00:21:10,220 --> 00:21:15,260
build servers package which contains

00:21:12,830 --> 00:21:22,130
free spec falls for the three stages of

00:21:15,260 --> 00:21:24,650
GCC grief but it's separate GCC packages

00:21:22,130 --> 00:21:26,480
not the ones directly linked or reused

00:21:24,650 --> 00:21:29,060
from dee belches you see that was my

00:21:26,480 --> 00:21:31,670
question yes they are separate okay and

00:21:29,060 --> 00:21:35,890
this is why they also look radically in

00:21:31,670 --> 00:21:38,510
compared to all this is a JCC okay so

00:21:35,890 --> 00:21:41,030
you have one bootstrap step and that's

00:21:38,510 --> 00:21:44,510
sufficient for for windows now there are

00:21:41,030 --> 00:21:46,130
phrase phrase limbs twisters so in whole

00:21:44,510 --> 00:21:49,010
three or three intermediate and then a

00:21:46,130 --> 00:21:51,650
final just the way you okay so on the

00:21:49,010 --> 00:21:54,350
same way as you're okay yeah so this one

00:21:51,650 --> 00:21:59,890
yeah yeah I think the one with new live

00:21:54,350 --> 00:22:03,640
in fact well there's only two then

00:21:59,890 --> 00:22:06,470
there's the bootstrap and the full one

00:22:03,640 --> 00:22:08,380
yeah okay in for the for the for the

00:22:06,470 --> 00:22:10,690
windows target we use the full car

00:22:08,380 --> 00:22:12,640
compiler to build itself for the target

00:22:10,690 --> 00:22:16,570
architecture so that we get the lipstick

00:22:12,640 --> 00:22:19,330
C++ dll six because you don't get that

00:22:16,570 --> 00:22:22,300
from the cross compiler actually you can

00:22:19,330 --> 00:22:25,870
possibly i believe so so it's i think by

00:22:22,300 --> 00:22:29,560
default it's so there is a setting in

00:22:25,870 --> 00:22:31,900
the know i think for for GCC it's not in

00:22:29,560 --> 00:22:33,610
the pre tracking it's in changed back so

00:22:31,900 --> 00:22:38,260
i think there is a variable in the top

00:22:33,610 --> 00:22:41,710
which determines which languages are

00:22:38,260 --> 00:22:44,170
being built and 41 it not every

00:22:41,710 --> 00:22:46,090
architectural actually can build the c++

00:22:44,170 --> 00:22:48,580
compiler of course but obviously for for

00:22:46,090 --> 00:22:50,650
windows and x86 architecture that should

00:22:48,580 --> 00:22:52,180
not be the limiting factor about it it's

00:22:50,650 --> 00:22:55,540
probably just a setting that could be

00:22:52,180 --> 00:23:01,240
enabled so it might be possible to maybe

00:22:55,540 --> 00:23:03,160
much to do them but I since i'm not a

00:23:01,240 --> 00:23:05,020
tool train developer myself and just you

00:23:03,160 --> 00:23:06,970
know a random contributor kind of I

00:23:05,020 --> 00:23:09,460
can't make any promises as to what

00:23:06,970 --> 00:23:12,880
actually gets accepted into de Velde CC

00:23:09,460 --> 00:23:15,160
and I did not spot rich c or Matthias

00:23:12,880 --> 00:23:17,230
not surrounding one from Kershaw anyone

00:23:15,160 --> 00:23:22,960
else from the toolchain team here to

00:23:17,230 --> 00:23:29,620
actually comment on that further

00:23:22,960 --> 00:23:31,330
comments or questions ok ok so like a

00:23:29,620 --> 00:23:33,490
year and a half ago was also toying

00:23:31,330 --> 00:23:37,150
around with Chris papyrus for some arm

00:23:33,490 --> 00:23:39,790
and some ape sports I have and back then

00:23:37,150 --> 00:23:43,390
i tried cross tool ng to get the tool

00:23:39,790 --> 00:23:45,940
chain and it was quite a mess because

00:23:43,390 --> 00:23:48,520
you had to try different versions of all

00:23:45,940 --> 00:23:51,730
the components of the toolchain to get

00:23:48,520 --> 00:23:52,690
it to run is that still like that so do

00:23:51,730 --> 00:23:57,700
you still need to try different

00:23:52,690 --> 00:24:00,700
combinations and so yes by by nature of

00:23:57,700 --> 00:24:06,430
our OBS and our packaging guidelines or

00:24:00,700 --> 00:24:08,320
policies tools like cost tool and GE or

00:24:06,430 --> 00:24:11,430
that there's others like there I think

00:24:08,320 --> 00:24:11,430
you can also use something like

00:24:12,039 --> 00:24:16,700
now not busy box what's the same project

00:24:15,110 --> 00:24:18,260
to build rude I think you can also use

00:24:16,700 --> 00:24:19,909
build route to to build cross compiler

00:24:18,260 --> 00:24:23,990
two trains for for certain I'm

00:24:19,909 --> 00:24:26,000
architectures they all either assume

00:24:23,990 --> 00:24:27,770
that they have network connectivity to

00:24:26,000 --> 00:24:31,909
download packages from the internet or

00:24:27,770 --> 00:24:35,630
they specifically rely on having like

00:24:31,909 --> 00:24:40,279
the source code tar balls in specific

00:24:35,630 --> 00:24:43,460
locations and whatever I've seen for 4x

00:24:40,279 --> 00:24:46,610
tenza in in cross toolchain that simply

00:24:43,460 --> 00:24:48,169
violates the philosophy of the opens of

00:24:46,610 --> 00:24:50,510
the factory where you have one source

00:24:48,169 --> 00:24:54,620
code terrible per package and not you

00:24:50,510 --> 00:24:58,520
know like binutils GCC libraries and GCC

00:24:54,620 --> 00:25:01,149
and and whatnot all thrown into one one

00:24:58,520 --> 00:25:05,179
source package alongside the other tool

00:25:01,149 --> 00:25:06,830
thanks okay thank you I think we have to

00:25:05,179 --> 00:25:08,120
to cut off now we're already five mins

00:25:06,830 --> 00:25:10,159
over time thank you very much for your

00:25:08,120 --> 00:25:12,860
time and let's hope that we can find a

00:25:10,159 --> 00:25:16,840
way to get this working into a

00:25:12,860 --> 00:25:16,840

YouTube URL: https://www.youtube.com/watch?v=0SQjy6QoOcY


