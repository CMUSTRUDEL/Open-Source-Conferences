Title: Josef Reidinger: Config Files API
Publication date: 2016-06-26
Playlist: openSUSE Conference 2016
Description: 
	https://media.ccc.de/v/822-config-files-api

YaST has been trying to find a solution to work with configuration files in a way that is easy and reusable, while ensuring the consistency of the resulting configuration. The response is Config Files API (CFA), a generic framework to work with configuration files in Ruby. Although currently is only used in the yast2-bootloader module, CFA will become one of the key components of YaST in the near future. Its design and foundation look beyond YaST, making it a useful resource in any environment needing programatic and semantic management of configuration files.  The talk will provide an overall overview of CFA's architecture and down to earth examples on how CFA can be used and extended.

Josef Reidinger
Captions: 
	00:00:08,100 --> 00:00:19,770
great so welcome to presentation about

00:00:12,770 --> 00:00:23,960
cfa which means config files api its api

00:00:19,770 --> 00:00:27,530
that mainly used for some editing of

00:00:23,960 --> 00:00:33,210
configuration file by editing I mean

00:00:27,530 --> 00:00:36,180
fine small changes in this file that do

00:00:33,210 --> 00:00:40,260
not break existing stuff so it's not

00:00:36,180 --> 00:00:43,019
something like salt or CF engine or side

00:00:40,260 --> 00:00:47,129
stuff that owns whole file and modifies

00:00:43,019 --> 00:00:49,680
just deploy a new version its api for do

00:00:47,129 --> 00:00:51,690
small changes like expect for example

00:00:49,680 --> 00:00:54,479
from us that it doesn't breaks your

00:00:51,690 --> 00:01:02,940
existing stuff doesn't break your own

00:00:54,479 --> 00:01:07,440
comments and such stuff so what's the

00:01:02,940 --> 00:01:12,409
content i will explain why we create new

00:01:07,440 --> 00:01:17,250
API by old one doesn't is not enough

00:01:12,409 --> 00:01:20,280
then I explain design of this API how it

00:01:17,250 --> 00:01:25,070
works together and then I've caused

00:01:20,280 --> 00:01:28,229
shows some real time or real life

00:01:25,070 --> 00:01:31,049
examples of usage because on tumbleweed

00:01:28,229 --> 00:01:34,859
it's already used so I wish you show

00:01:31,049 --> 00:01:39,719
some code that's did you use in double

00:01:34,859 --> 00:01:43,770
root so why it's obvious reason to too

00:01:39,719 --> 00:01:48,090
many face pounds when you use our see

00:01:43,770 --> 00:01:50,130
old code that's that's if you're the

00:01:48,090 --> 00:01:54,600
biggest motivation if the old code works

00:01:50,130 --> 00:01:58,100
somehow and is you can somehow use it

00:01:54,600 --> 00:02:01,079
then you do it but if it start to be

00:01:58,100 --> 00:02:06,329
very annoying then you have motivation

00:02:01,079 --> 00:02:11,490
to do it better so currently I will

00:02:06,329 --> 00:02:14,580
mostly talk about just because just even

00:02:11,490 --> 00:02:18,230
now still use some some old API for this

00:02:14,580 --> 00:02:21,870
changes it's called ser

00:02:18,230 --> 00:02:27,930
I even don't know what it actually means

00:02:21,870 --> 00:02:30,239
it's very old acronym and what's

00:02:27,930 --> 00:02:32,430
currently problem it's not much very

00:02:30,239 --> 00:02:36,930
visible it's it can be used only in the

00:02:32,430 --> 00:02:40,709
ass and even if some projects have some

00:02:36,930 --> 00:02:43,260
motivation to use it in the end they

00:02:40,709 --> 00:02:46,200
just give up because it's too tied with

00:02:43,260 --> 00:02:49,859
a rest of you asked it requires a lot of

00:02:46,200 --> 00:02:52,859
reiber libraries for me asked also a

00:02:49,859 --> 00:02:56,400
last point is a reason that it is for

00:02:52,859 --> 00:02:59,250
communication of ICP which is now very

00:02:56,400 --> 00:03:01,319
legacy and almost dead language it's

00:02:59,250 --> 00:03:07,439
also monolithic so if you want to use

00:03:01,319 --> 00:03:11,280
just a part of it like its ability for

00:03:07,439 --> 00:03:13,349
parsing files and actually don't want to

00:03:11,280 --> 00:03:18,629
read it or write it from current system

00:03:13,349 --> 00:03:22,199
then with a problem also it's completely

00:03:18,629 --> 00:03:27,599
written by esteem and maintained by them

00:03:22,199 --> 00:03:29,970
so every piece is done in-house which is

00:03:27,599 --> 00:03:33,359
always not so good we would like to

00:03:29,970 --> 00:03:36,329
share our workflow and also share a

00:03:33,359 --> 00:03:40,169
maintenance of some parts with other

00:03:36,329 --> 00:03:45,449
instance interested teams yeah its API

00:03:40,169 --> 00:03:49,650
is very strange and it's rated that it

00:03:45,449 --> 00:03:52,680
its API is confusing and we see it again

00:03:49,650 --> 00:03:57,780
and again in asked when someone new

00:03:52,680 --> 00:04:00,479
comes to the team the SCR is the most

00:03:57,780 --> 00:04:03,599
scary part of rust it's hard to explain

00:04:00,479 --> 00:04:06,870
it for newcomers it's hard to use it for

00:04:03,599 --> 00:04:09,810
them a and it's quite hard to also

00:04:06,870 --> 00:04:12,750
explain how it works because it have a

00:04:09,810 --> 00:04:15,720
lot of abstractions that are not needed

00:04:12,750 --> 00:04:18,180
that makes sense fifteen years ago when

00:04:15,720 --> 00:04:20,699
when it started this project but now we

00:04:18,180 --> 00:04:22,229
no longer make make sense and it's hard

00:04:20,699 --> 00:04:28,680
to explain something that doesn't make

00:04:22,229 --> 00:04:31,030
sense to anyone so what's a requirement

00:04:28,680 --> 00:04:35,470
for a new API that

00:04:31,030 --> 00:04:38,050
we hope will be replaced as CR and will

00:04:35,470 --> 00:04:41,080
be easier to use so of course the first

00:04:38,050 --> 00:04:43,090
stuff is easy to use if you have

00:04:41,080 --> 00:04:47,170
something that's hard to use no one will

00:04:43,090 --> 00:04:50,620
use it or try to find some shortcuts how

00:04:47,170 --> 00:04:55,300
to avoid a complex stuff it had to be

00:04:50,620 --> 00:04:58,350
also modular that if in future something

00:04:55,300 --> 00:05:00,940
useful appear in open source community

00:04:58,350 --> 00:05:03,100
we would like to replace for example

00:05:00,940 --> 00:05:06,430
some stuff that doesn't work well with

00:05:03,100 --> 00:05:10,330
something that's already existing or

00:05:06,430 --> 00:05:12,460
will exist in future and works better so

00:05:10,330 --> 00:05:16,480
we have we would like to have

00:05:12,460 --> 00:05:20,530
replaceable parts and also we would like

00:05:16,480 --> 00:05:24,910
with our oven parts that can be used at

00:05:20,530 --> 00:05:27,850
other places so some modules written for

00:05:24,910 --> 00:05:35,740
cfa we would like to reuse elsewhere

00:05:27,850 --> 00:05:38,650
also yeah of course requirements now is

00:05:35,740 --> 00:05:41,740
easy to test because what's no test it

00:05:38,650 --> 00:05:43,240
is usually broken and of course it

00:05:41,740 --> 00:05:45,100
doesn't mean that if you have one

00:05:43,240 --> 00:05:50,350
hundred percent test coverage that it's

00:05:45,100 --> 00:05:53,800
not broken but there's a very small

00:05:50,350 --> 00:05:56,080
chance it really decrease the number of

00:05:53,800 --> 00:05:59,590
bucks of course it should be

00:05:56,080 --> 00:06:02,740
object-oriented because ser is from ycp

00:05:59,590 --> 00:06:04,420
time so it's functional based but we

00:06:02,740 --> 00:06:07,390
would like to use object because

00:06:04,420 --> 00:06:11,800
currently as days in a row B so we would

00:06:07,390 --> 00:06:13,840
like object API and of course the most

00:06:11,800 --> 00:06:17,110
important palette is friendly to

00:06:13,840 --> 00:06:20,020
newcomers so if someone would like to

00:06:17,110 --> 00:06:23,440
start with you asked or would like to

00:06:20,020 --> 00:06:26,890
contribute to us then don't have a

00:06:23,440 --> 00:06:32,520
strange part in its code which is hard

00:06:26,890 --> 00:06:36,910
to understand so now let's look on

00:06:32,520 --> 00:06:41,170
design of cfa it basically have three

00:06:36,910 --> 00:06:43,720
components the basic one is sorry the

00:06:41,170 --> 00:06:46,200
writer they'd have a single

00:06:43,720 --> 00:06:46,200
responsibility

00:06:47,080 --> 00:06:58,660
translate string to some target the

00:06:53,600 --> 00:07:02,150
storage or string or whatever it is just

00:06:58,660 --> 00:07:07,130
right string or read that string from

00:07:02,150 --> 00:07:09,500
target then you have parser user so you

00:07:07,130 --> 00:07:14,780
can this string is then somehow

00:07:09,500 --> 00:07:17,720
interpret to some some tree or visa

00:07:14,780 --> 00:07:19,880
versa you have modified tree and want to

00:07:17,720 --> 00:07:24,440
translate to the back to string that can

00:07:19,880 --> 00:07:29,270
be read or write and then there is a

00:07:24,440 --> 00:07:34,700
model which is something like high level

00:07:29,270 --> 00:07:39,010
API for given configuration file usually

00:07:34,700 --> 00:07:41,930
model have some actions for it some

00:07:39,010 --> 00:07:45,710
operations and that operations work on a

00:07:41,930 --> 00:07:49,220
past three and that small line between

00:07:45,710 --> 00:07:52,940
reader and model is a dependency

00:07:49,220 --> 00:07:56,030
injection so what basically user use is

00:07:52,940 --> 00:07:59,690
they have model and then can pass

00:07:56,030 --> 00:08:04,520
different reader and writer so if you

00:07:59,690 --> 00:08:06,800
have for example file that's not on your

00:08:04,520 --> 00:08:10,520
system but somewhere over network you

00:08:06,800 --> 00:08:14,090
can write your own radio writer for the

00:08:10,520 --> 00:08:18,680
network file and pass it to model so in

00:08:14,090 --> 00:08:24,440
the end the stuff was read and write

00:08:18,680 --> 00:08:27,890
from this reader so now let me look

00:08:24,440 --> 00:08:33,530
closer to this as I said read the writer

00:08:27,890 --> 00:08:36,770
is very simple interface it allows read

00:08:33,530 --> 00:08:40,099
and write just two methods both methods

00:08:36,770 --> 00:08:44,450
get a path assets argument the path is

00:08:40,099 --> 00:08:47,060
selective to route so if you have if you

00:08:44,450 --> 00:08:50,150
want to read your for example grab to

00:08:47,060 --> 00:08:55,970
default file you just pass I won't read

00:08:50,150 --> 00:08:58,390
file that let's path is et Cie default

00:08:55,970 --> 00:08:58,390
graph

00:08:58,650 --> 00:09:06,550
it works only with plain strings so no

00:09:02,140 --> 00:09:09,070
formatting no no stripping off of this

00:09:06,550 --> 00:09:12,690
drink or any other operation it's really

00:09:09,070 --> 00:09:16,029
just get me string and examples we

00:09:12,690 --> 00:09:19,330
already have is a common file in Ruby

00:09:16,029 --> 00:09:21,370
which means we read from this path right

00:09:19,330 --> 00:09:24,190
to this path then we have memory file

00:09:21,370 --> 00:09:27,400
which is very useful for testing that

00:09:24,190 --> 00:09:29,740
string is hot only in memory and you

00:09:27,400 --> 00:09:31,570
construct it in code how file should

00:09:29,740 --> 00:09:34,810
look like and then work on it and then

00:09:31,570 --> 00:09:36,640
compare if infirmary looks after some

00:09:34,810 --> 00:09:40,210
modification as it should look like and

00:09:36,640 --> 00:09:43,029
then in last we create over also our

00:09:40,210 --> 00:09:45,310
oven specific that's not part of cfa a

00:09:43,029 --> 00:09:47,710
target file let's use during

00:09:45,310 --> 00:09:51,610
installation that they recognize if if

00:09:47,710 --> 00:09:56,400
you need to write to target system

00:09:51,610 --> 00:10:00,339
that's that's very very install stuff of

00:09:56,400 --> 00:10:03,880
course and if someone else needs his

00:10:00,339 --> 00:10:07,360
oven the writer for example reading

00:10:03,880 --> 00:10:09,280
writing over ssh then just create your

00:10:07,360 --> 00:10:14,350
own path that implements these two

00:10:09,280 --> 00:10:18,790
methods and it's enough the second part

00:10:14,350 --> 00:10:21,370
is parcel searles it it turns light

00:10:18,790 --> 00:10:25,240
between string and past three each three

00:10:21,370 --> 00:10:29,320
is partial specific I'm also considering

00:10:25,240 --> 00:10:33,130
create some generic part 3 but in the

00:10:29,320 --> 00:10:38,770
end I found it's too much abstraction it

00:10:33,130 --> 00:10:41,380
can lose some features of given parts so

00:10:38,770 --> 00:10:45,610
currently it's a specific parcel tree

00:10:41,380 --> 00:10:49,180
it's quite low level 3 for example in

00:10:45,610 --> 00:10:52,330
our gas it holds all commands it doesn't

00:10:49,180 --> 00:10:54,640
know any relations it just is positions

00:10:52,330 --> 00:11:00,160
and can recognize some some basic syntax

00:10:54,640 --> 00:11:02,580
and as I said examples is a gas which we

00:11:00,160 --> 00:11:07,450
use mainly for the parsing and

00:11:02,580 --> 00:11:10,150
sterilization and another possible on is

00:11:07,450 --> 00:11:12,610
line parser that

00:11:10,150 --> 00:11:18,040
for us simple config files that have

00:11:12,610 --> 00:11:20,860
each line 11 option so it's very very

00:11:18,040 --> 00:11:24,880
simple parser and of course you can use

00:11:20,860 --> 00:11:29,920
much more it's just currently used once

00:11:24,880 --> 00:11:32,380
and as you can see the hardest part

00:11:29,920 --> 00:11:35,050
which is passing we currently delegate

00:11:32,380 --> 00:11:38,470
to a gas it already have its own lenses

00:11:35,050 --> 00:11:42,640
that specify the syntax of trees and

00:11:38,470 --> 00:11:45,550
there's many available lenses so we

00:11:42,640 --> 00:11:51,130
don't spend time writing open parser for

00:11:45,550 --> 00:11:57,360
new files yeah and model is high level

00:11:51,130 --> 00:12:01,230
API it allows higher operations like

00:11:57,360 --> 00:12:06,880
enable something some operation or

00:12:01,230 --> 00:12:09,490
remove something it it's coupled with

00:12:06,880 --> 00:12:12,640
parson so it knows its parser and it's

00:12:09,490 --> 00:12:15,130
usually depend on it so there is no

00:12:12,640 --> 00:12:18,430
option to switch to different parcel for

00:12:15,130 --> 00:12:23,020
given model but you can pass your opener

00:12:18,430 --> 00:12:25,560
reader as I mentioned before also models

00:12:23,020 --> 00:12:28,270
currently allows to switch globular

00:12:25,560 --> 00:12:31,030
globally reader so if we have more

00:12:28,270 --> 00:12:34,180
models you can in one place which that

00:12:31,030 --> 00:12:38,680
all models use different reader like a

00:12:34,180 --> 00:12:40,960
network one or installation one also

00:12:38,680 --> 00:12:43,210
models ensure for consistency so if

00:12:40,960 --> 00:12:46,930
there is a config file get half price

00:12:43,210 --> 00:12:49,600
for example to to providing options then

00:12:46,930 --> 00:12:55,420
the Moodle and should ensure that it's

00:12:49,600 --> 00:12:57,460
not it's properly used the the module is

00:12:55,420 --> 00:12:59,860
something for target user so it should

00:12:57,460 --> 00:13:03,670
as I mentioned it should very high level

00:12:59,860 --> 00:13:06,899
and easy to use for them and examples

00:13:03,670 --> 00:13:12,899
are some grab models which shall shew

00:13:06,899 --> 00:13:26,779
show in few minutes so now interst more

00:13:12,899 --> 00:13:26,779
interesting part is examples so put it

00:13:34,379 --> 00:13:43,449
open it

00:13:37,160 --> 00:13:47,209
okay so currently this is a plug-in for

00:13:43,449 --> 00:13:50,779
cfa for grab two so the idea is that

00:13:47,209 --> 00:13:53,389
each software have its own plug-in that

00:13:50,779 --> 00:13:56,000
handles all its files currently for grab

00:13:53,389 --> 00:14:03,610
two we have four configuration files the

00:13:56,000 --> 00:14:08,839
views and for example the easy one is

00:14:03,610 --> 00:14:11,600
device map which is some it's a mapping

00:14:08,839 --> 00:14:15,800
between terminal devices and grab

00:14:11,600 --> 00:14:21,050
devices and how it looks like it's some

00:14:15,800 --> 00:14:24,379
model it's it have its own boxer and it

00:14:21,050 --> 00:14:27,170
use a gas so you just right I won't I'll

00:14:24,379 --> 00:14:32,180
get us and use this specific lands for

00:14:27,170 --> 00:14:37,699
it it has its own path so it's also

00:14:32,180 --> 00:14:39,829
constant where this file is and as you

00:14:37,699 --> 00:14:45,399
can see for example we ensure

00:14:39,829 --> 00:14:45,399
consistency grab two are basically a

00:14:45,670 --> 00:14:52,810
font so let me enlarge fun

00:14:57,800 --> 00:15:09,420
hey I hope how we can oh you know large

00:15:02,490 --> 00:15:13,290
this one okay okay so as you can see in

00:15:09,420 --> 00:15:16,410
sight we ensure that we use at maximum

00:15:13,290 --> 00:15:19,740
eight devices because it's some

00:15:16,410 --> 00:15:22,800
limitation of graph that it doesn't

00:15:19,740 --> 00:15:26,790
allow war it's caused by some hardware

00:15:22,800 --> 00:15:31,410
limitations so there is some consistency

00:15:26,790 --> 00:15:33,740
check there is some helpers like get me

00:15:31,410 --> 00:15:36,930
your up device forgiven caramel device

00:15:33,740 --> 00:15:39,480
get me system device forgiven grab your

00:15:36,930 --> 00:15:42,240
eyes to its really quite high level API

00:15:39,480 --> 00:15:45,269
that hides some it will details like

00:15:42,240 --> 00:15:49,560
some ordering inside stop it all heading

00:15:45,269 --> 00:15:52,069
your moving and also allows you to give

00:15:49,560 --> 00:15:55,560
some grub devices which as you can see

00:15:52,069 --> 00:16:01,439
filter out comments so you just just get

00:15:55,560 --> 00:16:04,170
the various stuff and this is a simple

00:16:01,439 --> 00:16:08,040
model for more complex one it's even

00:16:04,170 --> 00:16:10,980
more significant how it can make work

00:16:08,040 --> 00:16:13,439
easier which is default one its usual

00:16:10,980 --> 00:16:17,370
the most interesting config file for

00:16:13,439 --> 00:16:22,740
grab two so there is a set of simple

00:16:17,370 --> 00:16:27,060
attributes which basically means that it

00:16:22,740 --> 00:16:31,740
creates a robot assessor called default

00:16:27,060 --> 00:16:34,560
for he grabbed the phone and that's a

00:16:31,740 --> 00:16:36,870
common string once so it's justified

00:16:34,560 --> 00:16:40,199
there is such options and you can read

00:16:36,870 --> 00:16:46,980
it you can write and then comes a more

00:16:40,199 --> 00:16:49,459
tricky ones like caramel parameters and

00:16:46,980 --> 00:16:52,860
garnet technol parameters have some data

00:16:49,459 --> 00:16:55,470
but it looks like strength parallel

00:16:52,860 --> 00:16:57,840
parameters but in fact it's more complex

00:16:55,470 --> 00:17:02,070
because it's a common line

00:16:57,840 --> 00:17:05,490
which if its own internal ology and for

00:17:02,070 --> 00:17:11,190
example re parsnip if your default Carol

00:17:05,490 --> 00:17:13,550
get even parameter so the model defined

00:17:11,190 --> 00:17:17,910
it slogan of parameters and then you can

00:17:13,550 --> 00:17:20,490
vote like its documentation in there is

00:17:17,910 --> 00:17:22,320
parameter quiet and you if you get

00:17:20,490 --> 00:17:24,570
through it means there is such perfect

00:17:22,320 --> 00:17:27,420
every good force means there's no such

00:17:24,570 --> 00:17:29,790
parameter if you get strained it means

00:17:27,420 --> 00:17:33,030
there is single instance of this

00:17:29,790 --> 00:17:37,400
parameter with given value and to be

00:17:33,030 --> 00:17:40,350
given bar interesting career elves more

00:17:37,400 --> 00:17:43,020
specify a parameter multiple time so if

00:17:40,350 --> 00:17:46,500
there is for example if you use Siri to

00:17:43,020 --> 00:17:51,210
serial consoles then you can ask for it

00:17:46,500 --> 00:17:53,970
and you will get it so this early makes

00:17:51,210 --> 00:17:56,700
the working with it configuration file

00:17:53,970 --> 00:17:58,620
much much easier for target user because

00:17:56,700 --> 00:18:02,640
you have some helpers that ensure

00:17:58,620 --> 00:18:07,110
everything is properly voltage properly

00:18:02,640 --> 00:18:09,900
really placed properly also another

00:18:07,110 --> 00:18:13,890
example is if you have confirmation

00:18:09,900 --> 00:18:17,250
option they have just few possible

00:18:13,890 --> 00:18:19,710
values of course you can let you use up

00:18:17,250 --> 00:18:22,590
to add anything they want but there is a

00:18:19,710 --> 00:18:26,430
risk that it the gravity doesn't

00:18:22,590 --> 00:18:29,460
recognize such option so good model

00:18:26,430 --> 00:18:33,180
should mention what's possible what's

00:18:29,460 --> 00:18:37,050
possible values and then you can if you

00:18:33,180 --> 00:18:43,530
set it then again validate that it used

00:18:37,050 --> 00:18:49,230
the proper bonham okay and now let's

00:18:43,530 --> 00:18:52,200
check how it actually works so now i

00:18:49,230 --> 00:18:57,480
show you yes hope that use this device

00:18:52,200 --> 00:19:01,310
map and also shows that there is of

00:18:57,480 --> 00:19:05,580
course a much more logic above cfa

00:19:01,310 --> 00:19:10,560
because for example in the ass the idea

00:19:05,580 --> 00:19:11,440
is that we use unit devices and we want

00:19:10,560 --> 00:19:15,789
to use it in

00:19:11,440 --> 00:19:20,190
but cfa itself doesn't know anything

00:19:15,789 --> 00:19:24,399
about you death so it's again layer

00:19:20,190 --> 00:19:27,519
above cfa so if you want to check if

00:19:24,399 --> 00:19:32,309
device map contains given this you need

00:19:27,519 --> 00:19:36,370
to check that it contained given this

00:19:32,309 --> 00:19:38,529
translate it to you their device but if

00:19:36,370 --> 00:19:42,399
you do something some proposing you just

00:19:38,529 --> 00:19:46,509
do some filling ordering you can just

00:19:42,399 --> 00:19:53,850
ask give me all this with HD perfect

00:19:46,509 --> 00:20:01,470
sorted by bios order and psych stuff and

00:19:53,850 --> 00:20:01,470
now let me show a bit boxy fa itself

00:20:02,610 --> 00:20:10,779
base model have one interesting feature

00:20:06,549 --> 00:20:23,769
i would like to show you is how it set

00:20:10,779 --> 00:20:27,850
value which is sorry yeah so how it set

00:20:23,769 --> 00:20:34,720
value is that basically it tries to

00:20:27,850 --> 00:20:37,389
modify if value already exists and if in

00:20:34,720 --> 00:20:39,759
configuration file this value is not yet

00:20:37,389 --> 00:20:42,940
defined then it tried to uncomment it

00:20:39,759 --> 00:20:45,610
because usually what happens in default

00:20:42,940 --> 00:20:49,120
configuration files it they do have some

00:20:45,610 --> 00:20:51,730
comments and below is if you uncomment

00:20:49,120 --> 00:20:54,179
this line it happened this so we

00:20:51,730 --> 00:20:57,820
basically replace this commented out

00:20:54,179 --> 00:21:00,879
option and use it and only as a last

00:20:57,820 --> 00:21:05,230
option is that we add this new line to

00:21:00,879 --> 00:21:07,600
the to the end of a file so it's try to

00:21:05,230 --> 00:21:15,380
behave quite smartly when it try to

00:21:07,600 --> 00:21:20,600
modify something yeah

00:21:15,380 --> 00:21:23,610
and here is a example invitation of

00:21:20,600 --> 00:21:26,730
memory file as you see it's very simple

00:21:23,610 --> 00:21:32,670
simple stuff it just read write and hold

00:21:26,730 --> 00:21:37,190
it into internal memory as content okay

00:21:32,670 --> 00:21:41,040
so this is example how it looks like and

00:21:37,190 --> 00:21:53,700
do you have any questions regarding this

00:21:41,040 --> 00:21:55,860
API or it's possible usage okay it looks

00:21:53,700 --> 00:21:59,990
like not so thanks for our attention and

00:21:55,860 --> 00:21:59,990

YouTube URL: https://www.youtube.com/watch?v=O_aJdPsiIfs


