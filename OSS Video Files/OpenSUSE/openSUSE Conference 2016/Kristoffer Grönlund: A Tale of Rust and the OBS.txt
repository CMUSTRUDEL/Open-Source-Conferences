Title: Kristoffer Grönlund: A Tale of Rust and the OBS
Publication date: 2016-06-26
Playlist: openSUSE Conference 2016
Description: 
	https://media.ccc.de/v/782-a-tale-of-rust-and-the-obs

This talk will be a short introduction to the Rust programming language, why it is useful and why you would want to use it. Then I will discuss the current state of Rust in openSUSE, what the situation is regarding packaging crates and what remains to be done.

http://kri.gs/presentation-rust-obs/


Kristoffer Grönlund
Captions: 
	00:00:09,130 --> 00:00:16,520
so hello everyone I'm going to talk

00:00:13,910 --> 00:00:21,890
about rust which is a programming

00:00:16,520 --> 00:00:24,890
language and also about getting while

00:00:21,890 --> 00:00:29,480
getting rest into opensuse and the

00:00:24,890 --> 00:00:31,790
current state of where we are so yeah so

00:00:29,480 --> 00:00:36,470
I'm Christopher Carolyn I am the

00:00:31,790 --> 00:00:39,260
architect for a che and Souza and so it

00:00:36,470 --> 00:00:41,870
has nothing to do with rust but I'm

00:00:39,260 --> 00:00:46,670
interested in the language so this is

00:00:41,870 --> 00:00:49,010
this is kind of my hobby if you want to

00:00:46,670 --> 00:00:51,980
get the slides you can get them from

00:00:49,010 --> 00:00:57,260
this URL there will also be linked from

00:00:51,980 --> 00:01:04,040
the opensuse events page and i'll

00:00:57,260 --> 00:01:06,050
provide a PDF later so rust is a

00:01:04,040 --> 00:01:11,270
programming language developed by

00:01:06,050 --> 00:01:15,500
Mozilla primarily as intended as a

00:01:11,270 --> 00:01:18,500
replacement for c and c++ really the the

00:01:15,500 --> 00:01:21,440
idea that they had was that the needed a

00:01:18,500 --> 00:01:24,320
new language or they wanted to develop a

00:01:21,440 --> 00:01:26,870
better browser that wasn't susceptible

00:01:24,320 --> 00:01:30,260
to security holes in the same extent

00:01:26,870 --> 00:01:32,870
that the current firefox one is there

00:01:30,260 --> 00:01:35,600
they have a big issue with buffer on the

00:01:32,870 --> 00:01:37,550
flows and buffer overflows and memory

00:01:35,600 --> 00:01:40,310
leaks and other problems like this and

00:01:37,550 --> 00:01:43,910
they would try to figure out a way to

00:01:40,310 --> 00:01:47,510
solve that and so one way would be to

00:01:43,910 --> 00:01:49,370
switch to a managed language like Java

00:01:47,510 --> 00:01:52,790
or C sharp or something like this which

00:01:49,370 --> 00:01:56,300
runs in a vm but that comes with

00:01:52,790 --> 00:01:58,310
additional problems so if you if you run

00:01:56,300 --> 00:02:01,220
in a vm and you have garbage collection

00:01:58,310 --> 00:02:05,170
you have a runtime you have

00:02:01,220 --> 00:02:05,170
unpredictable memory usage memory

00:02:05,890 --> 00:02:14,060
implications

00:02:07,990 --> 00:02:17,360
so basically a modern browser is like a

00:02:14,060 --> 00:02:20,650
vm in itself it's it's hosting a bunch

00:02:17,360 --> 00:02:24,170
of processes one for each tab or window

00:02:20,650 --> 00:02:27,410
and it's hosting additional VMs inside

00:02:24,170 --> 00:02:30,230
to run JavaScript and so on so running

00:02:27,410 --> 00:02:31,940
all that inside a vm again would be okay

00:02:30,230 --> 00:02:33,740
so we're starting to get hurt too many

00:02:31,940 --> 00:02:35,810
virtual machines on top of virtual

00:02:33,740 --> 00:02:39,020
machines to have a viable solution so

00:02:35,810 --> 00:02:42,230
what I wanted to do is be able to have a

00:02:39,020 --> 00:02:46,310
language that operates on the same level

00:02:42,230 --> 00:02:49,220
as C and C++ but avoids the problems

00:02:46,310 --> 00:02:51,620
that C and C++ having exposing too much

00:02:49,220 --> 00:02:55,750
of the machinery of the system and

00:02:51,620 --> 00:03:00,080
letting you destroy yourself needlessly

00:02:55,750 --> 00:03:03,620
so the idea what rust is that it's a

00:03:00,080 --> 00:03:06,470
language which makes it more difficult

00:03:03,620 --> 00:03:11,600
to do things wrong that's that's the

00:03:06,470 --> 00:03:16,190
basic idea so today you can get the rust

00:03:11,600 --> 00:03:20,209
compiler on opensuse by installing from

00:03:16,190 --> 00:03:22,310
the devil languages rust project so

00:03:20,209 --> 00:03:28,190
basically the rust compiler that we have

00:03:22,310 --> 00:03:30,260
now is a prebuilt binary package so it's

00:03:28,190 --> 00:03:31,880
not yet ready to be included in the

00:03:30,260 --> 00:03:35,090
tumbleweed because it's not building

00:03:31,880 --> 00:03:39,709
from source entirely so to build rust

00:03:35,090 --> 00:03:42,470
you need rust so I'm going to get into

00:03:39,709 --> 00:03:44,810
more what that means but currently you

00:03:42,470 --> 00:03:48,380
need a specific version of rust to build

00:03:44,810 --> 00:03:51,079
any version of rust and that version is

00:03:48,380 --> 00:03:52,670
not necessarily the version that we

00:03:51,079 --> 00:03:55,040
already have in open citizens of yet

00:03:52,670 --> 00:03:56,510
it's a tricky problem we haven't figured

00:03:55,040 --> 00:03:58,820
out how to solve it I'm gonna go into

00:03:56,510 --> 00:04:01,910
more of that but first I'm going to talk

00:03:58,820 --> 00:04:04,610
a little bit about the language well I

00:04:01,910 --> 00:04:09,290
think I've gone into why you want it but

00:04:04,610 --> 00:04:12,110
so yeah zero overhead I see no runtime

00:04:09,290 --> 00:04:15,660
or vm or garbage collection

00:04:12,110 --> 00:04:19,470
memory safety so a language which tries

00:04:15,660 --> 00:04:21,540
to prevent buffer overflows or pointer

00:04:19,470 --> 00:04:25,080
arithmetic so you can't just point it

00:04:21,540 --> 00:04:27,270
around the memory and cause problems you

00:04:25,080 --> 00:04:30,330
can still cause all the problems that

00:04:27,270 --> 00:04:32,700
you can cause and see in rust all rust

00:04:30,330 --> 00:04:34,290
does is make it easier to do things

00:04:32,700 --> 00:04:37,500
right in the default case and more

00:04:34,290 --> 00:04:40,800
difficult to do things wrong whereas see

00:04:37,500 --> 00:04:43,830
for example makes it exceedingly easy to

00:04:40,800 --> 00:04:46,110
do things wrong and not even know it and

00:04:43,830 --> 00:04:48,720
very very difficult to do things right

00:04:46,110 --> 00:04:54,240
so that's kind of the difference in

00:04:48,720 --> 00:04:56,570
approach a side benefit of the way they

00:04:54,240 --> 00:05:00,060
chose to help memory was that they also

00:04:56,570 --> 00:05:01,860
introduced thread safety as a as a bonus

00:05:00,060 --> 00:05:05,100
and I'm going to go into a little bit

00:05:01,860 --> 00:05:07,440
about how that works but basically the

00:05:05,100 --> 00:05:09,120
way that rust handles memory has

00:05:07,440 --> 00:05:10,620
implications for threads that means that

00:05:09,120 --> 00:05:12,930
it's impossible to create a deadlock

00:05:10,620 --> 00:05:15,419
because you just can't write the code

00:05:12,930 --> 00:05:18,390
that would cause the deadlock unless you

00:05:15,419 --> 00:05:22,590
actually have unsafe blocks in there or

00:05:18,390 --> 00:05:26,910
so yeah and yeah the other thing is do

00:05:22,590 --> 00:05:31,770
you want sea level performance so if if

00:05:26,910 --> 00:05:33,210
this and easy interoperability with C so

00:05:31,770 --> 00:05:35,370
if these are things that are interesting

00:05:33,210 --> 00:05:41,520
to you then rust might be interesting as

00:05:35,370 --> 00:05:44,760
a language I I know that there is maybe

00:05:41,520 --> 00:05:49,979
a little bit of trepidation or fear

00:05:44,760 --> 00:05:53,039
because rust can be very hostile because

00:05:49,979 --> 00:05:55,860
it doesn't let you do things wrong so

00:05:53,039 --> 00:05:57,270
it's just going to in the beginning no

00:05:55,860 --> 00:06:00,030
matter what you do you're going to get a

00:05:57,270 --> 00:06:04,140
lot of error messages and trying to

00:06:00,030 --> 00:06:08,250
compile but I'll get into that too in

00:06:04,140 --> 00:06:13,380
more detail so here is a very simple

00:06:08,250 --> 00:06:17,700
rust program it looks similar to see if

00:06:13,380 --> 00:06:20,729
you look at it just like this already in

00:06:17,700 --> 00:06:22,350
this there are a lot of things that are

00:06:20,729 --> 00:06:27,210
unique to rust

00:06:22,350 --> 00:06:30,000
for example the ! after println means

00:06:27,210 --> 00:06:36,060
that this is a macro and macros in rusts

00:06:30,000 --> 00:06:39,810
are well I think they are most similar

00:06:36,060 --> 00:06:42,960
to macros in templated haskell or scheme

00:06:39,810 --> 00:06:47,660
if you've seen those languages and not

00:06:42,960 --> 00:06:51,060
at all like macros in C or C++ or and

00:06:47,660 --> 00:06:56,760
also not especially like macros in lisp

00:06:51,060 --> 00:07:02,370
or something like this so it's a it's

00:06:56,760 --> 00:07:04,440
not as free form as the macros in other

00:07:02,370 --> 00:07:06,930
languages where you can use do anything

00:07:04,440 --> 00:07:09,450
in a macro including like concatenating

00:07:06,930 --> 00:07:14,580
strings into new function calls but it

00:07:09,450 --> 00:07:16,560
is quite good at doing some of the

00:07:14,580 --> 00:07:18,750
things you know in a slightly safe way

00:07:16,560 --> 00:07:20,220
so for example the println back row used

00:07:18,750 --> 00:07:23,340
to adds a new line to the end of the

00:07:20,220 --> 00:07:24,870
string and then passes it to print and

00:07:23,340 --> 00:07:29,180
that the that kind of thing is quite

00:07:24,870 --> 00:07:32,520
simple to do with this macro system to

00:07:29,180 --> 00:07:34,200
compile and run this you use the rust

00:07:32,520 --> 00:07:37,980
compiler or you can use the rest

00:07:34,200 --> 00:07:41,310
compiler just like you would use GCC so

00:07:37,980 --> 00:07:45,930
you put put this in the file call it

00:07:41,310 --> 00:07:48,150
hello dot RS your run rust see passing

00:07:45,930 --> 00:07:52,230
it hello that RS and you get an

00:07:48,150 --> 00:07:54,270
executable just like you get from GCC it

00:07:52,230 --> 00:07:56,600
there's no runtime so it doesn't link to

00:07:54,270 --> 00:08:01,470
any big library or anything like that

00:07:56,600 --> 00:08:04,260
but it is statically linked to the

00:08:01,470 --> 00:08:06,630
standard library that is so the binary

00:08:04,260 --> 00:08:09,030
will become a fat binary currently there

00:08:06,630 --> 00:08:11,580
is no dynamic linking there is some

00:08:09,030 --> 00:08:13,860
support for dynamic linking and they're

00:08:11,580 --> 00:08:16,710
working on making it better but uh yeah

00:08:13,860 --> 00:08:18,960
that's another one of the issues that we

00:08:16,710 --> 00:08:21,260
are looking at for packaging for

00:08:18,960 --> 00:08:23,910
opensuse we would like to be able to

00:08:21,260 --> 00:08:28,490
dynamically linked to openssl for

00:08:23,910 --> 00:08:31,889
example and currently it's not that easy

00:08:28,490 --> 00:08:36,870
so to scare you a little bit here's a

00:08:31,889 --> 00:08:40,229
bigger example so this is a rust program

00:08:36,870 --> 00:08:41,969
which creates second thread and uses

00:08:40,229 --> 00:08:48,089
channels to communicate between the

00:08:41,969 --> 00:08:51,149
threads and has a shared hash map where

00:08:48,089 --> 00:08:53,760
it both threads try to insert into the

00:08:51,149 --> 00:08:55,470
hash map but at the same time and then

00:08:53,760 --> 00:08:59,520
the main thread tries to read from the

00:08:55,470 --> 00:09:03,149
hash map and this is the kind of thing

00:08:59,520 --> 00:09:07,470
that in C or C++ is quite difficult to

00:09:03,149 --> 00:09:10,230
do in a thread safe way and in rust you

00:09:07,470 --> 00:09:13,250
can't write this code in a way that

00:09:10,230 --> 00:09:15,930
would would not be thread-safe because

00:09:13,250 --> 00:09:19,020
the compiler is aware for example that

00:09:15,930 --> 00:09:21,899
the hash map is not thread aware so it

00:09:19,020 --> 00:09:24,029
won't even compile code that involves

00:09:21,899 --> 00:09:26,459
multiple threads using a hash map

00:09:24,029 --> 00:09:28,529
directly so what you need to do is you

00:09:26,459 --> 00:09:32,970
need to wrap the hashmap in a mutex you

00:09:28,529 --> 00:09:34,950
need to lock in each thread and if you

00:09:32,970 --> 00:09:39,120
do the locking incorrectly the compiler

00:09:34,950 --> 00:09:41,430
won't even compile the code so and you

00:09:39,120 --> 00:09:46,079
can also see a few other features of

00:09:41,430 --> 00:09:48,600
rust here so you can use modules so it

00:09:46,079 --> 00:09:53,310
has like a full module system like other

00:09:48,600 --> 00:09:57,660
more modern languages to include code

00:09:53,310 --> 00:10:01,020
from other modules you can also so here

00:09:57,660 --> 00:10:04,649
for example I'm calling as the color

00:10:01,020 --> 00:10:08,130
thread Collins bond without using use

00:10:04,649 --> 00:10:11,190
STD thread first so you can use fully

00:10:08,130 --> 00:10:16,740
qualify module names and access things

00:10:11,190 --> 00:10:19,190
that way so it has some nice features

00:10:16,740 --> 00:10:23,579
like the structuring so you can declare

00:10:19,190 --> 00:10:25,829
so the channel function returns both the

00:10:23,579 --> 00:10:28,350
sending and receiving end of the

00:10:25,829 --> 00:10:31,500
communication channel four threads and

00:10:28,350 --> 00:10:33,899
return to these as two a tuple of two

00:10:31,500 --> 00:10:34,910
separate things and you can assign each

00:10:33,899 --> 00:10:41,630
to

00:10:34,910 --> 00:10:45,500
a name in one construction the colon

00:10:41,630 --> 00:10:50,990
colon you is is a convention for memory

00:10:45,500 --> 00:10:54,590
handling so this is simply putting this

00:10:50,990 --> 00:10:58,400
memory on the heap so similar to new in

00:10:54,590 --> 00:11:03,350
C++ or Java but the memory is actually

00:10:58,400 --> 00:11:05,000
managed at compile time so rust will

00:11:03,350 --> 00:11:08,980
ensure that you have the correct number

00:11:05,000 --> 00:11:12,380
of allocations and everything is is

00:11:08,980 --> 00:11:15,800
every reference is scoped so this memory

00:11:12,380 --> 00:11:21,410
is freed when both threads go out of

00:11:15,800 --> 00:11:24,860
scope so to speak there's a few other

00:11:21,410 --> 00:11:28,430
niceties like pattern matching that I

00:11:24,860 --> 00:11:29,600
will go into a little bit more something

00:11:28,430 --> 00:11:32,140
you will see a lot when you start

00:11:29,600 --> 00:11:37,400
looking at examples of rust is this

00:11:32,140 --> 00:11:41,530
unwrap thing so rust doesn't have

00:11:37,400 --> 00:11:46,280
exceptions unlike Java or even C++

00:11:41,530 --> 00:11:51,200
instead functions usually return what is

00:11:46,280 --> 00:11:53,210
called result type which is an enum of

00:11:51,200 --> 00:11:56,930
either okay with the value that you were

00:11:53,210 --> 00:11:59,690
after or an error and it actually checks

00:11:56,930 --> 00:12:02,960
at compile time that you've handled all

00:11:59,690 --> 00:12:05,270
the cases so it forces you to check out

00:12:02,960 --> 00:12:07,790
is it okay then I do this if it's not

00:12:05,270 --> 00:12:11,110
okay then I do this other thing so so

00:12:07,790 --> 00:12:15,410
here for example it's saying okay if

00:12:11,110 --> 00:12:19,820
locking succeeds assign the result to

00:12:15,410 --> 00:12:22,430
this M variable and then let me access

00:12:19,820 --> 00:12:24,800
it within the scope of F and then you

00:12:22,430 --> 00:12:26,720
can do them put them else and handle the

00:12:24,800 --> 00:12:30,080
failure but in this case is used

00:12:26,720 --> 00:12:33,740
ignoring the error and what unwrapped us

00:12:30,080 --> 00:12:37,400
is let you continue if it everything was

00:12:33,740 --> 00:12:40,040
okay and panic as in and the whole

00:12:37,400 --> 00:12:42,560
process if there is a failure at this

00:12:40,040 --> 00:12:44,180
point so you see this a lot in example

00:12:42,560 --> 00:12:45,940
code because in example code you don't

00:12:44,180 --> 00:12:47,730
want to clutter it with error handling

00:12:45,940 --> 00:12:49,320
but of course in a

00:12:47,730 --> 00:12:52,829
real program you do want to hell your

00:12:49,320 --> 00:12:55,680
errors and the nice thing with having

00:12:52,829 --> 00:12:58,470
the unwrapped thing is that you do you

00:12:55,680 --> 00:13:00,600
have an explicit point in the code that

00:12:58,470 --> 00:13:04,260
says okay this is where it's going to

00:13:00,600 --> 00:13:06,449
crash if there's a failure so the thing

00:13:04,260 --> 00:13:11,070
that rust does is make it very explicit

00:13:06,449 --> 00:13:14,459
where your your failure points are so

00:13:11,070 --> 00:13:18,570
this makes it easy to find the source of

00:13:14,459 --> 00:13:20,850
the problem yeah I'm not going to go

00:13:18,570 --> 00:13:24,060
into much more about this example right

00:13:20,850 --> 00:13:26,639
now because it's a little bit too much

00:13:24,060 --> 00:13:28,529
but it's just show an example of a

00:13:26,639 --> 00:13:31,070
little bit more realistic code and use

00:13:28,529 --> 00:13:37,410
the normal example code that you get for

00:13:31,070 --> 00:13:40,110
things like this so this is a little bit

00:13:37,410 --> 00:13:42,480
about how allocation is handled in rust

00:13:40,110 --> 00:13:46,920
so in this example we have the main

00:13:42,480 --> 00:13:50,790
function which where we allocate so this

00:13:46,920 --> 00:13:52,949
is simply a five like an integer and

00:13:50,790 --> 00:13:57,600
it's put in the box which means that

00:13:52,949 --> 00:13:59,970
it's heap allocated but it's life's life

00:13:57,600 --> 00:14:03,949
span is scoped by the Block in which is

00:13:59,970 --> 00:14:06,240
defined so box to here for example

00:14:03,949 --> 00:14:09,420
exists until the end of the main

00:14:06,240 --> 00:14:13,260
function you can create like a little

00:14:09,420 --> 00:14:16,290
scope like this to limit the lifetime of

00:14:13,260 --> 00:14:17,490
variables so box three here is going to

00:14:16,290 --> 00:14:22,740
get created and then immediately

00:14:17,490 --> 00:14:26,610
destroyed and then in this function the

00:14:22,740 --> 00:14:29,630
box one this value is limited to the

00:14:26,610 --> 00:14:33,000
scope of that function so for example

00:14:29,630 --> 00:14:37,639
rust wouldn't let you create a box like

00:14:33,000 --> 00:14:42,660
this and then pass it out without

00:14:37,639 --> 00:14:51,720
handling that correctly so so in this

00:14:42,660 --> 00:14:55,730
example we are yeah and so the word

00:14:51,720 --> 00:14:59,350
there's a concept of ownership and

00:14:55,730 --> 00:15:00,970
moving ownership around in rust

00:14:59,350 --> 00:15:05,140
so that's how it's keeping track of

00:15:00,970 --> 00:15:08,020
memory is that the compiler keeps track

00:15:05,140 --> 00:15:12,430
of who owns a piece of memory at every

00:15:08,020 --> 00:15:13,870
stain of the program so in this case we

00:15:12,430 --> 00:15:15,850
start the program and we create two

00:15:13,870 --> 00:15:19,270
regular variables and these are limited

00:15:15,850 --> 00:15:22,120
to this scope so the owner is the main

00:15:19,270 --> 00:15:26,020
function in this case we then create

00:15:22,120 --> 00:15:30,670
this 5 and assign the variable a to it

00:15:26,020 --> 00:15:32,860
so at this point main owns a so we can

00:15:30,670 --> 00:15:36,550
actually read from it and print it at

00:15:32,860 --> 00:15:40,840
this point if we then create the second

00:15:36,550 --> 00:15:43,920
variable called B and assign to a if we

00:15:40,840 --> 00:15:49,120
then try to hear access a at this point

00:15:43,920 --> 00:15:52,030
it doesn't let us because the boxed

00:15:49,120 --> 00:15:54,190
memory that we assigned you a has now

00:15:52,030 --> 00:15:57,760
been the ownership has been transferred

00:15:54,190 --> 00:16:00,850
to be in this case so rust with no

00:15:57,760 --> 00:16:03,280
longer let us access a because a no

00:16:00,850 --> 00:16:05,980
longer owns that memory that memory has

00:16:03,280 --> 00:16:08,350
moved on so if you uncomment this line

00:16:05,980 --> 00:16:11,710
and try to run this program the compiler

00:16:08,350 --> 00:16:15,640
we say no a is now doesn't own this

00:16:11,710 --> 00:16:18,460
memory you can't access any anymore and

00:16:15,640 --> 00:16:20,020
then in the same way if you pass if you

00:16:18,460 --> 00:16:22,630
create a variable B and then you pass

00:16:20,020 --> 00:16:25,330
that to function like this that takes a

00:16:22,630 --> 00:16:28,420
box the only shape is transferred to

00:16:25,330 --> 00:16:31,690
that function so if you try to use be

00:16:28,420 --> 00:16:34,180
after this point the compiler will no

00:16:31,690 --> 00:16:35,800
longer let you will say no destroy box

00:16:34,180 --> 00:16:37,960
on that memory and at the end of its

00:16:35,800 --> 00:16:40,270
scoop the memory was freed because the

00:16:37,960 --> 00:16:42,970
owner of this memory went out of scope

00:16:40,270 --> 00:16:45,610
and so it's no longer available and

00:16:42,970 --> 00:16:47,380
freed it and at this point you would

00:16:45,610 --> 00:16:50,080
probably say wow this is completely

00:16:47,380 --> 00:16:53,200
unusable how can i if I can only use the

00:16:50,080 --> 00:16:55,240
variable ones what how can I do anything

00:16:53,200 --> 00:16:57,850
if I if I put destroy box in the loop

00:16:55,240 --> 00:17:02,080
here it won't compile because only the

00:16:57,850 --> 00:17:03,970
first iteration of the loop the it will

00:17:02,080 --> 00:17:05,470
pass the ownership in that intuition to

00:17:03,970 --> 00:17:08,230
the function and then free the memory

00:17:05,470 --> 00:17:10,090
and the Cavalli say well I mean second

00:17:08,230 --> 00:17:10,929
iteration there's no memory anymore you

00:17:10,090 --> 00:17:13,959
can't do this

00:17:10,929 --> 00:17:17,169
so the way we get around this and rust

00:17:13,959 --> 00:17:19,509
is with something called borrowing which

00:17:17,169 --> 00:17:21,429
is where you can say I'm still the owner

00:17:19,509 --> 00:17:23,709
of this memory I want to call this

00:17:21,429 --> 00:17:25,749
function and pass it this memory and I

00:17:23,709 --> 00:17:27,819
let it borrow the memory for a while and

00:17:25,749 --> 00:17:30,509
then when the function completes I'm

00:17:27,819 --> 00:17:36,399
still the owner the memory is still mine

00:17:30,509 --> 00:17:44,169
so the way you do this is with the see

00:17:36,399 --> 00:17:48,340
you the ad here where we're saying that

00:17:44,169 --> 00:17:51,009
in this skull is called well with the ad

00:17:48,340 --> 00:17:53,769
here as well so in this scope we're

00:17:51,009 --> 00:17:56,830
borrowing the memory of this point which

00:17:53,769 --> 00:18:01,749
is a struct just like in C as three

00:17:56,830 --> 00:18:04,899
members so point is the variable and

00:18:01,749 --> 00:18:07,840
main is the scope which owns this memory

00:18:04,899 --> 00:18:10,360
owns this variable we create a second

00:18:07,840 --> 00:18:15,369
scope in here and we borrow it using the

00:18:10,360 --> 00:18:18,340
at here and we can use it to look at it

00:18:15,369 --> 00:18:22,059
but it's actually by default the

00:18:18,340 --> 00:18:24,970
boroughs are immutable or const you'd

00:18:22,059 --> 00:18:27,220
say so you can look at the values at the

00:18:24,970 --> 00:18:31,110
end of the scope the main scoff still

00:18:27,220 --> 00:18:35,499
has ownership but we can't assign to it

00:18:31,110 --> 00:18:39,460
so to get a mutable borrow we have to

00:18:35,499 --> 00:18:44,049
use the add mu T or moot I don't know

00:18:39,460 --> 00:18:47,169
how to pronounce that operator and at it

00:18:44,049 --> 00:18:49,450
and here we can actually so the

00:18:47,169 --> 00:18:54,279
ownership is still maintained by main

00:18:49,450 --> 00:18:55,929
but the right rights so to speak the

00:18:54,279 --> 00:18:57,580
right to modify the variable is

00:18:55,929 --> 00:19:00,220
temporarily transferred to the

00:18:57,580 --> 00:19:03,009
stethoscope this other variable we can

00:19:00,220 --> 00:19:05,649
assign to the structure in in here and

00:19:03,009 --> 00:19:08,350
then at the endoscope those rights are

00:19:05,649 --> 00:19:10,929
transferred back so at this point the

00:19:08,350 --> 00:19:13,869
main point variable now has the rights

00:19:10,929 --> 00:19:16,690
again and there and those rights are

00:19:13,869 --> 00:19:18,659
actually transferred when it comes to

00:19:16,690 --> 00:19:21,040
writing so they can only ever be one

00:19:18,659 --> 00:19:23,560
writer too

00:19:21,040 --> 00:19:25,750
is a memory so the compiler real action

00:19:23,560 --> 00:19:28,420
make sure that there's only one piece of

00:19:25,750 --> 00:19:31,810
code at any time which has the right to

00:19:28,420 --> 00:19:34,810
modify memory and that is the reason why

00:19:31,810 --> 00:19:38,170
all rust code is actually thread safe as

00:19:34,810 --> 00:19:40,390
well because this means that no matter

00:19:38,170 --> 00:19:42,850
how many threads you have only one of

00:19:40,390 --> 00:19:45,280
them is at any point allowed to modify

00:19:42,850 --> 00:19:48,160
the memory and at compile time it will

00:19:45,280 --> 00:19:51,510
actually verify that this is true so

00:19:48,160 --> 00:19:54,220
that's that's pretty cool but it's also

00:19:51,510 --> 00:19:59,620
pretty tricky to write code in rust

00:19:54,220 --> 00:20:01,240
because of this another aspect of rust

00:19:59,620 --> 00:20:03,690
which is a little bit different from

00:20:01,240 --> 00:20:09,820
other languages is what's called trait

00:20:03,690 --> 00:20:13,090
so the language with I think this is

00:20:09,820 --> 00:20:15,580
most similar to is Haskell but it's also

00:20:13,090 --> 00:20:18,550
a little bit similar to the interfaces

00:20:15,580 --> 00:20:22,140
that you having go so in in rust you

00:20:18,550 --> 00:20:24,460
don't have classes like in C++ or Java

00:20:22,140 --> 00:20:27,510
what you have is you have structures

00:20:24,460 --> 00:20:30,610
like in C and then you have traits which

00:20:27,510 --> 00:20:35,650
describe collections of functions that

00:20:30,610 --> 00:20:37,630
operate on a particular structure so in

00:20:35,650 --> 00:20:40,690
this case we're defining a trait animal

00:20:37,630 --> 00:20:44,920
and we're defining a set of methods

00:20:40,690 --> 00:20:46,840
which can be applied to an animal but we

00:20:44,920 --> 00:20:48,760
are not actually defining any kind of

00:20:46,840 --> 00:20:51,460
structure that implements this straight

00:20:48,760 --> 00:20:55,060
at this point so there's no base class

00:20:51,460 --> 00:20:57,340
or there is no like root object that's

00:20:55,060 --> 00:20:58,660
like the default implementation what

00:20:57,340 --> 00:21:00,370
we're saying is that there is such a

00:20:58,660 --> 00:21:01,870
thing as an animal we haven't actually

00:21:00,370 --> 00:21:04,120
described an yet and these are not

00:21:01,870 --> 00:21:07,810
actual functions that you can call at

00:21:04,120 --> 00:21:09,190
this point so you need you need

00:21:07,810 --> 00:21:13,120
something that implements this straight

00:21:09,190 --> 00:21:15,970
and the way this is done is you define a

00:21:13,120 --> 00:21:17,770
structure and separately from this

00:21:15,970 --> 00:21:21,070
finding the structure you define an

00:21:17,770 --> 00:21:22,780
implementation of so okay so this is

00:21:21,070 --> 00:21:25,330
just implementing some functions for the

00:21:22,780 --> 00:21:26,980
structure so it's saying that okay so we

00:21:25,330 --> 00:21:29,770
have a structured sheep and separate

00:21:26,980 --> 00:21:32,700
from the structure it definition we

00:21:29,770 --> 00:21:35,010
define some methods for sheep

00:21:32,700 --> 00:21:36,390
and this can be done multiple times so

00:21:35,010 --> 00:21:38,130
you can have multiple blocks like this

00:21:36,390 --> 00:21:42,300
when you're defining methods then apply

00:21:38,130 --> 00:21:44,490
to sheep so it's not like a class in

00:21:42,300 --> 00:21:47,040
that sense that the it couples the data

00:21:44,490 --> 00:21:48,540
of the structure with the methods that

00:21:47,040 --> 00:21:51,240
can be applied to the structure you can

00:21:48,540 --> 00:21:53,430
actually separate those so you can have

00:21:51,240 --> 00:21:56,900
a library that provides methods for a

00:21:53,430 --> 00:22:00,630
structure that is defined elsewhere and

00:21:56,900 --> 00:22:04,050
then we can implement the animal trade

00:22:00,630 --> 00:22:07,650
for sheep and implement these functions

00:22:04,050 --> 00:22:14,070
for the Sheep type in particular which

00:22:07,650 --> 00:22:15,930
then lets us use these methods on sheep

00:22:14,070 --> 00:22:17,340
structures or other structures there

00:22:15,930 --> 00:22:19,560
also implement the animal trait and we

00:22:17,340 --> 00:22:22,980
can have a function that takes an animal

00:22:19,560 --> 00:22:26,880
as parameter uses the methods of animal

00:22:22,980 --> 00:22:28,980
on it and we can passing the shift in

00:22:26,880 --> 00:22:33,540
that method NEC is going to work and

00:22:28,980 --> 00:22:36,420
this is all more similar to C++

00:22:33,540 --> 00:22:39,690
templates than C++ classes in the sense

00:22:36,420 --> 00:22:42,570
that this is all derived at compile time

00:22:39,690 --> 00:22:44,700
as well so at compile time it's figuring

00:22:42,570 --> 00:22:49,770
out which method to actually call for

00:22:44,700 --> 00:22:51,630
for the animal in question so the way

00:22:49,770 --> 00:22:56,790
with you you would use this is that you

00:22:51,630 --> 00:22:59,150
would create a variable like this and

00:22:56,790 --> 00:23:02,220
here you can see a little bit of the

00:22:59,150 --> 00:23:04,710
type inference in rust where it's

00:23:02,220 --> 00:23:07,920
figuring out that it needs to actually

00:23:04,710 --> 00:23:09,720
call the function that creates a sheep

00:23:07,920 --> 00:23:13,920
because the variable that we're

00:23:09,720 --> 00:23:16,170
assigning it to has the type sheep so

00:23:13,920 --> 00:23:19,950
that's a little bit leave a trick even

00:23:16,170 --> 00:23:24,180
so it actually goes the other way so in

00:23:19,950 --> 00:23:27,360
previous examples like here for example

00:23:24,180 --> 00:23:29,340
we have we have a defined type of an

00:23:27,360 --> 00:23:31,500
obvious so we have some memory of a

00:23:29,340 --> 00:23:34,170
certain type and then when you say ok

00:23:31,500 --> 00:23:36,240
let the variable point be that type and

00:23:34,170 --> 00:23:38,730
then the compiler figures out okay so

00:23:36,240 --> 00:23:41,070
this is type point then this also has to

00:23:38,730 --> 00:23:43,530
have that type but in this case is

00:23:41,070 --> 00:23:45,020
actually going in the other direction so

00:23:43,530 --> 00:23:48,020
it's saying

00:23:45,020 --> 00:23:50,450
okay we we have a generic function here

00:23:48,020 --> 00:23:53,150
that creates animals and we're assigning

00:23:50,450 --> 00:23:55,480
it to a variable of a specific time then

00:23:53,150 --> 00:23:59,200
that generic function must actually be

00:23:55,480 --> 00:24:06,160
the cheap constructor and so it can go

00:23:59,200 --> 00:24:09,170
in that direction as well all right so I

00:24:06,160 --> 00:24:13,520
also put up so this is definition of

00:24:09,170 --> 00:24:17,660
println macro so the micros are

00:24:13,520 --> 00:24:19,730
basically compiler plugins so what this

00:24:17,660 --> 00:24:23,690
does is says when it sees the println

00:24:19,730 --> 00:24:27,830
macro it passes the expression that that

00:24:23,690 --> 00:24:31,910
back row was passed to this code which

00:24:27,830 --> 00:24:35,750
is then at compile time replaced so and

00:24:31,910 --> 00:24:37,700
the difference between this and just

00:24:35,750 --> 00:24:40,550
having a function is that this this is

00:24:37,700 --> 00:24:43,670
all done at compile time so you can do

00:24:40,550 --> 00:24:46,820
so here it's actually calling print and

00:24:43,670 --> 00:24:51,740
concat in when compiling so at runtime

00:24:46,820 --> 00:24:54,290
the result is just a string constant if

00:24:51,740 --> 00:24:57,500
if you're used to using something like

00:24:54,290 --> 00:25:00,710
Ruby or Python or another language like

00:24:57,500 --> 00:25:04,640
this that's just total nonsense because

00:25:00,710 --> 00:25:06,500
there is no compile or runtime in the

00:25:04,640 --> 00:25:08,120
same sense but if you're coming from C

00:25:06,500 --> 00:25:11,600
or C++ then there is an actual

00:25:08,120 --> 00:25:13,670
difference the the code execution in

00:25:11,600 --> 00:25:15,560
these macros happen when compiling the

00:25:13,670 --> 00:25:21,890
code not when actually running the

00:25:15,560 --> 00:25:23,540
program yeah so I think for learning

00:25:21,890 --> 00:25:27,350
rust in the beginning you don't really

00:25:23,540 --> 00:25:32,840
have to use macros at all it's more a

00:25:27,350 --> 00:25:34,340
neat feature later on I guess so someone

00:25:32,840 --> 00:25:37,820
might not have favorite things about

00:25:34,340 --> 00:25:44,960
rust so far is the match leaflet which

00:25:37,820 --> 00:25:48,560
is pattern matching so this is something

00:25:44,960 --> 00:25:51,920
from prologue and also Erlang I think

00:25:48,560 --> 00:25:53,560
has a lot of this but it's also coming

00:25:51,920 --> 00:26:00,140
into other languages where

00:25:53,560 --> 00:26:03,200
you at compile time say okay I'm

00:26:00,140 --> 00:26:05,450
returning either this or that from this

00:26:03,200 --> 00:26:08,810
function and the compiler can check that

00:26:05,450 --> 00:26:13,370
I'm actually handling all the cases so

00:26:08,810 --> 00:26:16,790
in rust there is no null at all so

00:26:13,370 --> 00:26:20,050
instead functions can return optional

00:26:16,790 --> 00:26:23,660
values so you will return oh it's either

00:26:20,050 --> 00:26:25,610
this object or it's nothing and at

00:26:23,660 --> 00:26:28,220
compile time it will check that you

00:26:25,610 --> 00:26:31,670
actually made sure that you got what you

00:26:28,220 --> 00:26:35,090
expected so there is there is no way to

00:26:31,670 --> 00:26:39,410
write code that is null unsafe in that

00:26:35,090 --> 00:26:42,500
sense yeah traits I talked about and

00:26:39,410 --> 00:26:46,580
then the next thing is cargo which is

00:26:42,500 --> 00:26:48,800
the package manager for for rust and I

00:26:46,580 --> 00:26:50,660
no llores is now look at me like I'm

00:26:48,800 --> 00:26:53,840
crazy because we already discussed the

00:26:50,660 --> 00:26:57,020
pains of package managers in languages

00:26:53,840 --> 00:26:59,900
but cargo is quite nice and yeah I'll

00:26:57,020 --> 00:27:05,090
get into the problems of it for us as

00:26:59,900 --> 00:27:08,720
opensuse people later so cargo is a tool

00:27:05,090 --> 00:27:12,110
that helps helps with using libraries

00:27:08,720 --> 00:27:15,170
and setting up projects so instead of

00:27:12,110 --> 00:27:18,560
using the rust compiler directly you can

00:27:15,170 --> 00:27:20,360
use cargo to manage your project so the

00:27:18,560 --> 00:27:23,480
way you would create a new project for

00:27:20,360 --> 00:27:25,640
our little hello promo code that I've

00:27:23,480 --> 00:27:29,180
showed in the beginning it's a TV called

00:27:25,640 --> 00:27:33,700
cargo new hello and they will create a

00:27:29,180 --> 00:27:37,670
git repository for for your project and

00:27:33,700 --> 00:27:39,560
create a little main function for it and

00:27:37,670 --> 00:27:44,090
everything and set everything up so you

00:27:39,560 --> 00:27:46,520
can compile a binary from that and the

00:27:44,090 --> 00:27:51,410
main definition of cargo project is the

00:27:46,520 --> 00:27:57,260
cargo dot the Tamil file tamil is a like

00:27:51,410 --> 00:27:59,020
in the file similar format where you

00:27:57,260 --> 00:28:02,450
would define the name of your project

00:27:59,020 --> 00:28:04,250
the ortho name the version of this

00:28:02,450 --> 00:28:05,230
project and then all the dependencies of

00:28:04,250 --> 00:28:08,390
this

00:28:05,230 --> 00:28:10,700
and also if it produces the library you

00:28:08,390 --> 00:28:14,210
would define that here as well instead

00:28:10,700 --> 00:28:16,990
of a binary and then the compile used

00:28:14,210 --> 00:28:22,130
run cargo built and it takes care of

00:28:16,990 --> 00:28:26,000
compiling if it's necessary and so on so

00:28:22,130 --> 00:28:27,980
that's that's quite nice in together

00:28:26,000 --> 00:28:32,540
with cargo there is something called

00:28:27,980 --> 00:28:34,610
crates which is the packages for rust so

00:28:32,540 --> 00:28:36,590
there's great stuff I 0 which is like a

00:28:34,610 --> 00:28:40,460
package hub just like four other

00:28:36,590 --> 00:28:42,710
languages and the way you would use it

00:28:40,460 --> 00:28:45,620
is in your car go tomo you define

00:28:42,710 --> 00:28:49,340
dependency so let's say we use the rand

00:28:45,620 --> 00:28:52,970
module for random number generation we

00:28:49,340 --> 00:28:55,790
will define the version we need and the

00:28:52,970 --> 00:28:58,580
dependency and then we use called cargo

00:28:55,790 --> 00:29:00,830
built and it's magically incredibly used

00:28:58,580 --> 00:29:02,929
goes out to the internet finds Rand and

00:29:00,830 --> 00:29:08,840
all the dependencies for it downloads

00:29:02,929 --> 00:29:11,059
compiles great so yeah ok so now I'm

00:29:08,840 --> 00:29:14,350
getting into the problems with this and

00:29:11,059 --> 00:29:17,179
we're where we at used right now so

00:29:14,350 --> 00:29:21,020
currently the people contributing to the

00:29:17,179 --> 00:29:23,210
rust packaging on opensuse are is this

00:29:21,020 --> 00:29:25,070
list I think actually there are some

00:29:23,210 --> 00:29:29,230
more people who got involved since I

00:29:25,070 --> 00:29:32,380
wrote this but the main the main guys is

00:29:29,230 --> 00:29:36,170
Michael I don't know if you're here oh

00:29:32,380 --> 00:29:38,059
great alright I'll talk to you later so

00:29:36,170 --> 00:29:42,230
he's done most of the work in getting

00:29:38,059 --> 00:29:46,429
the compiler up to date and getting car

00:29:42,230 --> 00:29:50,720
go in there and so on but there is still

00:29:46,429 --> 00:29:53,300
a lot of work remaining so currently we

00:29:50,720 --> 00:29:55,750
have two main projects under devil

00:29:53,300 --> 00:30:01,250
language rust there is the rust compiler

00:29:55,750 --> 00:30:04,400
and there is cargo bootstrap which is

00:30:01,250 --> 00:30:06,170
the cargo compiler thing and the reason

00:30:04,400 --> 00:30:09,110
it's called Corey bootstrap is because

00:30:06,170 --> 00:30:10,300
it's not quite building itself in the

00:30:09,110 --> 00:30:14,260
right way yet

00:30:10,300 --> 00:30:19,690
we're using Python project created by

00:30:14,260 --> 00:30:22,870
some Debian guys to build cargo without

00:30:19,690 --> 00:30:24,940
cargo because the problem is that the

00:30:22,870 --> 00:30:26,560
rust compiler is written in rust so to

00:30:24,940 --> 00:30:29,680
compile the rust compiler you need the

00:30:26,560 --> 00:30:31,990
rust compiler and cargo uses cargo to

00:30:29,680 --> 00:30:35,830
build itself so to build cargo you need

00:30:31,990 --> 00:30:39,280
cargo and figuring this out this is not

00:30:35,830 --> 00:30:41,350
that easy right now my goal is to get

00:30:39,280 --> 00:30:44,230
the rest compiler at least into

00:30:41,350 --> 00:30:46,660
tumbleweed by rust version 1 point 10

00:30:44,230 --> 00:30:51,610
because they made a big important change

00:30:46,660 --> 00:30:54,460
in their policies as of rust 1.9 which

00:30:51,610 --> 00:30:57,850
is that they promised that rust 1 point

00:30:54,460 --> 00:31:02,140
10 will be able to build itself using

00:30:57,850 --> 00:31:05,020
rust 1.9 and so on so if we have if we

00:31:02,140 --> 00:31:07,390
manage to package rust 1.9 we can they

00:31:05,020 --> 00:31:10,990
use our packaged rust version to build

00:31:07,390 --> 00:31:13,150
rust 1 point 10 and by that point we're

00:31:10,990 --> 00:31:15,490
bootstrapped and up and going so we can

00:31:13,150 --> 00:31:18,280
push it into tumbleweed and this remove

00:31:15,490 --> 00:31:21,100
the binary package from rust 1.9 and

00:31:18,280 --> 00:31:23,050
when rust 1 point 11 is released we can

00:31:21,100 --> 00:31:26,650
rebuild it with our 1 point 10 package

00:31:23,050 --> 00:31:28,330
so this is this is very similar to the

00:31:26,650 --> 00:31:30,790
way you would have to package GCC from

00:31:28,330 --> 00:31:32,260
the beginning so it's kind of a GCC is

00:31:30,790 --> 00:31:35,080
written in C so you need to c compiler

00:31:32,260 --> 00:31:40,420
to compile GCC so you have the same

00:31:35,080 --> 00:31:42,190
problem there it's just it's a little

00:31:40,420 --> 00:31:43,420
bit trickier than it might seem to

00:31:42,190 --> 00:31:47,380
actually figure out how to do this

00:31:43,420 --> 00:31:54,670
correctly yeah so that's that cargo is

00:31:47,380 --> 00:31:57,580
even worse because cargo is a cargo

00:31:54,670 --> 00:32:00,850
project with a long list of dependencies

00:31:57,580 --> 00:32:05,590
so to build the initial version of cargo

00:32:00,850 --> 00:32:08,470
we need to have like a fake cargo which

00:32:05,590 --> 00:32:10,650
or a binary package of cargo which we

00:32:08,470 --> 00:32:13,620
can use to build that version of colonel

00:32:10,650 --> 00:32:16,530
and we need to get like the package

00:32:13,620 --> 00:32:18,540
management up and running to get this

00:32:16,530 --> 00:32:20,910
working so this is the kind of the point

00:32:18,540 --> 00:32:22,830
where we are at now and this is the

00:32:20,910 --> 00:32:28,470
point after that where we haven't even

00:32:22,830 --> 00:32:30,300
gotten to you so my idea for the future

00:32:28,470 --> 00:32:32,460
is them we will combine kind of the

00:32:30,300 --> 00:32:36,210
approaches of the goal-line packaging

00:32:32,460 --> 00:32:39,690
stuff that the go the people i think

00:32:36,210 --> 00:32:41,460
it's Marguerite sue and of the project

00:32:39,690 --> 00:32:45,810
has done most of that work for a goal

00:32:41,460 --> 00:32:48,630
line to package go modules as rpms and

00:32:45,810 --> 00:32:52,080
combine them a little bit of how the

00:32:48,630 --> 00:32:55,080
Ruby stuff is managed using gmt rpm

00:32:52,080 --> 00:32:58,260
which is quite nice and I've started

00:32:55,080 --> 00:32:59,670
working on that there's in my home

00:32:58,260 --> 00:33:01,890
project there's something called cargo

00:32:59,670 --> 00:33:04,980
packaging which doesn't work at all

00:33:01,890 --> 00:33:06,660
right now but that's kind of the point

00:33:04,980 --> 00:33:09,480
that where I'm at right now looking at

00:33:06,660 --> 00:33:15,810
packaging rust and getting into opensuse

00:33:09,480 --> 00:33:18,480
so that's yeah then beyond this there

00:33:15,810 --> 00:33:20,480
are a lot of unsold issues with actually

00:33:18,480 --> 00:33:24,270
using rust and getting it into you

00:33:20,480 --> 00:33:28,410
sleeve for example so there is no stable

00:33:24,270 --> 00:33:32,460
ABI for rust itself for example which

00:33:28,410 --> 00:33:34,800
means that if you compile your rust

00:33:32,460 --> 00:33:38,130
program with a certain version of the

00:33:34,800 --> 00:33:40,230
rust compiler that comes with a certain

00:33:38,130 --> 00:33:42,780
standard library and if you update your

00:33:40,230 --> 00:33:46,260
rest compiler you have to recompile your

00:33:42,780 --> 00:33:49,680
program otherwise it won't link

00:33:46,260 --> 00:33:51,510
correctly if you use dynamic linking so

00:33:49,680 --> 00:33:53,100
right now we're limited to static

00:33:51,510 --> 00:33:56,700
linking like building everything into

00:33:53,100 --> 00:34:00,240
one binary which is yeah not great for

00:33:56,700 --> 00:34:02,400
security updates and so on the other

00:34:00,240 --> 00:34:06,120
problem is that the compilation of rust

00:34:02,400 --> 00:34:08,520
itself and rust programs is extremely

00:34:06,120 --> 00:34:12,210
slow and memory intense so to compile

00:34:08,520 --> 00:34:16,080
the rest compiler we need at least eight

00:34:12,210 --> 00:34:18,360
gigabytes of RAM and right now i think

00:34:16,080 --> 00:34:20,040
the vm is defined to have 50 gigabytes

00:34:18,360 --> 00:34:21,570
of disk and that's actually failing

00:34:20,040 --> 00:34:23,970
sometimes because it runs out the disk

00:34:21,570 --> 00:34:26,129
anyway and i don't even understand

00:34:23,970 --> 00:34:28,500
why how it can possibly use 50 gigabytes

00:34:26,129 --> 00:34:32,250
of temporary memory were building the

00:34:28,500 --> 00:34:34,349
compiler but there we are and it also

00:34:32,250 --> 00:34:37,139
right now it needs its own custom

00:34:34,349 --> 00:34:39,540
version of llvm to build a rust because

00:34:37,139 --> 00:34:43,530
rust is based on llvm and they have some

00:34:39,540 --> 00:34:45,270
patches to lv m so that's that's another

00:34:43,530 --> 00:34:47,129
issue we can't just use the element

00:34:45,270 --> 00:34:50,190
which is already packaged for opensuse

00:34:47,129 --> 00:34:53,460
we actually have to build lvm again just

00:34:50,190 --> 00:34:55,710
for us so those are issues that are

00:34:53,460 --> 00:34:57,450
remaining to be solved like the ABI

00:34:55,710 --> 00:34:59,010
problem is something that we can solve

00:34:57,450 --> 00:35:04,230
we have to wait for the rest community

00:34:59,010 --> 00:35:05,310
or or do it there but it's also one of

00:35:04,230 --> 00:35:09,690
the problems that I think is really

00:35:05,310 --> 00:35:11,520
difficult to solve and the problem is

00:35:09,690 --> 00:35:14,910
that it's really only a problem for us

00:35:11,520 --> 00:35:17,430
as distributions so it's only a problem

00:35:14,910 --> 00:35:20,010
for red hat and Suzy and a few other

00:35:17,430 --> 00:35:22,740
people for Mozilla for example they

00:35:20,010 --> 00:35:25,349
don't care about static linking Delhi

00:35:22,740 --> 00:35:28,530
just they use static link in the it

00:35:25,349 --> 00:35:32,940
works for them so that's that's one of

00:35:28,530 --> 00:35:37,440
the issues we have yeah so my main point

00:35:32,940 --> 00:35:39,570
is please help in the packaging rust if

00:35:37,440 --> 00:35:42,150
any of the people who were involved in

00:35:39,570 --> 00:35:45,060
packaging gold packages for example or

00:35:42,150 --> 00:35:47,460
Ruby for opensuse want to get involved

00:35:45,060 --> 00:35:50,070
in in helping out with rust I would be

00:35:47,460 --> 00:35:52,680
great because I think as far as I know

00:35:50,070 --> 00:35:54,930
both me and makalah don't really know

00:35:52,680 --> 00:35:57,210
that much about it about rpm macros and

00:35:54,930 --> 00:35:59,580
this is all magic to us we just want to

00:35:57,210 --> 00:36:01,080
get the compiler working so yeah any

00:35:59,580 --> 00:36:06,020
help you can give us that would be

00:36:01,080 --> 00:36:06,020
fantastic any questions

00:36:12,150 --> 00:36:21,369
yes the other microphone when do you

00:36:17,500 --> 00:36:24,069
expect to be able to do the bootstrap of

00:36:21,369 --> 00:36:28,569
rust then so that you can do the

00:36:24,069 --> 00:36:31,180
continuous updates etc so 1.9 has been

00:36:28,569 --> 00:36:33,880
released now like a few weeks ago and

00:36:31,180 --> 00:36:36,819
there are on a six-week release schedule

00:36:33,880 --> 00:36:39,130
so the next version of rust will be 1

00:36:36,819 --> 00:36:43,420
point 10 which will be released sometime

00:36:39,130 --> 00:36:46,599
in july i think i'm hoping to have at

00:36:43,420 --> 00:36:48,460
least the rust compiler ready to submit

00:36:46,599 --> 00:36:53,490
our hopefully accepted into tumbleweed

00:36:48,460 --> 00:36:53,490
by that time that's that's my my hope

00:36:55,829 --> 00:37:04,900
all right thank you Oh another question

00:36:59,680 --> 00:37:11,500
are there already some big software and

00:37:04,900 --> 00:37:13,420
written in rust yes so there is so the

00:37:11,500 --> 00:37:15,609
biggest project right now is the

00:37:13,420 --> 00:37:17,829
cerebral browser which is being built by

00:37:15,609 --> 00:37:21,279
Mozilla so this is the next version of

00:37:17,829 --> 00:37:23,230
Firefox where next means not the next

00:37:21,279 --> 00:37:26,069
version but sometime far far in the

00:37:23,230 --> 00:37:28,480
future so it's a whole new browser I

00:37:26,069 --> 00:37:30,460
think they've gotten pretty far in like

00:37:28,480 --> 00:37:31,839
standards compliance and so on but when

00:37:30,460 --> 00:37:35,039
it comes to like actual browser features

00:37:31,839 --> 00:37:37,509
its they still have a long way to go

00:37:35,039 --> 00:37:39,579
there's also i know there is something

00:37:37,509 --> 00:37:43,180
called habitat i think which is

00:37:39,579 --> 00:37:45,549
developed by the chef people's people

00:37:43,180 --> 00:37:47,710
make chef which is a part of chef

00:37:45,549 --> 00:37:49,450
somehow which is written in rust I don't

00:37:47,710 --> 00:37:52,019
know exactly I don't know anything about

00:37:49,450 --> 00:37:57,400
it and I'm I may have gotten the actual

00:37:52,019 --> 00:37:59,619
projects and details wrong as I think

00:37:57,400 --> 00:38:02,529
there are a few other like big projects

00:37:59,619 --> 00:38:04,150
but not anything very open like there

00:38:02,529 --> 00:38:06,549
are big companies using it but you

00:38:04,150 --> 00:38:08,380
haven't released anything publicly but

00:38:06,549 --> 00:38:10,509
there is a lot of interest in rust I

00:38:08,380 --> 00:38:13,569
mean it's it's still a very new language

00:38:10,509 --> 00:38:17,109
it's still being heavily developed so I

00:38:13,569 --> 00:38:19,240
mean if if I were going to develop

00:38:17,109 --> 00:38:22,460
something for production today I

00:38:19,240 --> 00:38:29,730
probably wouldn't use rust right now but

00:38:22,460 --> 00:38:34,280
soon I think it would be usable yeah all

00:38:29,730 --> 00:38:34,280

YouTube URL: https://www.youtube.com/watch?v=tMPbr4lyShg


