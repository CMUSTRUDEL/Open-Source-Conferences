Title: Improve the quality of Plasma with Wayland
Publication date: 2016-06-26
Playlist: openSUSE Conference 2016
Description: 
	https://media.ccc.de/v/1056-improve-the-quality-of-plasma-with-wayland

A talk from Martin Graesslin (one of the top Plasma developers) about how to Improve the quality of Plasma with Wayland

Richard Brown
Captions: 
	00:00:09,110 --> 00:00:15,860
okay so welcome to my talk about

00:00:12,840 --> 00:00:18,500
improving the quality of KDE plasma

00:00:15,860 --> 00:00:20,689
help of beylin this new veneering system

00:00:18,500 --> 00:00:22,820
which you can see in action here our

00:00:20,689 --> 00:00:25,009
motto at KD is a little bit violent

00:00:22,820 --> 00:00:26,450
we'll fix it if we have a problem we

00:00:25,009 --> 00:00:28,579
know Weiland will fix it

00:00:26,450 --> 00:00:30,439
multiscreen valiant bailant will fix it

00:00:28,579 --> 00:00:34,010
drags a trail and we'll fix it world

00:00:30,439 --> 00:00:41,960
peace valent we'll fix it so if there's

00:00:34,010 --> 00:00:44,750
a problem we have a solution so short

00:00:41,960 --> 00:00:47,149
about me I am Martin Wesleyan my email

00:00:44,750 --> 00:00:50,300
addresses I'm passing a KD torque

00:00:47,149 --> 00:00:53,060
I'm working for blue systems and a my

00:00:50,300 --> 00:00:55,840
I'm sponsored for working on Quinn

00:00:53,060 --> 00:00:59,930
Katie's plasma window manager and

00:00:55,840 --> 00:01:02,450
especially on the valent port a little

00:00:59,930 --> 00:01:05,479
bit about plasma plasma is Katie's

00:01:02,450 --> 00:01:07,280
desktop environment KDE is not a desktop

00:01:05,479 --> 00:01:09,710
environment Katie user community and

00:01:07,280 --> 00:01:12,920
plasma is the desktop environment of

00:01:09,710 --> 00:01:16,869
that community food users we are

00:01:12,920 --> 00:01:20,299
currently at version five six five and

00:01:16,869 --> 00:01:22,340
are about to release five point seven

00:01:20,299 --> 00:01:24,229
which I've heard will be the default

00:01:22,340 --> 00:01:27,200
desktop environment and the next

00:01:24,229 --> 00:01:29,360
openSUSE leap release we're currently at

00:01:27,200 --> 00:01:31,280
a three-months release schedule we used

00:01:29,360 --> 00:01:34,700
to be at six months now we are at three

00:01:31,280 --> 00:01:38,119
months so every three months there's a

00:01:34,700 --> 00:01:41,440
new release you can find us on hash

00:01:38,119 --> 00:01:44,450
plasma on IRC or on our mailing list and

00:01:41,440 --> 00:01:46,159
yes an X 11 windowing system but it's

00:01:44,450 --> 00:01:47,990
currently in the process of getting

00:01:46,159 --> 00:01:51,350
ported to Wayland it's actually working

00:01:47,990 --> 00:01:53,540
quite well already so a little bit about

00:01:51,350 --> 00:01:56,780
what I want to talk about in this

00:01:53,540 --> 00:01:58,729
presentation first of all I want to talk

00:01:56,780 --> 00:02:02,360
a little bit about our quality process

00:01:58,729 --> 00:02:04,430
in KDE in general and also in plasma

00:02:02,360 --> 00:02:07,850
then I want to talk a little bit about

00:02:04,430 --> 00:02:10,009
the problems of testing x11 testing x11

00:02:07,850 --> 00:02:13,840
if you don't have open QA I think open

00:02:10,009 --> 00:02:17,250
QA makes everything much much easier

00:02:13,840 --> 00:02:21,360
especially I want to talk about my

00:02:17,250 --> 00:02:23,250
how to test them window manager and then

00:02:21,360 --> 00:02:27,270
I want to talk a little bit about how

00:02:23,250 --> 00:02:29,460
valent changed the world how we can test

00:02:27,270 --> 00:02:31,500
in plasma how we can test our window

00:02:29,460 --> 00:02:33,450
manager how we can test our desktop

00:02:31,500 --> 00:02:35,790
shell and then a little bit about the

00:02:33,450 --> 00:02:39,030
future plans how we plan to extend all

00:02:35,790 --> 00:02:40,580
that what we've already implemented so

00:02:39,030 --> 00:02:44,520
let's start with our ecology act

00:02:40,580 --> 00:02:47,160
assurance process first of all I am

00:02:44,520 --> 00:02:49,860
taking a look at frameworks frameworks

00:02:47,160 --> 00:02:51,600
are the successor of the monolithic KD

00:02:49,860 --> 00:02:54,420
ellipse in KD 4 times

00:02:51,600 --> 00:02:57,630
it's nowadays 70 independent libraries

00:02:54,420 --> 00:03:00,620
built upon of uncute we have separated

00:02:57,630 --> 00:03:04,650
them and multiple tires with different

00:03:00,620 --> 00:03:06,810
dependency rules so we have tire 1 which

00:03:04,650 --> 00:03:09,060
is only depending on cute when we have a

00:03:06,810 --> 00:03:12,330
tire to you which depends on cued and

00:03:09,060 --> 00:03:15,420
tire worn frameworks entire 3 which can

00:03:12,330 --> 00:03:17,670
depend also on other tire 3 frameworks

00:03:15,420 --> 00:03:21,720
but of course no vesicular dependencies

00:03:17,670 --> 00:03:24,660
are allowed we are at a monthly release

00:03:21,720 --> 00:03:27,090
cycle as a monthly feature release cycle

00:03:24,660 --> 00:03:30,989
with no dedicated bug-fix releases and

00:03:27,090 --> 00:03:32,850
currently we are at release 523 which

00:03:30,989 --> 00:03:36,260
means at a monthly release cycle we are

00:03:32,850 --> 00:03:39,600
doing that now for 2 years now

00:03:36,260 --> 00:03:42,660
from a quality point of view this has

00:03:39,600 --> 00:03:45,239
quite immense implications we are in

00:03:42,660 --> 00:03:47,730
constant feature release cycle which

00:03:45,239 --> 00:03:49,709
means we cannot have box we are not

00:03:47,730 --> 00:03:53,670
allowed to introduce a bug in a

00:03:49,709 --> 00:03:55,709
framework but just doesn't work it also

00:03:53,670 --> 00:03:57,989
means we cannot tolerate half-baked

00:03:55,709 --> 00:04:00,930
features it's not like oh I want to get

00:03:57,989 --> 00:04:02,700
that in but it's not working yet no you

00:04:00,930 --> 00:04:04,890
cannot do that it has to wait till it's

00:04:02,700 --> 00:04:07,290
ready we can only integrate fully

00:04:04,890 --> 00:04:12,120
functional working code into frameworks

00:04:07,290 --> 00:04:14,580
and by reducing the development cycle to

00:04:12,120 --> 00:04:16,590
one month we took away the pressure to

00:04:14,580 --> 00:04:19,109
try to get something into a release

00:04:16,590 --> 00:04:21,660
because if you don't make it the next

00:04:19,109 --> 00:04:24,200
releases just a month previously was the

00:04:21,660 --> 00:04:27,590
next six months cycle it meant

00:04:24,200 --> 00:04:30,140
oh if I don't get it in now then it

00:04:27,590 --> 00:04:32,540
won't go into the steady release which

00:04:30,140 --> 00:04:34,750
are then picked by the distributions so

00:04:32,540 --> 00:04:38,480
if I'm missing half a year it means

00:04:34,750 --> 00:04:43,330
sometimes 1 to 1.5 years till it gets to

00:04:38,480 --> 00:04:45,920
the user and that was a huge problem and

00:04:43,330 --> 00:04:48,620
of course we have policies in place for

00:04:45,920 --> 00:04:51,350
frameworks we have the policy that our

00:04:48,620 --> 00:04:53,900
code must have auto test it must

00:04:51,350 --> 00:04:56,030
maintain binary compatibility if you've

00:04:53,900 --> 00:04:59,090
ever looked for rules of binary

00:04:56,030 --> 00:05:02,420
compatibility of C++ I've heard that KDE

00:04:59,090 --> 00:05:05,140
has the most comprehensive lifts of what

00:05:02,420 --> 00:05:07,730
is allowed and what not because KDE

00:05:05,140 --> 00:05:10,160
libraries do not only work on Linux and

00:05:07,730 --> 00:05:12,140
provide binary compatibility for Linux

00:05:10,160 --> 00:05:14,420
they also provide binary compatibility

00:05:12,140 --> 00:05:18,460
on Windows so for the microsoft

00:05:14,420 --> 00:05:21,920
microsoft visual studio compiler and OSX

00:05:18,460 --> 00:05:24,770
of course our commits are peer-reviewed

00:05:21,920 --> 00:05:27,890
and if our CI system has a failure it

00:05:24,770 --> 00:05:32,180
must be treated as a stop the line event

00:05:27,890 --> 00:05:35,810
so till the fix is till the failure is

00:05:32,180 --> 00:05:42,140
fixed no other commits may go into the

00:05:35,810 --> 00:05:44,390
framework now a little bit about the

00:05:42,140 --> 00:05:46,850
code review process and kitty

00:05:44,390 --> 00:05:49,760
first of all I have to say that every

00:05:46,850 --> 00:05:54,080
KDE contributor is allowed to commit to

00:05:49,760 --> 00:05:56,330
any repository of KDE without prior code

00:05:54,080 --> 00:05:56,840
review everybody has commit access to

00:05:56,330 --> 00:06:00,260
everything

00:05:56,840 --> 00:06:03,950
this means we cannot ensure on a

00:06:00,260 --> 00:06:06,140
technical level that we do code review

00:06:03,950 --> 00:06:08,920
it means we can only have a social

00:06:06,140 --> 00:06:11,300
contract and that's mostly kept

00:06:08,920 --> 00:06:13,220
sometimes it happens that people commit

00:06:11,300 --> 00:06:18,230
without review then but then they have

00:06:13,220 --> 00:06:22,700
to expect that they are shouted at the

00:06:18,230 --> 00:06:25,550
main website for code review is

00:06:22,700 --> 00:06:27,440
currently still review board at gate for

00:06:25,550 --> 00:06:30,140
a viewbot KDE dot are that got

00:06:27,440 --> 00:06:32,300
originally introduced by plasma and

00:06:30,140 --> 00:06:34,760
pretty quickly picked up by all other

00:06:32,300 --> 00:06:37,520
projects it's used but

00:06:34,760 --> 00:06:39,800
frameworks is using for code review we

00:06:37,520 --> 00:06:42,110
have also an old instance from the SVN

00:06:39,800 --> 00:06:45,410
times but we are also currently

00:06:42,110 --> 00:06:47,960
microwaving to fabricator plasma again

00:06:45,410 --> 00:06:52,460
an early adopter is already using

00:06:47,960 --> 00:06:56,150
fabricator and it's looking really good

00:06:52,460 --> 00:06:58,010
I'm used to bells now fabricator looks a

00:06:56,150 --> 00:06:59,810
little bit nicer seems to have a little

00:06:58,010 --> 00:07:03,560
bit better integration with the overall

00:06:59,810 --> 00:07:06,380
workflow so that's a good thing we also

00:07:03,560 --> 00:07:10,850
evaluated Garrett and the developers

00:07:06,380 --> 00:07:12,740
were not so happy with but but we are

00:07:10,850 --> 00:07:15,560
also used to Garrett because he uses

00:07:12,740 --> 00:07:18,680
Garrett and most KDE developers are also

00:07:15,560 --> 00:07:22,790
cute developers so that's also quite

00:07:18,680 --> 00:07:25,910
common to use then once we have our

00:07:22,790 --> 00:07:28,820
comet peer reviewed it gets committed

00:07:25,910 --> 00:07:31,550
and then it gives to our Jenkins

00:07:28,820 --> 00:07:34,070
instance there we have a build up for

00:07:31,550 --> 00:07:36,760
every master and stable branch of every

00:07:34,070 --> 00:07:40,520
repository which is quite a lot and

00:07:36,760 --> 00:07:42,950
whenever there is a commit the run is

00:07:40,520 --> 00:07:45,260
triggered which checks the build which

00:07:42,950 --> 00:07:48,290
runs the auto tests which are in the

00:07:45,260 --> 00:07:50,390
repository then if something does not

00:07:48,290 --> 00:07:53,530
work as expected it reports back and

00:07:50,390 --> 00:07:58,580
annoying ways which can be IRC messages

00:07:53,530 --> 00:08:05,000
it can be email RSS feed whatever so I

00:07:58,580 --> 00:08:08,030
think you all know Jenkins and so yeah

00:08:05,000 --> 00:08:10,250
and what's very nice we have multiple

00:08:08,030 --> 00:08:13,010
profiles in the build system so we can

00:08:10,250 --> 00:08:15,410
say ok I want to compile those projects

00:08:13,010 --> 00:08:21,170
twice with different compiler flags so

00:08:15,410 --> 00:08:23,480
that you can also cover a bit currently

00:08:21,170 --> 00:08:27,020
we perform the following checks we

00:08:23,480 --> 00:08:30,020
compile on Linux we do not yet compile

00:08:27,020 --> 00:08:31,880
on Android and we have currently after

00:08:30,020 --> 00:08:34,190
the run last print which we had last

00:08:31,880 --> 00:08:36,310
week more platforms and preparations who

00:08:34,190 --> 00:08:39,290
have heard that Android should be added

00:08:36,310 --> 00:08:41,279
there's talk about Windows of course not

00:08:39,290 --> 00:08:43,110
everything will work on window

00:08:41,279 --> 00:08:46,800
 will never be compiled on Windows

00:08:43,110 --> 00:08:49,980
but that's fine we have the auto test

00:08:46,800 --> 00:08:53,190
run we get a summary of the compiler

00:08:49,980 --> 00:08:56,810
warnings we have a sign features which

00:08:53,190 --> 00:09:02,519
check for heap use after free dissection

00:08:56,810 --> 00:09:04,709
so if we access memory which already got

00:09:02,519 --> 00:09:08,430
deleted viewing an auto test it will

00:09:04,709 --> 00:09:12,120
just abort and we have a nice build

00:09:08,430 --> 00:09:15,269
error not and build error test error we

00:09:12,120 --> 00:09:18,140
get code coverage and for the projects

00:09:15,269 --> 00:09:20,700
which use upstream there is also some

00:09:18,140 --> 00:09:22,709
tests performed I think there are for

00:09:20,700 --> 00:09:26,390
some projects a few more things which

00:09:22,709 --> 00:09:31,190
are performed but as I don't use that I

00:09:26,390 --> 00:09:33,510
don't really see that then in addition

00:09:31,190 --> 00:09:38,220
brand-new we also have a continuous

00:09:33,510 --> 00:09:40,860
delivery system that's neon so it just

00:09:38,220 --> 00:09:43,529
lots of the things that build KDE lot or

00:09:40,860 --> 00:09:46,800
already does but it also produces

00:09:43,529 --> 00:09:50,670
packages and built a dial a daily Iser

00:09:46,800 --> 00:09:53,970
and with that we can do actually test an

00:09:50,670 --> 00:09:56,670
integrated thing for a change which is

00:09:53,970 --> 00:09:58,279
not just the code you randomly have on

00:09:56,670 --> 00:10:01,110
your system but you can actually test

00:09:58,279 --> 00:10:03,270
similar to that as now what openSUSE of

00:10:01,110 --> 00:10:06,360
us with our gonna corrupt on that gives

00:10:03,270 --> 00:10:09,630
in the same direction but yeah neon as a

00:10:06,360 --> 00:10:13,140
KDE project directly so a little bit a

00:10:09,630 --> 00:10:17,220
different orchard so you now let's talk

00:10:13,140 --> 00:10:19,920
about testing x11 so my experience from

00:10:17,220 --> 00:10:24,000
working with Xcode for quite some time

00:10:19,920 --> 00:10:26,370
as that you cannot makamaka x11 if you

00:10:24,000 --> 00:10:28,860
want to have a unit test which accesses

00:10:26,370 --> 00:10:30,510
X and you want to mock X it's just not

00:10:28,860 --> 00:10:33,899
possible there are projects which have

00:10:30,510 --> 00:10:36,600
done it but my experiences it's too

00:10:33,899 --> 00:10:39,449
large so the expectation or something

00:10:36,600 --> 00:10:42,870
like 160 pages in addition you have

00:10:39,449 --> 00:10:45,260
extensions extensions X which replace

00:10:42,870 --> 00:10:48,329
core functionality extensions which

00:10:45,260 --> 00:10:49,640
replace extensions extensions which

00:10:48,329 --> 00:10:53,350
replace the previous

00:10:49,640 --> 00:10:58,640
of the same extensions so that's a lot

00:10:53,350 --> 00:11:01,820
then we have on top of that the ICC cm

00:10:58,640 --> 00:11:03,950
with another 60 pages of describing how

00:11:01,820 --> 00:11:05,960
an ex window manager and the

00:11:03,950 --> 00:11:08,660
communication should work we have the

00:11:05,960 --> 00:11:10,460
extended window manager hand and on top

00:11:08,660 --> 00:11:16,730
of that we have actually two libraries

00:11:10,460 --> 00:11:20,600
to mock X V and X level so mocking that

00:11:16,730 --> 00:11:22,940
has really really difficult in addition

00:11:20,600 --> 00:11:26,480
we have dependencies which pull in our

00:11:22,940 --> 00:11:28,910
acts without us even noticing especially

00:11:26,480 --> 00:11:32,030
back in the KT four times we had cute

00:11:28,910 --> 00:11:34,520
which just linked X we have cave in new

00:11:32,030 --> 00:11:37,510
system which linked X we have OpenGL

00:11:34,520 --> 00:11:40,430
which was defined to link X on Linux and

00:11:37,510 --> 00:11:44,390
of course any library using any of them

00:11:40,430 --> 00:11:46,730
so somehow you always get X and somehow

00:11:44,390 --> 00:11:50,360
you will always miss to mock something

00:11:46,730 --> 00:11:51,890
and yeah so my experience was when I

00:11:50,360 --> 00:11:54,290
always when I looked at it

00:11:51,890 --> 00:11:56,660
mocking is not possible we have to

00:11:54,290 --> 00:12:01,450
perform integration testing if we want

00:11:56,660 --> 00:12:03,980
to get anything tested so the normal

00:12:01,450 --> 00:12:06,950
integration test setup for x11 looks

00:12:03,980 --> 00:12:09,620
like that you run your experiment or fur

00:12:06,950 --> 00:12:11,750
on top of that you run open box as a

00:12:09,620 --> 00:12:18,280
window manager and then you use the X

00:12:11,750 --> 00:12:21,200
just extension to simulate input devices

00:12:18,280 --> 00:12:24,710
the problem with that is that X

00:12:21,200 --> 00:12:28,430
beautiful frame buffer is rather limited

00:12:24,710 --> 00:12:30,710
and way too restrictive restricted the

00:12:28,430 --> 00:12:34,520
same for access but accessed I can

00:12:30,710 --> 00:12:36,950
simulate mouse clicks and key presses

00:12:34,520 --> 00:12:44,080
I cannot simulate things like smooth

00:12:36,950 --> 00:12:47,420
crawling touch events etc so access is

00:12:44,080 --> 00:12:50,510
somewhere on the level from 10 15 years

00:12:47,420 --> 00:12:55,580
ago the more modern things were never

00:12:50,510 --> 00:12:58,820
edited with XF we be the biggest problem

00:12:55,580 --> 00:13:01,760
I noticed was the complete lack of GL x

00:12:58,820 --> 00:13:02,940
so I couldn't run OpenGL in a sensible

00:13:01,760 --> 00:13:05,700
way on top of it

00:13:02,940 --> 00:13:09,210
and expander was missing so in the

00:13:05,700 --> 00:13:12,000
latest version of x1 that we have in the

00:13:09,210 --> 00:13:15,870
latest version of X PFD we finally have

00:13:12,000 --> 00:13:19,200
X retina so that finally got fixed but

00:13:15,870 --> 00:13:22,620
it's still really really limited and not

00:13:19,200 --> 00:13:24,990
usable for proper testing because it can

00:13:22,620 --> 00:13:27,000
only do one resolution we cannot

00:13:24,990 --> 00:13:29,700
simulate the removal or adding of

00:13:27,000 --> 00:13:32,460
screens we don't get a physical size so

00:13:29,700 --> 00:13:35,780
anything which wants to calculate the

00:13:32,460 --> 00:13:38,400
DPI just won't work we don't even have a

00:13:35,780 --> 00:13:42,780
refresh sighs what did I write there a

00:13:38,400 --> 00:13:46,080
refresh rate say which reports a refresh

00:13:42,780 --> 00:13:49,110
rate of zero Hertz which is also far

00:13:46,080 --> 00:13:51,450
from the reality so I was surprised when

00:13:49,110 --> 00:13:52,980
I saw that it's just X render when I

00:13:51,450 --> 00:13:54,890
then looked at it I was disappointed

00:13:52,980 --> 00:13:59,430
again

00:13:54,890 --> 00:14:02,790
so why a simulating multi screen very

00:13:59,430 --> 00:14:04,650
important the big problem with the

00:14:02,790 --> 00:14:07,830
excellent extension is it's not atomic

00:14:04,650 --> 00:14:10,440
you get changes and unknown at atomic

00:14:07,830 --> 00:14:12,870
bay so for example you get a render

00:14:10,440 --> 00:14:14,580
event when you plug in a new screen then

00:14:12,870 --> 00:14:16,290
you have a demon reacting on that

00:14:14,580 --> 00:14:18,210
because it wants to set a proper

00:14:16,290 --> 00:14:23,940
resolution and the proper layout and you

00:14:18,210 --> 00:14:26,190
get more render event and whenever you

00:14:23,940 --> 00:14:28,320
act on a render event before you get the

00:14:26,190 --> 00:14:30,510
last one you are operating on

00:14:28,320 --> 00:14:33,390
intermediate state and the state you

00:14:30,510 --> 00:14:37,730
will should use will be wrong because

00:14:33,390 --> 00:14:40,020
the new ones are already queued and

00:14:37,730 --> 00:14:41,760
that's a little bit of a problem

00:14:40,020 --> 00:14:45,800
especially as we don't know when we will

00:14:41,760 --> 00:14:48,240
get the last render event so in Qin we

00:14:45,800 --> 00:14:51,060
introduced a ray like when we get the

00:14:48,240 --> 00:14:52,950
first render event we start a timer with

00:14:51,060 --> 00:14:56,370
100 milliseconds or something like that

00:14:52,950 --> 00:14:58,890
and on every render you want we restart

00:14:56,370 --> 00:15:00,600
the timer and we don't do anything till

00:14:58,890 --> 00:15:04,029
the time of high us

00:15:00,600 --> 00:15:06,819
so at that point we know okay we got the

00:15:04,029 --> 00:15:10,410
last rent a vent and so Quinn never

00:15:06,819 --> 00:15:13,329
operates on an incorrect state we either

00:15:10,410 --> 00:15:15,459
have the old state or the new one but

00:15:13,329 --> 00:15:18,249
not the ones in between where we would

00:15:15,459 --> 00:15:21,910
do scooper things like removing screens

00:15:18,249 --> 00:15:24,009
and then your window string or trying to

00:15:21,910 --> 00:15:28,269
run down on an output which doesn't

00:15:24,009 --> 00:15:31,269
exist so that work very well for Quinn

00:15:28,269 --> 00:15:34,149
over the last year so we have hardly got

00:15:31,269 --> 00:15:37,389
back reports about that this actually

00:15:34,149 --> 00:15:39,009
did not work and of course the EB

00:15:37,389 --> 00:15:41,259
timespan doesn't really matter because

00:15:39,009 --> 00:15:43,180
mostly the screens I'm out setting and

00:15:41,259 --> 00:15:44,980
up black anyway so you don't see

00:15:43,180 --> 00:15:48,939
anything on that remote setting takes

00:15:44,980 --> 00:15:52,959
much longer than our timer Co never want

00:15:48,939 --> 00:15:54,670
to do a little ex cruises to plasma 5

00:15:52,959 --> 00:15:57,610
and the multi screen problems so you

00:15:54,670 --> 00:16:00,069
might have had the experience when you

00:15:57,610 --> 00:16:03,490
tried plasma 5 that multi screen didn't

00:16:00,069 --> 00:16:05,860
work so how did that happen what went

00:16:03,490 --> 00:16:08,589
wrong after all in plasma for everything

00:16:05,860 --> 00:16:12,250
was fine the main problem is that q'd

00:16:08,589 --> 00:16:15,610
introduced a new Q screen API and then

00:16:12,250 --> 00:16:19,509
they decided to bound a Q screen to an

00:16:15,610 --> 00:16:21,670
x-ray on the screen and in addition a

00:16:19,509 --> 00:16:27,370
human no which represents a window on a

00:16:21,670 --> 00:16:29,230
screen belongs to a Kea screen and what

00:16:27,370 --> 00:16:31,809
then happened was a little bit

00:16:29,230 --> 00:16:33,970
unfortunate that if a Cuban now loses

00:16:31,809 --> 00:16:38,829
its Q screen the platform window gets

00:16:33,970 --> 00:16:41,379
destroyed so we had situation where the

00:16:38,829 --> 00:16:45,250
intermediate state meant we have no

00:16:41,379 --> 00:16:46,899
screens and now we'll be platform window

00:16:45,250 --> 00:16:49,959
gets destroyed and recreated

00:16:46,899 --> 00:16:52,990
okay that's nasty but still okay the

00:16:49,959 --> 00:16:55,300
windows just jump around we also had

00:16:52,990 --> 00:16:57,040
situations where the platform window

00:16:55,300 --> 00:16:59,499
gets destroyed and then we have another

00:16:57,040 --> 00:17:01,420
pointer dereference than the application

00:16:59,499 --> 00:17:04,689
crash that's probably what most people

00:17:01,420 --> 00:17:06,970
saw applications randomly crashing when

00:17:04,689 --> 00:17:08,770
you change the screens but all happened

00:17:06,970 --> 00:17:10,630
inside cutes killed

00:17:08,770 --> 00:17:13,409
it was never an error code it was all

00:17:10,630 --> 00:17:13,409
inside cute code

00:17:13,540 --> 00:17:18,650
unfortunately for us

00:17:15,020 --> 00:17:21,470
I still see crash reports with that they

00:17:18,650 --> 00:17:24,829
still come in with users of old cute

00:17:21,470 --> 00:17:29,290
versions mother opens use it but mostly

00:17:24,829 --> 00:17:31,730
I think Ubuntu is affected by that and

00:17:29,290 --> 00:17:34,220
what I also learned

00:17:31,730 --> 00:17:37,190
unfortunately that when all platform

00:17:34,220 --> 00:17:39,620
windows gets destroyed the app exits as

00:17:37,190 --> 00:17:42,170
all windows closed so the default

00:17:39,620 --> 00:17:45,230
behavior of cute as if all windows

00:17:42,170 --> 00:17:47,210
closed the app exit and that could be

00:17:45,230 --> 00:17:51,950
triggered by just removing all screens

00:17:47,210 --> 00:17:55,040
and that even caused a lock screen

00:17:51,950 --> 00:17:55,910
bypassed by disabling all screens that

00:17:55,040 --> 00:17:57,679
was something

00:17:55,910 --> 00:18:03,290
openSUSE actually found an open susan

00:17:57,679 --> 00:18:06,980
user reported you turn off all screens

00:18:03,290 --> 00:18:09,290
and the lock screen as bypassed it's

00:18:06,980 --> 00:18:10,760
really cute for two cute five regression

00:18:09,290 --> 00:18:12,530
because in queued for we never had a

00:18:10,760 --> 00:18:16,600
situation that we don't have any screens

00:18:12,530 --> 00:18:20,300
include five it could happen so yeah

00:18:16,600 --> 00:18:23,630
overall the user duration was very

00:18:20,300 --> 00:18:25,700
unfortunately because it could take the

00:18:23,630 --> 00:18:27,980
complete session down and we basically

00:18:25,700 --> 00:18:31,010
looked at it and had no chance to do

00:18:27,980 --> 00:18:32,000
anything about it because the problems

00:18:31,010 --> 00:18:34,370
were not in our code

00:18:32,000 --> 00:18:36,500
KDE people went to queued and fixed the

00:18:34,370 --> 00:18:39,500
code but it took time so the new

00:18:36,500 --> 00:18:43,820
releases came out and the fixes got in

00:18:39,500 --> 00:18:46,309
and also due to the crashes we actually

00:18:43,820 --> 00:18:49,580
didn't see the curve the tea box in our

00:18:46,309 --> 00:18:51,860
own code because they were covered by

00:18:49,580 --> 00:18:56,390
the crashes like the lock screen bypass

00:18:51,860 --> 00:19:00,050
it only happened after queued fixed the

00:18:56,390 --> 00:19:02,360
crashes because before the lock screen

00:19:00,050 --> 00:19:04,460
were just fresh and free start that was

00:19:02,360 --> 00:19:06,140
a condition we actually handled well we

00:19:04,460 --> 00:19:08,750
just were not able to handle the

00:19:06,140 --> 00:19:12,290
situation that all screens give away and

00:19:08,750 --> 00:19:14,690
the application exits so the current

00:19:12,290 --> 00:19:19,190
state is that was cute five five

00:19:14,690 --> 00:19:21,770
especially 55.1 most of the now pointer

00:19:19,190 --> 00:19:23,600
dereferences are fixed inside cute in

00:19:21,770 --> 00:19:25,669
addition since cute five six

00:19:23,600 --> 00:19:28,970
dummies cue screen is created if they

00:19:25,669 --> 00:19:31,760
are no expander outputs so the situation

00:19:28,970 --> 00:19:34,400
that there is no screen no longer exists

00:19:31,760 --> 00:19:36,710
but they are still a few problems we

00:19:34,400 --> 00:19:38,450
still the see that windows might get

00:19:36,710 --> 00:19:40,190
destroyed when an X render output is

00:19:38,450 --> 00:19:42,770
destroyed and we still see that

00:19:40,190 --> 00:19:45,860
sometimes windows jump around because of

00:19:42,770 --> 00:19:49,309
that and in my humble opinion that

00:19:45,860 --> 00:19:52,549
unfixable because it's broken by design

00:19:49,309 --> 00:19:55,340
a cue window should not be bound to an X

00:19:52,549 --> 00:19:58,370
render output that's not how X works on

00:19:55,340 --> 00:20:01,130
axial ways have a kind of screen even if

00:19:58,370 --> 00:20:03,470
you don't have outputs windows are bound

00:20:01,130 --> 00:20:06,320
to in position in the virtual screen and

00:20:03,470 --> 00:20:13,510
not bound to the position of them X went

00:20:06,320 --> 00:20:16,669
out but yeah and now back to the topic

00:20:13,510 --> 00:20:18,950
our experience over the years was that

00:20:16,669 --> 00:20:21,169
unit testing X when the code is not

00:20:18,950 --> 00:20:25,960
possible we wanted to do that for a long

00:20:21,169 --> 00:20:28,730
time but actually it's not possible and

00:20:25,960 --> 00:20:31,520
it's kind of realized on manual testing

00:20:28,730 --> 00:20:33,409
so you would have to have an outer test

00:20:31,520 --> 00:20:36,350
which tests and now please answer

00:20:33,409 --> 00:20:42,650
unblock the screen and that's not really

00:20:36,350 --> 00:20:45,169
feasible in addition a problem are the

00:20:42,650 --> 00:20:47,870
different for I was so over the last

00:20:45,169 --> 00:20:50,840
half year I saw changes in driver

00:20:47,870 --> 00:20:54,110
behavior quite often like I did not

00:20:50,840 --> 00:20:56,179
change anything that's my KDE or acute

00:20:54,110 --> 00:20:58,820
installation restarted the system and

00:20:56,179 --> 00:21:01,510
the behavior of how screens are handled

00:20:58,820 --> 00:21:05,299
by the intellect or Trevor changed

00:21:01,510 --> 00:21:09,770
change the pathways like didn't come up

00:21:05,299 --> 00:21:12,530
at all if you go into deep EMS paramedic

00:21:09,770 --> 00:21:16,460
safe it turns the screen off which is

00:21:12,530 --> 00:21:19,159
interesting than the treasures and yeah

00:21:16,460 --> 00:21:22,220
so that's something which you can hardly

00:21:19,159 --> 00:21:27,110
test you need to have tests which also

00:21:22,220 --> 00:21:29,030
consider the behavior of the drivers we

00:21:27,110 --> 00:21:31,580
actually have a few tests which try to

00:21:29,030 --> 00:21:34,210
do something like Quinn has a unit test

00:21:31,580 --> 00:21:36,880
which starts Xavier server

00:21:34,210 --> 00:21:38,620
with two outputs to at least test that

00:21:36,880 --> 00:21:43,870
we can handle the condition of two

00:21:38,620 --> 00:21:46,900
screens correctly and yeah and also for

00:21:43,870 --> 00:21:48,670
considering tests there are still

00:21:46,900 --> 00:21:52,750
systems out there which don't have X

00:21:48,670 --> 00:21:53,860
render so if you have something like VNC

00:21:52,750 --> 00:21:57,460
over X

00:21:53,860 --> 00:22:02,260
you might not have X Y at all and you

00:21:57,460 --> 00:22:07,570
should also test that because people are

00:22:02,260 --> 00:22:10,480
not pleased if that doesn't work so a

00:22:07,570 --> 00:22:11,710
little bit more about how testing x11

00:22:10,480 --> 00:22:16,750
code looks like

00:22:11,710 --> 00:22:18,820
so the code and KDE which interacts with

00:22:16,750 --> 00:22:20,850
x11 is really old

00:22:18,820 --> 00:22:26,410
it's from the times peculiar was still

00:22:20,850 --> 00:22:30,580
active and KDE so it's KDE one KDE -

00:22:26,410 --> 00:22:32,410
perhaps early kd3 so if you look at the

00:22:30,580 --> 00:22:34,480
code and then look at your changes and

00:22:32,410 --> 00:22:40,810
you see okay nobody touched that for 10

00:22:34,480 --> 00:22:42,760
years it's basically designed before

00:22:40,810 --> 00:22:45,670
concepts like unit testing or

00:22:42,760 --> 00:22:46,900
test-driven development we're coming

00:22:45,670 --> 00:22:51,570
over even known

00:22:46,900 --> 00:22:56,020
it's monolithic it doesn't have units

00:22:51,570 --> 00:22:58,360
it's not written with anything in mind

00:22:56,020 --> 00:22:59,950
which would not be x11 nobody thought

00:22:58,360 --> 00:23:06,070
about that there might be at some point

00:22:59,950 --> 00:23:08,410
Wayland but the code Brooks it's there

00:23:06,070 --> 00:23:13,950
for 10 years it's not getting touched it

00:23:08,410 --> 00:23:16,750
works so it's kind of tested by the age

00:23:13,950 --> 00:23:19,480
but it brings us to the point we how can

00:23:16,750 --> 00:23:22,270
we actually test it if we would want to

00:23:19,480 --> 00:23:24,550
unit test that we would have to refactor

00:23:22,270 --> 00:23:27,160
the code and that's in my opinion a very

00:23:24,550 --> 00:23:29,170
very bad idea because probably you're

00:23:27,160 --> 00:23:31,540
breaking more stuff by trying to

00:23:29,170 --> 00:23:36,190
refactor the code then you would gain by

00:23:31,540 --> 00:23:38,650
any test integration testing might be an

00:23:36,190 --> 00:23:40,720
idea if possible open QA might be a very

00:23:38,650 --> 00:23:45,580
good idea for such both code because you

00:23:40,720 --> 00:23:50,240
can then relatively easily test it

00:23:45,580 --> 00:23:52,640
so um on top of that how to test an X 11

00:23:50,240 --> 00:23:54,560
window manager so this is know a little

00:23:52,640 --> 00:23:56,900
bit describing the situation of twin

00:23:54,560 --> 00:23:59,240
before we started of the violent effort

00:23:56,900 --> 00:24:03,080
so we had a very monolithic architecture

00:23:59,240 --> 00:24:06,140
it didn't have any units we had one huge

00:24:03,080 --> 00:24:08,270
class which did everything it's best

00:24:06,140 --> 00:24:14,810
described by the anti pattern called the

00:24:08,270 --> 00:24:18,740
got pattern it completely relied on cute

00:24:14,810 --> 00:24:22,220
creating the X connection also it relied

00:24:18,740 --> 00:24:24,650
on cute creating windows which also

00:24:22,220 --> 00:24:28,160
meant but it cannot manage its own

00:24:24,650 --> 00:24:32,480
window so kuben is not able to create a

00:24:28,160 --> 00:24:35,330
window and management so if Quinn

00:24:32,480 --> 00:24:37,010
creates a window you will notice that it

00:24:35,330 --> 00:24:40,100
doesn't have window decorations because

00:24:37,010 --> 00:24:42,470
it cannot do that so when we went to

00:24:40,100 --> 00:24:45,230
Vale and we realized we need to reflect

00:24:42,470 --> 00:24:47,510
her because we needed to get away from

00:24:45,230 --> 00:24:51,770
this monolithic architecture which are

00:24:47,510 --> 00:24:54,170
thought about X and by refactoring us we

00:24:51,770 --> 00:24:56,960
created units and those could be tested

00:24:54,170 --> 00:25:00,980
so thanks to the refactoring we needed

00:24:56,960 --> 00:25:11,930
for Wayland we were finally able to unit

00:25:00,980 --> 00:25:13,520
test our code in areas but how does it

00:25:11,930 --> 00:25:15,380
look like with integration testing

00:25:13,520 --> 00:25:17,960
integration testing of a new manager is

00:25:15,380 --> 00:25:20,570
even more difficult than integration

00:25:17,960 --> 00:25:23,690
testing a normal x11 application because

00:25:20,570 --> 00:25:25,550
we can only have one window manager on a

00:25:23,690 --> 00:25:27,860
on an X herb

00:25:25,550 --> 00:25:30,590
so we would have to replace the window

00:25:27,860 --> 00:25:33,050
manager and then you if you would run

00:25:30,590 --> 00:25:36,830
the test on a developer system it would

00:25:33,050 --> 00:25:40,910
start to replace a normal window manager

00:25:36,830 --> 00:25:42,800
run the chest and then being a mute

00:25:40,910 --> 00:25:44,630
state because you cannot prepare the

00:25:42,800 --> 00:25:46,550
state's their window still around from

00:25:44,630 --> 00:25:48,410
the previous session and then how to get

00:25:46,550 --> 00:25:52,340
back to the normal window manager

00:25:48,410 --> 00:25:55,700
so it's only possible to test that in

00:25:52,340 --> 00:25:57,130
the context of xv-15 where we have the

00:25:55,700 --> 00:25:59,050
problems I just mentioned

00:25:57,130 --> 00:26:00,550
or we don't have GLX which we would

00:25:59,050 --> 00:26:03,010
really like to have we don't have X

00:26:00,550 --> 00:26:05,500
render especially in the times I'm

00:26:03,010 --> 00:26:11,170
talking about a few years back but just

00:26:05,500 --> 00:26:13,600
didn't have accessed so overall we also

00:26:11,170 --> 00:26:15,790
want to have a clean state if we want to

00:26:13,600 --> 00:26:17,680
test a window manager we want to be able

00:26:15,790 --> 00:26:19,780
to say okay we currently don't have been

00:26:17,680 --> 00:26:21,520
no no I create one it should people to

00:26:19,780 --> 00:26:24,310
Cynthia now I create the next one it

00:26:21,520 --> 00:26:27,270
should be positioned yeah so the clean

00:26:24,310 --> 00:26:30,100
state is really really important and

00:26:27,270 --> 00:26:33,610
that's really difficult to get if you

00:26:30,100 --> 00:26:36,400
try to do that in a test setup so

00:26:33,610 --> 00:26:40,840
basically we would have to start the X

00:26:36,400 --> 00:26:45,550
VfB from within the test and that's not

00:26:40,840 --> 00:26:48,850
possible with kids chess architecture so

00:26:45,550 --> 00:26:53,050
overall I had made the experiences that

00:26:48,850 --> 00:26:55,630
we cannot use the Q test framework for

00:26:53,050 --> 00:26:57,550
integration testing Quinn but that would

00:26:55,630 --> 00:26:59,650
be of course the one we would want to

00:26:57,550 --> 00:27:04,180
use because that's what our developers

00:26:59,650 --> 00:27:06,790
are familiar with so we had an idea

00:27:04,180 --> 00:27:08,950
evaluated in a bachelor thesis which was

00:27:06,790 --> 00:27:11,080
to create a dedicated framework for

00:27:08,950 --> 00:27:15,520
queuing which would start the required

00:27:11,080 --> 00:27:18,820
xvf be men would start Quinn on that xvf

00:27:15,520 --> 00:27:21,700
be inject a test script through Quinn's

00:27:18,820 --> 00:27:24,160
JavaScript API and then start helping

00:27:21,700 --> 00:27:26,800
implications to interact with us with

00:27:24,160 --> 00:27:28,990
the window manager and then to get the

00:27:26,800 --> 00:27:32,140
conditions in the script so the idea

00:27:28,990 --> 00:27:34,330
would be you create a window and the

00:27:32,140 --> 00:27:38,350
external process set it to full screen

00:27:34,330 --> 00:27:41,160
and your script verifies that window got

00:27:38,350 --> 00:27:44,110
created and that is put to full screen

00:27:41,160 --> 00:27:46,900
but overall we have never deployed that

00:27:44,110 --> 00:27:48,760
in production because it's - as in

00:27:46,900 --> 00:27:51,460
current because we are now not only

00:27:48,760 --> 00:27:53,440
talking between X and Quinn but also

00:27:51,460 --> 00:27:56,590
between X Quinn and the helper

00:27:53,440 --> 00:28:01,470
application and especially corner cases

00:27:56,590 --> 00:28:04,830
are not really testable with that and

00:28:01,470 --> 00:28:07,930
also when we had that framework

00:28:04,830 --> 00:28:09,170
evaluated I started to see a light at

00:28:07,930 --> 00:28:11,600
the end of the tunnel how

00:28:09,170 --> 00:28:15,290
can get better testing but the help of

00:28:11,600 --> 00:28:17,180
Ã¥land so the next thing I want to talk

00:28:15,290 --> 00:28:20,120
about is testing Covino system

00:28:17,180 --> 00:28:23,560
KB no system is our implementation of

00:28:20,120 --> 00:28:26,660
the extended window manager hints

00:28:23,560 --> 00:28:29,270
interestingly it does not depend on

00:28:26,660 --> 00:28:31,010
cutes x11 connection that's really

00:28:29,270 --> 00:28:33,260
important on that point because it made

00:28:31,010 --> 00:28:36,560
lots of things easier it's also not

00:28:33,260 --> 00:28:40,280
depending on cute Percy it's having an

00:28:36,560 --> 00:28:42,230
own implementation and what also made it

00:28:40,280 --> 00:28:44,780
much easier is that it doesn't perform

00:28:42,230 --> 00:28:47,840
any event processing by itself so

00:28:44,780 --> 00:28:49,460
instead you posit an excellent which was

00:28:47,840 --> 00:28:54,050
a property change or something like that

00:28:49,460 --> 00:28:56,720
and then it shows us as it and the

00:28:54,050 --> 00:29:01,490
support or cute five reported this

00:28:56,720 --> 00:29:05,420
framework from a clip tube xcb that was

00:29:01,490 --> 00:29:06,980
a huge change and I thought ok we are

00:29:05,420 --> 00:29:08,960
going to do that change which is the

00:29:06,980 --> 00:29:11,090
base of our window manager and we don't

00:29:08,960 --> 00:29:15,260
have tests for it no way I'm going to

00:29:11,090 --> 00:29:18,800
write the test for that so I went sir

00:29:15,260 --> 00:29:22,010
there and wrote test cases actually we

00:29:18,800 --> 00:29:24,080
did the port to xeb twice one developer

00:29:22,010 --> 00:29:26,600
did it I did it I wrote the tests

00:29:24,080 --> 00:29:28,100
against my implementation and then we

00:29:26,600 --> 00:29:31,690
swapped the implementation out and just

00:29:28,100 --> 00:29:34,700
used my implement a my test cases and

00:29:31,690 --> 00:29:36,950
what these tests you use what I have

00:29:34,700 --> 00:29:39,080
just described for our we would have one

00:29:36,950 --> 00:29:42,200
that you can have Quintessa it starts

00:29:39,080 --> 00:29:44,960
its own xvf be to have a clean state and

00:29:42,200 --> 00:29:47,480
then runs its test and these are very

00:29:44,960 --> 00:29:49,520
basic tests like creating a window

00:29:47,480 --> 00:29:54,430
setting a property on it and then verify

00:29:49,520 --> 00:29:57,620
that the property was set as we expected

00:29:54,430 --> 00:29:59,900
unfortunately it still allows the test

00:29:57,620 --> 00:30:04,370
methods to leak information into the

00:29:59,900 --> 00:30:06,710
next test case that was as I noticed

00:30:04,370 --> 00:30:08,810
that our implementation did not support

00:30:06,710 --> 00:30:12,370
multiple X servers so I could only

00:30:08,810 --> 00:30:15,050
connect to one X server at the time

00:30:12,370 --> 00:30:18,680
that's actually also changed because of

00:30:15,050 --> 00:30:22,050
Wayland so and but that I come to this

00:30:18,680 --> 00:30:25,930
topic what did we change with Wayland

00:30:22,050 --> 00:30:28,150
yeah first of all we are really

00:30:25,930 --> 00:30:30,280
unsatisfied with the testing

00:30:28,150 --> 00:30:33,070
capabilities of X and now that we are

00:30:30,280 --> 00:30:36,430
going to the new thing we want to is to

00:30:33,070 --> 00:30:39,670
fast fix our testing so we want to have

00:30:36,430 --> 00:30:42,670
proper multi-screen support which can be

00:30:39,670 --> 00:30:46,270
tested we want to have everything in the

00:30:42,670 --> 00:30:48,550
state that we can have unit tests that

00:30:46,270 --> 00:30:50,680
we can unit test it and we want to have

00:30:48,550 --> 00:30:54,850
better integration test capabilities

00:30:50,680 --> 00:30:57,460
than XV of B plus an open box it just X

00:30:54,850 --> 00:31:00,280
didn't work for us we have no the chance

00:30:57,460 --> 00:31:02,320
to to do it properly and we wanted to do

00:31:00,280 --> 00:31:09,100
that from the ride and do the planning

00:31:02,320 --> 00:31:10,630
with all of that in mind for our valent

00:31:09,100 --> 00:31:14,050
efforts we created a new framework

00:31:10,630 --> 00:31:18,310
that's K Wayland it's a tier one

00:31:14,050 --> 00:31:21,400
framework since five 25-22 so it's the

00:31:18,310 --> 00:31:24,640
latest framework to have been added to

00:31:21,400 --> 00:31:28,140
it so it was added last month but it had

00:31:24,640 --> 00:31:31,330
a previous life in plasma workspace

00:31:28,140 --> 00:31:35,110
basically it's a headless Weyland server

00:31:31,330 --> 00:31:39,790
api so it's an API which allows us to

00:31:35,110 --> 00:31:43,420
create a baling server and implement the

00:31:39,790 --> 00:31:45,490
protocols in a C++ styled manner an

00:31:43,420 --> 00:31:50,080
acute start manner to be precise and

00:31:45,490 --> 00:31:51,700
also to have the the contract described

00:31:50,080 --> 00:31:54,310
in the valent protocols implemented

00:31:51,700 --> 00:31:58,080
that's something like the balaam

00:31:54,310 --> 00:32:01,560
protocol specifies that if you pass

00:31:58,080 --> 00:32:05,410
keyboard focus to a surface the previous

00:32:01,560 --> 00:32:07,900
one should get a leaf event and the

00:32:05,410 --> 00:32:11,470
layer the library takes care of that to

00:32:07,900 --> 00:32:14,920
have it easily for the user of the

00:32:11,470 --> 00:32:17,890
library to just update keyboard focus

00:32:14,920 --> 00:32:20,020
the user of this library is mostly Kuen

00:32:17,890 --> 00:32:23,320
of course so we went for an approach

00:32:20,020 --> 00:32:25,210
like we had on x11 that the actual

00:32:23,320 --> 00:32:27,790
implementation of the things which make

00:32:25,210 --> 00:32:30,450
out a valence server is done in a

00:32:27,790 --> 00:32:33,070
framework so that ever other

00:32:30,450 --> 00:32:33,840
implementations could exist on it so if

00:32:33,070 --> 00:32:36,120
at some

00:32:33,840 --> 00:32:39,840
we say okay cue Anna's not doing it

00:32:36,120 --> 00:32:41,910
properly anymore we can write a new obey

00:32:39,840 --> 00:32:45,300
land server from scratch without having

00:32:41,910 --> 00:32:47,640
to rewrite everything what's very

00:32:45,300 --> 00:32:50,490
interesting about Kaiba land is that it

00:32:47,640 --> 00:32:53,040
also has a client library and the client

00:32:50,490 --> 00:32:57,600
library mostly exists only for testing

00:32:53,040 --> 00:33:01,800
purposes and what we achieved us a very

00:32:57,600 --> 00:33:04,230
very easy way to completely auto test K

00:33:01,800 --> 00:33:06,180
rail and we can easily create a balance

00:33:04,230 --> 00:33:08,460
however but exactly the things we want

00:33:06,180 --> 00:33:11,880
to have and then have a client connect

00:33:08,460 --> 00:33:17,970
to it and we can pretty much test every

00:33:11,880 --> 00:33:20,430
aspect of it so at the current point in

00:33:17,970 --> 00:33:23,720
time K Raymond of the library which has

00:33:20,430 --> 00:33:26,310
about 10,000 lines of client-side code

00:33:23,720 --> 00:33:28,830
12,000 line of server-side code and in

00:33:26,310 --> 00:33:31,590
about eleven thousand lines of outer

00:33:28,830 --> 00:33:34,500
test code and we have currently a test

00:33:31,590 --> 00:33:37,920
coverage of about 87% and the

00:33:34,500 --> 00:33:41,220
conditional coverage of about 65% the

00:33:37,920 --> 00:33:44,250
conditional coverage is so low because

00:33:41,220 --> 00:33:46,200
we have lots of assert especially in the

00:33:44,250 --> 00:33:48,480
client code and those we don't test

00:33:46,200 --> 00:33:50,520
obviously because otherwise our test

00:33:48,480 --> 00:33:53,370
would fail if we would go into an assert

00:33:50,520 --> 00:33:55,620
in the test so overall that's looking

00:33:53,370 --> 00:33:59,040
really good if we compare that to the

00:33:55,620 --> 00:34:01,710
x11 world and my experience lately is

00:33:59,040 --> 00:34:04,710
that if we have a balk we are able to

00:34:01,710 --> 00:34:07,020
create a test case for it so that's

00:34:04,710 --> 00:34:09,240
really good and also what I'm seeing is

00:34:07,020 --> 00:34:14,240
if we have a bug it's only not yet

00:34:09,240 --> 00:34:14,240
tested code or not yet test covered code

00:34:15,500 --> 00:34:22,080
so the first user of the covalent

00:34:18,990 --> 00:34:26,640
library was actually case green and not

00:34:22,080 --> 00:34:30,180
win because case win started to port to

00:34:26,640 --> 00:34:32,220
go to Whalen and wanted to test properly

00:34:30,180 --> 00:34:35,730
and that wanted to have a valency about

00:34:32,220 --> 00:34:38,250
which it can to connect to a way how to

00:34:35,730 --> 00:34:41,070
fake outputs like adding an output

00:34:38,250 --> 00:34:43,290
removing an output and what's really

00:34:41,070 --> 00:34:44,980
great about the tests in case green for

00:34:43,290 --> 00:34:48,220
Bay lenders but it can look

00:34:44,980 --> 00:34:51,220
as test data so you can describe or

00:34:48,220 --> 00:34:53,590
actually you can export the profiles you

00:34:51,220 --> 00:34:56,290
currently have like I have two screens

00:34:53,590 --> 00:34:58,119
with this resolution in this layout your

00:34:56,290 --> 00:35:01,330
exporter to test data invent you then

00:34:58,119 --> 00:35:04,030
you can tell us hey this one didn't work

00:35:01,330 --> 00:35:05,920
it did not do what it should do and we

00:35:04,030 --> 00:35:10,000
can put that into your test data and

00:35:05,920 --> 00:35:13,210
verify that it works and that also means

00:35:10,000 --> 00:35:15,460
that we can test the x11 code in

00:35:13,210 --> 00:35:17,380
directly by it because the shared

00:35:15,460 --> 00:35:21,670
functionality is now being tested

00:35:17,380 --> 00:35:25,200
through the veil and killed and what we

00:35:21,670 --> 00:35:28,869
think we did was doing X when de right

00:35:25,200 --> 00:35:33,450
we try to apply all the lessons we learn

00:35:28,869 --> 00:35:37,330
from X when we apply changes atomically

00:35:33,450 --> 00:35:43,119
we try to get feedback to K screen

00:35:37,330 --> 00:35:46,000
whenever something changes so if K

00:35:43,119 --> 00:35:48,460
screen requests the the outputs to be

00:35:46,000 --> 00:35:51,430
changed it sends a request to Quinn

00:35:48,460 --> 00:35:54,160
Quinn applies it and then sends back to

00:35:51,430 --> 00:35:57,220
hit to case when whether it worked or

00:35:54,160 --> 00:36:00,100
not if it didn't work it will revert to

00:35:57,220 --> 00:36:03,460
what was previously so it's no longer be

00:36:00,100 --> 00:36:07,660
we throw things at X render and see what

00:36:03,460 --> 00:36:14,500
sticks so that's a huge improvement for

00:36:07,660 --> 00:36:19,000
K screen so in Quinn we also had a few

00:36:14,500 --> 00:36:21,520
changes you to go into Wayland we had a

00:36:19,000 --> 00:36:24,100
few of the testing blockers removed we

00:36:21,520 --> 00:36:27,640
don't depend on cutes x11 connection

00:36:24,100 --> 00:36:31,180
anymore it's it's now recreating our own

00:36:27,640 --> 00:36:35,650
x11 connection and only on x11 we use

00:36:31,180 --> 00:36:37,960
the x11 connection provided by cute if

00:36:35,650 --> 00:36:42,340
you want stand alone on x11 so the

00:36:37,960 --> 00:36:43,960
normal old Qin we need to be able to

00:36:42,340 --> 00:36:46,960
connect to multiple X service that's

00:36:43,960 --> 00:36:49,000
very important in the test so in the

00:36:46,960 --> 00:36:49,840
developer workflow because we want to

00:36:49,000 --> 00:36:51,970
have a nest

00:36:49,840 --> 00:36:54,490
Quinn and this nested Quinn has to

00:36:51,970 --> 00:36:56,800
render tuned to the normal X server

00:36:54,490 --> 00:36:58,630
that's 1x connection and it has to have

00:36:56,800 --> 00:37:01,600
an X Wayland that's a different X

00:36:58,630 --> 00:37:05,080
connection so we actually had to remove

00:37:01,600 --> 00:37:08,530
the problem we had in the KB no system

00:37:05,080 --> 00:37:10,990
library that Nets WM only supported 1x

00:37:08,530 --> 00:37:13,510
server we had to remove that so that we

00:37:10,990 --> 00:37:17,350
can have Quentin probably running with

00:37:13,510 --> 00:37:20,200
multiple X servers and of course lots of

00:37:17,350 --> 00:37:22,090
the x11 specific code got reflected to

00:37:20,200 --> 00:37:25,570
the manuring system independent and

00:37:22,090 --> 00:37:27,640
those areas can now be tested we can we

00:37:25,570 --> 00:37:33,190
have created unit tests for them on x11

00:37:27,640 --> 00:37:37,030
and also for Wayland in addition we

00:37:33,190 --> 00:37:40,360
created some obstructions inside Quinn

00:37:37,030 --> 00:37:42,700
do you have the rendering and the input

00:37:40,360 --> 00:37:47,350
handling that from specific so we

00:37:42,700 --> 00:37:49,210
currently have a few specific specific

00:37:47,350 --> 00:37:51,850
plug-ins for that we have an X 11 plugin

00:37:49,210 --> 00:37:54,880
which can be used for an essex rendering

00:37:51,850 --> 00:37:58,690
or as a standalone say also the normal

00:37:54,880 --> 00:38:02,620
Quinn on X 11 nowadays loads the plug-in

00:37:58,690 --> 00:38:04,240
for the platform API abstraction we have

00:38:02,620 --> 00:38:07,240
a valent rendering back-end which is

00:38:04,240 --> 00:38:09,250
also again just nested we have for

00:38:07,240 --> 00:38:10,960
direct rendering management you also

00:38:09,250 --> 00:38:14,590
have a frame buffer device but that

00:38:10,960 --> 00:38:17,710
might get removed again and we are able

00:38:14,590 --> 00:38:24,340
to run on Android hardware composer with

00:38:17,710 --> 00:38:27,580
the help of lip Hybris in that I just

00:38:24,340 --> 00:38:29,800
already mentioned so yeah the we were

00:38:27,580 --> 00:38:32,590
able to change the Covino system and

00:38:29,800 --> 00:38:34,660
also adjusted all the outer tests so

00:38:32,590 --> 00:38:37,690
that every test method now gets its own

00:38:34,660 --> 00:38:44,590
x over that you don't have informations

00:38:37,690 --> 00:38:47,530
leaked into the next test and what was

00:38:44,590 --> 00:38:50,320
really a important change was done

00:38:47,530 --> 00:38:52,390
somewhere October November is last year

00:38:50,320 --> 00:38:54,910
is the introduction of a virtual

00:38:52,390 --> 00:38:57,430
platform plugin this visual platform

00:38:54,910 --> 00:38:58,690
plugin does not perform any rendering

00:38:57,430 --> 00:39:03,880
see it just

00:38:58,690 --> 00:39:07,180
whereas into a cue painter kapenta

00:39:03,880 --> 00:39:09,430
object or empty actually a cue image

00:39:07,180 --> 00:39:12,430
with the help of cue painter or into a

00:39:09,430 --> 00:39:16,720
beautiful frame buffer on beautiful

00:39:12,430 --> 00:39:20,020
rendering device and that we are able to

00:39:16,720 --> 00:39:23,650
run Quinn on a server which doesn't have

00:39:20,020 --> 00:39:25,680
a real screen and if we are able to run

00:39:23,650 --> 00:39:28,840
it on a server we are able to run it in

00:39:25,680 --> 00:39:32,410
our CI system so that's what we actually

00:39:28,840 --> 00:39:36,880
did we build up a test framework for

00:39:32,410 --> 00:39:41,710
Quinn which we can use now in our auto

00:39:36,880 --> 00:39:44,140
test and this test framework allows us

00:39:41,710 --> 00:39:46,930
to start the complete quinn including at

00:39:44,140 --> 00:39:51,060
Suellen including the compositor the

00:39:46,930 --> 00:39:54,310
effects everything we have and just

00:39:51,060 --> 00:39:57,400
don't render to real Hardware render

00:39:54,310 --> 00:39:59,200
into virtual devices and the sir gives

00:39:57,400 --> 00:40:01,330
us a possibility to have a complete

00:39:59,200 --> 00:40:04,000
introspection into our window manager

00:40:01,330 --> 00:40:05,950
and from there we can now create x

00:40:04,000 --> 00:40:10,330
windows and valent windows try to manage

00:40:05,950 --> 00:40:12,990
them verify what we did like did the

00:40:10,330 --> 00:40:16,510
strut on a panel get applied correctly

00:40:12,990 --> 00:40:18,490
we can add multi-screen like we want we

00:40:16,510 --> 00:40:21,100
can add screens we can remove screens

00:40:18,490 --> 00:40:25,900
and we can verify that inside rim that

00:40:21,100 --> 00:40:27,670
all works correctly so that's a huge

00:40:25,900 --> 00:40:29,800
game-changer for the development in

00:40:27,670 --> 00:40:31,840
cyclin because that's something I have

00:40:29,800 --> 00:40:34,630
dreamed of for years to be able to

00:40:31,840 --> 00:40:37,930
actually test whether Quinn when

00:40:34,630 --> 00:40:39,970
managers are window correctly and that

00:40:37,930 --> 00:40:43,090
also showed already that if he got a

00:40:39,970 --> 00:40:45,580
crash reported I was able to create test

00:40:43,090 --> 00:40:47,260
cases for that and fix it and now it

00:40:45,580 --> 00:40:51,460
will never happen again because now we

00:40:47,260 --> 00:40:53,440
have a test case so overall that means

00:40:51,460 --> 00:40:56,650
we are now able to do test-driven

00:40:53,440 --> 00:40:59,140
development inside Quinn

00:40:56,650 --> 00:41:02,920
I must say that Quinn had already a very

00:40:59,140 --> 00:41:04,750
good quality before it's not that we

00:41:02,920 --> 00:41:06,790
didn't have any quality at all so don't

00:41:04,750 --> 00:41:08,920
get that wrong just because we were not

00:41:06,790 --> 00:41:10,700
able to do test-driven development but

00:41:08,920 --> 00:41:13,760
overall over the last few

00:41:10,700 --> 00:41:17,300
I've added something like 7,000 lines of

00:41:13,760 --> 00:41:19,490
test code the new input handling code

00:41:17,300 --> 00:41:21,920
which we wrote for Weiland is completely

00:41:19,490 --> 00:41:24,890
under test coverage this includes that

00:41:21,920 --> 00:41:29,420
we have all the lockscreen situations

00:41:24,890 --> 00:41:31,430
completely tested so we actually know

00:41:29,420 --> 00:41:34,340
from our test cases that it's not

00:41:31,430 --> 00:41:41,630
possible that input events go to a

00:41:34,340 --> 00:41:44,000
window if the screen is lock what's also

00:41:41,630 --> 00:41:46,340
nice about this new framework us that we

00:41:44,000 --> 00:41:48,680
can from there start cute applications

00:41:46,340 --> 00:41:51,710
which then use cute Balin and with that

00:41:48,680 --> 00:41:54,470
we can actually also how to test cute

00:41:51,710 --> 00:41:57,470
code so if we see a big problem include

00:41:54,470 --> 00:42:00,050
we can create test cases for it inside

00:41:57,470 --> 00:42:06,320
our test framework and include that into

00:42:00,050 --> 00:42:08,840
our tests we currently those has a few

00:42:06,320 --> 00:42:11,120
limitations because we cannot test our

00:42:08,840 --> 00:42:13,490
x11 only killed so everything which is

00:42:11,120 --> 00:42:15,800
in our x11 standalone plug it cannot be

00:42:13,490 --> 00:42:17,600
tested by that which means we cannot

00:42:15,800 --> 00:42:19,780
test our extra inner compositor

00:42:17,600 --> 00:42:25,310
which means we cannot test the GL x

00:42:19,780 --> 00:42:27,410
compositor and creating x11 witness in

00:42:25,310 --> 00:42:30,080
the test case is a little bit cumbersome

00:42:27,410 --> 00:42:32,360
because we cannot use Guilford cute

00:42:30,080 --> 00:42:34,970
versus the platform plugin which is not

00:42:32,360 --> 00:42:37,520
xeb in the case of growing on valent so

00:42:34,970 --> 00:42:40,580
that's a little bit unfortunate but we

00:42:37,520 --> 00:42:46,070
have been at me WM classes which have us

00:42:40,580 --> 00:42:48,320
a little bit there so in addition

00:42:46,070 --> 00:42:51,020
brand-new in the latest framework

00:42:48,320 --> 00:42:57,350
release we have no avail and beautiful

00:42:51,020 --> 00:43:01,220
frame buffer test server we cannot start

00:42:57,350 --> 00:43:05,480
the K valent based testing which I

00:43:01,220 --> 00:43:09,440
presented previously in all cases so if

00:43:05,480 --> 00:43:11,450
you have an test which would depend on Q

00:43:09,440 --> 00:43:13,610
GUI application or Q application being

00:43:11,450 --> 00:43:15,500
created we have a dependency loop

00:43:13,610 --> 00:43:17,270
because it will try to connect to the

00:43:15,500 --> 00:43:19,230
valence server which you are about to

00:43:17,270 --> 00:43:23,250
start so that cannot work

00:43:19,230 --> 00:43:24,960
and then we just went into a situation

00:43:23,250 --> 00:43:29,010
but the application freezes

00:43:24,960 --> 00:43:31,080
I have gone but come through that with

00:43:29,010 --> 00:43:33,450
my Valen porting because I were

00:43:31,080 --> 00:43:38,820
they in this situation so I knew that

00:43:33,450 --> 00:43:42,060
cannot work and now with cable and 5:23

00:43:38,820 --> 00:43:44,130
we have a very very small binary which

00:43:42,060 --> 00:43:49,170
can be integrated to see Megan C test

00:43:44,130 --> 00:43:51,960
and all it does is it starts the server

00:43:49,170 --> 00:43:55,050
through a CMA command and then the

00:43:51,960 --> 00:43:58,920
server once it has completely started

00:43:55,050 --> 00:44:02,600
itself will start a test binary and then

00:43:58,920 --> 00:44:05,520
report back the result code of the test

00:44:02,600 --> 00:44:09,420
so what it supports is currently

00:44:05,520 --> 00:44:13,619
creating Windows faking input events so

00:44:09,420 --> 00:44:18,840
it's on the level of x VF v but we plan

00:44:13,619 --> 00:44:20,930
to extend that so with that I come to

00:44:18,840 --> 00:44:24,750
what we want to do in the future

00:44:20,930 --> 00:44:29,310
first of all I want to mention a problem

00:44:24,750 --> 00:44:31,410
which we have on our build Kelly dark ok

00:44:29,310 --> 00:44:33,770
de la dark run circles containers and

00:44:31,410 --> 00:44:37,230
there we don't happen trid wise and

00:44:33,770 --> 00:44:39,990
Quinn tries to do egl initialize without

00:44:37,230 --> 00:44:43,020
a DI device and that fails horribly and

00:44:39,990 --> 00:44:48,150
so we are forced to use the queue

00:44:43,020 --> 00:44:51,180
painter compositor for our tests on Berk

00:44:48,150 --> 00:44:55,660
a.org but we have actually a few tests

00:44:51,180 --> 00:44:58,450
which would need OpenGL so those half

00:44:55,660 --> 00:45:01,030
the cue skip currently and the code to

00:44:58,450 --> 00:45:05,410
ensure that they don't crash on the CIA

00:45:01,030 --> 00:45:09,310
system and don't shadow by showing

00:45:05,410 --> 00:45:11,950
warnings that tests fail and what a

00:45:09,310 --> 00:45:14,410
little bit of bigger problem is that we

00:45:11,950 --> 00:45:16,600
don't get any cute quick videos to show

00:45:14,410 --> 00:45:18,460
because cute quick terminates the

00:45:16,600 --> 00:45:23,260
application if it cannot create an

00:45:18,460 --> 00:45:26,200
OpenGL context so we cannot start any

00:45:23,260 --> 00:45:28,870
cute quick applications from this in

00:45:26,200 --> 00:45:32,650
Quinn's test framework which means we

00:45:28,870 --> 00:45:36,370
cannot start plasma to verify word so

00:45:32,650 --> 00:45:39,580
that's a big problem if anybody has

00:45:36,370 --> 00:45:42,940
ideas how we can get ETL initialize and

00:45:39,580 --> 00:45:44,980
measure work on in a docker container

00:45:42,940 --> 00:45:49,810
please tell us because we are pretty

00:45:44,980 --> 00:45:52,750
much clueless so what we want to do is

00:45:49,810 --> 00:45:55,870
extend our cable and test server

00:45:52,750 --> 00:45:58,720
currently there's only one test case so

00:45:55,870 --> 00:46:01,630
far which users but we want to be able

00:45:58,720 --> 00:46:04,510
to verify everything we use in cable no

00:46:01,630 --> 00:46:06,280
system also we want to use it for our

00:46:04,510 --> 00:46:11,050
own new task manager library which we

00:46:06,280 --> 00:46:14,470
introduced in plasma 5 7 and want to

00:46:11,050 --> 00:46:17,500
integrate this into further framework to

00:46:14,470 --> 00:46:20,340
have all the tests run twice so we

00:46:17,500 --> 00:46:23,260
normally have tests which run on x11 and

00:46:20,340 --> 00:46:25,750
we can very easily but this framework

00:46:23,260 --> 00:46:28,240
also run them on valent and by that just

00:46:25,750 --> 00:46:34,480
get a higher test coverage for the code

00:46:28,240 --> 00:46:36,460
and also 4k Rayland and also what I want

00:46:34,480 --> 00:46:38,350
to use it is test the hell out of the

00:46:36,460 --> 00:46:41,430
cute Wayland client library because it

00:46:38,350 --> 00:46:47,920
currently still has a few problems and

00:46:41,430 --> 00:46:49,600
these are not are annoying me also we

00:46:47,920 --> 00:46:53,080
would like to build up a test framework

00:46:49,600 --> 00:46:55,510
for plasma so the idea is to take what

00:46:53,080 --> 00:46:58,180
we have for Quinn and make it usable for

00:46:55,510 --> 00:47:00,580
plasma as well so that we can start

00:46:58,180 --> 00:47:04,339
plasma so the complete desktop session

00:47:00,580 --> 00:47:07,039
in the context of Quinn's test framework

00:47:04,339 --> 00:47:09,859
then have an IPC mesh investment mention

00:47:07,039 --> 00:47:13,309
isn't to verify the internals of current

00:47:09,859 --> 00:47:15,109
like plasma creates a panel and we want

00:47:13,309 --> 00:47:18,880
to see whether the panel actually got

00:47:15,109 --> 00:47:23,839
created and has only no manager side the

00:47:18,880 --> 00:47:25,910
positions we X we expect so that's kind

00:47:23,839 --> 00:47:28,999
of going into the area but open QA is

00:47:25,910 --> 00:47:30,890
also doing so maybe open QA will be the

00:47:28,999 --> 00:47:34,849
better choice that does something we

00:47:30,890 --> 00:47:37,249
still have to evaluate especially if we

00:47:34,849 --> 00:47:39,529
consider that we could take screenshot

00:47:37,249 --> 00:47:42,319
with it there we are getting an overlap

00:47:39,529 --> 00:47:46,029
so that's probably something to look

00:47:42,319 --> 00:47:48,529
into what is the better choice here and

00:47:46,029 --> 00:47:51,799
with that I am at the end of my

00:47:48,529 --> 00:47:53,210
presentation I still have a few minutes

00:47:51,799 --> 00:47:56,499
for questions so if you have any

00:47:53,210 --> 00:47:56,499
questions please ask

00:48:17,010 --> 00:48:20,330
doesn't work apparently

00:48:25,859 --> 00:48:32,940
just currently in openSUSE des the

00:48:29,420 --> 00:48:35,430
curtain image with valence a lot what

00:48:32,940 --> 00:48:38,130
would we need to do to be able to test

00:48:35,430 --> 00:48:43,019
it with open cue a which basically means

00:48:38,130 --> 00:48:46,289
getting it to work in Huy mu oh good

00:48:43,019 --> 00:48:51,690
question I don't know what would be

00:48:46,289 --> 00:48:53,160
needed to get it running so with the

00:48:51,690 --> 00:48:54,900
vehicle back and you probably would

00:48:53,160 --> 00:48:58,589
already get it running without any

00:48:54,900 --> 00:49:02,039
changes with QE mu you probably depends

00:48:58,589 --> 00:49:06,150
on whether you have GPU which is capable

00:49:02,039 --> 00:49:08,549
of - of doing da mo not not really open

00:49:06,150 --> 00:49:12,269
QA or visas are currently uses the

00:49:08,549 --> 00:49:15,690
sibyl's back-end so there is basically

00:49:12,269 --> 00:49:17,579
only earth frame buffer okay when you

00:49:15,690 --> 00:49:19,499
could use the frame of a back-end of

00:49:17,579 --> 00:49:22,289
clinton but when you don't have OpenGL

00:49:19,499 --> 00:49:27,119
and then me about cute quick born like

00:49:22,289 --> 00:49:30,650
that wasn't there to plan to support

00:49:27,119 --> 00:49:34,670
aids of the when doing and in cubes

00:49:30,650 --> 00:49:37,380
sorry I didn't get a request too noisy I

00:49:34,670 --> 00:49:38,910
think there was the idea to have a

00:49:37,380 --> 00:49:46,079
software when they went back and

00:49:38,910 --> 00:49:49,769
you - in right in implant in cute 5 7

00:49:46,079 --> 00:49:54,569
there is never cute quick software and

00:49:49,769 --> 00:49:59,339
Nara but that doesn't work for anything

00:49:54,569 --> 00:50:03,119
which actually expects OpenGL so code

00:49:59,339 --> 00:50:05,549
needs to be adjusted and yeah that will

00:50:03,119 --> 00:50:08,190
happen now that q5 7 is out I expect

00:50:05,549 --> 00:50:10,859
that KDE code will work on that

00:50:08,190 --> 00:50:13,229
but yeah if you want to actually test at

00:50:10,859 --> 00:50:16,079
an open QA you would want to test the

00:50:13,229 --> 00:50:19,019
real thing not just the software fall

00:50:16,079 --> 00:50:22,769
back but just exactly the problem I have

00:50:19,019 --> 00:50:24,209
here with but the egl initialize failing

00:50:22,769 --> 00:50:26,130
it I don't want to test the software

00:50:24,209 --> 00:50:30,180
fall back I want to test the OpenGL

00:50:26,130 --> 00:50:31,980
stack no you mentioned that you would

00:50:30,180 --> 00:50:34,860
want to develop different

00:50:31,980 --> 00:50:37,080
backhand and clean but you still do that

00:50:34,860 --> 00:50:43,770
if it's the only way to get it to work

00:50:37,080 --> 00:50:46,080
in QEMU and possibly then that for that

00:50:43,770 --> 00:50:48,060
is definitely a use case if that's the

00:50:46,080 --> 00:50:49,980
only way then we will keep the backend I

00:50:48,060 --> 00:50:51,930
mean it's not a lot of code that's

00:50:49,980 --> 00:50:54,390
something about one thousand lines of

00:50:51,930 --> 00:50:57,720
code it's not really expensive to keep

00:50:54,390 --> 00:51:00,900
it it's just for me there was a question

00:50:57,720 --> 00:51:03,210
does it make sense if you have a DRM

00:51:00,900 --> 00:51:05,190
device which can also be used for

00:51:03,210 --> 00:51:06,810
software engineering even if you don't

00:51:05,190 --> 00:51:08,490
have OpenGL doesn't make sense to have

00:51:06,810 --> 00:51:11,990
the frame buffer backing if they use

00:51:08,490 --> 00:51:15,950
cases for it I'm all for keeping it okay

00:51:11,990 --> 00:51:15,950
we have a question back there

00:51:21,650 --> 00:51:29,910
so just equipment about open QA and

00:51:26,460 --> 00:51:33,780
output gln software rendering currently

00:51:29,910 --> 00:51:37,530
we are using eleven pipe acceleration

00:51:33,780 --> 00:51:43,280
with Messer and an open QA is running

00:51:37,530 --> 00:51:47,550
used usually using the series software

00:51:43,280 --> 00:51:51,420
rendering so it means that cute and k

00:51:47,550 --> 00:51:54,060
with killing could perfectly run using

00:51:51,420 --> 00:51:58,740
the OpenGL back-end and then we would

00:51:54,060 --> 00:52:02,250
run using the software abolition of meza

00:51:58,740 --> 00:52:05,550
but at least you would test some open GL

00:52:02,250 --> 00:52:10,050
code of cute only if we get to that

00:52:05,550 --> 00:52:12,150
point so that's what we also tried to

00:52:10,050 --> 00:52:13,680
use a lot of the Empire and we didn't

00:52:12,150 --> 00:52:15,930
get to the point that may as I actually

00:52:13,680 --> 00:52:18,660
try to use a little bit M type it fails

00:52:15,930 --> 00:52:21,660
before it fails on the egl initialized

00:52:18,660 --> 00:52:25,910
call and at that point we are not very

00:52:21,660 --> 00:52:32,580
it would decide to use our vm pipe and

00:52:25,910 --> 00:52:36,990
the same with well cute code actually

00:52:32,580 --> 00:52:40,020
should work then but yeah we never got

00:52:36,990 --> 00:52:42,420
to the point but LLVM pipe would would

00:52:40,020 --> 00:52:45,660
even show up it is it's failing before

00:52:42,420 --> 00:52:48,330
yeah I can see it says you need to I

00:52:45,660 --> 00:52:50,960
mean we might need to work on site

00:52:48,330 --> 00:52:53,610
because we are able to use that for the

00:52:50,960 --> 00:53:07,230
genome testing and there is no reason

00:52:53,610 --> 00:53:09,120
why it wouldn't work for kit looks like

00:53:07,230 --> 00:53:11,540
they are no more question so thank you

00:53:09,120 --> 00:53:11,540

YouTube URL: https://www.youtube.com/watch?v=s8XiEyGVKcI


