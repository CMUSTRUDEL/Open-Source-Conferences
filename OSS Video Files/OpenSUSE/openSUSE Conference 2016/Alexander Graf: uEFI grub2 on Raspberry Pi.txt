Title: Alexander Graf: uEFI grub2 on Raspberry Pi
Publication date: 2016-06-26
Playlist: openSUSE Conference 2016
Description: 
	https://media.ccc.de/v/946-uefi-grub2-on-raspberry-pi

Booting is hard. Booting in the ARM world is even harder. State of the art are a dozen different boot loaders that may or may not deserve that name. Each gets configured differently and each has its own pros and cons.

As a distribution this is a nightmare. Configuring each and every one of them complicates code that really should be very simple.

To solve the problem, we can just add another layer of abstraction (grub2) on top of another layer of abstraction (uEFI) on top of another layer of abstraction (u-boot). Follow me on a journey on how all those layers can make life easier for the distribution and how much fun uEFI really is.

After this talk, you will know how ARM systems boot, what uEFI really means, how uEFI binaries interact with firmware and how we are going to move to uEFI based boot on openSUSE for ARM.

Alexander Graf
Captions: 
	00:00:07,950 --> 00:00:13,930
hello and welcome to my amazing talk

00:00:10,990 --> 00:00:16,990
about running every password you could

00:00:13,930 --> 00:00:20,759
possibly hear in a single device if I go

00:00:16,990 --> 00:00:20,759
up to raspberry all at once

00:00:21,180 --> 00:00:26,829
sumaya might extend the graph this time

00:00:23,829 --> 00:00:27,700
for wheel David was just thinking to be

00:00:26,829 --> 00:00:29,770
me

00:00:27,700 --> 00:00:31,599
I'm usually a KVM and keep me developer

00:00:29,770 --> 00:00:33,820
you might have seen me from things like

00:00:31,599 --> 00:00:38,020
Bonnie and KVM in KVM whining I was

00:00:33,820 --> 00:00:40,330
tending KVM doing KVM and power think

00:00:38,020 --> 00:00:42,730
things that people usually seem to take

00:00:40,330 --> 00:00:43,930
us granted these days but this time

00:00:42,730 --> 00:00:49,900
around I'm going to talk to you as a

00:00:43,930 --> 00:00:52,590
member of the open SUSE arm team so you

00:00:49,900 --> 00:00:55,060
saw on the headline the Raspberry Pi

00:00:52,590 --> 00:00:57,220
that's what it looks like you Polly most

00:00:55,060 --> 00:00:59,680
of you guys have seen one I just took

00:00:57,220 --> 00:01:01,180
this image from our web page so it

00:00:59,680 --> 00:01:03,610
always also has a logo on it which is

00:01:01,180 --> 00:01:05,049
cool so why would you possibly want to

00:01:03,610 --> 00:01:07,720
buy a Raspberry Pi that's very very

00:01:05,049 --> 00:01:09,670
simple reasons it's cheap as hell it's

00:01:07,720 --> 00:01:11,740
available like nothing else you can just

00:01:09,670 --> 00:01:13,840
go to a store grab it and it's arm-based

00:01:11,740 --> 00:01:18,550
what what more could you must be asked

00:01:13,840 --> 00:01:21,400
for but most of you guys probably want

00:01:18,550 --> 00:01:23,200
to run software on such a device right

00:01:21,400 --> 00:01:25,630
so you want to boot which means you want

00:01:23,200 --> 00:01:27,190
to get into a system so how does booting

00:01:25,630 --> 00:01:28,540
on the Raspberry Pi work well it's

00:01:27,190 --> 00:01:34,210
really really simple but you take this

00:01:28,540 --> 00:01:36,040
word and then you take USD card and then

00:01:34,210 --> 00:01:37,960
you plug USD card in and then you take

00:01:36,040 --> 00:01:39,820
your power cable and you park your power

00:01:37,960 --> 00:01:43,780
cable in down there and then it just

00:01:39,820 --> 00:01:45,520
boots unless you're the one creating the

00:01:43,780 --> 00:01:46,900
image that is supposed to make this

00:01:45,520 --> 00:01:50,290
thing boot which is what we're here for

00:01:46,900 --> 00:01:51,610
right your distribution so let's take a

00:01:50,290 --> 00:01:53,140
look at the SD card what does this thing

00:01:51,610 --> 00:01:55,710
actually look like what do we have in

00:01:53,140 --> 00:01:58,479
there you have the usual we do have

00:01:55,710 --> 00:02:00,310
screens really dark and we do have our

00:01:58,479 --> 00:02:02,409
root filesystem we do have a swap

00:02:00,310 --> 00:02:04,900
partition the user stuff you would

00:02:02,409 --> 00:02:06,400
expect on on a main device that you want

00:02:04,900 --> 00:02:09,220
you operating system from but the rest

00:02:06,400 --> 00:02:11,920
is especially in one regard in that it

00:02:09,220 --> 00:02:13,390
also has a fat partition and that one's

00:02:11,920 --> 00:02:15,040
very very mandatory on those devices

00:02:13,390 --> 00:02:18,639
because the fat partition actually

00:02:15,040 --> 00:02:19,460
contains a few files that are incredibly

00:02:18,639 --> 00:02:22,040
necessary to

00:02:19,460 --> 00:02:24,200
buuut such a device a really really most

00:02:22,040 --> 00:02:25,610
important one is blue cup in that just

00:02:24,200 --> 00:02:28,280
lies around on that pad partition it

00:02:25,610 --> 00:02:30,440
just tanks there and it's so important

00:02:28,280 --> 00:02:31,580
because that's what is the initial boot

00:02:30,440 --> 00:02:34,760
code that comes from the Raspberry Pi

00:02:31,580 --> 00:02:35,930
foundation it's actually GPU code so the

00:02:34,760 --> 00:02:38,300
whole thing doesn't boot from the arm

00:02:35,930 --> 00:02:40,730
system to boot from the GPU this is GPU

00:02:38,300 --> 00:02:42,470
code that then goes in and reach the

00:02:40,730 --> 00:02:46,460
convict text file which is also on there

00:02:42,470 --> 00:02:47,630
to figure out what it should do how it

00:02:46,460 --> 00:02:48,980
how it should look like whether it

00:02:47,630 --> 00:02:50,780
should n able serial ports what

00:02:48,980 --> 00:02:53,150
frequencies it should use what monitor

00:02:50,780 --> 00:02:57,190
depth it should use that's all within

00:02:53,150 --> 00:03:00,800
convict text with defaults obviously and

00:02:57,190 --> 00:03:03,320
we usually if you have saying a raspbian

00:03:00,800 --> 00:03:06,380
distribution you also get a kernel on

00:03:03,320 --> 00:03:08,990
that pad partition that view boot which

00:03:06,380 --> 00:03:10,580
ever from the very first time we enable

00:03:08,990 --> 00:03:13,880
the Raspberry Pi and an openSUSE

00:03:10,580 --> 00:03:17,270
we think it was a really bad idea so

00:03:13,880 --> 00:03:21,380
instead we are using you boot at that

00:03:17,270 --> 00:03:22,880
point and you boot then goes in and can

00:03:21,380 --> 00:03:25,300
actually break out of that pad partition

00:03:22,880 --> 00:03:28,160
and go into your real root partition and

00:03:25,300 --> 00:03:30,500
reach a script called boot script from

00:03:28,160 --> 00:03:33,500
there and boot a load the kernel in a

00:03:30,500 --> 00:03:34,790
dirty and device tree from your root

00:03:33,500 --> 00:03:40,730
partition which means you can actually

00:03:34,790 --> 00:03:43,210
update files with normal rpms how is

00:03:40,730 --> 00:03:48,020
that different from how you PC boots

00:03:43,210 --> 00:03:52,370
very simple UPC boots first off by being

00:03:48,020 --> 00:03:54,920
a PC and not a Raspberry Pi and then you

00:03:52,370 --> 00:03:56,150
have something some Sun stall which

00:03:54,920 --> 00:03:57,470
where you put your film way and on the

00:03:56,150 --> 00:03:59,780
Westway PI everything's on the SD card

00:03:57,470 --> 00:04:01,370
on a real PC you have something soldered

00:03:59,780 --> 00:04:04,820
onto your board where your EFI firmware

00:04:01,370 --> 00:04:07,070
usually dies and that EFI firmware goes

00:04:04,820 --> 00:04:08,510
around and just looks at your heart is

00:04:07,070 --> 00:04:10,790
at your storage device or whatever they

00:04:08,510 --> 00:04:13,510
are even me a network and just searches

00:04:10,790 --> 00:04:18,049
for something it should be based on

00:04:13,510 --> 00:04:19,430
different algorithms it finds something

00:04:18,049 --> 00:04:21,710
that it can execute and should execute

00:04:19,430 --> 00:04:24,320
and boot orders which usually in our

00:04:21,710 --> 00:04:28,970
case for openSUSE is grub to which then

00:04:24,320 --> 00:04:31,880
uses callbacks in to efi to proceed load

00:04:28,970 --> 00:04:32,750
the kernel run that kernel and you're

00:04:31,880 --> 00:04:34,790
good

00:04:32,750 --> 00:04:36,380
so you can see it's actually pretty

00:04:34,790 --> 00:04:39,260
similar to how the rest we buy boots

00:04:36,380 --> 00:04:41,060
just that you have film where piece of

00:04:39,260 --> 00:04:43,220
hardware rather than your SD card and

00:04:41,060 --> 00:04:45,980
you're not running off a GPU but other

00:04:43,220 --> 00:04:48,350
than that pretty similar so what is this

00:04:45,980 --> 00:04:50,510
EFI thing really I mean the whole talk

00:04:48,350 --> 00:04:51,650
is about running if I right so what what

00:04:50,510 --> 00:04:53,810
does he if I and why are people so

00:04:51,650 --> 00:04:54,980
scared of it I honestly don't know well

00:04:53,810 --> 00:04:56,870
why they're scared but I can tell you

00:04:54,980 --> 00:04:59,840
what it is the really really most

00:04:56,870 --> 00:05:01,220
important crucial core piece of EFI is

00:04:59,840 --> 00:05:03,560
something called the system table which

00:05:01,220 --> 00:05:05,030
is just a pointer to a struct that has

00:05:03,560 --> 00:05:07,310
pointers to structs at a pointers to

00:05:05,030 --> 00:05:10,130
structure the pointers - structs and all

00:05:07,310 --> 00:05:14,330
of those contain either information or

00:05:10,130 --> 00:05:15,800
function callbacks the most important

00:05:14,330 --> 00:05:19,340
one of them well the boot time services

00:05:15,800 --> 00:05:23,570
that's basically a collection of around

00:05:19,340 --> 00:05:26,030
50 function callbacks that you can call

00:05:23,570 --> 00:05:30,410
into to do different things during boot

00:05:26,030 --> 00:05:32,780
time Rock got to for example users there

00:05:30,410 --> 00:05:35,690
are those I just took a few most

00:05:32,780 --> 00:05:37,610
important ones out here obviously you

00:05:35,690 --> 00:05:39,530
want to load images right so the load

00:05:37,610 --> 00:05:40,790
image callback you just with you want if

00:05:39,530 --> 00:05:43,040
you have an image memory and you

00:05:40,790 --> 00:05:45,680
definitely want to have it loaded into

00:05:43,040 --> 00:05:49,070
into the system you called a lot image

00:05:45,680 --> 00:05:50,750
function with a binary that that's if I

00:05:49,070 --> 00:05:55,160
compatible anybody recognize what this

00:05:50,750 --> 00:05:58,370
might look like you've seen that thing

00:05:55,160 --> 00:06:01,280
down there before yeah it's a PE

00:05:58,370 --> 00:06:02,870
executable so basically the same thing

00:06:01,280 --> 00:06:04,820
that Windows uses it's the same format

00:06:02,870 --> 00:06:07,790
it's a pretty simple format to be honest

00:06:04,820 --> 00:06:09,530
a lot simpler than elf so loading that

00:06:07,790 --> 00:06:13,610
into memory is not too hard it's really

00:06:09,530 --> 00:06:16,430
just sections that you take and then put

00:06:13,610 --> 00:06:17,690
into RAM at different locations and then

00:06:16,430 --> 00:06:18,620
you've got an entry point jump into it

00:06:17,690 --> 00:06:24,470
and that's all you need to do for

00:06:18,620 --> 00:06:28,100
loading so loading an image is easy the

00:06:24,470 --> 00:06:30,229
other really core piece of efi is that

00:06:28,100 --> 00:06:31,790
it has a notion of objects it doesn't

00:06:30,229 --> 00:06:34,729
call them object and it doesn't call

00:06:31,790 --> 00:06:36,830
classes classes but it is basically the

00:06:34,729 --> 00:06:38,390
same idea so you have protocols which

00:06:36,830 --> 00:06:43,070
are classes and handles which all your

00:06:38,390 --> 00:06:45,020
objects and imagine you have a disk

00:06:43,070 --> 00:06:46,060
device what you got a SATA disk you're

00:06:45,020 --> 00:06:50,260
first started asking you

00:06:46,060 --> 00:06:53,680
system and that one said it is can how

00:06:50,260 --> 00:06:56,440
can implement a class called a lock

00:06:53,680 --> 00:06:58,210
operation class you never give names to

00:06:56,440 --> 00:07:01,720
anything in EFI they're all based on IDs

00:06:58,210 --> 00:07:03,970
you have really long 128-bit long gu IDs

00:07:01,720 --> 00:07:06,190
but this is basically just a class that

00:07:03,970 --> 00:07:07,960
says I can do block operations and that

00:07:06,190 --> 00:07:09,639
consists of just a few function

00:07:07,960 --> 00:07:11,530
callbacks against all of these a structs

00:07:09,639 --> 00:07:12,790
right so this is a struct that basically

00:07:11,530 --> 00:07:15,310
tells you it's a struct as a struct

00:07:12,790 --> 00:07:16,600
inside a struct and then in there you

00:07:15,310 --> 00:07:20,370
have function callbacks that you can

00:07:16,600 --> 00:07:23,860
call to read or write to such a device

00:07:20,370 --> 00:07:26,200
so very simple and it can also have a

00:07:23,860 --> 00:07:29,200
second or third or fourth or how many

00:07:26,200 --> 00:07:33,430
how many ever you want different classes

00:07:29,200 --> 00:07:36,040
implemented by the same object in the

00:07:33,430 --> 00:07:39,190
example of a senators for example you

00:07:36,040 --> 00:07:42,100
usually have a thing called a device

00:07:39,190 --> 00:07:44,169
path where you can find out where in

00:07:42,100 --> 00:07:46,450
your device tree this thing is so this

00:07:44,169 --> 00:07:47,919
is like my disk is attached to a SATA

00:07:46,450 --> 00:07:49,630
controller which is attached to a PCI

00:07:47,919 --> 00:07:55,419
device and then you can just walk

00:07:49,630 --> 00:07:57,400
through this this path so it's really

00:07:55,419 --> 00:08:00,479
just a simple means of providing access

00:07:57,400 --> 00:08:02,590
to objects and objects can be our celli

00:08:00,479 --> 00:08:04,060
enhanced too so you can have you can

00:08:02,590 --> 00:08:05,910
load enough or not the driver that then

00:08:04,060 --> 00:08:08,620
adds objects to your object list and

00:08:05,910 --> 00:08:12,760
exposes different devices basically with

00:08:08,620 --> 00:08:15,430
this and the next really cool thing that

00:08:12,760 --> 00:08:17,889
efi does which is important for film

00:08:15,430 --> 00:08:19,810
where is it manages memory you always

00:08:17,889 --> 00:08:21,940
want to know which memory in your memory

00:08:19,810 --> 00:08:25,120
space is already occupied which isn't so

00:08:21,940 --> 00:08:28,150
if I maintain sale memory map but you

00:08:25,120 --> 00:08:30,070
can always ask for wages they just says

00:08:28,150 --> 00:08:32,190
all right so at this address I have some

00:08:30,070 --> 00:08:34,750
space available at that address

00:08:32,190 --> 00:08:36,849
everything's already occupied as this

00:08:34,750 --> 00:08:38,500
address there's nothing there at all at

00:08:36,849 --> 00:08:40,930
that address we got one time services

00:08:38,500 --> 00:08:43,089
I'll get to this later them and say down

00:08:40,930 --> 00:08:46,450
here is a lot of memory available again

00:08:43,089 --> 00:08:48,730
if you allocate memory what happens is

00:08:46,450 --> 00:08:50,470
that if I basically just goes and says

00:08:48,730 --> 00:08:52,620
oh you want one megabyte allocation all

00:08:50,470 --> 00:08:56,050
right I'll swing down an existing

00:08:52,620 --> 00:08:57,670
available size and at you know one more

00:08:56,050 --> 00:08:59,440
blob for your one megabyte allocation we

00:08:57,670 --> 00:09:01,150
turn this thing to you and that's it

00:08:59,440 --> 00:09:02,680
it doesn't do anything beyond this so if

00:09:01,150 --> 00:09:03,940
you don't free this it will still be

00:09:02,680 --> 00:09:06,280
allocated by the time you execute

00:09:03,940 --> 00:09:12,280
application which by the way go up to

00:09:06,280 --> 00:09:13,630
does so every allocation is really

00:09:12,280 --> 00:09:15,160
simple to you you can always ask Lee

00:09:13,630 --> 00:09:17,020
memory map you can receive it whenever

00:09:15,160 --> 00:09:18,310
you like it's always up-to-date so you

00:09:17,020 --> 00:09:21,730
always know how much memory you still

00:09:18,310 --> 00:09:23,620
have available for allocations console

00:09:21,730 --> 00:09:26,080
is obvious it's just pointers to the

00:09:23,620 --> 00:09:28,990
console objects for standard instant it

00:09:26,080 --> 00:09:30,850
out and additional tables contain fancy

00:09:28,990 --> 00:09:33,700
things like your device tree or your a

00:09:30,850 --> 00:09:35,200
CPI table CD my tables everything that's

00:09:33,700 --> 00:09:36,940
just arbitrary data that you want to

00:09:35,200 --> 00:09:39,970
have some way memory and know where it

00:09:36,940 --> 00:09:42,360
is it just put s with IDs into those

00:09:39,970 --> 00:09:46,690
arbitrary tables so it's just apples off

00:09:42,360 --> 00:09:49,410
IDE and pointer runtime services are

00:09:46,690 --> 00:09:51,760
really really cool thing and Eve I

00:09:49,410 --> 00:09:53,560
imagine you boot your PC right you put

00:09:51,760 --> 00:09:56,200
it up and you have a lot of RAM and

00:09:53,560 --> 00:09:58,210
initially when you boot of course efi is

00:09:56,200 --> 00:10:01,210
running there and if i owns some of that

00:09:58,210 --> 00:10:03,010
ram now if i goes and loads grub grub

00:10:01,210 --> 00:10:05,170
goes and extends itself allocates a lot

00:10:03,010 --> 00:10:07,540
more memory lots linux into that space

00:10:05,170 --> 00:10:10,420
linux gets loaded into real memory and

00:10:07,540 --> 00:10:12,700
then what well then at this point linux

00:10:10,420 --> 00:10:16,210
actually is also in efi binary that

00:10:12,700 --> 00:10:18,280
executes and talks to efi and tells you

00:10:16,210 --> 00:10:18,880
if i you know what if i go away I don't

00:10:18,280 --> 00:10:22,180
need you anymore

00:10:18,880 --> 00:10:24,060
I'm out of I'm done with booting I don't

00:10:22,180 --> 00:10:26,380
need booting anymore

00:10:24,060 --> 00:10:28,150
please give me the Machine I want to

00:10:26,380 --> 00:10:30,640
have access to all of them of all of

00:10:28,150 --> 00:10:33,250
that memory without asking you for it so

00:10:30,640 --> 00:10:34,810
it does that but one thing that you can

00:10:33,250 --> 00:10:37,720
do with your values you can still

00:10:34,810 --> 00:10:41,740
preserve some of efi in your memory

00:10:37,720 --> 00:10:44,350
space by having that blob be self

00:10:41,740 --> 00:10:47,500
relocatable and linux calls you with

00:10:44,350 --> 00:10:50,530
your new relocation hydrosis on it so

00:10:47,500 --> 00:10:52,750
this blob is still available while Linux

00:10:50,530 --> 00:10:55,510
is running so Linux can call into

00:10:52,750 --> 00:10:58,750
functions inside of that small space and

00:10:55,510 --> 00:11:00,850
then those if I one-time services can

00:10:58,750 --> 00:11:03,010
still do operations on behalf of Linux

00:11:00,850 --> 00:11:06,089
so this is code that actually is film

00:11:03,010 --> 00:11:08,440
where code that you just call engine and

00:11:06,089 --> 00:11:11,680
the most obvious examples for one-time

00:11:08,440 --> 00:11:13,220
services are get time so you can ask efi

00:11:11,680 --> 00:11:15,920
what time it is just to access

00:11:13,220 --> 00:11:19,129
real time clock you can ask efi to give

00:11:15,920 --> 00:11:22,850
you a variable or set a variable you

00:11:19,129 --> 00:11:24,560
have some variable space in efi and you

00:11:22,850 --> 00:11:25,129
can ask it to reset your system for

00:11:24,560 --> 00:11:26,930
example

00:11:25,129 --> 00:11:29,480
please reboot now and you don't need to

00:11:26,930 --> 00:11:30,829
care about 50 different power management

00:11:29,480 --> 00:11:33,759
units or whatever you have out there is

00:11:30,829 --> 00:11:36,050
just reboots the system so it's really

00:11:33,759 --> 00:11:43,069
convenient hard wave section layer for

00:11:36,050 --> 00:11:46,009
you alright so how do we bridge you boot

00:11:43,069 --> 00:11:47,120
and and efi how do you how do these

00:11:46,009 --> 00:11:48,680
interfaces even match

00:11:47,120 --> 00:11:50,779
I mean you boo this is a completely

00:11:48,680 --> 00:11:52,160
different world isn't it it's fun for

00:11:50,779 --> 00:11:53,810
embedded it doesn't have anything to do

00:11:52,160 --> 00:11:57,850
with a real cool service that do have

00:11:53,810 --> 00:12:01,850
efi well if we take a really deep look

00:11:57,850 --> 00:12:03,589
man we run this mint yes sure we need to

00:12:01,850 --> 00:12:06,410
write new code to support all the memory

00:12:03,589 --> 00:12:08,959
management that if i expose us in in you

00:12:06,410 --> 00:12:10,670
boot because you good doesn't have an

00:12:08,959 --> 00:12:11,870
ocean or has has an ocean of memory

00:12:10,670 --> 00:12:16,069
allocations but it's different from what

00:12:11,870 --> 00:12:17,569
if i thinks it should be but anything

00:12:16,069 --> 00:12:19,490
else if you look at the network stack

00:12:17,569 --> 00:12:22,579
well there's a network stack in you boot

00:12:19,490 --> 00:12:24,829
so if we just let small weber code we

00:12:22,579 --> 00:12:26,120
can as well just access the you you

00:12:24,829 --> 00:12:29,209
couldn't wrap a coat at the u-boot

00:12:26,120 --> 00:12:32,750
network code from a random boot time

00:12:29,209 --> 00:12:35,990
service call back same goes for console

00:12:32,750 --> 00:12:37,970
for disk all the devices actually look

00:12:35,990 --> 00:12:39,769
almost the same on the interfaces if you

00:12:37,970 --> 00:12:41,180
really compare if i interfaces and do

00:12:39,769 --> 00:12:44,209
boot internal interfaces so all we need

00:12:41,180 --> 00:12:47,029
to do to support calling into you boot

00:12:44,209 --> 00:12:48,889
code from a boot time service function

00:12:47,029 --> 00:12:51,050
callback is to write a small wrapper

00:12:48,889 --> 00:12:57,079
that just converts function semantics

00:12:51,050 --> 00:12:58,519
for us for one term services that

00:12:57,079 --> 00:12:59,689
slightly more complicated because eva

00:12:58,519 --> 00:13:01,339
doesn't have any notion at all of

00:12:59,689 --> 00:13:04,610
runtime services it only knows how to

00:13:01,339 --> 00:13:09,559
run a good time and then tries to just

00:13:04,610 --> 00:13:11,240
completely disappear however it's not

00:13:09,559 --> 00:13:13,910
really hard to do either we need to

00:13:11,240 --> 00:13:15,589
basically teach a function like the

00:13:13,910 --> 00:13:17,120
reset cpu function to be one-time

00:13:15,589 --> 00:13:19,550
service aware that's a patch of about

00:13:17,120 --> 00:13:23,149
three to four lines at this point per

00:13:19,550 --> 00:13:25,880
function that we own to call and at that

00:13:23,149 --> 00:13:26,440
point we can just call a wrapper one the

00:13:25,880 --> 00:13:28,060
see

00:13:26,440 --> 00:13:30,070
you reset function and you get fully

00:13:28,060 --> 00:13:33,250
working one-time services in Ubud so I

00:13:30,070 --> 00:13:37,650
have enabled this for Raspberry Pi 3 or

00:13:33,250 --> 00:13:37,650
Wesley PI in general actually and the

00:13:37,710 --> 00:13:44,350
lay escape 2085 systems but adding

00:13:42,580 --> 00:13:49,150
adding new support is really matter of a

00:13:44,350 --> 00:13:51,670
couple lines of code so it's trivial get

00:13:49,150 --> 00:13:52,870
time we don't implement at all reason is

00:13:51,670 --> 00:13:54,760
most boards that you have out there

00:13:52,870 --> 00:13:56,920
don't have a time to don't have a clock

00:13:54,760 --> 00:14:00,520
to ask if you don't have a clock you

00:13:56,920 --> 00:14:02,590
can't really reach an working time and

00:14:00,520 --> 00:14:03,910
same for variables we for if you want to

00:14:02,590 --> 00:14:07,180
support variables we would need to

00:14:03,910 --> 00:14:08,350
support storing variables somewhere and

00:14:07,180 --> 00:14:10,060
reading variables from somewhere that

00:14:08,350 --> 00:14:11,350
doesn't collide with what Linux actually

00:14:10,060 --> 00:14:14,170
uses at the point in time when Linux

00:14:11,350 --> 00:14:16,000
calls our one-time service code we don't

00:14:14,170 --> 00:14:17,860
have those separate devices on most

00:14:16,000 --> 00:14:22,630
devices that we want to support with

00:14:17,860 --> 00:14:24,460
this and for additional tables very

00:14:22,630 --> 00:14:26,200
simple we just put our device 3 in there

00:14:24,460 --> 00:14:28,320
we have a device tree we can load the

00:14:26,200 --> 00:14:30,160
device tree we put it in there done deal

00:14:28,320 --> 00:14:32,260
and at that point we actually have

00:14:30,160 --> 00:14:34,780
everything we need to execute an EFI

00:14:32,260 --> 00:14:36,790
binary right so if we take a look this

00:14:34,780 --> 00:14:39,100
is just a boot lock from a sink and P

00:14:36,790 --> 00:14:41,230
system it just puts up into into you

00:14:39,100 --> 00:14:44,440
boot and then gets you to a shell all

00:14:41,230 --> 00:14:46,540
right so what we need to do to boot an

00:14:44,440 --> 00:14:48,400
EFI binary on these with currently boots

00:14:46,540 --> 00:14:51,190
so if you just take you boot 2016 or 5

00:14:48,400 --> 00:14:53,670
for example it's all implemented all you

00:14:51,190 --> 00:14:58,030
need to do is load your graph binary

00:14:53,670 --> 00:15:03,670
load your device tree and call booty if

00:14:58,030 --> 00:15:06,430
I'd done gotta go up it's as simple as

00:15:03,670 --> 00:15:09,370
that so if you take a current you boot

00:15:06,430 --> 00:15:10,870
you can always just manually load an EFI

00:15:09,370 --> 00:15:12,700
binary which could be grew up which

00:15:10,870 --> 00:15:14,680
could be the notes kernel itself it's

00:15:12,700 --> 00:15:18,010
also a fly binary can be anything that

00:15:14,680 --> 00:15:21,880
you like it could be the OpenBSD

00:15:18,010 --> 00:15:23,710
bootloader whatever you prefer but if he

00:15:21,880 --> 00:15:25,930
if we go back actually and take a look

00:15:23,710 --> 00:15:27,160
at this the six Erb one thing you might

00:15:25,930 --> 00:15:29,380
have realized while reading through all

00:15:27,160 --> 00:15:30,760
of this these lines here is there

00:15:29,380 --> 00:15:34,510
something on down there that's called

00:15:30,760 --> 00:15:37,440
auto boot so what is auto booed Ottawa

00:15:34,510 --> 00:15:40,770
just means that you boot goes in

00:15:37,440 --> 00:15:42,510
and executes a bhoot script that's

00:15:40,770 --> 00:15:44,490
predefined in the configuration and on

00:15:42,510 --> 00:15:46,490
most systems these days that's a distro

00:15:44,490 --> 00:15:49,140
script it's just a set of templates that

00:15:46,490 --> 00:15:51,990
go through a list of different devices

00:15:49,140 --> 00:15:53,540
and searches for known good sources of

00:15:51,990 --> 00:15:56,790
booting from them

00:15:53,540 --> 00:15:59,640
so really the distance gate just goes in

00:15:56,790 --> 00:16:04,470
such as your disk and looks if it finds

00:15:59,640 --> 00:16:07,350
a an EFI binary at the spec defined to

00:16:04,470 --> 00:16:09,990
removable location path for EFI binaries

00:16:07,350 --> 00:16:12,120
that's just part of the EFI spec and

00:16:09,990 --> 00:16:14,070
searches if it can find the device tree

00:16:12,120 --> 00:16:18,660
if it doesn't it just doesn't load it

00:16:14,070 --> 00:16:22,680
and then usually of course your efi

00:16:18,660 --> 00:16:24,870
binary is grub - so you don't press any

00:16:22,680 --> 00:16:27,750
key at all and it just automatically and

00:16:24,870 --> 00:16:29,040
everything and you get go up which is

00:16:27,750 --> 00:16:30,180
pretty much how you want to view these

00:16:29,040 --> 00:16:31,500
days right you don't want to mess with

00:16:30,180 --> 00:16:33,840
boot scripts you don't want to mess with

00:16:31,500 --> 00:16:36,900
anything at all you really just want to

00:16:33,840 --> 00:16:40,380
have things work out of the box so are

00:16:36,900 --> 00:16:43,620
we standing pretty good as you can see

00:16:40,380 --> 00:16:45,150
everything's implemented so we have if I

00:16:43,620 --> 00:16:47,040
object you have consoles or we have this

00:16:45,150 --> 00:16:50,250
support we have we can even do pixie

00:16:47,040 --> 00:16:51,600
both supports a fixie boot by now video

00:16:50,250 --> 00:16:54,480
support where you can see graphical

00:16:51,600 --> 00:16:56,700
output we can run grab - we can run

00:16:54,480 --> 00:16:59,340
Linux I have not tried to boot windows

00:16:56,700 --> 00:17:05,160
yet there were patches on the mailing

00:16:59,340 --> 00:17:07,020
list to enable x86 64 about two days

00:17:05,160 --> 00:17:08,490
after I posted my first patch set so it

00:17:07,020 --> 00:17:10,949
really is not hard to enable in your

00:17:08,490 --> 00:17:12,480
architecture but they haven't actually

00:17:10,949 --> 00:17:14,130
progressed since because the guy was

00:17:12,480 --> 00:17:16,140
doing something different since then and

00:17:14,130 --> 00:17:20,040
I don't know I don't really care too

00:17:16,140 --> 00:17:23,550
much about booting Windows right now if

00:17:20,040 --> 00:17:25,860
you compare code sizes between enabling

00:17:23,550 --> 00:17:28,439
if I support at not enabling if I

00:17:25,860 --> 00:17:33,150
support you can see that the difference

00:17:28,439 --> 00:17:35,090
is negligible you increase your code

00:17:33,150 --> 00:17:37,830
size by somewhere between 10 and 20 K

00:17:35,090 --> 00:17:40,050
which if your code is already 500

00:17:37,830 --> 00:17:41,280
kilobytes big 10 or 20 K doesn't really

00:17:40,050 --> 00:17:44,520
account for anything at all it's

00:17:41,280 --> 00:17:47,060
completely negligible which means that

00:17:44,520 --> 00:17:47,060
upstream

00:17:47,100 --> 00:17:52,659
we now enable by default so if you just

00:17:50,019 --> 00:17:56,200
take you boot and you do a Def config

00:17:52,659 --> 00:17:58,509
for a board you get efi support on two

00:17:56,200 --> 00:17:59,710
days you boot you don't have to mess

00:17:58,509 --> 00:18:01,690
with anything at all anymore you don't

00:17:59,710 --> 00:18:04,360
mess with you images with Z images with

00:18:01,690 --> 00:18:08,350
anything you just wanting to go up and

00:18:04,360 --> 00:18:10,119
it works since I'm telling you that

00:18:08,350 --> 00:18:13,649
everything works session Paulie also

00:18:10,119 --> 00:18:13,649
show you that it works which is more fun

00:18:19,169 --> 00:18:28,450
so for the for the demo I'm going to

00:18:22,200 --> 00:18:32,009
plug this R as be pi/3 I got in yet into

00:18:28,450 --> 00:18:32,009
the HDMI connector

00:18:43,710 --> 00:18:53,880
and connect power let's hope this one

00:18:50,970 --> 00:18:56,970
works all right there you go so this is

00:18:53,880 --> 00:18:58,470
this is you boot this is got to booting

00:18:56,970 --> 00:18:59,310
up with graphics and everything all the

00:18:58,470 --> 00:19:01,680
bells and whistles you would usually

00:18:59,310 --> 00:19:03,330
know if you have a USB keyboard attached

00:19:01,680 --> 00:19:05,220
you can even use the use a keyboard to

00:19:03,330 --> 00:19:08,400
edit a command line do whatever you like

00:19:05,220 --> 00:19:10,680
it boots into Linux and they go you get

00:19:08,400 --> 00:19:12,360
a fully working distribution with just

00:19:10,680 --> 00:19:14,010
the way you would usually expect it to

00:19:12,360 --> 00:19:15,480
work with all the Yas bootloader things

00:19:14,010 --> 00:19:17,610
working with all the pur bootloader

00:19:15,480 --> 00:19:20,160
updates working everything just works

00:19:17,610 --> 00:19:23,510
the way you would imagine it to have

00:19:20,160 --> 00:19:23,510
worked from the very first day

00:19:34,260 --> 00:19:39,940
I'll just leave it at that one so the

00:19:38,080 --> 00:19:42,100
next slide is we just a thank you and go

00:19:39,940 --> 00:19:46,210
out and try for yourself and do you have

00:19:42,100 --> 00:19:47,760
any questions cipher please get a mic

00:19:46,210 --> 00:19:50,860
there right thanks to you yes

00:19:47,760 --> 00:19:53,920
what'swhat's the behind slowing down the

00:19:50,860 --> 00:19:58,299
Raspberry Pi boot even more with more

00:19:53,920 --> 00:20:00,850
complicated stuff I mean the one thing

00:19:58,299 --> 00:20:02,590
if this doesn't work people will go

00:20:00,850 --> 00:20:04,900
googling and asked why it doesn't hurt

00:20:02,590 --> 00:20:07,270
everybody will tell them to go away just

00:20:04,900 --> 00:20:10,809
boot the Raspberry Pi like it's supposed

00:20:07,270 --> 00:20:12,190
to boot it depends on what your goal is

00:20:10,809 --> 00:20:13,900
it's your goal to support the Raspberry

00:20:12,190 --> 00:20:17,710
Pi boot the way the Raspberry Pi will do

00:20:13,900 --> 00:20:20,860
it does it if you if you want to really

00:20:17,710 --> 00:20:22,600
actually do it the Raspberry Pi way use

00:20:20,860 --> 00:20:25,390
the downstream kernel use whatever

00:20:22,600 --> 00:20:27,070
method you like I don't care if you want

00:20:25,390 --> 00:20:30,010
to boot the Raspberry Pi like you boot

00:20:27,070 --> 00:20:33,490
any random normal system if you want to

00:20:30,010 --> 00:20:39,400
actually go towards a maintainable

00:20:33,490 --> 00:20:41,110
future you want to have that path to

00:20:39,400 --> 00:20:44,260
speed up a lot more because I mean it's

00:20:41,110 --> 00:20:49,059
however lot slower than than booting a

00:20:44,260 --> 00:20:51,370
normal normal boot lid there were there

00:20:49,059 --> 00:20:53,020
was a 10 10 seconds timeout yes it does

00:20:51,370 --> 00:20:55,799
food slower but that's all things that

00:20:53,020 --> 00:20:55,799
are going to go away

00:21:00,580 --> 00:21:06,190
the big advantage of of these young I

00:21:04,840 --> 00:21:08,230
enablement in particular for the

00:21:06,190 --> 00:21:10,240
Raspberry Pi is here that you now have a

00:21:08,230 --> 00:21:12,780
boot menu to selectively and carl's

00:21:10,240 --> 00:21:15,430
because the way it worked before is that

00:21:12,780 --> 00:21:17,260
when we updated a kernel and the new

00:21:15,430 --> 00:21:19,630
kernel for some reason didn't work like

00:21:17,260 --> 00:21:21,760
some kernel head and then you were kind

00:21:19,630 --> 00:21:23,980
of stuck and you now had to take the SD

00:21:21,760 --> 00:21:26,770
card and you know put it into different

00:21:23,980 --> 00:21:28,630
machine tweak siblings and so on and now

00:21:26,770 --> 00:21:30,280
with this you know a couple of seconds

00:21:28,630 --> 00:21:32,320
more in the boot process you can just

00:21:30,280 --> 00:21:33,820
select a different kernel if the default

00:21:32,320 --> 00:21:37,000
selection doesn't work and you still

00:21:33,820 --> 00:21:39,010
have a working system you can also add a

00:21:37,000 --> 00:21:41,980
command lines on the fly from the

00:21:39,010 --> 00:21:44,050
bootloader it just basically moves your

00:21:41,980 --> 00:21:46,420
grasp a pie from a device that you

00:21:44,050 --> 00:21:48,490
target to have device that you work on

00:21:46,420 --> 00:21:50,650
that's let's visit the shift it goes

00:21:48,490 --> 00:21:52,510
from this is something like an embedded

00:21:50,650 --> 00:21:54,730
device like a mobile phone that I just

00:21:52,510 --> 00:21:56,140
want you cross compile things on my PC

00:21:54,730 --> 00:21:58,690
on and then push them onto the device

00:21:56,140 --> 00:22:01,120
over towards this is the device I'm

00:21:58,690 --> 00:22:03,820
actually working with and working on you

00:22:01,120 --> 00:22:06,310
you would never imagine to directly

00:22:03,820 --> 00:22:10,240
flash your kernel into your your flash

00:22:06,310 --> 00:22:13,740
chip on your PC with you well maybe you

00:22:10,240 --> 00:22:18,070
would but nobody else who is sane would

00:22:13,740 --> 00:22:19,900
so would this also mean that if you have

00:22:18,070 --> 00:22:21,340
battery FS and the snapshots that it's

00:22:19,900 --> 00:22:23,200
all just working yep

00:22:21,340 --> 00:22:25,210
all just working butter first snapshots

00:22:23,200 --> 00:22:26,740
snapshot well baked booting all of that

00:22:25,210 --> 00:22:28,690
just works out of the box the other

00:22:26,740 --> 00:22:31,570
question I have is a around pixie boot

00:22:28,690 --> 00:22:33,150
and so pixie boot is not implemented by

00:22:31,570 --> 00:22:38,950
the premiere in that case what's really

00:22:33,150 --> 00:22:43,150
done on the UF eyes or okay it's fully

00:22:38,950 --> 00:22:45,160
just a naming problem EFI is the

00:22:43,150 --> 00:22:47,290
specification that tells you how to

00:22:45,160 --> 00:22:49,420
implement these interfaces you would

00:22:47,290 --> 00:22:52,390
implement that specification and Tiano

00:22:49,420 --> 00:22:56,410
core implements that specification you

00:22:52,390 --> 00:22:57,700
can use both to boot your system and at

00:22:56,410 --> 00:22:59,410
that point because you're booting your

00:22:57,700 --> 00:23:04,000
system from those pieces of software

00:22:59,410 --> 00:23:07,420
they become your firmware so on the

00:23:04,000 --> 00:23:10,300
Raspberry Pi you would is my firmware on

00:23:07,420 --> 00:23:12,300
your PC a Tiano core based work from

00:23:10,300 --> 00:23:15,190
your vendor is your firmware

00:23:12,300 --> 00:23:17,830
it's just a naming naming thing and that

00:23:15,190 --> 00:23:23,230
film where implements efi or actually it

00:23:17,830 --> 00:23:25,260
implements UEFI because it's too low but

00:23:23,230 --> 00:23:27,820
it'll work that's a poor part a second

00:23:25,260 --> 00:23:29,620
big seafood will just work that's that's

00:23:27,820 --> 00:23:31,630
important yeah but the point about this

00:23:29,620 --> 00:23:33,820
is it won't be any different I'm a PC at

00:23:31,630 --> 00:23:36,730
that point if as soon as you have here

00:23:33,820 --> 00:23:39,100
you boot on there it will behave as a as

00:23:36,730 --> 00:23:42,250
a PC does or like the over drives that

00:23:39,100 --> 00:23:53,080
we saw earlier do just at a much lower

00:23:42,250 --> 00:23:58,140
price point more questions sighs of

00:23:53,080 --> 00:23:58,140
relief alright great well thanks a lot

00:24:02,740 --> 00:24:04,800

YouTube URL: https://www.youtube.com/watch?v=bNL1pd-rwCU


