Title: osc12: Lowlevel Userspace Programming
Publication date: 2012-10-24
Playlist: openSUSE Conference 2012
Description: 
	osc12: Lowlevel Userspace Programming from openSUSE. Like this? Watch the latest episode of openSUSE on Blip! http://blip.tv/opensuse/watch 

Petr Baudi? - Spock

See all episodes of openSUSE http://blip.tv/opensuse#EpisodeArchive
Visit openSUSE's series page http://blip.tv/opensuse
Captions: 
	00:00:00,800 --> 00:00:08,179
so well come on the talk low leverage

00:00:05,250 --> 00:00:15,900
based programming I am better baggage

00:00:08,179 --> 00:00:18,920
and today i like i like to talk a bit

00:00:15,900 --> 00:00:22,289
about the kind of system programming

00:00:18,920 --> 00:00:25,740
that's not frequently covered because

00:00:22,289 --> 00:00:28,740
usually usually you either program in

00:00:25,740 --> 00:00:32,520
the Cardinal you work on on device

00:00:28,740 --> 00:00:34,590
drivers or you tolko or you work on some

00:00:32,520 --> 00:00:37,170
virtual memory management or whatever

00:00:34,590 --> 00:00:40,110
else or you work on the application

00:00:37,170 --> 00:00:42,800
programs that draw pretty windows or are

00:00:40,110 --> 00:00:45,030
some network applications also on and

00:00:42,800 --> 00:00:49,260
today I'd like to talk a bit about

00:00:45,030 --> 00:00:52,500
what's between these two layers what

00:00:49,260 --> 00:00:55,890
happens in the in the user space at the

00:00:52,500 --> 00:00:59,550
lowest level how can you communicate

00:00:55,890 --> 00:01:01,620
with the colonel and how can you do some

00:00:59,550 --> 00:01:06,229
neat things in the user space without

00:01:01,620 --> 00:01:10,380
much canal help so this dog has been

00:01:06,229 --> 00:01:12,720
marked with that lean jello go but I

00:01:10,380 --> 00:01:16,920
don't think you really need to feel that

00:01:12,720 --> 00:01:19,979
much i'll be showing you some actual

00:01:16,920 --> 00:01:23,820
code and maybe there will be even a

00:01:19,979 --> 00:01:26,880
little of assembly in there but but i'll

00:01:23,820 --> 00:01:30,479
be covering a lot of or several smaller

00:01:26,880 --> 00:01:32,850
areas and if you just start to drift

00:01:30,479 --> 00:01:35,009
away and get lost in one area the

00:01:32,850 --> 00:01:36,810
chances are good that in a few minutes

00:01:35,009 --> 00:01:40,229
you'll be talking about something else

00:01:36,810 --> 00:01:42,840
in to catch up again so so don't don't

00:01:40,229 --> 00:01:47,070
really worry if you if you get busted in

00:01:42,840 --> 00:01:49,229
one part and and I think I don't expect

00:01:47,070 --> 00:01:51,780
you to remember all that that's that's

00:01:49,229 --> 00:01:53,579
sad here but I think for a good to linux

00:01:51,780 --> 00:01:55,799
programmer it's important to at least

00:01:53,579 --> 00:01:59,850
hear once about some of the concepts

00:01:55,799 --> 00:02:02,729
that i'll cover cover here so what will

00:01:59,850 --> 00:02:06,119
be what will we talk about we will talk

00:02:02,729 --> 00:02:08,729
about the colonel interface in the user

00:02:06,119 --> 00:02:10,679
space so what happens if you make a sis

00:02:08,729 --> 00:02:13,360
call if you ask the colonel to do

00:02:10,679 --> 00:02:16,330
something for you we will

00:02:13,360 --> 00:02:18,580
talk about what is actually a program

00:02:16,330 --> 00:02:21,160
how the father the program looks like

00:02:18,580 --> 00:02:24,070
and how can you inspect that file how

00:02:21,160 --> 00:02:27,760
can you how can you manipulate that file

00:02:24,070 --> 00:02:31,630
how can how do shared libraries work and

00:02:27,760 --> 00:02:35,050
what is a dynamic linker and so on and

00:02:31,630 --> 00:02:37,660
we will cover some some interesting

00:02:35,050 --> 00:02:43,360
system calls that can enable you to do

00:02:37,660 --> 00:02:46,840
to do some neat things so we will cover

00:02:43,360 --> 00:02:49,660
the mm fiscal which can which you can

00:02:46,840 --> 00:02:52,480
use to to set up some kind of memory

00:02:49,660 --> 00:02:56,350
that that is mapped to a certain file or

00:02:52,480 --> 00:02:58,630
just as Colonel 44 memory but it can it

00:02:56,350 --> 00:03:01,209
doesn't have to be a regular memory it

00:02:58,630 --> 00:03:04,000
can be some as some some interesting

00:03:01,209 --> 00:03:07,510
memory like the GPIO pins of a processor

00:03:04,000 --> 00:03:11,260
or whatever i'll show you how to run

00:03:07,510 --> 00:03:15,310
code that was never meant to run around

00:03:11,260 --> 00:03:18,190
in linux in the user context so we'll

00:03:15,310 --> 00:03:21,310
actually see how white works how those

00:03:18,190 --> 00:03:24,420
mo works and and how can you take some

00:03:21,310 --> 00:03:28,120
code for example maybe even from some

00:03:24,420 --> 00:03:31,840
well the code can be from just running

00:03:28,120 --> 00:03:33,280
standalone or it can be designed for

00:03:31,840 --> 00:03:35,560
some other operating system and how to

00:03:33,280 --> 00:03:37,750
set up the context of the Linux process

00:03:35,560 --> 00:03:40,330
to actually be able to run this code

00:03:37,750 --> 00:03:43,299
that was never meant for linux and we

00:03:40,330 --> 00:03:46,450
will see how to manipulate with already

00:03:43,299 --> 00:03:51,670
existing processes and how to stop them

00:03:46,450 --> 00:03:54,370
at will or touch their memory or or

00:03:51,670 --> 00:03:56,170
change the processes and so on so this

00:03:54,370 --> 00:03:58,660
is how for example the gdb debugger

00:03:56,170 --> 00:04:02,200
works the Astraeus tool works and so on

00:03:58,660 --> 00:04:08,110
we will take a look at what at how that

00:04:02,200 --> 00:04:10,269
works alright so I expected you have

00:04:08,110 --> 00:04:13,269
seen some c code before and that you

00:04:10,269 --> 00:04:14,620
have some user level experience in in

00:04:13,269 --> 00:04:16,840
the new set of course that you

00:04:14,620 --> 00:04:21,100
programmed that you already program some

00:04:16,840 --> 00:04:23,620
software a linux yeah and I yeah I'd

00:04:21,100 --> 00:04:25,690
like you to ask questions if something

00:04:23,620 --> 00:04:26,660
is really not clear but somehow people

00:04:25,690 --> 00:04:28,550
never

00:04:26,660 --> 00:04:29,810
really tempted to do that so I don't

00:04:28,550 --> 00:04:32,450
know maybe this will be the first time

00:04:29,810 --> 00:04:39,110
that people as I will ask a lot of

00:04:32,450 --> 00:04:42,200
questions and the purpose of of this

00:04:39,110 --> 00:04:46,580
talk why I am giving this talk is that

00:04:42,200 --> 00:04:49,670
I'd like to share some experiences with

00:04:46,580 --> 00:04:52,510
you and mainly encourage you to actually

00:04:49,670 --> 00:04:57,200
don't be afraid to look at the code

00:04:52,510 --> 00:04:59,320
because well when I was 13 and good

00:04:57,200 --> 00:05:01,730
friend of my father paw patroller

00:04:59,320 --> 00:05:03,890
introduced me to linux and install

00:05:01,730 --> 00:05:06,890
helped me install linux on my computer i

00:05:03,890 --> 00:05:09,560
was learning how to do a shell scripting

00:05:06,890 --> 00:05:12,890
and so on and i was learning some basics

00:05:09,560 --> 00:05:14,450
of the c language i thought that formal

00:05:12,890 --> 00:05:19,100
strings are you a stupid idea back then

00:05:14,450 --> 00:05:22,280
and i was wondering how to make some

00:05:19,100 --> 00:05:24,800
nice-looking text interfaces like how to

00:05:22,280 --> 00:05:27,710
write text on a specific position on the

00:05:24,800 --> 00:05:30,230
screen and so on so i've heard us and he

00:05:27,710 --> 00:05:31,760
told me well look at the code the linux

00:05:30,230 --> 00:05:35,570
kernel is open source so you can just

00:05:31,760 --> 00:05:40,370
look at the TTI device driver and look

00:05:35,570 --> 00:05:43,840
at how that works so i have spent two

00:05:40,370 --> 00:05:47,419
days of being totally miserable but and

00:05:43,840 --> 00:05:50,990
but finally i decide i found the code

00:05:47,419 --> 00:05:54,740
that that does this and I've deciphered

00:05:50,990 --> 00:05:58,310
how to how to do this escape sequence

00:05:54,740 --> 00:06:02,090
and it's been actually a great

00:05:58,310 --> 00:06:03,650
experience for me because because even

00:06:02,090 --> 00:06:07,580
though I didn't hear a no see very well

00:06:03,650 --> 00:06:11,150
I was finally able to find the code to

00:06:07,580 --> 00:06:13,520
find the code in linux and and I think

00:06:11,150 --> 00:06:16,160
it's been actually in the longer I'm

00:06:13,520 --> 00:06:17,660
better advice than just tell educated

00:06:16,160 --> 00:06:19,490
then to tell me just to look at the

00:06:17,660 --> 00:06:21,770
documentation or whatever of course that

00:06:19,490 --> 00:06:24,770
will be much easier but this way I

00:06:21,770 --> 00:06:26,390
learned so much in the two days that

00:06:24,770 --> 00:06:30,470
even though I felt feeling miserable

00:06:26,390 --> 00:06:33,020
when I was searching for this well it's

00:06:30,470 --> 00:06:35,479
been a great experience and I like to

00:06:33,020 --> 00:06:37,729
show some pieces of the of code here

00:06:35,479 --> 00:06:40,560
today if we all have enough time so that

00:06:37,729 --> 00:06:42,200
also you aren't afraid to actually look

00:06:40,560 --> 00:06:45,330
at the code that does these things

00:06:42,200 --> 00:06:46,980
because then you will be able to solve

00:06:45,330 --> 00:06:53,730
problems that you would never be able to

00:06:46,980 --> 00:06:56,150
solve before ok yeah just we won't

00:06:53,730 --> 00:06:59,430
really need that much assembler but it's

00:06:56,150 --> 00:07:01,860
if you want to do some system

00:06:59,430 --> 00:07:04,860
programming or just be able to debug

00:07:01,860 --> 00:07:06,950
even very unwieldy code it's useful to

00:07:04,860 --> 00:07:12,450
know just the very basics of assembler

00:07:06,950 --> 00:07:14,790
so well assembler is the is well it's

00:07:12,450 --> 00:07:16,979
not really programming language well it

00:07:14,790 --> 00:07:18,240
is a programming language but in a

00:07:16,979 --> 00:07:20,040
normal language you write some

00:07:18,240 --> 00:07:22,530
high-level comments and they get

00:07:20,040 --> 00:07:24,570
transferred translated to instructions

00:07:22,530 --> 00:07:26,700
which are executed by the processor in

00:07:24,570 --> 00:07:28,590
assembler you are writing directly the

00:07:26,700 --> 00:07:32,070
instructions that are executed by the

00:07:28,590 --> 00:07:35,300
processor so you need to know exactly

00:07:32,070 --> 00:07:38,880
how the processor internal uprights and

00:07:35,300 --> 00:07:41,040
that how much which registers the

00:07:38,880 --> 00:07:44,190
processor has how does it access memory

00:07:41,040 --> 00:07:46,440
and so on and if you want to do

00:07:44,190 --> 00:07:47,940
something you need to explicitly affect

00:07:46,440 --> 00:07:49,500
some data from memory do the

00:07:47,940 --> 00:07:51,900
transformation on the data and then

00:07:49,500 --> 00:07:53,070
explicitly put the data back back into

00:07:51,900 --> 00:07:55,919
the memory you need to manage your

00:07:53,070 --> 00:07:57,600
registers and and so on but you can do

00:07:55,919 --> 00:08:04,169
well you can do anything that the

00:07:57,600 --> 00:08:06,060
processor allows so often it's a okay

00:08:04,169 --> 00:08:08,669
you have some program and you can figure

00:08:06,060 --> 00:08:12,570
out what the program does and sometimes

00:08:08,669 --> 00:08:15,840
it's not so outlandish idea to actually

00:08:12,570 --> 00:08:19,200
look at the assembly code of a specific

00:08:15,840 --> 00:08:21,300
function of the program which with just

00:08:19,200 --> 00:08:25,289
the weird thing that you wonder about

00:08:21,300 --> 00:08:28,110
and well I won't really go into the

00:08:25,289 --> 00:08:30,810
details of of all instructions but I

00:08:28,110 --> 00:08:32,940
should actually at least explain that

00:08:30,810 --> 00:08:38,520
piece of the dead short piece of code

00:08:32,940 --> 00:08:43,979
that's over there so so the push a call

00:08:38,520 --> 00:08:46,020
the push a instruction thus stores all

00:08:43,979 --> 00:08:47,940
those basically although all the

00:08:46,020 --> 00:08:50,130
registers ordered the whole state of the

00:08:47,940 --> 00:08:52,530
processor to a stack so you can modify

00:08:50,130 --> 00:08:53,769
the state and then later at the end with

00:08:52,530 --> 00:08:56,379
the puppy in

00:08:53,769 --> 00:08:59,709
struction you can recover the state the

00:08:56,379 --> 00:09:02,259
more instruction sets the content of the

00:08:59,709 --> 00:09:05,139
regular history ax which is kind of like

00:09:02,259 --> 00:09:09,660
the first register of the processor to

00:09:05,139 --> 00:09:13,959
very one the third line is a bit weird

00:09:09,660 --> 00:09:18,549
do you know Dukes or bit operation so so

00:09:13,959 --> 00:09:22,329
who knows what that third line does okay

00:09:18,549 --> 00:09:26,019
some of you do so well you take the

00:09:22,329 --> 00:09:28,809
content of the second register the ebdb

00:09:26,019 --> 00:09:31,660
X register of the processor and you can

00:09:28,809 --> 00:09:35,709
sort it with itself and thus orbit

00:09:31,660 --> 00:09:38,350
operation works in such a way that if if

00:09:35,709 --> 00:09:41,499
if the bits that you are soaring are the

00:09:38,350 --> 00:09:44,259
same the result will be 0 and if they

00:09:41,499 --> 00:09:47,139
are different the result will be 1 so if

00:09:44,259 --> 00:09:49,480
you saw some value with itself then all

00:09:47,139 --> 00:09:52,499
the other bids will be the same so

00:09:49,480 --> 00:09:56,739
result of that will be will be 0 so that

00:09:52,499 --> 00:10:00,730
third line actually sets ebx 20 it's a

00:09:56,739 --> 00:10:02,799
kind of weird way to to do things

00:10:00,730 --> 00:10:04,569
because you would expect that just the

00:10:02,799 --> 00:10:07,899
same line as the second one would be

00:10:04,569 --> 00:10:11,199
used and you just use 0 except of one

00:10:07,899 --> 00:10:13,480
there but this is actually well just

00:10:11,199 --> 00:10:17,290
more efficient way to write this it

00:10:13,480 --> 00:10:20,230
takes less less memory to write this so

00:10:17,290 --> 00:10:22,600
so you're so traditional compilers will

00:10:20,230 --> 00:10:26,079
produce rather this instruction than

00:10:22,600 --> 00:10:31,660
explicitly moving constant 02 due to the

00:10:26,079 --> 00:10:40,079
register okay the fourth line is kind of

00:10:31,660 --> 00:10:40,079
special because that makes a cisco so so

00:10:40,379 --> 00:10:47,709
it triggers a software interrupt and the

00:10:44,589 --> 00:10:49,929
end and the colonel will catch that

00:10:47,709 --> 00:10:52,629
interrupt and you will at that point

00:10:49,929 --> 00:10:54,879
your program will stop and the colonel

00:10:52,629 --> 00:11:01,509
will take over and do whatever you want

00:10:54,879 --> 00:11:03,790
it to do so here the eax is the idea of

00:11:01,509 --> 00:11:06,399
the cisco that you want to do and I

00:11:03,790 --> 00:11:07,530
admitted I actually forgot right now

00:11:06,399 --> 00:11:11,110
what

00:11:07,530 --> 00:11:13,840
what number is the cisco number one can

00:11:11,110 --> 00:11:15,820
anyone help me out here I see a lot of

00:11:13,840 --> 00:11:24,580
carnal hackers here surely they all know

00:11:15,820 --> 00:11:28,080
the cisco numbers by heart oh so we can

00:11:24,580 --> 00:11:28,080
fight it fastest

00:11:33,910 --> 00:11:43,000
well meanwhile a while traditional Isis

00:11:37,330 --> 00:11:44,620
course will return the value in again in

00:11:43,000 --> 00:11:50,620
the first register of the processor in

00:11:44,620 --> 00:11:56,970
eax so they end by the exit Cisco okay

00:11:50,620 --> 00:12:01,270
cool so this okay so a so so using this

00:11:56,970 --> 00:12:04,000
you exit the program with return code

00:12:01,270 --> 00:12:09,340
zero because ebx is the first parameter

00:12:04,000 --> 00:12:12,550
of the cisco so so so using this code

00:12:09,340 --> 00:12:15,490
you will exit the program and actually

00:12:12,550 --> 00:12:17,400
the the last two lines will never get

00:12:15,490 --> 00:12:23,320
executed so I don't know why do I have

00:12:17,400 --> 00:12:26,200
them in there okay anyway maybe you just

00:12:23,320 --> 00:12:27,970
got the general idea of how the assembly

00:12:26,200 --> 00:12:29,530
code works and of course if you will

00:12:27,970 --> 00:12:32,260
ever need to use it you will need to

00:12:29,530 --> 00:12:34,540
look at some some some more

00:12:32,260 --> 00:12:38,170
documentation but but maybe this will be

00:12:34,540 --> 00:12:40,390
a bit helpful yeah and I won't go into

00:12:38,170 --> 00:12:41,680
the details of this because it would be

00:12:40,390 --> 00:12:44,490
here for a long time and it would be

00:12:41,680 --> 00:12:50,740
very bored and I'll skip this as well

00:12:44,490 --> 00:12:56,590
okay so I promised to I promised to

00:12:50,740 --> 00:13:04,030
cover how Cisco's work and make sure the

00:12:56,590 --> 00:13:06,580
time okay basically the car now does its

00:13:04,030 --> 00:13:09,760
things it manages the hardware and talks

00:13:06,580 --> 00:13:12,370
with the list by end the keyboard and

00:13:09,760 --> 00:13:13,810
rice data to the disk and so on but its

00:13:12,370 --> 00:13:22,090
main purpose is to run programs of

00:13:13,810 --> 00:13:23,770
course and and the program's use the

00:13:22,090 --> 00:13:25,750
services of the colonel and the camera

00:13:23,770 --> 00:13:27,580
actually has a lot of interfaces to the

00:13:25,750 --> 00:13:29,920
programs that the programs can use but

00:13:27,580 --> 00:13:32,500
of course the primary interface is the

00:13:29,920 --> 00:13:34,990
cisco interface so when we say that we

00:13:32,500 --> 00:13:38,970
make a system call that means that we

00:13:34,990 --> 00:13:44,110
from our for example C code we run some

00:13:38,970 --> 00:13:46,230
function and and usually the G lipsy

00:13:44,110 --> 00:13:48,830
which is the C library

00:13:46,230 --> 00:13:51,330
which provides the basic basic

00:13:48,830 --> 00:13:54,060
environment for C programs it implements

00:13:51,330 --> 00:13:57,510
functions like printf and square root

00:13:54,060 --> 00:13:59,520
and so on they it it provides these

00:13:57,510 --> 00:14:00,960
functions that most of the time these

00:13:59,520 --> 00:14:04,770
functions are actually very thin

00:14:00,960 --> 00:14:08,090
wrappers that do only one thing and that

00:14:04,770 --> 00:14:11,370
is get control over to the cardinal and

00:14:08,090 --> 00:14:14,370
and let the colonel do its thing and

00:14:11,370 --> 00:14:17,130
then when the control returns pass the

00:14:14,370 --> 00:14:19,620
return code from the colonel back back

00:14:17,130 --> 00:14:21,710
to the program so actually most of the

00:14:19,620 --> 00:14:24,120
code of the cisco's is auto-generated

00:14:21,710 --> 00:14:28,110
only some cisco's have some special

00:14:24,120 --> 00:14:32,880
comparability code and so on but what

00:14:28,110 --> 00:14:37,710
actually does on inside the GFC you need

00:14:32,880 --> 00:14:42,320
to in some way let the colonel know that

00:14:37,710 --> 00:14:45,570
you wanted to take you want to take it

00:14:42,320 --> 00:14:47,850
you want it to take over so there are

00:14:45,570 --> 00:14:54,840
actually several ways to do that because

00:14:47,850 --> 00:14:56,610
well the at least well this a lot of I

00:14:54,840 --> 00:14:59,310
should know that a lot of this is Intel

00:14:56,610 --> 00:15:03,630
specific so it's specific to the pc

00:14:59,310 --> 00:15:08,100
platform x86 and some of it to x86 64

00:15:03,630 --> 00:15:10,170
and of course for for example on arms it

00:15:08,100 --> 00:15:12,390
will all work a little differently but

00:15:10,170 --> 00:15:13,710
that wouldn't there won't be very big

00:15:12,390 --> 00:15:17,790
differences but for example this is

00:15:13,710 --> 00:15:22,800
quite PC specific so and the pc platform

00:15:17,790 --> 00:15:25,530
has very long history so so so there is

00:15:22,800 --> 00:15:27,510
sort of comparability craft and also

00:15:25,530 --> 00:15:29,820
only new processors support certain

00:15:27,510 --> 00:15:33,390
interfaces and so on and it's the same

00:15:29,820 --> 00:15:38,520
with with Cisco's the traditional way to

00:15:33,390 --> 00:15:41,250
do a cisco is is to do this crazy int

00:15:38,520 --> 00:15:44,100
instruction and that's actually kind of

00:15:41,250 --> 00:15:46,560
remnant from the days of of doors and

00:15:44,100 --> 00:15:48,900
standalone applications and the Intel

00:15:46,560 --> 00:15:52,980
processors it actually runs a software

00:15:48,900 --> 00:15:57,840
interrupt which is what they actually

00:15:52,980 --> 00:15:59,640
does is is well in in the in the

00:15:57,840 --> 00:16:00,150
compatible in the real Modi the

00:15:59,640 --> 00:16:02,580
competitive

00:16:00,150 --> 00:16:06,750
the mode of the processor it it looks at

00:16:02,580 --> 00:16:08,820
the top of the memory and there you will

00:16:06,750 --> 00:16:10,680
you will have list of addresses that

00:16:08,820 --> 00:16:12,810
will end the specific interrupts and if

00:16:10,680 --> 00:16:14,520
the if the application requires a

00:16:12,810 --> 00:16:16,170
certain service for example to write

00:16:14,520 --> 00:16:19,950
something to the screen it will trigger

00:16:16,170 --> 00:16:21,750
and interrupt and and various parts of

00:16:19,950 --> 00:16:24,870
the of the system the operating system

00:16:21,750 --> 00:16:26,910
the bios some extension cards and

00:16:24,870 --> 00:16:30,930
whatever will provide services in

00:16:26,910 --> 00:16:32,280
specific interrupts and and and when the

00:16:30,930 --> 00:16:34,680
application requires some service it

00:16:32,280 --> 00:16:39,110
will it will it will trigger a specific

00:16:34,680 --> 00:16:41,640
interrupt and the control gets gets

00:16:39,110 --> 00:16:44,250
transferred to the to the code provided

00:16:41,640 --> 00:16:46,050
by the by the bios for example the bus

00:16:44,250 --> 00:16:50,100
does its thing and then returns the

00:16:46,050 --> 00:16:53,630
control in car now there is just a

00:16:50,100 --> 00:17:00,960
single interrupt handler that's this

00:16:53,630 --> 00:17:03,810
it's it's number is 128 and and if if a

00:17:00,960 --> 00:17:05,520
process actually actually actually does

00:17:03,810 --> 00:17:08,850
and into a software interrupt

00:17:05,520 --> 00:17:12,720
instruction it it it gets so called

00:17:08,850 --> 00:17:15,660
trapped and and 12 process rubles we

00:17:12,720 --> 00:17:17,640
will see oh wait you shouldn't do this

00:17:15,660 --> 00:17:19,890
you are just an application and it'll

00:17:17,640 --> 00:17:21,870
transfer control to the colonel and the

00:17:19,890 --> 00:17:24,270
colonel will provide in the interrupt

00:17:21,870 --> 00:17:26,130
interrupt handler and the interrupt

00:17:24,270 --> 00:17:28,800
handler will look at the first register

00:17:26,130 --> 00:17:32,040
see it see the number of the in that

00:17:28,800 --> 00:17:35,000
register and transfer the control to a

00:17:32,040 --> 00:17:37,950
specific function within the kernel

00:17:35,000 --> 00:17:41,130
based based on the number so cisco's

00:17:37,950 --> 00:17:43,710
this is so this way the processor will

00:17:41,130 --> 00:17:47,070
trap and stop the process at the point

00:17:43,710 --> 00:17:48,990
it calls this in function and transfer

00:17:47,070 --> 00:17:51,810
code to the colonel and the colonel will

00:17:48,990 --> 00:17:54,270
just run a specific function so each

00:17:51,810 --> 00:17:56,850
each cisco is actually just a function

00:17:54,270 --> 00:17:58,740
in the car now and if you just grab for

00:17:56,850 --> 00:18:01,620
the name of the cisco usually will

00:17:58,740 --> 00:18:03,810
easily find the entry point and you can

00:18:01,620 --> 00:18:07,830
follow actually what goes on in that

00:18:03,810 --> 00:18:11,309
cisco if you are trying to understand

00:18:07,830 --> 00:18:16,110
some corner cases or or whatever

00:18:11,309 --> 00:18:18,389
okay actually because this because this

00:18:16,110 --> 00:18:21,299
int instruction was used for different

00:18:18,389 --> 00:18:23,730
purposes in the past it's actually not

00:18:21,299 --> 00:18:25,860
as efficient as it could be it involves

00:18:23,730 --> 00:18:29,190
some extra memory lookups to find out

00:18:25,860 --> 00:18:32,029
exactly exactly exactly what what kind

00:18:29,190 --> 00:18:35,460
of of interrupt handler should be

00:18:32,029 --> 00:18:41,809
executed what address do we need to jump

00:18:35,460 --> 00:18:41,809
to N and so on so so newer processors

00:18:43,249 --> 00:18:49,919
provide some new instructions to do this

00:18:46,799 --> 00:18:53,299
and actually historically in the Intel

00:18:49,919 --> 00:18:57,690
and ma ma MD tackle do this at once and

00:18:53,299 --> 00:19:01,169
each of them developed its own pair of

00:18:57,690 --> 00:19:04,429
new instructions and and the

00:19:01,169 --> 00:19:08,460
instructions don't work the same way so

00:19:04,429 --> 00:19:09,809
it's so it depends on exactly what of

00:19:08,460 --> 00:19:12,450
these instructions your processor

00:19:09,809 --> 00:19:17,129
supports and if you are running on an

00:19:12,450 --> 00:19:19,350
older processor you will you will your

00:19:17,129 --> 00:19:21,779
processor will support nidra and then

00:19:19,350 --> 00:19:25,289
the question is how does the usual

00:19:21,779 --> 00:19:29,519
carnal shields you from this processor

00:19:25,289 --> 00:19:31,289
specifics but but but well here we are

00:19:29,519 --> 00:19:32,879
talking about the kernel interface so

00:19:31,289 --> 00:19:37,139
the question is how does the program

00:19:32,879 --> 00:19:39,929
know whether whether it whether the

00:19:37,139 --> 00:19:42,600
special efficient siskel instructions

00:19:39,929 --> 00:19:47,070
are supported or not and the answer for

00:19:42,600 --> 00:19:49,230
that is well the colonel knows so what

00:19:47,070 --> 00:19:53,730
we could actually do is for the kernel

00:19:49,230 --> 00:19:56,129
to provide some few special pages in the

00:19:53,730 --> 00:19:58,980
memory at some fixed addresses so that

00:19:56,129 --> 00:20:03,029
well the the user space process can rely

00:19:58,980 --> 00:20:05,009
on the existence of of some code at some

00:20:03,029 --> 00:20:07,279
specific address which is reserved and

00:20:05,009 --> 00:20:10,470
cannot be used for anything else and

00:20:07,279 --> 00:20:13,139
instead of making a cisco you will just

00:20:10,470 --> 00:20:16,590
call a function on this specific fixed

00:20:13,139 --> 00:20:19,190
address so this is called in general

00:20:16,590 --> 00:20:22,889
this concept is called VDS oh and it has

00:20:19,190 --> 00:20:25,110
some other advantages because switch to

00:20:22,889 --> 00:20:27,179
the colonel is very very slow

00:20:25,110 --> 00:20:29,850
you need to save the complete set of the

00:20:27,179 --> 00:20:32,549
processors sometimes some cases are even

00:20:29,850 --> 00:20:34,440
flashed and so on so so so so switching

00:20:32,549 --> 00:20:36,179
to the terminal to make a Cisco is

00:20:34,440 --> 00:20:37,320
extremely still and if you actually if

00:20:36,179 --> 00:20:39,510
you are trying to optimize the

00:20:37,320 --> 00:20:41,370
performance of your program you should

00:20:39,510 --> 00:20:44,520
try to avoid Cisco's as much as possible

00:20:41,370 --> 00:20:48,120
because they were still down in a huge

00:20:44,520 --> 00:20:51,090
way so but for example to get the

00:20:48,120 --> 00:20:52,850
current time you want to to get the

00:20:51,090 --> 00:20:55,380
current time with some precision

00:20:52,850 --> 00:20:57,750
normally you would make a cisco that

00:20:55,380 --> 00:20:59,970
enters the colonel and the colonel just

00:20:57,750 --> 00:21:03,150
looks up at some memory where the

00:20:59,970 --> 00:21:05,100
current time is and then saved it to the

00:21:03,150 --> 00:21:07,290
registrant through the control back to

00:21:05,100 --> 00:21:10,020
you but there is really no reason why

00:21:07,290 --> 00:21:13,200
the colonel should need to do this what

00:21:10,020 --> 00:21:15,299
if you had just this value in some page

00:21:13,200 --> 00:21:17,880
which was mapped directed to your memory

00:21:15,299 --> 00:21:20,250
space so instead of all this expensive

00:21:17,880 --> 00:21:22,970
transfer control to the car now you can

00:21:20,250 --> 00:21:25,290
just look at some specific address and

00:21:22,970 --> 00:21:27,360
because you are not changing any state

00:21:25,290 --> 00:21:29,490
you are just looking up some public

00:21:27,360 --> 00:21:32,600
value which is you don't even need to

00:21:29,490 --> 00:21:35,190
care about any security or whatever so

00:21:32,600 --> 00:21:41,130
actually this is again exactly what

00:21:35,190 --> 00:21:44,760
happens and and and the so-called v d-v

00:21:41,130 --> 00:21:47,130
DSO offers several interfaces like this

00:21:44,760 --> 00:21:48,960
so instead of calling consist call you

00:21:47,130 --> 00:21:51,179
will just call a function in this

00:21:48,960 --> 00:21:53,250
special page and the content of the page

00:21:51,179 --> 00:21:55,950
the code of the function is provided by

00:21:53,250 --> 00:21:58,440
the kernel and mapped to your to your

00:21:55,950 --> 00:22:00,690
context so that you just made this call

00:21:58,440 --> 00:22:04,950
and one of these functions is actually

00:22:00,690 --> 00:22:07,740
the V the VCS call function which you

00:22:04,950 --> 00:22:10,110
will call and the function will use the

00:22:07,740 --> 00:22:11,910
best method available for a processor

00:22:10,110 --> 00:22:14,340
for entering the Cardinal for calling

00:22:11,910 --> 00:22:16,880
the colonel so so if your processor is

00:22:14,340 --> 00:22:19,799
too old and doesn't support any extra

00:22:16,880 --> 00:22:22,230
instructions the VCS call function code

00:22:19,799 --> 00:22:25,049
will which is provided by the colonel

00:22:22,230 --> 00:22:27,570
will just contain the int call and if

00:22:25,049 --> 00:22:29,610
your processor is to enough it will it

00:22:27,570 --> 00:22:32,720
will contain the code that uses the best

00:22:29,610 --> 00:22:32,720
method for your processor

00:22:34,710 --> 00:22:40,750
okay yeah there is a lot of other abis

00:22:38,320 --> 00:22:43,110
and I won't go into the detail so did

00:22:40,750 --> 00:22:45,760
you so of course you will realize that

00:22:43,110 --> 00:22:50,230
you have some special file systems like

00:22:45,760 --> 00:22:53,380
such pros or / sis and you have some

00:22:50,230 --> 00:22:56,440
special special kind of files which

00:22:53,380 --> 00:22:58,360
actually or at least file descriptors

00:22:56,440 --> 00:22:59,799
which if you read they will provide you

00:22:58,360 --> 00:23:01,740
with some special data like

00:22:59,799 --> 00:23:05,530
notifications of events in the system

00:23:01,740 --> 00:23:07,809
and so on and I well I won't really go

00:23:05,530 --> 00:23:09,429
into the detail but you can find really

00:23:07,809 --> 00:23:15,929
a lot of information there so I

00:23:09,429 --> 00:23:20,350
recommend reading up on this okay so

00:23:15,929 --> 00:23:24,429
time to look at some extra legs so I

00:23:20,350 --> 00:23:26,020
mentioned the MF Cisco before and the MM

00:23:24,429 --> 00:23:28,840
syscall what it does is that it's the

00:23:26,020 --> 00:23:32,890
primary way for programs actually get

00:23:28,840 --> 00:23:36,130
memory allocated so it just calls the it

00:23:32,890 --> 00:23:39,280
just tells the colonel i need so i need

00:23:36,130 --> 00:23:42,220
i need some memory and it's tell us it

00:23:39,280 --> 00:23:44,320
what kind of memory it is and how large

00:23:42,220 --> 00:23:46,539
chunk of memory do you want if you

00:23:44,320 --> 00:23:48,429
wanted a map on a specific address or

00:23:46,539 --> 00:23:52,360
you don't care what address it will have

00:23:48,429 --> 00:23:54,820
and so on and it can be used in two

00:23:52,360 --> 00:23:57,580
basic modes it can be so called

00:23:54,820 --> 00:24:00,610
anonymous memory that is well just just

00:23:57,580 --> 00:24:03,370
just memory or it can be mapped memory

00:24:00,610 --> 00:24:05,710
and then it will be memory which is

00:24:03,370 --> 00:24:11,020
actually corresponding to the contents

00:24:05,710 --> 00:24:13,570
of some file so so then if you a map a

00:24:11,020 --> 00:24:15,820
file to do to the memory then by

00:24:13,570 --> 00:24:19,390
accessing memory you are actually

00:24:15,820 --> 00:24:21,940
reading data from the file and if you if

00:24:19,390 --> 00:24:24,070
you just access the memory then if then

00:24:21,940 --> 00:24:27,490
if the contents of the file isn't rich

00:24:24,070 --> 00:24:30,010
isn't right from the diskette well then

00:24:27,490 --> 00:24:32,620
the colonel will trap your access again

00:24:30,010 --> 00:24:34,990
and it will load the necessary data from

00:24:32,620 --> 00:24:38,440
from the from the disk to the memory and

00:24:34,990 --> 00:24:41,380
then well return the control back to you

00:24:38,440 --> 00:24:44,830
and you will get your data and it's also

00:24:41,380 --> 00:24:47,290
it also works for right writing so so if

00:24:44,830 --> 00:24:50,350
you modify the contents of the memory

00:24:47,290 --> 00:24:52,630
it will be propagated to the disk so

00:24:50,350 --> 00:24:55,600
it's an interesting way to access to

00:24:52,630 --> 00:24:58,030
access files it has its problems because

00:24:55,600 --> 00:25:00,550
attending to files is kind of

00:24:58,030 --> 00:25:02,680
problematic in this case because because

00:25:00,550 --> 00:25:04,690
well if you map some memory that isn't

00:25:02,680 --> 00:25:06,280
actually on the disk and then while

00:25:04,690 --> 00:25:08,350
strange things might happen and I won't

00:25:06,280 --> 00:25:11,710
really don't you want to go into the

00:25:08,350 --> 00:25:16,620
details of that but it's still it's

00:25:11,710 --> 00:25:20,380
still it's still very useful and well

00:25:16,620 --> 00:25:25,750
one interesting thing I use this for is

00:25:20,380 --> 00:25:28,150
to actually met the device file

00:25:25,750 --> 00:25:32,800
representing the physical memory of the

00:25:28,150 --> 00:25:35,110
processor then you can met a piece of

00:25:32,800 --> 00:25:37,420
physical memory of the processor to

00:25:35,110 --> 00:25:39,460
Europe to your memory to to the memory

00:25:37,420 --> 00:25:43,360
of the process because of course each

00:25:39,460 --> 00:25:47,260
process is different memory because

00:25:43,360 --> 00:25:49,660
because the memory is mapped from from

00:25:47,260 --> 00:25:51,760
virtual memory which is kind of like the

00:25:49,660 --> 00:25:54,280
the image of the world which is

00:25:51,760 --> 00:25:57,100
accessible to the to the to the process

00:25:54,280 --> 00:25:59,140
to to the physical memory because each

00:25:57,100 --> 00:26:01,600
pitch process if you look at the same

00:25:59,140 --> 00:26:03,040
address in each process each process

00:26:01,600 --> 00:26:04,600
will probably see something different

00:26:03,040 --> 00:26:06,580
because each process has different

00:26:04,600 --> 00:26:08,530
libraries loaded and the different

00:26:06,580 --> 00:26:11,020
amounts of memory allocated on different

00:26:08,530 --> 00:26:13,900
places and so on and the kernel or the

00:26:11,020 --> 00:26:15,970
processor or they cooperate on that they

00:26:13,900 --> 00:26:19,990
handle translation from this virtual

00:26:15,970 --> 00:26:22,540
memory to the physical memory and but

00:26:19,990 --> 00:26:24,610
sometimes it's useful to actually be

00:26:22,540 --> 00:26:27,730
able to access the physical memory of

00:26:24,610 --> 00:26:31,270
the process so there is this special

00:26:27,730 --> 00:26:32,950
device file that man which corresponds

00:26:31,270 --> 00:26:35,620
to the physical memory and the few more

00:26:32,950 --> 00:26:38,680
if you met a portion of this file then

00:26:35,620 --> 00:26:40,720
when you access the file you will you

00:26:38,680 --> 00:26:43,030
will you will you will modify the

00:26:40,720 --> 00:26:48,250
contents of the physical memory one

00:26:43,030 --> 00:26:50,070
reason why this is useful is well the

00:26:48,250 --> 00:26:52,960
processor is just a circuit and

00:26:50,070 --> 00:26:55,030
sometimes it's useful when you do some a

00:26:52,960 --> 00:26:59,740
little programming it's useful to

00:26:55,030 --> 00:27:00,570
realize this perspective and I and and

00:26:59,740 --> 00:27:02,970
you'll be able

00:27:00,570 --> 00:27:05,039
to understand some concepts better i

00:27:02,970 --> 00:27:07,230
think if you try programming some

00:27:05,039 --> 00:27:09,330
microcontrollers where you can directly

00:27:07,230 --> 00:27:13,409
manipulate the pins of your processor

00:27:09,330 --> 00:27:15,419
and at least for me I I gained I've

00:27:13,409 --> 00:27:17,820
gained a useful perspective on system

00:27:15,419 --> 00:27:21,779
programming by doing this and I realized

00:27:17,820 --> 00:27:23,850
a lot of things that that were bothering

00:27:21,779 --> 00:27:25,830
me and that I didn't really understand

00:27:23,850 --> 00:27:27,929
about the low level architecture of the

00:27:25,830 --> 00:27:29,720
operating system and so on and now adays

00:27:27,929 --> 00:27:34,889
is pretty easy to actually do this

00:27:29,720 --> 00:27:37,649
because for example you you can buy or

00:27:34,889 --> 00:27:40,320
well you can buy or raspberry pi or an

00:27:37,649 --> 00:27:44,460
hour doing or our board like this and

00:27:40,320 --> 00:27:46,889
just attach some such as some lights

00:27:44,460 --> 00:27:49,309
that you can blink with and entreat

00:27:46,889 --> 00:27:52,799
value from various buttons and so on it

00:27:49,309 --> 00:27:54,600
this way I think you'll learn learn to

00:27:52,799 --> 00:28:00,649
think about the processor in a new way

00:27:54,600 --> 00:28:00,649
and potentially useful way so okay

00:28:01,730 --> 00:28:07,529
actually how is this for example ticket

00:28:05,820 --> 00:28:10,649
dunno the Raspberry Pi have you heard

00:28:07,529 --> 00:28:13,679
about the earth berry pie hope you have

00:28:10,649 --> 00:28:17,250
hurt okay some of you not all of you

00:28:13,679 --> 00:28:20,460
Raspberry Pi small is a small board with

00:28:17,250 --> 00:28:22,590
ARM processor and some some connectors

00:28:20,460 --> 00:28:24,779
and some some video connector and USB

00:28:22,590 --> 00:28:28,830
connectors and and stuff like that you

00:28:24,779 --> 00:28:33,029
can buy it for for something like thirty

00:28:28,830 --> 00:28:35,549
five or forty dollars and and one

00:28:33,029 --> 00:28:39,389
interesting feature it has it has a GPIO

00:28:35,549 --> 00:28:42,299
header so well you can run linux on this

00:28:39,389 --> 00:28:44,309
on this tiny on this tiny board but you

00:28:42,299 --> 00:28:47,490
can also attach some some lights or

00:28:44,309 --> 00:28:51,509
motors or buttons to to the GPIO pins

00:28:47,490 --> 00:28:54,389
and if you actually write to specific

00:28:51,509 --> 00:28:57,539
portions of the memory you will be able

00:28:54,389 --> 00:28:59,700
to change the status of these pins

00:28:57,539 --> 00:29:03,570
whether there is whether these pins are

00:28:59,700 --> 00:29:06,149
connected to some voltage source or if

00:29:03,570 --> 00:29:08,909
they will be grounded and on that

00:29:06,149 --> 00:29:11,250
depends whether your motor will turn or

00:29:08,909 --> 00:29:13,590
if your light will shine or if it will

00:29:11,250 --> 00:29:16,590
be dark so

00:29:13,590 --> 00:29:20,070
so all this is done by accessing a

00:29:16,590 --> 00:29:23,669
special special portion of the memory

00:29:20,070 --> 00:29:27,539
and well this is a map call actually

00:29:23,669 --> 00:29:29,760
that's right thus does exactly this so

00:29:27,539 --> 00:29:31,770
will you open open the file you get it

00:29:29,760 --> 00:29:33,600
the divide the definitely device file

00:29:31,770 --> 00:29:37,110
you get to file descriptor and then you

00:29:33,600 --> 00:29:40,650
call this crazy three line this crazy

00:29:37,110 --> 00:29:42,480
three line em up call which actually

00:29:40,650 --> 00:29:44,490
well let's take a brief look at the

00:29:42,480 --> 00:29:48,299
parameters the first parameters the

00:29:44,490 --> 00:29:49,799
desired address where you want to to

00:29:48,299 --> 00:29:53,250
have the memory mapped we don't really

00:29:49,799 --> 00:29:56,610
care here if what value the pointer to

00:29:53,250 --> 00:29:59,429
the memory will will will have so so we

00:29:56,610 --> 00:30:01,590
just put no Durant that the operating

00:29:59,429 --> 00:30:04,380
system decides of whatever suites it

00:30:01,590 --> 00:30:06,750
best the second parameter gpio block

00:30:04,380 --> 00:30:09,240
size is how much memory we want so have

00:30:06,750 --> 00:30:12,000
a large chunk of memory do we want

00:30:09,240 --> 00:30:16,350
mapped the the fella the third parameter

00:30:12,000 --> 00:30:18,870
is what kind of things do we want to do

00:30:16,350 --> 00:30:21,360
with the memory here we want to be able

00:30:18,870 --> 00:30:23,820
to read from the memory to get to check

00:30:21,360 --> 00:30:26,940
the current state of the GPIO pins and

00:30:23,820 --> 00:30:28,980
to write to the memory to change the

00:30:26,940 --> 00:30:33,299
value of the pins or the mode of the

00:30:28,980 --> 00:30:35,399
pins and so on and what's missing there

00:30:33,299 --> 00:30:39,630
is one other thing that we could have

00:30:35,399 --> 00:30:42,659
want to do is say it's easy cute code

00:30:39,630 --> 00:30:45,330
there of course that's that's nonsense

00:30:42,659 --> 00:30:50,190
44 area which is reserved to gpio pins

00:30:45,330 --> 00:30:52,559
unless you want to come to to well run

00:30:50,190 --> 00:30:54,630
code on your Raspberry Pi by setting up

00:30:52,559 --> 00:30:56,850
the GPIO pins in a specific way so that

00:30:54,630 --> 00:30:58,740
it corresponds to some instructions or

00:30:56,850 --> 00:31:01,409
whatever but it's not that's a bit

00:30:58,740 --> 00:31:03,090
contrived I guess but but if you map

00:31:01,409 --> 00:31:06,600
some file then it makes a difference

00:31:03,090 --> 00:31:09,149
whether you allow code code which is

00:31:06,600 --> 00:31:13,350
contained in such file to be executed or

00:31:09,149 --> 00:31:17,039
not and the next parameter map chart and

00:31:13,350 --> 00:31:20,789
not fixed map fixed is actually nonsense

00:31:17,039 --> 00:31:23,010
there ignore that please but but but map

00:31:20,789 --> 00:31:26,010
chart says that

00:31:23,010 --> 00:31:29,070
I don't want a private copy of this

00:31:26,010 --> 00:31:31,500
memory but i will but when i make some

00:31:29,070 --> 00:31:34,320
changes i want everyone to see these

00:31:31,500 --> 00:31:38,100
changes this actually makes a big

00:31:34,320 --> 00:31:41,850
difference and actually like two months

00:31:38,100 --> 00:31:44,130
ago I was at the customers and who you

00:31:41,850 --> 00:31:47,100
are we were debugging some some I'm up

00:31:44,130 --> 00:31:50,340
I'm up using code some some user space

00:31:47,100 --> 00:31:51,840
beside driver and after four hours it's

00:31:50,340 --> 00:31:53,940
turned out that the mistake was that

00:31:51,840 --> 00:31:56,970
they were mapping the device memory

00:31:53,940 --> 00:31:59,160
using not map shared but not private and

00:31:56,970 --> 00:32:03,270
if you map some memory with not private

00:31:59,160 --> 00:32:06,570
that means that when you change that

00:32:03,270 --> 00:32:09,090
memory only you see these changes so if

00:32:06,570 --> 00:32:12,270
you if you modify that memory a copy of

00:32:09,090 --> 00:32:14,580
the original page is made and from then

00:32:12,270 --> 00:32:16,530
on you are on your own playground and

00:32:14,580 --> 00:32:19,320
you can make changes but no one else

00:32:16,530 --> 00:32:21,600
will see see the changes and the changes

00:32:19,320 --> 00:32:24,090
will not be propagated back to the file

00:32:21,600 --> 00:32:25,680
so in this case back to the memory which

00:32:24,090 --> 00:32:27,150
and what we want the changes to be

00:32:25,680 --> 00:32:29,220
propagated back to the number this is

00:32:27,150 --> 00:32:33,480
the whole point so so we use the map

00:32:29,220 --> 00:32:35,550
shared flat okay yeah mmmm FD a

00:32:33,480 --> 00:32:38,910
parameter me is that ok we want map

00:32:35,550 --> 00:32:42,060
memory from from this file from dead man

00:32:38,910 --> 00:32:44,670
and the last parameter is the offset so

00:32:42,060 --> 00:32:47,790
so so the GPIO pins are controlled by a

00:32:44,670 --> 00:32:49,860
memory region at a fixed address and and

00:32:47,790 --> 00:32:54,120
that address is stored in the GPIO base

00:32:49,860 --> 00:32:56,430
constant so this is this is how we have

00:32:54,120 --> 00:32:59,760
the of this works and well memory is a

00:32:56,430 --> 00:33:02,640
wonderful place and actually well okay

00:32:59,760 --> 00:33:06,000
that was that one was some tiny tiny arm

00:33:02,640 --> 00:33:09,750
board but even on your pc this might be

00:33:06,000 --> 00:33:12,060
useful because sometimes well i agree

00:33:09,750 --> 00:33:14,130
that it's a bit dubious practice but

00:33:12,060 --> 00:33:16,590
sometimes sometimes you will you will

00:33:14,130 --> 00:33:19,410
meet it and and sometimes it's it's used

00:33:16,590 --> 00:33:21,840
at the driver for some for some device

00:33:19,410 --> 00:33:23,880
for example for some pci card is not

00:33:21,840 --> 00:33:26,790
implemented in the kernel but it runs in

00:33:23,880 --> 00:33:29,250
user space and sometimes it can be

00:33:26,790 --> 00:33:31,350
useful for quick prototyping of drivers

00:33:29,250 --> 00:33:33,450
or whatever just learning how the device

00:33:31,350 --> 00:33:35,280
works before you start actually touching

00:33:33,450 --> 00:33:36,120
the patching the touching the kernel

00:33:35,280 --> 00:33:39,090
code

00:33:36,120 --> 00:33:44,520
and with with all the worries associated

00:33:39,090 --> 00:33:47,370
with that so actually each PC I part

00:33:44,520 --> 00:33:51,030
that you have in your in your PC

00:33:47,370 --> 00:33:53,640
provides some memory sometimes it uses

00:33:51,030 --> 00:33:56,700
that just to talk with with the rest of

00:33:53,640 --> 00:33:59,370
the computer so so it provides a memory

00:33:56,700 --> 00:34:01,950
region fe and if you write something to

00:33:59,370 --> 00:34:04,110
that memory region it the card

00:34:01,950 --> 00:34:06,330
interprets that as a specific comment

00:34:04,110 --> 00:34:09,840
for example transfer data receive data

00:34:06,330 --> 00:34:13,080
whatever and and then if you write with

00:34:09,840 --> 00:34:15,510
some different place it will it will it

00:34:13,080 --> 00:34:19,580
will set the parameters of that or for

00:34:15,510 --> 00:34:23,190
example the your graphics card provides

00:34:19,580 --> 00:34:26,220
provides its video memory also as a

00:34:23,190 --> 00:34:28,590
memory and this is vice versa

00:34:26,220 --> 00:34:30,630
standardized right of the picture back

00:34:28,590 --> 00:34:32,400
to your channel doesn't really need to

00:34:30,630 --> 00:34:34,290
recognize the device you don't really

00:34:32,400 --> 00:34:36,780
need any driver for that but you will

00:34:34,290 --> 00:34:39,770
still be able to access these regions

00:34:36,780 --> 00:34:43,560
using that that that file in the

00:34:39,770 --> 00:34:46,290
directory and if you look at it it's a

00:34:43,560 --> 00:34:49,890
looks like a regular file its size

00:34:46,290 --> 00:34:53,460
corresponds to the size the its ties

00:34:49,890 --> 00:34:56,040
corresponds to the to the size of the

00:34:53,460 --> 00:34:59,610
region and again if you open it and am a

00:34:56,040 --> 00:35:03,150
bit then if you if you write something

00:34:59,610 --> 00:35:05,970
to it it gets actually written the data

00:35:03,150 --> 00:35:07,860
actually gets sent to the card and the

00:35:05,970 --> 00:35:10,800
card can recognize it as a comment or

00:35:07,860 --> 00:35:13,530
whatever and then you can reach it by

00:35:10,800 --> 00:35:16,620
its back end and talk with the card like

00:35:13,530 --> 00:35:19,800
this yeah and again i repeat be careful

00:35:16,620 --> 00:35:22,710
about web shark vs let's prayver it

00:35:19,800 --> 00:35:25,080
won't really work yeah there is actually

00:35:22,710 --> 00:35:28,290
a useful command line utility for that

00:35:25,080 --> 00:35:30,590
as well the URL is here pc item if you

00:35:28,290 --> 00:35:35,730
just google it you'll find it easily

00:35:30,590 --> 00:35:42,510
okay oh I'm thinking I'm going way too

00:35:35,730 --> 00:35:47,070
slow hmm okay so well just briefly about

00:35:42,510 --> 00:35:49,660
the format which is used for which is

00:35:47,070 --> 00:35:52,759
used for

00:35:49,660 --> 00:35:55,189
the binary is the programs of the system

00:35:52,759 --> 00:35:57,619
it's called Alf or executable and

00:35:55,189 --> 00:36:00,349
thinkable format and it's actually a

00:35:57,619 --> 00:36:04,930
very interesting convention because it's

00:36:00,349 --> 00:36:08,449
a single format which allows all kind of

00:36:04,930 --> 00:36:11,420
run a runtime data to be to be stored it

00:36:08,449 --> 00:36:14,539
can be a code of a program well by code

00:36:11,420 --> 00:36:17,749
I mean compiled code here it can it can

00:36:14,539 --> 00:36:20,479
it can store executable problem programs

00:36:17,749 --> 00:36:23,140
it can store shared libraries it can

00:36:20,479 --> 00:36:25,519
store core dumps it can store

00:36:23,140 --> 00:36:28,699
intermediate object files which are used

00:36:25,519 --> 00:36:31,430
for further further linking and so on

00:36:28,699 --> 00:36:34,039
and it's all it's it's all just a single

00:36:31,430 --> 00:36:36,769
single format which is very flexible and

00:36:34,039 --> 00:36:38,719
the thing you should remember that that

00:36:36,769 --> 00:36:43,969
there are sections and the sections

00:36:38,719 --> 00:36:46,670
describe describe information which is

00:36:43,969 --> 00:36:48,559
required for linking for example there

00:36:46,670 --> 00:36:50,359
is well there is a section that there is

00:36:48,559 --> 00:36:52,549
that so-called text section which

00:36:50,359 --> 00:36:54,709
contains the actual code there is a

00:36:52,549 --> 00:36:57,829
section with program header which

00:36:54,709 --> 00:37:00,619
contains some well useful general

00:36:57,829 --> 00:37:03,259
general description of the program and

00:37:00,619 --> 00:37:06,739
there is there is a section which

00:37:03,259 --> 00:37:08,900
contains lists all of its symbol list of

00:37:06,739 --> 00:37:11,449
all symbols that it depends on that

00:37:08,900 --> 00:37:14,029
means if the for example if you have a

00:37:11,449 --> 00:37:18,140
program which caused the print function

00:37:14,029 --> 00:37:20,479
call the formatted print then well of

00:37:18,140 --> 00:37:22,519
course the program doesn't provide this

00:37:20,479 --> 00:37:24,650
function call itself but it depends on

00:37:22,519 --> 00:37:27,109
an external library for that so there is

00:37:24,650 --> 00:37:30,349
a special table which contains the print

00:37:27,109 --> 00:37:32,660
fur label and says okay for this program

00:37:30,349 --> 00:37:35,269
to work we need to have something linked

00:37:32,660 --> 00:37:40,009
in some shared library or whatever which

00:37:35,269 --> 00:37:42,140
provides the print function call so it

00:37:40,009 --> 00:37:45,109
has typos like this and it also has

00:37:42,140 --> 00:37:47,269
so-called segments and segments describe

00:37:45,109 --> 00:37:51,199
how are things actually loaded in the

00:37:47,269 --> 00:37:53,509
memory when you when you want to run the

00:37:51,199 --> 00:37:56,390
program so it describes okay I want this

00:37:53,509 --> 00:38:00,410
data loaded here and that code for the

00:37:56,390 --> 00:38:01,940
dare and so on plus K to avoid confusion

00:38:00,410 --> 00:38:04,160
you should probably say

00:38:01,940 --> 00:38:06,859
that the sections and segments overlap

00:38:04,160 --> 00:38:09,079
so yeah yeah of course you have a text

00:38:06,859 --> 00:38:11,240
section and the text which contains the

00:38:09,079 --> 00:38:13,670
code and of course the text section is

00:38:11,240 --> 00:38:15,589
also part of some segments because you

00:38:13,670 --> 00:38:17,720
really want this load it in the memory

00:38:15,589 --> 00:38:20,480
but you can have multiple signals

00:38:17,720 --> 00:38:22,819
because for example you want an

00:38:20,480 --> 00:38:24,680
executable segment with the code some

00:38:22,819 --> 00:38:27,920
read-only cygnet with trees on the data

00:38:24,680 --> 00:38:33,530
and retry segment with saran time data

00:38:27,920 --> 00:38:36,140
and so on okay okay I should go faster

00:38:33,530 --> 00:38:38,300
here so so I actually wanted to show you

00:38:36,140 --> 00:38:40,280
the code which does then but I don't

00:38:38,300 --> 00:38:41,930
even has time for that so well you have

00:38:40,280 --> 00:38:45,140
some file names in the kernel that you

00:38:41,930 --> 00:38:48,079
can actually look at if you want you

00:38:45,140 --> 00:38:50,930
just well if you want to execute the

00:38:48,079 --> 00:38:53,420
program of course first you need to

00:38:50,930 --> 00:38:56,690
create a new process if you don't want

00:38:53,420 --> 00:38:58,339
the new program to substitute for the

00:38:56,690 --> 00:39:00,560
original program if for example if you

00:38:58,339 --> 00:39:02,569
are starting some program from midnight

00:39:00,560 --> 00:39:04,849
commander then midnight commander needs

00:39:02,569 --> 00:39:08,000
to create a new process so that midnight

00:39:04,849 --> 00:39:10,160
commanders keeps running while the new

00:39:08,000 --> 00:39:13,060
program also runs so first you create a

00:39:10,160 --> 00:39:13,060
new focus with

00:39:13,710 --> 00:39:15,770
you

00:39:21,950 --> 00:39:24,010
you

00:43:11,880 --> 00:43:18,480
does game and we would like to run this

00:43:14,490 --> 00:43:20,819
game just in just the just as a Linux

00:43:18,480 --> 00:43:25,349
process it actually isn't as difficult

00:43:20,819 --> 00:43:27,930
as it seems okay so we take the exam

00:43:25,349 --> 00:43:30,000
file of the game for example and women

00:43:27,930 --> 00:43:31,980
well apart from all the real locations

00:43:30,000 --> 00:43:34,980
which are contained in the header of the

00:43:31,980 --> 00:43:37,470
of file of the excel file and all the

00:43:34,980 --> 00:43:40,859
rest is just code that we could be able

00:43:37,470 --> 00:43:44,730
to run directly right the only problem

00:43:40,859 --> 00:43:47,279
is that well okay maybe it directly

00:43:44,730 --> 00:43:49,650
excesses some kind of hardware and it

00:43:47,279 --> 00:43:51,059
directly draws all the sprites and all

00:43:49,650 --> 00:43:54,000
the graphics to some kind of frame

00:43:51,059 --> 00:43:55,500
buffer and it is it caused some

00:43:54,000 --> 00:43:58,799
interrupt routine at the current

00:43:55,500 --> 00:44:00,450
position of the mouse and so on but but

00:43:58,799 --> 00:44:02,490
actually what we can do we can do two

00:44:00,450 --> 00:44:04,619
things we can find some problematic

00:44:02,490 --> 00:44:06,930
parts of the code and patch it of course

00:44:04,619 --> 00:44:09,569
by just replacing the instructions but

00:44:06,930 --> 00:44:11,400
that's kind of boring there is other

00:44:09,569 --> 00:44:15,690
interesting things we can do for example

00:44:11,400 --> 00:44:18,450
if the program accesses the graphics

00:44:15,690 --> 00:44:22,289
memory okay we can use for example sdl

00:44:18,450 --> 00:44:26,359
which is a pretty well-known well-known

00:44:22,289 --> 00:44:29,279
graphics library and it allows us to to

00:44:26,359 --> 00:44:31,769
allocate a frame buffer which is an area

00:44:29,279 --> 00:44:33,809
of memory where we can write to actually

00:44:31,769 --> 00:44:36,329
make pixels show on the screen with the

00:44:33,809 --> 00:44:40,079
right colors and one thing we can do is

00:44:36,329 --> 00:44:44,599
we can use the em up system call to

00:44:40,079 --> 00:44:47,670
request the frame buffer at a specific

00:44:44,599 --> 00:44:49,759
place in the memory which is compatible

00:44:47,670 --> 00:44:54,150
with the place where the graphics card

00:44:49,759 --> 00:44:56,039
puts it in in the in the doors another

00:44:54,150 --> 00:44:58,559
thing is okay what about the interrupt

00:44:56,039 --> 00:45:01,230
routines for example the of for example

00:44:58,559 --> 00:45:04,380
if the dos game wants to open a file or

00:45:01,230 --> 00:45:07,920
get the current position of the mouse it

00:45:04,380 --> 00:45:10,769
it called it executed some instructions

00:45:07,920 --> 00:45:12,329
which would normally be trapped and the

00:45:10,769 --> 00:45:13,559
ant linkscanner will just kill the

00:45:12,329 --> 00:45:15,299
process because the process did

00:45:13,559 --> 00:45:17,309
something it doesn't have permissions to

00:45:15,299 --> 00:45:20,849
do and which it doesn't make any sense

00:45:17,309 --> 00:45:23,990
in in the linux context anyway but okay

00:45:20,849 --> 00:45:25,770
how does the colonel kill the

00:45:23,990 --> 00:45:29,030
application by sending

00:45:25,770 --> 00:45:34,250
the by sending it the segmentation fault

00:45:29,030 --> 00:45:37,020
signal and well we can insert our own

00:45:34,250 --> 00:45:39,150
signal Hondros for most of the signals

00:45:37,020 --> 00:45:42,990
including segmentation fault and

00:45:39,150 --> 00:45:45,660
actually it isn't really very well

00:45:42,990 --> 00:45:47,880
documented but about the but normally

00:45:45,660 --> 00:45:49,920
the signal hand-roll will get just a

00:45:47,880 --> 00:45:51,990
single parameter with the name with the

00:45:49,920 --> 00:45:54,330
number of the signal received but for

00:45:51,990 --> 00:45:58,640
some signals you can there is another

00:45:54,330 --> 00:46:01,410
parameter that you can that that you can

00:45:58,640 --> 00:46:03,690
receive and that's a special structure

00:46:01,410 --> 00:46:06,870
which will exactly describe where this

00:46:03,690 --> 00:46:09,420
segmentation fault happened and what

00:46:06,870 --> 00:46:14,310
what was the value of all the registers

00:46:09,420 --> 00:46:16,470
so so so if if if the if the if the

00:46:14,310 --> 00:46:18,870
binary makes makes a call to the dos

00:46:16,470 --> 00:46:20,820
operating system that will be trapped at

00:46:18,870 --> 00:46:22,740
that point and you will get the

00:46:20,820 --> 00:46:24,180
segmentation fault but in that hand

00:46:22,740 --> 00:46:26,940
where you can look at the particular

00:46:24,180 --> 00:46:29,040
code there and look at the value of the

00:46:26,940 --> 00:46:30,630
registers and you will know what kind of

00:46:29,040 --> 00:46:33,060
interrupt or what kind of instruction

00:46:30,630 --> 00:46:35,730
happened and look at the registers and

00:46:33,060 --> 00:46:38,430
actually emulate emulate emulate this

00:46:35,730 --> 00:46:40,410
code and set up a back the registers to

00:46:38,430 --> 00:46:41,760
the correct return values and threaten

00:46:40,410 --> 00:46:44,580
control back to the program at the

00:46:41,760 --> 00:46:46,950
control and the program even even though

00:46:44,580 --> 00:46:50,700
it received a segmentation fault signal

00:46:46,950 --> 00:46:54,480
can run merrily on and there is other

00:46:50,700 --> 00:46:56,940
sick tricks like this so but this but

00:46:54,480 --> 00:46:58,680
custom segmentation handler for the

00:46:56,940 --> 00:47:00,720
handlers actually very useful and you

00:46:58,680 --> 00:47:02,340
can even use one too for example print

00:47:00,720 --> 00:47:07,280
out the back trace of the program and so

00:47:02,340 --> 00:47:10,260
on okay and the almost last slide is

00:47:07,280 --> 00:47:11,880
well this is the last system code I I

00:47:10,260 --> 00:47:15,300
would really like you to know about

00:47:11,880 --> 00:47:17,760
because it's useful to know how that's

00:47:15,300 --> 00:47:20,550
for example the estrous tool or gdb work

00:47:17,760 --> 00:47:24,690
internally I don't know who you ever

00:47:20,550 --> 00:47:29,240
used the stress tool okay almost

00:47:24,690 --> 00:47:32,310
everyone for those who didn't this is

00:47:29,240 --> 00:47:35,100
for me it's perhaps the most essential

00:47:32,310 --> 00:47:37,500
debugging tool I use if some program is

00:47:35,100 --> 00:47:39,180
a bit behaves it can be any program it

00:47:37,500 --> 00:47:41,609
can be an application program and

00:47:39,180 --> 00:47:44,700
I have never seen the sources but if it

00:47:41,609 --> 00:47:46,800
fells mysteriously often the easiest way

00:47:44,700 --> 00:47:49,079
to find out what actually goes wrong

00:47:46,800 --> 00:47:51,359
internally is to run it using estrace

00:47:49,079 --> 00:47:55,380
because estrace is a tool which runs the

00:47:51,359 --> 00:47:57,420
program but but but traps all the system

00:47:55,380 --> 00:47:59,940
calls the program makes including the

00:47:57,420 --> 00:48:02,849
parameters so you can exactly see what

00:47:59,940 --> 00:48:05,339
kind of files the program tries to open

00:48:02,849 --> 00:48:07,440
if that succeeded what kind of data it

00:48:05,339 --> 00:48:10,800
right is there and so on and often if

00:48:07,440 --> 00:48:13,530
okay the program says it cannot open

00:48:10,800 --> 00:48:16,890
some file or or cannot write some data

00:48:13,530 --> 00:48:19,619
somewhere then the way to find out

00:48:16,890 --> 00:48:22,010
exactly what goes wrong and be able to

00:48:19,619 --> 00:48:26,130
repair it is to run it using estrace and

00:48:22,010 --> 00:48:31,260
and as trace will will will will give

00:48:26,130 --> 00:48:33,420
you all this information and and how

00:48:31,260 --> 00:48:35,910
does it and actually a stretch is kind

00:48:33,420 --> 00:48:38,520
of interesting in in that it can also

00:48:35,910 --> 00:48:41,220
attach to an already running process so

00:48:38,520 --> 00:48:43,140
you have some demon demon which is

00:48:41,220 --> 00:48:45,299
running on the background and it does

00:48:43,140 --> 00:48:47,490
something queer toward it it starts

00:48:45,299 --> 00:48:50,130
consuming one hundred percent of the CPU

00:48:47,490 --> 00:48:53,790
and you want to know what's going on did

00:48:50,130 --> 00:48:57,329
it get into some some some infinite loop

00:48:53,790 --> 00:49:00,690
or is it trying to repeatedly read from

00:48:57,329 --> 00:49:03,119
some file or whatever again if you use a

00:49:00,690 --> 00:49:05,069
stress you can attach attach to this to

00:49:03,119 --> 00:49:08,750
this process and to immediately start

00:49:05,069 --> 00:49:13,349
seeing what kind of system calls it it

00:49:08,750 --> 00:49:16,109
it called it calls so the way this

00:49:13,349 --> 00:49:19,799
internally works is using the pit race a

00:49:16,109 --> 00:49:21,780
system call and while it's system call

00:49:19,799 --> 00:49:23,869
which is kind of famous for the amount

00:49:21,780 --> 00:49:27,630
of security holes that are actually

00:49:23,869 --> 00:49:30,569
contained in it so so sometimes it's

00:49:27,630 --> 00:49:33,180
actually even disabled but but I think

00:49:30,569 --> 00:49:35,640
there are there are some yeah I I think

00:49:33,180 --> 00:49:38,220
in some versions of Ubuntu it's disabled

00:49:35,640 --> 00:49:41,430
but well I hope there are still some way

00:49:38,220 --> 00:49:46,020
to enable it otherwise the flag for the

00:49:41,430 --> 00:49:50,880
ubuntu users just move to the vm or

00:49:46,020 --> 00:49:52,730
opensuse okay and the ptrace call allows

00:49:50,880 --> 00:49:54,980
you to manipulate with

00:49:52,730 --> 00:49:57,290
running processes like totally

00:49:54,980 --> 00:49:59,750
manipulate with them you connect to them

00:49:57,290 --> 00:50:01,940
you stop you stop the process and using

00:49:59,750 --> 00:50:03,440
P trace calls you can inspect the

00:50:01,940 --> 00:50:05,690
current value of all the wretched

00:50:03,440 --> 00:50:07,940
processor registers within the context

00:50:05,690 --> 00:50:10,100
of this process you can single-step the

00:50:07,940 --> 00:50:12,020
process instruction by instruction you

00:50:10,100 --> 00:50:14,990
can let it run until the next fiscal and

00:50:12,020 --> 00:50:19,040
just trap at that Cisco you can write to

00:50:14,990 --> 00:50:21,950
memory of that process and actually you

00:50:19,040 --> 00:50:24,380
can do pretty neat things using that for

00:50:21,950 --> 00:50:26,300
example okay you run some program and

00:50:24,380 --> 00:50:28,760
then the program runs longer than you

00:50:26,300 --> 00:50:31,160
thought and you need to go away already

00:50:28,760 --> 00:50:34,880
but you'd like to see what the program

00:50:31,160 --> 00:50:37,280
did when you are back home but you

00:50:34,880 --> 00:50:39,410
forgot to run the program inside the

00:50:37,280 --> 00:50:42,440
screen or a similar to which which it

00:50:39,410 --> 00:50:43,940
allows you to attach back to do to

00:50:42,440 --> 00:50:46,940
attach the program back and look at its

00:50:43,940 --> 00:50:51,830
output one thing you can you could do is

00:50:46,940 --> 00:50:55,430
use ptrace to override some currently

00:50:51,830 --> 00:50:58,310
running code in the in the program with

00:50:55,430 --> 00:51:02,360
with instructions and system calls which

00:50:58,310 --> 00:51:04,700
will change the terminal the controlling

00:51:02,360 --> 00:51:07,850
terminal and standard input and output

00:51:04,700 --> 00:51:11,840
of the program from its current standard

00:51:07,850 --> 00:51:13,610
input and output to your new input and

00:51:11,840 --> 00:51:16,280
output for example of your ssh session

00:51:13,610 --> 00:51:20,840
that that you started when you when we

00:51:16,280 --> 00:51:23,660
went back home so of course you doing

00:51:20,840 --> 00:51:26,300
that manually with Pete trace is sounds

00:51:23,660 --> 00:51:28,580
pretty scary but there are tools which

00:51:26,300 --> 00:51:30,980
can do this for you already but how they

00:51:28,580 --> 00:51:33,110
work is exactly using Petrus they use

00:51:30,980 --> 00:51:35,540
Pete race to replace existing pieces of

00:51:33,110 --> 00:51:37,700
memory in the running process to run the

00:51:35,540 --> 00:51:40,250
code the day once it's to run which will

00:51:37,700 --> 00:51:42,050
replace the file descriptors and and

00:51:40,250 --> 00:51:45,800
then give the control back to the

00:51:42,050 --> 00:51:47,660
program and pjs is a very useful tool

00:51:45,800 --> 00:51:52,550
for that to allow this kind of

00:51:47,660 --> 00:51:55,070
manipulation okay so one yeah yeah I

00:51:52,550 --> 00:51:57,320
promised you some committed code stores

00:51:55,070 --> 00:51:59,780
but it turns out well I would need at

00:51:57,320 --> 00:52:01,520
least extra half an hour which is not

00:51:59,780 --> 00:52:04,550
something that the schedule allows for

00:52:01,520 --> 00:52:06,890
so so the if you are really

00:52:04,550 --> 00:52:09,260
interested then we can make

00:52:06,890 --> 00:52:10,849
additional session where we can look at

00:52:09,260 --> 00:52:14,119
some of the details whatever interests

00:52:10,849 --> 00:52:16,940
you okay so that's that's all from me

00:52:14,119 --> 00:52:25,609
and I wonder if you have any questions

00:52:16,940 --> 00:52:31,309
or I don't know how this works I scared

00:52:25,609 --> 00:52:43,760
everyone too much okay there is a

00:52:31,309 --> 00:52:46,579
question hey is there a binary to easily

00:52:43,760 --> 00:52:52,880
read out deaf man which also gives you

00:52:46,579 --> 00:52:56,059
some comfortable options to whatever I

00:52:52,880 --> 00:52:58,940
found some code or it's easy to make up

00:52:56,059 --> 00:53:06,799
yourself but it's just something what do

00:52:58,940 --> 00:53:08,720
you mean by confortable options you can

00:53:06,799 --> 00:53:11,720
use some right now senator the whole

00:53:08,720 --> 00:53:14,779
memory area dumb whatever just just that

00:53:11,720 --> 00:53:18,109
you can use it just that you don't have

00:53:14,779 --> 00:53:20,180
to make up your own soup rogram mmm well

00:53:18,109 --> 00:53:23,000
yeah I think the best of the best way to

00:53:20,180 --> 00:53:25,670
do that is just use some hex editor

00:53:23,000 --> 00:53:30,859
which has enough capabilities to do this

00:53:25,670 --> 00:53:32,809
I can do a shameless plug here there is

00:53:30,859 --> 00:53:37,059
a hex editor that I wrote some time ago

00:53:32,809 --> 00:53:40,819
and lib or maintenance it now and its

00:53:37,059 --> 00:53:43,670
end and it's called head and it's kind

00:53:40,819 --> 00:53:45,529
of one of the possible tools which could

00:53:43,670 --> 00:53:47,269
do this but I think other hex editors

00:53:45,529 --> 00:53:50,569
can can work as well because you cannot

00:53:47,269 --> 00:53:52,190
use the exodus to jump at a different at

00:53:50,569 --> 00:53:56,230
a specific offset and then you can

00:53:52,190 --> 00:53:56,230
select the memory region that you want

00:53:58,760 --> 00:54:05,750
okay I'm afraid of you are done well I

00:54:04,400 --> 00:54:09,170
think that's a good thing because I

00:54:05,750 --> 00:54:13,840
think after this one busca maybe you

00:54:09,170 --> 00:54:16,340
could set up a workshop in in one of the

00:54:13,840 --> 00:54:22,340
meeting rooms I think there's one room

00:54:16,340 --> 00:54:25,160
for casual sessions so okay okay I can

00:54:22,340 --> 00:54:27,590
do that either this evening or sometime

00:54:25,160 --> 00:54:29,630
tomorrow we could do something like this

00:54:27,590 --> 00:54:31,610
if anyone would be interested so so i

00:54:29,630 --> 00:54:34,240
guess i'll just try to set up something

00:54:31,610 --> 00:54:36,440
with the organizers and write the time

00:54:34,240 --> 00:54:39,530
somewhere and if you are interested you

00:54:36,440 --> 00:54:41,300
can you can come and we can talk about

00:54:39,530 --> 00:54:47,470
specific code or walk through specific

00:54:41,300 --> 00:54:47,470
code and take a look at how things work

00:54:47,830 --> 00:54:52,820
okay so enjoy your lunch if you are

00:54:50,990 --> 00:54:55,420
going to lunch I think you must be

00:54:52,820 --> 00:54:55,420
hungry so

00:57:03,720 --> 00:57:05,780
you

00:57:18,060 --> 00:57:20,150
you

00:58:12,590 --> 00:58:14,650
you

00:58:19,350 --> 00:58:21,410

YouTube URL: https://www.youtube.com/watch?v=fwlxKlbHfOI


