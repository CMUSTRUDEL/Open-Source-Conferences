Title: osc12: Performance monitoring of modern X86 platforms using the CPUpower monitoring tool
Publication date: 2012-10-24
Playlist: openSUSE Conference 2012
Description: 
	osc12: Performance monitoring of modern X86 platforms using the CPUpower monitoring tool from openSUSE. Like this? Watch the latest episode of openSUSE on Blip! http://blip.tv/opensuse/watch 

Thomas Renninger

See all episodes of openSUSE http://blip.tv/opensuse#EpisodeArchive
Visit openSUSE's series page http://blip.tv/opensuse
Captions: 
	00:00:01,280 --> 00:00:09,389
is that ok i guess we can start my name

00:00:05,910 --> 00:00:16,920
is my name is thomas running i'm working

00:00:09,389 --> 00:00:21,720
for for Souza for six years now I've

00:00:16,920 --> 00:00:28,769
started in the mobile area therefore I'm

00:00:21,720 --> 00:00:31,140
still bound to to such stuff power

00:00:28,769 --> 00:00:34,350
consumption is already a big topic in

00:00:31,140 --> 00:00:39,540
the server area so all this stuff ends

00:00:34,350 --> 00:00:44,399
on my desk and even this is its marked

00:00:39,540 --> 00:00:47,129
as a ninja talk I guess everybody should

00:00:44,399 --> 00:00:51,660
understand what I'm talking about it's

00:00:47,129 --> 00:00:56,640
useful for people to understand to

00:00:51,660 --> 00:00:58,379
better understand their own the very

00:00:56,640 --> 00:01:02,430
specific benchmarks if the hackers

00:00:58,379 --> 00:01:04,320
whatever and it should be it should be

00:01:02,430 --> 00:01:06,750
very helpful for people with the laptops

00:01:04,320 --> 00:01:09,150
to get an idea about the power

00:01:06,750 --> 00:01:12,420
management features of the of the

00:01:09,150 --> 00:01:16,200
processor this is what I'm going to talk

00:01:12,420 --> 00:01:21,689
about I give a quick introduction of the

00:01:16,200 --> 00:01:28,860
most important power saving features

00:01:21,689 --> 00:01:32,880
modern x86 processors have a quick

00:01:28,860 --> 00:01:34,650
introduction why there is CPU power got

00:01:32,880 --> 00:01:37,100
got developed why there isn't yet

00:01:34,650 --> 00:01:37,100
another tool

00:01:55,850 --> 00:02:05,180
is going to use it how you can monitor

00:01:58,009 --> 00:02:08,509
them with this information those guys

00:02:05,180 --> 00:02:12,140
have to make up their minds themselves

00:02:08,509 --> 00:02:14,150
to understand whether some variation in

00:02:12,140 --> 00:02:19,190
the benchmarks might have to do with

00:02:14,150 --> 00:02:26,450
with the CPU power features or not and i

00:02:19,190 --> 00:02:28,310
said it's i'm going to introduce some

00:02:26,450 --> 00:02:31,400
features from scratch that people can

00:02:28,310 --> 00:02:38,840
understand who are not that deeply

00:02:31,400 --> 00:02:41,510
involved in in this hardware yes the cpu

00:02:38,840 --> 00:02:47,930
frequency voltage scaling available for

00:02:41,510 --> 00:02:51,920
quite some time it got enhanced that

00:02:47,930 --> 00:02:54,769
switching is really quick you don't have

00:02:51,920 --> 00:03:00,230
much latency if the if the Carlos

00:02:54,769 --> 00:03:02,989
switches the frequency the colonel had

00:03:00,230 --> 00:03:05,329
full control over that so if a specific

00:03:02,989 --> 00:03:08,170
frequency is said you're going to get

00:03:05,329 --> 00:03:11,450
that there might be dependencies between

00:03:08,170 --> 00:03:14,989
unless Bell on multi-core systems some

00:03:11,450 --> 00:03:17,510
course had the voltage has to be the

00:03:14,989 --> 00:03:24,350
same on the course or the same frequency

00:03:17,510 --> 00:03:27,560
the CPU power lets you lets you look up

00:03:24,350 --> 00:03:31,570
these dependencies and how how

00:03:27,560 --> 00:03:31,570
frequencies really switched and so on

00:03:33,579 --> 00:03:41,750
yes since yes the problem of course is

00:03:39,530 --> 00:03:43,910
to predict whether you have cpu load

00:03:41,750 --> 00:03:46,700
whether you have to ramp up the the

00:03:43,910 --> 00:03:51,230
frequency and you can't predict that

00:03:46,700 --> 00:03:53,030
it's hard to predict that before your

00:03:51,230 --> 00:03:55,700
workout starts so the current

00:03:53,030 --> 00:04:01,280
implementation is to pull the current

00:03:55,700 --> 00:04:05,630
workload the this is done on modern on

00:04:01,280 --> 00:04:07,560
latest CPUs rather often about every 20

00:04:05,630 --> 00:04:13,790
30 milliseconds

00:04:07,560 --> 00:04:15,989
and if you have constant workload say

00:04:13,790 --> 00:04:17,820
you're compiling the kernel for 30

00:04:15,989 --> 00:04:20,250
minutes you have one hundred percent cpu

00:04:17,820 --> 00:04:22,820
usage frequency will be ramped up all

00:04:20,250 --> 00:04:25,290
the time you have Cyril performance loss

00:04:22,820 --> 00:04:29,070
what is tricky is if the workload

00:04:25,290 --> 00:04:32,639
changes all the time for example on all

00:04:29,070 --> 00:04:35,700
accesses you often have waiting States

00:04:32,639 --> 00:04:37,860
then the CPU has to process and data it

00:04:35,700 --> 00:04:42,240
gets from the device there you have some

00:04:37,860 --> 00:04:44,870
frequent up and down workloads which of

00:04:42,240 --> 00:04:49,440
course is bad for the polling algorithm

00:04:44,870 --> 00:04:51,780
my next slide it's a benchmark I hope I

00:04:49,440 --> 00:04:53,490
can explain it that everybody

00:04:51,780 --> 00:04:58,520
understands that if you understand that

00:04:53,490 --> 00:05:05,850
you see where the you see where the

00:04:58,520 --> 00:05:08,310
where the bottlenecks are okay the tool

00:05:05,850 --> 00:05:10,770
works like that you have you have a

00:05:08,310 --> 00:05:13,919
simple for loop doing a simple operation

00:05:10,770 --> 00:05:17,220
an ad or something and you do that very

00:05:13,919 --> 00:05:22,280
often just to produce the to produce one

00:05:17,220 --> 00:05:28,110
hundred percent cpu load and you do that

00:05:22,280 --> 00:05:30,270
with frequency fully ramped up and you

00:05:28,110 --> 00:05:32,940
calibrate how long how much loops you

00:05:30,270 --> 00:05:35,190
have to do on this hardware to have one

00:05:32,940 --> 00:05:41,550
hundred percent cpu utilization say for

00:05:35,190 --> 00:05:43,979
one second for one second or 4 100

00:05:41,550 --> 00:05:46,260
milliseconds and then it does that very

00:05:43,979 --> 00:05:49,770
often it does one hundred percent cpu

00:05:46,260 --> 00:05:53,220
utilization and then sleeps again for a

00:05:49,770 --> 00:05:58,289
specific period of time and does this

00:05:53,220 --> 00:06:01,250
really often so here you have 200

00:05:58,289 --> 00:06:04,470
milliseconds full load 200 milliseconds

00:06:01,250 --> 00:06:07,530
totally Idol this is and you find out

00:06:04,470 --> 00:06:10,889
the worst cases for your for you for the

00:06:07,530 --> 00:06:14,400
for the frequency switching algorithm

00:06:10,889 --> 00:06:16,080
and you compare how long how long it

00:06:14,400 --> 00:06:18,090
takes compared to when you're fully

00:06:16,080 --> 00:06:20,150
ramped up this is the one hundred

00:06:18,090 --> 00:06:20,150
percent

00:06:20,230 --> 00:06:29,080
and these two lines are there are

00:06:25,860 --> 00:06:32,200
switches inside the colonel how often

00:06:29,080 --> 00:06:35,800
the load she'll get pulled and this is

00:06:32,200 --> 00:06:39,580
done with 20 milliseconds and 80

00:06:35,800 --> 00:06:43,480
milliseconds and of course if the if the

00:06:39,580 --> 00:06:45,910
load starts and 60 milliseconds later

00:06:43,480 --> 00:06:48,790
the colonel realizes oh I'm at one

00:06:45,910 --> 00:06:51,100
hundred percent you're running your your

00:06:48,790 --> 00:06:55,030
algorithm 60 milliseconds not ramped up

00:06:51,100 --> 00:06:57,310
and this is the this is the offset you

00:06:55,030 --> 00:07:02,760
have two one hundred percent it's longer

00:06:57,310 --> 00:07:07,990
it's longer as you run at at full load

00:07:02,760 --> 00:07:11,140
you reach 100 sent so this is where the

00:07:07,990 --> 00:07:13,150
performance loss comes from or if you

00:07:11,140 --> 00:07:18,070
have any typically you don't realize

00:07:13,150 --> 00:07:21,460
that that much in the cpu frequency with

00:07:18,070 --> 00:07:25,390
cpu frequency they are effort to do that

00:07:21,460 --> 00:07:28,420
somewhat better not to polling but put

00:07:25,390 --> 00:07:32,890
that more in the scheduler and ramped up

00:07:28,420 --> 00:07:35,020
pry or the process started re on

00:07:32,890 --> 00:07:38,440
Thunderman from internal promised

00:07:35,020 --> 00:07:42,250
something for two years ago anyway this

00:07:38,440 --> 00:07:43,510
the algorithm itself might change cpu

00:07:42,250 --> 00:07:45,340
frequency switching isn't that

00:07:43,510 --> 00:07:47,350
interesting anymore the worst discussion

00:07:45,340 --> 00:07:52,780
on modern CPUs to disable it at all and

00:07:47,350 --> 00:07:55,500
keep the processor at the highest

00:07:52,780 --> 00:07:59,860
frequency all the time this is because

00:07:55,500 --> 00:08:01,690
the sleeping states are are more

00:07:59,860 --> 00:08:09,400
efficient I'm come to sleeping states

00:08:01,690 --> 00:08:12,910
now yeah the point is say you have at to

00:08:09,400 --> 00:08:15,630
daunt 4 gigahertz you will waste 40

00:08:12,910 --> 00:08:19,360
watts if you ramp it down to two dot one

00:08:15,630 --> 00:08:21,550
gigahertz maybe you still need 15 bucks

00:08:19,360 --> 00:08:24,450
whatever if you sleep in a deep sleep

00:08:21,550 --> 00:08:28,720
states state you only have two BOTS and

00:08:24,450 --> 00:08:32,599
the idea is to keep full performance all

00:08:28,720 --> 00:08:34,789
the time the the colonel will issue

00:08:32,599 --> 00:08:36,860
will enter the idol routine will issue a

00:08:34,789 --> 00:08:39,529
sleeping state you want to enter that as

00:08:36,860 --> 00:08:41,509
fast as possible on modern CPUs the the

00:08:39,529 --> 00:08:44,480
sleep state weren't that efficient say

00:08:41,509 --> 00:08:46,480
two years ago cpu frequency scaling

00:08:44,480 --> 00:08:51,529
isn't that interesting more from a

00:08:46,480 --> 00:08:55,430
power-saving perspective yes now we are

00:08:51,529 --> 00:09:00,170
at the sea States this is very internal

00:08:55,430 --> 00:09:09,860
empty recently put quite some effort in

00:09:00,170 --> 00:09:13,639
to make this really efficient yes there

00:09:09,860 --> 00:09:16,130
is c1 it's called hold their it you

00:09:13,639 --> 00:09:19,579
don't have much much of power savings

00:09:16,130 --> 00:09:22,130
and the deeper the sleep state is the

00:09:19,579 --> 00:09:24,589
more hardware switched off while it

00:09:22,130 --> 00:09:29,180
sleeps and the longer takes until the

00:09:24,589 --> 00:09:36,279
processor is is able to process code

00:09:29,180 --> 00:09:39,019
again so so you have that trait of which

00:09:36,279 --> 00:09:43,930
now affects performance and totally

00:09:39,019 --> 00:09:49,060
other matter than then cpu frequency so

00:09:43,930 --> 00:09:49,060
if you have specific I all cards

00:09:50,980 --> 00:09:57,170
providing an interrupt in a bad

00:09:53,540 --> 00:10:00,230
frequency if where you just decided to

00:09:57,170 --> 00:10:03,110
go into a deep sleep state this this

00:10:00,230 --> 00:10:09,949
might be bad for your for performance

00:10:03,110 --> 00:10:13,040
and this so you so we want to know how

00:10:09,949 --> 00:10:15,829
much how often how long the processor

00:10:13,040 --> 00:10:20,089
goes into these DC States which isn't

00:10:15,829 --> 00:10:23,149
that easy the point is that the kernel

00:10:20,089 --> 00:10:24,620
trick is a specific sea state but it's

00:10:23,149 --> 00:10:26,839
very hardware dependent whether it

00:10:24,620 --> 00:10:31,759
really enters the sea state whether

00:10:26,839 --> 00:10:34,639
other course are going to also have to

00:10:31,759 --> 00:10:36,949
enter sea state to be able to enter deep

00:10:34,639 --> 00:10:38,870
asleep state and this is very very hard

00:10:36,949 --> 00:10:41,139
for specific and is probably going to

00:10:38,870 --> 00:10:44,290
change and get optimized even further

00:10:41,139 --> 00:10:48,740
the next year's

00:10:44,290 --> 00:10:51,080
there we are at the next topic we

00:10:48,740 --> 00:10:55,790
probably all heard about this boosting

00:10:51,080 --> 00:11:00,140
turbo boosting technology where the idea

00:10:55,790 --> 00:11:04,970
is the hardware vendor the cpu hardware

00:11:00,140 --> 00:11:08,270
vendor has to provide a specific thermal

00:11:04,970 --> 00:11:11,410
design power it's called TDP the

00:11:08,270 --> 00:11:19,660
processor must not produce more heat

00:11:11,410 --> 00:11:19,660
than specified and so you make use of

00:11:20,890 --> 00:11:27,170
multi-core CPUs you make use of the fact

00:11:24,530 --> 00:11:30,920
if several course are in deep asleep

00:11:27,170 --> 00:11:33,800
state's you know they are not going to

00:11:30,920 --> 00:11:38,180
use more than whatever bots and you can

00:11:33,800 --> 00:11:39,950
ramp and overclock one or more specific

00:11:38,180 --> 00:11:42,740
course again this is very hard to

00:11:39,950 --> 00:11:45,830
specific on the first aim T

00:11:42,740 --> 00:11:49,750
implementation you had it was enough to

00:11:45,830 --> 00:11:52,460
enter cc1 on two processors to ramp up

00:11:49,750 --> 00:11:54,530
two hundred megahertz the other core on

00:11:52,460 --> 00:11:57,830
Intel you had to enter deeper sleep

00:11:54,530 --> 00:12:01,580
states and cpu power i'm going to show

00:11:57,830 --> 00:12:03,260
you later it's going it's monitoring you

00:12:01,580 --> 00:12:04,190
is poking the hard way directly not

00:12:03,260 --> 00:12:07,820
through the code on the kernel itself

00:12:04,190 --> 00:12:09,890
doesn't know about that it's going to

00:12:07,820 --> 00:12:12,140
show you whether these see States really

00:12:09,890 --> 00:12:20,570
were entered whether you got boosted and

00:12:12,140 --> 00:12:22,970
so on right and there are a lot of you

00:12:20,570 --> 00:12:25,280
turns around to monitor staff very

00:12:22,970 --> 00:12:32,780
specifics if you freak utils is rather

00:12:25,280 --> 00:12:34,700
old yes but very useful you can switch

00:12:32,780 --> 00:12:38,930
governors you can set a maximum minimum

00:12:34,700 --> 00:12:43,880
frequency which is still relevant for

00:12:38,930 --> 00:12:44,830
specific use cases you can exam examine

00:12:43,880 --> 00:12:48,370
well

00:12:44,830 --> 00:12:54,310
what what frequency stages you have to

00:12:48,370 --> 00:12:57,610
provide etc this is rather new it's for

00:12:54,310 --> 00:13:01,990
examining see states only it's it's

00:12:57,610 --> 00:13:03,240
turbo start and it directly pokes the

00:13:01,990 --> 00:13:08,770
hardware through machine-specific

00:13:03,240 --> 00:13:11,860
registers msrs and reads out the usage

00:13:08,770 --> 00:13:14,410
of the deepest sleep states the hard way

00:13:11,860 --> 00:13:18,220
really entered the colonel may request

00:13:14,410 --> 00:13:21,370
specific see states but it's totally

00:13:18,220 --> 00:13:24,250
made up to the hardware which what is

00:13:21,370 --> 00:13:26,530
really what power saving modes are

00:13:24,250 --> 00:13:32,020
really entered choba start is to show

00:13:26,530 --> 00:13:33,910
you that what really happened x86 energy

00:13:32,020 --> 00:13:36,070
per policy is to set a very specific

00:13:33,910 --> 00:13:40,590
Intel flag they have a very specific

00:13:36,070 --> 00:13:43,870
register you can set a number from zero

00:13:40,590 --> 00:13:47,950
full performance to 10 whatever the

00:13:43,870 --> 00:13:50,800
Harper does below the monitor possibly

00:13:47,950 --> 00:13:54,280
also a cool frequency whatever and it's

00:13:50,800 --> 00:13:56,920
more so on the laptop you you want to

00:13:54,280 --> 00:13:59,680
write this register on the on the cpu

00:13:56,920 --> 00:14:02,470
because quite a lot stuff is going on in

00:13:59,680 --> 00:14:04,930
micro code below the in this in the CPU

00:14:02,470 --> 00:14:10,390
itself on a laptop you might want to

00:14:04,930 --> 00:14:12,700
override that this happy register with

00:14:10,390 --> 00:14:15,670
power with a bit about where power

00:14:12,700 --> 00:14:19,090
number and on the servers of course you

00:14:15,670 --> 00:14:20,770
want to write a 0 into it and there's

00:14:19,090 --> 00:14:22,270
power top you probably heard about I

00:14:20,770 --> 00:14:24,550
don't want to go into detail with that

00:14:22,270 --> 00:14:26,050
it's all about device power management

00:14:24,550 --> 00:14:29,170
but also quite a lot cpu power

00:14:26,050 --> 00:14:36,340
management perf time chart is somewhat

00:14:29,170 --> 00:14:39,940
special every time the colonel sets a

00:14:36,340 --> 00:14:43,120
specific cpu frequency it's going to

00:14:39,940 --> 00:14:46,030
issue a perfect and the same for cpu

00:14:43,120 --> 00:14:49,690
idle events and you can collect them use

00:14:46,030 --> 00:14:51,970
the space and draw nice graphs at what

00:14:49,690 --> 00:14:55,960
time the colonel very exactly what

00:14:51,970 --> 00:14:56,899
milliseconds requested idle state and so

00:14:55,960 --> 00:15:02,369
on

00:14:56,899 --> 00:15:03,629
the idea of CPU power is yes connect

00:15:02,369 --> 00:15:06,779
them all together the typical user

00:15:03,629 --> 00:15:11,809
specific is especially because C states

00:15:06,779 --> 00:15:14,759
the frequency scaling is bound together

00:15:11,809 --> 00:15:17,249
with the turbo boost mode and so on you

00:15:14,759 --> 00:15:21,479
want to have one tool to be able to

00:15:17,249 --> 00:15:23,249
examine your system and yes another also

00:15:21,479 --> 00:15:27,989
another reason is to boost art was

00:15:23,249 --> 00:15:30,359
written by Intel there are also empty

00:15:27,989 --> 00:15:33,109
registers but that totally their ex is

00:15:30,359 --> 00:15:36,059
totally different and was not worth to

00:15:33,109 --> 00:15:41,160
to extend to a poor start to make use of

00:15:36,059 --> 00:15:44,569
the PCI registers and anyway so the idea

00:15:41,160 --> 00:15:47,519
is to provide the CPU freaky tales

00:15:44,569 --> 00:15:51,089
functionality do a more generic

00:15:47,519 --> 00:15:56,149
interface for the sea state stuff it's a

00:15:51,089 --> 00:15:59,899
plug-in based approach where you can

00:15:56,149 --> 00:16:04,699
which can get extended much more easily

00:15:59,899 --> 00:16:08,249
for even for arm or whatever

00:16:04,699 --> 00:16:14,909
architectures trouble start is very it's

00:16:08,249 --> 00:16:18,149
very excit six Intel oriented it looks

00:16:14,909 --> 00:16:23,789
like that it's a like get or perf

00:16:18,149 --> 00:16:27,239
command subcommand style you have cpu

00:16:23,789 --> 00:16:30,629
power frequency infoset it's more or

00:16:27,239 --> 00:16:38,489
less excel at the sick cpu frequency

00:16:30,629 --> 00:16:40,889
tools yes you could nearly due to an

00:16:38,489 --> 00:16:44,279
alliance on the cpu frequency tool

00:16:40,889 --> 00:16:46,649
there's a tiny difference with them you

00:16:44,279 --> 00:16:48,299
can specify which course exactly you

00:16:46,649 --> 00:16:51,239
want to monitor this is interesting if

00:16:48,299 --> 00:16:55,079
you have 80 course on a server system

00:16:51,239 --> 00:16:59,059
and your console flows over you can

00:16:55,079 --> 00:17:02,569
specify to only monitor specific CPU

00:16:59,059 --> 00:17:06,389
specific process a package or whatever

00:17:02,569 --> 00:17:09,649
cpu power Idol info is new it simply

00:17:06,389 --> 00:17:09,649
reads out CFS

00:17:10,080 --> 00:17:22,000
Colonel exported information about the

00:17:13,950 --> 00:17:26,170
sea States whoa it gets it gets as I

00:17:22,000 --> 00:17:28,120
have to hurry up okay CP power info very

00:17:26,170 --> 00:17:32,290
specifics if you power top simply called

00:17:28,120 --> 00:17:35,110
power top I set the idea is to have that

00:17:32,290 --> 00:17:37,120
all together for the users to not have

00:17:35,110 --> 00:17:40,990
to google for several tools you have

00:17:37,120 --> 00:17:44,590
this all-in-one and most interesting for

00:17:40,990 --> 00:17:48,490
hardware readouts this is the plug and

00:17:44,590 --> 00:17:52,620
paper based approach see people some

00:17:48,490 --> 00:17:55,390
output of the of this this is morally

00:17:52,620 --> 00:17:59,590
self-explanatory than what i have done

00:17:55,390 --> 00:18:01,780
is producing full load on one core with

00:17:59,590 --> 00:18:04,290
this command and then simply call cpu

00:18:01,780 --> 00:18:08,710
power monitor it money to add it

00:18:04,290 --> 00:18:12,160
collects the sea state or whatever in

00:18:08,710 --> 00:18:19,450
for it it's it can get from from this

00:18:12,160 --> 00:18:21,280
hardware which monitors are you get

00:18:19,450 --> 00:18:24,130
depend on the hardware you're running

00:18:21,280 --> 00:18:26,860
this on this is even done on onyx and

00:18:24,130 --> 00:18:29,170
hyper an extent hypervisor not on the

00:18:26,860 --> 00:18:34,270
hypervisor on the extent colonel it

00:18:29,170 --> 00:18:36,310
still works with a tiny trick and what

00:18:34,270 --> 00:18:38,260
you typically want to do is to examine

00:18:36,310 --> 00:18:41,890
have a specific workload benchmark

00:18:38,260 --> 00:18:45,340
whatever is you just add an executable

00:18:41,890 --> 00:18:49,810
behind cpu power monitor and it execute

00:18:45,340 --> 00:18:51,430
this command monitors collect this data

00:18:49,810 --> 00:18:56,310
in the background when the command

00:18:51,430 --> 00:19:04,110
finishes it prints out this stuff so

00:18:56,310 --> 00:19:10,110
quickly obviously obviously this core

00:19:04,110 --> 00:19:16,150
execute is on full load your c0 means

00:19:10,110 --> 00:19:20,470
active processors working but because

00:19:16,150 --> 00:19:22,990
it's a hype it's an internal hyper

00:19:20,470 --> 00:19:25,270
threaded cpu

00:19:22,990 --> 00:19:28,090
the other core can't enter the deeper

00:19:25,270 --> 00:19:32,500
sleep states as well you have

00:19:28,090 --> 00:19:35,440
dependencies here because only the one

00:19:32,500 --> 00:19:38,860
core isn't it's on full load this

00:19:35,440 --> 00:19:40,809
package c state means in the chipset

00:19:38,860 --> 00:19:45,000
further stuff can be switched off and

00:19:40,809 --> 00:19:48,670
saving power those cannot be entered

00:19:45,000 --> 00:19:51,130
what can be entered is the pc to sandy

00:19:48,670 --> 00:19:53,440
sandy bridge specific the successor of

00:19:51,130 --> 00:19:55,360
nehalem sandy bridge the specific power

00:19:53,440 --> 00:19:58,120
saving mode to chipsets about a policy

00:19:55,360 --> 00:20:03,900
mode but only for I guess this is a 2

00:19:58,120 --> 00:20:07,600
processor system on the core 16 to 22 31

00:20:03,900 --> 00:20:14,320
what still is interesting this should be

00:20:07,600 --> 00:20:17,790
boosted I guess that that the maximum

00:20:14,320 --> 00:20:21,850
frequency is in 3 dot 4 gigahertz

00:20:17,790 --> 00:20:24,970
boosting is a bit difficult to identify

00:20:21,850 --> 00:20:27,130
chest country you can't read out yeah my

00:20:24,970 --> 00:20:30,130
boost it right now the only possibility

00:20:27,130 --> 00:20:32,710
is to measure that over time measure the

00:20:30,130 --> 00:20:36,370
average frequency you were in over a

00:20:32,710 --> 00:20:39,160
specific time it's not it's otherwise

00:20:36,370 --> 00:20:42,100
not possible by Harper restrictions so I

00:20:39,160 --> 00:20:48,250
guess this show gives a pretty nice

00:20:42,100 --> 00:20:51,840
overview how people working on specific

00:20:48,250 --> 00:20:54,460
benchmarks whatever analyzing the system

00:20:51,840 --> 00:20:56,610
can make use of this but it can also be

00:20:54,460 --> 00:21:01,210
very interesting for people bought a

00:20:56,610 --> 00:21:03,790
fresh new laptop wanted to try out thus

00:21:01,210 --> 00:21:05,800
my system run something in the

00:21:03,790 --> 00:21:09,040
background it has the bios being

00:21:05,800 --> 00:21:10,900
configured correctly CPU configured

00:21:09,040 --> 00:21:16,230
correctly by the buyers to make yourself

00:21:10,900 --> 00:21:20,410
all the features the CPU has this is a

00:21:16,230 --> 00:21:23,970
server a bigger service if you in this

00:21:20,410 --> 00:21:28,450
case it's very important to show the

00:21:23,970 --> 00:21:31,150
piracy of the of the course to be able

00:21:28,450 --> 00:21:34,000
to better interpret the stuff again

00:21:31,150 --> 00:21:36,090
here's the hyper here's the hyper 32

00:21:34,000 --> 00:21:38,760
cores were

00:21:36,090 --> 00:21:42,029
the one hundred percent load is running

00:21:38,760 --> 00:21:44,419
this one can't be boosted still all the

00:21:42,029 --> 00:21:49,909
frequencies ramped up on the first floor

00:21:44,419 --> 00:21:49,909
the other course are down at 1 gigahertz

00:21:50,720 --> 00:21:56,250
yes this is what the colonel request

00:21:53,730 --> 00:21:58,919
this is what the colonel things it it

00:21:56,250 --> 00:22:02,880
requests it only requests idle States on

00:21:58,919 --> 00:22:08,640
this cpu we're about the full load but

00:22:02,880 --> 00:22:10,620
the full Wilbur is fully utilized and in

00:22:08,640 --> 00:22:13,860
reality it may look totally different

00:22:10,620 --> 00:22:18,029
very hard for specific my change on the

00:22:13,860 --> 00:22:20,100
next whatever has well or whatever IV

00:22:18,029 --> 00:22:22,080
preaches the next one it might look

00:22:20,100 --> 00:22:24,210
different this is on a name two-year

00:22:22,080 --> 00:22:27,330
machine what I've said this doesn't or

00:22:24,210 --> 00:22:31,490
this does only exist this this

00:22:27,330 --> 00:22:33,809
monitoring on on cpu power it reads out

00:22:31,490 --> 00:22:37,110
this information from pci space

00:22:33,809 --> 00:22:40,649
therefore it can also be read if a

00:22:37,110 --> 00:22:44,190
specific core is offline software

00:22:40,649 --> 00:22:47,970
offline if someone is important that a

00:22:44,190 --> 00:22:51,000
very nice bit i found was this

00:22:47,970 --> 00:22:53,610
northbridge p1 it's a very empty

00:22:51,000 --> 00:22:56,070
specific counter it tells you whether

00:22:53,610 --> 00:22:59,880
the whole North Bridge could enter a

00:22:56,070 --> 00:23:04,230
deeper sleep state and this also depends

00:22:59,880 --> 00:23:06,620
on the graphics core to enter a power

00:23:04,230 --> 00:23:09,120
mode so while the graphics

00:23:06,620 --> 00:23:14,789
specifications are totally closed and so

00:23:09,120 --> 00:23:16,740
on you can still measure whether this

00:23:14,789 --> 00:23:20,159
one at least has been entered its a 1 or

00:23:16,740 --> 00:23:23,490
0 I realized that with the open-source

00:23:20,159 --> 00:23:25,500
graphics driver when I try this out

00:23:23,490 --> 00:23:27,840
maybe it's some time ago already

00:23:25,500 --> 00:23:29,640
hopefully it works now the open-source

00:23:27,840 --> 00:23:33,289
graphics driver this one was not entered

00:23:29,640 --> 00:23:37,350
with the FG LAX you get a 1 here and

00:23:33,289 --> 00:23:42,299
this might explain another 15 half an

00:23:37,350 --> 00:23:45,240
hour battery life time and yes also very

00:23:42,299 --> 00:23:48,240
interesting was even if you restrict the

00:23:45,240 --> 00:23:49,830
it's you can't see it here but if you

00:23:48,240 --> 00:23:53,610
restrict the idol states to

00:23:49,830 --> 00:23:56,429
which the current quest to see one this

00:23:53,610 --> 00:23:59,100
will get overwritten by this cpu family

00:23:56,429 --> 00:24:03,659
it will still enter internally deep

00:23:59,100 --> 00:24:06,990
asleep States this is interesting to

00:24:03,659 --> 00:24:10,890
know if you if you have some varieties

00:24:06,990 --> 00:24:15,390
in one to explain a specific phenomenon

00:24:10,890 --> 00:24:20,090
you you see these are yes I have to

00:24:15,390 --> 00:24:22,679
finish these are the monitors that exist

00:24:20,090 --> 00:24:24,120
this is just Colonel read out what the

00:24:22,679 --> 00:24:27,720
current requests the other one are very

00:24:24,120 --> 00:24:29,399
hard for specific you need the specific

00:24:27,720 --> 00:24:34,679
registers on the hardware that they get

00:24:29,399 --> 00:24:36,840
active I'm finished yes and this is what

00:24:34,679 --> 00:24:42,210
I'm thinking about could still be edit

00:24:36,840 --> 00:24:44,720
and so I'm finished thank you very much

00:24:42,210 --> 00:24:44,720

YouTube URL: https://www.youtube.com/watch?v=agS2WrZqi-E


