Title: OSC12 - megasas on steroids
Publication date: 2012-10-24
Playlist: openSUSE Conference 2012
Description: 
	OSC12 - megasas on steroids from openSUSE. Like this? Watch the latest episode of openSUSE on Blip! http://blip.tv/opensuse/watch 

Speaker: Hannes Reinecke
Room: Riker

See all episodes of openSUSE http://blip.tv/opensuse#EpisodeArchive
Visit openSUSE's series page http://blip.tv/opensuse
Captions: 
	00:00:00,000 --> 00:00:06,060
so this is a talk about me haces and vfi

00:00:03,600 --> 00:00:07,830
oh the fao is basically the new

00:00:06,060 --> 00:00:11,269
generation on how to do device

00:00:07,830 --> 00:00:16,520
assignment on you emo they used to be

00:00:11,269 --> 00:00:21,119
just a few seconds this Mustang right

00:00:16,520 --> 00:00:23,900
okay so pci device assignment most of

00:00:21,119 --> 00:00:26,820
you will be hopefully are familiar with

00:00:23,900 --> 00:00:29,460
virtualization and so nifty things you

00:00:26,820 --> 00:00:31,740
can do with device assignment basically

00:00:29,460 --> 00:00:34,680
means that you root a pci device

00:00:31,740 --> 00:00:36,780
directly to the guests without the host

00:00:34,680 --> 00:00:38,700
having to interfere so not something

00:00:36,780 --> 00:00:41,309
like send where everything away all has

00:00:38,700 --> 00:00:43,140
to go over the host module thing but

00:00:41,309 --> 00:00:45,420
rather that the guests can access the

00:00:43,140 --> 00:00:51,180
pci the actual pci device directly and

00:00:45,420 --> 00:00:53,129
work on it so many thing here is that

00:00:51,180 --> 00:00:55,289
office it's a virtual machines oh you

00:00:53,129 --> 00:00:58,020
need to access it somehow where you have

00:00:55,289 --> 00:01:00,199
various choices like the normal

00:00:58,020 --> 00:01:04,680
classical emulate device virtual devices

00:01:00,199 --> 00:01:06,990
then we have a linux concept called v

00:01:04,680 --> 00:01:09,630
host which specially are accelerated the

00:01:06,990 --> 00:01:12,630
over tile and obviously give a direct

00:01:09,630 --> 00:01:16,530
access to the hardware so if you look at

00:01:12,630 --> 00:01:18,090
the stack for a malay device it becomes

00:01:16,530 --> 00:01:19,409
rather complex you have tons and tons

00:01:18,090 --> 00:01:20,970
and tons of layers at all if you have

00:01:19,409 --> 00:01:23,430
the guest user letting the guests and

00:01:20,970 --> 00:01:25,799
the and the guests that talks to the

00:01:23,430 --> 00:01:27,990
carnal to the block layer locklear talks

00:01:25,799 --> 00:01:30,540
the driver the driver then talks to the

00:01:27,990 --> 00:01:32,909
driver emulation in the host humor in

00:01:30,540 --> 00:01:35,610
this case the drive emulation talks to

00:01:32,909 --> 00:01:38,250
the qme block layer the cube locklear

00:01:35,610 --> 00:01:40,439
talks to the host rock layer and the

00:01:38,250 --> 00:01:41,640
host blog layer talks to the host skazhi

00:01:40,439 --> 00:01:43,079
driver and discuss the driver finally

00:01:41,640 --> 00:01:45,329
finally finally actually access the

00:01:43,079 --> 00:01:47,579
harder so this is a bit of a tedious

00:01:45,329 --> 00:01:49,500
process and my time to time consumed in

00:01:47,579 --> 00:01:52,049
consuming which obviously means it's not

00:01:49,500 --> 00:01:53,250
really fast I mean it's totally a

00:01:52,049 --> 00:01:56,219
manager so it's virtually

00:01:53,250 --> 00:01:58,439
indistinguishable these and these I mean

00:01:56,219 --> 00:02:00,060
this driver these both drivers aren't

00:01:58,439 --> 00:02:03,299
identical so both think they actually

00:02:00,060 --> 00:02:07,290
talk to real hardware but still quite a

00:02:03,299 --> 00:02:09,179
few layers so to speed it up there's

00:02:07,290 --> 00:02:12,209
something called virtio

00:02:09,179 --> 00:02:15,959
which basically means that the driver in

00:02:12,209 --> 00:02:17,430
the host has violent access to the

00:02:15,959 --> 00:02:19,680
structures of the driver and the guest

00:02:17,430 --> 00:02:21,689
so it's cuz it kind of back to back

00:02:19,680 --> 00:02:23,750
communication going on here so the

00:02:21,689 --> 00:02:27,239
driver know exactly where the queue is

00:02:23,750 --> 00:02:29,280
the command q is for the for the guest

00:02:27,239 --> 00:02:31,049
Colonel and just gets the commands or

00:02:29,280 --> 00:02:32,489
just access the commands directly so you

00:02:31,049 --> 00:02:35,340
don't need to do any memory transfer

00:02:32,489 --> 00:02:38,790
which is quite fast but still it still

00:02:35,340 --> 00:02:40,920
means you have to go from the host

00:02:38,790 --> 00:02:43,200
process into the host Colonel and back

00:02:40,920 --> 00:02:44,700
down so that's still you're still quite

00:02:43,200 --> 00:02:47,730
some concept and context which is

00:02:44,700 --> 00:02:49,859
involved to make that to swim like

00:02:47,730 --> 00:02:54,959
swimming that even more there's a

00:02:49,859 --> 00:02:56,549
concept called V host which is again a

00:02:54,959 --> 00:02:58,829
back-to-back communication like verte I

00:02:56,549 --> 00:03:01,109
oh but this time it's back-to-back Canio

00:02:58,829 --> 00:03:03,000
in communication between the guest

00:03:01,109 --> 00:03:05,669
Colonel and the host color so you're

00:03:03,000 --> 00:03:07,260
skipping the host userland the host QA

00:03:05,669 --> 00:03:10,950
process altogether so you're not going

00:03:07,260 --> 00:03:14,310
into into the userland during ioka it

00:03:10,950 --> 00:03:15,870
but basically from one current context

00:03:14,310 --> 00:03:19,290
to now the current context which is

00:03:15,870 --> 00:03:20,909
quite fast or 11 should say suppose

00:03:19,290 --> 00:03:23,639
sleep I fast because no one actually has

00:03:20,909 --> 00:03:25,889
measured this and the beers driver then

00:03:23,639 --> 00:03:30,959
talks the burglar blah blah for the

00:03:25,889 --> 00:03:35,579
wrong and finally we have device

00:03:30,959 --> 00:03:37,859
assignment where we just skip that all

00:03:35,579 --> 00:03:42,720
together and have this one talking

00:03:37,859 --> 00:03:44,430
directly to the hardware as you can see

00:03:42,720 --> 00:03:46,530
it's not actually directly to the heart

00:03:44,430 --> 00:03:51,599
because means it doesn't really quite

00:03:46,530 --> 00:03:54,509
work work out as nicely you still you do

00:03:51,599 --> 00:03:56,909
need to translate the addresses from the

00:03:54,509 --> 00:03:59,220
host Colonel into the gas gun or vice

00:03:56,909 --> 00:04:00,900
versa brother so if you do in dma the

00:03:59,220 --> 00:04:02,549
dma addresses you get in the guest

00:04:00,900 --> 00:04:04,680
obvious with guest and guest addresses

00:04:02,549 --> 00:04:07,909
whereas if you put the guest address

00:04:04,680 --> 00:04:10,560
dragon on the host on the dma

00:04:07,909 --> 00:04:12,209
information for the area hardware the

00:04:10,560 --> 00:04:14,519
hardware things it's talking into the

00:04:12,209 --> 00:04:16,919
guest in the house context so it becomes

00:04:14,519 --> 00:04:19,680
rather confused where the data is for

00:04:16,919 --> 00:04:21,280
this you need an IOM you to make that

00:04:19,680 --> 00:04:24,580
work so that you did

00:04:21,280 --> 00:04:31,530
you can have that view offload the

00:04:24,580 --> 00:04:35,710
translation to the hardware this one so

00:04:31,530 --> 00:04:40,150
with MPC item assignment you can have a

00:04:35,710 --> 00:04:42,540
rather nifty access to the hardware so

00:04:40,150 --> 00:04:45,370
you don't have any Malaysian involved

00:04:42,540 --> 00:04:47,200
you can use unmodified drivers and you

00:04:45,370 --> 00:04:50,889
actually have the real Hardware talking

00:04:47,200 --> 00:04:53,380
to it to the to the guest however the

00:04:50,889 --> 00:04:55,240
pci device is then visible both in both

00:04:53,380 --> 00:04:58,210
the house and the guest context if

00:04:55,240 --> 00:04:59,530
you're using kvm or a queue which means

00:04:58,210 --> 00:05:01,870
you have to you have to prevent the

00:04:59,530 --> 00:05:03,850
excess and two assigned device from the

00:05:01,870 --> 00:05:06,360
host for which there is a module called

00:05:03,850 --> 00:05:11,350
piece of ice tub or if using BFI oh

00:05:06,360 --> 00:05:14,320
there's a piece of MDF I oh so the pci

00:05:11,350 --> 00:05:16,870
device assignment itself from here is

00:05:14,320 --> 00:05:18,580
that both have a different memory

00:05:16,870 --> 00:05:19,840
mapping so you have the Conn mapping

00:05:18,580 --> 00:05:22,450
which basically straight one-to-one

00:05:19,840 --> 00:05:25,900
mapping and you have the guest context

00:05:22,450 --> 00:05:29,830
which is somewhere skip to a difference

00:05:25,900 --> 00:05:32,830
some offset to the end to the into the

00:05:29,830 --> 00:05:35,560
host Colonel so the physical addresses

00:05:32,830 --> 00:05:37,419
or thought what the guest gets as

00:05:35,560 --> 00:05:41,200
physical addresses actual virtual

00:05:37,419 --> 00:05:44,260
addresses in the host which well needs

00:05:41,200 --> 00:05:45,729
to be translated somehow if you're

00:05:44,260 --> 00:05:47,200
you're running emulated emulation will

00:05:45,729 --> 00:05:48,580
do it do it for you but if you're not

00:05:47,200 --> 00:05:49,930
running emulated you have some other

00:05:48,580 --> 00:05:52,630
incident you have to have some other

00:05:49,930 --> 00:05:54,430
instance which does the translation so

00:05:52,630 --> 00:05:57,310
and as you talking directly to the

00:05:54,430 --> 00:05:58,870
hardware you can't really insert some

00:05:57,310 --> 00:06:00,070
magic bits in there to do the

00:05:58,870 --> 00:06:05,950
translation so we actually need some

00:06:00,070 --> 00:06:10,060
hardware support for this which is leads

00:06:05,950 --> 00:06:12,070
us to the iom you so you're actually

00:06:10,060 --> 00:06:14,740
doing it hardware support here the iom

00:06:12,070 --> 00:06:18,700
you which is present on most modern

00:06:14,740 --> 00:06:20,380
server hardware one has to say and about

00:06:18,700 --> 00:06:25,000
task is offered to translate the memory

00:06:20,380 --> 00:06:28,660
addresses engine recalls it v TD and mg

00:06:25,000 --> 00:06:31,210
calls at the eye but again be aware not

00:06:28,660 --> 00:06:31,960
every book a box with says it does v TD

00:06:31,210 --> 00:06:34,660
can

00:06:31,960 --> 00:06:38,530
actually has I own you and can do this

00:06:34,660 --> 00:06:41,199
trick you need to look out for the dma a

00:06:38,530 --> 00:06:43,150
our table if you have an inter box only

00:06:41,199 --> 00:06:45,789
if you have this Taylor this spi table

00:06:43,150 --> 00:06:47,289
the machine can do our DM a translation

00:06:45,789 --> 00:06:49,270
if you don't have this table forget it

00:06:47,289 --> 00:06:53,259
it could tell it could say yes I do vdd

00:06:49,270 --> 00:06:57,310
but in fact you can't use it the other

00:06:53,259 --> 00:07:01,539
thing is that the iom you is this a pure

00:06:57,310 --> 00:07:03,610
default because if you enable it you

00:07:01,539 --> 00:07:06,490
have a performance loss simply because

00:07:03,610 --> 00:07:08,710
their om you need to do translation for

00:07:06,490 --> 00:07:10,840
every io access not just for the

00:07:08,710 --> 00:07:15,280
emulator device but for every io access

00:07:10,840 --> 00:07:17,199
and this means the iom nu AI o mu has to

00:07:15,280 --> 00:07:18,759
look up each and every address in its a

00:07:17,199 --> 00:07:20,979
turn and look up table to figure out

00:07:18,759 --> 00:07:23,139
whether whether it is in the lookup

00:07:20,979 --> 00:07:26,199
table and then do a translation or not

00:07:23,139 --> 00:07:31,120
depending so there's there's another set

00:07:26,199 --> 00:07:32,710
off but there's another loop you look up

00:07:31,120 --> 00:07:34,990
involved which just makes the system

00:07:32,710 --> 00:07:40,930
bits running slower so hence its was

00:07:34,990 --> 00:07:44,909
able / default so okay that's the theory

00:07:40,930 --> 00:07:47,740
but what does how do we do this I'm gone

00:07:44,909 --> 00:07:50,440
how do we do with do this in queue or

00:07:47,740 --> 00:08:00,310
how do we simulate this and innovators

00:07:50,440 --> 00:08:03,310
in queue emo well qmo has the humor has

00:08:00,310 --> 00:08:05,110
a special mindset so whenever whatever

00:08:03,310 --> 00:08:07,780
you do in humorous has to work on all

00:08:05,110 --> 00:08:10,509
architectures or at least the concept

00:08:07,780 --> 00:08:12,159
has to work on all architectures even

00:08:10,509 --> 00:08:14,289
though there are actual architecture in

00:08:12,159 --> 00:08:15,880
case might not be a it might not have it

00:08:14,289 --> 00:08:18,190
implemented but that's a different story

00:08:15,880 --> 00:08:21,520
so it needs to work the concept must

00:08:18,190 --> 00:08:25,080
work on all architectures so in our case

00:08:21,520 --> 00:08:29,380
it means we need to take into account

00:08:25,080 --> 00:08:31,810
every iom you which is out there for

00:08:29,380 --> 00:08:34,870
every architecture which is a tricky

00:08:31,810 --> 00:08:38,050
task and there are some really strange

00:08:34,870 --> 00:08:41,550
iom use like the PowerPC alexia noise

00:08:38,050 --> 00:08:45,080
over there powerpc has a really weird

00:08:41,550 --> 00:08:47,420
notion on how you the iom you is

00:08:45,080 --> 00:08:50,420
to work so you do need to do some

00:08:47,420 --> 00:08:55,640
abstraction and the concept they came up

00:08:50,420 --> 00:08:59,780
with was is called the FIO p fa 0 is

00:08:55,640 --> 00:09:04,190
just abstraction for virtual function i

00:08:59,780 --> 00:09:07,010
oh so this is developed by alex

00:09:04,190 --> 00:09:09,800
williamson all rather this has been

00:09:07,010 --> 00:09:11,720
redeveloped by alex williamson because

00:09:09,800 --> 00:09:15,410
there's an earlier implementation of the

00:09:11,720 --> 00:09:20,660
fao by cisco which is several years old

00:09:15,410 --> 00:09:23,590
by now which originated cisco thought of

00:09:20,660 --> 00:09:28,970
using did use for their virtualization

00:09:23,590 --> 00:09:32,270
thing it never really took off as far as

00:09:28,970 --> 00:09:35,750
i know so it was just laying then Alex

00:09:32,270 --> 00:09:40,730
resurrected the idea so the concept is

00:09:35,750 --> 00:09:44,450
the trick with that one is that we can

00:09:40,730 --> 00:09:46,550
utilize the user space io hear the limbs

00:09:44,450 --> 00:09:48,260
town has a user space I oh I'm not sure

00:09:46,550 --> 00:09:53,540
if anyone's familiar with that probably

00:09:48,260 --> 00:09:56,480
not you of course you would okay so

00:09:53,540 --> 00:10:00,080
basically it means that you can run the

00:09:56,480 --> 00:10:04,100
driver in user space and that you only

00:10:00,080 --> 00:10:09,890
have two hooks into the kernel which is

00:10:04,100 --> 00:10:12,140
a so basically you can do I address

00:10:09,890 --> 00:10:14,360
mapping a user space via via a map and

00:10:12,140 --> 00:10:17,930
you have a special file descriptor

00:10:14,360 --> 00:10:21,920
called event FD which allows you allows

00:10:17,930 --> 00:10:23,840
the car to pass interrupts to user space

00:10:21,920 --> 00:10:25,430
which is quite helpful because that's

00:10:23,840 --> 00:10:27,440
what you need for drivers but can also

00:10:25,430 --> 00:10:29,510
be used in this case because you do need

00:10:27,440 --> 00:10:31,520
the interrupt somehow being routed to

00:10:29,510 --> 00:10:33,050
the interior guest the heart but doesn't

00:10:31,520 --> 00:10:39,470
do it for you you have to do some not

00:10:33,050 --> 00:10:41,960
for the gas heaters in a drop so and the

00:10:39,470 --> 00:10:43,940
other thing is what they did what he did

00:10:41,960 --> 00:10:47,860
was to implement something called device

00:10:43,940 --> 00:10:47,860
groups reason for this

00:10:49,089 --> 00:10:58,300
right okay device groups are required

00:10:55,540 --> 00:11:00,970
here because as mentioned this thing has

00:10:58,300 --> 00:11:03,309
to run all architecture and the thing is

00:11:00,970 --> 00:11:05,949
that not all I own muse on all

00:11:03,309 --> 00:11:08,680
architectures are able to address

00:11:05,949 --> 00:11:10,420
individual devices on powerpc for

00:11:08,680 --> 00:11:13,990
example it can only address device

00:11:10,420 --> 00:11:16,089
groups so several physical devices are

00:11:13,990 --> 00:11:19,389
lumped together in a device group and

00:11:16,089 --> 00:11:22,269
the iom you works on all of them devices

00:11:19,389 --> 00:11:25,209
simultaneously so it can't split that up

00:11:22,269 --> 00:11:28,540
that is a hardware limitation and to map

00:11:25,209 --> 00:11:31,420
this you bet you have to implement

00:11:28,540 --> 00:11:33,699
something called device groups which on

00:11:31,420 --> 00:11:36,579
inter platforms just degenerates into

00:11:33,699 --> 00:11:43,420
one group per device but help still have

00:11:36,579 --> 00:11:46,089
to do without so this whole thing is

00:11:43,420 --> 00:11:50,800
implemented in a new driver vfi OPC I

00:11:46,089 --> 00:11:56,949
which is present in 37 at least if not

00:11:50,800 --> 00:12:00,220
six presumably six and well this is just

00:11:56,949 --> 00:12:01,720
a pci drive without any pci specific

00:12:00,220 --> 00:12:03,279
information so it won't bind to anything

00:12:01,720 --> 00:12:07,360
you have to do it manually if you want

00:12:03,279 --> 00:12:09,189
to do it the usual trick of ecco is in

00:12:07,360 --> 00:12:11,319
pine doesn't work because it has an

00:12:09,189 --> 00:12:14,350
empty pci table so we actually have to

00:12:11,319 --> 00:12:18,519
fill in the pci vendor and pci model

00:12:14,350 --> 00:12:22,179
into that dry into that driver why are

00:12:18,519 --> 00:12:25,470
this new ID trick and if you do that it

00:12:22,179 --> 00:12:32,019
will actually bound a bind to the device

00:12:25,470 --> 00:12:35,949
which then has a nice is a nice thing

00:12:32,019 --> 00:12:39,240
because you do get a dead simple

00:12:35,949 --> 00:12:42,459
command-line for q amor this one is a

00:12:39,240 --> 00:12:46,439
humor is the commander for mac you may

00:12:42,459 --> 00:12:49,179
guess i run run in the lab which has two

00:12:46,439 --> 00:12:50,980
devices one I G B D F the virtual

00:12:49,179 --> 00:12:54,360
function of the idea of the IDB driver

00:12:50,980 --> 00:12:57,040
and Omega czars also both fully emulated

00:12:54,360 --> 00:12:59,429
no emulation nothing all runs on

00:12:57,040 --> 00:12:59,429
hardware

00:12:59,730 --> 00:13:08,790
absolutely nice it looks just like a

00:13:02,370 --> 00:13:11,370
real machine just then well then go just

00:13:08,790 --> 00:13:16,220
boots up the system that's the bias of

00:13:11,370 --> 00:13:16,220
the Americas coming on Justin Boots fine

00:13:16,430 --> 00:13:26,970
so well however as I mentioned yeah the

00:13:24,269 --> 00:13:30,269
whole things we did as I described at

00:13:26,970 --> 00:13:34,019
the start like vertigo and TCM gmv how's

00:13:30,269 --> 00:13:36,720
the more not our all concepts which look

00:13:34,019 --> 00:13:40,019
as if they could if they should make the

00:13:36,720 --> 00:13:44,010
Machine faster it's not that anyone has

00:13:40,019 --> 00:13:46,829
ever measured it simply because they

00:13:44,010 --> 00:13:49,260
always invented a new abstraction for

00:13:46,829 --> 00:13:50,970
doing the emulation so it's really hard

00:13:49,260 --> 00:13:52,500
to measure because not the same system

00:13:50,970 --> 00:13:54,029
you can't actually well sure you can

00:13:52,500 --> 00:13:55,920
measure but you might measure something

00:13:54,029 --> 00:13:58,079
completely different so you wouldn't

00:13:55,920 --> 00:14:03,470
even know if if it's remotely comparable

00:13:58,079 --> 00:14:03,470
even the real results you're getting so

00:14:04,970 --> 00:14:14,699
we could make things faster year but hmm

00:14:11,029 --> 00:14:17,940
again we do have several layers involved

00:14:14,699 --> 00:14:19,740
and to make a proper io performance

00:14:17,940 --> 00:14:22,440
measurement we would have to measure

00:14:19,740 --> 00:14:24,899
each of those layers to figure out right

00:14:22,440 --> 00:14:27,990
where is the latency where does it make

00:14:24,899 --> 00:14:30,300
sense to improve things because if I say

00:14:27,990 --> 00:14:31,829
would go ahead and say oh now I need to

00:14:30,300 --> 00:14:33,569
improve the humor block light because

00:14:31,829 --> 00:14:35,880
that's because I don't like it or

00:14:33,569 --> 00:14:39,449
because I think it's too slow if that's

00:14:35,880 --> 00:14:41,579
only a fraction of a percent of the

00:14:39,449 --> 00:14:43,500
entire io later see I could have

00:14:41,579 --> 00:14:45,630
believed it where's the point I will

00:14:43,500 --> 00:14:49,199
never get a gain any advantage all of

00:14:45,630 --> 00:14:51,540
that and to do so so to figure that out

00:14:49,199 --> 00:14:54,110
we first have to do a performance

00:14:51,540 --> 00:14:54,110
measurement

00:14:55,550 --> 00:15:01,310
so we could be using block trace here

00:14:59,330 --> 00:15:04,790
because that actually gives us a clear

00:15:01,310 --> 00:15:07,459
indication where the how how much time

00:15:04,790 --> 00:15:12,610
at each i/o request spends on each

00:15:07,459 --> 00:15:15,170
individual layer however this has some

00:15:12,610 --> 00:15:17,329
disadvantage or impediments here the one

00:15:15,170 --> 00:15:19,820
is that q Murr isn't measured here so

00:15:17,329 --> 00:15:21,260
because Q move runs in userland and the

00:15:19,820 --> 00:15:24,260
usual i'm visiting trace with that and

00:15:21,260 --> 00:15:26,709
that it's a vectorized only gathers

00:15:24,260 --> 00:15:29,540
local information for the running kernel

00:15:26,709 --> 00:15:31,310
so if you're running under qmo if you

00:15:29,540 --> 00:15:33,230
run this thing under QE more you have

00:15:31,310 --> 00:15:34,700
two kernels running you have your guests

00:15:33,230 --> 00:15:36,620
can run and your host Colonel running

00:15:34,700 --> 00:15:39,079
both will be getting you and try a block

00:15:36,620 --> 00:15:41,329
trace information but it's really hard

00:15:39,079 --> 00:15:43,519
to synchronize both because well which I

00:15:41,329 --> 00:15:51,230
again maps to the alert one in the other

00:15:43,519 --> 00:15:53,750
tries that is tricky so however we could

00:15:51,230 --> 00:15:58,160
be doing is do a comparative measurement

00:15:53,750 --> 00:16:00,350
as we we are now able to similar action

00:15:58,160 --> 00:16:02,870
devices and actually map the device is

00:16:00,350 --> 00:16:05,240
to direct it to the guest we could just

00:16:02,870 --> 00:16:07,399
have three or four setups one fully

00:16:05,240 --> 00:16:09,649
emily to one with what iOS guzzi go

00:16:07,399 --> 00:16:12,610
discuss it with iom you and one with my

00:16:09,649 --> 00:16:17,600
FL v fi 0 and measuring the over latency

00:16:12,610 --> 00:16:20,660
for each step so with that we can figure

00:16:17,600 --> 00:16:24,260
out at least roughly where the iolite is

00:16:20,660 --> 00:16:27,470
a latency lives the first component the

00:16:24,260 --> 00:16:30,140
first two will give us basically the

00:16:27,470 --> 00:16:31,760
overhead of the emulation comparing the

00:16:30,140 --> 00:16:34,910
second and the third will give us the

00:16:31,760 --> 00:16:38,170
overhead of the iom you because i said

00:16:34,910 --> 00:16:42,620
at the start the iom you should be in

00:16:38,170 --> 00:16:45,890
chorale latency but how much no one

00:16:42,620 --> 00:16:52,640
knows there is no data or do your some

00:16:45,890 --> 00:16:55,839
mail for iommu latency how big the the

00:16:52,640 --> 00:16:55,839
decreasing i will perform as well

00:17:03,620 --> 00:17:10,289
yeah but like Calgary had their own oil

00:17:06,089 --> 00:17:12,000
and other stuff so the recent generation

00:17:10,289 --> 00:17:18,169
should have pretty decent speed but

00:17:12,000 --> 00:17:20,370
again no one knows so so measure and

00:17:18,169 --> 00:17:23,130
comparing the third and the fourth will

00:17:20,370 --> 00:17:27,059
give you the difference between the

00:17:23,130 --> 00:17:30,720
emanation and VF I'll so with that we

00:17:27,059 --> 00:17:32,460
could actually do some nice some

00:17:30,720 --> 00:17:33,929
comparison here and figure out where it

00:17:32,460 --> 00:17:37,400
would make sense where it would make

00:17:33,929 --> 00:17:40,710
sense to improve improve improve things

00:17:37,400 --> 00:17:43,890
what we go to also is to extend block

00:17:40,710 --> 00:17:46,320
trace to actually see whether we can

00:17:43,890 --> 00:17:51,350
whether we can match the block trace

00:17:46,320 --> 00:17:54,150
information from the guest to the host

00:17:51,350 --> 00:17:57,900
thing is something like vertigo Scotty

00:17:54,150 --> 00:17:59,850
has attack field which just ace a 32-bit

00:17:57,900 --> 00:18:02,630
value or where you can stick any

00:17:59,850 --> 00:18:05,809
information so we could stick in the

00:18:02,630 --> 00:18:09,299
identifier for VIP or the request and

00:18:05,809 --> 00:18:10,530
map and have them display both in the

00:18:09,299 --> 00:18:12,360
host and the guests so we would not

00:18:10,530 --> 00:18:14,789
write this note request X and this

00:18:12,360 --> 00:18:16,530
universe apps X maps to their cyl crest

00:18:14,789 --> 00:18:18,659
on the house so that we could actually

00:18:16,530 --> 00:18:21,149
compare we could actually met mash up

00:18:18,659 --> 00:18:22,770
the block trace information so that have

00:18:21,149 --> 00:18:25,049
that we have a full measure and

00:18:22,770 --> 00:18:31,370
measurements of a full stack from guess

00:18:25,049 --> 00:18:33,690
userland down to the hardware so and

00:18:31,370 --> 00:18:36,030
well the problem of that is obvious that

00:18:33,690 --> 00:18:38,880
another problem is the time stamps that

00:18:36,030 --> 00:18:42,240
each block tracer has a time stamp on

00:18:38,880 --> 00:18:44,100
the i/o request and the time two times

00:18:42,240 --> 00:18:47,580
them in the host and the guests off is

00:18:44,100 --> 00:18:50,929
different so you would need to insert

00:18:47,580 --> 00:18:54,299
some synchronization point2 now exactly

00:18:50,929 --> 00:18:57,480
what which time in the host refers to

00:18:54,299 --> 00:18:59,010
the which time in the guest is anyone if

00:18:57,480 --> 00:19:02,010
anyone has a clever idea how to do this

00:18:59,010 --> 00:19:03,870
I'm all the years because I still don't

00:19:02,010 --> 00:19:06,780
know how to do this exactly so you could

00:19:03,870 --> 00:19:08,190
do something like ntp on both sides and

00:19:06,780 --> 00:19:12,149
how bright it will get

00:19:08,190 --> 00:19:15,000
roughly ok but then ntp doesn't have the

00:19:12,149 --> 00:19:16,799
highest precision so I'm I don't think

00:19:15,000 --> 00:19:18,570
it'll up to it up to that task but we've

00:19:16,799 --> 00:19:22,259
amped ntp you probably get a prison and

00:19:18,570 --> 00:19:25,399
precision in down two seconds roughly

00:19:22,259 --> 00:19:30,149
with a bit of luck milliseconds

00:19:25,399 --> 00:19:33,360
milliseconds yeah so but it'll

00:19:30,149 --> 00:19:34,860
inevitably so that got you can't do that

00:19:33,360 --> 00:19:36,629
you can't really use so you really want

00:19:34,860 --> 00:19:38,340
to go get it down to donate on to a

00:19:36,629 --> 00:19:47,580
precise timing here so not sure

00:19:38,340 --> 00:19:49,139
everything coming yeah and yes you could

00:19:47,580 --> 00:19:51,480
but this on your approximate if you

00:19:49,139 --> 00:19:53,159
won't be getting the offset with that if

00:19:51,480 --> 00:19:56,580
you do a round trip time yeah I know how

00:19:53,159 --> 00:19:58,440
long it took between the base is just

00:19:56,580 --> 00:20:01,019
measuring is around around your time ok

00:19:58,440 --> 00:20:02,909
I just it just took me say four seconds

00:20:01,019 --> 00:20:06,240
to get from the guests to the host and

00:20:02,909 --> 00:20:08,519
at any time between those four seconds

00:20:06,240 --> 00:20:11,009
the house in the house and has received

00:20:08,519 --> 00:20:12,299
a message what you would be doing it

00:20:11,009 --> 00:20:15,570
would be needing is to figure out

00:20:12,299 --> 00:20:18,090
exactly offset here so when exactly did

00:20:15,570 --> 00:20:19,620
the house in to get the request how long

00:20:18,090 --> 00:20:21,990
does it took for the hose to process it

00:20:19,620 --> 00:20:26,330
and when did you get back so to get the

00:20:21,990 --> 00:20:26,330
actual offset which the tricky part

00:20:33,090 --> 00:20:37,390
yeah you could pro yeah that's probably

00:20:35,350 --> 00:20:40,180
good idea use the p2p one because that's

00:20:37,390 --> 00:20:41,590
precisely use cut isn't it I haven't

00:20:40,180 --> 00:20:45,790
really looked into PDP but yes that's

00:20:41,590 --> 00:20:47,980
probably a good idea yeah all right good

00:20:45,790 --> 00:20:56,040
any more questions here because actually

00:20:47,980 --> 00:20:56,040
that's the first time toss talk done yes

00:20:59,790 --> 00:21:08,200
regarding now you have to have to talk

00:21:03,520 --> 00:21:12,280
really close it's actually on it um with

00:21:08,200 --> 00:21:17,320
the omm you I'm I'm more familiar with

00:21:12,280 --> 00:21:19,480
traditional mm you before the hardware

00:21:17,320 --> 00:21:23,820
extensions there were shadow pages to

00:21:19,480 --> 00:21:26,920
translate guests to physical addresses

00:21:23,820 --> 00:21:31,840
and with the extensions from pimentel

00:21:26,920 --> 00:21:36,430
named Eve nested pages sure you you do

00:21:31,840 --> 00:21:39,580
have a performance benefit saving the vm

00:21:36,430 --> 00:21:40,930
exits and having the host host having to

00:21:39,580 --> 00:21:44,140
keep up with the page tables on the

00:21:40,930 --> 00:21:48,670
guest but it also introduced the 2d page

00:21:44,140 --> 00:21:51,790
walk so depending on the performance and

00:21:48,670 --> 00:21:56,380
the workload characteristics you either

00:21:51,790 --> 00:22:00,370
have a performance gain or a loss does

00:21:56,380 --> 00:22:02,710
any of this translate into IM mmm you it

00:22:00,370 --> 00:22:04,300
actually does yeah because with i only

00:22:02,710 --> 00:22:07,060
we have the very same problems all over

00:22:04,300 --> 00:22:08,680
again you have the very same concept you

00:22:07,060 --> 00:22:11,260
have to have a you have additional page

00:22:08,680 --> 00:22:13,780
tables you have so you need to do an

00:22:11,260 --> 00:22:16,870
additional page walk iom you page walk

00:22:13,780 --> 00:22:19,270
you do have an iota TLB where all the

00:22:16,870 --> 00:22:20,830
lookup is being stored the iot lb is of

00:22:19,270 --> 00:22:23,080
different sizes depending on which city

00:22:20,830 --> 00:22:24,850
you you're running on mg has some insane

00:22:23,080 --> 00:22:26,440
amounts so you basically never need to

00:22:24,850 --> 00:22:30,100
flush the ltl because you're never able

00:22:26,440 --> 00:22:32,110
to fill it and on the inside you have an

00:22:30,100 --> 00:22:34,840
insanely small I OTL be so we're

00:22:32,110 --> 00:22:36,640
basically only basically nothing fits in

00:22:34,840 --> 00:22:40,029
it so you have to do TV first version on

00:22:36,640 --> 00:22:41,379
every access so yes it's

00:22:40,029 --> 00:22:44,469
basically the same here it's the same

00:22:41,379 --> 00:22:47,529
all over again and this is exactly known

00:22:44,469 --> 00:22:50,919
as i'm done any measurement here so it's

00:22:47,529 --> 00:22:54,070
just so really brought thumb yeah it

00:22:50,919 --> 00:22:55,929
looks as if let's see yes and I won't do

00:22:54,070 --> 00:22:57,940
it anyway so most go ahead and pro and

00:22:55,929 --> 00:22:59,769
program it without any real backing

00:22:57,940 --> 00:23:01,929
whether it's faster or not like the TCM

00:22:59,769 --> 00:23:08,429
vejo stuff yeah look specifically were

00:23:01,929 --> 00:23:08,429
faster but boo weathers really faster

00:23:15,960 --> 00:23:24,190
yes you will always be there will always

00:23:19,479 --> 00:23:26,919
be a dependency here and all performance

00:23:24,190 --> 00:23:28,659
measurement is only the specific

00:23:26,919 --> 00:23:30,549
workload you're introducing which you're

00:23:28,659 --> 00:23:32,799
measuring it is in no case the general

00:23:30,549 --> 00:23:34,059
one sure I mean this is no performance

00:23:32,799 --> 00:23:38,019
measurement you always have this problem

00:23:34,059 --> 00:23:39,879
and even further even the measuring KOMU

00:23:38,019 --> 00:23:41,979
there's even get to get it's even

00:23:39,879 --> 00:23:45,489
getting worse it might will be that your

00:23:41,979 --> 00:23:47,739
test case you're running is gay is

00:23:45,489 --> 00:23:49,929
geared up for one specific IOM you

00:23:47,739 --> 00:23:52,239
implementation not for the other so you

00:23:49,929 --> 00:23:54,129
might inadvertently just hitting the

00:23:52,239 --> 00:23:56,799
sweet spot of the IOM your button

00:23:54,129 --> 00:23:59,289
wouldn't even know because well you

00:23:56,799 --> 00:24:01,149
wouldn't you don't know at least I don't

00:23:59,289 --> 00:24:04,979
have a lot much internal knowledge of

00:24:01,149 --> 00:24:04,979
how a guy who works here

00:24:11,159 --> 00:24:18,509
what so you said that nobody has really

00:24:14,499 --> 00:24:20,649
benchmarked pci pass through stuff the

00:24:18,509 --> 00:24:25,869
virtuous if it really gives any

00:24:20,649 --> 00:24:28,869
performance in boost well the idea is

00:24:25,869 --> 00:24:30,940
that it does okay but it takes away I

00:24:28,869 --> 00:24:34,059
mean you no longer it's simple you're

00:24:30,940 --> 00:24:35,830
just taking away quite a few stuff so it

00:24:34,059 --> 00:24:37,479
must be false yeah and you're taking

00:24:35,830 --> 00:24:39,219
away one of the biggest features of

00:24:37,479 --> 00:24:41,320
virtualization I mean you can no longer

00:24:39,219 --> 00:24:44,080
migrate a machine yeah and here we go

00:24:41,320 --> 00:24:46,239
the migration stuff again yeah you can't

00:24:44,080 --> 00:24:50,859
migrate hey your towns you can't migrate

00:24:46,239 --> 00:24:52,599
I don't care why do you ask easier why

00:24:50,859 --> 00:24:55,570
do you want to virtualize at all if you

00:24:52,599 --> 00:24:57,849
don't want to my already for example not

00:24:55,570 --> 00:24:59,649
only migration and I'm sorry for

00:24:57,849 --> 00:25:01,809
interruption but I mean one of the

00:24:59,649 --> 00:25:04,149
benefits of virtualization is that you

00:25:01,809 --> 00:25:06,969
get hardware abstraction basically yeah

00:25:04,149 --> 00:25:08,799
and this is the age-old battle in

00:25:06,969 --> 00:25:11,200
virtualization what do we want to

00:25:08,799 --> 00:25:15,879
achieve with virtualization do you want

00:25:11,200 --> 00:25:19,029
to have a random virtual guests which

00:25:15,879 --> 00:25:22,359
provides a hardware which you can talk

00:25:19,029 --> 00:25:24,549
to which will run anywhere which is

00:25:22,359 --> 00:25:25,960
basically totally virtualized concept so

00:25:24,549 --> 00:25:27,879
you're running on abstract hardware

00:25:25,960 --> 00:25:31,359
which doesn't access on the real world

00:25:27,879 --> 00:25:40,499
but gives you the best performance or do

00:25:31,359 --> 00:25:40,499
you want to emulate a real machine so

00:25:40,559 --> 00:25:44,889
because then I can just run in everyone

00:25:43,149 --> 00:25:46,659
and it's just it's just nicer and it

00:25:44,889 --> 00:25:48,249
might well be that this hard way that I

00:25:46,659 --> 00:25:50,639
do need add to have access to this

00:25:48,249 --> 00:25:54,969
hardware which doesn't exist anymore

00:25:50,639 --> 00:26:01,599
like IBM mainframe I'm a mainframe had

00:25:54,969 --> 00:26:03,669
their own feel horrible old x500 drivers

00:26:01,599 --> 00:26:06,369
was what was the name of that and the

00:26:03,669 --> 00:26:10,089
old old escon wants they had this

00:26:06,369 --> 00:26:13,960
specific transfer mode they all see the

00:26:10,089 --> 00:26:15,919
LC network cards you didn't know about

00:26:13,960 --> 00:26:22,679
it

00:26:15,919 --> 00:26:25,830
all right no no network I oh the old old

00:26:22,679 --> 00:26:28,590
network driver yeah oh yeah exactly Oh

00:26:25,830 --> 00:26:30,960
Sam yeah that's it so there used to be

00:26:28,590 --> 00:26:35,190
real hard we're doing this doing the

00:26:30,960 --> 00:26:37,769
others and for the osm card but then

00:26:35,190 --> 00:26:40,409
eventually they have the main

00:26:37,769 --> 00:26:41,969
manufacturer of the heart run run event

00:26:40,409 --> 00:26:43,590
out of business so there's whoa there

00:26:41,969 --> 00:26:45,419
wasn't any they couldn't get any

00:26:43,590 --> 00:26:49,139
hardware anymore but they were still

00:26:45,419 --> 00:26:51,659
there support contracts still were

00:26:49,139 --> 00:26:53,460
running for another 10 years so they had

00:26:51,659 --> 00:26:55,169
to provide at least something to get

00:26:53,460 --> 00:26:57,019
excited to make this work again so they

00:26:55,169 --> 00:27:00,599
actually had to emulate the whole thing

00:26:57,019 --> 00:27:02,489
inside the machine just so that they

00:27:00,599 --> 00:27:04,379
have a drive would just looks like an

00:27:02,489 --> 00:27:08,279
osm one but in fact was just totally

00:27:04,379 --> 00:27:11,219
from hardware anyway so yeah but I mean

00:27:08,279 --> 00:27:13,859
that is the whole idea of the QM of

00:27:11,219 --> 00:27:15,779
stuff to emulate things isn't it so I

00:27:13,859 --> 00:27:17,309
mean this is cure which outlines tons

00:27:15,779 --> 00:27:20,899
and tons and tons of things why would

00:27:17,309 --> 00:27:25,619
you want to emulate say in SH for or

00:27:20,899 --> 00:27:27,419
whatever mg Voyager who cares if because

00:27:25,619 --> 00:27:29,879
if you either you do a virtualization

00:27:27,419 --> 00:27:31,919
thing then you should get you should do

00:27:29,879 --> 00:27:38,580
the virtualization actually good oh you

00:27:31,919 --> 00:27:40,859
want to do an imitation because they're

00:27:38,580 --> 00:27:43,469
kind of because then you can do because

00:27:40,859 --> 00:27:45,599
logical partitioning on the dr on the

00:27:43,469 --> 00:27:47,669
machine cuz once every several

00:27:45,599 --> 00:27:49,019
Independence's on the machine the final

00:27:47,669 --> 00:27:51,719
got yours plenty of use case for a

00:27:49,019 --> 00:27:53,399
device past true is prefers and one case

00:27:51,719 --> 00:27:55,200
is where you just want to consolidate

00:27:53,399 --> 00:27:57,119
workloads onto machine but have to fully

00:27:55,200 --> 00:27:59,009
I stage without use of containers in

00:27:57,119 --> 00:27:59,999
which case each individual machine

00:27:59,009 --> 00:28:01,979
should run as quickly as possible

00:27:59,999 --> 00:28:03,389
however there's no use case to my grades

00:28:01,979 --> 00:28:06,869
because it runs for the duration of the

00:28:03,389 --> 00:28:09,389
job and finishes there are cases where

00:28:06,869 --> 00:28:10,950
people simply do not need to migrate a

00:28:09,389 --> 00:28:12,659
virtual machine nor do they need the

00:28:10,950 --> 00:28:16,109
option to be available but the do need a

00:28:12,659 --> 00:28:20,549
virtual machine to run quickly like I

00:28:16,109 --> 00:28:23,399
mean powerpc powerpc runs virtualized

00:28:20,549 --> 00:28:25,889
all the way it has listen as an al pal

00:28:23,399 --> 00:28:26,919
you can't migrate nel pal everyone's

00:28:25,889 --> 00:28:30,129
happy without

00:28:26,919 --> 00:28:35,230
no one cares about my migration here

00:28:30,129 --> 00:28:36,909
that's oh I'm finished haha now we can

00:28:35,230 --> 00:28:39,309
talk about later but yeah I mean this is

00:28:36,909 --> 00:28:40,869
the you always get into this battle do

00:28:39,309 --> 00:28:43,779
we want to virtualization or do we want

00:28:40,869 --> 00:28:50,999
an emulation they are close but not

00:28:43,779 --> 00:28:50,999

YouTube URL: https://www.youtube.com/watch?v=UwP4EHlqdig


