Title: osc12: fdisk: a 21st century disk partitioning tool
Publication date: 2012-10-24
Playlist: openSUSE Conference 2012
Description: 
	osc12: fdisk: a 21st century disk partitioning tool from openSUSE. Like this? Watch the latest episode of openSUSE on Blip! http://blip.tv/opensuse/watch 

Davidlohr Bueso, Petr Uzel - Spock

See all episodes of openSUSE http://blip.tv/opensuse#EpisodeArchive
Visit openSUSE's series page http://blip.tv/opensuse
Captions: 
	00:00:00,000 --> 00:00:06,299
let's start hello everyone I have to say

00:00:03,149 --> 00:00:08,760
that I'm quite impressed by the number

00:00:06,299 --> 00:00:11,099
of people who are interested in such a

00:00:08,760 --> 00:00:14,340
boring topic as disk partitioning case

00:00:11,099 --> 00:00:16,440
but thank you for coming let me

00:00:14,340 --> 00:00:18,449
introduce let me start its shortly

00:00:16,440 --> 00:00:21,390
introducing ourselves my name is petal

00:00:18,449 --> 00:00:23,850
del I work for Souza and one of my

00:00:21,390 --> 00:00:27,000
responsibilities is that I need to take

00:00:23,850 --> 00:00:29,849
I'm maintaining I maintain the Utah

00:00:27,000 --> 00:00:31,349
linux package and parted package if you

00:00:29,849 --> 00:00:32,489
know I don't know if you know that's at

00:00:31,349 --> 00:00:35,010
the goethe linux package is the one

00:00:32,489 --> 00:00:37,649
which ships the fdisk like utilities so

00:00:35,010 --> 00:00:40,230
I'm basically the partitioner guy forces

00:00:37,649 --> 00:00:42,270
at least the user space party so just

00:00:40,230 --> 00:00:45,030
touching with my connection to the stock

00:00:42,270 --> 00:00:48,899
and the guy standing next to me it's the

00:00:45,030 --> 00:00:50,879
grizzle who works on a disk during this

00:00:48,899 --> 00:00:53,250
summer a little sign of code so he's the

00:00:50,879 --> 00:00:55,050
one to bind with I've this stops working

00:00:53,250 --> 00:00:59,460
for you and watch later you use a little

00:00:55,050 --> 00:01:01,800
packet I'll get this just an overview we

00:00:59,460 --> 00:01:06,990
can skip this one you might be wondering

00:01:01,800 --> 00:01:12,119
why we decided to take into the into the

00:01:06,990 --> 00:01:13,950
partition Earth's code because well yeah

00:01:12,119 --> 00:01:16,530
there are a couple of packages or a

00:01:13,950 --> 00:01:20,070
couple of projects which take care which

00:01:16,530 --> 00:01:22,710
due to partitioning and to give you some

00:01:20,070 --> 00:01:25,229
idea what we decided to work on fdisk

00:01:22,710 --> 00:01:26,820
and not any other partitioning tool i

00:01:25,229 --> 00:01:29,880
would like to present you the short list

00:01:26,820 --> 00:01:33,299
of available partitioning tools and some

00:01:29,880 --> 00:01:39,320
up their advantages and disadvantages so

00:01:33,299 --> 00:01:39,320
the first one it's um GNE you parted

00:01:39,979 --> 00:01:48,770
quite widely used package project or

00:01:45,630 --> 00:01:53,280
software or whatever for partitioning

00:01:48,770 --> 00:01:55,110
obviously one of the advantages and big

00:01:53,280 --> 00:01:58,020
advantages and the reason why it's used

00:01:55,110 --> 00:01:59,579
so widely is that it supports basically

00:01:58,020 --> 00:02:00,570
anything which you can have on the drive

00:01:59,579 --> 00:02:03,180
which has something to do with

00:02:00,570 --> 00:02:07,819
partitions for example GPT the legacy

00:02:03,180 --> 00:02:10,020
MBR AIX dvh and all those crazy

00:02:07,819 --> 00:02:12,370
abbreviations for partitioned labels

00:02:10,020 --> 00:02:13,930
which I don't even know what they mean

00:02:12,370 --> 00:02:15,370
but yeah the thing is that it supports

00:02:13,930 --> 00:02:20,470
basically everything and it presents

00:02:15,370 --> 00:02:23,709
nice nice unified API on top of the core

00:02:20,470 --> 00:02:26,620
functionality which means yes it works

00:02:23,709 --> 00:02:29,319
the same for whatever you have on the on

00:02:26,620 --> 00:02:31,569
the disk this could be considered an

00:02:29,319 --> 00:02:35,829
advantage but also it comes with some

00:02:31,569 --> 00:02:38,560
disadvantages which means that basically

00:02:35,829 --> 00:02:43,840
the support for almost everything makes

00:02:38,560 --> 00:02:47,829
it very inflexible we at sue's anymore

00:02:43,840 --> 00:02:50,739
we have to deal with various types of

00:02:47,829 --> 00:02:52,930
problems which are almost impossible to

00:02:50,739 --> 00:02:56,440
fix in part it's because because of its

00:02:52,930 --> 00:03:00,310
in at least in my opinion extreme in

00:02:56,440 --> 00:03:04,329
flexibility so yeah in ninety nine

00:03:00,310 --> 00:03:06,090
percent cases it works perfectly but in

00:03:04,329 --> 00:03:10,090
the rest is almost impossible to fix

00:03:06,090 --> 00:03:11,970
that's how I see that yeah another

00:03:10,090 --> 00:03:14,200
advantage that's the presence or

00:03:11,970 --> 00:03:17,380
existence of laporte that with it which

00:03:14,200 --> 00:03:20,440
is the short library supposed to you

00:03:17,380 --> 00:03:22,329
know for partitioning obviously when as

00:03:20,440 --> 00:03:28,000
I told you it's very inflexible so

00:03:22,329 --> 00:03:31,680
that's it then we have GPT fdisk which

00:03:28,000 --> 00:03:34,540
has great support for GPT more about GPT

00:03:31,680 --> 00:03:37,989
they will tell you what GPT is good for

00:03:34,540 --> 00:03:40,690
if you don't know that so yet it works

00:03:37,989 --> 00:03:46,419
perfectly for GPT but it works only for

00:03:40,690 --> 00:03:49,239
GPT so not that useful and past we have

00:03:46,419 --> 00:03:52,329
the fdisk family this is actually what

00:03:49,239 --> 00:03:56,349
the Eiffel Tokyo would we will talk

00:03:52,329 --> 00:03:58,900
about just to give you one idea about

00:03:56,349 --> 00:04:01,480
the mess so we have all these three

00:03:58,900 --> 00:04:03,250
utilities fdisk CF this kind of this car

00:04:01,480 --> 00:04:05,319
parts of the same package that's the

00:04:03,250 --> 00:04:09,430
utility nukes but it doesn't share any

00:04:05,319 --> 00:04:16,139
code so the somehow you know Adam a C

00:04:09,430 --> 00:04:21,729
and M life it's up to you now thank you

00:04:16,139 --> 00:04:24,610
so the f this family has preset it's

00:04:21,729 --> 00:04:28,090
part of the Utah Alex package

00:04:24,610 --> 00:04:30,879
and I've been hacking around programs

00:04:28,090 --> 00:04:33,939
and utilities on this package for for

00:04:30,879 --> 00:04:37,139
some time and in our to do file there is

00:04:33,939 --> 00:04:40,569
always fdisk clean clean up if this and

00:04:37,139 --> 00:04:42,699
it's been there been there been there

00:04:40,569 --> 00:04:48,389
nobody really wants to do it and I don't

00:04:42,699 --> 00:04:50,409
blame him so to further understand why I

00:04:48,389 --> 00:04:52,300
don't know if you've ever seen the code

00:04:50,409 --> 00:04:57,310
or at least the one that used to be

00:04:52,300 --> 00:05:00,310
there but it is smelly legacy code it's

00:04:57,310 --> 00:05:03,400
been around the fdisk itself for around

00:05:00,310 --> 00:05:06,300
20 years and over the time it's been

00:05:03,400 --> 00:05:10,569
subject to multiple hacks by different

00:05:06,300 --> 00:05:13,360
programmers with different ideas of what

00:05:10,569 --> 00:05:16,210
this utility should do should be like

00:05:13,360 --> 00:05:20,529
behave so we have a ton of different

00:05:16,210 --> 00:05:22,719
coding coding styles even stack jumping

00:05:20,529 --> 00:05:26,469
still where we still had it to a few

00:05:22,719 --> 00:05:29,919
months ago so all this is a result of

00:05:26,469 --> 00:05:33,250
code that's really good together and as

00:05:29,919 --> 00:05:38,830
you can imagine it's difficult to

00:05:33,250 --> 00:05:41,969
understand it when you hack it it is

00:05:38,830 --> 00:05:46,120
very error-prone because of its

00:05:41,969 --> 00:05:50,710
complexity of reading the code so that's

00:05:46,120 --> 00:05:55,539
mainly the reason why I chose to Reese

00:05:50,710 --> 00:06:02,050
revive fdisk so that's basically me

00:05:55,539 --> 00:06:04,449
during the summer very very bad so if

00:06:02,050 --> 00:06:08,439
this was stuck in the past we only had a

00:06:04,449 --> 00:06:13,569
das compatibility mode no GPT support

00:06:08,439 --> 00:06:16,620
except for recognizing a deputy disk the

00:06:13,569 --> 00:06:20,560
legacies cylinder head sector addressing

00:06:16,620 --> 00:06:26,580
and the the user interface for if disc

00:06:20,560 --> 00:06:29,860
itself is quite nasty and as pretty said

00:06:26,580 --> 00:06:34,990
the the other tools see if disc in SF

00:06:29,860 --> 00:06:37,860
disk had their own implementations there

00:06:34,990 --> 00:06:41,980
was no reusing code

00:06:37,860 --> 00:06:46,300
so what happens with all this hacker

00:06:41,980 --> 00:06:48,580
zoe's I don't blame anybody for wanting

00:06:46,300 --> 00:06:50,700
for not wanting to add new code and

00:06:48,580 --> 00:06:54,340
extending functionality because it's

00:06:50,700 --> 00:06:57,370
difficult tedious and error-prone and as

00:06:54,340 --> 00:06:59,110
a result users rules as well in the

00:06:57,370 --> 00:07:03,370
current state if this could not compete

00:06:59,110 --> 00:07:07,110
with other this partition errs for

00:07:03,370 --> 00:07:10,120
example parted and healthy competition

00:07:07,110 --> 00:07:12,430
is good for everybody because the more

00:07:10,120 --> 00:07:14,230
competition the better the code is the

00:07:12,430 --> 00:07:19,450
bit of functionality and the community

00:07:14,230 --> 00:07:22,060
grows so to fix all this mess we need to

00:07:19,450 --> 00:07:27,250
update f this to modern 21st century

00:07:22,060 --> 00:07:29,380
this standards the short-term goals

00:07:27,250 --> 00:07:32,500
which was the actual work I did during

00:07:29,380 --> 00:07:36,310
the summer was to clean up and refactor

00:07:32,500 --> 00:07:39,520
current legacy code create an internal

00:07:36,310 --> 00:07:42,730
API that abstracts the specifications

00:07:39,520 --> 00:07:49,660
and complexity of disk labels and

00:07:42,730 --> 00:07:52,030
finally add GPT support the thing all

00:07:49,660 --> 00:07:55,360
this is towards the greater good which

00:07:52,030 --> 00:07:59,020
long-term goals is to create an

00:07:55,360 --> 00:08:01,150
independent shared library like the beft

00:07:59,020 --> 00:08:03,610
disk kind of like it parted what look

00:08:01,150 --> 00:08:05,950
part it is to a new part it and with

00:08:03,610 --> 00:08:07,990
that new library rewrite the other

00:08:05,950 --> 00:08:16,450
remaining tools which is see if this can

00:08:07,990 --> 00:08:19,090
SF disk well since if disk is quite

00:08:16,450 --> 00:08:22,720
visible and it's been around for a long

00:08:19,090 --> 00:08:25,270
time we obviously can't break backwards

00:08:22,720 --> 00:08:28,120
compatibility in fact the the maintainer

00:08:25,270 --> 00:08:31,169
of the util enix package is very very

00:08:28,120 --> 00:08:36,720
strong about this and I of course agree

00:08:31,169 --> 00:08:40,870
and the the quality of the code that

00:08:36,720 --> 00:08:43,960
we're replacing it with has to be good

00:08:40,870 --> 00:08:46,990
quality I don't ever want to have to do

00:08:43,960 --> 00:08:50,820
this again well I'm alive so I hope it

00:08:46,990 --> 00:08:50,820
sticks for at least the next few decades

00:08:51,460 --> 00:08:56,900
so we're going to see I'm going to talk

00:08:55,310 --> 00:08:59,060
a little bit about the the new internal

00:08:56,900 --> 00:09:01,280
API which is still internal it's not a

00:08:59,060 --> 00:09:04,280
shared library yet some of the things

00:09:01,280 --> 00:09:05,840
I'm going to mention our things we want

00:09:04,280 --> 00:09:09,140
to other things are things we have

00:09:05,840 --> 00:09:13,370
already and we're also going to see

00:09:09,140 --> 00:09:16,400
about gbt support so the new internal

00:09:13,370 --> 00:09:21,140
API is that idea is to create an

00:09:16,400 --> 00:09:25,520
abstraction between the partition errs

00:09:21,140 --> 00:09:28,910
and what the partition to implementation

00:09:25,520 --> 00:09:32,120
like for example the user interfaces and

00:09:28,910 --> 00:09:37,310
what the actual functionality of a dis

00:09:32,120 --> 00:09:39,590
partitioner should provide we decided to

00:09:37,310 --> 00:09:42,140
use a driver based model to deal with

00:09:39,590 --> 00:09:45,110
disk labels and handle them through

00:09:42,140 --> 00:09:48,320
handle the events through callbacks for

00:09:45,110 --> 00:09:52,700
example adding up a partition verifying

00:09:48,320 --> 00:09:55,580
integrity getting the amount of free

00:09:52,700 --> 00:10:00,200
sectors things like that and this API

00:09:55,580 --> 00:10:02,900
can be seen first as a generic can

00:10:00,200 --> 00:10:05,360
handle generic disk logic like topology

00:10:02,900 --> 00:10:08,510
sectors and master boot record and also

00:10:05,360 --> 00:10:14,540
a gateway to the internal specifics of V

00:10:08,510 --> 00:10:18,830
of each disk label we have a central

00:10:14,540 --> 00:10:23,330
data structure that's our fdisk context

00:10:18,830 --> 00:10:26,690
which is an opaque structure we plan on

00:10:23,330 --> 00:10:29,030
adding version symbols to allow a bit of

00:10:26,690 --> 00:10:32,690
flexibility and perhaps the most

00:10:29,030 --> 00:10:35,660
important thing to explain is that it

00:10:32,690 --> 00:10:39,140
describes the disk so through this

00:10:35,660 --> 00:10:41,240
structure we can access everything from

00:10:39,140 --> 00:10:43,550
the disk and internally we can access

00:10:41,240 --> 00:10:48,500
all the disks operations through the

00:10:43,550 --> 00:10:51,530
disk labels here's a little overview

00:10:48,500 --> 00:10:56,080
that's a bit more more clear we can see

00:10:51,530 --> 00:10:58,950
that a pop if this if this SF this any

00:10:56,080 --> 00:11:05,820
this partitioning program

00:10:58,950 --> 00:11:08,670
we'll use this API to both do common

00:11:05,820 --> 00:11:11,850
disk utility things like initialization

00:11:08,670 --> 00:11:17,600
and device discovery through topology in

00:11:11,850 --> 00:11:21,720
geometry and when we need to work with

00:11:17,600 --> 00:11:25,770
disk label specifics we can see it as

00:11:21,720 --> 00:11:28,890
gateway that the app the API will handle

00:11:25,770 --> 00:11:33,570
the and the other part of the label

00:11:28,890 --> 00:11:36,630
specifics for example does bsd SDI GPT

00:11:33,570 --> 00:11:39,750
San etc and here we have the specifics

00:11:36,630 --> 00:11:48,180
that might be probing or adding deleting

00:11:39,750 --> 00:11:52,770
partitions etc what benefits does having

00:11:48,180 --> 00:11:54,990
happy bring us well we can unify

00:11:52,770 --> 00:12:00,390
concepts and specifications yet without

00:11:54,990 --> 00:12:04,710
hiding the details of disk labels it

00:12:00,390 --> 00:12:08,130
simplifies our work it makes the code

00:12:04,710 --> 00:12:12,960
easier to read and modify and this leads

00:12:08,130 --> 00:12:14,880
to I'm detecting bugs easier and reduces

00:12:12,960 --> 00:12:18,900
the the probability of introducing new

00:12:14,880 --> 00:12:27,230
ones and as I mentioned once complete we

00:12:18,900 --> 00:12:30,990
intend to have a shared library this

00:12:27,230 --> 00:12:34,970
internal IP I was the first thing I did

00:12:30,990 --> 00:12:38,190
during the summer and once i had this

00:12:34,970 --> 00:12:40,710
finished the next step was to implement

00:12:38,190 --> 00:12:44,390
GPT support i'm proud to say that

00:12:40,710 --> 00:12:47,150
because of these changes in the API

00:12:44,390 --> 00:12:51,870
adding a new disk label support was

00:12:47,150 --> 00:12:54,390
considerably easier so I could just deal

00:12:51,870 --> 00:13:01,440
with the complexity of GPT and not the

00:12:54,390 --> 00:13:04,200
complexity of fdisk so what is DPT it's

00:13:01,440 --> 00:13:07,470
a standard filling out

00:13:04,200 --> 00:13:10,950
my petition table on a disk developed by

00:13:07,470 --> 00:13:12,840
into in the late 90s and main idea was

00:13:10,950 --> 00:13:15,960
to overcome the limitations of the

00:13:12,840 --> 00:13:22,110
Master Boot Record nowadays it's part of

00:13:15,960 --> 00:13:24,540
the UEFI standard as well basically when

00:13:22,110 --> 00:13:29,000
we describe the benefits of GPT we're

00:13:24,540 --> 00:13:32,520
also talking about the problems of em Br

00:13:29,000 --> 00:13:36,900
for example GPT does not hear any more

00:13:32,520 --> 00:13:40,680
about logical extended partitions you

00:13:36,900 --> 00:13:44,370
can handle at least 128 named primary

00:13:40,680 --> 00:13:48,090
partitions since it uses 64-bit

00:13:44,370 --> 00:13:52,080
addressing through LBA if we use of

00:13:48,090 --> 00:13:58,740
typical 512 byte sector size we can get

00:13:52,080 --> 00:14:03,630
up to 9.4 Seabees in the partition it

00:13:58,740 --> 00:14:07,800
has a 32-bit checksums ERC's for the

00:14:03,630 --> 00:14:10,920
integrity and it has redundancy the data

00:14:07,800 --> 00:14:16,490
structures which of course protects

00:14:10,920 --> 00:14:20,640
against this failures for example MBR

00:14:16,490 --> 00:14:24,810
only since it has a 32-bit addressing it

00:14:20,640 --> 00:14:28,050
will only extend to two terabytes there

00:14:24,810 --> 00:14:30,570
also there's no redundancy in the data

00:14:28,050 --> 00:14:36,210
structure so this corruption is a lot

00:14:30,570 --> 00:14:41,100
more serious but there's no such thing

00:14:36,210 --> 00:14:44,400
as a free lunch so the drawbacks could

00:14:41,100 --> 00:14:47,640
be seen as currently there's not all the

00:14:44,400 --> 00:14:49,910
operating systems support GPT the same

00:14:47,640 --> 00:14:53,340
with the boot loaders and we have

00:14:49,910 --> 00:14:56,640
strange non-standard schemes like the

00:14:53,340 --> 00:15:00,900
hybrid master we recorded that for

00:14:56,640 --> 00:15:05,150
example is useful for systems that don't

00:15:00,900 --> 00:15:09,450
know about GBT like windows seven or XP

00:15:05,150 --> 00:15:13,769
XP ok so we have some some weird things

00:15:09,450 --> 00:15:17,589
going on as well so

00:15:13,769 --> 00:15:19,630
it was a well-known fact that if this

00:15:17,589 --> 00:15:22,959
didn't play well with with g bt in fact

00:15:19,630 --> 00:15:26,290
when it recognized the GPT disk label it

00:15:22,959 --> 00:15:30,820
said please use canoe parted so it's

00:15:26,290 --> 00:15:33,880
pushing users away when the users

00:15:30,820 --> 00:15:36,760
decided to actually use fdisk with g bt

00:15:33,880 --> 00:15:40,740
it could only use the the protective MBR

00:15:36,760 --> 00:15:45,160
which is the legacy das partitions and

00:15:40,740 --> 00:15:48,310
finally last month we got GPT support

00:15:45,160 --> 00:15:52,980
merge in main line if this I could say

00:15:48,310 --> 00:15:57,399
full it has all the necessary things

00:15:52,980 --> 00:16:01,240
code to to deal with GPT but it's there

00:15:57,399 --> 00:16:05,980
when a very experimental phase so use it

00:16:01,240 --> 00:16:07,690
at your own discretion I was just

00:16:05,980 --> 00:16:09,579
wondering when random idea whether we

00:16:07,690 --> 00:16:17,529
should patch part is to send the users

00:16:09,579 --> 00:16:23,800
back yes actually that would be quite

00:16:17,529 --> 00:16:25,930
fair we regain our our users so some

00:16:23,800 --> 00:16:28,690
details like some things that are

00:16:25,930 --> 00:16:31,630
different from our implementation then

00:16:28,690 --> 00:16:36,069
you see and others of parted and GPT

00:16:31,630 --> 00:16:40,569
fdisk first of all we deal with both

00:16:36,069 --> 00:16:43,630
legacy and hybrid mbrs when we write

00:16:40,569 --> 00:16:46,839
data the in-memory data changes to back

00:16:43,630 --> 00:16:50,350
to the disk if we're using a protective

00:16:46,839 --> 00:16:52,600
as I refreezing a hybrid MBR we actually

00:16:50,350 --> 00:16:55,180
don't write anything because if we did

00:16:52,600 --> 00:17:00,180
we'd be replacing it with a protective

00:16:55,180 --> 00:17:04,750
MBR and that's immediately a problem

00:17:00,180 --> 00:17:08,199
every time where you're modifying the

00:17:04,750 --> 00:17:13,780
the disks layout like adding partitions

00:17:08,199 --> 00:17:16,959
deleting them we immediately verify the

00:17:13,780 --> 00:17:19,730
integrity to the checksums not only when

00:17:16,959 --> 00:17:24,590
we write the data to disk

00:17:19,730 --> 00:17:27,420
Peter here was recently of trying the

00:17:24,590 --> 00:17:29,940
deputy support with larger logical

00:17:27,420 --> 00:17:36,420
sectors with 4 k's instead of the

00:17:29,940 --> 00:17:38,580
standard 512 we provide generous support

00:17:36,420 --> 00:17:41,340
for good partition types when you're

00:17:38,580 --> 00:17:44,430
going to add a new partition it defaults

00:17:41,340 --> 00:17:48,090
to to Linux partition type but you can

00:17:44,430 --> 00:17:55,320
change it and there's a lot of options

00:17:48,090 --> 00:18:02,070
to to to add to okay so this is a start

00:17:55,320 --> 00:18:06,480
there's still plenty to do when in one

00:18:02,070 --> 00:18:12,030
to do might be enhance f disks user

00:18:06,480 --> 00:18:16,740
interface I like gdb style la lib'ry

00:18:12,030 --> 00:18:19,170
dine with automatic competition I'm

00:18:16,740 --> 00:18:24,150
support more discs labels i'm planning

00:18:19,170 --> 00:18:28,890
on in the near future as time allows to

00:18:24,150 --> 00:18:32,310
implement apple partition map we also

00:18:28,890 --> 00:18:36,530
need a IX and i'm sure they're plenty

00:18:32,310 --> 00:18:39,540
more there's still cleanups to be done

00:18:36,530 --> 00:18:43,100
we need to write proper documentation

00:18:39,540 --> 00:18:45,480
for example a part it has a very nice

00:18:43,100 --> 00:18:48,890
manual which is not the same as the man

00:18:45,480 --> 00:18:52,050
page has an extra manual and of course

00:18:48,890 --> 00:18:57,810
test test test test test but the most

00:18:52,050 --> 00:19:00,050
important part and thank you for for

00:18:57,810 --> 00:19:00,050
coming

00:19:13,170 --> 00:19:19,960
okay well I have one question which

00:19:17,380 --> 00:19:22,510
intrigued me from the beginning how did

00:19:19,960 --> 00:19:24,790
you manage to rewrite the API so that it

00:19:22,510 --> 00:19:28,980
is general but you didn't fall into the

00:19:24,790 --> 00:19:31,480
same trap as new parted so it's flexible

00:19:28,980 --> 00:19:36,910
yeah that's what we thought about and

00:19:31,480 --> 00:19:39,400
the idea is yes make like two layers in

00:19:36,910 --> 00:19:41,200
the API first one parted like which

00:19:39,400 --> 00:19:43,210
handles everything that's the

00:19:41,200 --> 00:19:47,050
ninety-nine point nine percent cases

00:19:43,210 --> 00:19:50,050
which which work fine but also we need

00:19:47,050 --> 00:19:53,020
to write we want to write a same API

00:19:50,050 --> 00:19:55,210
which would be functions label specific

00:19:53,020 --> 00:19:57,910
for example I don't know one idea which

00:19:55,210 --> 00:20:01,740
comes to my mind is a function bounce to

00:19:57,910 --> 00:20:05,290
GPT which would create a hybrid

00:20:01,740 --> 00:20:08,500
protective NBR for example this I try to

00:20:05,290 --> 00:20:10,510
solve this problem with parted and it

00:20:08,500 --> 00:20:12,760
was really impossible it ended up in a

00:20:10,510 --> 00:20:14,860
horrible horrible patch which I hope

00:20:12,760 --> 00:20:16,810
nobody has seen so far and I definitely

00:20:14,860 --> 00:20:20,830
don't want to push it up stream because

00:20:16,810 --> 00:20:22,030
it would make no sense that's it one of

00:20:20,830 --> 00:20:24,520
the problems part of the eyes or the

00:20:22,030 --> 00:20:26,410
library the liq parted library is that

00:20:24,520 --> 00:20:28,660
it doesn't use any version symbols in

00:20:26,410 --> 00:20:34,000
the API which makes it really really

00:20:28,660 --> 00:20:36,820
inflexible and everything in part it it

00:20:34,000 --> 00:20:39,970
really works fine but it's not

00:20:36,820 --> 00:20:41,980
extensible not at all at least I can do

00:20:39,970 --> 00:20:45,780
that and I don't think anyone else can

00:20:41,980 --> 00:20:45,780
without rewriting it's completely

00:21:04,100 --> 00:21:09,799
just messing with hard disk isn't

00:21:07,580 --> 00:21:11,900
something well someone can do unless

00:21:09,799 --> 00:21:13,910
they have a laboratory this to work on

00:21:11,900 --> 00:21:18,020
so I'm just curious at what level are

00:21:13,910 --> 00:21:19,970
you with the release of fdisk what what

00:21:18,020 --> 00:21:23,419
other distributions have it included at

00:21:19,970 --> 00:21:26,090
least your release and at what point do

00:21:23,419 --> 00:21:29,059
you think well it seems like now it's in

00:21:26,090 --> 00:21:32,410
beta but at what point do you think it

00:21:29,059 --> 00:21:32,410
would be released time

00:21:46,169 --> 00:21:48,919
thank you

00:21:50,350 --> 00:21:57,850
let's see the first part of the the

00:21:55,070 --> 00:22:01,130
project which was the internal IP I was

00:21:57,850 --> 00:22:07,040
part of the last release of a view to

00:22:01,130 --> 00:22:10,160
Linux with chips fdisk there's a release

00:22:07,040 --> 00:22:14,060
cycle of this package every six months

00:22:10,160 --> 00:22:17,570
or four what twice or three times a year

00:22:14,060 --> 00:22:19,850
more or less so we recently got the

00:22:17,570 --> 00:22:26,390
second part of which is the GPT support

00:22:19,850 --> 00:22:29,080
in so then we'd have to wait like three

00:22:26,390 --> 00:22:31,640
more months two more months for it to be

00:22:29,080 --> 00:22:36,220
available in the next version of Utah

00:22:31,640 --> 00:22:42,890
Linux there's a big message that it's

00:22:36,220 --> 00:22:47,900
still in beta stage so in any case when

00:22:42,890 --> 00:22:50,020
since distributions are using a older

00:22:47,900 --> 00:22:53,860
version of you to Linux like one or two

00:22:50,020 --> 00:22:59,530
versions behind it actually won't reach

00:22:53,860 --> 00:23:04,370
end-users until next year more or less

00:22:59,530 --> 00:23:09,710
so I'm calculating a formal right it's

00:23:04,370 --> 00:23:12,190
stable enough and in another at least

00:23:09,710 --> 00:23:12,190
five months

00:23:21,919 --> 00:23:25,070

YouTube URL: https://www.youtube.com/watch?v=lJvnR-B0BSo


