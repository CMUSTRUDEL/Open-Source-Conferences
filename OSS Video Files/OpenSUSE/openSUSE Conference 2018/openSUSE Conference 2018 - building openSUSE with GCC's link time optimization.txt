Title: openSUSE Conference 2018 - building openSUSE with GCC's link time optimization
Publication date: 2018-05-25
Playlist: openSUSE Conference 2018
Description: 
	smaller & faster binaries

Link time optimization (LTO) extends scope of compiler optimizations to whole program or DSO. We present some data on pros & cons of using LTO to build openSUSE distribution by default. This is joint with with Martin Liška and Martin Jambor.

Link time optimization (LTO) extends scope of compiler optimizations to whole program or DSO. We present some data on pros & cons of using LTO to build openSUSE distribution by default. This is joint with with Martin Liška and Martin Jambor.

Jan Hubička
Captions: 
	00:00:06,920 --> 00:00:14,889
so hello my name is Sam bubucaca

00:00:10,070 --> 00:00:17,750
and I'm working on GCC for for Suzie and

00:00:14,889 --> 00:00:20,810
so this talk is going to be a bit about

00:00:17,750 --> 00:00:23,690
GCC and it's a joint talk with Mark

00:00:20,810 --> 00:00:25,370
English Irish is here so and about ten

00:00:23,690 --> 00:00:27,080
minutes before the end of the talk he

00:00:25,370 --> 00:00:29,060
will punch me and start speaking instead

00:00:27,080 --> 00:00:32,809
of me so don't be surprised that's

00:00:29,060 --> 00:00:35,809
prepared okay so I would like to say

00:00:32,809 --> 00:00:37,490
something about link time optimizations

00:00:35,809 --> 00:00:39,680
and I would like to try to convince you

00:00:37,490 --> 00:00:42,920
that it's a it's an interesting thing to

00:00:39,680 --> 00:00:45,020
try out and so the in the first part of

00:00:42,920 --> 00:00:47,329
the talk I will simply explain what the

00:00:45,020 --> 00:00:49,970
what the Ring time optimization is and

00:00:47,329 --> 00:00:53,690
then I will spend some time showing you

00:00:49,970 --> 00:00:56,630
some benchmarks and then we will try to

00:00:53,690 --> 00:00:58,340
discuss you know if the open source can

00:00:56,630 --> 00:01:00,829
be one of the first distributions which

00:00:58,340 --> 00:01:02,719
are built by LTO might be the first one

00:01:00,829 --> 00:01:06,619
because I don't know and about another

00:01:02,719 --> 00:01:12,080
one so let's start about about learning

00:01:06,619 --> 00:01:14,420
time optimization this is this is the

00:01:12,080 --> 00:01:17,450
usual compression model of the C

00:01:14,420 --> 00:01:20,150
compilers which is starting from from

00:01:17,450 --> 00:01:22,130
70s and in this model you know you run

00:01:20,150 --> 00:01:24,590
the compiler on every single source file

00:01:22,130 --> 00:01:28,250
and you produce the object files which

00:01:24,590 --> 00:01:30,619
are containing the final binary or final

00:01:28,250 --> 00:01:33,260
assembler output and then you use the

00:01:30,619 --> 00:01:35,720
linker it just bruises together and you

00:01:33,260 --> 00:01:38,869
get your binary which is cool because

00:01:35,720 --> 00:01:42,140
it's fast and you can distribute the

00:01:38,869 --> 00:01:43,790
build process but it's also limiting the

00:01:42,140 --> 00:01:45,470
compiler in the in the quantity of

00:01:43,790 --> 00:01:46,939
optimizations is can do because it

00:01:45,470 --> 00:01:48,530
doesn't know what the other objects are

00:01:46,939 --> 00:01:52,520
doing it only sees the part of the

00:01:48,530 --> 00:01:55,220
program so the link time optimization is

00:01:52,520 --> 00:01:58,930
something which is being introduced

00:01:55,220 --> 00:02:01,729
since 80s and it means that you compile

00:01:58,930 --> 00:02:03,770
the source files into the object files

00:02:01,729 --> 00:02:05,600
but this time the object file is not

00:02:03,770 --> 00:02:07,520
containing the final assembly but it

00:02:05,600 --> 00:02:08,810
contains intermediate language so that's

00:02:07,520 --> 00:02:11,750
what the IRS stands for

00:02:08,810 --> 00:02:13,670
and then you know this type of fake

00:02:11,750 --> 00:02:15,319
object files no there are no longer area

00:02:13,670 --> 00:02:16,940
object files they are put into the

00:02:15,319 --> 00:02:18,260
linker and owning car doesn't know what

00:02:16,940 --> 00:02:21,020
to do visit because it doesn't

00:02:18,260 --> 00:02:23,930
understand them so that's why there is a

00:02:21,020 --> 00:02:26,900
linker plug-in so the OTO plug-in and

00:02:23,930 --> 00:02:29,720
LTO plug-in tells the linker that the

00:02:26,900 --> 00:02:32,060
object files are actually used by by the

00:02:29,720 --> 00:02:33,739
compiler and it dispatches back to the

00:02:32,060 --> 00:02:36,500
compiler which is the link time compiler

00:02:33,739 --> 00:02:40,190
and the link time compiler takes all the

00:02:36,500 --> 00:02:41,900
object files at once and it produces the

00:02:40,190 --> 00:02:44,540
final binary which is fed back to the

00:02:41,900 --> 00:02:48,200
linker learning curve returns say that

00:02:44,540 --> 00:02:50,870
did all the job fat itself so this is

00:02:48,200 --> 00:02:53,600
this is the basic scheme and you can see

00:02:50,870 --> 00:02:56,360
that the LTO is kind of a change into

00:02:53,600 --> 00:02:58,220
the wall to chain it's not only changing

00:02:56,360 --> 00:03:00,950
the compiler but we need to change also

00:02:58,220 --> 00:03:02,660
the linker and the Hara and all the

00:03:00,950 --> 00:03:04,670
other tools which are holding key object

00:03:02,660 --> 00:03:07,370
files because all of them has to

00:03:04,670 --> 00:03:09,530
understand that from now on the object

00:03:07,370 --> 00:03:12,170
files can be the real object files but

00:03:09,530 --> 00:03:16,070
they also can be the fake fake object

00:03:12,170 --> 00:03:18,980
files and why we would we do this you

00:03:16,070 --> 00:03:22,430
know it's sort of work and the basically

00:03:18,980 --> 00:03:25,100
the reason why we do that is to get to

00:03:22,430 --> 00:03:27,530
get a better code quality so if you have

00:03:25,100 --> 00:03:28,850
the link time optimizer you know much

00:03:27,530 --> 00:03:31,100
more than you know on the compile time

00:03:28,850 --> 00:03:33,709
so the first important thing is that the

00:03:31,100 --> 00:03:37,850
linker tells you which objects which

00:03:33,709 --> 00:03:39,739
symbols are used only by by the code you

00:03:37,850 --> 00:03:42,890
see and these symbols are used by shared

00:03:39,739 --> 00:03:45,530
libraries or bonded somehow externally

00:03:42,890 --> 00:03:47,150
so basically you can optimize a lot more

00:03:45,530 --> 00:03:49,400
because you can somehow pretend that

00:03:47,150 --> 00:03:52,579
most of the functions in the program are

00:03:49,400 --> 00:03:54,170
static and you can change them and also

00:03:52,579 --> 00:03:56,269
you can do the cross modal inlining

00:03:54,170 --> 00:03:57,829
which is good because normally you have

00:03:56,269 --> 00:04:00,230
to put lot of code into your headdress

00:03:57,829 --> 00:04:03,859
that makes the program's more ugly to

00:04:00,230 --> 00:04:05,480
read and longer to compile and this way

00:04:03,859 --> 00:04:09,709
you can do it sample transparently

00:04:05,480 --> 00:04:11,420
behind the user's back and also the

00:04:09,709 --> 00:04:13,400
other issue block code removal is quite

00:04:11,420 --> 00:04:15,260
important because if you see the whole

00:04:13,400 --> 00:04:17,030
program you see that not everything is

00:04:15,260 --> 00:04:19,070
being used

00:04:17,030 --> 00:04:21,560
and there are some other more things

00:04:19,070 --> 00:04:23,450
like the exception handling optimization

00:04:21,560 --> 00:04:25,100
which means that you can show in C++

00:04:23,450 --> 00:04:27,590
programs that lot of functions are not

00:04:25,100 --> 00:04:29,750
drawing and you can remove lot of

00:04:27,590 --> 00:04:32,480
exception handling information and

00:04:29,750 --> 00:04:34,580
cleanups and you can also for the

00:04:32,480 --> 00:04:36,919
identical code and you can optimize for

00:04:34,580 --> 00:04:39,020
the code layout so this is the basic

00:04:36,919 --> 00:04:42,110
list of the optimizations which you can

00:04:39,020 --> 00:04:44,720
do and there are also problems so one of

00:04:42,110 --> 00:04:46,760
the problem is that you need to change

00:04:44,720 --> 00:04:48,500
the world to change the other way

00:04:46,760 --> 00:04:50,510
problem is that the compiler so much

00:04:48,500 --> 00:04:52,970
slower than linkers because they do much

00:04:50,510 --> 00:04:54,440
more work and each time you change a

00:04:52,970 --> 00:04:56,330
single file you know you have to do all

00:04:54,440 --> 00:04:58,730
the complex work again which takes a lot

00:04:56,330 --> 00:05:00,620
of time and the next thing which is

00:04:58,730 --> 00:05:02,840
problem especially for us is that the

00:05:00,620 --> 00:05:04,400
back reports becomes harder because if

00:05:02,840 --> 00:05:06,410
your program doesn't work you cannot

00:05:04,400 --> 00:05:08,360
just take the single object file and a

00:05:06,410 --> 00:05:10,520
source code and send it to the Bugzilla

00:05:08,360 --> 00:05:13,160
you know basically that the back reports

00:05:10,520 --> 00:05:14,570
like linux kernel is broken if i compare

00:05:13,160 --> 00:05:16,790
this version with this version of GCC

00:05:14,570 --> 00:05:20,330
and i don't know how to reduce it for

00:05:16,790 --> 00:05:23,780
this so this is quite a how and it's

00:05:20,330 --> 00:05:25,700
it's an important problem and also it's

00:05:23,780 --> 00:05:28,850
not completely transparent to the user

00:05:25,700 --> 00:05:30,740
so most of the time you can add LTO into

00:05:28,850 --> 00:05:33,220
your command line and you get an LTO and

00:05:30,740 --> 00:05:35,360
it works but it doesn't work in complex

00:05:33,220 --> 00:05:36,740
scenarios like if you do the linux

00:05:35,360 --> 00:05:40,600
kernel you know you need to do some

00:05:36,740 --> 00:05:44,900
extra work to actually get a co-working

00:05:40,600 --> 00:05:48,169
so this is the quick review of about LT

00:05:44,900 --> 00:05:51,650
OS and i will speak a little bit more

00:05:48,169 --> 00:05:53,960
about how GCC has became the length of

00:05:51,650 --> 00:05:56,180
optimizing compiler so there is actually

00:05:53,960 --> 00:05:58,640
quite a long history of the audio work

00:05:56,180 --> 00:06:01,520
the audio work started in 90s and

00:05:58,640 --> 00:06:03,770
basically in 90s the GCC was a compiler

00:06:01,520 --> 00:06:05,960
which was organized in the way that it

00:06:03,770 --> 00:06:07,280
was compiling every statement from the

00:06:05,960 --> 00:06:09,620
source code into the intermediate

00:06:07,280 --> 00:06:11,330
language and then as soon as possible it

00:06:09,620 --> 00:06:13,700
was producing the assembly which was

00:06:11,330 --> 00:06:15,200
necessary and this because in 80s there

00:06:13,700 --> 00:06:17,270
was not enough memory to alter the

00:06:15,200 --> 00:06:20,350
program or even the single compilation

00:06:17,270 --> 00:06:20,350
unit in

00:06:20,389 --> 00:06:24,919
memory so at that time it makes sense

00:06:23,360 --> 00:06:27,680
but it didn't make sense at the back of

00:06:24,919 --> 00:06:29,979
90s so from then you know we started to

00:06:27,680 --> 00:06:32,990
work on the high level optimizations so

00:06:29,979 --> 00:06:34,639
it was done by different companies like

00:06:32,990 --> 00:06:37,310
the new in line there was contributed by

00:06:34,639 --> 00:06:39,469
coarser a the unit at the time I

00:06:37,310 --> 00:06:41,389
remember it was done by Suzy because I

00:06:39,469 --> 00:06:44,389
started it I think on the first open

00:06:41,389 --> 00:06:48,349
source conference because I was bored so

00:06:44,389 --> 00:06:50,090
during the talks and there was a new

00:06:48,349 --> 00:06:53,689
high level optimization framework which

00:06:50,090 --> 00:06:56,629
is which was started in 2005 and at the

00:06:53,689 --> 00:06:59,270
in 2010 it was basically done so the

00:06:56,629 --> 00:07:01,099
basic LTO framework was on the on the

00:06:59,270 --> 00:07:05,479
place and it was able to compile some

00:07:01,099 --> 00:07:08,479
programs but it was slow and that was

00:07:05,479 --> 00:07:12,650
soft in 2011 by adding paralyzation

00:07:08,479 --> 00:07:14,750
model for for allottee also since 2011

00:07:12,650 --> 00:07:17,060
we are basically able to build Firefox

00:07:14,750 --> 00:07:18,710
in the reasonable time like on my

00:07:17,060 --> 00:07:21,949
machine it's about six minutes of

00:07:18,710 --> 00:07:24,800
linking time and I don't know six or

00:07:21,949 --> 00:07:27,589
seven gigs of memory which is a lot but

00:07:24,800 --> 00:07:29,990
it's also not that much you need 10 gigs

00:07:27,589 --> 00:07:34,250
of memory to build Firefox in my setup

00:07:29,990 --> 00:07:36,319
anyway so how that works you know so

00:07:34,250 --> 00:07:39,229
this is the this is the traditional link

00:07:36,319 --> 00:07:41,060
time optimization model and the main

00:07:39,229 --> 00:07:42,830
problem is that most of the work is done

00:07:41,060 --> 00:07:44,779
in the link time compiler the link time

00:07:42,830 --> 00:07:46,789
compiler can take lot of time you know

00:07:44,779 --> 00:07:49,939
on Firefox on my machine it takes about

00:07:46,789 --> 00:07:50,810
40 minutes to to finish his job which is

00:07:49,939 --> 00:07:55,719
very boring

00:07:50,810 --> 00:07:58,610
so what GCC does is that it's actually

00:07:55,719 --> 00:08:00,710
adding a world program analysis pass

00:07:58,610 --> 00:08:03,469
which is the only only part which is

00:08:00,710 --> 00:08:05,960
done in in serial and once we are done

00:08:03,469 --> 00:08:07,909
with the whole program analysis we are

00:08:05,960 --> 00:08:09,560
splitting up the program again into

00:08:07,909 --> 00:08:11,719
partitions and every partition is

00:08:09,560 --> 00:08:13,219
compiled independently so the completion

00:08:11,719 --> 00:08:16,009
times are much faster because we are

00:08:13,219 --> 00:08:17,839
able to use multiple CPUs and

00:08:16,009 --> 00:08:20,150
theoretically we are I saw able to

00:08:17,839 --> 00:08:23,629
distribute the world but we don't do

00:08:20,150 --> 00:08:25,879
that at the moment so this is slightly

00:08:23,629 --> 00:08:29,160
more complicated setup but it gets you

00:08:25,879 --> 00:08:35,520
pretty much all the benefits of LTO

00:08:29,160 --> 00:08:38,580
at at more reasonable cost so this is

00:08:35,520 --> 00:08:40,169
how the story continues so since 2012 we

00:08:38,580 --> 00:08:43,979
have the framework which is able to

00:08:40,169 --> 00:08:46,860
compile a big programs but it still

00:08:43,979 --> 00:08:48,510
needed a lot of work and basically the

00:08:46,860 --> 00:08:51,230
reason when I'm speaking here today is

00:08:48,510 --> 00:08:54,630
that in 2018 you know which is this year

00:08:51,230 --> 00:08:57,000
we finished the debugging first so you

00:08:54,630 --> 00:08:59,670
know you can finally debug the output of

00:08:57,000 --> 00:09:01,290
the LTL compiler in a reasonable quality

00:08:59,670 --> 00:09:03,810
so it's kind of comparable to the

00:09:01,290 --> 00:09:06,840
experience of debugging optimized code

00:09:03,810 --> 00:09:10,980
result LTO which is kind of important if

00:09:06,840 --> 00:09:14,580
you want to declare the compiler to be

00:09:10,980 --> 00:09:22,620
production already so it was 18 years of

00:09:14,580 --> 00:09:25,350
work and and I will show you how how

00:09:22,620 --> 00:09:27,510
that ties back so this is the kind of

00:09:25,350 --> 00:09:30,480
basic overview how GCC works

00:09:27,510 --> 00:09:32,790
no TCC has containing the parser and

00:09:30,480 --> 00:09:35,160
then it contain a lot of optimization

00:09:32,790 --> 00:09:37,560
passes there was 300 of them so I wasn't

00:09:35,160 --> 00:09:41,280
able to fit all of them on the slide but

00:09:37,560 --> 00:09:44,250
I did fit a good part of it and this is

00:09:41,280 --> 00:09:46,560
this is the split of the GCC compilation

00:09:44,250 --> 00:09:49,110
process so the first bar you know the

00:09:46,560 --> 00:09:52,470
right green one that happens on the

00:09:49,110 --> 00:09:54,240
other compile time so that's relatively

00:09:52,470 --> 00:09:57,510
cheap because each time you change the

00:09:54,240 --> 00:10:00,360
single file you you don't need to redo

00:09:57,510 --> 00:10:03,240
all the parsing and optimization of the

00:10:00,360 --> 00:10:04,890
all other source files and also you can

00:10:03,240 --> 00:10:09,420
do it in parallel you know usually we

00:10:04,890 --> 00:10:11,190
built with the parallel mic and one of

00:10:09,420 --> 00:10:14,010
the design goals was to put as many

00:10:11,190 --> 00:10:16,860
optimization as as you can into this

00:10:14,010 --> 00:10:18,930
early pass so there is a kind of a set

00:10:16,860 --> 00:10:20,430
of the early optimizations which is

00:10:18,930 --> 00:10:22,560
doing the things which are kind of

00:10:20,430 --> 00:10:24,810
obvious or simple so it's kind of close

00:10:22,560 --> 00:10:28,230
to what you do when you have a high

00:10:24,810 --> 00:10:29,760
quality JIT compiler like in Firefox so

00:10:28,230 --> 00:10:33,870
we do inline Inc we do constant

00:10:29,760 --> 00:10:36,330
propagation we do all this kind of

00:10:33,870 --> 00:10:38,339
standard standard optimizations which

00:10:36,330 --> 00:10:39,740
are ven-ven you know they don't get the

00:10:38,339 --> 00:10:42,770
code to be worse

00:10:39,740 --> 00:10:46,460
and at the end of this we we stream out

00:10:42,770 --> 00:10:49,670
the object files and whence the linker

00:10:46,460 --> 00:10:51,230
calls us back by the linker plugin and

00:10:49,670 --> 00:10:54,170
we start with the serial part which is

00:10:51,230 --> 00:10:56,600
the orange one and we read all the

00:10:54,170 --> 00:10:58,460
program advanced into the memory but we

00:10:56,600 --> 00:11:00,680
don't read everything we read only kind

00:10:58,460 --> 00:11:03,050
of summaries of what we have written on

00:11:00,680 --> 00:11:05,360
the compile time and all these summaries

00:11:03,050 --> 00:11:08,150
we perform the interprocedural

00:11:05,360 --> 00:11:11,650
optimizations so we do the difficult

00:11:08,150 --> 00:11:15,380
decisions like where to inline or how to

00:11:11,650 --> 00:11:16,850
how to clone the functions and we don't

00:11:15,380 --> 00:11:19,040
do the actual work we only made the

00:11:16,850 --> 00:11:20,870
decisions and we partition the program

00:11:19,040 --> 00:11:23,540
we stream stream it out which is here

00:11:20,870 --> 00:11:25,970
and then then the computation part

00:11:23,540 --> 00:11:28,370
happens which is pereira again this is

00:11:25,970 --> 00:11:30,230
very most of the busy works so there are

00:11:28,370 --> 00:11:35,450
kind of all the high level optimizations

00:11:30,230 --> 00:11:37,280
of loop optimizations and all the kind

00:11:35,450 --> 00:11:39,950
of more difficult optimizations which

00:11:37,280 --> 00:11:41,540
doesn't need to necessarily win and we

00:11:39,950 --> 00:11:44,600
also have to redo most of the early

00:11:41,540 --> 00:11:46,940
optimizations because the program has

00:11:44,600 --> 00:11:48,440
changed by inlining but the purpose of

00:11:46,940 --> 00:11:50,150
the early optimization says that the

00:11:48,440 --> 00:11:53,960
program gets votes more it is also

00:11:50,150 --> 00:11:55,790
easier to optimize so the study our part

00:11:53,960 --> 00:11:57,650
you know the orange part sees the

00:11:55,790 --> 00:11:59,780
program in the more elastic light and it

00:11:57,650 --> 00:12:02,360
would if if the optimization didn't

00:11:59,780 --> 00:12:03,500
happen sorry the traditional link time

00:12:02,360 --> 00:12:06,070
optimizers you know the other

00:12:03,500 --> 00:12:08,570
optimizations doesn't need to exist and

00:12:06,070 --> 00:12:10,730
usually every sip is done in the serial

00:12:08,570 --> 00:12:12,680
part so the difference in the GCC the

00:12:10,730 --> 00:12:15,700
traditional model is is this additional

00:12:12,680 --> 00:12:21,020
additional spreads of the compilation

00:12:15,700 --> 00:12:22,670
compilation process ok so I would like

00:12:21,020 --> 00:12:25,280
to speak a little bit about how that

00:12:22,670 --> 00:12:27,460
pays back in the performance let's see

00:12:25,280 --> 00:12:32,000
how I will do at the time so this is

00:12:27,460 --> 00:12:33,710
this is spec benchmark suite which is

00:12:32,000 --> 00:12:35,870
kind of the standard right how you tell

00:12:33,710 --> 00:12:37,520
the compiler performance so every

00:12:35,870 --> 00:12:40,010
compiled developer knows what the spec

00:12:37,520 --> 00:12:41,540
is there is a big committee choosing the

00:12:40,010 --> 00:12:43,640
benchmarks for it and the benchmark are

00:12:41,540 --> 00:12:46,600
supposed to be some representative for

00:12:43,640 --> 00:12:49,600
for the system performance

00:12:46,600 --> 00:12:53,079
and the bars the zero means the same

00:12:49,600 --> 00:12:55,120
performance as GCC six and the number

00:12:53,079 --> 00:12:57,550
seven percent no the speed-up so the

00:12:55,120 --> 00:12:59,529
bigger is better so it's not completely

00:12:57,550 --> 00:13:01,569
honest because I should have stopped it

00:12:59,529 --> 00:13:03,399
on zero and make that hundred-percent

00:13:01,569 --> 00:13:05,019
but then it would see nothing on the

00:13:03,399 --> 00:13:06,940
bars because I wouldn't be able to show

00:13:05,019 --> 00:13:10,389
there's a 1.5 percent difference in the

00:13:06,940 --> 00:13:11,459
performance so so mind that the bars are

00:13:10,389 --> 00:13:14,680
not very realistic

00:13:11,459 --> 00:13:17,019
you know if they go up but they know the

00:13:14,680 --> 00:13:19,149
performance doesn't go up that much so

00:13:17,019 --> 00:13:20,860
the first part of story is that you know

00:13:19,149 --> 00:13:23,440
if you want to get your program faster

00:13:20,860 --> 00:13:25,990
you might try to update the compiler and

00:13:23,440 --> 00:13:28,360
we do get a battery over at the time but

00:13:25,990 --> 00:13:30,490
the progress is relatively small because

00:13:28,360 --> 00:13:33,220
we are optimizing for the similar set of

00:13:30,490 --> 00:13:35,230
benchmarks for 20 years and we couldn't

00:13:33,220 --> 00:13:36,639
optimize for fifteen percent every year

00:13:35,230 --> 00:13:39,940
because the programs would be too fast

00:13:36,639 --> 00:13:42,160
and so and there is a green as the is a

00:13:39,940 --> 00:13:44,380
generic tuning and the orange is a

00:13:42,160 --> 00:13:46,630
tuning for a specific CPU which in this

00:13:44,380 --> 00:13:49,060
case was the Rison so you can see that

00:13:46,630 --> 00:13:50,620
the CPU tuning has improved because the

00:13:49,060 --> 00:13:52,350
rice and got into the market but the

00:13:50,620 --> 00:13:55,660
generic tuna didn't improve that much

00:13:52,350 --> 00:13:57,399
okay so this is the other thing you can

00:13:55,660 --> 00:13:59,769
do you know you can decide that you will

00:13:57,399 --> 00:14:01,630
use the most aggressive optimization so

00:13:59,769 --> 00:14:05,620
we have the O fast option which allows

00:14:01,630 --> 00:14:08,439
GCC to gather the bigger code but it

00:14:05,620 --> 00:14:10,029
also allows GCC to produce some

00:14:08,439 --> 00:14:12,550
operations which are not completely

00:14:10,029 --> 00:14:14,259
correct like assume that all the numbers

00:14:12,550 --> 00:14:17,139
are numbers in floating point and not

00:14:14,259 --> 00:14:20,290
own numbers and here you know you can

00:14:17,139 --> 00:14:24,339
see that we used to improve by about 2%

00:14:20,290 --> 00:14:26,079
over the over the base line which means

00:14:24,339 --> 00:14:27,639
that you know the batch park is really

00:14:26,079 --> 00:14:29,170
hard to optimize it's supposed to be

00:14:27,639 --> 00:14:31,899
kind of system which mark is memory

00:14:29,170 --> 00:14:34,899
bound but we have improved a lot more in

00:14:31,899 --> 00:14:36,279
the GCC eight but if you look on the on

00:14:34,899 --> 00:14:38,500
the distribution of the single

00:14:36,279 --> 00:14:41,560
benchmarks there is only one benchmark

00:14:38,500 --> 00:14:43,920
which improves a lot and that's a

00:14:41,560 --> 00:14:47,230
benchmark which is called hammer ax and

00:14:43,920 --> 00:14:49,300
it's it's optimized by very Singh it's a

00:14:47,230 --> 00:14:52,180
very basic trick of interchanging two

00:14:49,300 --> 00:14:53,920
loops so sometimes you know you can see

00:14:52,180 --> 00:14:55,860
the big jump that is coming from only a

00:14:53,920 --> 00:14:57,030
single benchmark

00:14:55,860 --> 00:14:59,420
which which is somehow not

00:14:57,030 --> 00:15:02,220
representative in the geometric average

00:14:59,420 --> 00:15:05,700
okay so this is what you can expect from

00:15:02,220 --> 00:15:08,040
from the from changing or compilation

00:15:05,700 --> 00:15:09,840
flights you can also say that maybe you

00:15:08,040 --> 00:15:12,060
know GCC is to alternate you can use

00:15:09,840 --> 00:15:15,180
different compiler so this is a clonk

00:15:12,060 --> 00:15:17,550
and an ICC now it's not completely fair

00:15:15,180 --> 00:15:19,530
to ICC because ICC doesn't tuned for

00:15:17,550 --> 00:15:21,870
them but you can see that the CPU

00:15:19,530 --> 00:15:24,710
turning is pretty small so it's a I

00:15:21,870 --> 00:15:27,330
think it's a representative enough and

00:15:24,710 --> 00:15:30,600
again you know you can see you know how

00:15:27,330 --> 00:15:32,370
how it compares to the GCC eight so

00:15:30,600 --> 00:15:35,370
basically you can see that most of the

00:15:32,370 --> 00:15:36,600
bars are coming below zero so GCC is

00:15:35,370 --> 00:15:39,090
actually doing pretty well you know

00:15:36,600 --> 00:15:42,510
compared to the ICC benchmark as well

00:15:39,090 --> 00:15:44,850
which is which is quite good because ICC

00:15:42,510 --> 00:15:47,610
is is a you know one of the reasons for

00:15:44,850 --> 00:15:53,010
ICC to exist is to get the spec numbers

00:15:47,610 --> 00:15:56,700
to be good okay so now you can try now

00:15:53,010 --> 00:15:59,340
you can try the OTO and here you can see

00:15:56,700 --> 00:16:01,470
that the lto is adding something like to

00:15:59,340 --> 00:16:03,330
accept percent of the performance so

00:16:01,470 --> 00:16:06,410
it's basically the same as switching go

00:16:03,330 --> 00:16:09,930
faster on the on the other compilers and

00:16:06,410 --> 00:16:13,160
that's coming without visual sacrificing

00:16:09,930 --> 00:16:17,040
the code size and result without

00:16:13,160 --> 00:16:18,810
sacrificing the precision and just to

00:16:17,040 --> 00:16:20,610
show how that works for other components

00:16:18,810 --> 00:16:23,220
you know like this is how the LTO

00:16:20,610 --> 00:16:26,340
compares to no LTO so you can see is

00:16:23,220 --> 00:16:27,780
fairly fairly distributed so you can

00:16:26,340 --> 00:16:33,540
expect that your average programmer

00:16:27,780 --> 00:16:37,340
speed up a bit and overall by something

00:16:33,540 --> 00:16:39,990
like one and half percent and this is

00:16:37,340 --> 00:16:42,390
what you can expect from the other

00:16:39,990 --> 00:16:44,760
compilers so the crank is also getting

00:16:42,390 --> 00:16:48,570
some benefits from the LTO which is

00:16:44,760 --> 00:16:51,050
comparable to GCC LTO compared to its

00:16:48,570 --> 00:16:55,050
baseline and icc is getting a lot more

00:16:51,050 --> 00:16:57,720
the reason is that the ICC has really a

00:16:55,050 --> 00:17:00,480
big team working on specific

00:16:57,720 --> 00:17:03,389
optimizations for

00:17:00,480 --> 00:17:05,459
for this specific benchmark so we know

00:17:03,389 --> 00:17:06,780
some of these some of these

00:17:05,459 --> 00:17:09,419
optimizations where they're coming from

00:17:06,780 --> 00:17:10,770
I like in the hammer ax what they do is

00:17:09,419 --> 00:17:12,809
that they change the memory

00:17:10,770 --> 00:17:14,390
representation of the matrix so instead

00:17:12,809 --> 00:17:16,829
of exchanging the loops you change

00:17:14,390 --> 00:17:18,630
change the memory representation which

00:17:16,829 --> 00:17:21,439
is something which ECC simply doesn't go

00:17:18,630 --> 00:17:24,419
because it's somehow considered to be

00:17:21,439 --> 00:17:26,579
specific to the benchmarking tricks you

00:17:24,419 --> 00:17:29,100
know we don't really know if we can do

00:17:26,579 --> 00:17:31,580
it in the way it would be it would be

00:17:29,100 --> 00:17:36,690
reasonable for for real-world programs

00:17:31,580 --> 00:17:39,120
so but but the conclusion definitely is

00:17:36,690 --> 00:17:41,700
that while we don't have much space to

00:17:39,120 --> 00:17:43,590
grow for for the perfect compression

00:17:41,700 --> 00:17:45,660
project because we are pretty much on

00:17:43,590 --> 00:17:48,840
the state-of-the-art no there is there

00:17:45,660 --> 00:17:53,970
is no space to grow for for ATO

00:17:48,840 --> 00:17:56,460
compilation ok so this is another thing

00:17:53,970 --> 00:17:57,990
which you can do to help to help your

00:17:56,460 --> 00:18:00,360
performance and that's to use the

00:17:57,990 --> 00:18:02,100
profile feedback so I'm not sure how

00:18:00,360 --> 00:18:05,100
many of you knows what profile feedback

00:18:02,100 --> 00:18:07,500
is but basically you can use the option

00:18:05,100 --> 00:18:09,630
profile generate to GCC and then you can

00:18:07,500 --> 00:18:11,450
run your application and then she sees

00:18:09,630 --> 00:18:14,990
you can use the data which are collected

00:18:11,450 --> 00:18:17,910
to optimize application better and

00:18:14,990 --> 00:18:20,040
profile feedback is kind of orthogonal

00:18:17,910 --> 00:18:22,559
to LTL because in LTL we know the

00:18:20,040 --> 00:18:23,940
comparator sort of options of to do but

00:18:22,559 --> 00:18:25,380
it doesn't know what to do because it

00:18:23,940 --> 00:18:27,570
doesn't understand the program very well

00:18:25,380 --> 00:18:29,010
if you have the profile feedback you

00:18:27,570 --> 00:18:30,270
know the profile feedback tells you you

00:18:29,010 --> 00:18:31,890
know which parts of the program are

00:18:30,270 --> 00:18:34,380
important you know how many times the

00:18:31,890 --> 00:18:37,049
website rating which functions to inline

00:18:34,380 --> 00:18:39,510
so together you can get pretty big speed

00:18:37,049 --> 00:18:41,100
ups and the speed ups can be pretty real

00:18:39,510 --> 00:18:43,410
you know like if you look on the peril

00:18:41,100 --> 00:18:48,120
benchmark which is better of course you

00:18:43,410 --> 00:18:50,940
can get something between 17 to 27 23

00:18:48,120 --> 00:18:53,220
percent improvement which is noticeable

00:18:50,940 --> 00:18:56,160
in GCC you get something like 7 percent

00:18:53,220 --> 00:18:58,500
improvement so that really translates to

00:18:56,160 --> 00:19:01,020
numbers which which relatively matters

00:18:58,500 --> 00:19:03,750
and you can see that you know the OT UNF

00:19:01,020 --> 00:19:05,520
do together is getting something like 7

00:19:03,750 --> 00:19:08,730
percent improvement overall which is

00:19:05,520 --> 00:19:11,970
pretty much compared to the Suffolk like

00:19:08,730 --> 00:19:12,260
know one point for how five percent or

00:19:11,970 --> 00:19:14,840
two

00:19:12,260 --> 00:19:16,510
and for healthier fgo alone so if you

00:19:14,840 --> 00:19:19,670
compare these two optimizations together

00:19:16,510 --> 00:19:24,440
you get much better result than than if

00:19:19,670 --> 00:19:26,420
you do just one alone this is a quicker

00:19:24,440 --> 00:19:28,700
slide on the code size so you can see

00:19:26,420 --> 00:19:30,410
that in GCC you know the OTO is actually

00:19:28,700 --> 00:19:31,700
decreasing the code size which is one of

00:19:30,410 --> 00:19:33,560
the goals you know if you want to build

00:19:31,700 --> 00:19:36,080
your system you want to make the system

00:19:33,560 --> 00:19:38,950
small or bigger that's different with

00:19:36,080 --> 00:19:41,240
ICC or client you know the audio is

00:19:38,950 --> 00:19:43,460
increasing the code size because maybe

00:19:41,240 --> 00:19:45,650
it's not tuned for this for this goal

00:19:43,460 --> 00:19:47,510
and also you can see that the profile

00:19:45,650 --> 00:19:53,540
feedback is getting the binary slightly

00:19:47,510 --> 00:19:56,060
smaller than then without so this is you

00:19:53,540 --> 00:19:58,850
know how things looks like on the on the

00:19:56,060 --> 00:20:00,380
benchmarks if you if you look you know I

00:19:58,850 --> 00:20:02,240
will skip this one because I don't have

00:20:00,380 --> 00:20:04,220
time but if you look on the real

00:20:02,240 --> 00:20:06,050
programs the situations are different

00:20:04,220 --> 00:20:07,490
because the real programs are much

00:20:06,050 --> 00:20:10,730
bigger than benchmarks you know the

00:20:07,490 --> 00:20:12,740
Firefox is a lot bigger than the biggest

00:20:10,730 --> 00:20:15,170
program in in the spec test suite

00:20:12,740 --> 00:20:17,090
because a CCC inspector so it is quite

00:20:15,170 --> 00:20:20,180
big but it's also it's the relatively

00:20:17,090 --> 00:20:22,370
small and these numbers was collected by

00:20:20,180 --> 00:20:24,350
the Firefox people because they try to

00:20:22,370 --> 00:20:25,910
the LTO in their official benchmarking

00:20:24,350 --> 00:20:28,280
server they have pretty cool

00:20:25,910 --> 00:20:31,130
benchmarking architecture and you can

00:20:28,280 --> 00:20:33,740
see that they measured that you can

00:20:31,130 --> 00:20:38,030
improve responsive responsiveness of the

00:20:33,740 --> 00:20:41,300
patron during by almost 20% or 30% with

00:20:38,030 --> 00:20:42,920
with without the profile feedback and

00:20:41,300 --> 00:20:44,450
also some of the other important

00:20:42,920 --> 00:20:45,050
benchmarks improves noticeably like

00:20:44,450 --> 00:20:47,510
dromio

00:20:45,050 --> 00:20:49,460
is a is a JavaScript benchmark which it

00:20:47,510 --> 00:20:52,730
was tuned for by them for a long time

00:20:49,460 --> 00:20:55,160
and that paint is a top painting there

00:20:52,730 --> 00:20:56,810
is a start up time on the very end so a

00:20:55,160 --> 00:21:01,010
lot of very overt benchmarks are

00:20:56,810 --> 00:21:03,110
improving by by this optimization and I

00:21:01,010 --> 00:21:05,510
like you know they have this way of of

00:21:03,110 --> 00:21:08,530
testing the performance so the orange is

00:21:05,510 --> 00:21:12,320
the bench baseline of the firefox and

00:21:08,530 --> 00:21:15,930
the violet or I don't know Bruder

00:21:12,320 --> 00:21:17,730
theorem guy so the blue dots are

00:21:15,930 --> 00:21:19,770
the various experiments you know it

00:21:17,730 --> 00:21:22,080
someone has tried to do a benchmark and

00:21:19,770 --> 00:21:24,750
here you know you can see the the bench

00:21:22,080 --> 00:21:26,550
part for an eyeblink LTO so basically in

00:21:24,750 --> 00:21:30,780
in one year over the Firefox development

00:21:26,550 --> 00:21:33,210
is this was the most most successful

00:21:30,780 --> 00:21:35,190
performance improvement they tried but

00:21:33,210 --> 00:21:37,440
they are still not brave enough to

00:21:35,190 --> 00:21:40,500
enable it by default which we will do

00:21:37,440 --> 00:21:42,720
hopefully and this is you know that's

00:21:40,500 --> 00:21:45,210
also kind of interesting to me you know

00:21:42,720 --> 00:21:47,580
that's the responsiveness test so you

00:21:45,210 --> 00:21:49,200
can see it's much more noisy and if you

00:21:47,580 --> 00:21:50,580
see the history you can see that the

00:21:49,200 --> 00:21:52,290
improvement is pretty good you know at

00:21:50,580 --> 00:21:55,170
the time so they're not going down it's

00:21:52,290 --> 00:21:58,170
better than so it's just this bar going

00:21:55,170 --> 00:21:59,790
down is better than going up but in the

00:21:58,170 --> 00:22:02,010
in the big scale you know they was able

00:21:59,790 --> 00:22:06,390
to get get a similar improvements

00:22:02,010 --> 00:22:09,690
otherwise okay and this is just to

00:22:06,390 --> 00:22:11,309
quickly summarize in our code size so

00:22:09,690 --> 00:22:13,020
you know of course that something which

00:22:11,309 --> 00:22:14,640
is not important for specs because the

00:22:13,020 --> 00:22:17,370
programs are relatively small but for

00:22:14,640 --> 00:22:18,929
Firefox it is so you can see that the

00:22:17,370 --> 00:22:21,120
binaries are slightly getting smaller

00:22:18,929 --> 00:22:23,640
you know over the GCC releases because

00:22:21,120 --> 00:22:25,440
we are looking into that and you can

00:22:23,640 --> 00:22:27,570
also see that the different optimization

00:22:25,440 --> 00:22:29,610
levels are making significantly

00:22:27,570 --> 00:22:33,210
different binaries so the O's 3 is very

00:22:29,610 --> 00:22:35,760
large you know and an OS is about the

00:22:33,210 --> 00:22:37,470
half of the code size of the O's 3 and

00:22:35,760 --> 00:22:39,059
you can see that the F do you know the

00:22:37,470 --> 00:22:40,770
profile feedback is making the binary

00:22:39,059 --> 00:22:42,450
significantly smaller because you know

00:22:40,770 --> 00:22:44,490
huge part of the Firefox is actually

00:22:42,450 --> 00:22:46,710
that it's not being tested by their

00:22:44,490 --> 00:22:50,550
preference so it's not optimized for a

00:22:46,710 --> 00:22:52,470
scroll speed and this is you know how it

00:22:50,550 --> 00:22:54,600
goes through the oto so the LTO gets

00:22:52,470 --> 00:22:56,700
really quite big improvements on the on

00:22:54,600 --> 00:22:59,340
the size and basically goes one step

00:22:56,700 --> 00:23:02,370
down so you know the Oh Steve it OTO is

00:22:59,340 --> 00:23:04,620
faster than then Oh Steve is on OTO but

00:23:02,370 --> 00:23:07,530
it's also smaller than Oh - so the

00:23:04,620 --> 00:23:09,990
binaries are really improving in the

00:23:07,530 --> 00:23:11,940
size and this is just to see you know

00:23:09,990 --> 00:23:15,450
how Crankworx so you know they have out

00:23:11,940 --> 00:23:17,160
- comparable to auro - but they're all

00:23:15,450 --> 00:23:20,160
three is smaller and the profile

00:23:17,160 --> 00:23:23,970
feedback is again not optimizing for

00:23:20,160 --> 00:23:25,930
size and the LTO is also not optimizing

00:23:23,970 --> 00:23:31,690
for size is the same story as

00:23:25,930 --> 00:23:35,440
for for specs so that's that's pretty

00:23:31,690 --> 00:23:37,570
much for the for the performance part so

00:23:35,440 --> 00:23:39,309
to summer it you know the LT all know

00:23:37,570 --> 00:23:41,500
works and it can build a big programs

00:23:39,309 --> 00:23:44,170
like Firefox action library office is

00:23:41,500 --> 00:23:45,970
built by default with LTO in the in the

00:23:44,170 --> 00:23:47,920
open suits now so that's why I'm

00:23:45,970 --> 00:23:49,330
projecting from Acrobat because I'm not

00:23:47,920 --> 00:23:54,550
sure it will not crash during that

00:23:49,330 --> 00:23:56,350
presentation and it's very I think I'd

00:23:54,550 --> 00:23:58,150
spread the successful size optimization

00:23:56,350 --> 00:24:01,150
because you can almost always see the

00:23:58,150 --> 00:24:02,650
size improvements and the performance

00:24:01,150 --> 00:24:04,330
improvement it really depends on the

00:24:02,650 --> 00:24:07,630
type of application if they matter to

00:24:04,330 --> 00:24:09,640
you or not but but often they also do

00:24:07,630 --> 00:24:12,370
and there's lot of space for the future

00:24:09,640 --> 00:24:14,440
improvements because you can improve GCC

00:24:12,370 --> 00:24:17,170
but you can also optimize applications

00:24:14,440 --> 00:24:20,350
for the audio so you know if we enable a

00:24:17,170 --> 00:24:23,110
slowly things well move to the overall

00:24:20,350 --> 00:24:26,200
better performance and that's the end of

00:24:23,110 --> 00:24:27,550
my part and Martine will tell you you

00:24:26,200 --> 00:24:36,540
know how that works without in sauce

00:24:27,550 --> 00:24:41,410
factory so I have couple slides about

00:24:36,540 --> 00:24:45,429
audio and factory what we did we

00:24:41,410 --> 00:24:48,630
basically took normal staging project we

00:24:45,429 --> 00:24:50,650
modified project conflict where we edit

00:24:48,630 --> 00:24:53,760
- FL tio2

00:24:50,650 --> 00:24:56,080
op flex now that recently we edit

00:24:53,760 --> 00:24:58,720
position and dependent execution by

00:24:56,080 --> 00:25:01,420
default in the distribution which means

00:24:58,720 --> 00:25:05,110
these options should be really used by

00:25:01,420 --> 00:25:06,700
every single package the number of

00:25:05,110 --> 00:25:11,190
failures is quite surprising

00:25:06,700 --> 00:25:16,150
it's only 80 packages of more than 2000

00:25:11,190 --> 00:25:21,250
the packages consists of all the KDE and

00:25:16,150 --> 00:25:25,660
Gnome and base system and to be able to

00:25:21,250 --> 00:25:29,170
test the staging project in open QA we

00:25:25,660 --> 00:25:32,440
had to basically disable OTO for

00:25:29,170 --> 00:25:35,410
packages which fail and then we are able

00:25:32,440 --> 00:25:38,010
to get distribution which is close to

00:25:35,410 --> 00:25:42,550
LTO distribution

00:25:38,010 --> 00:25:47,290
so next step was to boot the ISO image

00:25:42,550 --> 00:25:49,810
which we got in in KBM and I basically

00:25:47,290 --> 00:25:53,250
find all the elf executables and shared

00:25:49,810 --> 00:25:56,980
libraries which is close to 7,000 and

00:25:53,250 --> 00:26:03,070
the total size of these files reduced

00:25:56,980 --> 00:26:05,650
from almost two gigs by about 5% know

00:26:03,070 --> 00:26:08,110
that this is also including packages

00:26:05,650 --> 00:26:13,140
which were built without audio so the

00:26:08,110 --> 00:26:17,770
real number should be better I guess

00:26:13,140 --> 00:26:20,500
okay and I have couple of examples the

00:26:17,770 --> 00:26:23,350
first one is the main library of libera

00:26:20,500 --> 00:26:26,020
office which reduced by 16% which is

00:26:23,350 --> 00:26:32,440
quite significant and we have also

00:26:26,020 --> 00:26:35,290
examples of some MySQL binaries which

00:26:32,440 --> 00:26:38,350
reduced really significantly but it's

00:26:35,290 --> 00:26:44,590
due to usage of just the limited amount

00:26:38,350 --> 00:26:48,850
of code so we were able to boot it an

00:26:44,590 --> 00:26:52,450
open QA and it it was able to success

00:26:48,850 --> 00:26:56,260
the tests except some fall out which was

00:26:52,450 --> 00:27:00,010
quite small I guess and there are some

00:26:56,260 --> 00:27:01,900
issues the packages which failed felt

00:27:00,010 --> 00:27:07,540
for various reasons and I will go

00:27:01,900 --> 00:27:10,570
through the issues we've seen the first

00:27:07,540 --> 00:27:15,420
two are some limitations in GCC the

00:27:10,570 --> 00:27:18,340
first one was was a bailout when we

00:27:15,420 --> 00:27:21,400
basically rejected two symbols being

00:27:18,340 --> 00:27:24,040
defined in or being prevailing in two

00:27:21,400 --> 00:27:28,330
libraries which is a valid situation if

00:27:24,040 --> 00:27:30,520
you use no common option the second was

00:27:28,330 --> 00:27:32,890
a real miss compilation where he decided

00:27:30,520 --> 00:27:36,970
to merge two declarations of functions

00:27:32,890 --> 00:27:38,380
one was having attribute no return and

00:27:36,970 --> 00:27:42,700
the two declarations had the same

00:27:38,380 --> 00:27:45,910
assembly name so it was real issue the

00:27:42,700 --> 00:27:49,210
third one it's the reason why most of

00:27:45,910 --> 00:27:52,130
the shared libraries failed its

00:27:49,210 --> 00:27:55,400
it's a symbol of versioning for shared

00:27:52,130 --> 00:27:58,010
libraries where you can where you can

00:27:55,400 --> 00:28:01,040
have versions of interface of functions

00:27:58,010 --> 00:28:03,200
which you export and it allows you to

00:28:01,040 --> 00:28:05,210
run executable which is dynamic

00:28:03,200 --> 00:28:07,700
dynamically linked with a newer version

00:28:05,210 --> 00:28:10,040
of library but still using some old

00:28:07,700 --> 00:28:12,790
interface which is quite a nice feature

00:28:10,040 --> 00:28:21,260
but we will have to add a new function

00:28:12,790 --> 00:28:21,950
attribute for next GCC release yes that

00:28:21,260 --> 00:28:25,850
ik libraries

00:28:21,950 --> 00:28:29,150
so in general we should not ship static

00:28:25,850 --> 00:28:31,400
libraries in our packages there are

00:28:29,150 --> 00:28:34,130
obvious exceptions like some error

00:28:31,400 --> 00:28:38,600
recovery tools for file systems for

00:28:34,130 --> 00:28:41,870
instance and what we have to do we

00:28:38,600 --> 00:28:46,220
probably have to enable so-called F fat

00:28:41,870 --> 00:28:48,950
LTO objects which are object files which

00:28:46,220 --> 00:28:53,960
consists of both assembly language and

00:28:48,950 --> 00:28:55,850
LTO il and at the end of built of a

00:28:53,960 --> 00:28:59,570
package we basically have to strip all

00:28:55,850 --> 00:29:02,690
the LTO bytecode and we have to verify

00:28:59,570 --> 00:29:05,840
that we do not ship it what's good about

00:29:02,690 --> 00:29:07,610
it it's it's that even if you have a

00:29:05,840 --> 00:29:10,820
package which you want to be built

00:29:07,610 --> 00:29:13,520
vessel do and it's linked with a static

00:29:10,820 --> 00:29:16,690
library it's possible because OTO can

00:29:13,520 --> 00:29:24,410
transparently makes LTO

00:29:16,690 --> 00:29:27,110
objects and assembly objects so yeah we

00:29:24,410 --> 00:29:32,870
have some special audio warnings done by

00:29:27,110 --> 00:29:35,810
honza the first two examples this is

00:29:32,870 --> 00:29:38,690
this is issue the first one I look

00:29:35,810 --> 00:29:40,700
inside and it's it's issue where you

00:29:38,690 --> 00:29:42,890
have a structure being defined in a

00:29:40,700 --> 00:29:47,090
header file and it has conditional

00:29:42,890 --> 00:29:49,360
fields based on some macro and if you if

00:29:47,090 --> 00:29:51,830
you forget to include for instance

00:29:49,360 --> 00:29:54,890
conflict header file in a in a

00:29:51,830 --> 00:29:56,690
translation unit then you end up with is

00:29:54,890 --> 00:29:59,900
the two translation units having

00:29:56,690 --> 00:30:03,050
different layout of a structure which

00:29:59,900 --> 00:30:05,620
which can cause ya failures because of

00:30:03,050 --> 00:30:08,600
the size of is different and the binary

00:30:05,620 --> 00:30:12,200
yeah so the layout in memory is

00:30:08,600 --> 00:30:15,790
different Danny we have some legacy

00:30:12,200 --> 00:30:20,330
configure scripts which two gripping of

00:30:15,790 --> 00:30:23,780
object files which is not possible if

00:30:20,330 --> 00:30:25,670
you if you use LTO you have LD UIL and

00:30:23,780 --> 00:30:30,170
the object files you can grab for a

00:30:25,670 --> 00:30:34,010
format of floating point for instance so

00:30:30,170 --> 00:30:40,090
it's quite rare I would say then we have

00:30:34,010 --> 00:30:43,540
this tool DV is that DW that it it's

00:30:40,090 --> 00:30:47,410
it's a devourer of compression tool

00:30:43,540 --> 00:30:49,850
which is which is being developed by

00:30:47,410 --> 00:30:51,830
Jakob you reenact from Red Hat and it

00:30:49,850 --> 00:30:55,940
looks he's not have enough time to

00:30:51,830 --> 00:30:59,350
enhance it to fully support LTO so it's

00:30:55,940 --> 00:31:02,450
definitely what we need to work on and

00:30:59,350 --> 00:31:07,580
maybe we'll see some higher memory

00:31:02,450 --> 00:31:12,190
constraints for for a couple of packages

00:31:07,580 --> 00:31:16,130
like the office and etc you'll see and

00:31:12,190 --> 00:31:18,770
last issue I have it's it's quite

00:31:16,130 --> 00:31:22,400
similar to simple versioning it's usage

00:31:18,770 --> 00:31:24,320
of the block assembly assembly as you

00:31:22,400 --> 00:31:27,050
can see in the example there is a

00:31:24,320 --> 00:31:32,800
function being defined in assembly which

00:31:27,050 --> 00:31:35,090
is just string for GCC and the audio

00:31:32,800 --> 00:31:37,970
failure which you can see on the bottom

00:31:35,090 --> 00:31:42,290
is caused by a caller of the function is

00:31:37,970 --> 00:31:46,910
in a different translation unit in LTO

00:31:42,290 --> 00:31:50,090
so that it can't find a symbol it's

00:31:46,910 --> 00:31:54,040
quite easy to fix you basically at no

00:31:50,090 --> 00:31:56,770
LTO to the translation units which use

00:31:54,040 --> 00:31:59,770
this top-level

00:31:56,770 --> 00:31:59,770
symbols

00:32:00,130 --> 00:32:07,840
yeah this is last slide of the talk

00:32:03,130 --> 00:32:12,669
actually it presents histogram of text

00:32:07,840 --> 00:32:14,820
segments of packages and it basically

00:32:12,669 --> 00:32:19,380
tells the most of the packages are

00:32:14,820 --> 00:32:24,780
smaller and few of them are big bigger

00:32:19,380 --> 00:32:29,049
the biggest size improvement is seen on

00:32:24,780 --> 00:32:32,350
executables and the smaller is on shared

00:32:29,049 --> 00:32:40,570
libraries which provides quite some

00:32:32,350 --> 00:32:42,309
exported symbols and conclusion and so

00:32:40,570 --> 00:32:45,580
the conclusion of the talk is basically

00:32:42,309 --> 00:32:49,570
whether we want to have it in openSUSE

00:32:45,580 --> 00:32:52,809
factory being enabled by default we hope

00:32:49,570 --> 00:32:56,710
it's video Bell to you and Jesus major

00:32:52,809 --> 00:32:58,120
enough to do it and yeah as long as I'm

00:32:56,710 --> 00:33:01,299
as long as I mentioned we can be the

00:32:58,120 --> 00:33:05,890
first distribution which eventually will

00:33:01,299 --> 00:33:16,590
maybe one day appear in as well thank

00:33:05,890 --> 00:33:16,590
you do you have any questions

00:33:29,100 --> 00:33:34,780
so if you create the profile for your

00:33:31,960 --> 00:33:37,000
application for completion how probable

00:33:34,780 --> 00:33:41,410
is that it won't work when you start

00:33:37,000 --> 00:33:43,630
using newer version of GCC well at the

00:33:41,410 --> 00:33:45,820
moment the profile specific to the

00:33:43,630 --> 00:33:48,130
configuration and to the GCC so the idea

00:33:45,820 --> 00:33:51,970
is that we have to train it during the

00:33:48,130 --> 00:33:55,210
package belt and the way it works is

00:33:51,970 --> 00:33:57,100
that in many cases like in the Python or

00:33:55,210 --> 00:33:58,780
parallel you know we can simply run the

00:33:57,100 --> 00:34:00,520
test weight or do something like that so

00:33:58,780 --> 00:34:03,130
in the Firefox case it's slightly more

00:34:00,520 --> 00:34:05,680
challenging so what they do is that they

00:34:03,130 --> 00:34:07,840
simply start the far falls I cycle it

00:34:05,680 --> 00:34:10,330
through some pages and they have a they

00:34:07,840 --> 00:34:12,940
have a make file machinery for that so

00:34:10,330 --> 00:34:14,950
you need to open your web server which

00:34:12,940 --> 00:34:17,200
can be VNC so you don't need to really

00:34:14,950 --> 00:34:19,210
see it and it does the other sort of

00:34:17,200 --> 00:34:31,810
training each time you build it okay

00:34:19,210 --> 00:34:36,580
thank you so you built the whole

00:34:31,810 --> 00:34:42,550
distribution with LT old so how much

00:34:36,580 --> 00:34:46,120
longer it takes now actually I haven't

00:34:42,550 --> 00:34:51,430
measured it but there will be some

00:34:46,120 --> 00:34:53,680
increase but I will expect just a small

00:34:51,430 --> 00:34:59,830
one so it over had to be quite small I

00:34:53,680 --> 00:35:01,360
guess no it's a depends of course on the

00:34:59,830 --> 00:35:03,550
on the package but if I remember

00:35:01,360 --> 00:35:07,360
correctly it was something like 16 per

00:35:03,550 --> 00:35:09,790
file person for the brofist so that's an

00:35:07,360 --> 00:35:11,470
you know bigger packages are harder

00:35:09,790 --> 00:35:13,450
although the smaller packages are easier

00:35:11,470 --> 00:35:15,640
so I would say the average should be

00:35:13,450 --> 00:35:17,890
better but for example GCC itself is

00:35:15,640 --> 00:35:19,240
terrible because it has static library

00:35:17,890 --> 00:35:21,850
which is called it back-end which is

00:35:19,240 --> 00:35:25,240
very big it links it into every single

00:35:21,850 --> 00:35:27,370
language it supports so the GCC boostrap

00:35:25,240 --> 00:35:29,380
gets much slower without you so it

00:35:27,370 --> 00:35:31,620
really depends on how the program is

00:35:29,380 --> 00:35:31,620
structured

00:35:43,660 --> 00:35:49,850
two questions have you done any testings

00:35:46,640 --> 00:35:52,460
on architectures other than x86 64 and

00:35:49,850 --> 00:35:54,680
since you mentioned this leave for the

00:35:52,460 --> 00:35:59,360
future does this impact our ability to

00:35:54,680 --> 00:36:02,900
do live patching so the first question

00:35:59,360 --> 00:36:06,920
is no we just I just used open QA for

00:36:02,900 --> 00:36:09,050
exciti 664 and the second question we

00:36:06,920 --> 00:36:13,430
probably don't want to have it in a

00:36:09,050 --> 00:36:15,680
Linux kernel currently you need a huge

00:36:13,430 --> 00:36:18,560
bed set on top of Linux kernel to be

00:36:15,680 --> 00:36:21,320
able to build build with OTO and it's

00:36:18,560 --> 00:36:24,740
not upstream it's under cleaners working

00:36:21,320 --> 00:36:29,380
on that and he was rejected couple of

00:36:24,740 --> 00:36:29,380
times by Lee knows too much about site

00:36:29,590 --> 00:36:34,760
support Khanna is interesting because

00:36:32,120 --> 00:36:37,370
for us because it really trying a lot of

00:36:34,760 --> 00:36:40,070
strange cases with GCC needs to do but

00:36:37,370 --> 00:36:42,800
on the other hand you know the benefits

00:36:40,070 --> 00:36:45,020
are not so not as large because is

00:36:42,800 --> 00:36:47,630
heavily hand optimized or carefully

00:36:45,020 --> 00:36:49,340
carefully handler code base now the

00:36:47,630 --> 00:36:51,260
benefits are much bigger on things like

00:36:49,340 --> 00:36:54,410
liberal phase which is huge and has much

00:36:51,260 --> 00:36:56,210
more Excel abstraction penalty so yeah

00:36:54,410 --> 00:36:58,640
you know there are some packages like

00:36:56,210 --> 00:37:02,570
gilepsy which I don't expect it wants to

00:36:58,640 --> 00:37:06,410
have a deal at all so and also you know

00:37:02,570 --> 00:37:08,570
for the x86 question we don't we didn't

00:37:06,410 --> 00:37:10,760
do the ultimate test but of course the

00:37:08,570 --> 00:37:13,460
performance and spec benchmarking is

00:37:10,760 --> 00:37:20,900
done by by arm and IBM so they are also

00:37:13,460 --> 00:37:23,990
tracking the Geo performance the GCC

00:37:20,900 --> 00:37:26,900
code for for all those LTO handling is

00:37:23,990 --> 00:37:29,450
that generic code or other architecture

00:37:26,900 --> 00:37:32,090
specific bit so that like the power

00:37:29,450 --> 00:37:36,500
might be the benefits might not be as

00:37:32,090 --> 00:37:38,360
large as now for the only on the

00:37:36,500 --> 00:37:40,550
architecture specific part is how you

00:37:38,360 --> 00:37:42,110
pick it into the object files so we need

00:37:40,550 --> 00:37:43,580
to understand object fast so there's a

00:37:42,110 --> 00:37:45,490
different support for America different

00:37:43,580 --> 00:37:47,950
for Windows and different for

00:37:45,490 --> 00:37:53,250
for Alf but besides that it's a generic

00:37:47,950 --> 00:37:53,250
so it goes for all the other targets

00:37:58,290 --> 00:38:07,000
what is the increase in the due to this

00:38:03,880 --> 00:38:11,200
and il encode being added to the

00:38:07,000 --> 00:38:13,690
individual object files would that be

00:38:11,200 --> 00:38:16,450
noticeable in you know some packages

00:38:13,690 --> 00:38:21,580
having constraints for the dis sizes in

00:38:16,450 --> 00:38:23,380
OBS yeah there are generally bigger yeah

00:38:21,580 --> 00:38:25,690
yeah there are not sometimes bigger but

00:38:23,380 --> 00:38:28,660
there are somehow bigger than the usual

00:38:25,690 --> 00:38:31,300
usual object files because because they

00:38:28,660 --> 00:38:32,740
contain more information but on the

00:38:31,300 --> 00:38:34,330
other hand we are compressing them so

00:38:32,740 --> 00:38:37,810
they are compressed so they they take

00:38:34,330 --> 00:38:39,190
yeah yeah and also so yeah that's a

00:38:37,810 --> 00:38:41,080
Suffolk you are working on you know we

00:38:39,190 --> 00:38:43,119
are trying to reduce the quantity of

00:38:41,080 --> 00:38:45,089
information we are streaming because

00:38:43,119 --> 00:38:48,490
it's a important performance bottleneck

00:38:45,089 --> 00:38:51,369
so yeah I don't remember the numbers but

00:38:48,490 --> 00:38:53,970
it's off twice it's it's you know some

00:38:51,369 --> 00:38:53,970
percent ago

00:39:04,140 --> 00:39:10,050
so I guess it's time for beers thank you

00:39:13,820 --> 00:39:17,159
[Applause]

00:39:17,550 --> 00:39:19,610

YouTube URL: https://www.youtube.com/watch?v=41gKQrhEsh4


