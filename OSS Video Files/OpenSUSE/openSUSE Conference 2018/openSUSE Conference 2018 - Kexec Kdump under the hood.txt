Title: openSUSE Conference 2018 - Kexec Kdump under the hood
Publication date: 2018-05-25
Playlist: openSUSE Conference 2018
Description: 
	A look on the internals on arm64

Kdump is a vital tool for debugging severe kernel crashes, especially if the failure can't be reproduced easily or an direct access to the system is not possible.

When an sever error happens in the kernel, a new crash kernel get loaded which saves the memory of the crashed system. These dump can be used to analyze the state of the machine and hopefully give insights on what has happened.

This talks will dive into the internals of kexec and kdump. How the crash kernel get set-up, how it's execution get triggered. We will also look into kexec-tool, the user-space part needed to set up a system to use kdump. Where necessary, the architectural specific details will be explained by looking at the arm64 implementation. This talk is thought for people who want to have an insight into how kdump is working.

Kdump is a vital tool for debugging severe kernel crashes, especially if the failure can't be reproduced easily or an direct access to the system is not possible.

When an sever error happens in the kernel, a new crash kernel get loaded which saves the memory of the crashed system. These dump can be used to analyze the state of the machine and hopefully give insights on what has happened.

This talks will dive into the internals of kexec and kdump. How the crash kernel get set-up, how it's execution get triggered. We will also look into kexec-tool, the user-space part needed to set up a system to use kdump. Where necessary, the architectural specific details will be explained by looking at the arm64 implementation. This talk is thought for people who want to have an insight into how kdump is working.

Matthias Brugger
Captions: 
	00:00:06,560 --> 00:00:13,980
okay hello everybody welcome to my talk

00:00:09,660 --> 00:00:16,859
about kxa kdump I want to I will try to

00:00:13,980 --> 00:00:19,859
explain you a bit how okay exactly dump

00:00:16,859 --> 00:00:23,880
works and my name is Matthias Brock I

00:00:19,859 --> 00:00:34,850
work at SUSE Linux kernel engineer and I

00:00:23,880 --> 00:00:39,420
work mainly on arm 64 and I looked into

00:00:34,850 --> 00:00:44,370
kxe kdump for the for enablement for

00:00:39,420 --> 00:00:47,430
Slee 12 sp3 and well yeah then I thought

00:00:44,370 --> 00:00:49,230
that would be nice to the tour talk

00:00:47,430 --> 00:00:51,360
about it and it took me a while to

00:00:49,230 --> 00:00:53,879
actually find the time I am finally

00:00:51,360 --> 00:00:57,539
found find the time you know now at the

00:00:53,879 --> 00:01:00,170
moment so what I will talk about I will

00:00:57,539 --> 00:01:02,489
give a quick overview of see use cases

00:01:00,170 --> 00:01:05,000
then we will have look into the

00:01:02,489 --> 00:01:08,520
internals of user space and kernel we

00:01:05,000 --> 00:01:10,380
look about special support an open SUSE

00:01:08,520 --> 00:01:13,229
I will do a demo and we have some

00:01:10,380 --> 00:01:16,229
questions well you have some questions I

00:01:13,229 --> 00:01:20,159
have some answers of hopefully okay the

00:01:16,229 --> 00:01:22,170
use cases so first use case is put a new

00:01:20,159 --> 00:01:25,049
kernel without rebooting a machine so I

00:01:22,170 --> 00:01:28,170
come from an embedded and I pick round

00:01:25,049 --> 00:01:30,780
so that for me was a really strange use

00:01:28,170 --> 00:01:32,640
case because in embedded you just put up

00:01:30,780 --> 00:01:36,600
all the time when you for example

00:01:32,640 --> 00:01:39,119
develop but when you have like bigger

00:01:36,600 --> 00:01:41,400
systems like big servers and it can take

00:01:39,119 --> 00:01:43,799
quite a while for the film where to

00:01:41,400 --> 00:01:47,369
enumerate all the devices and then it

00:01:43,799 --> 00:01:48,840
makes it might make sense to just reboot

00:01:47,369 --> 00:01:53,100
the kernel without rebooting the whole

00:01:48,840 --> 00:01:55,110
firmware or you have like pre-production

00:01:53,100 --> 00:01:57,450
firmware which is not stable enough and

00:01:55,110 --> 00:01:59,820
you don't want to risk to reboot the

00:01:57,450 --> 00:02:03,750
whole machine and then have a broken

00:01:59,820 --> 00:02:06,049
firmware then the second use case is to

00:02:03,750 --> 00:02:08,640
debug a system I think this is a

00:02:06,049 --> 00:02:11,810
principal motivation why this was

00:02:08,640 --> 00:02:16,829
implemented in the first place and that

00:02:11,810 --> 00:02:20,459
the Suzi we use it we use it to the back

00:02:16,829 --> 00:02:22,500
Colonel crushes that happens and at our

00:02:20,459 --> 00:02:24,120
customers we have a lot of different

00:02:22,500 --> 00:02:28,049
customers with different hardware and

00:02:24,120 --> 00:02:31,530
that we don't always and have good locks

00:02:28,049 --> 00:02:34,500
because maybe there's no serial console

00:02:31,530 --> 00:02:38,069
or the locks are broken because the

00:02:34,500 --> 00:02:40,739
kernel crash is so bad or we don't have

00:02:38,069 --> 00:02:42,569
a reproducer in-house because it's some

00:02:40,739 --> 00:02:44,280
legacy co-current and the client that

00:02:42,569 --> 00:02:48,720
actually provokes the question we need

00:02:44,280 --> 00:02:51,209
to understand how this happens so we can

00:02:48,720 --> 00:02:54,689
use cakes academ for that I will explain

00:02:51,209 --> 00:02:57,569
in the rest of the presentation I will

00:02:54,689 --> 00:02:59,250
explain the use case of 40 packing

00:02:57,569 --> 00:03:03,299
assistant because the other one is it's

00:02:59,250 --> 00:03:06,000
a bit different and I I decided to look

00:03:03,299 --> 00:03:08,340
into this more in detail and the last

00:03:06,000 --> 00:03:10,169
one is to boot your system which is for

00:03:08,340 --> 00:03:13,169
me that sounds like totally crazy and

00:03:10,169 --> 00:03:15,329
that this was s/390 is doing when

00:03:13,169 --> 00:03:21,720
putting a system they do kxx in the end

00:03:15,329 --> 00:03:23,879
well okay some comments first so the

00:03:21,720 --> 00:03:25,919
different ways to talk about the

00:03:23,879 --> 00:03:28,409
production system and the captures kit

00:03:25,919 --> 00:03:30,150
check kernel or crush kernel or penny

00:03:28,409 --> 00:03:32,849
kernel so I will talk about the

00:03:30,150 --> 00:03:35,489
production kernel or production system

00:03:32,849 --> 00:03:39,780
in a capture kernel or capture system

00:03:35,489 --> 00:03:42,169
and the idea is said the capture system

00:03:39,780 --> 00:03:46,260
gets booted when the production system

00:03:42,169 --> 00:03:49,650
crashes so to make it more graphically

00:03:46,260 --> 00:03:52,470
you have here this is really crappy

00:03:49,650 --> 00:03:54,720
graphic I made but anyway but it's good

00:03:52,470 --> 00:03:56,939
enough it shows you like the memory of

00:03:54,720 --> 00:03:58,829
the system and the arrow shows you that

00:03:56,939 --> 00:04:01,439
the production kernel is running and

00:03:58,829 --> 00:04:04,379
then the production kernel crashes and

00:04:01,439 --> 00:04:06,680
then the capture kernel get started and

00:04:04,379 --> 00:04:10,169
the capture kernel creates somehow a

00:04:06,680 --> 00:04:14,459
dump file with a memory of the

00:04:10,169 --> 00:04:17,909
production system so that's that's how

00:04:14,459 --> 00:04:20,729
how it works and which parts and whelped

00:04:17,909 --> 00:04:23,520
well do we have a user space part the

00:04:20,729 --> 00:04:24,960
most important tool or the most

00:04:23,520 --> 00:04:27,990
important project this case

00:04:24,960 --> 00:04:31,280
tools which is used to prepare the

00:04:27,990 --> 00:04:34,620
capture system and somehow load it into

00:04:31,280 --> 00:04:36,569
into the to somehow load it so that it

00:04:34,620 --> 00:04:38,460
can boot it when the production system

00:04:36,569 --> 00:04:42,840
crashes then we have of course the

00:04:38,460 --> 00:04:45,660
kernel itself there are some other use

00:04:42,840 --> 00:04:48,810
of space tools to inspect the dam like

00:04:45,660 --> 00:04:52,770
make dump file or crash or crash peyten

00:04:48,810 --> 00:04:54,780
and I won't explain and I won't go into

00:04:52,770 --> 00:04:59,130
detail about these tools you can have a

00:04:54,780 --> 00:05:02,039
look we have the main page and at Lee

00:04:59,130 --> 00:05:04,199
and then there are some disco this this

00:05:02,039 --> 00:05:08,550
programs to make it easier to set things

00:05:04,199 --> 00:05:10,380
up sets things up and in the case of

00:05:08,550 --> 00:05:17,039
openSUSE that's called kdump

00:05:10,380 --> 00:05:18,990
which yeah so KX ik tools and tools has

00:05:17,039 --> 00:05:22,080
several tools the most important one is

00:05:18,990 --> 00:05:26,220
called KX ik and you can see here how

00:05:22,080 --> 00:05:28,530
you can for example load a kernel with

00:05:26,220 --> 00:05:30,090
an init Rd and you just use a command

00:05:28,530 --> 00:05:33,270
the kernel command line from the

00:05:30,090 --> 00:05:36,449
production system and you have different

00:05:33,270 --> 00:05:40,979
possibilities to use it so you can trust

00:05:36,449 --> 00:05:42,659
if you want to the first use case to

00:05:40,979 --> 00:05:45,360
just put a new kernel then you would use

00:05:42,659 --> 00:05:48,270
- L for load the system and then

00:05:45,360 --> 00:05:51,810
afterwards you do and - e KX sectors e

00:05:48,270 --> 00:05:54,599
which will reboot in the new kernel but

00:05:51,810 --> 00:05:58,169
unmount your file systems so that I

00:05:54,599 --> 00:06:01,169
don't get and damaged and this will

00:05:58,169 --> 00:06:02,729
basically call reboot with a magic

00:06:01,169 --> 00:06:04,500
number and the kernel and the curl then

00:06:02,729 --> 00:06:08,070
realizes that it shouldn't reboot but

00:06:04,500 --> 00:06:10,710
just reboot a new a new kernel and not

00:06:08,070 --> 00:06:14,009
the whole system apart form that you can

00:06:10,710 --> 00:06:16,530
unload a loaded kernel and you could

00:06:14,009 --> 00:06:24,090
have some architecture specific options

00:06:16,530 --> 00:06:26,280
like device 3 forearm 64 ok so remember

00:06:24,090 --> 00:06:29,039
how this works so the capture system

00:06:26,280 --> 00:06:30,840
takes the memory of the of the

00:06:29,039 --> 00:06:33,389
production system and creates a ton file

00:06:30,840 --> 00:06:35,250
so the question is how can the capture

00:06:33,389 --> 00:06:37,680
the system do this what does it need

00:06:35,250 --> 00:06:38,150
well what we need when the production

00:06:37,680 --> 00:06:40,250
system

00:06:38,150 --> 00:06:42,740
freshest is we need a capture Colonel we

00:06:40,250 --> 00:06:45,350
know no we need to know where they

00:06:42,740 --> 00:06:48,980
capture Colonel is in the memory too

00:06:45,350 --> 00:06:51,200
loaded we need to know which memory we

00:06:48,980 --> 00:06:53,810
can use for the capture Colonel because

00:06:51,200 --> 00:06:55,490
if we would use just the memory used by

00:06:53,810 --> 00:06:57,890
the production system then we could

00:06:55,490 --> 00:07:03,230
overwrite some values and interesting to

00:06:57,890 --> 00:07:06,230
analyze and we need to we need some use

00:07:03,230 --> 00:07:07,910
of space for the capture system and we

00:07:06,230 --> 00:07:09,530
need to know where they were actually

00:07:07,910 --> 00:07:15,020
the memory of the production system is

00:07:09,530 --> 00:07:19,670
so that we can creates a dump and to do

00:07:15,020 --> 00:07:21,830
this what we do is I made a small crappy

00:07:19,670 --> 00:07:23,420
graphic down here which is like the

00:07:21,830 --> 00:07:26,630
memory oh the whole memory of your

00:07:23,420 --> 00:07:28,880
machine and then you reserve which is

00:07:26,630 --> 00:07:31,700
the gray area you reserve some memory

00:07:28,880 --> 00:07:35,840
space we are they crash colonel equals

00:07:31,700 --> 00:07:38,420
some megabytes to where where the

00:07:35,840 --> 00:07:39,980
capture system will live in and you take

00:07:38,420 --> 00:07:42,200
this memory away from the production

00:07:39,980 --> 00:07:44,840
system so it can be a bit tricky to

00:07:42,200 --> 00:07:47,330
decide how big this memory area should

00:07:44,840 --> 00:07:49,550
be you don't want it to be too big to

00:07:47,330 --> 00:07:51,560
waste memory for something that you

00:07:49,550 --> 00:07:55,220
don't that you hopefully never you never

00:07:51,560 --> 00:07:58,270
need and but don't make it too small

00:07:55,220 --> 00:08:03,170
because then maybe your capture system

00:07:58,270 --> 00:08:05,990
does not come up so there are some tools

00:08:03,170 --> 00:08:10,550
that can help you I will show you later

00:08:05,990 --> 00:08:13,850
and you can see in this reserved area

00:08:10,550 --> 00:08:16,340
there we are there different segments

00:08:13,850 --> 00:08:20,960
like al-qaeda Colonel in a deity device

00:08:16,340 --> 00:08:24,290
tree in purgatory which which get loaded

00:08:20,960 --> 00:08:27,260
into the into the reserved memory and

00:08:24,290 --> 00:08:29,210
then the part here in the end that would

00:08:27,260 --> 00:08:31,330
be like the memory that actually the

00:08:29,210 --> 00:08:34,580
capture system can use of the boot and

00:08:31,330 --> 00:08:39,170
these segments this is how they are

00:08:34,580 --> 00:08:40,640
called and have this structure which is

00:08:39,170 --> 00:08:43,370
a shared structure between the user

00:08:40,640 --> 00:08:45,620
space and their in the kernel and for

00:08:43,370 --> 00:08:46,190
example in the case of the capture

00:08:45,620 --> 00:08:48,560
colonel

00:08:46,190 --> 00:08:52,010
when you load this with whiskey whiskey

00:08:48,560 --> 00:08:53,990
exact tools what it does it copies

00:08:52,010 --> 00:08:56,990
allocates a buffer of the size of your

00:08:53,990 --> 00:08:59,740
kernel in user space and copies your

00:08:56,990 --> 00:09:03,380
kernel in there and then it looks in the

00:08:59,740 --> 00:09:07,790
reserved region where it can find page

00:09:03,380 --> 00:09:10,940
aligned hole to reserve this for your

00:09:07,790 --> 00:09:13,820
kernel and so in the end you have like a

00:09:10,940 --> 00:09:16,220
buffer we say in user space your buffer

00:09:13,820 --> 00:09:18,350
with your kernel and you have appointed

00:09:16,220 --> 00:09:22,850
to the memory which would be pointing

00:09:18,350 --> 00:09:26,089
here and the size okay

00:09:22,850 --> 00:09:28,279
oh yeah okay so sorry and this this is

00:09:26,089 --> 00:09:31,190
for kernel and in Italy that's it what

00:09:28,279 --> 00:09:33,260
do you--what cakes it does the fqo

00:09:31,190 --> 00:09:35,240
header device tree in purgatory is a bit

00:09:33,260 --> 00:09:41,360
different and I will go more into detail

00:09:35,240 --> 00:09:44,149
now about this so the elf core header is

00:09:41,360 --> 00:09:45,740
an elf elf header or an elf file which

00:09:44,149 --> 00:09:51,910
holds information about the production

00:09:45,740 --> 00:09:55,310
memory and this is information the

00:09:51,910 --> 00:09:56,990
capture system later can create proc BM

00:09:55,310 --> 00:09:59,389
core which is a dumb file that you can

00:09:56,990 --> 00:10:03,949
then copy somewhere and inspect what

00:09:59,389 --> 00:10:05,959
really happened in your system and yeah

00:10:03,949 --> 00:10:08,089
this works like this that you have an

00:10:05,959 --> 00:10:10,940
elf head of an elf header and then you

00:10:08,089 --> 00:10:12,980
have program headers which points for

00:10:10,940 --> 00:10:16,339
example here to your production kernel

00:10:12,980 --> 00:10:19,160
or which points to the memory and there

00:10:16,339 --> 00:10:22,360
are different different program had us

00:10:19,160 --> 00:10:25,069
one for each CPU which points to the

00:10:22,360 --> 00:10:27,500
correct notes of each CPU which is a

00:10:25,069 --> 00:10:29,600
memory region in your production system

00:10:27,500 --> 00:10:32,690
where the production system will store

00:10:29,600 --> 00:10:35,620
information about CPU state pits CPU

00:10:32,690 --> 00:10:38,060
registers so that in the end you have an

00:10:35,620 --> 00:10:41,389
exact picture of what happened in every

00:10:38,060 --> 00:10:44,959
CPU and a moment of secretion and then

00:10:41,389 --> 00:10:50,269
yeah they exit tools can read the

00:10:44,959 --> 00:10:53,360
address via the sisyphus and then write

00:10:50,269 --> 00:10:59,449
C address into say program header and

00:10:53,360 --> 00:11:02,180
the size and that's it VM core is a data

00:10:59,449 --> 00:11:04,830
structure in the kernel which is used to

00:11:02,180 --> 00:11:06,630
describe how the kernel looks like so

00:11:04,830 --> 00:11:10,830
for debug information so you can for

00:11:06,630 --> 00:11:13,200
example see page size so you can see the

00:11:10,830 --> 00:11:15,360
offset of the Flex instruct page how big

00:11:13,200 --> 00:11:18,420
is a struct if that era and that's

00:11:15,360 --> 00:11:21,920
necessary to later be able to analyze

00:11:18,420 --> 00:11:25,200
the counterpart of seek memory dump and

00:11:21,920 --> 00:11:27,930
yeah that's also copied or stored

00:11:25,200 --> 00:11:30,420
somewhere in the in the in the

00:11:27,930 --> 00:11:32,400
protections in the production system

00:11:30,420 --> 00:11:40,620
memory and you can read this with this

00:11:32,400 --> 00:11:43,320
kernel VM core info and then Atlee then

00:11:40,620 --> 00:11:46,110
what you also need of course is the real

00:11:43,320 --> 00:11:51,240
memory said your production system has

00:11:46,110 --> 00:11:55,380
so what elf KX ik told us it reads proc

00:11:51,240 --> 00:11:59,390
IO mem and decides which parts of this

00:11:55,380 --> 00:12:03,480
system Ram by string string compare so

00:11:59,390 --> 00:12:09,120
nothing really elaborated and yeah and

00:12:03,480 --> 00:12:12,540
then points to that okay so that's about

00:12:09,120 --> 00:12:15,930
F Coweta these information as a citizen

00:12:12,540 --> 00:12:19,730
used to create the dump file and then in

00:12:15,930 --> 00:12:19,730
the capture system you can read read it

00:12:20,690 --> 00:12:27,560
ok let's talk about the next one here

00:12:23,700 --> 00:12:31,800
which is device tree device tree is an

00:12:27,560 --> 00:12:33,990
is a description language for hardware

00:12:31,800 --> 00:12:38,550
how the hardware looks of humour Sheen

00:12:33,990 --> 00:12:43,560
it's used by PowerPC in PI arm and arm

00:12:38,550 --> 00:12:47,040
64 hell is able by by specification is

00:12:43,560 --> 00:12:50,520
able to put and device with device tree

00:12:47,040 --> 00:12:54,210
or with a CPI but there are some some

00:12:50,520 --> 00:12:56,250
people that push the vendors to to a CPI

00:12:54,210 --> 00:13:03,120
only so there are machines that are a

00:12:56,250 --> 00:13:06,750
CPI only and then to be able to to use

00:13:03,120 --> 00:13:11,280
device 3 4 and 4 k x8 kdump

00:13:06,750 --> 00:13:14,580
you have a system where F DT and I'm 64

00:13:11,280 --> 00:13:16,230
which gives you minimal device tree we

00:13:14,580 --> 00:13:18,680
can I can show you that later which has

00:13:16,230 --> 00:13:24,220
just the you femm map

00:13:18,680 --> 00:13:30,110
where Dana tidy is allocated and the

00:13:24,220 --> 00:13:32,960
credible poot parameter and what kxx

00:13:30,110 --> 00:13:35,990
tools thus it reads this device 3 it

00:13:32,960 --> 00:13:38,029
updates the location of the energy which

00:13:35,990 --> 00:13:41,089
then points to the energy which is he a

00:13:38,029 --> 00:13:44,529
new reserved area it it's a pointer to

00:13:41,089 --> 00:13:48,380
the elf Coweta and it tells the system

00:13:44,529 --> 00:13:50,420
where the usable memory is and with this

00:13:48,380 --> 00:13:56,470
device fillet this is the capture system

00:13:50,420 --> 00:13:56,470
knows everything it needs to know ok

00:14:09,990 --> 00:14:13,999
[Laughter]

00:14:14,820 --> 00:14:17,889
[Music]

00:14:19,029 --> 00:14:27,890
yeah of course yeah it's only say uuuy

00:14:25,790 --> 00:14:29,420
fi memory map so I suppose it to

00:14:27,890 --> 00:14:31,850
translate it somewhere but I don't I

00:14:29,420 --> 00:14:37,130
haven't had a look on the code exactly

00:14:31,850 --> 00:14:39,230
how this is done and I mean I don't

00:14:37,130 --> 00:14:41,540
think that is that they prove that the

00:14:39,230 --> 00:14:45,950
diplom were apart from that the provides

00:14:41,540 --> 00:14:48,230
a device tree because that most probably

00:14:45,950 --> 00:14:50,480
won't work I mean a good work but

00:14:48,230 --> 00:14:55,820
because of human error it most probably

00:14:50,480 --> 00:14:58,070
won't work so ok a last bit we need for

00:14:55,820 --> 00:15:01,220
our capture system is the purgatory

00:14:58,070 --> 00:15:05,060
so the purgatory decides over heaven and

00:15:01,220 --> 00:15:08,209
hell and heaven is when the crap when

00:15:05,060 --> 00:15:09,890
you are able to put the capture system

00:15:08,209 --> 00:15:13,070
and hell is when your system is so

00:15:09,890 --> 00:15:16,010
broken that you can't do it and what Pro

00:15:13,070 --> 00:15:18,320
guitar Aeon I'm 64 does basically it

00:15:16,010 --> 00:15:21,130
checks all the segments well the other

00:15:18,320 --> 00:15:24,200
segments not its own but all the SS and

00:15:21,130 --> 00:15:26,920
checks for the hedge some to see that

00:15:24,200 --> 00:15:30,770
the that these sequences are not and

00:15:26,920 --> 00:15:32,740
changed in any way and that it's safe to

00:15:30,770 --> 00:15:36,080
put a set of choices

00:15:32,740 --> 00:15:39,770
says also in the newest version of

00:15:36,080 --> 00:15:42,290
Kasich tools command to ignore these

00:15:39,770 --> 00:15:44,000
checks which is really nice because it

00:15:42,290 --> 00:15:49,130
means purgatory sends you always to

00:15:44,000 --> 00:15:50,450
heaven so okay then the purgatory after

00:15:49,130 --> 00:15:52,700
after doing the checks and saying

00:15:50,450 --> 00:15:54,440
everything's okay it loads a kernel and

00:15:52,700 --> 00:15:57,110
device tree into righteousness and jumps

00:15:54,440 --> 00:15:57,529
to the kernel and we can can you see

00:15:57,110 --> 00:16:01,370
this

00:15:57,529 --> 00:16:03,980
yeah yes you can okay so this is the

00:16:01,370 --> 00:16:06,860
purgatory and I'm 64 I deleted some

00:16:03,980 --> 00:16:09,589
lines but basically it's a really easy

00:16:06,860 --> 00:16:13,100
assembly so it has some stick there's a

00:16:09,589 --> 00:16:14,690
stick is down here and that loads a

00:16:13,100 --> 00:16:18,200
stick and then it jumps to purgatory

00:16:14,690 --> 00:16:21,230
which is a c4c function which just to

00:16:18,200 --> 00:16:23,899
this hash check and then it loads the

00:16:21,230 --> 00:16:27,440
kernel entry point in the device tree

00:16:23,899 --> 00:16:30,410
address into registers 0 some other

00:16:27,440 --> 00:16:32,540
registers which is like say standard way

00:16:30,410 --> 00:16:35,660
to boot I'm 64 and then jumps to the

00:16:32,540 --> 00:16:39,890
kernel and what K exact tool does with

00:16:35,660 --> 00:16:43,520
this file it updates these two values to

00:16:39,890 --> 00:16:46,720
actually point to the kernel and to the

00:16:43,520 --> 00:16:49,339
device tree so in the end what we have

00:16:46,720 --> 00:16:51,649
to get all this information together all

00:16:49,339 --> 00:16:53,750
the ore to get all the information to

00:16:51,649 --> 00:16:56,870
purgatory is like the first program that

00:16:53,750 --> 00:16:58,520
gets executed when the system crashes he

00:16:56,870 --> 00:17:00,890
knows where the kernel is and where the

00:16:58,520 --> 00:17:03,050
device tree is and the device tree has

00:17:00,890 --> 00:17:04,850
point us to the elf core header in it Rd

00:17:03,050 --> 00:17:06,980
and the you save a memory for the system

00:17:04,850 --> 00:17:13,699
and the kernel will use the device tree

00:17:06,980 --> 00:17:19,490
to put up and and in gets a system

00:17:13,699 --> 00:17:22,790
running ok so that's all what kxx does

00:17:19,490 --> 00:17:25,400
it does pro it does create all these C

00:17:22,790 --> 00:17:29,210
segments and then it passes the segments

00:17:25,400 --> 00:17:31,340
to the em to the kernel and this is done

00:17:29,210 --> 00:17:34,970
via syscall it's called KX ik load

00:17:31,340 --> 00:17:37,520
there's another coil call which is KX ik

00:17:34,970 --> 00:17:39,470
file load where you just pass again curl

00:17:37,520 --> 00:17:41,150
and the Anita teaches of code to the

00:17:39,470 --> 00:17:42,590
production kernel and then the

00:17:41,150 --> 00:17:44,780
production kernel does all this stuff

00:17:42,590 --> 00:17:46,100
for you this is not yet implemented on

00:17:44,780 --> 00:17:50,120
arm 64 there are

00:17:46,100 --> 00:17:52,400
patches on the mailing list but it's not

00:17:50,120 --> 00:17:55,640
ready and yeah I've so I was looking

00:17:52,400 --> 00:17:58,340
into seek a exit load case and in the

00:17:55,640 --> 00:18:01,160
cake sack load case what cakes tools

00:17:58,340 --> 00:18:03,320
passes to the kernel is the entry points

00:18:01,160 --> 00:18:07,100
of the program repoint of the purgatory

00:18:03,320 --> 00:18:11,510
and the number of the segments you have

00:18:07,100 --> 00:18:13,850
and and and and well an array in the

00:18:11,510 --> 00:18:16,400
engineering offices of kxx sequence and

00:18:13,850 --> 00:18:20,150
the number they are how many are in the

00:18:16,400 --> 00:18:23,420
array ok so that's that's a user space

00:18:20,150 --> 00:18:30,140
part and now we get to the kernel part

00:18:23,420 --> 00:18:32,720
which is shorter so okay so kernel

00:18:30,140 --> 00:18:34,490
internals I will talk about three parts

00:18:32,720 --> 00:18:38,330
in the kernel internals so we have the

00:18:34,490 --> 00:18:40,070
part where and how does this capture

00:18:38,330 --> 00:18:42,140
system get loaded

00:18:40,070 --> 00:18:44,740
well the production system still is up

00:18:42,140 --> 00:18:46,850
and running which is CK exit load Cisco

00:18:44,740 --> 00:18:49,370
then what happens when the production

00:18:46,850 --> 00:18:54,260
kernel crashes and then what happens

00:18:49,370 --> 00:18:56,720
when they capture kernel boots up okay

00:18:54,260 --> 00:18:58,850
loading the capture kernel so first of

00:18:56,720 --> 00:19:01,460
all the kernel does some checks so that

00:18:58,850 --> 00:19:04,610
you're really rude to do this that you

00:19:01,460 --> 00:19:06,290
don't have too many sequins in your and

00:19:04,610 --> 00:19:08,960
that you want to pass because you can

00:19:06,290 --> 00:19:11,240
only pass sixteen and when all this is

00:19:08,960 --> 00:19:14,720
okay then it creates a structure which

00:19:11,240 --> 00:19:17,420
is called K image and which holds the

00:19:14,720 --> 00:19:20,570
kxx sequence that the information from

00:19:17,420 --> 00:19:22,070
user space it holds a purgatory entry

00:19:20,570 --> 00:19:27,170
point which you also got from user space

00:19:22,070 --> 00:19:29,480
and allocates a memory page for as a

00:19:27,170 --> 00:19:32,510
control page which could be used to

00:19:29,480 --> 00:19:36,740
actually start the program

00:19:32,510 --> 00:19:39,560
and we'll see that in a minute and it

00:19:36,740 --> 00:19:44,270
will also do a copy of 0 and BM core

00:19:39,560 --> 00:19:47,110
info and hold this I'm not quite sure

00:19:44,270 --> 00:19:52,040
why he does this I suppose it is

00:19:47,110 --> 00:19:54,410
because if BM Co info gets damaged send

00:19:52,040 --> 00:19:56,060
us a copy but I'm I'm not sure I'd I'm

00:19:54,410 --> 00:19:58,890
not really sure why they wear the crown

00:19:56,060 --> 00:20:00,960
of the disease okay

00:19:58,890 --> 00:20:02,640
so once this is done it will check all

00:20:00,960 --> 00:20:05,070
the sequence and it will check for the

00:20:02,640 --> 00:20:08,160
note overlain overlap that they a

00:20:05,070 --> 00:20:10,320
pitcher lined that they are all in the

00:20:08,160 --> 00:20:13,380
crash memory area and then reserve their

00:20:10,320 --> 00:20:17,910
and memory area that we allocated and it

00:20:13,380 --> 00:20:19,830
will check that same memory so the point

00:20:17,910 --> 00:20:22,410
of the sue memory is of course the size

00:20:19,830 --> 00:20:25,410
and that this is bigger was the same as

00:20:22,410 --> 00:20:27,120
user space buffer size because it can be

00:20:25,410 --> 00:20:30,179
bigger because it's better aligned so

00:20:27,120 --> 00:20:33,120
what the buffer is not page aligned and

00:20:30,179 --> 00:20:34,980
what it also does check and which is not

00:20:33,120 --> 00:20:37,500
checked in K exact tools and that was

00:20:34,980 --> 00:20:40,140
surprised to found this is that it

00:20:37,500 --> 00:20:42,110
checks that the memory of all segments

00:20:40,140 --> 00:20:45,750
the size of the memory of all segments

00:20:42,110 --> 00:20:48,830
translated to pages is smaller or the

00:20:45,750 --> 00:20:53,850
same as the total rampages divided by 2

00:20:48,830 --> 00:20:56,010
so if K x'q fails it could be this and

00:20:53,850 --> 00:20:59,070
it doesn't give any error just gives a

00:20:56,010 --> 00:21:06,780
bad look it just just returns with ours

00:20:59,070 --> 00:21:09,360
any look message anything ok when these

00:21:06,780 --> 00:21:12,570
checks are all pass because we are

00:21:09,360 --> 00:21:17,240
actually copying copying the data the

00:21:12,570 --> 00:21:21,070
sequence so we have we have there the

00:21:17,240 --> 00:21:22,260
data and we have several

00:21:21,070 --> 00:21:25,020
[Music]

00:21:22,260 --> 00:21:27,030
address in the capture and reserve

00:21:25,020 --> 00:21:29,460
memory area where to copy this so we use

00:21:27,030 --> 00:21:33,840
copy from user to copy this page by page

00:21:29,460 --> 00:21:37,290
and after that we clear the PT evaluate

00:21:33,840 --> 00:21:40,290
bit for all the for all these pages so

00:21:37,290 --> 00:21:45,780
that they can't be accessed by the

00:21:40,290 --> 00:21:50,040
system by accident ok and that's it this

00:21:45,780 --> 00:21:54,270
we we actually done when the kernel

00:21:50,040 --> 00:21:56,610
crashes it checks that the fresh kernel

00:21:54,270 --> 00:21:58,350
got loaded and then when it gets low

00:21:56,610 --> 00:22:00,540
that the first board does it disabled

00:21:58,350 --> 00:22:03,990
see I accused and saves the CPU Rick is

00:22:00,540 --> 00:22:07,500
the richest on the crashed CPU then it

00:22:03,990 --> 00:22:08,700
writes time to the VM core info so that

00:22:07,500 --> 00:22:11,250
you know at which time the crash

00:22:08,700 --> 00:22:11,970
happened and then it sends an inter

00:22:11,250 --> 00:22:14,910
process

00:22:11,970 --> 00:22:20,160
interrupt two in the processor interrupt

00:22:14,910 --> 00:22:22,890
to all the other CPUs to which is CPU

00:22:20,160 --> 00:22:25,280
crash stop which and this other CPUs

00:22:22,890 --> 00:22:29,580
basically what they did they also saves

00:22:25,280 --> 00:22:32,490
registers to their crash notes we saw we

00:22:29,580 --> 00:22:37,020
saw on the elf kureta disabled the local

00:22:32,490 --> 00:22:41,190
I accuse and then call and CPU died in

00:22:37,020 --> 00:22:44,430
the firmware is PC PSC is a power and

00:22:41,190 --> 00:22:47,760
power system for arm 64 which basically

00:22:44,430 --> 00:22:50,790
shuts down the CPUs then it checks that

00:22:47,760 --> 00:22:55,920
all CPUs actually down because sometimes

00:22:50,790 --> 00:22:57,900
this doesn't work that good and if if

00:22:55,920 --> 00:23:01,590
not all the CPUs are down it gives us

00:22:57,900 --> 00:23:03,240
and some warning but it doesn't stop

00:23:01,590 --> 00:23:08,270
anyway because yeah it's already

00:23:03,240 --> 00:23:10,380
everything lost so it copies a

00:23:08,270 --> 00:23:12,870
relocation code to the control page

00:23:10,380 --> 00:23:17,040
that's what they what it was allocated

00:23:12,870 --> 00:23:19,440
before it shut down menu and disable the

00:23:17,040 --> 00:23:21,810
caches and then it actually starts a

00:23:19,440 --> 00:23:24,900
relocation code which is armed 64

00:23:21,810 --> 00:23:27,570
relocate new kernel in the case of 164

00:23:24,900 --> 00:23:30,330
and then this is an assembly file which

00:23:27,570 --> 00:23:33,180
basically checks if the relocation is

00:23:30,330 --> 00:23:35,790
needed in the case of a crash kernel

00:23:33,180 --> 00:23:37,530
it's not needed and it jumps directly to

00:23:35,790 --> 00:23:41,040
the purgatory which we have seen before

00:23:37,530 --> 00:23:44,910
and then the purgatory starts up and and

00:23:41,040 --> 00:23:49,950
those still device 3 but what he has to

00:23:44,910 --> 00:23:51,630
do to the best wrinkle sorry ok then the

00:23:49,950 --> 00:23:54,690
current then the kernel starts the

00:23:51,630 --> 00:23:57,800
purgatory starts a kernel the colonel

00:23:54,690 --> 00:24:01,740
knows through this device tree

00:23:57,800 --> 00:24:04,020
information in its DTB were the elf core

00:24:01,740 --> 00:24:06,000
header layer lies where the usable

00:24:04,020 --> 00:24:09,030
memory isn't where the inner 30 starts

00:24:06,000 --> 00:24:11,820
so it can start the unit early and can

00:24:09,030 --> 00:24:14,040
create them from the elf core header the

00:24:11,820 --> 00:24:16,710
dump file how it does this will he

00:24:14,040 --> 00:24:21,840
reserve some memory and he copies the

00:24:16,710 --> 00:24:24,430
pointers from the from the elf core

00:24:21,840 --> 00:24:28,030
header into into C's file

00:24:24,430 --> 00:24:30,580
in the least file and it has a special

00:24:28,030 --> 00:24:32,680
read function so when you from users

00:24:30,580 --> 00:24:37,870
pages in the capture system actually

00:24:32,680 --> 00:24:40,630
read em read this file then actually you

00:24:37,870 --> 00:24:44,620
will copy the memory of the system and

00:24:40,630 --> 00:24:48,030
not beforehand okay

00:24:44,620 --> 00:24:52,330
oh I'm really I'm really quick a

00:24:48,030 --> 00:24:54,550
distribution part so setting all the

00:24:52,330 --> 00:24:57,040
system up is a bit tricky because you

00:24:54,550 --> 00:24:58,990
have several things you have to think

00:24:57,040 --> 00:25:01,150
about so first of all you have to know

00:24:58,990 --> 00:25:03,760
the reserved memory your needs which

00:25:01,150 --> 00:25:08,080
depends on your system rom on unit or

00:25:03,760 --> 00:25:10,720
decides etcetera so your energy

00:25:08,080 --> 00:25:13,300
shouldn't be too big but it should hold

00:25:10,720 --> 00:25:15,370
all the tools you need and all the tools

00:25:13,300 --> 00:25:18,880
you need is apart from the tools to

00:25:15,370 --> 00:25:21,100
somehow copies and done file that

00:25:18,880 --> 00:25:23,170
depends on where you want to copy some

00:25:21,100 --> 00:25:25,000
files so you can copy it down file to a

00:25:23,170 --> 00:25:28,510
local disk or you can copy it to a

00:25:25,000 --> 00:25:29,830
remote machine and and if you need of

00:25:28,510 --> 00:25:33,490
course you will need then need two

00:25:29,830 --> 00:25:35,890
drivers for the day for the for the

00:25:33,490 --> 00:25:39,180
fourth disc and for the file system or

00:25:35,890 --> 00:25:44,110
you will needs a network stack etc so

00:25:39,180 --> 00:25:46,240
it's not the lots of easy to make a D in

00:25:44,110 --> 00:25:47,830
it Rd in the end the last thing is you

00:25:46,240 --> 00:25:50,170
can decide do you want to reboot to the

00:25:47,830 --> 00:25:53,830
protection system after the crash or do

00:25:50,170 --> 00:25:56,950
you want to stay in there in the caption

00:25:53,830 --> 00:25:58,690
system so most probably you want to

00:25:56,950 --> 00:26:01,420
reboot because you need your system up

00:25:58,690 --> 00:26:05,830
and running and you hope that the crash

00:26:01,420 --> 00:26:09,780
doesn't appear too quick afterwards okay

00:26:05,830 --> 00:26:13,900
to do this we have suze kdump

00:26:09,780 --> 00:26:16,330
program or set of tools which basically

00:26:13,900 --> 00:26:19,060
has two parts which is a apart for the

00:26:16,330 --> 00:26:20,950
production system though this helps you

00:26:19,060 --> 00:26:23,850
with some rockets record scripts to

00:26:20,950 --> 00:26:30,490
create the unit Rd it helps you to

00:26:23,850 --> 00:26:34,510
execute the KX f ck x ik and the KX a

00:26:30,490 --> 00:26:36,130
call and it also as a tool to helps you

00:26:34,510 --> 00:26:36,900
approximate the side of the reserved

00:26:36,130 --> 00:26:38,700
memory

00:26:36,900 --> 00:26:41,550
the size of the reserved memory area

00:26:38,700 --> 00:26:43,790
that you will need and on the other hand

00:26:41,550 --> 00:26:46,800
when the capture system started this

00:26:43,790 --> 00:26:49,530
kdump tool also provides some services

00:26:46,800 --> 00:26:52,350
so you can create beforehand a

00:26:49,530 --> 00:26:55,830
configuration file to say where you want

00:26:52,350 --> 00:26:58,830
to store the a the dump and if you want

00:26:55,830 --> 00:27:03,030
to for example and compress it dump it

00:26:58,830 --> 00:27:06,660
cetera what you want to store in the

00:27:03,030 --> 00:27:09,390
dump so and if you are really lazy then

00:27:06,660 --> 00:27:11,610
you use just 2 K dump which is your

00:27:09,390 --> 00:27:13,350
friend because it's really easy to set

00:27:11,610 --> 00:27:16,800
this up so we can see here for example

00:27:13,350 --> 00:27:18,330
in the ton filtering you can you can

00:27:16,800 --> 00:27:21,150
read this read so you can for example

00:27:18,330 --> 00:27:22,950
you say what you want to include in the

00:27:21,150 --> 00:27:25,590
dump if you want to include free pages

00:27:22,950 --> 00:27:28,890
or pages would be 0 which makes your

00:27:25,590 --> 00:27:31,110
thumb file bigger or if you don't care

00:27:28,890 --> 00:27:35,310
about these or if you want to compress a

00:27:31,110 --> 00:27:37,260
file you can dump target you can say

00:27:35,310 --> 00:27:39,540
where you want to store it you can

00:27:37,260 --> 00:27:42,870
create some event notification so you

00:27:39,540 --> 00:27:46,800
get an email a you have some problem so

00:27:42,870 --> 00:27:48,990
that's nice and ok we don't have too

00:27:46,800 --> 00:27:53,480
much time but I wanted to do a really

00:27:48,990 --> 00:27:53,480
quick demo so let's see all this works

00:27:54,590 --> 00:28:03,840
ok can you read this more or less when

00:27:59,460 --> 00:28:06,660
I'm gonna put it up it's booting ok so I

00:28:03,840 --> 00:28:08,670
this is inverter machine on my laptop

00:28:06,660 --> 00:28:12,210
which is unfortunately using period

00:28:08,670 --> 00:28:17,070
route but it should do its trick to just

00:28:12,210 --> 00:28:20,360
show you so we can see for example that

00:28:17,070 --> 00:28:28,410
we have around 1 point 8 gigabyte of RAM

00:28:20,360 --> 00:28:31,350
you can see for example broke up you can

00:28:28,410 --> 00:28:33,630
see here that we have several and memory

00:28:31,350 --> 00:28:36,660
areas of a system ROM which is in use by

00:28:33,630 --> 00:28:45,870
K x'q tools to decide whether whether

00:28:36,660 --> 00:28:48,510
run is is present on the system we can

00:28:45,870 --> 00:28:50,700
see that we have an reserved memory area

00:28:48,510 --> 00:28:54,659
of Allah at 8 megabyte

00:28:50,700 --> 00:28:57,179
yeah which is this creche kernel which

00:28:54,659 --> 00:29:03,389
is he an i/o memory presented as crash

00:28:57,179 --> 00:29:06,570
colonel okay so I proved prepared these

00:29:03,389 --> 00:29:08,489
so what we will do we will load a panic

00:29:06,570 --> 00:29:09,989
colonel or a crush colonel we will

00:29:08,489 --> 00:29:13,639
ignore the checks because we don't have

00:29:09,989 --> 00:29:16,619
so much time and we will append to the

00:29:13,639 --> 00:29:19,830
command line like CPUs so that we don't

00:29:16,619 --> 00:29:23,940
have one CPU to be able only start one

00:29:19,830 --> 00:29:31,470
CPU and not to because right now we have

00:29:23,940 --> 00:29:33,960
two CPUs ok and now I will try to show

00:29:31,470 --> 00:29:49,289
you the device tree that's created from

00:29:33,960 --> 00:29:51,629
a CPI ok so you can see here this is the

00:29:49,289 --> 00:29:54,749
advice tree so we have just the linux

00:29:51,629 --> 00:29:56,580
you'ii fiy map and then you a female map

00:29:54,749 --> 00:29:58,249
and then we have the knitter D and they

00:29:56,580 --> 00:30:05,600
put arguments and that's it

00:29:58,249 --> 00:30:22,769
ok so let's load C system and now we can

00:30:05,600 --> 00:30:25,889
artificially crash our system so by

00:30:22,769 --> 00:30:33,450
writing C to proxies proxies our Q

00:30:25,889 --> 00:30:36,960
trigger you crash your system oh you

00:30:33,450 --> 00:30:42,649
have to shout I don't know why this

00:30:36,960 --> 00:30:50,909
happens that's that's a pity

00:30:42,649 --> 00:30:55,950
well now we are we are we are now in the

00:30:50,909 --> 00:30:59,460
capture system so if we can see now that

00:30:55,950 --> 00:31:03,239
we have 147 megabytes of ram because

00:30:59,460 --> 00:31:04,260
some is some is needed for the kxx

00:31:03,239 --> 00:31:16,790
sequence

00:31:04,260 --> 00:31:16,790
we can see that we only have one one CPU

00:31:35,380 --> 00:31:42,620
okay so this is the device tree and you

00:31:39,620 --> 00:31:46,910
can see that we have here Linux elfin

00:31:42,620 --> 00:31:51,340
elf core header and we have the usable

00:31:46,910 --> 00:31:54,530
memory here so last thing I want to do

00:31:51,340 --> 00:31:58,120
there's some program called BM chord

00:31:54,530 --> 00:31:58,120
image I know I want to do something else

00:32:05,320 --> 00:32:10,160
Proc p.m. choruses I'm fine and you can

00:32:08,240 --> 00:32:12,170
see the damn file is important gigabyte

00:32:10,160 --> 00:32:14,420
because it's a memory that we have in

00:32:12,170 --> 00:32:16,520
our production system of course you

00:32:14,420 --> 00:32:17,900
don't feel most probably I'm not

00:32:16,520 --> 00:32:21,080
interested in all the memories that's

00:32:17,900 --> 00:32:24,740
why you can with make them filed x-ray

00:32:21,080 --> 00:32:31,810
and actually decide which what you want

00:32:24,740 --> 00:32:34,790
to see and just to show you there's one

00:32:31,810 --> 00:32:38,060
program that's called vm core damask

00:32:34,790 --> 00:32:40,880
which will reach Colonel Locke from your

00:32:38,060 --> 00:32:45,680
crush system so you pass in the dump

00:32:40,880 --> 00:32:52,190
file and you will see that the system

00:32:45,680 --> 00:32:54,680
and the system crashed where it is yeah

00:32:52,190 --> 00:32:57,770
since our cue trigger crash so that's

00:32:54,680 --> 00:33:00,340
when we crashed our system so it works

00:32:57,770 --> 00:33:00,340
great

00:33:05,350 --> 00:33:11,990
really quick now so references I put

00:33:09,470 --> 00:33:14,090
some information in here so where the

00:33:11,990 --> 00:33:16,159
cakes tools you can find it some

00:33:14,090 --> 00:33:19,220
information some documentation from

00:33:16,159 --> 00:33:21,470
Susan and openSUSE about how to set

00:33:19,220 --> 00:33:24,559
those things up the Kadem tool for

00:33:21,470 --> 00:33:26,990
openSUSE and if you didn't understand

00:33:24,559 --> 00:33:29,179
what i explained there is a nice block

00:33:26,990 --> 00:33:31,129
from some guy from red head which

00:33:29,179 --> 00:33:36,679
explains more lesser saying that I do

00:33:31,129 --> 00:33:39,499
that I found in my research and we will

00:33:36,679 --> 00:34:08,210
stop be requited and takeaways and any

00:33:39,499 --> 00:34:10,609
questions that goes by are PS yeah well

00:34:08,210 --> 00:34:23,240
that goes by normal reboot we just put

00:34:10,609 --> 00:34:29,060
reboot and then yeah yeah yeah

00:34:23,240 --> 00:34:31,510
yes no you have so unified system table

00:34:29,060 --> 00:34:35,119
gif from the production platform you

00:34:31,510 --> 00:34:38,450
give you if yeah you you if I system

00:34:35,119 --> 00:34:39,859
table in the in the device tree so you

00:34:38,450 --> 00:34:45,010
get that from the production system you

00:34:39,859 --> 00:34:45,010
don't touch this you just add some yes

00:34:45,550 --> 00:35:04,250
yes please yes it can happen yeah I

00:34:59,119 --> 00:35:08,690
don't know I I don't know I can't tell

00:35:04,250 --> 00:35:13,450
you sorry anyone knows and yeah anyone

00:35:08,690 --> 00:35:13,450
has more experience No

00:35:29,760 --> 00:35:32,630
okay

00:35:35,650 --> 00:35:43,920
I mean what I can say is when you set

00:35:40,240 --> 00:35:46,359
this up you should first try this

00:35:43,920 --> 00:35:49,690
you piss and artificial crush that

00:35:46,359 --> 00:35:52,690
really your crest your capture system

00:35:49,690 --> 00:35:56,700
boots up it's it's it's not trivial to

00:35:52,690 --> 00:35:56,700
do to get this running

00:36:08,940 --> 00:36:13,829
yeah I don't know I mean if you if you

00:36:15,690 --> 00:36:23,650
there is no but there is this

00:36:19,720 --> 00:36:27,430
description in the in the documentation

00:36:23,650 --> 00:36:29,589
from Susie's s and formula to calculate

00:36:27,430 --> 00:36:32,710
how much memory you will need in the

00:36:29,589 --> 00:36:37,619
reversal in the Reserve memory so it

00:36:32,710 --> 00:36:37,619
depends how many CPUs you have and stuff

00:36:47,190 --> 00:36:53,170
yes exactly

00:36:49,509 --> 00:37:16,539
which is part of the kdump tool from

00:36:53,170 --> 00:37:20,890
susan no air crash crash colonel

00:37:16,539 --> 00:37:24,640
relocation happens when you just just

00:37:20,890 --> 00:37:26,019
and want to reboot a new kernel because

00:37:24,640 --> 00:37:39,509
then you don't you don't have a memory

00:37:26,019 --> 00:37:39,509
region and sorry

00:37:45,240 --> 00:37:53,820
I think I think the problem is and when

00:37:51,600 --> 00:37:58,500
you have K exit load so you don't have

00:37:53,820 --> 00:38:01,860
any reserved memory so you have to copy

00:37:58,500 --> 00:38:11,640
the kernel somewhere but maybe you will

00:38:01,860 --> 00:38:15,480
need it on a difference yeah but well

00:38:11,640 --> 00:38:18,630
when okay sorry this memory is is

00:38:15,480 --> 00:38:21,750
reserved and used if you load a capture

00:38:18,630 --> 00:38:23,730
curl with HP if you load that kernel to

00:38:21,750 --> 00:38:26,880
just reboot to a new kernel without any

00:38:23,730 --> 00:38:29,280
crash then you use - L and then it works

00:38:26,880 --> 00:38:32,460
differently you don't use you don't need

00:38:29,280 --> 00:38:35,460
you don't need the reverse reverse

00:38:32,460 --> 00:38:40,800
memory and and that they don't use it

00:38:35,460 --> 00:38:59,100
but I am not 100% sure this works to be

00:38:40,800 --> 00:39:03,110
honest yeah I mean yeah you can if use

00:38:59,100 --> 00:39:06,120
if you set up your inner D to store the

00:39:03,110 --> 00:39:09,390
to store the dump file on a remote

00:39:06,120 --> 00:39:12,870
machine that that's possible and then

00:39:09,390 --> 00:39:15,480
you don't touch the your local file

00:39:12,870 --> 00:39:17,880
system and then you can have a look on

00:39:15,480 --> 00:39:36,570
the dump and on the file systems to

00:39:17,880 --> 00:39:38,250
check what happened yeah well as far as

00:39:36,570 --> 00:39:39,180
I know there's no solution for that so

00:39:38,250 --> 00:39:42,840
you have to decide

00:39:39,180 --> 00:39:42,840
[Laughter]

00:39:48,300 --> 00:39:54,780
things I think the problem is you don't

00:39:49,860 --> 00:39:57,090
have any but well I think it's difficult

00:39:54,780 --> 00:40:00,830
I mean you would have to know when they

00:39:57,090 --> 00:40:00,830
capture system boy your system crashed

00:40:02,870 --> 00:40:22,920
yes yes but I mean there yeah I mean the

00:40:19,170 --> 00:40:25,290
possibility would be to reach the the

00:40:22,920 --> 00:40:28,110
lock the kernel can lock from your

00:40:25,290 --> 00:40:31,860
crashed system and then try to identify

00:40:28,110 --> 00:40:37,730
if it's file system or if it's something

00:40:31,860 --> 00:40:37,730
else it's possible but might be painful

00:40:39,950 --> 00:40:45,420
[Laughter]

00:40:50,170 --> 00:40:53,239
[Music]

00:40:57,530 --> 00:41:21,270
yes I mean for its so on in decay x''k

00:41:19,230 --> 00:41:23,790
tools I have like an architecture part

00:41:21,270 --> 00:41:26,940
which basically does all the loading of

00:41:23,790 --> 00:41:28,560
see kernel and the unit RT and creating

00:41:26,940 --> 00:41:31,200
all the earth core header but the

00:41:28,560 --> 00:41:35,550
creating the l squared is its generic

00:41:31,200 --> 00:41:43,110
but you I think the most important thing

00:41:35,550 --> 00:41:44,760
that you have to the most important

00:41:43,110 --> 00:41:49,230
thing but what you have to think about

00:41:44,760 --> 00:41:51,810
is how to do this right how to how to

00:41:49,230 --> 00:41:53,910
pass information to the kernel so non 64

00:41:51,810 --> 00:41:56,790
views device tree I don't know how it is

00:41:53,910 --> 00:41:59,820
done on on Intel for example I have no

00:41:56,790 --> 00:42:02,070
idea how they do it then for example

00:41:59,820 --> 00:42:04,950
when they implemented this on

00:42:02,070 --> 00:42:07,680
sixty-four that was a long discussion if

00:42:04,950 --> 00:42:10,550
they can add elf core header as an

00:42:07,680 --> 00:42:13,650
device tree in as a device tree property

00:42:10,550 --> 00:42:15,450
other systems use elf core header and

00:42:13,650 --> 00:42:18,980
they put command line I don't know why

00:42:15,450 --> 00:42:27,630
in arms I didn't do they didn't do that

00:42:18,980 --> 00:42:30,290
that would be a possibility and yeah any

00:42:27,630 --> 00:42:30,290
other question

00:42:31,100 --> 00:42:34,760
okay thank you very much

00:42:42,640 --> 00:42:44,700

YouTube URL: https://www.youtube.com/watch?v=E1tBFbGEk_A


