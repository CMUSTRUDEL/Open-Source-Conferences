Title: openSUSE Conference 2018 - Cross-compilers for lizards, two years later
Publication date: 2018-05-27
Playlist: openSUSE Conference 2018
Description: 
	https://media.ccc.de/v/1861-cross-compilers-for-lizards-two-years-later

Improving the microcontroller tooling

A few years ago we started adding cross-compiler packages to Tumbleweed, based on our maintained GCC packages. There have been two recent toolchain additions, more are still in the works, and several challenges remain - such as on our end Leap and PackageHub.

A few years ago we started adding cross-compiler packages to Tumbleweed, based on our maintained GCC packages. There have been two recent toolchain additions, more are still in the works, and several challenges remain - such as on our end Leap and PackageHub.

Andreas Färber
Captions: 
	00:00:08,480 --> 00:00:14,910
good morning let's get started

00:00:11,610 --> 00:00:17,910
my name is Matthias Nava I'm a project

00:00:14,910 --> 00:00:21,779
manager for the architecture at Souza

00:00:17,910 --> 00:00:25,050
labs and right now I'm going to give you

00:00:21,779 --> 00:00:34,380
an update on the cross compiler tool

00:00:25,050 --> 00:00:38,850
chains for openSUSE so first of all what

00:00:34,380 --> 00:00:39,719
is this about this is not about systems

00:00:38,850 --> 00:00:42,270
that are actually running

00:00:39,719 --> 00:00:45,120
openSUSE at least not in general but

00:00:42,270 --> 00:00:47,160
rather about small microcontroller

00:00:45,120 --> 00:00:52,050
systems that don't have a whole lot of

00:00:47,160 --> 00:00:54,660
RAM and code storage but at some point

00:00:52,050 --> 00:00:57,149
you want to develop software for to

00:00:54,660 --> 00:00:59,129
deploy on such microcontrollers you want

00:00:57,149 --> 00:01:01,800
to get the code that you have developed

00:00:59,129 --> 00:01:03,780
on to such microcontroller boards and

00:01:01,800 --> 00:01:07,740
once you have that maybe there are

00:01:03,780 --> 00:01:09,479
problems and you need to debug them so

00:01:07,740 --> 00:01:13,830
I'm gonna run through all of those

00:01:09,479 --> 00:01:15,420
stages more or less two years ago it

00:01:13,830 --> 00:01:18,450
opens with a conference in nürnberg I

00:01:15,420 --> 00:01:20,729
had presented um the first real cross

00:01:18,450 --> 00:01:22,350
compiler work so we had some ice cream

00:01:20,729 --> 00:01:26,150
cross compilers before that could be

00:01:22,350 --> 00:01:29,909
used for developing like kernels for

00:01:26,150 --> 00:01:32,490
systems running openSUSE so that you

00:01:29,909 --> 00:01:35,400
could take an x86 system and develop

00:01:32,490 --> 00:01:39,090
kernels for s/390 originally or also for

00:01:35,400 --> 00:01:41,670
power and later arm and now it was also

00:01:39,090 --> 00:01:44,850
possible to develop with a standard c

00:01:41,670 --> 00:01:48,270
library code for and non open to the

00:01:44,850 --> 00:01:50,970
targets the first one was the Epiphany

00:01:48,270 --> 00:01:53,700
target and this was used for the

00:01:50,970 --> 00:01:56,490
parallel abort and a crowdfunded

00:01:53,700 --> 00:01:59,250
arm board which has an fpga and via the

00:01:56,490 --> 00:02:03,060
fpga it connects to this coprocessor

00:01:59,250 --> 00:02:07,530
chip and then the other one the second

00:02:03,060 --> 00:02:09,840
one was for rx ran as extreme because

00:02:07,530 --> 00:02:11,020
there was the Sacre board and also some

00:02:09,840 --> 00:02:14,770
other boards

00:02:11,020 --> 00:02:23,140
that it was possible to actually deploy

00:02:14,770 --> 00:02:24,640
the co2 so just for completeness what

00:02:23,140 --> 00:02:26,890
existed as well as I mentioned there's

00:02:24,640 --> 00:02:28,540
also cost compilers for openSUSE in

00:02:26,890 --> 00:02:30,550
particular for openSUSE kernels not

00:02:28,540 --> 00:02:32,950
really for open to the applications and

00:02:30,550 --> 00:02:36,640
there's the client compiler tool train

00:02:32,950 --> 00:02:39,010
as part of the LLVM package which

00:02:36,640 --> 00:02:41,800
provides several targets depending on

00:02:39,010 --> 00:02:45,610
how it's being configured for us but at

00:02:41,800 --> 00:02:49,510
least for x86 64 we built pretty much

00:02:45,610 --> 00:02:52,840
almost everything we can there's also a

00:02:49,510 --> 00:02:55,180
tool called SCC which is its own

00:02:52,840 --> 00:02:57,160
compiler tool chain and is being used

00:02:55,180 --> 00:03:01,480
for micro controllers that have less

00:02:57,160 --> 00:03:03,220
than 32 bits so for example STM 8 which

00:03:01,480 --> 00:03:07,570
is you know 8-bit microcontroller and

00:03:03,220 --> 00:03:12,640
the 8051 architecture as well among

00:03:07,570 --> 00:03:16,240
others so moving on to what is actually

00:03:12,640 --> 00:03:19,780
new this year so Ritchie has been

00:03:16,240 --> 00:03:22,540
working on avoiding the need to specify

00:03:19,780 --> 00:03:25,180
the cross compilers by the exact version

00:03:22,540 --> 00:03:27,280
name so the way that they are built we

00:03:25,180 --> 00:03:29,800
and they are built as part of the GCC 7

00:03:27,280 --> 00:03:31,540
jesusí 8 and so on packages and that

00:03:29,800 --> 00:03:34,390
means that the binary that gets

00:03:31,540 --> 00:03:38,140
generated within the end be something -

00:03:34,390 --> 00:03:40,240
GCC - 8 for example and but normally

00:03:38,140 --> 00:03:42,070
make files when you build an open source

00:03:40,240 --> 00:03:45,970
packages will assume that you simply

00:03:42,070 --> 00:03:48,430
have a CC or GCC compiler with a cross

00:03:45,970 --> 00:03:50,470
compiler prefix so this would require

00:03:48,430 --> 00:03:52,600
either Patric make files or at least

00:03:50,470 --> 00:03:54,910
overriding like a handful of different

00:03:52,600 --> 00:04:00,280
variables in order to be able to use

00:03:54,910 --> 00:04:03,070
such a tool train using the alternatives

00:04:00,280 --> 00:04:06,310
mechanism we now get some links from GCC

00:04:03,070 --> 00:04:08,140
to GCC 7 or Jesus the 8 whatever is has

00:04:06,310 --> 00:04:10,989
been installed and the latest token M

00:04:08,140 --> 00:04:14,709
configured by the user which insurance

00:04:10,989 --> 00:04:20,350
allows us to just use this do we have

00:04:14,709 --> 00:04:22,890
any laser pointer here no so we can just

00:04:20,350 --> 00:04:22,890
use this

00:04:29,050 --> 00:04:33,110
automatic you can you can see it anyway

00:04:31,130 --> 00:04:35,180
so this cross-compiled variable should

00:04:33,110 --> 00:04:37,340
in most cases now be the only one that

00:04:35,180 --> 00:04:40,000
you use and food ash would be the prefix

00:04:37,340 --> 00:04:41,230
and that is being generated for the

00:04:40,000 --> 00:04:45,800
specific

00:04:41,230 --> 00:04:49,490
tool train so that would be our X - elf

00:04:45,800 --> 00:04:54,190
- would be the cost compiled perfect and

00:04:49,490 --> 00:04:57,590
then GCC eld and so on all the tools a

00:04:54,190 --> 00:04:59,660
second development was that after a

00:04:57,590 --> 00:05:02,600
phase of announcement we moved the new

00:04:59,660 --> 00:05:06,110
leap package from base system where it

00:05:02,600 --> 00:05:08,150
was alongside gilepsy and a user Lipsy

00:05:06,110 --> 00:05:10,220
into the DPL DCC package which has the

00:05:08,150 --> 00:05:12,740
advantage that we can better stage

00:05:10,220 --> 00:05:14,750
changes because then we have GCC and you

00:05:12,740 --> 00:05:16,580
live in the same place in particular

00:05:14,750 --> 00:05:19,460
when we add new tool trains otherwise we

00:05:16,580 --> 00:05:21,770
always have a or we still have a cyclic

00:05:19,460 --> 00:05:23,780
dependency between the packages but at

00:05:21,770 --> 00:05:28,580
least there we can test it before it all

00:05:23,780 --> 00:05:30,470
goes to factory and while the remaining

00:05:28,580 --> 00:05:35,450
problem with that is that we always need

00:05:30,470 --> 00:05:37,729
to take care to submit both the GCC

00:05:35,450 --> 00:05:40,370
package and the newly package or

00:05:37,729 --> 00:05:42,470
whatever C library is being used for the

00:05:40,370 --> 00:05:44,419
respective factory there's also AM maybe

00:05:42,470 --> 00:05:48,110
our lip see for example possibly further

00:05:44,419 --> 00:05:49,370
ones they always need to be submitted

00:05:48,110 --> 00:05:51,460
together and this hasn't always worked

00:05:49,370 --> 00:05:57,470
out that sometimes we had unresolvable

00:05:51,460 --> 00:06:00,229
Jesus Lee cost packages in factory what

00:05:57,470 --> 00:06:03,050
is new for my site this here is that for

00:06:00,229 --> 00:06:05,120
several months now we have an new arm

00:06:03,050 --> 00:06:08,180
cross compiler tool train which is able

00:06:05,120 --> 00:06:10,610
to develop code for use in either

00:06:08,180 --> 00:06:12,350
firmware or microcontrollers so that

00:06:10,610 --> 00:06:15,530
would be the cortex-m class of

00:06:12,350 --> 00:06:18,560
processors as well as the cortex a class

00:06:15,530 --> 00:06:22,630
where we don't need anything specific

00:06:18,560 --> 00:06:26,000
this was originally driven by the

00:06:22,630 --> 00:06:27,289
spectra and meltdown security

00:06:26,000 --> 00:06:30,650
vulnerabilities that I will be going

00:06:27,289 --> 00:06:32,840
into in the next presentation slot we

00:06:30,650 --> 00:06:35,570
needed to update a software package from

00:06:32,840 --> 00:06:37,850
version 1.4 to 1.5 and suddenly

00:06:35,570 --> 00:06:40,820
Guha dependency are not just compiling

00:06:37,850 --> 00:06:43,340
code for either 64-bit arm code or

00:06:40,820 --> 00:06:45,830
32-bit arm code but it needed both in

00:06:43,340 --> 00:06:49,010
the same package so as a solution we

00:06:45,830 --> 00:06:52,000
would be building it on a at 64 using

00:06:49,010 --> 00:06:56,030
the native GCC there but also using this

00:06:52,000 --> 00:06:57,920
new cost compiler I'm in order to DM to

00:06:56,030 --> 00:07:02,930
build parts of that code that would be

00:06:57,920 --> 00:07:04,610
reused in that the exact list of where

00:07:02,930 --> 00:07:06,890
you can use this compiler quatrain is

00:07:04,610 --> 00:07:08,120
probably much longer than what I've

00:07:06,890 --> 00:07:09,380
listed there I'm not going to read all

00:07:08,120 --> 00:07:12,980
of this

00:07:09,380 --> 00:07:14,960
what's noted in in brackets there is the

00:07:12,980 --> 00:07:18,880
various ways that you can actually get

00:07:14,960 --> 00:07:18,880
the code onto the board so

00:07:19,510 --> 00:07:24,190
STMicroelectronics has their own st-link

00:07:21,740 --> 00:07:27,650
mechanism which is a USB adapter that

00:07:24,190 --> 00:07:31,580
several tools exist for getting the code

00:07:27,650 --> 00:07:33,560
onto the board then there's the cmss tab

00:07:31,580 --> 00:07:35,570
standard that was developed by arm which

00:07:33,560 --> 00:07:38,180
has also used be taste with two

00:07:35,570 --> 00:07:41,150
different tools available to get that on

00:07:38,180 --> 00:07:44,000
there and and there's the J link as well

00:07:41,150 --> 00:07:46,700
as in some cases you have systems with

00:07:44,000 --> 00:07:49,670
heterogeneous course where you have both

00:07:46,700 --> 00:07:51,530
cortex a and cortex-m cores and then you

00:07:49,670 --> 00:07:56,180
can just boot into the Linux system and

00:07:51,530 --> 00:07:58,960
use certain commands to move to to put

00:07:56,180 --> 00:08:01,310
code in place to be executed by the

00:07:58,960 --> 00:08:04,720
microcontroller course or real-time

00:08:01,310 --> 00:08:04,720
course part of that system

00:08:06,940 --> 00:08:14,420
what is relatively new still is that we

00:08:11,060 --> 00:08:18,980
not only have a port of openSUSE running

00:08:14,420 --> 00:08:21,290
on the risk 5 architecture but rather

00:08:18,980 --> 00:08:23,330
that we also have a cost compiler in

00:08:21,290 --> 00:08:27,560
order to develop code for the initial

00:08:23,330 --> 00:08:30,910
set of risk 5 microcontroller board so

00:08:27,560 --> 00:08:34,099
in particular here the high 5 1 was

00:08:30,910 --> 00:08:35,900
quite known in the press I have to admit

00:08:34,099 --> 00:08:38,419
that I have not yet test that is on the

00:08:35,900 --> 00:08:40,460
board actually because we don't here to

00:08:38,419 --> 00:08:44,240
have our packages set up in order to

00:08:40,460 --> 00:08:45,800
actually get the code onto the board has

00:08:44,240 --> 00:08:48,970
anyone in the audience maybe

00:08:45,800 --> 00:08:48,970
experimented with that already

00:08:49,840 --> 00:09:02,120
no one okay oh no this is this is what

00:08:58,280 --> 00:09:06,290
you are thinking of is the higher end

00:09:02,120 --> 00:09:07,940
unleashed but which is like 999 but

00:09:06,290 --> 00:09:09,680
that's the one that can actually run the

00:09:07,940 --> 00:09:10,940
next now this is a small one that's just

00:09:09,680 --> 00:09:13,430
Arduino form-factor

00:09:10,940 --> 00:09:24,140
and can run only microcontroller core no

00:09:13,430 --> 00:09:25,520
Linux and not taking credit for this

00:09:24,140 --> 00:09:27,670
myself there were several people that

00:09:25,520 --> 00:09:30,440
have also been working on integrating

00:09:27,670 --> 00:09:34,960
AVR toolchains that were previously in a

00:09:30,440 --> 00:09:39,080
separate cost tool train project into

00:09:34,960 --> 00:09:41,360
this new set of GCC packages which

00:09:39,080 --> 00:09:43,970
Rodina has been integrating that one of

00:09:41,360 --> 00:09:46,160
the tool tray maintainer z' and while

00:09:43,970 --> 00:09:47,960
there's a lots and lots of boards in

00:09:46,160 --> 00:09:49,760
particular the original arduino boards

00:09:47,960 --> 00:09:52,490
and several clones of that that can be

00:09:49,760 --> 00:09:54,740
used with them there's also tools like

00:09:52,490 --> 00:09:56,720
maybe our dude is one that can be used

00:09:54,740 --> 00:10:01,460
to just get that virus silk connection

00:09:56,720 --> 00:10:06,020
onto and the board's moving on to some

00:10:01,460 --> 00:10:07,850
stuff that is not yet in factory we've

00:10:06,020 --> 00:10:11,570
been in contact with a company called

00:10:07,850 --> 00:10:13,490
andis in order to make packages

00:10:11,570 --> 00:10:16,010
available for their proprietary

00:10:13,490 --> 00:10:18,920
microcontroller architecture so they are

00:10:16,010 --> 00:10:20,500
also working on risk 5 and this is the

00:10:18,920 --> 00:10:25,090
previous generation of boards that

00:10:20,500 --> 00:10:28,610
they've come up with and another one is

00:10:25,090 --> 00:10:30,680
FD 32 which is from formerly from FTDI

00:10:28,610 --> 00:10:33,110
the company that makes the use be UART

00:10:30,680 --> 00:10:37,430
adapter amp chips by now that it's

00:10:33,110 --> 00:10:40,310
called bridge tech and yeah there are

00:10:37,430 --> 00:10:43,250
also some low cost boards available that

00:10:40,310 --> 00:10:46,730
the code can actually be used with

00:10:43,250 --> 00:10:48,890
however yet again we don't yet have

00:10:46,730 --> 00:11:00,760
packaged the tools to actually get the

00:10:48,890 --> 00:11:04,940
code onto those boards open topics so

00:11:00,760 --> 00:11:07,910
whenever we build cross compiler cost

00:11:04,940 --> 00:11:09,920
compiled code so that means like the new

00:11:07,910 --> 00:11:12,800
lip and packages that would actually

00:11:09,920 --> 00:11:16,010
execute not on your local system but on

00:11:12,800 --> 00:11:18,950
the microcontroller board or as part of

00:11:16,010 --> 00:11:24,920
some other quorum on on jellineck's

00:11:18,950 --> 00:11:27,620
board whenever the OBS and rpm scripts

00:11:24,920 --> 00:11:30,170
run in order to extract the debug info

00:11:27,620 --> 00:11:34,790
symbols into a separate package then

00:11:30,170 --> 00:11:36,680
that has led to binaries for foreign

00:11:34,790 --> 00:11:38,780
architectures breaking I'm not entirely

00:11:36,680 --> 00:11:41,780
sure why that is but we've needed to

00:11:38,780 --> 00:11:44,150
always explicitly disable the stripping

00:11:41,780 --> 00:11:46,280
and extraction of those debug symbols

00:11:44,150 --> 00:11:48,770
and from the packages would be

00:11:46,280 --> 00:11:50,270
interesting to find out why that is and

00:11:48,770 --> 00:11:52,160
whether we maybe can fix that in a

00:11:50,270 --> 00:11:55,400
central place instead of in every

00:11:52,160 --> 00:11:57,500
package so if you want to build some

00:11:55,400 --> 00:11:59,330
general-purpose library or some firmware

00:11:57,500 --> 00:12:02,420
then you would need to add at least two

00:11:59,330 --> 00:12:08,660
lines to your spec file to suppress this

00:12:02,420 --> 00:12:11,210
functionality the second one is that in

00:12:08,660 --> 00:12:13,790
theory we could sit down and build I

00:12:11,210 --> 00:12:16,700
don't know maybe 20 or something cross

00:12:13,790 --> 00:12:18,530
compiler tool trains but for one that

00:12:16,700 --> 00:12:21,110
would take quite long to build whenever

00:12:18,530 --> 00:12:23,630
the GCC TM team checks in a new revision

00:12:21,110 --> 00:12:31,330
of the compiler or maybe some patch in

00:12:23,630 --> 00:12:36,650
OBS and for another originally we had

00:12:31,330 --> 00:12:42,020
packaged the cross compiles for for a

00:12:36,650 --> 00:12:44,150
number of probably months but we figured

00:12:42,020 --> 00:12:46,910
out that the installation that certain

00:12:44,150 --> 00:12:52,880
binaries were getting installed too was

00:12:46,910 --> 00:12:55,100
not v1 we're at run time that were being

00:12:52,880 --> 00:12:57,140
expected so we had built successfully

00:12:55,100 --> 00:12:58,840
compilers but they were not fully

00:12:57,140 --> 00:13:03,090
working at run time in order

00:12:58,840 --> 00:13:06,370
to find like certain CR T dot o files

00:13:03,090 --> 00:13:09,970
and basically what we're at the moment

00:13:06,370 --> 00:13:12,310
still lacking is some package and we're

00:13:09,970 --> 00:13:14,410
still discussing how exactly to do that

00:13:12,310 --> 00:13:17,110
maybe one of you had suggestions for how

00:13:14,410 --> 00:13:19,870
to do that for just and compiling like a

00:13:17,110 --> 00:13:22,060
small hello world example to make sure

00:13:19,870 --> 00:13:25,000
that the compiler tool chain is in

00:13:22,060 --> 00:13:28,480
itself consistent so it would not be so

00:13:25,000 --> 00:13:30,910
much about desert compile code that is

00:13:28,480 --> 00:13:32,890
actually working on a specific CPU

00:13:30,910 --> 00:13:35,260
there's other test suites for that but

00:13:32,890 --> 00:13:38,290
rather just for validating that if we

00:13:35,260 --> 00:13:40,540
build the GCC seven and Jesus the a tool

00:13:38,290 --> 00:13:43,960
train for particular architecture that

00:13:40,540 --> 00:13:50,850
each one of those actually works as

00:13:43,960 --> 00:13:53,110
expected and finally one topic that I

00:13:50,850 --> 00:13:55,090
mentioned yesterday and the package hub

00:13:53,110 --> 00:13:57,490
talk is that it would also be cool if we

00:13:55,090 --> 00:13:59,560
could make some of those cost compilers

00:13:57,490 --> 00:14:02,880
available not just for openSUSE in the

00:13:59,560 --> 00:14:06,100
OBS but also for the commercial

00:14:02,880 --> 00:14:08,230
enterprise family of products and there

00:14:06,100 --> 00:14:10,300
are certain rules at the moment that

00:14:08,230 --> 00:14:12,640
stand in the way of this in that

00:14:10,300 --> 00:14:15,730
obviously Zeus is already shipping GCC

00:14:12,640 --> 00:14:19,270
compilers and for compilation of sleek

00:14:15,730 --> 00:14:21,430
code and as such we cannot just submit

00:14:19,270 --> 00:14:23,200
the GCC seven jesus the eight packages

00:14:21,430 --> 00:14:25,930
that those cross compilers are now part

00:14:23,200 --> 00:14:27,820
of into package shop because that would

00:14:25,930 --> 00:14:36,310
conflict with the package instead suzie

00:14:27,820 --> 00:14:38,230
is providing so at this point we have

00:14:36,310 --> 00:14:40,750
cross compiler to trends were able to

00:14:38,230 --> 00:14:43,570
turn source code that we've written

00:14:40,750 --> 00:14:45,280
ourselves into code to be run on such

00:14:43,570 --> 00:14:50,140
microcontrollers now how do we actually

00:14:45,280 --> 00:14:52,000
get that onto the boards my preferred

00:14:50,140 --> 00:14:56,970
solution for that is a package called

00:14:52,000 --> 00:14:56,970
open o CD short for on trip to bugger

00:14:58,020 --> 00:15:05,440
unfortunately the development of the

00:15:01,930 --> 00:15:08,800
package has not stalled but the releases

00:15:05,440 --> 00:15:11,200
are currently quite for i guess more

00:15:08,800 --> 00:15:12,170
than a year there's been no release but

00:15:11,200 --> 00:15:13,910
there is active

00:15:12,170 --> 00:15:16,760
development going on with the Garrett

00:15:13,910 --> 00:15:21,709
review system and um changes going into

00:15:16,760 --> 00:15:25,279
the project are are getting reviewed

00:15:21,709 --> 00:15:27,079
quite rigorously usually so my proposal

00:15:25,279 --> 00:15:28,910
would be that instead of sticking with

00:15:27,079 --> 00:15:31,399
is retort and release that is currently

00:15:28,910 --> 00:15:33,800
out there for tumbleweed it should be

00:15:31,399 --> 00:15:35,990
okay if we would actually switch to kid

00:15:33,800 --> 00:15:39,139
snapshots simply because then we could

00:15:35,990 --> 00:15:41,870
have like support for more trip sells

00:15:39,139 --> 00:15:46,250
every few weeks per month whenever

00:15:41,870 --> 00:15:50,329
something new comes out the problem with

00:15:46,250 --> 00:15:52,750
that is that there are dependencies that

00:15:50,329 --> 00:15:55,370
open OCD has a one library for

00:15:52,750 --> 00:16:00,410
interfacing with those trade link use be

00:15:55,370 --> 00:16:05,500
adapters it also uses TCL runtime so

00:16:00,410 --> 00:16:08,899
there may be points in time where the

00:16:05,500 --> 00:16:11,420
snapshot of open OCD may also require a

00:16:08,899 --> 00:16:16,279
snapshot of say lib trailing so that

00:16:11,420 --> 00:16:18,589
would be a trade off to make there's

00:16:16,279 --> 00:16:21,230
another tool and package most recently

00:16:18,589 --> 00:16:23,480
called piyo CD it was originally just

00:16:21,230 --> 00:16:25,790
the Python library for interfacing with

00:16:23,480 --> 00:16:30,350
embed boards that are based on this and

00:16:25,790 --> 00:16:32,510
CMS's tab standard more recently it has

00:16:30,350 --> 00:16:35,120
also grown some tools that can be run

00:16:32,510 --> 00:16:38,870
with a command line with a lot of

00:16:35,120 --> 00:16:41,720
arguments for just am starting a gdb

00:16:38,870 --> 00:16:45,339
server and then via gdb you can get your

00:16:41,720 --> 00:16:45,339
code onto the board

00:16:48,250 --> 00:16:53,800
and finally the latest edition from

00:16:50,860 --> 00:16:56,610
eyesight was the ESP jewel package so

00:16:53,800 --> 00:17:00,850
this is for expressive ESP thirty-two

00:16:56,610 --> 00:17:04,170
esp8266 and so on boards and based on

00:17:00,850 --> 00:17:04,170
the extensive architecture

00:17:04,589 --> 00:17:11,770
unfortunately the tool chain for

00:17:09,370 --> 00:17:13,870
building the code is not yet fully

00:17:11,770 --> 00:17:17,199
upstream so that we cannot really put

00:17:13,870 --> 00:17:19,240
that into factory yet but I'm in touch

00:17:17,199 --> 00:17:27,720
with them about hopefully getting that

00:17:19,240 --> 00:17:33,970
done in the future so yeah me some

00:17:27,720 --> 00:17:36,760
closing remarks there was the question

00:17:33,970 --> 00:17:41,250
already about a risk five so slightly

00:17:36,760 --> 00:17:44,530
related to that if you have a board that

00:17:41,250 --> 00:17:48,190
does not have an MMU but has sufficient

00:17:44,530 --> 00:17:51,040
ram at least on arm and a few other

00:17:48,190 --> 00:17:53,680
architectures it is possible to run not

00:17:51,040 --> 00:17:57,430
just micro controller firmware code but

00:17:53,680 --> 00:18:00,280
also an embedded Linux not provided by

00:17:57,430 --> 00:18:03,450
openSUSE but using our tools it can

00:18:00,280 --> 00:18:07,330
easily be built from the Linux sources

00:18:03,450 --> 00:18:11,170
there are various ways to go about that

00:18:07,330 --> 00:18:16,780
so the most frequent case is to use the

00:18:11,170 --> 00:18:19,210
UC lips Eng and they're what I have been

00:18:16,780 --> 00:18:21,310
working with so far is the flat tool

00:18:19,210 --> 00:18:23,500
train which means that you build elf

00:18:21,310 --> 00:18:27,670
binaries and then you convert them to a

00:18:23,500 --> 00:18:30,700
special flat format st has also proposed

00:18:27,670 --> 00:18:34,390
a new API called FD peak this has been

00:18:30,700 --> 00:18:37,360
existing for like Blackfin for example

00:18:34,390 --> 00:18:39,220
for quite some time already the proposal

00:18:37,360 --> 00:18:41,110
now is to do such a tool chain for arm

00:18:39,220 --> 00:18:41,860
as well it has been there's a

00:18:41,110 --> 00:18:43,660
proof-of-concept

00:18:41,860 --> 00:18:48,390
out there but it is not yet merged in

00:18:43,660 --> 00:18:55,470
the upstream M GCC project this would

00:18:48,390 --> 00:18:57,790
allow to reuse libraries between

00:18:55,470 --> 00:19:00,120
executables even without having their

00:18:57,790 --> 00:19:03,460
own virtual address spaces

00:19:00,120 --> 00:19:07,810
and some of the examples that I've

00:19:03,460 --> 00:19:12,040
tested this on has been the stm32f4 FM

00:19:07,810 --> 00:19:19,600
for originally from Fujitsu and the xmc

00:19:12,040 --> 00:19:22,900
4500 then another remark going slightly

00:19:19,600 --> 00:19:25,600
beyond micro controllers FPGA field

00:19:22,900 --> 00:19:28,780
programmable gate arrays is a way that

00:19:25,600 --> 00:19:31,230
you can not just develop software but

00:19:28,780 --> 00:19:35,770
Hardware based on software descriptions

00:19:31,230 --> 00:19:37,870
so you can configure you know or or and

00:19:35,770 --> 00:19:43,510
gates and you have local memory in there

00:19:37,870 --> 00:19:46,420
that you can also have local storage on

00:19:43,510 --> 00:19:50,410
and using this one thing you can do is

00:19:46,420 --> 00:19:53,920
you can implement soft core processors

00:19:50,410 --> 00:19:56,920
so you can actually have an FPGA chip

00:19:53,920 --> 00:19:59,980
and emulate in theory well on arm system

00:19:56,920 --> 00:20:02,610
or risk 5 is at the moment quite popular

00:19:59,980 --> 00:20:04,990
because for a long time there were no

00:20:02,610 --> 00:20:09,790
physical boards that you could run the

00:20:04,990 --> 00:20:12,010
code on which then opens a whole lot of

00:20:09,790 --> 00:20:14,050
range of use cases that people might

00:20:12,010 --> 00:20:15,520
have likes eiling's has those micro

00:20:14,050 --> 00:20:18,100
plays soft cores

00:20:15,520 --> 00:20:22,360
nya's is another one from another vendor

00:20:18,100 --> 00:20:24,400
open risk has seen a few uses and who

00:20:22,360 --> 00:20:27,580
knows what other cores there are or

00:20:24,400 --> 00:20:30,010
maybe in the future so that will be

00:20:27,580 --> 00:20:31,960
something to keep an eye on on whether

00:20:30,010 --> 00:20:34,030
there is any demand for that and the

00:20:31,960 --> 00:20:35,710
cool thing is that out of all those

00:20:34,030 --> 00:20:40,390
families well usually if you go to

00:20:35,710 --> 00:20:42,100
Xilinx lattice micro semi then you know

00:20:40,390 --> 00:20:43,930
they all have their proprietary tool

00:20:42,100 --> 00:20:46,090
trains in order to generate that code

00:20:43,930 --> 00:20:50,110
from a standard VHDL or very lock

00:20:46,090 --> 00:20:52,120
description but for ice 40mm a few years

00:20:50,110 --> 00:20:53,920
back someone has actually started

00:20:52,120 --> 00:20:55,990
reverse engineering the format needed

00:20:53,920 --> 00:20:58,060
for that and there are now open source

00:20:55,990 --> 00:21:00,580
tools in order to develop for this

00:20:58,060 --> 00:21:03,490
family of admittedly slightly smaller

00:21:00,580 --> 00:21:09,390
FPGAs but still it is a very interesting

00:21:03,490 --> 00:21:11,309
start with that I am done

00:21:09,390 --> 00:21:20,100
are there any for the questions in the

00:21:11,309 --> 00:21:46,320
audience Andrew shall we get you a

00:21:20,100 --> 00:21:49,740
microphone not walking yeah the the

00:21:46,320 --> 00:21:52,530
packages all in factory for all

00:21:49,740 --> 00:21:57,299
architectures so that if you wanted to

00:21:52,530 --> 00:21:59,340
cross compile on arm you could or on x86

00:21:57,299 --> 00:22:05,299
or power whatever so it's all available

00:21:59,340 --> 00:22:07,830
in factory now yes so there are no

00:22:05,299 --> 00:22:10,140
restrictions as to the code working and

00:22:07,830 --> 00:22:13,860
in factory arm you will find obviously

00:22:10,140 --> 00:22:20,059
the the corresponding packages for arm

00:22:13,860 --> 00:22:22,860
hosts what is I think not enabled is the

00:22:20,059 --> 00:22:24,870
the development project de velde CC does

00:22:22,860 --> 00:22:25,740
not have all architectures enable so

00:22:24,870 --> 00:22:27,270
they're not building the full

00:22:25,740 --> 00:22:30,030
architecture in some cases where I've

00:22:27,270 --> 00:22:32,610
said you know for example the prime use

00:22:30,030 --> 00:22:34,830
case of cross developing epiphany is on

00:22:32,610 --> 00:22:36,570
arm v7 so that's like one tool train

00:22:34,830 --> 00:22:38,490
that we have specifically enabled there

00:22:36,570 --> 00:22:40,500
to build but I don't think that all of

00:22:38,490 --> 00:22:42,210
them are available there but if you take

00:22:40,500 --> 00:22:44,900
a look at the ones in factory then yes

00:22:42,210 --> 00:22:49,290
there is no restriction on building them

00:22:44,900 --> 00:22:54,780
that I should be aware of so yes we have

00:22:49,290 --> 00:22:58,320
been we have been using as I mentioned

00:22:54,780 --> 00:23:00,870
the cross arm non tool chain on a at 64

00:22:58,320 --> 00:23:02,730
so even one arm you can cross compiled

00:23:00,870 --> 00:23:06,230
for other arm systems that would be the

00:23:02,730 --> 00:23:09,179
other thing to to look out for because

00:23:06,230 --> 00:23:11,370
we would not build a at 64 cross

00:23:09,179 --> 00:23:12,840
compilers on a at 64 that's the

00:23:11,370 --> 00:23:14,580
restriction that we have so if the name

00:23:12,840 --> 00:23:16,020
is different of the architectures that

00:23:14,580 --> 00:23:20,980
we're building them for then that should

00:23:16,020 --> 00:23:27,169
work any last question

00:23:20,980 --> 00:23:29,630
yes I didn't hear you mention the GCC -

00:23:27,169 --> 00:23:33,830
AVR and the typical workflow where you

00:23:29,630 --> 00:23:36,409
use AVR due to program to Atmel 8-bit

00:23:33,830 --> 00:23:38,539
microcontrollers is this something that

00:23:36,409 --> 00:23:40,580
you work on and test and have packages

00:23:38,539 --> 00:23:43,690
for as well

00:23:40,580 --> 00:23:47,090
I personally don't I just know that the

00:23:43,690 --> 00:23:50,720
architects that the that the package

00:23:47,090 --> 00:23:54,830
exists I'm not sure it could be either

00:23:50,720 --> 00:23:58,730
in Hardware electronics or in cross tool

00:23:54,830 --> 00:24:00,230
train AVR but personally I'm out of all

00:23:58,730 --> 00:24:01,940
the odd architectures I work with I

00:24:00,230 --> 00:24:03,230
don't happen to actually have an AVR

00:24:01,940 --> 00:24:08,509
baseboard so I have not entered it

00:24:03,230 --> 00:24:10,129
myself yet I've had Arduino builds

00:24:08,509 --> 00:24:13,100
working doing that but I can't remember

00:24:10,129 --> 00:24:15,139
if I took during our studio from within

00:24:13,100 --> 00:24:19,070
IPS or if I just took our to be nice to

00:24:15,139 --> 00:24:25,669
do from upstream but it is possible to

00:24:19,070 --> 00:24:27,440
do without too much effort okay I guess

00:24:25,669 --> 00:24:30,200
we'll have to finish here thank you very

00:24:27,440 --> 00:24:31,879
much for your time and if you want to

00:24:30,200 --> 00:24:34,070
hear more about what we've done with the

00:24:31,879 --> 00:24:38,230
arm cross compiler toolchain stay tuned

00:24:34,070 --> 00:24:38,230
for the next talk thank you much

00:24:44,150 --> 00:24:46,210

YouTube URL: https://www.youtube.com/watch?v=HPHKjltjLrQ


