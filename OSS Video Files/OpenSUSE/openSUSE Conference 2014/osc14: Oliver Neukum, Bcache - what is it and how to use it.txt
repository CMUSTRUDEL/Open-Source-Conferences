Title: osc14: Oliver Neukum, Bcache - what is it and how to use it
Publication date: 2014-04-26
Playlist: openSUSE Conference 2014
Description: 
	SSDs are fast. They also cost a lot of money. To combine the speed of an SSD with the huge capacity of a rotational medium various caching solutions have been proposed. Some of them have found their way into the kernel and are easily usable with openSUSE. These solutions are briefly compared.
This talk shows the principle behind bcache, introduces the prerequisites of using it and demonstrates how to set up bcache on an added SSD to boost performance of an existing HD.
Captions: 
	00:00:00,000 --> 00:00:06,690
I'm going to talk first of all something

00:00:05,040 --> 00:00:10,309
about the principles of cash shame

00:00:06,690 --> 00:00:13,679
because be cash is a casual solution a

00:00:10,309 --> 00:00:17,400
brief overview about the available

00:00:13,679 --> 00:00:20,609
caching solutions so you can evaluate

00:00:17,400 --> 00:00:24,800
what I'm talking about then a bit into

00:00:20,609 --> 00:00:29,730
the theory of be cash how it can be used

00:00:24,800 --> 00:00:32,640
then some actual numbers my conclusions

00:00:29,730 --> 00:00:35,579
about it an overview about what left's

00:00:32,640 --> 00:00:40,820
to eat what is left to be done and time

00:00:35,579 --> 00:00:40,820
permitting and actual this demonstration

00:00:45,710 --> 00:00:54,960
okay so as these are cool they are

00:00:51,649 --> 00:00:59,309
unfortunately also quite expensive and

00:00:54,960 --> 00:01:04,129
small the small part could be rectified

00:00:59,309 --> 00:01:09,710
by employing many of them but that would

00:01:04,129 --> 00:01:12,659
make the expensive part even harder so

00:01:09,710 --> 00:01:16,650
we would like to have something that is

00:01:12,659 --> 00:01:24,500
as large as a normal rotational disk and

00:01:16,650 --> 00:01:27,630
as fast as an SSD and to understand the

00:01:24,500 --> 00:01:31,850
problem involved in that it's necessary

00:01:27,630 --> 00:01:36,450
to look a bit at the meaning of fast as

00:01:31,850 --> 00:01:39,659
these are fast yes but there are two

00:01:36,450 --> 00:01:42,950
meanings of fast either you can have a

00:01:39,659 --> 00:01:47,100
throughput or you can have latency and

00:01:42,950 --> 00:01:49,560
it turns out that while as these are

00:01:47,100 --> 00:01:53,130
quite good as throughput they're not

00:01:49,560 --> 00:01:59,460
great they're just good

00:01:53,130 --> 00:02:02,310
terms still works anyway in terms of

00:01:59,460 --> 00:02:05,460
through of latency they are practically

00:02:02,310 --> 00:02:10,319
unbeatable Ram is better but Ram has the

00:02:05,460 --> 00:02:12,950
problem with power so the terms of

00:02:10,319 --> 00:02:16,739
throughput are important because

00:02:12,950 --> 00:02:19,530
sometimes you're caching solution is not

00:02:16,739 --> 00:02:22,800
up just against one disk but against the

00:02:19,530 --> 00:02:24,630
raid array so the challenge in the

00:02:22,800 --> 00:02:28,319
caching solution is to have something

00:02:24,630 --> 00:02:31,739
that combines the speed in latency often

00:02:28,319 --> 00:02:35,040
SSD and does not take too much of a

00:02:31,739 --> 00:02:39,470
penalty for the administer overhead to

00:02:35,040 --> 00:02:43,739
worsen throughput so what's available

00:02:39,470 --> 00:02:46,650
stands status of a few months ago we

00:02:43,739 --> 00:02:49,680
have enhanced io which is derived from

00:02:46,650 --> 00:02:57,390
flash cache which was the first solution

00:02:49,680 --> 00:03:02,100
written for by Facebook enhance i/o is

00:02:57,390 --> 00:03:06,090
rewritten and now is read/write just

00:03:02,100 --> 00:03:11,910
instead of read-only and when it was

00:03:06,090 --> 00:03:14,910
still read only it generated as is often

00:03:11,910 --> 00:03:19,430
the case a rival project cost be called

00:03:14,910 --> 00:03:24,450
be cash the main difference here is the

00:03:19,430 --> 00:03:28,040
administra flash cash used and enhanced

00:03:24,450 --> 00:03:32,880
I all still uses administer

00:03:28,040 --> 00:03:37,530
administration of the cash in RAM by

00:03:32,880 --> 00:03:41,220
means of a hash array and be cash uses

00:03:37,530 --> 00:03:45,180
Beatrice hence the name there is also DM

00:03:41,220 --> 00:03:47,010
cash built on the device meant for

00:03:45,180 --> 00:03:51,780
infrastructure the other two solutions

00:03:47,010 --> 00:03:54,150
are not I won't and consider it and I

00:03:51,780 --> 00:03:59,549
haven't as long as it doesn't do safe

00:03:54,150 --> 00:04:02,070
writes a DB cache and an answer I all

00:03:59,549 --> 00:04:05,910
right that has is reported as written

00:04:02,070 --> 00:04:06,720
has hit the disk the M cash cannot make

00:04:05,910 --> 00:04:09,630
that

00:04:06,720 --> 00:04:12,570
promise and as long as this does not do

00:04:09,630 --> 00:04:13,950
that I'm not going to use it and the

00:04:12,570 --> 00:04:21,420
user space tools I reported to be

00:04:13,950 --> 00:04:24,390
terrible hey how does be cash work it

00:04:21,420 --> 00:04:27,750
operates on block devices that means

00:04:24,390 --> 00:04:32,130
that what you use as a cash in theory

00:04:27,750 --> 00:04:37,040
does not have to be an SSD you could use

00:04:32,130 --> 00:04:40,290
a rotational disk two to cash an old CD

00:04:37,040 --> 00:04:44,120
I'm not commenting on making sense of

00:04:40,290 --> 00:04:47,640
that but it would work it has the other

00:04:44,120 --> 00:04:51,870
limitation on the other hand that it

00:04:47,640 --> 00:04:56,520
needs a backing block device so using it

00:04:51,870 --> 00:05:01,680
to cash NFS no way same for the other

00:04:56,520 --> 00:05:03,870
network block devices and just last week

00:05:01,680 --> 00:05:06,660
somebody came up with the idea of using

00:05:03,870 --> 00:05:12,750
tmpfs as a cash device won't work either

00:05:06,660 --> 00:05:15,350
that need to be block devices mmm it has

00:05:12,750 --> 00:05:18,330
currently not in the design the

00:05:15,350 --> 00:05:21,300
limitation that you can't use it for a

00:05:18,330 --> 00:05:23,220
clustered file system and as a far as

00:05:21,300 --> 00:05:28,410
far as i know it has never been tested

00:05:23,220 --> 00:05:30,950
on a changeable medium well it should be

00:05:28,410 --> 00:05:33,270
done this is not funny because

00:05:30,950 --> 00:05:37,440
changeable media are among the slowest

00:05:33,270 --> 00:05:41,520
but it needs additional logic the code

00:05:37,440 --> 00:05:45,320
as it is now works I've not found a

00:05:41,520 --> 00:05:54,930
crash or any data corruption but is not

00:05:45,320 --> 00:06:00,090
extremely mature so on disk imagine you

00:05:54,930 --> 00:06:03,450
have your disk then you have partitions

00:06:00,090 --> 00:06:08,460
on it I hope and on your SSD likewise

00:06:03,450 --> 00:06:10,560
I've made a nice graphic to show that so

00:06:08,460 --> 00:06:14,010
on your left you have the backing store

00:06:10,560 --> 00:06:17,550
petitions and on the right the SSD /

00:06:14,010 --> 00:06:19,200
petitions for caching I'm assuming here

00:06:17,550 --> 00:06:20,280
that the backing stores are actual

00:06:19,200 --> 00:06:23,880
rotational disks

00:06:20,280 --> 00:06:29,280
around and the SSD are rectangular

00:06:23,880 --> 00:06:32,580
anyway so on your backing store and on

00:06:29,280 --> 00:06:39,210
your cash you generate a special super

00:06:32,580 --> 00:06:43,410
block for big cash and secondary to that

00:06:39,210 --> 00:06:46,490
super block you create the file systems

00:06:43,410 --> 00:06:53,160
actual super block on the backing store

00:06:46,490 --> 00:06:56,850
so from your point the cache partition

00:06:53,160 --> 00:06:58,950
is no longer a normal file system the

00:06:56,850 --> 00:07:01,200
block ID tools will show it as a bee

00:06:58,950 --> 00:07:04,560
cache partition actually they should

00:07:01,200 --> 00:07:07,340
they didn't on factory I fixed that well

00:07:04,560 --> 00:07:10,380
I've made a patch it's not yet submitted

00:07:07,340 --> 00:07:12,419
this is the point here that you cannot

00:07:10,380 --> 00:07:15,810
accelerate dentally mount something that

00:07:12,419 --> 00:07:20,040
is dirty which is good and the problem

00:07:15,810 --> 00:07:22,590
is you cannot mount it in any other

00:07:20,040 --> 00:07:26,310
format as then as a big cash device

00:07:22,590 --> 00:07:28,229
which means if your be cash tools or the

00:07:26,310 --> 00:07:31,740
big cash module don't work for some

00:07:28,229 --> 00:07:37,020
reason your data is not lost but it is

00:07:31,740 --> 00:07:39,419
inaccessible um currently I in contrast

00:07:37,020 --> 00:07:42,030
to rate there is no auto-detection of

00:07:39,419 --> 00:07:45,660
big cash devices in the colonel so you

00:07:42,030 --> 00:07:48,210
could set it up from an init rd before

00:07:45,660 --> 00:07:52,260
root file system is mounted then you can

00:07:48,210 --> 00:07:55,350
catch you your root filesystem in theory

00:07:52,260 --> 00:07:59,750
I have looked into that and I frankly

00:07:55,350 --> 00:08:04,020
think it is a bit silly because on a

00:07:59,750 --> 00:08:08,870
modern SSD you'd have at least 32

00:08:04,020 --> 00:08:11,850
gigabytes which will take up any

00:08:08,870 --> 00:08:14,100
reasonably sized root filesystem if

00:08:11,850 --> 00:08:18,390
you're putting some special thing on it

00:08:14,100 --> 00:08:21,990
you can use a petition for that and be

00:08:18,390 --> 00:08:25,110
cash that in my opinion it just makes no

00:08:21,990 --> 00:08:29,270
sense to put your root file system on be

00:08:25,110 --> 00:08:29,270
cash but in theory it should work

00:08:30,319 --> 00:08:38,339
so the caching solution has one

00:08:35,070 --> 00:08:40,229
principal problem in any design what is

00:08:38,339 --> 00:08:42,120
your cash and what is your backing store

00:08:40,229 --> 00:08:44,750
and if you have several caches which is

00:08:42,120 --> 00:08:50,700
which backing stores cash and vice versa

00:08:44,750 --> 00:08:54,420
be cash does that by unique IDs you set

00:08:50,700 --> 00:08:58,529
them up at the beginning and the kernel

00:08:54,420 --> 00:09:01,890
as you register your devices reads the

00:08:58,529 --> 00:09:05,279
ids and compare them and then

00:09:01,890 --> 00:09:09,990
automatically assembles the the cash

00:09:05,279 --> 00:09:14,310
device that means that you can reach

00:09:09,990 --> 00:09:17,459
assign this on the fly and you have as

00:09:14,310 --> 00:09:20,519
much flexibility as is in my opinion

00:09:17,459 --> 00:09:25,410
possible barring some bugs i discover

00:09:20,519 --> 00:09:37,860
today but if you have to type in such a

00:09:25,410 --> 00:09:40,560
unique ID yourself no no fun the system

00:09:37,860 --> 00:09:43,410
is set up so that for administrative

00:09:40,560 --> 00:09:46,140
purposes you can use a clean backing

00:09:43,410 --> 00:09:48,390
store without a cash you need that

00:09:46,140 --> 00:09:56,360
during migration from one cash to

00:09:48,390 --> 00:09:59,540
another and one cash device can serve

00:09:56,360 --> 00:10:04,380
essentially other than by integer limit

00:09:59,540 --> 00:10:09,829
number of of packing stores I haven't

00:10:04,380 --> 00:10:14,160
tested that but in theory good idea in

00:10:09,829 --> 00:10:18,839
practice I doubt you'd use it but we

00:10:14,160 --> 00:10:23,519
will see in the future so the whole

00:10:18,839 --> 00:10:27,899
thing is administered by Sisyphus you

00:10:23,519 --> 00:10:32,130
just register by a special file in the B

00:10:27,899 --> 00:10:38,010
cache directory your devices and they

00:10:32,130 --> 00:10:39,510
are recognized by the unique IDs so you

00:10:38,010 --> 00:10:41,790
just write them in and everything will

00:10:39,510 --> 00:10:49,110
work there is a

00:10:41,790 --> 00:10:52,020
set which generates the secondary

00:10:49,110 --> 00:10:56,070
superblocks and does a bit of

00:10:52,020 --> 00:10:58,080
administration this works well for

00:10:56,070 --> 00:11:02,550
anything in more advanced and reading

00:10:58,080 --> 00:11:05,040
out the statistics you can you can and

00:11:02,550 --> 00:11:08,610
must unfortunately directly access the

00:11:05,040 --> 00:11:10,680
sea surface but statistics are easy to

00:11:08,610 --> 00:11:19,650
understand and there is not that much to

00:11:10,680 --> 00:11:22,050
be seen there the system is administered

00:11:19,650 --> 00:11:26,310
by Sisyphus but anything you change

00:11:22,050 --> 00:11:30,120
there is indeed persistently stored on

00:11:26,310 --> 00:11:35,880
the caching device you can change the

00:11:30,120 --> 00:11:40,830
caching Modi of which be cash has three

00:11:35,880 --> 00:11:46,590
and those are important so I'll have to

00:11:40,830 --> 00:11:49,950
say something about them there is in

00:11:46,590 --> 00:11:55,890
every caching solution the problem of

00:11:49,950 --> 00:11:58,440
what to cash and when to cash it oh the

00:11:55,890 --> 00:12:00,830
usual and probably only solution in that

00:11:58,440 --> 00:12:06,450
case is that you cash what you read and

00:12:00,830 --> 00:12:08,640
at some point evicted but when reading

00:12:06,450 --> 00:12:12,420
and there is a problem as I told you as

00:12:08,640 --> 00:12:15,540
as these have great latency but not so

00:12:12,420 --> 00:12:21,630
great throughput it is still larger than

00:12:15,540 --> 00:12:23,430
any conventional disks but to cash you

00:12:21,630 --> 00:12:27,930
have to read from the conventional disk

00:12:23,430 --> 00:12:30,630
and right to the SSD that can be done

00:12:27,930 --> 00:12:34,140
but it is obviously slower than just

00:12:30,630 --> 00:12:36,360
reading from the conventional medium so

00:12:34,140 --> 00:12:41,010
there is a chance that you actually

00:12:36,360 --> 00:12:42,750
worsen your performance and this would

00:12:41,010 --> 00:12:46,020
happen if you were to cache large

00:12:42,750 --> 00:12:49,860
sequential reads for that reason be cash

00:12:46,020 --> 00:12:52,650
does not do that and there is the

00:12:49,860 --> 00:12:54,900
problem that you're caching device is

00:12:52,650 --> 00:12:55,500
necessarily smaller than your backing

00:12:54,900 --> 00:12:58,050
store

00:12:55,500 --> 00:13:03,510
otherwise there is no point in using a

00:12:58,050 --> 00:13:05,970
cash so you cannot cash everything about

00:13:03,510 --> 00:13:11,130
the valuable stuff so there is a hard

00:13:05,970 --> 00:13:15,360
limit in the cash for what to cash there

00:13:11,130 --> 00:13:20,940
is an option to do a read ahead I've

00:13:15,360 --> 00:13:26,880
tested it a bit I found no significant

00:13:20,940 --> 00:13:30,900
benefit here but it may be beneficial on

00:13:26,880 --> 00:13:38,700
some configuration I can't really tell

00:13:30,900 --> 00:13:43,740
you so the caching Modi are material to

00:13:38,700 --> 00:13:46,650
writing to disk you would ideally also

00:13:43,740 --> 00:13:50,160
cash what you write on the suspicion

00:13:46,650 --> 00:13:52,110
that you will reuse it so there are

00:13:50,160 --> 00:13:56,700
three logical combinations if you have

00:13:52,110 --> 00:14:01,140
two devices you can either write it to

00:13:56,700 --> 00:14:04,440
disk and not cash that has the very

00:14:01,140 --> 00:14:07,890
obvious benefit that you do not have the

00:14:04,440 --> 00:14:10,380
cost of the second right because at some

00:14:07,890 --> 00:14:14,970
point you will have to hit the disk so

00:14:10,380 --> 00:14:18,950
why not do it cook just at once you can

00:14:14,970 --> 00:14:22,710
write to both obvious problem it is

00:14:18,950 --> 00:14:25,410
slower because you need to write at

00:14:22,710 --> 00:14:29,010
least twice in practice more because the

00:14:25,410 --> 00:14:32,460
administrative data is on the SSD so it

00:14:29,010 --> 00:14:34,530
can turn into well if you're unlucky

00:14:32,460 --> 00:14:39,839
enough you have to rebalance the b3 and

00:14:34,530 --> 00:14:43,260
that is costly in practice this is again

00:14:39,839 --> 00:14:46,200
mighty gated by the limit for large

00:14:43,260 --> 00:14:49,020
consecutive reads and writes but if you

00:14:46,200 --> 00:14:51,839
switch that that off which you can yes

00:14:49,020 --> 00:14:55,440
there is the case that be cash actually

00:14:51,839 --> 00:14:59,160
slows the top of things down there is

00:14:55,440 --> 00:15:03,720
the most cool setting that is right back

00:14:59,160 --> 00:15:05,850
you write only to SSD and do the writing

00:15:03,720 --> 00:15:07,649
to the actual disk in the background

00:15:05,850 --> 00:15:10,170
later

00:15:07,649 --> 00:15:12,990
which means you in principle should get

00:15:10,170 --> 00:15:18,509
minus administrative overhead the full

00:15:12,990 --> 00:15:21,449
seek latency of the SSD and again not

00:15:18,509 --> 00:15:24,869
the penalty of the not-so-great

00:15:21,449 --> 00:15:29,100
throughput given by the limit for large

00:15:24,869 --> 00:15:31,829
consecutive rights there is of course a

00:15:29,100 --> 00:15:34,860
problem let us suppose you have your

00:15:31,829 --> 00:15:37,050
nice r85 array for safety no single

00:15:34,860 --> 00:15:41,610
point of failure and you do the right

00:15:37,050 --> 00:15:45,959
back with a single SSD and ussd goes the

00:15:41,610 --> 00:15:53,790
way of all material things and then some

00:15:45,959 --> 00:15:58,829
of your data is lost so there are few

00:15:53,790 --> 00:16:01,470
other details you have to consider even

00:15:58,829 --> 00:16:07,550
your SSD is not infinitely fast it may

00:16:01,470 --> 00:16:07,550
be overloaded in that case there is a

00:16:08,689 --> 00:16:15,540
workaround so that be cash just gives up

00:16:12,509 --> 00:16:22,230
after a few milliseconds configurable

00:16:15,540 --> 00:16:24,990
and rights to disk so an error handling

00:16:22,230 --> 00:16:28,800
is done by just bypassing the cash in

00:16:24,990 --> 00:16:30,929
the rate case that will not always work

00:16:28,800 --> 00:16:33,209
in the right back mode because you may

00:16:30,929 --> 00:16:40,290
have dirty data that is only on the SSD

00:16:33,209 --> 00:16:44,040
but then well benefits have costs so

00:16:40,290 --> 00:16:50,160
I've benchmarks made benchmarks so you

00:16:44,040 --> 00:16:55,199
have seen actual numbers here it has

00:16:50,160 --> 00:16:57,480
they have been done on this system this

00:16:55,199 --> 00:17:00,149
is quite nice a laptop in my opinion I

00:16:57,480 --> 00:17:03,600
like them large because it can

00:17:00,149 --> 00:17:06,240
accommodate multiple disks so I've

00:17:03,600 --> 00:17:09,720
tested the worst case for be cash

00:17:06,240 --> 00:17:13,110
against a rate array the worst case

00:17:09,720 --> 00:17:16,380
because for some operations the reit

00:17:13,110 --> 00:17:19,439
array actually doubles performance reads

00:17:16,380 --> 00:17:21,120
and writes of large masses of data which

00:17:19,439 --> 00:17:24,449
can use both discs seventh

00:17:21,120 --> 00:17:27,270
viously should in theory double the

00:17:24,449 --> 00:17:31,280
throughput in practice the doubling does

00:17:27,270 --> 00:17:33,900
not quite happen but still on two discs

00:17:31,280 --> 00:17:37,170
if you add up the throughput numbers

00:17:33,900 --> 00:17:41,970
should be faster than one SSD 11

00:17:37,170 --> 00:17:46,350
cheapest st and this was intentionally

00:17:41,970 --> 00:17:49,070
done to see the worst case so to the

00:17:46,350 --> 00:17:53,460
numbers i use them as a raid 0 array

00:17:49,070 --> 00:18:00,780
with two identical disks of 320

00:17:53,460 --> 00:18:04,920
gigabytes they are 5400rpm SATA and i've

00:18:00,780 --> 00:18:09,440
done the test against either them as a

00:18:04,920 --> 00:18:14,190
raid 0 or one of the disks or for

00:18:09,440 --> 00:18:16,380
comparison purposes against the file

00:18:14,190 --> 00:18:25,760
system on conventional partition on the

00:18:16,380 --> 00:18:31,080
SSD the tests were done with home oh

00:18:25,760 --> 00:18:36,210
well yes anything I forgot no I asked

00:18:31,080 --> 00:18:39,600
it's I remember it is 32 gigabytes and I

00:18:36,210 --> 00:18:44,580
used about 24 them for cash but all

00:18:39,600 --> 00:18:47,490
tests were done so that the test files

00:18:44,580 --> 00:18:54,320
are smaller than the cache size so it

00:18:47,490 --> 00:18:58,679
should all fit in I also limited the

00:18:54,320 --> 00:19:02,070
memory used in for the colonel to 1

00:18:58,679 --> 00:19:05,429
gigabyte so the test file sizes were

00:19:02,070 --> 00:19:08,630
between the memory size and the cache

00:19:05,429 --> 00:19:11,580
size so the cash should be fully

00:19:08,630 --> 00:19:16,429
utilizable but the memory should not

00:19:11,580 --> 00:19:18,960
really make the test meaningless I

00:19:16,429 --> 00:19:21,360
allowed some significant memory so that

00:19:18,960 --> 00:19:23,880
you see the realistic effect of memory

00:19:21,360 --> 00:19:27,780
which you would also see normal testing

00:19:23,880 --> 00:19:32,220
I ran this on factory a state of a few

00:19:27,780 --> 00:19:32,960
weeks ago in the beginning I started out

00:19:32,220 --> 00:19:36,860
with

00:19:32,960 --> 00:19:40,309
few practical tests Colonel computation

00:19:36,860 --> 00:19:44,090
I'm konica and doing a few grabs on my

00:19:40,309 --> 00:19:49,360
Colonel sources but then for systematic

00:19:44,090 --> 00:19:53,480
testing I resorted to I ozone I ozone

00:19:49,360 --> 00:19:59,000
because it in some ways represents a

00:19:53,480 --> 00:20:00,830
relatively hard case for be cash and I'm

00:19:59,000 --> 00:20:03,890
of the opinion that if you test

00:20:00,830 --> 00:20:08,059
something you test it hard I'd rather be

00:20:03,890 --> 00:20:13,909
positively surprised and negatively mmm

00:20:08,059 --> 00:20:19,000
I ozone does a lot of tests too many to

00:20:13,909 --> 00:20:22,850
to really well no frankly time didn't

00:20:19,000 --> 00:20:26,179
suffice for running them all I also test

00:20:22,850 --> 00:20:28,610
does take a lot of time i use the tests

00:20:26,179 --> 00:20:30,799
for consecutive rights and rewrites on

00:20:28,610 --> 00:20:33,470
the theory that that should stress be

00:20:30,799 --> 00:20:38,029
cash and i should see any negative

00:20:33,470 --> 00:20:40,309
performance impact and i did do a random

00:20:38,029 --> 00:20:43,940
read and write to show more or less the

00:20:40,309 --> 00:20:49,279
best case for be cash i varied the

00:20:43,940 --> 00:20:51,440
record size used and the caching mode to

00:20:49,279 --> 00:20:55,490
see the influence of that get some

00:20:51,440 --> 00:20:57,230
significant data okay now to a few

00:20:55,490 --> 00:21:01,760
selected results those that are most

00:20:57,230 --> 00:21:03,980
significant what I should will the other

00:21:01,760 --> 00:21:05,750
results I left out are somehow in the

00:21:03,980 --> 00:21:07,429
middle and not really interesting

00:21:05,750 --> 00:21:12,380
between extreme cases i'm going to

00:21:07,429 --> 00:21:16,700
present here okay this was the the most

00:21:12,380 --> 00:21:23,059
basic case the single disc with 128 k a

00:21:16,700 --> 00:21:27,559
record size blue is the right well now

00:21:23,059 --> 00:21:30,710
you can read yourself now the

00:21:27,559 --> 00:21:37,370
interesting fact here is that on the

00:21:30,710 --> 00:21:41,419
large data rights be cash just does not

00:21:37,370 --> 00:21:44,870
help that was to be expected because

00:21:41,419 --> 00:21:45,840
there is the limit for large sequential

00:21:44,870 --> 00:21:48,299
writes so

00:21:45,840 --> 00:21:53,490
should be used at all but it turns out

00:21:48,299 --> 00:21:57,630
that even switching this off does not

00:21:53,490 --> 00:22:00,690
make a significant difference we're just

00:21:57,630 --> 00:22:03,600
seeing here that at sequential reads and

00:22:00,690 --> 00:22:05,850
well for reads we don't see it but we

00:22:03,600 --> 00:22:09,690
could assume it so at least for

00:22:05,850 --> 00:22:13,100
sequential writes an SSD plus the

00:22:09,690 --> 00:22:16,440
administer overhead just isn't that fast

00:22:13,100 --> 00:22:18,990
so if you are nice and get me a faster

00:22:16,440 --> 00:22:21,380
SSD I could rerun the tests but I

00:22:18,990 --> 00:22:26,070
believe this to make the case from from

00:22:21,380 --> 00:22:29,850
quite a lot of hardware what we see here

00:22:26,070 --> 00:22:32,279
that is in the right back case be cash

00:22:29,850 --> 00:22:36,659
performs practically as good as the

00:22:32,279 --> 00:22:43,350
naked SSD which is cool so for at least

00:22:36,659 --> 00:22:49,940
that use case perfect can't be done

00:22:43,350 --> 00:22:56,940
better there was the great great well

00:22:49,940 --> 00:23:03,440
yes it made me sad the reading case just

00:22:56,940 --> 00:23:08,539
doesn't help your SSD is beyond all

00:23:03,440 --> 00:23:12,840
expectations but p cash doesn't do it

00:23:08,539 --> 00:23:17,159
this can put in part be explained by the

00:23:12,840 --> 00:23:19,860
peculiarities of I ozone in that

00:23:17,159 --> 00:23:26,940
configuration there is just a low chance

00:23:19,860 --> 00:23:29,669
that a sector is reread I've tried to to

00:23:26,940 --> 00:23:32,220
change this by using read ahead but for

00:23:29,669 --> 00:23:38,680
any reasonable reader head setting there

00:23:32,220 --> 00:23:47,770
is no significant difference yes

00:23:38,680 --> 00:23:52,380
oh the rotational medium itself is here

00:23:47,770 --> 00:23:52,380
switching off the the read/write feature

00:23:54,780 --> 00:24:01,600
sorry should have tested this on a

00:23:58,420 --> 00:24:05,020
beamer but okay just for understanding

00:24:01,600 --> 00:24:07,420
purposes this is the naked disk this is

00:24:05,020 --> 00:24:10,870
with right around so you don't cash

00:24:07,420 --> 00:24:14,670
rights this is right back cashing rights

00:24:10,870 --> 00:24:17,470
and here for experimental purposes

00:24:14,670 --> 00:24:20,110
switching off the detection of large

00:24:17,470 --> 00:24:24,490
consecutive rights and here's the naked

00:24:20,110 --> 00:24:27,550
SSD so you can see that four consecutive

00:24:24,490 --> 00:24:31,540
rights the caching neither hurts no

00:24:27,550 --> 00:24:37,630
helps it does the same unfortunately is

00:24:31,540 --> 00:24:40,630
true for the random read case it is not

00:24:37,630 --> 00:24:43,060
true for caching rights for caching

00:24:40,630 --> 00:24:46,810
rights we are as fast as the naked SSD

00:24:43,060 --> 00:24:51,430
more or less for reads big hair sucks

00:24:46,810 --> 00:24:55,240
and here you can see that SSDs are not

00:24:51,430 --> 00:24:57,730
that good at writing the performance

00:24:55,240 --> 00:25:01,150
drops here and the be cash actually

00:24:57,730 --> 00:25:03,910
detects that and goes to the rotational

00:25:01,150 --> 00:25:07,030
disk as it should so it doesn't hurt but

00:25:03,910 --> 00:25:10,210
it doesn't help either as was to be

00:25:07,030 --> 00:25:15,940
expected but it's better to have a

00:25:10,210 --> 00:25:21,780
realistic picture there no it does help

00:25:15,940 --> 00:25:24,880
it does help in in the right case is so

00:25:21,780 --> 00:25:31,590
you can't say it doesn't help but you

00:25:24,880 --> 00:25:38,790
cannot say it helps every time mmm

00:25:31,590 --> 00:25:43,180
didn't I just show that oh yes sorry so

00:25:38,790 --> 00:25:47,020
make it even harder for be cash set it

00:25:43,180 --> 00:25:50,550
against the raid array worst case see

00:25:47,020 --> 00:25:52,090
the naked raid array is even faster and

00:25:50,550 --> 00:25:56,350
again

00:25:52,090 --> 00:25:58,779
be cash that's what it should it doesn't

00:25:56,350 --> 00:26:03,309
help things and it not neither does it

00:25:58,779 --> 00:26:07,480
hurt it would hurt without the detection

00:26:03,309 --> 00:26:13,900
for sequential writes and well these are

00:26:07,480 --> 00:26:16,679
identical obviously here we see that the

00:26:13,900 --> 00:26:22,929
same behavior is true for the reed case

00:26:16,679 --> 00:26:27,640
random read in random read a great array

00:26:22,929 --> 00:26:31,510
should increase performance but not

00:26:27,640 --> 00:26:33,279
linearly there is a 50-50 chance that on

00:26:31,510 --> 00:26:37,450
the next week you hit the same disk and

00:26:33,279 --> 00:26:41,559
then you screw it again in the random

00:26:37,450 --> 00:26:49,179
right case again we find that be cash

00:26:41,559 --> 00:26:54,610
helps even better than the naked SSD

00:26:49,179 --> 00:26:57,039
itself which is cool and this shows us

00:26:54,610 --> 00:27:01,000
that you really shouldn't switch off the

00:26:57,039 --> 00:27:02,950
sequential detection here nice

00:27:01,000 --> 00:27:10,980
experimental feature but in practice

00:27:02,950 --> 00:27:16,210
don't I've varied the record size and

00:27:10,980 --> 00:27:23,500
you can see that this helps the SSD its

00:27:16,210 --> 00:27:26,260
performance increases and be cash if you

00:27:23,500 --> 00:27:28,029
switch off the sequential detection yes

00:27:26,260 --> 00:27:29,559
this is significant if you run the

00:27:28,029 --> 00:27:34,510
numbers but the effect is very very

00:27:29,559 --> 00:27:38,409
small so just don't do it and we here we

00:27:34,510 --> 00:27:41,740
again find that for reading it does not

00:27:38,409 --> 00:27:43,779
help for writing the effect is if you

00:27:41,740 --> 00:27:48,460
run the numbers significant but again

00:27:43,779 --> 00:27:51,580
small so we have to conclude even for

00:27:48,460 --> 00:27:59,679
large writes be cash it's not what you

00:27:51,580 --> 00:28:02,500
want okay and here we have the case that

00:27:59,679 --> 00:28:05,340
really stressed the rotational disk this

00:28:02,500 --> 00:28:10,920
is a record size of 16 k

00:28:05,340 --> 00:28:13,160
against the right array 16k is smaller

00:28:10,920 --> 00:28:16,650
than the stripes eyes on the raid array

00:28:13,160 --> 00:28:19,770
so you have half the full effect of the

00:28:16,650 --> 00:28:22,980
negative scaling on the right array for

00:28:19,770 --> 00:28:27,930
random reads and writes still if you

00:28:22,980 --> 00:28:34,680
write consecutive consecutively the raid

00:28:27,930 --> 00:28:37,170
array does great the be cash does not

00:28:34,680 --> 00:28:41,250
quite so well this is significant if

00:28:37,170 --> 00:28:43,470
your random numbers but again the effect

00:28:41,250 --> 00:28:49,380
is small but here you see that caching

00:28:43,470 --> 00:28:51,660
can actually hurt so beware here we will

00:28:49,380 --> 00:28:56,550
find that switching of the sequential

00:28:51,660 --> 00:29:02,100
detection does help at the expense of

00:28:56,550 --> 00:29:04,800
rewriting so for some use cases SSDs

00:29:02,100 --> 00:29:08,640
really are weird I can't explain that

00:29:04,800 --> 00:29:12,000
honestly but where you can see an

00:29:08,640 --> 00:29:15,110
extreme effect here is in the right back

00:29:12,000 --> 00:29:20,660
it still isn't as good as the naked SSD

00:29:15,110 --> 00:29:27,150
but it is about three times as fast as

00:29:20,660 --> 00:29:28,410
not using the SSD so cool I mean you

00:29:27,150 --> 00:29:32,880
have here an operation that is

00:29:28,410 --> 00:29:36,510
inherently slow but it can be made three

00:29:32,880 --> 00:29:39,810
times faster and sometimes well your

00:29:36,510 --> 00:29:42,210
data may come in chunks of 16 k or some

00:29:39,810 --> 00:29:44,040
smaller size or slightly larger and it

00:29:42,210 --> 00:29:50,150
can't be helped so there it does

00:29:44,040 --> 00:29:56,130
something well as I said sometimes the

00:29:50,150 --> 00:30:01,410
results of your SSD are strange and

00:29:56,130 --> 00:30:03,000
can't really be explained I used x4 in

00:30:01,410 --> 00:30:07,940
those tests maybe I should have

00:30:03,000 --> 00:30:10,639
mentioned that there is

00:30:07,940 --> 00:30:13,250
I actually must admit I don't know

00:30:10,639 --> 00:30:15,409
whether x4 in that particularly kernel

00:30:13,250 --> 00:30:18,769
version we use on factory used trim

00:30:15,409 --> 00:30:23,570
command that might explain some of the

00:30:18,769 --> 00:30:27,649
peculiarities of the SSD because be cash

00:30:23,570 --> 00:30:29,690
would swallow the trim command if it the

00:30:27,649 --> 00:30:37,370
file system were to issue it to the big

00:30:29,690 --> 00:30:42,070
calf device I just don't know what we

00:30:37,370 --> 00:30:42,070
can conclude is that be cash always

00:30:42,129 --> 00:30:50,990
accelerates the random right case but it

00:30:47,269 --> 00:30:53,960
rarely does accelerate the random read

00:30:50,990 --> 00:30:57,289
case and in the large consecutive

00:30:53,960 --> 00:31:02,059
rewrite case and presumably read case it

00:30:57,289 --> 00:31:06,649
is useless I've tried to find out where

00:31:02,059 --> 00:31:08,809
the problem is for the random read case

00:31:06,649 --> 00:31:11,210
and the random write case in the

00:31:08,809 --> 00:31:13,610
consecutive case there it is clear what

00:31:11,210 --> 00:31:17,059
should happen and expect it happens in

00:31:13,610 --> 00:31:19,429
the reed case this is not so and I found

00:31:17,059 --> 00:31:24,409
out that our probe problem is to cash it

00:31:19,429 --> 00:31:26,600
right even in the best case we have a

00:31:24,409 --> 00:31:29,659
cache hit rate of just thirty percent

00:31:26,600 --> 00:31:32,179
and if you combine that with the

00:31:29,659 --> 00:31:37,009
overhead from the lookup of the failed

00:31:32,179 --> 00:31:38,779
cases be cash doesn't help in the worst

00:31:37,009 --> 00:31:41,299
cases where the performance dropped a

00:31:38,779 --> 00:31:45,759
little bit i found a hit k a cache hit

00:31:41,299 --> 00:31:48,919
rate of seven percent which is useless

00:31:45,759 --> 00:31:53,649
this is unfortunately not just an

00:31:48,919 --> 00:31:56,120
artifact of I ozone because unwrapping

00:31:53,649 --> 00:31:58,460
the same could be observed the the

00:31:56,120 --> 00:32:01,250
numbers are identical so I left them out

00:31:58,460 --> 00:32:05,860
for being boring when you compile your

00:32:01,250 --> 00:32:10,370
kernel which is CPU bound operation in

00:32:05,860 --> 00:32:12,740
practice small s I found that this

00:32:10,370 --> 00:32:15,970
machine can do a kernel computation on a

00:32:12,740 --> 00:32:20,509
naked rotational disk in 18 minutes and

00:32:15,970 --> 00:32:25,080
with be cash and write back it does take

00:32:20,509 --> 00:32:28,250
17 minutes 35 seconds I ran the tests

00:32:25,080 --> 00:32:31,080
quite a lot of time and even did the the

00:32:28,250 --> 00:32:33,840
chi-square test so the result is

00:32:31,080 --> 00:32:38,759
significant but it is very small about

00:32:33,840 --> 00:32:47,820
three and a half percent well so far so

00:32:38,759 --> 00:32:50,580
good so what do we conclude here i would

00:32:47,820 --> 00:32:55,470
say that there are use cases for which

00:32:50,580 --> 00:32:58,289
be cash really rocks the obvious one

00:32:55,470 --> 00:33:00,809
would be a mail server but in the

00:32:58,289 --> 00:33:05,820
general use case you might expect small

00:33:00,809 --> 00:33:08,549
benefits but nothing spectacular on the

00:33:05,820 --> 00:33:11,580
other hand if your machine comes with

00:33:08,549 --> 00:33:16,529
say a sixty four gigabit a sec gigabyte

00:33:11,580 --> 00:33:19,379
sorry SSD then you're reasonably sized

00:33:16,529 --> 00:33:22,799
root petition would be what 30 gigs 40

00:33:19,379 --> 00:33:28,500
40 it's just too large so you have some

00:33:22,799 --> 00:33:33,419
space left and why not use it what I

00:33:28,500 --> 00:33:36,629
found when actually doing this when you

00:33:33,419 --> 00:33:40,019
set up the be cash please load your

00:33:36,629 --> 00:33:43,379
module you will have the weird effect

00:33:40,019 --> 00:33:45,779
that the partition are correctly created

00:33:43,379 --> 00:33:48,779
if you don't but they are not associated

00:33:45,779 --> 00:33:51,299
with each other and then you have to

00:33:48,779 --> 00:33:56,490
manually type to the unique IDs and that

00:33:51,299 --> 00:33:59,370
is not a nice thing to do what I further

00:33:56,490 --> 00:34:02,669
found is that in factory the setup is

00:33:59,370 --> 00:34:05,669
quite brittle there is no colonel

00:34:02,669 --> 00:34:07,950
detection as I mentioned this is done by

00:34:05,669 --> 00:34:10,740
using block ID on all partitions on

00:34:07,950 --> 00:34:13,500
startup and just registering that with

00:34:10,740 --> 00:34:16,470
the big cash module and let the colonel

00:34:13,500 --> 00:34:20,300
do the Association which does work the

00:34:16,470 --> 00:34:25,500
problem here is that if block ID fails

00:34:20,300 --> 00:34:28,139
you have a problem currently a system d

00:34:25,500 --> 00:34:30,429
will then drop you into repair mode and

00:34:28,139 --> 00:34:34,130
you can do it yourself by hand

00:34:30,429 --> 00:34:40,220
and then continue the boot but pretty

00:34:34,130 --> 00:34:45,169
this is not as you saw all my tests you

00:34:40,220 --> 00:34:49,700
can combine be Koresh with rate and now

00:34:45,169 --> 00:34:51,470
you can I had to fix it and we discussed

00:34:49,700 --> 00:34:53,929
Custis internally and came to the

00:34:51,470 --> 00:34:56,840
conclusion that the same operation mode

00:34:53,929 --> 00:34:59,480
is to cash the right device as such and

00:34:56,840 --> 00:35:03,080
not the partitions of which the right

00:34:59,480 --> 00:35:12,770
device is made up it's just a ways to do

00:35:03,080 --> 00:35:17,780
that and yes let's look a bit in theory

00:35:12,770 --> 00:35:23,030
at the right solution because raid

00:35:17,780 --> 00:35:25,480
arrays rate 5 that is half from the way

00:35:23,030 --> 00:35:29,690
they work the principal problem with a

00:35:25,480 --> 00:35:34,540
random right they have to do that read

00:35:29,690 --> 00:35:37,670
at least two stripes to compute the

00:35:34,540 --> 00:35:42,770
parity data and rate six would have to

00:35:37,670 --> 00:35:45,710
read them all so from theory we should

00:35:42,770 --> 00:35:49,940
conclude that beaker should be the ideal

00:35:45,710 --> 00:35:52,070
solution to cache random writes on right

00:35:49,940 --> 00:35:55,880
five arrays if you use the right back

00:35:52,070 --> 00:35:57,890
operation frankly we have no laptop

00:35:55,880 --> 00:36:00,350
which is large enough to hold so many

00:35:57,890 --> 00:36:03,350
disks that I could build rate fiber

00:36:00,350 --> 00:36:05,720
rated test so i would have to reserve a

00:36:03,350 --> 00:36:08,420
test machine at some point I will

00:36:05,720 --> 00:36:11,930
probably do that but there is a limit

00:36:08,420 --> 00:36:14,780
two tests I could do so this table

00:36:11,930 --> 00:36:19,520
summarizes more or less what I found in

00:36:14,780 --> 00:36:27,170
testing against the raid array so what

00:36:19,520 --> 00:36:32,000
should we do for a distro at present be

00:36:27,170 --> 00:36:35,230
cash works in the kernel perfectly the

00:36:32,000 --> 00:36:39,550
tools are there but still a bit buggy

00:36:35,230 --> 00:36:43,330
but there is no support at all biased

00:36:39,550 --> 00:36:47,500
this means you can obviously not in

00:36:43,330 --> 00:36:50,260
stall on a big cash device which is not

00:36:47,500 --> 00:36:53,230
that bad because it makes no sense

00:36:50,260 --> 00:36:55,270
anyway you would for your special

00:36:53,230 --> 00:36:58,140
purpose create a special petition or

00:36:55,270 --> 00:37:02,290
cash home or whatever petition you use

00:36:58,140 --> 00:37:04,210
but on migration this will bite us we

00:37:02,290 --> 00:37:08,250
will have a device which just doesn't

00:37:04,210 --> 00:37:10,950
understand and that is not good

00:37:08,250 --> 00:37:13,780
furthermore if you want to do any

00:37:10,950 --> 00:37:18,220
administration just as franking your

00:37:13,780 --> 00:37:20,230
cash or lot enlarging it which FB cash

00:37:18,220 --> 00:37:25,380
would be done by creating a larger

00:37:20,230 --> 00:37:28,180
petition and detaching the cash and then

00:37:25,380 --> 00:37:30,910
reassociate in with the the backing

00:37:28,180 --> 00:37:33,880
store you have to do that by hand which

00:37:30,910 --> 00:37:38,410
involves typing the unique ids and so on

00:37:33,880 --> 00:37:41,020
not nice but doable we would like some

00:37:38,410 --> 00:37:43,570
advances support here if we decide that

00:37:41,020 --> 00:37:46,320
be cash is the way to go for in the

00:37:43,570 --> 00:37:57,880
future for caching and caching itself

00:37:46,320 --> 00:38:02,770
what oh well anyway and caching itself

00:37:57,880 --> 00:38:05,710
is sensible what else we would like to

00:38:02,770 --> 00:38:08,740
have is a conversion on the fly if you

00:38:05,710 --> 00:38:11,590
want to migrate to be cash there is such

00:38:08,740 --> 00:38:14,830
a utility called block available on the

00:38:11,590 --> 00:38:17,920
internet and frankly I didn't there but

00:38:14,830 --> 00:38:22,660
it exists what else we would like to do

00:38:17,920 --> 00:38:26,290
is safety feature currently your data is

00:38:22,660 --> 00:38:28,810
in principle safe against power failure

00:38:26,290 --> 00:38:32,650
on the SSD if you use the right back

00:38:28,810 --> 00:38:34,540
mode and shut down but this is not good

00:38:32,650 --> 00:38:38,650
because it means that you can't switch

00:38:34,540 --> 00:38:40,630
your SSD when the machine is off and if

00:38:38,650 --> 00:38:42,820
you cash against the right array you

00:38:40,630 --> 00:38:46,210
lose the the redundancy of a raid array

00:38:42,820 --> 00:38:48,190
right five that is all right one ideally

00:38:46,210 --> 00:38:50,080
we would flush the be cash whenever we

00:38:48,190 --> 00:38:52,630
shut down the machine so there needs to

00:38:50,080 --> 00:38:55,859
be something done in unfortunately no

00:38:52,630 --> 00:39:02,170
longer the init scripts button system d

00:38:55,859 --> 00:39:05,740
well okay I like if the time permits and

00:39:02,170 --> 00:39:07,809
it probably does do a demonstration here

00:39:05,740 --> 00:39:10,930
but I think questions if they should

00:39:07,809 --> 00:39:18,640
arise are more important so if you have

00:39:10,930 --> 00:39:22,630
questions please ask now no I would like

00:39:18,640 --> 00:39:24,640
to ask you if if there is someone behind

00:39:22,630 --> 00:39:27,369
that the biggest project if it is just

00:39:24,640 --> 00:39:29,530
your ideas and you are working them or

00:39:27,369 --> 00:39:32,650
if there is a cooperation with other

00:39:29,530 --> 00:39:34,839
developers and other companies so we

00:39:32,650 --> 00:39:37,359
will not develop something in Susa on

00:39:34,839 --> 00:39:41,710
our own and maintain that but we will

00:39:37,359 --> 00:39:43,990
cooperate with others okay this is a

00:39:41,710 --> 00:39:46,240
mistake I am NOT doing the big cash code

00:39:43,990 --> 00:39:47,799
in the kernel I'm just thinking it's

00:39:46,240 --> 00:39:52,750
cool and maintaining the users based

00:39:47,799 --> 00:39:54,790
tools for firstly there is external be

00:39:52,750 --> 00:40:05,760
cash development but the group doing it

00:39:54,790 --> 00:40:23,490
is not large did you try some tests with

00:40:05,760 --> 00:40:23,490
larger files maybe doesn't work okay I

00:40:24,780 --> 00:40:34,359
probably have to switch it on so yes

00:40:30,450 --> 00:40:36,790
screw it anyway yes I did one test with

00:40:34,359 --> 00:40:40,030
a larger file it shows that it doesn't

00:40:36,790 --> 00:40:42,760
make a difference I should have tried

00:40:40,030 --> 00:40:44,770
perhaps smaller files but then there is

00:40:42,760 --> 00:40:47,230
the danger that ram does too much

00:40:44,770 --> 00:40:49,900
caching and I would have to limit the

00:40:47,230 --> 00:40:53,530
Machine RAM size so much that I don't

00:40:49,900 --> 00:40:55,799
think the test is realistic any more any

00:40:53,530 --> 00:40:55,799
more questions

00:40:57,760 --> 00:41:03,079
now that you've mentioned that again via

00:41:00,470 --> 00:41:10,040
linux caches VFS operations itself right

00:41:03,079 --> 00:41:13,900
I would say it's a vm operation but that

00:41:10,040 --> 00:41:18,400
is probably talking about terms here

00:41:13,900 --> 00:41:23,569
right so I'm maybe being very naive

00:41:18,400 --> 00:41:27,380
wouldn't it be smart to enhance this EFS

00:41:23,569 --> 00:41:30,260
cash to use an SSD yes well bigger

00:41:27,380 --> 00:41:32,390
storage we were extended storage

00:41:30,260 --> 00:41:33,770
whatever so then you wouldn't need to

00:41:32,390 --> 00:41:36,230
fiddle with the setup and everything you

00:41:33,770 --> 00:41:38,599
just tell it well there's your flash

00:41:36,230 --> 00:41:40,670
drive use that you know for more storage

00:41:38,599 --> 00:41:50,319
of your VMs operations and eventually do

00:41:40,670 --> 00:41:53,210
your thing whenever you want to yes

00:41:50,319 --> 00:41:56,290
first of all it obviously means that you

00:41:53,210 --> 00:42:03,980
couldn't decide what you want to cache

00:41:56,290 --> 00:42:10,420
and secondly yes you could use the SSD

00:42:03,980 --> 00:42:15,760
as a swap medium and on the third hand

00:42:10,420 --> 00:42:18,079
somebody would need to try actually but

00:42:15,760 --> 00:42:21,440
expectations are that it would

00:42:18,079 --> 00:42:26,380
essentially be equivalent to using your

00:42:21,440 --> 00:42:26,380
SSD SS swap partition yes

00:42:30,400 --> 00:42:35,559
I mean if it weren't so the Deeks the

00:42:33,789 --> 00:42:38,619
result would be extremely exciting but

00:42:35,559 --> 00:42:45,309
all predictions would point to being it

00:42:38,619 --> 00:42:52,740
like a swap petition now with this setup

00:42:45,309 --> 00:42:52,740
can we use be cash on top of lvm sings

00:42:53,940 --> 00:43:05,410
yes I don't know so for the public can

00:43:02,140 --> 00:43:07,660
we use it on lv m yes did a test with

00:43:05,410 --> 00:43:13,200
butter FS no all tests were done with

00:43:07,660 --> 00:43:13,200
extra just for to be conservative here

00:43:19,170 --> 00:43:24,640
now I need to wear the call a corporate

00:43:22,150 --> 00:43:26,650
head the default is butter FS only for

00:43:24,640 --> 00:43:29,380
the root partition and as I just

00:43:26,650 --> 00:43:39,099
mentioned I don't think it's sensible to

00:43:29,380 --> 00:43:43,660
use AP cash for the route no more okay

00:43:39,099 --> 00:43:47,020
then let me switch and hope that no 12

00:43:43,660 --> 00:43:50,700
minutes actually I had to leave five so

00:43:47,020 --> 00:43:50,700
it makes seven let's try

00:44:03,600 --> 00:44:08,700
that was stupid I should have switched

00:44:05,860 --> 00:44:08,700
it on earlier

00:44:21,920 --> 00:44:35,059
oh so far for the stability of of

00:44:31,700 --> 00:44:38,839
bacon Factory actually we have it fixed

00:44:35,059 --> 00:44:41,720
now but this laptop has some fixes not

00:44:38,839 --> 00:44:44,119
yet merged and we are missing some

00:44:41,720 --> 00:44:46,910
features so let's hope it boots with the

00:44:44,119 --> 00:44:49,849
big head petition destroyed which I did

00:44:46,910 --> 00:44:51,589
this morning actually isn't quite easy

00:44:49,849 --> 00:44:55,220
to really wipe the because of your

00:44:51,589 --> 00:45:09,549
machine while without totally housing

00:44:55,220 --> 00:45:09,549
the file system come on

00:45:13,270 --> 00:45:18,880
if you take this as a comment about

00:45:16,330 --> 00:45:23,400
having a faster and more stable factory

00:45:18,880 --> 00:45:23,400
I would say the answer has been given

00:45:23,970 --> 00:45:26,970
yes

00:45:32,230 --> 00:45:34,230
Oh

00:45:56,079 --> 00:46:00,790
so let me get this into my remote

00:46:04,140 --> 00:46:08,480
doesn't work cool

00:46:15,670 --> 00:46:31,170
so can everybody see everybody but I ok

00:46:26,790 --> 00:46:31,170
then let's do line typing

00:46:43,600 --> 00:46:56,840
large enough probably not now good first

00:46:54,410 --> 00:47:09,410
thing whenever your mess with big cash

00:46:56,840 --> 00:47:20,540
is load the module if you do that now

00:47:09,410 --> 00:47:23,510
i'm on the safe sighs your scissor fest

00:47:20,540 --> 00:47:25,100
files directory which has the register

00:47:23,510 --> 00:47:32,480
file which is the heart of setting up be

00:47:25,100 --> 00:47:36,620
cash and like any competent attacker we

00:47:32,480 --> 00:47:38,930
will look at the demand page first they

00:47:36,620 --> 00:47:42,430
can see we have options for creating a

00:47:38,930 --> 00:47:45,230
cash and creating a backing device and

00:47:42,430 --> 00:47:46,640
what this documentation does not tell

00:47:45,230 --> 00:47:49,700
you is that you should do this

00:47:46,640 --> 00:47:53,590
simultaneously then the association will

00:47:49,700 --> 00:47:53,590
done ultimate will be done automatically

00:48:03,760 --> 00:48:13,430
this is the second partition on the SSD

00:48:09,160 --> 00:48:19,420
and this laptop really has two hard

00:48:13,430 --> 00:48:19,420
drives so fire here we are

00:48:30,460 --> 00:48:40,000
and you can see there is a big cash

00:48:32,740 --> 00:48:42,670
device the long string of numbers in hex

00:48:40,000 --> 00:48:49,320
you see there is the unique identity of

00:48:42,670 --> 00:48:49,320
the big cash device and there we have it

00:48:49,920 --> 00:48:53,730
let's get really experimental

00:49:07,040 --> 00:49:13,609
ok you get your wish i hope i have those

00:49:11,339 --> 00:49:13,609
tools

00:49:23,470 --> 00:49:30,060
ah sorry I hope this wasn't transmitted

00:49:34,799 --> 00:49:46,910
oh no no this should be butter FS he

00:49:43,170 --> 00:49:46,910
wants it he good he'll get it

00:49:55,010 --> 00:50:00,260
yes

00:49:57,300 --> 00:50:00,260
ok

00:50:02,400 --> 00:50:04,460
you

00:50:11,220 --> 00:50:18,920
I said edit anyway would you please do

00:50:16,140 --> 00:50:18,920
what I'm telling you

00:50:20,620 --> 00:50:23,370
yes

00:50:33,679 --> 00:50:37,880
this is also wrong now

00:50:44,910 --> 00:50:52,460
do you know whether butter FS will be

00:50:48,390 --> 00:50:52,460
able to live with these attributes here

00:51:00,290 --> 00:51:03,290
false

00:51:12,829 --> 00:51:14,890
a

00:51:22,390 --> 00:51:25,440
and here we are

00:51:34,630 --> 00:51:36,690
you

00:51:41,509 --> 00:51:46,289
and it works

00:51:44,020 --> 00:51:48,919
yay

00:51:46,289 --> 00:51:48,919
so

00:51:49,490 --> 00:52:01,010
yes we are already over time so any more

00:51:53,360 --> 00:52:04,220
questions my photo publicly actually I

00:52:01,010 --> 00:52:11,000
think you are looking for some tests or

00:52:04,220 --> 00:52:14,540
some yeah report about use a chore when

00:52:11,000 --> 00:52:17,810
we can do for that and just give numbers

00:52:14,540 --> 00:52:20,780
on a real bear material because I don't

00:52:17,810 --> 00:52:28,880
think msata Singh is the right thing to

00:52:20,780 --> 00:52:32,510
test that is a question of your use case

00:52:28,880 --> 00:52:35,540
I mean modern laptops often come pre

00:52:32,510 --> 00:52:38,230
equipped with the msata drive so there

00:52:35,540 --> 00:52:41,690
will be a demand to make use of it

00:52:38,230 --> 00:52:43,550
obviously there are other use cases but

00:52:41,690 --> 00:52:46,190
I don't think you can take this to mean

00:52:43,550 --> 00:52:49,820
that one or the other use case is

00:52:46,190 --> 00:52:52,250
invalid therefore if you have your bit

00:52:49,820 --> 00:52:57,430
fact honking rate array and then

00:52:52,250 --> 00:53:07,280
probably you do want better SSD yeah

00:52:57,430 --> 00:53:09,950
that's just also gone also do you know

00:53:07,280 --> 00:53:13,460
of any deployments of be cash in

00:53:09,950 --> 00:53:22,100
production heavy maybe stumped up on

00:53:13,460 --> 00:53:25,040
some reports about it or watch it uses

00:53:22,100 --> 00:53:29,900
if you count that as production but

00:53:25,040 --> 00:53:31,220
other than that no I don't Facebook uses

00:53:29,900 --> 00:53:34,550
caching heavily but they have their own

00:53:31,220 --> 00:53:37,480
solution maybe next year I'll have a

00:53:34,550 --> 00:53:37,480
look at enhanced oil

00:53:48,559 --> 00:53:51,219
ok

00:53:54,730 --> 00:53:58,089

YouTube URL: https://www.youtube.com/watch?v=pA4PiZpo6bk


