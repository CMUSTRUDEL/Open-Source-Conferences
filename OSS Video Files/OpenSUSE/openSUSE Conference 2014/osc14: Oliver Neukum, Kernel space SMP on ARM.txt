Title: osc14: Oliver Neukum, Kernel space SMP on ARM
Publication date: 2014-04-26
Playlist: openSUSE Conference 2014
Description: 
	Most kernel code and drivers in particular are written for multiple architectures. They need to respect an abstract memory model to run on all architectures. x86 is the most relaxed of the supported architectures. You can get away with violations of that model that cause subtle bugs on other architectures. Yet x86 is the architecture most people test on. This talk is about which rules apply to ARM. It shows what can go wrong if the rules are not obeyed and how the memory model is correctly respected in drivers.
The talk has two main sections. In the first section DMA is covered. In the second section SMP is covered.
Captions: 
	00:00:00,000 --> 00:00:11,719
join us I'm going to start now so this

00:00:03,510 --> 00:00:14,820
talk is about SMP on arm and it is about

00:00:11,719 --> 00:00:19,859
SP in kernel space because there you see

00:00:14,820 --> 00:00:22,230
the problems of SMP and memory coherency

00:00:19,859 --> 00:00:24,600
in general to a greater degree day in

00:00:22,230 --> 00:00:37,110
principle also exists in user space but

00:00:24,600 --> 00:00:39,329
that's a different field ok ok so a few

00:00:37,110 --> 00:00:44,820
basics first so that definitions are

00:00:39,329 --> 00:00:47,969
clear SMD as the basic characteristics

00:00:44,820 --> 00:00:50,820
that we have multiple CPUs but they

00:00:47,969 --> 00:00:57,750
operate on the same memory and I also

00:00:50,820 --> 00:00:59,910
share the rest of the hardware so the

00:00:57,750 --> 00:01:02,370
main difference is that you have not

00:00:59,910 --> 00:01:06,060
mean but only difference is that you

00:01:02,370 --> 00:01:09,470
have multiple CPUs and in user space you

00:01:06,060 --> 00:01:13,200
don't see this because your task as such

00:01:09,470 --> 00:01:16,920
runs on a single CPU and it runs as a

00:01:13,200 --> 00:01:19,290
single thread you do not get unless he

00:01:16,920 --> 00:01:22,920
use shared memory access to the address

00:01:19,290 --> 00:01:24,450
space of other tasks and even if you do

00:01:22,920 --> 00:01:29,159
that and need to coordinate with other

00:01:24,450 --> 00:01:32,009
tasks you have special libraries main

00:01:29,159 --> 00:01:37,229
example pthread which does the job for

00:01:32,009 --> 00:01:41,509
you in kernel space this is not the case

00:01:37,229 --> 00:01:46,079
the colonel always access is all memory

00:01:41,509 --> 00:01:48,780
the physical and the virtual address

00:01:46,079 --> 00:01:54,659
space of the task calling into kernel

00:01:48,780 --> 00:01:57,560
space and so all cpus operate on the

00:01:54,659 --> 00:02:06,180
same memory without any benefit of

00:01:57,560 --> 00:02:08,789
helper libraries so this may be boring

00:02:06,180 --> 00:02:11,670
well no it may not be boring it is more

00:02:08,789 --> 00:02:16,210
boring but it is necessary

00:02:11,670 --> 00:02:19,090
memory cells have addresses as we are in

00:02:16,210 --> 00:02:23,620
an SMP system those addresses are equal

00:02:19,090 --> 00:02:28,840
0 calls across all CPUs and on arm and

00:02:23,620 --> 00:02:33,610
x86 at most CPUs but I think alpha you

00:02:28,840 --> 00:02:37,050
can address a single bite as the minimum

00:02:33,610 --> 00:02:37,050
you can address more but you need not

00:02:37,440 --> 00:02:43,810
those memory cells have values which

00:02:41,020 --> 00:02:48,220
remain unchanging hopefully or your

00:02:43,810 --> 00:02:52,780
memory is defect and they do not depend

00:02:48,220 --> 00:02:54,370
on which cpu reads them which

00:02:52,780 --> 00:02:58,630
theoretically you need not be the case

00:02:54,370 --> 00:03:00,430
but no st. system does that but this is

00:02:58,630 --> 00:03:02,980
the point for the static case and

00:03:00,430 --> 00:03:05,220
therefore I'm going to make it now so

00:03:02,980 --> 00:03:09,550
that there are no misunderstandings

00:03:05,220 --> 00:03:12,910
modern CPUs have a feature called the

00:03:09,550 --> 00:03:18,460
cache actually usually several levels of

00:03:12,910 --> 00:03:21,460
them it has the name says a caches units

00:03:18,460 --> 00:03:25,800
of main memory read from the main memory

00:03:21,460 --> 00:03:30,940
or values to be written into main memory

00:03:25,800 --> 00:03:33,700
the cache itself cannot be addressed in

00:03:30,940 --> 00:03:37,540
user space you do not get to instructor

00:03:33,700 --> 00:03:42,010
to execute special instructions usually

00:03:37,540 --> 00:03:44,560
needed to to manage the cash and one of

00:03:42,010 --> 00:03:48,910
the most salient features of caches is

00:03:44,560 --> 00:03:54,970
that they have a quite large granularity

00:03:48,910 --> 00:03:58,240
much larger than the main memory the

00:03:54,970 --> 00:04:02,440
typical value is about 128 bytes going

00:03:58,240 --> 00:04:06,520
up all the time because this granularity

00:04:02,440 --> 00:04:09,490
deep determines how much extra

00:04:06,520 --> 00:04:15,550
management memory you have to use for

00:04:09,490 --> 00:04:17,890
your cash and those specialized memory

00:04:15,550 --> 00:04:21,669
management instructions operate on the

00:04:17,890 --> 00:04:23,410
cache line as their smallest unit that

00:04:21,669 --> 00:04:25,740
is going to be important when we come to

00:04:23,410 --> 00:04:25,740
dma

00:04:26,909 --> 00:04:33,580
now I'm going to talk about memory

00:04:30,580 --> 00:04:36,370
ordering and cache coherency which is

00:04:33,580 --> 00:04:38,969
rather a special case of memory ordering

00:04:36,370 --> 00:04:45,580
if you look at it from the right angle

00:04:38,969 --> 00:04:47,439
there are three kinds of ordering I'm

00:04:45,580 --> 00:04:50,020
going to talk about the first one is the

00:04:47,439 --> 00:04:55,319
ordering between different CPUs of the

00:04:50,020 --> 00:04:58,199
same system between the CPU and

00:04:55,319 --> 00:05:04,629
secondary controllers in the system and

00:04:58,199 --> 00:05:11,650
the CPU and dma any questions so far if

00:05:04,629 --> 00:05:15,550
you have any feel free to ask so let us

00:05:11,650 --> 00:05:18,039
enter the fourth dimension our programs

00:05:15,550 --> 00:05:21,930
need to alter memory from time to time

00:05:18,039 --> 00:05:25,349
rather frequently or they are useless

00:05:21,930 --> 00:05:29,379
that can be done in several ways

00:05:25,349 --> 00:05:34,569
actually into either CPU can access

00:05:29,379 --> 00:05:38,860
memory it does so as its Code directs

00:05:34,569 --> 00:05:41,110
and to the code any access happens

00:05:38,860 --> 00:05:45,969
exactly in the order that that code

00:05:41,110 --> 00:05:49,000
determines the problem here is other

00:05:45,969 --> 00:05:51,339
cpus typically don't execute the same

00:05:49,000 --> 00:05:53,349
code as the CPU your programming is

00:05:51,339 --> 00:05:58,870
running on so they do not know that

00:05:53,349 --> 00:06:01,960
order we shall come to the significance

00:05:58,870 --> 00:06:05,139
of that point a bit later and let me

00:06:01,960 --> 00:06:07,060
first second no before that get to the

00:06:05,139 --> 00:06:12,009
second kind of memory access it can be

00:06:07,060 --> 00:06:14,680
accessed by DM a DMA we need to define

00:06:12,009 --> 00:06:18,460
it oh let's do it for the general public

00:06:14,680 --> 00:06:21,550
it's memory we for our purposes here can

00:06:18,460 --> 00:06:25,740
define it as memory access for input and

00:06:21,550 --> 00:06:30,870
output by things other than a CPU that

00:06:25,740 --> 00:06:34,509
means that you cannot use locking to

00:06:30,870 --> 00:06:37,490
synchronize access to memory areas used

00:06:34,509 --> 00:06:40,910
to that for dma locking

00:06:37,490 --> 00:06:46,039
is a CPU to work DMA controllers cannot

00:06:40,910 --> 00:06:49,669
do that locking is that what you use to

00:06:46,039 --> 00:06:55,250
ensure that changes to memory happen

00:06:49,669 --> 00:06:59,949
atomic that is a special term here means

00:06:55,250 --> 00:07:02,960
that a tasks that is not your task

00:06:59,949 --> 00:07:07,580
either sees the full result of your

00:07:02,960 --> 00:07:11,210
manipulation or nothing at all if in

00:07:07,580 --> 00:07:14,840
that case any action is reduced to a

00:07:11,210 --> 00:07:18,080
simple action memory ordering does not

00:07:14,840 --> 00:07:21,770
have happen because you cannot order a

00:07:18,080 --> 00:07:27,470
single event that is if you do not use

00:07:21,770 --> 00:07:31,490
locking then the events Yoko do acquire

00:07:27,470 --> 00:07:36,039
an internal order and other cpus may act

00:07:31,490 --> 00:07:42,860
differently depending on that order so

00:07:36,039 --> 00:07:47,120
let's look at that so this is not to say

00:07:42,860 --> 00:07:50,020
that locking is bad locking usually is a

00:07:47,120 --> 00:07:52,789
good thing it simplifies code and

00:07:50,020 --> 00:07:55,520
although it has an obvious cost you need

00:07:52,789 --> 00:07:57,500
to take the log and release it that

00:07:55,520 --> 00:08:01,039
should not trick you into assuming that

00:07:57,500 --> 00:08:03,740
loculus coding is better yes it does not

00:08:01,039 --> 00:08:07,490
have that obvious cost but it has hidden

00:08:03,740 --> 00:08:08,870
costs and it is more complex and I'm

00:08:07,490 --> 00:08:12,110
going to talk about some of the

00:08:08,870 --> 00:08:15,440
complexities here ok let's go to a

00:08:12,110 --> 00:08:18,669
conventional example you are inserting a

00:08:15,440 --> 00:08:25,039
new element into a singly linked list

00:08:18,669 --> 00:08:29,960
basic task you might think so now what

00:08:25,039 --> 00:08:33,020
do you need to do first you alter the

00:08:29,960 --> 00:08:36,020
next point of the new element and then

00:08:33,020 --> 00:08:38,599
you alter the next pointer of the

00:08:36,020 --> 00:08:43,149
element after which year new element is

00:08:38,599 --> 00:08:47,060
supposed to be inserted that is not new

00:08:43,149 --> 00:08:50,350
that is also the case if on a UMP system

00:08:47,060 --> 00:08:52,570
you are writing loculus code

00:08:50,350 --> 00:08:55,330
and you get an interrupt between the

00:08:52,570 --> 00:08:58,540
first at the second step if you were to

00:08:55,330 --> 00:09:01,270
reverse those steps and get the

00:08:58,540 --> 00:09:04,960
interrupt after your new first formally

00:09:01,270 --> 00:09:06,940
second step the next point of the new

00:09:04,960 --> 00:09:11,800
element would be followed and nobody

00:09:06,940 --> 00:09:15,340
knows where you crash difference arises

00:09:11,800 --> 00:09:18,070
on an SMP system because you have

00:09:15,340 --> 00:09:21,100
multiple CPUs and we need to ask

00:09:18,070 --> 00:09:23,860
ourselves what does the other CPUC while

00:09:21,100 --> 00:09:30,910
it actually simultaneously reads your

00:09:23,860 --> 00:09:34,890
list and in asking those questions we

00:09:30,910 --> 00:09:37,600
are using a thing called a memory model

00:09:34,890 --> 00:09:44,080
which is drastically different between

00:09:37,600 --> 00:09:47,730
arm and x86 and not just arm and x86 but

00:09:44,080 --> 00:09:51,520
basically between everything and x86

00:09:47,730 --> 00:09:54,880
memory models concern themselves with

00:09:51,520 --> 00:10:02,500
the order of events what happens after

00:09:54,880 --> 00:10:05,440
which dry matter I know so ordering of

00:10:02,500 --> 00:10:08,980
events on another cpu can be noticed by

00:10:05,440 --> 00:10:15,130
the CPU you are running on by the memory

00:10:08,980 --> 00:10:19,210
day altar so you read memory and then

00:10:15,130 --> 00:10:23,230
you observe the contents and obviously

00:10:19,210 --> 00:10:27,760
what you observe depends on the order in

00:10:23,230 --> 00:10:30,040
which you read memory a change that has

00:10:27,760 --> 00:10:32,350
not yet happened by the time you read

00:10:30,040 --> 00:10:37,600
your memory cannot be seen by you and

00:10:32,350 --> 00:10:40,590
vice versa so that means that the

00:10:37,600 --> 00:10:45,670
ordering of events a CPU observes

00:10:40,590 --> 00:10:48,300
depends on the observer and obviously it

00:10:45,670 --> 00:10:51,130
depends on the execution if something

00:10:48,300 --> 00:10:54,820
technically and physically happens after

00:10:51,130 --> 00:10:59,460
something else you will see it in that

00:10:54,820 --> 00:11:04,810
order unless by mistake so

00:10:59,460 --> 00:11:09,630
how do we determine orders of events we

00:11:04,810 --> 00:11:14,950
do so by the means of a memory barrier a

00:11:09,630 --> 00:11:18,430
memory barrier is a special CPU

00:11:14,950 --> 00:11:22,060
instruction to understand what it

00:11:18,430 --> 00:11:25,870
exactly does we need to get a bit into

00:11:22,060 --> 00:11:30,760
the theory of the chronal the kernel

00:11:25,870 --> 00:11:34,630
itself is written for a theoretical

00:11:30,760 --> 00:11:38,890
worst case which is incidentally almost

00:11:34,630 --> 00:11:41,650
identical to the Alpha architecture the

00:11:38,890 --> 00:11:45,310
assumption of the colonel is that writes

00:11:41,650 --> 00:11:50,380
can happen in any order and reads also

00:11:45,310 --> 00:11:54,790
can happen in any order this is almost

00:11:50,380 --> 00:11:58,750
true forearm rights can happen in any

00:11:54,790 --> 00:12:02,950
order reads under some conditions can

00:11:58,750 --> 00:12:06,420
happen in any order now to understand

00:12:02,950 --> 00:12:10,150
why this is so you need to ask yourself

00:12:06,420 --> 00:12:13,630
what is your CPU supposed to do if it

00:12:10,150 --> 00:12:17,470
encounters a reconstruction and can for

00:12:13,630 --> 00:12:21,730
some reason let's say TLB miss not

00:12:17,470 --> 00:12:25,930
fulfill it I have two options either you

00:12:21,730 --> 00:12:28,090
wait or you do something else and in the

00:12:25,930 --> 00:12:30,010
course of doing something else you will

00:12:28,090 --> 00:12:32,400
sooner or later it encounter another

00:12:30,010 --> 00:12:37,120
instruction to read from main memory and

00:12:32,400 --> 00:12:40,890
then you need to make a decision do I

00:12:37,120 --> 00:12:44,830
keep my instructions in order then I

00:12:40,890 --> 00:12:48,700
will now wait and stall or I do not and

00:12:44,830 --> 00:12:52,300
then the events may be reordered by

00:12:48,700 --> 00:12:55,780
reordering reads the same also applies

00:12:52,300 --> 00:13:01,780
to to rights just to a lesser extent

00:12:55,780 --> 00:13:04,660
because rights can be buffered so that

00:13:01,780 --> 00:13:08,930
is the a model the colonel is written on

00:13:04,660 --> 00:13:12,470
and it was introduced with alpha

00:13:08,930 --> 00:13:15,560
the problem in the meantime is that

00:13:12,470 --> 00:13:20,660
alpha is dead and most kernel

00:13:15,560 --> 00:13:23,510
development takes place on x86 x86 is a

00:13:20,660 --> 00:13:27,470
very nice architecture it never read or

00:13:23,510 --> 00:13:30,709
does writes it does reorder reads under

00:13:27,470 --> 00:13:36,950
some conditions but under very few

00:13:30,709 --> 00:13:40,459
conditions that is what I was referring

00:13:36,950 --> 00:13:42,980
to when I said that x86 is better than

00:13:40,459 --> 00:13:44,779
arm in that regard it really is it

00:13:42,980 --> 00:13:49,130
really better than the rest of the world

00:13:44,779 --> 00:13:53,110
it is so a cost in the CPU architecture

00:13:49,130 --> 00:13:59,660
but as a programmer you don't see that

00:13:53,110 --> 00:14:03,920
it is let me be respectful to arm worst

00:13:59,660 --> 00:14:07,100
in worse in many other features but we

00:14:03,920 --> 00:14:14,209
write code not compile us so we really

00:14:07,100 --> 00:14:17,360
don't care about an arcane instruction

00:14:14,209 --> 00:14:19,550
set or two little registers for our

00:14:17,360 --> 00:14:22,459
purposes here we are concerned with the

00:14:19,550 --> 00:14:26,270
memory coherency and all ring and there

00:14:22,459 --> 00:14:28,910
it is bed this is nothing nothing new

00:14:26,270 --> 00:14:32,570
and our kernel is totally equipped to

00:14:28,910 --> 00:14:33,920
handle it but there are rules which you

00:14:32,570 --> 00:14:37,430
need to follow if you want is to be

00:14:33,920 --> 00:14:41,060
handled and arm really requires you to

00:14:37,430 --> 00:14:44,510
follow those rules so we now have for

00:14:41,060 --> 00:14:47,150
the first time in many years actually a

00:14:44,510 --> 00:14:56,990
test case for our multi addiction

00:14:47,150 --> 00:15:01,190
support so the colonel implements three

00:14:56,990 --> 00:15:03,980
basic kinds of memory barriers one which

00:15:01,190 --> 00:15:11,329
orders rights one which orders reads and

00:15:03,980 --> 00:15:14,480
one which orders everything on arm these

00:15:11,329 --> 00:15:18,529
actually map map to those three

00:15:14,480 --> 00:15:20,720
instructions the processor takes a hint

00:15:18,529 --> 00:15:24,889
so it can order more

00:15:20,720 --> 00:15:28,399
but these three instructions for

00:15:24,889 --> 00:15:33,680
barriers in principle exist in the

00:15:28,399 --> 00:15:39,139
colonel they are supplemented by the SMP

00:15:33,680 --> 00:15:43,759
varieties the SMP varieties are there

00:15:39,139 --> 00:15:49,480
because ordering between CPUs of course

00:15:43,759 --> 00:15:56,750
only matters if you have multiple CPUs

00:15:49,480 --> 00:16:01,970
so how are they used this is I believe

00:15:56,750 --> 00:16:05,689
yes to be the most well understandable

00:16:01,970 --> 00:16:08,569
example of a memory barrier use which

00:16:05,689 --> 00:16:13,339
probably points to memory barriers not

00:16:08,569 --> 00:16:16,970
easy to use and i would agree it is from

00:16:13,339 --> 00:16:19,100
the 50 code which is written with the

00:16:16,970 --> 00:16:21,709
assumption that you can use it lock

00:16:19,100 --> 00:16:26,120
lessly if you have one reader and one

00:16:21,709 --> 00:16:29,000
writer and if those readers and writers

00:16:26,120 --> 00:16:35,300
actually operate simultaneously on on

00:16:29,000 --> 00:16:41,540
different CPUs so this is the decode for

00:16:35,300 --> 00:16:45,319
putting values into the 50 and the

00:16:41,540 --> 00:16:49,339
putting of values into a 50 involves two

00:16:45,319 --> 00:16:53,000
steps first writing the value into main

00:16:49,339 --> 00:16:57,019
memory at the correct position and then

00:16:53,000 --> 00:16:59,779
not at then but end up dating the

00:16:57,019 --> 00:17:03,500
pointer to the next value to be stored

00:16:59,779 --> 00:17:08,679
or if you implement it the whale that

00:17:03,500 --> 00:17:11,169
their pointer are points at the current

00:17:08,679 --> 00:17:14,539
content of the five foot then you would

00:17:11,169 --> 00:17:16,610
before that increase the pointer anyway

00:17:14,539 --> 00:17:18,949
the chronal model operates on the

00:17:16,610 --> 00:17:25,699
assumption that the pointer points to

00:17:18,949 --> 00:17:28,189
the next value to be written this is a

00:17:25,699 --> 00:17:31,360
bit hard to understand because the 50

00:17:28,189 --> 00:17:33,800
code in the kernel is a bit optimized it

00:17:31,360 --> 00:17:37,430
assumes that you're 50 is

00:17:33,800 --> 00:17:40,250
order of two sized so it is never

00:17:37,430 --> 00:17:44,480
necessary to actually wrap the pointers

00:17:40,250 --> 00:17:47,870
around but the masking is always done so

00:17:44,480 --> 00:17:49,790
this code is actually correct but you

00:17:47,870 --> 00:17:53,270
need to look at it for an extended

00:17:49,790 --> 00:17:57,890
period of time to understand why so you

00:17:53,270 --> 00:18:01,300
can see first we're doing the masking

00:17:57,890 --> 00:18:05,900
operation to determine the actual index

00:18:01,300 --> 00:18:09,200
then we put the value to be put into the

00:18:05,900 --> 00:18:12,410
fifo into main memory then we do the

00:18:09,200 --> 00:18:16,670
main the memory barrier and then we

00:18:12,410 --> 00:18:19,430
increase the pointer on a single

00:18:16,670 --> 00:18:26,150
processor system this code is obviously

00:18:19,430 --> 00:18:29,510
correct on a multiprocessor system it is

00:18:26,150 --> 00:18:36,800
correct only because we have to make a

00:18:29,510 --> 00:18:41,540
memory career here the reader needs to

00:18:36,800 --> 00:18:45,350
know the index for new data for the sink

00:18:41,540 --> 00:18:47,330
simple purpose of comparing the depth

00:18:45,350 --> 00:18:48,770
with the index for read data to

00:18:47,330 --> 00:18:52,610
determine whether there is anything in

00:18:48,770 --> 00:18:55,610
the buffer so the buffer would become

00:18:52,610 --> 00:19:00,340
corrupted if those steps were to be

00:18:55,610 --> 00:19:05,960
reversed because a reader would then

00:19:00,340 --> 00:19:09,620
read the already updated pointer but not

00:19:05,960 --> 00:19:11,720
read the data written into memory so

00:19:09,620 --> 00:19:16,700
this is the crucial order of the data

00:19:11,720 --> 00:19:18,230
here I hope I made clear the relevance

00:19:16,700 --> 00:19:21,730
of the ordering of the operation here

00:19:18,230 --> 00:19:21,730
any questions so far

00:19:24,669 --> 00:19:33,500
let me point it out again perhaps here

00:19:27,820 --> 00:19:36,460
we have I am too small for this here we

00:19:33,500 --> 00:19:40,370
have the masking operation which

00:19:36,460 --> 00:19:43,159
computes the actual pointer because of

00:19:40,370 --> 00:19:45,500
the limited size of the 50 then we have

00:19:43,159 --> 00:19:49,760
the right operation the memory barrier

00:19:45,500 --> 00:19:53,600
and any increase of the pointer and that

00:19:49,760 --> 00:19:58,090
is always necessary to have lockers

00:19:53,600 --> 00:20:03,019
operations on through SMP systems as

00:19:58,090 --> 00:20:06,740
practically every system today to

00:20:03,019 --> 00:20:11,630
function correctly the point here is

00:20:06,740 --> 00:20:14,149
that it would not fail on x86 under any

00:20:11,630 --> 00:20:17,389
circumstances without the right barrier

00:20:14,149 --> 00:20:20,059
the corresponding read barrier is

00:20:17,389 --> 00:20:23,769
necessary on x86 but the right barrier

00:20:20,059 --> 00:20:27,559
is not this was actually discovered with

00:20:23,769 --> 00:20:33,860
linked lists lists on powerpc therefore

00:20:27,559 --> 00:20:38,299
the example ok let's go to the next

00:20:33,860 --> 00:20:42,110
ordering constraint there is an ordering

00:20:38,299 --> 00:20:50,090
issue with other excesses of memory

00:20:42,110 --> 00:20:53,899
which are not CPUs because this is so we

00:20:50,090 --> 00:20:58,820
have SP and non SMP varieties of our

00:20:53,899 --> 00:21:01,100
barrier operations basically they do the

00:20:58,820 --> 00:21:05,500
same thing if they do the same thing

00:21:01,100 --> 00:21:05,500
which well it's not about it again and

00:21:05,559 --> 00:21:14,029
so let's put it this way they'd either

00:21:07,700 --> 00:21:16,039
do nothing or the same thing therefore

00:21:14,029 --> 00:21:20,450
you can always use the the non S&P

00:21:16,039 --> 00:21:24,549
variety if you're unsure but in case

00:21:20,450 --> 00:21:28,789
you're sure please use the SMP variety

00:21:24,549 --> 00:21:30,529
well they would be better on a UMP

00:21:28,789 --> 00:21:33,860
system but basically who cares these

00:21:30,529 --> 00:21:36,289
days anyway the colonel uses a

00:21:33,860 --> 00:21:37,540
conditional compilation and either makes

00:21:36,289 --> 00:21:42,380
them identical or

00:21:37,540 --> 00:21:46,310
reduces the ump variety to a kernel

00:21:42,380 --> 00:21:48,130
variant to a compiler barrier which does

00:21:46,310 --> 00:21:53,030
nothing more than tell the compiler that

00:21:48,130 --> 00:21:56,180
no you must not reorder anything around

00:21:53,030 --> 00:21:58,520
this operation so what the code says

00:21:56,180 --> 00:22:05,300
must actually be translated into machine

00:21:58,520 --> 00:22:09,950
code here Oh now why do we do this in

00:22:05,300 --> 00:22:14,090
your typical laptop you have a well not

00:22:09,950 --> 00:22:18,320
a but several USB controllers perhaps a

00:22:14,090 --> 00:22:21,200
firewire controller with almost hundred

00:22:18,320 --> 00:22:26,110
percent certainty ayee an ethernet

00:22:21,200 --> 00:22:29,660
controller on whether modern systems

00:22:26,110 --> 00:22:31,670
perhaps a thunderbolt controller and of

00:22:29,660 --> 00:22:36,080
course you have to the internal graphics

00:22:31,670 --> 00:22:43,250
all those chips do access main memory

00:22:36,080 --> 00:22:46,070
and not just in the manner of DNA but to

00:22:43,250 --> 00:22:49,810
actually read their own instructions yes

00:22:46,070 --> 00:22:54,350
we do have in the kernel primitives for

00:22:49,810 --> 00:22:57,830
for reading into io space but first of

00:22:54,350 --> 00:22:59,660
all I o space not main memory and modern

00:22:57,830 --> 00:23:02,930
controllers retail instruction from main

00:22:59,660 --> 00:23:05,960
memory and they only work in respect

00:23:02,930 --> 00:23:08,810
with each other so yes if you write two

00:23:05,960 --> 00:23:10,870
PCI space your rights to appear to

00:23:08,810 --> 00:23:14,870
everything in the system in that order

00:23:10,870 --> 00:23:20,110
if you write something into memory it

00:23:14,870 --> 00:23:22,250
does not need to add ESO for for any

00:23:20,110 --> 00:23:26,140
part of your chips that there is not a

00:23:22,250 --> 00:23:32,510
CPU on arm on x86 again that will work

00:23:26,140 --> 00:23:39,910
so no testing let's look at this a bit

00:23:32,510 --> 00:23:42,860
further your modern I oath chipset tests

00:23:39,910 --> 00:23:46,759
perhaps something based on the ohci

00:23:42,860 --> 00:23:49,549
standard open host controller interface

00:23:46,759 --> 00:23:54,199
these are programmable to a surprisingly

00:23:49,549 --> 00:23:57,229
large degree you more or less described

00:23:54,199 --> 00:24:00,199
to the chip the i/o transfers you want

00:23:57,229 --> 00:24:02,690
to have done and not do them so you

00:24:00,199 --> 00:24:04,820
write a program about this if you

00:24:02,690 --> 00:24:08,269
transfers and then you return to the

00:24:04,820 --> 00:24:10,940
already running program you write this

00:24:08,269 --> 00:24:12,979
in main memory and put a jump to

00:24:10,940 --> 00:24:16,820
separate in instruction and the already

00:24:12,979 --> 00:24:22,069
running program of your controller where

00:24:16,820 --> 00:24:23,569
you in wise view and consideration for a

00:24:22,069 --> 00:24:26,419
future read you left a few not

00:24:23,569 --> 00:24:32,529
instructions which can be replaced by

00:24:26,419 --> 00:24:36,559
jump T sub routines so here the order of

00:24:32,529 --> 00:24:38,239
doing stuff is again important first you

00:24:36,559 --> 00:24:42,799
write your new code for the i/o

00:24:38,239 --> 00:24:47,059
controller and then you place the call

00:24:42,799 --> 00:24:54,109
for the new code into the already

00:24:47,059 --> 00:24:57,739
running code in your driver code this is

00:24:54,109 --> 00:25:03,139
done by logic you will write a new code

00:24:57,739 --> 00:25:07,699
and then the transfer call but if you do

00:25:03,139 --> 00:25:10,849
not regard the memory adding on rights

00:25:07,699 --> 00:25:13,699
correctly it may happen that this new

00:25:10,849 --> 00:25:16,940
coat are only parts of it will be

00:25:13,699 --> 00:25:20,239
written and your i/o controller will

00:25:16,940 --> 00:25:23,929
read this and do very very bad things

00:25:20,239 --> 00:25:26,779
crash right to random parts of the main

00:25:23,929 --> 00:25:29,379
memory call other parts of the main

00:25:26,779 --> 00:25:31,699
memory it is simply not predictable

00:25:29,379 --> 00:25:34,309
usually the result of such an error

00:25:31,699 --> 00:25:42,799
would be a kernel panic and one that is

00:25:34,309 --> 00:25:46,729
almost impossible to debug so let's look

00:25:42,799 --> 00:25:51,229
at the actual implementation this is

00:25:46,729 --> 00:25:56,480
from USB code that's the queuing

00:25:51,229 --> 00:26:00,500
function of the actual transfer

00:25:56,480 --> 00:26:06,910
descriptor here at least it's its last

00:26:00,500 --> 00:26:10,790
part you see up to the memory barrier

00:26:06,910 --> 00:26:14,960
your transfer descriptor is filled out

00:26:10,790 --> 00:26:19,419
and hashed and then there is a memory

00:26:14,960 --> 00:26:23,780
barrier and this here is the instruction

00:26:19,419 --> 00:26:26,960
for changing the execution point of the

00:26:23,780 --> 00:26:30,350
ohci controller from the moment this

00:26:26,960 --> 00:26:34,000
instruction here hits main memory the

00:26:30,350 --> 00:26:39,260
code is life and may be instructed no

00:26:34,000 --> 00:26:42,260
instructed execute sorry again here the

00:26:39,260 --> 00:26:47,140
order is extremely important and here

00:26:42,260 --> 00:26:51,200
because this applies to any hardware

00:26:47,140 --> 00:26:53,030
however many CPUs it may have we do have

00:26:51,200 --> 00:27:01,010
the right memory barrier and not as a

00:26:53,030 --> 00:27:03,770
pea variety okay so in the course of

00:27:01,010 --> 00:27:07,480
reviewing drivers over a long time I've

00:27:03,770 --> 00:27:13,970
seen a lot of things that can go wrong

00:27:07,480 --> 00:27:17,210
the first one is you have some two

00:27:13,970 --> 00:27:20,540
events the first of which is a read and

00:27:17,210 --> 00:27:23,179
the second of which is a right and then

00:27:20,540 --> 00:27:26,690
some people are clever enough to put

00:27:23,179 --> 00:27:31,150
first in a right barrier and then say a

00:27:26,690 --> 00:27:34,460
rig barrier that is not equivalent a

00:27:31,150 --> 00:27:37,160
right barrier orders rights and a read

00:27:34,460 --> 00:27:40,190
barrier orders reads if you need to

00:27:37,160 --> 00:27:43,820
order a read and a right you need to use

00:27:40,190 --> 00:27:53,030
the full mb instruction and catching

00:27:43,820 --> 00:27:56,419
this that was hard the main case where

00:27:53,030 --> 00:27:59,809
this happens is that you give a command

00:27:56,419 --> 00:28:03,169
and then look Oh what is my or I or

00:27:59,809 --> 00:28:08,150
controller doing no you must put a full

00:28:03,169 --> 00:28:09,830
mb there then I found and frankly

00:28:08,150 --> 00:28:12,590
experienced it myself

00:28:09,830 --> 00:28:14,890
that it is easier for the human mind to

00:28:12,590 --> 00:28:17,179
understand why you need to order rights

00:28:14,890 --> 00:28:22,519
but it is hard to understand why you

00:28:17,179 --> 00:28:25,010
need to order reads so people tend to

00:28:22,519 --> 00:28:26,720
put in the right memory barriers but

00:28:25,010 --> 00:28:32,840
forget to put in the raid member of

00:28:26,720 --> 00:28:36,440
areas because this is so and we come to

00:28:32,840 --> 00:28:38,419
the effect that in almost all cases for

00:28:36,440 --> 00:28:40,610
each right memory barrier there must be

00:28:38,419 --> 00:28:44,570
a corresponding read memory area and

00:28:40,610 --> 00:28:48,019
vice versa the colonel coding style

00:28:44,570 --> 00:28:51,409
insists that you put a comment to each

00:28:48,019 --> 00:28:54,889
memory area pointing to its equivalent

00:28:51,409 --> 00:28:58,820
if there is one in theory it is possible

00:28:54,889 --> 00:29:00,740
that you have an ordering issue with

00:28:58,820 --> 00:29:05,210
multiple colors of the same function but

00:29:00,740 --> 00:29:09,559
that is truly a rare as one case also in

00:29:05,210 --> 00:29:12,230
the corner of this what also tends to

00:29:09,559 --> 00:29:15,580
happen is that you have a mixing of i/o

00:29:12,230 --> 00:29:18,700
primitives and main memory accesses that

00:29:15,580 --> 00:29:22,399
happens when you chip is a bit older and

00:29:18,700 --> 00:29:25,340
you do not put a jump to separate incall

00:29:22,399 --> 00:29:27,860
in its limited machine code in the main

00:29:25,340 --> 00:29:30,139
memory but you write a description of

00:29:27,860 --> 00:29:36,019
buffers to be written into main memory

00:29:30,139 --> 00:29:38,779
and then you do an i/o access many bit

00:29:36,019 --> 00:29:42,460
older skazhi and Ethernet controllers

00:29:38,779 --> 00:29:47,389
operate by that man model in that case

00:29:42,460 --> 00:29:50,870
although the access to i/o space is

00:29:47,389 --> 00:29:53,480
perfectly ordered it is not ordered with

00:29:50,870 --> 00:29:55,730
respect to the main memory access way of

00:29:53,480 --> 00:29:58,960
written the description there you need

00:29:55,730 --> 00:30:05,149
to put in a main member a full member a

00:29:58,960 --> 00:30:09,370
right memory barrier okay question so

00:30:05,149 --> 00:30:13,389
far no

00:30:09,370 --> 00:30:18,889
and we now come to the dreaded area of

00:30:13,389 --> 00:30:23,059
cache coherency and dma and this is

00:30:18,889 --> 00:30:26,480
perhaps the hardest to understand point

00:30:23,059 --> 00:30:30,049
and coming to hear because in addition

00:30:26,480 --> 00:30:33,679
to memory ordering it also involves the

00:30:30,049 --> 00:30:36,470
effect of caches but it is the problem

00:30:33,679 --> 00:30:40,639
that most driver writers most readily

00:30:36,470 --> 00:30:46,250
encounter and then get an angry email

00:30:40,639 --> 00:30:48,919
from me please fix the the DMA rule

00:30:46,250 --> 00:30:55,460
violation in your driver I've written

00:30:48,919 --> 00:30:59,750
dozens of those and I want to stop let's

00:30:55,460 --> 00:31:04,039
look into history the issue is known for

00:30:59,750 --> 00:31:09,230
a long time about eleven and a half

00:31:04,039 --> 00:31:12,320
years now bordering on 12 as I said the

00:31:09,230 --> 00:31:15,279
problem is not limited to arm it also

00:31:12,320 --> 00:31:19,639
happens and happened on on powerpc and

00:31:15,279 --> 00:31:24,279
was exactly actually discovered with the

00:31:19,639 --> 00:31:27,110
very humble source of a USB mouse it

00:31:24,279 --> 00:31:31,630
produced weird results from time to time

00:31:27,110 --> 00:31:35,980
and there was a guy named Roland dryer

00:31:31,630 --> 00:31:39,049
who really found the source of dates and

00:31:35,980 --> 00:31:45,799
we should admire him this was a mean

00:31:39,049 --> 00:31:50,330
piece of debugging so why does this

00:31:45,799 --> 00:31:55,130
happen DNA moves data between devices

00:31:50,330 --> 00:31:57,139
and memory so far so good there is an

00:31:55,130 --> 00:32:00,710
obvious race do not touch the buffers

00:31:57,139 --> 00:32:03,080
while DNA is in progress or you may read

00:32:00,710 --> 00:32:05,600
the old on a new content that has

00:32:03,080 --> 00:32:11,510
nothing to do with caches or memory or

00:32:05,600 --> 00:32:14,690
ring that basic programming but there

00:32:11,510 --> 00:32:18,559
arises an additional issue which is

00:32:14,690 --> 00:32:21,299
caused by cashing in the abstract world

00:32:18,559 --> 00:32:24,779
your buffer is just

00:32:21,299 --> 00:32:29,039
an area of memory it has an address in a

00:32:24,779 --> 00:32:32,159
length and there you go because DNA does

00:32:29,039 --> 00:32:34,049
not have access to your mm you that

00:32:32,159 --> 00:32:39,360
buffer also needs to be contiguous in

00:32:34,049 --> 00:32:41,879
physical memory but okay the kernel

00:32:39,360 --> 00:32:46,440
memory is so the only problem you would

00:32:41,879 --> 00:32:49,110
have is if you tried trying to do 00

00:32:46,440 --> 00:32:51,720
copy I oh then you have the problem that

00:32:49,110 --> 00:32:56,220
data in user space is fragmented by the

00:32:51,720 --> 00:33:00,029
n- that does not concern us here we are

00:32:56,220 --> 00:33:07,710
asking ourselves what is the problem

00:33:00,029 --> 00:33:10,799
with caches so when a cpu now when a DMA

00:33:07,710 --> 00:33:15,989
controller does the DMA the data has to

00:33:10,799 --> 00:33:20,609
hit main memory now there is a case what

00:33:15,989 --> 00:33:24,840
if that memory is cared then there are

00:33:20,609 --> 00:33:28,379
two basic options either you change or

00:33:24,840 --> 00:33:32,999
throw away the cash that's what x86 does

00:33:28,379 --> 00:33:39,840
or you do nothing and that's the option

00:33:32,999 --> 00:33:43,249
that some models of arm shows it may be

00:33:39,840 --> 00:33:49,139
obvious that doing nothing is a

00:33:43,249 --> 00:33:53,989
dangerous option but dangerous in which

00:33:49,139 --> 00:33:57,629
exact way now let's consider two cases

00:33:53,989 --> 00:34:02,730
either you use the MA for output or for

00:33:57,629 --> 00:34:05,639
input if you do it for output and only

00:34:02,730 --> 00:34:08,960
main memory is looked at by the DMA

00:34:05,639 --> 00:34:11,490
controller then what you have written

00:34:08,960 --> 00:34:14,450
into that DMA controller and the pro

00:34:11,490 --> 00:34:18,210
into that buffer under program control

00:34:14,450 --> 00:34:22,470
better be what is also in the in the

00:34:18,210 --> 00:34:24,869
main memory and not stored for a limited

00:34:22,470 --> 00:34:29,069
time and amount of time in the cache or

00:34:24,869 --> 00:34:33,679
you write garbage more or less for input

00:34:29,069 --> 00:34:33,679
the problem is a bit harder to see

00:34:34,580 --> 00:34:42,839
if you read from the buffer before your

00:34:38,730 --> 00:34:48,179
DNA is finished you obviously read the

00:34:42,839 --> 00:34:52,260
old content and that old content is

00:34:48,179 --> 00:34:57,480
outdated that is a point where logic

00:34:52,260 --> 00:35:01,200
still applies the problem is here that

00:34:57,480 --> 00:35:04,500
need not only happen when you read from

00:35:01,200 --> 00:35:09,330
the buffer but it can happen if you read

00:35:04,500 --> 00:35:13,020
some other parts of memory and that is a

00:35:09,330 --> 00:35:19,410
non intuitive effect which needs a bit

00:35:13,020 --> 00:35:23,250
of explaining as I told you before the

00:35:19,410 --> 00:35:26,040
cache is organized in cache lines now we

00:35:23,250 --> 00:35:28,589
need to consider the part the the

00:35:26,040 --> 00:35:33,750
scenario where a cache line holds your

00:35:28,589 --> 00:35:36,780
buffer and something else so everything

00:35:33,750 --> 00:35:38,880
is alright you don't read from the

00:35:36,780 --> 00:35:41,160
buffer but you innocently read something

00:35:38,880 --> 00:35:43,290
else the whole cache line gets

00:35:41,160 --> 00:35:47,940
transferred there are something in your

00:35:43,290 --> 00:35:50,220
buffer something old in your buffer but

00:35:47,940 --> 00:35:52,800
it is now cached and here comes to

00:35:50,220 --> 00:35:55,650
interrupt DMA is finished fine i'm going

00:35:52,800 --> 00:35:59,820
to read my data read that buffer get the

00:35:55,650 --> 00:36:01,830
old content now you're in trouble there

00:35:59,820 --> 00:36:05,880
is nothing you can do by this point you

00:36:01,830 --> 00:36:09,570
simply have to avoid it and to avoid

00:36:05,880 --> 00:36:13,220
this problem the colonel again abstracts

00:36:09,570 --> 00:36:18,119
it in the way that we have a DMA model

00:36:13,220 --> 00:36:21,690
the DMA model there is a buffer and that

00:36:18,119 --> 00:36:24,930
buffer is either fit for dma or fit for

00:36:21,690 --> 00:36:29,869
cpu access there is no gray area in

00:36:24,930 --> 00:36:33,089
between there are primitives which

00:36:29,869 --> 00:36:36,000
transfer the buffer between those two

00:36:33,089 --> 00:36:40,910
states either you may do do DMA or you

00:36:36,000 --> 00:36:44,700
may do you may not do dream a primitive

00:36:40,910 --> 00:36:47,790
for mapping is is map single

00:36:44,700 --> 00:36:52,440
which means now you may do DMA and if

00:36:47,790 --> 00:36:54,150
you unwrap a bit then No More DMA a few

00:36:52,440 --> 00:36:56,430
elaborate help us on this you've got a

00:36:54,150 --> 00:36:59,250
scatter gather variety you got one for a

00:36:56,430 --> 00:37:03,329
whole page and so on does not really

00:36:59,250 --> 00:37:05,510
concern us and when you are in the

00:37:03,329 --> 00:37:09,690
practical difficulty of writing a driver

00:37:05,510 --> 00:37:12,150
you will very rarely use this the USB

00:37:09,690 --> 00:37:14,099
layer in the generic part will do the

00:37:12,150 --> 00:37:16,800
mapping for you if you're writing a

00:37:14,099 --> 00:37:19,380
device driver for some kind of USB

00:37:16,800 --> 00:37:22,200
gadget you submit your data to rear

00:37:19,380 --> 00:37:26,220
speaker it maps if you're writing for

00:37:22,200 --> 00:37:28,380
some reason well on arm maybe that's an

00:37:26,220 --> 00:37:31,170
actual example and you host controller

00:37:28,380 --> 00:37:35,190
driver USB cord will handle you already

00:37:31,170 --> 00:37:39,540
mapped data so knowledge of these

00:37:35,190 --> 00:37:42,060
operations is not what you desperately

00:37:39,540 --> 00:37:51,210
need if you do this but you need to know

00:37:42,060 --> 00:37:54,810
about their limitations so their

00:37:51,210 --> 00:37:58,200
limitations are that you really must not

00:37:54,810 --> 00:38:00,030
touch the buffer in particularly in

00:37:58,200 --> 00:38:03,420
particular that means that your

00:38:00,030 --> 00:38:07,589
operations have to happen again in an

00:38:03,420 --> 00:38:10,500
exact order you first you put the data

00:38:07,589 --> 00:38:13,560
at your buffer Daniel map it then you

00:38:10,500 --> 00:38:17,569
start your DNA then you're sure that

00:38:13,560 --> 00:38:19,740
your DNA is over and then you are method

00:38:17,569 --> 00:38:23,280
strictly speaking mapping and I'm

00:38:19,740 --> 00:38:28,260
mapping need not correspond but do it

00:38:23,280 --> 00:38:32,640
anyway that verification of the end of

00:38:28,260 --> 00:38:35,609
dma is a surprisingly hard point when

00:38:32,640 --> 00:38:37,740
you write a handler for time out you

00:38:35,609 --> 00:38:42,450
then need to make sure that really your

00:38:37,740 --> 00:38:45,210
DNA is not going to proceed because

00:38:42,450 --> 00:38:47,660
whenever you write in a handler for time

00:38:45,210 --> 00:38:50,280
out you are racing against the hardware

00:38:47,660 --> 00:38:52,680
there is the unlikely case that your i/o

00:38:50,280 --> 00:38:54,960
was exceptionally slow and really

00:38:52,680 --> 00:38:57,310
completes although the timeout was

00:38:54,960 --> 00:39:01,190
already called

00:38:57,310 --> 00:39:03,380
furthermore and theory the mapping

00:39:01,190 --> 00:39:06,830
functions can fail then you need to use

00:39:03,380 --> 00:39:14,690
a bad spot for failure to limited

00:39:06,830 --> 00:39:18,290
address space or whatever then you

00:39:14,690 --> 00:39:22,400
really need to look at the ordering

00:39:18,290 --> 00:39:26,540
constraints here listed in practice how

00:39:22,400 --> 00:39:31,100
do we do this we do not know the cache

00:39:26,540 --> 00:39:37,010
line size of our CPU and we really must

00:39:31,100 --> 00:39:41,330
not for us we stay with the model of the

00:39:37,010 --> 00:39:47,530
logical buffer given by a starting point

00:39:41,330 --> 00:39:51,050
and a length and the hardware does

00:39:47,530 --> 00:39:53,810
translate this abstraction into the

00:39:51,050 --> 00:39:57,070
appropriate invalidation of flushing

00:39:53,810 --> 00:40:00,850
operations on the cache line and

00:39:57,070 --> 00:40:03,650
computes by itself and with the help of

00:40:00,850 --> 00:40:06,620
architecture specific code which flash

00:40:03,650 --> 00:40:09,770
cache lines are to be flashed flushed or

00:40:06,620 --> 00:40:12,770
invalidated you are not supposed to

00:40:09,770 --> 00:40:15,320
concern that with yourself concern

00:40:12,770 --> 00:40:18,670
yourself with that for you the only

00:40:15,320 --> 00:40:26,570
question is where do I get clean buffers

00:40:18,670 --> 00:40:31,000
which do not share their cache lines

00:40:26,570 --> 00:40:35,720
with anything else you do that by

00:40:31,000 --> 00:40:39,520
obeying those routes at any time and not

00:40:35,720 --> 00:40:42,140
to share a buffer for multiple purposes

00:40:39,520 --> 00:40:46,690
they're always happen those clever

00:40:42,140 --> 00:40:51,230
people which have three sources of DNA

00:40:46,690 --> 00:40:54,530
one large and two small and okay we can

00:40:51,230 --> 00:40:57,440
be efficient here let's allocate one

00:40:54,530 --> 00:41:00,170
buffer large enough for the large large

00:40:57,440 --> 00:41:03,110
transfer and while that not does not go

00:41:00,170 --> 00:41:06,560
on we share the buffer between the two

00:41:03,110 --> 00:41:08,960
other operations does not work with for

00:41:06,560 --> 00:41:14,060
this reason and furthermore

00:41:08,960 --> 00:41:17,300
if userspace handles you a a user space

00:41:14,060 --> 00:41:19,970
address for using data to copy it in a

00:41:17,300 --> 00:41:25,220
special buffer if you want to do zero

00:41:19,970 --> 00:41:28,280
copy yes it would have more performance

00:41:25,220 --> 00:41:31,400
but you have to make sure that user

00:41:28,280 --> 00:41:35,119
space does not touch that page in which

00:41:31,400 --> 00:41:38,780
is purpose of in worst-case pages into

00:41:35,119 --> 00:41:41,270
which these buffers are put and that's

00:41:38,780 --> 00:41:46,599
not as simple as it looks like so no

00:41:41,270 --> 00:41:49,730
sharing and keep your cash landscape

00:41:46,599 --> 00:41:53,630
that's what it boils down to the colonel

00:41:49,730 --> 00:41:56,359
knows the cache line size of the deep

00:41:53,630 --> 00:41:59,960
CPU or can determine it you don't care

00:41:56,359 --> 00:42:02,540
you just get a clean buffer and you get

00:41:59,960 --> 00:42:04,760
it from came a lock and every K now log

00:42:02,540 --> 00:42:08,920
will give you something which is

00:42:04,760 --> 00:42:12,170
suitable for a buffer and you use that

00:42:08,920 --> 00:42:15,290
memory allocation for one buffer and one

00:42:12,170 --> 00:42:18,710
buffer only and for each buffer you use

00:42:15,290 --> 00:42:22,520
your own game okay now lock and you put

00:42:18,710 --> 00:42:25,010
nothing else in it and don't share it

00:42:22,520 --> 00:42:28,849
you may recycle it if you really want to

00:42:25,010 --> 00:42:31,940
but that's what it boils down to okay no

00:42:28,849 --> 00:42:36,920
sharing we're strictly selfish here and

00:42:31,940 --> 00:42:39,640
all is right good any questions our

00:42:36,920 --> 00:42:39,640
standard disclaimer

00:42:42,120 --> 00:42:51,760
yeah was too theoretical oh nothing to

00:42:47,590 --> 00:42:56,440
talk about it you get very subtle bugs

00:42:51,760 --> 00:43:00,790
there which are extremely hard to debug

00:42:56,440 --> 00:43:02,410
because obviously if you put any further

00:43:00,790 --> 00:43:09,280
instructions that you mess up the whole

00:43:02,410 --> 00:43:12,540
timing you will not see anything yes to

00:43:09,280 --> 00:43:15,670
hand you this microphone have there been

00:43:12,540 --> 00:43:19,120
recently or whenever some bugs that have

00:43:15,670 --> 00:43:22,330
been in the kernel for a long time and

00:43:19,120 --> 00:43:27,930
then they were discovered when arm was

00:43:22,330 --> 00:43:27,930
used because arm SP is not that old

00:43:28,440 --> 00:43:37,660
actually the one real buck we found was

00:43:35,140 --> 00:43:40,990
the one with the mouse and this was

00:43:37,660 --> 00:43:45,870
fixed a long time ago we routinely find

00:43:40,990 --> 00:43:51,100
such EMA bucks but we find them by

00:43:45,870 --> 00:43:54,130
visual inspection of the code we can

00:43:51,100 --> 00:43:55,930
from the loss of great numbers deduct

00:43:54,130 --> 00:44:00,040
that some of the random crashes that

00:43:55,930 --> 00:44:02,730
happen are caused by this but there is

00:44:00,040 --> 00:44:07,150
no way to fight this because this

00:44:02,730 --> 00:44:10,870
depends on the old the timing a very

00:44:07,150 --> 00:44:13,240
sensitive manner if you put a switch on

00:44:10,870 --> 00:44:15,690
dynamic debugging or something else it

00:44:13,240 --> 00:44:15,690
won't show

00:44:22,710 --> 00:44:42,630
good then we can end here and over to

00:44:26,950 --> 00:44:42,630

YouTube URL: https://www.youtube.com/watch?v=3P7LxO9NAwM


