Title: openSUSE Conference 2017 Libabigail: How semantic analysis of C and C++ ELF binaries can be used to
Publication date: 2017-05-28
Playlist: openSUSE Conference 2017
Description: 
	https://media.ccc.de/v/1234-libabigail-how-semantic-analysis-of-c-and-c-elf-binaries-can-be-used-to-analyze-abi-changes



Libabigail is an infrastructure for semantic analysis of ELF binaries containing C or C++ programs. It powers command line tools like ‘abidiff’, which let users compare ABI changes between two different versions of a given ELF binary by analyzing just the binary and its ancillary debug information.

The result of the binary comparison is a kind of hierarchical ‘diff’ which shows changes up to the types of the interfaces that constitute the ABI of an ELF program.

This infrastructure allows software distributors (among other actors) to build specific tooling to review and analyze ABI changes that might occur whenever a shared library package is updated.  That tooling might even be tailored to automatically prevent packages with unwanted incompatible ABI changes to reach users.

This talk intends to present Libabigail, its architecture, its capabilities, its current limits, its associated tools and how it might be used to further build highly tailored ABI verification tooling.  The talk will also explore the potential improvement paths that are currently identified, and from the feedback of the audience, explore improvement paths that are not yet identified.



dodjiseketeli
Captions: 
	00:00:07,280 --> 00:00:15,599
so hello everybody thank you for

00:00:11,370 --> 00:00:23,029
attending this this talk I know it's

00:00:15,599 --> 00:00:27,240
right after lunch so you might be well

00:00:23,029 --> 00:00:30,330
thank you for being here so yeah my name

00:00:27,240 --> 00:00:34,860
is doji I work for Red Hat in the tools

00:00:30,330 --> 00:00:39,690
team and my background is well a little

00:00:34,860 --> 00:00:44,000
bit in compilers and debuggers and since

00:00:39,690 --> 00:00:51,110
a little while have been working on our

00:00:44,000 --> 00:00:54,660
static analysis of elf binaries to infer

00:00:51,110 --> 00:00:57,809
interesting things about ABI and stuff

00:00:54,660 --> 00:01:01,340
so as a result we came up with a

00:00:57,809 --> 00:01:07,070
framework named a Big L which is an

00:01:01,340 --> 00:01:10,439
acronym for a bi generic analysis and

00:01:07,070 --> 00:01:16,110
instrumentation library well it's also

00:01:10,439 --> 00:01:24,659
the name of the wife of my oil the guy

00:01:16,110 --> 00:01:27,810
we started the project with so anyway so

00:01:24,659 --> 00:01:32,189
we use a be able to to basically compare

00:01:27,810 --> 00:01:36,240
binaries and come up with reports about

00:01:32,189 --> 00:01:39,479
the differences they have as far as ABI

00:01:36,240 --> 00:01:42,590
is concerned so this can be really

00:01:39,479 --> 00:01:47,700
interesting to folks ranging from

00:01:42,590 --> 00:01:51,630
developers up to people pushing bits

00:01:47,700 --> 00:01:56,549
coming out of the developers hand namely

00:01:51,630 --> 00:01:59,040
these true people and I thought it will

00:01:56,549 --> 00:02:00,899
be interesting to come and talk to you

00:01:59,040 --> 00:02:04,350
guys about what we've been doing at this

00:02:00,899 --> 00:02:05,790
in this area and maybe we can we can you

00:02:04,350 --> 00:02:09,000
know find areas where we can work

00:02:05,790 --> 00:02:10,830
together and improve what we have or you

00:02:09,000 --> 00:02:13,609
know change directions well and well

00:02:10,830 --> 00:02:16,459
discuss so

00:02:13,609 --> 00:02:20,370
today's in today's talk I'm going to

00:02:16,459 --> 00:02:22,349
first try and define what we mean by a

00:02:20,370 --> 00:02:26,159
bi you know this is a quite fluid

00:02:22,349 --> 00:02:29,219
concept it's not well defined and so it

00:02:26,159 --> 00:02:31,950
means different things for everyone so I

00:02:29,219 --> 00:02:34,920
thought it would be an interesting take

00:02:31,950 --> 00:02:36,629
to try to define what actually we what

00:02:34,920 --> 00:02:39,329
we actually mean by that in this project

00:02:36,629 --> 00:02:42,349
and then we'll talk about what we mean

00:02:39,329 --> 00:02:45,419
by a bi compatibility once we have

00:02:42,349 --> 00:02:49,169
definition for the ABI and then I'll

00:02:45,419 --> 00:02:52,319
jump straight to some examples of change

00:02:49,169 --> 00:02:57,049
reports we can have with the framework

00:02:52,319 --> 00:03:01,590
we have today once we have that we'll

00:02:57,049 --> 00:03:04,879
dive into what abigail is what it does

00:03:01,590 --> 00:03:08,609
how we perform those static analysis

00:03:04,879 --> 00:03:11,010
texts and see how it is used in real

00:03:08,609 --> 00:03:16,230
life today and then we'll talk about

00:03:11,010 --> 00:03:17,699
possible improvement and and well I say

00:03:16,230 --> 00:03:19,709
we'll talk because I'll present

00:03:17,699 --> 00:03:23,299
something but if you have ideas please

00:03:19,709 --> 00:03:25,250
feel free to to come up with those and

00:03:23,299 --> 00:03:30,889
so here we are

00:03:25,250 --> 00:03:34,799
so for to define what an ABI is well

00:03:30,889 --> 00:03:38,090
let's set a context first okay suppose

00:03:34,799 --> 00:03:43,109
we have a binary we which will name e

00:03:38,090 --> 00:03:47,370
and that binary uses a code from another

00:03:43,109 --> 00:03:49,739
binary that we call L so basically it

00:03:47,370 --> 00:03:53,759
can be an executable well that's where

00:03:49,739 --> 00:03:55,199
the e comes from or a shared library if

00:03:53,759 --> 00:03:57,989
there is something that is not clear

00:03:55,199 --> 00:04:01,620
please just stop me right ahead you know

00:03:57,989 --> 00:04:06,509
rather than waiting for the end so

00:04:01,620 --> 00:04:08,669
that's what E is and L can be well the

00:04:06,509 --> 00:04:12,239
shared library it's a library that's

00:04:08,669 --> 00:04:17,070
where the L come from and it can also be

00:04:12,239 --> 00:04:21,859
a dynamically loaded module so this is

00:04:17,070 --> 00:04:25,039
the basic context so at X at

00:04:21,859 --> 00:04:28,849
execution time what happens is that is

00:04:25,039 --> 00:04:31,580
that II expect properties from L in this

00:04:28,849 --> 00:04:34,849
well in these all these context I wanted

00:04:31,580 --> 00:04:35,689
to say that we're talking about mostly

00:04:34,849 --> 00:04:38,990
about elf

00:04:35,689 --> 00:04:40,759
you know the elf Linux format right now

00:04:38,990 --> 00:04:43,460
this is what we support we could support

00:04:40,759 --> 00:04:46,879
other things in the future but right now

00:04:43,460 --> 00:04:51,110
we're talking about elf so II expects

00:04:46,879 --> 00:04:53,060
properties from L at execution time so

00:04:51,110 --> 00:04:55,849
those properties can be things like the

00:04:53,060 --> 00:05:00,620
format of the binary the architecture

00:04:55,849 --> 00:05:03,860
well an executable are on x86 executable

00:05:00,620 --> 00:05:07,669
will expect an x86 library for instance

00:05:03,860 --> 00:05:12,229
right x86 dwarf well um elf will expect

00:05:07,669 --> 00:05:14,539
on x86 elf library for instance it will

00:05:12,229 --> 00:05:18,229
also expect the presence of certain elf

00:05:14,539 --> 00:05:20,779
symbols symbols coming from either

00:05:18,229 --> 00:05:24,919
functions or you know global variables

00:05:20,779 --> 00:05:27,770
or other things specific layout of data

00:05:24,919 --> 00:05:30,560
when I talk about this I mean types you

00:05:27,770 --> 00:05:33,349
know specific types of data and an a

00:05:30,560 --> 00:05:37,339
specific you know size alignment

00:05:33,349 --> 00:05:40,699
you know offset etc etc there are also

00:05:37,339 --> 00:05:43,750
other stuff like uh you know calling

00:05:40,699 --> 00:05:47,930
convention and etc etc but the first

00:05:43,750 --> 00:05:53,270
three are the things we're going to

00:05:47,930 --> 00:05:55,099
focus on more here so I wanted to stress

00:05:53,270 --> 00:05:57,020
also that those properties are

00:05:55,099 --> 00:06:00,259
structural they talk about the structure

00:05:57,020 --> 00:06:02,960
of the program not its behavior we're

00:06:00,259 --> 00:06:06,110
not talking about bugs where we want we

00:06:02,960 --> 00:06:08,389
were supposed to add two numbers and we

00:06:06,110 --> 00:06:09,469
were now we are now dividing them things

00:06:08,389 --> 00:06:11,419
like that we're not talking about

00:06:09,469 --> 00:06:14,659
dynamic thanks we're talking about

00:06:11,419 --> 00:06:15,820
structure you know types layout things

00:06:14,659 --> 00:06:23,630
like that

00:06:15,820 --> 00:06:28,130
so those properties that are loosely

00:06:23,630 --> 00:06:31,250
defined somehow are what we call the API

00:06:28,130 --> 00:06:39,470
those properties that II expect from L

00:06:31,250 --> 00:06:41,300
those are the ABI of L so more

00:06:39,470 --> 00:06:43,669
specifically when we talk about the ABI

00:06:41,300 --> 00:06:45,320
of a library or a binary in general

00:06:43,669 --> 00:06:47,539
we'll be talking about the set of

00:06:45,320 --> 00:06:51,650
symbols that it you know that it defines

00:06:47,539 --> 00:06:55,310
an an export and also the layout of the

00:06:51,650 --> 00:06:58,039
data expected by those symbols so from

00:06:55,310 --> 00:07:00,590
now on I will stop talking about symbols

00:06:58,039 --> 00:07:03,650
I'll talk about functions you know and

00:07:00,590 --> 00:07:05,960
variables because well that is what

00:07:03,650 --> 00:07:09,830
programmers I care about even though a

00:07:05,960 --> 00:07:13,250
function in source code end up being

00:07:09,830 --> 00:07:15,620
okay usually a symbol right in elf but

00:07:13,250 --> 00:07:17,720
we want to talk about things that are

00:07:15,620 --> 00:07:19,789
meaningful to developers so I'm going to

00:07:17,720 --> 00:07:25,389
talk about now functions and variables

00:07:19,789 --> 00:07:29,030
now so one thing to keep in mind is that

00:07:25,389 --> 00:07:31,669
API changes are there to stay they are

00:07:29,030 --> 00:07:35,990
inevitable in our free software world I

00:07:31,669 --> 00:07:38,090
mean we want our software to involve to

00:07:35,990 --> 00:07:42,020
evolve you know we've been talking about

00:07:38,090 --> 00:07:46,970
this all these during all these three

00:07:42,020 --> 00:07:49,789
days so we want we don't want to cast

00:07:46,970 --> 00:07:51,500
things in stone and say oh no you don't

00:07:49,789 --> 00:07:53,330
you can't change anything anymore

00:07:51,500 --> 00:07:55,849
because you're going to break ABI what

00:07:53,330 --> 00:07:58,120
whatever that means things are going to

00:07:55,849 --> 00:08:01,010
change and the API is going to evolve

00:07:58,120 --> 00:08:05,030
because we are fixing bugs we're adding

00:08:01,010 --> 00:08:07,669
features we want to kick to kick ass

00:08:05,030 --> 00:08:09,949
basically so we're going to add new

00:08:07,669 --> 00:08:14,659
functions we're going to add new global

00:08:09,949 --> 00:08:17,449
variables how we are going to change the

00:08:14,659 --> 00:08:20,000
signatures types and whatever of the

00:08:17,449 --> 00:08:21,800
existing functions all those things are

00:08:20,000 --> 00:08:24,590
going to happen and we want these things

00:08:21,800 --> 00:08:27,650
to keep happening but then what we want

00:08:24,590 --> 00:08:29,960
is to be able to detect

00:08:27,650 --> 00:08:39,740
the subset of those changes that are

00:08:29,960 --> 00:08:44,360
harmful so can you read this yeah so in

00:08:39,740 --> 00:08:46,790
this come in this context to us only

00:08:44,360 --> 00:08:51,760
what we call a bi incompatible changes

00:08:46,790 --> 00:08:55,880
are harmful for instance if you remove a

00:08:51,760 --> 00:08:57,740
a function that was there and that was

00:08:55,880 --> 00:09:02,140
there in L in the library and that was

00:08:57,740 --> 00:09:05,060
expected by the executable that is a

00:09:02,140 --> 00:09:08,300
harmful ABI change

00:09:05,060 --> 00:09:13,190
it's an ABI incompatible change because

00:09:08,300 --> 00:09:15,230
a new well existing is you know existing

00:09:13,190 --> 00:09:19,670
banner is executable binaries that are

00:09:15,230 --> 00:09:22,340
in nature well I will expect that

00:09:19,670 --> 00:09:27,110
function that you removed from your

00:09:22,340 --> 00:09:29,600
newer version of the library ah the same

00:09:27,110 --> 00:09:32,000
thing goes for incompatible you know

00:09:29,600 --> 00:09:36,830
data layout changes basically you have a

00:09:32,000 --> 00:09:39,800
type in which you removed a you know a

00:09:36,830 --> 00:09:44,420
structure in which you remove a data

00:09:39,800 --> 00:09:47,930
member things like that or you I don't

00:09:44,420 --> 00:09:50,720
know removed or added a function

00:09:47,930 --> 00:09:52,760
parameter things like that so you see

00:09:50,720 --> 00:09:54,500
I'm not talking about symbols anymore at

00:09:52,760 --> 00:09:59,230
this point even though we're looking at

00:09:54,500 --> 00:10:03,520
binaries and it follows that a bi

00:09:59,230 --> 00:10:07,190
compatible changes are fine they're fine

00:10:03,520 --> 00:10:09,380
but we might need to see those you know

00:10:07,190 --> 00:10:12,410
to still see them and we view them and

00:10:09,380 --> 00:10:14,780
be sure that oh this change even though

00:10:12,410 --> 00:10:17,300
it's not bad is really a kind of change

00:10:14,780 --> 00:10:25,120
I expect it you know just from looking

00:10:17,300 --> 00:10:26,680
at the binary ah so one thing to keep

00:10:25,120 --> 00:10:29,650
mind is that we want to be able to

00:10:26,680 --> 00:10:32,320
detect all those things by looking at

00:10:29,650 --> 00:10:36,100
the binaries only not by looking at the

00:10:32,320 --> 00:10:38,050
source code you know this is really

00:10:36,100 --> 00:10:40,839
important to keep in mind because well

00:10:38,050 --> 00:10:42,580
there are many reasons why why we want

00:10:40,839 --> 00:10:43,660
this but I think most of the district

00:10:42,580 --> 00:10:46,750
people get this right

00:10:43,660 --> 00:10:50,620
when you have well compilations is a

00:10:46,750 --> 00:10:52,839
kind of this destructive process there's

00:10:50,620 --> 00:10:55,210
some information that are not there

00:10:52,839 --> 00:10:57,400
anymore but there are also some

00:10:55,210 --> 00:10:59,500
information that are there that you

00:10:57,400 --> 00:11:02,260
can't see when you look at the source

00:10:59,500 --> 00:11:04,360
code for instance when you look at well

00:11:02,260 --> 00:11:07,779
we'll see that later in some of these

00:11:04,360 --> 00:11:10,600
examples that I have but when you look

00:11:07,779 --> 00:11:12,940
at a data structure a class or struct

00:11:10,600 --> 00:11:15,790
for instance you you don't know what the

00:11:12,940 --> 00:11:16,960
offsets of the data members are just by

00:11:15,790 --> 00:11:18,940
looking at the source code you have to

00:11:16,960 --> 00:11:21,339
think right but when you look at the

00:11:18,940 --> 00:11:22,900
binary boom you have those information

00:11:21,339 --> 00:11:24,990
so looking at the binary is really

00:11:22,900 --> 00:11:28,089
interesting because it reveals things

00:11:24,990 --> 00:11:32,140
that are hard to see when you just look

00:11:28,089 --> 00:11:33,790
at the source code and we want to be

00:11:32,140 --> 00:11:35,680
able to detect those things as soon as

00:11:33,790 --> 00:11:38,110
possible you know it's not when you are

00:11:35,680 --> 00:11:41,560
building the final stage of the distro

00:11:38,110 --> 00:11:44,589
that you want to detect those things as

00:11:41,560 --> 00:11:50,290
soon as possible in the dev process is

00:11:44,589 --> 00:11:53,709
what we want and we need to keep in mind

00:11:50,290 --> 00:11:56,410
that there is no magic here most of the

00:11:53,709 --> 00:12:01,750
most most of the interesting changes

00:11:56,410 --> 00:12:03,730
need a human review you know to to well

00:12:01,750 --> 00:12:06,820
to know if they're harmful or not so you

00:12:03,730 --> 00:12:08,950
need to make those changes changes stick

00:12:06,820 --> 00:12:13,029
out you know from from the noise and

00:12:08,950 --> 00:12:16,000
then have some folks to review them just

00:12:13,029 --> 00:12:18,790
like you review you know patches so for

00:12:16,000 --> 00:12:22,270
that what we want to use is to use the

00:12:18,790 --> 00:12:24,670
diff paradigm we have already well to

00:12:22,270 --> 00:12:26,920
let people review those ABI changes just

00:12:24,670 --> 00:12:29,080
as we review patches today which is

00:12:26,920 --> 00:12:31,150
something we don't do yet right

00:12:29,080 --> 00:12:34,870
but well this is the philosophy we're

00:12:31,150 --> 00:12:37,500
following while developing those tools

00:12:34,870 --> 00:12:42,650
and framework and so on and so forth

00:12:37,500 --> 00:12:52,080
so yeah I danced had the music here so

00:12:42,650 --> 00:12:54,090
let's look at some examples yeah okay so

00:12:52,080 --> 00:13:04,050
this is the place where the time where I

00:12:54,090 --> 00:13:05,520
switched it so so in this case what am I

00:13:04,050 --> 00:13:08,250
wanted I just wanted to show you

00:13:05,520 --> 00:13:10,590
something very quick I have a friend

00:13:08,250 --> 00:13:12,480
here Frederick who told me once you know

00:13:10,590 --> 00:13:15,810
it was probably fifteen years ago or

00:13:12,480 --> 00:13:17,550
something that chewing code about what

00:13:15,810 --> 00:13:18,720
you're demonstrating is a really bad

00:13:17,550 --> 00:13:21,720
thing to do right

00:13:18,720 --> 00:13:24,090
but here I'm not showing the code of the

00:13:21,720 --> 00:13:26,040
baby girl I'm showing the code well the

00:13:24,090 --> 00:13:29,390
baby girl works on code so I'm I'm not

00:13:26,040 --> 00:13:35,600
you know it's different what I'm doing

00:13:29,390 --> 00:13:40,380
so so here the a I wanted to show you I

00:13:35,600 --> 00:13:43,560
hit this so here you have a small

00:13:40,380 --> 00:13:46,770
function you know f one that has one

00:13:43,560 --> 00:13:50,310
parameter and here you have in a new

00:13:46,770 --> 00:13:53,580
version f1 on another version in which I

00:13:50,310 --> 00:13:55,790
added a parameter right and I probably

00:13:53,580 --> 00:13:59,270
yeah that's the only thing I did I guess

00:13:55,790 --> 00:14:05,880
so I want to I wanted to show you what

00:13:59,270 --> 00:14:10,530
Ali Baba girl based tool you know C's so

00:14:05,880 --> 00:14:15,140
I've compiled these things well I can

00:14:10,530 --> 00:14:23,610
run the compiler again just to show that

00:14:15,140 --> 00:14:25,830
I'm not ah yeah this is an artist set up

00:14:23,610 --> 00:14:35,790
and it's like I'm on the piano or

00:14:25,830 --> 00:14:38,220
something and yeah okay so so I compile

00:14:35,790 --> 00:14:41,310
this and I'm I'm just calling a tool

00:14:38,220 --> 00:14:44,340
named ABI dev and I give AP idea of the

00:14:41,310 --> 00:14:47,580
first version of of the binary you know

00:14:44,340 --> 00:14:50,010
live example one yeah I wrote this this

00:14:47,580 --> 00:14:51,450
morning while having a chat with a

00:14:50,010 --> 00:14:53,610
fellow here soo

00:14:51,450 --> 00:14:56,130
I couldn't find a better name I was more

00:14:53,610 --> 00:14:58,880
involved in our discussion so leap

00:14:56,130 --> 00:15:01,440
example 1 dot so0

00:14:58,880 --> 00:15:01,980
compared to lib example one that I saw

00:15:01,440 --> 00:15:05,750
that one

00:15:01,980 --> 00:15:19,370
Oh boom oh sorry I should put that in a

00:15:05,750 --> 00:15:19,370
red rag that into a file named ABI so

00:15:19,460 --> 00:15:28,520
have you seen what I what I did so I

00:15:24,200 --> 00:15:32,700
called a banner a program named ABI div

00:15:28,520 --> 00:15:37,560
right it's a program part of the Lib

00:15:32,700 --> 00:15:42,090
Abigail tool set that compares the ABI

00:15:37,560 --> 00:15:47,430
of two binaries ABI div and so here is

00:15:42,090 --> 00:15:49,130
the result of what it says so can you

00:15:47,430 --> 00:15:55,020
read that

00:15:49,130 --> 00:15:58,190
yeah okay it just says that here so it

00:15:55,020 --> 00:16:04,100
shows you so it says the function f1

00:15:58,190 --> 00:16:08,790
like you know with its signature has

00:16:04,100 --> 00:16:11,760
some changes in one of his it's subtypes

00:16:08,790 --> 00:16:16,110
right and the change is that the

00:16:11,760 --> 00:16:20,690
parameter 2 was added that's all and

00:16:16,110 --> 00:16:27,920
this is actually what we did if I do a

00:16:20,690 --> 00:16:27,920
div of the source code ah sorry

00:16:30,530 --> 00:16:33,530
v1

00:16:45,740 --> 00:16:53,340
so you see here the sort do you see that

00:16:48,510 --> 00:16:58,830
can you read that so this is a diff and

00:16:53,340 --> 00:17:02,130
so this is an N N and so this is the

00:16:58,830 --> 00:17:04,890
source this is an example of the end of

00:17:02,130 --> 00:17:06,600
report you get you know from from

00:17:04,890 --> 00:17:08,010
looking at the binary so you see that

00:17:06,600 --> 00:17:09,890
even though you're just looking at the

00:17:08,010 --> 00:17:12,000
binary and it's debug information

00:17:09,890 --> 00:17:14,010
because I've compiled this with debug

00:17:12,000 --> 00:17:16,680
information enabled you can have quite

00:17:14,010 --> 00:17:19,500
some detailed information right the line

00:17:16,680 --> 00:17:24,300
number is etc etc so we can move to

00:17:19,500 --> 00:17:28,200
something more involved with you know

00:17:24,300 --> 00:17:31,320
C++ so here we have in in blue here we

00:17:28,200 --> 00:17:34,430
have a class don't really need to read

00:17:31,320 --> 00:17:38,910
the details we have a class here and

00:17:34,430 --> 00:17:41,910
that mass is used by another class

00:17:38,910 --> 00:17:46,290
structure it is used here because we use

00:17:41,910 --> 00:17:51,960
C units last name is C and we you see in

00:17:46,290 --> 00:17:54,870
another type underneath here and you see

00:17:51,960 --> 00:17:58,590
I still have a function named f1 that

00:17:54,870 --> 00:18:10,530
uses C and I have a function named f2

00:17:58,590 --> 00:18:15,270
that uses and of course on the second

00:18:10,530 --> 00:18:18,810
side the thing that is highlighted in

00:18:15,270 --> 00:18:23,370
blue is well I created a base class so I

00:18:18,810 --> 00:18:25,580
changed C and midsi inherit a new class

00:18:23,370 --> 00:18:28,620
like this you know I was listening to

00:18:25,580 --> 00:18:30,840
the fellow over there so this was my

00:18:28,620 --> 00:18:34,380
it's because of him you know that

00:18:30,840 --> 00:18:38,130
inspiration came from you so I just made

00:18:34,380 --> 00:18:40,650
this change and well I was like ok how

00:18:38,130 --> 00:18:43,470
about adding a virtual here for instance

00:18:40,650 --> 00:18:46,380
in the class well the idea is just to

00:18:43,470 --> 00:18:50,850
make some changes and see what a be IDF

00:18:46,380 --> 00:18:51,480
says and I kept f1 as is you know I

00:18:50,850 --> 00:18:58,670
didn't

00:18:51,480 --> 00:19:01,320
signature ah and I kept f2 as is - oh

00:18:58,670 --> 00:19:06,360
well there is also an f3

00:19:01,320 --> 00:19:13,640
but anyway let's go did I try it oh yes

00:19:06,360 --> 00:19:17,330
so I compiled it as previously and I

00:19:13,640 --> 00:19:21,480
guess oh yeah

00:19:17,330 --> 00:19:24,090
I'm putting the result into a file so

00:19:21,480 --> 00:19:26,310
I'm running a B idea on the two binaries

00:19:24,090 --> 00:19:30,420
putting a result into a file text file

00:19:26,310 --> 00:19:40,860
and then I'm opening the text file in

00:19:30,420 --> 00:19:41,700
Emacs ah so so the changes are

00:19:40,860 --> 00:19:44,940
interesting here

00:19:41,700 --> 00:19:47,190
so first let's let's look at the summary

00:19:44,940 --> 00:19:49,320
of the changes that is shown right let's

00:19:47,190 --> 00:19:51,630
all say that there is one function that

00:19:49,320 --> 00:19:54,900
was changed change means that one of the

00:19:51,630 --> 00:19:58,620
types used by the function or subtypes

00:19:54,900 --> 00:20:00,630
no types of those types ah change right

00:19:58,620 --> 00:20:03,870
and it's also said that one function was

00:20:00,630 --> 00:20:06,930
added you know adding a function is not

00:20:03,870 --> 00:20:09,090
a problem right as I said earlier it's

00:20:06,930 --> 00:20:11,730
an ABI change but it's not necessarily a

00:20:09,090 --> 00:20:14,790
problem but we still want to see to see

00:20:11,730 --> 00:20:19,560
it and we you it and be sure that this

00:20:14,790 --> 00:20:21,840
changes will be next so we see that and

00:20:19,560 --> 00:20:26,130
it says that the function that I added

00:20:21,840 --> 00:20:29,520
will see o the get M 0 did I did I add a

00:20:26,130 --> 00:20:39,900
function I don't think so I mean I don't

00:20:29,520 --> 00:20:42,780
remember so let's look at you know so

00:20:39,900 --> 00:20:47,670
this was the the first class I had so

00:20:42,780 --> 00:20:51,870
you see get M 0 was already there in the

00:20:47,670 --> 00:20:54,690
first version and in the second one what

00:20:51,870 --> 00:20:58,410
did I do in the second one I still have

00:20:54,690 --> 00:21:03,500
get M 0 but you see I had a little

00:20:58,410 --> 00:21:04,920
change here in f1 in f1 here I called

00:21:03,500 --> 00:21:07,440
you know I

00:21:04,920 --> 00:21:11,940
invoked the get em zero you see here and

00:21:07,440 --> 00:21:17,700
blue whereas in the first case there was

00:21:11,940 --> 00:21:20,490
no code okay so in this is C++ get em

00:21:17,700 --> 00:21:24,360
zero here is in line you know what in

00:21:20,490 --> 00:21:25,230
line means so it's not generated per se

00:21:24,360 --> 00:21:28,380
oh sorry

00:21:25,230 --> 00:21:32,880
yeah get em zero is in line so it's not

00:21:28,380 --> 00:21:42,990
generated right by default but in the

00:21:32,880 --> 00:21:45,240
second case it is generated GCC

00:21:42,990 --> 00:21:48,030
generates it because it is called

00:21:45,240 --> 00:21:50,970
because someone uses it then it is

00:21:48,030 --> 00:21:55,170
generated you know this is also because

00:21:50,970 --> 00:21:56,790
I compiled without optimization if I

00:21:55,170 --> 00:21:59,370
compile with optimization we can try

00:21:56,790 --> 00:22:03,420
that later because we time is flowing

00:21:59,370 --> 00:22:06,060
you'll see that this added function will

00:22:03,420 --> 00:22:09,570
disappear because because of

00:22:06,060 --> 00:22:12,690
optimization the thing the function is

00:22:09,570 --> 00:22:14,550
just in line and not generated as a

00:22:12,690 --> 00:22:16,530
symbol right so these are the

00:22:14,550 --> 00:22:18,420
interesting things that you see when you

00:22:16,530 --> 00:22:19,800
just look at the banner is rather than

00:22:18,420 --> 00:22:21,120
looking at the source code the same

00:22:19,800 --> 00:22:24,240
source code can produce different

00:22:21,120 --> 00:22:27,600
binaries depending on how you compile it

00:22:24,240 --> 00:22:30,180
how you change the code etc etc this is

00:22:27,600 --> 00:22:33,600
what I meant by when I was saying we

00:22:30,180 --> 00:22:35,850
want to look at the binaries only you

00:22:33,600 --> 00:22:39,390
know well being able to look at those so

00:22:35,850 --> 00:22:41,070
added function you see or any in here

00:22:39,390 --> 00:22:44,190
you see the symbol of the function right

00:22:41,070 --> 00:22:47,250
and here you see its signature right and

00:22:44,190 --> 00:23:02,580
so let's look at the changes what it

00:22:47,250 --> 00:23:04,980
says so first

00:23:02,580 --> 00:23:07,320
return tap type of f1 changed of course

00:23:04,980 --> 00:23:12,179
it's that's it's true I change it from

00:23:07,320 --> 00:23:13,860
from voided to int so we catch that so

00:23:12,179 --> 00:23:16,140
you see that just by looking

00:23:13,860 --> 00:23:18,480
okay there are some tools around that

00:23:16,140 --> 00:23:20,789
would say that we'll just look at the

00:23:18,480 --> 00:23:23,640
symbols and because in C++ the symbols

00:23:20,789 --> 00:23:29,220
are mangled you know you could derive

00:23:23,640 --> 00:23:31,649
the type the types you know used by the

00:23:29,220 --> 00:23:34,080
function from the mangling do you follow

00:23:31,649 --> 00:23:38,039
me yeah people say that people think

00:23:34,080 --> 00:23:41,309
that well they're wrong because for

00:23:38,039 --> 00:23:45,029
instance the return types of functions

00:23:41,309 --> 00:23:46,529
are not part of the mangling only the

00:23:45,029 --> 00:23:48,960
parameters are part of the mingling and

00:23:46,529 --> 00:23:50,100
here I made that change on purpose you

00:23:48,960 --> 00:23:52,080
see that the return type of the function

00:23:50,100 --> 00:23:54,929
changed and we want to we want to catch

00:23:52,080 --> 00:23:57,210
that too so we really need to go look at

00:23:54,929 --> 00:24:08,669
the debug info in and analyze all that

00:23:57,210 --> 00:24:11,309
you know so you see here that the next

00:24:08,669 --> 00:24:15,149
change it shows us is that the first

00:24:11,309 --> 00:24:18,929
parameter which is a pointer to see 2002

00:24:15,149 --> 00:24:20,580
the class see changed well and how did

00:24:18,929 --> 00:24:22,710
it change it change because the thing

00:24:20,580 --> 00:24:27,269
that is pointed to by that pointer which

00:24:22,710 --> 00:24:30,360
is C changed how did see changed it had

00:24:27,269 --> 00:24:33,210
one base class insertion you remember I

00:24:30,360 --> 00:24:36,240
said that I added a new base class

00:24:33,210 --> 00:24:38,549
I made C inherit a new class so we catch

00:24:36,240 --> 00:24:40,169
we can catch that too by looking at the

00:24:38,549 --> 00:24:44,070
binary and this is what we do and other

00:24:40,169 --> 00:24:47,399
results well as a result of all those

00:24:44,070 --> 00:24:49,320
changes the size of C changes to this is

00:24:47,399 --> 00:24:54,360
something you cannot see by just looking

00:24:49,320 --> 00:24:55,980
at the source code right ah well you can

00:24:54,360 --> 00:24:58,500
see that it might change but you're not

00:24:55,980 --> 00:25:00,389
sure actually the reason why the size

00:24:58,500 --> 00:25:03,389
change here is because of the virtual

00:25:00,389 --> 00:25:06,200
you remember I added a virtual keyword

00:25:03,389 --> 00:25:09,899
to the destructor so because of that

00:25:06,200 --> 00:25:12,000
virtual that I added a V table got added

00:25:09,899 --> 00:25:14,520
to the class and the V table is added at

00:25:12,000 --> 00:25:16,360
the beginning and it's the V table the

00:25:14,520 --> 00:25:19,420
reachable is a reason why the size

00:25:16,360 --> 00:25:27,580
changed here actually so we see here

00:25:19,420 --> 00:25:30,309
that there is a V table insertion and we

00:25:27,580 --> 00:25:35,020
can say at which line it was inserted

00:25:30,309 --> 00:25:37,510
and the vegetable offset etc etc and as

00:25:35,020 --> 00:25:40,480
a result because something got inserted

00:25:37,510 --> 00:25:42,250
at the beginning of the class the offset

00:25:40,480 --> 00:25:50,820
of all the data members of the class

00:25:42,250 --> 00:25:53,740
changed too so we have these changes too

00:25:50,820 --> 00:25:57,820
just by changing but just by adding a

00:25:53,740 --> 00:26:04,360
virtual right so yeah we can learn a lot

00:25:57,820 --> 00:26:10,090
by just looking at the binaries so now I

00:26:04,360 --> 00:26:17,040
guess I'm done with ah well showing of

00:26:10,090 --> 00:26:17,040
what we can do with this kind of tooling

00:26:58,330 --> 00:27:03,040
so what do we do but behind the scenes

00:27:04,990 --> 00:27:10,760
basically Abigail and well what a I call

00:27:09,410 --> 00:27:13,250
it the baby girl because it's it's the

00:27:10,760 --> 00:27:16,610
name of the project the baby girl being

00:27:13,250 --> 00:27:19,220
the library that implements all the the

00:27:16,610 --> 00:27:22,660
stuff and also library of tools that

00:27:19,220 --> 00:27:25,850
come with on top of that library so

00:27:22,660 --> 00:27:30,050
basically we represent a bi artifact

00:27:25,850 --> 00:27:34,610
what does that mean we have an in-memory

00:27:30,050 --> 00:27:37,910
models for types and declarations just

00:27:34,610 --> 00:27:42,800
like a compiler does just like LLVM you

00:27:37,910 --> 00:27:45,679
know does so we Abigail represents us

00:27:42,800 --> 00:27:47,870
color types you know integers characters

00:27:45,679 --> 00:27:51,020
and so on and so forth aggregate types

00:27:47,870 --> 00:27:54,679
that's our arrays structures classes

00:27:51,020 --> 00:27:57,080
unions blah blah blah and declarations

00:27:54,679 --> 00:27:59,480
declaration being something that has a

00:27:57,080 --> 00:28:02,270
name and a type so all those things are

00:27:59,480 --> 00:28:06,950
you know represented you can write code

00:28:02,270 --> 00:28:08,630
saying you know read good saying okay

00:28:06,950 --> 00:28:10,490
this is a function the function has

00:28:08,630 --> 00:28:13,820
parameters and I'm adding a new

00:28:10,490 --> 00:28:18,070
parameter you know you can manipulate

00:28:13,820 --> 00:28:21,830
those those things on top of the ads

00:28:18,070 --> 00:28:25,100
Abigail has a model of what I call

00:28:21,830 --> 00:28:27,500
bundles of API artifacts the first

00:28:25,100 --> 00:28:30,290
bundle is obviously a translation unit

00:28:27,500 --> 00:28:33,670
so whenever you look at a binary the

00:28:30,290 --> 00:28:36,460
binary has debug information when it has

00:28:33,670 --> 00:28:41,660
and that debug those debug information

00:28:36,460 --> 00:28:45,260
describe things translation you need per

00:28:41,660 --> 00:28:47,380
translation unit right and it is inside

00:28:45,260 --> 00:28:48,890
the translation units that you have

00:28:47,380 --> 00:28:51,950
declarations and there

00:28:48,890 --> 00:28:55,880
types so we represent those translation

00:28:51,950 --> 00:28:58,310
unit in the Abigail model and we

00:28:55,880 --> 00:29:02,390
represent what we call a bi corpus on a

00:28:58,310 --> 00:29:04,640
bi corpus is the representation of a set

00:29:02,390 --> 00:29:08,630
of translation units so basically a

00:29:04,640 --> 00:29:11,810
shared library the ABI things artifact

00:29:08,630 --> 00:29:15,110
of a shared library is represented in

00:29:11,810 --> 00:29:19,250
Abigail speak as an ABI corpus that's

00:29:15,110 --> 00:29:23,090
what we how we call it and once we have

00:29:19,250 --> 00:29:26,060
ABI corpora yeah because the plural of

00:29:23,090 --> 00:29:28,310
corpus the latin word is corpora I was

00:29:26,060 --> 00:29:31,130
told anyway so when you have those

00:29:28,310 --> 00:29:36,410
corpora you can well compare compare

00:29:31,130 --> 00:29:39,050
them you know and so as usual we build a

00:29:36,410 --> 00:29:41,990
model of the DIF if you make it parallel

00:29:39,050 --> 00:29:44,630
with the new dev tool when the new dev

00:29:41,990 --> 00:29:47,030
tool I come you know compute the

00:29:44,630 --> 00:29:49,490
difference of two files what does it do

00:29:47,030 --> 00:29:51,200
with the difference it just emitted if

00:29:49,490 --> 00:29:52,730
you look at the source code it's what it

00:29:51,200 --> 00:29:55,160
does this is the different boom it

00:29:52,730 --> 00:29:58,310
emitted as a text doesn't do anything

00:29:55,160 --> 00:30:01,270
with that difference in our case we

00:29:58,310 --> 00:30:04,970
build a model of the difference ah

00:30:01,270 --> 00:30:08,390
and we actually build a tree you know a

00:30:04,970 --> 00:30:10,700
graph of those differences so if there

00:30:08,390 --> 00:30:12,860
is a difference between two structures

00:30:10,700 --> 00:30:14,810
for instance that difference might come

00:30:12,860 --> 00:30:17,330
from the fact that one of the data

00:30:14,810 --> 00:30:19,550
members of those two structures changed

00:30:17,330 --> 00:30:22,150
right so you will have one tree

00:30:19,550 --> 00:30:24,290
representing the you know the two

00:30:22,150 --> 00:30:28,210
structures difference between the two

00:30:24,290 --> 00:30:31,130
structures and a child tree note

00:30:28,210 --> 00:30:32,900
representing you know the detail of that

00:30:31,130 --> 00:30:34,790
change the detail being the change of

00:30:32,900 --> 00:30:36,920
the data members do you understand what

00:30:34,790 --> 00:30:41,270
I mean and like that you have a full

00:30:36,920 --> 00:30:44,480
graph of the changes in memory once we

00:30:41,270 --> 00:30:46,970
have that we can categorize the changes

00:30:44,480 --> 00:30:50,510
I mean we can walk the changes and mark

00:30:46,970 --> 00:30:52,790
them saying okay this change is that

00:30:50,510 --> 00:30:55,310
kind of change because I don't know for

00:30:52,790 --> 00:30:59,180
instance in C++ you can have a change

00:30:55,310 --> 00:31:00,080
about I don't know private the you know

00:30:59,180 --> 00:31:02,900
the

00:31:00,080 --> 00:31:06,170
the private data member becoming public

00:31:02,900 --> 00:31:08,380
you know this is a change but it might

00:31:06,170 --> 00:31:11,300
not be the same kind of change as

00:31:08,380 --> 00:31:13,880
removing you know it data member so we

00:31:11,300 --> 00:31:16,970
will put the first change in a category

00:31:13,880 --> 00:31:18,980
named private change category and the

00:31:16,970 --> 00:31:25,430
second change will be put in another

00:31:18,980 --> 00:31:27,380
category so categorizing changes one of

00:31:25,430 --> 00:31:29,420
the good things about categorizing

00:31:27,380 --> 00:31:32,900
changes if there is that we can see

00:31:29,420 --> 00:31:35,870
changes that come over and over in the

00:31:32,900 --> 00:31:38,750
previous example I show you use you've

00:31:35,870 --> 00:31:42,440
seen that there were two functions using

00:31:38,750 --> 00:31:44,900
the Class C write function f 1 and F 2

00:31:42,440 --> 00:31:48,020
if you don't remember I'm telling you

00:31:44,900 --> 00:31:50,990
again ah but then the report in the

00:31:48,020 --> 00:31:53,120
reports you saw the change about F 1

00:31:50,990 --> 00:31:55,730
only saying F 1 change blah blah blah

00:31:53,120 --> 00:31:58,370
and then you know because of C and you

00:31:55,730 --> 00:32:01,370
didn't see the change about F 2 well F

00:31:58,370 --> 00:32:04,850
to change to because of C you didn't see

00:32:01,370 --> 00:32:07,450
it because the tool categorized the

00:32:04,850 --> 00:32:10,520
changes on F 2 as being redundant

00:32:07,450 --> 00:32:12,410
redundant why because it's the same see

00:32:10,520 --> 00:32:15,260
that changed that we we've seen before

00:32:12,410 --> 00:32:18,020
if you have time we can go back and I'll

00:32:15,260 --> 00:32:20,420
show you how to you know API dev has an

00:32:18,020 --> 00:32:21,920
option to show you the redundant changes

00:32:20,420 --> 00:32:24,670
to if you want to see everything you

00:32:21,920 --> 00:32:27,500
know and we can do this kind of analysis

00:32:24,670 --> 00:32:29,660
because we keep the model of the changes

00:32:27,500 --> 00:32:33,590
in memory regions we don't just omit

00:32:29,660 --> 00:32:36,360
those changes as as soon as we see them

00:32:33,590 --> 00:32:38,760
one thing that is interesting too that I

00:32:36,360 --> 00:32:40,410
wanted to show but time is moving but

00:32:38,760 --> 00:32:44,070
and then and then well we can come back

00:32:40,410 --> 00:32:47,070
to that later if we're earlier is what

00:32:44,070 --> 00:32:49,080
we call suppression specifications you

00:32:47,070 --> 00:32:51,240
guys are you know about valgrind

00:32:49,080 --> 00:32:53,370
right yeah in vulgar and you have

00:32:51,240 --> 00:32:56,700
suppressions you know that it's the

00:32:53,370 --> 00:32:59,100
central it's to meet the most it's the

00:32:56,700 --> 00:33:02,010
best thing ever involve wine right

00:32:59,100 --> 00:33:03,900
you can you have a an error that keeps

00:33:02,010 --> 00:33:05,640
popping you know about it but you don't

00:33:03,900 --> 00:33:08,850
want to see that error again because for

00:33:05,640 --> 00:33:10,860
you it's noise right suppression

00:33:08,850 --> 00:33:14,520
specifications we have the same thing in

00:33:10,860 --> 00:33:16,890
your baby girl actually so and it's a

00:33:14,520 --> 00:33:19,290
bit more complicated well let's say you

00:33:16,890 --> 00:33:23,400
know evolve land in Val Grande because

00:33:19,290 --> 00:33:26,520
you can say things that like you can say

00:33:23,400 --> 00:33:30,180
things like don't show me changes about

00:33:26,520 --> 00:33:32,520
the type which name is foo you can also

00:33:30,180 --> 00:33:35,190
say okay don't show me changes about

00:33:32,520 --> 00:33:40,320
that type if the change is an addition a

00:33:35,190 --> 00:33:41,940
new member added at the end of C or you

00:33:40,320 --> 00:33:46,820
can say things like don't show me

00:33:41,940 --> 00:33:50,250
changes about function f if f is part of

00:33:46,820 --> 00:33:52,440
if F is part of a file named blah blah

00:33:50,250 --> 00:33:54,990
blah you know there are many many

00:33:52,440 --> 00:33:56,670
different things you can express and of

00:33:54,990 --> 00:33:59,190
course those things come from users

00:33:56,670 --> 00:34:00,990
we're saying I have this case where you

00:33:59,190 --> 00:34:02,670
know I would like to you know and okay

00:34:00,990 --> 00:34:04,590
can you do something you know and also

00:34:02,670 --> 00:34:06,660
we discussed the price and yeah you know

00:34:04,590 --> 00:34:10,920
we end up with something and you

00:34:06,660 --> 00:34:16,560
category so we can do we do these kind

00:34:10,920 --> 00:34:18,870
of things so afterwards we report about

00:34:16,560 --> 00:34:22,590
the changes and reporting means again

00:34:18,870 --> 00:34:25,080
walking the graph of diffs and depending

00:34:22,590 --> 00:34:28,460
on the category of a div node report

00:34:25,080 --> 00:34:31,470
about it or not if the category says oh

00:34:28,460 --> 00:34:34,470
this node has been suppressed by the

00:34:31,470 --> 00:34:38,730
user then you won't report it right if

00:34:34,470 --> 00:34:40,740
the category says oh this is a type def

00:34:38,730 --> 00:34:43,050
name change sometimes you have changes

00:34:40,740 --> 00:34:44,250
like that you have an inch I don't know

00:34:43,050 --> 00:34:47,520
you have

00:34:44,250 --> 00:34:49,800
added your some somewhere you have a

00:34:47,520 --> 00:34:50,760
type that is an integer and someone

00:34:49,800 --> 00:34:53,760
renamed that

00:34:50,760 --> 00:34:56,550
well someone defines a type def saying

00:34:53,760 --> 00:34:58,970
you know that integers name is now fancy

00:34:56,550 --> 00:35:01,260
type for instance so this is not a real

00:34:58,970 --> 00:35:03,090
you know it's a change but it's not

00:35:01,260 --> 00:35:06,540
necessarily harmful right

00:35:03,090 --> 00:35:10,140
some folks won't want to be able to you

00:35:06,540 --> 00:35:11,790
know dismiss well surprise this thing so

00:35:10,140 --> 00:35:15,119
we have a category for those kind of

00:35:11,790 --> 00:35:17,910
changes too so the reporting engine

00:35:15,119 --> 00:35:19,920
knows about categorization and and

00:35:17,910 --> 00:35:23,880
decide to show things depending on that

00:35:19,920 --> 00:35:25,710
and of course for now we only have one

00:35:23,880 --> 00:35:30,210
kind of text report

00:35:25,710 --> 00:35:36,630
ah but we could have more but well

00:35:30,210 --> 00:35:40,020
that's that that's what we have so we've

00:35:36,630 --> 00:35:44,880
just seen where we can when we can build

00:35:40,020 --> 00:35:47,910
as an in-memory model right so where do

00:35:44,880 --> 00:35:52,140
we build that model from we build it

00:35:47,910 --> 00:35:55,220
from reading elf and a dwarf dwarf is

00:35:52,140 --> 00:35:58,320
the format for debug info in elf

00:35:55,220 --> 00:36:02,400
basically those guys like Tolkien's

00:35:58,320 --> 00:36:05,369
books and well I guess anyway so in the

00:36:02,400 --> 00:36:08,400
baby girl there is a reader component

00:36:05,369 --> 00:36:11,670
that knows how to read our elf so it's

00:36:08,400 --> 00:36:15,000
written in C++ and from that it builds

00:36:11,670 --> 00:36:20,609
the Abigail model I was talking to you

00:36:15,000 --> 00:36:23,070
about earlier in memory so it does that

00:36:20,609 --> 00:36:26,609
for shared libraries object files and

00:36:23,070 --> 00:36:28,980
also actually actually also executable

00:36:26,609 --> 00:36:33,270
if only if even if I don't mention that

00:36:28,980 --> 00:36:38,820
here once we have that once we can read

00:36:33,270 --> 00:36:42,710
from from elf build a model well we we

00:36:38,820 --> 00:36:47,820
we can also write it down in in files

00:36:42,710 --> 00:36:51,230
obviously so that people can you know

00:36:47,820 --> 00:36:51,230
define snapshots of

00:36:51,420 --> 00:36:56,760
the ABI of a binary or a package you

00:36:54,779 --> 00:37:00,329
have a binary you don't want to put that

00:36:56,760 --> 00:37:04,380
in to get well you can extract its ABI

00:37:00,329 --> 00:37:07,920
and you know stash that ABI into gate

00:37:04,380 --> 00:37:09,960
the format is an XML ad hoc format we

00:37:07,920 --> 00:37:16,019
came up with and we call that ABI XML

00:37:09,960 --> 00:37:20,250
you know and of course we can read it

00:37:16,019 --> 00:37:22,650
back so this is interesting because once

00:37:20,250 --> 00:37:28,589
you read it back well you build a on

00:37:22,650 --> 00:37:31,650
Abigail model and so it lets you be able

00:37:28,589 --> 00:37:35,130
to you know to compare well I'll talk

00:37:31,650 --> 00:37:37,099
about that later you can you can you can

00:37:35,130 --> 00:37:41,549
have you can you can compare a binary

00:37:37,099 --> 00:37:43,890
against an ABI XML file you know because

00:37:41,549 --> 00:37:46,289
you read you can read both we come up

00:37:43,890 --> 00:37:49,799
with the in-memory model and then we can

00:37:46,289 --> 00:37:53,279
work on the in-memory model so which

00:37:49,799 --> 00:37:55,950
brings me to the tooling well around lib

00:37:53,279 --> 00:37:57,599
Abigail so I'll just skim quickly

00:37:55,950 --> 00:38:03,240
through some of the tools we have today

00:37:57,599 --> 00:38:06,289
so first we have ABI TW which emits you

00:38:03,240 --> 00:38:10,380
know it serializes the ABI

00:38:06,289 --> 00:38:14,190
representation of a binary to to a text

00:38:10,380 --> 00:38:16,019
file that's a tool we have a B idea that

00:38:14,190 --> 00:38:19,529
you've seen so ABI div can compare to

00:38:16,019 --> 00:38:21,210
binaries to ABI XML file or one ABI XML

00:38:19,529 --> 00:38:24,240
file and one binary you know things like

00:38:21,210 --> 00:38:28,349
that so you can compare an AI bi on a

00:38:24,240 --> 00:38:31,980
binary against a baseline there is ABI

00:38:28,349 --> 00:38:34,380
packaged if that compares the ABI of

00:38:31,980 --> 00:38:40,289
batteries that are inside rpms or DEP

00:38:34,380 --> 00:38:44,569
files so that was a yeah written for

00:38:40,289 --> 00:38:48,359
someone else and now I maintain it and

00:38:44,569 --> 00:38:51,059
the last one that came to the family is

00:38:48,359 --> 00:38:54,000
fed ABI packaged if these guys keep

00:38:51,059 --> 00:38:55,650
coming with the longer names we need to

00:38:54,000 --> 00:39:00,119
do something about this hey I didn't

00:38:55,650 --> 00:39:04,340
write this one it's someone else the

00:39:00,119 --> 00:39:08,600
colleague who wrote it on his own time

00:39:04,340 --> 00:39:13,100
by the way so this one is interesting it

00:39:08,600 --> 00:39:15,620
talks okay ABI packaged if just to so

00:39:13,100 --> 00:39:18,830
that you have things in mind

00:39:15,620 --> 00:39:22,820
it works on rpms but when when you work

00:39:18,830 --> 00:39:26,030
on rpms the debug info is split is in

00:39:22,820 --> 00:39:29,450
another it's in a separate package right

00:39:26,030 --> 00:39:32,240
so you've seen with ABI div when we want

00:39:29,450 --> 00:39:34,190
to compare two binary to binaries you

00:39:32,240 --> 00:39:35,480
just need the two binaries if you want

00:39:34,190 --> 00:39:38,750
to compare two packages you need

00:39:35,480 --> 00:39:43,040
actually four yeah because you need the

00:39:38,750 --> 00:39:45,440
to debug info right packages so the

00:39:43,040 --> 00:39:50,390
command line starts being a bit longer

00:39:45,440 --> 00:39:54,580
right you can actually need even more in

00:39:50,390 --> 00:39:54,580
certain cases because you know ABI

00:39:54,590 --> 00:40:01,460
Abigail sees everything basically I mean

00:39:59,960 --> 00:40:03,230
there are some changes should I should

00:40:01,460 --> 00:40:06,260
show you some examples but there are

00:40:03,230 --> 00:40:08,300
some changes that to some types that

00:40:06,260 --> 00:40:09,860
some developers don't want to see

00:40:08,300 --> 00:40:12,620
because they say that oh this type is

00:40:09,860 --> 00:40:15,380
private whatever that means in elf there

00:40:12,620 --> 00:40:17,240
is no such concept as a private type but

00:40:15,380 --> 00:40:20,510
what the developer means by that it

00:40:17,240 --> 00:40:24,440
means that type was not defined in the

00:40:20,510 --> 00:40:27,140
public header shipped by the you know

00:40:24,440 --> 00:40:30,260
the package or whatever that's what it

00:40:27,140 --> 00:40:31,760
means by private but in the binary we

00:40:30,260 --> 00:40:33,740
see all the types we don't care about

00:40:31,760 --> 00:40:35,840
you know so we tell you about all the

00:40:33,740 --> 00:40:37,400
changes so people came to me saying oh I

00:40:35,840 --> 00:40:40,820
don't want to see the changes about

00:40:37,400 --> 00:40:43,400
those types so there is an option to API

00:40:40,820 --> 00:40:45,800
package ative in which you give it the

00:40:43,400 --> 00:40:49,130
devel packages in which there are the

00:40:45,800 --> 00:40:54,970
header files right and so it won't show

00:40:49,130 --> 00:40:59,270
you changes about types that are not

00:40:54,970 --> 00:41:02,630
defined in the header files so six

00:40:59,270 --> 00:41:04,580
packages you need six packages just to

00:41:02,630 --> 00:41:07,730
run you know API packaged if that's a

00:41:04,580 --> 00:41:10,490
bit too much when you type comment lines

00:41:07,730 --> 00:41:12,050
so fed API package div is quite handy

00:41:10,490 --> 00:41:13,970
because you can't at you type it the

00:41:12,050 --> 00:41:16,970
name is long but then afterwards it

00:41:13,970 --> 00:41:17,810
becomes shorter you say fed API package

00:41:16,970 --> 00:41:21,260
div

00:41:17,810 --> 00:41:26,450
- - from you say Fedora ten or I don't

00:41:21,260 --> 00:41:28,820
know - - to our Fedora 2080 TBD the

00:41:26,450 --> 00:41:32,060
httpd package so it will go fetch all

00:41:28,820 --> 00:41:34,270
the packages the httpd packages from

00:41:32,060 --> 00:41:36,890
fedora 10 and 20

00:41:34,270 --> 00:41:39,650
you know the toboggan 4 packages develop

00:41:36,890 --> 00:41:41,990
packages whatever compare them and show

00:41:39,650 --> 00:41:43,910
you the difference so that's what it

00:41:41,990 --> 00:41:47,690
does so maybe we would need something

00:41:43,910 --> 00:41:50,840
like this for OBS or well just saying

00:41:47,690 --> 00:41:52,130
anyways so this is the part this is the

00:41:50,840 --> 00:41:54,050
part of the talk I'm going to change

00:41:52,130 --> 00:42:00,050
when I if I go talk to the Debian guys

00:41:54,050 --> 00:42:02,300
but anyway so I'm talking out loud here

00:42:00,050 --> 00:42:08,120
it's a chance that it's not recorded

00:42:02,300 --> 00:42:11,890
right so doing this we faced and we're

00:42:08,120 --> 00:42:18,020
still facing some interesting challenges

00:42:11,890 --> 00:42:23,810
we well speed and space matters a lot a

00:42:18,020 --> 00:42:25,400
lot more than what people think when

00:42:23,810 --> 00:42:28,040
you're dealing with something like curly

00:42:25,400 --> 00:42:31,910
baby girl you are looking at the entire

00:42:28,040 --> 00:42:34,010
binary and usually your compliation tool

00:42:31,910 --> 00:42:37,190
chain even your compilation tool chain

00:42:34,010 --> 00:42:40,010
usually doesn't do that unless you do

00:42:37,190 --> 00:42:42,320
something called LTO but we're not we'll

00:42:40,010 --> 00:42:45,800
put that aside usually your compel or

00:42:42,320 --> 00:42:47,930
just compels things file by file

00:42:45,800 --> 00:42:50,540
translation unit by translation unit

00:42:47,930 --> 00:42:53,810
right and the linker that sees

00:42:50,540 --> 00:42:56,750
everything doesn't analyze types right

00:42:53,810 --> 00:42:59,180
so it doesn't see types either we see

00:42:56,750 --> 00:43:03,260
all the types of all the translation

00:42:59,180 --> 00:43:07,190
units of the shell library so that it

00:43:03,260 --> 00:43:11,380
can be a lot a lot especially when you

00:43:07,190 --> 00:43:13,940
have like big C++ you know binaries and

00:43:11,380 --> 00:43:17,600
this is also due to the fact that the

00:43:13,940 --> 00:43:18,710
same types get included over and over

00:43:17,600 --> 00:43:22,610
and over again

00:43:18,710 --> 00:43:26,240
did I forget an over ok over again this

00:43:22,610 --> 00:43:28,160
is thanks to the famous - include you

00:43:26,240 --> 00:43:31,570
know hash include' thing that I love

00:43:28,160 --> 00:43:34,750
right so

00:43:31,570 --> 00:43:36,970
think about it we build representation

00:43:34,750 --> 00:43:40,560
in memory representation for those types

00:43:36,970 --> 00:43:43,930
for all of them if we have hundreds of

00:43:40,560 --> 00:43:46,840
thousands of types in memory that can do

00:43:43,930 --> 00:43:49,300
a lot you can end up with gigabytes and

00:43:46,840 --> 00:43:50,800
gigabytes of memory use just to

00:43:49,300 --> 00:43:52,060
represent those types and you need two

00:43:50,800 --> 00:43:56,320
copies because of course you're

00:43:52,060 --> 00:43:57,910
comparing two libraries right so we need

00:43:56,320 --> 00:44:01,390
to do something about that we need to

00:43:57,910 --> 00:44:03,730
deduct locate those types so basically

00:44:01,390 --> 00:44:08,740
what it means compiler people have fancy

00:44:03,730 --> 00:44:10,510
names for easy concept um when you see a

00:44:08,740 --> 00:44:13,630
type foo first time okay

00:44:10,510 --> 00:44:14,950
type foo and then you go to the next

00:44:13,630 --> 00:44:18,690
translation you need and you see type

00:44:14,950 --> 00:44:21,760
foo again well you shouldn't rebuild a

00:44:18,690 --> 00:44:23,650
translate and in-memory representation

00:44:21,760 --> 00:44:27,970
for these food you should we use the

00:44:23,650 --> 00:44:30,790
first one you saw deduplication but to

00:44:27,970 --> 00:44:33,130
do that so it's an easy concept but then

00:44:30,790 --> 00:44:35,260
to do that you need to be fast because

00:44:33,130 --> 00:44:38,470
how do you know that the second foo is

00:44:35,260 --> 00:44:41,320
the same one as the first one it is not

00:44:38,470 --> 00:44:43,870
because it is named foo that it is

00:44:41,320 --> 00:44:46,180
necessarily the same as the first one in

00:44:43,870 --> 00:44:48,310
C++ normally it should be the same

00:44:46,180 --> 00:44:50,860
because there is something named the one

00:44:48,310 --> 00:44:53,920
definition rule which is a suppose rule

00:44:50,860 --> 00:44:56,500
saying that if two entities have the

00:44:53,920 --> 00:44:59,350
same name then they ought to be the same

00:44:56,500 --> 00:45:02,290
entity but then in C you don't have such

00:44:59,350 --> 00:45:06,250
thing Yesi anyway so in C you can have

00:45:02,290 --> 00:45:09,580
foo in a file the same okay a different

00:45:06,250 --> 00:45:12,430
rule in a other file the two foods are

00:45:09,580 --> 00:45:16,090
export well uses used by external

00:45:12,430 --> 00:45:18,760
functions and they're not the same so to

00:45:16,090 --> 00:45:22,060
be able to know that we want well we

00:45:18,760 --> 00:45:23,620
want to deduplicate things so we need to

00:45:22,060 --> 00:45:25,390
know if the second food is the same as

00:45:23,620 --> 00:45:31,960
the first one so we need to compare them

00:45:25,390 --> 00:45:35,170
and comparison ah by construction is it

00:45:31,960 --> 00:45:37,900
is an exponential problem you compare

00:45:35,170 --> 00:45:39,580
things member wise and those members

00:45:37,900 --> 00:45:42,250
have types themselves that are

00:45:39,580 --> 00:45:44,440
structures that have members that are

00:45:42,250 --> 00:45:45,310
types that are structures that blah blah

00:45:44,440 --> 00:45:48,960
blah and then you

00:45:45,310 --> 00:45:52,860
you know it's it's exponential and

00:45:48,960 --> 00:45:56,400
seriously I mean if you do these things

00:45:52,860 --> 00:45:59,710
naively you can take it can take hours

00:45:56,400 --> 00:46:04,480
to complete just to compare two packages

00:45:59,710 --> 00:46:06,970
so we need to use some heuristics to

00:46:04,480 --> 00:46:10,090
transform the problem into a more linear

00:46:06,970 --> 00:46:13,480
one so that things can complete quickly

00:46:10,090 --> 00:46:15,840
so it's kind of there are some

00:46:13,480 --> 00:46:20,400
interesting you know graph algorithms

00:46:15,840 --> 00:46:23,650
underneath ah we also need to control

00:46:20,400 --> 00:46:28,510
well to avoid seeing things we don't

00:46:23,650 --> 00:46:33,090
want to see and when I say this when I

00:46:28,510 --> 00:46:36,780
say we do we depends on the project a

00:46:33,090 --> 00:46:40,150
change an API change for your project

00:46:36,780 --> 00:46:42,340
might be harmless and that very same

00:46:40,150 --> 00:46:45,640
change might be harmful for his project

00:46:42,340 --> 00:46:50,560
you might want to see those so we need

00:46:45,640 --> 00:46:52,390
to give you ways to to you know yeah to

00:46:50,560 --> 00:46:55,960
do to avoid saying what you want you

00:46:52,390 --> 00:46:57,460
don't want to see so these are this is

00:46:55,960 --> 00:46:59,560
why we came up with suppression

00:46:57,460 --> 00:47:01,660
specifications but it goes further for

00:46:59,560 --> 00:47:05,470
instance if you have a file named dot

00:47:01,660 --> 00:47:10,630
well that ends up with dot a bi ignore a

00:47:05,470 --> 00:47:14,830
bi ignore in your package in your RPM

00:47:10,630 --> 00:47:16,840
file API package diff will detect that

00:47:14,830 --> 00:47:20,680
and use it for instance as a suppression

00:47:16,840 --> 00:47:22,780
specification right and think about it

00:47:20,680 --> 00:47:26,170
if you build for instance an ABI

00:47:22,780 --> 00:47:28,830
verifier at the digital level you will

00:47:26,170 --> 00:47:31,300
need to provide users with these kind of

00:47:28,830 --> 00:47:34,240
capabilities provide them with the

00:47:31,300 --> 00:47:37,210
ability to say okay this change is OK I

00:47:34,240 --> 00:47:41,230
don't want to see it again in my next

00:47:37,210 --> 00:47:43,810
runs and of course this is a library

00:47:41,230 --> 00:47:46,210
that we're talking about not only tools

00:47:43,810 --> 00:47:50,020
so we need more documentation so

00:47:46,210 --> 00:47:52,960
basically all the the entry points need

00:47:50,020 --> 00:47:56,200
to be documented and we're doing that

00:47:52,960 --> 00:47:58,730
already but we need more documentation

00:47:56,200 --> 00:48:01,430
about the inside and things like that

00:47:58,730 --> 00:48:03,050
needs and we're doing I mean the things

00:48:01,430 --> 00:48:05,390
that are in this section challenges are

00:48:03,050 --> 00:48:10,220
things we're doing already but I wanted

00:48:05,390 --> 00:48:12,530
to you know stress on them so that you

00:48:10,220 --> 00:48:16,930
guys are aware of that we need a huge

00:48:12,530 --> 00:48:24,619
set of binaries for regression testing

00:48:16,930 --> 00:48:27,980
elf and dwarf is a very loose format you

00:48:24,619 --> 00:48:31,160
can put everything anything in elf or in

00:48:27,980 --> 00:48:33,619
dwarf so unless you test stuff you don't

00:48:31,160 --> 00:48:35,600
know what you are expecting on what

00:48:33,619 --> 00:48:36,020
you're really doing so we need a lot of

00:48:35,600 --> 00:48:38,510
test

00:48:36,020 --> 00:48:42,140
so the Lib Abigail Tarble is more than

00:48:38,510 --> 00:48:44,150
100 megabyte the Sun you know of size

00:48:42,140 --> 00:48:46,190
the reason is that we have lots of

00:48:44,150 --> 00:48:50,750
binaries just for testing when you run

00:48:46,190 --> 00:48:53,000
make check so yeah and we need even more

00:48:50,750 --> 00:48:55,520
than that and that well now what we were

00:48:53,000 --> 00:48:59,420
planning to do is to actually use fed

00:48:55,520 --> 00:49:01,670
ABI package diff or something else to go

00:48:59,420 --> 00:49:05,830
actually use the packages in the distro

00:49:01,670 --> 00:49:08,060
and destroy histories to use that as

00:49:05,830 --> 00:49:10,609
regression testing you know for instance

00:49:08,060 --> 00:49:15,200
if you compare a package against itself

00:49:10,609 --> 00:49:17,270
it should yield you know the empty set

00:49:15,200 --> 00:49:19,910
right for instance just doing that on

00:49:17,270 --> 00:49:23,300
thousands of packages will will be good

00:49:19,910 --> 00:49:28,010
so this is really important just like we

00:49:23,300 --> 00:49:33,520
test compilers so in fedora we're using

00:49:28,010 --> 00:49:37,790
this thing to to compare the ABI of new

00:49:33,520 --> 00:49:39,800
you know packages that are pushed um so

00:49:37,790 --> 00:49:45,650
it's been in production since a couple

00:49:39,800 --> 00:49:49,280
of months so yeah basically we perform

00:49:45,650 --> 00:49:52,369
an a/b idea of the new package against

00:49:49,280 --> 00:49:55,010
the previous stable one and it sends a

00:49:52,369 --> 00:49:57,050
friendly message to the package

00:49:55,010 --> 00:49:59,750
maintainer so the changes are

00:49:57,050 --> 00:50:02,119
categorized now you know what category

00:49:59,750 --> 00:50:04,310
is basically but roughly in this case

00:50:02,119 --> 00:50:06,109
it's less detail that then what we can

00:50:04,310 --> 00:50:08,660
do basically but this is what they

00:50:06,109 --> 00:50:10,970
wanted if

00:50:08,660 --> 00:50:14,599
well there are certain kinds of changes

00:50:10,970 --> 00:50:17,329
for which we are sure that they're going

00:50:14,599 --> 00:50:19,849
to cause a problem incompatible ABI

00:50:17,329 --> 00:50:23,240
changed for instance removed symbols for

00:50:19,849 --> 00:50:27,339
those those are flagged as failed you

00:50:23,240 --> 00:50:29,750
know for you know the BL basically and

00:50:27,339 --> 00:50:31,190
the most interesting changes you know

00:50:29,750 --> 00:50:33,799
for instance the changes I show you

00:50:31,190 --> 00:50:36,500
about the subtypes of functions those

00:50:33,799 --> 00:50:39,950
are flagged as need inspection if your

00:50:36,500 --> 00:50:43,339
package well if we so the the package

00:50:39,950 --> 00:50:46,309
maintainer needs to inspect the the

00:50:43,339 --> 00:50:48,230
package in those case and otherwise the

00:50:46,309 --> 00:50:52,819
package is flagged as past as far as

00:50:48,230 --> 00:50:54,680
this API test is concerned so it is

00:50:52,819 --> 00:50:58,250
based on tasket Ron I think you guys

00:50:54,680 --> 00:51:00,410
know about that the task name the task

00:50:58,250 --> 00:51:03,140
that runs on each package is named API

00:51:00,410 --> 00:51:05,990
check you can google that and we and it

00:51:03,140 --> 00:51:11,000
uses API package diff to perform those

00:51:05,990 --> 00:51:13,460
things it's written in Python so that's

00:51:11,000 --> 00:51:15,710
it at the same time package maintainer

00:51:13,460 --> 00:51:17,450
can use fat API package tip so they

00:51:15,710 --> 00:51:19,700
don't have to wait until they're

00:51:17,450 --> 00:51:24,829
submitted their package you know to try

00:51:19,700 --> 00:51:27,079
to see API changes and so it is in

00:51:24,829 --> 00:51:29,539
productions the limitations you know it

00:51:27,079 --> 00:51:31,880
it only works on CNC possible shared

00:51:29,539 --> 00:51:35,720
libraries today but well tomorrow if

00:51:31,880 --> 00:51:38,809
folks doing rust want support I mean if

00:51:35,720 --> 00:51:42,170
it is elf we can support it you just

00:51:38,809 --> 00:51:45,410
need some some work and it just runs on

00:51:42,170 --> 00:51:48,349
a small set while small set more several

00:51:45,410 --> 00:51:50,059
hundreds packages of you know packages

00:51:48,349 --> 00:51:54,380
that are in the critical path they call

00:51:50,059 --> 00:51:58,270
that and improvement that we need so

00:51:54,380 --> 00:52:01,220
I've just take this here so I'm

00:51:58,270 --> 00:52:04,329
currently working on supporting you know

00:52:01,220 --> 00:52:09,170
comparison of Linux kernels

00:52:04,329 --> 00:52:12,650
this is well it's it's it's well

00:52:09,170 --> 00:52:14,960
underway the Linux kernel is huge

00:52:12,650 --> 00:52:17,480
because we're not just comparing VM

00:52:14,960 --> 00:52:19,930
Linux we're comparing the union of VM

00:52:17,480 --> 00:52:23,950
Linux and all the modules

00:52:19,930 --> 00:52:28,210
there's a couple of those and the Linux

00:52:23,950 --> 00:52:30,279
kernel has its own way of handling elf

00:52:28,210 --> 00:52:33,039
so it's quite interesting so we need

00:52:30,279 --> 00:52:36,039
more you know better support of C and

00:52:33,039 --> 00:52:37,930
C++ a language construct mostly C++ you

00:52:36,039 --> 00:52:40,299
know the new stuff lambdas blah blah

00:52:37,930 --> 00:52:43,059
blah you know the new stuff it keeps

00:52:40,299 --> 00:52:46,119
coming just need to work to keep yeah

00:52:43,059 --> 00:52:47,920
because we basically have it's like a

00:52:46,119 --> 00:52:50,680
compiler where we have you know well you

00:52:47,920 --> 00:52:52,930
know you need to to parse there is a

00:52:50,680 --> 00:52:55,720
front end which is the the dwarf thing

00:52:52,930 --> 00:52:57,970
we build the middle and representation

00:52:55,720 --> 00:53:00,009
which is you know the Abigail model and

00:52:57,970 --> 00:53:04,299
then well the back end is emitting

00:53:00,009 --> 00:53:07,019
report blah so people will come with

00:53:04,299 --> 00:53:09,490
better API change categorization

00:53:07,019 --> 00:53:11,529
requests saying this change you

00:53:09,490 --> 00:53:14,049
categorize it as harmful and harmless

00:53:11,529 --> 00:53:16,630
please can you put that in harmful place

00:53:14,049 --> 00:53:18,099
and and we'll discuss and you know we'll

00:53:16,630 --> 00:53:22,390
see well you know where we can how we

00:53:18,099 --> 00:53:24,579
can do that some people want additional

00:53:22,390 --> 00:53:29,140
API change reports you see here in the

00:53:24,579 --> 00:53:32,109
reports I show you first we show the

00:53:29,140 --> 00:53:34,480
changes but we also show the impact you

00:53:32,109 --> 00:53:36,730
know what are the functions that are

00:53:34,480 --> 00:53:39,009
impacted or global variables some people

00:53:36,730 --> 00:53:41,079
just want to see the types that changed

00:53:39,009 --> 00:53:43,569
and don't care about the functions that

00:53:41,079 --> 00:53:46,329
were impacted because there are so many

00:53:43,569 --> 00:53:48,849
types you know so it's it's a valid

00:53:46,329 --> 00:53:50,140
request so we would need well we can do

00:53:48,849 --> 00:53:51,670
that we have all the information to do

00:53:50,140 --> 00:53:54,430
that we just need to you know emits

00:53:51,670 --> 00:53:57,009
other kinds of reports for that some

00:53:54,430 --> 00:54:00,309
people want more friendly web reporting

00:53:57,009 --> 00:54:03,390
we need work from that and someone even

00:54:00,309 --> 00:54:06,400
came with a crazy idea of something web

00:54:03,390 --> 00:54:08,440
anyway you know yeah so you submit two

00:54:06,400 --> 00:54:11,849
packages and the thing does its thing

00:54:08,440 --> 00:54:15,249
and shows you web reports you know

00:54:11,849 --> 00:54:17,529
anyway so if someone wants to do that it

00:54:15,249 --> 00:54:19,119
will be great but I don't know if what

00:54:17,529 --> 00:54:23,499
maybe I can try and learn some

00:54:19,119 --> 00:54:26,920
JavaScript but anyway so yeah that's it

00:54:23,499 --> 00:54:30,029
for me I guess now is the time question

00:54:26,920 --> 00:54:30,029
I'm sorry but I

00:54:30,910 --> 00:54:41,530
finished on time now you should do the

00:54:32,710 --> 00:54:44,349
same you have two minutes what

00:54:41,530 --> 00:54:50,079
architectures to support only x86 64 or

00:54:44,349 --> 00:54:55,210
so uh well right now well it is known to

00:54:50,079 --> 00:54:59,049
work on x86 arm PowerPC you know and

00:54:55,210 --> 00:55:04,480
even stuff the right answer is if we

00:54:59,049 --> 00:55:05,859
have dwarf if we on elf H work PowerPC

00:55:04,480 --> 00:55:08,859
showed that there are some corner cases

00:55:05,859 --> 00:55:12,490
sometimes ah but in theory it should

00:55:08,859 --> 00:55:18,069
work yeah another question does it also

00:55:12,490 --> 00:55:21,869
catch calling convention changes this is

00:55:18,069 --> 00:55:25,420
an interesting question right now no

00:55:21,869 --> 00:55:28,510
short answer but there is a have a

00:55:25,420 --> 00:55:31,630
bugzilla open to support that not not

00:55:28,510 --> 00:55:34,030
not necessarily calling convention

00:55:31,630 --> 00:55:36,250
changes but not necessarily only that

00:55:34,030 --> 00:55:39,339
but things that are more subtle than

00:55:36,250 --> 00:55:42,069
that for instance a parameter for

00:55:39,339 --> 00:55:48,220
instance the second parameter of a

00:55:42,069 --> 00:55:51,039
function the way that parameter is

00:55:48,220 --> 00:55:53,529
passed can change from a compiler to

00:55:51,039 --> 00:55:55,779
another for instance you have an LLVM

00:55:53,529 --> 00:55:59,950
generated binary that passes that

00:55:55,779 --> 00:56:01,690
parameter by on the stack and GCC will

00:55:59,950 --> 00:56:05,349
pass that or the other way around

00:56:01,690 --> 00:56:07,390
in registers things like that so the

00:56:05,349 --> 00:56:10,990
idea is to have is to be sure that we

00:56:07,390 --> 00:56:14,079
have that information in dwarf and if we

00:56:10,990 --> 00:56:17,789
have that and I think we have part of it

00:56:14,079 --> 00:56:22,210
then we can implement it on our side

00:56:17,789 --> 00:56:25,299
well if the structure of NC in a way the

00:56:22,210 --> 00:56:28,809
size of the structure changes can use

00:56:25,299 --> 00:56:33,309
some somehow detect from the library

00:56:28,809 --> 00:56:37,990
code whether it is IB IB a compatible or

00:56:33,309 --> 00:56:40,630
not this is a problem when when when you

00:56:37,990 --> 00:56:43,180
whether the function fills the wall

00:56:40,630 --> 00:56:44,010
structure including the last member and

00:56:43,180 --> 00:56:46,950
the

00:56:44,010 --> 00:56:53,790
size is in the public interface then it

00:56:46,950 --> 00:56:55,020
could overwrite a data okay to me so if

00:56:53,790 --> 00:56:57,690
I understand correctly the question

00:56:55,020 --> 00:57:00,120
correctly is if the size changes can we

00:56:57,690 --> 00:57:04,980
say if that change is compatible or not

00:57:00,120 --> 00:57:09,320
right that's well to answer that

00:57:04,980 --> 00:57:15,600
question well I would say that if that

00:57:09,320 --> 00:57:19,890
size change impacts another type right

00:57:15,600 --> 00:57:23,510
that uses that that the type which says

00:57:19,890 --> 00:57:27,870
changed then it's a bi incompatible

00:57:23,510 --> 00:57:30,000
right but then there is not only an

00:57:27,870 --> 00:57:32,400
impact that the impact is not

00:57:30,000 --> 00:57:34,890
necessarily only on other types it can

00:57:32,400 --> 00:57:39,300
be on code - you can have code let's say

00:57:34,890 --> 00:57:41,280
size of of that structure right so my

00:57:39,300 --> 00:57:44,730
short answer will be if the size changes

00:57:41,280 --> 00:57:49,380
it's bad period if it's not bad then you

00:57:44,730 --> 00:57:51,150
haven't looked close enough so yeah

00:57:49,380 --> 00:57:53,070
because the question came out you know

00:57:51,150 --> 00:57:56,310
over and over and you know for instance

00:57:53,070 --> 00:57:58,830
if a code says size of that size of is

00:57:56,310 --> 00:58:01,770
lost because you know it's a constant

00:57:58,830 --> 00:58:05,280
and we don't see that in the generated

00:58:01,770 --> 00:58:08,610
code anymore so I don't think we can

00:58:05,280 --> 00:58:11,490
really be sure that we're you know built

00:58:08,610 --> 00:58:13,590
doing the complete impact analysis of

00:58:11,490 --> 00:58:16,440
this kind of things and I think we would

00:58:13,590 --> 00:58:20,430
err on the safe side by saying that this

00:58:16,440 --> 00:58:25,770
is by period if you do it you know that

00:58:20,430 --> 00:58:30,000
you know it's potentially bad yeah he's

00:58:25,770 --> 00:58:32,850
bad you mentioned that you were looking

00:58:30,000 --> 00:58:34,620
for ways to identify whether to certain

00:58:32,850 --> 00:58:37,350
structs are the same and see which

00:58:34,620 --> 00:58:40,350
doesn't have to you od are have you

00:58:37,350 --> 00:58:42,750
thought about the building like an md5

00:58:40,350 --> 00:58:47,220
sum of a struct and then comparing that

00:58:42,750 --> 00:58:51,450
oh well the to us the problem is solved

00:58:47,220 --> 00:58:57,810
I mean well he solved but the question

00:58:51,450 --> 00:59:00,200
is interesting if to build an md5 sum or

00:58:57,810 --> 00:59:03,540
some you need to walk the structure

00:59:00,200 --> 00:59:07,950
right what I want to avoid is to walk

00:59:03,540 --> 00:59:11,280
the structure exactly and that is what

00:59:07,950 --> 00:59:13,740
we do that's what I meant by saying that

00:59:11,280 --> 00:59:17,160
trying to transform the problem from an

00:59:13,740 --> 00:59:19,170
exponential one to a linear one this is

00:59:17,160 --> 00:59:25,050
basically the kind of technique we use

00:59:19,170 --> 00:59:29,250
we we use yeah some kind of of hashing

00:59:25,050 --> 00:59:33,810
you know - yeah to avoid walking over

00:59:29,250 --> 00:59:37,710
and over we just walk once per type name

00:59:33,810 --> 00:59:41,010
and kind yes it's just that the Doha the

00:59:37,710 --> 00:59:49,650
the hush that we end up using is not we

00:59:41,010 --> 00:59:55,310
don't save it it's just in memory so I

00:59:49,650 --> 01:00:01,360
guess thank you very much

00:59:55,310 --> 01:00:01,360

YouTube URL: https://www.youtube.com/watch?v=wxVBuZK8Dl0


