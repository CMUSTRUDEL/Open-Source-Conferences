Title: openSUSE Conference 2017 A View inside of openSUSE's Awesome Haskell Support
Publication date: 2017-05-27
Playlist: openSUSE Conference 2017
Description: 
	https://media.ccc.de/v/1330-a-view-inside-of-opensuse-s-awesome-haskell-support



The functional programming language "Haskell" has been instrumental in researching the design of compilers, type systems, and advanced programming language features for more than 2 decades, but in recent years it has also become increasingly popular with red-blooded software engineers who worry about practical tasks like developing client/server systems, standalone applications, cryptography, finance solutions, or REST application back-ends. As it happens, openSUSE offers outstanding support for the Haskell language ecosystem and is therefore an ideal platform for discerning Haskell hackers who develop commercial-grade solutions. Both Tumbleweed and Leap support a whopping 2,200 Haskell packages that cover the entire LTS Haskell standard version 8.x. Furthermore, there exists a sophisticated infrastructure to easily maintain and update a package set of that size, which guarantees that important new releases make it into the distribution with a minimal delay.

In this presentation, we would like to describe the current state of Haskell packaging in openSUSE, covering the following topics in particular:

1. Introduce Haskell briefly and explain why it kicks ass.
2. How can I install and set up a Haskell development environment with openSUSE Leap or Tumbleweed?
3. How can I package and deploy my own Haskell applications on openSUSE with the Open Build Sevice?
4. How does the underlying infrastructure work ("cabal2obs") that makes all this possible?

The target audience for this presentation are Haskell programmers who would like to get started using openSUSE, openSUSE users who would like get started with Haskell, and packagers who would like to get insights into an endeavor that maintains and updates several thousand spec files without major human intervention.



Peter Simons
Captions: 
	00:00:09,260 --> 00:00:14,060
okay I saw

00:00:11,510 --> 00:00:16,960
right if some people are late when they

00:00:14,060 --> 00:00:23,779
won't miss that much in the beginning

00:00:16,960 --> 00:00:27,349
okay um is everything all right okay I'd

00:00:23,779 --> 00:00:28,820
like to talk for a bit about the state

00:00:27,349 --> 00:00:32,570
of the Haskell infrastructure in the

00:00:28,820 --> 00:00:35,510
open SUSE family of distributions I have

00:00:32,570 --> 00:00:37,160
split the talk a bit in in two parts and

00:00:35,510 --> 00:00:39,710
the first part is basically supposed to

00:00:37,160 --> 00:00:41,720
introduce people who know about open

00:00:39,710 --> 00:00:43,729
SUSE but who have no idea about Haskell

00:00:41,720 --> 00:00:45,500
I'd like to show a bit of the language

00:00:43,729 --> 00:00:47,900
Haskell and why it might be worthwhile

00:00:45,500 --> 00:00:50,510
to look into that and why open SUSE

00:00:47,900 --> 00:00:53,089
distributions are a good place to do

00:00:50,510 --> 00:00:54,769
that and the second part of the talk is

00:00:53,089 --> 00:00:56,690
then geared towards people who may be

00:00:54,769 --> 00:00:58,519
developing in Haskell but who don't know

00:00:56,690 --> 00:01:00,680
that much about open SUSE and who would

00:00:58,519 --> 00:01:02,870
like to know how do I set up my

00:01:00,680 --> 00:01:06,170
development environment how do I deploy

00:01:02,870 --> 00:01:08,570
my my programs and last but not least

00:01:06,170 --> 00:01:12,140
I'd like to share a couple of experience

00:01:08,570 --> 00:01:15,530
and insights into what it feels like to

00:01:12,140 --> 00:01:18,710
manage a package set of about 2200

00:01:15,530 --> 00:01:20,720
packages these days which we as I

00:01:18,710 --> 00:01:22,190
learned today I think accept a hundred

00:01:20,720 --> 00:01:24,200
of those which are still in the

00:01:22,190 --> 00:01:26,090
submission queue everything else is

00:01:24,200 --> 00:01:28,760
actually available in factory these days

00:01:26,090 --> 00:01:32,230
so there was a quite an interesting

00:01:28,760 --> 00:01:32,230
effort to get that done

00:01:32,980 --> 00:01:39,200
so Haskell it's a item I suppose that

00:01:36,740 --> 00:01:42,110
everybody who's here has heard the name

00:01:39,200 --> 00:01:44,810
at least um the language has a couple of

00:01:42,110 --> 00:01:47,990
very nice properties that I enjoy about

00:01:44,810 --> 00:01:49,850
it very much and since them I for the

00:01:47,990 --> 00:01:52,460
most time of my life was a C++

00:01:49,850 --> 00:01:55,430
programmer what I like about Haskell is

00:01:52,460 --> 00:01:57,710
very much is the concise syntax it's

00:01:55,430 --> 00:02:00,290
very much inspired by the notation of

00:01:57,710 --> 00:02:02,810
mathematics and mathematical notation is

00:02:00,290 --> 00:02:05,330
arguably very successful it's been

00:02:02,810 --> 00:02:07,970
developed for 2,000 years or longer and

00:02:05,330 --> 00:02:10,399
it's extremely expressive and short and

00:02:07,970 --> 00:02:12,830
it's the same in Haskell if you program

00:02:10,399 --> 00:02:15,860
in Haskell your source code is crisp and

00:02:12,830 --> 00:02:18,409
clean and you can read it easily if you

00:02:15,860 --> 00:02:20,359
write C++ a generic function then you

00:02:18,409 --> 00:02:23,389
have all kinds of boilerplates you have

00:02:20,359 --> 00:02:24,950
to inherit iterator traits you have to

00:02:23,389 --> 00:02:26,990
have all kinds of template

00:02:24,950 --> 00:02:29,270
keywords you have to have a structure

00:02:26,990 --> 00:02:31,910
around it define operators and whatnot

00:02:29,270 --> 00:02:34,849
and you have 80 lines of code for like

00:02:31,910 --> 00:02:36,860
one line of payload and in Haskell this

00:02:34,849 --> 00:02:39,080
is very much different so this is real

00:02:36,860 --> 00:02:41,390
source code all and when you define a

00:02:39,080 --> 00:02:44,209
function that's supposed to square some

00:02:41,390 --> 00:02:47,540
value then this is all you're right so

00:02:44,209 --> 00:02:51,080
there is no boilerplate at all all these

00:02:47,540 --> 00:02:53,060
you'll find that this is fairly similar

00:02:51,080 --> 00:02:55,580
to Python in Python you could write an

00:02:53,060 --> 00:02:57,980
almost identical definition of square

00:02:55,580 --> 00:02:59,810
you'd have a couple of extra brackets

00:02:57,980 --> 00:03:02,000
and you would have a def keyword at the

00:02:59,810 --> 00:03:03,760
beginning but the difference is that

00:03:02,000 --> 00:03:06,620
this is actually a statically typed

00:03:03,760 --> 00:03:08,840
language so all these functions and all

00:03:06,620 --> 00:03:11,510
these constants have a very precise very

00:03:08,840 --> 00:03:13,640
accurate type that is verified at

00:03:11,510 --> 00:03:16,280
compile time and you cannot use them in

00:03:13,640 --> 00:03:18,830
an unsafe way in the next slide we'll

00:03:16,280 --> 00:03:21,049
see what what's going on and so the

00:03:18,830 --> 00:03:24,019
square function is fairly obvious then

00:03:21,049 --> 00:03:27,440
you have a nice feature that this modulo

00:03:24,019 --> 00:03:31,040
function mo D is a normal function it

00:03:27,440 --> 00:03:33,260
takes two arguments and returns a result

00:03:31,040 --> 00:03:35,269
and what you can do in Haskell is that

00:03:33,260 --> 00:03:37,850
if you put the function name inspect

00:03:35,269 --> 00:03:41,180
--ax then you can write it between your

00:03:37,850 --> 00:03:43,549
operands so you could write mod x 2

00:03:41,180 --> 00:03:46,070
equals equals 0 or you can write it this

00:03:43,549 --> 00:03:49,700
way and use it like an operator which is

00:03:46,070 --> 00:03:51,799
sometimes more expressive you have list

00:03:49,700 --> 00:03:54,260
comprehensions so if you see the

00:03:51,799 --> 00:03:56,570
definition of this list of integer

00:03:54,260 --> 00:03:59,450
values there these all these three

00:03:56,570 --> 00:04:01,400
definitions are all equivalent and you

00:03:59,450 --> 00:04:03,500
have the list comprehension syntax which

00:04:01,400 --> 00:04:06,850
everyone was familiar with math will

00:04:03,500 --> 00:04:10,569
will recognize you have the second line

00:04:06,850 --> 00:04:13,940
uses a higher-order function so you have

00:04:10,569 --> 00:04:16,190
filter is a standard function which

00:04:13,940 --> 00:04:18,109
iterates over all elements of that list

00:04:16,190 --> 00:04:21,380
which is given as the third argument and

00:04:18,109 --> 00:04:23,660
applies this attribute to each of them

00:04:21,380 --> 00:04:25,610
and whenever is even returns true the

00:04:23,660 --> 00:04:27,740
result is kept in the list and it is

00:04:25,610 --> 00:04:31,010
even returns false the result is dropped

00:04:27,740 --> 00:04:33,380
from the list and so you can create the

00:04:31,010 --> 00:04:35,539
list of even numbers which is ultimately

00:04:33,380 --> 00:04:37,190
the same thing as that third line and

00:04:35,539 --> 00:04:38,759
you could write it just like that

00:04:37,190 --> 00:04:42,059
in a scale and would get the same

00:04:38,759 --> 00:04:44,520
and what is also kind of nice about this

00:04:42,059 --> 00:04:47,879
this is an infinite list so this list

00:04:44,520 --> 00:04:50,729
has no end and it contains all the

00:04:47,879 --> 00:04:53,279
numbers you can think of it like a

00:04:50,729 --> 00:04:56,879
generator in Python right it's not

00:04:53,279 --> 00:04:59,339
actually a list but it's know-how that

00:04:56,879 --> 00:05:03,419
tells you how to generate that list if

00:04:59,339 --> 00:05:07,139
you consume it then for the last example

00:05:03,419 --> 00:05:08,789
is the odd numbers there is also here is

00:05:07,139 --> 00:05:11,789
a feature that's particularly nice

00:05:08,789 --> 00:05:13,860
that's occurring so what this does is

00:05:11,789 --> 00:05:16,680
the plus operator is a function that

00:05:13,860 --> 00:05:19,319
takes two arguments and when I provide

00:05:16,680 --> 00:05:20,849
one argument already then this turns

00:05:19,319 --> 00:05:23,490
into a function that takes one argument

00:05:20,849 --> 00:05:26,849
and gives a result right so one argument

00:05:23,490 --> 00:05:29,069
has been bound already and you know the

00:05:26,849 --> 00:05:31,050
same thing form from C++ maybe but in

00:05:29,069 --> 00:05:33,659
C++ you have an explicit bind function

00:05:31,050 --> 00:05:35,639
to do this and in Haskell you can just

00:05:33,659 --> 00:05:37,080
write the argument there and transform

00:05:35,639 --> 00:05:39,059
the function into one that has one

00:05:37,080 --> 00:05:41,279
argument less and then you end up with

00:05:39,059 --> 00:05:43,439
something you can map over this list of

00:05:41,279 --> 00:05:46,740
even numbers to get at the result you

00:05:43,439 --> 00:05:49,110
get there so this all this code tends to

00:05:46,740 --> 00:05:51,020
be extremely short and expressive even

00:05:49,110 --> 00:05:55,499
though it encodes fairly sophisticated

00:05:51,020 --> 00:05:57,959
concepts the Haskell type system is very

00:05:55,499 --> 00:06:00,539
nice it's a static statically typed

00:05:57,959 --> 00:06:03,330
language it has very strong typing so

00:06:00,539 --> 00:06:05,459
unless unlike in C for instance if you

00:06:03,330 --> 00:06:07,229
have a function that expects and signed

00:06:05,459 --> 00:06:08,969
integer and you pass it an unsigned

00:06:07,229 --> 00:06:11,659
integer then this is a compiler error

00:06:08,969 --> 00:06:14,159
you can't do that you have to explicitly

00:06:11,659 --> 00:06:17,759
convert these different types and catch

00:06:14,159 --> 00:06:20,129
the overflows or under flows if you want

00:06:17,759 --> 00:06:23,189
to but the thing is you can't types are

00:06:20,129 --> 00:06:24,809
very strictly enforced and when we look

00:06:23,189 --> 00:06:27,029
at this the square function from the

00:06:24,809 --> 00:06:30,180
last slide it has a very accurate type

00:06:27,029 --> 00:06:32,819
right it takes some type a and returns

00:06:30,180 --> 00:06:34,740
some other type a so the information is

00:06:32,819 --> 00:06:37,439
we don't know what type it is but it

00:06:34,740 --> 00:06:40,589
takes returns the same type as it gets

00:06:37,439 --> 00:06:43,050
and there is one constraint on that type

00:06:40,589 --> 00:06:44,759
you can't just pass it anything but you

00:06:43,050 --> 00:06:47,490
can pass it only things that are

00:06:44,759 --> 00:06:50,519
instances of the class num and the class

00:06:47,490 --> 00:06:52,409
num this is the definition or short

00:06:50,519 --> 00:06:54,179
abbreviated definition

00:06:52,409 --> 00:06:56,759
has the distinguishing feature that it

00:06:54,179 --> 00:06:58,709
defines this operator so it makes

00:06:56,759 --> 00:07:00,839
perfect sense intuitively right so if

00:06:58,709 --> 00:07:02,909
you use this operator here then you can

00:07:00,839 --> 00:07:06,119
use this function only on things for

00:07:02,909 --> 00:07:08,219
which this operator is defined again

00:07:06,119 --> 00:07:10,050
this is something that you would be able

00:07:08,219 --> 00:07:11,519
to do in Python as well right if you

00:07:10,050 --> 00:07:13,050
have a Python function square like this

00:07:11,519 --> 00:07:15,330
and you pass it something that has a

00:07:13,050 --> 00:07:18,779
multiplication operator then it works

00:07:15,330 --> 00:07:21,389
right but the difference here is that if

00:07:18,779 --> 00:07:23,459
I define a new type fool for instance

00:07:21,389 --> 00:07:26,009
and then we define the multiplication

00:07:23,459 --> 00:07:28,349
operator for this then this is perfectly

00:07:26,009 --> 00:07:31,110
legitimate code right you can multiply

00:07:28,349 --> 00:07:33,689
food this way but you cannot pass food

00:07:31,110 --> 00:07:36,119
to square because this multiplication

00:07:33,689 --> 00:07:39,149
here is not the same multiplication as

00:07:36,119 --> 00:07:41,399
this one so the only way you'll be able

00:07:39,149 --> 00:07:43,979
to pass foo into the square function is

00:07:41,399 --> 00:07:47,519
if you define food to be an instance of

00:07:43,979 --> 00:07:50,219
num so you explicitly say I fulfill this

00:07:47,519 --> 00:07:52,939
interface and if this data type fulfills

00:07:50,219 --> 00:07:56,749
this interface then you can use it and

00:07:52,939 --> 00:07:59,129
so all the fundamental concepts of

00:07:56,749 --> 00:08:01,409
different kinds of numbers integrals

00:07:59,129 --> 00:08:03,629
floating-point numbers are abstracted in

00:08:01,409 --> 00:08:05,610
type classes in high school and all the

00:08:03,629 --> 00:08:08,009
code that you write always works for all

00:08:05,610 --> 00:08:09,659
instances of that class so when you

00:08:08,009 --> 00:08:12,240
write mathematical function and you can

00:08:09,659 --> 00:08:15,959
use them with a double or you can use

00:08:12,240 --> 00:08:17,909
them with a multi precision GNP whatnot

00:08:15,959 --> 00:08:20,759
object which takes lots and lots of

00:08:17,909 --> 00:08:24,149
memory this is you don't care right this

00:08:20,759 --> 00:08:26,909
is the same thing for you another very

00:08:24,149 --> 00:08:29,989
nice feature is and the ability to

00:08:26,909 --> 00:08:33,089
define polymorphic algebraic data types

00:08:29,989 --> 00:08:35,610
so for instance an optional value is

00:08:33,089 --> 00:08:37,979
typically encoded and it may be this

00:08:35,610 --> 00:08:40,889
this data type has two ways to construct

00:08:37,979 --> 00:08:43,439
it you can construct it with a just anti

00:08:40,889 --> 00:08:46,470
actual value or you can construct it

00:08:43,439 --> 00:08:48,120
saying nothing and then this is a type

00:08:46,470 --> 00:08:50,430
you can pass to a function for instance

00:08:48,120 --> 00:08:52,110
this function is going to going to greet

00:08:50,430 --> 00:08:54,569
someone and you pass the name of the

00:08:52,110 --> 00:08:57,720
person it's supposed to greet and if you

00:08:54,569 --> 00:08:59,879
pass it with just world it's going to

00:08:57,720 --> 00:09:02,279
say hello world and if you pass nothing

00:08:59,879 --> 00:09:04,780
then it's going to say hello stranger as

00:09:02,279 --> 00:09:08,230
a default right

00:09:04,780 --> 00:09:10,710
and so this is a very concise way to to

00:09:08,230 --> 00:09:13,540
express an optional value and you

00:09:10,710 --> 00:09:15,790
unresolved this ambiguity through

00:09:13,540 --> 00:09:17,740
pattern matching so you just write

00:09:15,790 --> 00:09:19,330
multiple cases of your function and the

00:09:17,740 --> 00:09:26,320
one that matches is going to be the one

00:09:19,330 --> 00:09:28,750
that's chosen and then there is another

00:09:26,320 --> 00:09:30,520
feature which is arguably the most

00:09:28,750 --> 00:09:32,920
mind-boggling one and that's a

00:09:30,520 --> 00:09:35,550
referential transparency or it's called

00:09:32,920 --> 00:09:38,950
a lazy evaluation is the common name and

00:09:35,550 --> 00:09:41,920
what that means is that no not late I'm

00:09:38,950 --> 00:09:44,620
not lazy relation excuse me um it's a

00:09:41,920 --> 00:09:46,540
pure functional purely functional what

00:09:44,620 --> 00:09:48,610
that means is that the result of a

00:09:46,540 --> 00:09:51,700
function depends only on its arguments

00:09:48,610 --> 00:09:53,830
so basically has good guarantees that if

00:09:51,700 --> 00:09:56,530
you call a function with one argument

00:09:53,830 --> 00:09:57,820
and you get some result then every time

00:09:56,530 --> 00:09:59,890
you call that function with that

00:09:57,820 --> 00:10:02,410
argument you will get the same result

00:09:59,890 --> 00:10:04,720
and this means that the compiler can

00:10:02,410 --> 00:10:06,220
optimize all common expressions anywhere

00:10:04,720 --> 00:10:08,800
in your source code that take the same

00:10:06,220 --> 00:10:10,420
arguments away and compute them once and

00:10:08,800 --> 00:10:12,310
replace the result everywhere

00:10:10,420 --> 00:10:14,740
for instance this function which

00:10:12,310 --> 00:10:16,810
computes the length of a list if you

00:10:14,740 --> 00:10:19,420
call it ten times with the same list you

00:10:16,810 --> 00:10:21,430
will get ten times the same result so

00:10:19,420 --> 00:10:23,670
now contrast that to the function string

00:10:21,430 --> 00:10:26,610
length that you know from C for instance

00:10:23,670 --> 00:10:28,930
if you pass string lengths a pointer

00:10:26,610 --> 00:10:30,730
then this is the read this is the

00:10:28,930 --> 00:10:32,290
argument to your to your function right

00:10:30,730 --> 00:10:34,270
and now string length is going to

00:10:32,290 --> 00:10:36,100
iterate over the memory until it finds

00:10:34,270 --> 00:10:37,630
it zero byte and it's going to return

00:10:36,100 --> 00:10:41,290
the number of bytes it could iterate

00:10:37,630 --> 00:10:43,270
until then so now if you change the

00:10:41,290 --> 00:10:45,339
underlying memory and call the function

00:10:43,270 --> 00:10:47,950
again with the same pointer you'll get a

00:10:45,339 --> 00:10:51,190
different result because the memory has

00:10:47,950 --> 00:10:53,650
changed right so there is a hidden state

00:10:51,190 --> 00:10:55,960
somewhere the memory in the machine

00:10:53,650 --> 00:10:58,210
which is not visible in this type

00:10:55,960 --> 00:11:00,700
because the pointer you pass is both

00:10:58,210 --> 00:11:02,380
times the same pointer and consequently

00:11:00,700 --> 00:11:04,810
this is a function you cannot bright

00:11:02,380 --> 00:11:08,770
impure Haskell so this function cannot

00:11:04,810 --> 00:11:10,360
exist right because it violates the

00:11:08,770 --> 00:11:17,110
guarantee of referential transparency

00:11:10,360 --> 00:11:18,700
and the referential transparency is nice

00:11:17,110 --> 00:11:20,590
for the compiler because

00:11:18,700 --> 00:11:23,650
allows for great opportunities for

00:11:20,590 --> 00:11:25,630
optimization but where it's really

00:11:23,650 --> 00:11:28,060
beneficial is for software engineers

00:11:25,630 --> 00:11:30,460
because what it means is that functions

00:11:28,060 --> 00:11:32,320
have no hidden state if you have a

00:11:30,460 --> 00:11:34,330
function that that is a pure

00:11:32,320 --> 00:11:36,970
mathematical function it takes five

00:11:34,330 --> 00:11:39,160
arguments and then all it does is work

00:11:36,970 --> 00:11:43,570
with those five arguments there's no

00:11:39,160 --> 00:11:45,550
other global variable there is no hidden

00:11:43,570 --> 00:11:47,680
state somewhere in a class method it

00:11:45,550 --> 00:11:49,210
doesn't exist it's just the arguments

00:11:47,680 --> 00:11:51,730
that you pass and those determine what

00:11:49,210 --> 00:11:53,830
the function does so if you read Haskell

00:11:51,730 --> 00:11:55,830
code then you can read one function at a

00:11:53,830 --> 00:11:58,390
time and you always have a complete

00:11:55,830 --> 00:12:01,420
algorithm that does something with with

00:11:58,390 --> 00:12:03,190
the arguments it takes of course you can

00:12:01,420 --> 00:12:04,930
go through all kinds of contortions to

00:12:03,190 --> 00:12:06,910
make the code unreadable anyway right

00:12:04,930 --> 00:12:12,610
but most of the time it's actually

00:12:06,910 --> 00:12:14,830
fairly difficult and then this is

00:12:12,610 --> 00:12:17,080
another crazy scheme and this is lazy

00:12:14,830 --> 00:12:20,710
evaluation which I was referring to

00:12:17,080 --> 00:12:23,290
before so in Haskell um a Haskell

00:12:20,710 --> 00:12:26,020
program is evaluated from from the end

00:12:23,290 --> 00:12:27,400
so the compiler looks at what is the

00:12:26,020 --> 00:12:29,260
program going to return when it

00:12:27,400 --> 00:12:31,540
terminates what's the end result and

00:12:29,260 --> 00:12:33,670
then it goes backwards through the

00:12:31,540 --> 00:12:35,950
source code and finds all the

00:12:33,670 --> 00:12:38,440
expressions it needs to compute that

00:12:35,950 --> 00:12:41,860
result and everything that it doesn't

00:12:38,440 --> 00:12:44,950
need it doesn't compute so for instance

00:12:41,860 --> 00:12:46,720
this is a list of integer and every

00:12:44,950 --> 00:12:49,150
single element of that list is going to

00:12:46,720 --> 00:12:50,860
throw an exception so this list this for

00:12:49,150 --> 00:12:52,960
instance is going to throw an arithmetic

00:12:50,860 --> 00:12:54,610
error this is going to throw an

00:12:52,960 --> 00:12:58,540
undefined exception this is going to

00:12:54,610 --> 00:13:02,470
throw and violate it assertion here we

00:12:58,540 --> 00:13:06,820
have a boolean which says this list has

00:13:02,470 --> 00:13:08,830
three items or we throw an exception so

00:13:06,820 --> 00:13:11,290
now the question is what happens when

00:13:08,830 --> 00:13:13,300
you evaluate that when you ask the

00:13:11,290 --> 00:13:19,240
compiler give me the value of B and the

00:13:13,300 --> 00:13:21,190
answer is you don't know and this is

00:13:19,240 --> 00:13:23,170
actually for surprising reason so the

00:13:21,190 --> 00:13:26,380
compiler is completely at liberty to

00:13:23,170 --> 00:13:29,020
evaluate this part and if it does it

00:13:26,380 --> 00:13:31,690
throws an exception or I can evaluate

00:13:29,020 --> 00:13:33,279
this part and in this case is going to

00:13:31,690 --> 00:13:35,630
return true

00:13:33,279 --> 00:13:41,449
the reason is when you look at the

00:13:35,630 --> 00:13:44,060
definition of length the function that

00:13:41,449 --> 00:13:45,560
computes the the list right it does

00:13:44,060 --> 00:13:47,180
pattern matching on the list it says

00:13:45,560 --> 00:13:48,560
give me the first element give me the

00:13:47,180 --> 00:13:51,350
rest of the list and then it does the

00:13:48,560 --> 00:13:54,260
recursion but this value is never

00:13:51,350 --> 00:13:56,300
actually required as far as the function

00:13:54,260 --> 00:13:58,190
is contained concerned this is just an

00:13:56,300 --> 00:14:00,260
entry in the list and I don't care what

00:13:58,190 --> 00:14:04,279
the entry actually is this is not

00:14:00,260 --> 00:14:07,040
evaluated so when you compute the length

00:14:04,279 --> 00:14:09,860
of that list this is going to come out

00:14:07,040 --> 00:14:11,930
as 3 there is no exception because none

00:14:09,860 --> 00:14:13,670
of those items is ever evaluated you

00:14:11,930 --> 00:14:16,250
don't need to evaluate them to compute

00:14:13,670 --> 00:14:20,089
the length of the list and so this

00:14:16,250 --> 00:14:23,180
boolean is either true or it's user

00:14:20,089 --> 00:14:28,360
error or fail and you don't know which

00:14:23,180 --> 00:14:30,589
one so lazy evaluation has some

00:14:28,360 --> 00:14:32,959
mind-boggling consequences it's

00:14:30,589 --> 00:14:34,430
sometimes very very difficult to predict

00:14:32,959 --> 00:14:36,250
what's going to happen when you have

00:14:34,430 --> 00:14:40,040
complex code that has these properties

00:14:36,250 --> 00:14:42,920
but the thing is that lazy evaluation um

00:14:40,040 --> 00:14:46,149
helps combat a very dangerous thing

00:14:42,920 --> 00:14:48,649
called premature optimization because

00:14:46,149 --> 00:14:51,139
when you know that things that I don't

00:14:48,649 --> 00:14:53,060
need are not going to be evaluated and

00:14:51,139 --> 00:14:54,829
they don't cost me anything it doesn't

00:14:53,060 --> 00:14:57,199
mean that you it means you don't have to

00:14:54,829 --> 00:14:59,660
optimize them if you think of an and

00:14:57,199 --> 00:15:02,480
posited parsing XML document for

00:14:59,660 --> 00:15:05,510
instance the XML document has like a

00:15:02,480 --> 00:15:07,550
thousand fields so now you can devise a

00:15:05,510 --> 00:15:09,139
data type that contains all those

00:15:07,550 --> 00:15:11,300
thousand fields and it very nicely

00:15:09,139 --> 00:15:12,949
passes them and it turns the strings

00:15:11,300 --> 00:15:14,690
into numbers where it's a number

00:15:12,949 --> 00:15:16,250
anywhere it's an email address it passes

00:15:14,690 --> 00:15:20,139
the email address and it gives you a

00:15:16,250 --> 00:15:22,940
very nice very structured sophisticated

00:15:20,139 --> 00:15:25,310
representation of the XML file and now

00:15:22,940 --> 00:15:27,380
somebody who is processing that XML file

00:15:25,310 --> 00:15:29,870
uses your library and says yeah I just

00:15:27,380 --> 00:15:32,839
want I don't know the first the first

00:15:29,870 --> 00:15:34,910
element I don't want the rest it means

00:15:32,839 --> 00:15:37,069
that your parser is not going to pass

00:15:34,910 --> 00:15:39,260
any of the rest it just passes the first

00:15:37,069 --> 00:15:43,370
elements as you see result and that's

00:15:39,260 --> 00:15:45,230
that so you can define you don't have to

00:15:43,370 --> 00:15:46,370
this notion that you have to abort the

00:15:45,230 --> 00:15:47,960
computation at some

00:15:46,370 --> 00:15:51,970
point you don't have to care about that

00:15:47,960 --> 00:15:51,970
the runtime system does that for you

00:15:52,900 --> 00:16:00,920
there is a lot more there is a Haskell

00:15:58,310 --> 00:16:04,400
is as far as I know the most popular

00:16:00,920 --> 00:16:06,020
language in language research in

00:16:04,400 --> 00:16:08,480
compiler research in type system

00:16:06,020 --> 00:16:11,120
research and there is a lot of work

00:16:08,480 --> 00:16:12,890
going on you have a an interactive

00:16:11,120 --> 00:16:15,080
development environment which people who

00:16:12,890 --> 00:16:16,970
program Python know that you have this

00:16:15,080 --> 00:16:18,620
this interactive shell and which you can

00:16:16,970 --> 00:16:20,390
call any function and you will get the

00:16:18,620 --> 00:16:23,390
result and this works particularly well

00:16:20,390 --> 00:16:25,040
in a purely functional language because

00:16:23,390 --> 00:16:27,110
if you have a function that depends only

00:16:25,040 --> 00:16:29,060
on its arguments that means you can call

00:16:27,110 --> 00:16:31,370
it in any context right there is no

00:16:29,060 --> 00:16:33,320
hidden state so you don't have to set up

00:16:31,370 --> 00:16:34,970
some elaborate environment to call your

00:16:33,320 --> 00:16:37,250
function you just pass it the arguments

00:16:34,970 --> 00:16:40,040
and then it works so this is actually

00:16:37,250 --> 00:16:43,820
very nice for for for development the

00:16:40,040 --> 00:16:47,300
type system in Haskell compiler is crazy

00:16:43,820 --> 00:16:48,620
there is a there working the the thing

00:16:47,300 --> 00:16:50,810
people are working on these days is

00:16:48,620 --> 00:16:53,089
dependent types and linear types and

00:16:50,810 --> 00:16:54,890
this is all very interesting research

00:16:53,089 --> 00:16:57,440
stuff that that's being prototype

00:16:54,890 --> 00:16:59,750
essentially in that language you have

00:16:57,440 --> 00:17:02,660
another thing which I personally love is

00:16:59,750 --> 00:17:05,120
asynchronous exceptions in Haskell um

00:17:02,660 --> 00:17:06,290
you have you can have any number of

00:17:05,120 --> 00:17:07,790
threats that are computing in parallel

00:17:06,290 --> 00:17:09,559
you can have thousands of threats

00:17:07,790 --> 00:17:11,870
doesn't matter it's quite common to do

00:17:09,559 --> 00:17:13,540
that and now one threat can throw an

00:17:11,870 --> 00:17:16,910
exception to another threat and that

00:17:13,540 --> 00:17:19,010
exception is going to arise at whatever

00:17:16,910 --> 00:17:22,069
point that other threat is currently

00:17:19,010 --> 00:17:23,630
evaluating so this means when you look

00:17:22,069 --> 00:17:26,000
at at your source code and you're

00:17:23,630 --> 00:17:28,280
thinking what exception can happen now

00:17:26,000 --> 00:17:30,320
the answer is everything

00:17:28,280 --> 00:17:32,270
every exception can happen at every

00:17:30,320 --> 00:17:34,790
point of your source code everything can

00:17:32,270 --> 00:17:36,440
fail with every error because another

00:17:34,790 --> 00:17:38,360
threat might throw you that thing and

00:17:36,440 --> 00:17:41,900
then you get it then it's your exception

00:17:38,360 --> 00:17:43,760
and this is also something that boggles

00:17:41,900 --> 00:17:46,240
your mind in the beginning because there

00:17:43,760 --> 00:17:48,860
is no such thing as code that can't fail

00:17:46,240 --> 00:17:51,140
but it's actually a very accurate

00:17:48,860 --> 00:17:53,150
representation of what computers are

00:17:51,140 --> 00:17:56,600
because when you assume this can't fail

00:17:53,150 --> 00:17:58,460
you are probably wrong and Hasker

00:17:56,600 --> 00:17:59,929
guarantees you yeah you are wrong this

00:17:58,460 --> 00:18:00,250
can fail and this can fail with any

00:17:59,929 --> 00:18:02,350
error

00:18:00,250 --> 00:18:05,590
you have to deal with everything at any

00:18:02,350 --> 00:18:07,780
point there is a software transactional

00:18:05,590 --> 00:18:11,440
memory it's probably hard to explain

00:18:07,780 --> 00:18:13,300
it's a way to bright transactions

00:18:11,440 --> 00:18:14,710
without locking which is very nice

00:18:13,300 --> 00:18:18,760
because it allows you to write

00:18:14,710 --> 00:18:20,950
composable software there is the support

00:18:18,760 --> 00:18:23,620
for parallel computation is excellent so

00:18:20,950 --> 00:18:26,260
when you write code in Haskell and you

00:18:23,620 --> 00:18:27,760
have a thousand threats all evaluating

00:18:26,260 --> 00:18:31,950
in parallel that's perfectly normal

00:18:27,760 --> 00:18:34,630
that's that's very efficient you can use

00:18:31,950 --> 00:18:36,370
theory and solve us to prove properties

00:18:34,630 --> 00:18:37,930
of your code and last but not least if

00:18:36,370 --> 00:18:39,760
you want to you can cross compile the

00:18:37,930 --> 00:18:40,480
entire thing to JavaScript and run it in

00:18:39,760 --> 00:18:44,950
a web browser

00:18:40,480 --> 00:18:47,140
it's very nice so now you're thinking

00:18:44,950 --> 00:18:49,630
man this Haskell doesn't sound so bad I

00:18:47,140 --> 00:18:52,540
want to try it and on open SUSE that's

00:18:49,630 --> 00:18:55,060
actually very simple so first of all you

00:18:52,540 --> 00:18:58,110
need the basic development environment

00:18:55,060 --> 00:19:01,330
and this is the compiler GHC and this

00:18:58,110 --> 00:19:03,070
the compiler and cabal install is the

00:19:01,330 --> 00:19:04,660
bill driver which you use to build your

00:19:03,070 --> 00:19:06,370
package to do your interactive

00:19:04,660 --> 00:19:09,790
development this is typically something

00:19:06,370 --> 00:19:11,260
you want this is a part of in tumbleweed

00:19:09,790 --> 00:19:13,330
you have the latest version of

00:19:11,260 --> 00:19:17,790
everything all the time we update that

00:19:13,330 --> 00:19:21,400
that basically once a week um in leap

00:19:17,790 --> 00:19:23,230
you're going to have in leap 42 3 you're

00:19:21,400 --> 00:19:26,590
also going to have the latest version of

00:19:23,230 --> 00:19:28,150
everything in leap 42 - you don't have

00:19:26,590 --> 00:19:30,130
that right now you have an older

00:19:28,150 --> 00:19:33,100
compiler and an older package set which

00:19:30,130 --> 00:19:35,470
is still fine for most purposes but it's

00:19:33,100 --> 00:19:37,750
not the bleeding edge because we stopped

00:19:35,470 --> 00:19:39,940
updating that at a certain point so that

00:19:37,750 --> 00:19:43,690
we don't break our users applications

00:19:39,940 --> 00:19:45,460
that they may have written then for

00:19:43,690 --> 00:19:47,110
installing libraries that you want to

00:19:45,460 --> 00:19:49,990
work with there is a central repository

00:19:47,110 --> 00:19:52,330
called Hecate and people who write

00:19:49,990 --> 00:19:54,160
libraries that you can reuse typically

00:19:52,330 --> 00:19:56,830
register them on hackage so you have

00:19:54,160 --> 00:19:59,590
this large database of things that you

00:19:56,830 --> 00:20:03,670
can browse and for every package that is

00:19:59,590 --> 00:20:05,890
on there you can typically try GHC - the

00:20:03,670 --> 00:20:07,960
name of that package def devil and

00:20:05,890 --> 00:20:11,200
install that and there is a really big

00:20:07,960 --> 00:20:14,120
chance that it will just work so in open

00:20:11,200 --> 00:20:16,610
source we distribute a subset of Hecate

00:20:14,120 --> 00:20:19,400
which is called um stack edge that's a

00:20:16,610 --> 00:20:21,140
variant it's quite stable hackage so we

00:20:19,400 --> 00:20:23,559
don't distribute everything that's up

00:20:21,140 --> 00:20:26,750
there but we distribute a subset that

00:20:23,559 --> 00:20:28,760
fulfill certain requirements like it's

00:20:26,750 --> 00:20:31,490
regression tested regularly there is a

00:20:28,760 --> 00:20:33,440
an address where you can report errors

00:20:31,490 --> 00:20:36,169
to and they are actually fixed in some

00:20:33,440 --> 00:20:38,890
some reasonable time frame so the author

00:20:36,169 --> 00:20:41,020
maintains the package well and there is

00:20:38,890 --> 00:20:43,789
we are certain quality insurance

00:20:41,020 --> 00:20:47,390
mechanisms in place and I think stack

00:20:43,789 --> 00:20:50,000
edge covers today about 2200 packages

00:20:47,390 --> 00:20:51,770
which is I don't know maybe a fifth of

00:20:50,000 --> 00:20:54,230
Hecate or so but the most interesting

00:20:51,770 --> 00:20:56,450
libraries are in there and we have all

00:20:54,230 --> 00:20:59,510
of them in tumbleweed and I think we

00:20:56,450 --> 00:21:03,110
have almost all of them in open leave as

00:20:59,510 --> 00:21:05,320
well um and last but not least there are

00:21:03,110 --> 00:21:07,640
tools written in Haskell which are no

00:21:05,320 --> 00:21:09,500
development library and you can install

00:21:07,640 --> 00:21:12,200
those like like any other tool for

00:21:09,500 --> 00:21:14,779
instance pan doc is an extremely nice

00:21:12,200 --> 00:21:18,529
utility to convert text formats from one

00:21:14,779 --> 00:21:20,240
format to another one oh don't ask the

00:21:18,529 --> 00:21:24,320
compiler of course and all of this is

00:21:20,240 --> 00:21:27,289
available via zipa so now suppose you

00:21:24,320 --> 00:21:30,409
are on an older distribution or you are

00:21:27,289 --> 00:21:32,000
on the commercial branch of Zeus line ox

00:21:30,409 --> 00:21:33,679
and you don't have those packages right

00:21:32,000 --> 00:21:35,960
away available or you have am i

00:21:33,679 --> 00:21:38,179
available in a version that doesn't suit

00:21:35,960 --> 00:21:39,590
your needs then what you can always do

00:21:38,179 --> 00:21:42,230
you can register any of those

00:21:39,590 --> 00:21:45,559
development projects which exists on on

00:21:42,230 --> 00:21:49,220
OBS on the command is a bit unwieldy but

00:21:45,559 --> 00:21:52,159
I think yeah you can figure it out if

00:21:49,220 --> 00:21:54,559
you want to so basically what happens is

00:21:52,159 --> 00:21:56,450
that this LTS package set it gets

00:21:54,559 --> 00:21:59,779
created at a certain point it gets a

00:21:56,450 --> 00:22:02,779
version number like LTS 6 and then there

00:21:59,779 --> 00:22:05,659
are updates of new packages go in only

00:22:02,779 --> 00:22:08,539
if they don't break the API so if there

00:22:05,659 --> 00:22:10,220
is a bug fix update will be updated in

00:22:08,539 --> 00:22:12,409
that package set but if there is an

00:22:10,220 --> 00:22:15,580
update that breaks the API it will not

00:22:12,409 --> 00:22:18,679
get into that package set and then every

00:22:15,580 --> 00:22:20,929
every year so there is a new 80s version

00:22:18,679 --> 00:22:22,850
where they say ok latest of everything

00:22:20,929 --> 00:22:25,460
and then we start the whole process over

00:22:22,850 --> 00:22:27,470
so within that package that you have a

00:22:25,460 --> 00:22:27,800
stable development environment and then

00:22:27,470 --> 00:22:30,350
you

00:22:27,800 --> 00:22:32,420
different versions that use different

00:22:30,350 --> 00:22:35,720
major versions of the Haskell packages

00:22:32,420 --> 00:22:38,780
and you can basically choose between any

00:22:35,720 --> 00:22:41,180
of those so the latest one is so

00:22:38,780 --> 00:22:42,980
currently IDs version 8 that's the one

00:22:41,180 --> 00:22:44,750
that we distribute here in this project

00:22:42,980 --> 00:22:47,780
which is the development project for

00:22:44,750 --> 00:22:50,270
factory and so when you say you're on

00:22:47,780 --> 00:22:52,100
leap 42 - and you want latest Haskell

00:22:50,270 --> 00:22:53,840
versions the latest Haskell compiler you

00:22:52,100 --> 00:22:56,240
can and you can just add that repository

00:22:53,840 --> 00:23:06,590
to your to your zipper installation and

00:22:56,240 --> 00:23:08,450
it will work fine then suppose you've

00:23:06,590 --> 00:23:10,370
written a nice application in Haskell a

00:23:08,450 --> 00:23:11,960
web application say and you want to

00:23:10,370 --> 00:23:15,890
deploy that on a whole bunch of machines

00:23:11,960 --> 00:23:19,040
and actually use it to provide services

00:23:15,890 --> 00:23:20,510
on the Internet then this is a problem

00:23:19,040 --> 00:23:23,000
that the Haskell community has

00:23:20,510 --> 00:23:25,430
traditionally struggled with and this is

00:23:23,000 --> 00:23:28,490
where I can just invite every Haskell

00:23:25,430 --> 00:23:30,740
hacker who wants to to do that give open

00:23:28,490 --> 00:23:33,290
give openSUSE try because here it's

00:23:30,740 --> 00:23:34,910
actually very simple the first thing

00:23:33,290 --> 00:23:36,290
that you can do say you have written

00:23:34,910 --> 00:23:38,780
your application that you want to deploy

00:23:36,290 --> 00:23:41,330
it the easiest way you can do that is

00:23:38,780 --> 00:23:43,190
just upload it to hackage get it

00:23:41,330 --> 00:23:45,170
registered into stack edge and then it

00:23:43,190 --> 00:23:48,140
takes a week or so and then we'll have

00:23:45,170 --> 00:23:50,390
it and we distribute it for you so once

00:23:48,140 --> 00:23:52,550
you publish your code and you release it

00:23:50,390 --> 00:23:54,350
as free software then openSUSE

00:23:52,550 --> 00:23:56,570
tumbleweed is automatically going to

00:23:54,350 --> 00:23:59,690
pick it up and that means you can

00:23:56,570 --> 00:24:01,190
install it everywhere now maybe that's

00:23:59,690 --> 00:24:03,770
not suitable for you for some reason

00:24:01,190 --> 00:24:06,260
maybe I don't know the code is not open

00:24:03,770 --> 00:24:08,840
source or maybe tumbleweed is not for

00:24:06,260 --> 00:24:11,030
you then you can always use the build

00:24:08,840 --> 00:24:13,790
service which is also for everyone who

00:24:11,030 --> 00:24:15,770
doesn't know that this is maybe the most

00:24:13,790 --> 00:24:17,990
useful service at all in all of open

00:24:15,770 --> 00:24:20,630
suits you can get an account here for

00:24:17,990 --> 00:24:22,700
free you can upload spec files for your

00:24:20,630 --> 00:24:24,590
packages and this thing will build them

00:24:22,700 --> 00:24:26,270
and will test them for you and it will

00:24:24,590 --> 00:24:30,680
distribute binaries for you and you can

00:24:26,270 --> 00:24:32,540
just use them wherever you want the spec

00:24:30,680 --> 00:24:34,160
files that you do you don't have to

00:24:32,540 --> 00:24:35,900
write them manually you can generate

00:24:34,160 --> 00:24:38,390
them automatically for your Asquith

00:24:35,900 --> 00:24:40,340
projects there's a tool called cabal rpm

00:24:38,390 --> 00:24:41,240
which is part of open source of course

00:24:40,340 --> 00:24:43,520
and you

00:24:41,240 --> 00:24:45,260
can feed the Cabal file through that and

00:24:43,520 --> 00:24:46,820
you get a spec file out of it that you

00:24:45,260 --> 00:24:49,190
can reduce the year and build your own

00:24:46,820 --> 00:24:51,170
application on the open build service

00:24:49,190 --> 00:24:54,170
and then you can install it everywhere

00:24:51,170 --> 00:24:56,210
and last but not least if you have a

00:24:54,170 --> 00:24:58,490
crazy complicated infrastructure that

00:24:56,210 --> 00:25:00,860
depends on very specific versions of

00:24:58,490 --> 00:25:02,930
very specific packages and and this is

00:25:00,860 --> 00:25:05,330
all a lot of work then you can use the

00:25:02,930 --> 00:25:07,070
tool that we use to build those

00:25:05,330 --> 00:25:09,710
development project which is called

00:25:07,070 --> 00:25:11,390
cabal to obs it's open source it's on

00:25:09,710 --> 00:25:13,250
github you can fork it you can change

00:25:11,390 --> 00:25:15,770
edit the package set run it and then

00:25:13,250 --> 00:25:19,190
upload your own package set to the open

00:25:15,770 --> 00:25:22,040
build service and build very specialized

00:25:19,190 --> 00:25:25,330
environments that are particularly

00:25:22,040 --> 00:25:30,380
well-suited for your needs

00:25:25,330 --> 00:25:33,320
so in haskell builds are described by

00:25:30,380 --> 00:25:35,570
something called um cabal the is a very

00:25:33,320 --> 00:25:37,640
clever abbreviation like common

00:25:35,570 --> 00:25:41,570
architecture for building things I don't

00:25:37,640 --> 00:25:44,900
I don't remember and this is basically a

00:25:41,570 --> 00:25:46,760
plain text file which contains some meta

00:25:44,900 --> 00:25:48,230
information about your package like what

00:25:46,760 --> 00:25:49,070
it's called what's the version what's

00:25:48,230 --> 00:25:51,500
the license

00:25:49,070 --> 00:25:53,360
a short description the synopsis all

00:25:51,500 --> 00:25:56,720
these things that that every package

00:25:53,360 --> 00:25:58,820
basically has and then you also have for

00:25:56,720 --> 00:26:01,190
instance a library an executable

00:25:58,820 --> 00:26:03,200
component in your package and these can

00:26:01,190 --> 00:26:05,420
depend on other Haskell packages like

00:26:03,200 --> 00:26:07,100
here and then they have this extra

00:26:05,420 --> 00:26:09,440
library stand so they can depend on

00:26:07,100 --> 00:26:11,690
system libraries in this example for

00:26:09,440 --> 00:26:14,810
instance the package depends on open ssl

00:26:11,690 --> 00:26:17,450
and once super to install that for you

00:26:14,810 --> 00:26:20,300
for your build you have an executable

00:26:17,450 --> 00:26:22,160
which depends on hand dark and example

00:26:20,300 --> 00:26:23,720
on the library and so this is something

00:26:22,160 --> 00:26:25,670
if you're developing a script package

00:26:23,720 --> 00:26:28,310
this is if I you are going to write this

00:26:25,670 --> 00:26:29,990
is something you'll probably do and once

00:26:28,310 --> 00:26:34,480
you have that you can generate a spec

00:26:29,990 --> 00:26:36,800
file from that automatically and

00:26:34,480 --> 00:26:40,550
obviously this is the process that we

00:26:36,800 --> 00:26:42,710
also use um when we this this this

00:26:40,550 --> 00:26:44,810
project with those 2000 bills in there

00:26:42,710 --> 00:26:48,290
we updated automatically from those

00:26:44,810 --> 00:26:50,660
those cabal files we download we

00:26:48,290 --> 00:26:53,210
download the cabal files from from

00:26:50,660 --> 00:26:54,530
hackage with a tool which is essentially

00:26:53,210 --> 00:26:58,450
a build system right

00:26:54,530 --> 00:27:01,040
written in Haskell and so you basically

00:26:58,450 --> 00:27:04,070
get the latest version of everything and

00:27:01,040 --> 00:27:06,080
then we rebuild a repository and the

00:27:04,070 --> 00:27:07,910
process I'm going to show it in more

00:27:06,080 --> 00:27:11,780
detail on the next slide but the process

00:27:07,910 --> 00:27:13,940
basically creates the spec file then we

00:27:11,780 --> 00:27:16,310
have in this case this update only shows

00:27:13,940 --> 00:27:18,050
an update for Pandora 80s 8 but

00:27:16,310 --> 00:27:19,820
obviously we update all kinds of

00:27:18,050 --> 00:27:22,760
packages in all kinds of kinds of

00:27:19,820 --> 00:27:25,640
package sets this is just one example to

00:27:22,760 --> 00:27:28,070
make it fit on the slide so suppose that

00:27:25,640 --> 00:27:30,230
version has an update and we generate

00:27:28,070 --> 00:27:32,390
this generate the spec file for it we

00:27:30,230 --> 00:27:35,720
run spec Lena over it to be basically

00:27:32,390 --> 00:27:38,590
run spec Lena over everything so we want

00:27:35,720 --> 00:27:41,960
our spec files to have a very consistent

00:27:38,590 --> 00:27:44,330
consistent look and and we want speckly

00:27:41,960 --> 00:27:47,990
not to be no op when you run it on it

00:27:44,330 --> 00:27:50,390
and then for some packages on the Kabala

00:27:47,990 --> 00:27:53,060
file maybe doesn't contain sufficient

00:27:50,390 --> 00:27:54,980
information or maybe we have additional

00:27:53,060 --> 00:27:57,290
features we'd like to enable and then we

00:27:54,980 --> 00:28:00,500
have a set of patches that may be

00:27:57,290 --> 00:28:03,530
applied to every of those packages to

00:28:00,500 --> 00:28:05,180
patch the spec file into I don't know to

00:28:03,530 --> 00:28:07,250
add additional features or fix the

00:28:05,180 --> 00:28:09,800
license tag like in this case and again

00:28:07,250 --> 00:28:13,310
after every patch we always run spec

00:28:09,800 --> 00:28:15,380
Tina and in the end it says done took 7

00:28:13,310 --> 00:28:17,900
seconds and now we have this edgy as 8

00:28:15,380 --> 00:28:20,060
package set and this is essentially a

00:28:17,900 --> 00:28:23,690
check out from OBS which we then commit

00:28:20,060 --> 00:28:25,400
and that's that so this whole update

00:28:23,690 --> 00:28:27,770
process I guess the point is the whole

00:28:25,400 --> 00:28:30,320
update process is automatic there is no

00:28:27,770 --> 00:28:31,820
human my image sometimes something

00:28:30,320 --> 00:28:33,800
breaks because of a bug somewhere but

00:28:31,820 --> 00:28:36,020
for the most part this is completely

00:28:33,800 --> 00:28:37,970
automatic so this package set is always

00:28:36,020 --> 00:28:39,890
in an up-to-date state and nobody's

00:28:37,970 --> 00:28:46,160
actually manually doing anything about

00:28:39,890 --> 00:28:48,920
it which is particularly nice so when we

00:28:46,160 --> 00:28:51,230
generate the package set we have this

00:28:48,920 --> 00:28:55,490
cabal - AVS utility which also

00:28:51,230 --> 00:28:57,680
implements a lot of of checks which we

00:28:55,490 --> 00:29:00,380
learned over time are fairly important

00:28:57,680 --> 00:29:02,660
so for instance sometimes people specify

00:29:00,380 --> 00:29:04,400
a name of a license that doesn't exist

00:29:02,660 --> 00:29:06,320
and we know that's going to fail the

00:29:04,400 --> 00:29:08,179
review so if we detect anything like

00:29:06,320 --> 00:29:10,740
that we bought the building

00:29:08,179 --> 00:29:14,269
then people have write all kinds of

00:29:10,740 --> 00:29:16,740
nonsense into their package descriptions

00:29:14,269 --> 00:29:18,990
oftentimes it's something like see you

00:29:16,740 --> 00:29:21,269
read me which doesn't help us much

00:29:18,990 --> 00:29:22,889
sometimes it's just plain nonsense all

00:29:21,269 --> 00:29:26,700
right something they copy pasted from

00:29:22,889 --> 00:29:28,679
the brown package and we make a good

00:29:26,700 --> 00:29:30,510
effort to detect these cases where these

00:29:28,679 --> 00:29:32,429
things don't add up and also about the

00:29:30,510 --> 00:29:35,700
build so that we can fix it manually and

00:29:32,429 --> 00:29:37,289
also what something people often do in

00:29:35,700 --> 00:29:39,389
karbala fights is that they confuse

00:29:37,289 --> 00:29:41,820
documentation and data files that they

00:29:39,389 --> 00:29:44,010
say I have a readme and it's a data file

00:29:41,820 --> 00:29:45,929
but no it's a readme it's documentation

00:29:44,010 --> 00:29:48,210
and then we try to automatically fix

00:29:45,929 --> 00:29:50,610
that in the spec file so that our users

00:29:48,210 --> 00:29:53,580
ever find the readme in the proper

00:29:50,610 --> 00:29:55,440
location okay so we generate the whole

00:29:53,580 --> 00:29:58,169
package set this is completely automatic

00:29:55,440 --> 00:30:00,330
then we commit it into this double

00:29:58,169 --> 00:30:03,210
project into the LTS eight project which

00:30:00,330 --> 00:30:05,190
is a bit of a staging area for the most

00:30:03,210 --> 00:30:06,840
part things just compiled sometimes

00:30:05,190 --> 00:30:08,519
there is a build or for some reason then

00:30:06,840 --> 00:30:12,510
we manually fix the build errors and

00:30:08,519 --> 00:30:14,279
then when this this development project

00:30:12,510 --> 00:30:16,889
is in a state where everything compiles

00:30:14,279 --> 00:30:18,960
then we synchronize it into the proper

00:30:16,889 --> 00:30:21,929
development project for for open source

00:30:18,960 --> 00:30:23,340
Factory and once it's in that project

00:30:21,929 --> 00:30:24,809
it's going to submit is going to be

00:30:23,340 --> 00:30:28,289
submitted to factory mostly

00:30:24,809 --> 00:30:30,389
automatically there is this obvious auto

00:30:28,289 --> 00:30:32,190
submitter a nice service that the the

00:30:30,389 --> 00:30:34,309
OBS team runs and it will automatically

00:30:32,190 --> 00:30:36,750
pick up the updates and submit them to

00:30:34,309 --> 00:30:38,580
to factory and then they show up and

00:30:36,750 --> 00:30:43,559
tumble with a couple of days later we're

00:30:38,580 --> 00:30:46,169
lucky so this whole stuff is all living

00:30:43,559 --> 00:30:48,570
on github um URL is on the next slide I

00:30:46,169 --> 00:30:50,309
think um so you can mess with that you

00:30:48,570 --> 00:30:53,220
can take a look at if you if you want to

00:30:50,309 --> 00:30:55,950
and the repository that we have contains

00:30:53,220 --> 00:30:57,720
obviously the the package sets the lists

00:30:55,950 --> 00:31:00,059
of packages and versions that we

00:30:57,720 --> 00:31:01,919
distribute we have a bunch of packages

00:31:00,059 --> 00:31:03,809
that are not part of stack age but that

00:31:01,919 --> 00:31:07,049
we distribute anyway because they're

00:31:03,809 --> 00:31:09,419
useful for some reason we have in some

00:31:07,049 --> 00:31:11,850
cases explicit build settings where we

00:31:09,419 --> 00:31:13,830
change defaults because we enable

00:31:11,850 --> 00:31:16,139
features that are not on by default or

00:31:13,830 --> 00:31:18,200
something like that and then we have a

00:31:16,139 --> 00:31:21,040
set a whole bunch of patches that

00:31:18,200 --> 00:31:25,179
improve the generated spec files

00:31:21,040 --> 00:31:27,220
and I counted those things yesterday and

00:31:25,179 --> 00:31:30,400
I was very surprised that we have

00:31:27,220 --> 00:31:33,580
actually well over 230 packages that

00:31:30,400 --> 00:31:36,730
declared a license incorrectly and this

00:31:33,580 --> 00:31:38,260
is I think the single most reason for

00:31:36,730 --> 00:31:41,110
failed reviews when we submit those

00:31:38,260 --> 00:31:43,630
things so people they say in the Kabala

00:31:41,110 --> 00:31:45,640
file I have a bsd to license and then

00:31:43,630 --> 00:31:48,340
they have a beast the free license file

00:31:45,640 --> 00:31:51,610
in there or some people say i'm GPL and

00:31:48,340 --> 00:31:54,669
in fact they are in MIT license and this

00:31:51,610 --> 00:31:57,490
is all very common I don't know how

00:31:54,669 --> 00:31:59,440
people do that but it's very common

00:31:57,490 --> 00:32:02,470
so people have no idea of what license

00:31:59,440 --> 00:32:06,100
that packages Ana and then we fix it for

00:32:02,470 --> 00:32:08,320
them this is I have to say one of the

00:32:06,100 --> 00:32:10,120
things that is really nice about open

00:32:08,320 --> 00:32:12,850
suits because when you download this

00:32:10,120 --> 00:32:15,549
stuff from from us then you can actually

00:32:12,850 --> 00:32:17,740
trust the the license so when the spec

00:32:15,549 --> 00:32:20,290
file says this is a bsd to package then

00:32:17,740 --> 00:32:22,030
it is a bsd to package but it should

00:32:20,290 --> 00:32:24,730
download it from from hackage then it

00:32:22,030 --> 00:32:26,710
might not be but in open source you have

00:32:24,730 --> 00:32:28,840
had a lawyer actually look at it and

00:32:26,710 --> 00:32:32,679
make sure that this information is

00:32:28,840 --> 00:32:35,830
accurate so this is I think quite a nice

00:32:32,679 --> 00:32:37,750
added value we have lots of fixes for

00:32:35,830 --> 00:32:39,179
for package descriptions that didn't

00:32:37,750 --> 00:32:41,799
make any sense

00:32:39,179 --> 00:32:43,660
sometimes people upload release tarballs

00:32:41,799 --> 00:32:47,230
where files are missing then we add them

00:32:43,660 --> 00:32:48,010
add them for them again and all kinds of

00:32:47,230 --> 00:32:51,220
things right

00:32:48,010 --> 00:32:56,110
I mean distributing software is not as

00:32:51,220 --> 00:32:58,090
easy as it looks ok so if you want to

00:32:56,110 --> 00:32:59,890
know more then these are the places to

00:32:58,090 --> 00:33:02,650
look at obviously the Haskell website

00:32:59,890 --> 00:33:04,540
has the complete standard for the

00:33:02,650 --> 00:33:08,590
language it have links to tutorials and

00:33:04,540 --> 00:33:10,750
everything stack edge is the place to

00:33:08,590 --> 00:33:12,669
look for the stable package sets if you

00:33:10,750 --> 00:33:15,700
want to mess with that this is the

00:33:12,669 --> 00:33:17,830
repository for our software that we use

00:33:15,700 --> 00:33:22,090
to develop everything and this is the

00:33:17,830 --> 00:33:24,549
development project in OBS ok I think it

00:33:22,090 --> 00:33:25,809
was fairly quick so thank you very much

00:33:24,549 --> 00:33:27,120
for your attention and if you have any

00:33:25,809 --> 00:33:34,540
questions then shoot

00:33:27,120 --> 00:33:38,780
[Music]

00:33:34,540 --> 00:33:45,410
is there any plan to make a house cow

00:33:38,780 --> 00:33:48,800
available on arm in openSUSE this it is

00:33:45,410 --> 00:34:09,440
not available for rb7 for the 32-bit

00:33:48,800 --> 00:34:13,040
port or at least I didn't find any so

00:34:09,440 --> 00:34:15,710
the development project here well maybe

00:34:13,040 --> 00:34:18,020
maybe I can help out here yeah

00:34:15,710 --> 00:34:20,000
I'm Peter Drummey I'm the the maintainer

00:34:18,020 --> 00:34:24,950
of the compiler so I'm actually

00:34:20,000 --> 00:34:26,000
responsible for initiating the 2000

00:34:24,950 --> 00:34:28,610
packages

00:34:26,000 --> 00:34:31,310
attack if you want to call it that

00:34:28,610 --> 00:34:36,530
currently I haven't we haven't installed

00:34:31,310 --> 00:34:42,740
the the 32-bit binaries for 4 GHz for 4

00:34:36,530 --> 00:34:46,030
arms personally I don't know if if I

00:34:42,740 --> 00:34:50,149
find the time to do it but others have

00:34:46,030 --> 00:34:52,100
submitted a bootstrapping compiler

00:34:50,149 --> 00:34:55,429
that's what we're missing in the past

00:34:52,100 --> 00:34:58,070
and I mean we could try I don't know I

00:34:55,429 --> 00:35:02,930
think we need a certain version of LLVM

00:34:58,070 --> 00:35:06,140
for the arm ports to work and and the

00:35:02,930 --> 00:35:14,750
right version of LLVM is not available

00:35:06,140 --> 00:35:17,060
in in the last leap version for 8.2 ghz

00:35:14,750 --> 00:35:21,980
version that's going to come out in June

00:35:17,060 --> 00:35:23,780
I think well that's the plan of GHC

00:35:21,980 --> 00:35:27,530
headquarters they said they're going to

00:35:23,780 --> 00:35:29,630
support LLVM 3 9 or maybe even 4 0 and

00:35:27,530 --> 00:35:32,540
we have both of those in in factory or

00:35:29,630 --> 00:35:35,750
in tumbleweed and I could give it a shot

00:35:32,540 --> 00:35:37,730
if I find the time or if somebody else

00:35:35,750 --> 00:35:42,250
wants to jump on it and just just send

00:35:37,730 --> 00:35:45,850
pull requests to to develop a skill and

00:35:42,250 --> 00:35:51,190
and enable it if if I can but be a bit

00:35:45,850 --> 00:35:53,560
patient was the 8.2 it's not my main job

00:35:51,190 --> 00:35:55,570
my students would get very angry if I

00:35:53,560 --> 00:35:57,130
said well I'm not preparing the lectures

00:35:55,570 --> 00:36:11,800
because I have to do the Haskell

00:35:57,130 --> 00:36:14,620
compiler I've got another question so

00:36:11,800 --> 00:36:17,260
then I'm for a university where we are

00:36:14,620 --> 00:36:19,180
working with like tools regarding for

00:36:17,260 --> 00:36:23,020
application field of data mining is

00:36:19,180 --> 00:36:25,360
there something or like tools like numpy

00:36:23,020 --> 00:36:26,950
and Syfy available I know let's sort is

00:36:25,360 --> 00:36:29,470
the problem question but other tools

00:36:26,950 --> 00:36:33,070
like numpy in sci-fi like pandas for

00:36:29,470 --> 00:36:34,690
reading in data and processing it does

00:36:33,070 --> 00:36:37,630
anyone here in the audience also knows

00:36:34,690 --> 00:36:41,880
of that because that would be quite cool

00:36:37,630 --> 00:36:43,810
to apply the slides button um there is a

00:36:41,880 --> 00:36:45,640
special interest group in ask a

00:36:43,810 --> 00:36:48,400
community that's concerned with data

00:36:45,640 --> 00:36:50,800
mining machine learning and they have

00:36:48,400 --> 00:36:54,220
produced a whole set of libraries there

00:36:50,800 --> 00:36:56,710
is something a very comprehensive

00:36:54,220 --> 00:36:58,840
binding to are which allows you to mix

00:36:56,710 --> 00:37:01,330
our and Haskell so you can write ask a

00:36:58,840 --> 00:37:03,970
code and seamlessly interface to our and

00:37:01,330 --> 00:37:06,760
share results which i think is probably

00:37:03,970 --> 00:37:08,740
a very good solution because our has the

00:37:06,760 --> 00:37:11,980
most sophisticated libraries in this

00:37:08,740 --> 00:37:13,840
area right and you have explicit machine

00:37:11,980 --> 00:37:16,620
learning libraries and visualization

00:37:13,840 --> 00:37:19,420
libraries that are written in SQL so I

00:37:16,620 --> 00:37:21,310
don't know I'm not an expert in this

00:37:19,420 --> 00:37:23,410
field so I don't know whether the stuff

00:37:21,310 --> 00:37:25,860
is as good as the Python libraries are

00:37:23,410 --> 00:37:30,700
but there certainly is a sophisticated

00:37:25,860 --> 00:37:33,240
infrastructure there yeah and it's open

00:37:30,700 --> 00:37:33,240
source right

00:37:38,450 --> 00:37:41,710

YouTube URL: https://www.youtube.com/watch?v=gu7tIFJjHhU


