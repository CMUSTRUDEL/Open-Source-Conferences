Title: openSUSE Conference 2017 Virtual Networking in the NFVi
Publication date: 2017-05-28
Playlist: openSUSE Conference 2017
Description: 
	https://media.ccc.de/v/1244-virtual-networking-in-the-nfvi

Landscapes and Challenges

NFV is a complex world made of hardware technologies and software stacks. A key component is the NFV infrastructure which provides the environment on which the Virtual Networking Functions run. The ecosystem of software/hardware for the NFVI is growing day-by-day making end-users life very difficult: Which platform to buy? Which stack to deploy? Which Virtual Networking solution should be adopted? Answering all these questions is far from being an easy task. In this presentation, we will provide you with the current state of the art of the vSwitch ecosystem (i.e. Open vSwitch, VPP), discuss different approaches around common use cases, deployment and integration challenges (i.e. SDN controller and orchestration integration) and what questions you shall ask yourself before picking your final networking software stack.
This presentation will help developers and end-users who are getting closer to the NFV world to familiarize themselves with the existing NFV technologies and, potentially, help them chose what to focus on based on our perspective.
Attendees can expect a detailed update on the current open-source vSwitch portfolio, new trends and on-going discussions within the open-source community.



Marco Varlese
Captions: 
	00:00:07,340 --> 00:00:12,139
hi everyone thanks for coming to this

00:00:10,710 --> 00:00:15,000
talk

00:00:12,139 --> 00:00:16,109
hopefully had a good lunch and this is

00:00:15,000 --> 00:00:19,080
going to be interesting so you don't

00:00:16,109 --> 00:00:22,850
fall asleep I'm mark overlays I'm

00:00:19,080 --> 00:00:24,920
working for the networking team in Susa

00:00:22,850 --> 00:00:27,689
and today I'm going to talk to you about

00:00:24,920 --> 00:00:29,039
visual networking in the NF VI which

00:00:27,689 --> 00:00:35,160
stands for network function

00:00:29,039 --> 00:00:38,700
virtualization in infrastructure so I'm

00:00:35,160 --> 00:00:41,399
going through quite few slides from the

00:00:38,700 --> 00:00:47,520
evolution of the data centers to few and

00:00:41,399 --> 00:00:48,960
NFV concepts focusing on two main with V

00:00:47,520 --> 00:00:53,520
switches that we currently see in the

00:00:48,960 --> 00:00:55,260
open source open V switch and VPP and

00:00:53,520 --> 00:00:59,449
then I'm going to talk to you about few

00:00:55,260 --> 00:01:03,930
things around platform awareness just

00:00:59,449 --> 00:01:08,479
out of curiosity who of you has any idea

00:01:03,930 --> 00:01:08,479
what a DV stands for and what it is

00:01:09,140 --> 00:01:24,630
current trends okay so according to the

00:01:20,070 --> 00:01:29,100
survey that cisco ran into 2013 77% of

00:01:24,630 --> 00:01:33,540
the data center traffic was seen the

00:01:29,100 --> 00:01:37,070
data center itself now if you think

00:01:33,540 --> 00:01:40,500
about it it's quite a lot of data that

00:01:37,070 --> 00:01:45,240
it's produced and consumed within the

00:01:40,500 --> 00:01:48,540
data center itself which is amazing if

00:01:45,240 --> 00:01:50,579
you think about the actual use that we

00:01:48,540 --> 00:01:54,470
that we do with our pcs when we access

00:01:50,579 --> 00:01:59,909
the internet so we usually consume data

00:01:54,470 --> 00:02:03,060
video news or upload data so there's a

00:01:59,909 --> 00:02:05,729
lot of that going on and still 77

00:02:03,060 --> 00:02:08,329
percent of that traffic is within the

00:02:05,729 --> 00:02:08,329
data center itself

00:02:08,440 --> 00:02:14,610
now if you if you for a second thing

00:02:12,040 --> 00:02:18,780
about what that means if you want to

00:02:14,610 --> 00:02:24,160
simply stick with a physical environment

00:02:18,780 --> 00:02:26,500
well you're gonna you're going to see in

00:02:24,160 --> 00:02:31,840
the bare metal situation you're going to

00:02:26,500 --> 00:02:34,620
see one OS per machine the networking is

00:02:31,840 --> 00:02:39,120
going to be organized in the usual

00:02:34,620 --> 00:02:42,700
access distribution and core layers

00:02:39,120 --> 00:02:44,680
you're going to see all the traditional

00:02:42,700 --> 00:02:46,840
l-2 and l-3 problems that you would see

00:02:44,680 --> 00:02:51,069
in a data center talking about spanning

00:02:46,840 --> 00:02:53,380
tree for example and what's worse is if

00:02:51,069 --> 00:02:56,260
you need to offer any type of high

00:02:53,380 --> 00:02:59,739
availability to your customers if you're

00:02:56,260 --> 00:03:02,530
a cloud for example cloud provider that

00:02:59,739 --> 00:03:04,510
can only be done with physical so that

00:03:02,530 --> 00:03:07,959
means physical machine to a physical

00:03:04,510 --> 00:03:12,220
machine or with the physical links

00:03:07,959 --> 00:03:14,410
between them so the issues obviously

00:03:12,220 --> 00:03:16,269
connected to this is that it's a it's a

00:03:14,410 --> 00:03:19,750
constrained environment it doesn't

00:03:16,269 --> 00:03:23,920
really scale and it's really really

00:03:19,750 --> 00:03:25,590
expensive and it's complex the network

00:03:23,920 --> 00:03:28,600
is obviously is going to be Subutai

00:03:25,590 --> 00:03:32,680
because you cannot really scale over a

00:03:28,600 --> 00:03:36,670
certain limit if you have any failures

00:03:32,680 --> 00:03:38,200
as I said the backup or the high

00:03:36,670 --> 00:03:42,280
availability type of scenario is going

00:03:38,200 --> 00:03:44,470
to have a very slow recovery and you'll

00:03:42,280 --> 00:03:47,310
find a situation where you're going to

00:03:44,470 --> 00:03:51,310
hit pretty soon what are the limits of

00:03:47,310 --> 00:03:54,730
what you're capable of number of MAC

00:03:51,310 --> 00:03:57,310
addresses number of VLANs how you're

00:03:54,730 --> 00:04:01,790
going to partition your network in the

00:03:57,310 --> 00:04:06,210
data center to scale to different size

00:04:01,790 --> 00:04:09,840
so visualization is not a new concept

00:04:06,210 --> 00:04:13,710
but the use of it in the networking

00:04:09,840 --> 00:04:18,720
space is pretty new talking about for

00:04:13,710 --> 00:04:20,250
five years the thing is with

00:04:18,720 --> 00:04:22,200
virtualization we solved a lot of the

00:04:20,250 --> 00:04:26,000
compute issues so for example now we can

00:04:22,200 --> 00:04:28,770
run multiple VMs on a single machine

00:04:26,000 --> 00:04:31,640
we can we can we can do efficient

00:04:28,770 --> 00:04:34,560
storage we can visualize storage and

00:04:31,640 --> 00:04:37,080
obviously we can also visualize network

00:04:34,560 --> 00:04:41,730
cards I'm sure that you have all heard

00:04:37,080 --> 00:04:44,010
about virtual functions on using SLV or

00:04:41,730 --> 00:04:46,290
multiple queues which are queues and all

00:04:44,010 --> 00:04:48,450
the magic that you can do with that what

00:04:46,290 --> 00:04:53,340
that means though is that we start

00:04:48,450 --> 00:04:55,640
seeing a brand new type of issue we now

00:04:53,340 --> 00:04:59,010
are talking about not just traffic

00:04:55,640 --> 00:05:00,540
heating they did the server the compute

00:04:59,010 --> 00:05:06,990
node but we're actually seeing traffic

00:05:00,540 --> 00:05:09,090
that hist West which means VM to VM goes

00:05:06,990 --> 00:05:14,270
on the same server and still has to be

00:05:09,090 --> 00:05:18,720
handled by something we have obviously

00:05:14,270 --> 00:05:23,790
the introduction of VX LAN which created

00:05:18,720 --> 00:05:26,310
a huge number of endpoints that are now

00:05:23,790 --> 00:05:30,900
possible to be reached versus what was

00:05:26,310 --> 00:05:33,630
possible with villain and and obviously

00:05:30,900 --> 00:05:36,870
we're talking about things like inter

00:05:33,630 --> 00:05:38,640
server security if you are a provider if

00:05:36,870 --> 00:05:41,040
you're offering a service how you make

00:05:38,640 --> 00:05:43,950
sure that somebody that's running a

00:05:41,040 --> 00:05:45,600
service on one virtual machine now that

00:05:43,950 --> 00:05:48,480
victim machine can talk to another

00:05:45,600 --> 00:05:51,150
virtual machine on the same host how you

00:05:48,480 --> 00:05:54,419
guarantee the right separation between

00:05:51,150 --> 00:05:58,169
the two of them talking about network

00:05:54,419 --> 00:06:00,540
traffic it was quite clear that there

00:05:58,169 --> 00:06:04,260
was in need of a of a new architecture

00:06:00,540 --> 00:06:07,410
or revisiting what was used before and

00:06:04,260 --> 00:06:10,320
trying to adjust it to these new

00:06:07,410 --> 00:06:12,150
scenarios so this

00:06:10,320 --> 00:06:15,210
pictures tries to basically give you an

00:06:12,150 --> 00:06:17,910
idea of what has been the evolution of a

00:06:15,210 --> 00:06:20,760
data center we we started with

00:06:17,910 --> 00:06:23,370
everything being in physical bare metal

00:06:20,760 --> 00:06:25,800
environment we then introduced the

00:06:23,370 --> 00:06:27,720
virtual data center with all they did

00:06:25,800 --> 00:06:31,260
the nice aspects of visualization and

00:06:27,720 --> 00:06:33,570
the nd compute then there was the

00:06:31,260 --> 00:06:35,640
introduction of the V switches which I'm

00:06:33,570 --> 00:06:40,020
going to talk to you about it in a

00:06:35,640 --> 00:06:44,550
second and did the next evolution of it

00:06:40,020 --> 00:06:47,010
was the V routers and then just in the

00:06:44,550 --> 00:06:49,740
in the in the recent years we have seen

00:06:47,010 --> 00:06:52,470
also the the user didn't and the more

00:06:49,740 --> 00:06:58,230
use of the extensible data planes these

00:06:52,470 --> 00:07:02,370
are things like BP f e BP f x DP from

00:06:58,230 --> 00:07:06,930
the IO visor community which offer a

00:07:02,370 --> 00:07:12,410
great a great computability and great

00:07:06,930 --> 00:07:18,240
programmability of data planes on linux

00:07:12,410 --> 00:07:19,950
so what is nav well first of all an

00:07:18,240 --> 00:07:23,430
efficient for network function

00:07:19,950 --> 00:07:27,720
virtualization and it offers the

00:07:23,430 --> 00:07:31,260
opportunity to decouple the network

00:07:27,720 --> 00:07:34,110
function from proprietary hardware and

00:07:31,260 --> 00:07:36,840
let them run in software if you think

00:07:34,110 --> 00:07:41,100
about what was the market in the

00:07:36,840 --> 00:07:45,000
networking space until few years ago and

00:07:41,100 --> 00:07:47,750
still predominant it was all made of for

00:07:45,000 --> 00:07:51,450
example hardware switches where a

00:07:47,750 --> 00:07:54,300
company like cisco juniper and and

00:07:51,450 --> 00:08:00,740
others had their big presence in the

00:07:54,300 --> 00:08:00,740
market and why was why was this

00:08:00,980 --> 00:08:10,500
architecture started and and thought

00:08:04,590 --> 00:08:12,980
about well it started with service

00:08:10,500 --> 00:08:15,600
providers who wanted to basically

00:08:12,980 --> 00:08:17,030
accelerate the deployment of new

00:08:15,600 --> 00:08:19,070
services

00:08:17,030 --> 00:08:22,430
to increase the growth and also to

00:08:19,070 --> 00:08:28,760
reduce the amount of money that they

00:08:22,430 --> 00:08:30,650
spend with Arbor as a result the Etsy

00:08:28,760 --> 00:08:33,320
which is the European telecommunications

00:08:30,650 --> 00:08:36,230
standards Institute basically married

00:08:33,320 --> 00:08:38,870
this idea and start supporting it and a

00:08:36,230 --> 00:08:41,450
lot of companies joined in then lots of

00:08:38,870 --> 00:08:45,910
experts people start producing a lot of

00:08:41,450 --> 00:08:49,430
drafts papers etc so it became really a

00:08:45,910 --> 00:08:52,220
sort of standard in the architecture in

00:08:49,430 --> 00:08:54,650
what it looks like so the the nfe

00:08:52,220 --> 00:08:57,020
basically allows you to to reduce your

00:08:54,650 --> 00:09:02,110
capital expenditure which here is called

00:08:57,020 --> 00:09:06,170
capex so you can reduce the amount of

00:09:02,110 --> 00:09:08,450
machines that you that you buy it reduce

00:09:06,170 --> 00:09:12,740
the OPEX which stands for operational

00:09:08,450 --> 00:09:15,080
expenditure because obviously buying

00:09:12,740 --> 00:09:18,350
less machines it means that in the data

00:09:15,080 --> 00:09:23,180
center you can use less power you can

00:09:18,350 --> 00:09:26,750
use less cooling to keep the temperature

00:09:23,180 --> 00:09:28,250
okay for the equipment and it also

00:09:26,750 --> 00:09:31,220
accelerate the time to market because

00:09:28,250 --> 00:09:33,410
now everything is is virtual everything

00:09:31,220 --> 00:09:35,600
can be d can be deployed with a click

00:09:33,410 --> 00:09:36,860
you can configure things in an easier

00:09:35,600 --> 00:09:40,580
way

00:09:36,860 --> 00:09:43,880
so people that want to to try out new

00:09:40,580 --> 00:09:46,700
things that want to test new things have

00:09:43,880 --> 00:09:53,650
the chance of doing it and it also

00:09:46,700 --> 00:09:57,080
offers a great degree of agility because

00:09:53,650 --> 00:10:00,890
what you can do you can easily scale up

00:09:57,080 --> 00:10:03,110
and down just by turning on new virtual

00:10:00,890 --> 00:10:05,300
machine switching it off based on the

00:10:03,110 --> 00:10:07,030
needs it would have been much much

00:10:05,300 --> 00:10:10,790
harder if you want to basically go and

00:10:07,030 --> 00:10:13,630
buy a server or configure server on the

00:10:10,790 --> 00:10:13,630
fly when you need it

00:10:14,410 --> 00:10:21,880
so in the end of ich werde the

00:10:19,060 --> 00:10:23,680
architecture is quite vast and obviously

00:10:21,880 --> 00:10:28,360
there are different layers there are

00:10:23,680 --> 00:10:31,120
different components I a very important

00:10:28,360 --> 00:10:35,080
part of it is played by the data plane

00:10:31,120 --> 00:10:37,240
and by the control plane and there is

00:10:35,080 --> 00:10:40,540
this concept of V switch which stands

00:10:37,240 --> 00:10:43,840
for virtual switch a virtual switch is

00:10:40,540 --> 00:10:47,680
is a software component that basically

00:10:43,840 --> 00:10:51,250
allows you to run traffic between VMs

00:10:47,680 --> 00:10:53,620
and can also allow you to to have that

00:10:51,250 --> 00:10:56,140
traffic reaching the outside world so

00:10:53,620 --> 00:10:59,070
what happens is that the VM can we can

00:10:56,140 --> 00:11:03,520
communicate with another VM on the same

00:10:59,070 --> 00:11:06,730
physical machine and the same VM if

00:11:03,520 --> 00:11:12,340
needed can reach the internet for

00:11:06,730 --> 00:11:13,840
example what's what's nice about a Vista

00:11:12,340 --> 00:11:16,930
switch is that it basically leaves

00:11:13,840 --> 00:11:19,570
within the hypervisor itself so now the

00:11:16,930 --> 00:11:21,930
hypervisor has as a network

00:11:19,570 --> 00:11:25,210
functionality as well added to the

00:11:21,930 --> 00:11:28,440
overall virtualization methodologies and

00:11:25,210 --> 00:11:35,410
techniques that's implemented in there

00:11:28,440 --> 00:11:38,020
and and and and basically it's much

00:11:35,410 --> 00:11:41,200
easier now if you want to roll out a

00:11:38,020 --> 00:11:43,660
network functionality to roll it out on

00:11:41,200 --> 00:11:47,710
your lab and then in your production

00:11:43,660 --> 00:11:50,130
environment you can simply add a new

00:11:47,710 --> 00:11:54,340
feature in the B switch and try it out

00:11:50,130 --> 00:11:57,340
and what's nice about it is that you can

00:11:54,340 --> 00:11:59,350
even be on a machine that is not

00:11:57,340 --> 00:12:01,450
connected to any other machine and you

00:11:59,350 --> 00:12:08,680
can still you do all your stuff

00:12:01,450 --> 00:12:13,420
with VMs one of the biggest challenges

00:12:08,680 --> 00:12:16,150
that are faced by the nav infrastructure

00:12:13,420 --> 00:12:19,720
in general is the very different

00:12:16,150 --> 00:12:23,890
requirements that are present in the

00:12:19,720 --> 00:12:26,860
different in the different sectors in of

00:12:23,890 --> 00:12:30,880
the industry for example on this on this

00:12:26,860 --> 00:12:32,770
slide I pick T requirements from an

00:12:30,880 --> 00:12:37,000
enterprise data center versus a telco

00:12:32,770 --> 00:12:38,500
provider so if you think about it in an

00:12:37,000 --> 00:12:40,600
enterprise data center most of the

00:12:38,500 --> 00:12:44,460
traffic is even these days just Stang

00:12:40,600 --> 00:12:49,390
gigabit while telco networks have

00:12:44,460 --> 00:12:51,250
40-plus gigabit network requirements if

00:12:49,390 --> 00:12:55,060
you think about the packet sizes which

00:12:51,250 --> 00:12:57,490
are really did the frames that are sent

00:12:55,060 --> 00:13:01,300
by by the machines and handled by the

00:12:57,490 --> 00:13:03,190
machines on in a data center in a data

00:13:01,300 --> 00:13:07,150
center you would expect this traffic to

00:13:03,190 --> 00:13:12,730
be a mixed type of traffic imagine there

00:13:07,150 --> 00:13:17,860
are queries coming for for webpages my

00:13:12,730 --> 00:13:21,810
sequel queries Oracle queries interim

00:13:17,860 --> 00:13:24,820
machine machine learning type of stuff

00:13:21,810 --> 00:13:28,360
while the telco network has to deal with

00:13:24,820 --> 00:13:30,190
a lot of control packets and control

00:13:28,360 --> 00:13:31,990
packets are usually very very small

00:13:30,190 --> 00:13:34,990
packets we're talking about 64 bytes

00:13:31,990 --> 00:13:39,240
back at 96 bytes packet the average

00:13:34,990 --> 00:13:39,240
being 72 or 74

00:13:40,240 --> 00:13:48,770
obviously another another requirement is

00:13:44,210 --> 00:13:52,220
the expectation of the customers in

00:13:48,770 --> 00:13:54,110
these two different domains so an

00:13:52,220 --> 00:13:56,150
enterprise data center really wants to

00:13:54,110 --> 00:13:59,720
to get the software out of the box

00:13:56,150 --> 00:14:02,660
install it and and just run with it a

00:13:59,720 --> 00:14:05,960
telco network instead usually focus a

00:14:02,660 --> 00:14:08,870
lot on customization because that's how

00:14:05,960 --> 00:14:11,120
they differentiate between another

00:14:08,870 --> 00:14:14,960
provider they can offer you one thing

00:14:11,120 --> 00:14:17,060
versus another feature so they customize

00:14:14,960 --> 00:14:22,400
products a lot and they spend a lot of

00:14:17,060 --> 00:14:24,350
time and money in doing that with

00:14:22,400 --> 00:14:26,570
regards to performance here I'm using

00:14:24,350 --> 00:14:31,400
the word nun for the enterprise data

00:14:26,570 --> 00:14:35,300
centers as a sort of the more the better

00:14:31,400 --> 00:14:38,030
right on the other hand the detail

00:14:35,300 --> 00:14:41,510
providers have very strict requirements

00:14:38,030 --> 00:14:44,750
on for example things like latency and

00:14:41,510 --> 00:14:47,480
jitter those requirements are not coming

00:14:44,750 --> 00:14:49,280
just out of the box they're they're

00:14:47,480 --> 00:14:53,050
coming from standards

00:14:49,280 --> 00:14:56,780
so if implement for example a 3G network

00:14:53,050 --> 00:14:59,420
you have specific requirements if you

00:14:56,780 --> 00:15:03,380
have a 4G network you have much stricter

00:14:59,420 --> 00:15:08,300
requirements and now with 5g things are

00:15:03,380 --> 00:15:11,860
going just crazy so it's very hard to to

00:15:08,300 --> 00:15:15,860
pick one solution that can fit all these

00:15:11,860 --> 00:15:18,110
usually they're tailored solutions and

00:15:15,860 --> 00:15:20,210
people need to really know exactly what

00:15:18,110 --> 00:15:25,160
they can achieve with each sub component

00:15:20,210 --> 00:15:27,050
in order to meet the requirements so as

00:15:25,160 --> 00:15:29,120
I said the beginning in this

00:15:27,050 --> 00:15:31,880
presentation I'm going to focus mainly

00:15:29,120 --> 00:15:35,840
on two piece which is one is the open V

00:15:31,880 --> 00:15:37,430
switch and the other one is the VPP on

00:15:35,840 --> 00:15:39,920
the open V switch side I'm going to be

00:15:37,430 --> 00:15:43,460
much quicker because we have another

00:15:39,920 --> 00:15:45,140
presentation later on today that I

00:15:43,460 --> 00:15:48,360
actually courage you to attend is about

00:15:45,140 --> 00:15:52,490
obvious and the PDK integration

00:15:48,360 --> 00:15:52,490
and it's a little bit more on the VPP

00:15:52,520 --> 00:15:59,010
what's interesting about these two

00:15:54,600 --> 00:16:02,790
projects they can they can run and use

00:15:59,010 --> 00:16:05,700
the standard kernel parte communication

00:16:02,790 --> 00:16:10,220
for handling packets so standard socket

00:16:05,700 --> 00:16:13,140
based but they can also integrate with

00:16:10,220 --> 00:16:16,350
DP DK which stands for data plane

00:16:13,140 --> 00:16:20,100
development kit and is the cutting edge

00:16:16,350 --> 00:16:26,730
in the open source for for packet

00:16:20,100 --> 00:16:30,810
handling and packet processing so what

00:16:26,730 --> 00:16:33,120
is open pit switch which elevated is

00:16:30,810 --> 00:16:35,250
obvious so it's a software-based

00:16:33,120 --> 00:16:38,220
solution as I said earlier it is a bit

00:16:35,250 --> 00:16:40,220
switch so it's softer and offers a

00:16:38,220 --> 00:16:44,220
flexible controller in userspace

00:16:40,220 --> 00:16:46,320
where we actually see a daemon running

00:16:44,220 --> 00:16:48,980
and you have all the nice tools that you

00:16:46,320 --> 00:16:53,370
can use to basically instruct the switch

00:16:48,980 --> 00:16:57,180
with specific flows for example and it

00:16:53,370 --> 00:16:57,660
has what's called the fast data path in

00:16:57,180 --> 00:16:59,670
userspace

00:16:57,660 --> 00:17:02,910
as I said I'm going to talk about the

00:16:59,670 --> 00:17:05,339
obvious DP DK if it was this standard

00:17:02,910 --> 00:17:09,329
obvious this data path is actually

00:17:05,339 --> 00:17:11,010
implemented within the kernel it also

00:17:09,329 --> 00:17:14,220
provides an implementation of open flow

00:17:11,010 --> 00:17:16,380
so if you want to use open flow to to

00:17:14,220 --> 00:17:19,140
configure and instruct your your

00:17:16,380 --> 00:17:22,439
pictures which you can do so and it's a

00:17:19,140 --> 00:17:25,110
based on Apache 2 license so just

00:17:22,439 --> 00:17:29,130
because I said to you that there are two

00:17:25,110 --> 00:17:31,560
incarnations of OBS I think this picture

00:17:29,130 --> 00:17:33,750
is quite nice a lot it basically shows

00:17:31,560 --> 00:17:36,450
you how the two differs between it

00:17:33,750 --> 00:17:40,860
between them on the left-hand side there

00:17:36,450 --> 00:17:42,900
is the OBS standard version which is the

00:17:40,860 --> 00:17:44,760
one using the kernel and on the right

00:17:42,900 --> 00:17:47,100
hand side there is the one that

00:17:44,760 --> 00:17:50,300
basically integrates with the data plane

00:17:47,100 --> 00:17:52,980
development kit so on the left hand side

00:17:50,300 --> 00:17:54,450
there is another component which is a

00:17:52,980 --> 00:17:56,960
kernel module which is called open V

00:17:54,450 --> 00:17:59,370
switch Tokyo that runs in the kernel and

00:17:56,960 --> 00:18:05,280
communicates with the user space

00:17:59,370 --> 00:18:07,440
through a net link infrastructure what

00:18:05,280 --> 00:18:09,840
happens is that the data plane is

00:18:07,440 --> 00:18:12,240
handled in the kernel and any exceptions

00:18:09,840 --> 00:18:16,020
to this data plane which means basically

00:18:12,240 --> 00:18:19,350
a flow that is not learned or a flow

00:18:16,020 --> 00:18:22,440
that is not configured a packet that

00:18:19,350 --> 00:18:26,430
basically missed it will will be sent to

00:18:22,440 --> 00:18:28,620
user space where a demon will Endel this

00:18:26,430 --> 00:18:31,590
packet to basically either be configured

00:18:28,620 --> 00:18:35,360
or discarded on the right-hand side

00:18:31,590 --> 00:18:38,370
instead the kernel module disappears and

00:18:35,360 --> 00:18:41,040
and all you have is a very small

00:18:38,370 --> 00:18:44,280
interface which is offered by either the

00:18:41,040 --> 00:18:48,390
IG bui yo yo yo kisi a generic or DVF

00:18:44,280 --> 00:18:51,450
iup CI kernel module to expose the

00:18:48,390 --> 00:18:52,980
network cards bars to the drivers that

00:18:51,450 --> 00:18:54,300
are actually running in user space and

00:18:52,980 --> 00:18:59,850
these drivers are called

00:18:54,300 --> 00:19:03,510
pull mode drivers the the name is coming

00:18:59,850 --> 00:19:05,550
because all these drivers are not usual

00:19:03,510 --> 00:19:09,420
drivers that are driven by interrupt but

00:19:05,550 --> 00:19:14,690
the instead they keep poling the NIC for

00:19:09,420 --> 00:19:17,880
packets coming in and in this case the

00:19:14,690 --> 00:19:19,980
forwarding plane it's sitting in user

00:19:17,880 --> 00:19:25,890
space itself so everything runs in user

00:19:19,980 --> 00:19:29,640
space the way that obvious works is can

00:19:25,890 --> 00:19:32,580
can run in two different modes called

00:19:29,640 --> 00:19:34,860
normal and flow based the normal mode

00:19:32,580 --> 00:19:39,320
basically act as a standard layer to

00:19:34,860 --> 00:19:42,120
switch what basically does is it puts

00:19:39,320 --> 00:19:44,400
the network on the network card in

00:19:42,120 --> 00:19:53,160
learning mode so it can learn new flows

00:19:44,400 --> 00:19:56,940
coming in and it forwards the frames to

00:19:53,160 --> 00:19:58,320
the previously learned eMac or basically

00:19:56,940 --> 00:19:59,790
can also flow the frame the frame

00:19:58,320 --> 00:20:03,510
depending on the compression that you

00:19:59,790 --> 00:20:05,910
said it if you set it to flow mode

00:20:03,510 --> 00:20:07,410
instead all of a sudden you see your

00:20:05,910 --> 00:20:10,020
piece which behaving as a sort of

00:20:07,410 --> 00:20:13,170
firewall as well because anything that

00:20:10,020 --> 00:20:16,680
is not being configured on the V switch

00:20:13,170 --> 00:20:20,460
it's basically dropped so you will have

00:20:16,680 --> 00:20:21,570
to have flows in your flow table to

00:20:20,460 --> 00:20:26,010
low-traffic

00:20:21,570 --> 00:20:28,850
through your piece which and since I

00:20:26,010 --> 00:20:31,580
mentioned the the concept of flow table

00:20:28,850 --> 00:20:35,610
what the flow table is is that it's a

00:20:31,580 --> 00:20:40,740
literally a table and it's composed by a

00:20:35,610 --> 00:20:45,390
match and an action part a match is

00:20:40,740 --> 00:20:47,520
basically allowing you to to specify the

00:20:45,390 --> 00:20:51,420
fields on the packet that you want to

00:20:47,520 --> 00:20:53,460
match against imagine it could be the

00:20:51,420 --> 00:20:55,500
source mark the DMACC it could be a

00:20:53,460 --> 00:20:59,220
source IP destination IP you can pretty

00:20:55,500 --> 00:21:04,140
much match on whatever you want in the

00:20:59,220 --> 00:21:08,850
packet and when a packet comes in it

00:21:04,140 --> 00:21:12,510
goes through this flow table and when a

00:21:08,850 --> 00:21:14,910
match is found we call it hit and the

00:21:12,510 --> 00:21:16,260
action according to this match will be

00:21:14,910 --> 00:21:18,930
performed so you can have for example

00:21:16,260 --> 00:21:20,340
forward which means that packet will be

00:21:18,930 --> 00:21:23,850
forwarded to

00:21:20,340 --> 00:21:26,570
for example the MAC address

00:21:23,850 --> 00:21:29,760
[Music]

00:21:26,570 --> 00:21:33,300
interestingly you can you can also use

00:21:29,760 --> 00:21:37,080
wildcards for for the matches which

00:21:33,300 --> 00:21:39,690
basically allows the user to simplify

00:21:37,080 --> 00:21:43,200
some use cases for example many cases

00:21:39,690 --> 00:21:47,070
you don't care about source port or a

00:21:43,200 --> 00:21:49,290
source Mac might be relevant or not so

00:21:47,070 --> 00:21:51,600
you can wild-card those in order to

00:21:49,290 --> 00:21:54,530
reduce the number of flows that you have

00:21:51,600 --> 00:21:54,530
in your flow table

00:21:57,830 --> 00:22:07,360
any questions you can interrupt me

00:21:59,149 --> 00:22:11,110
anytime on the other end we have V P P

00:22:07,360 --> 00:22:14,960
VP P stands for vector packet processing

00:22:11,110 --> 00:22:18,620
and it's as the word says is opposed to

00:22:14,960 --> 00:22:22,309
the concept of as color processing is an

00:22:18,620 --> 00:22:25,760
extensible framework that it that offers

00:22:22,309 --> 00:22:28,490
really production quality for switch

00:22:25,760 --> 00:22:32,080
router functionality the reason why is

00:22:28,490 --> 00:22:35,480
production qualities that PPP comes from

00:22:32,080 --> 00:22:38,889
many years of learning and developing of

00:22:35,480 --> 00:22:41,510
cisco who basically donated this

00:22:38,889 --> 00:22:43,130
software component to the open-source

00:22:41,510 --> 00:22:47,659
community

00:22:43,130 --> 00:22:50,510
18 months ago and they've actually used

00:22:47,659 --> 00:22:53,440
it in many many years on their products

00:22:50,510 --> 00:22:59,690
so it's pretty stable and being

00:22:53,440 --> 00:23:03,470
production tested VPP is part of the

00:22:59,690 --> 00:23:07,010
bigger project called fido which is

00:23:03,470 --> 00:23:16,220
written FD dot io and it's all set by

00:23:07,010 --> 00:23:19,580
the linux foundation one of the one of

00:23:16,220 --> 00:23:23,000
the differences of VPP compared to

00:23:19,580 --> 00:23:25,429
obvious is that obvious as I said

00:23:23,000 --> 00:23:29,529
implements a flow table and each packet

00:23:25,429 --> 00:23:31,730
will go through this flow table and

00:23:29,529 --> 00:23:34,460
obviously you are going to have a

00:23:31,730 --> 00:23:36,769
performance heat because of that because

00:23:34,460 --> 00:23:39,440
depending on where your flow sits in the

00:23:36,769 --> 00:23:43,340
flow table you'll be quicker or slower

00:23:39,440 --> 00:23:45,230
to find your match if you have thousands

00:23:43,340 --> 00:23:49,010
of entries in your flow table your

00:23:45,230 --> 00:23:50,929
pocket will go through through it and it

00:23:49,010 --> 00:23:55,149
could basically reach the the bottom

00:23:50,929 --> 00:23:55,149
part before being processed

00:23:55,380 --> 00:24:02,520
on the other end VPP what it does is in

00:23:58,590 --> 00:24:05,640
is implementing a graph and not only

00:24:02,520 --> 00:24:08,100
that but it's also processing packets in

00:24:05,640 --> 00:24:10,320
a vector-based mode what that means is

00:24:08,100 --> 00:24:12,630
that instead of having each single

00:24:10,320 --> 00:24:15,470
packet that comes from the NIC going

00:24:12,630 --> 00:24:20,460
through the graph at two a one by one

00:24:15,470 --> 00:24:23,730
they own the whole lot of packets in a

00:24:20,460 --> 00:24:27,990
vector mode will be processed by each

00:24:23,730 --> 00:24:32,040
node on the graph you may think that

00:24:27,990 --> 00:24:35,430
it's basically the same thing it's

00:24:32,040 --> 00:24:39,300
actually not and is also different from

00:24:35,430 --> 00:24:42,690
the concept of polling from the NIC in

00:24:39,300 --> 00:24:45,860
part in in in batch mode this is real

00:24:42,690 --> 00:24:48,990
data plane processing what happens is

00:24:45,860 --> 00:24:53,190
that because it's being handled as a

00:24:48,990 --> 00:24:56,190
vector we're going we are seeing less

00:24:53,190 --> 00:24:59,250
instruction cache misses less data cache

00:24:56,190 --> 00:25:03,480
misses there is a real optimization in

00:24:59,250 --> 00:25:07,230
terms of cache utilization and actually

00:25:03,480 --> 00:25:11,660
all this helps boosting the performance

00:25:07,230 --> 00:25:17,220
of your of your appliance of your server

00:25:11,660 --> 00:25:21,660
really really considerably it's also

00:25:17,220 --> 00:25:24,180
very flexible because if you need to to

00:25:21,660 --> 00:25:28,380
add a new functionality you don't have

00:25:24,180 --> 00:25:31,110
to know all the details of the overall

00:25:28,380 --> 00:25:34,170
design and over the overall code which

00:25:31,110 --> 00:25:38,090
trust me is quite a bit of code base but

00:25:34,170 --> 00:25:43,550
what you can do you can create a new

00:25:38,090 --> 00:25:46,530
node which in the VPP word is a plugin

00:25:43,550 --> 00:25:49,680
so you write your new code following the

00:25:46,530 --> 00:25:52,770
plug-in interface you implement it and

00:25:49,680 --> 00:25:55,620
you can plug it in a specific part of

00:25:52,770 --> 00:26:00,090
the graph where you require it to be so

00:25:55,620 --> 00:26:03,110
it's very flexible and it's it's quite

00:26:00,090 --> 00:26:07,050
developer friendly

00:26:03,110 --> 00:26:11,790
there are many use cases in the BPP

00:26:07,050 --> 00:26:15,030
world the the first one is the victors

00:26:11,790 --> 00:26:18,450
virtual router what happens is that

00:26:15,030 --> 00:26:22,190
together with with the library sets that

00:26:18,450 --> 00:26:26,280
you get with the with VPP you also get a

00:26:22,190 --> 00:26:30,080
CLI and this is the CLI allows you to

00:26:26,280 --> 00:26:33,060
basically run through the command line

00:26:30,080 --> 00:26:35,280
the configuration required to to

00:26:33,060 --> 00:26:41,880
basically set up a virtual switch or or

00:26:35,280 --> 00:26:44,540
or a router and in literally five or six

00:26:41,880 --> 00:26:48,720
different commands that you run between

00:26:44,540 --> 00:26:53,640
the Linux part and the VPP specific part

00:26:48,720 --> 00:26:56,580
you have a V switch going on between two

00:26:53,640 --> 00:27:00,690
endpoints being them built on machines

00:26:56,580 --> 00:27:04,140
or being them containers it's very very

00:27:00,690 --> 00:27:09,960
straightforward and easy at the same

00:27:04,140 --> 00:27:12,390
time VPP offers both local and remote

00:27:09,960 --> 00:27:17,190
programmability and the way they do it

00:27:12,390 --> 00:27:20,970
is to to basically have their set of API

00:27:17,190 --> 00:27:23,490
on top of their on top of their code

00:27:20,970 --> 00:27:26,100
they do not support things like open

00:27:23,490 --> 00:27:28,680
flow so you have to stick with the apt

00:27:26,100 --> 00:27:33,270
api that they give you the interesting

00:27:28,680 --> 00:27:35,880
thing is the API available are for a

00:27:33,270 --> 00:27:42,150
really big set of programming languages

00:27:35,880 --> 00:27:43,680
you can use C C++ Java Python Lua so you

00:27:42,150 --> 00:27:45,950
can basically pick the language you

00:27:43,680 --> 00:27:51,540
prefer and they all have the same

00:27:45,950 --> 00:27:54,720
interface it also offers remote

00:27:51,540 --> 00:27:57,050
programmability basically you can

00:27:54,720 --> 00:28:00,630
imagine you would like to integrate your

00:27:57,050 --> 00:28:02,610
visuals with your vista router with

00:28:00,630 --> 00:28:06,690
things like open the light for example

00:28:02,610 --> 00:28:08,770
which is a the SDN controller the factor

00:28:06,690 --> 00:28:12,010
these days

00:28:08,770 --> 00:28:15,160
and it offers a specific interface and

00:28:12,010 --> 00:28:18,700
it offers also currently available

00:28:15,160 --> 00:28:27,250
projects that allow you to control VPP

00:28:18,700 --> 00:28:32,410
through open the light okay I think

00:28:27,250 --> 00:28:34,570
recently enough six eight months it also

00:28:32,410 --> 00:28:36,550
integrates directly with OpenStack

00:28:34,570 --> 00:28:41,200
through the ml to plugin magazine

00:28:36,550 --> 00:28:43,840
mechanism driver the only thing is the

00:28:41,200 --> 00:28:47,380
code is not part of VPP you'll have to

00:28:43,840 --> 00:28:53,080
to pull it from from github from the

00:28:47,380 --> 00:28:55,300
OpenStack github and in this way you can

00:28:53,080 --> 00:28:59,320
basically skip the overhead of

00:28:55,300 --> 00:29:00,850
integrating VPP with odl and and then

00:28:59,320 --> 00:29:03,220
odl with OpenStack

00:29:00,850 --> 00:29:06,460
you could go straight directly talking

00:29:03,220 --> 00:29:14,950
OpenStack to VPP in a similar way as

00:29:06,460 --> 00:29:19,210
it's possible for obvious so as I said

00:29:14,950 --> 00:29:22,750
that earlier VPP is a high-performance

00:29:19,210 --> 00:29:24,250
user space network stack and the

00:29:22,750 --> 00:29:27,910
interesting bit is that you can run on

00:29:24,250 --> 00:29:30,370
commodity order so similar and this is

00:29:27,910 --> 00:29:33,490
very similar to obvious you can pick an

00:29:30,370 --> 00:29:37,090
x86 machine whatever it is you can

00:29:33,490 --> 00:29:38,830
install Linux and then install VPP that

00:29:37,090 --> 00:29:41,230
will run obviously can expect different

00:29:38,830 --> 00:29:45,250
type of performance based on the machine

00:29:41,230 --> 00:29:49,030
that you're deploying it on the same

00:29:45,250 --> 00:29:52,480
code can run on the host or in VMs or

00:29:49,030 --> 00:29:55,810
Linux containers in fact as I said it's

00:29:52,480 --> 00:29:59,710
very very easy also thanks to the to the

00:29:55,810 --> 00:30:03,630
nice abstractions done by the API to set

00:29:59,710 --> 00:30:07,560
up the same type of of setup scenario

00:30:03,630 --> 00:30:11,580
whether being using VMs for

00:30:07,560 --> 00:30:11,580
communications or containers

00:30:12,720 --> 00:30:22,830
it as I said it basically integrates

00:30:18,870 --> 00:30:25,320
with TP DK which is currently the best

00:30:22,830 --> 00:30:28,590
of the breed open-source driver

00:30:25,320 --> 00:30:33,350
technology for packet processing and is

00:30:28,590 --> 00:30:39,950
extensible using the plugins interface

00:30:33,350 --> 00:30:44,670
and yeah that's pretty much it

00:30:39,950 --> 00:30:49,200
so if we think about the the differences

00:30:44,670 --> 00:30:55,170
or if we put them side-by-side because

00:30:49,200 --> 00:30:57,540
they use D PDK they have already a lot

00:30:55,170 --> 00:30:59,820
of commonalities in terms of what you

00:30:57,540 --> 00:31:04,050
require on your platform to make this

00:30:59,820 --> 00:31:07,290
run so for example you will have to

00:31:04,050 --> 00:31:10,400
enable the huge page support whether

00:31:07,290 --> 00:31:13,560
being a two megabyte or one gigabyte

00:31:10,400 --> 00:31:20,210
pages you will have to use one or the

00:31:13,560 --> 00:31:24,870
other you will have to enable the iommu

00:31:20,210 --> 00:31:26,250
which which if you want to better

00:31:24,870 --> 00:31:29,610
performance you can set it up as a

00:31:26,250 --> 00:31:31,500
pass-through mode this is why you need

00:31:29,610 --> 00:31:34,560
the Intel ahem MB option is to enable

00:31:31,500 --> 00:31:36,570
SRO V on your system and obviously you

00:31:34,560 --> 00:31:44,190
will think you will need things like BTX

00:31:36,570 --> 00:31:47,760
vtd enabled in the bias what else well

00:31:44,190 --> 00:31:51,360
both this which you will require you to

00:31:47,760 --> 00:31:55,320
basically pick a specific driver whether

00:31:51,360 --> 00:31:58,470
being a GPIO European PCL generic or BFA

00:31:55,320 --> 00:32:01,140
your PCI and basically bind your NIC to

00:31:58,470 --> 00:32:03,840
those drivers which then Avenger will be

00:32:01,140 --> 00:32:07,820
used by the polymer drivers in the PDK

00:32:03,840 --> 00:32:07,820
to take the packets out of the NIC

00:32:09,790 --> 00:32:15,260
instead if we think about the design if

00:32:14,030 --> 00:32:18,770
we look at the architecture and the

00:32:15,260 --> 00:32:22,190
design of the two different components

00:32:18,770 --> 00:32:24,440
two different software they look very

00:32:22,190 --> 00:32:28,760
differently in fact we can talk about

00:32:24,440 --> 00:32:30,530
apples and oranges the open V switch as

00:32:28,760 --> 00:32:35,390
I said earlier it's based on a match

00:32:30,530 --> 00:32:38,060
action type of approach while VPP is

00:32:35,390 --> 00:32:42,200
based on vector packet processing using

00:32:38,060 --> 00:32:44,720
a graph the the open piece which has

00:32:42,200 --> 00:32:49,760
this concept of the fast path versus the

00:32:44,720 --> 00:32:52,700
slow path instead VPP is more focused on

00:32:49,760 --> 00:32:55,720
the extensibility of the functionality

00:32:52,700 --> 00:32:55,720
via plugins

00:32:56,680 --> 00:33:04,180
similarly VPP has always been taught and

00:33:01,010 --> 00:33:08,390
design with a high level of parallelism

00:33:04,180 --> 00:33:11,120
and as I said it doesn't really think

00:33:08,390 --> 00:33:13,010
about integration with controllers per

00:33:11,120 --> 00:33:16,640
se like Sdn controllers it doesn't not

00:33:13,010 --> 00:33:19,520
implement open flow as I said while

00:33:16,640 --> 00:33:22,640
obvious has been more focusing on the

00:33:19,520 --> 00:33:25,130
northbound part of of the stack thinking

00:33:22,640 --> 00:33:28,820
about things like open flow integration

00:33:25,130 --> 00:33:31,520
and and they also support the OBS DB

00:33:28,820 --> 00:33:34,340
which is another protocol which allows

00:33:31,520 --> 00:33:39,740
you to basically configure the DB switch

00:33:34,340 --> 00:33:43,130
itself I'm not going through these slide

00:33:39,740 --> 00:33:45,890
in details it's more if you download it

00:33:43,130 --> 00:33:50,090
you can you can actually see it they are

00:33:45,890 --> 00:33:52,160
all very much features rich they offer

00:33:50,090 --> 00:33:56,830
pretty much the same type of

00:33:52,160 --> 00:34:02,300
functionality in one flavor or the other

00:33:56,830 --> 00:34:05,660
something that just I just learned two

00:34:02,300 --> 00:34:08,409
months ago is a with the in VPP there's

00:34:05,660 --> 00:34:10,210
going to be very soon a full TCP stack

00:34:08,409 --> 00:34:14,570
implemented in userspace

00:34:10,210 --> 00:34:16,429
and that's going to open up a lot of

00:34:14,570 --> 00:34:18,800
more scenarios and more things to be

00:34:16,429 --> 00:34:22,000
done with it which is going to be very

00:34:18,800 --> 00:34:22,000
interesting to be seen

00:34:22,300 --> 00:34:29,060
with regards to the to the integration

00:34:25,909 --> 00:34:34,000
bit how these two components talk to

00:34:29,060 --> 00:34:38,600
other components in the much bigger nav

00:34:34,000 --> 00:34:40,760
orchestration architecture well as I

00:34:38,600 --> 00:34:43,490
said the open V switch allows to

00:34:40,760 --> 00:34:46,220
basically speak many languages a lot it

00:34:43,490 --> 00:34:50,120
allows the support of open flow supports

00:34:46,220 --> 00:34:53,240
OBS DB and it has a straight integration

00:34:50,120 --> 00:34:57,890
with the ml tube mechanism driver in

00:34:53,240 --> 00:35:00,080
OpenStack VPP is also now the the

00:34:57,890 --> 00:35:04,480
integration with OpenStack directly to

00:35:00,080 --> 00:35:08,840
the ml to plug in ml to driver mechanism

00:35:04,480 --> 00:35:14,000
however I'm not aware of being used and

00:35:08,840 --> 00:35:16,700
deployed happily while they did they

00:35:14,000 --> 00:35:18,760
distinct a little bit more and emphasize

00:35:16,700 --> 00:35:24,290
more on the open delight integration

00:35:18,760 --> 00:35:27,170
with own account and whether being a

00:35:24,290 --> 00:35:33,950
positive thing or not it does not

00:35:27,170 --> 00:35:37,490
support open flow so as I said I just

00:35:33,950 --> 00:35:41,390
wanted to also touch base a little bit

00:35:37,490 --> 00:35:43,550
on the platform awareness there's a lot

00:35:41,390 --> 00:35:47,480
on ongoing with ardor in general and

00:35:43,550 --> 00:35:50,300
what you can do with it so one thing

00:35:47,480 --> 00:35:53,330
that I would like to stress is because

00:35:50,300 --> 00:35:55,130
these two words acceleration and

00:35:53,330 --> 00:35:59,420
offloads are very often used

00:35:55,130 --> 00:36:00,170
interchangeably they actually mean two

00:35:59,420 --> 00:36:02,210
different things

00:36:00,170 --> 00:36:03,800
when you think about what you do with

00:36:02,210 --> 00:36:07,520
your art drawing or with your software

00:36:03,800 --> 00:36:10,040
so the acceleration is to take advantage

00:36:07,520 --> 00:36:12,920
of either techniques or methodologies

00:36:10,040 --> 00:36:15,590
which allow you to to improve any aspect

00:36:12,920 --> 00:36:19,030
of the performance of your software

00:36:15,590 --> 00:36:24,170
stack being throughput latency

00:36:19,030 --> 00:36:26,930
scalability the offload instead what we

00:36:24,170 --> 00:36:30,430
mean is to defer to a third party

00:36:26,930 --> 00:36:32,140
component which is usually harder

00:36:30,430 --> 00:36:34,960
the full execution of a given

00:36:32,140 --> 00:36:37,170
functionality you can imagine for

00:36:34,960 --> 00:36:40,420
example taking advantage of a hardware

00:36:37,170 --> 00:36:42,970
capability to do checksum and that's

00:36:40,420 --> 00:36:46,900
pretty much never by default on every

00:36:42,970 --> 00:36:51,100
single network card driver or TSO for

00:36:46,900 --> 00:36:54,610
TCP segmentation offload or recently VX

00:36:51,100 --> 00:36:57,940
lon ink up the cap whether being state

00:36:54,610 --> 00:36:59,350
fuller stateless many network cards

00:36:57,940 --> 00:37:01,570
these days offer that functionality as

00:36:59,350 --> 00:37:04,230
well but what that means is that

00:37:01,570 --> 00:37:07,540
software has nothing to do with that

00:37:04,230 --> 00:37:10,210
execution it just tells the artwork to

00:37:07,540 --> 00:37:13,390
take care of it and usually the software

00:37:10,210 --> 00:37:16,890
stack just gets a callback to be told

00:37:13,390 --> 00:37:20,440
what the result of that execution was

00:37:16,890 --> 00:37:25,000
another important aspect just because

00:37:20,440 --> 00:37:28,090
more and more these architecture is is

00:37:25,000 --> 00:37:32,130
present these days is a is Numa which

00:37:28,090 --> 00:37:32,130
stands for non-uniform memory access

00:37:32,220 --> 00:37:37,360
what what this is is that basically

00:37:34,570 --> 00:37:39,430
these days most of the servers using

00:37:37,360 --> 00:37:41,410
data centers that are made of blades and

00:37:39,430 --> 00:37:44,800
those blades can talk to each other

00:37:41,410 --> 00:37:47,350
through a backplane and eventually

00:37:44,800 --> 00:37:51,460
anyway your OS is deployed on the

00:37:47,350 --> 00:37:55,480
overall machine so your eyes now can see

00:37:51,460 --> 00:37:59,350
the different nodes which old PC already

00:37:55,480 --> 00:38:01,480
have multiple cores and four Weber's

00:37:59,350 --> 00:38:04,320
done multi-threading programming is

00:38:01,480 --> 00:38:07,540
already aware of what multi-threading

00:38:04,320 --> 00:38:10,750
problems are and if you scale it up to

00:38:07,540 --> 00:38:13,630
an uma platform then it means that you

00:38:10,750 --> 00:38:16,420
will also have to to take care of and

00:38:13,630 --> 00:38:19,690
know where those cores with those

00:38:16,420 --> 00:38:21,790
threads are running because if you for

00:38:19,690 --> 00:38:24,610
example start crossing the interconnect

00:38:21,790 --> 00:38:28,180
bus which on Intel is called qpi you

00:38:24,610 --> 00:38:31,660
will start paying down latency your

00:38:28,180 --> 00:38:34,920
throughput will decrease and obviously

00:38:31,660 --> 00:38:37,420
your system doesn't work as expected so

00:38:34,920 --> 00:38:40,120
being aware of for example where your

00:38:37,420 --> 00:38:41,860
PCI and where your memory is plugged

00:38:40,120 --> 00:38:43,220
onto and where your software is running

00:38:41,860 --> 00:38:47,660
on which node

00:38:43,220 --> 00:38:49,970
which course and now it communicates

00:38:47,660 --> 00:38:54,619
with other processes on different course

00:38:49,970 --> 00:38:58,160
is very very important I think in this

00:38:54,619 --> 00:39:01,060
regards a very good tool that we that we

00:38:58,160 --> 00:39:03,380
have on on Linux is the Numa CTL tool

00:39:01,060 --> 00:39:06,830
which very easily can show you the

00:39:03,380 --> 00:39:09,920
topology of your of your infrastructure

00:39:06,830 --> 00:39:12,050
of your machine can basically show which

00:39:09,920 --> 00:39:14,450
are the course numbered on which nodes

00:39:12,050 --> 00:39:19,609
how much memory is actually attached to

00:39:14,450 --> 00:39:23,410
each node and which node is handling

00:39:19,609 --> 00:39:26,090
which PCI devices because in some cases

00:39:23,410 --> 00:39:32,000
the PCI connectivity is specific to

00:39:26,090 --> 00:39:33,470
specific nodes so if you if you can see

00:39:32,000 --> 00:39:37,760
this on the right hand side there is an

00:39:33,470 --> 00:39:40,040
example of of a Numa CTL which shows on

00:39:37,760 --> 00:39:42,980
the machine that I was using for

00:39:40,040 --> 00:39:49,550
different nodes it's quite a powerful

00:39:42,980 --> 00:39:52,040
machine and on each node 24 cores and it

00:39:49,550 --> 00:39:57,080
also shows at the end the topology of it

00:39:52,040 --> 00:39:59,780
so basically highlighting what is the

00:39:57,080 --> 00:40:02,030
gap between each node and obviously

00:39:59,780 --> 00:40:03,800
because it's a matrix you would expect

00:40:02,030 --> 00:40:06,170
the diagonal of the matrix to be

00:40:03,800 --> 00:40:09,580
constant because it refers to the same

00:40:06,170 --> 00:40:13,700
node and all the rest with an increased

00:40:09,580 --> 00:40:17,420
cost and in fact if you can see it the

00:40:13,700 --> 00:40:19,400
diagonal there is shown as 10 meaning

00:40:17,420 --> 00:40:23,690
that from node 1 to node 1 I'm actually

00:40:19,400 --> 00:40:26,540
paying nothing and then I would pay 21

00:40:23,690 --> 00:40:30,080
so more than double the cost to reach

00:40:26,540 --> 00:40:33,770
from node 1 to node 2 and the rationale

00:40:30,080 --> 00:40:36,369
is that I'm going through a bus that

00:40:33,770 --> 00:40:41,510
connects the two nodes

00:40:36,369 --> 00:40:45,470
another aspect is related to the arturis

00:40:41,510 --> 00:40:47,960
systems and hardware accelerations for

00:40:45,470 --> 00:40:50,260
Network ads specifically now before I

00:40:47,960 --> 00:40:54,260
can actually talk about the to

00:40:50,260 --> 00:40:57,260
acceleration techniques let me tell you

00:40:54,260 --> 00:41:00,470
how it works in on the basics so when

00:40:57,260 --> 00:41:02,660
you have your hyper visor and it's

00:41:00,470 --> 00:41:05,359
visualizing your NIC which basically

00:41:02,660 --> 00:41:09,109
takes packets from another excuse and

00:41:05,359 --> 00:41:12,200
send packets to a txq that hypervisor

00:41:09,109 --> 00:41:15,609
has to do two very basic and fundamental

00:41:12,200 --> 00:41:19,309
things one is sorting the packets and

00:41:15,609 --> 00:41:21,980
the other one is routing the packets so

00:41:19,309 --> 00:41:23,990
in order to to send the packets to the

00:41:21,980 --> 00:41:27,589
right VM what it does is basically

00:41:23,990 --> 00:41:31,640
taking a decisions on an L to days which

00:41:27,589 --> 00:41:37,099
is similar to whatever as which does in

00:41:31,640 --> 00:41:40,369
the first case instead of acceleration

00:41:37,099 --> 00:41:43,549
technique which is called BM DQ is

00:41:40,369 --> 00:41:46,700
basically taking advantage of built or

00:41:43,549 --> 00:41:50,930
cues available on the erect side and on

00:41:46,700 --> 00:41:55,549
the TX side so that these queues can be

00:41:50,930 --> 00:41:58,579
directly mapped to a specific BM you may

00:41:55,549 --> 00:42:02,900
think that is very similar concept but

00:41:58,579 --> 00:42:05,660
is not because what these queues are

00:42:02,900 --> 00:42:08,119
connected with is also with IR queues

00:42:05,660 --> 00:42:10,490
and what you can do is that you can map

00:42:08,119 --> 00:42:14,119
IR queues to be handled by specific

00:42:10,490 --> 00:42:17,240
course and by pinning specific air cues

00:42:14,119 --> 00:42:18,950
to specific calls you basically reducing

00:42:17,240 --> 00:42:21,910
the amount of contacts which an overhead

00:42:18,950 --> 00:42:25,069
of other course doing other things

00:42:21,910 --> 00:42:27,200
instead they're focusing exactly on the

00:42:25,069 --> 00:42:29,980
particular traffic that is going to hit

00:42:27,200 --> 00:42:29,980
your BM

00:42:30,100 --> 00:42:37,040
[Music]

00:42:32,140 --> 00:42:39,850
the only issue although this was the did

00:42:37,040 --> 00:42:42,800
the first version of this acceleration

00:42:39,850 --> 00:42:47,240
there is still one bit missing here to

00:42:42,800 --> 00:42:50,660
make it better in fact in this scenario

00:42:47,240 --> 00:42:53,630
the I per visor still has to do the last

00:42:50,660 --> 00:42:57,950
memory copy of the packets coming from

00:42:53,630 --> 00:43:00,800
the visual cues to the VM or from the VM

00:42:57,950 --> 00:43:05,320
to the T excuse in case of a ascend

00:43:00,800 --> 00:43:09,290
traffic and and that problem is actually

00:43:05,320 --> 00:43:13,340
solved by the other technique which is

00:43:09,290 --> 00:43:15,680
called SRO V with Estrella V we are not

00:43:13,340 --> 00:43:18,500
talking about visual queues anymore we

00:43:15,680 --> 00:43:20,420
are talking about virtual functions is a

00:43:18,500 --> 00:43:21,830
much more advanced way of basically

00:43:20,420 --> 00:43:24,680
dealing with your network card that

00:43:21,830 --> 00:43:27,050
offers barriers between digital

00:43:24,680 --> 00:43:31,010
functions and all the security goes with

00:43:27,050 --> 00:43:32,960
it but if we stick with the with the

00:43:31,010 --> 00:43:36,680
problem associated with memory copies

00:43:32,960 --> 00:43:38,570
then there is no need now for the upper

00:43:36,680 --> 00:43:40,930
visor to perform the memory the last

00:43:38,570 --> 00:43:44,960
memory copy or the first memory copy

00:43:40,930 --> 00:43:48,380
anymore because the visual function is

00:43:44,960 --> 00:43:51,020
directly mapped into the VM memory space

00:43:48,380 --> 00:43:55,070
is already is directly managed by a

00:43:51,020 --> 00:43:58,730
specific driver which is a slightly

00:43:55,070 --> 00:44:02,930
different version of the network driver

00:43:58,730 --> 00:44:07,130
that you would use on the host and what

00:44:02,930 --> 00:44:09,800
allows used to basically deal with in

00:44:07,130 --> 00:44:14,150
network card driver with the network

00:44:09,800 --> 00:44:16,370
card itself directly from a VM so the

00:44:14,150 --> 00:44:19,570
upper voice is completely bypassed it

00:44:16,370 --> 00:44:19,570
does not take care of it anymore

00:44:20,099 --> 00:44:26,130
there are some caveats obviously around

00:44:23,430 --> 00:44:30,569
the use of s array of in not all good

00:44:26,130 --> 00:44:33,539
things come for free depending on which

00:44:30,569 --> 00:44:38,160
network card you use you may or may not

00:44:33,539 --> 00:44:40,460
have Seop functionalities usually all

00:44:38,160 --> 00:44:43,380
the very expensive network cards have it

00:44:40,460 --> 00:44:46,460
similarly there is a limit to the amount

00:44:43,380 --> 00:44:50,549
of virtual functions that you can have I

00:44:46,460 --> 00:44:53,460
think the the one that has the most

00:44:50,549 --> 00:44:55,410
disease has 64 digit of functions

00:44:53,460 --> 00:44:59,400
available which means that you can have

00:44:55,410 --> 00:45:02,729
on one single Ethernet port 64 built

00:44:59,400 --> 00:45:07,200
role devices but not more than that so

00:45:02,729 --> 00:45:10,289
if you want to to have a 60 v vm then

00:45:07,200 --> 00:45:12,239
you cannot or that vm cannot talk on the

00:45:10,289 --> 00:45:18,089
network card or you have to find

00:45:12,239 --> 00:45:18,509
different ways and with this I'm open to

00:45:18,089 --> 00:45:22,099
questions

00:45:18,509 --> 00:45:22,099
if you have any and you're still alive

00:45:26,509 --> 00:45:37,619
you mentioned the yeah so you mentioned

00:45:34,829 --> 00:45:44,279
that VPP has DP DK support

00:45:37,619 --> 00:45:48,029
what about ODP or the B also has an

00:45:44,279 --> 00:45:49,739
integration with DB DK right so it still

00:45:48,029 --> 00:45:57,089
go through DB DK you wouldn't be talking

00:45:49,739 --> 00:46:00,569
VPP direct to ADP come again so so what

00:45:57,089 --> 00:46:03,089
you've got the VPP interface DB DK

00:46:00,569 --> 00:46:05,039
there's no interface to a DP you'd still

00:46:03,089 --> 00:46:06,749
go through DVD case then gets ready P

00:46:05,039 --> 00:46:11,989
yes right yes

00:46:06,749 --> 00:46:11,989
there's no VPP ODP yeah type of scenario

00:46:18,360 --> 00:46:23,090
if no more questions thank you

00:46:25,670 --> 00:46:30,860

YouTube URL: https://www.youtube.com/watch?v=wRqZMHncPV8


