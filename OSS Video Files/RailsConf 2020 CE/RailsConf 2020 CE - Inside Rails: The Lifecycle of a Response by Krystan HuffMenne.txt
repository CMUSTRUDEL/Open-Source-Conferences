Title: RailsConf 2020 CE - Inside Rails: The Lifecycle of a Response by Krystan HuffMenne
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Inside Rails: The Lifecycle of a Response by Krystan HuffMenne

This breathtaking documentary series combines rare action, unimaginable scale, impossible locations and intimate moments captured from the deepest depths of Rails internals. Last year, we followed the lifecycle of best loved, wildest and most elusive Rails components through a request, from the browser to a controller action. This year, our journey takes us across the great text/plain, following the flow of HTTP streams, taking in the spectacular Action View as we find our way back to the browser. Join us to unearth the amazing lifecycle of a Rails response.

__________

Krystan HuffMenne is an engineer at Tilde, where she works on Skylight, the smart Rails profiler. She writes code in Ruby, JavaScript, and Instant Pot. Sheâ€™s a Florida-native living in Portland, OR with her husband and two kids.
Captions: 
	00:00:09,000 --> 00:00:14,980
hello railsconf I'm Kristen Huffman II

00:00:11,950 --> 00:00:17,490
joining you from Portland Oregon home of

00:00:14,980 --> 00:00:20,380
Powell's Books voodoo donuts and

00:00:17,490 --> 00:00:23,710
skylight the smart performance profiler

00:00:20,380 --> 00:00:25,119
for Ruby on Rails applications last year

00:00:23,710 --> 00:00:27,730
the skylight team gave a talk called

00:00:25,119 --> 00:00:30,400
inside rails the lifecycle of a request

00:00:27,730 --> 00:00:32,739
in that talk we covered everything that

00:00:30,400 --> 00:00:35,170
happens between typing a URL into your

00:00:32,739 --> 00:00:37,900
browser to a request reaching your rails

00:00:35,170 --> 00:00:40,150
controller action but that talk ended

00:00:37,900 --> 00:00:41,320
with a cliffhanger once we are in the

00:00:40,150 --> 00:00:43,210
controller action

00:00:41,320 --> 00:00:47,320
how does rail send a response back to

00:00:43,210 --> 00:00:49,089
the browser together these two talks

00:00:47,320 --> 00:00:51,400
will paint a complete picture of the

00:00:49,089 --> 00:00:53,890
browser request response cycle the

00:00:51,400 --> 00:00:56,229
foundation that the whole field of web

00:00:53,890 --> 00:00:58,180
development is built on but don't worry

00:00:56,229 --> 00:01:00,519
you don't need to have seen not talk to

00:00:58,180 --> 00:01:03,030
understand this one we'll start with a

00:01:00,519 --> 00:01:06,250
little recap of the important concepts

00:01:03,030 --> 00:01:08,530
buckle up because we are headed on the

00:01:06,250 --> 00:01:10,979
safari into the life cycle of the

00:01:08,530 --> 00:01:10,979
response

00:01:11,350 --> 00:01:14,890
inside rails

00:01:17,080 --> 00:01:25,060
and life cycle first let's get into our

00:01:22,120 --> 00:01:29,530
Safari Jeep and head on over to skylight

00:01:25,060 --> 00:01:35,670
dot io / Safari when we visit this page

00:01:29,530 --> 00:01:39,340
we should see hello world ok let's go oh

00:01:35,670 --> 00:01:42,310
no it appears that our Safari server has

00:01:39,340 --> 00:01:46,030
been overtaken by Lions instead of hello

00:01:42,310 --> 00:01:46,720
world we see roar savanna how did this

00:01:46,030 --> 00:01:49,960
happen

00:01:46,720 --> 00:01:52,600
let's find out first we need to answer

00:01:49,960 --> 00:01:54,790
this question when our browser connects

00:01:52,600 --> 00:01:57,910
to a server how does the server know

00:01:54,790 --> 00:01:59,740
what the browser is asking for the

00:01:57,910 --> 00:02:02,500
browser and the server have to agree on

00:01:59,740 --> 00:02:03,820
a language for speaking to each other so

00:02:02,500 --> 00:02:06,820
that they can understand what one

00:02:03,820 --> 00:02:10,899
another is asking for this set of rules

00:02:06,820 --> 00:02:13,630
is called HTTP it stands for hypertext

00:02:10,899 --> 00:02:16,030
Transfer Protocol which is the language

00:02:13,630 --> 00:02:18,910
that both browsers and web servers can

00:02:16,030 --> 00:02:22,780
understand protocol is just a fancy word

00:02:18,910 --> 00:02:25,209
for a set of rules let's try it we can

00:02:22,780 --> 00:02:28,260
use a program called telnet to open a

00:02:25,209 --> 00:02:32,470
connection to the skylight Safari server

00:02:28,260 --> 00:02:34,660
to get skylight io / Safari here is the

00:02:32,470 --> 00:02:37,209
simplest request we could make it

00:02:34,660 --> 00:02:40,690
specifies that it is a get request for

00:02:37,209 --> 00:02:44,050
the path / Safari using the HTTP

00:02:40,690 --> 00:02:47,830
protocol call version 1.1 and it is for

00:02:44,050 --> 00:02:49,900
the host skylight io and the HTTP

00:02:47,830 --> 00:02:52,780
compliant response from the server looks

00:02:49,900 --> 00:02:55,360
something like this it specifies that

00:02:52,780 --> 00:02:57,730
the request was successful gives a bunch

00:02:55,360 --> 00:03:00,790
of header information like content type

00:02:57,730 --> 00:03:03,760
content length and date and finally roar

00:03:00,790 --> 00:03:05,680
savanna the response body but what

00:03:03,760 --> 00:03:08,800
happened in between sending this request

00:03:05,680 --> 00:03:10,810
and receiving the response the request

00:03:08,800 --> 00:03:14,350
descent from the browser through the

00:03:10,810 --> 00:03:17,290
interwebs to our web server then another

00:03:14,350 --> 00:03:19,540
protocol kicks in the rack protocol is a

00:03:17,290 --> 00:03:22,840
set of rules for how to translate an

00:03:19,540 --> 00:03:25,030
HTTP compliant request into a format

00:03:22,840 --> 00:03:28,690
that a rack compliant ruby app like

00:03:25,030 --> 00:03:29,800
rails can understand the web server such

00:03:28,690 --> 00:03:34,810
as puma

00:03:29,800 --> 00:03:37,650
or unicorn interprets the HTTP request

00:03:34,810 --> 00:03:40,480
and parses it into an environment hash

00:03:37,650 --> 00:03:43,720
the web server then calls your rails app

00:03:40,480 --> 00:03:45,850
with this hash rails receives the

00:03:43,720 --> 00:03:48,700
environment hash passes it through a

00:03:45,850 --> 00:03:51,490
series of middleware and into your

00:03:48,700 --> 00:03:53,770
controller action in the Safari

00:03:51,490 --> 00:03:54,700
controller the Lions about an action

00:03:53,770 --> 00:03:57,040
called hello

00:03:54,700 --> 00:04:00,490
that tells rails to render a plaintext

00:03:57,040 --> 00:04:03,100
response that says roar savanah rails

00:04:00,490 --> 00:04:05,110
runs your controller code passes it back

00:04:03,100 --> 00:04:08,140
through all of that middleware then

00:04:05,110 --> 00:04:12,160
returns an array of three things the

00:04:08,140 --> 00:04:15,160
status code a hash of headers and the

00:04:12,160 --> 00:04:18,730
response body we'll call this the

00:04:15,160 --> 00:04:21,280
response array the rack compliant web

00:04:18,730 --> 00:04:23,890
server receives this array converts it

00:04:21,280 --> 00:04:26,320
into an HTTP compliant plaintext

00:04:23,890 --> 00:04:27,990
response and sends it on its merry way

00:04:26,320 --> 00:04:33,100
back to your browser

00:04:27,990 --> 00:04:34,690
roarsome bana easy-peasy right but how

00:04:33,100 --> 00:04:37,000
did rails know what to put in this array

00:04:34,690 --> 00:04:39,370
and how does the browser know what to do

00:04:37,000 --> 00:04:42,970
with this response that's where this

00:04:39,370 --> 00:04:46,200
year's talk comes in the first item in

00:04:42,970 --> 00:04:48,820
the response array is the status code

00:04:46,200 --> 00:04:51,340
simply put the status code is a

00:04:48,820 --> 00:04:55,080
three-digit number indicating if the

00:04:51,340 --> 00:04:57,940
request was successful or not and why

00:04:55,080 --> 00:05:01,419
status codes are separated into five

00:04:57,940 --> 00:05:03,310
classes one-hundredths informational

00:05:01,419 --> 00:05:09,100
these are pretty rare so we won't go

00:05:03,310 --> 00:05:13,900
into more detail 200s success 300s

00:05:09,100 --> 00:05:16,300
redirection 400s client error for errors

00:05:13,900 --> 00:05:20,350
originating on the client that made the

00:05:16,300 --> 00:05:23,860
request and 500s server error for errors

00:05:20,350 --> 00:05:26,020
originating on the server standardized

00:05:23,860 --> 00:05:27,730
status code help clients make sense of

00:05:26,020 --> 00:05:29,650
the response even if they can't read

00:05:27,730 --> 00:05:33,820
English or whatever human language the

00:05:29,650 --> 00:05:36,490
response body was written in this allows

00:05:33,820 --> 00:05:39,100
the browser for example to display the

00:05:36,490 --> 00:05:43,050
appropriate UI elements to the user or

00:05:39,100 --> 00:05:45,690
in development tools status codes also

00:05:43,050 --> 00:05:48,629
tell the Google crawler what to do for

00:05:45,690 --> 00:05:52,050
example pages responding with 500 errors

00:05:48,629 --> 00:05:55,050
will be revisited later and pages

00:05:52,050 --> 00:05:59,159
responding with 200 ok status codes will

00:05:55,050 --> 00:06:01,139
be indexed for these reasons we want to

00:05:59,159 --> 00:06:05,520
be as precise as possible when choosing

00:06:01,139 --> 00:06:07,669
a status code the simplest responses are

00:06:05,520 --> 00:06:10,530
the ones that require no response body

00:06:07,669 --> 00:06:12,720
even better we can tell the browser not

00:06:10,530 --> 00:06:15,330
to even expect a response body by

00:06:12,720 --> 00:06:17,849
choosing the correct status code for

00:06:15,330 --> 00:06:21,719
example let's say our safari controller

00:06:17,849 --> 00:06:23,940
has an e hippo action the action allows

00:06:21,719 --> 00:06:28,199
the current user to consume the hippo as

00:06:23,940 --> 00:06:31,259
long as they are a lion then it responds

00:06:28,199 --> 00:06:33,240
with a simple 204 which means the server

00:06:31,259 --> 00:06:35,550
has successfully fulfilled the request

00:06:33,240 --> 00:06:38,789
and there is no additional content to

00:06:35,550 --> 00:06:41,460
send in the response body in Safari

00:06:38,789 --> 00:06:43,560
speak that's the lion successfully ate

00:06:41,460 --> 00:06:49,979
the hippo and we can expect the hippo to

00:06:43,560 --> 00:06:52,169
have no body in rails the head method is

00:06:49,979 --> 00:06:55,560
shorthand for respond only with this

00:06:52,169 --> 00:06:58,110
status headers and an empty body the

00:06:55,560 --> 00:07:01,380
head method takes a symbol corresponding

00:06:58,110 --> 00:07:05,250
to a status in this case no content for

00:07:01,380 --> 00:07:09,479
204 another common set of status codes

00:07:05,250 --> 00:07:11,639
is the 300 series redirects for example

00:07:09,479 --> 00:07:14,849
if we send a get request to skylight

00:07:11,639 --> 00:07:17,729
Daioh slash bind hippo the fine hippo

00:07:14,849 --> 00:07:19,379
action redirects us to the Oasis URL

00:07:17,729 --> 00:07:23,430
because it's the dry season and the

00:07:19,379 --> 00:07:25,650
hippos have moved to find water the

00:07:23,430 --> 00:07:28,889
rails redirect to method responds with a

00:07:25,650 --> 00:07:30,870
302 found status by default and includes

00:07:28,889 --> 00:07:33,389
a location header more on headers to

00:07:30,870 --> 00:07:37,169
come with the URL to which the browser

00:07:33,389 --> 00:07:40,020
should redirect this status tells the

00:07:37,169 --> 00:07:43,440
browser the hippo temporarily resides in

00:07:40,020 --> 00:07:45,360
the Oasis URL sometimes the hippo

00:07:43,440 --> 00:07:49,050
resides elsewhere so always check this

00:07:45,360 --> 00:07:51,570
location first but let's say the hippo

00:07:49,050 --> 00:07:54,960
has moved in the oasis permanently maybe

00:07:51,570 --> 00:07:56,370
because of global warming in this case

00:07:54,960 --> 00:07:59,250
we could pass

00:07:56,370 --> 00:08:02,820
is to redirect to the moved permanently

00:07:59,250 --> 00:08:05,669
symbol corresponds with a 301 status

00:08:02,820 --> 00:08:08,160
code this says to the browser the hippo

00:08:05,669 --> 00:08:09,600
has moved permanently to the Oasis so

00:08:08,160 --> 00:08:12,930
whenever you are looking for the hippo

00:08:09,600 --> 00:08:15,270
look in the Oasis the next time you try

00:08:12,930 --> 00:08:17,760
to visit the hippo at slash find hippo

00:08:15,270 --> 00:08:20,340
your browser can automatically visit

00:08:17,760 --> 00:08:22,440
slash Oasis instead without having to

00:08:20,340 --> 00:08:25,830
make the extra request to slash find

00:08:22,440 --> 00:08:27,900
hippo alternatively we could add the

00:08:25,830 --> 00:08:30,990
following to our routes file and remove

00:08:27,900 --> 00:08:33,089
the controller action altogether the

00:08:30,990 --> 00:08:36,930
redirect helper in the router responds

00:08:33,089 --> 00:08:38,430
with a 301 as well there is one

00:08:36,930 --> 00:08:40,710
important thing to note about the

00:08:38,430 --> 00:08:42,779
redirect to method the controller

00:08:40,710 --> 00:08:45,089
continues to execute the code in the

00:08:42,779 --> 00:08:48,540
action even after you've called redirect

00:08:45,089 --> 00:08:51,420
to for example take a look at this

00:08:48,540 --> 00:08:53,940
version of the find hippo action once

00:08:51,420 --> 00:08:56,430
again we redirect to the Oasis URL if

00:08:53,940 --> 00:08:58,320
it's the dry season we only want to

00:08:56,430 --> 00:09:01,020
render the hippo here if it's the rainy

00:08:58,320 --> 00:09:05,250
season we'll just visit the endpoint to

00:09:01,020 --> 00:09:07,140
see it in action and oops because we

00:09:05,250 --> 00:09:09,720
didn't return when we called redirect -

00:09:07,140 --> 00:09:12,150
we actually hit both the redirect and

00:09:09,720 --> 00:09:15,570
render so rails doesn't know which

00:09:12,150 --> 00:09:18,560
response to respond with a 301 or a 200

00:09:15,570 --> 00:09:24,180
rails will throw a double render error

00:09:18,560 --> 00:09:26,430
and fixed by moving the redirect to into

00:09:24,180 --> 00:09:29,010
a before action we can ensure that

00:09:26,430 --> 00:09:32,150
render doesn't also get called because

00:09:29,010 --> 00:09:36,990
now we skip our entire controller action

00:09:32,150 --> 00:09:39,510
okay let's move on status codes are a

00:09:36,990 --> 00:09:42,390
very concise way of conveying important

00:09:39,510 --> 00:09:44,160
information to the browser but often we

00:09:42,390 --> 00:09:46,140
need to include additional instructions

00:09:44,160 --> 00:09:50,250
to the browser about how to handle our

00:09:46,140 --> 00:09:52,140
response enter headers headers are

00:09:50,250 --> 00:09:54,720
simply additional information about the

00:09:52,140 --> 00:09:56,490
response this information might provide

00:09:54,720 --> 00:09:58,440
directions for the browser such as

00:09:56,490 --> 00:10:01,170
weather and for how long to cache the

00:09:58,440 --> 00:10:03,380
response or it might provide metadata

00:10:01,170 --> 00:10:06,870
it's used in a JavaScript client app

00:10:03,380 --> 00:10:08,870
headers are included in in a hash as the

00:10:06,870 --> 00:10:11,170
second item and the response array

00:10:08,870 --> 00:10:13,910
our rails app returns to the web server

00:10:11,170 --> 00:10:16,160
we already talked about the location

00:10:13,910 --> 00:10:18,560
header which is used by the browser to

00:10:16,160 --> 00:10:20,240
know where it should redirect to here

00:10:18,560 --> 00:10:23,480
are some other common headers you might

00:10:20,240 --> 00:10:25,460
see in a rails app the content type

00:10:23,480 --> 00:10:27,440
response header tells the browser what

00:10:25,460 --> 00:10:31,010
the content type of returned content

00:10:27,440 --> 00:10:33,080
actually is for example an image an HTML

00:10:31,010 --> 00:10:36,230
document or just plain and formatted

00:10:33,080 --> 00:10:38,120
text the browser checks this in order to

00:10:36,230 --> 00:10:41,779
know how to display the response in the

00:10:38,120 --> 00:10:43,460
UI the content length header tells the

00:10:41,779 --> 00:10:46,760
browser the length and bytes of the

00:10:43,460 --> 00:10:48,380
response for example you might send a

00:10:46,760 --> 00:10:51,410
head request to an endpoint that

00:10:48,380 --> 00:10:53,180
endpoint can respond with head ok and a

00:10:51,410 --> 00:10:56,360
Content length so you can see how many

00:10:53,180 --> 00:10:58,130
bytes its response would be in order to

00:10:56,360 --> 00:11:00,440
generate a download percentage for

00:10:58,130 --> 00:11:03,110
example without having to wait for the

00:11:00,440 --> 00:11:05,200
entire body to download thus and gauging

00:11:03,110 --> 00:11:08,000
the usefulness of a download percentage

00:11:05,200 --> 00:11:10,900
this header is set automatically by the

00:11:08,000 --> 00:11:13,700
rack content length middle where the

00:11:10,900 --> 00:11:16,339
set-cookie header includes a semi colon

00:11:13,700 --> 00:11:17,990
separated key value string representing

00:11:16,339 --> 00:11:21,320
the cookies shared between the server

00:11:17,990 --> 00:11:23,300
and the browser for example rails sets a

00:11:21,320 --> 00:11:26,300
cookie to track a user's requests across

00:11:23,300 --> 00:11:30,220
a session cookies and rails are managed

00:11:26,300 --> 00:11:33,020
by a class called no joke the cookie jar

00:11:30,220 --> 00:11:36,709
these headers and many more are managed

00:11:33,020 --> 00:11:41,650
automatically by rails you can also set

00:11:36,709 --> 00:11:41,650
a header manually using response headers

00:11:42,760 --> 00:11:49,430
headers can be used to give the browser

00:11:45,220 --> 00:11:51,380
directions about caching HTTP caching is

00:11:49,430 --> 00:11:55,089
when your browser or a proxy of the

00:11:51,380 --> 00:11:57,620
browser stores an entire HTTP response

00:11:55,089 --> 00:11:59,690
the next time you make a request to that

00:11:57,620 --> 00:12:03,020
endpoint the response can be showing you

00:11:59,690 --> 00:12:05,029
more quickly caching behavior varies

00:12:03,020 --> 00:12:07,310
depending on the status code returned in

00:12:05,029 --> 00:12:09,700
the response with just yet another

00:12:07,310 --> 00:12:12,620
reason that status codes are important

00:12:09,700 --> 00:12:14,900
the main header used to control caching

00:12:12,620 --> 00:12:18,050
behavior is not surprisingly called the

00:12:14,900 --> 00:12:22,160
cache control header let's look at some

00:12:18,050 --> 00:12:25,819
examples here's our find hippo action

00:12:22,160 --> 00:12:27,529
it finds a hippo and renders it the code

00:12:25,819 --> 00:12:31,430
is very simple and yet we're

00:12:27,529 --> 00:12:33,740
experiencing some performance issues it

00:12:31,430 --> 00:12:36,290
turns out that hippos are big and

00:12:33,740 --> 00:12:38,930
difficult to render so maybe we should

00:12:36,290 --> 00:12:43,730
just render the hippo once then cache it

00:12:38,930 --> 00:12:44,420
forever HTTP cache forever allows us to

00:12:43,730 --> 00:12:47,029
do this

00:12:44,420 --> 00:12:49,819
it sets the cache control headers

00:12:47,029 --> 00:12:51,889
max-age directive to three billion one

00:12:49,819 --> 00:12:53,839
hundred and fifty five million six

00:12:51,889 --> 00:12:56,629
hundred and ninety five thousand and two

00:12:53,839 --> 00:12:59,870
hundred seconds for one century which is

00:12:56,629 --> 00:13:02,300
basically forever in computer years it

00:12:59,870 --> 00:13:04,040
also sets the private directive which

00:13:02,300 --> 00:13:07,129
tells the browser and all browser

00:13:04,040 --> 00:13:09,560
proxies along the way that this is a

00:13:07,129 --> 00:13:10,040
private hippo and she would prefer to be

00:13:09,560 --> 00:13:12,199
cached

00:13:10,040 --> 00:13:15,319
only by this users browser and not by a

00:13:12,199 --> 00:13:17,180
shared cache the private directive means

00:13:15,319 --> 00:13:19,879
only the account owner should have

00:13:17,180 --> 00:13:21,829
access to the response the browser can

00:13:19,879 --> 00:13:23,480
cache it but a cache between your server

00:13:21,829 --> 00:13:26,649
and the client such as a content

00:13:23,480 --> 00:13:29,420
distribution network or CDN should not

00:13:26,649 --> 00:13:32,420
if we want to allow caching by shared

00:13:29,420 --> 00:13:35,149
caches we can just packs public true to

00:13:32,420 --> 00:13:36,829
HTTP cache forever to tell browser

00:13:35,149 --> 00:13:38,779
proxies that we are okay with them

00:13:36,829 --> 00:13:45,290
caching the hippo responds along the way

00:13:38,779 --> 00:13:47,180
to the browser and it's public for

00:13:45,290 --> 00:13:49,579
another example of indefinite caching

00:13:47,180 --> 00:13:52,130
let's include a picture of our hippo in

00:13:49,579 --> 00:13:54,709
the template when we visit the page and

00:13:52,130 --> 00:13:56,689
look at the image source we notice that

00:13:54,709 --> 00:14:00,170
rails didn't just serve up the image at

00:13:56,689 --> 00:14:02,300
slash assets slash hippo dot PNG instead

00:14:00,170 --> 00:14:06,230
it served the image at slash assets

00:14:02,300 --> 00:14:10,189
slash hippo - gobbledygook dot PNG what

00:14:06,230 --> 00:14:12,290
is that about when the server serves our

00:14:10,189 --> 00:14:15,519
image it sets the cache control header

00:14:12,290 --> 00:14:18,050
to the equivalent of HTTP cache forever

00:14:15,519 --> 00:14:20,569
browsers and browser proxies like the

00:14:18,050 --> 00:14:23,629
CDN I mentioned before will cache that

00:14:20,569 --> 00:14:26,240
hippo pick forever but what if we change

00:14:23,629 --> 00:14:27,949
the picture how our users access the

00:14:26,240 --> 00:14:29,230
most up-to-date hippo pics on the

00:14:27,949 --> 00:14:32,589
interwebs

00:14:29,230 --> 00:14:35,029
the answer is fingerprinting the

00:14:32,589 --> 00:14:35,960
gobbledygook is actually the images

00:14:35,029 --> 00:14:38,900
fingerprint

00:14:35,960 --> 00:14:41,240
print and it's generated every time the

00:14:38,900 --> 00:14:44,600
rails asset pipeline compiles the image

00:14:41,240 --> 00:14:47,210
based on the content of the image if the

00:14:44,600 --> 00:14:49,970
image changes the fingerprint linked in

00:14:47,210 --> 00:14:52,310
the HTML changes and instead of showing

00:14:49,970 --> 00:14:54,410
the user the cached hippo pic the

00:14:52,310 --> 00:14:56,020
browser will retrieve the new version of

00:14:54,410 --> 00:15:00,260
the image

00:14:56,020 --> 00:15:02,630
okay back to response caching was it

00:15:00,260 --> 00:15:06,200
really smart to cache the entire hippo

00:15:02,630 --> 00:15:08,000
forever it was only live about 40 years

00:15:06,200 --> 00:15:08,660
and surely they changed throughout their

00:15:08,000 --> 00:15:10,940
lives

00:15:08,660 --> 00:15:14,570
maybe we should only cache the hippo for

00:15:10,940 --> 00:15:17,120
an hour expires in sets the cache

00:15:14,570 --> 00:15:18,970
control headers match max age directed

00:15:17,120 --> 00:15:22,070
to the given amount of time

00:15:18,970 --> 00:15:26,690
now our browser will reload the hippo if

00:15:22,070 --> 00:15:28,220
we visit the page after an hour but how

00:15:26,690 --> 00:15:31,880
do we know the hippo won't change within

00:15:28,220 --> 00:15:34,250
that hour this is hard to guarantee it

00:15:31,880 --> 00:15:36,560
sure would be nice if we could ask the

00:15:34,250 --> 00:15:39,440
server if the hippo has changed and only

00:15:36,560 --> 00:15:43,070
used like use the cache if the hippo has

00:15:39,440 --> 00:15:47,060
not changed well I have good news for

00:15:43,070 --> 00:15:49,640
you this is the default behavior with no

00:15:47,060 --> 00:15:52,330
caching specific code whatsoever the

00:15:49,640 --> 00:15:55,490
cache control header looks like this

00:15:52,330 --> 00:15:57,860
rails adds the must revalidate directive

00:15:55,490 --> 00:16:00,650
to the cache control header this means

00:15:57,860 --> 00:16:02,660
the browser should revalidate the cached

00:16:00,650 --> 00:16:06,740
response before displaying it to the

00:16:02,660 --> 00:16:09,530
user rails also sets the max age

00:16:06,740 --> 00:16:11,480
directive to zero seconds meaning that

00:16:09,530 --> 00:16:15,170
the cached response should immediately

00:16:11,480 --> 00:16:17,600
be considered stale together these

00:16:15,170 --> 00:16:19,820
directives tell the browser to always

00:16:17,600 --> 00:16:23,450
revalidate the cached response before

00:16:19,820 --> 00:16:29,180
displaying it so how does this rivality

00:16:23,450 --> 00:16:32,090
ssin work the first time we visited the

00:16:29,180 --> 00:16:33,710
slash blind hippo endpoint rails ran our

00:16:32,090 --> 00:16:35,900
code to create the response body

00:16:33,710 --> 00:16:40,130
including doing all that work to find

00:16:35,900 --> 00:16:41,810
and render the hippo before rails passes

00:16:40,130 --> 00:16:45,350
the body along to your server a

00:16:41,810 --> 00:16:48,440
middleware called rack etag digests the

00:16:45,350 --> 00:16:50,630
response body into a unique and to do

00:16:48,440 --> 00:16:54,440
similar to the asset fingerprints we

00:16:50,630 --> 00:16:56,360
talked about before rocky tag then sets

00:16:54,440 --> 00:16:59,870
the e-tag response header with this

00:16:56,360 --> 00:17:03,140
entity tag a browser caches this

00:16:59,870 --> 00:17:05,089
response including the headers when we

00:17:03,140 --> 00:17:07,370
visit this page again our browser

00:17:05,089 --> 00:17:10,160
notices that the cached response is

00:17:07,370 --> 00:17:13,699
stale with a max age of zero and that

00:17:10,160 --> 00:17:15,640
we've requested that it revalidate so

00:17:13,699 --> 00:17:18,949
when our browser sends the get request

00:17:15,640 --> 00:17:21,110
it includes the entity tag associated

00:17:18,949 --> 00:17:23,870
with the cached response back to the

00:17:21,110 --> 00:17:27,620
server via the if none match request

00:17:23,870 --> 00:17:30,170
header the server again runs our code to

00:17:27,620 --> 00:17:32,210
create the response body including doing

00:17:30,170 --> 00:17:35,870
all the work to find and render the

00:17:32,210 --> 00:17:39,830
hippo again then it passes the body

00:17:35,870 --> 00:17:43,220
along to Rack Attack again and again

00:17:39,830 --> 00:17:46,730
rack etag digests the response body into

00:17:43,220 --> 00:17:48,220
the unique entity tag and sets the e-tag

00:17:46,730 --> 00:17:51,080
response header

00:17:48,220 --> 00:17:54,050
now the next middleware in the chain

00:17:51,080 --> 00:17:56,690
rack conditional get checks if the new e

00:17:54,050 --> 00:17:59,210
tag header max matches the entity tag

00:17:56,690 --> 00:18:03,320
sent along by the if none match request

00:17:59,210 --> 00:18:06,110
header if they match rack conditional

00:18:03,320 --> 00:18:09,679
gap will replace the status with a 304

00:18:06,110 --> 00:18:11,419
not modified and discard the body the

00:18:09,679 --> 00:18:14,300
browser doesn't need to wait to download

00:18:11,419 --> 00:18:16,160
the redundant body and the 304 status

00:18:14,300 --> 00:18:19,880
tells the browser to just use the cached

00:18:16,160 --> 00:18:22,370
response instead if the new e tag does

00:18:19,880 --> 00:18:24,169
not match the server just sends the full

00:18:22,370 --> 00:18:27,440
response along with the original status

00:18:24,169 --> 00:18:34,429
code the browser will now render a fresh

00:18:27,440 --> 00:18:36,440
hippo it seems like the server is doing

00:18:34,429 --> 00:18:39,010
a lot of work rendering an entire hippo

00:18:36,440 --> 00:18:41,750
just to generate and compare etags

00:18:39,010 --> 00:18:43,610
if we know that the only reason that the

00:18:41,750 --> 00:18:46,100
response body is changing is because the

00:18:43,610 --> 00:18:51,080
hippo herself is changing surely there's

00:18:46,100 --> 00:18:53,390
a better way enter the stale method now

00:18:51,080 --> 00:18:56,510
our action says to render the hippo only

00:18:53,390 --> 00:18:58,250
if she is stale we still get the same

00:18:56,510 --> 00:19:00,380
caching headers as we did with the

00:18:58,250 --> 00:19:01,310
default action but the e tag is

00:19:00,380 --> 00:19:04,190
different even

00:19:01,310 --> 00:19:07,940
our response body is identical what

00:19:04,190 --> 00:19:09,830
changed here the sale method tells rails

00:19:07,940 --> 00:19:14,060
not to bother rendering the entire

00:19:09,830 --> 00:19:15,890
response body to build the e-tag instead

00:19:14,060 --> 00:19:17,810
just check if the hippo herself has

00:19:15,890 --> 00:19:21,230
changed and build the e-tag based on

00:19:17,810 --> 00:19:23,360
that under the hood rails just generates

00:19:21,230 --> 00:19:26,720
a string based on a combination of the

00:19:23,360 --> 00:19:30,160
model name ID and updated that then runs

00:19:26,720 --> 00:19:32,900
that through the e-tag digest algorithm

00:19:30,160 --> 00:19:35,240
this saves the server all of the effort

00:19:32,900 --> 00:19:39,170
of rendering the entire body just to

00:19:35,240 --> 00:19:41,330
generate the e-tag and finally what if

00:19:39,170 --> 00:19:45,320
the hippo is so private that she never

00:19:41,330 --> 00:19:47,330
ever wants to be cached weirdly rails

00:19:45,320 --> 00:19:49,160
doesn't yet have a built in method to do

00:19:47,330 --> 00:19:52,310
this so you have to set the cache

00:19:49,160 --> 00:19:54,770
control header directly the no store

00:19:52,310 --> 00:19:57,320
directive says that the response may not

00:19:54,770 --> 00:20:00,220
be stored in any cache be it their

00:19:57,320 --> 00:20:03,020
browser or any proxies along the way

00:20:00,220 --> 00:20:05,660
this is not to be confused with the

00:20:03,020 --> 00:20:07,580
poorly named no cache directive which

00:20:05,660 --> 00:20:10,070
despite its name means that the response

00:20:07,580 --> 00:20:11,660
can be stored in any cache but the

00:20:10,070 --> 00:20:16,040
stored response must be revalidated

00:20:11,660 --> 00:20:17,840
every time before it can be used now

00:20:16,040 --> 00:20:19,460
that we've used the status code and

00:20:17,840 --> 00:20:21,920
headers to communicate to the browser

00:20:19,460 --> 00:20:23,750
what to do with our response we should

00:20:21,920 --> 00:20:28,010
probably talk about the most important

00:20:23,750 --> 00:20:30,880
part of many responses the body the body

00:20:28,010 --> 00:20:34,010
is the final part of the response array

00:20:30,880 --> 00:20:37,880
it is a string representing the actual

00:20:34,010 --> 00:20:40,310
information the user has requested when

00:20:37,880 --> 00:20:42,950
we make our request to slash find hippo

00:20:40,310 --> 00:20:45,470
how does rails convert the code we wrote

00:20:42,950 --> 00:20:49,460
in our controller and view into an HTML

00:20:45,470 --> 00:20:53,450
page about a specific hippo let's find

00:20:49,460 --> 00:20:56,270
out when we visit slash find hippo in

00:20:53,450 --> 00:20:59,630
the browser our rails app serves up an

00:20:56,270 --> 00:21:01,820
HTML response we can verify this by

00:20:59,630 --> 00:21:05,000
looking at the content type response

00:21:01,820 --> 00:21:08,870
header but how did rails know to respond

00:21:05,000 --> 00:21:11,780
with HTML rails looks first at any

00:21:08,870 --> 00:21:14,850
explicitly requested file extensions for

00:21:11,780 --> 00:21:17,429
example slash bind hippo HTML

00:21:14,850 --> 00:21:19,289
if none is provided which is the case

00:21:17,429 --> 00:21:21,750
with the request we made to slash find

00:21:19,289 --> 00:21:25,259
hit bail then it looks at the accept

00:21:21,750 --> 00:21:28,200
request header our Safari browser

00:21:25,259 --> 00:21:31,139
defaults this accept request header to

00:21:28,200 --> 00:21:33,720
text slash HTML indicating it would

00:21:31,139 --> 00:21:37,039
prefer to receive the HTML content type

00:21:33,720 --> 00:21:40,559
formatted as a mime type in the response

00:21:37,039 --> 00:21:42,899
it also says that if there is no HTML

00:21:40,559 --> 00:21:47,009
version available the browser is happy

00:21:42,899 --> 00:21:48,990
to accept an XML version instead the

00:21:47,009 --> 00:21:52,019
render method we call in our controller

00:21:48,990 --> 00:21:54,149
looks for the template with the with the

00:21:52,019 --> 00:21:57,419
extension matching the requested content

00:21:54,149 --> 00:22:02,490
type so in this case Safari slash hippo

00:21:57,419 --> 00:22:05,509
dot HTML er be it also sets the content

00:22:02,490 --> 00:22:09,179
type header to match the rendered body

00:22:05,509 --> 00:22:13,490
we want a JSON hippo too so let's make a

00:22:09,179 --> 00:22:16,889
request to slash find hippo dot JSON

00:22:13,490 --> 00:22:21,629
oops we don't have a template for a JSON

00:22:16,889 --> 00:22:23,879
hippo yet we could add one or we can add

00:22:21,629 --> 00:22:28,919
a respond to block to handle the

00:22:23,879 --> 00:22:32,519
different formats now if we if we

00:22:28,919 --> 00:22:38,399
request slash find hippo JSON we get the

00:22:32,519 --> 00:22:40,529
JSON hippo jason interestingly browsers

00:22:38,399 --> 00:22:42,509
are not actually required to obey the

00:22:40,529 --> 00:22:45,389
content type header and might try to

00:22:42,509 --> 00:22:48,870
sniff out the type based on the contents

00:22:45,389 --> 00:22:51,539
of the file for this reason rail sets

00:22:48,870 --> 00:22:56,009
the X content type options header to

00:22:51,539 --> 00:22:57,899
know sniff to prevent this behavior now

00:22:56,009 --> 00:23:00,269
that we know what type of response to

00:22:57,899 --> 00:23:04,080
generate there are three ways our rails

00:23:00,269 --> 00:23:06,269
controller can generate a response we've

00:23:04,080 --> 00:23:09,450
already talked in depth about two of

00:23:06,269 --> 00:23:11,610
those ways the redirect to and head

00:23:09,450 --> 00:23:14,429
controller methods generate responses

00:23:11,610 --> 00:23:18,389
with status codes headers and empty

00:23:14,429 --> 00:23:21,960
bodies only the render method generates

00:23:18,389 --> 00:23:24,659
a full response that includes a body for

00:23:21,960 --> 00:23:27,549
our slash blind hippo example let's say

00:23:24,659 --> 00:23:30,649
the template looks like this

00:23:27,549 --> 00:23:33,499
when we visit slash find hippo and

00:23:30,649 --> 00:23:36,379
called render hippo the render method

00:23:33,499 --> 00:23:38,119
finds the appropriate template fills in

00:23:36,379 --> 00:23:41,029
all of the blanks with our instance

00:23:38,119 --> 00:23:43,639
variables and generates the body to send

00:23:41,029 --> 00:23:47,119
to the browser in order to accomplish

00:23:43,639 --> 00:23:51,109
this rails generates a view context

00:23:47,119 --> 00:23:54,139
class specific to each controller here

00:23:51,109 --> 00:23:56,209
is a very simplified example of what

00:23:54,139 --> 00:24:04,429
that view context class for the safari

00:23:56,209 --> 00:24:07,339
controller looks like when the view

00:24:04,429 --> 00:24:09,769
context is initialized rails loops

00:24:07,339 --> 00:24:11,779
through all of the instance variables we

00:24:09,769 --> 00:24:14,659
have set in our controller in this case

00:24:11,779 --> 00:24:17,109
at hippo and copies them into the view

00:24:14,659 --> 00:24:20,209
context object for use in the template

00:24:17,109 --> 00:24:25,940
these instance variables are known as

00:24:20,209 --> 00:24:28,399
assigns the view context class includes

00:24:25,940 --> 00:24:30,799
all of the helpers available from action

00:24:28,399 --> 00:24:32,899
view such as link to and all of the

00:24:30,799 --> 00:24:36,679
helpers we have defined in our app such

00:24:32,899 --> 00:24:38,989
as current user each template is

00:24:36,679 --> 00:24:41,809
compiled into an instance method on the

00:24:38,989 --> 00:24:44,089
view context class essentially each

00:24:41,809 --> 00:24:48,079
templates method is a souped up string

00:24:44,089 --> 00:24:52,729
concatenation in this case start the

00:24:48,079 --> 00:24:54,829
output string with hey get self dot

00:24:52,729 --> 00:24:56,690
current user which is available because

00:24:54,829 --> 00:25:00,109
we included all of our app helpers in

00:24:56,690 --> 00:25:01,999
the view context class escape current

00:25:00,109 --> 00:25:04,069
user dot name since it might be user

00:25:01,999 --> 00:25:10,069
input then append it to the output

00:25:04,069 --> 00:25:11,989
string add comma me get the at hippo

00:25:10,069 --> 00:25:15,349
instance variable that we set when we

00:25:11,989 --> 00:25:17,659
initialize the view context use self dot

00:25:15,349 --> 00:25:20,869
link to to generate a link to the page

00:25:17,659 --> 00:25:23,119
for our hippo again link to is available

00:25:20,869 --> 00:25:26,809
because we included all of the action

00:25:23,119 --> 00:25:29,719
view helpers as a module escape at hippo

00:25:26,809 --> 00:25:32,690
dot name to use for the link text then

00:25:29,719 --> 00:25:35,209
append the link to the output string add

00:25:32,690 --> 00:25:37,219
the exclamation point to finish the

00:25:35,209 --> 00:25:39,530
output string and return the output

00:25:37,219 --> 00:25:42,650
string

00:25:39,530 --> 00:25:46,220
and put it all together hey railsconf

00:25:42,650 --> 00:25:48,380
meet Phyllis Wow

00:25:46,220 --> 00:25:52,970
we finally found the elusive hippo

00:25:48,380 --> 00:25:55,120
Phyllis and she's 200 okay along the way

00:25:52,970 --> 00:25:58,490
we've witnessed a rare action

00:25:55,120 --> 00:26:01,010
unimaginable scale impossible locations

00:25:58,490 --> 00:26:03,670
and intimate moments captured from the

00:26:01,010 --> 00:26:06,440
deepest depths of the rails internals

00:26:03,670 --> 00:26:09,260
we've traveled across the great text

00:26:06,440 --> 00:26:11,960
plane taking in the spectacular action

00:26:09,260 --> 00:26:14,930
view as we found our way back to the

00:26:11,960 --> 00:26:17,810
browser thank you for joining me

00:26:14,930 --> 00:26:21,670
while we unearthed the amazing lifecycle

00:26:17,810 --> 00:26:21,670
of the rails response

00:26:24,010 --> 00:26:26,070

YouTube URL: https://www.youtube.com/watch?v=edjzEYMnrQw


