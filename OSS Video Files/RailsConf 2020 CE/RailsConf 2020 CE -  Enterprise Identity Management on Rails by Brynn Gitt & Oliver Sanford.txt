Title: RailsConf 2020 CE -  Enterprise Identity Management on Rails by Brynn Gitt & Oliver Sanford
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Enterprise Identity Management on Rails by Brynn Gitt & Oliver Sanford

Your team’s just inked that enterprise deal: 5000 seats at a well-known brand. But wait! Every week 100 people get hired or leave. Soon the customer's HR is complaining to the CEO and their engineers are hacking scripts against your undocumented API. Want to avoid this situation? We did too! Join us and learn how to automate identity management in Rails. We’ll demystify SCIM, peer under the hood of key Ruby auth and identity gems, and share insights to help you anticipate the twists in the road.

__________

"Brynn Gitt has been working on Ruby on Rails apps for five years. She has a BSE in electrical engineering from the University of Iowa. She is a senior software engineer at Mode (http://mode.com/), and led Mode’s implementation of the SCIM API. Previously, she worked at Academia.edu

Oliver Sanford has been developing Ruby and JavaScript apps for over a decade. He holds a PhD in anthropology from Berkeley and works as a senior software engineer at Mode (http://mode.com/), where he helps enterprises of all sizes understand the stories in their data."
Captions: 
	00:00:09,110 --> 00:00:15,449
welcome to railsconf 2020 couch edition

00:00:12,929 --> 00:00:21,360
and enterprise identity management on

00:00:15,449 --> 00:00:23,910
Rails I'm Bridget and I'm Oliver

00:00:21,360 --> 00:00:28,230
Sandford we're software engineers at

00:00:23,910 --> 00:00:31,050
mode analytics this talk is not about

00:00:28,230 --> 00:00:32,940
resetting passwords we don't like

00:00:31,050 --> 00:00:34,649
passwords very much and we're assuming

00:00:32,940 --> 00:00:36,270
you're already familiar enough with

00:00:34,649 --> 00:00:39,030
rails to have seen what password

00:00:36,270 --> 00:00:41,640
management typically looks like we're

00:00:39,030 --> 00:00:44,790
also going to skip right past session

00:00:41,640 --> 00:00:46,710
storage yes in a web app session the

00:00:44,790 --> 00:00:49,110
storage is the backbone of identity

00:00:46,710 --> 00:00:51,300
management it's something you have to

00:00:49,110 --> 00:00:54,149
handle in a way that suits your scale

00:00:51,300 --> 00:00:55,920
and infrastructure the various rails

00:00:54,149 --> 00:00:59,280
session stores are well covered

00:00:55,920 --> 00:01:01,950
elsewhere this talk is also not about

00:00:59,280 --> 00:01:04,049
real ID verification biometrics are

00:01:01,950 --> 00:01:06,030
other new forms of strong identity

00:01:04,049 --> 00:01:09,750
verification for government or health

00:01:06,030 --> 00:01:11,460
processes it is about several topics

00:01:09,750 --> 00:01:13,920
you'll want to consider if you're

00:01:11,460 --> 00:01:16,979
building a product or service for larger

00:01:13,920 --> 00:01:18,600
businesses this talk is about some of

00:01:16,979 --> 00:01:20,700
the lessons we've learned in handling

00:01:18,600 --> 00:01:23,310
identity concerns and rails apps and

00:01:20,700 --> 00:01:24,990
particularly through debugging sam'l and

00:01:23,310 --> 00:01:27,569
developing a skin integration

00:01:24,990 --> 00:01:29,880
we'll start with a big-picture design

00:01:27,569 --> 00:01:32,249
consideration and then we'll look at a

00:01:29,880 --> 00:01:34,319
couple areas more closely handling

00:01:32,249 --> 00:01:40,709
Enterprise authentication in rails and

00:01:34,319 --> 00:01:43,200
implementing skins the obvious but wrong

00:01:40,709 --> 00:01:45,599
way to set up an identity management in

00:01:43,200 --> 00:01:48,840
rails is to have all users share a

00:01:45,599 --> 00:01:51,990
single space users belong to an

00:01:48,840 --> 00:01:54,119
organization validate that no two user

00:01:51,990 --> 00:01:57,950
accounts can have the same email or

00:01:54,119 --> 00:02:00,869
username and you're done right wrong

00:01:57,950 --> 00:02:02,990
actually sometimes the same person

00:02:00,869 --> 00:02:07,020
belongs to more than one organization

00:02:02,990 --> 00:02:08,130
add a membership stable and voila users

00:02:07,020 --> 00:02:10,679
can be part of more than one

00:02:08,130 --> 00:02:13,650
organization here's where the trouble

00:02:10,679 --> 00:02:16,380
starts you'll run into policy conflicts

00:02:13,650 --> 00:02:19,290
immediately when two organizations have

00:02:16,380 --> 00:02:22,480
different login policies which one do

00:02:19,290 --> 00:02:24,269
you apply if someone has logged in

00:02:22,480 --> 00:02:26,860
fully according to one organization

00:02:24,269 --> 00:02:28,920
using a strategy or provider that

00:02:26,860 --> 00:02:32,530
another organization otherwise wouldn't

00:02:28,920 --> 00:02:35,799
what is their authorization level when a

00:02:32,530 --> 00:02:39,420
person is removed which organization has

00:02:35,799 --> 00:02:42,970
permission to delete their account a

00:02:39,420 --> 00:02:44,769
better approach is to scope users to

00:02:42,970 --> 00:02:47,319
organizations from the beginning of your

00:02:44,769 --> 00:02:49,450
project with this approach

00:02:47,319 --> 00:02:52,299
you'll validate traits like the email

00:02:49,450 --> 00:02:55,989
and username only within a single

00:02:52,299 --> 00:02:58,750
organization if Billy at Greenfield comm

00:02:55,989 --> 00:03:01,060
needs to be part of two orgs each org

00:02:58,750 --> 00:03:05,739
will need to maintain a separate Billy

00:03:01,060 --> 00:03:07,540
at Greenfield com account to understand

00:03:05,739 --> 00:03:08,530
the consequences of the two different

00:03:07,540 --> 00:03:12,670
design patterns

00:03:08,530 --> 00:03:15,010
let's compare github with slack github

00:03:12,670 --> 00:03:18,609
emerged out of an open source oriented

00:03:15,010 --> 00:03:20,890
ethos much like Twitter developers had

00:03:18,609 --> 00:03:24,489
handles in a single global namespace of

00:03:20,890 --> 00:03:27,160
users slack was designed for the

00:03:24,489 --> 00:03:28,959
enterprise from the beginning you log in

00:03:27,160 --> 00:03:32,139
to a workspace specific to your

00:03:28,959 --> 00:03:34,359
organization the github model is

00:03:32,139 --> 00:03:37,090
oriented toward global interactions and

00:03:34,359 --> 00:03:40,450
sharing a user can certainly still

00:03:37,090 --> 00:03:42,400
belong to an organization however things

00:03:40,450 --> 00:03:44,139
become more challenging when they belong

00:03:42,400 --> 00:03:46,780
to multiple organizations

00:03:44,139 --> 00:03:49,000
I definitely logged into my personal

00:03:46,780 --> 00:03:50,349
github account recently to discover I

00:03:49,000 --> 00:03:52,389
was still a member of a large

00:03:50,349 --> 00:03:56,019
organization I stopped contracting for

00:03:52,389 --> 00:03:58,120
three years ago the fact github has

00:03:56,019 --> 00:04:00,730
developed its Enterprise Cloud Edition

00:03:58,120 --> 00:04:03,669
which offers unique username account

00:04:00,730 --> 00:04:05,829
spaces sam'l authentication and skim

00:04:03,669 --> 00:04:08,829
integration at considerable additional

00:04:05,829 --> 00:04:10,780
cost speaks to the effort required in

00:04:08,829 --> 00:04:12,430
rebuilding or refactoring their service

00:04:10,780 --> 00:04:16,000
to move away from the global namespace

00:04:12,430 --> 00:04:19,510
pattern to the extent that github is

00:04:16,000 --> 00:04:21,579
really a b2b service that is if the

00:04:19,510 --> 00:04:24,099
platform is mostly used while people are

00:04:21,579 --> 00:04:26,530
at work with their employers paying for

00:04:24,099 --> 00:04:30,370
it the open-source model becomes

00:04:26,530 --> 00:04:32,229
extraneous if you have the luxury of

00:04:30,370 --> 00:04:34,690
planning for enterprise support from the

00:04:32,229 --> 00:04:36,039
ground up take those early decisions

00:04:34,690 --> 00:04:37,869
carefully

00:04:36,039 --> 00:04:39,669
how can you design your product or

00:04:37,869 --> 00:04:43,059
service so that Enterprise Identity

00:04:39,669 --> 00:04:45,939
Management is a breeze probably the best

00:04:43,059 --> 00:04:48,430
gift you can give yourself is if you are

00:04:45,939 --> 00:04:50,559
building a business product scope each

00:04:48,430 --> 00:04:53,860
user account entirely to a single

00:04:50,559 --> 00:04:56,619
organization if you need individuals to

00:04:53,860 --> 00:04:59,800
have accounts either add them all to an

00:04:56,619 --> 00:05:03,990
invisible general public organization or

00:04:59,800 --> 00:05:03,990
make them each and organization of one

00:05:04,619 --> 00:05:12,099
observability is fundamental identify

00:05:09,580 --> 00:05:14,289
and define any regular business events

00:05:12,099 --> 00:05:17,469
you want to log such as authentication

00:05:14,289 --> 00:05:21,399
success or failure a user provisioned

00:05:17,469 --> 00:05:24,430
event or a user deletion event in an

00:05:21,399 --> 00:05:26,919
existing service your product probably

00:05:24,430 --> 00:05:31,749
already has service objects to handle

00:05:26,919 --> 00:05:35,619
exceptions and analytics use them if you

00:05:31,749 --> 00:05:37,930
don't have them yet build them half the

00:05:35,619 --> 00:05:40,749
battle in development is exploring and

00:05:37,930 --> 00:05:42,909
tuning a living system if you work with

00:05:40,749 --> 00:05:45,459
the running system locally and explore

00:05:42,909 --> 00:05:47,620
actual payloads you'll find it makes the

00:05:45,459 --> 00:05:50,610
documentation much more concrete than

00:05:47,620 --> 00:05:53,620
the formalistic description of an RFP

00:05:50,610 --> 00:05:55,539
even for local development a log

00:05:53,620 --> 00:05:57,610
visualization product will serve you

00:05:55,539 --> 00:05:59,349
well compared to manually parsing the

00:05:57,610 --> 00:06:05,189
rails logs for everything you need to

00:05:59,349 --> 00:06:05,189
find omniauth

00:06:07,590 --> 00:06:13,169
many rails apps start out life offering

00:06:10,740 --> 00:06:16,680
authentication via username and password

00:06:13,169 --> 00:06:17,850
perhaps using something like devise try

00:06:16,680 --> 00:06:20,490
to skip this step

00:06:17,850 --> 00:06:22,940
storing individual passwords is insecure

00:06:20,490 --> 00:06:26,250
and risky avoid it if you can

00:06:22,940 --> 00:06:28,440
what's good about advice is that its

00:06:26,250 --> 00:06:30,680
modules implement many fundamentals of

00:06:28,440 --> 00:06:33,960
Identity Management in an itemized way

00:06:30,680 --> 00:06:35,910
they're instructive and represent

00:06:33,960 --> 00:06:39,120
concerns you may still want to address

00:06:35,910 --> 00:06:42,150
even if in a way that fits better with

00:06:39,120 --> 00:06:44,940
your existing practices for our purposes

00:06:42,150 --> 00:06:47,669
the minimum viable implementation is

00:06:44,940 --> 00:06:50,970
single sign-on via some combination of

00:06:47,669 --> 00:06:52,740
public a auth to vendors users will

00:06:50,970 --> 00:06:55,169
click on the first available single

00:06:52,740 --> 00:06:58,050
sign-on button and defer to an external

00:06:55,169 --> 00:07:00,150
service at this stage you'll need

00:06:58,050 --> 00:07:02,790
something more modular than username and

00:07:00,150 --> 00:07:07,370
password implementation in the rails

00:07:02,790 --> 00:07:07,370
ecosystem that something is omniauth

00:07:07,760 --> 00:07:14,520
omni auth really has only one central

00:07:11,160 --> 00:07:16,710
idea all forms of authentication boil

00:07:14,520 --> 00:07:19,710
down to a request phase in a callback

00:07:16,710 --> 00:07:22,470
phase and the request phase we check for

00:07:19,710 --> 00:07:24,480
evidence of the user's identity we look

00:07:22,470 --> 00:07:27,060
for an existing session and ask for

00:07:24,480 --> 00:07:29,280
credentials if we don't find it in the

00:07:27,060 --> 00:07:31,500
callback phase we pass verified identity

00:07:29,280 --> 00:07:33,780
information to your application and

00:07:31,500 --> 00:07:35,360
handle anything required to log these or

00:07:33,780 --> 00:07:38,070
in

00:07:35,360 --> 00:07:40,320
I'm the author supports some useful

00:07:38,070 --> 00:07:43,440
hooks such as before a request phase a

00:07:40,320 --> 00:07:46,200
good place for CSRF verification and

00:07:43,440 --> 00:07:49,680
sending information to analytics before

00:07:46,200 --> 00:07:51,450
callback phase and on failure in between

00:07:49,680 --> 00:07:53,490
it delegates the actual alert to

00:07:51,450 --> 00:07:56,030
whichever authentication strategy is

00:07:53,490 --> 00:07:56,030
appropriate

00:07:56,470 --> 00:08:01,700
depending on your customers you may find

00:07:59,240 --> 00:08:04,220
Google OAuth 2 is the most popular

00:08:01,700 --> 00:08:07,250
single sign-on method our perhaps github

00:08:04,220 --> 00:08:09,610
or Azure Active Directory in these cases

00:08:07,250 --> 00:08:12,320
you're connecting to public a auth to

00:08:09,610 --> 00:08:14,060
authorization servers and the connection

00:08:12,320 --> 00:08:16,460
details are more or less the same for

00:08:14,060 --> 00:08:18,230
all your customers so you'll wind up

00:08:16,460 --> 00:08:20,330
with something that looks like a pile of

00:08:18,230 --> 00:08:24,470
configuration constants from various

00:08:20,330 --> 00:08:26,510
Omni authentication strategy gems this

00:08:24,470 --> 00:08:29,240
may work for a while but there are some

00:08:26,510 --> 00:08:31,310
disadvantages to this system not all

00:08:29,240 --> 00:08:33,169
your customers will have all the login

00:08:31,310 --> 00:08:35,180
method set up so people will likely

00:08:33,169 --> 00:08:36,729
click on the wrong thing and wind up in

00:08:35,180 --> 00:08:39,320
the dead end

00:08:36,729 --> 00:08:41,839
moreover your customers may require you

00:08:39,320 --> 00:08:45,320
to insure their team only login with an

00:08:41,839 --> 00:08:47,720
approved strategy get access to both the

00:08:45,320 --> 00:08:51,830
request and call back actions where

00:08:47,720 --> 00:08:54,140
possible since your system now supports

00:08:51,830 --> 00:08:56,180
multiple authentication providers you'll

00:08:54,140 --> 00:08:58,880
need to track the appropriate external

00:08:56,180 --> 00:09:01,460
UID for each of them you'll find it in

00:08:58,880 --> 00:09:04,330
Omni off scoff hash and save it to an

00:09:01,460 --> 00:09:07,730
identity model associated with the user

00:09:04,330 --> 00:09:11,020
at this point the minimal possible ERD

00:09:07,730 --> 00:09:11,020
looks something like this

00:09:13,700 --> 00:09:19,380
sam'l stands for security assertion

00:09:16,350 --> 00:09:23,460
markup language the 2.0 specification

00:09:19,380 --> 00:09:26,640
was approved way back in 2005 before the

00:09:23,460 --> 00:09:29,310
world saw its first iPhone sam'l has

00:09:26,640 --> 00:09:31,530
some limitations but it's fully realized

00:09:29,310 --> 00:09:35,280
and fairly widely adopted in larger

00:09:31,530 --> 00:09:37,470
organizations it's a dialect of XML with

00:09:35,280 --> 00:09:41,850
a few interrelated documents you may

00:09:37,470 --> 00:09:43,730
wish to handle with the public o auth to

00:09:41,850 --> 00:09:46,170
vendors we discussed in the last section

00:09:43,730 --> 00:09:49,650
most of your connection details were

00:09:46,170 --> 00:09:51,630
constants no worries it won't be long

00:09:49,650 --> 00:09:54,210
before customers want to connect to

00:09:51,630 --> 00:09:57,120
identity providers entirely under their

00:09:54,210 --> 00:09:59,970
own control they might ask you to do

00:09:57,120 --> 00:10:01,620
this with throw off too but we found the

00:09:59,970 --> 00:10:04,650
most widely requested Enterprise

00:10:01,620 --> 00:10:09,750
authentication protocol is sam'l in the

00:10:04,650 --> 00:10:11,850
future it may be open ID connect a sam'l

00:10:09,750 --> 00:10:13,380
authentication flow can be initiated

00:10:11,850 --> 00:10:15,720
either directly from the identity

00:10:13,380 --> 00:10:18,320
provider or it can be initiated from the

00:10:15,720 --> 00:10:20,610
service provider that's your service

00:10:18,320 --> 00:10:23,310
there are some good reasons you want to

00:10:20,610 --> 00:10:25,200
initiate the request yourself your

00:10:23,310 --> 00:10:28,080
request will likely have a short timeout

00:10:25,200 --> 00:10:30,570
associated with it and may also contain

00:10:28,080 --> 00:10:32,730
some disposable immutable data you wish

00:10:30,570 --> 00:10:35,910
the identity provider to send back as

00:10:32,730 --> 00:10:38,160
part of the sam'l assertion in the OAuth

00:10:35,910 --> 00:10:41,250
2 world the sam'l assertion would be

00:10:38,160 --> 00:10:43,170
called an authorization token both

00:10:41,250 --> 00:10:47,040
measures help mitigate the risk of men

00:10:43,170 --> 00:10:49,620
in the middle attacks in a sam'l

00:10:47,040 --> 00:10:51,980
authentication flow the security

00:10:49,620 --> 00:10:54,300
assertion or sam'l response document

00:10:51,980 --> 00:10:56,120
contains the verified identifying

00:10:54,300 --> 00:10:58,650
information of the logged in user

00:10:56,120 --> 00:11:00,720
so once the sam'l response is received

00:10:58,650 --> 00:11:03,090
by the client and submitted to the

00:11:00,720 --> 00:11:06,300
service provider the authentication flow

00:11:03,090 --> 00:11:08,810
is done the service provider may decide

00:11:06,300 --> 00:11:11,010
not to log the user in for some reason a

00:11:08,810 --> 00:11:14,670
policy violation regarding a particular

00:11:11,010 --> 00:11:16,890
resource for example but from the moment

00:11:14,670 --> 00:11:19,140
the client sends the token the response

00:11:16,890 --> 00:11:21,660
document back to the service provider

00:11:19,140 --> 00:11:25,380
the identifying information has been

00:11:21,660 --> 00:11:28,110
delivered of course it's also essential

00:11:25,380 --> 00:11:30,270
be signed so sam'l documents should

00:11:28,110 --> 00:11:34,770
always contain a signature that matches

00:11:30,270 --> 00:11:36,630
the rest of the information provided the

00:11:34,770 --> 00:11:38,430
main issue with sam'l became clear

00:11:36,630 --> 00:11:41,640
within a few years after the release of

00:11:38,430 --> 00:11:44,820
2.0 it's that request assertion consumer

00:11:41,640 --> 00:11:47,250
service step which the client provides

00:11:44,820 --> 00:11:50,310
the security assertion to your service

00:11:47,250 --> 00:11:52,110
provider the sam'l specification makes

00:11:50,310 --> 00:11:54,600
the assumption that the client is a web

00:11:52,110 --> 00:11:57,140
browser and supports transport for this

00:11:54,600 --> 00:12:00,120
final step using either post or redirect

00:11:57,140 --> 00:12:00,780
this diagram implicitly shows the post

00:12:00,120 --> 00:12:04,650
variant

00:12:00,780 --> 00:12:06,750
since it responds with an XHTML form but

00:12:04,650 --> 00:12:09,950
for mobile clients this step does not

00:12:06,750 --> 00:12:12,120
work both two addresses this limitation

00:12:09,950 --> 00:12:13,350
providing for direct communication

00:12:12,120 --> 00:12:16,290
between the service and the

00:12:13,350 --> 00:12:19,050
authorization server the catch is that

00:12:16,290 --> 00:12:20,850
the identifying information is not

00:12:19,050 --> 00:12:23,760
provided to the user as part of the

00:12:20,850 --> 00:12:26,160
authentication token rather the service

00:12:23,760 --> 00:12:30,600
provider has to request it as part of

00:12:26,160 --> 00:12:32,970
the verification step if you need to

00:12:30,600 --> 00:12:35,640
support multiple customers with their

00:12:32,970 --> 00:12:38,640
own identity providers take a look at

00:12:35,640 --> 00:12:40,830
Omni off multi provider this makes it

00:12:38,640 --> 00:12:44,240
easy to pull the parameters for a sam'l

00:12:40,830 --> 00:12:47,910
strategy out of an active record model

00:12:44,240 --> 00:12:50,210
one limitation of Omni off is that while

00:12:47,910 --> 00:12:52,560
sam'l 2.0 supports automatic

00:12:50,210 --> 00:12:55,470
configuration through metadata exchange

00:12:52,560 --> 00:12:58,440
and Omni off supports an options phase

00:12:55,470 --> 00:13:00,480
for uses like that Omni off multi

00:12:58,440 --> 00:13:03,080
provider will need some extra tuning to

00:13:00,480 --> 00:13:05,730
get that to work in the meantime

00:13:03,080 --> 00:13:08,250
consider setting up a feature flag or

00:13:05,730 --> 00:13:11,940
environment toggle you can use to log

00:13:08,250 --> 00:13:13,950
the full XML of sam'l assertions in the

00:13:11,940 --> 00:13:16,080
event a particular customer has trouble

00:13:13,950 --> 00:13:18,510
setting up their sam'l provider you can

00:13:16,080 --> 00:13:21,260
grab the assertion and see exactly what

00:13:18,510 --> 00:13:21,260
is required

00:13:22,060 --> 00:13:27,280
debugging in practice here are a few

00:13:25,090 --> 00:13:29,020
other suggestions that are useful for

00:13:27,280 --> 00:13:32,590
debugging cinema and other

00:13:29,020 --> 00:13:34,300
authentication protocols set up test

00:13:32,590 --> 00:13:37,150
organizations with your most popular

00:13:34,300 --> 00:13:39,910
identity vendors such as octa or one

00:13:37,150 --> 00:13:42,250
login even if it's an identity provider

00:13:39,910 --> 00:13:44,920
that your organization also uses

00:13:42,250 --> 00:13:47,440
internally you probably won't be able to

00:13:44,920 --> 00:13:49,840
use your organizational account to do

00:13:47,440 --> 00:13:53,050
development and debugging instead you'll

00:13:49,840 --> 00:13:55,090
want a test organization with the larger

00:13:53,050 --> 00:13:57,070
vendors such as octa this is not

00:13:55,090 --> 00:13:58,210
necessarily included in your contract

00:13:57,070 --> 00:14:01,480
and it's something you'll want to

00:13:58,210 --> 00:14:03,520
negotiate if you use trial accounts for

00:14:01,480 --> 00:14:05,740
development and testing you'll find that

00:14:03,520 --> 00:14:09,040
they may expire and lose valuable State

00:14:05,740 --> 00:14:11,260
every 30 days to avoid this you'll want

00:14:09,040 --> 00:14:13,210
your vendor account manager to include

00:14:11,260 --> 00:14:14,990
permanent testing resources from the

00:14:13,210 --> 00:14:18,180
beginning

00:14:14,990 --> 00:14:20,910
rather than rely on a suspender with a

00:14:18,180 --> 00:14:22,890
large surface area another option that's

00:14:20,910 --> 00:14:25,290
helpful for understanding sam'l is to

00:14:22,890 --> 00:14:28,680
debug against an open-source identity

00:14:25,290 --> 00:14:30,870
provider such as key cloak this has the

00:14:28,680 --> 00:14:32,640
advantage of being free plus you can

00:14:30,870 --> 00:14:35,790
quickly set up and run the identity

00:14:32,640 --> 00:14:37,920
provider locally using docker key cloak

00:14:35,790 --> 00:14:40,020
is certainly a thinner solution than

00:14:37,920 --> 00:14:42,000
octa but in practice this makes it

00:14:40,020 --> 00:14:44,370
easier to locate the certificates and

00:14:42,000 --> 00:14:46,410
settings you need and to see how

00:14:44,370 --> 00:14:48,270
settings on the identity provider side

00:14:46,410 --> 00:14:50,570
match up with things you're seeing in

00:14:48,270 --> 00:14:50,570
Ruby

00:14:50,770 --> 00:14:56,630
you'll also want to be able to inspect

00:14:53,720 --> 00:14:59,570
authentication flows in process from the

00:14:56,630 --> 00:15:01,430
client perspective for this use in grok

00:14:59,570 --> 00:15:04,130
are a sam'l browser plugin

00:15:01,430 --> 00:15:06,230
the latter ads XML decoding and

00:15:04,130 --> 00:15:08,720
inspection to your browser developer

00:15:06,230 --> 00:15:10,880
tools it's super helpful to be able to

00:15:08,720 --> 00:15:13,130
see exactly what's being sent for each

00:15:10,880 --> 00:15:16,630
stage of the flow and to decode the

00:15:13,130 --> 00:15:16,630
sam'l assertions right there

00:15:17,760 --> 00:15:23,320
before you get your skin implementation

00:15:20,529 --> 00:15:25,870
in place you may need to handle account

00:15:23,320 --> 00:15:29,640
provisioning just in time after your

00:15:25,870 --> 00:15:32,050
single sign-on auth response is received

00:15:29,640 --> 00:15:33,640
the main idea is to treat the

00:15:32,050 --> 00:15:37,000
authorization token as being

00:15:33,640 --> 00:15:39,040
authoritative that is if Google says

00:15:37,000 --> 00:15:40,930
that Billy Moore from Greenfield is at

00:15:39,040 --> 00:15:43,690
your door and you don't have an account

00:15:40,930 --> 00:15:46,180
for Billy Moore yet you can create one

00:15:43,690 --> 00:15:47,470
for him as part of the login flow this

00:15:46,180 --> 00:15:50,920
is what we call just-in-time

00:15:47,470 --> 00:15:53,290
provisioning as we'll see shortly with

00:15:50,920 --> 00:15:55,810
skim a sam'l Plus just-in-time

00:15:53,290 --> 00:15:57,430
provisioning scenario raises a couple of

00:15:55,810 --> 00:16:00,370
edge cases which you'll need to think

00:15:57,430 --> 00:16:02,529
through among them email and name

00:16:00,370 --> 00:16:05,800
changes as when an individual gets

00:16:02,529 --> 00:16:07,779
married and email inheritance as when

00:16:05,800 --> 00:16:10,690
Billy Moore departs and Billy Strayhorn

00:16:07,779 --> 00:16:18,970
arrives and also wants to be Billy at

00:16:10,690 --> 00:16:21,220
Greenfield com what is skim skim stands

00:16:18,970 --> 00:16:23,410
for system for cross domain Identity

00:16:21,220 --> 00:16:25,540
Management note that throughout this

00:16:23,410 --> 00:16:30,720
presentation when we say skim we are

00:16:25,540 --> 00:16:30,720
referring to version 2.0 of the skim API

00:16:30,839 --> 00:16:35,860
is an API that is implemented by a

00:16:33,670 --> 00:16:38,080
service provider and used by an identity

00:16:35,860 --> 00:16:40,990
provider to manage resources on the

00:16:38,080 --> 00:16:43,240
service provider as a b2b company we

00:16:40,990 --> 00:16:44,830
implemented the skim API to allow our

00:16:43,240 --> 00:16:47,279
customers to manage their users and

00:16:44,830 --> 00:16:50,230
groups through third-party software

00:16:47,279 --> 00:16:52,240
specifically starting with hasta this

00:16:50,230 --> 00:16:54,459
gives the administrators other customer

00:16:52,240 --> 00:16:56,440
organizations more control over who can

00:16:54,459 --> 00:16:59,940
access our products and the permissions

00:16:56,440 --> 00:16:59,940
they have within our products

00:17:00,570 --> 00:17:07,150
there are two portions of the skim API

00:17:03,930 --> 00:17:09,760
discoverability and operations the

00:17:07,150 --> 00:17:11,579
discoverability portion of the API tells

00:17:09,760 --> 00:17:14,050
a client about the supported features

00:17:11,579 --> 00:17:16,870
resources and attributes that the

00:17:14,050 --> 00:17:18,819
operations portion implements the

00:17:16,870 --> 00:17:21,670
operation portion of the skim a PI

00:17:18,819 --> 00:17:25,000
provides the abilities to create read

00:17:21,670 --> 00:17:28,060
update and delete resources search for

00:17:25,000 --> 00:17:30,700
resources and perform operations on

00:17:28,060 --> 00:17:33,460
those resources the two resources

00:17:30,700 --> 00:17:36,250
defined in the skim API are users and

00:17:33,460 --> 00:17:39,630
groups however this can also be extended

00:17:36,250 --> 00:17:42,450
to other resources in your application

00:17:39,630 --> 00:17:45,310
here is an example of the user resource

00:17:42,450 --> 00:17:48,870
we can see many of the attributes that

00:17:45,310 --> 00:17:52,090
are defined in the skim core schema and

00:17:48,870 --> 00:17:54,280
here is the group resource there's a lot

00:17:52,090 --> 00:17:55,930
to take in here from these two resources

00:17:54,280 --> 00:17:58,450
so to start off we will want to

00:17:55,930 --> 00:18:00,580
determine how much of the skim API we

00:17:58,450 --> 00:18:03,910
need and want to support in order for

00:18:00,580 --> 00:18:06,970
our administrators our customers to

00:18:03,910 --> 00:18:09,520
manage resources in our application in

00:18:06,970 --> 00:18:14,320
an efficient way this will narrow the

00:18:09,520 --> 00:18:16,750
scope of our skin api we will want to

00:18:14,320 --> 00:18:19,300
think about how skin interacts with our

00:18:16,750 --> 00:18:21,460
internal permission structure if we use

00:18:19,300 --> 00:18:23,440
groups to assign permissions we'll want

00:18:21,460 --> 00:18:26,770
to implement the group's operations of

00:18:23,440 --> 00:18:28,990
the CM API we could also use a roles

00:18:26,770 --> 00:18:31,420
attribute on users to specify multiple

00:18:28,990 --> 00:18:34,150
values are the user type field to

00:18:31,420 --> 00:18:36,910
specify a singular value for our

00:18:34,150 --> 00:18:39,340
application we use both roles and groups

00:18:36,910 --> 00:18:41,050
for different permissions so we will

00:18:39,340 --> 00:18:43,120
implement the roles attribute in our

00:18:41,050 --> 00:18:46,480
scheme API and support the group's

00:18:43,120 --> 00:18:48,550
resource we have also worked with our

00:18:46,480 --> 00:18:50,380
product managers customer success and

00:18:48,550 --> 00:18:52,390
sales teams to determine which identity

00:18:50,380 --> 00:18:55,300
providers are the most valuable to our

00:18:52,390 --> 00:18:57,700
customers we have decided to start by

00:18:55,300 --> 00:18:59,890
integrating with octa so we will only

00:18:57,700 --> 00:19:02,590
need to implement the portions of the

00:18:59,890 --> 00:19:04,929
skin API which octa requires it's

00:19:02,590 --> 00:19:07,240
important to also spend time researching

00:19:04,929 --> 00:19:09,490
the other identity providers we may want

00:19:07,240 --> 00:19:11,320
to support in the future we don't want

00:19:09,490 --> 00:19:13,240
to dig ourselves into a whole by

00:19:11,320 --> 00:19:13,750
ignoring the rest of the skim API and

00:19:13,240 --> 00:19:16,890
missing a

00:19:13,750 --> 00:19:16,890
crucial piece from the beginning

00:19:17,019 --> 00:19:21,349
so we'll remove some of the user

00:19:19,519 --> 00:19:25,129
attributes from the user resource that

00:19:21,349 --> 00:19:27,379
we don't need to support and add some

00:19:25,129 --> 00:19:31,039
others to get our supported user

00:19:27,379 --> 00:19:32,499
resource and we'll do the same for

00:19:31,039 --> 00:19:35,179
groups

00:19:32,499 --> 00:19:40,519
our resources are starting to look more

00:19:35,179 --> 00:19:42,409
manageable now we will also be able to

00:19:40,519 --> 00:19:45,019
limit which endpoints are included in

00:19:42,409 --> 00:19:50,049
our first iteration of our scheme API by

00:19:45,019 --> 00:19:51,940
only implementing those that octo uses

00:19:50,049 --> 00:19:54,109
this eliminates the entire

00:19:51,940 --> 00:20:02,539
discoverability section of the scheme

00:19:54,109 --> 00:20:05,029
API and the bulk operations too so isn't

00:20:02,539 --> 00:20:07,279
there a gem for all this let's take a

00:20:05,029 --> 00:20:11,539
look at three gems to help us implement

00:20:07,279 --> 00:20:14,359
the scheme API skin kit by milk on skim

00:20:11,539 --> 00:20:16,989
rails by lesson Lee and skim engine by

00:20:14,359 --> 00:20:16,989
Cisco amp

00:20:17,590 --> 00:20:23,960
each of these gems covers a slightly

00:20:20,780 --> 00:20:26,600
different piece of the skin API skin kit

00:20:23,960 --> 00:20:28,970
covers the discoverability portion while

00:20:26,600 --> 00:20:32,060
skin rails covers the operations portion

00:20:28,970 --> 00:20:36,820
but only for users skin engine covers

00:20:32,060 --> 00:20:36,820
both the discoverability and operations

00:20:37,360 --> 00:20:42,680
the skin kit gem focuses on the schema

00:20:41,060 --> 00:20:44,810
and resources for your application

00:20:42,680 --> 00:20:46,730
supports it helps provide the

00:20:44,810 --> 00:20:49,310
discoverability portion of the skin may

00:20:46,730 --> 00:20:51,890
pie telling an identity provider about

00:20:49,310 --> 00:20:53,930
how to use your API it doesn't help you

00:20:51,890 --> 00:20:56,510
implement the operations portion of skin

00:20:53,930 --> 00:20:58,490
so after implementing this gem into your

00:20:56,510 --> 00:21:01,580
rails application you will still need to

00:20:58,490 --> 00:21:03,650
do all the work to manage resources the

00:21:01,580 --> 00:21:05,570
pieces of the skin may pie that skin kit

00:21:03,650 --> 00:21:07,970
will help you implement aren't required

00:21:05,570 --> 00:21:09,740
by octa so for us this meant skipping

00:21:07,970 --> 00:21:12,040
this entirely in order to narrow our

00:21:09,740 --> 00:21:12,040
scope

00:21:13,059 --> 00:21:19,580
next up we have the skin rails gem this

00:21:16,669 --> 00:21:21,739
gem is not fully skin compliant it

00:21:19,580 --> 00:21:24,589
focuses on the components of skin that

00:21:21,739 --> 00:21:26,899
are required by octave within the set of

00:21:24,589 --> 00:21:29,450
features octave supports this gem helps

00:21:26,899 --> 00:21:31,249
implement the scheme API for users it

00:21:29,450 --> 00:21:33,979
doesn't support groups are adding other

00:21:31,249 --> 00:21:35,570
resources this gem also makes

00:21:33,979 --> 00:21:38,089
assumptions about how your underlying

00:21:35,570 --> 00:21:40,190
data model looks it assumes your users

00:21:38,089 --> 00:21:42,229
are organized within a company that has

00:21:40,190 --> 00:21:44,269
a scope to get these errs it assumes

00:21:42,229 --> 00:21:48,049
that your data model matches the core

00:21:44,269 --> 00:21:50,149
skin schema due to our existing code

00:21:48,049 --> 00:21:52,399
there wasn't enough flexibility here to

00:21:50,149 --> 00:21:54,259
add support for groups and handle the

00:21:52,399 --> 00:21:58,219
differences between our data models and

00:21:54,259 --> 00:22:01,519
the skin core schema lastly we have the

00:21:58,219 --> 00:22:03,440
skin engine gem this gem aims to be more

00:22:01,519 --> 00:22:06,950
general-purpose than the skin kit and

00:22:03,440 --> 00:22:08,899
skin rails gems it supports the core

00:22:06,950 --> 00:22:10,759
schema endpoints the operations

00:22:08,899 --> 00:22:13,309
endpoints and can be extended to have

00:22:10,759 --> 00:22:14,389
multiple resource types there are soul

00:22:13,309 --> 00:22:16,969
pieces you will need to implement

00:22:14,389 --> 00:22:18,710
yourself though to be fully skin

00:22:16,969 --> 00:22:21,019
compliant you'll need to implement the

00:22:18,710 --> 00:22:23,599
index action with filtering handling

00:22:21,019 --> 00:22:28,549
patched parameters and other application

00:22:23,599 --> 00:22:30,289
specific logic that other logic is

00:22:28,549 --> 00:22:33,489
summarized nicely and an example

00:22:30,289 --> 00:22:36,349
controller in the skin engine repository

00:22:33,489 --> 00:22:39,409
convert the skin engine resources user

00:22:36,349 --> 00:22:43,149
to your application object and save this

00:22:39,409 --> 00:22:43,149
is definitely easier said than done

00:22:44,370 --> 00:22:49,000
factoring your skin API endpoints is the

00:22:47,230 --> 00:22:51,120
hardest part of writing your skin maybe

00:22:49,000 --> 00:22:51,120
I

00:22:51,409 --> 00:22:57,589
it can't supposes the question should I

00:22:55,229 --> 00:23:00,629
really do what this request is asking

00:22:57,589 --> 00:23:03,029
the answer to this question lies in the

00:23:00,629 --> 00:23:05,459
permissions of your application in our

00:23:03,029 --> 00:23:08,459
case users belong to organizations and

00:23:05,459 --> 00:23:10,259
organizations have domains if a request

00:23:08,459 --> 00:23:12,929
comes in for a user with an email

00:23:10,259 --> 00:23:14,759
address domain that belongs to the

00:23:12,929 --> 00:23:18,269
organisation that's making the request

00:23:14,759 --> 00:23:20,219
we do it we use domains as an additional

00:23:18,269 --> 00:23:22,259
way to determine if the request has

00:23:20,219 --> 00:23:25,469
permission to create our link to users

00:23:22,259 --> 00:23:27,719
with a specific email in addition to

00:23:25,469 --> 00:23:29,719
linking users we also ran into some edge

00:23:27,719 --> 00:23:33,479
cases and questions from our customers

00:23:29,719 --> 00:23:36,289
these edge cases also apply to SSO with

00:23:33,479 --> 00:23:36,289
just-in-time provisioning

00:23:36,870 --> 00:23:43,180
the first edge case we ran into involved

00:23:40,420 --> 00:23:45,370
emails someone got married I decided

00:23:43,180 --> 00:23:48,970
that goat lover was not an excessively

00:23:45,370 --> 00:23:50,650
professional email handle with skim it's

00:23:48,970 --> 00:23:52,870
now time for your administrator to link

00:23:50,650 --> 00:23:54,550
your accounts they use your first name

00:23:52,870 --> 00:23:56,890
last name email in the identity provider

00:23:54,550 --> 00:23:59,140
and it doesn't link to your goat lover

00:23:56,890 --> 00:24:02,500
email handle that use used to sign up

00:23:59,140 --> 00:24:04,390
for the service provider with instead

00:24:02,500 --> 00:24:07,320
that you have a fresh blanket count that

00:24:04,390 --> 00:24:10,990
is missing all your previous work in

00:24:07,320 --> 00:24:12,640
this case we provided our customers with

00:24:10,990 --> 00:24:14,740
instructions on how to remove the new

00:24:12,640 --> 00:24:17,320
account change the email within our

00:24:14,740 --> 00:24:19,690
application on the old account and then

00:24:17,320 --> 00:24:22,240
to retry the skin request another

00:24:19,690 --> 00:24:24,010
solution would be to use the goal of our

00:24:22,240 --> 00:24:26,140
email handle in the identity provider

00:24:24,010 --> 00:24:28,180
and then change it within the identity

00:24:26,140 --> 00:24:31,570
provider to trigger an update operation

00:24:28,180 --> 00:24:33,160
on our skin API in this case we are

00:24:31,570 --> 00:24:35,680
expecting the request to have an

00:24:33,160 --> 00:24:38,320
external UID that matches an existing

00:24:35,680 --> 00:24:41,560
user and a new email address our other

00:24:38,320 --> 00:24:43,660
changed attributes for the future we've

00:24:41,560 --> 00:24:45,780
also added this scenario as a warning in

00:24:43,660 --> 00:24:48,210
our skin integration guide

00:24:45,780 --> 00:24:51,760
SSO with just-in-time provisioning

00:24:48,210 --> 00:24:54,160
handles this similarly when we get the

00:24:51,760 --> 00:24:57,820
SSO login request we can check both the

00:24:54,160 --> 00:25:00,430
external UID and email address if the

00:24:57,820 --> 00:25:03,400
user already exists in our system as

00:25:00,430 --> 00:25:05,680
determined by their external UID but the

00:25:03,400 --> 00:25:07,570
authorization token specifies a

00:25:05,680 --> 00:25:11,640
different name our email address

00:25:07,570 --> 00:25:11,640
we're looking at an email change

00:25:13,730 --> 00:25:18,320
the other hand we may see that the

00:25:15,860 --> 00:25:21,710
external UID has changed but the email

00:25:18,320 --> 00:25:23,779
does already exist in the system and so

00:25:21,710 --> 00:25:26,360
we have a slightly more subtle situation

00:25:23,779 --> 00:25:27,950
to think about this happens when Billy

00:25:26,360 --> 00:25:30,409
Moore departs and Billy Strayhorn

00:25:27,950 --> 00:25:33,460
arrives and really wants to be Billy at

00:25:30,409 --> 00:25:33,460
my company calm

00:25:33,980 --> 00:25:39,660
it really depends on how the external

00:25:36,900 --> 00:25:42,360
system treats email addresses if it does

00:25:39,660 --> 00:25:44,580
not enforce email uniqueness stop right

00:25:42,360 --> 00:25:46,410
here there's nothing really you can

00:25:44,580 --> 00:25:48,180
conclude and your customer will have to

00:25:46,410 --> 00:25:51,540
take certain administrative actions

00:25:48,180 --> 00:25:53,760
manually if you can assume that the

00:25:51,540 --> 00:25:55,920
email though it might be mutable is

00:25:53,760 --> 00:25:58,380
unique within the customer organization

00:25:55,920 --> 00:26:01,110
at that moment then when you're off

00:25:58,380 --> 00:26:03,330
handling code sees the new external UID

00:26:01,110 --> 00:26:06,180
coupled with an old email address it

00:26:03,330 --> 00:26:08,910
probably means the old UID is now

00:26:06,180 --> 00:26:10,740
inactive or the funked someone has left

00:26:08,910 --> 00:26:12,540
the customer organization and you are

00:26:10,740 --> 00:26:16,230
now looking at a new person

00:26:12,540 --> 00:26:18,360
this is email inheritance checking the

00:26:16,230 --> 00:26:20,340
external UID is the solution for both

00:26:18,360 --> 00:26:23,880
the skin and SSO with just-in-time

00:26:20,340 --> 00:26:26,340
provisioning the challenge here is that

00:26:23,880 --> 00:26:28,770
the correct permissions action is then

00:26:26,340 --> 00:26:32,190
to deactivate or delete the prior user

00:26:28,770 --> 00:26:34,950
account however in a mature system these

00:26:32,190 --> 00:26:37,620
actions may not be so easy to take a

00:26:34,950 --> 00:26:39,810
user may have many associated records

00:26:37,620 --> 00:26:42,420
that they're shared and accessed within

00:26:39,810 --> 00:26:45,360
the team you will have to be careful

00:26:42,420 --> 00:26:47,100
about what you delete and how you manage

00:26:45,360 --> 00:26:50,190
the disposition of any ambiguous

00:26:47,100 --> 00:26:52,560
situations for instance if the user has

00:26:50,190 --> 00:26:54,930
scheduled for deletion is the creator or

00:26:52,560 --> 00:26:57,140
owner of a resource to whom's as that

00:26:54,930 --> 00:27:00,450
resource fall in the person's absence

00:26:57,140 --> 00:27:02,850
it's also possible user or

00:27:00,450 --> 00:27:05,010
administrative error has led to this

00:27:02,850 --> 00:27:07,200
situation in which case you'd better

00:27:05,010 --> 00:27:09,600
hope there's an easy way to undelete

00:27:07,200 --> 00:27:11,250
anything you may need to delete in order

00:27:09,600 --> 00:27:14,940
to provision the new account for the

00:27:11,250 --> 00:27:16,980
email inheritor when you decide to deep

00:27:14,940 --> 00:27:19,440
revision a user in the course of another

00:27:16,980 --> 00:27:22,170
users login or skimmer quests that's a

00:27:19,440 --> 00:27:23,820
significant business decision you will

00:27:22,170 --> 00:27:25,500
definitely want to make sure that you

00:27:23,820 --> 00:27:29,360
have observability and maybe even

00:27:25,500 --> 00:27:29,360
proactive alerting for these events

00:27:30,299 --> 00:27:35,110
next we'll talk about testing your skin

00:27:32,950 --> 00:27:36,970
may PEI to ensure it will work with

00:27:35,110 --> 00:27:41,740
identity providers to manage resources

00:27:36,970 --> 00:27:44,110
on your application there are a couple

00:27:41,740 --> 00:27:47,410
things we want to confirm when testing

00:27:44,110 --> 00:27:49,360
your CM integration the API complies

00:27:47,410 --> 00:27:52,450
with the format specified by the skin

00:27:49,360 --> 00:27:55,110
protocol each endpoint implements the

00:27:52,450 --> 00:27:57,490
business logic we expect to take place

00:27:55,110 --> 00:27:59,710
requests are authorized appropriately

00:27:57,490 --> 00:28:02,530
and only modify resources they should

00:27:59,710 --> 00:28:04,270
have access to integrating with our

00:28:02,530 --> 00:28:06,250
prefer that identity provider works

00:28:04,270 --> 00:28:08,169
we're able to make changes in the

00:28:06,250 --> 00:28:10,450
identity provider and see those changes

00:28:08,169 --> 00:28:12,130
within our application this also

00:28:10,450 --> 00:28:16,870
includes running through common and

00:28:12,130 --> 00:28:18,370
uncommon administrative work Liz so for

00:28:16,870 --> 00:28:19,590
each of these there will be different

00:28:18,370 --> 00:28:22,570
tools you can use

00:28:19,590 --> 00:28:24,640
octa provides tests for your api and

00:28:22,570 --> 00:28:26,590
basic tests of integrating with their

00:28:24,640 --> 00:28:28,809
preview environment that work with blaze

00:28:26,590 --> 00:28:30,820
meter run scope you'll also want to

00:28:28,809 --> 00:28:33,309
include r-spec or another framework for

00:28:30,820 --> 00:28:35,710
integration and unit tests and possibly

00:28:33,309 --> 00:28:37,780
penetration testing to ensure only

00:28:35,710 --> 00:28:39,870
authorized users are accessing and

00:28:37,780 --> 00:28:42,789
making changes through your skin api

00:28:39,870 --> 00:28:44,710
octa also requires an entire suite of

00:28:42,789 --> 00:28:47,440
manual testing to be done through the

00:28:44,710 --> 00:28:49,299
octave you environment this manual

00:28:47,440 --> 00:28:51,610
testing is tedious that will teach you

00:28:49,299 --> 00:28:53,440
how to use octa as an administrator and

00:28:51,610 --> 00:28:55,840
show the workflows administrators use

00:28:53,440 --> 00:28:57,880
for common tasks like assigning users to

00:28:55,840 --> 00:29:00,669
your applications deactivating and

00:28:57,880 --> 00:29:02,350
suspending users and pushing groups if

00:29:00,669 --> 00:29:04,450
you don't know how a specific workflow

00:29:02,350 --> 00:29:06,880
is done an octa you can probably find it

00:29:04,450 --> 00:29:09,190
in the manual testing spreadsheet we

00:29:06,880 --> 00:29:11,080
also relied on the tool called Angra to

00:29:09,190 --> 00:29:14,220
capture and replay requests that hit our

00:29:11,080 --> 00:29:14,220
skim development server

00:29:14,639 --> 00:29:18,899
when your skin may p.i is working you

00:29:17,230 --> 00:29:21,820
can then submit it to octopus

00:29:18,899 --> 00:29:23,799
integration network in order to submit

00:29:21,820 --> 00:29:26,230
you'll need to provide octa with an

00:29:23,799 --> 00:29:28,570
integration guide show passing automated

00:29:26,230 --> 00:29:32,529
tests and blaze maybe run scope confirm

00:29:28,570 --> 00:29:34,799
manual QA test pass and provide testing

00:29:32,529 --> 00:29:37,720
credentials for your application

00:29:34,799 --> 00:29:40,360
each time we contacted octa there was

00:29:37,720 --> 00:29:42,399
about a one week turnaround our initial

00:29:40,360 --> 00:29:43,769
feedback involved updating support

00:29:42,399 --> 00:29:45,909
contacts of our company

00:29:43,769 --> 00:29:47,700
removing optional blades made a run

00:29:45,909 --> 00:29:49,870
scope tests that were not passing

00:29:47,700 --> 00:29:51,940
providing testing credentials and

00:29:49,870 --> 00:29:55,570
confirming that we did the manual

00:29:51,940 --> 00:29:57,340
testing of our integration our first two

00:29:55,570 --> 00:29:59,529
bugs came from a race condition on

00:29:57,340 --> 00:30:01,659
creating users quickly and business

00:29:59,529 --> 00:30:04,659
logic for our application that needed to

00:30:01,659 --> 00:30:06,879
handle periods and email addresses the

00:30:04,659 --> 00:30:08,470
next round of bugs involves asking us

00:30:06,879 --> 00:30:11,230
update screenshots in their integration

00:30:08,470 --> 00:30:13,960
guide and an error on the octa tests and

00:30:11,230 --> 00:30:16,269
about how to use the rules attribute for

00:30:13,960 --> 00:30:18,879
our application there was a typo in the

00:30:16,269 --> 00:30:20,620
role they assigned after one more round

00:30:18,879 --> 00:30:22,629
of updating screenshots again in our

00:30:20,620 --> 00:30:25,029
integration guide our application was

00:30:22,629 --> 00:30:26,679
approved it took about five weeks from

00:30:25,029 --> 00:30:31,419
first submission to getting final

00:30:26,679 --> 00:30:33,460
approval we hope you have enjoyed

00:30:31,419 --> 00:30:35,500
hearing the lessons we've learned in

00:30:33,460 --> 00:30:38,649
handling identity concerns and rails

00:30:35,500 --> 00:30:40,840
apps debugging sam'l and developing a

00:30:38,649 --> 00:30:43,210
skin integration and have taken away

00:30:40,840 --> 00:30:45,340
some design considerations and insights

00:30:43,210 --> 00:30:49,230
into Enterprise Identity Management on

00:30:45,340 --> 00:30:49,230

YouTube URL: https://www.youtube.com/watch?v=hMdvur0YqQY


