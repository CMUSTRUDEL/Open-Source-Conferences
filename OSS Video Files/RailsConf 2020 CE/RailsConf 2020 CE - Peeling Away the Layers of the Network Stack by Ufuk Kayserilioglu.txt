Title: RailsConf 2020 CE - Peeling Away the Layers of the Network Stack by Ufuk Kayserilioglu
Publication date: 2020-04-24
Playlist: RailsConf 2020 CE
Description: 
	Peeling Away the Layers of the Network Stack by Ufuk Kayserilioglu

"As Rails developers, we depend on network protocols to ensure the products we build are available and accessible to our users. Despite this, many of us are poorly aware of how the layers of the network stack actually work, or why they are there.

Understanding the things that happen between physical signals on the wire and your Rails application will help you hone your craft and level you up. Fortunately, the basic concepts of network protocols are easy to grasp, with a little guidance. So let's walk together through these concepts, and peel away the layers of the network stack one by one."

__________

Ufuk is a Physics PhD turned polyglot software developer. He is currently working as a Senior Production Engineer on the Ruby and Rails Infrastructure Team at Shopify. He has over 20 years of experience working with statically and dynamically typed languages and he brings that to Shopify for the adoption of better Ruby tooling and practices. He currently works remotely from Cyprus where he lives with his beloved wife and wonderful daughter. In his free time, he teaches computer science to high-school students.
Captions: 
	00:00:08,870 --> 00:00:15,179
hello and welcome to this presentation

00:00:11,339 --> 00:00:17,460
in railsconf 2020 count Judaism I was

00:00:15,179 --> 00:00:19,680
really looking forward to seeing all of

00:00:17,460 --> 00:00:21,930
you in Portland this year but because of

00:00:19,680 --> 00:00:24,809
coronavirus this will have to be removed

00:00:21,930 --> 00:00:27,390
I hope you still enjoy it and thank you

00:00:24,809 --> 00:00:29,489
for joining me in this presentation so

00:00:27,390 --> 00:00:33,239
today we'll be talking about the layers

00:00:29,489 --> 00:00:36,570
of the network stack my name is Bhavik

00:00:33,239 --> 00:00:38,430
Kaiser Lola and I am a senior production

00:00:36,570 --> 00:00:43,020
engineer on the rails and Ruby

00:00:38,430 --> 00:00:45,000
infrastructure team at Shopify since

00:00:43,020 --> 00:00:46,440
you're watching a railsconf talk I'm

00:00:45,000 --> 00:00:49,680
going to assume that you're at least

00:00:46,440 --> 00:00:52,710
vaguely familiar with rails HTML

00:00:49,680 --> 00:00:54,480
Javascript and CSS and I would also

00:00:52,710 --> 00:00:57,480
assume that you know a thing or two

00:00:54,480 --> 00:01:00,000
about HTTP as well however for most of

00:00:57,480 --> 00:01:02,130
us rails developers or for most web

00:01:00,000 --> 00:01:04,500
developers for that matter the lower

00:01:02,130 --> 00:01:06,899
layers of the network stack are a big

00:01:04,500 --> 00:01:13,049
unknown you might have heard a million

00:01:06,899 --> 00:01:14,999
acronyms like DNS TCP ICMP 802 dot 11

00:01:13,049 --> 00:01:17,429
and maybe you are familiar with some of

00:01:14,999 --> 00:01:19,380
them what I've often seen though is that

00:01:17,429 --> 00:01:21,659
most web developers don't really

00:01:19,380 --> 00:01:24,049
understand all the complexity that lies

00:01:21,659 --> 00:01:26,789
beneath their applications however

00:01:24,049 --> 00:01:28,740
understanding the inner working of the

00:01:26,789 --> 00:01:31,289
stack you're working on proves to be an

00:01:28,740 --> 00:01:32,909
essential asset even if you're never

00:01:31,289 --> 00:01:35,579
going to be doing any low-level

00:01:32,909 --> 00:01:37,560
programming being able to troubleshoot

00:01:35,579 --> 00:01:39,590
different layers of the stack when

00:01:37,560 --> 00:01:42,270
things go wrong is still very useful

00:01:39,590 --> 00:01:44,700
also understanding the mechanics of the

00:01:42,270 --> 00:01:46,439
lower layers can inform how you build

00:01:44,700 --> 00:01:49,979
your application or short away for

00:01:46,439 --> 00:01:52,889
making it faster a case in point we all

00:01:49,979 --> 00:01:55,169
bundle our assets before we deploy our

00:01:52,889 --> 00:01:57,270
rails applications we are told that it

00:01:55,169 --> 00:01:59,669
speeds up page renders have you ever

00:01:57,270 --> 00:02:01,469
thought why if you don't know how web

00:01:59,669 --> 00:02:03,749
browsers work and if you don't know

00:02:01,469 --> 00:02:05,999
about TCP handshakes and how much of an

00:02:03,749 --> 00:02:08,940
overhead they add you probably didn't

00:02:05,999 --> 00:02:10,619
know why we bundle our assets having

00:02:08,940 --> 00:02:13,080
more knowledge of the network stack

00:02:10,619 --> 00:02:15,300
makes you a better web developer

00:02:13,080 --> 00:02:18,570
actually it makes you a better developer

00:02:15,300 --> 00:02:21,060
. so today we will be going deep into

00:02:18,570 --> 00:02:22,020
the lower layers of the network stack to

00:02:21,060 --> 00:02:24,360
gain a better

00:02:22,020 --> 00:02:27,600
if rudimentary understanding of how

00:02:24,360 --> 00:02:31,110
things work down there we all know that

00:02:27,600 --> 00:02:33,000
communication is hard and networks are

00:02:31,110 --> 00:02:35,070
all about communication

00:02:33,000 --> 00:02:37,500
during these days of social isolation

00:02:35,070 --> 00:02:39,960
with remote meetings and calls and check

00:02:37,500 --> 00:02:41,990
messages I'm sure we're all appreciating

00:02:39,960 --> 00:02:44,580
the joy of face-to-face communication

00:02:41,990 --> 00:02:46,320
communicating face-to-face is already

00:02:44,580 --> 00:02:48,780
hard communicating through all these

00:02:46,320 --> 00:02:51,240
other channels is even harder but

00:02:48,780 --> 00:02:53,820
humanity has built amazing communication

00:02:51,240 --> 00:02:56,160
tools people have built ruled and

00:02:53,820 --> 00:02:58,680
destroyed whole empires using nothing

00:02:56,160 --> 00:03:01,230
more than messengers or some script

00:02:58,680 --> 00:03:01,680
limbs on pieces of parchment paper that

00:03:01,230 --> 00:03:03,810
means

00:03:01,680 --> 00:03:05,610
when and if we get the fundamentals

00:03:03,810 --> 00:03:08,700
right we can communicate pretty

00:03:05,610 --> 00:03:10,950
effectively if you look at communication

00:03:08,700 --> 00:03:13,590
closely you'll realize that the most

00:03:10,950 --> 00:03:16,170
important aspects of it are about layers

00:03:13,590 --> 00:03:18,000
in the communication channel and what we

00:03:16,170 --> 00:03:20,070
can call the switching modes of the

00:03:18,000 --> 00:03:22,440
communication channel - so let's talk a

00:03:20,070 --> 00:03:25,470
little bit about those before we move on

00:03:22,440 --> 00:03:28,370
to the network stack let's talk about

00:03:25,470 --> 00:03:31,620
layers first as in most human endeavor

00:03:28,370 --> 00:03:33,540
communication is also layered the layers

00:03:31,620 --> 00:03:36,240
of communication built upon each other

00:03:33,540 --> 00:03:38,970
for example we send each other papers

00:03:36,240 --> 00:03:41,070
with ink on them in envelopes with

00:03:38,970 --> 00:03:44,250
addresses on them when the recipient

00:03:41,070 --> 00:03:45,990
opens the paper we send them they appear

00:03:44,250 --> 00:03:49,260
into the ink shapes and see the

00:03:45,990 --> 00:03:52,080
characters words sentences and extract

00:03:49,260 --> 00:03:54,210
meaning from that meaning they turn into

00:03:52,080 --> 00:03:56,760
understanding and feed it into their

00:03:54,210 --> 00:03:59,070
thinking we need to design communication

00:03:56,760 --> 00:04:01,050
systems where each layer serves a

00:03:59,070 --> 00:04:03,900
particular purpose like in that example

00:04:01,050 --> 00:04:06,390
of the letter exchange dividing up

00:04:03,900 --> 00:04:08,160
communication into layers also allows us

00:04:06,390 --> 00:04:11,490
to change some of the layers without

00:04:08,160 --> 00:04:13,410
affecting the message for example if the

00:04:11,490 --> 00:04:16,650
person we want to send a message to is

00:04:13,410 --> 00:04:18,450
close to where we are we can go and talk

00:04:16,650 --> 00:04:20,940
to them face-to-face instead of sending

00:04:18,450 --> 00:04:24,420
them a letter now the message in that

00:04:20,940 --> 00:04:28,200
case stays the same but the lower layers

00:04:24,420 --> 00:04:30,479
have changed they become verbal instead

00:04:28,200 --> 00:04:34,620
of written we want the same flexibility

00:04:30,479 --> 00:04:36,180
from our systems now let's move on to

00:04:34,620 --> 00:04:39,120
switching

00:04:36,180 --> 00:04:41,250
basically means the mud in which a

00:04:39,120 --> 00:04:44,120
communication channel between two

00:04:41,250 --> 00:04:46,530
entities is accessed by those entities

00:04:44,120 --> 00:04:48,840
there are fundamentally two different

00:04:46,530 --> 00:04:51,180
kinds of switching the first one is

00:04:48,840 --> 00:04:53,520
circuit switching and a good example of

00:04:51,180 --> 00:04:57,150
a circuit switched network is the analog

00:04:53,520 --> 00:04:59,130
telephone network the telephone network

00:04:57,150 --> 00:05:01,380
has many subscribers that are all

00:04:59,130 --> 00:05:03,570
connected to the network whenever one

00:05:01,380 --> 00:05:06,360
subscriber does another subscriber a

00:05:03,570 --> 00:05:08,250
circuit is formed between them actually

00:05:06,360 --> 00:05:10,620
the voltage over that circuit is what

00:05:08,250 --> 00:05:12,630
makes the landlines ring for the

00:05:10,620 --> 00:05:14,850
duration of the phone conversation the

00:05:12,630 --> 00:05:17,280
circuit has to be connected if it ever

00:05:14,850 --> 00:05:20,040
gets disconnected the conversation would

00:05:17,280 --> 00:05:21,960
be cut off that's why this is called a

00:05:20,040 --> 00:05:23,430
circuit switched member circuit

00:05:21,960 --> 00:05:25,650
switching makes establishing and

00:05:23,430 --> 00:05:28,050
maintaining communication easy but it's

00:05:25,650 --> 00:05:29,820
very inefficient even if the

00:05:28,050 --> 00:05:32,130
communication channel is not being used

00:05:29,820 --> 00:05:35,160
the resources are still being utilized

00:05:32,130 --> 00:05:36,780
and they're waiting connected the

00:05:35,160 --> 00:05:39,690
equivalent of circuit switching in real

00:05:36,780 --> 00:05:43,110
life would be to employ a messenger

00:05:39,690 --> 00:05:44,970
always waiting outside your door always

00:05:43,110 --> 00:05:47,270
ready to send your messages to your

00:05:44,970 --> 00:05:49,950
friends most of the time either the

00:05:47,270 --> 00:05:52,290
messenger would be idle waiting for you

00:05:49,950 --> 00:05:54,300
to communicate with someone or you would

00:05:52,290 --> 00:05:56,220
have sent the messenger off you can't

00:05:54,300 --> 00:06:00,000
send another message until the messenger

00:05:56,220 --> 00:06:01,890
has come back with a response another

00:06:00,000 --> 00:06:04,050
mode of switching is called packet

00:06:01,890 --> 00:06:06,990
switching a good example of packet

00:06:04,050 --> 00:06:08,520
switching is the postal network in the

00:06:06,990 --> 00:06:10,140
Postal Service if you want to

00:06:08,520 --> 00:06:12,870
communicate with a friend you write a

00:06:10,140 --> 00:06:17,040
letter and place it in an envelope and

00:06:12,870 --> 00:06:19,500
put it in a mail collection box a postal

00:06:17,040 --> 00:06:21,720
worker takes it to the post office where

00:06:19,500 --> 00:06:23,520
it gets sorted based on the address on

00:06:21,720 --> 00:06:26,460
the envelope it now gets sent to the

00:06:23,520 --> 00:06:28,860
head post office since in this case it's

00:06:26,460 --> 00:06:31,380
addressed overseas the head post-office

00:06:28,860 --> 00:06:34,080
sorts it and decides it should go on a

00:06:31,380 --> 00:06:36,210
plane to that different country now the

00:06:34,080 --> 00:06:38,580
letter enters another country's postal

00:06:36,210 --> 00:06:41,130
network the receiving head postal codes

00:06:38,580 --> 00:06:43,830
routes it to the regional post office

00:06:41,130 --> 00:06:46,470
the regional post office gives the

00:06:43,830 --> 00:06:48,840
letter to the postal worker who takes it

00:06:46,470 --> 00:06:51,150
to the correct address and places it

00:06:48,840 --> 00:06:53,250
your friends mailbox then your friend

00:06:51,150 --> 00:06:55,560
gets the envelope and reads the letter

00:06:53,250 --> 00:06:57,690
hopefully there are two important things

00:06:55,560 --> 00:07:00,660
to notice here no leg of the

00:06:57,690 --> 00:07:02,250
communication hogs any resources if you

00:07:00,660 --> 00:07:04,229
want to continue communicating with your

00:07:02,250 --> 00:07:09,120
friend you need to send another letter

00:07:04,229 --> 00:07:10,710
and two routing of the message crosses

00:07:09,120 --> 00:07:13,740
different networks that operate

00:07:10,710 --> 00:07:16,070
independently yet every point is able to

00:07:13,740 --> 00:07:19,199
route the message to the next point and

00:07:16,070 --> 00:07:21,330
every point in the route only needs to

00:07:19,199 --> 00:07:23,550
decide where the message is going to go

00:07:21,330 --> 00:07:26,190
next and no one has to know where your

00:07:23,550 --> 00:07:27,900
friend lives except the last postal

00:07:26,190 --> 00:07:30,450
worker who delivers the message to your

00:07:27,900 --> 00:07:35,430
end so we want to build something like

00:07:30,450 --> 00:07:37,500
this some smart people in early 1980s

00:07:35,430 --> 00:07:39,810
came together to standardize networks

00:07:37,500 --> 00:07:43,020
they created the open systems

00:07:39,810 --> 00:07:46,050
interconnection OSI port model of how

00:07:43,020 --> 00:07:48,300
such a system should operate the model

00:07:46,050 --> 00:07:51,000
consists of seven layers each with their

00:07:48,300 --> 00:07:54,650
independent responsibilities these are

00:07:51,000 --> 00:07:59,330
from bottom to top physical Data Link

00:07:54,650 --> 00:08:02,639
Network transport session presentation

00:07:59,330 --> 00:08:05,039
and application these seven layers make

00:08:02,639 --> 00:08:08,820
up the network stack on top of the stack

00:08:05,039 --> 00:08:12,419
sets your applications and services the

00:08:08,820 --> 00:08:15,090
OSI model is a concept and a reference

00:08:12,419 --> 00:08:17,400
the concrete implementation of a modern

00:08:15,090 --> 00:08:20,220
network stack that we will analyze is

00:08:17,400 --> 00:08:24,780
tcp/ip but we will still look at it from

00:08:20,220 --> 00:08:26,099
this perspective of the OSI model let's

00:08:24,780 --> 00:08:27,960
see how the stack works when an

00:08:26,099 --> 00:08:32,969
application on our computer wants to

00:08:27,960 --> 00:08:35,159
talk to another computer the application

00:08:32,969 --> 00:08:38,490
on our computer wants to send a piece of

00:08:35,159 --> 00:08:40,890
data it passes the data on to the

00:08:38,490 --> 00:08:43,140
application there the application layer

00:08:40,890 --> 00:08:46,200
adds some headers and footers and passes

00:08:43,140 --> 00:08:48,690
it on to the lower layer at each layer

00:08:46,200 --> 00:08:51,540
of the stack some data appropriate for

00:08:48,690 --> 00:08:53,779
that layer is appended you can think of

00:08:51,540 --> 00:08:57,810
these as envelopes with anomalous and

00:08:53,779 --> 00:08:59,850
when we get to the physical layer once

00:08:57,810 --> 00:09:02,730
the physical layer is done with it it

00:08:59,850 --> 00:09:04,920
gets transmitted to the other computer

00:09:02,730 --> 00:09:07,260
once the physical layer on the other

00:09:04,920 --> 00:09:09,870
computer receives the data it checks the

00:09:07,260 --> 00:09:11,760
unlock it verifies the integrity and

00:09:09,870 --> 00:09:14,850
makes sure it has received a message

00:09:11,760 --> 00:09:17,070
intended for that computer it strips the

00:09:14,850 --> 00:09:19,050
envelope for the physical layer and

00:09:17,070 --> 00:09:21,870
passes the payload to the layer above

00:09:19,050 --> 00:09:28,430
each layer does the same thing in turn

00:09:21,870 --> 00:09:31,560
until it gets all the way to the

00:09:28,430 --> 00:09:34,500
application layer the application layer

00:09:31,560 --> 00:09:36,540
also strips its data to finally the data

00:09:34,500 --> 00:09:39,630
gets passed to the application in the

00:09:36,540 --> 00:09:43,320
other computer and thus communication is

00:09:39,630 --> 00:09:46,500
enabled let's start diving in and

00:09:43,320 --> 00:09:49,230
starting from the physical layer here

00:09:46,500 --> 00:09:51,690
Alice is a lone computer sitting with no

00:09:49,230 --> 00:09:54,390
one to talk to she realizes Bob is

00:09:51,690 --> 00:09:56,370
nearby but they can't communicate until

00:09:54,390 --> 00:09:59,280
someone builds a physical link between

00:09:56,370 --> 00:10:02,100
them this link can be something as

00:09:59,280 --> 00:10:05,250
simple as a twisted pair cat five or six

00:10:02,100 --> 00:10:07,530
cable carrying electrical signals or it

00:10:05,250 --> 00:10:09,720
can be something like Wi-Fi carrying

00:10:07,530 --> 00:10:12,390
signal across the air using

00:10:09,720 --> 00:10:14,970
electromagnetic waves or it can be

00:10:12,390 --> 00:10:17,910
something as silly as pigeons carrying

00:10:14,970 --> 00:10:20,040
USB sticks the bottom line is it doesn't

00:10:17,910 --> 00:10:22,620
matter how the physical layer is formed

00:10:20,040 --> 00:10:25,160
what it needs to do is to be able to

00:10:22,620 --> 00:10:29,670
carry some sort of digital data as

00:10:25,160 --> 00:10:32,010
individual packets this was connecting

00:10:29,670 --> 00:10:34,950
just two computers Alice and Bob but

00:10:32,010 --> 00:10:36,720
what about Charlie are we going to

00:10:34,950 --> 00:10:37,050
connect all pairs of computers to each

00:10:36,720 --> 00:10:38,880
other

00:10:37,050 --> 00:10:41,240
no since that would grow coach

00:10:38,880 --> 00:10:44,340
quadratically in cost and complexity

00:10:41,240 --> 00:10:46,740
instead we are going to build a box in

00:10:44,340 --> 00:10:49,610
the middle and we're going to connect

00:10:46,740 --> 00:10:53,790
everyone to that box

00:10:49,610 --> 00:10:54,450
what this box is going to do is very

00:10:53,790 --> 00:10:57,360
simple

00:10:54,450 --> 00:10:59,550
whenever others send some signals to the

00:10:57,360 --> 00:11:01,520
network the box is just going to

00:10:59,550 --> 00:11:03,930
replicate the physical signals and

00:11:01,520 --> 00:11:06,600
repeat them to everyone else on the

00:11:03,930 --> 00:11:09,290
network this box is just a simple

00:11:06,600 --> 00:11:12,840
replicator and is called the hub

00:11:09,290 --> 00:11:15,150
thus a hub is a simple layer one device

00:11:12,840 --> 00:11:15,830
on the network it's the simplest Network

00:11:15,150 --> 00:11:18,740
equipment

00:11:15,830 --> 00:11:20,870
well actually a hot dog is quite

00:11:18,740 --> 00:11:24,800
wasteful since it keeps sending all the

00:11:20,870 --> 00:11:28,850
data to all the bodies we can solve this

00:11:24,800 --> 00:11:31,160
problem on layer to learn now we have

00:11:28,850 --> 00:11:33,860
the same physical Network but we want to

00:11:31,160 --> 00:11:36,590
have a new box that is smarter we want

00:11:33,860 --> 00:11:39,230
the new box to send the data only where

00:11:36,590 --> 00:11:42,410
it needs to go but to do that we need a

00:11:39,230 --> 00:11:44,510
new concept we need some addresses for

00:11:42,410 --> 00:11:47,840
each machine let's give all of these

00:11:44,510 --> 00:11:49,730
machines some addresses the addresses we

00:11:47,840 --> 00:11:53,930
give them in this case are 6 bytes long

00:11:49,730 --> 00:11:55,610
and we will call them MAC addresses now

00:11:53,930 --> 00:11:57,830
that we have MAC addresses we can

00:11:55,610 --> 00:12:00,860
require all messages to have a source

00:11:57,830 --> 00:12:02,600
and a destination address so the device

00:12:00,860 --> 00:12:04,790
in the middle can look at the data

00:12:02,600 --> 00:12:06,940
flowing through and can learn which

00:12:04,790 --> 00:12:09,800
computer is connected to which port

00:12:06,940 --> 00:12:12,650
afterwards between send the data to only

00:12:09,800 --> 00:12:15,950
the correct computer this device is

00:12:12,650 --> 00:12:18,230
called a switch a network switch so

00:12:15,950 --> 00:12:19,190
Alice now has to put together an

00:12:18,230 --> 00:12:21,920
Ethernet frame

00:12:19,190 --> 00:12:24,230
she puts the MAC addresses of Bob and

00:12:21,920 --> 00:12:26,660
herself as destination and source

00:12:24,230 --> 00:12:28,940
addresses not the length of the payload

00:12:26,660 --> 00:12:32,030
places the payload received from the

00:12:28,940 --> 00:12:33,850
upper layer in the stack and appends a

00:12:32,030 --> 00:12:36,830
checksum to prevent against corruption

00:12:33,850 --> 00:12:39,320
she takes that and sends it to the

00:12:36,830 --> 00:12:41,690
network when the switch receives it it

00:12:39,320 --> 00:12:43,970
knows Tony sent it to Bob's physical

00:12:41,690 --> 00:12:48,440
connection since the destination is

00:12:43,970 --> 00:12:51,650
Bob's Mac urges now let's take a look at

00:12:48,440 --> 00:12:53,390
the network there the problem with data

00:12:51,650 --> 00:12:55,550
link layer is this we can't

00:12:53,390 --> 00:12:57,380
realistically expect all the computers

00:12:55,550 --> 00:13:00,650
in the world to be connected to the same

00:12:57,380 --> 00:13:02,680
network in this example Alice is on a

00:13:00,650 --> 00:13:05,630
network which are Li Dave and error

00:13:02,680 --> 00:13:08,240
noticed Bob is not on this network now

00:13:05,630 --> 00:13:10,210
maybe he went to his vacation home how

00:13:08,240 --> 00:13:12,560
can Allah still communicate with Bob

00:13:10,210 --> 00:13:14,480
let's also assume for a moment that

00:13:12,560 --> 00:13:17,120
Charlie has another connection that is

00:13:14,480 --> 00:13:19,940
on the same local network as well that

00:13:17,120 --> 00:13:22,790
Charlie can inter mediate data transfer

00:13:19,940 --> 00:13:24,860
between Alice and Bob but how we only

00:13:22,790 --> 00:13:27,140
know how to do data transfer on a local

00:13:24,860 --> 00:13:27,590
network we now need to figure out how to

00:13:27,140 --> 00:13:30,950
do

00:13:27,590 --> 00:13:33,530
transfer on a network of networks thus

00:13:30,950 --> 00:13:36,410
MAC addresses lose their importance

00:13:33,530 --> 00:13:38,150
we need a new higher-level identifier

00:13:36,410 --> 00:13:40,390
for addressing nodes on different

00:13:38,150 --> 00:13:42,770
networks the most widely used

00:13:40,390 --> 00:13:45,740
implementation of layer 3 the networking

00:13:42,770 --> 00:13:48,650
layer is the Internet Protocol in IP

00:13:45,740 --> 00:13:51,650
each node is the sign of 4 bytes that is

00:13:48,650 --> 00:13:54,350
32-bit numeric address called the IP

00:13:51,650 --> 00:13:59,840
address so let's assign them to all the

00:13:54,350 --> 00:14:04,790
endpoints Alice has address 192 168 1 2

00:13:59,840 --> 00:14:07,760
Bob has 1 9 2 1 6 8 10 10 notice that

00:14:04,790 --> 00:14:10,490
Charlie has two IP addresses one on each

00:14:07,760 --> 00:14:12,650
network the analogy here is the

00:14:10,490 --> 00:14:15,290
following it's easy to describe a

00:14:12,650 --> 00:14:17,660
location to a local person you say it's

00:14:15,290 --> 00:14:19,610
on the corner of x and y but if you are

00:14:17,660 --> 00:14:21,890
describing the same location to a person

00:14:19,610 --> 00:14:24,110
from another country you would need to

00:14:21,890 --> 00:14:26,240
tell them which country which state

00:14:24,110 --> 00:14:29,420
which city which neighborhood as such

00:14:26,240 --> 00:14:31,220
that location is exactly that is the

00:14:29,420 --> 00:14:33,830
difference between MAC addresses and IP

00:14:31,220 --> 00:14:36,110
addresses MAC addresses only work on

00:14:33,830 --> 00:14:39,980
local networks but IP addresses work

00:14:36,110 --> 00:14:42,890
across networks now the floor Alice

00:14:39,980 --> 00:14:44,390
sends any data to do to Bob she needs to

00:14:42,890 --> 00:14:48,080
check to see if they're on the same

00:14:44,390 --> 00:14:51,560
network first she compares 192 168 1 2

00:14:48,080 --> 00:14:54,020
and 1 9 2 1 6 8 and 10 and decides that

00:14:51,560 --> 00:14:55,520
Bob is on a different network how does

00:14:54,020 --> 00:14:55,820
she do this we'll get to that in a

00:14:55,520 --> 00:14:59,570
minute

00:14:55,820 --> 00:15:01,930
well now Alice knows that she needs to

00:14:59,570 --> 00:15:05,390
put an IP packet together and she does

00:15:01,930 --> 00:15:09,380
she puts 4s version number because she's

00:15:05,390 --> 00:15:11,240
still using ipv4 and ipv6 yet she adds a

00:15:09,380 --> 00:15:13,700
time-to-live header which acts like a

00:15:11,240 --> 00:15:15,740
counter for the packet she adds her IP

00:15:13,700 --> 00:15:16,790
address and Bob's IP address as for some

00:15:15,740 --> 00:15:18,980
destination addresses

00:15:16,790 --> 00:15:22,310
she also calculates the checksum of the

00:15:18,980 --> 00:15:24,800
header and places into into a fuel in

00:15:22,310 --> 00:15:27,020
the IP packet header there are actually

00:15:24,800 --> 00:15:29,030
more accurate fuels than these but these

00:15:27,020 --> 00:15:30,980
are the most essential ones you can go

00:15:29,030 --> 00:15:33,740
to the website accompanying this talk to

00:15:30,980 --> 00:15:35,750
read what all the other headers are once

00:15:33,740 --> 00:15:38,000
she's built a header she attaches the

00:15:35,750 --> 00:15:40,930
payload given to the network there from

00:15:38,000 --> 00:15:45,040
the layer above the transport layer and

00:15:40,930 --> 00:15:48,730
hence the packet after China now charlie

00:15:45,040 --> 00:15:51,820
receives the packet and inspects it it

00:15:48,730 --> 00:15:53,950
sees that it's addressed to Bob he

00:15:51,820 --> 00:15:56,110
checks his own network connections to

00:15:53,950 --> 00:15:58,720
see where to send the packet off to next

00:15:56,110 --> 00:16:00,670
so that it gets delivered to Bob and

00:15:58,720 --> 00:16:02,410
Charlie notices that Bob is on the

00:16:00,670 --> 00:16:05,170
purple network that Charlie is also on

00:16:02,410 --> 00:16:08,800
so he sends the packet off to Bob in the

00:16:05,170 --> 00:16:11,560
other network thus Charlie has become a

00:16:08,800 --> 00:16:13,029
router between these two networks there

00:16:11,560 --> 00:16:15,310
could have been more routers between

00:16:13,029 --> 00:16:17,290
Alice and Bob but the result would have

00:16:15,310 --> 00:16:19,660
been the same every router that is

00:16:17,290 --> 00:16:21,700
connected to multiple networks has an

00:16:19,660 --> 00:16:23,740
algorithm to check for where to send a

00:16:21,700 --> 00:16:26,260
packet off to next for it to reach its

00:16:23,740 --> 00:16:28,240
destination this is not different than

00:16:26,260 --> 00:16:30,100
post offices around the world being able

00:16:28,240 --> 00:16:34,899
to route letters without having to know

00:16:30,100 --> 00:16:38,520
exactly where each recipient lives let's

00:16:34,899 --> 00:16:41,920
get back to that question from earlier

00:16:38,520 --> 00:16:44,560
how did Alice know that her and Bob were

00:16:41,920 --> 00:16:47,020
on different networks also how did she

00:16:44,560 --> 00:16:50,560
know to send the packet to Charlie and

00:16:47,020 --> 00:16:53,440
not Dave or ere the answer is that Alice

00:16:50,560 --> 00:16:55,510
has more than just her IP address she

00:16:53,440 --> 00:16:57,520
asked she needs two more pieces of

00:16:55,510 --> 00:17:00,070
information that describes the network

00:16:57,520 --> 00:17:03,940
she's on those are the subnet masks and

00:17:00,070 --> 00:17:06,010
the default gateway the subnet mask is

00:17:03,940 --> 00:17:08,860
for checking if two devices are on the

00:17:06,010 --> 00:17:11,230
same network this is how Alice uses the

00:17:08,860 --> 00:17:14,050
subnet mask to do that check she takes

00:17:11,230 --> 00:17:17,220
her IP address and her subnet mask and

00:17:14,050 --> 00:17:19,449
performs a bitwise and operation

00:17:17,220 --> 00:17:22,270
remember all these addresses are

00:17:19,449 --> 00:17:25,809
actually 32-bit numbers even though we

00:17:22,270 --> 00:17:28,660
write each byte as a decimal number the

00:17:25,809 --> 00:17:31,929
bitwise and is applied to these numbers

00:17:28,660 --> 00:17:34,030
binary representations like this and and

00:17:31,929 --> 00:17:38,170
with a 1 will always give you the

00:17:34,030 --> 00:17:41,530
original bit and an and with a 0 will

00:17:38,170 --> 00:17:43,720
always give you 0 so when we perform

00:17:41,530 --> 00:17:46,150
this calculation the subnet mask in this

00:17:43,720 --> 00:17:48,670
case has ones for the first three bytes

00:17:46,150 --> 00:17:51,429
and zeros for the last byte so it

00:17:48,670 --> 00:17:54,130
basically just zeros out the last byte

00:17:51,429 --> 00:17:54,880
of Alice's idea just so the result

00:17:54,130 --> 00:17:59,920
becomes

00:17:54,880 --> 00:18:03,340
192 168 1 0 now Alice does the same

00:17:59,920 --> 00:18:06,430
comparison with Bob the same calculation

00:18:03,340 --> 00:18:08,920
with Bob's IP address and her subnet

00:18:06,430 --> 00:18:11,950
mask she does the same bitwise and and

00:18:08,920 --> 00:18:15,550
it again zeros out the last byte of

00:18:11,950 --> 00:18:18,940
Bob's IP address so Alice gets 1 9 2 1 6

00:18:15,550 --> 00:18:21,730
8 10 and 0 she compares these two

00:18:18,940 --> 00:18:24,130
results and they're not the same so

00:18:21,730 --> 00:18:25,500
Alice and Bob are not on the same

00:18:24,130 --> 00:18:27,790
network

00:18:25,500 --> 00:18:30,490
there is one lingering question though

00:18:27,790 --> 00:18:33,400
how does Alice know where to send her

00:18:30,490 --> 00:18:36,430
packets to if she wants to send data to

00:18:33,400 --> 00:18:38,830
her default gateway charlie she only

00:18:36,430 --> 00:18:42,460
knows Chinese IP address which is 192

00:18:38,830 --> 00:18:45,370
168 1 1 but she does not know Chinese

00:18:42,460 --> 00:18:47,950
MAC address but we know that all common

00:18:45,370 --> 00:18:51,160
local network Alice needs to send a data

00:18:47,950 --> 00:18:53,950
link frame with Charlie's MAC address so

00:18:51,160 --> 00:18:56,380
how can she discover Chinese MAC address

00:18:53,950 --> 00:18:58,570
the answer is the address resolution

00:18:56,380 --> 00:19:01,660
protocol or art for short

00:18:58,570 --> 00:19:03,810
art is the network layer protocol to

00:19:01,660 --> 00:19:07,120
resolve IP addresses to MAC addresses

00:19:03,810 --> 00:19:09,040
how does it work very simple you ask

00:19:07,120 --> 00:19:12,310
everyone and the right person answers

00:19:09,040 --> 00:19:16,920
back alice puts together in our packet

00:19:12,310 --> 00:19:20,950
with the question who is 192 168 1 1 and

00:19:16,920 --> 00:19:22,390
broadcasts it on to the network the

00:19:20,950 --> 00:19:24,340
packet goes to all the machines on

00:19:22,390 --> 00:19:26,170
Alice's network they even there and just

00:19:24,340 --> 00:19:29,620
drop the packets since their IP address

00:19:26,170 --> 00:19:31,810
is not 1 9 2 1 6 8 1 1 but Charlie

00:19:29,620 --> 00:19:35,110
processes it and responds directly to

00:19:31,810 --> 00:19:36,070
Alice with a response our packets saying

00:19:35,110 --> 00:19:40,180
it's me

00:19:36,070 --> 00:19:42,970
I had the IP address 192 168 1 1 Alice

00:19:40,180 --> 00:19:45,790
upon receiving this message records the

00:19:42,970 --> 00:19:49,570
sender's MAC address and maps it with

00:19:45,790 --> 00:19:51,670
the IP address 192 168 1 she also keeps

00:19:49,570 --> 00:19:53,530
this record around so that she doesn't

00:19:51,670 --> 00:19:56,590
have to keep doing the same dance all

00:19:53,530 --> 00:19:58,930
the time and she where she records it is

00:19:56,590 --> 00:20:01,510
called the art table now that Alice

00:19:58,930 --> 00:20:04,000
knows Charlie's MAC address she can send

00:20:01,510 --> 00:20:07,450
her a key frame to Charlie by addressing

00:20:04,000 --> 00:20:08,400
it - Charlie's MAC address there is a

00:20:07,450 --> 00:20:11,130
handy tool

00:20:08,400 --> 00:20:13,350
right on UNIX and Windows systems which

00:20:11,130 --> 00:20:15,240
you can use to make queries or see the

00:20:13,350 --> 00:20:17,100
state of your art table like this you

00:20:15,240 --> 00:20:23,280
can go and check it out you can see it

00:20:17,100 --> 00:20:24,990
running on my computer there's one more

00:20:23,280 --> 00:20:26,850
con there's one more protocol that

00:20:24,990 --> 00:20:29,940
exists on the network layer and that is

00:20:26,850 --> 00:20:31,770
the ICMP protocol ICMP stands for

00:20:29,940 --> 00:20:34,290
Internet control message protocol and

00:20:31,770 --> 00:20:36,540
serves to provide control and diagnostic

00:20:34,290 --> 00:20:38,850
features on the network layer the

00:20:36,540 --> 00:20:42,000
simplest example of an ICMP message is

00:20:38,850 --> 00:20:46,650
the echo request message if Alice sends

00:20:42,000 --> 00:20:50,580
an echo request ICMP message to Bob Bob

00:20:46,650 --> 00:20:53,880
will answer with an echo response

00:20:50,580 --> 00:20:56,610
message this is the very simple ping

00:20:53,880 --> 00:20:59,309
pong mechanism so that's why this is

00:20:56,610 --> 00:21:02,280
called pinging a machine this is how the

00:20:59,309 --> 00:21:06,840
ping command works every time you do a

00:21:02,280 --> 00:21:09,330
ping 8888 your machine is sending an

00:21:06,840 --> 00:21:12,570
echo request message to the IP address

00:21:09,330 --> 00:21:14,370
and in return the remote party is

00:21:12,570 --> 00:21:16,830
sending back an echo response message

00:21:14,370 --> 00:21:19,260
when your machine receives the reply it

00:21:16,830 --> 00:21:22,920
calculates the time difference and shows

00:21:19,260 --> 00:21:25,580
the round-trip time now let's switch

00:21:22,920 --> 00:21:28,020
gears and move on to the transport layer

00:21:25,580 --> 00:21:29,670
now that we can send data packets

00:21:28,020 --> 00:21:31,320
between different machines on different

00:21:29,670 --> 00:21:34,170
networks we need a mechanism for

00:21:31,320 --> 00:21:36,570
transporting messages what do we mean by

00:21:34,170 --> 00:21:38,640
that let's go back to our postal service

00:21:36,570 --> 00:21:40,530
analogy when you send a letter to a

00:21:38,640 --> 00:21:42,780
different country you can also make a

00:21:40,530 --> 00:21:45,690
choice on what mechanism the network

00:21:42,780 --> 00:21:47,700
will use to transport your letter for

00:21:45,690 --> 00:21:49,950
example you can choose service delivery

00:21:47,700 --> 00:21:51,750
or airmail or you can choose to send

00:21:49,950 --> 00:21:54,690
your letter using registered mail so

00:21:51,750 --> 00:21:56,429
that we to track these choices exist

00:21:54,690 --> 00:21:59,130
outside of the operation of the network

00:21:56,429 --> 00:22:02,040
and provide the means of transport for

00:21:59,130 --> 00:22:03,780
your letter the simplest transport

00:22:02,040 --> 00:22:06,840
mechanism in the Internet Protocol suite

00:22:03,780 --> 00:22:09,540
is the user Datagram protocol or UDP for

00:22:06,840 --> 00:22:11,010
short it is a very simple message

00:22:09,540 --> 00:22:12,000
oriented protocol that is

00:22:11,010 --> 00:22:14,490
fire-and-forget

00:22:12,000 --> 00:22:16,650
it performs like the postcards you send

00:22:14,490 --> 00:22:18,750
to your friend you would not you would

00:22:16,650 --> 00:22:20,920
like the postcard to make it there but

00:22:18,750 --> 00:22:23,800
you probably wouldn't be that father

00:22:20,920 --> 00:22:25,810
didn't either before we talked about how

00:22:23,800 --> 00:22:27,940
you the key words we need to introduce

00:22:25,810 --> 00:22:31,330
yet another addressing concern and that

00:22:27,940 --> 00:22:33,970
is ports ports I like mail boxes on each

00:22:31,330 --> 00:22:36,670
IP address when you send a message to an

00:22:33,970 --> 00:22:38,530
IP address you need to also say which

00:22:36,670 --> 00:22:42,310
service at that address you want to talk

00:22:38,530 --> 00:22:44,560
thus we need the concept of port notice

00:22:42,310 --> 00:22:46,600
Alice has no ports in use but bob has

00:22:44,560 --> 00:22:47,820
many services that listen to various

00:22:46,600 --> 00:22:50,110
ports

00:22:47,820 --> 00:22:53,920
now Alice wants to send a quick message

00:22:50,110 --> 00:22:56,290
to Bob at port 53 she picks a random

00:22:53,920 --> 00:22:59,020
source port that is not used and places

00:22:56,290 --> 00:23:02,080
that in the UDP fragmentary she also

00:22:59,020 --> 00:23:04,240
places 53 as the destination port and as

00:23:02,080 --> 00:23:06,040
the length of the message and a checksum

00:23:04,240 --> 00:23:08,350
of the message to the UTP fragment

00:23:06,040 --> 00:23:11,170
header she that appends the payload that

00:23:08,350 --> 00:23:15,550
was handed by the upper layers and sends

00:23:11,170 --> 00:23:18,490
the UTB fragments all now when Bob

00:23:15,550 --> 00:23:21,040
receives it his transport layer parses

00:23:18,490 --> 00:23:22,810
the UDP fragment header and transfers

00:23:21,040 --> 00:23:27,010
the payload to the service listening to

00:23:22,810 --> 00:23:29,620
port 53 this is it there is nothing more

00:23:27,010 --> 00:23:32,820
and no state is stored on either end

00:23:29,620 --> 00:23:35,020
like we said it's fire-and-forget

00:23:32,820 --> 00:23:37,510
just to quickly demonstrate the

00:23:35,020 --> 00:23:40,210
shortcoming of UDP though let's look at

00:23:37,510 --> 00:23:40,930
what might happen if Alice sent two UDP

00:23:40,210 --> 00:23:43,210
Datagram

00:23:40,930 --> 00:23:46,630
Alice prepares the first UDP Datagram

00:23:43,210 --> 00:23:49,690
and time 0 she then creates another UDP

00:23:46,630 --> 00:23:52,060
Datagram and sends data it's entirely

00:23:49,690 --> 00:23:53,620
possible that the second Datagram takes

00:23:52,060 --> 00:23:56,230
a shorter path in the network and

00:23:53,620 --> 00:23:58,030
arrives before the first Datagram bob

00:23:56,230 --> 00:24:00,340
has no way of knowing that he received

00:23:58,030 --> 00:24:02,260
the packages on the wrong order since as

00:24:00,340 --> 00:24:05,010
we saw UDP has no information about

00:24:02,260 --> 00:24:07,720
sequence numbers or any kind of ordering

00:24:05,010 --> 00:24:09,970
unless the payload has some information

00:24:07,720 --> 00:24:11,260
about order Bob will process the

00:24:09,970 --> 00:24:14,380
messages in the wrong order

00:24:11,260 --> 00:24:16,930
so UDP is super lightweight not ordered

00:24:14,380 --> 00:24:18,670
and is best ever for example if one of

00:24:16,930 --> 00:24:20,950
these data grants had gotten lost along

00:24:18,670 --> 00:24:24,400
the way neither Alice nor Bob would have

00:24:20,950 --> 00:24:27,040
known that what happens if messages get

00:24:24,400 --> 00:24:27,610
Moscow let's look at a scenario in this

00:24:27,040 --> 00:24:29,800
scenario

00:24:27,610 --> 00:24:31,540
Alice and Bob want to decide on a time

00:24:29,800 --> 00:24:34,930
to me Alice sends a message to Bob

00:24:31,540 --> 00:24:36,310
saying meet at 1500 hours but then

00:24:34,930 --> 00:24:39,310
thing happened in one of the networks

00:24:36,310 --> 00:24:42,700
the UDP Datagram was traveling on and

00:24:39,310 --> 00:24:45,220
the Datagram got lost so but never got

00:24:42,700 --> 00:24:47,080
Alice's message so what should Alice -

00:24:45,220 --> 00:24:49,750
did they agree on a time just because

00:24:47,080 --> 00:24:51,430
Alice sent a message to Bob no because

00:24:49,750 --> 00:24:53,590
there's always the chance that Paul who

00:24:51,430 --> 00:24:56,170
never got Alice's message like in this

00:24:53,590 --> 00:24:59,980
case but there's another level to this

00:24:56,170 --> 00:25:05,500
in this scenario Alice's message does

00:24:59,980 --> 00:25:08,500
make it to Bob and Bob responds saying

00:25:05,500 --> 00:25:10,930
sounds good but that message never makes

00:25:08,500 --> 00:25:12,550
it back to Alice so Alice is feeling

00:25:10,930 --> 00:25:15,130
thinking that she sent a message to Bob

00:25:12,550 --> 00:25:17,110
but never heard back whereas Bob is not

00:25:15,130 --> 00:25:20,590
thinking they agreed on a time to meet

00:25:17,110 --> 00:25:23,680
should Bob be that short how can we make

00:25:20,590 --> 00:25:26,200
him even more sure maybe Bob should wait

00:25:23,680 --> 00:25:28,510
to hear back from Alice saying great see

00:25:26,200 --> 00:25:32,020
you then but what if Alice sends that

00:25:28,510 --> 00:25:35,050
message but that message gets lost now

00:25:32,020 --> 00:25:37,900
Alice is thinking they're on but bob has

00:25:35,050 --> 00:25:40,690
not gotten any confirmation this can go

00:25:37,900 --> 00:25:43,060
on and on and on without any resolution

00:25:40,690 --> 00:25:44,740
this is actually a classical computer

00:25:43,060 --> 00:25:47,500
science problem called the two generals

00:25:44,740 --> 00:25:51,550
problem and the problem in general is

00:25:47,500 --> 00:25:54,370
unsolvable so how can we address these

00:25:51,550 --> 00:25:56,980
shortcomings and how can we circumvent

00:25:54,370 --> 00:26:00,700
the two generals problem the answer is

00:25:56,980 --> 00:26:03,580
TCP transmission control protocol as

00:26:00,700 --> 00:26:05,650
opposed to UDP TCP is a highly complex

00:26:03,580 --> 00:26:08,650
protocol since in aims to provide many

00:26:05,650 --> 00:26:10,510
guarantees the key concepts in TCP are

00:26:08,650 --> 00:26:14,170
the notions of sequence numbers and

00:26:10,510 --> 00:26:15,640
acknowledgments each message in TCP has

00:26:14,170 --> 00:26:18,160
to have a sequence number that

00:26:15,640 --> 00:26:19,930
monotonically increases likewise each

00:26:18,160 --> 00:26:22,660
TCP message received needs to be

00:26:19,930 --> 00:26:25,570
acknowledged by an ACK message here's

00:26:22,660 --> 00:26:28,090
how it works when Alice wants to start

00:26:25,570 --> 00:26:30,310
talking to Bob using TCP she picks a

00:26:28,090 --> 00:26:32,830
random initial sequence number let's

00:26:30,310 --> 00:26:35,350
call a porta - and she builds a TCP

00:26:32,830 --> 00:26:37,720
message using that sequence number in

00:26:35,350 --> 00:26:41,770
this example alice is sending a message

00:26:37,720 --> 00:26:44,680
to Bob on port 80 this TCP segment is

00:26:41,770 --> 00:26:46,240
marked as a syn message since alice is

00:26:44,680 --> 00:26:48,400
just trying to synchronize right now

00:26:46,240 --> 00:26:51,210
she's not transmitting maybe it

00:26:48,400 --> 00:26:56,110
once the message is put together Alice

00:26:51,210 --> 00:26:58,960
sends it to Bob when Bob receives that

00:26:56,110 --> 00:27:01,090
message he now needs technology but

00:26:58,960 --> 00:27:03,130
since this is his first message to Alice

00:27:01,090 --> 00:27:06,190
- he also needs to pick a sequence

00:27:03,130 --> 00:27:08,410
number of his own and tamp it to us so

00:27:06,190 --> 00:27:12,340
he picks a random sequence number 1 2 3

00:27:08,410 --> 00:27:14,470
and builds a TCP segment here the ports

00:27:12,340 --> 00:27:17,290
are reversed since the data is now going

00:27:14,470 --> 00:27:20,230
back to whatever the service initially

00:27:17,290 --> 00:27:23,530
sent a message the segment is Mike as

00:27:20,230 --> 00:27:27,130
both a sin and an act message since Bob

00:27:23,530 --> 00:27:30,070
is both synchronizing and trying to

00:27:27,130 --> 00:27:31,809
acknowledge Alice's initial message he

00:27:30,070 --> 00:27:35,800
places one two three as the sequence

00:27:31,809 --> 00:27:38,170
number this time however he places an

00:27:35,800 --> 00:27:40,120
acknowledgment number in the segment by

00:27:38,170 --> 00:27:42,580
incrementing Alice's sequence number

00:27:40,120 --> 00:27:44,770
since bob has no extra data to send

00:27:42,580 --> 00:27:48,330
either the message is complete and Bob

00:27:44,770 --> 00:27:48,330
sends it back to Alice

00:27:55,429 --> 00:28:00,090
when Alice receives the same Acme

00:27:58,110 --> 00:28:02,880
segment the initial synchronization is

00:28:00,090 --> 00:28:05,970
complete at this point Alice knows that

00:28:02,880 --> 00:28:08,880
Bob got her sent message and she got Bob

00:28:05,970 --> 00:28:11,280
send message to now Alice can start

00:28:08,880 --> 00:28:12,210
sending data so she starts putting a TCP

00:28:11,280 --> 00:28:14,669
segment together

00:28:12,210 --> 00:28:17,820
she increments her sequence number which

00:28:14,669 --> 00:28:19,890
becomes 43 now she might TCP segment as

00:28:17,820 --> 00:28:22,350
an ack message because she's also

00:28:19,890 --> 00:28:25,919
acknowledging the receipt of Bob last

00:28:22,350 --> 00:28:28,260
syn ack message so she needs to also

00:28:25,919 --> 00:28:30,720
increment Bob sequence number and place

00:28:28,260 --> 00:28:32,820
it as the acknowledgement number Alice

00:28:30,720 --> 00:28:35,220
as the payload that she wants to send to

00:28:32,820 --> 00:28:39,510
Bob after this TCP segment header and

00:28:35,220 --> 00:28:42,090
sends the package of to Bob this is

00:28:39,510 --> 00:28:44,850
called a three-way handshake and is the

00:28:42,090 --> 00:28:46,590
signature of TCP communication of course

00:28:44,850 --> 00:28:48,750
this alone doesn't solve the problem

00:28:46,590 --> 00:28:50,970
we've encountered the port it just

00:28:48,750 --> 00:28:54,020
guarantees that East message received

00:28:50,970 --> 00:28:56,640
is associated with another message sent

00:28:54,020 --> 00:28:58,950
now let's see what happens if Alice's

00:28:56,640 --> 00:29:02,190
initial syn message gets lost

00:28:58,950 --> 00:29:04,380
Alice prepares her initial cynthia CP

00:29:02,190 --> 00:29:07,830
segment and her sequence number as

00:29:04,380 --> 00:29:10,320
before however as soon as she sends the

00:29:07,830 --> 00:29:13,049
same message she starts a timer if the

00:29:10,320 --> 00:29:16,140
same message gets lost and never reached

00:29:13,049 --> 00:29:19,950
Bob the timer will ultimately expire

00:29:16,140 --> 00:29:22,169
when that happens Alice will retry the

00:29:19,950 --> 00:29:23,520
same sin segment again she will reset

00:29:22,169 --> 00:29:26,250
the timer and start waiting for a

00:29:23,520 --> 00:29:31,440
response this time she gets the response

00:29:26,250 --> 00:29:33,570
from Bob just in time this timer is

00:29:31,440 --> 00:29:35,700
called the connection timer if Alice

00:29:33,570 --> 00:29:38,130
never got a reply from Bob after a few

00:29:35,700 --> 00:29:40,320
tries she would give up and notified the

00:29:38,130 --> 00:29:42,240
upper layers that there was a connection

00:29:40,320 --> 00:29:43,770
timer this is the reason why you

00:29:42,240 --> 00:29:45,780
sometimes see connection timed up

00:29:43,770 --> 00:29:48,360
messages if you're having connectivity

00:29:45,780 --> 00:29:48,960
problems the timer exists on Bob sites

00:29:48,360 --> 00:29:51,570
as well

00:29:48,960 --> 00:29:53,820
every time Alice or Bob send the message

00:29:51,570 --> 00:29:56,130
they start their timers and waits for an

00:29:53,820 --> 00:29:58,289
acknowledgment if the acknowledgment is

00:29:56,130 --> 00:30:01,559
not received on time the connection is

00:29:58,289 --> 00:30:03,480
the mosque this way TCP is able to

00:30:01,559 --> 00:30:05,220
ensure that either every message is

00:30:03,480 --> 00:30:08,280
guaranteed to have been delivered by

00:30:05,220 --> 00:30:08,710
receive an acknowledgment for it or that

00:30:08,280 --> 00:30:10,240
there's

00:30:08,710 --> 00:30:12,789
problem with the session and that

00:30:10,240 --> 00:30:14,529
everything should be dropped in that way

00:30:12,789 --> 00:30:16,440
it's an approach to addressing the

00:30:14,529 --> 00:30:19,210
journals problem without solving it

00:30:16,440 --> 00:30:21,340
moreover the sequence numbers in TCP

00:30:19,210 --> 00:30:23,919
messages ensure that even if segments

00:30:21,340 --> 00:30:26,260
appear out of order on Bob site Bob can

00:30:23,919 --> 00:30:28,899
still reorder them by using the sequence

00:30:26,260 --> 00:30:31,000
numbers as a summary TCP provides

00:30:28,899 --> 00:30:33,399
reliable and ordered communication

00:30:31,000 --> 00:30:35,799
between two parties but this comes at a

00:30:33,399 --> 00:30:37,210
really high cost each connection needs

00:30:35,799 --> 00:30:39,220
to to check out the running sequence

00:30:37,210 --> 00:30:41,289
number a timer for acknowledgments a

00:30:39,220 --> 00:30:43,750
list of which received sequence numbers

00:30:41,289 --> 00:30:45,909
were seen or not and a buffer to make

00:30:43,750 --> 00:30:46,630
sure messages can be reordered before

00:30:45,909 --> 00:30:49,390
being processed

00:30:46,630 --> 00:30:52,840
this makes TCP are really heavy weights

00:30:49,390 --> 00:30:55,750
protocol finally we're at the

00:30:52,840 --> 00:30:59,830
application layer did we skip layers 5 &

00:30:55,750 --> 00:31:01,539
6 yes since for most protocols layers 5

00:30:59,830 --> 00:31:03,789
to 7 have been combined into a single

00:31:01,539 --> 00:31:05,529
layer it turns out the increased

00:31:03,789 --> 00:31:07,809
flexibility of having separate layers

00:31:05,529 --> 00:31:10,179
decreases functionality so some of these

00:31:07,809 --> 00:31:11,679
layers are merged into one the first

00:31:10,179 --> 00:31:14,590
protocol I want to mention that the

00:31:11,679 --> 00:31:16,539
application layer is DNS as most of you

00:31:14,590 --> 00:31:18,580
might know DNS is the protocol that

00:31:16,539 --> 00:31:20,470
queries domain names and resolves them

00:31:18,580 --> 00:31:22,809
to IP addresses it can do more than that

00:31:20,470 --> 00:31:25,600
but that is the most basic functionality

00:31:22,809 --> 00:31:28,179
of the DNS protocol without going into

00:31:25,600 --> 00:31:30,820
too much detail but the NS query places

00:31:28,179 --> 00:31:33,220
the payload which in this case would be

00:31:30,820 --> 00:31:35,789
a domain name like Shopify calm and

00:31:33,220 --> 00:31:38,380
fills in the other fields of a DNS query

00:31:35,789 --> 00:31:39,700
since the DNS protocol is a binary

00:31:38,380 --> 00:31:42,730
protocol and since it has more

00:31:39,700 --> 00:31:44,260
functionality the actual request is much

00:31:42,730 --> 00:31:46,840
more complicated than this but this

00:31:44,260 --> 00:31:50,169
should give you a rough idea this query

00:31:46,840 --> 00:31:53,980
is sent by a UDP to the DNS server at

00:31:50,169 --> 00:31:59,760
port 53 the DNS server will look up the

00:31:53,980 --> 00:31:59,760
domain name and will return a response

00:32:01,110 --> 00:32:08,080
when Alice gets the response she looks

00:32:05,049 --> 00:32:10,690
up the DNS message and sees there is one

00:32:08,080 --> 00:32:13,630
answer and the address she queried for

00:32:10,690 --> 00:32:19,750
was thirty five one eighty five eighty

00:32:13,630 --> 00:32:22,240
two one three two now Alice is trying to

00:32:19,750 --> 00:32:24,730
go to the page HTTP

00:32:22,240 --> 00:32:27,460
Shopify comm / products which is a

00:32:24,730 --> 00:32:29,290
made-up page but it works when her

00:32:27,460 --> 00:32:31,960
browser hands off that requests from the

00:32:29,290 --> 00:32:34,179
network stack the stack looks up the IP

00:32:31,960 --> 00:32:36,250
address luckily we have just created the

00:32:34,179 --> 00:32:38,380
IP address of Shopify comm so it is

00:32:36,250 --> 00:32:41,380
cached we don't need to make another

00:32:38,380 --> 00:32:44,590
query to the network so now the network

00:32:41,380 --> 00:32:47,110
stack now prepares an HTTP request it

00:32:44,590 --> 00:32:49,270
takes the hostname of the URL and places

00:32:47,110 --> 00:32:52,000
into the host header and places the path

00:32:49,270 --> 00:32:55,179
of the URL into the resource path in the

00:32:52,000 --> 00:32:57,970
HTTP request line now that request is

00:32:55,179 --> 00:33:01,720
form it's passed to TCP for Transport

00:32:57,970 --> 00:33:05,020
TCP makes the handshake with 35 185 80

00:33:01,720 --> 00:33:08,530
to 1 3 2 and sends the payload to the

00:33:05,020 --> 00:33:11,170
server all of this is happening over IP

00:33:08,530 --> 00:33:13,920
with Alice sending data to her default

00:33:11,170 --> 00:33:16,510
gateway using Ethernet frames over Wi-Fi

00:33:13,920 --> 00:33:19,270
similarly a fiber-optic cable carries

00:33:16,510 --> 00:33:22,300
Ethernet frames so the Shopify server in

00:33:19,270 --> 00:33:24,420
an IP packet and the server extracts the

00:33:22,300 --> 00:33:27,010
payloads received at TCP port 80

00:33:24,420 --> 00:33:28,750
verifies acknowledgments and sequence

00:33:27,010 --> 00:33:31,240
numbers and since everything is in order

00:33:28,750 --> 00:33:33,820
it passes the data to the service that's

00:33:31,240 --> 00:33:36,370
loosening on that port that application

00:33:33,820 --> 00:33:39,460
in this case is nginx and the next text

00:33:36,370 --> 00:33:41,610
HTTP request parses it and decides that

00:33:39,460 --> 00:33:44,590
it should be passed to the puma

00:33:41,610 --> 00:33:46,480
application server when puma receives

00:33:44,590 --> 00:33:48,850
the message it converts it to a rack

00:33:46,480 --> 00:33:51,400
request and sends it to the booted

00:33:48,850 --> 00:33:53,679
bracket the rack

00:33:51,400 --> 00:33:56,679
ACK the rack application though is

00:33:53,679 --> 00:33:59,350
actually a rails application which then

00:33:56,679 --> 00:34:01,150
matches the request to a route and calls

00:33:59,350 --> 00:34:03,550
the products controller the controller

00:34:01,150 --> 00:34:06,400
queries the products model renders the

00:34:03,550 --> 00:34:09,879
response as a view the view render gets

00:34:06,400 --> 00:34:13,330
converted to a rack response which gets

00:34:09,879 --> 00:34:16,899
passed on to Puma which then returns it

00:34:13,330 --> 00:34:17,619
as an HTTP response to nginx now I

00:34:16,899 --> 00:34:20,800
reached

00:34:17,619 --> 00:34:22,629
TP response is ready note that all the

00:34:20,800 --> 00:34:25,500
bread parts in this response actually

00:34:22,629 --> 00:34:29,409
came from our react rails application

00:34:25,500 --> 00:34:31,629
all the server has to do now is 10 TCP

00:34:29,409 --> 00:34:34,119
packets back to Alice's browser which

00:34:31,629 --> 00:34:34,929
then parses the HTTP response and

00:34:34,119 --> 00:34:37,929
renders

00:34:34,929 --> 00:34:41,559
Shopify product space whew what a

00:34:37,929 --> 00:34:43,659
journey before I leave you I want to

00:34:41,559 --> 00:34:46,240
mention two tools you can use to broaden

00:34:43,659 --> 00:34:49,059
your understanding of these concepts the

00:34:46,240 --> 00:34:51,690
first a desktop tool named Wireshark and

00:34:49,059 --> 00:34:55,000
it's command-line cousin turn jerk

00:34:51,690 --> 00:34:57,220
Wireshark is a network capture analysis

00:34:55,000 --> 00:34:59,530
and dissection tool it can show you the

00:34:57,220 --> 00:35:01,900
parts of captured packets and perform

00:34:59,530 --> 00:35:04,059
session analysis anymore it's a really

00:35:01,900 --> 00:35:07,059
powerful tool and you can learn a lot by

00:35:04,059 --> 00:35:10,030
just playing around with it another tool

00:35:07,059 --> 00:35:12,670
is an map and map is the network scanner

00:35:10,030 --> 00:35:14,859
and security tool it came to port scans

00:35:12,670 --> 00:35:16,540
discover hidden services and specially

00:35:14,859 --> 00:35:19,150
crafted messages to other machines etc

00:35:16,540 --> 00:35:24,930
go and take a look at them play around

00:35:19,150 --> 00:35:28,300
with them so a quick recap number one

00:35:24,930 --> 00:35:30,339
layered stacks are important they give

00:35:28,300 --> 00:35:33,250
us flexibility of being able to change

00:35:30,339 --> 00:35:36,880
the underlying implementations packet

00:35:33,250 --> 00:35:38,380
switching gives us power and you really

00:35:36,880 --> 00:35:41,770
need to know the strengths and

00:35:38,380 --> 00:35:44,130
weaknesses of your tools and you need to

00:35:41,770 --> 00:35:47,380
pick the right one for the job finally

00:35:44,130 --> 00:35:49,720
always go deep in your domain you will

00:35:47,380 --> 00:35:54,250
discover many interesting things and

00:35:49,720 --> 00:35:57,099
learn a lot you can find more resources

00:35:54,250 --> 00:36:00,520
on the website that is associated with

00:35:57,099 --> 00:36:03,490
this talk HTTP peeling away the layers

00:36:00,520 --> 00:36:08,339
net you can also reach out to me on

00:36:03,490 --> 00:36:08,339

YouTube URL: https://www.youtube.com/watch?v=xPJgSca6TJc


