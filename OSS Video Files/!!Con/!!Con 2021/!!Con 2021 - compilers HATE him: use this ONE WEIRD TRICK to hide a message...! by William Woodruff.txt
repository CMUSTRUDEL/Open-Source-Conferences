Title: !!Con 2021 - compilers HATE him: use this ONE WEIRD TRICK to hide a message...! by William Woodruff
Publication date: 2021-07-06
Playlist: !!Con 2021
Description: 
	compilers HATE him: use this ONE WEIRD TRICK to hide a message in your x86 program!! by William Woodruff

Steganography is the art of hiding (not encrypting!) messages within otherwise inconspicuous data. Typical steganographic techniques involve media formats: images, movies, and audio. But what if we can hide messages within compiled programs themselves?? This talk will go through a whirlwind tour of steganography and the x86 architecture, and then show you ONE WEIRD TRICK in x86’s instruction encoding that allows us to do exactly that!

William Woodruff is a security researcher at Trail of Bits, primarily doing DARPA-funded research into program (LLVM) and binary (x86) analysis. During his free time, he likes to blog, ride bicycles, and do a bit of open source work (most recently in Rust). He’s slowly working on completing the system of German Transcendental Idealism.
Captions: 
	00:00:12,719 --> 00:00:15,599
uh like i'm saying my name is william

00:00:14,160 --> 00:00:16,640
and uh this is uh one

00:00:15,599 --> 00:00:19,199
weird trick you can use to hide a

00:00:16,640 --> 00:00:20,160
message in your x86 program um so first

00:00:19,199 --> 00:00:21,840
uh let's talk briefly about

00:00:20,160 --> 00:00:24,160
steganography um secondography is the

00:00:21,840 --> 00:00:25,840
heart the art of hiding data within data

00:00:24,160 --> 00:00:27,119
it comes from these two greek words and

00:00:25,840 --> 00:00:28,400
i like to think of it personally as

00:00:27,119 --> 00:00:30,800
cryptographies

00:00:28,400 --> 00:00:31,840
less formal and uh less useful sibling

00:00:30,800 --> 00:00:33,920
in most cases

00:00:31,840 --> 00:00:35,360
um it does have a few limited cases uses

00:00:33,920 --> 00:00:37,280
in the form of covert channels

00:00:35,360 --> 00:00:39,120
and secret metadata you often uh one

00:00:37,280 --> 00:00:40,000
famous use of it was actually an mmorpg

00:00:39,120 --> 00:00:41,600
to hide uh

00:00:40,000 --> 00:00:43,120
secret messages to find secret servers

00:00:41,600 --> 00:00:45,120
being run by by

00:00:43,120 --> 00:00:47,120
unauthorized users and also you see it

00:00:45,120 --> 00:00:48,800
being used for fun by cdf players

00:00:47,120 --> 00:00:50,480
uh but in general it's sort of less less

00:00:48,800 --> 00:00:53,760
useful than uh the more

00:00:50,480 --> 00:00:55,760
formal domain of cryptography um

00:00:53,760 --> 00:00:57,360
however uh to get briefly into it the

00:00:55,760 --> 00:00:59,359
theory of operation behind almost all

00:00:57,360 --> 00:01:01,359
segment graphic techniques is you take

00:00:59,359 --> 00:01:02,160
some some uh input format uh whose

00:01:01,359 --> 00:01:04,320
contents can

00:01:02,160 --> 00:01:05,680
plausibly vary very slightly uh and

00:01:04,320 --> 00:01:06,640
encode secret messages within those

00:01:05,680 --> 00:01:08,880
variations

00:01:06,640 --> 00:01:09,680
a good example of this is the rgb 24-bit

00:01:08,880 --> 00:01:12,000
color space

00:01:09,680 --> 00:01:13,439
these two colors below are nearly

00:01:12,000 --> 00:01:14,799
identical they're one bit off

00:01:13,439 --> 00:01:16,960
uh and human beings can't tell the

00:01:14,799 --> 00:01:18,799
difference but computer certainly can so

00:01:16,960 --> 00:01:20,799
if we take an input file that's encoded

00:01:18,799 --> 00:01:22,400
using the 24-bit rgb color space

00:01:20,799 --> 00:01:23,920
and we tweak these values very slightly

00:01:22,400 --> 00:01:24,560
we can use those tweaked bits to hide a

00:01:23,920 --> 00:01:26,080
message

00:01:24,560 --> 00:01:28,320
that only other people in the know can

00:01:26,080 --> 00:01:30,720
can decode um

00:01:28,320 --> 00:01:31,840
and uh this talk is going to be about uh

00:01:30,720 --> 00:01:33,280
stag using

00:01:31,840 --> 00:01:35,040
one of them formats like images video

00:01:33,280 --> 00:01:37,439
audio or text files but

00:01:35,040 --> 00:01:38,799
just for motivation uh in this case

00:01:37,439 --> 00:01:40,560
these two commands below

00:01:38,799 --> 00:01:42,079
hide and extract a picture of db cooper

00:01:40,560 --> 00:01:44,240
from this picture of bigfoot

00:01:42,079 --> 00:01:45,200
uh and here's that file i'll upload the

00:01:44,240 --> 00:01:45,840
slides later you can actually try this

00:01:45,200 --> 00:01:47,200
for yourself

00:01:45,840 --> 00:01:49,200
but this file actually has another image

00:01:47,200 --> 00:01:50,320
hidden within it and obviously you

00:01:49,200 --> 00:01:51,280
wouldn't be able to know this unless

00:01:50,320 --> 00:01:53,439
you wouldn't be able to extract unless

00:01:51,280 --> 00:01:55,119
you knew ahead of time that it was

00:01:53,439 --> 00:01:56,880
encoded using stagheid which is a

00:01:55,119 --> 00:01:59,280
publicly available tool you can install

00:01:56,880 --> 00:02:00,880
uh from ubuntu or any other by linux

00:01:59,280 --> 00:02:02,719
distro

00:02:00,880 --> 00:02:04,399
um so we'll talk about staton computer

00:02:02,719 --> 00:02:05,920
programs uh so first we've asked you

00:02:04,399 --> 00:02:08,080
know what would it look like to actually

00:02:05,920 --> 00:02:09,200
stack a compiled binary unlike the

00:02:08,080 --> 00:02:10,399
formats that i talked about before you

00:02:09,200 --> 00:02:12,319
know image media

00:02:10,399 --> 00:02:15,120
image formats video formats audio

00:02:12,319 --> 00:02:17,120
formats uh you can't do small

00:02:15,120 --> 00:02:18,239
changes small perturbations to to

00:02:17,120 --> 00:02:19,520
computer programs

00:02:18,239 --> 00:02:20,560
small changes to computer programs

00:02:19,520 --> 00:02:21,520
produce significant significant

00:02:20,560 --> 00:02:24,560
behavioral changes

00:02:21,520 --> 00:02:27,120
hoping a single bit willy-nilly means uh

00:02:24,560 --> 00:02:28,480
changing an ad into a sub or changing uh

00:02:27,120 --> 00:02:30,080
your your operands

00:02:28,480 --> 00:02:31,760
drastically in ways that that

00:02:30,080 --> 00:02:32,800
fundamentally break the correctness of

00:02:31,760 --> 00:02:34,720
the program

00:02:32,800 --> 00:02:36,319
um transformations also have to preserve

00:02:34,720 --> 00:02:37,920
environmental assumptions like binary

00:02:36,319 --> 00:02:39,920
relocations relative addressing and

00:02:37,920 --> 00:02:41,680
offsets within the compiled binary

00:02:39,920 --> 00:02:43,200
uh because these these environmental

00:02:41,680 --> 00:02:44,160
assumptions are made when loading the

00:02:43,200 --> 00:02:46,720
binary uh

00:02:44,160 --> 00:02:47,360
when executing it or when loading it

00:02:46,720 --> 00:02:50,160
into another

00:02:47,360 --> 00:02:51,360
binary or anything else of that sort uh

00:02:50,160 --> 00:02:52,879
so we can't just go around changing

00:02:51,360 --> 00:02:54,000
things willingly the way we can for an

00:02:52,879 --> 00:02:55,760
image file

00:02:54,000 --> 00:02:56,640
um so to understand how we're gonna do

00:02:55,760 --> 00:02:57,920
this we have to talk a little bit about

00:02:56,640 --> 00:02:59,760
x864

00:02:57,920 --> 00:03:01,920
um a key thing to understand about x864

00:02:59,760 --> 00:03:03,920
is that it's a massive and ancient

00:03:01,920 --> 00:03:05,920
isa uh you can trace its lineage all the

00:03:03,920 --> 00:03:08,560
way back to 1972 with the 808

00:03:05,920 --> 00:03:10,080
um and it's basically been stable with

00:03:08,560 --> 00:03:12,560
the exception of a bunch of extensions

00:03:10,080 --> 00:03:13,200
since 2003 with the amd64 64-bit

00:03:12,560 --> 00:03:15,120
extension

00:03:13,200 --> 00:03:16,080
to the original architecture um it's

00:03:15,120 --> 00:03:17,519
known as a cisco architecture which

00:03:16,080 --> 00:03:18,480
means it's complex instead of risk which

00:03:17,519 --> 00:03:20,080
is reduced

00:03:18,480 --> 00:03:21,280
uh and one of its relatively unique

00:03:20,080 --> 00:03:23,200
features is that it has a variable

00:03:21,280 --> 00:03:24,400
length encoding up to 15 bytes

00:03:23,200 --> 00:03:26,799
um it's also a registered memory

00:03:24,400 --> 00:03:28,480
architecture which means that uh

00:03:26,799 --> 00:03:29,840
its operations can actually take either

00:03:28,480 --> 00:03:31,440
register or memory

00:03:29,840 --> 00:03:33,519
operands in contrast to a load store

00:03:31,440 --> 00:03:34,959
architecture which can only take

00:03:33,519 --> 00:03:36,239
register operands for most operations

00:03:34,959 --> 00:03:36,720
and there are separate operations that

00:03:36,239 --> 00:03:38,799
load

00:03:36,720 --> 00:03:40,640
values into registers and these these

00:03:38,799 --> 00:03:41,599
last two points make x86 a very very

00:03:40,640 --> 00:03:43,280
different isa

00:03:41,599 --> 00:03:45,200
conceptually and in terms of encoding

00:03:43,280 --> 00:03:47,280
from risk or even just

00:03:45,200 --> 00:03:48,720
relatively simple architectures like arm

00:03:47,280 --> 00:03:51,519
mips risk five

00:03:48,720 --> 00:03:54,959
um even even other sisk architectures

00:03:51,519 --> 00:03:57,760
are not nearly as complicated as x86 is

00:03:54,959 --> 00:03:58,080
um so to get into things here's here's a

00:03:57,760 --> 00:03:59,680
uh

00:03:58,080 --> 00:04:01,280
uh visualization of xc6's instruction

00:03:59,680 --> 00:04:03,680
format this is this is an approximate an

00:04:01,280 --> 00:04:05,200
over approximation of x86's format but

00:04:03,680 --> 00:04:06,720
it gives you uh an idea of sort of the

00:04:05,200 --> 00:04:07,680
complexity we're dealing with and for

00:04:06,720 --> 00:04:08,720
the purposes of this technique we're

00:04:07,680 --> 00:04:09,360
only going to look at exactly two of

00:04:08,720 --> 00:04:10,799
these bytes

00:04:09,360 --> 00:04:12,720
we want to look at the op code byte and

00:04:10,799 --> 00:04:14,640
the moderam byte um i'll talk a little

00:04:12,720 --> 00:04:16,160
bit about those in a moment um so

00:04:14,640 --> 00:04:18,239
to understand what these bytes do you

00:04:16,160 --> 00:04:20,400
have to understand that uh

00:04:18,239 --> 00:04:21,600
uh xb6 is a whole lot of different ways

00:04:20,400 --> 00:04:22,720
to encode operands

00:04:21,600 --> 00:04:24,880
uh and one of the ways it does that is

00:04:22,720 --> 00:04:26,320
the modern byte uh the modern byte

00:04:24,880 --> 00:04:28,320
encodes uh

00:04:26,320 --> 00:04:29,840
two different kinds of operand uh or

00:04:28,320 --> 00:04:31,040
three different kinds of of operand

00:04:29,840 --> 00:04:32,400
techniques it encodes

00:04:31,040 --> 00:04:33,759
registered register operations

00:04:32,400 --> 00:04:35,280
registered memory operations and memory

00:04:33,759 --> 00:04:36,400
to register operations so you see those

00:04:35,280 --> 00:04:38,800
three above you can do

00:04:36,400 --> 00:04:40,639
you know add two registers together uh

00:04:38,800 --> 00:04:42,479
add a register and a memory location

00:04:40,639 --> 00:04:44,240
into a register or at original memory

00:04:42,479 --> 00:04:46,000
location into the memory location

00:04:44,240 --> 00:04:47,680
uh the way that the modern byte encodes

00:04:46,000 --> 00:04:49,360
those is with this mode selector

00:04:47,680 --> 00:04:51,040
followed by a register selector followed

00:04:49,360 --> 00:04:51,680
by a register or memory selector

00:04:51,040 --> 00:04:55,360
depending on

00:04:51,680 --> 00:04:56,639
the value of mode um 64-bit x86

00:04:55,360 --> 00:04:58,320
complicates this a little bit by adding

00:04:56,639 --> 00:05:00,240
the rex r and rex b

00:04:58,320 --> 00:05:01,680
uh bits but the essential mode of

00:05:00,240 --> 00:05:04,960
operation is the same

00:05:01,680 --> 00:05:06,479
um so uh a key thing that i that i i

00:05:04,960 --> 00:05:08,160
kind of glazed over there intentionally

00:05:06,479 --> 00:05:10,880
is that uh mod

00:05:08,160 --> 00:05:11,919
moderam reg and modern rm encode four

00:05:10,880 --> 00:05:13,280
possible states

00:05:11,919 --> 00:05:15,120
and yet there are only three encoding

00:05:13,280 --> 00:05:17,120
forms um

00:05:15,120 --> 00:05:18,880
and so so you know what's going on here

00:05:17,120 --> 00:05:20,800
and the answer is if we go back one

00:05:18,880 --> 00:05:22,720
uh the operand order that you see here

00:05:20,800 --> 00:05:25,600
of eax ebx or ax

00:05:22,720 --> 00:05:26,479
ebx with the ebx register opera rather a

00:05:25,600 --> 00:05:27,680
memory operand

00:05:26,479 --> 00:05:30,960
uh that order is controlled by the

00:05:27,680 --> 00:05:32,479
operand uh uh op code uh direction bit

00:05:30,960 --> 00:05:34,800
so there's another bit inside of that

00:05:32,479 --> 00:05:36,000
you know uh opcode byte that i mentioned

00:05:34,800 --> 00:05:37,039
earlier that controls the direction of

00:05:36,000 --> 00:05:39,120
these operands

00:05:37,039 --> 00:05:40,720
so there's actually four possible states

00:05:39,120 --> 00:05:41,680
but only three encoding forms and what

00:05:40,720 --> 00:05:42,960
that means is there's actually two

00:05:41,680 --> 00:05:44,400
different ways to encode

00:05:42,960 --> 00:05:46,080
register register operands using the

00:05:44,400 --> 00:05:47,360
modern byte in x86

00:05:46,080 --> 00:05:48,720
uh this isn't really documented anywhere

00:05:47,360 --> 00:05:49,360
but it's sort of it's it's a logical

00:05:48,720 --> 00:05:50,960
consequence

00:05:49,360 --> 00:05:53,280
of how the modern byte works with the

00:05:50,960 --> 00:05:55,600
direction bit inside of the opcode

00:05:53,280 --> 00:05:57,199
so you know this is this is exactly that

00:05:55,600 --> 00:05:58,800
if you actually look at x86's uh

00:05:57,199 --> 00:05:59,919
you know opcode tables these ones are

00:05:58,800 --> 00:06:00,400
from the intel software development

00:05:59,919 --> 00:06:01,680
manual

00:06:00,400 --> 00:06:03,039
you'll see that there are two different

00:06:01,680 --> 00:06:04,160
or at least two different variants for

00:06:03,039 --> 00:06:07,520
many op codes

00:06:04,160 --> 00:06:10,479
that have mod rmr variant and a uh

00:06:07,520 --> 00:06:11,120
uh or sorry an add rmr or an add rrm

00:06:10,479 --> 00:06:12,560
variant

00:06:11,120 --> 00:06:13,680
these two have identical semantics when

00:06:12,560 --> 00:06:15,039
they're used in register register mode

00:06:13,680 --> 00:06:16,160
but they have different semantics based

00:06:15,039 --> 00:06:17,840
on the direction bit when they're used

00:06:16,160 --> 00:06:20,080
in register memory or memory register

00:06:17,840 --> 00:06:22,160
mode uh

00:06:20,080 --> 00:06:24,160
so what you'll see here is you have two

00:06:22,160 --> 00:06:26,479
uh encodings that have the same length

00:06:24,160 --> 00:06:28,319
right they have uh they're both uh zero

00:06:26,479 --> 00:06:29,120
one zero three followed by the model m

00:06:28,319 --> 00:06:31,039
byte for the actual

00:06:29,120 --> 00:06:32,720
uh operating codeine so both two bytes

00:06:31,039 --> 00:06:33,840
long uh they have identical semantics so

00:06:32,720 --> 00:06:35,759
they both ads they both have the same

00:06:33,840 --> 00:06:38,560
flags operations they have the same

00:06:35,759 --> 00:06:39,520
timing behavior et cetera uh but we can

00:06:38,560 --> 00:06:40,639
select between them

00:06:39,520 --> 00:06:42,960
for one bit of second graphic

00:06:40,639 --> 00:06:44,319
information so every time we see

00:06:42,960 --> 00:06:45,680
an instruction that looks like this in a

00:06:44,319 --> 00:06:46,319
program we can encode one bit of

00:06:45,680 --> 00:06:49,759
information

00:06:46,319 --> 00:06:51,759
by by twiddling uh that encoding

00:06:49,759 --> 00:06:52,880
so uh the cool thing about this is this

00:06:51,759 --> 00:06:54,319
actually works for more than just ad it

00:06:52,880 --> 00:06:56,160
works for a key subset of x86

00:06:54,319 --> 00:06:57,280
instructions it works for add add carry

00:06:56,160 --> 00:07:00,319
sub sub borrow

00:06:57,280 --> 00:07:00,880
and xor xor and or xor maven comp uh all

00:07:00,319 --> 00:07:02,800
of which

00:07:00,880 --> 00:07:04,560
fortunately for us except for ad carry

00:07:02,800 --> 00:07:05,919
and sub borrow are extremely common in

00:07:04,560 --> 00:07:07,120
x86 binaries

00:07:05,919 --> 00:07:08,960
and even though i mentioned that it's a

00:07:07,120 --> 00:07:10,560
little bit different in exodus 664 this

00:07:08,960 --> 00:07:11,840
all still works in 64-bit code

00:07:10,560 --> 00:07:13,759
because the the basic operation of

00:07:11,840 --> 00:07:15,199
modern byte is still preserved even with

00:07:13,759 --> 00:07:17,280
the rex prefix

00:07:15,199 --> 00:07:19,199
so we can actually use this on like a

00:07:17,280 --> 00:07:20,479
massive swath of x86's encoded operand

00:07:19,199 --> 00:07:23,919
space at least for common

00:07:20,479 --> 00:07:24,960
for common binaries um so to put this

00:07:23,919 --> 00:07:26,000
all together we're going to take our

00:07:24,960 --> 00:07:27,520
secret message and we're going to code

00:07:26,000 --> 00:07:28,560
into a secret bit string

00:07:27,520 --> 00:07:30,160
we're then going to take our target

00:07:28,560 --> 00:07:31,360
program and pass it through an x86

00:07:30,160 --> 00:07:32,160
instruction encoder to get our decoded

00:07:31,360 --> 00:07:33,120
semantics

00:07:32,160 --> 00:07:34,240
we're going to iterate through each of

00:07:33,120 --> 00:07:35,440
those and then we're going to rewrite

00:07:34,240 --> 00:07:37,280
them to match the secret bit strings

00:07:35,440 --> 00:07:38,960
we'll select one or the other based on

00:07:37,280 --> 00:07:40,720
which bit in the bit string well we want

00:07:38,960 --> 00:07:42,160
to encode finally we'll write that out

00:07:40,720 --> 00:07:44,000
as our new fully functional executable

00:07:42,160 --> 00:07:45,520
that contains our secret message

00:07:44,000 --> 00:07:47,199
um i'll quickly walk through the code

00:07:45,520 --> 00:07:48,720
for this uh like i said there's

00:07:47,199 --> 00:07:50,720
there's you know a whole bunch of

00:07:48,720 --> 00:07:52,080
operations we can use add is shown below

00:07:50,720 --> 00:07:53,199
uh there's four possible variants

00:07:52,080 --> 00:07:55,039
this is exactly how it works at the

00:07:53,199 --> 00:07:57,759
assembler at the binary level the sub

00:07:55,039 --> 00:07:58,639
the disassembler sees things

00:07:57,759 --> 00:07:59,680
in order to understand how much

00:07:58,639 --> 00:08:01,039
information we can actually pack in we

00:07:59,680 --> 00:08:02,000
have to profile the binary so that's

00:08:01,039 --> 00:08:04,000
what we're doing here

00:08:02,000 --> 00:08:05,199
obviously just uh moving through every

00:08:04,000 --> 00:08:06,319
uh instruction in the program and

00:08:05,199 --> 00:08:06,960
checking whether it's in our supported

00:08:06,319 --> 00:08:08,000
op codes

00:08:06,960 --> 00:08:09,120
whether it's a registered register

00:08:08,000 --> 00:08:12,080
operation since that's the only time we

00:08:09,120 --> 00:08:13,520
can flip and then we save it if it is

00:08:12,080 --> 00:08:15,280
um and then finally to actually do our

00:08:13,520 --> 00:08:16,400
rewrite uh we're gonna select the new

00:08:15,280 --> 00:08:19,520
code uh which is

00:08:16,400 --> 00:08:21,919
uh you know either that add01 or add03

00:08:19,520 --> 00:08:22,560
variant based on whether or not we need

00:08:21,919 --> 00:08:24,479
to

00:08:22,560 --> 00:08:26,240
encode a particular bit of information

00:08:24,479 --> 00:08:27,759
so in one case we're already correctly

00:08:26,240 --> 00:08:28,800
encoded and the other two cases we just

00:08:27,759 --> 00:08:30,720
have to swap

00:08:28,800 --> 00:08:32,399
um based on you know the pairs we had

00:08:30,720 --> 00:08:35,200
earlier

00:08:32,399 --> 00:08:36,560
um and then we just uh take that new

00:08:35,200 --> 00:08:38,159
code we take our

00:08:36,560 --> 00:08:40,000
our operand registers as before or

00:08:38,159 --> 00:08:42,240
rather our register operances before

00:08:40,000 --> 00:08:43,839
uh and we use our encoder to create

00:08:42,240 --> 00:08:45,519
produce a brand new instruction that we

00:08:43,839 --> 00:08:48,560
splice directly into our copy of the

00:08:45,519 --> 00:08:49,200
uh program's instruction text and uh

00:08:48,560 --> 00:08:50,880
that's that

00:08:49,200 --> 00:08:52,399
um so i'm gonna drop this slide real

00:08:50,880 --> 00:08:52,959
quickly because i'm gonna do a live demo

00:08:52,399 --> 00:08:54,160
of this

00:08:52,959 --> 00:08:55,839
and if everything goes right hopefully

00:08:54,160 --> 00:08:56,880
this this screen is shared everybody can

00:08:55,839 --> 00:08:58,240
see this

00:08:56,880 --> 00:08:59,760
um so what i have here on the right hand

00:08:58,240 --> 00:09:00,480
side is a picture of bugs bunny and

00:08:59,760 --> 00:09:02,240
stalin

00:09:00,480 --> 00:09:03,680
um i've already loaded these commands

00:09:02,240 --> 00:09:04,560
here you can see that uh i have a copy

00:09:03,680 --> 00:09:06,720
of wireshark

00:09:04,560 --> 00:09:08,240
installed user bin has this checksum uh

00:09:06,720 --> 00:09:09,440
bug says this checksum

00:09:08,240 --> 00:09:10,800
and you can see that i've profiled this

00:09:09,440 --> 00:09:12,720
binary already and it has about 23

00:09:10,800 --> 00:09:15,040
kilobytes of space available

00:09:12,720 --> 00:09:16,080
so if everything goes right what i'll be

00:09:15,040 --> 00:09:18,640
able to do is this

00:09:16,080 --> 00:09:18,640
i'll be able to do

00:09:19,360 --> 00:09:23,040
and i'm going to do the statements my

00:09:22,000 --> 00:09:26,640
own copy of wireshark

00:09:23,040 --> 00:09:28,800
i'm going to load bugs into it now

00:09:26,640 --> 00:09:30,959
uh i have a copy of wireshark here that

00:09:28,800 --> 00:09:33,440
is you'll notice

00:09:30,959 --> 00:09:34,800
uh different in terms of its checksum

00:09:33,440 --> 00:09:37,760
from the initial one

00:09:34,800 --> 00:09:39,920
these two you know differ but if i run

00:09:37,760 --> 00:09:39,920
it

00:09:45,040 --> 00:09:48,560
i apologize for that keyboard you'll

00:09:47,200 --> 00:09:49,600
notice it is a perfectly functional

00:09:48,560 --> 00:09:50,800
version of wireshark

00:09:49,600 --> 00:09:54,399
um i can move around a little bit i want

00:09:50,800 --> 00:09:59,760
to be fast uh anyways if i do stick 86

00:09:54,399 --> 00:10:00,880
extract wireshark and i pump this into

00:09:59,760 --> 00:10:02,800
you will see that i in fact have a

00:10:00,880 --> 00:10:06,000
hidden copy of bugs inside of this

00:10:02,800 --> 00:10:08,480
this binary and if i do them to shaw sum

00:10:06,000 --> 00:10:08,480
you will see

00:10:13,920 --> 00:10:17,200
that this checksum matches our initial

00:10:16,320 --> 00:10:18,320
input

00:10:17,200 --> 00:10:20,240
so there you have it that is a way to

00:10:18,320 --> 00:10:21,760
hide a message inside of an arbitrary

00:10:20,240 --> 00:10:23,680
binary without breaking it

00:10:21,760 --> 00:10:25,680
uh using this this one weird trick

00:10:23,680 --> 00:10:28,800
inside of x86 is operating coding

00:10:25,680 --> 00:10:31,279
um i hope you enjoyed my talk if you did

00:10:28,800 --> 00:10:32,399
i have i'm going to put the slides for

00:10:31,279 --> 00:10:33,760
it up in a moment

00:10:32,399 --> 00:10:35,440
and the source is available on github

00:10:33,760 --> 00:10:36,880
under woodruff wsak86

00:10:35,440 --> 00:10:38,800
and of course uh you can follow me and

00:10:36,880 --> 00:10:43,920
talk to me on the bluebird site at

00:10:38,800 --> 00:10:43,920

YouTube URL: https://www.youtube.com/watch?v=-8MMLXB5E70


