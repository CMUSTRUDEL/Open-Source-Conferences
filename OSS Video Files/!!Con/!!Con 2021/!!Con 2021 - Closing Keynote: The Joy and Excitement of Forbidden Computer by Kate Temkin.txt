Title: !!Con 2021 - Closing Keynote: The Joy and Excitement of Forbidden Computer by Kate Temkin
Publication date: 2021-07-06
Playlist: !!Con 2021
Description: 
	Closing Keynote: The Joy and Excitement of Forbidden Computer by Kate Temkin

Kate Temkin is a hardware hacker and low-level engineer who spends most of her time exploring the hardware/software boundary and figuring out how to empower people with educational technology. Her recent interests include building hardware, software, and gateware for USB development, reverse engineering, and hacking.

When not hacking hardware, she maintains a variety of open-source projects, including LUNA, ViewSB, FaceDancer, and GreatFET, and probably spends more time than she should reverse engineering and be creating educational materials.
Captions: 
	00:00:13,440 --> 00:00:18,000
all right hello

00:00:15,360 --> 00:00:19,359
everyone's doing well it's a lot of good

00:00:18,000 --> 00:00:21,359
talks this morning

00:00:19,359 --> 00:00:23,119
this is i think the first time i've ever

00:00:21,359 --> 00:00:25,119
done a keynote that immediately followed

00:00:23,119 --> 00:00:27,359
a five minute countdown timer

00:00:25,119 --> 00:00:29,039
so i'm pretty excited to kind of take

00:00:27,359 --> 00:00:30,960
that energy into this

00:00:29,039 --> 00:00:32,480
i have about a half hour of material

00:00:30,960 --> 00:00:34,399
which is

00:00:32,480 --> 00:00:36,399
relatively challenging for me because i

00:00:34,399 --> 00:00:38,000
have a tendency to talk

00:00:36,399 --> 00:00:39,600
pretty much continuously so i'm going to

00:00:38,000 --> 00:00:43,120
get started but this

00:00:39,600 --> 00:00:44,000
talk is all about a specific project

00:00:43,120 --> 00:00:47,600
that i've done lately

00:00:44,000 --> 00:00:50,879
that i thought was something that was

00:00:47,600 --> 00:00:54,480
fun in a sense that is

00:00:50,879 --> 00:00:56,000
it was done specifically for the purpose

00:00:54,480 --> 00:00:58,719
of solving a problem that had kind of

00:00:56,000 --> 00:01:02,320
gotten stuck with me so

00:00:58,719 --> 00:01:04,239
who am i i am kate tempkin i lead the

00:01:02,320 --> 00:01:05,760
more digital side of a company called

00:01:04,239 --> 00:01:08,000
greatscot gadgets

00:01:05,760 --> 00:01:09,040
i do a lot of things that are designed

00:01:08,000 --> 00:01:12,080
to empower

00:01:09,040 --> 00:01:12,799
people with technology kind of one of my

00:01:12,080 --> 00:01:16,000
main goals

00:01:12,799 --> 00:01:19,280
is to take things that people don't

00:01:16,000 --> 00:01:22,720
easily have the ability to touch or see

00:01:19,280 --> 00:01:26,159
or kind of interact with things like usb

00:01:22,720 --> 00:01:26,880
or things that are going over wireless

00:01:26,159 --> 00:01:28,000
protocols

00:01:26,880 --> 00:01:29,680
and make those things that you can

00:01:28,000 --> 00:01:31,280
actually interact with because in

00:01:29,680 --> 00:01:32,799
interacting with them

00:01:31,280 --> 00:01:34,720
they start to become the kind of things

00:01:32,799 --> 00:01:37,360
that you can play with and playing with

00:01:34,720 --> 00:01:40,960
them you can understand them

00:01:37,360 --> 00:01:43,520
so kind of my whole thing here is that

00:01:40,960 --> 00:01:44,000
every little bit of computing that we do

00:01:43,520 --> 00:01:46,479
i think

00:01:44,000 --> 00:01:47,119
should have a human focus at the end of

00:01:46,479 --> 00:01:50,560
it

00:01:47,119 --> 00:01:52,000
i love doing things that directly

00:01:50,560 --> 00:01:53,680
empower people that allow people to

00:01:52,000 --> 00:01:56,000
understand things they wouldn't

00:01:53,680 --> 00:01:57,840
or that enable people to do things they

00:01:56,000 --> 00:01:59,119
wouldn't have been able to do

00:01:57,840 --> 00:02:00,880
either because of the price of

00:01:59,119 --> 00:02:04,560
technology or because

00:02:00,880 --> 00:02:04,560
of some technical limitation

00:02:04,880 --> 00:02:10,239
and so today i'm going to spend the next

00:02:07,759 --> 00:02:13,280
uh half hour telling you a story

00:02:10,239 --> 00:02:15,520
about uh a particular set of

00:02:13,280 --> 00:02:18,879
circumstances that led me

00:02:15,520 --> 00:02:19,599
from this kind of concept of deriving

00:02:18,879 --> 00:02:22,160
joy from

00:02:19,599 --> 00:02:23,120
let me see if i can use a laser pointer

00:02:22,160 --> 00:02:26,080
on this maybe not

00:02:23,120 --> 00:02:27,040
okay so the particular example of

00:02:26,080 --> 00:02:29,680
driving

00:02:27,040 --> 00:02:33,680
joy first from non-forbidden computing

00:02:29,680 --> 00:02:33,680
and this kind of journey in order to

00:02:33,760 --> 00:02:38,480
to actually build a project that allowed

00:02:36,560 --> 00:02:41,440
us to extract some joy from what i'll

00:02:38,480 --> 00:02:43,680
call forbidden computing

00:02:41,440 --> 00:02:45,360
and to understand this i'm going to tell

00:02:43,680 --> 00:02:48,800
you a little bit of backstory

00:02:45,360 --> 00:02:50,879
i have a particular good friend who is

00:02:48,800 --> 00:02:53,280
extremely extremely passionate about

00:02:50,879 --> 00:02:55,040
taking her entire setup with her

00:02:53,280 --> 00:02:57,120
one of the things she loves to be able

00:02:55,040 --> 00:02:58,560
to do is to be able to go out into the

00:02:57,120 --> 00:03:00,640
middle of nowhere with nothing other

00:02:58,560 --> 00:03:03,120
than the phone she has

00:03:00,640 --> 00:03:05,440
and then be able to use that phone to do

00:03:03,120 --> 00:03:07,040
pretty much any computing task

00:03:05,440 --> 00:03:09,440
and one of the things that enabled this

00:03:07,040 --> 00:03:12,239
for a very very long time

00:03:09,440 --> 00:03:14,400
is a program called utm which allows you

00:03:12,239 --> 00:03:17,599
to run virtual machines on

00:03:14,400 --> 00:03:19,760
ios and apple devices in general and

00:03:17,599 --> 00:03:22,400
that program was amazing because

00:03:19,760 --> 00:03:24,000
if you wanted to run something that was

00:03:22,400 --> 00:03:24,640
a windows application or a linux

00:03:24,000 --> 00:03:26,879
application

00:03:24,640 --> 00:03:28,799
you could boot up a virtual machine and

00:03:26,879 --> 00:03:30,560
relatively quickly

00:03:28,799 --> 00:03:32,959
be able to access everything like you

00:03:30,560 --> 00:03:35,519
would on a full computer

00:03:32,959 --> 00:03:36,400
so you don't have to kind of lug around

00:03:35,519 --> 00:03:38,159
a laptop

00:03:36,400 --> 00:03:40,080
you don't have to lug around you know an

00:03:38,159 --> 00:03:40,400
ipad anything like that you can actually

00:03:40,080 --> 00:03:42,319
do

00:03:40,400 --> 00:03:45,519
a lot of your computing directly from

00:03:42,319 --> 00:03:48,640
the palm of your hand not remoting

00:03:45,519 --> 00:03:50,159
just using these virtual machines

00:03:48,640 --> 00:03:53,360
and that was a really cool technology

00:03:50,159 --> 00:03:57,200
that in this case sparked a lot of joy

00:03:53,360 --> 00:04:00,000
but unfortunately eventually

00:03:57,200 --> 00:04:00,640
apple updated their operating systems

00:04:00,000 --> 00:04:02,959
ios

00:04:00,640 --> 00:04:03,760
and ipad os and those kind of things in

00:04:02,959 --> 00:04:07,040
order to

00:04:03,760 --> 00:04:09,599
block the technique that was used for

00:04:07,040 --> 00:04:11,760
allowing these virtual machines to run

00:04:09,599 --> 00:04:11,760
so

00:04:12,720 --> 00:04:16,479
there we reached a point where you had a

00:04:14,879 --> 00:04:18,320
choice between either

00:04:16,479 --> 00:04:20,160
keeping a low version of ios and not

00:04:18,320 --> 00:04:21,199
getting into his features and security

00:04:20,160 --> 00:04:24,880
stuff

00:04:21,199 --> 00:04:26,080
or being able to continue um or being

00:04:24,880 --> 00:04:28,720
able to

00:04:26,080 --> 00:04:30,880
get those updates and not be able to use

00:04:28,720 --> 00:04:34,080
utm

00:04:30,880 --> 00:04:34,800
so the real before we get into the

00:04:34,080 --> 00:04:38,160
actual

00:04:34,800 --> 00:04:39,600
um story of how we overcame those

00:04:38,160 --> 00:04:41,360
limitations

00:04:39,600 --> 00:04:43,520
first let's look at how this happened

00:04:41,360 --> 00:04:44,960
how do we wind up in this situation

00:04:43,520 --> 00:04:47,759
and in order to do that you have to

00:04:44,960 --> 00:04:48,880
understand the back end that actually

00:04:47,759 --> 00:04:51,120
drives

00:04:48,880 --> 00:04:51,919
utm which is a piece of software called

00:04:51,120 --> 00:04:53,919
keemu

00:04:51,919 --> 00:04:55,360
and this is this slide even though it's

00:04:53,919 --> 00:04:57,280
packed with text it's actually just a

00:04:55,360 --> 00:04:59,919
screenshot of the kimu website

00:04:57,280 --> 00:05:00,560
the most important thing is that keemu

00:04:59,919 --> 00:05:04,479
is

00:05:00,560 --> 00:05:08,160
a piece of emulation technology

00:05:04,479 --> 00:05:10,800
that can be used for a variety of things

00:05:08,160 --> 00:05:12,400
you may be familiar with keemufer as a

00:05:10,800 --> 00:05:15,120
virtualization front end

00:05:12,400 --> 00:05:16,560
where it does things like emulate disks

00:05:15,120 --> 00:05:20,960
and allows you to run

00:05:16,560 --> 00:05:23,039
hypervisors like kvm or zen

00:05:20,960 --> 00:05:25,600
but i'm actually interested in what i

00:05:23,039 --> 00:05:27,840
think is kind of a cooler use of

00:05:25,600 --> 00:05:30,080
keemu from my perspective which is full

00:05:27,840 --> 00:05:32,800
system emulation where kim you actually

00:05:30,080 --> 00:05:35,840
emulates the entirety of

00:05:32,800 --> 00:05:37,440
a of a computer and

00:05:35,840 --> 00:05:39,440
the really cool thing about that is that

00:05:37,440 --> 00:05:42,000
the computer that you're emulating

00:05:39,440 --> 00:05:43,280
does not actually need to be the same

00:05:42,000 --> 00:05:44,080
architecture as the machine you're

00:05:43,280 --> 00:05:46,000
running

00:05:44,080 --> 00:05:47,520
so you can go and emulate a raspberry pi

00:05:46,000 --> 00:05:50,880
on your x86 machine

00:05:47,520 --> 00:05:55,520
or you can emulate an x86 machine on

00:05:50,880 --> 00:05:57,680
your iphone which is an arm 64

00:05:55,520 --> 00:05:59,600
processor so this is really really neat

00:05:57,680 --> 00:06:03,120
especially if you want to be able to run

00:05:59,600 --> 00:06:06,880
something like full windows on your

00:06:03,120 --> 00:06:08,720
uh on your phone

00:06:06,880 --> 00:06:10,319
what's really cool here is the way this

00:06:08,720 --> 00:06:13,199
works the core

00:06:10,319 --> 00:06:13,720
of keemu used this way is an engine

00:06:13,199 --> 00:06:17,520
called

00:06:13,720 --> 00:06:20,639
tcg which is the tiny code generator

00:06:17,520 --> 00:06:23,840
and the tiny code generator is a

00:06:20,639 --> 00:06:25,840
kind of core computational translation

00:06:23,840 --> 00:06:28,800
translation engine that does binary

00:06:25,840 --> 00:06:31,520
translation from whatever your input is

00:06:28,800 --> 00:06:32,639
to whatever your output format is so in

00:06:31,520 --> 00:06:34,319
this case

00:06:32,639 --> 00:06:36,080
and the example i have on the slide it

00:06:34,319 --> 00:06:39,680
will take x8664

00:06:36,080 --> 00:06:39,919
machine code and then allow you to run

00:06:39,680 --> 00:06:43,440
it

00:06:39,919 --> 00:06:44,800
on an arc64 an arm 64-bit processor

00:06:43,440 --> 00:06:47,360
as we would if we were running this on

00:06:44,800 --> 00:06:47,360
an iphone

00:06:47,600 --> 00:06:50,960
so if we take a look at the input of

00:06:49,919 --> 00:06:55,039
some

00:06:50,960 --> 00:06:57,840
example x8664 code we can see

00:06:55,039 --> 00:06:59,280
the very first thing that happens is the

00:06:57,840 --> 00:07:00,639
block of

00:06:59,280 --> 00:07:02,319
computing that you want to do

00:07:00,639 --> 00:07:06,880
represented as a bunch of

00:07:02,319 --> 00:07:08,800
machine instructions wind up getting

00:07:06,880 --> 00:07:10,080
converted from their original

00:07:08,800 --> 00:07:11,919
representation

00:07:10,080 --> 00:07:13,599
into something called an intermediate

00:07:11,919 --> 00:07:16,319
representation

00:07:13,599 --> 00:07:18,800
this ir intermediate representation is

00:07:16,319 --> 00:07:19,680
very similar to the ir that exists in

00:07:18,800 --> 00:07:22,880
compilers like

00:07:19,680 --> 00:07:24,720
llvm it goes from the actual things that

00:07:22,880 --> 00:07:28,000
the operations are doing

00:07:24,720 --> 00:07:30,479
to the individual

00:07:28,000 --> 00:07:31,520
kind of core abstract ideas of

00:07:30,479 --> 00:07:33,440
computation

00:07:31,520 --> 00:07:35,199
so it's trying to break everything down

00:07:33,440 --> 00:07:37,360
to a more abstract level

00:07:35,199 --> 00:07:39,759
so if you look on this slide the first

00:07:37,360 --> 00:07:42,800
instruction that we had in x86

00:07:39,759 --> 00:07:45,120
was taking register eight

00:07:42,800 --> 00:07:46,319
xoring it with itself which happens to

00:07:45,120 --> 00:07:48,960
translate to

00:07:46,319 --> 00:07:50,639
the intermediate representation kind of

00:07:48,960 --> 00:07:51,360
abstraction that says really what this

00:07:50,639 --> 00:07:54,080
is doing

00:07:51,360 --> 00:07:54,560
is taking register 8 and moving 0 into

00:07:54,080 --> 00:07:58,240
it

00:07:54,560 --> 00:08:00,319
as a as a 64-bit number

00:07:58,240 --> 00:08:01,840
as we go through here every one of the

00:08:00,319 --> 00:08:04,160
operations that

00:08:01,840 --> 00:08:06,800
was represented in x86 code gets

00:08:04,160 --> 00:08:09,039
translated to this intermediary format

00:08:06,800 --> 00:08:11,440
and that intermediary format now has

00:08:09,039 --> 00:08:14,479
absolutely no relation to the

00:08:11,440 --> 00:08:15,440
initial platform the initial platform

00:08:14,479 --> 00:08:17,599
that we're emulating

00:08:15,440 --> 00:08:20,879
instead it's kind of a generic way of

00:08:17,599 --> 00:08:24,400
encapsulating the behavior we want

00:08:20,879 --> 00:08:26,560
from there our system actually takes

00:08:24,400 --> 00:08:29,599
that intermediate representation

00:08:26,560 --> 00:08:30,479
and compiles it into an equivalent set

00:08:29,599 --> 00:08:33,599
of up codes

00:08:30,479 --> 00:08:36,880
for the target architecture and

00:08:33,599 --> 00:08:38,240
this process is a little bit lossy as we

00:08:36,880 --> 00:08:41,120
go through this

00:08:38,240 --> 00:08:42,240
we generally tend to get less efficient

00:08:41,120 --> 00:08:44,880
code

00:08:42,240 --> 00:08:45,360
out of this machine than we did coming

00:08:44,880 --> 00:08:46,880
in

00:08:45,360 --> 00:08:48,959
but it's still code that can be run

00:08:46,880 --> 00:08:50,800
natively on your target architecture

00:08:48,959 --> 00:08:52,800
and once you've done that translation

00:08:50,800 --> 00:08:55,200
once you've done that binary translation

00:08:52,800 --> 00:08:56,720
you can actually take this block of code

00:08:55,200 --> 00:08:58,640
and run it every time

00:08:56,720 --> 00:09:00,320
you would be running the equivalent x86

00:08:58,640 --> 00:09:02,240
code so you don't have to go and do new

00:09:00,320 --> 00:09:02,880
processing you have native code that can

00:09:02,240 --> 00:09:04,880
run

00:09:02,880 --> 00:09:08,640
that can do all the same things as your

00:09:04,880 --> 00:09:10,640
x86 code would have

00:09:08,640 --> 00:09:12,320
so the whole magic that enables keemu to

00:09:10,640 --> 00:09:14,959
work in ways

00:09:12,320 --> 00:09:16,320
that allow you to run x86 programs on

00:09:14,959 --> 00:09:19,360
your arch 64

00:09:16,320 --> 00:09:23,360
phone is just in time generation

00:09:19,360 --> 00:09:25,440
where the uh the whole

00:09:23,360 --> 00:09:26,640
computer your representation of your

00:09:25,440 --> 00:09:28,720
emulated computer

00:09:26,640 --> 00:09:30,959
all the execution that goes through that

00:09:28,720 --> 00:09:32,240
winds up being translated into native

00:09:30,959 --> 00:09:35,519
code

00:09:32,240 --> 00:09:36,000
and then that native code is allowed to

00:09:35,519 --> 00:09:37,920
just run

00:09:36,000 --> 00:09:39,839
and then once it's been translated it

00:09:37,920 --> 00:09:41,519
just kind of stays there in a cache

00:09:39,839 --> 00:09:43,279
and can just be run over and over again

00:09:41,519 --> 00:09:44,880
without having to re-run this whole

00:09:43,279 --> 00:09:45,839
process every time we want to run that

00:09:44,880 --> 00:09:47,760
code

00:09:45,839 --> 00:09:48,880
and this actually can be pretty darn

00:09:47,760 --> 00:09:51,760
performant

00:09:48,880 --> 00:09:53,040
on a vm that takes about 12 seconds to

00:09:51,760 --> 00:09:57,040
boot

00:09:53,040 --> 00:09:58,800
uh natively this uh

00:09:57,040 --> 00:10:00,720
this kimu engine can actually get that

00:09:58,800 --> 00:10:03,519
to boot in about

00:10:00,720 --> 00:10:05,680
18 seconds using just in time generation

00:10:03,519 --> 00:10:07,760
and that's not a comprehensive benchmark

00:10:05,680 --> 00:10:08,720
but it gives you a good idea of the kind

00:10:07,760 --> 00:10:12,560
of

00:10:08,720 --> 00:10:13,680
uh the kind of overhead involved in

00:10:12,560 --> 00:10:17,040
those translations

00:10:13,680 --> 00:10:21,360
which is pretty minimal okay

00:10:17,040 --> 00:10:23,680
so what about using this on your phone

00:10:21,360 --> 00:10:24,640
if you have a modern phone you have a

00:10:23,680 --> 00:10:26,959
slight problem

00:10:24,640 --> 00:10:29,760
that all of the code that you have that

00:10:26,959 --> 00:10:31,920
you're able to run on that phone

00:10:29,760 --> 00:10:33,600
is usually required to be signed by a

00:10:31,920 --> 00:10:36,000
developer on apple phones

00:10:33,600 --> 00:10:37,279
every bit of code that runs should be

00:10:36,000 --> 00:10:39,600
signed by the

00:10:37,279 --> 00:10:41,040
person who actually authored it which

00:10:39,600 --> 00:10:42,560
means that if you're generating your

00:10:41,040 --> 00:10:43,760
code just in time

00:10:42,560 --> 00:10:45,200
if you're generating that code at the

00:10:43,760 --> 00:10:47,440
last minute in order to be able to run

00:10:45,200 --> 00:10:49,120
it

00:10:47,440 --> 00:10:51,360
from as part of that keemu process as

00:10:49,120 --> 00:10:51,839
part of tcg you're going to run into an

00:10:51,360 --> 00:10:54,800
issue

00:10:51,839 --> 00:10:56,560
because apple has put protections in

00:10:54,800 --> 00:10:58,079
place preventing you from

00:10:56,560 --> 00:10:59,760
being able to have memory that you can

00:10:58,079 --> 00:11:02,560
both fill with instructions

00:10:59,760 --> 00:11:04,000
and then execute from no memory can be

00:11:02,560 --> 00:11:06,560
both writable and

00:11:04,000 --> 00:11:07,360
executable unless you have a special

00:11:06,560 --> 00:11:09,839
entitlement

00:11:07,360 --> 00:11:12,320
that apple doesn't give to general

00:11:09,839 --> 00:11:15,120
general application developers

00:11:12,320 --> 00:11:16,240
so essentially if you go and try to do

00:11:15,120 --> 00:11:18,959
this

00:11:16,240 --> 00:11:20,720
on modern ios your just-in-time

00:11:18,959 --> 00:11:22,720
compilation or just-in-time translation

00:11:20,720 --> 00:11:24,959
is actually forbidden

00:11:22,720 --> 00:11:26,880
so we have gone fully into the domain of

00:11:24,959 --> 00:11:30,160
forbidden computing

00:11:26,880 --> 00:11:32,160
now one obvious workaround for um

00:11:30,160 --> 00:11:34,160
i guess i can say obvious one workaround

00:11:32,160 --> 00:11:37,040
that's obvious if you're really

00:11:34,160 --> 00:11:38,480
in deep into this problem space is that

00:11:37,040 --> 00:11:39,600
you can run the whole virtual machine

00:11:38,480 --> 00:11:42,880
you can run the

00:11:39,600 --> 00:11:45,519
processor on another virtual machine

00:11:42,880 --> 00:11:46,800
this virtual machine being one that is a

00:11:45,519 --> 00:11:49,519
virtual machine in the

00:11:46,800 --> 00:11:51,760
type of a language vm so we can actually

00:11:49,519 --> 00:11:53,519
take this and use it like

00:11:51,760 --> 00:11:56,160
uh if you think about this with like

00:11:53,519 --> 00:11:58,079
running code on a java virtual machine

00:11:56,160 --> 00:11:59,279
this is very similar there's actually an

00:11:58,079 --> 00:12:01,920
interpreter that takes

00:11:59,279 --> 00:12:05,120
all of the intermediate representation

00:12:01,920 --> 00:12:07,600
all of the stuff that you get from

00:12:05,120 --> 00:12:08,240
that kind of keymu processor agnostic

00:12:07,600 --> 00:12:10,160
format

00:12:08,240 --> 00:12:12,320
and just runs it it has a set of virtual

00:12:10,160 --> 00:12:14,480
registers and it knows how to

00:12:12,320 --> 00:12:16,079
um it knows when it sees the

00:12:14,480 --> 00:12:20,399
intermediate representation

00:12:16,079 --> 00:12:23,440
for uh for move zero into register eight

00:12:20,399 --> 00:12:26,720
it's capable of running some code

00:12:23,440 --> 00:12:28,720
that does that problem with that

00:12:26,720 --> 00:12:30,160
is that this is a big machine that is

00:12:28,720 --> 00:12:32,160
running in c

00:12:30,160 --> 00:12:33,760
that has these big jump tables and has

00:12:32,160 --> 00:12:35,440
all of these in directions to access a

00:12:33,760 --> 00:12:38,560
set of virtual registers

00:12:35,440 --> 00:12:40,320
so you're actually running a emulation

00:12:38,560 --> 00:12:43,760
of a machine

00:12:40,320 --> 00:12:45,600
on your phone that then in turn runs the

00:12:43,760 --> 00:12:47,200
emulation of the machine

00:12:45,600 --> 00:12:49,760
this level of indirection makes

00:12:47,200 --> 00:12:53,360
everything kind of get

00:12:49,760 --> 00:12:57,200
a little bit unbearable let me see if i

00:12:53,360 --> 00:12:57,200
can start this video properly

00:12:58,880 --> 00:13:05,519
so this is booting uh react to s

00:13:02,399 --> 00:13:08,639
on the on this

00:13:05,519 --> 00:13:09,600
interpreter running on an utm on an

00:13:08,639 --> 00:13:11,600
iphone

00:13:09,600 --> 00:13:13,200
and one thing you might notice is that

00:13:11,600 --> 00:13:16,240
as

00:13:13,200 --> 00:13:18,560
i'm sitting here and talking the whole

00:13:16,240 --> 00:13:22,800
system is very gradually

00:13:18,560 --> 00:13:25,839
loading things if you run the

00:13:22,800 --> 00:13:28,720
that same reference piece of

00:13:25,839 --> 00:13:30,720
vm that i had that booted in 12 seconds

00:13:28,720 --> 00:13:33,519
native and about 18 seconds

00:13:30,720 --> 00:13:34,639
on the just in time runtime on the

00:13:33,519 --> 00:13:37,839
interpreter

00:13:34,639 --> 00:13:41,279
it took something like 90 to

00:13:37,839 --> 00:13:44,560
120 seconds just to be able to boot up

00:13:41,279 --> 00:13:46,320
so everything gets really unusably slow

00:13:44,560 --> 00:13:48,959
really if we want this to work we're

00:13:46,320 --> 00:13:51,040
looking for something that is

00:13:48,959 --> 00:13:52,079
ideally not painful to use still fun to

00:13:51,040 --> 00:13:54,720
use

00:13:52,079 --> 00:13:57,279
and that means maybe somewhere between

00:13:54,720 --> 00:13:58,160
that 18 seconds and maybe 40 or 50

00:13:57,279 --> 00:13:59,920
seconds to boot

00:13:58,160 --> 00:14:02,560
not something in the hundreds and

00:13:59,920 --> 00:14:05,519
hundreds of seconds so

00:14:02,560 --> 00:14:06,320
we're left in this problem space i have

00:14:05,519 --> 00:14:07,839
this friend

00:14:06,320 --> 00:14:10,240
who has been loving running these

00:14:07,839 --> 00:14:12,560
virtual machines on her phone

00:14:10,240 --> 00:14:14,720
but suddenly can no longer do that in a

00:14:12,560 --> 00:14:17,839
typical way because

00:14:14,720 --> 00:14:20,399
we can't run generated code

00:14:17,839 --> 00:14:22,560
we are limited by apple to only being

00:14:20,399 --> 00:14:24,800
able to run code that comes pre-made

00:14:22,560 --> 00:14:26,720
and that we're able to sign at the time

00:14:24,800 --> 00:14:30,000
that we're going to put that

00:14:26,720 --> 00:14:33,120
code on a phone so

00:14:30,000 --> 00:14:35,519
we're kind of so this is the kind of

00:14:33,120 --> 00:14:39,040
problem space that got me thinking

00:14:35,519 --> 00:14:42,399
so in the process of her kind of uh

00:14:39,040 --> 00:14:43,839
explaining that she was super bummed to

00:14:42,399 --> 00:14:46,160
lose this

00:14:43,839 --> 00:14:47,760
we started talking a little bit about

00:14:46,160 --> 00:14:49,440
different ways around this

00:14:47,760 --> 00:14:50,959
different ways that we potentially could

00:14:49,440 --> 00:14:52,720
start running things and we

00:14:50,959 --> 00:14:55,519
we tried running out the interpreter and

00:14:52,720 --> 00:14:59,680
it was just too slow to be used

00:14:55,519 --> 00:15:01,680
but there is this one kind of

00:14:59,680 --> 00:15:03,839
saving grace in all of this which is

00:15:01,680 --> 00:15:07,600
that we can actually still

00:15:03,839 --> 00:15:10,480
run code as long as it's been pre-made

00:15:07,600 --> 00:15:12,480
as long as it's been pre-generated and

00:15:10,480 --> 00:15:15,600
you start thinking

00:15:12,480 --> 00:15:17,680
well okay if we can run pre-made code

00:15:15,600 --> 00:15:20,079
what if we were able to pre-generate

00:15:17,680 --> 00:15:22,000
every bit of code we might need

00:15:20,079 --> 00:15:23,279
now that sounds like a lot because

00:15:22,000 --> 00:15:24,480
theoretically there are infinite

00:15:23,279 --> 00:15:26,000
programs you could

00:15:24,480 --> 00:15:27,600
stick into this if you have infinite

00:15:26,000 --> 00:15:29,680
space right there's

00:15:27,600 --> 00:15:31,440
infinite solution space for all these

00:15:29,680 --> 00:15:33,279
things and for

00:15:31,440 --> 00:15:35,360
to be able to capture every possible

00:15:33,279 --> 00:15:39,600
program and pre-generate code for it

00:15:35,360 --> 00:15:41,920
is impossible but what we can do

00:15:39,600 --> 00:15:44,320
is we can take a look at the various

00:15:41,920 --> 00:15:47,199
pieces of intermediate representation

00:15:44,320 --> 00:15:49,040
that qmu is capable producing so if we

00:15:47,199 --> 00:15:52,399
have an instruction like

00:15:49,040 --> 00:15:54,639
move a value from r0 to r1 or in this

00:15:52,399 --> 00:15:59,279
case from r1 to r0

00:15:54,639 --> 00:16:01,839
we actually have a piece of ar64

00:15:59,279 --> 00:16:03,040
code in this case armed 64-bit code that

00:16:01,839 --> 00:16:05,199
does that

00:16:03,040 --> 00:16:06,959
and so we know how to generate a single

00:16:05,199 --> 00:16:08,160
little bit of pre-made code that handles

00:16:06,959 --> 00:16:10,480
that particular

00:16:08,160 --> 00:16:10,480
case

00:16:12,079 --> 00:16:16,160
if we were able to generate possibly a

00:16:14,720 --> 00:16:18,320
whole variety of these

00:16:16,160 --> 00:16:20,560
little tiny bits of code these little

00:16:18,320 --> 00:16:23,199
things that we'll call gadgets

00:16:20,560 --> 00:16:24,560
we could potentially write whole

00:16:23,199 --> 00:16:26,240
programs that way

00:16:24,560 --> 00:16:28,480
right but something still needs to come

00:16:26,240 --> 00:16:30,240
and stitch all of these things together

00:16:28,480 --> 00:16:32,639
right so if we had a pool of all of

00:16:30,240 --> 00:16:34,079
these it would be really nice to have

00:16:32,639 --> 00:16:36,160
the ability to go

00:16:34,079 --> 00:16:39,600
and kind of thread together all the

00:16:36,160 --> 00:16:39,600
individual pieces that we have

00:16:40,160 --> 00:16:44,240
one technique for doing that is to come

00:16:42,240 --> 00:16:44,959
up with a big list of every single

00:16:44,240 --> 00:16:47,199
gadget

00:16:44,959 --> 00:16:48,480
that corresponds to a potential thing

00:16:47,199 --> 00:16:51,759
that we might want to do

00:16:48,480 --> 00:16:53,360
so if our program was moving x1 and x0

00:16:51,759 --> 00:16:55,680
register 1 enter register 0

00:16:53,360 --> 00:16:56,720
and then adding register 2 and register

00:16:55,680 --> 00:16:59,040
00:16:56,720 --> 00:17:01,600
storing that result in register 0 we can

00:16:59,040 --> 00:17:03,440
find gadgets to do that

00:17:01,600 --> 00:17:05,839
and then stitch those together by adding

00:17:03,440 --> 00:17:08,720
a little bit of code after each gadget

00:17:05,839 --> 00:17:09,439
that goes and moves its way to the next

00:17:08,720 --> 00:17:12,000
one

00:17:09,439 --> 00:17:13,919
so we moved from a model where we were

00:17:12,000 --> 00:17:15,039
just stitching together machine code

00:17:13,919 --> 00:17:17,439
instructions

00:17:15,039 --> 00:17:19,280
to a model where we take a list that has

00:17:17,439 --> 00:17:21,039
all the different potential gadgets that

00:17:19,280 --> 00:17:22,880
we want

00:17:21,039 --> 00:17:25,280
just kind of sitting there address after

00:17:22,880 --> 00:17:25,839
address and then we write some code that

00:17:25,280 --> 00:17:29,280
says

00:17:25,839 --> 00:17:32,000
let me go into this list grab

00:17:29,280 --> 00:17:33,200
the next address and then just jump to

00:17:32,000 --> 00:17:35,760
it

00:17:33,200 --> 00:17:36,880
so we actually can have it so that every

00:17:35,760 --> 00:17:39,200
instruction

00:17:36,880 --> 00:17:41,200
that we want to run is followed by a

00:17:39,200 --> 00:17:43,280
really simple little epilogue

00:17:41,200 --> 00:17:44,240
that moves to the next instruction and

00:17:43,280 --> 00:17:45,520
at this point

00:17:44,240 --> 00:17:47,360
what we're actually doing instead of

00:17:45,520 --> 00:17:49,200
running code that we've generated is

00:17:47,360 --> 00:17:49,840
taking a whole bunch of pre-generated

00:17:49,200 --> 00:17:52,880
code and

00:17:49,840 --> 00:17:52,880
threading it together

00:17:54,720 --> 00:18:00,559
so we need every possible gadget

00:17:58,000 --> 00:18:01,360
that you might run into for this to work

00:18:00,559 --> 00:18:02,960
and

00:18:01,360 --> 00:18:04,799
this is very possible if you have

00:18:02,960 --> 00:18:07,360
something like 16

00:18:04,799 --> 00:18:09,039
registers on your system because you can

00:18:07,360 --> 00:18:12,960
go and generate add

00:18:09,039 --> 00:18:14,480
r0 r1 r2 and r0 r1 r3

00:18:12,960 --> 00:18:16,640
you can go and actually generate code

00:18:14,480 --> 00:18:19,520
that generates every single one

00:18:16,640 --> 00:18:21,360
of these little gadgets and so what i

00:18:19,520 --> 00:18:22,799
did is write a python script that goes

00:18:21,360 --> 00:18:25,440
and generates the

00:18:22,799 --> 00:18:27,120
low level assembly for every single one

00:18:25,440 --> 00:18:30,240
of the instructions

00:18:27,120 --> 00:18:32,400
that i use to implement all of the

00:18:30,240 --> 00:18:33,440
uh keemu intermediate representation

00:18:32,400 --> 00:18:37,039
instructions

00:18:33,440 --> 00:18:38,720
so here we have a whole

00:18:37,039 --> 00:18:40,400
just a little snippet of something that

00:18:38,720 --> 00:18:42,480
is saying okay for

00:18:40,400 --> 00:18:45,840
for example midway through the slide we

00:18:42,480 --> 00:18:47,840
have load a 8-bit unsigned value

00:18:45,840 --> 00:18:49,440
and then i have a little bit of arm code

00:18:47,840 --> 00:18:51,280
that has some placeholders

00:18:49,440 --> 00:18:53,600
and this python just goes through and

00:18:51,280 --> 00:18:54,240
substitutes the actual values for each

00:18:53,600 --> 00:18:57,840
individual

00:18:54,240 --> 00:19:01,200
possible argument into that template

00:18:57,840 --> 00:19:04,400
now we wind up with is a whole bunch of

00:19:01,200 --> 00:19:08,000
in this case inline assembly

00:19:04,400 --> 00:19:12,720
that implements every single possible

00:19:08,000 --> 00:19:14,960
operation in keemu-ir in ar-64 code

00:19:12,720 --> 00:19:16,640
pre-generated all in big files that we

00:19:14,960 --> 00:19:19,679
can go and sign these

00:19:16,640 --> 00:19:21,120
and then be able to operate uh

00:19:19,679 --> 00:19:24,720
that kind of stitching together

00:19:21,120 --> 00:19:28,000
technique on all of these little pieces

00:19:24,720 --> 00:19:28,799
so this trends this kind of transitions

00:19:28,000 --> 00:19:30,960
the

00:19:28,799 --> 00:19:33,280
way that we were working on this from

00:19:30,960 --> 00:19:35,360
something that took machine code in

00:19:33,280 --> 00:19:38,000
and produced machine code out into

00:19:35,360 --> 00:19:39,039
something that took machine code in and

00:19:38,000 --> 00:19:40,480
outputs these

00:19:39,039 --> 00:19:42,080
chains of gadgets which are then

00:19:40,480 --> 00:19:45,440
threaded together

00:19:42,080 --> 00:19:46,640
this new technique i've chosen to call

00:19:45,440 --> 00:19:48,960
the tiny code

00:19:46,640 --> 00:19:50,880
threaded interpreter because instead of

00:19:48,960 --> 00:19:51,520
the regular interpreter which went and

00:19:50,880 --> 00:19:53,280
actually

00:19:51,520 --> 00:19:54,799
took that intermediate representation

00:19:53,280 --> 00:19:56,880
and ran it manually

00:19:54,799 --> 00:19:59,840
we're actually taking pieces of machine

00:19:56,880 --> 00:20:01,840
code and stitching them together

00:19:59,840 --> 00:20:03,840
scheduling where all the jumps go so

00:20:01,840 --> 00:20:04,400
that we can actually have a continuous

00:20:03,840 --> 00:20:08,480
stream

00:20:04,400 --> 00:20:08,480
of executing instructions

00:20:08,799 --> 00:20:11,120
so

00:20:11,840 --> 00:20:15,200
this required one last little piece

00:20:13,600 --> 00:20:19,039
which is to implement

00:20:15,200 --> 00:20:19,760
that the actual piece that transforms

00:20:19,039 --> 00:20:21,760
from

00:20:19,760 --> 00:20:23,919
intermediate representation to those

00:20:21,760 --> 00:20:25,760
chains of gadgets

00:20:23,919 --> 00:20:29,760
which it turns out is actually just a

00:20:25,760 --> 00:20:31,760
big collection of these

00:20:29,760 --> 00:20:33,120
opcode emission instructions where

00:20:31,760 --> 00:20:34,159
instead of saying let me generate the

00:20:33,120 --> 00:20:36,320
machine code for

00:20:34,159 --> 00:20:38,400
a b swap instruction we're actually

00:20:36,320 --> 00:20:41,840
saying let me generate a pointer

00:20:38,400 --> 00:20:44,480
a gadget pointer in this case let me

00:20:41,840 --> 00:20:45,360
add the address of the code that already

00:20:44,480 --> 00:20:48,559
exists

00:20:45,360 --> 00:20:51,520
that performs this operation

00:20:48,559 --> 00:20:53,360
and what we get out is something where

00:20:51,520 --> 00:20:56,880
the intermediate representation

00:20:53,360 --> 00:21:00,000
is translated not from

00:20:56,880 --> 00:21:02,400
not directly to machine code but

00:21:00,000 --> 00:21:03,039
to a collection of gadgets that then run

00:21:02,400 --> 00:21:05,280
on

00:21:03,039 --> 00:21:06,240
this new weird kind of machine that

00:21:05,280 --> 00:21:08,480
we've made

00:21:06,240 --> 00:21:09,520
which is really a subset a specialized

00:21:08,480 --> 00:21:12,240
subset of

00:21:09,520 --> 00:21:13,120
our arm processor and so what we're able

00:21:12,240 --> 00:21:16,720
to do

00:21:13,120 --> 00:21:19,760
is just like before we take the

00:21:16,720 --> 00:21:21,840
uh the intermediate representation

00:21:19,760 --> 00:21:24,240
and produce something that can be run

00:21:21,840 --> 00:21:27,520
natively on our processor

00:21:24,240 --> 00:21:30,480
and that

00:21:27,520 --> 00:21:33,360
essentially means that we're going to be

00:21:30,480 --> 00:21:37,120
outputting these long chains of gadgets

00:21:33,360 --> 00:21:40,159
which in turn do all the same operations

00:21:37,120 --> 00:21:42,080
that we would be doing um

00:21:40,159 --> 00:21:43,679
on that target processor but with just

00:21:42,080 --> 00:21:46,400
little bits of extra code

00:21:43,679 --> 00:21:48,480
stitching everything together so we have

00:21:46,400 --> 00:21:52,640
is a really cool way of

00:21:48,480 --> 00:21:53,200
creating a a system that is capable of

00:21:52,640 --> 00:21:55,360
running

00:21:53,200 --> 00:21:56,720
native code just like the original was

00:21:55,360 --> 00:21:59,280
it doesn't have to interpret things

00:21:56,720 --> 00:22:02,240
every time but which is doing so

00:21:59,280 --> 00:22:03,120
using these generated pieces of code

00:22:02,240 --> 00:22:05,200
which were then

00:22:03,120 --> 00:22:07,840
sure cable of signing at the time that

00:22:05,200 --> 00:22:10,960
we built kemia

00:22:07,840 --> 00:22:12,080
so all this put together we can finally

00:22:10,960 --> 00:22:14,720
go and actually check

00:22:12,080 --> 00:22:16,320
to see how the performance is so what i

00:22:14,720 --> 00:22:19,520
have here is a comparison

00:22:16,320 --> 00:22:20,320
of tci on the left which is the basic

00:22:19,520 --> 00:22:22,880
interpreter

00:22:20,320 --> 00:22:24,320
and on the right tcti the threaded

00:22:22,880 --> 00:22:28,799
interpreter

00:22:24,320 --> 00:22:31,520
and we can actually see how quickly this

00:22:28,799 --> 00:22:33,039
to comparatively boot now you can mostly

00:22:31,520 --> 00:22:34,640
ignore when the windows change

00:22:33,039 --> 00:22:37,360
size because that is me tapping on the

00:22:34,640 --> 00:22:39,840
screen during these recorded videos

00:22:37,360 --> 00:22:40,720
but if you look at their content what

00:22:39,840 --> 00:22:44,880
you will notice

00:22:40,720 --> 00:22:45,760
is that tcti while not the fastest thing

00:22:44,880 --> 00:22:48,000
in the world

00:22:45,760 --> 00:22:50,000
is significantly significantly faster

00:22:48,000 --> 00:22:53,120
than tci which is still

00:22:50,000 --> 00:22:54,720
figuring out how to run the desktop and

00:22:53,120 --> 00:22:55,520
do the basic rendering at the time the

00:22:54,720 --> 00:22:58,159
tcti

00:22:55,520 --> 00:23:00,159
has been long done and so by making a

00:22:58,159 --> 00:23:01,360
more efficient interpreter by using this

00:23:00,159 --> 00:23:04,640
kind of

00:23:01,360 --> 00:23:08,080
um this kind of cheating

00:23:04,640 --> 00:23:10,559
technique we're able to get

00:23:08,080 --> 00:23:12,960
ourselves to something that is usable in

00:23:10,559 --> 00:23:14,559
a reasonable amount of time

00:23:12,960 --> 00:23:17,039
so we've gone from something that was

00:23:14,559 --> 00:23:20,480
completely computationally

00:23:17,039 --> 00:23:24,000
forbidden to something that is now

00:23:20,480 --> 00:23:28,000
uh that is now actually usable

00:23:24,000 --> 00:23:30,480
and this eventually made its way into

00:23:28,000 --> 00:23:31,679
utm the original application at the

00:23:30,480 --> 00:23:34,960
start of this

00:23:31,679 --> 00:23:38,320
so we've gone from something where

00:23:34,960 --> 00:23:39,760
the where we had a restricted computing

00:23:38,320 --> 00:23:40,320
environment we weren't allowed to do

00:23:39,760 --> 00:23:44,799
anything

00:23:40,320 --> 00:23:44,799
just in time translation like

00:23:45,120 --> 00:23:50,000
to something where we within those same

00:23:47,520 --> 00:23:54,159
restrictions now have a even weirder way

00:23:50,000 --> 00:23:56,480
of doing things that still circumvents

00:23:54,159 --> 00:23:58,480
the restrictions and on using this we're

00:23:56,480 --> 00:24:00,880
able to run

00:23:58,480 --> 00:24:01,520
applications again in virtual machines

00:24:00,880 --> 00:24:05,600
again

00:24:01,520 --> 00:24:08,080
on apple devices so

00:24:05,600 --> 00:24:09,919
just to give you some statistics i am

00:24:08,080 --> 00:24:13,120
going to preface this by saying

00:24:09,919 --> 00:24:14,799
there is my goal list was not to measure

00:24:13,120 --> 00:24:16,000
performance these were not scientific

00:24:14,799 --> 00:24:18,400
measurements

00:24:16,000 --> 00:24:20,080
i specifically did all of this for the

00:24:18,400 --> 00:24:21,279
purpose of being able to do something

00:24:20,080 --> 00:24:24,480
that was

00:24:21,279 --> 00:24:26,799
fun and for me to implement

00:24:24,480 --> 00:24:28,159
something that sparked joy for my friend

00:24:26,799 --> 00:24:30,640
who would no longer have to be

00:24:28,159 --> 00:24:31,600
without those virtual machines and

00:24:30,640 --> 00:24:34,400
something

00:24:31,600 --> 00:24:35,440
that was going to satisfy the itch i had

00:24:34,400 --> 00:24:37,760
had

00:24:35,440 --> 00:24:39,200
while uh thinking about the problem

00:24:37,760 --> 00:24:40,960
space to actually prove that this

00:24:39,200 --> 00:24:43,760
technique works

00:24:40,960 --> 00:24:45,039
so in our limited empirical testing

00:24:43,760 --> 00:24:47,200
which is

00:24:45,039 --> 00:24:48,880
which is booting that same reference

00:24:47,200 --> 00:24:52,480
image what we actually find is

00:24:48,880 --> 00:24:55,840
that a tcti boot of that reference image

00:24:52,480 --> 00:24:58,080
takes about 36 seconds so

00:24:55,840 --> 00:24:58,880
in its best in the best case of all the

00:24:58,080 --> 00:25:01,200
trials i did

00:24:58,880 --> 00:25:02,080
tci the regular interpreter the

00:25:01,200 --> 00:25:05,200
non-hacky

00:25:02,080 --> 00:25:06,720
interpreter was only able to make it to

00:25:05,200 --> 00:25:09,679
i believe like 78

00:25:06,720 --> 00:25:10,320
seconds in its absolute most optimized

00:25:09,679 --> 00:25:12,080
form

00:25:10,320 --> 00:25:13,760
so we basically cut the boot time in

00:25:12,080 --> 00:25:16,960
half just by doing

00:25:13,760 --> 00:25:18,960
our computational stuff in a little bit

00:25:16,960 --> 00:25:21,440
of a different way

00:25:18,960 --> 00:25:23,039
and so this is awesome because i think

00:25:21,440 --> 00:25:24,320
this is a really great example of

00:25:23,039 --> 00:25:28,640
something where

00:25:24,320 --> 00:25:30,960
you can take a really simple problem

00:25:28,640 --> 00:25:32,960
kind of apply that human factor and

00:25:30,960 --> 00:25:36,320
translate it into the real thing

00:25:32,960 --> 00:25:38,080
the real kind of uh outcome that i would

00:25:36,320 --> 00:25:41,279
hope to get from computing

00:25:38,080 --> 00:25:43,840
which is that we can use this then to

00:25:41,279 --> 00:25:43,840
spark joy

00:25:44,720 --> 00:25:48,880
and so at the end of the day we learn a

00:25:49,200 --> 00:25:53,760
kind of extremely powerful lesson here

00:25:52,400 --> 00:25:55,760
which is

00:25:53,760 --> 00:25:56,799
i put pitholia as when life forbids you

00:25:55,760 --> 00:25:59,360
from computing

00:25:56,799 --> 00:26:00,799
spark joy with a newer weirder computer

00:25:59,360 --> 00:26:02,880
but i think the

00:26:00,799 --> 00:26:04,240
a little bit of that pith removed the

00:26:02,880 --> 00:26:05,760
real thing that i would love for

00:26:04,240 --> 00:26:08,000
everyone to take away from this and take

00:26:05,760 --> 00:26:11,360
away from all the rest of the talks

00:26:08,000 --> 00:26:15,200
at this kind of amazing gear

00:26:11,360 --> 00:26:16,159
uh of various neat technological

00:26:15,200 --> 00:26:19,679
excitement

00:26:16,159 --> 00:26:21,279
is that when at the end of the day

00:26:19,679 --> 00:26:23,840
what you really should be doing as you

00:26:21,279 --> 00:26:24,880
build technology is thinking about ways

00:26:23,840 --> 00:26:27,360
that yours

00:26:24,880 --> 00:26:28,240
work is going to make things better for

00:26:27,360 --> 00:26:30,640
people

00:26:28,240 --> 00:26:32,400
right the whole goal here is to focus on

00:26:30,640 --> 00:26:36,840
that human factor

00:26:32,400 --> 00:26:38,080
and i hope this story is something that

00:26:36,840 --> 00:26:40,000
uh

00:26:38,080 --> 00:26:43,440
shows you just a really simple

00:26:40,000 --> 00:26:46,559
run-through of my thought process when

00:26:43,440 --> 00:26:50,159
a friend of mine was feeling down

00:26:46,559 --> 00:26:50,159
because of a computational problem

00:26:50,960 --> 00:26:58,240
so that all said i would love to go and

00:26:54,640 --> 00:26:58,240
answer some questions from discord

00:26:59,360 --> 00:27:04,080
yeah so the things i'm saying in the

00:27:02,640 --> 00:27:07,360
past there are like

00:27:04,080 --> 00:27:09,440
i honestly think this graph here

00:27:07,360 --> 00:27:10,880
is the pithy joyce bar graph is

00:27:09,440 --> 00:27:14,159
something that every one

00:27:10,880 --> 00:27:17,279
of your technical projects should have

00:27:14,159 --> 00:27:18,799
somewhere uh in your head

00:27:17,279 --> 00:27:21,840
so that you can at least kind of answer

00:27:18,799 --> 00:27:21,840
the question of

00:27:22,159 --> 00:27:25,360
what is this doing for me

00:27:29,760 --> 00:27:33,440
oh the question from discord is am i

00:27:31,679 --> 00:27:35,039
going to name the debugger for this

00:27:33,440 --> 00:27:38,320
inspector gadget because it's a

00:27:35,039 --> 00:27:41,200
rad name um there actually is a built-in

00:27:38,320 --> 00:27:43,200
debugger for this that is nameless so if

00:27:41,200 --> 00:27:48,320
you want to go into the code base and

00:27:43,200 --> 00:27:52,080
pr that you are completely welcome too

00:27:48,320 --> 00:27:55,600
hello how's ghosts oh that was amazing

00:27:52,080 --> 00:27:59,440
oh i'm so excited um that

00:27:55,600 --> 00:28:02,480
uh yeah plea please go ahead i uh

00:27:59,440 --> 00:28:03,440
yeah please question we got in discord

00:28:02,480 --> 00:28:06,399
is how

00:28:03,440 --> 00:28:07,120
uh this technique handles immediate

00:28:06,399 --> 00:28:09,840
values

00:28:07,120 --> 00:28:11,279
and those are either there's one of two

00:28:09,840 --> 00:28:13,840
ways for

00:28:11,279 --> 00:28:15,120
to handle that one of them is if they're

00:28:13,840 --> 00:28:16,640
very common immediate

00:28:15,120 --> 00:28:18,159
we build a gadget that has that

00:28:16,640 --> 00:28:20,000
immediate hard-coded

00:28:18,159 --> 00:28:21,440
otherwise we put the immediate right in

00:28:20,000 --> 00:28:23,039
the instruction stream just like you

00:28:21,440 --> 00:28:26,320
would any other machine code

00:28:23,039 --> 00:28:28,000
so that means that the matrix you end up

00:28:26,320 --> 00:28:29,840
with is a

00:28:28,000 --> 00:28:31,679
gadget pointer an immediate and then a

00:28:29,840 --> 00:28:34,080
gadget pointer and it's up to the gadget

00:28:31,679 --> 00:28:37,039
itself to go and pull that value

00:28:34,080 --> 00:28:38,960
uh out of that instruction stream in

00:28:37,039 --> 00:28:41,679
much the same way that a

00:28:38,960 --> 00:28:45,840
processor would do that itself in

00:28:41,679 --> 00:28:45,840
instruction decoding

00:28:46,559 --> 00:28:51,679
i was gonna ask um

00:28:49,600 --> 00:28:52,880
i was gonna ask about like cash

00:28:51,679 --> 00:28:53,600
characteristics and this and that and

00:28:52,880 --> 00:28:55,120
the other thing

00:28:53,600 --> 00:28:57,520
but the the actual question that i

00:28:55,120 --> 00:28:59,919
really have is did it work it like is

00:28:57,520 --> 00:29:00,880
your friend now able to take her iphone

00:28:59,919 --> 00:29:02,799
and like

00:29:00,880 --> 00:29:04,480
and like do stuff like into the woods

00:29:02,799 --> 00:29:06,320
and like do stuff with it

00:29:04,480 --> 00:29:07,919
yep it's actually now fast enough to be

00:29:06,320 --> 00:29:09,279
able to be used i'm getting blurry for

00:29:07,919 --> 00:29:12,399
some reason but okay

00:29:09,279 --> 00:29:16,320
the so it's actually fast enough to be

00:29:12,399 --> 00:29:17,440
usable in uh it's not as fast as it

00:29:16,320 --> 00:29:19,279
would have been otherwise but it's

00:29:17,440 --> 00:29:20,399
definitely usable and it has made its

00:29:19,279 --> 00:29:22,960
way into the core

00:29:20,399 --> 00:29:24,640
of that original program utm so now

00:29:22,960 --> 00:29:25,760
everyone who's in this situation can do

00:29:24,640 --> 00:29:28,080
the same thing

00:29:25,760 --> 00:29:32,240
which is kind of awesome they named it

00:29:28,080 --> 00:29:32,240
the very flattering utm slow edition

00:29:34,159 --> 00:29:38,480
i'm very curious about i'm very curious

00:29:36,320 --> 00:29:42,240
about like many parts of this

00:29:38,480 --> 00:29:44,000
um i i i'm not sure that

00:29:42,240 --> 00:29:45,520
um like like i could pick your brain on

00:29:44,000 --> 00:29:50,080
this all day um

00:29:45,520 --> 00:29:53,600
but um it's not immediately clear to me

00:29:50,080 --> 00:29:55,279
that i will have uh all of the

00:29:53,600 --> 00:29:56,720
bang bang khan attendees listen to me

00:29:55,279 --> 00:29:57,919
ask question after question after

00:29:56,720 --> 00:30:00,720
question after question

00:29:57,919 --> 00:30:01,600
about like cash performance and like

00:30:00,720 --> 00:30:05,120
wait you could do

00:30:01,600 --> 00:30:08,320
before ios 14.4 like how did that work

00:30:05,120 --> 00:30:10,480
um and all that sort of stuff so i think

00:30:08,320 --> 00:30:12,159
we should uh send that over in the

00:30:10,480 --> 00:30:15,840
discord direction

00:30:12,159 --> 00:30:17,679
um and um thank you kate

00:30:15,840 --> 00:30:19,039
thank you for you know the thing that i

00:30:17,679 --> 00:30:22,080
liked about this

00:30:19,039 --> 00:30:24,960
was not just that

00:30:22,080 --> 00:30:26,320
it's a really cool hack but it's

00:30:24,960 --> 00:30:29,360
important to do things for

00:30:26,320 --> 00:30:31,520
people and and i think that's the the

00:30:29,360 --> 00:30:32,799
at the very beginning you had mentioned

00:30:31,520 --> 00:30:35,600
um

00:30:32,799 --> 00:30:36,640
that you can understand the world by

00:30:35,600 --> 00:30:39,919
playing with it

00:30:36,640 --> 00:30:41,919
um and this is kind of how i feel

00:30:39,919 --> 00:30:43,279
like here i am in in my lab set up here

00:30:41,919 --> 00:30:45,200
i i have a

00:30:43,279 --> 00:30:47,200
i have an idea for a bang bang con talk

00:30:45,200 --> 00:30:48,240
uh next year that is exactly that like

00:30:47,200 --> 00:30:49,679
figuring out

00:30:48,240 --> 00:30:51,279
how wait i'm not going to say it out

00:30:49,679 --> 00:30:55,039
loud um the the

00:30:51,279 --> 00:30:57,679
the other organizers will hear it um

00:30:55,039 --> 00:30:59,600
but but all the same but by playing but

00:30:57,679 --> 00:31:00,480
by playing with objects either physical

00:30:59,600 --> 00:31:03,360
objects

00:31:00,480 --> 00:31:05,360
or software objects um you can

00:31:03,360 --> 00:31:07,039
understand

00:31:05,360 --> 00:31:08,559
how they you can understand how they

00:31:07,039 --> 00:31:12,320
work um

00:31:08,559 --> 00:31:13,919
and uh and and kind of just build your

00:31:12,320 --> 00:31:15,760
mental model i don't know i

00:31:13,919 --> 00:31:17,760
i i really like that that's kind of

00:31:15,760 --> 00:31:20,480
that's why that interactivity is

00:31:17,760 --> 00:31:21,519
things that something that things never

00:31:20,480 --> 00:31:22,960
feel real for

00:31:21,519 --> 00:31:24,880
people until they can get their hands on

00:31:22,960 --> 00:31:25,760
them so being able to make things

00:31:24,880 --> 00:31:29,760
tactile is

00:31:25,760 --> 00:31:33,600
such a powerful thing in computing

00:31:29,760 --> 00:31:35,120
i agree thank you very much kate um

00:31:33,600 --> 00:31:37,279
thank you for for helping us close out

00:31:35,120 --> 00:31:38,480
by mancon this year oh it was awesome

00:31:37,279 --> 00:31:39,440
thank you so much for putting on an

00:31:38,480 --> 00:31:42,320
amazing

00:31:39,440 --> 00:31:44,000
uh virtual conference really glad to see

00:31:42,320 --> 00:31:44,960
these things kind of thriving even when

00:31:44,000 --> 00:31:50,159
we're all

00:31:44,960 --> 00:31:50,159

YouTube URL: https://www.youtube.com/watch?v=6XIrhcaqctI


