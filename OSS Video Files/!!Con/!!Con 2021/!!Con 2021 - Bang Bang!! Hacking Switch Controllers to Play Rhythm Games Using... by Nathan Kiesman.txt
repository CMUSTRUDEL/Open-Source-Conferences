Title: !!Con 2021 - Bang Bang!! Hacking Switch Controllers to Play Rhythm Games Using... by Nathan Kiesman
Publication date: 2021-07-06
Playlist: !!Con 2021
Description: 
	Bang Bang!! Hacking Switch Controllers to Play Rhythm Games Using A Real Drum! by Nathan Kiesman

Taiko is a Japanese drumming tradition that dates back thousands of years, and has enjoyed a resurgence of popularity in the last decade. It is also the subject of an insanely cute rhythm game called “Taiko no Tatsujin”! However, unless the arcade version can be found, the player is stuck waving their controllers around, playing an imaginary drum. That is, unless this intrepid player has a homemade taiko drum, a microphone, a Teensy microcontroller, a rudimentary understanding of signal processing, and (optionally) access to a Target store. Learn about one of the most powerful and easy to use hobbyist microcontrollers, how computers can understand sound, and most importantly - how to Bang Bang! in style!

Nathan is a student at Columbia University (Go Lions!) studying electrical engineering and computing history, and is also president of the CU Taiko Club. When not working on problem sets, he’s generally exploring retro-tech, enjoying long walks on Maine’s beaches, creating and sharing art, wandering aimlessly around the World Wide Web, and telling terrible jokes. One project he’s working on right now is documenting XBAND, a defunct and recently resurrected dial-up network for the Super Nintendo.
Captions: 
	00:00:12,480 --> 00:00:15,679
hey there

00:00:13,120 --> 00:00:17,760
uh i'm nathan uh that was not my

00:00:15,679 --> 00:00:18,720
description i wish i have set a swimming

00:00:17,760 --> 00:00:20,240
pool on fire

00:00:18,720 --> 00:00:23,119
uh but that was actually for someone

00:00:20,240 --> 00:00:26,000
else uh anyway i'm nathan

00:00:23,119 --> 00:00:27,920
uh and i play the drums uh well more

00:00:26,000 --> 00:00:29,760
specifically the drum

00:00:27,920 --> 00:00:31,519
a year and a half ago i joined a taiko

00:00:29,760 --> 00:00:34,480
drumming club at my school

00:00:31,519 --> 00:00:36,320
taiko is a japanese word meaning drum

00:00:34,480 --> 00:00:37,120
but it usually refers to playing many

00:00:36,320 --> 00:00:40,000
chew daiko

00:00:37,120 --> 00:00:41,040
or fat drums in a small ensemble i

00:00:40,000 --> 00:00:42,719
absolutely love it

00:00:41,040 --> 00:00:44,399
mostly because i get to play very loud

00:00:42,719 --> 00:00:46,079
music for hours on end

00:00:44,399 --> 00:00:47,760
and i don't have to worry about learning

00:00:46,079 --> 00:00:50,160
things like chords or

00:00:47,760 --> 00:00:52,239
scales or any of that music stuff

00:00:50,160 --> 00:00:53,680
however due to my school being closed i

00:00:52,239 --> 00:00:55,920
have been able to play with my group in

00:00:53,680 --> 00:00:58,800
over a year

00:00:55,920 --> 00:01:00,399
luckily nintendo has come to the rescue

00:00:58,800 --> 00:01:02,320
originally an arcade title

00:01:00,399 --> 00:01:04,239
taiko no tatu-jin for the nintendo

00:01:02,320 --> 00:01:06,960
switch is a rhythm game where you

00:01:04,239 --> 00:01:06,960
play taiko

00:01:07,680 --> 00:01:11,360
but unless you can find the arcade

00:01:09,200 --> 00:01:12,799
version or pay extra for a fake drum

00:01:11,360 --> 00:01:14,560
you're stuck waving the controllers

00:01:12,799 --> 00:01:15,040
around in the air pretending to play a

00:01:14,560 --> 00:01:16,960
drum

00:01:15,040 --> 00:01:18,400
which is not nearly as fun as wailing on

00:01:16,960 --> 00:01:20,159
a real one

00:01:18,400 --> 00:01:21,600
my first attempt to improve this made it

00:01:20,159 --> 00:01:23,280
feel somewhat more realistic

00:01:21,600 --> 00:01:24,880
but it was pretty crude it missed a lot

00:01:23,280 --> 00:01:27,520
of hits and it just didn't feel quite

00:01:24,880 --> 00:01:29,040
right however since i have a real drum

00:01:27,520 --> 00:01:31,360
why can i make something so i could play

00:01:29,040 --> 00:01:33,200
with it instead of the controllers

00:01:31,360 --> 00:01:35,360
so to do this we need something that can

00:01:33,200 --> 00:01:37,200
listen to the drum using a microphone

00:01:35,360 --> 00:01:38,720
translate it into button presses for the

00:01:37,200 --> 00:01:40,400
game this

00:01:38,720 --> 00:01:42,640
is where the mighty microcontroller

00:01:40,400 --> 00:01:45,280
comes in a microcontroller

00:01:42,640 --> 00:01:46,320
is a chip that contains a processor ram

00:01:45,280 --> 00:01:48,799
program storage

00:01:46,320 --> 00:01:50,720
and interfaces for other electronics

00:01:48,799 --> 00:01:52,399
it's the perfect tool to take in signals

00:01:50,720 --> 00:01:55,280
and event from electronic hardware

00:01:52,399 --> 00:01:56,399
and act on that data they're absolutely

00:01:55,280 --> 00:01:58,000
useless on their own

00:01:56,399 --> 00:01:59,759
but can be connected to anything that

00:01:58,000 --> 00:02:01,200
uses electricity and a lot of things

00:01:59,759 --> 00:02:02,880
that don't

00:02:01,200 --> 00:02:04,799
the most famous microcontroller is the

00:02:02,880 --> 00:02:05,759
arduino made famous by maker blogs

00:02:04,799 --> 00:02:07,840
around the globe

00:02:05,759 --> 00:02:08,959
it's a great board it's very low sim

00:02:07,840 --> 00:02:11,039
very low power

00:02:08,959 --> 00:02:12,720
very simple but the chip in many of them

00:02:11,039 --> 00:02:13,920
is 15 years old so it's pretty slow

00:02:12,720 --> 00:02:16,400
nowadays

00:02:13,920 --> 00:02:17,680
for this i use the teensy it uses the

00:02:16,400 --> 00:02:19,360
same code as the arduino

00:02:17,680 --> 00:02:21,200
it has compatible libraries but it also

00:02:19,360 --> 00:02:23,200
has a ton of new libraries on top to

00:02:21,200 --> 00:02:25,360
interface with more advanced hardware

00:02:23,200 --> 00:02:26,560
it's super fast it can emulate all kinds

00:02:25,360 --> 00:02:28,319
of usb devices

00:02:26,560 --> 00:02:31,040
it has great support from its creator

00:02:28,319 --> 00:02:33,120
and it's teensy it's very small

00:02:31,040 --> 00:02:34,800
another board is the rp2040 by the

00:02:33,120 --> 00:02:36,720
raspberry pi foundation

00:02:34,800 --> 00:02:38,480
it's more powerful than the teensy at a

00:02:36,720 --> 00:02:39,760
quarter of the price but it's brand new

00:02:38,480 --> 00:02:40,720
and had only been out for a few days

00:02:39,760 --> 00:02:43,120
when i started this

00:02:40,720 --> 00:02:44,800
so i didn't use it i also could have

00:02:43,120 --> 00:02:46,319
used a regular raspberry pi or the

00:02:44,800 --> 00:02:49,120
raspberry pi zero

00:02:46,319 --> 00:02:49,599
uh these are great if you need to do

00:02:49,120 --> 00:02:51,680
video

00:02:49,599 --> 00:02:53,280
or talk to the internet but it is a tiny

00:02:51,680 --> 00:02:54,160
computer which means you have to deal

00:02:53,280 --> 00:02:56,400
with all the

00:02:54,160 --> 00:02:58,400
not so joyful parts of computing like

00:02:56,400 --> 00:02:59,120
updates and long boot times as opposed

00:02:58,400 --> 00:03:01,040
to these

00:02:59,120 --> 00:03:02,879
which directly run processor

00:03:01,040 --> 00:03:04,400
instructions without an os getting in

00:03:02,879 --> 00:03:06,480
the way

00:03:04,400 --> 00:03:08,400
so first we need to get audio data from

00:03:06,480 --> 00:03:09,360
the mic in the form of an analog voltage

00:03:08,400 --> 00:03:11,519
waveform

00:03:09,360 --> 00:03:13,280
into the teensy and to do this i use

00:03:11,519 --> 00:03:15,440
another one of my favorites

00:03:13,280 --> 00:03:17,360
the teensy audio board this adds a

00:03:15,440 --> 00:03:19,599
microphone and headphone ports to the

00:03:17,360 --> 00:03:22,239
teensy along with an sd card slot for

00:03:19,599 --> 00:03:22,239
sound files

00:03:23,200 --> 00:03:26,480
it's also built to be compatible with

00:03:24,799 --> 00:03:28,720
the teensy audio library

00:03:26,480 --> 00:03:30,560
and its audio systems design tool which

00:03:28,720 --> 00:03:31,519
is one of my favorite programming tools

00:03:30,560 --> 00:03:34,000
ever

00:03:31,519 --> 00:03:34,799
this designer gives you a bunch of input

00:03:34,000 --> 00:03:37,680
output

00:03:34,799 --> 00:03:39,360
synthesizer filter and analysis block so

00:03:37,680 --> 00:03:41,120
you can connect together graphically

00:03:39,360 --> 00:03:43,360
and it even tells you how to use them

00:03:41,120 --> 00:03:46,640
then once you're done designing

00:03:43,360 --> 00:03:48,239
your layout you click export and it

00:03:46,640 --> 00:03:49,920
gives you a code block to paste into the

00:03:48,239 --> 00:03:50,560
beginning of your program and it just

00:03:49,920 --> 00:03:52,400
works

00:03:50,560 --> 00:03:54,959
it's super powerful especially for a

00:03:52,400 --> 00:03:57,439
board as low level as the teensy

00:03:54,959 --> 00:03:59,439
so for our application if we needed to

00:03:57,439 --> 00:04:01,519
detect just any kind of loud bang

00:03:59,439 --> 00:04:03,680
we could use simple peak detection like

00:04:01,519 --> 00:04:05,920
shown here however

00:04:03,680 --> 00:04:06,720
tycho uses both hits on the center of

00:04:05,920 --> 00:04:09,200
the drum

00:04:06,720 --> 00:04:09,840
making a low bass sound and on the rim

00:04:09,200 --> 00:04:12,400
of the drum

00:04:09,840 --> 00:04:14,000
making a higher pitched tac sound so we

00:04:12,400 --> 00:04:14,560
need to be able to differentiate and

00:04:14,000 --> 00:04:16,320
detect

00:04:14,560 --> 00:04:17,840
both these kinds of hits based on their

00:04:16,320 --> 00:04:20,239
pitch

00:04:17,840 --> 00:04:21,919
to detect pitch we need to use an fft

00:04:20,239 --> 00:04:22,960
which stands for a fast fourier

00:04:21,919 --> 00:04:25,520
transform

00:04:22,960 --> 00:04:27,520
what's a fast fourier transform well

00:04:25,520 --> 00:04:30,720
it's like a regular fourier transform

00:04:27,520 --> 00:04:32,479
but just way faster fourier transforms

00:04:30,720 --> 00:04:34,720
are a very deep subject

00:04:32,479 --> 00:04:36,240
but for our simple use case we're taking

00:04:34,720 --> 00:04:38,800
small slices of time

00:04:36,240 --> 00:04:39,280
this library uses 340 fourths of a

00:04:38,800 --> 00:04:42,080
second

00:04:39,280 --> 00:04:43,680
for some reason and using it to tell us

00:04:42,080 --> 00:04:46,080
what frequencies or pitches

00:04:43,680 --> 00:04:49,040
are present in that slice of time this

00:04:46,080 --> 00:04:53,120
method gives us an array of 256 floats

00:04:49,040 --> 00:04:53,840
each index representing a bin 172 hertz

00:04:53,120 --> 00:04:56,000
wide

00:04:53,840 --> 00:04:58,400
and the percentage of the sound that

00:04:56,000 --> 00:05:00,160
fits into that frequency bin

00:04:58,400 --> 00:05:01,919
so using one of the examples included

00:05:00,160 --> 00:05:03,680
with the library i made a test program

00:05:01,919 --> 00:05:04,960
that listens to audio from a computer

00:05:03,680 --> 00:05:07,039
over usb

00:05:04,960 --> 00:05:09,039
and prints the fft arrays to the console

00:05:07,039 --> 00:05:10,720
whenever it hears a sound

00:05:09,039 --> 00:05:11,919
then i recorded some drum hits and i

00:05:10,720 --> 00:05:14,080
played them back so i'd have a

00:05:11,919 --> 00:05:15,600
repeatable signal and wouldn't go but

00:05:14,080 --> 00:05:19,039
wouldn't have to go back to the drum and

00:05:15,600 --> 00:05:20,800
smack it every time i recompiled

00:05:19,039 --> 00:05:22,639
so here are some representative hits

00:05:20,800 --> 00:05:23,600
along with their corresponding fft

00:05:22,639 --> 00:05:25,280
readouts

00:05:23,600 --> 00:05:27,600
looking at this i noticed that hits on

00:05:25,280 --> 00:05:28,800
the rim have never have any frequency in

00:05:27,600 --> 00:05:31,280
this bottom bin

00:05:28,800 --> 00:05:32,240
whereas hits in the center have tons of

00:05:31,280 --> 00:05:35,280
frequency

00:05:32,240 --> 00:05:37,680
in this bottom bin so my code gets to

00:05:35,280 --> 00:05:41,039
simply wait for any kind of audio spike

00:05:37,680 --> 00:05:43,440
check that line of the fft and

00:05:41,039 --> 00:05:44,880
print center if it sees sound in this

00:05:43,440 --> 00:05:47,840
bottom bin right here

00:05:44,880 --> 00:05:49,440
or rim if it doesn't that's all we need

00:05:47,840 --> 00:05:51,440
to detect and differentiate between

00:05:49,440 --> 00:05:54,240
these two kinds of hits

00:05:51,440 --> 00:05:55,919
so now that we can detect hits we need

00:05:54,240 --> 00:05:58,800
to actually complete the other half

00:05:55,919 --> 00:06:00,720
that is pressing buttons within the game

00:05:58,800 --> 00:06:02,400
since the nintendo switch uses usb

00:06:00,720 --> 00:06:04,319
controllers and as we know the teensy

00:06:02,400 --> 00:06:06,639
can emulate usb devices

00:06:04,319 --> 00:06:08,240
i thought it could be done over usb and

00:06:06,639 --> 00:06:08,880
sure enough i found a library that does

00:06:08,240 --> 00:06:11,680
just that

00:06:08,880 --> 00:06:13,039
so i installed it and that does not look

00:06:11,680 --> 00:06:15,440
good

00:06:13,039 --> 00:06:17,440
so turns out this library doesn't quite

00:06:15,440 --> 00:06:19,440
implement usb correctly and basically

00:06:17,440 --> 00:06:21,520
undefines all print statements causing

00:06:19,440 --> 00:06:23,360
tons of compiler errors

00:06:21,520 --> 00:06:26,080
so i did what any rational programmer

00:06:23,360 --> 00:06:27,360
would do and i commented out all 854

00:06:26,080 --> 00:06:28,400
print statements from the standard

00:06:27,360 --> 00:06:30,960
libraries

00:06:28,400 --> 00:06:32,160
you know typical coding stuff this made

00:06:30,960 --> 00:06:36,000
my code compile

00:06:32,160 --> 00:06:38,240
yay uh however uh shockingly enough it

00:06:36,000 --> 00:06:39,919
still didn't work

00:06:38,240 --> 00:06:42,639
so i did what any rational programmer

00:06:39,919 --> 00:06:44,319
would do again and i went to target

00:06:42,639 --> 00:06:46,880
and i bought the cheapest controller i

00:06:44,319 --> 00:06:51,039
could find after all if we can't emulate

00:06:46,880 --> 00:06:51,039
the controller we'll emulate the player

00:06:51,280 --> 00:06:54,720
i got this in response when i shared my

00:06:53,120 --> 00:06:56,400
improvised plan with a friend

00:06:54,720 --> 00:06:58,960
and personally i think this is

00:06:56,400 --> 00:07:00,720
electronics in a nutshell

00:06:58,960 --> 00:07:02,319
cracking the case open we can see that

00:07:00,720 --> 00:07:04,800
this shoulder button right here

00:07:02,319 --> 00:07:06,479
is connected by easy to access wires

00:07:04,800 --> 00:07:08,400
shown here

00:07:06,479 --> 00:07:09,840
using an ohm meter i found out that

00:07:08,400 --> 00:07:11,840
every time the button is pressed it

00:07:09,840 --> 00:07:13,520
connects the ground of the controller

00:07:11,840 --> 00:07:15,039
to the processor inside of the

00:07:13,520 --> 00:07:17,120
controller

00:07:15,039 --> 00:07:18,880
so if we connect our teensy to the wire

00:07:17,120 --> 00:07:21,360
as well it can simulate a press

00:07:18,880 --> 00:07:23,039
of the button by putting a low or zero

00:07:21,360 --> 00:07:24,720
volt signal on that line

00:07:23,039 --> 00:07:27,360
essentially connecting it to ground like

00:07:24,720 --> 00:07:27,360
the button does

00:07:28,880 --> 00:07:32,720
so i wired it together i modified the

00:07:31,759 --> 00:07:34,400
code to correct

00:07:32,720 --> 00:07:36,319
to press the correct button when it

00:07:34,400 --> 00:07:38,080
heard a drum hit and i hooked up this

00:07:36,319 --> 00:07:39,919
mess of wires to my switch

00:07:38,080 --> 00:07:42,240
which not only didn't catch fire or

00:07:39,919 --> 00:07:44,960
break but it actually started responding

00:07:42,240 --> 00:07:47,360
to the fake button presses

00:07:44,960 --> 00:07:50,080
so i changed the input in the code from

00:07:47,360 --> 00:07:52,000
usb audio to the line in jack

00:07:50,080 --> 00:07:54,400
i soldered in a microphone jack to the

00:07:52,000 --> 00:07:59,840
board i hooked up my microphone

00:07:54,400 --> 00:07:59,840
and i tried it with my drum

00:08:10,840 --> 00:08:13,840
my

00:08:22,479 --> 00:08:27,520
i love those corgis uh so if any of you

00:08:25,360 --> 00:08:29,360
played taiko uh please don't mention my

00:08:27,520 --> 00:08:30,720
terrible form to everyone else uh

00:08:29,360 --> 00:08:32,240
hopefully we can keep that a secret

00:08:30,720 --> 00:08:34,479
between us

00:08:32,240 --> 00:08:35,839
anyway uh this works surprisingly well

00:08:34,479 --> 00:08:37,360
without a lot of tweaking

00:08:35,839 --> 00:08:39,599
uh i think it was helped a lot by this

00:08:37,360 --> 00:08:41,599
game being designed for motion controls

00:08:39,599 --> 00:08:43,839
so it's pretty lenient with double hits

00:08:41,599 --> 00:08:45,440
or hits that are too early or too late

00:08:43,839 --> 00:08:47,519
which i guess i accidentally took

00:08:45,440 --> 00:08:49,600
advantage of

00:08:47,519 --> 00:08:51,839
so although i don't think many of you

00:08:49,600 --> 00:08:52,480
will go out and buy drums to recreate

00:08:51,839 --> 00:08:54,640
this

00:08:52,480 --> 00:08:56,800
i hope this can serve as inspiration for

00:08:54,640 --> 00:08:58,800
future projects of your own

00:08:56,800 --> 00:09:00,480
i usually like to modify hardware and

00:08:58,800 --> 00:09:02,320
tack on my own electronics like this

00:09:00,480 --> 00:09:03,920
instead of making things from scratch

00:09:02,320 --> 00:09:06,080
uh usually because i can use their

00:09:03,920 --> 00:09:06,959
existing power supplies and enclosures

00:09:06,080 --> 00:09:09,519
and interface

00:09:06,959 --> 00:09:10,720
so there's less for me to do myself in

00:09:09,519 --> 00:09:12,080
this case i would have had to make a

00:09:10,720 --> 00:09:14,000
controller from scratch

00:09:12,080 --> 00:09:15,680
which i have no idea how to do or worse

00:09:14,000 --> 00:09:17,839
yet make my own game

00:09:15,680 --> 00:09:19,200
and wow have you seen how much effort

00:09:17,839 --> 00:09:21,120
that takes

00:09:19,200 --> 00:09:22,800
plus it's fun to share mods of games and

00:09:21,120 --> 00:09:24,320
hardware with folks because you get an

00:09:22,800 --> 00:09:25,920
instant level of understanding with them

00:09:24,320 --> 00:09:29,440
when you proclaim ah i did

00:09:25,920 --> 00:09:30,800
x with y which is pretty nice however

00:09:29,440 --> 00:09:32,000
this means that there isn't a full

00:09:30,800 --> 00:09:32,959
understanding of everything in the

00:09:32,000 --> 00:09:34,560
system

00:09:32,959 --> 00:09:37,120
which can make troubleshooting a lot

00:09:34,560 --> 00:09:39,920
more painful if something goes wrong

00:09:37,120 --> 00:09:41,600
i usually just hope nothing goes wrong

00:09:39,920 --> 00:09:43,600
uh if you want to do more

00:09:41,600 --> 00:09:46,000
hardware hacking or making stuff like

00:09:43,600 --> 00:09:46,320
this great places to get inspiration and

00:09:46,000 --> 00:09:48,720
help

00:09:46,320 --> 00:09:50,959
include adafruit and sparkfun who make

00:09:48,720 --> 00:09:53,519
electronics for hobbyists like myself

00:09:50,959 --> 00:09:55,200
and they publish tons of project guides

00:09:53,519 --> 00:09:57,040
tons of how to's

00:09:55,200 --> 00:09:58,880
and they even open source all of their

00:09:57,040 --> 00:10:00,240
hardware and software design so they're

00:09:58,880 --> 00:10:01,720
they're really great companies really

00:10:00,240 --> 00:10:04,079
great resources

00:10:01,720 --> 00:10:05,440
hackaday.com and make magazine also has

00:10:04,079 --> 00:10:08,560
a tons of inspiration

00:10:05,440 --> 00:10:10,959
for projects like this uh anyway

00:10:08,560 --> 00:10:12,640
uh that's it from me i hope you enjoyed

00:10:10,959 --> 00:10:15,920
and uh thank you so much for your

00:10:12,640 --> 00:10:15,920

YouTube URL: https://www.youtube.com/watch?v=FhbSdsqr2mA


