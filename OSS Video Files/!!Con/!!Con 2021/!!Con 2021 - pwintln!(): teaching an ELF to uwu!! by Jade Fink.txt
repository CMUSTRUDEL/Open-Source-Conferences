Title: !!Con 2021 - pwintln!(): teaching an ELF to uwu!! by Jade Fink
Publication date: 2021-07-06
Playlist: !!Con 2021
Description: 
	pwintln!(): teaching an ELF to uwu!! by Jade Fink

Linux programs can print output in uwu-speak, but they either need to have their output filtered after the fact, or need to use special functions to output such text. This is clearly unacceptable! I should be able to include an uwuifier library so all my program’s output is uwuified, nyowo mattew whewe it came fwowom!!

I will show the learning process from idea to minimal prototype of a text uwuifier that, with one function call, inserts itself into its process using tricks from binary exploitation for ironically benign purposes. I figure out how the dynamic linker resolves function calls to the system C library and redirect them for my own nefarious purposes by fooling around with a debugger!

Jade is a Computer Engineering student at the University of British Columbia in Vancouver. While she’s not hacking on tooling (primarily Rust), operating systems, or making jokes on Twitter, she likes to bake and go on long bike rides around the city.
Captions: 
	00:00:13,040 --> 00:00:15,280
hi

00:00:13,679 --> 00:00:18,320
i'm jade and today i'm going to show how

00:00:15,280 --> 00:00:19,840
to turn println into 0.01

00:00:18,320 --> 00:00:22,160
you can find a link to these slides on

00:00:19,840 --> 00:00:24,480
the bottom left this idea was inspired

00:00:22,160 --> 00:00:26,960
by my friend 6b4c on twitter

00:00:24,480 --> 00:00:28,480
and i further developed it into a crate

00:00:26,960 --> 00:00:30,240
called puentelen that is available on

00:00:28,480 --> 00:00:31,760
the crates registry this talk

00:00:30,240 --> 00:00:33,440
demonstrates the

00:00:31,760 --> 00:00:36,320
prototyping process that went into that

00:00:33,440 --> 00:00:37,520
crate this is currently in safer station

00:00:36,320 --> 00:00:39,920
you'll be seeing some more of them in

00:00:37,520 --> 00:00:41,360
the slides they're a friend

00:00:39,920 --> 00:00:42,879
so i remember reading about a binary

00:00:41,360 --> 00:00:44,399
exploitation technique where you could

00:00:42,879 --> 00:00:45,360
overwrite some function pointers in

00:00:44,399 --> 00:00:48,160
memory and get

00:00:45,360 --> 00:00:49,760
programmed to go elsewhere when

00:00:48,160 --> 00:00:50,399
functions from external libraries such

00:00:49,760 --> 00:00:54,559
as

00:00:50,399 --> 00:00:56,079
the system c library lib c are called

00:00:54,559 --> 00:00:59,600
let's try writing a program and see what

00:00:56,079 --> 00:01:00,800
we can find of those

00:00:59,600 --> 00:01:02,079
so we're going to make a string hello

00:01:00,800 --> 00:01:03,039
bang bang con and then we're going to

00:01:02,079 --> 00:01:05,680
write it to the screen

00:01:03,039 --> 00:01:06,479
so we're going to use the right call and

00:01:05,680 --> 00:01:09,119
we're going to pass

00:01:06,479 --> 00:01:10,479
fall descriptor number one which is

00:01:09,119 --> 00:01:11,360
standard output

00:01:10,479 --> 00:01:13,119
and then we're going to give it a

00:01:11,360 --> 00:01:14,799
pointer to our string we need to turn

00:01:13,119 --> 00:01:15,840
that into a void pointer so let's cast

00:01:14,799 --> 00:01:17,040
that

00:01:15,840 --> 00:01:19,360
and then let's give it our string's

00:01:17,040 --> 00:01:19,360
length

00:01:20,080 --> 00:01:23,840
then we get an error that we need to use

00:01:21,520 --> 00:01:27,520
an unsafe block so let's do that

00:01:23,840 --> 00:01:30,560
because raw pointers are safe to use and

00:01:27,520 --> 00:01:31,920
now let's compile and run our program

00:01:30,560 --> 00:01:33,360
let's look at it in a debugger and see

00:01:31,920 --> 00:01:35,200
if we can find those function pointers

00:01:33,360 --> 00:01:36,560
we're looking for

00:01:35,200 --> 00:01:40,880
so we're going to set a breakpoint at

00:01:36,560 --> 00:01:42,240
the start of our program

00:01:40,880 --> 00:01:44,880
and then we're going to disassemble our

00:01:42,240 --> 00:01:45,280
program so we see at the bottom here a

00:01:44,880 --> 00:01:48,640
jump

00:01:45,280 --> 00:01:51,759
keyword pointer rip plus some offset

00:01:48,640 --> 00:01:53,439
the square bracket syntax there is

00:01:51,759 --> 00:01:55,280
a pointer dereference so it's

00:01:53,439 --> 00:01:57,600
dereferencing the pointer

00:01:55,280 --> 00:01:58,719
three nine five nine nine bytes after

00:01:57,600 --> 00:02:00,960
the

00:01:58,719 --> 00:02:02,240
current instruction so if we look at

00:02:00,960 --> 00:02:05,520
what's actually there

00:02:02,240 --> 00:02:07,520
at address five five five whatever

00:02:05,520 --> 00:02:09,200
then we see that there's another pointer

00:02:07,520 --> 00:02:10,399
and we find that if we look at what's at

00:02:09,200 --> 00:02:12,800
that pointer

00:02:10,399 --> 00:02:14,319
we find it's a pointer into write in the

00:02:12,800 --> 00:02:16,400
system c library so that's what we

00:02:14,319 --> 00:02:18,720
expect to see

00:02:16,400 --> 00:02:19,840
however how would we find this address

00:02:18,720 --> 00:02:21,360
so

00:02:19,840 --> 00:02:23,040
in order to answer that we need to look

00:02:21,360 --> 00:02:25,840
at when pulp is so when elf is the

00:02:23,040 --> 00:02:28,000
executable format used by linux and bsd

00:02:25,840 --> 00:02:29,520
it loads various sections out of your

00:02:28,000 --> 00:02:31,920
executable into

00:02:29,520 --> 00:02:34,000
requested locations in memory with

00:02:31,920 --> 00:02:35,680
requested permissions

00:02:34,000 --> 00:02:37,599
and it also allows for dynamic linking

00:02:35,680 --> 00:02:39,760
which means that you can have libraries

00:02:37,599 --> 00:02:41,760
that you can replace without having to

00:02:39,760 --> 00:02:43,840
recompile your program

00:02:41,760 --> 00:02:46,239
how do they do dynamic linking so on

00:02:43,840 --> 00:02:48,879
linux dynamic linking is accomplished

00:02:46,239 --> 00:02:49,760
by the dynamic loader which gets at your

00:02:48,879 --> 00:02:52,959
program before

00:02:49,760 --> 00:02:53,360
you get control and it will load all of

00:02:52,959 --> 00:02:57,360
your

00:02:53,360 --> 00:02:59,200
dynamic libraries and set relocations

00:02:57,360 --> 00:03:00,480
of all the functions that you call in

00:02:59,200 --> 00:03:02,840
those dynamic libraries

00:03:00,480 --> 00:03:04,319
to pointers to the actual functions

00:03:02,840 --> 00:03:06,319
memory

00:03:04,319 --> 00:03:08,000
so we want to read a relocation and for

00:03:06,319 --> 00:03:10,560
that we're going to use readoff

00:03:08,000 --> 00:03:11,440
so let's try that out so we're going to

00:03:10,560 --> 00:03:13,680
read the help page

00:03:11,440 --> 00:03:15,599
for readoff and see if we can find

00:03:13,680 --> 00:03:18,159
something to do with relocations

00:03:15,599 --> 00:03:19,440
and indeed we have dash r which deals

00:03:18,159 --> 00:03:22,959
with relocations

00:03:19,440 --> 00:03:24,080
okay so let's try looking at that

00:03:22,959 --> 00:03:26,239
so we're going to go look at the

00:03:24,080 --> 00:03:27,920
relocations of our executable

00:03:26,239 --> 00:03:30,080
and search for the write function in

00:03:27,920 --> 00:03:32,080
glibc

00:03:30,080 --> 00:03:33,920
we find that it is indeed there and it

00:03:32,080 --> 00:03:35,360
is at some offset

00:03:33,920 --> 00:03:36,959
we don't necessarily know what this

00:03:35,360 --> 00:03:38,879
offset is for yet

00:03:36,959 --> 00:03:40,239
but let's guess that it's probably from

00:03:38,879 --> 00:03:42,000
the start of our program

00:03:40,239 --> 00:03:43,519
we can find the survey program by

00:03:42,000 --> 00:03:46,239
running info proc mappings

00:03:43,519 --> 00:03:47,440
in gdb what this will do is it will find

00:03:46,239 --> 00:03:49,599
all the regions of memory

00:03:47,440 --> 00:03:50,640
that our program owns and we see that

00:03:49,599 --> 00:03:53,200
this

00:03:50,640 --> 00:03:54,400
top one is at opposite zero of our

00:03:53,200 --> 00:03:56,400
executable

00:03:54,400 --> 00:03:57,599
so that probably confirms our hypothesis

00:03:56,400 --> 00:03:59,680
already but let's

00:03:57,599 --> 00:04:00,879
let's continue testing it so we're going

00:03:59,680 --> 00:04:01,680
to add the offset that we got from

00:04:00,879 --> 00:04:03,280
vdolph

00:04:01,680 --> 00:04:05,200
to the number we got from gdb for the

00:04:03,280 --> 00:04:06,319
base of our program

00:04:05,200 --> 00:04:09,200
and then we're going to dereference that

00:04:06,319 --> 00:04:10,319
as a pointer and we see a 7fff value

00:04:09,200 --> 00:04:12,080
that we saw before

00:04:10,319 --> 00:04:13,519
so that already looks promising and

00:04:12,080 --> 00:04:14,159
indeed if we look at an instruction

00:04:13,519 --> 00:04:16,320
there

00:04:14,159 --> 00:04:18,479
we see that it is part of the right call

00:04:16,320 --> 00:04:20,400
so that's good

00:04:18,479 --> 00:04:22,320
let's start writing a wrapper so this

00:04:20,400 --> 00:04:25,360
wrapper has the same signature as

00:04:22,320 --> 00:04:28,000
the write function in libsy except it's

00:04:25,360 --> 00:04:30,720
translated into rust syntax

00:04:28,000 --> 00:04:32,639
first to wrap this we need to turn our

00:04:30,720 --> 00:04:35,040
input into a slice

00:04:32,639 --> 00:04:36,960
of bytes and then we take that slice of

00:04:35,040 --> 00:04:37,360
bytes and then we turn it into a string

00:04:36,960 --> 00:04:38,639
so

00:04:37,360 --> 00:04:43,199
it's a reference to the string that we

00:04:38,639 --> 00:04:43,919
were given then we convert that string

00:04:43,199 --> 00:04:46,960
to

00:04:43,919 --> 00:04:48,240
utf-8 while strings are utf-8 and then

00:04:46,960 --> 00:04:50,639
we need to

00:04:48,240 --> 00:04:51,440
copy that into heap memory as an own

00:04:50,639 --> 00:04:54,479
string

00:04:51,440 --> 00:04:56,240
and then a willify it so

00:04:54,479 --> 00:04:57,520
now we have a woofie string so now we

00:04:56,240 --> 00:05:00,720
need to write it to the screen

00:04:57,520 --> 00:05:03,680
however since we are going to overwrite

00:05:00,720 --> 00:05:05,600
the pointer to the right function we

00:05:03,680 --> 00:05:07,280
have to store away its original value

00:05:05,600 --> 00:05:09,520
because we can't call it through its

00:05:07,280 --> 00:05:11,199
normal method

00:05:09,520 --> 00:05:12,479
so we're going to make a global variable

00:05:11,199 --> 00:05:13,680
that we're just going to store the

00:05:12,479 --> 00:05:17,199
address of

00:05:13,680 --> 00:05:18,800
the write function at so in our wrapper

00:05:17,199 --> 00:05:21,440
then we are going to

00:05:18,800 --> 00:05:22,639
use that global variable to call the

00:05:21,440 --> 00:05:25,440
write function

00:05:22,639 --> 00:05:26,800
the original one with our woofie string

00:05:25,440 --> 00:05:29,520
with the same file descriptor

00:05:26,800 --> 00:05:30,000
and with the of5 string's length we then

00:05:29,520 --> 00:05:32,320
have to

00:05:30,000 --> 00:05:34,400
lie to our caller that we have written

00:05:32,320 --> 00:05:39,039
exactly how much they've asked for

00:05:34,400 --> 00:05:41,120
because otherwise it will go badly if we

00:05:39,039 --> 00:05:42,880
say actually wrote more than they asked

00:05:41,120 --> 00:05:44,479
for because we added some characters

00:05:42,880 --> 00:05:45,759
while overfine

00:05:44,479 --> 00:05:48,720
we then have to also add our

00:05:45,759 --> 00:05:50,400
verification library

00:05:48,720 --> 00:05:52,320
next we need to overwrite that function

00:05:50,400 --> 00:05:54,240
pointer so we're going to take

00:05:52,320 --> 00:05:55,520
in the hex address from the command line

00:05:54,240 --> 00:05:58,319
that we had gotten from

00:05:55,520 --> 00:05:59,840
readolf and then we're going to add that

00:05:58,319 --> 00:06:02,720
to the base address of our program that

00:05:59,840 --> 00:06:02,720
we got from before

00:06:05,680 --> 00:06:09,280
next we're going to uh de-reference that

00:06:08,720 --> 00:06:11,120
pointer

00:06:09,280 --> 00:06:14,080
and overwrite it but first we have to

00:06:11,120 --> 00:06:17,120
store it away in our global variable

00:06:14,080 --> 00:06:19,520
so we're going to use

00:06:17,120 --> 00:06:21,360
uh mem transmute which what that does is

00:06:19,520 --> 00:06:23,759
it converts a value of any type

00:06:21,360 --> 00:06:25,280
in rust into any other type it is

00:06:23,759 --> 00:06:26,560
extremely unsafe and therefore a lot of

00:06:25,280 --> 00:06:30,479
fun

00:06:26,560 --> 00:06:32,800
so we turn the dereferenced value

00:06:30,479 --> 00:06:35,120
of the relocation that is to say the

00:06:32,800 --> 00:06:37,120
address of the actual write function

00:06:35,120 --> 00:06:38,479
into a function pointer and then store

00:06:37,120 --> 00:06:42,160
it in our global variable

00:06:38,479 --> 00:06:44,639
then we overwrite the relocation

00:06:42,160 --> 00:06:45,280
with our replaced version then we

00:06:44,639 --> 00:06:49,360
rebuild the

00:06:45,280 --> 00:06:51,120
program we v delphi again because

00:06:49,360 --> 00:06:54,479
it's possible that the relocation moved

00:06:51,120 --> 00:06:54,479
because we added a bunch of code

00:06:54,639 --> 00:06:58,800
then we get the address and we set it as

00:06:57,360 --> 00:07:03,520
a command line argument with

00:06:58,800 --> 00:07:06,240
set args

00:07:03,520 --> 00:07:08,080
and then we run our program

00:07:06,240 --> 00:07:08,639
unfortunately it does a segmentation

00:07:08,080 --> 00:07:10,479
fault

00:07:08,639 --> 00:07:12,479
let's see if it is at least doing what

00:07:10,479 --> 00:07:15,120
we expect it to do

00:07:12,479 --> 00:07:17,680
so the address that we have is 555

00:07:15,120 --> 00:07:20,639
something which is what we saw before

00:07:17,680 --> 00:07:23,280
and if we look at what's at that address

00:07:20,639 --> 00:07:26,880
we indeed see a function pointer

00:07:23,280 --> 00:07:27,680
and if we look at what's at that

00:07:26,880 --> 00:07:29,599
function pointer

00:07:27,680 --> 00:07:31,680
indeed is a function pointer to write so

00:07:29,599 --> 00:07:34,800
it is what we expect it to be

00:07:31,680 --> 00:07:38,400
but the reason it failed is because

00:07:34,800 --> 00:07:40,080
as i said before the elf format allows

00:07:38,400 --> 00:07:40,639
you to specify permissions for regions

00:07:40,080 --> 00:07:42,880
of memory

00:07:40,639 --> 00:07:44,400
and so the relocations region is

00:07:42,880 --> 00:07:47,120
actually read only

00:07:44,400 --> 00:07:48,720
and therefore our right to it failed so

00:07:47,120 --> 00:07:50,560
all we have to do is we have to tell it

00:07:48,720 --> 00:07:51,759
that like actually we do want that to be

00:07:50,560 --> 00:07:54,960
writable

00:07:51,759 --> 00:07:57,440
and for that we use emprotect so

00:07:54,960 --> 00:07:58,000
what we're giving it is the address of

00:07:57,440 --> 00:08:01,759
the bottom

00:07:58,000 --> 00:08:04,560
of the 4096 byte page or

00:08:01,759 --> 00:08:05,840
region of memory that the function

00:08:04,560 --> 00:08:06,160
pointer that we're trying to overwrite

00:08:05,840 --> 00:08:09,840
is

00:08:06,160 --> 00:08:12,160
at and then we ask it to

00:08:09,840 --> 00:08:13,759
change an entire page at once the reason

00:08:12,160 --> 00:08:16,720
for this is that the granularity

00:08:13,759 --> 00:08:18,080
of memory permissions is one page we do

00:08:16,720 --> 00:08:19,919
some bit checks to get the bottom of the

00:08:18,080 --> 00:08:22,879
page

00:08:19,919 --> 00:08:24,080
then we go to read off again and go and

00:08:22,879 --> 00:08:27,039
get the right offset

00:08:24,080 --> 00:08:28,000
for our modified program and we set the

00:08:27,039 --> 00:08:31,440
arguments

00:08:28,000 --> 00:08:35,440
and we get hellouw yay

00:08:31,440 --> 00:08:39,200
all right so this also works on

00:08:35,440 --> 00:08:40,880
println uh because println internally

00:08:39,200 --> 00:08:42,560
calls right

00:08:40,880 --> 00:08:43,919
how do we do this properly though it

00:08:42,560 --> 00:08:45,920
turns out you're not actually supposed

00:08:43,919 --> 00:08:47,200
to redirect control flow of programs

00:08:45,920 --> 00:08:48,800
and generally that's considered a

00:08:47,200 --> 00:08:50,240
security vulnerability so there's

00:08:48,800 --> 00:08:52,000
various mitigations that are used to

00:08:50,240 --> 00:08:54,480
stop people doing this

00:08:52,000 --> 00:08:57,279
one example is layout randomization the

00:08:54,480 --> 00:08:59,600
program is not normally loaded at ox555

00:08:57,279 --> 00:09:01,279
it is loaded at a random address and

00:08:59,600 --> 00:09:03,680
that changes every time

00:09:01,279 --> 00:09:05,200
which means that shenanigans like this

00:09:03,680 --> 00:09:07,120
aren't supposed to work

00:09:05,200 --> 00:09:08,800
it only works because it's in a debugger

00:09:07,120 --> 00:09:10,240
the other thing is that the relocation

00:09:08,800 --> 00:09:11,279
section that we're trying to overwrite

00:09:10,240 --> 00:09:13,680
is right protected

00:09:11,279 --> 00:09:14,800
which is called railroad relocation's

00:09:13,680 --> 00:09:16,320
read only

00:09:14,800 --> 00:09:18,399
we also want to find the symbol

00:09:16,320 --> 00:09:21,279
ourselves and that's how we would get to

00:09:18,399 --> 00:09:23,360
like what the puente line crate does

00:09:21,279 --> 00:09:25,519
how do we start at finding the symbol

00:09:23,360 --> 00:09:29,200
well we want to look at readoff output

00:09:25,519 --> 00:09:30,880
and we find that we have this relocation

00:09:29,200 --> 00:09:34,160
section relay.dime so

00:09:30,880 --> 00:09:36,959
we need to find where that is and so

00:09:34,160 --> 00:09:37,600
with this convoluted page of diagram

00:09:36,959 --> 00:09:40,800
that was

00:09:37,600 --> 00:09:44,160
made from reading man5l for a long time

00:09:40,800 --> 00:09:47,760
we can find the symbol

00:09:44,160 --> 00:09:50,640
by looking at our program information

00:09:47,760 --> 00:09:53,120
so the starting point that you would use

00:09:50,640 --> 00:09:55,120
is get aux file which

00:09:53,120 --> 00:09:57,360
looks at information that the kernel

00:09:55,120 --> 00:09:58,640
returned while loading the program

00:09:57,360 --> 00:10:00,560
and that will tell us where our program

00:09:58,640 --> 00:10:03,279
headers are and then from that

00:10:00,560 --> 00:10:04,640
that's just the executable that's mapped

00:10:03,279 --> 00:10:06,399
directly into memory

00:10:04,640 --> 00:10:08,160
so then you essentially read the elf

00:10:06,399 --> 00:10:10,480
file as if it was

00:10:08,160 --> 00:10:11,920
on disk but just like out of your own

00:10:10,480 --> 00:10:13,920
memory

00:10:11,920 --> 00:10:16,079
you look at the program headers and use

00:10:13,920 --> 00:10:19,200
those to find your program base address

00:10:16,079 --> 00:10:20,959
and also where the dynamic table is

00:10:19,200 --> 00:10:22,640
from the dynamic table you know where

00:10:20,959 --> 00:10:25,440
the valet table is where the symbol

00:10:22,640 --> 00:10:26,959
table is and where the string table is

00:10:25,440 --> 00:10:29,519
from the relay table you go through each

00:10:26,959 --> 00:10:31,920
entry and then you can find

00:10:29,519 --> 00:10:32,959
the symbol table offset of each entry

00:10:31,920 --> 00:10:35,040
use that index

00:10:32,959 --> 00:10:36,320
into the symbol table and then that will

00:10:35,040 --> 00:10:38,720
tell you

00:10:36,320 --> 00:10:39,920
the string table offset of the name of

00:10:38,720 --> 00:10:42,240
the function

00:10:39,920 --> 00:10:43,760
you go through all of the relays until

00:10:42,240 --> 00:10:46,959
you find right

00:10:43,760 --> 00:10:48,240
and then you can and then you know what

00:10:46,959 --> 00:10:48,959
your offset is and then you can

00:10:48,240 --> 00:10:52,320
implement

00:10:48,959 --> 00:10:54,959
puentelen so this is very close to what

00:10:52,320 --> 00:10:56,880
puentelen is that we've already built in

00:10:54,959 --> 00:10:59,519
10 minutes

00:10:56,880 --> 00:11:00,120
so that's all i have enjoy the rest of

00:10:59,519 --> 00:11:03,120
your bang bang

00:11:00,120 --> 00:11:03,120

YouTube URL: https://www.youtube.com/watch?v=rB_2fzmMwDA


