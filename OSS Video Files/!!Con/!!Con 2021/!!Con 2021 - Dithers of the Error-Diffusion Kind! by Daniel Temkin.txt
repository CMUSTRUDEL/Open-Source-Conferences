Title: !!Con 2021 - Dithers of the Error-Diffusion Kind! by Daniel Temkin
Publication date: 2021-07-06
Playlist: !!Con 2021
Description: 
	Dithers of the Error-Diffusion Kind! by Daniel Temkin

Error-diffusion dithering is perhaps the fundamental algorithm of computer graphics. When an image is displayed in a reduced palette (such as black and white), a cloud of pixels return some detail to an image that otherwise would look washed out. Developed in the 1970s and 80s, they have been mostly stagnant since then.

This talk will revisit these algorithms and see what happens when we mess with these coeffients, leading to images where the dithers become inextricable from the content of the images! From there, weâ€™ll imagine how dithering might work in an alternate computer history, where our screens looked very different from the ones we use today.

Daniel Temkin is an artist and writer who is skeptical that human beings can understand logic or really write working code at all! They created the FatFinger dialect of JavaScript, which allows you to run typo-ridden JS, and the Entropy language, where all data decays the longer your program runs. They also design dither patterns for an alternate computer history where our screens are hexagonal, triangular, or other shapes.
Captions: 
	00:00:13,040 --> 00:00:15,280
hi

00:00:13,440 --> 00:00:17,359
i'm daniel tumpkin i'm an artist and

00:00:15,280 --> 00:00:19,680
programmer perhaps best known for my

00:00:17,359 --> 00:00:21,039
blog esoteric codes about slangs and

00:00:19,680 --> 00:00:22,160
code art

00:00:21,039 --> 00:00:23,680
but today i'm going to talk about

00:00:22,160 --> 00:00:25,359
another passion of mine which is

00:00:23,680 --> 00:00:27,760
dithering

00:00:25,359 --> 00:00:29,679
back in the 1970s they wanted to work

00:00:27,760 --> 00:00:30,000
out how to represent an image that has

00:00:29,679 --> 00:00:32,640
many

00:00:30,000 --> 00:00:33,920
colors using a small palette such as

00:00:32,640 --> 00:00:36,480
black and white

00:00:33,920 --> 00:00:37,220
for the pixels available on monitors of

00:00:36,480 --> 00:00:38,800
that era

00:00:37,220 --> 00:00:40,320
[Music]

00:00:38,800 --> 00:00:42,239
now one approach would be simply to

00:00:40,320 --> 00:00:43,760
round each pixel to the nearest in

00:00:42,239 --> 00:00:45,360
palette color

00:00:43,760 --> 00:00:47,120
so the darker pixels would round to

00:00:45,360 --> 00:00:49,120
black in this example and the brighter

00:00:47,120 --> 00:00:50,559
ones would would round to white

00:00:49,120 --> 00:00:52,399
but you can see how we lose a lot of

00:00:50,559 --> 00:00:54,320
detail that way

00:00:52,399 --> 00:00:56,800
dithering was developed to help you

00:00:54,320 --> 00:00:58,079
regain some of that detail

00:00:56,800 --> 00:00:59,760
the flavor of dithering i'm going to

00:00:58,079 --> 00:01:01,199
talk about today is error diffusion

00:00:59,760 --> 00:01:03,120
dithering

00:01:01,199 --> 00:01:04,799
for the first pixel it works exactly the

00:01:03,120 --> 00:01:07,200
same way you round

00:01:04,799 --> 00:01:08,080
towards black or white but the amount

00:01:07,200 --> 00:01:10,240
that you round

00:01:08,080 --> 00:01:11,119
like let's say we start with a pixel

00:01:10,240 --> 00:01:13,200
that's 60

00:01:11,119 --> 00:01:14,560
black if we round it the rest of the way

00:01:13,200 --> 00:01:17,119
to be a fully black

00:01:14,560 --> 00:01:18,640
pixel then we've introduced uh an error

00:01:17,119 --> 00:01:20,799
of 40

00:01:18,640 --> 00:01:22,080
we take that 40 percent and we divide it

00:01:20,799 --> 00:01:24,479
among the pixels

00:01:22,080 --> 00:01:26,560
neighboring that one um and round them a

00:01:24,479 --> 00:01:28,960
little bit in the other direction

00:01:26,560 --> 00:01:30,640
then we evaluate the next pixel and that

00:01:28,960 --> 00:01:32,240
one's already been shifted a little bit

00:01:30,640 --> 00:01:33,759
and now its error gets distributed to

00:01:32,240 --> 00:01:35,439
the pixels around it

00:01:33,759 --> 00:01:38,560
and that way the error gets distributed

00:01:35,439 --> 00:01:38,560
all around the image

00:01:38,640 --> 00:01:42,799
now dithering doesn't have to be just a

00:01:40,400 --> 00:01:43,119
black and white it can be to 16 colors

00:01:42,799 --> 00:01:46,079
or

00:01:43,119 --> 00:01:47,280
256 colors or actually to any arbitrary

00:01:46,079 --> 00:01:49,200
palette

00:01:47,280 --> 00:01:51,360
and it's still widely used it's just not

00:01:49,200 --> 00:01:52,000
as obvious with monitors that have tiny

00:01:51,360 --> 00:01:55,040
pixels

00:01:52,000 --> 00:01:56,719
and huge palettes of color

00:01:55,040 --> 00:01:58,399
now there are many different uh

00:01:56,719 --> 00:02:00,320
different kernels that we can use

00:01:58,399 --> 00:02:02,560
the kernels are the coefficient sets for

00:02:00,320 --> 00:02:04,240
that error distribution

00:02:02,560 --> 00:02:05,600
the most commonly used one is called

00:02:04,240 --> 00:02:07,520
floyd steinberg

00:02:05,600 --> 00:02:09,119
and that's the one that photoshop uses

00:02:07,520 --> 00:02:10,640
although they have their own proprietary

00:02:09,119 --> 00:02:12,400
version of it

00:02:10,640 --> 00:02:14,239
there's another one called atkinson

00:02:12,400 --> 00:02:17,440
which was invented by bill atkinson

00:02:14,239 --> 00:02:17,840
of hypercard fame and atkinson is very

00:02:17,440 --> 00:02:20,000
good

00:02:17,840 --> 00:02:21,760
for keeping contrast in the mid-tones

00:02:20,000 --> 00:02:22,879
but loses some detail in the darkest and

00:02:21,760 --> 00:02:24,560
lightest areas

00:02:22,879 --> 00:02:26,720
because not all of the errors carried

00:02:24,560 --> 00:02:27,920
over

00:02:26,720 --> 00:02:30,959
these kernels have not changed in

00:02:27,920 --> 00:02:32,080
decades so i recently spent a week at

00:02:30,959 --> 00:02:34,640
the recurs center

00:02:32,080 --> 00:02:36,239
virtually and wrote a scoring algorithm

00:02:34,640 --> 00:02:39,360
to see which of the dithering patterns

00:02:36,239 --> 00:02:41,120
match best with the original image and i

00:02:39,360 --> 00:02:42,720
do this by blurring both the dithered

00:02:41,120 --> 00:02:44,640
and undeterred image and then compare

00:02:42,720 --> 00:02:46,480
them using structural similarity index

00:02:44,640 --> 00:02:48,879
measure

00:02:46,480 --> 00:02:50,480
to make sure i'm not introducing bias i

00:02:48,879 --> 00:02:52,239
used one of the freely available data

00:02:50,480 --> 00:02:53,280
sets of faces from creative commons

00:02:52,239 --> 00:02:55,040
flickr images

00:02:53,280 --> 00:02:57,599
which i actually pared down myself with

00:02:55,040 --> 00:03:00,000
an emphasis on diversity

00:02:57,599 --> 00:03:02,000
i also included some line art which is

00:03:00,000 --> 00:03:05,040
difficult to dither well and trips up

00:03:02,000 --> 00:03:07,120
some of these dither kernels

00:03:05,040 --> 00:03:08,400
i used a simple machine learning process

00:03:07,120 --> 00:03:10,319
simulated annealing

00:03:08,400 --> 00:03:11,599
to generate new dithering kernels to

00:03:10,319 --> 00:03:13,920
test

00:03:11,599 --> 00:03:14,879
and i used both large and small versions

00:03:13,920 --> 00:03:16,640
of the images

00:03:14,879 --> 00:03:18,000
starting with all the small ones to

00:03:16,640 --> 00:03:21,680
quickly weed out the ones that

00:03:18,000 --> 00:03:21,680
aren't going to to work very well

00:03:22,480 --> 00:03:26,239
it turns out out of the random generated

00:03:24,480 --> 00:03:28,239
ones that that i created

00:03:26,239 --> 00:03:29,760
um the most interesting were not the

00:03:28,239 --> 00:03:31,120
ones that were high testing

00:03:29,760 --> 00:03:32,879
because they end up being very similar

00:03:31,120 --> 00:03:34,959
to what we already have but are usually

00:03:32,879 --> 00:03:36,319
just more complicated

00:03:34,959 --> 00:03:38,000
actually it was the medium to load

00:03:36,319 --> 00:03:39,519
testing ones where the pattern of the

00:03:38,000 --> 00:03:40,720
dither interferes with the contents of

00:03:39,519 --> 00:03:42,080
the image where things got more

00:03:40,720 --> 00:03:44,080
interesting

00:03:42,080 --> 00:03:45,360
and here i have a series of images of

00:03:44,080 --> 00:03:46,640
the david

00:03:45,360 --> 00:03:48,720
which i picked because it's so

00:03:46,640 --> 00:03:49,440
recognizable and you can see in these

00:03:48,720 --> 00:03:51,519
examples

00:03:49,440 --> 00:03:54,560
the noise and signal begin to merge the

00:03:51,519 --> 00:03:56,720
data encroaching into the subject matter

00:03:54,560 --> 00:03:58,159
in addition to that there are certain

00:03:56,720 --> 00:03:59,360
types of visual artifacts that are

00:03:58,159 --> 00:04:02,640
particularly distracting

00:03:59,360 --> 00:04:04,799
such as vertical stripes

00:04:02,640 --> 00:04:07,120
here is an extreme case of this where we

00:04:04,799 --> 00:04:09,760
have a kernel that has only one row

00:04:07,120 --> 00:04:10,480
so no error is carried from one row to

00:04:09,760 --> 00:04:12,480
the next

00:04:10,480 --> 00:04:14,000
in each one it's as if it begins at the

00:04:12,480 --> 00:04:16,239
beginning again which almost

00:04:14,000 --> 00:04:17,519
always causes these vertical stripe

00:04:16,239 --> 00:04:19,199
artifacts

00:04:17,519 --> 00:04:20,959
but even without the artifacts you can

00:04:19,199 --> 00:04:24,960
just have noise i have a whole

00:04:20,959 --> 00:04:24,960
collection here of snowy david pictures

00:04:25,360 --> 00:04:29,120
dithers that drop some of that error

00:04:27,360 --> 00:04:30,720
where not all of it is is carried over

00:04:29,120 --> 00:04:33,199
to surrounding pixels

00:04:30,720 --> 00:04:37,199
those lead to the high contrast images

00:04:33,199 --> 00:04:37,199
like my collection here of goth david's

00:04:37,759 --> 00:04:41,440
so now that i had a test that that um

00:04:39,759 --> 00:04:42,800
scored kernels i decided to bring it in

00:04:41,440 --> 00:04:44,479
a different direction

00:04:42,800 --> 00:04:46,720
and i considered alternate computer

00:04:44,479 --> 00:04:49,280
histories what if our screens

00:04:46,720 --> 00:04:50,400
had not been rectangular and and did not

00:04:49,280 --> 00:04:52,720
have square

00:04:50,400 --> 00:04:53,600
configurations of pixels what if we had

00:04:52,720 --> 00:04:56,080
triangular

00:04:53,600 --> 00:04:57,759
or hexagonal pixel configurations or

00:04:56,080 --> 00:04:59,040
other patterns

00:04:57,759 --> 00:05:01,039
and i decided to focus on the

00:04:59,040 --> 00:05:03,280
equilateral triangle and

00:05:01,039 --> 00:05:04,160
to fake this out by creating triangular

00:05:03,280 --> 00:05:07,600
pixels that are

00:05:04,160 --> 00:05:10,639
10 square pixels high then for each of

00:05:07,600 --> 00:05:12,639
those pixels i get the average color

00:05:10,639 --> 00:05:13,919
and from that i dither it the same way i

00:05:12,639 --> 00:05:18,560
dithered the original

00:05:13,919 --> 00:05:18,560
square images and do the same comparison

00:05:19,840 --> 00:05:23,440
so equilateral triangles are similar to

00:05:22,000 --> 00:05:25,360
squares in that

00:05:23,440 --> 00:05:26,880
each pixel has a neighbor in each of the

00:05:25,360 --> 00:05:28,560
cardinal directions they have an up

00:05:26,880 --> 00:05:30,240
neighbor down right and left

00:05:28,560 --> 00:05:32,000
so we'd expect that the same kernels

00:05:30,240 --> 00:05:34,960
would test well

00:05:32,000 --> 00:05:36,000
and it turns out that they do here's an

00:05:34,960 --> 00:05:37,600
image from the flickr

00:05:36,000 --> 00:05:39,280
data set and it's triangular pixel

00:05:37,600 --> 00:05:41,680
version and here

00:05:39,280 --> 00:05:44,160
is an image of me sanding that i used

00:05:41,680 --> 00:05:45,840
also for some of my tests

00:05:44,160 --> 00:05:49,039
pixelated it looks like this here's a

00:05:45,840 --> 00:05:51,120
smaller pixelated version

00:05:49,039 --> 00:05:52,160
and um it turns out that the originals

00:05:51,120 --> 00:05:54,639
like floyd steinberg

00:05:52,160 --> 00:05:55,520
do pretty well but they have some

00:05:54,639 --> 00:05:57,520
problems

00:05:55,520 --> 00:05:59,039
because the checkerboard pattern which

00:05:57,520 --> 00:06:01,440
is very very common

00:05:59,039 --> 00:06:02,479
uh in the original dither patterns when

00:06:01,440 --> 00:06:04,800
you hit the 50

00:06:02,479 --> 00:06:06,160
mark this was actually something that

00:06:04,800 --> 00:06:08,240
floyd and steinberg

00:06:06,160 --> 00:06:10,479
and the other developers of these dinner

00:06:08,240 --> 00:06:13,440
kernels wanted that at 50

00:06:10,479 --> 00:06:15,520
you would have um a perfect checkerboard

00:06:13,440 --> 00:06:17,520
the variation is atkinson where we also

00:06:15,520 --> 00:06:20,400
have a checkerboard but it's it's larger

00:06:17,520 --> 00:06:20,800
it's uh two by two pixels for each one

00:06:20,400 --> 00:06:23,039
um

00:06:20,800 --> 00:06:24,960
this works pretty well with square

00:06:23,039 --> 00:06:26,560
pixels but with triangles it creates

00:06:24,960 --> 00:06:28,240
sort of a flat looking area

00:06:26,560 --> 00:06:30,400
which is kind of distracting the same

00:06:28,240 --> 00:06:31,199
way that the the vertical stripes were

00:06:30,400 --> 00:06:35,360
distracting

00:06:31,199 --> 00:06:38,400
in in the square pixels

00:06:35,360 --> 00:06:41,600
so it turns out that my test um

00:06:38,400 --> 00:06:44,080
actually uh picked up on this and

00:06:41,600 --> 00:06:45,600
some of my randomly generated kernels

00:06:44,080 --> 00:06:47,759
actually tested better than

00:06:45,600 --> 00:06:50,639
than floyd steinberg did in the

00:06:47,759 --> 00:06:50,639
triangular space

00:06:51,120 --> 00:06:55,840
so i am actually still testing triangles

00:06:53,759 --> 00:06:58,400
but i'm also underway creating the next

00:06:55,840 --> 00:07:00,400
shape hexagons

00:06:58,400 --> 00:07:01,680
but it turns out for hexagons there

00:07:00,400 --> 00:07:02,080
actually is a place that we're already

00:07:01,680 --> 00:07:03,840
doing

00:07:02,080 --> 00:07:06,479
hexagonal dithering and that's in the

00:07:03,840 --> 00:07:09,440
printer um because the printer layout of

00:07:06,479 --> 00:07:11,599
of um of printer dots is actually a

00:07:09,440 --> 00:07:14,880
hexagonal pattern and there actually are

00:07:11,599 --> 00:07:16,560
dithering kernels for that as well

00:07:14,880 --> 00:07:18,160
so i'm doing this as part of a 10-year

00:07:16,560 --> 00:07:20,240
project called dither studies

00:07:18,160 --> 00:07:21,759
where i dither not photographic images

00:07:20,240 --> 00:07:24,000
but solid colors

00:07:21,759 --> 00:07:25,120
and i dither them to palettes of

00:07:24,000 --> 00:07:26,960
complementary colors

00:07:25,120 --> 00:07:29,120
opposite colors to make the dithering

00:07:26,960 --> 00:07:31,840
artifacts as obvious as possible as

00:07:29,120 --> 00:07:33,440
visible as possible

00:07:31,840 --> 00:07:35,120
and this is something i've done through

00:07:33,440 --> 00:07:37,599
uh i have a web app

00:07:35,120 --> 00:07:39,440
um i have videos and room size

00:07:37,599 --> 00:07:41,680
installations of those videos

00:07:39,440 --> 00:07:43,120
um and more recently over the last few

00:07:41,680 --> 00:07:44,800
years i've created this series of

00:07:43,120 --> 00:07:46,560
paintings

00:07:44,800 --> 00:07:47,840
but before i start actually painting

00:07:46,560 --> 00:07:50,800
triangular dinners

00:07:47,840 --> 00:07:51,599
i want to find the the triangular dither

00:07:50,800 --> 00:07:55,199
algorithms

00:07:51,599 --> 00:07:56,840
that actually work so why study dithers

00:07:55,199 --> 00:07:59,039
what's so fascinating about about

00:07:56,840 --> 00:08:01,759
dithering

00:07:59,039 --> 00:08:03,440
for me the error diffusion dithering

00:08:01,759 --> 00:08:05,039
it's a very simple algorithm

00:08:03,440 --> 00:08:07,280
it uses nothing more than grade school

00:08:05,039 --> 00:08:08,400
math and yet the patterns when applied

00:08:07,280 --> 00:08:11,199
to solid colors

00:08:08,400 --> 00:08:12,000
feel very irrational to me it's

00:08:11,199 --> 00:08:14,639
reminiscent

00:08:12,000 --> 00:08:17,039
of early computer art art by people like

00:08:14,639 --> 00:08:19,199
vera molnar and hiroshi kiwano

00:08:17,039 --> 00:08:20,800
um but really illustrate how little

00:08:19,199 --> 00:08:23,919
complexity it takes

00:08:20,800 --> 00:08:26,000
before logic feels irrational to us

00:08:23,919 --> 00:08:27,440
it's a great illustration of that gulf

00:08:26,000 --> 00:08:29,759
between human intent

00:08:27,440 --> 00:08:31,919
and logic that occurs every time that we

00:08:29,759 --> 00:08:38,719
sit to write code

00:08:31,919 --> 00:08:38,719

YouTube URL: https://www.youtube.com/watch?v=zaox9mSQ0A8


