Title: !!Con 2020 - Bringing back my 1998 by building an arduino that can recover a ... by Martin Gaston
Publication date: 2020-05-28
Playlist: !!Con 2020
Description: 
	bringing back my 1998 by building an arduino that can recover a playstation memory card! by Martin Gaston

In 1998, armed with the original PlayStation and my childhood, I saved Midgard from Sephiroth, averted nuclear armageddon by sneaking through Shadow Moses and escaped a zombie infested Racoon City.

These iconic games have been re-released and remastered in various forms, but my digital memories of them now only exist on a single PlayStation Memory Card: 128kb of EEPROM storage I recently found hidden in a shoebox during a move. Awash with nostalgia by just holding the rectangular card in my hands, I realised I just had to find a way to break into this trove.

Join me as I learn how to setup an Arduino to access this data, tear down an original PlayStation console, read those precious bytes from my memory card and then convert them into a format to relive my 1998 memories on a modern PlayStation emulator in 2020.

The talk is specifically aimed at beginners with an interest in hardware and low-level file manipulation, and looks to introduce obtaining, reading and parsing a binary file in an introductory and accessible way. Python is used for some file manipulation, so a little knowledge of dynamic languages and an interest in 90s gaming would likely be beneficial.

Following careers in games media and marketing, Martin really got into programming in 2018 after previously assuming tech was inaccessible for people without a computer science degree. He was forged in the friendly fires of Founders and Coders - a tuition-free, peer-led UK bootcamp - and now talks about the 90s way too much with the rest of the team at 8th Light.
Captions: 
	00:00:13,730 --> 00:00:20,610
hi thanks that introduction like said

00:00:18,720 --> 00:00:22,980
I'm here today to talk about building an

00:00:20,610 --> 00:00:30,000
Arduino that can cover a Playstation

00:00:22,980 --> 00:00:33,720
memory card and this little flailing

00:00:30,000 --> 00:00:36,989
nugget on the right is my son who will

00:00:33,720 --> 00:00:40,430
be three weeks old this weekend and he

00:00:36,989 --> 00:00:43,920
is now why I am so tired all of the time

00:00:40,430 --> 00:00:45,420
and maybe it's part about you know being

00:00:43,920 --> 00:00:47,480
a new parent but I've been thinking

00:00:45,420 --> 00:00:51,750
about the past a lot lately

00:00:47,480 --> 00:00:53,550
specifically 1998 where few experiences

00:00:51,750 --> 00:00:56,040
meant more to me at the time than when I

00:00:53,550 --> 00:00:59,370
saved the planet from Sephiroth in final

00:00:56,040 --> 00:01:01,320
fantasy 7 an epic RPG for the original

00:00:59,370 --> 00:01:04,439
PlayStation console and probably one of

00:01:01,320 --> 00:01:06,360
my favorite games of all time and I

00:01:04,439 --> 00:01:08,549
recently found this my original

00:01:06,360 --> 00:01:11,040
PlayStation memory card hidden in a

00:01:08,549 --> 00:01:12,869
shoebox during a move this little

00:01:11,040 --> 00:01:16,170
rectangle of flash storage holds my

00:01:12,869 --> 00:01:18,570
final fantasy 7 save and 22 years ago it

00:01:16,170 --> 00:01:22,800
was probably the most precious thing I

00:01:18,570 --> 00:01:25,440
had ever owned and so I figured hey as a

00:01:22,800 --> 00:01:27,030
new father and as a lover of cats it

00:01:25,440 --> 00:01:29,460
would be nice to have at least one thing

00:01:27,030 --> 00:01:32,340
in my life that I feel I could tell what

00:01:29,460 --> 00:01:34,890
to do so I decided I wanted to extract

00:01:32,340 --> 00:01:37,770
my final fantasy 7 save to a computer so

00:01:34,890 --> 00:01:39,300
I could load it up in an emulator and to

00:01:37,770 --> 00:01:40,890
do this I'd use an Arduino as a

00:01:39,300 --> 00:01:43,080
middleman and if you're not familiar

00:01:40,890 --> 00:01:45,090
with the Arduino don't worry it's a very

00:01:43,080 --> 00:01:48,299
handy board to jumpstart electronics

00:01:45,090 --> 00:01:50,810
projects and it has a USB serial port

00:01:48,299 --> 00:01:53,130
that we can use to send data to a PC and

00:01:50,810 --> 00:01:55,290
but first I needed to start with the

00:01:53,130 --> 00:01:57,659
memory card itself what was its former

00:01:55,290 --> 00:01:59,280
how was it put together and so standing

00:01:57,659 --> 00:02:01,260
on the shoulder of giants I looked at

00:01:59,280 --> 00:02:02,520
some reverse engineering documentation

00:02:01,260 --> 00:02:05,190
and realized that I was going to have to

00:02:02,520 --> 00:02:07,229
learn binary and my knowledge of binary

00:02:05,190 --> 00:02:08,729
at the start of this project was

00:02:07,229 --> 00:02:11,069
something that was basically a 0 or 1

00:02:08,729 --> 00:02:12,689
and that's true and we call it a bit and

00:02:11,069 --> 00:02:16,200
it's pretty much the core building block

00:02:12,689 --> 00:02:18,840
of computing and we also count our bits

00:02:16,200 --> 00:02:21,420
in binary so with regular numbers

00:02:18,840 --> 00:02:23,490
decimal numbers we count from 0 to 9

00:02:21,420 --> 00:02:25,200
and when we run out of digits we add one

00:02:23,490 --> 00:02:26,160
to a column on the left and we go back

00:02:25,200 --> 00:02:29,100
to zero and start

00:02:26,160 --> 00:02:32,640
all over again and we get $2.99 we start

00:02:29,100 --> 00:02:34,470
a new column and go to 100 and each new

00:02:32,640 --> 00:02:37,200
column is raised to a power of 10 and

00:02:34,470 --> 00:02:39,690
the exact same rules of counting applied

00:02:37,200 --> 00:02:41,250
to binary and also the hexadecimal but

00:02:39,690 --> 00:02:43,260
the crucial difference is we raise our

00:02:41,250 --> 00:02:44,130
columns to a power of 2 and 16

00:02:43,260 --> 00:02:47,130
respectively

00:02:44,130 --> 00:02:50,250
and another neat thing about hex is that

00:02:47,130 --> 00:02:52,020
a two digit hex number is 4 bits meaning

00:02:50,250 --> 00:02:55,200
we can represent a whole byte we're just

00:02:52,020 --> 00:02:58,230
two numbers and because if we smush

00:02:55,200 --> 00:03:00,120
eight bits together we get a byte which

00:02:58,230 --> 00:03:02,010
is a really integral unit of digital

00:03:00,120 --> 00:03:05,820
information and it gives us a total

00:03:02,010 --> 00:03:09,330
representation of 256 values in binary

00:03:05,820 --> 00:03:11,880
and we can actually assign additional

00:03:09,330 --> 00:03:13,800
meaning to those numbers so for instance

00:03:11,880 --> 00:03:15,660
there's ASCII which is a standard for

00:03:13,800 --> 00:03:18,120
encoding text and symbols with numbers

00:03:15,660 --> 00:03:22,650
so in ASCII the decimal number 67

00:03:18,120 --> 00:03:24,780
represents a capital C and manipulating

00:03:22,650 --> 00:03:27,720
these bits and bytes so add our own

00:03:24,780 --> 00:03:30,030
meaning is really how we build up all of

00:03:27,720 --> 00:03:32,310
the digital media we interact with from

00:03:30,030 --> 00:03:34,440
reading a PDF to streaming never have I

00:03:32,310 --> 00:03:37,260
ever or Netflix or busting out clouds

00:03:34,440 --> 00:03:38,390
awesome only slash limit break in Final

00:03:37,260 --> 00:03:40,530
Fantasy 7

00:03:38,390 --> 00:03:42,120
and so PlayStation developers could

00:03:40,530 --> 00:03:43,980
store their ones and zeroes but they

00:03:42,120 --> 00:03:47,490
were limited by the constraint of frames

00:03:43,980 --> 00:03:49,280
and blocks and basically size so a frame

00:03:47,490 --> 00:03:51,959
is a hundred and twenty eight bytes and

00:03:49,280 --> 00:03:54,209
this is actually the very first frame on

00:03:51,959 --> 00:03:56,040
any PlayStation memory card represented

00:03:54,209 --> 00:03:59,790
in hex and it base it was nothing but

00:03:56,040 --> 00:04:02,270
spell out MC and now if you take 64 of

00:03:59,790 --> 00:04:05,370
these frames you get a block of 8,000

00:04:02,270 --> 00:04:06,810
192 bytes this is a representation of

00:04:05,370 --> 00:04:08,910
frames on a standard one block

00:04:06,810 --> 00:04:11,010
PlayStation memory card Save you get one

00:04:08,910 --> 00:04:13,200
frame for title information 3/4 a nice

00:04:11,010 --> 00:04:15,560
little icon and the remaining 60 can be

00:04:13,200 --> 00:04:18,840
used by the game to store save data and

00:04:15,560 --> 00:04:21,270
the memory card holds 16 blocks it gives

00:04:18,840 --> 00:04:23,820
15 to the user and it keeps one for

00:04:21,270 --> 00:04:26,820
itself as a directory listing and so 16

00:04:23,820 --> 00:04:28,560
blocks gives us 1,024 frames then the

00:04:26,820 --> 00:04:30,240
nice thing about this project is that we

00:04:28,560 --> 00:04:31,890
don't have to worry about how the frames

00:04:30,240 --> 00:04:33,600
are actually really laid out we just

00:04:31,890 --> 00:04:36,690
need to know they exist we need to move

00:04:33,600 --> 00:04:38,070
all of them from one location to the

00:04:36,690 --> 00:04:39,480
other

00:04:38,070 --> 00:04:41,730
and with that I felt like I understood

00:04:39,480 --> 00:04:43,410
the shape of the memory card and so the

00:04:41,730 --> 00:04:47,340
next step was to use the Arduino to

00:04:43,410 --> 00:04:49,590
communicate directly with it and the

00:04:47,340 --> 00:04:51,090
idea was to fool the memory card into

00:04:49,590 --> 00:04:53,430
thinking the Arduino is just a regular

00:04:51,090 --> 00:04:56,070
old PlayStation the key here is these

00:04:53,430 --> 00:04:57,780
magical little digital pins that run up

00:04:56,070 --> 00:05:00,030
both sides of the board and their

00:04:57,780 --> 00:05:01,260
ability to create an electrical circuit

00:05:00,030 --> 00:05:03,840
with the memory card

00:05:01,260 --> 00:05:05,850
luckily the PlayStation memory card

00:05:03,840 --> 00:05:08,820
mostly conforms to a very established

00:05:05,850 --> 00:05:10,560
protocol for doing this called SPI which

00:05:08,820 --> 00:05:13,620
is common enough to have its own Arduino

00:05:10,560 --> 00:05:15,120
library and as a web developer I know a

00:05:13,620 --> 00:05:17,160
thing or two about using external

00:05:15,120 --> 00:05:20,640
dependencies so I felt very comfortable

00:05:17,160 --> 00:05:23,010
here and these actually correspond to

00:05:20,640 --> 00:05:25,020
the pins on the memory cut itself if we

00:05:23,010 --> 00:05:27,090
connect these pins to the Arduino pins

00:05:25,020 --> 00:05:30,270
we can create a circuit and start

00:05:27,090 --> 00:05:31,290
communicating and the PlayStation memory

00:05:30,270 --> 00:05:33,750
card can send the information

00:05:31,290 --> 00:05:36,270
electronically down its data wire by

00:05:33,750 --> 00:05:37,950
turning his voltage on or off when we

00:05:36,270 --> 00:05:40,050
send voltage through the connection we

00:05:37,950 --> 00:05:42,720
say it's high and we interpret that as

00:05:40,050 --> 00:05:45,150
a1 and conversely when we don't it's a

00:05:42,720 --> 00:05:46,830
lot and we read that as a zero and this

00:05:45,150 --> 00:05:49,020
is another reason why binary is so

00:05:46,830 --> 00:05:51,300
important we reduce all of that

00:05:49,020 --> 00:05:53,760
information back down to its most basic

00:05:51,300 --> 00:05:55,890
part we send it as a million ones and

00:05:53,760 --> 00:05:57,540
zeros piece by piece through an

00:05:55,890 --> 00:05:59,670
electrical signal and then we can

00:05:57,540 --> 00:06:01,560
rebuild it on the other end and we can

00:05:59,670 --> 00:06:03,180
also use another wire to create a clock

00:06:01,560 --> 00:06:05,880
signal between the Arduino and the

00:06:03,180 --> 00:06:07,500
memory card which aligns the devices so

00:06:05,880 --> 00:06:09,630
that they can only read the values when

00:06:07,500 --> 00:06:12,360
they're when that clock is high this

00:06:09,630 --> 00:06:16,080
helps our communication and our data

00:06:12,360 --> 00:06:17,730
stay reliable and what you can do is you

00:06:16,080 --> 00:06:20,070
can actually solder some wires directly

00:06:17,730 --> 00:06:22,650
to the memory card pins and then plug

00:06:20,070 --> 00:06:24,930
that into the Arduino ports now I have

00:06:22,650 --> 00:06:27,390
never sold it in my life and it's hard

00:06:24,930 --> 00:06:28,950
and it feels super dangerous and fun

00:06:27,390 --> 00:06:30,450
fact this card here is actually my

00:06:28,950 --> 00:06:32,460
brother's because I didn't want to risk

00:06:30,450 --> 00:06:35,040
my own card first and I have not taught

00:06:32,460 --> 00:06:36,600
him I've done this and if you're looking

00:06:35,040 --> 00:06:38,280
for a less permanent solution you can do

00:06:36,600 --> 00:06:40,140
this you can yank out the whole memory

00:06:38,280 --> 00:06:42,300
card reader from an old broken

00:06:40,140 --> 00:06:44,070
PlayStation and solder wires directly to

00:06:42,300 --> 00:06:45,570
that and when you do either of those

00:06:44,070 --> 00:06:48,480
things you will to make this connection

00:06:45,570 --> 00:06:50,130
and then the PlayStation memory card is

00:06:48,480 --> 00:06:51,940
now set to let you read data on a

00:06:50,130 --> 00:06:53,800
frame-by-frame basis and

00:06:51,940 --> 00:06:55,930
to do that you basically need to follow

00:06:53,800 --> 00:06:58,150
the PlayBook on the left in that exact

00:06:55,930 --> 00:07:00,310
order they Arduino they're slightly

00:06:58,150 --> 00:07:02,530
Arduino issues the send commands in

00:07:00,310 --> 00:07:05,980
green and receives the data in orange

00:07:02,530 --> 00:07:07,750
SBI always sends and receives a byte so

00:07:05,980 --> 00:07:10,270
a lot of our outgoing commands are just

00:07:07,750 --> 00:07:11,980
empty bytes set to zero and to initiate

00:07:10,270 --> 00:07:15,190
the communication we have to program the

00:07:11,980 --> 00:07:16,810
Arduino which uses C++ don't worry if

00:07:15,190 --> 00:07:18,160
you don't know any of that I only knew

00:07:16,810 --> 00:07:20,440
enough to hack together this refrain

00:07:18,160 --> 00:07:22,290
function which takes an argument after

00:07:20,440 --> 00:07:24,340
the address of which frame to read and

00:07:22,290 --> 00:07:26,530
but our address that we send in as a

00:07:24,340 --> 00:07:29,260
16-bit number so we have to break into

00:07:26,530 --> 00:07:31,450
two 8-bit bytes because there are 1,024

00:07:29,260 --> 00:07:33,910
frames in total we can't hold a number

00:07:31,450 --> 00:07:35,260
that big in a single byte so we have to

00:07:33,910 --> 00:07:38,110
send it to the memory card as two

00:07:35,260 --> 00:07:39,460
separate bytes and then we can tell our

00:07:38,110 --> 00:07:41,230
attention where another one of our wires

00:07:39,460 --> 00:07:43,210
to go low which is kind of the

00:07:41,230 --> 00:07:44,890
bat-signal to the memory card that are

00:07:43,210 --> 00:07:47,110
about to be sending some commands and

00:07:44,890 --> 00:07:50,530
then we can begin that SPI transaction

00:07:47,110 --> 00:07:52,750
thanks again SPI library and I've

00:07:50,530 --> 00:07:54,520
extracted a command function here which

00:07:52,750 --> 00:07:56,470
handles the sending and receiving of the

00:07:54,520 --> 00:07:59,560
bytes we're not using any of the return

00:07:56,470 --> 00:08:00,940
bytes for the first 10 commands but we

00:07:59,560 --> 00:08:04,150
still need to go through those motions

00:08:00,940 --> 00:08:05,919
and now we get to the meaty bit and at

00:08:04,150 --> 00:08:08,020
this stage the memory card goes bite by

00:08:05,919 --> 00:08:10,000
bite through the requested frame and the

00:08:08,020 --> 00:08:12,550
Arduino outputs its information through

00:08:10,000 --> 00:08:14,230
its USB serial connection and we also

00:08:12,550 --> 00:08:17,140
send across the results of the checksum

00:08:14,230 --> 00:08:18,430
from the confirmation bike and we finish

00:08:17,140 --> 00:08:20,380
this off by wrapping up the SPI

00:08:18,430 --> 00:08:22,150
transaction we set the attention wire

00:08:20,380 --> 00:08:25,240
back to high so we can signal that we

00:08:22,150 --> 00:08:27,400
have no more commands for now and now we

00:08:25,240 --> 00:08:29,200
can finally switch over to the PC to

00:08:27,400 --> 00:08:31,180
make some sense of all of this I'm using

00:08:29,200 --> 00:08:33,010
Python here but any scripting language

00:08:31,180 --> 00:08:36,070
that can write binary files or access

00:08:33,010 --> 00:08:38,229
serial ports will be fine so we're on

00:08:36,070 --> 00:08:40,240
the PC and we're reading what they are

00:08:38,229 --> 00:08:42,219
dueño writes over that USB serial

00:08:40,240 --> 00:08:44,500
connection by wrapping another library

00:08:42,219 --> 00:08:46,570
place serial into a memory card class

00:08:44,500 --> 00:08:49,270
creating a read frame method and

00:08:46,570 --> 00:08:51,520
assigning that data checksum and status

00:08:49,270 --> 00:08:53,770
bytes we transmitted from the arduino to

00:08:51,520 --> 00:08:55,510
variables in our python script we

00:08:53,770 --> 00:08:58,900
validate that the status is correct and

00:08:55,510 --> 00:09:00,970
then we return the data over in our main

00:08:58,900 --> 00:09:03,940
block we read the command-line arguments

00:09:00,970 --> 00:09:05,320
and we instantiate the class and we know

00:09:03,940 --> 00:09:07,660
how many frames there are

00:09:05,320 --> 00:09:09,520
so we can just open a binary file create

00:09:07,660 --> 00:09:11,230
a loop and run the read frame method

00:09:09,520 --> 00:09:14,260
until we've transferred all of the

00:09:11,230 --> 00:09:16,030
frames into it I know all of that work

00:09:14,260 --> 00:09:17,590
and you've come to this awesome tech

00:09:16,030 --> 00:09:19,420
conference and basically my grand

00:09:17,590 --> 00:09:22,720
conclusion is the bog-standard loop I'm

00:09:19,420 --> 00:09:25,330
sorry about that and the real question

00:09:22,720 --> 00:09:28,150
of course is did it actually work and

00:09:25,330 --> 00:09:31,300
this would be a super depressing talk if

00:09:28,150 --> 00:09:34,890
it didn't I suppose so I'm gonna try a

00:09:31,300 --> 00:09:37,360
little bit of screen sharing right now

00:09:34,890 --> 00:09:38,950
hopefully that's that's working that's

00:09:37,360 --> 00:09:40,480
life that is a emulator that is a

00:09:38,950 --> 00:09:42,730
Playstation emulator running right now

00:09:40,480 --> 00:09:45,040
this is Final Fantasy 7 I can click

00:09:42,730 --> 00:09:48,070
continue I can choose my memory card

00:09:45,040 --> 00:09:50,350
slot it loads a bit these are my

00:09:48,070 --> 00:09:53,200
original memory cards showing up in a

00:09:50,350 --> 00:09:55,840
Playstation emulator we can choose one

00:09:53,200 --> 00:09:58,780
of them and it can load I'll take a

00:09:55,840 --> 00:10:00,820
little while it's an old console but

00:09:58,780 --> 00:10:04,210
just thinking about this makes me feel

00:10:00,820 --> 00:10:07,600
22 years younger and it's kind of

00:10:04,210 --> 00:10:09,670
amazing the memories and feelings I

00:10:07,600 --> 00:10:11,950
attach to these files I mean that is a

00:10:09,670 --> 00:10:14,380
Gorton trucker bow right there I have

00:10:11,950 --> 00:10:16,450
stories about my life around so many of

00:10:14,380 --> 00:10:19,000
these games and maybe you've got some

00:10:16,450 --> 00:10:20,350
weird old storage device lying around

00:10:19,000 --> 00:10:21,970
somewhere that might be worth a trip

00:10:20,350 --> 00:10:23,530
down memory lane I would love to hear

00:10:21,970 --> 00:10:24,970
him at that and also I'll just like

00:10:23,530 --> 00:10:26,650
quickly finished by shouting out to our

00:10:24,970 --> 00:10:28,210
wonderful conference organisers and to

00:10:26,650 --> 00:10:30,100
all the key workers who've kept us fed

00:10:28,210 --> 00:10:31,780
healthy and supply over the past couple

00:10:30,100 --> 00:10:34,920
of months all of those people are heroes

00:10:31,780 --> 00:10:34,920

YouTube URL: https://www.youtube.com/watch?v=94IWsCxkpVI


