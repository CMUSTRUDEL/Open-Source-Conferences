Title: !!Con 2020 - Programming from an alternate timeline! by Matthew Dockrey
Publication date: 2020-05-28
Playlist: !!Con 2020
Description: 
	Programming from an alternate timeline! by Matthew Dockrey

We take ANDs and ORs for granted, but for millennia there was only the IMPLIES of classical Aristotelian syllogisms. It wasn’t until the 19th century that mathematical logic started to emerge, and it was a long time before it looked anything like what we use today. In 1879, Gottlob Frege published a gloriously weird notation system using branching lines, concavities and judgments. Sadly, no one else ever adopted it – in our timeline. Notation developed along less interesting lines here. But I wanted to see what programming would have been like had Frege won out, so I turned his notation into a working language. Doing so taught me just how different it is to approach problems with implication as your only logical operator, and it left me with a much deeper appreciation of our humble ANDs and ORs.

Matthew Dockrey is a Seattle-area industrial artist with a particular interest in kinetic sculpture of all scales. The history of technology provides the inspiration for much of his work, as well as exploring the beauty of mechanical design. His work has been featured on the Discovery Channel, displayed at Greenwich Observatory in London, and was selected to adorn the 2015 Hugo Award. His large-scale kinetic sculptures can be found at Burning Man, and his public art can increasingly be found in cities around the Pacific Northwest.
Captions: 
	00:00:13,080 --> 00:00:16,840
hey everyone this is a talk about

00:00:15,550 --> 00:00:18,730
programming from an alternate timeline

00:00:16,840 --> 00:00:20,890
so first some background

00:00:18,730 --> 00:00:23,170
I'm Matt Dockery also known as fish in

00:00:20,890 --> 00:00:24,880
my day job I work on software that

00:00:23,170 --> 00:00:26,830
controls industrial measuring systems

00:00:24,880 --> 00:00:28,360
otherwise I'm a metal worker and a

00:00:26,830 --> 00:00:29,800
kinetic sculptor who's been doing a lot

00:00:28,360 --> 00:00:31,810
of public art installations over the

00:00:29,800 --> 00:00:33,700
last few years but computers were my

00:00:31,810 --> 00:00:36,280
first passion and I certainly still love

00:00:33,700 --> 00:00:38,110
making them do weird things so I've

00:00:36,280 --> 00:00:40,480
recently been reading a lot of primary

00:00:38,110 --> 00:00:42,010
documents in the history of math and one

00:00:40,480 --> 00:00:43,239
of the things this quickly teaches you

00:00:42,010 --> 00:00:45,220
is that we're very lucky to have

00:00:43,239 --> 00:00:47,710
notational systems as standardized as

00:00:45,220 --> 00:00:49,450
they are today as a programmer I was

00:00:47,710 --> 00:00:51,640
particularly interested in tracing the

00:00:49,450 --> 00:00:53,530
development of logical notation its

00:00:51,640 --> 00:00:56,080
boolean logic so maybe it goes all the

00:00:53,530 --> 00:00:58,330
way back to George Boole himself not

00:00:56,080 --> 00:01:00,550
really the notation in his works is

00:00:58,330 --> 00:01:02,260
explicitly algebraic he's really

00:01:00,550 --> 00:01:04,360
developing more of a concept of set

00:01:02,260 --> 00:01:06,820
theory and probability than mathematical

00:01:04,360 --> 00:01:08,850
logic he uses multiplication to mean

00:01:06,820 --> 00:01:12,130
both logical and and set intersection

00:01:08,850 --> 00:01:13,810
addition his set Union and so on one of

00:01:12,130 --> 00:01:16,810
the first things he derives from this is

00:01:13,810 --> 00:01:19,359
his fundamental law of thought if x and

00:01:16,810 --> 00:01:21,310
y are identical the next times y equals

00:01:19,359 --> 00:01:24,070
x which is the same thing as x squared

00:01:21,310 --> 00:01:26,409
equals x the only solutions to this are

00:01:24,070 --> 00:01:28,560
x equal 1 and x equals 0 which he

00:01:26,409 --> 00:01:30,729
interprets as everything and nothing I

00:01:28,560 --> 00:01:33,759
can't say I'm quite sure I agree with

00:01:30,729 --> 00:01:36,159
that proof but given how 0 equals false

00:01:33,759 --> 00:01:37,810
and 1 equals 2 dominates our lives today

00:01:36,159 --> 00:01:39,939
he does seem to have stumbled into

00:01:37,810 --> 00:01:41,409
something important it's keeping over

00:01:39,939 --> 00:01:43,569
the rest of the 19th century for a

00:01:41,409 --> 00:01:45,189
moment the next work which dominates the

00:01:43,569 --> 00:01:47,740
logical landscape is Russel and

00:01:45,189 --> 00:01:49,780
whiteheads principia mathematica this is

00:01:47,740 --> 00:01:51,880
an infamously complex and lengthy work

00:01:49,780 --> 00:01:53,920
more influential in concept than in

00:01:51,880 --> 00:01:56,200
practice but it's also important for

00:01:53,920 --> 00:01:58,359
helping solidify notation it rejects

00:01:56,200 --> 00:02:01,060
parentheses for grouping however instead

00:01:58,359 --> 00:02:03,219
using a tiered system of dots but a lot

00:02:01,060 --> 00:02:04,929
happened between those two including a

00:02:03,219 --> 00:02:08,619
glorious system that has almost entirely

00:02:04,929 --> 00:02:11,140
forgotten today in 1879 got lobbed Fraga

00:02:08,619 --> 00:02:13,390
published his big riff shift or concept

00:02:11,140 --> 00:02:15,430
writing this was one of the first stabs

00:02:13,390 --> 00:02:17,800
at trying to derive basic mathematical

00:02:15,430 --> 00:02:20,380
concepts from logic and in that sense it

00:02:17,800 --> 00:02:21,730
was immensely influential it was also an

00:02:20,380 --> 00:02:23,560
almost complete break from any

00:02:21,730 --> 00:02:26,530
notational system that came before or

00:02:23,560 --> 00:02:27,040
after it often described as a flow chart

00:02:26,530 --> 00:02:29,080
or

00:02:27,040 --> 00:02:30,939
two dimensional it really is worth

00:02:29,080 --> 00:02:34,299
studying even you have no interest in

00:02:30,939 --> 00:02:36,189
logis ism or mathematical philosophy he

00:02:34,299 --> 00:02:39,340
describes judgments which are either

00:02:36,189 --> 00:02:41,319
affirmed or denied if a statement is a

00:02:39,340 --> 00:02:43,209
judgement it is preceded by this thick

00:02:41,319 --> 00:02:45,370
vertical line which shows it to be

00:02:43,209 --> 00:02:47,860
something known to be affirmed without

00:02:45,370 --> 00:02:50,200
this stroke it is a mere combination of

00:02:47,860 --> 00:02:51,519
ideas to be considered everything

00:02:50,200 --> 00:02:53,280
connected to the horizontal line is

00:02:51,519 --> 00:02:55,659
included as part of this judgment

00:02:53,280 --> 00:02:57,790
expressions can be negated using this

00:02:55,659 --> 00:02:59,980
symbol the only part of his system that

00:02:57,790 --> 00:03:01,959
was adopted elsewhere he also has

00:02:59,980 --> 00:03:04,569
letters which represent a value or a

00:03:01,959 --> 00:03:06,879
judgement their basic variables except

00:03:04,569 --> 00:03:07,389
they're not variable okay now into the

00:03:06,879 --> 00:03:10,750
fun stuff

00:03:07,389 --> 00:03:12,790
this is conditionality to define it he

00:03:10,750 --> 00:03:14,560
sets out a truth table and says this

00:03:12,790 --> 00:03:16,239
symbol stands for the judgment of a

00:03:14,560 --> 00:03:18,250
third of these possibilities does not

00:03:16,239 --> 00:03:20,889
take place but one of the other three

00:03:18,250 --> 00:03:22,510
does while not otherwise naming it as

00:03:20,889 --> 00:03:24,609
such he's describing the logical

00:03:22,510 --> 00:03:27,310
operator of implication here while this

00:03:24,609 --> 00:03:28,810
is sometimes written as if B than a it's

00:03:27,310 --> 00:03:30,180
important to note that it is not the

00:03:28,810 --> 00:03:32,590
same thing as an if statement

00:03:30,180 --> 00:03:35,919
implication is only false if B is true

00:03:32,590 --> 00:03:37,930
but a is not if B is false the truth

00:03:35,919 --> 00:03:40,180
value of the operation is always true

00:03:37,930 --> 00:03:42,220
that is a false statement logically

00:03:40,180 --> 00:03:44,319
implies everything consider the

00:03:42,220 --> 00:03:46,930
statement if it is raining then I am wet

00:03:44,319 --> 00:03:48,819
it only deals with the situation word is

00:03:46,930 --> 00:03:50,919
raining in which case I must be wet for

00:03:48,819 --> 00:03:52,569
the statement to be true if it isn't

00:03:50,919 --> 00:03:54,730
raining however it has nothing to say

00:03:52,569 --> 00:03:56,620
maybe I'm dry and maybe someone just

00:03:54,730 --> 00:03:58,180
dumped a bucket over my head and either

00:03:56,620 --> 00:04:00,160
case the original statement is still

00:03:58,180 --> 00:04:02,079
true I find it best to think of

00:04:00,160 --> 00:04:04,870
implication in modern terms of not B or

00:04:02,079 --> 00:04:06,609
a to keep from getting confused like all

00:04:04,870 --> 00:04:08,859
early logicians this was his only

00:04:06,609 --> 00:04:10,989
logical operator beyond simple negation

00:04:08,859 --> 00:04:12,699
and that works fine you can formulate

00:04:10,989 --> 00:04:15,099
any statement you want using just those

00:04:12,699 --> 00:04:17,320
two but it does seem very clumsy to the

00:04:15,099 --> 00:04:18,909
modern reader this is one of the things

00:04:17,320 --> 00:04:21,789
that struck me most deeply learning the

00:04:18,909 --> 00:04:24,190
early history good old and Anor aren't

00:04:21,789 --> 00:04:26,409
that old mathematical logic developed

00:04:24,190 --> 00:04:29,380
out of philosophic logic and that meant

00:04:26,409 --> 00:04:30,820
Aristotelian syllogisms for a long time

00:04:29,380 --> 00:04:33,190
all they were trying to do was formulate

00:04:30,820 --> 00:04:35,740
a more rigorous version of all men are

00:04:33,190 --> 00:04:36,940
mortal Socrates as a man therefore

00:04:35,740 --> 00:04:39,130
Socrates is mortal

00:04:36,940 --> 00:04:40,660
it wasn't until mathematical logic was

00:04:39,130 --> 00:04:42,070
explored for its own sake

00:04:40,660 --> 00:04:44,680
that the greater expressiveness of a

00:04:42,070 --> 00:04:47,290
hinden or became to be appreciated there

00:04:44,680 --> 00:04:49,360
was also the generality in frege's words

00:04:47,290 --> 00:04:51,520
this stands for the judgment that

00:04:49,360 --> 00:04:53,980
whatever we may take for its argument

00:04:51,520 --> 00:04:56,110
the function is a fact this works

00:04:53,980 --> 00:04:59,020
exactly like the universal quantifier or

00:04:56,110 --> 00:05:01,000
turned a notation of predicate calculus

00:04:59,020 --> 00:05:02,830
they're both nothing more than a formal

00:05:01,000 --> 00:05:05,170
way to write Aristotle's all men are

00:05:02,830 --> 00:05:07,930
mortal there isn't as you might be

00:05:05,170 --> 00:05:09,660
expecting an existential quantifier such

00:05:07,930 --> 00:05:12,520
as the backward a of predicate calculus

00:05:09,660 --> 00:05:13,990
this isn't strictly needed as it can be

00:05:12,520 --> 00:05:16,900
phrased in terms Freya has already

00:05:13,990 --> 00:05:19,330
defined to say there is an immortal frog

00:05:16,900 --> 00:05:21,670
is the same as saying it is not true

00:05:19,330 --> 00:05:24,700
that for all frogs F F is not immortal

00:05:21,670 --> 00:05:26,410
this Lac was common in fakers era the

00:05:24,700 --> 00:05:27,880
existential quantifier was another bit

00:05:26,410 --> 00:05:30,010
of syntactic sugar that took a while to

00:05:27,880 --> 00:05:31,870
be considered as a basic operator in its

00:05:30,010 --> 00:05:33,550
own right the big riff shift goes on to

00:05:31,870 --> 00:05:35,430
develop other terminology in terms of

00:05:33,550 --> 00:05:37,750
the above but those are the basics and

00:05:35,430 --> 00:05:39,730
reading through it while struggling

00:05:37,750 --> 00:05:41,200
through the interpretation I couldn't

00:05:39,730 --> 00:05:42,820
help but feel sad that this amazing

00:05:41,200 --> 00:05:45,280
notation had never been picked up by

00:05:42,820 --> 00:05:46,780
other mathematicians what if Russell and

00:05:45,280 --> 00:05:49,180
her Whitehead had used it to read the

00:05:46,780 --> 00:05:50,740
pre capilla what if Turing had used it

00:05:49,180 --> 00:05:53,200
when outlying in the next 50 years of

00:05:50,740 --> 00:05:55,420
computer science what would programming

00:05:53,200 --> 00:05:58,270
look like in that world I decided I had

00:05:55,420 --> 00:06:00,190
to find out the end result is Gottlob my

00:05:58,270 --> 00:06:01,960
esoteric programming language he's

00:06:00,190 --> 00:06:04,240
implemented in JavaScript so it can be

00:06:01,960 --> 00:06:05,830
run in any browser this was kind of

00:06:04,240 --> 00:06:08,050
achieved since it meant I didn't have to

00:06:05,830 --> 00:06:10,330
write the lexer parser and I really like

00:06:08,050 --> 00:06:11,890
writing luxr parsers but it was always

00:06:10,330 --> 00:06:13,810
going to need a custom editor for the

00:06:11,890 --> 00:06:15,310
notation so I figured it was best to

00:06:13,810 --> 00:06:15,880
keep it as accessible for people as

00:06:15,310 --> 00:06:18,610
possible

00:06:15,880 --> 00:06:20,740
now just like there isn't the one-to-one

00:06:18,610 --> 00:06:23,169
mapping between mathematical notation

00:06:20,740 --> 00:06:25,180
and real programming languages frege's

00:06:23,169 --> 00:06:27,010
system had to be adapted to turn it into

00:06:25,180 --> 00:06:28,060
something that can do things instead of

00:06:27,010 --> 00:06:30,400
just proving them

00:06:28,060 --> 00:06:32,860
I made the letters B actually variable

00:06:30,400 --> 00:06:34,630
for instance following his example these

00:06:32,860 --> 00:06:36,910
are all single characters typeset in

00:06:34,630 --> 00:06:38,919
fraktur they must be declared using the

00:06:36,910 --> 00:06:41,050
judgment stroke also following his

00:06:38,919 --> 00:06:42,880
example functions are typically named as

00:06:41,050 --> 00:06:45,040
Greek letters but this isn't enforced

00:06:42,880 --> 00:06:46,630
the namespace of Greek letters is

00:06:45,040 --> 00:06:48,250
limited enough that all the built-in

00:06:46,630 --> 00:06:50,530
utility functions are given normal

00:06:48,250 --> 00:06:52,570
English names conditionalities remained

00:06:50,530 --> 00:06:54,220
more or less the same just interpreted

00:06:52,570 --> 00:06:56,230
in the functional context

00:06:54,220 --> 00:06:58,810
B is evaluated and only if it is

00:06:56,230 --> 00:07:01,120
affirmed is a evaluated the entire thing

00:06:58,810 --> 00:07:03,130
remains a logical operator however whose

00:07:01,120 --> 00:07:05,950
judgment is always affirmed unless B is

00:07:03,130 --> 00:07:07,510
affirmed n A's denied generalities were

00:07:05,950 --> 00:07:09,760
obviously destined to become a loop

00:07:07,510 --> 00:07:12,550
operator however they couldn't actually

00:07:09,760 --> 00:07:14,350
be universal quantifiers forcing four

00:07:12,550 --> 00:07:16,090
statements to loop over all the integers

00:07:14,350 --> 00:07:18,580
would present both implementation and

00:07:16,090 --> 00:07:20,170
application difficulties in Gottlob the

00:07:18,580 --> 00:07:22,600
quantifier statement uses the

00:07:20,170 --> 00:07:24,700
pre-existing value of a and loops over

00:07:22,600 --> 00:07:27,220
every component if it's an array or from

00:07:24,700 --> 00:07:29,740
1 up to an including its value if it's

00:07:27,220 --> 00:07:31,750
an integer like conditionalities the

00:07:29,740 --> 00:07:34,240
generality remains a logical operator

00:07:31,750 --> 00:07:36,490
it's judgment is affirmed if and only if

00:07:34,240 --> 00:07:38,980
Phi of a is affirmed for each and every

00:07:36,490 --> 00:07:41,230
value of a I also added a matrix

00:07:38,980 --> 00:07:43,450
generality which instead of returning a

00:07:41,230 --> 00:07:46,120
judgment returns an array made up of the

00:07:43,450 --> 00:07:48,220
return value of every iteration this was

00:07:46,120 --> 00:07:49,960
a complete fabrication on my part but it

00:07:48,220 --> 00:07:51,520
proved useful and seemed true to the

00:07:49,960 --> 00:07:53,800
spirit of the alternate timeline I was

00:07:51,520 --> 00:07:55,420
trying to channel the rest is more or

00:07:53,800 --> 00:07:57,220
less a standard programming language

00:07:55,420 --> 00:07:59,710
that use a standard mathematical

00:07:57,220 --> 00:08:01,540
notation wherever possible the editor

00:07:59,710 --> 00:08:03,280
allows direct editing of any part of the

00:08:01,540 --> 00:08:04,930
program with statements being entered

00:08:03,280 --> 00:08:07,090
either from the menu on the left or via

00:08:04,930 --> 00:08:09,100
keyboard shortcuts basic arithmetic

00:08:07,090 --> 00:08:11,440
operations are introduced JavaScript

00:08:09,100 --> 00:08:13,120
just to keep it simple so what can you

00:08:11,440 --> 00:08:15,550
do with it here is a simple civil

00:08:13,120 --> 00:08:17,530
Barzani's prime number function the

00:08:15,550 --> 00:08:20,410
original value is saved in a letter C

00:08:17,530 --> 00:08:22,720
which a generality been loops over so

00:08:20,410 --> 00:08:25,330
for every number less than or equal to a

00:08:22,720 --> 00:08:27,910
the conditionalities must be affirmed if

00:08:25,330 --> 00:08:29,470
they are one or a itself as those

00:08:27,910 --> 00:08:31,210
branches evaluate to denied and

00:08:29,470 --> 00:08:32,380
conditionalities are always affirmed if

00:08:31,210 --> 00:08:34,419
that branch is denied

00:08:32,380 --> 00:08:37,120
so that just leaves the check to see if

00:08:34,419 --> 00:08:40,180
the value C does not divide evenly into

00:08:37,120 --> 00:08:42,700
a if it doesn't for all values of C than

00:08:40,180 --> 00:08:45,220
a must be a prime this is the classic or

00:08:42,700 --> 00:08:47,770
gorian leap year calculator a year is a

00:08:45,220 --> 00:08:50,440
leap year if it is divisible by 4 unless

00:08:47,770 --> 00:08:51,820
it is divisible by 100 unless it is also

00:08:50,440 --> 00:08:54,100
divisible by 400

00:08:51,820 --> 00:08:56,170
this is compactly phrased in got lob as

00:08:54,100 --> 00:08:58,480
such which makes sense if you pick it

00:08:56,170 --> 00:09:00,130
apart the inner conditionality will only

00:08:58,480 --> 00:09:02,980
been denied in the situation when the

00:09:00,130 --> 00:09:05,080
year it's divisible by 4 but not by 100

00:09:02,980 --> 00:09:06,790
thus the outer conditionality will be

00:09:05,080 --> 00:09:07,720
denied when the Year is not divisible by

00:09:06,790 --> 00:09:09,850
00:09:07,720 --> 00:09:12,269
and also when divisible by 100 but not

00:09:09,850 --> 00:09:14,529
by 400 so when did I learn from all this

00:09:12,269 --> 00:09:16,300
while I appreciate the link between

00:09:14,529 --> 00:09:18,699
classical logic and programming

00:09:16,300 --> 00:09:20,199
languages a lot more now like a lot of

00:09:18,699 --> 00:09:22,389
science and math that all tends to get

00:09:20,199 --> 00:09:23,470
taught in very a historical ways and I

00:09:22,389 --> 00:09:25,750
wish I'd learned about that connection

00:09:23,470 --> 00:09:27,220
earlier and I definitely appreciate

00:09:25,750 --> 00:09:29,740
modern notation a lot more now

00:09:27,220 --> 00:09:32,139
particularly the dominance of and and or

00:09:29,740 --> 00:09:33,519
over implies I'm sure I'd get more

00:09:32,139 --> 00:09:35,649
comfortable with it if I use it all the

00:09:33,519 --> 00:09:37,149
time but even after playing around all

00:09:35,649 --> 00:09:39,819
this time I do still find a fairly

00:09:37,149 --> 00:09:41,829
unintuitive simplifications like that

00:09:39,819 --> 00:09:44,199
are an unsung glory of mathematical

00:09:41,829 --> 00:09:46,180
formalization it's easy to dismiss that

00:09:44,199 --> 00:09:47,829
as an academic thing but writing things

00:09:46,180 --> 00:09:50,050
down in abstract notation can lead you

00:09:47,829 --> 00:09:51,670
to important discoveries people have

00:09:50,050 --> 00:09:53,800
been working with classical syllogisms

00:09:51,670 --> 00:09:55,180
for literally 2,000 years and they never

00:09:53,800 --> 00:09:57,910
noticed how much simpler it would be

00:09:55,180 --> 00:10:01,709
with and nor but within decades of bools

00:09:57,910 --> 00:10:04,089
first attempt those started to emerge so

00:10:01,709 --> 00:10:06,089
abstract notation can free you from

00:10:04,089 --> 00:10:09,209
assumptions you didn't even know you had

00:10:06,089 --> 00:10:09,209

YouTube URL: https://www.youtube.com/watch?v=D63j7f0EADc


