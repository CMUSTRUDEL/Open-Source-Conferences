Title: !!COn 2020 - Supercharged Dijkstra’s: Computing ‘shortest’ paths on large road... by Payas Rajan
Publication date: 2020-05-28
Playlist: !!Con 2020
Description: 
	Supercharged Dijkstra’s: Computing ‘shortest’ paths on large road graphs in microseconds! by Payas Rajan

Road networks are often modeled as graphs with millions of edges, and finding a ‘shortest’ path on them is a fundamental operation for several applications. When Fibonacci heaps are used, Dijkstra’s algorithm provides an asymptotically optimal solution to the shortest path problem. However, in practice, Dijkstra’s is too slow for unaltered use in mapping services. In this talk, I shall present Contraction Hierarchies, a technique that can speed up the shortest path computation by almost an order of magnitude or more!

Payas once wanted to study History, but is now working towards a PhD in Computer Science at the University of California - Riverside. His research involves developing strange versions of route planning algorithms for transportation networks, and sometimes, more broadly, algorithm engineering. He used to work for Samsung Research.
Captions: 
	00:00:13,720 --> 00:00:18,260
okay hello good evening or good

00:00:16,460 --> 00:00:20,360
afternoon depending on which time zone

00:00:18,260 --> 00:00:22,490
you are in and since we're talking about

00:00:20,360 --> 00:00:24,770
computing and at the heart of computing

00:00:22,490 --> 00:00:27,349
lie algorithms so I will present to you

00:00:24,770 --> 00:00:30,410
an algorithmic problem and two solutions

00:00:27,349 --> 00:00:32,390
to it after every solution I shall run a

00:00:30,410 --> 00:00:34,340
fairly optimized implementation of the

00:00:32,390 --> 00:00:36,290
algorithm written in rust and we shall

00:00:34,340 --> 00:00:38,930
see how the how well the solution forms

00:00:36,290 --> 00:00:41,450
in real time so this is a ten minute

00:00:38,930 --> 00:00:46,090
talk and it has two demos so let's begin

00:00:41,450 --> 00:00:50,090
okay a graph ok yes again sorry yeah a

00:00:46,090 --> 00:00:52,750
graph is composed of nodes edges and

00:00:50,090 --> 00:00:55,429
it's weights of course we know that and

00:00:52,750 --> 00:00:57,379
we shall consider only simple graphs so

00:00:55,429 --> 00:00:59,359
no self loops and parallel edges are

00:00:57,379 --> 00:01:00,589
allowed and we shall assume that the

00:00:59,359 --> 00:01:03,350
edge weights are always positive

00:01:00,589 --> 00:01:04,640
integers for now right now the problem

00:01:03,350 --> 00:01:06,560
that we're trying to solve is to find

00:01:04,640 --> 00:01:09,740
the shortest path from the source s to a

00:01:06,560 --> 00:01:10,100
target T in the graph sounds simple

00:01:09,740 --> 00:01:13,040
right

00:01:10,100 --> 00:01:15,170
no wait here's the real problem we need

00:01:13,040 --> 00:01:17,090
to find the shortest path on the graph

00:01:15,170 --> 00:01:19,880
of New York City and San Francisco Bay

00:01:17,090 --> 00:01:22,040
Area each of which has about 300

00:01:19,880 --> 00:01:26,090
thousand nodes and 800,000 edges each

00:01:22,040 --> 00:01:27,710
and we I mean the reason I use I have

00:01:26,090 --> 00:01:29,960
underlined the word shortest there is

00:01:27,710 --> 00:01:33,770
because the butts are not necessarily

00:01:29,960 --> 00:01:35,060
the shortest but they are actually they

00:01:33,770 --> 00:01:36,500
give me the quickest as well depending

00:01:35,060 --> 00:01:38,030
on depending on what edge weights you

00:01:36,500 --> 00:01:39,759
set so if you said there edge weights to

00:01:38,030 --> 00:01:41,780
this time taken to travel between notes

00:01:39,759 --> 00:01:45,890
the paths you get are actually the

00:01:41,780 --> 00:01:47,509
quickest paths right so it's the concept

00:01:45,890 --> 00:01:50,360
of shortest can actually be generalized

00:01:47,509 --> 00:01:51,950
okay so going ahead the classic solution

00:01:50,360 --> 00:01:54,890
to this problem is of course the

00:01:51,950 --> 00:01:57,530
Dijkstra's algorithm and which appeared

00:01:54,890 --> 00:01:59,750
in the 1959 paper by Dijkstra called

00:01:57,530 --> 00:02:03,649
note on two problems in connection with

00:01:59,750 --> 00:02:07,250
graphs and no that is not a typo that is

00:02:03,649 --> 00:02:10,640
actually an archaic word in the title of

00:02:07,250 --> 00:02:12,200
the paper and I'm glad that computer

00:02:10,640 --> 00:02:13,730
science has reached a milestone when we

00:02:12,200 --> 00:02:16,400
can find papers with archived words in

00:02:13,730 --> 00:02:18,950
the titles anyway let's move to the

00:02:16,400 --> 00:02:20,900
algorithm so here is the graph that we

00:02:18,950 --> 00:02:23,420
had in the that we took give us an

00:02:20,900 --> 00:02:25,300
example before and we have added the

00:02:23,420 --> 00:02:26,560
source s to a frontier

00:02:25,300 --> 00:02:29,470
and the green labels in every vertex

00:02:26,560 --> 00:02:33,130
represent the best known distance to

00:02:29,470 --> 00:02:36,970
that vertex from the source s next we

00:02:33,130 --> 00:02:40,030
start relaxing edges on each iteration

00:02:36,970 --> 00:02:43,420
we take this shortest edge incident on

00:02:40,030 --> 00:02:46,360
the frontier and add the destination

00:02:43,420 --> 00:02:47,860
node of the edge to the frontier add the

00:02:46,360 --> 00:02:50,410
destination of node of the vertex to the

00:02:47,860 --> 00:02:52,360
off node to the frontier and update the

00:02:50,410 --> 00:02:55,380
labels on the nose Addison to the new

00:02:52,360 --> 00:02:59,680
frontier if needed for example in this

00:02:55,380 --> 00:03:02,230
node here there are at the top the label

00:02:59,680 --> 00:03:05,140
was abated to five from infinity because

00:03:02,230 --> 00:03:10,330
we found a shortest path from s to that

00:03:05,140 --> 00:03:12,010
node via this node which has a shortest

00:03:10,330 --> 00:03:16,360
path which has a distance of which has a

00:03:12,010 --> 00:03:17,710
total distance of five right and four on

00:03:16,360 --> 00:03:20,320
the other hand we did not update the

00:03:17,710 --> 00:03:22,600
label for for because we had the new

00:03:20,320 --> 00:03:24,460
path that we found to this vertex was

00:03:22,600 --> 00:03:29,340
actually longer than the earlier path we

00:03:24,460 --> 00:03:32,920
are already new right so we repeat this

00:03:29,340 --> 00:03:35,290
till we've until the target is found or

00:03:32,920 --> 00:03:36,880
which are out of nodes and the

00:03:35,290 --> 00:03:40,209
complexity of this algorithm turns out

00:03:36,880 --> 00:03:42,640
to be order of v square which is from

00:03:40,209 --> 00:03:43,840
Tikes reservation people but over time

00:03:42,640 --> 00:03:47,160
it has been improved if you use

00:03:43,840 --> 00:03:49,989
Fibonacci heaps the best-known

00:03:47,160 --> 00:03:54,250
complexity is order of V log V Plus E

00:03:49,989 --> 00:03:56,320
right and now if you think we can do

00:03:54,250 --> 00:03:58,959
slightly better than this though so if

00:03:56,320 --> 00:04:00,820
what happens if you search from both the

00:03:58,959 --> 00:04:03,280
source and the target in opposite

00:04:00,820 --> 00:04:05,739
directions right so you have one source

00:04:03,280 --> 00:04:07,030
that goes on Yahoo delle you start

00:04:05,739 --> 00:04:09,640
developing one frontier from the source

00:04:07,030 --> 00:04:12,160
and another from the target and very ver

00:04:09,640 --> 00:04:13,570
both of those frontiers meet you should

00:04:12,160 --> 00:04:17,140
be able to find find and Shore as well

00:04:13,570 --> 00:04:19,030
right and ideally that should help us

00:04:17,140 --> 00:04:23,110
settle a few nodes and it should work

00:04:19,030 --> 00:04:27,750
well right okay so let's see let's see

00:04:23,110 --> 00:04:30,100
how well it works so here I this is the

00:04:27,750 --> 00:04:32,410
implementation for Dijkstra's and I'm

00:04:30,100 --> 00:04:35,410
going to run 100 queries randomized

00:04:32,410 --> 00:04:37,479
queries so we don't know from which edge

00:04:35,410 --> 00:04:38,770
to which from which word x2 which vertex

00:04:37,479 --> 00:04:41,710
it is going to the

00:04:38,770 --> 00:04:43,930
yes but on we see that on average it

00:04:41,710 --> 00:04:46,389
takes about 13 milliseconds per query

00:04:43,930 --> 00:04:49,090
and this is a graph that has 300,000

00:04:46,389 --> 00:04:52,360
vertices and about 800,000 edges right

00:04:49,090 --> 00:04:54,430
and maybe if it could be a fluke because

00:04:52,360 --> 00:04:56,699
we just had hundred queries right so

00:04:54,430 --> 00:05:00,190
let's run a couple of more times and

00:04:56,699 --> 00:05:02,259
every time you see that the time it

00:05:00,190 --> 00:05:04,449
roughly takes about 13 to 14

00:05:02,259 --> 00:05:08,080
I mean approximately 10 milliseconds per

00:05:04,449 --> 00:05:10,419
query right okay

00:05:08,080 --> 00:05:13,780
these are milliseconds but I promised

00:05:10,419 --> 00:05:16,900
you microseconds so we need to do

00:05:13,780 --> 00:05:20,979
something else we need to do is better

00:05:16,900 --> 00:05:25,720
than this right so in let's move to

00:05:20,979 --> 00:05:27,130
contraction hierarchies in 2006 the

00:05:25,720 --> 00:05:28,810
Center for discrete maths and

00:05:27,130 --> 00:05:30,699
theoretical computer science at Rutgers

00:05:28,810 --> 00:05:32,979
took up the shortest path problem as a

00:05:30,699 --> 00:05:34,960
challenge research groups were asked to

00:05:32,979 --> 00:05:37,000
submit papers and out of it came a whole

00:05:34,960 --> 00:05:38,199
host of speed-up techniques that could

00:05:37,000 --> 00:05:40,629
be used to make the shortest path

00:05:38,199 --> 00:05:42,789
computation faster one such technique is

00:05:40,629 --> 00:05:45,490
called the highway hierarchies now the

00:05:42,789 --> 00:05:49,240
idea is simple the researchers posited

00:05:45,490 --> 00:05:51,490
that not all edges had the same

00:05:49,240 --> 00:05:53,860
importance than a road network on one

00:05:51,490 --> 00:05:57,909
end there were local edges that had low

00:05:53,860 --> 00:05:59,860
edge weights because the vertices the

00:05:57,909 --> 00:06:01,630
vertices were pretty close and on the

00:05:59,860 --> 00:06:03,279
other end were highways with high edge

00:06:01,630 --> 00:06:06,669
weights because they connected nodes at

00:06:03,279 --> 00:06:09,279
a farther apart right this way

00:06:06,669 --> 00:06:11,229
the authors created some graphs within

00:06:09,279 --> 00:06:12,789
the road graph there was a sub graph for

00:06:11,229 --> 00:06:14,380
highways and there was another one for

00:06:12,789 --> 00:06:15,969
local roads and there were fewer the

00:06:14,380 --> 00:06:17,860
ones for the categories of road networks

00:06:15,969 --> 00:06:20,380
present at the network

00:06:17,860 --> 00:06:22,479
fun fact Germany categorizes the road

00:06:20,380 --> 00:06:26,469
into seven categories I have no idea why

00:06:22,479 --> 00:06:28,810
but they took so routing now and this

00:06:26,469 --> 00:06:30,520
model becomes like driving to travel

00:06:28,810 --> 00:06:32,770
long distances you want to hop on the

00:06:30,520 --> 00:06:34,630
highway as soon as possible and keep

00:06:32,770 --> 00:06:36,729
driving only highway only descending to

00:06:34,630 --> 00:06:38,949
the local roads when you reach close to

00:06:36,729 --> 00:06:40,599
your destination and this is exactly how

00:06:38,949 --> 00:06:42,470
a search worked when using highway

00:06:40,599 --> 00:06:44,750
hierarchies

00:06:42,470 --> 00:06:45,830
right now an interesting variant of this

00:06:44,750 --> 00:06:48,590
approach is called contraction

00:06:45,830 --> 00:06:51,650
hierarchies or CH that every node is

00:06:48,590 --> 00:06:53,930
given a place in the hierarchy once we

00:06:51,650 --> 00:06:55,430
have this hierarchy of nodes defined we

00:06:53,930 --> 00:07:01,220
can start applying the operation that

00:06:55,430 --> 00:07:03,830
gives CH its power shortcuts so explain

00:07:01,220 --> 00:07:08,390
simply if you have a shortest path from

00:07:03,830 --> 00:07:10,250
if the shortest path if you do V to W or

00:07:08,390 --> 00:07:12,590
for vertex V if you to V to W is a

00:07:10,250 --> 00:07:16,910
shortest path then the add a shortcut

00:07:12,590 --> 00:07:18,770
from u to W if you add the shortcut any

00:07:16,910 --> 00:07:21,020
dice research that reaches the vertex

00:07:18,770 --> 00:07:23,810
you can bypass the vertex field

00:07:21,020 --> 00:07:27,710
altogether this is called the

00:07:23,810 --> 00:07:30,050
contraction operation right now think

00:07:27,710 --> 00:07:32,840
about what we just did for a second we

00:07:30,050 --> 00:07:35,000
added edges to the graph and you made it

00:07:32,840 --> 00:07:39,919
bigger in order to compute the shortest

00:07:35,000 --> 00:07:43,130
paths faster right now going back to our

00:07:39,919 --> 00:07:45,140
example of what the running example that

00:07:43,130 --> 00:07:49,460
we have been taking so the red numbers

00:07:45,140 --> 00:07:51,650
are actually the order at the rank in

00:07:49,460 --> 00:07:53,990
which we are other ranks of the would

00:07:51,650 --> 00:07:57,020
cease or the orders in which we contract

00:07:53,990 --> 00:07:59,990
them and if I run the contraction

00:07:57,020 --> 00:08:01,669
algorithm on this graph I get that

00:07:59,990 --> 00:08:04,220
we add to sugar we have to add two

00:08:01,669 --> 00:08:05,979
shortcuts one from 11 to 13 another one

00:08:04,220 --> 00:08:08,600
from 2012 to 13

00:08:05,979 --> 00:08:10,430
after the short cuts have been added the

00:08:08,600 --> 00:08:12,620
search algorithm remains basically the

00:08:10,430 --> 00:08:14,750
same is bi-directional Dijkstra's except

00:08:12,620 --> 00:08:17,000
for one small change a forward search

00:08:14,750 --> 00:08:19,640
will now only go from lower rank nodes

00:08:17,000 --> 00:08:21,560
to higher rank nodes and the backward

00:08:19,640 --> 00:08:24,580
search will only go from higher rank

00:08:21,560 --> 00:08:27,590
nodes to lower rank notes for example

00:08:24,580 --> 00:08:30,169
here so if our so it starts from a

00:08:27,590 --> 00:08:34,190
vertex one it will only reach vertices

00:08:30,169 --> 00:08:37,010
that are above the rank one in the

00:08:34,190 --> 00:08:39,440
forward search and vice-versa for the

00:08:37,010 --> 00:08:41,060
backward search so the backward search

00:08:39,440 --> 00:08:43,219
only reaches the nodes that are actually

00:08:41,060 --> 00:08:46,610
higher than vertex four because I've in

00:08:43,219 --> 00:08:50,210
this case I reverse the direction of the

00:08:46,610 --> 00:08:52,310
edges right and there are a few

00:08:50,210 --> 00:08:54,020
considerations that we need to keep in

00:08:52,310 --> 00:08:55,700
mind when using this technique which is

00:08:54,020 --> 00:08:56,510
that in what order should the vertices

00:08:55,700 --> 00:08:58,610
contract

00:08:56,510 --> 00:09:01,220
and how do you compute the importance we

00:08:58,610 --> 00:09:03,380
have typically due to using hit a six

00:09:01,220 --> 00:09:07,160
but they're also optimal methods known

00:09:03,380 --> 00:09:08,810
so we can use that and okay

00:09:07,160 --> 00:09:11,440
so this is a pretty simple technique

00:09:08,810 --> 00:09:15,829
it's um slightly how to implement but

00:09:11,440 --> 00:09:20,889
let's see how well it works and I'll

00:09:15,829 --> 00:09:20,889
switch this again and okay

00:09:24,860 --> 00:09:30,779
contracting contracting contracting and

00:09:27,779 --> 00:09:33,569
here so we landed by the extra by the

00:09:30,779 --> 00:09:37,550
extreme taxes again and we we are just

00:09:33,569 --> 00:09:37,550
doing for it for ten shortest paths so

00:09:38,320 --> 00:09:42,820
we got a latency of nine milliseconds

00:09:40,810 --> 00:09:44,680
per query whereas using contraction

00:09:42,820 --> 00:09:47,770
hierarchies we are able to reduce a down

00:09:44,680 --> 00:09:49,570
to 43 microseconds and the reason you'll

00:09:47,770 --> 00:09:51,430
replicate this is because we are we have

00:09:49,570 --> 00:09:52,930
drastically reduce the search space for

00:09:51,430 --> 00:09:55,680
the bi-directional text or as that runs

00:09:52,930 --> 00:09:58,150
in the query phase of the algorithm

00:09:55,680 --> 00:10:01,680
let's run a couple of more times and see

00:09:58,150 --> 00:10:01,680
whether it actually remains static

00:10:01,949 --> 00:10:06,009
so this is hundred queries and we are

00:10:04,569 --> 00:10:11,649
getting again 13 milliseconds per query

00:10:06,009 --> 00:10:14,439
and 60 microseconds and mind you these

00:10:11,649 --> 00:10:16,540
are these are randomized way so I have

00:10:14,439 --> 00:10:18,730
no control over which shortest paths are

00:10:16,540 --> 00:10:20,709
actually running and in all the cases we

00:10:18,730 --> 00:10:23,230
are able to see about an order of

00:10:20,709 --> 00:10:24,220
magnitude of a speed-up as compared to

00:10:23,230 --> 00:10:29,529
the bi-directional and bi-directional

00:10:24,220 --> 00:10:31,540
ice risk right so yeah well that was the

00:10:29,529 --> 00:10:33,250
technique I've wanted to discuss and I

00:10:31,540 --> 00:10:34,880
hope you learn something about algorithm

00:10:33,250 --> 00:10:38,120
measuring today thank you

00:10:34,880 --> 00:10:38,120

YouTube URL: https://www.youtube.com/watch?v=5DdaoQeTis4


