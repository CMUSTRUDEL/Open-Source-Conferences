Title: !!Con 2020 - Using font shaping to put commas in big numbers EVERYWHERE!! by Tristan Hume
Publication date: 2020-05-28
Playlist: !!Con 2020
Description: 
	Using font shaping to put commas in big numbers EVERYWHERE!! by Tristan Hume

My job involves a lot of staring at big numbers, like latencies in nanoseconds, and picking out larger magnitudes like microseconds. I got tired of counting digits in many different programs, so I decided to solve the problem in the most general way possible: with a font! OpenType font shaping allows fonts to provide all sorts of fancy rules for how theyâ€™re displayed. Iâ€™ll explain how I repurposed a feature designed for Arabic calligraphy in order to make a font that inserts fake commas between groups of three digits in large numbers everywhere!

Tristan Hume works on fast software at Jane Street. He gets captivated by funny and cool technical ideas and develops a burning desire to implement them, mostly in Rust but sometimes in OpenType font shaping rules. He writes long technical articles about things he does and finds interesting at https://thume.ca/.
Captions: 
	00:00:13,030 --> 00:00:18,730
so I'm Tristan and my job involves a lot

00:00:16,960 --> 00:00:22,630
of staring at large tables of numbers

00:00:18,730 --> 00:00:23,950
and it's often I want to do something

00:00:22,630 --> 00:00:25,630
like look at this column of latency

00:00:23,950 --> 00:00:27,400
numbers in Minow seconds and pick out

00:00:25,630 --> 00:00:29,800
some larger quantity like microseconds

00:00:27,400 --> 00:00:31,630
in milliseconds and this used to involve

00:00:29,800 --> 00:00:33,340
counting a lot of digits starting from

00:00:31,630 --> 00:00:35,020
the right of the number and I found

00:00:33,340 --> 00:00:38,469
myself doing this and also as deterrent

00:00:35,020 --> 00:00:40,899
places like my text editor and my

00:00:38,469 --> 00:00:43,690
terminal and Python notebooks and my web

00:00:40,899 --> 00:00:46,510
browser and I didn't want to implement a

00:00:43,690 --> 00:00:48,550
solution for each of these places but I

00:00:46,510 --> 00:00:50,499
came up with a weird solution that would

00:00:48,550 --> 00:00:52,570
work in all of these places which is I

00:00:50,499 --> 00:00:55,839
could make a font that we didn't fake

00:00:52,570 --> 00:00:57,819
commas into my numbers and I could do

00:00:55,839 --> 00:01:00,670
this using shaping or at least I

00:00:57,819 --> 00:01:03,609
thought I could because fun shopping was

00:01:00,670 --> 00:01:05,379
really powerful and I had seen all sorts

00:01:03,609 --> 00:01:09,280
of examples of really beautiful

00:01:05,379 --> 00:01:13,390
calligraphy and fancy unifix of various

00:01:09,280 --> 00:01:15,250
sorts and so I have some examples here

00:01:13,390 --> 00:01:16,750
that I made by fooling around with the

00:01:15,250 --> 00:01:19,060
Unicode character palette for far too

00:01:16,750 --> 00:01:21,250
long like this face here made by

00:01:19,060 --> 00:01:23,229
combining characters to arrange things

00:01:21,250 --> 00:01:24,969
on top of each other and so I thought I

00:01:23,229 --> 00:01:26,799
could do it so I looked into the open

00:01:24,969 --> 00:01:31,899
type font shading specification which

00:01:26,799 --> 00:01:35,500
defines how all these things work and so

00:01:31,899 --> 00:01:37,780
it says that things proceed in various

00:01:35,500 --> 00:01:40,180
stages controlled by tables within the

00:01:37,780 --> 00:01:42,250
font so first the characters in the

00:01:40,180 --> 00:01:44,619
string are mapped to glyphs which are

00:01:42,250 --> 00:01:47,289
internal things used by the front and

00:01:44,619 --> 00:01:49,030
then glyph substitution rules and the G

00:01:47,289 --> 00:01:51,549
sub table are ran on them so these

00:01:49,030 --> 00:01:53,500
replace various sequences of glyphs with

00:01:51,549 --> 00:01:56,170
various other sequences of glyphs for

00:01:53,500 --> 00:01:58,119
example to do ligatures by combining

00:01:56,170 --> 00:02:01,420
glyphs together into a specialized

00:01:58,119 --> 00:02:03,189
literature then this sequence of glyphs

00:02:01,420 --> 00:02:05,380
that's had substitution applied to it

00:02:03,189 --> 00:02:08,470
goes to the glyph positioning step and

00:02:05,380 --> 00:02:10,869
what this does is it positions glyphs on

00:02:08,470 --> 00:02:13,510
top of each other in the correct

00:02:10,869 --> 00:02:15,820
location so that your accents are very

00:02:13,510 --> 00:02:18,040
simple above or below the character and

00:02:15,820 --> 00:02:19,990
at this point everything is still just

00:02:18,040 --> 00:02:21,310
internal IDs used by the font and it

00:02:19,990 --> 00:02:23,470
needs to be rendered by the UI system

00:02:21,310 --> 00:02:25,300
and in this case it needs to be

00:02:23,470 --> 00:02:26,980
translated to outlines and these

00:02:25,300 --> 00:02:30,520
outlines for each glyph are store

00:02:26,980 --> 00:02:31,900
in a table inside the fund and I was

00:02:30,520 --> 00:02:33,420
reading through this specification and I

00:02:31,900 --> 00:02:35,530
started to get a little worried because

00:02:33,420 --> 00:02:37,390
everything seems to work from the start

00:02:35,530 --> 00:02:39,400
of the string towards the end of the

00:02:37,390 --> 00:02:40,840
string and I needed to work from the end

00:02:39,400 --> 00:02:43,420
of the number towards the beginning of

00:02:40,840 --> 00:02:45,310
the number luckily at the very end I

00:02:43,420 --> 00:02:48,670
found the reverse chaining contextual

00:02:45,310 --> 00:02:52,019
single substitution rule and what this

00:02:48,670 --> 00:02:54,810
rule does is it acts kind of like a

00:02:52,019 --> 00:02:59,410
certain type of a regular expression

00:02:54,810 --> 00:03:01,299
where everything is a glyph class and

00:02:59,410 --> 00:03:05,200
glyph classes are kind of like reg X

00:03:01,299 --> 00:03:07,299
character classes where they match a set

00:03:05,200 --> 00:03:10,420
of glyphs that can be in a specific

00:03:07,299 --> 00:03:12,549
position so there's the single position

00:03:10,420 --> 00:03:14,680
to replace and a class of possible

00:03:12,549 --> 00:03:16,540
glyphs there and replacements for each

00:03:14,680 --> 00:03:19,170
of them as well as look ahead and

00:03:16,540 --> 00:03:22,569
backtracking classes that match various

00:03:19,170 --> 00:03:24,400
positions around that glyph and this

00:03:22,569 --> 00:03:26,470
rule type was originally designed for a

00:03:24,400 --> 00:03:29,500
type of Arabic calligraphy and it was

00:03:26,470 --> 00:03:31,150
actually meant for doing left-to-right

00:03:29,500 --> 00:03:33,040
shaping on that type of Arabic

00:03:31,150 --> 00:03:35,739
calligraphy but Arabic calligraphy is a

00:03:33,040 --> 00:03:37,299
right-to-left context so in order to

00:03:35,739 --> 00:03:38,290
left/right it has to work from the end

00:03:37,299 --> 00:03:40,329
of the string to the beginning of the

00:03:38,290 --> 00:03:41,799
string so in my left-to-right context

00:03:40,329 --> 00:03:46,569
that's exactly what I wanted it would

00:03:41,799 --> 00:03:49,000
work right to left so font designers

00:03:46,569 --> 00:03:51,040
don't actually use the tables directly

00:03:49,000 --> 00:03:52,690
because there's some binary format they

00:03:51,040 --> 00:03:56,160
use a language called feature files

00:03:52,690 --> 00:04:00,639
which compiles down to the tables and

00:03:56,160 --> 00:04:02,590
here I have an example file it has glyph

00:04:00,639 --> 00:04:05,350
class definitions at the top for lower

00:04:02,590 --> 00:04:07,450
case and upper case vowels it says a

00:04:05,350 --> 00:04:10,540
feature that I want my rules in these

00:04:07,450 --> 00:04:12,250
were just used for applying things in

00:04:10,540 --> 00:04:15,459
different orders or labeling and

00:04:12,250 --> 00:04:19,000
enabling things and then it has my rules

00:04:15,459 --> 00:04:21,250
my first rule takes finds a lowercase

00:04:19,000 --> 00:04:23,080
character next to another lowercase

00:04:21,250 --> 00:04:25,120
character and turns it into an uppercase

00:04:23,080 --> 00:04:26,889
character the next rule takes an

00:04:25,120 --> 00:04:28,539
uppercase character next to an uppercase

00:04:26,889 --> 00:04:30,160
character and turns it into a lowercase

00:04:28,539 --> 00:04:31,990
character and because these were

00:04:30,160 --> 00:04:35,650
reversed chaining they start from the

00:04:31,990 --> 00:04:37,810
end of my string and make it so that

00:04:35,650 --> 00:04:40,000
there's no two cases next to each other

00:04:37,810 --> 00:04:40,560
and so they alternate starting from

00:04:40,000 --> 00:04:43,200
whatever

00:04:40,560 --> 00:04:45,300
as at the end and this kind of

00:04:43,200 --> 00:04:47,970
alternating capitalization is kind of

00:04:45,300 --> 00:04:49,980
like counting modulo two from the end of

00:04:47,970 --> 00:04:52,350
the string by using two different glyph

00:04:49,980 --> 00:04:54,990
sets and we want to count digits from

00:04:52,350 --> 00:04:57,030
the end of the number and we can use a

00:04:54,990 --> 00:04:59,400
very similar technique by using

00:04:57,030 --> 00:05:01,200
different glyph sets but we only have

00:04:59,400 --> 00:05:03,660
one set of number glyphs so what we need

00:05:01,200 --> 00:05:06,900
to do is create extra copies of the

00:05:03,660 --> 00:05:08,820
digit glyphs so that we can keep this

00:05:06,900 --> 00:05:12,630
state because the only type of state in

00:05:08,820 --> 00:05:14,760
this substitution is by replacing glyphs

00:05:12,630 --> 00:05:20,000
so we need as many glyph sets as we need

00:05:14,760 --> 00:05:22,110
to count glyphs and as a digression I

00:05:20,000 --> 00:05:23,669
decided that at first I didn't want to

00:05:22,110 --> 00:05:25,350
insert commas I wanted to underline

00:05:23,669 --> 00:05:27,060
alternating groups of three digits and

00:05:25,350 --> 00:05:28,470
the reason is that I wanted this to work

00:05:27,060 --> 00:05:30,000
in my terminal which is a mono space

00:05:28,470 --> 00:05:31,620
context where every character has to be

00:05:30,000 --> 00:05:33,750
the same length and inserting commas

00:05:31,620 --> 00:05:34,500
would mess up the fixed width tables and

00:05:33,750 --> 00:05:36,960
things like that

00:05:34,500 --> 00:05:39,180
so in order to do this ultra naming

00:05:36,960 --> 00:05:40,860
underlining I needed to count modulo 6

00:05:39,180 --> 00:05:42,180
because that's the periodicity of this

00:05:40,860 --> 00:05:43,950
alternating groups of three digits

00:05:42,180 --> 00:05:46,050
pattern so I needed six different glyph

00:05:43,950 --> 00:05:48,750
sets meaning I needed to add five extra

00:05:46,050 --> 00:05:50,160
ones so this is how the first version of

00:05:48,750 --> 00:05:53,640
number de Lyonne worked the first

00:05:50,160 --> 00:05:55,080
character on the right of the number had

00:05:53,640 --> 00:05:57,630
no rules applied to it staying as

00:05:55,080 --> 00:05:59,580
effectively glyphs at zero and then the

00:05:57,630 --> 00:06:01,590
next character after it had a reverse

00:05:59,580 --> 00:06:03,720
sub-goal that matched a normal digit

00:06:01,590 --> 00:06:07,050
following a normal digit and turn it

00:06:03,720 --> 00:06:11,070
into a glyph one digit another character

00:06:07,050 --> 00:06:13,380
over a rule matched saying that a normal

00:06:11,070 --> 00:06:14,910
digit next to a glyphs at one digit gets

00:06:13,380 --> 00:06:18,840
replaced with a glyphs at two did it and

00:06:14,910 --> 00:06:21,270
this training pattern matches continues

00:06:18,840 --> 00:06:22,889
over the first six digits and then the

00:06:21,270 --> 00:06:24,539
seventh digit isn't matched by any rule

00:06:22,889 --> 00:06:27,630
and so stages of glyphs at zero digit

00:06:24,539 --> 00:06:29,970
and thus if I added more to just the

00:06:27,630 --> 00:06:31,800
pattern would just repeat and now that I

00:06:29,970 --> 00:06:36,030
have all my glyphs map to different

00:06:31,800 --> 00:06:39,300
glyphs s I can then modify the outlines

00:06:36,030 --> 00:06:40,710
therein the glyph table to change the

00:06:39,300 --> 00:06:43,289
style of some of these glyphs s so in

00:06:40,710 --> 00:06:45,720
this case I add an underline to glyph

00:06:43,289 --> 00:06:47,789
that's five four and three and this

00:06:45,720 --> 00:06:49,260
gives me my alternating underlining at

00:06:47,789 --> 00:06:51,450
least in theory now I have to actually

00:06:49,260 --> 00:06:52,380
write code for it and to do this I had

00:06:51,450 --> 00:06:53,980
heard of this thing called the power

00:06:52,380 --> 00:06:55,420
line fog battery which adds extra

00:06:53,980 --> 00:06:56,830
characters to a font which is kind of

00:06:55,420 --> 00:06:59,080
what I wanted so it was a good starting

00:06:56,830 --> 00:07:00,790
point except for the fact that the font

00:06:59,080 --> 00:07:02,500
library used crashed as soon as I tried

00:07:00,790 --> 00:07:04,090
to use a reverse sub rule and the reason

00:07:02,500 --> 00:07:05,470
is that it turns out nobody uses these

00:07:04,090 --> 00:07:07,120
rivers sub rules even for the type of

00:07:05,470 --> 00:07:08,650
Arabic calligraphy they're originally

00:07:07,120 --> 00:07:11,200
intended for so they're broken in a few

00:07:08,650 --> 00:07:13,480
different places luckily I did find a

00:07:11,200 --> 00:07:14,980
font library that did work and so I had

00:07:13,480 --> 00:07:17,650
my tables that finally had underlying

00:07:14,980 --> 00:07:20,470
times I'm alternating groups we did it's

00:07:17,650 --> 00:07:22,150
making them easier to read and so I went

00:07:20,470 --> 00:07:24,760
back to my original goal and I

00:07:22,150 --> 00:07:26,380
implemented fake colors by making some

00:07:24,760 --> 00:07:29,080
glyphs that's wider and inserting a

00:07:26,380 --> 00:07:30,850
comma into the upper line I squished

00:07:29,080 --> 00:07:32,500
glyphs together to make this kind of

00:07:30,850 --> 00:07:33,940
visual grouping and then I inserted a

00:07:32,500 --> 00:07:36,760
little commas in between so I could have

00:07:33,940 --> 00:07:39,310
come as even in mono spaced contexts did

00:07:36,760 --> 00:07:40,540
other fonts things like bolding and then

00:07:39,310 --> 00:07:42,010
put them on a website for people to

00:07:40,540 --> 00:07:44,470
download and wrote a blog post and

00:07:42,010 --> 00:07:46,150
someone saw this blog post and took it

00:07:44,470 --> 00:07:48,550
even further and wrote an implementation

00:07:46,150 --> 00:07:50,860
of fizzbuzz where it just adds numbers

00:07:48,550 --> 00:07:54,720
list elements and these kind of

00:07:50,860 --> 00:07:57,370
magically become the correct fizzbuzz

00:07:54,720 --> 00:07:59,950
things and it does this by implementing

00:07:57,370 --> 00:08:02,040
the divisibility rules for 3 & 5 that

00:07:59,950 --> 00:08:04,870
are based on the digits of the number as

00:08:02,040 --> 00:08:06,490
functioning rules and then basically

00:08:04,870 --> 00:08:10,150
implementing ligatures to replace those

00:08:06,490 --> 00:08:13,720
I thought this was super cool but I

00:08:10,150 --> 00:08:15,400
finally had underlines in all my places

00:08:13,720 --> 00:08:18,580
like my pandas notebooks at work and

00:08:15,400 --> 00:08:20,770
this was great now you might think this

00:08:18,580 --> 00:08:22,360
is a horrifying hack right and I don't

00:08:20,770 --> 00:08:23,710
actually think it is I think I'm kind of

00:08:22,360 --> 00:08:26,200
using font shaping for something that

00:08:23,710 --> 00:08:29,680
it's intended for or or the same kind of

00:08:26,200 --> 00:08:31,870
thing in terms of its taking a raw

00:08:29,680 --> 00:08:34,300
representation of the text and applying

00:08:31,870 --> 00:08:37,590
stylistic rules to make it it's more

00:08:34,300 --> 00:08:39,880
easy to read and visually pleasing and

00:08:37,590 --> 00:08:41,950
that's exactly the kind of thing that

00:08:39,880 --> 00:08:44,770
function is designed for it's kind of

00:08:41,950 --> 00:08:46,330
hacky insofar as I'm using it on ASCII

00:08:44,770 --> 00:08:48,130
characters that nobody expects launched

00:08:46,330 --> 00:08:49,660
anything to be applied to so various

00:08:48,130 --> 00:08:51,370
apps sometimes do performance

00:08:49,660 --> 00:08:53,800
optimizations to disable font shaping

00:08:51,370 --> 00:08:55,930
for Latin characters like sublime text

00:08:53,800 --> 00:09:00,010
diagram too so I had to switch terminals

00:08:55,930 --> 00:09:01,480
to kitty to get it to work but when it

00:09:00,010 --> 00:09:03,640
does work it actually works really well

00:09:01,480 --> 00:09:05,380
and quite seamlessly including like not

00:09:03,640 --> 00:09:07,630
having the fake commas when you copy the

00:09:05,380 --> 00:09:10,230
text so

00:09:07,630 --> 00:09:14,320
I think this is actually pretty good and

00:09:10,230 --> 00:09:16,150
I think it's a cool example of what you

00:09:14,320 --> 00:09:17,530
can do when you dive into a new level of

00:09:16,150 --> 00:09:19,900
the system that you might not have

00:09:17,530 --> 00:09:22,330
looked at before and find the right

00:09:19,900 --> 00:09:23,860
level to implement things I could have

00:09:22,330 --> 00:09:26,320
done it in some kind of way involving

00:09:23,860 --> 00:09:28,690
some ansi pattern matcher to work just

00:09:26,320 --> 00:09:29,800
in my terminal or a browser plugin but I

00:09:28,690 --> 00:09:31,120
would have had to implement multiple

00:09:29,800 --> 00:09:32,110
different things and it just wouldn't

00:09:31,120 --> 00:09:33,880
have worked very well and it actually

00:09:32,110 --> 00:09:35,500
would have been harder to do and even

00:09:33,880 --> 00:09:38,470
after the time I spent researching fog

00:09:35,500 --> 00:09:40,330
shaping so I urge you to go and dive in

00:09:38,470 --> 00:09:42,730
and understand new areas of the system

00:09:40,330 --> 00:09:45,510
that you haven't seen before Thanks

00:09:42,730 --> 00:09:45,510

YouTube URL: https://www.youtube.com/watch?v=Biqm9ndNyC8


