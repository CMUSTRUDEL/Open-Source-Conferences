Title: !!Con West 2020 - isis agora lovecruft: big number small computer
Publication date: 2020-03-23
Playlist: !!Con West 2020
Description: 
	Presented at !!Con West 2020: http://bangbangcon.com/west

isis agora lovecruft's keynote, big number small computer!

#bangbangcon #bangbangconwest #bangbangconwest2020
Captions: 
	00:00:27,240 --> 00:00:29,180
Hi, I’m isis agora lovecruft.

00:00:29,200 --> 00:00:31,380
My pronouns are they/them.

00:00:31,380 --> 00:00:35,930
Once upon a time, I was a theoretical physicist, specializing in quantum and string cosmologies.

00:00:35,930 --> 00:00:40,870
But one day, a fairy princess came and kissed me on the nose and the curse was lifted.

00:00:40,870 --> 00:00:42,210
(laughter)

00:00:42,210 --> 00:00:46,100
Or I was doubly cursed, because now I'm a cryptographer.

00:00:46,100 --> 00:00:50,230
There’s this thing that happens sometimes; when I tell this to cute people at parties,

00:00:50,230 --> 00:00:52,499
they get really excited.

00:00:52,499 --> 00:00:55,510
Their eyes open wide, and they open their phones to show me their insta profiles.

00:00:55,510 --> 00:01:00,510
I’m usually confused at this point, and they ask if I want to do a shoot with them.

00:01:00,510 --> 00:01:04,030
This is when I realize that they probably misheard me, and they probably think that

00:01:04,030 --> 00:01:06,890
I said that I was a photographer.

00:01:06,890 --> 00:01:14,670
At this point, my strategy is usually to enunciate very clearly and tell them, I’m not a photographer,

00:01:14,670 --> 00:01:16,090
I'm a cryptographer.

00:01:16,090 --> 00:01:22,130
I bend maths to my will to keep secrets.

00:01:22,130 --> 00:01:27,000
In all cases but one, however, this led said cute person to dismay, shuffling off, usually

00:01:27,000 --> 00:01:29,360
mumbling about tech workers.

00:01:29,360 --> 00:01:34,039
I mean, fair.

00:01:34,039 --> 00:01:39,390
My new strategy is to talk about my photography, which albeit clearly second rate, doesn't

00:01:39,390 --> 00:01:43,480
horrify them as much as my math interests.

00:01:43,480 --> 00:01:46,509
But today I'm going to talk about the truly horrifying.

00:01:46,509 --> 00:01:51,179
Not only am I going to talk about cryptography, I’m going to talk about postquantum cryptography

00:01:51,179 --> 00:01:56,469
-- that is, cryptography that can be executed on a classical computer, but that remains

00:01:56,469 --> 00:02:01,491
secure against hypotherical adversaries in the hypothetical future where we have hypothetical

00:02:01,491 --> 00:02:06,109
ideal quantum computers suitable for quantum computation.

00:02:06,109 --> 00:02:15,220
Not only am I talking about post-quantum cryptography, but I will also be talking about 8 bit computers.

00:02:15,220 --> 00:02:17,140
How many of you had one of these machines as a kid?

00:02:17,140 --> 00:02:18,140
I didn't!

00:02:18,140 --> 00:02:27,970
By the time I realized I desperately wanted a Commodore 64, I was in kindergarten and

00:02:27,970 --> 00:02:29,640
the year was 1995.

00:02:29,640 --> 00:02:32,100
I begged my parents for one.

00:02:32,100 --> 00:02:35,690
My parents were both hackers, for background.

00:02:35,690 --> 00:02:38,930
Around that time, I had only written a bit of shell scripts on an ancient DOS machine

00:02:38,930 --> 00:02:40,710
they had let me use.

00:02:40,710 --> 00:02:47,700
My dad had to pull down an old VCR and hook it up to the DOS machine to store my code

00:02:47,700 --> 00:02:49,910
on VHS magnetic tape.

00:02:49,910 --> 00:02:52,560
He said it would last longer and store more.

00:02:52,560 --> 00:02:57,690
I had my own modem, which being a little kid and too young to realize I could desolder

00:02:57,690 --> 00:03:06,210
the modem's speaker, I used it under a pillow late at night in order to sign into IRC.

00:03:06,210 --> 00:03:11,400
My parents argued which "real" language I should learn first.

00:03:11,400 --> 00:03:12,510
My dad argued for assembly.

00:03:12,510 --> 00:03:17,540
Get to know the machine, the lowest bare metal workings of the hardware, before working up

00:03:17,540 --> 00:03:19,120
to higher level stuff.

00:03:19,120 --> 00:03:23,570
My mom argued for Perl.

00:03:23,570 --> 00:03:28,280
I don't know why.

00:03:28,280 --> 00:03:30,670
I looked up a bunch of samples of code in various languages.

00:03:30,670 --> 00:03:31,980
I had nothing else to go on.

00:03:31,980 --> 00:03:35,760
And of course, I chose LISP.

00:03:35,760 --> 00:03:40,340
My parents asked me about it and I told them I picked it because it was cute, because the

00:03:40,340 --> 00:03:43,900
trailing parentheses were curvy like girls.

00:03:43,900 --> 00:03:48,630
They were mortified.

00:03:48,630 --> 00:03:51,660
It was that year that I first asked for a Commodore 64.

00:03:51,660 --> 00:03:53,620
They said you don't want one of those.

00:03:53,620 --> 00:03:55,830
We'll get you a Pentium Pro.

00:03:55,830 --> 00:03:56,830
Way better.

00:03:56,830 --> 00:04:00,570
I said, ok sure, but I still want a Commodore 64!

00:04:00,570 --> 00:04:02,860
Since then, I've always asked for one.

00:04:02,860 --> 00:04:05,240
Every birthday and holiday.

00:04:05,240 --> 00:04:08,080
They kept saying: You don't want that!

00:04:08,080 --> 00:04:09,080
It's old.

00:04:09,080 --> 00:04:10,080
It's junk.

00:04:10,080 --> 00:04:13,950
This continued in my 20s, in which I moved to the EU and stopped asking for anything

00:04:13,950 --> 00:04:18,090
because of the daunting prospect of having to carry more luggage across an ocean again,

00:04:18,090 --> 00:04:21,630
but a couple of years ago, I moved back home to San Francisco.

00:04:21,630 --> 00:04:27,210
I mentioned to a friend how badly I wanted a Commodore 64, all the art and chiptunes

00:04:27,210 --> 00:04:30,440
I wanted to make with it.

00:04:30,440 --> 00:04:32,580
Maybe even a game.

00:04:32,580 --> 00:04:39,140
My friend responded... isis, you can just get one.

00:04:39,140 --> 00:04:42,820
You're an adult now.

00:04:42,820 --> 00:04:44,710
This was a revelation.

00:04:44,710 --> 00:04:49,000
After thinking it through, I decided my friend might be right.

00:04:49,000 --> 00:04:51,280
Surely I was an adult.

00:04:51,280 --> 00:04:55,930
So I did what adults do on a random Tuesday for no special reason at all.

00:04:55,930 --> 00:04:59,540
I opened up eBay and I bought a Commodore 64.

00:04:59,540 --> 00:05:04,400
I texted my mom on Signal as soon as I got it to tell her the good news.

00:05:04,400 --> 00:05:09,510
She responded in all caps WHAT?!

00:05:09,510 --> 00:05:11,460
This was very confusing to me.

00:05:11,460 --> 00:05:12,460
So I said...

00:05:12,460 --> 00:05:13,570
You know, I've always wanted one.

00:05:13,570 --> 00:05:17,200
I've been asking for one since I was five.

00:05:17,200 --> 00:05:19,350
And still in all caps, she responded...

00:05:19,360 --> 00:05:26,260
Sweetie, we thought you were joking!

00:05:26,400 --> 00:05:35,040
(laughter)

00:05:35,040 --> 00:05:42,080
I can't even remember what the code I wrote last week does without documenting it extremely

00:05:42,170 --> 00:05:43,170
well.

00:05:43,170 --> 00:05:51,550
And my parents think that I can keep a joke running for 22 years!

00:05:51,550 --> 00:06:00,780
So the MOS6502 chipset, which is the chipset in the Commodore 64, was introduced in 1975

00:06:00,780 --> 00:06:06,270
and sold for 1/6 of the price of the competing chips from Motorola and Intel, leading it

00:06:06,270 --> 00:06:10,500
to be credited along with the Zilog Z80 for sparking the home computing revolution of

00:06:10,500 --> 00:06:12,440
the early '80s.

00:06:12,440 --> 00:06:17,880
These chips were used in a large number of devices in the 80s, the ATARI2600, the Atari

00:06:17,880 --> 00:06:25,680
8-bit Family, APPLE II, the Nintendo Entertainment System (including the Famicom Family Computer

00:06:25,680 --> 00:06:32,610
-- I had no idea these existed), the Commodore 64, of course, the Commodore PET, the ATARI

00:06:32,610 --> 00:06:40,550
Lynx, the Ohio Scientific Challenger 4P, the BBC Micro, and even Tamagotchis!

00:06:40,550 --> 00:06:44,970
All using the 6502 or variations of the basic design.

00:06:44,970 --> 00:06:48,770
The Commodore 64 claims to be one of the most popular home computers of all time, selling

00:06:48,770 --> 00:06:51,790
over 19 million units worldwide.

00:06:51,790 --> 00:06:56,730
I'm not sure if that still remains the case, but we'll let them have it.

00:06:56,730 --> 00:07:02,210
For the 6502 architecture, there are 151 8-bit official op codes.

00:07:02,210 --> 00:07:07,290
An op code is simply a number in machine language that a processor recognizes as being a request

00:07:07,290 --> 00:07:09,000
to do a specific operation.

00:07:09,000 --> 00:07:16,320
These 151 op codes are organized into 56 instructions, some with multiple addressing modes, which

00:07:16,320 --> 00:07:18,710
I'll get to in a second.

00:07:18,710 --> 00:07:22,510
Instructions are then named with human memorable names called mnemonics, which is what we use

00:07:22,510 --> 00:07:24,930
to write assembly languages.

00:07:24,930 --> 00:07:29,030
The first so-called page of memory, which is not actually a page in the modern sense,

00:07:29,030 --> 00:07:34,440
but rather a contiguous chunk of 256 bytes, which is easier for the processor to successively

00:07:34,440 --> 00:07:39,210
address on these chips, is referred to as zero page.

00:07:39,210 --> 00:07:43,780
The chip which was actually used in the Commodore 64 is a 6510.

00:07:43,780 --> 00:07:48,150
The only difference being that the first two bytes in memory on the zero page of the chip

00:07:48,150 --> 00:07:51,590
allow what is called bank switching.

00:07:51,590 --> 00:07:56,889
Where you may memory map or unmap hard coded ROMs or allow addresses to pass through into

00:07:56,889 --> 00:07:57,889
RAM.

00:07:57,889 --> 00:08:03,400
The ROMs on the Commodore 64 include the kernel, some i/o functionality, a thing called a character

00:08:03,400 --> 00:08:08,650
ROM that stores characters and glyphs, and a BASIC interpreter, which is a text adventure

00:08:08,650 --> 00:08:13,520
that people seemed to enjoy in the '80s.

00:08:13,520 --> 00:08:19,150
One important thing to note: Since it's an 8 bit processor, the registers are 8 bits.

00:08:19,150 --> 00:08:20,479
And you only get three of them.

00:08:20,479 --> 00:08:22,300
A, X, and Y.

00:08:22,300 --> 00:08:26,389
A is the accumulator.

00:08:26,389 --> 00:08:33,180
So when you tell it to do something like ADC #5, which stands for add with carry the literal

00:08:33,180 --> 00:08:38,599
number 5, it does an add of 5 to the contents of the accumulator.

00:08:38,599 --> 00:08:44,259
The other registers are referred to as index registers.

00:08:44,259 --> 00:08:48,220
They're generally used for storing indexes, and can only do incredibly basic tasks like

00:08:48,220 --> 00:08:54,649
being incremented, decremented, or stored in memory.

00:08:54,649 --> 00:08:58,889
Now onto addressing modes.

00:08:58,889 --> 00:09:01,300
This is immediate addressing.

00:09:01,300 --> 00:09:04,499
The first instruction you can see is LDA.

00:09:04,499 --> 00:09:07,930
Which means load A or load into the accumulator.

00:09:07,930 --> 00:09:13,420
The literal, that's what the hashtag stands for, the hex, which is what the $ stands for,

00:09:13,420 --> 00:09:18,860
C0, which is the number 192, and then we clear the carry flag, which lets us know if there's

00:09:18,860 --> 00:09:23,040
been an overflow in the accumulator.

00:09:23,040 --> 00:09:26,580
Then we do add with carry the literal number 5.

00:09:26,580 --> 00:09:29,100
Now the accumulator contains the number 197.

00:09:29,100 --> 00:09:36,029
The next -- this is a pretty straightforward mode of addressing -- so now we can see the

00:09:36,029 --> 00:09:39,410
same instructions again, but used with absolute addressing.

00:09:39,410 --> 00:09:43,420
Where we used absolute addresses to point to a certain region in memory.

00:09:43,420 --> 00:09:55,149
We load 192 into the accumulator, store it at the region in memory, CFFF, we load the

00:09:55,149 --> 00:10:01,199
number 5, the literal 5, into the accumulator, clear the carry bit, and then we add the contents

00:10:01,199 --> 00:10:09,649
of the address in memory at CFFF into A and now A again contains 197.

00:10:09,649 --> 00:10:11,600
Next mode is a little bit more complicated.

00:10:11,600 --> 00:10:15,209
And this is where things start to cause problems.

00:10:15,209 --> 00:10:20,139
You can quickly write code that does surprising things.

00:10:20,139 --> 00:10:28,430
We load 0xFA into the accumulator, we store that at the location in memory CAAA, and then

00:10:28,430 --> 00:10:31,339
we load CF into the accumulator.

00:10:31,339 --> 00:10:39,050
What we're doing here by loading these literals 0xCF and 0xFA is we're putting an address

00:10:39,050 --> 00:10:40,290
at another address.

00:10:40,290 --> 00:10:44,670
But because the accumulator is 8 bits, it can only store 1 byte at a time, so we have

00:10:44,670 --> 00:10:48,570
to do the topmost bits first and the bottommost bits second.

00:10:48,570 --> 00:10:54,860
We're storing the bottom-most bits CF at CAAB, the next byte in memory, obviously.

00:10:54,860 --> 00:10:57,269
One up from CAAA.

00:10:57,269 --> 00:11:04,200
And then we're loading the number 5 into the accumulator, storing it at CFFA, loading 192

00:11:04,200 --> 00:11:12,890
into A, storing it at CFFF, clearing the carry flag, and then we do the add at CFAAA, which

00:11:12,890 --> 00:11:20,850
gets dereferenced to CFFA, and you take the contents of CFFA, which is 5, or sorry, is

00:11:20,850 --> 00:11:23,439
192, and we load it into the accumulator.

00:11:23,439 --> 00:11:26,870
A now again contains 197.

00:11:26,870 --> 00:11:28,339
And I promise this is the last one.

00:11:28,339 --> 00:11:32,610
But this is where things start to get really, really weird, and you can cause bugs really

00:11:32,610 --> 00:11:36,240
quickly, which is amazing.

00:11:36,240 --> 00:11:41,589
So again, we're doing this whole setup of loading 0xCFFA into the spot at memory at

00:11:41,589 --> 00:11:42,879
CAAA.

00:11:42,879 --> 00:11:44,399
We're loading 5 into the accumulator.

00:11:44,399 --> 00:11:48,199
We're loading -- we're storing it at CFFA.

00:11:48,199 --> 00:11:49,920
We're loading 192 in the accumulator.

00:11:49,920 --> 00:11:50,920
Same thing as before.

00:11:50,920 --> 00:11:52,269
We're storing at CFFF.

00:11:52,269 --> 00:11:53,709
That's the same.

00:11:53,709 --> 00:11:54,970
Clear the carry flag.

00:11:54,970 --> 00:11:59,019
But now we do indirect indexed addressing.

00:11:59,019 --> 00:12:03,990
We give it an address where it's gonna add an index to it first, then look at the location

00:12:03,990 --> 00:12:08,279
in memory to find another location in memory, then take the contents of that memory and

00:12:08,279 --> 00:12:10,519
add it to the accumulator.

00:12:10,519 --> 00:12:13,959
A now contains 197.

00:12:13,959 --> 00:12:18,779
As you can guess, this is a really quick way to cause bugs.

00:12:18,779 --> 00:12:28,939
So indirect mode is one of the ways that it's sort of fucky is...

00:12:28,939 --> 00:12:32,839
It has no carry flag associated with the jump instruction.

00:12:32,839 --> 00:12:39,850
So it's really easy to transfer program execution to the wrong place in memory by using indirect

00:12:39,850 --> 00:12:43,920
index addressing mode and giving it the wrong index, because suddenly if you're at a page

00:12:43,920 --> 00:12:54,410
boundary, say you're at 30FF, it doesn't actually wrap around to grab the next address at 3100.

00:12:54,410 --> 00:12:57,279
But it wraps back around to 3000.

00:12:57,279 --> 00:13:01,779
So suddenly you've transferred program execution to another place in memory which you didn't

00:13:01,779 --> 00:13:07,199
intend, which is really hard to debug, and I will show an example of that.

00:13:07,199 --> 00:13:11,519
So we load 40 into A. The literal 40.

00:13:11,519 --> 00:13:14,519
And we store it at 3000, as I mentioned.

00:13:14,519 --> 00:13:28,430
Load 0x80 into A, store at 30FF, load 50 into A, and store at the location in memory 3100.

00:13:28,430 --> 00:13:35,189
So you would guess that if you jump to 30FF, it would grab the next byte at 3100 and you

00:13:35,189 --> 00:13:39,470
would transfer program execution to the address at 5080.

00:13:39,470 --> 00:13:42,059
That's not the case because it wraps back around.

00:13:42,059 --> 00:13:47,499
You jump to 4080 and now you have a horrible bug.

00:13:47,499 --> 00:13:55,129
Now that we understand a little bit about the assembly, to talk a little bit more about

00:13:55,129 --> 00:13:57,959
the op codes...

00:13:57,959 --> 00:14:02,680
So because the op codes are 8 bit, there are obviously 256 available op codes.

00:14:02,680 --> 00:14:10,790
There are 105 which exist but are unofficial, otherwise often called the illegal op codes.

00:14:10,790 --> 00:14:16,470
Many of them curiously combine other arithmetic operations, such as OR’ing the value of

00:14:16,470 --> 00:14:22,179
a register, while shifting right or left by the value stored in another register.

00:14:22,179 --> 00:14:26,769
Obviously it's important to use as many of the illegal op codes as possible.

00:14:26,769 --> 00:14:32,329
(laughter) It may even be illegal not to use as many of the illegal op codes as possible.

00:14:32,329 --> 00:14:36,970
Sadly, though, I have yet to find a place in my current code to use any of them, so

00:14:36,970 --> 00:14:39,480
I'm leaving this as an exercise to the reader.

00:14:39,480 --> 00:14:43,949
Patches are extremely welcome and will be rewarded with a lapel badge which reads

00:14:43,949 --> 00:14:48,309
"be gay, do crime codes".

00:14:48,309 --> 00:14:51,610
Alright.

00:14:51,610 --> 00:14:55,739
So now that we’ve covered the 6502, or 6510 instruction set a little bit, I’m gonna

00:14:55,739 --> 00:14:59,970
talk a bit about the cryptography.

00:14:59,970 --> 00:15:05,670
So hypothetically, in the hypothetical future, we will hypothetically have hypothetical ideal

00:15:05,670 --> 00:15:11,670
quantum computers, which are hypothetically suitable for generalized computation and hypothetically

00:15:11,670 --> 00:15:18,470
have suitably efficient hypothetical quantum error correction codes, hypothetically.

00:15:18,470 --> 00:15:24,279
If this were to hypothetically happen it would ruin most of our current discrete log-based

00:15:24,279 --> 00:15:26,769
public key cryptography.

00:15:26,769 --> 00:15:31,290
Some like myself believe that efficient quantum error correction is likely impossible and

00:15:31,290 --> 00:15:36,410
even if it were possible, we're more likely to see non-generalized quantum computers designed

00:15:36,410 --> 00:15:42,350
to break only certain classic cryptographic algorithms or even certain key pairs for a

00:15:42,350 --> 00:15:44,889
classic cryptographic algorithm.

00:15:44,889 --> 00:15:55,650
Even if the worst case scenario is a remote chance, even if it’s .001% likely, it's

00:15:55,650 --> 00:16:01,579
nonetheless important to prepare for, as any unciphered communications could be deciphered

00:16:01,579 --> 00:16:03,989
by a quantum-capable adversary.

00:16:03,989 --> 00:16:08,220
As mentioned before, the subfield of cryptography which deals with algorithms which can be run

00:16:08,220 --> 00:16:14,379
on a classical computer but withstand attacks from a quantum computer is referred to as

00:16:14,379 --> 00:16:16,690
postquantum cryptography.

00:16:16,690 --> 00:16:21,709
The reason why quantum computers will be better than classical computers at certain classes

00:16:21,709 --> 00:16:28,809
of problems relates to the complexity of a function called the Fourier transformation.

00:16:28,809 --> 00:16:34,480
Basically it takes a set of combined waveforms and breaks it down into individual components.

00:16:34,480 --> 00:16:39,069
A real world example of this would be taking a recording of a group of people talking in

00:16:39,069 --> 00:16:44,110
a party and breaking it down into recordings of distinct individuals.

00:16:44,110 --> 00:16:48,369
Fourier transforms are phenomenally expensive on classical computers, reaching exponential

00:16:48,369 --> 00:16:51,810
complexity in the number of distinct input waveforms.

00:16:51,810 --> 00:16:54,839
But the quantum Fourier transform is linear.

00:16:54,839 --> 00:16:58,989
This allows us to compute certain classes of problems faster on a quantum computer than

00:16:58,989 --> 00:17:03,259
a classical one, such as computing discrete logarithms and factoring composites of large

00:17:03,259 --> 00:17:10,039
primes, mathematical problems which much of our public key cryptography relies upon today.

00:17:10,039 --> 00:17:16,389
So before delving into the postquantum variant of this, let's review classical elliptic curve

00:17:16,389 --> 00:17:19,569
key exchanges.

00:17:19,569 --> 00:17:25,100
We set a publicly known point, G, a generator of a group of elements, that is, points on

00:17:25,100 --> 00:17:26,559
the elliptic curve.

00:17:26,559 --> 00:17:31,880
This group has order P, which just means that there are P number of elements in the group.

00:17:31,880 --> 00:17:37,480
Alice and Bob both two secret scalars, which are just integers modulo some prime number,

00:17:37,480 --> 00:17:43,650
as A and B in the set of integers modulo that large prime number.

00:17:43,650 --> 00:17:51,269
Alice computes her public key as big A equals little A times G and sends this to Bob.

00:17:51,269 --> 00:17:57,600
Similarly, Bob computes his public key as big B equals little b times G and sends it

00:17:57,600 --> 00:17:58,600
to Alice.

00:17:58,600 --> 00:18:05,690
Alice computes their shared secret as S=little a times big B, which is equal to little a

00:18:05,690 --> 00:18:11,450
times little b times G. Bob computes theirs.

00:18:11,450 --> 00:18:18,170
Little b times big A, which is equal to little b times little a times G, and thus they arrive

00:18:18,170 --> 00:18:23,250
at the same shared value, and only an adversary which can break discrete logarithms in real

00:18:23,250 --> 00:18:28,429
time, such as a hypothetical generalized quantum computer, is able to take those at the same

00:18:28,429 --> 00:18:33,970
time, derive the secrets, and arrive at the shared value.

00:18:33,970 --> 00:18:40,669
So, without going into much details of the mathematics, but please feel free to talk

00:18:40,669 --> 00:18:45,139
to me later if you’d like to know more, to make this problem secure against adversaries

00:18:45,139 --> 00:18:50,179
with quantum computers, we need to rely on different mathematical problems.

00:18:50,179 --> 00:18:54,639
In the case of supersingular isogeny key exchanges, which -- that’s a lot of big words, I’m

00:18:54,639 --> 00:18:56,700
going to kind of gloss over them!

00:18:56,700 --> 00:19:01,040
-- rather than using points on elliptic curves as public keys, we use the elliptic curves

00:19:01,040 --> 00:19:07,299
themselves as public keys, by computing what are known as isogenes, one to one mappings

00:19:07,299 --> 00:19:15,250
where each point on a curve uniquely corresponds to a point on another curve and vice versa.

00:19:15,250 --> 00:19:17,370
So back to 8 bit.

00:19:17,370 --> 00:19:22,510
The catch phrase for the Commodore 64 was I adore my 64.

00:19:22,510 --> 00:19:24,470
People genuinely love these machines.

00:19:24,470 --> 00:19:25,470
I do too.

00:19:25,470 --> 00:19:31,559
If we're gonna continue using them, it's vital that we secure them against attacks from quantum

00:19:31,559 --> 00:19:35,250
computers today!

00:19:35,250 --> 00:19:38,690
(laughter)

00:19:38,690 --> 00:19:43,539
So one of the best known sets of parameters for implementing supersingular isogeny key

00:19:43,539 --> 00:19:49,440
exchanges requires implementing a specific field, a set of numbers that have addition

00:19:49,440 --> 00:19:53,820
(and hence subtraction), and multiplication (and hence division) defined.

00:19:53,820 --> 00:20:01,030
In this case, the field is integers modulo this 484-bit prime.

00:20:01,030 --> 00:20:06,220
Commodore 64s have 8 bit registers.

00:20:06,220 --> 00:20:09,730
Modulo arithmetic, 484 bit prime.

00:20:09,730 --> 00:20:15,100
Typically, in cryptography, we assume things about the chips we're working on.

00:20:15,100 --> 00:20:23,210
Not only that they have a multiplication instruction but one that operates in constant time.

00:20:23,210 --> 00:20:25,639
The term constant time is slightly misleading.

00:20:25,639 --> 00:20:28,830
We don't mean always runs in the same amount of time.

00:20:28,830 --> 00:20:34,580
But rather we mean: doesn't change the amount of runtime with respect to secret data.

00:20:34,580 --> 00:20:39,440
Algorithms which are not constant time, also known as variable time algorithms, have numerous

00:20:39,440 --> 00:20:44,840
known attacks for recovering secret values, while running such algorithms, such as listening

00:20:44,840 --> 00:20:49,960
to the frequency of a whine that the CPU makes, watching latency over a network or through

00:20:49,960 --> 00:20:56,670
a coprocess, or seeing if some junk data has been evicted from a CPU cache.

00:20:56,670 --> 00:21:01,149
Not only do we assume we have a mole instruction, but we generally assume very specific things

00:21:01,149 --> 00:21:05,500
about the way its underlying algorithm works.

00:21:05,500 --> 00:21:12,200
This is where I should point out that the 6502 or 6510 architecture in Commodore 64s

00:21:12,200 --> 00:21:18,230
not only has no constant time instruction for multiplication, it has no multiply instruction

00:21:18,230 --> 00:21:19,390
at all.

00:21:19,390 --> 00:21:20,390
None.

00:21:20,390 --> 00:21:26,100
So if you want to multiply numbers, you have to implement it using bitwise shifts and addition.

00:21:26,100 --> 00:21:28,370
And manually handle the carry flag.

00:21:28,370 --> 00:21:34,980
To my knowledge, no one has ever attempted constant time cryptography on such an architecture.

00:21:34,980 --> 00:21:43,440
So I sat down to a blank emacs buffer, staring for about 20 minutes and like every normal

00:21:43,440 --> 00:21:48,220
completely rational developer does, I decided to see if anyone else had ever tried solving

00:21:48,220 --> 00:21:50,270
my problem before.

00:21:50,270 --> 00:21:54,769
I did this, knowing full well that I was doing something that explicitly had never been done

00:21:54,769 --> 00:21:55,929
before.

00:21:55,929 --> 00:22:10,330
And I opened up a new tab and went to Google and typed in the query: Big number, small

00:22:10,330 --> 00:22:12,610
computer.

00:22:12,610 --> 00:22:16,700
This went about as well as you can expect.

00:22:16,700 --> 00:22:22,620
So I sat down again and began to implement from scratch 440 8 bit integers of 56 words

00:22:22,620 --> 00:22:28,030
each modulo 484 bit prime on an 8 bit system.

00:22:28,030 --> 00:22:33,280
Like a completely normal rational developer does.

00:22:33,280 --> 00:22:35,450
So...

00:22:35,450 --> 00:22:37,270
At this point, I have bad news.

00:22:37,270 --> 00:22:39,250
I brought my Commodore 64 today.

00:22:39,250 --> 00:22:42,990
I intended to do a demo of the code.

00:22:42,990 --> 00:22:45,720
But at this point, the code is not quite yet finished.

00:22:45,720 --> 00:22:49,659
I've been working on it for two or three weeks now.

00:22:49,659 --> 00:22:51,659
The code is on GitHub.

00:22:51,659 --> 00:22:57,600
I do have the finite field arithmetic done and the Montgomery arithmetic.

00:22:57,600 --> 00:22:58,600
Largely done.

00:22:58,600 --> 00:23:03,630
What's left is to implement the two isogenes and three isogenes, which are comparatively

00:23:03,630 --> 00:23:08,420
high level and sound like big words, but they're actually easier than implementing the field,

00:23:08,420 --> 00:23:11,590
which involves implementing multiplication, which is not fun.

00:23:11,590 --> 00:23:17,180
Honestly, I was hoping to demo it live, as I mentioned.

00:23:17,180 --> 00:23:21,850
Because by my estimations of the cycle count from what I have done so far, I believe Alice's

00:23:21,850 --> 00:23:28,120
key exchange should take a brief 40 minutes.

00:23:28,120 --> 00:23:33,039
And Bob's side of the key exchange should take roughly an hour.

00:23:33,039 --> 00:23:36,559
Just in time for the end of this talk.

00:23:36,559 --> 00:23:37,559
That's all.

00:23:37,559 --> 00:23:40,870
I would like to thank !!Con for inviting me.

00:23:40,870 --> 00:23:43,580
And thanks to the organizers for their hard work.

00:23:43,580 --> 00:23:48,549
And thank you to all the other wonderful speakers whose talks I am looking forward to today.

00:23:48,549 --> 00:23:50,730
And solidarity with the graduate students on strike.

00:23:50,730 --> 00:23:56,480

YouTube URL: https://www.youtube.com/watch?v=hyT6VM7_byE


