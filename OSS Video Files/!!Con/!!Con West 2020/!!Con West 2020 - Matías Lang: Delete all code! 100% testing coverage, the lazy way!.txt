Title: !!Con West 2020 - Matías Lang: Delete all code! 100% testing coverage, the lazy way!
Publication date: 2020-03-23
Playlist: !!Con West 2020
Description: 
	Presented at !!Con West 2020: http://bangbangcon.com/west

What do you do when your year-end bonus is directly related to the testing coverage of your project? Writing more tests, although expected, sounded pretty boring. Instead of that, I focused on writing a (totally useless) tool that deletes all untested branches on your code, therefore giving 100% coverage to your project, and not affecting its (tested) functionality!

In this talk, we’ll learn how to write code that uses AST manipulation to modify other pieces of code, and the problems of implementing this in Python. Also, we’ll discuss how an initially useless side project turned out to be not so useless.

#bangbangcon #bangbangconwest #bangbangconwest2020
Captions: 
	00:00:26,240 --> 00:00:27,120
Okay.

00:00:27,120 --> 00:00:29,260
Hi, everyone!

00:00:29,279 --> 00:00:35,480
So my talk idea started one day at my company, while reviewing year end bonuses.

00:00:35,480 --> 00:00:38,530
This is a monetary compensation.

00:00:38,530 --> 00:00:43,969
Based on the accomplishment of certain objectives the company had.

00:00:43,969 --> 00:00:49,940
So as any good employee, I tried to find a way to automate this thing.

00:00:49,940 --> 00:00:53,590
Oh, not working.

00:00:53,590 --> 00:00:54,800
Okay.

00:00:54,800 --> 00:00:59,159
To automate this thing.

00:00:59,159 --> 00:01:03,820
Let's find a way to minimize the work I had to do.

00:01:03,820 --> 00:01:08,140
But maximize the profit I could get from it.

00:01:08,140 --> 00:01:09,140
Obviously.

00:01:09,140 --> 00:01:10,140
So...

00:01:10,140 --> 00:01:16,300
One of the objectives we had was to get 100% testing coverage in our product.

00:01:16,300 --> 00:01:22,010
And if we think for a while, it seems that is an automatable metric.

00:01:22,010 --> 00:01:26,210
So I had this revelation.

00:01:26,210 --> 00:01:33,790
That testing code is measured based on how many lines of your code are being executed

00:01:33,790 --> 00:01:35,270
when you run your test suite.

00:01:35,270 --> 00:01:41,690
So if we just delete every line that it's uncovered, that means that because the lines

00:01:41,690 --> 00:01:49,610
weren't tested, or executed, my tests will pass anyway, and because the lines don't exist

00:01:49,610 --> 00:01:54,060
anymore, we'll get 100% coverage for free.

00:01:54,060 --> 00:01:55,060
So...

00:01:55,060 --> 00:02:02,550
Yesterday in Nick's talk, we saw how to write programs that write other programs.

00:02:02,550 --> 00:02:09,760
And today, I'll be talking about how to write programs that delete other programs, basically.

00:02:09,760 --> 00:02:11,700
So...

00:02:12,820 --> 00:02:19,620
To give an idea of what I expect my program to do, let's take this simple example.

00:02:19,630 --> 00:02:22,640
This is a simple if-else Python code.

00:02:22,650 --> 00:02:25,620
We'll be using Python.

00:02:25,620 --> 00:02:32,340
And we see here that the else branch of my code is not being executed in my test.

00:02:32,340 --> 00:02:33,340
It's not called.

00:02:33,340 --> 00:02:39,670
So what I would expect from this tool is, given the source code of the program, and

00:02:39,670 --> 00:02:46,010
the coverage information -- to delete the else, the oops(), and this is not tested.

00:02:46,010 --> 00:02:48,550
No evidence of it.

00:02:48,550 --> 00:02:54,450
For example, we have a function that -- it looks like it can be tested, but it has some

00:02:54,450 --> 00:02:55,740
unreachable goal.

00:02:55,740 --> 00:03:00,610
In this simple goal, we can just remove the last two lines.

00:03:00,610 --> 00:03:04,400
We will have 100% testing coverage.

00:03:04,400 --> 00:03:11,030
So to do this kind of tool that does source code transformation, I used the best tool

00:03:11,030 --> 00:03:12,890
for this.

00:03:12,890 --> 00:03:14,760
Regular expressions.

00:03:14,760 --> 00:03:16,620
Just kidding.

00:03:16,620 --> 00:03:22,450
Please don't use regular expressions to do this.

00:03:22,450 --> 00:03:28,530
What I used instead was Abstract Syntax Trees, so ASTs.

00:03:28,530 --> 00:03:34,100
It's basically a tree-based data structure designed to represent your source code.

00:03:34,100 --> 00:03:40,870
In this case, a simple hello world will be translated into a function call, where the

00:03:40,870 --> 00:03:46,920
child -- for one side, the function name, and for the other the arguments to the print

00:03:46,920 --> 00:03:47,920
function.

00:03:47,920 --> 00:03:56,120
That in this case is a binary operation where children are the hello and the world string.

00:03:56,120 --> 00:03:57,819
So simple enough.

00:03:57,819 --> 00:03:59,930
This AST.

00:03:59,930 --> 00:04:07,850
So just using the Python standard library, it is possible to, when I have this tree,

00:04:07,850 --> 00:04:14,260
it's a syntax tree, essentially, so this means I can work it and transform it just as we'll

00:04:14,260 --> 00:04:16,989
do with any kind of tree.

00:04:16,989 --> 00:04:26,240
This simple code that you see here is trying to get the -- pass this print hello world

00:04:26,240 --> 00:04:27,520
into an AST.

00:04:27,520 --> 00:04:37,460
Then it will visit each node in the syntax tree, and when it sees some bin operation,

00:04:37,460 --> 00:04:41,389
it will hard code the right part of it to the !!Con string.

00:04:41,389 --> 00:04:50,740
So in this case, the print hello world thing will be translated into this hello !!Con thing.

00:04:50,740 --> 00:04:55,150
One thing I want to mention is that the Python standard library has an AST module, but it

00:04:55,150 --> 00:05:02,130
doesn't allow me to transform, to convert this transformed AST back into source code

00:05:02,130 --> 00:05:03,130
again.

00:05:03,130 --> 00:05:06,970
So for this, I had to use this Google library called Pasta.

00:05:06,970 --> 00:05:11,069
I wanted to mention it, because the maintainers have been extremely supportive.

00:05:11,069 --> 00:05:17,689
I had to report many issues, because what I was doing was apparently kind of strange.

00:05:17,689 --> 00:05:22,559
So I hit a lot of corner cases related to indentation.

00:05:22,559 --> 00:05:36,569
But the maintainers helped me a lot, and fixed all the bugs almost instantly.

00:05:36,569 --> 00:05:41,350
So this is essentially what I had in my code.

00:05:41,350 --> 00:05:47,729
I wrote a program that does exactly that.

00:05:47,729 --> 00:05:50,970
It's GPL licensed.

00:05:50,970 --> 00:05:59,069
And it's not so tiny, as I will expect before.

00:05:59,069 --> 00:06:02,400
I thought it was going to take me a few hours.

00:06:02,400 --> 00:06:05,150
And it turned out to be way harder.

00:06:05,150 --> 00:06:12,520
Because what I had to do wasn't just removing the else of an if or removing the original

00:06:12,520 --> 00:06:13,520
code.

00:06:13,520 --> 00:06:18,969
But I had to deal with more complex AST transformations.

00:06:18,969 --> 00:06:25,770
For example, I had to deal with side effects in the if test expressions.

00:06:25,770 --> 00:06:34,099
Or I had to deal with the Python yield statement -- because it forms functions into generator

00:06:34,099 --> 00:06:46,169
functions, even when it's not tested, even with the yield line, it's not executed.

00:06:46,169 --> 00:06:49,559
It will impact on your source code.

00:06:49,559 --> 00:06:52,650
So I cannot trust it.

00:06:52,650 --> 00:07:00,610
One thing I also found that was a bug in the Python coverage library that incorrectly reported my

00:07:00,610 --> 00:07:09,539
call as being uncovered, because when I deleted the line, my code broke, because it was actually

00:07:09,539 --> 00:07:10,539
called.

00:07:10,539 --> 00:07:15,270
Apparently this was related to a CPython optimizer machine bug.

00:07:15,270 --> 00:07:17,740
I have no idea what it did.

00:07:17,740 --> 00:07:18,740
But...

00:07:18,740 --> 00:07:23,800
Eventually I fixed these issues, and we got this project.

00:07:23,800 --> 00:07:28,400
So I think it's time for a demo, how this works.

00:07:33,820 --> 00:07:34,820
Here I have...

00:07:34,840 --> 00:07:36,140
Can you see okay?

00:07:37,860 --> 00:07:45,400
Here I have a simple Python project I chose just because it has a fast test suite.

00:07:45,400 --> 00:07:48,020
So I will run the test suite to see.

00:07:52,580 --> 00:07:53,080
Yay.

00:07:53,240 --> 00:07:54,140
All tests are passing.

00:07:54,140 --> 00:07:57,540
Just as we would expect.

00:07:57,540 --> 00:07:58,820
But if we...

00:07:58,880 --> 00:08:00,720
Whoa.

00:08:01,560 --> 00:08:04,889
If we see the report, it has only 46% coverage.

00:08:04,889 --> 00:08:05,979
That's not so good.

00:08:05,979 --> 00:08:08,469
My boss wouldn't be so happy.

00:08:08,469 --> 00:08:14,319
But we have magicov to the rescue.

00:08:14,319 --> 00:08:15,330
Oops.

00:08:15,330 --> 00:08:18,659
I think I didn't...

00:08:18,659 --> 00:08:19,960
Okay.

00:08:19,960 --> 00:08:21,259
I...

00:08:21,259 --> 00:08:22,569
Yeah.

00:08:22,569 --> 00:08:25,659
I want to avoid any misunderstanding of the tool.

00:08:25,659 --> 00:08:29,139
So I shall run this.

00:08:29,139 --> 00:08:31,319
Oh, no!

00:08:31,319 --> 00:08:34,620
Magicov, what did you just do with my code?

00:08:34,620 --> 00:08:36,360
You messed it up!

00:08:36,360 --> 00:08:37,360
Yeah.

00:08:37,360 --> 00:08:40,870
A lot of the deleted lines...

00:08:40,870 --> 00:08:41,870
No!

00:08:41,870 --> 00:08:43,039
This can't be good!

00:08:43,039 --> 00:08:47,190
But if we run the test suite again...

00:08:47,190 --> 00:08:50,029
Let's wait a second.

00:08:50,029 --> 00:08:53,590
Oh, all tests are passing.

00:08:53,590 --> 00:08:55,010
That's good.

00:08:55,010 --> 00:09:00,779
And if we see the report...

00:09:00,779 --> 00:09:02,970
Whoa!

00:09:02,970 --> 00:09:03,970
So yeah.

00:09:03,970 --> 00:09:07,850
I have time for one more demo.

00:09:07,850 --> 00:09:15,790
So if we think this tool, magicov, was designed using test driven development, so it has a

00:09:15,790 --> 00:09:17,329
pretty good test suite.

00:09:17,329 --> 00:09:19,050
If we run it...

00:09:19,050 --> 00:09:22,310
It says all tests are passing.

00:09:22,310 --> 00:09:24,180
And 86% coverage.

00:09:24,180 --> 00:09:27,000
It's good enough.

00:09:27,000 --> 00:09:31,380
But not good enough for 100% testing coverage!

00:09:31,380 --> 00:09:34,640
So let's run the tool.

00:09:35,340 --> 00:09:36,340
Yeah.

00:09:36,340 --> 00:09:37,340
Here we have...

00:09:37,340 --> 00:09:42,220
It did some code deletions here.

00:09:42,240 --> 00:09:44,000
And if we see...

00:09:45,520 --> 00:09:46,360
Oh, I forgot the tool.

00:09:46,540 --> 00:09:47,460
No.

00:09:50,060 --> 00:09:51,540
Oh, I didn't run the test.

00:09:51,760 --> 00:09:52,760
Sorry.

00:09:52,860 --> 00:09:53,960
I had to run this again.

00:09:53,960 --> 00:09:55,680
I see the report and...

00:09:55,680 --> 00:09:57,450
Yeah!

00:09:57,450 --> 00:10:00,980
So thanks!

00:10:01,020 --> 00:10:05,480
We just Magicov'ed Magicov.

00:10:12,840 --> 00:10:23,160
So as I hope you got by now, this tool wasn't really designed to get a profit.

00:10:23,960 --> 00:10:30,960
It was just an excuse to make a tool that...it's useless

00:10:31,560 --> 00:10:34,840
It has no purpose.

00:10:34,850 --> 00:10:37,459
But it was really fun to do that.

00:10:37,459 --> 00:10:45,800
So what I want you to take from this talk is that the world is full of rational, useful,

00:10:45,800 --> 00:10:47,910
pragmatic software.

00:10:47,910 --> 00:10:52,630
But that doesn't mean you have to write useful software!

00:10:52,630 --> 00:10:54,600
This was really fun.

00:10:54,600 --> 00:11:00,649
I learned a lot of AST manipulation, source code transforming.

00:11:00,649 --> 00:11:06,850
Even if it's useless, I learned a lot, and it was really fun doing it.

00:11:06,850 --> 00:11:11,949
So I want you encourage you to write useless software.

00:11:11,949 --> 00:11:14,700

YouTube URL: https://www.youtube.com/watch?v=2bnlI3UpH-w


