Title: !!Con West 2020 - Spencer Alves: Reverse engineering game formats for fun and profit! (or just fun)
Publication date: 2020-03-23
Playlist: !!Con West 2020
Description: 
	Presented at !!Con West 2020: http://bangbangcon.com/west

Video games can be cool, right? You know what’s cooler? A hex editor!

For a while I’ve made a hobby of figuring out how games store their data, and converting it to and from other formats. I’m far from the only one to do that, but I want to share what I have learned so that you don’t have to start from scratch: things like how a hex editor works, what floating point looks like, file structures and layout, and more general reversing strategies.

#bangbangcon #bangbangconwest #bangbangconwest2020
Captions: 
	00:00:26,180 --> 00:00:29,660
Okay. Hi!

00:00:29,740 --> 00:00:33,040
So I have a lot of stuff to go through.

00:00:33,040 --> 00:00:36,970
So I hope that you've read the summary on the website.

00:00:36,970 --> 00:00:45,090
Quick disclaimer before we get started: Most of my experience is with games with file systems.

00:00:45,090 --> 00:00:48,350
So games on discs, or downloadable PC games.

00:00:48,350 --> 00:00:54,180
That's not to say that none of this is applicable to, you know, games on cartridges or even

00:00:54,180 --> 00:00:55,350
things that aren't games.

00:00:55,350 --> 00:00:57,370
I hope the techniques are general.

00:00:57,370 --> 00:01:01,920
First of all, why is this something you want to get into?

00:01:01,920 --> 00:01:06,390
Well, reasons from least useful to most useful.

00:01:06,390 --> 00:01:08,030
Least useful being showing off.

00:01:08,030 --> 00:01:09,850
These are some cool websites I like.

00:01:09,850 --> 00:01:15,659
Noclip.website is a place where you can fly around the levels from some 3D games.

00:01:15,659 --> 00:01:22,950
SilvaGunner is a YouTube channel that does spoofs of video game soundtracks.

00:01:22,950 --> 00:01:27,229
And a lot of their sources are from actually the game data itself.

00:01:27,229 --> 00:01:28,380
Second reason is modding.

00:01:28,380 --> 00:01:32,799
If you get a good enough understanding of these data formats, you can convince the program

00:01:32,799 --> 00:01:38,469
that the data you make is what it expects and you can put your own content in there!

00:01:38,469 --> 00:01:41,180
Another reason is engine recreation.

00:01:41,180 --> 00:01:48,619
So a lot of old games don't run so well on modern systems anymore.

00:01:48,619 --> 00:01:54,439
So some enterprising people have taken it upon themselves to rewrite them from scratch.

00:01:54,439 --> 00:01:58,119
Given a good enough understanding of the formats they use.

00:01:58,119 --> 00:02:01,329
Finally, the most useful thing to get out of this is learning.

00:02:01,329 --> 00:02:07,459
You learn a lot about how these game engines work, how they're put together, the engineering

00:02:07,459 --> 00:02:17,200
that goes behind them, and it's valuable information for even your day-to-day programming.

00:02:17,200 --> 00:02:19,170
What have I done with this?

00:02:19,170 --> 00:02:20,580
Well...

00:02:20,580 --> 00:02:24,390
This is supposed to be Mario doing a victory pose, but let me know after the talk if you're

00:02:24,390 --> 00:02:28,390
good with matrix math.

00:02:28,390 --> 00:02:32,940
Before you get started, even doing this, you want to do some research, because the older

00:02:32,940 --> 00:02:37,140
and more popular the game is, the more likely someone has already done the work for you,

00:02:37,140 --> 00:02:38,960
or at least most of the work.

00:02:38,960 --> 00:02:41,820
So here are some search terms.

00:02:41,820 --> 00:02:46,370
Another thing you want to think about while you're doing this work is: Keep in mind the

00:02:46,370 --> 00:02:47,370
context.

00:02:47,370 --> 00:02:48,620
What engine does it use?

00:02:48,620 --> 00:02:52,530
That's useful because engines generally use the same format.

00:02:52,530 --> 00:02:58,350
So you know if you look up another game that uses the same formats, someone may have done

00:02:58,350 --> 00:03:01,370
the work for you.

00:03:01,370 --> 00:03:04,280
What platform was it made for?

00:03:04,280 --> 00:03:08,100
That can determine things like endianness, which we’ll get to later.

00:03:08,100 --> 00:03:10,100
And who developed it?

00:03:10,100 --> 00:03:12,040
This actually goes back to the first bullet point.

00:03:12,040 --> 00:03:18,070
Even if they don't say they're using a specific engine, if a developer made two games in quick

00:03:18,070 --> 00:03:24,400
succession, it's likely that they at least had some code in common.

00:03:24,400 --> 00:03:31,010
Another thing you can get out of who developed it is...

00:03:31,010 --> 00:03:32,080
The environment it was developed in.

00:03:32,080 --> 00:03:39,670
Like, a lot of Japanese developers at least used to like to use Shift JIS instead of Unicode.

00:03:39,670 --> 00:03:42,400
So if you've never seen a hex editor before, this is what it looks like.

00:03:42,400 --> 00:03:47,360
Left column is position, middle is the actual contents of the file in hexadecimal, the right

00:03:47,360 --> 00:03:54,700
column is the same content as the file, but interpreted in ASCII, with little dots for things that aren’t

00:03:54,700 --> 00:03:59,500
printable in ASCII, and bottom there is -- I should be highlighting these.

00:03:59,500 --> 00:04:03,570
That's position, contents, ASCII.

00:04:03,570 --> 00:04:04,730
That's the... I call it decode view.

00:04:04,730 --> 00:04:10,940
It’s the contents next to the cursor, just interpreted in different data formats.

00:04:10,940 --> 00:04:13,420
Mine doesn't have a string view, but some others do.

00:04:13,420 --> 00:04:14,920
Like fling point.

00:04:14,920 --> 00:04:16,190
Things like that.

00:04:16,190 --> 00:04:19,239
I'm gonna give you this example now.

00:04:19,239 --> 00:04:22,909
By the end of the talk, hopefully I'll have given you enough information that you can

00:04:22,909 --> 00:04:24,620
figure out what this actually is.

00:04:24,620 --> 00:04:26,710
Or at least what type of file it is.

00:04:26,710 --> 00:04:28,699
I'll give you two little hints now.

00:04:28,699 --> 00:04:31,660
One is these two columns.

00:04:31,660 --> 00:04:35,990
And then the other one is the numbers on the right have a certain pattern to them.

00:04:35,990 --> 00:04:40,360
Give you a few seconds.

00:04:40,360 --> 00:04:41,360
Integers are pretty straightforward.

00:04:41,360 --> 00:04:43,110
But they can have...

00:04:43,110 --> 00:04:45,990
You have to keep two interesting things about them in mind.

00:04:45,990 --> 00:04:48,680
One is endianness.

00:04:48,680 --> 00:04:51,280
They can go either way.

00:04:51,280 --> 00:04:54,430
As for why you would want something little endian...

00:04:54,430 --> 00:04:58,310
Go ask Intel.

00:04:58,310 --> 00:05:01,979
They can also be signed or unsigned.

00:05:01,979 --> 00:05:05,900
That's not what I mean.

00:05:05,900 --> 00:05:07,129
Signed or unsigned.

00:05:07,129 --> 00:05:12,210
That means whether or not it has a plus or a minus in front of it.

00:05:12,210 --> 00:05:16,360
If you see a number starting with a bunch of Fs in hexadecimal, that's less likely a

00:05:16,360 --> 00:05:21,740
really really big number and more likely a small negative number.

00:05:21,740 --> 00:05:27,340
Floating point is harder to read in hex view than integers.

00:05:27,340 --> 00:05:29,169
But two hints I can give you.

00:05:29,169 --> 00:05:34,810
One is be looking out for that 803F or 3F80 -- that second line in the table there -- because

00:05:34,810 --> 00:05:37,759
1.0 is really really common.

00:05:37,759 --> 00:05:44,360
And in fact, as a kind of extension to that, as humans, we like to use human-sized numbers.

00:05:44,360 --> 00:05:50,090
So the exponents -- those last two -- that last byte -- is gonna be common for a lot

00:05:50,090 --> 00:05:51,090
of them.

00:05:51,090 --> 00:05:59,580
If you pop it into the decode view, and you see something like 3x10^38 or something, or

00:05:59,680 --> 00:06:06,800
3x10^200000, these game developers don't normally need to count the number of cows under the

00:06:06,800 --> 00:06:07,800
sun.

00:06:07,800 --> 00:06:13,719
So they'll usually be human-sized numbers.

00:06:13,719 --> 00:06:18,930
As for where things actually go in the file, the obvious answer is just put one thing after

00:06:18,930 --> 00:06:19,930
another.

00:06:19,930 --> 00:06:21,310
Like in a c-structed memory.

00:06:21,310 --> 00:06:22,599
Here's an example of that.

00:06:22,599 --> 00:06:28,930
It gets a little bit more complicated when you have arbitrarily sized arrays or complex

00:06:28,930 --> 00:06:32,830
data types.

00:06:32,830 --> 00:06:37,219
One way to do that is just have -- one way to do a dynamically sized array, for example,

00:06:37,219 --> 00:06:42,620
is to have just the number of the thing and number of things immediately following.

00:06:42,620 --> 00:06:45,000
But there are some other things you can do.

00:06:45,000 --> 00:06:48,830
For example, pointers.

00:06:48,830 --> 00:06:52,370
In a real running program, you can just allocate some memory and have a pointer to it.

00:06:52,370 --> 00:06:55,400
In a file, you actually have to have it all in that linear space.

00:06:55,400 --> 00:06:57,350
You can still do the same thing.

00:06:57,350 --> 00:06:58,550
So here's an example.

00:06:58,550 --> 00:07:00,330
Ignore the top part.

00:07:00,330 --> 00:07:01,330
That's the header.

00:07:01,330 --> 00:07:04,520
But you see immediately after the header you have these two numbers, which are little-endian,

00:07:04,520 --> 00:07:09,560
but if you flip it around, it points to other positions in the file.

00:07:09,560 --> 00:07:14,949
So that way this example is showing you -- at this point in the file are the -- I think

00:07:14,949 --> 00:07:19,330
it's like positions, and at this point in the file, the vertex normals, something like

00:07:19,330 --> 00:07:21,340
that.

00:07:21,340 --> 00:07:25,809
Another way you can have things laid out in the file is with chunks.

00:07:25,809 --> 00:07:28,849
Not that kind of chunk.

00:07:28,849 --> 00:07:34,159
And this is more common for really complex formats, like documents or movie files that

00:07:34,159 --> 00:07:38,050
need to have a whole bunch of different types of things all in one file.

00:07:38,050 --> 00:07:42,580
Usually you'll have a 4-byte or 8-byte or however many byte identifier for what type

00:07:42,580 --> 00:07:47,469
each chunk is and a few byte for how long the chunk is.

00:07:47,469 --> 00:07:53,839
You can see each of these chunks is 4-0 bytes, and that exactly lines up with four rows in

00:07:53,839 --> 00:07:56,860
our hex dump here.

00:07:56,860 --> 00:08:00,729
So the example that I gave you at the beginning -- I'll give you the hints again.

00:08:00,729 --> 00:08:01,729
That is this column.

00:08:01,729 --> 00:08:05,400
And actually, I’m gonna give you a little bit more information.

00:08:05,400 --> 00:08:08,900
All of these in the left column are floating point numbers.

00:08:08,900 --> 00:08:11,830
And everything on the right side are integers that are increasing.

00:08:11,830 --> 00:08:16,680
Now, anybody have any ideas as to what this is more specifically?

00:08:16,680 --> 00:08:21,849
Yes, this is a 3D mesh.

00:08:21,849 --> 00:08:22,849
Nice job.

00:08:22,849 --> 00:08:28,539
Each of those floating point numbers is a 3D position and each of those indices is -- well,

00:08:28,539 --> 00:08:30,319
numbers is an index into these positions.

00:08:30,319 --> 00:08:34,289
You get three positions, and they make a triangle.

00:08:34,289 --> 00:08:35,289
And you get a mesh.

00:08:35,289 --> 00:08:36,289
Yeah.

00:08:36,289 --> 00:08:39,779
So one thing I want to point out is the numbers on the right are generally increasing.

00:08:39,779 --> 00:08:45,449
Because that's just the way, like, indices that are automatically generated tend to be

00:08:45,449 --> 00:08:46,459
laid out.

00:08:46,459 --> 00:08:49,160
Other small things -- indices I just talked about.

00:08:49,160 --> 00:08:53,100
Opcodes we heard about in earlier talks.

00:08:53,100 --> 00:08:54,100
So they're useful for programs.

00:08:54,100 --> 00:08:56,290
They're also useful for things like music.

00:08:56,290 --> 00:08:57,410
Images are really fun in a hex editor.

00:08:57,410 --> 00:09:00,850
Because you can resize it as big as the image and view it in hexview.

00:09:00,850 --> 00:09:02,880
Audio samples tend to go up and down.

00:09:02,880 --> 00:09:09,370
Encryption and compression are really easy to recognize but really hard to decode.

00:09:09,370 --> 00:09:16,030
Because they both kind of have this similar goal of making data look random.

00:09:16,030 --> 00:09:17,030
Right?

00:09:17,030 --> 00:09:20,430
Compression needs to get as much data into as little space as possible.

00:09:20,430 --> 00:09:22,980
And encryption -- its actual goal is to make it look random.

00:09:22,980 --> 00:09:26,900
So I don't have any good solutions for that right now.

00:09:26,900 --> 00:09:30,360
Other techniques you can use, other than just looking at the hex and figuring it out from

00:09:30,360 --> 00:09:36,820
there -- the first bullet point in the last example I showed you we can recognize the

00:09:36,820 --> 00:09:40,779
different data types and then you might look at the beginning to see if there are any pointers

00:09:40,779 --> 00:09:41,970
to that, or you can look the other way.

00:09:41,970 --> 00:09:44,759
You can look at the beginning and there are things that look like pointers, and so later

00:09:44,759 --> 00:09:49,459
in the file you can look at where those point to.

00:09:49,459 --> 00:09:54,480
The next three bullet points, the ones that start with a C, are useful if you already

00:09:54,480 --> 00:09:57,930
have a program that can go one direction or the other.

00:09:57,930 --> 00:10:01,019
For, like, comparing with your own program.

00:10:01,019 --> 00:10:07,090
The second to last one, debugging, is useful if you have a debugger, or also an emulator.

00:10:07,090 --> 00:10:12,670
And then as a last resort, is actually reversing the executable.

00:10:12,670 --> 00:10:14,820
And that could be a whole separate topic.

00:10:14,820 --> 00:10:16,380
That could actually be a college course.

00:10:16,380 --> 00:10:17,639
Not a 10-minute talk.

00:10:17,639 --> 00:10:19,459
So I'm not gonna go into it here.

00:10:19,459 --> 00:10:24,550
And the other reason I would consider it my last resort is in the first slide, I talked

00:10:24,550 --> 00:10:26,529
about engine recreations.

00:10:26,529 --> 00:10:27,529
If you..

00:10:27,529 --> 00:10:30,970
How do I put this?

00:10:30,970 --> 00:10:37,610
If you look at the actual Assembly code of some executable, and you try to recreate it,

00:10:37,610 --> 00:10:39,900
you can't prove that you're not just copying it.

00:10:39,900 --> 00:10:40,950
So that gets to...

00:10:40,950 --> 00:10:42,870
Legally gray.

00:10:42,870 --> 00:10:46,350
If there's one thing I want you to take away from this talk, it's that there's no such

00:10:46,350 --> 00:10:51,029
thing as an unknown, unstructured blob of binary data.

00:10:51,029 --> 00:10:53,680
I mean, these files are written by people, right?

00:10:53,680 --> 00:10:56,000
People put those numbers there for a reason.

00:10:56,000 --> 00:10:58,579
And if you're adventurous enough, you can find out why.

00:10:58,579 --> 00:10:59,610
Here are some resources.

00:10:59,610 --> 00:11:01,470

YouTube URL: https://www.youtube.com/watch?v=MXbo6y6MCPE


