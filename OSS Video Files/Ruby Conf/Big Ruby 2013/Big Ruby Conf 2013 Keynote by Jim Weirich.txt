Title: Big Ruby Conf 2013 Keynote by Jim Weirich
Publication date: 2020-01-28
Playlist: Big Ruby 2013
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGdt/
Captions: 
	00:00:19,289 --> 00:00:24,640
thank you I'm glad to be here yeah I'm

00:00:22,779 --> 00:00:30,039
never gonna hear the end of the array

00:00:24,640 --> 00:00:32,559
conversion joke semi alright good we've

00:00:30,039 --> 00:00:34,180
got screen we've got slides my clicker

00:00:32,559 --> 00:00:38,079
works and we're going to start off with

00:00:34,180 --> 00:00:39,940
some fun before we get anything else I

00:00:38,079 --> 00:00:42,040
just want to show you a little bit of

00:00:39,940 --> 00:00:57,460
what we've been playing with back in the

00:00:42,040 --> 00:01:00,010
office so let's bring up this this is a

00:00:57,460 --> 00:01:02,469
parrot ar.drone you can see it flying

00:01:00,010 --> 00:01:04,269
there that's under the control of one of

00:01:02,469 --> 00:01:07,330
my co-workers Caron Meyer that's her

00:01:04,269 --> 00:01:12,550
drone and we have a nice big open atrium

00:01:07,330 --> 00:01:13,869
area in our office that allows us to fly

00:01:12,550 --> 00:01:15,310
these things right there in the office

00:01:13,869 --> 00:01:18,009
so a lot of lunch times or after work

00:01:15,310 --> 00:01:20,770
we'll go out there and we'll fly the

00:01:18,009 --> 00:01:23,200
drone there's Karen now what you need to

00:01:20,770 --> 00:01:24,970
realize is I'm video videoing desks and

00:01:23,200 --> 00:01:28,330
I'm doing it from my drone which is also

00:01:24,970 --> 00:01:31,450
flying that's why the camera is a little

00:01:28,330 --> 00:01:34,060
bit wobbly we're trying to fly around

00:01:31,450 --> 00:01:36,610
the big open area there the corner at

00:01:34,060 --> 00:01:38,920
the corner and I'm trying to do the

00:01:36,610 --> 00:01:41,319
maneuver where I go around and try to

00:01:38,920 --> 00:01:43,239
keep her in my field of view they're a

00:01:41,319 --> 00:01:46,750
little close to the wall there Karen

00:01:43,239 --> 00:01:50,619
okay we're good and we're just having

00:01:46,750 --> 00:01:52,030
fun playing with these things just

00:01:50,619 --> 00:01:53,649
moving them around I'm not gonna make

00:01:52,030 --> 00:01:55,810
you watch the whole thing the whole

00:01:53,649 --> 00:01:58,629
thing here but let me show you what

00:01:55,810 --> 00:02:00,569
happens when your drone runs out of

00:01:58,629 --> 00:02:05,190
battery you'll skip over here to the end

00:02:00,569 --> 00:02:05,190
okay I'm watching again there we go

00:02:05,459 --> 00:02:13,239
so flying drones awesome fun I recommend

00:02:10,780 --> 00:02:17,020
you grab one and have a good time with

00:02:13,239 --> 00:02:19,500
that I move this microphone a little bit

00:02:17,020 --> 00:02:19,500
more in the middle

00:02:22,689 --> 00:02:28,159
can you still hear me are we good yeah

00:02:24,890 --> 00:02:29,870
all right done so we're gonna talk about

00:02:28,159 --> 00:02:31,340
Ruby we're gonna talk about code we're

00:02:29,870 --> 00:02:34,390
gonna talk about threads and events and

00:02:31,340 --> 00:02:37,579
we're going to talk about flying robots

00:02:34,390 --> 00:02:39,620
so before I get it is that I want to

00:02:37,579 --> 00:02:41,120
share with you this concept of a

00:02:39,620 --> 00:02:43,250
narrative chart because we're going to

00:02:41,120 --> 00:02:45,079
be telling some stories here and I think

00:02:43,250 --> 00:02:45,859
telling stories is a very interesting

00:02:45,079 --> 00:02:48,500
thing to do

00:02:45,859 --> 00:02:52,040
and one thing you can do with movies is

00:02:48,500 --> 00:02:54,609
to go through and chart them and see how

00:02:52,040 --> 00:02:57,109
the narrative moves along and how the

00:02:54,609 --> 00:02:58,790
protagonist in the movie move around

00:02:57,109 --> 00:03:01,549
throughout the movie so the first one is

00:02:58,790 --> 00:03:04,700
12 Angry Men it has anyone seen this one

00:03:01,549 --> 00:03:07,760
this is a classic this is awesome and

00:03:04,700 --> 00:03:11,900
it's entire movie where you sit in one

00:03:07,760 --> 00:03:13,430
room with 12 jurors and they argue for

00:03:11,900 --> 00:03:15,439
the full length of the movie but it is

00:03:13,430 --> 00:03:17,269
fascinating is a good psychological

00:03:15,439 --> 00:03:20,989
drama and very good so here's a

00:03:17,269 --> 00:03:23,510
narrative chart for 12 Angry Men 12 men

00:03:20,989 --> 00:03:25,760
in a room they don't move around much

00:03:23,510 --> 00:03:29,540
here's another movie you might be more

00:03:25,760 --> 00:03:31,250
familiar with how many seen this one if

00:03:29,540 --> 00:03:36,799
you don't raise your hand you lose your

00:03:31,250 --> 00:03:39,199
geek status I have a friend whose

00:03:36,799 --> 00:03:42,590
girlfriend has not yet seen this movie

00:03:39,199 --> 00:03:48,919
and I yeah well that's exactly what he's

00:03:42,590 --> 00:03:51,290
got to correct that very soon so this is

00:03:48,919 --> 00:03:54,489
the narrative chart for Star Wars you

00:03:51,290 --> 00:03:58,310
can see so here's Luke all by himself

00:03:54,489 --> 00:04:01,430
obi-wan c-3po r2d2 and Leia are they

00:03:58,310 --> 00:04:04,459
together the droids escape over here is

00:04:01,430 --> 00:04:07,579
the the whole rescue Leia from the Death

00:04:04,459 --> 00:04:09,979
Star scene here's the duel where obi-wan

00:04:07,579 --> 00:04:12,199
dies over here is where the Death Star

00:04:09,979 --> 00:04:14,000
is blown up and you see Han and Chewie

00:04:12,199 --> 00:04:15,620
fly away and then come back in the nick

00:04:14,000 --> 00:04:17,449
of time so you kind of see a whole

00:04:15,620 --> 00:04:19,370
narrative thing go there and they

00:04:17,449 --> 00:04:21,919
actually plot this thing out for the for

00:04:19,370 --> 00:04:25,250
those three movies the being the real

00:04:21,919 --> 00:04:28,610
movies so

00:04:25,250 --> 00:04:29,840
this is from xkcd so go look this up if

00:04:28,610 --> 00:04:31,610
you want to see that they have a bunch

00:04:29,840 --> 00:04:35,630
of other movies out there but there's

00:04:31,610 --> 00:04:37,940
one more I want to share ok so you've

00:04:35,630 --> 00:04:39,940
seen this one - I'll ask us how many

00:04:37,940 --> 00:04:42,560
people have seen it more than once

00:04:39,940 --> 00:04:44,240
yes you must see this one more than once

00:04:42,560 --> 00:04:47,270
how many people understand what was

00:04:44,240 --> 00:04:48,950
going on in this movie exactly because

00:04:47,270 --> 00:04:57,400
this is the narrative chart for that

00:04:48,950 --> 00:04:57,400
movie ok excuse me

00:05:02,169 --> 00:05:07,490
so how many people here I want to ask

00:05:05,300 --> 00:05:10,660
this question how many people here

00:05:07,490 --> 00:05:13,130
consider themselves primarily a well

00:05:10,660 --> 00:05:16,760
hold your hand up if you're a Ruby

00:05:13,130 --> 00:05:21,560
programmer Ruby developer okay keep your

00:05:16,760 --> 00:05:24,830
hand put your hand down if you consider

00:05:21,560 --> 00:05:29,540
yourself primarily a web developer and

00:05:24,830 --> 00:05:31,040
that includes Rails or Sinatra so leave

00:05:29,540 --> 00:05:33,320
your hand up if you don't consider

00:05:31,040 --> 00:05:35,990
yourself primarily well ok good a couple

00:05:33,320 --> 00:05:39,050
people up there I think I've been using

00:05:35,990 --> 00:05:41,240
Ruby since before rails so to me Ruby is

00:05:39,050 --> 00:05:43,030
a general-purpose program I've used it

00:05:41,240 --> 00:05:46,130
for lots of things I've used it for

00:05:43,030 --> 00:05:47,990
scripting my tools I got so frustrated a

00:05:46,130 --> 00:05:49,640
frustrated was a build system at one

00:05:47,990 --> 00:05:51,979
client I worked out I wrote an entire

00:05:49,640 --> 00:05:55,160
build system in Ruby just to make things

00:05:51,979 --> 00:05:57,440
easier for me so I'm very much of the

00:05:55,160 --> 00:05:59,540
mindset that Ruby is not merely the web

00:05:57,440 --> 00:06:03,320
but not everybody out there is like that

00:05:59,540 --> 00:06:04,729
I think they see rails and they kind of

00:06:03,320 --> 00:06:06,260
forget Ruby's involved and they whole

00:06:04,729 --> 00:06:07,940
it's think the whole thing is tied up

00:06:06,260 --> 00:06:13,070
and it's only good for web programming

00:06:07,940 --> 00:06:17,060
so I want to encourage you to consider

00:06:13,070 --> 00:06:18,830
using Ruby for non web projects and

00:06:17,060 --> 00:06:22,580
there's lots of things out there that

00:06:18,830 --> 00:06:25,520
you can do I build tools scripting

00:06:22,580 --> 00:06:28,040
back-end stuff and I'm sure you hear

00:06:25,520 --> 00:06:30,229
more about this throughout the weekend

00:06:28,040 --> 00:06:32,900
here but I want to talk about a

00:06:30,229 --> 00:06:37,010
particular project that we did that was

00:06:32,900 --> 00:06:38,590
refreshingly not web-based now it was

00:06:37,010 --> 00:06:41,770
tied to a web it was kind of a back

00:06:38,590 --> 00:06:44,110
again for some processing but in this

00:06:41,770 --> 00:06:46,240
story I'm going to I'm gonna tell you

00:06:44,110 --> 00:06:47,860
the story about this project kind of in

00:06:46,240 --> 00:06:50,200
the abstract I'm not going to get into

00:06:47,860 --> 00:06:53,080
details about it it was a non web

00:06:50,200 --> 00:06:55,660
project it will involve lots of code you

00:06:53,080 --> 00:06:57,940
will see code examples in this talk you

00:06:55,660 --> 00:07:00,310
will we will talk about threads and we

00:06:57,940 --> 00:07:02,290
will talk about events during this time

00:07:00,310 --> 00:07:04,570
and we will also talk about flying

00:07:02,290 --> 00:07:06,820
robots unfortunately the project we work

00:07:04,570 --> 00:07:08,980
on didn't really use flying robots but I

00:07:06,820 --> 00:07:11,320
can't resist tying them in somehow

00:07:08,980 --> 00:07:13,980
so hopefully learn a little bit about

00:07:11,320 --> 00:07:16,930
Ruby through this particular discussion

00:07:13,980 --> 00:07:19,060
now imagine this is an analog to our

00:07:16,930 --> 00:07:22,300
real project when we got there the

00:07:19,060 --> 00:07:25,150
client had several hardware managing

00:07:22,300 --> 00:07:27,700
system set up and let's say it was four

00:07:25,150 --> 00:07:30,160
Roombas and general purpose robots and

00:07:27,700 --> 00:07:31,990
they would have a lot of Roombas and a

00:07:30,160 --> 00:07:34,870
lot of robots out there and they would

00:07:31,990 --> 00:07:37,210
communicate with their servers talking

00:07:34,870 --> 00:07:39,150
to manager programs there was a program

00:07:37,210 --> 00:07:41,650
to have managed the room bus there was a

00:07:39,150 --> 00:07:45,100
program to manage the general robots and

00:07:41,650 --> 00:07:48,040
they asked us to write a drone manager

00:07:45,100 --> 00:07:49,540
program I'm very excited about this

00:07:48,040 --> 00:07:51,280
because yes this is this is a really

00:07:49,540 --> 00:07:53,920
cool thing to do and again the drones

00:07:51,280 --> 00:07:55,240
will be connecting with tcp/ip they'll

00:07:53,920 --> 00:07:58,030
be creating sockets and they'll be

00:07:55,240 --> 00:08:00,460
sending information and we need to have

00:07:58,030 --> 00:08:03,610
a manager talk to them now the key thing

00:08:00,460 --> 00:08:05,800
here is that this is not a web program

00:08:03,610 --> 00:08:08,470
this is this is a program talking over

00:08:05,800 --> 00:08:13,050
sockets to hardware devices out there in

00:08:08,470 --> 00:08:16,060
the wild it has to support thousands of

00:08:13,050 --> 00:08:18,130
connections all at the same time and

00:08:16,060 --> 00:08:20,200
still pump the data through it now you

00:08:18,130 --> 00:08:23,680
might say thousands of connections that

00:08:20,200 --> 00:08:26,070
seems like a lot and it does it is the

00:08:23,680 --> 00:08:28,930
original programs were written in Java

00:08:26,070 --> 00:08:30,760
but I've written Java before I'm not

00:08:28,930 --> 00:08:32,500
scared of writing Java but coming into

00:08:30,760 --> 00:08:35,560
this thing I I was thinking you know

00:08:32,500 --> 00:08:39,100
there's no reason we could not do this

00:08:35,560 --> 00:08:42,580
particular manager in Ruby turns out

00:08:39,100 --> 00:08:45,430
that the Java programs are about 4,000

00:08:42,580 --> 00:08:47,260
lines long that's how big they are the

00:08:45,430 --> 00:08:51,649
Ruby program when we got done with that

00:08:47,260 --> 00:08:53,990
was between 3 and 400 lines so

00:08:51,649 --> 00:08:57,110
you know ten to one difference now I'll

00:08:53,990 --> 00:08:59,720
let you know up front that the original

00:08:57,110 --> 00:09:01,399
versions were fairly smart programs they

00:08:59,720 --> 00:09:03,350
did a lot of processing on the data

00:09:01,399 --> 00:09:06,949
passing through that proved problematic

00:09:03,350 --> 00:09:09,709
in that these managers you want to have

00:09:06,949 --> 00:09:11,329
up running all the time so making

00:09:09,709 --> 00:09:12,679
changes to them was problematic because

00:09:11,329 --> 00:09:14,569
if you change program you have to drop

00:09:12,679 --> 00:09:17,029
the manager and all the hardware devices

00:09:14,569 --> 00:09:19,009
have to reconnect which that caused the

00:09:17,029 --> 00:09:22,100
problem they referred to as the

00:09:19,009 --> 00:09:23,509
Sundering heard everything reconnects

00:09:22,100 --> 00:09:25,850
all at once you got to take care of all

00:09:23,509 --> 00:09:28,100
that data so we decided to keep the

00:09:25,850 --> 00:09:30,920
drone manager dumb he was going to be a

00:09:28,100 --> 00:09:33,679
day to pump only and not do a whole lot

00:09:30,920 --> 00:09:36,350
of smart processing so that is one

00:09:33,679 --> 00:09:39,860
reason for the reduce lines but maybe

00:09:36,350 --> 00:09:42,559
that accounts you know you know mm

00:09:39,860 --> 00:09:44,629
rather than 4,000 lines so we were still

00:09:42,559 --> 00:09:47,149
greatly reduced in the number of lines

00:09:44,629 --> 00:09:48,679
of code to do the Ruby version this is

00:09:47,149 --> 00:09:50,059
the whole system here I'm not going to

00:09:48,679 --> 00:09:51,350
talk about this part but I want you to

00:09:50,059 --> 00:09:53,540
let you know it exists

00:09:51,350 --> 00:09:55,579
the manager programs talked to some kind

00:09:53,540 --> 00:09:58,220
of message queue in the background there

00:09:55,579 --> 00:10:00,139
was a worker set of workers that pulled

00:09:58,220 --> 00:10:01,519
messages off the message queue and

00:10:00,139 --> 00:10:03,949
updated the database with information

00:10:01,519 --> 00:10:06,170
from all the different managers and then

00:10:03,949 --> 00:10:08,089
there was a rails web portal front-end

00:10:06,170 --> 00:10:10,910
that pulled data out of the database and

00:10:08,089 --> 00:10:12,829
displayed them to the users and the web

00:10:10,910 --> 00:10:15,019
program and the workers could both send

00:10:12,829 --> 00:10:16,339
messages back into the queue and to each

00:10:15,019 --> 00:10:18,290
of the managers which would further

00:10:16,339 --> 00:10:20,720
forward those messages out to the

00:10:18,290 --> 00:10:22,759
hardware devices so there was complete

00:10:20,720 --> 00:10:24,829
control from the web all the way out to

00:10:22,759 --> 00:10:27,319
the hardware devices that was really

00:10:24,829 --> 00:10:29,899
really cool but we're going to talk

00:10:27,319 --> 00:10:31,970
about this part right here and in fact I

00:10:29,899 --> 00:10:33,860
want to concentrate just on the drone

00:10:31,970 --> 00:10:36,410
part and what we did to make that work

00:10:33,860 --> 00:10:38,600
how we accomplished the job of talking

00:10:36,410 --> 00:10:46,249
to thousands of connections really fast

00:10:38,600 --> 00:10:48,499
in Ruby so for our talk purposes we have

00:10:46,249 --> 00:10:50,720
to establish a protocol between the

00:10:48,499 --> 00:10:52,910
drones and the manager they're going to

00:10:50,720 --> 00:10:55,069
talk over a socket connection it's going

00:10:52,910 --> 00:10:56,929
to be a text-based protocol we're going

00:10:55,069 --> 00:11:00,069
to call that protocol the flying robot

00:10:56,929 --> 00:11:02,540
objects with navigations protocol frown

00:11:00,069 --> 00:11:04,020
frown looks like this it's a very simple

00:11:02,540 --> 00:11:06,779
protocol it has four

00:11:04,020 --> 00:11:08,820
commands in it to commands are sent by

00:11:06,779 --> 00:11:10,800
the drone there's a position command

00:11:08,820 --> 00:11:13,260
where the drone reports where he is at

00:11:10,800 --> 00:11:15,209
that point in time in XY coordinates and

00:11:13,260 --> 00:11:21,660
there is a name command where the drone

00:11:15,209 --> 00:11:24,240
reports its own name the coming back to

00:11:21,660 --> 00:11:27,779
the drone there are two commands one is

00:11:24,240 --> 00:11:29,850
a name query and when the drone receives

00:11:27,779 --> 00:11:32,190
this command he should respond with the

00:11:29,850 --> 00:11:33,990
name command going back out so if the

00:11:32,190 --> 00:11:35,940
software needs to know a name of a drone

00:11:33,990 --> 00:11:38,420
he will ask in the drone will tell him

00:11:35,940 --> 00:11:40,770
his name and finally there's a crash

00:11:38,420 --> 00:11:42,930
message that it forms a drone he is

00:11:40,770 --> 00:11:46,020
occupying the same physical space as

00:11:42,930 --> 00:11:47,790
another drone and therefore he should

00:11:46,020 --> 00:11:50,399
crash and he should disconnect from the

00:11:47,790 --> 00:11:55,020
network he is down he is dead so that's

00:11:50,399 --> 00:11:57,980
our frown protocol this is an example of

00:11:55,020 --> 00:12:01,050
that a drone might send the position 5 6

00:11:57,980 --> 00:12:03,720
the monitor gets that the monarch is oh

00:12:01,050 --> 00:12:05,670
here's a brand new drone I don't know

00:12:03,720 --> 00:12:07,740
what what is called so I'm gonna send

00:12:05,670 --> 00:12:10,110
the name message back to the drone the

00:12:07,740 --> 00:12:12,420
drone responses hey I'm drone aim and

00:12:10,110 --> 00:12:14,370
then he'll update his position as he

00:12:12,420 --> 00:12:16,440
moves around kind of randomly walked and

00:12:14,370 --> 00:12:18,570
then when the monitor detects a crash

00:12:16,440 --> 00:12:21,329
he'll send a craft message and then the

00:12:18,570 --> 00:12:24,329
drone will disconnect at that point and

00:12:21,329 --> 00:12:26,310
he'll disappear off the network ok so

00:12:24,329 --> 00:12:28,500
the so that's the drone here's the

00:12:26,310 --> 00:12:31,230
monitor the monitors job is to display

00:12:28,500 --> 00:12:35,610
in a high-definition graphics

00:12:31,230 --> 00:12:37,589
environment the positions of all the

00:12:35,610 --> 00:12:39,720
drones that it knows about I

00:12:37,589 --> 00:12:41,040
particularly like the use of colons to

00:12:39,720 --> 00:12:46,020
represent the four rotors of the

00:12:41,040 --> 00:12:48,300
quadcopter the monitors set of commands

00:12:46,020 --> 00:12:52,800
will look like this he's also talking

00:12:48,300 --> 00:12:53,730
through a tcp/ip network and he the data

00:12:52,800 --> 00:12:56,760
we're sending him is a little more

00:12:53,730 --> 00:12:58,920
sophisticated it will be JSON serialized

00:12:56,760 --> 00:13:01,529
versions of these data structures so

00:12:58,920 --> 00:13:03,480
incoming he'll get a drone ID so the

00:13:01,529 --> 00:13:06,839
drone manager here every time a drone

00:13:03,480 --> 00:13:09,750
connects will create a ID for that drone

00:13:06,839 --> 00:13:11,310
that is unique and when he sends

00:13:09,750 --> 00:13:13,560
messages to the monitor he will tell you

00:13:11,310 --> 00:13:14,070
what drone it is he will get connected

00:13:13,560 --> 00:13:15,660
and

00:13:14,070 --> 00:13:17,580
connecting messages when drones connect

00:13:15,660 --> 00:13:19,440
and disconnect and he will also get the

00:13:17,580 --> 00:13:21,390
data messages whenever drone sends a

00:13:19,440 --> 00:13:23,850
frown message he will get a data message

00:13:21,390 --> 00:13:26,490
that looks like this going back from the

00:13:23,850 --> 00:13:27,990
monitor to the manager will be messages

00:13:26,490 --> 00:13:29,700
that look like this a message for this

00:13:27,990 --> 00:13:32,400
particular drone and this particular

00:13:29,700 --> 00:13:34,260
frown message right there I think is

00:13:32,400 --> 00:13:36,540
particularly cool that we designed this

00:13:34,260 --> 00:13:40,050
protocol to use arrays in this direction

00:13:36,540 --> 00:13:44,370
and hashes in that direction I don't

00:13:40,050 --> 00:13:45,840
know why I didn't actually even notice

00:13:44,370 --> 00:13:47,310
we did that Pillai was making this slide

00:13:45,840 --> 00:13:50,820
up and saw both of them on the same page

00:13:47,310 --> 00:13:53,640
at the same time we should fix that so

00:13:50,820 --> 00:13:55,170
let's look at the code that it takes to

00:13:53,640 --> 00:13:57,150
do this now this is going to be the

00:13:55,170 --> 00:13:59,310
drone code right here but this is a very

00:13:57,150 --> 00:14:02,940
close analog to what we wrote in real

00:13:59,310 --> 00:14:07,080
life for our client there's lots of

00:14:02,940 --> 00:14:08,730
details omitted error handling logging

00:14:07,080 --> 00:14:10,800
details and things like that I'm leaving

00:14:08,730 --> 00:14:12,450
out so we can concentrate on the code

00:14:10,800 --> 00:14:16,620
that we need to make this whole thing

00:14:12,450 --> 00:14:18,450
work together so first off this is the

00:14:16,620 --> 00:14:20,340
manager program this is the program sits

00:14:18,450 --> 00:14:23,190
right in the middle talks to the drones

00:14:20,340 --> 00:14:26,460
and talks to the monitor so his job is

00:14:23,190 --> 00:14:29,040
to pass data back and forth between the

00:14:26,460 --> 00:14:30,870
drones and the monitor tagging the data

00:14:29,040 --> 00:14:33,090
from the drones with the appropriate ID

00:14:30,870 --> 00:14:35,490
and when the data comes back from the

00:14:33,090 --> 00:14:37,470
monitor to look up the drone based on

00:14:35,490 --> 00:14:40,170
the ID and send it to that particular

00:14:37,470 --> 00:14:42,540
drone so the main program looks

00:14:40,170 --> 00:14:45,240
something like this we're using a vente

00:14:42,540 --> 00:14:46,950
machine a vente machine is a ruby

00:14:45,240 --> 00:14:50,970
library that allows you to do

00:14:46,950 --> 00:14:52,650
essentially nodejs stuff event at i/o so

00:14:50,970 --> 00:14:54,810
that you get call backs when Isle

00:14:52,650 --> 00:14:59,190
happens and you respond to particular

00:14:54,810 --> 00:15:01,740
events as things happen the main program

00:14:59,190 --> 00:15:03,780
is a big event loop set up by the run

00:15:01,740 --> 00:15:06,990
command on event machine and from here

00:15:03,780 --> 00:15:09,630
to here this configures the servers that

00:15:06,990 --> 00:15:13,410
we say our system needs we have two

00:15:09,630 --> 00:15:15,120
servers one is a monitor session here

00:15:13,410 --> 00:15:18,900
and he's set up to be on this host

00:15:15,120 --> 00:15:21,630
monitoring the socket and the drone

00:15:18,900 --> 00:15:25,920
session here also set up and he's on a

00:15:21,630 --> 00:15:27,240
different pork right there and that's us

00:15:25,920 --> 00:15:29,670
those things up and act

00:15:27,240 --> 00:15:31,499
I had red highlights here so he clicked

00:15:29,670 --> 00:15:34,259
like this and didn't have to point with

00:15:31,499 --> 00:15:36,899
my laser pointer so there you go so we

00:15:34,259 --> 00:15:40,050
shot two servers each server is

00:15:36,899 --> 00:15:41,999
monitoring a particular port for

00:15:40,050 --> 00:15:47,069
incoming messages incoming connections

00:15:41,999 --> 00:15:48,720
on the TCP IP now the sessions let's

00:15:47,069 --> 00:15:51,779
look at the drone session in particular

00:15:48,720 --> 00:15:54,839
this is the part of our program that

00:15:51,779 --> 00:15:59,429
looks for incoming messages from the

00:15:54,839 --> 00:16:01,019
drone and the server are actually the

00:15:59,429 --> 00:16:03,509
monitor piece monitor session is very

00:16:01,019 --> 00:16:07,829
much like this because they all they're

00:16:03,509 --> 00:16:10,050
all event machine servers so when an

00:16:07,829 --> 00:16:12,749
incoming connection is made event

00:16:10,050 --> 00:16:15,749
machine will go and create a new object

00:16:12,749 --> 00:16:19,860
of type drone session so that happens

00:16:15,749 --> 00:16:23,490
when a drone connects up after we create

00:16:19,860 --> 00:16:25,800
a drone session he will get a post init

00:16:23,490 --> 00:16:27,779
command so after event machine is done

00:16:25,800 --> 00:16:29,850
and he's ready to start using the

00:16:27,779 --> 00:16:32,369
session he'll send him a post and knit

00:16:29,850 --> 00:16:34,649
flag and then our drone our excuse me

00:16:32,369 --> 00:16:36,720
our drone session can do any final setup

00:16:34,649 --> 00:16:39,059
that he needs to do right before he's

00:16:36,720 --> 00:16:41,279
ready to start receiving messages when

00:16:39,059 --> 00:16:44,040
data comes in event machine will break

00:16:41,279 --> 00:16:46,319
it up into line by line input in each

00:16:44,040 --> 00:16:48,329
line he will send to us with a receive

00:16:46,319 --> 00:16:52,199
line message so receive line gets called

00:16:48,329 --> 00:16:54,720
on our drone session finally when the

00:16:52,199 --> 00:16:56,309
connection is closed the session will

00:16:54,720 --> 00:17:02,819
receive loops the session will receive

00:16:56,309 --> 00:17:04,380
an unbiased also so these these three

00:17:02,819 --> 00:17:06,929
messages here and the create is all

00:17:04,380 --> 00:17:10,230
handled by event machine our software

00:17:06,929 --> 00:17:12,179
can you know if it detects an error

00:17:10,230 --> 00:17:15,299
wants to shut shut down for some reason

00:17:12,179 --> 00:17:17,370
he can call the close because and call

00:17:15,299 --> 00:17:20,850
and give it a reason which then in turn

00:17:17,370 --> 00:17:23,159
calls the closed message which will in

00:17:20,850 --> 00:17:25,079
turn cause unbind to happen in the whole

00:17:23,159 --> 00:17:27,299
thing begin to shutdown but this is

00:17:25,079 --> 00:17:29,760
called by our software not by event

00:17:27,299 --> 00:17:35,760
machine all these others methods here

00:17:29,760 --> 00:17:38,490
are called by event machine itself so

00:17:35,760 --> 00:17:40,520
let's look at a drone session to create

00:17:38,490 --> 00:17:42,140
it we create a module called drones

00:17:40,520 --> 00:17:43,820
this is weird in an event machine now

00:17:42,140 --> 00:17:45,620
just a number of different ways you can

00:17:43,820 --> 00:17:48,260
do this and we decided to go with the

00:17:45,620 --> 00:17:53,420
module approach you take a module you

00:17:48,260 --> 00:17:56,120
mix in this line text to module and

00:17:53,420 --> 00:17:59,210
that's what allows us to receive lines

00:17:56,120 --> 00:18:00,980
of data rather than packets of data so

00:17:59,210 --> 00:18:04,250
event machine will break that up into

00:18:00,980 --> 00:18:09,290
lines for us the posted NIT this is what

00:18:04,250 --> 00:18:10,910
happens after a connection is made and

00:18:09,290 --> 00:18:13,040
we're ready to start receiving data but

00:18:10,910 --> 00:18:14,840
before we get the first message what we

00:18:13,040 --> 00:18:17,570
want to do is log the fact that we've

00:18:14,840 --> 00:18:19,730
got a new connection kind of log whatta

00:18:17,570 --> 00:18:22,820
IP address it's coming from and then

00:18:19,730 --> 00:18:25,550
also save ourself save this session

00:18:22,820 --> 00:18:27,350
object in a big hash collection based

00:18:25,550 --> 00:18:30,710
upon the connection ID the connection ID

00:18:27,350 --> 00:18:32,450
is a UUID that we generate that is

00:18:30,710 --> 00:18:35,240
unique for every session that gets

00:18:32,450 --> 00:18:37,790
created so we save that we save a

00:18:35,240 --> 00:18:43,250
reference to ourself in a big hash based

00:18:37,790 --> 00:18:48,200
upon the connection ID when we receive a

00:18:43,250 --> 00:18:52,220
line of data the first thing we do is in

00:18:48,200 --> 00:18:54,980
q and q is a private method in the drone

00:18:52,220 --> 00:18:56,810
session that actually sends the data to

00:18:54,980 --> 00:18:58,550
the monitor we'll see that in just a

00:18:56,810 --> 00:19:01,780
second and in queues a message for the

00:18:58,550 --> 00:19:05,510
monitor and it accused a connect message

00:19:01,780 --> 00:19:07,580
unless unless we've already received a

00:19:05,510 --> 00:19:09,140
message so the reason we do this we

00:19:07,580 --> 00:19:11,180
could do this back here in the post an

00:19:09,140 --> 00:19:12,890
it and we did for a while but we found

00:19:11,180 --> 00:19:15,080
that a lot of our hardware devices were

00:19:12,890 --> 00:19:17,090
connecting and never sending anything so

00:19:15,080 --> 00:19:19,010
we've got a lot of stutter on the line

00:19:17,090 --> 00:19:20,930
so we didn't actually send anything to

00:19:19,010 --> 00:19:23,420
the monitor until we actually started

00:19:20,930 --> 00:19:25,370
receiving data so the first time through

00:19:23,420 --> 00:19:27,620
we want to tell the monitor hey we got

00:19:25,370 --> 00:19:30,380
to connect going on here we marked the

00:19:27,620 --> 00:19:33,380
messages received we take the data we

00:19:30,380 --> 00:19:35,710
decode the frame this removes control

00:19:33,380 --> 00:19:39,020
characters and new lines and odd things

00:19:35,710 --> 00:19:41,960
that are inserted in the protocol just

00:19:39,020 --> 00:19:44,390
for transmission purposes deep decodes

00:19:41,960 --> 00:19:48,410
the frame and then the decoded frame

00:19:44,390 --> 00:19:50,720
then is sent as message data - and this

00:19:48,410 --> 00:19:51,770
will internally call in queue with data

00:19:50,720 --> 00:19:53,600
and the decode

00:19:51,770 --> 00:19:55,910
message and that will go to the monitor

00:19:53,600 --> 00:19:58,430
so every time we receive a line from a

00:19:55,910 --> 00:20:01,870
drone we just forward it to the monitor

00:19:58,430 --> 00:20:01,870
that's essentially what we're doing here

00:20:03,340 --> 00:20:09,650
unbind is simple if we've received any

00:20:07,220 --> 00:20:12,620
data whatsoever we go ahead and tell the

00:20:09,650 --> 00:20:14,690
monitor we're disconnecting and then we

00:20:12,620 --> 00:20:16,970
delete ourselves from the global hash

00:20:14,690 --> 00:20:18,620
that references this session since we

00:20:16,970 --> 00:20:23,270
are shutting down we want to make sure

00:20:18,620 --> 00:20:27,620
we remove ourselves from the hash here's

00:20:23,270 --> 00:20:31,280
the private NQ message that takes data

00:20:27,620 --> 00:20:33,200
and serialize it creates a array of

00:20:31,280 --> 00:20:35,780
connection ID and data converts it to

00:20:33,200 --> 00:20:37,640
JSON and then send to monitor that sends

00:20:35,780 --> 00:20:42,230
the data the serialized data to the

00:20:37,640 --> 00:20:46,130
monitors portion of the program so

00:20:42,230 --> 00:20:52,210
that's fairly straightforward all right

00:20:46,130 --> 00:20:52,210
cool questions yeah

00:20:58,160 --> 00:21:03,770
because we only have a two-dimensional

00:20:59,870 --> 00:21:05,540
display for our drones so and and what

00:21:03,770 --> 00:21:07,850
we've discovered in real life if one

00:21:05,540 --> 00:21:10,160
drone is above another the wash from the

00:21:07,850 --> 00:21:12,800
upper drone totally destroys the lower

00:21:10,160 --> 00:21:17,660
drone and in fact they both go careening

00:21:12,800 --> 00:21:19,400
off towards walls so for our purposes

00:21:17,660 --> 00:21:21,380
two dimensions is enough and for this

00:21:19,400 --> 00:21:23,630
demo it's enough so let's go and see

00:21:21,380 --> 00:21:25,910
this at work so I actually wrote up this

00:21:23,630 --> 00:21:28,820
software for real and I got three

00:21:25,910 --> 00:21:32,170
screens here and oh I'm gonna have to

00:21:28,820 --> 00:21:34,580
move this guy over a little bit there

00:21:32,170 --> 00:21:42,530
okay so on the bottom screen I'm going

00:21:34,580 --> 00:21:45,200
to run the drone manager the thing that

00:21:42,530 --> 00:21:46,400
sits between them and passed those

00:21:45,200 --> 00:21:49,040
messages back and forth

00:21:46,400 --> 00:21:51,770
so he started now this is using the

00:21:49,040 --> 00:21:54,320
event machine version up here I'm going

00:21:51,770 --> 00:21:55,730
to start the drone monitor and he goes

00:21:54,320 --> 00:21:56,480
and he blanks the screen because he's

00:21:55,730 --> 00:21:58,940
ready to go

00:21:56,480 --> 00:22:00,970
and over here let's go and let's go

00:21:58,940 --> 00:22:03,440
ahead and let's connect up to this

00:22:00,970 --> 00:22:06,880
monitor manually and just see what

00:22:03,440 --> 00:22:09,650
happens so let's telnet to localhost for

00:22:06,880 --> 00:22:12,920
8090 we've got a connection I'm gonna

00:22:09,650 --> 00:22:16,130
send my position as position five five

00:22:12,920 --> 00:22:18,920
and I can in in frown it allows you to

00:22:16,130 --> 00:22:21,050
abbreviate down to one character so

00:22:18,920 --> 00:22:23,510
there we go the monitor did that

00:22:21,050 --> 00:22:25,550
detected a new drone but he doesn't know

00:22:23,510 --> 00:22:28,100
the name yet so he sent a name question

00:22:25,550 --> 00:22:30,110
marking message back over here and I see

00:22:28,100 --> 00:22:33,460
that in my town that session so oh now I

00:22:30,110 --> 00:22:36,440
gotta tell him his name my name is X and

00:22:33,460 --> 00:22:38,420
I do that and the monitor updates the

00:22:36,440 --> 00:22:40,400
name of the drone just like that now I

00:22:38,420 --> 00:22:43,930
can sit here and I can move the drone

00:22:40,400 --> 00:22:50,210
around like that position five for

00:22:43,930 --> 00:22:52,190
position six six and the monitor just

00:22:50,210 --> 00:22:54,050
updates the position that the drone is

00:22:52,190 --> 00:22:56,930
reporting now that's cool with one drone

00:22:54,050 --> 00:23:00,710
but what if we had more drones laying

00:22:56,930 --> 00:23:04,549
around so I actually have a drone

00:23:00,710 --> 00:23:11,779
program right here let's run that

00:23:04,549 --> 00:23:15,739
Ruby - I live been drone and this will

00:23:11,779 --> 00:23:23,209
be drone a I know it's called Plus drone

00:23:15,739 --> 00:23:25,729
plus in that program once a second will

00:23:23,209 --> 00:23:28,459
update the position and send it out on

00:23:25,729 --> 00:23:29,959
the TCP socket to the server he's

00:23:28,459 --> 00:23:34,639
connected and the monitor picks that up

00:23:29,959 --> 00:23:37,609
and runs that's kind of cool - drones

00:23:34,639 --> 00:23:41,059
are cool how about oh let's let's make

00:23:37,609 --> 00:23:44,829
them crash can I make him crash so he

00:23:41,059 --> 00:23:51,739
looks like he's in about position - five

00:23:44,829 --> 00:23:54,529
position one seven crash yes so notice I

00:23:51,739 --> 00:23:58,309
got the crash message here that means I

00:23:54,529 --> 00:24:00,889
have to disconnect and it says drone X

00:23:58,309 --> 00:24:03,349
disconnected will flip over here and we

00:24:00,889 --> 00:24:07,159
see we got the message drone plus was

00:24:03,349 --> 00:24:12,019
flying drone plus crashed awesome well

00:24:07,159 --> 00:24:16,969
we also have a fly message and let's be

00:24:12,019 --> 00:24:18,559
bold let's start up 20 drones so it's

00:24:16,969 --> 00:24:22,329
just a little script that runs the drone

00:24:18,559 --> 00:24:22,329
program 20 times in the background

00:24:27,520 --> 00:24:33,760
I now want to equip my simulated drones

00:24:29,920 --> 00:24:35,440
with lasers and have them battle it out

00:24:33,760 --> 00:24:37,720
I think that would be fun but so so

00:24:35,440 --> 00:24:39,010
here's here's a framework for that kind

00:24:37,720 --> 00:24:41,230
of thing and this is actually very very

00:24:39,010 --> 00:24:44,470
close to what we did for our client in

00:24:41,230 --> 00:24:46,690
allowing his connections to to be made

00:24:44,470 --> 00:24:48,970
we had a text protocol that we had to

00:24:46,690 --> 00:24:50,890
use we had to respond all the messages

00:24:48,970 --> 00:24:53,650
pass them on to the queuing mechanism so

00:24:50,890 --> 00:24:56,500
it got into our database and very very

00:24:53,650 --> 00:24:59,440
similar to what we're doing here but let

00:24:56,500 --> 00:25:02,460
that run long enough eventually all the

00:24:59,440 --> 00:25:04,510
clone of the drones will crash because

00:25:02,460 --> 00:25:06,220
they're just doing a random walk and

00:25:04,510 --> 00:25:10,690
they will crash eventually let's just

00:25:06,220 --> 00:25:16,810
leave that run for a while let's go back

00:25:10,690 --> 00:25:18,670
to our slides so that's the demo so what

00:25:16,810 --> 00:25:22,240
do we like and what do we not like about

00:25:18,670 --> 00:25:24,790
this particular solution well number one

00:25:22,240 --> 00:25:26,920
it handles a bazillion connections we

00:25:24,790 --> 00:25:29,800
really can't truly handle a thousand

00:25:26,920 --> 00:25:32,230
connections with our application and we

00:25:29,800 --> 00:25:35,290
do that we did stress tests on it and we

00:25:32,230 --> 00:25:37,300
had a thousand we didn't actually have

00:25:35,290 --> 00:25:38,950
the real hardware devices but we did

00:25:37,300 --> 00:25:41,500
simulate a thousand hardware devices

00:25:38,950 --> 00:25:43,810
coming in to our servers and we handle

00:25:41,500 --> 00:25:46,960
it quite readily there was not a problem

00:25:43,810 --> 00:25:49,840
doing this in Ruby using a vent machine

00:25:46,960 --> 00:25:51,700
it was mainly IO bound anyway so the

00:25:49,840 --> 00:25:53,170
Ruby processing was minimal Ruby just

00:25:51,700 --> 00:25:53,650
got out of the way and let the data flow

00:25:53,170 --> 00:25:55,450
through it

00:25:53,650 --> 00:25:58,270
and it was a very easy solution like I

00:25:55,450 --> 00:26:00,460
said we had a 10x savings in the number

00:25:58,270 --> 00:26:01,990
of lines over the Java solution and the

00:26:00,460 --> 00:26:04,360
Java solution the Ruby solution were

00:26:01,990 --> 00:26:06,460
very similar they were both a vented

00:26:04,360 --> 00:26:08,470
solutions the Java system had a little

00:26:06,460 --> 00:26:11,110
more smarts in it that did some extra

00:26:08,470 --> 00:26:12,490
handling of the messages but not that

00:26:11,110 --> 00:26:14,980
much that I think it throws the

00:26:12,490 --> 00:26:16,480
comparison out of whack other thing we'd

00:26:14,980 --> 00:26:18,550
like is the whole thing is single

00:26:16,480 --> 00:26:21,220
threaded I don't have to worry about

00:26:18,550 --> 00:26:22,900
locks I don't have to worry about mutual

00:26:21,220 --> 00:26:25,090
exclusion I don't have to worry about

00:26:22,900 --> 00:26:27,430
race conditions because the whole thing

00:26:25,090 --> 00:26:29,440
runs in a single thread and that makes

00:26:27,430 --> 00:26:31,390
programming it really really easy and

00:26:29,440 --> 00:26:34,330
this is one of the nice things about a

00:26:31,390 --> 00:26:36,520
vented programming one of the things I

00:26:34,330 --> 00:26:41,340
don't like about this solution is that

00:26:36,520 --> 00:26:45,629
it's single threaded yeah you know it's

00:26:41,340 --> 00:26:47,190
it's a blessing and a curse if it's

00:26:45,629 --> 00:26:49,679
single-threaded that means it cannot

00:26:47,190 --> 00:26:52,970
take advantage of all the cores that I

00:26:49,679 --> 00:26:55,620
have on my system my laptop here has

00:26:52,970 --> 00:26:56,940
four cores and they're hyper threaded so

00:26:55,620 --> 00:27:00,179
essentially it could have eight things

00:26:56,940 --> 00:27:01,980
going on at once and out of those eight

00:27:00,179 --> 00:27:04,590
I can use one-eighth of the entire

00:27:01,980 --> 00:27:06,840
processing power of my laptop to do this

00:27:04,590 --> 00:27:09,360
now on an i/o bound system that knot

00:27:06,840 --> 00:27:13,289
might not make a difference but on other

00:27:09,360 --> 00:27:14,999
situations that might be a big deal the

00:27:13,289 --> 00:27:17,879
other thing I don't really like about it

00:27:14,999 --> 00:27:20,369
is that you have to warp your mind into

00:27:17,879 --> 00:27:21,899
this whole event and style of

00:27:20,369 --> 00:27:25,139
programming and it's a little bit

00:27:21,899 --> 00:27:27,570
different for example here's a program I

00:27:25,139 --> 00:27:29,519
didn't show you earlier but here's when

00:27:27,570 --> 00:27:34,499
someone requests our drone session to

00:27:29,519 --> 00:27:36,149
shut down we go and we log the reason

00:27:34,499 --> 00:27:38,490
he's being shut down and then we set a

00:27:36,149 --> 00:27:40,590
timer for five seconds and you say okay

00:27:38,490 --> 00:27:42,779
in five seconds close the connection

00:27:40,590 --> 00:27:44,610
that'll let any outgoing messages get

00:27:42,779 --> 00:27:46,019
out of the way and lets it quiet down a

00:27:44,610 --> 00:27:49,679
little bit before we actually do the

00:27:46,019 --> 00:27:50,549
shutdown so this close connection is a

00:27:49,679 --> 00:27:52,460
callback

00:27:50,549 --> 00:27:55,350
everything that happens asynchronously

00:27:52,460 --> 00:27:58,710
in an invented program has to be put

00:27:55,350 --> 00:28:02,820
into a callback to be called later now

00:27:58,710 --> 00:28:04,590
this is not bad but if you had something

00:28:02,820 --> 00:28:06,509
like this so the timer needs to do

00:28:04,590 --> 00:28:08,159
something and that something is also

00:28:06,509 --> 00:28:09,869
asynchronous and when it's done it's got

00:28:08,159 --> 00:28:12,509
to return a result then you have to make

00:28:09,869 --> 00:28:14,220
a decision off that result that to do

00:28:12,509 --> 00:28:16,230
something or something else and those

00:28:14,220 --> 00:28:19,710
are event and you have this crazy crazy

00:28:16,230 --> 00:28:21,720
crazy nested callback scenario and and

00:28:19,710 --> 00:28:25,470
there's actually a name for this thing

00:28:21,720 --> 00:28:27,029
it's called callback spaghetti and if

00:28:25,470 --> 00:28:28,740
you're not careful your programs will

00:28:27,029 --> 00:28:31,470
suffer from this now there's techniques

00:28:28,740 --> 00:28:32,820
to get around it but you know it's it's

00:28:31,470 --> 00:28:34,799
something that you have to manage and

00:28:32,820 --> 00:28:37,110
it's a different way of thinking than

00:28:34,799 --> 00:28:41,960
the straightforward linear thought that

00:28:37,110 --> 00:28:45,830
we're used to programming in normally

00:28:41,960 --> 00:28:45,830
how dislike it in here

00:28:46,110 --> 00:28:52,960
okay so why why don't I just write a

00:28:51,190 --> 00:28:54,370
threaded program man what's the problem

00:28:52,960 --> 00:28:56,050
with writing threaded program so real

00:28:54,370 --> 00:28:58,360
quick you probably all know this anyways

00:28:56,050 --> 00:29:00,040
but let's just discuss the scenarios the

00:28:58,360 --> 00:29:02,559
problem of threading is that when two

00:29:00,040 --> 00:29:04,900
threads share mutable data and try to

00:29:02,559 --> 00:29:08,650
change the data you have the possibility

00:29:04,900 --> 00:29:10,720
of a race condition if you don't

00:29:08,650 --> 00:29:12,429
carefully control how that shared data

00:29:10,720 --> 00:29:17,559
is updated you're going to run into

00:29:12,429 --> 00:29:19,570
problems you know missing updates or

00:29:17,559 --> 00:29:21,340
inconsistent updates or something's not

00:29:19,570 --> 00:29:22,660
going to happen now there's a couple of

00:29:21,340 --> 00:29:24,670
things you can do you can say well

00:29:22,660 --> 00:29:26,710
forget it let's just use a single thread

00:29:24,670 --> 00:29:28,900
but we already talked about the problems

00:29:26,710 --> 00:29:29,890
with that you get this kind of chart on

00:29:28,900 --> 00:29:33,280
your Activity Monitor

00:29:29,890 --> 00:29:36,850
I produced this chart by saying loop do

00:29:33,280 --> 00:29:41,500
end in IRB and that's exactly what you

00:29:36,850 --> 00:29:44,980
get you can write locks around your

00:29:41,500 --> 00:29:46,330
shared data the problem was this I mean

00:29:44,980 --> 00:29:47,620
this is a standard thing and everybody

00:29:46,330 --> 00:29:49,600
knows how to do this if you've done any

00:29:47,620 --> 00:29:51,370
threaded programming at all but the

00:29:49,600 --> 00:29:53,320
problem with this is it requires

00:29:51,370 --> 00:29:56,260
cooperation from all the threads if you

00:29:53,320 --> 00:29:58,630
forget to access the lock to acquire the

00:29:56,260 --> 00:29:59,640
lock before you mutate the data you're

00:29:58,630 --> 00:30:03,490
screwed

00:29:59,640 --> 00:30:05,500
you also this solution doesn't compose

00:30:03,490 --> 00:30:11,280
it's difficult to hide the fact you're

00:30:05,500 --> 00:30:13,300
using a lock inside of inside a module

00:30:11,280 --> 00:30:14,800
it's hard to hide it because there are

00:30:13,300 --> 00:30:17,350
different things that might need to be

00:30:14,800 --> 00:30:20,140
atomic together and it's just really

00:30:17,350 --> 00:30:23,080
hard to compose lock based solutions and

00:30:20,140 --> 00:30:25,510
you run the risk of getting deadlocks I

00:30:23,080 --> 00:30:27,220
this thread could lock a resource that

00:30:25,510 --> 00:30:28,780
started could lock a resource and then

00:30:27,220 --> 00:30:30,670
they each try to get the resource that

00:30:28,780 --> 00:30:32,380
the other guy has that's a deadlock

00:30:30,670 --> 00:30:34,720
condition they can't proceed from that

00:30:32,380 --> 00:30:38,320
and that's a real danger in threaded

00:30:34,720 --> 00:30:40,840
programs ok so maybe we can solve it by

00:30:38,320 --> 00:30:43,090
not sharing data it's a problem shared

00:30:40,840 --> 00:30:45,250
mutable data then let's not share our

00:30:43,090 --> 00:30:47,470
mutable data and that leads to well one

00:30:45,250 --> 00:30:49,540
solution is a process scenario and this

00:30:47,470 --> 00:30:52,390
is hotting unit what UNIX does you just

00:30:49,540 --> 00:30:54,309
run multiple processes to get each their

00:30:52,390 --> 00:30:57,010
own mutable state and they never share

00:30:54,309 --> 00:30:58,240
it so there's no problem and if you want

00:30:57,010 --> 00:30:58,870
to communicate to use something like

00:30:58,240 --> 00:31:01,060
message

00:30:58,870 --> 00:31:03,940
Q's or something between the two the

00:31:01,060 --> 00:31:06,460
problem with this scenario rails works a

00:31:03,940 --> 00:31:08,980
lot these days we scale rails across

00:31:06,460 --> 00:31:11,410
multiple CPUs by just running a lot of

00:31:08,980 --> 00:31:13,360
rails processes probably this it's

00:31:11,410 --> 00:31:15,910
rather heavy weight that's an entire

00:31:13,360 --> 00:31:19,930
UNIX process you're using just to get

00:31:15,910 --> 00:31:22,060
that that parallelism it uses up a lot

00:31:19,930 --> 00:31:24,310
of memory because each process has its

00:31:22,060 --> 00:31:28,480
own memory and that can be alleviated to

00:31:24,310 --> 00:31:30,850
a degree by copy and write solutions and

00:31:28,480 --> 00:31:32,560
things like that but it's still using up

00:31:30,850 --> 00:31:34,570
memory and communication between the

00:31:32,560 --> 00:31:37,420
processes is difficult if you need a lot

00:31:34,570 --> 00:31:42,940
of communication this is a hard thing to

00:31:37,420 --> 00:31:45,520
do here's a solution that closure uses

00:31:42,940 --> 00:31:50,100
if shared mutable data is the problem

00:31:45,520 --> 00:31:52,690
let's use immutable data and this works

00:31:50,100 --> 00:31:55,990
closure is a functional language it does

00:31:52,690 --> 00:31:57,790
not mutate its variables by default so

00:31:55,990 --> 00:31:59,800
it's very easy to share data between two

00:31:57,790 --> 00:32:01,720
closure threads and not have a problem

00:31:59,800 --> 00:32:03,430
because you don't ever change the data

00:32:01,720 --> 00:32:05,710
you just rebind variables and that's a

00:32:03,430 --> 00:32:08,280
local thing it doesn't affect the

00:32:05,710 --> 00:32:10,330
threads if you do want to share data

00:32:08,280 --> 00:32:13,270
closure says let's put it in a

00:32:10,330 --> 00:32:17,560
transactional a software transactional

00:32:13,270 --> 00:32:19,690
memory cell and this is a special thing

00:32:17,560 --> 00:32:20,680
that is guaranteed to be atomic when you

00:32:19,690 --> 00:32:22,330
change it there's all kinds of

00:32:20,680 --> 00:32:24,520
mechanisms to make that whole thing work

00:32:22,330 --> 00:32:26,140
but if you need to share will use this

00:32:24,520 --> 00:32:29,290
special thing otherwise the default is

00:32:26,140 --> 00:32:31,150
to not mutate our data and and closure

00:32:29,290 --> 00:32:33,970
actually has a very very very good story

00:32:31,150 --> 00:32:37,630
for parallelism and I'm very envious of

00:32:33,970 --> 00:32:40,420
them for that reason Erlang says okay we

00:32:37,630 --> 00:32:42,580
won't mutate and we won't share so all

00:32:40,420 --> 00:32:45,100
communication in Erlang happens between

00:32:42,580 --> 00:32:47,140
threads by putting little tiny messages

00:32:45,100 --> 00:32:49,300
on a message queue and then the thread

00:32:47,140 --> 00:32:50,710
here sets and reads its mailboxes okay

00:32:49,300 --> 00:32:53,740
now I'm doing this now I'm doing this

00:32:50,710 --> 00:32:55,390
now I'm doing this so within the thread

00:32:53,740 --> 00:32:58,090
within the process of an interline

00:32:55,390 --> 00:33:01,540
process he is handling one message at a

00:32:58,090 --> 00:33:03,430
time but parallelism is going on because

00:33:01,540 --> 00:33:05,590
the communication is by message back and

00:33:03,430 --> 00:33:10,480
forth between processes and that turns

00:33:05,590 --> 00:33:13,200
out to be a really good model so what

00:33:10,480 --> 00:33:15,730
what works well with Ruby

00:33:13,200 --> 00:33:17,920
I'd like to talk a little bit about

00:33:15,730 --> 00:33:21,880
something called celluloid celluloid is

00:33:17,920 --> 00:33:23,770
a library written by Tony a CRE I

00:33:21,880 --> 00:33:27,810
believe his name that's how you say his

00:33:23,770 --> 00:33:32,010
name and celluloid is an Erlang like

00:33:27,810 --> 00:33:34,600
actor based solution for threading

00:33:32,010 --> 00:33:38,560
here's example right out of the

00:33:34,600 --> 00:33:41,740
celluloid page we're creating a class

00:33:38,560 --> 00:33:44,320
called Sheen we include celluloid and

00:33:41,740 --> 00:33:47,890
that turns this class into a celluloid

00:33:44,320 --> 00:33:51,190
actor that means when you call methods

00:33:47,890 --> 00:33:53,350
on the celluloid actor these messages

00:33:51,190 --> 00:33:56,710
actually when you call this it actually

00:33:53,350 --> 00:33:59,500
sends a message into the mailbox of the

00:33:56,710 --> 00:34:01,420
celluloid actor the actor pulls that

00:33:59,500 --> 00:34:03,970
message off and cause the internal

00:34:01,420 --> 00:34:06,460
objects method and then returns result

00:34:03,970 --> 00:34:09,130
by another message going back if you

00:34:06,460 --> 00:34:11,770
want to you can say async and that does

00:34:09,130 --> 00:34:14,200
the same thing but does not wait for the

00:34:11,770 --> 00:34:16,390
return message so you can do you can say

00:34:14,200 --> 00:34:19,000
go off and do this and whatever you get

00:34:16,390 --> 00:34:20,290
around to it that's fine I'm going to go

00:34:19,000 --> 00:34:22,780
off and do something else while you're

00:34:20,290 --> 00:34:25,060
processing that message and then here

00:34:22,780 --> 00:34:27,010
the report returns the status so this

00:34:25,060 --> 00:34:28,840
will set the status this will cue up

00:34:27,010 --> 00:34:30,880
another message so once this one's

00:34:28,840 --> 00:34:32,919
handled this report goes in and gets the

00:34:30,880 --> 00:34:35,950
result of that it's a very very very

00:34:32,919 --> 00:34:38,470
nice system for handling parallelism now

00:34:35,950 --> 00:34:41,679
the beauty of this is that within an

00:34:38,470 --> 00:34:43,570
actor within a celluloid actor it's a

00:34:41,679 --> 00:34:45,390
single thread processing all that data

00:34:43,570 --> 00:34:48,040
so you don't have to worry about walking

00:34:45,390 --> 00:34:49,179
parallelism happens between actors and

00:34:48,040 --> 00:34:51,400
you have the choice of doing it

00:34:49,179 --> 00:34:55,210
synchronously or asynchronously style

00:34:51,400 --> 00:35:00,840
communication between the two so what if

00:34:55,210 --> 00:35:00,840
we use celluloid for our drone solution

00:35:02,340 --> 00:35:09,400
problem is that in celluloid every actor

00:35:05,710 --> 00:35:12,340
is its own thread and all those threads

00:35:09,400 --> 00:35:15,550
are not nearly as expensive as processes

00:35:12,340 --> 00:35:17,500
they are still rather you know they're

00:35:15,550 --> 00:35:19,540
more heavyweight than just a regular

00:35:17,500 --> 00:35:22,420
object there's a staff has to be

00:35:19,540 --> 00:35:23,110
allocated for each thread and and all

00:35:22,420 --> 00:35:25,570
that so

00:35:23,110 --> 00:35:25,960
so this creating a celluloid actor

00:35:25,570 --> 00:35:28,510
forever

00:35:25,960 --> 00:35:29,710
drone out there not really a realistic

00:35:28,510 --> 00:35:31,680
solution if you want to get up to a

00:35:29,710 --> 00:35:35,710
thousand drones

00:35:31,680 --> 00:35:37,680
however surprise the folks who wrote

00:35:35,710 --> 00:35:42,280
celluloid know this and they said okay

00:35:37,680 --> 00:35:44,470
let's take this actor model and the way

00:35:42,280 --> 00:35:47,080
we interact with the world and let's

00:35:44,470 --> 00:35:49,690
take a vented programming and combine

00:35:47,080 --> 00:35:52,810
the two so that internally on a

00:35:49,690 --> 00:35:55,210
celluloid I Oh after the whole thing is

00:35:52,810 --> 00:35:57,490
a vented but you interact with it like a

00:35:55,210 --> 00:36:01,540
regular celluloid after so you can't

00:35:57,490 --> 00:36:04,660
tell the difference so celluloid IO

00:36:01,540 --> 00:36:07,780
provides fast event-driven IO it wraps

00:36:04,660 --> 00:36:09,339
all the IO in celluloid like actors so

00:36:07,780 --> 00:36:11,880
you can't tell you're even using a

00:36:09,339 --> 00:36:14,650
vented programming and then provides

00:36:11,880 --> 00:36:18,010
duct-tape socket classes so that you use

00:36:14,650 --> 00:36:19,150
regular TCP socket calls in your program

00:36:18,010 --> 00:36:21,250
like you would in a single-threaded

00:36:19,150 --> 00:36:23,470
program and you're doing a vented i/o

00:36:21,250 --> 00:36:27,700
and you don't even know it it hides the

00:36:23,470 --> 00:36:29,890
advented nature of your IO from you so

00:36:27,700 --> 00:36:32,349
how would the drone session we'll call

00:36:29,890 --> 00:36:35,080
it a drone cell now look like in

00:36:32,349 --> 00:36:36,849
celluloid we create the class we include

00:36:35,080 --> 00:36:39,940
the celluloid IO to turn it into an IO

00:36:36,849 --> 00:36:42,520
after we initialize the thing we capture

00:36:39,940 --> 00:36:44,950
the monitor we create a tcpi server now

00:36:42,520 --> 00:36:46,660
we're using regular TCP IP server calls

00:36:44,950 --> 00:36:48,460
just like you would in a single threaded

00:36:46,660 --> 00:36:52,830
thing the difference is that this is

00:36:48,460 --> 00:36:56,320
actually a celluloid IO tcp/ip server

00:36:52,830 --> 00:36:58,839
that knows about a vent at i/o and will

00:36:56,320 --> 00:37:00,369
do that under the covers we store the

00:36:58,839 --> 00:37:03,099
server for that we store an array of

00:37:00,369 --> 00:37:08,950
drones here and then we say run bang and

00:37:03,099 --> 00:37:11,050
here is run there is rotten ok run is

00:37:08,950 --> 00:37:14,020
just an infinite loop that handles

00:37:11,050 --> 00:37:16,330
incoming connections now notice we call

00:37:14,020 --> 00:37:19,869
it run bang and here we're calling it

00:37:16,330 --> 00:37:22,240
just regular run cellulite io objects if

00:37:19,869 --> 00:37:24,930
you call it with a bang method is kind

00:37:22,240 --> 00:37:28,060
of like saying to the event loop

00:37:24,930 --> 00:37:30,160
schedule the run method to run next to

00:37:28,060 --> 00:37:32,260
please after I'm done run it

00:37:30,160 --> 00:37:34,030
asynchronously and if whatever I'm done

00:37:32,260 --> 00:37:39,609
cue that up in the event loop so it

00:37:34,030 --> 00:37:42,910
happens next so in so this will happen

00:37:39,609 --> 00:37:45,640
after after our initialize is done run

00:37:42,910 --> 00:37:47,079
will be queued up to be ready to run he

00:37:45,640 --> 00:37:50,019
will go into an infinite loop and

00:37:47,079 --> 00:37:52,630
whenever the server object detects an

00:37:50,019 --> 00:37:54,459
incoming connection he will call handle

00:37:52,630 --> 00:37:57,999
connection bang so handle connection

00:37:54,459 --> 00:38:00,309
will be queued up to run next and here's

00:37:57,999 --> 00:38:02,739
handle connection this is how we handle

00:38:00,309 --> 00:38:05,619
an incoming connection we'll get a

00:38:02,739 --> 00:38:07,150
socket we're gonna wrap the socket at a

00:38:05,619 --> 00:38:08,920
line protocol because we want to read it

00:38:07,150 --> 00:38:11,229
line by line and sockets don't have a

00:38:08,920 --> 00:38:12,489
nice line by line interface for it so we

00:38:11,229 --> 00:38:14,849
write a little wrapper around it to

00:38:12,489 --> 00:38:17,920
provide that to us we'll call that iOS

00:38:14,849 --> 00:38:19,930
well remember the IRS object in our

00:38:17,920 --> 00:38:22,269
array of drones and remember this is an

00:38:19,930 --> 00:38:26,499
internal object it's no longer a global

00:38:22,269 --> 00:38:28,839
one well generate our UUID we will tell

00:38:26,499 --> 00:38:32,019
the monitor that we're connected to it

00:38:28,839 --> 00:38:33,910
this sends the connect message we then

00:38:32,019 --> 00:38:37,059
go into an infinite loop to handle data

00:38:33,910 --> 00:38:39,640
from the drone read a line of data

00:38:37,059 --> 00:38:41,589
decode it send it to the monitor loop

00:38:39,640 --> 00:38:45,339
back read a line a data decode at sent

00:38:41,589 --> 00:38:48,279
as a monitor data read decode write read

00:38:45,339 --> 00:38:50,890
dqo write over and over and over this is

00:38:48,279 --> 00:38:52,449
exactly the process that we're doing for

00:38:50,890 --> 00:38:54,729
handling a drone and notice we're doing

00:38:52,449 --> 00:38:56,380
it in a regular loop we don't have to

00:38:54,729 --> 00:38:59,199
worry about callbacks we don't have to

00:38:56,380 --> 00:39:01,869
worry about when is this going to run we

00:38:59,199 --> 00:39:04,150
just write straight line logic like

00:39:01,869 --> 00:39:06,999
we're used to writing in a single

00:39:04,150 --> 00:39:08,859
threaded application and all the

00:39:06,999 --> 00:39:12,969
invented nature of that is hidden behind

00:39:08,859 --> 00:39:15,849
us yeah and I highlighted these things

00:39:12,969 --> 00:39:18,579
in red too I keep forgetting yeah

00:39:15,849 --> 00:39:20,699
Oh notice here the a safe call so that

00:39:18,579 --> 00:39:23,380
when we send the data to the monitor

00:39:20,699 --> 00:39:25,329
we're doing it so here's your data I

00:39:23,380 --> 00:39:27,309
don't know if the monitor is ready to

00:39:25,329 --> 00:39:29,170
accept this data or not but I don't care

00:39:27,309 --> 00:39:30,759
I'm gonna send the data then I'm gonna

00:39:29,170 --> 00:39:33,099
immediately return so I can get my next

00:39:30,759 --> 00:39:35,920
little bit of drone data to send us a

00:39:33,099 --> 00:39:38,289
monitor again so this will this will

00:39:35,920 --> 00:39:40,089
send it to the mailbox on the monitor

00:39:38,289 --> 00:39:42,489
after the monitor actor has a similar

00:39:40,089 --> 00:39:46,930
loop sitting there reading them incoming

00:39:42,489 --> 00:39:48,519
messages and handling them okay what we

00:39:46,930 --> 00:39:50,979
like about the solution there are no

00:39:48,519 --> 00:39:52,310
callbacks it's straight in line regular

00:39:50,979 --> 00:39:55,430
logic and all our code

00:39:52,310 --> 00:39:58,820
it uses the standard tcp/ip sockets or

00:39:55,430 --> 00:40:00,620
closed analogs to those that are really

00:39:58,820 --> 00:40:03,650
a vented under the surface we just can't

00:40:00,620 --> 00:40:06,950
tell you have all the invented

00:40:03,650 --> 00:40:10,550
efficiency under the hood without having

00:40:06,950 --> 00:40:12,350
to write event code and we're all of a

00:40:10,550 --> 00:40:15,530
sudden using all the cords because these

00:40:12,350 --> 00:40:16,970
are threads now it's not a single

00:40:15,530 --> 00:40:18,950
threaded solution this is a multiple

00:40:16,970 --> 00:40:21,350
threaded solution and now we can take

00:40:18,950 --> 00:40:24,170
advantage of all of our threads now

00:40:21,350 --> 00:40:26,540
caveat here you guys know that there's a

00:40:24,170 --> 00:40:28,910
global interpreter lock in regular Ruby

00:40:26,540 --> 00:40:31,220
right so that means when you're running

00:40:28,910 --> 00:40:34,370
Ruby code only you only run on one

00:40:31,220 --> 00:40:38,270
process at a time however that's not

00:40:34,370 --> 00:40:40,130
true in either Rubinius or in JRuby so

00:40:38,270 --> 00:40:42,670
if you want to really take advantage of

00:40:40,130 --> 00:40:45,380
this system with threads

00:40:42,670 --> 00:40:52,760
rubinius or JRuby are good solutions to

00:40:45,380 --> 00:40:54,140
play with that okay demo again and I

00:40:52,760 --> 00:40:56,510
think I got about ten minutes is that

00:40:54,140 --> 00:40:58,790
right yeah okay awesome

00:40:56,510 --> 00:41:00,350
we're working out about right let's go

00:40:58,790 --> 00:41:02,330
back to our demo and look all our

00:41:00,350 --> 00:41:04,850
Chrome's have crashed they're not

00:41:02,330 --> 00:41:11,680
surprised let's go down here let's kill

00:41:04,850 --> 00:41:16,820
our server and let's see here

00:41:11,680 --> 00:41:24,680
oops bring this guy down a bit here

00:41:16,820 --> 00:41:26,630
resize him okay so rather than running

00:41:24,680 --> 00:41:28,640
during messages I got drone celluloid

00:41:26,630 --> 00:41:31,340
this is the same drone manager that we

00:41:28,640 --> 00:41:35,240
saw before but written using celluloid

00:41:31,340 --> 00:41:37,880
rather than a vent IO will fire him up

00:41:35,240 --> 00:41:39,320
here I'm gonna start our server this is

00:41:37,880 --> 00:41:41,390
the same server I didn't rewrite the

00:41:39,320 --> 00:41:43,790
server at all he doesn't care what kind

00:41:41,390 --> 00:41:46,790
of excuse me this is the same monitor he

00:41:43,790 --> 00:41:50,150
doesn't care what the managers written

00:41:46,790 --> 00:41:50,510
in invented IO or celluloid he doesn't

00:41:50,150 --> 00:41:52,070
care

00:41:50,510 --> 00:41:54,140
so he's going to be the same thing and

00:41:52,070 --> 00:41:56,510
he's running now in a clear screen let's

00:41:54,140 --> 00:42:00,400
go over here let's just run a bunch

00:41:56,510 --> 00:42:00,400
let's run 60 drones

00:42:04,590 --> 00:42:08,860
populate some begins to find the name of

00:42:07,030 --> 00:42:11,740
each of the drones they begin crashing

00:42:08,860 --> 00:42:13,060
all over the place but it's working

00:42:11,740 --> 00:42:25,590
quite well actually

00:42:13,060 --> 00:42:25,590
I'm quite happy with that cool awesome

00:42:26,880 --> 00:42:31,230
we'll let that one run for a while too

00:42:35,589 --> 00:42:40,749
okay invented IO celluloid IO so summary

00:42:38,650 --> 00:42:42,699
what did we learn well number one we

00:42:40,749 --> 00:42:44,920
learned that Ruby is not a one-trick

00:42:42,699 --> 00:42:46,959
horse you can use Ruby for a lot of

00:42:44,920 --> 00:42:49,089
applications and I think the use of

00:42:46,959 --> 00:42:51,130
celluloid really really really opens up

00:42:49,089 --> 00:42:52,930
the possibilities of using rubies in

00:42:51,130 --> 00:42:55,209
environments where we might not have

00:42:52,930 --> 00:42:56,469
thought about using Ruby before I'm sure

00:42:55,209 --> 00:42:58,180
the guys that when they wrote the

00:42:56,469 --> 00:43:00,160
original Java versions of these hardware

00:42:58,180 --> 00:43:02,739
managers didn't even think Ruby had the

00:43:00,160 --> 00:43:04,239
the capability of doing that but because

00:43:02,739 --> 00:43:05,619
we decided to take a chance we

00:43:04,239 --> 00:43:10,569
discovered it did and actually worked

00:43:05,619 --> 00:43:13,209
very very well for doing that Ruby has a

00:43:10,569 --> 00:43:14,559
reasonable multi-threaded solution now I

00:43:13,209 --> 00:43:16,930
don't think it's as good as closure

00:43:14,559 --> 00:43:18,880
closure has an awesome solution but the

00:43:16,930 --> 00:43:21,099
route the celluloid solution in Ruby is

00:43:18,880 --> 00:43:24,039
actually very reasonable because you

00:43:21,099 --> 00:43:26,469
limit the interaction to between actors

00:43:24,039 --> 00:43:28,299
and within an actor you don't your your

00:43:26,469 --> 00:43:29,199
a single thread what's in an actor so

00:43:28,299 --> 00:43:32,259
you don't have to worry about locking

00:43:29,199 --> 00:43:34,089
within the thread you reduce the surface

00:43:32,259 --> 00:43:36,069
area of stuff you have to worry about

00:43:34,089 --> 00:43:39,309
when you're writing multi-threaded code

00:43:36,069 --> 00:43:42,009
so the actor model is a very very good

00:43:39,309 --> 00:43:44,319
solution for Ruby without radically

00:43:42,009 --> 00:43:46,420
changing the language to be immutable

00:43:44,319 --> 00:43:48,579
like closure is I think this is probably

00:43:46,420 --> 00:43:51,279
about the best we're gonna get for

00:43:48,579 --> 00:43:53,319
multi-threaded in in Ruby that's awesome

00:43:51,279 --> 00:43:59,019
and we also learned that flying robots

00:43:53,319 --> 00:44:04,779
are a lot of fun yeah yay so is this

00:43:59,019 --> 00:44:06,549
really practical in Ruby and I want to

00:44:04,779 --> 00:44:10,390
introduce you to a brand new library

00:44:06,549 --> 00:44:12,880
that just came out last week in fact it

00:44:10,390 --> 00:44:14,709
was announced last week at the LA Ruby

00:44:12,880 --> 00:44:16,569
conf and I was sitting there and I was

00:44:14,709 --> 00:44:18,069
talking to Ron Evans I said Ron you've

00:44:16,569 --> 00:44:19,900
got to see these videos I have on my

00:44:18,069 --> 00:44:22,979
flying drone and how I'm doing

00:44:19,900 --> 00:44:26,140
talking to it with Ruby he says Jim

00:44:22,979 --> 00:44:28,529
don't say a word wait two and a half

00:44:26,140 --> 00:44:28,529
hours

00:44:29,110 --> 00:44:33,910
so Ron did the closing keynote at the

00:44:31,450 --> 00:44:38,110
conference and he got up and he

00:44:33,910 --> 00:44:41,170
introduced the r2 library r2 is a micro

00:44:38,110 --> 00:44:44,260
framework for robotics written in Ruby

00:44:41,170 --> 00:44:47,610
it supports talking to Arduino sphero's

00:44:44,260 --> 00:44:50,770
and done at the Tom parrot ar.drone twos

00:44:47,610 --> 00:44:53,140
excellent that's exciting and your arm

00:44:50,770 --> 00:44:57,160
is based on celluloid and celluloid IO

00:44:53,140 --> 00:45:02,170
so it uses that solution there here's an

00:44:57,160 --> 00:45:06,310
example of actually flying a robot by

00:45:02,170 --> 00:45:10,330
the wire using our to create some

00:45:06,310 --> 00:45:13,030
connections here tell the drove to start

00:45:10,330 --> 00:45:15,370
till the drone to take off after 25

00:45:13,030 --> 00:45:16,990
seconds do this after 30 seconds do that

00:45:15,370 --> 00:45:19,740
and loop you could write this more

00:45:16,990 --> 00:45:23,260
straight line if you wanted to and

00:45:19,740 --> 00:45:24,250
here's a picture of this is run clear

00:45:23,260 --> 00:45:27,250
over they are you standing in front of

00:45:24,250 --> 00:45:29,200
the laptop they have a bunch of hero

00:45:27,250 --> 00:45:30,940
robots I don't know if you've ever seen

00:45:29,200 --> 00:45:33,760
this pharaoh robots the little round

00:45:30,940 --> 00:45:37,000
balls and they roll around they're

00:45:33,760 --> 00:45:39,880
controlled by a Bluetooth connection and

00:45:37,000 --> 00:45:42,640
they change colors so he set seven of

00:45:39,880 --> 00:45:44,560
these balls on a table ran an hour to

00:45:42,640 --> 00:45:46,900
program that talk to each of the balls

00:45:44,560 --> 00:45:48,340
and made them and then he ran and when

00:45:46,900 --> 00:45:51,220
they would hit each other they would

00:45:48,340 --> 00:45:53,410
change colors so it was an awesome

00:45:51,220 --> 00:45:55,180
little demo these balls randomly rolling

00:45:53,410 --> 00:45:56,500
all along the table changing directions

00:45:55,180 --> 00:45:57,880
in random directions when they would

00:45:56,500 --> 00:46:00,940
strike each other they would change

00:45:57,880 --> 00:46:05,350
colors it was a lot of fun so that was

00:46:00,940 --> 00:46:06,910
that they also demonstrated this and I'm

00:46:05,350 --> 00:46:09,340
going to show you a video of this okay I

00:46:06,910 --> 00:46:13,360
really wished I could bring my drone

00:46:09,340 --> 00:46:14,560
here and fly it for you but that didn't

00:46:13,360 --> 00:46:16,480
happen I didn't have enough time to get

00:46:14,560 --> 00:46:19,030
things set up but I'm gonna show you a

00:46:16,480 --> 00:46:22,780
video of this this is they took the r2

00:46:19,030 --> 00:46:26,800
based library and wrote a program that

00:46:22,780 --> 00:46:28,480
talked to a Wii controller and took

00:46:26,800 --> 00:46:30,670
button presses from the Wii controller

00:46:28,480 --> 00:46:34,000
ran it in the program then it would send

00:46:30,670 --> 00:46:37,060
out commands to the ar.drone and they

00:46:34,000 --> 00:46:39,160
flew it through the controller going

00:46:37,060 --> 00:46:41,650
using the r2 program to send the

00:46:39,160 --> 00:46:44,340
commands out to the ar.drone so let's

00:46:41,650 --> 00:46:44,340
see that happen

00:47:00,510 --> 00:47:04,060
when I turn off the sound because you

00:47:02,530 --> 00:47:06,640
guys probably can't hear it anyways but

00:47:04,060 --> 00:47:12,010
there it is they're flying it totally

00:47:06,640 --> 00:47:12,670
under the control of Ruby and that is

00:47:12,010 --> 00:47:14,950
cool

00:47:12,670 --> 00:47:16,750
they said the responsiveness actually

00:47:14,950 --> 00:47:18,280
they were using rubinius to do this one

00:47:16,750 --> 00:47:20,470
they said the multi-threaded

00:47:18,280 --> 00:47:23,050
responsiveness of Rubinius was very very

00:47:20,470 --> 00:47:26,350
good they also tried JRuby they said

00:47:23,050 --> 00:47:28,000
JRuby although faster overall had a

00:47:26,350 --> 00:47:30,550
little more latency in it that was

00:47:28,000 --> 00:47:32,740
surprising to me but they were flying it

00:47:30,550 --> 00:47:34,210
around they had total control of it and

00:47:32,740 --> 00:47:37,360
you got to realize that we were in a car

00:47:34,210 --> 00:47:40,030
museum and the Ferraris and Lamborghinis

00:47:37,360 --> 00:47:41,410
and Austen marketing's in the background

00:47:40,030 --> 00:47:43,510
you probably had several million dollars

00:47:41,410 --> 00:47:46,630
worth of cars the background they were

00:47:43,510 --> 00:47:48,250
flying this robot around at some point

00:47:46,630 --> 00:47:50,920
someone runs out and kind of does this

00:47:48,250 --> 00:47:53,620
kind of to protect the cars he wasn't

00:47:50,920 --> 00:47:56,710
sure where the flying robot was going

00:47:53,620 --> 00:48:02,020
that's cool that's real-world stuff then

00:47:56,710 --> 00:48:03,910
in Ruby doing doing robotics also I

00:48:02,020 --> 00:48:06,070
didn't see their over here on the screen

00:48:03,910 --> 00:48:09,220
it's awful let's see if we come back

00:48:06,070 --> 00:48:11,560
there's a video feed so he was pulling

00:48:09,220 --> 00:48:13,510
video off of the drone and showing it on

00:48:11,560 --> 00:48:15,940
the screen at the same time he was

00:48:13,510 --> 00:48:18,040
pulling down nav data and showing it on

00:48:15,940 --> 00:48:22,930
the screen so he was getting all this

00:48:18,040 --> 00:48:25,330
good data out of off of the drone

00:48:22,930 --> 00:48:27,280
through Ruby in real time that was

00:48:25,330 --> 00:48:32,110
pretty awesome let's just skip down here

00:48:27,280 --> 00:48:37,470
to the landing here he's coming in he's

00:48:32,110 --> 00:48:40,540
coming in he's hovering and he's closed

00:48:37,470 --> 00:48:46,540
her down move it over just a little bit

00:48:40,540 --> 00:48:49,560
does it over and down there we go that's

00:48:46,540 --> 00:48:49,560
awesome that's cool

00:48:50,619 --> 00:48:58,539
so all right well I think I'm done

00:48:56,140 --> 00:49:01,890
I'm Jim Warrick I work for Neil and

00:48:58,539 --> 00:49:01,890
thank you very much

00:49:14,810 --> 00:49:16,870

YouTube URL: https://www.youtube.com/watch?v=vIHdhaF2R2w


