Title: Garden City Ruby 2014 - The Dark Side of Ruby by Gautam Rege
Publication date: 2020-01-24
Playlist: Garden City Ruby 2014
Description: 
	I love Ruby! But as in any relationship, to love means that you have to accept the "dark side" too! Ruby is human and has a lot of gotchas, tricks, wierdness and sometimes scary features that I plan to highlight. This talk aims to provide the "Ah-ha!" moments when working in Ruby.

This talk is for beginners and experts alike - in fact, I tag slides to mark their level and beginners can choose to tune out of the heavy stuff! My talk shall cover the dark side of the following features of Ruby (in no particular order)

Base Conversions
Infinity
Keywords
method missing
Module inheritance (it exists!)
Curried Procs
Cherry picking module methods
Oniguruma games
procs, blocks and my friend stubby.
Object ids
==, ===, eql? and equal?
and more...
As with most of my talks, humor play an important role and I shall aim to get everyone high on Ruby with a deep dive!

Help us caption & translate this video!

http://amara.org/v/FG4U/
Captions: 
	00:00:25,560 --> 00:00:27,980
All right, good morning people.

00:00:27,980 --> 00:00:32,520
After a bright talk this morning by Ajey, it's

00:00:32,520 --> 00:00:37,930
time to get dark and dirty, OK. So I'm

00:00:37,930 --> 00:00:42,190
from Josh Software, and it started in 2007. These

00:00:42,190 --> 00:00:47,100
are my Twitter handles. And I'm also an author.

00:00:47,100 --> 00:00:50,040
I have a couple of books which are out.

00:00:50,040 --> 00:00:53,720
Well it doesn't look so dark anymore, does it?

00:00:53,720 --> 00:00:57,750
So what is my talk gonna be about? Don't

00:00:57,750 --> 00:01:01,610
worry. It's not gonna be anything scary. I love

00:01:01,610 --> 00:01:06,570
Ruby. But as with every marriage, and I hope

00:01:06,570 --> 00:01:09,150
there's no Ruby in the crowd - OK. As

00:01:09,150 --> 00:01:11,170
with every marriage you also need to know the

00:01:11,170 --> 00:01:14,049
other side. You know the side you were -

00:01:14,049 --> 00:01:16,840
you didn't know when you were just going around.

00:01:16,840 --> 00:01:19,990
But it's the same thing with Ruby. You have

00:01:19,990 --> 00:01:22,880
to know what you're looking at. And my talk

00:01:22,880 --> 00:01:25,840
is going to be about the weirdness and the

00:01:25,840 --> 00:01:29,549
gotcha moments. In short, in my talk, if you

00:01:29,549 --> 00:01:35,689
find 'Ah-ha!' moments, it's working. Oh, we have a

00:01:35,689 --> 00:01:40,329
varied audience today. So to ensure sanity, I have

00:01:40,329 --> 00:01:44,119
tagged my slides. My slides are tagged with my

00:01:44,119 --> 00:01:48,920
good friend bumblebee to keep it neutral, that these

00:01:48,920 --> 00:01:52,149
are for beginners. So you must pay attention. And

00:01:52,149 --> 00:01:54,729
the experts, try to give the beginners a chance

00:01:54,729 --> 00:01:58,990
to give the answer. And the experts, you know,

00:01:58,990 --> 00:02:03,219
take your inspiration from Optimus Prime. And the beginners

00:02:03,219 --> 00:02:05,789
can choose to tune out, but whatever you learn,

00:02:05,789 --> 00:02:09,970
the better. So let's get started with the infamous

00:02:09,970 --> 00:02:16,970
infinity. Now, we all know what infinity is, right?

00:02:17,860 --> 00:02:20,569
And since we are all programmers, obviously we should

00:02:20,569 --> 00:02:23,830
know the answer to this one. What's the answer?

00:02:23,830 --> 00:02:29,090
There are no surprises here. No surprises there. No

00:02:29,090 --> 00:02:32,520
division by zero. We know this. What about, what

00:02:32,520 --> 00:02:39,520
about this? Oops. This actually works. So we know

00:02:40,000 --> 00:02:43,870
that everything in Ruby is an object. So that

00:02:43,870 --> 00:02:45,540
looks like a, that looks like a class. So

00:02:45,540 --> 00:02:47,760
let's see what the hell that is anyway. If

00:02:47,760 --> 00:02:50,170
you type this out, what do you think I

00:02:50,170 --> 00:02:54,659
get? So... what's going on here? So infinity is

00:02:54,659 --> 00:02:57,230
a constant define in the float class. Where do

00:02:57,230 --> 00:02:59,560
you see it, you don't see it there. I

00:02:59,560 --> 00:03:01,989
can use this constant to form range comparisons. I

00:03:01,989 --> 00:03:04,629
can use it with equality operators and stuff like

00:03:04,629 --> 00:03:08,799
that. Imagine three equal to equal to infinity. But

00:03:08,799 --> 00:03:13,260
it works. Oh well. So. This is the way

00:03:13,260 --> 00:03:15,829
I get people warmed up. Let's do something with

00:03:15,829 --> 00:03:19,450
more of an adrenaline rush. Base conversions. It's a

00:03:19,450 --> 00:03:22,930
lot of fun. So what do you think is

00:03:22,930 --> 00:03:27,469
the output of this particular thing? Now, I don't

00:03:27,469 --> 00:03:29,640
want all the math geeks going to their calculators,

00:03:29,640 --> 00:03:34,890
but essence is converting a number to a string

00:03:34,890 --> 00:03:38,700
in the octal format. So again, no surprises. Should

00:03:38,700 --> 00:03:45,469
be fine. But let's push the tempo. Now what?

00:03:45,469 --> 00:03:51,060
That, actually works. The next time you are reading

00:03:51,060 --> 00:03:54,439
about, and you hear a name like getafix, ??

00:03:54,439 --> 00:03:59,000
(00:03:57:07). You know oblix, asterix. It need not be

00:03:59,000 --> 00:04:04,620
a name, it could be a number. Well, now

00:04:04,620 --> 00:04:11,620
what? Push the limits. Oops. So now if you

00:04:12,599 --> 00:04:14,980
look at it a little logically, the radix as

00:04:14,980 --> 00:04:17,720
a portion ?? (00:04:15:18) is supported only in thirty-six,

00:04:17,720 --> 00:04:20,859
because you have twenty-six alphabets and ten digits. So

00:04:20,859 --> 00:04:21,829
it can go only up to a radix of

00:04:21,829 --> 00:04:26,240
thirty-six. So if there are some innovators out there,

00:04:26,240 --> 00:04:30,370
who want to actually get a new alphabet into

00:04:30,370 --> 00:04:32,940
the English dictionary, we could probably have a radix

00:04:32,940 --> 00:04:39,940
of thirty-seven. OK. Let's move on to the star.

00:04:41,180 --> 00:04:43,870
Not the rock star, but the star operator. And

00:04:43,870 --> 00:04:46,180
to start with, let's see what it has to

00:04:46,180 --> 00:04:50,150
do with Splat Expander. Oh boy, we see more

00:04:50,150 --> 00:04:53,550
and more of Ruby code right now. So what

00:04:53,550 --> 00:04:58,030
do you think is name and occupation here? As

00:04:58,030 --> 00:05:00,990
we can see we have a struct which takes,

00:05:00,990 --> 00:05:05,120
which has two somethings, name and occupation, and I

00:05:05,120 --> 00:05:09,949
create an object off the struct. Now what do

00:05:09,949 --> 00:05:15,160
we see? Nothing fancy. We're still good. Right? So

00:05:15,160 --> 00:05:17,580
the Splat Expander is actually taking my arguments and

00:05:17,580 --> 00:05:20,600
given me the right name and the right occupation.

00:05:20,600 --> 00:05:21,949
But we don't do things like this, do we?

00:05:21,949 --> 00:05:25,930
We usually - we are Rails programmers. We work

00:05:25,930 --> 00:05:27,900
in Rails, so we usually have stuff like this.

00:05:27,900 --> 00:05:31,639
We use keyword arguments. We all have keyword arguments

00:05:31,639 --> 00:05:34,520
to initiate a class like this and stuff. What

00:05:34,520 --> 00:05:41,520
is the output now? It's Optimus Prime, so, the

00:05:42,800 --> 00:05:47,780
experts? What is name and occupation? Here it's changed.

00:05:47,780 --> 00:05:52,280
That's because the struct always has an array of

00:05:52,280 --> 00:05:54,800
arguments. It does not differentiate between this. This will

00:05:54,800 --> 00:05:59,009
not work on a class. Well, let's get to

00:05:59,009 --> 00:06:04,490
something more funny. What about this? How many here

00:06:04,490 --> 00:06:07,889
have used this before? We know how to convert

00:06:07,889 --> 00:06:09,729
an array into hash. How many of you have

00:06:09,729 --> 00:06:13,590
used this notation before? All right-y, I have two

00:06:13,590 --> 00:06:17,780
people in the audience. Excellent. What happens now? What

00:06:17,780 --> 00:06:20,629
does this do? It actually converts to a hash.

00:06:20,629 --> 00:06:23,729
And out of curiosity what if I add a

00:06:23,729 --> 00:06:29,759
seventh element in the array? Error. No like, dude,

00:06:29,759 --> 00:06:31,069
I don't know what to do, what should I

00:06:31,069 --> 00:06:34,330
do with the last one? Well, let's try some

00:06:34,330 --> 00:06:37,800
more stars. Who all thinks that the output of

00:06:37,800 --> 00:06:43,460
this is gonna be three, six, and nine? Who

00:06:43,460 --> 00:06:50,460
all think otherwise? What's the output? Awesome. And now?

00:06:52,199 --> 00:06:59,199
That was easy wasn't it? Now what? String ??

00:07:03,370 --> 00:07:08,310
(00:07:04:24). That's all actually works. And let's take it

00:07:08,310 --> 00:07:11,190
to the next level. How many here know about

00:07:11,190 --> 00:07:14,830
Stabby, Stabby proc? Here is a sample. So this

00:07:14,830 --> 00:07:17,489
is a Stabby proc that we have which takes

00:07:17,489 --> 00:07:21,750
- note we are still working with star. So

00:07:21,750 --> 00:07:23,909
if I make an invocation ?? (00:07:23:07) to the

00:07:23,909 --> 00:07:30,909
block like this, what is the output? Mumbling, mumbling,

00:07:32,550 --> 00:07:39,550
mumbling. It's five. And now you say, I knew

00:07:40,259 --> 00:07:42,379
that. Right. So basically the short form for the

00:07:42,379 --> 00:07:45,629
first, second last, last, and the rest of the

00:07:45,629 --> 00:07:49,289
stuff is in the middle. Pretty helpful thing to

00:07:49,289 --> 00:07:52,050
know. This works on all. It not, it's just

00:07:52,050 --> 00:07:54,000
not worked with the Stabby proc, it'll work with

00:07:54,000 --> 00:07:58,180
Lambda, it'll work with a method, too. But, as

00:07:58,180 --> 00:08:00,930
with Ruby, and, if I'm supposed to be standing

00:08:00,930 --> 00:08:03,870
here and I'm supposed to be lecturing you on

00:08:03,870 --> 00:08:06,919
all this, I'm supposed to know my stuff. Lo

00:08:06,919 --> 00:08:11,090
and behold, when I was trying these experiments, I

00:08:11,090 --> 00:08:14,419
learned something new. What do you think is the

00:08:14,419 --> 00:08:18,870
output of that? That actually works, and I have

00:08:18,870 --> 00:08:22,289
freaking no idea how. So, well let's put in

00:08:22,289 --> 00:08:24,770
the slide, and if I have somebody looking explain

00:08:24,770 --> 00:08:27,150
to me how does that dot notation just work?

00:08:27,150 --> 00:08:29,490
And it works only on this. It will not

00:08:29,490 --> 00:08:31,590
work on a method obviously, right. But it works!

00:08:31,590 --> 00:08:38,590
So, welcome to the weirdness of Ruby. Well. Getting

00:08:38,620 --> 00:08:44,240
onto really complex stuff. Case statements. How many of

00:08:44,240 --> 00:08:45,600
you have - you all have used cases, right?

00:08:45,600 --> 00:08:47,240
Case when and stuff like that. Why do you

00:08:47,240 --> 00:08:50,060
think this works? And I've tried to make the

00:08:50,060 --> 00:08:54,580
example as complex as possible. All right. If Optimus

00:08:54,580 --> 00:08:56,680
Prime doesn't do this who the hell else would,

00:08:56,680 --> 00:09:03,680
right? So what is the output? It's pretty obvious

00:09:04,300 --> 00:09:06,320
that we have a multiple of three, because nine

00:09:06,320 --> 00:09:08,329
is a multiple of three, and yeah, because we

00:09:08,329 --> 00:09:10,450
can all read in English and Ruby gives us

00:09:10,450 --> 00:09:14,880
readable code. We know the output here, right? Well

00:09:14,880 --> 00:09:17,870
it's true. You're absolutely right. Ruby's not that weird.

00:09:17,870 --> 00:09:20,170
It'll give you the right answers. But my question

00:09:20,170 --> 00:09:25,870
is: multiple_of is a method, right? It takes one

00:09:25,870 --> 00:09:30,430
parameter, which I have passed. How was it compared

00:09:30,430 --> 00:09:37,430
with nine? Where did nine come into the picture?

00:09:39,540 --> 00:09:43,610
Behind every case, behind every successful case, is a

00:09:43,610 --> 00:09:46,790
case equality operator. So what actually happens is that

00:09:46,790 --> 00:09:50,480
that number nine is used with a case equality

00:09:50,480 --> 00:09:54,839
operator. And that case equality operator is an alias

00:09:54,839 --> 00:09:58,380
to the proc call, which actually gets us our

00:09:58,380 --> 00:10:02,970
output. Well. Though this seems pretty straightforward, it has

00:10:02,970 --> 00:10:08,550
just given me immense power. I can now manipulate

00:10:08,550 --> 00:10:10,620
any way that I want a case equality operator

00:10:10,620 --> 00:10:14,630
to work. Simply by over riding the equal to

00:10:14,630 --> 00:10:16,240
equal to equal to method - the case equality

00:10:16,240 --> 00:10:19,260
operator. And I am good to have any sort

00:10:19,260 --> 00:10:21,610
of case comparisons that I want to make. I

00:10:21,610 --> 00:10:24,329
don't care what happens, but it's my call anymore,

00:10:24,329 --> 00:10:28,079
right. Speaking of case equality operator, let's go to

00:10:28,079 --> 00:10:30,269
equality. How many of you all know these symbols?

00:10:30,269 --> 00:10:34,040
There are operators, an eql question mark, and equal

00:10:34,040 --> 00:10:41,040
question mark. Let's have some fun. Any takers? Who

00:10:43,430 --> 00:10:46,459
all think the output is true? Who all think

00:10:46,459 --> 00:10:50,170
the output is false? What happened to the rest

00:10:50,170 --> 00:10:55,360
of the people? Don't care. Don't care. That's bad

00:10:55,360 --> 00:10:56,950
for a conference. You know we just got a

00:10:56,950 --> 00:10:58,230
huge lecture about participation! Again, who all thinks it's

00:10:58,230 --> 00:11:05,230
true? Who all think it's false? Why? Oh, come

00:11:05,480 --> 00:11:09,380
on man, Ruby's gonna be really neat. Of course

00:11:09,380 --> 00:11:14,519
it's true. Well, what do you think now? Anybody

00:11:14,519 --> 00:11:18,940
think it's true? All right man. Stand up dude.

00:11:18,940 --> 00:11:21,800
Please give him a welcome, because he's got it

00:11:21,800 --> 00:11:26,820
absolutely right. What the hell happened to the rest?

00:11:26,820 --> 00:11:29,399
Dude, we just saw the slide before about case

00:11:29,399 --> 00:11:31,720
equality. Are you telling me if you use that

00:11:31,720 --> 00:11:34,790
in a when statement it's not gonna work? Of

00:11:34,790 --> 00:11:39,730
course it's gonna work. You're just comparing to one.

00:11:39,730 --> 00:11:46,060
And... now what? True? How many people think it's

00:11:46,060 --> 00:11:52,260
true? How many people think it's false? Why? So

00:11:52,260 --> 00:11:54,209
people called false but thought it was true but

00:11:54,209 --> 00:11:57,389
didn't want to answer. Well it's false, and I've

00:11:57,389 --> 00:11:59,110
got you guys so motivated you don't want to

00:11:59,110 --> 00:12:02,959
answer, right. Damn it. But this is actually equality

00:12:02,959 --> 00:12:05,680
by value. So the value returned by the object

00:12:05,680 --> 00:12:08,720
is one, the value returned by the float is

00:12:08,720 --> 00:12:14,430
a floating point one. It's completely different. Now what?

00:12:14,430 --> 00:12:18,300
Now it's interesting. Why is it false? Somebody said

00:12:18,300 --> 00:12:25,300
very confidently, why is it false? Absolutely. Now here's

00:12:25,430 --> 00:12:29,100
the weirdness. This stuff actually compares the object ID

00:12:29,100 --> 00:12:30,829
of the two, and a integer and a float

00:12:30,829 --> 00:12:34,670
would have two different object IDs. It's obvious, right

00:12:34,670 --> 00:12:40,040
fellas? So. Aiy aiy aiy, true false, what's it

00:12:40,040 --> 00:12:47,040
guys? There string 'a' and string 'a' are two

00:12:47,240 --> 00:12:52,329
different ruby objects. If I switch that two a

00:12:52,329 --> 00:12:54,600
symbol - thank you that's where you go. So

00:12:54,600 --> 00:13:00,760
with that, let's hit the jackpot. How many of

00:13:00,760 --> 00:13:03,490
you all know what curry is? It's a lot

00:13:03,490 --> 00:13:06,410
of fun, a lot of fun. But to make

00:13:06,410 --> 00:13:10,389
it funnier, I actually decided let's have the slot

00:13:10,389 --> 00:13:13,940
machine get three pulls. And I wrote code for

00:13:13,940 --> 00:13:17,370
it on my flight here, so I have no

00:13:17,370 --> 00:13:20,160
idea whether that's correct or wrong, but like, we

00:13:20,160 --> 00:13:23,579
know it seems a little weird though. I've tried

00:13:23,579 --> 00:13:26,579
to compare if all the three pulls are equal

00:13:26,579 --> 00:13:31,730
and then I'm preparing some recipe with curry, and

00:13:31,730 --> 00:13:37,350
do you think it would work? It just looks

00:13:37,350 --> 00:13:40,810
a little bit of weird code, but I shall

00:13:40,810 --> 00:13:46,850
explain. So curry is a method in the proc

00:13:46,850 --> 00:13:51,769
class which actually returns a lambda if all the

00:13:51,769 --> 00:13:55,010
parameters are not fulfilled. So in this particular case,

00:13:55,010 --> 00:13:57,790
I needed three parameters, X, Y, and Z, and

00:13:57,790 --> 00:14:00,760
in the first statement, I passed only one. Note,

00:14:00,760 --> 00:14:04,040
the invocation is in square brackets. It's different. And

00:14:04,040 --> 00:14:06,720
it returns me a lambda, but other times when

00:14:06,720 --> 00:14:09,420
all the parameters are actually fulfilled in the second

00:14:09,420 --> 00:14:13,420
statement, it actually evaluates the proc. Now if you

00:14:13,420 --> 00:14:15,610
had to write the same code you would have

00:14:15,610 --> 00:14:18,459
taken different types of input, weighted for the user

00:14:18,459 --> 00:14:23,290
with (00:14:18:29) ...?? one, two, three, and evaluated it.

00:14:23,290 --> 00:14:24,920
You don't need to do that. And these things

00:14:24,920 --> 00:14:31,920
can actually be very helpful. So curry away. So!

00:14:34,300 --> 00:14:41,300
So you think you can tell protected from private.

00:14:41,949 --> 00:14:44,320
OK, I am not a - I'm a better

00:14:44,320 --> 00:14:50,360
programmer than a singer. Right. Private methods. All of

00:14:50,360 --> 00:14:54,000
us have been taught since school, unfortunately, that private

00:14:54,000 --> 00:14:58,740
methods are not inherited. Are they inherited? As you

00:14:58,740 --> 00:15:01,259
can see, foo is a private method. And I

00:15:01,259 --> 00:15:02,910
ran out of creativity, so I just went to

00:15:02,910 --> 00:15:06,060
the standard base type foo, blah blah blah here.

00:15:06,060 --> 00:15:10,620
Is this going to work? All of us take

00:15:10,620 --> 00:15:13,070
a lot of things for granted. How many of

00:15:13,070 --> 00:15:14,420
you all knew this already, that private methods are

00:15:14,420 --> 00:15:18,500
inherited in Ruby? All right, OK, now I'm scared.

00:15:18,500 --> 00:15:21,160
How many of you all didn't know this? Don't

00:15:21,160 --> 00:15:24,610
be shy, don't be shy. OK, so this is

00:15:24,610 --> 00:15:28,079
actually one of the basic principles of where Ruby

00:15:28,079 --> 00:15:32,339
actually breaks traditional object oriented concepts. All private methods

00:15:32,339 --> 00:15:36,699
are inherited. What? How many of you all have

00:15:36,699 --> 00:15:41,860
seen this code before? Forget the Mongoid::Document but include?

00:15:41,860 --> 00:15:46,029
Wait, come on. Everybody knows it! What is include?

00:15:46,029 --> 00:15:53,029
Is it a keyword? How many thought it was

00:15:53,139 --> 00:15:55,120
a keyword? Oh it's like that, require or that

00:15:55,120 --> 00:16:01,639
import in Java. Include is a private instance method

00:16:01,639 --> 00:16:07,500
defined in the class module. So while that is

00:16:07,500 --> 00:16:10,980
sinking in, it raises a basic question. All private

00:16:10,980 --> 00:16:17,980
methods are inherited. So what are protected methods? So

00:16:18,269 --> 00:16:19,889
what about protected methods? So what's the difference between

00:16:19,889 --> 00:16:23,089
private methods and protected methods now? We were told

00:16:23,089 --> 00:16:27,290
in our school that protected methods are inherited but

00:16:27,290 --> 00:16:32,110
not publicly accessible, right. Now private methods are inherited

00:16:32,110 --> 00:16:36,649
but not publicly accessible, right? So what are private

00:16:36,649 --> 00:16:41,130
metho- protected methods? Contrary to popular belief, in Ruby

00:16:41,130 --> 00:16:46,490
protected methods actually work with objects and not classes.

00:16:46,490 --> 00:16:49,610
And you can invoke a protected method on another

00:16:49,610 --> 00:16:54,339
object within the same lineage. And I say, what

00:16:54,339 --> 00:17:01,339
the... what? Better explained with an example. Simple example,

00:17:01,610 --> 00:17:03,060
for the sake of brevity I put the initializer

00:17:03,060 --> 00:17:09,230
in one line. What is the output, people? Don't

00:17:09,230 --> 00:17:15,040
be shy. You have bumblebee to help you out.

00:17:15,040 --> 00:17:19,990
No takers. Come on man, that's like pretty obvious

00:17:19,990 --> 00:17:23,050
right. You can't call a protected method on an

00:17:23,050 --> 00:17:30,050
object, right? Simple stuff. However. Now beginners, so-called beginners

00:17:31,340 --> 00:17:33,430
can tune out. This is fun. I added a

00:17:33,430 --> 00:17:38,740
method called fights. Same piece of code. What is

00:17:38,740 --> 00:17:44,070
the output? Take a wild guess, man. Go for

00:17:44,070 --> 00:17:51,070
it. So either Megatron or Decepticon. Any other deceptive

00:17:52,350 --> 00:17:59,350
ideas? Guys, very practically, a quick lesson in human

00:17:59,880 --> 00:18:02,710
psychology. If that didn't work, would I have that

00:18:02,710 --> 00:18:08,150
slide up there again? It works, man. It works.

00:18:08,150 --> 00:18:09,940
But why did it work and how did it

00:18:09,940 --> 00:18:13,430
work? The interesting part is that piece of line,

00:18:13,430 --> 00:18:15,660
earlier in the previous slide, prime dot nick did

00:18:15,660 --> 00:18:18,550
not work, but here target dot nick actually works.

00:18:18,550 --> 00:18:22,120
I have called a protected method on an object.

00:18:22,120 --> 00:18:25,960
Now that same lineage means that because I'm inside

00:18:25,960 --> 00:18:28,950
the class Autobot, because I'm calling a method on

00:18:28,950 --> 00:18:32,320
the prime object, which is in, which is in

00:18:32,320 --> 00:18:36,190
Autobot class, and since another object called Megatron there

00:18:36,190 --> 00:18:40,810
is of the same lineage, it's also an Autobot.

00:18:40,810 --> 00:18:46,850
I can call the protected methods. So why didn't

00:18:46,850 --> 00:18:49,900
it work earlier? Because everything in Ruby is an

00:18:49,900 --> 00:18:52,340
object. If you're trying to start prime dot nick

00:18:52,340 --> 00:18:55,140
and the previous case was outside the scope. So

00:18:55,140 --> 00:18:57,640
it was effectively in some main class, not the

00:18:57,640 --> 00:19:00,730
same lineage, so it doesn't work. So Ruby actually

00:19:00,730 --> 00:19:04,400
works in the traditional way, but has different internal

00:19:04,400 --> 00:19:07,380
meanings. And if now this was getting a little

00:19:07,380 --> 00:19:10,430
complicated, how many of you all thought there are

00:19:10,430 --> 00:19:12,430
keywords in Ruby? Cause that man there is gonna

00:19:12,430 --> 00:19:14,260
come and shoot you if you think Ruby has

00:19:14,260 --> 00:19:21,260
keywords. Does that code work? Is it even valid?

00:19:23,700 --> 00:19:29,640
Should it give me a syntax error? If, how

00:19:29,640 --> 00:19:30,990
many of you think it will give me an

00:19:30,990 --> 00:19:33,460
error? Syntax error too? What's wrong with you? Have

00:19:33,460 --> 00:19:37,070
you gone mad?-kind of errors. Any takers for syntax

00:19:37,070 --> 00:19:40,010
errors? Probably not. But if not, then I want

00:19:40,010 --> 00:19:41,280
to ask you know what is the output of

00:19:41,280 --> 00:19:48,280
this code? Seriously. There it is, seriously. Question is,

00:19:50,440 --> 00:19:51,710
how many of you all thought this is an

00:19:51,710 --> 00:19:55,400
error called stack_too_deep. Cause when I call false it

00:19:55,400 --> 00:19:57,770
calls true, once you call true it will call

00:19:57,770 --> 00:20:02,250
false. And it goes into a recursive loop and

00:20:02,250 --> 00:20:08,330
case stack_too_deep. Any takers for stack_too_deep? Higher, higher! And

00:20:08,330 --> 00:20:12,240
how many think it will actually work? All right.

00:20:12,240 --> 00:20:15,510
The rest of the people, you all are beginners.

00:20:15,510 --> 00:20:17,300
But yeah this works. So it does not stack_too_deep.

00:20:17,300 --> 00:20:21,680
This actually works because true, true's resolution is immediately

00:20:21,680 --> 00:20:24,800
determined as the boolean value. However if I had

00:20:24,800 --> 00:20:29,650
changed these two particular statements, the content in the

00:20:29,650 --> 00:20:32,130
methods to self dot false and self dot true

00:20:32,130 --> 00:20:39,130
I would probably get stack_too_deep. Not probably, definitely get

00:20:39,190 --> 00:20:42,270
stack_too_deep. OK. So. If this wasn't complex enough for

00:20:42,270 --> 00:20:49,200
you, let's go to modules, the mysterious modules. You

00:20:49,200 --> 00:20:51,030
know what the bull I have with my good

00:20:51,030 --> 00:20:54,660
friend module, which has power, Megatron is super powerful,

00:20:54,660 --> 00:20:57,990
and he's a force, he's evil. And I want

00:20:57,990 --> 00:21:00,910
to put that in my class Hanuman. note the

00:21:00,910 --> 00:21:04,070
star, because that's true. I want the power of

00:21:04,070 --> 00:21:10,590
Megatron with Hanuman. Hanuman! Unfortunately this will not go

00:21:10,590 --> 00:21:13,460
down too well religiously for us, because though it

00:21:13,460 --> 00:21:15,890
will be Hanuman will be as powerful as Megatron,

00:21:15,890 --> 00:21:19,960
Hanuman is now evil! So what do I do?

00:21:19,960 --> 00:21:22,560
Is there a way I can cherry-pick from Megatron,

00:21:22,560 --> 00:21:25,650
saying, I want the power of Megatron but I

00:21:25,650 --> 00:21:32,650
don't want to be evil? What do I do?

00:21:33,060 --> 00:21:35,700
I require. Note, I have not included Megatron, I

00:21:35,700 --> 00:21:39,980
require the Megatron method- Megatron file, Megatron RB. I

00:21:39,980 --> 00:21:43,270
define a method called power and I go to

00:21:43,270 --> 00:21:46,190
the module, tell him to give me that instance

00:21:46,190 --> 00:21:49,600
method called power, which gives me something called an

00:21:49,600 --> 00:21:54,030
unbounded method. And then I bind it to me,

00:21:54,030 --> 00:21:59,730
that is self, and I call it. And that

00:21:59,730 --> 00:22:06,730
makes my Hanuman religiously acceptable to society. Question? No.

00:22:09,150 --> 00:22:11,870
So note self, self is the object call. So

00:22:11,870 --> 00:22:13,680
it's not working on the class call, it's actually

00:22:13,680 --> 00:22:16,260
working on the instance. So every object, every instance

00:22:16,260 --> 00:22:21,660
of Hanuman, will actually get the power of Megatron.

00:22:21,660 --> 00:22:26,890
And with that I end my talk and thank

00:22:26,890 --> 00:22:29,980
my two assistants here. I have, I'm open for

00:22:29,980 --> 00:22:33,820
a few questions. Do I have the time, guys?

00:22:33,820 --> 00:22:35,910
Satish, do I have some time? For questions? Yay!

00:22:35,910 --> 00:22:40,650
We have a lot of time for questions! All

00:22:40,650 --> 00:22:47,650
right, you. Thank you. You have a question there.

00:22:49,190 --> 00:22:52,970
QUESTION: What exactly lead you to title this talk

00:22:52,970 --> 00:22:56,840
as the Dark Side of Ruby? G.R.: Oooh. Now

00:22:56,840 --> 00:22:59,660
he killed me, didn't he? So that was a,

00:22:59,660 --> 00:23:01,510
there's a two-sided answer to that. One was to

00:23:01,510 --> 00:23:06,020
fool the organizers, to get the CF?? (00:23:05:23) accepted.

00:23:06,020 --> 00:23:10,510
But more importantly, the dark side of Ruby tries

00:23:10,510 --> 00:23:12,130
to bring out the weirdness in Ruby, which is

00:23:12,130 --> 00:23:15,700
not the evil part, but the hidden part. Like

00:23:15,700 --> 00:23:18,130
the dark side of the moon where we have

00:23:18,130 --> 00:23:20,180
all these kind of stuff that breaks, the gotchas,

00:23:20,180 --> 00:23:22,870
the moment that we feel that are going to

00:23:22,870 --> 00:23:25,740
help but you don't really need to care about

00:23:25,740 --> 00:23:28,160
it, but it's really, really important that you know

00:23:28,160 --> 00:23:32,840
these things exist. That's why Dark Side of Ruby.

00:23:32,840 --> 00:23:37,920
So I still love Ruby - no offense. Any

00:23:37,920 --> 00:23:44,920
other questions? Yes sir. QUESTION: So have you suffered

00:23:45,120 --> 00:23:47,040
because of any of these gotchas in you work?

00:23:47,040 --> 00:23:50,940
G.R.: Absolutely! This is all part of experience. Part

00:23:50,940 --> 00:23:55,860
(00:23:53:00 ??) is part of experience, part is training,

00:23:55,860 --> 00:23:59,310
and partly is preparation for my talk, trying to

00:23:59,310 --> 00:24:02,030
find out these terms, and figuring things out. There's

00:24:02,030 --> 00:24:04,170
a lot of stuff that I've actually kept out,

00:24:04,170 --> 00:24:08,370
like you know ?? (00:24:07:03) games. Lots of fun

00:24:08,370 --> 00:24:10,850
with method missing. I haven't even touched upon blocks

00:24:10,850 --> 00:24:12,970
and ?? There's lots of funny stuff which happens

00:24:12,970 --> 00:24:17,130
there. But I have only half an hour. So

00:24:17,130 --> 00:24:18,450
the question to you guys also is that in

00:24:18,450 --> 00:24:20,260
case you find some of these funny things which

00:24:20,260 --> 00:24:23,040
happen in Ruby, and are able to explain it

00:24:23,040 --> 00:24:24,770
or not able to explain it, send me a

00:24:24,770 --> 00:24:27,580
Tweet, send me an email, and I will probably

00:24:27,580 --> 00:24:30,600
investigate and improve my talk at your expense. QUESTION:

00:24:30,600 --> 00:24:35,380
Yeah. So the other question is, are there some

00:24:35,380 --> 00:24:39,850
practices, certain things that I follow, so that I

00:24:39,850 --> 00:24:42,730
don't get, I don't encounter these? G.R.: Well, so

00:24:42,730 --> 00:24:44,220
one thing, these aren't problems. What I wanted to

00:24:44,220 --> 00:24:45,900
point out here is that this is not a

00:24:45,900 --> 00:24:47,390
bad part of Ruby, but these are the things

00:24:47,390 --> 00:24:50,130
that we take for granted. So knowing about protected

00:24:50,130 --> 00:24:55,050
and private being different is important. But not mandatory

00:24:55,050 --> 00:24:57,910
for us to work as Rails programmers. But if

00:24:57,910 --> 00:25:01,750
you know that, how protected and private actually work,

00:25:01,750 --> 00:25:05,050
it makes us better programmers. So best practices of

00:25:05,050 --> 00:25:07,450
Ruby are already there. You know there are things

00:25:07,450 --> 00:25:11,380
like flip-flops in Ruby which is for lack of

00:25:11,380 --> 00:25:15,220
a better term, a mind star star star star.

00:25:15,220 --> 00:25:18,010
But, I do not recommend it. But it's there.

00:25:18,010 --> 00:25:20,860
There are plenty of other things in Ruby, too.

00:25:20,860 --> 00:25:24,620
Which work, which should work, which you should use.

00:25:24,620 --> 00:25:26,970
The bottom line is that Ruby gives us the

00:25:26,970 --> 00:25:29,530
maximum flexibility to build the way we want to

00:25:29,530 --> 00:25:33,050
build our code. So with great power comes great

00:25:33,050 --> 00:25:35,530
responsibility. And sometimes it's irresponsible. So it worked out

00:25:35,530 --> 00:25:39,040
great. Yeah. QUESTION: So is there a good parts

00:25:39,040 --> 00:25:41,460
of Ruby, like good parts of Java- G.R.: What?

00:25:41,460 --> 00:25:43,890
QUESTION: Good parts of Ruby? G.R.: Oh, good parts?

00:25:43,890 --> 00:25:45,650
Everything! I've been working in Ruby for six years

00:25:45,650 --> 00:25:48,050
and I still love it. QUESTION: No, there is

00:25:48,050 --> 00:25:49,320
a famous book called Good Parts of JavaScript, a

00:25:49,320 --> 00:25:51,600
very thin book that allows a subset of language

00:25:51,600 --> 00:25:55,600
that is very safe to use, that you can

00:25:55,600 --> 00:26:02,110
be very productive in. So do you, have you

00:26:02,110 --> 00:26:02,200
come across something that says, like, there's a subset

00:26:02,200 --> 00:26:02,300
that you should stick to and use? G.R.: So

00:26:02,300 --> 00:26:05,390
the best part about Ruby that I like is

00:26:05,390 --> 00:26:09,070
the closures, which is completely misunderstood, because every time

00:26:09,070 --> 00:26:11,390
I talk to any person who's getting into Ruby

00:26:11,390 --> 00:26:12,620
and I show them what a closure is they're

00:26:12,620 --> 00:26:15,060
like yeah, that's a loop. But it's not. It's

00:26:15,060 --> 00:26:17,670
like far more better than that. And it's far

00:26:17,670 --> 00:26:20,660
more - it's more intuitive. It gets into the

00:26:20,660 --> 00:26:23,410
details and gives us so much more incentive about

00:26:23,410 --> 00:26:26,160
learning how Ruby internals work, that we tend to

00:26:26,160 --> 00:26:29,100
actually ignore it in Rails. And I only (00:26:30:29)

00:26:29,100 --> 00:26:31,530
have a lot of respect for people who have

00:26:31,530 --> 00:26:33,010
learned Ruby and gone to Rails, because they know

00:26:33,010 --> 00:26:35,790
the right thing, other than most of us, including

00:26:35,790 --> 00:26:38,340
me, who got into Rails and then fell in

00:26:38,340 --> 00:26:41,770
love with Ruby. So it's different. QUESTION: So is

00:26:41,770 --> 00:26:46,310
Ruby the good parts the next book? G.R.: Could

00:26:46,310 --> 00:26:48,090
be. But I'll need a lot of community support

00:26:48,090 --> 00:26:54,900
for that. Yes? QUESTION: Yeah, hi, thanks for the

00:26:54,900 --> 00:26:57,390
talk. Just (00:26:55:09). I have been checking out Exorcism

00:26:57,390 --> 00:26:59,030
dot IO. I don't know if you guys have

00:26:59,030 --> 00:27:01,750
heard of it. So it's actually started by Katrina,

00:27:01,750 --> 00:27:04,000
who's part of the Ruby Rogues, and I have

00:27:04,000 --> 00:27:06,530
had a wonderful time running stuff from Ruby, like

00:27:06,530 --> 00:27:08,940
I have been working Ruby for ?? (00:27:08:20) for

00:27:08,940 --> 00:27:11,650
years and also gotchas- G.R.: So, Exorcism dot IO.

00:27:11,650 --> 00:27:14,560
That's great. QUESTION: Like really good Ruby idioms that

00:27:14,560 --> 00:27:15,500
like so it's basically what happens is you, there

00:27:15,500 --> 00:27:17,210
are around ten languages if I'm not wrong. You

00:27:17,210 --> 00:27:21,160
can pick Ruby, you can sub in your solutions.

00:27:21,160 --> 00:27:23,660
People can look at your code. They can give

00:27:23,660 --> 00:27:26,810
good reviews. You can help out others with your

00:27:26,810 --> 00:27:30,190
suggestions. Yeah- G.R.: But to add to that, there

00:27:30,190 --> 00:27:32,370
is also some interesting - I'm not sure if

00:27:32,370 --> 00:27:35,870
you all have heard of Winbgall (00:27:33:08). Wingolf was

00:27:35,870 --> 00:27:38,670
a gem and a simple tool where you can

00:27:38,670 --> 00:27:42,150
report a problem statement, and using whim, you know

00:27:42,150 --> 00:27:46,150
execute that in the least number of key presses.

00:27:46,150 --> 00:27:48,650
Similarly there are a few initiatives for Ruby golf,

00:27:48,650 --> 00:27:51,350
where you can actually try things like, the beginner

00:27:51,350 --> 00:27:54,210
?? they actually said they have things with ??

00:27:54,210 --> 00:27:57,790
you know stuff like, write this piece of code

00:27:57,790 --> 00:28:01,130
without using arrays, or without using the equality operator.

00:28:01,130 --> 00:28:03,500
And then you start, your mind starts churning, and

00:28:03,500 --> 00:28:05,090
then you dig deeper into Ruby and find other

00:28:05,090 --> 00:28:07,140
things. So the best way to find these things

00:28:07,140 --> 00:28:10,850
is to try Ruby ?? All right we had

00:28:10,850 --> 00:28:13,380
a question there too. QUESTION: Not really a question,

00:28:13,380 --> 00:28:16,210
but just a suggestion, actually, to folks who are

00:28:16,210 --> 00:28:18,740
trying to learn Ruby. I like that he pointed

00:28:18,740 --> 00:28:20,700
out that some of the things that we've learned

00:28:20,700 --> 00:28:24,290
in college, classical logic and stuff doesn't really apply.

00:28:24,290 --> 00:28:27,750
What really helped me understand differences was that treat

00:28:27,750 --> 00:28:30,840
Ruby as a object-focused language and most of the

00:28:30,840 --> 00:28:33,120
languages that you probably end up working with, Java,

00:28:33,120 --> 00:28:36,280
C sharp, they'll be class focused. So concepts like

00:28:36,280 --> 00:28:39,340
private, protected, just like you mentioned, are all object-level

00:28:39,340 --> 00:28:41,580
concepts in Ruby. In fact if you wanted to

00:28:41,580 --> 00:28:44,570
draw parallels again JavaScript is a good parallel because

00:28:44,570 --> 00:28:47,230
JavaScript is also an object-focused language. So there are a

00:28:47,230 --> 00:28:48,950
lot of parallels between JavaScript and Ruby, and

00:28:49,000 --> 00:28:51,700
less between Java and Ruby.

00:28:51,700 --> 00:28:52,700
QUERANT: Yeah, and-

00:28:52,740 --> 00:28:55,700
It's like the dot, I'm sorry, that dot thing just amazed me.

00:28:55,700 --> 00:28:58,780
??, just having a dot.

00:28:58,900 --> 00:29:01,460
and I was actually kind of disappointed when it

00:29:01,460 --> 00:29:04,040
ended. I just wanted more. OK.

00:29:04,140 --> 00:29:05,140
G.R.: Cool. Thank you.

00:29:08,260 --> 00:29:09,260
Yes?

00:29:11,080 --> 00:29:13,200
The Well-Grounded Rubyist. A must read.

00:29:14,260 --> 00:29:15,680
V.O.: Somebody Tweet about it, please.

00:29:16,340 --> 00:29:17,680
V.O.: We'll take one last question.

00:29:19,500 --> 00:29:21,840
QUERANT: How does it help to have protected and private method

00:29:21,940 --> 00:29:24,940
different from other languages? The way Ruby does it?

00:29:25,160 --> 00:29:27,780
G.R.: I'm sorry. Did you ask what is different between protected and private-

00:29:27,780 --> 00:29:30,140
QUERANT: No. How does it help to have a different design implementation, 

00:29:30,140 --> 00:29:31,140
to have it different.

00:29:31,140 --> 00:29:33,720
G.R.: Oh. Excellent. And I love answering this question.

00:29:33,720 --> 00:29:35,560
Though sometimes it can be a little long.

00:29:35,560 --> 00:29:39,760
Why is private and protected different private and protected different in Ruby than

00:29:39,760 --> 00:29:41,540
in other traditional standard languages?

00:29:41,540 --> 00:29:43,160
Because Ruby did it right.

00:29:43,160 --> 00:29:44,840
That's how it's supposed to be.

00:29:44,840 --> 00:29:46,240
Example.

00:29:48,180 --> 00:29:50,440
You know, when we talk about object-oriented programming, 

00:29:50,440 --> 00:29:52,680
it's supposed to be about objects. Things that you can see and touch.

00:29:52,680 --> 00:29:55,060
For example: Inheritance.

00:29:55,060 --> 00:29:57,020
Right. What is inheritance?

00:29:57,020 --> 00:29:59,380
In, put it in, no uncertain term, though, it's my

00:29:59,380 --> 00:30:01,080
??

00:30:01,820 --> 00:30:04,900
Right. My inherited land my from my ancestors.

00:30:06,500 --> 00:30:08,740
It's private. It's inherited.

00:30:08,740 --> 00:30:11,620
You can. It, it comes within the family.

00:30:11,620 --> 00:30:13,640
It can be protected. Can be private.

00:30:13,640 --> 00:30:16,900
But, if you have your dad's wallet, do you inherit it?

00:30:18,280 --> 00:30:20,440
You can choose to use it. You can choose not to use it.

00:30:20,500 --> 00:30:21,620
It's just there.

00:30:21,620 --> 00:30:24,980
The inheritance of land can be protected because it always stays in the family.

00:30:24,980 --> 00:30:28,440
Like, for example, the money in the family is protected.

00:30:28,440 --> 00:30:31,340
But that's always dealing with parents and children.

00:30:31,340 --> 00:30:35,460
You can't go, your father. Just because you have a father and I have a father

00:30:35,460 --> 00:30:37,000
I can't go asking your father for money.

00:30:37,000 --> 00:30:40,700
Right. It's immense, how you determine. And of course public is the same everywhere.

00:30:41,260 --> 00:30:43,960
So Ruby did it right, because it's, everything's object-centric.

00:30:44,680 --> 00:30:47,940
Exactly what Aman said just now. Everything's object centric.

00:30:48,660 --> 00:30:52,140
And, traditionally in object-oriented concepts, it started off right

00:30:52,140 --> 00:30:57,020
and then it went all across the tangent, where you had this inheritance, and

00:30:57,020 --> 00:30:59,120
classes and stuff like that. All the standard

00:31:00,060 --> 00:31:06,480
things that I never talk about: incapsulation, abstraction, polymorphism

00:31:06,480 --> 00:31:09,440
which seem to be the essence of object-oriented programming but is not.

00:31:10,240 --> 00:31:11,840
V.O.: So, a follow-up question.

00:31:11,840 --> 00:31:16,380
I have it. So is there a well-known pattern that makes use of, makes good of

00:31:16,380 --> 00:31:18,200
private and protected?

00:31:18,980 --> 00:31:19,980
We understand why- G.R.: Good qu-

00:31:19,980 --> 00:31:20,980
QUERANT: Is it because it

00:31:20,980 --> 00:31:24,400
G.R.: Include. Include. Include is an excellent example.

00:31:24,400 --> 00:31:26,660
There are actually other patterns, too.

00:31:26,660 --> 00:31:30,780
There are other patterns which allow for protected, protected is used very heavily for

00:31:30,780 --> 00:31:34,080
all sorts of, the usually standard, why use protected, for example

00:31:34,080 --> 00:31:37,180
protecting your password generation algorithm.

00:31:37,180 --> 00:31:39,060
Something like that. But that's the deal with objects.

00:31:39,180 --> 00:31:41,980
And since objects can be called only from their own lineage

00:31:41,980 --> 00:31:43,940
you're always safe. Good question.

00:31:46,000 --> 00:31:47,460
All right. V.O.: Anymore questions?

00:31:48,380 --> 00:31:50,340
If there's anymore questions, we'll take it offline.

00:31:50,340 --> 00:31:52,140
G.R.: Sure. Thank you so much

00:31:53,840 --> 00:31:54,840

YouTube URL: https://www.youtube.com/watch?v=-oorcRJ2Kfg


