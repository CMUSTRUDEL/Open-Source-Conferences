Title: Garden City Ruby 2014 - Native Extensions Served 3 Ways by Tejas Deinkar
Publication date: 2020-01-24
Playlist: Garden City Ruby 2014
Description: 
	New runtimes, technologies and languages keep popping up, and there is a need for libraries that work across language, and across runtimes.

This talk will contrast some of the ways to build a native (usually C/C++) extension, and integrate them with your application. We'll look at how to build a native extension, while staying within the paradigm of the language.

We will be covering (in some detail): * Native C extensions using MRI/Rbx APIs (and contrasting it with the python API possibly) * SWIG to automatically generate wrapper code * FFI to build libraries that work across multiple implementations of ruby

Help us caption & translate this video!

http://amara.org/v/FG4P/
Captions: 
	00:00:00,100 --> 00:00:00,200
Yeah, so, hi everyone.

00:00:00,300 --> 00:00:00,400
Like Swanand said, I'm also part of the team that's organized this,

00:00:00,500 --> 00:00:00,600
so I want to just say it's really awesome to see, like,

00:00:00,700 --> 00:00:00,800
this huge a crowd on a Friday morning in Banglore.

00:00:00,900 --> 00:00:01,000
So, what I'm speaking about today is native extensions in Ruby.

00:00:01,100 --> 00:00:01,200
The title of my talk is Native Extensions Served 3 Ways.

00:00:01,300 --> 00:00:01,400
About myself: I'm Tejas, Tejas Dinkar.

00:00:01,500 --> 00:00:01,600
I am a partner at Nilenso software, which I am an employee on

00:00:01,700 --> 00:00:01,800
collective and it's a really fun place to work.

00:00:01,900 --> 00:00:02,000
If you want to know more, catch me tomorrow.

00:00:02,100 --> 00:00:02,200
I'm on Twitter. I am tdinkar, and on GitHub I am GJA.

00:00:02,300 --> 00:00:02,400
You can find most of my OpenSource contributions over there.

00:00:02,500 --> 00:00:02,600
So, about my talk, this is actually a pretty technical talk,

00:00:02,700 --> 00:00:02,800
so expect to see lots of code. I hope to have five minutes for questions.

00:00:02,900 --> 00:00:03,000
I'll try to beat ?? and beg for it (?? @ 00:01:18).

00:00:03,100 --> 00:00:03,200
But if I don't have time, just catch me in the hallway

00:00:03,300 --> 00:00:03,400
and I can try to answer whatever I can.

00:00:03,500 --> 00:00:03,600
So I'll mostly be covering C extensions, FFI and Swig.

00:00:03,700 --> 00:00:03,800
Let's talk about first why you would ever want to build

00:00:03,900 --> 00:00:04,000
a native extension for Ruby. There's a bunch of different reasons.

00:00:04,100 --> 00:00:04,200
Number one is to maybe integrate with new libraries.

00:00:04,300 --> 00:00:04,400
Say like a new database has dome out, like, for example LibDrizzle,

00:00:04,500 --> 00:00:04,600
which is a new library that came out to work with

00:00:04,700 --> 00:00:04,800
MySQL in the Drizzle database.

00:00:04,900 --> 00:00:05,000
You might want to port that over to Ruby.

00:00:05,100 --> 00:00:05,200
You might want to improve performance of critical code.

00:00:05,300 --> 00:00:05,400
There's different ways of doing this, of course.

00:00:05,500 --> 00:00:05,600
You could try doing JRuby, look at different caches,

00:00:05,700 --> 00:00:05,800
but somethings you have an algorithm that you

00:00:05,900 --> 00:00:06,000
just want to implement in native code,

00:00:06,100 --> 00:00:06,200
or there's already a great library that implements it.

00:00:06,300 --> 00:00:06,400
Someone has given me an example of CSAT,

00:00:06,500 --> 00:00:06,600
which I think Bundler could have actually used,

00:00:06,700 --> 00:00:06,800
or could use, to kind of resolve gem deficiencies,

00:00:06,900 --> 00:00:07,000
and that's written in C++.

00:00:07,100 --> 00:00:07,200
Sometimes you wanna just move that there to

00:00:07,300 --> 00:00:07,400
improve performance, and of course you want to

00:00:07,500 --> 00:00:07,600
write code that works, of course different languages,

00:00:07,700 --> 00:00:07,800
and in general it's a lot of fun.

00:00:07,900 --> 00:00:08,000
You know like, real hackers program in C

00:00:08,100 --> 00:00:08,200
and all that stuff.

00:00:08,300 --> 00:00:08,400
So you could just feel super elite by doing this.

00:00:08,500 --> 00:00:08,600
So before we talk about native extensions,

00:00:08,700 --> 00:00:08,800
I'm just gonna take a small segue and ask-

00:00:08,900 --> 00:00:09,000
So let's talk about Python a little bit.

00:00:09,100 --> 00:00:09,200
Like how many people in the house are like, are Pythonistas?

00:00:09,300 --> 00:00:09,400
How many big Python fans?

00:00:09,500 --> 00:00:09,600
Well, that's actually surprisingly small.

00:00:09,700 --> 00:00:09,800
I thought there would be more.

00:00:09,900 --> 00:00:10,000
So I've figured out the best way to write Python code,

00:00:10,100 --> 00:00:10,200
and I'm gonna tell you this right now and-

00:00:10,300 --> 00:00:10,400
Yes, of course, I am trolling you.

00:00:10,500 --> 00:00:10,600
So over here I have a Python interpreter open

00:00:10,700 --> 00:00:10,800
and I'm gonna say import Ruby.

00:00:10,900 --> 00:00:11,000
Yeah, that seems innocent enough.

00:00:11,100 --> 00:00:11,200
I'm gonna say Ruby dot eval foobar dot size.

00:00:11,300 --> 00:00:11,400
Hmm, that seems to return six.

00:00:11,500 --> 00:00:11,600
So that seems to work. Let's try something more complicated.

00:00:11,700 --> 00:00:11,800
I'm gonna define a method, factorial, and, def factorial,

00:00:11,900 --> 00:00:12,000
partial, N equals zero, partial, factorial, N minus one,

00:00:12,100 --> 00:00:12,200
et cetera.

00:00:12,300 --> 00:00:12,400
Yes it's still recursive, I know.

00:00:12,500 --> 00:00:12,600
And finally I'm gonna call it,

00:00:12,700 --> 00:00:12,800
and I'm gonna say Ruby dot eval factorial five.

00:00:12,900 --> 00:00:13,000
Yet again you'll see that I actually get the result, right.

00:00:13,100 --> 00:00:13,200
So wow, what's this? Have I implemented Python in Ruby?

00:00:13,300 --> 00:00:13,400
Let's look at the code which actually makes this happen.

00:00:13,500 --> 00:00:13,600
How can I actually make this work?

00:00:13,700 --> 00:00:13,800
Well, surprisingly, it's about a dozen lines of code.

00:00:13,900 --> 00:00:14,000
I know this might be a bit hard to read from the back,

00:00:14,100 --> 00:00:14,200
so I'm just gonna read out the interesting bits line by line.

00:00:14,300 --> 00:00:14,400
So it's about a dozen lines of code,

00:00:14,500 --> 00:00:14,600
but let's remove all the Python stuff and let's just

00:00:14,700 --> 00:00:14,800
look at the Ruby parts of this. It's even a lot less,

00:00:14,900 --> 00:00:15,000
yeah, so let's go through this one by one.

00:00:15,100 --> 00:00:15,200
I start off my including Ruby dot H.

00:00:15,300 --> 00:00:15,400
Ruby dot H, most of you who are familiar

00:00:15,500 --> 00:00:15,600
with C and C++ dot H files, are hetero files.

00:00:15,700 --> 00:00:15,800
They basically have the definitions of various

00:00:15,900 --> 00:00:16,000
constructs that Ruby or, like, whatever,

00:00:16,100 --> 00:00:16,200
that your library exposes, so that you can,

00:00:16,300 --> 00:00:16,400
so that your compiler knows what definitions exist in the first place.

00:00:16,500 --> 00:00:16,600
So any Ruby extension that you write,

00:00:16,700 --> 00:00:16,800
you'll need to include Ruby dot H,

00:00:16,900 --> 00:00:17,000
and most of the time this is completely sufficient.

00:00:17,100 --> 00:00:17,200
You don't need to include anything else.

00:00:17,300 --> 00:00:17,400
So let's start looking at the actual code.

00:00:17,500 --> 00:00:17,600
I have a method called Python Ruby eval.

00:00:17,700 --> 00:00:17,800
Yeah, and it accepts one parameter,

00:00:17,900 --> 00:00:18,000
which is a string. OK, nothing complicated here.

00:00:18,100 --> 00:00:18,200
What I do next is I take that string and

00:00:18,300 --> 00:00:18,400
I pass it to a function called R-B eval string,

00:00:18,500 --> 00:00:18,600
right, which stands for Ruby eval string.

00:00:18,700 --> 00:00:18,800
Nothing really magical over here.

00:00:18,900 --> 00:00:19,000
All I'm doing is I'm calling Ruby's eval,

00:00:19,100 --> 00:00:19,200
and you'll notice that the R-B eval returns a object of the type value.

00:00:19,300 --> 00:00:19,400
This value is actually very important.

00:00:19,500 --> 00:00:19,600
The same way in Ruby every single object inherits from object,

00:00:19,700 --> 00:00:19,800
the corresponding construct in the CRuby extensions is the value object.

00:00:19,900 --> 00:00:20,000
Value object is used to represent every single Ruby object

00:00:20,100 --> 00:00:20,200
from nil to true to false to every single custom object.

00:00:20,300 --> 00:00:20,400
Fine, so I have this value object. What am I gonna do next?

00:00:20,500 --> 00:00:20,600
Well, what I'm gonna do is I'm gonna

00:00:20,700 --> 00:00:20,800
switch on the type of the object.

00:00:20,900 --> 00:00:21,000
Yeah, there's a macro called type, and if it's a fix num,

00:00:21,100 --> 00:00:21,200
fix nums are numbers in Ruby,

00:00:21,300 --> 00:00:21,400
I'm gonna call fix num to N,

00:00:21,500 --> 00:00:21,600
to just convert that to an integer.

00:00:21,700 --> 00:00:21,800
If it's a string I'm gonna call string value pointer,

00:00:21,900 --> 00:00:22,000
which converts from a Ruby string into a C string.

00:00:22,100 --> 00:00:22,200
And if it's some other type, like if it's an array, yeah,

00:00:22,300 --> 00:00:22,400
I could have implemented this,

00:00:22,500 --> 00:00:22,600
but yeah I'm too lazy right now,

00:00:22,700 --> 00:00:22,800
so I'm just gonna say return none,

00:00:22,900 --> 00:00:23,000
which is the Python version of nil.

00:00:23,100 --> 00:00:23,200
So yeah that's pretty much it.

00:00:23,300 --> 00:00:23,400
That's all it really took to kind of build

00:00:23,500 --> 00:00:23,600
a small kind of Ruby module which would extend

00:00:23,700 --> 00:00:23,800
some of the functionality of Ruby into Python.

00:00:23,900 --> 00:00:24,000
Let's look at something that's like another construct.

00:00:24,100 --> 00:00:24,200
I don't want to build all my quota

00:00:24,300 --> 00:00:24,400
and I don't want to eval all of it.

00:00:24,500 --> 00:00:24,600
Let's say I want to require a file.

00:00:24,700 --> 00:00:24,800
It's pretty much the same.

00:00:24,900 --> 00:00:25,000
All I need to do is, I accept the file

00:00:25,100 --> 00:00:25,200
and I do R-B require on that file, yeah,

00:00:25,300 --> 00:00:25,400
so in general, yay!

00:00:25,500 --> 00:00:25,600
Actually in that twelve lines of code

00:00:25,700 --> 00:00:25,800
you really have built your first Ruby extension

00:00:25,900 --> 00:00:26,000
and your first Python extension.

00:00:26,100 --> 00:00:26,200
So what I'm really trying to call out,

00:00:26,300 --> 00:00:26,400
is it really is very simple, like,

00:00:26,500 --> 00:00:26,600
as Ruby developers we always have a lot of fears,

00:00:26,700 --> 00:00:26,800
like, oh this very simple thing in Ruby.

00:00:26,900 --> 00:00:27,000
How could I even do it in a C extension?

00:00:27,100 --> 00:00:27,200
It turns out that the Ruby C extensions are great,

00:00:27,300 --> 00:00:27,400
because they expose almost everything

00:00:27,500 --> 00:00:27,600
you would ever want to do in Ruby,

00:00:27,700 --> 00:00:27,800
it exposes the same thing in C.

00:00:27,900 --> 00:00:28,000
So let's look at, what are,

00:00:28,100 --> 00:00:28,200
why aren't there more,

00:00:28,300 --> 00:00:28,400
why aren't we doing it more?

00:00:28,500 --> 00:00:28,600
Well, the biggest common fear every time

00:00:28,700 --> 00:00:28,800
somebody mentions C through Ruby or in general

00:00:28,900 --> 00:00:29,000
hello program, what about memory allocation?

00:00:29,100 --> 00:00:29,200
Like how do I handle this?

00:00:29,300 --> 00:00:29,400
Well, as it turns out, it's really not as difficult

00:00:29,500 --> 00:00:29,600
as you might think, and since you are still programming

00:00:29,700 --> 00:00:29,800
in the Ruby world, you actually have

00:00:29,900 --> 00:00:30,000
a lot of things that can actually help you.

00:00:30,100 --> 00:00:30,200
In particular there are two, there are these two macros, right.

00:00:30,300 --> 00:00:30,400
The first one basically takes a C pointer and stuffs it inside a Ruby object.

00:00:30,500 --> 00:00:30,600
You just tell it which class you want that Ruby object

00:00:30,700 --> 00:00:30,800
to be in and it will magically be created with your pointer.

00:00:30,900 --> 00:00:31,000
And the last, the second one gets the pointer.

00:00:31,100 --> 00:00:31,200
What actually happens internally is that your memory

00:00:31,300 --> 00:00:31,400
that's allocated has been tied to this Ruby object,

00:00:31,500 --> 00:00:31,600
and when this Ruby object gets garbage collected,

00:00:31,700 --> 00:00:31,800
so does your pointer.

00:00:31,900 --> 00:00:32,000
So in many ways you're basically just re-using

00:00:32,100 --> 00:00:32,200
the Ruby's GC to build a, you know,

00:00:32,300 --> 00:00:32,400
to manage your native code as well.

00:00:32,500 --> 00:00:32,600
Right, no batteries included is the next big fear.

00:00:32,700 --> 00:00:32,800
But just keep in mind that since you are

00:00:32,900 --> 00:00:33,000
programming in the Ruby extension,

00:00:33,100 --> 00:00:33,200
in Ruby extensions with C,

00:00:33,300 --> 00:00:33,400
you actually have access to every single

00:00:33,500 --> 00:00:33,600
basic functionality that Ruby can provide you.

00:00:33,700 --> 00:00:33,800
There are methods to manipulate arrays,

00:00:33,900 --> 00:00:34,000
strings, hashes, you name it.

00:00:34,100 --> 00:00:34,200
It's all very easy to manipulate even in the C extension.

00:00:34,300 --> 00:00:34,400
And of course portability.

00:00:34,500 --> 00:00:34,600
I have no idea what this comic is about,

00:00:34,700 --> 00:00:34,800
it was on Geek, but it was the first thing

00:00:34,900 --> 00:00:35,000
that I found for portability.

00:00:35,100 --> 00:00:35,200
So most C extensions work only in MRI,

00:00:35,300 --> 00:00:35,400
except they sort of work in Ruby NS.

00:00:35,500 --> 00:00:35,600
Like Ruby NS has tried to make the sort of API compatible,

00:00:35,700 --> 00:00:35,800
but it sometimes works, it sometimes doesn't.

00:00:35,900 --> 00:00:36,000
So basically all you can trust if you're writing

00:00:36,100 --> 00:00:36,200
C API is your API, your gem is gonna work in MRI.

00:00:36,300 --> 00:00:36,400
So what about, what if you do want to-

00:00:36,500 --> 00:00:36,600
OK, so, the last concern I always see is,

00:00:36,700 --> 00:00:36,800
how do I even get started?

00:00:36,900 --> 00:00:37,000
What is the best practices,

00:00:37,100 --> 00:00:37,200
how do I build a C extension for this?

00:00:37,300 --> 00:00:37,400
I've always found that the Ruby source code

00:00:37,500 --> 00:00:37,600
itself is probably the best documentation

00:00:37,700 --> 00:00:37,800
for how to build a C extension.

00:00:37,900 --> 00:00:38,000
It's actually very simple,

00:00:38,100 --> 00:00:38,200
very easy to understand, very nice to read.

00:00:38,300 --> 00:00:38,400
So over here I've actually,

00:00:38,500 --> 00:00:38,600
I'm actually showing you string dot C,

00:00:38,700 --> 00:00:38,800
and I'm gonna walk through a few lines of this code now, OK.

00:00:38,900 --> 00:00:39,000
So the first line is a method called init string, right.

00:00:39,100 --> 00:00:39,200
This is the equivalent of main for your Ruby extension.

00:00:39,300 --> 00:00:39,400
Whenever your gem is required it is gonna call this function.

00:00:39,500 --> 00:00:39,600
So if there was a gem called string,

00:00:39,700 --> 00:00:39,800
and I said require string,

00:00:39,900 --> 00:00:40,000
it would call this method init underscore string, yeah.

00:00:40,100 --> 00:00:40,200
The first thing I'm gonna do over there

00:00:40,300 --> 00:00:40,400
is I'm gonna say R-B define class.

00:00:40,500 --> 00:00:40,600
I'm gonna define a class called string,

00:00:40,700 --> 00:00:40,800
which inherits from object, right.

00:00:40,900 --> 00:00:41,000
That's exactly equivalent to class string,

00:00:41,100 --> 00:00:41,200
less than sign object. Nothing complicated there.

00:00:41,300 --> 00:00:41,400
I'm storing this in a variable called

00:00:41,500 --> 00:00:41,600
R-B underscore C string, yeah,

00:00:41,700 --> 00:00:41,800
and then I'm gonna define a method

00:00:41,900 --> 00:00:42,000
on R-B underscore C string called E-Q-L question mark, right.

00:00:42,100 --> 00:00:42,200
What I'm gonna tell it is that this method,

00:00:42,300 --> 00:00:42,400
when somebody calls E-Q-L question mark on any string,

00:00:42,500 --> 00:00:42,600
call this C function, which is

00:00:42,700 --> 00:00:42,800
R-B underscore S-T-R underscore equal, right.

00:00:42,900 --> 00:00:43,000
Still nothing complicated over there.

00:00:43,100 --> 00:00:43,200
And the last thing says that I expect one

00:00:43,300 --> 00:00:43,400
extra parameter to be there.

00:00:43,500 --> 00:00:43,600
Self is always fast, but I want one extra parameter.

00:00:43,700 --> 00:00:43,800
So those are the four simple parameters to this.

00:00:43,900 --> 00:00:44,000
There is your class name, your function name,

00:00:44,100 --> 00:00:44,200
the C function to call, and the number of parameters.

00:00:44,300 --> 00:00:44,400
Still nothing really complicated.

00:00:44,500 --> 00:00:44,600
Let's look at the actual implementation of the function.

00:00:44,700 --> 00:00:44,800
Really simple. If self is equal to S-T-R of 2, return true.

00:00:44,900 --> 00:00:45,000
Yes, they're the same object, because the two of them

00:00:45,100 --> 00:00:45,200
are the same object ID. They have the same object ID.

00:00:45,300 --> 00:00:45,400
They're actually the same object.

00:00:45,500 --> 00:00:45,600
Similarly, the second one is not a string.

00:00:45,700 --> 00:00:45,800
Return false, simple enough.

00:00:45,900 --> 00:00:46,000
And the last line kind of delegates

00:00:46,100 --> 00:00:46,200
to the old Ruby equal,

00:00:46,300 --> 00:00:46,400
which will do the algorithm most of us learned

00:00:46,500 --> 00:00:46,600
in high school, where you compile,

00:00:46,700 --> 00:00:46,800
compare a string by a string, character by character

00:00:46,900 --> 00:00:47,000
to figure out, are these two strings equal?

00:00:47,100 --> 00:00:47,200
So as you can see there's really nothing

00:00:47,300 --> 00:00:47,400
very complicated in building a C extension.

00:00:47,500 --> 00:00:47,600
And most of the time your architecture sort of looks like this.

00:00:47,700 --> 00:00:47,800
You have the Ruby, you have the native code

00:00:47,900 --> 00:00:48,000
on the left. This is the code you kind of want to run,

00:00:48,100 --> 00:00:48,200
and you have Ruby code on the right,

00:00:48,300 --> 00:00:48,400
and this is the code that you want to consume,

00:00:48,500 --> 00:00:48,600
that code that you've somehow built.

00:00:48,700 --> 00:00:48,800
In between, in purple, is a Ruby-aware native code.

00:00:48,900 --> 00:00:49,000
And why do I say Ruby-aware native code?

00:00:49,100 --> 00:00:49,200
Because you've still written this as native code.

00:00:49,300 --> 00:00:49,400
It's still written in C.

00:00:49,500 --> 00:00:49,600
It's still compiled down to a dot S-O file or a dot Dylib file on Mac.

00:00:49,700 --> 00:00:49,800
But it's Ruby-aware.

00:00:49,900 --> 00:00:50,000
It knows how things work in Ruby.

00:00:50,100 --> 00:00:50,200
Compared to this FFI kind of does the opposite.

00:00:50,300 --> 00:00:50,400
Instead of Ruby-aware native code,

00:00:50,500 --> 00:00:50,600
what you have is native-aware Ruby code, right.

00:00:50,700 --> 00:00:50,800
So what this means is with FFI basically

00:00:50,900 --> 00:00:51,000
working purely in Ruby, which somehow understands

00:00:51,100 --> 00:00:51,200
how the native architecture of the system-

00:00:51,300 --> 00:00:51,400
OK, so FFI is a Ruby D-S-L.

00:00:51,500 --> 00:00:51,600
It's really easy to implement.

00:00:51,700 --> 00:00:51,800
It's even easier than MRI, like than the C extension.

00:00:51,900 --> 00:00:52,000
It actually works across all Ruby implementations.

00:00:52,100 --> 00:00:52,200
I would actually say that all the Ruby implementors

00:00:52,300 --> 00:00:52,400
got together one day and said, how can we make something

00:00:52,500 --> 00:00:52,600
that'll make it easy for us to integrate with libraries,

00:00:52,700 --> 00:00:52,800
so it works on JRuby, it works on MRI,

00:00:52,900 --> 00:00:53,000
it even works on Mac Ruby, Mac L? Ruby B-N-S,

00:00:53,100 --> 00:00:53,200
you name it, it works.

00:00:53,300 --> 00:00:53,400
And it basically converts to and from C primitives for you directly.

00:00:53,500 --> 00:00:53,600
So let's look at an example.

00:00:53,700 --> 00:00:53,800
I'm just taking the example straight out of GitHub.

00:00:53,900 --> 00:00:54,000
This one's not complicated at all. All I'm doing is I'm saying require FFI.

00:00:54,100 --> 00:00:54,200
I'm saying this is an FFI library,

00:00:54,300 --> 00:00:54,400
my module is FFI library,

00:00:54,500 --> 00:00:54,600
and I'm saying it attaches to lib C.

00:00:54,700 --> 00:00:54,800
And by lib C that doesn't imply

00:00:54,900 --> 00:00:55,000
that the library is written in C.

00:00:55,100 --> 00:00:55,200
What that means is this C standard

00:00:55,300 --> 00:00:55,400
library that you want to connect to.

00:00:55,500 --> 00:00:55,600
And I'm creating a method called puts and

00:00:55,700 --> 00:00:55,800
I'm saying puts takes one argument - it's a string,

00:00:55,900 --> 00:00:56,000
and it returns one argument, which is a,

00:00:56,100 --> 00:00:56,200
one value which is an integer.

00:00:56,300 --> 00:00:56,400
Realy nothing complicated over there.

00:00:56,500 --> 00:00:56,600
This creates a static class method,

00:00:56,700 --> 00:00:56,800
or a module method on this module,

00:00:56,900 --> 00:00:57,000
so I can say my lib dot puts, hello world, using lib C.

00:00:57,100 --> 00:00:57,200
It's very, very easy to attach to a function using FFI.

00:00:57,300 --> 00:00:57,400
And let's quickly look at another example.

00:00:57,500 --> 00:00:57,600
This one I'm attaching pow, which takes two doubles

00:00:57,700 --> 00:00:57,800
and returns a double, and you can see it in action over there.

00:00:57,900 --> 00:00:58,000
It works.

00:00:58,100 --> 00:00:58,200
And here I'm attaching to lib dot M, which is the math library.

00:00:58,300 --> 00:00:58,400
So actually FFI supports a lot of built-in types.

00:00:58,500 --> 00:00:58,600
It supports integers, characters,

00:00:58,700 --> 00:00:58,800
and for everything else,

00:00:58,900 --> 00:00:59,000
every single pointer type that you would use in C,

00:00:59,100 --> 00:00:59,200
it supports, well, a pointer.

00:00:59,300 --> 00:00:59,400
So in general FFI is probably your best solution for everything.

00:00:59,500 --> 00:00:59,600
If you're trying to build a new gem and

00:00:59,700 --> 00:00:59,800
you want people to use your gem, and

00:00:59,900 --> 00:01:00,000
you're not just doing it for fun,

00:01:00,100 --> 00:01:00,200
you probably want to build it using FFI.

00:01:00,300 --> 00:01:00,400
It also lets you do your modeling in Ruby,

00:01:00,500 --> 00:01:00,600
which means the deployments also a little bit easier.

00:01:00,700 --> 00:01:00,800
You don't need to struggle with Make files

00:01:00,900 --> 00:01:01,000
and other stuff kind of build that extension.

00:01:01,100 --> 00:01:01,200
Unfortunately one piece of misinformation that

00:01:01,300 --> 00:01:01,400
seems to be out there is that FFI,

00:01:01,500 --> 00:01:01,600
if you build it with FFI,

00:01:01,700 --> 00:01:01,800
you do not need to worry about garbage collection.

00:01:01,900 --> 00:01:02,000
I'll show you an example in the next slide,

00:01:02,100 --> 00:01:02,200
and unfortunately with FFI there is no

00:01:02,300 --> 00:01:02,400
C++ support without wrapping.

00:01:02,500 --> 00:01:02,600
So you could see over here that these

00:01:02,700 --> 00:01:02,800
functions that we attached to are all static functions in C.

00:01:02,900 --> 00:01:03,000
They kind of are not attached to any object.

00:01:03,100 --> 00:01:03,200
They take fixed number of parameters so

00:01:03,300 --> 00:01:03,400
that's not possible to wrap C++ functions directly.

00:01:03,500 --> 00:01:03,600
You could write a thin shim, which kind of

00:01:03,700 --> 00:01:03,800
takes static functions which you can use to call your C++ functions.

00:01:03,900 --> 00:01:04,000
But it still starts getting to be more effort and you need to write that in C or C++.

00:01:04,100 --> 00:01:04,200
So you do still have to worry about the garbage collection,

00:01:04,300 --> 00:01:04,400
however, with FFI, and I'll show you a quick example where it matters.

00:01:04,500 --> 00:01:04,600
Most people will write code that looks

00:01:04,700 --> 00:01:04,800
something like this and not worry about it.

00:01:04,900 --> 00:01:05,000
So I have a def run query which will crash,

00:01:05,100 --> 00:01:05,200
and say D-B connection is equal to my

00:01:05,300 --> 00:01:05,400
FFI module database connection local host,

00:01:05,500 --> 00:01:05,600
and my FFI module database query I'm passing is a D-B connection

00:01:05,700 --> 00:01:05,800
and I'm saying select star from users.

00:01:05,900 --> 00:01:06,000
This will probably work most of the time.

00:01:06,100 --> 00:01:06,200
But in reality that D-B connection will eventually get GC'd.

00:01:06,300 --> 00:01:06,400
And internally in C your cursor will probably hold

00:01:06,500 --> 00:01:06,600
a pointer to your D-B connection,

00:01:06,700 --> 00:01:06,800
even though this has not been exposed to you via the API.

00:01:06,900 --> 00:01:07,000
So when your D-B connection gets GC'd,

00:01:07,100 --> 00:01:07,200
or like when the Ruby object gets GC'd,

00:01:07,300 --> 00:01:07,400
the pointer is gonna get GC'd in memory,

00:01:07,500 --> 00:01:07,600
and then when your cursor tries to access the D-B connection,

00:01:07,700 --> 00:01:07,800
it will crash.

00:01:07,900 --> 00:01:08,000
Yeah, so the standard pattern for solving something

00:01:08,100 --> 00:01:08,200
like this is to make sure that these

00:01:08,300 --> 00:01:08,400
two objects are aware of each other in the Ruby world.

00:01:08,500 --> 00:01:08,600
The most, in general what I've seen happen a lot

00:01:08,700 --> 00:01:08,800
is you save the database cursor and you kind of just say,

00:01:08,900 --> 00:01:09,000
cursor dot D-B connection is equal to the other connection,

00:01:09,100 --> 00:01:09,200
so that this has a pointer in Ruby as well

00:01:09,300 --> 00:01:09,400
which corresponds to the C pointer.

00:01:09,500 --> 00:01:09,600
So it's not as if you can just blindly

00:01:09,700 --> 00:01:09,800
take the library and, just looking at the APIs, do this.

00:01:09,900 --> 00:01:10,000
Although, granted, with the very primitive types,

00:01:10,100 --> 00:01:10,200
when you're looking at things on the left side,

00:01:10,300 --> 00:01:10,400
the characters, the strings, you're less likely to fall,

00:01:10,500 --> 00:01:10,600
face big memory problems.

00:01:10,700 --> 00:01:10,800
So that's mostly all I'm gonna speak about FFI.

00:01:10,900 --> 00:01:11,000
If you look at the progression we've made,

00:01:11,100 --> 00:01:11,200
we've kind of, we've started with gems that work in MRI.

00:01:11,300 --> 00:01:11,400
We've moved onto gems that work in all Ruby and (00:18:15 - ??),

00:01:11,500 --> 00:01:11,600
now let's talk about gems that work on all programming languages.

00:01:11,700 --> 00:01:11,800
And soon we'll talk about taking over the world.

00:01:11,900 --> 00:01:12,000
So SWIG is sort of the answer to that.

00:01:12,100 --> 00:01:12,200
SWIG stands for the simplified wraper and interface generator -

00:01:12,300 --> 00:01:12,400
which is a big tongue-twister.

00:01:12,500 --> 00:01:12,600
Basically what SWIG does is it lets you

00:01:12,700 --> 00:01:12,800
annotate your C and C++ header files.

00:01:12,900 --> 00:01:13,000
The architecture is sort of like this -

00:01:13,100 --> 00:01:13,200
there's native code over there, there's some magic in between,

00:01:13,300 --> 00:01:13,400
and then magically you get Ruby code and Python code out of it.

00:01:13,500 --> 00:01:13,600
Let's look a little bit about how this magic works.

00:01:13,700 --> 00:01:13,800
So FFI, sorry, SWIG works off an interface file.

00:01:13,900 --> 00:01:14,000
What it basically is is it's an annotated header file

00:01:14,100 --> 00:01:14,200
and it auto-generates code to make it work in your various languages.

00:01:14,300 --> 00:01:14,400
And how it auto-generates that code depends on every single language.

00:01:14,500 --> 00:01:14,600
So for C for Ruby builds a C extension.

00:01:14,700 --> 00:01:14,800
So maybe it won't work in JRuby.

00:01:14,900 --> 00:01:15,000
But for Ruby it actually generates C code which will call your library.

00:01:15,100 --> 00:01:15,200
For Python it's actually a C and a dot py file.

00:01:15,300 --> 00:01:15,400
For Java it builds a JNI interface.

00:01:15,500 --> 00:01:15,600
And of course you still will have the same GC problem

00:01:15,700 --> 00:01:15,800
that you had while we were discussing FFI.

00:01:15,900 --> 00:01:16,000
But in general SWIG actually works pretty well.

00:01:16,100 --> 00:01:16,200
There are a couple of Ruby gems out there

00:01:16,300 --> 00:01:16,400
that are built using SWIG.

00:01:16,500 --> 00:01:16,600
I've seen it actually used in practice for

00:01:16,700 --> 00:01:16,800
like a large company which had an algorithm

00:01:16,900 --> 00:01:17,000
it wanted to share across different programming language.

00:01:17,100 --> 00:01:17,200
They had a Python, a Java, and a Ruby sort of front-end,

00:01:17,300 --> 00:01:17,400
so what they did was build their code in C++,

00:01:17,500 --> 00:01:17,600
exposed it via SWIG and were able to use it in

00:01:17,700 --> 00:01:17,800
all these three different languages. It's really simple.

00:01:17,900 --> 00:01:18,000
So over here we have a class called rectangle

00:01:18,100 --> 00:01:18,200
which has a length and a breadth

00:01:18,300 --> 00:01:18,400
and a constructor and an int called area -

00:01:18,500 --> 00:01:18,600
and I'm sure most of you would know the implementation of this.

00:01:18,700 --> 00:01:18,800
All I need to do is add some junk at the top and the bottom and yeah,

00:01:18,900 --> 00:01:19,000
no, that's it, and magically it will kind of work.

00:01:19,100 --> 00:01:19,200
So unless I said this is a module called shape

00:01:19,300 --> 00:01:19,400
that translates to Ruby directly to a name space,

00:01:19,500 --> 00:01:19,600
I just need to say require shapes.

00:01:19,700 --> 00:01:19,800
Rectangle equals shapes dot rectangle dot new, and so on and so forth.

00:01:19,900 --> 00:01:20,000
So with SWIG it's very easy to quickly kind

00:01:20,100 --> 00:01:20,200
of generate interfaces across multiple different

00:01:20,300 --> 00:01:20,400
langues really fast, and you can do this if you are,

00:01:20,500 --> 00:01:20,600
especially if you're the maintainer of the actual native library.

00:01:20,700 --> 00:01:20,800
So if you are the maintainer of the

00:01:20,900 --> 00:01:21,000
actual native library I would recommend going with SWIG.

00:01:21,100 --> 00:01:21,200
There are other options as well.

00:01:21,300 --> 00:01:21,400
Ruby has no shortage of ways to include native things.

00:01:21,500 --> 00:01:21,600
I think an old one which has been around

00:01:21,700 --> 00:01:21,800
for a long time is dynamic load that is basically

00:01:21,900 --> 00:01:22,000
the port of C's DL open into Ruby. It's been around since forever,

00:01:22,100 --> 00:01:22,200
but I've heard a lot of reports of it

00:01:22,300 --> 00:01:22,400
being really buggy and in general I think both that and Fiddle,

00:01:22,500 --> 00:01:22,600
which is now - Fiddle is actually coming in Ruby 2 or Ruby 2.1 -

00:01:22,700 --> 00:01:22,800
that is again another way of introducing native libraries.

00:01:22,900 --> 00:01:23,000
Both of these kind of work in concept

00:01:23,100 --> 00:01:23,200
very similar to how FFI works,

00:01:23,300 --> 00:01:23,400
so I'm not gonna spend a lot of time covering them.

00:01:23,500 --> 00:01:23,600
I think Fiddle may start becoming

00:01:23,700 --> 00:01:23,800
popular soon as more and more people start using Ruby 2.

00:01:23,900 --> 00:01:24,000
I don't know if FFI and Fiddle are someday

00:01:24,100 --> 00:01:24,200
going to start merging together,

00:01:24,300 --> 00:01:24,400
but in general these are the other two options.

00:01:24,500 --> 00:01:24,600
So, TL;DR.

00:01:24,700 --> 00:01:24,800
Native extensions are fun, really easy to build.

00:01:24,900 --> 00:01:25,000
The three big tools which are C extensions, FFI and SWIG.

00:01:25,100 --> 00:01:25,200
You probably want to choose FFI if you don't maintain the library,

00:01:25,300 --> 00:01:25,400
even if it's too easy to write the code for it,

00:01:25,500 --> 00:01:25,600
but SWIG may be better if you actually maintain

00:01:25,700 --> 00:01:25,800
the library and you want to expose it to a number of people.

00:01:25,900 --> 00:01:26,000
OK, thank you. I think I actually have time for questions.

00:01:26,100 --> 00:01:26,200
How much time do I have for questions?

00:01:26,300 --> 00:01:26,400
V.O.: Ten minutes.

00:01:26,500 --> 00:01:26,600
T.D.: OK, so does anyone have any questions?

00:01:26,700 --> 00:01:26,800
Yes?

00:01:26,900 --> 00:01:27,000
QUERANT: So when you actuall write the native code,

00:01:27,100 --> 00:01:27,200
right, do you have to take it off during GIL acquir-

00:01:27,300 --> 00:01:27,400
acquiring GIL and using it yourself?

00:01:27,500 --> 00:01:27,600
T.D.: So actually that's kind of an interesting question.

00:01:27,700 --> 00:01:27,800
I think that like when it actually calls the

00:01:27,900 --> 00:01:28,000
native extensions that's all the code you write,

00:01:28,100 --> 00:01:28,200
would be considered a single Ruby call.

00:01:28,300 --> 00:01:28,400
So I'm not actually sure if the GIL is held for the entire time.

00:01:28,500 --> 00:01:28,600
I think by default the GIL would be held

00:01:28,700 --> 00:01:28,800
for the entire time your code is being executed.

00:01:28,900 --> 00:01:29,000
QUERANT: OK

00:01:29,100 --> 00:01:29,200
T.D.: Unless you say do something to create a thread and move out.

00:01:29,300 --> 00:01:29,400
QUERANT: Right, but when you're writing,

00:01:29,500 --> 00:01:29,600
especially things like the database connection-

00:01:29,700 --> 00:01:29,800
T.D.: Right.

00:01:29,900 --> 00:01:30,000
QUERANT: Right, when you have that kind of-

00:01:30,100 --> 00:01:30,200
T.D.: OK, the database connection.

00:01:30,300 --> 00:01:30,400
QUERANT: Yeah, if you have- anyway,

00:01:30,500 --> 00:01:30,600
when you have that kind of a code, right,

00:01:30,700 --> 00:01:30,800
it's not very- you would assume that somebody might

00:01:30,900 --> 00:01:31,000
have done a thread dot new and, you know,

00:01:31,100 --> 00:01:31,200
gone ahead and called the still lines of code.

00:01:31,300 --> 00:01:31,400
T.D.: Right.

00:01:31,500 --> 00:01:31,600
QUERANT: Which means, like, if you haven't taken

00:01:31,700 --> 00:01:31,800
the global interpreter lock yourself,

00:01:31,900 --> 00:01:32,000
then the chances are the same problem that you

00:01:32,100 --> 00:01:32,200
said with GC might occur.

00:01:32,300 --> 00:01:32,400
You might get pre-empted and

00:01:32,500 --> 00:01:32,600
then horrible things might have happened.

00:01:32,700 --> 00:01:32,800
So, does that mean every line,

00:01:32,900 --> 00:01:33,000
every native extension that you write,

00:01:33,100 --> 00:01:33,200
needs to take GIL because it's

00:01:33,300 --> 00:01:33,400
an obscure case of some re-doing it in a new thread?

00:01:33,500 --> 00:01:33,600
T.D.: So, actually, so, in theory, I think yes.

00:01:33,700 --> 00:01:33,800
When the code, so, OK, so most native extensions...

00:01:33,900 --> 00:01:34,000
let me just go all the way back.

00:01:34,100 --> 00:01:34,200
QUERANT: So go to the C code.

00:01:34,300 --> 00:01:34,400
T.D.: Yeah, this one, yeah?

00:01:34,500 --> 00:01:34,600
QUERANT: Right.

00:01:34,700 --> 00:01:34,800
T.D.: Right, so wht Ruby recalls automatically.

00:01:34,900 --> 00:01:35,000
When I say string will equal some other string,

00:01:35,100 --> 00:01:35,200
and as long as the code is in this method,

00:01:35,300 --> 00:01:35,400
you will be holding the GIL.

00:01:35,500 --> 00:01:35,600
I don't think anyone else can execute code during this time, unless...

00:01:35,700 --> 00:01:35,800
Actually, I'll need to get back to you.

00:01:35,900 --> 00:01:36,000
QUERANT: All right.

00:01:36,100 --> 00:01:36,200
T.D.: Let me check.

00:01:36,300 --> 00:01:36,400
QUERANT: Yeah, I mean, sure. Yeah, this was something that I-

00:01:36,500 --> 00:01:36,600
T.D.: OK, sure.

00:01:36,700 --> 00:01:36,800
QUERANT: Yeah, OK. Yeah, so, like on the same note, actually,

00:01:36,900 --> 00:01:37,000
I just want to add, your C extension,

00:01:37,100 --> 00:01:37,200
you only acquire the GIL if, in your extension,

00:01:37,300 --> 00:01:37,400
you're going to run something along the running thing.

00:01:37,500 --> 00:01:37,600
But you don't want to,

00:01:37,700 --> 00:01:37,800
you don't want the control to return to Ruby.

00:01:37,900 --> 00:01:38,000
For example, let's say you,

00:01:38,100 --> 00:01:38,200
your C extension takes a measure,

00:01:38,300 --> 00:01:38,400
and it does some image processing, actually,

00:01:38,500 --> 00:01:38,600
and you don't want, you just want the C extension

00:01:38,700 --> 00:01:38,800
to write the file to the disk and call it a day.

00:01:38,900 --> 00:01:39,000
You don't want to return that something to-

00:01:39,100 --> 00:01:39,200
Then you acquire a GIL in your extension

00:01:39,300 --> 00:01:39,400
and then that thread will run completely separate

00:01:39,500 --> 00:01:39,600
from your- which Ruby BM is it running at?

00:01:39,700 --> 00:01:39,800
Actually, so that's the only time when

00:01:39,900 --> 00:01:40,000
you will acquire a lock, if any,

00:01:40,100 --> 00:01:40,200
if you're passing any data back to Ruby.

00:01:40,300 --> 00:01:40,400
Or anyway, you pass it back, control,

00:01:40,500 --> 00:01:40,600
the control back to this thing,

00:01:40,700 --> 00:01:40,800
then you don't want to acquire the GIL yourself actually.

00:01:40,900 --> 00:01:41,000
There are constructs for that, but generally not recommended.

00:01:41,100 --> 00:01:41,200
T.D.: Yeah, so I believe what he's saying is correct.

00:01:41,300 --> 00:01:41,400
I was slightly mistaken, I think the GIL is only acquired

00:01:41,500 --> 00:01:41,600
when you enter the function.

00:01:41,700 --> 00:01:41,800
As soon as you enter the function the GIL is released,

00:01:41,900 --> 00:01:42,000
unless I'm mistaken, that's correct, right?

00:01:42,100 --> 00:01:42,200
QUERANT: That's correct.

00:01:42,300 --> 00:01:42,400
T.D.: Yeah. So, yeah. So I guess if you actually call

00:01:42,500 --> 00:01:42,600
anything that's a Ruby construct from here,

00:01:42,700 --> 00:01:42,800
you can actually call a method from within your C function body.

00:01:42,900 --> 00:01:43,000
I think at that point you'll need to re-acquire the global interpreter lock.

00:01:43,100 --> 00:01:43,200
But you're correct that GIL is only caught when you enter the method.

00:01:43,300 --> 00:01:43,400
V.O.: We have time for more questions.

00:01:43,500 --> 00:01:43,600
QUERANT: Hey Tejas, how do you test native extensions?

00:01:43,700 --> 00:01:43,800
T.D.: OK, so, it's like I said.

00:01:43,900 --> 00:01:44,000
The architecture of most of your things is sort of like this,

00:01:44,100 --> 00:01:44,200
where you have native code, Ruby-aware native code,

00:01:44,300 --> 00:01:44,400
and your actual Ruby code. Presumably you're doing something

00:01:44,500 --> 00:01:44,600
a Google test or something, to test your native code,

00:01:44,700 --> 00:01:44,800
and to test your actual Ruby code depending on what your library is.

00:01:44,900 --> 00:01:45,000
It will vary drastically.

00:01:45,100 --> 00:01:45,200
So for example, if you're writing something

00:01:45,300 --> 00:01:45,400
that connects to a database,

00:01:45,500 --> 00:01:45,600
you may want to actually step out the things that actually call.

00:01:45,700 --> 00:01:45,800
Say if you're implementing with FFI or even with a native extension,

00:01:45,900 --> 00:01:46,000
if you're making something like a database call

00:01:46,100 --> 00:01:46,200
you may actually want to mock out or stamp out the

00:01:46,300 --> 00:01:46,400
actual implementation that connects the two.

00:01:46,500 --> 00:01:46,600
But if you're doing something that's maybe not so intensive,

00:01:46,700 --> 00:01:46,800
maybe something like a JSON parsing library,

00:01:46,900 --> 00:01:47,000
what I would recommend at this level is actually writing an integration test,

00:01:47,100 --> 00:01:47,200
actually parse it in JSON and make sure it actually

00:01:47,300 --> 00:01:47,400
returns to the actual, you know, representation that you expected.

00:01:47,500 --> 00:01:47,600
So the answer to how do you test is actually it varies,

00:01:47,700 --> 00:01:47,800
very, very drastically, and I've seen like different

00:01:47,900 --> 00:01:48,000
maturities of tests across like, all of them. Does that answer your question?

00:01:48,100 --> 00:01:48,200
QUERANT: Maybe, yeah.

00:01:48,300 --> 00:01:48,400
T.D.: Anything else?

00:01:48,500 --> 00:01:48,600
OK then, I guess I-

00:01:48,700 --> 00:01:48,800

YouTube URL: https://www.youtube.com/watch?v=bI5oJr4ueQc


