Title: Garden City Ruby 2014 - Panel
Publication date: 2020-01-24
Playlist: Garden City Ruby 2014
Description: 
	Panel Members: Chad Fowler, Yogi Kulkarni, Hemant Kumar, and Baishampayan Ghose

Discussion on Programming languages and evolution of Ruby. This will be a unique opportunity to learn how good programmers learn new programming languages and as a Rubyist what we should be doing next to improve ourselves.

Help us caption & translate this video!

http://amara.org/v/FG3d/
Captions: 
	00:00:27,000 --> 00:00:34,900
HEMANT KUMAR: So I would ask our panelists to come forward and chat.

00:00:34,920 --> 00:00:41,270
So Chad is, Chad Fowler is the author of The Passionate Programmer

00:00:41,270 --> 00:00:45,070
and he has been a-

00:00:45,070 --> 00:00:46,940
CHAD FOWLER: Yes?

00:00:46,940 --> 00:00:51,560
H.K.: He's been like, he's one of the oldest,

00:00:51,560 --> 00:00:55,970
one of the oldest Ruby guys around. He's embarrassing me.

00:00:55,970 --> 00:01:01,870
C.F.: I'm one of the oldest people here. Thank you Colby (00:01:00).

00:01:01,870 --> 00:01:08,630
H.K.: And next, Yogi. Yogi is principal architect of Flipkart

00:01:08,630 --> 00:01:13,759
and he has obviously worked in one of the largest

00:01:13,759 --> 00:01:20,759
deployment serve and supply chain in Ruby, and yeah.

00:01:21,420 --> 00:01:27,490
Next person I'm gonna ask is Baishampayan Ghose, uh, BG.

00:01:27,490 --> 00:01:30,889
Is he outside? Can you, can anyone? So. You guys can sit.

00:01:30,889 --> 00:01:36,740
C.F.: Yes, what?

00:01:36,740 --> 00:01:38,889
H.K.: You guys can sit actually.

00:01:38,889 --> 00:01:42,020
C.F.: He wants us to sit down. Sorry, I'll sit.

00:01:42,020 --> 00:01:47,079
H.K.: So, yeah, our next panelist is Baishampayan Ghose.

00:01:47,079 --> 00:01:49,539
He is a polyglot programmer

00:01:49,539 --> 00:01:55,329
and he is CTO of Helpshift, a start-up running from California.

00:01:55,329 --> 00:02:02,329
And last I would like to call on Venkat Subramaniyan.

00:02:07,990 --> 00:02:11,330
He is CEO of Mahaswami Software.

00:02:11,330 --> 00:02:15,420
He has been programming in Ruby for like ten years,

00:02:15,420 --> 00:02:21,940
and for a real long time, so.

00:02:21,940 --> 00:02:28,940
OK, so we'll start the panel discussion by asking the panelists like,

00:02:30,530 --> 00:02:36,650
what is your current language of choice primarily, and why? Swami, Venkat.

00:02:36,650 --> 00:02:41,970
Venkat Subramaniyan: OK, we use primarily Ruby.

00:02:41,970 --> 00:02:45,510
We've been using Ruby for the past, I mean,

00:02:45,510 --> 00:02:48,780
writing bigger-sized products since six, seven years.

00:02:48,780 --> 00:02:51,450
But we use quite a bit of Java along with it.

00:02:51,450 --> 00:02:53,970
H.K.: Why? Like, why do you use it? (00:02:51)

00:02:53,970 --> 00:02:58,080
V.S.: Well, see there is some very, like,

00:02:58,080 --> 00:03:00,230
well-established libraries, like reporting GINs,

00:03:00,230 --> 00:03:02,650
and several stuff that you don't want to really, you know,

00:03:02,650 --> 00:03:04,290
try to match from the Ruby side.

00:03:04,290 --> 00:03:06,460
So we just bring the best of both worlds by

00:03:06,460 --> 00:03:08,040
cutting forward all the good libraries.

00:03:08,040 --> 00:03:10,830
Jewels we have used quite a bit. Jasper reports.

00:03:10,830 --> 00:03:13,570
These are all stuff for which there isn't an equivalent exist,

00:03:13,570 --> 00:03:15,890
and we just want to use the knowledge

00:03:15,890 --> 00:03:18,660
and, you know, the well-established software there,

00:03:18,660 --> 00:03:24,700
for their purpose. So that's one of the main reasons.

00:03:24,700 --> 00:03:28,930
Baishampayan Ghose: So we use multiple languages, but,

00:03:28,930 --> 00:03:32,120
Closure is our main programming language of choice.

00:03:32,120 --> 00:03:34,680
We have been using it since I think late 2008.

00:03:34,680 --> 00:03:40,750
We're one of the first companies to put Closure into production.

00:03:40,750 --> 00:03:42,760
We use Closure because a variety of reasons, but,

00:03:42,760 --> 00:03:49,130
I guess if I have to say name a few reasons, that would be,

00:03:49,130 --> 00:03:52,100
Closure lets me focus on the problem,

00:03:52,100 --> 00:03:53,900
and it pretty much gets out of the way.

00:03:53,900 --> 00:03:58,490
And there is a lot of focus on awesome things like immutability,

00:03:58,490 --> 00:04:04,160
data as a main construct for doing competition.

00:04:04,160 --> 00:04:07,370
And of course it's a lisp so I get all the power,

00:04:07,370 --> 00:04:10,630
and it's also something that runs in the JVM,

00:04:10,630 --> 00:04:15,510
so I can also leverage the awesome Java ecosystem.

00:04:15,510 --> 00:04:16,840
So yeah, but, at the same time,

00:04:16,840 --> 00:04:18,380
we do use different languages for different needs.

00:04:18,380 --> 00:04:22,350
We have used Erlang in the past, we use Go as well,

00:04:22,350 --> 00:04:27,610
and of course there is JavaScript and a bunch of other languages.

00:04:27,610 --> 00:04:29,490
H.K.: So do you think like, let's say,

00:04:29,490 --> 00:04:31,260
Closure doesn't seem to be right language for

00:04:31,260 --> 00:04:33,970
how to write utility to you know like

00:04:33,970 --> 00:04:37,820
do something on my OS X, for example.

00:04:37,820 --> 00:04:40,500
If I auto-install something or manage processes or anything.

00:04:40,500 --> 00:04:44,040
Do you think like it's a right tool for that sort of thing?

00:04:44,040 --> 00:04:47,580
B.G.: So, to build your, if you want to build a small utility,

00:04:47,580 --> 00:04:49,490
you'd need a faster start-up time,

00:04:49,490 --> 00:04:51,350
and that problem is inherent in JVM.

00:04:51,350 --> 00:04:54,510
It has nothing to do with Closure, per se.

00:04:54,510 --> 00:04:57,370
But Closure also has something called Closure Script,

00:04:57,370 --> 00:04:59,530
which lets you write whatever code that you want to write in Closure,

00:04:59,530 --> 00:05:01,280
but then the compiler compiles it down to JavaScript,

00:05:01,280 --> 00:05:07,850
and basically you can create a node.js application out of Closure code.

00:05:07,850 --> 00:05:11,230
You get all the flexibility and constructs

00:05:11,230 --> 00:05:14,250
to build abstractions that Closure provides,

00:05:14,250 --> 00:05:18,440
but you can target, you know, different run-times.

00:05:18,440 --> 00:05:21,990
So you can run, you can build a shell utility as well.

00:05:21,990 --> 00:05:22,740
C.F.: Do you actually do that?

00:05:22,740 --> 00:05:24,710
Do you like write command line programs?

00:05:24,710 --> 00:05:28,630
B.G.: We've done it a few times. We've done it a few times.

00:05:28,630 --> 00:05:30,460
It's not something that we publicly do, but yeah,

00:05:30,460 --> 00:05:33,300
Nailgun is another upload that you talked about in your talk, right.

00:05:33,300 --> 00:05:36,940
And, so yeah, so that's what we do.

00:05:36,940 --> 00:05:37,889
But there are other hacks, like tweaking

00:05:37,889 --> 00:05:39,290
the boot class paths in JVM to make the start up times faster.

00:05:39,290 --> 00:05:43,680
That's what something learning new is in Closure.

00:05:43,680 --> 00:05:48,820
There are ways of getting it, but yeah, you are,

00:05:48,820 --> 00:05:52,990
in a way, right that, by default, it's, Closure is probably not a,

00:05:52,990 --> 00:05:57,490
not the right run time for building shell utilities.

00:05:57,490 --> 00:06:01,669
H.K.: OK, so, before we move to Chad, like, you said like,

00:06:01,669 --> 00:06:03,260
all the power of lisp actually,

00:06:03,260 --> 00:06:04,380
so, can you elaborate on that?

00:06:04,380 --> 00:06:05,370
What do you mean by all the power of Lisp?

00:06:05,370 --> 00:06:09,590
B.G.: Sure. So, how many people use Emacs here?

00:06:09,590 --> 00:06:11,930
Twenty percent maybe. You do?

00:06:11,930 --> 00:06:17,230
C.F.: No, I don't personally.

00:06:17,230 --> 00:06:19,220
Never.

00:06:19,220 --> 00:06:25,480
B.G.: Never? But you talked about Emacs

00:06:25,480 --> 00:06:28,910
as well as good software systems.

00:06:28,910 --> 00:06:32,210
C.F.: Not to use, though, just as an example.

00:06:32,210 --> 00:06:36,760
B.G.: Just to talk a lot. Anyway, so Emacs as a software

00:06:36,760 --> 00:06:38,449
is thirty-five years old today,

00:06:38,449 --> 00:06:43,370
and still is in production, so to speak,

00:06:43,370 --> 00:06:44,090
you can still use it.

00:06:44,090 --> 00:06:46,740
So, what can we learn from Emacs?

00:06:46,740 --> 00:06:50,800
Well, the language is always available to use,

00:06:50,800 --> 00:06:53,949
right, so if you compare it with, let's say,

00:06:53,949 --> 00:06:56,580
Python or Java, there is a difference between

00:06:56,580 --> 00:06:59,540
compile time and run time. When you are running,

00:06:59,540 --> 00:07:06,540
the language is not available to you.

00:07:06,710 --> 00:07:09,590
You cannot, you know, manipulate the code itself

00:07:09,590 --> 00:07:14,820
while it is running, or generate new code, dynamically.

00:07:14,820 --> 00:07:21,820
So that is one thing that lisp dialect exploits by design,

00:07:22,820 --> 00:07:25,729
because they have something,

00:07:25,729 --> 00:07:27,050
a property called homoiconicity,

00:07:27,050 --> 00:07:29,650
which basically means that the code and data

00:07:29,650 --> 00:07:30,360
are pretty much the same. Even though they may not be identical,

00:07:30,360 --> 00:07:30,490
but, for all practical purposes they are the same.

00:07:30,490 --> 00:07:33,919
That means when a Closure code is running,

00:07:33,919 --> 00:07:36,250
it can manipulate itself while it's running,

00:07:36,250 --> 00:07:38,370
and it can maybe generate new code, optimize something away.

00:07:38,370 --> 00:07:41,030
So basically it lets you write code which writes more code,

00:07:41,030 --> 00:07:42,250
so, and that is something which is always preferable.

00:07:42,250 --> 00:07:44,889
It is better to write a code that writes more code

00:07:44,889 --> 00:07:51,889
than to just write code. So, and there are many other features

00:07:52,430 --> 00:07:56,389
that lisp has, for example, the language itself is so simple,

00:07:56,389 --> 00:08:01,259
like there are just few primitives to understand and learn about.

00:08:01,259 --> 00:08:02,540
Syntax is pretty much non-existent,

00:08:02,540 --> 00:08:04,009
and very simple to understand and learn.

00:08:04,009 --> 00:08:09,139
And that really reduces a lot of cognitive overload

00:08:09,139 --> 00:08:09,900
that some languages might introduce.

00:08:09,900 --> 00:08:11,970
So yeah, I mean, these are probably a few superficial advantages.

00:08:11,970 --> 00:08:17,699
I can go deep into it, but maybe we can talk about it after.

00:08:17,699 --> 00:08:24,699
H.K.: Yeah, so, Chad, like, what is your poison of choice?

00:08:30,000 --> 00:08:32,430
C.F.: My poison of choice?

00:08:32,430 --> 00:08:34,669
H.K.: Yeah.

00:08:34,669 --> 00:08:37,750
C.F.: I guess, it's hard to answer that question.

00:08:37,750 --> 00:08:39,240
I don't have an answer, right?

00:08:39,240 --> 00:08:43,550
The one single answer I could give you is anything except for Ruby.

00:08:43,550 --> 00:08:44,240
H.K.: OK.

00:08:44,240 --> 00:08:49,170
C.F.: And I mean that very seriously.

00:08:49,170 --> 00:08:53,670
I remember in 2007, I was at MountainWest Ruby Conference,

00:08:53,670 --> 00:08:57,440
the first one, that Coby was talking about earlier,

00:08:57,440 --> 00:09:00,520
and I did a keynote, my first- no, it wasn't my first keynote,

00:09:00,520 --> 00:09:02,330
it was my first Ruby Conference keynote.

00:09:02,330 --> 00:09:06,020
It was about, like, what do we do next, after Ruby?

00:09:06,020 --> 00:09:10,260
And I was already deep in the like toil

00:09:10,260 --> 00:09:13,520
and stress of being worried that I identified

00:09:13,520 --> 00:09:16,310
too heavily with Ruby, in 2007.

00:09:16,310 --> 00:09:19,120
So I wanted to like get out of the Ruby thing

00:09:19,120 --> 00:09:21,480
and not be the Ruby guy,

00:09:21,480 --> 00:09:23,890
and I'm still desperately trying to do that.

00:09:23,890 --> 00:09:27,000
But, no, I mean, like, I said,

00:09:27,000 --> 00:09:28,620
when I was speaking earlier,

00:09:28,620 --> 00:09:35,620
I'm using Closure, Scala, Node, Java, Objective C, Ruby, Erlang, everything,

00:09:35,760 --> 00:09:40,490
at work right now. I think probably what I'll learn next

00:09:40,490 --> 00:09:42,610
really seriously is Objective C.

00:09:42,610 --> 00:09:47,290
But I'm going to try to use it, even on the server,

00:09:47,290 --> 00:09:50,140
as like a language to develop services in,

00:09:50,140 --> 00:09:52,300
just as an experiment so I can learn it better

00:09:52,300 --> 00:09:55,089
and do better job on the clients.

00:09:55,089 --> 00:09:58,200
H.K.: So like not Ruby?

00:09:58,200 --> 00:10:01,450
Is it because like you already had kind of a Ruby like,

00:10:01,450 --> 00:10:02,390
you obviously work with Ruby as like with the,

00:10:02,390 --> 00:10:02,520
along with Dave Thomas, and all of these guys,

00:10:02,520 --> 00:10:08,700
you were one of the earlier adopters of Ruby, so like, are-

00:10:08,700 --> 00:10:11,870
C.F.: Yeah, because I will never learn anything else about Ruby,

00:10:11,870 --> 00:10:13,540
cause I know everything.

00:10:13,540 --> 00:10:17,740
No, it's- I'm always suspicious of myself

00:10:17,740 --> 00:10:22,580
when I identify too heavily with anything extrinsic to me.

00:10:22,580 --> 00:10:24,490
Like for me to say I am a Ruby programmer-

00:10:24,490 --> 00:10:27,700
if I say that, I feel bad, and I know that I've made a mistake.

00:10:27,700 --> 00:10:30,570
I know that I'm creating some rigidity of value

00:10:30,570 --> 00:10:36,200
that is ultimately counter productive to my success

00:10:36,200 --> 00:10:38,870
and to the success of people around me.

00:10:38,870 --> 00:10:41,950
So like I've been doing more Java in the past month

00:10:41,950 --> 00:10:47,459
than Ruby, which I used to do full time in 1999.

00:10:47,459 --> 00:10:49,760
And it's been a really good freeing thing,

00:10:49,760 --> 00:10:53,230
like I am not a Ruby programmer, I am a programmer,

00:10:53,230 --> 00:10:54,459
and even that is kind of limiting,

00:10:54,459 --> 00:10:57,209
because I'm more and less than that at the same time.

00:10:57,209 --> 00:10:59,640
So it's not so much that I'm worried about Ruby itself,

00:10:59,640 --> 00:11:01,209
it's that I'm worried about putting myself

00:11:01,209 --> 00:11:03,450
into a bucket that I can't get out of,

00:11:03,450 --> 00:11:07,410
even if it's a subconscious problem.

00:11:07,410 --> 00:11:13,580
H.K.: OK, Yogi. Yeah, so what do you-

00:11:13,580 --> 00:11:14,330
Yogi Kulkarni: Sure.

00:11:14,330 --> 00:11:16,740
So, if you're asking about personal choice then,

00:11:16,740 --> 00:11:19,279
sure, you know I like coding in Ruby.

00:11:19,279 --> 00:11:21,839
I just love it because it's compact.

00:11:21,839 --> 00:11:26,339
I feel the translation from my thoughts to code is shortest in Ruby,

00:11:26,339 --> 00:11:28,860
so it just feels very natural.

00:11:28,860 --> 00:11:32,550
But that said, I think I've moved the last seven years

00:11:32,550 --> 00:11:37,040
from being a kind of a language geek, of sorts,

00:11:37,040 --> 00:11:40,110
not really, but, I used to love program language theory

00:11:40,110 --> 00:11:42,029
and getting into stuff like that,

00:11:42,029 --> 00:11:45,870
but to actually not caring too much about it.

00:11:45,870 --> 00:11:47,930
I think programming languages are good,

00:11:47,930 --> 00:11:50,700
and they kind of get you excited,

00:11:50,700 --> 00:11:54,600
but when it comes to actually solving hard problems,

00:11:54,600 --> 00:11:57,040
it's the ecosystem that matters around that language.

00:11:57,040 --> 00:11:59,959
Things like the tools, the profilers, the monitoring tools,

00:11:59,959 --> 00:12:03,519
debuggers, you know that's the stuff which no language

00:12:03,519 --> 00:12:06,080
is gonna save you when you're in production, right.

00:12:06,080 --> 00:12:06,920
So you just need to have that,

00:12:06,920 --> 00:12:10,200
the maturity of an ecosystem is really important there.

00:12:10,200 --> 00:12:12,709
Which is why we keep going back to the JVM over and over,

00:12:12,709 --> 00:12:15,930
and even the new languages are being built on the JVM as,

00:12:15,930 --> 00:12:19,290
it's for exactly that reason.

00:12:19,290 --> 00:12:21,399
But among the newer languages on the JVM,

00:12:21,399 --> 00:12:25,080
I'm actually surprised that I've- so, I'm kind of

00:12:25,080 --> 00:12:26,209
intrigued by Closure and Scala.

00:12:26,209 --> 00:12:28,990
We actually looked at Scala very carefully

00:12:28,990 --> 00:12:32,230
for the system I spoke about.

00:12:32,230 --> 00:12:36,269
But I didn't think it gave the kind of jump.

00:12:36,269 --> 00:12:39,980
I felt was kind of marginal,

00:12:39,980 --> 00:12:42,600
the improvement over just doing good Java,

00:12:42,600 --> 00:12:44,680
that Scala gave, that's arguable.

00:12:44,680 --> 00:12:47,290
There's a lot of language features there,

00:12:47,290 --> 00:12:48,640
possibly too many language features,

00:12:48,640 --> 00:12:51,560
which is one of my concerns.

00:12:51,560 --> 00:12:53,209
But Closure, we looked at that also,

00:12:53,209 --> 00:12:54,740
but we didn't look, we didn't actually

00:12:54,740 --> 00:12:56,529
take it that seriously, because of basically

00:12:56,529 --> 00:12:57,640
the prefix notation being too alien.

00:12:57,640 --> 00:12:59,589
We wanted something block structured

00:12:59,589 --> 00:13:04,200
for people moving from Java to Ruby.

00:13:04,200 --> 00:13:05,760
So I think, yeah,

00:13:05,760 --> 00:13:08,709
those are the kind of things that are on my mind.

00:13:08,709 --> 00:13:12,779
H.K.: OK. So, Ghose, do you- I'm gonna call you BG, OK?

00:13:12,779 --> 00:13:15,279
Yeah, so, BG, do you ever like,

00:13:15,279 --> 00:13:19,190
the programming languages do not matter all that much,

00:13:19,190 --> 00:13:22,760
do you think the state of it are like if you improved like-

00:13:22,760 --> 00:13:28,190
B.G.: I'm told Alan Pearl is here,

00:13:28,190 --> 00:13:32,140
and he basically said that programming language

00:13:32,140 --> 00:13:36,019
basically shapes the way you think about solving problems.

00:13:36,019 --> 00:13:37,250
So even if you do not use Closure or Scala

00:13:37,250 --> 00:13:37,570
or whatever fancy language that comes out,

00:13:37,570 --> 00:13:42,459
you should try it out because ultimately

00:13:42,459 --> 00:13:45,360
you're trying to solve a problem, right.

00:13:45,360 --> 00:13:47,360
You have the problem at hand,

00:13:47,360 --> 00:13:50,329
and you'd like to look at the problem from different perspectives.

00:13:50,329 --> 00:13:52,690
See if you only have one way of looking at the problem,

00:13:52,690 --> 00:13:56,149
then you know, by repeating the same approach a

00:13:56,149 --> 00:13:59,010
thousand times is not going to help you.

00:13:59,010 --> 00:13:59,370
You should look at different ways of

00:13:59,370 --> 00:14:00,200
maybe approaching the problem,

00:14:00,200 --> 00:14:04,740
and even understanding the problem itself.

00:14:04,740 --> 00:14:11,740
Simple example, parallel processing can be done using threads.

00:14:13,370 --> 00:14:16,070
You can use quarantines.

00:14:16,070 --> 00:14:17,459
You can use CSB, you can use Actor.

00:14:17,459 --> 00:14:18,290
What should I use, given any situation?

00:14:18,290 --> 00:14:19,350
So even if that- if I don't even know about Actors or CSB,

00:14:19,350 --> 00:14:20,470
I'll never be exposed to that line of thought,

00:14:20,470 --> 00:14:24,730
so that code is basically to learn a language,

00:14:24,730 --> 00:14:27,700
not to just switch wholesale to that language,

00:14:27,700 --> 00:14:34,390
but to be able to appreciate new ways of looking at solving problems.

00:14:34,390 --> 00:14:37,350
Y.K.: So I think that's a great point, and when I,

00:14:37,350 --> 00:14:39,899
kind of, I missed mentioning this, see,

00:14:39,899 --> 00:14:42,160
when I was a program language geek,

00:14:42,160 --> 00:14:46,160
I think the one great important inspiration for me was SICP,

00:14:46,160 --> 00:14:49,180
right, structural interpretation of computer programs.

00:14:49,180 --> 00:14:52,800
And that's something which, again, goes back to what is,

00:14:52,800 --> 00:14:55,640
what are the fundamental abstractions again,

00:14:55,640 --> 00:14:58,310
you can reach out to solve problems of different natures, right.

00:14:58,310 --> 00:15:01,279
And that was the crux of it, you can use data as abstraction,

00:15:01,279 --> 00:15:02,120
procedures are abstraction,

00:15:02,120 --> 00:15:05,740
stream processing and actually creating languages of your own.

00:15:05,740 --> 00:15:08,790
So the point is that there are far more paradigms, right,

00:15:08,790 --> 00:15:11,320
and I think getting a grasp of those paradigms is very critical,

00:15:11,320 --> 00:15:13,140
but for that you don't necessarily need to go

00:15:13,140 --> 00:15:16,019
every new languages around for you to see what

00:15:16,019 --> 00:15:18,579
ideas are implemented well in which language,

00:15:18,579 --> 00:15:19,269
what can you adopt.

00:15:19,269 --> 00:15:21,269
Take for example, after reading SICP,

00:15:21,269 --> 00:15:24,220
I think my Java programming became so much better,

00:15:24,220 --> 00:15:28,649
I have said using more anonymous functions or classes,

00:15:28,649 --> 00:15:34,870
yeah, that's ugly but, so yeah. So I totally agree with that.

00:15:34,870 --> 00:15:39,000
H.K. So we, you talked about like,

00:15:39,000 --> 00:15:42,850
how many of you heard of like something like,

00:15:42,850 --> 00:15:45,290
or used a after patch in full or any sort of concurrent programming,

00:15:45,290 --> 00:15:46,810
can we have a show of hands?

00:15:46,810 --> 00:15:50,300
OK, so, anybody wants to explain like yeah?

00:15:50,300 --> 00:15:52,920
B.G.: There is nothing to explain.

00:15:52,920 --> 00:15:56,600
Just go and read on Wikipedia.

00:15:56,600 --> 00:15:59,399
C.F.: Or DFM.

00:15:59,399 --> 00:16:03,139
B.G.: Or DFM, yeah.

00:16:03,139 --> 00:16:06,440
H.K.: So. Which language you think like does

00:16:06,440 --> 00:16:09,800
the whole active pattern problem programming properly?

00:16:09,800 --> 00:16:13,490
B.G.: So Actors are well implemented in Erlang,

00:16:13,490 --> 00:16:18,930
and Echo, if you are using Scala, so take a look at it.

00:16:18,930 --> 00:16:20,600
And again this is not a single bullet,

00:16:20,600 --> 00:16:22,050
again go back to your own basics,

00:16:22,050 --> 00:16:23,240
Fred Brooks told you guys many years back,

00:16:23,240 --> 00:16:23,980
go back to your basics. (00:16:28 - ??)

00:16:23,980 --> 00:16:25,100
So Actors will not solve all kinds of problems

00:16:25,100 --> 00:16:25,579
for you but you should be aware that there is

00:16:25,579 --> 00:16:25,620
another abstraction that I could probably leverage

00:16:25,620 --> 00:16:32,620
to solve whatever problem that I have and can.

00:16:38,290 --> 00:16:43,100
CSP is another thing that I briefly alluded to.

00:16:43,100 --> 00:16:46,550
That's something that is embodied in Go.

00:16:46,550 --> 00:16:50,529
So Yogi just said that you don't need to learn a programming language,

00:16:50,529 --> 00:16:54,810
but look at systems where all these ideas are well-implemented,

00:16:54,810 --> 00:16:58,250
but I would also argue that not all ideas

00:16:58,250 --> 00:17:01,740
can be implemented as well in all languages.

00:17:01,740 --> 00:17:05,100
So you cannot, for example, Java does not, I mean,

00:17:05,100 --> 00:17:07,679
Java has something called Lambdas, but Java hasn't,

00:17:07,679 --> 00:17:09,370
does not have any of those functions.

00:17:09,370 --> 00:17:10,949
So if I really wanted to understand the value

00:17:10,949 --> 00:17:16,079
and virtues of any of those functions,

00:17:16,079 --> 00:17:18,410
I can't learn it through Java.

00:17:18,410 --> 00:17:20,240
The closest I'll get to is dependent injection,

00:17:20,240 --> 00:17:23,069
but that is yet another level of abstraction,

00:17:23,069 --> 00:17:28,799
which basically removes me part of the way from the core goal, right.

00:17:28,799 --> 00:17:34,240
So there are languages which are design to level certain principles.

00:17:34,240 --> 00:17:38,730
Go for example is built on top of CSP,

00:17:38,730 --> 00:17:41,419
and the channels are a first class thing,

00:17:41,419 --> 00:17:41,760
Erlang, also has something similar.

00:17:41,760 --> 00:17:45,140
So maybe learning those languages will expose you

00:17:45,140 --> 00:17:47,919
to those ideas much better than something other language.

00:17:47,919 --> 00:17:48,860
H.K.: Chad, you want to-

00:17:48,860 --> 00:17:50,040
C.F.: Yeah, I think from a,

00:17:50,040 --> 00:17:52,770
from the perspective of learning the paradigm,

00:17:52,770 --> 00:17:55,340
I think Yogi is lucky that he is smart enough

00:17:55,340 --> 00:17:58,850
to read a book and then get all these things.

00:17:58,850 --> 00:18:00,700
My experience is not the same.

00:18:00,700 --> 00:18:01,799
I'm honest about that.

00:18:01,799 --> 00:18:02,660
I don't think you're not being sincere,

00:18:02,660 --> 00:18:07,360
I think some people, including me,

00:18:07,360 --> 00:18:09,299
have to actually use the thing,

00:18:09,299 --> 00:18:11,950
not just the language but the paradigm.

00:18:11,950 --> 00:18:15,910
So like I can read about Actors in five minutes.

00:18:15,910 --> 00:18:20,350
I totally understand it from a theoretical perspective.

00:18:20,350 --> 00:18:21,090
But it takes awhile,

00:18:21,090 --> 00:18:22,490
and it takes actually trying

00:18:22,490 --> 00:18:27,090
for me to really get where it makes sense, you know.

00:18:27,090 --> 00:18:28,299
B.G.: To appreciate it.

00:18:28,299 --> 00:18:31,200
and also to appreciate the edges of it.

00:18:31,200 --> 00:18:33,630
So I actually think like,

00:18:33,630 --> 00:18:35,990
I've been trying to get out of Ruby

00:18:35,990 --> 00:18:36,860
as I've been saying.

00:18:36,860 --> 00:18:39,150
I mean the truth is I have learned,

00:18:39,150 --> 00:18:40,820
I don't know how many programming languages

00:18:40,820 --> 00:18:42,290
since I started doing Ruby,

00:18:42,290 --> 00:18:44,130
but I have never stuck to one.

00:18:44,130 --> 00:18:45,809
I have, but you know,

00:18:45,809 --> 00:18:48,010
I have rarely stuck to one long enough to where

00:18:48,010 --> 00:18:50,780
I really, really thought like that,

00:18:50,780 --> 00:18:53,160
and like the best case scenario for me

00:18:53,160 --> 00:18:58,790
in picking up these other paradigms is to like

00:18:58,790 --> 00:19:03,570
get so into Go programming that then I go back to Ruby,

00:19:03,570 --> 00:19:07,290
and I go to do something, and I don't try to implement channels,

00:19:07,290 --> 00:19:10,890
I just say, damn it, channels aren't here, I'm frustrated now.

00:19:10,890 --> 00:19:13,940
And it, I see that this language isn't perfect

00:19:13,940 --> 00:19:15,190
because no language is.

00:19:15,190 --> 00:19:17,150
But you can't get to that point,

00:19:17,150 --> 00:19:19,070
and that's like where the maturity comes from,

00:19:19,070 --> 00:19:21,860
where you're not in love with any certain thing,

00:19:21,860 --> 00:19:24,080
and you're, you see the entire landscape,

00:19:24,080 --> 00:19:26,299
and this is a part of why I can't answer the question

00:19:26,299 --> 00:19:28,070
of what my go-to language is right now.

00:19:28,070 --> 00:19:30,870
Like I'm doing a lot of Scala because there

00:19:30,870 --> 00:19:35,419
are certain things that I'm working on that work really well with Actors.

00:19:35,419 --> 00:19:39,130
Like I can conceptualize them with Actors and that's what I'm gonna-

00:19:39,130 --> 00:19:42,190
I'm gonna write it in Scala because we already have the JVM,

00:19:42,190 --> 00:19:44,549
so therefore it's easy to do Scala versus Erlang.

00:19:44,549 --> 00:19:48,200
H.K.: But still there's a problem here.

00:19:48,200 --> 00:19:50,220
Like the way you approach programming language

00:19:50,220 --> 00:19:53,090
for example like in Ruby world for example,

00:19:53,090 --> 00:19:56,510
like Eric Hodel or [00"19"54] ??

00:19:56,510 --> 00:19:59,080
these guys are maintaining tools that you have written actually,

00:19:59,080 --> 00:20:02,260
for many years back, and those tools all have,

00:20:02,260 --> 00:20:04,770
like for example Ruby gems didn't have proper

00:20:04,770 --> 00:20:08,630
test suite for awhile actually, and like the building-

00:20:08,630 --> 00:20:12,220
C.F.: That's because tests are a design smell.

00:20:12,220 --> 00:20:13,179
That's why.

00:20:13,179 --> 00:20:17,970
H.K.: My point is like building a tools like of a language,

00:20:17,970 --> 00:20:19,460
around a language takes time actually.

00:20:19,460 --> 00:20:21,780
Do you think like for example like Eric Hodel

00:20:21,780 --> 00:20:24,289
and these guys are probably working with this thing

00:20:24,289 --> 00:20:26,370
for like nine years or so,

00:20:26,370 --> 00:20:28,000
and they're still doing it, right,

00:20:28,000 --> 00:20:30,280
so how do you like, if, how do you fix that?

00:20:30,280 --> 00:20:34,280
Like you need to stay long-term in a language

00:20:34,280 --> 00:20:37,460
to really change it, right, or like am I wrong here?

00:20:37,460 --> 00:20:40,220
C.F.: You mean you need to stay in it to change the language itself?

00:20:40,220 --> 00:20:42,360
H.K.: To change the language or build like

00:20:42,360 --> 00:20:46,690
the infrastructure or the libraries, gems to support it.

00:20:46,690 --> 00:20:48,169
C.F.: Yeah, somebody does.

00:20:48,169 --> 00:20:50,530
It doesn't have to be me, right.

00:20:50,530 --> 00:20:52,770
B.G.: Again, so let me add something to what Chad said.

00:20:52,770 --> 00:20:57,490
So Chad said that I don't want to remain a Ruby programmer.

00:20:57,490 --> 00:21:00,460
I think what he means is the Ruby mindset, OK,

00:21:00,460 --> 00:21:03,650
or any mindset thereof. It's not about writing,

00:21:03,650 --> 00:21:05,010
just coding that language.

00:21:05,010 --> 00:21:05,820
So you can still be a Ruby programmer for twenty years,

00:21:05,820 --> 00:21:10,370
but that doesn't mean you keep the same mindset

00:21:10,370 --> 00:21:13,490
all the time, right. There are things which are not even new,

00:21:13,490 --> 00:21:15,100
but we are not discovering those things

00:21:15,100 --> 00:21:17,010
because we are not looking beyond Ruby.

00:21:17,010 --> 00:21:18,850
H.K.: Can anyone else, sorry -

00:21:18,850 --> 00:21:21,980
can anyone else carry the mic

00:21:21,980 --> 00:21:26,020
and give it to the audience actually because- there's no mic

00:21:26,020 --> 00:21:26,860
B.G.: It's not just about Ruby, per se, right,

00:21:26,860 --> 00:21:27,610
it's about any- it's applicable to any language,

00:21:27,610 --> 00:21:31,809
like JavaScript, or Scala, or even Java for that matter.

00:21:31,809 --> 00:21:36,230
V.S.: So this, this is kind of intrinsic to,

00:21:36,230 --> 00:21:39,610
something intrinsic to all we actually select

00:21:39,610 --> 00:21:42,940
a language or set of languages to develop these tastes,

00:21:42,940 --> 00:21:44,070
depending on the nature of the problem,

00:21:44,070 --> 00:21:47,090
I guess you pick what is called like a language

00:21:47,090 --> 00:21:50,260
to which other languages can actually circle around

00:21:50,260 --> 00:21:52,580
and support various smaller problems,

00:21:52,580 --> 00:21:55,250
whereas this core language that you're picking is solving

00:21:55,250 --> 00:21:58,130
like majority of the nature of the problem.

00:21:58,130 --> 00:21:59,520
For example, web application,

00:21:59,520 --> 00:22:00,720
but you got some parallelism stuff

00:22:00,720 --> 00:22:03,240
that you need to do or you got some

00:22:03,240 --> 00:22:04,940
functional programming stuff you need to do like Scala,

00:22:04,940 --> 00:22:07,039
so you probably pick one language, well like,

00:22:07,039 --> 00:22:10,360
Ruby, as to kind of like hold everything together,

00:22:10,360 --> 00:22:12,020
but you do have these other languages in which

00:22:12,020 --> 00:22:12,309
you actually solve problems differently.

00:22:12,309 --> 00:22:18,510
So it's more of- but different problems in some contexts,

00:22:18,510 --> 00:22:19,880
Scala may be the code language,

00:22:19,880 --> 00:22:21,500
and you may want to wrap it around Ruby

00:22:21,500 --> 00:22:23,890
a little bit or maybe other things a little bit as well,

00:22:23,890 --> 00:22:26,309
so it's more of starting from the

00:22:26,309 --> 00:22:28,440
architecture of the nature of the problem,

00:22:28,440 --> 00:22:30,970
but being polyglots, you have this choice now,

00:22:30,970 --> 00:22:32,919
not to implement and struggle with one language

00:22:32,919 --> 00:22:34,970
like you just talked about example, but I wish

00:22:34,970 --> 00:22:37,110
channels were there in one particular case.

00:22:37,110 --> 00:22:39,780
But now you could pick, if you can become a polyglot

00:22:39,780 --> 00:22:42,400
and learn these other languages to a good degree,

00:22:42,400 --> 00:22:44,580
you could pick other languages to compliment it

00:22:44,580 --> 00:22:46,610
and solve those specific problems. So this seems

00:22:46,610 --> 00:22:49,130
to be an approach that's kind of intrinsically

00:22:49,130 --> 00:22:50,169
developing right now.

00:22:50,169 --> 00:22:55,470
QUERANT: I have a point very close to what you're saying.

00:22:55,470 --> 00:22:59,940
Like based on, like especially what you said about languages, right.

00:22:59,940 --> 00:23:04,280
Like a general message could be use the right tool

00:23:04,280 --> 00:23:07,360
for the right thing kind of a thing,

00:23:07,360 --> 00:23:12,919
but the problem could be that not everyone can pick up,

00:23:12,919 --> 00:23:14,539
so when you go into a code based on,

00:23:14,539 --> 00:23:16,549
let's say, five different languages are being used

00:23:16,549 --> 00:23:19,360
for the right kind of problems,

00:23:19,360 --> 00:23:20,950
so they are doing the right thing,

00:23:20,950 --> 00:23:22,440
but for someone to go into that code base

00:23:22,440 --> 00:23:24,690
and pick it up would become very hard right,

00:23:24,690 --> 00:23:26,990
because not everybody's turned in that way.

00:23:26,990 --> 00:23:30,039
So that's like, so polyglot comes with a very heavy cost

00:23:30,039 --> 00:23:31,789
of being able to replace yourself.

00:23:31,789 --> 00:23:34,130
At least that's been my experience,

00:23:34,130 --> 00:23:35,549
so that's my first question,

00:23:35,549 --> 00:23:40,190
and like adding onto that like it's very easy

00:23:40,190 --> 00:23:43,530
like you said you know like to pick up a book,

00:23:43,530 --> 00:23:44,960
read through it, go through some you know

00:23:44,960 --> 00:23:47,110
tutorials or whatever it is but like Yogi

00:23:47,110 --> 00:23:49,299
was saying how his team had a,

00:23:49,299 --> 00:23:51,409
they needed about three to four months

00:23:51,409 --> 00:23:53,630
to start writing idiomatic Ruby, right,

00:23:53,630 --> 00:23:55,070
and that is a big deal,

00:23:55,070 --> 00:23:56,539
because in those three to four months

00:23:56,539 --> 00:23:59,950
it's critical that you keep churning out code, right.

00:23:59,950 --> 00:24:01,309
You'll kill yourself or you can't

00:24:01,309 --> 00:24:04,390
come to a halt because now you're getting this new language on board.

00:24:04,390 --> 00:24:07,820
You guys had the luxury of having an existing system,

00:24:07,820 --> 00:24:09,690
which was, and you were replacing that system,

00:24:09,690 --> 00:24:12,100
but that's not necessarily always the case.

00:24:12,100 --> 00:24:17,330
You have to write, so- yeah, so

00:24:17,330 --> 00:24:17,409
H.K.: [indecipherable] (00:24:14)

00:24:17,409 --> 00:24:19,659
QUERANT: Yeah, so like my second point was around, like,

00:24:19,659 --> 00:24:22,809
that was the first question for polyglot recruiting

00:24:22,809 --> 00:24:24,240
and things like that would become very hard,

00:24:24,240 --> 00:24:25,929
how do you know that.

00:24:25,929 --> 00:24:29,330
Second, it's easy to pick up a language on a theoretical sense,

00:24:29,330 --> 00:24:31,980
but to be able to start writing idiomatic programs

00:24:31,980 --> 00:24:35,870
while also developing production-quality code,

00:24:35,870 --> 00:24:39,460
do you guys have any experience about how you got that working?

00:24:39,460 --> 00:24:42,650
H.K.: That was the second question here that

00:24:42,650 --> 00:24:46,809
I was about to ask actually, which was like,

00:24:46,809 --> 00:24:48,020
at least one part of, but like,

00:24:48,020 --> 00:24:50,890
how does an organization adopt a new you know like language?

00:24:50,890 --> 00:24:51,570
For example in Flipkart, like,

00:24:51,570 --> 00:24:54,490
or the company where all of us work,

00:24:54,490 --> 00:24:56,600
like you know like there's a,

00:24:56,600 --> 00:24:58,299
in January a programmer decides I'm going to build

00:24:58,299 --> 00:25:00,360
this program in Erlang or I'm going to build this thing

00:25:00,360 --> 00:25:02,770
in Go and there's nobody else Go,

00:25:02,770 --> 00:25:04,250
nobody else doing Go,

00:25:04,250 --> 00:25:06,270
so as like you guys,

00:25:06,270 --> 00:25:08,909
a senior person in your respective companies,

00:25:08,909 --> 00:25:12,090
so do you listen to that guy or -

00:25:12,090 --> 00:25:15,650
our deployment system is attuned for like JVM deployment

00:25:15,650 --> 00:25:19,789
or Ruby deployment and whole package management or whatever,

00:25:19,789 --> 00:25:21,240
and don't write this.

00:25:21,240 --> 00:25:23,789
So there is like an aspect of like adopting a new technology,

00:25:23,789 --> 00:25:28,380
hiring, you know like the skill, the idea of entry,

00:25:28,380 --> 00:25:35,380
like in code business which are like- so how do you tackle that problem in general?

00:25:36,390 --> 00:25:42,230
Y.K.: So it's a hard problem, right. So at Flipkart,

00:25:42,230 --> 00:25:44,640
we were already fairly polyglot,

00:25:44,640 --> 00:25:49,190
for example we all, the website is in PHP,

00:25:49,190 --> 00:25:50,970
the search engine is in Closure,

00:25:50,970 --> 00:25:53,140
the UGC system is written in Scala,

00:25:53,140 --> 00:25:54,880
Java is all over the place,

00:25:54,880 --> 00:25:56,450
Ruby came into the supply chain,

00:25:56,450 --> 00:25:58,640
node.js is there in the seller platform and more.

00:25:58,640 --> 00:26:00,280
So we were already there,

00:26:00,280 --> 00:26:02,520
but we actually ran into a few problems there.

00:26:02,520 --> 00:26:07,190
So when, I think the question of technology selection

00:26:07,190 --> 00:26:08,710
is actually quite critical.

00:26:08,710 --> 00:26:10,780
Very often a lot of it is driven by,

00:26:10,780 --> 00:26:14,809
is mostly blog-driven decision making,

00:26:14,809 --> 00:26:20,640
and that is, that can be quite scary.

00:26:20,640 --> 00:26:23,169
So we've started to put in some kind of process,

00:26:23,169 --> 00:26:24,590
it's hard, it's not worked so far.

00:26:24,590 --> 00:26:26,059
We've been trying for one year

00:26:26,059 --> 00:26:27,179
and the process is like,

00:26:27,179 --> 00:26:29,220
you know OK go up to somebody else in the team

00:26:29,220 --> 00:26:30,870
and just ask them, just bounce off your thoughts

00:26:30,870 --> 00:26:33,539
first before you kind of take up a new system,

00:26:33,539 --> 00:26:34,330
a new technology.

00:26:34,330 --> 00:26:38,419
So we tried to formalize that, we failed miserably at it.

00:26:38,419 --> 00:26:41,490
But right now what we have set focus on is interfaces.

00:26:41,490 --> 00:26:46,370
So we've become fairly diligent about

00:26:46,370 --> 00:26:48,690
making sure that the interface and contracts are good,

00:26:48,690 --> 00:26:50,570
building systems, and then the systems can call independently,

00:26:50,570 --> 00:26:51,600
whatever tech stack they use,

00:26:51,600 --> 00:26:53,570
as long as the team is committed to it,

00:26:53,570 --> 00:26:56,320
that's not a completely way-out language.

00:26:56,320 --> 00:26:59,169
So we moved from being predominantly

00:26:59,169 --> 00:27:02,549
thrift-oriented interfaces to HTTP,

00:27:02,549 --> 00:27:02,789
and that's added a huge amount of value.

00:27:02,789 --> 00:27:06,980
QUERANT: Can you say what thrift is? (00:27:06 - indecipherable)

00:27:06,980 --> 00:27:10,770
Y.K.: Sure. So Thrift is a binding protocol

00:27:10,770 --> 00:27:12,070
which came out of Facebook I think,

00:27:12,070 --> 00:27:15,169
so it basically gives you both RPCM point

00:27:15,169 --> 00:27:16,580
and a data utilization mechanism,

00:27:16,580 --> 00:27:21,620
so it's basically like Corba,

00:27:21,620 --> 00:27:23,240
but it's, so it basically gives you a fast, uh-

00:27:23,240 --> 00:27:25,350
C.F.: These people are too young for that actually.

00:27:25,350 --> 00:27:28,179
Y.K.: Oops. What is Corba? Yeah.

00:27:28,179 --> 00:27:31,029
C.F.: Do not ask that question.

00:27:31,029 --> 00:27:34,470
B.G.: That'll be a big panel discussion by itself, right.

00:27:34,470 --> 00:27:36,190
C.F.: You have to be at least twenty-one to hear

00:27:36,190 --> 00:27:38,950
about Corba and not everyone in this room is twenty-one.

00:27:38,950 --> 00:27:44,429
Y.K.: Protocol buffers. It's more like that, OK anyway. So-

00:27:44,429 --> 00:27:46,650
C.F.: I think connection is open too, right-

00:27:46,650 --> 00:27:47,200
Y.K.: Sorry?

00:27:47,200 --> 00:27:49,460
C.F.: You can keep a long-running PCP connection with that.

00:27:49,460 --> 00:27:54,070
Y.K.: With Thrift you can do it, yes I think so. Yes.

00:27:54,070 --> 00:27:57,100
C.F.: You can keep a long-running PCP connection open too,

00:27:57,100 --> 00:28:00,480
which makes performance better than HTTP in some cases.

00:28:00,480 --> 00:28:03,789
Y.K.: Right, but if you already moved to HTTP 1.1%

00:28:03,789 --> 00:28:04,890
connections that's kind of taken care of.

00:28:04,890 --> 00:28:07,559
So yeah most modern libraries have that. So-

00:28:07,559 --> 00:28:09,900
H.K.: We are digressing I think-

00:28:09,900 --> 00:28:11,850
Y.K.: Yeah, where were we?

00:28:11,850 --> 00:28:13,440
C.F.: Let's keep digressing, let's go.

00:28:13,440 --> 00:28:16,750
Y.K.: We were talking about the language and like the context-

00:28:16,750 --> 00:28:19,190
Y.K.: Right, so we become pretty delusioned about contacts,

00:28:19,190 --> 00:28:23,590
so HTTP and the, and actually having sensible rest end points

00:28:23,590 --> 00:28:26,240
and resources has become kind of defacto,

00:28:26,240 --> 00:28:27,970
and that's actually helped a lot.

00:28:27,970 --> 00:28:29,940
So systems within Flipkart are extremely open,

00:28:29,940 --> 00:28:32,970
you can actually query them pretty easily to extract data,

00:28:32,970 --> 00:28:37,240
not push data to it, but yeah, so I think that works.

00:28:37,240 --> 00:28:41,409
And then each team can independently take decisions

00:28:41,409 --> 00:28:42,340
with some guidelines at hand,

00:28:42,340 --> 00:28:44,720
so we kind of brought people towards

00:28:44,720 --> 00:28:47,950
a few languages and technology stacks that have worked,

00:28:47,950 --> 00:28:49,840
but not insist on it, so if somebody goes out and says you know,

00:28:49,840 --> 00:28:52,200
Elixir is also meant for these reasons,

00:28:52,200 --> 00:28:54,029
we'll at least ask them that OK,

00:28:54,029 --> 00:28:56,860
does it check a box on tooling,

00:28:56,860 --> 00:28:59,090
on some mode of profiling or monitoring,

00:28:59,090 --> 00:29:01,220
and basically a small check list of sorts.

00:29:01,220 --> 00:29:03,299
We have not implemented this yet.

00:29:03,299 --> 00:29:04,320
It's probably going to-

00:29:04,320 --> 00:29:06,900
shit's going to hit the fan when we kind of suggest it,

00:29:06,900 --> 00:29:08,890
but yeah that's the idea.

00:29:08,890 --> 00:29:13,029
C.F.: Our solution is a little more messy,

00:29:13,029 --> 00:29:18,440
I guess, as you would probably expect from me.

00:29:18,440 --> 00:29:21,039
But like you said, not too way-out language,

00:29:21,039 --> 00:29:24,159
I like the way-out languages, and I would like everyone

00:29:24,159 --> 00:29:27,520
to be able to do any weird language they want,

00:29:27,520 --> 00:29:30,510
cause I hate that being a thing that people talk about

00:29:30,510 --> 00:29:33,150
and are frustrated about at work.

00:29:33,150 --> 00:29:34,590
Such a stupid thing to worry about.

00:29:34,590 --> 00:29:37,840
So as I talked about in my talk this morning,

00:29:37,840 --> 00:29:41,059
I will tell developers, any language you want, fine,

00:29:41,059 --> 00:29:43,880
go ahead, but you have to write very little code,

00:29:43,880 --> 00:29:46,350
it has to be a very small well-defined thing.

00:29:46,350 --> 00:29:49,210
We are also working very hard on the interface definitions,

00:29:49,210 --> 00:29:52,330
and that's why I was talking about that JSON Schema validation stuff,

00:29:52,330 --> 00:29:56,029
to add one more layer of monitoring to it.

00:29:56,029 --> 00:30:01,529
But most importantly, I want to hire people that I trust,

00:30:01,529 --> 00:30:04,799
and I want to show them that I trust them.

00:30:04,799 --> 00:30:07,409
So if someone really, really wants to do something in Elixir,

00:30:07,409 --> 00:30:11,380
and I have one guy who really, really wants to do something in Elixir,

00:30:11,380 --> 00:30:13,990
he actually proposed it for one project and I said fine,

00:30:13,990 --> 00:30:16,460
whatever. Then we realized we needed to do a lot of stuff

00:30:16,460 --> 00:30:20,470
that talked to Amazon SQS, and there was no good Erlang library

00:30:20,470 --> 00:30:22,100
or Elixir library we could find,

00:30:22,100 --> 00:30:24,630
so we did it in Scala instead, because it was easier.

00:30:24,630 --> 00:30:27,659
But he made the choice, not me, and so,

00:30:27,659 --> 00:30:32,049
like, we have one thing in Lua even, in engine X.

00:30:32,049 --> 00:30:37,500
I would love to have like Assembly and Objective C on the server,

00:30:37,500 --> 00:30:39,789
you know any, maybe, I don't know, Visual Basic,

00:30:39,789 --> 00:30:43,000
does that still exist? We could do that too.

00:30:43,000 --> 00:30:43,600
Off-screen: It totally does.

00:30:43,600 --> 00:30:44,630
C.F.: Yeah, it does. All right, awesome.

00:30:44,630 --> 00:30:46,070
Server-side Visual Basic.

00:30:46,070 --> 00:30:52,169
B.G.: So I guess it's more of a cultural problem,

00:30:52,169 --> 00:30:54,659
it's not really a technical problem.

00:30:54,659 --> 00:30:58,169
And I think it can be solved by setting the right expectations

00:30:58,169 --> 00:31:03,900
and what Chad said, totally agree. Trust your team members.

00:31:03,900 --> 00:31:08,169
Give them the opportunity to try out new tools, and you know, prove them.

00:31:08,169 --> 00:31:11,929
So what we do is that, when a new programming language

00:31:11,929 --> 00:31:14,480
comes out, any way as such we are using a cool

00:31:14,480 --> 00:31:19,190
and really hip programming. But if something cooler comes out,

00:31:19,190 --> 00:31:22,610
like, I don't know, something might come out tomorrow.

00:31:22,610 --> 00:31:28,730
But we always have encouraged people to try out new languages

00:31:28,730 --> 00:31:32,779
and maybe build a internal project and show it to us

00:31:32,779 --> 00:31:36,580
and we take a collective decision in such cases.

00:31:36,580 --> 00:31:39,039
But, yeah. So I think it seems more like a cultural situation,

00:31:39,039 --> 00:31:40,640
and as far as hiring is concerned, I think it's better off,

00:31:40,640 --> 00:31:45,169
better if you hire programmers, instead of Ruby programmers

00:31:45,169 --> 00:31:48,190
or Java programmers, or PHP programmers.

00:31:48,190 --> 00:31:50,600
Get people who can write code and who can learn new things,

00:31:50,600 --> 00:31:54,679
because even in the Ruby world, you are doing new things every day.

00:31:54,679 --> 00:32:01,270
If you cannot learn new tools or techniques then you are stuck.

00:32:01,270 --> 00:32:01,570
QUERANT: (indecipherable - 00:31:57)

00:32:01,570 --> 00:32:03,539
B.G.: A code base, you are talking about a code base.

00:32:03,539 --> 00:32:04,190
QUERANT: (indecipherable - 00:32:04)

00:32:04,190 --> 00:32:07,350
B.G.: So idioms are formed over time, right,

00:32:07,350 --> 00:32:09,720
and they are also learned over time.

00:32:09,720 --> 00:32:12,149
So if you are working on a sufficiently complicated code base,

00:32:12,149 --> 00:32:14,990
any way will take you some time to grok it,

00:32:14,990 --> 00:32:16,120
if there's and existing code base.

00:32:16,120 --> 00:32:17,559
Now if you were trying to learn something

00:32:17,559 --> 00:32:19,970
and to build something fresh.

00:32:19,970 --> 00:32:21,760
It will take you some time, there will be some iterative-

00:32:21,760 --> 00:32:24,549
some iterations, right. That, I think is perfectly normal.

00:32:24,549 --> 00:32:27,990
C.F.: Yeah, I actually meant to answer the idiomatic thing.

00:32:27,990 --> 00:32:30,880
If it works and everyone can understand it,

00:32:30,880 --> 00:32:32,140
I don't really care.

00:32:32,140 --> 00:32:34,080
Like let it look like Java code written

00:32:34,080 --> 00:32:36,850
with Ruby syntax. Doesn't matter if it performs

00:32:36,850 --> 00:32:39,059
and the person enjoyed doing it and it,

00:32:39,059 --> 00:32:42,049
you know, didn't take them forever,

00:32:42,049 --> 00:32:44,159
and it's not completely confusing.

00:32:44,159 --> 00:32:47,419
But, and my answer to that is keep it really small.

00:32:47,419 --> 00:32:50,539
If it does, it doesn't matter if it's idiomatic at all.

00:32:50,539 --> 00:32:51,450
H.K.: But there's like-

00:32:51,450 --> 00:32:54,990
B.G.: Another thing, just one thing that I'll add is that,

00:32:54,990 --> 00:32:56,460
how do you really define idiomatic code, OK?

00:32:56,460 --> 00:33:00,399
A code in which you are able to leverage the features

00:33:00,399 --> 00:33:03,970
of a programming language the best is idiomatic code, right.

00:33:03,970 --> 00:33:05,429
So if you're championing a programming language

00:33:05,429 --> 00:33:08,679
you are trying to introduce the new programming language to your company,

00:33:08,679 --> 00:33:11,640
and of course you'd like to exploit all its features, right.

00:33:11,640 --> 00:33:15,740
Unless it is handed down to you by your boss, right.

00:33:15,740 --> 00:33:18,770
So if someone is championing a new programming language,

00:33:18,770 --> 00:33:23,679
it's his prerogative to you know to learn what the idioms are,

00:33:23,679 --> 00:33:25,470
maybe figure them out over time.

00:33:25,470 --> 00:33:28,460
H.K. This not working?

00:33:28,460 --> 00:33:35,460
B.G.: Yeah that doesn't seem to work.

00:33:36,080 --> 00:33:38,380
V.S.: So it's gonna be a slow process, you know,

00:33:38,380 --> 00:33:40,549
obviously we just talked about lots of languages,

00:33:40,549 --> 00:33:43,080
and the key thing is are we doing in house,

00:33:43,080 --> 00:33:44,590
we have control of the deployment environment,

00:33:44,590 --> 00:33:46,440
versus, we are gonna consult.

00:33:46,440 --> 00:33:49,059
So for example, Flipkart, or, in several cases,

00:33:49,059 --> 00:33:52,020
that there's a lot, you're in control of the whole thing,

00:33:52,020 --> 00:33:53,690
that, and you basically decide, or,

00:33:53,690 --> 00:33:56,059
you live with the consequences of the whole thing, right.

00:33:56,059 --> 00:33:58,520
Then when you're dealing with the customer-based solution,

00:33:58,520 --> 00:34:01,270
obviously there's a lot more constraints as to,

00:34:01,270 --> 00:34:02,860
you know, he would look for somethings that he can

00:34:02,860 --> 00:34:04,659
add more people to work with as opposed to just you,

00:34:04,659 --> 00:34:05,820
and what if you can go away,

00:34:05,820 --> 00:34:07,600
and in-house holds the same problem.

00:34:07,600 --> 00:34:11,359
So probably to start with just learn one more language.

00:34:11,359 --> 00:34:13,250
Just learn one more language and start using it,

00:34:13,250 --> 00:34:14,379
and it's gonna take some time, like you said,

00:34:14,379 --> 00:34:15,829
it's just cultural thing, you know.

00:34:15,829 --> 00:34:18,499
Particularly in India the context is not just,

00:34:18,499 --> 00:34:21,979
you know, just start with one more language,

00:34:21,979 --> 00:34:23,200
try to use it in deployment,

00:34:23,200 --> 00:34:25,559
so it doesn't look like you're grabbing this opportunity

00:34:25,559 --> 00:34:28,779
to as many language as possible into solution you build,

00:34:28,779 --> 00:34:31,089
just for the sake of learning new things.

00:34:31,089 --> 00:34:33,809
But just do one more language, carefully.

00:34:33,809 --> 00:34:34,959
But in order for you to do that

00:34:34,959 --> 00:34:37,549
you probably will have to casually learn five-six languages.

00:34:37,549 --> 00:34:38,950
And you may want to pick that language

00:34:38,950 --> 00:34:40,869
that you want and it's gonna be a slow process.

00:34:40,869 --> 00:34:41,259
You're not gonna be able to finally deliver all this,

00:34:41,259 --> 00:34:46,700
and then you know, introduce a new language just like that next day.

00:34:46,700 --> 00:34:48,709
C.F.: Yeah, when I started learning Ruby,

00:34:48,709 --> 00:34:52,049
I started using it in 2000 network,

00:34:52,049 --> 00:34:53,829
and it was to generate Java code,

00:34:53,829 --> 00:34:55,369
because no one would let me deploy Ruby.

00:34:55,369 --> 00:34:57,019
So I just wrote Java generators

00:34:57,019 --> 00:34:58,859
and I wrote everything like as a DSL in Ruby.

00:34:58,859 --> 00:35:00,599
V.S.: Yeah absolutely.

00:35:00,599 --> 00:35:02,709
My first experience with Ruby was not really mainstream.

00:35:02,709 --> 00:35:04,829
We were just doing, it was called load disk conductors.

00:35:04,829 --> 00:35:07,289
It was an OpenSource thing that we were just doing.

00:35:07,289 --> 00:35:09,209
So what we wanted is we wanted to drive these command lines,

00:35:09,209 --> 00:35:11,019
and Ruby was a language to do that.

00:35:11,019 --> 00:35:12,839
So there are other opportunities for you to use

00:35:12,839 --> 00:35:15,089
new languages may not be in your main code base,

00:35:15,089 --> 00:35:17,229
all the supporting tool systems as well.

00:35:17,229 --> 00:35:18,039
So there's a lot of opportunities,

00:35:18,039 --> 00:35:20,229
so you may not look at it as,

00:35:20,229 --> 00:35:25,349
can I change my main language, or how soon can I do it?

00:35:25,349 --> 00:35:26,140
K.H.: So-

00:35:26,140 --> 00:35:28,469
Y.K.: So, one of the, I don't know,

00:35:28,469 --> 00:35:30,709
this is a thought, this has been kind of crossing my mind repeatedly,

00:35:30,709 --> 00:35:32,959
and kind of worrying me, also.

00:35:32,959 --> 00:35:38,410
So I used to be kind of involved in the language choice wars a lot,

00:35:38,410 --> 00:35:44,959
and always on the now try out something new side.

00:35:44,959 --> 00:35:46,430
And I've kind of discovered a completely

00:35:46,430 --> 00:35:47,660
different way of working at Flipkart,

00:35:47,660 --> 00:35:50,259
and some of the other people who've been there.

00:35:50,259 --> 00:35:52,589
They kind of shook me out of,

00:35:52,589 --> 00:35:56,440
maybe my Thoughtworks influenced it in a certain way.

00:35:56,440 --> 00:36:00,170
So, and there's a very key point when that happened.

00:36:00,170 --> 00:36:03,190
So I think the difference was this, right.

00:36:03,190 --> 00:36:05,369
The take-away was that,

00:36:05,369 --> 00:36:06,920
if I'm arguing about a programming language,

00:36:06,920 --> 00:36:11,920
I probably don't understand the problem domain well enough, right.

00:36:11,920 --> 00:36:15,779
And I've seen cases where systems have been built

00:36:15,779 --> 00:36:19,329
which go fundamentally towards the problem being solved as really about,

00:36:19,329 --> 00:36:20,309
and modeled the code abstraction so beautifully,

00:36:20,309 --> 00:36:24,099
that then, or it identified the co-op section so beautifully

00:36:24,099 --> 00:36:28,920
that it doesn't matter which language you implement it in,

00:36:28,920 --> 00:36:30,170
because that problem is solved.

00:36:30,170 --> 00:36:33,009
And even before we started implementation that is beautiful.

00:36:33,009 --> 00:36:34,099
I think with this giant perspective,

00:36:34,099 --> 00:36:36,329
I think somewhere that has got lost.

00:36:36,329 --> 00:36:38,729
We try to kind of get into implementation much sooner.

00:36:38,729 --> 00:36:41,979
So if I could actually go back and say what's the most,

00:36:41,979 --> 00:36:43,150
my favorite programming language,

00:36:43,150 --> 00:36:45,309
I think I would say domain-driven design actually.

00:36:45,309 --> 00:36:47,859
I would actually just recommend people to...

00:36:47,859 --> 00:36:50,180
oh and actually do that on my team also, too,

00:36:50,180 --> 00:36:53,529
actually read that book and try and apply it.

00:36:53,529 --> 00:36:57,039
Because I think a huge set of wins are possible from that,

00:36:57,039 --> 00:36:59,920
without even going down to the programming language level.

00:36:59,920 --> 00:37:03,910
C.F.: Yeah, the programming language is a tactical choice,

00:37:03,910 --> 00:37:06,799
in most cases, right, but the domain,

00:37:06,799 --> 00:37:09,150
it's like what you were saying about performance earlier.

00:37:09,150 --> 00:37:12,829
You could use Java or you could use JRuby, doesn't really matter,

00:37:12,829 --> 00:37:15,099
because the database is gonna be slow, right.

00:37:15,099 --> 00:37:18,390
When it comes to application design and architecture,

00:37:18,390 --> 00:37:21,719
it's really a hierarchy, so domain-driven design is

00:37:21,719 --> 00:37:23,729
at a level higher than the languages.

00:37:23,729 --> 00:37:27,269
I would still say that the languages make you think differently,

00:37:27,269 --> 00:37:30,559
and some languages suit different domains better,

00:37:30,559 --> 00:37:33,380
and having really open-mindedly going,

00:37:33,380 --> 00:37:36,989
gone back to Java recently for various reasons,

00:37:36,989 --> 00:37:40,890
I can tell you that it's terrible to use, it really is.

00:37:40,890 --> 00:37:42,729
It wastes my time compared to Ruby

00:37:42,729 --> 00:37:45,519
and compared to Scala and compared to more modern languages.

00:37:45,519 --> 00:37:47,039
And it's not a knock against Java -

00:37:47,039 --> 00:37:49,549
Java's older and doesn't have those benefits.

00:37:49,549 --> 00:37:52,859
So I think tactically, it's a bit of an exaggeration

00:37:52,859 --> 00:37:55,450
to say that the language doesn't matter, but I get your point.

00:37:55,450 --> 00:37:57,759
Y.K.: Sure. So just as a counterpoint to that.

00:37:57,759 --> 00:38:00,150
Actually having gone from Ruby back to Java,

00:38:00,150 --> 00:38:03,450
there's a few very low-latency systems that we had to

00:38:03,450 --> 00:38:07,529
build out recently and those are built with some of the newer Java stacks,

00:38:07,529 --> 00:38:12,609
like say dropwizard which has got Hibernate integrated into it,

00:38:12,609 --> 00:38:16,880
and Netti and, so it's basically a complete stack

00:38:16,880 --> 00:38:18,440
and actual systems and the designs that came out of it

00:38:18,440 --> 00:38:18,650
were actually pretty good,

00:38:18,650 --> 00:38:22,019
and I was surprised and actually happy

00:38:22,019 --> 00:38:23,269
to go back and look at Java.

00:38:23,269 --> 00:38:27,140
And I actually enjoy looking forward to Java ahead.

00:38:27,140 --> 00:38:29,859
More than Scala in a sense.

00:38:29,859 --> 00:38:31,920
H.K.: That's good, because-

00:38:31,920 --> 00:38:37,319
So the Java aid that you mentioned and then Scala.

00:38:37,319 --> 00:38:38,499
So there's a couple of things

00:38:38,499 --> 00:38:43,599
like if you talked about this Java like and Scala like,

00:38:43,599 --> 00:38:44,690
why would you choose like, for example, today,

00:38:44,690 --> 00:38:46,569
like Java it is not released.

00:38:46,569 --> 00:38:52,229
But what would issues like, is there any reason to choose

00:38:52,229 --> 00:38:55,069
like Scala over Java now actually?

00:38:55,069 --> 00:38:57,829
Because now for example, (00:38:57 - ??)

00:38:57,829 --> 00:39:00,160
is a good system, but it is usable from both the languages,

00:39:00,160 --> 00:39:04,239
right, so is there any reason to pick- Chad?

00:39:04,239 --> 00:39:09,680
C.F.: Yes. So the question is,

00:39:09,680 --> 00:39:11,529
is there any reason to pick Java over Scala,

00:39:11,529 --> 00:39:13,819
or Scala over Java. Does one win?

00:39:13,819 --> 00:39:19,430
H.K.: No, no, no, no. Just Java, like Scala over Java, like-

00:39:19,430 --> 00:39:21,829
C.F.: Is Scal- or, should you actually,

00:39:21,829 --> 00:39:23,719
because of Java aid, does Scala need-

00:39:23,719 --> 00:39:25,279
H.K.: Or Java seven, yeah.

00:39:25,279 --> 00:39:29,319
C.F.: Java seven, then yes. Like.

00:39:29,319 --> 00:39:35,450
For me I see Scala as like totally over-engineered,

00:39:35,450 --> 00:39:38,509
in the same way that Yogi almost said, but like,

00:39:38,509 --> 00:39:42,709
too many features. But, and I'm even writing a book about it,

00:39:42,709 --> 00:39:45,709
but I kind of hate it.

00:39:45,709 --> 00:39:49,140
That said, you can program Scala like Java

00:39:49,140 --> 00:39:52,109
with less annoying syntax. You can do that,

00:39:52,109 --> 00:39:54,170
you can make it be like a Java program,

00:39:54,170 --> 00:39:56,849
and if you do, I would argue very strongly,

00:39:56,849 --> 00:39:58,170
and maybe, and this is subjective

00:39:58,170 --> 00:40:00,690
and maybe even kind of fashion-oriented,

00:40:00,690 --> 00:40:03,390
I would argue that the Scala code is better to look at

00:40:03,390 --> 00:40:05,809
and easier to write than the Java code.

00:40:05,809 --> 00:40:09,430
There's less typing, and I mean that in two sense.

00:40:09,430 --> 00:40:10,410
Less typing on the keyboard

00:40:10,410 --> 00:40:15,069
and less having to explicitly type because of type inference.

00:40:15,069 --> 00:40:18,599
I'm sure, and like with Java seven there are Lambdas,

00:40:18,599 --> 00:40:20,509
with Java 8 I'm sure it's gonna be some sort of

00:40:20,509 --> 00:40:23,539
anemic thing that doesn't quite work the way we want it to.

00:40:23,539 --> 00:40:25,299
It's perfect in Scala.

00:40:25,299 --> 00:40:27,140
There's a lot of great stuff about Scala,

00:40:27,140 --> 00:40:31,519
as a next evolution of Java.

00:40:31,519 --> 00:40:34,469
But, you can also, like Ruby,

00:40:34,469 --> 00:40:37,630
with meta-programming and eval and all the crazy stuff you can do,

00:40:37,630 --> 00:40:44,630
you can completely shoot yourself in the foot with it, too.

00:40:46,599 --> 00:40:53,599
QUERANT: So, when we compare these languages,

00:40:55,380 --> 00:40:56,749
like Java and Ruby and all that,

00:40:56,749 --> 00:41:00,440
the thing that we kind of focus on is the amount of,

00:41:00,440 --> 00:41:04,999
volume of code. Volume of code doesn't lead to the ease of understanding.

00:41:04,999 --> 00:41:07,660
One of the thing that Java really does well

00:41:07,660 --> 00:41:11,519
is things are so simple that there's no,

00:41:11,519 --> 00:41:13,739
there's implicit stuff happening behind

00:41:13,739 --> 00:41:17,199
the scenes and all that. And very, very well-factored Java code

00:41:17,199 --> 00:41:18,880
is not so ugly to look at.

00:41:18,880 --> 00:41:20,609
We have written all small methods

00:41:20,609 --> 00:41:22,589
and composed stuff out of it.

00:41:22,589 --> 00:41:25,479
It's not so ugly to write or ugly to look at it. So-

00:41:25,479 --> 00:41:26,589
C.F.: I would like to answer that

00:41:26,589 --> 00:41:28,569
even if you're not asking me,

00:41:28,569 --> 00:41:31,400
cause I could imagine myself saying that

00:41:31,400 --> 00:41:33,029
if I were in the audience.

00:41:33,029 --> 00:41:36,499
But right now I strongly disagree with you.

00:41:36,499 --> 00:41:41,890
I think Java is simple as a language, yes,

00:41:41,890 --> 00:41:46,880
but what it leads to is, because of its lack of flexibility,

00:41:46,880 --> 00:41:49,150
it's not the volume of code that I hate -

00:41:49,150 --> 00:41:51,279
I mean sometimes it is, sometimes it's literally because

00:41:51,279 --> 00:41:53,599
I have to type date date equals new date.

00:41:53,599 --> 00:41:56,219
I don't need that.

00:41:56,219 --> 00:41:59,119
But it's also the ability to be expressive,

00:41:59,119 --> 00:42:02,259
and to me that's where Java strongly lacks.

00:42:02,259 --> 00:42:05,999
It's pretty good as a system language, like,

00:42:05,999 --> 00:42:08,339
at the point where you decide you need to make that distinction,

00:42:08,339 --> 00:42:10,779
but maybe as things get faster you don't need to anymore.

00:42:10,779 --> 00:42:15,479
But I believe that the abstractions that people end up creating for Java,

00:42:15,479 --> 00:42:19,069
at least idiomatic Java, like in the Java world,

00:42:19,069 --> 00:42:21,549
idiomatic is a bad sign, I would say,

00:42:21,549 --> 00:42:24,469
because it leads to this kind of pattern soup thing.

00:42:24,469 --> 00:42:26,809
And it's true that you can reason about it,

00:42:26,809 --> 00:42:29,170
because it's statically typed, and there are

00:42:29,170 --> 00:42:31,499
less opportunities for meta-programming,

00:42:31,499 --> 00:42:34,140
but it's a slow process in my experience of reasoning about it,

00:42:34,140 --> 00:42:37,180
because you get so far away from the domain,

00:42:37,180 --> 00:42:40,119
creating all these factories and interfaces and crap,

00:42:40,119 --> 00:42:42,769
just so that you can make it testable and plugable,

00:42:42,769 --> 00:42:47,959
that it, the actual logic and the core of the business gets lost.

00:42:47,959 --> 00:42:52,459
Do you have a- anyone have a point to make on that?

00:42:52,459 --> 00:42:55,589
B.G.: So yeah, I totally agree with Chad here.

00:42:55,589 --> 00:42:57,949
Java the language is designed to be very simple,

00:42:57,949 --> 00:42:59,839
but at the same time it's also very rigid.

00:42:59,839 --> 00:43:03,690
So imagine explaining philosophy to a kid, right.

00:43:03,690 --> 00:43:07,089
The kid probably has a vocabulary of maybe hundred words.

00:43:07,089 --> 00:43:11,839
How do you do that? You cannot discuss the existence of God,

00:43:11,839 --> 00:43:14,630
you know, or maybe the nature of knowledge,

00:43:14,630 --> 00:43:18,299
in front of a kid, because the kid doesn't have the vocabulary

00:43:18,299 --> 00:43:21,359
that you need to communicate with that child, right.

00:43:21,359 --> 00:43:23,549
So what you end up doing is over-simplification.

00:43:23,549 --> 00:43:26,579
So by the time you simplify the concepts to

00:43:26,579 --> 00:43:29,380
the primitives that the child can understand,

00:43:29,380 --> 00:43:33,109
you're far away from Aristotle and Plato, you know.

00:43:33,109 --> 00:43:36,809
So that's the example that I give you.

00:43:36,809 --> 00:43:39,289
QUERANT: I have a question.

00:43:39,289 --> 00:43:41,769
At what point do you feel comfortable or something

00:43:41,769 --> 00:43:46,400
like a threshold level for new languages to be used in production,

00:43:46,400 --> 00:43:48,160
you know, like, there are some languages which are

00:43:48,160 --> 00:43:49,969
coming up now but you still you know

00:43:49,969 --> 00:43:51,430
that it's not something that you use.

00:43:51,430 --> 00:43:53,789
As for me I would probably look at an example,

00:43:53,789 --> 00:43:55,749
if I would say OK, there are quite a few systems,

00:43:55,749 --> 00:43:58,449
big huge systems based on Ruby, I could recommend

00:43:58,449 --> 00:44:01,239
it to someone people who are comfortable say if

00:44:01,239 --> 00:44:04,059
they say it is OK if I use Ruby yeah say because

00:44:04,059 --> 00:44:06,009
there are people who use it. But at production level

00:44:06,009 --> 00:44:07,769
when that new language is- at what point do you feel

00:44:07,769 --> 00:44:08,799
comfortable to say that, OK, this is viable to use

00:44:08,799 --> 00:44:08,999
in production?

00:44:08,999 --> 00:44:09,940
B.G.: Fantastic question. I would say that this is a

00:44:09,940 --> 00:44:10,279
case that you need to develop over time, and I think

00:44:10,279 --> 00:44:10,799
it comes with experience. The more you learn of different

00:44:10,799 --> 00:44:16,849
programming languages, the better you get at evaluating them,

00:44:16,849 --> 00:44:23,849
but having said that, community support does matter,

00:44:25,299 --> 00:44:27,650
based on-

00:44:27,650 --> 00:44:32,349
(00:44:36 - dead audio - 00:44:37)

00:44:32,349 --> 00:44:39,349
OK, you can have a language which can have a

00:44:40,259 --> 00:44:42,279
huge community around it.

00:44:42,279 --> 00:44:44,180
That does not necessarily equate to the language being awesome, OK.

00:44:44,180 --> 00:44:46,059
Documentation is also another thing, ?? (00:44:45)

00:44:46,059 --> 00:44:47,319
is also another thing.

00:44:47,319 --> 00:44:52,640
But again I would say that one of the ways is to really see,

00:44:52,640 --> 00:44:55,519
what is the USB of the language, what kind of problem

00:44:55,519 --> 00:44:58,880
is the language helping you solve, OK. If you see that,

00:44:58,880 --> 00:45:02,199
it's like you already know Python, and there is Ruby,

00:45:02,199 --> 00:45:04,039
not really very different, honestly.

00:45:04,039 --> 00:45:08,380
So, but if you see Go, again, very different,

00:45:08,380 --> 00:45:12,479
a lot of interesting concepts, and so you might

00:45:12,479 --> 00:45:16,799
find problems where that language might fit in just perfectly, right.

00:45:16,799 --> 00:45:21,739
So it's OK to maybe wait for a production by a larger community,

00:45:21,739 --> 00:45:25,209
but sometimes you have to be that champion yourself, right.

00:45:25,209 --> 00:45:28,319
Someone started using the language first, when Ruby came out, right.

00:45:28,319 --> 00:45:30,420
(00:45:27) was the guy, probably.

00:45:30,420 --> 00:45:32,119
That's why he's worshiped today.

00:45:32,119 --> 00:45:35,640
So why not be the (name) yourself.

00:45:35,640 --> 00:45:38,640
QUERANT: (indecipherable - 00:45:37)

00:45:38,640 --> 00:45:43,949
Y.K.: Yup. Yeah, so I think it's,

00:45:43,949 --> 00:45:47,180
there are quite a few kind of milestones for a language

00:45:47,180 --> 00:45:49,190
to go through, but I think the most critical,

00:45:49,190 --> 00:45:51,219
so again, it depends on the kind of client

00:45:51,219 --> 00:45:52,509
that you're kind of suggesting this to, right,

00:45:52,509 --> 00:45:54,239
like if it's a small start up then sure,

00:45:54,239 --> 00:45:55,349
you have a lot more flexibility.

00:45:55,349 --> 00:45:56,999
If it's a larger system, it has to scale,

00:45:56,999 --> 00:45:58,900
you got different constraints.

00:45:58,900 --> 00:46:02,449
But I think by and large the existence

00:46:02,449 --> 00:46:08,239
of a very low latency production profiler

00:46:08,239 --> 00:46:12,039
or on-time run system is probably that milestone.

00:46:12,039 --> 00:46:14,519
The moment that it is in place,

00:46:14,519 --> 00:46:17,359
a profiler which can actually run in production,

00:46:17,359 --> 00:46:19,729
for that language, I think that marks a very critical

00:46:19,729 --> 00:46:22,009
milestone when the language starts evolving at a very

00:46:22,009 --> 00:46:25,319
different pace. Because you start kind of finding issues

00:46:25,319 --> 00:46:27,789
which you never had been able to find before, right.

00:46:27,789 --> 00:46:30,739
So for example, with both tools, we've been able to do

00:46:30,739 --> 00:46:32,819
amazing things in production with Ruby, which was just

00:46:32,819 --> 00:46:35,249
not possible before we knew, even the commercial ordinative,

00:46:35,249 --> 00:46:37,509
like ?? (00:46:35) for that matter, right, so either a

00:46:37,509 --> 00:46:40,099
commercial or opensource production profiling tool I

00:46:40,099 --> 00:46:41,219
think is a pretty significant milestone.

00:46:41,219 --> 00:46:43,819
QUERANT: I have a couple of questions here.

00:46:43,819 --> 00:46:45,890
B.G.: Right, Yogi.

00:46:45,890 --> 00:46:51,430
Y.K.: I don't know. Haven't you seen production?

00:46:51,430 --> 00:46:56,309
B.G.: The production level compiler which you can plug into a running system?

00:46:56,309 --> 00:46:59,039
Y.K.: So there are-

00:46:59,039 --> 00:47:03,339
(00:46:58 - dead audio - 00:47:29)

00:47:03,339 --> 00:47:07,940
B.G.: Yeah, but those are Valgrind but, which is not probably-

00:47:07,940 --> 00:47:08,920
Y.K.: Sure.

00:47:08,920 --> 00:47:12,499
B.G.: I think, what I will say is that,

00:47:12,499 --> 00:47:16,459
Yogi is talking about the presence of a profiler being very important.

00:47:16,459 --> 00:47:18,900
I think again it depends on the domain that you are in.

00:47:18,900 --> 00:47:21,849
What kind of company you work for, what your challenges are.

00:47:21,849 --> 00:47:24,769
It could just be documentation for you. Right or it could be

00:47:24,769 --> 00:47:29,829
just the existence of a all-out library for you, right.

00:47:29,829 --> 00:47:34,579
So I think it depends. The answer, real answer is it really depends.

00:47:34,579 --> 00:47:39,499
QUERANT: I have a question. Like when do we actually

00:47:39,499 --> 00:47:42,539
choose a interpreted language versus a compile language,

00:47:42,539 --> 00:47:45,170
is my first question. Like for example,

00:47:45,170 --> 00:47:48,130
Ruby's interpreted language, and like Java is kind of both,

00:47:48,130 --> 00:47:51,749
like when do we actually choose that one is the first question,

00:47:51,749 --> 00:47:53,420
and second question is-

00:47:53,420 --> 00:48:00,420
H.K.: Just ask one question. Please ask one question.

00:48:02,509 --> 00:48:08,569
QUERANT: Yeah. The question is asked.

00:48:08,569 --> 00:48:14,660
Y.K.: So, OK again this is, as Baishampayan said,

00:48:14,660 --> 00:48:19,209
it's kind of a black art. But roughly the euristics that I used were,

00:48:19,209 --> 00:48:23,930
is primarily driven by is the system gonna be

00:48:23,930 --> 00:48:30,930
CPU-bound or IO-bound? What kind of latencies do you need? Do you want

00:48:34,939 --> 00:48:38,319
(00:48:27 - dead audio - 00:48:42)

00:48:38,319 --> 00:48:43,400
I'd probably go straight away to

00:48:43,400 --> 00:48:48,489
Java or any other static-type language,

00:48:48,489 --> 00:48:49,660
which gives those kind of performance.

00:48:49,660 --> 00:48:53,979
So I think latency is one. I don't know - you might-

00:48:53,979 --> 00:48:56,579
B.G.: So I would say that the differences between

00:48:56,579 --> 00:48:58,989
interpreted and compile languages, they are kind of

00:48:58,989 --> 00:49:02,069
like blurring these days. I think you, what you really mean,

00:49:02,069 --> 00:49:05,380
is a native language versus a language that runs in the VM.

00:49:05,380 --> 00:49:11,670
OK. So I think VMs are as fast as natively compiled languages today.

00:49:11,670 --> 00:49:16,729
And so for example, one of the lowest latency languages

00:49:16,729 --> 00:49:19,890
would be Erlang, but it's not really a natively

00:49:19,890 --> 00:49:23,430
ompiled language for that matter.

00:49:23,430 --> 00:49:27,809
So again, Yogi is absolutely right, it depends on the problem.

00:49:27,809 --> 00:49:30,829
If it's CPO-bound, maybe you should use a language

00:49:30,829 --> 00:49:33,769
which spits out a native binary or maybe

00:49:33,769 --> 00:49:36,699
has a very fast git compiler inside of VM.

00:49:36,699 --> 00:49:40,999
Or if it's IO-bound, which most web-applications are by the way,

00:49:40,999 --> 00:49:44,009
then just use Python, Ruby or whatever, or JavaScript.

00:49:44,009 --> 00:49:48,549
C.F.: Yeah, but in, it is a blurring not only of that boundary,

00:49:48,549 --> 00:49:50,489
but a blurring of concerns.

00:49:50,489 --> 00:49:55,749
So like you said you have never used Ruby for something that

00:49:55,749 --> 00:49:57,019
requires that low-latency. That's because Ruby's not fast enough,

00:49:57,019 --> 00:49:58,180
not because it's an interpretive language, right.

00:49:58,180 --> 00:50:04,199
If it were, yeah, so I would personally say on anything where

00:50:04,199 --> 00:50:04,439
I don't mind having the source code present, which means any

00:50:04,439 --> 00:50:04,509
server-side thing for example, I would use interpretive languages,

00:50:04,509 --> 00:50:04,829
because it's a pain in the ass, I don't want to do that.

00:50:04,829 --> 00:50:05,099
And what all of these things do is the answer, effectively

00:50:05,099 --> 00:50:05,249
just compile it for you, anyway.

00:50:05,249 --> 00:50:05,449
QUERANT: My question is for all panel members.

00:50:05,449 --> 00:50:05,640
From invention of a competitive we're seeing that

00:50:05,640 --> 00:50:05,839
there are so many languages came and gone,

00:50:05,839 --> 00:50:12,839
and each language right on the veil,

00:50:13,199 --> 00:50:20,199
are serving out their time.

00:50:34,289 --> 00:50:41,289
I would say that today Ruby is one of those languages riding on the veil.

00:50:44,680 --> 00:50:48,229
C is the only language which is there for a long time,

00:50:48,229 --> 00:50:51,430
and it is from the starting of the computer still it is there.

00:50:51,430 --> 00:50:55,529
So my question is, how long do you think that the Ruby will be last,

00:50:55,529 --> 00:50:59,479
and what is going to be the next veil? Will it be Closure, or Scala,

00:50:59,479 --> 00:51:03,650
Go or any other language, because the moment is coming to the market

00:51:03,650 --> 00:51:06,709
and total paradigm of programming is changing.

00:51:06,709 --> 00:51:09,469
B.G.: Great question. I will just, in my recollection,

00:51:09,469 --> 00:51:12,130
the oldest language that is still in existence is Lisp,

00:51:12,130 --> 00:51:17,689
and not C. It predates Unix and C by twenty years.

00:51:17,689 --> 00:51:18,209
And anyway-

00:51:18,209 --> 00:51:21,039
C.F.: So that's a huge wave is what you're saying.

00:51:21,039 --> 00:51:22,160
B.G.: Huge wave.

00:51:22,160 --> 00:51:27,029
C.F.: We're still in the Lisp bubble, which will soon burst.

00:51:27,029 --> 00:51:30,989
Everyone will realize that was stupid.

00:51:30,989 --> 00:51:35,059
Do you really want an answer to that question. We didn't really answer it.

00:51:35,059 --> 00:51:38,339
B.G.: So languages do come and go but paradigms do stay,

00:51:38,339 --> 00:51:40,869
OK. So fine, don't focus on languages,

00:51:40,869 --> 00:51:42,839
focus on learning different paradigms.

00:51:42,839 --> 00:51:45,849
C.F.: But they don't really come and go that much.

00:51:45,849 --> 00:51:47,390
I mean think about it, like-

00:51:47,390 --> 00:51:49,699
B.G.: They might, like PHP fell out of favor.

00:51:49,699 --> 00:51:51,890
C.F.: But it's not, not it's out of fashion. Fashion.

00:51:51,890 --> 00:51:53,049
B.G.: It is that.

00:51:53,049 --> 00:51:55,799
C.F.: It is heavily deployed, right, you're running it.

00:51:55,799 --> 00:51:57,059
So it still exists.

00:51:57,059 --> 00:51:59,880
H.K.: A bit sheepishly but running.

00:51:59,880 --> 00:52:04,410
V.K.: But remember one thing. Ruby is older than Java.

00:52:04,410 --> 00:52:06,529
It's been there since 2004.

00:52:06,529 --> 00:52:08,549
But how many people started referring to Ruby

00:52:08,549 --> 00:52:12,170
until Ruby on Rails came? So it's a solution that language

00:52:12,170 --> 00:52:15,199
or a framework provides this, what inspired everything.

00:52:15,199 --> 00:52:18,140
In fact Ruby on Rails inspired the entire ecosystem

00:52:18,140 --> 00:52:21,420
much more of other languages beyond just Ruby.

00:52:21,420 --> 00:52:24,959
So that's in fact, it's Ruby on Rails that made Ruby popular.

00:52:24,959 --> 00:52:28,299
B.G.: It's also Ruby's Achille's heel, by the way.

00:52:28,299 --> 00:52:30,449
V.K.: Absolutely. There's a downside to it, extra-

00:52:30,449 --> 00:52:32,329
B.G.: I'll keep patching FTW, right? Not.

00:52:32,329 --> 00:52:34,869
V.K.: But remember, you know, we were doing all

00:52:34,869 --> 00:52:38,849
this web XML business till Ruby on Rails came about,

00:52:38,849 --> 00:52:42,789
and all this other stuff. So what changed, if you were to call it,

00:52:42,789 --> 00:52:45,989
you would call it Ruby on Rails for the better, rather than Ruby-

00:52:45,989 --> 00:52:47,839
H.K.: Are you saying that the whole rest

00:52:47,839 --> 00:52:52,119
thing was because of Rails? Venkat?

00:52:52,119 --> 00:52:56,339
V.K.: Certainly the moment was more simplification,

00:52:56,339 --> 00:52:58,259
convection over configuration,

00:52:58,259 --> 00:53:00,249
so that's what the Ruby on Rails was inspiring.

00:53:00,249 --> 00:53:01,479
So you could just say that, you know,

00:53:01,479 --> 00:53:03,809
people who were doing Ruby on Rails were doing more

00:53:03,809 --> 00:53:05,759
rest than people who were doing dot net

00:53:05,759 --> 00:53:06,949
and doing the sub-business.

00:53:06,949 --> 00:53:10,809
But by the way, sub seems to be effectively dead, right.

00:53:10,809 --> 00:53:12,999
C.F.: But unfortunately it's dead

00:53:12,999 --> 00:53:16,449
in the same way that PHP is dead. It still exists.

00:53:16,449 --> 00:53:19,599
V.K.: That's true. The same that Colba is dead, right.

00:53:19,599 --> 00:53:21,369
C.F.: And Colba, for that matter. Sorry kids.

00:53:21,369 --> 00:53:25,189
V.K.: And that will never go away, because as long as-

00:53:25,189 --> 00:53:30,739
H.K.: So the next question that I wanted to ask is like,

00:53:30,739 --> 00:53:32,160
Yogi talked about in his presentation, like,

00:53:32,160 --> 00:53:35,269
how using a service architecture,

00:53:35,269 --> 00:53:37,829
like for interface-based for, you know like multiple small

00:53:37,829 --> 00:53:39,759
micro-applications, small applications.

00:53:39,759 --> 00:53:42,739
So the next question is like how do you go about

00:53:42,739 --> 00:53:45,029
in an organization, you have a product,

00:53:45,029 --> 00:53:46,849
or maybe more than one product.

00:53:46,849 --> 00:53:51,249
How do you go about building a true polyglot system,

00:53:51,249 --> 00:53:53,479
where you know like programmers are encouraged to come

00:53:53,479 --> 00:53:55,839
and you know like use different languages.

00:53:55,839 --> 00:53:58,839
Does this require like some previous thought,

00:53:58,839 --> 00:54:00,459
or does it happen automatically, like, yeah.

00:54:00,459 --> 00:54:04,099
What are the best practices and everything?

00:54:04,099 --> 00:54:08,189
C.F.: It's for one of us isn't it.

00:54:08,189 --> 00:54:11,390
Or he says it's for me and I say it's for you.

00:54:11,390 --> 00:54:15,779
OK, so I, actually Yogi did sort of answer this a minute ago.

00:54:15,779 --> 00:54:18,209
You know, you really do need to focus on the

00:54:18,209 --> 00:54:20,430
architecture of the system first.

00:54:20,430 --> 00:54:23,089
That's essentially what my whole rant was this morning,

00:54:23,089 --> 00:54:25,859
is about the architecture of a system that's

00:54:25,859 --> 00:54:31,709
made of small components that interact in well-defined ways

00:54:31,709 --> 00:54:35,160
with very clear responsibilities of each component,

00:54:35,160 --> 00:54:37,849
and the components can and will be thrown away.

00:54:37,849 --> 00:54:40,749
I think for us once we have that set up,

00:54:40,749 --> 00:54:44,199
I really can say yes, write a service in Rust,

00:54:44,199 --> 00:54:46,329
I don't care. I don't even know what it looks like,

00:54:46,329 --> 00:54:48,229
I haven't bothered to read about it yet.

00:54:48,229 --> 00:54:50,559
It's fine. Yeah, it's like C++.

00:54:50,559 --> 00:54:54,019
So yeah it's excellent. It's battle-worn.

00:54:54,019 --> 00:54:57,369
But if it performs well enough

00:54:57,369 --> 00:54:59,239
and it actually works and we're monitoring it

00:54:59,239 --> 00:55:03,319
and doing these, and it's deployable in the way that we can deploy,

00:55:03,319 --> 00:55:06,799
I don't need an ecosystem for polyglot programming then.

00:55:06,799 --> 00:55:09,209
I just need to encourage people to try things

00:55:09,209 --> 00:55:13,049
and to throw them away if they didn't work out.

00:55:13,049 --> 00:55:15,119
H.K.: Venkat, you had something-

00:55:15,119 --> 00:55:16,349
V.K.: Actually there's something

00:55:16,349 --> 00:55:18,829
we just talked about this morning.

00:55:18,829 --> 00:55:21,609
We have to move away from a language requiring

00:55:21,609 --> 00:55:23,939
to be hidden in a web service just to be safe,

00:55:23,939 --> 00:55:25,549
and you can throw it away later.

00:55:25,549 --> 00:55:28,420
I think the languages will have to find a way to work together,

00:55:28,420 --> 00:55:30,949
where you don't need to hide things behind rest.

00:55:30,949 --> 00:55:33,809
All these languages will have to come with a way to improve,

00:55:33,809 --> 00:55:36,869
thereby they should, Ruby should really

00:55:36,869 --> 00:55:38,519
see a world of coexistence with Java,

00:55:38,519 --> 00:55:40,630
and a world of coexistence with dot net.

00:55:40,630 --> 00:55:42,579
Because in many cases we develop in, like JRuby,

00:55:42,579 --> 00:55:45,079
right. You develop in Ruby and you deploy it in Java,

00:55:45,079 --> 00:55:47,359
or J to E, with all the monitoring tools,

00:55:47,359 --> 00:55:49,189
and you talked about profiling.

00:55:49,189 --> 00:55:52,509
JVM and the JV-maker system is very great for deployments

00:55:52,509 --> 00:55:55,709
actually better. So in order for you to use it,

00:55:55,709 --> 00:55:58,309
the Ruby language has to become friendly with Java.

00:55:58,309 --> 00:55:59,910
The simplest thing for example is RJB, which is a bridge to

00:55:59,910 --> 00:56:03,390
Java, which is still, we use by the way,

00:56:03,390 --> 00:56:05,170
over in JRuby as well as separately.

00:56:05,170 --> 00:56:07,299
So you need a way to actually have one language

00:56:07,299 --> 00:56:09,769
talk to another in somewhat standardized, simpler,

00:56:09,769 --> 00:56:11,049
less overhead mechanism.

00:56:11,049 --> 00:56:14,079
And I think that would really encourage people

00:56:14,079 --> 00:56:16,599
to use different languages without having

00:56:16,599 --> 00:56:19,499
to build this up layer or risk layer.

00:56:19,499 --> 00:56:21,679
Y.K.: So you're saying that at like binary level,

00:56:21,679 --> 00:56:24,849
actually like a foreign function interface and.

00:56:24,849 --> 00:56:27,119
I think the simplest way to do that is still over the network.

00:56:27,119 --> 00:56:29,140
Like when it's rest or it's zero MQO or whatever, right,

00:56:29,140 --> 00:56:31,599
it's like independent processes interacting with each other,

00:56:31,599 --> 00:56:33,599
isolated, not messing with each other.

00:56:33,599 --> 00:56:36,519
It just works well. Not convince the RJB or-

00:56:36,519 --> 00:56:38,369
V.K.: You're talking about it from an architecting

00:56:38,369 --> 00:56:41,189
a bigger system standpoint, but I'm just talking about

00:56:41,189 --> 00:56:43,809
simply, I'm running this web application, but certain

00:56:43,809 --> 00:56:45,920
part has to be paralyzed. I should be able to do it

00:56:45,920 --> 00:56:50,539
with less overhead, less new layers, if a simpler

00:56:50,539 --> 00:56:52,329
problem exists where that's applicable, right.

00:56:52,329 --> 00:56:54,150
What you were just talking about, it's applicable,

00:56:54,150 --> 00:56:56,689
has certain complexity and certain layer, but

00:56:56,689 --> 00:56:59,259
generally encouraging people to apply multiple

00:56:59,259 --> 00:57:01,589
languages to a single solution, right now,

00:57:01,589 --> 00:57:02,809
has so much overhead.

00:57:02,809 --> 00:57:06,109
I mean, today colleges are teach kids,

00:57:06,109 --> 00:57:07,969
people about different languages,

00:57:07,969 --> 00:57:09,640
but it's as if, like if you don't get a job

00:57:09,640 --> 00:57:12,589
in Java then go and look for a dot net job.

00:57:12,589 --> 00:57:14,359
That's really how we are learning multiple languages,

00:57:14,359 --> 00:57:16,400
so but we are not learning, it's not that

00:57:16,400 --> 00:57:17,609
we are not learning multiple languages,

00:57:17,609 --> 00:57:20,469
but we are not polyglots by default or

00:57:20,469 --> 00:57:22,589
by simplicity of the system.

00:57:22,589 --> 00:57:24,910
That is I believe, if you want to be,

00:57:24,910 --> 00:57:26,289
if you want to encourage polyglotism,

00:57:26,289 --> 00:57:27,829
you just have to go to the next level

00:57:27,829 --> 00:57:30,479
where languages will have to coexist with each other.

00:57:30,479 --> 00:57:30,949
B.G.: I think-

00:57:30,949 --> 00:57:32,319
V.K.: That is what we built with that notion.

00:57:32,319 --> 00:57:33,929
B.G.: Fair enough. So I think co-existence can

00:57:33,929 --> 00:57:35,910
be looked at from different angles.

00:57:35,910 --> 00:57:39,269
I think what you're talking about is run-time co-existence,

00:57:39,269 --> 00:57:42,609
you know, inside one run-time you have multiple languages running.

00:57:42,609 --> 00:57:44,439
I don't know that that's technically feasible-

00:57:44,439 --> 00:57:46,069
V.K.: It may not be run time, it may not be

00:57:46,069 --> 00:57:48,660
a single process co-existence- it would be a multi-process.

00:57:48,660 --> 00:57:51,429
B.G.: But it would have to be over some network, right.

00:57:51,429 --> 00:57:53,039
V.K.: No. For example, take RGB.

00:57:53,039 --> 00:57:54,380
B.G.: How does it work?

00:57:54,380 --> 00:57:56,059
V.K.: It's almost like you're just calling

00:57:56,059 --> 00:57:57,299
it into the process and kind of like-

00:57:57,299 --> 00:57:58,189
B.G.: But how does it really work?

00:57:58,189 --> 00:57:59,819
V.K.: It could even be-

00:57:59,819 --> 00:58:01,670
C.F.: It's still one process, right, RGB.

00:58:01,670 --> 00:58:02,670
B.G.: Yeah it's still one process.

00:58:02,670 --> 00:58:03,400
V.K.: I agree.

00:58:03,400 --> 00:58:04,859
B.G.: It's still one process, right.

00:58:04,859 --> 00:58:06,569
V.K.: JVM does its own thing, right.

00:58:06,569 --> 00:58:08,509
In a way JVM has its own layer-

00:58:08,509 --> 00:58:10,420
B.G.: But ultimately it's all JVM bite code-

00:58:10,420 --> 00:58:11,380
V.K.: True.

00:58:11,380 --> 00:58:14,529
B.G.: So I think we are all building, or have to

00:58:14,529 --> 00:58:17,079
build distributor systems at the end of the day today,

00:58:17,079 --> 00:58:18,829
and we're also trying to build abstractions.

00:58:18,829 --> 00:58:20,999
Right, that is the whole goal of building

00:58:20,999 --> 00:58:24,949
a software architecture that lets, let me find out which parts

00:58:24,949 --> 00:58:26,809
I can abstract and how.

00:58:26,809 --> 00:58:28,769
So what Yogi talked about,

00:58:28,769 --> 00:58:30,049
and totally agree with him,

00:58:30,049 --> 00:58:34,869
I think the best approach is to abstract away the optimal concerns

00:58:34,869 --> 00:58:35,939
and constructs of the system

00:58:35,939 --> 00:58:38,829
and tie them together using one language

00:58:38,829 --> 00:58:40,420
that is spoken on the system.

00:58:40,420 --> 00:58:43,410
So I think they used JSON in JSON Schema for the-

00:58:43,410 --> 00:58:44,189
Y.K.: It was in HTTP.

00:58:44,189 --> 00:58:45,289
B.G.: It was in HTTP, OK, yeah.

00:58:45,289 --> 00:58:48,309
So what you could use- you guys use it-

00:58:48,309 --> 00:58:50,459
you could use a message queue or maybe use

00:58:50,459 --> 00:58:53,359
something like zero in cue sockets to communicate

00:58:53,359 --> 00:58:57,939
over and maybe use Thrift or even JSON data for communication, but-

00:58:57,939 --> 00:58:58,509
H.K.: So-

00:58:58,509 --> 00:59:01,439
B.G.: The idea is to basically build a system

00:59:01,439 --> 00:59:04,789
of optimal components tied together but using one system,

00:59:04,789 --> 00:59:06,439
but then for the message buzz you can either

00:59:06,439 --> 00:59:09,439
use a socket or a message queue.

00:59:09,439 --> 00:59:14,400
H.K.: So, there's definitely a lot of tools which are,

00:59:14,400 --> 00:59:18,259
like run-times that exist which allow run-time re-use of languages,

00:59:18,259 --> 00:59:22,219
for example like, either on top of the LLVM or on top of JVM,

00:59:22,219 --> 00:59:24,929
you know like how you have Closure collections you can use

00:59:24,929 --> 00:59:27,309
from JRuby actually, there are projects that allow that.

00:59:27,309 --> 00:59:29,289
Do you think that all those are basically toys

00:59:29,289 --> 00:59:32,599
and shouldn't be used in any seriousness?

00:59:32,599 --> 00:59:35,209
B.G.: Closure collections are not toys.

00:59:35,209 --> 00:59:39,369
But what I would say that, I think that this idea,

00:59:39,369 --> 00:59:42,549
it can be applied to the JVM languages,

00:59:42,549 --> 00:59:44,109
but many times you have to use some language

00:59:44,109 --> 00:59:46,910
which is not available on the JVM, right.

00:59:46,910 --> 00:59:48,499
And you cannot use LLVM for it,

00:59:48,499 --> 00:59:50,809
because it's something which is much lower level

00:59:50,809 --> 00:59:53,679
than the JVM. So you'll have to use the network

00:59:53,679 --> 00:59:57,019
to communicate over each other.

00:59:57,019 --> 00:59:59,640
But as far as JVM languages are concerned, yeah, why not.

00:59:59,640 --> 01:00:03,849
At a theoretical level, inter-opt between languages

01:00:03,849 --> 01:00:06,890
is something that we should shoot for. Absolutely.

01:00:06,890 --> 01:00:10,130
QUERANT: I have a complaint and a question here.

01:00:10,130 --> 01:00:13,609
Complaint: You're arguing too much.

01:00:13,609 --> 01:00:17,429
You obviously are in disagreement.

01:00:17,429 --> 01:00:18,199
So

01:00:18,199 --> 01:00:22,009
B.G.: Agreeing too each other.

01:00:22,009 --> 01:00:26,799
C.F.: Closure collections are a toy then-

01:00:26,799 --> 01:00:29,479
I actually, when he was saying are these things a toy,

01:00:29,479 --> 01:00:32,989
I don't mean Closure collections, but I do think that,

01:00:32,989 --> 01:00:38,339
the whole idea of interrupt in a VM or in a process is overrated.

01:00:38,339 --> 01:00:40,709
And I think it's overrated, like,

01:00:40,709 --> 01:00:43,920
I remember being at Fu Camp talking to the parrot guys

01:00:43,920 --> 01:00:46,929
and LLVM guys awhile back in a workshop,

01:00:46,929 --> 01:00:48,089
and they were all complaining because they

01:00:48,089 --> 01:00:52,079
had tried to do like JavaScript on all these different VMs.

01:00:52,079 --> 01:00:53,910
They realized that like an array in JavaScript

01:00:53,910 --> 01:00:55,640
has different semantics then like an array in Java

01:00:55,640 --> 01:00:57,939
and an array in Ruby. You know if you add

01:00:57,939 --> 01:01:00,890
something way off in the distance,

01:01:00,890 --> 01:01:02,759
past the end of the array, in some languages

01:01:02,759 --> 01:01:04,789
it's an error and in some languages it nil fills,

01:01:04,789 --> 01:01:07,849
in some languages it's you know, so like,

01:01:07,849 --> 01:01:09,069
that's a really stupid example,

01:01:09,069 --> 01:01:12,380
and you can all imagine there's some way to solve that.

01:01:12,380 --> 01:01:15,239
But with the more interesting features of the language,

01:01:15,239 --> 01:01:18,429
that lead us to want to be polyglots,

01:01:18,429 --> 01:01:20,920
like I don't really think it makes sense to instantiate

01:01:20,920 --> 01:01:23,150
a Ruby class from Java, for example.

01:01:23,150 --> 01:01:24,329
Because the Ruby class does different

01:01:24,329 --> 01:01:27,799
things than the Java class and vice versa.

01:01:27,799 --> 01:01:30,289
Yes it can sometimes be nice.

01:01:30,289 --> 01:01:31,279
So like when you're in Closure

01:01:31,279 --> 01:01:33,039
and you want to use someone's ancient

01:01:33,039 --> 01:01:35,579
Java library that has been working for years,

01:01:35,579 --> 01:01:37,519
you just do it. When you do it, though,

01:01:37,519 --> 01:01:39,400
it's hideous, and it like, the Java interrupt

01:01:39,400 --> 01:01:42,079
is really not nice. And you know you're doing -

01:01:42,079 --> 01:01:44,819
it works fine. But it's uglier than Closure code.

01:01:44,819 --> 01:01:46,849
Right, so then you want to write something so it

01:01:46,849 --> 01:01:49,699
looks like Closure and feels like Closure.

01:01:49,699 --> 01:01:53,839
So personally I think an operating system is also

01:01:53,839 --> 01:01:56,509
like one process, you can think of it that way these days.

01:01:56,509 --> 01:01:59,219
It didn't use to be the case. But I can spin one up

01:01:59,219 --> 01:02:01,619
and start running it, and then have language interrupt

01:02:01,619 --> 01:02:05,049
with multiple processes in there talking via sockets,

01:02:05,049 --> 01:02:07,559
and it's conceptually not very different. Like if

01:02:07,559 --> 01:02:09,489
I describe it to my mom she won't know the difference

01:02:09,489 --> 01:02:12,119
between that and a virtual machine, so.

01:02:12,119 --> 01:02:14,019
B.G.: There's domain sockets in Unix, right.

01:02:14,019 --> 01:02:15,219
C.F.: Oh yeah domain sockets in Unix. Of course.

01:02:15,219 --> 01:02:16,739
This might be the solution, then.

01:02:16,739 --> 01:02:19,099
QUERANT: Quick question to all the panelists.

01:02:19,099 --> 01:02:22,609
As we stand today, what is the minimum number of languages,

01:02:22,609 --> 01:02:28,410
minimum set-up languages you would recommend to all the programmers.

01:02:28,410 --> 01:02:32,559
H.K.: 01:02:30 - dead audio

01:02:32,559 --> 01:02:38,449
C.F.: Did you tell him his question was invalid, is that it? I disagree.

01:02:38,449 --> 01:02:43,890
H.K.: So what I was trying to-

01:02:43,890 --> 01:02:44,489
B.G.: I would say it's a really awesome question.

01:02:44,489 --> 01:02:47,839
I would say is that maybe don't worry too much about

01:02:47,839 --> 01:02:49,799
the number of languages that you are learning,

01:02:49,799 --> 01:02:52,519
but number of different paradigms that you are learning, right.

01:02:52,519 --> 01:02:58,660
H.K.: So the question was like, like a kind of paraphrasing, like, so-

01:02:58,660 --> 01:03:01,679
B.G.: Doesn't matter. Look at the paradigms.

01:03:01,679 --> 01:03:05,130
If you already know C, then don't bother about C++,

01:03:05,130 --> 01:03:07,759
you know, for example, or whatever.

01:03:07,759 --> 01:03:12,189
H.K.: Yeah so the next question I had here was like,

01:03:12,189 --> 01:03:15,529
I'm just jumping back and forth, but like yeah,

01:03:15,529 --> 01:03:18,349
what next programming languages, like for example,

01:03:18,349 --> 01:03:22,829
you guys are looking forward to. Like you know

01:03:22,829 --> 01:03:26,499
starting with Swami like, sorry, Venkat, like-

01:03:26,499 --> 01:03:30,669
V.K.: OK I'm just looking for a better Ruby.

01:03:30,669 --> 01:03:32,809
H.K.: What do you mean by that?

01:03:32,809 --> 01:03:35,069
V.K.: It's more of- I'm just looking for a

01:03:35,069 --> 01:03:37,039
standardized Ruby where I should be able to

01:03:37,039 --> 01:03:39,529
switch between the Java world and the MRA world,

01:03:39,529 --> 01:03:41,880
without lots of friction and you know, and better

01:03:41,880 --> 01:03:43,709
performing Ruby generally speaking. When as much

01:03:43,709 --> 01:03:47,089
as we just talked about low-level you know you talk

01:03:47,089 --> 01:03:48,749
low-latency stuff. I think we can't keep saying that

01:03:48,749 --> 01:03:53,509
Ruby's, you know, it's really slow for a reason, right.

01:03:53,509 --> 01:03:57,630
And Ruby can run in a hot spot. I want- Java was slow

01:03:57,630 --> 01:04:00,069
because of hot- before hotspot. But Java became very,

01:04:00,069 --> 01:04:03,410
very fast through that time and lots of new work has

01:04:03,410 --> 01:04:05,259
put in there. So there has to be some research into

01:04:05,259 --> 01:04:08,079
performance in Ruby I think or something. I'm just looking

01:04:08,079 --> 01:04:13,739
for better Ruby essentially. For my investment of time and

01:04:13,739 --> 01:04:15,999
language. But certainly, I mean I would like to learn Scala

01:04:15,999 --> 01:04:17,499
and stuff that like, something.

01:04:17,499 --> 01:04:20,709
B.G.: So for me learning a new programming language is

01:04:20,709 --> 01:04:24,109
more like a cognitive exercise to expand my own thought

01:04:24,109 --> 01:04:29,679
processes, not specifically to you know apply in production.

01:04:29,679 --> 01:04:33,199
So the new language that I will be learning in 2014 is Factor,

01:04:33,199 --> 01:04:35,369
and you should check it out.

01:04:35,369 --> 01:04:39,059
C.F.: I was gonna say Factor.

01:04:39,059 --> 01:04:41,109
We should not sit next to each other. We're too similar.

01:04:41,109 --> 01:04:44,229
H.K.: Why, but why, can you just like say why exactly Factor?

01:04:44,229 --> 01:04:48,779
C.F.: I would say Factor because it really hurts to,

01:04:48,779 --> 01:04:50,329
it hurts in a non-stupid way.

01:04:50,329 --> 01:04:53,890
Like if you learn Befunge it hurts in a stupid way.

01:04:53,890 --> 01:04:57,369
Like there's no reason to learn Befunge except for fun.

01:04:57,369 --> 01:05:00,729
Factor, though, there's something clearly there, right.

01:05:00,729 --> 01:05:07,269
It's concatenative programming. It's a different way of having to think.

01:05:07,269 --> 01:05:10,229
And it's a different way that to me feels

01:05:10,229 --> 01:05:15,469
like it's deeper than it is stupid. It, so, actually

01:05:15,469 --> 01:05:19,949
I wouldn't probably learn it now, but I almost said that though.

01:05:19,949 --> 01:05:21,439
It was on my list.

01:05:21,439 --> 01:05:25,459
B.G.: I already know APL and a little bit of J maybe.

01:05:25,459 --> 01:05:28,679
But APL is, again another concatenative language,

01:05:28,679 --> 01:05:30,259
which inspired Factor.

01:05:30,259 --> 01:05:33,630
APL is some language which I can read but cannot type,

01:05:33,630 --> 01:05:36,269
because to type APL code you need a separate keyboard.

01:05:36,269 --> 01:05:39,749
That's why I'm learning Factor this year.

01:05:39,749 --> 01:05:41,079
H.K.: Yogi?

01:05:41,079 --> 01:05:45,719
Y.K.: I don't know, Sanskrit, maybe. (01:04:41 ??)

01:05:45,719 --> 01:05:48,880
But yeah, I think Go or Haskel.

01:05:48,880 --> 01:05:53,089
I think there the most differences from what I already know, so.

01:05:53,089 --> 01:05:57,890
H.K.: Fair enough. So I think a lot of first -

01:05:57,890 --> 01:06:01,319
learn programming languages and then the Dave Thomas

01:06:01,319 --> 01:06:04,729
like his book Pragmatic Programmer recommends like learn

01:06:04,729 --> 01:06:06,259
a programming language a year actually.

01:06:06,259 --> 01:06:09,809
And so one of the things that I've been

01:06:09,809 --> 01:06:13,150
wondering is like, how do you exactly like

01:06:13,150 --> 01:06:15,209
go about learning a language? You cannot,

01:06:15,209 --> 01:06:18,689
so like you cannot go to Flipkart and deploy

01:06:18,689 --> 01:06:21,049
a production system in Hascal, that, I don't

01:06:21,049 --> 01:06:24,579
know if you allow, but we talked about that already, actually.

01:06:24,579 --> 01:06:26,759
So but like how do, how does a person like

01:06:26,759 --> 01:06:28,390
when picking up a language go about

01:06:28,390 --> 01:06:32,229
learning a programming language, and like so-

01:06:32,229 --> 01:06:35,339
V.K.: So I think I've probably got the -

01:06:35,339 --> 01:06:39,059
so yeah like. I actually read the manual.

01:06:39,059 --> 01:06:44,059
Yeah, I'm so boring. And so I just read the manual

01:06:44,059 --> 01:06:47,400
just to get a flavor of what it's about and what's possible.

01:06:47,400 --> 01:06:50,559
Without going deeply into it it usually takes

01:06:50,559 --> 01:06:51,619
like a few hours, because it's really superficial.

01:06:51,619 --> 01:06:53,669
But once I get a sense of what the language is about,

01:06:53,669 --> 01:06:54,979
what the code constructs are, then do a second pass

01:06:54,979 --> 01:06:55,549
to kind of just decide really what's it about

01:06:55,549 --> 01:06:56,109
and then play around with some code. But as-

01:06:56,109 --> 01:06:56,419
(01:07:03 - dead audio space 01:07:47)

01:06:56,419 --> 01:06:57,049
C.F.: I would try to do some simple services

01:06:57,049 --> 01:07:01,809
and you know stuff with Actors running in the background.

01:07:01,809 --> 01:07:08,809
And whenever I saw something I didn't understand

01:07:29,609 --> 01:07:36,609
I would just go look in the source code for play.

01:07:51,839 --> 01:07:58,839
Then I would look at this crazy Scala type stuff

01:07:58,900 --> 01:08:00,739
and have to then read the manual for a few hours

01:08:00,739 --> 01:08:03,619
to figure out what's happening. But now I will never forget,

01:08:03,619 --> 01:08:06,390
because I encountered it through a painful situation,

01:08:06,390 --> 01:08:11,119
so I have like the emotional trigger to never let go of that knowledge.

01:08:11,119 --> 01:08:12,910
B.G.: That's interesting, yeah.

01:08:12,910 --> 01:08:16,660
I think, so every new language brings a different way

01:08:16,660 --> 01:08:20,420
of thinking to the table. So reading the manual

01:08:20,420 --> 01:08:23,080
should be the first thing that you should do I think.

01:08:23,080 --> 01:08:24,759
Maybe because, usually the manual is written

01:08:24,759 --> 01:08:26,310
by the author of the language,

01:08:26,310 --> 01:08:30,159
or at least some supporting material about the rational

01:08:30,159 --> 01:08:32,369
or the ethos of language.

01:08:32,369 --> 01:08:34,319
And once you have some superficial idea

01:08:34,319 --> 01:08:37,079
what the language, start building something.

01:08:37,079 --> 01:08:39,469
And at the same time look at the source code

01:08:39,469 --> 01:08:41,650
of the language, or maybe the standard library

01:08:41,650 --> 01:08:44,690
or some other products or tools that have already

01:08:44,690 --> 01:08:45,960
been written in that language,

01:08:45,960 --> 01:08:48,480
to get a sense of how things are detected,

01:08:48,480 --> 01:08:50,089
what the idioms could be.

01:08:50,089 --> 01:08:53,949
And basically read more code, and then write.

01:08:53,949 --> 01:08:56,529
I think I've always benefited more from

01:08:56,529 --> 01:08:59,359
reading a lot more code than writing.

01:08:59,359 --> 01:09:02,549
V.K.: Yeah I think the problem comes first in,

01:09:02,549 --> 01:09:02,989
I don't choose a language, just more of a problem,

01:09:02,989 --> 01:09:05,949
and I think this language could be better to solve that problem,

01:09:05,949 --> 01:09:08,179
and then just to find the quickest way to solve the problem

01:09:08,179 --> 01:09:09,719
and learn the crux of the language.

01:09:09,719 --> 01:09:14,429
And then go learn further by looking into the manual and other stuff.

01:09:14,429 --> 01:09:17,589
H.K.: So Chad I was talking to you before

01:09:17,589 --> 01:09:21,889
and like you said like don't just learn a language,

01:09:21,889 --> 01:09:23,460
deploy something production like similar,

01:09:23,460 --> 01:09:27,279
and don't learn a language in a year, like spend time with it.

01:09:27,279 --> 01:09:29,460
Build something, solve a hard problem,

01:09:29,460 --> 01:09:31,989
build something complicated, how do you say-

01:09:31,989 --> 01:09:35,259
C.F.: Well yeah what I was telling you about is Dave Thomas,

01:09:35,259 --> 01:09:37,989
who is one of the authors of Pragmatic Programmer

01:09:37,989 --> 01:09:41,409
who coined this language of the year idea,

01:09:41,409 --> 01:09:44,569
he spoke at RubyConf 2010 and he said that he had

01:09:44,569 --> 01:09:48,069
revised his thoughts on what the challenge should be.

01:09:48,069 --> 01:09:49,909
Instead of just learning a language every year,

01:09:49,909 --> 01:09:53,239
I think he has the same problem I do, he can't retain it.

01:09:53,239 --> 01:09:56,340
He challenged everyone to learn a language and deploy it

01:09:56,340 --> 01:09:58,760
to production every year.

01:09:58,760 --> 01:10:02,360
Because to him again it's the same thing I just described for myself,

01:10:02,360 --> 01:10:05,670
that he personally can't hold on to the knowledge

01:10:05,670 --> 01:10:08,400
unless he experiences the real pain

01:10:08,400 --> 01:10:10,570
of putting something into practice.

01:10:10,570 --> 01:10:11,699
V.K.: Absolutely.

01:10:11,699 --> 01:10:15,280
H.K.: So the pretty much like,

01:10:15,280 --> 01:10:17,550
you learn programming languages like a lot of persons,

01:10:17,550 --> 01:10:21,300
but really our day jobs still requires to programm in Ruby

01:10:21,300 --> 01:10:25,170
or Java or whatever, so, one of the key things like,

01:10:25,170 --> 01:10:28,079
you write Lisp, you become a better Java programmer.

01:10:28,079 --> 01:10:30,659
That's the wisdom so, like, how do you exactly go

01:10:30,659 --> 01:10:32,369
about adopting features, you know like, for example,

01:10:32,369 --> 01:10:37,929
like Closure or Scala or Haskel or Go, and you know

01:10:37,929 --> 01:10:41,789
like the language the you program in day to day,

01:10:41,789 --> 01:10:44,329
maybe for the dayjob. So like,

01:10:44,329 --> 01:10:45,250
B.G.: How do you adopt a new language?

01:10:45,250 --> 01:10:46,630
H.K.: How do you adopt features?

01:10:46,630 --> 01:10:47,260
B.G.: Ideas.

01:10:47,260 --> 01:10:48,199
H.K.: Ideas, yeah.

01:10:48,199 --> 01:10:51,010
B.G.: So, as I said, every language has a different

01:10:51,010 --> 01:10:55,719
way of you know solving problems. So for example

01:10:55,719 --> 01:10:57,110
if I take the example of Closure, in Closure there

01:10:57,110 --> 01:11:01,300
is a lot of emphasis on data. OK, you don't hide data

01:11:01,300 --> 01:11:04,090
inside objects and stuff.

01:11:04,090 --> 01:11:06,840
You basically treat everything as first class data structures

01:11:06,840 --> 01:11:09,750
and then manipulate the data using standard library

01:11:09,750 --> 01:11:12,530
functions and spit it out into a different format

01:11:12,530 --> 01:11:16,280
if you need to. So that, some design or architectural

01:11:16,280 --> 01:11:18,710
thinking that can be applied to any language, right.

01:11:18,710 --> 01:11:21,409
I know people who are actual provisional

01:11:21,409 --> 01:11:23,429
Python programmers, who learned Closure,

01:11:23,429 --> 01:11:25,909
did some real programming in Closure,

01:11:25,909 --> 01:11:28,190
and went back to doing Python

01:11:28,190 --> 01:11:30,929
and came back to me and told me that my Python code

01:11:30,929 --> 01:11:33,320
is so much better now, right.

01:11:33,320 --> 01:11:34,760
So I think it's not just about Closure

01:11:34,760 --> 01:11:39,770
or any specific language, but the idea is that,

01:11:39,770 --> 01:11:42,360
get a taste of the language,

01:11:42,360 --> 01:11:44,550
see how they think about solving problems,

01:11:44,550 --> 01:11:46,079
and you know, you may not be able

01:11:46,079 --> 01:11:47,829
to transport all the ideas,

01:11:47,829 --> 01:11:49,139
like if you like channels in

01:11:49,139 --> 01:11:51,510
Go you cannot build a channel-like thing in Java,

01:11:51,510 --> 01:11:55,360
for example. It would be very hard for you to do it.

01:11:55,360 --> 01:11:58,039
But at least if you have an appreciation for it,

01:11:58,039 --> 01:11:59,079
maybe who knows tomorrow you might

01:11:59,079 --> 01:12:03,199
be able to use a third party library to use it.

01:12:03,199 --> 01:12:06,949
C.F.: There's actually a problem that can happen,

01:12:06,949 --> 01:12:08,840
though. So you can take good things,

01:12:08,840 --> 01:12:12,780
like the data orientation or the ideas of immutability

01:12:12,780 --> 01:12:16,889
by default in Closure and then just try to make your

01:12:16,889 --> 01:12:20,309
Ruby code be like that, because you understand the benefits.

01:12:20,309 --> 01:12:23,429
Or you could do stuff like try

01:12:23,429 --> 01:12:26,039
(01:12:23 - dead audio space - 01:12:36)

01:12:26,039 --> 01:12:30,199
it's even possible to then simulate the features

01:12:30,199 --> 01:12:34,889
of one of these languages that you're learning from,

01:12:34,889 --> 01:12:41,150
but you emulate them in an environment that's not friendly to them,

01:12:41,150 --> 01:12:47,520
and it's a bad idea. So I would say don't go too crazy trying

01:12:47,520 --> 01:12:50,530
to make Ruby be functional more than it is,

01:12:50,530 --> 01:12:52,929
or to be Actor-oriented or whatever.

01:12:52,929 --> 01:12:57,130
B.G.: There will always be incidents (01:12:53)

01:12:57,130 --> 01:12:58,929
in practice, right.

01:12:58,929 --> 01:13:03,329
You'll figure it out if you try to apply it.

01:13:03,329 --> 01:13:07,179
Y.K.: I'm gonna agree with Chad, so.

01:13:07,179 --> 01:13:12,119
V.K. Yeah, OK, I'm not into this functional side

01:13:12,119 --> 01:13:15,880
or you know the Lisp side of Closure set of things yet.

01:13:15,880 --> 01:13:18,190
So my experience is essentially trying to play more

01:13:18,190 --> 01:13:20,520
ideas from Ruby into Java, and there was a-

01:13:20,520 --> 01:13:22,869
you know probably Java at level that we just talked about.

01:13:22,869 --> 01:13:25,710
It's such a, what is it called, a restrictive language.

01:13:25,710 --> 01:13:29,070
There is a lot that I could actually learn and apply to

01:13:29,070 --> 01:13:31,000
Java and Ruby which was really exciting.

01:13:31,000 --> 01:13:31,960
There were libraries,

01:13:31,960 --> 01:13:35,070
I think there were coming up for like

01:13:35,070 --> 01:13:37,360
calling anonymous functions or proc like things

01:13:37,360 --> 01:13:38,900
that I could actually use them.

01:13:38,900 --> 01:13:41,420
So those are, it was not really really tangible at

01:13:41,420 --> 01:13:44,840
specific example I could give. My Java programming extensively improved.

01:13:44,840 --> 01:13:49,360
Or readability of the code improved by having written Ruby code.

01:13:49,360 --> 01:13:51,960
Some of it will actually happen naturally I believe.

01:13:51,960 --> 01:13:54,119
B.G.: I don't think that -

01:13:54,119 --> 01:13:56,340
For example I was doing a lot of Python before

01:13:56,340 --> 01:13:59,710
I started doing some real Lisp programming.

01:13:59,710 --> 01:14:03,050
Python always had the map and filter and reduce functions.

01:14:03,050 --> 01:14:05,400
I was never able to appreciate those functions when

01:14:05,400 --> 01:14:08,320
I was just a Python programmer, OK. For example,

01:14:08,320 --> 01:14:11,630
Closure has something called protocols, OK.

01:14:11,630 --> 01:14:15,550
How many people here have heard about refinements in Ruby 2.0.

01:14:15,550 --> 01:14:17,389
C.F.: Refinements, yeah.

01:14:17,389 --> 01:14:19,550
B.G.: Yeah. It's a new feature.

01:14:19,550 --> 01:14:22,579
So, see, minority. OK, it's a really good feature,

01:14:22,579 --> 01:14:25,900
and it lets you do code monkey patching but restricted

01:14:25,900 --> 01:14:29,369
to a specific module, OK. So I think that,

01:14:29,369 --> 01:14:31,929
Ruby guys don't, are often are don't

01:14:31,929 --> 01:14:36,639
understand benefits then it's kind of like a shame, right.

01:14:36,639 --> 01:14:39,010
Y.K.: Yeah but that's a point right,

01:14:39,010 --> 01:14:40,820
that's something which has to happen at the language level.

01:14:40,820 --> 01:14:44,650
Like as a application developer who's not working on the language itself,

01:14:44,650 --> 01:14:48,539
adoption of features from other languages will run into bottle necks.

01:14:48,539 --> 01:14:52,059
So that's definitely one area where, for example in the Java world, right,

01:14:52,059 --> 01:14:55,500
when you move back from a lot of the ex-Ruby programmers

01:14:55,500 --> 01:14:58,489
move back to Java, and they created some beautiful libraries.

01:14:58,489 --> 01:15:02,520
Like for example I know an ex-thoughtworker who's done

01:15:02,520 --> 01:15:05,599
a library called (01:15:03), which allows you to kind of mimic

01:15:05,599 --> 01:15:07,309
Closures in Java, and it works through

01:15:07,309 --> 01:15:12,750
actually hooking up a Java agent at run time.

01:15:12,750 --> 01:15:14,679
So the point is it's a beautiful experiment,

01:15:14,679 --> 01:15:17,369
but you can't really use that in production

01:15:17,369 --> 01:15:18,579
because your IDs not going to recognize it,

01:15:18,579 --> 01:15:21,280
you know simple things like that which might

01:15:21,280 --> 01:15:23,300
seem like trivial but they actually hurt, because

01:15:23,300 --> 01:15:25,860
another the code syntax highlighting is kind of

01:15:25,860 --> 01:15:28,199
gone for a toss. The debug obviously doesn't work,

01:15:28,199 --> 01:15:28,309
you can't-

01:15:28,309 --> 01:15:33,719
So you got to hook up the agent while running the app.

01:15:33,719 --> 01:15:38,900
So it becomes tricky, so I think a lot of the language

01:15:38,900 --> 01:15:41,719
features which get adopted do get a lot of those frameworks.

01:15:41,719 --> 01:15:44,170
For example, Actor systems, even though we don't have

01:15:44,170 --> 01:15:49,000
it in Java, kind of analogies of that have been funnily

01:15:49,000 --> 01:15:52,409
enough systems like Mule (01:15:40) right, which is again

01:15:52,409 --> 01:15:55,409
enterprising and boring, but essentially it solves

01:15:55,409 --> 01:15:56,949
the same problem. Like not at the language level but

01:15:56,949 --> 01:16:00,190
it allows you to coordinate independent Actors

01:16:00,190 --> 01:16:04,369
and construct bulges (01:16:01) of flows which kind

01:16:04,369 --> 01:16:06,869
of do something productive and allow you to scale

01:16:06,869 --> 01:16:08,270
out in a very simple way, right.

01:16:08,270 --> 01:16:11,550
So frameworks end up kind of taking their place in a certain way.

01:16:11,550 --> 01:16:14,199
I think it's difficult to bring it down to a language very well.

01:16:14,199 --> 01:16:16,579
V.K.: That kind of introduced like using

01:16:16,579 --> 01:16:18,099
play framework in Java, right.

01:16:18,099 --> 01:16:20,139
It actually brings a lot of Rails goodness

01:16:20,139 --> 01:16:23,090
and Rails inspiration into Java, so you don't,

01:16:23,090 --> 01:16:24,500
it's not necessarily about the language weights.

01:16:24,500 --> 01:16:27,409
It's also things like dimension or configuration,

01:16:27,409 --> 01:16:29,440
which can be learned and applied into other languages.

01:16:29,440 --> 01:16:31,969
So just ideas are behind a specific paradigm,

01:16:31,969 --> 01:16:34,750
the simplicity or the philosophy behind it can

01:16:34,750 --> 01:16:37,020
be applied into other languages, like Java from Ruby.

01:16:37,020 --> 01:16:39,889
So I think the framework side of it plays I think a big role.

01:16:39,889 --> 01:16:41,300
Y.K.: Yeah that's a great point because there's

01:16:41,300 --> 01:16:46,230
funnily enough right like a framework like Rails

01:16:46,230 --> 01:16:48,989
or Sinatra was invented in Java. Why is that?

01:16:48,989 --> 01:16:52,030
Because the thought process that's behind Java

01:16:52,030 --> 01:16:54,030
is just not tooled to the kind of thinking and

01:16:54,030 --> 01:16:55,750
such lightweight simplistic services.

01:16:55,750 --> 01:16:59,239
And it only took somebody to kind of look at Ruby,

01:16:59,239 --> 01:17:01,159
see its simplicity and be able to kind of build

01:17:01,159 --> 01:17:02,349
something so simple as Sinatra, like it's beautiful.

01:17:02,349 --> 01:17:04,250
And now that thought process has come out.

01:17:04,250 --> 01:17:05,900
So yeah play's a great example actually.

01:17:05,900 --> 01:17:07,840
V.K.: Yeah I think there's two things you know,

01:17:07,840 --> 01:17:10,929
the discussion kind of weighed towards more towards

01:17:10,929 --> 01:17:14,469
the paradigms, more. But I think there is an

01:17:14,469 --> 01:17:16,280
things like simplicity, conventional configuration

01:17:16,280 --> 01:17:20,409
or concepts, which is another side that languages have,

01:17:20,409 --> 01:17:23,369
which are not specific to how to make parallelism better

01:17:23,369 --> 01:17:25,320
which are not specific to how to do functional programming,

01:17:25,320 --> 01:17:27,340
but still something which was not done before or

01:17:27,340 --> 01:17:29,780
easy enough in your language, which you could have applied.

01:17:29,780 --> 01:17:31,210
You know the language is easier.

01:17:31,210 --> 01:17:32,639
But those are not new libraries

01:17:32,639 --> 01:17:34,570
or nothing to do with really specific functions.

01:17:34,570 --> 01:17:36,969
But you could get better in other languages by

01:17:36,969 --> 01:17:39,179
looking at this other philosophy behind

01:17:39,179 --> 01:17:41,699
the language just beyond a specific paradigm

01:17:41,699 --> 01:17:43,119
of the strength of the language.

01:17:43,119 --> 01:17:47,469
H.K.: So we are about to close the panel discussion.

01:17:47,469 --> 01:17:50,980
Any questions? We have time for questions.

01:17:50,980 --> 01:17:51,659
Actually.

01:17:51,659 --> 01:17:55,179
C.F.: Or how about you just raise your hand

01:17:55,179 --> 01:17:56,199
if you want to ask a question

01:17:56,199 --> 01:17:59,230
and otherwise we'll all get tea. You have a question.

01:17:59,230 --> 01:18:04,739
B.G.: Or we can just move the discussion to the break room.

01:18:04,739 --> 01:18:10,340
We could do that. So let's just you know - OK.

01:18:10,340 --> 01:18:17,340
QUERANT: So I worked in different programming languages.

01:18:17,800 --> 01:18:22,869
So about four to five, so I think programming languages

01:18:22,869 --> 01:18:26,469
rose to such heights because either because the programming

01:18:26,469 --> 01:18:29,170
language itself or through its supporting libraries.

01:18:29,170 --> 01:18:32,539
For example, Ruby was not in so much mainstream until

01:18:32,539 --> 01:18:38,610
Rails came into existence. And Python for scientific calculation.

01:18:38,610 --> 01:18:41,949
C for internal system, you know Linux kind of stuff.

01:18:41,949 --> 01:18:42,969
C++ for games and other stuff.

01:18:42,969 --> 01:18:45,849
So what all, I mean do these programming languages

01:18:45,849 --> 01:18:50,369
have and uh, example like Scala, Closure, Go, Erlang.

01:18:50,369 --> 01:18:53,000
So these are upcoming, like dot also.

01:18:53,000 --> 01:18:54,860
So what do these programming languages have

01:18:54,860 --> 01:18:57,380
that they'll come on call. I mean what do these libraries,

01:18:57,380 --> 01:19:00,420
I mean what are the bigger libraries that they have,

01:19:00,420 --> 01:19:03,170
so that people like me can use them for certain purpose.

01:19:03,170 --> 01:19:06,480
So what all they are useful for?

01:19:06,480 --> 01:19:08,760
C.F.: That'll take awhile.

01:19:08,760 --> 01:19:11,340
B.G.: That's a very long-winded question.

01:19:11,340 --> 01:19:13,909
I'll very quickly answer that.

01:19:13,909 --> 01:19:16,909
Every language probably has a killer app, right,

01:19:16,909 --> 01:19:20,059
to champion it or maybe make it famous or popular.

01:19:20,059 --> 01:19:25,909
Not every, not all languages have one specific killer app,

01:19:25,909 --> 01:19:28,320
for example, while, what would you say the

01:19:28,320 --> 01:19:30,489
killer app for JavaScript is, right?

01:19:30,489 --> 01:19:31,969
Or what about Objective C?

01:19:31,969 --> 01:19:33,949
Right, just that you don't have any other choice

01:19:33,949 --> 01:19:37,400
in those cases, right. If you want to program for the browser,

01:19:37,400 --> 01:19:38,889
JavaScript is your only choice,

01:19:38,889 --> 01:19:42,119
Objective C if you are doing Apple programming, right.

01:19:42,119 --> 01:19:45,030
So yeah, I mean, every once in awhile there

01:19:45,030 --> 01:19:47,929
are projects or libraries or products which

01:19:47,929 --> 01:19:49,480
do come and make something very famous.

01:19:49,480 --> 01:19:54,510
But it may not be true for everything.

01:20:01,400 --> 01:20:02,740
H.K.: If anybody has any other questions

01:20:02,740 --> 01:20:06,000
then I can (drowned out by applause - 01:20:05)

01:20:06,780 --> 01:20:08,740

YouTube URL: https://www.youtube.com/watch?v=zmGEUorbkPc


