Title: RubyConf 2019 - Opening Keynote - Ruby Progress Report by Yukihiro Matzumoto (Matz)
Publication date: 2019-11-27
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Opening Keynote - Ruby Progress Report by Yukihiro Matzumoto (Matz)

#confreaks #rubyconf2019 #rubyconf
Captions: 
	00:00:14,969 --> 00:00:26,539
Good morning, everyone. Thank you. I always feel nervous before you. Every year. This

00:00:26,539 --> 00:00:38,320
is RubyConf, the canonical Ruby conference. This is the 19th conference? Yeah. Thank you

00:00:38,320 --> 00:00:47,840
for coming.  And I am very glad to have so many first‑timers. We

00:00:47,840 --> 00:00:58,830
welcome you. So, I'm talking about Ruby, because this is a Ruby conference. Ruby is

00:00:58,830 --> 00:01:02,900
pretty popular programming language. You know that. 

00:01:02,900 --> 00:01:13,920
And it is 11th in the TIOBE index out of 150 programming languages. And ranked eighth

00:01:13,920 --> 00:01:19,920
in the Redmonk index. So, it's quite popular... still. 

00:01:19,920 --> 00:01:25,470
But nothing lasts long. And then the pride goes before a fall. 

00:01:25,470 --> 00:01:39,400
[ Laughter ] So we have to be anxious about extinction. So,

00:01:39,400 --> 00:01:49,120
what makes Ruby great? I think the best one is the programming joy. Back in the '90s,

00:01:49,120 --> 00:01:58,010
so there are people, especially programming language designers tend to focus on the efficiency. So,

00:01:58,010 --> 00:02:08,119
the computers were so slow back in the '80s and '90s so that we had to focus on the performance

00:02:08,119 --> 00:02:14,860
of the language. Compiling program language and static type framing languages were popular

00:02:14,860 --> 00:02:28,530
like C, C++. JavaScript was not there. And then ‑‑ but as a programmer, I started

00:02:28,530 --> 00:02:38,530
creating Ruby in 1993. So, back then, very few programming languages focused on humans. They

00:02:38,530 --> 00:02:47,010
tried to focus on machines, because they need more performance. But I'm ‑‑ I was a

00:02:47,010 --> 00:02:59,709
hobby programmer. The programming languages itself were my hobby. So, I created Ruby

00:02:59,709 --> 00:03:05,040
just for fun. It was my hobby. I didn't expect this big audience. 

00:03:05,040 --> 00:03:15,830
[ Laughter ] But... because Ruby was originally my hobby,

00:03:15,830 --> 00:03:27,060
so I was no order or requirement from the customers. I didn't have any specific reason

00:03:27,060 --> 00:03:36,989
to create something. I just created Ruby for myself. I enjoyed creating Ruby. I enjoyed

00:03:36,989 --> 00:03:45,470
implementing Ruby, and I enjoyed designing the language. For that reason, I focused

00:03:45,470 --> 00:03:57,340
on myself, because I'm so selfish. A selfish person. But accidentally, many of you felt

00:03:57,340 --> 00:04:07,000
similar, and I happened to make it a free software. So, people are free to use that,

00:04:07,000 --> 00:04:15,810
without any money. So, people started using it in scripting, gaming, building some desktop

00:04:15,810 --> 00:04:24,270
application or something. And the web came in. And then the people started using ‑‑

00:04:24,270 --> 00:04:33,139
creating web applications using Ruby.  Programming was pretty popular back then,

00:04:33,139 --> 00:04:39,900
but Ruby is better in many ways. Ruby is the pure object‑oriented framing language. It

00:04:39,900 --> 00:04:49,250
is modular. It is powerful. And it is a little bit readable. Not like pearl, in many

00:04:49,250 --> 00:04:58,870
cases.  And then mostly because of the joy of the

00:04:58,870 --> 00:05:05,500
programming, the Ruby programming tends to be productive. Because most of the time when

00:05:05,500 --> 00:05:13,500
you are using Ruby, you are highly motivated. You are productive when you're motivated. And

00:05:13,500 --> 00:05:21,530
you are motivated when you feel joy. Right? So that's one of the reasons Ruby is highly productive. Of

00:05:21,530 --> 00:05:31,310
course we have many convenient and strong features for productivity. But the best key

00:05:31,310 --> 00:05:38,940
of Ruby productivity is the motivation and joy. 

00:05:38,940 --> 00:05:44,879
Of course it is very good language design. Of course I designed it. 

00:05:44,879 --> 00:05:51,551
[ Laughter ] But most importantly, we have resources, because

00:05:51,551 --> 00:06:04,960
so many people created libraries and frameworks and Gems. So, those resources help you become

00:06:04,960 --> 00:06:17,060
even more productive. Those resources does not come out of nowhere. It's

00:06:17,060 --> 00:06:27,520
from the community. So, I think the community is the key of Ruby's success and popularity

00:06:27,520 --> 00:06:34,919
and productivity ‑‑ everything. Ruby is the community. Okay. Ruby is a language

00:06:34,919 --> 00:06:45,500
software. And it's good, you know? It's good language. It's well‑designed. But

00:06:45,500 --> 00:06:58,080
the community is more important.  If I didn't put it on the internet, if I didn't

00:06:58,080 --> 00:07:10,280
make it open‑source, Ruby might be nothing without community. It should have been nothing. So,

00:07:10,280 --> 00:07:17,949
that you are the Ruby.  In that sense, we have to attract people,

00:07:17,949 --> 00:07:33,850
because the community without newcomers will be, you know, dimmed. Go away. So, we have

00:07:33,850 --> 00:07:40,900
to attract people. Those newcomers ‑‑ welcome! Those newcomers are a very good

00:07:40,900 --> 00:07:48,600
sign of Ruby's success.  We have to provide technology to attract people,

00:07:48,600 --> 00:07:55,810
good community to attract people, and we need more jobs to attract people. And yeah. Broader

00:07:55,810 --> 00:08:02,139
audience to attract people.  Open source community cannot stop. We are

00:08:02,139 --> 00:08:14,490
like kind of a shark. We have to keep swimming. Because we cannot expect high loyalty for free. Because

00:08:14,490 --> 00:08:20,490
you are not forced to use Ruby ‑‑ okay, most of you. 

00:08:20,490 --> 00:08:25,740
[ Laughter ] You came to the community. You came to the

00:08:25,740 --> 00:08:36,399
conference because you felt Ruby is good, and that you wanted to learn more about Ruby,

00:08:36,399 --> 00:08:50,069
right? So this is attractiveness. But because you're not forced, you can go to Python, PHP,

00:08:50,069 --> 00:09:00,740
JavaScript, or whatever. You can freely go away from the community. So, we have to attract

00:09:00,740 --> 00:09:12,149
people. We attract people by good technology, good community, and the participation is the

00:09:12,149 --> 00:09:20,510
key.  We call it open. We are open community. So,

00:09:20,510 --> 00:09:28,749
Ruby is often called open‑source software. I'm in the free software camp, but I like the

00:09:28,749 --> 00:09:43,189
term "open," because open means welcome. Welcoming you. So, I like the term open. And being

00:09:43,189 --> 00:10:00,420
open as a community, we build the future of Ruby. Not me only, but with you. 

00:10:00,420 --> 00:10:13,339
The roadmap. I rarely talk about the roadmap, but this time is an exception. There year,

00:10:13,339 --> 00:10:20,269
December ‑‑ next month ‑‑ we are going to release Ruby 2.7. 

00:10:20,269 --> 00:10:27,639
[ Applause ] As a Christmas gift. 

00:10:27,639 --> 00:10:34,709
[ Laughter ] As usual. And next year, we are going to

00:10:34,709 --> 00:10:45,009
release Ruby 3.0.  [ Applause ]

00:10:45,009 --> 00:10:51,139
Very importantly, this is fixed. No matter what happens, we are going to have the Ruby

00:10:51,139 --> 00:11:01,160
3.0 next year. Actually, some members of the core members, including me are a bit worried

00:11:01,160 --> 00:11:12,130
that we cannot keep the deadline of Ruby 3.0. But unless extremely bad things happen...

00:11:12,130 --> 00:11:23,269
[ Laughter ] We may drop some announced features in Ruby3,

00:11:23,269 --> 00:11:35,329
but we will release Ruby3 next year.  They will come later if we drop. We will

00:11:35,329 --> 00:11:37,850
try our best.  [ Laughter ]

00:11:37,850 --> 00:11:47,399
So okay. Let me tell you about Ruby 2.7 coming pretty soon. We are going to have the very

00:11:47,399 --> 00:11:59,170
nifty feature in Ruby 2.7, because Ruby 3.0 will not be the big jump. It's just a next

00:11:59,170 --> 00:12:06,839
release. We have the big jump in the version number, but not big jump in the language. So,

00:12:06,839 --> 00:12:17,549
there are some new features prepared for the Ruby 3.0 is released with Ruby 2.7. 

00:12:17,549 --> 00:12:22,940
The first one is the pattern matching. We are going to have it. Not the regular expression

00:12:22,940 --> 00:12:34,540
pattern matching. But the pattern matching from many functional programming languages. 

00:12:34,540 --> 00:12:44,220
With using the pattern matching, you can, like this. Took the JSON data and pattern

00:12:44,220 --> 00:12:56,619
match to the recall named Alice and her child, Bob, and retrieved the age of her son. Or

00:12:56,619 --> 00:13:06,989
no Alice. Well, if you write down the existing Ruby, you have to write it like this. Okay? The

00:13:06,989 --> 00:13:16,839
person's name is Alice. Then children is Alice's children. And Alice has one child

00:13:16,839 --> 00:13:25,569
whose name is Bob. And retrieve the age of his son or something like that. 

00:13:25,569 --> 00:13:37,529
This is quite straightforward, isn't it? Yeah. Okay. Pattern matching can make Ruby more concise. So,

00:13:37,529 --> 00:13:43,589
we are going to have the pattern matching. Okay. I admit it. The pattern match something slow

00:13:43,589 --> 00:13:45,439
right now.  [ Laughter ]

00:13:45,439 --> 00:13:52,009
If you use a pattern matching Ruby 2.7, you will be warned. 

00:13:52,009 --> 00:13:58,870
[ Laughter ] This is experimental feature, but you can

00:13:58,870 --> 00:14:07,819
use it anyway. And I bet you will use it. And you will love it. 

00:14:07,819 --> 00:14:15,689
Okay. Keyword arguments. I admit that I regret some part of keyword arguments, because

00:14:15,689 --> 00:14:27,179
of some of the history issue. But back in Ruby 1.9, I allowed to put the hash argument

00:14:27,179 --> 00:14:40,129
at the bottom of the keyword. So, that people can use the hash as a keyword argument, emulating

00:14:40,129 --> 00:14:48,269
keyword arguments. Then Ruby 2.0 introduced some part of the keyword argument, but we

00:14:48,269 --> 00:15:00,750
have to support the pre‑existing emulation. So, combining that, we have some weird corner

00:15:00,750 --> 00:15:11,810
cases. So, it's kind of confusing. For example, what should happen? We have the method named

00:15:11,810 --> 00:15:24,139
m, and it has two arguments. One is traditional. The other is keywords. Then call method m with

00:15:24,139 --> 00:15:34,299
a keyword argument. What should happen? Error? Yeah. It should be error, I think. But it works like

00:15:34,299 --> 00:15:43,139
this.  Whoa. Okay. Next question. What should

00:15:43,139 --> 00:15:52,609
happen one is optional argument, the other is keyword argument. And I call it with one

00:15:52,609 --> 00:16:05,499
keyword argument. What should happen? Reality is this...

00:16:05,499 --> 00:16:13,259
Kind of confusing. Okay. Keyword arguments pitfalls. The wrong number of arguments cause

00:16:13,259 --> 00:16:21,040
very nasty confusion. And in combination with optional or rest arguments can be confusing. And

00:16:21,040 --> 00:16:29,959
combination with hash arguments is confusing. So, we should fix to avoid future tragedy. 

00:16:29,959 --> 00:16:40,589
I know it's backward incompatible, but it's a pain we must suffer. So, we will do it

00:16:40,589 --> 00:16:47,009
in gradual steps. Step one, Ruby 2.7. Step two is Ruby 3.0 or later...

00:16:47,009 --> 00:16:57,089
Ruby 2.7, the behavior is basically compatible with Ruby 2.6 or before. But you will get

00:16:57,089 --> 00:17:12,260
warnings. And Ruby 2.7 introduced very ugly Ruby2 keywords method. In 3.0, we will introduce

00:17:12,260 --> 00:17:18,640
real keyword arguments. So, that means you can write the program that runs on both Ruby

00:17:18,640 --> 00:17:30,460
2.6 and 2.7. You can write the Ruby program that runs on both Ruby 2.7 and Ruby 3.0. But

00:17:30,460 --> 00:17:38,480
not for Ruby 2.6 and Ruby 3.0, because of this incompatibility. So, you have to migrate. 

00:17:38,480 --> 00:17:49,990
But, after this pain, unfortunately, this unfortunate pain, keyword arguments will be

00:17:49,990 --> 00:18:00,409
simpler, easier, and safer. I will tell you, this is the biggest incompatibility in Ruby

00:18:00,409 --> 00:18:05,860
3.  I'm sorry. But you have to suffer. We will

00:18:05,860 --> 00:18:15,019
provide a migration path so that we try to least your pain. 

00:18:15,019 --> 00:18:29,210
Okay. Numbered parameters. We introduced numbered parameters. Okay. _1 is the default

00:18:29,210 --> 00:18:40,169
parameter, first default parameters. Okay? So you can take these elements and double them. It's

00:18:40,169 --> 00:18:53,090
quite easy. And you can use it,_1,_2, local variables and the methods. But be warned. Stop

00:18:53,090 --> 00:19:01,799
using it for your new programs. Okay?  Next one is argument forwarding. You can

00:19:01,799 --> 00:19:08,730
write it like this. Three dots. Receiving any arguments in three dots, and they are

00:19:08,730 --> 00:19:19,799
passing any arguments in three dots. You need to wrap them in parens always. You can

00:19:19,799 --> 00:19:27,120
drop the parentheses around the arguments for most cases in Ruby. But this is one of

00:19:27,120 --> 00:19:33,600
the exceptions. You have to wrap the argument forwarding in parentheses. 

00:19:33,600 --> 00:19:43,700
Begin/end ranges. This is kind of trivial. But one, dot dot means the endless range. So,

00:19:43,700 --> 00:19:55,130
it means the one and forever. And then ..10 is negative infinity to one. I'm sorry. 

00:19:55,130 --> 00:20:11,450
So GC compaction. We will introduce memory compaction. We have less memory consumption,

00:20:11,450 --> 00:20:21,799
but it should be manual compaction. So, memory compaction is still slow, so you have to tell

00:20:21,799 --> 00:20:26,779
the garbage collector to compact when you are idle. 

00:20:26,779 --> 00:20:44,340
So Unicode 12.1 and more emojis. More emojis.  [ Laughter ]

00:20:44,340 --> 00:20:50,990
[ Applause ] Some will appreciate it, but as an implementer

00:20:50,990 --> 00:20:53,779
of the text processing, I say nah.  [ Laughter ]

00:20:53,779 --> 00:21:15,809
Better IRB. IRB, we introduced the multi‑line edit for IRB. If you hit the top key twice,

00:21:15,809 --> 00:21:24,139
you will see the, you know, the inline references. You don't have to switch the window or terminate

00:21:24,139 --> 00:21:34,490
the IRB to look up the reference.  We will have faster fiber. Samuel Williams

00:21:34,490 --> 00:21:44,600
improved it a lot. Great.  And we will have the faster JIT compiler,

00:21:44,600 --> 00:21:58,100
great.  And Ruby JIT will be very close to 3x3 in

00:21:58,100 --> 00:22:02,549
some benchmarks.  [ Applause ]

00:22:02,549 --> 00:22:12,519
Thank you. And we added many convenient methods like enumerable tally due to elements of the

00:22:12,519 --> 00:22:24,030
enumerable. The filter_map, and the unbound method to bind_call and others. 

00:22:24,030 --> 00:22:42,510
So what's not new in Ruby 2.7? Pipeline operator. From F #and elixir. They have this instead of

00:22:42,510 --> 00:22:50,760
this. But, it's canceled.  [ Laughter ]

00:22:50,760 --> 00:22:59,960
Okay. Natural pipeline operator behavior in Ruby is very dependent on the definition

00:22:59,960 --> 00:23:01,820
of natural.  [ Laughter ]

00:23:01,820 --> 00:23:10,210
Let me explain a little bit more about that. I was very frustrated about that. Pipeline

00:23:10,210 --> 00:23:25,990
operator in F # defines it like this. And this operator on the left‑hand side argument

00:23:25,990 --> 00:23:38,759
at the bottom of the argument list. In Elixir, it's defined in macro, and it's the left‑hand

00:23:38,759 --> 00:23:49,850
operand as the first argument as the function calls. That means the behavior of the pipeline

00:23:49,850 --> 00:24:00,389
operator differs in F # and elixir according to the culture and library design of the language. The

00:24:00,389 --> 00:24:07,730
concept of the pipeline operator, the common behavior of the pipeline operator is to add

00:24:07,730 --> 00:24:18,230
primary argument to the call. So, I defined natural behavior of pipeline operator for

00:24:18,230 --> 00:24:26,870
Ruby, and it should add primary argument to the call. Think about the map method in Ruby,

00:24:26,870 --> 00:24:34,890
the primary operator, the most important argument, which is the enumerable, is the receiver. So,

00:24:34,890 --> 00:24:43,039
add primary argument to the call means to add primary argument as the receiver...

00:24:43,039 --> 00:24:52,990
It is the method call. But many people expect Elixir's pipeline behavior, because they know

00:24:52,990 --> 00:25:08,190
Elixir's. So, there are far more than I thought. The common sense is defined by the community. So,

00:25:08,190 --> 00:25:14,330
if I strongly insist the proposed behavior, I would have tried to persuade the community. And

00:25:14,330 --> 00:25:30,750
it would take years. But even though I was the original proposer of the idea... yeah. It's

00:25:30,750 --> 00:25:39,529
okay to drop for me. Unfortunately, not that much. So, I canceled. 

00:25:39,529 --> 00:25:47,980
The second one is a method reference operator. In Python and some other languages, the obj.foo

00:25:47,980 --> 00:26:00,120
returns the foo method from Ruby at obj. But in Ruby, obj.foo calls method, even with a

00:26:00,120 --> 00:26:10,480
parentheses. So, the parentheses is not significant in Ruby language. It's very useful. Obj.foo

00:26:10,480 --> 00:26:24,110
can be attribute retrieving defined by method. So, you can easily define the accessor. So, it's

00:26:24,110 --> 00:26:32,660
quite suitable for object‑oriented programming language. But it's relatively harder to get

00:26:32,660 --> 00:26:41,390
a method object. You have to do like this. Obj.method, and the symbol. 

00:26:41,390 --> 00:26:53,210
So, instead of the existing way to retrieve the method object, we proposed obj.:foo to

00:26:53,210 --> 00:27:05,200
retrieve the method object. Yeah... but it's useful in some cases, and it's short and it

00:27:05,200 --> 00:27:14,679
is powerful, but ugly. Yeah. It kind of looks like braille. Yep. And in recent years,

00:27:14,679 --> 00:27:22,860
we have added some features as part of functional programming languages, but we didn't have

00:27:22,860 --> 00:27:30,090
the grand design of functional programming in Ruby. So, we will take time to think about

00:27:30,090 --> 00:27:39,769
functional programming in Ruby. So, it's canceled for Ruby 2.7 to rethink. But maybe

00:27:39,769 --> 00:27:47,980
we will provide method reference operator in Ruby 3 or farther in the future. But we

00:27:47,980 --> 00:27:56,139
have to make some grand design of the functional programming in Ruby. 

00:27:56,139 --> 00:28:08,750
So, what's next? You will have the Ruby 3.0, and the current plan ‑‑ I talked with

00:28:08,750 --> 00:28:18,380
many people to design the future of Ruby. Last few years, we are working on improving the

00:28:18,380 --> 00:28:26,059
performance. And we have to be a multi‑core ware. And we can address the bigger team

00:28:26,059 --> 00:28:34,201
and bigger projects.  So the Ruby3 should have the VM performance

00:28:34,201 --> 00:28:43,270
and con currency and static analysis. So, the VM performance. We already ‑‑ Ruby

00:28:43,270 --> 00:28:53,070
2.6, last year, we shipped with the JIT compiler, experimental JIT compiler. It ran Ruby applications

00:28:53,070 --> 00:29:03,500
faster, two times faster for some cases, very CPU‑intensive tasks. But whereas the application

00:29:03,500 --> 00:29:11,639
runs slower, unfortunately. But we are working on it for last year. And we are working on

00:29:11,639 --> 00:29:26,019
it for Ruby 3. And right now the JIT compiler for applications runs as fast as without JIT. Not

00:29:26,019 --> 00:29:38,200
faster yet. But we are trying.  And in some benchmarks like very CPU‑intensive

00:29:38,200 --> 00:29:48,789
benchmarks, it comes 2.8 times faster compared to Ruby 2.0. So, we are very close to Ruby

00:29:48,789 --> 00:30:01,820
3x3. So, yeah. We merged. Okay.  Next we have improved garbage collectors. We

00:30:01,820 --> 00:30:13,559
must ‑‑ the heap in 2.6 and compaction in 2.7. We keep improving performance. 

00:30:13,559 --> 00:30:23,630
Concurrency. Concurrency is hard. I regret adding threads. 

00:30:23,630 --> 00:30:31,910
[ Laughter ] I added threads to Ruby way before 1.8. So,

00:30:31,910 --> 00:30:42,460
they are way older. So, back then, every ‑‑ most of the computers only have one CPU. So,

00:30:42,460 --> 00:30:50,289
we didn't have to care about multi‑core. So, the grand design of the Ruby threads is stick

00:30:50,289 --> 00:31:00,960
to the single core. But, you know, these days we have many cores on laptops, smart

00:31:00,960 --> 00:31:13,840
phones, even on the Raspberry Pi. We have to care about multi‑core. So, in the multi‑core

00:31:13,840 --> 00:31:21,179
age, there are threads and the Ruby concurrency is hard to use correctly, hard to use it efficiently,

00:31:21,179 --> 00:31:29,919
and it's very hard to debug. We need a better concurrency abstraction. So, we talked a

00:31:29,919 --> 00:31:35,889
lot about the future of concurrency in Ruby, and we concluded we are going to provide a

00:31:35,889 --> 00:31:43,370
new concurrency model, one for CPU bottlenecks and the other for the IO bottlenecks. We

00:31:43,370 --> 00:31:56,659
will provide fibers for I/O bottlenecks. They should be

00:31:56,659 --> 00:32:04,000
easy to use, easy to debug, and they are easy to perform. 

00:32:04,000 --> 00:32:19,090
You might say that the go or elixir use single routine. The processes for go and elixir. But

00:32:19,090 --> 00:32:26,860
we need two. Because these languages are designed with the concurrency model from its

00:32:26,860 --> 00:32:38,059
day one. But these concurrency models add on, so that for the sake of the compatibility

00:32:38,059 --> 00:32:45,419
and the portability, so that we need two entities instead of one. The one is guilds or maybe

00:32:45,419 --> 00:32:53,019
we call isolates. We have to discuss it a little bit more. It's kind of like WebWorkers

00:32:53,019 --> 00:33:05,289
or Isolate in JavaScript. It helps the multi‑cores by offloading the CPU‑heavy tasks. 

00:33:05,289 --> 00:33:15,850
The fibers were a small enhancement. It uses the I/0 multitasking and built‑in async

00:33:15,850 --> 00:33:28,179
so that we are not going to have the async or await ‑‑ the reserved like in JavaScript

00:33:28,179 --> 00:33:39,409
or Python or whatever, but we just use fibers. You can't write down the normal subsequential

00:33:39,409 --> 00:33:48,279
program with the normal plexing.  And now, static analysis. We can call it

00:33:48,279 --> 00:33:57,809
static typing. As the project grows, the test becomes a burden. You know that. Testing

00:33:57,809 --> 00:34:10,220
increases in size and more time. And tests are not DRY. Don't Repeat Yourself principle. You

00:34:10,220 --> 00:34:20,490
know? We do write tests anyway, but we want to be more productive by reducing tests. The

00:34:20,490 --> 00:34:31,260
other languages tried to reduce the tests by providing type hinting or type annotations. Or

00:34:31,260 --> 00:34:37,780
even the different dialect of the language from Microsoft. 

00:34:37,780 --> 00:34:48,720
So what should we do? Add type annotations? Or the creating the alternative dialect like

00:34:48,720 --> 00:34:52,990
a TypeRuby? No.  [ Laughter ]

00:34:52,990 --> 00:35:03,130
I hate type annotations.  [ Applause ]

00:35:03,130 --> 00:35:12,760
Because it's not DRY. You know? You program, your current Ruby programs run without any

00:35:12,760 --> 00:35:20,040
type annotation, right? Because Ruby does not provide type annotations. Because I'm

00:35:20,040 --> 00:35:24,569
stubborn.  [ Laughter ]

00:35:24,569 --> 00:35:34,210
But if it works, so adding type annotation is kind of redundant. So, it's not DRY. So,

00:35:34,210 --> 00:35:41,160
that we won't add type hinting to the language, because it's not needed for my picture. The

00:35:41,160 --> 00:35:51,990
plan for Ruby static typing, we will provide static type information for standard libraries. In

00:35:51,990 --> 00:36:00,200
format named "Ruby Signatures." The future Gems can provide type information as well,

00:36:00,200 --> 00:36:09,240
so you can have the type information in different files from your programs. You may wonder

00:36:09,240 --> 00:36:19,300
that having different file ‑‑ so you have to make it in two files instead of one. But

00:36:19,300 --> 00:36:26,740
it has a reason. Because, you know, in the far distant future, maybe five years later

00:36:26,740 --> 00:36:38,410
or ten years later, we will have the very smart compiler with AI. So, that you can

00:36:38,410 --> 00:36:46,180
guess the type information without any type signature. So, that at that time, you don't

00:36:46,180 --> 00:36:52,550
have any type signature, Ruby signature, type annotation, no anything. You just learn by

00:36:52,550 --> 00:36:58,870
the compiler. Your program is wrong or something like that. You made mistake in this line

00:36:58,870 --> 00:37:08,640
of code. Compilers can tell you or teach you how to program Ruby. And we will provide

00:37:08,640 --> 00:37:16,430
a tool named the Type Profiler that uses AI for type checking. This AI stands for the

00:37:16,430 --> 00:37:21,569
abstract interpretation.  [ Laughter ]

00:37:21,569 --> 00:37:28,670
[ Applause ] So that traces call paths of your applications. And

00:37:28,670 --> 00:37:35,030
collecting type information of your application. And along with the checking type contradiction

00:37:35,030 --> 00:37:44,230
to the type information from the type signatures. Then generates signatures for your applications. And

00:37:44,230 --> 00:37:52,319
that means you will have the type information of your application without writing any type

00:37:52,319 --> 00:38:04,970
annotations. And then you can have the third party type checkers. So, that uses type information

00:38:04,970 --> 00:38:14,880
from signatures.  Currently we have some ‑‑ the Ruby static

00:38:14,880 --> 00:38:22,810
type checkers including RDL and Sorbet and Steep. Sorbet and Steep have their own sessions

00:38:22,810 --> 00:38:30,500
in this conference. If you have interest in it, go ahead and attend these sessions. And

00:38:30,500 --> 00:38:42,470
then, yeah. They don't use the Ruby signatures yet. The projects are started before the

00:38:42,470 --> 00:38:56,579
Ruby signatures. But all of us agree to adopt the Ruby signature gradually in the future. 

00:38:56,579 --> 00:39:02,309
What will happen with this type checking? You ordinary Ruby programs will be statically

00:39:02,309 --> 00:39:10,359
type checked. Errors in compile time without any type annotations in your Ruby programs. If

00:39:10,359 --> 00:39:17,250
you refine type definition files in the signatures, you will have better checking. So, type profiler

00:39:17,250 --> 00:39:29,490
cannot generate types or make a distinct ‑‑ distinguish between the tuple type and the

00:39:29,490 --> 00:39:38,780
uniform. So, you can write down the Ruby signature by hand to tell a compiler that

00:39:38,780 --> 00:39:49,020
kind of information. But Ruby static type checking without any type annotation. Wouldn't

00:39:49,020 --> 00:39:53,790
that be cool?  [ Applause ]

00:39:53,790 --> 00:40:02,109
Yeah. We are working on it. And the result is promising. At least from my point of view. We

00:40:02,109 --> 00:40:11,200
cannot stop progressing. We cannot stop progressing as a community, otherwise we will die. Eventually. So,

00:40:11,200 --> 00:40:22,319
we need to survive. We have to keep moving forward. It is our destiny. Not only us,

00:40:22,319 --> 00:40:34,849
but you, too. Participation is the key. Ruby can be better. Ruby can be great. Ruby can

00:40:34,849 --> 00:40:49,500
make your life happy with your participation.  More than 20 years ago, I created the term,

00:40:49,500 --> 00:41:02,940
"Rubyist," and the definition of Rubyist is a person who is more than a mere user. So,

00:41:02,940 --> 00:41:13,640
you are Rubyists, because you attended the conference. And you are part of the community. You

00:41:13,640 --> 00:41:23,529
are Rubyists. I wish you all keep being Rubyists. Don't go away. 

00:41:23,529 --> 00:41:27,500
[ Laughter ] And happily ever after. Thank you. 

00:41:27,500 --> 00:41:27,750

YouTube URL: https://www.youtube.com/watch?v=2g9R7PUCEXo


