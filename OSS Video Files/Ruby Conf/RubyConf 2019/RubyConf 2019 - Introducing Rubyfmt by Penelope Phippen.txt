Title: RubyConf 2019 - Introducing Rubyfmt by Penelope Phippen
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Introducing Rubyfmt by Penelope Phippen

Go has gofmt, Rust: rustfmt, elixir: mix format, so what about Ruby? One response is Rubocop! A sometimes beloved, sometimes maligned formatting and linting tool. A design principle of Rubocop is configurability. So, what if we had a code formatter without configuration options?


In this talk, you’ll learn about my goals for Rubyfmt, my upcoming Ruby formatter. You’ll also get a guided tour through Ruby’s parser, and learn about why I’m rewriting the parser in Rust! This talk will get technical, and you should come if you want to learn more about Ruby’s parser and internals.

#rubyconf2019 #confreaks
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:13,139 --> 00:00:25,830
I think you all saw me this morning hi

00:00:16,770 --> 00:00:30,779
how's everyone doing I'm so happy to be

00:00:25,830 --> 00:00:33,540
here this is the first time I'm giving a

00:00:30,779 --> 00:00:37,890
talk as a director ruby central and

00:00:33,540 --> 00:00:41,850
we'll get into that but have a few

00:00:37,890 --> 00:00:46,789
personal updates to talk about before we

00:00:41,850 --> 00:00:53,789
get too far into it this is gonna get

00:00:46,789 --> 00:00:58,769
real emotional I I'm so happy to be here

00:00:53,789 --> 00:01:01,949
so just to introduce myself my name is

00:00:58,769 --> 00:01:06,570
Penelope my pronouns are she and her I'm

00:01:01,949 --> 00:01:09,480
trans and I'm a woman and I really

00:01:06,570 --> 00:01:12,540
couldn't have done this without the Ruby

00:01:09,480 --> 00:01:18,930
community I've been coming to these

00:01:12,540 --> 00:01:22,619
conferences since 2013 I owe my career

00:01:18,930 --> 00:01:25,590
many of my best friendships and so much

00:01:22,619 --> 00:01:30,360
of my life to the folks in this room and

00:01:25,590 --> 00:01:32,189
beyond and I'm just I'm so proud to be

00:01:30,360 --> 00:01:35,630
able to stand here in front of you today

00:01:32,189 --> 00:01:35,630
and say this

00:01:52,149 --> 00:01:57,500
thank you

00:01:54,229 --> 00:01:59,899
as I mentioned I'm also director to be

00:01:57,500 --> 00:02:01,850
central now I will be helping organize

00:01:59,899 --> 00:02:05,060
this conference and all of the

00:02:01,850 --> 00:02:08,239
conference's going forward I will be the

00:02:05,060 --> 00:02:11,090
program chair for railsconf so please

00:02:08,239 --> 00:02:15,890
submit a talk to railsconf we'd love to

00:02:11,090 --> 00:02:20,209
have you I'm no longer an aspic

00:02:15,890 --> 00:02:22,670
maintainer I officially retired from

00:02:20,209 --> 00:02:24,709
doing that we're taking on these

00:02:22,670 --> 00:02:26,950
additional responsibilities it just

00:02:24,709 --> 00:02:31,010
wasn't something I was able to keep

00:02:26,950 --> 00:02:33,349
doing and I want to say thank you to

00:02:31,010 --> 00:02:33,890
John Rowe who takes over now as the lead

00:02:33,349 --> 00:02:37,040
maintainer

00:02:33,890 --> 00:02:39,500
of our spec and Myron Marston Andy

00:02:37,040 --> 00:02:43,069
Linderman and David Chiu linskey who

00:02:39,500 --> 00:02:45,590
really took the time to teach me how to

00:02:43,069 --> 00:02:47,630
work on the framework and really

00:02:45,590 --> 00:02:51,760
actually helped me become the ruby

00:02:47,630 --> 00:02:51,760
developer I am today

00:02:54,280 --> 00:03:00,109
so Ruby format is going to be my open

00:02:58,370 --> 00:03:02,329
source focus for the next well and

00:03:00,109 --> 00:03:08,329
that's the purpose of this talk so let's

00:03:02,329 --> 00:03:09,739
get into it what is Ruby format well for

00:03:08,329 --> 00:03:11,569
the last couple of years I've been

00:03:09,739 --> 00:03:14,840
programming not just in Ruby but also

00:03:11,569 --> 00:03:16,400
I've been doing a lot of go and if

00:03:14,840 --> 00:03:19,549
you've all worked and go you've probably

00:03:16,400 --> 00:03:21,500
encountered the go format tool what go

00:03:19,549 --> 00:03:24,620
format does is it allows you to sort of

00:03:21,500 --> 00:03:27,079
make any change you want to a file and

00:03:24,620 --> 00:03:29,269
as the like formatting you can mess it

00:03:27,079 --> 00:03:31,790
up in any way that you want basically

00:03:29,269 --> 00:03:34,130
and just save the file and when you do

00:03:31,790 --> 00:03:35,750
so the code will just snap into place so

00:03:34,130 --> 00:03:38,709
here I have some like garbage

00:03:35,750 --> 00:03:41,920
indentation I save the file and fix a

00:03:38,709 --> 00:03:45,980
syntax error and I think all the code

00:03:41,920 --> 00:03:47,150
just eventually will snap in yeah you

00:03:45,980 --> 00:03:49,130
can see it sort of fixes the indentation

00:03:47,150 --> 00:03:52,099
automatically but also what's really

00:03:49,130 --> 00:03:54,799
important is this happens super super

00:03:52,099 --> 00:03:56,840
quickly the file that I was editing

00:03:54,799 --> 00:03:59,360
there was about two thousand lines of

00:03:56,840 --> 00:04:02,989
code and go format is executing in

00:03:59,360 --> 00:04:04,430
around 25 milliseconds to give you some

00:04:02,989 --> 00:04:06,469
idea your typical

00:04:04,430 --> 00:04:09,709
buta screen refreshes once every 16

00:04:06,469 --> 00:04:15,170
milliseconds so this is Bali - screen

00:04:09,709 --> 00:04:18,680
refreshes and like I can't not know this

00:04:15,170 --> 00:04:23,330
now this is to me like the existence of

00:04:18,680 --> 00:04:26,030
this tool in go it's just amazing it

00:04:23,330 --> 00:04:29,360
makes working with a code feel great and

00:04:26,030 --> 00:04:34,190
we don't have something like that in

00:04:29,360 --> 00:04:36,139
Ruby today and so I set out to build it

00:04:34,190 --> 00:04:38,900
I set out to build the equivalent sort

00:04:36,139 --> 00:04:39,949
of class of tool a very very fast code

00:04:38,900 --> 00:04:43,880
formatter

00:04:39,949 --> 00:04:46,070
in Ruby so what this basically means is

00:04:43,880 --> 00:04:49,070
that we take source code in the program

00:04:46,070 --> 00:04:52,280
runs and the output is like better

00:04:49,070 --> 00:04:56,300
formatted source code consistent and it

00:04:52,280 --> 00:04:59,120
should execute very quickly go format

00:04:56,300 --> 00:05:01,430
has no formatting related configuration

00:04:59,120 --> 00:05:03,710
options and neither will Ruby format

00:05:01,430 --> 00:05:06,320
when it's done this is just sort of help

00:05:03,710 --> 00:05:08,479
basically ensure speed of execution and

00:05:06,320 --> 00:05:10,190
consistency of style and I'm gonna talk

00:05:08,479 --> 00:05:13,520
a little bit about the philosophy behind

00:05:10,190 --> 00:05:16,449
that versus why ruber Corp has all of

00:05:13,520 --> 00:05:20,210
the configuration flags in this talk um

00:05:16,449 --> 00:05:23,300
Ruby format will behave very much like a

00:05:20,210 --> 00:05:26,060
UNIX tool it is designed to be very

00:05:23,300 --> 00:05:28,340
singular consume input from standardin

00:05:26,060 --> 00:05:30,530
or file names right to stand it out or

00:05:28,340 --> 00:05:35,389
write files in place you know very very

00:05:30,530 --> 00:05:39,229
simple behaviors it also will never be

00:05:35,389 --> 00:05:42,409
distributed as a gem and this is

00:05:39,229 --> 00:05:44,949
something that I've seen some confusion

00:05:42,409 --> 00:05:48,199
around um

00:05:44,949 --> 00:05:52,099
the tool is reliant on so many like

00:05:48,199 --> 00:05:55,039
binary and system pieces that the kind

00:05:52,099 --> 00:05:58,039
of like project level isolation that we

00:05:55,039 --> 00:06:00,560
use gems for just doesn't make sense for

00:05:58,039 --> 00:06:02,960
a tool like this there's no there's no

00:06:00,560 --> 00:06:07,009
way for me to efficiently distribute

00:06:02,960 --> 00:06:11,659
Ruby format as a gem and so that's just

00:06:07,009 --> 00:06:14,360
not going to happen in terms of

00:06:11,659 --> 00:06:17,689
development cycle if I'm at least six

00:06:14,360 --> 00:06:20,689
months away maybe more

00:06:17,689 --> 00:06:23,839
and I will sort of be tweeting updates

00:06:20,689 --> 00:06:27,649
I'm Penelope Zone on Twitter if you want

00:06:23,839 --> 00:06:30,049
to find out when it's ready so like I

00:06:27,649 --> 00:06:32,619
could I could finish here that's that's

00:06:30,049 --> 00:06:35,719
it that's my tool that's what it does

00:06:32,619 --> 00:06:41,059
but instead I'd kind of like to get into

00:06:35,719 --> 00:06:44,659
like the why am I doing this this is a

00:06:41,059 --> 00:06:48,129
really hard problem to solve and I'm

00:06:44,659 --> 00:06:50,959
going at it in possibly the hardest way

00:06:48,129 --> 00:06:53,889
and to talk about it I kind of want to

00:06:50,959 --> 00:06:57,169
talk about this idea of principle or

00:06:53,889 --> 00:06:59,300
trade-offs so like if you were to

00:06:57,169 --> 00:07:02,779
imagine you're someone whose job it is

00:06:59,300 --> 00:07:05,089
to like craft beautiful handmade pieces

00:07:02,779 --> 00:07:08,149
of furniture that can last for

00:07:05,089 --> 00:07:11,300
generations and be passed down between

00:07:08,149 --> 00:07:13,479
members of a family right like you're

00:07:11,300 --> 00:07:16,099
probably going to err on the side of

00:07:13,479 --> 00:07:17,959
being slow and building things that are

00:07:16,099 --> 00:07:19,789
incredibly sturdy and carefully

00:07:17,959 --> 00:07:22,339
thought-out and sort of have all of

00:07:19,789 --> 00:07:24,919
these properties of craft around what

00:07:22,339 --> 00:07:26,989
you're building and you may come to

00:07:24,919 --> 00:07:30,649
believe right that this is like the

00:07:26,989 --> 00:07:32,899
correct and good way to build furniture

00:07:30,649 --> 00:07:36,249
and I think all of us would love to own

00:07:32,899 --> 00:07:39,349
a craftsman piece of furniture but

00:07:36,249 --> 00:07:42,409
what's much more common is that we go to

00:07:39,349 --> 00:07:44,300
like here and we buy like very very

00:07:42,409 --> 00:07:47,329
cheap furniture right there can be

00:07:44,300 --> 00:07:50,119
assembled quickly but isn't durable at

00:07:47,329 --> 00:07:54,829
all I mean if you've ever tried to move

00:07:50,119 --> 00:07:56,599
house with IKEA furniture you know that

00:07:54,829 --> 00:07:59,599
we have the opposite properties but like

00:07:56,599 --> 00:08:01,610
it's still good right like I don't think

00:07:59,599 --> 00:08:05,509
anyone would in their right mind say

00:08:01,610 --> 00:08:07,039
that IKEA is objectively bad right and

00:08:05,509 --> 00:08:09,860
so we have a trade-off here there's like

00:08:07,039 --> 00:08:11,329
a tension between these sort of two

00:08:09,860 --> 00:08:14,629
ideas of what we want and what the

00:08:11,329 --> 00:08:16,759
purpose of the thing is for there's

00:08:14,629 --> 00:08:21,079
principles underlying the decision

00:08:16,759 --> 00:08:22,909
making to come to software right we

00:08:21,079 --> 00:08:24,860
could also sort of talk about this as a

00:08:22,909 --> 00:08:28,219
principle the idea that TDD results in

00:08:24,860 --> 00:08:30,439
better code if you would ask me what I

00:08:28,219 --> 00:08:31,520
thought about this statement three or

00:08:30,439 --> 00:08:32,990
four years ago I would

00:08:31,520 --> 00:08:36,830
told you this is absolutely true and

00:08:32,990 --> 00:08:38,300
people who don't do TDD are bad if you

00:08:36,830 --> 00:08:40,219
follow me on the internet you'll know

00:08:38,300 --> 00:08:43,339
that recently I went on a podcast where

00:08:40,219 --> 00:08:47,270
I ranted for an hour with Betsy hybl no

00:08:43,339 --> 00:08:50,510
rapping of an F D grim about why TDD is

00:08:47,270 --> 00:08:52,220
not good or at least very hard to teach

00:08:50,510 --> 00:08:58,339
and very hard to do right and can result

00:08:52,220 --> 00:09:01,610
in more damage than use and so like this

00:08:58,339 --> 00:09:03,709
is also not objectively true right this

00:09:01,610 --> 00:09:06,800
is a principal sometimes it applies

00:09:03,709 --> 00:09:08,690
sometimes it doesn't apply and what

00:09:06,800 --> 00:09:11,300
we're really talking about here is like

00:09:08,690 --> 00:09:13,070
discussion of trade-offs like what are

00:09:11,300 --> 00:09:16,240
the trade-offs that we want to accept in

00:09:13,070 --> 00:09:19,160
order to build what we're building and

00:09:16,240 --> 00:09:22,730
so when I was writing this twerk I

00:09:19,160 --> 00:09:26,079
realized that what makes ruby format

00:09:22,730 --> 00:09:29,329
different to all of the other tools that

00:09:26,079 --> 00:09:30,920
are out there not just technically but

00:09:29,329 --> 00:09:35,600
from a sort of higher level perspective

00:09:30,920 --> 00:09:40,579
is that it is born of like my very

00:09:35,600 --> 00:09:42,260
specific brand of care mad and like I've

00:09:40,579 --> 00:09:45,740
tried to boil that down into the

00:09:42,260 --> 00:09:48,800
principles that I'm using to build Ruby

00:09:45,740 --> 00:09:50,690
format and so when I was writing this

00:09:48,800 --> 00:09:52,820
talk the best that I could sort of

00:09:50,690 --> 00:09:55,430
distill them down into pithy statements

00:09:52,820 --> 00:09:58,760
that fit on a slide is do one thing well

00:09:55,430 --> 00:10:02,329
correctness beats simplicity and speed

00:09:58,760 --> 00:10:04,220
is needed at any cost and I'm going to

00:10:02,329 --> 00:10:06,589
explore what these principles mean to me

00:10:04,220 --> 00:10:08,570
in the context of some of the other fit

00:10:06,589 --> 00:10:10,490
tools that you might have seen so let's

00:10:08,570 --> 00:10:13,160
start by talking about do one thing well

00:10:10,490 --> 00:10:14,779
and to sort of frame this in context

00:10:13,160 --> 00:10:17,300
we're going to talk a little bit about

00:10:14,779 --> 00:10:21,290
ribbit carp is anyone from the rubric up

00:10:17,300 --> 00:10:23,540
team in the room know this isn't like a

00:10:21,290 --> 00:10:25,610
this isn't like I'm about to dunk on you

00:10:23,540 --> 00:10:26,350
I like in fact like look this is the

00:10:25,610 --> 00:10:31,399
next slide

00:10:26,350 --> 00:10:33,500
hey like I really like I have definitely

00:10:31,399 --> 00:10:35,420
been guilty of getting mad at rubric

00:10:33,500 --> 00:10:37,220
often saying mean things about it and I

00:10:35,420 --> 00:10:40,610
kind of want to apologize for that like

00:10:37,220 --> 00:10:43,149
it's a good tool and I think talking

00:10:40,610 --> 00:10:45,110
about a in this context of principle

00:10:43,149 --> 00:10:47,570
makes it clear why

00:10:45,110 --> 00:10:49,640
so like if you go to the river cop

00:10:47,570 --> 00:10:52,760
documentation website these are like all

00:10:49,640 --> 00:10:54,740
of the categories of cops that they have

00:10:52,760 --> 00:10:56,510
right because we were talking to a lot

00:10:54,740 --> 00:11:00,110
of stuff I could do formatting naturist

00:10:56,510 --> 00:11:03,140
linting etc and this is not really like

00:11:00,110 --> 00:11:05,990
seven rings that overlap like this this

00:11:03,140 --> 00:11:07,730
is a seven dimensional Venn diagram this

00:11:05,990 --> 00:11:10,730
this by the way is a rotationally

00:11:07,730 --> 00:11:12,350
symmetric seven dimensional Venn diagram

00:11:10,730 --> 00:11:14,180
I just wasn't gonna like put all the

00:11:12,350 --> 00:11:18,290
text in all the boxes it's too much

00:11:14,180 --> 00:11:21,170
effort um so imagine this blob not these

00:11:18,290 --> 00:11:22,730
rings but this kind of applies right so

00:11:21,170 --> 00:11:26,170
like remote cart can do all of these

00:11:22,730 --> 00:11:29,470
things and it can do them pretty well um

00:11:26,170 --> 00:11:32,570
but like Ruby format is only doing

00:11:29,470 --> 00:11:36,470
formatting we literally only care about

00:11:32,570 --> 00:11:38,450
this one specific slice and because of

00:11:36,470 --> 00:11:40,570
that I can sort of like focus really

00:11:38,450 --> 00:11:43,370
hard and sweat the details and work out

00:11:40,570 --> 00:11:45,950
exactly how to get like really really

00:11:43,370 --> 00:11:48,230
nice Ruby formatting going um

00:11:45,950 --> 00:11:54,160
River clock is infinitely configurable

00:11:48,230 --> 00:11:57,290
and that kind of what am I trying to say

00:11:54,160 --> 00:11:59,300
it kind of means that you as a team have

00:11:57,290 --> 00:12:01,550
to decide which configurations you value

00:11:59,300 --> 00:12:04,610
and to talk about that a little bit more

00:12:01,550 --> 00:12:08,240
I'm gonna do my level best to hand over

00:12:04,610 --> 00:12:12,520
to Justin via a lightning talk from LA

00:12:08,240 --> 00:12:15,230
cool uh that's not gonna work so we'll

00:12:12,520 --> 00:12:19,970
we'll skip two minutes of Justin talking

00:12:15,230 --> 00:12:23,810
and I'll have to fill in so at rubyconf

00:12:19,970 --> 00:12:28,940
in LA justin announced a tool called

00:12:23,810 --> 00:12:31,760
standard standard is a rubric up with a

00:12:28,940 --> 00:12:34,280
like pre baked configuration that sort

00:12:31,760 --> 00:12:36,740
of represents what justin and the folks

00:12:34,280 --> 00:12:39,080
over at testable believe is sort of like

00:12:36,740 --> 00:12:42,770
a good out of the box configuration for

00:12:39,080 --> 00:12:46,430
most ruby teams justin's can see is

00:12:42,770 --> 00:12:48,170
roughly that for most teams having this

00:12:46,430 --> 00:12:50,270
sort of like discussion about which

00:12:48,170 --> 00:12:53,690
pieces of rubric or configuration do and

00:12:50,270 --> 00:12:55,700
don't make sense for them consumes more

00:12:53,690 --> 00:12:57,860
time than it is valuable and so he's

00:12:55,700 --> 00:12:58,579
trying to have like the meta yak shave

00:12:57,860 --> 00:13:01,790
one

00:12:58,579 --> 00:13:04,489
last time and then just like be

00:13:01,790 --> 00:13:06,139
configured forever um I was going to cut

00:13:04,489 --> 00:13:09,499
in half way through Justin's talk and

00:13:06,139 --> 00:13:12,170
ask the question how many folks in this

00:13:09,499 --> 00:13:14,509
room use Rubick Rubick up and have a

00:13:12,170 --> 00:13:16,309
significantly different configuration

00:13:14,509 --> 00:13:21,160
from the River Club out of the box

00:13:16,309 --> 00:13:24,259
defaults yeah that's like most of you

00:13:21,160 --> 00:13:28,339
this is so this is so unsurprising to me

00:13:24,259 --> 00:13:30,529
I think everyone finds at least one

00:13:28,339 --> 00:13:33,319
thing if not many in the rubric of

00:13:30,529 --> 00:13:37,579
defaults they don't like and this is

00:13:33,319 --> 00:13:40,189
like part of what I am driving with the

00:13:37,579 --> 00:13:42,079
effort in Ruby format is to try and come

00:13:40,189 --> 00:13:45,249
up with a sort of like formatting

00:13:42,079 --> 00:13:48,589
solution that is palatable to everyone

00:13:45,249 --> 00:13:52,040
even if it's not everyone's favorite I

00:13:48,589 --> 00:13:54,019
was gonna play a bunch more of Justin

00:13:52,040 --> 00:13:56,540
but we don't have a audio through the

00:13:54,019 --> 00:13:58,790
laptop so I'll just summarize it by

00:13:56,540 --> 00:14:01,309
saying it finished with Aaron wearing

00:13:58,790 --> 00:14:04,970
his burger hat and describing standard

00:14:01,309 --> 00:14:06,529
as rubric hope the good parts haha Aaron

00:14:04,970 --> 00:14:08,749
is wearing the same burger hat which I

00:14:06,529 --> 00:14:16,129
assume is an endorsement that's a ruby

00:14:08,749 --> 00:14:19,249
format is a good tool so ruby format

00:14:16,129 --> 00:14:20,269
like literally is a different clot the

00:14:19,249 --> 00:14:21,649
point I'm trying to make here is that

00:14:20,269 --> 00:14:23,899
Ruby format is literally a different

00:14:21,649 --> 00:14:26,269
class of tool it is designed to do

00:14:23,899 --> 00:14:28,879
something entirely different if you go

00:14:26,269 --> 00:14:31,790
to the rubric op page that's just like a

00:14:28,879 --> 00:14:34,459
list of all of these configuration

00:14:31,790 --> 00:14:37,579
options and the sort of conceit of this

00:14:34,459 --> 00:14:41,600
doing one thing well idea is that the

00:14:37,579 --> 00:14:43,879
rubric op team has to support an every

00:14:41,600 --> 00:14:48,139
and any possible combination of those

00:14:43,879 --> 00:14:49,939
and produce something useful and that's

00:14:48,139 --> 00:14:53,119
really hard like once you have

00:14:49,939 --> 00:14:55,249
customizable software and like code

00:14:53,119 --> 00:14:56,540
format like that just becomes infinitely

00:14:55,249 --> 00:15:00,829
hard to build something that people can

00:14:56,540 --> 00:15:03,230
appreciate so when I talk about doing

00:15:00,829 --> 00:15:06,709
one thing well what I really mean is

00:15:03,230 --> 00:15:09,049
that like configuration implies doing

00:15:06,709 --> 00:15:10,879
multiple things right if you have

00:15:09,049 --> 00:15:12,410
different formatting options

00:15:10,879 --> 00:15:14,480
you no longer really have a singular

00:15:12,410 --> 00:15:16,699
auto for matter you have a category of

00:15:14,480 --> 00:15:19,220
Auto for matters you can compose

00:15:16,699 --> 00:15:20,839
together and like you have to support

00:15:19,220 --> 00:15:22,850
every possible combination of them which

00:15:20,839 --> 00:15:25,129
I have no interest in doing this is a

00:15:22,850 --> 00:15:29,360
hard enough problem to solve on its own

00:15:25,129 --> 00:15:32,600
so ruby format supports one consistent

00:15:29,360 --> 00:15:34,790
style you will not be able to change it

00:15:32,600 --> 00:15:37,189
but I'm going to try and make it so that

00:15:34,790 --> 00:15:39,019
everyone kind of likes it - giving you

00:15:37,189 --> 00:15:39,670
just like one example of what this looks

00:15:39,019 --> 00:15:41,689
like

00:15:39,670 --> 00:15:43,579
imagine you have this piece of Ruby

00:15:41,689 --> 00:15:46,129
right and I very deliberately not

00:15:43,579 --> 00:15:48,350
indented it here in this example just so

00:15:46,129 --> 00:15:50,269
you can take in what we're doing we have

00:15:48,350 --> 00:15:51,800
an if state have an if statement we

00:15:50,269 --> 00:15:54,620
assign the result into a local variable

00:15:51,800 --> 00:15:55,790
the two arms call a method there are a

00:15:54,620 --> 00:15:58,399
couple of ways you could indent this

00:15:55,790 --> 00:16:00,649
right you can indent it like this or you

00:15:58,399 --> 00:16:03,069
can indent it like this there are others

00:16:00,649 --> 00:16:05,720
but these are like two alternatives and

00:16:03,069 --> 00:16:07,699
the same thing is true with like string

00:16:05,720 --> 00:16:08,990
literals where you're broken over

00:16:07,699 --> 00:16:10,730
multiple lines right

00:16:08,990 --> 00:16:15,949
most people would either indent it like

00:16:10,730 --> 00:16:17,899
this or like this and so like what's the

00:16:15,949 --> 00:16:20,899
answer right if you're building one

00:16:17,899 --> 00:16:25,579
singular Ruby Auto formatting style what

00:16:20,899 --> 00:16:28,189
do you do well where we ended up is that

00:16:25,579 --> 00:16:30,649
Ruby format will always indent two to

00:16:28,189 --> 00:16:34,160
the relative parent and as a reason for

00:16:30,649 --> 00:16:37,790
this we had to build special case logic

00:16:34,160 --> 00:16:40,069
to find where to anchor to if we didn't

00:16:37,790 --> 00:16:43,040
do this it literally makes the auto

00:16:40,069 --> 00:16:45,019
formatter simpler to not push things all

00:16:43,040 --> 00:16:47,480
the way in and so Ruby format will

00:16:45,019 --> 00:16:49,759
prefer this and this over the other

00:16:47,480 --> 00:16:52,519
style that I showed is possible right

00:16:49,759 --> 00:16:53,990
and like again this is a trade-off but

00:16:52,519 --> 00:16:57,110
when we think about doing one thing well

00:16:53,990 --> 00:16:59,809
it's sweating these kind of tiny tiny

00:16:57,110 --> 00:17:02,930
details that's so important to me like

00:16:59,809 --> 00:17:07,520
I'm probably the angriest person in this

00:17:02,930 --> 00:17:10,760
room about Ruby formatting believe me

00:17:07,520 --> 00:17:12,890
and like I've spending so much time just

00:17:10,760 --> 00:17:15,380
thinking about what does it actually

00:17:12,890 --> 00:17:18,549
mean and what does good Ruby look like

00:17:15,380 --> 00:17:20,480
so that's that's doing one thing well

00:17:18,549 --> 00:17:24,740
the next principle i want to talk about

00:17:20,480 --> 00:17:25,429
is correctness beating simplicity and to

00:17:24,740 --> 00:17:25,850
talk about it

00:17:25,429 --> 00:17:27,589
i

00:17:25,850 --> 00:17:31,070
ask you the question like how do you

00:17:27,589 --> 00:17:33,140
pause Ruby how do you take a like file

00:17:31,070 --> 00:17:35,150
of Ruby source code and build a data

00:17:33,140 --> 00:17:37,370
structure that lets you understand what

00:17:35,150 --> 00:17:39,830
the structure of the program is well if

00:17:37,370 --> 00:17:43,280
you google this literally the first

00:17:39,830 --> 00:17:45,770
result is this gem called Pazza which

00:17:43,280 --> 00:17:49,220
like seems like an excellent result

00:17:45,770 --> 00:17:52,760
right and this is this is the white

00:17:49,220 --> 00:17:56,539
quark parser this plaza or a variant of

00:17:52,760 --> 00:17:59,419
it is used by rubric op and github for

00:17:56,539 --> 00:18:01,130
their Ruby syntax highlighting and the

00:17:59,419 --> 00:18:05,720
sorbet team reimplemented a

00:18:01,130 --> 00:18:07,159
reimplementation of this in c++ the

00:18:05,720 --> 00:18:13,309
person from the survey team at the front

00:18:07,159 --> 00:18:17,740
of the room is laughing and here's the

00:18:13,309 --> 00:18:20,650
thing the output of this Pazza is great

00:18:17,740 --> 00:18:24,500
it's really really easy to deal with

00:18:20,650 --> 00:18:27,799
it's super cool so like say you have a

00:18:24,500 --> 00:18:30,080
program where you like just have a

00:18:27,799 --> 00:18:32,090
function call with no arguments the

00:18:30,080 --> 00:18:33,650
output looks like this thank you so pay

00:18:32,090 --> 00:18:35,750
team for making it easy to call your

00:18:33,650 --> 00:18:39,020
paws are from the command line

00:18:35,750 --> 00:18:41,240
and if you add parentheses with a single

00:18:39,020 --> 00:18:43,400
argument like the thing that changes is

00:18:41,240 --> 00:18:47,210
the odds node and you get an integer

00:18:43,400 --> 00:18:49,400
with a value equal to one in it so then

00:18:47,210 --> 00:18:51,470
you go and read the documentation for

00:18:49,400 --> 00:18:53,900
the white quark parser and there's this

00:18:51,470 --> 00:18:56,270
whole section entitled compatibility

00:18:53,900 --> 00:18:57,650
with MRI I was reading this and I was

00:18:56,270 --> 00:19:01,270
reading this and I was like okay okay

00:18:57,650 --> 00:19:04,669
okay and then they have this section

00:19:01,270 --> 00:19:06,950
basically it's impossible to build a

00:19:04,669 --> 00:19:09,140
ruby Pazza that's completely compatible

00:19:06,950 --> 00:19:11,330
with the one that ships with MRI because

00:19:09,140 --> 00:19:13,970
they change it all the time and so like

00:19:11,330 --> 00:19:17,360
the folks who build this tool just don't

00:19:13,970 --> 00:19:19,789
even try that they're doing a good job

00:19:17,360 --> 00:19:21,980
but they like literally state it is

00:19:19,789 --> 00:19:24,740
impossible that this will be completely

00:19:21,980 --> 00:19:26,750
correct for all ruby programs and that's

00:19:24,740 --> 00:19:30,710
fair it would be very hard for them to

00:19:26,750 --> 00:19:34,549
do that unlike for 99% of Ruby programs

00:19:30,710 --> 00:19:36,830
this will never ever be a problem like

00:19:34,549 --> 00:19:39,360
the white core parser is good enough to

00:19:36,830 --> 00:19:42,780
deal with almost all of the

00:19:39,360 --> 00:19:47,220
code you will ever write but it's that

00:19:42,780 --> 00:19:48,780
almost that really gets me because the

00:19:47,220 --> 00:19:50,850
thing is if I'm building a rotary

00:19:48,780 --> 00:19:54,059
formatter a program that consumes your

00:19:50,850 --> 00:19:58,110
code changes it and spits a new code

00:19:54,059 --> 00:19:59,750
back out if the pawza I'm using isn't a

00:19:58,110 --> 00:20:03,720
ruby Pazza

00:19:59,750 --> 00:20:05,400
there is a nonzero probability I could

00:20:03,720 --> 00:20:10,380
meaningfully change the behavior of your

00:20:05,400 --> 00:20:11,940
program and I know because like the

00:20:10,380 --> 00:20:14,340
worst results of that could be like I

00:20:11,940 --> 00:20:20,610
drop your database or something and like

00:20:14,340 --> 00:20:24,000
I don't I don't know so the other way

00:20:20,610 --> 00:20:27,929
that you can pause Ruby is with a tool

00:20:24,000 --> 00:20:31,169
called Ripper Ripper is a piece of the

00:20:27,929 --> 00:20:34,460
Ruby standard library which compiles the

00:20:31,169 --> 00:20:38,250
pawza built into the Ruby implementation

00:20:34,460 --> 00:20:41,880
as a like alternate library available to

00:20:38,250 --> 00:20:43,799
Ruby the C and that seems great right

00:20:41,880 --> 00:20:45,450
like it's the actual Ruby Pazza

00:20:43,799 --> 00:20:48,750
and it's in the standard library I don't

00:20:45,450 --> 00:20:50,280
even need a gem of course there's no

00:20:48,750 --> 00:20:52,890
such thing as a free lunch in software

00:20:50,280 --> 00:20:56,250
there are some very distinct

00:20:52,890 --> 00:20:57,990
disadvantages to doing this so one of

00:20:56,250 --> 00:21:00,750
them is that you have to boot a Ruby

00:20:57,990 --> 00:21:04,110
interpreter I know that we're sort of

00:21:00,750 --> 00:21:06,660
talking about a very small amount of

00:21:04,110 --> 00:21:09,360
time here but I'll show you later why

00:21:06,660 --> 00:21:10,950
that's a problem with the the tool there

00:21:09,360 --> 00:21:13,370
sorbet folks wrote they can pause

00:21:10,950 --> 00:21:15,929
millions of lines of code in seconds

00:21:13,370 --> 00:21:18,840
can't do that with Ruby it's just not

00:21:15,929 --> 00:21:23,700
possible um running ruby is slower than

00:21:18,840 --> 00:21:26,390
not running Ruby unfortunately but like

00:21:23,700 --> 00:21:29,700
speed alone is something we can solve

00:21:26,390 --> 00:21:32,370
the problem is that rippers output is

00:21:29,700 --> 00:21:34,230
nowhere near as nice as the output of a

00:21:32,370 --> 00:21:36,480
white court parser to work with and I'll

00:21:34,230 --> 00:21:40,919
show you an example so if we take that

00:21:36,480 --> 00:21:43,320
same program this is the output for just

00:21:40,919 --> 00:21:44,850
a zero argument method call you have a V

00:21:43,320 --> 00:21:46,140
call okay that's our function call type

00:21:44,850 --> 00:21:48,390
we have ident

00:21:46,140 --> 00:21:50,010
that seems fine but if we change it back

00:21:48,390 --> 00:21:52,070
to that program where we pass an

00:21:50,010 --> 00:21:52,070
argument

00:21:52,639 --> 00:21:58,470
everything changes it changes from V

00:21:56,009 --> 00:22:00,120
Cole to method ad argh that's Cole type

00:21:58,470 --> 00:22:02,639
actually changes from vehicle to F Cole

00:22:00,120 --> 00:22:04,710
does this odd / n thing then augs

00:22:02,639 --> 00:22:07,950
like there's so much extra stuff here

00:22:04,710 --> 00:22:10,679
and this happens everywhere in Ripper

00:22:07,950 --> 00:22:12,179
anytime you change like a small thing it

00:22:10,679 --> 00:22:14,970
sends you down a completely different

00:22:12,179 --> 00:22:18,059
path tree path and there is a good

00:22:14,970 --> 00:22:20,429
reason for this like due to how ruby is

00:22:18,059 --> 00:22:24,990
implemented but I don't have time to get

00:22:20,429 --> 00:22:28,369
into that now so we have an accurate

00:22:24,990 --> 00:22:30,929
passer but its output is kind of painful

00:22:28,369 --> 00:22:33,539
ruby format uses Ripper to ensure

00:22:30,929 --> 00:22:36,899
compatibility with whatever program

00:22:33,539 --> 00:22:40,559
you're building and honestly this is

00:22:36,899 --> 00:22:43,019
where all of the time in building ruby

00:22:40,559 --> 00:22:47,399
format is going is working out how to

00:22:43,019 --> 00:22:48,299
deal with Ripper correctly if I had used

00:22:47,399 --> 00:22:50,519
the white quark Pazza

00:22:48,299 --> 00:22:54,720
I would be done like we would have a

00:22:50,519 --> 00:22:56,669
Ruby also formatter but also it wouldn't

00:22:54,720 --> 00:23:01,440
be completely and totally correct and I

00:22:56,669 --> 00:23:03,869
would be sad I have this weird plan to

00:23:01,440 --> 00:23:05,970
like extract Ripper fraught like from

00:23:03,869 --> 00:23:08,340
being directly coupled to the Ruby

00:23:05,970 --> 00:23:10,080
interpreter eventually but I'm also not

00:23:08,340 --> 00:23:14,460
gonna get into that now that could be

00:23:10,080 --> 00:23:16,889
another complete 45-minute talk um so

00:23:14,460 --> 00:23:20,369
here's what I'm saying I'm very glad

00:23:16,889 --> 00:23:22,830
that sorbet and rubric op exist and are

00:23:20,369 --> 00:23:25,919
done and are shipped and did not use

00:23:22,830 --> 00:23:27,659
refer to build this because they

00:23:25,919 --> 00:23:31,619
probably would have still be building

00:23:27,659 --> 00:23:33,749
that pauses out but I just can't for

00:23:31,619 --> 00:23:36,480
Ruby format it needs to be correct and

00:23:33,749 --> 00:23:39,240
this is how we achieve that form of

00:23:36,480 --> 00:23:41,460
correctness this is a lot of extra

00:23:39,240 --> 00:23:43,499
effort but I think it's worth it to get

00:23:41,460 --> 00:23:47,159
a really really precise and well

00:23:43,499 --> 00:23:49,230
implemented tool and now we got to kind

00:23:47,159 --> 00:23:50,759
of talk about my favorite speed is

00:23:49,230 --> 00:23:53,460
needed at any cost

00:23:50,759 --> 00:23:56,190
so like earlier we saw that go format

00:23:53,460 --> 00:23:59,490
executed in 25 milliseconds even on like

00:23:56,190 --> 00:24:01,500
very large files and the question then

00:23:59,490 --> 00:24:04,529
becomes like how does that compare with

00:24:01,500 --> 00:24:06,509
Ruby to give you some idea of what's

00:24:04,529 --> 00:24:09,479
saving in 25 milliseconds

00:24:06,509 --> 00:24:12,059
looks like this is currently frozen but

00:24:09,479 --> 00:24:14,369
if I play the video can you even notice

00:24:12,059 --> 00:24:15,959
the 25 millisecond delay that I put in

00:24:14,369 --> 00:24:17,669
there when I'm saving the file like

00:24:15,959 --> 00:24:20,820
there is a 25 millisecond pool is

00:24:17,669 --> 00:24:23,459
happening there no one can see it so the

00:24:20,820 --> 00:24:27,239
question really for a tool like this is

00:24:23,459 --> 00:24:28,919
how fast is fast enough and this then

00:24:27,239 --> 00:24:33,029
becomes a discussion of like execution

00:24:28,919 --> 00:24:35,879
speed well basically the fastest any

00:24:33,029 --> 00:24:38,579
program can meaningfully execute in this

00:24:35,879 --> 00:24:40,349
context is 16 milliseconds the display

00:24:38,579 --> 00:24:43,259
on your laptop is refreshing 60 times a

00:24:40,349 --> 00:24:44,429
second that's a 16 millisecond delay if

00:24:43,259 --> 00:24:46,799
I can be faster than that

00:24:44,429 --> 00:24:50,239
I'm done but even like 2 or 3 screen

00:24:46,799 --> 00:24:52,829
refreshes almost zero humans can notice

00:24:50,239 --> 00:24:54,779
most of the interactivity design

00:24:52,829 --> 00:24:57,779
research says that if you take longer

00:24:54,779 --> 00:25:00,869
than a hundred milliseconds most people

00:24:57,779 --> 00:25:02,579
will be able to notice and that can be

00:25:00,869 --> 00:25:05,489
really painful and break people's

00:25:02,579 --> 00:25:07,469
workflows especially them users in the

00:25:05,489 --> 00:25:10,349
room most of you are doing your

00:25:07,469 --> 00:25:11,579
interactions after save unless 100

00:25:10,349 --> 00:25:16,440
milliseconds because you're not actually

00:25:11,579 --> 00:25:18,809
watching what the screen does so my

00:25:16,440 --> 00:25:21,329
current goal is to get ruby format to be

00:25:18,809 --> 00:25:23,969
able to execute in less than 100

00:25:21,329 --> 00:25:26,339
milliseconds on a 3,000 line Ruby file

00:25:23,969 --> 00:25:29,789
this when I went through the source code

00:25:26,339 --> 00:25:32,129
of rails and r-spec this seemed to be

00:25:29,789 --> 00:25:35,339
about the largest files that were there

00:25:32,129 --> 00:25:37,499
I know in your apps some of you have

00:25:35,339 --> 00:25:43,379
files called user dot RB that are bigger

00:25:37,499 --> 00:25:45,059
than that but like this we have to set

00:25:43,379 --> 00:25:48,149
the limit somewhere um

00:25:45,059 --> 00:25:52,229
so the absolute fastest you can do

00:25:48,149 --> 00:25:56,449
anything with Ruby is this command Ruby

00:25:52,229 --> 00:25:59,249
- - disable equal gems a empty string so

00:25:56,449 --> 00:26:01,319
by default when you start up Ruby it

00:25:59,249 --> 00:26:04,169
will load a bunch of Ruby gems related

00:26:01,319 --> 00:26:06,749
information passing this disabled gems

00:26:04,169 --> 00:26:09,329
flag tells it not to do that and then e

00:26:06,749 --> 00:26:14,369
empty string is just saying evaluate no

00:26:09,329 --> 00:26:16,679
code on my latest edition 13-inch

00:26:14,369 --> 00:26:18,539
MacBook that command takes 25

00:26:16,679 --> 00:26:19,860
milliseconds to execute or about two

00:26:18,539 --> 00:26:24,300
screen refreshes

00:26:19,860 --> 00:26:28,410
if you turn jams on so just really

00:26:24,300 --> 00:26:32,220
evaluate empty string with no code it

00:26:28,410 --> 00:26:36,630
takes about 75 milliseconds and so this

00:26:32,220 --> 00:26:39,930
is telling me basically that like we

00:26:36,630 --> 00:26:41,910
can't run the pawza and format a 3,000

00:26:39,930 --> 00:26:47,070
line file in 25 milliseconds there's

00:26:41,910 --> 00:26:49,560
just no way so ruby format can't use

00:26:47,070 --> 00:26:51,570
gems like you just have this fundamental

00:26:49,560 --> 00:26:56,250
restriction where to build this program

00:26:51,570 --> 00:26:57,930
we cannot use ruby gems again speed is

00:26:56,250 --> 00:27:01,320
needed at any cost because this is in

00:26:57,930 --> 00:27:04,670
people's interactivity loops I want to

00:27:01,320 --> 00:27:06,720
show you one more time scale this is 800

00:27:04,670 --> 00:27:08,400
milliseconds and the boxes here

00:27:06,720 --> 00:27:12,870
represent the same time units as the

00:27:08,400 --> 00:27:15,990
colors they did previously would anyone

00:27:12,870 --> 00:27:22,740
like to hazard a guess what doing bundle

00:27:15,990 --> 00:27:26,970
exec any command tape takes so if you

00:27:22,740 --> 00:27:31,830
measure this just booting bundle exec

00:27:26,970 --> 00:27:36,090
Ruby empty string takes 425 milliseconds

00:27:31,830 --> 00:27:39,020
so that's four times are like time

00:27:36,090 --> 00:27:42,750
budget already so we absolutely

00:27:39,020 --> 00:27:45,450
definitely can't use bundler and just to

00:27:42,750 --> 00:27:47,640
sort of show you what this looks like

00:27:45,450 --> 00:27:50,040
this was actually taken by measuring

00:27:47,640 --> 00:27:53,100
against bundle exec for uber cop on a

00:27:50,040 --> 00:27:55,830
four line file I like wanted to just see

00:27:53,100 --> 00:27:57,330
like is there anything we could do where

00:27:55,830 --> 00:27:59,700
we can sort of like inherit from rubric

00:27:57,330 --> 00:28:04,500
or pull rubric open as a jam or extract

00:27:59,700 --> 00:28:06,840
parts of it and the answer is just no um

00:28:04,500 --> 00:28:08,580
while River co-op has a bunch of cool

00:28:06,840 --> 00:28:11,820
internal libraries for dealing with Ruby

00:28:08,580 --> 00:28:14,490
source code I just can't imagine a way

00:28:11,820 --> 00:28:16,980
in which that would ever be fast enough

00:28:14,490 --> 00:28:18,330
and this is not supposed to be like a

00:28:16,980 --> 00:28:20,250
dunk on rubric op

00:28:18,330 --> 00:28:24,660
rubric OP is designed to be a completely

00:28:20,250 --> 00:28:27,750
different class of tool so the question

00:28:24,660 --> 00:28:29,010
is like where am i today like right I've

00:28:27,750 --> 00:28:32,370
just been talking to you for a while

00:28:29,010 --> 00:28:33,179
about why I am building this and how I'm

00:28:32,370 --> 00:28:36,690
building it

00:28:33,179 --> 00:28:39,389
so we actually completed an

00:28:36,690 --> 00:28:42,719
implementation of Ruby format entirely

00:28:39,389 --> 00:28:45,749
in Ruby that can read in a file generate

00:28:42,719 --> 00:28:48,059
a Ruby pause tree generate an internal

00:28:45,749 --> 00:28:50,519
sort of like cue like representation and

00:28:48,059 --> 00:28:53,789
then serialize it back out to a source

00:28:50,519 --> 00:28:55,759
code file and like I was so happy on

00:28:53,789 --> 00:28:59,729
that day like there is something like

00:28:55,759 --> 00:29:02,249
200 files in the Ruby format repo which

00:28:59,729 --> 00:29:05,039
are all just like weird arcane Ruby

00:29:02,249 --> 00:29:07,529
syntax to make sure we are compatible

00:29:05,039 --> 00:29:10,619
with everything one of them I actually

00:29:07,529 --> 00:29:13,999
sent a bug report to the stripe folks

00:29:10,619 --> 00:29:18,389
because it broke the sorbet Pazza

00:29:13,999 --> 00:29:21,029
recursive here Doc's are a thing there's

00:29:18,389 --> 00:29:24,109
like three people in this room who get

00:29:21,029 --> 00:29:28,080
that joke and they know why I'm sad now

00:29:24,109 --> 00:29:29,999
so here's where we're at today this file

00:29:28,080 --> 00:29:32,029
is 186 lines the pure Ruby

00:29:29,999 --> 00:29:36,019
implementation takes about 106

00:29:32,029 --> 00:29:38,820
milliseconds to execute on a larger file

00:29:36,019 --> 00:29:44,909
187 and on that sort of like 2,000 line

00:29:38,820 --> 00:29:47,549
file 415 we're too slow Ruby format the

00:29:44,909 --> 00:29:50,609
Ruby the pure Ruby version just is not

00:29:47,549 --> 00:29:52,619
fast enough I am through profilers that

00:29:50,609 --> 00:29:56,489
they say that every optimization I could

00:29:52,619 --> 00:29:58,849
think of I did GC tuning this just

00:29:56,489 --> 00:30:03,119
wasn't gonna happen

00:29:58,849 --> 00:30:06,269
unfortunately the Ruby's we have today

00:30:03,119 --> 00:30:08,279
on not fast enough to build a ruby for

00:30:06,269 --> 00:30:09,960
matter which is kind of sad I really

00:30:08,279 --> 00:30:11,399
wanted to be able to say I built a pure

00:30:09,960 --> 00:30:16,080
Ruby Ruby formatter

00:30:11,399 --> 00:30:18,599
that would've been super cool um so what

00:30:16,080 --> 00:30:20,639
do we do well when you want to go really

00:30:18,599 --> 00:30:22,139
fast these days there's really one

00:30:20,639 --> 00:30:26,309
language that everyone's talking about

00:30:22,139 --> 00:30:31,099
it's rust and so I started rewriting

00:30:26,309 --> 00:30:34,139
pieces of the Ruby format in rust oh

00:30:31,099 --> 00:30:35,999
yeah I talked a little bit about Ripper

00:30:34,139 --> 00:30:38,309
which is the library built on top of a

00:30:35,999 --> 00:30:41,609
file within Ruby called paws don't why

00:30:38,309 --> 00:30:46,530
pause dot why is written in a language

00:30:41,609 --> 00:30:49,650
called yak and is the tool that Ruby

00:30:46,530 --> 00:30:52,740
users to generate its own parser the

00:30:49,650 --> 00:30:56,130
problem is that the yak code in positive

00:30:52,740 --> 00:30:58,620
way can't really be separated from the

00:30:56,130 --> 00:31:01,530
Ruby interpreter there's no easy

00:30:58,620 --> 00:31:04,290
mechanism for us to just invoke the

00:31:01,530 --> 00:31:06,120
parser from a rust program if I could

00:31:04,290 --> 00:31:09,750
just write all of this in pure rust I

00:31:06,120 --> 00:31:14,400
would be like very done but that's also

00:31:09,750 --> 00:31:18,270
not possible so Ruby and rust working

00:31:14,400 --> 00:31:21,690
together in perfect harmony what I have

00:31:18,270 --> 00:31:24,720
today is a ruby program which reads your

00:31:21,690 --> 00:31:27,180
source code generates a par 3 and then

00:31:24,720 --> 00:31:32,790
converts it to JSON this by the way is

00:31:27,180 --> 00:31:36,300
the official logo of JSON that JSON tree

00:31:32,790 --> 00:31:39,020
is then sent into a rust program which

00:31:36,300 --> 00:31:41,760
is generated as a ruby native extension

00:31:39,020 --> 00:31:43,890
the rust program then converts that JSON

00:31:41,760 --> 00:31:45,450
into a parse tree generates that

00:31:43,890 --> 00:31:50,940
intermediate representation and

00:31:45,450 --> 00:31:52,290
serializes out the file it's so fast oh

00:31:50,940 --> 00:31:56,820
my god

00:31:52,290 --> 00:31:58,800
I'm the basic difference is that the

00:31:56,820 --> 00:32:02,280
rust program has a completely typesafe

00:31:58,800 --> 00:32:04,800
specification of the Ruby parse tree and

00:32:02,280 --> 00:32:06,540
so it's able to do like static and not

00:32:04,800 --> 00:32:10,170
dynamic dispatch to do all the

00:32:06,540 --> 00:32:12,540
formatting it's really really fast the

00:32:10,170 --> 00:32:14,190
initial the initial test suggests this

00:32:12,540 --> 00:32:20,480
will be able to blow through the 3,000

00:32:14,190 --> 00:32:24,510
line files no problem I my life now is

00:32:20,480 --> 00:32:25,920
building tooling in rust to work with

00:32:24,510 --> 00:32:29,670
Ruby source code

00:32:25,920 --> 00:32:33,840
I have intent once I'm done with this

00:32:29,670 --> 00:32:37,800
sort of first pass to begin pulling the

00:32:33,840 --> 00:32:39,750
pawza entirely into rust i don't know

00:32:37,800 --> 00:32:41,280
how achievable that is on any kind of

00:32:39,750 --> 00:32:46,050
reasonable time scale and it's why I'm

00:32:41,280 --> 00:32:52,080
doing it last and not first um so let's

00:32:46,050 --> 00:32:56,790
summarize when I'm building many pieces

00:32:52,080 --> 00:32:58,290
of software I tend to hold some of these

00:32:56,790 --> 00:33:00,270
principles in my head but in particular

00:32:58,290 --> 00:33:02,190
for building Ruby format

00:33:00,270 --> 00:33:04,830
these things are so important it just

00:33:02,190 --> 00:33:07,410
will not be good people will not want to

00:33:04,830 --> 00:33:13,440
use it if it doesn't do all of these

00:33:07,410 --> 00:33:16,380
things but like these imply so much work

00:33:13,440 --> 00:33:18,210
like I'm doing so much work to get this

00:33:16,380 --> 00:33:21,140
done it's a really really hard piece of

00:33:18,210 --> 00:33:23,340
software to build in fact like I

00:33:21,140 --> 00:33:24,690
genuinely think this might be the most

00:33:23,340 --> 00:33:27,000
technically complex piece of software

00:33:24,690 --> 00:33:29,160
I've ever built and I include like all

00:33:27,000 --> 00:33:31,280
of the distributed system nonsense I did

00:33:29,160 --> 00:33:35,970
when I worked at digitalocean

00:33:31,280 --> 00:33:40,350
this is it's super cool like it really

00:33:35,970 --> 00:33:42,480
really motivates me I am spending a lot

00:33:40,350 --> 00:33:43,380
of time sweating the details and trying

00:33:42,480 --> 00:33:46,920
to get this right

00:33:43,380 --> 00:33:49,350
I think many folks outside of Ruby say

00:33:46,920 --> 00:33:51,650
that like us not having an auto in for

00:33:49,350 --> 00:33:55,950
mater is kind of us missing table stakes

00:33:51,650 --> 00:34:00,600
these days and I think we can solve this

00:33:55,950 --> 00:34:02,160
problem I genuinely and legitimately

00:34:00,600 --> 00:34:04,830
want to say thank you to the river cop

00:34:02,160 --> 00:34:06,990
and sorbet teams like they have already

00:34:04,830 --> 00:34:09,149
built fantastic examples of ruby

00:34:06,990 --> 00:34:11,520
developer tooling and proved that

00:34:09,149 --> 00:34:13,290
there's appetite for like this kind of

00:34:11,520 --> 00:34:16,919
thing and frankly without the existence

00:34:13,290 --> 00:34:19,889
of these two I probably wouldn't know if

00:34:16,919 --> 00:34:21,840
I could build and pull this off so why

00:34:19,889 --> 00:34:25,220
can you get the code the code is

00:34:21,840 --> 00:34:26,760
github.com Penelope's own ruby format

00:34:25,220 --> 00:34:28,070
that's all I got

00:34:26,760 --> 00:34:37,610
thank you so much

00:34:28,070 --> 00:34:37,610
[Applause]

00:34:38,040 --> 00:34:47,309

YouTube URL: https://www.youtube.com/watch?v=ifUbj1xErlg


