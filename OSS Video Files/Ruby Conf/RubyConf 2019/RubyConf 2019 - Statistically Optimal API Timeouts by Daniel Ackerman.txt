Title: RubyConf 2019 - Statistically Optimal API Timeouts by Daniel Ackerman
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Statistically Optimal API Timeouts by Daniel Ackerman

Have you ever written code that retries an API request? How did you pick the amount of time to wait before retrying? If you resorted to making an 'educated best guess' then this talk is for you.

You will walk away from this talk with: 1. Knowledge of when a timeout is optimal & how important this optimality is! 2. An explanation of the algorithms necessary to calculate optimal timeouts! 3. An overview of a new open source Ruby library to calculate optimal timeouts using an open source CAS!

By the end: you will be equipped to optimize your timeouts, using your favorite language, Ruby.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:13,120 --> 00:00:17,039
hey

00:00:14,920 --> 00:00:19,600
um

00:00:17,039 --> 00:00:20,560
so i'm daniel ackerman and i'm here to

00:00:19,600 --> 00:00:22,960
present to you

00:00:20,560 --> 00:00:24,080
my talk on statistically optimal uh

00:00:22,960 --> 00:00:26,720
retry policies or

00:00:24,080 --> 00:00:27,359
statistically optimal api timeouts uh

00:00:26,720 --> 00:00:29,199
really a

00:00:27,359 --> 00:00:30,720
timeout is how long you're gonna wait

00:00:29,199 --> 00:00:32,399
before you retry a request

00:00:30,720 --> 00:00:34,800
so i think another great way to put it

00:00:32,399 --> 00:00:36,559
is uh optimal retry policies

00:00:34,800 --> 00:00:38,079
uh so first i'll go over a bit of a

00:00:36,559 --> 00:00:39,200
background on the problem be some

00:00:38,079 --> 00:00:40,640
information about me and

00:00:39,200 --> 00:00:42,640
also kind of what inspired me to take

00:00:40,640 --> 00:00:45,200
this on then i'll go over

00:00:42,640 --> 00:00:47,200
why one should use timeouts or what the

00:00:45,200 --> 00:00:49,920
canonical situations for them are

00:00:47,200 --> 00:00:51,600
and then uh i'll look at how one can use

00:00:49,920 --> 00:00:53,199
timeouts in ruby i'll go over kind of

00:00:51,600 --> 00:00:55,760
the correct way to use them

00:00:53,199 --> 00:00:57,199
and then i'll briefly touch on if your

00:00:55,760 --> 00:00:58,879
timeouts are good

00:00:57,199 --> 00:01:00,239
how you can kind of evaluate their

00:00:58,879 --> 00:01:01,680
goodness in a way

00:01:00,239 --> 00:01:03,600
and then we'll jump into timeout

00:01:01,680 --> 00:01:06,799
optimization which will cover my

00:01:03,600 --> 00:01:07,920
uh usage of this maxima ruby maxima

00:01:06,799 --> 00:01:10,000
library i wrote

00:01:07,920 --> 00:01:10,960
to calculate these optimal timeouts for

00:01:10,000 --> 00:01:12,720
you

00:01:10,960 --> 00:01:14,640
but first i'd like to start with a quote

00:01:12,720 --> 00:01:15,360
by descartes uh he was a famous

00:01:14,640 --> 00:01:17,840
philosopher

00:01:15,360 --> 00:01:19,360
from the 1600s and he said that

00:01:17,840 --> 00:01:20,799
mathematics is a more powerful

00:01:19,360 --> 00:01:22,080
instrument of knowledge than any other

00:01:20,799 --> 00:01:23,840
that has been bequeathed to us

00:01:22,080 --> 00:01:25,200
by human agency i think that it's

00:01:23,840 --> 00:01:27,119
important to start with a quote for

00:01:25,200 --> 00:01:28,720
a very mathematically based talk like

00:01:27,119 --> 00:01:31,520
this uh it kind of gets

00:01:28,720 --> 00:01:31,920
our mind in the right mindset um so

00:01:31,520 --> 00:01:35,200
first

00:01:31,920 --> 00:01:36,400
a bit of background uh about me i'm from

00:01:35,200 --> 00:01:38,240
austin texas

00:01:36,400 --> 00:01:39,439
i'm daniel ackerman it's pretty hot

00:01:38,240 --> 00:01:40,000
there i've been enjoying the cold

00:01:39,439 --> 00:01:41,600
weather and

00:01:40,000 --> 00:01:45,520
i'm a software engineer at braintree

00:01:41,600 --> 00:01:48,320
where i work on the pay with paypal team

00:01:45,520 --> 00:01:51,439
and i love mathematics it's kind of what

00:01:48,320 --> 00:01:51,439
inspired me for this talk

00:01:53,439 --> 00:01:57,119
and so now i'll touch on my inspiration

00:01:56,240 --> 00:01:59,680
um

00:01:57,119 --> 00:02:00,880
you know we we have these timeouts and

00:01:59,680 --> 00:02:02,960
all of our apis

00:02:00,880 --> 00:02:04,399
uh i know you've seen them before the

00:02:02,960 --> 00:02:07,439
question is uh

00:02:04,399 --> 00:02:09,840
how did someone establish that value um

00:02:07,439 --> 00:02:11,120
basically all of these network requests

00:02:09,840 --> 00:02:13,840
need a timeout

00:02:11,120 --> 00:02:15,360
and oftentimes they're kind of magically

00:02:13,840 --> 00:02:16,480
placed there you know you'll see in some

00:02:15,360 --> 00:02:18,239
get history that

00:02:16,480 --> 00:02:20,800
it's seven seconds and you don't really

00:02:18,239 --> 00:02:22,640
know why or it's the 95th percentile

00:02:20,800 --> 00:02:24,480
often there is a suggestion to retry at

00:02:22,640 --> 00:02:27,280
the 95th percentile

00:02:24,480 --> 00:02:27,840
uh this suggestion it isn't really

00:02:27,280 --> 00:02:31,440
backed up

00:02:27,840 --> 00:02:33,120
by any quantitative claims like people

00:02:31,440 --> 00:02:35,280
always say oh the 95th percentile or the

00:02:33,120 --> 00:02:38,080
99th percentile or the 90th percentile

00:02:35,280 --> 00:02:39,680
kind of my my question was uh what it

00:02:38,080 --> 00:02:41,680
like why would we pick this

00:02:39,680 --> 00:02:43,599
um and also with my mathematical

00:02:41,680 --> 00:02:45,680
background determining a solution

00:02:43,599 --> 00:02:47,599
looked like a good and practical

00:02:45,680 --> 00:02:49,360
challenge uh so first we'll look at a

00:02:47,599 --> 00:02:51,840
quick pictorial argument

00:02:49,360 --> 00:02:53,920
these are two distributions and the cdf

00:02:51,840 --> 00:02:56,160
is the chances of receiving response by

00:02:53,920 --> 00:02:57,360
a certain time if we look at the one on

00:02:56,160 --> 00:02:59,360
the left we're

00:02:57,360 --> 00:03:01,920
getting about 80 percent of our

00:02:59,360 --> 00:03:03,599
responses by 4 seconds

00:03:01,920 --> 00:03:05,519
and the 95th percentile is about 10

00:03:03,599 --> 00:03:07,440
seconds and really on the right the 80th

00:03:05,519 --> 00:03:08,440
percentile is 10 seconds while the 95th

00:03:07,440 --> 00:03:11,599
percentile is

00:03:08,440 --> 00:03:14,159
10.4 seconds right uh

00:03:11,599 --> 00:03:15,120
as a mathematician it looks very quite

00:03:14,159 --> 00:03:18,239
obviously to me that

00:03:15,120 --> 00:03:20,000
the left distribution could be optimized

00:03:18,239 --> 00:03:21,519
you could optimize against that and with

00:03:20,000 --> 00:03:23,360
this 80th percentile you could probably

00:03:21,519 --> 00:03:24,159
take advantage of that and speed up the

00:03:23,360 --> 00:03:27,680
overall

00:03:24,159 --> 00:03:29,040
uh request cycle or your retry rate um

00:03:27,680 --> 00:03:31,680
basically looking at the distribution

00:03:29,040 --> 00:03:34,640
can can uh kind of informed my

00:03:31,680 --> 00:03:35,440
reason to look into this more um and

00:03:34,640 --> 00:03:36,400
also

00:03:35,440 --> 00:03:38,640
something that's great about this is

00:03:36,400 --> 00:03:39,680
it's very easy to change uh it doesn't

00:03:38,640 --> 00:03:41,360
require any crazy

00:03:39,680 --> 00:03:43,040
infrastructure changes like you know you

00:03:41,360 --> 00:03:45,440
have to add some basic uh

00:03:43,040 --> 00:03:46,560
tools to allow for more retries or for

00:03:45,440 --> 00:03:48,879
more timeouts

00:03:46,560 --> 00:03:50,239
but it's typically as easy as changing a

00:03:48,879 --> 00:03:52,159
config file

00:03:50,239 --> 00:03:54,159
it also has some unique impacts if it's

00:03:52,159 --> 00:03:56,400
possible to speed up the

00:03:54,159 --> 00:03:57,360
overall response time of many downstream

00:03:56,400 --> 00:03:59,439
requests

00:03:57,360 --> 00:04:01,439
then you can theoretically boost the

00:03:59,439 --> 00:04:02,319
response rate of your api or your

00:04:01,439 --> 00:04:05,120
service or

00:04:02,319 --> 00:04:06,080
your tool uh that would be incredible

00:04:05,120 --> 00:04:07,920
because otherwise

00:04:06,080 --> 00:04:10,560
you can't really speed up the downstream

00:04:07,920 --> 00:04:13,599
api without convincing them to do so and

00:04:10,560 --> 00:04:16,639
often that you can't do that um

00:04:13,599 --> 00:04:19,199
and uh yeah so

00:04:16,639 --> 00:04:20,160
now we'll jump into why uh one should

00:04:19,199 --> 00:04:22,720
use timeouts

00:04:20,160 --> 00:04:24,000
uh there's protocol failure which is

00:04:22,720 --> 00:04:25,280
some failure between you and the

00:04:24,000 --> 00:04:27,840
downstream service

00:04:25,280 --> 00:04:29,520
and there's also service failure uh so

00:04:27,840 --> 00:04:32,080
looking at protocol failure

00:04:29,520 --> 00:04:33,120
typically uh as ruby developers we're

00:04:32,080 --> 00:04:35,919
going over the internet

00:04:33,120 --> 00:04:36,400
it's like a tcp connection we're sending

00:04:35,919 --> 00:04:37,600
uh

00:04:36,400 --> 00:04:40,080
you know some message to a server and

00:04:37,600 --> 00:04:41,759
they're gonna respond back over http

00:04:40,080 --> 00:04:43,759
uh and that means that all seven of

00:04:41,759 --> 00:04:45,680
these layers have to work perfectly

00:04:43,759 --> 00:04:47,199
if any of them fail for any reason it's

00:04:45,680 --> 00:04:48,000
possible you won't even get a response

00:04:47,199 --> 00:04:51,360
back

00:04:48,000 --> 00:04:53,280
uh depending and when

00:04:51,360 --> 00:04:55,199
you're writing api requests whether it's

00:04:53,280 --> 00:04:56,240
a tool or a service uh you have to be

00:04:55,199 --> 00:04:57,680
aware that you know

00:04:56,240 --> 00:05:00,160
you there is a chance for protocol

00:04:57,680 --> 00:05:02,240
failure um but also

00:05:00,160 --> 00:05:04,160
uh something to keep in mind is that

00:05:02,240 --> 00:05:04,960
almost no service can guarantee a

00:05:04,160 --> 00:05:08,080
success

00:05:04,960 --> 00:05:10,000
uh this is due to turn completeness and

00:05:08,080 --> 00:05:12,000
the halting problem but basically we we

00:05:10,000 --> 00:05:13,759
can guarantee that no service is

00:05:12,000 --> 00:05:16,720
guaranteed to succeed

00:05:13,759 --> 00:05:17,840
uh there's always a failure it's kind of

00:05:16,720 --> 00:05:21,039
expected right

00:05:17,840 --> 00:05:23,360
um so now we'll jump into how you can

00:05:21,039 --> 00:05:25,759
use timeouts in ruby

00:05:23,360 --> 00:05:26,800
and for http requests you need to make

00:05:25,759 --> 00:05:28,000
sure you're setting these in your

00:05:26,800 --> 00:05:30,960
adapter

00:05:28,000 --> 00:05:31,360
and if you're using a timeout for like

00:05:30,960 --> 00:05:34,400
some

00:05:31,360 --> 00:05:36,320
computational code use timeout timeout

00:05:34,400 --> 00:05:38,400
we'll kind of jump into both of these

00:05:36,320 --> 00:05:41,680
these are examples of using

00:05:38,400 --> 00:05:43,840
the adapter to set your timeouts uh

00:05:41,680 --> 00:05:45,759
really in the context of this talk we're

00:05:43,840 --> 00:05:48,240
typically talking about timeout

00:05:45,759 --> 00:05:49,039
uh but it depends on which adapter

00:05:48,240 --> 00:05:51,120
you're using and

00:05:49,039 --> 00:05:52,400
how that adapter is configured um and

00:05:51,120 --> 00:05:53,759
really i have to give credit where

00:05:52,400 --> 00:05:56,400
credit is due

00:05:53,759 --> 00:05:57,600
the ultimate guide to ruby timeouts is

00:05:56,400 --> 00:06:00,000
an incredible guide with

00:05:57,600 --> 00:06:01,759
a list of basically every adapter in

00:06:00,000 --> 00:06:02,160
existence including like sql adapters

00:06:01,759 --> 00:06:04,240
that

00:06:02,160 --> 00:06:05,199
you can refer to for how to set these

00:06:04,240 --> 00:06:08,720
timeouts for

00:06:05,199 --> 00:06:11,600
uh your your code uh and what have you

00:06:08,720 --> 00:06:13,360
um and also uh it's very important that

00:06:11,600 --> 00:06:15,120
you don't use timeout timeout

00:06:13,360 --> 00:06:17,520
for setting your network request

00:06:15,120 --> 00:06:19,840
timeouts this will spin up a new thread

00:06:17,520 --> 00:06:21,039
and start the execution and then wait

00:06:19,840 --> 00:06:22,960
for either

00:06:21,039 --> 00:06:24,479
the number of seconds you're waiting to

00:06:22,960 --> 00:06:25,039
complete or for the calculation to

00:06:24,479 --> 00:06:26,319
complete

00:06:25,039 --> 00:06:28,240
if you use this for your network

00:06:26,319 --> 00:06:30,080
requests you'll run into a ton of issues

00:06:28,240 --> 00:06:31,600
like broken sockets and

00:06:30,080 --> 00:06:33,440
i've seen this many times in new code

00:06:31,600 --> 00:06:35,280
bases and it's something you just you

00:06:33,440 --> 00:06:38,960
absolutely do not want to do

00:06:35,280 --> 00:06:39,360
just a healthy psa um so now we'll look

00:06:38,960 --> 00:06:42,479
at

00:06:39,360 --> 00:06:44,400
if our timeouts are any good uh

00:06:42,479 --> 00:06:46,319
and i think it's worth looking at this

00:06:44,400 --> 00:06:47,680
quote by peter drucker

00:06:46,319 --> 00:06:50,319
if you can't measure it you can't

00:06:47,680 --> 00:06:51,520
improve it and i think that uh often

00:06:50,319 --> 00:06:54,080
what i find with

00:06:51,520 --> 00:06:55,520
services is they won't keep track of the

00:06:54,080 --> 00:06:56,160
success rate of their downstream

00:06:55,520 --> 00:06:59,280
requests

00:06:56,160 --> 00:07:01,039
uh especially with a policy and

00:06:59,280 --> 00:07:03,199
if you're not keeping track of the

00:07:01,039 --> 00:07:04,080
response times it's actually impossible

00:07:03,199 --> 00:07:06,319
to

00:07:04,080 --> 00:07:08,479
try and improve it uh or to even you

00:07:06,319 --> 00:07:10,400
know reflect on your retry policies

00:07:08,479 --> 00:07:12,240
i've seen in services before where

00:07:10,400 --> 00:07:12,639
someone you know they'll set a timeout

00:07:12,240 --> 00:07:15,520
of

00:07:12,639 --> 00:07:16,319
10 seconds and 99 percent of their

00:07:15,520 --> 00:07:18,240
responses

00:07:16,319 --> 00:07:19,840
you know their 99th percentile is two

00:07:18,240 --> 00:07:20,720
seconds let's say but because they

00:07:19,840 --> 00:07:22,639
didn't start

00:07:20,720 --> 00:07:24,160
um because they weren't tracking it it

00:07:22,639 --> 00:07:26,319
wasn't possible for them to

00:07:24,160 --> 00:07:28,000
uh kind of have that feedback loop and

00:07:26,319 --> 00:07:29,280
improve upon their existing timeout so

00:07:28,000 --> 00:07:29,919
that's something i highly suggest for

00:07:29,280 --> 00:07:32,960
any

00:07:29,919 --> 00:07:35,120
anybody for any any requests i go in

00:07:32,960 --> 00:07:36,400
um specifically for high volume services

00:07:35,120 --> 00:07:37,199
where you're sending a lot of requests

00:07:36,400 --> 00:07:38,639
downstream

00:07:37,199 --> 00:07:40,720
it is very important that you monitor

00:07:38,639 --> 00:07:41,599
this uh you can you should have

00:07:40,720 --> 00:07:43,759
dashboards

00:07:41,599 --> 00:07:45,440
and potentially alerts depending upon

00:07:43,759 --> 00:07:47,759
what what your service is doing

00:07:45,440 --> 00:07:50,000
um and one thing to keep in mind is that

00:07:47,759 --> 00:07:52,639
the 95th percentile is actually an

00:07:50,000 --> 00:07:53,520
okay measure to use here uh i mean we're

00:07:52,639 --> 00:07:56,639
saying is that

00:07:53,520 --> 00:07:59,120
95 of your requests have received a

00:07:56,639 --> 00:07:59,759
response uh if your service is low

00:07:59,120 --> 00:08:02,800
volume

00:07:59,759 --> 00:08:04,319
or it isn't um you know super important

00:08:02,800 --> 00:08:08,560
that you get a quick response that's

00:08:04,319 --> 00:08:10,639
actually a fine uh general rule of thumb

00:08:08,560 --> 00:08:12,160
and ideally you're going to be capturing

00:08:10,639 --> 00:08:13,919
this data in some

00:08:12,160 --> 00:08:15,520
proxy layer that means that you can

00:08:13,919 --> 00:08:16,800
totally hang up on the requests in your

00:08:15,520 --> 00:08:20,879
application and

00:08:16,800 --> 00:08:22,400
wait and do analysis in your proxy layer

00:08:20,879 --> 00:08:23,759
it's also very important that especially

00:08:22,400 --> 00:08:24,479
before you attempt to optimize these

00:08:23,759 --> 00:08:26,800
timeouts

00:08:24,479 --> 00:08:27,520
you're communicating with any down with

00:08:26,800 --> 00:08:30,639
the api

00:08:27,520 --> 00:08:32,000
owners uh if there's something they can

00:08:30,639 --> 00:08:33,919
do to speed up your

00:08:32,000 --> 00:08:35,519
your requests or if they can give you

00:08:33,919 --> 00:08:36,959
assistance it's

00:08:35,519 --> 00:08:38,560
definitely best to reach out to them

00:08:36,959 --> 00:08:43,360
first uh oftentimes

00:08:38,560 --> 00:08:45,920
that can really help out um and

00:08:43,360 --> 00:08:46,480
yeah um but now we'll go into how one

00:08:45,920 --> 00:08:48,480
could

00:08:46,480 --> 00:08:50,399
optimize the timeouts uh first we'll go

00:08:48,480 --> 00:08:51,040
over a bit of a mathematical formulation

00:08:50,399 --> 00:08:53,440
of what

00:08:51,040 --> 00:08:54,480
this kind of a request cycle success

00:08:53,440 --> 00:08:56,240
chance would look like

00:08:54,480 --> 00:08:57,760
we'll look into how we would collect our

00:08:56,240 --> 00:08:59,760
data we'll look at an

00:08:57,760 --> 00:09:00,880
independent non-linear solution so

00:08:59,760 --> 00:09:02,320
independent requests

00:09:00,880 --> 00:09:04,160
we'll briefly touch on how one could

00:09:02,320 --> 00:09:05,440
look at this from a linear solution

00:09:04,160 --> 00:09:07,360
and then we'll kind of analyze these

00:09:05,440 --> 00:09:08,080
results in a way that i feel like we'll

00:09:07,360 --> 00:09:10,320
all

00:09:08,080 --> 00:09:11,839
gain something from um so in terms of

00:09:10,320 --> 00:09:13,040
the mathematical formulation

00:09:11,839 --> 00:09:14,880
we're going to start looking at like a

00:09:13,040 --> 00:09:17,120
basic system topology of the the

00:09:14,880 --> 00:09:18,240
you know what what kind of system should

00:09:17,120 --> 00:09:20,720
uh

00:09:18,240 --> 00:09:22,000
one try to optimize timeouts for um

00:09:20,720 --> 00:09:25,279
we'll build an equation

00:09:22,000 --> 00:09:27,040
a cdf for equation for multiple timeouts

00:09:25,279 --> 00:09:28,080
the chances of a success by a certain

00:09:27,040 --> 00:09:30,080
time given that

00:09:28,080 --> 00:09:31,440
you have one timeout we'll look at an

00:09:30,080 --> 00:09:33,519
equation for multiple

00:09:31,440 --> 00:09:34,480
timeouts uh we'll look at an

00:09:33,519 --> 00:09:36,800
unconstrained

00:09:34,480 --> 00:09:37,920
optimization problem version of it an

00:09:36,800 --> 00:09:39,760
optimization problem

00:09:37,920 --> 00:09:41,519
uh we'll look at the definition of what

00:09:39,760 --> 00:09:42,959
an optimization problem is and then

00:09:41,519 --> 00:09:44,320
we'll convert this into a constrained

00:09:42,959 --> 00:09:48,160
optimization problem

00:09:44,320 --> 00:09:50,320
um so to look at the system topology the

00:09:48,160 --> 00:09:52,160
only the real system i suggest you try

00:09:50,320 --> 00:09:53,839
and apply this approach to is one where

00:09:52,160 --> 00:09:55,760
you know you have some service and

00:09:53,839 --> 00:09:57,519
you're getting a request to it

00:09:55,760 --> 00:09:59,360
you're under kind of a time crunch to

00:09:57,519 --> 00:10:00,880
get a response as fast as possible to

00:09:59,360 --> 00:10:03,440
the upstream service right

00:10:00,880 --> 00:10:05,120
and you may have to touch reach out to

00:10:03,440 --> 00:10:06,320
many downstream services

00:10:05,120 --> 00:10:08,160
uh it could be a server you know

00:10:06,320 --> 00:10:11,519
whatever but um

00:10:08,160 --> 00:10:12,959
in these cases you your response rate

00:10:11,519 --> 00:10:15,279
uh the response rate of those downstream

00:10:12,959 --> 00:10:16,959
apis in some is proportionate to the

00:10:15,279 --> 00:10:19,279
response rate of your api

00:10:16,959 --> 00:10:21,839
therefore you should if possible you

00:10:19,279 --> 00:10:25,200
should try to maximize the speed of this

00:10:21,839 --> 00:10:27,680
um so first we'll look at uh what

00:10:25,200 --> 00:10:29,600
uh or this cdf would look like for one

00:10:27,680 --> 00:10:32,640
timeout and then two timeouts

00:10:29,600 --> 00:10:35,440
um and really uh this is

00:10:32,640 --> 00:10:37,279
this is what it'll look like um if we

00:10:35,440 --> 00:10:38,240
haven't started processing or we haven't

00:10:37,279 --> 00:10:40,720
sent the request yet

00:10:38,240 --> 00:10:41,519
there's zero chance of success once

00:10:40,720 --> 00:10:42,959
we've sent it

00:10:41,519 --> 00:10:45,200
are the chances of this test is

00:10:42,959 --> 00:10:46,320
proportionate to this overall cdf you're

00:10:45,200 --> 00:10:50,000
calculating

00:10:46,320 --> 00:10:52,640
um so the overall chances of receiving a

00:10:50,000 --> 00:10:53,920
response by a certain time uh and then

00:10:52,640 --> 00:10:55,120
once we've reached the timeout we've

00:10:53,920 --> 00:10:56,880
kind of capped out and

00:10:55,120 --> 00:10:59,040
there's you know you can't increase your

00:10:56,880 --> 00:11:01,760
chances of receiving response

00:10:59,040 --> 00:11:02,399
uh but when we introduce a second

00:11:01,760 --> 00:11:05,279
timeout

00:11:02,399 --> 00:11:05,760
the equation becomes more complicated or

00:11:05,279 --> 00:11:07,519
after

00:11:05,760 --> 00:11:09,040
the first timeout is completed we're

00:11:07,519 --> 00:11:09,600
really looking at the chances that at

00:11:09,040 --> 00:11:12,160
least

00:11:09,600 --> 00:11:14,000
one of the requ of the request has

00:11:12,160 --> 00:11:16,560
succeeded by a certain time

00:11:14,000 --> 00:11:17,279
uh when we take this when we look at two

00:11:16,560 --> 00:11:20,320
timeouts

00:11:17,279 --> 00:11:22,240
um once both of them have completed

00:11:20,320 --> 00:11:23,519
the request cycle the chance to discuss

00:11:22,240 --> 00:11:26,000
can't increase uh

00:11:23,519 --> 00:11:27,600
you know it's fairly obvious um and

00:11:26,000 --> 00:11:28,000
here's an example of what shifting

00:11:27,600 --> 00:11:30,160
around

00:11:28,000 --> 00:11:31,920
a timeout would look like in terms of

00:11:30,160 --> 00:11:32,959
the resulting distribution for a chance

00:11:31,920 --> 00:11:34,720
of success

00:11:32,959 --> 00:11:36,240
uh and while this is slight it is

00:11:34,720 --> 00:11:39,040
actually an impact

00:11:36,240 --> 00:11:40,079
uh that can be made here um and then

00:11:39,040 --> 00:11:42,640
we'll look at one for

00:11:40,079 --> 00:11:44,240
you know multiple timeouts uh in some

00:11:42,640 --> 00:11:45,279
cases you could be three or four or five

00:11:44,240 --> 00:11:48,480
timeouts right

00:11:45,279 --> 00:11:51,200
and uh uh cdf is a chance

00:11:48,480 --> 00:11:53,040
like it's the in this context is your

00:11:51,200 --> 00:11:53,600
chances of success by a certain time

00:11:53,040 --> 00:11:56,480
right

00:11:53,600 --> 00:11:58,160
so uh the percentage of requests that

00:11:56,480 --> 00:12:00,480
you know you send out a request

00:11:58,160 --> 00:12:01,760
there's uh in you know one instance you

00:12:00,480 --> 00:12:03,680
receive it by eight seconds

00:12:01,760 --> 00:12:04,800
the next time it's 20 seconds right and

00:12:03,680 --> 00:12:06,959
if we sum up

00:12:04,800 --> 00:12:08,399
all of the potential times we build like

00:12:06,959 --> 00:12:08,959
a distribution for your chances of

00:12:08,399 --> 00:12:11,519
getting a

00:12:08,959 --> 00:12:12,639
response by a specific time then we

00:12:11,519 --> 00:12:13,519
integrate that and you get like your

00:12:12,639 --> 00:12:15,920
chances of

00:12:13,519 --> 00:12:16,720
receiving a response so uh one good

00:12:15,920 --> 00:12:19,120
example is

00:12:16,720 --> 00:12:21,519
in any cases by 10 seconds for example

00:12:19,120 --> 00:12:24,560
we've received basically 100

00:12:21,519 --> 00:12:26,959
of a response to 100 of our requests

00:12:24,560 --> 00:12:28,959
as to where by six seconds we receive

00:12:26,959 --> 00:12:31,200
like you know 90

00:12:28,959 --> 00:12:31,200
um

00:12:32,399 --> 00:12:38,800
so now that we have an equation to

00:12:35,680 --> 00:12:40,800
use for multiple timeouts uh

00:12:38,800 --> 00:12:42,880
calculating the the sum total chance of

00:12:40,800 --> 00:12:45,279
a success given multiple timeouts

00:12:42,880 --> 00:12:46,480
we'll look at how uh we'll look at this

00:12:45,279 --> 00:12:47,839
in terms of an unconstrained

00:12:46,480 --> 00:12:49,680
optimization problem

00:12:47,839 --> 00:12:51,440
ideally you want to minimize total

00:12:49,680 --> 00:12:53,040
amount of time you're using for

00:12:51,440 --> 00:12:54,560
your this request sequence for this

00:12:53,040 --> 00:12:57,279
downstream service while

00:12:54,560 --> 00:12:58,160
maximizing the chances of this net like

00:12:57,279 --> 00:13:00,639
of the total

00:12:58,160 --> 00:13:02,000
request sequences success uh and

00:13:00,639 --> 00:13:02,320
unfortunately this is unconstrained

00:13:02,000 --> 00:13:03,920
because

00:13:02,320 --> 00:13:05,839
you want two things at the same time you

00:13:03,920 --> 00:13:06,959
want to minimize your time and maximize

00:13:05,839 --> 00:13:09,519
your chances of success

00:13:06,959 --> 00:13:11,279
so we'll look at this um really the

00:13:09,519 --> 00:13:14,240
definition of an optimize

00:13:11,279 --> 00:13:14,560
of an optimization problem it it only

00:13:14,240 --> 00:13:15,920
has

00:13:14,560 --> 00:13:17,600
one measure that we're trying to

00:13:15,920 --> 00:13:18,560
minimize or maximize everything else is

00:13:17,600 --> 00:13:21,200
constrained

00:13:18,560 --> 00:13:22,800
and in this case i think it's easiest to

00:13:21,200 --> 00:13:25,760
just constrain the chances

00:13:22,800 --> 00:13:26,959
of the constrain the overall amount of

00:13:25,760 --> 00:13:28,000
time you're spending on this request

00:13:26,959 --> 00:13:30,160
sequence right so

00:13:28,000 --> 00:13:31,040
you would suppose uh given this this

00:13:30,160 --> 00:13:33,040
distribution

00:13:31,040 --> 00:13:35,360
uh for a chance of success i want to

00:13:33,040 --> 00:13:36,240
calculate you know given 10 seconds and

00:13:35,360 --> 00:13:38,720
two timeouts

00:13:36,240 --> 00:13:40,240
how can i maximize my chances of success

00:13:38,720 --> 00:13:42,720
and i think this is helpful

00:13:40,240 --> 00:13:44,000
a service can always take in a total

00:13:42,720 --> 00:13:45,120
amount of time that they can spend on

00:13:44,000 --> 00:13:46,959
the operation

00:13:45,120 --> 00:13:48,639
and uh with that in mind you could

00:13:46,959 --> 00:13:51,600
always apply it like this

00:13:48,639 --> 00:13:52,480
um so now we'll look at how you can

00:13:51,600 --> 00:13:54,639
actually do this

00:13:52,480 --> 00:13:55,760
uh or how you gather the data for this

00:13:54,639 --> 00:13:57,600
um

00:13:55,760 --> 00:13:59,440
gathering the data would be as simple as

00:13:57,600 --> 00:14:01,680
looking at your proxy layer and

00:13:59,440 --> 00:14:02,880
pulling the taking the request time and

00:14:01,680 --> 00:14:04,560
the response time subtracting your

00:14:02,880 --> 00:14:08,320
response time from your request time and

00:14:04,560 --> 00:14:11,199
getting just basically a distribution

00:14:08,320 --> 00:14:11,680
for your chances of success by a certain

00:14:11,199 --> 00:14:15,279
time

00:14:11,680 --> 00:14:17,279
uh you can group the data by each uh

00:14:15,279 --> 00:14:18,480
segment right it may not be by url it

00:14:17,279 --> 00:14:20,639
may be by

00:14:18,480 --> 00:14:21,920
uh like operation where you're passing

00:14:20,639 --> 00:14:22,800
in a specific parameter but you want to

00:14:21,920 --> 00:14:24,240
group it by

00:14:22,800 --> 00:14:26,639
distributions that would that would make

00:14:24,240 --> 00:14:29,519
sense as a requester like for the api

00:14:26,639 --> 00:14:31,040
you want to you know um and then we need

00:14:29,519 --> 00:14:33,279
to transform this data into

00:14:31,040 --> 00:14:34,720
an actual cdf and this would be like the

00:14:33,279 --> 00:14:36,959
pdf uh

00:14:34,720 --> 00:14:38,720
like you know this would mean that at

00:14:36,959 --> 00:14:39,600
0.3 seconds we received a ton of

00:14:38,720 --> 00:14:41,199
responses

00:14:39,600 --> 00:14:43,199
uh in two seconds we received a lot of

00:14:41,199 --> 00:14:45,040
responses so on when we

00:14:43,199 --> 00:14:46,320
kind of integrate over this we'll get a

00:14:45,040 --> 00:14:48,480
cdf which is

00:14:46,320 --> 00:14:49,839
by you know two seconds we've received

00:14:48,480 --> 00:14:51,440
fifty percent of

00:14:49,839 --> 00:14:53,120
a response for fifty percent of our

00:14:51,440 --> 00:14:55,199
requests uh and

00:14:53,120 --> 00:14:57,199
it's basically integrating the the left

00:14:55,199 --> 00:14:59,440
hand um but now that we have

00:14:57,199 --> 00:15:00,880
data we need to find a way to

00:14:59,440 --> 00:15:03,680
analytically solve this

00:15:00,880 --> 00:15:04,639
uh so one great thing we can do we have

00:15:03,680 --> 00:15:07,279
this discrete

00:15:04,639 --> 00:15:07,760
set of this discrete data uh we actually

00:15:07,279 --> 00:15:09,760
need to

00:15:07,760 --> 00:15:11,040
convert we need to perform a regression

00:15:09,760 --> 00:15:12,560
on it um

00:15:11,040 --> 00:15:14,560
and that's required for like an

00:15:12,560 --> 00:15:17,040
analytical optimization

00:15:14,560 --> 00:15:19,199
it's just necessary uh and thankfully

00:15:17,040 --> 00:15:20,079
with the the stoneware stress theorem to

00:15:19,199 --> 00:15:22,240
tell us that

00:15:20,079 --> 00:15:24,240
polynomial approximations are perfectly

00:15:22,240 --> 00:15:27,199
accurate on a fixed uh

00:15:24,240 --> 00:15:27,760
spec on a closed interval uh and it's

00:15:27,199 --> 00:15:30,639
such a

00:15:27,760 --> 00:15:33,120
great theorem but basically we perform a

00:15:30,639 --> 00:15:34,639
least squares regression over your data

00:15:33,120 --> 00:15:36,079
and you can see how as the the terms

00:15:34,639 --> 00:15:36,399
increase for this regression we're kind

00:15:36,079 --> 00:15:38,079
of

00:15:36,399 --> 00:15:39,759
fitting the data in this case that the

00:15:38,079 --> 00:15:42,320
data would be uh purely

00:15:39,759 --> 00:15:44,560
going up it'd be your discrete cdf but

00:15:42,320 --> 00:15:46,560
we'll fit a polynomial to the data

00:15:44,560 --> 00:15:47,839
and that will give us a great

00:15:46,560 --> 00:15:51,040
approximation of your

00:15:47,839 --> 00:15:52,560
your actual uh distribution and then

00:15:51,040 --> 00:15:54,480
in order to actually solve this we'll

00:15:52,560 --> 00:15:56,079
apply lagrangian multipliers

00:15:54,480 --> 00:15:57,839
uh and it's actually very difficult to

00:15:56,079 --> 00:15:59,839
explain lagrangian multipliers but

00:15:57,839 --> 00:16:01,759
they're used in multi-variable calculus

00:15:59,839 --> 00:16:03,199
to literally solve this exact problem

00:16:01,759 --> 00:16:05,519
where you're trying to maximize

00:16:03,199 --> 00:16:06,639
some function with respect to another

00:16:05,519 --> 00:16:09,360
function

00:16:06,639 --> 00:16:11,040
and our constraint in this case is again

00:16:09,360 --> 00:16:12,720
all of the total amount of time we want

00:16:11,040 --> 00:16:14,480
to spend on these requests

00:16:12,720 --> 00:16:16,079
uh and we're trying to maximize this

00:16:14,480 --> 00:16:16,959
other you know maximize the chances of

00:16:16,079 --> 00:16:20,000
success

00:16:16,959 --> 00:16:20,880
uh and thankfully given that uh the sum

00:16:20,000 --> 00:16:24,480
of the timeouts

00:16:20,880 --> 00:16:26,320
is a analytical function and the the

00:16:24,480 --> 00:16:27,440
uh calculation for the chances of

00:16:26,320 --> 00:16:29,120
success by a certain time is also

00:16:27,440 --> 00:16:30,320
analytical we can apply lagrangian

00:16:29,120 --> 00:16:33,279
multipliers

00:16:30,320 --> 00:16:34,639
um so now we'll jump into the actual

00:16:33,279 --> 00:16:37,680
code behind this

00:16:34,639 --> 00:16:39,839
uh we want to build and interpolate cdf

00:16:37,680 --> 00:16:40,880
so you'll provide it like your your data

00:16:39,839 --> 00:16:44,959
this would be a

00:16:40,880 --> 00:16:46,480
comma csv file of the second that you're

00:16:44,959 --> 00:16:48,639
making the request and the chances of

00:16:46,480 --> 00:16:51,920
having received a request by that time

00:16:48,639 --> 00:16:54,079
um and then this is some maxima code to

00:16:51,920 --> 00:16:54,959
actually perform the interpolation that

00:16:54,079 --> 00:16:57,759
we're doing here for the

00:16:54,959 --> 00:16:59,680
for the polynomial fit um this is like a

00:16:57,759 --> 00:17:01,519
part of the library i wrote but uh

00:16:59,680 --> 00:17:02,880
we're basically taking in the set of

00:17:01,519 --> 00:17:04,480
points and we're going to perform a

00:17:02,880 --> 00:17:06,880
least squares regression

00:17:04,480 --> 00:17:08,000
over some polynomial fit with a certain

00:17:06,880 --> 00:17:11,919
number of terms

00:17:08,000 --> 00:17:14,480
in this case 9 just for this example uh

00:17:11,919 --> 00:17:15,199
then we want to build the lagrangian

00:17:14,480 --> 00:17:17,120
function and

00:17:15,199 --> 00:17:18,480
we'll do that by building the chances of

00:17:17,120 --> 00:17:22,400
at least one success

00:17:18,480 --> 00:17:23,760
uh by a time uh and we provide in this

00:17:22,400 --> 00:17:24,799
kind of polynomial this this

00:17:23,760 --> 00:17:27,039
interpolated

00:17:24,799 --> 00:17:28,319
uh chance of success by a certain time

00:17:27,039 --> 00:17:30,480
we have this

00:17:28,319 --> 00:17:31,520
uh l constant which is just like a

00:17:30,480 --> 00:17:34,240
lambda it's what

00:17:31,520 --> 00:17:36,080
they use for lagrangian multipliers and

00:17:34,240 --> 00:17:37,039
then we have this constraint which is

00:17:36,080 --> 00:17:39,360
going to be the

00:17:37,039 --> 00:17:40,720
sum of all of our independent timeouts

00:17:39,360 --> 00:17:42,640
minus the total time and

00:17:40,720 --> 00:17:43,760
that has to equal zero for lagrangian

00:17:42,640 --> 00:17:46,720
multiplier

00:17:43,760 --> 00:17:47,280
work um and then we basically take the

00:17:46,720 --> 00:17:49,520
gradient

00:17:47,280 --> 00:17:51,520
which is you know the derivative of each

00:17:49,520 --> 00:17:54,640
independent timeout along with the

00:17:51,520 --> 00:17:56,400
lambda and we set the constraint to zero

00:17:54,640 --> 00:17:57,919
this is all just like how you apply

00:17:56,400 --> 00:18:00,880
lagrangian multipliers

00:17:57,919 --> 00:18:02,480
um and then we solve it as a system of

00:18:00,880 --> 00:18:05,440
polynomial equations

00:18:02,480 --> 00:18:05,840
uh this isn't it's just uh going to pass

00:18:05,440 --> 00:18:09,120
it to

00:18:05,840 --> 00:18:11,120
maxima and run uh algosis which will

00:18:09,120 --> 00:18:13,760
solve a system of linear a system of

00:18:11,120 --> 00:18:14,960
polynomial equations which once it's

00:18:13,760 --> 00:18:15,919
solved it'll actually give you a

00:18:14,960 --> 00:18:19,600
solution

00:18:15,919 --> 00:18:24,160
um and then uh you can actually run it

00:18:19,600 --> 00:18:28,640
um a an alternative to applying it as

00:18:24,160 --> 00:18:29,760
a uh as a continuous system is to look

00:18:28,640 --> 00:18:31,679
at it discretely

00:18:29,760 --> 00:18:32,799
and it's actually possible to transform

00:18:31,679 --> 00:18:34,799
this uh

00:18:32,799 --> 00:18:36,240
this continuous system into a discrete

00:18:34,799 --> 00:18:38,000
one where you could apply

00:18:36,240 --> 00:18:40,160
this to the knapsack problem in the

00:18:38,000 --> 00:18:42,320
knapsack problem canonically you have a

00:18:40,160 --> 00:18:44,400
set of items that you want to

00:18:42,320 --> 00:18:46,000
you want to maximize the value of while

00:18:44,400 --> 00:18:47,520
staying under some constraint of the

00:18:46,000 --> 00:18:50,080
number of items you can take

00:18:47,520 --> 00:18:51,200
and if you properly transform your

00:18:50,080 --> 00:18:53,360
distribution

00:18:51,200 --> 00:18:54,240
into uh if you properly transform the

00:18:53,360 --> 00:18:56,720
equation

00:18:54,240 --> 00:18:57,840
uh with you basically take the log and

00:18:56,720 --> 00:19:01,360
some other operations

00:18:57,840 --> 00:19:04,400
uh you can uh like like right here um

00:19:01,360 --> 00:19:05,280
you can actually apply the knapsack

00:19:04,400 --> 00:19:07,760
problem to this

00:19:05,280 --> 00:19:08,480
problem it will be discrete and so your

00:19:07,760 --> 00:19:10,720
solution will

00:19:08,480 --> 00:19:12,720
provide every possible solution but it

00:19:10,720 --> 00:19:13,840
will provide you with an accurate bound

00:19:12,720 --> 00:19:16,000
and it is much faster

00:19:13,840 --> 00:19:17,440
you won't have to interpolate and solve

00:19:16,000 --> 00:19:20,559
a system of equations

00:19:17,440 --> 00:19:21,679
um and so i'd like to go over some

00:19:20,559 --> 00:19:24,400
caveats for this

00:19:21,679 --> 00:19:25,919
uh the analysis presented only works for

00:19:24,400 --> 00:19:28,240
item potent requests

00:19:25,919 --> 00:19:29,919
and also for independent requests right

00:19:28,240 --> 00:19:32,559
this is basically gets

00:19:29,919 --> 00:19:34,000
uh anything where you know the second

00:19:32,559 --> 00:19:36,640
request won't depend on

00:19:34,000 --> 00:19:38,320
the time of the first one uh and that's

00:19:36,640 --> 00:19:39,039
unfortunate but i'll go into the reasons

00:19:38,320 --> 00:19:42,160
why

00:19:39,039 --> 00:19:45,360
um a typical policy

00:19:42,160 --> 00:19:47,039
uh typically the optimal policy is the

00:19:45,360 --> 00:19:48,559
total amount of time divided by the

00:19:47,039 --> 00:19:50,160
number of timeouts and

00:19:48,559 --> 00:19:52,799
this is a bit unfortunate to me but this

00:19:50,160 --> 00:19:54,880
is the net result of of this talk

00:19:52,799 --> 00:19:55,919
uh often when you apply these lagrangian

00:19:54,880 --> 00:19:58,640
multipliers

00:19:55,919 --> 00:20:00,400
the uh the highest the the policy with

00:19:58,640 --> 00:20:03,120
the highest chance of success is

00:20:00,400 --> 00:20:04,159
typically uh this but it's important

00:20:03,120 --> 00:20:06,080
again to look at

00:20:04,159 --> 00:20:07,600
uh here's like three distributions for

00:20:06,080 --> 00:20:09,760
example you know if if

00:20:07,600 --> 00:20:11,360
it's taking uh more time to get a

00:20:09,760 --> 00:20:12,720
response like this you know this black

00:20:11,360 --> 00:20:14,960
distribution at the bottom

00:20:12,720 --> 00:20:15,919
then it's there's almost no way you can

00:20:14,960 --> 00:20:18,159
optimize it as

00:20:15,919 --> 00:20:20,240
you have to wait you know until you hit

00:20:18,159 --> 00:20:23,200
this a very high percentile

00:20:20,240 --> 00:20:23,760
95 this is like the 95th percentile here

00:20:23,200 --> 00:20:24,799
but if

00:20:23,760 --> 00:20:26,720
you're looking like this orange

00:20:24,799 --> 00:20:28,480
distribution right um there's more of a

00:20:26,720 --> 00:20:29,440
chance to optimize it as you're getting

00:20:28,480 --> 00:20:32,080
more responses

00:20:29,440 --> 00:20:33,360
faster in any case where i see you know

00:20:32,080 --> 00:20:35,039
a distribution where i'm getting

00:20:33,360 --> 00:20:36,960
most you know like the 80th percentile

00:20:35,039 --> 00:20:37,760
is very very rapid with this kind of

00:20:36,960 --> 00:20:40,640
long tail

00:20:37,760 --> 00:20:42,400
towards a a 95th percentile it's often a

00:20:40,640 --> 00:20:43,919
case for me to think oh like what if we

00:20:42,400 --> 00:20:45,280
could actually optimize this this

00:20:43,919 --> 00:20:46,960
timeout policy

00:20:45,280 --> 00:20:49,039
uh instead of you know waiting for the

00:20:46,960 --> 00:20:51,600
95th percentile or what have you

00:20:49,039 --> 00:20:52,880
um and it's also worth looking into what

00:20:51,600 --> 00:20:53,919
you know what kind of analysis would be

00:20:52,880 --> 00:20:57,280
necessary for

00:20:53,919 --> 00:20:59,919
dependent requests um and

00:20:57,280 --> 00:21:00,480
one thing to keep in mind is when you're

00:20:59,919 --> 00:21:04,320
making

00:21:00,480 --> 00:21:04,880
uh dependent requests the it's possible

00:21:04,320 --> 00:21:07,919
that the

00:21:04,880 --> 00:21:09,600
downstream service is processing uh

00:21:07,919 --> 00:21:11,360
you know post-result operations right

00:21:09,600 --> 00:21:14,000
like they've calculated a result

00:21:11,360 --> 00:21:14,480
but they're running some uh like some

00:21:14,000 --> 00:21:16,159
some

00:21:14,480 --> 00:21:17,679
you know they're doing some metrics or

00:21:16,159 --> 00:21:19,200
something else or a downstream service

00:21:17,679 --> 00:21:20,799
is currently waiting on something else

00:21:19,200 --> 00:21:21,840
right but your response has already been

00:21:20,799 --> 00:21:23,600
calculated and

00:21:21,840 --> 00:21:25,039
in these cases a second request can

00:21:23,600 --> 00:21:28,159
actually lead to

00:21:25,039 --> 00:21:28,480
a faster response time but unfortunately

00:21:28,159 --> 00:21:30,480
the

00:21:28,480 --> 00:21:32,400
amount of data that's necessary to

00:21:30,480 --> 00:21:33,840
calculate the

00:21:32,400 --> 00:21:35,360
to look at the distribution for

00:21:33,840 --> 00:21:36,880
dependent requests is almost

00:21:35,360 --> 00:21:39,120
inconceivable you basically have to

00:21:36,880 --> 00:21:41,600
retried every possible interval

00:21:39,120 --> 00:21:42,480
and as much you know spent many hours

00:21:41,600 --> 00:21:44,799
trying to do this and

00:21:42,480 --> 00:21:46,960
it's almost it's basically impossible um

00:21:44,799 --> 00:21:47,520
it is possible to use something like a

00:21:46,960 --> 00:21:49,360
bayesian

00:21:47,520 --> 00:21:51,280
analysis and look at each independent

00:21:49,360 --> 00:21:52,880
request and have like a real-time policy

00:21:51,280 --> 00:21:53,200
generator but for an offline policy

00:21:52,880 --> 00:21:55,520
where

00:21:53,200 --> 00:21:57,360
you calculate it once and uh you're done

00:21:55,520 --> 00:22:00,880
it's uh it's not it's not possible

00:21:57,360 --> 00:22:02,240
um and i held it best also to end with a

00:22:00,880 --> 00:22:04,240
quote by descartes uh

00:22:02,240 --> 00:22:06,240
each problem that i solved became a rule

00:22:04,240 --> 00:22:07,200
which served afterwards to solve other

00:22:06,240 --> 00:22:09,600
problems

00:22:07,200 --> 00:22:10,559
uh i've found that is taking about two

00:22:09,600 --> 00:22:13,760
years to get a good

00:22:10,559 --> 00:22:15,120
solution for this uh that has led to me

00:22:13,760 --> 00:22:16,880
looking into other areas such as you

00:22:15,120 --> 00:22:18,880
know looking at analyzing

00:22:16,880 --> 00:22:20,400
analyzing this for dependent requests uh

00:22:18,880 --> 00:22:22,640
which is very difficult

00:22:20,400 --> 00:22:24,159
um but i'm hoping that someday i'll have

00:22:22,640 --> 00:22:26,460
more results here

00:22:24,159 --> 00:22:27,250
that's my talk thank you

00:22:26,460 --> 00:22:42,640
[Applause]

00:22:27,250 --> 00:22:44,720
[Music]

00:22:42,640 --> 00:22:44,720

YouTube URL: https://www.youtube.com/watch?v=OxNL0vRsXi0


