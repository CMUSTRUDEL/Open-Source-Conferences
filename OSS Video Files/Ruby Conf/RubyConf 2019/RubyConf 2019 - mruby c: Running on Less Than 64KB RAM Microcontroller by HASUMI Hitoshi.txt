Title: RubyConf 2019 - mruby c: Running on Less Than 64KB RAM Microcontroller by HASUMI Hitoshi
Publication date: 2019-11-28
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - mruby/c: Running on Less Than 64KB RAM Microcontroller by HASUMI Hitoshi

I will show you an actual IoT product which uses one-chip-microcontroller-based hardwares for a Japanese Sake Brewery. Brewing Sake requires workers to take temperature of the ingredients very frequently. mruby/c is a small implementation of Ruby and runs on microcontroller which has less than 64KB RAM. You will see a new Ruby World.

#confreaks #rubyconf2019
Captions: 
	00:00:13,120 --> 00:00:14,120
>> Hello.

00:00:14,120 --> 00:00:15,220
Do you hear me?

00:00:15,220 --> 00:00:16,220
Hello, everybody!

00:00:16,220 --> 00:00:21,590
It is a great honor of having such an opportunity on RubyConf.

00:00:21,590 --> 00:00:28,250
I'm really, really nervous, because I didn't expect such a great hall where I should give

00:00:28,250 --> 00:00:31,730
a talk.

00:00:31,730 --> 00:00:45,850
[ Laughter ] the title of my talk is mRuby/c: Running on less than I should fix that.

00:00:45,850 --> 00:00:53,920
I'm Hasumi, and I live in Matsue city, which is the holy place of Ruby, because Matz lives

00:00:53,920 --> 00:00:55,129
there.

00:00:55,129 --> 00:01:00,109
I love sake and soba and coffee.

00:01:00,109 --> 00:01:02,379
Do you know soba?

00:01:02,379 --> 00:01:03,379
Oh!

00:01:03,379 --> 00:01:08,630
Polish people didn't know soba at all.

00:01:08,630 --> 00:01:11,300
But American people know it.

00:01:11,300 --> 00:01:15,750
There is Monstar lab, which is where I work.

00:01:15,750 --> 00:01:22,150
We have many branchs in the world, and one of them is fuzz.

00:01:22,150 --> 00:01:26,610
They are making shake shack.

00:01:26,610 --> 00:01:30,080
I haven't tried it yet.

00:01:30,080 --> 00:01:33,920
I'm trying it on Friday.

00:01:33,920 --> 00:01:36,110
I think.

00:01:36,110 --> 00:01:41,170
And I usually participate in Matsue.rb.

00:01:41,170 --> 00:01:46,930
This is Matsue castle built in 1611.

00:01:46,930 --> 00:01:49,330
Let's go.

00:01:49,330 --> 00:01:54,100
My subject, chapter 1, introduction.

00:01:54,100 --> 00:02:01,860
Let me explain some rules of what we should know.

00:02:01,860 --> 00:02:06,490
MRuby/c is a language implementation I will talk about today.

00:02:06,490 --> 00:02:13,370
I say mrubyc since slash c is harder for me to pronounce.

00:02:13,370 --> 00:02:20,860
So, in this presentation, I will say mRuby/C. A microcontroler contains a small CPU, memory,

00:02:20,860 --> 00:02:24,560
and small peripherals.

00:02:24,560 --> 00:02:31,549
RTOS stands for real time OS, usually used for microcontroler.

00:02:31,549 --> 00:02:36,959
I didn't use it today, but I will cover it in the talk later.

00:02:36,959 --> 00:02:41,810
The word "task" is almost equivalent to thread in Linux.

00:02:41,810 --> 00:02:45,959
We say task in microcontroller world.

00:02:45,959 --> 00:02:48,340
This is really important.

00:02:48,340 --> 00:02:55,650
Asahi Shuzo is one of the best Sake breweries.

00:02:55,650 --> 00:03:15,120
Shuzo means Sake brewery, and doesn't have anything to do with the super dry beer.

00:03:15,120 --> 00:03:18,610
Let me explain why I use microcontroler.

00:03:18,610 --> 00:03:25,000
Because I didn't use a single board computer like Raspberry Pi for production environment

00:03:25,000 --> 00:03:33,579
or deployment, because I use microcontroller, because it starts immediately right after

00:03:33,579 --> 00:03:34,579
plugged in.

00:03:34,579 --> 00:03:44,049
In my case, end users, brewery workers, they can use it very simply, like home electrical

00:03:44,049 --> 00:03:45,049
appliance.

00:03:45,049 --> 00:03:52,269
The only thing they should do is turn them off and turn them on.

00:03:52,269 --> 00:03:54,269
That's it.

00:03:54,269 --> 00:04:01,980
And microcontroller can run without OS, like Linux or Windows.

00:04:01,980 --> 00:04:11,599
It is called Bare Metal.

00:04:11,599 --> 00:04:16,489
Many malware aims at Linux or Windows.

00:04:16,489 --> 00:04:18,109
That's more.

00:04:18,109 --> 00:04:29,590
This is the most important thing, I think.

00:04:29,590 --> 00:04:30,729
Low energy.

00:04:30,729 --> 00:04:33,520
It's rarely overheated.

00:04:33,520 --> 00:04:36,300
So you have many choices of power supply.

00:04:36,300 --> 00:04:41,770
Things like small batteries or solar cells.

00:04:41,770 --> 00:04:46,449
Microcontroller is also suitable for mass production.

00:04:46,449 --> 00:04:55,900
You can choose appropriate chipset for your application so that you minimize the cost.

00:04:55,900 --> 00:05:01,300
There are so many different models of microcontrollers out there.

00:05:01,300 --> 00:05:04,590
I have introduced two of them.

00:05:04,590 --> 00:05:06,740
First is CYPRESS PSoC5LP.

00:05:06,740 --> 00:05:14,920
I used it for the Sake brewery.

00:05:14,920 --> 00:05:18,060
It has 65kilobytes of RAM.

00:05:18,060 --> 00:05:24,240
It can be represented by 16 bits integer.

00:05:24,240 --> 00:05:27,650
The second one, you may know this.

00:05:27,650 --> 00:05:31,340
ESP32, a very popular one recently.

00:05:31,340 --> 00:05:35,759
I will show you a demonstration with it later.

00:05:35,759 --> 00:05:42,190
And then about my IoT project.

00:05:42,190 --> 00:05:45,409
It is IoT project for Sake brewing.

00:05:45,409 --> 00:05:49,430
I use PSoC5LP for it.

00:05:49,430 --> 00:05:54,430
It was delivered to actual brew work in January 2018.

00:05:54,430 --> 00:06:02,990
The devices post temperature of Sake ingredient in brewing and surrounding temperature and

00:06:02,990 --> 00:06:06,259
humidity to server.

00:06:06,259 --> 00:06:11,110
That data is displayed on a mobile app.

00:06:11,110 --> 00:06:14,479
They are now steaming rice.

00:06:14,479 --> 00:06:22,460
And she is now bringing rice mold up in a thermostat brew.

00:06:22,460 --> 00:06:27,680
The rice can obtain how can I say?

00:06:27,680 --> 00:06:38,680
Natural lactic acid from the air and from the wooden stuff in this way.

00:06:38,680 --> 00:06:52,780
This is my first version of the device.

00:06:52,780 --> 00:07:01,699
It is sensing temperature.

00:07:01,699 --> 00:07:04,150
This is the second version.

00:07:04,150 --> 00:07:09,030
It looks much cooler, really.

00:07:09,030 --> 00:07:14,909
[ Laughter ] And this is the smartphone app.

00:07:14,909 --> 00:07:20,009
Temperature ingredient, which is more than 42 degrees.

00:07:20,009 --> 00:07:30,419
42 degrees is equivalent to approximately 100 degrees Fahrenheit, I think.

00:07:30,419 --> 00:07:38,449
Even though the room is 31.

00:07:38,449 --> 00:07:41,419
It reaches very hot.

00:07:41,419 --> 00:07:46,130
By the way, IoT in field makes you Hurry.

00:07:46,130 --> 00:07:54,389
Please imagine that you have to go back and forth between dark, cold storage cellar and

00:07:54,389 --> 00:07:57,021
humid, very hot rice mold room.

00:07:57,021 --> 00:08:00,500
The thermostat room.

00:08:00,500 --> 00:08:08,060
And there are brewery workers running around and shout around, because brewing Sake is

00:08:08,060 --> 00:08:12,590
a fight against time.

00:08:12,590 --> 00:08:19,860
What if you have to mend your firmware with your small laptop in ten minutes on site?

00:08:19,860 --> 00:08:21,479
Imagine!

00:08:21,479 --> 00:08:24,699
You will thank Ruby's descriptiveness and agility.

00:08:24,699 --> 00:08:31,949
You will figure out after listening to my talk.

00:08:31,949 --> 00:08:38,350
I think...

00:08:38,350 --> 00:08:47,029
And this is the first and the only Sake labeled with Ruby, because this Sake was brewed with

00:08:47,029 --> 00:08:50,339
Ruby.

00:08:50,339 --> 00:08:57,050
[ Applause ] I'm not 100% sure, but you will be able to

00:08:57,050 --> 00:09:03,690
drink this if you come to Ruby Kaigi2020.

00:09:03,690 --> 00:09:04,690
Is that correct?

00:09:04,690 --> 00:09:12,339
I hope you all come to Japan next year!

00:09:12,339 --> 00:09:14,290
In April!

00:09:14,290 --> 00:09:19,440
This is the best season to visit Japan.

00:09:19,440 --> 00:09:24,370
I'll show you a demo about CO2 concentration.

00:09:24,370 --> 00:09:31,370
CO2 concentration, 400ppm is atmospheric level.

00:09:31,370 --> 00:09:38,440
At 1000ppm, your programming speed decreases.

00:09:38,440 --> 00:09:49,430
And tomatoes require CO2 because of what photosynthesis.

00:09:49,430 --> 00:09:55,980
And more than 2000, you feel sleepiness and probably headache.

00:09:55,980 --> 00:10:03,480
And you are no longer active if it's 40, 000.

00:10:03,480 --> 00:10:08,200
Please look at the screen.

00:10:08,200 --> 00:10:12,310
Here.

00:10:12,310 --> 00:10:17,340
This is CO2 sensor, and this reads 32.

00:10:17,340 --> 00:10:30,070
Now it reports CO2 value for us.

00:10:30,070 --> 00:10:35,130
No...

00:10:35,130 --> 00:10:40,190
1,294ppm.

00:10:40,190 --> 00:10:44,720
And my device is taking currently CO2 concentration.

00:10:44,720 --> 00:10:48,769
CO2 may increase because of your breathing.

00:10:48,769 --> 00:10:57,339
So, I'll prove that it is due to CO2 if you fell asleep while I was speaking.

00:10:57,339 --> 00:11:03,360
[ Laughter ] I promise you.

00:11:03,360 --> 00:11:09,579
By the way, there are so many lovely bugaboos in IoT development.

00:11:09,579 --> 00:11:18,780
Things like peripheral equipments, circuit, wiring problem, housing problem, water problem,

00:11:18,780 --> 00:11:22,110
and a printed circuit board is called a PCB.

00:11:22,110 --> 00:11:23,949
And soldering.

00:11:23,949 --> 00:11:28,810
And writing firmware with C or mRuby or micro Python.

00:11:28,810 --> 00:11:30,230
I don't know.

00:11:30,230 --> 00:11:32,480
And network problems.

00:11:32,480 --> 00:11:36,940
I encountered several of them today.

00:11:36,940 --> 00:11:39,820
This is peripheral equipments.

00:11:39,820 --> 00:11:47,620
It is very important to check the part each part before writing application code.

00:11:47,620 --> 00:11:53,079
Equipments like sensor or communication module work as its spec sheets?

00:11:53,079 --> 00:11:58,720
And whether or not the equipment is broken.

00:11:58,720 --> 00:12:00,360
Combining parts is unrevertible.

00:12:00,360 --> 00:12:03,950
We don't have Git for hardware.

00:12:03,950 --> 00:12:07,279
So, this is very important to check this.

00:12:07,279 --> 00:12:18,790
So I often make such stuff for just experiment with Raspberry Pi and CRuby.

00:12:18,790 --> 00:12:20,990
This is CRuby, not mRuby.

00:12:20,990 --> 00:12:29,800
This is called for creating a shell to communicate with new serial protocol.

00:12:29,800 --> 00:12:40,310
Using such Ruby has rubyserial gem.

00:12:40,310 --> 00:12:46,050
And we say something to the module.

00:12:46,050 --> 00:12:51,170
And it responds with something.

00:12:51,170 --> 00:12:52,860
This is the yacht come.

00:12:52,860 --> 00:12:57,829
If I say AT, it assumes the command.

00:12:57,829 --> 00:13:00,840
If approximate I say AT, it replies okay.

00:13:00,840 --> 00:13:08,010
If I say AT+CIMI, it replies with a unique identifier.

00:13:08,010 --> 00:13:14,970
And if I say command, which doesn't exist, it reports error.

00:13:14,970 --> 00:13:23,410
And this is soldering, the most, biggest bugaboo.

00:13:23,410 --> 00:13:29,779
This is surface mounting part, which has 0.8 millimeter pins.

00:13:29,779 --> 00:13:40,589
It often works even if you leave a pin unsoldered on surface mounting, because the pin touches

00:13:40,589 --> 00:13:42,230
on the circuit's plate.

00:13:42,230 --> 00:13:47,920
Then it will come not to work one day.

00:13:47,920 --> 00:13:49,509
This is my actual case.

00:13:49,509 --> 00:13:54,639
Discovering this kind of bug is much more difficult than software bug.

00:13:54,639 --> 00:14:04,569
I remember my teacher said, "All the cause of failure, it is impatience."

00:14:04,569 --> 00:14:11,920
Chapter 2, mRuby/C. Before that, what is mRuby?

00:14:11,920 --> 00:14:16,520
Before mRuby/C. Let's review mRuby.

00:14:16,520 --> 00:14:23,290
MRuby is another implementation of Ruby for general embedded usage.

00:14:23,290 --> 00:14:37,970
It is easily combined with system programming like C, C++, rust, Go.

00:14:37,970 --> 00:14:43,639
So, what is mRuby/C?

00:14:43,639 --> 00:14:50,020
MRuby/C is yet another implementation of mRuby.

00:14:50,020 --> 00:14:56,389
Slash C symbolizes compact, concurrent, and capability.

00:14:56,389 --> 00:15:02,480
It is especially dedicated to one chip microcontroller.

00:15:02,480 --> 00:15:11,970
This is a comparison between mRuby and mRuby/C from the viewpoint of processing stack.

00:15:11,970 --> 00:15:25,860
This bytecode is the same, literally the same.

00:15:25,860 --> 00:15:32,110
Because we compile it by mRuby/C, mRuby compiler, which Matz makes.

00:15:32,110 --> 00:15:38,579
And VM executes the bytecode as a task.

00:15:38,579 --> 00:15:44,230
And on the other hand, mRuby/C has another VM, another implementation of VM.

00:15:44,230 --> 00:15:53,199
This VM executes the bytecode as a task.

00:15:53,199 --> 00:15:57,779
Bytecode is kind of intermediate representation.

00:15:57,779 --> 00:16:01,959
MRuby bytecode is designed for mRuby VM.

00:16:01,959 --> 00:16:09,430
MRuby VM dynamically processes.

00:16:09,430 --> 00:16:13,480
This is how it looks.

00:16:13,480 --> 00:16:19,509
If you compile for "Hello World!"

00:16:19,509 --> 00:16:24,800
You can get this bytecode.

00:16:24,800 --> 00:16:30,089
This is hexadecimal dump.

00:16:30,089 --> 00:16:39,769
It looks like this.

00:16:39,769 --> 00:16:45,889
If you use mRuby, not mRuby/C, but if you use mRuby on microcontroller, you should use

00:16:45,889 --> 00:16:57,300
RTOS, to realize multitasking, because RTOS manages multiple VMs.

00:16:57,300 --> 00:17:10,160
MRuby/C on microcontroler has its on mechanism, and it's rrt0.

00:17:10,160 --> 00:17:14,730
Rrt0 means ruby runtime 0.

00:17:14,730 --> 00:17:18,770
But I don't know what exactly means zero.

00:17:18,770 --> 00:17:25,470
I think it's traditional naming.

00:17:25,470 --> 00:17:33,780
This is a comparison table between mRuby and mRuby/C. MRuby/c is three years behind from

00:17:33,780 --> 00:17:35,420
mRuby.

00:17:35,420 --> 00:17:49,340
MRuby/C's RAM consumption is one fifth of mRuby, in general.

00:17:49,340 --> 00:17:54,929
And mRuby/C's VM is much smaller than mRuby's.

00:17:54,929 --> 00:17:59,880
That's why mRuby/C runs on smaller RAM.

00:17:59,880 --> 00:18:09,880
MRuby/C has less functionality than mRuby, naturally than CRuby.

00:18:09,880 --> 00:18:13,850
So how less?

00:18:13,850 --> 00:18:23,340
For example, mRuby/c doesn't have module, therefore there is no kernel module.

00:18:23,340 --> 00:18:30,190
So, you must wonder how can you put that?

00:18:30,190 --> 00:18:34,210
In mRuby/c, put is implemented in object class.

00:18:34,210 --> 00:18:45,630
It doesn't have send or evalor method or test point or blah blah blah.

00:18:45,630 --> 00:18:50,659
This is actual full list of mRuby/c classes.

00:18:50,659 --> 00:18:58,380
This is very few, right?

00:18:58,380 --> 00:19:10,500
[ Laughter ] VM is the exclusive one for mRuby/C. But in

00:19:10,500 --> 00:19:16,240
spite of the fact, it's no problem in practical usage of microcontroller.

00:19:16,240 --> 00:19:21,110
As far as IoT goes, mRuby/C is enough Ruby.

00:19:21,110 --> 00:19:30,180
And we can fully develop firmwares with these features of mRuby/c.

00:19:30,180 --> 00:19:42,790
This is just basics to illustrate and explain the basics of mRuby/c.

00:19:42,790 --> 00:19:49,592
We write main.c, and rb files.

00:19:49,592 --> 00:19:56,980
And every compiler compiles every file into c files.

00:19:56,980 --> 00:20:00,130
So, we write main.c and rb file.

00:20:00,130 --> 00:20:10,500
We don't write src and task_1.c. we don't write this.

00:20:10,500 --> 00:20:17,710
And the main.c includes bytecode like this.

00:20:17,710 --> 00:20:29,270
And we can specify shape size, which mRuby VM uses in the next line.

00:20:29,270 --> 00:20:33,559
And mRuby/C there is the init function.

00:20:33,559 --> 00:20:38,350
Allocates memory, as we mentioned before.

00:20:38,350 --> 00:20:46,760
And then we use this function twice to make tasks.

00:20:46,760 --> 00:20:51,130
This is the preparation for multitasking.

00:20:51,130 --> 00:21:04,900
And finally, mRuby/cmrbc_run function this is how you use it.

00:21:04,900 --> 00:21:11,530
We can easily run multiple VMs with concurrency feature of rrt0.

00:21:11,530 --> 00:21:20,110
You might be disappointed to know that you have to write C. Main.c. we have to write

00:21:20,110 --> 00:21:24,380
main.c, but it is almost boilerplate code, so no worry.

00:21:24,380 --> 00:21:26,570
You can do it.

00:21:26,570 --> 00:21:30,549
I can do it.

00:21:30,549 --> 00:21:32,800
Chapter 3.

00:21:32,800 --> 00:21:38,380
Application code and tools.

00:21:38,380 --> 00:21:41,690
This is the repository of today's demo.

00:21:41,690 --> 00:21:50,409
Just check it later if you have any concern.

00:21:50,409 --> 00:21:52,930
This is how it looks.

00:21:52,930 --> 00:21:59,440
The actual code where I am now demonstrating.

00:21:59,440 --> 00:22:04,010
It has two infinite loops.

00:22:04,010 --> 00:22:08,260
And it has three models.

00:22:08,260 --> 00:22:11,870
You can imagine them, what are them?

00:22:11,870 --> 00:22:13,890
From the name, right?

00:22:13,890 --> 00:22:22,529
CO2 and LED and thermistor, which is the sense of temperature.

00:22:22,529 --> 00:22:26,040
This is the primary infinite loop.

00:22:26,040 --> 00:22:35,130
It initializes three models like this.

00:22:35,130 --> 00:22:40,450
I write Co2 and thermistor as global variables.

00:22:40,450 --> 00:22:54,179
Because another thread, another task uses it.

00:22:54,179 --> 00:23:04,330
And in that while true loop, it reports when CO2 is above a certain value, 2000 in this

00:23:04,330 --> 00:23:13,270
case, by led flashing inside an infinite loop.

00:23:13,270 --> 00:23:21,000
But how does led #trun_on work?

00:23:21,000 --> 00:23:23,580
Looking back.

00:23:23,580 --> 00:23:30,020
How does led #turn_on work?

00:23:30,020 --> 00:23:35,830
LED model is now pretty simple.

00:23:35,830 --> 00:23:41,440
Initialize nestled and in a pin.

00:23:41,440 --> 00:23:47,630
And turn_on method set that pin high level.

00:23:47,630 --> 00:23:52,990
And turn_off method set low.

00:23:52,990 --> 00:23:54,279
That's it.

00:23:54,279 --> 00:23:59,130
But it's doubtful, right?

00:23:59,130 --> 00:24:02,779
Why so simple.

00:24:02,779 --> 00:24:08,260
If you think the secret is in the code, you are correct.

00:24:08,260 --> 00:24:19,990
The Ruby method for the c function.

00:24:19,990 --> 00:24:26,190
If you are familiar with mri, you can see the same thing.

00:24:26,190 --> 00:24:31,309
We can define Ruby method by mrbc_define_method function.

00:24:31,309 --> 00:24:39,240
And in this case, this method defines the object class.

00:24:39,240 --> 00:24:47,899
We can define methods in any class in this way.

00:24:47,899 --> 00:24:53,020
The model is rather complicated, but basically the same.

00:24:53,020 --> 00:24:59,220
The model requires us to write this form of command.

00:24:59,220 --> 00:25:02,740
This form.

00:25:02,740 --> 00:25:07,700
According to the spec sheet.

00:25:07,700 --> 00:25:20,049
And after writing from microcontroller and CO2 sensor, there is a write command.

00:25:20,049 --> 00:25:22,890
Where where where where?

00:25:22,890 --> 00:25:23,890
uart_write_bytes.

00:25:23,890 --> 00:25:34,380
And after that we can retrieve the read_bytes in this lang.

00:25:34,380 --> 00:25:40,030
And here I made an array object.

00:25:40,030 --> 00:25:47,350
This is mRuby/c's object, which has nine things.

00:25:47,350 --> 00:26:04,850
And in full loop, this convert in the C language array into mRuby/C array and return it.

00:26:04,850 --> 00:26:10,600
This is how get_Co2 value works.

00:26:10,600 --> 00:26:26,570
On Ruby's side, CO2 model calculates the concentration.

00:26:26,570 --> 00:26:41,779
This condition is checking with the CO2 sensor, if it is working or not.

00:26:41,779 --> 00:26:46,640
This is just a trivial tip to reduce memory usage.

00:26:46,640 --> 00:26:51,250
C function can return string object instead of array.

00:26:51,250 --> 00:27:00,690
I use array object, but you can use string object, because mrbc_array_new allocates larger

00:27:00,690 --> 00:27:10,490
memory than mrbc_string, so you can use string object instead of array object if memory becomes

00:27:10,490 --> 00:27:11,880
short.

00:27:11,880 --> 00:27:14,200
This is very natural.

00:27:14,200 --> 00:27:26,440
You can remember string of C is just an array of character, so we can use string for this.

00:27:26,440 --> 00:27:31,370
And this Ruby model works as well.

00:27:31,370 --> 00:27:34,909
Because this is Ruby.

00:27:34,909 --> 00:27:38,100
Right?

00:27:38,100 --> 00:27:45,890
And the role of the secondary loop is sending data to server.

00:27:45,890 --> 00:27:51,350
Concatenating string object.

00:27:51,350 --> 00:27:59,470
It's much, much easier than C. As you know.

00:27:59,470 --> 00:28:00,470
Thank you, Matz.

00:28:00,470 --> 00:28:09,210
[ Laughter ] So let me introduce several tools for developing

00:28:09,210 --> 00:28:12,169
mRuby/c.

00:28:12,169 --> 00:28:18,789
I myself made these three tools in order to develop mRuby/c application smart.

00:28:18,789 --> 00:28:26,860
In other words, I'm trying to make it Rubyish.

00:28:26,860 --> 00:28:35,549
Rubyish means, in my humble opinion, based on UNIX or Linux and using command line and

00:28:35,549 --> 00:28:43,309
no IDE as far as possible.

00:28:43,309 --> 00:28:54,450
You can't use Mac OS in general on the CYPRESS piece.

00:28:54,450 --> 00:29:03,159
In short, taking full advantage of our laptop and Ruby world.

00:29:03,159 --> 00:29:07,429
First thing is mRuby c utils.

00:29:07,429 --> 00:29:11,809
This is one binary tool made with mruby.

00:29:11,809 --> 00:29:15,630
It helps to install boilerplate of application.

00:29:15,630 --> 00:29:25,820
This is a key feature, but I don't differ on that.

00:29:25,820 --> 00:29:32,679
Subcommands classes shows all the class lists of mrubyc.

00:29:32,679 --> 00:29:45,029
And subcommand methods shows all of the methods of specified class.

00:29:45,029 --> 00:29:48,929
Array in this case.

00:29:48,929 --> 00:29:50,970
Next, mrubyc test.

00:29:50,970 --> 00:29:54,159
This is a unit testing framework.

00:29:54,159 --> 00:30:02,990
This is a RubyGem implemented with CRuby.

00:30:02,990 --> 00:30:13,140
It is now official testing tool of mrubyc dev team.

00:30:13,140 --> 00:30:17,040
Mrubyc test works like this.

00:30:17,040 --> 00:30:26,809
Gathers information from app code and test code and internally generates stub and mock

00:30:26,809 --> 00:30:28,669
methods.

00:30:28,669 --> 00:30:32,130
And it makes all in one script test.rb.

00:30:32,130 --> 00:30:42,039
Then mruby/c compiles it into bytecode.

00:30:42,039 --> 00:30:53,350
And c compiler, for example, gcc builds bytecode to test executable.

00:30:53,350 --> 00:31:01,650
And if you run this, it reports the result.

00:31:01,650 --> 00:31:05,360
The lower side is internal things.

00:31:05,360 --> 00:31:12,480
So you can use it just for normal ruby testing framework.

00:31:12,480 --> 00:31:14,610
And this is the third one.

00:31:14,610 --> 00:31:16,250
Mrubyc debugger.

00:31:16,250 --> 00:31:31,500
It is a debugger for infinite loop.

00:31:31,500 --> 00:31:34,250
This is an animation GIF.

00:31:34,250 --> 00:31:42,130
There are two tasks coordinating each other.

00:31:42,130 --> 00:31:52,139
And we can you can visually see the application flows such as global variables and between

00:31:52,139 --> 00:31:53,919
tasks and mutex.

00:31:53,919 --> 00:31:57,330
I can't write that.

00:31:57,330 --> 00:32:00,700
Mutex which controls the exclusive processing.

00:32:00,700 --> 00:32:04,750
Moreover, you can make break points.

00:32:04,750 --> 00:32:10,429
Break points like this.

00:32:10,429 --> 00:32:17,730
Get local variables in the bottom of the screen.

00:32:17,730 --> 00:32:21,929
This is what I'm making for mruby c.

00:32:21,929 --> 00:32:26,480
Go back to CO2 demo.

00:32:26,480 --> 00:32:39,090
How about the CO2?

00:32:39,090 --> 00:32:41,039
It is... 1,231ppm.

00:32:41,039 --> 00:32:42,039
Hmmm.

00:32:42,039 --> 00:32:43,960
So, so.

00:32:43,960 --> 00:32:52,720
But it's not bad ventilation facility, this room has.

00:32:52,720 --> 00:32:53,720
Conclusion.

00:32:53,720 --> 00:32:58,559
You should refresh the air.

00:32:58,559 --> 00:33:03,419
Thank you for paying attention.

00:33:03,419 --> 00:33:07,309
Thank you so much.

00:33:07,309 --> 00:33:08,289

YouTube URL: https://www.youtube.com/watch?v=1VFPSHs3WvI


