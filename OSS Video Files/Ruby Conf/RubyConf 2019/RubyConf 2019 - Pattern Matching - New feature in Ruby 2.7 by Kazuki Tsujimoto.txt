Title: RubyConf 2019 - Pattern Matching - New feature in Ruby 2.7 by Kazuki Tsujimoto
Publication date: 2019-11-27
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Pattern Matching - New feature in Ruby 2.7 by Kazuki Tsujimoto

Ruby core team plans to introduce pattern matching as an experimental feature in Ruby 2.7. In this presentation, we will talk about the current proposed syntax and its design policy.

#confreaks #rubyconf2019
Captions: 
	00:00:12,370 --> 00:00:29,439
>> Okay. So, I'm ready to get started. My name is Tsujimoto, and I am here to talk 

00:00:29,439 --> 00:00:51,440
to you today about pattern matching. I would like to give you an overview of what I would

00:00:51,440 --> 00:00:57,550
like to communicate in this session. Pattern matching has already been released

00:00:57,550 --> 00:01:12,410
in 2.7, but it is still an experimental feature. We are trying to collect information on the

00:01:12,410 --> 00:01:22,460
real‑use cases so that we try to provide more convenient syntax.

00:01:22,460 --> 00:01:33,890
I would appreciate it if you would try it and give us some feedback. This slide shows

00:01:33,890 --> 00:01:42,030
my agenda for today. First, I would like to define pattern matching. What is it? What

00:01:42,030 --> 00:01:47,440
is its function? Next, I would like to talk about specifications.

00:01:47,440 --> 00:01:55,580
Finally, I would like to talk about the thought behind the design.

00:01:55,580 --> 00:02:05,530
Okay. So, what is pattern matching? Although it is difficult to define pattern matching

00:02:05,530 --> 00:02:17,599
in a few words, the slide shows a good quote sentence taken from Haskell's tutorial. To

00:02:17,599 --> 00:02:28,189
summarize it for Rubyists, it's a combination of case/when and multiple assignments, I think.

00:02:28,189 --> 00:02:37,709
So we extend case expressions for pattern matching in current specification. So, we

00:02:37,709 --> 00:02:50,069
use case/in instead of case/when. So, in this case, there is a variable in the condition.

00:02:50,069 --> 00:02:59,890
So it is similar to multiple assignments, I think.

00:02:59,890 --> 00:03:05,200
Of course, there is a difference between pattern matching and multiple assignments. Pattern

00:03:05,200 --> 00:03:17,129
matching checks the object structure. So in this case, the pattern requires array has

00:03:17,129 --> 00:03:28,870
only one element. So, this pattern fails and we will move on to the next pattern. This

00:03:28,870 --> 00:03:35,129
pattern match is successful, because the pattern object has the same structure. What we have

00:03:35,129 --> 00:03:40,249
to pay attention to here is not just using the

00:03:40,249 --> 00:03:51,780
variable value like 0 or 2. So, you check the structure and assign its value to a variable

00:03:51,780 --> 00:04:00,880
at the same time. It is a convenient feature of pattern matching.

00:04:00,880 --> 00:04:11,180
Pattern matching also supports the Hash. So, in this case, this pattern has two keys.

00:04:11,180 --> 00:04:19,170
One is key a, and it would have to be zero. And x would have to be one.

00:04:19,170 --> 00:04:26,490
But there isn't an x, so this pattern doesn't match.

00:04:26,490 --> 00:04:36,150
And in this case, a would have to be zero and b would have to be var, so this pattern

00:04:36,150 --> 00:04:47,230
matches and var is set to 1. This is a rough summary of pattern matching.

00:04:47,230 --> 00:04:55,820
Next I would like to show real use cases of pattern matching. This is an example of a

00:04:55,820 --> 00:04:59,880
situation that may arise when you handle JSON data.

00:04:59,880 --> 00:05:09,770
If you look at the upper right of the slide, there is information about a person.

00:05:09,770 --> 00:05:16,580
There is also a code printing the age if the condition is met.

00:05:16,580 --> 00:05:26,479
The condition is the person, name being Alice, and she has one child.

00:05:26,479 --> 00:05:34,931
And his name is Bob. You get the age and print it. So, the condition

00:05:34,931 --> 00:05:45,379
I have described can be written easily. So, it is very beneficial aspect of pattern matching.

00:05:45,379 --> 00:05:58,750
Now, I would like to talk about specifications. I described pattern matches uses case/in for

00:05:58,750 --> 00:06:03,509
the syntax. And the patterns are run in sequence until

00:06:03,509 --> 00:06:12,080
the first one finds a match. And if no pattern matches, the else clause

00:06:12,080 --> 00:06:20,610
is executed. And if no pattern matches emerge, and there is no else clause, the no matching

00:06:20,610 --> 00:06:32,849
pattern error exception is raised. It is possible to specify additional if and

00:06:32,849 --> 00:06:42,400
unless to specify the additional condition. It is called a guard. The guard expression

00:06:42,400 --> 00:06:52,090
is evaluated if the preceding pattern matches. So, in this case, the pattern takes two elements,

00:06:52,090 --> 00:07:03,069
a and b, and these two values should be different. So, this kind of complex condition can be used

00:07:03,069 --> 00:07:14,180
when the guard is used. And previous version of Ruby 2.7, single line

00:07:14,180 --> 00:07:21,960
pattern matching has been introduced. I think it is syntactic sugar when you only

00:07:21,960 --> 00:07:33,180
want to write one condition. Okay, so next, I would like to explain about

00:07:33,180 --> 00:07:38,419
several patterns. Ruby's pattern matching has six different

00:07:38,419 --> 00:07:47,020
patterns listed here. So, I would like to explain each of them one by one.

00:07:47,020 --> 00:07:55,800
The first one is a value pattern. A value pattern matches the pattern and object

00:07:55,800 --> 00:08:05,889
are compared with using triple equal method. It is very much like case/when. So, there

00:08:05,889 --> 00:08:15,470
is three different patterns built, and the overall pattern will be matched.

00:08:15,470 --> 00:08:24,659
Next is the variable pattern. Variable pattern matches any value and binds

00:08:24,659 --> 00:08:32,479
the variable name to that value. So, these patterns are a set to zero.

00:08:32,479 --> 00:08:44,320
Variable pattern is normally used to refer the value to the latter, but the variable

00:08:44,320 --> 00:08:53,630
pattern can be used to check object structure. To do that, you may need to drop unnecessary

00:08:53,630 --> 00:09:00,490
values. And you can use the underscore to drop the

00:09:00,490 --> 00:09:06,760
values. Since the underscore is also used to drop values for multiple

00:09:06,760 --> 00:09:15,639
assignments, so this feature can be accepted easily. So, in this case, the pattern requires

00:09:15,639 --> 00:09:22,690
the given object has just two items. It doesn't care about what the value the object

00:09:22,690 --> 00:09:33,290
has. When we talk about variable patterns, there

00:09:33,290 --> 00:09:42,579
is one thing that we need to consider carefully. That is situations when you have an outer

00:09:42,579 --> 00:09:54,800
variable with the same name. In this case, first is a set to zero.

00:09:54,800 --> 00:10:06,170
But in pattern, it will be just ignored and a set to 1.

00:10:06,170 --> 00:10:16,579
So this behavior is sometimes acceptable, but if you want to perform pattern matching

00:10:16,579 --> 00:10:26,600
against existing variable value, then you can use caret at the head of a variable. So,

00:10:26,600 --> 00:10:32,970
if you have been using Elixir, you are familiar with that.

00:10:32,970 --> 00:10:42,700
This function is taken from Elixir's pin operator. So, in this case, the pattern includes caret a,

00:10:42,700 --> 00:10:49,080
which means 0. The pattern doesn't match, so no matching

00:10:49,080 --> 00:11:00,540
pattern error exception is raised. And the next pattern is alternative pattern.

00:11:00,540 --> 00:11:03,890
This pattern matches if any of the patterns matches.

00:11:03,890 --> 00:11:13,620
Basically it is pretty straightforward. Next is our AS pattern.

00:11:13,620 --> 00:11:21,060
The AS pattern matches the object to the pattern on the left side of the hash rocket.

00:11:21,060 --> 00:11:30,220
And if pattern matches, the object is assigned to the variable on the right side of the hash

00:11:30,220 --> 00:11:34,529
rocket. I think it is similar to rescue statement.

00:11:34,529 --> 00:11:43,079
The rescue statement also checks exception class and assigns the exception object to

00:11:43,079 --> 00:11:49,110
the variable. In this case, zero is an instance of the integer. So,

00:11:49,110 --> 00:12:02,720
the pattern matches and a is set to zero. The AS pattern is becoming increasingly more

00:12:02,720 --> 00:12:13,269
convenient as the object becomes more complex. So, in this case, you have a nested array for

00:12:13,269 --> 00:12:27,720
matching, which you can bind along the way and refer to that vallater. So, it is a convenient

00:12:27,720 --> 00:12:30,130
example.

00:12:30,130 --> 00:12:36,279
Next is array pattern. Array pattern is a bit different from what

00:12:36,279 --> 00:12:42,470
you might expect. That is because the array pattern is not separate

00:12:42,470 --> 00:12:55,500
from array object. So, let me explain what matching is done by array pattern, step by

00:12:55,500 --> 00:13:01,610
step. First, this pattern can be specified constant

00:13:01,610 --> 00:13:11,230
in the syntax and the pattern and the constant compared with triple equal method.

00:13:11,230 --> 00:13:23,850
Normally a constant stores an object. So, this means the given object is an instance

00:13:23,850 --> 00:13:33,630
specified across. And if it returns true, check if the object

00:13:33,630 --> 00:13:40,600
has a deconstruct method that returns an array. If that object has a deconstruct method, then

00:13:40,600 --> 00:13:55,980
its return value will be like the third pattern and the pattern matching is done.

00:13:55,980 --> 00:14:08,839
There are three types of syntax for this. First is in terms of using bracket or parentheses.

00:14:08,839 --> 00:14:17,580
You can use either one. You can see it works like array return.

00:14:17,580 --> 00:14:28,579
This is syntactic sugar for first and second, that specifies a basic object. So, that means

00:14:28,579 --> 00:14:38,329
this pattern matches any object, not only for array objects.

00:14:38,329 --> 00:14:51,020
So let me show the example of array pattern. And array pattern is array object.

00:14:51,020 --> 00:14:55,220
In case of array, the deconstruct method returns the array itself.

00:14:55,220 --> 00:15:04,160
Actually, this deconstruct method is a built‑in method, so you don't need to define it yourself.

00:15:04,160 --> 00:15:16,149
There are four patterns below. And the patterns have match success.

00:15:16,149 --> 00:15:26,959
Okay. So, let me explain what happens in the first pattern.

00:15:26,959 --> 00:15:34,160
This pattern the array class as a constant. So, 0, 1, 2, will be called.

00:15:34,160 --> 00:15:48,610
And they will want to return deconstruct method to 0, 1, 2. So, its return value will be

00:15:48,610 --> 00:16:04,190
here. So, the pattern matches. And the second, third, and fourth patterns ‑‑

00:16:04,190 --> 00:16:19,339
sorry ‑‑ second, third, and fourth patterns are where constant becomes object or basicObject.

00:16:19,339 --> 00:16:28,329
And in the first pattern, you can write these patterns without brackets. So, if we want

00:16:28,329 --> 00:16:42,540
to reduce typing, it is okay to omit brackets. Next example is array pattern with things

00:16:42,540 --> 00:16:46,370
other than array objects. Sorry.

00:16:46,370 --> 00:17:00,480
A typical use case of that would be, I think, struct. So, this is an example of a struct.

00:17:00,480 --> 00:17:07,850
Deconstruct method for struct is a defined as alias to to_a.

00:17:07,850 --> 00:17:17,780
When defined like that, the constructor method return value of the method is equal to the

00:17:17,780 --> 00:17:22,789
argument for the method. So, it is convenient for pattern matching.

00:17:22,789 --> 00:17:35,910
For example, I define colored object, and it takes three arguments, r, g, b, which will

00:17:35,910 --> 00:17:43,230
be used to make our object. And if you create color object in this manner,

00:17:43,230 --> 00:17:57,040
the deconstruct method returns 0, 10, 20. If you use this to receive the color object

00:17:57,040 --> 00:18:03,440
and try to identify the resulting color, you will get this code.

00:18:03,440 --> 00:18:12,470
In the first pattern, r, g, b value is 0, 0, 0. So, that would be black.

00:18:12,470 --> 00:18:24,020
And in the second pat certain a case where r is 255, so it would be red. So, I think

00:18:24,020 --> 00:18:33,150
it is very easy to understand. Next is a hash pattern.

00:18:33,150 --> 00:18:43,040
This is a hash version of the array pattern.

00:18:43,040 --> 00:18:46,561
The difference ‑‑ the main difference between hash pattern and array pattern is

00:18:46,561 --> 00:18:53,530
in array pattern, the deconstruct method is used to deconstruct object.

00:18:53,530 --> 00:19:02,610
But for hash pattern, deconstruct_keys method is used to deconstruct the object.

00:19:02,610 --> 00:19:14,850
And there are three types of hash pattern. It is similar to array pattern.

00:19:14,850 --> 00:19:20,240
And this is an example of a hash pattern with hash object.

00:19:20,240 --> 00:19:27,700
And the constructor_keys for hash returns is to return hash itself.

00:19:27,700 --> 00:19:40,320
Like array on the deconstruct method. But deconstruct_keys takes one element, keys.

00:19:40,320 --> 00:19:47,950
This element is used in other methods. So, I would like to explain about the iterator.

00:19:47,950 --> 00:19:56,990
And there are four patterns built. If you can understand array pattern, you can

00:19:56,990 --> 00:20:02,260
read this pattern result in any program, I think.

00:20:02,260 --> 00:20:10,080
But the second pattern needs some explanation, I think.

00:20:10,080 --> 00:20:19,390
This pattern has only one key, a, but the object has two keys, a and b.

00:20:19,390 --> 00:20:31,020
But this pattern, hash pattern requires a pattern is a subset of a specified object.

00:20:31,020 --> 00:20:42,160
And in this pattern, it includes rest variable. It is similar to the rest keyword arguments,

00:20:42,160 --> 00:20:55,580
so rest will be b: 1, that is a reminder of matching.

00:20:55,580 --> 00:21:03,560
And the rest of the pattern is specified as a rest keyword.

00:21:03,560 --> 00:21:14,620
That means a reminder for matching should be empty. So, this pattern will fail.

00:21:14,620 --> 00:21:21,590
In hash pattern, you can omit the braces, too.

00:21:21,590 --> 00:21:28,390
And the hash pattern provides the syntactic sugar that is just writing the key.

00:21:28,390 --> 00:21:35,210
It is similar to the required keyword argument. So, in this case, a is set to zero and b is set

00:21:35,210 --> 00:21:45,610
to 1. Okay. So, I will explain about keys argument

00:21:45,610 --> 00:21:53,490
for deconstruct_keys. First, let's forget about keys and think about

00:21:53,490 --> 00:21:58,500
implementing deconstruct_keys for time class object.

00:21:58,500 --> 00:22:08,190
I think it returns a hash that includes the year or month or others, which is elements

00:22:08,190 --> 00:22:16,390
of time class. In Ruby 2.6, there are as many ‑‑ about

00:22:16,390 --> 00:22:30,669
40 items for such elements. But in contrast, there is a pattern. And this

00:22:30,669 --> 00:22:40,110
pattern specifies only the year. So, pattern adjustment is year, but it returns 40 items

00:22:40,110 --> 00:22:54,429
hashed. So, it is very inefficient, I think. So to improve that, keys refer to an array

00:22:54,429 --> 00:23:05,450
containing the keys specified in the pattern. So, if we use that, we can implement the deconstruct_keys

00:23:05,450 --> 00:23:24,910
that returns a hash only includes that keys. We should note that there is a rest keyword

00:23:24,910 --> 00:23:33,549
rest variable in the pattern. Nil is passed instead. So, in such case,

00:23:33,549 --> 00:23:50,120
you must return all key value pairs. So, let's review the improved version of the keys.

00:23:50,120 --> 00:23:58,140
First, VALID_KEYS is defined. And then if keys is an array, extract valid

00:23:58,140 --> 00:24:08,549
keys from keys element and create a hash with keys.

00:24:08,549 --> 00:24:25,960
If keys is new, return hash object. So if pattern specifies only year, keys argument

00:24:25,960 --> 00:24:35,610
is just includes year and return value of the deconstruct_keys is just includes year. So,

00:24:35,610 --> 00:24:43,870
it is extremely, extremely effective. However, the implementation is rather complex. So,

00:24:43,870 --> 00:24:58,320
there is a tradeoff in terms of complexity and performance. So, you should have to ‑‑

00:24:58,320 --> 00:25:13,659
you should be care about ‑‑ you very need to be use keys element.

00:25:13,659 --> 00:25:17,860
Okay. So, next I would like to talk about design.

00:25:17,860 --> 00:25:30,820
So what policies were used by designing pattern matching? First is compatibility.

00:25:30,820 --> 00:25:40,220
I think compatibility is very important. And so what effects will be introduced by

00:25:40,220 --> 00:25:48,200
pattern matching? I can think of two items. First one is the syntax, because it introduces

00:25:48,200 --> 00:25:55,490
case/in, and the other one is the namespace, because there is a new exception for us NoMatchingPatternError,

00:25:55,490 --> 00:26:09,340
and new methods: The 'deconstruct', 'deconstruct_keys'. So we should be careful about their effects. So,

00:26:09,340 --> 00:26:18,820
regarding syntax, we are not going to define new reserved words. So, if we can define

00:26:18,820 --> 00:26:28,090
pattern matching within the existing keywords, there is going to be 100%compatibility, which

00:26:28,090 --> 00:26:37,590
is what I always aim for. Also, however, it will be lost if we introduce

00:26:37,590 --> 00:26:45,510
new keyword. For example, if we introduce new match expression,

00:26:45,510 --> 00:26:56,500
if user uses match like this code, this code will be broken. So, we have no choice but

00:26:56,500 --> 00:27:08,180
to extend the case expression. So the next question is what should we use

00:27:08,180 --> 00:27:16,289
instead of the when keyword? This keyword has a ‑‑ first of all it should be suitable

00:27:16,289 --> 00:27:25,710
for pattern matching. And second is it must not be placed at the

00:27:25,710 --> 00:27:32,010
beginning of the expression. When I was first thinking about that, I think

00:27:32,010 --> 00:27:38,850
there was no new reserved words meeting those requirements.

00:27:38,850 --> 00:27:53,110
But I noticed in, which is being used now. So some of you may not know about that, but

00:27:53,110 --> 00:28:03,220
Ruby has the for expression. Have you ever used for in production? No?

00:28:03,220 --> 00:28:10,919
So it contains an in keyword that meets the requirements that I described. So, I decided

00:28:10,919 --> 00:28:23,080
to use case in combination. Next is about namespace. Unlike syntax, we

00:28:23,080 --> 00:28:32,360
cannot maintain 100%compatibility for the name space. For example, if NoMatchingPatternError

00:28:32,360 --> 00:28:43,010
has already been used, it will not work. As for 'deconstruct' and 'deconstruct_keys',

00:28:43,010 --> 00:28:50,159
if you are ‑‑ if user brings the code from current

00:28:50,159 --> 00:29:01,610
version of Ruby to Ruby 2.7, it will work. But if user attempts to combine to pattern

00:29:01,610 --> 00:29:10,590
matching, it may not work. So, we should choose a name that is not currently used.

00:29:10,590 --> 00:29:22,150
In order to do that, we are trying to investigate the code of all gems hosted by Rubygems.org,

00:29:22,150 --> 00:29:34,440
and check if the name is used or not. But especially for deconstruct_keys, I think

00:29:34,440 --> 00:29:47,020
it is a good name in terms of uniqueness, but name‑wise, I am actually ‑‑ it

00:29:47,020 --> 00:29:57,029
is not so good. So I would appreciate getting some good idea

00:29:57,029 --> 00:30:07,470
from all of you. So, feedback is welcome. And the next policy is be Rubyish.

00:30:07,470 --> 00:30:13,400
Pattern matching is a widely used function in functional programming languages.

00:30:13,400 --> 00:30:22,299
But as you know, Ruby's dynamic error typed object‑oriented language. So, it is necessary

00:30:22,299 --> 00:30:32,040
to combine these essences efficiently. I think there is two possibilities for that.

00:30:32,040 --> 00:30:36,630
First one is we provide a powerful array hash support.

00:30:36,630 --> 00:30:46,399
And another one is we provide a way to encourage duck typing.

00:30:46,399 --> 00:30:53,419
So array and hash are very important data structures for Ruby, I think. So, as you

00:30:53,419 --> 00:31:01,610
know, these objects are given special treatment for Ruby within the context of multiple assignments

00:31:01,610 --> 00:31:11,840
or keyword arguments. So, we provide array patterns and hash patterns and provide abbreviation

00:31:11,840 --> 00:31:21,520
and syntactic sugar to make it possible to use it natural.

00:31:21,520 --> 00:31:37,150
And another point is encourage duck typing. So we provide concise syntax for duck typing.

00:31:37,150 --> 00:31:48,760
That means in this example, there is two ideas. I believe most users probably use upper pattern

00:31:48,760 --> 00:31:54,520
rather than the lower pattern because it is simple.

00:31:54,520 --> 00:32:04,610
If you use the upper pattern, the object assigned to time variable should not be an instance

00:32:04,610 --> 00:32:17,639
of time class. And the next point is we don't provide a way

00:32:17,639 --> 00:32:28,600
to match ‑‑ to make a match with arguments. So, in this case, case keyword is deleted, and

00:32:28,600 --> 00:32:39,320
immediately tried to make a match with arguments. I think it is possible to support that syntax,

00:32:39,320 --> 00:32:48,299
but checking if an argument is an instance of the specified class is not duck typing,

00:32:48,299 --> 00:32:57,940
I think. So, I hesitate to introduce such syntax.

00:32:57,940 --> 00:33:07,210
And finally, there is future works. So since I don't have enough time to explain

00:33:07,210 --> 00:33:18,100
all, I will write documentation. It is very important to write document about

00:33:18,100 --> 00:33:28,620
the specification of the pattern matching. So, it would be helpful that a native speaker

00:33:28,620 --> 00:33:42,080
or someone who is very familiar with English would volunteer to assist us. So, from this

00:33:42,080 --> 00:33:50,090
year, Ruby's repository is migrated from subversion to Git, and it is also a chance to show you

00:33:50,090 --> 00:33:57,870
activity and contribute to the page on GitHub. If you are interested in joining us, please

00:33:57,870 --> 00:34:04,059
let me know. Okay. So, with that, I conclude my presentation.

00:34:04,059 --> 00:34:05,570

YouTube URL: https://www.youtube.com/watch?v=wo4eZ2iVIyo


