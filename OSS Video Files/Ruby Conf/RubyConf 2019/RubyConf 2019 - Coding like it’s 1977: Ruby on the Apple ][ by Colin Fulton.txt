Title: RubyConf 2019 - Coding like it’s 1977: Ruby on the Apple ][ by Colin Fulton
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	Coding like it’s 1977: Ruby on the Apple ][ by Colin Fulton

Many developers at some point in their programming career get curious about how HTTP servers work and how to build one from scratch without any external libraries.​Well, recently, I got curious about “How do HTTP servers work”? “How are HTTP servers built?” and “Can I build an HTTP server and client with Ruby without using any gems?“ And you know what, the answers are, yes, yes and yes!​We’ll explore how to build a simple http server using the Socket class available in the Ruby’s standard library. In the process, we will also get a crash course on how HTTP works.


#confreaks #rubyconf2019 #rubyconf
Captions: 
	00:00:12,320 --> 00:00:13,840
>> All righty.

00:00:13,840 --> 00:00:15,360
Hi, everyone.

00:00:15,360 --> 00:00:17,910
I think we're good to start going.

00:00:17,910 --> 00:00:23,620
However, before we get going, it seems a little silly to give my presentation like this.

00:00:23,620 --> 00:00:25,180
Hold on one moment.

00:00:25,180 --> 00:00:27,840
Let me I got my slides here on this floppy disk.

00:00:27,840 --> 00:00:29,720
I'll go ahead and pop that in.

00:00:29,720 --> 00:00:37,800
Got to move this video cable over... wait for it to load up.

00:00:37,800 --> 00:00:39,700
Awesome!

00:00:39,700 --> 00:00:42,110
Turn this sucker on!

00:00:42,110 --> 00:00:43,810
[ Clicking ]

00:00:43,810 --> 00:00:48,920
[ Applause ] One moment.

00:00:48,920 --> 00:00:58,440
Now if we go ahead and run the catalog command, get a list of everything on the disk.

00:00:58,440 --> 00:00:59,440
Got my slides there.

00:00:59,440 --> 00:01:04,110
So, I'll run the binary run command and run the program with my slides.

00:01:04,110 --> 00:01:08,950
Now it's going to take a little bit, because it's got to load a whole 8 kilobytes of slides

00:01:08,950 --> 00:01:11,100
into memory.

00:01:11,100 --> 00:01:18,980
The actual program which I wrote an assembly to present these slides is 241 bytes long.

00:01:18,980 --> 00:01:23,630
That is smaller than a single slide in keynote and smaller than everyone's GIF in every single

00:01:23,630 --> 00:01:26,860
other talk today.

00:01:26,860 --> 00:01:30,340
If you have written assembly for 241 bytes, it may seem big.

00:01:30,340 --> 00:01:32,729
There was a little bit of feature bloat.

00:01:32,729 --> 00:01:34,030
I added a lot of features.

00:01:34,030 --> 00:01:37,180
That's why it's a whole 241 bytes.

00:01:37,180 --> 00:01:38,470
All righty.

00:01:38,470 --> 00:01:40,710
So, a little bit about myself.

00:01:40,710 --> 00:01:41,850
My name is Colin Fulton.

00:01:41,850 --> 00:01:49,299
I'm at a fantastic place to work, Duo.

00:01:49,299 --> 00:01:50,310
And we are currently hiring.

00:01:50,310 --> 00:01:54,630
If you are interested in doing nothing at all related to this but interested in cloud

00:01:54,630 --> 00:01:58,560
security, feel free to talk to me after this.

00:01:58,560 --> 00:02:05,740
To answer the elephant in the room, yes, this is an Apple II c up here on stage with me.

00:02:05,740 --> 00:02:11,690
This is one of the late year variants, the compact version.

00:02:11,690 --> 00:02:19,560
The original Apple II and all Apple IIs for compatibility reasons, they run on 1 megahertz

00:02:19,560 --> 00:02:22,109
of CPUs.

00:02:22,109 --> 00:02:26,600
The lowest model came in with 8 kilobytes of RAM, and that included video memory.

00:02:26,600 --> 00:02:32,359
There wasn't that much you could do with the original.

00:02:32,359 --> 00:02:36,720
If you wonder, yes, this computer is, in fact, by a couple of months, older than me.

00:02:36,720 --> 00:02:42,570
I know some of you are also thinking, seriously, did you actually fly out here with all of

00:02:42,570 --> 00:02:45,150
this vintage computing stuff?

00:02:45,150 --> 00:02:48,200
Isn't it dangerous?

00:02:48,200 --> 00:02:49,200
You're totally right.

00:02:49,200 --> 00:02:54,750
It would be ridiculous of me to fly out here with an Apple II c, which is why I flew out

00:02:54,750 --> 00:02:58,599
with two, in case that one broke.

00:02:58,599 --> 00:03:02,690
[ Applause ] They loved me in security.

00:03:02,690 --> 00:03:08,200
And you may be wondering also, couldn't you use an emulator, wouldn't that be good enough?

00:03:08,200 --> 00:03:15,250
I could, but it would be nowhere near as fun and nowhere near as dangerous.

00:03:15,250 --> 00:03:16,840
All righty.

00:03:16,840 --> 00:03:22,030
So the Apple II c has the 6502 processor.

00:03:22,030 --> 00:03:28,729
It is still being produced, but it is arguably the processor that really started the personal

00:03:28,729 --> 00:03:30,400
computer revolution.

00:03:30,400 --> 00:03:35,900
It doesn't start the personal computer revolution because it was fast or particularly powerful.

00:03:35,900 --> 00:03:38,980
It's an 8 bit CPU.

00:03:38,980 --> 00:03:44,140
You have to do a little bit of weird programming to deal with the fact that it can only process

00:03:44,140 --> 00:03:51,600
8 bits at a time, but addresses are longer than the data it can actually process.

00:03:51,600 --> 00:03:53,850
It only has three registers in it.

00:03:53,850 --> 00:03:58,660
If you're a Rubyist who has never written anything like assembly programs before, that

00:03:58,660 --> 00:04:01,650
means effectively you're coding with only three variables.

00:04:01,650 --> 00:04:05,820
So, whatever you do, you have to juggle your data around in the three variables.

00:04:05,820 --> 00:04:11,030
The 6502 is more limited, because those variables are all specialized.

00:04:11,030 --> 00:04:15,090
There is no variable that can do all of the commands.

00:04:15,090 --> 00:04:24,840
To contrast it with the x86 processor in this more modern Apple laptop, it has 16 general

00:04:24,840 --> 00:04:25,840
purpose.

00:04:25,840 --> 00:04:32,810
The x86 in here has over 1,000 instructions it can run ranging from simple math operations

00:04:32,810 --> 00:04:37,410
to crazy complicated video rendering stuff.

00:04:37,410 --> 00:04:41,450
It's worth noting for those of you who are interested, because you're limited to three

00:04:41,450 --> 00:04:46,750
registers the creator of the 6502 gave you a special first page in memory.

00:04:46,750 --> 00:04:51,600
So, the first 256 bytes in memory, there are special commands for accessing that part of

00:04:51,600 --> 00:04:56,300
memory, which run faster than any other memory command.

00:04:56,300 --> 00:05:03,000
You do have a special segment of memory to use virtual registers instead.

00:05:03,000 --> 00:05:08,760
There are only 56 instructions on the 6502 processor sort of.

00:05:08,760 --> 00:05:15,730
That's relatively limited.

00:05:15,730 --> 00:05:19,900
There's no multiply instruction and no divide instruction or subtract instruction.

00:05:19,900 --> 00:05:26,750
But there is an add instruction.

00:05:26,750 --> 00:05:32,960
The reason I say it only sort of has 56 instructions because originally the rotate right instruction

00:05:32,960 --> 00:05:37,760
was completely broken on the first release of the processor.

00:05:37,760 --> 00:05:49,260
They didn't mention it on the documentation, and they fixed the bug internally and they

00:05:49,260 --> 00:05:52,670
got it up to 56 instructions.

00:05:52,670 --> 00:05:59,420
The reason why the 6502 was the computer used in the Apple II, the Commodore 64, the Nintendo

00:05:59,420 --> 00:06:06,920
entertainment system is because it was relatively fast.

00:06:06,920 --> 00:06:09,680
It couldn't do much, but what it did it did quickly.

00:06:09,680 --> 00:06:10,850
And it was cheap.

00:06:10,850 --> 00:06:17,130
When it came out, it was one sixth the price of the competing CPUs out there, which really

00:06:17,130 --> 00:06:20,420
annoyed the competitors like Intel and Motorola.

00:06:20,420 --> 00:06:25,770
So, they ended up having to slash the price of their CPUs to try to match what the 6502

00:06:25,770 --> 00:06:27,210
could do.

00:06:27,210 --> 00:06:30,840
What is it like to program on this relatively limited machine?

00:06:30,840 --> 00:06:36,860
I would like to do a hello world program, but do it in the same way that Steve Wozniak

00:06:36,860 --> 00:06:38,750
did the original interpreter.

00:06:38,750 --> 00:06:43,580
Which means we will do it in machine code.

00:06:43,580 --> 00:06:53,430
So, if it's the year 1977, you don't have a computer to do a lot of your development

00:06:53,430 --> 00:06:57,490
work, most likely, because cheap computers had not been invented yet.

00:06:57,490 --> 00:07:01,830
So, the first thing you will do is get a pencil and paper and plan out what is it that I want

00:07:01,830 --> 00:07:06,340
the computer to think through it the old fashioned way.

00:07:06,340 --> 00:07:14,520
If we want to print to the screen, the algorithm I'm going to use here is that first we're

00:07:14,520 --> 00:07:20,920
going to initialize one of the registers inside the memory with the length of the string that

00:07:20,920 --> 00:07:22,840
we want to print out.

00:07:22,840 --> 00:07:26,440
Then we are going to load a character from the string from memory.

00:07:26,440 --> 00:07:28,680
So, we're going to store our string somewhere in memory.

00:07:28,680 --> 00:07:33,330
We're going to load one of the characters into another register.

00:07:33,330 --> 00:07:38,419
We're going to go ahead and store that character from that register into video memory.

00:07:38,419 --> 00:07:43,330
We can directly write characters to the screen by directly writing to RAM.

00:07:43,330 --> 00:07:48,840
This is not necessarily it's a faster way to do it, but there are other subroutines

00:07:48,840 --> 00:07:51,490
inside which will do this in a slightly easier way.

00:07:51,490 --> 00:07:56,400
Fourth thing that we need to, do we're going to decrement that string length register,

00:07:56,400 --> 00:07:59,889
because we just printed out one character, so we're going to go to the character before

00:07:59,889 --> 00:08:00,889
that character.

00:08:00,889 --> 00:08:01,889
So, we decrement it.

00:08:01,889 --> 00:08:07,950
Then we need to check if we're at the end of the string.

00:08:07,950 --> 00:08:12,990
We're going to branch back to we're going to just end the program.

00:08:12,990 --> 00:08:16,370
If we're not at the end of the string, if we haven't gotten to zero string length yet,

00:08:16,370 --> 00:08:22,139
we will go back to step two and continue spitting out characters on to the screen to eventually

00:08:22,139 --> 00:08:23,330
reach the end.

00:08:23,330 --> 00:08:26,400
Finally when this loop completes, it's the end of the program and we can go ahead and

00:08:26,400 --> 00:08:27,400
return.

00:08:27,400 --> 00:08:29,540
So, we have a plan for what the code looks like.

00:08:29,540 --> 00:08:31,030
Now we actually need to write it.

00:08:31,030 --> 00:08:37,060
So, you would get out a book or a pamphlet which has the various machine code instructions

00:08:37,060 --> 00:08:38,079
written on it.

00:08:38,079 --> 00:08:44,589
Here are the instructions that the machines can do and the hexadecimal values associated.

00:08:44,589 --> 00:08:55,360
Now Steve Wozniak, when he was creating the Apple II, he created the mini monitor and

00:08:55,360 --> 00:09:01,620
it lets you directly edit memory.

00:09:01,620 --> 00:09:04,570
So what is it like to program this way?

00:09:04,570 --> 00:09:09,589
All righty, so what I'm going to go ahead and do, hit the m key, which is a shortcut

00:09:09,589 --> 00:09:13,270
which lets me go into the mini monitor.

00:09:13,270 --> 00:09:14,490
What can we do in here?

00:09:14,490 --> 00:09:16,260
We can read bytes from memory.

00:09:16,260 --> 00:09:21,420
If I type in the character 9, we can say that the ninth byte in memory is 01.

00:09:21,420 --> 00:09:22,580
Awesome.

00:09:22,580 --> 00:09:23,810
Now we can read ranges.

00:09:23,810 --> 00:09:29,750
So, if I say 10 20, so 10.20, it will read out a range in memory, and we can look at

00:09:29,750 --> 00:09:30,750
memory that way.

00:09:30,750 --> 00:09:32,270
So, we can read from memory.

00:09:32,270 --> 00:09:33,270
How do we write to it?

00:09:33,270 --> 00:09:37,850
We will start our program by writing at the 800th byte.

00:09:37,850 --> 00:09:43,550
And then the colon lets the mini monitor know that okay, everything after this is going

00:09:43,550 --> 00:09:48,160
to be hexadecimal values that I want to write starting at the 800th byte in memory.

00:09:48,160 --> 00:09:52,770
So, the first thing we want to do is load the y register with the length of the string.

00:09:52,770 --> 00:09:59,250
So the load y with a literal value instruction is A0.

00:09:59,250 --> 00:10:04,110
And the length of the string in this case is going to be 0C.

00:10:04,110 --> 00:10:10,850
So, next we want to load the A register with a value directly out of memory, wherever we

00:10:10,850 --> 00:10:11,900
happen to be storing our string.

00:10:11,900 --> 00:10:15,100
And we want to offset it by whatever value is in Y.

00:10:15,100 --> 00:10:21,070
And the load from memory with the offset of Y into the A register instruction, I hope

00:10:21,070 --> 00:10:23,750
it has a better name than that.

00:10:23,750 --> 00:10:25,170
It's very easy to write.

00:10:25,170 --> 00:10:27,390
It's just B9.

00:10:27,390 --> 00:10:30,490
Then we need the address in memory that we're going to be reading from.

00:10:30,490 --> 00:10:36,940
That's going to be 0B and then 08, because we're doing little Indian.

00:10:36,940 --> 00:10:38,080
All right.

00:10:38,080 --> 00:10:40,680
Now we get to the exciting part, writing the rest of the program.

00:10:40,680 --> 00:10:42,450
I think you can all see where this is going.

00:10:42,450 --> 00:10:54,550
So, I will first type in 99, 33, 06 88 D0 F7.

00:10:54,550 --> 00:10:58,900
Obviously we need to terminate this program, so we're going to type in oops going to type

00:10:58,900 --> 00:11:01,420
in a 60.

00:11:01,420 --> 00:11:02,420
All righty.

00:11:02,420 --> 00:11:03,520
Now we get to the exciting part.

00:11:03,520 --> 00:11:07,110
If any of you know the character encoding here, no spoilers!

00:11:07,110 --> 00:11:13,580
We're going to type in 48 49 and 60.

00:11:13,580 --> 00:11:14,940
Relatively uninteresting.

00:11:14,940 --> 00:11:33,279
We're going to do 52 55 42 59 and this next part, everyone can guess you have your 43

00:11:33,279 --> 00:11:38,250
4F 4E 46, and then a little spicy and exciting.

00:11:38,250 --> 00:11:39,360
61.

00:11:39,360 --> 00:11:42,380
[ Laughter ] I assume that the captioning right now just

00:11:42,380 --> 00:11:45,000
looks glorious.

00:11:45,000 --> 00:11:46,000
All right.

00:11:46,000 --> 00:11:47,000
We have written our program.

00:11:47,000 --> 00:11:50,800
We will hit enter and we have written all of that to memory.

00:11:50,800 --> 00:11:54,920
Now to run this program, I'm first gonna clear the screen out a little bit.

00:11:54,920 --> 00:11:57,570
Give it room to write.

00:11:57,570 --> 00:12:02,670
If anyone knows a better way to do that, please let me know.

00:12:02,670 --> 00:12:05,399
[ Laughter ] To run the program, we have to tell the mini

00:12:05,399 --> 00:12:10,860
monitor where we want to start in memory, and then here we want to start at 8, the start

00:12:10,860 --> 00:12:11,860
of our program.

00:12:11,860 --> 00:12:16,620
And then the G character says execute starting at that line.

00:12:16,620 --> 00:12:20,260
Now, if we did everything right.

00:12:20,260 --> 00:12:22,350
Hey!

00:12:22,350 --> 00:12:28,620
[ Cheers and Applause ]

00:12:28,620 --> 00:12:31,530
You have no idea how seldom I screw this up.

00:12:31,530 --> 00:12:33,070
I lied.

00:12:33,070 --> 00:12:34,520
It's very often.

00:12:34,520 --> 00:12:35,520
Very often.

00:12:35,520 --> 00:12:36,990
I get this wrong in practice all the time.

00:12:36,990 --> 00:12:37,990
We have a program.

00:12:37,990 --> 00:12:41,860
The mini monitor lets us disassemble the program.

00:12:41,860 --> 00:12:47,010
So, we can say 800L, and look at our program.

00:12:47,010 --> 00:12:49,020
It looks kind of like a confusing jumble of stuff.

00:12:49,020 --> 00:12:53,940
If you look here on the left hand side, we have a column of addresses in memory.

00:12:53,940 --> 00:12:56,410
We then have all the bytes of the addresses in memory.

00:12:56,410 --> 00:12:58,570
And here are the instructions.

00:12:58,570 --> 00:13:05,160
We initially loaded Y with a literal hexadecimal value of C, and we loaded the A register,

00:13:05,160 --> 00:13:08,580
which was whatever in this address offset by Y.

00:13:08,580 --> 00:13:14,520
We stored this address in memory offset by Y, etc., etc., etc., etc.

00:13:14,520 --> 00:13:15,710
So, there you go.

00:13:15,710 --> 00:13:20,980
This is what it was actually like for Steve Wozniak to write the original BASIC interpreter.

00:13:20,980 --> 00:13:29,339
How he managed to do it, I don't know and it has surprisingly few bugs in it.

00:13:29,339 --> 00:13:31,640
So now I need to go back to my presentation.

00:13:31,640 --> 00:13:34,890
So, I'm going to exit into BASIC.

00:13:34,890 --> 00:13:42,850
And it's call 1016, and we're back at where we were in the talk.

00:13:42,850 --> 00:13:48,720
For those of you that are curious, there isn't an operating system on here.

00:13:48,720 --> 00:13:52,160
It isn't that there are multiple applications running concurrently.

00:13:52,160 --> 00:13:55,149
We're just handing off execution to different parts of memory.

00:13:55,149 --> 00:13:58,890
And I had to structure the talk so that none of the parts of memory would overwrite each

00:13:58,890 --> 00:14:04,510
other, which was a fun juggling act.

00:14:04,510 --> 00:14:08,600
If this is how everyone had to do programming, I don't think most of us would be here today.

00:14:08,600 --> 00:14:13,500
Most would have given up and computers would be nowhere mere as powerful as they are today.

00:14:13,500 --> 00:14:24,120
The BASIC programming language, it is the language that democratized programming languages.

00:14:24,120 --> 00:14:34,670
When you turn on the machine, it doesn't have anything but a BASIC interpreter.

00:14:34,670 --> 00:14:39,310
A lot of people remember BASIC fondly, but it's not the greatest programming language

00:14:39,310 --> 00:14:40,900
in the world.

00:14:40,900 --> 00:14:46,790
While this machine does have Steve Wozniak's original BASIC on here, the default is Applesoft,

00:14:46,790 --> 00:14:58,100
written by Microsoft by some guy named Bill Gates or something like that.

00:14:58,100 --> 00:15:03,000
Let's go back to the mini monitor.

00:15:03,000 --> 00:15:09,310
And let's do fun things like print "hello" and it prints out the word hello.

00:15:09,310 --> 00:15:18,180
We can say Ruby="great" and it returns a type mismatch error.

00:15:18,180 --> 00:15:23,110
The reason for that is you can't have strings as variables.

00:15:23,110 --> 00:15:28,830
It's lazy, so you have to append a dollar sign to the end of any variable that is storing

00:15:28,830 --> 00:15:30,130
a string.

00:15:30,130 --> 00:15:40,459
So if we type in Ruby it prints out great.

00:15:40,459 --> 00:15:41,459
Awesome.

00:15:41,459 --> 00:15:46,500
Then go ahead and you may notice somebody weird happen with a typo.

00:15:46,500 --> 00:15:49,010
We'll get to that.

00:15:49,010 --> 00:15:52,950
[ Laughter ] Let's make another variable.

00:15:52,950 --> 00:15:54,220
We'll say rust.

00:15:54,220 --> 00:15:55,269
Rust=great.

00:15:55,269 --> 00:16:03,140
We'll then print out rust dollar sign.

00:16:03,140 --> 00:16:09,060
And then if we go back and print Ruby, you will see that it overwrote the previous Ruby

00:16:09,060 --> 00:16:12,590
variable with the word also great.

00:16:12,590 --> 00:16:18,650
Applesoft BASIC lets you have variable names up to 256 bytes long.

00:16:18,650 --> 00:16:23,360
But it only looks at the first two characters in the variable name and everything after

00:16:23,360 --> 00:16:24,360
that gets tossed out.

00:16:24,360 --> 00:16:27,980
So, you have to be very careful when constructing variables.

00:16:27,980 --> 00:16:33,450
I'm glad that programming languages have gotten a little better since BASIC.

00:16:33,450 --> 00:16:36,510
What is it?

00:16:36,510 --> 00:16:37,510
Call 1016.

00:16:37,510 --> 00:16:38,709
Go back to the slides.

00:16:38,709 --> 00:16:43,550
So, I think that Ruby would be a much better programming language to use on the Apple II.

00:16:43,550 --> 00:16:44,550
Don't you?

00:16:44,550 --> 00:16:46,760
I think it's easier to work with.

00:16:46,760 --> 00:16:57,300
So, the question I had is how is it possible to squeeze Ruby on to the Apple II?

00:16:57,300 --> 00:17:03,471
You first might think that Ruby is written in C, so we will compile C Ruby, and there

00:17:03,471 --> 00:17:07,269
are compilers out there that will do it.

00:17:07,269 --> 00:17:08,269
Fantastic.

00:17:08,269 --> 00:17:09,269
Job over.

00:17:09,269 --> 00:17:10,269
Done.

00:17:10,269 --> 00:17:11,579
Thank you, everyone.

00:17:11,579 --> 00:17:12,809
We're done.

00:17:12,809 --> 00:17:13,809
Nope.

00:17:13,809 --> 00:17:16,250
C Ruby expects certain things.

00:17:16,250 --> 00:17:20,679
Things like a file system, which this doesn't have.

00:17:20,679 --> 00:17:23,939
There were operating systems that you could get for the Apple II which had a file system,

00:17:23,939 --> 00:17:27,279
but keep in mind this doesn't have a hard disk in it.

00:17:27,279 --> 00:17:31,630
You could buy it, but they were very expensive.

00:17:31,630 --> 00:17:38,190
CRuby also expects Unicode.

00:17:38,190 --> 00:17:41,379
That didn't exist at the time this computer was created.

00:17:41,379 --> 00:17:51,000
And CRuby would minimum expect there to be ASCII, but this uses a subset of ASCII.

00:17:51,000 --> 00:17:57,049
If you want things like curly brackets, no go.

00:17:57,049 --> 00:17:59,580
All righty.

00:17:59,580 --> 00:18:04,100
The other thing is that the binary for CRuby is over 3 megabytes in size.

00:18:04,100 --> 00:18:10,520
While we could do crazy things with loading multiple floppy disks or a special memory

00:18:10,520 --> 00:18:11,769
card, but it won't work.

00:18:11,769 --> 00:18:17,039
CRuby is not going to work on an old machine like the Apple II.

00:18:17,039 --> 00:18:22,100
However, there is mRuby, the ruby designed for embedding in small systems.

00:18:22,100 --> 00:18:23,100
Awesome.

00:18:23,100 --> 00:18:25,299
This will be so much easier.

00:18:25,299 --> 00:18:27,960
Except mRuby is still too big.

00:18:27,960 --> 00:18:37,619
There is a great project which I believe is called mRuby/C. While it works with an amazingly

00:18:37,619 --> 00:18:42,759
small amount of RAM like we have on the Apple II, you still require a lot of ROM space to

00:18:42,759 --> 00:18:46,419
store code and VM.

00:18:46,419 --> 00:18:51,669
Here we want the entire runtime fitting in RAM, so mRuby is still going to be too big.

00:18:51,669 --> 00:18:56,470
And C is too high level of a programming language to program on a thing like this.

00:18:56,470 --> 00:18:59,460
I know it sounds crazy to call C a high level programming language.

00:18:59,460 --> 00:19:01,419
But when you write a switch statement?

00:19:01,419 --> 00:19:07,260
C, it can get implemented in one of half a dozen different ways.

00:19:07,260 --> 00:19:11,559
So, the code that you write doesn't directly translate into assembly.

00:19:11,559 --> 00:19:17,169
With such a restricted machine, we want tight control over exactly what code is written,

00:19:17,169 --> 00:19:21,951
which is why we would probably want to choose assembly as opposed to something like C. Is

00:19:21,951 --> 00:19:22,951
all hope lost?

00:19:22,951 --> 00:19:29,950
I have been working a little more than a year on it, and I would like to present to you

00:19:29,950 --> 00:19:34,269
nRuby for the Apple II.

00:19:34,269 --> 00:19:44,419
[ Applause ] NRuby brings you all the joys of Ruby, but it's really, really small.

00:19:44,419 --> 00:19:50,340
It's not going to have perfect feature parity with Ruby, but it has a lot of the features

00:19:50,340 --> 00:19:52,739
that maybe Ruby a great programming language.

00:19:52,739 --> 00:19:55,859
You can have a total of 256 objects.

00:19:55,859 --> 00:19:58,409
So, many objects.

00:19:58,409 --> 00:20:05,730
That's fewer objects than you get when you run an empty Ruby program, but still with

00:20:05,730 --> 00:20:10,370
256 objects, you can do dozens of different things.

00:20:10,370 --> 00:20:13,519
[ Laughter ] It's written entirely in assembly, which we'll

00:20:13,519 --> 00:20:14,519
talk about in a little bit.

00:20:14,519 --> 00:20:19,429
And that's why it's taken a while and is still very much in the alpha stage.

00:20:19,429 --> 00:20:20,480
Why is it called nRuby?

00:20:20,480 --> 00:20:25,140
I thought for a moment to call it nano Ruby.

00:20:25,140 --> 00:20:32,019
So, you chop off half of an m and you get nRuby.

00:20:32,019 --> 00:20:34,330
I know what questions some of you are going to ask.

00:20:34,330 --> 00:20:35,889
Let's address it.

00:20:35,889 --> 00:20:37,890
Will it run rails?

00:20:37,890 --> 00:20:40,970
[ Laughter ] No.

00:20:40,970 --> 00:20:41,970
Why would you ask that?

00:20:41,970 --> 00:20:47,570
Now once we get to maybe the beta state or 1.0, if someone wants to implement a nano

00:20:47,570 --> 00:20:50,960
version of rails to run within this, that would be amazing.

00:20:50,960 --> 00:20:58,950
Enough talking, show us the demo.

00:20:58,950 --> 00:21:04,490
Let me load up, I got on here on this floppy disk, one of only two floppy disks in the

00:21:04,490 --> 00:21:08,990
world with this on it, the alpha version of nRuby.

00:21:08,990 --> 00:21:12,570
Let's see how this goes.

00:21:12,570 --> 00:21:17,730
Go ahead and eject the slides, turn off the computer.

00:21:17,730 --> 00:21:20,119
Got to wait a little bit for the RAM to clear out.

00:21:20,119 --> 00:21:23,740
You may remember with older computers, the RAM takes a while to go to zero.

00:21:23,740 --> 00:21:28,489
If I turn on the computer too fast, a bunch of Gibberish is on the screen.

00:21:28,489 --> 00:21:31,639
Old computers are great.

00:21:31,639 --> 00:21:34,350
All righty.

00:21:34,350 --> 00:21:36,059
Loading and reading from the disk.

00:21:36,059 --> 00:21:39,480
Then gonna go ahead and let's see.

00:21:39,480 --> 00:21:40,480
Catalog.

00:21:40,480 --> 00:21:42,769
Make sure we have the right disk.

00:21:42,769 --> 00:21:44,389
There we have the nRuby executable.

00:21:44,389 --> 00:21:50,700
We will go ahead and do binary run of nRuby.

00:21:50,700 --> 00:21:54,909
Takes a second to load and now we have an irb style of prompt.

00:21:54,909 --> 00:22:00,149
Let's do what you have to do the first time you have any programming language.

00:22:00,149 --> 00:22:12,460
Put "hello RubyConf" and it prints out Hello RubyConf!

00:22:12,460 --> 00:22:18,749
This may seem like a relatively simple program, for this to work, there is a parser entirely

00:22:18,749 --> 00:22:22,619
written in assembly that is going through every single one of those characters figuring

00:22:22,619 --> 00:22:26,730
out we have a local variable call and then a literal string.

00:22:26,730 --> 00:22:33,309
It's creating a bunch of VM code that can run into the nRuby VM.

00:22:33,309 --> 00:22:40,539
It reads through the bytecode and it creates an object using a rather surprisingly small

00:22:40,539 --> 00:22:45,470
but still amazingly complicated memory management tool which manages the memory inside of there

00:22:45,470 --> 00:22:46,470
to create the string.

00:22:46,470 --> 00:22:50,840
Then it calls the puts command, local look up and prints to the string.

00:22:50,840 --> 00:22:56,580
There's an amazing amount of stuff that goes into hello world.

00:22:56,580 --> 00:22:57,899
Let's do the example we did before.

00:22:57,899 --> 00:23:05,370
We'll say Ruby="great" and we'll say rust="also great"

00:23:05,370 --> 00:23:15,490
You'll notice here when I do the assignment, it's not printing out the string afterwards.

00:23:15,490 --> 00:23:16,869
Assignments are statements right now.

00:23:16,869 --> 00:23:21,730
They are not actually being evaluated as expressions for those of you that know what that means,

00:23:21,730 --> 00:23:25,859
but we are working on making sure that everything is expressions so you can nest assignments

00:23:25,859 --> 00:23:26,859
and things like that.

00:23:26,859 --> 00:23:32,779
So, let's go ahead and put Ruby.

00:23:32,779 --> 00:23:35,109
Cool.

00:23:35,109 --> 00:23:36,799
That mostly did okay...

00:23:36,799 --> 00:23:40,820
Let's see what happens if we put rust.

00:23:40,820 --> 00:23:42,960
This is supposed to not actually happen.

00:23:42,960 --> 00:23:44,980
Well, they're different.

00:23:44,980 --> 00:23:53,509
[ Laughter ] Did I mention this is alpha software?

00:23:53,509 --> 00:23:56,879
Just for giggles, let's see if method definition is working.

00:23:56,879 --> 00:24:02,659
One of the fun things about assembly programming is when your program goes wrong, it can start

00:24:02,659 --> 00:24:04,409
overwriting random parts of memory.

00:24:04,409 --> 00:24:09,890
And the fact that there are random characters appearing in the string means okay.

00:24:09,890 --> 00:24:20,990
We're just going to see how this goes.

00:24:20,990 --> 00:24:26,390
Def greet name.

00:24:26,390 --> 00:24:30,549
[ Typing ] That's not good that it printed out hello.

00:24:30,549 --> 00:24:33,370
[ Laughter ] Okay.

00:24:33,370 --> 00:24:36,190
We're running.

00:24:36,190 --> 00:24:37,690
Time is a thing.

00:24:37,690 --> 00:24:39,909
Let's go back to the slides.

00:24:39,909 --> 00:24:40,909
I'm sorry everyone.

00:24:40,909 --> 00:24:42,700
This is the problem with alpha software.

00:24:42,700 --> 00:24:45,659
However if you're interested, I had my Twitter handle up there before.

00:24:45,659 --> 00:24:51,039
I am going to be posting updates with nRuby as it gets developed.

00:24:51,039 --> 00:24:55,860
I'm sorry if you're waiting to use nRuby in production.

00:24:55,860 --> 00:25:01,259
As I just accidentally demonstrated, it's clearly not quite production ready.

00:25:01,259 --> 00:25:05,009
But let's go ahead and go back to the slides so we can talk about the internals, at least

00:25:05,009 --> 00:25:10,929
the bits that work, apparently.

00:25:10,929 --> 00:25:18,529
Let's turn off.

00:25:18,529 --> 00:25:23,610
[ Clicking ] [ Typing ]

00:25:23,610 --> 00:25:24,610
All right.

00:25:24,610 --> 00:25:25,620
We'll skip ahead.

00:25:25,620 --> 00:25:26,620
All right.

00:25:26,620 --> 00:25:33,139
So, last thing for those of you who are technically inclined, I want to give you a peak under

00:25:33,139 --> 00:25:37,379
the hood of nRuby and how is it actually implemented inside of there.

00:25:37,379 --> 00:25:40,179
So, the first thing people ask me is assembly.

00:25:40,179 --> 00:25:42,539
My God, that's the worst form of programming.

00:25:42,539 --> 00:25:46,269
It must be incredibly difficult and terrible.

00:25:46,269 --> 00:25:48,570
You're just trying to punish yourself.

00:25:48,570 --> 00:25:54,879
Assembly is not as bad as a lot of people make it out to be.

00:25:54,879 --> 00:25:56,159
Assembly does very little.

00:25:56,159 --> 00:26:01,879
It's easy to learn because there isn't that much that a processor like the 6502 can do.

00:26:01,879 --> 00:26:07,109
The hard part is taking the components to compose them together and make useful programs.

00:26:07,109 --> 00:26:13,909
But to learn assembly, you only have 56 instructions and many of them are repeats of each other.

00:26:13,909 --> 00:26:17,629
It's relatively easy to learn as a language.

00:26:17,629 --> 00:26:22,209
In order to do this, I did test driven development in assembly

00:26:22,209 --> 00:26:27,570
[ Applause ] Thank you.

00:26:27,570 --> 00:26:29,260
I'm not sure why that's getting applause.

00:26:29,260 --> 00:26:36,269
I think it's it blows my mind that most people don't do test driven development assembly.

00:26:36,269 --> 00:26:41,440
I can talk to you afterwards about how it works.

00:26:41,440 --> 00:26:47,759
But you call out to your subroutine in assembly and load a value.

00:26:47,759 --> 00:26:49,379
Is it the value I expected?

00:26:49,379 --> 00:26:53,349
If so, print one thing to the screen and if not, print an f to the screen.

00:26:53,349 --> 00:26:59,230
Then you run the program and it prints characters and you look at the source code and see which

00:26:59,230 --> 00:27:01,720
tests passed and which failed.

00:27:01,720 --> 00:27:08,039
It's a lot less code than something like r spec.

00:27:08,039 --> 00:27:12,519
So assembly code is relatively easy to read once you kind of know what's going on.

00:27:12,519 --> 00:27:13,820
It's divided into three columns.

00:27:13,820 --> 00:27:15,570
You have a label, which is optional.

00:27:15,570 --> 00:27:21,340
A pneumonic, which is a fancy way of saying it's a shortening of the name of the instruction

00:27:21,340 --> 00:27:22,359
you want to call.

00:27:22,359 --> 00:27:25,710
And then the instructions take an argument.

00:27:25,710 --> 00:27:33,320
So, the program that we wrote before to print "hi RubyConf" on the screen looked like this,

00:27:33,320 --> 00:27:36,460
which is more readable than the machine code we were doing before.

00:27:36,460 --> 00:27:43,679
We are loading the y register with a literal value, a literal number 12.

00:27:43,679 --> 00:27:45,730
We have a label here called loop.

00:27:45,730 --> 00:27:50,999
It says rather than me having to figure out what address in memory this line of code is,

00:27:50,999 --> 00:27:53,599
just put a value there to reference later.

00:27:53,599 --> 00:27:58,080
Then we load an A register with another variable.

00:27:58,080 --> 00:27:59,719
We go through the code.

00:27:59,719 --> 00:28:04,989
And our final branch statement, you'll see the argument is loop, and that pastes in whatever

00:28:04,989 --> 00:28:06,999
address happens to be there.

00:28:06,999 --> 00:28:09,509
So, again, assembly really doesn't do that much.

00:28:09,509 --> 00:28:15,769
Once you learn to read the pneumonics and three letter codes, it's a relatively pleasant

00:28:15,769 --> 00:28:20,620
programming experience once you get your head around the nitty gritty details.

00:28:20,620 --> 00:28:22,960
So what is modern Apple II development like?

00:28:22,960 --> 00:28:28,989
I'm not using the actual vintage machine to do the development work.

00:28:28,989 --> 00:28:31,419
I'm using an emulator.

00:28:31,419 --> 00:28:34,539
It simulates the clicky clacky noises.

00:28:34,539 --> 00:28:42,909
It has a reasonably good debugger and let you step through your program step by step.

00:28:42,909 --> 00:28:46,499
Having a debugger is very, very important for this so you can actually walk through

00:28:46,499 --> 00:28:48,399
your program and see what it's actually doing.

00:28:48,399 --> 00:28:53,659
When it goes out of control, it really goes out of control, as you guys saw.

00:28:53,659 --> 00:28:59,899
The assembler that I'm using to turn text files into actual machine bytecode is called

00:28:59,899 --> 00:29:04,559
Merlin32.

00:29:04,559 --> 00:29:12,969
It's the descendent of a whole line of assemblers, there was Merlin16 and Merlin8, and the original

00:29:12,969 --> 00:29:24,429
Merlin which was written for the actual original Apple II.

00:29:24,429 --> 00:29:27,119
Another option is the CC65 assembler.

00:29:27,119 --> 00:29:34,389
That is specifically designed for compiling C code for things like the Commodore 64 and

00:29:34,389 --> 00:29:36,739
the Apple II.

00:29:36,739 --> 00:29:39,979
CC65 also has an assembler.

00:29:39,979 --> 00:29:44,720
I found it more difficult to use, so that's why I went with Merlin.

00:29:44,720 --> 00:29:51,179
I used a program called Apple commander to take that binary and turn it into a disk image.

00:29:51,179 --> 00:29:53,419
Apple commander happens to be written in java.

00:29:53,419 --> 00:29:57,369
I don't know why.

00:29:57,369 --> 00:30:01,299
It takes binaries and puts them on to virtual disks, so whatever.

00:30:01,299 --> 00:30:03,009
It works well for me.

00:30:03,009 --> 00:30:10,299
I then use a program called ADTpro to transfer the disk image from my computer to the actual

00:30:10,299 --> 00:30:11,299
Apple II.

00:30:11,299 --> 00:30:16,940
Obviously there's no USB port in the Apple II, so I need this USB to serial adapter,

00:30:16,940 --> 00:30:18,059
which ADT recognizes.

00:30:18,059 --> 00:30:26,919
So, it doesn't have a serial port, so I also need a serial port to null modem cable.

00:30:26,919 --> 00:30:30,549
I hope I don't lose this, because there is like one person I could find that still makes

00:30:30,549 --> 00:30:32,029
these things.

00:30:32,029 --> 00:30:38,109
So how does nRuby manage memory?

00:30:38,109 --> 00:30:42,190
That's one of the main things that Ruby does for us, allows us to write programs without

00:30:42,190 --> 00:30:44,100
having to do things like manage memory.

00:30:44,100 --> 00:30:48,909
We can just write our code and have fun.

00:30:48,909 --> 00:30:55,090
So, memory is divided into pages of 256 bytes.

00:30:55,090 --> 00:31:01,669
I have taken 16 of those pages and said these are where we're going to basically store our

00:31:01,669 --> 00:31:02,669
heap.

00:31:02,669 --> 00:31:04,450
This is the space where the objects are gonna be stored.

00:31:04,450 --> 00:31:13,129
I take you to the 156 byte pages and divide it into 16 byte long slots.

00:31:13,129 --> 00:31:15,639
We have 16 of them.

00:31:15,639 --> 00:31:19,960
And then each one of those can be given a single byte to give it a unique value, which

00:31:19,960 --> 00:31:24,289
means when referencing objects, I only need a single byte to reference where that object

00:31:24,289 --> 00:31:28,019
or slice of an object is stored in memory.

00:31:28,019 --> 00:31:34,399
The way I initially implemented this was I went ahead and numbered the bytes in order.

00:31:34,399 --> 00:31:41,049
So, page 0 started with slot 00, then slot 01, then slot 02, etc.

00:31:41,049 --> 00:31:45,779
Now I needed to write a program which could take these slot addresses and translate them

00:31:45,779 --> 00:31:50,450
to actual addresses that I could reference things in memory.

00:31:50,450 --> 00:31:56,669
So let's say I have a slot ID of CF with the layout I described to you, that translates

00:31:56,669 --> 00:32:01,389
to page 0C and byte F0.

00:32:01,389 --> 00:32:04,379
Those are the hexadecimal values.

00:32:04,379 --> 00:32:10,549
We need to turn CF into F0 and 0C.

00:32:10,549 --> 00:32:17,279
C is the first nibble of that byte, and the page takes that first nibble and ships it

00:32:17,279 --> 00:32:20,269
on to the second nibble.

00:32:20,269 --> 00:32:29,070
So, all we need to do to translate is just do a bunch of arithmetic shift operations.

00:32:29,070 --> 00:32:37,230
So, we shave off the A register, which is where we're storing the ID.

00:32:37,230 --> 00:32:41,940
We perform a bunch of shifts, and that gives us the slot byte address.

00:32:41,940 --> 00:32:47,809
And then we shift right, and that gives us the slot page address.

00:32:47,809 --> 00:32:52,159
And now we've translated that number into an actual address in memory.

00:32:52,159 --> 00:32:53,249
Awesome.

00:32:53,249 --> 00:32:55,830
However, this is a lot of code.

00:32:55,830 --> 00:32:56,830
No, it doesn't look like it.

00:32:56,830 --> 00:32:57,989
To me, this irked me.

00:32:57,989 --> 00:32:59,760
I have all of these shift operations.

00:32:59,760 --> 00:33:02,080
It seems like there would be a more efficient way to do this.

00:33:02,080 --> 00:33:08,190
So, I looked for a while and realized we could get more clever.

00:33:08,190 --> 00:33:11,499
What I had done is laid out things column by column.

00:33:11,499 --> 00:33:15,729
But what would happen if instead we laid things out row by row?

00:33:15,729 --> 00:33:19,830
So the first slot is going to be page 0, slot 0.

00:33:19,830 --> 00:33:25,519
And the second slot instead of being page 0 slot 1 will be page 1 slot 0.

00:33:25,519 --> 00:33:27,499
And we go across each row.

00:33:27,499 --> 00:33:32,049
So, now all of the objects are striped in memory.

00:33:32,049 --> 00:33:37,679
Once we get to the end of 16 pages, we loop back and store in the second row and byte

00:33:37,679 --> 00:33:40,239
in each page in memory.

00:33:40,239 --> 00:33:46,239
All that we have done is taken our IDs and rotated them 90 degrees.

00:33:46,239 --> 00:33:53,909
So, with our old algorithm, CF translated to page 0C, byte F0 like we talked before.

00:33:53,909 --> 00:33:59,860
With the new algorithm, it translates to 0F, C0.

00:33:59,860 --> 00:34:03,610
Now the C and the F are in the exact same nibble.

00:34:03,610 --> 00:34:09,200
So, now we need to replace each nibble with a zero.

00:34:09,200 --> 00:34:12,070
So, our new assembly code looks like this.

00:34:12,070 --> 00:34:22,620
We replace all of the shifts.

00:34:22,620 --> 00:34:24,429
Keep all the rest the same code.

00:34:24,429 --> 00:34:28,110
This means we go from all of this code to all this code.

00:34:28,110 --> 00:34:31,480
Which is a significant amount faster.

00:34:31,480 --> 00:34:32,480
All righty.

00:34:32,480 --> 00:34:35,270
If you got lost there, don't worry.

00:34:35,270 --> 00:34:38,100
It confused me when I was writing it, certainly.

00:34:38,100 --> 00:34:42,720
However, the great thing about test driven development is I had tests that had the right

00:34:42,720 --> 00:34:48,530
values and expectations so I could keep hacking until eventually I got it working.

00:34:48,530 --> 00:34:50,010
What's next?

00:34:50,010 --> 00:34:56,300
Obviously I need to finish nRuby and pass the current alpha state.

00:34:56,300 --> 00:34:58,870
And I need to release it to GitHub.

00:34:58,870 --> 00:35:03,230
The reason it's not on there now is some of the build tools I have on there now are not

00:35:03,230 --> 00:35:04,280
technically open source.

00:35:04,280 --> 00:35:06,350
They're freely available but not open source.

00:35:06,350 --> 00:35:16,060
So, I need to pull out code, because it might be in a bit of a licensing gray area.

00:35:16,060 --> 00:35:25,230
I would love to get nRuby working on other processors like the MSP430.

00:35:25,230 --> 00:35:29,340
It's easier to program for.

00:35:29,340 --> 00:35:31,780
It has subtraction, which is amazing.

00:35:31,780 --> 00:35:35,230
Oh, I wish I had subtraction.

00:35:35,230 --> 00:35:42,790
The other cool thing is you can get very, very, very low power MSP430 processors, which

00:35:42,790 --> 00:35:52,250
means potentially if we can port N Ruby, we could take a lemon, put a zinc and copper

00:35:52,250 --> 00:35:57,350
plate, wire it up, and run Ruby programs off of a lemon.

00:35:57,350 --> 00:36:05,810
For anyone who says Ruby is inefficient and power hungry, this would prove them wrong.

00:36:05,810 --> 00:36:13,700
There are other computers that run the 6502, including the NES, which is kind of right

00:36:13,700 --> 00:36:20,930
now my holy grail for nRuby, because it would be amazing to write games in Ruby on the NES,

00:36:20,930 --> 00:36:25,760
but it only has two kilobytes of RAM, but it has 40 kilobytes of ROM space, so we might

00:36:25,760 --> 00:36:34,450
be able to hack something together, but one day, I want to get it there.

00:36:34,450 --> 00:36:36,070
And what's next for you?

00:36:36,070 --> 00:36:39,830
If you are interested in this kind of stuff, if you enjoyed this talk, where can you go

00:36:39,830 --> 00:36:40,830
to learn more?

00:36:40,830 --> 00:36:43,830
I have some recommendations if you want to learn more.

00:36:43,830 --> 00:36:47,330
There's a talk called reverse engineering the MOS 6502.

00:36:47,330 --> 00:36:50,830
It is a technical deep dive.

00:36:50,830 --> 00:36:57,250
They stripped away the top of the chip and read out where the transistors are.

00:36:57,250 --> 00:37:00,910
It's an amazing talk.

00:37:00,910 --> 00:37:05,490
They go fast, but luckily it's on YouTube, so you can pause and rewind to follow what

00:37:05,490 --> 00:37:07,300
they're doing.

00:37:07,300 --> 00:37:11,180
There's also another talk called the ultimate Commodore 64 talk.

00:37:11,180 --> 00:37:18,000
It is another deep dive into another interesting old computer that works off of the 6502.

00:37:18,000 --> 00:37:23,150
And look up demoscene.

00:37:23,150 --> 00:37:25,990
They try to push them to the limits of what's possible.

00:37:25,990 --> 00:37:34,560
There are demoscene demos where they do 3D graphics on a Commodore 64, unimaginably powerful

00:37:34,560 --> 00:37:40,430
programs and they do it by doing insanely crazy hacks in their assembly code.

00:37:40,430 --> 00:37:45,720
And there are talks about how demoscene developers do what they do and the tricks they use to

00:37:45,720 --> 00:37:49,700
get more power out of the machines.

00:37:49,700 --> 00:37:57,360
Do you want the fun of all of this but not all of the horrible pain of doing assembly

00:37:57,360 --> 00:37:58,360
programming?

00:37:58,360 --> 00:38:02,660
Do you find the idea of this fun, but don't actually want to implement something on a

00:38:02,660 --> 00:38:04,620
vintage processor?

00:38:04,620 --> 00:38:07,620
There are computer games that are good to do.

00:38:07,620 --> 00:38:08,800
There is a game called TIS100.

00:38:08,800 --> 00:38:14,360
You write assembly code to solve puzzles.

00:38:14,360 --> 00:38:19,500
There's another called human resource simulator or something like that.

00:38:19,500 --> 00:38:22,350
Human resource machine.

00:38:22,350 --> 00:38:28,390
It is a game where you do drag and drop style programming with effectively assembly to do

00:38:28,390 --> 00:38:31,730
terrible things in a human resource department.

00:38:31,730 --> 00:38:39,320
If you want to try retro programming, I would try the Commodore 64 or the Apple II.

00:38:39,320 --> 00:38:45,550
The Commodore 64 has the advantage that there are more people writing code for it so there

00:38:45,550 --> 00:38:49,580
are fantastic resources and talks.

00:38:49,580 --> 00:38:56,260
If you go to the Apple help page, Apple.com and go to the help box, there's a check box

00:38:56,260 --> 00:38:59,020
to view historical documents or something.

00:38:59,020 --> 00:39:04,660
And on Apple.com, you can search their original help documents for the Apple II.

00:39:04,660 --> 00:39:09,730
So, I got some of the resources from Apple themselves, which is really cool.

00:39:09,730 --> 00:39:15,410
If you want to try programming retro games instead of a computer, I recommend the Atari2600.

00:39:15,410 --> 00:39:19,930
It's limited and easier.

00:39:19,930 --> 00:39:25,570
So, the games you write will be simple, but it's a good one to get started on.

00:39:25,570 --> 00:39:26,890
Or the Nintendo entertainment system.

00:39:26,890 --> 00:39:35,900
A lot of the advanced consoles such as the super Nintendo had really advanced graphics,

00:39:35,900 --> 00:39:40,240
but also meant they were a pain to program for, so I recommend starting with the simpler

00:39:40,240 --> 00:39:46,420
older consoles or computers.

00:39:46,420 --> 00:39:50,040
And my talk seems to have frozen up, so that's fantastic.

00:39:50,040 --> 00:39:54,250
Luckily the next slide was a slide to say thank you very much for coming.

00:39:54,250 --> 00:39:56,310
Let me just go back.

00:39:56,310 --> 00:40:02,720
I have my Twitter handle and GitHub and e mail address.

00:40:02,720 --> 00:40:07,150
If you want to talk about this, feel free to talk to me afterwards or ask questions

00:40:07,150 --> 00:40:09,670
or hit me up on Twitter or e mail.

00:40:09,670 --> 00:40:14,220
I'm not very active, but I promise that anything you ask I will talk to you eventually, because

00:40:14,220 --> 00:40:17,570
I do love talking with people about this stuff and sharing the passion.

00:40:17,570 --> 00:40:18,890
So, again, thank you very much.

00:40:18,890 --> 00:40:19,079

YouTube URL: https://www.youtube.com/watch?v=M7LEf7-W12k


