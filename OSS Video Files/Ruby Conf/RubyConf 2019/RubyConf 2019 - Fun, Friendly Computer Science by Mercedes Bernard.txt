Title: RubyConf 2019 - Fun, Friendly Computer Science by Mercedes Bernard
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Fun, Friendly Computer Science by Mercedes Bernard

Computer science concepts like Big O Notation, set theory, data structures, and principles of object-oriented programming sound intimidating, but they donâ€™t have to be! This talk will dive into some fundamental computer science topics and debunk the myth that only â€˜realâ€™ programmers know CS.


Whether you are a code school grad, self-taught career switcher, or someone who, like me, didn't pay attention in night class, join me as we explore some computer science theory behind the code we write every day through fun illustrations and real-world examples.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:11,980 --> 00:00:17,900
hello everyone we're gonna go ahead and

00:00:14,600 --> 00:00:20,420
get started because this talk when I

00:00:17,900 --> 00:00:21,529
practice hits right at 40 minutes and I

00:00:20,420 --> 00:00:24,770
want to make sure that you don't miss

00:00:21,529 --> 00:00:26,630
out on any content so if you are here

00:00:24,770 --> 00:00:29,240
for fun friendly computer science you're

00:00:26,630 --> 00:00:31,670
in the right place this talk is going to

00:00:29,240 --> 00:00:34,100
be your computer science quick hits so

00:00:31,670 --> 00:00:37,160
we're gonna cover seven computer science

00:00:34,100 --> 00:00:39,140
topics in about 35 minutes and so

00:00:37,160 --> 00:00:41,570
because we don't have very much time I

00:00:39,140 --> 00:00:44,480
am mainly focusing on fundamental and

00:00:41,570 --> 00:00:46,700
intro object-oriented concepts there's a

00:00:44,480 --> 00:00:49,430
whole world of computer science out

00:00:46,700 --> 00:00:52,579
there but I cannot fit it into 40

00:00:49,430 --> 00:00:55,700
minutes if you have familiarity with

00:00:52,579 --> 00:00:57,739
loops arrays and classes you'll have no

00:00:55,700 --> 00:01:01,250
problem following along this is a

00:00:57,739 --> 00:01:04,100
beginner level talk my name is Mercedes

00:01:01,250 --> 00:01:06,290
Bernhard my pronouns are she and her and

00:01:04,100 --> 00:01:08,390
I am an engineering manager and senior

00:01:06,290 --> 00:01:13,399
software engineer with a consulting firm

00:01:08,390 --> 00:01:15,680
in Chicago called tandem my background

00:01:13,399 --> 00:01:17,869
is in traditional computer science I

00:01:15,680 --> 00:01:20,420
have a bachelor's in it from DePaul

00:01:17,869 --> 00:01:23,240
University but the longer that I am in

00:01:20,420 --> 00:01:25,549
this industry the more I realize that I

00:01:23,240 --> 00:01:28,159
don't need to know all of that or at

00:01:25,549 --> 00:01:31,340
least not to the depth that they teach

00:01:28,159 --> 00:01:33,049
it to you if you came into software from

00:01:31,340 --> 00:01:34,400
a non-traditional career path whether

00:01:33,049 --> 00:01:36,170
you went to a code school you

00:01:34,400 --> 00:01:38,150
self-taught you jumped around and tried

00:01:36,170 --> 00:01:40,310
a lot of different careers you may have

00:01:38,150 --> 00:01:43,670
never had the opportunity to learn these

00:01:40,310 --> 00:01:46,790
items but you'll still be interviewed on

00:01:43,670 --> 00:01:50,180
it and if you are you know more of a

00:01:46,790 --> 00:01:52,490
front-end engineer interviewing and tech

00:01:50,180 --> 00:01:54,439
is broken many interviewers don't know

00:01:52,490 --> 00:01:57,110
how to interview and so even though you

00:01:54,439 --> 00:01:58,939
might be doing lots of CSS you might

00:01:57,110 --> 00:02:01,640
still get asked to implement a linked

00:01:58,939 --> 00:02:04,310
list which like why you're never going

00:02:01,640 --> 00:02:06,649
to need to do it so my goal with this

00:02:04,310 --> 00:02:08,390
talk is to show you that these topics

00:02:06,649 --> 00:02:11,120
that show up in interviews and that are

00:02:08,390 --> 00:02:12,550
sometimes used for gatekeeping aren't

00:02:11,120 --> 00:02:15,070
intimidating and they

00:02:12,550 --> 00:02:17,440
aren't truly that important because a

00:02:15,070 --> 00:02:18,910
you probably know most of what I'm gonna

00:02:17,440 --> 00:02:22,090
cover today you just don't have the

00:02:18,910 --> 00:02:25,000
right vocabulary to seem like you do and

00:02:22,090 --> 00:02:27,310
it's just truly not that important you

00:02:25,000 --> 00:02:29,590
can get by without ever learning this

00:02:27,310 --> 00:02:31,240
you'll walk away from this talk with a

00:02:29,590 --> 00:02:34,000
high-level understanding of a bunch of

00:02:31,240 --> 00:02:36,460
different concepts as well as metaphors

00:02:34,000 --> 00:02:38,470
that may help you explain them and code

00:02:36,460 --> 00:02:40,030
samples that you can refer to later if

00:02:38,470 --> 00:02:42,340
you want to dig deeper and you find this

00:02:40,030 --> 00:02:44,050
interesting if you're sitting here and

00:02:42,340 --> 00:02:46,090
you're like oh cool you said this is

00:02:44,050 --> 00:02:47,890
beginner I know all of this stuff I

00:02:46,090 --> 00:02:49,390
don't need it I guarantee you there's

00:02:47,890 --> 00:02:51,430
still something in here that you can

00:02:49,390 --> 00:02:54,790
take away to help explain the stuff to

00:02:51,430 --> 00:02:57,340
the people that you mentor if you are

00:02:54,790 --> 00:02:59,050
someone who likes visual aids who would

00:02:57,340 --> 00:03:00,760
prefer to have the slides up close

00:02:59,050 --> 00:03:02,650
especially because there are code

00:03:00,760 --> 00:03:06,370
samples and I could only do so much to

00:03:02,650 --> 00:03:09,160
make them fit the you can find the

00:03:06,370 --> 00:03:11,460
slides here they've been posted and

00:03:09,160 --> 00:03:14,290
you'll be able to follow along there

00:03:11,460 --> 00:03:16,780
there will also be code samples in this

00:03:14,290 --> 00:03:19,810
talk you can find them all on my github

00:03:16,780 --> 00:03:21,730
if you do go pull those down be sure to

00:03:19,810 --> 00:03:24,490
check out the commits I made I did a

00:03:21,730 --> 00:03:26,830
very good job on my commits and so there

00:03:24,490 --> 00:03:28,840
is a commit for each concept with a

00:03:26,830 --> 00:03:30,880
great commit message

00:03:28,840 --> 00:03:32,920
there's test coverage so you can go look

00:03:30,880 --> 00:03:34,480
at unit tests that some of the concepts

00:03:32,920 --> 00:03:36,390
the tests actually do a better job

00:03:34,480 --> 00:03:39,820
illustrating what I'm trying to explain

00:03:36,390 --> 00:03:41,920
and all of the code is runnable so

00:03:39,820 --> 00:03:44,080
you'll have a working UI to play with if

00:03:41,920 --> 00:03:47,709
you learn more by doing than by reading

00:03:44,080 --> 00:03:50,110
if you are here I assume you write Ruby

00:03:47,709 --> 00:03:52,420
code but I also have a repo for

00:03:50,110 --> 00:03:54,250
JavaScript and Python if that is what

00:03:52,420 --> 00:03:56,380
you're more familiar with or if you just

00:03:54,250 --> 00:04:00,130
want to see how those compare to each

00:03:56,380 --> 00:04:01,990
other all right so this is everything

00:04:00,130 --> 00:04:04,900
that we're going to be getting through

00:04:01,990 --> 00:04:08,620
in the next 35 minutes

00:04:04,900 --> 00:04:10,120
so let's go do we have anybody here who

00:04:08,620 --> 00:04:13,590
is really good in the kitchen

00:04:10,120 --> 00:04:16,419
likes to cook likes to bake awesome

00:04:13,590 --> 00:04:19,479
don't call me out when I'm wrong because

00:04:16,419 --> 00:04:20,889
I'm terrible at it but if you're good at

00:04:19,479 --> 00:04:24,040
cooking there's this thing called

00:04:20,889 --> 00:04:25,930
cooking with ratios and so cooking with

00:04:24,040 --> 00:04:27,940
ratios is where you don't memorize a

00:04:25,930 --> 00:04:32,229
recipe but instead you memorize the

00:04:27,940 --> 00:04:33,820
ratios of ingredients so you change the

00:04:32,229 --> 00:04:36,400
proportion of your greedy n't

00:04:33,820 --> 00:04:39,580
to how much of a thing that you want to

00:04:36,400 --> 00:04:42,010
make big o-notation measures the

00:04:39,580 --> 00:04:45,430
relative complexity of a function or

00:04:42,010 --> 00:04:47,199
algorithm most often like when you're in

00:04:45,430 --> 00:04:49,960
an interview we're talking about running

00:04:47,199 --> 00:04:51,580
time but we can truly talk about any

00:04:49,960 --> 00:04:54,820
computing resource we can talk about

00:04:51,580 --> 00:04:57,880
stack stack depth we can talk about your

00:04:54,820 --> 00:04:59,770
CPU memory usage all of that but running

00:04:57,880 --> 00:05:01,240
time is most common and so that's what

00:04:59,770 --> 00:05:05,250
we're going to use for all of these

00:05:01,240 --> 00:05:09,039
examples when we're talking about Big O

00:05:05,250 --> 00:05:12,580
it's also language hardware and time

00:05:09,039 --> 00:05:15,190
agnostic so if I truly soup up my laptop

00:05:12,580 --> 00:05:16,090
and the same code runs faster on mine

00:05:15,190 --> 00:05:19,090
than yours

00:05:16,090 --> 00:05:21,310
it doesn't matter the O the relative

00:05:19,090 --> 00:05:24,039
complexity of the code is still the same

00:05:21,310 --> 00:05:27,940
and it's all measured in proportion to

00:05:24,039 --> 00:05:30,310
the input size when we're talking about

00:05:27,940 --> 00:05:33,520
Big O we're also talking about it in a

00:05:30,310 --> 00:05:35,110
worst case scenario so if you somebody

00:05:33,520 --> 00:05:38,050
says like here's a sorting algorithm

00:05:35,110 --> 00:05:40,210
what's the big ono tation they don't

00:05:38,050 --> 00:05:43,120
care that like if the collection I

00:05:40,210 --> 00:05:44,560
handed you is almost sorted like it's

00:05:43,120 --> 00:05:46,710
quicker to sort cuz you're like I just

00:05:44,560 --> 00:05:49,570
gotta let those two things and it's done

00:05:46,710 --> 00:05:51,310
they want a worst case scenario that's

00:05:49,570 --> 00:05:52,990
what we're talking about if you get

00:05:51,310 --> 00:05:55,539
something that's completely jumbled what

00:05:52,990 --> 00:05:57,490
is the worst-case scenario in running

00:05:55,539 --> 00:06:00,619
time to sort it

00:05:57,490 --> 00:06:05,029
okay so I'm gonna break down some of the

00:06:00,619 --> 00:06:08,089
O's the first Oh is of one it's oh it's

00:06:05,029 --> 00:06:11,119
a constant running time so no matter how

00:06:08,089 --> 00:06:13,849
your input size changes it always takes

00:06:11,119 --> 00:06:16,339
the same amount of time to run if we're

00:06:13,849 --> 00:06:20,270
making cupcakes which cupcakes follow a

00:06:16,339 --> 00:06:24,020
4 3 2 1 ratio fun fact

00:06:20,270 --> 00:06:26,330
it's like 4 eggs 3 cups of flour butter

00:06:24,020 --> 00:06:30,680
I don't know I'm a bad cook don't follow

00:06:26,330 --> 00:06:33,680
any recipe that you see today um but if

00:06:30,680 --> 00:06:35,509
we are combining the butter and sugar

00:06:33,680 --> 00:06:38,029
we're going to beat them with an

00:06:35,509 --> 00:06:41,509
electric mixer for 3 minutes so that's

00:06:38,029 --> 00:06:44,419
right here and so I don't care if I'm

00:06:41,509 --> 00:06:46,069
doing two cups butter 1 cup sugar 4 cups

00:06:44,419 --> 00:06:48,860
butter 2 cups sugar

00:06:46,069 --> 00:06:51,289
I always I'm going to beat it for 3

00:06:48,860 --> 00:06:52,849
minutes so constant time I don't care

00:06:51,289 --> 00:06:57,259
what's coming in it's always a constant

00:06:52,849 --> 00:07:01,459
time that's oh of one the next most

00:06:57,259 --> 00:07:03,769
common ohh is 0 of n so this is that the

00:07:01,459 --> 00:07:06,019
running time increases in direct

00:07:03,769 --> 00:07:10,339
proportion to the input size it's a

00:07:06,019 --> 00:07:13,069
linear complexity and so what you'll see

00:07:10,339 --> 00:07:15,169
here is if the recipe says you know as

00:07:13,069 --> 00:07:16,939
we add our eggs you're going to add an

00:07:15,169 --> 00:07:19,279
egg and beat it with an electric mixer

00:07:16,939 --> 00:07:20,839
for one minute add another egg beat or a

00:07:19,279 --> 00:07:23,389
minute add another egg beat it for a

00:07:20,839 --> 00:07:25,819
minute you'll see that if I have to add

00:07:23,389 --> 00:07:27,979
four eggs it's four minutes if I have to

00:07:25,819 --> 00:07:35,029
add eight eggs it's eight minutes it's a

00:07:27,979 --> 00:07:37,369
linear it increases in linear time now

00:07:35,029 --> 00:07:40,209
we're getting a little worse here both

00:07:37,369 --> 00:07:45,800
in terms of performance and my examples

00:07:40,209 --> 00:07:47,930
so if I want to combine the flour the

00:07:45,800 --> 00:07:51,469
milk and the butter really slowly I

00:07:47,930 --> 00:07:53,809
don't want chunky flour I might want to

00:07:51,469 --> 00:07:57,259
do something that performs in O of N

00:07:53,809 --> 00:07:58,519
squared time so o of N squared like how

00:07:57,259 --> 00:08:00,469
often are you like oh yeah I totally

00:07:58,519 --> 00:08:03,559
square the input size on a thing

00:08:00,469 --> 00:08:08,120
actually any time that you see a nested

00:08:03,559 --> 00:08:12,290
loop it's o of N squared so linear a

00:08:08,120 --> 00:08:14,660
a kind of flag for is this o of n is is

00:08:12,290 --> 00:08:16,520
there a for loop or a while loop you can

00:08:14,660 --> 00:08:18,650
be pretty confident that's probably o of

00:08:16,520 --> 00:08:21,260
n as soon as you start seeing things

00:08:18,650 --> 00:08:26,660
that are nested that's oh of N squared

00:08:21,260 --> 00:08:29,570
if I wanted to beat it even slower I

00:08:26,660 --> 00:08:32,270
might add another layer of nesting the

00:08:29,570 --> 00:08:34,580
third layer would be o of n cubed fourth

00:08:32,270 --> 00:08:36,169
o of n to the fourth and so on and so

00:08:34,580 --> 00:08:41,570
forth until why are you writing code

00:08:36,169 --> 00:08:43,610
that performs so bad now again let's say

00:08:41,570 --> 00:08:47,000
that I'm making cupcakes because we are

00:08:43,610 --> 00:08:49,820
celebrating Fibonacci's birthday I want

00:08:47,000 --> 00:08:52,370
to again I know the very contrived but I

00:08:49,820 --> 00:08:55,490
want to frost Fibonacci numbers on all

00:08:52,370 --> 00:08:58,339
my cupcakes before I give them to you to

00:08:55,490 --> 00:09:00,830
calculate the Fibonacci number it's o of

00:08:58,339 --> 00:09:04,430
two to the N this is exponential growth

00:09:00,830 --> 00:09:07,010
so the first couple increases in input

00:09:04,430 --> 00:09:09,740
size it's not a huge increase in running

00:09:07,010 --> 00:09:12,290
time but as you go it increases more and

00:09:09,740 --> 00:09:14,839
more becoming steeper and steeper for

00:09:12,290 --> 00:09:15,400
the smaller increases if that makes

00:09:14,839 --> 00:09:18,560
sense

00:09:15,400 --> 00:09:21,440
so calculating the Fibonacci number

00:09:18,560 --> 00:09:24,380
recursively is an exponential algorithm

00:09:21,440 --> 00:09:27,709
it doesn't perform super well don't

00:09:24,380 --> 00:09:33,200
really do it this way but this is just

00:09:27,709 --> 00:09:35,480
one example and then the cousin at least

00:09:33,200 --> 00:09:38,510
in my head the cousin to exponential

00:09:35,480 --> 00:09:41,779
growth is logarithmic growth so o of log

00:09:38,510 --> 00:09:43,220
n where exponential growth increases

00:09:41,779 --> 00:09:45,020
more and more and more and more and gets

00:09:43,220 --> 00:09:47,330
really steep logarithmic growth

00:09:45,020 --> 00:09:49,760
approaches constant time the bigger your

00:09:47,330 --> 00:09:51,770
input size gets so at a certain point

00:09:49,760 --> 00:09:53,930
you hit like a worst case scenario it's

00:09:51,770 --> 00:09:55,940
going it like reaches its worst

00:09:53,930 --> 00:09:58,670
performance and then pretty much levels

00:09:55,940 --> 00:10:01,880
out divide and conquer algorithms are

00:09:58,670 --> 00:10:04,070
usually logarithmic so binary search is

00:10:01,880 --> 00:10:06,440
one example if I wanted to extend my

00:10:04,070 --> 00:10:08,810
cupcake metaphor I might use a

00:10:06,440 --> 00:10:11,300
logarithmic algorithm for handing them

00:10:08,810 --> 00:10:13,670
out where I have all my cupcakes I take

00:10:11,300 --> 00:10:15,920
one and I give half to you and have to

00:10:13,670 --> 00:10:17,930
you you take one and then you each split

00:10:15,920 --> 00:10:20,089
it in half all the way through to the

00:10:17,930 --> 00:10:21,649
back of the room like I said these are

00:10:20,089 --> 00:10:23,839
getting very contrived I didn't

00:10:21,649 --> 00:10:27,709
make you sit through that but that would

00:10:23,839 --> 00:10:31,430
be one example of logarithmic growth so

00:10:27,709 --> 00:10:35,990
when do you use Big O interviews it

00:10:31,430 --> 00:10:37,309
comes up a lot it just does and it's one

00:10:35,990 --> 00:10:39,139
of those things that you can't really

00:10:37,309 --> 00:10:42,470
piece together with context clues like

00:10:39,139 --> 00:10:44,779
you can a linked list it also is really

00:10:42,470 --> 00:10:46,550
a great mechanism for having a shared

00:10:44,779 --> 00:10:48,619
language with other programmers to

00:10:46,550 --> 00:10:51,499
compare the performance of two different

00:10:48,619 --> 00:10:53,749
approaches to the code but if you walk

00:10:51,499 --> 00:10:56,569
away and you don't remember what oh of N

00:10:53,749 --> 00:10:58,670
squared is or what you know exponential

00:10:56,569 --> 00:11:01,429
growth is that's totally cool if all you

00:10:58,670 --> 00:11:04,249
walk away with is the more we nest these

00:11:01,429 --> 00:11:06,079
loops the worse it gets that's amazing

00:11:04,249 --> 00:11:09,499
and that's seriously the best use case

00:11:06,079 --> 00:11:11,300
for a Big O in my opinion all right

00:11:09,499 --> 00:11:12,439
moving right along we're gonna talk

00:11:11,300 --> 00:11:15,350
about set theory

00:11:12,439 --> 00:11:19,160
so Venn diagrams are a great way to

00:11:15,350 --> 00:11:21,860
think about set theory a set is a data

00:11:19,160 --> 00:11:24,559
structure similar to an array but it's

00:11:21,860 --> 00:11:27,790
characterized by being an unordered

00:11:24,559 --> 00:11:30,829
collection and it has no duplicates that

00:11:27,790 --> 00:11:33,199
in and of itself isn't super interesting

00:11:30,829 --> 00:11:35,509
their sets are more interesting by the

00:11:33,199 --> 00:11:38,559
math that we can do on them and this

00:11:35,509 --> 00:11:41,120
math is the foundation of set theory

00:11:38,559 --> 00:11:43,819
this is the Venn diagram that we are

00:11:41,120 --> 00:11:45,829
going to be using throughout this talk I

00:11:43,819 --> 00:11:48,529
truly encourage you to go follow those

00:11:45,829 --> 00:11:50,059
Instagram accounts they're adorable and

00:11:48,529 --> 00:11:53,389
I won't be offended if you're on your

00:11:50,059 --> 00:11:54,970
phone so the first set operation we're

00:11:53,389 --> 00:11:58,279
going to talk about is Union

00:11:54,970 --> 00:12:03,019
mathematically Union is written as X cup

00:11:58,279 --> 00:12:07,850
Y or X Union Y it is all of the things

00:12:03,019 --> 00:12:09,499
that exist in set X or in set Y which is

00:12:07,850 --> 00:12:11,689
why we have everything because

00:12:09,499 --> 00:12:14,569
everything exists in one or the other

00:12:11,689 --> 00:12:17,269
and in this case if I were to curate my

00:12:14,569 --> 00:12:19,759
Instagram feed according to a set Union

00:12:17,269 --> 00:12:21,900
I would have all of the cute animal

00:12:19,759 --> 00:12:24,510
accounts in my feed

00:12:21,900 --> 00:12:30,000
the converse of that is an intersection

00:12:24,510 --> 00:12:32,940
which is X cap Y or X intersect Y and

00:12:30,000 --> 00:12:35,130
it's the stuff that exists in x and y so

00:12:32,940 --> 00:12:37,620
it's only the stuff that exists in both

00:12:35,130 --> 00:12:40,620
which is why we have just this stuff in

00:12:37,620 --> 00:12:42,960
the middle here so this is when I want

00:12:40,620 --> 00:12:44,850
all the cute friendships I only want the

00:12:42,960 --> 00:12:49,710
accounts that have a cute dog and a cute

00:12:44,850 --> 00:12:50,550
cat if I'm a dog person which I am I'm

00:12:49,710 --> 00:12:52,710
very sorry

00:12:50,550 --> 00:12:56,130
I might curate my feed using a set

00:12:52,710 --> 00:12:59,430
difference so just X minus y it's the

00:12:56,130 --> 00:13:02,070
stuff that only exists in set X nothing

00:12:59,430 --> 00:13:04,500
that also exists in set Y which is why

00:13:02,070 --> 00:13:06,900
we get this little like moon shape here

00:13:04,500 --> 00:13:09,000
and so this would be if I didn't want to

00:13:06,900 --> 00:13:12,480
see any cats in my feed I only want dogs

00:13:09,000 --> 00:13:14,930
I would do this if you are a cat person

00:13:12,480 --> 00:13:17,400
you might do the opposite which because

00:13:14,930 --> 00:13:19,110
mathematicians and computer scientists

00:13:17,400 --> 00:13:21,180
love to make everything complicated they

00:13:19,110 --> 00:13:23,130
gave its own name too so instead of just

00:13:21,180 --> 00:13:25,050
being the other difference they call it

00:13:23,130 --> 00:13:28,260
the relative complement and it gets its

00:13:25,050 --> 00:13:30,089
own notation this Y slash X and this

00:13:28,260 --> 00:13:33,810
would give you everything that has cute

00:13:30,089 --> 00:13:36,570
cats and none of the cute dogs it is

00:13:33,810 --> 00:13:40,320
literally the same as Y minus X so like

00:13:36,570 --> 00:13:42,380
don't let that confuse you and then

00:13:40,320 --> 00:13:45,720
finally we have the symmetric difference

00:13:42,380 --> 00:13:47,970
mathematically it's X Delta Y and so

00:13:45,720 --> 00:13:52,230
this would be the things that exist only

00:13:47,970 --> 00:13:55,470
in X or only in Y and none of the stuff

00:13:52,230 --> 00:13:58,200
that's in the intersection if I can't

00:13:55,470 --> 00:14:00,060
handle the cuteness of cat and dog best

00:13:58,200 --> 00:14:02,730
friends because truly it's the greatest

00:14:00,060 --> 00:14:05,520
thing I might say like I can only handle

00:14:02,730 --> 00:14:09,839
cute dogs and cute cats but not both and

00:14:05,520 --> 00:14:12,630
this is what I would do so when do you

00:14:09,839 --> 00:14:15,779
use Venn diagrams if you have ever used

00:14:12,630 --> 00:14:18,029
a relational database set theory forms

00:14:15,779 --> 00:14:20,760
the foundation of relational databases

00:14:18,029 --> 00:14:22,230
when you're writing sequel you're doing

00:14:20,760 --> 00:14:24,660
inner joins you're doing all of that

00:14:22,230 --> 00:14:28,440
you're using set theory in order to

00:14:24,660 --> 00:14:31,290
achieve it from a feature implementation

00:14:28,440 --> 00:14:33,780
standpoint if you are making

00:14:31,290 --> 00:14:36,450
website filters on a website let's say

00:14:33,780 --> 00:14:40,020
like I'm going to buy shoes and I say oh

00:14:36,450 --> 00:14:42,330
I can be a six or a six-and-a-half is in

00:14:40,020 --> 00:14:44,700
the size category and I want brown shoes

00:14:42,330 --> 00:14:47,220
the things that are in the same category

00:14:44,700 --> 00:14:48,870
are a union whereas when they're in

00:14:47,220 --> 00:14:52,400
different categories that becomes an

00:14:48,870 --> 00:14:57,420
intersection so that's also set theory

00:14:52,400 --> 00:15:00,270
all right recursion so Russian nesting

00:14:57,420 --> 00:15:01,950
dolls are a great metaphor for recursion

00:15:00,270 --> 00:15:05,070
because they're all the exact same

00:15:01,950 --> 00:15:05,820
except for size if you have never played

00:15:05,070 --> 00:15:08,310
with them

00:15:05,820 --> 00:15:10,410
the dolls continue you like get the

00:15:08,310 --> 00:15:12,990
biggest one you open it there's another

00:15:10,410 --> 00:15:14,280
one inside of it it opens so you open

00:15:12,990 --> 00:15:15,990
that one and then you just keep going

00:15:14,280 --> 00:15:18,330
until you get to the smallest one which

00:15:15,990 --> 00:15:20,010
usually is just like a solid block of

00:15:18,330 --> 00:15:22,590
wood it doesn't open it doesn't do

00:15:20,010 --> 00:15:26,640
anything and then you close them back up

00:15:22,590 --> 00:15:28,680
in reverse order so recursion is the

00:15:26,640 --> 00:15:32,010
process in which a function calls itself

00:15:28,680 --> 00:15:34,470
directly or indirectly and the function

00:15:32,010 --> 00:15:36,900
that is doing the calling of itself is

00:15:34,470 --> 00:15:38,850
called the recursive function so if

00:15:36,900 --> 00:15:40,920
you're in an interview and somebody asks

00:15:38,850 --> 00:15:43,350
you like what's the recursive function

00:15:40,920 --> 00:15:47,100
it's not a trick question it's just the

00:15:43,350 --> 00:15:49,110
one that calls itself when you are

00:15:47,100 --> 00:15:51,810
writing a recursive function we don't

00:15:49,110 --> 00:15:53,280
want it to call itself indefinitely like

00:15:51,810 --> 00:15:54,810
we don't want to get ourself in an

00:15:53,280 --> 00:15:57,540
infinite loop have a stack overflow

00:15:54,810 --> 00:15:59,940
exception it's just not great so you

00:15:57,540 --> 00:16:03,900
need to find one case that returns a

00:15:59,940 --> 00:16:06,840
finite like discrete discrete value and

00:16:03,900 --> 00:16:09,180
that's called the base case in recursion

00:16:06,840 --> 00:16:11,640
when you are trying to write a recursive

00:16:09,180 --> 00:16:14,010
function the base case is the easiest

00:16:11,640 --> 00:16:17,430
place to start and then build out from

00:16:14,010 --> 00:16:19,680
there so in Russian nesting dolls that

00:16:17,430 --> 00:16:21,780
smallest child that doesn't open that's

00:16:19,680 --> 00:16:24,720
the base case and we'll look at an

00:16:21,780 --> 00:16:27,450
example here so here we have two

00:16:24,720 --> 00:16:29,610
functions we have count and then we have

00:16:27,450 --> 00:16:31,770
count nested dolls so I'm asking you

00:16:29,610 --> 00:16:34,500
here's a big doll tell me how many

00:16:31,770 --> 00:16:37,110
nested dolls there are the recursive

00:16:34,500 --> 00:16:39,230
function here is count nested dolls

00:16:37,110 --> 00:16:42,930
because that's the one that calls itself

00:16:39,230 --> 00:16:44,880
a recursive function almost always takes

00:16:42,930 --> 00:16:46,740
a parameter or parameters

00:16:44,880 --> 00:16:49,589
unless you're doing something funky with

00:16:46,740 --> 00:16:51,750
instance variables or global state in

00:16:49,589 --> 00:16:54,990
some way which don't it's a little

00:16:51,750 --> 00:17:00,180
confusing but and so what happens here

00:16:54,990 --> 00:17:02,550
is we pass in the biggest doll and we

00:17:00,180 --> 00:17:05,939
open it and there's a child in it right

00:17:02,550 --> 00:17:07,949
and so we go okay there's a child so I'm

00:17:05,939 --> 00:17:10,319
going to continue to open it but when I

00:17:07,949 --> 00:17:13,679
come back and go to close it up and come

00:17:10,319 --> 00:17:16,799
out of this call stack I'm going to

00:17:13,679 --> 00:17:18,720
remember to add one okay cool so biggest

00:17:16,799 --> 00:17:20,850
I'll open I'm in the next one I open it

00:17:18,720 --> 00:17:23,220
it also has a child so I'm going to come

00:17:20,850 --> 00:17:24,630
back down into here call it again I'm

00:17:23,220 --> 00:17:26,429
gonna open it but I'm gonna remember

00:17:24,630 --> 00:17:28,559
when I come back out of this call stack

00:17:26,429 --> 00:17:30,090
I'm gonna add one you continue to do

00:17:28,559 --> 00:17:32,159
that until you get to the smallest doll

00:17:30,090 --> 00:17:34,710
remember it's a solid block of wood it

00:17:32,159 --> 00:17:38,039
doesn't open I try to open it there's no

00:17:34,710 --> 00:17:41,669
child that's there's nothing to open so

00:17:38,039 --> 00:17:43,530
I'm at my base case and I return one so

00:17:41,669 --> 00:17:45,030
I'm gonna put it back in its parent and

00:17:43,530 --> 00:17:46,230
close its parent and remember when I

00:17:45,030 --> 00:17:48,240
said I closed my parent I'm gonna

00:17:46,230 --> 00:17:50,850
remember oh I'm gonna add one so I've

00:17:48,240 --> 00:17:53,370
got to put that in its parent close it

00:17:50,850 --> 00:17:55,710
remember I'm adding 1/3 up the call

00:17:53,370 --> 00:17:58,820
stack until I'm exited and I handed you

00:17:55,710 --> 00:18:04,159
eight dolls or whatever it is

00:17:58,820 --> 00:18:06,809
so recursion is just fancy looping

00:18:04,159 --> 00:18:09,059
anything that you can do iteratively you

00:18:06,809 --> 00:18:13,559
can also do recursively and vice versa

00:18:09,059 --> 00:18:15,750
but recursion as you might know because

00:18:13,559 --> 00:18:17,760
it is kind of an intimidating topic is

00:18:15,750 --> 00:18:18,510
sometimes hard to read it's hard to

00:18:17,760 --> 00:18:22,380
understand

00:18:18,510 --> 00:18:24,900
and so nested hierarchies tend to lend

00:18:22,380 --> 00:18:28,650
themselves best to using recursion to

00:18:24,900 --> 00:18:30,480
solve them if you're making a mega menu

00:18:28,650 --> 00:18:32,730
on a website you're calculating where

00:18:30,480 --> 00:18:34,830
you're at and a breadcrumb you're trying

00:18:32,730 --> 00:18:37,470
to render a file structure anything with

00:18:34,830 --> 00:18:38,549
nested hierarchies recursion usually

00:18:37,470 --> 00:18:42,080
works really well because you'll come

00:18:38,549 --> 00:18:44,520
back excuse me in 6 months and go oh

00:18:42,080 --> 00:18:46,559
conceptually this is how I would model

00:18:44,520 --> 00:18:48,360
it in my head this makes sense whereas

00:18:46,559 --> 00:18:50,370
things that are more flat when you try

00:18:48,360 --> 00:18:51,600
to do them recursively can be really

00:18:50,370 --> 00:18:53,549
hard to wrap your head around because

00:18:51,600 --> 00:18:54,510
your mental model just doesn't work that

00:18:53,549 --> 00:18:56,710
way

00:18:54,510 --> 00:18:59,500
all right now we're going to get into

00:18:56,710 --> 00:19:01,780
the four principles of object-oriented

00:18:59,500 --> 00:19:03,370
programming so if you're ever in an

00:19:01,780 --> 00:19:04,690
interview and you get asked what are the

00:19:03,370 --> 00:19:07,270
four principles of object-oriented

00:19:04,690 --> 00:19:09,750
programming you will be able to answer

00:19:07,270 --> 00:19:13,900
this now so the first one is

00:19:09,750 --> 00:19:18,160
encapsulation do we have any horse

00:19:13,900 --> 00:19:20,260
people here yeah yeah one okay cool well

00:19:18,160 --> 00:19:24,130
then you all won't know if I get this

00:19:20,260 --> 00:19:25,059
wrong so horses I had to do research for

00:19:24,130 --> 00:19:28,600
this they didn't tell us

00:19:25,059 --> 00:19:30,429
horses have four main gates they can

00:19:28,600 --> 00:19:32,710
walk they can trot

00:19:30,429 --> 00:19:35,020
they can canter and they can gallop a

00:19:32,710 --> 00:19:37,050
walk is characterized by a four beat

00:19:35,020 --> 00:19:39,670
pace it's the slowest of their gates

00:19:37,050 --> 00:19:41,770
trot is a to beat gait it's a little bit

00:19:39,670 --> 00:19:43,960
faster then you've got a canter which is

00:19:41,770 --> 00:19:45,850
a three beat gait it's even faster and

00:19:43,960 --> 00:19:47,980
then an all-out gallop is their fastest

00:19:45,850 --> 00:19:49,770
and we're back to a four beat gate they

00:19:47,980 --> 00:19:52,600
move their legs in different orders

00:19:49,770 --> 00:19:53,890
sometimes at the same time sometimes

00:19:52,600 --> 00:19:55,090
they start in the back sometimes they

00:19:53,890 --> 00:19:58,270
start in the front they're all very

00:19:55,090 --> 00:20:00,280
different so if I were to make a very

00:19:58,270 --> 00:20:01,840
fun exciting video game where I go I

00:20:00,280 --> 00:20:05,020
need you to move a horse across the

00:20:01,840 --> 00:20:08,530
screen would you want to say if I go I

00:20:05,020 --> 00:20:10,929
need it to walk 30 steps would you want

00:20:08,530 --> 00:20:13,390
to know like okay so first they lift

00:20:10,929 --> 00:20:15,400
their back left leg and down and then

00:20:13,390 --> 00:20:17,710
their front right leg and down and then

00:20:15,400 --> 00:20:19,750
their back right leg and down and then

00:20:17,710 --> 00:20:23,260
their front left like it's oh my god

00:20:19,750 --> 00:20:25,000
please no that doesn't I mean I know the

00:20:23,260 --> 00:20:27,820
game isn't fun on its own but that

00:20:25,000 --> 00:20:31,090
sounds even worse so instead I would

00:20:27,820 --> 00:20:32,530
probably create four methods for you to

00:20:31,090 --> 00:20:37,330
use and then you would tell the horse

00:20:32,530 --> 00:20:40,660
like walk 30 steps gallop 70 steps right

00:20:37,330 --> 00:20:42,970
so these methods would encapsulate the

00:20:40,660 --> 00:20:45,940
state of the horse's legs at any given

00:20:42,970 --> 00:20:47,530
point in time this will help make sure

00:20:45,940 --> 00:20:49,540
that you don't break your horse and

00:20:47,530 --> 00:20:51,880
somehow end up with three legs off the

00:20:49,540 --> 00:20:53,470
ground when they're not supposed to and

00:20:51,880 --> 00:20:54,600
it also gives you just a much better

00:20:53,470 --> 00:20:59,110
experience

00:20:54,600 --> 00:21:02,590
so encapsulation is when you hide an

00:20:59,110 --> 00:21:04,720
object's state from other objects you

00:21:02,590 --> 00:21:06,179
create a public interface which is just

00:21:04,720 --> 00:21:09,570
a fancy way of saying

00:21:06,179 --> 00:21:12,059
method for other objects to mutate your

00:21:09,570 --> 00:21:14,279
object state in this case it's a horse

00:21:12,059 --> 00:21:17,190
and it the state is where are their legs

00:21:14,279 --> 00:21:19,740
at any given point in time but you know

00:21:17,190 --> 00:21:21,659
it could be you know your web component

00:21:19,740 --> 00:21:23,580
or anything else like what is your state

00:21:21,659 --> 00:21:25,679
that you don't want other objects to

00:21:23,580 --> 00:21:26,850
mutate directly because they don't know

00:21:25,679 --> 00:21:30,509
your constraints they don't know what

00:21:26,850 --> 00:21:32,159
they could break so if we look at what

00:21:30,509 --> 00:21:35,100
it would look like if I were to

00:21:32,159 --> 00:21:37,649
encapsulate the horses state for a

00:21:35,100 --> 00:21:39,929
canter it might look like this a cancer

00:21:37,649 --> 00:21:42,330
is a three-beat gait so you can see here

00:21:39,929 --> 00:21:43,860
I move the first leg up and down the

00:21:42,330 --> 00:21:47,100
next to come up and down at the same

00:21:43,860 --> 00:21:49,590
time and then the last one I kind of

00:21:47,100 --> 00:21:53,009
munched the whole idea of how fast they

00:21:49,590 --> 00:21:55,590
move but what your user or your other

00:21:53,009 --> 00:21:57,720
objects would see is they would just get

00:21:55,590 --> 00:21:59,999
a new horse and they would say canter

00:21:57,720 --> 00:22:02,039
for however many steps I told you so

00:21:59,999 --> 00:22:04,409
you've completely encapsulated the state

00:22:02,039 --> 00:22:06,509
of their legs of your horses legs from

00:22:04,409 --> 00:22:08,549
the other object but they still get to

00:22:06,509 --> 00:22:09,179
tell your object like I need you to do

00:22:08,549 --> 00:22:13,580
this thing

00:22:09,179 --> 00:22:19,200
so that's encapsulation next up is

00:22:13,580 --> 00:22:22,559
abstraction when you push a button on a

00:22:19,200 --> 00:22:25,409
remote control something happens on your

00:22:22,559 --> 00:22:28,200
TV right so the volume goes up the

00:22:25,409 --> 00:22:31,649
channel changes it turns off whatever

00:22:28,200 --> 00:22:33,450
there are like very few I mean nowadays

00:22:31,649 --> 00:22:35,820
remotes have lots of buttons but like

00:22:33,450 --> 00:22:38,009
there are a finite number of things that

00:22:35,820 --> 00:22:40,499
you can do and you don't need to know

00:22:38,009 --> 00:22:42,179
how it works in order for like that

00:22:40,499 --> 00:22:44,490
thing to happen so you don't need to

00:22:42,179 --> 00:22:46,559
know to change the channel that when you

00:22:44,490 --> 00:22:48,779
push a button it somehow gets encoded

00:22:46,559 --> 00:22:50,730
into binary which then gets encoded into

00:22:48,779 --> 00:22:53,220
infrared light it gets sent to your TV

00:22:50,730 --> 00:22:54,809
your TV decodes the light back into

00:22:53,220 --> 00:22:57,360
binary sends it to the microprocessor

00:22:54,809 --> 00:22:59,490
and then does even more stuff to change

00:22:57,360 --> 00:23:01,529
the state of your TV you don't need to

00:22:59,490 --> 00:23:03,499
know that you pushed a button and the

00:23:01,529 --> 00:23:07,170
channel changed which is wonderful

00:23:03,499 --> 00:23:09,420
so that's an abstraction

00:23:07,170 --> 00:23:11,530
abstraction is an extension of

00:23:09,420 --> 00:23:13,299
encapsulation and it can sometimes be

00:23:11,530 --> 00:23:15,760
really challenging to explain the

00:23:13,299 --> 00:23:17,799
difference so abstraction refers to

00:23:15,760 --> 00:23:19,840
hiding all of the internal

00:23:17,799 --> 00:23:22,690
implementation details of a class and

00:23:19,840 --> 00:23:24,549
providing very few clear mechanisms for

00:23:22,690 --> 00:23:26,730
other objects in the code to interact

00:23:24,549 --> 00:23:29,860
with it

00:23:26,730 --> 00:23:32,429
encapsulation you don't let other things

00:23:29,860 --> 00:23:34,900
mutate the state of your object

00:23:32,429 --> 00:23:37,240
abstraction is you're hiding all of the

00:23:34,900 --> 00:23:39,190
implementation details of the class or

00:23:37,240 --> 00:23:40,780
system from other objects so they're

00:23:39,190 --> 00:23:43,480
very closely related but they're

00:23:40,780 --> 00:23:46,450
slightly different and you can create

00:23:43,480 --> 00:23:49,030
different abstractions so if you've ever

00:23:46,450 --> 00:23:50,770
been in a code review or just in a team

00:23:49,030 --> 00:23:53,020
meeting and you've heard somebody go we

00:23:50,770 --> 00:23:56,919
made the wrong extraction you're like

00:23:53,020 --> 00:24:00,040
but it does the thing what they mean is

00:23:56,919 --> 00:24:02,230
that the way that other objects interact

00:24:00,040 --> 00:24:04,210
with it is not quite right doesn't quite

00:24:02,230 --> 00:24:07,570
meet requirements or is just a little

00:24:04,210 --> 00:24:11,020
clumsy if you think about back to the

00:24:07,570 --> 00:24:12,580
TVs in the 50s 60s 70s the abstraction

00:24:11,020 --> 00:24:14,590
at that point was like I want to change

00:24:12,580 --> 00:24:16,840
the channel I get up off the couch I

00:24:14,590 --> 00:24:19,030
walk over I turned the knob and then I

00:24:16,840 --> 00:24:21,400
go back and I sit down watch it for 30

00:24:19,030 --> 00:24:23,710
seconds go that's boring get back up go

00:24:21,400 --> 00:24:25,360
turn the knob and sit down and so in the

00:24:23,710 --> 00:24:27,669
80s we were like wouldn't it be better

00:24:25,360 --> 00:24:29,679
if I just push a button so you made a

00:24:27,669 --> 00:24:31,510
different abstraction but the TV's still

00:24:29,679 --> 00:24:35,380
doing the same thing just how you

00:24:31,510 --> 00:24:36,880
interact with it is different so for

00:24:35,380 --> 00:24:39,360
example this might be how we

00:24:36,880 --> 00:24:42,820
programmatically model a remote control

00:24:39,360 --> 00:24:47,200
you have a remote in a television and I

00:24:42,820 --> 00:24:50,169
say like turn on turn up turn up to loud

00:24:47,200 --> 00:24:51,790
turn down but what you don't see and

00:24:50,169 --> 00:24:54,040
what other objects in the system don't

00:24:51,790 --> 00:24:55,690
see is that all this other stuff is

00:24:54,040 --> 00:24:58,450
happening everything that I walked you

00:24:55,690 --> 00:25:01,240
through before where it's handling the

00:24:58,450 --> 00:25:03,250
click of the button encoding it into

00:25:01,240 --> 00:25:05,169
binary converting that to infrared light

00:25:03,250 --> 00:25:07,390
sending it to the TV and then obviously

00:25:05,169 --> 00:25:09,600
there's all the stuff the TV does to

00:25:07,390 --> 00:25:13,060
make that happen

00:25:09,600 --> 00:25:14,980
all right we got one into onto number

00:25:13,060 --> 00:25:19,840
three which is inheritance

00:25:14,980 --> 00:25:23,050
so all garden plants need Sun soil water

00:25:19,840 --> 00:25:25,330
to survive and if you're like me I have

00:25:23,050 --> 00:25:28,630
a black thumb I can't keep anything

00:25:25,330 --> 00:25:30,580
alive truly and so when I go to for me

00:25:28,630 --> 00:25:32,770
its Home Depot but like whatever store

00:25:30,580 --> 00:25:35,800
has their garden center I read those

00:25:32,770 --> 00:25:37,300
little cards so closely that they like

00:25:35,800 --> 00:25:39,520
stick in the dirt so Mike I don't want

00:25:37,300 --> 00:25:40,900
to kill this plant do you how much water

00:25:39,520 --> 00:25:42,430
do you need how much Sun do you need

00:25:40,900 --> 00:25:45,250
like I'm gonna make this perfect and

00:25:42,430 --> 00:25:47,380
they still died but you know like you

00:25:45,250 --> 00:25:50,650
want to learn everything you can about

00:25:47,380 --> 00:25:52,360
how to take care of this plant so if we

00:25:50,650 --> 00:25:55,030
were gonna code up an app that like

00:25:52,360 --> 00:25:56,770
created those little cards from

00:25:55,030 --> 00:26:00,040
information that we have about all those

00:25:56,770 --> 00:26:03,370
plants we might use inheritance to share

00:26:00,040 --> 00:26:05,680
the code that prints out like accesses

00:26:03,370 --> 00:26:06,970
all of the plants some needs what are

00:26:05,680 --> 00:26:09,250
their light needs what are their soil

00:26:06,970 --> 00:26:12,280
needs and print them out in a human

00:26:09,250 --> 00:26:14,830
understandable like sentence so

00:26:12,280 --> 00:26:18,280
inheritance supports reusability in

00:26:14,830 --> 00:26:20,350
programming there's a child class also

00:26:18,280 --> 00:26:22,510
sometimes known as a sub class because

00:26:20,350 --> 00:26:26,080
again computer scientists love lots of

00:26:22,510 --> 00:26:28,030
words and so the child class can inherit

00:26:26,080 --> 00:26:31,150
all of the fields and properties and

00:26:28,030 --> 00:26:34,240
methods from its parent class base class

00:26:31,150 --> 00:26:36,160
super class pick one they all are at the

00:26:34,240 --> 00:26:39,910
same thing it's the class that you

00:26:36,160 --> 00:26:42,730
inherit from and so a child class can

00:26:39,910 --> 00:26:44,740
inherit all of the code from its parent

00:26:42,730 --> 00:26:47,230
class and then it can also choose to

00:26:44,740 --> 00:26:50,230
implement on top of that its own code

00:26:47,230 --> 00:26:52,300
that either slightly changes the parent

00:26:50,230 --> 00:26:53,550
classes behavior or just builds on top

00:26:52,300 --> 00:26:56,670
of it

00:26:53,550 --> 00:26:59,520
for example if we were to make an app

00:26:56,670 --> 00:27:02,610
that printed out how to take care of

00:26:59,520 --> 00:27:06,900
each plant I might have a base class of

00:27:02,610 --> 00:27:09,510
plant that has some attribute readers

00:27:06,900 --> 00:27:11,700
for you know what is it named how much

00:27:09,510 --> 00:27:13,890
light doesn't need and then has some

00:27:11,700 --> 00:27:16,290
methods so that we can print out how to

00:27:13,890 --> 00:27:18,120
plant it how to take care of it and then

00:27:16,290 --> 00:27:20,760
put it all together in a way that makes

00:27:18,120 --> 00:27:23,250
sense where I want to know the name how

00:27:20,760 --> 00:27:27,210
to plant it how to take care of it

00:27:23,250 --> 00:27:31,350
and so then if I have children classes

00:27:27,210 --> 00:27:34,200
of that which this spot right here over

00:27:31,350 --> 00:27:36,360
on the side tells it that geranium

00:27:34,200 --> 00:27:39,299
inherits from plant

00:27:36,360 --> 00:27:41,970
so now geranium has access to everything

00:27:39,299 --> 00:27:44,309
that we saw over here and then it just

00:27:41,970 --> 00:27:46,799
has one it just has its constructor

00:27:44,309 --> 00:27:48,620
where it sets its instance variables so

00:27:46,799 --> 00:27:52,049
that you know the geranium is named

00:27:48,620 --> 00:27:55,830
geranium and it likes Sun and it likes

00:27:52,049 --> 00:27:58,440
to be dry and then that's all you have

00:27:55,830 --> 00:28:03,000
to do you don't have to define any of

00:27:58,440 --> 00:28:06,360
the other methods but over here then I

00:28:03,000 --> 00:28:08,340
can make a collection of plants and for

00:28:06,360 --> 00:28:09,929
each one of them if they all inherit

00:28:08,340 --> 00:28:12,630
from plant

00:28:09,929 --> 00:28:14,940
I can just say learn how to garden and

00:28:12,630 --> 00:28:17,100
so even though I didn't define that

00:28:14,940 --> 00:28:19,950
method in the child class because it

00:28:17,100 --> 00:28:22,740
inherits from plant it has access to it

00:28:19,950 --> 00:28:24,929
and so then it will print out all those

00:28:22,740 --> 00:28:27,000
instructions in a way that hopefully I

00:28:24,929 --> 00:28:31,440
will understand and not kill my

00:28:27,000 --> 00:28:33,470
geraniums and then the last principle of

00:28:31,440 --> 00:28:37,169
object-oriented programming is

00:28:33,470 --> 00:28:40,289
polymorphism so if you are an avid

00:28:37,169 --> 00:28:42,240
crafter I am I crochet I love it it's

00:28:40,289 --> 00:28:45,030
great if you do come find me we'll chat

00:28:42,240 --> 00:28:46,950
about it but you know that there are

00:28:45,030 --> 00:28:49,200
lots of different crafts that you can

00:28:46,950 --> 00:28:52,350
use to do essentially the same thing

00:28:49,200 --> 00:28:54,360
which is make a fabric and though like

00:28:52,350 --> 00:28:56,190
the type of the fabric might be

00:28:54,360 --> 00:28:57,510
different and the characteristics of it

00:28:56,190 --> 00:29:00,530
might be different at the end of the day

00:28:57,510 --> 00:29:03,450
you did the same thing you made a fabric

00:29:00,530 --> 00:29:04,980
so if you were to model that

00:29:03,450 --> 00:29:07,320
programmatically you might take

00:29:04,980 --> 00:29:09,360
advantage of polymorphism so

00:29:07,320 --> 00:29:11,659
polymorphism is an object-oriented

00:29:09,360 --> 00:29:15,480
concept where you can use multiple

00:29:11,659 --> 00:29:18,919
classes in exactly the same way so there

00:29:15,480 --> 00:29:22,140
concrete implementation doesn't matter

00:29:18,919 --> 00:29:24,539
inheritance which we just saw is one way

00:29:22,140 --> 00:29:26,400
to achieve polymorphism where they all

00:29:24,539 --> 00:29:28,350
inherit from plant and then I can use

00:29:26,400 --> 00:29:30,090
that learn how to garden method and I

00:29:28,350 --> 00:29:32,970
don't care if it's a geranium or a

00:29:30,090 --> 00:29:36,140
begonia or whatever but there are other

00:29:32,970 --> 00:29:39,230
ways to achieve polymorphism one is duck

00:29:36,140 --> 00:29:40,850
typing so very popular in the Ruby

00:29:39,230 --> 00:29:43,820
community and that's where you define

00:29:40,850 --> 00:29:45,530
the same method name same signature on

00:29:43,820 --> 00:29:47,750
lots of different classes and then you

00:29:45,530 --> 00:29:50,510
can use all of those classes and it'll

00:29:47,750 --> 00:29:52,700
just work if it walks like a duck and

00:29:50,510 --> 00:29:55,880
talks like a duck it is a duck duck

00:29:52,700 --> 00:29:58,220
typing but if you are working in a

00:29:55,880 --> 00:30:01,160
statically typed language you may choose

00:29:58,220 --> 00:30:04,040
to use an interface which just is like a

00:30:01,160 --> 00:30:07,100
contract that says you must implement

00:30:04,040 --> 00:30:09,170
these methods with these signatures and

00:30:07,100 --> 00:30:11,590
so it's like takes duck typing to a new

00:30:09,170 --> 00:30:14,270
level where it's just actually enforced

00:30:11,590 --> 00:30:19,940
so in our example we're gonna use duck

00:30:14,270 --> 00:30:22,970
typing here we've got a create fabric

00:30:19,940 --> 00:30:25,490
method this is on a knitting class and

00:30:22,970 --> 00:30:29,120
so to knit if you want to create a

00:30:25,490 --> 00:30:31,550
fabric you you know knit weight is this

00:30:29,120 --> 00:30:33,740
yeah you knit a row purl a row knit a

00:30:31,550 --> 00:30:37,790
row purl a row and you'll create a

00:30:33,740 --> 00:30:41,000
fabric but if I don't want to do that

00:30:37,790 --> 00:30:44,420
and instead I want to weave my fabric

00:30:41,000 --> 00:30:46,640
I still have a create fabric method

00:30:44,420 --> 00:30:49,670
takes the exact same argument as

00:30:46,640 --> 00:30:51,200
knitting but it's concrete

00:30:49,670 --> 00:30:52,940
implementation is different right

00:30:51,200 --> 00:30:55,280
because with weaving you're like weaving

00:30:52,940 --> 00:30:56,600
a thread over under over under and then

00:30:55,280 --> 00:30:58,490
back the other way

00:30:56,600 --> 00:31:01,610
so you create a different type of fabric

00:30:58,490 --> 00:31:02,990
and if neither one of those is what you

00:31:01,610 --> 00:31:04,670
want instead you're like me and you're

00:31:02,990 --> 00:31:06,050
like I want to crochet it's simple hard

00:31:04,670 --> 00:31:08,990
to mess up you don't have to count as

00:31:06,050 --> 00:31:12,400
much you might do this again notice

00:31:08,990 --> 00:31:15,620
create fabric takes the same parameter

00:31:12,400 --> 00:31:18,020
but it's implementation is very simple

00:31:15,620 --> 00:31:20,100
you just make stitches that's it you

00:31:18,020 --> 00:31:23,850
can't mess it up

00:31:20,100 --> 00:31:25,350
but when it comes time to actually use

00:31:23,850 --> 00:31:28,440
them let's say that I have a little web

00:31:25,350 --> 00:31:30,630
app that's like hey pick your favorite

00:31:28,440 --> 00:31:33,210
craft tell me how much fabric you want

00:31:30,630 --> 00:31:36,330
to make and we will output it you'll see

00:31:33,210 --> 00:31:38,130
here that I'll just read it from the

00:31:36,330 --> 00:31:41,400
input whatever the person told me so

00:31:38,130 --> 00:31:44,130
they're like I like to weave cool so I

00:31:41,400 --> 00:31:46,590
can store the class in a variable here

00:31:44,130 --> 00:31:47,880
doesn't matter which it is it just

00:31:46,590 --> 00:31:50,520
becomes this variable

00:31:47,880 --> 00:31:53,550
I'll instantiate a new instance of it

00:31:50,520 --> 00:31:56,280
and then I can just use it to create

00:31:53,550 --> 00:31:58,950
fabric because they all have that method

00:31:56,280 --> 00:32:01,410
with that with those parameters defined

00:31:58,950 --> 00:32:04,530
it will work and so now I've been able

00:32:01,410 --> 00:32:06,690
to use any concrete class regardless of

00:32:04,530 --> 00:32:11,400
its implementation in the same way which

00:32:06,690 --> 00:32:15,120
achieves polymorphism awesome we did

00:32:11,400 --> 00:32:18,540
really good on time great so if you

00:32:15,120 --> 00:32:20,670
liked this I had to cut a section on

00:32:18,540 --> 00:32:23,460
data structures out of the middle of it

00:32:20,670 --> 00:32:26,070
but you can find the slides for it as

00:32:23,460 --> 00:32:27,810
well as the code samples I did include

00:32:26,070 --> 00:32:31,440
the data structures code samples if you

00:32:27,810 --> 00:32:34,790
like it up on my website and I'm happy

00:32:31,440 --> 00:32:34,790
to take questions if there are any

00:32:34,880 --> 00:32:46,319
[Applause]

00:32:38,900 --> 00:32:46,319
[Music]

00:32:46,830 --> 00:32:48,890

YouTube URL: https://www.youtube.com/watch?v=IhD-9Xvbnt0


