Title: RubyConf 2019 - Digesting MRI by Studying Alternative Ruby Implementations by Christian Bruckmayer
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Digesting MRI by Studying Alternative Ruby Implementations by Christian Bruckmayer

Pointers, managing memory and static typing - writing C code is hard! However, most programming languages, including Matz's Ruby Interpreter (MRI), are implemented in a low level programming language. So you think without knowing these concepts, you can not contribute to Ruby? Wrong! Although MRI is implemented in C, fortunately there are Ruby's in Java, Go and even Ruby itself.


If you ever wanted to learn about Ruby internals without being a C expert, this talk is for you. Join me on my journey of re-implementing hash maps in JRuby, breaking bundler and actually learn to write (some) C code.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,440 --> 00:00:23,150
hello hello rubicon hey I hope you all

00:00:19,230 --> 00:00:26,190
had a great lunch welcome to my talk and

00:00:23,150 --> 00:00:30,119
I would like to start my talk with a

00:00:26,190 --> 00:00:33,449
little story and it's about my first job

00:00:30,119 --> 00:00:35,159
in like my was actually my last job in

00:00:33,449 --> 00:00:38,249
it was the first job what I had after

00:00:35,159 --> 00:00:41,039
university and I was one of the first

00:00:38,249 --> 00:00:43,739
engineers in the team there was only my

00:00:41,039 --> 00:00:46,920
boss and another engineer and then I

00:00:43,739 --> 00:00:48,690
joined and over time we started to grow

00:00:46,920 --> 00:00:51,749
this team and we hired more and more

00:00:48,690 --> 00:00:55,979
developers so in the end we had around

00:00:51,749 --> 00:00:57,629
12 developers and so over this time I

00:00:55,979 --> 00:00:59,850
was helping onboarding all these new

00:00:57,629 --> 00:01:03,329
engineers I did peer programming and

00:00:59,850 --> 00:01:06,930
more programming and I I was taking more

00:01:03,329 --> 00:01:09,390
and more responsibilities and at some

00:01:06,930 --> 00:01:12,600
point I got promoted to be a senior

00:01:09,390 --> 00:01:14,550
developer and it was still one of my

00:01:12,600 --> 00:01:16,740
first it was still my first job and I

00:01:14,550 --> 00:01:21,560
was like a point in my career where were

00:01:16,740 --> 00:01:24,570
sitting down and thinking and reflecting

00:01:21,560 --> 00:01:26,190
what is a senior developer what is

00:01:24,570 --> 00:01:30,090
actually a senior developer so I was

00:01:26,190 --> 00:01:31,500
sitting down thinking about it and so

00:01:30,090 --> 00:01:33,600
one thing what came to my mind is

00:01:31,500 --> 00:01:36,300
experience so probably most of you would

00:01:33,600 --> 00:01:38,580
agree somebody was like with a software

00:01:36,300 --> 00:01:40,950
engineer for 10 years 15 years was a lot

00:01:38,580 --> 00:01:43,950
of experience is maybe a senior

00:01:40,950 --> 00:01:46,710
developer or somebody who provides

00:01:43,950 --> 00:01:49,380
leadership who can help bring a feature

00:01:46,710 --> 00:01:52,200
from inception to production and split

00:01:49,380 --> 00:01:56,040
it up and delegate different work tasks

00:01:52,200 --> 00:01:57,659
with different developers or maybe

00:01:56,040 --> 00:01:59,909
somebody who is a good mentor who can

00:01:57,659 --> 00:02:04,080
help junior developers to level up to

00:01:59,909 --> 00:02:07,470
become better telev developers and one

00:02:04,080 --> 00:02:10,200
thing one thing what also came to my

00:02:07,470 --> 00:02:12,780
mind is somebody was a really good

00:02:10,200 --> 00:02:14,340
programmer like master's programming is

00:02:12,780 --> 00:02:16,379
like it's a little bit

00:02:14,340 --> 00:02:19,250
but somebody was a really good

00:02:16,379 --> 00:02:22,319
programmer and I was a Ruby programmer

00:02:19,250 --> 00:02:25,110
so for me it was somebody was really

00:02:22,319 --> 00:02:27,360
good in programming Ruby so it was

00:02:25,110 --> 00:02:31,410
sitting down and thinking like how can I

00:02:27,360 --> 00:02:32,310
become a better Ruby programmer and it

00:02:31,410 --> 00:02:35,489
came to my mind

00:02:32,310 --> 00:02:37,530
Ruby is just a computer program so and

00:02:35,489 --> 00:02:39,299
as you can study arrays application to

00:02:37,530 --> 00:02:41,849
understand it better you could just

00:02:39,299 --> 00:02:44,580
study Ruby to become a better Ruby

00:02:41,849 --> 00:02:46,799
programmer and that is a topic of my

00:02:44,580 --> 00:02:48,480
talk today start testing MRI

00:02:46,799 --> 00:02:51,840
by studying alternative Ruby

00:02:48,480 --> 00:02:55,530
implementations my name is Christian

00:02:51,840 --> 00:02:57,959
Brooke Maya most of what I talk today is

00:02:55,530 --> 00:03:00,629
on my website brookmire dotnet so I

00:02:57,959 --> 00:03:03,569
wrote a few blog articles most stuff

00:03:00,629 --> 00:03:06,090
about JRuby about the performance work I

00:03:03,569 --> 00:03:08,549
did there so if you're interested if you

00:03:06,090 --> 00:03:13,200
want to learn more and also see more

00:03:08,549 --> 00:03:14,670
benchmarks then go to my blog I live at

00:03:13,200 --> 00:03:17,099
the moment in Bristol in the United

00:03:14,670 --> 00:03:19,200
Kingdom Bristol is around two hours away

00:03:17,099 --> 00:03:22,940
from London so it's not London and there

00:03:19,200 --> 00:03:26,639
are more cities in England except London

00:03:22,940 --> 00:03:28,859
I currently work at route pet so they're

00:03:26,639 --> 00:03:31,829
global headquarter of cook pet is also

00:03:28,859 --> 00:03:33,900
in Bristol if you're into home cooking

00:03:31,829 --> 00:03:35,970
definitely check out cook pad if you're

00:03:33,900 --> 00:03:41,069
interested in cooking then talk to me

00:03:35,970 --> 00:03:43,560
after the after the talk and today I

00:03:41,069 --> 00:03:46,859
brought three different examples to you

00:03:43,560 --> 00:03:48,870
so one example is about MRI my second

00:03:46,859 --> 00:03:51,660
example is about rubinius and opal and

00:03:48,870 --> 00:03:54,090
the last example it's about JRuby so the

00:03:51,660 --> 00:03:57,950
first two examples are quite small and

00:03:54,090 --> 00:04:02,819
then most stuff I will talk about JRuby

00:03:57,950 --> 00:04:05,970
so let's get started so my first example

00:04:02,819 --> 00:04:08,639
is about MRI see Ruby

00:04:05,970 --> 00:04:11,099
so if most peak most people when they

00:04:08,639 --> 00:04:13,799
speak about Ruby they mean actually MRI

00:04:11,099 --> 00:04:16,950
which is the reference implementation of

00:04:13,799 --> 00:04:20,489
Ruby started by mots in 1993 it's

00:04:16,950 --> 00:04:23,219
implemented in C and I said like it's

00:04:20,489 --> 00:04:27,250
most people when they mean Ruby they

00:04:23,219 --> 00:04:29,230
mean MRI so

00:04:27,250 --> 00:04:31,810
recap I wanted to become a better Ruby

00:04:29,230 --> 00:04:36,450
programmer I thought Ruby is a computer

00:04:31,810 --> 00:04:40,570
program so I will just go to to github

00:04:36,450 --> 00:04:42,610
read the Ruby source code go to the Ruby

00:04:40,570 --> 00:04:44,500
issue tracker maybe fix a bug implement

00:04:42,610 --> 00:04:51,160
a feature and eventually I will be a

00:04:44,500 --> 00:04:52,990
better Ruby programmer so my first step

00:04:51,160 --> 00:04:55,060
was I went to the Ruby issue tracker

00:04:52,990 --> 00:04:57,610
browse around search for features or

00:04:55,060 --> 00:05:00,760
bugs I could work on and they found this

00:04:57,610 --> 00:05:03,760
issue every min max it's is much slower

00:05:00,760 --> 00:05:08,230
than calling both min and Max so what

00:05:03,760 --> 00:05:10,720
does it mean so you have an array with

00:05:08,230 --> 00:05:13,870
the numbers not one to ten one to nine

00:05:10,720 --> 00:05:15,700
and then you can call Aryan max and it

00:05:13,870 --> 00:05:18,490
will return an area with the numbers one

00:05:15,700 --> 00:05:20,890
and nine or you can call array dot min

00:05:18,490 --> 00:05:24,690
and area dog Max and it will return the

00:05:20,890 --> 00:05:28,030
same result so I did a benchmark

00:05:24,690 --> 00:05:32,140
compared the two methods and it turns

00:05:28,030 --> 00:05:34,630
out re min Max is actually 1.8 times

00:05:32,140 --> 00:05:38,050
slower than calling every min in area

00:05:34,630 --> 00:05:40,510
dot max and that was surprisingly

00:05:38,050 --> 00:05:42,970
because I was was expecting calling one

00:05:40,510 --> 00:05:45,910
method should be faster than calling two

00:05:42,970 --> 00:05:48,930
methods so and the reason is array min

00:05:45,910 --> 00:05:52,870
Max is included by the innumerable

00:05:48,930 --> 00:05:57,280
module and doesn't use the internal fast

00:05:52,870 --> 00:05:59,680
methods of array so I thought sounds

00:05:57,280 --> 00:06:02,169
sounds like a good first issue so I

00:05:59,680 --> 00:06:05,400
started I fought Ruby started

00:06:02,169 --> 00:06:10,990
programming created a pull request and

00:06:05,400 --> 00:06:12,610
yeah was happy but my pure classical

00:06:10,990 --> 00:06:14,410
close really quick because there was

00:06:12,610 --> 00:06:17,080
already a patch attached to the Ruby

00:06:14,410 --> 00:06:18,460
issue tracker which I didn't see and I

00:06:17,080 --> 00:06:21,310
was really disappointed because I

00:06:18,460 --> 00:06:24,360
thought like I did all this work and I

00:06:21,310 --> 00:06:27,130
was hoping to get a patch into Ruby and

00:06:24,360 --> 00:06:29,919
then I was thinking big my goal was

00:06:27,130 --> 00:06:33,450
understanding Ruby better so my goal

00:06:29,919 --> 00:06:36,760
wasn't getting a patch into Ruby and

00:06:33,450 --> 00:06:39,010
actually I I learned something new I

00:06:36,760 --> 00:06:40,030
learned how to compile Ruby I learned to

00:06:39,010 --> 00:06:42,900
program a little bit

00:06:40,030 --> 00:06:45,790
see which I didn't do since University

00:06:42,900 --> 00:06:49,030
it challenged me to try try out

00:06:45,790 --> 00:06:50,770
something new and eventually it all also

00:06:49,030 --> 00:06:56,110
inspired me to look into different

00:06:50,770 --> 00:06:58,840
implementations of Ruby which brings us

00:06:56,110 --> 00:07:00,060
to my second example which is about Ruby

00:06:58,840 --> 00:07:03,400
news and opal

00:07:00,060 --> 00:07:06,250
so Ruby newest is Ruby in bare

00:07:03,400 --> 00:07:08,800
invitation row written in Ruby so only

00:07:06,250 --> 00:07:15,160
the virtual machine is implemented in c

00:07:08,800 --> 00:07:17,530
and c++ and opal is actually Ruby to

00:07:15,160 --> 00:07:19,480
JavaScript transpiler which makes it

00:07:17,530 --> 00:07:23,350
possible to run your Ruby code in the

00:07:19,480 --> 00:07:26,770
browser so it's really cool and my idea

00:07:23,350 --> 00:07:30,910
was as MRI is a reference implementation

00:07:26,770 --> 00:07:33,040
of Ruby I will go to the Ruby release

00:07:30,910 --> 00:07:34,060
notes see what is new in Ruby and then I

00:07:33,040 --> 00:07:35,860
will check out the different

00:07:34,060 --> 00:07:38,110
implementations and see if they already

00:07:35,860 --> 00:07:43,180
implemented these features and if not I

00:07:38,110 --> 00:07:47,230
will do it so in Ruby 2.5 string got a

00:07:43,180 --> 00:07:49,390
method called delete prefix and delete

00:07:47,230 --> 00:07:51,340
prefix does you have a string and then

00:07:49,390 --> 00:07:53,620
you can call delete prefix and it will

00:07:51,340 --> 00:07:59,290
just remove the first part of the string

00:07:53,620 --> 00:08:03,250
if it matches so in Ruby nears it looks

00:07:59,290 --> 00:08:06,400
very similar simple so it does just type

00:08:03,250 --> 00:08:08,380
conversion and then if the string starts

00:08:06,400 --> 00:08:10,480
with this prefix then it removes it

00:08:08,380 --> 00:08:14,500
otherwise it will return a copy of the

00:08:10,480 --> 00:08:16,900
string and in Oh pal it actually looks

00:08:14,500 --> 00:08:20,020
very very similar so what you can see

00:08:16,900 --> 00:08:23,230
here is are they one difference is the

00:08:20,020 --> 00:08:27,670
person did X which usually shares out

00:08:23,230 --> 00:08:33,060
and execute on your shell what it does

00:08:27,670 --> 00:08:33,060
here is it it executes JavaScript code

00:08:33,540 --> 00:08:38,980
so I was starting implementing it and my

00:08:37,510 --> 00:08:41,140
first steps was like I was playing

00:08:38,980 --> 00:08:43,960
around with this new method and I tried

00:08:41,140 --> 00:08:45,760
it should work with a symbol right so it

00:08:43,960 --> 00:08:48,010
was trying it out with a simple and I

00:08:45,760 --> 00:08:49,510
got a type error and I was I was a

00:08:48,010 --> 00:08:52,420
little bit surprised because I was

00:08:49,510 --> 00:08:53,830
expecting it works with the symbol so I

00:08:52,420 --> 00:08:57,100
was looking at the implementation

00:08:53,830 --> 00:09:03,580
again and it does a conversion to with

00:08:57,100 --> 00:09:05,830
two STR and as it turns out a symbol

00:09:03,580 --> 00:09:08,170
does not implement their two STR method

00:09:05,830 --> 00:09:10,510
because as simple it's not a string it

00:09:08,170 --> 00:09:14,590
implements the 2's method but not the

00:09:10,510 --> 00:09:16,600
two STR and there's actually a really

00:09:14,590 --> 00:09:20,020
interesting issue on the Ruby issue

00:09:16,600 --> 00:09:21,910
tracker from six years ago about

00:09:20,020 --> 00:09:24,970
discussions if a symbol should implement

00:09:21,910 --> 00:09:27,520
their two STR method and they also

00:09:24,970 --> 00:09:30,880
discuss why it shouldn't because the

00:09:27,520 --> 00:09:35,290
symbol is not a string just in some in

00:09:30,880 --> 00:09:36,850
some places it behaves like a string so

00:09:35,290 --> 00:09:38,650
and I learned about explicit and

00:09:36,850 --> 00:09:42,430
implicit conversions so in the explicit

00:09:38,650 --> 00:09:44,470
case we say this symbol is a string and

00:09:42,430 --> 00:09:46,960
then we use it as a string and in the

00:09:44,470 --> 00:09:50,140
implicit case Ruby does it in there in

00:09:46,960 --> 00:09:52,750
the background for us so for instance

00:09:50,140 --> 00:09:55,780
here we can just create a class prefix

00:09:52,750 --> 00:09:59,700
implement their two STR method and then

00:09:55,780 --> 00:10:03,490
use it as a prefix and it would work and

00:09:59,700 --> 00:10:05,650
interestingly if you look into rails

00:10:03,490 --> 00:10:08,530
that is what they do and the path class

00:10:05,650 --> 00:10:11,410
so path was initially inherited from

00:10:08,530 --> 00:10:14,470
string and aaron patterson tree fact

00:10:11,410 --> 00:10:16,750
that it like seven years ago to be not

00:10:14,470 --> 00:10:20,710
inherited by string anymore and he

00:10:16,750 --> 00:10:23,740
implemented the two STR method so what

00:10:20,710 --> 00:10:27,220
you can see here you can take a string

00:10:23,740 --> 00:10:29,650
and concatenate it with a plus if you

00:10:27,220 --> 00:10:31,600
implement their two STR method which

00:10:29,650 --> 00:10:34,660
doesn't work if you only implement 2's

00:10:31,600 --> 00:10:36,790
and there was this pull request from

00:10:34,660 --> 00:10:42,760
seven years ago and Aaron explains it

00:10:36,790 --> 00:10:45,070
very good on the issue and then I looked

00:10:42,760 --> 00:10:48,150
again in the implementation and I was

00:10:45,070 --> 00:10:50,980
surprised so if you don't remove the

00:10:48,150 --> 00:10:54,010
prefix so if it doesn't match it returns

00:10:50,980 --> 00:10:58,600
a copy of the string which surprised me

00:10:54,010 --> 00:11:01,240
a little bit and on Monday evening I was

00:10:58,600 --> 00:11:04,300
out for dinner and I met Ryan which is

00:11:01,240 --> 00:11:06,130
the who did a talk this morning about

00:11:04,300 --> 00:11:07,620
Archie shock which is a rust

00:11:06,130 --> 00:11:09,300
implementation of Ruby

00:11:07,620 --> 00:11:11,250
and I was talking with him and I was

00:11:09,300 --> 00:11:13,530
saying like I think I found a part in

00:11:11,250 --> 00:11:15,780
Archie short because you don't return a

00:11:13,530 --> 00:11:18,930
copy of the string you returned the same

00:11:15,780 --> 00:11:21,330
string so this is actually the back and

00:11:18,930 --> 00:11:23,190
he was saying oh that's interesting why

00:11:21,330 --> 00:11:25,920
why did you not fix it why did you not

00:11:23,190 --> 00:11:27,720
send a pull request so yesterday evening

00:11:25,920 --> 00:11:30,960
I did a pull request and Ryan already

00:11:27,720 --> 00:11:34,920
merged it since fixed now in artichoke

00:11:30,960 --> 00:11:38,220
and I was looking more into it why it

00:11:34,920 --> 00:11:41,490
does return a copy of the string and

00:11:38,220 --> 00:11:44,700
turns out most methods on string return

00:11:41,490 --> 00:11:46,770
a copy if they don't do anything just to

00:11:44,700 --> 00:11:49,410
be consistent for instance I have a

00:11:46,770 --> 00:11:52,140
string hello and I want to delete the

00:11:49,410 --> 00:11:55,080
character a which doesn't match in the

00:11:52,140 --> 00:11:57,120
string and it returns a copy if you use

00:11:55,080 --> 00:11:59,400
Chomp which returns all the right space

00:11:57,120 --> 00:12:01,830
so there's no white space in this string

00:11:59,400 --> 00:12:04,680
it returns a copy of the string or if

00:12:01,830 --> 00:12:08,760
you use cheese up which also replaces

00:12:04,680 --> 00:12:10,260
the would replace the a with a a which

00:12:08,760 --> 00:12:15,480
doesn't do anything in this case it also

00:12:10,260 --> 00:12:17,280
returns a copy of the string so what I

00:12:15,480 --> 00:12:19,260
learned with this contribution it's it

00:12:17,280 --> 00:12:21,120
was a really small contribution in three

00:12:19,260 --> 00:12:22,830
different projects like actually only

00:12:21,120 --> 00:12:25,050
three or four lines of code but I

00:12:22,830 --> 00:12:27,860
learned so many things about Ruby and I

00:12:25,050 --> 00:12:33,840
dipped into the rails code studied Reyes

00:12:27,860 --> 00:12:41,160
so what's really interesting which

00:12:33,840 --> 00:12:49,110
brings us to my last example which is

00:12:41,160 --> 00:12:51,270
about JRuby so JRuby is the Java

00:12:49,110 --> 00:12:56,760
implementation of Ruby which runs on the

00:12:51,270 --> 00:13:01,320
JVM and it's it implements concurrency

00:12:56,760 --> 00:13:04,700
and it's really fast so actually one of

00:13:01,320 --> 00:13:07,080
their like what is written on the

00:13:04,700 --> 00:13:10,740
documentation of che Ruby and the github

00:13:07,080 --> 00:13:12,720
page one of the first census is it aims

00:13:10,740 --> 00:13:15,600
to be a complete correct and fast

00:13:12,720 --> 00:13:19,620
implementation of Ruby so it's all like

00:13:15,600 --> 00:13:21,300
that sounds really interesting so if one

00:13:19,620 --> 00:13:24,660
of the main goals is fasting

00:13:21,300 --> 00:13:27,649
limitation then it's probably fun to

00:13:24,660 --> 00:13:30,390
work on some performance issue see I was

00:13:27,649 --> 00:13:32,459
again going to the Ruby issue Trek and

00:13:30,390 --> 00:13:35,190
the JRuby issue tracker and looking

00:13:32,459 --> 00:13:38,850
around what I could do and eventually I

00:13:35,190 --> 00:13:43,140
found this issue hash tables with open

00:13:38,850 --> 00:13:45,740
addressing and that is a feature which

00:13:43,140 --> 00:13:49,740
got introduced in Ruby 2.4 which

00:13:45,740 --> 00:13:54,029
improved hash tables by around 40% so

00:13:49,740 --> 00:13:56,839
made hash tables 40% faster and I

00:13:54,029 --> 00:14:01,500
thought that sounds really interesting

00:13:56,839 --> 00:14:05,459
how how hard can it be like just two

00:14:01,500 --> 00:14:07,380
days ago Aaron tweeted this tweet so

00:14:05,459 --> 00:14:14,010
implement the hash been there done that

00:14:07,380 --> 00:14:16,800
so seems seems to be quite easy so I was

00:14:14,010 --> 00:14:20,490
looking into the issue and I found the

00:14:16,800 --> 00:14:25,880
patch on MRI which is like almost 1500

00:14:20,490 --> 00:14:29,730
lines of code and I'm not a C program I

00:14:25,880 --> 00:14:32,459
didn't never lie I did some scene

00:14:29,730 --> 00:14:37,410
University but I'm not a C programmer at

00:14:32,459 --> 00:14:39,089
all so I was like ok this is this is

00:14:37,410 --> 00:14:41,459
probably not going to happen I can't

00:14:39,089 --> 00:14:45,660
read like 15 on a lines of code in C and

00:14:41,459 --> 00:14:50,399
then transfer the knowledge to such a

00:14:45,660 --> 00:14:52,740
ruby so my initial idea was I already

00:14:50,399 --> 00:14:55,320
showed or showed you in the first part

00:14:52,740 --> 00:14:57,990
of the talk Rubinius so my first idea

00:14:55,320 --> 00:15:00,000
was I will look into Ruby Gnaeus if they

00:14:57,990 --> 00:15:01,560
implemented it I would just read the

00:15:00,000 --> 00:15:06,120
Ruby code there and then I will

00:15:01,560 --> 00:15:09,810
implement it in JRuby however they

00:15:06,120 --> 00:15:15,480
didn't implement it so my next idea was

00:15:09,810 --> 00:15:19,140
I already compiled Ruby so I know how to

00:15:15,480 --> 00:15:21,360
compile it and I thought like I would

00:15:19,140 --> 00:15:23,940
just put in sprinkle in some ports and

00:15:21,360 --> 00:15:25,680
then I will execute different code and

00:15:23,940 --> 00:15:28,620
try what it does to understand it better

00:15:25,680 --> 00:15:30,990
so there be underscore P method it's

00:15:28,620 --> 00:15:33,209
just a print in C and I thought like

00:15:30,990 --> 00:15:34,889
okay maybe maybe that would work so I

00:15:33,209 --> 00:15:37,259
compile

00:15:34,889 --> 00:15:40,499
compiled Ruby tried it out and got a

00:15:37,259 --> 00:15:44,339
segmentation fault so there I was it

00:15:40,499 --> 00:15:46,439
didn't work and so I was going back to

00:15:44,339 --> 00:15:48,660
the issue and it was starting to read

00:15:46,439 --> 00:15:52,889
the patch and trying to understand it

00:15:48,660 --> 00:15:56,189
and in the patch there's actually at the

00:15:52,889 --> 00:15:59,249
top is a really good description of the

00:15:56,189 --> 00:16:03,509
algorithm what they implemented just

00:15:59,249 --> 00:16:06,720
written down with ASCII art how it works

00:16:03,509 --> 00:16:10,649
so I thought it's maybe I can try to

00:16:06,720 --> 00:16:13,199
implement this in Ruby try to understand

00:16:10,649 --> 00:16:17,279
what they did and then transfer the

00:16:13,199 --> 00:16:20,939
knowledge to Java and research a little

00:16:17,279 --> 00:16:25,999
bit how open addressing works so that

00:16:20,939 --> 00:16:31,169
was my first that was then my next step

00:16:25,999 --> 00:16:34,470
so a hash to to recap is we create a

00:16:31,169 --> 00:16:37,079
hash and then we can set a key and the

00:16:34,470 --> 00:16:42,569
with a value and then we can retrieve

00:16:37,079 --> 00:16:44,549
the key again so the approach but they

00:16:42,569 --> 00:16:49,410
implemented before was called separate

00:16:44,549 --> 00:16:54,169
chaining and so in this case we create a

00:16:49,410 --> 00:16:59,399
class hash which has buckets variable

00:16:54,169 --> 00:17:01,139
which is an array and the array is a

00:16:59,399 --> 00:17:06,269
nested array so what you see in the

00:17:01,139 --> 00:17:13,740
break heads means that the array each

00:17:06,269 --> 00:17:17,370
value is by default an empty array so if

00:17:13,740 --> 00:17:20,100
you want to set a key you just find the

00:17:17,370 --> 00:17:24,059
key if the key exists we replace the

00:17:20,100 --> 00:17:27,269
value if the key does not exist we

00:17:24,059 --> 00:17:29,010
search for the bucket and append entry

00:17:27,269 --> 00:17:31,220
to it and their entry is just a struct

00:17:29,010 --> 00:17:34,980
for the key and the value

00:17:31,220 --> 00:17:38,070
so the find method finds the bucket and

00:17:34,980 --> 00:17:41,010
then just iterates over all entries in

00:17:38,070 --> 00:17:45,809
this array so we have an array of nested

00:17:41,010 --> 00:17:48,730
arrays basically and the bucket we find

00:17:45,809 --> 00:17:51,430
the bucket by calculating

00:17:48,730 --> 00:17:56,770
index and the index is the hash value of

00:17:51,430 --> 00:17:59,380
the key modulus the packets length so I

00:17:56,770 --> 00:18:01,690
was wondering why is this approach not

00:17:59,380 --> 00:18:04,360
good or why why do we want to implement

00:18:01,690 --> 00:18:07,870
a different approach and the reason is

00:18:04,360 --> 00:18:11,770
called cache locality the cache locality

00:18:07,870 --> 00:18:14,050
this is copied from Wikipedia is if a

00:18:11,770 --> 00:18:16,600
particular storage locations reference

00:18:14,050 --> 00:18:18,520
then it is likely that nearby memory

00:18:16,600 --> 00:18:22,600
locations will be referenced in the near

00:18:18,520 --> 00:18:24,760
future so what does it mean imagine you

00:18:22,600 --> 00:18:27,100
have an array and you iterate over the

00:18:24,760 --> 00:18:31,000
area to print out just what what is in

00:18:27,100 --> 00:18:33,640
the area most cases if you access the

00:18:31,000 --> 00:18:35,110
first value of the array you also exist

00:18:33,640 --> 00:18:38,830
the second the third the fourth the

00:18:35,110 --> 00:18:42,610
fifth element so that's a very common

00:18:38,830 --> 00:18:44,410
use case it's in cache locality turns

00:18:42,610 --> 00:18:48,220
out like most modern computer

00:18:44,410 --> 00:18:51,600
architectures implement a feature if you

00:18:48,220 --> 00:18:54,610
access a value from their from their

00:18:51,600 --> 00:18:57,730
memory then it will load nearby memory

00:18:54,610 --> 00:19:00,430
into the CPUs cache and then the next

00:18:57,730 --> 00:19:02,680
time you access it it will already be in

00:19:00,430 --> 00:19:06,100
the cache so in the case you access the

00:19:02,680 --> 00:19:08,200
first element it will load the hopefully

00:19:06,100 --> 00:19:10,060
the wall array into their CPUs cash and

00:19:08,200 --> 00:19:12,880
then accessing the second and the third

00:19:10,060 --> 00:19:16,180
element will be really fast so that is

00:19:12,880 --> 00:19:18,250
basically what you want to what we want

00:19:16,180 --> 00:19:20,350
to do with open addressing because with

00:19:18,250 --> 00:19:24,210
the approach when you have nested arrays

00:19:20,350 --> 00:19:26,950
it's unlikely that you have a cache hit

00:19:24,210 --> 00:19:29,200
so an open addressing first step what we

00:19:26,950 --> 00:19:32,170
did is we were getting rid of the nested

00:19:29,200 --> 00:19:34,690
arrays the first step is they're the

00:19:32,170 --> 00:19:38,280
same we find we check if the key already

00:19:34,690 --> 00:19:42,970
exists if it exists we replace the value

00:19:38,280 --> 00:19:47,080
if it doesn't exist we we find the

00:19:42,970 --> 00:19:49,210
packet and then we insert on the packet

00:19:47,080 --> 00:19:53,470
the entry so we don't append it anymore

00:19:49,210 --> 00:19:57,760
we just insert it there and find also

00:19:53,470 --> 00:20:01,450
just use the bucket from the pockets

00:19:57,760 --> 00:20:02,650
array and the main difference now is how

00:20:01,450 --> 00:20:05,440
we find the bucket

00:20:02,650 --> 00:20:09,130
so we calculate the index again and then

00:20:05,440 --> 00:20:11,920
we iterate over the one array and try to

00:20:09,130 --> 00:20:12,730
find the key and if we don't find the

00:20:11,920 --> 00:20:16,410
key

00:20:12,730 --> 00:20:20,440
Battaglia calculate the next index and

00:20:16,410 --> 00:20:23,170
in our case like simply by a simplified

00:20:20,440 --> 00:20:25,720
version for this talk it's just we take

00:20:23,170 --> 00:20:29,830
the next step in the array we take the

00:20:25,720 --> 00:20:31,420
next entry so in in the real in the real

00:20:29,830 --> 00:20:34,110
implementation we have a second hash

00:20:31,420 --> 00:20:38,770
function but here we just take the next

00:20:34,110 --> 00:20:40,300
element so I did this in Ruby tried to

00:20:38,770 --> 00:20:44,590
understand it and then I started to

00:20:40,300 --> 00:20:49,210
implement it in JRuby so I did started

00:20:44,590 --> 00:20:52,090
to reflect it internally and this is

00:20:49,210 --> 00:20:54,610
really famous quote from the programming

00:20:52,090 --> 00:20:57,070
programming programmer which there's

00:20:54,610 --> 00:21:00,820
different languages of the same problems

00:20:57,070 --> 00:21:03,400
in different ways so really in the

00:21:00,820 --> 00:21:06,670
beginning I found it really annoying in

00:21:03,400 --> 00:21:08,679
Java the static typing and then when he

00:21:06,670 --> 00:21:11,559
started to do a big refactoring I really

00:21:08,679 --> 00:21:13,450
appreciate it because it guided me if

00:21:11,559 --> 00:21:15,670
you needed to replace a value it told

00:21:13,450 --> 00:21:18,610
you you forgot something you need to go

00:21:15,670 --> 00:21:20,890
there so doing the same refactoring in

00:21:18,610 --> 00:21:23,890
Ruby would be probably really hairy

00:21:20,890 --> 00:21:26,679
really difficult and you also need to

00:21:23,890 --> 00:21:31,960
wait until your test pass or failure to

00:21:26,679 --> 00:21:33,910
until you find some issues and in

00:21:31,960 --> 00:21:36,250
software we also have this approach

00:21:33,910 --> 00:21:39,670
released early release often so I

00:21:36,250 --> 00:21:44,020
started working on this issue and really

00:21:39,670 --> 00:21:46,960
quick I realized I'm stuck so what I did

00:21:44,020 --> 00:21:48,910
is I created like a draft pour request

00:21:46,960 --> 00:21:52,840
and ask people from the trade will be

00:21:48,910 --> 00:21:55,720
community to help me and what we heared

00:21:52,840 --> 00:21:59,140
on Monday in the keynote is ideas become

00:21:55,720 --> 00:22:02,070
bigger when you share them so I think

00:21:59,140 --> 00:22:05,380
that was one of the one of the reasons I

00:22:02,070 --> 00:22:07,059
finished this project because I asked

00:22:05,380 --> 00:22:09,910
early for help and asked for input

00:22:07,059 --> 00:22:14,750
otherwise I probably would have instruct

00:22:09,910 --> 00:22:20,690
and yeah probably wouldn't finish it

00:22:14,750 --> 00:22:23,960
and so I finished the first

00:22:20,690 --> 00:22:27,790
implementation of this of this new

00:22:23,960 --> 00:22:30,920
approach but turns out it wasn't faster

00:22:27,790 --> 00:22:32,690
so we were discussing in in my pull

00:22:30,920 --> 00:22:34,370
request in my draft pull request

00:22:32,690 --> 00:22:37,850
why it's not faster what we could try

00:22:34,370 --> 00:22:39,740
and one approach some contributor came

00:22:37,850 --> 00:22:43,670
up with it was we should remove the

00:22:39,740 --> 00:22:46,220
entry object because then we remove a

00:22:43,670 --> 00:22:48,260
lot of object allocations so what we did

00:22:46,220 --> 00:22:50,600
instead is we remove the entry object

00:22:48,260 --> 00:22:52,970
and then on the first position we

00:22:50,600 --> 00:22:56,000
entered the key and second position like

00:22:52,970 --> 00:22:58,460
plus one pocket we entered the value and

00:22:56,000 --> 00:23:01,970
we removed a lot of object allocations

00:22:58,460 --> 00:23:06,170
and that actually did did improve the

00:23:01,970 --> 00:23:09,800
performance a lot and a couple of weeks

00:23:06,170 --> 00:23:11,900
ago I was at Ruby conference and Akira

00:23:09,800 --> 00:23:13,600
Matsuda gave a talk about performance

00:23:11,900 --> 00:23:16,100
optimizations and he was saying this

00:23:13,600 --> 00:23:18,610
performance optimization is a game in

00:23:16,100 --> 00:23:24,230
which you want to achieve a high score

00:23:18,610 --> 00:23:26,960
so stuff like this removing objects you

00:23:24,230 --> 00:23:28,910
you can't usually do in your daily in

00:23:26,960 --> 00:23:31,880
your day to day job because if I could

00:23:28,910 --> 00:23:33,650
come in tomorrow morning and start

00:23:31,880 --> 00:23:37,700
removing objects then my co-workers

00:23:33,650 --> 00:23:40,670
probably would say no but in projects

00:23:37,700 --> 00:23:44,870
like this you can do it because you want

00:23:40,670 --> 00:23:47,900
to make the the you want to make chair

00:23:44,870 --> 00:23:51,110
will be really fast so you accept that

00:23:47,900 --> 00:23:55,310
you increase the complexity for for

00:23:51,110 --> 00:23:58,520
better performance so I was finishing

00:23:55,310 --> 00:24:02,720
the pull request and then eventually we

00:23:58,520 --> 00:24:05,600
merged it which took around two months I

00:24:02,720 --> 00:24:07,910
was working in there in the evenings and

00:24:05,600 --> 00:24:10,010
then on the weekends the pitch was in

00:24:07,910 --> 00:24:16,130
the world pitch was around seven hundred

00:24:10,010 --> 00:24:17,990
lines of code and after it got merged a

00:24:16,130 --> 00:24:21,790
couple of weeks later we needed to

00:24:17,990 --> 00:24:24,100
revert it temporarily so the issue is

00:24:21,790 --> 00:24:27,170
turns out the new implementation

00:24:24,100 --> 00:24:29,660
performs it's not as

00:24:27,170 --> 00:24:36,020
in concurrency as the previous

00:24:29,660 --> 00:24:38,930
implementation was so yeah we're

00:24:36,020 --> 00:24:40,630
currently working on it to merge it soon

00:24:38,930 --> 00:24:43,940
back into it but we need to make it more

00:24:40,630 --> 00:24:46,100
solid and robust in concurrency cases

00:24:43,940 --> 00:24:48,350
which for instance is not not an issue

00:24:46,100 --> 00:24:50,920
in MRI because you have the global

00:24:48,350 --> 00:24:55,130
interpreter lock

00:24:50,920 --> 00:24:58,040
so to recap this section slide but happy

00:24:55,130 --> 00:25:00,800
really a lot was prototyping so which I

00:24:58,040 --> 00:25:03,140
still use a lot in my day-to-day job so

00:25:00,800 --> 00:25:05,570
if there's feature which is too complex

00:25:03,140 --> 00:25:07,070
or which I'm not sure about and I just

00:25:05,570 --> 00:25:11,900
do a really quick prototype maybe

00:25:07,070 --> 00:25:14,740
outside even of of the project and then

00:25:11,900 --> 00:25:20,230
also ask for help so ask the community

00:25:14,740 --> 00:25:20,230
make draft or request share your ideas

00:25:20,530 --> 00:25:29,470
so yeah these were my three different

00:25:24,050 --> 00:25:32,330
examples and I started my talk with a

00:25:29,470 --> 00:25:34,870
question like what defines a senior

00:25:32,330 --> 00:25:37,580
developer and it was like I wanted to

00:25:34,870 --> 00:25:39,830
become a better Ruby program and master

00:25:37,580 --> 00:25:43,300
Ruby I mean probably nobody really

00:25:39,830 --> 00:25:48,200
masters Ruby except maybe mutts

00:25:43,300 --> 00:25:50,420
but program programming is you never

00:25:48,200 --> 00:25:55,040
stop learning like every day you learn

00:25:50,420 --> 00:25:58,280
something new and that's what what you

00:25:55,040 --> 00:26:00,620
need to accept and with open source you

00:25:58,280 --> 00:26:02,360
can just like browse around and get help

00:26:00,620 --> 00:26:04,160
and learn how chances are implemented

00:26:02,360 --> 00:26:07,160
how Ruby is implemented and learn

00:26:04,160 --> 00:26:12,040
something new and we also have a huge

00:26:07,160 --> 00:26:12,040
community which is usually happy to help

00:26:12,220 --> 00:26:20,960
thank you

00:26:14,830 --> 00:26:33,070
[Applause]

00:26:20,960 --> 00:26:33,070

YouTube URL: https://www.youtube.com/watch?v=-UVV8_560eE


