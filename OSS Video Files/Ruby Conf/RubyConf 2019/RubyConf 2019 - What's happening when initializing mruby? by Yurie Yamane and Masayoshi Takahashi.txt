Title: RubyConf 2019 - What's happening when initializing mruby? by Yurie Yamane and Masayoshi Takahashi
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - What's happening when initializing mruby? by Yurie Yamane and Masayoshi Takahashi

Like MRI, mruby initializes all classes before execution. This has a negative impact on Ruby's initialization speed and memory. This increase in memory usage is particularly fatal for mruby. We have created a new mrbgem to solve this issue. The key idea is pre-execution; we actually run mruby and do initialization, generate the structures in the form of C source code, and recompile it. In this session, we will look at the initial behavior of the mruby through an introduction to our tools.

#rubyconf2019 #confreaks
Captions: 
	00:00:13,530 --> 00:00:14,530
Hi everyone.

00:00:14,530 --> 00:00:20,400
We will talk about initialization of mruby.

00:00:20,400 --> 00:00:25,669
Before this session begins, we'll briefly summarize our session.

00:00:25,669 --> 00:00:31,939
After our self introduction, we will talk about mruby and its initialization.

00:00:31,939 --> 00:00:41,050
We have a problem of initialization of mruby, so we will talk about how to improve it.

00:00:41,050 --> 00:00:46,980
Our solution is nvgen, an mrbgem for modified mruby.

00:00:46,980 --> 00:00:55,079
Finally, we will show our result and future works.

00:00:55,079 --> 00:00:58,679
Let me introduce ourselves.

00:00:58,679 --> 00:01:05,530
I am Yurie, I am interested in microcomputer and real-time OS.

00:01:05,530 --> 00:01:07,890
I'm a member of Toppers project.

00:01:07,890 --> 00:01:12,810
Toppers project makes kernel for real-time OS and tools.

00:01:12,810 --> 00:01:18,939
I do demonstrations and presentations at many exhibitions.

00:01:18,939 --> 00:01:27,299
In addition, Matz and I are planning to virtually join the talk about mruby at the event called

00:01:27,299 --> 00:01:38,039
ET2019 which is hold in Japan this evening.

00:01:38,039 --> 00:01:39,869
And I'm Musayoshi Takahashi.

00:01:39,869 --> 00:01:45,080
I've used Ruby for 20 years but almost used CRuby, not mruby.

00:01:45,080 --> 00:01:50,759
In addition, I'm one of the organizers of RubyKaigi in Japan, and the next RubyKaigi

00:01:50,759 --> 00:01:55,659
will be held in Matsumoto city in next April.

00:01:55,659 --> 00:02:00,159
Please come and join.

00:02:00,159 --> 00:02:05,420
And we published a zine called "Introduction to mruby" a few months ago.

00:02:05,420 --> 00:02:06,420
This book.

00:02:06,420 --> 00:02:07,420
This zine.

00:02:07,420 --> 00:02:17,520
I brought the sample of the book, so please let me know if you are interested.

00:02:17,520 --> 00:02:20,560
The topic of our session is initialization of mruby.

00:02:20,560 --> 00:02:27,200
In this session, we'll talk about the mruby, its initialization, and our improvement of

00:02:27,200 --> 00:02:28,200
it.

00:02:28,200 --> 00:02:32,280
So, first of all, we'll talk about mruby.

00:02:32,280 --> 00:02:41,040
mruby is an implementation of Ruby, like CRuby, JRuby, Rubinius, Opal, and Artichoke.

00:02:41,040 --> 00:02:46,840
It's also called a lightweight Ruby. mruby is a very small implementation compared to

00:02:46,840 --> 00:02:48,760
CRuby and JRuby.

00:02:48,760 --> 00:02:53,069
It's comply with the ISO standard of Ruby.

00:02:53,069 --> 00:02:57,720
mruby has mainly two target areas.

00:02:57,720 --> 00:03:03,840
Embedded systems and embedded in applications such as servers and games.

00:03:03,840 --> 00:03:06,040
We have focused the former.

00:03:06,040 --> 00:03:08,640
Embedded systems.

00:03:08,640 --> 00:03:15,650
We recently used a board called M5StickC to run mruby.

00:03:15,650 --> 00:03:22,799
This is M5StickC is a new board made by M5Stack company.

00:03:22,799 --> 00:03:27,870
It's size is very small like this, but it's very powerful.

00:03:27,870 --> 00:03:35,730
The board used ESP32 microcontroller, and it has Wi-Fi, Bluetooth, small LCD, sensors,

00:03:35,730 --> 00:03:38,489
battery and so on.

00:03:38,489 --> 00:03:45,870
The M5StickC diagram looks like this.

00:03:45,870 --> 00:03:48,080
On the right side.

00:03:48,080 --> 00:03:56,800
And you can add extra sensors and our actuators are with the board.

00:03:56,800 --> 00:04:03,049
We already installed mruby and a sample ruby program on it.

00:04:03,049 --> 00:04:08,459
Let's show the demo.

00:04:08,459 --> 00:04:25,180
This is a clock.

00:04:25,180 --> 00:04:37,729
Can you see?

00:04:37,729 --> 00:04:50,280
A little difficult...

00:04:50,280 --> 00:04:55,919
You can make adjusts of time using NTP with its Wi-Fi.

00:04:55,919 --> 00:05:05,280
And when you shake it, it shows two dices.

00:05:05,280 --> 00:05:09,530
And more shaking, more dices.

00:05:09,530 --> 00:05:19,330
M5StickC has motion sensors and when shaking it, the sensor detects its motion or the acceleration,

00:05:19,330 --> 00:05:20,360
and shows dices.

00:05:20,360 --> 00:05:42,160
The original program of it is in Arduino, C++, so we ported it to mruby.

00:05:42,160 --> 00:05:46,610
Now back to our topic, initialization of mruby.

00:05:46,610 --> 00:05:53,260
While thinking about the initialization of mruby, I made a quiz of mruby.

00:05:53,260 --> 00:05:57,990
How many objects are created in initialization of mruby?

00:05:57,990 --> 00:06:07,380
The important hint is all classes are objects, so the number of the objects is always greater

00:06:07,380 --> 00:06:09,819
than the number of classes.

00:06:09,819 --> 00:06:14,139
The answer is number three.

00:06:14,139 --> 00:06:16,009
212.

00:06:16,009 --> 00:06:19,910
But actually it depends on configuration of your mruby.

00:06:19,910 --> 00:06:28,460
The library of mruby is implemented at mrubygems like standard gems in CRuby.

00:06:28,460 --> 00:06:33,020
So, mruby is smaller than CRuby.

00:06:33,020 --> 00:06:37,419
Anyway, many objects are generated when initializing mruby.

00:06:37,419 --> 00:06:48,050
We used the word "initialization", but we have not defined the meaning of this word.

00:06:48,050 --> 00:06:56,530
In this session, "initialization" means everything before executing your ruby projects, sorry,

00:06:56,530 --> 00:06:59,139
your ruby scripts.

00:06:59,139 --> 00:07:04,210
There are so many main parts of initialization.

00:07:04,210 --> 00:07:07,880
First, initializing mruby VM.

00:07:07,880 --> 00:07:11,539
Second, initializing GC system.

00:07:11,539 --> 00:07:16,170
Third, initializing all classes and modules.

00:07:16,170 --> 00:07:23,610
Object, String, Integer, Array, and other standard classes should be defined before

00:07:23,610 --> 00:07:25,230
running your code.

00:07:25,230 --> 00:07:30,860
So, it should be defined during initialization process.

00:07:30,860 --> 00:07:36,759
In addition, methods of the classes should be defined too.

00:07:36,759 --> 00:07:41,129
These are important things in initialization.

00:07:41,129 --> 00:07:48,770
We make brief expression of mruby VM.

00:07:48,770 --> 00:07:54,720
The implementation of mruby VM is a struct called mrb_state.

00:07:54,720 --> 00:07:59,740
It has its context, the execution environment.

00:07:59,740 --> 00:08:04,810
Context has a callinfo array, and a stack.

00:08:04,810 --> 00:08:09,060
Those are created in initialization process.

00:08:09,060 --> 00:08:17,550
The main theme of initialization of the GC system is allocation of memory.

00:08:17,550 --> 00:08:21,230
Objects of mruby are implemented as RVALUE.

00:08:21,230 --> 00:08:24,400
RVALUE is union, fixed size structure.

00:08:24,400 --> 00:08:27,880
RVALUEs are all same size.

00:08:27,880 --> 00:08:35,150
During initialization of GC system, mruby gives (?) a lot of memory for RVALUE.

00:08:35,150 --> 00:08:42,729
At last, we'll explain initialization of classes and modules.

00:08:42,729 --> 00:08:47,550
Classes and Modules are implemented at struct, "RClass".

00:08:47,550 --> 00:08:50,820
RClass is a kind of RVALUE.

00:08:50,820 --> 00:08:57,620
RClass has a reference to a method table and an instance variable table.

00:08:57,620 --> 00:09:06,380
Method table is a map of method names and method bodies.

00:09:06,380 --> 00:09:12,610
Likewise, instance variable table is a map of variable names and values.

00:09:12,610 --> 00:09:22,280
Moreover, instance variable table is also used for providing information about the class

00:09:22,280 --> 00:09:24,360
as described below.

00:09:24,360 --> 00:09:35,670
Method names are also represented internally as symbols, so you must also initialize the

00:09:35,670 --> 00:09:36,730
symbols.

00:09:36,730 --> 00:09:41,780
Now let me explain what we want to improve.

00:09:41,780 --> 00:09:46,390
The challenge here is memory consumption.

00:09:46,390 --> 00:09:53,420
All classes and methods initializations are spread out in memory.

00:09:53,420 --> 00:09:58,830
But most classes and methods don't change on runtime.

00:09:58,830 --> 00:10:07,110
So we want to save more in environment with low memory such as microcomputers, sorry,

00:10:07,110 --> 00:10:11,030
such as microcontrollers.

00:10:11,030 --> 00:10:18,410
So we came up with a way to improve memory consumption.

00:10:18,410 --> 00:10:21,070
Microcontroller has its own RAM and flash ROM.

00:10:21,070 --> 00:10:28,470
Flash ROM has more capacity than RAM on many microcontrollers.

00:10:28,470 --> 00:10:34,570
So using ROM instead of RAM can save memory consumption.

00:10:34,570 --> 00:10:42,840
However, flash ROM cannot be written while initialization is in progress.

00:10:42,840 --> 00:10:47,890
Flash ROM is of course ROM, meaning it's read only.

00:10:47,890 --> 00:10:54,640
you can actually write blocks (?) but you can't write like RAM.

00:10:54,640 --> 00:11:00,120
Alternatively, you can change the source in the form of C source code.

00:11:00,120 --> 00:11:10,090
So, we tried using pre-execution and code generation to solve this problem.

00:11:10,090 --> 00:11:15,840
Pre-execution is a process like this figure.

00:11:15,840 --> 00:11:20,890
So this pre-processing is done before execution.

00:11:20,890 --> 00:11:26,590
As the values are not normally result from execution.

00:11:26,590 --> 00:11:31,750
Would have been given from the beginning.

00:11:31,750 --> 00:11:37,140
Initialization is, as the name suggest, the first thing you do.

00:11:37,140 --> 00:11:46,210
So if you want to do something before initialization, you need to separate it from normal execution.

00:11:46,210 --> 00:11:56,140
To take advantage of pre-execution result, we will perform two steps execution.

00:11:56,140 --> 00:12:00,490
First, run mruby for code generation only.

00:12:00,490 --> 00:12:08,000
This is to generate pre-execution literals in the form of C source file.

00:12:08,000 --> 00:12:19,930
The generated C files are then combined with the mruby core, to create another executable.

00:12:19,930 --> 00:12:25,120
This executable reduce memory consumption of mruby.

00:12:25,120 --> 00:12:37,110
So, let's talk about nvgen.

00:12:37,110 --> 00:12:44,990
nvgen stands for "Non-Volatile mruby Generator", and it's actually implemented as an mrbgem,

00:12:44,990 --> 00:12:46,420
mruby-bin-nvgen.

00:12:46,420 --> 00:12:50,680
But mruby need to be modified to run it.

00:12:50,680 --> 00:12:57,940
As mentioned several times, nvgen generates two source, two C source codes.

00:12:57,940 --> 00:13:04,840
One is a source of symbol information, the other is a collection of objects and their

00:13:04,840 --> 00:13:07,960
associated data structures.

00:13:07,960 --> 00:13:13,580
When creating a new application with nvgen, you will combine these generated sources with

00:13:13,580 --> 00:13:20,550
mruby itself, and other codes to create a new executable.

00:13:20,550 --> 00:13:26,590
Now, let's take a closer look at memory usage.

00:13:26,590 --> 00:13:35,500
If you use the C language you may have heard about memory classification and memory maps.

00:13:35,500 --> 00:13:43,460
Memory is divided into some areas, such as read-only data, data, heap, and stack.

00:13:43,460 --> 00:13:51,410
Constants are placed in read-only data which is usually in flash ROM.

00:13:51,410 --> 00:13:58,640
Global and static variables are placed in data, and memory allocated during execution

00:13:58,640 --> 00:14:01,170
is placed in heap.

00:14:01,170 --> 00:14:08,690
In this talk, we are going to use the data in heaps as well to reduce consumption by

00:14:08,690 --> 00:14:16,630
using rodata and data.

00:14:16,630 --> 00:14:22,100
This table shows how each category is used.

00:14:22,100 --> 00:14:25,790
Everything in the table is in heap for normal mruby.

00:14:25,790 --> 00:14:33,130
This is how nvgen changes memory usage.

00:14:33,130 --> 00:14:36,090
Let me explain in more detail.

00:14:36,090 --> 00:14:45,960
Normally, all internal data and methods associated with a class are created in the heap.

00:14:45,960 --> 00:14:55,100
In other word, it's all in RAM. nvgen, on the other hand, uses data and ROM

00:14:55,100 --> 00:14:56,250
space instead of heap.

00:14:56,250 --> 00:15:02,380
Suppose the new method is added.

00:15:02,380 --> 00:15:08,320
In that case, the method information is placed in RAM, not ROM.

00:15:08,320 --> 00:15:16,100
Also, when classes are created or object are created, they are placed in RAM.

00:15:16,100 --> 00:15:26,160
As you can see, nvgen is intended to improve execution at the time of initialization, and

00:15:26,160 --> 00:15:30,750
does not change anything after the initialization process.

00:15:30,750 --> 00:15:35,850
Here is the list of what nvgen does.

00:15:35,850 --> 00:15:41,040
Collect the generated objects as well as the information related to them.

00:15:41,040 --> 00:15:50,120
Then it dumps the object itself and its method in C form along with its associated information

00:15:50,120 --> 00:15:51,230
and symbols.

00:15:51,230 --> 00:15:59,270
Finally, dumps the mruby VM itself after pre-execution.

00:15:59,270 --> 00:16:03,260
This figure provides additional information on memory usage.

00:16:03,260 --> 00:16:10,410
There are three patterns for representing mruby objects in C data structure.

00:16:10,410 --> 00:16:18,350
For Integer and Symbol, you can simply express the value as mrb_value.

00:16:18,350 --> 00:16:23,600
But for other classes, you need RVALUE or more data.

00:16:23,600 --> 00:16:33,790
Object, class object, and Class object are second, String object and Array object are

00:16:33,790 --> 00:16:34,790
third.

00:16:34,790 --> 00:16:36,820
mrb_value is simple.

00:16:36,820 --> 00:16:40,950
It's immediate value and Type Tag bits.

00:16:40,950 --> 00:16:48,830
Symbol and Fixnum objects are represented only by mrb_value, but other needs RVALUE.

00:16:48,830 --> 00:16:54,800
RVALUE is the basic data structure for representing objects.

00:16:54,800 --> 00:17:01,200
RVALUE consists of a common object header, and class specific items.

00:17:01,200 --> 00:17:10,169
For example, RClass consists of a common object header, pointers to instance variables, a

00:17:10,169 --> 00:17:16,000
pointer to the method table, and a pointer to super class.

00:17:16,000 --> 00:17:28,331
For example, the Foo class on the left is converted to a data in the form on the right.

00:17:28,331 --> 00:17:29,930
We'll also explain method.

00:17:29,930 --> 00:17:37,130
The data structure of a method is different when the method definition is written in C

00:17:37,130 --> 00:17:39,540
than in Ruby.

00:17:39,540 --> 00:17:43,870
Both use struct "RProc", which is a kind of RVALUE.

00:17:43,870 --> 00:17:51,980
Methods defined in C has a reference to the C function while method defined in Ruby use

00:17:51,980 --> 00:17:57,950
a structure called IREP converted from Ruby code.

00:17:57,950 --> 00:18:04,610
IREP is created by dividing Ruby code into method and blocks.

00:18:04,610 --> 00:18:14,490
For example, such a method definition and method execution would create two IREPs.

00:18:14,490 --> 00:18:18,170
IREP has more information than bytecode.

00:18:18,170 --> 00:18:25,390
It contains the number of local variables, registers, and symbols using blocks and methods.

00:18:25,390 --> 00:18:34,910
IREP can also be nested, so a pointer is provided to this all (?).

00:18:34,910 --> 00:18:43,180
You can use the mrbc command to see the result of the IREP conversion.

00:18:43,180 --> 00:18:52,090
This is the result of converting the Ruby code to IREP, using mrbc command.

00:18:52,090 --> 00:19:01,840
I will also describe the challenge that had to be solved when creating nvgen, and how

00:19:01,840 --> 00:19:05,490
to solve them.

00:19:05,490 --> 00:19:12,730
The Ruby object, RVALUE, contains bit of flags in its data structure.

00:19:12,730 --> 00:19:20,620
For example, whether an object has been frozen is done using this flag.

00:19:20,620 --> 00:19:27,740
Therefore, you should reproduce this behavior when placing RVALUE in ROM.

00:19:27,740 --> 00:19:38,940
So, unlike normal RVALUE, we have a C Array in the data area with flags stripped out,

00:19:38,940 --> 00:19:44,440
and RVALUE has an index into that area.

00:19:44,440 --> 00:19:50,370
This allows a large number of RVALUEs to reside in ROM.

00:19:50,370 --> 00:19:57,140
It also extends mruby GC.

00:19:57,140 --> 00:20:07,340
The GC mruby uses is called tracker GC because it performs GC by assigning three colors,

00:20:07,340 --> 00:20:12,850
black, gray, and white to RVALUEs.

00:20:12,850 --> 00:20:22,760
Objects placed in ROM are marked red, to ensure that GC works correctly when using ROM.

00:20:22,760 --> 00:20:33,870
Method definitions also needs some integrity (?) to make full use of RAM and ROM.

00:20:33,870 --> 00:20:38,650
Once all methods are in ROM, you cannot add new methods.

00:20:38,650 --> 00:20:46,800
For this reason, we have provided pointers to additional methods' tables in the instance

00:20:46,800 --> 00:20:48,920
variable storage areas.

00:20:48,920 --> 00:21:00,630
You can now search for methods that are added later.

00:21:00,630 --> 00:21:09,470
We'll show another demo.

00:21:09,470 --> 00:21:12,180
Okay?

00:21:12,180 --> 00:21:17,610
In trouble?

00:21:17,610 --> 00:21:20,320
Okay?

00:21:20,320 --> 00:21:23,030
Sorry...

00:21:23,030 --> 00:21:29,520
Sending data on this device to the server.

00:21:29,520 --> 00:21:32,240
This time we will use AWS IoT.

00:21:32,240 --> 00:21:36,130
The data is sent to the server via Wi-Fi.

00:21:36,130 --> 00:21:44,400
The network we use, our Wi-Fi router, we use for tonight's session.

00:21:44,400 --> 00:21:47,060
This was provided by Lightweight Ruby Forum.

00:21:47,060 --> 00:21:48,060
Thank you.

00:21:48,060 --> 00:21:53,640
The communication protocol uses MQTT.

00:21:53,640 --> 00:22:02,340
The M5StickC has six axis motion sensor.

00:22:02,340 --> 00:22:13,900
Motion sensors also call the acceleration meters detecting movement of the device.

00:22:13,900 --> 00:22:16,540
The published code looks like this.

00:22:16,540 --> 00:22:23,920
The device gets the sensor values, and publish it to the server in JSON format.

00:22:23,920 --> 00:22:31,840
This displays the data sent by the device to the server as a graph.

00:22:31,840 --> 00:22:36,010
This use elastic search and Kibana.

00:22:36,010 --> 00:23:11,170
I get the server, ah sorry, I get the sensor value with M5StickC and publish to AWS IoT.

00:23:11,170 --> 00:23:22,540
This is AWS screen... this sensor... cursor, cursor, my cursor...

00:23:22,540 --> 00:23:42,120
This is the topic name, topic one, and click this, this is this sensor's value.

00:23:42,120 --> 00:23:46,810
And, this is Elasticsearch page.

00:23:46,810 --> 00:24:07,190
This URL, click, and display Kibana, this is... shake, shake, and click refresh the

00:24:07,190 --> 00:24:38,600
sensor value, enter... sorry, this is the display 

00:24:38,600 --> 00:25:05,020
of an entered, entered number, for example 3

00:25:05,020 --> 00:25:27,300
enter 3, sorry, will try again.

00:25:27,300 --> 00:25:35,410
Where is my cursor?

00:25:35,410 --> 00:25:52,030
(snip) Sorry, I speak Japanese... (snip) Please wait...

00:25:52,030 --> 00:25:56,910
Then auto-refresh.

00:25:56,910 --> 00:26:06,690
Shake, shake, like this.

00:26:06,690 --> 00:26:17,340
Oh, thank you!

00:26:17,340 --> 00:26:35,730
Sorry, my slides, oh sorry...

00:26:35,730 --> 00:26:40,110
I actually tried to see how much memories were reduced.

00:26:40,110 --> 00:26:49,520
mruby used RAM over 100 kilobytes with default mrubygems, in our first trial last year, we

00:26:49,520 --> 00:26:58,600
could shrink it to the half size of mruby, 100 kilobytes.

00:26:58,600 --> 00:27:08,309
Moreover, with nvgen, mruby itself was able to be reduced down to 20 kilo bytes of RAM.

00:27:08,309 --> 00:27:12,470
Anyhow, some future works.

00:27:12,470 --> 00:27:13,470
Thank you!

00:27:13,470 --> 00:27:16,840
First, we should support mruby 2.1.0.

00:27:16,840 --> 00:27:24,880
In addition, we will also provide a feedback to mruby itself.

00:27:24,880 --> 00:27:34,060
We wanted to integrate it by this RubyConf, but due to disagreement with Matz, we are

00:27:34,060 --> 00:27:37,980
not going to be able to merge it as it is.

00:27:37,980 --> 00:27:43,070
Therefore, we will consider how we can do it.

00:27:43,070 --> 00:27:49,559
Finally, let me make a few acknowledge mention (?).

00:27:49,559 --> 00:27:53,020
The Ruby Association supported our development of nvgen.

00:27:53,020 --> 00:28:00,520
The mruby forum supported us including participation in ET.

00:28:00,520 --> 00:28:07,790
Thank you Aaron for reviewing English.

00:28:07,790 --> 00:28:08,790
Thank you.

00:28:08,790 --> 00:28:15,340
Finally, we referred some figures of mruby books and documents written by Kishima-san,

00:28:15,340 --> 00:28:22,010
we really appreciate it.

00:28:22,010 --> 00:28:24,170
That's all.

00:28:24,170 --> 00:28:25,480

YouTube URL: https://www.youtube.com/watch?v=E05ACAZSXDI


