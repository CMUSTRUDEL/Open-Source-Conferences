Title: RubyConf 2019 - Building a Ruby: Artichoke is a Ruby Made with Rust by Ryan Lopopolo
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Building a Ruby: Artichoke is a Ruby Made with Rust by Ryan Lopopolo

Artichoke is a new Ruby implementation. Artichoke is written in Rust and aspires to be compatible with MRI Ruby 2.6.3. Artichoke is a platform that allows experimenting with VM implementations while providing a VM-agnostic implementation of Ruby Core and Standard Library. This talk will discuss Artichokeâ€™s history, architecture, goals, and implementation.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,260 --> 00:00:15,840
hi everyone

00:00:13,920 --> 00:00:24,570
we welcome to the last day of Ruby conf

00:00:15,840 --> 00:00:26,700
we made it thank you for coming today

00:00:24,570 --> 00:00:29,070
I'm here to talk to you about artichoke

00:00:26,700 --> 00:00:31,530
which is a new Ruby VM that I've been

00:00:29,070 --> 00:00:33,239
working on for the last nine months I'm

00:00:31,530 --> 00:00:35,129
guessing the first time many have you

00:00:33,239 --> 00:00:37,590
heard of artichoke was during the

00:00:35,129 --> 00:00:40,019
syntaxerror game show on Monday so

00:00:37,590 --> 00:00:41,280
awesome thank you for thank you for

00:00:40,019 --> 00:00:42,929
following up with your excitement I

00:00:41,280 --> 00:00:45,539
appreciate it

00:00:42,929 --> 00:00:49,109
this deck is available at artichoke

00:00:45,539 --> 00:00:51,329
github do slash Ruby conf slash 2019 if

00:00:49,109 --> 00:00:53,370
you want to tweet or follow along there

00:00:51,329 --> 00:00:55,800
are a bunch of interactive web assembly

00:00:53,370 --> 00:00:57,870
demos in the deck which are pretty fun

00:00:55,800 --> 00:01:01,399
to play with and you can also create

00:00:57,870 --> 00:01:03,690
your own demos that artichoke dot run

00:01:01,399 --> 00:01:05,489
before I get started though I'd like to

00:01:03,690 --> 00:01:07,770
thank three people in particular who

00:01:05,489 --> 00:01:10,500
provided me with a ton of support along

00:01:07,770 --> 00:01:12,000
the way you know of getting as far as I

00:01:10,500 --> 00:01:14,640
have in the implementation and leading

00:01:12,000 --> 00:01:17,219
up to Ruby conf I want to thank Daniel

00:01:14,640 --> 00:01:27,210
Steven and wobba thank you very much and

00:01:17,219 --> 00:01:28,109
I appreciate all your support so what is

00:01:27,210 --> 00:01:31,890
artichoke

00:01:28,109 --> 00:01:34,740
well artichoke is a ruby it targets Ruby

00:01:31,890 --> 00:01:36,600
2 point six point three that includes

00:01:34,740 --> 00:01:39,960
you know the core and the standard

00:01:36,600 --> 00:01:40,729
library and it runs and targets

00:01:39,960 --> 00:01:44,640
webassembly

00:01:40,729 --> 00:01:46,020
this here is a web assembly demo you'll

00:01:44,640 --> 00:01:49,280
see a bunch of these in the deck that

00:01:46,020 --> 00:01:52,439
embeds an iframe of artichoke run and

00:01:49,280 --> 00:01:54,950
can be used to execute Ruby code so

00:01:52,439 --> 00:01:57,450
let's do that right now

00:01:54,950 --> 00:01:59,280
we've got this code that sets up this

00:01:57,450 --> 00:02:02,130
properties object that's kind of a

00:01:59,280 --> 00:02:05,280
wrapper around a hash we shove some keys

00:02:02,130 --> 00:02:08,250
into it generate some JSON and test with

00:02:05,280 --> 00:02:10,229
a very nice regex validation that the

00:02:08,250 --> 00:02:12,900
JSON contains what we expect and print

00:02:10,229 --> 00:02:14,760
it out there's a lot going on here which

00:02:12,900 --> 00:02:18,000
will kind of dive into over the course

00:02:14,760 --> 00:02:19,470
of the talk but I guess one thing to

00:02:18,000 --> 00:02:20,970
note is that we have parts of the

00:02:19,470 --> 00:02:23,100
standard library in here which is

00:02:20,970 --> 00:02:24,630
little unobvious how that happens given

00:02:23,100 --> 00:02:30,300
that this is webassembly and there's no

00:02:24,630 --> 00:02:32,100
file system but I think it's important

00:02:30,300 --> 00:02:35,100
to ask the question now before we dive

00:02:32,100 --> 00:02:37,650
any further of why would I want to build

00:02:35,100 --> 00:02:39,810
a ruby and I'm just gonna play this

00:02:37,650 --> 00:02:43,560
video here and hopefully explain a

00:02:39,810 --> 00:02:46,920
little bit to you why that's the case so

00:02:43,560 --> 00:02:50,250
I didn't set out to build a ruby about

00:02:46,920 --> 00:02:51,930
ten months ago I was trying to put

00:02:50,250 --> 00:02:54,120
together a hackathon project and I

00:02:51,930 --> 00:02:55,800
wanted to build a Rube Goldberg machine

00:02:54,120 --> 00:03:00,090
like the one you see here in this music

00:02:55,800 --> 00:03:02,640
video we were trying to build a react

00:03:00,090 --> 00:03:05,310
code editor that would be populated with

00:03:02,640 --> 00:03:07,650
some Ruby code we would then post that

00:03:05,310 --> 00:03:10,230
Ruby code back to a rust web server

00:03:07,650 --> 00:03:12,420
hopefully evaluate that code to generate

00:03:10,230 --> 00:03:16,050
some CSS which we would pipe back to the

00:03:12,420 --> 00:03:18,870
browser to restyle the code editor never

00:03:16,050 --> 00:03:21,330
caught quite got that far because along

00:03:18,870 --> 00:03:23,310
the way just like the apocryphal game

00:03:21,330 --> 00:03:25,230
developer who gets more interested in

00:03:23,310 --> 00:03:26,730
building the game engine I got more

00:03:25,230 --> 00:03:30,870
interested in the Ruby bindings

00:03:26,730 --> 00:03:36,230
themselves and so began a long journey

00:03:30,870 --> 00:03:39,480
to build a Ruby along the way I

00:03:36,230 --> 00:03:41,130
implemented a rack compatible web server

00:03:39,480 --> 00:03:44,959
that was capable of running a Sinatra

00:03:41,130 --> 00:03:46,700
web application and this sort of

00:03:44,959 --> 00:03:50,130
user-based

00:03:46,700 --> 00:03:51,450
drive toward feature completeness is

00:03:50,130 --> 00:03:56,220
something that has pushed the project

00:03:51,450 --> 00:03:58,140
forward in the SA worse is better the

00:03:56,220 --> 00:04:00,540
author posits that there's two styles of

00:03:58,140 --> 00:04:04,200
software development one called the MIT

00:04:00,540 --> 00:04:05,910
style or the crown jewel style is to be

00:04:04,200 --> 00:04:07,860
very designed focused and build the

00:04:05,910 --> 00:04:10,560
perfect thing that's not done until it's

00:04:07,860 --> 00:04:12,060
done when trying to build a Ruby that

00:04:10,560 --> 00:04:14,820
seems like the wrong approach to take

00:04:12,060 --> 00:04:17,370
because there's so much to do there's so

00:04:14,820 --> 00:04:19,769
many idiosyncrasies in MRI that getting

00:04:17,370 --> 00:04:20,489
it right from this outset is next to

00:04:19,769 --> 00:04:23,520
impossible

00:04:20,489 --> 00:04:26,550
so instead artichoke takes the New

00:04:23,520 --> 00:04:28,560
Jersey approach which is to build the

00:04:26,550 --> 00:04:32,490
worst thing that can possibly work and

00:04:28,560 --> 00:04:33,729
then take use cases like building a

00:04:32,490 --> 00:04:37,090
Sinatra

00:04:33,729 --> 00:04:38,770
running server to hone in on the correct

00:04:37,090 --> 00:04:51,249
implementation and trend toward

00:04:38,770 --> 00:04:53,379
correctness over time that being said we

00:04:51,249 --> 00:04:57,069
are still early days and there is lots

00:04:53,379 --> 00:04:58,509
to do I hope you are excited enough by

00:04:57,069 --> 00:05:01,870
the end of this talk to check out our

00:04:58,509 --> 00:05:03,069
github and hopefully take a look at some

00:05:01,870 --> 00:05:06,669
tickets that you might find interesting

00:05:03,069 --> 00:05:10,629
contributing to all of the tickets in

00:05:06,669 --> 00:05:12,550
the artichoke set of repositories are

00:05:10,629 --> 00:05:15,009
tagged with how difficult we think they

00:05:12,550 --> 00:05:16,689
might be for someone to implement the

00:05:15,009 --> 00:05:17,949
ones y'all are probably most interested

00:05:16,689 --> 00:05:24,009
in are the ones that are tagged

00:05:17,949 --> 00:05:26,680
e-easy and a Help Wanted and yeah I hope

00:05:24,009 --> 00:05:28,900
you check them out I will say that

00:05:26,680 --> 00:05:33,069
artichoke is written in both rust and

00:05:28,900 --> 00:05:35,759
Ruby so we are looking for contributions

00:05:33,069 --> 00:05:39,339
of folks from both those backgrounds

00:05:35,759 --> 00:05:41,800
additionally Russ at least so far I've

00:05:39,339 --> 00:05:43,629
found to be pretty approachable this is

00:05:41,800 --> 00:05:45,009
only my second Russ project and I've

00:05:43,629 --> 00:05:46,810
been able to crank out you know thirty

00:05:45,009 --> 00:05:47,669
thousand lines of code so it's not so

00:05:46,810 --> 00:05:51,550
bad

00:05:47,669 --> 00:05:53,379
additionally we've found that some folks

00:05:51,550 --> 00:05:55,689
that are more comfortable with Ruby will

00:05:53,379 --> 00:05:57,490
start implementing parts of core and the

00:05:55,689 --> 00:05:59,409
standard library in Ruby and then

00:05:57,490 --> 00:06:01,629
graduate to implementing some of them in

00:05:59,409 --> 00:06:06,599
Russ that are either easier to do there

00:06:01,629 --> 00:06:06,599
or performance critical or or whatever

00:06:08,969 --> 00:06:13,270
that was a little bit of background now

00:06:11,229 --> 00:06:15,279
I kind of want to go over the high level

00:06:13,270 --> 00:06:17,500
goals for artichoke and we'll dive into

00:06:15,279 --> 00:06:19,000
a little bit of why those are good goals

00:06:17,500 --> 00:06:20,500
to have and how we would go about

00:06:19,000 --> 00:06:23,379
implementing them with some of the tools

00:06:20,500 --> 00:06:24,699
we have available to us our first goal

00:06:23,379 --> 00:06:26,319
is to build for webassembly

00:06:24,699 --> 00:06:28,599
you've kind of seen this already in the

00:06:26,319 --> 00:06:31,960
in the demo that I showed earlier the

00:06:28,599 --> 00:06:33,370
next is to execute untrusted code will

00:06:31,960 --> 00:06:35,110
dive into a little bit in the next

00:06:33,370 --> 00:06:38,020
couple of slides of what that means and

00:06:35,110 --> 00:06:40,539
why it's important and finally we want

00:06:38,020 --> 00:06:42,430
to be able to package Ruby applications

00:06:40,539 --> 00:06:46,110
as single binaries for ease of

00:06:42,430 --> 00:06:46,110
deployment and auditability

00:06:46,390 --> 00:06:49,900
a little bit about webassembly

00:06:48,660 --> 00:06:53,950
webassembly

00:06:49,900 --> 00:06:58,270
is a virtual machine runtime that is

00:06:53,950 --> 00:07:00,130
able to execute code that's compiled

00:06:58,270 --> 00:07:02,890
from high-level languages like rust and

00:07:00,130 --> 00:07:07,150
c++ the web assembly is nice because

00:07:02,890 --> 00:07:08,830
it's sandbox by default one concrete

00:07:07,150 --> 00:07:10,930
example of this is that memory out of

00:07:08,830 --> 00:07:12,670
bounds memory accesses trap instead of

00:07:10,930 --> 00:07:14,920
causing undefined behavior or

00:07:12,670 --> 00:07:16,840
potentially crashing your program this

00:07:14,920 --> 00:07:18,610
is good for some of the other goals

00:07:16,840 --> 00:07:20,220
we've laid out such as executing

00:07:18,610 --> 00:07:22,180
untrusted code

00:07:20,220 --> 00:07:23,950
additionally webassembly is a

00:07:22,180 --> 00:07:25,720
multi-platform it's for more than just

00:07:23,950 --> 00:07:28,060
browsers although it can run there as

00:07:25,720 --> 00:07:30,430
well there are several web assembly

00:07:28,060 --> 00:07:32,410
runtimes most notably node that allow

00:07:30,430 --> 00:07:35,370
you to execute web assembly code on

00:07:32,410 --> 00:07:38,100
something like a linux server and

00:07:35,370 --> 00:07:40,270
finally this is the big banner

00:07:38,100 --> 00:07:42,160
hip-hip-hooray thing is that it allows

00:07:40,270 --> 00:07:43,780
us to execute Ruby in the browser which

00:07:42,160 --> 00:07:53,170
we've seen it's pretty cool at least I

00:07:43,780 --> 00:07:55,210
think so thank you so a little bit about

00:07:53,170 --> 00:07:56,680
this untrusted code thing like what is

00:07:55,210 --> 00:07:58,870
untrusted code what types of

00:07:56,680 --> 00:08:00,130
applications have it and why why would

00:07:58,870 --> 00:08:03,370
we want it

00:08:00,130 --> 00:08:05,880
I think of untrusted code as a program

00:08:03,370 --> 00:08:08,500
that offers code execution as a service

00:08:05,880 --> 00:08:11,110
and some examples of programs that do

00:08:08,500 --> 00:08:13,300
that are things like Mozilla Firefox

00:08:11,110 --> 00:08:15,370
that execute both web assembly and

00:08:13,300 --> 00:08:17,200
JavaScript in the browser that is

00:08:15,370 --> 00:08:20,050
potentially from someplace that you

00:08:17,200 --> 00:08:22,030
might not like additionally game engines

00:08:20,050 --> 00:08:24,010
typically exposed scripting capabilities

00:08:22,030 --> 00:08:26,170
because it is easier and more productive

00:08:24,010 --> 00:08:27,700
to iterate on level design in a

00:08:26,170 --> 00:08:31,750
scripting language than it is by

00:08:27,700 --> 00:08:34,330
recompiling C++ additionally something

00:08:31,750 --> 00:08:36,700
like Shopify scripts allows users of a

00:08:34,330 --> 00:08:38,350
platform to inject and configure the

00:08:36,700 --> 00:08:41,110
platform by running code that they

00:08:38,350 --> 00:08:44,140
supply and even something like Redis has

00:08:41,110 --> 00:08:46,270
an eval command that will execute user

00:08:44,140 --> 00:08:48,550
supplied Lua scripts in the context of

00:08:46,270 --> 00:08:50,080
the database it would be nice if we

00:08:48,550 --> 00:08:52,680
could use Ruby for some of these use

00:08:50,080 --> 00:08:52,680
cases too

00:08:54,800 --> 00:09:00,259
with single binary apps we're going for

00:08:57,369 --> 00:09:03,129
dead simple hermetic deployments and

00:09:00,259 --> 00:09:06,290
what does that mean well a ruby

00:09:03,129 --> 00:09:08,259
installation in app today touches a lot

00:09:06,290 --> 00:09:10,910
of different parts of the file system

00:09:08,259 --> 00:09:13,910
just a base Ruby install loads a bunch

00:09:10,910 --> 00:09:15,980
of shared objects and has files from the

00:09:13,910 --> 00:09:17,899
standard library strewn about on disk in

00:09:15,980 --> 00:09:20,059
the Lib directory which can make it

00:09:17,899 --> 00:09:22,759
difficult to you know bootstrap a new

00:09:20,059 --> 00:09:25,309
deployment both on Linux and windows and

00:09:22,759 --> 00:09:26,779
makes things like deploying a docker

00:09:25,309 --> 00:09:28,660
container a little more tricky than they

00:09:26,779 --> 00:09:31,309
need to be

00:09:28,660 --> 00:09:35,540
additionally apps themselves typically

00:09:31,309 --> 00:09:36,920
load Ruby code gems config and assets

00:09:35,540 --> 00:09:38,929
and it would be nice if we could bundle

00:09:36,920 --> 00:09:40,549
these all together into one binary to

00:09:38,929 --> 00:09:46,549
make it super simple for us to deploy

00:09:40,549 --> 00:09:48,529
our applications so summarize our our

00:09:46,549 --> 00:09:51,019
goals for for the project are to build

00:09:48,529 --> 00:09:53,899
for web assembly execute untrusted code

00:09:51,019 --> 00:09:57,199
and package single binary applications

00:09:53,899 --> 00:09:58,970
in a way that's easy to deploy what

00:09:57,199 --> 00:10:03,649
tools do we have available in order to

00:09:58,970 --> 00:10:05,329
make this a reality in artichoke well

00:10:03,649 --> 00:10:07,129
the first and maybe the most obvious one

00:10:05,329 --> 00:10:09,559
given the title of this talk is that we

00:10:07,129 --> 00:10:15,579
can use rust for fun and profit in order

00:10:09,559 --> 00:10:19,309
to make our Ruby meet these goals one

00:10:15,579 --> 00:10:22,220
easy win we have is that Russ has a

00:10:19,309 --> 00:10:24,170
native web assembly back-end which means

00:10:22,220 --> 00:10:26,480
that we can write Russ code and very

00:10:24,170 --> 00:10:30,040
easily compile it to web assembly in a

00:10:26,480 --> 00:10:32,389
format that's consumable by the browser

00:10:30,040 --> 00:10:34,309
building for web assembly and Russ is as

00:10:32,389 --> 00:10:36,769
simple as invoking these two lines of

00:10:34,309 --> 00:10:39,549
code which means that it's easy to add

00:10:36,769 --> 00:10:42,529
to something like a build process to

00:10:39,549 --> 00:10:44,649
compile your Ruby application for the

00:10:42,529 --> 00:10:44,649
web

00:10:46,940 --> 00:10:53,210
ah demo time again one thing that is

00:10:50,440 --> 00:10:55,310
pretty powerful about Rus - and the fact

00:10:53,210 --> 00:10:57,680
that it has this native webassembly

00:10:55,310 --> 00:11:00,170
compilation built into the tool chain is

00:10:57,680 --> 00:11:03,800
that there are several parts of the

00:11:00,170 --> 00:11:07,340
ecosystem that are built for web

00:11:03,800 --> 00:11:09,470
assembly so here we have a program that

00:11:07,340 --> 00:11:13,310
includes this gem called artichoke web

00:11:09,470 --> 00:11:16,970
and artichoke web binds to a rust crate

00:11:13,310 --> 00:11:20,030
or library called standard web which

00:11:16,970 --> 00:11:24,560
gives us access to JavaScript ap is in

00:11:20,030 --> 00:11:28,220
rust so now we have a gem that's gonna

00:11:24,560 --> 00:11:30,650
bind to a rust library that exposes the

00:11:28,220 --> 00:11:33,710
location object in JavaScript so we have

00:11:30,650 --> 00:11:37,940
this nice chain of dependencies going

00:11:33,710 --> 00:11:42,860
from Ruby to JavaScript the artichoke

00:11:37,940 --> 00:11:47,360
dot run playground stores the text of

00:11:42,860 --> 00:11:50,120
the program in the location hash of the

00:11:47,360 --> 00:11:52,580
URL that is served so we can sort of use

00:11:50,120 --> 00:11:55,970
these bindings to standard web to create

00:11:52,580 --> 00:11:58,550
a coin that uses the location hash of

00:11:55,970 --> 00:12:05,530
this iframe as storage so if we run this

00:11:58,550 --> 00:12:05,530
program it will print out itself tada

00:12:06,530 --> 00:12:14,610
[Applause]

00:12:10,580 --> 00:12:15,870
this is only possible because of not

00:12:14,610 --> 00:12:17,760
only the rust ecosystem around

00:12:15,870 --> 00:12:24,000
webassembly but some infrastructure in

00:12:17,760 --> 00:12:32,160
artichoke to expose rust modules as ruby

00:12:24,000 --> 00:12:34,230
gems another thing that Russ gives us

00:12:32,160 --> 00:12:37,140
that makes our life a little easier on

00:12:34,230 --> 00:12:40,800
the single binary application front is

00:12:37,140 --> 00:12:44,460
that it supports static linking so when

00:12:40,800 --> 00:12:46,080
we pull in a crate dependency we don't

00:12:44,460 --> 00:12:48,210
end up with a bunch of shared objects

00:12:46,080 --> 00:12:50,420
that we need to load at runtime instead

00:12:48,210 --> 00:12:53,880
they all get linked into our application

00:12:50,420 --> 00:12:57,120
to support you know a single single

00:12:53,880 --> 00:12:59,400
binary distribution the goal here is to

00:12:57,120 --> 00:13:01,200
be able to take that single binary and

00:12:59,400 --> 00:13:03,810
drop it into a from scratch docker

00:13:01,200 --> 00:13:07,470
container and have you know a full rails

00:13:03,810 --> 00:13:11,430
installation right there additionally on

00:13:07,470 --> 00:13:14,130
Linux Russ supports building against

00:13:11,430 --> 00:13:17,000
muscle Lib C which gives us even more

00:13:14,130 --> 00:13:19,470
hermetic nough since single binary

00:13:17,000 --> 00:13:25,500
applications with no dependencies on the

00:13:19,470 --> 00:13:26,850
host system at all it's all great we've

00:13:25,500 --> 00:13:28,320
got this Russ tool chain that's gonna

00:13:26,850 --> 00:13:29,880
make our life a little easier when it

00:13:28,320 --> 00:13:31,860
comes to meeting some of our goals but

00:13:29,880 --> 00:13:35,010
that doesn't help us actually build the

00:13:31,860 --> 00:13:37,470
Ruby so how do we take these Russ tools

00:13:35,010 --> 00:13:43,620
and turn them into something that looks

00:13:37,470 --> 00:13:46,560
like Ruby for me the most recognizable

00:13:43,620 --> 00:13:48,690
part of Ruby is the core Ruby core

00:13:46,560 --> 00:13:50,790
consists of a bunch of classes and

00:13:48,690 --> 00:13:53,850
modules that make up the API is that you

00:13:50,790 --> 00:13:56,790
use everyday things like the env object

00:13:53,850 --> 00:13:59,160
or array or file or regex bin match data

00:13:56,790 --> 00:14:02,010
this is how you go about writing Ruby

00:13:59,160 --> 00:14:03,720
code so in order to you know build a

00:14:02,010 --> 00:14:07,910
Ruby we need to build all of these

00:14:03,720 --> 00:14:07,910
pieces how do we go about doing that

00:14:08,510 --> 00:14:16,650
well to align with some of the goals of

00:14:13,260 --> 00:14:18,510
the project Ruby core actually consists

00:14:16,650 --> 00:14:20,690
of the core objects that are backed by

00:14:18,510 --> 00:14:22,500
multiple implementations of the same

00:14:20,690 --> 00:14:25,440
interface

00:14:22,500 --> 00:14:28,200
these interfaces and what is exposed or

00:14:25,440 --> 00:14:32,060
configurable at compile time let's take

00:14:28,200 --> 00:14:32,060
a look at what exactly that means

00:14:33,110 --> 00:14:41,340
so env is how you access the system

00:14:37,530 --> 00:14:43,860
environ in Ruby it is a little unobvious

00:14:41,340 --> 00:14:46,110
how env works in the context of web

00:14:43,860 --> 00:14:47,820
assembly given that this is not a UNIX

00:14:46,110 --> 00:14:49,860
based platform and there's really no

00:14:47,820 --> 00:14:53,100
environment to speak of but this program

00:14:49,860 --> 00:14:57,390
right here will run and it does so using

00:14:53,100 --> 00:14:59,790
an alternate back-end of env so there

00:14:57,390 --> 00:15:02,280
are two implementations of env that

00:14:59,790 --> 00:15:04,980
artichoke exposes the first is probably

00:15:02,280 --> 00:15:06,360
the obvious one it talks to the system

00:15:04,980 --> 00:15:09,180
environment and it makes it really easy

00:15:06,360 --> 00:15:11,460
for you now to modify your path or you

00:15:09,180 --> 00:15:15,270
know modify your LD preload or whatever

00:15:11,460 --> 00:15:17,190
you want but maybe modifying those

00:15:15,270 --> 00:15:19,110
things is not what you want if you're

00:15:17,190 --> 00:15:22,590
executing Ruby in the context of a game

00:15:19,110 --> 00:15:25,290
engine so the second implementation of

00:15:22,590 --> 00:15:28,440
env is backed by hash map but has the

00:15:25,290 --> 00:15:31,890
same API as the normal env so programs

00:15:28,440 --> 00:15:41,190
that expect it are able to behave in the

00:15:31,890 --> 00:15:43,350
same way this is how you build a ruby

00:15:41,190 --> 00:15:45,600
that is able to execute in untrusted

00:15:43,350 --> 00:15:48,600
context by allowing you to turn off and

00:15:45,600 --> 00:15:56,210
on different features of the API based

00:15:48,600 --> 00:15:58,920
on compile time flags another

00:15:56,210 --> 00:16:00,600
interesting piece you would want when

00:15:58,920 --> 00:16:02,310
you're building a ruby that maybe

00:16:00,600 --> 00:16:06,780
doesn't have access to file descriptors

00:16:02,310 --> 00:16:08,910
is some notion of capturable IO in web

00:16:06,780 --> 00:16:11,100
assembly there is no file descriptor one

00:16:08,910 --> 00:16:12,510
for you to print stuff out to but still

00:16:11,100 --> 00:16:13,920
throughout all these demos we've been

00:16:12,510 --> 00:16:16,680
able to print stuff to the screen and

00:16:13,920 --> 00:16:18,780
the way that works is by having the

00:16:16,680 --> 00:16:21,720
interpreter exposed multiple different

00:16:18,780 --> 00:16:24,480
IO strategies that can optionally

00:16:21,720 --> 00:16:27,210
capture IO into a buffer as it is

00:16:24,480 --> 00:16:29,850
generated and then be extracted from

00:16:27,210 --> 00:16:32,130
those interpreter components later on so

00:16:29,850 --> 00:16:34,740
here we have some code that I ripped

00:16:32,130 --> 00:16:36,300
from starwars that's going to you know

00:16:34,740 --> 00:16:38,250
issue some warnings and

00:16:36,300 --> 00:16:40,770
sure that the x-wings are ready to

00:16:38,250 --> 00:16:43,500
attack the dust the Deathstar and all of

00:16:40,770 --> 00:16:48,960
that io is captured and put on the

00:16:43,500 --> 00:16:51,810
screen here additionally we can sort of

00:16:48,960 --> 00:16:53,820
add and remove different parts of Io if

00:16:51,810 --> 00:16:56,310
we would like in order to improve the

00:16:53,820 --> 00:16:57,810
security guarantees of the Ruby that

00:16:56,310 --> 00:17:00,720
we're building there are some

00:16:57,810 --> 00:17:03,710
particularly scary parts of Io such as

00:17:00,720 --> 00:17:06,480
iota P open and kernel open with a pipe

00:17:03,710 --> 00:17:09,090
we probably don't want access to these

00:17:06,480 --> 00:17:12,240
things in a web assembly environment or

00:17:09,090 --> 00:17:15,210
in a game engine but we're able to

00:17:12,240 --> 00:17:16,100
disable them by turning them off at

00:17:15,210 --> 00:17:19,190
compile time

00:17:16,100 --> 00:17:23,460
the way this is implemented is that

00:17:19,190 --> 00:17:25,650
these dangerous ap eyes are an optional

00:17:23,460 --> 00:17:27,420
feature that is enabled by default which

00:17:25,650 --> 00:17:28,980
means when you're building for a more

00:17:27,420 --> 00:17:30,840
specialized environment like web

00:17:28,980 --> 00:17:34,550
assembly you just turn these features

00:17:30,840 --> 00:17:34,550
off and you don't get access to them

00:17:37,430 --> 00:17:41,940
additionally we have this wonderful

00:17:40,170 --> 00:17:43,560
virtual file system that's embedded in

00:17:41,940 --> 00:17:46,680
artichoke that allows us to do fun

00:17:43,560 --> 00:17:48,480
things like require things from disk

00:17:46,680 --> 00:17:51,960
even though we don't actually have a

00:17:48,480 --> 00:17:54,170
disk so the JSON implementation in

00:17:51,960 --> 00:17:56,130
artichoke uses the JSON pure

00:17:54,170 --> 00:17:58,050
implementation that's present in Ruby

00:17:56,130 --> 00:18:00,120
and that's just a bunch of Ruby files

00:17:58,050 --> 00:18:02,640
that are loaded from disk from the Lib

00:18:00,120 --> 00:18:04,710
directory and during build time we

00:18:02,640 --> 00:18:07,860
actually embed these sources in the

00:18:04,710 --> 00:18:09,240
artichoke binary and expose them to the

00:18:07,860 --> 00:18:11,490
interpreter through a virtual file

00:18:09,240 --> 00:18:13,140
system this is the same virtual file

00:18:11,490 --> 00:18:15,480
system that all those rust extensions

00:18:13,140 --> 00:18:18,330
get loaded into as well which means that

00:18:15,480 --> 00:18:21,710
the rest of the interpreter doesn't have

00:18:18,330 --> 00:18:23,970
to think about the difference between a

00:18:21,710 --> 00:18:25,770
ruby source that's actually on disk

00:18:23,970 --> 00:18:27,870
versus a ruby source that is you know

00:18:25,770 --> 00:18:29,820
maybe embedded in the binary which makes

00:18:27,870 --> 00:18:32,340
it easier to support the use cases of

00:18:29,820 --> 00:18:34,410
single binary applications as well so

00:18:32,340 --> 00:18:36,120
here we're gonna require some JSON and

00:18:34,410 --> 00:18:40,250
turn it to JSON and print it out and

00:18:36,120 --> 00:18:40,250
that's great we have JSON yay

00:18:43,140 --> 00:18:47,530
another instance of this sort of

00:18:45,850 --> 00:18:49,210
multiple back-end pattern and allowing

00:18:47,530 --> 00:18:50,380
us to turn things on and off a

00:18:49,210 --> 00:18:53,950
compile-time

00:18:50,380 --> 00:18:56,650
is regex regex is pretty pervasive it

00:18:53,950 --> 00:18:58,690
allows us to you know match against text

00:18:56,650 --> 00:19:00,270
content and see what we have going on

00:18:58,690 --> 00:19:02,680
there

00:19:00,270 --> 00:19:04,540
artichoke actually has three

00:19:02,680 --> 00:19:08,910
implementations of regex floating around

00:19:04,540 --> 00:19:14,800
in it oh and one of those is based on

00:19:08,910 --> 00:19:19,240
ona Karuma which is the Ruby Ruby regex

00:19:14,800 --> 00:19:21,280
library and we use that in order to you

00:19:19,240 --> 00:19:24,190
know validate patterns to make sure that

00:19:21,280 --> 00:19:25,450
they are you know ones that we can

00:19:24,190 --> 00:19:28,000
actually match against that Ruby

00:19:25,450 --> 00:19:30,070
supports but most of the time after we

00:19:28,000 --> 00:19:33,670
do that validation we delegate to a Russ

00:19:30,070 --> 00:19:35,260
library that is much faster for patterns

00:19:33,670 --> 00:19:38,950
that do not have any backtracking in

00:19:35,260 --> 00:19:41,620
them this also allows us to turn off on

00:19:38,950 --> 00:19:44,080
a guru room at compile time to be rid of

00:19:41,620 --> 00:19:46,270
a C dependency while building artichoke

00:19:44,080 --> 00:19:47,680
which for a context like webassembly is

00:19:46,270 --> 00:19:49,900
much more convenient because

00:19:47,680 --> 00:19:54,550
Rost natively compiles to webassembly

00:19:49,900 --> 00:19:57,280
whereas c is a little more tricky so

00:19:54,550 --> 00:19:58,540
here we have this giant haystack and

00:19:57,280 --> 00:20:01,870
we're gonna try and find the path to

00:19:58,540 --> 00:20:05,590
enlightenment when we run this the regex

00:20:01,870 --> 00:20:07,360
implementation does what we expect regex

00:20:05,590 --> 00:20:09,940
and mash data were two of the first

00:20:07,360 --> 00:20:13,720
components of cor that were implemented

00:20:09,940 --> 00:20:25,800
in artichoke driven by the desire to run

00:20:13,720 --> 00:20:28,600
Sinatra so we've got parts of core now

00:20:25,800 --> 00:20:32,290
how can we sort of go one step further

00:20:28,600 --> 00:20:34,000
and leverage rust and the ecosystem and

00:20:32,290 --> 00:20:36,940
some of the design considerations that

00:20:34,000 --> 00:20:40,660
we've been working with so far to make

00:20:36,940 --> 00:20:43,510
Ruby faster using using some of those

00:20:40,660 --> 00:20:46,740
tools all of the benchmarks run on the

00:20:43,510 --> 00:20:50,940
next few slides we're done on an AWS ec2

00:20:46,740 --> 00:20:50,940
c5 2x large instance

00:20:52,890 --> 00:21:01,140
so string scan is an API that takes

00:20:56,610 --> 00:21:06,150
either a string or a regex and finds all

00:21:01,140 --> 00:21:09,270
of the matches in the in the body of the

00:21:06,150 --> 00:21:12,510
string that were we're testing here

00:21:09,270 --> 00:21:15,690
we're testing a six point eight seven

00:21:12,510 --> 00:21:18,630
megabyte Unicode text which looks like

00:21:15,690 --> 00:21:23,100
this this is the text of learn X&Y

00:21:18,630 --> 00:21:28,380
minutes and we're gonna scan for these

00:21:23,100 --> 00:21:31,500
particular fixed string patterns when we

00:21:28,380 --> 00:21:34,860
do that artichoke is about 25% faster

00:21:31,500 --> 00:21:39,350
than MRI the way it is able to do that

00:21:34,860 --> 00:21:42,059
is that artichoke uses a vectorized

00:21:39,350 --> 00:21:43,830
implementation of a two way substring

00:21:42,059 --> 00:21:45,660
search algorithm which sounds very

00:21:43,830 --> 00:21:47,370
complicated but it's great that I didn't

00:21:45,660 --> 00:21:50,370
have to implement any of that because

00:21:47,370 --> 00:21:53,700
the high quality create infrastructure

00:21:50,370 --> 00:21:55,470
that rust exposes to us I did try and

00:21:53,700 --> 00:21:59,780
implement it and I failed miserably so I

00:21:55,470 --> 00:21:59,780
was happy to delegate to a crate there

00:22:01,549 --> 00:22:08,880
if we do the same test over the same

00:22:04,860 --> 00:22:11,309
corpus but instead use a few regex we'll

00:22:08,880 --> 00:22:14,580
also see that artichoke is a bit faster

00:22:11,309 --> 00:22:17,010
and the reason falls back on those three

00:22:14,580 --> 00:22:23,150
different implementations of regex that

00:22:17,010 --> 00:22:26,850
we have so when we are scanning with a

00:22:23,150 --> 00:22:28,830
regex pattern we you know necessarily

00:22:26,850 --> 00:22:30,390
have to do the register scanning there's

00:22:28,830 --> 00:22:32,010
no backtracking in any of these so we

00:22:30,390 --> 00:22:33,919
don't necessarily need to pay for the

00:22:32,010 --> 00:22:36,660
overhead of a backtracking engine and

00:22:33,919 --> 00:22:38,760
additionally for each match were

00:22:36,660 --> 00:22:40,290
required to construct a match data

00:22:38,760 --> 00:22:40,740
object which has a reference to the

00:22:40,290 --> 00:22:43,590
regex

00:22:40,740 --> 00:22:48,110
and artichoke is able to do this in a

00:22:43,590 --> 00:22:52,140
lazy manner that doesn't actually do any

00:22:48,110 --> 00:22:55,350
substantial allocation of match data

00:22:52,140 --> 00:22:58,410
objects so when we combine those things

00:22:55,350 --> 00:23:01,860
together we get implementation that is

00:22:58,410 --> 00:23:05,280
about 50% faster than MRI again relying

00:23:01,860 --> 00:23:05,950
on the RUS ecosystem to pull in regex

00:23:05,280 --> 00:23:09,370
engine that

00:23:05,950 --> 00:23:11,380
is backed by deterministic finite

00:23:09,370 --> 00:23:14,850
automaton which sounds very complicated

00:23:11,380 --> 00:23:14,850
and I'm glad I didn't need to implement

00:23:16,860 --> 00:23:23,950
another cool thing that artichoke has

00:23:20,799 --> 00:23:26,289
that I'm not sure any other alternative

00:23:23,950 --> 00:23:29,350
Ruby implementation has is this concept

00:23:26,289 --> 00:23:32,769
of a source array so if you run just the

00:23:29,350 --> 00:23:34,630
first two lines of this program in any

00:23:32,769 --> 00:23:36,669
other Ruby interpreter you will have a

00:23:34,630 --> 00:23:39,669
very sad time trying to allocate all of

00:23:36,669 --> 00:23:42,490
that memory we haven't talked about

00:23:39,669 --> 00:23:45,669
array much but it has the same concept

00:23:42,490 --> 00:23:49,720
of multiple backends that that the rest

00:23:45,669 --> 00:23:53,260
of the core does so this first line

00:23:49,720 --> 00:23:55,889
actually creates a aggregate array that

00:23:53,260 --> 00:23:57,460
contains two sub arrays one is a sparse

00:23:55,889 --> 00:24:00,370
array of nulls

00:23:57,460 --> 00:24:03,010
and the other is a specialized array of

00:24:00,370 --> 00:24:04,630
one element same with concat we're

00:24:03,010 --> 00:24:07,529
adding to this aggregate array a

00:24:04,630 --> 00:24:10,630
sequence based array at the front and

00:24:07,529 --> 00:24:13,269
buffer types to the end reverse happens

00:24:10,630 --> 00:24:15,220
very quickly because even though we have

00:24:13,269 --> 00:24:16,750
of quadrillion elements in the array

00:24:15,220 --> 00:24:18,820
that sparse array doesn't need to

00:24:16,750 --> 00:24:23,350
actually do any reversals because it's

00:24:18,820 --> 00:24:25,299
just a bunch of nulls and yeah when we

00:24:23,350 --> 00:24:27,519
run this on artichoke it takes about

00:24:25,299 --> 00:24:30,480
seven megabytes of memory but MRI is

00:24:27,519 --> 00:24:30,480
like nope

00:24:34,279 --> 00:24:41,149
some of the upcoming work that we have

00:24:37,720 --> 00:24:44,840
for artichoke mostly revolves around the

00:24:41,149 --> 00:24:47,059
core artichoke in the true New Jersey

00:24:44,840 --> 00:24:50,120
style doesn't actually implement its own

00:24:47,059 --> 00:24:53,269
VM or parser it relies on M Ruby for

00:24:50,120 --> 00:24:56,120
those so most of the work is involved

00:24:53,269 --> 00:24:59,809
around pulling parts of Ruby core out of

00:24:56,120 --> 00:25:02,840
M Ruby to enable work to on the VM and

00:24:59,809 --> 00:25:05,960
parser later on so things we're looking

00:25:02,840 --> 00:25:11,659
forward to or a hash with a small Veck

00:25:05,960 --> 00:25:13,669
back-end hashes of small numbers of keys

00:25:11,659 --> 00:25:15,529
and values are quickly implemented as a

00:25:13,669 --> 00:25:17,330
vector because computers are very good

00:25:15,529 --> 00:25:20,409
at scanning linear chunks of memory and

00:25:17,330 --> 00:25:24,049
less good about doing random access

00:25:20,409 --> 00:25:26,149
additionally we need a range

00:25:24,049 --> 00:25:28,370
implementation and would simultaneously

00:25:26,149 --> 00:25:31,009
like to implement a specialized array

00:25:28,370 --> 00:25:32,990
type that is backed by a range when you

00:25:31,009 --> 00:25:35,090
call you know a range from one to a

00:25:32,990 --> 00:25:37,220
thousand to a that doesn't actually need

00:25:35,090 --> 00:25:38,299
to create an array of all of those

00:25:37,220 --> 00:25:41,690
elements

00:25:38,299 --> 00:25:44,029
additionally extending file to actually

00:25:41,690 --> 00:25:45,500
support the operating system back-end as

00:25:44,029 --> 00:25:47,840
opposed to being trapped in an in-memory

00:25:45,500 --> 00:25:53,419
file system is something that we need to

00:25:47,840 --> 00:25:55,129
do so that's everything I have

00:25:53,419 --> 00:25:57,590
again I'm I hope you're looking forward

00:25:55,129 --> 00:26:00,769
to checking out artichoke on github and

00:25:57,590 --> 00:26:02,600
maybe sending a PR or two please check

00:26:00,769 --> 00:26:03,610
out artichoke tout run and thank you

00:26:02,600 --> 00:26:06,860
very much

00:26:03,610 --> 00:26:06,860
[Applause]

00:26:10,490 --> 00:26:13,589
[Applause]

00:26:14,650 --> 00:26:20,230
if I could summarize the question its

00:26:16,900 --> 00:26:23,170
how do you think about enabling a

00:26:20,230 --> 00:26:26,190
compilation to wesam versus being a Ruby

00:26:23,170 --> 00:26:30,760
interpreter that is able to target wasum

00:26:26,190 --> 00:26:32,820
okay so I think for now we are a Ruby

00:26:30,760 --> 00:26:36,250
interpreter that targets web assembly

00:26:32,820 --> 00:26:38,200
there is a shell of a project in the

00:26:36,250 --> 00:26:42,450
github called Jasper which we would love

00:26:38,200 --> 00:26:45,520
contributions to that is intended to

00:26:42,450 --> 00:26:48,850
bundle a full application into a web

00:26:45,520 --> 00:26:52,030
assembly bundle for now that would

00:26:48,850 --> 00:26:53,980
mostly involve like concatenating those

00:26:52,030 --> 00:26:57,490
sources into the virtual file system but

00:26:53,980 --> 00:26:58,900
like if you extend that vision out it

00:26:57,490 --> 00:27:00,910
could potentially involve you know

00:26:58,900 --> 00:27:02,680
static compilation total web assembly as

00:27:00,910 --> 00:27:06,550
well but I would say that is like very

00:27:02,680 --> 00:27:09,010
far away into the future I have heard of

00:27:06,550 --> 00:27:11,410
it but I have Oh sorry have you gotten

00:27:09,010 --> 00:27:13,840
any usage out of the rubinius standard

00:27:11,410 --> 00:27:19,210
library I've heard of it I have not

00:27:13,840 --> 00:27:22,000
actually looked at it most of the core

00:27:19,210 --> 00:27:24,760
has been at least the Ruby

00:27:22,000 --> 00:27:28,330
implementations has been bootstrapped

00:27:24,760 --> 00:27:30,640
with the EM Ruby core but because M Ruby

00:27:28,330 --> 00:27:35,790
targets the ISO standard of Ruby as

00:27:30,640 --> 00:27:37,260
opposed to Ruby to 6 ah it's largely

00:27:35,790 --> 00:27:43,450
uncomplaining

00:27:37,260 --> 00:27:44,980
so has has required some surgery on how

00:27:43,450 --> 00:27:48,550
does artichoke deal with third-party

00:27:44,980 --> 00:27:52,990
gems is the question so when I was

00:27:48,550 --> 00:27:56,800
building the RAC clone that ran Sinatra

00:27:52,990 --> 00:27:58,930
I did this by vendor in the gems into

00:27:56,800 --> 00:28:01,120
the repo patching them so that they ran

00:27:58,930 --> 00:28:02,560
on the particular version of the

00:28:01,120 --> 00:28:04,810
interpreter that I was using and then

00:28:02,560 --> 00:28:07,570
embedding those gem sources into the

00:28:04,810 --> 00:28:09,510
binary that is not super sustainable and

00:28:07,570 --> 00:28:14,470
that's why something like jasper is

00:28:09,510 --> 00:28:16,300
important for taking the full spread of

00:28:14,470 --> 00:28:19,750
sources from your Ruby application and

00:28:16,300 --> 00:28:22,630
bundling them up for you so in

00:28:19,750 --> 00:28:24,110
webassembly there are no threads and the

00:28:22,630 --> 00:28:25,640
EM Ruby

00:28:24,110 --> 00:28:29,539
interpreter we are bootstrapped with

00:28:25,640 --> 00:28:33,529
it's not thread safe so the way I do

00:28:29,539 --> 00:28:36,200
this today is to have a blocking

00:28:33,529 --> 00:28:39,500
implementation of thread and mutex and

00:28:36,200 --> 00:28:41,380
monitor which allows you to simulate

00:28:39,500 --> 00:28:47,539
thread and have access to the full API

00:28:41,380 --> 00:28:50,720
but not actually be concurrent this is

00:28:47,539 --> 00:28:53,630
nice because it lets you do things like

00:28:50,720 --> 00:28:55,789
access thread locals in a way that makes

00:28:53,630 --> 00:28:58,970
the application run similar to how we

00:28:55,789 --> 00:29:00,830
have this shim for env even when there's

00:28:58,970 --> 00:29:03,000
no environment that we can that we can

00:29:00,830 --> 00:29:07,110
shell out - thank you

00:29:03,000 --> 00:29:19,200
[Applause]

00:29:07,110 --> 00:29:19,200

YouTube URL: https://www.youtube.com/watch?v=QMni48MBqFw


