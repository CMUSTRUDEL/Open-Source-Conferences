Title: RubyConf 2019 - A Static Type Analyzer of Untyped Ruby Code for Ruby 3 by Yusuke Endoh
Publication date: 2019-11-29
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - A Static Type Analyzer of Untyped Ruby Code for Ruby 3 by Yusuke Endoh

Ruby 3 is planned to provide a toolchain for static analysis: (1) the standard type signature format for Ruby code, (2) a type analyzer to guess a signature of a non-signatured Ruby code, and (3) a type checker (such as Sorbet) to verify a code with its signature. In the talk, we present a candidate of (2), called Type Profiler, which aims to allow you not to write a signature manually. It abstractly runs a non-annotated Ruby code in "type" level, tries to find possible errors, and generates a type signature prototype for the code. We show some demos and development progress.

#confreaks #rubyconf2019
Captions: 
	00:00:00,130 --> 00:00:24,319
>> Hello. All right. Okay. So, let's start. I talk about ‑‑ this is the second time

00:00:24,319 --> 00:00:33,950
for me to talk to RubyConf. Sorry? Okay. Thank you. 

00:00:33,950 --> 00:00:43,900
But the previous talk, my previous talk is about reprogramming. So this is the first

00:00:43,900 --> 00:00:50,160
time for me to talk about this. I will do my best. 

00:00:50,160 --> 00:01:04,580
Okay. I am Yusuke. I became a Ruby programmer in 2008. The most famous feature I contributed

00:01:04,580 --> 00:01:12,619
is perhaps keyword argument. I implemented keyword argument at Ruby 2.0. And I created

00:01:12,619 --> 00:01:28,829
a benchmark program for Ruby 3x3 called Optcarrot. And I was Ruby 2.0 release manager, and I have

00:01:28,829 --> 00:01:37,720
been still involved in the management until today. So, I'm also working on quality assurance

00:01:37,720 --> 00:01:47,689
of Ruby, including the tests.  I'm working at Cookpad, and as my job, I'm

00:01:47,689 --> 00:02:02,240
developing Ruby with ko.  So let me briefly introduce our company. Cookpad

00:02:02,240 --> 00:02:10,170
is a company aiming to make everyday cooking fun as our mission. So, the main service

00:02:10,170 --> 00:02:17,610
is a recipe sharing service. You can submit your cooking recipe and also enjoy recipes

00:02:17,610 --> 00:02:24,210
that other users shared. And there's about 93 million users in the world. 

00:02:24,210 --> 00:02:42,420
We support about 30 languages and about 73 countries. The service is going to aim to

00:02:42,420 --> 00:02:49,890
be number one in 100 countries. Cookpad ‑‑ to maintain this large scale service, we need

00:02:49,890 --> 00:02:57,190
many great Ruby engineers, so we are hiring. I'm working at Japan office, but Cookpad headquarters

00:02:57,190 --> 00:03:03,430
is in united kingdom. If you are interested, contact me. 

00:03:03,430 --> 00:03:15,191
So today, I will talk about three topics. One is Matz's plan for Ruby 3 types. As Matz

00:03:15,191 --> 00:03:23,160
said in his keynote ‑‑ sorry. As you see, the previous two talks in this room were

00:03:23,160 --> 00:03:33,110
both about Sorbet, a type checker for Ruby. And Sorbet is the most mature, but there are some

00:03:33,110 --> 00:03:44,180
other proposed type managers for Ruby. With Sorbet team and other authors including me

00:03:44,180 --> 00:03:53,500
held monthly online meeting with Matz to discuss Ruby 3 static analysis. And Matz's branding

00:03:53,500 --> 00:04:04,819
to put them into one big picture. Allowing users to choose a suitable type checker according

00:04:04,819 --> 00:04:14,570
to their needs.  A key feature to integrate is Ruby signature. This

00:04:14,570 --> 00:04:22,291
is the standard format to write typing information for Ruby code. All the type checkers can

00:04:22,291 --> 00:04:31,570
use and share the same type signatures for Ruby stdlib and gems. And finally, I would

00:04:31,570 --> 00:04:38,820
like to talk about my project called type profiler. Type profiler is a type analysis

00:04:38,820 --> 00:04:45,370
for non‑annotated Ruby code. It aims to provide a cleaned up type interface to help

00:04:45,370 --> 00:04:54,870
write a signature.  Okay. I will explain each one. First is

00:04:54,870 --> 00:05:06,330
Matz said that Ruby 3 will provide type static analysis feature. Oops. And the objective

00:05:06,330 --> 00:05:18,750
is to find possible bugs without execution. The aim is to improve development experience for

00:05:18,750 --> 00:05:37,140
humans. But it is not just for humans. So, for example, this method is considered exception

00:05:37,140 --> 00:05:49,500
1 this increment method. But this definition has one type. Integer time is written, and

00:05:49,500 --> 00:06:03,070
it has another type error. If you can find such bugs before running, that would be great. The

00:06:03,070 --> 00:06:15,060
simple solution is to apply torsion type checking to Ruby. But torsion type checking requires

00:06:15,060 --> 00:06:24,260
more or less type annotation. For example, so you need to write what types the method

00:06:24,260 --> 00:06:33,490
accepts and returns, like these green lines.  If people accept this annotation, this style

00:06:33,490 --> 00:06:41,010
of annotation, it is simple. So, here I would like to ask you, do you want to write annotation

00:06:41,010 --> 00:06:55,180
into your code? If you want to write, please raise your hand. Oops. Take a picture. Okay. Thank

00:06:55,180 --> 00:06:59,889
you.  And next, if you don't want to write such

00:06:59,889 --> 00:07:10,350
annotations, please raise your hand. Whoa!  Okay. Thank you. Honestly, I prepared two

00:07:10,350 --> 00:07:12,449
slides.  [ Laughter ]

00:07:12,449 --> 00:07:22,460
It was unexpected for me. I thought many of you would like to write type annotations

00:07:22,460 --> 00:07:29,320
because they are actually useful not only for type checkers, but also as a communication

00:07:29,320 --> 00:07:37,100
to explain the API to other developers. So, it is important, especially in large scale

00:07:37,100 --> 00:07:46,389
projects. And actually in Ruby 3, you can write types by hand if you like. Because

00:07:46,389 --> 00:07:52,831
Ruby 3 will provide the optional way to write type annotations. And if you like them, you

00:07:52,831 --> 00:08:01,870
will gain stronger type checking by Sorbet as a type checker. 

00:08:01,870 --> 00:08:09,451
However, Matz said in his keynote, he still hates type annotations. This is why I am

00:08:09,451 --> 00:08:19,850
working on my project. By using type profiler in Ruby 3, you don't have to write annotations

00:08:19,850 --> 00:08:32,460
by hand. And you can check your code with almost or no annotations. If my project is

00:08:32,460 --> 00:08:41,010
successful. Unfortunately, what type profiler aim ‑‑ honestly, the 

00:08:41,010 --> 00:08:48,490
development of type profiler is going through difficulties. But to keep Ruby clean by default,

00:08:48,490 --> 00:08:55,550
I write it.  To achieve this goal, Matz is currently planning

00:08:55,550 --> 00:09:05,770
for Ruby 3 to provide three features. First is Ruby signature language, the standard type

00:09:05,770 --> 00:09:15,940
signature format for stdlib. Second is type inference for non‑annotated code. Third

00:09:15,940 --> 00:09:24,100
is a type checker that verifies the consistency between code and signatures. So, by using

00:09:24,100 --> 00:09:33,420
item one, Ruby signature, you can write type signatures by hand. But you don't have to

00:09:33,420 --> 00:09:43,660
do it manually using item two. You can automatically generate profiler signatures for your code. Your

00:09:43,660 --> 00:09:54,030
non‑annotated code. And finally you will have signatures for your code and by applying

00:09:54,030 --> 00:10:01,150
item 3, you can type check your code. Item three includes Sorbet. Sorbet has already

00:10:01,150 --> 00:10:07,810
been explained, so in this talk, I would like to explain items 1 and 2. 

00:10:07,810 --> 00:10:16,351
Okay. Ruby signatures. I asked a Ruby signature developer to explain himself. So, I pass

00:10:16,351 --> 00:10:27,980
the mic to him.  >> Thank you. So, I lead the design and implementation

00:10:27,980 --> 00:10:36,800
of RBS in the Ruby core team. I also developed my own static type checker called Steep, and

00:10:36,800 --> 00:10:44,110
there is a correction about the keynote yesterday. We don't have a session about Steep this year. So,

00:10:44,110 --> 00:10:57,430
I'm working for Square now.  So, this is the Ruby signature language RBS. It

00:10:57,430 --> 00:11:06,270
is standard language to describe the types of the Ruby programs like the classes, modules,

00:11:06,270 --> 00:11:16,339
variables, etc. So, one of the most important things in RBS is it is another language from

00:11:16,339 --> 00:11:24,470
Ruby. It is a different syntax, different semantics. It is ‑‑ we wanted to keep

00:11:24,470 --> 00:11:36,970
the Ruby code unannotated. The green lines are RBS on the slide. So, in inc.rbs, we

00:11:36,970 --> 00:11:46,130
have the type. It has a method increment. It receives one argument of integer and returns

00:11:46,130 --> 00:11:56,200
an integer. So, this is a bit similar to Ruby, I hope. It is structurally different

00:11:56,200 --> 00:12:12,500
syntax. So, in the inc.rb, it is the Ruby program you already use. So, the signature,

00:12:12,500 --> 00:12:21,450
it's written to another file.  This is another example of the RBS class definitions

00:12:21,450 --> 00:12:30,330
of array. So, we support generics. We support some overloading. We provide an optional

00:12:30,330 --> 00:12:38,680
types to represent it might be new. Or we allow you to write the type of blocks, and

00:12:38,680 --> 00:12:48,720
we support some of the mixins, including the include and extension. We also support to

00:12:48,720 --> 00:12:57,140
defining interface. So, the difference between class and modules in the interface is there

00:12:57,140 --> 00:13:05,610
is no component in Ruby program associated with interface. So, the interface we call

00:13:05,610 --> 00:13:12,990
duck is to support the duck typing. So, it means that there are no specific class associated

00:13:12,990 --> 00:13:20,670
with the interface, but duck type, the value of duck type has a method of quack. 

00:13:20,670 --> 00:13:32,730
So, RBS has two usages. The first one is for type checking. If you want to type check

00:13:32,730 --> 00:13:40,200
your application or your library using some static type checkers including Sorbet or Steep,

00:13:40,200 --> 00:13:48,860
then you need some type information of the libraries. So, the RBS is to describe the

00:13:48,860 --> 00:13:58,760
types of the classes included in the gems. Or, in fact, my type checker Steep uses RBS to

00:13:58,760 --> 00:14:06,360
define the signature of your library or your Ruby application. So, if it is defined for

00:14:06,360 --> 00:14:14,790
Sorbet for line type annotations into Ruby code, Steep uses a different file to write

00:14:14,790 --> 00:14:20,320
the signature of Ruby types, the types of Ruby application. 

00:14:20,320 --> 00:14:27,380
Another one is for documentation. So, RBS has all of the classes included in the program,

00:14:27,380 --> 00:14:35,140
and it describes what is the methods defined in the classes or its types. So, I believe

00:14:35,140 --> 00:14:44,390
that it's easier to use the RBS compared to ‑‑ to know about the classes. 

00:14:44,390 --> 00:14:54,170
So, this is how to use the RBS. Another one is how to make RBS. The easiest one is using

00:14:54,170 --> 00:15:00,680
some kind of the editors and write every line of the RBS yourself. But I know that it's

00:15:00,680 --> 00:15:09,160
super difficult, so we provide a tool to generate a template of the RBS from the Ruby called

00:15:09,160 --> 00:15:15,030
Sorbet RBI. It's super simple. It scans the program and detects some of the class

00:15:15,030 --> 00:15:19,110
definitions and method definitions and brings the templates. 

00:15:19,110 --> 00:15:26,980
Another one is generating the RBS from using Type Profiler. This is the subject of this

00:15:26,980 --> 00:15:45,550
session. Now I'm trying to go back to test RBS definitions. If it is correct one, using

00:15:45,550 --> 00:15:51,089
the runtime APIs by the dynamic type checking. So, it is an option that you don't want to type

00:15:51,089 --> 00:15:57,910
check your Ruby program, but you want to write RBS. So, this is a quick introduction of

00:15:57,910 --> 00:16:11,010
RBS. And so I'll hand it back to Yusuke.  >> Thank you. So, now we enter the main topic. This

00:16:11,010 --> 00:16:23,700
is my project called Type Profiler, and the key idea of the approach. Type Profiler has

00:16:23,700 --> 00:16:33,050
a clear advantage. It can write mostly non‑annotated Ruby code. But as I said, the test is changing,

00:16:33,050 --> 00:16:43,630
so there are some limitations.  So type profiler is a kind of type inference

00:16:43,630 --> 00:16:51,990
that accepts non‑annotated Ruby code and generates a prototype of signatures. This

00:16:51,990 --> 00:17:00,300
is very simple example. Type profiler is this code and suggests the signature type. And

00:17:00,300 --> 00:17:10,390
the increment is accept integer and return integer. So, there is no guesses. But type

00:17:10,390 --> 00:17:18,309
profiler may produce abnormal results. So, a user is assumed that they check the result

00:17:18,309 --> 00:17:26,380
before applying Type Checker.  And in addition, type profiler counts as a

00:17:26,380 --> 00:17:38,581
weak type checker. If type profiler finds unknown during analysis, the type profiler

00:17:38,581 --> 00:17:47,120
reports it as a possible error. And type profiler finds unresolvable overload such

00:17:47,120 --> 00:17:58,870
as integer plus in an argument. Type profiler finds a possible type error like this. 

00:17:58,870 --> 00:18:05,850
The analysis in general, we have torsion type checker such as Sorbet, but it may be useful

00:18:05,850 --> 00:18:15,530
if you don't want to maintain the signatures.  Okay. Before explaining how Type Profiler

00:18:15,530 --> 00:18:22,299
analyzes a record, I would like to briefly show what Type Profiler can do currently. I

00:18:22,299 --> 00:18:35,211
will show two simple case studies with two programs. Ao.rb and Optcarrot. Why is it

00:18:35,211 --> 00:18:44,350
called Ao.rb? It is a simple rendering program written in Ruby. It is about 300 lines of

00:18:44,350 --> 00:19:06,750
code. I will show it... okay.  And this is a normal Ruby code. This is normal

00:19:06,750 --> 00:19:19,390
Ruby code, as you can see. And applying type‑profiler to this code. It outputs like this, a prototype

00:19:19,390 --> 00:19:31,750
of signatures. I explain by using slides. This is the syntax of the signature prototype. Type‑profiler

00:19:31,750 --> 00:19:39,850
detected a class Vec definition. It is a 3D vector and you can see three instance variables,

00:19:39,850 --> 00:19:47,970
x, y, and z. And the union type is complex, float, and any. And the some vector operations. Vnormalize,

00:19:47,970 --> 00:19:51,280
vlength, and v dot. Vnormalize ‑‑ this is due to lack of written class as I showed

00:19:51,280 --> 00:19:52,810
the first code.  Oops. Ah. Vlength. Math.sqrt. And type

00:19:52,810 --> 00:19:56,700
profiler has no knowledge about that. So, this is my fault. And fortunately, I fixed

00:19:56,700 --> 00:20:01,190
this in the previous break. So, it is now ‑‑ oops. Vlength returns float. Correctly. Okay. 

00:20:01,190 --> 00:20:03,780
So, in this case, I succeeded to fix this, but type profiler may return. So, in such

00:20:03,780 --> 00:20:09,940
a case, you need to fix it by hand by rewriting the results. Maybe in this case, to float

00:20:09,940 --> 00:20:12,670
in this case.  Okay. Also type profiler detects scene class. There

00:20:12,670 --> 00:20:21,750
are instance variables as a type. And putting instance variables as planes. This represents

00:20:21,750 --> 00:20:30,660
a model. This has three results. And this type is like this. Type profiler found this. Okay. 

00:20:30,660 --> 00:20:34,010
So as you see, Type Profiler basically generates a signature prototype. In my opinion, it

00:20:34,010 --> 00:20:36,240
served as a good step to write signature for Ruby code instead of writing by hand. Also,

00:20:36,240 --> 00:20:40,790
this is not the main focus of Type Profiler, but it may be useful to understand the program

00:20:40,790 --> 00:20:50,190
structure. However, the prototype has some wrong and incomplete guesses. It is due to

00:20:50,190 --> 00:20:58,440
lack of knowledge of reading classes. I think I can somewhat improve the precision, but

00:20:58,440 --> 00:21:03,700
type profiler has limitations that I will explain later. 

00:21:03,700 --> 00:21:09,470
Okay. The latest case is so‑called optcarrot. It is an 8 bit program that I have created for

00:21:09,470 --> 00:21:14,799
Ruby 3x3. It has about 5,000 lines of code. This is a result. The main class optcarrot had

00:21:14,799 --> 00:21:19,590
some instance variables. It failed to detect other methods, but this is, again, due to

00:21:19,590 --> 00:21:23,520
many limiting functions. And that being said, the result is still useful for prototyping,

00:21:23,520 --> 00:21:31,220
I think. And actually somewhat informative. This class has three circuits, CPU, APU as audio

00:21:31,220 --> 00:21:37,500
processing unit, and the PPU as the picture processing unit. And nowadays we call it

00:21:37,500 --> 00:21:41,770
GPU. Okay?  And this is the observed class APU. APU combines

00:21:41,770 --> 00:21:44,410
four tests. Two pulse modules and one triangle module and one noise module. This result

00:21:44,410 --> 00:21:49,130
clearly shows the program structure result with messy implementation. Okay? So I didn't

00:21:49,130 --> 00:21:55,539
know it would analyze so deeply. It is meant to show simple results. This is because type

00:21:55,539 --> 00:22:01,720
profiler doesn't know about many built in classes and methods. This uses fiber class

00:22:01,720 --> 00:22:08,620
and type profiler doesn't know the class at all. So, type profiler ‑‑ if type profiler

00:22:08,620 --> 00:22:14,590
encounters unknown classes, they are looked at as in and can no longer analyze the code. But

00:22:14,590 --> 00:22:19,330
still the result is useful, I think, for prototyping a signature. The approach of type profiler,

00:22:19,330 --> 00:22:24,410
I explain next is never perfect. But I believe it is promising. Okay? 

00:22:24,410 --> 00:22:40,140
I briefly explained the key idea of type‑level profiler. I said it is kind of type inference,

00:22:40,140 --> 00:22:44,680
but it is very different from torsion type inference. It was sort of the interpretation

00:22:44,680 --> 00:22:58,720
of so called AI. Simple execution. The idea of type profiler is the Ruby code in type‑level. This

00:22:58,720 --> 00:23:04,090
shows a simple example. In Ruby interpreter, the last, a call to foo with element 42 pass

00:23:04,090 --> 00:23:09,929
into integer 42 and returns a string object. In type profiler, the same code passes an integer

00:23:09,929 --> 00:23:15,230
type instead of completing 42 and returns a string type like this. And type profiler

00:23:15,230 --> 00:23:19,950
records what types are passed and returned and shows the Ruby signature format. 

00:23:19,950 --> 00:23:23,710
Okay. Type profiler selects the concrete value. And so type profiler cannot tell which

00:23:23,710 --> 00:23:28,350
one you selected. For example, type profiler just notes integer in this case, so it cannot

00:23:28,350 --> 00:23:36,179
determine if less than 10 is what, so it forks the execution. In this case, it then returns

00:23:36,179 --> 00:23:40,080
an integer, and this returns a string. But type profiler suggests type signature by using

00:23:40,080 --> 00:23:44,679
union type method, accept integer and returns integer or string this is union type. 

00:23:44,679 --> 00:23:48,980
Okay. Finally I talk of the difficulties of type profiler. Type profiler works beautifully

00:23:48,980 --> 00:23:53,350
in some cases, but it has some limitation and incompleteness. I will explain. First

00:23:53,350 --> 00:23:59,929
is type profiler analyzes Ruby code by interpreting it. It cannot analyze untested methods. Typically,

00:23:59,929 --> 00:24:09,420
a tested code is a good way to trigger method in type profiler. If you write a test code

00:24:09,420 --> 00:24:16,690
like this, type profiler can infer the argument type on the return type or the method being

00:24:16,690 --> 00:24:28,360
tested like this. However, if there is no test for the method, the method is not used

00:24:28,360 --> 00:24:38,020
directly, type profiler cannot determine the signature of the method like this.

00:24:38,020 --> 00:24:44,940
Even you write this, some tests lead to wrong guess. For example, this test expects exception

00:24:44,940 --> 00:24:50,670
by passing wrong type arguments. In this case, type profiler doesn't know that this

00:24:50,670 --> 00:24:55,780
test expects exception, so it generates long signature like this. It is not the fact. And

00:24:55,780 --> 00:25:00,500
another case is a mock object. The test passes mock object object to method bar in this case.

00:25:00,500 --> 00:25:06,130
So type profiler infers the method is mockObject. But it is not expected signature, of course. 

00:25:06,130 --> 00:26:03,240
To prevent these wrong guesses, type profiler needs to know that 

00:26:03,240 --> 00:26:16,680
these tests are not suitable to infer the signature. Type profiler requires ‑‑

00:26:16,680 --> 00:26:48,320
so integration between type profiler and testing framework is needed. 

00:26:48,320 --> 00:26:54,799
Type profiler has Singleton limitations due to its type level interpretation. Typically

00:26:54,799 --> 00:27:01,900
type profiler cannot handle object send. This is an example. This specifies a target method

00:27:01,900 --> 00:27:19,790
by using inc to_sym in this example. Type profiler cannot do this because it has no

00:27:19,790 --> 00:27:31,020
knowledge. This is just sitting. It does not know the contents. So, type profiler

00:27:31,020 --> 00:27:46,870
cannot know the result is a symbol. But not symbol inc. So, type profiler cannot identify

00:27:46,870 --> 00:28:01,960
your target method so in this case the method inc cannot be inferred correctly. The

00:28:01,960 --> 00:28:06,460
same goes to other variable features for example, Singleton method. It cannot handle object #eval. But

00:28:06,460 --> 00:28:10,529
it supports class methods by special handling of class objects. And object eval and binding

00:28:10,529 --> 00:28:21,120
are different to deal with. In such case, you need to write a Ruby signature for such

00:28:21,120 --> 00:28:25,870
method by hand.  Now finally, actually designing and implementing

00:28:25,870 --> 00:28:30,120
type profiler is harder than implementing MRI‑compatible normal interpreter. This

00:28:30,120 --> 00:28:38,249
is excusable. I'm implementing it by trial and run. It has already taken one year. It

00:28:38,249 --> 00:28:44,760
does not support many language features yet. And features are not supported yet. The analysis

00:28:44,760 --> 00:29:00,059
performance must be improved. I need to perform more case studies with programs and applications. I

00:29:00,059 --> 00:29:08,890
would really appreciate your company's contribution.  Okay. Related work. MRuby meta‑circumstance

00:29:08,890 --> 00:29:18,200
Lahas type analysis for mRuby. It is also based on abstract interpretation. Actually,

00:29:18,200 --> 00:29:26,350
mRuby is like type profiler. And type analysis for JavaScript is a research project for inputting

00:29:26,350 --> 00:29:33,029
types of non‑annotated JavaScript. It is also based on abstract interpretation. And

00:29:33,029 --> 00:29:42,390
RDL is a research project to extend Ruby with types. And recently, Jeff Foster started

00:29:42,390 --> 00:32:57,620
supporting type inference. The approach is very different from ours. It is based 

00:32:57,620 --> 00:33:42,820
on traditional type inference with some heuristics. I hope their approach will succeed for the case

00:33:42,820 --> 00:34:03,130
where my project fails. And okay. Acknowledgment. Hideki Miura. And there are multiple discussions with Matz,

00:34:03,130 --> 00:34:25,369
akr, and ko1. And I wrote a paper in Japanese about this and Steep with partners. 

00:34:25,369 --> 00:34:30,669
And Jeff foster's research group is developing RDL. 

00:34:30,669 --> 00:34:42,569
Okay. I conclude this talk. I explained Matz's plan for Ruby 3 types. It consists

00:34:42,569 --> 00:34:53,709
of three key items. And I introduced Type Profiler, type inference that is included

00:34:53,709 --> 00:35:02,160
that is planned to be included. And Type Profiler is an approach that is applicable

00:35:02,160 --> 00:35:09,369
to non‑annotated Ruby code. It is based on abstract interpretation. I hope it will

00:35:09,369 --> 00:35:22,049
make it possible to analyze code with little change for Ruby's great programming experience. Type

00:35:22,049 --> 00:35:28,239
profiler is open source, so any comment or contributions are really welcome. 

00:35:28,239 --> 00:35:31,079
Okay. I conclude this talk. That's all. Thank you. 

00:35:31,079 --> 00:35:31,479

YouTube URL: https://www.youtube.com/watch?v=l1B3NJc2eU8


