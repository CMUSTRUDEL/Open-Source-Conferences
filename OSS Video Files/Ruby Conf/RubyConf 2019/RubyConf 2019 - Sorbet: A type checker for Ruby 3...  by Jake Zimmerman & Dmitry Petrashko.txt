Title: RubyConf 2019 - Sorbet: A type checker for Ruby 3...  by Jake Zimmerman & Dmitry Petrashko
Publication date: 2019-11-28
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Sorbet: A type checker for Ruby 3 you can use today! by Jake Zimmerman & Dmitry Petrashko

In June we open-sourced Sorbet, a fast, powerful type checker designed for Ruby. In the 6 months since, tons of things have improved! We’ve built quality editor tools like jump-to-def and seen many contributions from a growing community. Within Stripe, we've used Sorbet to drive code quality via measurable, concrete indicators.

We’ll share these improvements and give an update on our collaboration with Matz and the Ruby 3 Types working group. Suitable for anyone using Ruby—no familiarity with Sorbet needed! Come follow in the footsteps of the many companies already using Sorbet.

#confreaks #rubyconf2019
Captions: 
	00:00:12,370 --> 00:00:22,009
>> Hello, everybody. Welcome to RubyConf. This is a talk about sorbet, the type checker for

00:00:22,009 --> 00:00:26,270
Ruby 3 that you can use today. I'm Dmitry Petrashko.

00:00:26,270 --> 00:00:38,370
>> I'm Jake Zimmerman. >> First we will run through some of the background. Which

00:00:38,370 --> 00:00:44,600
problems that exist to solve and why we believe this is the right solution for them. We are

00:00:44,600 --> 00:00:50,989
followed by discussing the today reality of this, about how the community is using it

00:00:50,989 --> 00:00:56,640
today, how other companies are benefitting, and what is waiting for us in Ruby 3. 

00:00:56,640 --> 00:01:02,989
>> DMITRY: So we're coming from Stripe, which is a company that is helping other people

00:01:02,989 --> 00:01:10,070
run businesses online, helping them focus on building their products by making it easier

00:01:10,070 --> 00:01:16,610
for them to facilitate payments on the internet. Stripe has more than 2,000 employees. We have engineering

00:01:16,610 --> 00:01:23,650
hubs in San Francisco, Seattle, Dublin. We're hiring and we're also hiring remotes. Go

00:01:23,650 --> 00:01:30,990
online and see what positions are there.  We, more specifically, are members of Stripe

00:01:30,990 --> 00:01:36,530
developer productivity team. We're the teaming helping engineers have the most productive

00:01:36,530 --> 00:01:44,930
life of their career at Stripe. We help them focus on building the product rather than

00:01:44,930 --> 00:01:50,630
overcoming obstacles which are specific to development. 

00:01:50,630 --> 00:01:56,610
And Stripe, more specifically, uses Ruby a lot. Ruby is our main product language, and

00:01:56,610 --> 00:02:02,360
thus as developer productivity team is helping Stripe engineers be more productive, we mostly

00:02:02,360 --> 00:02:11,830
end up working in Ruby and building Ruby abstractions for Stripe. Thus, our customers, customers

00:02:11,830 --> 00:02:16,960
of mine, are internal Stripe engineers. There are hundreds of them writing millions of lines

00:02:16,960 --> 00:02:23,990
of code in a single repo. That's intentional. We want it to be easier to make changes, to make

00:02:23,990 --> 00:02:28,060
swapping changes around the entire code base so we have a single codebase with so many

00:02:28,060 --> 00:02:39,739
lines of code.  In order to figure out what do we do to make

00:02:39,739 --> 00:02:46,819
our engineers more productive, one of the ways we learn is by asking them. We run developer

00:02:46,819 --> 00:02:54,480
productivity survey. Before Sorbet existed, a common feedback that we heard is that for

00:02:54,480 --> 00:02:59,959
engineers, it was taking a long amount of time to get feedback for existing systems

00:02:59,959 --> 00:03:05,980
on whether their code is correct. It took too long to grasp the unfamiliar code, to

00:03:05,980 --> 00:03:11,810
read the code of other teams or previous people who were on the team. And it was ‑‑

00:03:11,810 --> 00:03:16,279
the codebase was pretty fragile. It was easy to break things and a lot of assumptions were

00:03:16,279 --> 00:03:24,770
unspoken. It was possible to break the things without noticing it. 

00:03:24,770 --> 00:03:30,510
So, we went to assess what were our options to improve the situation. The first option

00:03:30,510 --> 00:03:37,561
is do nothing. Ignore the feedback and let the engineers cope with the situation. The

00:03:37,561 --> 00:03:43,550
downside here is engineers will be less productive. They will continue facing this complexity of the

00:03:43,550 --> 00:03:50,299
code base, the brittleness, and increasing iteration cycle. The alternative was treat

00:03:50,299 --> 00:03:57,859
the symptoms. We could find the biggest offenders and fix them. But as the company is growing,

00:03:57,859 --> 00:04:04,029
we believe it would be increasingly harder for us as a single team to do this manually. So,

00:04:04,029 --> 00:04:08,180
we didn't choose this option, either.  Another option was declare bankruptcy and

00:04:08,180 --> 00:04:17,570
rewrite the thing. Rewrite it and make it perfect from the start. This was a high risk. We'll

00:04:17,570 --> 00:04:23,030
have to have hundreds of engineers rewriting our product. During that, we'll have to maintain

00:04:23,030 --> 00:04:28,181
both of them. And maybe it will succeed or fail, and it's all or nothing. It's either

00:04:28,181 --> 00:04:33,030
entirely successful or entirely failing. It's a high risk. 

00:04:33,030 --> 00:04:37,900
Another option was to write some things. Take ten engineers and take the horrendous offenders

00:04:37,900 --> 00:04:45,540
and rewrite the things that matters, but it's hard to agree what matters long term. It

00:04:45,540 --> 00:04:50,780
might be wrong. Some things that used to matter no longer matter and some things matter

00:04:50,780 --> 00:04:58,870
more now. You might be launching new products or changing priorities, and maybe there are

00:04:58,870 --> 00:05:03,509
pressures that make the area that used to be not important more important. So, it's

00:05:03,509 --> 00:05:09,720
a hard decision. And it requires substantial amount of engineering. And finally the one

00:05:09,720 --> 00:05:17,981
that we chose. We chose to write a type checker. This is a tool. This is not a process that you

00:05:17,981 --> 00:05:22,360
need to do. This is a tool that you do, and the tool works on everything. 

00:05:22,360 --> 00:05:28,599
So what we did is started a team with three engineers. The smallest investment in between

00:05:28,599 --> 00:05:36,139
all of those, which was able to deliver incremental value in a month. Every improvement was possible

00:05:36,139 --> 00:05:42,159
on a file by file basis. Improvements came every day rather than requiring a leap of

00:05:42,159 --> 00:05:46,960
faith, and a lot of engineers committed to the leap of faith. So, that's why we built

00:05:46,960 --> 00:05:52,700
the type checker.  Here is the timeline. In October 2017, the

00:05:52,700 --> 00:05:58,190
project was kicked off. Originally we have been evaluating a few other alternatives. Most

00:05:58,190 --> 00:06:05,990
notably, the type checker built for GitHub, we took the parser for it. And it's pretty

00:06:05,990 --> 00:06:14,550
good. We evaluated RDL, which was built by Jeff Foster. Unfortunately, it was too slow

00:06:14,550 --> 00:06:20,360
to work on our code base. It would have taken literally hours to do a single type checking. It

00:06:20,360 --> 00:06:27,199
would be slower than our test. So, because of this, we decided to implement our own thing. 

00:06:27,199 --> 00:06:36,409
In February 2018, we typed first production code in real world. We ourselves, as developers

00:06:36,409 --> 00:06:40,939
of the tool, were verifying whether our tool actually is useful by taking real code and

00:06:40,939 --> 00:06:48,090
trying to type exit seeing that error messages made sense. And to be honest, at first they

00:06:48,090 --> 00:06:53,069
didn't. They were complaining too much in some cases where the code is correct, but

00:06:53,069 --> 00:06:57,280
it doesn't like it. It wants to follow some scheme that you may disagree with, and you

00:06:57,280 --> 00:07:02,010
are probably right. Why is it forcing this on me? And in other cases it was permitting

00:07:02,010 --> 00:07:07,939
things that we didn't want. This is a moment that we believe contributed the most to the

00:07:07,939 --> 00:07:13,669
experience of using Sorbet. We have been intentionally building on a balance of allowing

00:07:13,669 --> 00:07:20,759
users to write the code that they want and checking the things that are there. We want

00:07:20,759 --> 00:07:26,870
the users to feel like this is a helper rather than prohibiting them from something. 

00:07:26,870 --> 00:07:32,900
And the manifestation of this was in June 2018, where we made this required for every

00:07:32,900 --> 00:07:38,390
engineer at Stripe. At that moment when it became enforced on everybody, this with us

00:07:38,390 --> 00:07:44,010
a moment where we were very careful to make sure that we're here for every engineer. If

00:07:44,010 --> 00:07:50,550
somebody doesn't like it, we want to make sure they hear heard. 

00:07:50,550 --> 00:07:56,860
Fortunately, it worked really well. A majority of people liked it. Some people were neutral

00:07:56,860 --> 00:08:00,659
for quite a time, but as we were developing more and more features that they cared about,

00:08:00,659 --> 00:08:09,810
they got on board. And a year later in 2019, after extensive beta with more than 40 companies,

00:08:09,810 --> 00:08:13,749
it was open sourced and now it's available for everybody to use. 

00:08:13,749 --> 00:08:20,620
So, I want to dive deeper in what problems did we want Sorbet to solve and how does this

00:08:20,620 --> 00:08:25,379
solve them? Jake?  >> JAKE: Thank you, Dmitry. All right. So,

00:08:25,379 --> 00:08:31,409
we're going to dive into what problems Sorbet actually solves in a real code base. So,

00:08:31,409 --> 00:08:36,040
going back, Dmitry mentioned the developer productivity survey that we run at Stripe,

00:08:36,040 --> 00:08:42,190
and there were three repeated complaints or concerns that people raised over multiple

00:08:42,190 --> 00:08:52,010
iterations. It took too long to grasp unfamiliar code, it took too long to get feedback. And

00:08:52,010 --> 00:08:59,279
then, you know, having changed it and gotten the initial feedback, it was still too easy

00:08:59,279 --> 00:09:04,420
to accidentally break things. Well‑meaning developers, people get paged, and that's something

00:09:04,420 --> 00:09:10,120
that we try to minimize so that we can make them more productive, focusing on actual product,

00:09:10,120 --> 00:09:15,269
not fixing broken product.  So, as an example, diving into that first

00:09:15,269 --> 00:09:20,050
point of what I mean by it took too long to grasp unfamiliar code, I pulled this snippet

00:09:20,050 --> 00:09:28,519
from Stripe's codebase. I shortened some variable names. Consider that we're trying

00:09:28,519 --> 00:09:34,220
to debug something. Maybe we saw a reference to something in a stack trace and we're like

00:09:34,220 --> 00:09:38,889
why is there a problem here? So it's our task to understand it. But we have no tools

00:09:38,889 --> 00:09:45,209
to figure out what's going on. The first question is that merchant argument, is that

00:09:45,209 --> 00:09:50,890
a string ID of a merchant's unique ID? Or is that an actual object that is some model

00:09:50,890 --> 00:09:57,020
instance? And we can't actually tell, because it's just being passed on to two other functions.

00:09:57,020 --> 00:10:01,520
We're not interacting with it, so it could be one of either. If we wanted to change

00:10:01,520 --> 00:10:05,421
this code and we wanted to access some property on a merchant, we don't know whether we first

00:10:05,421 --> 00:10:09,730
have to load the thing from the database or whether we already have it from the database

00:10:09,730 --> 00:10:13,920
and we can just access its fields directly.  Another question that we might want to ask

00:10:13,920 --> 00:10:19,880
here is okay, we can see that the result of this similarity fetch call is returning data,

00:10:19,880 --> 00:10:23,680
but the previous programmer thought that it might be null. Is it actually going to be

00:10:23,680 --> 00:10:29,130
null? What does it mean for the result to be null? We're coding defensively and sticking

00:10:29,130 --> 00:10:37,920
an or= an empty array, but is that something we should handle completely different? We

00:10:37,920 --> 00:10:41,500
have no knowledge into what this code should be doing. 

00:10:41,500 --> 00:10:47,500
We have taken a simple example. Maybe it's kind of trivial, but it happens all the time,

00:10:47,500 --> 00:10:51,490
especially when you're working with an engineering organization the size of Stripes where you

00:10:51,490 --> 00:11:00,769
have so many changes a day. The chance is inevitable. Every day you're looking at code

00:11:00,769 --> 00:11:05,990
that is unfamiliar.  So that second point that came up in the survey

00:11:05,990 --> 00:11:12,000
was it took too long to get feedback. Here are some numbers. If Stripe very, very strongly

00:11:12,000 --> 00:11:16,589
believes in test‑driven development, so we write tons and tons of tests because Stripe

00:11:16,589 --> 00:11:20,030
is involved with actually moving people's money around, so we want to make sure we're

00:11:20,030 --> 00:11:24,130
doing that correctly. Over the years we have written so many tests that if you tried to

00:11:24,130 --> 00:11:29,579
run every test that Stripe has on a single laptop end‑to‑end, it would take days

00:11:29,579 --> 00:11:37,199
of wall clock time. So, of course we have done a lot of work to make these tests run

00:11:37,199 --> 00:11:43,720
in parallel with really powerful CI so you can get results really fast. So, those tests,

00:11:43,720 --> 00:11:48,350
you know, take anywhere from 10 to 20 minutes and recently we have done really impressive

00:11:48,350 --> 00:11:55,140
minutes to get it down to 8 or 6 or 5 minutes, but that's still 5 minutes where you're just

00:11:55,140 --> 00:11:59,960
waiting to see if the changes you made is the right change. And we really want to measure

00:11:59,960 --> 00:12:05,230
ourselves based on how fast people can actually change the code. People can type a single

00:12:05,230 --> 00:12:11,970
key inside their editor and see it render on the screen in milliseconds. So, we aspire

00:12:11,970 --> 00:12:17,310
to give them feedback that quickly. So, that's kind of what we're trying to get to in terms

00:12:17,310 --> 00:12:22,710
of too long to get feedback about the code.  And the third is it's too easy to accidentally

00:12:22,710 --> 00:12:27,780
break things. So, going back to the snippet from before, let's say we identified, okay. It

00:12:27,780 --> 00:12:32,570
actually is a string but I need it to be a merchant. So, let's change it. What are

00:12:32,570 --> 00:12:38,730
the places that I need to update? Maybe this method, it has a particularly unique name

00:12:38,730 --> 00:12:44,829
like find card similarity probably doesn't show up in a lot of places, but that's not

00:12:44,829 --> 00:12:50,930
always the case. Sometimes these methods, you can't descrip for them. Maybe you can

00:12:50,930 --> 00:12:56,420
run the tests and see what tests fail, but that doesn't catch everything. Is it enough

00:12:56,420 --> 00:13:01,930
if the tests pass? Is it enough if you make the change and then deploy the code and see

00:13:01,930 --> 00:13:08,730
that production says that there is no errors? At what point can we be confident that the change

00:13:08,730 --> 00:13:15,040
we did make was safe? Those are the kind of problems that we're trying to use Sorbet

00:13:15,040 --> 00:13:21,769
to solve. So, at this point we built Sorbet, every Stripe engineer is using it. Looking

00:13:21,769 --> 00:13:27,149
back on the year or two years of using Sorbet at Stripe, has it fixed these things? Rather

00:13:27,149 --> 00:13:32,090
than answering that question directly, I would rather go to a demo. You can almost follow

00:13:32,090 --> 00:13:37,130
along. You won't have the starter code that I have, but we have built an online sandbox

00:13:37,130 --> 00:13:44,330
for Sorbet called sorbet.run, and anybody can go there on your browser and mess around

00:13:44,330 --> 00:13:50,910
with it. Because it's running in a browser, I can embed it in an iframe, so I can mess

00:13:50,910 --> 00:13:58,790
around with it right here.  The first question that we were thinking about

00:13:58,790 --> 00:14:03,750
is it took too long to grasp unfamiliar code. We were not sure what this function was doing. All

00:14:03,750 --> 00:14:09,810
we have to do with sorbet is point and click ‑‑ not even click, just point. 

00:14:09,810 --> 00:14:13,879
>> DMITRY: You should be pointing on the other screen. 

00:14:13,879 --> 00:14:21,820
>> JAKE: You're right. Thank you, Dmitry. Hover. Cool! So the first thing that you can do is you can

00:14:21,820 --> 00:14:26,779
hover over the name of a method and immediately see the type for this method. You can see

00:14:26,779 --> 00:14:31,769
also the documentation for this method. You can see, like, the question we were trying

00:14:31,769 --> 00:14:36,110
to figure out before was merchant a string or was it an object? We can see directly

00:14:36,110 --> 00:14:40,930
there, it's a string. If there wasn't, you know ‑‑ sometimes there's documentation

00:14:40,930 --> 00:14:44,589
and sometimes there isn't. If there wasn't documentation and we wanted to check the implementation

00:14:44,589 --> 00:14:50,199
out, we can right click and go to check definition and we jump down to the definition. This

00:14:50,199 --> 00:14:56,800
is a little demo, so I unimplemented it. In Stripe's code base, it is implemented. That

00:14:56,800 --> 00:15:06,329
is immediate. That feedback is point and click and people can figure out this code

00:15:06,329 --> 00:15:10,149
that's unfamiliar to them and get grounded in the reality and move on and think about

00:15:10,149 --> 00:15:16,600
the problem they were actually trying to solve.  Oops. My cursor is over here. The next question

00:15:16,600 --> 00:15:23,910
we had was having changed the code, what is the fastest feedback that we can give people

00:15:23,910 --> 00:15:27,860
as to whether they have done it correctly or not. So, I'm going to go over here and

00:15:27,860 --> 00:15:31,959
introduce an error for the sake of making an error. The red squiggles update as soon

00:15:31,959 --> 00:15:37,370
as I type something, so Sorbet can point directly to the parts of your program that are wrong

00:15:37,370 --> 00:15:44,699
as you're typing it. You don't have to wait for the test run to see that you typo'd the

00:15:44,699 --> 00:15:50,860
name. And again, as you type things, not only can Sorbet tell you what's wrong, but

00:15:50,860 --> 00:15:55,731
it can suggest to you how to fix it. Here I type the name of this method, and Sorbet

00:15:55,731 --> 00:16:01,779
immediately pops up a completion item that says maybe you meant this, and not only will

00:16:01,779 --> 00:16:07,360
it say ‑‑ it's kind of small. But it's suggesting the fetch method that's on this

00:16:07,360 --> 00:16:14,859
object. Not only is it suggesting the name of the method, if I ask for the documentation,

00:16:14,859 --> 00:16:21,899
it will show it to me. It tells me the type of this method and what the documentation

00:16:21,899 --> 00:16:27,579
is for it. If we press tab, it will let us fill in the blanks for all the information

00:16:27,579 --> 00:16:31,629
that it needs. So, we can go over here for merchant and it will suggest merchant and

00:16:31,629 --> 00:16:37,990
so on and so forth. This demo, again, running on an iframe in a reveal js presentation. But

00:16:37,990 --> 00:16:47,750
that's how fast it is in Stripe's multi‑million line Ruby codebase, partly due to interesting

00:16:47,750 --> 00:16:52,800
architectural decisions. Sorbet can see that it's only editing inside of a method so it

00:16:52,800 --> 00:16:59,279
only needs to analyze that method. We have done interesting things to be able to give

00:16:59,279 --> 00:17:03,310
this feedback to developers as quickly as we can. 

00:17:03,310 --> 00:17:09,589
The last thing is we want to make it harder ‑‑ not impossible, but hard tore accidentally

00:17:09,589 --> 00:17:14,230
break the code. So, the way that Sorbet does this is by giving people one more tool to

00:17:14,230 --> 00:17:20,120
analyze their correctness. So, having grappled with unfamiliar code as a developer, now we

00:17:20,120 --> 00:17:24,750
want to go in and leave our understanding behind for future engineers so when they come

00:17:24,750 --> 00:17:30,600
in next time, they won't have to know whether this thing is a merchant ID or a merchant

00:17:30,600 --> 00:17:34,590
object. They can just see it. So, the easiest way to do that is by leaving behind a type

00:17:34,590 --> 00:17:40,610
annotation for this method. We can write a type annotation by typing sig, which is

00:17:40,610 --> 00:17:48,320
like method signature. So, if we start typing that inside this editor, not only will Sorbet

00:17:48,320 --> 00:17:54,880
show us that sig is a method we could call but it will also show us a suggested sig. Just

00:17:54,880 --> 00:18:01,190
by typing out the start of a type annotation, Sorbet says it looks like you can add this,

00:18:01,190 --> 00:18:07,210
and it's right in this case. The parameters that says it's a method that will take a merchant,

00:18:07,210 --> 00:18:13,240
which is a string and it returns a similarly record object. And all we have to do is press

00:18:13,240 --> 00:18:20,581
tab and that signature pops into the code. That gives us a great starting point if we want

00:18:20,581 --> 00:18:25,830
to change the code. Now Sorbet will update its knowledge of the world and say it must

00:18:25,830 --> 00:18:31,180
be the case that this signature is true. If we wanted to change it, maybe the change we

00:18:31,180 --> 00:18:37,490
wanted to make was to change this from a string to a merchant object, as soon as we finish

00:18:37,490 --> 00:18:41,600
typing that signature, Sorbet then updated its knowledge and said okay, it must be the

00:18:41,600 --> 00:18:47,380
case that this is a merchant object. If you were ever using, you know, this local variable

00:18:47,380 --> 00:18:50,890
in a way that was incompatible with that, it will show you all the errors. I can't

00:18:50,890 --> 00:18:55,789
show you, because it's in the browser. But in VSCode, there would be a separate tab where

00:18:55,789 --> 00:19:05,511
it would list the errors and you could jump to dev and fix the error. Expected string

00:19:05,511 --> 00:19:13,690
found merchant object. Now we can go through, and again, this is one more way to be, you

00:19:13,690 --> 00:19:17,020
know, a little bit more confident that the change that you have made doesn't silently

00:19:17,020 --> 00:19:21,631
break something. Tests help, deploying the code helps, and also, type checking the code

00:19:21,631 --> 00:19:29,789
helps, so that's kind of one more way.  So let's click out of here. Those are the

00:19:29,789 --> 00:19:35,950
three benefits that we talked about where the types make the code easier to grasp. Sorbet

00:19:35,950 --> 00:19:42,059
is as fast as you can type. So, you get feedback much more quickly than other alternative methods

00:19:42,059 --> 00:19:46,630
and Sorbet ends up being one more tool to help developers and analyze whether the thing

00:19:46,630 --> 00:19:49,380
that they have written is actually the thing that they wanted. 

00:19:49,380 --> 00:19:55,130
Cool. So, that's the demo of the problems that Sorbet was trying to address and whether

00:19:55,130 --> 00:20:00,039
or not it solved them. Now I will hand it back to Dmitry to talk about the community

00:20:00,039 --> 00:20:08,000
since we have open sourced Sorbet.  >> DMITRY: It has been slightly less than

00:20:08,000 --> 00:20:17,179
a year since we open sourced Sorbet. We had an ongoing discussion with Ruby core team

00:20:17,179 --> 00:20:23,549
about what should be happening with this. As Matz announced at Ruby kaigi2019, Ruby 3 standard

00:20:23,549 --> 00:20:37,690
library will ship with type definitions.  There are 

00:20:37,690 --> 00:20:43,250
active discussions about how do we evolve the Ruby usage of types, how to make it be

00:20:43,250 --> 00:20:49,211
Ruby and get the benefits that type languages normally get. It's been a great collaboration

00:20:49,211 --> 00:20:57,659
and a pleasure. Thank you, Matz. All of the work has been done by the creator of the

00:20:57,659 --> 00:21:04,000
type checker called Steep. He has created the syntax for type signatures that Ruby 3

00:21:04,000 --> 00:21:10,330
will ship with. So, thank you.  Since we have open sourced, we have had in

00:21:10,330 --> 00:21:17,340
the open source, in the new repo, more than 800 pull requests, and a lot of them are coming

00:21:17,340 --> 00:21:24,830
from not Stripe. We have 135 contributors who contributed to it. 10 are on the Sorbet

00:21:24,830 --> 00:21:40,230
team, and 30 are stripe, and 85 are coming from Shopify, Heroku, a great collaboration. Companies

00:21:40,230 --> 00:21:45,400
are helping make it easier for people to adopt Sorbet and making it discover more errors,

00:21:45,400 --> 00:21:50,870
errors that those companies care about. At this moment, we believe that tooling behind

00:21:50,870 --> 00:21:57,000
Sorbet, the tooling that those companies created together can make it easier for you and pretty

00:21:57,000 --> 00:22:04,870
easy to adopt Sorbet. Shopify will talk more about this, about what are the steps that

00:22:04,870 --> 00:22:08,240
they took and how did they benefit from it and what are the problems and what were the

00:22:08,240 --> 00:22:14,010
solutions for them. So, it's the next talk in this slot. So, please follow us. 

00:22:14,010 --> 00:22:23,470
I wanted to specifically also pinpoint a few contributors. Alex snaps has contributed

00:22:23,470 --> 00:22:29,820
with the details about how to make it work correctly and in tricky cases where parser

00:22:29,820 --> 00:22:39,590
for Ruby doesn't do what you expect it to, Sorbet now does it for you. They are substantial

00:22:39,590 --> 00:22:48,450
contributions. Univerio has built a way to automatically add documentation that comes

00:22:48,450 --> 00:23:00,250
from stdlib. Hover was coming from your codebase. But similarly now, the information for hover can

00:23:00,250 --> 00:23:07,630
be coming from stdlib. You will now have documentation on arrays, on hashes, on maps,

00:23:07,630 --> 00:23:21,400
all of those. This is awesome. Thank you.  And we also have gem support. Not every company

00:23:21,400 --> 00:23:31,970
does it. Coinbase doesn't. As an early user of Sorbet, they have ‑‑ since we open‑sourced,

00:23:31,970 --> 00:23:41,640
117 gems have been added additionally to the ones that were added in bulk. A majority

00:23:41,640 --> 00:23:47,120
of the gems that people use now have types now, and those types are Either auto‑generated

00:23:47,120 --> 00:23:56,490
with tools that are part of the repo or part of a similar tool that Shopify will present. We

00:23:56,490 --> 00:24:02,640
have automatic ways to gather type signatures to be shared. And then you can modify them

00:24:02,640 --> 00:24:06,820
and make them more precise to specify specific types. 

00:24:06,820 --> 00:24:11,760
And majority of the contributions are from the community. This is a very active project

00:24:11,760 --> 00:24:16,581
that helps better integrate Sorbet into the gems. If you're a library author, please

00:24:16,581 --> 00:24:19,190
join. If you're a library user, please join. There

00:24:19,190 --> 00:24:34,140
are also entire projects that are extending and building the ecosystem to make it easier

00:24:34,140 --> 00:24:43,610
for you to adopt. The most important one is sorbet‑rails. This is started by CZI. An

00:24:43,610 --> 00:24:47,720
interesting thing about Stripe, Stripe uses Ruby but we don't use Rails. A majority of

00:24:47,720 --> 00:24:55,789
projects do use Rails. So, CZI created an external extension that makes Sorbet play

00:24:55,789 --> 00:25:04,070
really well with Rails. There's another extension called Sword. So, you have a codebase where

00:25:04,070 --> 00:25:10,950
you use to describe a majority of your arguments, you can convert them to sorbet types in order

00:25:10,950 --> 00:25:19,039
for them to be checked. And Parlour is a plug‑in ecosystem for writing plugins so

00:25:19,039 --> 00:25:26,429
you can teach sorbet about the internal coding conventions, internal magic that is adding

00:25:26,429 --> 00:25:31,250
additional benefit to your company, and you would benefit from adding types to it, despite

00:25:31,250 --> 00:25:38,419
it not being used by other people.  And finally, this has been us presenting our

00:25:38,419 --> 00:25:44,140
project as people who are working on it. So, we can make it look fancy. So, we also want

00:25:44,140 --> 00:25:55,059
to add some direct feedback from the users of it. So, here is one. I'll just let you

00:25:55,059 --> 00:26:03,240
read it through.  So a very common thing that happens in a big

00:26:03,240 --> 00:26:06,740
codebase is in order to make a change, in order to feel good about the change, you need

00:26:06,740 --> 00:26:09,931
to refactor some code around it and as you are refactoring the code, you need to make

00:26:09,931 --> 00:26:19,649
sure you don't break stuff. And iteration can be painful, and can make it so that you

00:26:19,649 --> 00:26:23,909
don't end up and you don't want to change things. And thus you end up piling hacks

00:26:23,909 --> 00:26:29,460
and hacks. So, here the person is saying that sorbet is making it easier for them to

00:26:29,460 --> 00:26:36,700
have faster iteration loop and thus to do the refactorings. 

00:26:36,700 --> 00:26:45,350
Here, similarly. Stripe has a bunch of smaller code bases that do not have sorbet. And it's

00:26:45,350 --> 00:26:50,580
very hard for people to compare their experience pre‑sorbet and after, because we're gradually

00:26:50,580 --> 00:26:56,830
rolling it out. If you ever go to the other code bases that do not have the benefits,

00:26:56,830 --> 00:27:02,370
people see a striking difference between the two. We actually saw one of them start adopting

00:27:02,370 --> 00:27:08,049
it in smaller projects simply because they're used to it and they enjoy the benefits. 

00:27:08,049 --> 00:27:18,559
So yep. Even smaller projects than Stripe are getting types. And then, yep. 

00:27:18,559 --> 00:27:30,470
>> JAKE: This was the e‑mail that we sent out the first day that we released go to definition. It's

00:27:30,470 --> 00:27:34,590
completely changed the way many people write Ruby code because they don't wait for figuring

00:27:34,590 --> 00:27:39,019
out where something is defined. They just click and click and click and suddenly they

00:27:39,019 --> 00:27:44,670
understand the code.  >> DMITRY: Yes. This changes the iteration

00:27:44,670 --> 00:27:51,279
speed. This changes. It empowers engineers to be more productive, to be more brave, to

00:27:51,279 --> 00:27:57,309
do more experimentation. They feel that they have better ways to check that they are still

00:27:57,309 --> 00:28:04,460
safe. This allows them to build more features, to change existing features, and do this in

00:28:04,460 --> 00:28:11,019
the code base that they now like. They like the abstractions that they introduce. They

00:28:11,019 --> 00:28:15,809
like that they can change them or eliminate the abstractions they no longer like. What's

00:28:15,809 --> 00:28:27,800
next? The major push is investing into the editorials. We're investing in auto‑complete

00:28:27,800 --> 00:28:35,710
and finding references. We're moving to things which rather than asking questions about your

00:28:35,710 --> 00:28:40,990
codebase, we'll be changing it like refactorings. Doing refactorings automatically like renaming

00:28:40,990 --> 00:28:47,480
a class or a method or reordering local variables. Maybe promoting a positional argument to a

00:28:47,480 --> 00:28:54,120
keyword argument or back. This is the majority of our investment. The second one is we want

00:28:54,120 --> 00:29:01,210
to make it even faster. Sorbet ‑‑ Stripe codebase is growing. And we want our users

00:29:01,210 --> 00:29:07,880
to continue having fast iteration cycle. From our experience, a majority of the code bases

00:29:07,880 --> 00:29:15,080
similar to Stripe grow exponentially over time, which means we need to continue to make

00:29:15,080 --> 00:29:23,789
sorbet faster.  And finally, we're hearing feedback from internal

00:29:23,789 --> 00:29:31,450
and external users, which one do we hear most commonly? Which ones will be the most useful

00:29:31,450 --> 00:29:41,590
for our users to invest?? We now have interfaces. You can specify that a module describes a set

00:29:41,590 --> 00:29:46,670
of functions and you're required to always override them to implement them. You can

00:29:46,670 --> 00:29:52,909
have final methods and final classes and exhaustiveness checks and sealed classes. A lot of the features

00:29:52,909 --> 00:30:00,539
that you would normally provide you guarantees are now possible and are being asked for by

00:30:00,539 --> 00:30:11,200
users and we're prioritizing them by demand. There is going to be an awesome talk about how to

00:30:11,200 --> 00:30:19,570
adopt sorbet presented by Shopify. If you stay in this room, you will see it. They

00:30:19,570 --> 00:30:25,519
will describe what problems did sorbet solve at Shopify. They will describe what was the

00:30:25,519 --> 00:30:29,419
progress around solving them and what were the problems that they ran into and how did

00:30:29,419 --> 00:30:33,730
they solve them so you can learn from their experiences. 

00:30:33,730 --> 00:30:39,090
Thank you for following our talks. We would love you to share your questions and feedback. If

00:30:39,090 --> 00:30:43,280
you haven't tried sorbet, try it. If you have, please let us know how did it go. We

00:30:43,280 --> 00:30:49,720
would love to make it better. Thank you for coming. As always, we are hiring. We'll

00:30:49,720 --> 00:30:53,610
be around. Thank you.  >> JAKE: Also, I have stickers. 

00:30:53,610 --> 00:30:57,390
[ Applause ]

00:30:57,390 --> 00:31:04,950
>> [ Inaudible Question ]

00:31:04,950 --> 00:31:12,880
>> DMITRY: So the question was we have this sig. The way you annotate the method with

00:31:12,880 --> 00:31:18,139
a signature and it comes before the method. And the question was how do we implement it. Jake

00:31:18,139 --> 00:31:21,860
do you want to take this one?  >> JAKE: Our syntax has gone through multiple

00:31:21,860 --> 00:31:30,639
iterations of design and redesign. The actual concrete syntax is sig is just a method name. And

00:31:30,639 --> 00:31:35,529
it's kind of hidden. I tricked you for the purpose of this demo, but there's actually

00:31:35,529 --> 00:31:42,440
a module down here at the bottom called tsig. And if you include it, you can monkeypatch every

00:31:42,440 --> 00:31:49,701
module. Alternatively, you can put extend tsig any place you would like to use that

00:31:49,701 --> 00:31:57,750
annotation. We did that for a long time. We required every Stripe developer to have this

00:31:57,750 --> 00:32:01,769
extension in every class that they wanted to use types in, and we realized wait a second,

00:32:01,769 --> 00:32:07,071
80%of our classes have this in there and it's just noise so let's just get it and put it

00:32:07,071 --> 00:32:11,700
everywhere.  >> DMITRY: It runs in standard Ruby. It doesn't

00:32:11,700 --> 00:32:17,019
require any custom modifications. You just mix in what you mix in and now you have type

00:32:17,019 --> 00:32:18,483
signatures. Thank you for a great question.  >> [ Inaudible Question ]

00:32:18,483 --> 00:32:34,960
>> DMITRY: So the question is what do we use for VS code? Microsoft is popularizing it. It

00:32:34,960 --> 00:32:41,039
works in other editors. We know it works in VI. We know that people have integrated it

00:32:41,039 --> 00:32:47,899
in emacs. This is just language integration. And yep, it works. Thank you for a great question. Yes,

00:32:47,899 --> 00:32:48,899
please.  >> [ Off mic ].

00:32:48,899 --> 00:32:54,340
>> DMITRY: So the question is if you are already using Ruby mine what are the benefits of using

00:32:54,340 --> 00:33:02,910
this? Ruby mine tries to understand your code base as written and to provide you some

00:33:02,910 --> 00:33:08,940
information, but it cannot do as much. It does not have the types. It tries to get

00:33:08,940 --> 00:33:13,169
something, sometimes opportunistically. The difference here is when you're describing

00:33:13,169 --> 00:33:18,019
the sig, you're describing the intent. You're describing not what this method happens to

00:33:18,019 --> 00:33:22,559
do now, but what I want it to do. You're describing that I want it to actually do this

00:33:22,559 --> 00:33:31,059
rather than anything else. So, it provides guarantees. If you're using IDE, like you

00:33:31,059 --> 00:33:39,430
can still have auto complete to some degree. Much lesser case and frequently will be slower. But

00:33:39,430 --> 00:33:43,730
if you have a small code base, at the same time, the question is how much of this can

00:33:43,730 --> 00:33:49,799
you trust? With sorbet, all of the signatures are 100%trust worthy. They are checked in

00:33:49,799 --> 00:33:54,250
production at Stripe. They are checked in tests at Stripe. They're fast enough for

00:33:54,250 --> 00:33:58,910
us to be able to run in production so they provide guarantees rather than hope. Hope

00:33:58,910 --> 00:34:03,169
is not a strategy. Thank you for a great question. Yes, please. 

00:34:03,169 --> 00:34:04,169
>> [ Inaudible Question ]

00:34:04,169 --> 00:34:07,529
>> >> JAKE: I don't remember if Matz covered

00:34:07,529 --> 00:34:17,390
it here, but in April or May, he basically talked about these three tiers of type checkers. So,

00:34:17,390 --> 00:34:22,110
there's the Ruby core tier, and then there are things that are built right on top of

00:34:22,110 --> 00:34:29,200
core, and then the third tier of third‑party checkers. What they plan to ship for Ruby

00:34:29,200 --> 00:34:34,240
3 release is type signatures for the Ruby stdlib. When those are available, we will

00:34:34,240 --> 00:35:00,810
flip a switch. On top of that, Yusuke will be giving a talk in this room after Shopify. He's

00:35:00,810 --> 00:35:05,180
going to talk about his progress about trying to come up with types for untyped programs. And

00:35:05,180 --> 00:35:13,250
the third one, which is third‑party checkers like sorbet and RDL are these kind of like

00:35:13,250 --> 00:35:18,290
things that will, you know, in their own way, analyze the type signatures. So, there will

00:35:18,290 --> 00:35:23,170
always be a place for sorbet. It's just that we will be using either our own source of

00:35:23,170 --> 00:35:28,350
truth for the stdlib or the Ruby source of truth, and sorbet will work the same way.

00:35:28,350 --> 00:35:30,630
>> DMITRY: Thank you for a great question.  >> [ Inaudible Question ]

00:35:30,630 --> 00:35:31,630
>> DMITRY: Could you repeat again?  >> [ Inaudible Question ]

00:35:31,630 --> 00:35:36,190
>> DMITRY: So the question was can you support polymorphic interfaces, I guess? So if you

00:35:36,190 --> 00:35:41,340
specify a type and rather than taking a merchant, you want to take something. So, we have union

00:35:41,340 --> 00:35:47,400
types. So Jake is showing ‑‑ I'm intending to take either a string or a merchant and

00:35:47,400 --> 00:35:53,940
we will check it correctly. And also you can use mix‑ins as interfaces in your types. We

00:35:53,940 --> 00:35:58,270
not only have classes in the type system, but also modules. Combining the two is the

00:35:58,270 --> 00:36:02,060
most common way we see people model the question that you're asking. 

00:36:02,060 --> 00:36:03,839
>> [ Inaudible Question ]

00:36:03,839 --> 00:36:15,200
>> JAKE: That's a nice question to pass off. I think that the key design principle is the

00:36:15,200 --> 00:36:20,370
same design principle that makes it easy to adopt. Everything starts out in a codebase

00:36:20,370 --> 00:36:25,890
without types so everything is untyped. And then over time you add type annotations to

00:36:25,890 --> 00:36:32,580
it, so they are added one by one. If there is a place where you realize, like, there

00:36:32,580 --> 00:36:37,150
is nothing currently in sorbet's type system that will let me 100%accurately annotate this

00:36:37,150 --> 00:36:43,620
type, which does happen. Sometimes there is something that is doing really wonky things. Either

00:36:43,620 --> 00:36:48,031
the first parameter is this or the first parameter is this and the second is this and the types

00:36:48,031 --> 00:36:54,350
change all over the place. Sometimes you have to say okay, I can't type this and leave it

00:36:54,350 --> 00:36:59,910
at that. The thing that we have seen at Stripe and the thing that Shopify will touch on is

00:36:59,910 --> 00:37:06,491
you don't actually need to type literally everything to get tons of benefit. You can

00:37:06,491 --> 00:37:11,600
be okay typing the most common and important things and having those things checked. If

00:37:11,600 --> 00:37:15,900
there is a conflict, they're rare enough that you can say I'm just not going to worry about

00:37:15,900 --> 00:37:18,380
this.  >> DMITRY: Thank you for a great question. Question

00:37:18,380 --> 00:37:20,320
in the back?  >> [ Inaudible Question ]

00:37:20,320 --> 00:37:25,030
>> DMITRY: One downside that I saw from this is some people get super excited and they

00:37:25,030 --> 00:37:28,970
end up mostly writing the types rather than the programs.

00:37:28,970 --> 00:37:35,600
[ Laughter ] We internally don't encourage this, and we

00:37:35,600 --> 00:37:41,440
discourage it. Types are there to help you. Types are not there to prove that you are smart. Types

00:37:41,440 --> 00:37:46,050
are not there to introduce complexity. Types are there to make it easier for other engineers. If

00:37:46,050 --> 00:37:50,760
you're writing a complex type that makes it harder for other engineers, that's not what

00:37:50,760 --> 00:37:55,120
they are there for.  >> JAKE: Another thing that I have seen that

00:37:55,120 --> 00:38:01,081
gets people into a little bit of a trap is they trust Sorbet maybe too much. As you

00:38:01,081 --> 00:38:06,370
are incrementally adopting sorbet in a code base, it will never be at 100%coverage. If

00:38:06,370 --> 00:38:11,540
you assume that the only thing you need to ensure correctness is the type check, you

00:38:11,540 --> 00:38:15,960
might get bit. You might be dealing with a gem that doesn't have type annotations yet

00:38:15,960 --> 00:38:20,610
or an older part of your code base that doesn't have type annotations. If you assume the

00:38:20,610 --> 00:38:29,360
only thing you need is types and not rely on tests as strongly or on careful monitoring

00:38:29,360 --> 00:38:33,700
as strongly, sorbet is one more tool, not a replacement for existing tools. 

00:38:33,700 --> 00:38:34,700
>> DMITRY: Yes, please.  >> [ Inaudible Question ]

00:38:34,700 --> 00:38:39,550
>> DMITRY: The question was so far we're using nominal types. Do we see a future where we

00:38:39,550 --> 00:38:44,360
will do structural types. As this has been progressing, this is one of the questions

00:38:44,360 --> 00:38:52,170
we are looking to answer. A lot of research that happened before us, most notably by Jeff

00:38:52,170 --> 00:39:02,070
Foster shows that structural types, the error messages are by people. If you expect to

00:39:02,070 --> 00:39:08,070
have an integer and you got a float, the structural types will describe this as here is 55 methods

00:39:08,070 --> 00:39:16,720
on integer, but I expected 55 methods on floats and they look similar. Why are you complaining

00:39:16,720 --> 00:39:22,050
at me? They seem the same.  So, we chose nominal type system because of

00:39:22,050 --> 00:39:29,060
the user experience, because by having classes, having modules, you are building a shared

00:39:29,060 --> 00:39:34,840
language between you and the type checker. The question was can we type check Ruby code in

00:39:34,840 --> 00:39:42,270
this world? Yes. There are rare cases where somebody is asking for those. But most commonly

00:39:42,270 --> 00:39:47,540
we have seen this create more problems than solve it. If you are doing this, you also

00:39:47,540 --> 00:39:56,460
most likely have a method that has a short name. So, from our experience, we believe

00:39:56,460 --> 00:40:02,140
that it would be, at this point, potentially harmful to add it. It's additional work. It

00:40:02,140 --> 00:40:08,580
makes it easier to adopt in some cases, but at this point our suggestion is use untyped. This

00:40:08,580 --> 00:40:18,420
seems to be doing wonky things. So, our suggestion is just go with untyped. Thank you for a

00:40:18,420 --> 00:40:23,740
great question.  >> JAKE: I think we are at time, but I have

00:40:23,740 --> 00:40:28,090
nothing else to do but talk about types. So, if you have any other questions for me or

00:40:28,090 --> 00:40:31,740
Dmitry, we will be around pretty much the rest of today and all of tomorrow. 

00:40:31,740 --> 00:40:33,900

YouTube URL: https://www.youtube.com/watch?v=jielBIZ40mw


