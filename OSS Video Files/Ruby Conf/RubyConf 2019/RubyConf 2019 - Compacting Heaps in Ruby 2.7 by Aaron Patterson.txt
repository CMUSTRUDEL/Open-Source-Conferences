Title: RubyConf 2019 - Compacting Heaps in Ruby 2.7 by Aaron Patterson
Publication date: 2019-11-29
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Compacting Heaps in Ruby 2.7 by Aaron Patterson

Ruby 2.7 will feature a manual heap compactor integrated with the GC. In this presentation we'll cover how Ruby's memory is arranged, how compaction can be helpful to your application, as well as algorithms and implementation details of the heap compactor. As a bonus, we'll cover GC debugging techniques as well! This presentation is going to be heaps of fun. Don't turn the page because we're going to scan the stack for some great pointers!

#confreaks #rubyconf2019
Captions: 
	00:00:00,120 --> 00:00:02,300
>> Hello.

00:00:02,300 --> 00:00:04,480
Hello.

00:00:04,480 --> 00:00:06,660
Okay.

00:00:06,660 --> 00:00:17,580
I guess let's do this.

00:00:17,580 --> 00:00:20,190
Unfortunately, my oh.

00:00:20,190 --> 00:00:21,190
Okay.

00:00:21,190 --> 00:00:22,190
I got to shut off the Wi Fi here.

00:00:22,190 --> 00:00:23,190
Um, hello.

00:00:23,190 --> 00:00:24,190
Oh geez.

00:00:24,190 --> 00:00:25,190
Am I up here?

00:00:25,190 --> 00:00:26,190
Okay.

00:00:26,190 --> 00:00:27,190
Hello, everybody!

00:00:27,190 --> 00:00:28,190
Hello!

00:00:28,190 --> 00:00:29,190
I'm really, really excited to be here today.

00:00:29,190 --> 00:00:35,710
I'm so excited to give a 40 minute long ignite style presentation.

00:00:35,710 --> 00:00:41,790
Which was the slide I was going to put in here, but my tethering is too slow, so I'm

00:00:41,790 --> 00:00:46,030
just telling you the joke instead of putting it in slide form.

00:00:46,030 --> 00:00:48,730
Imagine that there is an ignite slide here.

00:00:48,730 --> 00:00:49,880
Okay.

00:00:49,880 --> 00:00:58,180
So, I'm wearing this hamburger hat today because I heard I needed to dress up, wear my formal

00:00:58,180 --> 00:01:00,640
attire.

00:01:00,640 --> 00:01:03,780
But I'm gonna take this off now, because I feel it's probably bad for the recording.

00:01:03,780 --> 00:01:06,110
I don't want my face to get all dark.

00:01:06,110 --> 00:01:08,050
Hello everybody.

00:01:08,050 --> 00:01:10,530
Hamburger hat!

00:01:10,530 --> 00:01:14,740
So we're going be talking about compacting GC for MRI.

00:01:14,740 --> 00:01:16,270
Hello.

00:01:16,270 --> 00:01:17,810
Hello!

00:01:17,810 --> 00:01:20,870
I apologize.

00:01:20,870 --> 00:01:23,720
I know this is the third day.

00:01:23,720 --> 00:01:27,830
We're nearing the end of the third day and you have come to an extremely technical presentation.

00:01:27,830 --> 00:01:29,450
So, my apologies.

00:01:29,450 --> 00:01:31,170
My name is Aaron Paterson.

00:01:31,170 --> 00:01:34,130
My given name is @tenderlove.

00:01:34,130 --> 00:01:39,480
I changed my name to Aaron.

00:01:39,480 --> 00:01:41,130
You can call me either one of those.

00:01:41,130 --> 00:01:44,970
This is what I look like on the internet.

00:01:44,970 --> 00:01:47,130
I have two cats.

00:01:47,130 --> 00:01:50,540
This one's name is Gorbachev Puff Puff Thunder Horse.

00:01:50,540 --> 00:01:53,470
He is the most famous of my cats.

00:01:53,470 --> 00:01:54,470
I have stickers of him.

00:01:54,470 --> 00:01:58,400
If you would like a sticker.

00:01:58,400 --> 00:02:11,099
This is Sea Tac Facebook >> CAPTIONER: Don't wait for me...

00:02:11,099 --> 00:02:20,949
I got Gorbachev!

00:02:20,949 --> 00:02:24,930
>> I am extremely nervous in front of you all today.

00:02:24,930 --> 00:02:36,549
But actually, I stayed at a Holiday Inn Express.

00:02:36,549 --> 00:02:38,840
Here is me.

00:02:38,840 --> 00:02:41,909
I'm on the Rails core team.

00:02:41,909 --> 00:02:47,650
We're the team responsible for developing Rails, and I looked up my commits, and my

00:02:47,650 --> 00:02:53,189
first commit was here in 2009, so I have been a commiter my first commit was about ten years

00:02:53,189 --> 00:02:57,799
ago, but I have been on the core team since 2011.

00:02:57,799 --> 00:03:02,330
I'm also on the Ruby core team which is responsible for developing Ruby.

00:03:02,330 --> 00:03:07,459
And my very first commit to Ruby core was ten years ago in October.

00:03:07,459 --> 00:03:10,870
This is my ten year anniversary on the Ruby core team.

00:03:10,870 --> 00:03:14,549
[ Applause ] Thank you!

00:03:14,549 --> 00:03:18,420
Now, this is not to say that I know what I am talking about.

00:03:18,420 --> 00:03:20,379
That is absolutely not true.

00:03:20,379 --> 00:03:26,550
I need you to take your expectations for this presentation and lower them a bit for me.

00:03:26,550 --> 00:03:30,099
And when they're down here, bring them down just a bit more.

00:03:30,099 --> 00:03:32,980
I'd really appreciate that.

00:03:32,980 --> 00:03:39,219
The way that I got on to the Ruby core team is I was able to crash Ruby a whole lot, and

00:03:39,219 --> 00:03:46,480
I got a lot of seg faults and those produced core files, and they were Ruby core files.

00:03:46,480 --> 00:03:48,860
Ahhhh!

00:03:48,860 --> 00:03:52,140
All of you may actually already be on the Ruby core team.

00:03:52,140 --> 00:03:58,459
What you should do is go check and do ls /cores and you may also have many Ruby core files

00:03:58,459 --> 00:04:00,200
as well.

00:04:00,200 --> 00:04:06,599
So, today I'm going to be talking about compacting GC for MRI, but first I want to talk about

00:04:06,599 --> 00:04:10,319
controversial features in Ruby 2.7.

00:04:10,319 --> 00:04:14,860
Matz talked a little about these in his presentation and I want to talk about them too.

00:04:14,860 --> 00:04:17,280
The first one is the pipeline operator.

00:04:17,280 --> 00:04:21,579
It got deleted, but I want to talk about it anyway.

00:04:21,579 --> 00:04:24,250
It looks like this.

00:04:24,250 --> 00:04:27,530
And I know that there was a lot of controversy around this.

00:04:27,530 --> 00:04:32,199
People did not like this operator implemented in this way.

00:04:32,199 --> 00:04:37,419
But I thought to myself that Ruby is designed for developer happiness, as Matz says.

00:04:37,419 --> 00:04:44,090
I would change it to a smile operator.

00:04:44,090 --> 00:04:47,560
You can see the pull request.

00:04:47,560 --> 00:04:48,560
It's up there.

00:04:48,560 --> 00:04:53,530
Unfortunately, it got rejected and I think it's because I guess it's because the pipeline

00:04:53,530 --> 00:04:54,960
operator was canceled.

00:04:54,960 --> 00:04:56,260
So, that's unfortunate.

00:04:56,260 --> 00:05:00,870
We could have had emojis in there, but we do not.

00:05:00,870 --> 00:05:04,980
The next thing I want to talk about is Typed Ruby.

00:05:04,980 --> 00:05:08,370
How many of you are excited about getting types into Ruby?

00:05:08,370 --> 00:05:09,370
Yeah!

00:05:09,370 --> 00:05:10,370
All right.

00:05:10,370 --> 00:05:11,370
That's great.

00:05:11,370 --> 00:05:12,370
That's great.

00:05:12,370 --> 00:05:20,849
But the thing I don't understand about it is I thought we already typed Ruby...

00:05:20,849 --> 00:05:27,440
I know some of you may copy and paste from stack overflow, but we typically type things

00:05:27,440 --> 00:05:29,380
so...

00:05:29,380 --> 00:05:34,960
Let's talk about let's actually get down to what we're supposed to be talking about today,

00:05:34,960 --> 00:05:39,100
which is manual heap compaction for MRI.

00:05:39,100 --> 00:05:44,020
This is a patch that I wrote for Ruby, and it's in Ruby now.

00:05:44,020 --> 00:05:49,380
It took me about three years to complete this work.

00:05:49,380 --> 00:05:55,280
And I have to admit, this is the most difficult project I have ever worked on in my life.

00:05:55,280 --> 00:05:58,270
This is the most difficult thing I've ever written in my life.

00:05:58,270 --> 00:06:01,189
And I usually don't say that I have any new ideas.

00:06:01,189 --> 00:06:05,389
I'll give presentations and I'll say I don't think of anything new, but I think I finally

00:06:05,389 --> 00:06:08,599
had a new idea, and that's this one.

00:06:08,599 --> 00:06:13,139
I will show you how I know this.

00:06:13,139 --> 00:06:16,900
Actually, Chris Seaton tweeted this.

00:06:16,900 --> 00:06:20,780
He is on the truffle team.

00:06:20,780 --> 00:06:28,479
He said that I had a novel solution for not moving objects referenced from C. Now Chris

00:06:28,479 --> 00:06:33,730
is he comes from an academic background, so I want to translate this slide a little bit

00:06:33,730 --> 00:06:35,740
or this tweet a little bit for you.

00:06:35,740 --> 00:06:42,840
So, when Chris says novel solution, what that actually means is that I am a genius.

00:06:42,840 --> 00:06:47,220
[ Laughter ] So thank you so much.

00:06:47,220 --> 00:06:53,020
So, I want to, before we get into the meat of this, I do want to say a quick couple of

00:06:53,020 --> 00:06:54,530
thank yous.

00:06:54,530 --> 00:06:58,080
I want to call out a couple of people specifically to thank.

00:06:58,080 --> 00:07:04,580
That is Koichi Sasada and Allison McMillan.

00:07:04,580 --> 00:07:05,750
I'll tell you why.

00:07:05,750 --> 00:07:10,710
When I first came up with this project, for many years I kept thinking oh, it's impossible

00:07:10,710 --> 00:07:16,460
to get compaction implemented in MRI and I just thought that was a thing that couldn't

00:07:16,460 --> 00:07:18,150
be done.

00:07:18,150 --> 00:07:25,110
And I explained this to Koichi and he said to me, why not?

00:07:25,110 --> 00:07:26,740
Why is it impossible?

00:07:26,740 --> 00:07:30,590
And I said to him I don't know, just many smart people tell me that and he said maybe

00:07:30,590 --> 00:07:33,090
you should try it and see if it actually is.

00:07:33,090 --> 00:07:34,759
And I was like okay.

00:07:34,759 --> 00:07:37,580
So, then I tried it, and it is possible.

00:07:37,580 --> 00:07:41,490
But unfortunately, it took me a very long time to implement this.

00:07:41,490 --> 00:07:45,789
And it was, as I said, this was the most difficult project I've ever worked on.

00:07:45,789 --> 00:07:49,550
So, I would get stalled and depressed about it.

00:07:49,550 --> 00:07:53,999
And Allison reached out to me and said hey, I would like to work with you on this project.

00:07:53,999 --> 00:07:56,000
So, every week I would pair with her on this.

00:07:56,000 --> 00:08:04,080
And that meant that I don't particularly like pairing with people when it's just me staring

00:08:04,080 --> 00:08:09,539
at some really not great C code.

00:08:09,539 --> 00:08:11,680
Trying to figure out what's going on.

00:08:11,680 --> 00:08:16,650
So, each week I would try to figure out what we were gonna do, plan it, and actually do

00:08:16,650 --> 00:08:17,650
that pairing session.

00:08:17,650 --> 00:08:22,520
So, she helped me move this project along, and it wouldn't be here today without these

00:08:22,520 --> 00:08:23,860
two people.

00:08:23,860 --> 00:08:25,830
So today's topics.

00:08:25,830 --> 00:08:30,819
I am going to talk about Ruby's heap, the compaction algorithm, implementation details,

00:08:30,819 --> 00:08:36,250
results, and if I have time at the end, I will talk about debugging techniques.

00:08:36,250 --> 00:08:41,510
I think a lot of people talk about GC algorithms and implementations, but I don't think they

00:08:41,510 --> 00:08:48,649
talk about debugging garbage collectors and I want to talk about that if we have time.

00:08:48,649 --> 00:08:50,970
So what is compaction?

00:08:50,970 --> 00:08:56,860
It is taking allocated memory and free memory and rearranging them.

00:08:56,860 --> 00:09:06,190
Imagine we have memory that looks like this with 

00:09:06,190 --> 00:09:07,530
allocated interspersed.

00:09:07,530 --> 00:09:11,500
And we can combine the blocks to look something like this.

00:09:11,500 --> 00:09:18,110
This may maybe some of you remember this.

00:09:18,110 --> 00:09:20,430
This is defragging a hard drive.

00:09:20,430 --> 00:09:27,600
But instead of defragging persistent data, instead what we're doing is defragging data

00:09:27,600 --> 00:09:31,160
that's in memory.

00:09:31,160 --> 00:09:32,980
One question is why would you want to do this?

00:09:32,980 --> 00:09:35,279
What is the benefit of compaction?

00:09:35,279 --> 00:09:37,980
One benefit is efficient memory usage.

00:09:37,980 --> 00:09:44,260
For example we have a heap layout that looks something like this and we want to allocate

00:09:44,260 --> 00:09:48,290
a new chunk of memory.

00:09:48,290 --> 00:09:52,680
That chunk that we would like to allocate is too wide so it won't fit in this free area.

00:09:52,680 --> 00:09:55,200
So, maybe we look at this free area.

00:09:55,200 --> 00:09:56,839
And it won't fit there either.

00:09:56,839 --> 00:10:00,360
It won't fit in either of the two places so we will get an out of memory error.

00:10:00,360 --> 00:10:03,149
We can't allocate this chunk.

00:10:03,149 --> 00:10:12,670
If we compacted it, it is wide enough and we can allocate into that chunk so we're able

00:10:12,670 --> 00:10:16,630
to use this memory more efficiently.

00:10:16,630 --> 00:10:22,720
Another reason to compact is more efficient use of CPU caches.

00:10:22,720 --> 00:10:27,190
So, when a program reads memory, it has to go through the CPU to get the memory.

00:10:27,190 --> 00:10:33,060
It has to read some memory and in order to do that, the CPU has to ask your RAM for it.

00:10:33,060 --> 00:10:38,290
The CPU will read chunks of memory at a time and actually reading from the RAM is kind

00:10:38,290 --> 00:10:44,250
of a slow operation, so there are a few caches in between the CPU and your RAM.

00:10:44,250 --> 00:10:53,120
And what will happen is the CPU will say I want to read a chunk into the cache.

00:10:53,120 --> 00:10:58,639
Hopefully when it is processing, all of the data we will be dealing with is out of the

00:10:58,639 --> 00:11:02,269
CPU caches.

00:11:02,269 --> 00:11:05,841
So, in this case we read this memory here.

00:11:05,841 --> 00:11:10,120
We have allocated memory and we happened to get some free memory, too.

00:11:10,120 --> 00:11:11,949
These are read into the CPU cache.

00:11:11,949 --> 00:11:17,180
As our program is going along processing the data in the memory, maybe it gets along to

00:11:17,180 --> 00:11:20,440
here and it's like oh, well, I don't need the stuff in the free memory.

00:11:20,440 --> 00:11:24,620
I need a different address and I need to go somewhere else and get it.

00:11:24,620 --> 00:11:30,279
What that means is maybe we have to hop over here and read over there and continue with

00:11:30,279 --> 00:11:31,690
our program.

00:11:31,690 --> 00:11:39,949
Doing this hop and reading memory from RAM is a slow operation, so if we can reduce that,

00:11:39,949 --> 00:11:42,279
then we'll have a faster program.

00:11:42,279 --> 00:11:48,980
If we are rearranging memory like this, hopefully we'll rearrange memory such that when we read

00:11:48,980 --> 00:11:53,449
out of memory, we'll read everything we need into a CPU cache and we'll be able to process

00:11:53,449 --> 00:11:55,290
all the results.

00:11:55,290 --> 00:12:00,139
That is a feature or what do you call it?

00:12:00,139 --> 00:12:02,790
The attribute of this is called good locality.

00:12:02,790 --> 00:12:07,160
If we have all of the data in the same kind of area, we call that good locality.

00:12:07,160 --> 00:12:11,420
Another reason is copy on write friendliness.

00:12:11,420 --> 00:12:18,959
We use Unicorn and it saves memory by using a copy on write technique and compaction will

00:12:18,959 --> 00:12:22,240
increase the efficiency of this particular technique.

00:12:22,240 --> 00:12:28,920
What this technique is, is we create a parent process.

00:12:28,920 --> 00:12:33,889
We boot up our Rails app and fork off a bunch of child processes.

00:12:33,889 --> 00:12:39,140
Those child processes get a copy of the parent process's memory.

00:12:39,140 --> 00:12:41,079
Let's say we do this and say okay.

00:12:41,079 --> 00:12:42,800
We have a child process.

00:12:42,800 --> 00:12:48,110
Now when the child process is created, it doesn't actually copy all of the parent's

00:12:48,110 --> 00:12:50,450
memory into the child process.

00:12:50,450 --> 00:12:53,180
Instead it points at the parent process.

00:12:53,180 --> 00:12:57,380
So, it creates virtual memory that points at the parent process.

00:12:57,380 --> 00:13:02,279
Now, let's say we need to write some data, the child wants to write some data into its

00:13:02,279 --> 00:13:03,699
pages.

00:13:03,699 --> 00:13:08,770
What will happen is the child process will say okay, I want to write into a free memory

00:13:08,770 --> 00:13:10,490
chunk.

00:13:10,490 --> 00:13:15,509
It'll write into this free memory chunk and that connection will get removed.

00:13:15,509 --> 00:13:19,279
So, it's no longer connected to the parent process.

00:13:19,279 --> 00:13:25,509
So, the child process will copy that chunk down into itself and then write into that

00:13:25,509 --> 00:13:26,699
location.

00:13:26,699 --> 00:13:32,790
Now, unfortunately, when this happens, the operating system takes care of this for us,

00:13:32,790 --> 00:13:35,769
and the operating system doesn't copy just what we need.

00:13:35,769 --> 00:13:39,329
It copies them in multiples of page sizes.

00:13:39,329 --> 00:13:44,290
So, that means that instead of just copying that free chunk down into the child process,

00:13:44,290 --> 00:13:48,389
we may actually get some stuff on the left or right of it that we don't actually need,

00:13:48,389 --> 00:13:53,640
so instead maybe we copy this allocated memory down into the child process as well.

00:13:53,640 --> 00:13:59,839
That means now our child process is consuming more memory than we originally could have.

00:13:59,839 --> 00:14:04,610
If we were to eliminate that fragmentation, it's less likely that we would encounter situations

00:14:04,610 --> 00:14:07,579
like this.

00:14:07,579 --> 00:14:14,470
The solution to all of these problems is essentially eliminating fragmentation, and fragmentation

00:14:14,470 --> 00:14:16,560
compaction is the solution to fragmentation.

00:14:16,560 --> 00:14:17,670
That's it.

00:14:17,670 --> 00:14:22,270
Just to recap, fragmented memory looks something like this.

00:14:22,270 --> 00:14:26,580
When we compact it to have no fragmentation, it looks something like this.

00:14:26,580 --> 00:14:30,769
Now another thing that I need to cover as well is in Ruby we can think of our programs

00:14:30,769 --> 00:14:34,269
as having two kind of heaps.

00:14:34,269 --> 00:14:37,170
So let's imagine we have our computer system.

00:14:37,170 --> 00:14:39,370
Our computer system has some amount of memory.

00:14:39,370 --> 00:14:44,040
Now in that memory, when we allocate memory from the system, we typically use Malloc to

00:14:44,040 --> 00:14:45,209
do that.

00:14:45,209 --> 00:14:48,260
We'll create what I call a Malloc heap.

00:14:48,260 --> 00:14:49,750
So, we ask malloc for memory.

00:14:49,750 --> 00:14:55,610
And inside of that malloc heap is Ruby's object heap.

00:14:55,610 --> 00:14:59,230
We have two different ones, but one is inside of the other.

00:14:59,230 --> 00:15:03,480
So, Ruby's object heap is allocated by malloc as well.

00:15:03,480 --> 00:15:06,790
But we can think of them as two separate areas.

00:15:06,790 --> 00:15:12,170
When we allocate objects, they get allocated out of Ruby's object heap.

00:15:12,170 --> 00:15:17,199
We do object.new, that comes out of Ruby's object heap like this.

00:15:17,199 --> 00:15:23,910
Now ideally the Ruby heap and the malloc heap would be exactly the same size, but unfortunately

00:15:23,910 --> 00:15:24,910
they're not.

00:15:24,910 --> 00:15:27,500
And I'll give you a simple example of why they're not.

00:15:27,500 --> 00:15:30,410
Let's say they have a string.

00:15:30,410 --> 00:15:31,949
We allocate a new string.

00:15:31,949 --> 00:15:37,610
This string actually points at a byte array, and that byte array is allocated out of malloc.

00:15:37,610 --> 00:15:44,690
So, it's allocated out of Ruby's object heap but the actual string itself is allocated

00:15:44,690 --> 00:15:46,339
via malloc.

00:15:46,339 --> 00:15:51,370
This is one reason why the malloc heap will be larger than Ruby's object heap.

00:15:51,370 --> 00:15:55,490
Unfortunately, fragmentation can occur in both of these heaps.

00:15:55,490 --> 00:15:59,709
When you talk about eliminating fragmentation, you need to be specific about which one you're

00:15:59,709 --> 00:16:00,790
talking about.

00:16:00,790 --> 00:16:05,779
So, for the malloc heap, at work we typically use jemalloc, and I'm not going to get into

00:16:05,779 --> 00:16:21,440
this, but if you have a Rails application, you should use anything but glibc.

00:16:21,440 --> 00:16:25,399
So Ruby's heap, let's take a look at Ruby's heap.

00:16:25,399 --> 00:16:27,959
And I don't mean the system memory or the malloc heap.

00:16:27,959 --> 00:16:30,550
I'm talking about what's stored inside of there.

00:16:30,550 --> 00:16:32,480
This is ruby's heap.

00:16:32,480 --> 00:16:35,139
Ruby's heap layout looks something like this.

00:16:35,139 --> 00:16:41,700
Ruby's objects are represented by a specific amount of memory.

00:16:41,700 --> 00:16:44,600
One of these boxes represents a byte.

00:16:44,600 --> 00:16:47,730
So, each object is 40 bytes.

00:16:47,730 --> 00:16:49,759
Each chunk is a slot.

00:16:49,759 --> 00:16:51,940
The slots can be empty or filled.

00:16:51,940 --> 00:16:56,279
So, we'll use white to represent empty and blue to represent filled.

00:16:56,279 --> 00:17:00,970
And later I will represent a new color, orange, and that's going to represent moved.

00:17:00,970 --> 00:17:08,520
Now one page, these slots are stored on what's called a page and one page is about 16 kilobytes

00:17:08,520 --> 00:17:13,329
so here we have contiguous slots and they create a page.

00:17:13,329 --> 00:17:18,970
One page is 16 kilobytes, and a Ruby heap is made up of multiple pages.

00:17:18,970 --> 00:17:21,520
So, this is what a Ruby heap looks like.

00:17:21,520 --> 00:17:26,459
We have multiple pages here, and each of those pages is allocated using the malloc system

00:17:26,459 --> 00:17:27,579
call.

00:17:27,579 --> 00:17:33,360
Now there's one more bit of information that we need to know before we can actually implement

00:17:33,360 --> 00:17:39,130
compaction and that's that each slot in Ruby's heap has a unique address.

00:17:39,130 --> 00:17:44,620
So, if we look at all of these slots, each of them has a unique address.

00:17:44,620 --> 00:17:48,390
Given this information, we can actually implement a compaction algorithm.

00:17:48,390 --> 00:17:51,390
So, let's look at the algorithm I choose.

00:17:51,390 --> 00:17:56,049
The one I'm going to use is called a two finger compaction algorithm.

00:17:56,049 --> 00:17:58,309
It was originally done in LISP.

00:17:58,309 --> 00:18:01,500
It is not a very good algorithm.

00:18:01,500 --> 00:18:04,110
If we have time after, I will tell you why.

00:18:04,110 --> 00:18:08,669
If you want to ask me a question, say Aaron, why is this not a good algorithm and I will

00:18:08,669 --> 00:18:15,240
be happy to explain this to you.

00:18:15,240 --> 00:18:19,231
When I first started this project, I didn't think it was possible, so I wanted to choose

00:18:19,231 --> 00:18:21,250
something easy to start with.

00:18:21,250 --> 00:18:23,200
Essentially the algorithm has two different parts.

00:18:23,200 --> 00:18:27,480
The first is moving objects and the second is updating references.

00:18:27,480 --> 00:18:30,190
First we will look at moving objects.

00:18:30,190 --> 00:18:34,880
So, imagine we have a heap that looks something like this.

00:18:34,880 --> 00:18:37,669
We've got a bunch of objects in there.

00:18:37,669 --> 00:18:42,929
The algorithm works by having two different fingers or pointers, one to either side of

00:18:42,929 --> 00:18:44,160
the heap.

00:18:44,160 --> 00:18:47,430
One pointer is called the free pointer, and we'll put that at the left side and the other

00:18:47,430 --> 00:18:51,202
pointer is called the scan pointer and we'll put that at the right side.

00:18:51,202 --> 00:18:54,680
The free pointer moves to the right until it can find a free slot.

00:18:54,680 --> 00:18:59,640
It will go along like this, finds a free spot and stops.

00:18:59,640 --> 00:19:06,990
The scan will move to the left until it finds a filled slot and then it will stop.

00:19:06,990 --> 00:19:09,620
Once they're in place, it will swap the two locations.

00:19:09,620 --> 00:19:11,930
It swaps like this.

00:19:11,930 --> 00:19:16,340
And we leave a forwarding address in place of the old object.

00:19:16,340 --> 00:19:20,100
So, here this one was at 9, but it is now at 4.

00:19:20,100 --> 00:19:22,500
So, we'll leave the number four here.

00:19:22,500 --> 00:19:24,000
And we'll repeat this process.

00:19:24,000 --> 00:19:25,730
We'll move the free pointer over.

00:19:25,730 --> 00:19:27,460
We'll move the scan pointer back.

00:19:27,460 --> 00:19:28,990
Swap the two.

00:19:28,990 --> 00:19:37,480
Leave a forwarding address, and then we repeat this process until the two pointers have met.

00:19:37,480 --> 00:19:42,330
So once the two have met, we are done moving objects around.

00:19:42,330 --> 00:19:44,480
The next part is updating references.

00:19:44,480 --> 00:19:46,331
So, let's say we have that same heap.

00:19:46,331 --> 00:19:54,290
It looks something like this.

00:19:54,290 --> 00:19:57,010
After objects are moved it will look like this.

00:19:57,010 --> 00:20:03,320
What we do to update the references is we walk through each object looking at the references

00:20:03,320 --> 00:20:04,320
and updating them.

00:20:04,320 --> 00:20:07,080
So, for example we start by looking at one.

00:20:07,080 --> 00:20:08,830
One points at six, but it's fine.

00:20:08,830 --> 00:20:09,830
It's not a forwarding address.

00:20:09,830 --> 00:20:17,090
So, we move on to two and two points at nine but nine is now at four so we update it to

00:20:17,090 --> 00:20:18,090
point at four.

00:20:18,090 --> 00:20:19,380
So, we say okay.

00:20:19,380 --> 00:20:21,049
Point over here at four.

00:20:21,049 --> 00:20:23,140
And we do that for three as well.

00:20:23,140 --> 00:20:26,679
Three points at eight, but it should go to five, so we update that.

00:20:26,679 --> 00:20:28,440
Thank you.

00:20:28,440 --> 00:20:33,170
And then we continue this process for each of the objects in the heap, and then we're

00:20:33,170 --> 00:20:39,919
done updating references, and all we have left to do is we convert those moved addresses

00:20:39,919 --> 00:20:43,900
into free slots, and we've successfully compacted the heap.

00:20:43,900 --> 00:20:45,200
This is it.

00:20:45,200 --> 00:20:52,190
So, if we were to rewrite this algorithm in Ruby, this is a Ruby conference, not a C conference...

00:20:52,190 --> 00:20:54,580
right?

00:20:54,580 --> 00:20:59,549
Though I will give you pointers in C if you would like.

00:20:59,549 --> 00:21:02,520
[ Laughter ] Sorry!

00:21:02,520 --> 00:21:04,010
Okay.

00:21:04,010 --> 00:21:11,350
So, this is what the algorithm would look like.

00:21:11,350 --> 00:21:32,150
The left 

00:21:32,150 --> 00:21:40,440
and right

00:21:40,440 --> 00:22:19,169
(((TEXT MISSING DUE TO SOFTWARE CRASH DURING TALK)))

00:22:19,169 --> 00:22:29,000
So for example, we need to know how do hashes hold references, how do arrays hold references,

00:22:29,000 --> 00:22:36,929
how do objects hold references, expressions, structs, etc.

00:22:36,929 --> 00:22:41,430
So, this is actually the most complicated part of this patch.

00:22:41,430 --> 00:22:43,720
So, I'm gonna show you the actual code here.

00:22:43,720 --> 00:22:44,720
Sorry.

00:22:44,720 --> 00:22:45,720
It's C code.

00:22:45,720 --> 00:22:46,720
This is it.

00:22:46,720 --> 00:22:48,510
One sec.

00:22:48,510 --> 00:22:54,710
Here is the entire patch.

00:22:54,710 --> 00:22:57,920
And that is only the reference updating part of this.

00:22:57,920 --> 00:23:03,720
If I was to estimate, I would say maybe 80% of the patch is just updating references.

00:23:03,720 --> 00:23:08,240
So, since updating references is the most complicated part of this, I want to talk about

00:23:08,240 --> 00:23:10,309
this part of the project.

00:23:10,309 --> 00:23:14,110
This is probably the hardest part for me to implement, and the main thing is we need to

00:23:14,110 --> 00:23:18,620
be able to update references while supporting C extensions.

00:23:18,620 --> 00:23:24,799
And I came up with a scheme for doing this and, I think this scheme is the novel idea.

00:23:24,799 --> 00:23:29,260
Which isn't trust me, it's not that novel.

00:23:29,260 --> 00:23:34,760
So, we have to answer a question like where are references stored?

00:23:34,760 --> 00:23:38,909
The most difficult thing about updating references is figuring out where all of them are stored.

00:23:38,909 --> 00:23:44,539
Now today, regardless of whether or not you have any Ruby core files on your computer,

00:23:44,539 --> 00:23:47,340
we are all part of the Ruby core team today, okay?

00:23:47,340 --> 00:23:48,340
All of us.

00:23:48,340 --> 00:23:54,340
Now a nice thing for us, while we are all hacking on this garbage collector is that

00:23:54,340 --> 00:23:59,860
we can say, okay, how do an array store its references?

00:23:59,860 --> 00:24:04,820
So for example, we have an array here, and we can go look at the source code for array.

00:24:04,820 --> 00:24:09,649
And if we go up array.c, we can see that the array points at a buffer.

00:24:09,649 --> 00:24:14,580
This buffer just contains a buffer of value stars, and it points at a bunch of different

00:24:14,580 --> 00:24:17,320
objects.

00:24:17,320 --> 00:24:21,461
Since all of us know how this is implemented, we can actually go into the garbage collector

00:24:21,461 --> 00:24:27,570
and say okay, when it's time to update references, we know how the references are stored so we

00:24:27,570 --> 00:24:31,720
can actually go in and write the code to fix them up.

00:24:31,720 --> 00:24:34,270
We can do the same thing for hashes as well.

00:24:34,270 --> 00:24:38,659
We know that a hash will point to a list of values and a list of keys.

00:24:38,659 --> 00:24:43,270
And we can look at the implementation of a hash and since we all know the implementation

00:24:43,270 --> 00:24:46,570
of the hash, we can write the reference updating code.

00:24:46,570 --> 00:24:50,090
And we just repeat this process for every single class that's in Ruby.

00:24:50,090 --> 00:24:57,890
So, we do it for strings, classes, modules, symbols, reg xs, all of the fun stuff.

00:24:57,890 --> 00:25:02,320
What I like to call the types is I like to call these types known types.

00:25:02,320 --> 00:25:05,649
So, the garbage collector can update all known types.

00:25:05,649 --> 00:25:11,210
Known types are types that are implemented by Ruby, by Ruby the language.

00:25:11,210 --> 00:25:12,860
But that leaves a question for us.

00:25:12,860 --> 00:25:18,110
What about unknown types and I refer to unknown types as types that are implemented in C.

00:25:18,110 --> 00:25:21,230
And I will give you an example of one.

00:25:21,230 --> 00:25:24,200
We use a JSON parser called yajl.

00:25:24,200 --> 00:25:32,419
Yajl is written in C and this is the struct that is used for that parser.

00:25:32,419 --> 00:25:35,340
You don't need to understand C to get this.

00:25:35,340 --> 00:25:36,610
I will explain it.

00:25:36,610 --> 00:25:41,130
But essentially these two values here, the struct points at two values.

00:25:41,130 --> 00:25:42,130
These are Ruby objects.

00:25:42,130 --> 00:25:45,570
It has references to two Ruby objects, okay?

00:25:45,570 --> 00:25:49,250
When we create a new yajl parser, we will Malloc the struct.

00:25:49,250 --> 00:25:57,860
Then we will also allocate a Ruby object allocated out of the Ruby heap.

00:25:57,860 --> 00:26:02,490
This Ruby object will point at that Malloc's data and this is what we deal with in our

00:26:02,490 --> 00:26:04,450
Ruby programs.

00:26:04,450 --> 00:26:10,370
Now this struct will point it has two references as we noticed here in the struct definition.

00:26:10,370 --> 00:26:13,820
It points at a builder stack and a parse_complete_callback.

00:26:13,820 --> 00:26:21,020
I don't know what they are, but what's important is they are two Ruby objects.

00:26:21,020 --> 00:26:27,110
Now unfortunately, the garbage collector doesn't know anything about this struct.

00:26:27,110 --> 00:26:31,190
Since it doesn't know, it can't update the references.

00:26:31,190 --> 00:26:34,500
So, how do we prevent those objects from moving?

00:26:34,500 --> 00:26:39,840
Now the garbage collector will look and say I don't know what this is.

00:26:39,840 --> 00:26:42,059
I can't fix it.

00:26:42,059 --> 00:26:47,460
Unfortunately, if any of these objects move, say that one moves, now it's moved somewhere

00:26:47,460 --> 00:26:51,550
else and the program will just crash.

00:26:51,550 --> 00:26:53,360
Hopefully.

00:26:53,360 --> 00:26:56,970
[ Laughter ] Yes.

00:26:56,970 --> 00:27:05,169
Let me I am going to convey to you how scary this is.

00:27:05,169 --> 00:27:06,440
Imagine okay.

00:27:06,440 --> 00:27:09,570
I'm going off script here.

00:27:09,570 --> 00:27:11,860
Imagine that Ruby object moves, okay?

00:27:11,860 --> 00:27:12,860
So it moves.

00:27:12,860 --> 00:27:13,860
It goes away.

00:27:13,860 --> 00:27:16,080
GC says I don't know.

00:27:16,080 --> 00:27:17,740
This thing moves away.

00:27:17,740 --> 00:27:20,150
Imagine the program continues to run and it doesn't crash.

00:27:20,150 --> 00:27:23,980
Like we don't use the agile for a little bit.

00:27:23,980 --> 00:27:29,529
Another object gets allocated, another Ruby object gets allocated but allocated in its

00:27:29,529 --> 00:27:30,960
place.

00:27:30,960 --> 00:27:34,520
Now the reference is good but it's pointing at the wrong thing.

00:27:34,520 --> 00:27:36,410
So just imagine that in your program.

00:27:36,410 --> 00:27:37,410
So, yes.

00:27:37,410 --> 00:27:38,410
This is scary.

00:27:38,410 --> 00:27:41,360
So, we really, really want to prevent this from happening.

00:27:41,360 --> 00:27:42,660
All right.

00:27:42,660 --> 00:27:44,039
So how do we do that?

00:27:44,039 --> 00:27:48,419
The way that we do that is all of these c extensions need to implement a mark function.

00:27:48,419 --> 00:27:51,080
They have to keep these references alive.

00:27:51,080 --> 00:27:55,600
If they don't keep the references alive, the garbage collector will of course collect them,

00:27:55,600 --> 00:27:57,320
and then the program will crash anyway.

00:27:57,320 --> 00:28:01,700
So, C extension authors need to write a mark function that marks the references.

00:28:01,700 --> 00:28:08,679
And this is from the yajl C extension and it's marking its references here.

00:28:08,679 --> 00:28:16,440
We can say every time we mark something, the C extension author has to call rb_gc_mark

00:28:16,440 --> 00:28:19,210
and they pass it in.

00:28:19,210 --> 00:28:27,580
So, these objects go through rb_gc_mark, and anything that passes through rb_gc will not

00:28:27,580 --> 00:28:29,450
allow it to move.

00:28:29,450 --> 00:28:37,510
So, anything marked with rb_gc_mark cannot move.

00:28:37,510 --> 00:28:39,559
I had to add something called pinning bits.

00:28:39,559 --> 00:28:44,730
It's a bit table that sits alongside of the objects.

00:28:44,730 --> 00:28:47,900
So, let's say is we have an object layout that looks like this.

00:28:47,900 --> 00:28:50,960
We have an array at the top.

00:28:50,960 --> 00:28:56,269
I want to demonstrate the difference between a known and unknown type.

00:28:56,269 --> 00:29:02,659
During the mark phase, we'll go through and mark this.

00:29:02,659 --> 00:29:08,159
The GC will mark, yajl will mark those in the pin bit table.

00:29:08,159 --> 00:29:12,840
When the array goes to mark, it will mark its references, but it doesn't use that function,

00:29:12,840 --> 00:29:15,289
it uses a different function.

00:29:15,289 --> 00:29:18,000
One we have implemented in Ruby and is private.

00:29:18,000 --> 00:29:22,560
They get marked but not pinned in the pin bit table.

00:29:22,560 --> 00:29:28,290
Now when the garbage collector goes to compact, we go and do the same algorithm, so we'll

00:29:28,290 --> 00:29:34,540
scan along, but what will happen is when the scan pointer finds something that's pinned,

00:29:34,540 --> 00:29:36,970
it just skips it and goes to the next one.

00:29:36,970 --> 00:29:41,390
So, all the objects that were pinned, they don't move, and we just continue with this

00:29:41,390 --> 00:29:46,660
algorithm as normal, swapping, leaving forwarding addresses, etc.

00:29:46,660 --> 00:29:47,660
Okay.

00:29:47,660 --> 00:29:48,660
Great.

00:29:48,660 --> 00:29:50,480
Good job, keynote.

00:29:50,480 --> 00:29:55,669
And it's that fast, too, GC.

00:29:55,669 --> 00:30:01,450
So when we go through and update the references, the GC will look at yajl and say I don't know

00:30:01,450 --> 00:30:02,450
this type.

00:30:02,450 --> 00:30:03,500
I can't update it.

00:30:03,500 --> 00:30:07,200
But it doesn't matter because we've guaranteed that all of its references stay put.

00:30:07,200 --> 00:30:08,200
They don't move.

00:30:08,200 --> 00:30:10,200
So, it will update the array.

00:30:10,200 --> 00:30:11,950
The array gets updated as normal.

00:30:11,950 --> 00:30:14,760
All the objects get updated as normal.

00:30:14,760 --> 00:30:16,090
Okay.

00:30:16,090 --> 00:30:17,429
Bleh.

00:30:17,429 --> 00:30:20,110
Thank you.

00:30:20,110 --> 00:30:22,799
That fast.

00:30:22,799 --> 00:30:24,510
So known types will use gc_mark_no_pin.

00:30:24,510 --> 00:30:27,730
I have changed it to movable.

00:30:27,730 --> 00:30:32,529
I think that's better than no_pin.

00:30:32,529 --> 00:30:37,990
So, we know not to move those.

00:30:37,990 --> 00:30:43,920
This is how we can keep our c extensions safe, and this is the novel idea, I guess.

00:30:43,920 --> 00:30:47,179
So I want to talk a little bit about allowing movement in C extensions.

00:30:47,179 --> 00:30:51,290
We would like to write extensions that are compaction friendly.

00:30:51,290 --> 00:30:56,330
So, what I did to do that is I implemented three things.

00:30:56,330 --> 00:31:00,889
Compaction callback, movable marking, and a new location function.

00:31:00,889 --> 00:31:05,330
The GC can't update C extensions, but C extensions, they can update themselves.

00:31:05,330 --> 00:31:08,300
So, what I did is I said okay.

00:31:08,300 --> 00:31:14,200
We're going to update yajl.

00:31:14,200 --> 00:31:18,080
Here we specify a mark function and a free function.

00:31:18,080 --> 00:31:23,390
We'll update this to have a third callback which is the compact function.

00:31:23,390 --> 00:31:26,470
This is updated code.

00:31:26,470 --> 00:31:29,250
We specified compact callback.

00:31:29,250 --> 00:31:33,960
This gets called after every compaction.

00:31:33,960 --> 00:31:41,130
Now we change the mark function, rather than calling RBGC mark.

00:31:41,130 --> 00:31:46,340
That says I want you to mark this but it's okay if the object moves.

00:31:46,340 --> 00:31:52,549
Then inside of our compaction callback, we call this function, rb_gc_location and this

00:31:52,549 --> 00:31:58,740
asks the garbage collector hey, if this thing moved, give me the updated address.

00:31:58,740 --> 00:32:00,269
And that's how we implement that.

00:32:00,269 --> 00:32:05,630
There is one known issue, and this is kind of a doozy.

00:32:05,630 --> 00:32:09,230
Let's say we have an object graph that looks like this.

00:32:09,230 --> 00:32:18,770
We have an object implemented in Ruby and one implemented in C. Imagine I am a C extension

00:32:18,770 --> 00:32:23,980
author, and I know that my Ruby object, it points at this third object and I know that

00:32:23,980 --> 00:32:30,389
the C object also points at this third object, and I know that the Ruby object will keep

00:32:30,389 --> 00:32:31,850
this third object alive.

00:32:31,850 --> 00:32:34,900
So, I think to myself, ah, I am clever.

00:32:34,900 --> 00:32:39,679
I know that the Ruby object will keep the third object alive, so I'm not going to mark

00:32:39,679 --> 00:32:42,059
it from the C object.

00:32:42,059 --> 00:32:45,390
I will rely on that Ruby object to keep it alive.

00:32:45,390 --> 00:32:50,990
I know that this one is automatically marked via gc_mark_no_pin, so I'm not going to mark

00:32:50,990 --> 00:32:57,770
this one because it will stay alive.

00:32:57,770 --> 00:32:59,000
It is a thing.

00:32:59,000 --> 00:33:06,950
So, what will happen in this case is the compactor will run, will swap locations, everything

00:33:06,950 --> 00:33:08,830
will look just fine.

00:33:08,830 --> 00:33:14,320
The Ruby object, its references will get updated correctly, but the C object, its references

00:33:14,320 --> 00:33:15,360
will not get updated.

00:33:15,360 --> 00:33:22,220
It will point to a free location or in a very, very worse case scenario, the wrong object.

00:33:22,220 --> 00:33:27,230
And our program will actually, hopefully crash.

00:33:27,230 --> 00:33:29,919
We want it to crash in this situation.

00:33:29,919 --> 00:33:34,211
So maybe this isn't too common, although I have found it in a few places so far, one

00:33:34,211 --> 00:33:36,970
of them is the compilation process.

00:33:36,970 --> 00:33:45,200
When we convert text to an abstract syntax tree, there is a location.

00:33:45,200 --> 00:33:51,990
I fixed it in instruction sequences and the intermediate representation, and we will talk

00:33:51,990 --> 00:33:54,080
about that now.

00:33:54,080 --> 00:33:58,779
Essentially inside of our instruction sequences we point at real Ruby objects.

00:33:58,779 --> 00:34:05,820
If you look at an instruction sequence, it's an array of bytes and it has a pointer to

00:34:05,820 --> 00:34:06,820
a literal.

00:34:06,820 --> 00:34:09,250
A string.

00:34:09,250 --> 00:34:12,530
It used to be we would keep this alive via a mark array.

00:34:12,530 --> 00:34:19,230
They would be relied on to keep these things alive and this pattern is almost the same

00:34:19,230 --> 00:34:23,180
as we saw in our problem object graph.

00:34:23,180 --> 00:34:29,190
So, I fixed this by essentially walking all of the instruction sequences at mark time.

00:34:29,190 --> 00:34:35,420
What that means is that we're able to eliminate this mark array and directly mark these things.

00:34:35,420 --> 00:34:41,390
And as you can see, like, this is to demonstrate this has been a multiyear yak shave, this

00:34:41,390 --> 00:34:51,630
was released in Ruby 2.6 and done in preparation of implementing the compacter.

00:34:51,630 --> 00:34:57,080
During compilation it would break and I was able to fix it in basically the same way.

00:34:57,080 --> 00:35:11,290
The intermediate representation had almost the exact same pattern used there.

00:35:11,290 --> 00:35:14,430
Those are all in Ruby 2.7.

00:35:14,430 --> 00:35:18,280
So, that is great.

00:35:18,280 --> 00:35:20,200
All right.

00:35:20,200 --> 00:35:21,220
One more example.

00:35:21,220 --> 00:35:24,400
I found this in the JSON library as well.

00:35:24,400 --> 00:35:32,000
An interesting pattern about this problem is that if these two objects are written in

00:35:32,000 --> 00:35:39,620
Ruby, we have pure Ruby implementations here, if we are clever and by clever, I mean evil

00:35:39,620 --> 00:35:45,610
Ruby developers, we can actually cut that reference, because it's just Ruby code, right?

00:35:45,610 --> 00:35:49,950
And if we cut that reference, the garbage collector will go ahead and collect that object

00:35:49,950 --> 00:35:54,770
and now we have a C extension that's pointing at nothing and the program will crash.

00:35:54,770 --> 00:35:56,600
So, let me give you an example.

00:35:56,600 --> 00:36:00,970
Here is a problem code here in the JSON library.

00:36:00,970 --> 00:36:10,720
We're pointing at constants and the constants are globals.

00:36:10,720 --> 00:36:13,630
I could make this program crash by doing this.

00:36:13,630 --> 00:36:15,890
Essentially what I would say is okay.

00:36:15,890 --> 00:36:16,890
Guess what?

00:36:16,890 --> 00:36:19,980
I am going to remove that constant here.

00:36:19,980 --> 00:36:25,560
The garbage collector would then go ahead and collect that constant when we did a gc.start

00:36:25,560 --> 00:36:28,370
and then the program would crash.

00:36:28,370 --> 00:36:29,370
So that was cool.

00:36:29,370 --> 00:36:30,630
The fix is very simple.

00:36:30,630 --> 00:36:32,420
We just say we need to mark these things.

00:36:32,420 --> 00:36:37,070
I found the same thing in message pack.

00:36:37,070 --> 00:36:41,920
Since this reference was created in Ruby, I was able to cut it, make the program crash,

00:36:41,920 --> 00:36:45,540
and then let's see did I do the animation?

00:36:45,540 --> 00:36:46,540
Yes!

00:36:46,540 --> 00:36:47,540
Ahhhh!

00:36:47,540 --> 00:36:48,540
I love that.

00:36:48,540 --> 00:36:50,740
I'm trying to use all of the Keynote animations.

00:36:50,740 --> 00:36:52,600
All right.

00:36:52,600 --> 00:37:00,290
So my hypothesis with this, and I think that most of you will agree with me is that pure

00:37:00,290 --> 00:37:02,720
Ruby programs shouldn't crash.

00:37:02,720 --> 00:37:03,730
Right?

00:37:03,730 --> 00:37:05,750
[ Laughter ] Yes!

00:37:05,750 --> 00:37:06,760
Yes!

00:37:06,760 --> 00:37:09,160
Clap for that.

00:37:09,160 --> 00:37:10,880
Yes!

00:37:10,880 --> 00:37:14,030
[ Applause ] I know we all want to be on the Ruby core

00:37:14,030 --> 00:37:16,330
team, but our programs really shouldn't crash.

00:37:16,330 --> 00:37:19,050
We should not get core files out of them.

00:37:19,050 --> 00:37:23,870
Since I was able to get the rest of the core team to agree with this particular premise

00:37:23,870 --> 00:37:30,110
and because of that if I can make your program crash using pure Ruby, it is a bug and we

00:37:30,110 --> 00:37:32,530
should fix it.

00:37:32,530 --> 00:37:37,510
What shakes out of this is a very, very simple rule for C extension authors, and that is

00:37:37,510 --> 00:37:42,010
essentially if you hold a reference, you must mark the reference.

00:37:42,010 --> 00:37:43,430
That's it.

00:37:43,430 --> 00:37:46,310
If you hold a reference, you need to mark a reference.

00:37:46,310 --> 00:37:52,500
Now let me give you another solution, another solution to this problem is to just don't

00:37:52,500 --> 00:37:54,130
write any C code.

00:37:54,130 --> 00:37:58,310
I think that that is the better solution.

00:37:58,310 --> 00:38:01,860
So, let's go over one more challenge and check out the results.

00:38:01,860 --> 00:38:04,550
I want to talk about object_id.

00:38:04,550 --> 00:38:07,580
This is an interesting problem.

00:38:07,580 --> 00:38:14,540
Generally direct memory access prevents movement of objects, so let's take a look at how object_id

00:38:14,540 --> 00:38:17,660
is implemented in Ruby 2.6 and older.

00:38:17,660 --> 00:38:21,140
Object_id in Ruby 2.6 and older is based on location.

00:38:21,140 --> 00:38:31,790
Now, the 

00:38:31,790 --> 00:38:37,130
question is if one of these objects moves, what is the object_id now?

00:38:37,130 --> 00:38:38,390
Right?

00:38:38,390 --> 00:38:42,350
And I'm gonna talk about my initial solution for this, and we'll see a much better solution

00:38:42,350 --> 00:38:43,490
here in a couple minutes.

00:38:43,490 --> 00:38:47,790
Essentially, what is the object_id here?

00:38:47,790 --> 00:38:51,530
We would say we don't know.

00:38:51,530 --> 00:38:52,530
We haven't looked.

00:38:52,530 --> 00:38:53,840
We compact the heap.

00:38:53,840 --> 00:38:54,840
It moves.

00:38:54,840 --> 00:38:56,150
Check out the object_id.

00:38:56,150 --> 00:38:57,300
It is 1.

00:38:57,300 --> 00:38:58,920
No problem.

00:38:58,920 --> 00:39:00,360
What is it after we move?

00:39:00,360 --> 00:39:02,960
We will look here.

00:39:02,960 --> 00:39:04,680
Okay.

00:39:04,680 --> 00:39:05,680
Create an object.

00:39:05,680 --> 00:39:07,640
Look at its object_id, it's 4.

00:39:07,640 --> 00:39:09,750
We compact the heap.

00:39:09,750 --> 00:39:14,230
Then we check the object_id again, question is what should the object_id be here?

00:39:14,230 --> 00:39:17,260
Well, you would probably expect 4.

00:39:17,260 --> 00:39:19,110
I would think.

00:39:19,110 --> 00:39:24,120
So to fix this, my initial solution was to keep track of that object_id and make sure

00:39:24,120 --> 00:39:25,120
it didn't change.

00:39:25,120 --> 00:39:27,310
So, essentially I keep a global map.

00:39:27,310 --> 00:39:31,770
If you call object_id, we keep track of the object_id that you saw.

00:39:31,770 --> 00:39:33,380
Okay?

00:39:33,380 --> 00:39:37,740
So essentially the solution is here, walking through the code again, check the object_id,

00:39:37,740 --> 00:39:40,000
create a map, 4 maps to 4.

00:39:40,000 --> 00:39:41,630
We compact the heap.

00:39:41,630 --> 00:39:43,150
Now it's at address 1.

00:39:43,150 --> 00:39:49,460
So, the address 1 maps to object_id 4 and when you call again, you get the right number.

00:39:49,460 --> 00:39:53,570
Unfortunately, this introduces a problem, and this is a thing that sucks about this

00:39:53,570 --> 00:39:55,110
algorithm.

00:39:55,110 --> 00:40:00,300
What happens here, let's say we take a look at this and move this and allocate a new object.

00:40:00,300 --> 00:40:04,380
This object y happens to be put into slot 4.

00:40:04,380 --> 00:40:07,540
And now what?

00:40:07,540 --> 00:40:09,830
What should the object_id be?

00:40:09,830 --> 00:40:12,640
In my initial implementation what I did is said okay.

00:40:12,640 --> 00:40:15,490
We're just going to count up.

00:40:15,490 --> 00:40:17,410
Just add one.

00:40:17,410 --> 00:40:19,570
If that one's being used, go up again.

00:40:19,570 --> 00:40:22,819
Just keep going and see what happens.

00:40:22,819 --> 00:40:24,530
[ Laughter ] And then store that.

00:40:24,530 --> 00:40:28,150
So, in this particular case our object_id is gonna be 5.

00:40:28,150 --> 00:40:30,430
Let's walk through these animations.

00:40:30,430 --> 00:40:32,060
Yay!

00:40:32,060 --> 00:40:36,260
I can't wait to get to the better solution, because this one is not good.

00:40:36,260 --> 00:40:39,790
So, here we have object_id 5.

00:40:39,790 --> 00:40:44,220
Unfortunately that means we have to clean up the table when an object gets freed or

00:40:44,220 --> 00:40:46,510
the table would grow forever.

00:40:46,510 --> 00:40:55,300
So, in GC clean up, if the location was seen, we have to remove it from the map.

00:40:55,300 --> 00:41:03,400
I call this mostly location based object IDs, because it's typically the address, but sometimes

00:41:03,400 --> 00:41:05,030
it won't be.

00:41:05,030 --> 00:41:07,120
Fortunately, this is canceled.

00:41:07,120 --> 00:41:10,780
Well, it's like 20% canceled.

00:41:10,780 --> 00:41:14,440
Actually, we refactored it to be better.

00:41:14,440 --> 00:41:15,680
That's what we did.

00:41:15,680 --> 00:41:20,940
Now in master, I don't know if this is actually going to make it into 2.7, but in master we

00:41:20,940 --> 00:41:30,030
have a monotonic object ID and I worked on this with my co worker, j Hawthorne.

00:41:30,030 --> 00:41:37,160
So, when you call object ID, we will give you a number and when you call we will give

00:41:37,160 --> 00:41:42,820
you a bigger number and we will do it forever and ever and ever.

00:41:42,820 --> 00:41:51,020
This is what it looks like if you build Ruby today, you call object_id new.

00:41:51,020 --> 00:41:55,810
I gave an example here in the middle where we allocate an object, But you will see each

00:41:55,810 --> 00:41:58,560
time it increments by 20.

00:41:58,560 --> 00:42:03,350
But that final one, the one in the middle there, it didn't get an object_id, and the

00:42:03,350 --> 00:42:08,151
reason I did that is to demonstrate that this number is only calculated at the time that

00:42:08,151 --> 00:42:09,151
you call object_id.

00:42:09,151 --> 00:42:15,910
So, a cool feature about this is object_ids are truly unique.

00:42:15,910 --> 00:42:20,090
Before since they were memory addresses, it meant that we could reuse them.

00:42:20,090 --> 00:42:22,210
Today they are unique.

00:42:22,210 --> 00:42:25,640
We can also do weird things like count the number of object ID calls.

00:42:25,640 --> 00:42:32,270
So, for example here, the other thing we can do is I didn't put a slide of counting object

00:42:32,270 --> 00:42:36,770
IDs, but I want to call something out that's weird.

00:42:36,770 --> 00:42:46,110
In Ruby 2.6 and older, if you call in spec, it is actually the address.

00:42:46,110 --> 00:42:48,250
Those two numbers are related.

00:42:48,250 --> 00:42:54,350
Now in Ruby 2.7 and newer, there is absolutely no relationship between those two numbers.

00:42:54,350 --> 00:43:01,270
And let's cut this part out of the video, but a question I have for you in the audience

00:43:01,270 --> 00:43:09,110
here is if that inspect is based on the address and the object moves, what will the inspect

00:43:09,110 --> 00:43:11,110
look like?

00:43:11,110 --> 00:43:13,390
But please don't file a bug about that.

00:43:13,390 --> 00:43:15,130
Thank you.

00:43:15,130 --> 00:43:16,130
Okay.

00:43:16,130 --> 00:43:21,360
So, the tl;dr is please don't use object ID unless you need to.

00:43:21,360 --> 00:43:24,040
Oh my God, I'm way out of time.

00:43:24,040 --> 00:43:26,130
This is a basic Rails application.

00:43:26,130 --> 00:43:27,740
I mapped the memory out.

00:43:27,740 --> 00:43:31,370
This is the first implementation, after compaction and before.

00:43:31,370 --> 00:43:35,330
This is our Rails application at work.

00:43:35,330 --> 00:43:38,460
The top is before bottom is after.

00:43:38,460 --> 00:43:42,590
It's way too big to fit on a slide so I slide it all the way like this.

00:43:42,590 --> 00:43:46,320
This is the very first implementation when I first got it working.

00:43:46,320 --> 00:43:51,360
And this first implementation, 3% of the objects were pinned in the heap.

00:43:51,360 --> 00:43:52,950
I have since been able to improve it.

00:43:52,950 --> 00:43:55,150
I didn't tell you this.

00:43:55,150 --> 00:43:58,480
So, red dots represent objects that are pinned.

00:43:58,480 --> 00:44:03,230
Black represents objects, white represents free space.

00:44:03,230 --> 00:44:07,290
So the red dots, you can see from the red how much of the heap is pinned.

00:44:07,290 --> 00:44:09,420
You can see we have a lot of it here.

00:44:09,420 --> 00:44:13,320
What's weird is that a lot is only 3%.

00:44:13,320 --> 00:44:17,450
So, here is after some work on it before and after.

00:44:17,450 --> 00:44:19,670
And you can hardly see any red now.

00:44:19,670 --> 00:44:22,910
So, you can see it's shrunk down a bunch.

00:44:22,910 --> 00:44:25,390
That's with 1% pinned.

00:44:25,390 --> 00:44:28,420
Right now, this is what it is today.

00:44:28,420 --> 00:44:31,120
Actually it may be even better than this.

00:44:31,120 --> 00:44:34,360
So, you can see there we have a much bigger improvement.

00:44:34,360 --> 00:44:40,150
[ Applause ] Yes, thank you!

00:44:40,150 --> 00:44:47,370
3% pinned results in a 10% smaller heap.

00:44:47,370 --> 00:44:48,370
Future plans.

00:44:48,370 --> 00:44:50,430
I'm way over time.

00:44:50,430 --> 00:44:51,860
I need to do performance improvements.

00:44:51,860 --> 00:44:52,860
It's not fast.

00:44:52,860 --> 00:44:54,310
It's very inefficient.

00:44:54,310 --> 00:44:57,821
We do a full collection and then move the objects and then update the references and

00:44:57,821 --> 00:44:58,850
then a full GC.

00:44:58,850 --> 00:45:00,780
I have eliminated the full GC.

00:45:00,780 --> 00:45:02,170
That is gone.

00:45:02,170 --> 00:45:07,810
We still do the three steps but we can reduce down to two and it is theoretically possible

00:45:07,810 --> 00:45:10,930
to combine those two together into one.

00:45:10,930 --> 00:45:13,460
So, I want to do that as well.

00:45:13,460 --> 00:45:16,650
In Ruby 3.0, my plan is to add automatic compaction.

00:45:16,650 --> 00:45:18,200
Right now you need to call GC.compact.

00:45:18,200 --> 00:45:23,090
In the future, you do nothing.

00:45:23,090 --> 00:45:28,960
The difference between what we have today in sliding, instead of using two fingers,

00:45:28,960 --> 00:45:32,050
we will slide them together like that.

00:45:32,050 --> 00:45:37,630
The reason is for better locality and it supports variable width objects.

00:45:37,630 --> 00:45:41,600
And the final thing I want to do is implement variable width allocation.

00:45:41,600 --> 00:45:44,460
And what that means, oh, thank you, yes.

00:45:44,460 --> 00:45:48,110
What that means is today we have fixed width allocation that looks like this.

00:45:48,110 --> 00:45:53,790
Our heap looks like this and instead I would like it to look like this where we can allocate

00:45:53,790 --> 00:45:57,420
things of any size that we want to.

00:45:57,420 --> 00:46:03,000
The way I want to end this talk today is we're constantly improving Ruby.

00:46:03,000 --> 00:46:06,410
The folks on the core team are doing their best to improve the Ruby implementation that

00:46:06,410 --> 00:46:07,540
we have now.

00:46:07,540 --> 00:46:11,760
I personally believe that Ruby's future is very exciting.

00:46:11,760 --> 00:46:16,120
And I want to say thank you to all of you for coming today.

00:46:16,120 --> 00:46:20,770
Thank you.

00:46:20,770 --> 00:46:23,090

YouTube URL: https://www.youtube.com/watch?v=1F3gXYhQsAY


