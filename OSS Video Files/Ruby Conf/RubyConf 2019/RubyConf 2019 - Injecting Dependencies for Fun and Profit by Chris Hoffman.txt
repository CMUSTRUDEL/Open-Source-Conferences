Title: RubyConf 2019 - Injecting Dependencies for Fun and Profit by Chris Hoffman
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Injecting Dependencies for Fun and Profit by Chris Hoffman

Does your codebase not seem as flexible as it used to? Are you missing that bounce in its step? Is your test suite no longer full of vigor? Get Dependency Injection! Dependency Injection soothes testing pains, improves your domain model, and makes your code more maintainable. Pay no mind to the naysayers; Dependency Injection isn’t just for architecture astronauts--it’s truly a technique for the common developer. So step right up! Discover the potential dangers of Globals, learn how to use Dependency Injection to avoid them, and see if it could be a boon to your project!

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,420 --> 00:00:18,850
okay my time we're starting so that

00:00:16,299 --> 00:00:20,890
means we're gonna get started hi I'm

00:00:18,850 --> 00:00:21,910
Chris Hoffman I use he/him pronouns I'm

00:00:20,890 --> 00:00:23,590
a senior developer to an e-commerce

00:00:21,910 --> 00:00:24,760
company called outpour oh and today

00:00:23,590 --> 00:00:27,160
we're gonna talk about dependency

00:00:24,760 --> 00:00:28,600
injection first I'm gonna introduce

00:00:27,160 --> 00:00:30,340
dependency injection with some actual

00:00:28,600 --> 00:00:32,079
codes y'all can get a concrete idea of

00:00:30,340 --> 00:00:33,910
what using the technique looks like and

00:00:32,079 --> 00:00:35,260
with that context established I'm going

00:00:33,910 --> 00:00:37,510
to talk about the benefits of dependency

00:00:35,260 --> 00:00:39,790
injection both for our code and for the

00:00:37,510 --> 00:00:41,950
users experience of our code I'm also

00:00:39,790 --> 00:00:43,960
going to talk about why you might prefer

00:00:41,950 --> 00:00:45,730
dependency injection to the more

00:00:43,960 --> 00:00:47,770
familiar Ruby test testing technique of

00:00:45,730 --> 00:00:49,270
partial mocking then I'm gonna wrap up

00:00:47,770 --> 00:00:50,829
with examining how we might go about

00:00:49,270 --> 00:00:53,590
introducing dependency injection into a

00:00:50,829 --> 00:00:56,590
rails app so that's the agenda we're

00:00:53,590 --> 00:00:58,450
gonna get started to start with the

00:00:56,590 --> 00:01:00,430
phrase dependency injection isn't used

00:00:58,450 --> 00:01:03,129
to mean just one thing it's not a single

00:01:00,430 --> 00:01:04,959
technique one of the things it can refer

00:01:03,129 --> 00:01:07,869
to is dependency injection frameworks

00:01:04,959 --> 00:01:10,539
which are not shall we say universally

00:01:07,869 --> 00:01:12,219
loved they can frequently be frustrating

00:01:10,539 --> 00:01:14,139
to work with and confusing to debug and

00:01:12,219 --> 00:01:15,639
the applications that rely on them it's

00:01:14,139 --> 00:01:17,499
almost impossible to escape using them

00:01:15,639 --> 00:01:19,929
fortunately we're not gonna be talking

00:01:17,499 --> 00:01:21,130
about those at all today the dependency

00:01:19,929 --> 00:01:22,509
injection I'm going to show you is a

00:01:21,130 --> 00:01:23,649
lightweight technique that you can

00:01:22,509 --> 00:01:25,539
introduce into your applications

00:01:23,649 --> 00:01:27,159
incrementally it'll help you write more

00:01:25,539 --> 00:01:28,600
testable more maintainable code and

00:01:27,159 --> 00:01:30,459
it'll help you ship software they better

00:01:28,600 --> 00:01:32,950
use your experience those are bold

00:01:30,459 --> 00:01:34,509
claims to be sure even worse I'm not

00:01:32,950 --> 00:01:36,130
going to defend those claims right now I

00:01:34,509 --> 00:01:37,509
want to show you all code right away so

00:01:36,130 --> 00:01:38,799
that when I do defend those claims

00:01:37,509 --> 00:01:40,810
they'll be contextualized in what you've

00:01:38,799 --> 00:01:43,060
just seen instead of being baseless and

00:01:40,810 --> 00:01:44,439
abstracted from anything concrete so

00:01:43,060 --> 00:01:47,950
with that out of the way let's talk

00:01:44,439 --> 00:01:49,539
about home automation and Ruby so let's

00:01:47,950 --> 00:01:51,340
pretend we want to automate our home and

00:01:49,539 --> 00:01:53,229
let's pretend we want to use Ruby are we

00:01:51,340 --> 00:01:56,469
all pretending that I'm gonna pretend

00:01:53,229 --> 00:01:59,109
that we're all pretending that don't

00:01:56,469 --> 00:02:00,399
start with something simple sometime in

00:01:59,109 --> 00:02:02,139
the morning either right after we get up

00:02:00,399 --> 00:02:04,149
or before we leave the house we want to

00:02:02,139 --> 00:02:05,829
know what the day's weather is and

00:02:04,149 --> 00:02:07,539
because we don't want to deal with a

00:02:05,829 --> 00:02:08,830
screen or having to you know find a

00:02:07,539 --> 00:02:12,490
screen to look at we want to have our

00:02:08,830 --> 00:02:14,050
house read us are the weather report in

00:02:12,490 --> 00:02:17,290
a disembodied not in any

00:02:14,050 --> 00:02:18,430
creepy voice so our code might look

00:02:17,290 --> 00:02:21,670
something like this we're gonna get a

00:02:18,430 --> 00:02:23,200
prediction from a from a weather service

00:02:21,670 --> 00:02:24,580
and we're gonna call it predict today's

00:02:23,200 --> 00:02:27,370
weather this thing is probably gonna

00:02:24,580 --> 00:02:29,800
talk to an HTTP API maybe more than one

00:02:27,370 --> 00:02:32,080
if it's got some some failback behaviors

00:02:29,800 --> 00:02:34,690
and then we're gonna have our house

00:02:32,080 --> 00:02:36,850
voice I can't call it a speaker because

00:02:34,690 --> 00:02:38,380
speaker means literally any device that

00:02:36,850 --> 00:02:41,830
turns electrical signals and just sound

00:02:38,380 --> 00:02:45,310
not just spoken words so that's annoying

00:02:41,830 --> 00:02:46,780
thank you English to say a a sentence

00:02:45,310 --> 00:02:47,950
for us and because prediction comes from

00:02:46,780 --> 00:02:50,470
our weather service we don't want to

00:02:47,950 --> 00:02:52,930
have it know how to turn into a spoken

00:02:50,470 --> 00:02:54,310
sentence by itself so we're gonna use an

00:02:52,930 --> 00:02:57,100
intermediate object that's gonna wrap

00:02:54,310 --> 00:02:58,540
that and I think you know speech is a

00:02:57,100 --> 00:02:59,950
decent home for this so this is gonna be

00:02:58,540 --> 00:03:01,090
today's weather speech and it's going to

00:02:59,950 --> 00:03:03,460
take our prediction and we're gonna call

00:03:01,090 --> 00:03:05,020
to us on it and this is pretty much your

00:03:03,460 --> 00:03:06,400
code but let's turn it to something that

00:03:05,020 --> 00:03:07,930
might look a little more realistic so if

00:03:06,400 --> 00:03:09,250
we're doing this in Ruby we're probably

00:03:07,930 --> 00:03:10,630
gonna be using a framework either an

00:03:09,250 --> 00:03:11,320
open source one or one of our own

00:03:10,630 --> 00:03:14,020
devising

00:03:11,320 --> 00:03:16,120
and that means inheriting from a base

00:03:14,020 --> 00:03:18,730
class and defining one or more methods

00:03:16,120 --> 00:03:20,170
yeah it's smart home action and perform

00:03:18,730 --> 00:03:22,840
these are not you know immensely

00:03:20,170 --> 00:03:24,250
inventive names but IMO framework based

00:03:22,840 --> 00:03:28,900
classes should probably be named boring

00:03:24,250 --> 00:03:32,290
things so the way we would use this

00:03:28,900 --> 00:03:33,760
assuming our smart home library has some

00:03:32,290 --> 00:03:35,530
kind of registration mechanism is we

00:03:33,760 --> 00:03:36,820
instantiate these Global's with you know

00:03:35,530 --> 00:03:38,800
we create our weather service with

00:03:36,820 --> 00:03:40,840
whether or not example comm we've heard

00:03:38,800 --> 00:03:42,790
a house voice with new and we can choose

00:03:40,840 --> 00:03:45,700
a voice actor isn't that great we're

00:03:42,790 --> 00:03:47,709
picking Nicholas Cage because honestly

00:03:45,700 --> 00:03:49,270
if I want something to get me excited

00:03:47,709 --> 00:03:52,060
about the day the antics of Nicholas

00:03:49,270 --> 00:03:53,709
Cage will definitely do that and as

00:03:52,060 --> 00:03:57,820
previously stated in the specifications

00:03:53,709 --> 00:03:58,870
we want creepiness of not at all so now

00:03:57,820 --> 00:04:00,850
we're going to tell our smart home to

00:03:58,870 --> 00:04:04,450
schedule at 6:15 that's a good time for

00:04:00,850 --> 00:04:05,739
Nick and we're gonna instantiate a

00:04:04,450 --> 00:04:08,610
describe today's weather object we're

00:04:05,739 --> 00:04:10,720
gonna call it new or perform on it okay

00:04:08,610 --> 00:04:13,989
so let's think about how we would test

00:04:10,720 --> 00:04:16,390
this we run into two problems

00:04:13,989 --> 00:04:18,940
immediately one talking to the Weather

00:04:16,390 --> 00:04:21,609
Service in in our test is going to be

00:04:18,940 --> 00:04:24,010
potentially either at worst it's going

00:04:21,609 --> 00:04:26,470
to be slow because the tests are because

00:04:24,010 --> 00:04:28,000
the requests are going to succeed and at

00:04:26,470 --> 00:04:30,790
worst it's going to make our

00:04:28,000 --> 00:04:32,050
test suite fail for reasons that have

00:04:30,790 --> 00:04:34,780
nothing to do with our code if those

00:04:32,050 --> 00:04:36,010
HTTP requests fail and I personally like

00:04:34,780 --> 00:04:38,530
to have a test suite that only fails

00:04:36,010 --> 00:04:43,030
when I have messed up not you know the

00:04:38,530 --> 00:04:47,170
the api's I depend on the house voice is

00:04:43,030 --> 00:04:48,610
is even worse we definitely do not want

00:04:47,170 --> 00:04:50,290
to use our actual house speaker system

00:04:48,610 --> 00:04:52,600
when running tests one that would be

00:04:50,290 --> 00:04:55,060
annoying to we might be listening to

00:04:52,600 --> 00:04:56,770
music or there might be other voice

00:04:55,060 --> 00:04:59,230
actions that we've that we've already

00:04:56,770 --> 00:05:00,310
registered like things that tell us if

00:04:59,230 --> 00:05:03,880
someone's at the door or that our

00:05:00,310 --> 00:05:06,190
laundry is ready and it gets it gets

00:05:03,880 --> 00:05:11,050
worse if house voice don't say is a

00:05:06,190 --> 00:05:14,170
blocking call speech is slow compared to

00:05:11,050 --> 00:05:16,570
for a computer so we would slow down our

00:05:14,170 --> 00:05:18,670
test suite even worse than the HTTP

00:05:16,570 --> 00:05:20,560
requests that hit our weather service

00:05:18,670 --> 00:05:22,900
and if house voice does say is

00:05:20,560 --> 00:05:24,640
non-blocking then it would queue up all

00:05:22,900 --> 00:05:25,960
our voice samples all at once and they

00:05:24,640 --> 00:05:28,150
would play all at once and it would be

00:05:25,960 --> 00:05:31,419
cacophonous and loud and terrible so

00:05:28,150 --> 00:05:33,640
we're gonna try to not use either the

00:05:31,419 --> 00:05:34,780
real internet or are real speakers while

00:05:33,640 --> 00:05:36,580
testing this so how would we go about

00:05:34,780 --> 00:05:37,990
doing this well there's two ways to go

00:05:36,580 --> 00:05:39,010
about doing this one of those is partial

00:05:37,990 --> 00:05:40,360
mocking which is mentioned we're not

00:05:39,010 --> 00:05:41,980
going to be talking about until later

00:05:40,360 --> 00:05:46,060
and the second is dependency injection

00:05:41,980 --> 00:05:48,010
welcome to the talk so to inject our

00:05:46,060 --> 00:05:49,510
dependencies what we're gonna do is

00:05:48,010 --> 00:05:52,960
we're gonna create a constructor for

00:05:49,510 --> 00:05:54,100
this for this class we're gonna we're

00:05:52,960 --> 00:05:55,000
going to give it some name parameters

00:05:54,100 --> 00:05:56,590
we're gonna give it another name for

00:05:55,000 --> 00:06:00,479
ammeter and then we're gonna sign those

00:05:56,590 --> 00:06:03,280
two two instance variables pretty simple

00:06:00,479 --> 00:06:05,740
to do and then we're going to turn our

00:06:03,280 --> 00:06:07,540
Global's in our code into those instance

00:06:05,740 --> 00:06:09,820
variables pretty cut-and-dried not not

00:06:07,540 --> 00:06:11,080
very complicated at all and then because

00:06:09,820 --> 00:06:12,550
it's slide code and I need always real

00:06:11,080 --> 00:06:15,310
estate possible we're gonna collapse our

00:06:12,550 --> 00:06:17,380
constructor into a single line no

00:06:15,310 --> 00:06:19,270
information has been lost because it

00:06:17,380 --> 00:06:21,310
looks a lot like boilerplate and all the

00:06:19,270 --> 00:06:24,640
the names of our dependencies are in the

00:06:21,310 --> 00:06:28,270
signature anyway now we just need to fix

00:06:24,640 --> 00:06:29,800
our registration code to - to work - to

00:06:28,270 --> 00:06:32,410
work with the new new code we've written

00:06:29,800 --> 00:06:35,470
so we're gonna you know wrap or we're

00:06:32,410 --> 00:06:36,910
gonna move our block up there we move

00:06:35,470 --> 00:06:39,360
that around we're gonna make them local

00:06:36,910 --> 00:06:42,280
variables and we're going to inject them

00:06:39,360 --> 00:06:45,070
okay so now

00:06:42,280 --> 00:06:49,240
is what this would look like and we can

00:06:45,070 --> 00:06:50,889
get started testing it so we want to

00:06:49,240 --> 00:06:52,630
write our first test like it tells me

00:06:50,889 --> 00:06:54,370
today's weather prediction we're gonna

00:06:52,630 --> 00:06:55,900
create an instance double of our weather

00:06:54,370 --> 00:06:58,060
service and and it's double of our house

00:06:55,900 --> 00:06:59,530
voice for those of you not familiar with

00:06:58,060 --> 00:07:01,780
the instance double method it generates

00:06:59,530 --> 00:07:03,400
an r-spec verifying double and our spec

00:07:01,780 --> 00:07:05,980
verifying doubles are great and play an

00:07:03,400 --> 00:07:07,060
important role in our tests one of them

00:07:05,980 --> 00:07:08,560
important one it's one of those

00:07:07,060 --> 00:07:10,090
important things to keep track of when

00:07:08,560 --> 00:07:13,360
testing dependency injector injected

00:07:10,090 --> 00:07:15,550
code is to make sure that the not real

00:07:13,360 --> 00:07:17,110
life objects that were instantiate that

00:07:15,550 --> 00:07:19,930
we're injecting in place of our real

00:07:17,110 --> 00:07:21,940
life objects behave the same way so that

00:07:19,930 --> 00:07:23,410
means we want them to have we don't they

00:07:21,940 --> 00:07:24,430
don't need to have all of the methods or

00:07:23,410 --> 00:07:26,620
the real thing but they need to have the

00:07:24,430 --> 00:07:28,750
ones we're going to call and they need

00:07:26,620 --> 00:07:30,730
to they and those methods need to have

00:07:28,750 --> 00:07:32,169
the same argument signature or the same

00:07:30,730 --> 00:07:34,870
method signature they need to have the

00:07:32,169 --> 00:07:37,960
same return type and if possible they

00:07:34,870 --> 00:07:39,550
should raise the same exceptions if you

00:07:37,960 --> 00:07:40,780
don't you might up with a test that

00:07:39,550 --> 00:07:43,870
repeatedly fails with a node method

00:07:40,780 --> 00:07:46,419
error and or worse you could have a test

00:07:43,870 --> 00:07:47,950
that passes for the wrong reasons if we

00:07:46,419 --> 00:07:49,240
were working in a language like Java we

00:07:47,950 --> 00:07:50,650
would use interfaces and have the

00:07:49,240 --> 00:07:52,270
compiler take care of verify and all of

00:07:50,650 --> 00:07:54,030
that for us well we don't have

00:07:52,270 --> 00:07:56,919
interfaces or a compiler in Ruby

00:07:54,030 --> 00:07:59,200
fortunately these doubles are gonna have

00:07:56,919 --> 00:08:01,180
our back with the next best thing right

00:07:59,200 --> 00:08:05,640
now this code will not do anything I

00:08:01,180 --> 00:08:07,720
mean that literally if we if I if I call

00:08:05,640 --> 00:08:08,830
predict A's weather on our weather

00:08:07,720 --> 00:08:10,419
service double even though it's a

00:08:08,830 --> 00:08:11,830
doubling the weather service class it

00:08:10,419 --> 00:08:13,600
will give me a no method error so if I

00:08:11,830 --> 00:08:15,570
want if I want this test to do anything

00:08:13,600 --> 00:08:18,010
we have to start we have to start

00:08:15,570 --> 00:08:19,900
configuring our doubles so first I'm

00:08:18,010 --> 00:08:21,820
gonna allow the weather service object

00:08:19,900 --> 00:08:23,530
to receive then predict today's weather

00:08:21,820 --> 00:08:27,010
method just like it does in in our code

00:08:23,530 --> 00:08:29,680
above and I want it to return you know

00:08:27,010 --> 00:08:31,210
some data in this case this is very

00:08:29,680 --> 00:08:33,789
simplified it would probably also you

00:08:31,210 --> 00:08:34,960
know give me a precipitation percentages

00:08:33,789 --> 00:08:37,919
and a bunch of other things but against

00:08:34,960 --> 00:08:37,919
live code and I need the real estate

00:08:38,070 --> 00:08:42,400
this allowance is very cool but it still

00:08:41,110 --> 00:08:45,670
does not create a test because this

00:08:42,400 --> 00:08:47,620
doesn't make assertions to do that I

00:08:45,670 --> 00:08:49,630
want I'm going to expect our house voice

00:08:47,620 --> 00:08:53,370
to receive say just like it does in the

00:08:49,630 --> 00:08:55,930
code and even better I can I can make it

00:08:53,370 --> 00:08:59,370
only pass our tests

00:08:55,930 --> 00:09:02,290
if it receives the vertices of fragment

00:08:59,370 --> 00:09:03,760
matching the exact string that I'm just

00:09:02,290 --> 00:09:06,070
going to assume because slide code our

00:09:03,760 --> 00:09:08,950
today's weather speech to s method it

00:09:06,070 --> 00:09:10,870
returns to us so now now this test would

00:09:08,950 --> 00:09:14,020
fail because nothing in it is calling

00:09:10,870 --> 00:09:15,430
the perform method in our class so we're

00:09:14,020 --> 00:09:16,690
going to create a describe today's

00:09:15,430 --> 00:09:17,770
weather object we're gonna give it our

00:09:16,690 --> 00:09:20,260
weather service we're gonna give our

00:09:17,770 --> 00:09:23,680
house boys thanks Nick and we're gonna

00:09:20,260 --> 00:09:25,000
call perform on it this test will now

00:09:23,680 --> 00:09:28,150
satisfy the method expectation we've

00:09:25,000 --> 00:09:29,500
placed on our house voice double so this

00:09:28,150 --> 00:09:31,780
is this is the main this is one of the

00:09:29,500 --> 00:09:33,160
main benefits of of dependency injection

00:09:31,780 --> 00:09:35,020
it allows us to test the logic and

00:09:33,160 --> 00:09:36,810
interactions of our code with precise

00:09:35,020 --> 00:09:39,700
control over what side effects if any

00:09:36,810 --> 00:09:41,680
will will happen during our tests it's

00:09:39,700 --> 00:09:43,990
also very straightforward to use we have

00:09:41,680 --> 00:09:45,610
you know the the actor ranges certain

00:09:43,990 --> 00:09:46,720
pattern we have you know we're gonna set

00:09:45,610 --> 00:09:49,660
up our doubles we're gonna configure

00:09:46,720 --> 00:09:51,850
them and then we're gonna call our code

00:09:49,660 --> 00:09:54,610
and pray that it works in this case it

00:09:51,850 --> 00:09:56,830
does so it couldn't be more

00:09:54,610 --> 00:10:00,970
straightforward but there is more let's

00:09:56,830 --> 00:10:04,750
talk about failure so we don't often

00:10:00,970 --> 00:10:06,910
design for failure that well we don't

00:10:04,750 --> 00:10:09,670
often consider it a core component of

00:10:06,910 --> 00:10:10,390
user experience but we're wrong when we

00:10:09,670 --> 00:10:12,280
do that

00:10:10,390 --> 00:10:14,260
when a user encounters a failure system

00:10:12,280 --> 00:10:17,470
a failure state of your system when they

00:10:14,260 --> 00:10:19,090
are on a sad path if you will that user

00:10:17,470 --> 00:10:21,040
is that they're most confused and

00:10:19,090 --> 00:10:22,300
they're at least empowered and because

00:10:21,040 --> 00:10:25,150
of that it's crucial that as developers

00:10:22,300 --> 00:10:29,410
we do two things we one communicate to

00:10:25,150 --> 00:10:30,760
them what has happened you know our our

00:10:29,410 --> 00:10:33,070
website is receiving an unusually high

00:10:30,760 --> 00:10:34,960
volume of traffic right now we can also

00:10:33,070 --> 00:10:36,400
we can also tell them what if anything

00:10:34,960 --> 00:10:40,030
they can do about it and what if

00:10:36,400 --> 00:10:41,710
anything we're doing about it we can

00:10:40,030 --> 00:10:43,360
tell them you know maybe come back in

00:10:41,710 --> 00:10:46,450
two minutes and we're looking into the

00:10:43,360 --> 00:10:49,750
problem the second thing we need to be

00:10:46,450 --> 00:10:51,370
doing is is once we've thought about how

00:10:49,750 --> 00:10:53,170
we want to communicate that a failure

00:10:51,370 --> 00:10:54,850
has occurred to the user that is now

00:10:53,170 --> 00:10:57,160
part of the specification of our system

00:10:54,850 --> 00:10:59,530
it is it is part of what we think of is

00:10:57,160 --> 00:11:04,330
the expected behavior of our system so

00:10:59,530 --> 00:11:06,760
we should test that so let's so in our

00:11:04,330 --> 00:11:09,220
in our code which doesn't run anywhere

00:11:06,760 --> 00:11:11,290
because it doesn't exist

00:11:09,220 --> 00:11:14,350
failure is not has like no consequences

00:11:11,290 --> 00:11:15,970
whatsoever however we work on things

00:11:14,350 --> 00:11:17,410
with actual users that have actual

00:11:15,970 --> 00:11:20,680
consequences when things fail so let's

00:11:17,410 --> 00:11:22,600
let's let's go into that here we're

00:11:20,680 --> 00:11:24,160
gonna we're going to consider the what

00:11:22,600 --> 00:11:26,139
happens if our weather service can't get

00:11:24,160 --> 00:11:28,209
a weather prediction we're gonna pretend

00:11:26,139 --> 00:11:31,240
that are that are that our weather

00:11:28,209 --> 00:11:33,100
service will raise a no press QA no

00:11:31,240 --> 00:11:35,470
prediction or will raise a no prediction

00:11:33,100 --> 00:11:37,959
available error if it cannot if it

00:11:35,470 --> 00:11:39,399
cannot talk to its website or if it gets

00:11:37,959 --> 00:11:41,769
a timeout or you know one of a variety

00:11:39,399 --> 00:11:44,379
of things can happen in this case we

00:11:41,769 --> 00:11:49,470
would like we would like Nick to to read

00:11:44,379 --> 00:11:52,540
a you know default message to us and yes

00:11:49,470 --> 00:11:54,399
we could make a 2001 Space Odyssey joke

00:11:52,540 --> 00:11:55,540
here but as previously mentioned we want

00:11:54,399 --> 00:11:58,569
the voice to not be creepy

00:11:55,540 --> 00:12:00,430
so there will be no references to any

00:11:58,569 --> 00:12:05,529
Dave's or inability to perform things on

00:12:00,430 --> 00:12:06,910
Dave's behalf so to test this we do

00:12:05,529 --> 00:12:08,410
pretty much the same thing we're gonna

00:12:06,910 --> 00:12:09,339
we're gonna we're gonna test that it

00:12:08,410 --> 00:12:11,579
tells me you can't get a weather

00:12:09,339 --> 00:12:16,000
prediction we're gonna collapse the

00:12:11,579 --> 00:12:17,589
instant the initializer again and we're

00:12:16,000 --> 00:12:19,839
going to make our weather service we're

00:12:17,589 --> 00:12:20,920
gonna make our house voice we're going

00:12:19,839 --> 00:12:22,449
to allow the weather service to receive

00:12:20,920 --> 00:12:23,829
predict today's weather just like before

00:12:22,449 --> 00:12:24,910
but in this case we don't want it to

00:12:23,829 --> 00:12:26,470
return a thing we want it to raise a

00:12:24,910 --> 00:12:28,540
thing so we're gonna have it raising no

00:12:26,470 --> 00:12:31,089
prediction available exception just like

00:12:28,540 --> 00:12:32,319
our code does the same as before we're

00:12:31,089 --> 00:12:35,139
going to expect our house voice to

00:12:32,319 --> 00:12:36,610
recieve say with a fragment containing

00:12:35,139 --> 00:12:41,500
the words in order with spaces between

00:12:36,610 --> 00:12:43,329
them unable to predict this is this is

00:12:41,500 --> 00:12:46,059
not just a simplification for slide code

00:12:43,329 --> 00:12:48,100
I when I when I do this in real life I

00:12:46,059 --> 00:12:49,839
frequently use reg X's to match against

00:12:48,100 --> 00:12:51,550
strings because if I just match the

00:12:49,839 --> 00:12:54,459
entire string any time I change the

00:12:51,550 --> 00:12:55,750
string to because our designer has told

00:12:54,459 --> 00:12:58,360
me hey we should adjust the tone like

00:12:55,750 --> 00:12:59,920
this which is a good thing to do I don't

00:12:58,360 --> 00:13:02,079
have to redo my whole test so I'll

00:12:59,920 --> 00:13:04,480
create a red X that matches what in my

00:13:02,079 --> 00:13:05,889
mind are the important bits and right

00:13:04,480 --> 00:13:09,189
here the important bits are unable to

00:13:05,889 --> 00:13:10,389
predict and then just like before we're

00:13:09,189 --> 00:13:11,529
gonna call describe we're gonna

00:13:10,389 --> 00:13:12,610
essentially to describe today's weather

00:13:11,529 --> 00:13:15,069
object we're gonna pass it our

00:13:12,610 --> 00:13:19,420
dependencies and we are going to perform

00:13:15,069 --> 00:13:21,639
and the only difference between this

00:13:19,420 --> 00:13:22,610
test and the test before it are these

00:13:21,639 --> 00:13:27,560
bits

00:13:22,610 --> 00:13:29,150
everything else is the same so not only

00:13:27,560 --> 00:13:31,070
is dependency injection a great way to

00:13:29,150 --> 00:13:31,970
control to test the logic and

00:13:31,070 --> 00:13:33,830
interaction of our code while

00:13:31,970 --> 00:13:36,320
controlling the side-effects it's also

00:13:33,830 --> 00:13:38,360
just as straightforward as testing to

00:13:36,320 --> 00:13:41,690
test sad paths as it is to test happy

00:13:38,360 --> 00:13:44,510
path so if we if we want to start

00:13:41,690 --> 00:13:45,560
designing our our failure behaviors of

00:13:44,510 --> 00:13:46,910
our system to provide a better user

00:13:45,560 --> 00:13:51,620
experience to kind of see injections

00:13:46,910 --> 00:13:54,260
really the way to go to do so I'm gonna

00:13:51,620 --> 00:13:55,250
answer this question now because I'm

00:13:54,260 --> 00:13:57,380
sure it's occurred to a bunch of you

00:13:55,250 --> 00:13:59,390
that we could just partially mock all of

00:13:57,380 --> 00:14:01,820
this stuff so let's let's look at what

00:13:59,390 --> 00:14:03,650
that would look like so here's the code

00:14:01,820 --> 00:14:05,270
here's our original code with Global's

00:14:03,650 --> 00:14:07,870
and I've updated it to include the

00:14:05,270 --> 00:14:09,950
failure behavior we just added and

00:14:07,870 --> 00:14:11,720
here's how we would test it we would

00:14:09,950 --> 00:14:13,250
allow our weather service to receive

00:14:11,720 --> 00:14:14,360
predict today's weather we don't need to

00:14:13,250 --> 00:14:16,400
setup test doubles because they already

00:14:14,360 --> 00:14:19,430
exist they're Global's but we do need to

00:14:16,400 --> 00:14:22,850
change the way they work we want it to

00:14:19,430 --> 00:14:26,510
receive a no prediction available and we

00:14:22,850 --> 00:14:28,040
want expect house to receive say with

00:14:26,510 --> 00:14:29,630
unable to predict just like before now

00:14:28,040 --> 00:14:32,980
these are not instance levels our spec

00:14:29,630 --> 00:14:35,660
but our spec is sufficiently powerful to

00:14:32,980 --> 00:14:39,680
just override existing objects that it

00:14:35,660 --> 00:14:41,270
doesn't control and you know just it's

00:14:39,680 --> 00:14:43,040
we call it partial mocking but really

00:14:41,270 --> 00:14:46,310
it's monkey patching but only in testing

00:14:43,040 --> 00:14:48,170
so it's fine right so that's what we're

00:14:46,310 --> 00:14:49,520
doing and then just like sorry just like

00:14:48,170 --> 00:14:51,500
before we're gonna have two skies

00:14:49,520 --> 00:14:53,030
today's weather new dot perform now we

00:14:51,500 --> 00:14:54,860
can absolutely test this piece of code

00:14:53,030 --> 00:14:56,030
roughly the same way that we did with

00:14:54,860 --> 00:14:59,150
the dependency injected piece of code

00:14:56,030 --> 00:15:00,920
this is less code than before so the

00:14:59,150 --> 00:15:02,150
question isn't this is the question why

00:15:00,920 --> 00:15:03,560
should I use dependency injection sort

00:15:02,150 --> 00:15:05,570
of partial mocking isn't a question of

00:15:03,560 --> 00:15:07,190
testing techniques the question actually

00:15:05,570 --> 00:15:11,200
being asked is why should I change my

00:15:07,190 --> 00:15:11,200
code to make injecting dependencies easy

00:15:12,160 --> 00:15:16,910
so the reason for that is like I said

00:15:15,440 --> 00:15:18,500
the difference between these code isn't

00:15:16,910 --> 00:15:19,850
the differences between these pieces of

00:15:18,500 --> 00:15:21,590
code isn't the testing techniques the

00:15:19,850 --> 00:15:22,970
difference is that's the entire

00:15:21,590 --> 00:15:25,790
difference one of these has an

00:15:22,970 --> 00:15:27,530
initializer and one of them doesn't one

00:15:25,790 --> 00:15:28,760
of these has an explicit listing of all

00:15:27,530 --> 00:15:31,010
its dependencies in one convenient

00:15:28,760 --> 00:15:33,620
location that anyone can read and one of

00:15:31,010 --> 00:15:35,330
them doesn't so while there is more code

00:15:33,620 --> 00:15:35,760
in the dependency injected version and

00:15:35,330 --> 00:15:37,320
that code is

00:15:35,760 --> 00:15:38,970
easy to dismiss this boilerplate it

00:15:37,320 --> 00:15:40,560
serves a critical function that more

00:15:38,970 --> 00:15:42,540
than make up that more than makes up for

00:15:40,560 --> 00:15:45,060
the extra line count it provides us

00:15:42,540 --> 00:15:46,320
information being able to add a glance

00:15:45,060 --> 00:15:48,030
know what the dependencies of a given

00:15:46,320 --> 00:15:49,650
object are is exceedingly powerful in

00:15:48,030 --> 00:15:51,330
software development it helps you answer

00:15:49,650 --> 00:15:52,920
questions like is this code doing too

00:15:51,330 --> 00:15:54,630
much which we normally answer with you

00:15:52,920 --> 00:15:55,890
know a gut reaction if we're in a large

00:15:54,630 --> 00:15:57,240
code base we think well this thing does

00:15:55,890 --> 00:15:58,410
that and it does the other thing it

00:15:57,240 --> 00:15:59,640
talks to people maps and it talks to

00:15:58,410 --> 00:16:01,290
this coupon API and it does this fourth

00:15:59,640 --> 00:16:04,010
thing but it also makes our robot do a

00:16:01,290 --> 00:16:05,730
thing I don't know why just does and

00:16:04,010 --> 00:16:08,970
we're probably gonna miss three

00:16:05,730 --> 00:16:13,380
dependencies if we have a list of them

00:16:08,970 --> 00:16:14,760
it's real hard to do that we can also

00:16:13,380 --> 00:16:17,010
answer the question how can this thing

00:16:14,760 --> 00:16:18,570
fail which is previously mentioned is an

00:16:17,010 --> 00:16:21,870
important a part is an important part of

00:16:18,570 --> 00:16:23,640
having a good user experience in large

00:16:21,870 --> 00:16:25,350
code base in large code bases you can

00:16:23,640 --> 00:16:26,850
probably eventually get to is this is

00:16:25,350 --> 00:16:28,290
this is this piece of code doing too

00:16:26,850 --> 00:16:29,250
much once you've gotten past like six or

00:16:28,290 --> 00:16:33,600
seven dependencies the answer is

00:16:29,250 --> 00:16:35,490
probably yes but it's very hard to

00:16:33,600 --> 00:16:37,380
answer how are what are all the ways

00:16:35,490 --> 00:16:39,960
this thing can fail unless I know all

00:16:37,380 --> 00:16:41,730
the dependencies and in large code bases

00:16:39,960 --> 00:16:45,390
that's really hard to actually get an

00:16:41,730 --> 00:16:47,340
accurate read of sometimes with our

00:16:45,390 --> 00:16:50,100
initializer here we can simply look at

00:16:47,340 --> 00:16:52,260
it and know what our dependencies are it

00:16:50,100 --> 00:16:54,060
helps on onboard developers faster by

00:16:52,260 --> 00:16:55,140
acting as an information display so they

00:16:54,060 --> 00:16:56,400
don't have to hunt through code to

00:16:55,140 --> 00:16:58,650
figure out what all the responsibilities

00:16:56,400 --> 00:16:59,820
of an object are and quite frequently

00:16:58,650 --> 00:17:03,330
the responsibilities of an object

00:16:59,820 --> 00:17:04,949
closely mirror its dependencies it also

00:17:03,330 --> 00:17:06,390
prevents you from being surprised by

00:17:04,949 --> 00:17:08,010
dependencies that crop up in the middle

00:17:06,390 --> 00:17:09,959
of testing you know that feeling when

00:17:08,010 --> 00:17:11,040
you're testing something testing a large

00:17:09,959 --> 00:17:12,240
piece of code you think you've stubbed

00:17:11,040 --> 00:17:14,100
or mocked or faked all of the

00:17:12,240 --> 00:17:15,540
dependencies and you're pretty sure your

00:17:14,100 --> 00:17:18,480
test is actually going to run not pass

00:17:15,540 --> 00:17:20,640
just run in full this test this this

00:17:18,480 --> 00:17:24,030
test run yeah that's a terrible feeling

00:17:20,640 --> 00:17:25,050
and and having and it's because we don't

00:17:24,030 --> 00:17:26,790
have an explicit listing of our

00:17:25,050 --> 00:17:30,090
dependencies if we do we're no longer

00:17:26,790 --> 00:17:31,260
surprised by our dependencies even worse

00:17:30,090 --> 00:17:33,660
being surprised by our dependencies

00:17:31,260 --> 00:17:35,730
keeps the knowledge of how to test a

00:17:33,660 --> 00:17:37,260
thing or what what all that code does in

00:17:35,730 --> 00:17:38,550
one person's head like if you have a

00:17:37,260 --> 00:17:39,660
large code base and dependencies are all

00:17:38,550 --> 00:17:42,750
over the place you will eventually get

00:17:39,660 --> 00:17:44,130
that code tested like you're paid money

00:17:42,750 --> 00:17:45,270
your job depends on completing that

00:17:44,130 --> 00:17:47,520
piece of work you're gonna find a way to

00:17:45,270 --> 00:17:49,350
get it done but once you've done that

00:17:47,520 --> 00:17:51,240
that knowledge is now just

00:17:49,350 --> 00:17:52,500
your head or your in your pairs head if

00:17:51,240 --> 00:17:54,390
you're if you're doing pair programming

00:17:52,500 --> 00:17:55,860
with dependency injection that knowledge

00:17:54,390 --> 00:17:59,100
is always present in the code where

00:17:55,860 --> 00:18:00,210
anyone can look at and find it simply

00:17:59,100 --> 00:18:02,100
the reason to use dependency injection

00:18:00,210 --> 00:18:03,809
instead of partial mocking is that di

00:18:02,100 --> 00:18:07,020
enables you to know your code in a way

00:18:03,809 --> 00:18:09,720
that partial mocking doesn't so that

00:18:07,020 --> 00:18:11,000
sounds great if a little apocalyptic for

00:18:09,720 --> 00:18:13,950
those of us who aren't using it already

00:18:11,000 --> 00:18:15,299
but how do I do this in rails I know

00:18:13,950 --> 00:18:19,710
we're at Ruby conflict how do I do this

00:18:15,299 --> 00:18:20,880
in rails a disclaimer before we begin if

00:18:19,710 --> 00:18:22,740
any of you were hoping I'd show you some

00:18:20,880 --> 00:18:24,000
amazing way to inject a stub of active

00:18:22,740 --> 00:18:25,440
records so you could test rails code

00:18:24,000 --> 00:18:29,309
without talking to the database that's

00:18:25,440 --> 00:18:31,289
I'm really sorry that ship has already

00:18:29,309 --> 00:18:32,820
sailed it probably wouldn't take you too

00:18:31,289 --> 00:18:34,919
much time to create a stand-in that let

00:18:32,820 --> 00:18:37,440
you create that you find create save

00:18:34,919 --> 00:18:38,669
update delete records but as soon as you

00:18:37,440 --> 00:18:40,080
want to test any transactional behavior

00:18:38,669 --> 00:18:41,730
or any of the more complicated

00:18:40,080 --> 00:18:43,080
concurrency control mechanisms and when

00:18:41,730 --> 00:18:44,490
I say the more complicated concurrency

00:18:43,080 --> 00:18:46,320
control mechanisms I mean all of the

00:18:44,490 --> 00:18:48,179
concurrency control mechanisms in the

00:18:46,320 --> 00:18:49,740
sequel specification you've essentially

00:18:48,179 --> 00:18:51,450
you're essentially committed to building

00:18:49,740 --> 00:18:52,590
an in-memory database we already have

00:18:51,450 --> 00:18:54,480
one of those it's called a sequel light

00:18:52,590 --> 00:18:56,490
and it doesn't implement all the in all

00:18:54,480 --> 00:18:57,780
the concurrency control behaviors of the

00:18:56,490 --> 00:18:58,980
sequel specification so if you want to

00:18:57,780 --> 00:19:00,030
spend more engineering time than the

00:18:58,980 --> 00:19:03,360
maintainer is that sequel light have

00:19:00,030 --> 00:19:05,460
feel free if you do I will use it but

00:19:03,360 --> 00:19:07,370
but I can't personally justify that

00:19:05,460 --> 00:19:09,690
engineering effort to myself or my team

00:19:07,370 --> 00:19:11,280
and it's much and it's much the same way

00:19:09,690 --> 00:19:13,230
with the components directly provided by

00:19:11,280 --> 00:19:15,090
rails itself one of the things that you

00:19:13,230 --> 00:19:16,350
may have noticed is that in order to to

00:19:15,090 --> 00:19:18,450
use dependency injection we have to

00:19:16,350 --> 00:19:19,710
control object instantiation so a

00:19:18,450 --> 00:19:20,940
hundred percent true but I said I wasn't

00:19:19,710 --> 00:19:22,590
going to talk about dependency injection

00:19:20,940 --> 00:19:26,070
frameworks so we have to control object

00:19:22,590 --> 00:19:27,870
instantiation rails doesn't really let

00:19:26,070 --> 00:19:30,330
us control object instantiation at all

00:19:27,870 --> 00:19:31,620
except except with active active record

00:19:30,330 --> 00:19:33,150
and with active record all we're doing

00:19:31,620 --> 00:19:34,950
is providing data we're not providing a

00:19:33,150 --> 00:19:36,990
new database connection for for each

00:19:34,950 --> 00:19:38,630
user object we create so that doesn't

00:19:36,990 --> 00:19:40,770
really let us substitute dependencies

00:19:38,630 --> 00:19:42,179
fortunately we can use dependency

00:19:40,770 --> 00:19:44,039
injection with surface objects or

00:19:42,179 --> 00:19:45,630
interactors or you know whatever variant

00:19:44,039 --> 00:19:48,030
whatever you want to call the variant

00:19:45,630 --> 00:19:49,140
you're using we control the creation of

00:19:48,030 --> 00:19:50,820
those objects so we can inject your own

00:19:49,140 --> 00:19:52,799
dependencies in both real life and in

00:19:50,820 --> 00:19:56,039
tests here's an example of what our

00:19:52,799 --> 00:19:58,740
weather prediction thing would look like

00:19:56,039 --> 00:20:02,700
if we used it in rails obviously you

00:19:58,740 --> 00:20:03,180
know Nic Cage doesn't scale much as he

00:20:02,700 --> 00:20:06,750
tried

00:20:03,180 --> 00:20:08,190
when he needed to pay back the IRS so

00:20:06,750 --> 00:20:09,570
we're gonna we're gonna email our

00:20:08,190 --> 00:20:12,000
weather predictions instead of having

00:20:09,570 --> 00:20:15,570
instead of having Olmec read read them

00:20:12,000 --> 00:20:18,000
out yeah I wanted to see you know the

00:20:15,570 --> 00:20:21,030
the audio API is too but that's not this

00:20:18,000 --> 00:20:22,470
talk so like before we're gonna have an

00:20:21,030 --> 00:20:24,000
initializer with our weather service and

00:20:22,470 --> 00:20:26,220
a user because we want to email a

00:20:24,000 --> 00:20:28,410
specific user the weather service maybe

00:20:26,220 --> 00:20:30,960
our user is Nicolas Cage that'd be cool

00:20:28,410 --> 00:20:32,370
so we're gonna assign our we're gonna

00:20:30,960 --> 00:20:34,500
assign these two instance variables

00:20:32,370 --> 00:20:35,490
we're gonna create a call method just

00:20:34,500 --> 00:20:36,720
like before we're gonna have our weather

00:20:35,490 --> 00:20:39,050
service call predict today's weather

00:20:36,720 --> 00:20:41,160
we're gonna have a weather mailer new

00:20:39,050 --> 00:20:42,390
we're gonna give it the user we're gonna

00:20:41,160 --> 00:20:45,030
give it the prediction and we're gonna

00:20:42,390 --> 00:20:47,010
tell it to deliver a mail later this is

00:20:45,030 --> 00:20:50,910
pretty simple and the way we test this

00:20:47,010 --> 00:20:53,190
and compressing the initializer we're

00:20:50,910 --> 00:20:55,260
gonna say it gets a weather prediction

00:20:53,190 --> 00:20:56,760
and emails a user we're gonna we're

00:20:55,260 --> 00:20:58,710
gonna we're gonna build a user here we

00:20:56,760 --> 00:20:59,940
don't need to make an instance double we

00:20:58,710 --> 00:21:01,110
could pull one out of the database or if

00:20:59,940 --> 00:21:03,210
we never want to touch the database at

00:21:01,110 --> 00:21:06,510
all we could just build one the doctor

00:21:03,210 --> 00:21:07,650
thoughts are meant to mean data we're

00:21:06,510 --> 00:21:09,060
gonna create an instance double of our

00:21:07,650 --> 00:21:10,290
weather service just like before

00:21:09,060 --> 00:21:11,640
we're gonna allow our weather service to

00:21:10,290 --> 00:21:12,840
receive predict today's weather and

00:21:11,640 --> 00:21:15,210
return hey it's our data from the

00:21:12,840 --> 00:21:19,110
beginning of the talk look at that and

00:21:15,210 --> 00:21:21,270
then we are going to in instantiate our

00:21:19,110 --> 00:21:22,650
mail weather prediction service not new

00:21:21,270 --> 00:21:24,930
with our weather service which is a

00:21:22,650 --> 00:21:27,120
different kind of service and our user

00:21:24,930 --> 00:21:28,860
and we're gonna call it and then we're

00:21:27,120 --> 00:21:31,970
gonna do one of the many ways you can

00:21:28,860 --> 00:21:36,510
test that a mail was delivered in rails

00:21:31,970 --> 00:21:38,070
so again while we can't well we can't

00:21:36,510 --> 00:21:40,380
use dependency injection throughout the

00:21:38,070 --> 00:21:43,520
entirety of our rails code what we can

00:21:40,380 --> 00:21:45,900
do is create a code that is a separate

00:21:43,520 --> 00:21:49,140
from our from our from our standard

00:21:45,900 --> 00:21:52,170
rails from the standard nouns rails

00:21:49,140 --> 00:21:54,990
provide us that provides us and and

00:21:52,170 --> 00:21:57,540
control those ourselves in controllers

00:21:54,990 --> 00:22:04,770
or models and use dependency injection

00:21:57,540 --> 00:22:06,960
on them so to recap i've demonstrated

00:22:04,770 --> 00:22:08,520
what simple but what what dependency

00:22:06,960 --> 00:22:09,690
injection looks like and how it's pretty

00:22:08,520 --> 00:22:11,160
straightforward I've explained to

00:22:09,690 --> 00:22:12,870
benefits and what its advantages are

00:22:11,160 --> 00:22:14,100
over partial mocking I've shown what

00:22:12,870 --> 00:22:16,080
using dependency injection in a rails

00:22:14,100 --> 00:22:18,299
app life might look like

00:22:16,080 --> 00:22:20,220
now I might normally ask what have we

00:22:18,299 --> 00:22:21,870
learned but I have no idea what y'all

00:22:20,220 --> 00:22:23,820
learned for some of you this is all been

00:22:21,870 --> 00:22:24,690
mostly new for some of you mostly not in

00:22:23,820 --> 00:22:25,980
heck if you're one of the people had

00:22:24,690 --> 00:22:27,240
demoed this talk to you not only did you

00:22:25,980 --> 00:22:29,490
learn nothing you also knew all the

00:22:27,240 --> 00:22:31,019
jokes and what I was gonna say so let's

00:22:29,490 --> 00:22:32,130
talk about instead of what what we've

00:22:31,019 --> 00:22:33,960
learned what I think you should take

00:22:32,130 --> 00:22:35,159
away from this talk since even if you

00:22:33,960 --> 00:22:38,250
didn't learn a thing that's still a

00:22:35,159 --> 00:22:40,500
relevant question I hope that you take

00:22:38,250 --> 00:22:42,870
away three things from this talk one sad

00:22:40,500 --> 00:22:44,429
paths are part of your UX they're not a

00:22:42,870 --> 00:22:47,940
thing you can ignore if you want a truly

00:22:44,429 --> 00:22:51,110
great user experience and as developers

00:22:47,940 --> 00:22:53,279
we once we have that failure behavior

00:22:51,110 --> 00:22:56,490
thought about and designed and specified

00:22:53,279 --> 00:22:58,289
we should be testing it second thing

00:22:56,490 --> 00:23:00,690
explicit dependencies help you know your

00:22:58,289 --> 00:23:03,870
code they are invaluable in in code

00:23:00,690 --> 00:23:06,149
bases small and large they let you they

00:23:03,870 --> 00:23:08,100
let you test the failure behavior that

00:23:06,149 --> 00:23:10,649
we just talked about in the first

00:23:08,100 --> 00:23:12,029
takeaway they help on board new

00:23:10,649 --> 00:23:14,100
developers they help reduce confusion

00:23:12,029 --> 00:23:16,830
and surprise and frustration throughout

00:23:14,100 --> 00:23:20,820
your codebase they are a they are a

00:23:16,830 --> 00:23:24,360
unalloyed good thing second or third

00:23:20,820 --> 00:23:26,250
second second dependency injection is

00:23:24,360 --> 00:23:27,990
possible and useful and rails you this

00:23:26,250 --> 00:23:29,639
is not just a ruby testing technique

00:23:27,990 --> 00:23:31,409
there this is this is not just a testing

00:23:29,639 --> 00:23:34,350
technique that is only for architecture

00:23:31,409 --> 00:23:36,570
astronauts you can use it we we use it

00:23:34,350 --> 00:23:38,399
and we we write a couple rails apps I

00:23:36,570 --> 00:23:39,380
think it's like 40 something in last

00:23:38,399 --> 00:23:48,330
count

00:23:39,380 --> 00:23:50,010
so yeah that is the talk thank you so

00:23:48,330 --> 00:23:51,120
the question is if you have if you have

00:23:50,010 --> 00:23:53,870
a whole codebase that's that's

00:23:51,120 --> 00:23:57,659
dependency injected do we ever have

00:23:53,870 --> 00:23:59,610
composite classes to to merge some of

00:23:57,659 --> 00:24:02,340
those dependencies so we're not passing

00:23:59,610 --> 00:24:07,830
around a bunch of them all the time is

00:24:02,340 --> 00:24:10,200
that that your question okay so when

00:24:07,830 --> 00:24:13,380
when when I do this in actual in actual

00:24:10,200 --> 00:24:16,909
code bases let's go back to a thing with

00:24:13,380 --> 00:24:16,909
an initializer that we can actually read

00:24:19,830 --> 00:24:25,290
there we go I don't do it this way I

00:24:23,340 --> 00:24:27,390
don't I don't have a named parameter for

00:24:25,290 --> 00:24:30,080
each dependency what I'll frequently do

00:24:27,390 --> 00:24:32,490
is have some kind of object that I can

00:24:30,080 --> 00:24:34,050
that works kind of like an open struct

00:24:32,490 --> 00:24:36,150
or a hash that I can attach a bunch of

00:24:34,050 --> 00:24:37,920
dependencies to and then and then what I

00:24:36,150 --> 00:24:39,780
do is I have every object that's going

00:24:37,920 --> 00:24:43,800
to be dependency injected take like

00:24:39,780 --> 00:24:46,020
depths as a keyword and then in their

00:24:43,800 --> 00:24:47,880
initializer I'll have them assert the

00:24:46,020 --> 00:24:51,000
dependencies they need that object to

00:24:47,880 --> 00:24:53,100
contain so we still we retain all the

00:24:51,000 --> 00:24:55,320
information that our constructor gives

00:24:53,100 --> 00:24:56,910
us and we don't have the problem of if

00:24:55,320 --> 00:24:58,470
we want to inject a dependency like five

00:24:56,910 --> 00:25:00,150
layers in we have to change every

00:24:58,470 --> 00:25:04,050
constructor between there and the

00:25:00,150 --> 00:25:08,280
outside of the code yep so that's what

00:25:04,050 --> 00:25:10,800
the that is what the instance doubles

00:25:08,280 --> 00:25:13,470
are for instance doubles in Ruby

00:25:10,800 --> 00:25:14,970
automatically verify if I tried to if I

00:25:13,470 --> 00:25:16,890
wanted to say allow whether service to

00:25:14,970 --> 00:25:19,290
receive say which it doesn't implement

00:25:16,890 --> 00:25:21,270
right there r-spec would say no and

00:25:19,290 --> 00:25:24,570
would give me a no method error and if I

00:25:21,270 --> 00:25:26,610
tried to make if I try to have expect

00:25:24,570 --> 00:25:28,170
houseboys receive say with no arguments

00:25:26,610 --> 00:25:29,730
when it has a single when it has at

00:25:28,170 --> 00:25:31,230
least one positional required argument

00:25:29,730 --> 00:25:32,370
it would give me an argument error and

00:25:31,230 --> 00:25:39,060
say meet that and tell me that's not

00:25:32,370 --> 00:25:41,100
valid not off the top of my head I'm

00:25:39,060 --> 00:25:42,780
being told by what reliable sources that

00:25:41,100 --> 00:25:50,040
there is a gem what that gem may or may

00:25:42,780 --> 00:25:51,630
not do I cannot tell you yeah I respect

00:25:50,040 --> 00:25:53,430
so our spec is actually a gem that is

00:25:51,630 --> 00:25:57,090
composed of three other gems I respect

00:25:53,430 --> 00:26:00,270
for r-spec expectations and a third

00:25:57,090 --> 00:26:01,710
thing and r-spec expect an r-spec it's

00:26:00,270 --> 00:26:03,450
either our spec expectations our respect

00:26:01,710 --> 00:26:04,890
mocks is where the is where the instance

00:26:03,450 --> 00:26:06,470
doubles are so you can pull that in and

00:26:04,890 --> 00:26:10,040
just kind of plug it in I'm sure there's

00:26:06,470 --> 00:26:16,310
multiple blog posts on how to do that so

00:26:10,040 --> 00:26:16,310
any other questions yes

00:26:19,730 --> 00:26:29,740
if I want to double a if I want to

00:26:24,350 --> 00:26:31,730
double a class I might sorry the the the

00:26:29,740 --> 00:26:33,230
and I have now not done that for two

00:26:31,730 --> 00:26:34,670
questions the previous question was how

00:26:33,230 --> 00:26:36,410
how would I do this in mini test and

00:26:34,670 --> 00:26:38,360
this meant and this gentleman's question

00:26:36,410 --> 00:26:45,200
is what do I use our suspect class

00:26:38,360 --> 00:26:51,410
doubles not all that frequently I mean I

00:26:45,200 --> 00:26:52,760
have before I'm I'm more partial to so

00:26:51,410 --> 00:26:56,420
the reason I imagined that I would use

00:26:52,760 --> 00:26:58,460
class doubles and I'm framing it that

00:26:56,420 --> 00:26:59,690
way because you might have a much more

00:26:58,460 --> 00:27:01,700
broad imagination than I do and use

00:26:59,690 --> 00:27:03,470
classes for different things but the way

00:27:01,700 --> 00:27:06,320
I would use them is if I had like a

00:27:03,470 --> 00:27:10,880
singleton or class methods that I wanted

00:27:06,320 --> 00:27:12,410
to call outside of a of the context of a

00:27:10,880 --> 00:27:15,500
particular instance but that still had

00:27:12,410 --> 00:27:18,020
dependencies and I generally structure

00:27:15,500 --> 00:27:20,030
my code to avoid doing that so if I was

00:27:18,020 --> 00:27:21,470
so I basically anytime anything that

00:27:20,030 --> 00:27:25,040
happens a dependency when I'm writing

00:27:21,470 --> 00:27:26,660
Ruby that's that's separate from a lot

00:27:25,040 --> 00:27:29,630
of the rails nouns or in its own library

00:27:26,660 --> 00:27:31,550
or whatever anything that takes a

00:27:29,630 --> 00:27:34,580
dependency I pretty much make an

00:27:31,550 --> 00:27:36,980
instance as opposed to a class but if

00:27:34,580 --> 00:27:38,360
but if but if you don't want to do that

00:27:36,980 --> 00:27:41,090
then you have class doubles are fine

00:27:38,360 --> 00:27:42,710
thing to do the question is how do you

00:27:41,090 --> 00:27:44,140
verify that the returned doubles are the

00:27:42,710 --> 00:27:47,930
same as the return values that you're

00:27:44,140 --> 00:27:49,160
your object would return and the answer

00:27:47,930 --> 00:27:50,600
is you can't

00:27:49,160 --> 00:27:51,980
because we don't have a compiler and we

00:27:50,600 --> 00:27:54,680
don't have interfaces we've there's no

00:27:51,980 --> 00:27:56,780
way like are the the method name and the

00:27:54,680 --> 00:27:59,390
method signature are static data that

00:27:56,780 --> 00:28:02,240
Ruby that you can get at via Ruby

00:27:59,390 --> 00:28:05,390
introspection but the return value is

00:28:02,240 --> 00:28:07,520
not a thing you can you can use I

00:28:05,390 --> 00:28:09,980
haven't played around with sorbet at all

00:28:07,520 --> 00:28:13,010
but like that might be a thing I would

00:28:09,980 --> 00:28:14,750
look at if I if I really wanted to

00:28:13,010 --> 00:28:17,570
investigate that possibility

00:28:14,750 --> 00:28:19,490
so yeah you you have to use your human

00:28:17,570 --> 00:28:21,809
eyeballs to look at and go is that the

00:28:19,490 --> 00:28:23,789
same thing so

00:28:21,809 --> 00:28:25,349
oh well if you have any further

00:28:23,789 --> 00:28:26,429
questions for me that is my twitter

00:28:25,349 --> 00:28:27,779
handle or you can find me at the

00:28:26,429 --> 00:28:29,609
conference I regret to inform you that I

00:28:27,779 --> 00:28:31,440
am NOT tall but I do have this ponytail

00:28:29,609 --> 00:28:32,690
so maybe that'll help you find me if you

00:28:31,440 --> 00:28:38,830
want to

00:28:32,690 --> 00:28:52,130
[Applause]

00:28:38,830 --> 00:28:52,130

YouTube URL: https://www.youtube.com/watch?v=b5vfNcjJsLU


