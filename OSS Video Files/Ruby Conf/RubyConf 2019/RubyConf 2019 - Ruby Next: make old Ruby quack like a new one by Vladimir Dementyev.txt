Title: RubyConf 2019 - Ruby Next: make old Ruby quack like a new one by Vladimir Dementyev
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Ruby Next: make old Ruby quack like a new one by Vladimir Dementyev

Ruby 2.7 is just around the corner. It will bring a lot of new features, including new syntax additions: pattern matching, numbered parameters.

That's good news. The bad news is that not many of us will be able to use these goodies right away: the upgrade cost blocks application developers; gem authors have to support older versions.

What if we were able to use Ruby Next features while running Ruby Current? Maybe, we can cast a metaprogramming spell for that? Yes, we can. And I'll show you how.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,830 --> 00:00:21,960
hello Ruby gone how we doing

00:00:17,330 --> 00:00:23,789
okay I hope you doing well so welcome to

00:00:21,960 --> 00:00:26,570
my talk and today I gonna talk about

00:00:23,789 --> 00:00:30,359
Ruby it's a programming language and

00:00:26,570 --> 00:00:32,969
this joke is well it looks a bit similar

00:00:30,359 --> 00:00:34,649
to the keynotes right and it's not a

00:00:32,969 --> 00:00:36,479
coincidence because I think it's this

00:00:34,649 --> 00:00:40,710
talk is a kind of spin-off to what

00:00:36,479 --> 00:00:43,530
Matt's told about this morning about

00:00:40,710 --> 00:00:46,829
upcoming Ruby features and challenges

00:00:43,530 --> 00:00:49,530
they bring to us and but I'm gonna take

00:00:46,829 --> 00:00:53,069
a look at their different angle from the

00:00:49,530 --> 00:00:54,659
perspective of the Ruby developers not

00:00:53,069 --> 00:00:57,749
from the perspective or language

00:00:54,659 --> 00:01:00,239
designers or core team members however

00:00:57,749 --> 00:01:04,940
making decisions so I'm going to talk

00:01:00,239 --> 00:01:09,510
about Ruby next it's a kind of thing and

00:01:04,940 --> 00:01:12,600
as title of the talk says in the program

00:01:09,510 --> 00:01:13,070
that's make out Ruby Clark like a new

00:01:12,600 --> 00:01:16,260
one

00:01:13,070 --> 00:01:17,910
so what is it driven me let me show you

00:01:16,260 --> 00:01:21,750
quick spoiler or what I gonna talk about

00:01:17,910 --> 00:01:24,510
today so assume you have a older version

00:01:21,750 --> 00:01:26,280
of Ruby even not the recent one but the

00:01:24,510 --> 00:01:28,700
preview is and you want to try this

00:01:26,280 --> 00:01:31,590
shiny new pattern matching syntax and

00:01:28,700 --> 00:01:35,370
it's likely gonna fail or something like

00:01:31,590 --> 00:01:39,390
this because Ruby 2/5 doesn't know

00:01:35,370 --> 00:01:42,690
anything about better mentioned right

00:01:39,390 --> 00:01:44,250
what is Ruby next so in terms of this

00:01:42,690 --> 00:01:46,830
example Rubin axe is just a simple

00:01:44,250 --> 00:01:49,500
switch here in the common which makes

00:01:46,830 --> 00:01:53,460
older will be understand recognized and

00:01:49,500 --> 00:01:55,370
correctly evaluate than you would be so

00:01:53,460 --> 00:01:57,500
that's what I going to talk about today

00:01:55,370 --> 00:02:01,290
now to the official part

00:01:57,500 --> 00:02:03,210
my name is Vladimir I'm kind of from

00:02:01,290 --> 00:02:04,510
Russia but sometimes I live in New York

00:02:03,210 --> 00:02:06,890
City

00:02:04,510 --> 00:02:11,060
I'm working for a company called evil

00:02:06,890 --> 00:02:14,270
Martians we distributed consultancy

00:02:11,060 --> 00:02:16,460
agency with agents and basis all of the

00:02:14,270 --> 00:02:18,490
world from San Francisco to also kinda

00:02:16,460 --> 00:02:21,640
Pam and right now I'm here in Nashville

00:02:18,490 --> 00:02:24,470
but I'm the only one here unfortunately

00:02:21,640 --> 00:02:26,390
except from the clients well it's

00:02:24,470 --> 00:02:28,190
getting louder except from the clients

00:02:26,390 --> 00:02:30,290
work we doing a lot of open source stuff

00:02:28,190 --> 00:02:32,330
you probably heard about some of these

00:02:30,290 --> 00:02:34,360
projects and who knows what's gonna be

00:02:32,330 --> 00:02:34,360
next

00:02:34,400 --> 00:02:39,110
I'm a ruby developer and now I only ruby

00:02:36,920 --> 00:02:44,000
developer you could find me on github I

00:02:39,110 --> 00:02:45,770
have some cool projects probably and the

00:02:44,000 --> 00:02:48,470
thing that makes sense in terms of this

00:02:45,770 --> 00:02:51,230
talk I'm a gems offer currently I

00:02:48,470 --> 00:02:54,560
maintain dozens of ruby gems at all of

00:02:51,230 --> 00:02:57,770
them kind of popular of course but well

00:02:54,560 --> 00:03:01,460
some of them could be familiar and that

00:02:57,770 --> 00:03:05,090
leads us to the first problem to the

00:03:01,460 --> 00:03:07,670
situation which brought me here to the

00:03:05,090 --> 00:03:11,900
stage talking about some kind of new

00:03:07,670 --> 00:03:14,000
thing so as a library developer I have

00:03:11,900 --> 00:03:16,250
to support all the versions I can just

00:03:14,000 --> 00:03:17,750
use the most recent one because well

00:03:16,250 --> 00:03:20,360
nobody gonna use the library which

00:03:17,750 --> 00:03:23,060
doesn't support their Ruby version so I

00:03:20,360 --> 00:03:24,739
have to stick to at least those Ruby

00:03:23,060 --> 00:03:27,620
versions which end of life haven't

00:03:24,739 --> 00:03:30,440
reached yet and as of now would be to

00:03:27,620 --> 00:03:35,150
freeze officially dead and Ruby too far

00:03:30,440 --> 00:03:38,770
is going be so I'm currently migrating

00:03:35,150 --> 00:03:42,530
all of my libraries two to five at least

00:03:38,770 --> 00:03:45,470
but the problem I want to use to seven

00:03:42,530 --> 00:03:47,870
features well they really go good good

00:03:45,470 --> 00:03:50,450
you know maths

00:03:47,870 --> 00:03:52,940
told you about this this morning so we

00:03:50,450 --> 00:03:54,620
already know about this features but I

00:03:52,940 --> 00:03:56,120
can't so that's the first problem

00:03:54,620 --> 00:04:01,489
kind of a small problem because it only

00:03:56,120 --> 00:04:03,050
bothers me and gems offer but now that

00:04:01,489 --> 00:04:04,870
we're here is the gem software raise

00:04:03,050 --> 00:04:08,190
your hand if you maintain in a channel

00:04:04,870 --> 00:04:11,310
yeah so it's about if

00:04:08,190 --> 00:04:12,989
not so many most of you applications

00:04:11,310 --> 00:04:16,229
developers right who develop

00:04:12,989 --> 00:04:23,160
applications in Ruby yeah okay sounds

00:04:16,229 --> 00:04:24,690
good we have to become but but even if

00:04:23,160 --> 00:04:27,240
you develop your application it doesn't

00:04:24,690 --> 00:04:28,970
mean that you can upgrade your ruby

00:04:27,240 --> 00:04:32,460
version right away as it's released and

00:04:28,970 --> 00:04:35,490
according to some numbers collected by

00:04:32,460 --> 00:04:37,979
JetBrains massive Ruby developers are

00:04:35,490 --> 00:04:38,520
still using second-to-last or even third

00:04:37,979 --> 00:04:42,990
to last

00:04:38,520 --> 00:04:45,770
Ruby versions not even to six and which

00:04:42,990 --> 00:04:48,120
must important about charitable

00:04:45,770 --> 00:04:50,370
respondents are not going to switch to

00:04:48,120 --> 00:04:53,760
new ruby version why so well maybe

00:04:50,370 --> 00:04:55,530
because the cost of upgrades sometimes

00:04:53,760 --> 00:04:57,840
it's costs don't think it's not just

00:04:55,530 --> 00:05:03,539
changing your ruby version filing your

00:04:57,840 --> 00:05:05,669
repo it doesn't Wars it yes you know it

00:05:03,539 --> 00:05:07,940
requires some effort not everyone

00:05:05,669 --> 00:05:11,210
understands what it could bring to me

00:05:07,940 --> 00:05:14,190
performance well yeah technically every

00:05:11,210 --> 00:05:19,220
V release brings new performance

00:05:14,190 --> 00:05:21,630
improvements but well from my experience

00:05:19,220 --> 00:05:23,430
that's not that's something that no one

00:05:21,630 --> 00:05:26,400
cares about when developing applications

00:05:23,430 --> 00:05:29,729
maybe major in performance could could

00:05:26,400 --> 00:05:32,490
force people to upgrade but not so well

00:05:29,729 --> 00:05:35,700
two to three percent faster hashes or

00:05:32,490 --> 00:05:37,199
whatever so this is not usually the case

00:05:35,700 --> 00:05:39,780
why people upgrade through the versions

00:05:37,199 --> 00:05:43,380
new features well that should be the

00:05:39,780 --> 00:05:46,919
case so we want to use something new we

00:05:43,380 --> 00:05:50,099
as humans we like trying new things and

00:05:46,919 --> 00:05:52,710
new cool features could encourage a

00:05:50,099 --> 00:05:54,990
store use greatest Ruby version but

00:05:52,710 --> 00:05:57,750
until recently I say I'd like to say

00:05:54,990 --> 00:06:02,760
until 2 7 which is hasn't been released

00:05:57,750 --> 00:06:05,780
yet we haven't had a lot of shiny new

00:06:02,760 --> 00:06:08,250
stuff with every minor release but

00:06:05,780 --> 00:06:10,860
anyway sometimes there was a reason to

00:06:08,250 --> 00:06:13,139
upgrade and I'm gonna tell you a short

00:06:10,860 --> 00:06:16,500
story how I can was the idea so that I

00:06:13,139 --> 00:06:18,510
want to use modern Ruby features even if

00:06:16,500 --> 00:06:20,969
I want to support older it's all started

00:06:18,510 --> 00:06:23,489
about two years ago with Ruby 2/5

00:06:20,969 --> 00:06:25,799
and one feature caught my attention do

00:06:23,489 --> 00:06:30,589
you know what is it any suggestions what

00:06:25,799 --> 00:06:35,159
Cain was to five yeah okay it's yourself

00:06:30,589 --> 00:06:36,989
well yeah it could be well why why so I

00:06:35,159 --> 00:06:38,819
was a bit skeptical in the very

00:06:36,989 --> 00:06:40,499
beginning because I have no idea why do

00:06:38,819 --> 00:06:43,499
we need this stupid the name their

00:06:40,499 --> 00:06:45,629
methods available for every object what

00:06:43,499 --> 00:06:48,239
the use case for that but instead of

00:06:45,629 --> 00:06:51,959
just trying to be against it I decided

00:06:48,239 --> 00:06:55,529
okay I have to try it to figure out why

00:06:51,959 --> 00:06:58,139
it it's really cool and going forward

00:06:55,529 --> 00:07:03,389
it's it's cool and now I'm using it

00:06:58,139 --> 00:07:05,459
every day but though then I had to well

00:07:03,389 --> 00:07:09,029
I wanted to try to use it but I was

00:07:05,459 --> 00:07:11,249
building jams so I had to backboard it

00:07:09,029 --> 00:07:13,709
somehow what is a typical way of back

00:07:11,249 --> 00:07:16,860
party new features to old versions well

00:07:13,709 --> 00:07:19,469
this is way this is not good way of

00:07:16,860 --> 00:07:21,809
backporting stuff and we are metal broke

00:07:19,469 --> 00:07:23,519
I mean for good Trek and this is not

00:07:21,809 --> 00:07:26,550
what we're going to talk about extending

00:07:23,519 --> 00:07:29,550
Colossus is is evil and even being evil

00:07:26,550 --> 00:07:31,379
Martian I'm not so evil to do that in my

00:07:29,550 --> 00:07:33,360
gems because that could lead to

00:07:31,379 --> 00:07:35,550
conflicts and to unexpected behavior

00:07:33,360 --> 00:07:37,949
it's probably sometimes okay when you

00:07:35,550 --> 00:07:39,479
develop an application okay but when are

00:07:37,949 --> 00:07:41,009
you development libraries others going

00:07:39,479 --> 00:07:44,159
to use it's unacceptable

00:07:41,009 --> 00:07:46,679
and even with itself the chance of

00:07:44,159 --> 00:07:49,229
collision is pretty low because no one

00:07:46,679 --> 00:07:53,819
going to name a method like this but

00:07:49,229 --> 00:07:55,379
then another change of cured and we got

00:07:53,819 --> 00:07:56,999
a new name much better name but this

00:07:55,379 --> 00:07:59,789
names could be used by other libraries

00:07:56,999 --> 00:08:01,409
and actually it's used so I decided to

00:07:59,789 --> 00:08:04,439
go another way and started to use

00:08:01,409 --> 00:08:06,869
another type of monkey patching which is

00:08:04,439 --> 00:08:08,909
called refinements and that's the first

00:08:06,869 --> 00:08:11,610
thing I'm gonna talk about today a

00:08:08,909 --> 00:08:16,969
little bit who knows what the hell

00:08:11,610 --> 00:08:21,779
refinement is and who use refinements me

00:08:16,969 --> 00:08:24,299
okay so a bit of history requirements is

00:08:21,779 --> 00:08:28,469
a pretty old Ruby feature they were

00:08:24,299 --> 00:08:32,260
introduced in 2.0 but was marked with

00:08:28,469 --> 00:08:38,310
this very dangerous word experimental

00:08:32,260 --> 00:08:41,740
and even if we remove this label in 2.1

00:08:38,310 --> 00:08:43,600
people's not gonna wasn't going to use

00:08:41,740 --> 00:08:45,850
it anyway because they were afraid that

00:08:43,600 --> 00:08:47,920
oh they still experimental they're gonna

00:08:45,850 --> 00:08:49,450
be removed and some future versions

00:08:47,920 --> 00:08:52,780
maybe because there were some talks of

00:08:49,450 --> 00:08:55,270
like this and there were a lot of well

00:08:52,780 --> 00:08:57,280
real problems and fiction problems with

00:08:55,270 --> 00:08:59,320
refinements like inconsistency of

00:08:57,280 --> 00:09:00,790
functionality refinements were getting

00:08:59,320 --> 00:09:04,140
better was their release in probably

00:09:00,790 --> 00:09:08,170
into five to six they finally became

00:09:04,140 --> 00:09:11,230
ninety percent consistent but yeah they

00:09:08,170 --> 00:09:13,240
don't go away in 3.0 so we're gonna live

00:09:11,230 --> 00:09:15,640
with them for some quite a time so we're

00:09:13,240 --> 00:09:20,200
gonna use them so refinement is a

00:09:15,640 --> 00:09:24,990
lexically scoped monkey patch it means

00:09:20,200 --> 00:09:27,820
that it somehow takes into account the

00:09:24,990 --> 00:09:31,540
place from where the method code was

00:09:27,820 --> 00:09:35,080
made in other words it changed the way

00:09:31,540 --> 00:09:37,180
method lookup work in Ruby before we

00:09:35,080 --> 00:09:41,370
finance we have a pretty straightforward

00:09:37,180 --> 00:09:44,740
method lookup algorithm we go for the

00:09:41,370 --> 00:09:46,780
ancestor change chain for the object

00:09:44,740 --> 00:09:50,830
class so it's depended and included

00:09:46,780 --> 00:09:53,470
modules class singleton class parent

00:09:50,830 --> 00:09:55,810
class and so on and so forth and we just

00:09:53,470 --> 00:09:57,760
check every module class in this chain

00:09:55,810 --> 00:10:02,620
and whether the method is defined here

00:09:57,760 --> 00:10:07,300
in a fit this we use it and apply we

00:10:02,620 --> 00:10:08,500
famous did this small change which

00:10:07,300 --> 00:10:10,420
actually turn out to be really big

00:10:08,500 --> 00:10:12,340
because now we have to take into account

00:10:10,420 --> 00:10:14,710
the context of the situation hopefully

00:10:12,340 --> 00:10:17,050
it will be already track the execution

00:10:14,710 --> 00:10:20,590
context for every same massive goal to

00:10:17,050 --> 00:10:23,020
simplify things and we didn't have to

00:10:20,590 --> 00:10:25,630
change the way interpreter work but we

00:10:23,020 --> 00:10:28,510
changed drastically the way metal cups

00:10:25,630 --> 00:10:30,310
direct work which well from my

00:10:28,510 --> 00:10:31,990
perspective that's okay because MRA is

00:10:30,310 --> 00:10:35,770
the first implementation which added

00:10:31,990 --> 00:10:39,160
this but other implementations like

00:10:35,770 --> 00:10:41,800
JRuby truffle Ruby and well they kind of

00:10:39,160 --> 00:10:43,060
hate refinements because they're really

00:10:41,800 --> 00:10:45,910
hard to

00:10:43,060 --> 00:10:47,889
well implement and without losing

00:10:45,910 --> 00:10:51,490
optimizations they have in JVM for

00:10:47,889 --> 00:10:52,870
example and that was another reason why

00:10:51,490 --> 00:10:55,000
refinements were not so popular because

00:10:52,870 --> 00:10:57,220
the second most popular Ruby

00:10:55,000 --> 00:10:58,990
implementation J will be had pretty poor

00:10:57,220 --> 00:11:02,529
support for refinements until very

00:10:58,990 --> 00:11:05,110
recently I can say that's lazy the

00:11:02,529 --> 00:11:07,839
latest version fixed almost all the box

00:11:05,110 --> 00:11:10,389
with your finest Cera's neither did a

00:11:07,839 --> 00:11:13,029
great amount of work reflected all the

00:11:10,389 --> 00:11:15,189
way method lookup work in JRuby and now

00:11:13,029 --> 00:11:17,319
we can use your famous with JRuby like

00:11:15,189 --> 00:11:20,889
an MRI almost there's still some issues

00:11:17,319 --> 00:11:22,689
I edit recently so refinement if I meant

00:11:20,889 --> 00:11:24,699
is two-step operation first you define

00:11:22,689 --> 00:11:27,629
refinement then you activate it the

00:11:24,699 --> 00:11:31,149
final refinement is almost equal to

00:11:27,629 --> 00:11:33,790
batch in a class but except we open in

00:11:31,149 --> 00:11:36,579
the class you go refine method and pass

00:11:33,790 --> 00:11:40,870
a block to define the methods inside so

00:11:36,579 --> 00:11:42,819
this looks pretty similar and activation

00:11:40,870 --> 00:11:45,250
is a special method it's called using

00:11:42,819 --> 00:11:47,319
where you tell the current execution

00:11:45,250 --> 00:11:50,019
context that there is an active

00:11:47,319 --> 00:11:51,670
refinement in this context and what does

00:11:50,019 --> 00:11:55,360
it mean lexical so let's consider two

00:11:51,670 --> 00:11:57,519
examples in one file we add this using

00:11:55,360 --> 00:11:59,860
mantra and another one doesn't have it

00:11:57,519 --> 00:12:02,259
we still use then methods and you've

00:11:59,860 --> 00:12:03,730
around the first one it works and from

00:12:02,259 --> 00:12:05,920
the second one it doesn't know about the

00:12:03,730 --> 00:12:08,199
methods and because it doesn't define in

00:12:05,920 --> 00:12:10,389
this scope so that's the way your family

00:12:08,199 --> 00:12:12,220
works we can say your assignment is a

00:12:10,389 --> 00:12:13,870
safe monkey - because it's not leaking

00:12:12,220 --> 00:12:17,350
anywhere outside of the code you

00:12:13,870 --> 00:12:20,550
explicitly activate it that's why I

00:12:17,350 --> 00:12:23,800
decided to use your famous for

00:12:20,550 --> 00:12:26,379
backporting new api's - older rubies

00:12:23,800 --> 00:12:29,860
because it's kind of safe way of memory

00:12:26,379 --> 00:12:31,660
batching who knows about what what kind

00:12:29,860 --> 00:12:36,639
of things I'd wanted to backboard -

00:12:31,660 --> 00:12:38,769
older rubies well when it was 250 era we

00:12:36,639 --> 00:12:43,829
had healed self and couple of useful

00:12:38,769 --> 00:12:46,480
hash methods Fred fetch which also make

00:12:43,829 --> 00:12:49,629
operating with Fred local variables a

00:12:46,480 --> 00:12:52,209
bit more concise in two SEC's we got

00:12:49,629 --> 00:12:55,120
them throughout compositions useless

00:12:52,209 --> 00:12:56,830
alias are a filter enumerable filter in

00:12:55,120 --> 00:12:59,590
a couple of array methods

00:12:56,830 --> 00:13:01,960
finally into seven again we already seen

00:12:59,590 --> 00:13:04,480
this today a numeral charlie filter map

00:13:01,960 --> 00:13:07,810
couple time methods and development

00:13:04,480 --> 00:13:10,510
bicycle if you interested in following

00:13:07,810 --> 00:13:12,100
ruby chinese lock in a good and readable

00:13:10,510 --> 00:13:15,010
way i highly recommend to change this

00:13:12,100 --> 00:13:18,310
website it's a ruby references good help

00:13:15,010 --> 00:13:19,900
io will be changes it's maintained by

00:13:18,310 --> 00:13:24,250
victor shepherd of who's given token

00:13:19,900 --> 00:13:27,010
Wednesday its silikal source of true for

00:13:24,250 --> 00:13:30,790
Ruby language for change logs for

00:13:27,010 --> 00:13:34,960
language itself it's really useful so

00:13:30,790 --> 00:13:37,180
Ruby next as a version 2018 which didn't

00:13:34,960 --> 00:13:39,040
exist and just was in my mind what they

00:13:37,180 --> 00:13:40,930
deal with one refinement which contains

00:13:39,040 --> 00:13:43,450
all the back ported methods all the

00:13:40,930 --> 00:13:46,090
modules and classic and you can just go

00:13:43,450 --> 00:13:48,070
using Ruby next and everything start

00:13:46,090 --> 00:13:51,370
working as it is the latest version of

00:13:48,070 --> 00:13:54,190
Ruby so for example in this script we

00:13:51,370 --> 00:13:56,200
have filter map Sally and it just works

00:13:54,190 --> 00:13:58,690
so it if you come back it's just

00:13:56,200 --> 00:14:04,260
calculate the number of files it was a

00:13:58,690 --> 00:14:07,210
specific extension in directory okay so

00:14:04,260 --> 00:14:08,920
this refinement is no operational in

00:14:07,210 --> 00:14:11,530
those version in which this method have

00:14:08,920 --> 00:14:13,960
been implemented so it's kind of easy to

00:14:11,530 --> 00:14:15,670
use just drop it use it and it would

00:14:13,960 --> 00:14:19,240
make your work or your girls compatible

00:14:15,670 --> 00:14:24,570
from the API perspective with the new

00:14:19,240 --> 00:14:29,470
all code would become paper was new so

00:14:24,570 --> 00:14:31,180
but then Ruby's juice Allen well it's

00:14:29,470 --> 00:14:33,970
kind of a revolutionary action release

00:14:31,180 --> 00:14:36,400
because it brings now I know for now

00:14:33,970 --> 00:14:38,950
it's free syntax related features like

00:14:36,400 --> 00:14:41,980
better matching member params method

00:14:38,950 --> 00:14:43,630
reference died Oh cancel sorry but I'm

00:14:41,980 --> 00:14:45,790
still using it and I'm gonna use it in

00:14:43,630 --> 00:14:47,200
my examples because I like it and acts

00:14:45,790 --> 00:14:50,800
forwarding but we can actually find

00:14:47,200 --> 00:14:51,970
cinders so it's kind of impossible what

00:14:50,800 --> 00:14:54,160
we can do with syntax instead of

00:14:51,970 --> 00:14:57,130
refining it and using some rubies tab

00:14:54,160 --> 00:14:58,440
well there is work called transpiler

00:14:57,130 --> 00:15:00,649
transpiling

00:14:58,440 --> 00:15:04,729
source code

00:15:00,649 --> 00:15:07,129
and eventually as of now ruby next is a

00:15:04,729 --> 00:15:10,040
combination of universal refinement for

00:15:07,129 --> 00:15:14,229
api's and a transpiler for new syntax

00:15:10,040 --> 00:15:14,229
features so transpiling

00:15:19,049 --> 00:15:26,399
smiling is a compiling source code into

00:15:22,529 --> 00:15:29,129
source code so as input we have Ruby -

00:15:26,399 --> 00:15:32,660
seven source code as output we have Ruby

00:15:29,129 --> 00:15:34,949
- five source code which does the same

00:15:32,660 --> 00:15:39,059
that's not a new idea

00:15:34,949 --> 00:15:42,660
of course if you ever try to build

00:15:39,059 --> 00:15:45,149
something with JavaScript or CSS you

00:15:42,660 --> 00:15:47,819
definitely heard about Babel which is

00:15:45,149 --> 00:15:51,809
used next-generation JavaScript today or

00:15:47,819 --> 00:15:55,679
Posse SS used tomorrow CSS today so

00:15:51,809 --> 00:15:58,319
that's very similar idea here so we want

00:15:55,679 --> 00:16:02,790
to make it possible to use upcoming

00:15:58,319 --> 00:16:05,009
features in their current and the whole

00:16:02,790 --> 00:16:07,499
process is could be described like this

00:16:05,009 --> 00:16:09,359
so we got a good source code we parse it

00:16:07,499 --> 00:16:12,059
with some kind of parser and generator

00:16:09,359 --> 00:16:14,009
after Santa's tree then we modify this

00:16:12,059 --> 00:16:17,369
abstract syntax tree because working

00:16:14,009 --> 00:16:19,079
with trees is much easier than what you

00:16:17,369 --> 00:16:21,660
see with streams right who can I just

00:16:19,079 --> 00:16:25,019
rewrite string source code we need

00:16:21,660 --> 00:16:27,359
something more object oriented program

00:16:25,019 --> 00:16:32,639
and then we generate a new source code

00:16:27,359 --> 00:16:34,529
with this new a tree let's take a look

00:16:32,639 --> 00:16:38,269
at the example so this is a code this is

00:16:34,529 --> 00:16:42,209
better mash an example for Ruby to seven

00:16:38,269 --> 00:16:44,819
very stupid but anyway let's talk first

00:16:42,209 --> 00:16:46,709
about how we can transform source code

00:16:44,819 --> 00:16:48,359
to abstract syntax tree there are a

00:16:46,709 --> 00:16:52,079
number of options in Ruby which we have

00:16:48,359 --> 00:16:54,629
the first one is called Ripper this is

00:16:52,079 --> 00:16:57,779
build a new library and it allows you to

00:16:54,629 --> 00:17:01,139
generate a abstract syntax tree in the

00:16:57,779 --> 00:17:03,929
form of array of symbols and other

00:17:01,139 --> 00:17:08,760
primitives and race however so this kind

00:17:03,929 --> 00:17:09,480
of example it's been you know B for a

00:17:08,760 --> 00:17:12,179
long time

00:17:09,480 --> 00:17:13,949
but it the big problem of it and we it's

00:17:12,179 --> 00:17:17,100
version specific we cannot pass the

00:17:13,949 --> 00:17:19,409
course with written for Ruby to Salem

00:17:17,100 --> 00:17:21,510
using repair from Ruby to five because

00:17:19,409 --> 00:17:23,279
it doesn't understand it it's kind of

00:17:21,510 --> 00:17:25,980
bundled in the current Ruby version and

00:17:23,279 --> 00:17:28,799
it can be extended so that's not an

00:17:25,980 --> 00:17:31,620
option anyway there are some some

00:17:28,799 --> 00:17:33,060
spirals which use river as its source to

00:17:31,620 --> 00:17:36,630
aced

00:17:33,060 --> 00:17:39,120
- for example Prevot which do some code

00:17:36,630 --> 00:17:41,550
optimizations and Ruby code without

00:17:39,120 --> 00:17:47,310
changing our version semantics but only

00:17:41,550 --> 00:17:51,990
doing some micro stuff like folding

00:17:47,310 --> 00:17:55,110
constants whatever another candidate is

00:17:51,990 --> 00:17:59,250
a Ruby damn abstract seems extreme so it

00:17:55,110 --> 00:18:00,990
kind of well also generates industry in

00:17:59,250 --> 00:18:03,300
a different form so that this time we

00:18:00,990 --> 00:18:05,850
get objects with more information than

00:18:03,300 --> 00:18:10,500
from Reaper but it's a new thing it's

00:18:05,850 --> 00:18:13,500
not so well documented and I'm not sure

00:18:10,500 --> 00:18:16,170
anyone except from the offers of this

00:18:13,500 --> 00:18:18,030
feature use it and it's my specific so

00:18:16,170 --> 00:18:21,480
comparing to Reaper which has been back

00:18:18,030 --> 00:18:23,610
ported to JRuby for example and Ruby

00:18:21,480 --> 00:18:27,030
damn abstract syntax tree hasn't been

00:18:23,610 --> 00:18:30,330
yet and again again the same thing with

00:18:27,030 --> 00:18:32,490
Reaper its first specific so we go next

00:18:30,330 --> 00:18:37,350
and that's parser parser is a separate

00:18:32,490 --> 00:18:39,510
gem how surprisingly also allows us to

00:18:37,350 --> 00:18:43,260
generate that search industry but they

00:18:39,510 --> 00:18:44,940
look pretty readable the good points of

00:18:43,260 --> 00:18:46,800
parser it's reading pure ruby it's

00:18:44,940 --> 00:18:50,880
version independent which means you can

00:18:46,800 --> 00:18:54,440
parse code right reading for any version

00:18:50,880 --> 00:18:58,560
of ruby from any other version and it's

00:18:54,440 --> 00:19:01,080
already been used in many tools actually

00:18:58,560 --> 00:19:04,140
one of the most famous example of parser

00:19:01,080 --> 00:19:07,350
usage is Robocop Jam so Robocop Hughes

00:19:04,140 --> 00:19:10,260
parser to analyze your code and to

00:19:07,350 --> 00:19:11,790
transformations and last but not least

00:19:10,260 --> 00:19:16,620
it actually was born into a Martians

00:19:11,790 --> 00:19:17,610
years ago but it was another good point

00:19:16,620 --> 00:19:19,470
about parser

00:19:17,610 --> 00:19:21,990
there is also an ant parser Jam which

00:19:19,470 --> 00:19:24,360
does for us this is the last step of the

00:19:21,990 --> 00:19:25,950
separation so we've given a abstract

00:19:24,360 --> 00:19:30,330
syntax tree we can generate a source

00:19:25,950 --> 00:19:33,050
code and it's not gonna be the same

00:19:30,330 --> 00:19:34,230
source code that you write because

00:19:33,050 --> 00:19:36,690
unpair

00:19:34,230 --> 00:19:39,420
acts like a very opinionated alder

00:19:36,690 --> 00:19:42,120
formatter so it's don't care about the

00:19:39,420 --> 00:19:44,970
original source code and how it looked

00:19:42,120 --> 00:19:45,670
like but it generates just some stable

00:19:44,970 --> 00:19:47,440
representation

00:19:45,670 --> 00:19:52,930
Rudy Sarzo so here for example we use

00:19:47,440 --> 00:19:55,270
explicit array instead of this parser is

00:19:52,930 --> 00:19:59,410
not ideal the restaurant where we

00:19:55,270 --> 00:20:02,320
strange will be use cases which it can

00:19:59,410 --> 00:20:05,290
parse correctly but well I don't know

00:20:02,320 --> 00:20:06,880
we've only one write code like this so

00:20:05,290 --> 00:20:12,700
parsha is good enough at least for now

00:20:06,880 --> 00:20:15,070
to be a core of this transpiler so we

00:20:12,700 --> 00:20:18,340
chose browser parser and the final

00:20:15,070 --> 00:20:20,350
schema is which bars ruby code using

00:20:18,340 --> 00:20:23,020
edge parser which is not an official

00:20:20,350 --> 00:20:24,700
version then we replace ast nodes and

00:20:23,020 --> 00:20:27,460
then we generate a new code is an our

00:20:24,700 --> 00:20:30,490
parser so this is the same just written

00:20:27,460 --> 00:20:32,770
in ruby code and this is an example of

00:20:30,490 --> 00:20:36,340
rewriter so for every feature we have a

00:20:32,770 --> 00:20:40,030
special class called rewriter which does

00:20:36,340 --> 00:20:42,400
this not replacement so from method

00:20:40,030 --> 00:20:44,160
reference which cancelled anyway it's a

00:20:42,400 --> 00:20:47,530
good example because it's the simplest

00:20:44,160 --> 00:20:50,770
transformation we had we transform this

00:20:47,530 --> 00:20:55,740
now into this node by replacing map ref

00:20:50,770 --> 00:20:57,910
with cent method that's that simple

00:20:55,740 --> 00:20:58,750
pattern matching is a bit more

00:20:57,910 --> 00:21:02,080
complicated

00:20:58,750 --> 00:21:05,140
well actually it's already I just edited

00:21:02,080 --> 00:21:07,750
a few dozen lines an hour ago

00:21:05,140 --> 00:21:09,970
so it's more than 500 lines of code to

00:21:07,750 --> 00:21:11,950
just make better imagine working Ruby

00:21:09,970 --> 00:21:14,410
2/5 and we're going to talk about it a

00:21:11,950 --> 00:21:16,180
bit more because there are some

00:21:14,410 --> 00:21:17,950
interesting stuff there so better

00:21:16,180 --> 00:21:21,070
matching how to do pattern matching

00:21:17,950 --> 00:21:23,290
without case in we can use if-else why

00:21:21,070 --> 00:21:25,090
not because well if else can do anything

00:21:23,290 --> 00:21:28,420
we also need to construct and

00:21:25,090 --> 00:21:32,200
reconstruct keys for representing non

00:21:28,420 --> 00:21:34,240
array or hash glasses for pattern

00:21:32,200 --> 00:21:37,600
matching and we need to perform some

00:21:34,240 --> 00:21:39,400
type and structure checks well if anyone

00:21:37,600 --> 00:21:41,890
of you saw the recent talk of pattern

00:21:39,400 --> 00:21:43,960
matching cute gonna be so there was

00:21:41,890 --> 00:21:48,250
something like this explained in terms

00:21:43,960 --> 00:21:51,700
of Ruby 2 7 but we go to try to rewrite

00:21:48,250 --> 00:21:55,650
this in Ruby 2 5 so let's try to do this

00:21:51,700 --> 00:21:59,400
with fizz bass program first I want to

00:21:55,650 --> 00:22:02,100
try to rewrite this program as of I

00:21:59,400 --> 00:22:03,740
wanted to do that knowing which program

00:22:02,100 --> 00:22:07,470
I want to write so with some context

00:22:03,740 --> 00:22:11,179
what how can I write this fizzbuzz from

00:22:07,470 --> 00:22:14,370
left to right so we just can compare the

00:22:11,179 --> 00:22:16,710
array then we compare elements and

00:22:14,370 --> 00:22:19,830
arrays no matching pattern which is

00:22:16,710 --> 00:22:20,490
better imagine specification if nothing

00:22:19,830 --> 00:22:24,840
happened

00:22:20,490 --> 00:22:28,529
it looks pretty readable and easy to

00:22:24,840 --> 00:22:31,440
understand but transpiler should be very

00:22:28,529 --> 00:22:33,299
very smart to translate the left side to

00:22:31,440 --> 00:22:35,610
the right side what actually is

00:22:33,299 --> 00:22:37,110
happening in transpiler that we have to

00:22:35,610 --> 00:22:39,630
call to construct him and if it's array

00:22:37,110 --> 00:22:42,179
because why not maybe it has been

00:22:39,630 --> 00:22:44,460
overridden I don't know we should check

00:22:42,179 --> 00:22:47,279
for the class and race type error if

00:22:44,460 --> 00:22:48,870
it's not matching and we cannot just

00:22:47,279 --> 00:22:52,559
match the whole array we have to match

00:22:48,870 --> 00:22:56,070
elements one by one anyone for this

00:22:52,559 --> 00:22:57,840
year's case well even if you can see in

00:22:56,070 --> 00:22:59,039
the documentation that's underscores the

00:22:57,840 --> 00:23:01,649
kind of special variable it's not a

00:22:59,039 --> 00:23:03,440
special variable it's a typical local

00:23:01,649 --> 00:23:06,390
wearable you can even use it in your

00:23:03,440 --> 00:23:08,460
expression but it's just kind of not

00:23:06,390 --> 00:23:11,730
recommended but from the perspective of

00:23:08,460 --> 00:23:14,450
transpilers it's a legal name for local

00:23:11,730 --> 00:23:18,570
label so we have to sign it and us

00:23:14,450 --> 00:23:20,730
further so the code is a bit more

00:23:18,570 --> 00:23:23,010
complicated and if we take a look at the

00:23:20,730 --> 00:23:25,440
real transpile of code it's going to be

00:23:23,010 --> 00:23:30,630
much more complicated for this example

00:23:25,440 --> 00:23:33,600
but truly care about it I don't think so

00:23:30,630 --> 00:23:37,559
because this is a version for machines

00:23:33,600 --> 00:23:39,419
for robots for our VM we shouldn't see

00:23:37,559 --> 00:23:41,669
this code this should be somehow

00:23:39,419 --> 00:23:43,620
auto-generated and hidden and people

00:23:41,669 --> 00:23:45,690
should see this and this is a source of

00:23:43,620 --> 00:23:48,950
truth and this is a source of truth for

00:23:45,690 --> 00:23:48,950
your computer

00:23:50,270 --> 00:23:54,860
comparing these two methods there may be

00:23:52,580 --> 00:23:56,059
the question what about performance we

00:23:54,860 --> 00:23:59,920
do a lot of stuff here

00:23:56,059 --> 00:24:03,050
really and this looks pretty simple I

00:23:59,920 --> 00:24:04,130
try should ever make some benchmarks and

00:24:03,050 --> 00:24:05,390
it was a bit surprised

00:24:04,130 --> 00:24:07,400
well Matt's already told that better

00:24:05,390 --> 00:24:09,530
meshing is slowing to seven but it turn

00:24:07,400 --> 00:24:11,179
out to be twice slower even more than

00:24:09,530 --> 00:24:14,660
the transpiled version with gifts and

00:24:11,179 --> 00:24:16,880
else for this particular example well it

00:24:14,660 --> 00:24:20,120
highly depends on the code you try to

00:24:16,880 --> 00:24:23,630
transpile for example this code for the

00:24:20,120 --> 00:24:27,380
documentation which has we complex

00:24:23,630 --> 00:24:30,110
better matching it's also slower in to

00:24:27,380 --> 00:24:32,929
seven than transpiled version but not by

00:24:30,110 --> 00:24:36,140
a factor of two but just 50% but anyway

00:24:32,929 --> 00:24:38,780
so I expected better machining to say

00:24:36,140 --> 00:24:41,000
won't be much faster than transpiled

00:24:38,780 --> 00:24:42,280
version but turn out that that's not

00:24:41,000 --> 00:24:45,290
true

00:24:42,280 --> 00:24:47,450
well okay we know how to transform

00:24:45,290 --> 00:24:50,510
source code from one version to another

00:24:47,450 --> 00:24:52,550
but in Ruby unlike JavaScript for

00:24:50,510 --> 00:24:54,890
example we don't have a build phase

00:24:52,550 --> 00:24:59,929
right we do not build our application we

00:24:54,890 --> 00:25:02,390
just run Ruby and sound file RB and that

00:24:59,929 --> 00:25:09,290
should work how to make it work I was a

00:25:02,390 --> 00:25:12,850
Reuben exhale to transpile code in our

00:25:09,290 --> 00:25:12,850
case so

00:25:14,160 --> 00:25:19,530
I'm suggesting two strategies depending

00:25:16,140 --> 00:25:22,289
on what you building so for applications

00:25:19,530 --> 00:25:24,720
and scripts or anything else which you

00:25:22,289 --> 00:25:28,140
want to run on your machine

00:25:24,720 --> 00:25:32,309
we can't just fail at runtime and for

00:25:28,140 --> 00:25:34,500
gems it's better to transpile at build

00:25:32,309 --> 00:25:36,510
or release time to package all the

00:25:34,500 --> 00:25:38,669
transpile files along with the source

00:25:36,510 --> 00:25:40,049
files I'm going to talk about it today

00:25:38,669 --> 00:25:42,539
let's start with runtime

00:25:40,049 --> 00:25:45,000
so runtime is a big hack there's a one

00:25:42,539 --> 00:25:49,080
huge hack around all the ways will be

00:25:45,000 --> 00:25:51,870
low and evaluate code so hijack cannot

00:25:49,080 --> 00:25:54,270
require and just reimplemented yourself

00:25:51,870 --> 00:26:00,900
that's the only way we can transpile

00:25:54,270 --> 00:26:03,630
source code at runtime the code so this

00:26:00,900 --> 00:26:06,000
is just over writing kernel require

00:26:03,630 --> 00:26:07,830
which fall back to the original one if

00:26:06,000 --> 00:26:13,080
we failed for some reason to load the

00:26:07,830 --> 00:26:16,669
code the way we implement require is

00:26:13,080 --> 00:26:18,960
build on top of two arrays which

00:26:16,669 --> 00:26:21,600
responsible for loading pictures and

00:26:18,960 --> 00:26:23,640
Ruby so low that the array of locations

00:26:21,600 --> 00:26:26,700
of where to look for a particular

00:26:23,640 --> 00:26:29,940
feature so feature is a kind of a path

00:26:26,700 --> 00:26:33,780
on name of a jam for example Lotus

00:26:29,940 --> 00:26:37,049
picture is a array of all loaded Ruby

00:26:33,780 --> 00:26:38,850
and shared extensions files the absolute

00:26:37,049 --> 00:26:41,309
paths so that it's used to check whether

00:26:38,850 --> 00:26:43,530
we already loaded this feature or not to

00:26:41,309 --> 00:26:46,580
make require work only once if you go to

00:26:43,530 --> 00:26:48,960
multiple times and that's the way we can

00:26:46,580 --> 00:26:51,840
implement it in Ruby and actually what

00:26:48,960 --> 00:26:54,799
we're doing will be next runtime mode so

00:26:51,840 --> 00:26:58,559
first we need to resolve feature path

00:26:54,799 --> 00:27:03,440
it's just scanning the load path trying

00:26:58,559 --> 00:27:06,870
to figure out hit their file with this

00:27:03,440 --> 00:27:09,690
part path part and if it is to return

00:27:06,870 --> 00:27:11,880
this file then we check whether this

00:27:09,690 --> 00:27:15,510
absolute path has been already loaded

00:27:11,880 --> 00:27:17,610
and finally we read the source code we

00:27:15,510 --> 00:27:19,530
transform the scope source code

00:27:17,610 --> 00:27:23,070
this is where method reference actually

00:27:19,530 --> 00:27:25,590
is very useful and then the magic

00:27:23,070 --> 00:27:26,460
happens here we evaluate the source code

00:27:25,590 --> 00:27:27,900
on the

00:27:26,460 --> 00:27:30,540
specific constant called top-level

00:27:27,900 --> 00:27:32,700
binding so this binding of the main Ruby

00:27:30,540 --> 00:27:36,450
objects which is a top-level context of

00:27:32,700 --> 00:27:38,550
the fuchsia and evaluating code in the

00:27:36,450 --> 00:27:43,860
top-level binding is kind of similar to

00:27:38,550 --> 00:27:46,560
just load any file so it works the same

00:27:43,860 --> 00:27:49,190
way as Ruby acquire trouble they get

00:27:46,560 --> 00:27:54,570
well maybe there are some pitiful side I

00:27:49,190 --> 00:27:58,560
haven't found yet and that makes it work

00:27:54,570 --> 00:28:03,620
and this switch Ruby next this is not as

00:27:58,560 --> 00:28:05,550
kind of extension of Ruby interpreter or

00:28:03,620 --> 00:28:09,180
common line interface

00:28:05,550 --> 00:28:12,390
it's just next

00:28:09,180 --> 00:28:14,340
so Rubin axis expanded into me require

00:28:12,390 --> 00:28:16,620
who the next and hoobin axis just filed

00:28:14,340 --> 00:28:19,500
that loads all the runtime hacks so

00:28:16,620 --> 00:28:21,780
that's make it possible to use this very

00:28:19,500 --> 00:28:27,900
beautiful notation to running scripts

00:28:21,780 --> 00:28:30,420
using modern syntax okay so yeah runtime

00:28:27,900 --> 00:28:33,900
more is definitely not for production as

00:28:30,420 --> 00:28:36,780
it is now but it's good for testing we

00:28:33,900 --> 00:28:40,160
use runtime mode to test route X itself

00:28:36,780 --> 00:28:44,070
that's why actually it was built and

00:28:40,160 --> 00:28:46,170
future version of Ruby next will likely

00:28:44,070 --> 00:28:48,390
have an integration with boot snap what

00:28:46,170 --> 00:28:52,980
snap also hijacked require and all that

00:28:48,390 --> 00:28:55,320
stuff but well it it's kind of a measure

00:28:52,980 --> 00:28:57,360
library and they I hope they found all

00:28:55,320 --> 00:28:59,310
the edge cases and we can rely on their

00:28:57,360 --> 00:29:02,310
choir mechanism so if we can integrate

00:28:59,310 --> 00:29:08,820
into this we can make runtime out really

00:29:02,310 --> 00:29:11,850
safe doable in any application not about

00:29:08,820 --> 00:29:15,300
gems so the idea is that we ship

00:29:11,850 --> 00:29:18,030
transport will be source files along

00:29:15,300 --> 00:29:21,120
with the original source code because we

00:29:18,030 --> 00:29:23,640
don't want to transfer code in front

00:29:21,120 --> 00:29:26,810
time and we don't want to add additional

00:29:23,640 --> 00:29:28,680
runtime devs for our gems except from

00:29:26,810 --> 00:29:32,390
refinement part of the Ruby next because

00:29:28,680 --> 00:29:32,390
it's required for pattern matching first

00:29:32,720 --> 00:29:36,620
Reuben extra physics command-line

00:29:34,610 --> 00:29:41,690
interface will be next with a comment

00:29:36,620 --> 00:29:44,720
next to Phi which performs transpiling

00:29:41,690 --> 00:29:47,929
and created a directory in your projects

00:29:44,720 --> 00:29:51,049
root directory so they'll leap called RB

00:29:47,929 --> 00:29:53,690
next and put there all the transpiled

00:29:51,049 --> 00:29:55,880
files under those files which will need

00:29:53,690 --> 00:29:58,010
to transfer which you use some features

00:29:55,880 --> 00:30:01,370
not supported by minimum required

00:29:58,010 --> 00:30:03,799
version you want to support and then in

00:30:01,370 --> 00:30:07,309
your entry point of your jam

00:30:03,799 --> 00:30:09,470
you only need to call this method set up

00:30:07,309 --> 00:30:13,820
general all particularly probably too

00:30:09,470 --> 00:30:16,789
long which again use the knowledge about

00:30:13,820 --> 00:30:18,890
blow path induce the following trick so

00:30:16,789 --> 00:30:22,760
it detects the current ruby version

00:30:18,890 --> 00:30:25,730
detects the corresponding RB next folder

00:30:22,760 --> 00:30:28,120
with the transpiled files and add this

00:30:25,730 --> 00:30:31,309
folder to the load path before the

00:30:28,120 --> 00:30:33,110
original library folder that makes ruby

00:30:31,309 --> 00:30:35,840
for all the subsequent require calls

00:30:33,110 --> 00:30:38,029
first check this transpiled files folder

00:30:35,840 --> 00:30:40,250
if the feature is present there use it

00:30:38,029 --> 00:30:43,549
and if it's not then go to the original

00:30:40,250 --> 00:30:46,690
folder this way we only add this folder

00:30:43,549 --> 00:30:50,179
to the load path again if we need to

00:30:46,690 --> 00:30:51,980
support this version so for the latest

00:30:50,179 --> 00:30:54,710
version nothing gonna happen at all

00:30:51,980 --> 00:30:58,299
so this way we can shape transpile file

00:30:54,710 --> 00:31:02,149
along with gems and make it transparent

00:30:58,299 --> 00:31:06,039
well everything i was talking about is

00:31:02,149 --> 00:31:10,730
available on github and it even works

00:31:06,039 --> 00:31:12,770
currently we support most cindex

00:31:10,730 --> 00:31:15,559
features from to section to seven well

00:31:12,770 --> 00:31:17,929
except from start lestranges because

00:31:15,559 --> 00:31:20,179
well I don't figure out whether we need

00:31:17,929 --> 00:31:21,919
them at all and we don't support this

00:31:20,179 --> 00:31:24,350
new feature of pattern matching which is

00:31:21,919 --> 00:31:27,200
called one line pattern matching without

00:31:24,350 --> 00:31:30,789
case because it's haven't been released

00:31:27,200 --> 00:31:36,230
and even in preview versions of Ruby so

00:31:30,789 --> 00:31:38,570
but it's gonna be someday there the

00:31:36,230 --> 00:31:40,970
question arise what about compatibility

00:31:38,570 --> 00:31:43,549
how safe it is to use this transpile

00:31:40,970 --> 00:31:49,940
code how do we prove that it's

00:31:43,549 --> 00:31:52,389
correct well to make it you know not

00:31:49,940 --> 00:31:56,029
100% of course because it's impossible

00:31:52,389 --> 00:31:59,600
but to make it as correct as the Ruby

00:31:56,029 --> 00:32:01,399
implementation we use two sources of

00:31:59,600 --> 00:32:05,570
tests we do not write tests ourselves

00:32:01,399 --> 00:32:08,360
mostly we use a project called Ruby spec

00:32:05,570 --> 00:32:09,860
so the specification for Ruby language

00:32:08,360 --> 00:32:12,590
so the collection of tests other

00:32:09,860 --> 00:32:13,759
implementations used to be confirmed to

00:32:12,590 --> 00:32:17,570
conform with the Ruby

00:32:13,759 --> 00:32:20,809
I'm arrived and well unfortunately Ruby

00:32:17,570 --> 00:32:22,940
spec is not ready four to seven features

00:32:20,809 --> 00:32:25,759
there are no tests for pattern matching

00:32:22,940 --> 00:32:29,419
for example for those features we use

00:32:25,759 --> 00:32:31,159
Ruby's own test for this feature so we

00:32:29,419 --> 00:32:33,739
just grab tests from Ruby it's like a

00:32:31,159 --> 00:32:35,480
1000 line for pattern matching and we

00:32:33,739 --> 00:32:38,299
make sure that works in our versions we

00:32:35,480 --> 00:32:41,869
want to support that kind of guarantee

00:32:38,299 --> 00:32:45,049
is that at least we transpile code the

00:32:41,869 --> 00:32:48,019
way Ruby implement in a implementation

00:32:45,049 --> 00:32:49,820
assumes it should work it doesn't mean

00:32:48,019 --> 00:32:51,619
that it works exactly the same because I

00:32:49,820 --> 00:32:53,869
don't think that everything is every

00:32:51,619 --> 00:32:56,499
edge case is covered with tests in Ruby

00:32:53,869 --> 00:33:00,769
but well at least we tried

00:32:56,499 --> 00:33:04,639
so what's next what we can do with this

00:33:00,769 --> 00:33:06,980
except from well funny let's use modern

00:33:04,639 --> 00:33:09,639
features and every application and

00:33:06,980 --> 00:33:13,759
library will build it's kind of a just a

00:33:09,639 --> 00:33:17,779
bad project but we can go a bit further

00:33:13,759 --> 00:33:20,239
first of all we can change the title of

00:33:17,779 --> 00:33:23,419
the talk to make

00:33:20,239 --> 00:33:24,679
Oh Ruby squawk like a new one and I mean

00:33:23,419 --> 00:33:26,600
by all rubies I mean other

00:33:24,679 --> 00:33:29,899
implementations which we have a lot of

00:33:26,600 --> 00:33:32,539
them and this is a place where routine

00:33:29,899 --> 00:33:34,629
acts could be useful because well all of

00:33:32,539 --> 00:33:37,100
this implementation will eventually

00:33:34,629 --> 00:33:39,710
implement the new features but it would

00:33:37,100 --> 00:33:41,899
take some time and it could be quite a

00:33:39,710 --> 00:33:44,299
lot of time what we can do is ribbon

00:33:41,899 --> 00:33:48,619
axis all users of this technologists to

00:33:44,299 --> 00:33:50,659
start using new features right now so

00:33:48,619 --> 00:33:54,169
say it was M Ruby Alpo are too sharp

00:33:50,659 --> 00:33:55,930
reason whatever so too last one is

00:33:54,169 --> 00:33:59,330
actually M Ruby but anyway

00:33:55,930 --> 00:34:17,090
that's one of the way we can apply this

00:33:59,330 --> 00:34:20,090
idea but there is more I know yeah what

00:34:17,090 --> 00:34:22,070
else we can do is this that's kind of a

00:34:20,090 --> 00:34:24,170
new idea which I came up right well

00:34:22,070 --> 00:34:26,930
again I gonna mention this accident with

00:34:24,170 --> 00:34:32,090
method reference because so it's kind of

00:34:26,930 --> 00:34:33,920
confused so I see an opportunity for the

00:34:32,090 --> 00:34:36,890
project like this maybe some different

00:34:33,920 --> 00:34:41,060
project I know to be more than just a

00:34:36,890 --> 00:34:43,370
found tool so let's cycle this talk and

00:34:41,060 --> 00:34:50,180
come to the upgrade question new

00:34:43,370 --> 00:34:52,460
features will either start upgrade

00:34:50,180 --> 00:34:55,060
through to selling because we have new

00:34:52,460 --> 00:34:58,940
shiny features I don't think so because

00:34:55,060 --> 00:34:59,780
they're experimental and that labels

00:34:58,940 --> 00:35:02,210
changed everything

00:34:59,780 --> 00:35:05,480
I'm not going to use experimental

00:35:02,210 --> 00:35:08,330
features in my 10 years old monolith

00:35:05,480 --> 00:35:10,940
because I don't want to rewrite them the

00:35:08,330 --> 00:35:12,710
day their Ruby core team decided they no

00:35:10,940 --> 00:35:15,640
longer needed this feature so I'm not

00:35:12,710 --> 00:35:18,640
going to use them that's a problem

00:35:15,640 --> 00:35:18,640
experimental

00:35:18,710 --> 00:35:24,410
that should be it one more time and one

00:35:21,799 --> 00:35:28,940
more and maybe we can call it X

00:35:24,410 --> 00:35:31,039
Palermo's but yeah that's a word that

00:35:28,940 --> 00:35:34,039
actually change that's a very powerful

00:35:31,039 --> 00:35:37,220
world and this world and this world they

00:35:34,039 --> 00:35:39,890
both really powerful and they both

00:35:37,220 --> 00:35:43,609
destructing so this word distracts the

00:35:39,890 --> 00:35:46,460
idea of giving an opportunity to use new

00:35:43,609 --> 00:35:52,099
features to community so we need an

00:35:46,460 --> 00:35:54,529
experiment but we first need to have to

00:35:52,099 --> 00:35:58,549
kind of come up with the process of

00:35:54,529 --> 00:35:59,299
experimenting some guidelines and why I

00:35:58,549 --> 00:36:01,910
don't think so

00:35:59,299 --> 00:36:03,170
well that's to two examples like Matt's

00:36:01,910 --> 00:36:05,869
or dimensions that there are some

00:36:03,170 --> 00:36:10,220
numbers pipeline operators swiped three

00:36:05,869 --> 00:36:12,500
and a half months okay method reference

00:36:10,220 --> 00:36:15,859
almost year and it passed the first

00:36:12,500 --> 00:36:19,369
release candidate and it was cancelled

00:36:15,859 --> 00:36:22,250
and actually no one knows why well

00:36:19,369 --> 00:36:22,730
probably a few people but they're not in

00:36:22,250 --> 00:36:26,630
this room

00:36:22,730 --> 00:36:28,970
well it clear that we don't have a

00:36:26,630 --> 00:36:32,000
process of dealing with new features of

00:36:28,970 --> 00:36:35,210
introducing new things new but big

00:36:32,000 --> 00:36:37,250
things into the language let's take a

00:36:35,210 --> 00:36:38,809
look at how others do this again

00:36:37,250 --> 00:36:41,630
JavaScript I'm not a JavaScript

00:36:38,809 --> 00:36:45,589
developer but well they have some good

00:36:41,630 --> 00:36:49,520
parts in their community as well oh they

00:36:45,589 --> 00:36:51,410
have this tc39 committee which works on

00:36:49,520 --> 00:36:53,690
the evolution of echo scripts of the

00:36:51,410 --> 00:36:55,789
station and they have a process of

00:36:53,690 --> 00:36:57,980
passing pictures along the stages and

00:36:55,789 --> 00:36:59,720
they have for example this candidate

00:36:57,980 --> 00:37:01,579
stage which is very similar to what we

00:36:59,720 --> 00:37:06,950
have now in Ruby 2/7 experimental

00:37:01,579 --> 00:37:10,270
features and there is a important point

00:37:06,950 --> 00:37:14,150
here will require feedback from users

00:37:10,270 --> 00:37:15,740
not from the commuters not from the core

00:37:14,150 --> 00:37:19,640
team not from the implementation

00:37:15,740 --> 00:37:23,599
developers from users and even more the

00:37:19,640 --> 00:37:26,150
already mentioned Babel is often used as

00:37:23,599 --> 00:37:28,789
a source of true for committee to decide

00:37:26,150 --> 00:37:31,910
whether we want to add this feature or

00:37:28,789 --> 00:37:33,140
not let's ask users of Babel who already

00:37:31,910 --> 00:37:36,830
use this

00:37:33,140 --> 00:37:40,010
flagged by experimental whether it's

00:37:36,830 --> 00:37:41,990
good or not can we improve it that's the

00:37:40,010 --> 00:37:45,910
process we don't have such process in

00:37:41,990 --> 00:37:48,890
Ruby and we can't do this because it's

00:37:45,910 --> 00:37:51,680
impossible to evaluate a new feature

00:37:48,890 --> 00:37:55,370
using a whole word example you need to

00:37:51,680 --> 00:37:58,370
try it in the application you're working

00:37:55,370 --> 00:38:02,120
on every day in some kind of maybe

00:37:58,370 --> 00:38:07,780
production app whatever it will caught

00:38:02,120 --> 00:38:12,460
not in their sin taking example so

00:38:07,780 --> 00:38:16,220
that's the big idea which I know how to

00:38:12,460 --> 00:38:19,430
tell it to gorging maybe I have to come

00:38:16,220 --> 00:38:21,590
to Japan to do that but anyway that's

00:38:19,430 --> 00:38:23,600
what I think about if I want to work on

00:38:21,590 --> 00:38:26,060
this project I'm going to make it

00:38:23,600 --> 00:38:30,140
something big and not just a tool to

00:38:26,060 --> 00:38:31,900
experiment with all the Ruby hackery so

00:38:30,140 --> 00:38:36,400
don't wait for Christmas

00:38:31,900 --> 00:38:40,800
start using Ruby next thank you

00:38:36,400 --> 00:38:48,089
[Applause]

00:38:40,800 --> 00:38:48,089
[Music]

00:38:50,370 --> 00:38:52,430

YouTube URL: https://www.youtube.com/watch?v=T6epHXlUmG0


