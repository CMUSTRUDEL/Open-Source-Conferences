Title: RubyConf 2019 - Principles of Awesome APIs and How to Build Them by Keavy McMinn
Publication date: 2019-11-27
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Principles of Awesome APIs and How to Build Them by Keavy McMinn

We know the theory of what makes for a good API: it should be consistent, stable, and well documented. However, when we struggle to put good principles into practice, the API becomes difficult for your teammates and frustrating for your users. So, how do we pragmatically implement APIs in line with good principles? In particular, how do we get a bundle of engineers to do this together?

This is a talk for those curious about designing, building, and maintaining modern APIs. We’ll look at specific tooling and strategies to help improve and maintain the quality, consistency, and stability of your API. You’ll learn how to proactively make improvements to these areas, and how to make it easier to shepherd API development in your company.

#confreaks #rubyconf2019
Captions: 
	00:00:12,380 --> 00:00:14,340
Good morning, everyone!  [ Applause ]

00:00:14,340 --> 00:00:19,910
Don't do that! Thanks. Several years ago, I spent some time training on the island of

00:00:19,910 --> 00:00:26,610
Lanzarote. It's a place many triathletes love to hit. You can ride for hours without

00:00:26,610 --> 00:00:34,480
seeing a single car, but the weather and landscape can be brutal. 

00:00:34,480 --> 00:00:38,160
When I first rode there, I had to stop a few moments into the ride, because I couldn't

00:00:38,160 --> 00:00:43,260
believe how strong the wind was. I thought I was going to be blown clean off my bike. But

00:00:43,260 --> 00:00:50,360
I'm an idiot and I decided to train for the ironman race there. I am kind of small, and

00:00:50,360 --> 00:00:57,780
on a triathlon bike, the wind can push me around. It was gruelling. Some days the

00:00:57,780 --> 00:01:04,260
headwind was so strong that I had to work really hard to inch forward at all. And I

00:01:04,260 --> 00:01:10,020
finished fast descents in such a state of shock to still be upright that my legs trembled

00:01:10,020 --> 00:01:15,020
for minutes.  I remember at the end of my first training

00:01:15,020 --> 00:01:23,011
day, I said to my friends, this course and its weather was too tough for me. I don't

00:01:23,011 --> 00:01:31,039
think I can do it. A more experienced friend offered me great advice. She said try to

00:01:31,039 --> 00:01:38,079
work with the wind. Don't fight it all the time. Otherwise I'd just exhaust myself. Initially

00:01:38,079 --> 00:01:42,659
I wasn't too sure how to physically do that when you have to go in a certain direction. But

00:01:42,659 --> 00:01:48,950
through practice, I got better at getting a sense for what the wind was doing and assessing

00:01:48,950 --> 00:01:55,710
the risk and learning to work with my bike and my body. I gradually learned how to judge

00:01:55,710 --> 00:02:04,350
the crosswinds, how to ride at a 30 degree angle, literally leaning into it. And I shifted

00:02:04,350 --> 00:02:11,310
my mental attitude. I stopped trying to ignore or fight it. And I developed a respect for

00:02:11,310 --> 00:02:16,849
the wind. I used to talk out loud to it, as you do. 

00:02:16,849 --> 00:02:24,130
The wind was just a fact, and it was a waste of my energy to wish it was any different. Accepting

00:02:24,130 --> 00:02:36,800
and embracing that made all the difference.  A good API needs to be consistent, stable,

00:02:36,800 --> 00:02:43,280
and well‑documented. We know this. As consumers ourselves, these are the qualities

00:02:43,280 --> 00:02:52,950
we want from APIs that we have to use. As consumers, we know how annoying a poor API

00:02:52,950 --> 00:02:59,030
experience can be. We might be totally dependent on an API for our product, but yet we don't

00:02:59,030 --> 00:03:05,660
have any control over it. We have to react to it. Perhaps sometimes scrambling to get

00:03:05,660 --> 00:03:11,820
it updated just in time with producers' changes. And that's when we even know about the change

00:03:11,820 --> 00:03:18,280
in advance.  Or we might use a handful of APIs to help

00:03:18,280 --> 00:03:24,700
with smaller tasks, maybe someone set up a chron job that runs a script and produces

00:03:24,700 --> 00:03:31,110
an API and produces a monthly report. We're not monitoring it because it's just a little

00:03:31,110 --> 00:03:37,030
script somewhere. And it works just fine like that for years, and then the department

00:03:37,030 --> 00:03:42,320
that reads that monthly report starts to notice that the numbers just look a bit off. So,

00:03:42,320 --> 00:03:47,610
you dig and eventually discover that the API is not returning numbers the same way. So,

00:03:47,610 --> 00:03:51,590
now half the data in that report is just wrong or missing. 

00:03:51,590 --> 00:04:02,010
If an API change is handled poorly, it can be really painful for us as consumers. Then

00:04:02,010 --> 00:04:09,490
from our experience as producers, there's a certain type of developer who doesn't like

00:04:09,490 --> 00:04:17,009
things to be wrong. You may know this type or be one yourself. The type of developer

00:04:17,009 --> 00:04:22,910
who writes scripts to catch the inconsistencies in your code base, refactors the whole test

00:04:22,910 --> 00:04:29,820
suite to make sure every scenario is covered efficiently. They notice all the details

00:04:29,820 --> 00:04:36,700
and give the most thoughtful and considered code review. This is not me, by the way. 

00:04:36,700 --> 00:04:45,350
But this is someone you want on your API team. But the struggle for them is sometimes when things

00:04:45,350 --> 00:04:54,450
are wrong with an API, they have to stay wrong. Sometimes you can't fix things because your users are

00:04:54,450 --> 00:05:00,370
accustomed to the wrong thing, so fixing it would actually break it. And that can be

00:05:00,370 --> 00:05:08,020
really hard for some developers to accept.  Being able to change the API or not, as the

00:05:08,020 --> 00:05:17,601
case often is, is probably the biggest pain point we feel as developers of APIs. I want

00:05:17,601 --> 00:05:23,000
to just pause for a second to remind ourselves what an API is, and why that ability to change

00:05:23,000 --> 00:05:30,871
is so hard.  For many of our use cases, an API is the interface

00:05:30,871 --> 00:05:37,370
between our product and its users. It's interacted with by a code on the user's side to perform

00:05:37,370 --> 00:05:46,240
something for their product. When we're developing software for humans to use, if we change how

00:05:46,240 --> 00:05:52,660
it looks or works slightly, the humans might get confused, but they'll figure it out. When

00:05:52,660 --> 00:06:02,200
it's computers on the other side, that's not gonna fly. Code can't just figure it out. 

00:06:02,200 --> 00:06:08,310
So because our users rely on our API's code interacting in the moment with their code,

00:06:08,310 --> 00:06:16,110
by the nature of that territory, it needs to be a very conservative space for development. When

00:06:16,110 --> 00:06:21,230
we're developing APIs, we're bound by many constraints, centered around the communication

00:06:21,230 --> 00:06:27,710
and expectations between both sides of that interface. That's the nature of developing

00:06:27,710 --> 00:06:32,639
APIs. Similar to the realities of riding your bike in the wind, we're developing in

00:06:32,639 --> 00:06:41,250
a landscape of constant constraints.  If we want to produce an awesome API, which

00:06:41,250 --> 00:06:48,160
we know means being consistent, stable, and well‑documented, we need to work with those

00:06:48,160 --> 00:06:53,910
constraints. Trying to fight the reality of APIs, the nature of that interface is doomed

00:06:53,910 --> 00:07:00,790
to failure for the product and misery for us as developers. 

00:07:00,790 --> 00:07:05,620
From other areas of development, we might be used to imposing our will on the product,

00:07:05,620 --> 00:07:10,130
so it might be frustrating for us to not be able to make changes how and when we want,

00:07:10,130 --> 00:07:17,500
but that's the nature of building APIs. So, we can either be miserable, fighting those

00:07:17,500 --> 00:07:25,190
constraints, or we can embrace them.  One thing that I think is useful for us to

00:07:25,190 --> 00:07:30,860
remember is that these constraints are good for us, too. If you're writing an API for

00:07:30,860 --> 00:07:34,910
yourself, for a hobby project where you're the producer and consumer, you can do whatever

00:07:34,910 --> 00:07:42,419
you want where you want. But this talk is for building APIs for other people to use. You

00:07:42,419 --> 00:07:48,290
want people to use your product, service, tool. 

00:07:48,290 --> 00:07:56,240
The API might be the foundation of your entire service, or it might enable your product to

00:07:56,240 --> 00:08:01,380
grow and evolve through the creativity and power of all the tools that build on top of

00:08:01,380 --> 00:08:07,630
it.  The ability to build an ecosystem around your

00:08:07,630 --> 00:08:16,270
product through the API is hugely powerful for a business. It increases the value exponentially. You're

00:08:16,270 --> 00:08:23,600
brokering relationships between parties that otherwise might not be able to connect. But

00:08:23,600 --> 00:08:31,360
each time you break the API, that's one less tool that can work with your service. 

00:08:31,360 --> 00:08:36,949
So these constraints, when respected, offer both sides some protection. They enable our

00:08:36,949 --> 00:08:43,269
users to lend their trust to build their software on top of ours, and they also enable us to

00:08:43,269 --> 00:08:51,210
grow and maintain a wide user base that enables us to be successful. 

00:08:51,210 --> 00:08:57,580
So here are some ways that I've found useful for embracing and working with those constraints,

00:08:57,580 --> 00:09:06,149
to help achieve those main principles of being consistent, stable, and well‑documented. First,

00:09:06,149 --> 00:09:14,149
to be consistent, we need to be rigorously consistent in how we represent our data. For

00:09:14,149 --> 00:09:22,670
example, if a user has a property of Admin that is returned as a Boolean in one end point,

00:09:22,670 --> 00:09:29,450
it shouldn't be returned as a string or integer in another. And you might think, well, of

00:09:29,450 --> 00:09:35,161
course. We wouldn't do that. And no one would intentionally. But as an API code base

00:09:35,161 --> 00:09:40,880
or team grows, these inconsistencies can slip through to the public interface really easily. And

00:09:40,880 --> 00:09:49,250
that's particularly easy to slip through when there are multiple apps that make up a public

00:09:49,250 --> 00:09:52,980
API.  So to help avoid those mistakes, we can use

00:09:52,980 --> 00:09:58,600
tooling to help maintain the consistency of our API's data. And there are a lot of choices

00:09:58,600 --> 00:10:06,460
for this. These are just a few. These recoveries or specs provide a specific way to describe

00:10:06,460 --> 00:10:14,520
what objects exist in your API, what they look like, and how people can work with them. 

00:10:14,520 --> 00:10:21,510
My preferred option is JSON schema, because it's relatively simple, but flexible and powerful. For

00:10:21,510 --> 00:10:28,020
example, you can use it to validate user input as well as your output. 

00:10:28,020 --> 00:10:34,240
And in this conservative nature of API development, it's usually best to approach any shiny, new

00:10:34,240 --> 00:10:39,590
thing with caution. So, it's reassuring to know JSON schema has been around for years,

00:10:39,590 --> 00:10:45,201
and it's battle‑tested in production by several APIs that many of us know and use

00:10:45,201 --> 00:10:55,830
like Heroku, GitHub, and soon, Fastly.  A schema can be the one source of truth for

00:10:55,830 --> 00:11:02,490
your API. Knowing that your source for data is accurate means you can confidently use

00:11:02,490 --> 00:11:10,839
it to do things like generate documentation examples. Test the representation of objects

00:11:10,839 --> 00:11:17,990
or your requests, some responses, and validate user input. I'm going to talk about JSON

00:11:17,990 --> 00:11:24,690
schema, but you might prefer to choose a different tool. The important thing is that you use

00:11:24,690 --> 00:11:31,360
something as your one source of truth. Select the tool that best suits your context, your

00:11:31,360 --> 00:11:37,110
organization, your code base.  So there are some particularly handy tools

00:11:37,110 --> 00:11:44,520
for working with JSON schema in Ruby. The committee gem enables you to perform validation

00:11:44,520 --> 00:11:50,459
of user requests of that user‑supplied input against your schema, which makes it really

00:11:50,459 --> 00:11:56,180
easy to provide the user with immediate feedback if, say, they supply a parameter that's the

00:11:56,180 --> 00:12:01,800
wrong type or not quite formatted correctly. And you can do that validation centrally before

00:12:01,800 --> 00:12:10,339
a request even hits specific end point code.  The PRMD gem enables you to combine and verify

00:12:10,339 --> 00:12:16,230
multiple schema files, which is super useful once you're beyond needing to describe one

00:12:16,230 --> 00:12:22,480
or two objects. It's much easier to manage those in a smaller chunk of JSON at a time. So,

00:12:22,480 --> 00:12:33,230
you might have one schema files for users and another for teams, say. 

00:12:33,230 --> 00:12:38,390
You can see the schema for some APIs online. For example, Heroku have an end point to read

00:12:38,390 --> 00:12:45,291
the schema for their API. And that's a super‑useful way to learn through real‑life examples

00:12:45,291 --> 00:12:51,100
of seeing the constraints that someone else applies to their data as a complement to the

00:12:51,100 --> 00:12:58,640
examples you'll find in the docs.  And if you're thinking this all sounds fantastic,

00:12:58,640 --> 00:13:04,910
let's go back to work and make a schema to enforce consistency. It'll be amazing. A

00:13:04,910 --> 00:13:10,980
word of warning. Building a schema file like this is the ideal if you have a greenfield

00:13:10,980 --> 00:13:17,769
project or just have the luxury of a fresh start. If you have an existing API, you probably

00:13:17,769 --> 00:13:24,360
can't apply a schema in all of those ways, because you probably have a whole bunch of

00:13:24,360 --> 00:13:31,110
inconsistencies in your API. You might not know about them all yet, but if it was left

00:13:31,110 --> 00:13:36,410
up to humans at this point, you probably do. And that's okay. Everyone has skeletons in their

00:13:36,410 --> 00:13:42,370
API closet.  So where you don't have a schema, a safer

00:13:42,370 --> 00:13:49,850
starting point would be first to get a measure of your inconsistencies. So, you could take

00:13:49,850 --> 00:13:55,040
a close look at your documented responses, run some comparisons between the response

00:13:55,040 --> 00:14:01,550
examples in your docs and the responses you get when you actually make a call to the API. It

00:14:01,550 --> 00:14:06,529
might take a bit of time to set up a test with sample data, and you might need to parse

00:14:06,529 --> 00:14:12,820
the examples you give in your documentation. But then you can write Ruby scripts to make real

00:14:12,820 --> 00:14:20,959
requests to your APIs for each of those and compare the results against the documentation. 

00:14:20,959 --> 00:14:26,300
You could note where and how the responses are different. Are there any additional keys

00:14:26,300 --> 00:14:32,649
or missing keys in the hashes? Are any of the attribute's classes different than you

00:14:32,649 --> 00:14:39,310
said? And if those Booleans that are actually a string? I did this recently. And even

00:14:39,310 --> 00:14:45,370
the exercise of reading your docs and forming all of those requests is highly beneficial. It's

00:14:45,370 --> 00:14:50,279
a really good way to familiarize yourself with the public interface and see things from

00:14:50,279 --> 00:14:53,290
the consumer's position and build up that empathy. 

00:14:53,290 --> 00:15:01,060
You could create a schema for a small portion of the API. Say in your app you have a user

00:15:01,060 --> 00:15:06,870
object and some end points for users. You could try writing a schema just for those,

00:15:06,870 --> 00:15:11,450
and then run your tests for the user end points against that schema and see how many of your

00:15:11,450 --> 00:15:17,750
tests feel and how they feel. You could even do that in production and just log where the

00:15:17,750 --> 00:15:24,899
mismatches are. And if the output is actually what you really want, then you can correct

00:15:24,899 --> 00:15:31,830
the schema to reflect that. But if the schema was correct, and the output doesn't match

00:15:31,830 --> 00:15:36,940
it, then you can't change that output immediately, because that's the Output your users have

00:15:36,940 --> 00:15:45,110
gotten used to. So, it would break things on their side if you fixed it. 

00:15:45,110 --> 00:15:52,790
Then, it can be really interesting and pretty effective to get a better understanding of

00:15:52,790 --> 00:15:58,040
the inconsistencies by taking a deep look through the code through parsing the code,

00:15:58,040 --> 00:16:04,459
using code to analyze the code. I've used the whitequark parser for this job. It's

00:16:04,459 --> 00:16:13,330
a parser for Ruby written in Ruby.  You can use this gem to parse your code and

00:16:13,330 --> 00:16:21,010
form abstracts and text trees, ASTs, which as the tree name suggests, gives you an object

00:16:21,010 --> 00:16:25,010
that you can then crawl around in to find the branchs and leaves that you're most interested

00:16:25,010 --> 00:16:32,550
in. This doesn't need to be pretty or polished. My own scripts that do this are definitely not. But

00:16:32,550 --> 00:16:39,250
this kind of tooling isn't going into production. It's meant to help you explore the code and tell

00:16:39,250 --> 00:16:45,100
you things that you're curious about.  For example, you could use a parser to peer

00:16:45,100 --> 00:16:52,470
into end point code and see what's being called. Maybe you would monitor and measure the calls around

00:16:52,470 --> 00:16:57,760
authentication. You can note what methods are being used, what arguments are passed

00:16:57,760 --> 00:17:05,601
to those, what classes the arguments are. Parsing the code with code is hugely powerful, but

00:17:05,601 --> 00:17:11,919
just exploring this at all can give you really useful insights. 

00:17:11,919 --> 00:17:15,880
Seeing your inconsistencies can help you make decisions about them. Maybe you have done

00:17:15,880 --> 00:17:21,750
a thing three ways, but now you can pick the one way that you want to deliberately choose

00:17:21,750 --> 00:17:28,620
for the future. I've done this recently for the code base at Fastly where the public API

00:17:28,620 --> 00:17:33,950
is formed across multiple apps, and it's given us insights and measures into a ton of useful

00:17:33,950 --> 00:17:39,650
information that would be otherwise pretty difficult to do. 

00:17:39,650 --> 00:17:44,480
And I think as a bonus, looking at and measuring these things can set you up nicely to basically

00:17:44,480 --> 00:17:51,970
have a custom linter that would help you monitor your code in the future. 

00:17:51,970 --> 00:17:59,010
So getting to consistent data might be a methodical process with painstakingly slow work, but

00:17:59,010 --> 00:18:15,419
then it will be amazing.  The 

00:18:15,419 --> 00:18:25,299
second big principle of good API is stable. If you do one thing, I recommend simply to think

00:18:25,299 --> 00:18:35,570
deeply and write down what the API is for. What each end point is for. This sounds so simple

00:18:35,570 --> 00:18:40,700
that many people don't do it, preferring instead to dig into the more technical work of writing

00:18:40,700 --> 00:18:48,200
code or specs. But even with API‑specific specs, I think you get distracted by the syntax

00:18:48,200 --> 00:18:54,270
and the opinions of the tooling. And all of that can come later. But as a starting

00:18:54,270 --> 00:18:59,500
point, I believe it's way more beneficial to write down just in plain language what

00:18:59,500 --> 00:19:08,799
the API is for. That seemingly simple thing is hard to do, but it's important. So, in

00:19:08,799 --> 00:19:16,940
high‑level design for an API, I recommend including the usage examples for any new end

00:19:16,940 --> 00:19:21,549
points. What would users do with it? What variations might they do? What workflows

00:19:21,549 --> 00:19:27,549
would it need to support? What does your business need from it? What are the potential

00:19:27,549 --> 00:19:33,299
performance issues? What would happen if there were 10,000 of the objects that could potentially

00:19:33,299 --> 00:19:40,660
be returned? What does it look like? What does the path look like? Are there any parameters

00:19:40,660 --> 00:19:47,330
in the path? What do they look like? And what will you call it? Keeping in mind that

00:19:47,330 --> 00:19:52,340
if you can't think of a neat title for an end point, that's probably a sign that your

00:19:52,340 --> 00:19:59,570
design is a bit off.  And remember, of course, there's a cost in

00:19:59,570 --> 00:20:05,540
adding new end points. More code to write, test, maintain, document, and do code review

00:20:05,540 --> 00:20:12,080
for. So, you want to consider, do we really need this addition? Do you REALLY want to

00:20:12,080 --> 00:20:20,490
walk that dog every morning when you're tired and there's a blizzard blowing outside? And

00:20:20,490 --> 00:20:26,220
write those high‑level design docs before you write any code, before you have invested

00:20:26,220 --> 00:20:32,539
in a particular approach, while the cost of change is low. The more thought and care

00:20:32,539 --> 00:20:36,610
you put into the API design up‑front, the more chance of shipping the right thing in

00:20:36,610 --> 00:20:45,030
the first place and reducing the risk of change later. 

00:20:45,030 --> 00:20:53,530
So we need the API to be a calm, predictable, and reliable space. But that interface is

00:20:53,530 --> 00:21:01,169
surrounded by things which are not calm. Everything is changing. Our product, the technology

00:21:01,169 --> 00:21:07,710
choices to build and document our API, our users' needs and workflows, our assumptions

00:21:07,710 --> 00:21:14,250
about our users' needs, our legal obligations, security vulnerabilities, bugs in the code,

00:21:14,250 --> 00:21:20,789
our teammates, our company's leadership, their priorities. The API is at the center of a

00:21:20,789 --> 00:21:30,610
constant state of flux. On top of that, our API also has to change in order to stay relevant

00:21:30,610 --> 00:21:36,921
to that wider context. So, the stable center has to change with everything else, but that

00:21:36,921 --> 00:21:46,340
change has to be very controlled, if indeed it's even possible. 

00:21:46,340 --> 00:21:55,650
So we have this constant friction between the need to change and our constraints. As

00:21:55,650 --> 00:22:01,990
developers or shepherds of the API, it's good for us to be aware of that friction and the

00:22:01,990 --> 00:22:09,200
demands for change, but not to react to all of those demands all of the time. We need

00:22:09,200 --> 00:22:16,130
to optimize for walking the API along a very stable, thoughtful, and kind path through

00:22:16,130 --> 00:22:21,490
all of that. Sometimes that will mean pushing back against some of those forces that might

00:22:21,490 --> 00:22:28,730
disturb the calm center. That might involve asking a lot of questions, helping to find

00:22:28,730 --> 00:22:35,420
creative ways to absorb the problem on your side rather than inflict it on the consumer. Or

00:22:35,420 --> 00:22:43,130
sometimes saying no or not yet.  Shepherds of the API often aren't the most

00:22:43,130 --> 00:22:50,350
popular people in the engineering org. So, if you don't mind being unpopular, come join

00:22:50,350 --> 00:22:59,860
your local API team. Some literature on API development will say that change is bad and

00:22:59,860 --> 00:23:07,980
therefore you should simply never make breaking changes to your API. I don't buy that approach. To

00:23:07,980 --> 00:23:13,470
me, it's not working with the constraints, it's more like punting on them. And don't

00:23:13,470 --> 00:23:20,080
get me wrong. Breaking changes should be very rare and a last resort. But in reality,

00:23:20,080 --> 00:23:28,530
the need will arise. We need to be able to evolve our API along with our product and

00:23:28,530 --> 00:23:39,410
respond to emergency situations like a major availability or security problem. 

00:23:39,410 --> 00:23:44,980
And if you really think about it, change itself is not necessarily bad. It's negative impact

00:23:44,980 --> 00:23:53,660
from change that is bad. So, the goal is to minimize the negative impact. A great

00:23:53,660 --> 00:24:00,400
way to help with that is to provide transitions. Provide a transition workflow or a way for users to

00:24:00,400 --> 00:24:09,740
adapt to the new thing. And that could take different forms. One would be previews, for

00:24:09,740 --> 00:24:17,240
example, the GitHub API releases new or changed end points under a preview, which is a specific

00:24:17,240 --> 00:24:25,830
accept header that you can opt into using. Versioning, for example, the stripe API offer very granular

00:24:25,830 --> 00:24:32,890
versions on a date basis and commit to supporting all previous versions, which must be a huge

00:24:32,890 --> 00:24:39,299
undertaking behind the scenes. With either of those approaches, you want to be sure that

00:24:39,299 --> 00:24:46,620
users can use multiple versions, say one on staging as they try out and prepare for new

00:24:46,620 --> 00:24:53,669
behavior, but continue to use a different version on production. 

00:24:53,669 --> 00:24:57,790
Another simple way to provide a transition, say, for example, if you really need to change

00:24:57,790 --> 00:25:03,770
the name of an attribute, you could provide both old and the new names for some transition

00:25:03,770 --> 00:25:11,930
period before you remove the old one. Whatever form you choose or combination thereof, the

00:25:11,930 --> 00:25:20,070
key is to provide a way for users to transition to the new thing gracefully. 

00:25:20,070 --> 00:25:24,760
But accept that the reality is that we may not be able to reach everyone. And that some

00:25:24,760 --> 00:25:32,840
users may not take any action. So, it's highly unlikely going to achieve zero impact. The

00:25:32,840 --> 00:25:40,690
only way to get to zero is probably if you have zero users. In which case, cool...

00:25:40,690 --> 00:25:47,980
The goal is to minimize the negative impact as much as you can reasonably do. And lastly,

00:25:47,980 --> 00:25:59,980
an awesome API needs to be well‑documented. Provide clear information to users on how you intend

00:25:59,980 --> 00:26:07,660
to change or break the API through things like documenting your deprecation policy,

00:26:07,660 --> 00:26:12,830
for which I recommend you provide generous conservative timeframes for. Expectations

00:26:12,830 --> 00:26:20,909
around any kind of preview periods, for which I recommend you provide short time frames

00:26:20,909 --> 00:26:25,950
for, otherwise people forget it's not really the final version and not really suitable

00:26:25,950 --> 00:26:32,460
for production. And do provide a change log with specific information on all the changes

00:26:32,460 --> 00:26:39,940
and how developers can adapt to use those.  Being explicit and transparent about these

00:26:39,940 --> 00:26:45,640
things gives users some confidence in the process and builds trust, which is a crucial

00:26:45,640 --> 00:26:54,950
ingredient to sustain an awesome API. And then remember that people don't read. 

00:26:54,950 --> 00:27:00,040
[ Laughter ] So even if you've given all the notices and

00:27:00,040 --> 00:27:05,530
warnings, news of upcoming changes won't reach all your users, even with the best will in

00:27:05,530 --> 00:27:13,590
the world, even with great monitoring and usage metrics, you may not be able to reach

00:27:13,590 --> 00:27:20,040
your users. Maybe the people that wrote the code using your API are no longer the people

00:27:20,040 --> 00:27:28,750
who maintain it or care. The first time some people will notice a change is when their

00:27:28,750 --> 00:27:35,500
thing that depended on it stops working. To help compensate, you can also make use of

00:27:35,500 --> 00:27:41,909
brinites, where after all the regularly timed notices, you would schedule a deploy of the

00:27:41,909 --> 00:27:50,180
change temporarily, maybe just for an hour, but just enough time for people to freak out. And

00:27:50,180 --> 00:27:55,120
then you withdraw that and give people more time to adapt to the upcoming change on their

00:27:55,120 --> 00:28:03,710
side before you make the switch for real.  There's so much detail to get right on an

00:28:03,710 --> 00:28:10,070
end point‑by‑end point basis, that it's easy to not look up and see the overall picture. But

00:28:10,070 --> 00:28:14,830
it's highly beneficial to provide a way for some people to see a holistic view of the

00:28:14,830 --> 00:28:22,480
API. And I mean inside your company, I should say. But even having scripts that can capture

00:28:22,480 --> 00:28:27,590
a measure of key data points, which maybe you stick in a spreadsheet could give your

00:28:27,590 --> 00:28:33,559
API or product team some useful insights. The beauty of this work is that it doesn't go

00:28:33,559 --> 00:28:39,180
near production. So, it doesn't have to be pretty or polished. Just something that enables

00:28:39,180 --> 00:28:45,980
you to take a holistic view of that data whenever you need to. 

00:28:45,980 --> 00:28:52,440
For example, you may capture a note of things like which endpoints are undocumented, which

00:28:52,440 --> 00:28:58,700
endpoints are in some state of not public. Maybe a private beta or preview, and did they enter

00:28:58,700 --> 00:29:06,150
that phase? Anything that's earmarked to be deprecated. And when those are due to

00:29:06,150 --> 00:29:14,590
be removed all together.  In order to collectively build and maintain

00:29:14,590 --> 00:29:21,900
the consistency and stability, you need to govern choices and decisions. Having written

00:29:21,900 --> 00:29:28,040
down internal guidelines on how your company builds APIs would make it easier for everyone,

00:29:28,040 --> 00:29:37,450
both current and future teammates to build a consistent, stable API. Make sure you have

00:29:37,450 --> 00:29:44,010
clear guidelines on how to make changes. Any ambiguity on how to make changes can be a

00:29:44,010 --> 00:29:50,900
major source of stress and frustration for engineering teams. So, set clear expectations

00:29:50,900 --> 00:29:59,570
and share guidance internally on what's okay or not okay and how to go about making changes. 

00:29:59,570 --> 00:30:04,770
It's super‑useful to have an internal API style guide where, if it's a restful API,

00:30:04,770 --> 00:30:11,270
you might include things like what patterns for paths are okay or not okay, or that URLs

00:30:11,270 --> 00:30:20,159
with a verb or adjective in them is a smell. So, you could encourage a fault of design to work

00:30:20,159 --> 00:30:27,870
for that 95% use case and allow you to fine‑tune some results. Of course, there will be exceptions

00:30:27,870 --> 00:30:33,620
to any rule. One example from the GitHub API, there's a fetch to the latest release,

00:30:33,620 --> 00:30:40,350
which clearly has an adjective in the path. That was a conscious design decision, because

00:30:40,350 --> 00:30:47,200
users almost always want just the latest release. So, for that exceptional type of case, it's a

00:30:47,200 --> 00:30:57,110
better interface if it optimizes for the common use case, even if it's not textbook restful. 

00:30:57,110 --> 00:31:05,059
Some choices will be uncontroversial, where there's fairly clear good design and bad design. With

00:31:05,059 --> 00:31:10,480
some choices around how you implement an API, there is no correct answer. And people will

00:31:10,480 --> 00:31:17,960
have valid arguments for different approaches. But here's the thing: Most of this, the specific

00:31:17,960 --> 00:31:28,580
choice doesn't really matter. What's important is that you make a choice and apply it consistently. 

00:31:28,580 --> 00:31:34,700
Your internal guidelines will always be guidelines and decisions will need to be created by humans

00:31:34,700 --> 00:31:43,240
weighing out the trade‑offs. So lastly, in your internal documentation, I highly recommend

00:31:43,240 --> 00:31:49,520
writing down who is responsible for what. To build and maintain an awesome API, your group

00:31:49,520 --> 00:31:55,300
needs to have a clear understanding of ownership and the decision‑making process. When that's

00:31:55,300 --> 00:32:02,899
ambiguous, it creates frustration. And just wastes time and energy. Also, it encourages

00:32:02,899 --> 00:32:09,260
poor quality code as endpoints become orphaned if no one specifically owns them. No one

00:32:09,260 --> 00:32:16,429
fixes the flakey tests or bugs that arise, because hey, it's not their code. 

00:32:16,429 --> 00:32:22,559
So I recommend carefully deciding and writing down things like who's responsible for building

00:32:22,559 --> 00:32:29,059
APIs for new features. Who's responsible for the underlying concepts, the plumbing. And

00:32:29,059 --> 00:32:35,429
with documentation, who is responsible for which parts of that work? 

00:32:35,429 --> 00:32:40,789
Everything needs an owner, a responsible party. And that information should be written down and

00:32:40,789 --> 00:32:50,140
easily discoverable. And then who gets a say in the decision‑making process? I find

00:32:50,140 --> 00:32:55,899
many people get uncomfortable setting up a decision‑making process up front, maybe

00:32:55,899 --> 00:33:03,059
preferring to try to attain consensus. If that's the case in your group, I suggest it's

00:33:03,059 --> 00:33:10,550
worth asking what happens when we can't? And maybe it's worth writing down that answer

00:33:10,550 --> 00:33:22,440
just in case you don't have consensus.  So that island became one of my favorite places

00:33:22,440 --> 00:33:27,820
to train and race. I spent weeks and weeks out there. I got to know the roads like the

00:33:27,820 --> 00:33:34,020
back of my hand. It made me a better athlete, not just the technical skills, but with my

00:33:34,020 --> 00:33:41,740
mental toughness. And sure, I loved to ride my bike on a calm, sunny day, but I know I

00:33:41,740 --> 00:33:49,280
can adjust my mindset and embrace the day when the conditions get tough. I love working

00:33:49,280 --> 00:33:58,029
with APIs. And not even despite but because of the winds that come with that territory. I

00:33:58,029 --> 00:34:04,649
love making something that helps other developers make something. That people would choose

00:34:04,649 --> 00:34:10,829
to build on top of what I build. That's a pretty special thing to be part of, and I

00:34:10,829 --> 00:34:19,029
take that privilege seriously. So, I hope you find something useful in some of these

00:34:19,029 --> 00:34:25,289
ways that I find helpful to work with the constraints to build awesome APIs. But the

00:34:25,289 --> 00:34:30,899
important bit is that you don't fight your constraints. Know what they are. Plan for

00:34:30,899 --> 00:34:38,579
them. Work with your constraints. And I want to leave you with this quote. 

00:34:38,579 --> 00:34:46,639
It doesn't have to be fucking hard. It just has to be consistent. Which is fucking hard. 

00:34:46,639 --> 00:34:50,129
[ Laughter ] He's talking about training for Iron Man triathlons,

00:34:50,129 --> 00:34:55,009
but I think it sums up API development pretty well. Thank you. 

00:34:55,009 --> 00:34:56,449

YouTube URL: https://www.youtube.com/watch?v=NgFm7qAhv9g


