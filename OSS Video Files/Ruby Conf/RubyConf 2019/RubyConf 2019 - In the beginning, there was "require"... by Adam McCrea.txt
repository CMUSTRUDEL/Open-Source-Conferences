Title: RubyConf 2019 - In the beginning, there was "require"... by Adam McCrea
Publication date: 2019-11-29
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - In the beginning, there was "require"... by Adam McCrea

Almost every Ruby program begins with the "require" method, but many of us don't pause to think about what it's doing until it fails us.

What happens when we call "require"? How does Ruby find what we're looking for? Is Bundler somehow involved? What about "requirerelative" and "requiredependency", and what the heck is a "binstub"?

This talk will guide beginner and intermediate Rubyists through these foundational concepts that power our Ruby programs, from single-file script to a behemoth Rails 6 app.

#confreaks #rubyconf2019
Captions: 
	00:00:13,679 --> 00:00:22,561
>> Hello. Good afternoon. I want to tell you a story about why I'm here giving you

00:00:22,561 --> 00:00:28,800
this talk today, and it's a little bit of a confession. Earlier this summer, I was

00:00:28,800 --> 00:00:35,980
working on a project that was adding some custom video processing for file uploads on

00:00:35,980 --> 00:00:43,020
a Rails application, and it had me looking through the source code for active storage. While

00:00:43,020 --> 00:00:51,140
I was in there, I came across these lines of code. And I didn't know what they did. I

00:00:51,140 --> 00:00:55,360
was fooling with require, but I had never seen a require dependency before. I didn't

00:00:55,360 --> 00:01:01,829
know why they were there. I didn't know if they were part of Ruby or part of Rails. So,

00:01:01,829 --> 00:01:08,009
I did what a curious developer does in that situation. I shoved that curiosity aside

00:01:08,009 --> 00:01:13,710
because I had a task to do.  Fortunately those lines were inconsequential

00:01:13,710 --> 00:01:18,460
to what I was doing. It wasn't a big deal. But it was pretty soon after that that I needed

00:01:18,460 --> 00:01:24,520
to package this code into an engine to pull into our Rails application. And while Rails

00:01:24,520 --> 00:01:29,720
gives you boilerplate code, it's up to you where you put the engine and how you require

00:01:29,720 --> 00:01:35,420
it and some of the glue that holds the engine together, and again I found myself in unfamiliar

00:01:35,420 --> 00:01:42,360
territory. And I was really uncomfortable with this knowledge gap, but I needed to face

00:01:42,360 --> 00:01:51,470
it head‑on, and I decided to cargo cult the engine and find another solution. That

00:01:51,470 --> 00:01:56,230
is when we use an idea or code from somebody else that we don't really understand how it

00:01:56,230 --> 00:02:01,840
works or why it was used. And I've cargo culted far more often than I am comfortable

00:02:01,840 --> 00:02:06,950
admitting.  Ultimately I got this thing done, but I was

00:02:06,950 --> 00:02:12,450
feeling ashamed and embarrassed that I never took the time to dig in and understand how

00:02:12,450 --> 00:02:20,200
this stuff worked. I just plowed through it to get the job done. And I was embarrassed

00:02:20,200 --> 00:02:26,189
because I have been writing Ruby applications professionally for 12 years. How can I do

00:02:26,189 --> 00:02:32,440
it for that long and not understand how to require code for a Ruby application? So my

00:02:32,440 --> 00:02:40,450
goal is to fill that knowledge gap that I had and that maybe some of you have as well. 

00:02:40,450 --> 00:02:46,700
Before I do that, quick introduction. My name is Adam McCrea. I go by Adam logic everywhere

00:02:46,700 --> 00:02:59,269
online. I work for you need a budget, also known as ynab. I built a Heroku add‑on

00:02:59,269 --> 00:03:05,559
that will make your lives easier if you're running a Rails app on Heroku. 

00:03:05,559 --> 00:03:19,589
I think of dependencies as coming in three flavors. So, first we've

00:03:19,589 --> 00:03:27,650
got standard library code. This is things like csv, open uri, logger, things that are

00:03:27,650 --> 00:03:32,870
packaged with Ruby, but we do need to require them to be able to use them. 

00:03:32,870 --> 00:03:38,510
Then we've got Rubygems. This is code that other folks have written. They have generously

00:03:38,510 --> 00:03:45,309
open sourced it and made it available to the world and we want to pull it into our projects. Finally

00:03:45,309 --> 00:03:52,519
we've got code that exists with our own projects. Obviously for anything of size, we want to split it

00:03:52,519 --> 00:04:00,079
up and put it in modules and subdirectories and do that stuff and glue the files together.

00:04:00,079 --> 00:04:09,579
And every language has a way of doing this. PHP has include. Node.js has require, ES6 does

00:04:09,579 --> 00:04:16,329
the same thing with import. And of course in Ruby we have require. And require_relative

00:04:16,329 --> 00:04:23,460
and require understand dependency, load, autoload, and Bundler, and of course, Rails where everything

00:04:23,460 --> 00:04:28,000
happens magically and you don't have to require anything. 

00:04:28,000 --> 00:04:33,440
As I dove in, I was blind sided but about little I knew about the nuances and techniques

00:04:33,440 --> 00:04:42,280
available to us. As I was learning, I kind of fit things into a mental model where I've

00:04:42,280 --> 00:04:49,599
got this matrix, and things on the left side, these are things that are eagerly loaded. Ruby's

00:04:49,599 --> 00:04:54,819
going to go and get the dependency and evaluate it when we ask it to. On the right side we

00:04:54,819 --> 00:05:00,240
have lazy loaded dependencies. We're going to tell Ruby we need a thing, but don't go

00:05:00,240 --> 00:05:07,120
get it yet. Go get it later if you have to, and we'll see what thatk loos like. On the

00:05:07,120 --> 00:05:12,830
top we've got explicit dependencies. This means we're telling Ruby exactly what we want

00:05:12,830 --> 00:05:17,300
and where to get it from.  And on the bottom, we have implicit dependencies.

00:05:17,300 --> 00:05:21,789
That means our program needs to just figure out where to get things from. We're not going

00:05:21,789 --> 00:05:25,409
to tell it exactly where the files live that we need. 

00:05:25,409 --> 00:05:31,509
So let's dive in and talk about the star of the show, which is require. Require is really

00:05:31,509 --> 00:05:37,020
the foundation of all of these methods and to understand it, let's take a look at some

00:05:37,020 --> 00:05:43,099
examples. The simplest thing you can do with require is requiring a standard library like

00:05:43,099 --> 00:05:49,460
CSV. It comes with ruby. But if we try to reference CSV without requiring it, we will

00:05:49,460 --> 00:05:56,009
get an error. We need to require it first. Require returns true, that means yes, we found this

00:05:56,009 --> 00:06:01,110
thing. We've loaded it. Everything is great. And now we can use CSV. If we try to require

00:06:01,110 --> 00:06:07,229
again, it returns false because we have loaded the thing. We don't need to load it again. It's

00:06:07,229 --> 00:06:12,449
not an error state. It's saying nothing happened. You can require things multiple times and it's

00:06:12,449 --> 00:06:19,909
essentially a no op. So, what is require? Require is a method. It's a method on the kernel

00:06:19,909 --> 00:06:25,560
module along with others that we use a lot like puts and rays. And because they're on

00:06:25,560 --> 00:06:29,759
kernel, that means we can call them from anywhere. And because they're just methods, that means they

00:06:29,759 --> 00:06:38,610
can be overwritten.  When we pass a string like csv to require,

00:06:38,610 --> 00:06:46,080
what it does is it looks like a global variable in Ruby called LOAD_PATH. It is an array

00:06:46,080 --> 00:06:54,270
of file system paths, and a system that will go through each of them in order looking for

00:06:54,270 --> 00:06:57,680
this file that ‑‑ this name that we asked for. We asked for csv, so it will look for

00:06:57,680 --> 00:07:07,020
csv.rb. It will look at each of our directors in load path. It will find it because the

00:07:07,020 --> 00:07:13,370
standard libraries are all in load path out of the box. But we can add to load path,

00:07:13,370 --> 00:07:20,691
as you will see in a bit.  So when it finds the csv file and loads it,

00:07:20,691 --> 00:07:29,169
it will add it to another global variable called loaded features. It's a list of every

00:07:29,169 --> 00:07:34,320
feature that require has loaded. So, when we try to load it again, require knows not

00:07:34,320 --> 00:07:42,779
to load it again. Csv.rb is going to be in loaded features along with a lot of other

00:07:42,779 --> 00:07:49,970
related stuff because csv.rb had its own requires and it required other things as well. So,

00:07:49,970 --> 00:07:56,090
that's requiring a standard library.  Requiring a gem looks very similar. So, minitest

00:07:56,090 --> 00:08:02,749
is a gem. If I try to use it without requiring it, it's gonna be an error. I need to require

00:08:02,749 --> 00:08:10,240
it. And once I require it, I can use it. This looks, on the surface to require in the standard

00:08:10,240 --> 00:08:16,490
library. But there is a subtle difference. If we were to look at our load path before we

00:08:16,490 --> 00:08:22,871
required minitest, we would see that minitest actually is not in our LOAD_PATH, until we

00:08:22,871 --> 00:08:29,729
require it and then it is. What's happening here is called gem activation. Remember how

00:08:29,729 --> 00:08:37,690
we talked about require is a method? Ruby gems overrides it to give the gem activation

00:08:37,690 --> 00:08:47,810
functionality. So, what happens in the Rubygems version of require? 

00:08:47,810 --> 00:08:52,680
First thing it does is it checks loaded features just like the original require method. In

00:08:52,680 --> 00:09:04,500
our case, minitest hadn't been required yet. It is now a LOAD_PATH. I did have minitest installed

00:09:04,500 --> 00:09:11,980
and at that point it's going to add the gem's lib folder to the LOAD_PATH, so when it proceeds

00:09:11,980 --> 00:09:20,850
with the original required behavior, it will find it and be able to load minitest.rb from

00:09:20,850 --> 00:09:28,399
the lib folder. There's an asterisk next to lib there because you can actually change

00:09:28,399 --> 00:09:38,820
the name of the folder in a gem spec when you author a gem. Most of them will use that

00:09:38,820 --> 00:09:44,670
name.  So the third thing that I want to require

00:09:44,670 --> 00:09:51,300
in the project are files that's actually within our project. And here we've got a very simple

00:09:51,300 --> 00:09:57,959
file structure. We've got a main.rb and an example.rb inside of an example lib directory. We

00:09:57,959 --> 00:10:04,880
want to require example from main. Simple enough thing. What's gonna happen if we try

00:10:04,880 --> 00:10:14,279
to require example or try to require lib/example? These are both gonna fail. Require is just gonna

00:10:14,279 --> 00:10:20,821
go through our load path. And this particular project isn't in our LOAD_PATH. So, we need

00:10:20,821 --> 00:10:26,050
to take some different steps. There are different alternatives we can use here. We can give

00:10:26,050 --> 00:10:34,230
require an absolute system path. So, it lives on my machine and this works. Obviously it's

00:10:34,230 --> 00:10:39,089
very brittle. Anything could change on my machine. I could move things around. I can't

00:10:39,089 --> 00:10:44,570
share this with anybody. It's very coupled to my machine in this moment. So, generally

00:10:44,570 --> 00:10:48,980
not a great idea to do this. We can change it a little bit, though, to make it a relative

00:10:48,980 --> 00:10:55,060
file system path. Now it's no longer tied to my machine. And this will work. It's

00:10:55,060 --> 00:11:02,600
a little better. But there's a gotcha. It's relative to the working directory where you've

00:11:02,600 --> 00:11:09,040
executed this program from. So, in this case, if we go up to a parent directory and so instead

00:11:09,040 --> 00:11:16,170
of just executing main.rb, we execute project/main.rb, now our require isn't going to work because

00:11:16,170 --> 00:11:23,490
we have changed our working directory.  Okay. So, how can we reliably require this

00:11:23,490 --> 00:11:32,440
example file? One option is to actually add our lib directory to our $LOAD_PATH. If we

00:11:32,440 --> 00:11:46,990
are going to require a lot of things from this lib directory, and then we can require

00:11:46,990 --> 00:12:04,850
example. Anything else. This does what we just did, adding the lib directory to $LOAD_PATH

00:12:04,850 --> 00:12:12,620
so we can require things from it. And this is really useful in tests. So, if we have

00:12:12,620 --> 00:12:17,139
an example test file, and within that file we want to require a test helper, something

00:12:17,139 --> 00:12:23,199
like that, it's really handy to have the test directory in our $LOAD_PATH. But we only

00:12:23,199 --> 00:12:28,610
want the test directory in our $LOAD_PATH when we're running tests. So, it's really

00:12:28,610 --> 00:12:34,920
handy to be able to, at runtime just include the test directory in our $LOAD_PATH. And

00:12:34,920 --> 00:12:40,649
we can run tests this way or write a rake task or some other executable to do that for

00:12:40,649 --> 00:12:45,199
us. But what if we don't want to mess with the $LOAD_PATH? What's another option to

00:12:45,199 --> 00:12:56,519
reliably require? That's where require_relative comes in. 

00:12:56,519 --> 00:13:09,490
This was depend on the current working directory. Require_relative fixes that. It is always relative from where

00:13:09,490 --> 00:13:14,650
it's called. If we got it in main.rb, it will be relative to main.rb no matter where

00:13:14,650 --> 00:13:18,769
the program is executed from. This would work great. 

00:13:18,769 --> 00:13:27,819
Quickly, let's talk about load. Load looks a lot like require. Except for the little

00:13:27,819 --> 00:13:31,990
difference that you actually have to put the file extension on there. But the much bigger

00:13:31,990 --> 00:13:37,740
difference with load is every time you call it, it's re‑evaluating that file, which

00:13:37,740 --> 00:13:43,520
is gonna be problematic if it's going to be redefining constants and obviously you don't

00:13:43,520 --> 00:13:51,350
want to take the time to reload things. This is mostly useful in an irb or console situation

00:13:51,350 --> 00:13:56,639
or if you're writing your own library kind of thing. In most applications you almost

00:13:56,639 --> 00:14:04,060
never want to use load.  All right. Let's talk about Bundler. To

00:14:04,060 --> 00:14:15,240
understand why Bundler is so important, let's revisit our minitest example. When you require

00:14:15,240 --> 00:14:24,699
minitests, they worked great. But if you look at the versions, I have two different

00:14:24,699 --> 00:14:31,269
versions of minitest. Which version actually got required? In this case, it's the most

00:14:31,269 --> 00:14:35,709
recent version. Rubygems is always going to require the most recent version. If this

00:14:35,709 --> 00:14:41,540
is a script I wrote for myself, that's fine. But if I want to share with other people, we want

00:14:41,540 --> 00:14:45,449
to make sure that others are using the same version as well. And that's the problem that

00:14:45,449 --> 00:14:53,600
Bundler solves for us. We create a gem file and in that gem file we declare the gems that

00:14:53,600 --> 00:15:00,639
our program needs and the version restrictions that we care about. And when we run bundle

00:15:00,639 --> 00:15:05,410
install, it's gonna make sure that we have installed versions of those gems that match

00:15:05,410 --> 00:15:13,079
those version restrictions. It's gonna create a lock file called Gemfile.lock to lock our

00:15:13,079 --> 00:15:19,389
project to the exact installed versions of those gems. Now when anybody else that we

00:15:19,389 --> 00:15:25,540
share this with if we deploy it to another environment runs bundle.install, the exact

00:15:25,540 --> 00:15:33,540
versions will be installed. Now that we've done that, we can require minitest, and which

00:15:33,540 --> 00:15:40,790
version is going to get required? It's actually not the version we wanted. We locked our

00:15:40,790 --> 00:15:45,310
version to minitest 5.11, but we required 5.12.

00:15:45,310 --> 00:15:52,150
Why didn't we get the locked version? We're still using Rubygems version of require, which

00:15:52,150 --> 00:15:57,900
is going to use the most recently installed version and we have version 5.12 installed. So,

00:15:57,900 --> 00:16:06,540
if we want to require the appropriate version, we need Bundler's help with that as well. So,

00:16:06,540 --> 00:16:13,000
we bring in Bundler. We call Bundler.setup. This goes through the lock file and for all of

00:16:13,000 --> 00:16:21,310
our locked gems, it will add those lib directories to our $LOAD_PATH so when we call require

00:16:21,310 --> 00:16:29,500
after that, the minitest gem doesn't have to be added. It's already in our $LOAD_PATH

00:16:29,500 --> 00:16:34,050
so require can just go through the $LOAD_PATH and find the right version and we're good

00:16:34,050 --> 00:16:39,700
to go.  This idea of setting up the $LOAD_PATH and

00:16:39,700 --> 00:16:47,830
requiring Bundler can put that together for us in a single command, Bundler.require. Bundler.require

00:16:47,830 --> 00:16:55,639
sets up our $LOAD_PATH and requires everything that we've defined in our gem file unless

00:16:55,639 --> 00:17:02,790
we've explicitly opted out of any of those through the require: False option. If we

00:17:02,790 --> 00:17:09,560
put this into our gem file, when we call, it's going to skip over anything that is opted

00:17:09,560 --> 00:17:12,040
out and we would need to manually require that gem. 

00:17:12,040 --> 00:17:19,970
So that's Bundler. For the moment I'm going to skip over require_dependency. We're going

00:17:19,970 --> 00:17:29,150
to skip over to the lazy quadrant. That means we're telling Ruby about a dependency but

00:17:29,150 --> 00:17:35,420
it's not going to evaluate it yet. It's gonna do it later. Let's see what that means. In

00:17:35,420 --> 00:17:39,540
our example file, we're defining a class and spitting out some outputs so we know when

00:17:39,540 --> 00:17:47,770
it's required. And if instead of requiring it, if we auto load it, when we auto load

00:17:47,770 --> 00:17:52,420
it, it's not actually going to go and read that file at all. Nothing happens here. Nothing

00:17:52,420 --> 00:17:59,190
happens until we reference the example constant that we pass to auto load. So, we say auto

00:17:59,190 --> 00:18:03,820
load example, example is the name of the constant that's gonna trigger the loading. And then

00:18:03,820 --> 00:18:09,470
we give it a path just like we would give to require. In fact, autoload calls require

00:18:09,470 --> 00:18:17,170
under the hood. When we call for the first time, that's when it happens. If we never

00:18:17,170 --> 00:18:25,480
reference the example constant, it would never be loaded. That means our program will initially

00:18:25,480 --> 00:18:30,080
load faster because we're not initially loading a lot of things. We're deferring the loading

00:18:30,080 --> 00:18:36,540
to later on. And it also means that for a library where maybe the consumers of that

00:18:36,540 --> 00:18:40,431
library aren't going to use all the pieces of it, a lot of things never have to be loaded

00:18:40,431 --> 00:18:48,160
at all. And a lot of libraries do use this. One example is Rack. And I picked Rack just because

00:18:48,160 --> 00:18:57,440
it has a whole bunch of them. The main rack.rb file has over 40 autoload calls in the beginning. And

00:18:57,440 --> 00:19:03,840
some of those have their own autoload calls so there's a lot of that going on there. 

00:19:03,840 --> 00:19:08,190
And notice for in this Rack example, we did not have to modify $LOAD_PATH at all because

00:19:08,190 --> 00:19:13,150
it's a gem and when the gem gets activated, the gem's lib directory gets loaded into the

00:19:13,150 --> 00:19:17,370
path. So, within the context of a gem, we don't have to worry about manually adding

00:19:17,370 --> 00:19:22,950
lib to the $LOAD_PATH like we did before.  So this kind of autoloading is built into

00:19:22,950 --> 00:19:31,630
Ruby. Rails autoloading is a different beast. These quadrants at the bottom, that's all Rails

00:19:31,630 --> 00:19:38,930
territory because Rails is built on the idea of convention over configuration. Another

00:19:38,930 --> 00:19:45,160
way of saying that is implicit over explicit. When you're building a Rails app, you don't need

00:19:45,160 --> 00:19:51,270
to explicitly require the application code. It's all implicit. If we fire up a Rails console,

00:19:51,270 --> 00:19:55,800
we can see what that looks like. When we fire it up and ask if the user constant is

00:19:55,800 --> 00:20:02,520
defined, it is not. It hasn't been loaded yet. If we try to use it, it gets automatically

00:20:02,520 --> 00:20:07,900
loaded and the constant does exist at that point. The benefit is it lets us write control

00:20:07,900 --> 00:20:14,520
like this. We can write Rails controller and models without requiring anything that

00:20:14,520 --> 00:20:21,890
it depends on. We are relying on application controller existing and user existing, but

00:20:21,890 --> 00:20:30,280
we're not explicitly requiring them. So, how does Rails go about this? Whenever it

00:20:30,280 --> 00:20:36,800
encounters one of those constants that hasn't been loaded yet, it's gonna look in a configuration

00:20:36,800 --> 00:20:47,370
called autoload_paths. It is an array of file system paths. And it's gonna look through

00:20:47,370 --> 00:20:54,720
those for a file that matches the name of the missing constant. If we're trying to

00:20:54,720 --> 00:21:00,080
reference a user constant, Rails is going to look at controllers for user.rb and then

00:21:00,080 --> 00:21:11,220
it will look at app/models and it will find it and load it. Any concerns directories

00:21:11,220 --> 00:21:17,720
under those. Basically anything in an app folder in a Rails app is going to be part

00:21:17,720 --> 00:21:24,890
of that autoload system.  But a very important distinction is that autoload_paths

00:21:24,890 --> 00:21:30,690
and $LOAD_PATH are completely separate and distinct things. Autoload_paths is Rails

00:21:30,690 --> 00:21:43,430
and $LOAD_PATH is used by require. A good example is lib. It's not in autoload_paths

00:21:43,430 --> 00:21:47,980
but we do often put the things in there that we need in our application. So, we actually

00:21:47,980 --> 00:21:56,240
do need to require them. But Rails does add lib to $LOAD_PATH so we can require them without

00:21:56,240 --> 00:22:01,520
resorting to require_relative or having to manually mess with $LOAD_PATH ourselves. 

00:22:01,520 --> 00:22:12,220
But what would happen if we added lib to autoload_path? Is it a good idea? We're gonna come back to

00:22:12,220 --> 00:22:20,570
that. Because we were just looking at Rails in development, which has this deferred, this

00:22:20,570 --> 00:22:27,040
lazy autoloading behavior. It's not gonna load things until we reference a missing constant. In

00:22:27,040 --> 00:22:33,430
production, things work differently. In production, we want to take the time up front to load

00:22:33,430 --> 00:22:37,970
everything so that when users come in with requests, those are as fast as possible and

00:22:37,970 --> 00:22:46,240
we're not loading things while the user waits for us. And the way this works is it's going

00:22:46,240 --> 00:22:52,790
to load every file it finds. Everything inside is going to be required at boot and if we

00:22:52,790 --> 00:22:59,340
put lib, it would eagerly load all of that stuff in production, and lib can often become

00:22:59,340 --> 00:23:05,670
a bit of a junk drawer. You may have things in there only needed in development or testing

00:23:05,670 --> 00:23:10,950
or whatever. So, that can be a little bit dangerous. That is why it's generally not

00:23:10,950 --> 00:23:24,990
advised to put lib in autoload_paths. Leave autoload_paths alone and require from lib. 

00:23:24,990 --> 00:23:30,100
So now we're finally at require_dependency, the thing that started this whole exploration

00:23:30,100 --> 00:23:37,200
for me. Turns out it is part of Rails, not part of Ruby. And it's part of the Rails

00:23:37,200 --> 00:23:42,721
autoloading system, and interestingly enough it's to force eager loading of something that

00:23:42,721 --> 00:23:49,080
would otherwise be autoloaded. What does that mean? Going back to this example, it

00:23:49,080 --> 00:23:55,160
makes a bit more sense if we look at the next three lines. So, we are requiring the three

00:23:55,160 --> 00:24:04,830
dependencies and then including those modules.  Normally we wouldn't need to do any explicit

00:24:04,830 --> 00:24:08,670
requiring, because the autoloading mechanism is going to autoled these for us, because

00:24:08,670 --> 00:24:14,730
when the active storage gem, they live in the app model, and everything inside of the

00:24:14,730 --> 00:24:24,350
app directories are autoloaded. So, when we include this analyzable module, when active_storage

00:24:24,350 --> 00:24:31,020
includes it, if it hadn't been loaded, the autoloading mechanism would kick in and require

00:24:31,020 --> 00:24:40,010
it and load it. But what if our application defined our own analyzable module? At the

00:24:40,010 --> 00:24:47,930
top level? The Rails autoloading mechanism wouldn't realize that. It would say we have

00:24:47,930 --> 00:24:52,830
an analyzable module so we don't need to autoload another one and it would be using the wrong

00:24:52,830 --> 00:24:59,150
one. So, require_dependency is a way of saying let's make sure we go and load this thing

00:24:59,150 --> 00:25:05,720
that we know we're gonna need and not let autoloading get potentially confused. 

00:25:05,720 --> 00:25:10,901
The irony is that this is actually not even necessary any more in Rails 6. This thing

00:25:10,901 --> 00:25:15,790
that sent me down this whole path is actually no longer necessary, because in Rails 6, the

00:25:15,790 --> 00:25:21,140
autoloading mechanism has been completely rewritten and it actually is smart enough

00:25:21,140 --> 00:25:31,260
to recognize that when we include analyzable and we're inside the active_storage/blob class,

00:25:31,260 --> 00:25:39,350
we will identify it before we use a top‑level analyzable. 

00:25:39,350 --> 00:25:47,920
So in Rails 6, if you're using the new autoloading mechanism, you actually don't even need require_dependency. Let's

00:25:47,920 --> 00:25:53,280
look at our take‑aways from all of this.  We looked at requiring standard libraries

00:25:53,280 --> 00:25:58,370
and the require method is our friend there. And even if we're within a Rails app, we still

00:25:58,370 --> 00:26:07,050
need to require standard libraries. Always. We looked at requiring gems and if it's something

00:26:07,050 --> 00:26:10,470
that you're writing just for yourself and you don't need to share it, just using require

00:26:10,470 --> 00:26:15,790
is fine. But anything that you want to be able to deploy or share, that's when you definitely

00:26:15,790 --> 00:26:20,230
want to be using Bundler to make sure that everybody is using the same versions. And

00:26:20,230 --> 00:26:26,490
to use that, Bundler.set up along with require along with bundle.require are worth using

00:26:26,490 --> 00:26:35,230
together and a lot of things will do that Bundler.require for you. In a Rails application

00:26:35,230 --> 00:26:42,510
you don't need to require gems because that is happening for you. 

00:26:42,510 --> 00:26:47,750
Within a project, if it's not a Rails project, you've got some options. We can use require_relative. That

00:26:47,750 --> 00:26:52,390
will work fine. If we're going to be requiring a lot of things from a common directory, we

00:26:52,390 --> 00:26:58,510
can add that directory to our $LOAD_PATH and use require or we can use autoload, especially

00:26:58,510 --> 00:27:04,470
if we're building a library. That's super helpful. 

00:27:04,470 --> 00:27:09,570
And finally within a Rails project, embrace the implicit autoloading. Don't try to work

00:27:09,570 --> 00:27:14,500
around it. Don't try to require something that's gonna be autoloaded and don't try to

00:27:14,500 --> 00:27:22,020
autoload something that is from the front. Follow the golden path and your life will be a whole

00:27:22,020 --> 00:27:27,630
lot easier.  So I hope this talk has filled a knowledge

00:27:27,630 --> 00:27:32,630
gap for some of you. I know it has for me. And I want to encourage you when you encounter

00:27:32,630 --> 00:27:38,040
these kind of knowledge gaps of your own, don't be afraid to dive in. Try to resist

00:27:38,040 --> 00:27:43,100
the urge to shove it aside. And don't be embarrassed about it because we all have knowledge

00:27:43,100 --> 00:27:48,790
gaps.  If you have any questions for me, I'm @Adamlogic

00:27:48,790 --> 00:27:59,370
on Twitter. I have some YNAB shirts and thank you so much for being here with me today. 

00:27:59,370 --> 00:27:59,390

YouTube URL: https://www.youtube.com/watch?v=I0a5zv7uBHw


