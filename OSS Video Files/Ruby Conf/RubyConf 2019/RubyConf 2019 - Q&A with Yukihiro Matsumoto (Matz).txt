Title: RubyConf 2019 - Q&A with Yukihiro Matsumoto (Matz)
Publication date: 2019-11-30
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Q&A with Yukihiro Matsumoto (Matz)

#confreaks #rubyconf2019
Captions: 
	00:00:12,360 --> 00:00:18,210
>> EVAN: My chair is missing a foot, and I don't want you to see me looking nervous,

00:00:18,210 --> 00:00:20,100
so we will eliminate this right now. And please give Barrett a hand. He didn't thank

00:00:20,100 --> 00:00:21,100
himself.  [ Applause ]

00:00:21,100 --> 00:00:22,100
All right. Where were we?  >> MATZ: Nashville? 

00:00:22,100 --> 00:00:24,900
>> EVAN: Oh thank you. Yes. Been a long couple days. Whoo! No. So, thanks for coming

00:00:24,900 --> 00:00:32,550
to the traditional Q&A. The way that we'll do this is we solicited some questions online,

00:00:32,550 --> 00:00:36,460
and then I also have some questions that I will just sprinkle in, and then we also have

00:00:36,460 --> 00:00:43,260
mics up here for you all to ask questions. So, if you have a question, you don't have to

00:00:43,260 --> 00:00:47,110
wait for me to finish. You can go ahead and line up. I will call on you and sprinkle

00:00:47,110 --> 00:00:52,790
them in. And yeah, just have a conversation and see where it takes us. 

00:00:52,790 --> 00:00:56,960
How was the conference?  >> MATZ: It was a great conference. Thank

00:00:56,960 --> 00:01:05,129
you. And I was a bit tired this year, so I missed many of the sessions. But I am looking

00:01:05,129 --> 00:01:10,240
forward to see the videos.  >> EVAN: Good. Ice‑breaker question. That

00:01:10,240 --> 00:01:18,970
went well. Maybe not. Maybe it didn't go well. All right. The questions online are

00:01:18,970 --> 00:01:22,210
really good. I think we will probably do that more in the future as well. It allowed

00:01:22,210 --> 00:01:28,150
people to expand on their question in written form. The first one we had is looking back

00:01:28,150 --> 00:01:33,140
at Ruby's history ‑‑ some of these will sound familiar. But I think people like asking

00:01:33,140 --> 00:01:37,050
you the same question year‑over‑year and see if they get a different answer. That's

00:01:37,050 --> 00:01:42,110
a fun game. Looking back at Ruby's history is there a language feature that you or the

00:01:42,110 --> 00:01:49,970
core team is especially proud of? Something that really stood the test of time? Or conversely,

00:01:49,970 --> 00:01:54,830
has there been anything in the Ruby community that has impressed you like a library or product

00:01:54,830 --> 00:02:00,090
or something like that?  >> MATZ: As a language, the invention of the

00:02:00,090 --> 00:02:14,840
block is remarkable for me. It is very small change, but it is readable and writable and

00:02:14,840 --> 00:02:20,780
pretty expressive.  For the libraries, the invention of Rubygem

00:02:20,780 --> 00:02:27,730
is very impressive. Actually, the very first version of Rubygem is written in the very

00:02:27,730 --> 00:02:33,260
first version of this conference.  >> EVAN: By David and Chad and Rich. I can't

00:02:33,260 --> 00:02:41,810
remember who exactly was in that room at the time. My follow‑up is we have two syntaxes

00:02:41,810 --> 00:02:46,560
for the block. Which one came first? Did the do end or the curly braces? 

00:02:46,560 --> 00:02:51,100
>> The brace comes first.  >> EVAN: And you were like oh, I need another

00:02:51,100 --> 00:02:55,720
way of doing this.  >> MATZ: Actually, before the first release

00:02:55,720 --> 00:03:13,569
of version 0.95, I released to my close friends that Ruby's Godfather told me that it was

00:03:13,569 --> 00:03:21,120
confusing. So, I enhanced the syntax.  >> EVAN: That's interesting. It was like

00:03:21,120 --> 00:03:28,810
oh, it would be nice to match them up, too. That's cool. 

00:03:28,810 --> 00:03:34,209
As we're looking at Ruby 3.0 and thinking about Ruby 3.0, are there ‑‑ there's

00:03:34,209 --> 00:03:40,670
a couple of questions about sort of like things that we might remove and part of the other

00:03:40,670 --> 00:03:48,349
sort of half of that question is do you ‑‑ like I know that you have talked about sort

00:03:48,349 --> 00:03:55,000
of the way that major version upgrades have gone in other languages. So, are you thinking

00:03:55,000 --> 00:03:59,569
of the two to three transition as it being a big transition for people? Like taking

00:03:59,569 --> 00:04:03,819
away a lot of things that they have to figure out how to replace? Or maybe talk a little

00:04:03,819 --> 00:04:10,099
bit about that?  >> MATZ: Yeah. Between Ruby version 1.8 and

00:04:10,099 --> 00:04:19,879
1.9, we had a huge jam for compatibility. And I think it was necessary, but it requires

00:04:19,879 --> 00:04:27,509
the community to migrate to the new version 1.9 for five or seven years. 

00:04:27,509 --> 00:04:32,830
>> EVAN: It was a while.  >> MATZ: It was a long time. Half of the

00:04:32,830 --> 00:04:39,060
community stays in the 1.8 for a long, long time. And you know, we at the core team,

00:04:39,060 --> 00:04:47,129
we made a lot of effort to improve the 1.9 so half of the Ruby community was left behind. So,

00:04:47,129 --> 00:04:56,189
I don't like that kind of tragedy. And as we see the similar tragedy in the Python community,

00:04:56,189 --> 00:05:02,469
so I feel even more stronger.  >> EVAN: So is there anything that ‑‑

00:05:02,469 --> 00:05:07,819
but it is on the flip side, it is opportunity to take things away. So, are there things

00:05:07,819 --> 00:05:11,660
you're thinking that you want to take away in Ruby 3? 

00:05:11,660 --> 00:05:20,289
>> MATZ: We are going to remove several features, several very trivial features, like the save

00:05:20,289 --> 00:05:34,259
variable for maybe the dialogue setting... some variable. But, they are very trivial. So,

00:05:34,259 --> 00:05:44,639
we took several years to remove them. Once you be warned to use that feature, then you

00:05:44,639 --> 00:05:49,099
got error for using that feature. Then we totally remove the feature in the future or

00:05:49,099 --> 00:05:52,729
something like that.  >> EVAN: I don't recall if you talked about

00:05:52,729 --> 00:06:00,129
this on day one. It's been a couple of days now. So, we're looking at Ruby 2.7 for this

00:06:00,129 --> 00:06:08,039
coming up this year. And how many are we gonna have Ruby 2.8 or 2.9? Do you have thoughts?

00:06:08,039 --> 00:06:12,509
Do we get Ruby 2.10?  >> MATZ: No. 

00:06:12,509 --> 00:06:21,650
>> EVAN: So three minor versions left?  >> MATZ: Actually, as I mentioned in the keynote,

00:06:21,650 --> 00:06:31,210
so there's No. 2.8 or 2.9. We are going to plan to release 3.0 next year. 

00:06:31,210 --> 00:06:35,970
>> EVAN: Okay.  >> MATZ: Whatever happens...

00:06:35,970 --> 00:06:39,579
[ Laughter ] Unless extremely bad things happen. 

00:06:39,579 --> 00:06:47,569
>> EVAN: All right. Good. Let's see. So, let's see here. What else? I don't know

00:06:47,569 --> 00:06:52,379
who this might have been, because they didn't attach names on purpose. But someone wanted

00:06:52,379 --> 00:06:59,969
to know if you have changed your mind about macros in Ruby 3.0. I don't know who might

00:06:59,969 --> 00:07:04,619
have asked that.  >> MATZ: No! That is a long question, but

00:07:04,619 --> 00:07:13,849
basically no. In 2.6, we exposed ast so we can build from the Ruby program. Then you

00:07:13,849 --> 00:07:22,409
can tweak the ast and you can generate the bytecode from that so you can create that

00:07:22,409 --> 00:07:33,770
intermediate processing of the program. That means that you can implement some kind of

00:07:33,770 --> 00:07:38,529
macro using that kind of tool.  >> EVAN: So you're saying there's a chance? 

00:07:38,529 --> 00:07:42,889
>> MATZ: Yeah, there's a chance, but not actually in the language. 

00:07:42,889 --> 00:07:46,419
>> EVAN: Maybe pre‑processing hooks before you parse and then...

00:07:46,419 --> 00:07:54,469
>> MATZ: Yeah, those kind of things. And also some pop mentioned about the transpiler, the

00:07:54,469 --> 00:08:03,280
compiler, they are tweaking the transpiler so you can have another chance to have something

00:08:03,280 --> 00:08:12,789
similar to macro. Maybe you can extract a new language features using that kind of a

00:08:12,789 --> 00:08:15,770
transpiler.  >> EVAN: Um, yeah. Let's see. Don't forget,

00:08:15,770 --> 00:08:21,819
if you have questions, please, the mic is right here. It's not just my time. It's

00:08:21,819 --> 00:08:32,209
your time. If you have questions, please come up to the mics, and I will call on you. Let's

00:08:32,209 --> 00:08:38,780
see if anyone's at the mics. Oh! I've already covered macros. 

00:08:38,780 --> 00:08:47,230
>> I'm not going to ask about macros. Is the pipeline operator gonna come back? 

00:08:47,230 --> 00:08:59,769
>> MATZ: I would say there's a chance.  >> EVAN: The pipeline operator, if we could

00:08:59,769 --> 00:09:04,950
talk about it for a second, it might be an interesting view into how Ruby core decides

00:09:04,950 --> 00:09:11,360
on what experiments to take and how you evaluate the experiment and whether or not to go forward

00:09:11,360 --> 00:09:16,480
with it. So, could you maybe talk about, like, who presented it, how you did the evaluation

00:09:16,480 --> 00:09:24,230
and came up with the decision to pull it out?  >> MATZ: Okay. I was the one who introduced

00:09:24,230 --> 00:09:33,190
the idea of the pipeline operator into Ruby at Ruby Kaigi this year. And then we discussed

00:09:33,190 --> 00:09:45,519
a little bit and we experimented a bit. And we had several controversy. And then we found

00:09:45,519 --> 00:09:53,500
out that people expect pipeline operator to behave like Elixir pipeline operator. It

00:09:53,500 --> 00:10:06,100
was surprising for me. So, you know, after considering a little bit, a little while. Then

00:10:06,100 --> 00:10:16,279
it's not worth frustrating the whole community. And I just, you know, retract the idea. 

00:10:16,279 --> 00:10:24,819
Maybe after the idea, we come up with a consensus of the behavior of pipeline operator, really

00:10:24,819 --> 00:10:30,430
consider it.  >> EVAN: Okay. That's a good question that

00:10:30,430 --> 00:10:34,589
someone had submitted, which is sort of around functional programming. Obviously the pipeline

00:10:34,589 --> 00:10:40,970
operator is sort of a form of that. You know, are there any other things, like you ‑‑

00:10:40,970 --> 00:10:48,860
like maybe talk about what was the thing that drove you to say oh, maybe we should have

00:10:48,860 --> 00:10:55,339
a pipeline operator? Was it looking at Elixir and other functional languages? Are there

00:10:55,339 --> 00:10:59,790
things out there that makes you think maybe we can have something that does like this

00:10:59,790 --> 00:11:08,320
or other features that you have considered?  >> MATZ: We considered pattern matching from

00:11:08,320 --> 00:11:16,629
the functional programming language, and then we merged ‑‑ we take it. And what else? What

00:11:16,629 --> 00:11:21,720
else?  We have very teeny idea like an immutable

00:11:21,720 --> 00:11:28,640
struct or something like that. But it's not a big deal, so maybe we add them in the next

00:11:28,640 --> 00:11:33,980
release or something. But not for Ruby 2.7.  >> EVAN: Okay. Okay. So, maybe expanding

00:11:33,980 --> 00:11:40,680
frozen?  >> MATZ: Yeah, maybe we have syntax to create

00:11:40,680 --> 00:11:52,279
a JSON‑linked tree using the immutable hash or something. We are not having any good

00:11:52,279 --> 00:11:56,930
idea with expression to create that kind of tree. 

00:11:56,930 --> 00:12:03,450
>> EVAN: Okay. Whoever submitted this question... >> MATZ: We are welcome to proposals.

00:12:03,450 --> 00:12:08,680
>> EVAN: Is there a good way if someone has a proposal that they want to submit to Ruby

00:12:08,680 --> 00:12:16,600
Core, is the best way to write it up? Or is it to submit a patch first? What do you

00:12:16,600 --> 00:12:19,110
think the best way to submit a proposal like this? 

00:12:19,110 --> 00:12:36,810
>> MATZ: Submit to the issue tracker with the bugs to rubylang.org. So, having a pull

00:12:36,810 --> 00:12:47,149
request is good things, because we can ‑‑ we can't tell the exact behavior, the original

00:12:47,149 --> 00:12:58,139
proposal intended. But we might not take the exact pull request. If you can describe

00:12:58,139 --> 00:13:04,609
the basic ideas, feel free to submit in English... or Japanese.

00:13:04,609 --> 00:13:13,090
>> EVAN: Or Japanese. Okay. This gentleman... >> MATZ: Actually, English is preferable because

00:13:13,090 --> 00:13:17,570
of the very fraction of the community can understand Japanese. 

00:13:17,570 --> 00:13:24,680
>> EVAN: Okay.  >> Hello Matz. First, thank you for bringing

00:13:24,680 --> 00:13:30,899
pattern matching into Ruby. That's really exciting. And I'm wondering if there might

00:13:30,899 --> 00:13:37,290
be plans for the future to add pattern matching like Elixir at the function level. Right

00:13:37,290 --> 00:13:45,180
now you can do case_in. And in Elixir, you can define multiple versions of a function

00:13:45,180 --> 00:13:52,790
with different parameters or conditionals. Right now if you define a method in Ruby, again,

00:13:52,790 --> 00:13:57,019
it overwrites the first one, so there would need to be some changes. Is that something

00:13:57,019 --> 00:14:04,730
that you see valuable or possible in the future?  >> MATZ: Yeah, in Elixir, we have the multiple

00:14:04,730 --> 00:14:14,690
version of the function and you can dispatch it according to the patterns. We already have

00:14:14,690 --> 00:14:24,730
had optional argument or something like that, so it is quite difficult to have the overwriting,

00:14:24,730 --> 00:14:33,100
overloading methods in Ruby. So, I don't think it's impossible, but it's quite difficult

00:14:33,100 --> 00:14:44,379
to add the overloading method in Ruby so it might take time even if it's possible. 

00:14:44,379 --> 00:14:48,110
>> Thank you.  >> EVAN: Aaron. 

00:14:48,110 --> 00:14:58,029
>> MATZ: Oh, you.  >> So I noticed in Perl 6 now, they use emojis

00:14:58,029 --> 00:15:02,170
for some operators like atomic... [ Laughter ]

00:15:02,170 --> 00:15:06,690
Would you consider adding emoji operators in Ruby? 

00:15:06,690 --> 00:15:11,129
>> EVAN: Can I expand it to just be Unicode operators? 

00:15:11,129 --> 00:15:22,249
>> Yeah, yes! Yes! You can! Ha ha!  >> MATZ: Actually, we Japanese long for so

00:15:22,249 --> 00:15:28,370
many characters. And why you guys want to be suffered. 

00:15:28,370 --> 00:15:30,510
[ Laughter ]

00:15:30,510 --> 00:15:41,209
>> Because they look cool.  [ Laughter ].

00:15:41,209 --> 00:15:50,109
>> MATZ: You have to pay the price. I know that. Yeah. Not soon. 

00:15:50,109 --> 00:15:56,670
>> Okay.  >> EVAN: Maybe ask another interesting question

00:15:56,670 --> 00:16:01,639
which is not necessarily all the way to Unicode operators, but one thing that's interesting

00:16:01,639 --> 00:16:09,839
about Ruby is that the set of operators is fixed. Whereas you have a lot of languages

00:16:09,839 --> 00:16:15,660
where you can sort of have this arbitrary operator out there. Would you ever consider

00:16:15,660 --> 00:16:23,050
having arbitrary operators rather than just the fixed set that we have of, you know, greater

00:16:23,050 --> 00:16:28,250
than and less than, spaceship and that stuff?  >> MATZ: Yeah. In some languages you can

00:16:28,250 --> 00:16:41,350
add arbitrary combination of characters as the operators. Like Haskell and Scala. In

00:16:41,350 --> 00:16:51,680
some languages, the new operator needs to fall into some particular format like sometimes

00:16:51,680 --> 00:17:00,790
the operators have to be surrounded by the percent or something like that. 

00:17:00,790 --> 00:17:09,150
And the ‑‑ I think the formal makes your program cryptic. It's like a macro, and for

00:17:09,150 --> 00:17:17,909
the same reason, I don't want to add that kind of things into the language. The latter

00:17:17,909 --> 00:17:25,120
ones, adding new arbitrary operator within a certain format, it's possible, but we are

00:17:25,120 --> 00:17:35,299
lacking characters. I don't know how we describe the new operator. But I think the latter

00:17:35,299 --> 00:17:41,679
has slightly more chance.  >> EVAN: Trying to figure out how do you express

00:17:41,679 --> 00:17:48,049
precedence rules is also hard.  >> MATZ: Yeah, in some other languages has

00:17:48,049 --> 00:17:52,399
the same precedence for that newly added operators.  >> EVAN: That makes sense. Yeah? 

00:17:52,399 --> 00:18:00,789
>> So, especially because so many people here are new to programming or relatively new to

00:18:00,789 --> 00:18:04,520
programming, what advice would you give to people who are interested in making their

00:18:04,520 --> 00:18:09,030
own programming language? Or, you know, would you encourage others with making their own

00:18:09,030 --> 00:18:19,470
programming languages like you did with Ruby?  >> MATZ: Uh... so there are several books

00:18:19,470 --> 00:18:25,299
on creating programming languages. And some of them are very good book. But unfortunately,

00:18:25,299 --> 00:18:33,659
those book focus on implementation of the language. So, there are very few books ‑‑

00:18:33,659 --> 00:18:38,909
probably no books for focusing on the design of the programming language. 

00:18:38,909 --> 00:18:45,110
Actually, a few years ago, I wrote a book about designing programming language, but

00:18:45,110 --> 00:18:51,610
it's in Japanese and translated into Korean and Chinese. So, if you do speak those languages,

00:18:51,610 --> 00:18:57,740
that's okay, buy my book.  >> EVAN: Maybe we should get it translated

00:18:57,740 --> 00:19:01,010
into English, then.  >> MATZ: Yeah, probably. 

00:19:01,010 --> 00:19:02,730
[ Laughter ]. >> EVAN: Makes note...

00:19:02,730 --> 00:19:13,169
>> Thank you.  >> Sorry. I'm live tweeting random things. So,

00:19:13,169 --> 00:19:23,080
the dot colon operator. I dearly miss it and I would like it back. It was shorthand. So,

00:19:23,080 --> 00:19:28,490
a lot of us who tend to have more of a functional bent, we were fond of that operator and sad

00:19:28,490 --> 00:19:33,669
to see it go. Though with as many admittedly evil things that we did to the operator, we

00:19:33,669 --> 00:19:40,850
kind of understand why.  >> EVAN: Maybe explain what it did. 

00:19:40,850 --> 00:19:50,140
>> MATZ: The dot colon operator ‑‑ to retrieve the method object from the object. So,

00:19:50,140 --> 00:20:03,190
that object.call on foo takes the foo method object from the object. We have to do that

00:20:03,190 --> 00:20:13,419
object.method with the symbol foo or something like that. It's kind of indirect. By using

00:20:13,419 --> 00:20:21,149
dot colon operator, you have to retrieve the method object directly from the object. 

00:20:21,149 --> 00:20:36,809
There are terms named list 1 and list 2. List 1 is a list language like Ski and Scala and

00:20:36,809 --> 00:20:49,760
Python. And .object or .name notation retrieves the corresponding function or method object. And

00:20:49,760 --> 00:21:00,730
then the other language, like object.foo calls the method foo, like Ruby or some other many

00:21:00,730 --> 00:21:12,309
programming language is call LISP2. And Ruby is the LISP2 camp. So, because by using that

00:21:12,309 --> 00:21:21,700
kind of notation, so we don't have to add parentheses every time. So, you can emulate

00:21:21,700 --> 00:21:30,659
the attribute access through the method.  It's better for the object‑oriented programming. But

00:21:30,659 --> 00:21:40,260
for functional programming, it is sometimes better to retrieve the function object or

00:21:40,260 --> 00:21:48,220
a method object. Then to emulate the functional programming in Ruby, it is much easier to

00:21:48,220 --> 00:21:56,770
retrieve the method object without those kind of method direction. 

00:21:56,770 --> 00:22:07,210
So that's the reason we want to introduce the dot colon operator. But we retract the

00:22:07,210 --> 00:22:14,740
idea for two reasons. The first one is the ‑‑ three reasons, actually. The one reason is

00:22:14,740 --> 00:22:23,740
there's ‑‑ okay. Dot colon operator retrieve a method object from the object. But

00:22:23,740 --> 00:22:32,020
we ‑‑ to retrieve the method object from the classes, modules, we still have to call

00:22:32,020 --> 00:22:48,970
the instance method. Instance method method. Yeah. So, it's not kind of in consistency and perfection. This

00:22:48,970 --> 00:22:55,960
is one reason.  The second reason is we added some, you know,

00:22:55,960 --> 00:23:00,769
features as part of the functional programming, but these addition is kind of ad hoc. So,

00:23:00,769 --> 00:23:10,149
that we believe that it's ‑‑ we have to take time to design ‑‑ interest the

00:23:10,149 --> 00:23:18,230
ground design of the functional programming in Ruby. So, that's the second and the biggest

00:23:18,230 --> 00:23:26,269
reason to retract that dot colon operator.  The third reason is the dot colon does not

00:23:26,269 --> 00:23:36,930
really look like the method retrieval, but like braille. I don't like that operator's

00:23:36,930 --> 00:23:42,940
appearance. So, for those reasons, we retracted the dot colon operator. So, that means we

00:23:42,940 --> 00:23:50,570
reject the idea of the method retrieving method reference all together, so maybe we will have

00:23:50,570 --> 00:23:58,760
time to consider about functional programming in Ruby. So, as a result, we might re‑introduce

00:23:58,760 --> 00:24:08,769
a new operator. And that might happen to be dot colon. But after the discussion we

00:24:08,769 --> 00:24:15,130
are going to have.  Of course we invite you to join the discussion. 

00:24:15,130 --> 00:24:20,690
>> EVAN: Did we get to your question?  >> Yeah, I would say that's perfectly fair. Yes,

00:24:20,690 --> 00:24:24,500
we did very bad things with it and you want to be careful introducing those things because

00:24:24,500 --> 00:24:30,309
we horribly abuse them and write blog posts and probably give conference talks about them. So,

00:24:30,309 --> 00:24:38,320
I apologize. So, I appreciate that you are considering this because once they are in

00:24:38,320 --> 00:24:44,060
there, they're very hard to not have in there. I'll very much be contributing to this discussion,

00:24:44,060 --> 00:24:49,049
and anyone else who is interested in this, I know others were, I would like to have them

00:24:49,049 --> 00:24:51,880
participate in some of these discussions as well. And I believe they will. Thank you

00:24:51,880 --> 00:24:55,680
for taking the time and being considerate about those. 

00:24:55,680 --> 00:25:08,560
>> MATZ: Thank you.  >> Dear Matz. Over here on your right. This

00:25:08,560 --> 00:25:19,669
other mic, Matz. So, in some far‑off, distant, but inevitable future where you're no longer

00:25:19,669 --> 00:25:26,580
able or no longer interested in being the sort of driving designer of Ruby, have you

00:25:26,580 --> 00:25:35,010
thought about what ‑‑ how the language design will move forward after you? In this

00:25:35,010 --> 00:25:38,420
future, there's still lots of people using Ruby, of course. 

00:25:38,420 --> 00:25:41,570
>> MATZ: Yeah... >> EVAN: Less morbid. Have you thought about

00:25:41,570 --> 00:25:57,870
retirement?  >> MATZ: Actually, the Python creator retired. That

00:25:57,870 --> 00:26:07,610
made me thought about my retirement plan in the future. But he is nine years older than

00:26:07,610 --> 00:26:16,980
me. So, we can stand for next nine years or something. 

00:26:16,980 --> 00:26:30,590
The Python community formed the board of design or something with the five members or something. By

00:26:30,590 --> 00:26:38,340
voting. Yeah. But I'm not a true believer of the democracy in software. 

00:26:38,340 --> 00:26:43,750
[ Laughter ]. >> EVAN: You don't necessarily want four people

00:26:43,750 --> 00:26:50,630
painting a picture. Sometimes you want one person. But I think, like, have you thought

00:26:50,630 --> 00:26:57,280
about what it would look like? I know you have a lot of people who already do lots of

00:26:57,280 --> 00:27:00,859
things.  >> MATZ: Yeah. Okay. 

00:27:00,859 --> 00:27:10,850
>> EVAN: We're not trying to put you on the spot, either. So...

00:27:10,850 --> 00:27:16,909
>> MATZ: Okay. Year 2025, six years from now, I will turn 60. Probably I am having

00:27:16,909 --> 00:27:31,419
a year off. So, that community can stay, so probably I will name some kind of successor

00:27:31,419 --> 00:27:41,149
or replacer at least for a year. And then after Ruby 3, we have some kind of designing

00:27:41,149 --> 00:27:53,700
practice things for my successor candidate. And after that, I might name one of them to be

00:27:53,700 --> 00:27:55,349
my successor.  >> EVAN: Okay. Yeah. That's good. 

00:27:55,349 --> 00:28:01,539
>> MATZ: It's a big plan. We have years ahead.  >> So the future is still there's a single

00:28:01,539 --> 00:28:05,909
author of the language? A single designer?  >> EVAN: You still want to have one person? 

00:28:05,909 --> 00:28:14,490
>> MATZ: Yeah, because sometimes the committee thinks or the, you know, the community ‑‑

00:28:14,490 --> 00:28:25,380
the design decision could be irresponsible. Okay. I don't care about this feature, so, okay. Either

00:28:25,380 --> 00:28:33,210
follow the other ones or something like that. So, that makes language less consistent or something

00:28:33,210 --> 00:28:40,360
like that. So, I still believe the language should be designed by the very one particular

00:28:40,360 --> 00:28:48,990
person to make decision and take responsibility.  >> EVAN: Yep. Over here. 

00:28:48,990 --> 00:28:54,480
>> Yeah. So, about eight years ago, you filed an issue on the Ruby tracker about autoload

00:28:54,480 --> 00:29:00,059
and possibly wanting to remove it. It got closed earlier this year. I was wondering

00:29:00,059 --> 00:29:05,190
what went through your mind over the past so many eight years behind your opinion of

00:29:05,190 --> 00:29:11,220
autoloading and its use and should we use it as much as we do? And generally your opinion

00:29:11,220 --> 00:29:14,610
of it?  >> MATZ: I still don't like the autoload. And

00:29:14,610 --> 00:29:21,360
I want to remove that from the language if possible. But the impact of the removing

00:29:21,360 --> 00:29:28,980
was far bigger than I expected. So, you know, I don't want to punish the community because

00:29:28,980 --> 00:29:41,990
of my preference. That's the biggest reason I changed my mind. 

00:29:41,990 --> 00:29:47,330
>> How do you see the relationship between the automated tests and the typing in programming

00:29:47,330 --> 00:29:54,080
languages? Do you think having one reduces the need for the other? Or do you think they

00:29:54,080 --> 00:29:59,840
can work together?  >> MATZ: No. By using static typings, we

00:29:59,840 --> 00:30:07,870
find more errors at the compile time so that we don't have to code very silly type tests

00:30:07,870 --> 00:30:16,030
like, you know, assert type things in a test so that we can reduce the assertion from the

00:30:16,030 --> 00:30:30,549
tests. But the ratio of these kind of type assertion silly tests, they are relatively

00:30:30,549 --> 00:30:37,100
smaller in the test so that we might ‑‑ we have to pay more attention to the logic

00:30:37,100 --> 00:30:45,830
in the tests. But you know, these silly things can be omitted in the reference state. So,

00:30:45,830 --> 00:30:57,169
having static testing, static type checking increase the quality of the software, I believe. 

00:30:57,169 --> 00:31:00,210
>> Thank you.  >> EVAN: Yeah. 

00:31:00,210 --> 00:31:07,700
>> So during the keynote, you mentioned how I/O concurrency how you regret adding threads,

00:31:07,700 --> 00:31:13,080
and you were interested in using fibers as a solution. And you mentioned the async gem

00:31:13,080 --> 00:31:18,090
as well. And I was wondering if you could elaborate a little bit on what you think the

00:31:18,090 --> 00:31:29,240
future of concurrency in Ruby is.  >> MATZ: This is difficult because of the

00:31:29,240 --> 00:31:39,779
states. We have nothing to guide the concurrency structure or architecture. But by using the

00:31:39,779 --> 00:31:49,110
guilds or the fibers, we can reduce the burden of the concurrency for one thing. 

00:31:49,110 --> 00:31:58,640
As I explained in the keynote, the isolates can be considered as the web workers in JavaScript. So,

00:31:58,640 --> 00:32:10,580
again, you can offload that long‑running task into ‑‑ separate the native threads. And

00:32:10,580 --> 00:32:17,070
it is independent name space so that you don't have to worry about the shared state or something

00:32:17,070 --> 00:32:32,010
like that. You can communicate via channels. And then for I/O multiplexity, this is very much

00:32:32,010 --> 00:32:39,049
important. For example, with node.js is single threaded, but it's still fast because these

00:32:39,049 --> 00:32:47,190
kind of quick I/O multiplexing. And we want to provide that kind of feature. 

00:32:47,190 --> 00:32:53,470
We reduce the cost of the context switching of the fibers using sometimes assembler or

00:32:53,470 --> 00:33:03,610
something like. The context switch something reduced dramatically into six to seven? Yeah. Then

00:33:03,610 --> 00:33:13,500
we are going to introduce the core of the async gem into the very core. Actually, a

00:33:13,500 --> 00:33:19,799
core part of the async gem into the Ruby core. It's kind of confusing. 

00:33:19,799 --> 00:33:29,549
And then the other part is still defined in the async gem. So, that we can use the, you

00:33:29,549 --> 00:33:40,350
know, I/O multiplexity without marking.  >> So would that mean like there would be

00:33:40,350 --> 00:33:45,999
async versions of the HTTP? The existing core library? 

00:33:45,999 --> 00:33:51,679
>> MATZ: Yeah. We are going to have the async version of the database access and the socket

00:33:51,679 --> 00:33:55,890
access and the file access or something like that. 

00:33:55,890 --> 00:34:03,830
>> Cool. Thank you.  >> EVAN: My follow‑up question there is,

00:34:03,830 --> 00:34:09,669
having a lot of async stuff makes it harder for people who write C extensions, because

00:34:09,669 --> 00:34:17,399
you have a C extension that is kind of expected to live and do its thing. I don't recall. Can

00:34:17,399 --> 00:34:23,879
you save a fiber through a C extension frame right now? 

00:34:23,879 --> 00:34:33,170
>> MATZ: Yes... on some major platforms, we use the stack switching so that you can keep

00:34:33,170 --> 00:34:37,680
the C extension stack frame, even though we can't. 

00:34:37,680 --> 00:34:40,830
>> EVAN: Okay. Yeah. 

00:34:40,830 --> 00:34:47,340
>> What is an upcoming change or addition to Ruby that you are personally most excited

00:34:47,340 --> 00:34:51,840
about?  >> MATZ: The most excited one is the pattern

00:34:51,840 --> 00:34:59,310
matching. So, it will open up a whole new world in Ruby programming. It's still experimental,

00:34:59,310 --> 00:35:08,360
and it's still slow, but its expressiveness is very dramatic. 

00:35:08,360 --> 00:35:16,610
>> Yeah. You talked a lot about things that are coming in Ruby 2.7 and Ruby 3. Have you

00:35:16,610 --> 00:35:24,620
thought about any features or modules that you could remove in Ruby 3 or Ruby 4 without

00:35:24,620 --> 00:35:32,510
having a lot of issues with backwards compatibility?  >> MATZ: Well, so we still have the very old

00:35:32,510 --> 00:35:37,880
modules like, you know, the Singleton module or ‑‑

00:35:37,880 --> 00:35:45,620
>> EVAN: Grieve. >> MATZ: English. Those kinds of things can

00:35:45,620 --> 00:35:54,420
be removed in the future. And actually, we made them in a bundle gem so we can remove

00:35:54,420 --> 00:35:58,761
them gradually.  >> EVAN: All right. I think I'll ask you

00:35:58,761 --> 00:36:04,840
a couple of quick questions here at the end, non‑programming ones. One person said you

00:36:04,840 --> 00:36:11,680
work on this every day? Do you get tired of it? Do you feel like you get burned out? Do

00:36:11,680 --> 00:36:17,830
you do anything? How do you cope with that? Do you just take time away from it? Do you have

00:36:17,830 --> 00:36:24,230
something that you do?  >> MATZ: Actually, I have no obligation. I

00:36:24,230 --> 00:36:37,770
am hired by Heroku. And thanks to Heroku. I have no assigned job. So, I can do whatever

00:36:37,770 --> 00:36:44,310
I want in Ruby. And I spent some of my time as a language designer, so make decision of

00:36:44,310 --> 00:36:50,180
the language change, language future. The other part is as a programmer, so I implement

00:36:50,180 --> 00:36:59,550
mRuby. So, yeah, when I get tired of the designing language, I go to as a programmer. And

00:36:59,550 --> 00:37:06,800
then I implement some new features of mRuby. Then I get tired of the C programming, so I go

00:37:06,800 --> 00:37:13,790
back to the designing the language. And if I tired of both of them, so I go out. Yeah. Read

00:37:13,790 --> 00:37:19,610
a book.  >> EVAN: So you switch back and forth to keep

00:37:19,610 --> 00:37:25,580
yourself fresh. I will ask one bonus question. We're just at time, because I had forgotten to get

00:37:25,580 --> 00:37:32,700
to this. Someone asked if there's a future where MRI and mRuby kind of merge together

00:37:32,700 --> 00:37:39,530
or are they always going to be separate?  >> MATZ: I think they will always be separated,

00:37:39,530 --> 00:37:49,140
because that first priority is a little bit different. CRUBY, the priority of CRuby is

00:37:49,140 --> 00:37:59,490
being the canonical implementation. So, every new feature is implemented in CRuby first. And

00:37:59,490 --> 00:38:12,090
then the other implementation like JRuby, etc. So, in addition, CRuby focusing on the

00:38:12,090 --> 00:38:24,020
performance of the server side, especially. And then you also work usable as a scripting language. But

00:38:24,020 --> 00:38:35,370
JRuby is focus on the big server process. And for that case, JRuby is unbeatable. And mRuby

00:38:35,370 --> 00:38:40,950
is focused on the smaller devices and reducing the memory consumptions and something like

00:38:40,950 --> 00:38:51,680
that for that purpose mRuby is the winner. For that reason, so every different implementation

00:38:51,680 --> 00:38:58,940
has every different domain to live. So, we are not going to merge them into one. 

00:38:58,940 --> 00:39:04,819
>> EVAN: One last bonus question. Someone wanted to know how your dog is doing. 

00:39:04,819 --> 00:39:13,650
>> MATZ: Yeah. Thank you. Two months ago, my dog lost. It's gone. And yeah, but don't

00:39:13,650 --> 00:39:28,270
worry. 48 hours later, we found him! Yeah. Actually, he just disappeared from my backyard. No

00:39:28,270 --> 00:39:37,750
one ‑‑ my ‑‑ the fence was shut. So, I don't know. There's no reason to escape. But

00:39:37,750 --> 00:39:49,310
he disappeared. But two days later, the police called me and my neighbor, 200 yards away,

00:39:49,310 --> 00:39:55,430
who found the dog and called the police. Yeah. We found him. 

00:39:55,430 --> 00:39:58,420
>> EVAN: Well, great. Thank you, everybody. Thank you, Matz for your time. 

00:39:58,420 --> 00:39:59,610

YouTube URL: https://www.youtube.com/watch?v=vqpNmaEDn-o


