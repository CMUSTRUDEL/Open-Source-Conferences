Title: RubyConf 2019 - Ruby ate my DSL! by Daniel Azuma
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Ruby ate my DSL! by Daniel Azuma

DSLs (Domain-Specific Languages) are fun to design, but it's easy to forget that they are still "Just Ruby." If users of your DSL can mix in Ruby code... any Ruby code... you can bet they will, and it's all too easy for that to go awry. In this session, you'll encounter examples of how seemingly innocuous Ruby code can make a DSL go disastrously wrong, and you’ll learn techniques you can use to harden your DSL against the cleverness of your users. If you’re writing, or even thinking of writing a DSL, this talk is for you.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,920 --> 00:00:17,310
before I get started I just kind of want

00:00:15,480 --> 00:00:19,380
to skits I just want to say you know

00:00:17,310 --> 00:00:23,970
we're in Nashville Tennessee this year

00:00:19,380 --> 00:00:26,580
and I'll be honest I'm kind of a stuffy

00:00:23,970 --> 00:00:28,380
West Coast city dweller and Nashville

00:00:26,580 --> 00:00:31,859
has not really been on my bucket list

00:00:28,380 --> 00:00:34,079
for places to visit it was not really on

00:00:31,859 --> 00:00:37,050
my radar but since the conference was

00:00:34,079 --> 00:00:40,170
here this year I decided to come a few

00:00:37,050 --> 00:00:43,559
days early so I my wife and I came on

00:00:40,170 --> 00:00:44,879
Friday and we we got a chance to check

00:00:43,559 --> 00:00:48,600
out the city check out some of the

00:00:44,879 --> 00:00:50,999
venues check out some of the music and I

00:00:48,600 --> 00:00:56,370
got a I could admit I was really blown

00:00:50,999 --> 00:00:58,109
away this is an amazing place we really

00:00:56,370 --> 00:01:00,359
loved it how many of you had a chance to

00:00:58,109 --> 00:01:03,929
check out some of the places so far

00:01:00,359 --> 00:01:05,190
check out some shows just a few we're

00:01:03,929 --> 00:01:07,260
here for three days

00:01:05,190 --> 00:01:09,600
that's that means several evenings and

00:01:07,260 --> 00:01:12,240
so I really encourage you if you get a

00:01:09,600 --> 00:01:14,910
chance go out and check out the city go

00:01:12,240 --> 00:01:17,880
out and and and just just walk into

00:01:14,910 --> 00:01:20,580
pretty much any music venue any any jazz

00:01:17,880 --> 00:01:23,550
club to anything you won't regret it

00:01:20,580 --> 00:01:26,090
you you won't be disappointed there's

00:01:23,550 --> 00:01:30,360
some amazing talents in this city

00:01:26,090 --> 00:01:31,790
so that's anyway that's that's enough

00:01:30,360 --> 00:01:34,850
sermon for me

00:01:31,790 --> 00:01:38,810
we we're gonna have a gripe session

00:01:34,850 --> 00:01:42,080
today right session yeah that's right

00:01:38,810 --> 00:01:44,159
we're gonna gripe about Ruby and DSL and

00:01:42,080 --> 00:01:45,840
again for those of you who just coming

00:01:44,159 --> 00:01:47,730
in are those in the back please move

00:01:45,840 --> 00:01:49,050
forward there's a lot of there's plenty

00:01:47,730 --> 00:01:51,210
of open seats and there's a lot of code

00:01:49,050 --> 00:01:55,830
on these slides and so it'd be good to

00:01:51,210 --> 00:01:59,250
get closer so you can see so not long

00:01:55,830 --> 00:02:02,040
ago I had to write a Sinatra app for my

00:01:59,250 --> 00:02:04,890
day job this is kind of a simplified

00:02:02,040 --> 00:02:08,239
view of what the code was basically its

00:02:04,890 --> 00:02:11,549
job was to invoke a shell command and

00:02:08,239 --> 00:02:13,439
capture its output and then kind of

00:02:11,549 --> 00:02:14,190
format that output is JSON and send that

00:02:13,439 --> 00:02:16,740
as a response

00:02:14,190 --> 00:02:18,990
all right so really simple

00:02:16,740 --> 00:02:21,600
straightforward app I figured hey I've

00:02:18,990 --> 00:02:24,690
done Sinatra before what could possibly

00:02:21,600 --> 00:02:27,840
go wrong I tested it locally just to

00:02:24,690 --> 00:02:32,970
make sure and as it turns out there was

00:02:27,840 --> 00:02:34,470
a bug can anyone see the bug I'm gonna

00:02:32,970 --> 00:02:38,370
see the bug raise your hand if you think

00:02:34,470 --> 00:02:40,050
you know what the bug is okay few hands

00:02:38,370 --> 00:02:43,770
a couple of hands up if you have your

00:02:40,050 --> 00:02:46,500
hands up I might call on you so okay for

00:02:43,770 --> 00:02:52,140
the rest of you here's a hint this is

00:02:46,500 --> 00:02:54,870
the stack Trace that you get anyone see

00:02:52,140 --> 00:02:59,880
it who thinks they know what knows

00:02:54,870 --> 00:03:03,950
what's going on okay no one's hand is up

00:02:59,880 --> 00:03:03,950
now okay what do you think is happening

00:03:09,220 --> 00:03:20,530
the invoke method is a symbol to oh in

00:03:17,890 --> 00:03:22,330
side the echo okay so inside the echo

00:03:20,530 --> 00:03:27,820
there need to be a symbol that for it to

00:03:22,330 --> 00:03:31,030
be executed not quite not quite okay

00:03:27,820 --> 00:03:35,470
well we'll just we'll just move on um so

00:03:31,030 --> 00:03:38,440
the problem is here problem is this call

00:03:35,470 --> 00:03:42,730
turns out that Sinatra has an internal

00:03:38,440 --> 00:03:44,800
private methods named invoke and so this

00:03:42,730 --> 00:03:47,110
line here actually calls Sinatra's

00:03:44,800 --> 00:03:49,060
method not my helper method that I have

00:03:47,110 --> 00:03:51,070
there of course you know it's a bit

00:03:49,060 --> 00:03:53,110
tricky to just to see that right and you

00:03:51,070 --> 00:03:54,940
the the calling conventions don't match

00:03:53,110 --> 00:03:58,090
up we get this obscure exception here

00:03:54,940 --> 00:04:00,700
that's hard to parse it's it's hard to

00:03:58,090 --> 00:04:04,150
know what's going on unless you dig into

00:04:00,700 --> 00:04:07,840
Sinatra's source and you understand what

00:04:04,150 --> 00:04:10,780
DSL is doing now it's not my point here

00:04:07,840 --> 00:04:13,300
to pick on Sinatra this happens a lot in

00:04:10,780 --> 00:04:16,390
Ruby across many allowed across many

00:04:13,300 --> 00:04:18,910
libraries especially when dsls

00:04:16,390 --> 00:04:21,130
domain-specific languages are involved

00:04:18,910 --> 00:04:23,110
so we're gonna spend this session

00:04:21,130 --> 00:04:24,910
griping about this we're gonna spend the

00:04:23,110 --> 00:04:27,400
session talking about this we're gonna

00:04:24,910 --> 00:04:30,550
look at how do cells work we're gonna

00:04:27,400 --> 00:04:33,910
see why some ordinary Ruby code and

00:04:30,550 --> 00:04:35,530
sometimes make dsls go wrong and then

00:04:33,910 --> 00:04:38,710
we're gonna study some techniques that

00:04:35,530 --> 00:04:42,540
you can use to kind of help harden your

00:04:38,710 --> 00:04:45,340
DSL against problems like that okay

00:04:42,540 --> 00:04:48,070
quick intro before I get too far this is

00:04:45,340 --> 00:04:52,450
me my name is Daniel azuma I've been a

00:04:48,070 --> 00:04:55,090
Rubeus since about 2005 ish right around

00:04:52,450 --> 00:04:57,669
the time that rails 1.0 came out I've

00:04:55,090 --> 00:05:01,150
done a variety of things and some rails

00:04:57,669 --> 00:05:04,300
startups currently I work at Google

00:05:01,150 --> 00:05:06,330
Cloud I'm the Ruby engineer there we

00:05:04,300 --> 00:05:09,540
don't do a whole lot of Ruby at Google

00:05:06,330 --> 00:05:13,600
but there are several of us that's a

00:05:09,540 --> 00:05:15,550
bunch of us that worked there and a lot

00:05:13,600 --> 00:05:18,669
of us what we do is were kind of

00:05:15,550 --> 00:05:22,450
consultants for rubies or Google's

00:05:18,669 --> 00:05:23,200
engineering teams so that's a lot of my

00:05:22,450 --> 00:05:26,200
role my role

00:05:23,200 --> 00:05:27,670
to kind of go to the the engineering

00:05:26,200 --> 00:05:30,010
teams that are building Google Cloud and

00:05:27,670 --> 00:05:33,190
help them tailor their products for our

00:05:30,010 --> 00:05:36,400
needs as Ruby developers to help them

00:05:33,190 --> 00:05:39,370
understand our idioms our tools our

00:05:36,400 --> 00:05:42,280
practices so that Google's cloud will

00:05:39,370 --> 00:05:43,720
work well for for Ruby developers so

00:05:42,280 --> 00:05:47,380
today what we're gonna do is we're going

00:05:43,720 --> 00:05:51,430
to talk about some ruby practices around

00:05:47,380 --> 00:05:54,490
ESL's and I'm gonna take a stab at

00:05:51,430 --> 00:05:57,190
defining DSL before I get started the

00:05:54,490 --> 00:06:00,730
the talk previous to this went through a

00:05:57,190 --> 00:06:02,740
lot of definition time and definitions

00:06:00,730 --> 00:06:03,790
are important especially when you're

00:06:02,740 --> 00:06:06,330
talking about some of these things

00:06:03,790 --> 00:06:10,120
because as as the last speaker mentioned

00:06:06,330 --> 00:06:11,710
Ruby sometimes has different concepts so

00:06:10,120 --> 00:06:15,130
the concepts work slightly differently

00:06:11,710 --> 00:06:16,390
in Ruby than in other languages when I

00:06:15,130 --> 00:06:20,080
speak of DSL

00:06:16,390 --> 00:06:23,800
I'm talking about Bayer methods that are

00:06:20,080 --> 00:06:26,350
not part of core Ruby they are methods

00:06:23,800 --> 00:06:28,240
so what does that mean Bayer methods

00:06:26,350 --> 00:06:30,730
I mean methods that don't need a

00:06:28,240 --> 00:06:34,000
receiver object to be called so methods

00:06:30,730 --> 00:06:37,480
like put s or sleep that that look like

00:06:34,000 --> 00:06:39,610
commands in Ruby so those kinds of

00:06:37,480 --> 00:06:41,710
methods but methods that are provided by

00:06:39,610 --> 00:06:44,290
a library they're not part of the

00:06:41,710 --> 00:06:46,300
standard library or the core of Ruby but

00:06:44,290 --> 00:06:49,890
they're part of a kind of an external

00:06:46,300 --> 00:06:53,260
library or third-party library so dsls

00:06:49,890 --> 00:06:57,340
they they're very useful they can make

00:06:53,260 --> 00:07:01,150
for some very nice expressive concise

00:06:57,340 --> 00:07:04,600
code looking back at our Sinatra example

00:07:01,150 --> 00:07:06,310
that get method there is called without

00:07:04,600 --> 00:07:09,940
a receiver object is called at the top

00:07:06,310 --> 00:07:12,790
level but it's being used as if it were

00:07:09,940 --> 00:07:15,880
being it were part of core Ruby all

00:07:12,790 --> 00:07:19,090
right but it's not it's part of the

00:07:15,880 --> 00:07:21,630
Sinatra DSL now how does the Natura

00:07:19,090 --> 00:07:24,910
accomplish something like this

00:07:21,630 --> 00:07:28,930
Sinatra adds this method to the main

00:07:24,910 --> 00:07:32,680
object the main object this is an object

00:07:28,930 --> 00:07:34,270
that is considered to be self when when

00:07:32,680 --> 00:07:36,370
you're at the top level of a ruby file

00:07:34,270 --> 00:07:38,590
so every Ruby application has one

00:07:36,370 --> 00:07:40,630
these objects and we'll talk about this

00:07:38,590 --> 00:07:43,060
more in a bit but first here's another

00:07:40,630 --> 00:07:46,660
example of a DSL this one's from rails

00:07:43,060 --> 00:07:50,080
who's a rails developer here okay a lot

00:07:46,660 --> 00:07:51,940
of us that's right a lot of us came to

00:07:50,080 --> 00:07:55,150
rails came to Ruby through Rails that's

00:07:51,940 --> 00:07:57,940
that was my story and I know a few of us

00:07:55,150 --> 00:08:02,020
like to bash on Rails a little bit just

00:07:57,940 --> 00:08:04,990
because it's it's big and embattled but

00:08:02,020 --> 00:08:06,520
really it's it's a nice solid library

00:08:04,990 --> 00:08:08,919
it's a nice solid framework and that's

00:08:06,520 --> 00:08:12,310
why a lot of us use it and one of the

00:08:08,919 --> 00:08:14,320
reasons its it works so well is because

00:08:12,310 --> 00:08:18,190
of how strategically it uses

00:08:14,320 --> 00:08:21,699
metaprogramming and ESL's internally to

00:08:18,190 --> 00:08:24,070
be expressive and so here's an example

00:08:21,699 --> 00:08:25,810
from rails routing I copied this

00:08:24,070 --> 00:08:29,110
directly out of the rails routing guide

00:08:25,810 --> 00:08:30,669
here and again we have methods that are

00:08:29,110 --> 00:08:34,089
being called without a receiver and

00:08:30,669 --> 00:08:36,010
those aren't part of core Ruby those are

00:08:34,089 --> 00:08:41,409
methods that are defined on a mapper

00:08:36,010 --> 00:08:45,400
object that's it's a class on in the

00:08:41,409 --> 00:08:48,130
router section of a section dispatch so

00:08:45,400 --> 00:08:51,490
when you call routes draw in your routes

00:08:48,130 --> 00:08:55,150
file and you pass it a block that block

00:08:51,490 --> 00:08:55,360
gets executed using a ruby construct

00:08:55,150 --> 00:08:58,990
called

00:08:55,360 --> 00:09:01,870
instance eval so within the block what

00:08:58,990 --> 00:09:05,170
happens is self the the current Ruby

00:09:01,870 --> 00:09:07,060
object gets set to another object in

00:09:05,170 --> 00:09:09,910
this case it gets set to a mapper object

00:09:07,060 --> 00:09:12,220
and so within the block self asset to

00:09:09,910 --> 00:09:14,830
the mapper and you have access to all

00:09:12,220 --> 00:09:18,070
that mappers methods like resource and

00:09:14,830 --> 00:09:21,190
resolve so setting self within the block

00:09:18,070 --> 00:09:25,390
or adding methods to an existing object

00:09:21,190 --> 00:09:27,730
these are two useful techniques a lot of

00:09:25,390 --> 00:09:30,190
lot of DSL is basically boil down to one

00:09:27,730 --> 00:09:31,450
of these these two techniques they make

00:09:30,190 --> 00:09:35,820
it look like we're extending the

00:09:31,450 --> 00:09:39,160
language extending Ruby but despite that

00:09:35,820 --> 00:09:43,360
it's important to realize that it's

00:09:39,160 --> 00:09:45,339
still Ruby we're still writing Ruby even

00:09:43,360 --> 00:09:48,160
though you have a DSL and it might

00:09:45,339 --> 00:09:50,240
appear to extend the language creates

00:09:48,160 --> 00:09:54,170
new methods that are kind of looked like

00:09:50,240 --> 00:09:57,440
part of core yours yes so you're still

00:09:54,170 --> 00:10:00,470
writing Ruby and you know what users of

00:09:57,440 --> 00:10:01,940
your DSL know that right they're still

00:10:00,470 --> 00:10:04,339
going to be writing Ruby even when

00:10:01,940 --> 00:10:06,200
they're coding to your DSL they're still

00:10:04,339 --> 00:10:08,779
gonna expect to be able to write Ruby

00:10:06,200 --> 00:10:11,649
they're still it's going to expect to be

00:10:08,779 --> 00:10:15,589
able to define classes define modules

00:10:11,649 --> 00:10:18,560
rights methods call methods all the

00:10:15,589 --> 00:10:20,450
stuff that they expect from Ruby they're

00:10:18,560 --> 00:10:25,880
gonna expect to be able to do in your

00:10:20,450 --> 00:10:28,670
DSL so as a DSL writer and there's a DSL

00:10:25,880 --> 00:10:31,640
designer it's important that you have to

00:10:28,670 --> 00:10:34,399
plan for this right this doesn't always

00:10:31,640 --> 00:10:37,880
come for free in Ruby you do have to be

00:10:34,399 --> 00:10:40,730
intentional about making sure that Ruby

00:10:37,880 --> 00:10:43,339
works well in your DSL so we're gonna

00:10:40,730 --> 00:10:45,620
look at a bunch of examples and to

00:10:43,339 --> 00:10:47,870
illustrate things we're going to create

00:10:45,620 --> 00:10:50,390
a little strawman DSL so here's some

00:10:47,870 --> 00:10:54,740
some example code I'm going to call this

00:10:50,390 --> 00:10:56,600
nano spec who here uses r-spec a lot of

00:10:54,740 --> 00:11:00,980
us use our spec or mini test spec which

00:10:56,600 --> 00:11:04,130
is mini tests implementation of it our

00:11:00,980 --> 00:11:07,399
spec is a testing framework very very

00:11:04,130 --> 00:11:09,380
well used as you as you saw nano spec is

00:11:07,399 --> 00:11:12,589
just going to be a really tiny subset of

00:11:09,380 --> 00:11:15,050
r-spec here's what you can do with it

00:11:12,589 --> 00:11:18,680
basically you can create describe blocks

00:11:15,050 --> 00:11:22,040
and within those you can create specs

00:11:18,680 --> 00:11:25,760
and add code to them that's it nothing

00:11:22,040 --> 00:11:31,459
else so no expectations no mocks no

00:11:25,760 --> 00:11:35,000
reporting just described and it so

00:11:31,459 --> 00:11:37,820
implementing this is not too hard we'll

00:11:35,000 --> 00:11:40,220
see the code right here we'll start by

00:11:37,820 --> 00:11:43,130
adding a described method to the kernel

00:11:40,220 --> 00:11:45,529
module so that it can be called from the

00:11:43,130 --> 00:11:46,010
top level so you've got a described

00:11:45,529 --> 00:11:48,529
method

00:11:46,010 --> 00:11:51,290
now each described method takes a block

00:11:48,529 --> 00:11:53,270
and that block represents some entity

00:11:51,290 --> 00:11:55,100
that we're testing so we'll create a

00:11:53,270 --> 00:11:58,490
class for that to entity and we'll call

00:11:55,100 --> 00:12:02,140
an entity and each time we call describe

00:11:58,490 --> 00:12:06,760
we'll create an instance of entity

00:12:02,140 --> 00:12:08,709
right now describe takes a block so

00:12:06,760 --> 00:12:12,850
we'll use instance eval to run that

00:12:08,709 --> 00:12:15,700
block inside the entity object and so

00:12:12,850 --> 00:12:18,970
that when the user calls it within that

00:12:15,700 --> 00:12:22,120
block entity is what implements that

00:12:18,970 --> 00:12:24,640
method so just fill out the

00:12:22,120 --> 00:12:27,640
implementation here will collect all the

00:12:24,640 --> 00:12:29,649
specs store them in memory and then

00:12:27,640 --> 00:12:33,490
we'll provide an exit block so that

00:12:29,649 --> 00:12:35,829
after after all the specs are defined it

00:12:33,490 --> 00:12:38,320
goes through and runs all of them and

00:12:35,829 --> 00:12:41,800
that's it we have a test framework in

00:12:38,320 --> 00:12:43,660
twenty lines of code so very simple very

00:12:41,800 --> 00:12:49,240
straightforward what could possibly go

00:12:43,660 --> 00:12:53,320
wrong turns out quite a lot so here's a

00:12:49,240 --> 00:12:55,300
simple example to start us off suppose I

00:12:53,320 --> 00:12:59,170
want to use an instance variable in my

00:12:55,300 --> 00:13:01,120
spec now this is Ruby we use instance

00:12:59,170 --> 00:13:04,300
variables all the time if this were

00:13:01,120 --> 00:13:06,370
r-spec very common pattern is to have

00:13:04,300 --> 00:13:08,260
before blocks that initialize things and

00:13:06,370 --> 00:13:10,420
then pass information into your specs

00:13:08,260 --> 00:13:12,970
using instance variables so very

00:13:10,420 --> 00:13:14,680
reasonable to do this we were we were

00:13:12,970 --> 00:13:16,360
just looking at the implementation so

00:13:14,680 --> 00:13:19,449
some of you may have already seen the

00:13:16,360 --> 00:13:21,850
problem here this spec is being run

00:13:19,449 --> 00:13:25,410
using instance eval or within an

00:13:21,850 --> 00:13:28,209
instance eval block and so when it runs

00:13:25,410 --> 00:13:31,269
self is pointing at an instance of

00:13:28,209 --> 00:13:34,329
entity an entity already uses an

00:13:31,269 --> 00:13:36,370
instance variable called name so when we

00:13:34,329 --> 00:13:40,140
run this spec it's gonna clobber our

00:13:36,370 --> 00:13:43,390
name variable in our net or entity class

00:13:40,140 --> 00:13:45,910
now in this case it's pretty obvious

00:13:43,390 --> 00:13:48,550
what's going on it's very simple example

00:13:45,910 --> 00:13:51,399
if this were a more complex DSL so we're

00:13:48,550 --> 00:13:53,800
a real world library and your user

00:13:51,399 --> 00:13:56,110
clobbered one of your internal instance

00:13:53,800 --> 00:13:58,630
variables it would probably be a lot

00:13:56,110 --> 00:14:01,029
harder to debug the results could be

00:13:58,630 --> 00:14:03,820
pretty unpredictable you'd have to dig

00:14:01,029 --> 00:14:05,440
into the the internals of that class

00:14:03,820 --> 00:14:10,220
that DSL class to really figure out

00:14:05,440 --> 00:14:12,170
what's what's going on so

00:14:10,220 --> 00:14:14,420
let's stop a moment and think about

00:14:12,170 --> 00:14:18,050
what's what's happening here what's

00:14:14,420 --> 00:14:22,550
really happening when you use instance

00:14:18,050 --> 00:14:24,829
eval you're setting self you're setting

00:14:22,550 --> 00:14:26,600
self and you're running arbitrary code

00:14:24,829 --> 00:14:29,209
you're running code that your user is

00:14:26,600 --> 00:14:33,560
giving you effectively you're bringing

00:14:29,209 --> 00:14:35,629
that user code into your object you're

00:14:33,560 --> 00:14:38,720
bringing that inside your implementation

00:14:35,629 --> 00:14:42,769
it's as if that code is just another

00:14:38,720 --> 00:14:44,899
method in your class and so your users

00:14:42,769 --> 00:14:48,980
are injecting code in your class they

00:14:44,899 --> 00:14:52,040
can access or clobber any of your any of

00:14:48,980 --> 00:14:53,959
your internals anything in your class

00:14:52,040 --> 00:14:54,920
whether it's intentional or whether it's

00:14:53,959 --> 00:14:57,529
accidental

00:14:54,920 --> 00:14:59,810
they can collide or clobber with your

00:14:57,529 --> 00:15:03,410
stuff they have unfettered access there

00:14:59,810 --> 00:15:05,149
are no guardrails here and this is

00:15:03,410 --> 00:15:07,579
precisely what happens with our Sinatra

00:15:05,149 --> 00:15:10,420
example right that get block is called

00:15:07,579 --> 00:15:13,639
using instance eval it runs inside

00:15:10,420 --> 00:15:16,100
Sinatra's DSL object and that mistakenly

00:15:13,639 --> 00:15:18,949
calls Sinatra's privates method and then

00:15:16,100 --> 00:15:23,060
you get this weird exception no

00:15:18,949 --> 00:15:25,130
guardrails so whenever we write a DSL

00:15:23,060 --> 00:15:28,610
it's a good idea to put up some

00:15:25,130 --> 00:15:31,339
insulation just to start off some some

00:15:28,610 --> 00:15:33,319
checks some restrictions in your code to

00:15:31,339 --> 00:15:36,980
make sure that what your user is do in

00:15:33,319 --> 00:15:39,800
Ruby doesn't stomp on your DSL or

00:15:36,980 --> 00:15:41,209
vice-versa so that your DSL doesn't

00:15:39,800 --> 00:15:44,120
interfere with what your users are

00:15:41,209 --> 00:15:45,649
trying to do when they write Ruby so

00:15:44,120 --> 00:15:48,740
here's a simple example of how you can

00:15:45,649 --> 00:15:53,120
do that consider adopting a naming

00:15:48,740 --> 00:15:56,059
convention a naming convention for any

00:15:53,120 --> 00:15:58,670
private names in your DSL implementation

00:15:56,059 --> 00:16:01,610
so your instance variables your private

00:15:58,670 --> 00:16:04,550
methods for example you can add some

00:16:01,610 --> 00:16:07,129
uncommon prefix or suffix to your names

00:16:04,550 --> 00:16:10,100
just to reduce the chance that your

00:16:07,129 --> 00:16:12,139
users might collide with them I take our

00:16:10,100 --> 00:16:13,730
DSL class we have several instance

00:16:12,139 --> 00:16:16,490
variables here we have name you have

00:16:13,730 --> 00:16:18,610
specs we could prefix those instance

00:16:16,490 --> 00:16:21,410
variables say with a double underscore

00:16:18,610 --> 00:16:24,030
though this doesn't prevent users from

00:16:21,410 --> 00:16:26,370
clobbering those those variables but

00:16:24,030 --> 00:16:30,330
does make it less likely that your users

00:16:26,370 --> 00:16:33,720
will accidentally clobber them don't

00:16:30,330 --> 00:16:36,450
forget private methods you know even if

00:16:33,720 --> 00:16:38,400
a method is marked private it's not

00:16:36,450 --> 00:16:42,150
really private here because your users

00:16:38,400 --> 00:16:45,440
are running thing in instance eval self

00:16:42,150 --> 00:16:48,390
is set to your your class your object

00:16:45,440 --> 00:16:50,670
and so your user codes your users code

00:16:48,390 --> 00:16:53,880
can still call a private method within

00:16:50,670 --> 00:16:56,520
that block private is not really private

00:16:53,880 --> 00:16:57,330
in the in the DSL there really is no

00:16:56,520 --> 00:16:59,430
such thing

00:16:57,330 --> 00:17:02,820
indeed as private there's no

00:16:59,430 --> 00:17:04,829
encapsulation and so you do have to be

00:17:02,820 --> 00:17:08,520
very careful with what you put in your

00:17:04,829 --> 00:17:10,829
DSL class in fact it's often a good

00:17:08,520 --> 00:17:15,270
practice and here's another useful tip

00:17:10,829 --> 00:17:18,060
to move as much out of your DSL class as

00:17:15,270 --> 00:17:21,839
you can and the common technique for

00:17:18,060 --> 00:17:25,560
this is to separate your DSL interface

00:17:21,839 --> 00:17:29,340
from its implementation you move the DSL

00:17:25,560 --> 00:17:31,860
implementation out of your DSL into a

00:17:29,340 --> 00:17:34,530
separate object and then delegate calls

00:17:31,860 --> 00:17:36,930
to it so here's what that movement might

00:17:34,530 --> 00:17:40,170
look like for nano spec remember we have

00:17:36,930 --> 00:17:43,230
this entity class it serves currently as

00:17:40,170 --> 00:17:46,230
both the DSL and it's implementation so

00:17:43,230 --> 00:17:48,330
it provides that it method and it stores

00:17:46,230 --> 00:17:51,810
all the data and it provides all the

00:17:48,330 --> 00:17:54,930
code to run all the tests so instead

00:17:51,810 --> 00:17:57,780
what you could do is split that into a

00:17:54,930 --> 00:18:00,690
DSL class and an implementation class so

00:17:57,780 --> 00:18:04,110
the DSL class just implements the DSL

00:18:00,690 --> 00:18:06,000
methods such as it and then all that

00:18:04,110 --> 00:18:09,030
method does is it turns around and calls

00:18:06,000 --> 00:18:11,430
an implementation object and that

00:18:09,030 --> 00:18:13,320
implementation object then includes all

00:18:11,430 --> 00:18:14,970
the instance variables all the private

00:18:13,320 --> 00:18:17,340
methods all the stuff that can get

00:18:14,970 --> 00:18:20,280
stomped on it's kept in that

00:18:17,340 --> 00:18:23,270
implementation object away from the DSL

00:18:20,280 --> 00:18:27,120
where it can't be accessed by accident

00:18:23,270 --> 00:18:31,500
so another tip consider delegating

00:18:27,120 --> 00:18:32,730
implementation to a separate object so

00:18:31,500 --> 00:18:36,010
those are some ways that you can

00:18:32,730 --> 00:18:39,070
insulate your DSL from incorrect access

00:18:36,010 --> 00:18:42,520
but there's another I would say maybe

00:18:39,070 --> 00:18:45,490
more important aspect to making your DSL

00:18:42,520 --> 00:18:50,500
more robust and that is to bring the DSL

00:18:45,490 --> 00:18:52,870
closer to Ruby make your DSL look more

00:18:50,500 --> 00:18:55,240
like normal Ruby rehave more like normal

00:18:52,870 --> 00:18:59,590
Ruby so it eliminates differences

00:18:55,240 --> 00:19:02,740
between your DSL and Ruby what do I mean

00:18:59,590 --> 00:19:05,470
by that so again here's a simple example

00:19:02,740 --> 00:19:08,200
to start us off remember how we

00:19:05,470 --> 00:19:11,380
implement and describe we added it to

00:19:08,200 --> 00:19:13,510
the kernel module alright this is great

00:19:11,380 --> 00:19:15,940
now it can be called from the top level

00:19:13,510 --> 00:19:18,400
and this is how methods like put us and

00:19:15,940 --> 00:19:20,110
sleep are implemented their methods of

00:19:18,400 --> 00:19:25,360
kernel so you can call them from

00:19:20,110 --> 00:19:29,230
anywhere but remember what kernel is it

00:19:25,360 --> 00:19:33,220
gets mixed into every Ruby class almost

00:19:29,230 --> 00:19:35,320
every Ruby classes will see but it means

00:19:33,220 --> 00:19:38,770
pretty much means that that described

00:19:35,320 --> 00:19:41,950
method gets added to almost every Ruby

00:19:38,770 --> 00:19:44,169
object in the application often you

00:19:41,950 --> 00:19:48,370
don't need to do that you don't need a

00:19:44,169 --> 00:19:51,040
described method on every object indeed

00:19:48,370 --> 00:19:53,770
doing so increases the risk that

00:19:51,040 --> 00:19:56,730
something might go wrong because other

00:19:53,770 --> 00:19:59,530
classes in the application don't expect

00:19:56,730 --> 00:20:02,679
that described method to be to be

00:19:59,530 --> 00:20:04,570
present the users app might not expect

00:20:02,679 --> 00:20:07,270
its own classes to have a described

00:20:04,570 --> 00:20:09,790
method or Ruby system classes like

00:20:07,270 --> 00:20:12,340
integer or string to have a described

00:20:09,790 --> 00:20:14,500
method and so by adding them to kernel

00:20:12,340 --> 00:20:17,020
we've modified more than we intends to

00:20:14,500 --> 00:20:21,010
we've modified more than we need to and

00:20:17,020 --> 00:20:23,350
that increases risk this dsl really only

00:20:21,010 --> 00:20:27,520
needs that described method at the top

00:20:23,350 --> 00:20:30,190
level we only need it on one object not

00:20:27,520 --> 00:20:33,490
all of them just one and that's the main

00:20:30,190 --> 00:20:36,640
object that we were talking about so

00:20:33,490 --> 00:20:38,950
don't add it to kernel just extend the

00:20:36,640 --> 00:20:40,900
one object that you need to talk just

00:20:38,950 --> 00:20:43,120
extend them in object so that's what

00:20:40,900 --> 00:20:45,610
we've done here we're extending the main

00:20:43,120 --> 00:20:48,549
object with with a module that contains

00:20:45,610 --> 00:20:49,970
that described method so another tip

00:20:48,549 --> 00:20:53,120
minimize this go

00:20:49,970 --> 00:20:55,690
of your changes add methods only with

00:20:53,120 --> 00:20:58,690
when where they were actually needed

00:20:55,690 --> 00:21:02,270
change as little as possible

00:20:58,690 --> 00:21:05,000
most most ESL's do do a reasonable job

00:21:02,270 --> 00:21:09,440
of this there are a few exceptions I'm

00:21:05,000 --> 00:21:12,350
looking at you mini tests but generally

00:21:09,440 --> 00:21:15,290
you know this is a very important very

00:21:12,350 --> 00:21:16,340
important tip there is more to it than

00:21:15,290 --> 00:21:19,880
that though we were talking about

00:21:16,340 --> 00:21:22,430
bringing a DSL closer to Ruby and that

00:21:19,880 --> 00:21:25,570
means minimizing changes but it also

00:21:22,430 --> 00:21:29,090
means paying attention to the DSL design

00:21:25,570 --> 00:21:32,750
making the DSL design look more Ruby

00:21:29,090 --> 00:21:35,150
like making it fit into a ruby context

00:21:32,750 --> 00:21:37,160
now that's kind of hand wavy so let's

00:21:35,150 --> 00:21:38,840
unpack this a bit and to do that we're

00:21:37,160 --> 00:21:41,330
gonna take a look at another issue that

00:21:38,840 --> 00:21:43,670
comes up all the time when we use dsls

00:21:41,330 --> 00:21:46,390
and that's helper methods alright as

00:21:43,670 --> 00:21:48,950
Ruby developers we like short methods

00:21:46,390 --> 00:21:51,650
short methods are readable they're more

00:21:48,950 --> 00:21:53,900
testable your users are gonna run to

00:21:51,650 --> 00:21:56,090
want to write short methods and that

00:21:53,900 --> 00:21:58,100
means they're gonna want to write helper

00:21:56,090 --> 00:22:03,530
methods they're gonna want to decompose

00:21:58,100 --> 00:22:05,570
their logic now when a user decides they

00:22:03,530 --> 00:22:06,920
want to use your DSL and they need to

00:22:05,570 --> 00:22:13,930
write helper methods where do they put

00:22:06,920 --> 00:22:13,930
them where two helper methods go here

00:22:14,410 --> 00:22:20,150
Ruby methods belong in classes or

00:22:16,940 --> 00:22:21,680
modules right we all know that so what

00:22:20,150 --> 00:22:24,200
do we what do you do if you're using a

00:22:21,680 --> 00:22:26,900
DSL like this it has blocks but no

00:22:24,200 --> 00:22:29,750
classes or modules if I define the

00:22:26,900 --> 00:22:31,730
helper method where do I put it what

00:22:29,750 --> 00:22:36,740
class does it actually end up connected

00:22:31,730 --> 00:22:38,710
to how do I call it can I call it this

00:22:36,740 --> 00:22:41,720
is one of the big challenges of DSL

00:22:38,710 --> 00:22:45,830
you're removing Ruby code from their

00:22:41,720 --> 00:22:48,140
normal context in as parts of modules

00:22:45,830 --> 00:22:52,700
parts of classes and this creates some

00:22:48,140 --> 00:22:55,430
ambiguity in the usage so let's explore

00:22:52,700 --> 00:22:57,380
this just a bit in many cases what

00:22:55,430 --> 00:22:59,210
actually happens what users will

00:22:57,380 --> 00:23:02,450
actually do is define helper methods at

00:22:59,210 --> 00:23:03,650
the top level of the Ruby file so if

00:23:02,450 --> 00:23:05,750
you're you're writing a sign

00:23:03,650 --> 00:23:08,600
trap or a rake file or one of those

00:23:05,750 --> 00:23:10,850
those DSL typically this is what you've

00:23:08,600 --> 00:23:13,700
done right you you you rights the helper

00:23:10,850 --> 00:23:15,320
methods at the top level now if we do

00:23:13,700 --> 00:23:20,170
this where does that method actually end

00:23:15,320 --> 00:23:22,730
up it's part of a class object correct

00:23:20,170 --> 00:23:24,920
by default when you define a method the

00:23:22,730 --> 00:23:28,910
top-level it becomes a private method of

00:23:24,920 --> 00:23:30,980
the object class okay now since the

00:23:28,910 --> 00:23:33,410
object is a base class for everything

00:23:30,980 --> 00:23:35,960
including your DSL class this actually

00:23:33,410 --> 00:23:37,670
works out your users call their helper

00:23:35,960 --> 00:23:39,320
method and it looks like they're calling

00:23:37,670 --> 00:23:41,510
it directly like it looks like this is

00:23:39,320 --> 00:23:44,390
just a direct method call but actually

00:23:41,510 --> 00:23:47,510
it's if it's in instance eval it's being

00:23:44,390 --> 00:23:49,910
called through the DSL class your DSL

00:23:47,510 --> 00:23:51,800
class and so the method call is going

00:23:49,910 --> 00:23:56,120
through there then it's going down to

00:23:51,800 --> 00:23:58,580
the the superclass just objects and and

00:23:56,120 --> 00:24:00,650
then it finds the method there so it

00:23:58,580 --> 00:24:03,980
just kind of happens to work out but

00:24:00,650 --> 00:24:06,610
it's a little bit roundabout now this

00:24:03,980 --> 00:24:10,820
does have an important implication and

00:24:06,610 --> 00:24:13,520
that's basic object basic object is

00:24:10,820 --> 00:24:15,679
intended as a blank slate class so it

00:24:13,520 --> 00:24:17,750
has far fewer methods and objects and

00:24:15,679 --> 00:24:22,370
that means for some of us it can be

00:24:17,750 --> 00:24:26,929
tempting to use it as a DSL class don't

00:24:22,370 --> 00:24:29,900
do this because it does not include that

00:24:26,929 --> 00:24:33,050
users helper method that helper methods

00:24:29,900 --> 00:24:35,570
defines on object not basic object so

00:24:33,050 --> 00:24:38,300
the DSL does not inherit it and the user

00:24:35,570 --> 00:24:41,720
cannot call it within that that instance

00:24:38,300 --> 00:24:44,870
eval block now it's important to

00:24:41,720 --> 00:24:47,600
understand what basic object is it kind

00:24:44,870 --> 00:24:51,470
of takes you out of the normal

00:24:47,600 --> 00:24:54,110
Ruby class hierarchy it takes you out of

00:24:51,470 --> 00:24:56,179
the normal Ruby context and so some

00:24:54,110 --> 00:25:01,160
things that your users might normally

00:24:56,179 --> 00:25:03,920
expect of Ruby will not work kernel

00:25:01,160 --> 00:25:06,290
methods methods like put s or sleep will

00:25:03,920 --> 00:25:08,780
not work methods of the object class

00:25:06,290 --> 00:25:11,120
some of Ruby's language features are

00:25:08,780 --> 00:25:12,250
implemented as kernel methods and they

00:25:11,120 --> 00:25:15,110
will not work

00:25:12,250 --> 00:25:16,160
of course the users helper methods will

00:25:15,110 --> 00:25:18,590
not work

00:25:16,160 --> 00:25:22,370
now there are cases when basic object

00:25:18,590 --> 00:25:24,770
might be useful but usually it's better

00:25:22,370 --> 00:25:28,850
to avoid it for dsls because it takes

00:25:24,770 --> 00:25:31,760
you out of the Ruby class hierarchy it

00:25:28,850 --> 00:25:36,770
increases the difference between your

00:25:31,760 --> 00:25:39,050
DSL and normal Ruby okay so let's go

00:25:36,770 --> 00:25:41,930
back to our helper method what if we

00:25:39,050 --> 00:25:45,740
move this helper method here inside the

00:25:41,930 --> 00:25:48,200
block so defining a method inside a DSL

00:25:45,740 --> 00:25:50,900
block what would happen what would

00:25:48,200 --> 00:25:54,920
happen what would a user expect to

00:25:50,900 --> 00:25:57,020
happen if you did this again methods are

00:25:54,920 --> 00:26:03,730
usually defined in classes or modules

00:25:57,020 --> 00:26:07,360
not blocks so we have an ambiguity here

00:26:03,730 --> 00:26:11,180
now I would argue that for the most part

00:26:07,360 --> 00:26:13,610
developers expect lexical scoping when

00:26:11,180 --> 00:26:15,800
they work with blocks they expect

00:26:13,610 --> 00:26:18,020
lexical scoping they expect methods to

00:26:15,800 --> 00:26:23,210
be visible based on the lexical

00:26:18,020 --> 00:26:25,930
structure of their code so it's useful

00:26:23,210 --> 00:26:31,220
to know useful to do as much as possible

00:26:25,930 --> 00:26:34,460
honor lexical scoping honor lexical

00:26:31,220 --> 00:26:38,090
scoping whenever you design whenever you

00:26:34,460 --> 00:26:42,820
implement a DSL now unfortunately in

00:26:38,090 --> 00:26:45,680
Ruby this does not always come for free

00:26:42,820 --> 00:26:49,220
local variables are lexically scoped by

00:26:45,680 --> 00:26:51,230
default but methods are different you

00:26:49,220 --> 00:26:59,300
don't always get them for free so let's

00:26:51,230 --> 00:27:00,290
dig into that a bit so we've used

00:26:59,300 --> 00:27:03,440
instance eval

00:27:00,290 --> 00:27:05,990
so they implement this block in general

00:27:03,440 --> 00:27:08,660
you use instance eval any methods

00:27:05,990 --> 00:27:11,320
defines in that block and get added to

00:27:08,660 --> 00:27:15,230
the singleton class of the DSL object

00:27:11,320 --> 00:27:16,840
alright methods on it eval block are

00:27:15,230 --> 00:27:19,580
defined on the singleton class

00:27:16,840 --> 00:27:22,010
effectively the method is added to self

00:27:19,580 --> 00:27:24,290
its methods added to that one object and

00:27:22,010 --> 00:27:26,500
nothing else okay

00:27:24,290 --> 00:27:28,820
so what we have here kind of works out

00:27:26,500 --> 00:27:29,840
right because that method is defined on

00:27:28,820 --> 00:27:33,080
self

00:27:29,840 --> 00:27:35,150
and word instant eval so we call it we

00:27:33,080 --> 00:27:38,809
can call it directly on self and we're

00:27:35,150 --> 00:27:41,539
able to call it when you have more than

00:27:38,809 --> 00:27:43,820
one block you do have to pay more

00:27:41,539 --> 00:27:46,820
attention say you have two separate

00:27:43,820 --> 00:27:49,360
blocks like this now lexical scoping

00:27:46,820 --> 00:27:52,880
implies that these are separate scopes

00:27:49,360 --> 00:27:54,470
right scoping implies these are separate

00:27:52,880 --> 00:27:58,039
methods in separate scopes and they only

00:27:54,470 --> 00:27:59,510
apply within their block so you need

00:27:58,039 --> 00:28:01,760
some big you need to make sure that you

00:27:59,510 --> 00:28:05,450
implements that make sure that you have

00:28:01,760 --> 00:28:07,250
a separate DSL object for each block so

00:28:05,450 --> 00:28:10,520
that you end up with those separate

00:28:07,250 --> 00:28:12,350
scopes don't reuse that the same DSL

00:28:10,520 --> 00:28:15,320
object or those two methods will collide

00:28:12,350 --> 00:28:19,539
and users don't expect that they expect

00:28:15,320 --> 00:28:21,470
lexical scoping what about nested blocks

00:28:19,539 --> 00:28:21,940
now we're starting to get a little more

00:28:21,470 --> 00:28:24,830
tricky

00:28:21,940 --> 00:28:28,520
both r-spec and mini tests support

00:28:24,830 --> 00:28:31,390
nested described blocks so it is

00:28:28,520 --> 00:28:34,429
important it is an important use case

00:28:31,390 --> 00:28:36,700
but it's kind of tricky that inner block

00:28:34,429 --> 00:28:40,340
needs to be able to call a method

00:28:36,700 --> 00:28:42,470
defined in the outer block so in this

00:28:40,340 --> 00:28:44,690
case try speaking is defined in outer

00:28:42,470 --> 00:28:47,840
you expect to be able to call it from

00:28:44,690 --> 00:28:49,700
inner but not vice versa

00:28:47,840 --> 00:28:52,669
so if you defined that method and inner

00:28:49,700 --> 00:28:55,760
you would not be able to you would not

00:28:52,669 --> 00:28:58,279
expect to be able to see it in outer so

00:28:55,760 --> 00:29:01,640
that means you still cannot reuse the

00:28:58,279 --> 00:29:04,850
same DSL object for those two those two

00:29:01,640 --> 00:29:06,890
blocks but still the inner block somehow

00:29:04,850 --> 00:29:11,480
needs to be able to access methods are

00:29:06,890 --> 00:29:13,490
defined on the outer block one approach

00:29:11,480 --> 00:29:15,770
to solving this is to delegate method

00:29:13,490 --> 00:29:17,630
calls from the inner object to the outer

00:29:15,770 --> 00:29:20,120
so you can use something like method

00:29:17,630 --> 00:29:22,309
missing or you know there are there

00:29:20,120 --> 00:29:24,470
various techniques to delegate method

00:29:22,309 --> 00:29:26,210
calls so if your inner DSL object

00:29:24,470 --> 00:29:29,779
doesn't understand the method you should

00:29:26,210 --> 00:29:34,580
delegate it to the outer DSL method or

00:29:29,779 --> 00:29:36,590
DSL object or another option we'll talk

00:29:34,580 --> 00:29:38,990
about classes next if you're using

00:29:36,590 --> 00:29:41,809
classes you can have the inner object

00:29:38,990 --> 00:29:43,090
subclass the outer object now either way

00:29:41,809 --> 00:29:45,490
Ruby doesn't give you this

00:29:43,090 --> 00:29:47,830
behavior for free you have you probably

00:29:45,490 --> 00:29:49,500
have to do this explicitly your DSL

00:29:47,830 --> 00:29:52,060
needs to be intentional about

00:29:49,500 --> 00:29:53,670
implementing lexical scoping when it

00:29:52,060 --> 00:29:57,130
comes to methods

00:29:53,670 --> 00:30:01,650
here's another useful technique model

00:29:57,130 --> 00:30:05,140
classes in your DSL model classes

00:30:01,650 --> 00:30:09,130
classes this is kind of what r-spec and

00:30:05,140 --> 00:30:12,760
mini tests actually do for for describe

00:30:09,130 --> 00:30:15,400
blocks not exactly but it's close they

00:30:12,760 --> 00:30:20,500
model describe blocks so they resemble

00:30:15,400 --> 00:30:22,630
classes then for each test they create a

00:30:20,500 --> 00:30:24,640
new instance of that class and that's

00:30:22,630 --> 00:30:28,180
isolates tests from each other right so

00:30:24,640 --> 00:30:29,890
it's a very useful technique but what's

00:30:28,180 --> 00:30:32,920
really nice about this is it makes it

00:30:29,890 --> 00:30:37,480
obvious how helper methods should behave

00:30:32,920 --> 00:30:39,490
like if a describe block is a class then

00:30:37,480 --> 00:30:42,520
that method is just a method of the

00:30:39,490 --> 00:30:44,320
class however once again you don't

00:30:42,520 --> 00:30:46,930
necessarily get that for free you have

00:30:44,320 --> 00:30:48,940
to be intentional about it for example

00:30:46,930 --> 00:30:51,220
in this case you might need to use class

00:30:48,940 --> 00:30:53,680
eval rather than instance eval so just

00:30:51,220 --> 00:30:55,450
to execute that described block that's

00:30:53,680 --> 00:30:58,500
to make sure those helper methods are

00:30:55,450 --> 00:31:01,240
added as normal methods and not as class

00:30:58,500 --> 00:31:03,490
methods as single not as singleton class

00:31:01,240 --> 00:31:05,350
methods if you've ever wondered about

00:31:03,490 --> 00:31:08,140
what the difference is between instance

00:31:05,350 --> 00:31:10,990
eval and class eval they both set self

00:31:08,140 --> 00:31:13,660
but they differ in how they treat method

00:31:10,990 --> 00:31:15,580
definitions inside the block so if

00:31:13,660 --> 00:31:17,470
you're writing a DSL it's important to

00:31:15,580 --> 00:31:19,180
understand that difference and be

00:31:17,470 --> 00:31:23,530
intentional about using the right

00:31:19,180 --> 00:31:26,140
constructs so in general modeling DSL

00:31:23,530 --> 00:31:28,870
blocks as as classes is often a very

00:31:26,140 --> 00:31:33,580
useful technique again because classes

00:31:28,870 --> 00:31:35,620
are a ruby concept classes are Ruby

00:31:33,580 --> 00:31:39,100
concepts if you model classes in your

00:31:35,620 --> 00:31:40,810
DSL it brings your DSL closer to Ruby it

00:31:39,100 --> 00:31:43,270
reduces confusion it makes it more

00:31:40,810 --> 00:31:45,640
obvious to your users what's going on

00:31:43,270 --> 00:31:48,760
and it can make it easier for you as an

00:31:45,640 --> 00:31:51,610
implementer to avoid corner cases now a

00:31:48,760 --> 00:31:53,440
little side note here constants

00:31:51,610 --> 00:31:55,360
constants raise some of the same

00:31:53,440 --> 00:31:56,860
questions as me as method definitions

00:31:55,360 --> 00:31:58,600
you know they're attached

00:31:56,860 --> 00:32:01,000
modules or classes usually so if I

00:31:58,600 --> 00:32:02,400
define a constant where does it go will

00:32:01,000 --> 00:32:04,390
I be able to access it

00:32:02,400 --> 00:32:07,240
unfortunately constants are kind of a

00:32:04,390 --> 00:32:09,640
pain they're not affected by instance

00:32:07,240 --> 00:32:12,970
eval they're not affected by class eval

00:32:09,640 --> 00:32:15,850
you really can't control very well where

00:32:12,970 --> 00:32:17,890
they end up in hindsight they probably

00:32:15,850 --> 00:32:22,540
should have been but it's not how they

00:32:17,890 --> 00:32:24,850
work so the upshot is generally

00:32:22,540 --> 00:32:29,080
constants cannot be made to avoid like

00:32:24,850 --> 00:32:31,570
to be made to obey lexical scoping using

00:32:29,080 --> 00:32:33,610
techniques that we've talked about so

00:32:31,570 --> 00:32:34,870
these two constants here they're in

00:32:33,610 --> 00:32:36,520
different blocks and they appear to be

00:32:34,870 --> 00:32:39,100
in different scopes but actually they're

00:32:36,520 --> 00:32:41,230
not they're not they both behave as if

00:32:39,100 --> 00:32:43,660
they are defined at the top level on the

00:32:41,230 --> 00:32:46,030
object class in fact that second

00:32:43,660 --> 00:32:48,160
definition is going to trigger a warning

00:32:46,030 --> 00:32:52,240
because you're actually redefining the

00:32:48,160 --> 00:32:53,740
constant there that's confusing that's

00:32:52,240 --> 00:32:56,110
confusing and really there's a way

00:32:53,740 --> 00:32:57,700
around it there at least there's no good

00:32:56,110 --> 00:33:01,179
way to fix it there might be ways that

00:32:57,700 --> 00:33:04,840
you can hack using eval and some and

00:33:01,179 --> 00:33:07,030
some code code generation but really the

00:33:04,840 --> 00:33:08,350
advice that I would give when do you

00:33:07,030 --> 00:33:10,360
think Constance is actually to

00:33:08,350 --> 00:33:12,940
discourage your users from using them

00:33:10,360 --> 00:33:16,299
and a good way to do that is to provide

00:33:12,940 --> 00:33:18,549
alternatives provide another way to do

00:33:16,299 --> 00:33:21,820
the kinds of things that you'd normally

00:33:18,549 --> 00:33:24,669
use constants for here's an example from

00:33:21,820 --> 00:33:27,790
r-spec our spec provides a construct

00:33:24,669 --> 00:33:31,120
called let and let's give users an

00:33:27,790 --> 00:33:32,740
alternative to creating constants you

00:33:31,120 --> 00:33:34,870
know there's an idiomatic alternative

00:33:32,740 --> 00:33:36,179
and indeed a better one because it does

00:33:34,870 --> 00:33:42,160
lazy evaluation

00:33:36,179 --> 00:33:43,630
all right so provide alternatives no to

00:33:42,160 --> 00:33:46,360
be honest Ruby constants are kind of a

00:33:43,630 --> 00:33:48,760
mess always have been especially in the

00:33:46,360 --> 00:33:51,400
context of a DSL so the more that you

00:33:48,760 --> 00:33:54,160
can guide your users using alternatives

00:33:51,400 --> 00:33:56,380
or other mechanisms whether you can

00:33:54,160 --> 00:34:00,040
guide your users to avoid them I think

00:33:56,380 --> 00:34:01,450
the better off that you'll be all right

00:34:00,040 --> 00:34:04,480
so we've talked about a number of issues

00:34:01,450 --> 00:34:08,649
here we've talked about ways to insulate

00:34:04,480 --> 00:34:10,770
your DSL from Ruby remember with the DSL

00:34:08,649 --> 00:34:14,559
there's no such thing as private

00:34:10,770 --> 00:34:18,039
so separate your DSL interface from its

00:34:14,559 --> 00:34:19,990
implementation use a naming convention

00:34:18,039 --> 00:34:24,010
for instance variables for private

00:34:19,990 --> 00:34:26,679
methods we also talked about designing

00:34:24,010 --> 00:34:29,919
your DSL to look and behave more like

00:34:26,679 --> 00:34:32,349
Ruby more like normal Ruby so we talked

00:34:29,919 --> 00:34:34,450
about changing as little as possible we

00:34:32,349 --> 00:34:36,520
talked about adding methods only where

00:34:34,450 --> 00:34:38,950
they're needed we talked about helper

00:34:36,520 --> 00:34:41,409
methods designing for a lexical scoping

00:34:38,950 --> 00:34:44,889
avoiding basic objects we talked about

00:34:41,409 --> 00:34:47,940
modeling familiar Ruby caught concepts

00:34:44,889 --> 00:34:51,280
like classes in your DSL just to

00:34:47,940 --> 00:34:53,740
eliminate some of that difference that

00:34:51,280 --> 00:34:59,280
cognitive difference and it's important

00:34:53,740 --> 00:35:01,690
to make your DSL more Ruby like in fact

00:34:59,280 --> 00:35:06,339
personally I don't really like the term

00:35:01,690 --> 00:35:09,480
DSL I used to use it a lot I rigged a

00:35:06,339 --> 00:35:11,710
fair number of DSL in my time both for

00:35:09,480 --> 00:35:15,400
asked his application development as

00:35:11,710 --> 00:35:17,829
well as for libraries I used to call

00:35:15,400 --> 00:35:20,710
them DSL these days I prefer not to say

00:35:17,829 --> 00:35:23,230
domain-specific language because we're

00:35:20,710 --> 00:35:25,289
not writing a language not really

00:35:23,230 --> 00:35:28,539
writing a language we're writing Ruby

00:35:25,289 --> 00:35:31,900
we're always writing Ruby we're creating

00:35:28,539 --> 00:35:34,900
DSR domain-specific Ruby we're still

00:35:31,900 --> 00:35:36,130
writing Ruby I think it's very important

00:35:34,900 --> 00:35:38,349
to keep that in mind

00:35:36,130 --> 00:35:41,890
as we do this Ruby's meta programming

00:35:38,349 --> 00:35:44,859
techniques are very very powerful

00:35:41,890 --> 00:35:48,520
they're very very useful but the more we

00:35:44,859 --> 00:35:51,520
treat them as a separate language the

00:35:48,520 --> 00:35:53,319
more we try to divorce it from Ruby the

00:35:51,520 --> 00:35:56,559
more we open ourselves up to a lot of

00:35:53,319 --> 00:35:57,579
risk and that this I don't think that's

00:35:56,559 --> 00:36:02,079
really necessary

00:35:57,579 --> 00:36:06,490
so instead think of it as just Ruby when

00:36:02,079 --> 00:36:09,910
you design your next DSR think about how

00:36:06,490 --> 00:36:11,589
you can make it look like Ruby think

00:36:09,910 --> 00:36:15,099
about how you can make it smell like

00:36:11,589 --> 00:36:19,829
Ruby don't stray too far from Ruby

00:36:15,099 --> 00:36:22,900
idioms ruby concepts Ruby constructs

00:36:19,829 --> 00:36:24,099
model it after Ruby and I think you'll

00:36:22,900 --> 00:36:26,680
find that you

00:36:24,099 --> 00:36:29,229
end up with a much more robust and a

00:36:26,680 --> 00:36:34,040
much less confusing experience for your

00:36:29,229 --> 00:36:39,510
users thank you for coming

00:36:34,040 --> 00:36:52,810
[Applause]

00:36:39,510 --> 00:36:52,810

YouTube URL: https://www.youtube.com/watch?v=Ov-tMtOkKS4


