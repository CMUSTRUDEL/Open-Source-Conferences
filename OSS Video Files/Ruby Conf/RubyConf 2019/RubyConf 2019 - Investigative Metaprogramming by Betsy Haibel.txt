Title: RubyConf 2019 - Investigative Metaprogramming by Betsy Haibel
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Investigative Metaprogramming by Betsy Haibel

When was the last time you got an un-Googleable error? The kind that takes you and your lead three days to debug, with weird generic stacktraces deep in framework internals? What if you could approach that bug with something other than trial, error, and tears? Metaprogramming can come to the rescue -- just not the kind you do in production. In this talk, you'll learn strategies for investigative metaprogramming. You'll learn how to insert debugging hooks anywhere and instrument anything. You'll even learn how to turn that information into actionable bugfixes.

#confreaks #rubyconf2019
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:11,830 --> 00:00:15,650
all right so today we're going to be

00:00:14,330 --> 00:00:17,539
talking a bit about using meta

00:00:15,650 --> 00:00:20,029
programming to debug issues that would

00:00:17,539 --> 00:00:21,279
otherwise be extremely difficult to

00:00:20,029 --> 00:00:23,869
figure out

00:00:21,279 --> 00:00:26,089
now speaking of difficult to figure out

00:00:23,869 --> 00:00:28,939
I want to say up front that there are a

00:00:26,089 --> 00:00:30,740
few bugs in my keynote animations how

00:00:28,939 --> 00:00:33,980
many of you have done a lot of CSS who

00:00:30,740 --> 00:00:35,360
are a lot of sequel so like we know that

00:00:33,980 --> 00:00:37,910
when we're programming declaratively

00:00:35,360 --> 00:00:41,240
like in CSS or sequel it turns out

00:00:37,910 --> 00:00:44,650
keynote it's incredibly efficient about

00:00:41,240 --> 00:00:46,910
95% of the time and then there's that 5%

00:00:44,650 --> 00:00:51,200
where you and the interpreter have a

00:00:46,910 --> 00:00:53,750
very different opinion about reality and

00:00:51,200 --> 00:00:57,650
I'm ringing that up not just visited

00:00:53,750 --> 00:01:00,670
disclaimer and an apology but actually

00:00:57,650 --> 00:01:04,009
is a Content warning if you have

00:01:00,670 --> 00:01:06,740
cognitive issues or other sensitivities

00:01:04,009 --> 00:01:09,350
that mean that seeing stuttery

00:01:06,740 --> 00:01:11,329
animations might be difficult or

00:01:09,350 --> 00:01:13,039
dangerous for you I unfortunately cannot

00:01:11,329 --> 00:01:16,810
promise that my talk is going to be

00:01:13,039 --> 00:01:16,810
entirely free as that I'm sorry

00:01:17,390 --> 00:01:22,609
so continuing on in the spirit of

00:01:19,070 --> 00:01:25,819
talking about bugs it's time for another

00:01:22,609 --> 00:01:27,350
scary debugging story I know it's like a

00:01:25,819 --> 00:01:28,850
whole three weeks after Halloween and

00:01:27,350 --> 00:01:33,590
we're supposed to be over that now but

00:01:28,850 --> 00:01:35,060
bear with me about a year ago I was

00:01:33,590 --> 00:01:38,030
working with a consulting client on a

00:01:35,060 --> 00:01:39,619
rails major version upgrade in the

00:01:38,030 --> 00:01:41,780
course of this project we encountered

00:01:39,619 --> 00:01:43,340
complicated meta programming that

00:01:41,780 --> 00:01:46,429
interacted strangely with the rails

00:01:43,340 --> 00:01:48,049
autosave internals this meta program

00:01:46,429 --> 00:01:51,020
code had been written about a decade

00:01:48,049 --> 00:01:53,630
before by contractors who'd worked on

00:01:51,020 --> 00:01:56,299
the original Greenfields by many of whom

00:01:53,630 --> 00:01:58,520
left the project shortly after and had

00:01:56,299 --> 00:02:04,100
not been there at all in the intervening

00:01:58,520 --> 00:02:09,940
decade it all started when the tests

00:02:04,100 --> 00:02:12,560
failed with this one obscure error deep

00:02:09,940 --> 00:02:15,680
into the rails internals with a stack

00:02:12,560 --> 00:02:20,640
trace about three screens long

00:02:15,680 --> 00:02:21,750
we tried googling but stackoverflow was

00:02:20,640 --> 00:02:24,299
completely useless

00:02:21,750 --> 00:02:26,189
there was this one github issue for path

00:02:24,299 --> 00:02:28,500
debris bot that kind of looked right and

00:02:26,189 --> 00:02:30,000
we thought maybe because we had just

00:02:28,500 --> 00:02:31,680
switch from mechanized to factory taught

00:02:30,000 --> 00:02:35,549
since mechanized didn't work with rails

00:02:31,680 --> 00:02:38,040
5 but following up on what that is she

00:02:35,549 --> 00:02:42,930
told us didn't pan out either and so we

00:02:38,040 --> 00:02:44,340
were in an unhappy place and right now

00:02:42,930 --> 00:02:47,400
you're probably guessing in your heads

00:02:44,340 --> 00:02:50,280
about the epic road ahead of us maybe it

00:02:47,400 --> 00:03:01,560
took us a few days to solve this few

00:02:50,280 --> 00:03:04,290
weeks now two hours there wasn't that

00:03:01,560 --> 00:03:06,569
much of a trick to it even we knew the

00:03:04,290 --> 00:03:09,450
problem we were seeing was can't modify

00:03:06,569 --> 00:03:12,389
frozen ash we knew we're really seeing

00:03:09,450 --> 00:03:14,370
that problem the trick play and

00:03:12,389 --> 00:03:15,989
realizing that that was not a useful

00:03:14,370 --> 00:03:19,290
thing for us to understand in the moment

00:03:15,989 --> 00:03:23,459
what we really needed to know instead

00:03:19,290 --> 00:03:26,430
was where the hash froze you can't

00:03:23,459 --> 00:03:28,139
rewind time from an error but you can

00:03:26,430 --> 00:03:32,579
add debugging logic when you're

00:03:28,139 --> 00:03:35,220
replicating a bug we're able to use some

00:03:32,579 --> 00:03:38,400
simple light meta programming just the

00:03:35,220 --> 00:03:40,379
contents of this page to insert the stig

00:03:38,400 --> 00:03:41,209
this debug code and identify where the

00:03:40,379 --> 00:03:43,859
hash was freezing

00:03:41,209 --> 00:03:46,620
we followed a pretty simple process it

00:03:43,859 --> 00:03:49,680
fits on slide we added some telemetry

00:03:46,620 --> 00:03:51,090
and then later on we looked at the

00:03:49,680 --> 00:03:53,970
relevant data that the telemetry had

00:03:51,090 --> 00:03:55,260
surfaced this would honestly be a very

00:03:53,970 --> 00:03:57,299
boring story if it weren't for the fact

00:03:55,260 --> 00:03:59,129
that involved meta programming and the

00:03:57,299 --> 00:04:02,819
fact that it turned a 2-week bug into a

00:03:59,129 --> 00:04:04,500
2-hour one now right now so the more

00:04:02,819 --> 00:04:09,209
pedantic among you may be wondering

00:04:04,500 --> 00:04:10,980
where the meta programming is and so I'd

00:04:09,209 --> 00:04:14,579
like to take us us to take a quick

00:04:10,980 --> 00:04:16,169
moment to define meta programming y'all

00:04:14,579 --> 00:04:18,000
may be worried that this is a horrible

00:04:16,169 --> 00:04:20,889
tangent detour mess and that this talk

00:04:18,000 --> 00:04:23,120
is careening off the rails

00:04:20,889 --> 00:04:24,350
now when I was practicing this chalk in

00:04:23,120 --> 00:04:25,820
front of my team at work I hadn't

00:04:24,350 --> 00:04:28,070
written my speaker notes yet and I was

00:04:25,820 --> 00:04:29,419
kind of improving I said that off the

00:04:28,070 --> 00:04:31,550
rails bit entirely straight faced

00:04:29,419 --> 00:04:32,930
without intentionally making a pun but

00:04:31,550 --> 00:04:34,280
then my teammates laughed like I'd done

00:04:32,930 --> 00:04:41,180
it on purpose so we're all stuck with

00:04:34,280 --> 00:04:42,759
that joke now anyway this talk is going

00:04:41,180 --> 00:04:45,050
to concern itself with three questions

00:04:42,759 --> 00:04:47,870
first off how do we define meta

00:04:45,050 --> 00:04:49,130
programming in the context of Ruby it

00:04:47,870 --> 00:04:52,130
turns out that the way that meta

00:04:49,130 --> 00:04:54,229
programming works in Ruby is pretty

00:04:52,130 --> 00:04:56,150
different than how some other languages

00:04:54,229 --> 00:04:58,490
do meta programming and that that's

00:04:56,150 --> 00:05:00,110
actually related to why is Ruby is

00:04:58,490 --> 00:05:03,860
sometimes hard to debug with other

00:05:00,110 --> 00:05:05,660
languages tools after that we're going

00:05:03,860 --> 00:05:07,729
to look at some peculiar lis Ruby ish

00:05:05,660 --> 00:05:09,680
ways that we can use meta programming to

00:05:07,729 --> 00:05:13,520
investigate what's going on inside the

00:05:09,680 --> 00:05:15,259
Ruby VM and then finally we're going to

00:05:13,520 --> 00:05:17,509
return to the story I just told you and

00:05:15,259 --> 00:05:18,349
examine it in more depth we'll talk

00:05:17,509 --> 00:05:19,490
about how we can apply these

00:05:18,349 --> 00:05:22,460
investigative meta programming

00:05:19,490 --> 00:05:24,229
techniques IRL to read out bugs root

00:05:22,460 --> 00:05:28,580
causes much more quickly than we could

00:05:24,229 --> 00:05:30,949
otherwise so for starters what is meta

00:05:28,580 --> 00:05:33,500
programming when we talk about meta

00:05:30,949 --> 00:05:36,500
programming we tend to superimpose two

00:05:33,500 --> 00:05:37,909
definitions in our heads there's the

00:05:36,500 --> 00:05:40,159
academic definition that we're taught to

00:05:37,909 --> 00:05:41,539
use in technical interviews and then

00:05:40,159 --> 00:05:43,099
there's a slightly more pragmatic

00:05:41,539 --> 00:05:46,330
definition that is how most of us

00:05:43,099 --> 00:05:48,860
actually think about meta programming

00:05:46,330 --> 00:05:51,409
one of the common academic definitions

00:05:48,860 --> 00:05:53,659
is code that modifies the structure of

00:05:51,409 --> 00:05:55,190
the program at runtime and according to

00:05:53,659 --> 00:05:55,520
some extensive Twitter research on my

00:05:55,190 --> 00:05:57,979
part

00:05:55,520 --> 00:06:00,229
the most common pragmatic definition is

00:05:57,979 --> 00:06:02,380
code I can't analyze using a full text

00:06:00,229 --> 00:06:02,380
search

00:06:05,110 --> 00:06:09,770
what's interesting to me is the way that

00:06:07,310 --> 00:06:11,300
these definitions conflict there's a

00:06:09,770 --> 00:06:13,100
hole you can drive a Mack truck through

00:06:11,300 --> 00:06:16,940
and that hole is the existence of the

00:06:13,100 --> 00:06:18,860
send in Ruby we don't really call

00:06:16,940 --> 00:06:21,230
methods on objects so much

00:06:18,860 --> 00:06:23,030
that's just syntactic sugar which is to

00:06:21,230 --> 00:06:25,820
say a lie we made up to make Ruby look

00:06:23,030 --> 00:06:28,010
more like other languages in Ruby we

00:06:25,820 --> 00:06:30,080
send messages to objects and then those

00:06:28,010 --> 00:06:32,480
objects decide how they want to react to

00:06:30,080 --> 00:06:34,610
those messages whenever you call a

00:06:32,480 --> 00:06:39,080
method in Ruby it's really just an alias

00:06:34,610 --> 00:06:40,700
for calling send this means that if part

00:06:39,080 --> 00:06:42,410
of your code base calls send with a

00:06:40,700 --> 00:06:44,900
variable value rather than a static

00:06:42,410 --> 00:06:46,910
value you can't use full text search to

00:06:44,900 --> 00:06:49,970
determine all the places that methods on

00:06:46,910 --> 00:06:51,650
that object are used using the send with

00:06:49,970 --> 00:06:53,300
variables falls firmly within most

00:06:51,650 --> 00:06:55,220
people's practical definition of meta

00:06:53,300 --> 00:06:57,320
programming even though it doesn't do

00:06:55,220 --> 00:07:02,750
anything like modifying the structure of

00:06:57,320 --> 00:07:04,250
the program at runtime and so okay maybe

00:07:02,750 --> 00:07:06,710
we can get out of this hole by trying to

00:07:04,250 --> 00:07:08,630
modify the academic definition maybe we

00:07:06,710 --> 00:07:11,420
can modify a team or exclusive inclusive

00:07:08,630 --> 00:07:12,830
of sin maybe it's not just code that

00:07:11,420 --> 00:07:15,140
modifies program structure at runtime

00:07:12,830 --> 00:07:19,610
but also code that determines the method

00:07:15,140 --> 00:07:21,530
to be invoked then oops that definition

00:07:19,610 --> 00:07:26,660
is even more vulnerable to having rules

00:07:21,530 --> 00:07:28,940
poked in it is there any practical

00:07:26,660 --> 00:07:30,710
distinction between determining the

00:07:28,940 --> 00:07:33,320
method to be invoked at runtime by using

00:07:30,710 --> 00:07:35,230
send with a variable and determining the

00:07:33,320 --> 00:07:38,420
exact same thing with an if statement

00:07:35,230 --> 00:07:41,540
not to me not from a theoretical

00:07:38,420 --> 00:07:43,010
perspective anyway like yes you can full

00:07:41,540 --> 00:07:45,560
text search for one and not the other

00:07:43,010 --> 00:07:47,120
and that is a very real difference but

00:07:45,560 --> 00:07:50,420
it's not a difference that can be

00:07:47,120 --> 00:07:52,830
captured easily by talking about this in

00:07:50,420 --> 00:07:55,229
terms of what happens when

00:07:52,830 --> 00:07:57,930
and while I'm playing the well actually

00:07:55,229 --> 00:08:02,280
gave on my own talk I'd like to also

00:07:57,930 --> 00:08:05,159
zoom in on this at runtime business Ruby

00:08:02,280 --> 00:08:06,780
is an interpreted language interpreted

00:08:05,159 --> 00:08:09,509
languages sometimes the distinction

00:08:06,780 --> 00:08:12,360
between load time and run time breaks

00:08:09,509 --> 00:08:15,440
down and some things about the structure

00:08:12,360 --> 00:08:18,440
of Ruby make that difference especially

00:08:15,440 --> 00:08:18,440
meaningless

00:08:20,180 --> 00:08:24,180
so let's take a zoom into the Ruby

00:08:22,560 --> 00:08:28,560
interpreter and how it loads a pretty

00:08:24,180 --> 00:08:29,370
basic class we've all written code like

00:08:28,560 --> 00:08:33,419
this before

00:08:29,370 --> 00:08:35,789
simple class one getter one Center after

00:08:33,419 --> 00:08:37,349
our Ruby file has been parsed their

00:08:35,789 --> 00:08:40,800
interpreter goes through the generated

00:08:37,349 --> 00:08:42,089
abstract syntax tree node by node it

00:08:40,800 --> 00:08:43,919
gets from a node that defines a class

00:08:42,089 --> 00:08:47,490
and it builds a class both from the

00:08:43,919 --> 00:08:50,040
virtual machine then every time we

00:08:47,490 --> 00:08:53,570
define method it has the method to the

00:08:50,040 --> 00:08:53,570
list of instance methods for that class

00:08:54,529 --> 00:09:00,959
but under the hood it's actually doing

00:08:58,620 --> 00:09:05,010
something a little more like this it's

00:09:00,959 --> 00:09:06,720
building Ruby objects in Ruby when we

00:09:05,010 --> 00:09:09,390
define a class but we're actually doing

00:09:06,720 --> 00:09:11,220
is instantiating a class object when we

00:09:09,390 --> 00:09:14,010
define instance methods we're adding

00:09:11,220 --> 00:09:18,839
methods objects to the array of instance

00:09:14,010 --> 00:09:20,220
methods that that object tracks now

00:09:18,839 --> 00:09:21,990
let's look at an equally vanilla Ruby

00:09:20,220 --> 00:09:23,850
class but one that uses the adder

00:09:21,990 --> 00:09:26,040
accessor macro to define its getter

00:09:23,850 --> 00:09:28,740
setter pair instead of defining the same

00:09:26,040 --> 00:09:30,149
pair manually class macros are

00:09:28,740 --> 00:09:33,120
definitely something that a lot of

00:09:30,149 --> 00:09:35,820
people think of as meta programming but

00:09:33,120 --> 00:09:38,940
because adder accessor is so common it's

00:09:35,820 --> 00:09:40,860
something we type every day it's easier

00:09:38,940 --> 00:09:44,880
for us to not think oh this is meta

00:09:40,860 --> 00:09:46,620
programming Capital m it's scary

00:09:44,880 --> 00:09:49,829
and so we started getting by defining a

00:09:46,620 --> 00:09:53,040
class whatever but then we hit macro

00:09:49,829 --> 00:09:55,709
call to add or accessor other accessors

00:09:53,040 --> 00:09:57,959
a method we're sending the adder

00:09:55,709 --> 00:10:00,449
accessor message so the yarn class when

00:09:57,959 --> 00:10:04,019
we call it and so now we need to look

00:10:00,449 --> 00:10:07,920
that method up adder accessor isn't

00:10:04,019 --> 00:10:09,420
defined on the yarn class itself and so

00:10:07,920 --> 00:10:12,060
we have to go into its ancestor chain

00:10:09,420 --> 00:10:14,519
now look up the method yarn is an

00:10:12,060 --> 00:10:16,100
instance of class and at our accessor is

00:10:14,519 --> 00:10:18,480
defined as an instance method on class

00:10:16,100 --> 00:10:20,699
so that's the definition of a direct

00:10:18,480 --> 00:10:25,319
sesor we use to define a getter setter

00:10:20,699 --> 00:10:27,360
pair adder accessor then calls define

00:10:25,319 --> 00:10:29,699
method twice to define that getter and

00:10:27,360 --> 00:10:31,440
setter for the attribute name in this

00:10:29,699 --> 00:10:35,790
case length that we passed into adder

00:10:31,440 --> 00:10:37,199
accessor this definitely feels a little

00:10:35,790 --> 00:10:41,670
like metaphor we're calling define

00:10:37,199 --> 00:10:44,279
method we're using Ruby methods like

00:10:41,670 --> 00:10:47,670
define method to define the structure of

00:10:44,279 --> 00:10:50,699
our program and so my question is is

00:10:47,670 --> 00:10:56,339
this happening at run time or at load

00:10:50,699 --> 00:10:58,519
time my answer to this is that that's

00:10:56,339 --> 00:11:02,060
not a meaningful distinction in Ruby

00:10:58,519 --> 00:11:06,230
we're using Ruby to load our classes and

00:11:02,060 --> 00:11:10,589
so it's all a big mismatch

00:11:06,230 --> 00:11:11,880
it's all happening at once the

00:11:10,589 --> 00:11:13,920
definition we're taught to use for

00:11:11,880 --> 00:11:15,949
metaprogramming codes that modifies the

00:11:13,920 --> 00:11:19,800
structure of the program at runtime

00:11:15,949 --> 00:11:21,990
works in other languages it's like a

00:11:19,800 --> 00:11:25,050
really great definition for how Java

00:11:21,990 --> 00:11:27,089
meta programming works but in Java a

00:11:25,050 --> 00:11:29,060
program structure is different than the

00:11:27,089 --> 00:11:32,040
data passing through the program and

00:11:29,060 --> 00:11:33,720
Java also has a defined compilation

00:11:32,040 --> 00:11:37,019
phase that has to complete before you

00:11:33,720 --> 00:11:38,579
can run the program in Ruby neither of

00:11:37,019 --> 00:11:40,470
the assumptions underlying this

00:11:38,579 --> 00:11:41,550
modifying the structure definition is

00:11:40,470 --> 00:11:43,740
actually true

00:11:41,550 --> 00:11:45,180
Ruby uses Ruby to build up the

00:11:43,740 --> 00:11:47,100
underlying structure of classes and

00:11:45,180 --> 00:11:49,199
methods that we invoke and treats

00:11:47,100 --> 00:11:51,600
classes and methods as just other kinds

00:11:49,199 --> 00:11:54,610
of objects

00:11:51,600 --> 00:11:56,199
so in Ruby the best academic sounding

00:11:54,610 --> 00:11:59,410
definition of meta program that I can

00:11:56,199 --> 00:12:00,790
come up with is code that modifies the

00:11:59,410 --> 00:12:02,350
thing that we would call program

00:12:00,790 --> 00:12:05,379
structure if we were using another

00:12:02,350 --> 00:12:08,980
language just like it modifies the data

00:12:05,379 --> 00:12:11,079
passing through the program now this

00:12:08,980 --> 00:12:13,029
definition is a lot more compatible with

00:12:11,079 --> 00:12:15,069
the pragmatics definition that all of us

00:12:13,029 --> 00:12:18,519
actually use when we're thinking oh god

00:12:15,069 --> 00:12:20,740
Ruby magic and that's because at its

00:12:18,519 --> 00:12:24,939
core the pragmatics definition is not

00:12:20,740 --> 00:12:31,869
about full text search instead it is

00:12:24,939 --> 00:12:33,819
about feelings the pragmatics definition

00:12:31,869 --> 00:12:36,459
is about our feelings in the face of

00:12:33,819 --> 00:12:38,829
code that resists analysis via full text

00:12:36,459 --> 00:12:41,559
search and these feelings are at least

00:12:38,829 --> 00:12:43,509
when I have them about approximately oh

00:12:41,559 --> 00:12:45,369
my god I don't know what's going on huh

00:12:43,509 --> 00:12:49,720
why how am I ever going to be bug this

00:12:45,369 --> 00:12:51,129
oh god and these feelings are also why

00:12:49,720 --> 00:12:53,350
people from strongly typed language

00:12:51,129 --> 00:12:56,019
backgrounds often find Ruby a bit tricky

00:12:53,350 --> 00:12:57,759
at first when you're used to having real

00:12:56,019 --> 00:13:00,819
compiler warn you off of certain kinds

00:12:57,759 --> 00:13:02,290
of type bugs it's really intimidating to

00:13:00,819 --> 00:13:06,610
program in a language that doesn't offer

00:13:02,290 --> 00:13:08,319
you the same assistance these feelings

00:13:06,610 --> 00:13:10,350
are ultimately about not having the two

00:13:08,319 --> 00:13:12,970
tools were used to from other languages

00:13:10,350 --> 00:13:14,920
just as we can't rely on the same idea

00:13:12,970 --> 00:13:16,899
of program structure as distinct from

00:13:14,920 --> 00:13:19,749
data that is present in other languages

00:13:16,899 --> 00:13:21,970
and this was even true if ruby was the

00:13:19,749 --> 00:13:23,350
first language you were taught this is

00:13:21,970 --> 00:13:26,050
true even if your B is the only language

00:13:23,350 --> 00:13:27,879
you know and that's because all of us

00:13:26,050 --> 00:13:29,709
were taught really within paradigm that

00:13:27,879 --> 00:13:33,220
believes that program structure and

00:13:29,709 --> 00:13:35,499
program data are different that paradigm

00:13:33,220 --> 00:13:38,230
exists because that was true and that in

00:13:35,499 --> 00:13:41,649
basic that was true in Pascal that was

00:13:38,230 --> 00:13:43,299
true in Java that was true in the

00:13:41,649 --> 00:13:45,550
traditional first languages that most

00:13:43,299 --> 00:13:48,470
people learned

00:13:45,550 --> 00:13:51,410
now there are two cases that we can take

00:13:48,470 --> 00:13:54,110
this reality that we were taught Ruby

00:13:51,410 --> 00:13:57,410
wrong and one of them will be blaming

00:13:54,110 --> 00:13:59,840
the victim one of them would be saying

00:13:57,410 --> 00:14:02,180
that okay real programmers whoever those

00:13:59,840 --> 00:14:03,620
are do not need tooling to help them

00:14:02,180 --> 00:14:06,800
understand what the heck of program is

00:14:03,620 --> 00:14:10,550
doing and I'm not about that

00:14:06,800 --> 00:14:14,150
I do think we still need tools but I

00:14:10,550 --> 00:14:15,380
think we need ruby tools I also think we

00:14:14,150 --> 00:14:19,040
need them to be tools that we can use

00:14:15,380 --> 00:14:20,720
today stripe spent several years trying

00:14:19,040 --> 00:14:22,280
to develop a gradual type system for

00:14:20,720 --> 00:14:24,140
Ruby and don't get me wrong I think

00:14:22,280 --> 00:14:26,140
sorbet is an amazing piece of

00:14:24,140 --> 00:14:29,150
engineering that is pushing Ruby forward

00:14:26,140 --> 00:14:31,940
but the average organization does not

00:14:29,150 --> 00:14:34,310
have the time or developers to like

00:14:31,940 --> 00:14:38,210
assign three people to make a type

00:14:34,310 --> 00:14:40,910
system for four years the average

00:14:38,210 --> 00:14:44,570
organization just can't engage in while

00:14:40,910 --> 00:14:48,110
making efforts that's that extensive we

00:14:44,570 --> 00:14:49,790
also needed these Ruby tools to be tools

00:14:48,110 --> 00:14:54,170
that can deal with Ruby code bases as

00:14:49,790 --> 00:14:57,560
they are I have worked in a lot of

00:14:54,170 --> 00:14:59,930
decade old code bases where you can date

00:14:57,560 --> 00:15:02,570
any given piece of code by the style it

00:14:59,930 --> 00:15:05,290
was written in our community's opinions

00:15:02,570 --> 00:15:08,120
on how to write Ruby well keep changing

00:15:05,290 --> 00:15:10,430
if my toolset only works with a specific

00:15:08,120 --> 00:15:12,680
dialect of Ruby that I have defined as

00:15:10,430 --> 00:15:15,440
good Ruby and that limits me as

00:15:12,680 --> 00:15:17,930
developer it means that I can only work

00:15:15,440 --> 00:15:22,310
with in some arbitrary personal and a

00:15:17,930 --> 00:15:25,960
fashion dependent notion of good code it

00:15:22,310 --> 00:15:25,960
locks me to a particular point in time

00:15:26,410 --> 00:15:31,850
so the correct tool I think is applying

00:15:29,030 --> 00:15:33,500
more Ruby to the problem it's to fight

00:15:31,850 --> 00:15:37,490
other people's probe meta programming

00:15:33,500 --> 00:15:39,560
with meta programming of our own and I

00:15:37,490 --> 00:15:42,620
mean that both in the hand-wavy Ruby

00:15:39,560 --> 00:15:44,420
magic sense of code that violates our

00:15:42,620 --> 00:15:47,240
expectations about static program

00:15:44,420 --> 00:15:48,350
structure like using prepend to override

00:15:47,240 --> 00:15:51,110
a definition

00:15:48,350 --> 00:15:53,060
and in the stricter sense of code that

00:15:51,110 --> 00:15:54,890
streets structural elements like the

00:15:53,060 --> 00:15:57,710
current stack trace the same way it

00:15:54,890 --> 00:15:59,330
treats data and functions if we can

00:15:57,710 --> 00:16:01,100
manipulate structure like we can data

00:15:59,330 --> 00:16:03,590
then that means that we can assign

00:16:01,100 --> 00:16:05,300
structure to a variable that means that

00:16:03,590 --> 00:16:09,320
we can print that variable out when

00:16:05,300 --> 00:16:11,330
we're debugging and that's cool one of

00:16:09,320 --> 00:16:13,880
the most powerful things in computing is

00:16:11,330 --> 00:16:16,490
giving up on trying to be smart is

00:16:13,880 --> 00:16:19,580
giving up on trying to predict what the

00:16:16,490 --> 00:16:21,650
computer will do and instead just asking

00:16:19,580 --> 00:16:26,390
the computer what's going on and

00:16:21,650 --> 00:16:27,710
observing the results and so now we're

00:16:26,390 --> 00:16:29,990
going to look at three basic ways that

00:16:27,710 --> 00:16:31,340
we can leverage Ruby's dynamism to help

00:16:29,990 --> 00:16:34,220
us understand what's going on in our

00:16:31,340 --> 00:16:35,930
programs at run time the first of these

00:16:34,220 --> 00:16:38,860
is reflection which is computer science

00:16:35,930 --> 00:16:41,420
for asking a program about its structure

00:16:38,860 --> 00:16:43,520
the second is using dynamic language

00:16:41,420 --> 00:16:46,730
features to record what our programs do

00:16:43,520 --> 00:16:48,380
when and the third is using those same

00:16:46,730 --> 00:16:57,320
features to help us more efficiently

00:16:48,380 --> 00:16:59,990
review what has happened the most basic

00:16:57,320 --> 00:17:01,820
way we can use reflection and Ruby is

00:16:59,990 --> 00:17:04,550
calling itself to understand what the

00:17:01,820 --> 00:17:07,209
current object is and then we can kind

00:17:04,550 --> 00:17:07,209
of proceed from there

00:17:07,240 --> 00:17:13,010
we can ask yourself what's classics an

00:17:09,920 --> 00:17:15,050
instance of in this case a wool yarn

00:17:13,010 --> 00:17:17,680
instance turns out to have a class of

00:17:15,050 --> 00:17:20,810
wool yarn this isn't necessarily very

00:17:17,680 --> 00:17:22,189
interesting information itself but we

00:17:20,810 --> 00:17:28,010
can move on from here to some really

00:17:22,189 --> 00:17:30,290
cool places for example once we have a

00:17:28,010 --> 00:17:36,080
class we can look up that class's

00:17:30,290 --> 00:17:38,390
ancestor tree once you have an ancestor

00:17:36,080 --> 00:17:41,890
tree we can see which of the class's

00:17:38,390 --> 00:17:41,890
ancestors define a given method

00:17:44,240 --> 00:17:50,570
and then once we have that we can even

00:17:48,500 --> 00:17:53,360
look up all the places within our code

00:17:50,570 --> 00:17:55,039
base that method is defined it's kind of

00:17:53,360 --> 00:18:01,450
like feel Flex search but it's a lot

00:17:55,039 --> 00:18:04,820
more Rubeus and then from there just

00:18:01,450 --> 00:18:07,580
within ruby we can even print out all of

00:18:04,820 --> 00:18:09,559
the possible method definitions so here

00:18:07,580 --> 00:18:11,179
we can learn that the subclass will yar

00:18:09,559 --> 00:18:13,220
and completely overrides the definition

00:18:11,179 --> 00:18:14,750
from the fiber class which is good

00:18:13,220 --> 00:18:19,880
because that definition would have just

00:18:14,750 --> 00:18:21,549
raised an error like I said some bugs in

00:18:19,880 --> 00:18:24,309
my animations it's fine

00:18:21,549 --> 00:18:26,419
now I'm just scratching the surface here

00:18:24,309 --> 00:18:28,190
there are a million things that you can

00:18:26,419 --> 00:18:30,440
look at about any given object or

00:18:28,190 --> 00:18:32,480
binding in Ruby I encourage you to open

00:18:30,440 --> 00:18:35,360
up IRB or a debugger and just kind of

00:18:32,480 --> 00:18:37,190
play around call dot methods on things

00:18:35,360 --> 00:18:39,049
which tells you what the methods on that

00:18:37,190 --> 00:18:40,010
object are and then call us up call some

00:18:39,049 --> 00:18:43,960
of those methods that look

00:18:40,010 --> 00:18:46,340
metaprogramming e and see what happens

00:18:43,960 --> 00:18:49,130
however after a while you are going to

00:18:46,340 --> 00:18:51,320
get sick of typing yarn methods - object

00:18:49,130 --> 00:18:53,120
new methods to see what methods that are

00:18:51,320 --> 00:18:56,090
like normal looking are available for an

00:18:53,120 --> 00:18:58,549
object in these moments you are either

00:18:56,090 --> 00:19:02,990
going to be tempted to find a gem or

00:18:58,549 --> 00:19:05,450
attempted to build a gem pry exists

00:19:02,990 --> 00:19:07,820
frags does a lot of work for you pry is

00:19:05,450 --> 00:19:10,820
great past using Frye

00:19:07,820 --> 00:19:13,310
I would actually kind of suppress the

00:19:10,820 --> 00:19:15,800
instinct to Gemma fie things

00:19:13,310 --> 00:19:17,420
what I instead suggest is storing some

00:19:15,800 --> 00:19:19,370
of the one-off methods that you use for

00:19:17,420 --> 00:19:24,350
analysis in an IRB cyle

00:19:19,370 --> 00:19:26,030
an IRB RC file or a prior C file this

00:19:24,350 --> 00:19:29,330
way they'll be loaded whenever you're at

00:19:26,030 --> 00:19:31,430
a rebel ground and the reason I'd

00:19:29,330 --> 00:19:33,260
suggest this is that ultimately using

00:19:31,430 --> 00:19:35,060
meta programming techniques to explore

00:19:33,260 --> 00:19:37,190
what your code is doing is about

00:19:35,060 --> 00:19:40,190
expanding your understanding both in the

00:19:37,190 --> 00:19:44,060
moment and by training your gut of what

00:19:40,190 --> 00:19:45,710
Ruby is doing you can import a library

00:19:44,060 --> 00:19:47,660
for making HTTP connections more

00:19:45,710 --> 00:19:48,140
conveniently and have that work out

00:19:47,660 --> 00:19:50,030
great

00:19:48,140 --> 00:19:52,100
because you can make 99% of API calls

00:19:50,030 --> 00:19:55,430
just fine without understanding the

00:19:52,100 --> 00:19:57,170
intricacies of HTTP as a protocol the

00:19:55,430 --> 00:19:58,610
goal with using most gems is to shield

00:19:57,170 --> 00:20:03,380
you from meeting to know stuff and

00:19:58,610 --> 00:20:04,790
honestly I kind of love that but if

00:20:03,380 --> 00:20:07,280
you're shielding yourself from meetings

00:20:04,790 --> 00:20:10,280
know stuff it's pretty hard to learn

00:20:07,280 --> 00:20:12,020
that stuff at the same time you can't

00:20:10,280 --> 00:20:15,410
just type require and suddenly

00:20:12,020 --> 00:20:17,000
understand Ruby's object model better so

00:20:15,410 --> 00:20:21,170
anyway moment of philosophy over let's

00:20:17,000 --> 00:20:23,240
talk about recording recording is about

00:20:21,170 --> 00:20:25,370
understanding your code over time it's

00:20:23,240 --> 00:20:28,430
about taking snapshots of what has gone

00:20:25,370 --> 00:20:34,100
on so you can understand later behavior

00:20:28,430 --> 00:20:36,650
better there are two big ways that I

00:20:34,100 --> 00:20:38,690
like to insert recording logic we can

00:20:36,650 --> 00:20:41,180
use prepend to tack additional logic

00:20:38,690 --> 00:20:44,240
into a class or we can use the trace

00:20:41,180 --> 00:20:46,130
point API now trace point is an enormous

00:20:44,240 --> 00:20:48,440
topic and it could consume an entire

00:20:46,130 --> 00:20:51,220
talk in itself very easily so I'm just

00:20:48,440 --> 00:20:53,840
going to go over a basic example now

00:20:51,220 --> 00:20:56,720
trace point organizes itself around

00:20:53,840 --> 00:20:58,640
events and one of those the most useful

00:20:56,720 --> 00:21:02,060
one in my opinion is another line of

00:20:58,640 --> 00:21:04,700
code just got executed being able to

00:21:02,060 --> 00:21:06,320
trace this is super powerful for example

00:21:04,700 --> 00:21:07,400
in this code we insert like a very

00:21:06,320 --> 00:21:10,760
simple if statement

00:21:07,400 --> 00:21:12,290
very gently that compares a value to a

00:21:10,760 --> 00:21:15,230
tracking variable that matches its

00:21:12,290 --> 00:21:17,210
previous value if that value of that

00:21:15,230 --> 00:21:19,780
variable changes then we print out where

00:21:17,210 --> 00:21:19,780
it changed

00:21:21,820 --> 00:21:26,120
now as important as how we insert Kalama

00:21:24,559 --> 00:21:28,550
tree is where we store the results of

00:21:26,120 --> 00:21:30,170
that telemetry the simplest form of this

00:21:28,550 --> 00:21:33,050
is just putting it in variable whether

00:21:30,170 --> 00:21:34,730
this is an IVA or a global variable yes

00:21:33,050 --> 00:21:36,260
by the way ruby has Global's we don't

00:21:34,730 --> 00:21:37,580
see them very often in production code

00:21:36,260 --> 00:21:39,680
because in production code they're a

00:21:37,580 --> 00:21:43,040
horrible idea but this is debugging code

00:21:39,680 --> 00:21:44,720
so who cares you can also put

00:21:43,040 --> 00:21:46,250
information into a logger and this gets

00:21:44,720 --> 00:21:48,140
really powerful when it's a relatively

00:21:46,250 --> 00:21:52,640
smart logger that puts information into

00:21:48,140 --> 00:21:53,990
a searchable or filterable format one

00:21:52,640 --> 00:21:55,700
question I've been asked is where you

00:21:53,990 --> 00:21:57,020
should even put code like this because

00:21:55,700 --> 00:21:59,690
it doesn't fit nicely within your

00:21:57,020 --> 00:22:01,250
existing project structure and my most

00:21:59,690 --> 00:22:04,190
honest answer is whatever works for you

00:22:01,250 --> 00:22:06,559
what I personally do is I'll either make

00:22:04,190 --> 00:22:09,590
a file in the initializer directory or a

00:22:06,559 --> 00:22:11,120
rails project called debugging dot RB or

00:22:09,590 --> 00:22:14,540
I'll make something similar in a test

00:22:11,120 --> 00:22:16,429
support director directory I never check

00:22:14,540 --> 00:22:18,950
this file and to get and half the time I

00:22:16,429 --> 00:22:20,270
delete it after I found the problem if a

00:22:18,950 --> 00:22:22,760
similar technique works well for you

00:22:20,270 --> 00:22:24,679
great if something else works better for

00:22:22,760 --> 00:22:25,850
you then run with that I don't really

00:22:24,679 --> 00:22:30,410
think there's a right or a wrong way to

00:22:25,850 --> 00:22:32,960
do this now finally let's talk about

00:22:30,410 --> 00:22:35,510
reviewing the things we record there are

00:22:32,960 --> 00:22:37,220
two basic ways to do this one is

00:22:35,510 --> 00:22:39,260
inserting a debugger breakpoint and the

00:22:37,220 --> 00:22:40,820
other is adding a put statement and some

00:22:39,260 --> 00:22:41,960
of you are probably groaning internally

00:22:40,820 --> 00:22:46,040
right now because you are probably

00:22:41,960 --> 00:22:47,450
already doing these things but the

00:22:46,040 --> 00:22:49,490
magnetic nature of Ruby means that you

00:22:47,450 --> 00:22:52,670
can do them conditionally and that's

00:22:49,490 --> 00:22:54,260
really cool and really efficient how

00:22:52,670 --> 00:22:56,360
many people here have inserted a by bug

00:22:54,260 --> 00:22:58,400
in their code and then doped write that

00:22:56,360 --> 00:23:00,080
right back out when it turned out that

00:22:58,400 --> 00:23:03,020
that code was called a lot more often

00:23:00,080 --> 00:23:05,540
than they thought I'm seeing a lot of

00:23:03,020 --> 00:23:07,400
hands a lot of laughter yeah in other

00:23:05,540 --> 00:23:09,679
languages you insert debugger

00:23:07,400 --> 00:23:12,620
breakpoints in your IDE and they always

00:23:09,679 --> 00:23:14,600
trigger no matter what but in Ruby

00:23:12,620 --> 00:23:17,280
calling binding dot pry or calling by

00:23:14,600 --> 00:23:19,800
bug is just calling our method

00:23:17,280 --> 00:23:23,010
so we can trigger debug breakpoints if

00:23:19,800 --> 00:23:25,200
and only if a given flag is true we can

00:23:23,010 --> 00:23:30,120
add breakpoints or add put statements at

00:23:25,200 --> 00:23:31,620
the site of errors so now let's look at

00:23:30,120 --> 00:23:33,420
these things in the context of solving

00:23:31,620 --> 00:23:37,260
real problems like the bug I mentioned

00:23:33,420 --> 00:23:39,660
at the start of this talk what's

00:23:37,260 --> 00:23:41,550
important to remember here is that our

00:23:39,660 --> 00:23:42,960
goal is not to understand everything

00:23:41,550 --> 00:23:47,060
that our programming is doing our

00:23:42,960 --> 00:23:49,200
program is doing our goal is to fix bugs

00:23:47,060 --> 00:23:52,440
that means our goal is to figure out the

00:23:49,200 --> 00:23:54,480
cause of the bug bugs are caused by what

00:23:52,440 --> 00:23:55,980
we thought would be true crashing into

00:23:54,480 --> 00:23:59,010
what is actually true in the real world

00:23:55,980 --> 00:24:00,510
and so to isolate the cause of a bug we

00:23:59,010 --> 00:24:02,910
need to systematically identify things

00:24:00,510 --> 00:24:05,100
we think are true or that might be true

00:24:02,910 --> 00:24:08,100
and then figure out a way to prove

00:24:05,100 --> 00:24:10,230
whether they're true or not in this

00:24:08,100 --> 00:24:12,180
context investigative meta programming

00:24:10,230 --> 00:24:13,680
is technique for expanding the number of

00:24:12,180 --> 00:24:17,130
questions that we can answer in a

00:24:13,680 --> 00:24:19,680
reasonable amount of time here the

00:24:17,130 --> 00:24:21,600
question we're trying to answer is did

00:24:19,680 --> 00:24:25,770
the hash freeze correctly or did it

00:24:21,600 --> 00:24:27,990
freeze and appropriately in order that

00:24:25,770 --> 00:24:30,420
to answer that question first we need to

00:24:27,990 --> 00:24:34,770
answer the smaller question of when did

00:24:30,420 --> 00:24:36,060
the hash freeze there's a naive way of

00:24:34,770 --> 00:24:37,710
doing this which is just just print out

00:24:36,060 --> 00:24:41,490
a message whenever the hash freezes and

00:24:37,710 --> 00:24:45,810
we totally tried that first ríos traces

00:24:41,490 --> 00:24:47,940
hashes a lot turns out we had assembled

00:24:45,810 --> 00:24:50,550
ourselves a whole haystack of print

00:24:47,940 --> 00:24:52,080
statements sorting through that haystack

00:24:50,550 --> 00:24:55,860
to find a single needle was going to be

00:24:52,080 --> 00:24:58,800
way more time than it was worth we had a

00:24:55,860 --> 00:25:00,180
reviewing problem in other words we're

00:24:58,800 --> 00:25:03,180
not filtering enough when we're

00:25:00,180 --> 00:25:05,100
reviewing the data in order to solve

00:25:03,180 --> 00:25:07,020
reviewing problems it can help for look

00:25:05,100 --> 00:25:08,170
for vague places in the question we're

00:25:07,020 --> 00:25:11,440
asking

00:25:08,170 --> 00:25:15,610
we're not asking when is a hash freezing

00:25:11,440 --> 00:25:20,470
we're asking when the specific hash that

00:25:15,610 --> 00:25:21,550
is throwing the error is freezing and so

00:25:20,470 --> 00:25:23,590
the appropriate way to review this

00:25:21,550 --> 00:25:26,980
information is to do something at the

00:25:23,590 --> 00:25:31,350
error site what that is you might not be

00:25:26,980 --> 00:25:35,560
sure yet but that's fine

00:25:31,350 --> 00:25:37,330
because that is a recording problem we

00:25:35,560 --> 00:25:38,800
can think about recording problems by

00:25:37,330 --> 00:25:41,410
thinking about the actions we want to

00:25:38,800 --> 00:25:44,110
record in this case we're interested in

00:25:41,410 --> 00:25:47,560
when the hash is freezing and so we

00:25:44,110 --> 00:25:48,880
instrument the freeze method and so now

00:25:47,560 --> 00:25:52,120
the question is what do we instrument

00:25:48,880 --> 00:25:54,670
that with you're guessing right that's a

00:25:52,120 --> 00:25:56,710
reflection problem we solve reflection

00:25:54,670 --> 00:25:59,560
problems by thinking out what about what

00:25:56,710 --> 00:26:02,470
data were trying to collect in this case

00:25:59,560 --> 00:26:03,970
it's when the hash is freezing and so

00:26:02,470 --> 00:26:07,570
the stack trace is the most useful piece

00:26:03,970 --> 00:26:09,340
of information by using this technique

00:26:07,570 --> 00:26:10,870
we are able to pinpoint the exact place

00:26:09,340 --> 00:26:13,060
where an association was being deleted

00:26:10,870 --> 00:26:14,500
when it shouldn't have been we didn't

00:26:13,060 --> 00:26:17,410
like solve the root cause or anything

00:26:14,500 --> 00:26:19,450
but we were able to gently detach one

00:26:17,410 --> 00:26:23,050
bit of code from a crafty old subsystem

00:26:19,450 --> 00:26:24,520
and unblockable Grails upgrade and I

00:26:23,050 --> 00:26:29,040
think that that was plenty of

00:26:24,520 --> 00:26:29,040
accomplishment for two hours of work I

00:26:29,400 --> 00:26:33,730
keep on stressing the time thing

00:26:31,810 --> 00:26:36,730
because time is a proxy for our feelings

00:26:33,730 --> 00:26:39,100
too when programming tasks take more

00:26:36,730 --> 00:26:41,050
time than we think they ought to we feel

00:26:39,100 --> 00:26:43,840
frustrated and defeated and anxious and

00:26:41,050 --> 00:26:46,000
we have to live with those feelings for

00:26:43,840 --> 00:26:50,290
the duration of the terrible programming

00:26:46,000 --> 00:26:52,150
tasks and so there's been a backlash

00:26:50,290 --> 00:26:52,870
against free meta programming and

00:26:52,150 --> 00:26:55,470
monkey-patching

00:26:52,870 --> 00:26:57,550
and all the things that make Ruby Ruby

00:26:55,470 --> 00:26:59,110
rather than just interpreter Java

00:26:57,550 --> 00:27:00,880
because we don't want to have these

00:26:59,110 --> 00:27:02,680
feelings ever these feelings are

00:27:00,880 --> 00:27:05,060
terrible

00:27:02,680 --> 00:27:07,580
but when I gave an early draft of this

00:27:05,060 --> 00:27:10,700
talk at work my boss pointed out to me

00:27:07,580 --> 00:27:12,740
later that my secret thesis was in other

00:27:10,700 --> 00:27:15,230
languages you solve things by building

00:27:12,740 --> 00:27:19,790
libraries and in Ruby you solve things

00:27:15,230 --> 00:27:21,590
by building programmers in a lot of

00:27:19,790 --> 00:27:23,900
modern developer discourse we talk about

00:27:21,590 --> 00:27:24,880
prevention and about saving us from

00:27:23,900 --> 00:27:28,760
ourselves

00:27:24,880 --> 00:27:30,440
but there are two ways of doing that we

00:27:28,760 --> 00:27:32,570
can do that by making our frameworks so

00:27:30,440 --> 00:27:34,940
restrictive that we can't possibly shoot

00:27:32,570 --> 00:27:37,790
ourselves in the foot and spend our day

00:27:34,940 --> 00:27:39,860
is writing boilerplate this is

00:27:37,790 --> 00:27:41,870
ultimately an impulse toward controlling

00:27:39,860 --> 00:27:44,210
not only ourselves but over people

00:27:41,870 --> 00:27:46,190
it's that reducing ourselves and our

00:27:44,210 --> 00:27:49,820
teammates about - nothing but cogs a

00:27:46,190 --> 00:27:51,580
machine Ruby's big secret is that it

00:27:49,820 --> 00:27:55,280
lets us save ourselves a different way

00:27:51,580 --> 00:27:57,140
it lets us save ourselves from anxiety

00:27:55,280 --> 00:27:59,960
and feelings and other people's meta

00:27:57,140 --> 00:28:03,640
programming by empowering ourselves and

00:27:59,960 --> 00:28:03,640
I like that story better

00:28:06,610 --> 00:28:14,870
so I'm Betsy I am currently an advisor I

00:28:12,920 --> 00:28:16,760
used to be there full time but recently

00:28:14,870 --> 00:28:19,010
took a full-time position at long-term

00:28:16,760 --> 00:28:20,960
stock exchange I'm an advisor at cohere

00:28:19,010 --> 00:28:23,120
which is a consulting company that wants

00:28:20,960 --> 00:28:24,950
to make you a better programmer if you

00:28:23,120 --> 00:28:27,170
want a two hour staring session with one

00:28:24,950 --> 00:28:28,880
of my co-founders like the one which I

00:28:27,170 --> 00:28:31,010
solved the bug I talked about in this

00:28:28,880 --> 00:28:33,230
story then you should go to week oh here

00:28:31,010 --> 00:28:36,110
calm and email them and I'm sure they'd

00:28:33,230 --> 00:28:39,770
be delighted to let you exchange some of

00:28:36,110 --> 00:28:41,570
your money for their time we also if

00:28:39,770 --> 00:28:45,020
you're less commercially have a

00:28:41,570 --> 00:28:47,300
newsletter that contains my co-founder

00:28:45,020 --> 00:28:48,920
Jennifer's thoughts on engineering and

00:28:47,300 --> 00:28:51,770
engineering management and how to be a

00:28:48,920 --> 00:28:53,420
better person in teammate and this is

00:28:51,770 --> 00:28:54,080
not shameless self-promotion Jennifer is

00:28:53,420 --> 00:28:57,200
amazing

00:28:54,080 --> 00:29:01,580
you should read what she writes recently

00:28:57,200 --> 00:29:03,530
Jennifer Marlena Compton and I also

00:29:01,580 --> 00:29:05,510
co-wrote is the in series called les

00:29:03,530 --> 00:29:09,050
pair which you can purchase at let's

00:29:05,510 --> 00:29:11,120
pair guy and it's about being a pair

00:29:09,050 --> 00:29:14,539
programmer

00:29:11,120 --> 00:29:17,929
more in a more friendly way even if

00:29:14,539 --> 00:29:22,580
you're trying to pare across a skills

00:29:17,929 --> 00:29:23,779
gap an experience gap being career woman

00:29:22,580 --> 00:29:32,360
who's trying to pair with the straight

00:29:23,779 --> 00:29:38,090
man things like that thank you

00:29:32,360 --> 00:29:51,390
[Applause]

00:29:38,090 --> 00:29:51,390

YouTube URL: https://www.youtube.com/watch?v=bJMzWumXPmo


