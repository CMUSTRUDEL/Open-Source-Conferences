Title: RubyConf2019 - Digging Up Code Graves in Ruby by Noah Matisoff
Publication date: 2019-12-04
Playlist: RubyConf 2019
Description: 
	RubyConf2019 - Digging Up Code Graves in Ruby by Noah Matisoff

As codebases grow, having dead code is a common issue that teams need to tackle. Especially for consumer-facing products that frequently run A/B tests using feature flags, dead code paths can be a significant source of technical debt sneakily piling up. Luckily, the Ruby standard library exposes Coverage -- which is a simple, experimental code coverage measurement tool.


Let's dive into how Coverage and other tools can be used and expanded to track down dead code paths in Ruby.

#rubyconf2019 #confreaks
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,150 --> 00:00:17,050
thanks everyone for coming

00:00:15,000 --> 00:00:20,050
cool so I'm gonna go ahead and get

00:00:17,050 --> 00:00:23,440
started this talk is called digging up

00:00:20,050 --> 00:00:26,980
code graves in Ruby so I'm going to talk

00:00:23,440 --> 00:00:29,980
a bit about managing dead code and the

00:00:26,980 --> 00:00:32,349
complexity of it I'll dive into some

00:00:29,980 --> 00:00:35,710
examples and talk about some tools for

00:00:32,349 --> 00:00:38,590
managing dead code and tracking dead

00:00:35,710 --> 00:00:41,079
code down in different ruby projects and

00:00:38,590 --> 00:00:46,480
and rails code bases so before I get

00:00:41,079 --> 00:00:48,610
into it quick introduction so I'm Noah I

00:00:46,480 --> 00:00:49,809
work on the engineering team at Credit

00:00:48,610 --> 00:00:53,350
Karma

00:00:49,809 --> 00:00:56,020
I love Ruby I've been doing doing Ruby

00:00:53,350 --> 00:00:58,809
for a really long time most recently

00:00:56,020 --> 00:01:00,850
I've been doing Scala so happy to talk

00:00:58,809 --> 00:01:04,659
about the differences between the two

00:01:00,850 --> 00:01:08,259
after after the talk as well cool

00:01:04,659 --> 00:01:10,060
so technical debt this is a term that

00:01:08,259 --> 00:01:13,569
probably most of you are pretty familiar

00:01:10,060 --> 00:01:15,369
with and have some experience with and

00:01:13,569 --> 00:01:20,259
probably discussed with your teams on a

00:01:15,369 --> 00:01:23,469
regular basis so there's also something

00:01:20,259 --> 00:01:25,090
called code hygiene which is probably a

00:01:23,469 --> 00:01:28,899
term that some of you have have heard as

00:01:25,090 --> 00:01:32,200
well code hygiene is kind of an umbrella

00:01:28,899 --> 00:01:36,009
term for anything to do with the health

00:01:32,200 --> 00:01:39,310
and longevity of a code base so this

00:01:36,009 --> 00:01:42,429
could be a variety of things so this is

00:01:39,310 --> 00:01:44,560
kind of a visualization for technical

00:01:42,429 --> 00:01:46,450
debt and code hygiene technical debt can

00:01:44,560 --> 00:01:48,249
be many things that don't include code

00:01:46,450 --> 00:01:50,619
hygiene as well but I'll mostly be

00:01:48,249 --> 00:01:52,630
talking about code hygiene today so a

00:01:50,619 --> 00:01:55,359
few examples of code hygiene

00:01:52,630 --> 00:01:58,719
so keeping dependencies up-to-date in

00:01:55,359 --> 00:02:01,299
your project so for example this could

00:01:58,719 --> 00:02:02,679
be the Ruby version of the project that

00:02:01,299 --> 00:02:05,259
you're that you're working on or running

00:02:02,679 --> 00:02:07,179
as well as the version of Postgres that

00:02:05,259 --> 00:02:08,770
you might be running or any sort of

00:02:07,179 --> 00:02:12,400
dependencies or gems in your code base

00:02:08,770 --> 00:02:13,610
as well so refactoring code is another

00:02:12,400 --> 00:02:16,960
common

00:02:13,610 --> 00:02:18,950
aspect of coat hygiene and it's

00:02:16,960 --> 00:02:22,480
something that's also frequently

00:02:18,950 --> 00:02:24,950
considered you know technical debt so

00:02:22,480 --> 00:02:27,080
many of us are writing Ruby in a

00:02:24,950 --> 00:02:29,420
fast-paced environment working on Rails

00:02:27,080 --> 00:02:33,110
app so refactoring code is something

00:02:29,420 --> 00:02:35,510
that is important for good code code

00:02:33,110 --> 00:02:38,750
hygiene and you know tackling techno for

00:02:35,510 --> 00:02:41,870
that documentation being accurate and

00:02:38,750 --> 00:02:44,209
complete this is something that also you

00:02:41,870 --> 00:02:47,540
know is probably is usually considered

00:02:44,209 --> 00:02:49,730
code hygiene even though it's not actual

00:02:47,540 --> 00:02:51,680
code keeping documentation up to date

00:02:49,730 --> 00:02:54,920
for your REST API s or internal

00:02:51,680 --> 00:02:58,550
documentation for any sort of projects

00:02:54,920 --> 00:03:00,890
inside your codebase and managing dead

00:02:58,550 --> 00:03:03,650
code is also considered code hygiene

00:03:00,890 --> 00:03:05,840
what this talk is about and many many

00:03:03,650 --> 00:03:07,940
more so there's probably many more

00:03:05,840 --> 00:03:12,170
examples that could be talked about that

00:03:07,940 --> 00:03:14,630
fit under code hygiene cool so what

00:03:12,170 --> 00:03:16,070
about dead code so dead code is is

00:03:14,630 --> 00:03:19,340
another term that we may hear from time

00:03:16,070 --> 00:03:23,330
to time we probably have a general idea

00:03:19,340 --> 00:03:24,980
of what this means there are two

00:03:23,330 --> 00:03:26,320
distinct differences that I'm going to

00:03:24,980 --> 00:03:30,140
talk about today

00:03:26,320 --> 00:03:31,790
so this is the Wikipedia definition in

00:03:30,140 --> 00:03:34,610
computer programming unreachable code is

00:03:31,790 --> 00:03:36,590
part of the source code that our source

00:03:34,610 --> 00:03:38,390
code of which a program can never be

00:03:36,590 --> 00:03:40,610
executed because there exists no control

00:03:38,390 --> 00:03:42,799
flow path to the code from the rest of

00:03:40,610 --> 00:03:44,360
the program unreachable code is

00:03:42,799 --> 00:03:45,830
sometimes also called dead code even

00:03:44,360 --> 00:03:48,380
though dead code may also refer to code

00:03:45,830 --> 00:03:51,709
that is executed but has no effect on

00:03:48,380 --> 00:03:53,959
the output of a program so this is also

00:03:51,709 --> 00:03:56,930
kind of another visualization so dead

00:03:53,959 --> 00:04:01,970
code is part of code hygiene but also is

00:03:56,930 --> 00:04:04,670
a form of technical debt so dead code so

00:04:01,970 --> 00:04:08,090
the kind of for a latter aspect of that

00:04:04,670 --> 00:04:10,670
previous definition executed code that

00:04:08,090 --> 00:04:14,870
is never used in a program or code base

00:04:10,670 --> 00:04:16,280
so this is kind of a simple example so

00:04:14,870 --> 00:04:18,019
if you have an add function that takes

00:04:16,280 --> 00:04:21,470
two arguments to add two numbers

00:04:18,019 --> 00:04:24,740
together clearly that second line there

00:04:21,470 --> 00:04:27,170
is is considered dead code not

00:04:24,740 --> 00:04:28,880
unreachable since it is run so

00:04:27,170 --> 00:04:30,560
that's the distinction there between bed

00:04:28,880 --> 00:04:33,740
code and and what's also called

00:04:30,560 --> 00:04:36,380
unreachable code while this this is a

00:04:33,740 --> 00:04:39,650
pretty harmless example consider you

00:04:36,380 --> 00:04:44,090
know in a larger application instead of

00:04:39,650 --> 00:04:46,610
this z equals x we might be making some

00:04:44,090 --> 00:04:48,950
Network call or doing some expensive

00:04:46,610 --> 00:04:52,910
operation that could cause the user to

00:04:48,950 --> 00:04:55,460
wait unnecessarily so the second aspect

00:04:52,910 --> 00:04:57,190
of of dead code is unreachable code so

00:04:55,460 --> 00:05:01,330
code that's referenced but will never

00:04:57,190 --> 00:05:04,190
deterministically never be wrong so

00:05:01,330 --> 00:05:08,300
there's kind of a variety of unreachable

00:05:04,190 --> 00:05:09,770
cases or code that's unreachable so if

00:05:08,300 --> 00:05:13,280
you have logical errors and conditional

00:05:09,770 --> 00:05:16,160
statements so also a simple example this

00:05:13,280 --> 00:05:19,240
is probably considered a bug to most

00:05:16,160 --> 00:05:22,010
people but consider a case maybe where

00:05:19,240 --> 00:05:24,200
my number is not a hard-coded value and

00:05:22,010 --> 00:05:27,710
we're getting some data from a remote

00:05:24,200 --> 00:05:31,400
source and we never execute call my

00:05:27,710 --> 00:05:35,680
method because we simply or the if the

00:05:31,400 --> 00:05:37,760
if condition is simply never true so

00:05:35,680 --> 00:05:39,550
another case is code that was left

00:05:37,760 --> 00:05:41,210
intact for the purpose of preservation

00:05:39,550 --> 00:05:44,110
so if you have some code that's

00:05:41,210 --> 00:05:46,900
unreachable but has been left around

00:05:44,110 --> 00:05:50,960
just for kind of documentation purposes

00:05:46,900 --> 00:05:53,150
this is probably not very useful

00:05:50,960 --> 00:05:55,580
git is an awesome tool that that works

00:05:53,150 --> 00:05:57,680
pretty well for that data used in a

00:05:55,580 --> 00:06:00,920
conditional statement that never causes

00:05:57,680 --> 00:06:03,890
a truth of your false evaluation so

00:06:00,920 --> 00:06:05,240
here's an example of that so if we have

00:06:03,890 --> 00:06:08,270
a method that calls some external

00:06:05,240 --> 00:06:11,050
service could be a database could be an

00:06:08,270 --> 00:06:15,200
external API could be an internal API

00:06:11,050 --> 00:06:18,320
and we get back results and we check

00:06:15,200 --> 00:06:20,210
that result and we call a method but if

00:06:18,320 --> 00:06:22,490
that result isn't truthy then we call my

00:06:20,210 --> 00:06:26,420
other method also a contrived example

00:06:22,490 --> 00:06:29,420
but in this case you know this could be

00:06:26,420 --> 00:06:32,510
an example where there may see there may

00:06:29,420 --> 00:06:35,570
be some dead code if results is always

00:06:32,510 --> 00:06:37,910
true the-- or always false ii and maybe

00:06:35,570 --> 00:06:40,690
at some point that wasn't the case but

00:06:37,910 --> 00:06:44,960
it's not obvious to the reader

00:06:40,690 --> 00:06:48,050
so feature toggles are also another

00:06:44,960 --> 00:06:50,410
common case of dead code that they can

00:06:48,050 --> 00:06:53,240
be introduced into your codebase so

00:06:50,410 --> 00:06:55,130
they've become kind of a common practice

00:06:53,240 --> 00:06:57,440
for canary testing a/b testing dart

00:06:55,130 --> 00:06:59,720
deploying operational testing and

00:06:57,440 --> 00:07:02,690
they're great for being able to iterate

00:06:59,720 --> 00:07:06,140
quickly on a product for quantitative or

00:07:02,690 --> 00:07:09,530
qualitative measurement however the

00:07:06,140 --> 00:07:12,140
downside of adopting them pushes cost on

00:07:09,530 --> 00:07:13,640
to development so there are many ways of

00:07:12,140 --> 00:07:16,400
implementing them some as simple as a

00:07:13,640 --> 00:07:17,930
table in your relational database and a

00:07:16,400 --> 00:07:20,990
simple clasp or wrapper around querying

00:07:17,930 --> 00:07:23,060
for the state of various toggles there

00:07:20,990 --> 00:07:25,370
are also third-party services available

00:07:23,060 --> 00:07:27,740
for accomplishing this that can provide

00:07:25,370 --> 00:07:29,450
great UI is for toggling features many

00:07:27,740 --> 00:07:32,990
companies will also invest internal in

00:07:29,450 --> 00:07:35,960
internal tooling for this kind of

00:07:32,990 --> 00:07:38,060
functionality a few of a few of the most

00:07:35,960 --> 00:07:41,870
common strategies i've seen for using

00:07:38,060 --> 00:07:43,100
them are at the edge so using them and

00:07:41,870 --> 00:07:44,300
maybe your front-end code or your

00:07:43,100 --> 00:07:47,900
front-end application

00:07:44,300 --> 00:07:50,840
to toggle button color or copy or things

00:07:47,900 --> 00:07:52,580
of that nature if you're using them

00:07:50,840 --> 00:07:54,620
across the stack so you're also using

00:07:52,580 --> 00:07:55,880
them to toggle internal implementation

00:07:54,620 --> 00:07:59,930
details or internal implementation

00:07:55,880 --> 00:08:02,180
behavior you know you'll have you could

00:07:59,930 --> 00:08:05,570
potentially have dead code as a result

00:08:02,180 --> 00:08:08,590
of this across the stack so a few of the

00:08:05,570 --> 00:08:11,030
pros and cons of using future toggles so

00:08:08,590 --> 00:08:13,370
one benefit is you can pretty much say

00:08:11,030 --> 00:08:16,310
goodbye to feature branches you can

00:08:13,370 --> 00:08:18,560
merge branches behind a feature toggle

00:08:16,310 --> 00:08:21,830
or a feature flag it's also called dart

00:08:18,560 --> 00:08:24,650
deploying so if you have some feature

00:08:21,830 --> 00:08:25,840
that a team is working on you can kind

00:08:24,650 --> 00:08:28,340
of build the shell of that feature

00:08:25,840 --> 00:08:31,070
deploy to production and iterate on it

00:08:28,340 --> 00:08:34,490
iterate on it in production another

00:08:31,070 --> 00:08:36,229
benefit is it any enables the agile

00:08:34,490 --> 00:08:38,870
philosophy so you can release

00:08:36,229 --> 00:08:42,260
experimental features to a small user

00:08:38,870 --> 00:08:45,110
base and instead of building something

00:08:42,260 --> 00:08:46,730
that's larger upfront it also can give

00:08:45,110 --> 00:08:50,450
control of product functionality to

00:08:46,730 --> 00:08:51,440
stakeholders so an example of that would

00:08:50,450 --> 00:08:53,330
be is

00:08:51,440 --> 00:08:55,160
if there's a product manager on your

00:08:53,330 --> 00:08:57,530
team or project manager on your team

00:08:55,160 --> 00:09:01,130
they can control the state of of the

00:08:57,530 --> 00:09:02,960
product from a panel that's shared which

00:09:01,130 --> 00:09:07,100
has the various states of different

00:09:02,960 --> 00:09:10,970
flags in your project so it also allows

00:09:07,100 --> 00:09:13,460
for segmenting feature variations across

00:09:10,970 --> 00:09:15,950
your product which allows for a/b

00:09:13,460 --> 00:09:18,860
testing which can provide insight into

00:09:15,950 --> 00:09:21,140
optimal UX what your users like better

00:09:18,860 --> 00:09:23,510
what experience they prefer and what

00:09:21,140 --> 00:09:26,270
experience converts better so some of

00:09:23,510 --> 00:09:27,980
the cons so as mentioned it can be a

00:09:26,270 --> 00:09:29,560
significant source of dead code and in

00:09:27,980 --> 00:09:33,980
the form of potentially unreachable code

00:09:29,560 --> 00:09:35,660
which carries costs with it requires

00:09:33,980 --> 00:09:37,940
maintaining backwards compatibility in

00:09:35,660 --> 00:09:40,250
all code changes so if you're migrating

00:09:37,940 --> 00:09:41,330
from one way of doing something in your

00:09:40,250 --> 00:09:44,330
code base to another way of doing

00:09:41,330 --> 00:09:47,150
something you probably need to and want

00:09:44,330 --> 00:09:50,540
to maintain backwards compatibility

00:09:47,150 --> 00:09:53,570
between both those versions to support

00:09:50,540 --> 00:09:57,290
them if you potentially turn a flag or a

00:09:53,570 --> 00:09:58,970
feature toggle off or on it can

00:09:57,290 --> 00:10:00,350
introduce fragmented States across

00:09:58,970 --> 00:10:01,940
environments if environments are not

00:10:00,350 --> 00:10:04,520
kept in sync with the status of a toggle

00:10:01,940 --> 00:10:07,550
era flag so what I mean by that is if

00:10:04,520 --> 00:10:09,890
you have multiple environments for your

00:10:07,550 --> 00:10:13,460
application such as production QA

00:10:09,890 --> 00:10:17,060
development you might have different

00:10:13,460 --> 00:10:18,830
flags that have different states set in

00:10:17,060 --> 00:10:20,510
across different environments so you're

00:10:18,830 --> 00:10:22,190
seeing different experiences while

00:10:20,510 --> 00:10:23,360
testing your application in one

00:10:22,190 --> 00:10:26,180
environment or developing your

00:10:23,360 --> 00:10:27,920
application in one environment testing

00:10:26,180 --> 00:10:31,940
complexity so in your unit tests and

00:10:27,920 --> 00:10:36,020
your integration tests you probably want

00:10:31,940 --> 00:10:37,280
to maintain any tests that test existing

00:10:36,020 --> 00:10:39,890
behavior and new behavior that you're

00:10:37,280 --> 00:10:43,160
introducing behind a toggle so that

00:10:39,890 --> 00:10:46,910
carries costs with it as well so let's

00:10:43,160 --> 00:10:49,790
look at an example in code so here's a

00:10:46,910 --> 00:10:52,280
fairly large example so I'll try and

00:10:49,790 --> 00:10:55,570
break it down so let's pretend we're

00:10:52,280 --> 00:10:57,410
building a system for grading a

00:10:55,570 --> 00:10:59,180
transcript so we have a trance a

00:10:57,410 --> 00:11:01,760
transcript class there at the bottom

00:10:59,180 --> 00:11:04,670
that transcript class takes a list of

00:11:01,760 --> 00:11:06,980
letters grade letters

00:11:04,670 --> 00:11:10,160
and then it maps over them and builds up

00:11:06,980 --> 00:11:13,880
a collection of great objects each of

00:11:10,160 --> 00:11:15,769
those great objects has a public or that

00:11:13,880 --> 00:11:18,110
grade in that grade class has a public

00:11:15,769 --> 00:11:21,050
instance method points which will return

00:11:18,110 --> 00:11:24,279
the point value for each grade and then

00:11:21,050 --> 00:11:28,339
the average API on the transcript class

00:11:24,279 --> 00:11:29,930
will sum up each grade point or each

00:11:28,339 --> 00:11:31,220
grade and give you a point value and

00:11:29,930 --> 00:11:35,060
then divide by the total amount of

00:11:31,220 --> 00:11:37,160
grades that you have so here's kind of a

00:11:35,060 --> 00:11:39,829
second example that we've expanded here

00:11:37,160 --> 00:11:43,100
so say we want to support letter grades

00:11:39,829 --> 00:11:45,709
with plus and minus and The Associated

00:11:43,100 --> 00:11:46,640
point values there so this is also kind

00:11:45,709 --> 00:11:49,779
of large so I'm gonna break it down

00:11:46,640 --> 00:11:52,459
slide by slide so firstly we added the

00:11:49,779 --> 00:11:55,399
letter grades with the plus and minus

00:11:52,459 --> 00:11:59,170
point values and letter grades

00:11:55,399 --> 00:12:03,410
themselves secondly we added a generic

00:11:59,170 --> 00:12:05,959
keyword argument to the points method

00:12:03,410 --> 00:12:07,700
and what that does is if it's generic it

00:12:05,959 --> 00:12:12,110
looks at the first letter or the first

00:12:07,700 --> 00:12:13,820
character zeroth character in the grade

00:12:12,110 --> 00:12:16,070
instance instance variable value

00:12:13,820 --> 00:12:18,680
otherwise it uses the entire value which

00:12:16,070 --> 00:12:20,870
will include the plus or minus and then

00:12:18,680 --> 00:12:25,240
lastly we change the transcript average

00:12:20,870 --> 00:12:27,279
API which will pass through the generic

00:12:25,240 --> 00:12:31,180
argument which is passed through to it

00:12:27,279 --> 00:12:35,839
so that will give us either generic or

00:12:31,180 --> 00:12:40,490
non generic grade point average so

00:12:35,839 --> 00:12:43,490
here's that example altogether so here's

00:12:40,490 --> 00:12:46,040
how we might use that implementation so

00:12:43,490 --> 00:12:48,769
we will accentuate a transcript we'll

00:12:46,040 --> 00:12:51,940
pass through some grades to it and those

00:12:48,769 --> 00:12:55,880
will get mapped to great objects

00:12:51,940 --> 00:12:58,010
secondly we'll grab the feature feature

00:12:55,880 --> 00:13:00,490
toggle value for which grading strategy

00:12:58,010 --> 00:13:02,420
we want to use so we're imagining that

00:13:00,490 --> 00:13:04,699
you know there's a front end for this

00:13:02,420 --> 00:13:08,810
application and we're changing the

00:13:04,699 --> 00:13:11,680
grading strategy based on testing which

00:13:08,810 --> 00:13:14,449
which strategy is desired for the user

00:13:11,680 --> 00:13:16,520
so we'll we'll check the value of that

00:13:14,449 --> 00:13:18,560
toggle if it's generic then we'll call

00:13:16,520 --> 00:13:21,199
the transcript average API

00:13:18,560 --> 00:13:23,000
or method with without any arguments if

00:13:21,199 --> 00:13:25,550
it's not generic then we fall back onto

00:13:23,000 --> 00:13:29,209
passing through generic false which will

00:13:25,550 --> 00:13:33,740
use the plus and minus grade point

00:13:29,209 --> 00:13:36,310
values so what's the issue here so this

00:13:33,740 --> 00:13:38,240
implementation supports two behaviors

00:13:36,310 --> 00:13:41,449
probably could use some sort of

00:13:38,240 --> 00:13:43,639
abstraction and there could be separate

00:13:41,449 --> 00:13:46,970
strategies or separate classes for doing

00:13:43,639 --> 00:13:50,420
those calculations but let's assume that

00:13:46,970 --> 00:13:55,819
this code was supported to support it

00:13:50,420 --> 00:13:58,100
for being able to test multiple

00:13:55,819 --> 00:14:00,129
variations of a feature for which

00:13:58,100 --> 00:14:02,660
feature we'd like to or for which

00:14:00,129 --> 00:14:06,170
scoring strategy we'd like to proceed

00:14:02,660 --> 00:14:08,709
with so in that case we the internal

00:14:06,170 --> 00:14:12,310
implementation doesn't have any no

00:14:08,709 --> 00:14:16,819
know-how or knowing of the fact that

00:14:12,310 --> 00:14:20,860
it's being tested it's passed through

00:14:16,819 --> 00:14:24,730
via the generic keyword argument so

00:14:20,860 --> 00:14:30,050
eventually if this code here was only

00:14:24,730 --> 00:14:33,310
hitting the generic calculation snippet

00:14:30,050 --> 00:14:35,839
then the case where were doing the more

00:14:33,310 --> 00:14:38,720
complex calculation or advanced

00:14:35,839 --> 00:14:41,300
calculation would be dead code and

00:14:38,720 --> 00:14:43,220
vice-versa so if we decided that

00:14:41,300 --> 00:14:47,300
eventually we're only going to calculate

00:14:43,220 --> 00:14:50,120
with plus and minus letter grades then

00:14:47,300 --> 00:14:53,649
the simple calculation or generic

00:14:50,120 --> 00:14:56,259
calculation would become redundant so

00:14:53,649 --> 00:14:58,699
another way of doing this would be to

00:14:56,259 --> 00:15:01,370
have the internal implementation know

00:14:58,699 --> 00:15:03,079
about the feature toggle but then we

00:15:01,370 --> 00:15:05,809
would be coupling the feature toggle to

00:15:03,079 --> 00:15:08,630
the internal implementation so we we

00:15:05,809 --> 00:15:10,880
need to kind of understand the the

00:15:08,630 --> 00:15:13,220
variations either from the internal

00:15:10,880 --> 00:15:17,089
implementation or from the values being

00:15:13,220 --> 00:15:19,279
passed through to it so now I'll talk

00:15:17,089 --> 00:15:22,569
about for some strategies for managing

00:15:19,279 --> 00:15:25,220
dead code so in a case like this so

00:15:22,569 --> 00:15:27,500
there's this really unique and

00:15:25,220 --> 00:15:29,720
experimental library in the Ruby

00:15:27,500 --> 00:15:31,519
standard library called coverage it's a

00:15:29,720 --> 00:15:32,120
lightweight tool for tracking code

00:15:31,519 --> 00:15:35,089
passing

00:15:32,120 --> 00:15:36,950
larger code bases so here's the official

00:15:35,089 --> 00:15:40,370
documentation on it documentation on it

00:15:36,950 --> 00:15:42,230
it's pretty sparse so here's the example

00:15:40,370 --> 00:15:45,770
from the Ruby Docs

00:15:42,230 --> 00:15:47,990
I'll break this down so s equals zero

00:15:45,770 --> 00:15:51,970
it's it's setting s equal to 0 and then

00:15:47,990 --> 00:15:55,480
looping over ten times and incrementing

00:15:51,970 --> 00:15:57,860
the value of s with X in each iteration

00:15:55,480 --> 00:16:01,150
and then it's checking if the value is

00:15:57,860 --> 00:16:06,440
equal to 45 and outputting the ok symbol

00:16:01,150 --> 00:16:10,700
so the output is here down at the bottom

00:16:06,440 --> 00:16:12,529
so we can see oh that array that's what

00:16:10,700 --> 00:16:16,550
coverage give gives us so coverage is

00:16:12,529 --> 00:16:18,500
telling us that line zero or line 1 was

00:16:16,550 --> 00:16:20,510
ran' once and line two was around once

00:16:18,500 --> 00:16:23,300
and line three was around ten times and

00:16:20,510 --> 00:16:25,600
so forth anywhere that coverage outputs

00:16:23,300 --> 00:16:28,160
nil that means that it's a line that

00:16:25,600 --> 00:16:31,310
though there was no code that coverage

00:16:28,160 --> 00:16:33,380
could could tell us about so any an

00:16:31,310 --> 00:16:36,800
example that would be end or an empty

00:16:33,380 --> 00:16:40,010
line so that's why you see nil there for

00:16:36,800 --> 00:16:43,790
the last end and the first end as well

00:16:40,010 --> 00:16:45,020
as the empty line so it's kind of hard

00:16:43,790 --> 00:16:47,360
to understand at first without the

00:16:45,020 --> 00:16:51,380
actual line numbers so here's an example

00:16:47,360 --> 00:16:54,470
of that code snippet with some pretty

00:16:51,380 --> 00:16:56,600
printing so lines this basically

00:16:54,470 --> 00:16:58,760
converted the output from coverage into

00:16:56,600 --> 00:17:01,820
a hash instead of an array and the

00:16:58,760 --> 00:17:05,209
indices in that array indicate the line

00:17:01,820 --> 00:17:08,530
number in the code so this is telling us

00:17:05,209 --> 00:17:13,010
each line and how many times it was ran

00:17:08,530 --> 00:17:17,030
so coverage can be used for in larger

00:17:13,010 --> 00:17:19,130
examples you can use it for having the

00:17:17,030 --> 00:17:21,939
Ruby VM tell you which lines of code at

00:17:19,130 --> 00:17:24,920
run so you can pass through different

00:17:21,939 --> 00:17:26,720
values he's in the in the grading

00:17:24,920 --> 00:17:29,420
example you could pass through generic

00:17:26,720 --> 00:17:31,520
true or generic false and look at the

00:17:29,420 --> 00:17:34,190
output from coverage and coverage will

00:17:31,520 --> 00:17:36,440
tell you which lines the the VM ran and

00:17:34,190 --> 00:17:38,000
how many times so you can see if there

00:17:36,440 --> 00:17:40,490
are some lines that were expected to be

00:17:38,000 --> 00:17:43,520
run or weren't expected to be run and

00:17:40,490 --> 00:17:46,010
where coverage will tell you that so

00:17:43,520 --> 00:17:48,260
coverage can be useful for

00:17:46,010 --> 00:17:52,669
testing different variations of code

00:17:48,260 --> 00:17:55,540
paths that maybe aren't used anymore so

00:17:52,669 --> 00:17:57,440
another strategy for managing dead code

00:17:55,540 --> 00:18:00,140
warning and/or logging by the

00:17:57,440 --> 00:18:02,750
experimentation platform or feature

00:18:00,140 --> 00:18:04,340
toggling platform it's being used when a

00:18:02,750 --> 00:18:05,830
given experiment or a feature toggle has

00:18:04,340 --> 00:18:08,780
been alive for some period of time and

00:18:05,830 --> 00:18:11,270
targeting 100% of traffic so if you have

00:18:08,780 --> 00:18:13,429
a feature flag or a feature toggle or an

00:18:11,270 --> 00:18:15,799
experiment that has been running for a

00:18:13,429 --> 00:18:17,780
long time and it's been at 100% of

00:18:15,799 --> 00:18:20,090
traffic then you know that in your in

00:18:17,780 --> 00:18:22,910
your code base it's likely that the old

00:18:20,090 --> 00:18:26,270
variation is no longer needed and is

00:18:22,910 --> 00:18:28,610
probably a dead code so some

00:18:26,270 --> 00:18:31,240
experimentation platforms give this to

00:18:28,610 --> 00:18:33,820
you if you're using your own lightweight

00:18:31,240 --> 00:18:38,630
implementation you could build this into

00:18:33,820 --> 00:18:42,710
whatever you are using so there's also

00:18:38,630 --> 00:18:43,970
this really neat tool by Searles called

00:18:42,710 --> 00:18:47,929
to do or die

00:18:43,970 --> 00:18:51,370
it might be a bit too much but this is a

00:18:47,929 --> 00:18:54,620
way to comment or augment your code with

00:18:51,370 --> 00:18:57,160
to do or die calls and you can add a

00:18:54,620 --> 00:19:00,980
comment and a date and this will tell

00:18:57,160 --> 00:19:05,450
your application to this will tell your

00:19:00,980 --> 00:19:10,760
application to log or warn or even crash

00:19:05,450 --> 00:19:12,710
if some date has passed and that comment

00:19:10,760 --> 00:19:14,840
is still there so this can be useful for

00:19:12,710 --> 00:19:16,460
maybe personal projects or even

00:19:14,840 --> 00:19:18,350
production projects but you'll probably

00:19:16,460 --> 00:19:22,070
want a logger worn in production rather

00:19:18,350 --> 00:19:23,510
than crash so and then you could you

00:19:22,070 --> 00:19:26,540
could crash in pre-production

00:19:23,510 --> 00:19:29,690
environments similar to what DB migrate

00:19:26,540 --> 00:19:31,669
does in development so another strategy

00:19:29,690 --> 00:19:36,230
this is less technical and more

00:19:31,669 --> 00:19:39,169
organizational would be to add a

00:19:36,230 --> 00:19:41,540
requirement to whatever project

00:19:39,169 --> 00:19:43,910
initially introduced the new code or new

00:19:41,540 --> 00:19:47,960
functionality add a requirement to that

00:19:43,910 --> 00:19:50,360
project to come back and evaluate you

00:19:47,960 --> 00:19:52,640
know any old code that that may still

00:19:50,360 --> 00:19:53,990
exist due to the new functionality that

00:19:52,640 --> 00:19:58,159
was introduced and tested or

00:19:53,990 --> 00:19:59,690
experimented on so what if I do nothing

00:19:58,159 --> 00:20:02,330
so what if

00:19:59,690 --> 00:20:05,320
we never cleaned up dead code and we

00:20:02,330 --> 00:20:07,970
just let it exist in in our code bases

00:20:05,320 --> 00:20:10,010
technically I you know that wouldn't

00:20:07,970 --> 00:20:13,669
that may not break anything in and by

00:20:10,010 --> 00:20:15,500
itself but their costs associated with

00:20:13,669 --> 00:20:18,830
that and you might end up feeling like

00:20:15,500 --> 00:20:20,419
this so you might feel like everything

00:20:18,830 --> 00:20:23,960
is fine but eventually you'll you'll

00:20:20,419 --> 00:20:25,520
realize that you know it's becoming

00:20:23,960 --> 00:20:29,630
increasingly difficult to work in a code

00:20:25,520 --> 00:20:32,240
base like that so some of the costs

00:20:29,630 --> 00:20:36,020
associated with you know ignoring dead

00:20:32,240 --> 00:20:38,240
code or ignoring unreachable code could

00:20:36,020 --> 00:20:40,340
be wasted cycles in your application

00:20:38,240 --> 00:20:42,230
that causes a user to wait unnecessarily

00:20:40,340 --> 00:20:44,630
so this could be an external API call

00:20:42,230 --> 00:20:46,970
it's not needed or a database query

00:20:44,630 --> 00:20:48,559
that's not needed

00:20:46,970 --> 00:20:50,690
it makes onboarding engineers on to a

00:20:48,559 --> 00:20:52,429
project increasingly difficult when

00:20:50,690 --> 00:20:54,350
there are large pores portions of the

00:20:52,429 --> 00:20:55,580
project that are bellick's so if you

00:20:54,350 --> 00:20:58,539
have a new engineer joining the team

00:20:55,580 --> 00:21:00,980
jumping into the codebase and you know

00:20:58,539 --> 00:21:03,350
they're there are lots of portions of

00:21:00,980 --> 00:21:07,520
the code base or implementation that are

00:21:03,350 --> 00:21:10,789
no longer used are no longer executed it

00:21:07,520 --> 00:21:16,070
becomes increasingly difficult to manage

00:21:10,789 --> 00:21:18,590
that maintaining it by way of updating

00:21:16,070 --> 00:21:20,240
unit tests due to tangent tangential

00:21:18,590 --> 00:21:22,520
changes or supporting it without knowing

00:21:20,240 --> 00:21:26,419
it's unused has cost the suit associated

00:21:22,520 --> 00:21:29,179
with it as well so if you make some

00:21:26,419 --> 00:21:31,940
change and some portion of dead code

00:21:29,179 --> 00:21:36,110
breaks and you have to update or it's

00:21:31,940 --> 00:21:38,780
Tet their tests break due to some other

00:21:36,110 --> 00:21:40,640
unrelated change you may find yourself

00:21:38,780 --> 00:21:42,289
updating tests for dead code just

00:21:40,640 --> 00:21:44,750
because the dead poet itself hasn't been

00:21:42,289 --> 00:21:47,390
removed and that might be the path of

00:21:44,750 --> 00:21:49,610
least resistance so that's also kind of

00:21:47,390 --> 00:21:54,590
a another downside of maintaining old

00:21:49,610 --> 00:21:56,929
dead code so this is a great quote and

00:21:54,590 --> 00:21:59,780
Martin Fowler also has a great article

00:21:56,929 --> 00:22:02,120
on the cost of feature toggles but Heat

00:21:59,780 --> 00:22:03,679
the way he put it was Savi teams view

00:22:02,120 --> 00:22:06,470
their feature toggles as inventory which

00:22:03,679 --> 00:22:08,930
comes with a carrying cost and work to

00:22:06,470 --> 00:22:12,470
keep that inventory low

00:22:08,930 --> 00:22:15,950
as as low as possible so that's a great

00:22:12,470 --> 00:22:17,630
quote from him viewing dead code and as

00:22:15,950 --> 00:22:20,390
a result of future toggles or otherwise

00:22:17,630 --> 00:22:24,740
as inventory and the cost of that

00:22:20,390 --> 00:22:26,690
inventory can be seen if again so that's

00:22:24,740 --> 00:22:29,540
all I have for today I'll be taking

00:22:26,690 --> 00:22:31,750
questions afterward off stage so thanks

00:22:29,540 --> 00:22:31,750
everyone

00:22:34,180 --> 00:22:47,469

YouTube URL: https://www.youtube.com/watch?v=ffrv-JppavY


