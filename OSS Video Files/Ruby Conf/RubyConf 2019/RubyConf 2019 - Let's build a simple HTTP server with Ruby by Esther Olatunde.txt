Title: RubyConf 2019 - Let's build a simple HTTP server with Ruby by Esther Olatunde
Publication date: 2019-11-30
Playlist: RubyConf 2019
Description: 
	Let's build a simple HTTP server with Ruby by Esther Olatunde

Many developers at some point in their programming career get curious about how HTTP servers work and how to build one from scratch without any external libraries.​Well, recently, I got curious about “How do HTTP servers work”? “How are HTTP servers built?” and “Can I build an HTTP server and client with Ruby without using any gems?“ And you know what, the answers are, yes, yes and yes!​We’ll explore how to build a simple http server using the Socket class available in the Ruby’s standard library. In the process, we will also get a crash course on how HTTP works.


#confreaks #rubyconf2019 #rubyconf
Captions: 
	00:00:12,380 --> 00:00:16,980
>> Hi, everyone.

00:00:16,980 --> 00:00:19,130
I'm so excited to be here.

00:00:19,130 --> 00:00:24,190
This is my very first RubyConf, and the last [ Applause ]

00:00:24,190 --> 00:00:26,050
Yeah.

00:00:26,050 --> 00:00:29,450
So, I'm excited to be here.

00:00:29,450 --> 00:00:33,270
I can't imagine being a speaker.

00:00:33,270 --> 00:00:38,700
And the last couple of days has been really amazing, and it's what I imagined RubyConf

00:00:38,700 --> 00:00:40,140
to be and more.

00:00:40,140 --> 00:00:41,760
So, welcome!

00:00:41,760 --> 00:00:49,590
Welcome to my talk, which is let's build a simple HTTP server with Ruby.

00:00:49,590 --> 00:00:56,980
The Ruby community has a few popular web servers that are based off of Rack, we have web Rick,

00:00:56,980 --> 00:01:02,940
puma, Thin, unicorn, Passenger, and a few others.

00:01:02,940 --> 00:01:07,970
These servers are battle tested, so you don't really need to roll your own.

00:01:07,970 --> 00:01:10,220
There's no need for that.

00:01:10,220 --> 00:01:16,719
However, I think it's a great learning experience if you want to learn how HTTP and a simple

00:01:16,719 --> 00:01:20,000
web server works so you know what's going on under the hood.

00:01:20,000 --> 00:01:27,499
At the end of this talk, we'll ultimately be building a very simplistic server we will

00:01:27,499 --> 00:01:33,030
have built for ourselves with minimal HTTP, obviously non spec compliant HTTP server and

00:01:33,030 --> 00:01:34,030
client.

00:01:34,030 --> 00:01:40,210
Before I proceed, a little about me.

00:01:40,210 --> 00:01:45,209
I write code that sometimes works on computers.

00:01:45,209 --> 00:01:55,310
And I'm based in Lagos, Nigeria, and I'm a developer for Aexoo, a league tech marketplace

00:01:55,310 --> 00:01:56,909
based in the UK.

00:01:56,909 --> 00:02:00,289
So, let's dig in.

00:02:00,289 --> 00:02:10,810
How many of us knows what happens when you visit a URL in a browser?

00:02:10,810 --> 00:02:18,900
So this might seem a bit redundant to most of us, but I think we should start from here

00:02:18,900 --> 00:02:20,450
and connect the dots.

00:02:20,450 --> 00:02:26,340
The internet is a massive distributed client/server information system.

00:02:26,340 --> 00:02:34,800
Many applications are running over the web such as browsers, e mail, file transfer, audio,

00:02:34,800 --> 00:02:38,340
video streaming, e commerce, etc.

00:02:38,340 --> 00:02:44,160
In order for proper communication to take place between the client that is your browsers

00:02:44,160 --> 00:02:50,010
and these servers where the applications are on, these applications have to agree on the

00:02:50,010 --> 00:02:58,890
specific application level protocol such as HTTP for the web, FTP for e mail, for file

00:02:58,890 --> 00:03:04,830
transfer, SMTP for e mail and POP.

00:03:04,830 --> 00:03:15,500
The application protocol that makes the web work is hypertext transfer protocol or HTTP.

00:03:15,500 --> 00:03:21,180
It is a protocol that web browsers and web servers use to communicate with each other

00:03:21,180 --> 00:03:22,350
over the internet.

00:03:22,350 --> 00:03:30,970
The HTTP protocol is the mote popular application protocol that is used over the internet.

00:03:30,970 --> 00:03:36,610
And here's a basic overview of how it works.

00:03:36,610 --> 00:03:43,410
So, like I said earlier, HTTP is a request response protocol that describes how web servers

00:03:43,410 --> 00:03:47,710
exchange data with clients and browsers.

00:03:47,710 --> 00:03:53,260
So, when you type in a browser, this is technically what happens.

00:03:53,260 --> 00:04:00,430
The web browser connects to the web server, sends an HTTP request where the TCP protocol

00:04:00,430 --> 00:04:06,350
stack for the desired web page and the web server receives the request.

00:04:06,350 --> 00:04:08,440
It checks if the web page is available.

00:04:08,440 --> 00:04:14,120
If the page exists, the web server sends it back to the client.

00:04:14,120 --> 00:04:19,970
And if the page does not exist, the web server sends an error message.

00:04:19,970 --> 00:04:27,450
And this cycle, this request/response cycle is essentially how HTTP and the web works.

00:04:27,450 --> 00:04:40,880
HTTP, as specification for this protocol, there's a doc for it which is maintained by

00:04:40,880 --> 00:04:42,950
the worldwide web consortium.

00:04:42,950 --> 00:04:54,070
And the original is 0.9 released in 1991 by Tim Berners lee.

00:04:54,070 --> 00:04:56,060
And there have been different versions.

00:04:56,060 --> 00:05:03,430
HTTP/1.0 and 1.1.

00:05:03,430 --> 00:05:08,230
And there is also HTTP/2, which was standardized in 2015.

00:05:08,230 --> 00:05:15,660
I think there's a proposal in the works for HTTP/3, and that's currently in draft.

00:05:15,660 --> 00:05:21,389
If you are curious about that, this is the link and you can see the different spec that

00:05:21,389 --> 00:05:22,900
explains in details.

00:05:22,900 --> 00:05:30,150
If you want to join into discussion about HTTP/3, you can do that.

00:05:30,150 --> 00:05:41,880
So, the URL as a syntax, and the syntax URL essentially is a uniquely like it's used to

00:05:41,880 --> 00:05:48,270
uniquely identify a resource over the web, because that's, you know, the address, essentially,

00:05:48,270 --> 00:05:50,790
where any resource is based on the web.

00:05:50,790 --> 00:05:53,150
And this is what the syntax looks like.

00:05:53,150 --> 00:05:58,930
The syntax as the protocol which is application level protocol.

00:05:58,930 --> 00:06:05,580
And then it has the host name and it has the port for the web is usually port 80.

00:06:05,580 --> 00:06:08,140
You don't necessarily need to provide it.

00:06:08,140 --> 00:06:11,890
And it has the path or the file name.

00:06:11,890 --> 00:06:24,580
So for instance, when you receive this URL, example.com/Lagos, the browser issues a request

00:06:24,580 --> 00:06:29,889
and opens a connection to the example on port 80.

00:06:29,889 --> 00:06:35,400
The server accepts the connection, and when the connection has been made, the HTTP client

00:06:35,400 --> 00:06:45,230
that is your browser turns that URL into a request message and sends an HTTP request.

00:06:45,230 --> 00:06:54,770
So the server when it gets that request, it parses the request into a multiline string

00:06:54,770 --> 00:06:57,300
that looks like this.

00:06:57,300 --> 00:07:02,669
And the first line of that string is the request line.

00:07:02,669 --> 00:07:08,790
This is this contains the HTTP method, in this case it's get.

00:07:08,790 --> 00:07:17,890
It contains the request URI, which is also the path, and then it contains the HTTP version.

00:07:17,890 --> 00:07:24,710
Subsequent lines after the second line are request Headers, which are key value pairs

00:07:24,710 --> 00:07:27,370
that are delimited by a colon.

00:07:27,370 --> 00:07:33,520
And sometimes an HTTP request contains request body as well.

00:07:33,520 --> 00:07:42,790
So when you visit that particular URL on a web browser, so that request you saw earlier

00:07:42,790 --> 00:07:45,500
was, you know, the example.

00:07:45,500 --> 00:07:47,230
You get a lot more information.

00:07:47,230 --> 00:07:48,850
But it is similar.

00:07:48,850 --> 00:07:58,150
The first line always has that but browsers return more information to you more than code

00:07:58,150 --> 00:07:59,419
does.

00:07:59,419 --> 00:08:04,560
So using that same connection that has been established with your server, the server responds

00:08:04,560 --> 00:08:07,930
with the content of the file or an error.

00:08:07,930 --> 00:08:14,390
The HTTP server sends, you know, based on your request, it tries to interpret if your

00:08:14,390 --> 00:08:19,900
server understands the request, it tries to interpret it and return, you know, the content

00:08:19,900 --> 00:08:24,770
of the message based on, you know, its understanding of your request.

00:08:24,770 --> 00:08:31,260
So, this is the response that you get when you call example.com/lagos.

00:08:31,260 --> 00:08:41,899
So, because I made Lagos the HTML up, it doesn't exist, so the server is telling me, you know,

00:08:41,899 --> 00:08:43,209
404 not found.

00:08:43,209 --> 00:08:50,600
This returns the version, the scope, and the status message.

00:08:50,600 --> 00:08:52,650
And that's also the response Header.

00:08:52,650 --> 00:08:59,040
The response body also contains a bit more information about the response it is sending

00:08:59,040 --> 00:09:00,120
to you.

00:09:00,120 --> 00:09:03,600
And underneath that is the body of the response.

00:09:03,600 --> 00:09:11,149
So, if there is an HTML page there, it's rendered there or displayed to you.

00:09:11,149 --> 00:09:19,890
So this flow is essentially the basic implementation of HTTP and how HTTP servers work.

00:09:19,890 --> 00:09:26,370
Your server should be able to accept a request and it should be able to send back a response

00:09:26,370 --> 00:09:27,460
to you.

00:09:27,460 --> 00:09:32,820
This is the most common interaction that is happening on web servers today.

00:09:32,820 --> 00:09:35,130
What we're going to do today is let's implement this.

00:09:35,130 --> 00:09:42,110
Let's implement a server that can do this with just Ruby and no xml.

00:09:42,110 --> 00:09:44,250
What do we need for that?

00:09:44,250 --> 00:09:52,480
We need a tool that can listen for bidirectional communication between client and servers.

00:09:52,480 --> 00:09:54,490
And this leads us to Sockets.

00:09:54,490 --> 00:09:58,529
And a socket takes a bit, socket programming.

00:09:58,529 --> 00:10:06,360
But essentially, a socket is an endpoint for a two way communication between two programs

00:10:06,360 --> 00:10:07,790
that are running on a network.

00:10:07,790 --> 00:10:14,010
So, it's circular, it's bound to a port so the TCP layer can find the application that

00:10:14,010 --> 00:10:15,670
the data is sent to.

00:10:15,670 --> 00:10:20,410
And your server forms the listener socket while the client reaches out to the server.

00:10:20,410 --> 00:10:28,970
But you don't need to worry about implementing this, because the Ruby stdlib has already

00:10:28,970 --> 00:10:32,370
implemented Socket for us.

00:10:32,370 --> 00:10:38,420
And that brings us to the Socket Class, the Ruby Socket Class.

00:10:38,420 --> 00:10:43,890
It provides access to the underlying operating system socket implementations.

00:10:43,890 --> 00:10:50,959
So, it contains specific classes for handling common transports as well as a generic interface

00:10:50,959 --> 00:10:53,360
for handling the rest.

00:10:53,360 --> 00:10:59,790
All the functionality in the socket library is accessible through a single extension library,

00:10:59,790 --> 00:11:02,770
and this is well documented in there.

00:11:02,770 --> 00:11:06,960
So, you can go in and check it out and check out all the classes and all the methods that

00:11:06,960 --> 00:11:10,300
are attached to the socket.

00:11:10,300 --> 00:11:13,839
So, that's really all we need, guys.

00:11:13,839 --> 00:11:20,120
So now that we have our socket, we can now proceed to building our HTTP server.

00:11:20,120 --> 00:11:24,959
Before we go ahead, based on all I have been saying, I want to identify the three main

00:11:24,959 --> 00:11:30,810
things we are going to build, the three main features that our server needs to have to

00:11:30,810 --> 00:11:32,080
be functional.

00:11:32,080 --> 00:11:34,860
Our server needs to be able to listen for connection.

00:11:34,860 --> 00:11:39,680
It needs to be able to parse the request, and it needs to be able to build and send

00:11:39,680 --> 00:11:41,340
the response back to the client.

00:11:41,340 --> 00:11:44,220
So, we're going to build that.

00:11:44,220 --> 00:11:54,620
To handle the listening for connections bit, this is how we do that.

00:11:54,620 --> 00:12:04,890
We require socket from the stdlib, and then we need to define our server by initializing

00:12:04,890 --> 00:12:11,300
the TCPServer class and have it listen for new connections on TCP port.

00:12:11,300 --> 00:12:16,360
I have chosen to bound the server to port 5000.

00:12:16,360 --> 00:12:22,800
You can choose any integer from 100 and above.

00:12:22,800 --> 00:12:32,010
Next, we want to loop infinitely so that we can process our incoming connection one at

00:12:32,010 --> 00:12:35,870
a time.

00:12:35,870 --> 00:12:45,730
That will wait until a client connects to our server and it will return a TCPSocket

00:12:45,730 --> 00:12:52,130
that can be used in a similar fashion to other Ruby I/O object.

00:12:52,130 --> 00:13:01,060
Once we have that, we need to be able to once our server has been connected to, right, we

00:13:01,060 --> 00:13:06,450
need to be able to read the request that has just hit our server.

00:13:06,450 --> 00:13:15,080
And how we do that is using the .get method, and that method essentially reads the first

00:13:15,080 --> 00:13:17,570
line of the request.

00:13:17,570 --> 00:13:25,720
And you know, if you go into the socket library, it explains the .get method reads the next

00:13:25,720 --> 00:13:30,330
line from an I/O stream.

00:13:30,330 --> 00:13:38,110
We have initialized our server to be ready for that.

00:13:38,110 --> 00:13:42,030
Using the get method, we can read it.

00:13:42,030 --> 00:13:51,340
Then I'm just using the last one, using STDERR to print that out to the console.

00:13:51,340 --> 00:13:52,340
And that's it.

00:13:52,340 --> 00:13:57,070
So, with this, we have our server listening at port 5000.

00:13:57,070 --> 00:14:02,520
It can accept the connection and it can print the first line of the request that we just

00:14:02,520 --> 00:14:03,520
received.

00:14:03,520 --> 00:14:13,080
It is worthy to note that the server does nothing except listen to the IP address and

00:14:13,080 --> 00:14:20,830
the port that you specify until you make if you run that and until you make a request,

00:14:20,830 --> 00:14:26,230
it will be waiting and listening for you to connect to it.

00:14:26,230 --> 00:14:31,230
So, when you run this block of code, this is what you get.

00:14:31,230 --> 00:14:35,670
You get a response.

00:14:35,670 --> 00:14:37,170
On your console, you get this.

00:14:37,170 --> 00:14:45,029
And that's essentially the first line of the HTTP request, which is the get method and

00:14:45,029 --> 00:14:48,440
the path and the HTTP version.

00:14:48,440 --> 00:14:56,970
However, for a real server, we want our server to be able to read everything that has been

00:14:56,970 --> 00:15:00,520
sent to the I/O stream from the request.

00:15:00,520 --> 00:15:12,450
So, we do that using the.readpartial (2048) method.

00:15:12,450 --> 00:15:26,279
With 2048 byte stream, you can basically listen to almost every stream that every I/O stream

00:15:26,279 --> 00:15:29,440
that hits that request.

00:15:29,440 --> 00:15:34,790
So, with that, we get everything from our HTTP request.

00:15:34,790 --> 00:15:41,889
So, when you run that, you get this full HTTP request that has gotten to our server, and

00:15:41,889 --> 00:15:45,870
we're printing that out.

00:15:45,870 --> 00:15:50,339
So now that you have this, we need to be able to parse this.

00:15:50,339 --> 00:15:54,010
Because like I mentioned earlier, that is just a string like on your server.

00:15:54,010 --> 00:15:55,710
It is seen as a string.

00:15:55,710 --> 00:15:57,371
Like it doesn't understand it.

00:15:57,371 --> 00:16:05,120
It needs to be able to parse it so it understands what to do with the string that it has received.

00:16:05,120 --> 00:16:06,450
So it's just a string.

00:16:06,450 --> 00:16:07,740
We need to be able to parse it.

00:16:07,740 --> 00:16:13,209
And to parse it, I have this parse method.

00:16:13,209 --> 00:16:23,329
And this parse method essentially, because we know the request string, the first line

00:16:23,329 --> 00:16:28,980
of your request string has the method, the path, and the version, we're essentially splitting

00:16:28,980 --> 00:16:35,660
your first line into three variables and assigning the first is the method, the second is the

00:16:35,660 --> 00:16:37,700
path, and the third is the version.

00:16:37,700 --> 00:16:40,589
So, that's very simple and that does just that.

00:16:40,589 --> 00:16:47,730
And then we want that parse method to return a hash with the method, the path, and the

00:16:47,730 --> 00:16:48,730
headers.

00:16:48,730 --> 00:16:56,670
And for the headers, we need to parse that a little bit more, because the headers needs

00:16:56,670 --> 00:17:04,069
to be made up of an hash of key value pairs so you know what is in the header that your

00:17:04,069 --> 00:17:06,150
HTTP request has.

00:17:06,150 --> 00:17:13,049
And the next slide shows a snippet of code for how you parse the headers.

00:17:13,049 --> 00:17:19,070
So, here, we're taking the request body from the second line, because we already we've

00:17:19,070 --> 00:17:21,480
already handled the first line.

00:17:21,480 --> 00:17:27,750
And then we are taking each line until we get to the end of the line, we're splitting

00:17:27,750 --> 00:17:30,280
it into key and value.

00:17:30,280 --> 00:17:31,630
That's essentially what that does.

00:17:31,630 --> 00:17:38,410
It parses into key value pairs and delimited by a colon.

00:17:38,410 --> 00:17:46,070
So, at the end of this, like when you run all of this code, we should have a parsed

00:17:46,070 --> 00:17:48,460
request that our server understands.

00:17:48,460 --> 00:17:53,549
So, our server knows what is what based on the request it gets.

00:17:53,549 --> 00:18:00,669
So, when you run that, you should get this, which is a hash that has been parsed.

00:18:00,669 --> 00:18:03,100
This is our request.

00:18:03,100 --> 00:18:06,350
Our server knows this is the method.

00:18:06,350 --> 00:18:07,491
This is the path.

00:18:07,491 --> 00:18:09,280
And these are the headers.

00:18:09,280 --> 00:18:14,960
When we have this data, we can now use it on our server as we want.

00:18:14,960 --> 00:18:24,320
So, when we have this data, we need to now build and send the response back to our client.

00:18:24,320 --> 00:18:37,870
So to do that, I have this method that essentially assigns the path, you know, using our parsed_request

00:18:37,870 --> 00:18:47,230
and fetching the path that's there and the third line checks if the path is the directory

00:18:47,230 --> 00:18:50,770
using the forward slash.

00:18:50,770 --> 00:18:56,740
We respond with the server root path, and the index.html.

00:18:56,740 --> 00:19:01,620
And index.html is a file that exists on your server.

00:19:01,620 --> 00:19:08,330
It could be a jpeg or whatever you want, your own directory for your server to have when

00:19:08,330 --> 00:19:11,850
you hit the home path of your server.

00:19:11,850 --> 00:19:19,130
And if it's not the home directory, you want it to essentially, you know, look for the

00:19:19,130 --> 00:19:21,870
path, you know, in your own directory.

00:19:21,870 --> 00:19:25,040
And return that to you.

00:19:25,040 --> 00:19:32,030
In a second, I'm going to show you what the respond_with method does.

00:19:32,030 --> 00:19:39,010
The respond_with method is pretty straightforward in that it's just checking is that path the

00:19:39,010 --> 00:19:41,510
file, is the file at that path?

00:19:41,510 --> 00:19:44,180
Does it exist, right?

00:19:44,180 --> 00:19:51,490
If it finds that path in your root directory, it essentially we call another method which

00:19:51,490 --> 00:19:55,299
returns an ok response and reads that file to you.

00:19:55,299 --> 00:19:58,270
I will show you what the OK response looks like shortly.

00:19:58,270 --> 00:20:01,950
If it doesn't, if it returns a Not Found response.

00:20:01,950 --> 00:20:08,110
So, those are the conditions we are handling at the moment.

00:20:08,110 --> 00:20:16,721
And for a functional production ready HTTP server, you know that condition can go, you

00:20:16,721 --> 00:20:18,830
know, there can be a different flow for that.

00:20:18,830 --> 00:20:22,799
And it would have to be a lot more elegant than that.

00:20:22,799 --> 00:20:28,070
So, this is what our OK Response looks like.

00:20:28,070 --> 00:20:34,000
Essentially because we know according to HTTP spec that the status code for an OK response

00:20:34,000 --> 00:20:36,510
is 200, we're just using that.

00:20:36,510 --> 00:20:42,510
And then we are also sending the buddy from the OK response to our response class, which

00:20:42,510 --> 00:20:44,630
I will show to you in a minute.

00:20:44,630 --> 00:20:47,470
This is what the Not Found response looks like.

00:20:47,470 --> 00:20:54,210
The Not Found response just returns 404 and it doesn't bother for that.

00:20:54,210 --> 00:20:59,610
And here is what the response class looks like.

00:20:59,610 --> 00:21:08,470
So, here, because we already know according to the HTTP spec the structure of what an

00:21:08,470 --> 00:21:11,020
HTTP response should look like.

00:21:11,020 --> 00:21:18,640
We're essentially picking the core, the buddy, and creating a string that looks like what

00:21:18,640 --> 00:21:23,270
an HTTP response should look like, but we are using that based on the request that we've

00:21:23,270 --> 00:21:27,650
gotten from our server.

00:21:27,650 --> 00:21:36,280
And then when we have the response, we send that back to the client.

00:21:36,280 --> 00:21:41,810
And that's what our response class looks like.

00:21:41,810 --> 00:21:49,260
So, this is what the full thing looks like if you put all of the code I've just showed

00:21:49,260 --> 00:21:50,340
you.

00:21:50,340 --> 00:21:51,419
Yeah.

00:21:51,419 --> 00:21:53,059
This is what the full thing looks like.

00:21:53,059 --> 00:22:00,860
We're requiring the socket from the stdlib.

00:22:00,860 --> 00:22:06,179
All of those methods that I showed to you earlier, I extracted them into a class called

00:22:06,179 --> 00:22:08,160
HTTP request parser.

00:22:08,160 --> 00:22:15,870
And then I, you know, extracted the response into another class, and then, you know, we

00:22:15,870 --> 00:22:23,870
are initializing our server and binding it to port 5000, listening for connection, reading

00:22:23,870 --> 00:22:32,800
everything that hits our connection as a request, creating a usable request from that, taking

00:22:32,800 --> 00:22:38,470
that request, sending it to our response class so that our response class can parse that

00:22:38,470 --> 00:22:42,660
properly, and we take that response and send it back to the client and then we close the

00:22:42,660 --> 00:22:43,660
client.

00:22:43,660 --> 00:22:49,400
And that's the simple flow for implementing an HTTP server.

00:22:49,400 --> 00:22:52,640
So, what I want to do now is let's see.

00:22:52,640 --> 00:23:01,850
I want to run this and show you, you know, what this looks like, what we have implemented

00:23:01,850 --> 00:23:05,860
so far.

00:23:05,860 --> 00:23:13,039
All right.

00:23:13,039 --> 00:23:19,440
Showing you again what I have displayed in the slides.

00:23:19,440 --> 00:23:21,289
This is in server.rb.

00:23:21,289 --> 00:23:35,500
So, when we run this... ruby server.rb.

00:23:35,500 --> 00:23:36,980
We have started our server.

00:23:36,980 --> 00:23:46,760
It runs whatever it is in the server.rb and we have bound to port 5000, and it's just

00:23:46,760 --> 00:23:49,710
waiting for a connection.

00:23:49,710 --> 00:23:52,400
And it will keep waiting until we make a request to end.

00:23:52,400 --> 00:23:53,700
Let's make a request to end.

00:23:53,700 --> 00:24:05,850
I want to call localhost:5000 Yeah.

00:24:05,850 --> 00:24:15,570
So, when you call localhost:5000, that's what's happening.

00:24:15,570 --> 00:24:16,570
You know?

00:24:16,570 --> 00:24:24,190
You have the HTTP request at the top, and then beneath that you have the header, which

00:24:24,190 --> 00:24:28,840
is what we have in our index page.

00:24:28,840 --> 00:24:33,700
So, if I want to let me see if I can that is using call.

00:24:33,700 --> 00:24:49,090
Let's see what that looks like on a browser...

00:24:49,090 --> 00:24:55,140
Okay.

00:24:55,140 --> 00:25:01,190
Yeah.

00:25:01,190 --> 00:25:09,530
So, you have the Hello World.

00:25:09,530 --> 00:25:22,420
I have another file in there that is Hello world what's that?

00:25:22,420 --> 00:25:27,039
Hello.txt, I think?

00:25:27,039 --> 00:25:31,720
So that's displaying hello.txt, and that's on the server.

00:25:31,720 --> 00:25:36,130
It's basically the same thing as the results.

00:25:36,130 --> 00:25:39,400
That exists in our server root path.

00:25:39,400 --> 00:25:43,580
There is one more thing that I will explain in a bit.

00:25:43,580 --> 00:25:54,180
We have I have a hello.rb, so you can execute Ruby if the file is executable on your root

00:25:54,180 --> 00:25:55,180
directory.

00:25:55,180 --> 00:25:56,180
So, let me show you that.

00:25:56,180 --> 00:25:58,049
So, I have 9+2 there, and that is valid to 11.

00:25:58,049 --> 00:26:03,860
So, let's go back to the slides...

00:26:03,860 --> 00:26:27,840
I want to minimize that... oh, sorry.

00:26:27,840 --> 00:26:31,270
Okay.

00:26:31,270 --> 00:26:58,680
Um... that's not showing yet... where was I?

00:26:58,680 --> 00:27:05,530
All right.

00:27:05,530 --> 00:27:12,380
Cool, yeah.

00:27:12,380 --> 00:27:21,930
So, I just showed you a demo of what that does when you run that.

00:27:21,930 --> 00:27:28,860
Now that we have you can see we have our server handling basic resource fetching.

00:27:28,860 --> 00:27:33,830
I forgot to show you if we request for a file that doesn't exist, it will handle that and

00:27:33,830 --> 00:27:38,860
show you 404, Not Found.

00:27:38,860 --> 00:27:42,340
If you want to get there are a few other things we can do.

00:27:42,340 --> 00:27:44,429
We can get a little ambitious.

00:27:44,429 --> 00:27:46,159
I already showed you that.

00:27:46,159 --> 00:27:50,020
We can make our server execute a Ruby file.

00:27:50,020 --> 00:27:55,510
And we can also make our server parse a query.

00:27:55,510 --> 00:28:02,210
So, how will you, you know, develop your server, like modify what I have just shown you to

00:28:02,210 --> 00:28:08,330
parse a query so that it understands that this particular part that you just requested

00:28:08,330 --> 00:28:11,710
for has a query, and how would you handle that query?

00:28:11,710 --> 00:28:19,840
To execute a Ruby file, you can modify that snippet of code I have and essentially check

00:28:19,840 --> 00:28:21,289
if that file is executable.

00:28:21,289 --> 00:28:27,500
So, just straightforward, you have the file.executable method on the file class.

00:28:27,500 --> 00:28:35,220
Check if it is executable and if it is, use the path to execute that.

00:28:35,220 --> 00:28:40,770
And if it's not, you do the regular file.binread that we have been doing and just basically

00:28:40,770 --> 00:28:44,870
read that file and return it.

00:28:44,870 --> 00:28:50,970
For parsing a query, we need to modify if you remember our query parser method, we need

00:28:50,970 --> 00:28:58,130
to modify that just a little bit because we know that according to the HTTP spec, when

00:28:58,130 --> 00:29:03,360
it has a question mark sign, sit a query.

00:29:03,360 --> 00:29:06,440
We have agreed that that's the situation.

00:29:06,440 --> 00:29:18,450
We have taken that path and split it by the question mark, and whatever is after the first

00:29:18,450 --> 00:29:26,240
index of that, the second index of whatever is after the split is your query.

00:29:26,240 --> 00:29:33,059
And then when you have that query, we can then modify that and send that back to your

00:29:33,059 --> 00:29:40,929
request parser, return your parsed request in a way that you add the query to your parsed

00:29:40,929 --> 00:29:41,929
request.

00:29:41,929 --> 00:29:47,711
So, when that has been parsed, you can see how you can modify your request parser that

00:29:47,711 --> 00:29:57,250
if this request has a query, this is the flow you should go and how you should handle that.

00:29:57,250 --> 00:30:03,470
But for the sake of this presentation, I didn't put it in the demo.

00:30:03,470 --> 00:30:10,789
But you can play around with that and try and implement that.

00:30:10,789 --> 00:30:13,610
Hold on... oh yeah.

00:30:13,610 --> 00:30:15,720
I had that.

00:30:15,720 --> 00:30:17,130
All right.

00:30:17,130 --> 00:30:26,390
So, that's our server, but do you think our server is ready to be made available on the

00:30:26,390 --> 00:30:28,190
internet yet?

00:30:28,190 --> 00:30:38,350
Um... unfortunately, I mean, if you're the only one that knows the URL the ports, I mean,

00:30:38,350 --> 00:30:42,470
the URL where that server is and you're not sharing with anyone, fine.

00:30:42,470 --> 00:30:49,299
But if you want to make it available in public, I would say no, sadly, because it's missing

00:30:49,299 --> 00:30:50,929
lots of features, right?

00:30:50,929 --> 00:30:56,299
If this is the only server we have, our job would be so hard.

00:30:56,299 --> 00:30:58,200
It's missing lots of features.

00:30:58,200 --> 00:31:00,530
And there's so many features you can add to it.

00:31:00,530 --> 00:31:03,910
We can do query parsing.

00:31:03,910 --> 00:31:06,390
We can have one handling security.

00:31:06,390 --> 00:31:11,010
We have one handling lots of, tons of stuff.

00:31:11,010 --> 00:31:18,570
But there's one particular issue I would like to highlight based on the current implementation

00:31:18,570 --> 00:31:21,700
of the server that I just showed you.

00:31:21,700 --> 00:31:28,299
And that is the current implementation I just showed you is susceptible to path traversal

00:31:28,299 --> 00:31:29,299
attack.

00:31:29,299 --> 00:31:30,789
And this is an attack.

00:31:30,789 --> 00:31:36,681
When you put that server I have now on the internet, someone can essentially using the

00:31:36,681 --> 00:31:46,220
dot dot slash to access root directories that I do not want them to.

00:31:46,220 --> 00:31:48,620
That's not secure.

00:31:48,620 --> 00:31:56,700
So, someone can essentially, you know, if that's not localhost, it's an IP address that

00:31:56,700 --> 00:31:59,700
links to a server that I have on the internet.

00:31:59,700 --> 00:32:05,980
Someone can use the ../to access the directory, and we don't want that.

00:32:05,980 --> 00:32:13,919
There are solutions and algorithms that have been written to prevent this, but I didn't

00:32:13,919 --> 00:32:15,710
cover that in this scope.

00:32:15,710 --> 00:32:21,480
But it's something to look out for, and you can play around with it with your friends.

00:32:21,480 --> 00:32:28,340
So, as Ruby developers, I'm sure we're all wondering, yeah, we've built this very simplistic

00:32:28,340 --> 00:32:29,340
thing.

00:32:29,340 --> 00:32:30,340
How does this affect my life?

00:32:30,340 --> 00:32:33,990
Where does Rack fit in?

00:32:33,990 --> 00:32:41,200
I want to do a little bit of two points to basically link that back to Rack.

00:32:41,200 --> 00:32:50,309
Essentially, why we use Rack and why the Rack is so such a life saver is that Rack has built

00:32:50,309 --> 00:32:53,490
an HTTP interface for Ruby.

00:32:53,490 --> 00:32:59,409
Most of the servers that we have, that I showed you earlier, web Rick, Thin, they are all

00:32:59,409 --> 00:33:01,059
built on top of Rack.

00:33:01,059 --> 00:33:07,570
It is defined a standard interface for interacting with HTTP and connecting web servers.

00:33:07,570 --> 00:33:16,350
All of the things that we are missing, they have been developed and thought through and

00:33:16,350 --> 00:33:18,370
built properly in Rack.

00:33:18,370 --> 00:33:30,690
So, you can take if you are trying to build a server

00:33:30,690 --> 00:33:36,220
that you want to put on the internet, I would advise you, you know, build it on top of Rack.

00:33:36,220 --> 00:33:41,710
So, all that I have just shown you with a few lines of code, you can, you know, have

00:33:41,710 --> 00:33:48,401
a server that does a lot more than I have just displayed, and you can have that, you

00:33:48,401 --> 00:33:51,450
know, a functional production ready server.

00:33:51,450 --> 00:33:54,320
And that's it.

00:33:54,320 --> 00:34:00,940
If you want to read more, there is the HTTP spec doc, there is a socket doc, there is

00:34:00,940 --> 00:34:04,150
a Rack doc, and I like digging.

00:34:04,150 --> 00:34:08,329
I'm really very curious, because that's how I learn.

00:34:08,329 --> 00:34:16,230
You can check the docs and see how the things are built and the connecting points.

00:34:16,230 --> 00:34:17,579
I'm challenging you.

00:34:17,579 --> 00:34:25,279
If you can, you should try and dig into the Rack and see where the beginning part, where

00:34:25,279 --> 00:34:28,409
the socket library that I showed you is used.

00:34:28,409 --> 00:34:31,669
You will find that code interesting.

00:34:31,669 --> 00:34:32,669
And that's it.

00:34:32,669 --> 00:34:33,669
Thank you.

00:34:33,669 --> 00:34:34,669
Thank you so much.

00:34:34,669 --> 00:34:34,670

YouTube URL: https://www.youtube.com/watch?v=JFbBj2CN5Mo


