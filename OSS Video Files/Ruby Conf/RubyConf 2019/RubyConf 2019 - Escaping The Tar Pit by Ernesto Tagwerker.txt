Title: RubyConf 2019 - Escaping The Tar Pit by Ernesto Tagwerker
Publication date: 2019-12-03
Playlist: RubyConf 2019
Description: 
	RubyConf 2019 - Escaping The Tar Pit by Ernesto Tagwerker

Nobody wants to inherit a project that reeks but here we are: Stuck in the tar pit. How can we get out? Could we have avoided it in the first place?


In this talk you will learn how to use a few, great Ruby gems that will guide you out of that sticky tar you are in. On top of that, you will learn a repeatable way to gradually pay off technical debt.

#rubyconf2019 #confreaks
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:12,200 --> 00:00:18,840
well welcome back here to talk about the

00:00:16,379 --> 00:00:21,449
tar pit how to avoid it in the first

00:00:18,840 --> 00:00:24,480
place and if you're stuck in it how to

00:00:21,449 --> 00:00:26,910
get out of it my name is Ernesto tack

00:00:24,480 --> 00:00:29,850
worker and you can find me on Twitter

00:00:26,910 --> 00:00:35,719
github anywhere with the handle attack

00:00:29,850 --> 00:00:39,359
worker my pronouns are he/him his and

00:00:35,719 --> 00:00:43,769
I'm honored to be here and the code

00:00:39,359 --> 00:00:47,129
quality track so I'm originally from

00:00:43,769 --> 00:00:49,469
Argentina so if you've if you hear an

00:00:47,129 --> 00:00:52,710
accent or weird word it's because

00:00:49,469 --> 00:00:54,089
English is not my first language so I'll

00:00:52,710 --> 00:00:56,489
try to do my best

00:00:54,089 --> 00:00:58,559
I have been living in Philadelphia for

00:00:56,489 --> 00:01:02,370
the past three years with my wife

00:00:58,559 --> 00:01:04,500
daughter and I love open source I

00:01:02,370 --> 00:01:07,260
wouldn't be here today if it wasn't

00:01:04,500 --> 00:01:09,090
thanks to open source a lot of the code

00:01:07,260 --> 00:01:11,880
that I'm going to talk about was written

00:01:09,090 --> 00:01:15,930
by other people maybe some of you out

00:01:11,880 --> 00:01:17,909
there actually maybe like 5% of the code

00:01:15,930 --> 00:01:20,009
that I'm gonna talk about in this talk I

00:01:17,909 --> 00:01:24,420
wrote myself and it's basically just

00:01:20,009 --> 00:01:26,909
gluing other open-source libraries I'm

00:01:24,420 --> 00:01:30,149
the founder of a small software

00:01:26,909 --> 00:01:32,240
development shop called humble aus we

00:01:30,149 --> 00:01:35,909
like to work a lot with Ruby rails

00:01:32,240 --> 00:01:37,859
JavaScript and open source we try to

00:01:35,909 --> 00:01:40,859
give back to the community as much as

00:01:37,859 --> 00:01:43,829
possible through a bunch of gems that

00:01:40,859 --> 00:01:46,649
you might have heard of now a few years

00:01:43,829 --> 00:01:50,280
ago we found ourselves working a lot

00:01:46,649 --> 00:01:52,920
with rails upgrades and we thought why

00:01:50,280 --> 00:01:56,789
don't we make a service out of this and

00:01:52,920 --> 00:01:59,670
that's how fast Ruby dot IO was born

00:01:56,789 --> 00:02:01,590
it's basically a productize service that

00:01:59,670 --> 00:02:05,039
helps companies upgrade their rails

00:02:01,590 --> 00:02:07,380
applications in a few weeks now the

00:02:05,039 --> 00:02:10,229
problem with this is that we get a ton

00:02:07,380 --> 00:02:13,110
of projects that are not ready for an

00:02:10,229 --> 00:02:15,060
upgrade so a lot of the insights I'm

00:02:13,110 --> 00:02:18,270
gonna share with you today come from our

00:02:15,060 --> 00:02:21,209
experience doing rails upgrades but also

00:02:18,270 --> 00:02:24,480
assessing code quality very quickly

00:02:21,209 --> 00:02:27,299
we spend one week doing a code dive into

00:02:24,480 --> 00:02:30,030
our clients projects and then we decide

00:02:27,299 --> 00:02:32,909
whether we take them or not because

00:02:30,030 --> 00:02:35,780
we're never going to do a rails upgrade

00:02:32,909 --> 00:02:38,790
for a project that has no code coverage

00:02:35,780 --> 00:02:41,400
so that's one of the things that to keep

00:02:38,790 --> 00:02:44,670
in mind now when I'm not working on

00:02:41,400 --> 00:02:47,819
humble labs or fast Ruby do I like to

00:02:44,670 --> 00:02:50,280
maintain a few gems database cleaner is

00:02:47,819 --> 00:02:53,599
a tool that helps you clean your

00:02:50,280 --> 00:02:58,200
database your database between test runs

00:02:53,599 --> 00:03:00,989
bundler leak is a gem that lets you find

00:02:58,200 --> 00:03:03,269
leaky dependencies in your application

00:03:00,989 --> 00:03:05,250
there's a known database of leaky

00:03:03,269 --> 00:03:07,650
dependencies out there and you might be

00:03:05,250 --> 00:03:10,620
using one of them so bundler leak does

00:03:07,650 --> 00:03:13,310
help you with that and next rails is a

00:03:10,620 --> 00:03:15,629
tool kit that will help you find

00:03:13,310 --> 00:03:17,939
incompatibilities between your current

00:03:15,629 --> 00:03:20,310
version of rails and your next version

00:03:17,939 --> 00:03:24,239
of rails and it will help you do things

00:03:20,310 --> 00:03:26,790
like dual booting now the inspiration

00:03:24,239 --> 00:03:29,159
for this talk is this book that was

00:03:26,790 --> 00:03:30,959
published many many years ago it's

00:03:29,159 --> 00:03:34,079
called the mythical man-month

00:03:30,959 --> 00:03:39,030
and the very first chapter talks about

00:03:34,079 --> 00:03:42,209
the tar pit and Fred Brooks here talks

00:03:39,030 --> 00:03:44,790
about this pre historical scene where

00:03:42,209 --> 00:03:49,079
beasts would get stuck in the tar pit

00:03:44,790 --> 00:03:51,810
and struggled to get out I really liked

00:03:49,079 --> 00:03:54,750
this quote that says the fiercer to

00:03:51,810 --> 00:03:58,739
struggle the more entangling the tar and

00:03:54,750 --> 00:04:02,310
no beast is so so strong or so skillful

00:03:58,739 --> 00:04:04,319
but that they ultimately sink and then

00:04:02,310 --> 00:04:10,259
he goes on to talk about large system

00:04:04,319 --> 00:04:13,650
programming and to be honest this book

00:04:10,259 --> 00:04:16,500
was published in 1975 and today we still

00:04:13,650 --> 00:04:18,750
have the same issues that are written

00:04:16,500 --> 00:04:22,049
out in this book - the mainframe

00:04:18,750 --> 00:04:24,090
mainframe problems and all that so you

00:04:22,049 --> 00:04:25,650
can replace large system programming in

00:04:24,090 --> 00:04:28,889
this phrase and replace it with cloud

00:04:25,650 --> 00:04:32,550
computing or Minimum Viable products

00:04:28,889 --> 00:04:34,689
development fred brooks is also the

00:04:32,550 --> 00:04:37,029
author of no sir and also

00:04:34,689 --> 00:04:39,309
bullet an essay that is great I

00:04:37,029 --> 00:04:42,489
recommend you go read it if you haven't

00:04:39,309 --> 00:04:45,939
already and in that essay he talks about

00:04:42,489 --> 00:04:48,939
our problems not being solved by one

00:04:45,939 --> 00:04:51,449
technology because our problems in

00:04:48,939 --> 00:04:54,719
software engineering are not they're not

00:04:51,449 --> 00:04:57,399
technological per se they're more about

00:04:54,719 --> 00:05:02,019
processes and communication and teams

00:04:57,399 --> 00:05:03,909
and people so going back to the Tarpan i

00:05:02,019 --> 00:05:06,849
think we're either in two states we're

00:05:03,909 --> 00:05:09,669
in the tar pit right now or we're trying

00:05:06,849 --> 00:05:12,579
to avoid it and if we are in the tar pit

00:05:09,669 --> 00:05:15,399
we're trying to get out we've all

00:05:12,579 --> 00:05:17,499
inherited a project that sucked

00:05:15,399 --> 00:05:19,809
and we're like yeah I'm gonna pay off

00:05:17,499 --> 00:05:22,449
technical debt and it's gonna be awesome

00:05:19,809 --> 00:05:24,879
I'm gonna make it awesome and then you

00:05:22,449 --> 00:05:25,509
go into the project you start doing your

00:05:24,879 --> 00:05:27,519
best

00:05:25,509 --> 00:05:31,229
trying to refactor and the more you

00:05:27,519 --> 00:05:34,779
refactor the harder it gets

00:05:31,229 --> 00:05:38,739
yes to bring it back to modern world The

00:05:34,779 --> 00:05:41,559
Simpsons always have a gift for this and

00:05:38,739 --> 00:05:43,779
that's what it looks like so to bring it

00:05:41,559 --> 00:05:46,269
back to reality and just stop talking

00:05:43,779 --> 00:05:49,269
about an analogy the Tar Pits sometimes

00:05:46,269 --> 00:05:51,729
shows up like this projects running

00:05:49,269 --> 00:05:53,919
over-budget saying you ship something in

00:05:51,729 --> 00:05:57,610
a month and then six months end you

00:05:53,919 --> 00:06:00,669
don't know when you'll be done taking

00:05:57,610 --> 00:06:02,559
forever to ship small changes telling

00:06:00,669 --> 00:06:05,110
your boss yeah I'll ship this change in

00:06:02,559 --> 00:06:07,119
a week and then a week goes by and your

00:06:05,110 --> 00:06:12,099
boss is like so when is it gonna be done

00:06:07,119 --> 00:06:14,619
you're like I have no idea and then the

00:06:12,099 --> 00:06:17,349
classic sacrificing quality and

00:06:14,619 --> 00:06:19,569
increasing increasing tech debt to be

00:06:17,349 --> 00:06:22,569
paid off later but then later never

00:06:19,569 --> 00:06:25,689
comes and the tarp it just gets stickier

00:06:22,569 --> 00:06:29,889
and stickier and to bring it back to

00:06:25,689 --> 00:06:32,909
reality and to a current gif we can look

00:06:29,889 --> 00:06:39,129
at this and we're all familiar with this

00:06:32,909 --> 00:06:40,929
but it's not fine because this is is

00:06:39,129 --> 00:06:44,619
messy and you don't want to be in a

00:06:40,929 --> 00:06:46,959
project like this one so yeah the first

00:06:44,619 --> 00:06:48,130
thing you can do is avoid such projects

00:06:46,959 --> 00:06:50,710
right

00:06:48,130 --> 00:06:52,480
you'll be in this situation where boss

00:06:50,710 --> 00:06:54,460
comes up to you and they tell you yeah

00:06:52,480 --> 00:06:57,520
if you could come in on this great

00:06:54,460 --> 00:07:03,820
legacy project and maintaining maintain

00:06:57,520 --> 00:07:06,820
it from now on that'd be great for us at

00:07:03,820 --> 00:07:09,130
fast Rubio it's basically a client who

00:07:06,820 --> 00:07:10,870
has a rails project that is totally out

00:07:09,130 --> 00:07:14,260
of date and they need us to upgrade it

00:07:10,870 --> 00:07:16,270
and the problem with this is that if you

00:07:14,260 --> 00:07:18,250
agree if you say like yes I will

00:07:16,270 --> 00:07:21,190
maintain this project the next question

00:07:18,250 --> 00:07:24,160
you'll get is this one how long is it

00:07:21,190 --> 00:07:27,520
going to take to ship this small change

00:07:24,160 --> 00:07:32,980
and of course the next comment will be

00:07:27,520 --> 00:07:34,990
because I need it by end of day today so

00:07:32,980 --> 00:07:36,700
you'll have to quickly assess code

00:07:34,990 --> 00:07:39,370
quality before you commit to maintaining

00:07:36,700 --> 00:07:42,490
this project sometimes you'll be able to

00:07:39,370 --> 00:07:43,720
say no and sometimes you'll be able well

00:07:42,490 --> 00:07:46,960
you'll have to maintain it

00:07:43,720 --> 00:07:49,750
which will suck but that's what part two

00:07:46,960 --> 00:07:52,420
is all about part two builds on top of

00:07:49,750 --> 00:07:53,950
part one and uses some of the tools that

00:07:52,420 --> 00:07:56,860
I'm going to talk about in the first

00:07:53,950 --> 00:07:58,960
part of the presentation and I'll

00:07:56,860 --> 00:08:02,980
address this question how can we

00:07:58,960 --> 00:08:07,060
gradually pay off technical debt all

00:08:02,980 --> 00:08:10,420
right so let's get started part one you

00:08:07,060 --> 00:08:13,930
get to work next week and boss comes up

00:08:10,420 --> 00:08:16,540
to you yeah Carl quit so he's the only

00:08:13,930 --> 00:08:19,990
one who knows how to maintain the legacy

00:08:16,540 --> 00:08:20,590
system it can't be that hard go figure

00:08:19,990 --> 00:08:24,070
it out

00:08:20,590 --> 00:08:27,850
and of course Dilbert ends up stuck in

00:08:24,070 --> 00:08:30,730
the tar pit in our in our industry it

00:08:27,850 --> 00:08:34,120
looks like this it can be that hard it's

00:08:30,730 --> 00:08:36,760
a ruby project right ruby was the sign

00:08:34,120 --> 00:08:41,020
wood programmer happiness in mine so it

00:08:36,760 --> 00:08:44,500
should make you happy right well yes

00:08:41,020 --> 00:08:48,550
that was the vision but then we came

00:08:44,500 --> 00:08:52,680
along and used Ruby and some projects

00:08:48,550 --> 00:08:52,680
just don't spark Joey okay

00:08:52,960 --> 00:08:59,990
so how can we quickly assess code

00:08:56,150 --> 00:09:00,680
quality well there are a bunch of ways

00:08:59,990 --> 00:09:03,230
to do it

00:09:00,680 --> 00:09:05,450
the main ones are you pay someone to do

00:09:03,230 --> 00:09:09,590
it for you and you can use code climate

00:09:05,450 --> 00:09:13,370
code is C codes een or you can use a

00:09:09,590 --> 00:09:14,990
free and open source gem to do it so for

00:09:13,370 --> 00:09:17,540
the sake of this talk I'm going to talk

00:09:14,990 --> 00:09:19,910
about open source gems because even the

00:09:17,540 --> 00:09:22,010
paid services use some of these gems to

00:09:19,910 --> 00:09:25,220
give you the score for the application

00:09:22,010 --> 00:09:27,800
and these gems do a bunch of things for

00:09:25,220 --> 00:09:29,960
you they do static code analysis so that

00:09:27,800 --> 00:09:32,120
means that they read every single line

00:09:29,960 --> 00:09:35,120
of code in your application and then

00:09:32,120 --> 00:09:37,460
they assign a complexity score to every

00:09:35,120 --> 00:09:40,040
single file so you can see the

00:09:37,460 --> 00:09:43,910
complexity in every prod Embree for the

00:09:40,040 --> 00:09:45,560
total complexity in the project then

00:09:43,910 --> 00:09:48,230
there are tools that will calculate code

00:09:45,560 --> 00:09:52,070
coverage for you they will tell you your

00:09:48,230 --> 00:09:55,850
test suite exercises 80% of all your

00:09:52,070 --> 00:09:57,770
code base and then there are tools that

00:09:55,850 --> 00:10:00,110
know all the code smells that are out

00:09:57,770 --> 00:10:02,660
there in the world and they will compare

00:10:00,110 --> 00:10:04,640
a known database of code smells would

00:10:02,660 --> 00:10:08,360
your code base to tell you how smelly

00:10:04,640 --> 00:10:10,250
your code is and then you'll get a good

00:10:08,360 --> 00:10:14,360
picture of software quality and your

00:10:10,250 --> 00:10:16,670
project and of course what is software

00:10:14,360 --> 00:10:20,990
quality anyway I think we don't talk

00:10:16,670 --> 00:10:22,970
about this enough so unfortunately there

00:10:20,990 --> 00:10:24,950
are hundreds of definitions out there

00:10:22,970 --> 00:10:27,860
there are books written about this their

00:10:24,950 --> 00:10:31,160
models written about this and I'm going

00:10:27,860 --> 00:10:34,370
to focus only on a few definitions the

00:10:31,160 --> 00:10:36,860
first one is by the I Triple E that says

00:10:34,370 --> 00:10:39,770
it's the degree to which a system

00:10:36,860 --> 00:10:43,160
component or process meets implicit and

00:10:39,770 --> 00:10:45,110
explicit requirements ensure there was a

00:10:43,160 --> 00:10:47,390
committee that got together and came up

00:10:45,110 --> 00:10:50,450
with this definition which is totally

00:10:47,390 --> 00:10:53,390
accurate but next week you need to

00:10:50,450 --> 00:10:57,680
maintain the project so this to me

00:10:53,390 --> 00:10:59,270
sounds like it works as expected but

00:10:57,680 --> 00:11:02,300
this is not software quality in my

00:10:59,270 --> 00:11:05,120
opinion because I need to maintain it so

00:11:02,300 --> 00:11:10,700
to me it is it works as expected

00:11:05,120 --> 00:11:13,130
it is not a pain to maintain it now to

00:11:10,700 --> 00:11:19,310
see another definition we have the ISO

00:11:13,130 --> 00:11:22,220
91 26-1 please don't fall asleep it's

00:11:19,310 --> 00:11:24,220
very short which talks about five

00:11:22,220 --> 00:11:27,610
different aspects of software quality

00:11:24,220 --> 00:11:29,750
and I want to focus on maintainability

00:11:27,610 --> 00:11:32,720
because that's what we're going to do

00:11:29,750 --> 00:11:34,430
we're going to maintain the project so

00:11:32,720 --> 00:11:36,740
when I talk about maintainability I like

00:11:34,430 --> 00:11:39,050
to talk about two aspects and the order

00:11:36,740 --> 00:11:42,140
here is important I think the first one

00:11:39,050 --> 00:11:44,720
that I care about is code coverage like

00:11:42,140 --> 00:11:48,920
how many statements in my application

00:11:44,720 --> 00:11:51,170
are executed by my test suite now this

00:11:48,920 --> 00:11:55,190
is key because it will affect the next

00:11:51,170 --> 00:11:57,080
one which is code quality now I will

00:11:55,190 --> 00:12:00,800
find complex files and I will find

00:11:57,080 --> 00:12:02,450
smelly files and I'll be refactoring

00:12:00,800 --> 00:12:04,700
those files and if I'm going to do that

00:12:02,450 --> 00:12:07,190
I need tests to make sure that the

00:12:04,700 --> 00:12:10,250
behavior remains the same way while I

00:12:07,190 --> 00:12:12,200
improve code quality now the good news

00:12:10,250 --> 00:12:16,040
is that in Ruby we have a bunch of tools

00:12:12,200 --> 00:12:19,400
out there that are awesome and are very

00:12:16,040 --> 00:12:22,339
easy to set up so for code coverage we

00:12:19,400 --> 00:12:24,740
have simple cough simple cough will tell

00:12:22,339 --> 00:12:28,790
us how many statements are exercised

00:12:24,740 --> 00:12:30,589
with our test suite now yeah the problem

00:12:28,790 --> 00:12:33,050
is that it won't tell us if the tests

00:12:30,589 --> 00:12:36,110
are good or bad it will just tell us if

00:12:33,050 --> 00:12:39,470
they're exercised which is something

00:12:36,110 --> 00:12:42,470
it's more than nothing okay you can load

00:12:39,470 --> 00:12:44,660
it like this and then load it and your

00:12:42,470 --> 00:12:46,820
spec helper like this and here you're

00:12:44,660 --> 00:12:49,880
telling simple cop to track every single

00:12:46,820 --> 00:12:51,380
Ruby file and to only load simple curve

00:12:49,880 --> 00:12:54,770
when there is an environment variable

00:12:51,380 --> 00:12:58,010
called coverage now you want to do that

00:12:54,770 --> 00:13:00,260
because this will affect a little bit of

00:12:58,010 --> 00:13:03,770
the performance in the test suite so you

00:13:00,260 --> 00:13:05,510
want to load it only sometimes and then

00:13:03,770 --> 00:13:08,180
you can run it and this will generate a

00:13:05,510 --> 00:13:13,130
nice-looking HTML report that looks like

00:13:08,180 --> 00:13:16,040
this now this tells us that 82% of this

00:13:13,130 --> 00:13:18,880
projects statements are executed by our

00:13:16,040 --> 00:13:20,830
test suite and it's awesome it's a

00:13:18,880 --> 00:13:24,040
signal that tells us something about the

00:13:20,830 --> 00:13:26,260
project now for code quality is not as

00:13:24,040 --> 00:13:29,230
simple they're a bunch of tools out

00:13:26,260 --> 00:13:32,460
there there's flog there's Flay there's

00:13:29,230 --> 00:13:35,230
reek there's metric foo ruby critic

00:13:32,460 --> 00:13:38,890
attractor and they're more and more that

00:13:35,230 --> 00:13:40,600
I obviously haven't listed here now for

00:13:38,890 --> 00:13:43,030
the talk I decided to go with ruby

00:13:40,600 --> 00:13:45,760
critic I like this one because it's

00:13:43,030 --> 00:13:47,890
currently maintained it is active and it

00:13:45,760 --> 00:13:52,500
uses other gems that are out there like

00:13:47,890 --> 00:13:55,570
flog Flay reek and recently simple cuff

00:13:52,500 --> 00:14:01,180
now a couple concepts that Ruby critic

00:13:55,570 --> 00:14:04,090
uses a churn and complexity now churn is

00:14:01,180 --> 00:14:06,400
interesting it it tells us how many

00:14:04,090 --> 00:14:09,760
times a file has been changed since the

00:14:06,400 --> 00:14:11,770
beginning of the project now for that we

00:14:09,760 --> 00:14:14,230
have get so gate will tell us how many

00:14:11,770 --> 00:14:18,460
time of files is a file has been

00:14:14,230 --> 00:14:20,830
committed we can quickly do this to find

00:14:18,460 --> 00:14:27,550
out that default dot RB has been changed

00:14:20,830 --> 00:14:29,740
three times and then turn count is 3 now

00:14:27,550 --> 00:14:31,930
this metric by itself is not that

00:14:29,740 --> 00:14:34,390
interesting it will tell us like how

00:14:31,930 --> 00:14:36,700
many or what are the files have have

00:14:34,390 --> 00:14:39,520
been changed the most I'm sure there is

00:14:36,700 --> 00:14:40,960
some value there but it becomes more

00:14:39,520 --> 00:14:45,550
interesting when you combine it with

00:14:40,960 --> 00:14:48,160
complexity now complexity Ruby Critic

00:14:45,550 --> 00:14:51,820
uses flog to calculate complexity of a

00:14:48,160 --> 00:14:55,180
ruby file flog is a gem by Ryan Davis

00:14:51,820 --> 00:14:57,580
from Seattle RB and it's been around for

00:14:55,180 --> 00:15:01,180
more than 10 years you can use it like

00:14:57,580 --> 00:15:04,030
this basically you say flog food RB and

00:15:01,180 --> 00:15:08,980
it will tell you yes food that RB has a

00:15:04,030 --> 00:15:12,280
score of 10.8 it's like okay what is

00:15:08,980 --> 00:15:15,310
that good is it bad well I don't know

00:15:12,280 --> 00:15:17,440
let's look at it what it does is it

00:15:15,310 --> 00:15:19,810
assigns a numeric value to every

00:15:17,440 --> 00:15:22,540
operation and every statement in the

00:15:19,810 --> 00:15:25,810
methods of all the methods in the module

00:15:22,540 --> 00:15:30,280
so an assignment is one point to an eval

00:15:25,810 --> 00:15:32,230
as 6.0 and so on and so forth so here we

00:15:30,280 --> 00:15:34,840
know that

00:15:32,230 --> 00:15:38,050
like City points for this project or for

00:15:34,840 --> 00:15:40,060
this file is ten point eight again by

00:15:38,050 --> 00:15:43,150
itself is a metric that will tell you

00:15:40,060 --> 00:15:46,030
yes this is not a complex file but then

00:15:43,150 --> 00:15:49,390
when you combine it with churn it starts

00:15:46,030 --> 00:15:51,640
to become super interesting and Michael

00:15:49,390 --> 00:15:54,010
feathers has written about this a lot

00:15:51,640 --> 00:15:56,020
and then Sandi Metz went on to write

00:15:54,010 --> 00:16:00,130
another article which is super

00:15:56,020 --> 00:16:03,310
interesting and they basically talked

00:16:00,130 --> 00:16:06,010
about this graph this graph has in the

00:16:03,310 --> 00:16:09,490
y-axis the complexity and in the x-axis

00:16:06,010 --> 00:16:11,890
churn so if you have a file that has

00:16:09,490 --> 00:16:14,020
changed two times but the complexity is

00:16:11,890 --> 00:16:18,070
a hundred thousand you'll have it in the

00:16:14,020 --> 00:16:19,570
upper left quadrant but if the

00:16:18,070 --> 00:16:22,720
complexity is a hundred and it has

00:16:19,570 --> 00:16:25,930
changed changed 27 times you'll find it

00:16:22,720 --> 00:16:27,580
in the lower right quadrant now by

00:16:25,930 --> 00:16:29,500
itself this doesn't really tell you much

00:16:27,580 --> 00:16:31,750
but when you see all the files it

00:16:29,500 --> 00:16:34,960
becomes super interesting so we're gonna

00:16:31,750 --> 00:16:37,990
see an example which will be critic you

00:16:34,960 --> 00:16:42,130
can install it like this and run it like

00:16:37,990 --> 00:16:47,020
this and you'll get an HTML report that

00:16:42,130 --> 00:16:50,890
looks like this it's like okay so what

00:16:47,020 --> 00:16:52,990
do I do with this like well by itself

00:16:50,890 --> 00:16:55,420
it's hard to interpret this graph is it

00:16:52,990 --> 00:16:57,120
the tarp it is it a dumpster fire I

00:16:55,420 --> 00:17:00,340
don't know

00:16:57,120 --> 00:17:04,570
well let's go and see the left side

00:17:00,340 --> 00:17:06,850
first we have these GPA pie graph or

00:17:04,570 --> 00:17:10,390
basically every file in the project gets

00:17:06,850 --> 00:17:11,950
graded from A to F for those of you not

00:17:10,390 --> 00:17:15,910
familiar with the American grading

00:17:11,950 --> 00:17:20,230
system think about 100% to 0% for a test

00:17:15,910 --> 00:17:23,050
score so for calculating the GPA it uses

00:17:20,230 --> 00:17:25,450
reek for this coat the coat smells and

00:17:23,050 --> 00:17:27,160
it uses flog for the complexity off the

00:17:25,450 --> 00:17:30,640
file and then it merges all that

00:17:27,160 --> 00:17:32,020
information into one single score so if

00:17:30,640 --> 00:17:34,210
you look at that you can be like well

00:17:32,020 --> 00:17:38,200
yeah 60 percent of the project is either

00:17:34,210 --> 00:17:42,040
a B or an a but then 25% of it is either

00:17:38,200 --> 00:17:44,539
a D or an F so still undecided whether

00:17:42,040 --> 00:17:46,770
this is a good project or a bad project

00:17:44,539 --> 00:17:48,510
if you look at the other graph you'll

00:17:46,770 --> 00:17:50,820
see that churn versus complexity and

00:17:48,510 --> 00:17:54,450
every single file in the project that's

00:17:50,820 --> 00:17:56,100
plotted there now again this is a lot of

00:17:54,450 --> 00:17:58,279
information what a lot of points and I

00:17:56,100 --> 00:18:01,020
don't really know what to do with it so

00:17:58,279 --> 00:18:03,600
it helps me to look at it this way I

00:18:01,020 --> 00:18:06,690
look at all the files and then I imagine

00:18:03,600 --> 00:18:10,470
this asymptote that helps me divide the

00:18:06,690 --> 00:18:13,529
graph in four different quadrants now

00:18:10,470 --> 00:18:15,750
the first one is the best quadrant it's

00:18:13,529 --> 00:18:17,730
like this is the good place you want

00:18:15,750 --> 00:18:22,230
your files to be low turn and low

00:18:17,730 --> 00:18:27,299
complexity then in the upper left

00:18:22,230 --> 00:18:29,190
quadrant you'll have file yeah yeah yeah

00:18:27,299 --> 00:18:32,549
that's what it is I'm just trying to be

00:18:29,190 --> 00:18:34,710
honest here these are files that

00:18:32,549 --> 00:18:38,159
probably work they're super complex but

00:18:34,710 --> 00:18:40,440
nobody touches them so Sandi Metz has

00:18:38,159 --> 00:18:43,860
definitely put it the right in a better

00:18:40,440 --> 00:18:47,240
way than I have she says if the code

00:18:43,860 --> 00:18:49,770
never changes it's not costing us money

00:18:47,240 --> 00:18:51,500
so not your priority if you're gonna go

00:18:49,770 --> 00:18:53,880
refactor Thanks

00:18:51,500 --> 00:18:56,880
now in the lower right quadrant you're

00:18:53,880 --> 00:18:59,250
gonna find files that change a lot but

00:18:56,880 --> 00:19:01,409
they're super simple so you can look at

00:18:59,250 --> 00:19:03,990
them and understand them and they're

00:19:01,409 --> 00:19:06,059
obviously not costing you money these

00:19:03,990 --> 00:19:08,720
are files like configuration files or

00:19:06,059 --> 00:19:12,330
translation files or something that is

00:19:08,720 --> 00:19:14,130
not your priority to be honest now it

00:19:12,330 --> 00:19:17,460
gets really interesting when you get to

00:19:14,130 --> 00:19:19,649
the upper right quadrant so yeah these

00:19:17,460 --> 00:19:22,830
modules are complex and they change a

00:19:19,649 --> 00:19:25,740
lot and Michael feathers says that

00:19:22,830 --> 00:19:30,510
sometimes a class becomes so complex

00:19:25,740 --> 00:19:32,610
that refactoring seems too difficult so

00:19:30,510 --> 00:19:35,340
you know you need to refactor them and

00:19:32,610 --> 00:19:38,130
you want to but every time you go and

00:19:35,340 --> 00:19:42,390
try to do it you just lose time and you

00:19:38,130 --> 00:19:43,830
can't do it and one single sprint so you

00:19:42,390 --> 00:19:46,860
know you need to do it but you just

00:19:43,830 --> 00:19:49,730
don't have the time now when you look at

00:19:46,860 --> 00:19:52,470
this graph you can answer the question

00:19:49,730 --> 00:19:55,580
are you getting into a tar pit

00:19:52,470 --> 00:19:57,200
is it a dumpster fire or is it a truly

00:19:55,580 --> 00:19:59,870
maintainable project

00:19:57,200 --> 00:20:01,520
and sometimes will be easier than others

00:19:59,870 --> 00:20:03,500
sometimes you'll look at the graph and

00:20:01,520 --> 00:20:05,690
see all the files in the upper right

00:20:03,500 --> 00:20:07,970
quadrant and you'll be like yeah no

00:20:05,690 --> 00:20:13,580
thank you I don't want to work on this

00:20:07,970 --> 00:20:16,300
project so so far we saw a couple things

00:20:13,580 --> 00:20:19,760
for code quality and code coverage and

00:20:16,300 --> 00:20:22,010
these things are signals in my book you

00:20:19,760 --> 00:20:26,260
have one signal for code coverage and

00:20:22,010 --> 00:20:30,020
you have another signal for complexity

00:20:26,260 --> 00:20:33,530
now they're both analyzing the same code

00:20:30,020 --> 00:20:36,380
base so I think it's normal it's like a

00:20:33,530 --> 00:20:38,660
good idea to put it all in one graph and

00:20:36,380 --> 00:20:40,700
say for all of those files

00:20:38,660 --> 00:20:45,680
you know the complexity and you know the

00:20:40,700 --> 00:20:48,380
code coverage and then I was like what

00:20:45,680 --> 00:20:50,990
if we could combine the two signals into

00:20:48,380 --> 00:20:55,070
one to gather insights from our code

00:20:50,990 --> 00:20:59,270
base and I like to call this distinct

00:20:55,070 --> 00:21:03,110
score now of course the higher distinct

00:20:59,270 --> 00:21:05,840
score the worse the file write and the

00:21:03,110 --> 00:21:09,290
stink score is a function of code

00:21:05,840 --> 00:21:11,900
quality and code coverage and code

00:21:09,290 --> 00:21:15,860
quality is composed of complexity and

00:21:11,900 --> 00:21:18,200
smells so the main idea behind this

00:21:15,860 --> 00:21:21,380
formula and this new metric is to say

00:21:18,200 --> 00:21:25,160
files which lag tests should be

00:21:21,380 --> 00:21:27,410
penalized and by penalized I mean you

00:21:25,160 --> 00:21:30,230
should pay special attention to these

00:21:27,410 --> 00:21:34,010
files that are super complex and lack

00:21:30,230 --> 00:21:36,440
code coverage it's easier to see this

00:21:34,010 --> 00:21:39,920
with an example let's say we have food

00:21:36,440 --> 00:21:43,340
RB and we no complexity and we know

00:21:39,920 --> 00:21:46,130
smells so we multiply multiplexity time

00:21:43,340 --> 00:21:49,190
smells and we get a hundred smell points

00:21:46,130 --> 00:21:52,790
let's say then we have bar that RB with

00:21:49,190 --> 00:21:55,730
the same metrics so if you look at them

00:21:52,790 --> 00:21:59,810
side by side you're like well both of

00:21:55,730 --> 00:22:03,290
them have a hundred smell points so foo

00:21:59,810 --> 00:22:05,570
and bar are equally stinky yeah okay you

00:22:03,290 --> 00:22:07,580
can say that because you don't know code

00:22:05,570 --> 00:22:09,650
coverage but what if you knew code

00:22:07,580 --> 00:22:12,680
coverage for all of those files

00:22:09,650 --> 00:22:15,650
and you knew that food that our be has

00:22:12,680 --> 00:22:18,920
0% code coverage there's no test for

00:22:15,650 --> 00:22:22,040
this file but then bar is perfect they

00:22:18,920 --> 00:22:25,309
have perfect code coverage you do the

00:22:22,040 --> 00:22:28,850
same math but then you add a factor that

00:22:25,309 --> 00:22:31,550
penalizes the smell points and then you

00:22:28,850 --> 00:22:35,390
come up with the stink score so now you

00:22:31,550 --> 00:22:39,200
see food our B is a stinkier than bar

00:22:35,390 --> 00:22:43,130
that are being and that's the conclusion

00:22:39,200 --> 00:22:45,140
you can come with come up with now of

00:22:43,130 --> 00:22:47,600
course this is something that you can do

00:22:45,140 --> 00:22:51,530
manually and we've done it a lot in

00:22:47,600 --> 00:22:53,720
faster video we should we would

00:22:51,530 --> 00:22:55,580
basically take a project look at the

00:22:53,720 --> 00:22:57,260
code complexity and then look at the

00:22:55,580 --> 00:22:59,929
code coverage and then manually

00:22:57,260 --> 00:23:03,050
cross-reference the data to produce a

00:22:59,929 --> 00:23:06,230
code audit report for our clients which

00:23:03,050 --> 00:23:09,890
was super tedious and you can do it but

00:23:06,230 --> 00:23:13,100
we're programmers right so we came up

00:23:09,890 --> 00:23:16,490
with a calculator and who better than a

00:23:13,100 --> 00:23:20,300
skunk to ask about whether a file is

00:23:16,490 --> 00:23:22,490
think you're than other right so yeah

00:23:20,300 --> 00:23:25,640
this is a stink score calculator and

00:23:22,490 --> 00:23:28,010
what it does is it builds on top of Ruby

00:23:25,640 --> 00:23:30,559
critic so that's why what I was saying

00:23:28,010 --> 00:23:33,200
like 95% of the code in this talk was

00:23:30,559 --> 00:23:35,480
written by someone else skunk is just

00:23:33,200 --> 00:23:39,290
gluing metrics that are already out

00:23:35,480 --> 00:23:42,679
there like simple cops metric and ruby

00:23:39,290 --> 00:23:47,630
critics metrics you can install it like

00:23:42,679 --> 00:23:50,120
this and then run it like this and so

00:23:47,630 --> 00:23:53,030
far the report is not pretty it looks

00:23:50,120 --> 00:23:57,140
like this but the most important part

00:23:53,030 --> 00:24:00,910
are the files here you get a sorted list

00:23:57,140 --> 00:24:04,880
of files from the stinkiest file to the

00:24:00,910 --> 00:24:07,309
least stinky file so here you can see

00:24:04,880 --> 00:24:10,400
that get dot RB is the stinkiest file

00:24:07,309 --> 00:24:13,070
out there now at the end of the list you

00:24:10,400 --> 00:24:15,950
also get a summary of all the numbers

00:24:13,070 --> 00:24:17,840
now stink score todo is not that

00:24:15,950 --> 00:24:20,330
important because the more features you

00:24:17,840 --> 00:24:22,370
add the more it's going to get to be

00:24:20,330 --> 00:24:23,650
higher so it's only going to grow as you

00:24:22,370 --> 00:24:25,990
add features to your project

00:24:23,650 --> 00:24:28,330
the one thing that I want to focus on is

00:24:25,990 --> 00:24:30,160
distinct score average which is

00:24:28,330 --> 00:24:34,440
basically the total divided by the

00:24:30,160 --> 00:24:34,440
number of modules in your project a

00:24:34,620 --> 00:24:40,420
little bit about how I came up with this

00:24:37,300 --> 00:24:44,290
number ruby critic has this cost method

00:24:40,420 --> 00:24:47,860
for every module now this formula uses

00:24:44,290 --> 00:24:50,740
the smells that come from reek and it

00:24:47,860 --> 00:24:53,740
calculates a cost for every smell that

00:24:50,740 --> 00:24:57,130
is in the Ruby file and then it uses

00:24:53,740 --> 00:25:00,850
complexity and it divides it by a magic

00:24:57,130 --> 00:25:03,700
factor of 25 which I don't know why it's

00:25:00,850 --> 00:25:08,370
25 but it does that and then it comes up

00:25:03,700 --> 00:25:08,370
with a total score for the file

00:25:08,580 --> 00:25:15,220
what skunk does is it uses the cost

00:25:11,590 --> 00:25:18,910
value and then it brings in the penalty

00:25:15,220 --> 00:25:22,540
factor so if there's perfect coverage to

00:25:18,910 --> 00:25:25,300
stink score is gonna be the cost but if

00:25:22,540 --> 00:25:27,460
the code coverage is at 20% then the

00:25:25,300 --> 00:25:29,980
penalty factor is gonna be 80 so it's

00:25:27,460 --> 00:25:31,830
the stink score is gonna be 80 times

00:25:29,980 --> 00:25:36,600
cost

00:25:31,830 --> 00:25:40,030
now a few warnings about skunk it is pre

00:25:36,600 --> 00:25:44,650
1.0 and until last night there was a

00:25:40,030 --> 00:25:49,450
major error in the formula so feel free

00:25:44,650 --> 00:25:50,950
to go check it out but anyway I'll tell

00:25:49,450 --> 00:25:54,520
you if you ask me later I'll tell you

00:25:50,950 --> 00:25:56,590
what it was and you need to run rate

00:25:54,520 --> 00:25:59,170
tests what coverage set to true before

00:25:56,590 --> 00:26:02,470
Iran skunk because skunk will basically

00:25:59,170 --> 00:26:04,900
load the coverage result set JSON file

00:26:02,470 --> 00:26:08,559
from simple cob to know which files are

00:26:04,900 --> 00:26:11,140
covered and which are not and definitely

00:26:08,559 --> 00:26:13,179
open to feedback I think this is just

00:26:11,140 --> 00:26:17,590
the beginning of a conversation about

00:26:13,179 --> 00:26:19,450
code quality and technical debt alright

00:26:17,590 --> 00:26:21,580
so right now we have three metrics we

00:26:19,450 --> 00:26:23,950
have metrics for maintainability that

00:26:21,580 --> 00:26:26,860
are code coverage quality and distinct

00:26:23,950 --> 00:26:28,240
score so the good news is that now we

00:26:26,860 --> 00:26:31,540
know where we stand

00:26:28,240 --> 00:26:34,720
we know where we are in the map of

00:26:31,540 --> 00:26:36,640
technical debt which is good right

00:26:34,720 --> 00:26:37,960
because if you don't know where you are

00:26:36,640 --> 00:26:41,710
you don't know where you need to go to

00:26:37,960 --> 00:26:43,290
and these are the La Brea Tar Pits yes

00:26:41,710 --> 00:26:46,720
that is correct

00:26:43,290 --> 00:26:49,750
all right so part two is all about using

00:26:46,720 --> 00:26:53,820
what we learn from part one and guiding

00:26:49,750 --> 00:26:56,170
us in paying off technical debt because

00:26:53,820 --> 00:26:57,910
let's say we are in that in that

00:26:56,170 --> 00:27:00,430
situation where we can't really turn

00:26:57,910 --> 00:27:03,340
down the project so we really like our

00:27:00,430 --> 00:27:05,170
job we liked our we liked our benefits

00:27:03,340 --> 00:27:10,480
and we just need to maintain the project

00:27:05,170 --> 00:27:13,180
okay so okay I need to ship features and

00:27:10,480 --> 00:27:16,810
I need to ship patches and I also want

00:27:13,180 --> 00:27:20,160
to ship improvements to the code quality

00:27:16,810 --> 00:27:23,500
right so where do we begin

00:27:20,160 --> 00:27:32,230
well a good way to start is by removing

00:27:23,500 --> 00:27:35,860
files we all love that right okay cool

00:27:32,230 --> 00:27:39,730
so one way to go about this is to use a

00:27:35,860 --> 00:27:42,640
gem like cover band it's a gem that you

00:27:39,730 --> 00:27:44,110
can install and run in production and it

00:27:42,640 --> 00:27:47,440
will basically track every single

00:27:44,110 --> 00:27:53,470
statement that it gets exercised by real

00:27:47,440 --> 00:27:55,330
production usage all right and then

00:27:53,470 --> 00:27:55,960
you'll get an HTML report that looks

00:27:55,330 --> 00:27:57,940
like this

00:27:55,960 --> 00:28:00,220
which is basically the same as simple

00:27:57,940 --> 00:28:03,250
cough the only difference is that this

00:28:00,220 --> 00:28:06,370
this information comes from real

00:28:03,250 --> 00:28:07,960
production usage and this will guide you

00:28:06,370 --> 00:28:09,790
in removing files that are no longer

00:28:07,960 --> 00:28:14,590
used or methods that are no longer

00:28:09,790 --> 00:28:17,770
called cool another way to go reducing

00:28:14,590 --> 00:28:20,560
our sting score is to refactor complex

00:28:17,770 --> 00:28:22,870
files yeah awesome

00:28:20,560 --> 00:28:25,660
we inherited the project and we all want

00:28:22,870 --> 00:28:27,640
to do that right so we go back to the

00:28:25,660 --> 00:28:31,240
graph and we see all these files up

00:28:27,640 --> 00:28:33,900
there and we're like okay these are

00:28:31,240 --> 00:28:35,350
great candidates for a refactoring right

00:28:33,900 --> 00:28:37,960
cool

00:28:35,350 --> 00:28:39,790
but there are four files there and I

00:28:37,960 --> 00:28:43,380
have no idea which one I want to

00:28:39,790 --> 00:28:47,410
refactor first and that's when I say

00:28:43,380 --> 00:28:51,220
churn versus complexity is not enough to

00:28:47,410 --> 00:28:53,780
prioritize your refactoring efforts and

00:28:51,220 --> 00:28:56,690
that's when the stink score table comes

00:28:53,780 --> 00:28:59,600
into play you can basically look at all

00:28:56,690 --> 00:29:02,179
the files and you can find the ones that

00:28:59,600 --> 00:29:03,799
do have code coverage and you can find

00:29:02,179 --> 00:29:05,900
that of course you don't want to

00:29:03,799 --> 00:29:08,420
refactor the files that have 0% code

00:29:05,900 --> 00:29:11,510
coverage that would be a nightmare I

00:29:08,420 --> 00:29:14,540
don't do that but you do want to

00:29:11,510 --> 00:29:17,090
refactor the ones that have 60% or more

00:29:14,540 --> 00:29:18,950
in terms of code coverage in this

00:29:17,090 --> 00:29:23,120
particular case we see that gate dot RB

00:29:18,950 --> 00:29:25,700
has 60% code coverage so we say okay it

00:29:23,120 --> 00:29:30,200
is the stinkiest file and it has decent

00:29:25,700 --> 00:29:33,530
code coverage so you go to the graph you

00:29:30,200 --> 00:29:36,350
find it and then yes it's time for the

00:29:33,530 --> 00:29:38,870
manual work of looking at the file and

00:29:36,350 --> 00:29:41,299
analyzing what are the things that you

00:29:38,870 --> 00:29:45,200
can refactor so one of the things you

00:29:41,299 --> 00:29:47,059
can do is split the file in two separate

00:29:45,200 --> 00:29:49,880
files let's say that you found two

00:29:47,059 --> 00:29:51,860
responsibilities and get dot RB not only

00:29:49,880 --> 00:29:56,480
that's a fetch data but it also

00:29:51,860 --> 00:29:58,820
calculates statistics so what you do is

00:29:56,480 --> 00:30:02,059
you refactor it into two files which

00:29:58,820 --> 00:30:05,120
moves basically it gets rid of get RB

00:30:02,059 --> 00:30:11,900
and it moves the two new files to the

00:30:05,120 --> 00:30:16,700
lower lower left quadrant awesome you

00:30:11,900 --> 00:30:20,169
paid off technical debt but how much how

00:30:16,700 --> 00:30:23,059
much did you improve the project and and

00:30:20,169 --> 00:30:25,790
it's it's hard to communicate this right

00:30:23,059 --> 00:30:27,710
because you can spend a lot of time

00:30:25,790 --> 00:30:29,419
paying off technical debt and then you

00:30:27,710 --> 00:30:32,360
go to your boss and you say yeah I paid

00:30:29,419 --> 00:30:35,570
off some technical debt or I paid off a

00:30:32,360 --> 00:30:38,809
lot of technical debt we need a numeric

00:30:35,570 --> 00:30:40,760
value for this it's it's like a new

00:30:38,809 --> 00:30:44,299
language to communicate how much

00:30:40,760 --> 00:30:46,400
technical debt you paid off so the good

00:30:44,299 --> 00:30:49,010
thing is that skunk has a feature for

00:30:46,400 --> 00:30:51,470
this you can compare your own branch

00:30:49,010 --> 00:30:54,410
again semester and basically compare

00:30:51,470 --> 00:30:56,510
compare the stink score average to tell

00:30:54,410 --> 00:31:01,340
you that you actually improved the

00:30:56,510 --> 00:31:04,009
project by 10% so now you can go to your

00:31:01,340 --> 00:31:05,960
or to your team and say look in this

00:31:04,009 --> 00:31:09,970
sprint I spent some time refactoring the

00:31:05,960 --> 00:31:09,970
file and I made it ten percent better

00:31:10,629 --> 00:31:17,059
another great way to pay off technical

00:31:13,730 --> 00:31:19,190
debt is to write tests of course that

00:31:17,059 --> 00:31:23,899
way you are reducing the penalty factor

00:31:19,190 --> 00:31:26,629
for every file you can go to the stable

00:31:23,899 --> 00:31:29,840
again and look at the files that have 0%

00:31:26,629 --> 00:31:32,690
code coverage now the first two files

00:31:29,840 --> 00:31:34,669
out there with 0% code coverage are just

00:31:32,690 --> 00:31:37,309
test files so we ignore them you

00:31:34,669 --> 00:31:39,980
shouldn't even be there but anyway they

00:31:37,309 --> 00:31:42,019
are so we picked the the third one that

00:31:39,980 --> 00:31:45,769
is the rape test that gets called all

00:31:42,019 --> 00:31:49,669
the time and what we can do is write

00:31:45,769 --> 00:31:52,070
some tests for it and then do skunk - be

00:31:49,669 --> 00:31:56,269
master and get the code coverage

00:31:52,070 --> 00:31:59,899
percentage well to be perfectly honest

00:31:56,269 --> 00:32:02,929
this is not ready yet but the road map

00:31:59,899 --> 00:32:05,360
would be to do something like this it

00:32:02,929 --> 00:32:07,940
gets a little tricky because simple cop

00:32:05,360 --> 00:32:11,690
tracks everything in our result said dot

00:32:07,940 --> 00:32:12,769
JSON file so it's in the road map but it

00:32:11,690 --> 00:32:16,580
would be awesome to be able to

00:32:12,769 --> 00:32:18,409
communicate this like that the important

00:32:16,580 --> 00:32:20,240
thing is that now you have a stink score

00:32:18,409 --> 00:32:23,960
average that you can keep track over

00:32:20,240 --> 00:32:26,720
time and basically every few weeks you

00:32:23,960 --> 00:32:29,899
can run the report and say well we're

00:32:26,720 --> 00:32:32,600
actually pretty stable or well no we are

00:32:29,899 --> 00:32:34,340
actually going up exponentially so

00:32:32,600 --> 00:32:37,879
there's something wrong in our

00:32:34,340 --> 00:32:42,860
engineering practices we need to be more

00:32:37,879 --> 00:32:45,909
aware of what we're doing the main goal

00:32:42,860 --> 00:32:48,649
of this presentation is to talk about

00:32:45,909 --> 00:32:51,710
measuring technical debt and mesh

00:32:48,649 --> 00:32:54,950
measuring the efforts that we do to pay

00:32:51,710 --> 00:32:56,990
off technical debt it's so hard to go to

00:32:54,950 --> 00:33:01,190
a non-technical client and tell them

00:32:56,990 --> 00:33:03,080
yeah we paid off some technical debt if

00:33:01,190 --> 00:33:05,749
we can have a metric to tell them we

00:33:03,080 --> 00:33:08,269
paid off 20% of your technical debt it

00:33:05,749 --> 00:33:12,019
gets a lot easier to communicate the

00:33:08,269 --> 00:33:14,299
value of our engineering skills and if

00:33:12,019 --> 00:33:15,260
you don't like skunk that's ok you can

00:33:14,299 --> 00:33:19,309
just use simple

00:33:15,260 --> 00:33:23,840
and Ruby critic to measure the quality

00:33:19,309 --> 00:33:26,059
of the the codebase and of course like

00:33:23,840 --> 00:33:30,010
any tool out there this could be used

00:33:26,059 --> 00:33:34,700
for evil yes and please don't do that

00:33:30,010 --> 00:33:37,429
the goal is not to power your next witch

00:33:34,700 --> 00:33:40,700
hunt or to help you point fingers at

00:33:37,429 --> 00:33:43,760
your co-workers that's the worst thing

00:33:40,700 --> 00:33:46,340
you can do the goal of this tool is to

00:33:43,760 --> 00:33:49,309
be your comm pass getting out of the tar

00:33:46,340 --> 00:33:51,320
pit it will tell you what a numeric

00:33:49,309 --> 00:33:58,730
value whether you're actually making it

00:33:51,320 --> 00:34:01,340
better or making it worse all right

00:33:58,730 --> 00:34:05,210
thank you so much for your attention if

00:34:01,340 --> 00:34:08,030
you have any ideas or any questions that

00:34:05,210 --> 00:34:10,669
you want to discuss in the Ruby project

00:34:08,030 --> 00:34:14,470
is all open source and you can just go

00:34:10,669 --> 00:34:16,760
to a faster would be skunk and github

00:34:14,470 --> 00:34:19,520
thanks a lot to Humble Apps for

00:34:16,760 --> 00:34:22,070
sponsoring me to be here I wouldn't be

00:34:19,520 --> 00:34:26,090
able to speak at rubyconf without their

00:34:22,070 --> 00:34:29,889
help we are hiring and we are 100%

00:34:26,090 --> 00:34:32,899
remote so feel free to check us out and

00:34:29,889 --> 00:34:34,850
yeah if you have any questions and we

00:34:32,899 --> 00:34:37,010
don't get to talk in the conference feel

00:34:34,850 --> 00:34:40,129
free to reach out to me via Twitter I'm

00:34:37,010 --> 00:34:45,989
always eager to get more ideas about the

00:34:40,129 --> 00:34:48,130
stink score and skunk thank you

00:34:45,989 --> 00:35:02,179
[Applause]

00:34:48,130 --> 00:35:02,179

YouTube URL: https://www.youtube.com/watch?v=ZyU6K6eR-_A


