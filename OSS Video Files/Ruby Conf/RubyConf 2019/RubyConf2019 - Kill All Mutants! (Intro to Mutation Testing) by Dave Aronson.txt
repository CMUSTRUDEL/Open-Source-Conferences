Title: RubyConf2019 - Kill All Mutants! (Intro to Mutation Testing) by Dave Aronson
Publication date: 2019-12-04
Playlist: RubyConf 2019
Description: 
	RubyConf2019 - Kill All Mutants! (Intro to Mutation Testing) by Dave Aronson

How good are your tests? Would they still pass if the tested code was changed much? If so, you may have a problem!

Mutation testing helps reveal these cases. It runs your unit tests, using many slightly altered versions of each method, called "mutants". If a mutant passes (or "survives") all of the method's tests, that implies certain flaws in your code, your tests, or both!

Come find out how to use this advanced technique to discover problems lurking in your code and/or tests.

#rubyconf2019 #confreaks
Captions: 
	00:00:04,190 --> 00:00:10,269
[Music]

00:00:11,860 --> 00:00:18,410
okay good afternoon

00:00:13,790 --> 00:00:20,900
Nashville Dave Aronson the t-rex oh Coto

00:00:18,410 --> 00:00:25,310
Soros LLC and I'm here to teach you to

00:00:20,900 --> 00:00:28,490
kill mutants but first I think we need

00:00:25,310 --> 00:00:31,250
to level set some expectations so call

00:00:28,490 --> 00:00:33,230
this an advanced talk might be a little

00:00:31,250 --> 00:00:34,760
bit misleading to call it an

00:00:33,230 --> 00:00:37,670
introductory talk though it would be

00:00:34,760 --> 00:00:40,940
even more misleading what this is is an

00:00:37,670 --> 00:00:43,280
introduction to and advanced talk I mean

00:00:40,940 --> 00:00:45,469
it's an advanced topic so if you're

00:00:43,280 --> 00:00:48,260
already well-versed in mutation testing

00:00:45,469 --> 00:00:50,360
I won't be too offended if you go seek

00:00:48,260 --> 00:00:52,550
better learning opportunities but I'd

00:00:50,360 --> 00:00:56,270
still rather you stick around so you can

00:00:52,550 --> 00:00:58,969
correct my mistakes later in private and

00:00:56,270 --> 00:01:01,820
I mentioned mistakes because I'm not an

00:00:58,969 --> 00:01:04,879
expert on mutation testing one of the

00:01:01,820 --> 00:01:07,100
dirty little secrets of public speaking

00:01:04,879 --> 00:01:08,840
is you don't have to be an expert you

00:01:07,100 --> 00:01:11,090
just have to know a little more than

00:01:08,840 --> 00:01:14,780
your audience and be able to convey it

00:01:11,090 --> 00:01:16,369
to them and mutation testing is still so

00:01:14,780 --> 00:01:19,100
rare that most developers have never

00:01:16,369 --> 00:01:21,740
even heard of it so let's start with the

00:01:19,100 --> 00:01:25,880
basics what on Infinite Earths is

00:01:21,740 --> 00:01:28,580
mutation testing in our universe that of

00:01:25,880 --> 00:01:31,099
software development not comic books of

00:01:28,580 --> 00:01:34,459
course it's a software testing technique

00:01:31,099 --> 00:01:38,300
surprise you might look at the name and

00:01:34,459 --> 00:01:40,459
think well it's obviously about testing

00:01:38,300 --> 00:01:44,119
the mutations used in genetic genetic

00:01:40,459 --> 00:01:48,259
algorithms but no it's about testing our

00:01:44,119 --> 00:01:52,989
code and also our unit test suite by

00:01:48,259 --> 00:01:56,869
using mutations its primary benefit is

00:01:52,989 --> 00:02:00,700
to help ensure that our tests are strict

00:01:56,869 --> 00:02:03,200
by finding the gaps in our test suite

00:02:00,700 --> 00:02:05,509
that let our code get away with

00:02:03,200 --> 00:02:08,119
unintended behavior and once we find

00:02:05,509 --> 00:02:11,239
these gaps we can either add tests or

00:02:08,119 --> 00:02:11,989
expand and improve our tests to close up

00:02:11,239 --> 00:02:15,050
those gaps

00:02:11,989 --> 00:02:18,049
this lack of strictness comes mainly

00:02:15,050 --> 00:02:20,620
from lack of tests or poorly written

00:02:18,049 --> 00:02:22,480
tests or poorly maintained tests

00:02:20,620 --> 00:02:25,239
didn't keep pace with changes in the

00:02:22,480 --> 00:02:27,610
code speaking of which it can also help

00:02:25,239 --> 00:02:30,700
improve our code by helping to ensure

00:02:27,610 --> 00:02:33,840
that our code is meaningful by which I

00:02:30,700 --> 00:02:36,819
mean that any little change to the code

00:02:33,840 --> 00:02:40,390
should result in a noticeable change in

00:02:36,819 --> 00:02:43,989
its behavior lack of meaning generally

00:02:40,390 --> 00:02:47,379
comes from code being unreachable or

00:02:43,989 --> 00:02:51,220
redundant or otherwise without any real

00:02:47,379 --> 00:02:53,950
effect once we find code like that we

00:02:51,220 --> 00:02:56,470
can either make it meaningful if it if

00:02:53,950 --> 00:02:58,170
that fits our original intention or just

00:02:56,470 --> 00:03:00,489
get rid of it

00:02:58,170 --> 00:03:03,609
mutation testing puts these two together

00:03:00,489 --> 00:03:05,950
by ensuring first that our code is

00:03:03,609 --> 00:03:08,799
meaningful so that the change it made

00:03:05,950 --> 00:03:10,780
had a noticeable effect and then that

00:03:08,799 --> 00:03:14,230
our tests are strict enough to notice

00:03:10,780 --> 00:03:16,629
that change and fail now not all the

00:03:14,230 --> 00:03:20,670
tests have to fail but each change

00:03:16,629 --> 00:03:23,440
should make at least one test fail

00:03:20,670 --> 00:03:26,410
mutation testing does all this by

00:03:23,440 --> 00:03:28,540
mutating copies of our code hence the

00:03:26,410 --> 00:03:31,359
name and it does this with the intention

00:03:28,540 --> 00:03:35,950
of creating test failures otherwise it's

00:03:31,359 --> 00:03:38,769
yes otherwise known as false so mutation

00:03:35,950 --> 00:03:42,220
testing can be categorized as a fault

00:03:38,769 --> 00:03:45,190
based testing technique and this means

00:03:42,220 --> 00:03:47,349
it is sort of related to something you

00:03:45,190 --> 00:03:50,739
might already be familiar with chaos

00:03:47,349 --> 00:03:53,889
monkey from Netflix just like chaos

00:03:50,739 --> 00:03:57,669
monkey helps Netflix find flaws in their

00:03:53,889 --> 00:04:00,699
error recovery process mutation testing

00:03:57,669 --> 00:04:04,419
helps us find flaws in our test suite

00:04:00,699 --> 00:04:06,449
and in our code but the way mutation

00:04:04,419 --> 00:04:10,900
testing works is sort of upside down

00:04:06,449 --> 00:04:12,730
from how chaos monkey works chaos monkey

00:04:10,900 --> 00:04:16,359
does a lot of things but it's best known

00:04:12,730 --> 00:04:19,599
for injecting faults such as dropped

00:04:16,359 --> 00:04:23,050
connections into Netflix's production

00:04:19,599 --> 00:04:25,570
network and if all goes well in the

00:04:23,050 --> 00:04:28,090
sense that Netflix is customers don't

00:04:25,570 --> 00:04:32,349
notice then they know that their error

00:04:28,090 --> 00:04:33,879
recovery is working well mutation

00:04:32,349 --> 00:04:37,209
testing however

00:04:33,879 --> 00:04:39,099
injects semantics changes it doesn't

00:04:37,209 --> 00:04:41,649
know whether these changes are going to

00:04:39,099 --> 00:04:44,229
result in faults or not but we certainly

00:04:41,649 --> 00:04:48,099
hope they all will but that's up to the

00:04:44,229 --> 00:04:50,800
test suite it puts these changes into

00:04:48,099 --> 00:04:53,770
copies of our code not our actual

00:04:50,800 --> 00:04:59,139
network and it does this all in our test

00:04:53,770 --> 00:05:02,439
environment not production and lastly if

00:04:59,139 --> 00:05:05,169
all goes well in the sense that our unit

00:05:02,439 --> 00:05:06,639
tests all still pass that does not mean

00:05:05,169 --> 00:05:09,849
everything's great that means there is a

00:05:06,639 --> 00:05:16,419
problem remember each change should make

00:05:09,849 --> 00:05:19,599
at least one unit test fail but there

00:05:16,419 --> 00:05:22,599
are some drawbacks so it is not quite a

00:05:19,599 --> 00:05:25,089
silver bullet as we developers know

00:05:22,599 --> 00:05:26,800
there's no such thing besides which

00:05:25,089 --> 00:05:30,369
those are for killing werewolves not

00:05:26,800 --> 00:05:32,199
mutants the first drawback is that it's

00:05:30,369 --> 00:05:36,969
rather hard labor on the CPU and

00:05:32,199 --> 00:05:39,459
therefore usually fairly slow we won't

00:05:36,969 --> 00:05:44,169
want to mean a mutation test our entire

00:05:39,459 --> 00:05:46,509
code base on every save may be over a

00:05:44,169 --> 00:05:49,059
lunch break for a smallish system or

00:05:46,509 --> 00:05:52,089
overnight or over a weekend for a larger

00:05:49,059 --> 00:05:55,209
one fortunately most tools include an

00:05:52,089 --> 00:05:57,879
incremental mode so we can just check

00:05:55,209 --> 00:06:01,329
what has changed since last time we ran

00:05:57,879 --> 00:06:03,819
our mutation testing that we might be

00:06:01,329 --> 00:06:06,490
able to do on every save for a very

00:06:03,819 --> 00:06:09,819
small system or at least over a much

00:06:06,490 --> 00:06:12,189
shorter break for other ones its CPU

00:06:09,819 --> 00:06:15,659
intensive nature can also really run up

00:06:12,189 --> 00:06:19,059
our bills on cloud-based systems such as

00:06:15,659 --> 00:06:22,629
AWS or Asscher or edge or or however you

00:06:19,059 --> 00:06:24,479
pronounce it another drawback is that it

00:06:22,629 --> 00:06:27,879
is not at all a beginner friendly

00:06:24,479 --> 00:06:30,490
technique mainly it tells us that making

00:06:27,879 --> 00:06:33,579
this particular change to the code made

00:06:30,490 --> 00:06:37,119
no difference whatsoever to our test

00:06:33,579 --> 00:06:40,269
results what does that mean

00:06:37,119 --> 00:06:42,939
it takes a lot of interpretation to

00:06:40,269 --> 00:06:46,180
figure out what a mutant is trying to

00:06:42,939 --> 00:06:49,390
tell us their accent is virus right

00:06:46,180 --> 00:06:51,430
and they almost is incoherent it does

00:06:49,390 --> 00:06:53,350
Assam B's but with a much larger

00:06:51,430 --> 00:06:58,630
vocabulary so they're not always on

00:06:53,350 --> 00:07:01,330
about Briggs they're usually trying to

00:06:58,630 --> 00:07:05,830
tell us that our code is meaningless or

00:07:01,330 --> 00:07:07,360
our tests are lacks or both but it can

00:07:05,830 --> 00:07:11,140
be very difficult to figure out exactly

00:07:07,360 --> 00:07:14,290
how and worse yet often it's a false

00:07:11,140 --> 00:07:16,690
alarm the mutation might not have made

00:07:14,290 --> 00:07:19,840
any tests fail but it didn't really make

00:07:16,690 --> 00:07:21,760
any actual difference either it can

00:07:19,840 --> 00:07:22,480
still take quite a lot of time to figure

00:07:21,760 --> 00:07:25,330
that out

00:07:22,480 --> 00:07:27,550
and even if a mutation did make a

00:07:25,330 --> 00:07:29,880
difference there's still quite a lot of

00:07:27,550 --> 00:07:32,920
code that we shouldn't bother to test

00:07:29,880 --> 00:07:36,070
like if you have a debugging statement

00:07:32,920 --> 00:07:38,950
that says value of X is and then the

00:07:36,070 --> 00:07:41,650
value of x that constant part the string

00:07:38,950 --> 00:07:44,260
the value of x is is going to get

00:07:41,650 --> 00:07:47,380
mutated even though we don't really care

00:07:44,260 --> 00:07:50,500
about that fortunately most tools do

00:07:47,380 --> 00:07:52,780
have a way to say don't bother mutating

00:07:50,500 --> 00:07:55,750
this line or even this whole function or

00:07:52,780 --> 00:07:57,640
method whatever but that's usually done

00:07:55,750 --> 00:08:01,120
with comments which can then clutter up

00:07:57,640 --> 00:08:03,760
the code and make it less readable now

00:08:01,120 --> 00:08:07,300
that we've seen some of the major pros

00:08:03,760 --> 00:08:11,110
and cons what exactly does mutation

00:08:07,300 --> 00:08:13,690
testing do and how so let's peel back

00:08:11,110 --> 00:08:17,890
one layer of the onion and look at a

00:08:13,690 --> 00:08:20,980
high level view first our chosen

00:08:17,890 --> 00:08:24,520
mutation testing tool will break our

00:08:20,980 --> 00:08:28,000
code apart into pieces to test usually

00:08:24,520 --> 00:08:30,640
in Ruby or other object-oriented

00:08:28,000 --> 00:08:34,270
languages this will be our methods and

00:08:30,640 --> 00:08:38,469
then for each one it will try to find

00:08:34,270 --> 00:08:41,260
the tests for that method if the tool

00:08:38,469 --> 00:08:43,780
can't find any then some of them will

00:08:41,260 --> 00:08:45,730
use the entire test suite which is

00:08:43,780 --> 00:08:48,340
horribly inefficient leads to a lot more

00:08:45,730 --> 00:08:51,070
false alarms but most will just skip

00:08:48,340 --> 00:08:53,950
that one method and go on better yet a

00:08:51,070 --> 00:08:58,360
lot of them will warn us so we know we

00:08:53,950 --> 00:08:59,889
should go add some tests assuming that

00:08:58,360 --> 00:09:04,059
we're not going to skip the

00:08:59,889 --> 00:09:06,399
particularly tool makes the mutants and

00:09:04,059 --> 00:09:09,970
to do that it looks closely at exactly

00:09:06,399 --> 00:09:12,819
how it can be changed and for each tiny

00:09:09,970 --> 00:09:15,790
little way that method can be changed

00:09:12,819 --> 00:09:19,029
the tool will make one mutant with that

00:09:15,790 --> 00:09:22,029
change in it and once it's done creating

00:09:19,029 --> 00:09:24,489
all the mutants it can from one

00:09:22,029 --> 00:09:26,470
particular method then it will iterate

00:09:24,489 --> 00:09:28,230
over the list and now we get to the

00:09:26,470 --> 00:09:32,139
heart of the matter

00:09:28,230 --> 00:09:35,769
for each mutant derived from a given

00:09:32,139 --> 00:09:40,239
method our tool will run each of that

00:09:35,769 --> 00:09:42,189
methods unit tests but using each mutant

00:09:40,239 --> 00:09:46,619
in turn instead of the original function

00:09:42,189 --> 00:09:49,509
if we get down to one test that fails

00:09:46,619 --> 00:09:51,519
that is called killing the mutant and

00:09:49,509 --> 00:09:54,850
that's exactly what we want it's a good

00:09:51,519 --> 00:09:56,769
thing it means that first the code was

00:09:54,850 --> 00:09:59,619
meaningful enough that the tiny little

00:09:56,769 --> 00:10:02,109
change it made to create that mutant did

00:09:59,619 --> 00:10:05,019
have a noticeable effect on the behavior

00:10:02,109 --> 00:10:07,959
and secondly that at least one of the

00:10:05,019 --> 00:10:14,319
tests was strict enough to spot that

00:10:07,959 --> 00:10:17,220
difference and fail after it's after

00:10:14,319 --> 00:10:20,589
that mutant has made that test fail

00:10:17,220 --> 00:10:23,019
generally the tool will stop running any

00:10:20,589 --> 00:10:25,149
more tests against that mutant we don't

00:10:23,019 --> 00:10:27,519
care how many more it could make fail

00:10:25,149 --> 00:10:31,119
like so much in computer science we only

00:10:27,519 --> 00:10:33,879
care about ones and zeros well then move

00:10:31,119 --> 00:10:35,470
on to the next mutant or if if that was

00:10:33,879 --> 00:10:39,639
the last one from that function or

00:10:35,470 --> 00:10:42,309
method move on to the next method but if

00:10:39,639 --> 00:10:46,480
a mutant survives all those tests

00:10:42,309 --> 00:10:49,480
meaning it lets them all pass then it

00:10:46,480 --> 00:10:52,720
has the superpower of mimicry skilled

00:10:49,480 --> 00:10:55,179
enough to fool our tests and this

00:10:52,720 --> 00:10:58,029
usually means that our code is

00:10:55,179 --> 00:11:01,149
meaningless or our tests are lacks or

00:10:58,029 --> 00:11:04,629
both and now it's up to us to figure out

00:11:01,149 --> 00:11:06,669
how now let's peel back another layer

00:11:04,629 --> 00:11:09,629
and look at some of the technical

00:11:06,669 --> 00:11:12,940
details of exactly how it does this

00:11:09,629 --> 00:11:15,910
first our tool parses our code

00:11:12,940 --> 00:11:19,000
into an abstract syntax tree I know some

00:11:15,910 --> 00:11:20,980
of those boxes maybe you rather small to

00:11:19,000 --> 00:11:24,600
read from back there but we don't need

00:11:20,980 --> 00:11:28,000
to understand this ast in detail and

00:11:24,600 --> 00:11:31,150
also some tools do it slightly

00:11:28,000 --> 00:11:34,510
differently they work against bytecode

00:11:31,150 --> 00:11:36,460
rather than an AST some proof of

00:11:34,510 --> 00:11:39,310
concepts and such may even work on

00:11:36,460 --> 00:11:42,280
actual raw text but most of them use an

00:11:39,310 --> 00:11:44,980
AST so let's just roll with that after

00:11:42,280 --> 00:11:48,580
our tool creates an AST then it

00:11:44,980 --> 00:11:52,630
traverses it looking for sub trees or

00:11:48,580 --> 00:11:56,230
branches if you will to represent our

00:11:52,630 --> 00:11:58,470
methods and after finding them then it

00:11:56,230 --> 00:12:01,000
reach them basically like I said before

00:11:58,470 --> 00:12:05,410
looking for their tests and running them

00:12:01,000 --> 00:12:08,290
but how does it look for the tests that

00:12:05,410 --> 00:12:11,530
usually relies at least partly on us

00:12:08,290 --> 00:12:13,210
developers either annotating our tests

00:12:11,530 --> 00:12:16,710
or following some kind of naming

00:12:13,210 --> 00:12:19,750
convention but this is sometimes

00:12:16,710 --> 00:12:23,140
augmented maybe even completely replaced

00:12:19,750 --> 00:12:25,300
by the tool looking at what tests call

00:12:23,140 --> 00:12:27,360
what methods though this can get a

00:12:25,300 --> 00:12:32,680
little tricky if the method is not

00:12:27,360 --> 00:12:34,900
called directly from the test after the

00:12:32,680 --> 00:12:38,110
tool has found all the methods tests

00:12:34,900 --> 00:12:39,760
then assuming it's not going to skip

00:12:38,110 --> 00:12:40,270
this method because of lack of tests or

00:12:39,760 --> 00:12:44,500
whatever

00:12:40,270 --> 00:12:49,530
it makes the mutants so how do we make

00:12:44,500 --> 00:12:52,480
mutants from an AST it four versus that

00:12:49,530 --> 00:12:55,210
subtree just like it did to the whole

00:12:52,480 --> 00:12:58,360
thing but now instead of looking for

00:12:55,210 --> 00:13:01,450
even smaller sub trees like twigs or

00:12:58,360 --> 00:13:03,760
something to extract it's looking for

00:13:01,450 --> 00:13:05,950
nodes where it can change something or

00:13:03,760 --> 00:13:12,220
you can replace that with another kind

00:13:05,950 --> 00:13:14,980
of node for each one of those that it

00:13:12,220 --> 00:13:17,500
finds and for each way that it can

00:13:14,980 --> 00:13:24,449
change that node then it'll make a fresh

00:13:17,500 --> 00:13:27,750
copy of that methods ast sub tree

00:13:24,449 --> 00:13:30,699
for instance suppose our tool has

00:13:27,750 --> 00:13:33,639
started traversing that AST I showed

00:13:30,699 --> 00:13:36,970
earlier and has gotten down to this not

00:13:33,639 --> 00:13:40,810
equal comparison by following those red

00:13:36,970 --> 00:13:43,329
arrows there for each way it could

00:13:40,810 --> 00:13:46,810
change that node it would make a fresh

00:13:43,329 --> 00:13:49,870
copy of this entire subtree with only

00:13:46,810 --> 00:13:53,139
that node changed in that particular way

00:13:49,870 --> 00:13:55,629
and once it's done doing that for that

00:13:53,139 --> 00:13:58,810
node it would continue traversing the

00:13:55,629 --> 00:14:01,439
whole rest of the subtree and do

00:13:58,810 --> 00:14:04,990
likewise for the rest of the nodes so

00:14:01,439 --> 00:14:07,449
I've said a lot about changes it makes

00:14:04,990 --> 00:14:08,939
changes to this and so forth but what

00:14:07,449 --> 00:14:12,790
kind of changes are we talking about

00:14:08,939 --> 00:14:15,339
there are quite a lot it could change

00:14:12,790 --> 00:14:17,819
a mathematical or logical or bitwise

00:14:15,339 --> 00:14:20,529
operator from one to another in

00:14:17,819 --> 00:14:23,439
languages and situations where it can do

00:14:20,529 --> 00:14:26,410
so it could even substitute one of a

00:14:23,439 --> 00:14:28,000
different category for instance in Ruby

00:14:26,410 --> 00:14:32,350
we can treat pretty much anything as a

00:14:28,000 --> 00:14:37,600
boolean so X plus y could be changed to

00:14:32,350 --> 00:14:42,130
X and y or X or Y it could change the

00:14:37,600 --> 00:14:44,170
order of operands in situations where

00:14:42,130 --> 00:14:45,790
that matters most of them are smart

00:14:44,170 --> 00:14:48,339
enough not to bother doing that with

00:14:45,790 --> 00:14:51,310
plus but it'll do that with minus and

00:14:48,339 --> 00:14:54,310
divide an exponentiation it could change

00:14:51,310 --> 00:14:56,550
a comparison from one to another it

00:14:54,310 --> 00:15:00,959
could change you could insert or remove

00:14:56,550 --> 00:15:05,290
rather a logical mathematical or bitwise

00:15:00,959 --> 00:15:07,720
negation it can change a constant or

00:15:05,290 --> 00:15:12,339
variable or expression or function call

00:15:07,720 --> 00:15:14,889
to a completely different value possibly

00:15:12,339 --> 00:15:18,100
even one of a different and even

00:15:14,889 --> 00:15:21,610
incompatible type such as changing a

00:15:18,100 --> 00:15:26,079
number two if I may quote sméagol

00:15:21,610 --> 00:15:29,500
stringing out a nothing it can remove

00:15:26,079 --> 00:15:32,829
entire lines of code it could remove a

00:15:29,500 --> 00:15:36,400
condition or a loop control it could

00:15:32,829 --> 00:15:40,630
scramble or truncate arguments in

00:15:36,400 --> 00:15:43,540
method call or a method declaration it

00:15:40,630 --> 00:15:45,910
can replace a methods entire body with

00:15:43,540 --> 00:15:47,980
just a constant or either of the

00:15:45,910 --> 00:15:50,260
arguments or raising a deliberate error

00:15:47,980 --> 00:15:53,860
or nothing at all if the language

00:15:50,260 --> 00:15:55,630
permits like Ruby does there are many

00:15:53,860 --> 00:15:59,500
many more kinds of changes it could make

00:15:55,630 --> 00:16:01,420
but I think you get the idea by now now

00:15:59,500 --> 00:16:03,640
from here on in the process if there

00:16:01,420 --> 00:16:05,770
aren't any other low-level details I

00:16:03,640 --> 00:16:08,490
want to add so let's look at some

00:16:05,770 --> 00:16:11,190
examples we'll start with an easy one

00:16:08,490 --> 00:16:16,440
suppose we have a method like this

00:16:11,190 --> 00:16:19,870
pretty simple but think about what a

00:16:16,440 --> 00:16:22,030
mutant made from this might return

00:16:19,870 --> 00:16:24,370
because that's what our unit tests are

00:16:22,030 --> 00:16:26,680
probably going to be looking at and

00:16:24,370 --> 00:16:29,620
there are lots and lots but mainly you

00:16:26,680 --> 00:16:33,250
could return all kinds of values like

00:16:29,620 --> 00:16:35,170
any of these expressions or constants

00:16:33,250 --> 00:16:38,680
and many more but I had to stop

00:16:35,170 --> 00:16:42,720
somewhere now suppose we have only one

00:16:38,680 --> 00:16:46,570
test like so this is a pretty bad test

00:16:42,720 --> 00:16:49,540
but even so most of the mutants from

00:16:46,570 --> 00:16:51,720
that previous slide would get killed the

00:16:49,540 --> 00:16:54,760
ones shown here and crossed out green

00:16:51,720 --> 00:16:57,370
the ones returning constants are quite

00:16:54,760 --> 00:17:00,040
unlikely to match you know for is not a

00:16:57,370 --> 00:17:01,950
very common constant to just randomly

00:17:00,040 --> 00:17:04,720
come up with or have any significance

00:17:01,950 --> 00:17:06,970
subtracting gets a zero dividing gets us

00:17:04,720 --> 00:17:09,850
one returning other either argument

00:17:06,970 --> 00:17:13,180
alone gets us to and even the ones that

00:17:09,850 --> 00:17:16,089
deliberately raise an error or even

00:17:13,180 --> 00:17:20,640
accidentally raise an error will at

00:17:16,089 --> 00:17:23,820
least make the test not pass but

00:17:20,640 --> 00:17:27,459
addition multiplication and

00:17:23,820 --> 00:17:29,560
exponentiation in the reverse order also

00:17:27,459 --> 00:17:32,460
get us the right answer and will

00:17:29,560 --> 00:17:35,740
therefore survive that particular test

00:17:32,460 --> 00:17:37,930
and we know this because we run a

00:17:35,740 --> 00:17:40,330
mutation testing tool and it gives us a

00:17:37,930 --> 00:17:44,200
report that looks something roughly like

00:17:40,330 --> 00:17:46,570
this the exact words and format and

00:17:44,200 --> 00:17:48,670
amount of context and so forth vary

00:17:46,570 --> 00:17:49,540
widely depending upon which tool we use

00:17:48,670 --> 00:17:52,190
but

00:17:49,540 --> 00:17:55,270
information should be roughly the same

00:17:52,190 --> 00:17:58,220
and to unpack what that information is

00:17:55,270 --> 00:18:01,910
it's telling us that if we changed the

00:17:58,220 --> 00:18:05,330
method called power which is in file

00:18:01,910 --> 00:18:08,930
demo RB starting at line 42 in any of

00:18:05,330 --> 00:18:12,710
four different ways then all its unit

00:18:08,930 --> 00:18:15,680
tests would still pass and then that

00:18:12,710 --> 00:18:17,420
those four ways are to change line 42 to

00:18:15,680 --> 00:18:19,850
swap the order of the arguments to

00:18:17,420 --> 00:18:22,040
change line 43 to change the

00:18:19,850 --> 00:18:25,400
exponentiation to addition or

00:18:22,040 --> 00:18:29,150
multiplication or to change line 43 to

00:18:25,400 --> 00:18:33,290
swap the order of the operands pretty

00:18:29,150 --> 00:18:35,960
straightforward right so what is this

00:18:33,290 --> 00:18:39,740
set of surviving mutants trying to tell

00:18:35,960 --> 00:18:42,470
us a good start to figuring that out is

00:18:39,740 --> 00:18:46,160
to ask ourselves how are these mutants

00:18:42,470 --> 00:18:49,040
surviving what is it about done that

00:18:46,160 --> 00:18:51,620
lets all our unit tests or in this case

00:18:49,040 --> 00:18:55,790
our one and only unit test still pass

00:18:51,620 --> 00:18:57,560
the usual answer is that they give the

00:18:55,790 --> 00:19:02,540
same result or have the same side

00:18:57,560 --> 00:19:05,960
effects as our original method and to

00:19:02,540 --> 00:19:08,570
determine how that happens one useful

00:19:05,960 --> 00:19:11,810
technique is to look at at least one

00:19:08,570 --> 00:19:15,140
mutant together with at least one of the

00:19:11,810 --> 00:19:18,280
unit tests it passes so let's start with

00:19:15,140 --> 00:19:21,830
the plus mutant looking at that change

00:19:18,280 --> 00:19:27,440
now it's changing the exponentiation 2

00:19:21,830 --> 00:19:30,200
plus makes it fairly clear that this

00:19:27,440 --> 00:19:32,660
mutant is surviving because 2 to the

00:19:30,200 --> 00:19:38,390
second power what we expect to have

00:19:32,660 --> 00:19:40,400
happen equals 2 plus to the other both 4

00:19:38,390 --> 00:19:45,020
I assume you all know that much basic

00:19:40,400 --> 00:19:47,510
math so how do we kill this mutant the

00:19:45,020 --> 00:19:49,340
main way you kill a mutant is to make

00:19:47,510 --> 00:19:52,760
sure you have a test you can either

00:19:49,340 --> 00:19:56,690
change the existing test or an existing

00:19:52,760 --> 00:20:00,470
test or add a new test with arguments

00:19:56,690 --> 00:20:02,360
such that the two expressions come out

00:20:00,470 --> 00:20:02,960
differently in other words we just need

00:20:02,360 --> 00:20:06,500
to

00:20:02,960 --> 00:20:11,540
assert that some X to the Y equals Z

00:20:06,500 --> 00:20:14,810
such that X plus y is not Z easy enough

00:20:11,540 --> 00:20:17,090
for instance we could add or change the

00:20:14,810 --> 00:20:22,670
test to say this that 2 to the third is

00:20:17,090 --> 00:20:27,110
8 2 plus 3 is 5 which is not 8

00:20:22,670 --> 00:20:31,250
so that kills the plus mutant 2 times 3

00:20:27,110 --> 00:20:35,750
is 6 which is also not 8 so it also

00:20:31,250 --> 00:20:37,810
happens to kill the x mutant and 3

00:20:35,750 --> 00:20:42,320
squared is 9

00:20:37,810 --> 00:20:45,440
again not 8 so it kills the argument

00:20:42,320 --> 00:20:48,200
swapping mutants as well now we didn't

00:20:45,440 --> 00:20:49,460
have to necessarily attack them all at

00:20:48,200 --> 00:20:52,760
once we don't need to be a superhero

00:20:49,460 --> 00:20:56,480
about it we could have said instead as

00:20:52,760 --> 00:20:59,240
an intermediate step that 2 to the 4th

00:20:56,480 --> 00:21:02,470
is 16 that would have killed the plus

00:20:59,240 --> 00:21:05,330
and times mutants without killing the

00:21:02,470 --> 00:21:08,300
argument swapping mutants quite yet and

00:21:05,330 --> 00:21:11,740
then we could have added this or changed

00:21:08,300 --> 00:21:15,110
the test to this to kill those as well

00:21:11,740 --> 00:21:19,070
now this may make mutation testing sound

00:21:15,110 --> 00:21:22,310
rather simple but this was a nearly

00:21:19,070 --> 00:21:25,550
trivial example so it's pretty easy to

00:21:22,310 --> 00:21:29,150
think up new arguments to make all the

00:21:25,550 --> 00:21:31,820
reasonable mutants return a different

00:21:29,150 --> 00:21:33,890
value from the original method so

00:21:31,820 --> 00:21:36,860
there's lots of ways to skin that Fleur

00:21:33,890 --> 00:21:39,710
again so let's look at them more complex

00:21:36,860 --> 00:21:44,480
example suppose we have a method to send

00:21:39,710 --> 00:21:49,430
a message like so this method send

00:21:44,480 --> 00:21:53,060
message loops over and over sending in

00:21:49,430 --> 00:21:55,910
each chunk as much as send bytes can

00:21:53,060 --> 00:21:59,300
handle in one shot picking up where it

00:21:55,910 --> 00:22:03,200
left off each time until the whole thing

00:21:59,300 --> 00:22:05,300
has been sent now a mutation testing

00:22:03,200 --> 00:22:08,000
tool can make lots and lots of different

00:22:05,300 --> 00:22:11,030
mutants out of this but what a

00:22:08,000 --> 00:22:15,629
particular interest would be this that's

00:22:11,030 --> 00:22:18,460
an example of removing a loop control

00:22:15,629 --> 00:22:21,940
now suppose that this mutant does indeed

00:22:18,460 --> 00:22:24,850
survive our test suite which consists

00:22:21,940 --> 00:22:26,879
mainly of this there's a little more to

00:22:24,850 --> 00:22:30,249
it that I'm not going to show quite yet

00:22:26,879 --> 00:22:33,549
mainly setting the size in constructing

00:22:30,249 --> 00:22:37,869
message but even without seeing those

00:22:33,549 --> 00:22:41,970
parts there is something that the

00:22:37,869 --> 00:22:46,889
survival of the non looping mutant is

00:22:41,970 --> 00:22:49,539
trying to tell us and that is that if a

00:22:46,889 --> 00:22:54,129
mutant that only goes through this loop

00:22:49,539 --> 00:22:58,230
body once acts the same as far as our

00:22:54,129 --> 00:23:00,909
test suite can tell as the original code

00:22:58,230 --> 00:23:03,100
then our tests are not making our

00:23:00,909 --> 00:23:09,190
original code go through that loop body

00:23:03,100 --> 00:23:11,830
more than once the question then is okay

00:23:09,190 --> 00:23:13,509
what does that mean and you'll find that

00:23:11,830 --> 00:23:15,999
interpreting what mutants are trying to

00:23:13,509 --> 00:23:20,230
tell you involves a lot of asking

00:23:15,999 --> 00:23:24,129
yourself over and over recursively what

00:23:20,230 --> 00:23:26,799
does that mean in this case it means

00:23:24,129 --> 00:23:29,440
we're not testing sending a message

00:23:26,799 --> 00:23:33,700
bigger than what send bytes can handle

00:23:29,440 --> 00:23:35,559
in one chunk so most likely we're just

00:23:33,700 --> 00:23:38,409
not testing sending a big enough message

00:23:35,559 --> 00:23:42,429
for instance we see here that are

00:23:38,409 --> 00:23:46,299
maximum chunk size which is what send

00:23:42,429 --> 00:23:48,669
bytes can handle in one shot is 10,000

00:23:46,299 --> 00:23:52,389
bytes but we're testing with just a tiny

00:23:48,669 --> 00:23:53,619
little three byte message so of course

00:23:52,389 --> 00:23:56,879
it's only gonna go through that loop

00:23:53,619 --> 00:24:00,009
once so how do we fix that

00:23:56,879 --> 00:24:02,139
should be pretty easy assuming there's

00:24:00,009 --> 00:24:04,059
nothing weird about the code preventing

00:24:02,139 --> 00:24:06,759
us from doing so we just take the

00:24:04,059 --> 00:24:09,970
maximum chunk size as declared

00:24:06,759 --> 00:24:14,739
presumably publicly add one create that

00:24:09,970 --> 00:24:18,070
big message then try to send it but

00:24:14,739 --> 00:24:20,830
perhaps to paraphrase Shakespeare The

00:24:18,070 --> 00:24:23,169
Fault dear Nashville is not in our tests

00:24:20,830 --> 00:24:26,679
but in our code that these mutants are

00:24:23,169 --> 00:24:27,430
survivors perhaps we did try sending

00:24:26,679 --> 00:24:29,500
with the

00:24:27,430 --> 00:24:31,930
largest permissible message out of a

00:24:29,500 --> 00:24:35,290
predefined set of messages or at least

00:24:31,930 --> 00:24:38,110
message sizes for instance here we have

00:24:35,290 --> 00:24:42,700
small and large messages and we tried

00:24:38,110 --> 00:24:44,830
sending a large and yet the non looping

00:24:42,700 --> 00:24:46,180
mutant still survives what could

00:24:44,830 --> 00:24:49,180
possibly be wrong with that

00:24:46,180 --> 00:24:53,800
is there anything wrong with that what's

00:24:49,180 --> 00:24:57,430
it trying to tell us now now it's trying

00:24:53,800 --> 00:25:00,460
to tell us that a version of send

00:24:57,430 --> 00:25:03,390
message with the looping removed will do

00:25:00,460 --> 00:25:07,620
the job just fine this is an example of

00:25:03,390 --> 00:25:11,140
mutation testing finding redundant code

00:25:07,620 --> 00:25:13,570
if we also strip out all the other stuff

00:25:11,140 --> 00:25:16,210
that was needed only to support the

00:25:13,570 --> 00:25:18,250
looping then it boils down to this and

00:25:16,210 --> 00:25:21,580
now it's really clear that the ultimate

00:25:18,250 --> 00:25:24,160
message is that send message may well be

00:25:21,580 --> 00:25:28,360
entirely redundant we could possibly

00:25:24,160 --> 00:25:31,240
just use send bytes directly now I say

00:25:28,360 --> 00:25:34,300
may well be redundant not is redundant

00:25:31,240 --> 00:25:37,120
because in real-world code there may be

00:25:34,300 --> 00:25:39,550
some logging and error handling and

00:25:37,120 --> 00:25:43,270
whatnot that we need to put in send

00:25:39,550 --> 00:25:47,230
message but at the very least be looping

00:25:43,270 --> 00:25:51,820
was redundant so what do we do about it

00:25:47,230 --> 00:25:53,920
we can just chop out the looping or if

00:25:51,820 --> 00:25:56,620
we don't need any extra stuff in send

00:25:53,920 --> 00:25:58,150
message drop out send message entirely

00:25:56,620 --> 00:26:01,570
and this will make our code more

00:25:58,150 --> 00:26:06,040
maintainable by getting rid of useless

00:26:01,570 --> 00:26:08,710
crushed fortunately when it's this kind

00:26:06,040 --> 00:26:10,510
of situation the fix is pretty clear

00:26:08,710 --> 00:26:14,380
just get rid of whatever it is that the

00:26:10,510 --> 00:26:18,940
mutant doesn't have now that we've seen

00:26:14,380 --> 00:26:21,190
a few examples of spotting bad tests and

00:26:18,940 --> 00:26:25,240
redundant code I'd like to address a few

00:26:21,190 --> 00:26:28,180
frequently asked questions first this

00:26:25,240 --> 00:26:30,730
all sounds pretty crazy the literally

00:26:28,180 --> 00:26:33,910
making tests fail in order to prove that

00:26:30,730 --> 00:26:36,750
the code succeeds this whole bizarro

00:26:33,910 --> 00:26:39,940
idea come from in the first place

00:26:36,750 --> 00:26:42,580
mutation testing has a surprising

00:26:39,940 --> 00:26:46,019
the long history at least in the context

00:26:42,580 --> 00:26:49,179
of computers if it was first proposed in

00:26:46,019 --> 00:26:51,970
1971 in Richard Lipton's term paper

00:26:49,179 --> 00:26:55,450
titled fault diagnosis of computer

00:26:51,970 --> 00:26:57,730
program the Sun the first tool didn't

00:26:55,450 --> 00:27:01,299
even appear until nine years after that

00:26:57,730 --> 00:27:05,169
in 1980 as part of Timothy buds PhD work

00:27:01,299 --> 00:27:08,850
at Yale and even after that it still

00:27:05,169 --> 00:27:11,259
wasn't practical for most of us running

00:27:08,850 --> 00:27:14,139
consumer-grade or desktop workstation

00:27:11,259 --> 00:27:18,850
grade machines as opposed to souped-up

00:27:14,139 --> 00:27:21,039
servers or gaming rigs until more

00:27:18,850 --> 00:27:24,659
recently maybe the past couple decades

00:27:21,039 --> 00:27:28,019
with advances in cpu speed multi-core

00:27:24,659 --> 00:27:30,580
CPUs more memory and things like that

00:27:28,019 --> 00:27:34,240
that leads us to the next question why

00:27:30,580 --> 00:27:37,899
is it so CPU intensive to answer that we

00:27:34,240 --> 00:27:40,570
have to do some basic math suppose that

00:27:37,899 --> 00:27:44,200
our program has methods with typically

00:27:40,570 --> 00:27:47,409
about 10 lines each and each line has

00:27:44,200 --> 00:27:50,200
about five places or it could be changed

00:27:47,409 --> 00:27:52,659
to about 20 different alternatives that

00:27:50,200 --> 00:27:56,230
works out to about a thousand mutants

00:27:52,659 --> 00:27:58,419
per function and for each one will

00:27:56,230 --> 00:28:02,019
probably have to run at least a few unit

00:27:58,419 --> 00:28:04,750
tests anywhere from one if we get real

00:28:02,019 --> 00:28:07,240
lucky and kill it on the first shot all

00:28:04,750 --> 00:28:10,690
the way up to all the unit tests

00:28:07,240 --> 00:28:12,850
applicable to that method if we get so

00:28:10,690 --> 00:28:15,250
unlucky as to kill it on the last shot

00:28:12,850 --> 00:28:18,870
or worse yet it survives them all and

00:28:15,250 --> 00:28:22,570
has to be reported as a surviving mutant

00:28:18,870 --> 00:28:27,490
but suppose we wind up running just a

00:28:22,570 --> 00:28:29,710
mere tiny 10% of all the unit tests for

00:28:27,490 --> 00:28:32,289
the particular method on average for

00:28:29,710 --> 00:28:34,779
each mutant since we started with a

00:28:32,289 --> 00:28:37,720
thousand mutants that's still a hundred

00:28:34,779 --> 00:28:39,100
times more test runs than just running

00:28:37,720 --> 00:28:42,669
our normal test suite

00:28:39,100 --> 00:28:45,120
so if our unit tests normally took a

00:28:42,669 --> 00:28:47,409
zippe ten seconds

00:28:45,120 --> 00:28:49,539
mutation testing with these assumptions

00:28:47,409 --> 00:28:50,680
is likely to take about a thousand

00:28:49,539 --> 00:28:53,160
seconds which might

00:28:50,680 --> 00:28:58,230
sound like much at first but it's almost

00:28:53,160 --> 00:29:00,820
17 minutes but there is some good news

00:28:58,230 --> 00:29:03,250
over the past decade or so there's been

00:29:00,820 --> 00:29:06,330
a lot of research on trimming down the

00:29:03,250 --> 00:29:10,450
mutant horde using techniques like

00:29:06,330 --> 00:29:12,700
weeding out those that are redundant

00:29:10,450 --> 00:29:15,000
with another mutant or semantically

00:29:12,700 --> 00:29:17,680
equivalent to the original code or

00:29:15,000 --> 00:29:20,230
otherwise trivial like they're going to

00:29:17,680 --> 00:29:22,870
raise an error condition that the tool

00:29:20,230 --> 00:29:25,920
can tell the code and the tests are not

00:29:22,870 --> 00:29:29,190
going to catch things like these have

00:29:25,920 --> 00:29:32,410
squished it down to about a third under

00:29:29,190 --> 00:29:35,260
some very good circumstances but even

00:29:32,410 --> 00:29:37,720
with that rare level of success it's

00:29:35,260 --> 00:29:40,990
still no silver bullet because this

00:29:37,720 --> 00:29:44,490
takes a chunk of CPU time itself and the

00:29:40,990 --> 00:29:48,010
leftover mutants are still quite a lot

00:29:44,490 --> 00:29:51,840
the last common question is when making

00:29:48,010 --> 00:29:54,850
mutants why change them in only one way

00:29:51,840 --> 00:29:58,840
there are a few reasons first it helps

00:29:54,850 --> 00:30:00,580
us poor humans focus it's much easier to

00:29:58,840 --> 00:30:03,160
tell what a mutant is trying to say to

00:30:00,580 --> 00:30:05,020
us if we're only talking about one thing

00:30:03,160 --> 00:30:06,610
in the first place you can think of it

00:30:05,020 --> 00:30:09,520
like using the single responsibility

00:30:06,610 --> 00:30:11,560
principle another reason is that

00:30:09,520 --> 00:30:14,980
multiple changes may balance each other

00:30:11,560 --> 00:30:17,980
out for no net effect leading to a lot

00:30:14,980 --> 00:30:20,470
more false alarms for instance remember

00:30:17,980 --> 00:30:23,920
that first trivial example and it's

00:30:20,470 --> 00:30:26,860
argument swapping mutants if one

00:30:23,920 --> 00:30:29,980
mutation one mutant had both of these

00:30:26,860 --> 00:30:31,930
mutations whoops then the first one

00:30:29,980 --> 00:30:34,300
would swap the arguments and the second

00:30:31,930 --> 00:30:36,760
one would swap them right back for no

00:30:34,300 --> 00:30:39,280
net effect so if such a mutant would

00:30:36,760 --> 00:30:41,550
survive any unit test you care to throw

00:30:39,280 --> 00:30:41,550
at it

00:30:41,880 --> 00:30:46,800
lastly allowing multiple mutations per

00:30:45,100 --> 00:30:49,360
mutant would create a combinatorial

00:30:46,800 --> 00:30:52,750
explosion of mutants with the tool

00:30:49,360 --> 00:30:56,080
making many many times more mutants per

00:30:52,750 --> 00:30:59,080
method which would make it even more CPU

00:30:56,080 --> 00:31:02,170
intensive I'll spare you the math but

00:30:59,080 --> 00:31:04,240
with our earlier code size assumptions

00:31:02,170 --> 00:31:07,480
even if we managed to

00:31:04,240 --> 00:31:10,920
weed them down to 1/3 at each step with

00:31:07,480 --> 00:31:15,850
one mutation per mutant we would have

00:31:10,920 --> 00:31:20,559
333 mutants per method and 1/3 but I'm

00:31:15,850 --> 00:31:24,040
rounding with 2 we would already have

00:31:20,559 --> 00:31:29,190
almost a hundred and ten thousand and

00:31:24,040 --> 00:31:30,460
then with three we would have over 35

00:31:29,190 --> 00:31:32,679
million

00:31:30,460 --> 00:31:35,110
never mind running the tests just

00:31:32,679 --> 00:31:37,390
creating the mutants we get to be quite

00:31:35,110 --> 00:31:40,420
a heavy workload but we can avoid the

00:31:37,390 --> 00:31:42,640
heavy workload and the lack of focus and

00:31:40,420 --> 00:31:47,170
the increased false alarms if we just

00:31:42,640 --> 00:31:49,600
limit it to one mutation per mutant so

00:31:47,170 --> 00:31:52,030
to summarize at last mutation testing is

00:31:49,600 --> 00:31:54,550
a powerful tool to ensure that our code

00:31:52,030 --> 00:31:57,520
is meaningful and our tests are strict

00:31:54,550 --> 00:32:00,340
it's fairly easy to get started with in

00:31:57,520 --> 00:32:02,790
terms of setting up the tools and

00:32:00,340 --> 00:32:07,330
annotating the tests which may be

00:32:02,790 --> 00:32:10,570
tedious but at least it is easy but it's

00:32:07,330 --> 00:32:13,720
not so easy to interpret the results nor

00:32:10,570 --> 00:32:16,360
is it easy on the CPU even if these

00:32:13,720 --> 00:32:18,550
drawbacks mean it's not very well suited

00:32:16,360 --> 00:32:21,730
for our current projects I still think

00:32:18,550 --> 00:32:24,670
it's just a really cool idea in a geeky

00:32:21,730 --> 00:32:27,309
kind of way if you'd like the try

00:32:24,670 --> 00:32:29,559
mutation testing for yourself here's a

00:32:27,309 --> 00:32:31,510
list of some popular tools for some

00:32:29,559 --> 00:32:33,610
popular languages and frameworks and

00:32:31,510 --> 00:32:37,179
some other ones I doubt many of you are

00:32:33,610 --> 00:32:38,800
doing fortran 77 these days I'll talk a

00:32:37,179 --> 00:32:43,380
little longer so you can take pictures

00:32:38,800 --> 00:32:46,360
if you like as for the ones about Ruby

00:32:43,380 --> 00:32:50,050
mutant is the main one but they are

00:32:46,360 --> 00:32:52,360
moving to a closed source paid model but

00:32:50,050 --> 00:32:54,040
they are leaving the last open source

00:32:52,360 --> 00:32:57,190
one out there for everyone to use for

00:32:54,040 --> 00:32:59,110
free and I'm not entirely sure but if I

00:32:57,190 --> 00:33:02,410
remember rightly open source projects

00:32:59,110 --> 00:33:05,350
can use even the paid version for free

00:33:02,410 --> 00:33:08,050
mu test is a fork of an old version of

00:33:05,350 --> 00:33:10,030
mutant and work has continued on it so

00:33:08,050 --> 00:33:14,110
it has some features mutant doesn't and

00:33:10,030 --> 00:33:16,509
vice-versa but it's only compatible with

00:33:14,110 --> 00:33:18,369
r-spec rather than mini tests

00:33:16,509 --> 00:33:20,169
my current main client uses mini tests

00:33:18,369 --> 00:33:22,479
so I didn't bother playing with new

00:33:20,169 --> 00:33:27,399
tests much Haeckel hasn't been updated

00:33:22,479 --> 00:33:29,799
since 2013 so good luck with that as for

00:33:27,399 --> 00:33:31,539
the rest of them just be aware that I

00:33:29,799 --> 00:33:33,429
mean look for the other languages and so

00:33:31,539 --> 00:33:37,479
forth it just be aware that many of

00:33:33,429 --> 00:33:40,389
these may be outdated I do not know or

00:33:37,479 --> 00:33:44,309
even just follow quite all of those

00:33:40,389 --> 00:33:49,389
languages everybody done taking pictures

00:33:44,309 --> 00:33:53,559
okay moving on lastly a shout-out to Tom

00:33:49,389 --> 00:33:55,299
Tao a consulting Network I'm in that has

00:33:53,559 --> 00:33:57,369
a speaker's network that helped me

00:33:55,299 --> 00:34:00,399
prepare and practice this presentation

00:33:57,369 --> 00:34:03,639
please use my referral link there if you

00:34:00,399 --> 00:34:06,789
want to hire us or join us and many

00:34:03,639 --> 00:34:10,450
thanks to Marcus chirp who created

00:34:06,789 --> 00:34:13,000
mutant the main mutation testing tool

00:34:10,450 --> 00:34:14,710
I've actually used and has been very

00:34:13,000 --> 00:34:16,929
willing to answer my questions and

00:34:14,710 --> 00:34:19,359
critique his presentation and now it's

00:34:16,929 --> 00:34:22,929
your turn we have about five and a half

00:34:19,359 --> 00:34:24,279
minutes for questions if you think of

00:34:22,929 --> 00:34:26,559
something later there's my contact

00:34:24,279 --> 00:34:27,879
information up there and of course I

00:34:26,559 --> 00:34:30,269
have cards and I'll be around for the

00:34:27,879 --> 00:34:32,980
rest of the conference any questions

00:34:30,269 --> 00:34:34,779
okay how long does it take to get up and

00:34:32,980 --> 00:34:38,889
running with mutation testing on a

00:34:34,779 --> 00:34:40,779
project to get your first I guess would

00:34:38,889 --> 00:34:42,339
be your first report you know here's

00:34:40,779 --> 00:34:46,000
some surviving mutants you should do

00:34:42,339 --> 00:34:48,519
something about on a reasonable size

00:34:46,000 --> 00:34:52,990
project I suppose you could make a

00:34:48,519 --> 00:34:55,779
decent dent in it by just installing the

00:34:52,990 --> 00:34:57,819
tool and running it how long that's

00:34:55,779 --> 00:35:01,690
gonna take depends how big your codebase

00:34:57,819 --> 00:35:05,920
is and whether your chosen tool skips

00:35:01,690 --> 00:35:09,640
tests I mean it skips methods that it

00:35:05,920 --> 00:35:12,759
doesn't find any tests for a number of

00:35:09,640 --> 00:35:16,150
other factors but I would guess with a

00:35:12,759 --> 00:35:20,200
not too huge rails app or something like

00:35:16,150 --> 00:35:26,589
that you could have an actionable set of

00:35:20,200 --> 00:35:29,349
mutant reports in under an hour the most

00:35:26,589 --> 00:35:30,230
time-consuming part at least in my

00:35:29,349 --> 00:35:33,710
experience

00:35:30,230 --> 00:35:36,680
very limited are waiting for the thing

00:35:33,710 --> 00:35:39,470
to actually run rather than the setup

00:35:36,680 --> 00:35:42,470
and like you do that over a lunch break

00:35:39,470 --> 00:35:44,990
or overnight or something and even more

00:35:42,470 --> 00:35:47,060
so than trying to figure out what the

00:35:44,990 --> 00:35:50,780
mutants are trying to tell you that's

00:35:47,060 --> 00:35:53,810
why I consider this an advanced topic a

00:35:50,780 --> 00:35:56,660
lot of it takes a lot of experience okay

00:35:53,810 --> 00:36:00,349
when killing mutants do I consider it

00:35:56,660 --> 00:36:06,430
more of a best practice to optimize a

00:36:00,349 --> 00:36:12,280
given test or add additional tests I

00:36:06,430 --> 00:36:14,180
would say that's really a subset of the

00:36:12,280 --> 00:36:21,250
philosophy of whether one does that

00:36:14,180 --> 00:36:21,250
overall in tests what I generally do is

00:36:21,310 --> 00:36:28,820
write tests for specific situations I'm

00:36:25,339 --> 00:36:32,690
trying to make sure are covered so for

00:36:28,820 --> 00:36:36,260
instance with that initial example of

00:36:32,690 --> 00:36:38,859
the power method I think I would have

00:36:36,260 --> 00:36:42,040
some function say okay what if some

00:36:38,859 --> 00:36:46,130
smartass passes in a zero what if some

00:36:42,040 --> 00:36:49,400
you know passes in something otherwise

00:36:46,130 --> 00:36:53,750
invalid and of course a few cases for

00:36:49,400 --> 00:36:57,500
the normal usage like two to the third

00:36:53,750 --> 00:37:03,500
power or whatever for that I think I

00:36:57,500 --> 00:37:06,230
would try to just have one or two but

00:37:03,500 --> 00:37:11,960
not an excessive number of fairly normal

00:37:06,230 --> 00:37:16,400
tests chosen so as to not let a lot of

00:37:11,960 --> 00:37:20,780
mutants survive it may be difficult with

00:37:16,400 --> 00:37:24,619
some kinds of functions to have one test

00:37:20,780 --> 00:37:27,440
kill a boatload of mutants nuke

00:37:24,619 --> 00:37:28,910
Magneto's headquarters or whatever but

00:37:27,440 --> 00:37:32,869
like I said no need to be a superhero

00:37:28,910 --> 00:37:34,609
about it you can have one test kill that

00:37:32,869 --> 00:37:35,990
batch of mutants and other tests kill

00:37:34,609 --> 00:37:39,170
that batch of mutants which as you may

00:37:35,990 --> 00:37:40,880
notice is overlapping a little don't

00:37:39,170 --> 00:37:41,530
overthink it too much I guess would be

00:37:40,880 --> 00:37:44,860
the main thing

00:37:41,530 --> 00:37:47,620
okay and okay the question is do mutant

00:37:44,860 --> 00:37:51,850
and Mew test patch the Ruby interpreter

00:37:47,620 --> 00:37:54,610
to make this work I don't think they do

00:37:51,850 --> 00:37:57,130
anything to the copy that you are

00:37:54,610 --> 00:38:01,090
actually using for most of your regular

00:37:57,130 --> 00:38:02,710
Ruby usage I haven't taken a look at how

00:38:01,090 --> 00:38:07,450
they work under the hood so they may

00:38:02,710 --> 00:38:11,710
make a copy and tweak that I've done a

00:38:07,450 --> 00:38:17,560
little bit of other custom parsing stuff

00:38:11,710 --> 00:38:20,110
and what I've seen done in that domain

00:38:17,560 --> 00:38:24,640
is mainly okay here's you know the

00:38:20,110 --> 00:38:27,790
grammar we're trying to use have it go

00:38:24,640 --> 00:38:29,470
according to that may reveal a few

00:38:27,790 --> 00:38:32,440
additional things or ignore some things

00:38:29,470 --> 00:38:35,350
that the normal configuration would

00:38:32,440 --> 00:38:37,390
ignore I don't think it does anything

00:38:35,350 --> 00:38:38,950
that would I don't think either of those

00:38:37,390 --> 00:38:42,910
rather it wouldn't do anything that

00:38:38,950 --> 00:38:45,820
leaks into your other usage of the

00:38:42,910 --> 00:38:49,480
interpreter we have 45 seconds anybody

00:38:45,820 --> 00:38:51,760
had a real quick question all right I

00:38:49,480 --> 00:38:54,640
guess then we get a little lead on

00:38:51,760 --> 00:38:58,680
everybody for the afternoon snacks

00:38:54,640 --> 00:39:06,099
[Applause]

00:38:58,680 --> 00:39:06,099
[Music]

00:39:08,420 --> 00:39:10,480

YouTube URL: https://www.youtube.com/watch?v=9GId6mFL0_c


