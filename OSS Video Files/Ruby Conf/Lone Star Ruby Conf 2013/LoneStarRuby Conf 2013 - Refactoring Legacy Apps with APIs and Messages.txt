Title: LoneStarRuby Conf 2013 - Refactoring Legacy Apps with APIs and Messages
Publication date: 2020-01-28
Playlist: Lone Star Ruby Conf 2013
Description: 
	By Corey Ehmke

Rails as a framework is famous for getting an application up and running quickly, but the very paradigms that make it so easy at the start can lead to maintenance nightmares down the road. Successful applications grow rapidly larger, more complex, and harder to extend and maintain. One way to approach refactoring a monolithic application is dividing it up into a series of smaller applications that organize the work of the system through internal APIs and message queues. In this presentation you will be introduced to tools to enable this architecture, gain insight on how best to use them, and explore the guiding principles behind the SOA approach to refactoring.

Help us caption & translate this video!

http://amara.org/v/FG83/
Captions: 
	00:00:14,820 --> 00:00:21,420
I am part of the Chicago quarry

00:00:17,310 --> 00:00:23,220
contingent of the Ruby community as as

00:00:21,420 --> 00:00:25,860
they said been working in startups for a

00:00:23,220 --> 00:00:27,630
while and I really care a lot about

00:00:25,860 --> 00:00:29,520
giving back to the community and I'm

00:00:27,630 --> 00:00:31,820
very honored to have the opportunity to

00:00:29,520 --> 00:00:35,040
share with you guys what I have learned

00:00:31,820 --> 00:00:38,309
about architecture as it applies to

00:00:35,040 --> 00:00:40,589
rails applications so i am going to talk

00:00:38,309 --> 00:00:42,000
to you about the a word software

00:00:40,589 --> 00:00:44,400
architecture something that we don't

00:00:42,000 --> 00:00:46,440
really talk about very much anymore what

00:00:44,400 --> 00:00:48,840
I bean by architecture this is a formal

00:00:46,440 --> 00:00:51,000
definition but what I mean by it is

00:00:48,840 --> 00:00:52,469
something different from what a lot of

00:00:51,000 --> 00:00:53,579
people mean to mean by it I think we all

00:00:52,469 --> 00:00:56,370
have different ideas of what

00:00:53,579 --> 00:00:58,379
architecture really means I think of it

00:00:56,370 --> 00:00:59,789
as something that it's both viable it's

00:00:58,379 --> 00:01:01,770
finding a balance between viability in

00:00:59,789 --> 00:01:04,920
the short term and maintainability in

00:01:01,770 --> 00:01:07,110
the long term it's a it's a compromise a

00:01:04,920 --> 00:01:08,789
series of compromises we want to make

00:01:07,110 --> 00:01:10,619
sure that we're delivering a solution

00:01:08,789 --> 00:01:12,090
that actually works without spending too

00:01:10,619 --> 00:01:13,890
much time thinking about the design of

00:01:12,090 --> 00:01:15,570
it but if we spend too little time

00:01:13,890 --> 00:01:17,009
designing it we're essentially paying

00:01:15,570 --> 00:01:18,690
our mortgage with a credit card and

00:01:17,009 --> 00:01:20,960
we're accumulating debt that's going to

00:01:18,690 --> 00:01:23,100
come back and hurt us later so

00:01:20,960 --> 00:01:25,170
architecture is some science there's

00:01:23,100 --> 00:01:26,220
definitely a methodology to it but I

00:01:25,170 --> 00:01:28,619
like to think that a lot of it comes

00:01:26,220 --> 00:01:31,110
down to technical aesthetics a sense of

00:01:28,619 --> 00:01:35,689
beauty and symmetry that you develop

00:01:31,110 --> 00:01:38,759
over time this is Foucault's Pendulum

00:01:35,689 --> 00:01:40,530
architecture over time especially in the

00:01:38,759 --> 00:01:44,610
open source world in the world that we

00:01:40,530 --> 00:01:46,560
move in swings from clarity to agility

00:01:44,610 --> 00:01:49,820
back and forth and back and forth less

00:01:46,560 --> 00:01:52,560
and more design goes into what we do

00:01:49,820 --> 00:01:53,780
it's really a conflict between big

00:01:52,560 --> 00:01:58,920
upfront design the architecture

00:01:53,780 --> 00:02:00,630
astronaut and the cowboy coder and James

00:01:58,920 --> 00:02:02,579
Gray gave a talk at Ruby Midwest in

00:02:00,630 --> 00:02:04,320
which he said that every developer falls

00:02:02,579 --> 00:02:07,110
on a spectrum between one of these two

00:02:04,320 --> 00:02:10,079
extremes so I want to talk a minute

00:02:07,110 --> 00:02:11,700
about big out front design it's part of

00:02:10,079 --> 00:02:14,370
our history and we should acknowledge it

00:02:11,700 --> 00:02:16,590
as such so it's much maligned but the

00:02:14,370 --> 00:02:18,360
decision to do big our front design it

00:02:16,590 --> 00:02:20,250
wasn't stupid people doing stupid things

00:02:18,360 --> 00:02:22,560
there were actually really good reasons

00:02:20,250 --> 00:02:24,359
for doing big upfront design we had the

00:02:22,560 --> 00:02:26,340
luxury and I've been doing this for a

00:02:24,359 --> 00:02:28,590
while so I've been in this world we had

00:02:26,340 --> 00:02:30,690
the luxury of long-term product roadmaps

00:02:28,590 --> 00:02:32,580
things weren't moving quite at the pace

00:02:30,690 --> 00:02:34,349
that they are today we had stable

00:02:32,580 --> 00:02:38,280
platforms we had standards that were

00:02:34,349 --> 00:02:39,870
very formal so design led to high

00:02:38,280 --> 00:02:42,300
predictability understandability

00:02:39,870 --> 00:02:44,129
maintainability and really a guided

00:02:42,300 --> 00:02:46,980
evolution of technology along a

00:02:44,129 --> 00:02:48,900
pre-plotted path but of course we all

00:02:46,980 --> 00:02:51,239
know it had some disadvantages as well

00:02:48,900 --> 00:02:53,129
when you failed you failed really big

00:02:51,239 --> 00:02:54,780
and you failed really late your

00:02:53,129 --> 00:02:56,489
solutions were untested until they were

00:02:54,780 --> 00:02:57,690
actually delivered and you had to cross

00:02:56,489 --> 00:02:59,849
your fingers and hope that you did

00:02:57,690 --> 00:03:01,620
everything absolutely right because

00:02:59,849 --> 00:03:04,620
change was expensive and failure was

00:03:01,620 --> 00:03:06,209
expensive so the pendulum has swung in

00:03:04,620 --> 00:03:07,980
the opposite direction in modern times

00:03:06,209 --> 00:03:10,410
and we have what I call ad hoc

00:03:07,980 --> 00:03:12,680
architecture we have guiding principles

00:03:10,410 --> 00:03:15,450
that sort of determine what we build

00:03:12,680 --> 00:03:17,430
these are all of the promises of modern

00:03:15,450 --> 00:03:19,500
frameworks a lot of the architectural

00:03:17,430 --> 00:03:21,060
decisions are already made for us and in

00:03:19,500 --> 00:03:22,980
theory we can spend all of our time

00:03:21,060 --> 00:03:24,599
focusing on what's called business logic

00:03:22,980 --> 00:03:27,599
determinate I've always had issues with

00:03:24,599 --> 00:03:29,849
but so we have the best of intentions we

00:03:27,599 --> 00:03:33,600
do these things and what happens is our

00:03:29,849 --> 00:03:36,150
design emerges slowly over time great

00:03:33,600 --> 00:03:37,799
intentions we hope that everything sort

00:03:36,150 --> 00:03:39,359
of lines up in the end it doesn't

00:03:37,799 --> 00:03:42,239
already always happen that way unless

00:03:39,359 --> 00:03:43,889
you happen to be building a monorail so

00:03:42,239 --> 00:03:45,299
how does this happen instead of focusing

00:03:43,889 --> 00:03:47,250
on business logic like we could or

00:03:45,299 --> 00:03:50,430
should we fight against conventions

00:03:47,250 --> 00:03:52,549
because our case is a special case so

00:03:50,430 --> 00:03:55,319
the five controller verbs for example

00:03:52,549 --> 00:03:57,150
they last for ten minutes and then you

00:03:55,319 --> 00:03:58,590
introduce the search method to your

00:03:57,150 --> 00:04:01,799
controller and that's the beginning of

00:03:58,590 --> 00:04:04,260
the end you end up with logic leaking

00:04:01,799 --> 00:04:05,760
into your controllers and scaffolding

00:04:04,260 --> 00:04:07,230
and generated code is part of the

00:04:05,760 --> 00:04:09,120
problem here when you generate a

00:04:07,230 --> 00:04:10,799
controller in rails you get conditional

00:04:09,120 --> 00:04:13,950
code conditional code baguettes

00:04:10,799 --> 00:04:15,540
conditional code just like real life

00:04:13,950 --> 00:04:18,180
relationships are really easy to start

00:04:15,540 --> 00:04:19,829
and really hard to maintain when your

00:04:18,180 --> 00:04:21,570
relation when your object graph gets to

00:04:19,829 --> 00:04:23,940
be about three miles wide and replete

00:04:21,570 --> 00:04:26,910
with callbacks good luck with your test

00:04:23,940 --> 00:04:30,020
suite where do we put non persisted

00:04:26,910 --> 00:04:35,010
models I don't know what do you think

00:04:30,020 --> 00:04:37,349
junk drawer and we end up with a gem

00:04:35,010 --> 00:04:38,700
file that's a mile long how many of you

00:04:37,349 --> 00:04:42,169
actually know what the Ruby racer does

00:04:38,700 --> 00:04:45,110
and what happens if it goes away

00:04:42,169 --> 00:04:46,189
it's always there we have gems that we

00:04:45,110 --> 00:04:47,629
don't know what they're there for we

00:04:46,189 --> 00:04:51,199
don't know who introduced them and we're

00:04:47,629 --> 00:04:52,669
afraid to take them out Caleb cornman

00:04:51,199 --> 00:04:55,580
once said that the user model is the

00:04:52,669 --> 00:04:57,199
katamari damacy of rails it picks up

00:04:55,580 --> 00:05:00,889
methods and attributes as it rolls

00:04:57,199 --> 00:05:04,490
through your application that never

00:05:00,889 --> 00:05:06,979
happens to anyone here right so how can

00:05:04,490 --> 00:05:09,529
you tell if you have a design and

00:05:06,979 --> 00:05:11,330
architecture that is degraded change

00:05:09,529 --> 00:05:12,889
becomes hard because every change has a

00:05:11,330 --> 00:05:14,090
ripple effect on your application you

00:05:12,889 --> 00:05:16,639
can't always predict what's going to

00:05:14,090 --> 00:05:18,409
happen and when you do make a change

00:05:16,639 --> 00:05:20,449
unexpected parts of your system break

00:05:18,409 --> 00:05:22,339
you find that you can't pick up your

00:05:20,449 --> 00:05:23,449
code and move it to other applications a

00:05:22,339 --> 00:05:24,919
little into other parts of your

00:05:23,449 --> 00:05:28,129
application because it's really

00:05:24,919 --> 00:05:30,050
entangled and you have increased

00:05:28,129 --> 00:05:31,460
difficulty and adding new features the

00:05:30,050 --> 00:05:33,589
the rate at which you can add features

00:05:31,460 --> 00:05:35,210
get slower and slower over time so

00:05:33,589 --> 00:05:38,120
change gets harder over time this is a

00:05:35,210 --> 00:05:40,159
very scientific graph time is the x axis

00:05:38,120 --> 00:05:42,199
and the difficulty of change is the y

00:05:40,159 --> 00:05:44,330
axis and there are no numbers here

00:05:42,199 --> 00:05:47,439
because I'm not a numbers person but at

00:05:44,330 --> 00:05:50,419
the beginning change is relatively easy

00:05:47,439 --> 00:05:52,849
after a while you get to the point where

00:05:50,419 --> 00:05:54,080
if you have an intern or someone who

00:05:52,849 --> 00:05:58,279
just came out of dead boot camp you're

00:05:54,080 --> 00:05:59,629
going to let them make the change then

00:05:58,279 --> 00:06:01,099
you hear about a feature that's coming

00:05:59,629 --> 00:06:02,509
up and you decide it's time for a

00:06:01,099 --> 00:06:06,349
vacation or you're really not feeling

00:06:02,509 --> 00:06:11,960
very well and finally your reaction is

00:06:06,349 --> 00:06:14,449
to kill it with fire so how did we get

00:06:11,960 --> 00:06:16,999
here we got here by painting by the

00:06:14,449 --> 00:06:19,310
numbers believing what we read on Stack

00:06:16,999 --> 00:06:21,759
Overflow relying on the behavior of

00:06:19,310 --> 00:06:24,469
things that we don't fully understand

00:06:21,759 --> 00:06:25,939
we've also had dozens of hands on the

00:06:24,469 --> 00:06:28,399
code it might have been written by

00:06:25,939 --> 00:06:30,020
consultants who are building an MVP and

00:06:28,399 --> 00:06:30,979
now you have to live with decisions that

00:06:30,020 --> 00:06:34,849
were made based on short-term

00:06:30,979 --> 00:06:36,740
circumstances classes attract new

00:06:34,849 --> 00:06:41,360
methods the same way that black clothes

00:06:36,740 --> 00:06:43,939
attack at a trot cat hair as a test

00:06:41,360 --> 00:06:45,949
suite grows your TDD program your TDD

00:06:43,939 --> 00:06:47,960
practice goes away because if you have

00:06:45,949 --> 00:06:50,800
to wait minutes for your test suite to

00:06:47,960 --> 00:06:53,529
run you are not doing TDD anymore

00:06:50,800 --> 00:06:55,940
finally physics teaches us that systems

00:06:53,529 --> 00:06:57,470
evolve toward a state of maximum in

00:06:55,940 --> 00:07:00,050
trippy so even if you're doing

00:06:57,470 --> 00:07:02,450
everything right eventually your design

00:07:00,050 --> 00:07:06,320
will degrade and it happens one line of

00:07:02,450 --> 00:07:08,150
code at a time Uncle Bob said that most

00:07:06,320 --> 00:07:09,380
software eventually degrades to the

00:07:08,150 --> 00:07:12,410
point where someone will declare the

00:07:09,380 --> 00:07:14,780
design to be unsound and I think there's

00:07:12,410 --> 00:07:16,700
a lot of truth in that so let's take a

00:07:14,780 --> 00:07:19,130
step back and decide what's important to

00:07:16,700 --> 00:07:22,150
us as developers and as people who are

00:07:19,130 --> 00:07:24,020
participating in an ad hoc architecture

00:07:22,150 --> 00:07:26,180
there are a lot of new developers that

00:07:24,020 --> 00:07:27,830
are entering our field and we want to

00:07:26,180 --> 00:07:30,380
find a way to respect their ideas and

00:07:27,830 --> 00:07:31,910
their enthusiasm and temper it with our

00:07:30,380 --> 00:07:35,090
experience of what works and what's

00:07:31,910 --> 00:07:36,890
maintainable we want to apply solid

00:07:35,090 --> 00:07:40,160
design principles and create good

00:07:36,890 --> 00:07:41,810
solutions that people want to use good

00:07:40,160 --> 00:07:43,520
code we find lends itself to the use

00:07:41,810 --> 00:07:45,680
cases that were not necessarily what we

00:07:43,520 --> 00:07:48,080
had in mind at the beginning so if we

00:07:45,680 --> 00:07:49,670
think of a values-based approach we

00:07:48,080 --> 00:07:51,950
might implement these things and hope

00:07:49,670 --> 00:07:53,660
that we arrive at a better architecture

00:07:51,950 --> 00:07:56,270
than we do if we simply ignore our

00:07:53,660 --> 00:07:58,030
values so let's apply these values to

00:07:56,270 --> 00:08:00,050
our architecture there's been some

00:07:58,030 --> 00:08:01,669
exploration of alternative architectures

00:08:00,050 --> 00:08:03,260
lately that I don't think get enough

00:08:01,669 --> 00:08:04,910
attention and one of the things that I

00:08:03,260 --> 00:08:07,190
find really interesting concept of

00:08:04,910 --> 00:08:09,800
hexagonal design so we're all familiar

00:08:07,190 --> 00:08:12,080
with MVC and we hold NBC up as an ideal

00:08:09,800 --> 00:08:14,450
but it's very very easy to violate its

00:08:12,080 --> 00:08:17,000
principles and practice layered

00:08:14,450 --> 00:08:20,169
architectures break down you have I've

00:08:17,000 --> 00:08:22,400
seen sessions passed down to models and

00:08:20,169 --> 00:08:23,690
nothing is going to stop you from doing

00:08:22,400 --> 00:08:26,600
that and no one's going to yell at you

00:08:23,690 --> 00:08:28,190
if you do that if they don't see it so

00:08:26,600 --> 00:08:31,010
it's really really easy to violate our

00:08:28,190 --> 00:08:33,860
layered architecture so what if we think

00:08:31,010 --> 00:08:37,400
instead of domain objects as pure Ruby

00:08:33,860 --> 00:08:39,260
classes in a cluster and this cluster

00:08:37,400 --> 00:08:43,280
has edges that we're exposing to the

00:08:39,260 --> 00:08:45,980
world exposing to consumers and what if

00:08:43,280 --> 00:08:48,470
we drop in consumers to these edges as

00:08:45,980 --> 00:08:50,510
we want and swap them out as we want if

00:08:48,470 --> 00:08:52,070
we're doing it in pure Ruby as you'll

00:08:50,510 --> 00:08:54,050
see it gets much much easier we can

00:08:52,070 --> 00:08:57,170
think of our testing framework is one of

00:08:54,050 --> 00:08:59,720
the consumers of our logic our

00:08:57,170 --> 00:09:01,700
persistence layer despite what active

00:08:59,720 --> 00:09:06,400
record would have us do persistence is a

00:09:01,700 --> 00:09:09,649
service not a class hierarchy

00:09:06,400 --> 00:09:11,269
persistence is a service HTTP is a sir

00:09:09,649 --> 00:09:12,920
this is an interface between our

00:09:11,269 --> 00:09:15,709
application and most of our users or

00:09:12,920 --> 00:09:18,050
other applications the command line we

00:09:15,709 --> 00:09:20,660
use rake we use cron jobs that's a

00:09:18,050 --> 00:09:22,100
consumer of our app in our logic you

00:09:20,660 --> 00:09:24,079
might have a messaging system in place

00:09:22,100 --> 00:09:25,519
and you might have a monitoring you

00:09:24,079 --> 00:09:28,759
should have a monitoring system in place

00:09:25,519 --> 00:09:31,490
so if you build those those sort of

00:09:28,759 --> 00:09:33,619
consumers into your application you're

00:09:31,490 --> 00:09:35,720
locked in to a specific implementation

00:09:33,619 --> 00:09:37,399
you're locked into what is good and bad

00:09:35,720 --> 00:09:38,809
about that specific implementation and

00:09:37,399 --> 00:09:42,499
you'll find it very hard to swap things

00:09:38,809 --> 00:09:43,850
out so if you take the more disciplined

00:09:42,499 --> 00:09:46,399
approach and keep your domain objects

00:09:43,850 --> 00:09:49,040
pure you can use different services at

00:09:46,399 --> 00:09:51,559
at the different edges might start out

00:09:49,040 --> 00:09:53,499
with a Sinatra app every sufficiently

00:09:51,559 --> 00:09:56,240
advanced Sinatra app becomes rails so

00:09:53,499 --> 00:09:57,740
over time you might drop rails in

00:09:56,240 --> 00:10:00,050
instead you might say I don't like

00:09:57,740 --> 00:10:01,579
postgres anymore i go to this

00:10:00,050 --> 00:10:03,290
gives you the flexibility to change your

00:10:01,579 --> 00:10:07,189
mind about fundamental components of

00:10:03,290 --> 00:10:09,829
your architecture your users include

00:10:07,189 --> 00:10:13,339
your customers your internal staff test

00:10:09,829 --> 00:10:16,089
scripts cron jobs other applications you

00:10:13,339 --> 00:10:18,290
want to design for all of those equally

00:10:16,089 --> 00:10:20,569
you want to give every class its

00:10:18,290 --> 00:10:22,459
distinct its own distinct API we don't

00:10:20,569 --> 00:10:25,069
have the concept of formal interfaces in

00:10:22,459 --> 00:10:26,779
Ruby but we can we can think about the

00:10:25,069 --> 00:10:28,970
API that are objects is exposed to the

00:10:26,779 --> 00:10:30,980
world and try to be disciplined about

00:10:28,970 --> 00:10:32,899
the methods that we're exposing and how

00:10:30,980 --> 00:10:36,470
they're called and make sure that we are

00:10:32,899 --> 00:10:38,449
enabling correct usage rails is great

00:10:36,470 --> 00:10:41,120
but we are at a ruby conference we're

00:10:38,449 --> 00:10:43,160
rubios first and foremost let's remember

00:10:41,120 --> 00:10:45,740
that and write our applications in Ruby

00:10:43,160 --> 00:10:47,569
and know the difference this will let us

00:10:45,740 --> 00:10:49,699
achieve framework independence Ruby

00:10:47,569 --> 00:10:51,920
existed before rails and it's my opinion

00:10:49,699 --> 00:10:56,990
that Ruby will exist after we're done

00:10:51,920 --> 00:10:59,059
with rails so I want to talk a bit about

00:10:56,990 --> 00:11:01,040
using api's and messages that's probably

00:10:59,059 --> 00:11:02,689
why you're here there's this great quote

00:11:01,040 --> 00:11:05,329
by Doug McIlroy one of the fathers of

00:11:02,689 --> 00:11:06,740
UNIX that you should write programs to

00:11:05,329 --> 00:11:09,019
handle text streams because that's a

00:11:06,740 --> 00:11:10,459
universal interface I would amend this a

00:11:09,019 --> 00:11:12,799
little bit and say that you should write

00:11:10,459 --> 00:11:17,360
your programs to handle HTTP because

00:11:12,799 --> 00:11:20,600
that is a nearly universal interface so

00:11:17,360 --> 00:11:22,069
I talked about ecosystems of small

00:11:20,600 --> 00:11:23,240
applications you notice that I have not

00:11:22,069 --> 00:11:25,580
used the three letter acronym

00:11:23,240 --> 00:11:27,589
to describe services and ap is and I

00:11:25,580 --> 00:11:29,600
don't intend to I think of an ecosystem

00:11:27,589 --> 00:11:32,330
and I use that term very deliberately a

00:11:29,600 --> 00:11:35,000
healthy ecosystem consists of symbiotic

00:11:32,330 --> 00:11:37,130
relationships between organisms that

00:11:35,000 --> 00:11:39,620
have the resources they need to live and

00:11:37,130 --> 00:11:41,180
to grow and to be healthy that's what

00:11:39,620 --> 00:11:42,339
our applications should look like that's

00:11:41,180 --> 00:11:46,370
what our architecture should look like

00:11:42,339 --> 00:11:47,660
so we need to decide in order to

00:11:46,370 --> 00:11:49,520
implement this we need to sort of

00:11:47,660 --> 00:11:52,430
segregate functionaries of functionality

00:11:49,520 --> 00:11:54,830
decide which applications need which we

00:11:52,430 --> 00:11:56,899
need access to which models do not try

00:11:54,830 --> 00:11:59,149
to share by the way models between

00:11:56,899 --> 00:12:00,980
applications using get sub modules or

00:11:59,149 --> 00:12:04,940
engines or anything like that that is

00:12:00,980 --> 00:12:07,190
the road to the sixth circle of hell and

00:12:04,940 --> 00:12:08,810
as i said before i'm going to bang this

00:12:07,190 --> 00:12:12,890
from a little bit more persistence is a

00:12:08,810 --> 00:12:15,709
service we bind our applications

00:12:12,890 --> 00:12:18,260
together using api's and messages it's

00:12:15,709 --> 00:12:20,510
about sending and receiving messages I'm

00:12:18,260 --> 00:12:22,399
going to come back to that when you're

00:12:20,510 --> 00:12:24,500
when you're sending messages when you're

00:12:22,399 --> 00:12:26,540
using API is to pull data between

00:12:24,500 --> 00:12:28,160
systems think about your caching

00:12:26,540 --> 00:12:30,470
strategy think about how fresh your data

00:12:28,160 --> 00:12:32,630
actually needs to be is it okay if it's

00:12:30,470 --> 00:12:35,720
five seconds old is it okay if it's a

00:12:32,630 --> 00:12:38,240
day old what range in between that you

00:12:35,720 --> 00:12:42,020
actually need your data to be to be

00:12:38,240 --> 00:12:42,860
perfectly concise and consistent you're

00:12:42,020 --> 00:12:44,480
going to want to think about your

00:12:42,860 --> 00:12:45,920
messaging system that use this is

00:12:44,480 --> 00:12:48,500
critical plumbing and we're at a stage

00:12:45,920 --> 00:12:51,079
in the evolution or the lifecycle of

00:12:48,500 --> 00:12:53,420
messaging solutions where no clear

00:12:51,079 --> 00:12:54,709
winner has emerged yet and there's not a

00:12:53,420 --> 00:12:56,329
lot of interoperability between

00:12:54,709 --> 00:12:57,589
different approaches to messaging

00:12:56,329 --> 00:13:00,079
there's not a standard there's not a

00:12:57,589 --> 00:13:02,480
protocol that i'm aware of at least so

00:13:00,079 --> 00:13:04,220
do your research find out what's going

00:13:02,480 --> 00:13:08,120
to work best for your particular use

00:13:04,220 --> 00:13:10,430
case and and be very thoughtful about it

00:13:08,120 --> 00:13:14,140
so i've talked about hexagonal

00:13:10,430 --> 00:13:17,600
architecture a bit i've talked about

00:13:14,140 --> 00:13:19,190
messages and api's these are organizing

00:13:17,600 --> 00:13:21,380
principles that help us look at the

00:13:19,190 --> 00:13:23,390
problem of architecture and there's a

00:13:21,380 --> 00:13:24,829
but there's there's one other aspect to

00:13:23,390 --> 00:13:26,870
architecture that I wanted to bring up

00:13:24,829 --> 00:13:29,329
we were very fortunate to have standing

00:13:26,870 --> 00:13:31,430
that's here speaking to us at this

00:13:29,329 --> 00:13:33,170
conference and when I read practical

00:13:31,430 --> 00:13:35,089
object oriented design and Ruby it

00:13:33,170 --> 00:13:35,920
reminded me of what I liked about oh oh

00:13:35,089 --> 00:13:39,040
and

00:13:35,920 --> 00:13:42,130
it sort of took me back to when I first

00:13:39,040 --> 00:13:43,420
learned how to do oh oh and I think one

00:13:42,130 --> 00:13:46,170
of the main messages that I took away

00:13:43,420 --> 00:13:48,579
from her book that as developers we

00:13:46,170 --> 00:13:50,529
think a lot about objects but we should

00:13:48,579 --> 00:13:53,829
think more about messages that are sent

00:13:50,529 --> 00:13:57,070
between objects that's really the heart

00:13:53,829 --> 00:13:59,949
of what oo is so I had this revelation

00:13:57,070 --> 00:14:03,339
what if we think of an application as an

00:13:59,949 --> 00:14:06,100
object can we apply the principles of

00:14:03,339 --> 00:14:10,269
object-oriented design to architecture

00:14:06,100 --> 00:14:12,730
itself oh it's a proven formula for

00:14:10,269 --> 00:14:14,769
successful solid design it's been around

00:14:12,730 --> 00:14:16,810
with us for quite a while there may be

00:14:14,769 --> 00:14:21,490
other trends that are emerging now if

00:14:16,810 --> 00:14:22,839
you are in the other talk but uh we

00:14:21,490 --> 00:14:26,470
think of classes communicating via

00:14:22,839 --> 00:14:28,510
messages we can think that that is the

00:14:26,470 --> 00:14:31,870
equivalent of applications communicating

00:14:28,510 --> 00:14:36,850
via messages some other Oh principles

00:14:31,870 --> 00:14:39,130
that we can apply cohesion an

00:14:36,850 --> 00:14:41,519
application is a group of components

00:14:39,130 --> 00:14:44,140
that perform a function on the same data

00:14:41,519 --> 00:14:46,630
we can apply the single responsibility

00:14:44,140 --> 00:14:49,570
principle to applications an application

00:14:46,630 --> 00:14:51,190
should do one well defined thing we

00:14:49,570 --> 00:14:53,199
should use api's which are kind of

00:14:51,190 --> 00:14:54,790
contract we can add methods but not

00:14:53,199 --> 00:14:55,930
change methods already there because we

00:14:54,790 --> 00:14:57,579
don't want to violate the contract that

00:14:55,930 --> 00:14:59,949
we have with the rest of the ecosystem

00:14:57,579 --> 00:15:01,690
and we can change our underlying

00:14:59,949 --> 00:15:03,699
implementation without changing the

00:15:01,690 --> 00:15:08,110
methods that we expose via our api's or

00:15:03,699 --> 00:15:10,120
weak inversion our AP is we don't care

00:15:08,110 --> 00:15:12,640
about which application sends a message

00:15:10,120 --> 00:15:15,190
or which application processes the

00:15:12,640 --> 00:15:17,529
message we just care that the messages

00:15:15,190 --> 00:15:18,850
are being sent and the correct consumer

00:15:17,529 --> 00:15:20,079
will be listening to the message that

00:15:18,850 --> 00:15:23,019
we're sending it take the appropriate

00:15:20,079 --> 00:15:25,060
action we can create client specific

00:15:23,019 --> 00:15:27,010
interfaces using api's and the clients

00:15:25,060 --> 00:15:29,740
might be other applications they may be

00:15:27,010 --> 00:15:33,970
users it may be a data dump that you

00:15:29,740 --> 00:15:37,420
want to send us someone this by creating

00:15:33,970 --> 00:15:40,209
api's you'll find that you can re-enable

00:15:37,420 --> 00:15:42,160
at sort of special feature of oo where

00:15:40,209 --> 00:15:43,779
you are able to use code in novel ways

00:15:42,160 --> 00:15:45,699
new ways that you weren't exactly

00:15:43,779 --> 00:15:48,600
predicting at the beginning when you

00:15:45,699 --> 00:15:50,670
were doing your your initial coding so

00:15:48,600 --> 00:15:52,110
so how many of you have legacy

00:15:50,670 --> 00:15:55,079
applications that you're working with

00:15:52,110 --> 00:15:56,819
and let me define legacy application for

00:15:55,079 --> 00:15:58,889
you it's not an application that is a

00:15:56,819 --> 00:16:01,050
year old or six months old or two years

00:15:58,889 --> 00:16:03,149
old it's not an application necessarily

00:16:01,050 --> 00:16:04,470
that's version 2 of rails it's an

00:16:03,149 --> 00:16:07,470
application that you have stopped paying

00:16:04,470 --> 00:16:09,810
attention to how many of you have legacy

00:16:07,470 --> 00:16:13,790
applications okay there's a few more

00:16:09,810 --> 00:16:16,170
hands up so age is not measured in in

00:16:13,790 --> 00:16:18,029
chronological time it's it's spans of

00:16:16,170 --> 00:16:19,410
attention I know that there are things

00:16:18,029 --> 00:16:21,420
that I worked on six months ago that I

00:16:19,410 --> 00:16:23,250
haven't looked at since then but if I go

00:16:21,420 --> 00:16:24,569
back I don't have them in my head

00:16:23,250 --> 00:16:26,519
anymore I don't have a picture of what

00:16:24,569 --> 00:16:28,019
they're all about my head anymore I have

00:16:26,519 --> 00:16:29,940
to look at my test suite to figure out

00:16:28,019 --> 00:16:31,470
what were the what were the special edge

00:16:29,940 --> 00:16:35,670
cases that led me to design in this

00:16:31,470 --> 00:16:37,319
particular way there are some things

00:16:35,670 --> 00:16:38,970
that I think are really important and

00:16:37,319 --> 00:16:40,889
I'm writing a book with Carrie Miller

00:16:38,970 --> 00:16:42,959
about legacy applications and one of the

00:16:40,889 --> 00:16:45,120
sort of key things that we agreed on at

00:16:42,959 --> 00:16:47,339
the beginning was that it's important to

00:16:45,120 --> 00:16:48,509
think about not only the mechanics of

00:16:47,339 --> 00:16:50,220
dealing with legacy code but the

00:16:48,509 --> 00:16:52,709
attitude with which we approach legacy

00:16:50,220 --> 00:16:54,720
code legacy code is not broken it is

00:16:52,709 --> 00:16:56,699
unfamiliar code it was created under

00:16:54,720 --> 00:17:00,089
circumstances that you don't understand

00:16:56,699 --> 00:17:01,620
or maybe that don't exist anymore the

00:17:00,089 --> 00:17:04,559
people who are responsible for legacy

00:17:01,620 --> 00:17:06,959
code were not stupid they were working

00:17:04,559 --> 00:17:08,429
under conditions that you don't know

00:17:06,959 --> 00:17:09,659
about they were sincere they were

00:17:08,429 --> 00:17:12,059
hardworking and they were doing their

00:17:09,659 --> 00:17:15,870
very best don't get blamed no good can

00:17:12,059 --> 00:17:19,110
come from that a legacy application

00:17:15,870 --> 00:17:21,329
contains vital information about your

00:17:19,110 --> 00:17:23,280
business there are edge cases that you

00:17:21,329 --> 00:17:25,079
don't know about that are just sort of

00:17:23,280 --> 00:17:27,360
magically handled in the background you

00:17:25,079 --> 00:17:28,620
want to mine those legacy applications

00:17:27,360 --> 00:17:30,679
for that information and for that

00:17:28,620 --> 00:17:35,100
knowledge otherwise you're throwing away

00:17:30,679 --> 00:17:37,620
person years of thought and in problem

00:17:35,100 --> 00:17:39,059
solving so it's very tempting to say we

00:17:37,620 --> 00:17:40,080
want to redo from start and someone

00:17:39,059 --> 00:17:43,320
actually brought that up in the

00:17:40,080 --> 00:17:45,809
refactoring workshop yesterday but

00:17:43,320 --> 00:17:47,940
you're you're throwing a lot of way in

00:17:45,809 --> 00:17:50,970
exchange for the privilege of green

00:17:47,940 --> 00:17:56,010
fielding so how do we actually tackle

00:17:50,970 --> 00:17:57,780
these legacy applications dismantle God

00:17:56,010 --> 00:17:58,950
classes you can use code climate define

00:17:57,780 --> 00:18:01,290
the classes that are the biggest

00:17:58,950 --> 00:18:01,730
violators and and start taking them

00:18:01,290 --> 00:18:05,060
apart

00:18:01,730 --> 00:18:09,310
is my last job we had a user model that

00:18:05,060 --> 00:18:12,110
understood 2000 over 2000 messages and

00:18:09,310 --> 00:18:13,730
that's I don't think we were unique who

00:18:12,110 --> 00:18:19,190
has a user model that's less than 100

00:18:13,730 --> 00:18:20,420
lines of code and think so so I had the

00:18:19,190 --> 00:18:22,550
privilege of working with Corey Haines

00:18:20,420 --> 00:18:25,280
and he taught me about modules and how

00:18:22,550 --> 00:18:27,710
to use modules to contain as a container

00:18:25,280 --> 00:18:29,870
for behavior and he named them I used to

00:18:27,710 --> 00:18:31,970
I was an English major so I came up with

00:18:29,870 --> 00:18:33,800
clever mythological names for all stuff

00:18:31,970 --> 00:18:38,120
that I created and he named things like

00:18:33,800 --> 00:18:44,300
works with LA or implements such and

00:18:38,120 --> 00:18:45,740
such and he was right and I was wrong so

00:18:44,300 --> 00:18:46,850
you might have a requires permissions

00:18:45,740 --> 00:18:48,680
module that you including your

00:18:46,850 --> 00:18:51,110
controllers or it works with date ranges

00:18:48,680 --> 00:18:53,450
module that provides a set of name of

00:18:51,110 --> 00:18:55,220
name scopes for several of your modules

00:18:53,450 --> 00:18:59,410
and although I would love to call those

00:18:55,220 --> 00:19:02,900
like Cerberus and psychopomp right so

00:18:59,410 --> 00:19:04,220
look at engines very carefully engines

00:19:02,900 --> 00:19:06,620
are really really neat and I think

00:19:04,220 --> 00:19:10,460
they're really underutilized devised is

00:19:06,620 --> 00:19:12,620
a great example of an engine think about

00:19:10,460 --> 00:19:14,660
moving models like engines let you take

00:19:12,620 --> 00:19:17,060
an entire MVC stack and make it portable

00:19:14,660 --> 00:19:18,830
and package it as a gem so think about

00:19:17,060 --> 00:19:20,270
taking your models and your business

00:19:18,830 --> 00:19:22,310
logic and your controllers and views

00:19:20,270 --> 00:19:23,870
that are about a single thing and moving

00:19:22,310 --> 00:19:25,910
it into an engine because once you do

00:19:23,870 --> 00:19:28,040
that you can pick those engines up and

00:19:25,910 --> 00:19:29,930
build an entire application around it

00:19:28,040 --> 00:19:32,330
it's a nice way to extract your code and

00:19:29,930 --> 00:19:36,230
then refactor it into a small standalone

00:19:32,330 --> 00:19:38,540
application the observer pattern is

00:19:36,230 --> 00:19:41,270
really cool rails observers are

00:19:38,540 --> 00:19:43,310
synchronous which makes no sense to me

00:19:41,270 --> 00:19:46,430
at all and to me violates the principle

00:19:43,310 --> 00:19:48,290
of least surprised be explicit about the

00:19:46,430 --> 00:19:49,850
behaviors that you want to happen when

00:19:48,290 --> 00:19:53,510
an object changes state and do it

00:19:49,850 --> 00:19:55,910
asynchronously using your message bus I

00:19:53,510 --> 00:19:58,150
believe that persistence in this day and

00:19:55,910 --> 00:20:01,100
age should be an asynchronous operation

00:19:58,150 --> 00:20:03,230
if you're validating before you're

00:20:01,100 --> 00:20:05,240
trying to do a right most of the time

00:20:03,230 --> 00:20:06,980
your right is going to happen I would

00:20:05,240 --> 00:20:08,960
say it's a 10 9 s your right is going to

00:20:06,980 --> 00:20:10,400
happen so deal with the exceptions but

00:20:08,960 --> 00:20:14,020
don't say hey did you really write to

00:20:10,400 --> 00:20:14,020
the database okay I can move on

00:20:14,419 --> 00:20:20,059
another area of plumbing you don't want

00:20:16,129 --> 00:20:22,039
to skip on is your API design I could I

00:20:20,059 --> 00:20:23,389
would even go so far as to say since we

00:20:22,039 --> 00:20:25,970
don't have interfaces you can use your

00:20:23,389 --> 00:20:27,529
API to refactor your models your fat

00:20:25,970 --> 00:20:29,779
models that user model I talked about

00:20:27,529 --> 00:20:31,879
with two thousand messages we found out

00:20:29,779 --> 00:20:34,369
when we built our API we built it piece

00:20:31,879 --> 00:20:36,109
by piece by piece there were 12 methods

00:20:34,369 --> 00:20:40,970
that it needed to expose to the world

00:20:36,109 --> 00:20:44,359
out of that 2000 think about

00:20:40,970 --> 00:20:45,590
synchronicity versus a synchronicity one

00:20:44,359 --> 00:20:48,019
example is you have a client application

00:20:45,590 --> 00:20:50,059
that needs to authenticate a user that's

00:20:48,019 --> 00:20:51,889
a great use of an off of a synchronous

00:20:50,059 --> 00:20:53,570
call you send the credentials across you

00:20:51,889 --> 00:20:56,450
get the auth token back it's a fairly

00:20:53,570 --> 00:20:58,759
lightweight operation you want to use a

00:20:56,450 --> 00:21:00,409
message queue for asynchronous calls so

00:20:58,759 --> 00:21:01,909
the persistence example I was talking

00:21:00,409 --> 00:21:03,919
about maybe the user has updated their

00:21:01,909 --> 00:21:05,600
preferences and you can afford to wait

00:21:03,919 --> 00:21:07,609
five seconds for that change to take

00:21:05,600 --> 00:21:09,139
effect they change some of their

00:21:07,609 --> 00:21:11,059
attribute they correct a misspelling of

00:21:09,139 --> 00:21:13,190
their company name you can wait for that

00:21:11,059 --> 00:21:16,489
change to take effect so whatever you

00:21:13,190 --> 00:21:19,600
can do asynchronously for excuse me for

00:21:16,489 --> 00:21:19,600
performance reasons do it asynchronously

00:21:20,200 --> 00:21:26,029
if you have sets of functionality that

00:21:24,100 --> 00:21:28,429
could potentially serve multiple

00:21:26,029 --> 00:21:31,220
applications in your ecosystem extract

00:21:28,429 --> 00:21:34,129
them into services I did use the S word

00:21:31,220 --> 00:21:36,830
but just this once persistence

00:21:34,129 --> 00:21:38,210
authentication authorization reporting

00:21:36,830 --> 00:21:42,080
all of these are great candidates from

00:21:38,210 --> 00:21:44,480
moving off into applications that expose

00:21:42,080 --> 00:21:48,889
a layer exposed functionality through an

00:21:44,480 --> 00:21:51,529
API i would i would encourage all of you

00:21:48,889 --> 00:21:52,730
to explore the presenter pattern you

00:21:51,529 --> 00:21:56,659
might be familiar with a tool called

00:21:52,730 --> 00:21:58,549
draper there are other tools that are

00:21:56,659 --> 00:22:00,409
that are that perform similar functions

00:21:58,549 --> 00:22:02,450
that basically allow you to be really

00:22:00,409 --> 00:22:04,159
really explicit about the methods and

00:22:02,450 --> 00:22:05,570
attributes of your objects you want to

00:22:04,159 --> 00:22:08,889
expose to the world and help you hide

00:22:05,570 --> 00:22:12,710
the internals I'm a fan of faceted

00:22:08,889 --> 00:22:15,409
because I wrote it and yes all my open

00:22:12,710 --> 00:22:17,389
source projects have logos it's a

00:22:15,409 --> 00:22:20,179
declarative framework for building api's

00:22:17,389 --> 00:22:22,220
so if you've ever used mongoid you know

00:22:20,179 --> 00:22:25,999
how you instead of having a schema you

00:22:22,220 --> 00:22:26,970
say field xfield why faceted let you do

00:22:25,999 --> 00:22:29,070
the same thing with

00:22:26,970 --> 00:22:31,070
atures except those attributes that you

00:22:29,070 --> 00:22:34,350
declare can be methods in the presenter

00:22:31,070 --> 00:22:35,940
like a decorator for example or it might

00:22:34,350 --> 00:22:38,400
be a method on the object that you're

00:22:35,940 --> 00:22:41,789
calling work in the direct attribute on

00:22:38,400 --> 00:22:43,470
the object that you're presenting so

00:22:41,789 --> 00:22:45,000
we've talked about different refactoring

00:22:43,470 --> 00:22:48,179
techniques and some of the philosophical

00:22:45,000 --> 00:22:49,530
approaches to refactoring that you might

00:22:48,179 --> 00:22:51,510
take some of the ways that you might

00:22:49,530 --> 00:22:52,860
attack your legacy application break it

00:22:51,510 --> 00:22:55,380
into smaller pieces that are more

00:22:52,860 --> 00:22:57,179
manageable what do we get on the other

00:22:55,380 --> 00:22:59,429
side of refactoring you might end up

00:22:57,179 --> 00:23:01,530
with something like this this is

00:22:59,429 --> 00:23:03,030
actually very very similar to the

00:23:01,530 --> 00:23:06,539
architecture I built at my last job

00:23:03,030 --> 00:23:09,360
before i came into apartment we took our

00:23:06,539 --> 00:23:13,970
legacy application this awful monolithic

00:23:09,360 --> 00:23:16,710
thing that was ironically called Diablo

00:23:13,970 --> 00:23:18,919
very aptly named and we made it our

00:23:16,710 --> 00:23:22,470
persistence API that's all I did anymore

00:23:18,919 --> 00:23:24,270
we slowly stripped out all of the we

00:23:22,470 --> 00:23:26,789
went interface by interface user group

00:23:24,270 --> 00:23:29,039
by user group and stripped it out into

00:23:26,789 --> 00:23:32,190
into small applications so we ended up

00:23:29,039 --> 00:23:34,950
with reporting API persistence API and a

00:23:32,190 --> 00:23:37,250
messaging API and everything else in our

00:23:34,950 --> 00:23:39,809
in our suite of internal and external

00:23:37,250 --> 00:23:43,080
applications including iOS apps and

00:23:39,809 --> 00:23:46,260
Android apps use this layer to

00:23:43,080 --> 00:23:48,090
communicate with the business so we had

00:23:46,260 --> 00:23:50,669
our consumer application we had a few

00:23:48,090 --> 00:23:52,260
different internal applications we had a

00:23:50,669 --> 00:23:54,020
hack day one day and if you don't do

00:23:52,260 --> 00:23:57,240
hack days I really strongly recommend it

00:23:54,020 --> 00:24:01,020
we had a hack day I happen to have built

00:23:57,240 --> 00:24:03,510
our reporting infrastructure with

00:24:01,020 --> 00:24:05,880
faceted I'd like dropped it in just just

00:24:03,510 --> 00:24:08,100
as an example to show someone how easy

00:24:05,880 --> 00:24:09,750
it was to integrate so we spent like a

00:24:08,100 --> 00:24:12,150
couple of hours doing that and our next

00:24:09,750 --> 00:24:15,030
hack day someone came up with the idea

00:24:12,150 --> 00:24:17,070
we had a sales team and salespeople are

00:24:15,030 --> 00:24:18,690
highly motivated by numbers and by

00:24:17,070 --> 00:24:21,360
statistics and they're also very

00:24:18,690 --> 00:24:22,770
competitive so someone at the hack they

00:24:21,360 --> 00:24:24,299
had the idea of what if we built a

00:24:22,770 --> 00:24:26,270
dashboard for sales that gave them

00:24:24,299 --> 00:24:29,100
real-time data on how they were selling

00:24:26,270 --> 00:24:30,690
broken out by sales team wouldn't that

00:24:29,100 --> 00:24:33,270
be cool and I was like you know what we

00:24:30,690 --> 00:24:35,520
have an API for that already so two of

00:24:33,270 --> 00:24:37,200
us over the period over a period of like

00:24:35,520 --> 00:24:39,810
six hours most of which was taken up by

00:24:37,200 --> 00:24:42,510
you I

00:24:39,810 --> 00:24:44,280
built this dashboard that now it lives

00:24:42,510 --> 00:24:47,550
on giant television sets throughout the

00:24:44,280 --> 00:24:49,770
sales area and we actually saw an uptick

00:24:47,550 --> 00:24:51,810
in sales performance as a result of

00:24:49,770 --> 00:24:53,700
providing them with this information it

00:24:51,810 --> 00:24:55,290
was a great example I thought of a

00:24:53,700 --> 00:24:59,100
client specific or user specific

00:24:55,290 --> 00:25:01,410
interface that was a delight er that was

00:24:59,100 --> 00:25:03,000
that was unexpected it was novel use of

00:25:01,410 --> 00:25:06,870
infrastructure that we have previously

00:25:03,000 --> 00:25:07,980
built so some of the benefits on the

00:25:06,870 --> 00:25:09,660
other side of this because this is a

00:25:07,980 --> 00:25:11,970
very arduous process and it's going to

00:25:09,660 --> 00:25:14,310
take you a year at least depending on

00:25:11,970 --> 00:25:15,600
the size of your application you need to

00:25:14,310 --> 00:25:17,670
think about the positives you're going

00:25:15,600 --> 00:25:20,700
to get on the other side of this and use

00:25:17,670 --> 00:25:22,260
that as motivation to to get through the

00:25:20,700 --> 00:25:24,210
slog work that you're going to have to

00:25:22,260 --> 00:25:27,330
do as you break your infrastructure up

00:25:24,210 --> 00:25:28,650
into smaller and smaller pieces you are

00:25:27,330 --> 00:25:30,090
going to end up with the reduced cost of

00:25:28,650 --> 00:25:32,340
change according to sending sending

00:25:30,090 --> 00:25:35,580
match this is the principal virtue of

00:25:32,340 --> 00:25:37,980
object oriented design you're going to

00:25:35,580 --> 00:25:41,580
have the cost and friction around adding

00:25:37,980 --> 00:25:42,990
new features greatly reduced another

00:25:41,580 --> 00:25:44,880
thing that we there was an unexpected

00:25:42,990 --> 00:25:46,410
side effect for us we had different

00:25:44,880 --> 00:25:50,640
teams that were focused on building

00:25:46,410 --> 00:25:51,720
different small applications we found

00:25:50,640 --> 00:25:55,290
that the teams developed a great

00:25:51,720 --> 00:25:56,910
autonomy when I started there we had two

00:25:55,290 --> 00:25:59,370
weeks prints and every two weeks we

00:25:56,910 --> 00:26:00,930
would release and it was kind of a big

00:25:59,370 --> 00:26:03,090
deal in all the engineers it was

00:26:00,930 --> 00:26:05,730
everyone on on deck you couldn't work

00:26:03,090 --> 00:26:07,890
from home on those days QA was involved

00:26:05,730 --> 00:26:09,210
there was always some sort of crisis

00:26:07,890 --> 00:26:10,500
that would emerge because it's a

00:26:09,210 --> 00:26:12,990
production deployment and that sort of

00:26:10,500 --> 00:26:15,930
thing this happens but as we broke into

00:26:12,990 --> 00:26:17,940
smaller apps we found that team a could

00:26:15,930 --> 00:26:20,970
deploy on Tuesday afternoon at the

00:26:17,940 --> 00:26:23,580
height of business and because messages

00:26:20,970 --> 00:26:25,110
were stacking up in a queue the

00:26:23,580 --> 00:26:26,970
application was ready to process the

00:26:25,110 --> 00:26:29,100
messages when it came back online and

00:26:26,970 --> 00:26:31,470
the rest of the absent ecosystem had no

00:26:29,100 --> 00:26:33,360
idea that for that minute and a half

00:26:31,470 --> 00:26:37,290
that it took to spin up the Heroku app

00:26:33,360 --> 00:26:38,910
that that service was unavailable so we

00:26:37,290 --> 00:26:40,590
all be all the teams became autonomous

00:26:38,910 --> 00:26:42,360
and were able to release that will and

00:26:40,590 --> 00:26:45,540
we no longer had those bi-weekly

00:26:42,360 --> 00:26:47,970
releases whenever a feature was ready we

00:26:45,540 --> 00:26:49,830
shipped it and that's supposed to be

00:26:47,970 --> 00:26:52,529
what agile is all about anyway

00:26:49,830 --> 00:26:55,049
so downtime became really really low

00:26:52,529 --> 00:26:57,029
impact another thing we found is that uh

00:26:55,049 --> 00:26:58,740
as I mentioned before there a lot of new

00:26:57,029 --> 00:27:01,350
tabs who are entering our industry and

00:26:58,740 --> 00:27:03,390
one of the hardest things for people to

00:27:01,350 --> 00:27:06,059
do when they're starting at a new

00:27:03,390 --> 00:27:08,190
company let alone a new career is take a

00:27:06,059 --> 00:27:09,929
complicated system and build a picture

00:27:08,190 --> 00:27:11,309
of it in their head and if you don't

00:27:09,929 --> 00:27:13,919
have that picture of what your system

00:27:11,309 --> 00:27:17,130
looks like in your head any contribution

00:27:13,919 --> 00:27:20,399
you make to it is likely to be wrong or

00:27:17,130 --> 00:27:22,649
duplicated or something that that really

00:27:20,399 --> 00:27:26,220
should be short-lived but the long slip

00:27:22,649 --> 00:27:28,799
code is our is a temporary code so if

00:27:26,220 --> 00:27:30,659
you break your architecture up into lots

00:27:28,799 --> 00:27:32,279
of small applications these small

00:27:30,659 --> 00:27:33,980
applications are easy to understand it's

00:27:32,279 --> 00:27:36,450
easy to look at an app that handles

00:27:33,980 --> 00:27:38,220
authorization and understand how it

00:27:36,450 --> 00:27:40,529
works and then you can move on to the

00:27:38,220 --> 00:27:42,480
next piece that is actually its own repo

00:27:40,529 --> 00:27:44,760
its own application and see how that

00:27:42,480 --> 00:27:46,649
interacts with authentication and you

00:27:44,760 --> 00:27:48,029
can slowly build up your picture instead

00:27:46,649 --> 00:27:53,880
of having to wrap your head around this

00:27:48,029 --> 00:27:55,860
big monolithic group of functionality we

00:27:53,880 --> 00:27:57,750
talked about TDD before and how over

00:27:55,860 --> 00:27:59,549
time you can't do it anymore when you

00:27:57,750 --> 00:28:01,200
have small applications and especially

00:27:59,549 --> 00:28:03,779
when you remove persistence from the

00:28:01,200 --> 00:28:06,450
picture your test Suites run fast again

00:28:03,779 --> 00:28:08,490
and you can actually do true TDD where

00:28:06,450 --> 00:28:11,070
you change one line of code to change

00:28:08,490 --> 00:28:13,230
the message of your failure run your

00:28:11,070 --> 00:28:14,639
tests see the message go back and change

00:28:13,230 --> 00:28:17,309
the message and repeat until you're

00:28:14,639 --> 00:28:19,620
happy with the code another sort of

00:28:17,309 --> 00:28:21,840
novel thing that that emerges from this

00:28:19,620 --> 00:28:23,610
sort of architecture is you can do a be

00:28:21,840 --> 00:28:26,279
testing on your infrastructure if you're

00:28:23,610 --> 00:28:27,779
not familiar in sort of marketing in the

00:28:26,279 --> 00:28:31,260
marketing world a B testing is where you

00:28:27,779 --> 00:28:33,570
present you have a landing page that has

00:28:31,260 --> 00:28:35,580
a headline at the top on the right in

00:28:33,570 --> 00:28:37,789
eighteen point type and you have another

00:28:35,580 --> 00:28:40,080
landing page that has a little left in

00:28:37,789 --> 00:28:41,880
eighteen point type actually you want to

00:28:40,080 --> 00:28:43,679
change one thing at a time and use you

00:28:41,880 --> 00:28:45,990
you direct a certain amount of traffic

00:28:43,679 --> 00:28:48,480
to either landing page and see which one

00:28:45,990 --> 00:28:49,980
performs better so you can do

00:28:48,480 --> 00:28:51,960
multivariate testing where you change

00:28:49,980 --> 00:28:54,179
lots of things at the same time and you

00:28:51,960 --> 00:28:55,860
throw them up and see what sticks and

00:28:54,179 --> 00:28:57,600
over time you arrive at you know what is

00:28:55,860 --> 00:28:59,909
the optimal solution based on actual

00:28:57,600 --> 00:29:01,799
behavior with a with a small app

00:28:59,909 --> 00:29:03,210
architecture that's message based again

00:29:01,799 --> 00:29:05,700
we don't care who can

00:29:03,210 --> 00:29:07,140
the message multiple applications can

00:29:05,700 --> 00:29:09,210
consume the same message and do

00:29:07,140 --> 00:29:10,980
different things with it so let's say

00:29:09,210 --> 00:29:12,270
you're thinking about moving to MongoDB

00:29:10,980 --> 00:29:14,789
but you've heard that there might be

00:29:12,270 --> 00:29:16,380
some performance issues with it add

00:29:14,789 --> 00:29:18,659
another persistence layer to your

00:29:16,380 --> 00:29:21,240
ecosystem so you have your postgres

00:29:18,659 --> 00:29:23,130
listener that's consuming messages that

00:29:21,240 --> 00:29:25,679
have to do with saving models you also

00:29:23,130 --> 00:29:27,659
have your MongoDB listener that is doing

00:29:25,679 --> 00:29:29,220
the same thing and you can wire each of

00:29:27,659 --> 00:29:32,220
them up to your reporting applications

00:29:29,220 --> 00:29:34,860
who was one performs better you can

00:29:32,220 --> 00:29:36,750
direct if you're not using direct if

00:29:34,860 --> 00:29:39,210
you're not using messages to allow

00:29:36,750 --> 00:29:41,520
multiple consumers you can direct x

00:29:39,210 --> 00:29:44,270
amount of traffic via to the api of one

00:29:41,520 --> 00:29:47,549
application versus the other application

00:29:44,270 --> 00:29:49,470
one of the other benefits you get is

00:29:47,549 --> 00:29:51,630
that you have flexibility in the tools

00:29:49,470 --> 00:29:54,899
that you bring to bear you can build an

00:29:51,630 --> 00:29:59,190
app in nodejs that understands json and

00:29:54,899 --> 00:30:00,510
point it to your JSON API you can have

00:29:59,190 --> 00:30:02,159
small applications that are better

00:30:00,510 --> 00:30:04,919
suited for Sinatra that don't need all

00:30:02,159 --> 00:30:08,760
the overhead rails you can build your

00:30:04,919 --> 00:30:11,130
application in elixir and as long as it

00:30:08,760 --> 00:30:14,220
understands HTTP it will talk to the

00:30:11,130 --> 00:30:15,870
other applications in the ecosystem what

00:30:14,220 --> 00:30:17,970
this really gives us it allows us to

00:30:15,870 --> 00:30:19,679
live up to the ideal that we're sort of

00:30:17,970 --> 00:30:21,450
hinting at the beginning with ad hoc

00:30:19,679 --> 00:30:24,240
architecture which is the

00:30:21,450 --> 00:30:26,820
democratization of architecture I

00:30:24,240 --> 00:30:29,130
believe that architecture is something

00:30:26,820 --> 00:30:32,220
that although once it was the province

00:30:29,130 --> 00:30:33,450
of architects that that job title is

00:30:32,220 --> 00:30:36,090
sort of on the way out and a lot of

00:30:33,450 --> 00:30:37,830
respects especially at smaller more

00:30:36,090 --> 00:30:39,149
agile companies and instead

00:30:37,830 --> 00:30:42,000
architectures something that all of us

00:30:39,149 --> 00:30:44,370
own and all of us contribute to or all

00:30:42,000 --> 00:30:46,169
of us take something away from so it

00:30:44,370 --> 00:30:48,210
behooves us to be the best architects

00:30:46,169 --> 00:30:53,250
that we can be because there is a shared

00:30:48,210 --> 00:30:54,929
responsibility now that the ideal that

00:30:53,250 --> 00:30:57,299
we want to accomplish is that all of us

00:30:54,929 --> 00:30:59,490
are equal participants in a democratic

00:30:57,299 --> 00:31:02,909
system of architecture that quality will

00:30:59,490 --> 00:31:04,860
emerge from so I've done I've taken this

00:31:02,909 --> 00:31:08,370
approach at several different shops that

00:31:04,860 --> 00:31:09,960
I've worked at you can to start small be

00:31:08,370 --> 00:31:11,730
really thoughtful if you don't agree

00:31:09,960 --> 00:31:14,100
with the tactics and strategies that

00:31:11,730 --> 00:31:15,720
I've outlined don't follow them but do

00:31:14,100 --> 00:31:19,289
something don't be

00:31:15,720 --> 00:31:22,169
prisoner it's your legacy code I'm Cory

00:31:19,289 --> 00:31:23,400
banta Khan twitter if you think some of

00:31:22,169 --> 00:31:25,110
the ideas that I've shared today are

00:31:23,400 --> 00:31:27,539
interesting go to smash the monolith

00:31:25,110 --> 00:31:29,250
calm and sign up to find out more about

00:31:27,539 --> 00:31:32,700
the book that Carrie Miller and I are

00:31:29,250 --> 00:31:34,049
writing on this very topic I thank you

00:31:32,700 --> 00:31:36,450
for your time and attention and I hope

00:31:34,049 --> 00:31:37,830
that I've been helpful to you and

00:31:36,450 --> 00:31:39,210
sharing some of the things that I

00:31:37,830 --> 00:31:41,429
learned as I've worked with legacy apps

00:31:39,210 --> 00:31:42,500
it looks like we have nine minutes and

00:31:41,429 --> 00:31:45,500
I'd like to open it up to questions

00:31:42,500 --> 00:31:45,500

YouTube URL: https://www.youtube.com/watch?v=zzv-uv39954


