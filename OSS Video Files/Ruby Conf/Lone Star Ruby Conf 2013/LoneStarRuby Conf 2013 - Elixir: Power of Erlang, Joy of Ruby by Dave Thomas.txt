Title: LoneStarRuby Conf 2013 - Elixir: Power of Erlang, Joy of Ruby by Dave Thomas
Publication date: 2020-01-28
Playlist: Lone Star Ruby Conf 2013
Description: 
	Dave Thomas
Elixir: Power of Erlang, Joy of Ruby

I'm a language nut. I love trying them out, and I love thinking about their design and implementation. (I know, it's sad.)

I came across Ruby in 1998 because I was an avid reader of comp.lang.misc (ask your parents). I downloaded it, compiled it, and fell in love. As with any time you fall in love, it's difficult to explain why. It just worked the way I work, and it had enough depth to keep me interested.

Fast forward 15 years. All that time I'd been looking for something new that gave me the same feeling.

Then I came across Elixir, a language by JosÃ© Valim, that puts a humane, Ruby-like syntax on the Erlang VM.

Now I'm dangerous. I want other people to see just how great this is. I want to evangelize. I won't try to convert you away from Ruby. But I might just persuade you to add Elixir to your toolset.

So come along and let me show you the things that I think make Elixir a serious alternative for writing highly reliable, scalable, and performant server code.

And, more important, let me show you some fun stuff.

Help us caption & translate this video!

http://amara.org/v/FG9C/
Captions: 
	00:00:20,420 --> 00:00:22,520
DAVE THOMAS: How are you all doing? Good?

00:00:22,520 --> 00:00:23,141
AUDIENCE: Cold!

00:00:23,540 --> 00:00:24,470
D.T.: Fata- cold?

00:00:24,470 --> 00:00:25,069
AUDIENCE: Yeah.

00:00:25,069 --> 00:00:26,789
D.T.: Then come up here and move your arms

00:00:26,789 --> 00:00:28,089
around a bit. It's great.

00:00:30,860 --> 00:00:35,760
Let me start off by explaining something, right. I

00:00:35,760 --> 00:00:39,710
love Ruby. I've been doing Ruby since 1998. I

00:00:39,710 --> 00:00:43,050
have read the Pick Axe book four times. And,

00:00:43,050 --> 00:00:47,199
in fact, the latest revision went into print, well,

00:00:47,199 --> 00:00:50,430
came off the presses on Friday, last week, a

00:00:50,430 --> 00:00:53,170
week ago. And there's actually four copies to be

00:00:53,170 --> 00:00:55,030
won lying around somewhere.

00:00:55,030 --> 00:00:57,390
OK, so, I have a commitment to Ruby. Don't

00:00:57,390 --> 00:01:01,160
get me wrong, right. So, I'm not here to

00:01:01,160 --> 00:01:04,690
say, all you Ruby programmers are, you know, shouldn't

00:01:04,690 --> 00:01:11,399
be here, it's crap. That's not the case.

00:01:11,399 --> 00:01:13,500
However, I also think that we owe it to

00:01:13,500 --> 00:01:16,520
ourselves, all of us, to keep an eye on

00:01:16,520 --> 00:01:19,070
what's going on. Because if we don't, as Sandi

00:01:19,070 --> 00:01:20,970
and I were discussing over lunch, if you don't

00:01:20,970 --> 00:01:23,280
keep an eye on what's going on, then eventually

00:01:23,280 --> 00:01:24,369
you will be out of date.

00:01:24,369 --> 00:01:28,539
I, how many people here used to go to\ \

00:01:28,539 --> 00:01:32,219
the No Fluff, Just Stuff Conference things? A few.\

00:01:32,219 --> 00:01:34,969
\ Not many. I'm actually kind of proud of the\

00:01:34,969 --> 00:01:37,940
\ fact that I've actually been banned from speaking

00:01:37,940 --> 00:01:38,789
at\ \

00:01:38,789 --> 00:01:40,990
those. Because I used to go to a Java,\ \

00:01:40,990 --> 00:01:44,560
Java Conferences to talk about Ruby. And they said,\

00:01:44,560 --> 00:01:46,039
\ oh, you can't do that anymore. Go talk about\

00:01:46,039 --> 00:01:48,000
\ Java. And I said, no, I'm not gonna talk\

00:01:48,000 --> 00:01:49,880
\ about Java anymore.\

00:01:49,880 --> 00:01:51,120
\ So here I am in a Ruby conference. I\

00:01:51,120 --> 00:01:56,170
\ am gonna talk about Elixir. So, why, why I'm\

00:01:56,170 --> 00:02:00,080
\ gonna talk about Elixir. Elixir, to me, is

00:02:00,080 --> 00:02:02,810
of the gateway to what I used to do\ \

00:02:02,810 --> 00:02:05,979
to what I will be doing. And I've been\ \

00:02:05,979 --> 00:02:08,170
looking for this for ten years and I've finally\ \

00:02:08,170 --> 00:02:10,170
found it.\ \

00:02:10,170 --> 00:02:15,130
So, the reality, I think, is that the future\ \

00:02:15,130 --> 00:02:19,760
is functional and the future is concurrent. Those two\

00:02:19,760 --> 00:02:22,170
\ technologies combined are pretty much the

00:02:22,170 --> 00:02:23,500
only way we\ \

00:02:23,500 --> 00:02:27,959
can continue to develop in, say, develop in terms\

00:02:27,959 --> 00:02:31,459
\ of like, carry on, get things better, in software.\

00:02:31,459 --> 00:02:33,720
\ We're kind of running into all sorts of obstacles.\

00:02:33,720 --> 00:02:38,220
\ I'm sure you've all heard of. That's not gonna\

00:02:38,220 --> 00:02:43,390
\ work. All right. Don't play. You've all heard

00:02:43,390 --> 00:02:44,770
of\ \

00:02:44,770 --> 00:02:51,770
Moore's Law. For the longest time I couldn't work\

00:02:52,690 --> 00:02:56,530
\ out what he had to do with it. But,\

00:02:56,530 --> 00:02:59,730
\ you know. Something like, you know, every

00:02:59,730 --> 00:03:00,260
year you\ \

00:03:00,260 --> 00:03:04,490
get twice as ugly or something. I don't know\ \

00:03:04,490 --> 00:03:06,920
what it is.\ \

00:03:06,920 --> 00:03:09,040
But, does he or does he not look like\ \

00:03:09,040 --> 00:03:11,380
- this, this is Gordon Moore, right. He looks,\ \

00:03:11,380 --> 00:03:16,019
to me, like Wendy's Dave Thomas guy, don't you\

00:03:16,019 --> 00:03:18,390
\ think? But, and he's cheery. The reason he's

00:03:18,390 --> 00:03:18,510
cheery\ \

00:03:18,510 --> 00:03:21,250
is he's worth four billion dollars. But, he's cheery.\

00:03:21,250 --> 00:03:24,860
\ And he came up with the famous Moore's Law.\

00:03:24,860 --> 00:03:26,850
\ Now, Moore's Law is not actually what most

00:03:26,850 --> 00:03:27,260
people\ \

00:03:27,260 --> 00:03:28,250
say it is.\ \

00:03:28,250 --> 00:03:34,320
Moore's Law says that the most cost-effective density for\

00:03:34,320 --> 00:03:38,580
\ putting transistors onto a certain chip doubles

00:03:38,580 --> 00:03:39,160
every two\ \

00:03:39,160 --> 00:03:41,569
years. You know? It's nothing to do with performance\ \

00:03:41,569 --> 00:03:45,120
or anything else. It just says that, Moore's Law\

00:03:45,120 --> 00:03:46,860
\ says I can pack twice as many transistors

00:03:46,860 --> 00:03:47,230
onto\ \

00:03:47,230 --> 00:03:52,180
a chip and hit the most optimal point for\ \

00:03:52,180 --> 00:03:53,410
cost-effectiveness.\ \

00:03:53,410 --> 00:03:57,160
And it is pretty well born out. I, so\ \

00:03:57,160 --> 00:03:59,660
I'll show in a moment - I copied the\ \

00:03:59,660 --> 00:04:04,810
slide - what the first micro-persistor I used was.\

00:04:04,810 --> 00:04:07,040
\ And it was definitely, I've definitely used

00:04:07,040 --> 00:04:10,660
8008. And\ \

00:04:10,660 --> 00:04:13,380
I've used the 6502, which is the, the last\ \

00:04:13,380 --> 00:04:15,260
one on the bottom there. So both of them\ \

00:04:15,260 --> 00:04:19,959
down there have maybe three thousand transistors on them,\

00:04:19,959 --> 00:04:21,650
\ right.\

00:04:21,650 --> 00:04:25,289
\ The axis on the y-axis here is exponential,

00:04:25,289 --> 00:04:25,680
just\ \

00:04:25,680 --> 00:04:28,099
as it was on Sandi's graph in her books.\ \

00:04:28,099 --> 00:04:35,099
So, nowadays, my laptop has a core 07 in\ \

00:04:36,289 --> 00:04:40,629
it, so it's up there. Unbelievably, I just like,\

00:04:40,629 --> 00:04:42,270
\ last night when I actually got these numbers,

00:04:42,270 --> 00:04:42,669
I\ \

00:04:42,669 --> 00:04:46,830
couldn't believe it. My laptop has roughly a billion\

00:04:46,830 --> 00:04:52,070
\ transistors in its processor. A billion transistors.\

00:04:52,070 --> 00:04:54,630
\ And so I've actually measured the size of

00:04:54,630 --> 00:04:55,220
the\ \

00:04:55,220 --> 00:04:58,500
processor chip, cause Intel don't actually release the specs.\

00:04:58,500 --> 00:05:04,650
\ And worked out that it's 121 square millimeters,

00:05:04,650 --> 00:05:06,800
right.\ \

00:05:06,800 --> 00:05:10,090
Which means that I have eight and a quarter\ \

00:05:10,090 --> 00:05:17,090
million transistors per square millimeter in my processor. That's\

00:05:17,130 --> 00:05:19,460
\ almost unimaginable. To learn how big a square

00:05:19,460 --> 00:05:20,280
millimeter\ \

00:05:20,280 --> 00:05:26,440
is, well, I finally found a use for this\ \

00:05:26,440 --> 00:05:28,930
guy, because if you take the cross-section of a\

00:05:28,930 --> 00:05:35,930
\ typical paperclip, it is about a square millimeter.

00:05:36,130 --> 00:05:37,550
So,\ \

00:05:37,550 --> 00:05:40,320
eight point six, or sorry, eight point two-five million\

00:05:40,320 --> 00:05:42,800
\ transistors in that little space there.\

00:05:42,800 --> 00:05:48,010
\ But what that really means in practice is

00:05:48,010 --> 00:05:49,160
that\ \

00:05:49,160 --> 00:05:52,389
you can't use, you know, a hundred, sorry, a\

00:05:52,389 --> 00:05:56,070
\ billion transistors, like you would use ten

00:05:56,070 --> 00:05:56,720
thousand. If\ \

00:05:56,720 --> 00:05:59,699
you have ten thousand transistors, you basically have them\

00:05:59,699 --> 00:06:01,260
\ all sitting as, you know, here's addition,

00:06:01,260 --> 00:06:01,530
no go\ \

00:06:01,530 --> 00:06:02,280
do this, no go do that. When you have\ \

00:06:02,280 --> 00:06:06,640
that many, then you cannot coordinate them and have\

00:06:06,640 --> 00:06:08,320
\ them all working on the same problem at the\

00:06:08,320 --> 00:06:10,930
\ same time in any kind of meaningful way, right.\

00:06:10,930 --> 00:06:13,150
\ If nothing else, the speed of light gets in\

00:06:13,150 --> 00:06:13,740
\ your way.\

00:06:13,740 --> 00:06:15,650
\ So, as a result, we're moving more and more\

00:06:15,650 --> 00:06:17,820
\ towards multi-core and then hyper-threading

00:06:17,820 --> 00:06:19,410
inside the cores to\ \

00:06:19,410 --> 00:06:22,600
give us parallelism in our processors. We've all heard\

00:06:22,600 --> 00:06:26,960
\ this, right. And we've all kind of like hoped\

00:06:26,960 --> 00:06:29,270
\ the problem will go away, because this doesn't

00:06:29,270 --> 00:06:29,729
really\ \

00:06:29,729 --> 00:06:32,460
effect us right now. We can sort of get\ \

00:06:32,460 --> 00:06:35,340
away with writing our Rails code on our servers,\ \

00:06:35,340 --> 00:06:38,960
and we'll run n-processors and it kind of works.\

00:06:38,960 --> 00:06:43,180
\ Except it kind of doesn't. You all know the\

00:06:43,180 --> 00:06:45,870
\ issues that we face when we try and run\

00:06:45,870 --> 00:06:46,849
\ that way.\

00:06:46,849 --> 00:06:49,540
\ So, for those reasons, I think that we're

00:06:49,540 --> 00:06:49,720
looking\ \

00:06:49,720 --> 00:06:53,250
at a C-change, now. In order to continue to\ \

00:06:53,250 --> 00:06:56,320
exploit this growing curve that's Moore's Law, we are\

00:06:56,320 --> 00:06:59,150
\ going to have to find new ways of writing\

00:06:59,150 --> 00:07:01,229
\ software, and I believe that functional programming

00:07:01,229 --> 00:07:01,780
is one\ \

00:07:01,780 --> 00:07:03,729
of those new ways.\ \

00:07:03,729 --> 00:07:09,250
So, Elixir, I think, is functional, concurrent, pragmatic and\

00:07:09,250 --> 00:07:11,820
\ fun. Let's spend a bit of time looking at\

00:07:11,820 --> 00:07:15,360
\ the functional aspects. Now, initially I had,

00:07:15,360 --> 00:07:15,650
like, I\ \

00:07:15,650 --> 00:07:17,409
don't know, a hundred slides or something. I thought,\

00:07:17,409 --> 00:07:20,000
\ screw that, let me just code instead. So I'm\

00:07:20,000 --> 00:07:21,650
\ just gonna try and code some stuff up. You'll\

00:07:21,650 --> 00:07:24,479
\ get to see how bad a typist I am,\

00:07:24,479 --> 00:07:26,080
\ and between us, we may learn something.\

00:07:26,080 --> 00:07:30,610
\ So, the first thing I'm gonna do is I'm\

00:07:30,610 --> 00:07:33,570
\ actually gonna go into the shell, and Elixir

00:07:33,570 --> 00:07:33,850
has\ \

00:07:33,850 --> 00:07:37,190
a shell just like IRB, that's called IEX. I\

00:07:37,190 --> 00:07:40,860
\ say it's just like IRB. It's nothing like

00:07:40,860 --> 00:07:41,900
IRB.\ \

00:07:41,900 --> 00:07:48,900
Let me just do something quickly here. OK. So,\

00:07:49,110 --> 00:07:52,479
\ first of all, right now, I am orchestrating

00:07:52,479 --> 00:07:54,030
roughly\ \

00:07:54,030 --> 00:07:59,490
twenty-five independent processors in my Elixir shell here.\

00:07:59,490 --> 00:08:03,050
\ So, the compiler is running in a separate

00:08:03,050 --> 00:08:03,660
process.\ \

00:08:03,660 --> 00:08:06,849
The Elixir command line, so the IEX command line\

00:08:06,849 --> 00:08:09,030
\ is running in a separate shell, a separate

00:08:09,030 --> 00:08:09,780
process.\ \

00:08:09,780 --> 00:08:13,400
And they're all communicating back and forth. Which is\

00:08:13,400 --> 00:08:16,229
\ kind of cool, and it's totally transparent.

00:08:16,229 --> 00:08:16,770
Just like\ \

00:08:16,770 --> 00:08:19,560
with IRB, I can do things like, you know,\ \

00:08:19,560 --> 00:08:22,380
type an expression and it works. I can assign\ \

00:08:22,380 --> 00:08:25,320
to a variable, right. So now a has the\ \

00:08:25,320 --> 00:08:27,570
value one.\ \

00:08:27,570 --> 00:08:29,350
Except I'm not assigning to a variable because this\

00:08:29,350 --> 00:08:31,590
\ is a functional programming language, right.

00:08:31,590 --> 00:08:32,459
All I'm doing\ \

00:08:32,459 --> 00:08:35,759
when I say a equals one is asserting that\ \

00:08:35,759 --> 00:08:40,120
a and one both have the same value. So,\ \

00:08:40,120 --> 00:08:42,919
because of that, I can also say one equals\ \

00:08:42,919 --> 00:08:45,810
a. And it says yup, no problem at all.\ \

00:08:45,810 --> 00:08:48,070
Now what happens if I was to say two\ \

00:08:48,070 --> 00:08:52,459
equals a. Well that now gets you something called\

00:08:52,459 --> 00:08:55,519
\ a NoMatchError. And the reason for that is

00:08:55,519 --> 00:08:55,790
that\ \

00:08:55,790 --> 00:08:59,800
Elixir will only bind new values to variables if\

00:08:59,800 --> 00:09:01,869
\ they're on the left-hand side of an equal

00:09:01,869 --> 00:09:02,540
sign.\ \

00:09:02,540 --> 00:09:05,139
So here, a already has a value one. So\ \

00:09:05,139 --> 00:09:07,569
Elixir says, I'm sorry, but whatever is over here\

00:09:07,569 --> 00:09:10,980
\ has to be a one as well. You know.\

00:09:10,980 --> 00:09:14,790
\ Now, I told you about pattern matching. This

00:09:14,790 --> 00:09:15,050
is\ \

00:09:15,050 --> 00:09:19,109
an absolutely critical thing in any functional programming language.\

00:09:19,109 --> 00:09:22,029
\ So let's have a quick look at pattern matching.\

00:09:22,029 --> 00:09:24,410
\ We've already seen a equals one. Well, here,

00:09:24,410 --> 00:09:24,699
we\ \

00:09:24,699 --> 00:09:26,950
have a pattern which is some variable and a\

00:09:26,950 --> 00:09:28,699
\ scalar. And that's gonna make, the variable

00:09:28,699 --> 00:09:28,949
has the\ \

00:09:28,949 --> 00:09:31,670
same value as the scalar. I could use Elixir\ \

00:09:31,670 --> 00:09:37,850
list instead, OK. So now my variable a has\ \

00:09:37,850 --> 00:09:42,560
been associated with that list one, two, three. But\

00:09:42,560 --> 00:09:44,209
\ pattern matching goes pretty deep. So I can

00:09:44,209 --> 00:09:45,389
actually\ \

00:09:45,389 --> 00:09:50,290
say, [d,e,f] equals a. And what this is gonna\ \

00:09:50,290 --> 00:09:53,959
do is say, OK, on both sides I'm expecting\ \

00:09:53,959 --> 00:09:58,230
to see a list of three elements. Well, it\ \

00:09:58,230 --> 00:09:59,470
just so happens that a is a list of\ \

00:09:59,470 --> 00:10:02,040
three elements. So this is gonna match, and it's\

00:10:02,040 --> 00:10:07,089
\ gonna assign one to d, two to e, and\

00:10:07,089 --> 00:10:08,820
\ three to f. Yeah?\

00:10:08,820 --> 00:10:12,320
\ All right. We can take it a bit further\

00:10:12,320 --> 00:10:16,550
\ than that. I can, for example, take a list\

00:10:16,550 --> 00:10:19,690
\ like a, and split it into its head and\

00:10:19,690 --> 00:10:23,250
\ its tail. So I can say, head followed by\

00:10:23,250 --> 00:10:27,350
\ tail in a list equals a. And if I\

00:10:27,350 --> 00:10:33,069
\ do that, then a, so the head is one.\

00:10:33,069 --> 00:10:37,430
\ The first element. And the tail is the rest\

00:10:37,430 --> 00:10:42,089
\ of the list. Yeah? So pattern matching allows

00:10:42,089 --> 00:10:42,600
me\ \

00:10:42,600 --> 00:10:46,029
to construct and deconstruct my data. And as you'll\

00:10:46,029 --> 00:10:48,329
\ see a bit later on, it also allows me\

00:10:48,329 --> 00:10:51,790
\ to write really large programs without any

00:10:51,790 --> 00:10:54,319
conditional logic.\ \

00:10:54,319 --> 00:10:56,399
Typically also without any loops.\ \

00:10:56,399 --> 00:11:00,069
All I'm doing is declaring stuff in my code.\ \

00:11:00,069 --> 00:11:01,930
So let's start off and actually write some Elixir\

00:11:01,930 --> 00:11:04,110
\ code, like, outside this thing. Let's go into

00:11:04,110 --> 00:11:04,920
an\ \

00:11:04,920 --> 00:11:08,209
editor here. So I'll just use Sublime. And let's\

00:11:08,209 --> 00:11:10,629
\ just write a really quick bit of Elixir. Let's\

00:11:10,629 --> 00:11:13,449
\ do defmodule, let's call it Sequence because

00:11:13,449 --> 00:11:14,029
eventually it\ \

00:11:14,029 --> 00:11:16,619
will be. Oops.\ \

00:11:16,619 --> 00:11:23,489
All right. So, all Elixir code goes into a\ \

00:11:23,489 --> 00:11:25,769
module. So, that's not quite true. When you want\

00:11:25,769 --> 00:11:26,639
\ to compile Elixir code, you have to put it\

00:11:26,639 --> 00:11:29,130
\ into a module. And the reason for that is\

00:11:29,130 --> 00:11:31,589
\ that Elixir runs on the Erlang virtual machine,

00:11:31,589 --> 00:11:32,129
and\ \

00:11:32,129 --> 00:11:35,489
that's how the Erlang virtual machine manages its code.\

00:11:35,489 --> 00:11:37,220
\ You may have heard the Erlang/Elixir do a

00:11:37,220 --> 00:11:37,610
hot-swapping\ \

00:11:37,610 --> 00:11:40,410
of code. Well, I can hot swap?? Elixir code\ \

00:11:40,410 --> 00:11:42,040
as well. So when you're running an application, I\

00:11:42,040 --> 00:11:44,579
\ can replace it. I replace things at the module\

00:11:44,579 --> 00:11:45,969
\ level. So that's why I have to put my\

00:11:45,969 --> 00:11:47,839
\ code in a module.\

00:11:47,839 --> 00:11:53,189
\ So I can write a method, let's say hello,\

00:11:53,189 --> 00:12:00,189
\ and we'll just say IO. All right. And then\

00:12:01,490 --> 00:12:03,959
\ down here I can call it by saying Sequence\

00:12:03,959 --> 00:12:10,320
\ dot hello. Yeah? If I run that code, wow.\

00:12:10,320 --> 00:12:14,850
\ So, if you are squinting, you will think that,\

00:12:14,850 --> 00:12:17,529
\ that was Ruby, right. Very, very similar.

00:12:17,529 --> 00:12:18,389
And, in\ \

00:12:18,389 --> 00:12:21,069
fact, Elixir takes a whole bunch of things from\

00:12:21,069 --> 00:12:24,329
\ Ruby and runs with them.\

00:12:24,329 --> 00:12:28,259
\ For example, here, you think that is a function\

00:12:28,259 --> 00:12:30,939
\ definition. Which it kind of is. But actually,

00:12:30,939 --> 00:12:31,399
it's\ \

00:12:31,399 --> 00:12:35,839
alo a function call. Because, in Elixir, def is\

00:12:35,839 --> 00:12:39,420
\ a function call. So is defmodule. And this

00:12:39,420 --> 00:12:39,470
function\ \

00:12:39,470 --> 00:12:43,680
takes two parameters. The name of the method and\

00:12:43,680 --> 00:12:46,300
\ the body of the method. And it just so\

00:12:46,300 --> 00:12:49,429
\ happens, in Elixir, there's a bit of syntactic

00:12:49,429 --> 00:12:49,939
sugar\ \

00:12:49,939 --> 00:12:53,649
that lets me write the body as do end.\ \

00:12:53,649 --> 00:13:00,649
Underneath the covers, that actually gets translated into, oops,\

00:13:02,299 --> 00:13:05,529
\ that.\

00:13:05,529 --> 00:13:08,179
\ That do colon there is actually just like

00:13:08,179 --> 00:13:08,230
a\ \

00:13:08,230 --> 00:13:12,559
Ruby hash. It's just a named parameter that I'm\

00:13:12,559 --> 00:13:15,369
\ passing in. So, for example, an if statement

00:13:15,369 --> 00:13:16,199
in\ \

00:13:16,199 --> 00:13:18,709
Elixir, if I have an if statement like if\ \

00:13:18,709 --> 00:13:25,709
a equals b, sorry, do something, else something else.\

00:13:26,529 --> 00:13:30,989
\ Yeah? Actually, again, it's just syntactic

00:13:30,989 --> 00:13:32,329
sugar. Because if\ \

00:13:32,329 --> 00:13:36,220
is also just a method. Actually it's a macro,\ \

00:13:36,220 --> 00:13:38,819
effectively. It's a method. It takes three parameters. It\

00:13:38,819 --> 00:13:41,639
\ takes the expression, it takes the do block,

00:13:41,639 --> 00:13:42,369
and\ \

00:13:42,369 --> 00:13:45,889
it takes the else block.\ \

00:13:45,889 --> 00:13:49,089
And that means that I can rewrite the entire\ \

00:13:49,089 --> 00:13:53,809
language if I want to, right. Everything is soft.\

00:13:53,809 --> 00:13:55,639
\ We always talk about metaprogramming. This

00:13:55,639 --> 00:13:58,170
is serious metaprogramming.\ \

00:13:58,170 --> 00:14:02,559
And unlike other languages you might name, it's actually\

00:14:02,559 --> 00:14:04,480
\ done in a very controlled style. First of

00:14:04,480 --> 00:14:05,399
all,\ \

00:14:05,399 --> 00:14:08,279
metaprogramming in Elixir is done by manipulating the parse\

00:14:08,279 --> 00:14:10,509
\ tree, which actually happens to be an Elixir

00:14:10,509 --> 00:14:10,839
data\ \

00:14:10,839 --> 00:14:14,239
structure. It is done in a hygienic way, so\ \

00:14:14,239 --> 00:14:17,959
it will not overwrite any of your local values\ \

00:14:17,959 --> 00:14:23,959
accidentally. And it is done in a scoped way.\ \

00:14:23,959 --> 00:14:27,999
In Elixir, every change you make to the environment,\ \

00:14:27,999 --> 00:14:30,970
whether it's defining macros or including a module, whatever\

00:14:30,970 --> 00:14:34,649
\ it might be, is lexically scoped. So, for

00:14:34,649 --> 00:14:35,329
example,\ \

00:14:35,329 --> 00:14:39,579
I can say apply this differentiation of a particular\

00:14:39,579 --> 00:14:43,660
\ operator only to the parameters of this method

00:14:43,660 --> 00:14:45,899
call,\ \

00:14:45,899 --> 00:14:47,649
which can come in very, very useful.\ \

00:14:47,649 --> 00:14:50,440
However, that's not why we're here. So let's have\

00:14:50,440 --> 00:14:51,879
\ a look at something slightly different. Let's

00:14:51,879 --> 00:14:52,709
have a\ \

00:14:52,709 --> 00:14:54,709
look at lists. So what I want to be\ \

00:14:54,709 --> 00:14:59,239
able to do is say something like IO dot\ \

00:14:59,239 --> 00:15:06,239
puts Sequence, oops, dot length of some list. Yeah?\

00:15:07,529 --> 00:15:10,149
\ So, how am I about, how am I gonna\

00:15:10,149 --> 00:15:12,109
\ go about doing that? Well, obviously there

00:15:12,109 --> 00:15:12,499
are built-in\ \

00:15:12,499 --> 00:15:14,259
ways of doing this, but let's do it the\ \

00:15:14,259 --> 00:15:14,660
hard way.\ \

00:15:14,660 --> 00:15:19,189
So I need to find a method called length\ \

00:15:19,189 --> 00:15:21,149
that's gonna give me the length of the list.\ \

00:15:21,149 --> 00:15:24,379
In a functional programming language, I'm gonna use pattern\

00:15:24,379 --> 00:15:26,899
\ matching to do most of the work for me.\

00:15:26,899 --> 00:15:29,459
\ So I'm gonna say, the length of an empty\

00:15:29,459 --> 00:15:32,670
\ list, k, I'm pattern matching here, an empty

00:15:32,670 --> 00:15:32,949
list.\ \

00:15:32,949 --> 00:15:36,609
And what's the length of an empty list? Zero.\ \

00:15:36,609 --> 00:15:39,480
So, that's taken care of one case. The other\ \

00:15:39,480 --> 00:15:42,249
case is a non-empty list. So let's have a\ \

00:15:42,249 --> 00:15:46,139
look at a list which has a head or\ \

00:15:46,139 --> 00:15:50,579
a tail. And tail is potentially empty. So what's\

00:15:50,579 --> 00:15:51,680
\ the list of that?\

00:15:51,680 --> 00:15:55,759
\ Well, we know the head contributes one. And

00:15:55,759 --> 00:16:01,189
the length of the tail is simply length(tail). That\

00:16:01,189 --> 00:16:07,399
\ make sense? Nice little recursive definition.

00:16:07,399 --> 00:16:09,439
If I run\ \

00:16:09,439 --> 00:16:10,649
that, it blows up.\ \

00:16:10,649 --> 00:16:12,369
AUDIENCE: [laughter]\ \

00:16:12,369 --> 00:16:17,540
D.T.: But that's OK. Oh. Kernel dot length conflicts\

00:16:17,540 --> 00:16:19,329
\ with local function. Look at that. I actually

00:16:19,329 --> 00:16:19,499
have,\ \

00:16:19,499 --> 00:16:21,600
although it's untyped, it actually does a fair amount\

00:16:21,600 --> 00:16:24,689
\ of work to make sure that, for example, I\

00:16:24,689 --> 00:16:26,689
\ haven't mispelt function names, that I haven't

00:16:26,689 --> 00:16:27,989
accidentally overwritten\ \

00:16:27,989 --> 00:16:34,989
function names. So let's call that len rather than\

00:16:35,069 --> 00:16:40,009
\ length. There we go. So the problem is here.\

00:16:40,009 --> 00:16:44,109
\ First of all, there's my result, five. Also

00:16:44,109 --> 00:16:44,999
notice,\ \

00:16:44,999 --> 00:16:47,949
variable head is unused, because here, when I did\

00:16:47,949 --> 00:16:49,839
\ the pattern match, I said head to be the\

00:16:49,839 --> 00:16:51,709
\ head of the list, tail to be the tail\

00:16:51,709 --> 00:16:53,799
\ of the list, but then my code, I only\

00:16:53,799 --> 00:16:56,790
\ ever use tail. So, Elixir has a convention

00:16:56,790 --> 00:16:56,949
that\ \

00:16:56,949 --> 00:16:58,389
if I've got an underscore in front of a\ \

00:16:58,389 --> 00:17:01,329
variable name, it says, I don't plan to use\ \

00:17:01,329 --> 00:17:02,069
this variable.\ \

00:17:02,069 --> 00:17:05,939
So by doing that, my warning goes away. I\ \

00:17:05,939 --> 00:17:10,430
could, in fact, just say underscore here, and again,\

00:17:10,430 --> 00:17:12,410
\ that just works. But I personally prefer to

00:17:12,410 --> 00:17:12,600
leave\ \

00:17:12,600 --> 00:17:14,819
the variable name there because it documents what I'm\

00:17:14,819 --> 00:17:18,069
\ doing. That's a typical recursive definition.

00:17:18,069 --> 00:17:18,730
You don't find\ \

00:17:18,730 --> 00:17:23,220
yourself doing those too often. K, but one of\

00:17:23,220 --> 00:17:25,579
\ the things I like about this, from a, an\

00:17:25,579 --> 00:17:28,740
\ aesthetic point of view, is that my definitions

00:17:28,740 --> 00:17:29,750
here\ \

00:17:29,750 --> 00:17:32,500
are pretty much the specification of what I want\

00:17:32,500 --> 00:17:35,670
\ to write. So the length of an empty list\

00:17:35,670 --> 00:17:37,890
\ is zero. That's, you know, someone could tell

00:17:37,890 --> 00:17:38,110
you\ \

00:17:38,110 --> 00:17:40,540
that. Right. The length of any other list is\

00:17:40,540 --> 00:17:43,440
\ one plus the length of the rest of the\

00:17:43,440 --> 00:17:44,990
\ list. OK, it's a specification.\

00:17:44,990 --> 00:17:48,270
\ Let me show you another specification. This

00:17:48,270 --> 00:17:49,020
one is\ \

00:17:49,020 --> 00:17:51,320
like, it's almost like you'll groan when you see\

00:17:51,320 --> 00:17:52,900
\ it, right, but it's actually useful for my

00:17:52,900 --> 00:17:54,370
purposes.\ \

00:17:54,370 --> 00:17:58,549
Fibonacci numbers, right. One, one, two, three, five, eight,\

00:17:58,549 --> 00:18:00,640
\ whatever. Each number is the sum of the previous\

00:18:00,640 --> 00:18:03,059
\ two numbers. If you go to a math book\

00:18:03,059 --> 00:18:05,790
\ or Wikipedia or whatever else, they will tell

00:18:05,790 --> 00:18:06,390
you,\ \

00:18:06,390 --> 00:18:08,710
the definition of a function of fibonacci is the\

00:18:08,710 --> 00:18:15,710
\ fibonacci of zero is one. The fibonacci of

00:18:18,830 --> 00:18:19,390
one,\ \

00:18:19,390 --> 00:18:24,920
oops, is also one. And then the fibonacci of\

00:18:24,920 --> 00:18:31,920
\ some number n is the fibonacci of n minus\

00:18:33,360 --> 00:18:37,690
\ one, woops, plus the fibonacci of n minus

00:18:37,690 --> 00:18:38,530
two.\ \

00:18:38,530 --> 00:18:44,620
That is the mathematical definition of fibonacci, yeah.\

00:18:44,620 --> 00:18:48,000
\ But, if we were to convert that into running\

00:18:48,000 --> 00:18:53,780
\ Elixir code, all I have to do is say,\

00:18:53,780 --> 00:18:58,760
\ right, and now I have code. So now I\

00:18:58,760 --> 00:19:05,760
\ have to say Sequence dot fib(20). There it

00:19:06,250 --> 00:19:08,200
is.\ \

00:19:08,200 --> 00:19:12,410
Is that cool? Yeah. Now, at this point, you're\ \

00:19:12,410 --> 00:19:13,910
probably saying, but, Dave, that's all very well, but\

00:19:13,910 --> 00:19:16,430
\ how many times a day to you actually calculate\

00:19:16,430 --> 00:19:18,310
\ the fibonacci sequence, right? Eh, OK. No

00:19:18,310 --> 00:19:18,900
more than\ \

00:19:18,900 --> 00:19:22,320
five or six, I have to tell you.\ \

00:19:22,320 --> 00:19:26,640
But that's OK, because the reality is that this\

00:19:26,640 --> 00:19:29,850
\ form of expressing code I do all the time,\

00:19:29,850 --> 00:19:32,930
\ in fact, when I'm writing Ruby code, I will\

00:19:32,930 --> 00:19:34,730
\ sit there and I'll typically work out the

00:19:34,730 --> 00:19:35,030
various\ \

00:19:35,030 --> 00:19:37,230
definitions, and I'll write them down, not as tidy\

00:19:37,230 --> 00:19:39,270
\ as this, but I'll write, you know, zero is\

00:19:39,270 --> 00:19:41,610
\ one. And I'll write, you know, empty request

00:19:41,610 --> 00:19:41,660
means\ \

00:19:41,660 --> 00:19:43,320
I send back a form or whatever. You know,\ \

00:19:43,320 --> 00:19:45,850
all those kind of things I would write down.\ \

00:19:45,850 --> 00:19:47,880
I do the same when I'm writing Elixir, but\ \

00:19:47,880 --> 00:19:50,190
it just turns out, coincidentally, I'm writing code, right.\

00:19:50,190 --> 00:19:52,330
\ That's really cool.\

00:19:52,330 --> 00:19:54,170
\ So let's look at a few more things in\

00:19:54,170 --> 00:19:57,290
\ here. First of all, let's define a map function.\

00:19:57,290 --> 00:19:59,500
\ It's the same as the Ruby map function in\

00:19:59,500 --> 00:20:02,140
\ that I want to take a collection and apply\

00:20:02,140 --> 00:20:04,420
\ a function to each element in that collection

00:20:04,420 --> 00:20:05,000
and\ \

00:20:05,000 --> 00:20:09,030
return the resulting set of values. So, I'm gonna\

00:20:09,030 --> 00:20:10,940
\ say, let's start with a use because that's

00:20:10,940 --> 00:20:11,140
always\ \

00:20:11,140 --> 00:20:12,820
a good way of doing things. So in this\ \

00:20:12,820 --> 00:20:18,490
case, I will do IO dot puts Sequence dot\ \

00:20:18,490 --> 00:20:21,700
map(). OK, so I'm gonna map, in this case,\ \

00:20:21,700 --> 00:20:24,400
a list. So let's go four, five, six, seven,\ \

00:20:24,400 --> 00:20:27,900
and I'm gonna map it through my fibonacci function,\

00:20:27,900 --> 00:20:31,410
\ all right. So my fibonacci sequence is gonna

00:20:31,410 --> 00:20:32,170
be.\ \

00:20:32,170 --> 00:20:37,710
Oh, actually I'll do it this way.\ \

00:20:37,710 --> 00:20:42,800
OK. So I want to say, Sequence dot fib\ \

00:20:42,800 --> 00:20:46,309
of some number n for each successive element. So\

00:20:46,309 --> 00:20:51,810
\ how do I do that? Well, the long-winded way\

00:20:51,810 --> 00:20:53,950
\ is to say, I'm gonna write an anonymous function,\

00:20:53,950 --> 00:20:56,710
\ that's just like a lambda in Ruby, that takes\

00:20:56,710 --> 00:21:00,560
\ a parameter n and its body is, will calculate\

00:21:00,560 --> 00:21:04,679
\ the sequence dot fib of n, yeah. So my\

00:21:04,679 --> 00:21:06,830
\ map function takes the collection and it takes

00:21:06,830 --> 00:21:07,530
the\ \

00:21:07,530 --> 00:21:10,910
function. So let's start off with that.\ \

00:21:10,910 --> 00:21:14,549
So the map function takes a collection and it\

00:21:14,549 --> 00:21:18,980
\ takes a function. So what are my special cases\

00:21:18,980 --> 00:21:20,720
\ here? Well I think it's the same as the,\

00:21:20,720 --> 00:21:23,750
\ the counting one, the length one we did, and\

00:21:23,750 --> 00:21:25,680
\ that is, if I want to map over an\

00:21:25,680 --> 00:21:28,900
\ empty collection, then what's gonna come back

00:21:28,900 --> 00:21:29,670
is also\ \

00:21:29,670 --> 00:21:32,900
an empty collection, yeah. That's all I need to\

00:21:32,900 --> 00:21:35,520
\ do. So now I'm dealing with the case of\

00:21:35,520 --> 00:21:37,670
\ mapping over a non-empty collection. So we're

00:21:37,670 --> 00:21:38,040
gonna do\ \

00:21:38,040 --> 00:21:43,190
that head-tail thing again. And we get the function.\

00:21:43,190 --> 00:21:45,630
\ So now, what are we gonna do here?\

00:21:45,630 --> 00:21:48,450
\ Well I have to apply the function to the\

00:21:48,450 --> 00:21:49,940
\ head of the list, because that's part of what\

00:21:49,940 --> 00:21:52,320
\ I have to do. And then I have to\

00:21:52,320 --> 00:21:55,320
\ generate the rest of the list, which is being\

00:21:55,320 --> 00:22:00,390
\ mapped. So I can express that by saying, OK,\

00:22:00,390 --> 00:22:04,730
\ fun dot head, so, let's clone the function

00:22:04,730 --> 00:22:05,240
on\ \

00:22:05,240 --> 00:22:08,990
the head, and then I'm gonna build the rest\ \

00:22:08,990 --> 00:22:14,610
of the list by mapping on the tail. And\ \

00:22:14,610 --> 00:22:17,040
that map function is the same map function here.\

00:22:17,040 --> 00:22:18,140
\ So what's gonna happen? Let me shrink the

00:22:18,140 --> 00:22:19,400
if I shrink the font down, can you see\ \

00:22:19,400 --> 00:22:23,560
it in the back? Is that OK? OK, thank\ \

00:22:23,560 --> 00:22:27,260
you. All right. So, what's gonna happen here is,\

00:22:27,260 --> 00:22:29,610
\ each time around this recursion, it's gonna

00:22:29,610 --> 00:22:30,850
take one\ \

00:22:30,850 --> 00:22:33,970
extra element of the list. It's gonna convert that\

00:22:33,970 --> 00:22:35,990
\ by running it through the function and build

00:22:35,990 --> 00:22:36,100
a\ \

00:22:36,100 --> 00:22:38,410
new list where that element's there. Then at the\

00:22:38,410 --> 00:22:40,990
\ very end, I'm gonna run out of list. So\

00:22:40,990 --> 00:22:42,799
\ tail will be empty, so then it comes with\

00:22:42,799 --> 00:22:45,190
\ this clause and it's gonna terminate the recursion.\

00:22:45,190 --> 00:22:48,860
\ So now in theory, if I run this code,\

00:22:48,860 --> 00:22:54,320
\ oh. Ah! OK. Let me change this to be\

00:22:54,320 --> 00:22:57,940
\ an inspect. All right. I've just run afoul

00:22:57,940 --> 00:22:58,210
of\ \

00:22:58,210 --> 00:23:01,980
some Erlang disgustingness. All right. But anyway. So there\

00:23:01,980 --> 00:23:07,320
\ is me mapping my list. Yeah. That's not bad\

00:23:07,320 --> 00:23:09,760
\ is it. It's really quite straight-forward.

00:23:09,760 --> 00:23:11,170
It's really understandable\ \

00:23:11,170 --> 00:23:12,730
code. It is recursive.\ \

00:23:12,730 --> 00:23:17,310
But so what? So here I've written a map\ \

00:23:17,310 --> 00:23:20,100
function and a fibonacci function, and in both cases,\

00:23:20,100 --> 00:23:22,680
\ I have no explicit loops, I have no explicit\

00:23:22,680 --> 00:23:25,580
\ conditional logic, which is absolutely fantastic.

00:23:25,580 --> 00:23:26,420
OK.\ \

00:23:26,420 --> 00:23:28,970
So, you say to me, but Dave you're doing,\ \

00:23:28,970 --> 00:23:30,800
you know, testing by inspection. Can we do better\

00:23:30,800 --> 00:23:32,490
\ than that? You bet we can. So let's do\

00:23:32,490 --> 00:23:37,290
\ something like class TestIt. No, not class.

00:23:37,290 --> 00:23:39,130
Oh, dear,\ \

00:23:39,130 --> 00:23:42,030
dear, so that's the problem. You switch back and\

00:23:42,030 --> 00:23:43,930
\ forth between the two and you are totally

00:23:43,930 --> 00:23:44,530
lost.\ \

00:23:44,530 --> 00:23:48,820
It's horrible. All right. So.\ \

00:23:48,820 --> 00:23:52,450
So there's my test module. I need to use\ \

00:23:52,450 --> 00:23:55,620
ExUnit, which is a testing framework, and in fact,\

00:23:55,620 --> 00:23:58,320
\ I actually have to start the testing framework.

00:23:58,320 --> 00:23:58,550
Cause\ \

00:23:58,550 --> 00:24:00,690
Erlang's about lots of processes. It actually runs in\

00:24:00,690 --> 00:24:02,700
\ its own separate process. So I'm gonna run

00:24:02,700 --> 00:24:02,980
its\ \

00:24:02,980 --> 00:24:05,340
own process. So now I can write some tests.\ \

00:24:05,340 --> 00:24:12,340
Test "Basic fib function works" do. All right. So\

00:24:16,500 --> 00:24:23,500
\ now assert Sequence dot fib(10) equals one

00:24:25,470 --> 00:24:27,970
oh nine\ \

00:24:27,970 --> 00:24:34,970
four six, end. Test "Basic Map works" do. So\

00:24:41,559 --> 00:24:48,559
\ now I'm just gonna cut and paste over here,\

00:24:55,970 --> 00:25:02,970
\ so I have. OK, so. Five, eight, thirteen,

00:25:03,360 --> 00:25:04,020
oops.\ \

00:25:04,020 --> 00:25:08,030
I made a typo. Bad me.\ \

00:25:08,030 --> 00:25:12,320
Okee dokes. So, folks, that's a basic unit test\

00:25:12,320 --> 00:25:14,510
\ written using the ExUnit framework. So let's

00:25:14,510 --> 00:25:16,900
see what\ \

00:25:16,900 --> 00:25:23,900
happens when I run that. Function test two undefined.\

00:25:24,800 --> 00:25:28,150
\ I'm sorry, where?\

00:25:28,150 --> 00:25:29,289
\ AUDIENCE: [indecipherable]\

00:25:29,289 --> 00:25:32,230
\ D.T.: To get the fun thing done. Yeah. I\

00:25:32,230 --> 00:25:34,360
\ think that's, that's not the error I'm actually

00:25:34,360 --> 00:25:34,690
seeing\ \

00:25:34,690 --> 00:25:39,260
here. I'm seeing a problem that test two is\ \

00:25:39,260 --> 00:25:43,390
undefined, which means that this test method here, which\

00:25:43,390 --> 00:25:44,550
\ probably means that I've forgotten something.

00:25:44,550 --> 00:25:44,970
Give me a\ \

00:25:44,970 --> 00:25:46,430
quick second. I had a cheat sheet just to\ \

00:25:46,430 --> 00:25:49,940
make sure I don't do this. Oh, I'm sorry,\ \

00:25:49,940 --> 00:25:52,900
it's not use ExUnit, it's use ExUnit dot case.\ \

00:25:52,900 --> 00:25:57,270
That's right. Oh, there you go. There worked loads,\

00:25:57,270 --> 00:25:59,210
\ a whole lot better.\

00:25:59,210 --> 00:26:02,480
\ Cannot invoke remote function Sequence dot

00:26:02,480 --> 00:26:06,080
fib/1.\ \

00:26:06,080 --> 00:26:13,080
AUDIENCE: [indecipherable]\ \

00:26:13,280 --> 00:26:20,280
D.T.: Cause it is.\ \

00:26:20,730 --> 00:26:24,290
AUDIENCE: [indecipherable]\ \

00:26:24,290 --> 00:26:30,250
D.T.: Is that what it is? Oh, sorry. It'll\ \

00:26:30,250 --> 00:26:37,250
be eighty-nine in that case, isn't it? All right.\

00:26:37,430 --> 00:26:42,230
\ I'm having a really bad time here. What's

00:26:42,230 --> 00:26:42,350
wrong\ \

00:26:42,350 --> 00:26:45,460
with that?\ \

00:26:45,460 --> 00:26:52,460
What on earth is wrong with that?\ \

00:27:02,140 --> 00:27:04,120
It is not the most efficient way of doing\ \

00:27:04,120 --> 00:27:11,120
that, I have to tell you. Oh, oh, oh.\ \

00:27:12,750 --> 00:27:18,100
OK. Here we go. Here we go. Thank you.\ \

00:27:18,100 --> 00:27:19,500
Thank you.\ \

00:27:19,500 --> 00:27:25,179
All right. So, my test failed. Notice the error.\

00:27:25,179 --> 00:27:28,680
\ Expected five, eight, thirteen, twenty-one,

00:27:28,680 --> 00:27:32,490
but got five, eight,\ \

00:27:32,490 --> 00:27:35,960
thirteen, twenty-two. In most of the testing frameworks, I'd\

00:27:35,960 --> 00:27:39,690
\ have to say assert_equals that comma result.

00:27:39,690 --> 00:27:40,680
Right. Remember\ \

00:27:40,680 --> 00:27:45,340
I said that metaprogramming is wonderful in Elixir. Here\

00:27:45,340 --> 00:27:50,120
\ my test function actually intercepts calls

00:27:50,120 --> 00:27:51,770
to equals equals\ \

00:27:51,770 --> 00:27:55,230
inside that block. It runs the original equals equals,\

00:27:55,230 --> 00:27:57,860
\ but it still has access to the two operands,\

00:27:57,860 --> 00:28:00,970
\ as a code fragment. So it can take that\

00:28:00,970 --> 00:28:03,950
\ code fragment, convert it back into text,

00:28:03,950 --> 00:28:04,470
and then\ \

00:28:04,470 --> 00:28:08,950
use it here to show me the two values.\ \

00:28:08,950 --> 00:28:12,400
That is pretty damn cool. Just think of the\ \

00:28:12,400 --> 00:28:18,380
cool stuff you could do with that. All right.\ \

00:28:18,380 --> 00:28:22,090
So, let's push the boat out. I talked about\ \

00:28:22,090 --> 00:28:25,820
it being a parallel, a concurrent language, so let's\

00:28:25,820 --> 00:28:28,970
\ go back to our map sequence here, and let's\

00:28:28,970 --> 00:28:32,030
\ see if we can make this parallel. And I\

00:28:32,030 --> 00:28:35,840
\ have, five minutes? Is that right? Somebody?

00:28:35,840 --> 00:28:36,930
God help\ \

00:28:36,930 --> 00:28:38,570
me. All right.\ \

00:28:38,570 --> 00:28:40,930
So, I'm gonna write a parallel version of map.\

00:28:40,930 --> 00:28:43,440
\ So let's call it pmap, all right. it's gonna\

00:28:43,440 --> 00:28:50,370
\ take a collection and a function, yeah. And

00:28:50,370 --> 00:28:50,730
what\ \

00:28:50,730 --> 00:28:53,480
it's gonna do is this is what I'm gonna\ \

00:28:53,480 --> 00:28:56,190
show you how I think about functional programming. It's\

00:28:56,190 --> 00:29:00,200
\ gonna take the collection, it's going to run

00:29:00,200 --> 00:29:00,330
each\ \

00:29:00,330 --> 00:29:03,050
of the elements of this collection in a separate\ \

00:29:03,050 --> 00:29:07,590
sub-process. So we're gonna call it spawn_children(), let's call\

00:29:07,590 --> 00:29:12,040
\ it fun rather than function just to save myself\

00:29:12,040 --> 00:29:15,260
\ a little bit here. And then after we've done\

00:29:15,260 --> 00:29:16,770
\ that we're gonna collect the results.\

00:29:16,770 --> 00:29:22,950
\ So what's this pipe operator here? It's actually

00:29:22,950 --> 00:29:23,230
a\ \

00:29:23,230 --> 00:29:25,130
pipe line. Just as if we're in the Unix\ \

00:29:25,130 --> 00:29:27,559
shell and I can pipe the output of one\ \

00:29:27,559 --> 00:29:30,500
thing into the next. Here, I've taken my collection.\ \

00:29:30,500 --> 00:29:35,059
I am piping it to spawn children, and then\ \

00:29:35,059 --> 00:29:37,250
the results will come back. I'm gonna pipe it\

00:29:37,250 --> 00:29:41,070
\ to collect the results. The reason this is

00:29:41,070 --> 00:29:41,620
significant\ \

00:29:41,620 --> 00:29:43,260
is not that it saves me a little bit\ \

00:29:43,260 --> 00:29:45,510
of typing. The reason it's significant is it changes\

00:29:45,510 --> 00:29:48,180
\ the way I think about programming. Because

00:29:48,180 --> 00:29:48,680
now I\ \

00:29:48,680 --> 00:29:52,680
think about programming as mapping from a to b,\

00:29:52,680 --> 00:29:54,850
\ and not from doing something. So here I have\

00:29:54,850 --> 00:29:56,870
\ a collection. I'm gonna map it into a set\

00:29:56,870 --> 00:29:58,850
\ of processes. And then I'm gonna map those

00:29:58,850 --> 00:30:00,070
processes\ \

00:30:00,070 --> 00:30:04,149
into some results. So it's a transformation. It's not\

00:30:04,149 --> 00:30:07,240
\ a explicit imperative way of coding.\

00:30:07,240 --> 00:30:09,300
\ So how do we code those things up? Well,\

00:30:09,300 --> 00:30:12,890
\ I know I'm running out of time so I'm\

00:30:12,890 --> 00:30:14,919
\ gonna do this pretty quickly. So, I have my\

00:30:14,919 --> 00:30:16,200
\ spawn_children function, and it's gonna take

00:30:16,200 --> 00:30:17,820
a collection and\ \

00:30:17,820 --> 00:30:24,820
a function, and it's gonna take the collection and\

00:30:25,149 --> 00:30:27,090
\ it's gonna map it, so again I'm gonna transform\

00:30:27,090 --> 00:30:32,350
\ the collection by mapping it through, that's

00:30:32,350 --> 00:30:35,440
spawn_child- yeah.\ \

00:30:35,440 --> 00:30:41,630
A function called spawn_child. So it's going to spawn\

00:30:41,630 --> 00:30:44,130
\ one independent child, K.\

00:30:44,130 --> 00:30:45,809
\ And clearly I need to pass it the element\

00:30:45,809 --> 00:30:49,740
\ from the collection and the function. So what

00:30:49,740 --> 00:30:49,880
I\ \

00:30:49,880 --> 00:30:53,550
could do is to say something like this, elem\ \

00:30:53,550 --> 00:30:55,920
comma fun, and then wrap this in an anonymous\ \

00:30:55,920 --> 00:30:58,180
function, just as you would in Ruby. So I'd\ \

00:30:58,180 --> 00:31:02,980
say function, so I'm gonna receive an element. And\

00:31:02,980 --> 00:31:05,620
\ I'm gonna do that. But because that's such

00:31:05,620 --> 00:31:05,900
a\ \

00:31:05,900 --> 00:31:08,830
common pattern, Elixir has a short cut for this.\

00:31:08,830 --> 00:31:14,880
\ I could say map it through spawn_children,

00:31:14,880 --> 00:31:15,240
where the\ \

00:31:15,240 --> 00:31:20,120
first element is the first parameter passed in, and\

00:31:20,120 --> 00:31:22,090
\ Elixir automatically is gonna wrap that into

00:31:22,090 --> 00:31:23,059
an anonymous\ \

00:31:23,059 --> 00:31:25,610
function. It's then gonna say, but wait a minute,\

00:31:25,610 --> 00:31:27,340
\ this anonymous function is nothing more than

00:31:27,340 --> 00:31:27,780
a call\ \

00:31:27,780 --> 00:31:30,179
to a named function, so it's gonna rewrite that\

00:31:30,179 --> 00:31:32,240
\ again into a direct function call to that

00:31:32,240 --> 00:31:32,500
named\ \

00:31:32,500 --> 00:31:34,919
function, once for each element in the collection. That's\

00:31:34,919 --> 00:31:36,340
\ pretty sweet. Right.\

00:31:36,340 --> 00:31:38,570
\ So what does my spawn_child look like? It's

00:31:38,570 --> 00:31:38,940
gonna\ \

00:31:38,940 --> 00:31:43,740
look like something like it receives a value and\

00:31:43,740 --> 00:31:46,120
\ it receives a function, and this is where

00:31:46,120 --> 00:31:46,210
it\ \

00:31:46,210 --> 00:31:47,779
gets a little bit tricky, because what we're gonna\

00:31:47,779 --> 00:31:49,960
\ do is we're gonna spawn ourselves and make

00:31:49,960 --> 00:31:50,270
ourselves\ \

00:31:50,270 --> 00:31:52,820
run in a separate process. To run in a\ \

00:31:52,820 --> 00:31:57,200
separate process in Elixir, I'm gonna call spawn, and\

00:31:57,200 --> 00:32:00,050
\ there are many different ways of calling spawn.

00:32:00,050 --> 00:32:00,420
The\ \

00:32:00,420 --> 00:32:02,270
one I'm gonna choose is actually slightly verbose, but\

00:32:02,270 --> 00:32:04,870
\ it's actually easiest to explain. I'm gonna

00:32:04,870 --> 00:32:05,870
spanw a\ \

00:32:05,870 --> 00:32:09,990
function in my current module that's gonna be called\

00:32:09,990 --> 00:32:13,270
\ :child, and I'm gonna pass it three parameters.

00:32:13,270 --> 00:32:13,650
So\ \

00:32:13,650 --> 00:32:16,380
the parameters I'm gonna pass it are the value,\ \

00:32:16,380 --> 00:32:19,210
I'm gonna pass it the function and I'm gonna\ \

00:32:19,210 --> 00:32:23,520
pass it myself. Self is a, a current process.\ \

00:32:23,520 --> 00:32:25,110
And the reason I want to do that is\ \

00:32:25,110 --> 00:32:26,700
that my child is gonna send me a message\ \

00:32:26,700 --> 00:32:29,690
back to say here's the value.\ \

00:32:29,690 --> 00:32:31,530
So now I'm gonna run my child function. Do\ \

00:32:31,530 --> 00:32:33,440
I really write all these one-line functions when I'm\

00:32:33,440 --> 00:32:37,580
\ writing Elixir? Actually I do. And typically

00:32:37,580 --> 00:32:38,950
them on the same line just because it's like\ \

00:32:38,950 --> 00:32:43,470
easier to do that. I find this kind of\ \

00:32:43,470 --> 00:32:45,580
decomposition. Step at a time, just decomposing it to\

00:32:45,580 --> 00:32:47,740
\ single-line functions. It's really a powerful

00:32:47,740 --> 00:32:48,130
way to think\ \

00:32:48,130 --> 00:32:49,270
about it.\ \

00:32:49,270 --> 00:32:51,580
So my child method, what that's gonna do is\ \

00:32:51,580 --> 00:32:53,600
actually send - so, OK, so the child method\ \

00:32:53,600 --> 00:32:59,330
receives a value, a function, and a pointer to\

00:32:59,330 --> 00:33:01,300
\ self, which is actually the parent of the

00:33:01,300 --> 00:33:02,010
child,\ \

00:33:02,010 --> 00:33:03,990
yeah. SO what it's gonna do is send a\ \

00:33:03,990 --> 00:33:07,710
message back to the parent. And I'm using Elixir,\

00:33:07,710 --> 00:33:11,820
\ oops, arrow thing here, which means send a

00:33:11,820 --> 00:33:12,250
message.\ \

00:33:12,250 --> 00:33:14,340
And what message am I gonna send? I am\ \

00:33:14,340 --> 00:33:19,990
gonna respond with my own process id, and the\

00:33:19,990 --> 00:33:23,960
\ value. And the value is fun dot. So I'm\

00:33:23,960 --> 00:33:28,460
\ calling the, the function on the current value.

00:33:28,460 --> 00:33:28,970
OK.\ \

00:33:28,970 --> 00:33:30,990
So here, what I've done is come back to\ \

00:33:30,990 --> 00:33:33,210
my original pmap up top there. I've done the\ \

00:33:33,210 --> 00:33:36,170
first part. I've spawned a separate process for each\

00:33:36,170 --> 00:33:37,840
\ value in my incoming collection, and it's

00:33:37,840 --> 00:33:38,940
now running\ \

00:33:38,940 --> 00:33:42,259
independently somewhere. So what you do now is collect\

00:33:42,259 --> 00:33:44,390
\ your results back. And to collect your results

00:33:44,390 --> 00:33:44,540
back,\ \

00:33:44,540 --> 00:33:46,150
I'm just gonna go down some lines so you\ \

00:33:46,150 --> 00:33:52,820
can see it, it's gonna look like this. Collect_results.\ \

00:33:52,820 --> 00:33:56,760
Now, the result of running all of this mapping\ \

00:33:56,760 --> 00:33:58,880
is that I'm gonna take a set of values\ \

00:33:58,880 --> 00:34:01,080
and convert it to a set of processes. So\ \

00:34:01,080 --> 00:34:04,200
my collect_results is gonna get passed a set of\

00:34:04,200 --> 00:34:07,030
\ process ids. And what I need to do is\

00:34:07,030 --> 00:34:09,919
\ to get the results from those processes in

00:34:09,919 --> 00:34:10,619
order.\ \

00:34:10,619 --> 00:34:13,829
So, I'm gonna use a, a receive block, and\ \

00:34:13,829 --> 00:34:18,119
that means go and receive a message, and pattern\ \

00:34:18,119 --> 00:34:21,280
matching allows me to control what message I receive,\

00:34:21,280 --> 00:34:21,760
\ when.\

00:34:21,760 --> 00:34:24,010
\ In this case, what I want to do is\

00:34:24,010 --> 00:34:26,059
\ to receive the message from a particular pid.

00:34:26,059 --> 00:34:26,319
OK.\ \

00:34:26,319 --> 00:34:28,790
So, I haven't got that yet. I'll get it\ \

00:34:28,790 --> 00:34:30,710
in a sec. And it's gonna come back with\ \

00:34:30,710 --> 00:34:32,739
a pid and a value, and out of all,\ \

00:34:32,739 --> 00:34:35,059
the only part of that I'm interested in is\ \

00:34:35,059 --> 00:34:39,089
the value. So, my problem here is that my\ \

00:34:39,089 --> 00:34:41,919
collect_results has got a whole list of pids. I\

00:34:41,919 --> 00:34:44,020
\ want the result to be a particular pid, so\

00:34:44,020 --> 00:34:45,909
\ I'm gonna break that into two methods here.

00:34:45,909 --> 00:34:46,149
So\ \

00:34:46,149 --> 00:34:50,609
I'm gonna say pids transform them by mapping them\

00:34:50,609 --> 00:34:56,249
\ through the function collect_result_for_pid.

00:34:56,249 --> 00:35:01,640
And, again, it takes the\ \

00:35:01,640 --> 00:35:05,089
pid as a parameter, and now I'm gonna have\ \

00:35:05,089 --> 00:35:10,069
a method called def collect_results_for_pid, it takes a pid,\

00:35:10,069 --> 00:35:11,959
\ and away we go.\

00:35:11,959 --> 00:35:15,519
\ AUDIENCE: You have a naming, naming problem

00:35:15,519 --> 00:35:16,640
on line\ \

00:35:16,640 --> 00:35:17,579
twenty-six.\ \

00:35:17,579 --> 00:35:19,609
D.T.: Line twenty-six. That. Oh, look at that. Collect.\

00:35:19,609 --> 00:35:21,339
\ Yes. Thank you. I mean, the chances of it\

00:35:21,339 --> 00:35:22,400
\ actually running the first time are about

00:35:22,400 --> 00:35:23,400
zero. But\ \

00:35:23,400 --> 00:35:25,309
we'll, we'll give it a go. All right. I\ \

00:35:25,309 --> 00:35:26,949
mean, given my luck this afternoon, it's gonna be\

00:35:26,949 --> 00:35:28,659
\ like, it'll blow my machine up or something.\

00:35:28,659 --> 00:35:31,599
\ So, what I've done here is actually a fair\

00:35:31,599 --> 00:35:33,529
\ amount of typing. I don't have to make it\

00:35:33,529 --> 00:35:36,130
\ so big. but what I'm doing, what I'm doing\

00:35:36,130 --> 00:35:37,899
\ instead is spelling it out so I can show\

00:35:37,899 --> 00:35:41,150
\ you my thought process. So if we run this,\

00:35:41,150 --> 00:35:44,029
\ and it blows up. What a surprise. Function

00:35:44,029 --> 00:35:44,489
collection_results\ \

00:35:44,489 --> 00:35:47,509
does not exist. So somewhere I've used collection_results.\ \

00:35:47,509 --> 00:35:48,619
AuDIENCE: [indecipherable]\ \

00:35:48,619 --> 00:35:53,609
D.T.: Should be collect_results, right. And it fails again.\

00:35:53,609 --> 00:35:58,339
\ You see, it's very. Oh, that's my test failing.\

00:35:58,339 --> 00:36:05,339
\ All right. Fix that up. Yay! All right.\

00:36:06,289 --> 00:36:09,200
\ So I changed that form being map to pmap.\

00:36:09,200 --> 00:36:14,430
\ Still works. Cool. Just to make sure that

00:36:14,430 --> 00:36:16,369
can actually see that, and I know I'm about\ \

00:36:16,369 --> 00:36:18,730
to get bum rushed, right. OK, I'm just gonna\ \

00:36:18,730 --> 00:36:21,650
show you just one cool thing. And that is,\ \

00:36:21,650 --> 00:36:25,670
if I take that file, which is called what?\ \

00:36:25,670 --> 00:36:30,609
T. My god I'm imaginative. OK.\ \

00:36:30,609 --> 00:36:37,609
Oh, that's the wrong t. Hmm. Oh, there it\ \

00:36:41,819 --> 00:36:48,819
is. If there are any Brits you'll know why\ \

00:36:52,700 --> 00:36:56,719
I called this directory BluePeter, because here's some examples\

00:36:56,719 --> 00:37:02,369
\ I prepared for earlier. All right. So now

00:37:02,369 --> 00:37:02,809
I've\ \

00:37:02,809 --> 00:37:05,640
loaded that file into my Elixir, so I can\ \

00:37:05,640 --> 00:37:08,069
call Sequence. Actually I can't call Sequence. Actually I\

00:37:08,069 --> 00:37:10,019
\ can't call Sequence. Import Sequence. All

00:37:10,019 --> 00:37:12,460
right, so now\ \

00:37:12,460 --> 00:37:17,390
I can say fib(30), say, and there's the result.\ \

00:37:17,390 --> 00:37:21,980
So, if I now run fib, if I run\ \

00:37:21,980 --> 00:37:28,980
regular map. So map, say, thir- oh, let's make\

00:37:29,490 --> 00:37:34,710
\ it thirty-five. Five, thirty-six, thirty-seven,

00:37:34,710 --> 00:37:38,470
thirty-eight, thirty-nine, and forty.\ \

00:37:38,470 --> 00:37:42,730
And I map it through the fibonacci thing. Hey,\

00:37:42,730 --> 00:37:47,509
\ everybody's picky. All right. And it blows

00:37:47,509 --> 00:37:48,900
up. Why\ \

00:37:48,900 --> 00:37:55,160
did it blow up? Oh. Thank you. OK. So,\ \

00:37:55,160 --> 00:37:57,239
if, while it's doing this, I call up my\ \

00:37:57,239 --> 00:38:02,420
activity monitor, you'll see that I'm running on one\

00:38:02,420 --> 00:38:07,019
\ CPU, you know. And there's the results. If

00:38:07,019 --> 00:38:07,319
I\ \

00:38:07,319 --> 00:38:13,549
change this to use pmap, I'm running on all\ \

00:38:13,549 --> 00:38:19,079
That cool? All right. I've got, I could go\ \

00:38:19,079 --> 00:38:22,960
on for days, but then you won't let me\ \

00:38:22,960 --> 00:38:26,560
come back. So, I want to come back. So.\ \

00:38:26,560 --> 00:38:27,060
V.O.: Thank you Dave.\ \

00:38:27,060 --> 00:38:28,540

YouTube URL: https://www.youtube.com/watch?v=KQwEmdOH-GM


