Title: RustConf 2020 - Macros for a More Productive Rust by jam1garner
Publication date: 2021-04-19
Playlist: RustConf 2020
Description: 
	Macros for a More Productive Rust by jam1garner

The macro system in Rust is still arguably in its infancy. While a lot of the implementation has already been done, plenty of projects don't properly take advantage of macros due to the limited resources on what macro programming should look like. This talk is aimed at introducing those interested in using macros in existing or future projects to macro idioms often needed in order to take projects to the next level.
Captions: 
	00:00:17,039 --> 00:00:20,240
hey

00:00:17,520 --> 00:00:21,520
so this is macros for a more productive

00:00:20,240 --> 00:00:23,600
rust

00:00:21,520 --> 00:00:24,880
uh just a little bit about me before i

00:00:23,600 --> 00:00:28,480
get started

00:00:24,880 --> 00:00:30,960
my name is jam i use hem pronouns

00:00:28,480 --> 00:00:33,200
professionally i do security research

00:00:30,960 --> 00:00:33,520
however in my free time i mostly focus

00:00:33,200 --> 00:00:37,200
on

00:00:33,520 --> 00:00:41,440
modding uh general open source

00:00:37,200 --> 00:00:46,079
stuff so

00:00:41,440 --> 00:00:48,000
macros here's the simplest macro

00:00:46,079 --> 00:00:49,600
it's composed of only a few parts you

00:00:48,000 --> 00:00:51,920
have the

00:00:49,600 --> 00:00:53,680
declaration which just sets what the

00:00:51,920 --> 00:00:56,399
name of the macro is

00:00:53,680 --> 00:00:57,280
you have the pattern which essentially

00:00:56,399 --> 00:01:00,559
handles

00:00:57,280 --> 00:01:04,400
parsing the input to the macro

00:01:00,559 --> 00:01:06,320
so you might have different types of

00:01:04,400 --> 00:01:08,240
syntax fragments so you might have

00:01:06,320 --> 00:01:08,880
expressions you might have names of

00:01:08,240 --> 00:01:12,159
types

00:01:08,880 --> 00:01:14,479
you might have identifiers

00:01:12,159 --> 00:01:16,320
you can basically pass arbitrary rust

00:01:14,479 --> 00:01:18,000
into it and you can set

00:01:16,320 --> 00:01:19,360
what different things you want to match

00:01:18,000 --> 00:01:21,920
against

00:01:19,360 --> 00:01:24,640
and so then you have the expansion which

00:01:21,920 --> 00:01:28,320
the expansion is what the macro becomes

00:01:24,640 --> 00:01:31,520
after you call it so as the name implies

00:01:28,320 --> 00:01:32,880
it is what it expands into uh so and

00:01:31,520 --> 00:01:36,000
then you also have

00:01:32,880 --> 00:01:39,360
here's an instance in

00:01:36,000 --> 00:01:42,079
here's an example of calling the macro

00:01:39,360 --> 00:01:44,000
so in this case just passing in a symbol

00:01:42,079 --> 00:01:46,240
3 which is a valid expression

00:01:44,000 --> 00:01:47,840
and if we want to see what it looks like

00:01:46,240 --> 00:01:50,399
when this expands

00:01:47,840 --> 00:01:51,920
we just basically take the expansion and

00:01:50,399 --> 00:01:54,320
we template in

00:01:51,920 --> 00:01:55,360
the variable that we're passing in so in

00:01:54,320 --> 00:01:58,799
this case it's just

00:01:55,360 --> 00:01:59,040
num which is uh going to be prefixed by

00:01:58,799 --> 00:02:02,079
a

00:01:59,040 --> 00:02:02,880
dollar sign and so then it expands to

00:02:02,079 --> 00:02:04,799
this

00:02:02,880 --> 00:02:07,040
if you want to expand things on your own

00:02:04,799 --> 00:02:07,759
there's two really great resources for

00:02:07,040 --> 00:02:09,920
it there's

00:02:07,759 --> 00:02:11,200
cargo expand which is a cargo sub

00:02:09,920 --> 00:02:14,080
command

00:02:11,200 --> 00:02:15,280
made by david tolnay which is which just

00:02:14,080 --> 00:02:19,440
allows you to see

00:02:15,280 --> 00:02:21,040
okay what happens when my macro expands

00:02:19,440 --> 00:02:24,080
what is it expanding to

00:02:21,040 --> 00:02:27,360
and you also have the ability to

00:02:24,080 --> 00:02:29,440
under the rust playground at the bottom

00:02:27,360 --> 00:02:30,879
of the tool section you have the ability

00:02:29,440 --> 00:02:33,680
to expand your macros

00:02:30,879 --> 00:02:35,360
and so highly recommend going on rust

00:02:33,680 --> 00:02:36,239
playground in order to play around with

00:02:35,360 --> 00:02:40,319
that

00:02:36,239 --> 00:02:42,640
so another feature of macros

00:02:40,319 --> 00:02:43,680
is that you can have it match against

00:02:42,640 --> 00:02:46,400
something

00:02:43,680 --> 00:02:47,200
multiple times so kind of like regex

00:02:46,400 --> 00:02:49,280
where you have

00:02:47,200 --> 00:02:50,959
star plus and question mark to control

00:02:49,280 --> 00:02:52,239
the amount of times you match against

00:02:50,959 --> 00:02:55,360
something

00:02:52,239 --> 00:02:58,640
it's exactly the same here in rust you

00:02:55,360 --> 00:03:01,599
define a capture group and then

00:02:58,640 --> 00:03:03,440
you say okay how many times do i want

00:03:01,599 --> 00:03:05,440
this to repeat so you use like star if

00:03:03,440 --> 00:03:06,720
you want zero or more you have question

00:03:05,440 --> 00:03:10,080
mark if you want it to

00:03:06,720 --> 00:03:12,480
be once or no times

00:03:10,080 --> 00:03:13,760
and then another the last you know big

00:03:12,480 --> 00:03:17,200
feature of

00:03:13,760 --> 00:03:19,680
macro rules macros is that you can have

00:03:17,200 --> 00:03:21,280
multiple different patterns that you're

00:03:19,680 --> 00:03:24,159
matching against

00:03:21,280 --> 00:03:26,480
and the different patterns can have

00:03:24,159 --> 00:03:27,200
different expansions and so that allows

00:03:26,480 --> 00:03:29,440
you

00:03:27,200 --> 00:03:30,720
to essentially encode parsing logic in

00:03:29,440 --> 00:03:32,959
order to figure out how you actually

00:03:30,720 --> 00:03:35,760
want to handle your expansion

00:03:32,959 --> 00:03:37,280
so in this case it's just a simple macro

00:03:35,760 --> 00:03:39,440
which expands

00:03:37,280 --> 00:03:41,280
differently based off of whether or not

00:03:39,440 --> 00:03:44,959
you pass a two or three into it

00:03:41,280 --> 00:03:45,599
simple enough so when we put those all

00:03:44,959 --> 00:03:48,239
together

00:03:45,599 --> 00:03:49,840
we can do a lot cooler things with macro

00:03:48,239 --> 00:03:52,879
rules macros

00:03:49,840 --> 00:03:56,560
so for example we have this trait called

00:03:52,879 --> 00:03:59,360
as bytes it's a simple trait all it does

00:03:56,560 --> 00:04:01,120
is takes whatever structure that

00:03:59,360 --> 00:04:04,799
implements as bytes

00:04:01,120 --> 00:04:05,680
and then it converts it into a vector of

00:04:04,799 --> 00:04:07,840
bytes

00:04:05,680 --> 00:04:09,920
so for example if we want to implement

00:04:07,840 --> 00:04:12,799
it for u16

00:04:09,920 --> 00:04:15,439
we might use the associated functions

00:04:12,799 --> 00:04:18,639
for converting u16s into bytes

00:04:15,439 --> 00:04:21,040
simple enough but the thing is is that

00:04:18,639 --> 00:04:22,400
if you have to type this in for every

00:04:21,040 --> 00:04:24,080
different integer type

00:04:22,400 --> 00:04:26,560
it's going to be a lot of repetitive

00:04:24,080 --> 00:04:29,759
code and it's not going to be easy

00:04:26,560 --> 00:04:31,600
to manage it after you've written it

00:04:29,759 --> 00:04:33,199
and it's going to be harder to not

00:04:31,600 --> 00:04:35,040
necessarily harder to read but it's just

00:04:33,199 --> 00:04:36,880
going to be a lot to read

00:04:35,040 --> 00:04:39,600
and anytime you have to go in and make a

00:04:36,880 --> 00:04:43,199
change you have to change all of them

00:04:39,600 --> 00:04:45,919
but we can remove that if we use

00:04:43,199 --> 00:04:46,960
repetition from before in order to

00:04:45,919 --> 00:04:49,199
implement

00:04:46,960 --> 00:04:50,720
the trait for all of the integer types

00:04:49,199 --> 00:04:52,960
at once and so

00:04:50,720 --> 00:04:54,240
the way we can do that is first we just

00:04:52,960 --> 00:04:58,160
wrap our example

00:04:54,240 --> 00:05:02,320
implementation in a macro

00:04:58,160 --> 00:05:05,520
we set it to repeat we then

00:05:02,320 --> 00:05:07,360
make it so that we have our pattern be

00:05:05,520 --> 00:05:09,360
matching against repeated comma

00:05:07,360 --> 00:05:11,440
separated type names

00:05:09,360 --> 00:05:12,560
and then we replace every instance of

00:05:11,440 --> 00:05:15,280
u16

00:05:12,560 --> 00:05:15,600
with our type name and so that allows it

00:05:15,280 --> 00:05:18,240
to

00:05:15,600 --> 00:05:20,400
it says okay generate this code in

00:05:18,240 --> 00:05:23,440
multiple repetitions of it

00:05:20,400 --> 00:05:24,400
for whatever given types we pass in and

00:05:23,440 --> 00:05:26,960
so

00:05:24,400 --> 00:05:28,160
then if we call it with all of the types

00:05:26,960 --> 00:05:30,000
it'll generate

00:05:28,160 --> 00:05:31,199
implementations for all of those types

00:05:30,000 --> 00:05:32,560
and then we only have

00:05:31,199 --> 00:05:35,759
one implementation that we have to

00:05:32,560 --> 00:05:40,479
maintain and it's the templated one

00:05:35,759 --> 00:05:43,199
and so some intermediate techniques for

00:05:40,479 --> 00:05:44,400
macro rules macros is you can use

00:05:43,199 --> 00:05:46,639
internal rules

00:05:44,400 --> 00:05:48,160
which basically in this example we have

00:05:46,639 --> 00:05:51,440
two macros we have

00:05:48,160 --> 00:05:54,000
macro one we have macro two and macro 1

00:05:51,440 --> 00:05:55,600
calls onto macro 2 and that might be

00:05:54,000 --> 00:05:57,120
necessary because

00:05:55,600 --> 00:05:59,600
like i said earlier the only way to

00:05:57,120 --> 00:06:02,800
really encode parsing logic

00:05:59,600 --> 00:06:05,280
is if you have multiple patterns

00:06:02,800 --> 00:06:07,840
or rules that you are matching against

00:06:05,280 --> 00:06:10,800
in order to encode that logic and so

00:06:07,840 --> 00:06:11,919
if we have to have multiple steps of

00:06:10,800 --> 00:06:14,479
parsing logic

00:06:11,919 --> 00:06:16,560
then we end up having to have

00:06:14,479 --> 00:06:18,560
essentially multiple macros to handle

00:06:16,560 --> 00:06:21,600
each layer of logic

00:06:18,560 --> 00:06:22,960
and so in this case uh this actually

00:06:21,600 --> 00:06:26,319
causes a problem because

00:06:22,960 --> 00:06:27,840
if we import macro 1 into scope but not

00:06:26,319 --> 00:06:30,720
macro 2

00:06:27,840 --> 00:06:32,000
then macro 1 tries to use macro 2 after

00:06:30,720 --> 00:06:34,880
it expands

00:06:32,000 --> 00:06:35,520
but it's not in scope so how do we fix

00:06:34,880 --> 00:06:37,600
this

00:06:35,520 --> 00:06:38,960
so basically what we're going to do is

00:06:37,600 --> 00:06:41,840
we're going to collapse the two

00:06:38,960 --> 00:06:42,319
into a single macro and so the way we do

00:06:41,840 --> 00:06:44,479
that

00:06:42,319 --> 00:06:46,000
is with internal rules and internal

00:06:44,479 --> 00:06:48,720
rules are basically

00:06:46,000 --> 00:06:49,120
you have a pattern that starts with act

00:06:48,720 --> 00:06:51,039
which

00:06:49,120 --> 00:06:52,880
that's just by convention but it's

00:06:51,039 --> 00:06:55,680
highly recommended because

00:06:52,880 --> 00:06:56,400
at isn't really used very often in rust

00:06:55,680 --> 00:06:58,560
syntax

00:06:56,400 --> 00:06:59,680
so it's not likely to cause any

00:06:58,560 --> 00:07:01,120
collisions with

00:06:59,680 --> 00:07:04,400
the things you're actually trying to

00:07:01,120 --> 00:07:06,400
match against and so in this case

00:07:04,400 --> 00:07:08,000
since our previous macro is called macro

00:07:06,400 --> 00:07:11,280
tool 2

00:07:08,000 --> 00:07:11,680
we instead have a rule that matches

00:07:11,280 --> 00:07:14,160
against

00:07:11,680 --> 00:07:15,599
at macro2 and so basically what that

00:07:14,160 --> 00:07:17,919
allows us to do

00:07:15,599 --> 00:07:18,720
is we can have macro1 recursively call

00:07:17,919 --> 00:07:21,840
itself

00:07:18,720 --> 00:07:22,400
but then passing at macro2 at the start

00:07:21,840 --> 00:07:25,440
of the

00:07:22,400 --> 00:07:27,280
inputs to macro one in order to call the

00:07:25,440 --> 00:07:30,160
internal rule

00:07:27,280 --> 00:07:30,720
and so another important technique is

00:07:30,160 --> 00:07:34,479
called

00:07:30,720 --> 00:07:35,520
a tt mantra and so tt stands for token

00:07:34,479 --> 00:07:37,120
tree

00:07:35,520 --> 00:07:38,639
and basically what's happening here is

00:07:37,120 --> 00:07:41,280
that if you

00:07:38,639 --> 00:07:42,560
everything in rust is going to be split

00:07:41,280 --> 00:07:44,720
up into tokens

00:07:42,560 --> 00:07:45,599
uh you a basically in a tree format

00:07:44,720 --> 00:07:48,319
because

00:07:45,599 --> 00:07:49,440
if you have like brackets everything

00:07:48,319 --> 00:07:51,599
inside of the brackets

00:07:49,440 --> 00:07:54,319
is going to be a child of that the

00:07:51,599 --> 00:07:57,520
bracket tokens in your token tree

00:07:54,319 --> 00:07:59,360
and so if you match against repeated

00:07:57,520 --> 00:08:00,720
token trees then you match against

00:07:59,360 --> 00:08:03,199
everything that gets passed into the

00:08:00,720 --> 00:08:05,680
macro and so if you match against

00:08:03,199 --> 00:08:06,639
something and then the rest of the token

00:08:05,680 --> 00:08:09,919
trees

00:08:06,639 --> 00:08:11,919
then you can essentially say okay i'm

00:08:09,919 --> 00:08:13,680
only matching against the first token

00:08:11,919 --> 00:08:14,960
and then i can pass the rest of those

00:08:13,680 --> 00:08:17,599
token trees

00:08:14,960 --> 00:08:18,479
back into the macro and so i can handle

00:08:17,599 --> 00:08:21,520
parsing

00:08:18,479 --> 00:08:24,319
one set of tokens at a time so

00:08:21,520 --> 00:08:24,800
in this example we have matching against

00:08:24,319 --> 00:08:26,960
either

00:08:24,800 --> 00:08:29,759
up or down and each time it's followed

00:08:26,960 --> 00:08:31,520
by the rest of the token trees

00:08:29,759 --> 00:08:33,919
and so if we actually look at what that

00:08:31,520 --> 00:08:37,039
what happens when we try to handle that

00:08:33,919 --> 00:08:38,399
is we have up up down down and then it

00:08:37,039 --> 00:08:41,440
matches against that first

00:08:38,399 --> 00:08:43,839
up for the first branch of it

00:08:41,440 --> 00:08:46,000
and then it take captures the up down

00:08:43,839 --> 00:08:48,560
down as the rest of the token trees

00:08:46,000 --> 00:08:49,279
and then it passes that back in to the

00:08:48,560 --> 00:08:51,839
macro

00:08:49,279 --> 00:08:53,200
so then it's just another call of up

00:08:51,839 --> 00:08:55,040
down down and then there's those

00:08:53,200 --> 00:08:56,240
recursive calls allow us to handle it

00:08:55,040 --> 00:08:59,040
one at a time going

00:08:56,240 --> 00:09:00,959
down down and then down and then we hit

00:08:59,040 --> 00:09:04,399
our base case which is just

00:09:00,959 --> 00:09:07,519
when nothing gets passed in we then just

00:09:04,399 --> 00:09:09,040
do nothing and so after that it expands

00:09:07,519 --> 00:09:10,800
into nothing and then we

00:09:09,040 --> 00:09:12,480
have all of our code and we've been able

00:09:10,800 --> 00:09:14,560
to handle it one step

00:09:12,480 --> 00:09:16,000
one set of tokens at a time so we can

00:09:14,560 --> 00:09:19,200
have

00:09:16,000 --> 00:09:22,640
multiple repeating tokens but each one

00:09:19,200 --> 00:09:24,560
has parsing logic for handling okay

00:09:22,640 --> 00:09:26,959
i match against up where i match against

00:09:24,560 --> 00:09:28,800
down and so

00:09:26,959 --> 00:09:30,560
one really useful crate for when you're

00:09:28,800 --> 00:09:31,440
writing macro rules macros is called

00:09:30,560 --> 00:09:33,360
paste

00:09:31,440 --> 00:09:35,279
and so one of the limitations of macro

00:09:33,360 --> 00:09:37,279
rules macros is that you can't create

00:09:35,279 --> 00:09:38,880
new identifiers

00:09:37,279 --> 00:09:40,800
but what paste allows you to do to

00:09:38,880 --> 00:09:45,200
circumvent that is

00:09:40,800 --> 00:09:47,279
it allows you to concatenate different

00:09:45,200 --> 00:09:49,279
identifiers in order to create a new

00:09:47,279 --> 00:09:52,320
identifier so in this example it has

00:09:49,279 --> 00:09:54,000
the four identifiers q r s and t and it

00:09:52,320 --> 00:09:58,720
concatenates all of those to form

00:09:54,000 --> 00:09:58,720
q r s t and so

00:09:59,200 --> 00:10:04,720
absolutely great create

00:10:02,399 --> 00:10:06,000
if you wanted to find this crate or

00:10:04,720 --> 00:10:08,320
other crates like it

00:10:06,000 --> 00:10:09,120
uh david tolnay the person who actually

00:10:08,320 --> 00:10:12,160
made paste

00:10:09,120 --> 00:10:15,519
actually has a site that allows you

00:10:12,160 --> 00:10:16,959
to look at a lot of useful stuff related

00:10:15,519 --> 00:10:20,079
to macros

00:10:16,959 --> 00:10:20,079
it's actually his github

00:10:20,399 --> 00:10:26,240
so proc macros the other type of macro

00:10:24,560 --> 00:10:28,959
different from macro rules

00:10:26,240 --> 00:10:29,839
so proc macros the general idea is that

00:10:28,959 --> 00:10:32,880
you're writing

00:10:29,839 --> 00:10:36,000
another rust program which then

00:10:32,880 --> 00:10:39,040
takes in a series of tokens and then

00:10:36,000 --> 00:10:41,519
it returns a series of tokens

00:10:39,040 --> 00:10:43,279
and so for example we have function like

00:10:41,519 --> 00:10:46,720
macros which are basically

00:10:43,279 --> 00:10:47,760
the same thing as macro rules macros

00:10:46,720 --> 00:10:50,399
except they're a little bit more

00:10:47,760 --> 00:10:52,800
powerful because they're proc macros

00:10:50,399 --> 00:10:54,640
and you can have arbitrary rust logic

00:10:52,800 --> 00:10:56,240
for determining how you modify your

00:10:54,640 --> 00:11:00,399
stream of tokens

00:10:56,240 --> 00:11:03,040
so in this example it's a json macro

00:11:00,399 --> 00:11:04,560
from rocket and it allows you to

00:11:03,040 --> 00:11:07,519
essentially

00:11:04,560 --> 00:11:08,560
just trade up right json within your

00:11:07,519 --> 00:11:11,440
code

00:11:08,560 --> 00:11:14,000
and even use rust expressions as values

00:11:11,440 --> 00:11:15,600
or keys within your json

00:11:14,000 --> 00:11:17,440
and that's great for like if you're

00:11:15,600 --> 00:11:19,279
writing a web server and

00:11:17,440 --> 00:11:21,040
you want a quick ergonomic way to build

00:11:19,279 --> 00:11:23,440
a json response

00:11:21,040 --> 00:11:25,120
a wonderful way to do it and so then we

00:11:23,440 --> 00:11:26,959
also have attribute macros

00:11:25,120 --> 00:11:28,800
so attributes are just those little

00:11:26,959 --> 00:11:31,680
things that go before functions

00:11:28,800 --> 00:11:33,040
or static variables or anything like

00:11:31,680 --> 00:11:36,079
that

00:11:33,040 --> 00:11:39,519
and so what this allows us to do

00:11:36,079 --> 00:11:42,880
is essentially associate data

00:11:39,519 --> 00:11:46,160
or some action or something with the

00:11:42,880 --> 00:11:49,360
function or static or whatever

00:11:46,160 --> 00:11:50,399
itself and so in this example from

00:11:49,360 --> 00:11:53,279
rocket

00:11:50,399 --> 00:11:54,240
it's the get attribute macro and so what

00:11:53,279 --> 00:11:58,160
that allows you to do

00:11:54,240 --> 00:12:01,120
is you can mark a function as a http

00:11:58,160 --> 00:12:02,160
git handler and so in the example we

00:12:01,120 --> 00:12:04,959
have the path

00:12:02,160 --> 00:12:06,560
slash hello slash name slash age and

00:12:04,959 --> 00:12:09,920
basically what it does is it

00:12:06,560 --> 00:12:12,240
takes whatever url path you're going to

00:12:09,920 --> 00:12:15,760
so like it might be slash hello slash

00:12:12,240 --> 00:12:16,399
jam slash whatever and then it handles

00:12:15,760 --> 00:12:18,480
the

00:12:16,399 --> 00:12:20,000
name and age and actually passes it into

00:12:18,480 --> 00:12:21,839
those functions

00:12:20,000 --> 00:12:23,360
and so that allows you to remove a lot

00:12:21,839 --> 00:12:25,760
of boilerplate that would otherwise be

00:12:23,360 --> 00:12:28,240
required for either handling

00:12:25,760 --> 00:12:28,880
the different routes or actually

00:12:28,240 --> 00:12:30,480
handling

00:12:28,880 --> 00:12:32,160
pulling the information out of the

00:12:30,480 --> 00:12:34,800
routes and it makes it a little bit more

00:12:32,160 --> 00:12:37,519
robust as you don't actually have to

00:12:34,800 --> 00:12:40,160
have the error-prone nature of trying to

00:12:37,519 --> 00:12:43,440
pull that information out yourself

00:12:40,160 --> 00:12:46,399
and so lastly we have derived macros

00:12:43,440 --> 00:12:48,000
and essentially if you're familiar with

00:12:46,399 --> 00:12:48,959
rust you're probably familiar with the

00:12:48,000 --> 00:12:52,560
concept of

00:12:48,959 --> 00:12:55,839
deriving things like clone or debug

00:12:52,560 --> 00:12:58,079
or copy and so what derive macros allow

00:12:55,839 --> 00:13:00,720
you to do is allows you to

00:12:58,079 --> 00:13:03,680
have your own derived handler for

00:13:00,720 --> 00:13:06,800
implementing a trait automatically

00:13:03,680 --> 00:13:09,839
and so here's an example from saturday

00:13:06,800 --> 00:13:11,760
in which you can and what saturday

00:13:09,839 --> 00:13:13,760
allows you to do is allows you to derive

00:13:11,760 --> 00:13:17,360
serialize and deserialize for

00:13:13,760 --> 00:13:20,000
arbitrary structs or enums and

00:13:17,360 --> 00:13:21,200
then you can actually serialize it or

00:13:20,000 --> 00:13:24,240
deserialize it

00:13:21,200 --> 00:13:25,519
to and from whatever format supports

00:13:24,240 --> 00:13:28,160
certain so for example

00:13:25,519 --> 00:13:29,680
serde.json is a great for converting to

00:13:28,160 --> 00:13:34,000
and from

00:13:29,680 --> 00:13:37,360
json strings and it's absolutely great

00:13:34,000 --> 00:13:38,320
you should definitely check it out and

00:13:37,360 --> 00:13:40,880
so

00:13:38,320 --> 00:13:41,360
proc macros uh if you want to create one

00:13:40,880 --> 00:13:42,639
yourself

00:13:41,360 --> 00:13:45,360
all you have to do is create a new

00:13:42,639 --> 00:13:46,560
library throw proc macro equals true in

00:13:45,360 --> 00:13:47,839
your tomml

00:13:46,560 --> 00:13:50,480
and then you just have to make a

00:13:47,839 --> 00:13:53,360
function which takes in a token stream

00:13:50,480 --> 00:13:54,639
and outputs a different stream so here's

00:13:53,360 --> 00:13:56,880
an example

00:13:54,639 --> 00:13:58,240
of how we can make a proc macro and so

00:13:56,880 --> 00:14:01,279
what this does

00:13:58,240 --> 00:14:02,000
is this is a attribute macro which you

00:14:01,279 --> 00:14:04,720
put it

00:14:02,000 --> 00:14:06,639
at the top of a function and what it'll

00:14:04,720 --> 00:14:08,399
do is it'll insert a print statement at

00:14:06,639 --> 00:14:11,040
the beginning of the function

00:14:08,399 --> 00:14:11,839
so that it prints out okay i'm entering

00:14:11,040 --> 00:14:15,519
this function

00:14:11,839 --> 00:14:19,040
which allows you to trace things so

00:14:15,519 --> 00:14:22,399
basically the way this macro works

00:14:19,040 --> 00:14:25,440
is first up we have a line that uses syn

00:14:22,399 --> 00:14:29,440
parse macro input and so what syn is

00:14:25,440 --> 00:14:32,639
syn is it allows you to parse

00:14:29,440 --> 00:14:35,680
arbitrary rust source from

00:14:32,639 --> 00:14:36,480
tokens so like in this situation it's

00:14:35,680 --> 00:14:40,399
parsing the

00:14:36,480 --> 00:14:42,399
input to our proc macro as a function

00:14:40,399 --> 00:14:45,680
and it also handles the error handling

00:14:42,399 --> 00:14:47,519
for you so it'll give you a pretty error

00:14:45,680 --> 00:14:49,920
if they try if someone tries to pass in

00:14:47,519 --> 00:14:52,000
something other than a function

00:14:49,920 --> 00:14:54,800
and so then we take the name of the

00:14:52,000 --> 00:14:58,240
function and convert it to a string

00:14:54,800 --> 00:15:00,079
and so here's a sin

00:14:58,240 --> 00:15:01,600
parse quote and so what that allows you

00:15:00,079 --> 00:15:04,880
to do is

00:15:01,600 --> 00:15:08,639
quote is a crate which allows you

00:15:04,880 --> 00:15:11,920
to essentially pseudo quote

00:15:08,639 --> 00:15:12,959
your code and convert it to tokens so in

00:15:11,920 --> 00:15:15,839
this situation

00:15:12,959 --> 00:15:18,560
we have this macro parse quote and

00:15:15,839 --> 00:15:20,480
essentially we can just write whatever

00:15:18,560 --> 00:15:22,800
code we want in there kind of like when

00:15:20,480 --> 00:15:23,839
we're doing macro rules macros and we

00:15:22,800 --> 00:15:26,720
can template

00:15:23,839 --> 00:15:28,480
different tokens into it so in this case

00:15:26,720 --> 00:15:31,600
i take the function name and i template

00:15:28,480 --> 00:15:34,240
it into my code

00:15:31,600 --> 00:15:36,560
and then in this case since it's parse

00:15:34,240 --> 00:15:39,279
quote instead of just quote

00:15:36,560 --> 00:15:40,639
it then parses it into a statement in

00:15:39,279 --> 00:15:42,800
this situation

00:15:40,639 --> 00:15:45,279
and then we insert that statement at the

00:15:42,800 --> 00:15:48,240
beginning of our function block

00:15:45,279 --> 00:15:49,120
and then we use quote to convert the

00:15:48,240 --> 00:15:51,920
function

00:15:49,120 --> 00:15:53,680
back into tokens and return it and

00:15:51,920 --> 00:15:56,800
that's all it takes

00:15:53,680 --> 00:15:57,440
so let's see some things that show how

00:15:56,800 --> 00:16:01,120
powerful

00:15:57,440 --> 00:16:01,839
proc macros are so here's an example

00:16:01,120 --> 00:16:04,160
called

00:16:01,839 --> 00:16:05,199
tree flexion and if you're at all

00:16:04,160 --> 00:16:07,440
familiar with c

00:16:05,199 --> 00:16:08,560
sharp or java or other object-oriented

00:16:07,440 --> 00:16:10,720
languages

00:16:08,560 --> 00:16:12,560
that have the feature of reflection

00:16:10,720 --> 00:16:16,240
essentially what it allows you to do

00:16:12,560 --> 00:16:16,639
is it allows you to at runtime take a

00:16:16,240 --> 00:16:20,000
look

00:16:16,639 --> 00:16:22,800
at what are the actual names

00:16:20,000 --> 00:16:24,160
of fields within like a structure or

00:16:22,800 --> 00:16:26,240
class or whatever

00:16:24,160 --> 00:16:28,160
and what's the layout of them and that

00:16:26,240 --> 00:16:31,759
essentially allows you to

00:16:28,160 --> 00:16:35,600
just kind of have have programming

00:16:31,759 --> 00:16:38,240
related to the layout of your struct

00:16:35,600 --> 00:16:39,120
and so in game dev you might use that to

00:16:38,240 --> 00:16:42,399
allow

00:16:39,120 --> 00:16:47,440
your developer console to

00:16:42,399 --> 00:16:49,600
modify arbitrary structures at runtime

00:16:47,440 --> 00:16:52,079
and that's a very useful tool and so

00:16:49,600 --> 00:16:53,600
what derive macros in this situation

00:16:52,079 --> 00:16:55,120
allow you to do is you can actually kind

00:16:53,600 --> 00:16:57,519
of replicate

00:16:55,120 --> 00:16:58,880
reflection but instead of handling it

00:16:57,519 --> 00:17:01,759
all at runtime and

00:16:58,880 --> 00:17:03,759
incurring those costs you can instead

00:17:01,759 --> 00:17:05,439
have it at compile time because

00:17:03,759 --> 00:17:07,439
you can derive it for each of your

00:17:05,439 --> 00:17:09,839
structures that you're using

00:17:07,439 --> 00:17:11,360
and first off you're not paying for it

00:17:09,839 --> 00:17:13,120
for any of the structures that you don't

00:17:11,360 --> 00:17:16,559
want accessible

00:17:13,120 --> 00:17:19,039
but also you can generate efficient code

00:17:16,559 --> 00:17:20,959
for each different type and that allows

00:17:19,039 --> 00:17:24,240
you to

00:17:20,959 --> 00:17:26,079
essentially have it so you have compile

00:17:24,240 --> 00:17:28,000
time reflection where you're generating

00:17:26,079 --> 00:17:30,080
unique functions for each type that

00:17:28,000 --> 00:17:32,960
handle it as efficiently as possible for

00:17:30,080 --> 00:17:35,200
that specific type

00:17:32,960 --> 00:17:36,640
and so here's another example this is a

00:17:35,200 --> 00:17:39,440
macro i wrote called bin

00:17:36,640 --> 00:17:40,000
read i definitely recommend you check it

00:17:39,440 --> 00:17:43,600
out if

00:17:40,000 --> 00:17:46,720
you are doing any binary parsing

00:17:43,600 --> 00:17:48,799
but essentially the idea of it is

00:17:46,720 --> 00:17:50,880
instead of writing a bunch of code for

00:17:48,799 --> 00:17:54,880
handling your parsing logic

00:17:50,880 --> 00:17:57,600
instead use your struct declaration

00:17:54,880 --> 00:17:58,320
and use the ordering of your field and

00:17:57,600 --> 00:18:01,200
some

00:17:58,320 --> 00:18:02,080
metadata in attributes in order to

00:18:01,200 --> 00:18:05,520
actually

00:18:02,080 --> 00:18:06,880
encode the parsing logic so that you

00:18:05,520 --> 00:18:08,640
don't actually have to write your

00:18:06,880 --> 00:18:10,320
parsing code you have your parsing code

00:18:08,640 --> 00:18:12,400
generated for you

00:18:10,320 --> 00:18:16,720
and so that allows you to have kind of

00:18:12,400 --> 00:18:18,480
declarative programming for your parsing

00:18:16,720 --> 00:18:20,960
and i think that was a pretty successful

00:18:18,480 --> 00:18:22,640
experiment but one cool thing you can

00:18:20,960 --> 00:18:24,559
kind of learn from this is basically

00:18:22,640 --> 00:18:25,520
when you're implementing a derived macro

00:18:24,559 --> 00:18:28,640
what you want to do

00:18:25,520 --> 00:18:31,919
is you want to offload as much of the

00:18:28,640 --> 00:18:33,520
lot the actual like code out of the proc

00:18:31,919 --> 00:18:36,640
macro itself and into

00:18:33,520 --> 00:18:39,360
for example like a trait so in this case

00:18:36,640 --> 00:18:40,000
i have like been read the trait in

00:18:39,360 --> 00:18:43,120
question

00:18:40,000 --> 00:18:45,760
implemented for all of the like integer

00:18:43,120 --> 00:18:47,840
types and all the other primitives

00:18:45,760 --> 00:18:49,840
and then some more helper types and then

00:18:47,840 --> 00:18:51,679
my derived macro all it does is it

00:18:49,840 --> 00:18:55,440
generates some code

00:18:51,679 --> 00:18:56,000
that a uses the attributes involved with

00:18:55,440 --> 00:18:59,440
it in order

00:18:56,000 --> 00:19:02,880
to generate some code but also b

00:18:59,440 --> 00:19:03,919
to handle just kind of recursively

00:19:02,880 --> 00:19:05,600
calling the trait

00:19:03,919 --> 00:19:07,840
on the types used in the struct and

00:19:05,600 --> 00:19:10,480
that's basically how all derived macros

00:19:07,840 --> 00:19:13,039
are going to work

00:19:10,480 --> 00:19:13,039
and so

00:19:13,150 --> 00:19:18,480
[Music]

00:19:14,720 --> 00:19:19,280
and so here's one of the really coolest

00:19:18,480 --> 00:19:22,960
examples

00:19:19,280 --> 00:19:25,039
of how you can use function like macros

00:19:22,960 --> 00:19:27,280
and for a function like proc macros

00:19:25,039 --> 00:19:29,919
since you can just

00:19:27,280 --> 00:19:30,799
write arbitrary tokens in there because

00:19:29,919 --> 00:19:33,520
it's imbe

00:19:30,799 --> 00:19:35,840
it's inside of a separator and therefore

00:19:33,520 --> 00:19:38,320
doesn't actually have to

00:19:35,840 --> 00:19:39,679
be valid rust like an attribute macro if

00:19:38,320 --> 00:19:42,400
you attach it to a function

00:19:39,679 --> 00:19:43,280
it still has to be a valid function but

00:19:42,400 --> 00:19:47,039
within it

00:19:43,280 --> 00:19:49,120
you can kind of it has to parse properly

00:19:47,039 --> 00:19:51,440
but with function like macros since all

00:19:49,120 --> 00:19:53,919
of your tokens are like in parentheses

00:19:51,440 --> 00:19:55,039
you can essentially have arbitrary

00:19:53,919 --> 00:19:58,080
tokens and you can

00:19:55,039 --> 00:19:58,640
encode your own syntax so like maybe

00:19:58,080 --> 00:20:01,600
something

00:19:58,640 --> 00:20:02,000
that's domain specific like on the top

00:20:01,600 --> 00:20:05,440
left

00:20:02,000 --> 00:20:08,640
i'm encoding some information about okay

00:20:05,440 --> 00:20:10,159
this is just a arbitrary language that

00:20:08,640 --> 00:20:12,960
allows you to encode

00:20:10,159 --> 00:20:13,760
moveset information for a game so like

00:20:12,960 --> 00:20:17,280
okay

00:20:13,760 --> 00:20:21,280
wait 16 frames and then create

00:20:17,280 --> 00:20:23,520
a hitbox and then do this and that

00:20:21,280 --> 00:20:25,760
but an even cooler example of using that

00:20:23,520 --> 00:20:28,880
is this crate called inline python

00:20:25,760 --> 00:20:32,080
and so you might think inline python

00:20:28,880 --> 00:20:33,919
that doesn't make any sense rust has

00:20:32,080 --> 00:20:35,280
like it it doesn't care about white

00:20:33,919 --> 00:20:37,120
space it's

00:20:35,280 --> 00:20:38,880
completely ignores it it just parses the

00:20:37,120 --> 00:20:40,000
tokens between the white space so how

00:20:38,880 --> 00:20:42,640
can you encode

00:20:40,000 --> 00:20:43,840
python like python is dependent on the

00:20:42,640 --> 00:20:45,600
white space you have to have your

00:20:43,840 --> 00:20:48,080
tabbing correct and everything

00:20:45,600 --> 00:20:49,280
but the thing is is what inline python

00:20:48,080 --> 00:20:51,760
does

00:20:49,280 --> 00:20:52,480
is it looks at your tokens so for

00:20:51,760 --> 00:20:54,799
example

00:20:52,480 --> 00:20:56,559
in the bottom right we have like the

00:20:54,799 --> 00:20:58,320
four and then we have the print on the

00:20:56,559 --> 00:21:00,559
next line and we can look at the line

00:20:58,320 --> 00:21:02,400
numbers of those tokens and we can look

00:21:00,559 --> 00:21:04,240
at the column numbers of this tokens and

00:21:02,400 --> 00:21:05,120
we can figure out okay there is a tab in

00:21:04,240 --> 00:21:07,840
here and we can

00:21:05,120 --> 00:21:09,679
recreate the white space from the

00:21:07,840 --> 00:21:12,720
positions of the tokens

00:21:09,679 --> 00:21:16,000
and this allows you to essentially write

00:21:12,720 --> 00:21:18,000
arbitrary inline languages for

00:21:16,000 --> 00:21:19,440
your specific domain so if you want to

00:21:18,000 --> 00:21:21,440
write python

00:21:19,440 --> 00:21:23,360
that pulls rust variables you can use

00:21:21,440 --> 00:21:25,600
inline python or you can

00:21:23,360 --> 00:21:27,760
write your own and that's insanely

00:21:25,600 --> 00:21:29,919
powerful

00:21:27,760 --> 00:21:30,880
and so here's an example of an attribute

00:21:29,919 --> 00:21:33,840
macro

00:21:30,880 --> 00:21:34,400
also one i wrote it's called skyline

00:21:33,840 --> 00:21:36,480
hook

00:21:34,400 --> 00:21:38,400
and essentially what it does is it

00:21:36,480 --> 00:21:41,039
allows you to replace

00:21:38,400 --> 00:21:41,840
a function in another binary with your

00:21:41,039 --> 00:21:43,600
rust function

00:21:41,840 --> 00:21:45,280
so in this case you just provide it like

00:21:43,600 --> 00:21:48,240
a program counter

00:21:45,280 --> 00:21:49,520
and then you provide your function and

00:21:48,240 --> 00:21:51,840
then it allows you to

00:21:49,520 --> 00:21:53,760
replace that by doing a bunch of

00:21:51,840 --> 00:21:54,240
nonsense in the background to actually

00:21:53,760 --> 00:21:56,080
handle

00:21:54,240 --> 00:21:57,760
like the code patching and everything

00:21:56,080 --> 00:22:00,000
like that

00:21:57,760 --> 00:22:01,039
and it even allows you to call the

00:22:00,000 --> 00:22:02,799
original function

00:22:01,039 --> 00:22:04,880
in case you actually just want to like

00:22:02,799 --> 00:22:05,840
modify some of the input variables and

00:22:04,880 --> 00:22:08,720
then

00:22:05,840 --> 00:22:10,720
defer to the original uh and one great

00:22:08,720 --> 00:22:15,200
example of how someone used that

00:22:10,720 --> 00:22:18,400
is a somebody made a pokemon randomizer

00:22:15,200 --> 00:22:19,840
um and so it really just takes one like

00:22:18,400 --> 00:22:22,880
50 line function

00:22:19,840 --> 00:22:24,880
or it just randomizes some values in

00:22:22,880 --> 00:22:26,799
some function it's overriding and that's

00:22:24,880 --> 00:22:28,799
all it takes

00:22:26,799 --> 00:22:29,919
and the attribute macro actually handles

00:22:28,799 --> 00:22:32,080
all of the

00:22:29,919 --> 00:22:33,520
inserting your code patching and

00:22:32,080 --> 00:22:37,039
everything like that

00:22:33,520 --> 00:22:40,000
but can we take macros even further

00:22:37,039 --> 00:22:41,120
so in an earlier talk esteban started

00:22:40,000 --> 00:22:42,960
talking a lot

00:22:41,120 --> 00:22:44,320
about rus plus plus and it got me

00:22:42,960 --> 00:22:46,960
thinking you know like

00:22:44,320 --> 00:22:48,080
rust great language i love it it's my

00:22:46,960 --> 00:22:50,640
favorite language

00:22:48,080 --> 00:22:51,280
but like it still needs a lot of

00:22:50,640 --> 00:22:54,720
features

00:22:51,280 --> 00:22:57,039
like if you think about it like it can't

00:22:54,720 --> 00:22:58,720
interrupt with c plus at all like what's

00:22:57,039 --> 00:23:01,200
up with that and like

00:22:58,720 --> 00:23:02,880
also i don't have the ability to do

00:23:01,200 --> 00:23:05,200
inheritance like

00:23:02,880 --> 00:23:06,799
is russ not even an object-oriented

00:23:05,200 --> 00:23:08,159
programming language like i don't

00:23:06,799 --> 00:23:11,440
understand so like

00:23:08,159 --> 00:23:14,799
the conclusion i came to is rust must be

00:23:11,440 --> 00:23:16,400
a bad language like you know a good

00:23:14,799 --> 00:23:19,919
language like sipos plus

00:23:16,400 --> 00:23:23,440
has these features uh kidding obviously

00:23:19,919 --> 00:23:25,280
um but uh

00:23:23,440 --> 00:23:27,039
still this got me thinking about like oh

00:23:25,280 --> 00:23:29,280
you know

00:23:27,039 --> 00:23:30,799
what if we actually introduce

00:23:29,280 --> 00:23:34,080
inheritance and c

00:23:30,799 --> 00:23:36,480
plus interoperability with a macro

00:23:34,080 --> 00:23:38,159
uh and so i made this crate called cpp

00:23:36,480 --> 00:23:41,039
inherit and what it allows you to do

00:23:38,159 --> 00:23:41,520
is it allows you to inherit rust types

00:23:41,039 --> 00:23:44,080
from

00:23:41,520 --> 00:23:45,919
c plus plus types and even like override

00:23:44,080 --> 00:23:46,400
virtual functions and in the background

00:23:45,919 --> 00:23:48,720
it

00:23:46,400 --> 00:23:50,720
you know calls out to gcc and it says

00:23:48,720 --> 00:23:53,760
compile this header file

00:23:50,720 --> 00:23:57,200
and give me the dwarf information for it

00:23:53,760 --> 00:23:59,440
and show me what the v table layout is

00:23:57,200 --> 00:24:01,039
so that i can recreate it within rust

00:23:59,440 --> 00:24:04,000
and it generates a bunch of code in the

00:24:01,039 --> 00:24:07,120
background for handling that all for you

00:24:04,000 --> 00:24:07,679
so that you can inherit from c plus plus

00:24:07,120 --> 00:24:11,360
classes

00:24:07,679 --> 00:24:14,559
using rust drugs and so

00:24:11,360 --> 00:24:19,840
uh that's all i got thank you for

00:24:14,559 --> 00:24:19,840

YouTube URL: https://www.youtube.com/watch?v=HN6EUcnGN1s


