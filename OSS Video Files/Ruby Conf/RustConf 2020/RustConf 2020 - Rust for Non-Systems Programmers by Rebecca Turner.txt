Title: RustConf 2020 - Rust for Non-Systems Programmers by Rebecca Turner
Publication date: 2021-04-19
Playlist: RustConf 2020
Description: 
	Rust for Non-Systems Programmers by Rebecca Turner

Rust improves on C and C++ by providing memory safety and better concurrency primitives. But for a lot of tools and programs, dynamic languages like Python, Ruby, and Perl are already memory safe and fast enough. “Rust for Non-Systems Programmers” showcases some of the reasons I like Rust as someone who's not a systems programmer, including mutability tracking, development tooling, great documentation, a welcoming community, type-inference/algebraic datatypes, and error handling.
Captions: 
	00:00:16,720 --> 00:00:20,880
hey folks my name is rebecca turner i

00:00:18,880 --> 00:00:22,640
use she her pronouns and i'm going to be

00:00:20,880 --> 00:00:25,359
talking about rust for non-systems

00:00:22,640 --> 00:00:25,359
programmers

00:00:25,920 --> 00:00:29,199
don't worry about taking notes all the

00:00:27,519 --> 00:00:31,279
code i'm going to be showing you as well

00:00:29,199 --> 00:00:34,399
as these slides and a rough transcript

00:00:31,279 --> 00:00:34,399
are available online

00:00:39,520 --> 00:00:42,719
and i'm going to wait a little bit so

00:00:41,040 --> 00:00:45,840
people can copy down

00:00:42,719 --> 00:00:45,840
these links

00:00:51,520 --> 00:00:56,559
so i'm a non-systems programmer before

00:00:54,239 --> 00:00:58,160
learning rust i mostly wrote python and

00:00:56,559 --> 00:00:59,199
now rust is pretty much my favorite

00:00:58,160 --> 00:01:00,879
language

00:00:59,199 --> 00:01:03,199
but if you looked at the wrestling.org

00:01:00,879 --> 00:01:06,159
website before 2019 that might not make

00:01:03,199 --> 00:01:08,240
a lot of sense to you

00:01:06,159 --> 00:01:09,760
here's the wrestling.org website at the

00:01:08,240 --> 00:01:11,200
end of 2018

00:01:09,760 --> 00:01:13,520
right before they rolled out the new

00:01:11,200 --> 00:01:15,920
site the headline emphasizes systems

00:01:13,520 --> 00:01:17,520
programming speed and memory safety

00:01:15,920 --> 00:01:20,000
all things i don't directly care about

00:01:17,520 --> 00:01:20,000
that much

00:01:21,920 --> 00:01:26,320
and here's the new website today in

00:01:23,680 --> 00:01:28,080
mid-2020 now rust is about empowering

00:01:26,320 --> 00:01:30,000
everyone to build reliable and efficient

00:01:28,080 --> 00:01:32,000
software and the website focuses on

00:01:30,000 --> 00:01:33,759
reliability and productivity

00:01:32,000 --> 00:01:35,600
but a lot of the documentation is lagged

00:01:33,759 --> 00:01:37,680
behind and still assumes that new rust

00:01:35,600 --> 00:01:41,040
programmers already know c plus plus or

00:01:37,680 --> 00:01:42,799
something similar

00:01:41,040 --> 00:01:44,720
that made it really hard for me to learn

00:01:42,799 --> 00:01:45,520
rust i've never really understood memory

00:01:44,720 --> 00:01:47,360
management

00:01:45,520 --> 00:01:49,119
so a lot of the documentation was pretty

00:01:47,360 --> 00:01:51,040
inaccessible for me

00:01:49,119 --> 00:01:52,880
i want to talk about how we can use rust

00:01:51,040 --> 00:01:54,799
as non-systems programmers without

00:01:52,880 --> 00:01:58,880
getting too bogged down into the details

00:01:54,799 --> 00:01:58,880
of optimization and memory management

00:02:04,399 --> 00:02:07,600
before we start writing code let's take

00:02:06,159 --> 00:02:09,280
a quick look at some of the things rust

00:02:07,600 --> 00:02:10,720
makes strikingly easy

00:02:09,280 --> 00:02:12,000
and don't worry if i go through these

00:02:10,720 --> 00:02:14,480
quickly we'll come back to these

00:02:12,000 --> 00:02:16,080
features soon

00:02:14,480 --> 00:02:19,599
rust can do command line argument

00:02:16,080 --> 00:02:21,760
parsing generated from a type definition

00:02:19,599 --> 00:02:23,680
with automatic typo correction while

00:02:21,760 --> 00:02:24,560
generating tab completion scripts and

00:02:23,680 --> 00:02:27,599
man pages

00:02:24,560 --> 00:02:27,599
at compile time

00:02:27,840 --> 00:02:31,519
rust can give great error reports for

00:02:29,760 --> 00:02:36,000
complex errors while automatically

00:02:31,519 --> 00:02:38,160
deserializing json to a custom type and

00:02:36,000 --> 00:02:40,160
rust can output fancy test dips with a

00:02:38,160 --> 00:02:43,440
one-line import that integrates with the

00:02:40,160 --> 00:02:45,360
default test framework

00:02:43,440 --> 00:02:46,800
rest can do a whole lot more too but i

00:02:45,360 --> 00:02:49,599
don't want to just list random rest

00:02:46,800 --> 00:02:51,519
features for 30 minutes

00:02:49,599 --> 00:02:53,120
when i was learning rust a process that

00:02:51,519 --> 00:02:54,400
had three or four false starts since

00:02:53,120 --> 00:02:56,080
about 2016

00:02:54,400 --> 00:02:57,840
i kept getting halfway through writing a

00:02:56,080 --> 00:03:00,159
program before i'd get stuck on a

00:02:57,840 --> 00:03:01,760
compiler error i couldn't figure out

00:03:00,159 --> 00:03:03,840
so we're going to write a non-trivial

00:03:01,760 --> 00:03:05,360
rest program together and see how we can

00:03:03,840 --> 00:03:06,480
solve a lot of common problems in a

00:03:05,360 --> 00:03:08,319
rusty way

00:03:06,480 --> 00:03:11,599
without worrying about the finer details

00:03:08,319 --> 00:03:13,440
that i have a hard time understanding

00:03:11,599 --> 00:03:15,120
there's a lot of rest features and tools

00:03:13,440 --> 00:03:16,000
that aren't important to me as a python

00:03:15,120 --> 00:03:17,599
programmer

00:03:16,000 --> 00:03:19,440
and i'm going to pretty much skip over

00:03:17,599 --> 00:03:21,280
those entirely we're not going to

00:03:19,440 --> 00:03:22,720
optimize anything because the totally

00:03:21,280 --> 00:03:24,879
naive program we're going to write

00:03:22,720 --> 00:03:26,640
takes a tenth of a second to run and

00:03:24,879 --> 00:03:28,319
almost all that time is spent waiting on

00:03:26,640 --> 00:03:30,319
some network requests

00:03:28,319 --> 00:03:32,080
we're not going to talk about macros or

00:03:30,319 --> 00:03:34,799
a lot of the fancy type system features

00:03:32,080 --> 00:03:36,879
rust has or pointers i'm not even going

00:03:34,799 --> 00:03:39,360
to say the words heap or stack or

00:03:36,879 --> 00:03:41,519
allocate if it wouldn't matter in python

00:03:39,360 --> 00:03:43,840
or javascript or ruby it wouldn't matter

00:03:41,519 --> 00:03:43,840
here

00:03:44,000 --> 00:03:48,239
i have adhd and it varies from person to

00:03:46,560 --> 00:03:50,000
person but one area i really struggle

00:03:48,239 --> 00:03:51,440
with is working memory which is roughly

00:03:50,000 --> 00:03:52,799
how much information you can hold in

00:03:51,440 --> 00:03:54,959
your head at once

00:03:52,799 --> 00:03:57,040
and as an engineer that means that i

00:03:54,959 --> 00:03:59,120
can't hold much of the program concept

00:03:57,040 --> 00:04:00,799
in my mind while i work

00:03:59,120 --> 00:04:02,159
it's really important that i have a

00:04:00,799 --> 00:04:04,319
powerful compiler

00:04:02,159 --> 00:04:05,439
linters and tests because otherwise i

00:04:04,319 --> 00:04:07,120
have no way of knowing that the

00:04:05,439 --> 00:04:09,360
program's correct

00:04:07,120 --> 00:04:11,200
type annotations and auto completion

00:04:09,360 --> 00:04:13,040
aren't optional niceties for me

00:04:11,200 --> 00:04:14,720
it's essential that my tools tell me

00:04:13,040 --> 00:04:15,599
which operations are supported on which

00:04:14,720 --> 00:04:17,280
variables

00:04:15,599 --> 00:04:18,880
because otherwise i have to look them up

00:04:17,280 --> 00:04:21,120
nearly every time

00:04:18,880 --> 00:04:24,080
rest really shines in all these areas i

00:04:21,120 --> 00:04:25,600
work with my compiler to check my work

00:04:24,080 --> 00:04:27,440
and it helps me feel a lot more

00:04:25,600 --> 00:04:30,000
confident that my programs do what i

00:04:27,440 --> 00:04:31,680
think they do

00:04:30,000 --> 00:04:33,040
before we start looking at code i want

00:04:31,680 --> 00:04:36,639
to point out a few of the tools that

00:04:33,040 --> 00:04:36,639
make writing rust easy and fun

00:04:36,880 --> 00:04:40,720
we have restock which compiles dot

00:04:38,880 --> 00:04:42,720
comments written in markdown to web

00:04:40,720 --> 00:04:43,440
pages complete with search links and

00:04:42,720 --> 00:04:45,440
more

00:04:43,440 --> 00:04:47,759
we also have mdbook for writing longer

00:04:45,440 --> 00:04:49,600
form narrative style documentation

00:04:47,759 --> 00:04:50,960
mdbook was created to write the rest

00:04:49,600 --> 00:04:52,800
book the main source of ros

00:04:50,960 --> 00:04:54,800
documentation

00:04:52,800 --> 00:04:57,040
we have two very good language servers

00:04:54,800 --> 00:04:58,880
for auto completion definition jumping

00:04:57,040 --> 00:05:01,759
quick fixes and more

00:04:58,880 --> 00:05:05,759
rls is distributed with rust itself and

00:05:01,759 --> 00:05:08,479
rust analyzer is a community project

00:05:05,759 --> 00:05:09,440
and we also have cargo a package manager

00:05:08,479 --> 00:05:11,360
and build system

00:05:09,440 --> 00:05:13,440
integrating with the crates.io package

00:05:11,360 --> 00:05:15,120
repository that handles everything from

00:05:13,440 --> 00:05:16,960
dependency resolution to building

00:05:15,120 --> 00:05:19,680
documentation running tests and

00:05:16,960 --> 00:05:19,680
benchmarking

00:05:20,240 --> 00:05:23,440
here's the generated documentation for

00:05:21,919 --> 00:05:24,560
the rand crate which you can find at

00:05:23,440 --> 00:05:27,360
docs.rf

00:05:24,560 --> 00:05:28,479
rand when we open it up we can see the

00:05:27,360 --> 00:05:30,320
overview they wrote

00:05:28,479 --> 00:05:32,000
and we can even search the crates items

00:05:30,320 --> 00:05:33,840
with keyboard shortcuts

00:05:32,000 --> 00:05:35,520
if we click on the threadrng function we

00:05:33,840 --> 00:05:37,280
get to this definition

00:05:35,520 --> 00:05:38,639
if we click on that return type there we

00:05:37,280 --> 00:05:40,639
can check out the documentation for

00:05:38,639 --> 00:05:42,639
thread rng

00:05:40,639 --> 00:05:44,400
we see a description and if we scroll

00:05:42,639 --> 00:05:45,919
down a bit we can see the traits that

00:05:44,400 --> 00:05:47,600
rng implements and we'll come back to

00:05:45,919 --> 00:05:49,840
what a trade is soon

00:05:47,600 --> 00:05:51,600
rng core looks interesting so let's find

00:05:49,840 --> 00:05:53,680
out about that one

00:05:51,600 --> 00:05:55,120
we see a description at first and then

00:05:53,680 --> 00:05:58,880
if we scroll down we can see the

00:05:55,120 --> 00:06:01,120
required methods and their documentation

00:05:58,880 --> 00:06:02,960
having a uniform style and interface for

00:06:01,120 --> 00:06:04,960
documentation is really helpful when

00:06:02,960 --> 00:06:06,479
exploring libraries api

00:06:04,960 --> 00:06:09,199
and when jumping between multiple

00:06:06,479 --> 00:06:09,199
libraries

00:06:12,960 --> 00:06:18,240
here's a pretty simple rest program just

00:06:14,880 --> 00:06:20,319
to show off a bit of syntax

00:06:18,240 --> 00:06:21,440
the use statement imports names from

00:06:20,319 --> 00:06:23,680
libraries

00:06:21,440 --> 00:06:25,680
colon colon is used as a path separator

00:06:23,680 --> 00:06:27,440
and namespacing operator

00:06:25,680 --> 00:06:29,680
next we define a function with the fn

00:06:27,440 --> 00:06:31,440
keyword the function named main is the

00:06:29,680 --> 00:06:33,680
entry point

00:06:31,440 --> 00:06:35,919
we call the var function in the end

00:06:33,680 --> 00:06:36,880
module and assign the value it returns

00:06:35,919 --> 00:06:39,440
to user

00:06:36,880 --> 00:06:40,080
rest figures out the type for us and

00:06:39,440 --> 00:06:42,720
vare

00:06:40,080 --> 00:06:44,479
is a result or returns a result so we

00:06:42,720 --> 00:06:45,280
have to unwrap it which will crash if

00:06:44,479 --> 00:06:47,039
there's an error

00:06:45,280 --> 00:06:49,360
we'll talk about what all that means in

00:06:47,039 --> 00:06:51,120
a minute and next we have an

00:06:49,360 --> 00:06:53,280
if statement which has braces but no

00:06:51,120 --> 00:06:55,280
parentheses

00:06:53,280 --> 00:06:57,039
um note that we're comparing strings

00:06:55,280 --> 00:06:58,400
with equals equals so we have operator

00:06:57,039 --> 00:07:00,400
overloading

00:06:58,400 --> 00:07:01,919
and then we have this print line macro

00:07:00,400 --> 00:07:03,680
the exclamation mark at the end of the

00:07:01,919 --> 00:07:05,360
name means it's a macro and the string

00:07:03,680 --> 00:07:07,120
literal there is actually turned into a

00:07:05,360 --> 00:07:09,520
series of formatting instructions

00:07:07,120 --> 00:07:11,280
at compile time and the compiler checks

00:07:09,520 --> 00:07:14,319
that that we have enough arguments and

00:07:11,280 --> 00:07:14,319
that they're the right type

00:07:14,720 --> 00:07:19,360
we can run cargo build to compile the

00:07:16,880 --> 00:07:21,360
program

00:07:19,360 --> 00:07:31,840
and then we can run it and it does what

00:07:21,360 --> 00:07:31,840
we expect

00:07:32,479 --> 00:07:36,000
although if the user environment

00:07:34,240 --> 00:07:36,880
variable is empty it might be a bit

00:07:36,000 --> 00:07:39,280
confusing

00:07:36,880 --> 00:07:45,840
and if user contains invalid utf-8 it'll

00:07:39,280 --> 00:07:45,840
crash the whole program

00:07:47,759 --> 00:07:53,840
so this type that ver and ver returns

00:07:50,960 --> 00:07:55,599
is result which isn't a noun which means

00:07:53,840 --> 00:07:56,879
it's a type that can be one of a number

00:07:55,599 --> 00:07:58,879
of different things

00:07:56,879 --> 00:08:00,000
it's also generic type so we can pick

00:07:58,879 --> 00:08:02,319
any two types t

00:08:00,000 --> 00:08:03,039
and e and use a result type which can

00:08:02,319 --> 00:08:05,440
either be

00:08:03,039 --> 00:08:08,800
an okay variant containing a t value or

00:08:05,440 --> 00:08:10,240
an air variant containing an e value

00:08:08,800 --> 00:08:11,919
one way we can deal with that error is

00:08:10,240 --> 00:08:13,520
by matching on it which is a bit like an

00:08:11,919 --> 00:08:14,960
is instance check

00:08:13,520 --> 00:08:16,560
here we'll just handle an error by

00:08:14,960 --> 00:08:19,120
printing a simple message so

00:08:16,560 --> 00:08:20,479
if we have an okay value we take that

00:08:19,120 --> 00:08:23,039
and run our logic

00:08:20,479 --> 00:08:24,879
from before we have an error value we

00:08:23,039 --> 00:08:28,400
throw it away using the underscore

00:08:24,879 --> 00:08:31,840
as a place a placeholder or wildcard

00:08:28,400 --> 00:08:33,440
and just print that little message

00:08:31,840 --> 00:08:35,440
so now when we run our program within

00:08:33,440 --> 00:08:36,719
valid data we print an error message

00:08:35,440 --> 00:08:37,919
instead of crashing

00:08:36,719 --> 00:08:39,360
we'll talk about some other ways to

00:08:37,919 --> 00:08:40,880
handle errors as we go but for the

00:08:39,360 --> 00:08:42,880
definitive rundown check out jane

00:08:40,880 --> 00:08:44,320
ludspy's talk error handling isn't all

00:08:42,880 --> 00:08:46,080
about errors

00:08:44,320 --> 00:08:47,680
but this talk is about ref's value as a

00:08:46,080 --> 00:08:48,959
practical programming language which

00:08:47,680 --> 00:08:50,160
means doing a lot more than writing

00:08:48,959 --> 00:08:51,760
hello world

00:08:50,160 --> 00:08:53,120
so let's write a program in rest and

00:08:51,760 --> 00:08:55,839
explore some of the ways the language

00:08:53,120 --> 00:08:55,839
helps us out

00:08:55,920 --> 00:08:58,959
i have this rear seat printer hooked up

00:08:57,360 --> 00:08:59,680
to my computer and it's super fun to

00:08:58,959 --> 00:09:01,519
play with

00:08:59,680 --> 00:09:02,560
there's no ink so paper is incredibly

00:09:01,519 --> 00:09:04,000
cheap and they're designed for

00:09:02,560 --> 00:09:05,360
restaurants in retail so they're

00:09:04,000 --> 00:09:06,880
incredibly durable

00:09:05,360 --> 00:09:08,720
i always forget to check the weather in

00:09:06,880 --> 00:09:10,720
the morning so i want to write a program

00:09:08,720 --> 00:09:12,800
i can set to run before i wake

00:09:10,720 --> 00:09:16,560
up that tells me the weather and how

00:09:12,800 --> 00:09:16,560
it'll feel compared to the previous day

00:09:21,200 --> 00:09:25,200
weather apis come and go but right now

00:09:23,200 --> 00:09:25,600
openweather is providing decent data for

00:09:25,200 --> 00:09:28,080
free

00:09:25,600 --> 00:09:29,760
even if the default units are kelvins

00:09:28,080 --> 00:09:31,120
here's a simple call of their api in

00:09:29,760 --> 00:09:33,440
python

00:09:31,120 --> 00:09:34,240
first we load the api key from a json

00:09:33,440 --> 00:09:36,959
file

00:09:34,240 --> 00:09:40,399
then we make a request and finally we

00:09:36,959 --> 00:09:40,399
print out the response text

00:09:47,680 --> 00:09:50,800
when we run it we get a minified json

00:09:49,519 --> 00:09:55,040
blob as output

00:09:50,800 --> 00:09:55,040
so let's work on recreating this in rest

00:09:55,360 --> 00:09:59,680
here's a start at a line-by-line

00:09:56,959 --> 00:10:02,720
conversion of that program

00:09:59,680 --> 00:10:04,000
first we're using the include stir macro

00:10:02,720 --> 00:10:06,800
which actually reads a file

00:10:04,000 --> 00:10:08,480
as utf-8 at compile time we'll work on

00:10:06,800 --> 00:10:10,240
opening files in a bit but this works

00:10:08,480 --> 00:10:12,240
well enough for now

00:10:10,240 --> 00:10:14,800
next we're going to use the 3d json

00:10:12,240 --> 00:10:16,079
crate to parse that string into a json

00:10:14,800 --> 00:10:19,200
value

00:10:16,079 --> 00:10:21,040
and then we get the api key key out of

00:10:19,200 --> 00:10:22,560
the object as a string

00:10:21,040 --> 00:10:24,560
each time we assert something about the

00:10:22,560 --> 00:10:26,480
type of value in this object we need to

00:10:24,560 --> 00:10:29,040
unwrap it because we might not have

00:10:26,480 --> 00:10:31,279
value of the type we want so we need to

00:10:29,040 --> 00:10:33,120
deal with that somehow

00:10:31,279 --> 00:10:34,880
note that this isn't entirely unique to

00:10:33,120 --> 00:10:37,120
rust though our python program would

00:10:34,880 --> 00:10:39,600
also crash if api kiobj wasn't

00:10:37,120 --> 00:10:40,800
a json object or if it didn't have a key

00:10:39,600 --> 00:10:42,399
named api key

00:10:40,800 --> 00:10:44,800
or if the value of that key wasn't a

00:10:42,399 --> 00:10:46,240
string but rest makes us be explicit

00:10:44,800 --> 00:10:47,040
about all these assumptions that we're

00:10:46,240 --> 00:10:49,200
making

00:10:47,040 --> 00:10:50,640
that's not necessarily a bad thing it

00:10:49,200 --> 00:10:51,279
helps us figure out where errors could

00:10:50,640 --> 00:10:53,360
happen

00:10:51,279 --> 00:10:54,399
but it is awfully verbose and painful to

00:10:53,360 --> 00:10:57,760
write like this

00:10:54,399 --> 00:10:59,760
but we do have a better way here we're

00:10:57,760 --> 00:11:00,320
declaring a struct which is roughly a

00:10:59,760 --> 00:11:02,000
class

00:11:00,320 --> 00:11:03,680
in the sense of a blob of data with

00:11:02,000 --> 00:11:05,600
named fields and methods

00:11:03,680 --> 00:11:09,200
and then we're deriving some traits for

00:11:05,600 --> 00:11:09,200
it so what's a trait

00:11:12,880 --> 00:11:16,640
a trait is a set of method signatures

00:11:14,720 --> 00:11:18,480
that specify some interface

00:11:16,640 --> 00:11:21,120
here the from trait lets us convert from

00:11:18,480 --> 00:11:23,040
one type to another

00:11:21,120 --> 00:11:24,160
we can implement a trait for a type with

00:11:23,040 --> 00:11:25,680
an impul block

00:11:24,160 --> 00:11:28,000
note the self keyword there that

00:11:25,680 --> 00:11:30,000
indicates the impul block's type that

00:11:28,000 --> 00:11:31,600
makes refactoring a lot easier and lets

00:11:30,000 --> 00:11:33,519
us talk about things like

00:11:31,600 --> 00:11:43,839
a function that returns the same type as

00:11:33,519 --> 00:11:43,839
the value it's called on

00:11:48,720 --> 00:11:52,399
rust lets us do a lot of funky things

00:11:50,399 --> 00:11:54,160
with traits and particularly traits with

00:11:52,399 --> 00:11:56,160
generic types like these

00:11:54,160 --> 00:11:59,040
here's the into trait which is from in

00:11:56,160 --> 00:11:59,040
the other direction

00:11:59,279 --> 00:12:05,360
we can implement into u for all types t

00:12:02,480 --> 00:12:06,880
as long as u implements from of t the

00:12:05,360 --> 00:12:08,320
implementation is pretty simple if you

00:12:06,880 --> 00:12:12,639
can wrap your head around that

00:12:08,320 --> 00:12:14,399
we call the you we call use from method

00:12:12,639 --> 00:12:16,399
and that's pretty magical we only have

00:12:14,399 --> 00:12:18,639
to implement one of into

00:12:16,399 --> 00:12:21,839
or from and we get the other implement

00:12:18,639 --> 00:12:21,839
the other trait for free

00:12:22,399 --> 00:12:27,839
so if we have this implementation from

00:12:24,480 --> 00:12:30,079
string for open weather config

00:12:27,839 --> 00:12:30,959
we can use the into method on the string

00:12:30,079 --> 00:12:34,000
type to convert

00:12:30,959 --> 00:12:36,079
to an open weather config object but

00:12:34,000 --> 00:12:38,160
about that two owned call there what's

00:12:36,079 --> 00:12:39,760
the deal shouldn't a string literal

00:12:38,160 --> 00:12:42,480
already be a string without calling

00:12:39,760 --> 00:12:42,480
another method

00:12:42,800 --> 00:12:47,279
well in rust string literals get baked

00:12:45,040 --> 00:12:48,880
into the compiled binary directly

00:12:47,279 --> 00:12:50,720
because that data is always sitting at a

00:12:48,880 --> 00:12:52,240
fixed location in the library

00:12:50,720 --> 00:12:54,000
we can't change it without copying it

00:12:52,240 --> 00:12:56,160
into memory first because

00:12:54,000 --> 00:12:57,519
if we changed it there it would change

00:12:56,160 --> 00:12:58,480
it for everyone else using the string

00:12:57,519 --> 00:12:59,680
literal

00:12:58,480 --> 00:13:01,120
so if we want to have a string that

00:12:59,680 --> 00:13:02,720
belongs to us rather than one

00:13:01,120 --> 00:13:03,519
referencing some data elsewhere in the

00:13:02,720 --> 00:13:05,120
program

00:13:03,519 --> 00:13:06,800
we have to call the two owned method to

00:13:05,120 --> 00:13:08,800
convert it which creates a new string

00:13:06,800 --> 00:13:10,720
object and copies the data we need into

00:13:08,800 --> 00:13:13,040
it

00:13:10,720 --> 00:13:14,639
back to our open weather config struct

00:13:13,040 --> 00:13:16,639
we don't have to implement every trait

00:13:14,639 --> 00:13:17,360
by hand like we were doing within to and

00:13:16,639 --> 00:13:19,120
from

00:13:17,360 --> 00:13:21,040
the other option is to use a derived

00:13:19,120 --> 00:13:21,680
macro which is a function written in

00:13:21,040 --> 00:13:23,440
rust

00:13:21,680 --> 00:13:25,519
that reads the types definition as a

00:13:23,440 --> 00:13:27,279
syntax tree and automatically generates

00:13:25,519 --> 00:13:28,880
an impul block for us

00:13:27,279 --> 00:13:30,880
there's usually a few requirements for

00:13:28,880 --> 00:13:31,680
deriving traits in particular for traits

00:13:30,880 --> 00:13:34,000
like debug

00:13:31,680 --> 00:13:35,920
clone and deserialize we need all the

00:13:34,000 --> 00:13:37,839
types the struct is composed of which

00:13:35,920 --> 00:13:39,120
here is just string to implement the

00:13:37,839 --> 00:13:40,880
same trait

00:13:39,120 --> 00:13:43,040
debug lets us pretty print the structs

00:13:40,880 --> 00:13:45,120
data clone lets us deeply copy it

00:13:43,040 --> 00:13:47,519
and certi's deserialized trait lets us

00:13:45,120 --> 00:13:48,800
deserialize it from json or with other

00:13:47,519 --> 00:14:03,360
30 libraries

00:13:48,800 --> 00:14:05,199
xml yaml tamil protobufs and more

00:14:03,360 --> 00:14:06,880
here's what deserializing to a value

00:14:05,199 --> 00:14:08,800
looks like note that we don't need to

00:14:06,880 --> 00:14:09,279
explicitly construct our open weather

00:14:08,800 --> 00:14:12,000
config

00:14:09,279 --> 00:14:13,440
object that along with parsing the json

00:14:12,000 --> 00:14:15,279
matching up keys to fields and

00:14:13,440 --> 00:14:17,839
recursively constructing other

00:14:15,279 --> 00:14:20,880
realizable values is handled by certi

00:14:17,839 --> 00:14:20,880
and certi json

00:14:23,440 --> 00:14:27,680
now when we run this we get some nice

00:14:25,199 --> 00:14:30,079
pretty printed debug output by default

00:14:27,680 --> 00:14:32,160
that's not my actual api key by the way

00:14:30,079 --> 00:14:33,760
don't worry

00:14:32,160 --> 00:14:35,440
the next change i want to make is adding

00:14:33,760 --> 00:14:35,760
struct opt which generates a command

00:14:35,440 --> 00:14:37,839
line

00:14:35,760 --> 00:14:39,440
interface from a struct definition

00:14:37,839 --> 00:14:41,040
instead of declaring all our arguments

00:14:39,440 --> 00:14:42,399
as strings and pulling them out of an

00:14:41,040 --> 00:14:44,079
untyped hash map

00:14:42,399 --> 00:14:45,199
we just declare them as struct fields

00:14:44,079 --> 00:14:46,720
which means we get things like

00:14:45,199 --> 00:14:47,519
autocompletion for our command line

00:14:46,720 --> 00:14:49,440
options

00:14:47,519 --> 00:14:51,600
along with bonuses like detecting that

00:14:49,440 --> 00:14:59,839
option fields aren't mandatory and vec

00:14:51,600 --> 00:14:59,839
fields can have multiple values

00:15:00,000 --> 00:15:03,440
we get a lot of perks from streptop

00:15:01,839 --> 00:15:05,519
including this great generated help

00:15:03,440 --> 00:15:07,600
message

00:15:05,519 --> 00:15:10,720
and we even help we even get help with

00:15:07,600 --> 00:15:10,720
typos by default

00:15:11,279 --> 00:15:14,480
the next thing i want to do is add some

00:15:12,880 --> 00:15:16,320
error reporting so we don't have to

00:15:14,480 --> 00:15:17,600
unwrap everything and cause panics when

00:15:16,320 --> 00:15:20,240
something fails

00:15:17,600 --> 00:15:22,000
the error crate by jane ludsby gives us

00:15:20,240 --> 00:15:23,279
the beautifully formatted error messages

00:15:22,000 --> 00:15:23,920
i showed off at the beginning of the

00:15:23,279 --> 00:15:25,600
talk

00:15:23,920 --> 00:15:27,600
and has a lot of other functionality we

00:15:25,600 --> 00:15:29,199
won't explore here

00:15:27,600 --> 00:15:30,880
now we can handle errors with the

00:15:29,199 --> 00:15:34,880
question mark operator which is a pretty

00:15:30,880 --> 00:15:36,639
simple but important bit of syntax sugar

00:15:34,880 --> 00:15:38,320
the question marks are transformed into

00:15:36,639 --> 00:15:40,079
roughly these match statements

00:15:38,320 --> 00:15:42,320
if we have an okay value we take that

00:15:40,079 --> 00:15:44,000
value and use it otherwise we return the

00:15:42,320 --> 00:15:46,079
error value from the whole function we

00:15:44,000 --> 00:15:47,279
just bubble up the error to the caller

00:15:46,079 --> 00:15:49,199
it's a little bit like throwing an

00:15:47,279 --> 00:15:51,040
exception but we don't quit an arbitrary

00:15:49,199 --> 00:15:51,600
series of functions we only go up one

00:15:51,040 --> 00:15:52,959
layer

00:15:51,600 --> 00:15:55,839
and the type system doesn't let us

00:15:52,959 --> 00:15:55,839
ignore it

00:16:05,680 --> 00:16:09,120
using the question mark operator again

00:16:07,519 --> 00:16:11,519
we're going to use the wraparound

00:16:09,120 --> 00:16:14,079
methods from errors wrapper trait to

00:16:11,519 --> 00:16:15,600
more accurately describe what went wrong

00:16:14,079 --> 00:16:17,199
we just write a bit about what we were

00:16:15,600 --> 00:16:19,120
doing that might have caused an error

00:16:17,199 --> 00:16:21,199
and then that string will get displayed

00:16:19,120 --> 00:16:22,959
if the error report is printed

00:16:21,199 --> 00:16:24,320
it's a pretty simple step provided you

00:16:22,959 --> 00:16:27,680
do it from the start and it makes

00:16:24,320 --> 00:16:27,680
debugging a lot easier

00:16:35,839 --> 00:16:39,519
here we can try to use a non-existent

00:16:37,680 --> 00:16:41,600
file or an invalid one

00:16:39,519 --> 00:16:43,040
as our config and we can see the error

00:16:41,600 --> 00:16:44,720
messages we get

00:16:43,040 --> 00:16:46,000
these are pretty simple on their own but

00:16:44,720 --> 00:16:47,680
they're especially useful when we have a

00:16:46,000 --> 00:16:49,360
bunch of layers of error contacts to

00:16:47,680 --> 00:16:51,040
figure out what we did wrong

00:16:49,360 --> 00:16:52,880
and unlike exceptions in a lot of

00:16:51,040 --> 00:16:56,639
languages we don't just get an enormous

00:16:52,880 --> 00:16:56,639
unreadable stack trace by default

00:16:56,800 --> 00:17:00,000
now we're going to use the request

00:16:58,240 --> 00:17:01,839
library to make a simple call to the

00:17:00,000 --> 00:17:04,319
open weather api

00:17:01,839 --> 00:17:05,600
we create an http client object called

00:17:04,319 --> 00:17:08,160
the get method with the

00:17:05,600 --> 00:17:18,240
endpoint url add some query parameters

00:17:08,160 --> 00:17:19,600
and send the request off

00:17:18,240 --> 00:17:21,439
we can see when we pretty print the

00:17:19,600 --> 00:17:23,919
response object we get all the fields we

00:17:21,439 --> 00:17:26,400
might expect headers a status code and

00:17:23,919 --> 00:17:26,400
so on

00:17:26,880 --> 00:17:29,919
and we can also print the response text

00:17:28,880 --> 00:17:32,240
which is this

00:17:29,919 --> 00:17:34,400
big minified json blob we're going to

00:17:32,240 --> 00:17:35,760
deserialize that too but first let's

00:17:34,400 --> 00:17:38,559
clean up our interface to the open

00:17:35,760 --> 00:17:38,559
weather api

00:17:44,720 --> 00:17:47,840
so let's unify our config file with the

00:17:46,799 --> 00:17:49,840
api client

00:17:47,840 --> 00:17:51,840
instead of passing an api key into every

00:17:49,840 --> 00:17:53,919
function call we can keep it in the same

00:17:51,840 --> 00:17:55,520
struct that holds the request client

00:17:53,919 --> 00:17:57,360
and because the client has a default

00:17:55,520 --> 00:17:59,200
value we can tell certi to use that

00:17:57,360 --> 00:18:01,679
instead of expecting it in our config

00:17:59,200 --> 00:18:04,160
file

00:18:01,679 --> 00:18:06,160
now we can just read our config config

00:18:04,160 --> 00:18:06,960
object from the same json file we were

00:18:06,160 --> 00:18:10,080
using before

00:18:06,960 --> 00:18:12,080
without even a constructor method

00:18:10,080 --> 00:18:13,520
now to make our api a bit cleaner let's

00:18:12,080 --> 00:18:15,200
start implementing methods

00:18:13,520 --> 00:18:16,799
this gives us something that looks a lot

00:18:15,200 --> 00:18:18,000
like the classes we may have used in

00:18:16,799 --> 00:18:19,280
other languages

00:18:18,000 --> 00:18:21,039
and although rust doesn't have

00:18:19,280 --> 00:18:22,720
inheritance or subtyping generic

00:18:21,039 --> 00:18:23,760
functions and crates can get us pretty

00:18:22,720 --> 00:18:25,679
close

00:18:23,760 --> 00:18:26,799
an impul block lets us put methods on

00:18:25,679 --> 00:18:28,400
types

00:18:26,799 --> 00:18:30,880
like python rust doesn't have an

00:18:28,400 --> 00:18:31,440
implicit this object you can reference

00:18:30,880 --> 00:18:34,960
you need to

00:18:31,440 --> 00:18:36,720
write it explicitly itself

00:18:34,960 --> 00:18:38,799
we also have angle brackets after the

00:18:36,720 --> 00:18:41,039
function to indicate that the function

00:18:38,799 --> 00:18:42,799
is generic

00:18:41,039 --> 00:18:44,960
here we have one generic parameter named

00:18:42,799 --> 00:18:46,640
response and the colon indicates a trait

00:18:44,960 --> 00:18:48,400
bound which means that response needs to

00:18:46,640 --> 00:18:50,880
be a type with an implementation of d

00:18:48,400 --> 00:18:53,039
serialize owned which is exactly what

00:18:50,880 --> 00:18:54,400
derived d serialize gives us

00:18:53,039 --> 00:18:56,160
essentially we've copied a type

00:18:54,400 --> 00:18:57,760
parameter from the 30.json

00:18:56,160 --> 00:19:01,679
from reader functions so that we can

00:18:57,760 --> 00:19:01,679
deserialize to any type we define

00:19:01,919 --> 00:19:05,520
we can define structs for the api

00:19:03,600 --> 00:19:10,000
responses these are pretty much copied

00:19:05,520 --> 00:19:11,600
from the open weather api docs

00:19:10,000 --> 00:19:15,120
and then we can define a helper method

00:19:11,600 --> 00:19:15,120
to make that request directly

00:19:18,400 --> 00:19:22,080
note that we don't need to annotate the

00:19:19,919 --> 00:19:24,240
generic types for the self.getcall

00:19:22,080 --> 00:19:25,600
although we can if we want the compiler

00:19:24,240 --> 00:19:27,120
is smart enough to figure out what the

00:19:25,600 --> 00:19:30,720
type parameter needs to be from the

00:19:27,120 --> 00:19:33,440
return type of self.get on its own

00:19:30,720 --> 00:19:35,440
and then after we can use the new method

00:19:33,440 --> 00:19:35,840
in our main function to get the forecast

00:19:35,440 --> 00:19:39,360
data

00:19:35,840 --> 00:19:41,280
as a richly typed struct

00:19:39,360 --> 00:19:42,960
one thing i want from my forecast is to

00:19:41,280 --> 00:19:44,559
tell me if today is going to be warmer

00:19:42,960 --> 00:19:46,320
or colder than yesterday

00:19:44,559 --> 00:19:47,679
so i'll create a temp difference in them

00:19:46,320 --> 00:19:50,840
and then a helper method to get the

00:19:47,679 --> 00:19:53,200
appropriate temp difference for two

00:19:50,840 --> 00:19:54,960
flips

00:19:53,200 --> 00:19:56,640
here's that constructor function which

00:19:54,960 --> 00:19:58,080
takes two floats calculates their

00:19:56,640 --> 00:20:00,000
difference and matches them to the

00:19:58,080 --> 00:20:01,760
correct temp difference variant

00:20:00,000 --> 00:20:03,600
we're also adding conditional statements

00:20:01,760 --> 00:20:05,440
to the match patterns which makes it

00:20:03,600 --> 00:20:07,200
help which helps make it a bit clearer

00:20:05,440 --> 00:20:10,000
that we're determining which range the

00:20:07,200 --> 00:20:10,000
delta is in

00:20:10,799 --> 00:20:14,640
i'm really bad at arithmetic stuff so i

00:20:12,880 --> 00:20:16,320
want to write a few tests to make sure i

00:20:14,640 --> 00:20:17,679
got the subtraction order and everything

00:20:16,320 --> 00:20:20,799
right

00:20:17,679 --> 00:20:22,559
first we have this config test attribute

00:20:20,799 --> 00:20:24,159
which means the entire test module is

00:20:22,559 --> 00:20:25,039
conditionally compiled so our tests

00:20:24,159 --> 00:20:28,000
don't get

00:20:25,039 --> 00:20:29,760
lumped into our other builds we have to

00:20:28,000 --> 00:20:31,600
import the functions and values from the

00:20:29,760 --> 00:20:32,159
parent module that is the rest of the

00:20:31,600 --> 00:20:35,200
file

00:20:32,159 --> 00:20:36,480
explicitly and then a test is just a

00:20:35,200 --> 00:20:39,360
function annotated

00:20:36,480 --> 00:20:40,880
with the test attribute and finally we

00:20:39,360 --> 00:20:43,760
can write asserts with the assert and

00:20:40,880 --> 00:20:45,280
assertiq macros

00:20:43,760 --> 00:20:47,039
we can run our tests to make sure that

00:20:45,280 --> 00:20:48,720
we've written everything correctly

00:20:47,039 --> 00:20:50,320
and another little thing i like about

00:20:48,720 --> 00:20:52,159
rust the type system

00:20:50,320 --> 00:20:54,080
lets me describe and check a lot of my

00:20:52,159 --> 00:20:56,159
code before it compiles correctly

00:20:54,080 --> 00:20:58,240
so i end up writing tests that crash and

00:20:56,159 --> 00:20:59,520
fail immediately a lot less often than i

00:20:58,240 --> 00:21:03,440
do in other languages

00:20:59,520 --> 00:21:05,120
which is a big boost to my self-esteem

00:21:03,440 --> 00:21:06,400
i also want to be able to state various

00:21:05,120 --> 00:21:07,280
things about a collection of

00:21:06,400 --> 00:21:09,039
temperatures

00:21:07,280 --> 00:21:10,720
like their range and their average so

00:21:09,039 --> 00:21:12,000
i'll have a stat struct that'll handle

00:21:10,720 --> 00:21:14,640
that computation

00:21:12,000 --> 00:21:17,840
storing the minimum maximum average and

00:21:14,640 --> 00:21:17,840
number of values

00:21:18,000 --> 00:21:21,760
let's implement the default trait for

00:21:19,679 --> 00:21:23,520
stats which gives us a way to construct

00:21:21,760 --> 00:21:25,760
a default value for a type

00:21:23,520 --> 00:21:27,520
it's like go's concept of a zero value

00:21:25,760 --> 00:21:28,720
but rest doesn't require that every type

00:21:27,520 --> 00:21:30,799
implement default

00:21:28,720 --> 00:21:32,799
because that's not always meaningful for

00:21:30,799 --> 00:21:34,720
example types like file handles don't

00:21:32,799 --> 00:21:36,720
have a reasonable default

00:21:34,720 --> 00:21:38,559
we're picking infinity for the starting

00:21:36,720 --> 00:21:39,679
minimum value because every float is

00:21:38,559 --> 00:21:41,679
less than infinity

00:21:39,679 --> 00:21:43,520
and negative infinity for max from the

00:21:41,679 --> 00:21:46,400
same reason

00:21:43,520 --> 00:21:48,000
note that we have associated constants

00:21:46,400 --> 00:21:50,720
for even our primitive types

00:21:48,000 --> 00:21:52,240
in rust primitive types are treated just

00:21:50,720 --> 00:21:55,360
like any other type

00:21:52,240 --> 00:21:58,799
um as opposed with like

00:21:55,360 --> 00:22:00,480
java where we have to treat reference

00:21:58,799 --> 00:22:03,039
types and primitive types really

00:22:00,480 --> 00:22:03,039
differently

00:22:03,360 --> 00:22:07,120
now we can construct a stats object from

00:22:05,440 --> 00:22:09,039
an iterator of floats

00:22:07,120 --> 00:22:11,200
we can start by initializing a mutable

00:22:09,039 --> 00:22:12,000
return value and a sum of the iterators

00:22:11,200 --> 00:22:13,600
elements

00:22:12,000 --> 00:22:15,600
they need to be mutable so that we can

00:22:13,600 --> 00:22:18,960
change their properties and values as we

00:22:15,600 --> 00:22:18,960
go on through this computation

00:22:21,840 --> 00:22:25,840
next we take each value in the iterator

00:22:23,760 --> 00:22:28,000
and update the return values minimum and

00:22:25,840 --> 00:22:29,919
maximum values if applicable

00:22:28,000 --> 00:22:32,320
as well as the element count and running

00:22:29,919 --> 00:22:32,320
total

00:22:36,960 --> 00:22:41,840
and finally we compute the average value

00:22:39,200 --> 00:22:41,840
and return

00:22:42,960 --> 00:22:46,880
then we can gather the temperatures for

00:22:44,720 --> 00:22:48,320
yesterday into a stats object

00:22:46,880 --> 00:22:50,880
note that because we're using lazy

00:22:48,320 --> 00:22:52,400
iterators it mapping each data point to

00:22:50,880 --> 00:22:54,480
the temperature it felt like doesn't

00:22:52,400 --> 00:22:56,320
require writing a whole new array

00:22:54,480 --> 00:22:58,559
we just generate the data as we go and

00:22:56,320 --> 00:22:59,840
there's no storage overhead

00:22:58,559 --> 00:23:01,360
we can do the same thing with our

00:22:59,840 --> 00:23:04,559
forecast making sure to limit the

00:23:01,360 --> 00:23:06,159
forecast to 24 hourly data points

00:23:04,559 --> 00:23:09,840
and then we can get a temperature

00:23:06,159 --> 00:23:09,840
difference between the two days

00:23:15,600 --> 00:23:18,640
to finish up let's print out the data

00:23:17,200 --> 00:23:20,799
we've gathered

00:23:18,640 --> 00:23:22,000
first i want to print a smiley face for

00:23:20,799 --> 00:23:23,520
good weather so i'll check

00:23:22,000 --> 00:23:25,679
if the average temperature today is

00:23:23,520 --> 00:23:27,520
between 60 and 80 degrees

00:23:25,679 --> 00:23:29,360
then we'll print the first line

00:23:27,520 --> 00:23:32,559
truncating today's average temperature

00:23:29,360 --> 00:23:32,559
to two decimal places

00:23:32,799 --> 00:23:35,919
and then we're going to print the rest

00:23:34,080 --> 00:23:36,320
of it there's a bunch to break down here

00:23:35,919 --> 00:23:39,600
so

00:23:36,320 --> 00:23:41,279
let's break it down first because print

00:23:39,600 --> 00:23:43,120
line is a macro we can do weird things

00:23:41,279 --> 00:23:45,039
with the syntax like this keyword

00:23:43,120 --> 00:23:47,440
argument syntax that's only used for the

00:23:45,039 --> 00:23:49,840
printing and formatting macros

00:23:47,440 --> 00:23:52,240
next we have a match statement rests if

00:23:49,840 --> 00:23:55,840
else and match statements return a value

00:23:52,240 --> 00:23:58,640
so we can use them in line like this for

00:23:55,840 --> 00:24:00,400
argument values and then we're going to

00:23:58,640 --> 00:24:00,960
finish with a smiley face if today is

00:24:00,400 --> 00:24:03,279
going to be

00:24:00,960 --> 00:24:04,400
warm and nice weather or a period

00:24:03,279 --> 00:24:06,320
otherwise

00:24:04,400 --> 00:24:09,760
and after printing all that information

00:24:06,320 --> 00:24:09,760
out our program is done

00:24:14,640 --> 00:24:18,000
so building and running it we can see

00:24:16,080 --> 00:24:20,000
what the final output looks like after i

00:24:18,000 --> 00:24:22,320
fixed several issues with smithing with

00:24:20,000 --> 00:24:24,080
missing or superfluous white space

00:24:22,320 --> 00:24:26,400
so now all we have left to do is print

00:24:24,080 --> 00:24:26,400
it out

00:24:26,640 --> 00:24:31,200
we pipe our program's output to lp to

00:24:29,200 --> 00:24:34,720
print it

00:24:31,200 --> 00:24:34,720
and here we go

00:24:45,360 --> 00:24:49,440
and there's the same receipt a little

00:24:46,880 --> 00:24:49,440
bit bigger

00:24:52,000 --> 00:24:56,400
and before i go let me leave you with

00:24:54,640 --> 00:24:58,000
one last piece of advice

00:24:56,400 --> 00:24:59,679
if you're writing a rest program and

00:24:58,000 --> 00:25:01,520
you're trying to work with references

00:24:59,679 --> 00:25:03,679
and it's just not working clone your

00:25:01,520 --> 00:25:05,440
data cloning can fix a lot of annoying

00:25:03,679 --> 00:25:06,960
problems and it's rarely a performance

00:25:05,440 --> 00:25:08,159
issue when writing scripts or command

00:25:06,960 --> 00:25:09,919
line interfaces

00:25:08,159 --> 00:25:11,360
particularly when compared with dynamic

00:25:09,919 --> 00:25:13,200
languages but

00:25:11,360 --> 00:25:14,960
if you end up in those circumstances you

00:25:13,200 --> 00:25:15,760
can always ask another rest programmer

00:25:14,960 --> 00:25:17,200
for help

00:25:15,760 --> 00:25:18,720
our community is full of kind and

00:25:17,200 --> 00:25:20,320
helpful people willing to share a few

00:25:18,720 --> 00:25:21,840
minutes of their time to help fix areas

00:25:20,320 --> 00:25:23,360
you don't understand

00:25:21,840 --> 00:25:24,880
i certainly couldn't have learned rest

00:25:23,360 --> 00:25:26,799
on my own and as long as you're

00:25:24,880 --> 00:25:29,520
respectful of your peers we're all glad

00:25:26,799 --> 00:25:31,919
to help

00:25:29,520 --> 00:25:33,679
everything i talked about is just a tiny

00:25:31,919 --> 00:25:36,159
portion of what you can do with rest

00:25:33,679 --> 00:25:38,000
and what rest can do for you there's so

00:25:36,159 --> 00:25:39,919
many features and tools i wanted to talk

00:25:38,000 --> 00:25:41,760
about that i didn't have time for

00:25:39,919 --> 00:25:43,840
things like adding methods to foreign

00:25:41,760 --> 00:25:47,360
types type safe numbers

00:25:43,840 --> 00:25:49,120
unit conversions and more

00:25:47,360 --> 00:25:51,039
thanks so much for listening and i hope

00:25:49,120 --> 00:25:52,960
you do some amazing things with rest

00:25:51,039 --> 00:25:55,200
i'm rebecca turner and this has been

00:25:52,960 --> 00:25:57,840
rest for non-systems programmers

00:25:55,200 --> 00:25:57,840

YouTube URL: https://www.youtube.com/watch?v=2kjTKjy-Gho


