Title: RustConf 2020 - Bending the Curve: A Personal Tutor at Your Fingertips by Esteban Kuber
Publication date: 2021-04-19
Playlist: RustConf 2020
Description: 
	Bending the Curve: A Personal Tutor at Your Fingertips by Esteban Kuber

Rust is a language known for speed and security kept behind a hard learning curve, caused by one of its unyielding goals of being a flexible systems language. By taking teachings from other domains and understanding the design constraints of the language semantics are not the entirety of the UX of a compiler, it manages to also empower everyone to build reliable and efficient software without compromises. Lets have a conversation with rustc.
Captions: 
	00:00:16,240 --> 00:00:19,119
hi

00:00:16,960 --> 00:00:20,000
i'm stephen cuber a software engineer at

00:00:19,119 --> 00:00:22,640
premier

00:00:20,000 --> 00:00:24,240
and a member of the ras compiler team i

00:00:22,640 --> 00:00:24,960
will be talking about what rust can do

00:00:24,240 --> 00:00:27,359
to improve

00:00:24,960 --> 00:00:28,960
its learnability beyond changing the

00:00:27,359 --> 00:00:30,880
language itself

00:00:28,960 --> 00:00:32,000
but first i want to address the name of

00:00:30,880 --> 00:00:33,840
the talk

00:00:32,000 --> 00:00:35,840
i chose it late last year before our

00:00:33,840 --> 00:00:36,480
current situation and because i'm a bit

00:00:35,840 --> 00:00:38,000
slow

00:00:36,480 --> 00:00:40,399
i didn't realize how topical it has

00:00:38,000 --> 00:00:43,440
become until after it has been accepted

00:00:40,399 --> 00:00:45,280
and published it will become clear

00:00:43,440 --> 00:00:46,719
why i chose it originally later in the

00:00:45,280 --> 00:00:49,039
talk

00:00:46,719 --> 00:00:50,879
secondly while i was expanding the

00:00:49,039 --> 00:00:52,640
outline of this talk into draft

00:00:50,879 --> 00:00:55,039
i realized that the topics i was talking

00:00:52,640 --> 00:00:56,399
about were way more general than just

00:00:55,039 --> 00:00:58,480
rust

00:00:56,399 --> 00:01:00,239
because of these two things if i were to

00:00:58,480 --> 00:01:01,440
change the title of this talk it would

00:01:00,239 --> 00:01:02,559
be closer to

00:01:01,440 --> 00:01:05,360
so you want to make a programming

00:01:02,559 --> 00:01:07,439
language that people use

00:01:05,360 --> 00:01:09,920
i also want to point out that this talk

00:01:07,439 --> 00:01:13,200
will address not the how rust does

00:01:09,920 --> 00:01:15,600
some things but instead what and why

00:01:13,200 --> 00:01:17,119
and finally i want to acknowledge that

00:01:15,600 --> 00:01:18,880
i'm not a language designer

00:01:17,119 --> 00:01:20,560
and i'm not speaking in any official

00:01:18,880 --> 00:01:22,159
capacity as a member of the compiler

00:01:20,560 --> 00:01:25,040
team

00:01:22,159 --> 00:01:26,960
with that out of the way let's talk

00:01:25,040 --> 00:01:28,880
about migration

00:01:26,960 --> 00:01:30,560
an experience that a lot of you may have

00:01:28,880 --> 00:01:33,759
had is moving to a new city

00:01:30,560 --> 00:01:35,600
a new state or a country when going

00:01:33,759 --> 00:01:38,400
through something like that you have to

00:01:35,600 --> 00:01:40,799
really learn how and where to do things

00:01:38,400 --> 00:01:43,759
that you were already used to doing

00:01:40,799 --> 00:01:46,159
you will rely on one of broadly speaking

00:01:43,759 --> 00:01:49,119
three tools and strategies

00:01:46,159 --> 00:01:51,520
first you will have access to a map

00:01:49,119 --> 00:01:53,119
which is a simplified

00:01:51,520 --> 00:01:55,680
graphical representation of a physical

00:01:53,119 --> 00:01:57,920
space it lets you get your bearings

00:01:55,680 --> 00:02:00,000
find where important places are and help

00:01:57,920 --> 00:02:01,439
you get there

00:02:00,000 --> 00:02:03,920
with it you can know that the

00:02:01,439 --> 00:02:04,719
firefighter station is 450 meters away

00:02:03,920 --> 00:02:06,960
from your house

00:02:04,719 --> 00:02:08,399
as the crow flies but it won't tell you

00:02:06,960 --> 00:02:08,959
that the sidewalk in front of it is

00:02:08,399 --> 00:02:10,399
broken

00:02:08,959 --> 00:02:12,000
so you have to watch your step around

00:02:10,399 --> 00:02:14,560
there

00:02:12,000 --> 00:02:16,239
second you will also explore either

00:02:14,560 --> 00:02:18,560
intentionally or not

00:02:16,239 --> 00:02:20,840
as you go about your day and slowly

00:02:18,560 --> 00:02:23,680
create and expand a mental map of the

00:02:20,840 --> 00:02:25,599
area you may come across a pizza place

00:02:23,680 --> 00:02:27,200
and think to yourself it looks

00:02:25,599 --> 00:02:29,840
reasonably priced

00:02:27,200 --> 00:02:30,959
i need to check it out it's two blocks

00:02:29,840 --> 00:02:34,239
down the street

00:02:30,959 --> 00:02:37,040
next to the red house and finally

00:02:34,239 --> 00:02:37,680
you may check out a travel guide or talk

00:02:37,040 --> 00:02:40,560
to a neighbor

00:02:37,680 --> 00:02:42,879
or friend that already knows the city

00:02:40,560 --> 00:02:44,560
they may let you know about things that

00:02:42,879 --> 00:02:46,319
would otherwise take you a long time to

00:02:44,560 --> 00:02:48,480
find out about

00:02:46,319 --> 00:02:49,840
like telling you if you go three blocks

00:02:48,480 --> 00:02:51,120
the other way there is a pizza place

00:02:49,840 --> 00:02:53,680
that is more expensive

00:02:51,120 --> 00:02:55,200
but it's the best pizza in town or they

00:02:53,680 --> 00:02:56,720
will let you know about things in

00:02:55,200 --> 00:02:59,360
advance that would be annoying

00:02:56,720 --> 00:03:00,159
or inconvenient to find out yourself

00:02:59,360 --> 00:03:02,000
like

00:03:00,159 --> 00:03:03,440
in order to take the bus you need to

00:03:02,000 --> 00:03:06,560
already have a travel card

00:03:03,440 --> 00:03:07,280
or you need the exact change what they

00:03:06,560 --> 00:03:09,360
are doing

00:03:07,280 --> 00:03:11,040
is using their lived experience

00:03:09,360 --> 00:03:13,200
extrapolate what they know about you

00:03:11,040 --> 00:03:14,959
and your lived experience and cut to the

00:03:13,200 --> 00:03:16,720
chase to discuss the areas

00:03:14,959 --> 00:03:19,360
that are different from what you may be

00:03:16,720 --> 00:03:22,879
used to instead of starting from scratch

00:03:19,360 --> 00:03:24,400
and explaining what the street is

00:03:22,879 --> 00:03:27,840
the experience of learning a programming

00:03:24,400 --> 00:03:30,000
language can be very similar

00:03:27,840 --> 00:03:32,159
you will have a map of the land in the

00:03:30,000 --> 00:03:34,080
shape of the reference documentation

00:03:32,159 --> 00:03:36,640
which will be detailed in the languages

00:03:34,080 --> 00:03:38,080
and libraries arcane behaviors

00:03:36,640 --> 00:03:40,400
some people like to go through the

00:03:38,080 --> 00:03:42,640
documentation from cover to cover

00:03:40,400 --> 00:03:44,000
and only then once they have an idea of

00:03:42,640 --> 00:03:45,920
what's available

00:03:44,000 --> 00:03:48,159
will they venture to write their first

00:03:45,920 --> 00:03:51,120
line of code

00:03:48,159 --> 00:03:52,480
other people are more hands-on

00:03:51,120 --> 00:03:54,959
particularly people

00:03:52,480 --> 00:03:57,280
that have read that already know one or

00:03:54,959 --> 00:03:59,680
more other languages are ready

00:03:57,280 --> 00:04:02,319
they may need a brief introduction and

00:03:59,680 --> 00:04:04,159
then start trying things out

00:04:02,319 --> 00:04:06,560
through this trial and error they will

00:04:04,159 --> 00:04:07,840
be building a mental map of the language

00:04:06,560 --> 00:04:10,319
identifying where their previous

00:04:07,840 --> 00:04:12,239
knowledge applies and where it diverges

00:04:10,319 --> 00:04:13,760
in the new language

00:04:12,239 --> 00:04:15,519
when moving from a language to another

00:04:13,760 --> 00:04:17,519
that follows the same particular

00:04:15,519 --> 00:04:20,560
programming paradigm

00:04:17,519 --> 00:04:22,960
this process can be quite smooth when

00:04:20,560 --> 00:04:25,360
going from one paradigm to another

00:04:22,960 --> 00:04:27,520
the process can be more arduous for

00:04:25,360 --> 00:04:28,720
example somebody familiar only with a

00:04:27,520 --> 00:04:30,560
skull

00:04:28,720 --> 00:04:32,720
moving to shava would require a slight

00:04:30,560 --> 00:04:34,320
change in their mental model

00:04:32,720 --> 00:04:36,560
same for someone moving from shabbat to

00:04:34,320 --> 00:04:40,000
haskell

00:04:36,560 --> 00:04:41,440
finally some people will seek out help

00:04:40,000 --> 00:04:43,919
this can be in the shape of a book

00:04:41,440 --> 00:04:46,960
targeted at people learning the language

00:04:43,919 --> 00:04:49,840
in some cases aimed at people

00:04:46,960 --> 00:04:51,040
from very specific backgrounds or

00:04:49,840 --> 00:04:52,080
through the reliance on online

00:04:51,040 --> 00:04:54,720
communities

00:04:52,080 --> 00:04:56,479
or even hiring a teacher to teach you

00:04:54,720 --> 00:04:58,960
the language

00:04:56,479 --> 00:05:00,320
when doing this regardless of medium the

00:04:58,960 --> 00:05:01,120
people on the other side will try to

00:05:00,320 --> 00:05:02,800
identify

00:05:01,120 --> 00:05:04,160
what your current level of familiarity

00:05:02,800 --> 00:05:06,639
with the subject is

00:05:04,160 --> 00:05:08,080
what you already know in order to

00:05:06,639 --> 00:05:10,960
minimize the time needed

00:05:08,080 --> 00:05:11,759
to get you up to speed and productive

00:05:10,960 --> 00:05:14,160
this includes

00:05:11,759 --> 00:05:15,120
succinctly pointing out things that will

00:05:14,160 --> 00:05:17,120
work out the same

00:05:15,120 --> 00:05:18,960
to what you're already used to and

00:05:17,120 --> 00:05:20,400
particularly pointing out where that is

00:05:18,960 --> 00:05:21,759
not the case

00:05:20,400 --> 00:05:23,600
i will be referring to this whole

00:05:21,759 --> 00:05:24,160
category of learning approach under the

00:05:23,600 --> 00:05:27,600
word

00:05:24,160 --> 00:05:28,479
tutor when designing a programming

00:05:27,600 --> 00:05:30,639
language

00:05:28,479 --> 00:05:31,680
you will have a list of priorities or

00:05:30,639 --> 00:05:34,160
objectives

00:05:31,680 --> 00:05:35,440
you want to accomplish you can't

00:05:34,160 --> 00:05:37,919
prioritize all things

00:05:35,440 --> 00:05:39,919
equally which means that some will have

00:05:37,919 --> 00:05:42,560
a higher weight than others

00:05:39,919 --> 00:05:44,240
and some will even restrict or preclude

00:05:42,560 --> 00:05:46,160
others

00:05:44,240 --> 00:05:48,080
you may want to prioritize runtime and

00:05:46,160 --> 00:05:50,400
design flexibility

00:05:48,080 --> 00:05:51,120
but this priority will almost assuredly

00:05:50,400 --> 00:05:53,840
restrict

00:05:51,120 --> 00:05:55,520
how performance your language could be

00:05:53,840 --> 00:05:56,880
you could decide to prioritize final

00:05:55,520 --> 00:05:58,880
execution speed

00:05:56,880 --> 00:06:00,240
but that may require you to sacrifice

00:05:58,880 --> 00:06:02,160
compilation speed or restrict how

00:06:00,240 --> 00:06:03,759
dynamic your software can easily be made

00:06:02,160 --> 00:06:05,280
at runtime

00:06:03,759 --> 00:06:07,199
a different priority may become

00:06:05,280 --> 00:06:08,560
compilation speed but this will

00:06:07,199 --> 00:06:09,680
certainly affect what features the

00:06:08,560 --> 00:06:11,360
language can have

00:06:09,680 --> 00:06:12,720
in order to avoid potentially

00:06:11,360 --> 00:06:14,720
exponential evaluation

00:06:12,720 --> 00:06:16,800
in the language or how ergonomic the

00:06:14,720 --> 00:06:18,800
language can be

00:06:16,800 --> 00:06:20,400
an example from rust could be that the

00:06:18,800 --> 00:06:22,720
smallest compilation unit

00:06:20,400 --> 00:06:24,960
is the crate and not the file like in

00:06:22,720 --> 00:06:27,120
other languages

00:06:24,960 --> 00:06:28,800
this permits the existence of circular

00:06:27,120 --> 00:06:31,600
imports in the language

00:06:28,800 --> 00:06:32,639
for example splitting an idt definition

00:06:31,600 --> 00:06:34,880
and its implementation

00:06:32,639 --> 00:06:37,360
throughout multiple files as long as

00:06:34,880 --> 00:06:39,039
they all belong to the same crate

00:06:37,360 --> 00:06:41,360
this is good for the ergonomics of the

00:06:39,039 --> 00:06:42,319
language to help you keep your code

00:06:41,360 --> 00:06:45,120
clean

00:06:42,319 --> 00:06:45,759
but it means that currently rossi cannot

00:06:45,120 --> 00:06:48,080
compile

00:06:45,759 --> 00:06:49,520
multiple files from the same crate in

00:06:48,080 --> 00:06:51,599
parallel

00:06:49,520 --> 00:06:52,720
this is not as a strong technical

00:06:51,599 --> 00:06:54,400
restriction mind you

00:06:52,720 --> 00:06:55,919
there are changes that could be made to

00:06:54,400 --> 00:06:58,400
make this possible

00:06:55,919 --> 00:06:59,840
but they are hard to implement if the

00:06:58,400 --> 00:07:01,440
language design had gone with a more

00:06:59,840 --> 00:07:03,440
restrictive module system

00:07:01,440 --> 00:07:04,560
it would be less ergonomic but it would

00:07:03,440 --> 00:07:06,319
have allowed to simplify the

00:07:04,560 --> 00:07:07,759
implementation of the compiler

00:07:06,319 --> 00:07:11,360
and made it easier to make this

00:07:07,759 --> 00:07:13,360
particular part of it faster

00:07:11,360 --> 00:07:15,039
one reason i'm very happy to see the

00:07:13,360 --> 00:07:16,560
explosion of new languages in the past

00:07:15,039 --> 00:07:18,560
couple of decades

00:07:16,560 --> 00:07:19,599
is that there is no wrong answer on what

00:07:18,560 --> 00:07:22,639
the priorities

00:07:19,599 --> 00:07:24,479
should be and even if there were

00:07:22,639 --> 00:07:27,199
having a swarm attack in the problem

00:07:24,479 --> 00:07:29,360
space helps everybody

00:07:27,199 --> 00:07:31,599
we can learn from each other see what

00:07:29,360 --> 00:07:33,599
works what doesn't

00:07:31,599 --> 00:07:35,039
languages share and steal from each

00:07:33,599 --> 00:07:38,000
other all the time

00:07:35,039 --> 00:07:39,199
and that is a great thing rust for

00:07:38,000 --> 00:07:42,800
example has very few

00:07:39,199 --> 00:07:44,400
original ideas and always implied

00:07:42,800 --> 00:07:46,240
priority in language design

00:07:44,400 --> 00:07:47,919
is to make the language as easy to pick

00:07:46,240 --> 00:07:49,599
up as possible

00:07:47,919 --> 00:07:51,360
very rarely someone goes out of their

00:07:49,599 --> 00:07:54,560
way to make their product

00:07:51,360 --> 00:07:55,280
harder to use beyond the objectives of

00:07:54,560 --> 00:07:56,879
the language

00:07:55,280 --> 00:07:58,560
there are different parts of what makes

00:07:56,879 --> 00:08:00,560
a language

00:07:58,560 --> 00:08:02,240
first and most visibly you have the

00:08:00,560 --> 00:08:03,039
chosen syntax and grammar of the

00:08:02,240 --> 00:08:05,199
language

00:08:03,039 --> 00:08:06,879
which is what you can write what the

00:08:05,199 --> 00:08:09,199
code looks like

00:08:06,879 --> 00:08:11,039
a lot of conversations go on at length

00:08:09,199 --> 00:08:12,960
about syntax as if it were the most

00:08:11,039 --> 00:08:16,080
important part of any language

00:08:12,960 --> 00:08:18,960
i strongly disagree cue async await

00:08:16,080 --> 00:08:21,039
syntax conversation in the comments

00:08:18,960 --> 00:08:23,520
i consider parsing and syntax to be the

00:08:21,039 --> 00:08:25,840
least interesting part of any language

00:08:23,520 --> 00:08:27,840
as it is mostly a solved problem that

00:08:25,840 --> 00:08:29,599
requires little effort in both design

00:08:27,840 --> 00:08:31,440
and implementation

00:08:29,599 --> 00:08:33,279
model of things like malformed code

00:08:31,440 --> 00:08:35,440
recovery

00:08:33,279 --> 00:08:38,080
particularly when put in contrast with

00:08:35,440 --> 00:08:40,800
the rest of the compilers functions

00:08:38,080 --> 00:08:42,640
and the language design space using

00:08:40,800 --> 00:08:44,240
square brackets instead of less than

00:08:42,640 --> 00:08:45,040
more than for generics to give an

00:08:44,240 --> 00:08:47,360
example

00:08:45,040 --> 00:08:48,720
has little impact on the experience of

00:08:47,360 --> 00:08:50,560
writing the language

00:08:48,720 --> 00:08:52,240
although it can have huge implications

00:08:50,560 --> 00:08:54,800
on the compiler's implementation and

00:08:52,240 --> 00:08:57,839
error recovery cue turbofish

00:08:54,800 --> 00:09:00,959
conversation in the comments

00:08:57,839 --> 00:09:02,880
secondly you will also have the

00:09:00,959 --> 00:09:04,959
semantics of the syntax

00:09:02,880 --> 00:09:06,640
what the code actually how the code

00:09:04,959 --> 00:09:07,519
actually behaves when written a certain

00:09:06,640 --> 00:09:09,360
way

00:09:07,519 --> 00:09:10,880
this is where small differences can

00:09:09,360 --> 00:09:12,480
surprise people when moving from

00:09:10,880 --> 00:09:15,040
language to language

00:09:12,480 --> 00:09:16,480
this includes behaviors such as what

00:09:15,040 --> 00:09:17,440
happens behind the scenes when you call

00:09:16,480 --> 00:09:19,440
a method

00:09:17,440 --> 00:09:22,000
or where in memory your data leaves and

00:09:19,440 --> 00:09:25,600
how it is accessed

00:09:22,000 --> 00:09:28,320
finally you have features what you can

00:09:25,600 --> 00:09:29,519
and almost as important cannot do with

00:09:28,320 --> 00:09:31,200
language

00:09:29,519 --> 00:09:33,760
language design is a lot of the time

00:09:31,200 --> 00:09:35,120
saying no removing things that have been

00:09:33,760 --> 00:09:37,040
tried before

00:09:35,120 --> 00:09:38,959
that can lead people to make avoidable

00:09:37,040 --> 00:09:40,959
mistakes or that don't fit the rest of

00:09:38,959 --> 00:09:42,880
the language

00:09:40,959 --> 00:09:44,480
if you have used rust you have already

00:09:42,880 --> 00:09:46,959
noticed that this is this is

00:09:44,480 --> 00:09:48,160
very much part of its design from the

00:09:46,959 --> 00:09:49,600
plural checker through the

00:09:48,160 --> 00:09:51,600
non-representability of null to

00:09:49,600 --> 00:09:53,440
immutability by default

00:09:51,600 --> 00:09:55,440
when it comes down to it features are

00:09:53,440 --> 00:09:57,200
sometimes foundational stuff common to

00:09:55,440 --> 00:09:59,120
all or most languages

00:09:57,200 --> 00:10:00,399
like being able to bind a local variable

00:09:59,120 --> 00:10:02,560
or while loops

00:10:00,399 --> 00:10:03,519
or formalizing existing patterns into

00:10:02,560 --> 00:10:05,440
the language

00:10:03,519 --> 00:10:07,680
like message passing or first class

00:10:05,440 --> 00:10:10,399
functions

00:10:07,680 --> 00:10:10,959
regardless anyone learning your new

00:10:10,399 --> 00:10:13,040
language

00:10:10,959 --> 00:10:14,399
and in our case rust will have to

00:10:13,040 --> 00:10:17,519
internalize rules

00:10:14,399 --> 00:10:20,399
from those three buckets if they come

00:10:17,519 --> 00:10:22,079
tabula rasa you can ignore prior art and

00:10:20,399 --> 00:10:22,800
do anything you think will be best for

00:10:22,079 --> 00:10:25,440
them

00:10:22,800 --> 00:10:26,959
but in reality a lot of people will be

00:10:25,440 --> 00:10:27,920
coming from other already existing

00:10:26,959 --> 00:10:29,519
languages

00:10:27,920 --> 00:10:31,279
and there are so many languages out

00:10:29,519 --> 00:10:34,160
there that you can

00:10:31,279 --> 00:10:36,560
learn a lot from or still if you prefer

00:10:34,160 --> 00:10:38,000
with the benefit of hindsight

00:10:36,560 --> 00:10:39,760
for all the complaints about the

00:10:38,000 --> 00:10:42,320
breakneck change in rust

00:10:39,760 --> 00:10:43,120
i believe it is a boring language all of

00:10:42,320 --> 00:10:44,640
its features

00:10:43,120 --> 00:10:48,079
with a single exception of the borrowed

00:10:44,640 --> 00:10:50,079
checker already exist in other languages

00:10:48,079 --> 00:10:52,160
people more eloquent than me have

00:10:50,079 --> 00:10:55,200
described this as your language

00:10:52,160 --> 00:10:57,760
strangeness budget try to say that

00:10:55,200 --> 00:10:59,760
three times in a row the further you

00:10:57,760 --> 00:11:02,000
stray from the beaten path

00:10:59,760 --> 00:11:04,160
the harder it will be for people to walk

00:11:02,000 --> 00:11:06,640
with you

00:11:04,160 --> 00:11:07,519
consider human languages for instance

00:11:06,640 --> 00:11:10,480
there are lots

00:11:07,519 --> 00:11:13,040
of languages across this earth of ours

00:11:10,480 --> 00:11:14,880
and a lot of them have common roots

00:11:13,040 --> 00:11:16,480
somebody who speaks spanish for example

00:11:14,880 --> 00:11:18,320
will have a relatively easy time

00:11:16,480 --> 00:11:20,720
learning portuguese

00:11:18,320 --> 00:11:21,760
there is no one-to-one mapping for every

00:11:20,720 --> 00:11:24,560
grammatical

00:11:21,760 --> 00:11:25,760
construct and rule but due to their

00:11:24,560 --> 00:11:27,279
shared heritage

00:11:25,760 --> 00:11:29,360
applying rules from spanish to

00:11:27,279 --> 00:11:30,800
portuguese will be correct more often

00:11:29,360 --> 00:11:32,399
than not

00:11:30,800 --> 00:11:34,079
picture instead if a japanese person

00:11:32,399 --> 00:11:36,480
wanted to learn norwegian

00:11:34,079 --> 00:11:37,440
as beautiful as norwegian may be due to

00:11:36,480 --> 00:11:39,920
those two languages

00:11:37,440 --> 00:11:42,079
sharing no common root this person will

00:11:39,920 --> 00:11:43,839
be having to start from scratch

00:11:42,079 --> 00:11:46,160
which can be a much more frustrating

00:11:43,839 --> 00:11:50,240
experience

00:11:46,160 --> 00:11:50,959
quick aside i have the unsubstantiated

00:11:50,240 --> 00:11:52,399
theory

00:11:50,959 --> 00:11:54,160
that experienced developers have a

00:11:52,399 --> 00:11:56,240
harder time than less experienced

00:11:54,160 --> 00:11:58,320
developers when learning rust

00:11:56,240 --> 00:11:59,839
they need to forget a lot of constructs

00:11:58,320 --> 00:12:01,519
that work well enough in the languages

00:11:59,839 --> 00:12:02,959
they already know

00:12:01,519 --> 00:12:04,880
because they introduce things that go

00:12:02,959 --> 00:12:07,839
against the single owner enforcement

00:12:04,880 --> 00:12:08,639
that rastas whereas somebody with less

00:12:07,839 --> 00:12:11,279
experience

00:12:08,639 --> 00:12:12,000
will simultaneously accept restrictions

00:12:11,279 --> 00:12:15,200
as

00:12:12,000 --> 00:12:18,240
just the way it is and not seek out

00:12:15,200 --> 00:12:20,079
other more performant constructs that

00:12:18,240 --> 00:12:23,120
can be much harder to understand

00:12:20,079 --> 00:12:25,440
or implement breast has a curse

00:12:23,120 --> 00:12:26,639
it has many but this one is critical

00:12:25,440 --> 00:12:29,040
inefficient code

00:12:26,639 --> 00:12:30,639
is generally visible experienced

00:12:29,040 --> 00:12:32,240
developers hate to notice that their

00:12:30,639 --> 00:12:34,320
code is inefficient

00:12:32,240 --> 00:12:35,440
they will recall at seeing arc of ref

00:12:34,320 --> 00:12:36,880
cell of t

00:12:35,440 --> 00:12:39,440
but they won't bite an eye at using

00:12:36,880 --> 00:12:41,279
python i know because i have the same

00:12:39,440 --> 00:12:43,600
instinct

00:12:41,279 --> 00:12:44,880
this makes it much harder to learn rust

00:12:43,600 --> 00:12:47,519
for experienced developers

00:12:44,880 --> 00:12:48,959
because they start with simple ros code

00:12:47,519 --> 00:12:49,920
that will work but is slightly

00:12:48,959 --> 00:12:52,160
inefficient

00:12:49,920 --> 00:12:53,760
and in an effort to improve it they land

00:12:52,160 --> 00:12:56,079
squarely in parts of the language

00:12:53,760 --> 00:12:58,639
that they haven't yet developed a mental

00:12:56,079 --> 00:12:58,639
model for

00:12:59,440 --> 00:13:03,200
to summarize when creating a learnable

00:13:02,160 --> 00:13:06,240
language

00:13:03,200 --> 00:13:07,839
copy from others deviate from them only

00:13:06,240 --> 00:13:09,519
if you're convinced you have a very good

00:13:07,839 --> 00:13:11,760
reason to do so

00:13:09,519 --> 00:13:14,320
to do otherwise is to avoid success at

00:13:11,760 --> 00:13:14,320
all costs

00:13:14,560 --> 00:13:17,920
if you have been on the internet for as

00:13:15,839 --> 00:13:20,800
long as i have you must have already

00:13:17,920 --> 00:13:23,600
encountered this old joke

00:13:20,800 --> 00:13:25,680
it's it represents the learning curves

00:13:23,600 --> 00:13:27,920
for some popular editors people would

00:13:25,680 --> 00:13:30,240
use back in the 90s

00:13:27,920 --> 00:13:33,519
people have done quite a few of these

00:13:30,240 --> 00:13:35,360
graphs for programming languages too

00:13:33,519 --> 00:13:37,200
i would say that grass probably lands

00:13:35,360 --> 00:13:38,560
somewhere between c plus plus and has

00:13:37,200 --> 00:13:40,639
calendar

00:13:38,560 --> 00:13:42,800
but if you go looking around for the

00:13:40,639 --> 00:13:48,079
perception of rust's

00:13:42,800 --> 00:13:50,399
learning curve it's not very encouraging

00:13:48,079 --> 00:13:52,160
of the problem is the objectives we've

00:13:50,399 --> 00:13:54,800
said ourselves

00:13:52,160 --> 00:13:55,600
we prioritize being able to produce fast

00:13:54,800 --> 00:13:57,760
binaries

00:13:55,600 --> 00:13:59,040
for constrained environments and

00:13:57,760 --> 00:14:00,800
anything that can be done towards

00:13:59,040 --> 00:14:03,839
ergonomics and compilation speeds

00:14:00,800 --> 00:14:06,079
will not affecting that objective is

00:14:03,839 --> 00:14:08,240
already been done

00:14:06,079 --> 00:14:10,560
having said that the experience of

00:14:08,240 --> 00:14:13,600
learning and using a language

00:14:10,560 --> 00:14:16,720
goes beyond the language itself

00:14:13,600 --> 00:14:19,839
the available libraries documentation

00:14:16,720 --> 00:14:22,720
tooling platform support

00:14:19,839 --> 00:14:24,240
and the surrounding community all affect

00:14:22,720 --> 00:14:26,959
how easy it is to

00:14:24,240 --> 00:14:29,360
learn a language and as importantly how

00:14:26,959 --> 00:14:31,680
likely people are to stick around

00:14:29,360 --> 00:14:33,440
going back to my original analogy moving

00:14:31,680 --> 00:14:34,560
to a new place is not a single decision

00:14:33,440 --> 00:14:36,959
in time

00:14:34,560 --> 00:14:38,880
in fact every day you reaffirmed your

00:14:36,959 --> 00:14:42,240
decision to stay

00:14:38,880 --> 00:14:42,959
even if possibly if you had infinite

00:14:42,240 --> 00:14:44,399
resources

00:14:42,959 --> 00:14:46,880
you could improve the learnability of

00:14:44,399 --> 00:14:49,360
your language change the slope

00:14:46,880 --> 00:14:50,560
of its learning curve by providing every

00:14:49,360 --> 00:14:53,680
single newcomer

00:14:50,560 --> 00:14:56,720
with a personalized tutor

00:14:53,680 --> 00:14:58,399
this needless to say doesn't scale

00:14:56,720 --> 00:15:00,880
you may have noticed that i included a

00:14:58,399 --> 00:15:02,320
nebulous tooling item in that prior

00:15:00,880 --> 00:15:03,760
slide

00:15:02,320 --> 00:15:06,240
this includes things like code

00:15:03,760 --> 00:15:08,560
formatters linters debuggers package

00:15:06,240 --> 00:15:10,839
managers and ids

00:15:08,560 --> 00:15:13,199
for a while last century and up to the

00:15:10,839 --> 00:15:16,959
90s there was this fad in

00:15:13,199 --> 00:15:19,199
our industry that expert systems

00:15:16,959 --> 00:15:21,600
it was positive that you could take a

00:15:19,199 --> 00:15:22,959
handful of really experienced people

00:15:21,600 --> 00:15:24,720
pick their brains and encode their

00:15:22,959 --> 00:15:26,000
thinking mental model and decision

00:15:24,720 --> 00:15:28,320
making process

00:15:26,000 --> 00:15:29,680
and use that as the basis of software

00:15:28,320 --> 00:15:32,399
used by other

00:15:29,680 --> 00:15:32,880
less experienced people this way you

00:15:32,399 --> 00:15:35,360
could get

00:15:32,880 --> 00:15:37,360
the benefits of an expert at a fraction

00:15:35,360 --> 00:15:39,120
of the cost to train one

00:15:37,360 --> 00:15:41,199
we are still trying to apply this idea

00:15:39,120 --> 00:15:43,199
only now we call it machine learning

00:15:41,199 --> 00:15:46,480
and we use it to figure out how many

00:15:43,199 --> 00:15:49,279
teaspoons there are in a measuring cup

00:15:46,480 --> 00:15:51,759
this idea has been used in our industry

00:15:49,279 --> 00:15:53,759
in an effort to increase productivity

00:15:51,759 --> 00:15:56,320
in the shape of ideas integrated

00:15:53,759 --> 00:15:58,240
development environments

00:15:56,320 --> 00:16:00,079
these programs with a text editor

00:15:58,240 --> 00:16:01,920
debugger code navigation utilities of

00:16:00,079 --> 00:16:03,440
the completion and all the goodies

00:16:01,920 --> 00:16:05,600
have everything you may need when

00:16:03,440 --> 00:16:08,480
writing software

00:16:05,600 --> 00:16:08,880
if you look at most ecosystems ideas are

00:16:08,480 --> 00:16:11,440
not

00:16:08,880 --> 00:16:12,720
as an optional separate tool from the

00:16:11,440 --> 00:16:14,959
compiler

00:16:12,720 --> 00:16:16,480
in javaland you have a plethora of

00:16:14,959 --> 00:16:20,000
options to choose from

00:16:16,480 --> 00:16:22,480
from google to pretty amazing

00:16:20,000 --> 00:16:24,399
in the microsoft.net ecosystem talking

00:16:22,480 --> 00:16:25,120
about the ide visual studio and the

00:16:24,399 --> 00:16:26,959
compiler

00:16:25,120 --> 00:16:29,120
as separate entities is making a

00:16:26,959 --> 00:16:31,120
distinction without the difference

00:16:29,120 --> 00:16:34,320
the compiler is so deeply embedded in

00:16:31,120 --> 00:16:36,880
the ide that they are one and the same

00:16:34,320 --> 00:16:38,240
but as i said earlier ides are focused

00:16:36,880 --> 00:16:41,519
on productivity

00:16:38,240 --> 00:16:43,600
not learnability we could create a new

00:16:41,519 --> 00:16:45,920
tool to act as a tutor

00:16:43,600 --> 00:16:47,839
apply the idea of expert systems to the

00:16:45,920 --> 00:16:49,519
teaching of a language

00:16:47,839 --> 00:16:52,639
but when you introduce a new tool you

00:16:49,519 --> 00:16:56,000
have the problem of discoverability

00:16:52,639 --> 00:16:58,720
the people that may need it most

00:16:56,000 --> 00:16:59,519
will never find out about it you could

00:16:58,720 --> 00:17:02,399
introduce it

00:16:59,519 --> 00:17:04,160
into an ide but if your ecosystem isn't

00:17:02,399 --> 00:17:06,720
self-contained making this ide the

00:17:04,160 --> 00:17:10,079
defacto tool that all newcomers use

00:17:06,720 --> 00:17:13,600
you're not helping everyone you could

00:17:10,079 --> 00:17:14,480
however there is one mandatory tool that

00:17:13,600 --> 00:17:18,799
people are

00:17:14,480 --> 00:17:20,880
forced to use the compiler

00:17:18,799 --> 00:17:22,480
a lot of people have this idea that the

00:17:20,880 --> 00:17:25,520
primary function of a compiler

00:17:22,480 --> 00:17:27,439
is to take well-form code and spit out a

00:17:25,520 --> 00:17:29,919
runnable binary

00:17:27,439 --> 00:17:31,520
my sticky my steaming hot take is that

00:17:29,919 --> 00:17:34,080
the primary function of a compiler

00:17:31,520 --> 00:17:35,200
is to take malformed code and emit

00:17:34,080 --> 00:17:37,440
diagnostics

00:17:35,200 --> 00:17:38,720
to help the programmer turn it into well

00:17:37,440 --> 00:17:41,440
form code

00:17:38,720 --> 00:17:42,400
a compiler is a narrow reporting tool

00:17:41,440 --> 00:17:45,440
with a codes

00:17:42,400 --> 00:17:46,960
generation side gig i know a lot of

00:17:45,440 --> 00:17:49,760
people will give me pushback on that

00:17:46,960 --> 00:17:51,520
comment and i am being slightly flippant

00:17:49,760 --> 00:17:53,120
but what the user of the compiler uses

00:17:51,520 --> 00:17:54,720
it for the mesh

00:17:53,120 --> 00:17:56,960
vast majority of the time is to get

00:17:54,720 --> 00:17:59,760
feedback on whether they have missed

00:17:56,960 --> 00:18:00,799
something the vast majority of the code

00:17:59,760 --> 00:18:04,000
in the ras compiler

00:18:00,799 --> 00:18:05,840
is dedicated to error reporting yeah i

00:18:04,000 --> 00:18:07,919
don't have good statistics but

00:18:05,840 --> 00:18:08,960
anyone that has contributed to russia

00:18:07,919 --> 00:18:12,000
can attest

00:18:08,960 --> 00:18:14,080
that it certainly feels that way

00:18:12,000 --> 00:18:15,200
efficiency of generated code is

00:18:14,080 --> 00:18:17,360
important

00:18:15,200 --> 00:18:18,480
but it is a well explored space with

00:18:17,360 --> 00:18:21,200
decades of research

00:18:18,480 --> 00:18:22,640
and applied techniques at the same time

00:18:21,200 --> 00:18:24,400
emitting good diagnostics

00:18:22,640 --> 00:18:26,000
is hard because it requires a lot of

00:18:24,400 --> 00:18:27,840
foresight and effort

00:18:26,000 --> 00:18:29,200
diagnostic errors touch upon every

00:18:27,840 --> 00:18:31,280
single part of the language

00:18:29,200 --> 00:18:32,480
from how easy it is to write typos that

00:18:31,280 --> 00:18:35,600
look like word from

00:18:32,480 --> 00:18:37,600
but nonsensical code to parsing errors

00:18:35,600 --> 00:18:38,640
that are carried forward to later stages

00:18:37,600 --> 00:18:41,600
of the compiler

00:18:38,640 --> 00:18:43,120
compounding as they go along unless you

00:18:41,600 --> 00:18:45,120
make it a priority

00:18:43,120 --> 00:18:47,039
the developer experience will always be

00:18:45,120 --> 00:18:48,960
subpar

00:18:47,039 --> 00:18:50,400
communicating with a user to get them to

00:18:48,960 --> 00:18:52,960
that generated binary

00:18:50,400 --> 00:18:54,320
is at least as important and in my eyes

00:18:52,960 --> 00:18:56,559
it is more important

00:18:54,320 --> 00:18:58,400
than any other task the compiler is

00:18:56,559 --> 00:19:00,799
asked to do

00:18:58,400 --> 00:19:01,440
and when we're emitting diagnostic

00:19:00,799 --> 00:19:03,760
errors

00:19:01,440 --> 00:19:04,480
is the perfect place and moment to teach

00:19:03,760 --> 00:19:06,400
people

00:19:04,480 --> 00:19:09,840
they have made a mistake and we can

00:19:06,400 --> 00:19:11,360
explain to them why they've made it

00:19:09,840 --> 00:19:12,320
think about what i'm talking about what

00:19:11,360 --> 00:19:14,240
the possibilities

00:19:12,320 --> 00:19:16,240
with the possibilities we have here

00:19:14,240 --> 00:19:19,360
consider the kind of errors that people

00:19:16,240 --> 00:19:21,760
see you have parse errors that are

00:19:19,360 --> 00:19:22,640
caused by malformed code that is close

00:19:21,760 --> 00:19:25,600
to correct

00:19:22,640 --> 00:19:26,720
but that has a few typos there is quite

00:19:25,600 --> 00:19:28,080
a bit of research

00:19:26,720 --> 00:19:29,760
on how to detect these errors

00:19:28,080 --> 00:19:32,080
automatically and identify what the

00:19:29,760 --> 00:19:34,240
user's original intent was

00:19:32,080 --> 00:19:36,000
but if you have enough users reporting

00:19:34,240 --> 00:19:37,520
bugs and enough developers

00:19:36,000 --> 00:19:39,280
you can get quite far with simply

00:19:37,520 --> 00:19:39,840
identifying common and problematic

00:19:39,280 --> 00:19:41,919
errors

00:19:39,840 --> 00:19:44,080
and handling them proactively in the

00:19:41,919 --> 00:19:47,440
parser we can detect

00:19:44,080 --> 00:19:48,480
small incorrect usages an example i

00:19:47,440 --> 00:19:50,960
always come back to

00:19:48,480 --> 00:19:52,000
is type ascription it doesn't matter

00:19:50,960 --> 00:19:53,600
what it does

00:19:52,000 --> 00:19:55,760
but i'll give you a short overview

00:19:53,600 --> 00:19:57,280
regardless it is nightly only

00:19:55,760 --> 00:19:58,960
it lets you annotate a new expression

00:19:57,280 --> 00:20:00,320
with a type and uses the column

00:19:58,960 --> 00:20:03,679
character

00:20:00,320 --> 00:20:05,760
in order to mimic lead bindings

00:20:03,679 --> 00:20:07,679
with types function argument bindings

00:20:05,760 --> 00:20:10,240
and struct field bindings

00:20:07,679 --> 00:20:11,360
but it has one extra characteristic it

00:20:10,240 --> 00:20:13,200
is extremely

00:20:11,360 --> 00:20:15,360
easy to make a typo that looks like it's

00:20:13,200 --> 00:20:17,760
a naive rust parser

00:20:15,360 --> 00:20:19,440
it's been the main of my existence but i

00:20:17,760 --> 00:20:20,000
am quite happy with how well we can

00:20:19,440 --> 00:20:22,960
detect it

00:20:20,000 --> 00:20:23,360
nowadays and recover relatively well

00:20:22,960 --> 00:20:25,039
although

00:20:23,360 --> 00:20:26,880
as you can see at the bottom there we

00:20:25,039 --> 00:20:29,679
are still not quite there

00:20:26,880 --> 00:20:31,760
in silencing knockdown errors caused by

00:20:29,679 --> 00:20:33,919
it

00:20:31,760 --> 00:20:35,360
other more pervasive errors are what i

00:20:33,919 --> 00:20:37,440
call negative space

00:20:35,360 --> 00:20:39,280
boundary errors i've taken to

00:20:37,440 --> 00:20:41,520
interpreting the negative space

00:20:39,280 --> 00:20:43,760
of a language as the area outside of a

00:20:41,520 --> 00:20:46,000
language valids grammar

00:20:43,760 --> 00:20:47,360
consider a cartesian area everything

00:20:46,000 --> 00:20:49,840
inside of that boundary

00:20:47,360 --> 00:20:50,480
is valid rust everything outside of that

00:20:49,840 --> 00:20:53,039
boundary

00:20:50,480 --> 00:20:54,799
is all possible implementations of text

00:20:53,039 --> 00:20:56,000
that's how the rust grammar sees the

00:20:54,799 --> 00:20:58,559
world

00:20:56,000 --> 00:21:00,000
but we aren't like that with healing

00:20:58,559 --> 00:21:01,520
shades of grey

00:21:00,000 --> 00:21:03,200
there is code that lies right on the

00:21:01,520 --> 00:21:04,960
wrong side of that boundary that would

00:21:03,200 --> 00:21:07,120
look to a human as correct

00:21:04,960 --> 00:21:09,919
it could be code that breast explicitly

00:21:07,120 --> 00:21:11,760
doesn't support for some specific reason

00:21:09,919 --> 00:21:13,120
a reasonable person may be extrapolating

00:21:11,760 --> 00:21:14,159
from rules they have already

00:21:13,120 --> 00:21:16,880
internalized

00:21:14,159 --> 00:21:18,559
if not fully learned or relying on rules

00:21:16,880 --> 00:21:19,440
from other languages that don't apply to

00:21:18,559 --> 00:21:22,720
rust

00:21:19,440 --> 00:21:24,559
and lander but the interesting thing

00:21:22,720 --> 00:21:26,640
is that we can proactively search for

00:21:24,559 --> 00:21:29,600
these cases or at least

00:21:26,640 --> 00:21:31,200
watch people land in those places this

00:21:29,600 --> 00:21:33,919
is not an original idea

00:21:31,200 --> 00:21:35,520
other types of software products conduct

00:21:33,919 --> 00:21:37,360
user research all the time

00:21:35,520 --> 00:21:39,440
looking at how people fail to use their

00:21:37,360 --> 00:21:40,080
products and once they have identified

00:21:39,440 --> 00:21:43,200
things

00:21:40,080 --> 00:21:44,000
reasonable people may do we can make the

00:21:43,200 --> 00:21:46,640
compiler

00:21:44,000 --> 00:21:47,360
handle them even when they are features

00:21:46,640 --> 00:21:50,799
that can't be

00:21:47,360 --> 00:21:52,960
included in language because we can make

00:21:50,799 --> 00:21:55,120
the compiler infer intent

00:21:52,960 --> 00:21:56,640
we can make the compiler understand the

00:21:55,120 --> 00:21:58,960
superset of the language

00:21:56,640 --> 00:22:01,120
and guide people towards a valid

00:21:58,960 --> 00:22:02,640
supported solution

00:22:01,120 --> 00:22:04,960
while explaining why what they have

00:22:02,640 --> 00:22:06,320
tried to do isn't supported

00:22:04,960 --> 00:22:08,240
this can include things that are

00:22:06,320 --> 00:22:11,440
possible in other languages

00:22:08,240 --> 00:22:13,039
but that are not possible in rust one

00:22:11,440 --> 00:22:13,760
problem you may envision with that

00:22:13,039 --> 00:22:16,000
approach

00:22:13,760 --> 00:22:17,600
is that a tutor needs to have some

00:22:16,000 --> 00:22:20,480
knowledge of their duty

00:22:17,600 --> 00:22:22,400
to give them short relevant explanations

00:22:20,480 --> 00:22:24,960
as you can imagine writing a compiler

00:22:22,400 --> 00:22:27,200
with that level of knowledge of the user

00:22:24,960 --> 00:22:28,320
would be difficult for a non-google

00:22:27,200 --> 00:22:31,120
entity

00:22:28,320 --> 00:22:33,679
and even then but the compiler has

00:22:31,120 --> 00:22:35,919
context of what the error was

00:22:33,679 --> 00:22:37,679
for problems off the beaten path but

00:22:35,919 --> 00:22:39,280
with a high degree of intent we can

00:22:37,679 --> 00:22:40,480
assume that the user knows what they are

00:22:39,280 --> 00:22:42,000
trying to accomplish

00:22:40,480 --> 00:22:44,559
they just don't know how to do it in

00:22:42,000 --> 00:22:46,640
rest you need to have a lot of

00:22:44,559 --> 00:22:49,120
confidence when guiding the user

00:22:46,640 --> 00:22:50,640
though because misleading users can have

00:22:49,120 --> 00:22:53,039
dire consequences

00:22:50,640 --> 00:22:53,760
for example people with less experience

00:22:53,039 --> 00:22:56,320
may treat

00:22:53,760 --> 00:22:58,080
the compiler as an all-knowing oracle

00:22:56,320 --> 00:23:00,640
when the oracle is wrong

00:22:58,080 --> 00:23:02,240
they get very confused for common

00:23:00,640 --> 00:23:04,880
problems like typos we don't need to

00:23:02,240 --> 00:23:06,720
give too much of an explanation

00:23:04,880 --> 00:23:08,559
consider explaining the distinction

00:23:06,720 --> 00:23:10,320
between string slices and heap allocated

00:23:08,559 --> 00:23:12,159
strings to a newcomer

00:23:10,320 --> 00:23:13,840
rast has two and a half types here to

00:23:12,159 --> 00:23:15,520
represent the concept that depending on

00:23:13,840 --> 00:23:19,360
the language you're coming from

00:23:15,520 --> 00:23:22,320
is either one or maybe two a string

00:23:19,360 --> 00:23:23,760
is a continuous piece of memory holding

00:23:22,320 --> 00:23:27,039
valid utf-8

00:23:23,760 --> 00:23:29,840
sequence of code points a string slice

00:23:27,039 --> 00:23:31,200
is a fat pointer to a string and that

00:23:29,840 --> 00:23:33,440
length

00:23:31,200 --> 00:23:36,000
a heap allocated string is almost the

00:23:33,440 --> 00:23:38,400
same but this fat pointer is owned

00:23:36,000 --> 00:23:40,400
and the sequence is in the heap and can

00:23:38,400 --> 00:23:42,320
be reallocated

00:23:40,400 --> 00:23:43,919
we need to explain that string slices

00:23:42,320 --> 00:23:46,960
can point to either a string or as

00:23:43,919 --> 00:23:49,360
inside a heap allocated string

00:23:46,960 --> 00:23:50,960
we have to explain the ownership mode

00:23:49,360 --> 00:23:52,559
auto referencing

00:23:50,960 --> 00:23:55,360
the distinction between the hip and the

00:23:52,559 --> 00:23:57,200
stack unicode code points

00:23:55,360 --> 00:23:58,799
and we haven't even mentioned null

00:23:57,200 --> 00:24:01,919
terminated strings

00:23:58,799 --> 00:24:05,440
os string path back of u8

00:24:01,919 --> 00:24:08,559
back of char utf-8 utf-16 utf-32

00:24:05,440 --> 00:24:10,640
seismic or lifetime yet

00:24:08,559 --> 00:24:12,799
if you knew where the user is coming

00:24:10,640 --> 00:24:14,720
from we could explain to a c developer

00:24:12,799 --> 00:24:16,559
that the string is like a non-null

00:24:14,720 --> 00:24:18,720
terminated string in their binary

00:24:16,559 --> 00:24:20,799
to a c plus plus developer that string

00:24:18,720 --> 00:24:22,480
slice is like a string view

00:24:20,799 --> 00:24:24,480
and to a java developer that the heap

00:24:22,480 --> 00:24:26,480
allocated string is analogous to a

00:24:24,480 --> 00:24:28,400
string buffer

00:24:26,480 --> 00:24:29,600
but we can't know where they are coming

00:24:28,400 --> 00:24:31,440
from

00:24:29,600 --> 00:24:33,039
and you just saw how much time i needed

00:24:31,440 --> 00:24:36,080
to explain this one thing

00:24:33,039 --> 00:24:37,760
that you encounter really early on and

00:24:36,080 --> 00:24:41,279
that you're likely to encounter

00:24:37,760 --> 00:24:43,520
often after that so instead

00:24:41,279 --> 00:24:45,360
we got to give out enough information to

00:24:43,520 --> 00:24:49,360
immediately unblock you

00:24:45,360 --> 00:24:51,600
consider borrowing call to owned

00:24:49,360 --> 00:24:52,880
we provide a strong description of the

00:24:51,600 --> 00:24:54,400
problem that gives you

00:24:52,880 --> 00:24:56,000
just enough information to tell you

00:24:54,400 --> 00:24:58,320
there is a reason for the supplied code

00:24:56,000 --> 00:25:00,400
not to be accepted

00:24:58,320 --> 00:25:01,600
in other code in other cases we would

00:25:00,400 --> 00:25:04,000
even weave

00:25:01,600 --> 00:25:05,120
a bunch of shargan in the description on

00:25:04,000 --> 00:25:06,880
purpose

00:25:05,120 --> 00:25:10,000
to feed you words that you can search

00:25:06,880 --> 00:25:11,120
for this way people are slowly learning

00:25:10,000 --> 00:25:13,600
some of the rules

00:25:11,120 --> 00:25:14,159
sometimes sometimes by inference and

00:25:13,600 --> 00:25:17,039
sometimes

00:25:14,159 --> 00:25:17,600
being outright told about them an

00:25:17,039 --> 00:25:20,880
example

00:25:17,600 --> 00:25:23,120
of teaching one relevant can be

00:25:20,880 --> 00:25:24,400
when wanting to return something that

00:25:23,120 --> 00:25:25,760
implements a trade

00:25:24,400 --> 00:25:29,200
without caring about the actual

00:25:25,760 --> 00:25:32,080
underlying type a last newcomer's

00:25:29,200 --> 00:25:32,799
first instinct could be to directly

00:25:32,080 --> 00:25:35,600
return it

00:25:32,799 --> 00:25:36,960
and just set the return type to the to

00:25:35,600 --> 00:25:40,159
trade

00:25:36,960 --> 00:25:41,200
currently inundate doing so currently

00:25:40,159 --> 00:25:43,760
inundates the

00:25:41,200 --> 00:25:45,520
output with a bunch of different errors

00:25:43,760 --> 00:25:46,640
some are stylistic warnings that can be

00:25:45,520 --> 00:25:50,000
easily fixed

00:25:46,640 --> 00:25:52,559
and we explain how to do so other are

00:25:50,000 --> 00:25:53,520
not down errors that we should be hiding

00:25:52,559 --> 00:25:55,279
already

00:25:53,520 --> 00:25:57,200
they will be fixed if you fix other

00:25:55,279 --> 00:25:59,440
parts of the code

00:25:57,200 --> 00:26:00,480
but then we get to the meat of the

00:25:59,440 --> 00:26:02,880
output

00:26:00,480 --> 00:26:04,400
we introduce people to a potentially new

00:26:02,880 --> 00:26:05,520
feature for them

00:26:04,400 --> 00:26:08,799
and even include a link to the

00:26:05,520 --> 00:26:10,799
documentation they can read up on

00:26:08,799 --> 00:26:12,080
the compiler actually checks that the

00:26:10,799 --> 00:26:14,080
suggestion would

00:26:12,080 --> 00:26:16,080
actually work it checks that the

00:26:14,080 --> 00:26:18,240
involved types could work with a new

00:26:16,080 --> 00:26:20,240
return type

00:26:18,240 --> 00:26:23,039
with slightly different output where

00:26:20,240 --> 00:26:24,799
infiltrate wouldn't work directly

00:26:23,039 --> 00:26:27,120
we still give a bunch of unnecessary

00:26:24,799 --> 00:26:27,919
errors but we also explain why

00:26:27,120 --> 00:26:30,400
infiltrate

00:26:27,919 --> 00:26:32,080
won't work and provide the user a bunch

00:26:30,400 --> 00:26:34,960
of alternatives

00:26:32,080 --> 00:26:36,000
in this case using a box trade object or

00:26:34,960 --> 00:26:37,600
an enum

00:26:36,000 --> 00:26:40,000
along with some example code that they

00:26:37,600 --> 00:26:42,080
can directly use

00:26:40,000 --> 00:26:43,600
all of this lets us get around the lack

00:26:42,080 --> 00:26:46,320
of support in the language

00:26:43,600 --> 00:26:48,480
for unsized return types while

00:26:46,320 --> 00:26:50,000
unblocking the user without forcing them

00:26:48,480 --> 00:26:53,760
to visit a forum

00:26:50,000 --> 00:26:55,919
to ask for help of course

00:26:53,760 --> 00:26:57,840
someone that already knows they can't

00:26:55,919 --> 00:27:01,279
return and box trades directly

00:26:57,840 --> 00:27:02,320
may trade may try to avoid the heap

00:27:01,279 --> 00:27:04,640
allocation cost

00:27:02,320 --> 00:27:05,440
and try to return a borrow but not know

00:27:04,640 --> 00:27:06,880
or forget

00:27:05,440 --> 00:27:09,120
that the lifetime has to be related

00:27:06,880 --> 00:27:11,279
somewhere

00:27:09,120 --> 00:27:12,480
another example can be when people get

00:27:11,279 --> 00:27:15,279
bitten by implicit

00:27:12,480 --> 00:27:17,760
static lifetime requirements of tried

00:27:15,279 --> 00:27:19,520
objects or type parameters

00:27:17,760 --> 00:27:20,799
in all of these cases the compiler tries

00:27:19,520 --> 00:27:22,880
to interpret

00:27:20,799 --> 00:27:25,120
what the user is trying to accomplish

00:27:22,880 --> 00:27:26,080
and gives as short an explanation as it

00:27:25,120 --> 00:27:29,039
can

00:27:26,080 --> 00:27:30,399
to get them underway you can consider

00:27:29,039 --> 00:27:32,840
the objective to

00:27:30,399 --> 00:27:35,919
minimize how much people have to ask for

00:27:32,840 --> 00:27:38,080
help i showed that my co-workers asked

00:27:35,919 --> 00:27:40,720
me for help for a given problem

00:27:38,080 --> 00:27:42,320
once and then i run and encode the

00:27:40,720 --> 00:27:43,840
explanation in the compiler

00:27:42,320 --> 00:27:45,440
if the compiler has been helpful to you

00:27:43,840 --> 00:27:49,039
in the past feel free to ask

00:27:45,440 --> 00:27:50,080
to thank my coworkers but once you have

00:27:49,039 --> 00:27:52,399
gone this direction

00:27:50,080 --> 00:27:54,159
of providing suggestions you can go wild

00:27:52,399 --> 00:27:55,200
i mean if you're already parsing a meta

00:27:54,159 --> 00:27:58,159
language

00:27:55,200 --> 00:27:59,679
let's call it plus plus plus why not go

00:27:58,159 --> 00:28:01,440
all the way in

00:27:59,679 --> 00:28:03,919
you can start parsing things from other

00:28:01,440 --> 00:28:06,000
languages and start translating them

00:28:03,919 --> 00:28:07,200
you don't have to go too deep down that

00:28:06,000 --> 00:28:08,960
route

00:28:07,200 --> 00:28:11,520
just enough to catch people that have a

00:28:08,960 --> 00:28:13,679
momentary mental lapse

00:28:11,520 --> 00:28:14,720
i'm also convinced that this approach

00:28:13,679 --> 00:28:18,080
has an extra benefit

00:28:14,720 --> 00:28:21,840
that is incredibly important it lets

00:28:18,080 --> 00:28:24,000
rust remain simple it reduces how many

00:28:21,840 --> 00:28:25,679
rules people need to keep in mind and

00:28:24,000 --> 00:28:28,480
makes the behavior of the code

00:28:25,679 --> 00:28:30,640
directly related to the code itself

00:28:28,480 --> 00:28:33,840
there is no need for advanced behavior

00:28:30,640 --> 00:28:35,679
in the compiler that decides whether to

00:28:33,840 --> 00:28:36,640
use static or dynamic dispatch on a

00:28:35,679 --> 00:28:38,960
method call

00:28:36,640 --> 00:28:40,640
depending on some internal heuristics

00:28:38,960 --> 00:28:42,559
the behavior is laid bare

00:28:40,640 --> 00:28:44,799
in the code and its performance

00:28:42,559 --> 00:28:46,320
characteristics will not change from

00:28:44,799 --> 00:28:48,799
from under you

00:28:46,320 --> 00:28:51,440
due to some unrelated code changes

00:28:48,799 --> 00:28:54,399
crossing some threshold

00:28:51,440 --> 00:28:56,000
i also believe strongly that dedicating

00:28:54,399 --> 00:28:58,320
manpower to improving the user

00:28:56,000 --> 00:29:01,520
experience of developer tools is

00:28:58,320 --> 00:29:02,640
of paramount importance it is quite

00:29:01,520 --> 00:29:04,720
amazing to me

00:29:02,640 --> 00:29:06,960
what we have come to expect from our

00:29:04,720 --> 00:29:10,080
tools user experience

00:29:06,960 --> 00:29:12,000
it seems like our entire industry has

00:29:10,080 --> 00:29:14,480
had stockholm syndrome for so long

00:29:12,000 --> 00:29:15,120
that we don't even notice anymore i want

00:29:14,480 --> 00:29:18,480
to ask

00:29:15,120 --> 00:29:21,200
of all of you today two things

00:29:18,480 --> 00:29:24,240
demand better from your tools and be

00:29:21,200 --> 00:29:27,840
mindful of your users

00:29:24,240 --> 00:29:27,840

YouTube URL: https://www.youtube.com/watch?v=l0OazNIVcFs


