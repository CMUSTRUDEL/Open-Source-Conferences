Title: Aloha Ruby Conf 2012 Ten Things You Didn't Know You Could Do by James Edward Gray II
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGfq/
Captions: 
	00:00:14,730 --> 00:00:21,790
are we ready to get started alright this

00:00:19,180 --> 00:00:24,430
is the most ridiculously Hawaiian shirt

00:00:21,790 --> 00:00:26,500
I own it seemed kind of fitting for

00:00:24,430 --> 00:00:33,010
giving a talk in Hawaii right

00:00:26,500 --> 00:00:36,370
how about it in Jamaica but I saw it in

00:00:33,010 --> 00:00:41,440
a store after I got to fight the exact

00:00:36,370 --> 00:00:43,270
same pattern I think it counts just for

00:00:41,440 --> 00:00:46,239
those who don't know me I'm James / gray

00:00:43,270 --> 00:00:49,750
ii i'm the guy that says awesome all the

00:00:46,239 --> 00:00:52,540
time on the ruby rooms podcast so if you

00:00:49,750 --> 00:00:54,160
listen to that it's my first time in

00:00:52,540 --> 00:00:55,840
hawaii it's pretty great

00:00:54,160 --> 00:00:58,000
right before giving my talk i was

00:00:55,840 --> 00:01:01,329
sitting outside near the beach watching

00:00:58,000 --> 00:01:05,649
this her that's pretty awesome how come

00:01:01,329 --> 00:01:08,550
we're not out there so this is actually

00:01:05,649 --> 00:01:11,680
the second talk i dating kind of a

00:01:08,550 --> 00:01:13,360
related set a real top this year i did

00:01:11,680 --> 00:01:16,180
10 things you didn't know rails could do

00:01:13,360 --> 00:01:18,940
and if you saw that talk live or online

00:01:16,180 --> 00:01:21,369
you know i didn't actually do plan i did

00:01:18,940 --> 00:01:24,400
forty two things you didn't know rails

00:01:21,369 --> 00:01:28,000
to do in hindsight that was a really

00:01:24,400 --> 00:01:30,670
stupid mistake right because i still had

00:01:28,000 --> 00:01:32,290
this time together and i'm assuming you

00:01:30,670 --> 00:01:34,689
guys are not gonna let me get away with

00:01:32,290 --> 00:01:37,330
10 things you didn't know ruby can do

00:01:34,689 --> 00:01:40,090
great so i guess we have to go to at

00:01:37,330 --> 00:01:43,299
least 42 is that the minimum you'll

00:01:40,090 --> 00:01:46,810
accept i'm assuming but we didn't come

00:01:43,299 --> 00:01:48,840
all this way and you know here we are in

00:01:46,810 --> 00:01:51,040
paradise and i want to make sure

00:01:48,840 --> 00:01:53,020
everybody leaves this room learning

00:01:51,040 --> 00:01:56,310
something new so what do you say we up

00:01:53,020 --> 00:01:56,310
the ante a little bit

00:01:56,960 --> 00:02:03,150
you think we'll find out by the way if

00:02:01,650 --> 00:02:05,460
you're one of those people who takes

00:02:03,150 --> 00:02:09,660
notes you're about to have a very

00:02:05,460 --> 00:02:13,200
stressful 40 minutes so you might just

00:02:09,660 --> 00:02:15,959
want to let this one go I would I'll

00:02:13,200 --> 00:02:19,410
throw my slides online you know do it

00:02:15,959 --> 00:02:21,540
that way let go everything I'm going to

00:02:19,410 --> 00:02:23,910
show you has been tested with this Ruby

00:02:21,540 --> 00:02:25,800
so it works on this Ruby most things

00:02:23,910 --> 00:02:28,709
will work on most rubies but there are

00:02:25,800 --> 00:02:31,110
some exceptions all right I'm gonna

00:02:28,709 --> 00:02:34,560
break these down into come categories so

00:02:31,110 --> 00:02:36,600
let's start with compiler drinks did you

00:02:34,560 --> 00:02:39,150
know that this is actually executable

00:02:36,600 --> 00:02:41,790
Ruby code there really is

00:02:39,150 --> 00:02:43,709
if you pass Ruby the dash X which they

00:02:41,790 --> 00:02:46,260
will ignore everything finished a bang

00:02:43,709 --> 00:02:48,390
line and by default Ruby will already

00:02:46,260 --> 00:02:49,800
ignore everything under underscore

00:02:48,390 --> 00:02:52,350
underscore and underscore underscore

00:02:49,800 --> 00:02:55,920
which means I'll jump goes away and it

00:02:52,350 --> 00:02:57,840
will actually run your code that end

00:02:55,920 --> 00:02:59,580
token is a special view and its own

00:02:57,840 --> 00:03:02,130
right when it's in your program

00:02:59,580 --> 00:03:04,440
Ruby opens an i/o object on points about

00:03:02,130 --> 00:03:06,630
whatever comes after that this is the

00:03:04,440 --> 00:03:09,060
special IO object right there called

00:03:06,630 --> 00:03:13,709
data and then you can read or do any

00:03:09,060 --> 00:03:15,269
kind of normal operations with it you

00:03:13,709 --> 00:03:17,549
can even use that to do dirty tricks

00:03:15,269 --> 00:03:19,170
right since any i/o operation so you can

00:03:17,549 --> 00:03:20,970
rewind back to the beginning of the file

00:03:19,170 --> 00:03:23,459
then you'd be looking at your code

00:03:20,970 --> 00:03:26,670
instead of the data all right so you can

00:03:23,459 --> 00:03:28,980
cheat to make a client better I actually

00:03:26,670 --> 00:03:31,709
use this trick quite a bit with the data

00:03:28,980 --> 00:03:34,410
thing and that's you can grab a lock on

00:03:31,709 --> 00:03:36,510
data which makes your program exclusive

00:03:34,410 --> 00:03:40,230
only one copy of it's running in fact

00:03:36,510 --> 00:03:41,910
right I just remember to leave that in

00:03:40,230 --> 00:03:43,709
token in there because if it

00:03:41,910 --> 00:03:46,799
accidentally gets treated your program

00:03:43,709 --> 00:03:48,690
won't run correctly so you might want to

00:03:46,799 --> 00:03:51,239
put a note there about why it needs to

00:03:48,690 --> 00:03:53,100
stay there you can see here that it's

00:03:51,239 --> 00:03:56,750
exclusive and I can't start a second

00:03:53,100 --> 00:03:59,700
copy of it until I show the first one

00:03:56,750 --> 00:04:01,210
another trick I've used once in a while

00:03:59,700 --> 00:04:04,300
which probably isn't as good of an

00:04:01,210 --> 00:04:06,520
is that you can store data down there

00:04:04,300 --> 00:04:08,920
since Ruby opens into the right position

00:04:06,520 --> 00:04:11,080
you know where to truncate the file to

00:04:08,920 --> 00:04:13,240
to cut off the end of it and then you

00:04:11,080 --> 00:04:14,770
can write the data back out the cool

00:04:13,240 --> 00:04:17,260
thing about this trick is that the data

00:04:14,770 --> 00:04:18,850
travels around with your code which is

00:04:17,260 --> 00:04:25,390
kind of a neat trick and scripting

00:04:18,850 --> 00:04:26,890
sometimes it's fun trick has gotten

00:04:25,390 --> 00:04:29,680
pretty good about telling you what's

00:04:26,890 --> 00:04:32,020
going on you can ask for the headset

00:04:29,680 --> 00:04:34,150
abstract syntax tree but it constructs

00:04:32,020 --> 00:04:37,630
so if you wanted to see if it read

00:04:34,150 --> 00:04:39,820
something as a block or a hash baby it

00:04:37,630 --> 00:04:41,290
here's the actual method color but it's

00:04:39,820 --> 00:04:43,690
hard for me to tell not knowing what

00:04:41,290 --> 00:04:45,580
these are nodes are if it's treating

00:04:43,690 --> 00:04:47,320
that as a block or not but there's

00:04:45,580 --> 00:04:50,050
another option you can ask for the purse

00:04:47,320 --> 00:04:51,640
tree with comments and then it has these

00:04:50,050 --> 00:04:53,350
really helpful comments in here and it

00:04:51,640 --> 00:04:55,900
shows you that this node means that it

00:04:53,350 --> 00:04:57,370
was a method call with a block so it

00:04:55,900 --> 00:04:59,500
actually explains it to you

00:04:57,370 --> 00:05:01,000
it's kind of nice you can also ask for

00:04:59,500 --> 00:05:04,780
the instruction sequence that the

00:05:01,000 --> 00:05:06,400
virtual machine reads and if you're

00:05:04,780 --> 00:05:08,710
really sadistic and want to see how

00:05:06,400 --> 00:05:11,860
personal I think you can ask Ruby to I

00:05:08,710 --> 00:05:13,780
show you its parsing through your code

00:05:11,860 --> 00:05:15,340
it's probably only useful if you're

00:05:13,780 --> 00:05:18,490
around working with Ruby itself but

00:05:15,340 --> 00:05:20,700
still kind of neat this is a magic

00:05:18,490 --> 00:05:24,190
constant that if you define it to a hash

00:05:20,700 --> 00:05:26,680
before you require some code Ruby will

00:05:24,190 --> 00:05:29,440
stick all the loaded code in that cache

00:05:26,680 --> 00:05:31,630
so the key is the file name and then the

00:05:29,440 --> 00:05:32,920
values are the lines of code voting so

00:05:31,630 --> 00:05:35,530
if you want to do any kind of code

00:05:32,920 --> 00:05:38,580
analysis or something like that you can

00:05:35,530 --> 00:05:41,770
get at the actual code that Ruby women

00:05:38,580 --> 00:05:44,530
and everybody will tell you Ruby doesn't

00:05:41,770 --> 00:05:46,270
include tail call optimization so we

00:05:44,530 --> 00:05:48,490
can't run code like this it just blows

00:05:46,270 --> 00:05:50,530
the stack I even though it could be tail

00:05:48,490 --> 00:05:52,210
call optimized it's not true that really

00:05:50,530 --> 00:05:56,320
doesn't include it it's just off by

00:05:52,210 --> 00:05:58,090
default so if you turn it on you'll also

00:05:56,320 --> 00:05:59,200
want to turn off tracing instructions

00:05:58,090 --> 00:06:02,080
because that's what tail call

00:05:59,200 --> 00:06:04,120
optimization interferes with and that's

00:06:02,080 --> 00:06:05,380
why it's off by default and then you

00:06:04,120 --> 00:06:07,270
need to make sure your code gets

00:06:05,380 --> 00:06:09,900
compiled after you've changed those

00:06:07,270 --> 00:06:12,480
options so here I took tit in

00:06:09,900 --> 00:06:14,610
I'll make that happen and then you can

00:06:12,480 --> 00:06:16,320
get tail call optimization so it runs

00:06:14,610 --> 00:06:19,920
this code actually quite quickly and it

00:06:16,320 --> 00:06:22,710
spits out a very large number okay let's

00:06:19,920 --> 00:06:24,960
talk about syntax I love super it's my

00:06:22,710 --> 00:06:26,940
favorite keyword in Ruby there's a

00:06:24,960 --> 00:06:28,950
really simple example to use it to pass

00:06:26,940 --> 00:06:31,320
up to the parent class whatever you want

00:06:28,950 --> 00:06:34,650
so even though I got a B and C I'm only

00:06:31,320 --> 00:06:36,900
passing up am being if you leave

00:06:34,650 --> 00:06:39,150
everything off of super no parenthesis

00:06:36,900 --> 00:06:41,040
no arguments then everything gets past

00:06:39,150 --> 00:06:43,590
that right imagine we all know that it's

00:06:41,040 --> 00:06:47,790
kind of pretty common usage everything

00:06:43,590 --> 00:06:50,850
goes up including the book here's a got

00:06:47,790 --> 00:06:53,670
you though if you modify those values

00:06:50,850 --> 00:06:55,110
before you use that ver super now this

00:06:53,670 --> 00:06:57,600
first one is probably not surprising

00:06:55,110 --> 00:07:00,570
just calling some mutating methods but

00:06:57,600 --> 00:07:03,060
even if you reassigned a variable and

00:07:00,570 --> 00:07:06,240
then call a bear super all the

00:07:03,060 --> 00:07:07,770
modifications go up alright so you can

00:07:06,240 --> 00:07:10,350
actually modify them before you sign

00:07:07,770 --> 00:07:12,630
them up if use an empty set of

00:07:10,350 --> 00:07:14,010
parenthesis on super then you can

00:07:12,630 --> 00:07:16,400
purpose where you pass out and nothing

00:07:14,010 --> 00:07:19,020
no matter what you were giving and

00:07:16,400 --> 00:07:20,760
here's a trick if you need to get rid of

00:07:19,020 --> 00:07:23,250
the block like you were passed a block

00:07:20,760 --> 00:07:24,750
but you don't want to pass the block up

00:07:23,250 --> 00:07:27,000
to the parent class you can use this

00:07:24,750 --> 00:07:29,400
ampersand know so basically it's a pass

00:07:27,000 --> 00:07:32,370
an empty block a bunch of cool tricks

00:07:29,400 --> 00:07:33,810
with super there's another trick you can

00:07:32,370 --> 00:07:36,960
combine super with another awesome

00:07:33,810 --> 00:07:39,480
keyword and defined and Ruby will tell

00:07:36,960 --> 00:07:42,420
you if there is a parent class that if

00:07:39,480 --> 00:07:44,970
you can delegate to so you can see oh

00:07:42,420 --> 00:07:47,070
there is some method I'll use that or no

00:07:44,970 --> 00:07:48,450
I need to handle it myself it's works

00:07:47,070 --> 00:07:53,970
really good with that make sense

00:07:48,450 --> 00:07:56,610
obviously there's a new lambda syntax in

00:07:53,970 --> 00:07:58,710
Ruby 1-9 this arrow operator this is

00:07:56,610 --> 00:08:00,990
what a normal bear one looks like this

00:07:58,710 --> 00:08:03,180
is the full version with people's

00:08:00,990 --> 00:08:04,560
arguments and blocks and all that but

00:08:03,180 --> 00:08:07,800
gotcha here is to remember that the

00:08:04,560 --> 00:08:08,960
arguments moved outside and walk I kind

00:08:07,800 --> 00:08:14,120
of different from normal

00:08:08,960 --> 00:08:17,000
be syntax if you don't like that you can

00:08:14,120 --> 00:08:19,069
just turn on Ruby's utf-8 source code

00:08:17,000 --> 00:08:20,930
mode and then you can use utf-8

00:08:19,069 --> 00:08:24,110
characters and just redefine lambda is

00:08:20,930 --> 00:08:26,150
the actual symbol and so then you can

00:08:24,110 --> 00:08:29,979
call the actual symbol of lambda

00:08:26,150 --> 00:08:29,979
come on it's pretty cool

00:08:30,710 --> 00:08:36,080
watch turnout take books right this is

00:08:33,830 --> 00:08:37,849
mostly useful in meta programming when

00:08:36,080 --> 00:08:39,500
you need to define methods

00:08:37,849 --> 00:08:41,300
programmatically or something like that

00:08:39,500 --> 00:08:42,589
but you have blocks take bullets which

00:08:41,300 --> 00:08:44,630
sometimes hard to get your head around

00:08:42,589 --> 00:08:49,430
but we're gonna finding that this is

00:08:44,630 --> 00:08:52,459
pretty handy there's a new call syntax

00:08:49,430 --> 00:08:54,110
if you just do that period and then your

00:08:52,459 --> 00:08:55,310
argument list after that these are all

00:08:54,110 --> 00:08:58,040
empty but you can actually pass

00:08:55,310 --> 00:09:00,830
arguments it will call the call method

00:08:58,040 --> 00:09:03,200
so that's useful for lambdas and method

00:09:00,830 --> 00:09:04,940
references but any object you define as

00:09:03,200 --> 00:09:10,690
long as it has a call method this syntax

00:09:04,940 --> 00:09:13,490
works and you probably know about

00:09:10,690 --> 00:09:15,410
assemble to product I've mentioned a

00:09:13,490 --> 00:09:16,640
couple times even at the conference but

00:09:15,410 --> 00:09:19,250
it's worth noting that it takes

00:09:16,640 --> 00:09:21,350
arguments the first one is the receiver

00:09:19,250 --> 00:09:24,800
of the call but anything after that is

00:09:21,350 --> 00:09:26,750
part of the normal argument list so the

00:09:24,800 --> 00:09:29,870
proctor that builds can actually take

00:09:26,750 --> 00:09:31,520
arguments I mentioned this one in Ben's

00:09:29,870 --> 00:09:34,010
talk yesterday but you can drop the

00:09:31,520 --> 00:09:35,630
ampere stand with inject because inject

00:09:34,010 --> 00:09:37,160
is now smart enough if you pass it

00:09:35,630 --> 00:09:39,020
assemble it assumes that's the method

00:09:37,160 --> 00:09:41,270
you want to call and it use it back to

00:09:39,020 --> 00:09:44,839
build the block so that's a little bit

00:09:41,270 --> 00:09:46,760
of shortcut back case statements are

00:09:44,839 --> 00:09:48,500
pretty cool because we can use anything

00:09:46,760 --> 00:09:50,959
that responds to the three cool operator

00:09:48,500 --> 00:09:54,230
one cool thing that does that is range

00:09:50,959 --> 00:09:56,120
right so you can use it to swap things

00:09:54,230 --> 00:09:58,600
into categories just by defining some

00:09:56,120 --> 00:10:01,329
ranges

00:09:58,600 --> 00:10:03,250
Calabrese if you're going to do that one

00:10:01,329 --> 00:10:06,430
thing that works great with ranges is

00:10:03,250 --> 00:10:07,690
dates you can date new or give you

00:10:06,430 --> 00:10:09,850
basically in the beginning of time and

00:10:07,690 --> 00:10:12,250
date affinity basically the end of time

00:10:09,850 --> 00:10:13,870
so you can slot things and the date

00:10:12,250 --> 00:10:17,370
ranges to find out if your before or

00:10:13,870 --> 00:10:20,410
after something in the circle period

00:10:17,370 --> 00:10:22,810
another thing that got the 312 operator

00:10:20,410 --> 00:10:25,329
and Ruby 1:9 is proc objects or what

00:10:22,810 --> 00:10:28,180
lambda makes so you can now have like

00:10:25,329 --> 00:10:30,250
intelligent code running to do each of

00:10:28,180 --> 00:10:35,500
the comparisons which makes personal

00:10:30,250 --> 00:10:39,519
pretty crazy K stands there's the syntax

00:10:35,500 --> 00:10:41,470
that kind of s printf inspired idea it

00:10:39,519 --> 00:10:43,810
is actually there isn't a sprint F

00:10:41,470 --> 00:10:45,519
method in Ruby but I like using it this

00:10:43,810 --> 00:10:47,860
way where you just put the format string

00:10:45,519 --> 00:10:49,750
on the website contents on the right

00:10:47,860 --> 00:10:53,019
side and use that percent operator in

00:10:49,750 --> 00:10:56,259
the middle and then you can make this

00:10:53,019 --> 00:10:59,319
formatted output one cool option to look

00:10:56,259 --> 00:11:02,560
into if you use this as percent P it's a

00:10:59,319 --> 00:11:04,509
ruby on on that does inspect on whatever

00:11:02,560 --> 00:11:06,819
object you pass so you can get the

00:11:04,509 --> 00:11:10,420
actual room in your object and what it

00:11:06,819 --> 00:11:12,759
looks like this sucker I just showed you

00:11:10,420 --> 00:11:14,769
has a whole lot of options I'm using a

00:11:12,759 --> 00:11:16,389
ton of them right here I'll point some

00:11:14,769 --> 00:11:19,240
out the coolest one is that you can

00:11:16,389 --> 00:11:22,660
refer to things by name now so you can

00:11:19,240 --> 00:11:24,670
use names and then hash items and it'll

00:11:22,660 --> 00:11:27,759
refer to the objects by name and stowed

00:11:24,670 --> 00:11:29,980
position you can set decimal places on

00:11:27,759 --> 00:11:33,759
floating points you can give the fields

00:11:29,980 --> 00:11:36,040
sizes and they'll be padded out and you

00:11:33,759 --> 00:11:38,040
can left and right justify you can use

00:11:36,040 --> 00:11:41,230
all that to make some pretty cool output

00:11:38,040 --> 00:11:44,829
just using those simple format strings

00:11:41,230 --> 00:11:47,259
so it's worth looking at to you probably

00:11:44,829 --> 00:11:49,630
all know about here Docs but where you

00:11:47,259 --> 00:11:51,490
may not know is after a gear dock the

00:11:49,630 --> 00:11:54,230
rest of the line is just a normal line

00:11:51,490 --> 00:11:57,650
of Ruby so it could include any

00:11:54,230 --> 00:11:59,240
we can have including other ear docks so

00:11:57,650 --> 00:12:02,420
if you have to hear docks on the same

00:11:59,240 --> 00:12:05,030
lines and they just come in after the

00:12:02,420 --> 00:12:08,570
line and of order so you can have more

00:12:05,030 --> 00:12:10,580
than one and if they're bringing Ruby

00:12:08,570 --> 00:12:12,440
with warnings which this is the program

00:12:10,580 --> 00:12:15,500
that agreed to do that and it's usually

00:12:12,440 --> 00:12:17,560
a good idea then you'll get a warning if

00:12:15,500 --> 00:12:22,790
you try to access an instance variable

00:12:17,560 --> 00:12:25,670
before it's been assigned my favorite

00:12:22,790 --> 00:12:27,770
way to get around that is to switch the

00:12:25,670 --> 00:12:30,020
operator to the four equals operator

00:12:27,770 --> 00:12:32,150
because the sucker is really smart and

00:12:30,020 --> 00:12:34,700
it will do it define check before it

00:12:32,150 --> 00:12:37,810
does the assignment so it actually gods

00:12:34,700 --> 00:12:41,180
is the warning for you on purpose

00:12:37,810 --> 00:12:43,820
if you're interpolating values you can

00:12:41,180 --> 00:12:46,580
sometimes leave off the braces as long

00:12:43,820 --> 00:12:49,010
as your variable starts with some kind

00:12:46,580 --> 00:12:50,540
of signal so they're gonna be knows it's

00:12:49,010 --> 00:12:57,440
actually a variable and not a number

00:12:50,540 --> 00:12:59,840
sign you can read the braces off this

00:12:57,440 --> 00:13:02,870
side if using I need to remind would be

00:12:59,840 --> 00:13:04,760
1/9 you can use name groups in a regular

00:13:02,870 --> 00:13:07,010
expression so refer to them by name

00:13:04,760 --> 00:13:09,290
instead of position and if you use it

00:13:07,010 --> 00:13:12,530
this way then Ruby watch reset local

00:13:09,290 --> 00:13:14,480
variables for you to the same names as

00:13:12,530 --> 00:13:16,820
the groups you use your regular

00:13:14,480 --> 00:13:19,100
expression has to be on the website of

00:13:16,820 --> 00:13:21,080
the match operator and it has to be a

00:13:19,100 --> 00:13:22,790
literal writing X it cannot being a

00:13:21,080 --> 00:13:24,920
variable or anything like that

00:13:22,790 --> 00:13:26,870
these are hints Ruby they tell it you

00:13:24,920 --> 00:13:32,840
don't mind if it says some variables for

00:13:26,870 --> 00:13:35,030
you tries to honor conventions in a lot

00:13:32,840 --> 00:13:37,940
of places this particular code is an

00:13:35,030 --> 00:13:40,550
error because I've reused that same

00:13:37,940 --> 00:13:42,080
variable name twice I'm trying to just

00:13:40,550 --> 00:13:44,570
ignore these now used and I pick

00:13:42,080 --> 00:13:47,210
something the convention for ignoring a

00:13:44,570 --> 00:13:49,610
variable is the underscore and

00:13:47,210 --> 00:13:51,620
if I use that Ruby will actually let it

00:13:49,610 --> 00:13:53,240
go through so even though I'd double

00:13:51,620 --> 00:13:56,390
assign the variable it doesn't care you

00:13:53,240 --> 00:13:59,180
know what's it happy let's look at some

00:13:56,390 --> 00:14:01,070
data structures uh this wouldn't make

00:13:59,180 --> 00:14:03,170
sense when you think about it but it's

00:14:01,070 --> 00:14:05,960
probably worth talking about for a

00:14:03,170 --> 00:14:07,640
second objects just have references to

00:14:05,960 --> 00:14:09,530
other objects so of course one of those

00:14:07,640 --> 00:14:11,900
references could be the same object

00:14:09,530 --> 00:14:14,210
again right so you can have nested

00:14:11,900 --> 00:14:18,220
structures in this case to build like a

00:14:14,210 --> 00:14:20,450
ring it just keeps going back around

00:14:18,220 --> 00:14:23,240
another way to do the same thing would

00:14:20,450 --> 00:14:25,670
be to just use movie 1/9 cycle operators

00:14:23,240 --> 00:14:27,380
which will return in innumerable the

00:14:25,670 --> 00:14:29,390
iterates already seems like over and

00:14:27,380 --> 00:14:31,280
over again be careful how you iterate

00:14:29,390 --> 00:14:34,340
with it because it literally will go on

00:14:31,280 --> 00:14:36,320
forever if you call each kind so can you

00:14:34,340 --> 00:14:38,290
be careful they take some say kind of

00:14:36,320 --> 00:14:41,770
hope right out of it

00:14:38,290 --> 00:14:44,990
and this is a cool trick too you can use

00:14:41,770 --> 00:14:47,270
associative arrays and Ruby arrays of

00:14:44,990 --> 00:14:49,040
arrays array the inner eraser and two

00:14:47,270 --> 00:14:51,410
elements and then you can get that those

00:14:49,040 --> 00:14:53,630
inner arrays using associate or search

00:14:51,410 --> 00:14:55,310
the methods so research get someone on

00:14:53,630 --> 00:14:57,830
the left in are so she gets one on the

00:14:55,310 --> 00:14:59,630
right and you get the full pair back so

00:14:57,830 --> 00:15:01,370
it's kind of like a hash except you can

00:14:59,630 --> 00:15:04,280
control the order I had since you can

00:15:01,370 --> 00:15:05,690
just select the array so well handy

00:15:04,280 --> 00:15:07,580
there's a couple other tricks you can do

00:15:05,690 --> 00:15:10,070
with this for example you could choose

00:15:07,580 --> 00:15:11,900
to put more than two items in there you

00:15:10,070 --> 00:15:13,660
can all make pretty easily on the first

00:15:11,900 --> 00:15:16,880
two but you still get the others back

00:15:13,660 --> 00:15:22,130
right so you can hide some extra data

00:15:16,880 --> 00:15:23,660
and another good use for them is they're

00:15:22,130 --> 00:15:26,000
automatically versioned

00:15:23,660 --> 00:15:28,790
since associate our research will find

00:15:26,000 --> 00:15:30,620
the first match if you unship something

00:15:28,790 --> 00:15:33,110
on to the beginning you basically change

00:15:30,620 --> 00:15:35,270
that fumed and the older one will be

00:15:33,110 --> 00:15:37,220
ignored but thing you could get it back

00:15:35,270 --> 00:15:38,810
later if you needed to by finding the

00:15:37,220 --> 00:15:40,910
one that you are giving and then looking

00:15:38,810 --> 00:15:44,560
after that so you can kind of use this

00:15:40,910 --> 00:15:44,560
as a version cache

00:15:45,500 --> 00:15:52,010
Ruby's hash is also fine with all kinds

00:15:49,310 --> 00:15:53,180
of tricks one that I love to exploit is

00:15:52,010 --> 00:15:55,900
the fact that the hash

00:15:53,180 --> 00:15:58,430
is basically a memoization algorithm

00:15:55,900 --> 00:16:01,160
because it calls it anytime the values

00:15:58,430 --> 00:16:02,510
not there if the value gets set while

00:16:01,160 --> 00:16:04,610
the block runs then you're just

00:16:02,510 --> 00:16:06,620
memorizing data and most of that's

00:16:04,610 --> 00:16:09,230
happening in C so it's lightning quick

00:16:06,620 --> 00:16:13,820
right a really handy way to do

00:16:09,230 --> 00:16:16,130
memorization and Ruby's hash you you're

00:16:13,820 --> 00:16:18,380
set that default product but you can get

00:16:16,130 --> 00:16:21,260
access to it and pass it down to say

00:16:18,380 --> 00:16:23,180
other objects like nested washes and

00:16:21,260 --> 00:16:25,250
then you can build this deep data

00:16:23,180 --> 00:16:28,040
structure and Ruby would create all the

00:16:25,250 --> 00:16:29,480
intervening rubbles for you right so you

00:16:28,040 --> 00:16:34,400
can get this kind of either River

00:16:29,480 --> 00:16:36,680
vacation that pearl has deep Copeland

00:16:34,400 --> 00:16:40,580
kind of cool blog post about how you can

00:16:36,680 --> 00:16:42,950
use lambdas and hashes and create kind

00:16:40,580 --> 00:16:44,240
of your own dispatch table and that

00:16:42,950 --> 00:16:46,250
usually gets combined with the case

00:16:44,240 --> 00:16:49,250
statement to decide what the execute and

00:16:46,250 --> 00:16:53,060
then you can basically branch on

00:16:49,250 --> 00:16:56,900
different code obviously I used to here

00:16:53,060 --> 00:16:59,900
to make a trivial rpm County reader now

00:16:56,900 --> 00:17:01,940
I have to go back and face Josh lesser

00:16:59,900 --> 00:17:04,010
next week and if I stop it that's like

00:17:01,940 --> 00:17:06,440
he would yell at me so this is how you

00:17:04,010 --> 00:17:08,810
do the same thing with objects by new

00:17:06,440 --> 00:17:10,310
red ruby do the dispatching for you just

00:17:08,810 --> 00:17:12,410
to find a bunch of methods and then call

00:17:10,310 --> 00:17:17,180
the back of anybody dispatches based on

00:17:12,410 --> 00:17:20,030
a same output if you're only gonna learn

00:17:17,180 --> 00:17:21,830
one method on Ruby's hatch make it fetch

00:17:20,030 --> 00:17:23,900
inspection is awesome

00:17:21,830 --> 00:17:26,510
you can fetch values just like you do

00:17:23,900 --> 00:17:30,140
with brackets but fetch gives you

00:17:26,510 --> 00:17:33,740
multiple ways to set default values and

00:17:30,140 --> 00:17:35,150
the block is lazy it won't be run if it

00:17:33,740 --> 00:17:37,610
doesn't need to be because the value is

00:17:35,150 --> 00:17:39,860
already in hash so it's good for hiding

00:17:37,610 --> 00:17:41,420
expensive operations and if you try to

00:17:39,860 --> 00:17:42,710
fetch in value it's not there you're

00:17:41,420 --> 00:17:45,440
actually giving an error

00:17:42,710 --> 00:17:47,090
which makes it much easier to find bugs

00:17:45,440 --> 00:17:48,520
near programs because you don't

00:17:47,090 --> 00:17:52,580
introduce them know that

00:17:48,520 --> 00:17:54,260
mother please fetch is awesome

00:17:52,580 --> 00:17:56,330
you probably know you can index into a

00:17:54,260 --> 00:17:58,820
string with a couple of offsets and get

00:17:56,330 --> 00:18:00,590
the part that matches you can also index

00:17:58,820 --> 00:18:03,230
into a string with a regular expression

00:18:00,590 --> 00:18:04,730
and get the part that matches I use this

00:18:03,230 --> 00:18:08,600
more often than the match operator

00:18:04,730 --> 00:18:11,740
actually and you can even ask for a

00:18:08,600 --> 00:18:16,310
certain ordered group or a named group

00:18:11,740 --> 00:18:19,490
and get back back taking that one crazy

00:18:16,310 --> 00:18:21,110
step further you can actually assign to

00:18:19,490 --> 00:18:23,450
the part of the string that matches that

00:18:21,110 --> 00:18:25,520
regular expression effectively replacing

00:18:23,450 --> 00:18:28,310
it or you convert the sign to an

00:18:25,520 --> 00:18:30,350
individual group in that match regular

00:18:28,310 --> 00:18:33,470
expression forgetting or placing that

00:18:30,350 --> 00:18:37,730
group I don't use that but it's kind of

00:18:33,470 --> 00:18:39,230
wild you get the leftmost match by

00:18:37,730 --> 00:18:41,660
default I imagine most of us know that

00:18:39,230 --> 00:18:45,140
but if you want the rightmost match our

00:18:41,660 --> 00:18:46,940
index will take a regular expression so

00:18:45,140 --> 00:18:48,950
you can just pass a regular expression

00:18:46,940 --> 00:18:50,990
into there be careful how you write your

00:18:48,950 --> 00:18:52,910
regular expression though because as you

00:18:50,990 --> 00:18:55,520
see the first one matches just the two

00:18:52,910 --> 00:18:57,380
at the end because that's one or more

00:18:55,520 --> 00:18:59,210
digits so if you really wanted the whole

00:18:57,380 --> 00:19:01,010
last number you've got to use some

00:18:59,210 --> 00:19:05,210
anchors or something like I did in the

00:19:01,010 --> 00:19:08,000
second one if you need to chew through

00:19:05,210 --> 00:19:10,910
some binary data you can use the unpack

00:19:08,000 --> 00:19:13,790
method you passing these format strings

00:19:10,910 --> 00:19:16,460
this one means skip 16 bytes and then

00:19:13,790 --> 00:19:19,040
pull to network order integers out of

00:19:16,460 --> 00:19:21,080
there that's where p.m. G's hide the rip

00:19:19,040 --> 00:19:22,580
in height so you can use that to peek

00:19:21,080 --> 00:19:25,670
inside and see how big the image

00:19:22,580 --> 00:19:27,710
actually is there's another method on a

00:19:25,670 --> 00:19:30,470
rake compact which does the opposite

00:19:27,710 --> 00:19:31,450
operation it backs binary data up for

00:19:30,470 --> 00:19:36,980
you

00:19:31,450 --> 00:19:38,750
and iterators it is one of the great

00:19:36,980 --> 00:19:40,970
iterators in Ruby because the hard thing

00:19:38,750 --> 00:19:43,070
to do with Ruby's iterators is to go

00:19:40,970 --> 00:19:44,420
through two collections at once since

00:19:43,070 --> 00:19:46,040
their internal iterators

00:19:44,420 --> 00:19:47,450
zip solves that problem you can go

00:19:46,040 --> 00:19:51,130
through any number of collections you

00:19:47,450 --> 00:19:51,130
want to it once so it's handy

00:19:52,160 --> 00:19:56,990
partition will ask a yes or no question

00:19:54,860 --> 00:19:59,120
of every item that's what the lock does

00:19:56,990 --> 00:20:01,250
and divide them into two groups

00:19:59,120 --> 00:20:03,890
places that were yes some places that

00:20:01,250 --> 00:20:08,080
were no so you can use that to you that

00:20:03,890 --> 00:20:10,460
split out groups there's a new one nine

00:20:08,080 --> 00:20:13,700
kind of partition like method called

00:20:10,460 --> 00:20:15,740
chunk it asks any question it doesn't

00:20:13,700 --> 00:20:18,020
have to be yes or no and as long as

00:20:15,740 --> 00:20:19,940
adjacent items in the list keep

00:20:18,020 --> 00:20:22,280
returning the same answer and they get

00:20:19,940 --> 00:20:23,270
grouped together which is kind of hard

00:20:22,280 --> 00:20:25,250
to wrap your head around in the

00:20:23,270 --> 00:20:27,980
beginning but in this case I've used it

00:20:25,250 --> 00:20:30,140
to separate out chapters right so as

00:20:27,980 --> 00:20:32,240
long as there's a leading one and it's

00:20:30,140 --> 00:20:35,630
chapter one and when it's leading to its

00:20:32,240 --> 00:20:38,870
chapter two black map is another

00:20:35,630 --> 00:20:42,140
iterator I'm quickly gaining of in Ruby

00:20:38,870 --> 00:20:44,059
one nine and if you have arrays as your

00:20:42,140 --> 00:20:46,400
values it will concatenate all those

00:20:44,059 --> 00:20:48,860
together so you only get one or a back

00:20:46,400 --> 00:20:50,540
at the end that's the combining two

00:20:48,860 --> 00:20:52,460
items so you don't have two inner arrays

00:20:50,540 --> 00:20:57,410
in there it's basically matte plus

00:20:52,460 --> 00:21:00,230
flatten another great new iterator is

00:20:57,410 --> 00:21:03,290
each with object a lot of people use

00:21:00,230 --> 00:21:05,150
inject where they have to purposely

00:21:03,290 --> 00:21:07,400
return the right object that they're

00:21:05,150 --> 00:21:09,170
trying to get forward that's exactly

00:21:07,400 --> 00:21:11,540
what each with object does it will

00:21:09,170 --> 00:21:13,670
ignore the return value whatever it is

00:21:11,540 --> 00:21:18,410
and just keep carrying that object

00:21:13,670 --> 00:21:21,200
forward for you so here's for iterators

00:21:18,410 --> 00:21:23,420
that allow you to take items off the

00:21:21,200 --> 00:21:25,490
front of a list skip items at the front

00:21:23,420 --> 00:21:27,710
of the list or do the same thing using

00:21:25,490 --> 00:21:29,809
blocks to make the decision about where

00:21:27,710 --> 00:21:32,390
you start and stop so those are pretty

00:21:29,809 --> 00:21:36,340
handy for just grabbing some items off

00:21:32,390 --> 00:21:38,929
the front of the list or ignoring a few

00:21:36,340 --> 00:21:41,090
the I already mentioned that cycle

00:21:38,929 --> 00:21:42,950
returns an enumerator if you want to

00:21:41,090 --> 00:21:45,350
walk through that enumerator manually

00:21:42,950 --> 00:21:46,060
you can just call next to keep getting

00:21:45,350 --> 00:21:48,920
the next

00:21:46,060 --> 00:21:52,700
so you can actually just step through

00:21:48,920 --> 00:21:55,070
manually a cool feature of this is that

00:21:52,700 --> 00:21:57,740
next is gonna return an error when you

00:21:55,070 --> 00:22:00,800
run out called stock iteration and loop

00:21:57,740 --> 00:22:03,620
has been changed in Ruby 1 9 to rescue

00:22:00,800 --> 00:22:06,200
stop iteration and break out of the loop

00:22:03,620 --> 00:22:08,570
so you can just call next over and over

00:22:06,200 --> 00:22:10,190
again and local loop will automatically

00:22:08,570 --> 00:22:15,200
do the right thing at the end of the

00:22:10,190 --> 00:22:17,030
list another advantage of enumerables

00:22:15,200 --> 00:22:19,790
most of Ruby's iterators have now been

00:22:17,030 --> 00:22:22,520
enhanced to return the sorry enumerators

00:22:19,790 --> 00:22:24,860
not enumerables enumerators when they're

00:22:22,520 --> 00:22:26,750
called without a block and that means

00:22:24,860 --> 00:22:28,280
you can change iterators together so we

00:22:26,750 --> 00:22:30,140
divide them into chunks of three and

00:22:28,280 --> 00:22:33,620
then map those it's like those are

00:22:30,140 --> 00:22:35,570
whatever once you've changed raters like

00:22:33,620 --> 00:22:37,700
we change methods so here I'm using the

00:22:35,570 --> 00:22:40,340
same trick calling it with object

00:22:37,700 --> 00:22:43,130
without a block so I get an enumerator

00:22:40,340 --> 00:22:45,980
and then enumerator has a few iterators

00:22:43,130 --> 00:22:48,110
that are just for it like this with

00:22:45,980 --> 00:22:50,960
index so we always have each with index

00:22:48,110 --> 00:22:52,940
and people wanted map with index but now

00:22:50,960 --> 00:22:55,310
you can just put with index on any

00:22:52,940 --> 00:22:57,590
enumerator so you can have an objective

00:22:55,310 --> 00:22:59,600
index or whatever you want there's also

00:22:57,590 --> 00:23:05,210
a wick object which works like either

00:22:59,600 --> 00:23:11,540
age without okay we're about halfway

00:23:05,210 --> 00:23:13,880
there it's still with me so why do I do

00:23:11,540 --> 00:23:16,670
this I don't know they seem like a good

00:23:13,880 --> 00:23:19,250
idea in the beginning let's see I'm

00:23:16,670 --> 00:23:21,650
trying to give me your ideas right good

00:23:19,250 --> 00:23:24,560
ideas weird ideas bad ideas I don't

00:23:21,650 --> 00:23:26,870
really care just ideas right sometimes

00:23:24,560 --> 00:23:29,210
even the bad ideas are cool jumping off

00:23:26,870 --> 00:23:33,080
points that eventually lead to better

00:23:29,210 --> 00:23:35,150
ideas I don't that's why anything or

00:23:33,080 --> 00:23:36,560
something like that but we don't have

00:23:35,150 --> 00:23:39,920
time to talk about this we have more

00:23:36,560 --> 00:23:41,570
items together I see someone that's like

00:23:39,920 --> 00:23:45,440
it's mine all right

00:23:41,570 --> 00:23:47,420
Cory Ruby I have two Ruby itself you can

00:23:45,440 --> 00:23:50,270
programmatically and construct classes

00:23:47,420 --> 00:23:53,240
in Ruby and you can set a parent class

00:23:50,270 --> 00:23:54,680
and the reason to do this is that block

00:23:53,240 --> 00:23:57,830
is a closure so you

00:23:54,680 --> 00:23:59,960
access to the local variables so you can

00:23:57,830 --> 00:24:03,260
programmatically decide what methods to

00:23:59,960 --> 00:24:04,970
add or something like that the same

00:24:03,260 --> 00:24:06,530
thing what it's worth modules of course

00:24:04,970 --> 00:24:08,390
you can programmatically construct

00:24:06,530 --> 00:24:13,940
modules in exactly the same way there's

00:24:08,390 --> 00:24:16,190
no parent class and one of them praises

00:24:13,940 --> 00:24:18,980
people tend to use this is in

00:24:16,190 --> 00:24:21,440
inheritance because you can actually

00:24:18,980 --> 00:24:23,450
inherit from anything but there's a ruby

00:24:21,440 --> 00:24:26,030
expression there's a long as it results

00:24:23,450 --> 00:24:28,130
in a class so you can write a method

00:24:26,030 --> 00:24:30,050
that makes whatever class you want and

00:24:28,130 --> 00:24:38,270
returns it and then you can enter it

00:24:30,050 --> 00:24:41,480
from that thing and modules the same

00:24:38,270 --> 00:24:44,810
thing you can include any expression

00:24:41,480 --> 00:24:46,880
that results in a module so same same

00:24:44,810 --> 00:24:51,770
thing cool for scary kinds of

00:24:46,880 --> 00:24:54,830
metaprogramming avi combines that last

00:24:51,770 --> 00:24:58,130
trick with another unusual trick you can

00:24:54,830 --> 00:24:59,990
subclass module so that you can

00:24:58,130 --> 00:25:02,600
basically keep track of some state on

00:24:59,990 --> 00:25:05,810
the module itself like in this case I

00:25:02,600 --> 00:25:08,450
defined two string to tell me what

00:25:05,810 --> 00:25:09,950
argument the method was called with and

00:25:08,450 --> 00:25:11,630
then you can see in the output the first

00:25:09,950 --> 00:25:14,030
line when I asked for the ancestors

00:25:11,630 --> 00:25:16,040
instead of just getting some generic

00:25:14,030 --> 00:25:19,610
module in the West and I can actually

00:25:16,040 --> 00:25:23,960
see was constructing so it's kind of

00:25:19,610 --> 00:25:26,660
handy for if you want to make a type

00:25:23,960 --> 00:25:28,670
that's just an empty class you don't

00:25:26,660 --> 00:25:30,800
have to use the class definition block

00:25:28,670 --> 00:25:32,570
with nothing in it you can just use

00:25:30,800 --> 00:25:34,460
class there like I shown you before the

00:25:32,570 --> 00:25:36,890
block is optional so if you read the

00:25:34,460 --> 00:25:38,750
block out it it's the same thing okay

00:25:36,890 --> 00:25:40,280
it's a normal class with inheritance

00:25:38,750 --> 00:25:44,090
behaves normal way

00:25:40,280 --> 00:25:45,980
well cleaner syntax I think also a lot

00:25:44,090 --> 00:25:48,710
of people do that inherit from anything

00:25:45,980 --> 00:25:50,990
trick on struct but you don't need to

00:25:48,710 --> 00:25:53,000
because struck takes a block and it

00:25:50,990 --> 00:25:55,090
class evals whatever is inside the box

00:25:53,000 --> 00:25:59,470
so you can just make a block and

00:25:55,090 --> 00:26:01,660
yeah if you don't like assigning struct

00:25:59,470 --> 00:26:03,970
to a constant you can pass a string as

00:26:01,660 --> 00:26:06,580
the first argument and struck will make

00:26:03,970 --> 00:26:08,980
a subclass in the struct namespace for

00:26:06,580 --> 00:26:10,480
you so you can actually define all your

00:26:08,980 --> 00:26:14,070
struts there and you don't even have to

00:26:10,480 --> 00:26:14,070
assign the constant if you don't want to

00:26:14,400 --> 00:26:19,930
I'm pretty sure we all know about method

00:26:17,260 --> 00:26:22,690
they say we use that all the time but

00:26:19,930 --> 00:26:24,460
there's also respond to missing now and

00:26:22,690 --> 00:26:26,260
you get a couple of benefits if you

00:26:24,460 --> 00:26:28,570
actually implement it to return the

00:26:26,260 --> 00:26:30,760
right answer the first and obvious one

00:26:28,570 --> 00:26:33,370
is that respond to will give correct

00:26:30,760 --> 00:26:35,650
answers about your dynamic methods but

00:26:33,370 --> 00:26:37,990
the even cooler one is that then you can

00:26:35,650 --> 00:26:41,140
grab method references to your dynamic

00:26:37,990 --> 00:26:43,980
methods which is pretty useful for some

00:26:41,140 --> 00:26:43,980
tricks I'll show you in a bit

00:26:44,820 --> 00:26:51,010
in fact here's one of those traces this

00:26:47,470 --> 00:26:52,870
is how Sinatra builds its methods

00:26:51,010 --> 00:26:54,640
it doesn't use instance eval which is

00:26:52,870 --> 00:26:57,640
kind of cool it uses this variation

00:26:54,640 --> 00:26:59,680
where it defines methods grabs a

00:26:57,640 --> 00:27:03,840
reference to them and then removes them

00:26:59,680 --> 00:27:06,130
right and this is very efficient because

00:27:03,840 --> 00:27:07,720
the methods already been defined it's

00:27:06,130 --> 00:27:10,060
already passed the compilation step and

00:27:07,720 --> 00:27:12,400
all that it's quick plus you can use it

00:27:10,060 --> 00:27:15,490
on any object you can rebind it to

00:27:12,400 --> 00:27:19,680
different objects and invoking so this

00:27:15,490 --> 00:27:22,510
is a really cool meta programming trick

00:27:19,680 --> 00:27:24,670
okay let's move animated programming and

00:27:22,510 --> 00:27:28,210
onto debugging if you're gonna do bug

00:27:24,670 --> 00:27:31,060
one handy thing I tend to use sometimes

00:27:28,210 --> 00:27:32,980
is the ability to walk over every object

00:27:31,060 --> 00:27:37,660
in the system you can just iterate over

00:27:32,980 --> 00:27:39,670
them and ask questions about money if

00:27:37,660 --> 00:27:41,560
you want to just go over specific types

00:27:39,670 --> 00:27:43,970
of objects you can get back to just

00:27:41,560 --> 00:27:47,870
passing the type

00:27:43,970 --> 00:27:49,850
that's the same thing if you only need

00:27:47,870 --> 00:27:52,240
the counts of objects you can ask for

00:27:49,850 --> 00:27:55,850
that you get the room you types

00:27:52,240 --> 00:27:58,370
individual counts as the values it's

00:27:55,850 --> 00:28:00,320
good sometimes be handy for finding like

00:27:58,370 --> 00:28:02,000
memory leaks and stuff where the object

00:28:00,320 --> 00:28:03,309
counts are just going up up up and not

00:28:02,000 --> 00:28:05,150
back down

00:28:03,309 --> 00:28:07,100
actually if you really want to find

00:28:05,150 --> 00:28:09,620
memory leaks you can turn on the garbage

00:28:07,100 --> 00:28:11,540
collector profiler and then run some

00:28:09,620 --> 00:28:13,580
code that stresses garbage collection

00:28:11,540 --> 00:28:15,470
out and then you can get the results

00:28:13,580 --> 00:28:17,360
afterward and it'll basically give you

00:28:15,470 --> 00:28:18,620
this table of numbers I know you can't

00:28:17,360 --> 00:28:21,230
really see the numbers because they're

00:28:18,620 --> 00:28:23,870
small but it's just giving sizes and

00:28:21,230 --> 00:28:25,640
bytes object counts time the garbage

00:28:23,870 --> 00:28:27,500
collection took to run and stuff like

00:28:25,640 --> 00:28:29,840
that so you can use this to see your

00:28:27,500 --> 00:28:31,309
memory increasing over time if garbage

00:28:29,840 --> 00:28:33,380
collection is running correctly right

00:28:31,309 --> 00:28:35,270
you should see those numbers stabilizing

00:28:33,380 --> 00:28:36,650
at some point but if they just keep

00:28:35,270 --> 00:28:40,490
going up up up you probably have a

00:28:36,650 --> 00:28:42,710
memory weak in theirs if you have a

00:28:40,490 --> 00:28:45,200
bunch of change method calls like we

00:28:42,710 --> 00:28:46,400
want to do in Ruby like this and you

00:28:45,200 --> 00:28:48,860
want to get some debugging information

00:28:46,400 --> 00:28:52,220
in the memo you can use the new pack

00:28:48,860 --> 00:28:54,380
method which lets you tap into the

00:28:52,220 --> 00:28:56,300
occult chain run some code and then it

00:28:54,380 --> 00:28:59,600
ignores the results of your block and

00:28:56,300 --> 00:29:01,280
just goes on with the receiver so it's a

00:28:59,600 --> 00:29:03,980
good way to peek into the middle of

00:29:01,280 --> 00:29:05,480
something but if you're just trying to

00:29:03,980 --> 00:29:06,410
peek into the middle of something to

00:29:05,480 --> 00:29:08,929
print something out

00:29:06,410 --> 00:29:11,809
skip tap altogether because the P method

00:29:08,929 --> 00:29:14,750
was in cans - Ruby 1:9 to return its

00:29:11,809 --> 00:29:16,730
argument so whatever you pass into it

00:29:14,750 --> 00:29:19,929
also gets returned and you can just keep

00:29:16,730 --> 00:29:19,929
changing on it at the end of that

00:29:20,800 --> 00:29:26,570
another wonderful divine trick if you're

00:29:24,290 --> 00:29:29,210
working with threads set this guy to

00:29:26,570 --> 00:29:32,450
truth because if you end up having an

00:29:29,210 --> 00:29:34,880
error and a thread then the program

00:29:32,450 --> 00:29:36,860
keeps running until you actually end up

00:29:34,880 --> 00:29:39,350
joining that Greg and then

00:29:36,860 --> 00:29:41,240
will actually be tossed this often means

00:29:39,350 --> 00:29:43,250
Theatre happens a long way away

00:29:41,240 --> 00:29:45,410
different where somebody actually went

00:29:43,250 --> 00:29:47,600
wrong so if you want to see where it

00:29:45,410 --> 00:29:49,010
went on such as flying through and as

00:29:47,600 --> 00:29:51,860
soon as there's an error anywhere you

00:29:49,010 --> 00:29:54,100
die so makes it really easy to find

00:29:51,860 --> 00:29:54,100
things

00:29:54,920 --> 00:30:02,330
Ruby hazard the bug flag which is good

00:29:58,520 --> 00:30:04,130
and bad you can use it to hide some code

00:30:02,330 --> 00:30:06,590
but you only want to run some funds and

00:30:04,130 --> 00:30:09,230
you can see that it will give you the

00:30:06,590 --> 00:30:11,900
output you want here but it turns on

00:30:09,230 --> 00:30:13,940
whole lot of extra stuff so you get

00:30:11,900 --> 00:30:15,919
warnings like the good kind that you

00:30:13,940 --> 00:30:18,140
didn't initialize a variable but also

00:30:15,919 --> 00:30:20,179
some not super helpful ones about

00:30:18,140 --> 00:30:22,370
exceptions that were thrown and rescued

00:30:20,179 --> 00:30:25,280
and stuff like that so you get a lot of

00:30:22,370 --> 00:30:27,140
noisy output that you can also hide some

00:30:25,280 --> 00:30:33,020
of your going in there and Ruby does

00:30:27,140 --> 00:30:35,510
this ring you pass they - a flag between

00:30:33,020 --> 00:30:37,940
is a neat way to do balance checks if

00:30:35,510 --> 00:30:39,320
you're looking you know even with a date

00:30:37,940 --> 00:30:42,950
range or something works with any

00:30:39,320 --> 00:30:45,799
comparable object numbers strains dates

00:30:42,950 --> 00:30:48,049
and you can see if some object is

00:30:45,799 --> 00:30:52,970
between these of other objects so short

00:30:48,049 --> 00:30:56,150
but handy one if you want to walk over

00:30:52,970 --> 00:30:58,160
some data line by line in Ruby and you

00:30:56,150 --> 00:31:00,890
should rather than slurping it all into

00:30:58,160 --> 00:31:02,960
memory you can use for each and it

00:31:00,890 --> 00:31:05,450
doesn't open and then each over each

00:31:02,960 --> 00:31:07,870
line and then close so it's kind of it

00:31:05,450 --> 00:31:10,400
can do short it

00:31:07,870 --> 00:31:12,620
there's a similar one for writing data

00:31:10,400 --> 00:31:15,260
out so you can give the name of a file

00:31:12,620 --> 00:31:18,380
and then I just been diggin you want to

00:31:15,260 --> 00:31:18,770
stick in it and it will open it put it

00:31:18,380 --> 00:31:21,290
out

00:31:18,770 --> 00:31:23,330
actually you can pass a position in the

00:31:21,290 --> 00:31:24,870
file and the file will be trying to say

00:31:23,330 --> 00:31:27,540
go to that position in your

00:31:24,870 --> 00:31:29,370
will be appended on to the end I don't

00:31:27,540 --> 00:31:31,520
really know what a practical use for

00:31:29,370 --> 00:31:33,720
that aspect and be cool to find one

00:31:31,520 --> 00:31:38,850
otherwise the file just gets wiped out

00:31:33,720 --> 00:31:40,470
or in place I see a lot of people write

00:31:38,850 --> 00:31:42,750
their own demonize and I think it's not

00:31:40,470 --> 00:31:44,700
very long it's like 10 lines 12 lines

00:31:42,750 --> 00:31:49,050
right and we're still one out of red

00:31:44,700 --> 00:31:51,420
brick but Ruby one night processed email

00:31:49,050 --> 00:31:53,670
so you can just call that and then

00:31:51,420 --> 00:31:55,440
you're you're processed attached it's

00:31:53,670 --> 00:32:01,320
from the terminal and runs in the

00:31:55,440 --> 00:32:04,620
background pretty okay if you're into

00:32:01,320 --> 00:32:06,750
spying processes and such you need to

00:32:04,620 --> 00:32:08,850
check out the spawn command which was

00:32:06,750 --> 00:32:10,590
added over there one night the suckers a

00:32:08,850 --> 00:32:11,760
monster allows you to control

00:32:10,590 --> 00:32:14,040
environment variables

00:32:11,760 --> 00:32:15,900
obviously the command to be run and you

00:32:14,040 --> 00:32:17,790
get a whole bunch of options you know

00:32:15,900 --> 00:32:20,220
give me a big file back so that you can

00:32:17,790 --> 00:32:22,740
call other process methods on that pig

00:32:20,220 --> 00:32:24,750
file so it's really great way to spawn

00:32:22,740 --> 00:32:26,309
processes and I was worried you wouldn't

00:32:24,750 --> 00:32:28,290
believe me and look it up so this is

00:32:26,309 --> 00:32:31,860
about everything I could think about

00:32:28,290 --> 00:32:33,720
spawn on one slide it has some serious

00:32:31,860 --> 00:32:36,630
control over the environment variables

00:32:33,720 --> 00:32:39,090
you can control show expansion or not

00:32:36,630 --> 00:32:41,370
rename your process and the process list

00:32:39,090 --> 00:32:43,350
set your nicks and you like things like

00:32:41,370 --> 00:32:47,610
the process group or change the working

00:32:43,350 --> 00:32:49,320
directory redirect IO objects and using

00:32:47,610 --> 00:32:52,500
the KB to make it synchronous or

00:32:49,320 --> 00:32:54,030
asynchronous so seriously look up spawn

00:32:52,500 --> 00:32:58,500
it's about all you need to work with

00:32:54,030 --> 00:33:01,309
processes in Ruby One Nights awesome all

00:32:58,500 --> 00:33:05,100
rights talking about standard library a

00:33:01,309 --> 00:33:06,809
new feature is that you can get a secure

00:33:05,100 --> 00:33:09,210
random numbers so I guess they're good

00:33:06,809 --> 00:33:11,880
enough for cryptography I hope I don't

00:33:09,210 --> 00:33:13,740
know I don't do cryptography hope so but

00:33:11,880 --> 00:33:16,320
when I use its modulo 4 is then it will

00:33:13,740 --> 00:33:18,690
randomly generate Vega for you and I

00:33:16,320 --> 00:33:21,090
find that super handy hex data byte

00:33:18,690 --> 00:33:23,790
random bytes whatever you can even get

00:33:21,090 --> 00:33:26,210
you write these if you want unique IDs

00:33:23,790 --> 00:33:28,250
those IDs are strictly ran

00:33:26,210 --> 00:33:31,750
is the MAC address or the time or things

00:33:28,250 --> 00:33:31,750
like that but they're just randomly

00:33:31,780 --> 00:33:36,710
another method I love from the standard

00:33:34,520 --> 00:33:39,440
library a lot from the standard

00:33:36,710 --> 00:33:42,170
libraries open URI once you require it

00:33:39,440 --> 00:33:43,820
you can read from any web URL just like

00:33:42,170 --> 00:33:47,810
you were reading from a file using

00:33:43,820 --> 00:33:49,460
normal IO methods or whatever so it's

00:33:47,810 --> 00:33:51,340
about the easiest way in the world the

00:33:49,460 --> 00:33:59,300
ants and a half the web

00:33:51,340 --> 00:34:01,760
this is Rubirosa webisode was if you

00:33:59,300 --> 00:34:02,960
have to work with external processes

00:34:01,760 --> 00:34:06,770
eventually you're going to care about

00:34:02,960 --> 00:34:08,930
arguments to those processes and having

00:34:06,770 --> 00:34:10,940
to parse them correctly it will quote

00:34:08,930 --> 00:34:12,530
them correctly there is a standard

00:34:10,940 --> 00:34:14,360
library that will do that for you called

00:34:12,530 --> 00:34:17,360
sha words so it will show you how

00:34:14,360 --> 00:34:19,190
arguments are parsed it will quote being

00:34:17,360 --> 00:34:21,830
an individual argument for you or a

00:34:19,190 --> 00:34:23,540
quote a group of arguments for you so

00:34:21,830 --> 00:34:27,110
this is really handy when you're using

00:34:23,540 --> 00:34:28,400
reviews a glue language you don't have

00:34:27,110 --> 00:34:31,310
to remember all that crazy

00:34:28,400 --> 00:34:35,030
shorty here's a feature of the ER bi

00:34:31,310 --> 00:34:37,220
never seen it used if you extend this

00:34:35,030 --> 00:34:40,340
module in your class you're getting

00:34:37,220 --> 00:34:41,930
access to death nearly nothing and you

00:34:40,340 --> 00:34:44,360
can just give it the name of the method

00:34:41,930 --> 00:34:46,550
and then the name of an A or B template

00:34:44,360 --> 00:34:48,800
and it will basically turn that year B

00:34:46,550 --> 00:34:53,720
template into a method on your object

00:34:48,800 --> 00:34:57,560
and since it's precompiled it's fast

00:34:53,720 --> 00:34:58,430
it's pretty quick right so kind of a

00:34:57,560 --> 00:35:03,560
neat trick

00:34:58,430 --> 00:35:05,990
I love the file oh you tells module and

00:35:03,560 --> 00:35:07,670
the standard library because as you can

00:35:05,990 --> 00:35:09,620
see the method names are all in UNIX

00:35:07,670 --> 00:35:11,720
they're the unix commands with the

00:35:09,620 --> 00:35:14,450
arguments you a pass to them which means

00:35:11,720 --> 00:35:17,900
I can guess about the method name and

00:35:14,450 --> 00:35:19,640
I'm usually right I love that so this is

00:35:17,900 --> 00:35:22,250
that great module for when you're

00:35:19,640 --> 00:35:24,590
working with the file system a great way

00:35:22,250 --> 00:35:26,390
to use it is to include to extend it

00:35:24,590 --> 00:35:28,610
somewhere and then call those methods

00:35:26,390 --> 00:35:30,560
normally and the reason you want to do

00:35:28,610 --> 00:35:31,150
this is because there are other versions

00:35:30,560 --> 00:35:33,970
of file

00:35:31,150 --> 00:35:36,009
- like verbose which will print out what

00:35:33,970 --> 00:35:37,869
it's doing or dry run which will print

00:35:36,009 --> 00:35:40,180
out what it's doing but not actually do

00:35:37,869 --> 00:35:42,220
it so you can check things before you

00:35:40,180 --> 00:35:46,299
actually do them so this is an awesome

00:35:42,220 --> 00:35:48,430
trick and there's an object-oriented way

00:35:46,299 --> 00:35:50,019
to deal with path so standard library

00:35:48,430 --> 00:35:52,809
that's a lot cleaner and then like

00:35:50,019 --> 00:35:55,269
manually using file under and stuff it

00:35:52,809 --> 00:35:57,789
gives you ways to create paths ways to

00:35:55,269 --> 00:35:59,920
check them and work with them and then

00:35:57,789 --> 00:36:04,410
of course you can do the normal eye

00:35:59,920 --> 00:36:04,410
operations on them they can normally do

00:36:04,499 --> 00:36:10,450
there's a really great database and the

00:36:07,890 --> 00:36:12,789
standard library that's super simple to

00:36:10,450 --> 00:36:14,259
use just point it at a file and then do

00:36:12,789 --> 00:36:16,240
everything inside of a transaction

00:36:14,259 --> 00:36:18,309
because it's transactional database it

00:36:16,240 --> 00:36:20,829
has read many transactions you can abort

00:36:18,309 --> 00:36:22,660
the transaction and the data itself is

00:36:20,829 --> 00:36:24,819
just a hash so you can just assign

00:36:22,660 --> 00:36:27,069
values to action it's a hash in a file

00:36:24,819 --> 00:36:29,349
the - there's of course your data has to

00:36:27,069 --> 00:36:32,049
fit new memory but it's multiprocessing

00:36:29,349 --> 00:36:33,940
safe thread and save all that and you

00:36:32,049 --> 00:36:35,739
can swap it out for a gamble store which

00:36:33,940 --> 00:36:37,329
is also in the standard library you only

00:36:35,739 --> 00:36:39,670
have to change the require and the

00:36:37,329 --> 00:36:41,259
object name and the database will be

00:36:39,670 --> 00:36:43,390
written in Hamel so you get the same

00:36:41,259 --> 00:36:45,519
results but the database is human

00:36:43,390 --> 00:36:48,730
readable that's a little slower of

00:36:45,519 --> 00:36:49,509
course there's also a set in standard

00:36:48,730 --> 00:36:52,059
library I know

00:36:49,509 --> 00:36:53,829
array has a lot of set functions but

00:36:52,059 --> 00:36:55,450
this one gives you various ways to a guy

00:36:53,829 --> 00:36:57,430
go and see how they're added check

00:36:55,450 --> 00:36:59,920
membership super site so I'm say and

00:36:57,430 --> 00:37:01,569
there's even a sorted version so this is

00:36:59,920 --> 00:37:03,369
a lot easier to use than just calling

00:37:01,569 --> 00:37:04,739
unique on an array all the time or

00:37:03,369 --> 00:37:07,839
something like that

00:37:04,739 --> 00:37:10,150
let's look at some tools Ruby itself is

00:37:07,839 --> 00:37:12,549
a tool and has command-line switches

00:37:10,150 --> 00:37:15,849
they can build large programs for you

00:37:12,549 --> 00:37:19,720
because it assumes your code runs in

00:37:15,849 --> 00:37:21,670
this loop and you can even hear backups

00:37:19,720 --> 00:37:23,680
and files while you work on them so your

00:37:21,670 --> 00:37:27,880
data changes but you can backup of your

00:37:23,680 --> 00:37:30,549
way this are def is in my group I just

00:37:27,880 --> 00:37:31,040
showed you that's a special object that

00:37:30,549 --> 00:37:33,410
is

00:37:31,040 --> 00:37:35,600
catenation of all the viral parameters

00:37:33,410 --> 00:37:38,060
on the command line so you can treat

00:37:35,600 --> 00:37:40,490
them as one IO object and you can even

00:37:38,060 --> 00:37:42,080
use our deck our deck yourself without

00:37:40,490 --> 00:37:44,960
the command line you can just grab this

00:37:42,080 --> 00:37:47,510
class and you up to point of arrow so

00:37:44,960 --> 00:37:49,640
you can use it in other places this is a

00:37:47,510 --> 00:37:52,130
flip flop operator it's probably the

00:37:49,640 --> 00:37:53,870
most confusing thing and all of Ruby but

00:37:52,130 --> 00:37:55,850
it is great for tuning through data in

00:37:53,870 --> 00:38:00,470
some cases it's basically a state

00:37:55,850 --> 00:38:02,030
machine the first expression will be

00:38:00,470 --> 00:38:04,610
checked against every line until it

00:38:02,030 --> 00:38:05,990
matches then they think turns on then

00:38:04,610 --> 00:38:07,430
the second expression will be checked

00:38:05,990 --> 00:38:09,740
against every line until it matches

00:38:07,430 --> 00:38:12,050
which turns the thing back off so you

00:38:09,740 --> 00:38:15,620
can use it to grab chunks of data

00:38:12,050 --> 00:38:18,410
starting hearing and being here that

00:38:15,620 --> 00:38:20,540
works Ruby also understands these begin

00:38:18,410 --> 00:38:23,090
and end blocks which will only run at

00:38:20,540 --> 00:38:24,830
the beginning and end of a program even

00:38:23,090 --> 00:38:26,660
if they're inside of a loop like the one

00:38:24,830 --> 00:38:28,910
I showed you before so you can use on

00:38:26,660 --> 00:38:32,870
they initialize some stuff in scary

00:38:28,910 --> 00:38:34,790
command-line programs IRB if you don't

00:38:32,870 --> 00:38:37,430
know this one that's a lifesaver and the

00:38:34,790 --> 00:38:39,980
underscores will last about you that are

00:38:37,430 --> 00:38:41,600
being calculated that is probably the

00:38:39,980 --> 00:38:43,550
thing I use most often and the rails

00:38:41,600 --> 00:38:45,890
console because you run some query and

00:38:43,550 --> 00:38:47,750
then you can still get a B data our site

00:38:45,890 --> 00:38:49,220
if you were variable in whatever a lot

00:38:47,750 --> 00:38:51,860
of people like pride because it can

00:38:49,220 --> 00:38:53,720
focus in on individual objects IRB is

00:38:51,860 --> 00:38:55,670
actually always been able to do that you

00:38:53,720 --> 00:38:58,370
can just call IRB in and pass the object

00:38:55,670 --> 00:39:00,230
they'll change focus to that you can see

00:38:58,370 --> 00:39:01,790
what objects it currently has it runs

00:39:00,230 --> 00:39:03,740
each one they do different threads so

00:39:01,790 --> 00:39:05,870
they're called jobs you can switch back

00:39:03,740 --> 00:39:07,640
and forth between them and you can quit

00:39:05,870 --> 00:39:10,340
out of an inner job to get back to the

00:39:07,640 --> 00:39:14,210
top scope just with anything so RB Zoe's

00:39:10,340 --> 00:39:16,370
on this you can also use IRB the library

00:39:14,210 --> 00:39:18,770
just by calling start here exit signal

00:39:16,370 --> 00:39:20,150
handler that triggers IRB just leave

00:39:18,770 --> 00:39:22,100
yourself some way to get to the main

00:39:20,150 --> 00:39:24,410
program because you want kind of access

00:39:22,100 --> 00:39:26,870
to local variables but you can see that

00:39:24,410 --> 00:39:28,970
I can run my program controls need to

00:39:26,870 --> 00:39:29,670
get an IRB console twiddle some values

00:39:28,970 --> 00:39:31,650
and

00:39:29,670 --> 00:39:33,990
my program still running with the change

00:39:31,650 --> 00:39:37,289
values I was reckon we can do for your

00:39:33,990 --> 00:39:40,410
money if you end up with like a wall of

00:39:37,289 --> 00:39:42,240
JSON and you want to clean it up if you

00:39:40,410 --> 00:39:44,460
have Ruby installed you also have this

00:39:42,240 --> 00:39:46,559
weird utility called pretty by Jason

00:39:44,460 --> 00:39:48,589
Garvey and you can just pipe it through

00:39:46,559 --> 00:39:52,260
there and you'll get creams next line

00:39:48,589 --> 00:39:54,420
okay last one you can actually read

00:39:52,260 --> 00:39:56,760
programs that running forever using a

00:39:54,420 --> 00:39:58,319
few tricks this program does random math

00:39:56,760 --> 00:40:01,799
so eventually it does something stupid

00:39:58,319 --> 00:40:03,630
like divide by zero you can set an exit

00:40:01,799 --> 00:40:05,789
code to run some code when Ruby's about

00:40:03,630 --> 00:40:06,990
to exit check the exception that's been

00:40:05,789 --> 00:40:09,299
thrown make sure it's not something

00:40:06,990 --> 00:40:11,279
you're okay with like control C or exit

00:40:09,299 --> 00:40:14,549
being called and then you can replace

00:40:11,279 --> 00:40:17,609
your program with a copy of itself to

00:40:14,549 --> 00:40:19,289
basically just give yourself a fresh

00:40:17,609 --> 00:40:21,599
copy that doesn't have bugs and that can

00:40:19,289 --> 00:40:23,099
keep on running so even though this code

00:40:21,599 --> 00:40:26,250
Rosebud's that were literally running

00:40:23,099 --> 00:40:28,769
forever I never stop and most of these

00:40:26,250 --> 00:40:30,329
tricks I've shown you are actually based

00:40:28,769 --> 00:40:31,890
on some of them were just for fun but

00:40:30,329 --> 00:40:32,369
most of them are actually based on real

00:40:31,890 --> 00:40:35,220
things

00:40:32,369 --> 00:40:38,039
this one believe it or not is based on a

00:40:35,220 --> 00:40:40,140
real thing textmate uses a trick very

00:40:38,039 --> 00:40:42,240
similar to this when it runs your Ruby

00:40:40,140 --> 00:40:43,920
code like when you hit Apple R so they

00:40:42,240 --> 00:40:45,869
can tell if your program ends there with

00:40:43,920 --> 00:40:48,440
an error or not and then if it's an

00:40:45,869 --> 00:40:51,420
error it can give you a nice hyperlink

00:40:48,440 --> 00:40:53,640
stacktrace as opposed to the actual

00:40:51,420 --> 00:40:55,410
program output right so some of these

00:40:53,640 --> 00:40:58,170
are actually impractical believe it or

00:40:55,410 --> 00:40:59,910
not I promise these slides will be

00:40:58,170 --> 00:41:02,099
online since I didn't let you take

00:40:59,910 --> 00:41:03,779
notice I'll tweet about them when I put

00:41:02,099 --> 00:41:05,609
them up so you can just follow me and

00:41:03,779 --> 00:41:08,480
you give them that that's what I've got

00:41:05,609 --> 00:41:08,480
thank you very much

00:41:22,260 --> 00:41:24,320

YouTube URL: https://www.youtube.com/watch?v=aBgnlBoIkVM


