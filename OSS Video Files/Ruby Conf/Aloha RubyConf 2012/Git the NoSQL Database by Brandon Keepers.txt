Title: Git the NoSQL Database by Brandon Keepers
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGfp/
Captions: 
	00:00:15,850 --> 00:00:21,110
my name is Brandon keepers I'm a

00:00:18,290 --> 00:00:25,160
developer at github you find me online

00:00:21,110 --> 00:00:26,750
as beekeepers or on boat on both twitter

00:00:25,160 --> 00:00:30,230
and github so feel free to send me a

00:00:26,750 --> 00:00:33,320
message i'm here today mostly because i

00:00:30,230 --> 00:00:34,730
made the organizers feel guilty back in

00:00:33,320 --> 00:00:36,860
like march when i saw that this was

00:00:34,730 --> 00:00:39,440
announced I was like hey this conference

00:00:36,860 --> 00:00:40,820
on my birthday smooth talk I things I

00:00:39,440 --> 00:00:46,010
should get to come to Hawaii for my

00:00:40,820 --> 00:00:48,140
birthday so it worked out well so this

00:00:46,010 --> 00:00:51,260
is this talk is about using it as a

00:00:48,140 --> 00:00:53,059
database and I don't think I'm the only

00:00:51,260 --> 00:00:55,190
one that's had this idea in fact when I

00:00:53,059 --> 00:00:56,989
when I first thought of it you know you

00:00:55,190 --> 00:00:58,670
come up those ideas and like yes this is

00:00:56,989 --> 00:01:00,559
so revolutionary then you like google it

00:00:58,670 --> 00:01:04,040
and like 30 people have had the same

00:01:00,559 --> 00:01:07,100
thing and tried it by still an

00:01:04,040 --> 00:01:08,600
experiment with it so this was you know

00:01:07,100 --> 00:01:10,340
is like one of those like the windows

00:01:08,600 --> 00:01:11,930
commercials where like you know the guys

00:01:10,340 --> 00:01:14,390
in the shower and like his muscles are

00:01:11,930 --> 00:01:16,820
all Ripley and is this beautiful idea

00:01:14,390 --> 00:01:19,310
what if I could use get as the date of

00:01:16,820 --> 00:01:20,720
Noah wasn't like that at all but anyway

00:01:19,310 --> 00:01:24,550
what if I could use get as a database

00:01:20,720 --> 00:01:26,540
works great for code i love it for code

00:01:24,550 --> 00:01:28,430
but what it like what would it look like

00:01:26,540 --> 00:01:31,460
to use it actually as your applications

00:01:28,430 --> 00:01:33,850
main database so one of my co-workers

00:01:31,460 --> 00:01:36,980
john hoy and i played around with this

00:01:33,850 --> 00:01:39,470
we built this app called gasket which

00:01:36,980 --> 00:01:41,750
was we really liked pivotal tracker at

00:01:39,470 --> 00:01:43,400
the time and we're like Willis it would

00:01:41,750 --> 00:01:46,010
be really awesome if those issues could

00:01:43,400 --> 00:01:49,130
be in our git repo with the the rest of

00:01:46,010 --> 00:01:50,870
the code so we built this this project

00:01:49,130 --> 00:01:52,370
called gasket you know is still up on

00:01:50,870 --> 00:01:54,880
github you can clone it there hasn't

00:01:52,370 --> 00:01:59,120
been any commits to it for a while but

00:01:54,880 --> 00:02:00,590
feel free to check it out so before we

00:01:59,120 --> 00:02:03,830
get too far into this I have a couple

00:02:00,590 --> 00:02:07,179
disclaimers the first I work at github

00:02:03,830 --> 00:02:09,979
which you may or may not know we use get

00:02:07,179 --> 00:02:12,800
there are a lot of people at github that

00:02:09,979 --> 00:02:14,629
know a lot about get all of those guys

00:02:12,800 --> 00:02:17,920
across the top especially the guy with

00:02:14,629 --> 00:02:20,150
his toe in his mouth are brilliant

00:02:17,920 --> 00:02:21,290
despite the toe in the mouth I know it

00:02:20,150 --> 00:02:25,730
doesn't

00:02:21,290 --> 00:02:27,769
exude brilliance but trust me I'll show

00:02:25,730 --> 00:02:29,469
you later the the response i got for him

00:02:27,769 --> 00:02:32,390
when I was doing research for this

00:02:29,469 --> 00:02:37,189
anyway there's a lot of smart people I'm

00:02:32,390 --> 00:02:40,790
not one of those people at github I know

00:02:37,189 --> 00:02:43,310
a lot about using it and I would say I'm

00:02:40,790 --> 00:02:45,769
a fairly advanced user when it comes to

00:02:43,310 --> 00:02:47,959
the internals of get and what would make

00:02:45,769 --> 00:02:51,739
that a good database I was pretty much a

00:02:47,959 --> 00:02:54,409
noob so there's my first one and then

00:02:51,739 --> 00:02:58,549
the second disclaimer i think the word

00:02:54,409 --> 00:03:00,079
no no sequel or no SQL is BS it's good

00:02:58,549 --> 00:03:02,389
marketing speak which you know it got a

00:03:00,079 --> 00:03:07,069
few of you in the room which is why i

00:03:02,389 --> 00:03:09,650
use it but i think when people i gets to

00:03:07,069 --> 00:03:11,659
back up like i love no sequel databases

00:03:09,650 --> 00:03:14,569
I love key value stores I use them all

00:03:11,659 --> 00:03:17,810
the time I'm to the point where it pains

00:03:14,569 --> 00:03:20,299
me to use an SQL database but I don't

00:03:17,810 --> 00:03:22,040
think I think no sequel is a really bad

00:03:20,299 --> 00:03:24,010
term for this when people are talking

00:03:22,040 --> 00:03:26,419
about no sequel what they really mean is

00:03:24,010 --> 00:03:29,479
you're dealing with a database that is

00:03:26,419 --> 00:03:31,159
ski Milus and non-relational meaning

00:03:29,479 --> 00:03:32,810
that it doesn't care about the

00:03:31,159 --> 00:03:35,269
underlying structure of what your data

00:03:32,810 --> 00:03:36,620
is it doesn't care what the schema for

00:03:35,269 --> 00:03:39,260
that is and it doesn't care about the

00:03:36,620 --> 00:03:40,940
relationships within your data so

00:03:39,260 --> 00:03:44,030
there's there's no optimizations that a

00:03:40,940 --> 00:03:45,739
database like react or or whatever

00:03:44,030 --> 00:03:47,750
makes for the relationships between your

00:03:45,739 --> 00:03:50,989
data you define those relationships and

00:03:47,750 --> 00:03:54,769
give meaning to them so there's my to

00:03:50,989 --> 00:03:57,290
disclaimers today really simple I want

00:03:54,769 --> 00:04:00,139
to look at so okay how do we use get as

00:03:57,290 --> 00:04:02,120
a no sequel database talk about some

00:04:00,139 --> 00:04:05,949
reasons why it's really awesome and talk

00:04:02,120 --> 00:04:05,949
about some reasons why it really sucks

00:04:06,920 --> 00:04:12,500
so the first one how is get a database

00:04:09,670 --> 00:04:14,060
if we ask it what it is by looking at

00:04:12,500 --> 00:04:18,380
the man page it tells us that it's the

00:04:14,060 --> 00:04:19,639
stupid content tracker it's so humble if

00:04:18,380 --> 00:04:21,680
I think that is kind of interesting like

00:04:19,639 --> 00:04:23,960
get in it's one line sentence doesn't

00:04:21,680 --> 00:04:25,880
even claimed to be a distributed version

00:04:23,960 --> 00:04:29,120
control system it goes on to say that in

00:04:25,880 --> 00:04:32,900
the longer description but itself claims

00:04:29,120 --> 00:04:35,030
to be a Content tracker I'm going to be

00:04:32,900 --> 00:04:37,250
using the word database rather loosely

00:04:35,030 --> 00:04:38,570
here for a bit if you you know look at

00:04:37,250 --> 00:04:39,919
the dictionary definition it's a

00:04:38,570 --> 00:04:41,720
structured set of data held in the

00:04:39,919 --> 00:04:43,370
computer which basically means all of

00:04:41,720 --> 00:04:46,460
the data in your computer is structured

00:04:43,370 --> 00:04:48,110
because it's Anna file system so that's

00:04:46,460 --> 00:04:52,340
the working definition that we've got

00:04:48,110 --> 00:04:57,440
here so if it's a database how do we

00:04:52,340 --> 00:04:59,750
store data in it here we go get 101 we

00:04:57,440 --> 00:05:03,800
initialize the database so we make a

00:04:59,750 --> 00:05:09,200
directory and CD into it we call get in

00:05:03,800 --> 00:05:12,020
it to create a new database we can then

00:05:09,200 --> 00:05:15,440
write stuff to our database so I'm going

00:05:12,020 --> 00:05:19,490
to in this case store Jason so I echo

00:05:15,440 --> 00:05:23,600
some JSON string into a file I add that

00:05:19,490 --> 00:05:28,100
file and then I commit whoo we added

00:05:23,600 --> 00:05:30,080
data to our database and then we can

00:05:28,100 --> 00:05:33,820
read that data back out by saying get

00:05:30,080 --> 00:05:36,530
show the file that I just added awesome

00:05:33,820 --> 00:05:40,690
thanks for coming that's how you use get

00:05:36,530 --> 00:05:43,220
us a database all right yeah seriously

00:05:40,690 --> 00:05:45,410
file system obviously is not a good data

00:05:43,220 --> 00:05:47,660
store if we want to get technical about

00:05:45,410 --> 00:05:49,880
it it is a key value store you can give

00:05:47,660 --> 00:05:54,860
it a key which is a path and stick some

00:05:49,880 --> 00:05:58,550
value in it other key value stores react

00:05:54,860 --> 00:05:59,690
redis Cassandra amazon dynamo there's

00:05:58,550 --> 00:06:03,110
all kinds of them these are all awesome

00:05:59,690 --> 00:06:05,210
databases so let's let's look at then

00:06:03,110 --> 00:06:08,000
what would it look like to use get more

00:06:05,210 --> 00:06:10,039
in the vein of one of these and less

00:06:08,000 --> 00:06:12,229
directly accessing files I mean

00:06:10,039 --> 00:06:13,880
obviously if we if we went just down the

00:06:12,229 --> 00:06:16,430
file system route we quickly run into

00:06:13,880 --> 00:06:18,080
issues with you know there's like three

00:06:16,430 --> 00:06:19,529
operations I have to do on the file

00:06:18,080 --> 00:06:21,299
system before I can commit it

00:06:19,529 --> 00:06:26,399
that means only one process can do that

00:06:21,299 --> 00:06:28,519
at a time right so so basically we have

00:06:26,399 --> 00:06:32,789
to go a little bit deeper here to

00:06:28,519 --> 00:06:34,469
understand how to use this most of us

00:06:32,789 --> 00:06:36,779
are probably familiar with all of these

00:06:34,469 --> 00:06:40,349
git commands it's what get calls the

00:06:36,779 --> 00:06:43,649
porcelain so they get ad get commit you

00:06:40,349 --> 00:06:47,159
know get show basically the commands

00:06:43,649 --> 00:06:50,339
that we use every day but there's more

00:06:47,159 --> 00:06:52,649
to get than just those commands if you

00:06:50,339 --> 00:06:55,889
look through the get man pages you'll

00:06:52,649 --> 00:06:58,439
find all of these which which get calls

00:06:55,889 --> 00:06:59,549
the plumbing and these are them just

00:06:58,439 --> 00:07:01,499
kind of the way that they get is

00:06:59,549 --> 00:07:02,789
structured it's built so that you can

00:07:01,499 --> 00:07:04,559
have all of these really small pieces

00:07:02,789 --> 00:07:06,839
and then it has these higher level

00:07:04,559 --> 00:07:09,419
commands on top of them that kind of you

00:07:06,839 --> 00:07:13,829
know mold them all together sounds kind

00:07:09,419 --> 00:07:15,719
of UNIX see so to use get as a database

00:07:13,829 --> 00:07:17,519
let's see let's kind of walk down the

00:07:15,719 --> 00:07:19,469
path of what it looks like you know like

00:07:17,519 --> 00:07:23,489
what does get ad doing and get commit

00:07:19,469 --> 00:07:25,979
that gives us this structure let's see

00:07:23,489 --> 00:07:26,999
how we can do that manually as part of

00:07:25,979 --> 00:07:30,589
that we're going to learn a little bit

00:07:26,999 --> 00:07:33,089
more about how gets data structure works

00:07:30,589 --> 00:07:35,849
so at the very lowest level and get we

00:07:33,089 --> 00:07:37,499
have blobs anyone know is anyone like

00:07:35,849 --> 00:07:41,999
read anything about all this stuff blobs

00:07:37,499 --> 00:07:44,610
and trees and all right few people so

00:07:41,999 --> 00:07:46,589
the lowest level get has these blobs so

00:07:44,610 --> 00:07:48,509
we can take any content we want and we

00:07:46,589 --> 00:07:49,949
can stick it into a blob so we do that

00:07:48,509 --> 00:07:52,439
again we're still on the command line we

00:07:49,949 --> 00:07:55,289
say echo whatever string we want to

00:07:52,439 --> 00:07:57,239
store and then we pipe it in to get hash

00:07:55,289 --> 00:08:00,899
object which is going to take the

00:07:57,239 --> 00:08:03,179
contents of that string and basically

00:08:00,899 --> 00:08:06,269
generate a sha-1 for it and store it in

00:08:03,179 --> 00:08:08,939
a file with that same shop so all of the

00:08:06,269 --> 00:08:11,129
blobs are unique based on their contents

00:08:08,939 --> 00:08:13,169
if I if I take the same data and try and

00:08:11,129 --> 00:08:16,260
stick it in a blob again it's going to

00:08:13,169 --> 00:08:20,020
basically point to that exact same blob

00:08:16,260 --> 00:08:22,090
so get hash object HW to say to write it

00:08:20,020 --> 00:08:23,889
and the standard in to say look for

00:08:22,090 --> 00:08:26,380
input coming from standard in it gives

00:08:23,889 --> 00:08:29,710
us back the Shah or these these contents

00:08:26,380 --> 00:08:32,020
and also writes them into our get

00:08:29,710 --> 00:08:34,360
database so when we went into that

00:08:32,020 --> 00:08:35,650
directory and we called get in it what

00:08:34,360 --> 00:08:37,659
it did is it created this dot get

00:08:35,650 --> 00:08:40,419
directory and now that we've done our

00:08:37,659 --> 00:08:42,990
hash objects we've got one blob in there

00:08:40,419 --> 00:08:45,100
with with a show that it just showed us

00:08:42,990 --> 00:08:47,560
we'll keep developing this little

00:08:45,100 --> 00:08:50,860
diagram here to give us an idea of what

00:08:47,560 --> 00:08:54,070
it looks like so how do we read these

00:08:50,860 --> 00:08:55,570
things back out we say first of all we

00:08:54,070 --> 00:08:59,770
can just look at the file system we say

00:08:55,570 --> 00:09:01,660
find get objects and we want to only we

00:08:59,770 --> 00:09:03,280
only want things that are type file and

00:09:01,660 --> 00:09:06,580
we see that there's there's a file in

00:09:03,280 --> 00:09:07,660
that directory with with our shop if you

00:09:06,580 --> 00:09:10,780
try to look at that it would be some

00:09:07,660 --> 00:09:13,300
like binary data but we can say get cat

00:09:10,780 --> 00:09:16,120
file and give it our Shah and actually

00:09:13,300 --> 00:09:17,620
get the contents back all right looking

00:09:16,120 --> 00:09:19,870
a little bit more like a database maybe

00:09:17,620 --> 00:09:24,150
now we can have multiple things writing

00:09:19,870 --> 00:09:24,150
blobs and they won't stomp on each other

00:09:24,180 --> 00:09:30,339
so how do we update data so with the

00:09:28,780 --> 00:09:33,100
with the underlying data structure of

00:09:30,339 --> 00:09:36,339
get it uses the contents to generate

00:09:33,100 --> 00:09:38,080
this ID this shÃ¡Ã¡ which makes it

00:09:36,339 --> 00:09:39,610
basically immutable once we store

00:09:38,080 --> 00:09:41,230
something in it you can never change it

00:09:39,610 --> 00:09:43,270
if you do change it it's going to change

00:09:41,230 --> 00:09:46,000
the ID that's not exactly helpful in a

00:09:43,270 --> 00:09:49,180
data store so we're going to keep

00:09:46,000 --> 00:09:52,900
walking up gets data structure and look

00:09:49,180 --> 00:09:56,290
at what else I gives us next we have

00:09:52,900 --> 00:09:58,120
trees trees are basically like in your

00:09:56,290 --> 00:10:00,190
file system like directories they can

00:09:58,120 --> 00:10:02,290
hold a list of blobs or a list of other

00:10:00,190 --> 00:10:05,020
trees so what we want to do is we want

00:10:02,290 --> 00:10:07,600
to stage some changes into a tree

00:10:05,020 --> 00:10:10,390
basically tell it keep a reference to

00:10:07,600 --> 00:10:13,630
this blob that we just created so I say

00:10:10,390 --> 00:10:16,720
get update index hotel it add cash info

00:10:13,630 --> 00:10:19,870
is just the file attributes of the file

00:10:16,720 --> 00:10:21,910
we're adding and then be Shah and then

00:10:19,870 --> 00:10:23,600
on the right hand side the the reference

00:10:21,910 --> 00:10:25,279
or the ID that we want to refer

00:10:23,600 --> 00:10:28,250
from now on so from now on I'm going to

00:10:25,279 --> 00:10:29,839
say okay this object is one Jason that's

00:10:28,250 --> 00:10:32,899
the the friendly name that I want to

00:10:29,839 --> 00:10:35,420
give it so we add that we staged the

00:10:32,899 --> 00:10:37,370
index and we say get right tree which is

00:10:35,420 --> 00:10:40,279
going to give us back another Shaw so

00:10:37,370 --> 00:10:42,380
just like blobs you know the Shah of the

00:10:40,279 --> 00:10:44,120
the blob is depending on the content

00:10:42,380 --> 00:10:45,980
trees are going to do the same thing

00:10:44,120 --> 00:10:47,569
whatever whatever blobs that we stick

00:10:45,980 --> 00:10:49,519
inside of them they're going to it's

00:10:47,569 --> 00:10:52,490
going to generate a new sha that is

00:10:49,519 --> 00:10:53,509
depending on the the contents of that so

00:10:52,490 --> 00:10:55,579
now we have something that looks a

00:10:53,509 --> 00:10:57,680
little bit like this we have a tree

00:10:55,579 --> 00:11:01,639
which points to a blob and both of them

00:10:57,680 --> 00:11:03,110
have their own their own shop you can

00:11:01,639 --> 00:11:05,720
also have I mentioned this you can have

00:11:03,110 --> 00:11:07,910
multiple blobs in a tree this is neil

00:11:05,720 --> 00:11:11,600
like a directory with files in it same

00:11:07,910 --> 00:11:12,920
idea then you can also have a tree point

00:11:11,600 --> 00:11:15,519
to another tree with with blobs

00:11:12,920 --> 00:11:15,519
underneath that

00:11:17,270 --> 00:11:22,040
next we want to look at commits so we've

00:11:19,970 --> 00:11:23,810
got our blob we've got a tree now we

00:11:22,040 --> 00:11:25,610
need basically a marker in time that

00:11:23,810 --> 00:11:28,400
says okay this is the state of this tree

00:11:25,610 --> 00:11:30,680
at this one moment in time and so I can

00:11:28,400 --> 00:11:33,470
tell to say get commit tree give it a

00:11:30,680 --> 00:11:36,020
message and then I give it the Shah of

00:11:33,470 --> 00:11:37,460
the tree that I want to commit so this

00:11:36,020 --> 00:11:39,920
is going to create a commit object for

00:11:37,460 --> 00:11:43,790
us look something like this points that

00:11:39,920 --> 00:11:46,940
tree that tree points of those blobs we

00:11:43,790 --> 00:11:51,980
still can't reference our file one jason

00:11:46,940 --> 00:11:54,050
without without changing every time so

00:11:51,980 --> 00:11:56,360
the last step that is writing a

00:11:54,050 --> 00:11:58,280
reference in reference is what kind of

00:11:56,360 --> 00:12:01,970
gives us a symbolic link to the latest

00:11:58,280 --> 00:12:05,390
state of our database i'm going to say

00:12:01,970 --> 00:12:08,210
get update ref and i give it a friendly

00:12:05,390 --> 00:12:10,430
name so RAF heads master with you just

00:12:08,210 --> 00:12:12,650
type git commit this is what gets doing

00:12:10,430 --> 00:12:15,260
behind the scenes and I give it the

00:12:12,650 --> 00:12:19,190
commit ID that I want this reference to

00:12:15,260 --> 00:12:22,010
point to now I can look in my might get

00:12:19,190 --> 00:12:24,520
object database and I see file actually

00:12:22,010 --> 00:12:28,070
contains the show that I just gave it a

00:12:24,520 --> 00:12:29,870
tree now is looking like this so we have

00:12:28,070 --> 00:12:31,310
our reference which points to the commit

00:12:29,870 --> 00:12:35,240
point to the tree points of the blobs

00:12:31,310 --> 00:12:38,600
and now finally we can read back out the

00:12:35,240 --> 00:12:40,220
data that we stuck in it without without

00:12:38,600 --> 00:12:42,200
the ID changing every time we want to

00:12:40,220 --> 00:12:45,110
update the data so i could say get show

00:12:42,200 --> 00:12:47,960
master which is my reference colon one

00:12:45,110 --> 00:12:50,120
jason meaning the ID that i gave it when

00:12:47,960 --> 00:12:52,490
I stuck it in so this is essentially

00:12:50,120 --> 00:12:54,320
what we did with our few familiar

00:12:52,490 --> 00:12:57,050
commands earlier we added yet when we

00:12:54,320 --> 00:13:00,470
added a file we committed we were just

00:12:57,050 --> 00:13:03,000
doing those steps

00:13:00,470 --> 00:13:07,050
and then as far as the revision history

00:13:03,000 --> 00:13:09,450
goes the way that keeps track of that is

00:13:07,050 --> 00:13:12,030
we simply do that process over and over

00:13:09,450 --> 00:13:14,130
so if I want to change your blob I go

00:13:12,030 --> 00:13:16,860
update the contents it gives me a new ID

00:13:14,130 --> 00:13:18,240
for that blob I update the tree I create

00:13:16,860 --> 00:13:20,460
a new commit and then I move the

00:13:18,240 --> 00:13:23,670
reference to point to that commit again

00:13:20,460 --> 00:13:28,920
so underlying you underneath I get this

00:13:23,670 --> 00:13:30,210
is how fundamentally it works it's not

00:13:28,920 --> 00:13:33,540
really helpful for using it as a

00:13:30,210 --> 00:13:35,640
database at this point first of all

00:13:33,540 --> 00:13:36,930
we're using all these shell commands or

00:13:35,640 --> 00:13:39,630
programmers we don't want to use shell

00:13:36,930 --> 00:13:43,980
commands so let's look at some Ruby

00:13:39,630 --> 00:13:45,840
libraries the oldest one and one is

00:13:43,980 --> 00:13:48,450
still used in a lot of places in github

00:13:45,840 --> 00:13:50,910
is grit so I'm gonna use that for our

00:13:48,450 --> 00:13:54,240
examples here today there's also lib get

00:13:50,910 --> 00:13:55,620
to is an awesome project that we've been

00:13:54,240 --> 00:13:58,050
putting a lot of effort into at github

00:13:55,620 --> 00:14:00,510
to try and create a link bubble c

00:13:58,050 --> 00:14:02,490
library for for all the git commands and

00:14:00,510 --> 00:14:04,890
then there's some there's bindings in

00:14:02,490 --> 00:14:07,740
like every language you can imagine for

00:14:04,890 --> 00:14:09,240
lib get to so you're going to do

00:14:07,740 --> 00:14:11,010
anything real with this type of stuff I

00:14:09,240 --> 00:14:12,540
would recommend looking at the lib get

00:14:11,010 --> 00:14:16,320
to stuff and Ruby there's a library

00:14:12,540 --> 00:14:18,380
called rugged which is coming along

00:14:16,320 --> 00:14:18,380
nicely

00:14:22,329 --> 00:14:28,089
so grit is a gym the gem install it and

00:14:25,720 --> 00:14:30,399
say require grit and then I just create

00:14:28,089 --> 00:14:34,149
a new instance of a grit repo with the

00:14:30,399 --> 00:14:36,519
path with the path to that repo so let's

00:14:34,149 --> 00:14:38,439
look at how we do basically what we just

00:14:36,519 --> 00:14:42,040
did from the command line in code how do

00:14:38,439 --> 00:14:45,519
we add new files update the index and

00:14:42,040 --> 00:14:46,929
update a reference to point to that well

00:14:45,519 --> 00:14:49,149
the first thing we can do is we can get

00:14:46,929 --> 00:14:50,980
access to a new index you call repo down

00:14:49,149 --> 00:14:52,809
index and I'll just give you a blank

00:14:50,980 --> 00:14:57,489
slate where you can stage some of your

00:14:52,809 --> 00:14:58,929
changes in order to maintain this

00:14:57,489 --> 00:15:01,209
revision history we have to get a

00:14:58,929 --> 00:15:03,939
reference to the latest commit and the

00:15:01,209 --> 00:15:05,709
tree that that points to so I say repo'd

00:15:03,939 --> 00:15:08,049
I get headmaster is the reference that

00:15:05,709 --> 00:15:09,699
I'm pointing to and then I can grab the

00:15:08,049 --> 00:15:12,939
tree from that which will copy basically

00:15:09,699 --> 00:15:16,929
all the the trees changes into my my

00:15:12,939 --> 00:15:20,259
index and then finally we can make our

00:15:16,929 --> 00:15:22,449
changes so get add whatever we want to

00:15:20,259 --> 00:15:23,739
call this thing yet its ID essentially

00:15:22,449 --> 00:15:26,829
and then the data that we want to put

00:15:23,739 --> 00:15:28,779
into it and then we can commit it to

00:15:26,829 --> 00:15:30,279
maintain that commit history we have to

00:15:28,779 --> 00:15:33,220
give it its parents which right now is

00:15:30,279 --> 00:15:35,769
just head that commits meaning the the

00:15:33,220 --> 00:15:37,509
previous commit and then we can tell it

00:15:35,769 --> 00:15:39,040
which head or which reference

00:15:37,509 --> 00:15:41,319
essentially to update ruins update

00:15:39,040 --> 00:15:42,519
master so that's how we do the same

00:15:41,319 --> 00:15:45,189
thing that we did with all those

00:15:42,519 --> 00:15:47,529
porcelain commands and then reading

00:15:45,189 --> 00:15:49,449
things back out relatively easy we say

00:15:47,529 --> 00:15:52,540
okay give me give me access to the

00:15:49,449 --> 00:15:55,749
latest head get the tree from that and

00:15:52,540 --> 00:15:59,709
then it overrides the division operator

00:15:55,749 --> 00:16:04,049
to let you pass in the file name to get

00:15:59,709 --> 00:16:04,049
that blob back so we can say blob data

00:16:04,279 --> 00:16:15,709
you with me so far we need to take like

00:16:07,069 --> 00:16:18,079
a stretching break anything okay so all

00:16:15,709 --> 00:16:20,660
of this is fun but it seems like a lot

00:16:18,079 --> 00:16:23,809
of work we're lazy programmers after all

00:16:20,660 --> 00:16:25,339
we need no RM for everything because

00:16:23,809 --> 00:16:30,470
heaven forbid we have to actually write

00:16:25,339 --> 00:16:33,559
code so don't worry there's some

00:16:30,470 --> 00:16:36,110
libraries out there toy store is a

00:16:33,559 --> 00:16:38,749
really simple key value data store based

00:16:36,110 --> 00:16:41,870
on an active model and there's I wrote

00:16:38,749 --> 00:16:43,490
an adapter get for it and then there's

00:16:41,870 --> 00:16:45,350
also get model which has been around for

00:16:43,490 --> 00:16:48,649
a while I believe that's also based on

00:16:45,350 --> 00:16:50,990
active model either one of them pretty

00:16:48,649 --> 00:16:54,499
much do the same thing so here's what it

00:16:50,990 --> 00:16:57,829
looks like with toy store so I define a

00:16:54,499 --> 00:17:00,379
new class called issue I include toy

00:16:57,829 --> 00:17:01,879
store and I point it to my repo and then

00:17:00,379 --> 00:17:04,250
just define the attributes that I want

00:17:01,879 --> 00:17:05,659
to keep track out so looks similar to

00:17:04,250 --> 00:17:08,959
like active record or if you used

00:17:05,659 --> 00:17:11,929
mongoid or mapper something

00:17:08,959 --> 00:17:15,740
similar to that and now I can use it

00:17:11,929 --> 00:17:18,559
just like I would any existing model so

00:17:15,740 --> 00:17:21,770
i say issue that creates pass in my

00:17:18,559 --> 00:17:24,559
attributes i can get by ID i can update

00:17:21,770 --> 00:17:26,630
attributes i could destroy so behind the

00:17:24,559 --> 00:17:29,559
scenes that's doing all of the commands

00:17:26,630 --> 00:17:32,870
that we just looked at you know when i

00:17:29,559 --> 00:17:34,549
create a new one its stages you know

00:17:32,870 --> 00:17:36,860
creates a new index stages all the

00:17:34,549 --> 00:17:39,470
changes in it copies over the current

00:17:36,860 --> 00:17:41,000
tree and then commits that same thing

00:17:39,470 --> 00:17:43,760
when i update attributes does basically

00:17:41,000 --> 00:17:45,820
the same thing and destroy it just

00:17:43,760 --> 00:17:49,690
removes that entry from the tree

00:17:45,820 --> 00:17:52,990
convince it so there's basically how you

00:17:49,690 --> 00:17:54,580
use get as a database it's still file

00:17:52,990 --> 00:17:57,550
system based which we'll talk about a

00:17:54,580 --> 00:17:59,200
lot of the issues in that but first

00:17:57,550 --> 00:18:03,880
let's talk about some of the reasons why

00:17:59,200 --> 00:18:06,970
this is really awesome first is the ski

00:18:03,880 --> 00:18:10,240
melissande non-relational part like i

00:18:06,970 --> 00:18:14,620
mentioned earlier i love the key value

00:18:10,240 --> 00:18:15,820
stores or no sequel databases i think it

00:18:14,620 --> 00:18:17,560
may not be perfect for every situation

00:18:15,820 --> 00:18:19,630
but i think most of the web apps that we

00:18:17,560 --> 00:18:22,480
write a key value store is actually a

00:18:19,630 --> 00:18:23,590
really good fit because most the time

00:18:22,480 --> 00:18:25,570
we're just treating the database as a

00:18:23,590 --> 00:18:27,190
dumb hash anyway you know we're not

00:18:25,570 --> 00:18:31,630
really taking advantage of the features

00:18:27,190 --> 00:18:33,550
of postcards of mysql and so then I mean

00:18:31,630 --> 00:18:35,710
a word on the the schema listen and on

00:18:33,550 --> 00:18:37,480
relational part I think a lot of people

00:18:35,710 --> 00:18:39,580
are worried okay if I use a schema lyst

00:18:37,480 --> 00:18:41,140
database then that means my application

00:18:39,580 --> 00:18:42,340
doesn't have a schema that you know

00:18:41,140 --> 00:18:45,160
people can just throw things in there

00:18:42,340 --> 00:18:47,500
however they want but the thing with a

00:18:45,160 --> 00:18:48,850
scheme euless database is your only

00:18:47,500 --> 00:18:50,590
saying that the database doesn't care

00:18:48,850 --> 00:18:52,780
what the schema is your application

00:18:50,590 --> 00:18:55,330
still has a schema and it enforces it I

00:18:52,780 --> 00:18:57,490
mean an active record AB or in a typical

00:18:55,330 --> 00:18:59,890
rails app we're already enforcing the

00:18:57,490 --> 00:19:01,630
schema or our data constraints in active

00:18:59,890 --> 00:19:04,690
record the database is doing very little

00:19:01,630 --> 00:19:05,770
to enforce those constraints and so when

00:19:04,690 --> 00:19:07,870
you're using a schema list database

00:19:05,770 --> 00:19:10,630
you're doing the same thing your model

00:19:07,870 --> 00:19:13,540
enforces those constraints and then the

00:19:10,630 --> 00:19:16,510
non-relational aspect is interesting

00:19:13,540 --> 00:19:18,220
because you know like a sequel database

00:19:16,510 --> 00:19:21,550
is going to make a lot of optimizations

00:19:18,220 --> 00:19:23,590
you know you can do joins to to define

00:19:21,550 --> 00:19:26,080
your relationships you don't really get

00:19:23,590 --> 00:19:28,930
that power in these schemas databases

00:19:26,080 --> 00:19:31,510
earlier the key value stores anyway you

00:19:28,930 --> 00:19:34,030
have to you have to define the way that

00:19:31,510 --> 00:19:35,800
those relationships work yourself so

00:19:34,030 --> 00:19:38,890
what that might look like so let's say

00:19:35,800 --> 00:19:40,450
our issue tracker the that we built if I

00:19:38,890 --> 00:19:45,040
wanted to put a bunch of issues into a

00:19:40,450 --> 00:19:47,170
milestone you know I might I might

00:19:45,040 --> 00:19:48,380
decide just to declare a milestone ID on

00:19:47,170 --> 00:19:51,080
issue and then

00:19:48,380 --> 00:19:53,540
have to query for all of those issues

00:19:51,080 --> 00:19:55,640
but what you like in in our get database

00:19:53,540 --> 00:19:57,560
it's really hard to look through all of

00:19:55,640 --> 00:20:00,500
the files that have that milestone ID

00:19:57,560 --> 00:20:03,560
there's not an easy way to index that so

00:20:00,500 --> 00:20:06,470
maybe you will actually create in your

00:20:03,560 --> 00:20:08,570
milestone record you'll have a list of

00:20:06,470 --> 00:20:09,770
issue IDs and so to get all the issues

00:20:08,570 --> 00:20:12,050
in that milestone you just read the

00:20:09,770 --> 00:20:13,820
milestone and then load each of those

00:20:12,050 --> 00:20:15,680
IDs separately but anyway the point

00:20:13,820 --> 00:20:17,600
being you do to clear how the

00:20:15,680 --> 00:20:19,760
relationships work and you kind of

00:20:17,600 --> 00:20:21,920
optimize them for your use case there's

00:20:19,760 --> 00:20:26,260
not you know like one fourth normal form

00:20:21,920 --> 00:20:26,260
in a key value store

00:20:30,200 --> 00:20:35,870
obviously using it as a database gives

00:20:33,590 --> 00:20:39,320
you versioning given that's what kit is

00:20:35,870 --> 00:20:41,000
really good at I think this is a really

00:20:39,320 --> 00:20:42,890
interesting use case for a lot of apps

00:20:41,000 --> 00:20:44,810
like imagine if you could see every time

00:20:42,890 --> 00:20:50,000
every record was ever changed and who

00:20:44,810 --> 00:20:55,010
did it so we get history I can look back

00:20:50,000 --> 00:20:57,200
and see who did the changes and why we

00:20:55,010 --> 00:21:00,200
can give you diff so this is from the

00:20:57,200 --> 00:21:02,690
from gasket the app today was was

00:21:00,200 --> 00:21:06,350
referencing and I can see on Wednesday

00:21:02,690 --> 00:21:08,240
August 31st Jonathan Hawaii updated this

00:21:06,350 --> 00:21:10,310
record and you can actually see his

00:21:08,240 --> 00:21:12,860
changes so he changed the description

00:21:10,310 --> 00:21:15,380
from just style editor to hey I need a

00:21:12,860 --> 00:21:17,630
mock up right now and then he changed

00:21:15,380 --> 00:21:19,070
the status I don't think you see there

00:21:17,630 --> 00:21:22,630
we change the status from pending to

00:21:19,070 --> 00:21:22,630
started so we started working on it

00:21:23,680 --> 00:21:28,250
there's some interesting opportunities

00:21:25,790 --> 00:21:30,470
with hooks so inside of get inside of

00:21:28,250 --> 00:21:32,390
your git repo there's a hoax directory

00:21:30,470 --> 00:21:34,820
which are scripts that are run every

00:21:32,390 --> 00:21:36,470
time certain actions or performs so

00:21:34,820 --> 00:21:38,690
we've got things like you know whenever

00:21:36,470 --> 00:21:41,140
a patch is applied whenever commit

00:21:38,690 --> 00:21:43,400
messages entered pre-commit post commit

00:21:41,140 --> 00:21:45,410
you know the receipt whenever you push

00:21:43,400 --> 00:21:46,760
and pull there's are some really

00:21:45,410 --> 00:21:48,290
interesting opportunities to use those

00:21:46,760 --> 00:21:50,120
hooks as part of your application

00:21:48,290 --> 00:21:52,220
lifecycle so let's say you want to

00:21:50,120 --> 00:21:53,660
generate an atom feed every time your

00:21:52,220 --> 00:21:55,640
content changes you could do that as

00:21:53,660 --> 00:21:58,900
part of those hooks instead of waiting

00:21:55,640 --> 00:21:58,900
so the first time it's accessed

00:22:01,480 --> 00:22:06,250
we have replication built in so if you

00:22:04,150 --> 00:22:08,020
have an app that's read heavy it'd be

00:22:06,250 --> 00:22:10,480
really easy to distribute the load you

00:22:08,020 --> 00:22:17,980
just clone that repo to a bunch of other

00:22:10,480 --> 00:22:21,070
servers and use those as to-read from we

00:22:17,980 --> 00:22:23,110
have branches this one was one of the

00:22:21,070 --> 00:22:24,820
things I was most excited about at the

00:22:23,110 --> 00:22:26,890
time that I started exploring this I was

00:22:24,820 --> 00:22:28,809
doing working on a content management

00:22:26,890 --> 00:22:32,110
system I was saying how awesome would it

00:22:28,809 --> 00:22:34,540
be if I could build an alternate version

00:22:32,110 --> 00:22:36,010
of my sight or work on a refresh without

00:22:34,540 --> 00:22:37,570
actually publishing it live so

00:22:36,010 --> 00:22:40,210
essentially in the database layer I

00:22:37,570 --> 00:22:41,890
would just be making a branch make my

00:22:40,210 --> 00:22:45,429
changes for my site and then once it was

00:22:41,890 --> 00:22:46,540
done merge it back in so I think I mean

00:22:45,429 --> 00:22:49,240
there could be really interesting things

00:22:46,540 --> 00:22:51,700
like you know imagine a recipe site that

00:22:49,240 --> 00:22:53,350
you know or like I'm into brewing it'd

00:22:51,700 --> 00:22:55,419
be awesome to have a site where you

00:22:53,350 --> 00:22:57,130
could have recipes for brewing that

00:22:55,419 --> 00:23:01,299
people could fork and make changes to

00:22:57,130 --> 00:23:03,309
and merge them back in or you just use

00:23:01,299 --> 00:23:06,730
github for that

00:23:03,309 --> 00:23:12,190
and then lastly why does this idea suck

00:23:06,730 --> 00:23:14,889
and there are many ways basically

00:23:12,190 --> 00:23:16,809
everything that is good about things

00:23:14,889 --> 00:23:19,059
that are meant to be databases yet does

00:23:16,809 --> 00:23:23,019
not have so the whole idea of like

00:23:19,059 --> 00:23:24,970
transactions you know referential

00:23:23,019 --> 00:23:26,289
integrity all of that stuff like that

00:23:24,970 --> 00:23:28,840
you know there's a lot that goes into

00:23:26,289 --> 00:23:31,299
building a good data store you know

00:23:28,840 --> 00:23:33,159
things like react cassandra like they're

00:23:31,299 --> 00:23:35,409
optimized for certain use cases and

00:23:33,159 --> 00:23:37,090
those are really hard problems to solve

00:23:35,409 --> 00:23:39,509
and and get doesn't care about any of

00:23:37,090 --> 00:23:43,749
them because it's not meant for this so

00:23:39,509 --> 00:23:46,299
race conditions are abound in in this

00:23:43,749 --> 00:23:47,200
scenario so imagine you know we have

00:23:46,299 --> 00:23:50,379
this code that we looked at earlier

00:23:47,200 --> 00:23:52,509
where X a repoed get headmaster so give

00:23:50,379 --> 00:23:55,419
me the last last version of my data and

00:23:52,509 --> 00:23:57,129
then I copy over the tree at this point

00:23:55,419 --> 00:23:59,710
I'm hoping that nobody else is changing

00:23:57,129 --> 00:24:01,299
any data right now because if there's

00:23:59,710 --> 00:24:03,340
another process that's doing the same

00:24:01,299 --> 00:24:05,679
thing either their changes or mine are

00:24:03,340 --> 00:24:08,289
going to get lost so then when i go to

00:24:05,679 --> 00:24:12,159
commit this here if anything changed

00:24:08,289 --> 00:24:14,409
between there I'm screwed so let mean

00:24:12,159 --> 00:24:17,019
the way around that is you can do a lock

00:24:14,409 --> 00:24:19,210
file but now again we're we're limiting

00:24:17,019 --> 00:24:21,249
our right performance because only one

00:24:19,210 --> 00:24:23,340
process can write to this there can

00:24:21,249 --> 00:24:25,779
update the current reference at a time

00:24:23,340 --> 00:24:27,519
so here's same thing you know create a

00:24:25,779 --> 00:24:29,379
lock file and then within that lock I

00:24:27,519 --> 00:24:31,539
get get a reference to the head copy the

00:24:29,379 --> 00:24:37,029
tree over and then

00:24:31,539 --> 00:24:40,929
back merge conflicts suck in coding and

00:24:37,029 --> 00:24:42,460
they suck even worse in data this was

00:24:40,929 --> 00:24:45,190
probably one of the biggest frustrations

00:24:42,460 --> 00:24:47,859
while we were working on that on gasket

00:24:45,190 --> 00:24:49,239
the issue tracking app we would you know

00:24:47,859 --> 00:24:51,700
height and I would both be working on it

00:24:49,239 --> 00:24:54,399
and I would update some stories and push

00:24:51,700 --> 00:24:57,340
and he would had already updated them or

00:24:54,399 --> 00:24:59,679
changed something else in them and at

00:24:57,340 --> 00:25:01,359
the time right now we still don't have a

00:24:59,679 --> 00:25:03,820
way to automatically resolve those merge

00:25:01,359 --> 00:25:05,769
conflicts in code I spent a little bit

00:25:03,820 --> 00:25:08,259
of time trying to figure that out and I

00:25:05,769 --> 00:25:10,779
couldn't so hopefully there's someone

00:25:08,259 --> 00:25:12,779
else smarter that can like what I wanted

00:25:10,779 --> 00:25:15,700
to be able to do is just say okay

00:25:12,779 --> 00:25:18,009
basically apply take each attribute that

00:25:15,700 --> 00:25:20,919
changed and whatever the latest version

00:25:18,009 --> 00:25:24,129
is of that take that but i would have to

00:25:20,919 --> 00:25:27,039
you know like parse the angle bracket

00:25:24,129 --> 00:25:28,179
merge conflict thing and anyway we

00:25:27,039 --> 00:25:32,080
didn't we didn't spend much time on it

00:25:28,179 --> 00:25:35,799
but it's kind of a sucky problem the

00:25:32,080 --> 00:25:38,229
other problem is get is not web scale if

00:25:35,799 --> 00:25:41,080
you haven't watched this video you

00:25:38,229 --> 00:25:44,859
should just search mongodb web scale

00:25:41,080 --> 00:25:46,869
it's kind of funny get is not web scale

00:25:44,859 --> 00:25:48,999
though there's a hard right limit per

00:25:46,869 --> 00:25:51,460
repo so we're dealing with files here

00:25:48,999 --> 00:25:53,979
get does nothing as in terms of like

00:25:51,460 --> 00:25:56,679
caching or you know buffering rights or

00:25:53,979 --> 00:25:59,320
anything like that so I wrote a little

00:25:56,679 --> 00:26:01,509
test script that just committed over and

00:25:59,320 --> 00:26:04,690
over as fast as it could and on my

00:26:01,509 --> 00:26:07,450
laptop solid-state drive makela care I

00:26:04,690 --> 00:26:09,580
got almost 100 commits a second which

00:26:07,450 --> 00:26:12,279
for most projects is probably not

00:26:09,580 --> 00:26:14,830
sufficient there's many I mean there's a

00:26:12,279 --> 00:26:16,239
ton of projects that business fine but

00:26:14,830 --> 00:26:18,940
once you get to a certain scale this

00:26:16,239 --> 00:26:22,119
obviously won't work the other issue

00:26:18,940 --> 00:26:23,710
with it is the pathnames matter so the

00:26:22,119 --> 00:26:25,509
first script that I wrote was only

00:26:23,710 --> 00:26:28,090
updating one file over and over and over

00:26:25,509 --> 00:26:30,909
so that's like the most you know ideal

00:26:28,090 --> 00:26:32,769
use case so in this one I just say okay

00:26:30,909 --> 00:26:35,109
let's create a thousand keys and update

00:26:32,769 --> 00:26:38,049
them over and over and I end up getting

00:26:35,109 --> 00:26:40,599
like 14 commits a second so what's

00:26:38,049 --> 00:26:42,100
happening is all thousand of these files

00:26:40,599 --> 00:26:44,200
are in the same directory

00:26:42,100 --> 00:26:47,020
so every time I change one of them I

00:26:44,200 --> 00:26:50,169
have to copy over the shaws for every

00:26:47,020 --> 00:26:52,390
single blob in that directory so that's

00:26:50,169 --> 00:26:55,720
I'm again one of the one of the issues

00:26:52,390 --> 00:26:58,450
with gets fundamental design not being

00:26:55,720 --> 00:27:00,100
optimized for this is I have to keep a

00:26:58,450 --> 00:27:03,270
reference to the to the latest version

00:27:00,100 --> 00:27:05,890
of all of these things in my in my tree

00:27:03,270 --> 00:27:09,390
and so I'm having to constantly copy

00:27:05,890 --> 00:27:12,309
those over one way to get around that is

00:27:09,390 --> 00:27:14,710
simply to nest I basically do what get

00:27:12,309 --> 00:27:18,159
does internally in its file system in

00:27:14,710 --> 00:27:21,070
its object database so here I basically

00:27:18,159 --> 00:27:22,809
create all the files nested so if the

00:27:21,070 --> 00:27:25,120
Shah starts with a0 I create a directory

00:27:22,809 --> 00:27:26,890
called zero put them inside of that the

00:27:25,120 --> 00:27:29,650
next character is another zero then they

00:27:26,890 --> 00:27:31,659
go inside of there in this case so like

00:27:29,650 --> 00:27:34,360
with these thousand files again I'm back

00:27:31,659 --> 00:27:38,710
up to 67 commits a second which isn't

00:27:34,360 --> 00:27:40,030
bad if this file right here changes then

00:27:38,710 --> 00:27:42,760
it's going to have to rewrite everything

00:27:40,030 --> 00:27:45,220
in this tree everything in this tree so

00:27:42,760 --> 00:27:46,600
0 through 9 and then everything at the

00:27:45,220 --> 00:27:50,559
top level so you're still rewriting

00:27:46,600 --> 00:27:54,880
several trees but it's a lot less than

00:27:50,559 --> 00:27:58,690
then if they're all flat there was this

00:27:54,880 --> 00:28:01,510
post back in February some people from

00:27:58,690 --> 00:28:03,880
facebook said hey get doesn't work for

00:28:01,510 --> 00:28:06,970
us because Facebook uses one giant git

00:28:03,880 --> 00:28:08,559
repo and just some stats from this email

00:28:06,970 --> 00:28:11,289
that they posted they basically did a

00:28:08,559 --> 00:28:14,740
test with four million commits 1.3

00:28:11,289 --> 00:28:16,510
million files 15 gigs of data when

00:28:14,740 --> 00:28:18,220
they'd run git repack which is basically

00:28:16,510 --> 00:28:19,720
the way of saying ok take all of the

00:28:18,220 --> 00:28:22,840
history and kind of pack it up in a nice

00:28:19,720 --> 00:28:25,450
file so it's more concise took two days

00:28:22,840 --> 00:28:28,419
a simple get status would take like 39

00:28:25,450 --> 00:28:30,100
minutes when they first ran it simply

00:28:28,419 --> 00:28:31,750
adding a file calling get ad which just

00:28:30,100 --> 00:28:34,030
stages the changes was taking seven

00:28:31,750 --> 00:28:36,140
seconds and then actually commit it took

00:28:34,030 --> 00:28:38,300
41 minutes

00:28:36,140 --> 00:28:40,130
I don't know I didn't really follow this

00:28:38,300 --> 00:28:41,770
thread closely and I imagine that

00:28:40,130 --> 00:28:44,680
there's a lot of other issues besides

00:28:41,770 --> 00:28:46,670
the main stats that they listed but

00:28:44,680 --> 00:28:48,710
you're definitely going to run into some

00:28:46,670 --> 00:28:54,230
issue when you have large repos with a

00:28:48,710 --> 00:28:57,710
lot of history so then basically before

00:28:54,230 --> 00:28:59,390
we're done here which I want to talk

00:28:57,710 --> 00:29:01,310
about some of the things that we've done

00:28:59,390 --> 00:29:04,670
at github to take it around this because

00:29:01,310 --> 00:29:07,640
obviously our primary back-end is get

00:29:04,670 --> 00:29:11,290
and we still use MySQL for a lot in a

00:29:07,640 --> 00:29:16,490
lot of data but we're serving git repos

00:29:11,290 --> 00:29:19,280
so while ago 2008 Tom posted this how we

00:29:16,490 --> 00:29:21,440
made github fast and this was as part of

00:29:19,280 --> 00:29:24,380
the the move to rackspace basically like

00:29:21,440 --> 00:29:27,170
the architecture changes that came along

00:29:24,380 --> 00:29:29,930
with that and the secret sauce behind

00:29:27,170 --> 00:29:33,080
this was with smoke it's a library we

00:29:29,930 --> 00:29:35,780
wrote the sits on top of grit or it sits

00:29:33,080 --> 00:29:37,430
in front of grit really and what are

00:29:35,780 --> 00:29:39,590
what the infrastructure pretty much

00:29:37,430 --> 00:29:42,830
still looks like today even four years

00:29:39,590 --> 00:29:44,810
later is we have github com and we have

00:29:42,830 --> 00:29:46,610
this really simple router that's just a

00:29:44,810 --> 00:29:48,980
little like Redis app or a little app

00:29:46,610 --> 00:29:50,720
that users notice as its database and

00:29:48,980 --> 00:29:53,180
every time we create a new repo we add a

00:29:50,720 --> 00:29:56,150
entry in there for routing and we say

00:29:53,180 --> 00:29:59,540
okay this repo points to this disk over

00:29:56,150 --> 00:30:02,420
here and then we have the this Erlang

00:29:59,540 --> 00:30:05,510
RPC layer that actually does all of the

00:30:02,420 --> 00:30:08,120
the get fetches and so well I mean what

00:30:05,510 --> 00:30:09,950
this bodice was our limit is on the file

00:30:08,120 --> 00:30:12,740
system right where we're trying to fetch

00:30:09,950 --> 00:30:14,030
your repos and serve them up the problem

00:30:12,740 --> 00:30:16,640
is that one file system can only do so

00:30:14,030 --> 00:30:18,560
much and this allowed us to distribute

00:30:16,640 --> 00:30:21,700
the load so every single file or every

00:30:18,560 --> 00:30:23,780
single disk holds different repos and

00:30:21,700 --> 00:30:25,190
hopefully they're all not being accessed

00:30:23,780 --> 00:30:27,530
at the same time

00:30:25,190 --> 00:30:29,690
so there's still a hard right limit for

00:30:27,530 --> 00:30:31,670
repo you know if somebody like for

00:30:29,690 --> 00:30:33,200
example I know the WebKit repo is kind

00:30:31,670 --> 00:30:35,690
of a pain for us often because there's

00:30:33,200 --> 00:30:37,550
tons and tons of data in it like a clone

00:30:35,690 --> 00:30:40,250
takes I don't even know how long it's

00:30:37,550 --> 00:30:44,270
like like 15 gigs or something like that

00:30:40,250 --> 00:30:46,790
takes forever um so I mean we still have

00:30:44,270 --> 00:30:48,020
these these limitations per disk but

00:30:46,790 --> 00:30:49,730
we've been able we're able to distribute

00:30:48,020 --> 00:30:53,930
the disks or distribute the load out

00:30:49,730 --> 00:30:55,610
over a lot of disks so then lastly it

00:30:53,930 --> 00:30:57,080
talks a little bit about this but a few

00:30:55,610 --> 00:30:59,840
use cases where I still think that this

00:30:57,080 --> 00:31:01,970
is a great idea anything that's content

00:30:59,840 --> 00:31:05,480
heavy it is the the stupid content

00:31:01,970 --> 00:31:07,660
tracker after all so I think I would

00:31:05,480 --> 00:31:11,120
love to see a content management system

00:31:07,660 --> 00:31:13,310
that my wife could use built with get

00:31:11,120 --> 00:31:15,950
behind it I mean we have you know github

00:31:13,310 --> 00:31:17,300
pages is awesome for developers actually

00:31:15,950 --> 00:31:21,500
I did get my wife even get have pages

00:31:17,300 --> 00:31:23,090
but that was quite an experience but I

00:31:21,500 --> 00:31:24,650
would love to see like a really simple

00:31:23,090 --> 00:31:27,350
content management system bill would get

00:31:24,650 --> 00:31:29,780
behind it it's awesome for translations

00:31:27,350 --> 00:31:31,400
I know a guy that he didn't do it yet he

00:31:29,780 --> 00:31:34,270
did it with material but he builds

00:31:31,400 --> 00:31:36,590
translation software in their company

00:31:34,270 --> 00:31:38,180
they'll go into like remote villages in

00:31:36,590 --> 00:31:41,030
Africa and help them translate like

00:31:38,180 --> 00:31:42,350
classic texts and you know sometimes

00:31:41,030 --> 00:31:43,700
there's not internet connections there

00:31:42,350 --> 00:31:47,840
so they'll just take a flash drive with

00:31:43,700 --> 00:31:51,020
the app and mercurial data material repo

00:31:47,840 --> 00:31:52,910
on it work on the translation and then

00:31:51,020 --> 00:31:56,330
whenever they come back they just bring

00:31:52,910 --> 00:31:58,760
that flash drive pull it back in do

00:31:56,330 --> 00:31:59,720
emerge into the main main code base and

00:31:58,760 --> 00:32:02,570
now and they have all of these

00:31:59,720 --> 00:32:05,210
translations together so I think it's an

00:32:02,570 --> 00:32:08,900
awesome use case for it wiki's as well

00:32:05,210 --> 00:32:11,020
we owe get hub wiki is still backed by

00:32:08,900 --> 00:32:13,820
get

00:32:11,020 --> 00:32:16,070
the other the other use case or at least

00:32:13,820 --> 00:32:18,500
a condition for a use case as your app

00:32:16,070 --> 00:32:20,870
has to be partitioned bull if you have

00:32:18,500 --> 00:32:23,210
if you're planning to back an entire app

00:32:20,870 --> 00:32:25,610
with one get repo it's not going to work

00:32:23,210 --> 00:32:28,460
if you have any kind of heavy load I

00:32:25,610 --> 00:32:30,200
mean you have to be able to to break up

00:32:28,460 --> 00:32:32,240
into multiple repos so I mean obviously

00:32:30,200 --> 00:32:34,970
use cases github that's exactly what

00:32:32,240 --> 00:32:36,980
we're doing project management so like

00:32:34,970 --> 00:32:39,410
this issue tracker thing would you know

00:32:36,980 --> 00:32:42,110
I don't know if it be possible for us to

00:32:39,410 --> 00:32:43,760
build github issues back by get but I

00:32:42,110 --> 00:32:48,620
think it's an interesting idea it would

00:32:43,760 --> 00:32:50,240
be fun to pursue and I mean again

00:32:48,620 --> 00:32:53,030
another precondition is it has to be

00:32:50,240 --> 00:32:55,100
read heavy and right light I mean if you

00:32:53,030 --> 00:32:59,510
have given app that's right heavy I

00:32:55,100 --> 00:33:01,780
don't think it is a great great solution

00:32:59,510 --> 00:33:01,780
to that

00:33:02,310 --> 00:33:08,400
some examples techno weenie rick wilson

00:33:05,750 --> 00:33:11,340
also works at github had done a lot of

00:33:08,400 --> 00:33:13,590
work prior to me on this he built madrox

00:33:11,340 --> 00:33:16,710
which is like a example like Twitter

00:33:13,590 --> 00:33:19,560
type app where you post statuses as

00:33:16,710 --> 00:33:21,330
commit messages and then you can emerge

00:33:19,560 --> 00:33:25,740
other people's commits and/or their

00:33:21,330 --> 00:33:28,740
statuses in to your stream golem is what

00:33:25,740 --> 00:33:32,750
backs github wikis so check that out and

00:33:28,740 --> 00:33:36,090
then gasket is the staff today demoed

00:33:32,750 --> 00:33:38,190
then finally a few credits GRIK olson

00:33:36,090 --> 00:33:39,720
gave a talk similar to this I had no

00:33:38,190 --> 00:33:43,170
idea he'd given it when I proposed this

00:33:39,720 --> 00:33:45,480
one so I I picked his brain and used a

00:33:43,170 --> 00:33:47,790
little bit of his stuff the peacoat

00:33:45,480 --> 00:33:50,340
internals is old but it's still awesome

00:33:47,790 --> 00:33:51,930
for understanding the internal to get I

00:33:50,340 --> 00:33:54,450
don't know if there's a better resource

00:33:51,930 --> 00:33:58,020
out there now but I still occasionally

00:33:54,450 --> 00:34:00,020
will go back to that and then lastly I a

00:33:58,020 --> 00:34:03,660
couple of my co-workers I need to thank

00:34:00,020 --> 00:34:05,340
I send an email to Ryan tomato our

00:34:03,660 --> 00:34:08,280
director of engineering saying hey um

00:34:05,340 --> 00:34:09,540
this was back in I think March I'm going

00:34:08,280 --> 00:34:12,030
to be working on this talk I just kind

00:34:09,540 --> 00:34:13,680
of want to make sure that I'm not full

00:34:12,030 --> 00:34:16,050
of crap because I don't know all the

00:34:13,680 --> 00:34:17,370
details of the internals and we went

00:34:16,050 --> 00:34:20,430
back and forth a little bit you can see

00:34:17,370 --> 00:34:22,200
the thread and then I had a few other

00:34:20,430 --> 00:34:24,000
questions you know as anyone

00:34:22,200 --> 00:34:26,400
experimenting experimented with backing

00:34:24,000 --> 00:34:27,690
get objects with refs our arrest with

00:34:26,400 --> 00:34:29,850
react or any other kind of key value

00:34:27,690 --> 00:34:32,580
store and he basically came back he's

00:34:29,850 --> 00:34:35,490
like I don't know let's ask peff the guy

00:34:32,580 --> 00:34:36,690
that was suckin his toe and the best way

00:34:35,490 --> 00:34:38,760
for me to illustrate this was a video

00:34:36,690 --> 00:34:41,100
that writes back with his email that's

00:34:38,760 --> 00:34:43,830
like five thousand words long like

00:34:41,100 --> 00:34:45,450
broken up into sections of like all the

00:34:43,830 --> 00:34:46,680
different things that he's looked at and

00:34:45,450 --> 00:34:49,470
talked about and all the issues that

00:34:46,680 --> 00:34:51,869
you'll have so

00:34:49,470 --> 00:34:53,070
I don't know if that's published but we

00:34:51,869 --> 00:34:55,639
should publish it there's a lot of good

00:34:53,070 --> 00:34:58,940
info so anyway thanks to those guys

00:34:55,639 --> 00:34:58,940
anyone have any questions

00:35:03,040 --> 00:35:16,850
you show me 20 minutes 20 minutes yeah I

00:35:15,500 --> 00:35:21,530
does anyone know I have no idea what

00:35:16,850 --> 00:35:23,210
they ended up doing I don't know I mean

00:35:21,530 --> 00:35:24,380
everybody like part of that thread

00:35:23,210 --> 00:35:28,369
everyone was saying we'll obviously

00:35:24,380 --> 00:35:31,190
don't put your entire company's code in

00:35:28,369 --> 00:35:32,570
one repo but I still think I think to

00:35:31,190 --> 00:35:34,609
this day facebook still works like that

00:35:32,570 --> 00:35:37,310
everything that's facebook is in one

00:35:34,609 --> 00:35:39,050
repo I don't know if they're on I don't

00:35:37,310 --> 00:35:40,430
even know if they had tried switching to

00:35:39,050 --> 00:35:43,280
get yet at that point if they were still

00:35:40,430 --> 00:35:45,369
on the subversion or something I have no

00:35:43,280 --> 00:35:45,369
idea

00:35:46,870 --> 00:35:52,450
yeah yeah if you get rid of some of the

00:35:49,990 --> 00:35:55,450
history that would help but I still

00:35:52,450 --> 00:35:57,310
there was like what like let's go back

00:35:55,450 --> 00:35:59,380
to the X there was like 1 million files

00:35:57,310 --> 00:36:00,790
or something like that like I don't know

00:35:59,380 --> 00:36:09,150
how you have that many files in the

00:36:00,790 --> 00:36:09,150
project oops I won't see Clark

00:36:09,920 --> 00:36:12,640
good night

00:36:14,820 --> 00:36:21,010
yeah there we go yeah 1.3 million files

00:36:18,130 --> 00:36:24,210
like how do you have that many lines of

00:36:21,010 --> 00:36:28,750
files with code in a single project I

00:36:24,210 --> 00:36:30,850
don't know yeah what do you think is a

00:36:28,750 --> 00:36:33,630
reasonable limit to the number of party

00:36:30,850 --> 00:36:37,120
like partitions you you should have like

00:36:33,630 --> 00:36:41,380
like if I have let's say a database of a

00:36:37,120 --> 00:36:45,310
time series I have 6,000 I have 12,000

00:36:41,380 --> 00:36:48,160
time series set for this kind of award I

00:36:45,310 --> 00:36:50,140
mean so like the way that we have it on

00:36:48,160 --> 00:36:52,660
github right now when we could scale

00:36:50,140 --> 00:36:54,670
what we currently have infinitely we

00:36:52,660 --> 00:36:58,960
just have to keep adding disks and like

00:36:54,670 --> 00:37:01,330
I know I think we're up to like 24 file

00:36:58,960 --> 00:37:04,780
servers with each with like 16 discs

00:37:01,330 --> 00:37:08,500
right now something in that range and so

00:37:04,780 --> 00:37:12,310
I mean I think that that that will scale

00:37:08,500 --> 00:37:14,890
infinitely as long as each disc can keep

00:37:12,310 --> 00:37:16,840
up with the right load or essentially

00:37:14,890 --> 00:37:20,470
the right load that we have I don't

00:37:16,840 --> 00:37:21,850
think the reload is a huge issue see I

00:37:20,470 --> 00:37:25,140
mean I don't know if that helps I think

00:37:21,850 --> 00:37:25,140
it mostly depends on the

00:37:28,520 --> 00:37:31,240
really

00:37:35,440 --> 00:37:40,319
get that same for protocol and

00:37:45,790 --> 00:37:54,550
awesome yes I was interesting we did so

00:37:50,590 --> 00:37:57,820
part of the that big thread with Jeff

00:37:54,550 --> 00:38:00,700
King that was like a book one of my

00:37:57,820 --> 00:38:02,860
questions was why not back get with a

00:38:00,700 --> 00:38:05,470
real key value store like react or

00:38:02,860 --> 00:38:06,880
cassander or something like that and we

00:38:05,470 --> 00:38:08,200
looked into it i think scott chacon

00:38:06,880 --> 00:38:10,030
built something a while ago and then

00:38:08,200 --> 00:38:13,510
somebody at Google built it back with

00:38:10,030 --> 00:38:16,450
Cassandra and the main issue is just the

00:38:13,510 --> 00:38:18,610
latency and that I mean get score model

00:38:16,450 --> 00:38:21,130
is it's like self-referential so you

00:38:18,610 --> 00:38:23,080
pull back a reference which is a commit

00:38:21,130 --> 00:38:24,910
that commits has a bunch of shots you

00:38:23,080 --> 00:38:27,010
have to go ask for those jaws which are

00:38:24,910 --> 00:38:28,510
you know the trees that you have to go

00:38:27,010 --> 00:38:30,670
back and ask for blobs and if you're

00:38:28,510 --> 00:38:33,100
doing like a git log your kind of

00:38:30,670 --> 00:38:34,600
recursively doing that so in every round

00:38:33,100 --> 00:38:37,360
trip to the database let's say it took

00:38:34,600 --> 00:38:40,960
like 20 milliseconds I think the latency

00:38:37,360 --> 00:38:43,350
is just way too slow awesome thank you

00:38:40,960 --> 00:38:43,350
very much

00:38:53,870 --> 00:38:55,930

YouTube URL: https://www.youtube.com/watch?v=fjN4c4RWiV0


