Title: Why JRuby? by Charles Nutter
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGgW/
Captions: 
	00:00:14,900 --> 00:00:21,240
okay it's three o'clock now I guess

00:00:18,270 --> 00:00:23,009
we'll just get going okay so I talked a

00:00:21,240 --> 00:00:24,840
little bit about why AJ Ruiz interesting

00:00:23,009 --> 00:00:25,950
maybe give some fun demos and hopefully

00:00:24,840 --> 00:00:28,710
have time for some questions at the end

00:00:25,950 --> 00:00:31,410
I'm Charles nutter I've been doing Java

00:00:28,710 --> 00:00:33,899
since the beginning pretty much doing

00:00:31,410 --> 00:00:36,630
Ruby actually since 2004 when I went to

00:00:33,899 --> 00:00:39,420
a ruby coffin rest in that time working

00:00:36,630 --> 00:00:40,770
on JRuby full-time since 2006 kind of

00:00:39,420 --> 00:00:44,100
crazy that's been actually six years now

00:00:40,770 --> 00:00:45,680
of just working on JRuby and I'm not

00:00:44,100 --> 00:00:48,210
bored of it which is even more amazing

00:00:45,680 --> 00:00:51,060
and now I'm actually we moved to red hat

00:00:48,210 --> 00:00:52,470
in the jboss polyglot server group where

00:00:51,060 --> 00:00:55,320
we're doing some fun stuff I'll show

00:00:52,470 --> 00:00:57,600
later so first of all what is JRuby

00:00:55,320 --> 00:01:02,220
hopefully is it has anybody played with

00:00:57,600 --> 00:01:06,509
JRuby before ever okay about half the

00:01:02,220 --> 00:01:08,009
room so so jruby well you can look in

00:01:06,509 --> 00:01:10,290
the book I mean we got this book we've

00:01:08,009 --> 00:01:12,030
got a deploying JRuby book but JRuby is

00:01:10,290 --> 00:01:14,820
basically just Ruby running on the JVM

00:01:12,030 --> 00:01:17,939
or you know a better a better different

00:01:14,820 --> 00:01:20,069
vm for running Ruby code most of it's

00:01:17,939 --> 00:01:21,479
written in Java kind of legacy that's

00:01:20,069 --> 00:01:23,579
what the code base was but we're moving

00:01:21,479 --> 00:01:25,170
more and more parts of it into Ruby over

00:01:23,579 --> 00:01:26,909
time which makes it a little bit easier

00:01:25,170 --> 00:01:29,369
for us to maintain a little bit easier

00:01:26,909 --> 00:01:30,719
for folks to contribute to everything's

00:01:29,369 --> 00:01:34,319
pretty much standard standard command

00:01:30,719 --> 00:01:35,909
line we have 1.8 and 1.9 features in the

00:01:34,319 --> 00:01:37,920
box all the time so you can switch

00:01:35,909 --> 00:01:39,149
between them if you're opting for one or

00:01:37,920 --> 00:01:41,280
the other I want to try and play with

00:01:39,149 --> 00:01:43,649
stuff and generally we try to make it

00:01:41,280 --> 00:01:46,170
pretty much a drop-in replacement for

00:01:43,649 --> 00:01:47,759
MRI for standard Ruby and now there's an

00:01:46,170 --> 00:01:50,939
asterisks here because there's a few

00:01:47,759 --> 00:01:52,590
caveats the low-level UNIX stuff like

00:01:50,939 --> 00:01:55,170
low-level file descriptor control

00:01:52,590 --> 00:01:57,420
process control things like fork and

00:01:55,170 --> 00:01:59,909
stuff not quite there some of them were

00:01:57,420 --> 00:02:03,090
adding and improving over time but it's

00:01:59,909 --> 00:02:05,849
an ongoing process we don't really

00:02:03,090 --> 00:02:07,829
support see extensions in junior be 16

00:02:05,849 --> 00:02:10,259
we added support that was built for us

00:02:07,829 --> 00:02:12,930
as part of the Ruby summer of code but

00:02:10,259 --> 00:02:15,300
it proved to be a very big maintenance

00:02:12,930 --> 00:02:18,360
hassle to keep up with especially ruby

00:02:15,300 --> 00:02:20,790
1.9 additions to the api's and very few

00:02:18,360 --> 00:02:23,040
people used it plus the way that the

00:02:20,790 --> 00:02:25,439
Ruby the ubc extension API is designed

00:02:23,040 --> 00:02:26,970
to kind of crippled concurrency crippled

00:02:25,439 --> 00:02:27,960
performance in a lot of different ways

00:02:26,970 --> 00:02:29,880
for the most part that's kind of

00:02:27,960 --> 00:02:31,620
deprecated and we we go back to not

00:02:29,880 --> 00:02:35,280
supporting see extensions but it may not

00:02:31,620 --> 00:02:37,050
matter us all clear up later and then

00:02:35,280 --> 00:02:39,120
like I say some features are different

00:02:37,050 --> 00:02:41,970
or some features are unavailable objects

00:02:39,120 --> 00:02:43,380
base each object for example is not

00:02:41,970 --> 00:02:45,000
always available you have to turn it on

00:02:43,380 --> 00:02:46,800
one of those things that are usually

00:02:45,000 --> 00:02:48,900
done for debugging or profiling purposes

00:02:46,800 --> 00:02:50,940
so it may not be a big deal trace

00:02:48,900 --> 00:02:52,320
functions turn on some debugging support

00:02:50,940 --> 00:02:54,060
and then all the trace events will be

00:02:52,320 --> 00:02:55,860
there little things like that some stuff

00:02:54,060 --> 00:02:58,590
we can't support because vm level wise

00:02:55,860 --> 00:03:02,310
they just don't work like continuations

00:02:58,590 --> 00:03:03,810
and fork and whatnot JRE 17 is the

00:03:02,310 --> 00:03:04,890
release we're working on right now it's

00:03:03,810 --> 00:03:08,250
the one that I'm hoping everybody will

00:03:04,890 --> 00:03:10,500
try out Ruby 193 by default and we've

00:03:08,250 --> 00:03:13,290
done a ton of work to make sure that 193

00:03:10,500 --> 00:03:14,940
behavior is pretty close to a hundred

00:03:13,290 --> 00:03:17,430
percent especially working hard on in

00:03:14,940 --> 00:03:21,180
coatings which has been a big effort and

00:03:17,430 --> 00:03:22,620
a big big change in Ruby 19 not lots of

00:03:21,180 --> 00:03:24,810
lots of performance improvements

00:03:22,620 --> 00:03:26,970
especially around concurrency straight

00:03:24,810 --> 00:03:29,160
line execution performance we've also

00:03:26,970 --> 00:03:31,050
added in support for Java sevens invoke

00:03:29,160 --> 00:03:33,000
dynamic which I'll talk about in a bit

00:03:31,050 --> 00:03:34,980
basically gives us a much better

00:03:33,000 --> 00:03:36,510
possibility for optimizing Ruby in the

00:03:34,980 --> 00:03:38,790
future and we have the beginnings of a

00:03:36,510 --> 00:03:41,840
new optimizing compiler with in JRuby

00:03:38,790 --> 00:03:44,580
before we even give the code to the JVM

00:03:41,840 --> 00:03:46,530
so getting started with JRuby now you

00:03:44,580 --> 00:03:48,030
need a JVM installed most platforms have

00:03:46,530 --> 00:03:50,250
a bill that's pretty easy to get in some

00:03:48,030 --> 00:03:52,620
way we have a blog post on the JRuby

00:03:50,250 --> 00:03:56,519
blog that says how to get java 7 setup

00:03:52,620 --> 00:03:58,320
on linux windows OS 10 etc very easy to

00:03:56,519 --> 00:04:00,930
get it up and going and then if you're

00:03:58,320 --> 00:04:03,120
using our vm r vm install JRuby will get

00:04:00,930 --> 00:04:06,150
the current major release which would be

00:04:03,120 --> 00:04:08,489
168 right now I encourage you to try out

00:04:06,150 --> 00:04:10,260
the 17 RC because we're real close to

00:04:08,489 --> 00:04:12,630
release now and we'd like to like to

00:04:10,260 --> 00:04:13,799
roust out any final bugs or you can

00:04:12,630 --> 00:04:16,019
pretty much just download it manually

00:04:13,799 --> 00:04:18,900
there's no build process involved all

00:04:16,019 --> 00:04:21,479
the native bits we pre-built for almost

00:04:18,900 --> 00:04:23,460
a dozen platforms so download a tarball

00:04:21,479 --> 00:04:25,340
unpack it put it in your path and you're

00:04:23,460 --> 00:04:27,900
ready to go you got you here be running

00:04:25,340 --> 00:04:32,460
so let's see what running jruby looks

00:04:27,900 --> 00:04:33,930
like got a basic command line here I'm

00:04:32,460 --> 00:04:36,419
going to run my favorite little

00:04:33,930 --> 00:04:39,200
benchmark which generates a little Julia

00:04:36,419 --> 00:04:41,600
set fractal

00:04:39,200 --> 00:04:42,920
okay finish the flip-flop fractal and I

00:04:41,600 --> 00:04:45,290
like this one cuz it actually builds it

00:04:42,920 --> 00:04:48,760
in the terminal okay so jruby is

00:04:45,290 --> 00:04:50,810
obviously working at this point now I

00:04:48,760 --> 00:04:52,490
have to show the code for this just

00:04:50,810 --> 00:04:53,390
because it's hilarious now this must

00:04:52,490 --> 00:04:57,250
have been part of some sort of

00:04:53,390 --> 00:05:00,080
obfuscation contest because I have

00:04:57,250 --> 00:05:02,450
absolutely no idea how that bottom piece

00:05:00,080 --> 00:05:05,630
of code works has anybody ever used the

00:05:02,450 --> 00:05:07,520
flip-flop operator in Ruby yes of course

00:05:05,630 --> 00:05:10,850
aaron has he uses it all the time that's

00:05:07,520 --> 00:05:12,350
why rails is awesome but yeah I mean

00:05:10,850 --> 00:05:14,780
this is the feature that most people

00:05:12,350 --> 00:05:16,340
even know what it does in Ruby and this

00:05:14,780 --> 00:05:17,810
authors actually managed to stack like

00:05:16,340 --> 00:05:20,270
nine of them together to generate a

00:05:17,810 --> 00:05:22,190
fractal so if you want some homework for

00:05:20,270 --> 00:05:24,140
afterwards you can figure out exactly

00:05:22,190 --> 00:05:25,820
what's going on there so my job today is

00:05:24,140 --> 00:05:27,950
kind of to convince anybody who hasn't

00:05:25,820 --> 00:05:30,590
played with JRuby or tried it out that

00:05:27,950 --> 00:05:32,630
it's really the best Ruby runtime to be

00:05:30,590 --> 00:05:35,030
using and I put an asterisk here because

00:05:32,630 --> 00:05:36,710
it's the best for some definitions of

00:05:35,030 --> 00:05:38,030
best there are various things are going

00:05:36,710 --> 00:05:39,860
to be doing where J Ruby's not the right

00:05:38,030 --> 00:05:41,330
tool but i'm going to show you where i

00:05:39,860 --> 00:05:43,670
think it's really fits and where the

00:05:41,330 --> 00:05:45,200
sweet sweet spots are so first of all

00:05:43,670 --> 00:05:46,850
kind of talking about the jruby team

00:05:45,200 --> 00:05:50,060
this is kind of the baseline of why

00:05:46,850 --> 00:05:52,430
jruby really works as a project most

00:05:50,060 --> 00:05:55,310
people think of JRuby and the JRuby team

00:05:52,430 --> 00:05:57,760
is pretty much me which I do a lot of

00:05:55,310 --> 00:05:59,840
work on it and I do a lot of talks but

00:05:57,760 --> 00:06:02,570
there's much more complicated than that

00:05:59,840 --> 00:06:05,290
the real JRuby team is kind of Tom and I

00:06:02,570 --> 00:06:07,400
up at the top of the team here

00:06:05,290 --> 00:06:08,990
orchestrating things herding cats and

00:06:07,400 --> 00:06:10,880
then a whole bunch of other contributors

00:06:08,990 --> 00:06:12,800
that come and go over time that we

00:06:10,880 --> 00:06:14,780
manage on the project and this is

00:06:12,800 --> 00:06:16,790
basically just working on core JRuby and

00:06:14,780 --> 00:06:19,130
libraries that that we've kind of spun

00:06:16,790 --> 00:06:21,890
off to help make JRuby work but there's

00:06:19,130 --> 00:06:23,240
even bigger story to this in that all of

00:06:21,890 --> 00:06:25,730
the different jvms that are out there

00:06:23,240 --> 00:06:27,680
are also part of our team they do all of

00:06:25,730 --> 00:06:28,880
the work to make the vm level operations

00:06:27,680 --> 00:06:31,010
work make it integrate with the

00:06:28,880 --> 00:06:33,200
processor in the operating system and we

00:06:31,010 --> 00:06:35,180
build on top of that so the jruby team

00:06:33,200 --> 00:06:37,480
really includes all of the different JVM

00:06:35,180 --> 00:06:39,650
groups that are doing their great work

00:06:37,480 --> 00:06:41,480
if you look at how jruby is generally

00:06:39,650 --> 00:06:43,190
structured as an implementation we've

00:06:41,480 --> 00:06:44,720
got the part that's JRuby that we work

00:06:43,190 --> 00:06:47,360
on the core team and the contributors

00:06:44,720 --> 00:06:49,550
and whatnot parser the bytecode jit core

00:06:47,360 --> 00:06:51,080
classes job integration other libraries

00:06:49,550 --> 00:06:52,020
related to coatings and regular

00:06:51,080 --> 00:06:53,699
expressions that we have

00:06:52,020 --> 00:06:55,680
have native integration that we've built

00:06:53,699 --> 00:06:57,449
and then the JVM at the bottom that

00:06:55,680 --> 00:07:00,030
implements threading and concurrency

00:06:57,449 --> 00:07:02,909
safe concurrency at the vm level garbage

00:07:00,030 --> 00:07:05,849
collection a native optimizing it

00:07:02,909 --> 00:07:09,360
has its own jni java native extension

00:07:05,849 --> 00:07:12,000
capi and we build on top of this and

00:07:09,360 --> 00:07:13,710
what that means is that basically we

00:07:12,000 --> 00:07:15,770
don't have to worry about any of that

00:07:13,710 --> 00:07:18,659
stuff we don't have to sit and work on

00:07:15,770 --> 00:07:20,639
implementing a GC or debugging a GC

00:07:18,659 --> 00:07:24,030
which is even more fun we don't have to

00:07:20,639 --> 00:07:25,770
write an optimizing native jit the JVM

00:07:24,030 --> 00:07:27,479
guys do that and we just have to

00:07:25,770 --> 00:07:30,870
implement things in the right way to

00:07:27,479 --> 00:07:32,430
utilize the JVM and what this it means

00:07:30,870 --> 00:07:33,960
that there's so many pieces of Jay Ruby

00:07:32,430 --> 00:07:36,180
that we just don't have to do we don't

00:07:33,960 --> 00:07:37,860
have to worry about all this stuff so we

00:07:36,180 --> 00:07:39,300
can focus on making JRuby better and

00:07:37,860 --> 00:07:44,219
it's how we've actually managed to catch

00:07:39,300 --> 00:07:47,729
up with and almost match now Ruby core

00:07:44,219 --> 00:07:51,180
implementation as it as it happens JRuby

00:07:47,729 --> 00:07:53,190
17 has a hidden dash dash 2 2 point 0

00:07:51,180 --> 00:07:54,870
flag that will turn on as several jaber

00:07:53,190 --> 00:07:56,699
Ruby 2 point 0 features that are named

00:07:54,870 --> 00:07:58,259
and released we've kind of caught up now

00:07:56,699 --> 00:08:00,569
and we can keep up with regular Ruby

00:07:58,259 --> 00:08:01,620
development at this point and the bottom

00:08:00,569 --> 00:08:03,690
line here is that we could basically

00:08:01,620 --> 00:08:05,550
stopped working on JRuby today and have

00:08:03,690 --> 00:08:07,710
no one commits anything else and it

00:08:05,550 --> 00:08:09,210
would continue to get faster because the

00:08:07,710 --> 00:08:11,190
JVM guys are there and continue to

00:08:09,210 --> 00:08:13,590
implement that stuff for us so that's

00:08:11,190 --> 00:08:14,789
that's future proof as long as the JVM

00:08:13,590 --> 00:08:16,169
is going to be around we're going to

00:08:14,789 --> 00:08:19,020
continue to get better even if we don't

00:08:16,169 --> 00:08:20,159
do anything all right in the next area

00:08:19,020 --> 00:08:23,090
that get everybody kind of kind of

00:08:20,159 --> 00:08:25,380
shines is a in cross-platform support so

00:08:23,090 --> 00:08:27,389
there's been various folks who've said

00:08:25,380 --> 00:08:29,550
maybe Jay Ruby's the best way to do Ruby

00:08:27,389 --> 00:08:30,479
on windows at one point mots even said

00:08:29,550 --> 00:08:32,010
that maybe if you're having a lot of

00:08:30,479 --> 00:08:33,959
trouble on windows you should try jruby

00:08:32,010 --> 00:08:35,669
we've spent a lot of time trying to make

00:08:33,959 --> 00:08:38,190
sure that JRuby runs well on windows

00:08:35,669 --> 00:08:41,399
runs well on lots of different odd or

00:08:38,190 --> 00:08:43,050
exotic platforms and again we get a lot

00:08:41,399 --> 00:08:44,970
of that because the JVM has been built

00:08:43,050 --> 00:08:47,160
and tested and runs really well on all

00:08:44,970 --> 00:08:49,350
these different platforms to more

00:08:47,160 --> 00:08:52,050
interestingly we can run on dalvik which

00:08:49,350 --> 00:08:54,270
is androids vm there is support for a

00:08:52,050 --> 00:08:56,640
library called rubato that lets you

00:08:54,270 --> 00:08:58,140
write ruby applications in JRuby deploy

00:08:56,640 --> 00:09:00,120
an application to the market and have it

00:08:58,140 --> 00:09:02,130
run as a normal dalvik application we've

00:09:00,120 --> 00:09:03,750
had that for a couple years now and then

00:09:02,130 --> 00:09:05,500
any of them embedded JVMs oracle

00:09:03,750 --> 00:09:08,040
released recently made their

00:09:05,500 --> 00:09:10,420
embedded hotspot openjdk free for

00:09:08,040 --> 00:09:11,680
general purpose use and so if you're

00:09:10,420 --> 00:09:13,180
running on small devices and doing

00:09:11,680 --> 00:09:14,710
general purpose sort of embedded

00:09:13,180 --> 00:09:18,520
computing you can use jruby there as

00:09:14,710 --> 00:09:21,460
well here is from our issue tracker any

00:09:18,520 --> 00:09:25,690
openvms people here or as/400 anybody no

00:09:21,460 --> 00:09:27,190
not surprising so openvms which is still

00:09:25,690 --> 00:09:29,260
alive and kicking there's a couple guys

00:09:27,190 --> 00:09:31,030
that have been doing it for 25 years and

00:09:29,260 --> 00:09:34,570
continuing to maintain those systems we

00:09:31,030 --> 00:09:36,870
actually have 15 mostly closed a couple

00:09:34,570 --> 00:09:39,700
open issues in our tracker for openvms

00:09:36,870 --> 00:09:41,740
if you look at our list of platforms

00:09:39,700 --> 00:09:45,490
that we support for native ffi level

00:09:41,740 --> 00:09:47,200
which is the Ruby ffi dsl and any native

00:09:45,490 --> 00:09:49,120
features that we need to do that kind of

00:09:47,200 --> 00:09:50,650
route around the JVM we obviously have

00:09:49,120 --> 00:09:55,510
some interesting once you're like s390x

00:09:50,650 --> 00:09:57,550
linux for mainframes power pc linux we

00:09:55,510 --> 00:09:59,470
don't unfortunately have the openvms or

00:09:57,550 --> 00:10:01,570
as400 builds yet a little bit of

00:09:59,470 --> 00:10:02,920
challenge getting those but we do we

00:10:01,570 --> 00:10:05,050
work very hard to make sure that what

00:10:02,920 --> 00:10:06,880
you get in the box with JRuby will run

00:10:05,050 --> 00:10:11,200
anywhere there's a JVM without having to

00:10:06,880 --> 00:10:12,880
build anything this is a list off of

00:10:11,200 --> 00:10:15,700
rubygems that Iran today these are all

00:10:12,880 --> 00:10:18,460
the libraries in rubygems.org that have

00:10:15,700 --> 00:10:20,080
a Java platform version some of these

00:10:18,460 --> 00:10:21,970
only have a Java platform version

00:10:20,080 --> 00:10:23,920
because they're made to run on JRuby but

00:10:21,970 --> 00:10:26,020
the basic idea here is that because

00:10:23,920 --> 00:10:28,180
these are all built with JRuby and mine

00:10:26,020 --> 00:10:30,430
with the JVM in mind no native see

00:10:28,180 --> 00:10:32,890
extensions no library requirements on

00:10:30,430 --> 00:10:34,780
the court on the system you'd install no

00:10:32,890 --> 00:10:36,670
build of this the extension that might

00:10:34,780 --> 00:10:38,530
fail you pretty much just install it and

00:10:36,670 --> 00:10:40,600
it runs to binary that comes down and

00:10:38,530 --> 00:10:42,550
you're done and even better you can pull

00:10:40,600 --> 00:10:44,560
this all into another into a single

00:10:42,550 --> 00:10:46,390
installable package ship it to another

00:10:44,560 --> 00:10:49,900
machine and it'll run there just the

00:10:46,390 --> 00:10:51,730
same so platform wise you can kind of

00:10:49,900 --> 00:10:53,890
talk about servers to any java based

00:10:51,730 --> 00:10:55,420
server can host ruby so if you're in a

00:10:53,890 --> 00:10:57,430
shop where they're mostly doing java or

00:10:55,420 --> 00:10:58,870
if you want to do ruby development in

00:10:57,430 --> 00:11:00,940
the shop that's mostly java you can

00:10:58,870 --> 00:11:02,320
deploy it on all the same servers but we

00:11:00,940 --> 00:11:04,600
also have servers that are designed more

00:11:02,320 --> 00:11:06,900
with ruby folks in mind trinidad is

00:11:04,600 --> 00:11:09,340
basically the Tomcat application server

00:11:06,900 --> 00:11:11,200
stripped down and wrapped with a nice

00:11:09,340 --> 00:11:13,930
Ruby command line so you can run it like

00:11:11,200 --> 00:11:16,090
a unicorn or puma or command line server

00:11:13,930 --> 00:11:19,089
still has everything that Tomcat can do

00:11:16,090 --> 00:11:21,639
with multiple threads high concurrency

00:11:19,089 --> 00:11:23,139
nice HTTP pipeline but it looks pretty

00:11:21,639 --> 00:11:25,449
much like you're running a regular Ruby

00:11:23,139 --> 00:11:27,100
server at the command line toward box is

00:11:25,449 --> 00:11:29,139
a little bit more interesting because it

00:11:27,100 --> 00:11:31,540
takes that same concept and then

00:11:29,139 --> 00:11:33,939
provides all of the services from a

00:11:31,540 --> 00:11:36,100
larger scale enterprise app again with

00:11:33,939 --> 00:11:37,509
nice Ruby api's and Ruby configuration

00:11:36,100 --> 00:11:39,790
you never really even know you're

00:11:37,509 --> 00:11:41,620
running inside a JVM based server but

00:11:39,790 --> 00:11:44,110
you've got all this stuff so if we look

00:11:41,620 --> 00:11:45,879
at a typical Ruby application it starts

00:11:44,110 --> 00:11:48,040
out simple we've got our server we've

00:11:45,879 --> 00:11:49,899
got our web front-end rack and then

00:11:48,040 --> 00:11:52,149
maybe a Sinatra or rails back into some

00:11:49,899 --> 00:11:53,860
kind and then we will decide ok we need

00:11:52,149 --> 00:11:56,259
some some delayed jobs we need some

00:11:53,860 --> 00:11:57,790
tasks scheduled jobs background jobs to

00:11:56,259 --> 00:12:00,970
run so we were under seconds another

00:11:57,790 --> 00:12:02,620
server to do that for us ok now we need

00:12:00,970 --> 00:12:03,999
to have some some time jobs that I've

00:12:02,620 --> 00:12:05,709
run a particular times a day so we're

00:12:03,999 --> 00:12:07,920
going to set some stuff up in cron and

00:12:05,709 --> 00:12:10,089
make sure that that runs on schedule

00:12:07,920 --> 00:12:11,620
maybe we need to monitor this make sure

00:12:10,089 --> 00:12:12,790
it stays up make sure that our servers

00:12:11,620 --> 00:12:14,980
are still running and they're doing what

00:12:12,790 --> 00:12:16,959
they're supposed to and so as these

00:12:14,980 --> 00:12:19,059
applications grow they get more and more

00:12:16,959 --> 00:12:21,189
complex as they have all these pieces

00:12:19,059 --> 00:12:22,870
spread out different api's for each

00:12:21,189 --> 00:12:24,999
perhaps multiple implementations of the

00:12:22,870 --> 00:12:26,319
api's for each and you have to

00:12:24,999 --> 00:12:28,360
orchestrate all this together and make

00:12:26,319 --> 00:12:30,610
sure it keeps running well the idea with

00:12:28,360 --> 00:12:32,499
pork box is that the JBoss server

00:12:30,610 --> 00:12:36,490
basically provides all of these services

00:12:32,499 --> 00:12:39,059
messaging caching clustering in and out

00:12:36,490 --> 00:12:41,410
of memory caching scheduled jobs

00:12:39,059 --> 00:12:44,019
background jobs all of this stuff is in

00:12:41,410 --> 00:12:45,939
the box and so it puts a nice Ruby front

00:12:44,019 --> 00:12:47,860
end on the whole thing you get all of

00:12:45,939 --> 00:12:50,290
that in the same box managed through one

00:12:47,860 --> 00:12:51,910
tool one process and it does everything

00:12:50,290 --> 00:12:56,319
that your cluster of services would have

00:12:51,910 --> 00:12:57,730
done before here's a short list of all

00:12:56,319 --> 00:12:59,620
the stuff that comes in the box in

00:12:57,730 --> 00:13:01,089
torque box so if you're building a Jay

00:12:59,620 --> 00:13:03,490
Ruby application you basically can do

00:13:01,089 --> 00:13:05,410
all of this in one server without having

00:13:03,490 --> 00:13:07,120
any other external dependencies or any

00:13:05,410 --> 00:13:09,519
other external libraries to deal with a

00:13:07,120 --> 00:13:11,170
lot simpler and torque boxes just gem

00:13:09,519 --> 00:13:12,730
installable and you can pull it down

00:13:11,170 --> 00:13:14,199
start it up and have all this stuff

00:13:12,730 --> 00:13:20,199
running on the system without installing

00:13:14,199 --> 00:13:22,329
anything else all Ruby api's and they're

00:13:20,199 --> 00:13:24,939
actually pretty nice so here is the

00:13:22,329 --> 00:13:26,949
basic configuration which ruby version

00:13:24,939 --> 00:13:28,540
mode you want to run in do you want

00:13:26,949 --> 00:13:32,110
things to be getting compiling at

00:13:28,540 --> 00:13:33,399
runtime or not do you want debugging on

00:13:32,110 --> 00:13:35,500
do you want to be interactive it can

00:13:33,399 --> 00:13:38,110
spin up a little IRB console on the

00:13:35,500 --> 00:13:40,450
server so you can check actually connect

00:13:38,110 --> 00:13:41,680
to the server see what's going on run

00:13:40,450 --> 00:13:44,350
queries and make sure things are doing

00:13:41,680 --> 00:13:46,209
what they're supposed to and the all the

00:13:44,350 --> 00:13:48,220
configuration comes in both a ruby dsl

00:13:46,209 --> 00:13:50,649
form and a yam will form so depending on

00:13:48,220 --> 00:13:53,079
how you want to set it up so let's look

00:13:50,649 --> 00:13:54,670
at messaging specifically here's the

00:13:53,079 --> 00:13:57,040
Ruby and the animal versions for setting

00:13:54,670 --> 00:13:59,529
up a Q and a topic and you're done all

00:13:57,040 --> 00:14:02,019
this goes in the same torque box derby

00:13:59,529 --> 00:14:04,390
config file and you've got messaging

00:14:02,019 --> 00:14:06,610
cues set up and calling them has a nice

00:14:04,390 --> 00:14:10,390
simple Ruby feeling API that goes along

00:14:06,610 --> 00:14:12,610
with it no bother hassle no hassle of

00:14:10,390 --> 00:14:14,620
doing all of the typical JVM server

00:14:12,610 --> 00:14:16,000
stuff no hassle of spinning up at a

00:14:14,620 --> 00:14:18,100
separate process and making sure that's

00:14:16,000 --> 00:14:19,690
running properly and going out a process

00:14:18,100 --> 00:14:23,470
to do all of your messaging this is

00:14:19,690 --> 00:14:27,040
pretty much it alright so moving on to

00:14:23,470 --> 00:14:28,570
libraries if you look at maven the

00:14:27,040 --> 00:14:31,779
standard repository of libraries for

00:14:28,570 --> 00:14:33,550
java JVM applications there's 340,000

00:14:31,779 --> 00:14:36,820
versions of different jars in maven

00:14:33,550 --> 00:14:39,399
right now compare that to 35,000 gems in

00:14:36,820 --> 00:14:41,440
Ruby Ruby gems org so we're talking

00:14:39,399 --> 00:14:43,750
about a ten to one difference in how

00:14:41,440 --> 00:14:46,029
much there is available for libraries if

00:14:43,750 --> 00:14:47,470
you're running on JRuby and all of these

00:14:46,029 --> 00:14:50,140
can be cheese just be called as if

00:14:47,470 --> 00:14:51,940
they're a normal Ruby library so very

00:14:50,140 --> 00:14:53,860
few of these have any native code you

00:14:51,940 --> 00:14:56,649
pull them down call him from your Ruby

00:14:53,860 --> 00:14:57,970
code and you've got access to them this

00:14:56,649 --> 00:14:59,769
is an example of an application a

00:14:57,970 --> 00:15:02,980
commercial application that uses the

00:14:59,769 --> 00:15:06,070
batik SVG library to do a production

00:15:02,980 --> 00:15:08,470
flow simulation like supply chain

00:15:06,070 --> 00:15:12,490
management kind of stuff and this was

00:15:08,470 --> 00:15:14,890
done for I think Department of Defense

00:15:12,490 --> 00:15:17,709
and then spun off as an external project

00:15:14,890 --> 00:15:18,970
that other folks could use if anybody's

00:15:17,709 --> 00:15:20,620
ever played with red car there's an

00:15:18,970 --> 00:15:23,529
editor called red car that is written

00:15:20,620 --> 00:15:27,010
entirely in Ruby and uses a few JRuby

00:15:23,529 --> 00:15:30,370
libraries or JVM libraries to do the

00:15:27,010 --> 00:15:32,769
visual the GUI portion it uses SWT to

00:15:30,370 --> 00:15:34,390
use to do some of the backend stuff it

00:15:32,769 --> 00:15:35,829
has a sport for closure support for

00:15:34,390 --> 00:15:38,050
other languages all within the same

00:15:35,829 --> 00:15:40,060
editor and basically all written in Ruby

00:15:38,050 --> 00:15:43,480
from top to bottom just by calling these

00:15:40,060 --> 00:15:45,970
libraries and actually I want to show

00:15:43,480 --> 00:15:49,240
this so javafx is

00:15:45,970 --> 00:15:51,910
has been maligned for very good reason

00:15:49,240 --> 00:15:54,759
in most cases javafx is Oracle's new

00:15:51,910 --> 00:15:57,459
attempt to build a new GUI tool kit for

00:15:54,759 --> 00:15:59,829
JVM based applications it was originally

00:15:57,459 --> 00:16:02,259
son's attempt to create a GUI tool kit

00:15:59,829 --> 00:16:03,819
plus a language and it was a horrible

00:16:02,259 --> 00:16:05,889
abortive attempt at putting putting all

00:16:03,819 --> 00:16:07,269
that together so that's gone now but it

00:16:05,889 --> 00:16:10,000
means that we have this library that we

00:16:07,269 --> 00:16:12,250
can call and use directly basically as a

00:16:10,000 --> 00:16:14,230
scene graph that you build up with all

00:16:12,250 --> 00:16:16,000
of your vectors all of your drawings all

00:16:14,230 --> 00:16:18,220
of your 3d elements and then it tosses

00:16:16,000 --> 00:16:20,670
it into an optimized back-end department

00:16:18,220 --> 00:16:22,920
regardless of what platform you're on

00:16:20,670 --> 00:16:26,259
the example I'm going to show there's a

00:16:22,920 --> 00:16:28,600
basic JavaFX example of doing an analog

00:16:26,259 --> 00:16:30,189
clock and you can see here we were

00:16:28,600 --> 00:16:31,930
creating a couple pads so we're drawing

00:16:30,189 --> 00:16:33,639
the minute hand and the hour hand

00:16:31,930 --> 00:16:37,449
they're going to be filled with black

00:16:33,639 --> 00:16:39,550
and then we just have basic JavaFX

00:16:37,449 --> 00:16:42,370
primitives to say move the target here

00:16:39,550 --> 00:16:44,079
draw this line draw an arc rotate it in

00:16:42,370 --> 00:16:45,790
this particular way and then it all gets

00:16:44,079 --> 00:16:47,800
optimized and thrown into the graphics

00:16:45,790 --> 00:16:54,069
back-end the way it's supposed to let's

00:16:47,800 --> 00:16:55,449
see if this one actually works okay so

00:16:54,069 --> 00:16:57,040
that we start up with JRuby there we go

00:16:55,449 --> 00:16:59,920
so this is all implemented in Ruby the

00:16:57,040 --> 00:17:03,069
logic of it the building of the UI is

00:16:59,920 --> 00:17:04,780
all done sort of as a builder API and

00:17:03,069 --> 00:17:06,400
there are various dsl's that people have

00:17:04,780 --> 00:17:09,220
written around this for Ruby to build

00:17:06,400 --> 00:17:11,770
this stuff up but you can do accelerated

00:17:09,220 --> 00:17:13,329
graphics 2d and 3d graphics with a

00:17:11,770 --> 00:17:20,079
library that's basically built into the

00:17:13,329 --> 00:17:21,789
JVM now another one that's fun here how

00:17:20,079 --> 00:17:23,980
many people do minecraft play minecraft

00:17:21,789 --> 00:17:27,130
at all few folks how many people know

00:17:23,980 --> 00:17:29,470
what minecraft is ok so most folks in

00:17:27,130 --> 00:17:31,900
know what minecraft is so for rubyconf

00:17:29,470 --> 00:17:37,650
last year tom gave a talk on his library

00:17:31,900 --> 00:17:40,059
proven which is sort of a japanese ii

00:17:37,650 --> 00:17:42,490
mutilation of plugin but it's basically

00:17:40,059 --> 00:17:46,390
a ruby api that allows you to write

00:17:42,490 --> 00:17:48,929
plugins for minecraft very clean dsl for

00:17:46,390 --> 00:17:51,070
handling events adding event listeners

00:17:48,929 --> 00:17:52,720
running different scripts and what not

00:17:51,070 --> 00:17:55,570
controlling different objects in the

00:17:52,720 --> 00:17:57,010
system querying objects and since then

00:17:55,570 --> 00:17:59,710
he actually worked on an implementation

00:17:57,010 --> 00:18:04,750
of logo that runs on top of pro

00:17:59,710 --> 00:18:06,399
in in the minecraft runtime and this is

00:18:04,750 --> 00:18:11,140
an example of basically a little prague

00:18:06,399 --> 00:18:14,649
in Progo script that will draw a pyramid

00:18:11,140 --> 00:18:16,179
of a particular length on a side and of

00:18:14,649 --> 00:18:18,250
course since this is minecraft we have

00:18:16,179 --> 00:18:20,260
three dimensions so there's a turn-up

00:18:18,250 --> 00:18:22,840
and it turned down as well as the

00:18:20,260 --> 00:18:28,750
typical turn left and right let's see

00:18:22,840 --> 00:18:31,090
what this looks like ok so here we are

00:18:28,750 --> 00:18:34,480
in a little minecraft world that's

00:18:31,090 --> 00:18:35,770
actually Tom's girlfriend hanging out ok

00:18:34,480 --> 00:18:38,320
so we're going to start at that point

00:18:35,770 --> 00:18:42,309
whatever square you're pointing at we're

00:18:38,320 --> 00:18:47,440
going to draw a pyramid that is 12 on a

00:18:42,309 --> 00:18:50,020
side tom is deciding 12 8 and we'll make

00:18:47,440 --> 00:18:52,240
it out of gold or just for this demo and

00:18:50,020 --> 00:18:53,890
of course we don't have a turtle so we

00:18:52,240 --> 00:18:55,360
use a chicken because it makes sense

00:18:53,890 --> 00:18:57,580
it's minecraft world and we'll have a

00:18:55,360 --> 00:18:59,470
chicken draw our graphics and there we

00:18:57,580 --> 00:19:01,480
go and this is all it's just a simple

00:18:59,470 --> 00:19:04,600
Ruby script running on top of the plug

00:19:01,480 --> 00:19:06,940
in Ruby backend for Ruby front end plug

00:19:04,600 --> 00:19:09,010
in stuff for Minecraft and there we go

00:19:06,940 --> 00:19:11,260
we have our twelve by twelve pyramid

00:19:09,010 --> 00:19:14,470
drawn by a chicken who says you can't

00:19:11,260 --> 00:19:16,779
use a roof or useful things and then

00:19:14,470 --> 00:19:21,640
we'll undrawn and then it's gone it has

00:19:16,779 --> 00:19:23,409
memory of what it's actually done ok so

00:19:21,640 --> 00:19:25,029
that's fun and these are all just

00:19:23,409 --> 00:19:27,190
libraries you can pull down I mean it's

00:19:25,029 --> 00:19:28,960
just a thrill to play with all this one

00:19:27,190 --> 00:19:31,330
stuff so three pencils another library

00:19:28,960 --> 00:19:34,240
that tom has worked on I wraps the ardor

00:19:31,330 --> 00:19:37,990
3d library which is using a lightweight

00:19:34,240 --> 00:19:39,549
java opengl back end and then providing

00:19:37,990 --> 00:19:42,309
a scene graph and other stuff on top of

00:19:39,549 --> 00:19:47,200
it and it's actually if you go to Tom's

00:19:42,309 --> 00:19:48,970
account on github NM o en e bo and look

00:19:47,200 --> 00:19:51,190
for three pens you can basically just

00:19:48,970 --> 00:19:52,750
clone this and run it and it has all the

00:19:51,190 --> 00:19:54,669
native libraries that are required for

00:19:52,750 --> 00:19:57,279
it built in so on pretty much any

00:19:54,669 --> 00:19:59,770
platform you have three pence you have

00:19:57,279 --> 00:20:02,559
Jay Ruby of a JVM you can do 3d graphics

00:19:59,770 --> 00:20:04,330
and 3d games and the example he thought

00:20:02,559 --> 00:20:07,179
would be fun to show is there's a little

00:20:04,330 --> 00:20:10,600
skybox that just spins a cube around in

00:20:07,179 --> 00:20:12,279
a blue background let's run that one

00:20:10,600 --> 00:20:12,490
there's another one I'll run to this is

00:20:12,279 --> 00:20:17,260
kinda

00:20:12,490 --> 00:20:19,540
fun so this is neo the neo demo in here

00:20:17,260 --> 00:20:21,130
and so all the logic of what's actually

00:20:19,540 --> 00:20:24,309
happening to the 3d objects is

00:20:21,130 --> 00:20:27,040
implemented in Ruby in JRuby and it runs

00:20:24,309 --> 00:20:29,080
fine there's an interesting bug there if

00:20:27,040 --> 00:20:33,220
you notice when the one that's in band

00:20:29,080 --> 00:20:37,780
back passes in front of the the front

00:20:33,220 --> 00:20:39,280
one so but again built-in stuff that we

00:20:37,780 --> 00:20:41,320
can do on the JVM and we can use

00:20:39,280 --> 00:20:44,110
existing libraries from Ruby without any

00:20:41,320 --> 00:20:47,590
hassle and I like there's another one

00:20:44,110 --> 00:20:49,809
that's a little bit more entertaining so

00:20:47,590 --> 00:20:51,250
here this is bubble mark benchmark

00:20:49,809 --> 00:20:53,410
that's basically just showing a bunch of

00:20:51,250 --> 00:20:55,630
bubbles bouncing around you'll notice it

00:20:53,410 --> 00:20:57,400
starts out button 100 frames per second

00:20:55,630 --> 00:20:59,050
and then optimizes as the JVM gets

00:20:57,400 --> 00:21:00,580
faster I think this will end up

00:20:59,050 --> 00:21:03,570
somewhere in the 900 range maybe a

00:21:00,580 --> 00:21:06,700
little bit faster 1100 frames per second

00:21:03,570 --> 00:21:09,070
more frames per second but then we can

00:21:06,700 --> 00:21:10,990
we can challenge jruby in the JVM a

00:21:09,070 --> 00:21:13,150
little bit by throwing 128 of these in

00:21:10,990 --> 00:21:16,090
here still doing pretty well around

00:21:13,150 --> 00:21:17,950
seven hundred frames per second will do

00:21:16,090 --> 00:21:20,559
will drop it back down we got ball the

00:21:17,950 --> 00:21:23,620
ball collision and actually vsync it so

00:21:20,559 --> 00:21:26,050
it always sticks right around 60 to 100

00:21:23,620 --> 00:21:29,440
frames per second so it's nice and clean

00:21:26,050 --> 00:21:31,210
and we have predictable again the logic

00:21:29,440 --> 00:21:34,059
for all this is implemented in Ruby

00:21:31,210 --> 00:21:37,650
calling into a JVM library that then

00:21:34,059 --> 00:21:37,650
does all of the fast graphics for us

00:21:39,270 --> 00:21:42,270
okay

00:21:45,429 --> 00:21:58,720
that is the wrong talk how did that

00:21:48,740 --> 00:21:58,720
happen go away go away go away go away

00:21:58,840 --> 00:22:03,770
there we go that's weird went to the

00:22:01,399 --> 00:22:04,730
back okay so that's libraries and

00:22:03,770 --> 00:22:06,260
there's obviously a lot of other

00:22:04,730 --> 00:22:07,789
practical libraries out there that can

00:22:06,260 --> 00:22:09,710
do all sorts of fun things for you too

00:22:07,789 --> 00:22:11,210
but pretty much any jvm library that's

00:22:09,710 --> 00:22:14,419
available you can pull it down and just

00:22:11,210 --> 00:22:17,750
call it from Ruby code so more more

00:22:14,419 --> 00:22:20,270
low-level now talking about vm level

00:22:17,750 --> 00:22:21,620
issues like garbage collection has

00:22:20,270 --> 00:22:25,039
anybody had garbage collection issues

00:22:21,620 --> 00:22:27,529
running on MRI pauses too much just too

00:22:25,039 --> 00:22:29,630
much cpu use in general that's not

00:22:27,529 --> 00:22:31,640
uncommon as far as running with with MRI

00:22:29,630 --> 00:22:34,700
so the issues that basically

00:22:31,640 --> 00:22:36,380
applications data set either within the

00:22:34,700 --> 00:22:37,580
single run or over time as the

00:22:36,380 --> 00:22:39,590
application becomes more complicated

00:22:37,580 --> 00:22:41,840
will grow and you'll have a larger

00:22:39,590 --> 00:22:44,120
application more data more objects in

00:22:41,840 --> 00:22:46,940
memory and Ruby itself is very object

00:22:44,120 --> 00:22:49,460
heavy on top of that so eventually you

00:22:46,940 --> 00:22:53,000
do have a problem with this on MRI let's

00:22:49,460 --> 00:22:55,190
look at so on the JVM side we have lots

00:22:53,000 --> 00:22:57,350
of different GC options many different

00:22:55,190 --> 00:22:59,000
to choose from scale to different sorts

00:22:57,350 --> 00:23:01,340
of loads scale for multiprocessor

00:22:59,000 --> 00:23:03,230
systems and these are pretty much the

00:23:01,340 --> 00:23:04,909
best garbage collectors in the world if

00:23:03,230 --> 00:23:08,809
you look back at GC research over the

00:23:04,909 --> 00:23:11,270
past you know 15 years or so pretty much

00:23:08,809 --> 00:23:12,890
every implementation of GC has been

00:23:11,270 --> 00:23:15,799
mentioned as mentioned or has been

00:23:12,890 --> 00:23:17,659
implemented specifically for the JVM and

00:23:15,799 --> 00:23:21,169
a lot of that work is now available for

00:23:17,659 --> 00:23:23,809
free and open JDK so here's the OpenJDK

00:23:21,169 --> 00:23:25,070
ones that are actually interesting the

00:23:23,809 --> 00:23:27,440
default is usually to run with the

00:23:25,070 --> 00:23:29,360
parallel collector which does stop the

00:23:27,440 --> 00:23:30,919
world the application does stop but it

00:23:29,360 --> 00:23:32,570
uses as many cores as you have in your

00:23:30,919 --> 00:23:34,820
system to do that collection as fast as

00:23:32,570 --> 00:23:36,860
possible the concurrent collector tries

00:23:34,820 --> 00:23:39,500
to avoid pausing the application as much

00:23:36,860 --> 00:23:41,840
as possible and runs concurrently to the

00:23:39,500 --> 00:23:43,070
application itself g1 is kind of

00:23:41,840 --> 00:23:45,080
intended to replace the concurrent

00:23:43,070 --> 00:23:46,730
collector and it allows all generations

00:23:45,080 --> 00:23:48,830
all different objects to be collected

00:23:46,730 --> 00:23:50,659
concurrently up to some certain limit

00:23:48,830 --> 00:23:53,179
and then there's a serial collector

00:23:50,659 --> 00:23:55,190
that's very fast throughput but it stops

00:23:53,179 --> 00:23:57,760
the world for every collection that goes

00:23:55,190 --> 00:23:59,530
on so I have a couple

00:23:57,760 --> 00:24:01,570
demos I'm not going to run here I've

00:23:59,530 --> 00:24:04,810
pre-run these and gathered some metrics

00:24:01,570 --> 00:24:07,810
about GC in JRuby versus MRI so the

00:24:04,810 --> 00:24:09,880
first one is GC demo 1 it has a lot of

00:24:07,810 --> 00:24:11,200
GC which is a mix of old and young

00:24:09,880 --> 00:24:12,910
objects so obvious that I've been

00:24:11,200 --> 00:24:14,770
sticking around for more than a few

00:24:12,910 --> 00:24:17,080
seconds combined with stuff that's being

00:24:14,770 --> 00:24:20,950
spun on really quickly and then the heat

00:24:17,080 --> 00:24:23,530
steadily grows over time here's the

00:24:20,950 --> 00:24:26,230
example so we have a couple different

00:24:23,530 --> 00:24:28,390
levels of loops the innermost loop the

00:24:26,230 --> 00:24:29,800
purl loop basically just spins off and

00:24:28,390 --> 00:24:31,780
creates a hundred of these simple

00:24:29,800 --> 00:24:33,160
objects so that's the young objects that

00:24:31,780 --> 00:24:36,430
are getting collected very frequently

00:24:33,160 --> 00:24:39,280
the next loop out basically just creates

00:24:36,430 --> 00:24:41,590
a longer long longer and longer chain of

00:24:39,280 --> 00:24:43,930
objects a linked list of objects so that

00:24:41,590 --> 00:24:46,390
grows in memory it gets old and gets

00:24:43,930 --> 00:24:48,160
promoted to the old garbage collection

00:24:46,390 --> 00:24:50,050
generation and then gets collected at

00:24:48,160 --> 00:24:52,750
some point so both garbage collectors

00:24:50,050 --> 00:24:57,040
being exercised here and so I went to

00:24:52,750 --> 00:24:59,050
run this on MRI 1 93 and JRuby just to

00:24:57,040 --> 00:25:01,840
get like a general idea of how much

00:24:59,050 --> 00:25:04,960
garbage collections happening and I got

00:25:01,840 --> 00:25:08,350
something like almost 8,000 collections

00:25:04,960 --> 00:25:10,960
happened during this 10 20 second run of

00:25:08,350 --> 00:25:12,520
this script and I actually I through

00:25:10,960 --> 00:25:14,260
this into a graph and had to make it

00:25:12,520 --> 00:25:15,880
logarithmic so you can even see how many

00:25:14,260 --> 00:25:18,820
garbage collections happened during the

00:25:15,880 --> 00:25:20,950
jruby run it was under a hundred it was

00:25:18,820 --> 00:25:22,510
something like 75 total garbage

00:25:20,950 --> 00:25:24,960
collections that ran during the entire

00:25:22,510 --> 00:25:26,680
script and this is not a typical

00:25:24,960 --> 00:25:29,650
applications that run on JRuby are

00:25:26,680 --> 00:25:31,270
generally not going to BGC bound if we

00:25:29,650 --> 00:25:34,180
look at how much time is actually being

00:25:31,270 --> 00:25:36,670
spent for GC it's getting up into the

00:25:34,180 --> 00:25:38,560
twelve thirteen percent range for MRI

00:25:36,670 --> 00:25:41,050
and now the thing to think about is that

00:25:38,560 --> 00:25:43,270
this is per process so if you've got

00:25:41,050 --> 00:25:44,920
every single process in the system using

00:25:43,270 --> 00:25:47,290
twelve to thirteen percent of its CPU

00:25:44,920 --> 00:25:50,260
time just to clean up garbage you're

00:25:47,290 --> 00:25:51,490
wasting a tremendous amount of CPU to

00:25:50,260 --> 00:25:52,990
keep all of those concurrent connections

00:25:51,490 --> 00:25:57,400
and all those concurrent processing

00:25:52,990 --> 00:25:59,500
going did a measure of how long the GCS

00:25:57,400 --> 00:26:01,090
was actually taking you can see that MRI

00:25:59,500 --> 00:26:02,890
does pretty good for small heaps and

00:26:01,090 --> 00:26:05,260
that's one reason that for small

00:26:02,890 --> 00:26:08,050
applications command line apps a little

00:26:05,260 --> 00:26:10,030
short scripts MRI is still probably the

00:26:08,050 --> 00:26:11,260
best way to go it starts up fast it runs

00:26:10,030 --> 00:26:14,080
pretty fast at small

00:26:11,260 --> 00:26:16,990
small levels of load small application

00:26:14,080 --> 00:26:18,400
data sets but very quickly as the

00:26:16,990 --> 00:26:20,650
application gets into a typical rail

00:26:18,400 --> 00:26:22,870
size you can see that these pauses or

00:26:20,650 --> 00:26:25,930
that the amount of time being used for

00:26:22,870 --> 00:26:28,690
each GC is going up and up all the time

00:26:25,930 --> 00:26:31,570
you get to an application that's 200 300

00:26:28,690 --> 00:26:32,530
400 Meg in a given process you're

00:26:31,570 --> 00:26:34,150
getting up to the point where you're

00:26:32,530 --> 00:26:37,420
waiting a half a second for garbage

00:26:34,150 --> 00:26:40,690
collection to run when it runs so GC

00:26:37,420 --> 00:26:43,390
demo2 is a little bit different frequent

00:26:40,690 --> 00:26:46,060
GC but it's all young objects and then

00:26:43,390 --> 00:26:48,670
it lets the heap grow and create larger

00:26:46,060 --> 00:26:51,190
and larger objects so over time it's not

00:26:48,670 --> 00:26:52,570
garbage collecting as much but it's a

00:26:51,190 --> 00:26:55,000
larger and larger section of memory

00:26:52,570 --> 00:26:57,280
that's being used by the application so

00:26:55,000 --> 00:26:59,500
this is the example here this will

00:26:57,280 --> 00:27:00,790
continue to run and just build up memory

00:26:59,500 --> 00:27:02,470
and make the application larger and

00:27:00,790 --> 00:27:03,880
larger while it does a massive amount of

00:27:02,470 --> 00:27:06,580
young generation collecting on these

00:27:03,880 --> 00:27:08,740
little objects so Jesus a time comes out

00:27:06,580 --> 00:27:10,360
a little bit closer here for a longer

00:27:08,740 --> 00:27:12,430
run JRuby to probably pick up because

00:27:10,360 --> 00:27:14,890
over time and application would settle

00:27:12,430 --> 00:27:16,660
into a particular set of old objects and

00:27:14,890 --> 00:27:19,390
in the JVM which is not even look at

00:27:16,660 --> 00:27:22,450
them for GC purposes now this one is a

00:27:19,390 --> 00:27:25,180
little bit scarier these are real world

00:27:22,450 --> 00:27:28,240
stopping pauses in the application as it

00:27:25,180 --> 00:27:31,030
goes on so obviously JRuby runs us a lot

00:27:28,240 --> 00:27:33,130
faster first of all than MRI but you can

00:27:31,030 --> 00:27:35,470
see as the application grows as the

00:27:33,130 --> 00:27:37,270
amount of data on the heap grows the

00:27:35,470 --> 00:27:39,550
whole application is pausing more

00:27:37,270 --> 00:27:41,650
getting up into a quarter second pause

00:27:39,550 --> 00:27:43,630
times towards the end and this is pause

00:27:41,650 --> 00:27:45,730
times that will be that way for the rest

00:27:43,630 --> 00:27:47,470
of the application lifetime until you

00:27:45,730 --> 00:27:49,900
kill it and restart it and then let the

00:27:47,470 --> 00:27:51,640
process begin again whereas JRuby can

00:27:49,900 --> 00:27:54,160
handle gigabyte heaps and it's going to

00:27:51,640 --> 00:27:58,450
be pauses in the point 0 1 range almost

00:27:54,160 --> 00:27:59,920
all the time or lower so yeah this is

00:27:58,450 --> 00:28:02,050
your application and these are the pause

00:27:59,920 --> 00:28:04,180
times that users are starting to see and

00:28:02,050 --> 00:28:06,130
here's the opposite they're they're not

00:28:04,180 --> 00:28:08,580
happy with this more and more requests

00:28:06,130 --> 00:28:11,950
have to wait for those GC pauses and

00:28:08,580 --> 00:28:15,010
generally people are not happy so in

00:28:11,950 --> 00:28:16,570
general jruby running any typical Ruby

00:28:15,010 --> 00:28:18,250
application GC is not going to be a

00:28:16,570 --> 00:28:20,080
problem you're going to much more

00:28:18,250 --> 00:28:21,040
predictable applications and you're

00:28:20,080 --> 00:28:23,659
going to make a lot better use of

00:28:21,040 --> 00:28:28,230
resources on the system

00:28:23,659 --> 00:28:30,119
alright so threading jruby of course is

00:28:28,230 --> 00:28:33,239
is based on the JVM which has real

00:28:30,119 --> 00:28:34,889
parallel threads and there's not much

00:28:33,239 --> 00:28:37,259
else to it we don't do anything special

00:28:34,889 --> 00:28:39,960
other than just make a ruby thread map

00:28:37,259 --> 00:28:42,629
to a JVM thread and let the JVM run with

00:28:39,960 --> 00:28:44,129
it that also means that one process can

00:28:42,629 --> 00:28:46,350
handle all the cores in your system and

00:28:44,129 --> 00:28:47,369
saturate them it can handle all the

00:28:46,350 --> 00:28:49,980
requests you want to throw at it

00:28:47,369 --> 00:28:51,419
concurrently and you don't have to have

00:28:49,980 --> 00:28:55,320
extra processes you don't have to waste

00:28:51,419 --> 00:28:58,109
those resources so here's a contrived

00:28:55,320 --> 00:29:00,779
benchmark that basically just counts up

00:28:58,109 --> 00:29:01,950
a bunch of numbers there's the single

00:29:00,779 --> 00:29:03,960
threaded version that just goes straight

00:29:01,950 --> 00:29:05,850
through it and then a threaded version

00:29:03,960 --> 00:29:08,970
that spins up 10 threads to break it up

00:29:05,850 --> 00:29:12,059
into 10 pieces now if we run this on

00:29:08,970 --> 00:29:14,369
Ruby 19 unthreaded you'll see one core

00:29:12,059 --> 00:29:15,899
will saturate like you'd expect if we

00:29:14,369 --> 00:29:18,269
split this up and we have the 10 threads

00:29:15,899 --> 00:29:20,519
do it well we've basically the same

00:29:18,269 --> 00:29:22,350
amount of CPU spread out across a couple

00:29:20,519 --> 00:29:24,239
of Coors but we're not saturating with

00:29:22,350 --> 00:29:26,639
all the CPUs in the system we're not

00:29:24,239 --> 00:29:28,769
using up what's available now if we run

00:29:26,639 --> 00:29:30,419
on JRuby and I'll note that every other

00:29:28,769 --> 00:29:31,919
core here's a hyper threaded core so

00:29:30,419 --> 00:29:34,470
sometimes they do their work sometimes

00:29:31,919 --> 00:29:35,999
they don't so JRuby unthreaded we have

00:29:34,470 --> 00:29:37,470
the one thread that's pretty close to a

00:29:35,999 --> 00:29:39,059
hundred percent you'll notice on the

00:29:37,470 --> 00:29:41,309
left as a thread that's maybe around

00:29:39,059 --> 00:29:42,929
thirty percent that's the JVM actually

00:29:41,309 --> 00:29:44,820
doing its GC in the background and

00:29:42,929 --> 00:29:47,340
picking up objects while the application

00:29:44,820 --> 00:29:49,619
runs if we run this with all the threads

00:29:47,340 --> 00:29:51,720
then there we go we saturate everything

00:29:49,619 --> 00:29:53,789
we're actually using the system in one

00:29:51,720 --> 00:29:55,590
process without having to do auto

00:29:53,789 --> 00:29:58,279
process communication without having to

00:29:55,590 --> 00:30:00,659
manage all these at different instances

00:29:58,279 --> 00:30:02,609
and then as far as scaling this here is

00:30:00,659 --> 00:30:04,739
a threaded reverse as a benchmark from

00:30:02,609 --> 00:30:06,239
JRuby suite that basically just takes a

00:30:04,739 --> 00:30:09,149
large string and tries to manually

00:30:06,239 --> 00:30:11,100
reverse it as fast as it can so with one

00:30:09,149 --> 00:30:13,350
thread versus two we're almost twice as

00:30:11,100 --> 00:30:15,299
much and then you can see it's kind of a

00:30:13,350 --> 00:30:17,580
tapering off effect but it does actually

00:30:15,299 --> 00:30:18,720
scale with the number of cores with the

00:30:17,580 --> 00:30:21,419
number of threads that you're throwing

00:30:18,720 --> 00:30:23,279
at it and you notice like I said it's

00:30:21,419 --> 00:30:25,379
nonlinear it's kind of a curve down to

00:30:23,279 --> 00:30:26,609
the bottom so more work and running

00:30:25,379 --> 00:30:28,320
through this stuff faster means more

00:30:26,609 --> 00:30:30,419
objects and eventually you start to

00:30:28,320 --> 00:30:32,700
saturate the pipeline of for example my

00:30:30,419 --> 00:30:35,789
machine a machine with higher memory

00:30:32,700 --> 00:30:36,840
pipeline for faster memory you can scale

00:30:35,789 --> 00:30:41,039
a lot more linearly

00:30:36,840 --> 00:30:43,409
across processes across threads all

00:30:41,039 --> 00:30:45,270
right last section here the JVM has been

00:30:43,409 --> 00:30:48,049
around for a long time and as a result

00:30:45,270 --> 00:30:50,820
there are tons of tools available for it

00:30:48,049 --> 00:30:53,130
visualvm your kit NetBeans JX insider

00:30:50,820 --> 00:30:55,529
just for that are fairly commonly used

00:30:53,130 --> 00:30:57,929
there's dozens of others for doing heap

00:30:55,529 --> 00:31:01,440
analysis for doing live profiling of

00:30:57,929 --> 00:31:03,750
applications we have a couple tools

00:31:01,440 --> 00:31:05,340
built in we have dash dash profile which

00:31:03,750 --> 00:31:07,620
will give you a basic profile of the

00:31:05,340 --> 00:31:09,990
application a graph version that will

00:31:07,620 --> 00:31:12,600
show you call trees and which call trees

00:31:09,990 --> 00:31:14,250
are the heaviest want heaviest it for

00:31:12,600 --> 00:31:16,260
doing memory profiling you can turn on a

00:31:14,250 --> 00:31:18,899
feature in JRuby that allows the JVM to

00:31:16,260 --> 00:31:21,270
show normal classes in object profiles

00:31:18,899 --> 00:31:23,760
so any of the JVM object profiling stuff

00:31:21,270 --> 00:31:24,779
will work with regular Ruby classes and

00:31:23,760 --> 00:31:26,340
then there's a lot of command line

00:31:24,779 --> 00:31:29,100
profiles that are built into the JVM

00:31:26,340 --> 00:31:30,510
that do a lot of this too so monitoring

00:31:29,100 --> 00:31:31,919
is kind of the other half of tools when

00:31:30,510 --> 00:31:34,169
you've got an application in production

00:31:31,919 --> 00:31:35,940
and you want to keep an eye on it the

00:31:34,169 --> 00:31:37,710
JVM has something called Java management

00:31:35,940 --> 00:31:39,809
extensions built-in and there's a couple

00:31:37,710 --> 00:31:43,080
different gems that allow you to query

00:31:39,809 --> 00:31:46,230
or register management interfaces from a

00:31:43,080 --> 00:31:47,820
ruby application jconsole and visual vm

00:31:46,230 --> 00:31:49,919
are the typical ways that you access

00:31:47,820 --> 00:31:51,539
these I'll show a little bit of visual

00:31:49,919 --> 00:31:53,010
vm in a minute and there's a lot of

00:31:51,539 --> 00:31:54,840
servers that provide additional tools

00:31:53,010 --> 00:31:57,600
like how many requests per second you're

00:31:54,840 --> 00:31:59,429
getting in basic profiling of requests

00:31:57,600 --> 00:32:01,289
end-to-end that you can query it all

00:31:59,429 --> 00:32:02,730
remotely and it's just a standard

00:32:01,289 --> 00:32:05,460
interface that any of these tools can

00:32:02,730 --> 00:32:07,740
access on those servers new relic in' in

00:32:05,460 --> 00:32:10,169
the other external JX ternal application

00:32:07,740 --> 00:32:11,850
monitoring folks also have JVM support

00:32:10,169 --> 00:32:13,679
that's essentially built on top of this

00:32:11,850 --> 00:32:16,409
so you can have Ruby level monitoring

00:32:13,679 --> 00:32:19,140
and vm runtime level monitoring to go

00:32:16,409 --> 00:32:21,149
with it submission of ems would I want

00:32:19,140 --> 00:32:23,010
to show a little bit there are CPU

00:32:21,149 --> 00:32:24,840
memory thread monitoring stuff built in

00:32:23,010 --> 00:32:27,029
there's profiling for either

00:32:24,840 --> 00:32:28,700
instrumented or sampled profiling built

00:32:27,029 --> 00:32:30,899
in that you can run in any application

00:32:28,700 --> 00:32:33,120
visual GC is really cool which is what

00:32:30,899 --> 00:32:35,730
I'll show and then you can pull off heap

00:32:33,120 --> 00:32:37,500
dumps analyze them see how many objects

00:32:35,730 --> 00:32:39,149
you have in memory and then go and

00:32:37,500 --> 00:32:40,860
investigate why you have extra of any

00:32:39,149 --> 00:32:44,279
extra objects while you're leaking and

00:32:40,860 --> 00:32:46,950
so on here's a view of it actually doing

00:32:44,279 --> 00:32:48,390
the memory profiling so here it's we've

00:32:46,950 --> 00:32:49,850
turned on the flag that allows Ruby

00:32:48,390 --> 00:32:52,039
objects to show up as normal JV

00:32:49,850 --> 00:32:53,929
em objects started up a basic rails

00:32:52,039 --> 00:32:55,580
application and this is what memory look

00:32:53,929 --> 00:32:57,320
like the rails does a pretty good job of

00:32:55,580 --> 00:32:59,450
keeping its own footprint pretty small

00:32:57,320 --> 00:33:00,919
but rubygems has a lot of libraries and

00:32:59,450 --> 00:33:02,809
a lot of gems that it's loaded in so

00:33:00,919 --> 00:33:04,340
that's what shows up as the largest part

00:33:02,809 --> 00:33:08,120
of the heap for a base application in

00:33:04,340 --> 00:33:10,970
this case here's another one actually

00:33:08,120 --> 00:33:13,580
profiling ruby application running so

00:33:10,970 --> 00:33:15,110
we've got a rails application and config

00:33:13,580 --> 00:33:17,179
is apparently getting hit here as the

00:33:15,110 --> 00:33:19,309
top one and then it goes down from there

00:33:17,179 --> 00:33:24,039
so regular Ruby methods showing up in a

00:33:19,309 --> 00:33:30,200
JVM monitoring tool and I'll show a

00:33:24,039 --> 00:33:34,340
little example of this you see demo two

00:33:30,200 --> 00:33:37,760
will run GC demo two and actually hook

00:33:34,340 --> 00:33:39,320
up to it with visual vm so usually on

00:33:37,760 --> 00:33:41,390
most isn't even called the jdk you've

00:33:39,320 --> 00:33:43,700
got j visual vm as a command that you

00:33:41,390 --> 00:33:45,289
can start up and connect to any

00:33:43,700 --> 00:33:47,419
application here it sees that we've

00:33:45,289 --> 00:33:50,450
actually got a JRuby app running the

00:33:47,419 --> 00:33:52,520
visual vm guys have built that in bring

00:33:50,450 --> 00:33:55,309
that up and like i said this monitoring

00:33:52,520 --> 00:33:58,460
of basic stuff like cpu how much heap is

00:33:55,309 --> 00:34:00,980
being used over time i'll live i can

00:33:58,460 --> 00:34:02,450
force the system to do a GC i can do a

00:34:00,980 --> 00:34:05,270
heap dump and and analyze it for what

00:34:02,450 --> 00:34:06,860
objects are available in memory here's

00:34:05,270 --> 00:34:08,600
what all the threads are doing mostly

00:34:06,860 --> 00:34:11,869
this is a simple script so it's all the

00:34:08,600 --> 00:34:13,780
JVM baseline script threads and our 1j

00:34:11,869 --> 00:34:16,730
Ruby thread is the main thread down here

00:34:13,780 --> 00:34:18,940
but this is a little bit more fun this

00:34:16,730 --> 00:34:20,840
is actually showing the GC running live

00:34:18,940 --> 00:34:23,240
so we have each of the different

00:34:20,840 --> 00:34:25,190
generations of GC it shows how much

00:34:23,240 --> 00:34:27,260
allocation is going on how big they're

00:34:25,190 --> 00:34:29,960
getting the nice sawtooth in effect of a

00:34:27,260 --> 00:34:32,270
good non leaking application and you can

00:34:29,960 --> 00:34:35,030
see the bars going up and down as the

00:34:32,270 --> 00:34:37,310
different generations fill up so if you

00:34:35,030 --> 00:34:39,800
see nice saw tues like this that mostly

00:34:37,310 --> 00:34:41,659
stay the same height across the top you

00:34:39,800 --> 00:34:43,760
got a good clean application if you see

00:34:41,659 --> 00:34:45,530
that steadily increasing you might have

00:34:43,760 --> 00:34:48,639
a leak and then you can use other parts

00:34:45,530 --> 00:34:48,639
of the same tool to find that

00:34:50,510 --> 00:34:58,200
last section here so performance this is

00:34:55,950 --> 00:35:01,290
where I work on work on in JRuby most

00:34:58,200 --> 00:35:03,540
most of the time so we're running on top

00:35:01,290 --> 00:35:05,640
of the JVM jruby basically will compile

00:35:03,540 --> 00:35:07,650
Ruby code down into JVM bytecode and

00:35:05,640 --> 00:35:09,870
then the JVM will take that byte code

00:35:07,650 --> 00:35:12,660
and do its own rounds of optimization

00:35:09,870 --> 00:35:13,890
and this is some of the best technology

00:35:12,660 --> 00:35:16,140
in the world it's it's it's definitely

00:35:13,890 --> 00:35:19,050
the fastest manage runtime in the world

00:35:16,140 --> 00:35:21,840
at least as far as running java type

00:35:19,050 --> 00:35:23,280
code that it can optimize and in Java 7

00:35:21,840 --> 00:35:24,540
we're actually starting to take

00:35:23,280 --> 00:35:26,250
advantage of that same level of

00:35:24,540 --> 00:35:29,520
optimization because they added invoke

00:35:26,250 --> 00:35:31,110
dynamic which is a base JVM support for

00:35:29,520 --> 00:35:34,500
doing dynamic in vacations like we have

00:35:31,110 --> 00:35:36,690
in Ruby so invoke dynamic if we look at

00:35:34,500 --> 00:35:38,370
Jay Ruby's evolution over time we've got

00:35:36,690 --> 00:35:40,350
a little simple piece of Ruby code here

00:35:38,370 --> 00:35:44,220
that calls from food a bar and bar tab

00:35:40,350 --> 00:35:46,290
as on previous versions of Java five and

00:35:44,220 --> 00:35:48,090
six we have a bunch of call logic in

00:35:46,290 --> 00:35:49,560
between each of these steps and that

00:35:48,090 --> 00:35:51,480
kind of obscures that the fact that

00:35:49,560 --> 00:35:53,220
we're calling from food a bar as far as

00:35:51,480 --> 00:35:56,160
the JVM goes it doesn't know how to

00:35:53,220 --> 00:35:58,590
optimize these pieces together with

00:35:56,160 --> 00:36:00,510
invoke dynamic all of that stuff kind of

00:35:58,590 --> 00:36:03,120
disappears the dynamic call logic is

00:36:00,510 --> 00:36:05,220
built into the JVM itself and so it all

00:36:03,120 --> 00:36:07,710
goes away the JVM sees that straight

00:36:05,220 --> 00:36:09,330
through path for optimizing and it can

00:36:07,710 --> 00:36:11,160
do the optimizations that it would do

00:36:09,330 --> 00:36:13,770
for any other statically typed language

00:36:11,160 --> 00:36:16,350
on the JVM literally we can have Ruby

00:36:13,770 --> 00:36:19,550
code that runs as fast as Java or

00:36:16,350 --> 00:36:22,440
scholar or any of those static languages

00:36:19,550 --> 00:36:24,090
a little bit more a different way of

00:36:22,440 --> 00:36:25,770
looking at inlining this is a little

00:36:24,090 --> 00:36:27,120
script that I ran on the bottom is the

00:36:25,770 --> 00:36:29,130
assembly which I'm sure everybody can

00:36:27,120 --> 00:36:32,250
read for what it actually generates for

00:36:29,130 --> 00:36:35,400
the code for invoker it's actually in

00:36:32,250 --> 00:36:37,830
line foo so it runs long enough the JVM

00:36:35,400 --> 00:36:39,660
sees us doing these dynamic calls and it

00:36:37,830 --> 00:36:41,190
sees that invoker always calls foo and

00:36:39,660 --> 00:36:43,140
so instead of doing the call to foo

00:36:41,190 --> 00:36:46,170
every single time it actually will just

00:36:43,140 --> 00:36:48,630
put that value of one or whatever foo is

00:36:46,170 --> 00:36:49,800
doing in the body of invoker and then if

00:36:48,630 --> 00:36:51,600
it runs a little bit longer its able to

00:36:49,800 --> 00:36:52,950
optimize a few more levels well it'll

00:36:51,600 --> 00:36:55,530
see that invoker isn't doing anything

00:36:52,950 --> 00:36:57,810
special will in line that right into the

00:36:55,530 --> 00:36:59,370
loop here and so we actually have a loop

00:36:57,810 --> 00:37:01,490
that is doing no calls other than the

00:36:59,370 --> 00:37:03,630
math calls that it does to run the loop

00:37:01,490 --> 00:37:05,280
maybe it'll get rid of that you see

00:37:03,630 --> 00:37:06,810
that that values never actually used its

00:37:05,280 --> 00:37:08,760
loaded from a known place in memory and

00:37:06,810 --> 00:37:10,490
then ignored so we're not even gonna do

00:37:08,760 --> 00:37:12,240
the look up for that value anyway and

00:37:10,490 --> 00:37:15,540
then this loop actually doesn't

00:37:12,240 --> 00:37:17,250
accomplish anything so if we get the GBM

00:37:15,540 --> 00:37:19,770
to understand all of these different

00:37:17,250 --> 00:37:21,810
pieces well enough this even disappears

00:37:19,770 --> 00:37:23,820
this is one of the wonderful challenges

00:37:21,810 --> 00:37:24,780
of benchmarking on the JVM you have to

00:37:23,820 --> 00:37:26,520
make sure your benchmark actually

00:37:24,780 --> 00:37:27,900
accomplishes something or it will

00:37:26,520 --> 00:37:30,210
actually optimize the whole thing away

00:37:27,900 --> 00:37:32,490
and this is now feasibly possible with

00:37:30,210 --> 00:37:35,460
Ruby that we can get the same sort of

00:37:32,490 --> 00:37:38,310
optimizations for Ruby that JVM guys

00:37:35,460 --> 00:37:42,600
have been talking about for years that's

00:37:38,310 --> 00:37:44,790
a nice one I like that actual numbers

00:37:42,600 --> 00:37:46,950
these are you'll notice none of these

00:37:44,790 --> 00:37:49,230
are silly fib benchmarks these are more

00:37:46,950 --> 00:37:51,600
real-world benchmarks doing base64

00:37:49,230 --> 00:37:53,040
encoding riches is kind of a vm

00:37:51,600 --> 00:37:56,070
simulated it does a few things that are

00:37:53,040 --> 00:37:58,140
difficult for BMS like polymorphic calls

00:37:56,070 --> 00:37:59,970
multiple targets at the same call site

00:37:58,140 --> 00:38:02,520
neural is a basically a neural network

00:37:59,970 --> 00:38:04,800
simulator very simple cs101 version of

00:38:02,520 --> 00:38:06,360
it Mandelbrot just generates a mantle

00:38:04,800 --> 00:38:08,760
brought to the console many times and

00:38:06,360 --> 00:38:12,060
red black builds up a very large red

00:38:08,760 --> 00:38:14,610
black tree walks it searches it deletes

00:38:12,060 --> 00:38:17,130
elements and whatnot this is jay ruby

00:38:14,610 --> 00:38:18,630
before invoke dynamic running on java 6

00:38:17,130 --> 00:38:20,940
and we're already doing pretty good

00:38:18,630 --> 00:38:23,790
we're generally faster than Ruby 19 for

00:38:20,940 --> 00:38:26,820
this stuff and with the invoke dynamic

00:38:23,790 --> 00:38:28,170
stuff much faster some of these cases

00:38:26,820 --> 00:38:30,330
are actually starting to get as close to

00:38:28,170 --> 00:38:31,770
what you would have for Java performance

00:38:30,330 --> 00:38:33,390
if you implemented essentially the same

00:38:31,770 --> 00:38:36,870
amount of work to be done behind the

00:38:33,390 --> 00:38:40,050
scenes another more recent benchmark

00:38:36,870 --> 00:38:42,060
Chuck remus post ported a c++

00:38:40,050 --> 00:38:43,950
implementation of Dicers smooth smooth

00:38:42,060 --> 00:38:45,240
sort you can go ahead and look at that

00:38:43,950 --> 00:38:47,720
if you want to get more details on it

00:38:45,240 --> 00:38:51,090
and again we're doing pretty well here

00:38:47,720 --> 00:38:53,370
Ruby 193 is definitely better than Ruby

00:38:51,090 --> 00:38:55,890
18 but we're pretty much blowing it away

00:38:53,370 --> 00:38:58,050
with invoke dynamic here and even other

00:38:55,890 --> 00:38:59,670
VMS that do native code generation are

00:38:58,050 --> 00:39:03,120
still not quite caught up to what the

00:38:59,670 --> 00:39:04,890
JVM jit can do here and this is again I

00:39:03,120 --> 00:39:06,660
could sit back and do nothing and the

00:39:04,890 --> 00:39:08,340
JVM guys were optimizing invoke dynamic

00:39:06,660 --> 00:39:12,090
would continue to make these graphs go

00:39:08,340 --> 00:39:13,530
up for jruby what are our rails rails is

00:39:12,090 --> 00:39:15,230
the biggest real-world application of

00:39:13,530 --> 00:39:17,390
all

00:39:15,230 --> 00:39:19,190
here's one tweet that somebody ran this

00:39:17,390 --> 00:39:21,200
and said that it was way or out for me

00:39:19,190 --> 00:39:23,960
performing 19 on their particular

00:39:21,200 --> 00:39:25,640
application and the the caveat here is

00:39:23,960 --> 00:39:27,410
it's going to vary depending on what

00:39:25,640 --> 00:39:28,760
your application does if you're doing a

00:39:27,410 --> 00:39:30,050
lot of data base hits and creating crap

00:39:28,760 --> 00:39:31,730
loads of objects and memory and doing a

00:39:30,050 --> 00:39:33,320
lot of database queries it's going to

00:39:31,730 --> 00:39:35,420
depend more on how fast the database

00:39:33,320 --> 00:39:37,070
layer works and how fast those queries

00:39:35,420 --> 00:39:38,150
can be generated and how fast the

00:39:37,070 --> 00:39:40,070
objects that go with them can be

00:39:38,150 --> 00:39:41,960
generated which is almost all native and

00:39:40,070 --> 00:39:43,700
every implementation but on your

00:39:41,960 --> 00:39:45,230
application if you've got a lot of Ruby

00:39:43,700 --> 00:39:47,390
intensive computation that's going on

00:39:45,230 --> 00:39:50,060
it's very likely that jer be able to run

00:39:47,390 --> 00:39:51,380
it considerably faster the torque box

00:39:50,060 --> 00:39:53,619
guys have run some of their own numbers

00:39:51,380 --> 00:39:56,570
naturally so here's the basic

00:39:53,619 --> 00:39:58,790
straightline performance numbers latency

00:39:56,570 --> 00:40:01,910
wise torque boxes is far and away the

00:39:58,790 --> 00:40:03,680
best request a return very quickly even

00:40:01,910 --> 00:40:05,869
at higher loads and with more concurrent

00:40:03,680 --> 00:40:08,270
requests it maintains very consistent

00:40:05,869 --> 00:40:11,000
latency and then throughput you'll see

00:40:08,270 --> 00:40:12,470
that but both of the Ruby 19 versions

00:40:11,000 --> 00:40:14,000
even though they've got their spinning

00:40:12,470 --> 00:40:16,640
up their threads or their processes in

00:40:14,000 --> 00:40:18,890
the background they are they eventually

00:40:16,640 --> 00:40:21,530
peak and they can't handle any more load

00:40:18,890 --> 00:40:24,230
too much memory pipeline too much GC

00:40:21,530 --> 00:40:25,609
overhead whatever it is the JVM versions

00:40:24,230 --> 00:40:27,500
both torque box and Trinidad can go a

00:40:25,609 --> 00:40:30,260
lot higher and this graph just continues

00:40:27,500 --> 00:40:32,660
to go up if we extend it more on the

00:40:30,260 --> 00:40:34,790
resource utilization side we see torque

00:40:32,660 --> 00:40:38,180
box and Trinidad as far as CPU use and

00:40:34,790 --> 00:40:40,130
almost always using less CPU to generate

00:40:38,180 --> 00:40:42,080
the same requests and in law cases

00:40:40,130 --> 00:40:46,340
generate those requests more quickly and

00:40:42,080 --> 00:40:48,260
using less memory in the process so

00:40:46,340 --> 00:40:50,630
we've got more free memory in the system

00:40:48,260 --> 00:40:53,090
running with the JRuby versions versus

00:40:50,630 --> 00:40:57,100
an actual scaled up version of a Ruby 19

00:40:53,090 --> 00:40:59,300
stuff alright that's about all I have

00:40:57,100 --> 00:41:02,180
really want people to just try this out

00:40:59,300 --> 00:41:04,880
we work on JRuby solely so that you can

00:41:02,180 --> 00:41:07,430
try out JRuby I mean I'm paid to work on

00:41:04,880 --> 00:41:09,530
it but I'm not like it's my day job it's

00:41:07,430 --> 00:41:10,910
it's not something where I'm expecting

00:41:09,530 --> 00:41:12,050
to get millions of dollars off this I do

00:41:10,910 --> 00:41:13,730
this because I like working on it

00:41:12,050 --> 00:41:16,340
because I like to help people run Ruby

00:41:13,730 --> 00:41:18,230
apps better turn on JRuby and Travis if

00:41:16,340 --> 00:41:21,260
you have any libraries travis has been

00:41:18,230 --> 00:41:22,850
by far the the greatest help for getting

00:41:21,260 --> 00:41:24,710
Ruby libraries to run across different

00:41:22,850 --> 00:41:27,740
limitations hopefully we can get

00:41:24,710 --> 00:41:28,910
platforms as part of that too and let us

00:41:27,740 --> 00:41:30,560
know what you think

00:41:28,910 --> 00:41:31,460
check out the books if your if you want

00:41:30,560 --> 00:41:33,290
to go straight to deploying applications

00:41:31,460 --> 00:41:35,540
we've got the deploying JRuby book which

00:41:33,290 --> 00:41:37,010
a lot of folks are enjoying the basic

00:41:35,540 --> 00:41:38,360
jruby book talks a lot about Java

00:41:37,010 --> 00:41:41,450
integration how to get you every other

00:41:38,360 --> 00:41:43,280
than going and you know it's it's up to

00:41:41,450 --> 00:41:45,920
you to help us make JRuby do what you

00:41:43,280 --> 00:41:47,660
want it to that's run faster use less

00:41:45,920 --> 00:41:50,360
memory support better more libraries

00:41:47,660 --> 00:41:53,240
just let us know and that's that's what

00:41:50,360 --> 00:41:56,240
we do there's the books again and

00:41:53,240 --> 00:41:59,830
there's my information so that's all I

00:41:56,240 --> 00:42:03,220
have got time for questions anything

00:41:59,830 --> 00:42:03,220
yeah here

00:42:07,330 --> 00:42:11,080
okay which if you switch to em remember

00:42:09,670 --> 00:42:13,660
I to JRuby what are the caveats are run

00:42:11,080 --> 00:42:16,870
into by far the biggest one is the C

00:42:13,660 --> 00:42:19,300
extension issue most applications that

00:42:16,870 --> 00:42:20,890
have grown up in MRI world use a lot of

00:42:19,300 --> 00:42:23,830
different see extension libraries for

00:42:20,890 --> 00:42:25,420
graphics or whatever else or for goofy

00:42:23,830 --> 00:42:29,500
things like markdown our discounts been

00:42:25,420 --> 00:42:32,920
a pain in my butt but in most cases

00:42:29,500 --> 00:42:34,510
there is usually an API a lot of the sea

00:42:32,920 --> 00:42:36,490
extension gems have a dash Java version

00:42:34,510 --> 00:42:38,170
that has a job of library that runs it

00:42:36,490 --> 00:42:40,360
behind the scenes for the ones that

00:42:38,170 --> 00:42:42,820
don't there's usually a an API

00:42:40,360 --> 00:42:44,590
compatible replacement or there's almost

00:42:42,820 --> 00:42:46,600
certainly a JVM library that you can

00:42:44,590 --> 00:42:47,830
swap in and that's a little bit more

00:42:46,600 --> 00:42:50,020
work because you're gonna have to work

00:42:47,830 --> 00:42:52,870
with a different API but there's

00:42:50,020 --> 00:42:54,460
basically no c extension library on MRI

00:42:52,870 --> 00:42:56,410
that doesn't have some sort of

00:42:54,460 --> 00:42:58,270
equivalent running on JRuby it just

00:42:56,410 --> 00:43:00,520
depends if it fits right if it's a

00:42:58,270 --> 00:43:02,920
drop-in replacement or not the other

00:43:00,520 --> 00:43:05,410
caveat is startup time which is an

00:43:02,920 --> 00:43:07,900
ongoing problem for us mostly this is

00:43:05,410 --> 00:43:09,670
JVM issues that it just starts out cold

00:43:07,900 --> 00:43:11,980
the entire implementation has to be

00:43:09,670 --> 00:43:15,370
compiled by the JVM to even parse things

00:43:11,980 --> 00:43:17,830
fast this is improving with the Java 7

00:43:15,370 --> 00:43:19,870
and Java 8 builds and with JRuby 17

00:43:17,830 --> 00:43:21,580
folks are reporting that its twenty

00:43:19,870 --> 00:43:25,150
thirty forty percent faster startup time

00:43:21,580 --> 00:43:27,220
there are things like JRuby r-spec guard

00:43:25,150 --> 00:43:28,810
stuff that will allow it to run tests in

00:43:27,220 --> 00:43:31,330
the background so TDD can be a little

00:43:28,810 --> 00:43:33,310
bit easier and we have support for

00:43:31,330 --> 00:43:34,960
something built-in called nail gun which

00:43:33,310 --> 00:43:36,580
basically keeps a warm JVM in the

00:43:34,960 --> 00:43:39,580
background and just tosses it commands

00:43:36,580 --> 00:43:41,830
that can make / command run times be

00:43:39,580 --> 00:43:43,870
down below a second almost every time so

00:43:41,830 --> 00:43:45,460
does there are a few few little

00:43:43,870 --> 00:43:47,500
mitigating items you have to think about

00:43:45,460 --> 00:43:52,120
making a migration but in general

00:43:47,500 --> 00:43:53,650
there's ways around all of them all

00:43:52,120 --> 00:43:55,860
right what we'll call that a day thanks

00:43:53,650 --> 00:43:55,860
very much

00:44:07,420 --> 00:44:09,480

YouTube URL: https://www.youtube.com/watch?v=etCJKDCbCj4


