Title: Web API's with ERLANG a Ruby Dev's POV by Patrick Huesler
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGfm/
Captions: 
	00:00:00,320 --> 00:00:19,220
[Music]

00:00:14,710 --> 00:00:24,320
good morning everyone welcome to my talk

00:00:19,220 --> 00:00:27,349
that called more than syntax my name's

00:00:24,320 --> 00:00:30,590
Patrick and you can find me under fueler

00:00:27,349 --> 00:00:33,200
on Twitter I've been told to that you

00:00:30,590 --> 00:00:37,399
should not give out your name on stage

00:00:33,200 --> 00:00:39,530
by a trainer but I think that's just

00:00:37,399 --> 00:00:43,190
rude so I grabbed it I read on that and

00:00:39,530 --> 00:00:45,829
I should introduce myself more than

00:00:43,190 --> 00:00:49,280
syntax was the original name of the talk

00:00:45,829 --> 00:00:52,519
and but on the way here I changed my

00:00:49,280 --> 00:00:55,850
mind and I pivoted on my talk like a

00:00:52,519 --> 00:00:59,989
good startup does these days so I

00:00:55,850 --> 00:01:03,739
changed it to that api's with Earl and a

00:00:59,989 --> 00:01:05,570
Ruby developers point of view in which

00:01:03,739 --> 00:01:08,780
I'm going to talk about how you can

00:01:05,570 --> 00:01:11,990
write web services in Erlang and how you

00:01:08,780 --> 00:01:13,850
can have your Ruby tools did you do it

00:01:11,990 --> 00:01:16,670
off your environment and your

00:01:13,850 --> 00:01:18,799
automations and your deployments all

00:01:16,670 --> 00:01:21,170
stuff like that if you can have that in

00:01:18,799 --> 00:01:24,110
Berlin that's what I've been trying to

00:01:21,170 --> 00:01:26,619
do in the last three months also on a

00:01:24,110 --> 00:01:30,439
very important note from yesterday

00:01:26,619 --> 00:01:32,570
Terence Lee is not a liar because

00:01:30,439 --> 00:01:35,570
apparently he gave it into yesterday

00:01:32,570 --> 00:01:39,020
telling a telling that he's looking

00:01:35,570 --> 00:01:41,930
forward to life coding in my talk and

00:01:39,020 --> 00:01:45,469
that's not gonna happen because I

00:01:41,930 --> 00:01:50,090
changed a talk again because I cannot

00:01:45,469 --> 00:01:52,729
coat and frame coherent sentences it's

00:01:50,090 --> 00:01:55,899
just not how I work several spare you

00:01:52,729 --> 00:01:58,609
the embarrassment and I skip that so

00:01:55,899 --> 00:02:00,350
there isn't a liar in fact he's awesome

00:01:58,609 --> 00:02:04,440
also with his work on the rails gross

00:02:00,350 --> 00:02:08,020
so it's no warning

00:02:04,440 --> 00:02:11,380
cool topic for Hawaii I guess so but

00:02:08,020 --> 00:02:13,230
bear with me I grew up in Switzerland in

00:02:11,380 --> 00:02:16,360
the mountains I grew up in snow

00:02:13,230 --> 00:02:19,209
so snowboarding skiing ice hockey you

00:02:16,360 --> 00:02:22,300
name it I did it there was even one

00:02:19,209 --> 00:02:25,569
incidents where actually would go to

00:02:22,300 --> 00:02:27,250
kindergarten with my skis on zoom'

00:02:25,569 --> 00:02:31,110
fairly proficient in snowboarding I know

00:02:27,250 --> 00:02:33,430
how it works which brings me to surfing

00:02:31,110 --> 00:02:35,739
for one reason I have this slide so I

00:02:33,430 --> 00:02:38,860
can actually wear shorts onstage as a

00:02:35,739 --> 00:02:44,019
prop I don't feel embarrassed but also

00:02:38,860 --> 00:02:46,450
because I wanted to learn surfing and I

00:02:44,019 --> 00:02:48,640
thought it would be easy knowing how to

00:02:46,450 --> 00:02:51,250
snowboard I thought it's just piece of

00:02:48,640 --> 00:02:53,050
cake let's just do it so I actually did

00:02:51,250 --> 00:02:55,900
read a book what's your thing

00:02:53,050 --> 00:02:58,330
every detail how you do it I know

00:02:55,900 --> 00:03:00,280
thought well that's great I can do it

00:02:58,330 --> 00:03:03,180
it's very similar snowboarding no

00:03:00,280 --> 00:03:07,690
problem so one day yep she went out

00:03:03,180 --> 00:03:10,000
surfing and I got my board shorts or in

00:03:07,690 --> 00:03:12,000
fact in a European most of time need a

00:03:10,000 --> 00:03:14,829
wetsuit because the waters too cold so

00:03:12,000 --> 00:03:16,840
only now I did the surf check check for

00:03:14,829 --> 00:03:20,019
the waves or where the currents or where

00:03:16,840 --> 00:03:22,420
the lineup is and I wanted to pedal out

00:03:20,019 --> 00:03:24,190
I fell off the boards first thing I

00:03:22,420 --> 00:03:26,290
didn't know those things are pretty

00:03:24,190 --> 00:03:28,989
wobbly so I couldn't even panel that

00:03:26,290 --> 00:03:32,320
thing so the next day roadblock that a

00:03:28,989 --> 00:03:35,049
hit was trying to get out but I managed

00:03:32,320 --> 00:03:37,329
to get around this then I was planning

00:03:35,049 --> 00:03:39,610
my first way if I paddle it on I was

00:03:37,329 --> 00:03:41,260
quite confident I would stand up and I

00:03:39,610 --> 00:03:44,410
had a great feeling that this is going

00:03:41,260 --> 00:03:47,049
to be like snowboarding and this is what

00:03:44,410 --> 00:03:51,450
happened and this is what's happened to

00:03:47,049 --> 00:03:54,030
whole afternoon so the lesson here is

00:03:51,450 --> 00:03:57,720
sometimes just reading a book and

00:03:54,030 --> 00:04:00,190
banking on your previous knowledge and

00:03:57,720 --> 00:04:03,299
that being transferable to your new

00:04:00,190 --> 00:04:07,359
skill sometimes doesn't really cut it

00:04:03,299 --> 00:04:10,340
which brings me to early same story here

00:04:07,359 --> 00:04:15,180
or similar story just with Ruby and

00:04:10,340 --> 00:04:19,230
um so just a quick check who here has

00:04:15,180 --> 00:04:22,320
looked into airline Wow

00:04:19,230 --> 00:04:28,520
who here has right production as written

00:04:22,320 --> 00:04:32,580
production code in airline okay okay so

00:04:28,520 --> 00:04:34,500
I am actually in Erlang beginners wall

00:04:32,580 --> 00:04:37,470
I've only been using it productively for

00:04:34,500 --> 00:04:39,450
a couple of months I started getting

00:04:37,470 --> 00:04:42,180
into it like four years ago but I didn't

00:04:39,450 --> 00:04:44,760
never go went further than the chat

00:04:42,180 --> 00:04:46,320
server HelloWorld application so that

00:04:44,760 --> 00:04:50,190
also means you shouldn't believe like

00:04:46,320 --> 00:04:51,450
it's a beginner's perspective so there

00:04:50,190 --> 00:04:53,070
might be some stuff in there that an

00:04:51,450 --> 00:04:55,290
experienced airline developer we just go

00:04:53,070 --> 00:04:57,060
no that's not how we work so you find

00:04:55,290 --> 00:04:58,920
something like that please let me know

00:04:57,060 --> 00:05:02,700
after the talk and I'll try to correct

00:04:58,920 --> 00:05:03,840
it and I will not cover an introduction

00:05:02,700 --> 00:05:06,270
to Erlang

00:05:03,840 --> 00:05:07,860
I think I'm not able to in the first

00:05:06,270 --> 00:05:11,610
place other people have done is a lot

00:05:07,860 --> 00:05:15,240
better I will more focus on the concepts

00:05:11,610 --> 00:05:18,680
and under stuff that I have to build to

00:05:15,240 --> 00:05:21,870
have like my rails Ruby mindset tools

00:05:18,680 --> 00:05:25,260
working in Erlang and preferably do a

00:05:21,870 --> 00:05:27,510
long way so not trying to shoehorn Ruby

00:05:25,260 --> 00:05:29,760
ways into Erlang so I will focus on that

00:05:27,510 --> 00:05:33,840
and it's gonna be a lot of a lot of

00:05:29,760 --> 00:05:35,370
content a lot of code it doesn't um will

00:05:33,840 --> 00:05:37,020
not go to into every detail but it's

00:05:35,370 --> 00:05:39,240
fine I put everything up on a github

00:05:37,020 --> 00:05:41,490
repository and I deployed the

00:05:39,240 --> 00:05:44,400
application to Heroku so you can check

00:05:41,490 --> 00:05:46,260
up on that later on just to make sure

00:05:44,400 --> 00:05:50,130
we're on the same page a quick Erlang

00:05:46,260 --> 00:05:54,140
refresher it is a functional language so

00:05:50,130 --> 00:05:56,310
it's based on the mathematical paradigm

00:05:54,140 --> 00:06:00,030
your code everything is a mathematical

00:05:56,310 --> 00:06:03,390
function then you work with it tries to

00:06:00,030 --> 00:06:05,430
avoid state and mutable data which turns

00:06:03,390 --> 00:06:07,890
out is extremely useful for some for

00:06:05,430 --> 00:06:10,880
stuff you build in Erlang it has a

00:06:07,890 --> 00:06:13,200
compiled language that builds byte codes

00:06:10,880 --> 00:06:14,800
that's called beam files and it gets

00:06:13,200 --> 00:06:16,720
executed by a virtual machine

00:06:14,800 --> 00:06:19,410
it handles everything and handles the

00:06:16,720 --> 00:06:23,890
connection between nodes and clusters

00:06:19,410 --> 00:06:26,110
and there's Erlang OTP which is a set of

00:06:23,890 --> 00:06:28,840
common practices patterns and

00:06:26,110 --> 00:06:30,670
abstractions that help you build great

00:06:28,840 --> 00:06:33,100
applications in Erlang like a generic

00:06:30,670 --> 00:06:38,200
server like state machines and event

00:06:33,100 --> 00:06:42,370
handling so white Erlang first of all

00:06:38,200 --> 00:06:43,720
because Koree Hanes likes it and if

00:06:42,370 --> 00:06:47,390
that's not good enough for you

00:06:43,720 --> 00:06:50,480
I've brought the bigger gun

00:06:47,390 --> 00:06:50,480
[Music]

00:06:54,340 --> 00:06:59,620
hello my name is Brianna Decker and I'm

00:06:57,550 --> 00:07:03,340
responsible for the computer science

00:06:59,620 --> 00:07:08,200
laboratory our job that is to put

00:07:03,340 --> 00:07:10,720
research to work and our main challenge

00:07:08,200 --> 00:07:14,250
that is how to program large real-time

00:07:10,720 --> 00:07:19,120
systems as efficiently as possible and

00:07:14,250 --> 00:07:21,250
after many experiments we decided that

00:07:19,120 --> 00:07:25,480
we had to move from convention

00:07:21,250 --> 00:07:28,420
high-level languages such as ada Qin C++

00:07:25,480 --> 00:07:32,950
etc into the world of declarative

00:07:28,420 --> 00:07:35,620
programming we also found out that the

00:07:32,950 --> 00:07:40,420
only way to do that that was to develop

00:07:35,620 --> 00:07:43,450
our own language and the language which

00:07:40,420 --> 00:07:44,950
is called Ireland in this video will

00:07:43,450 --> 00:07:48,150
show you about the properties of this

00:07:44,950 --> 00:07:51,220
language and how its applied in large

00:07:48,150 --> 00:07:53,380
prototyping projects and also about the

00:07:51,220 --> 00:07:58,960
potentials of this language for the

00:07:53,380 --> 00:08:00,460
future so I'm shooting when you start

00:07:58,960 --> 00:08:02,640
running your own code maybe right after

00:08:00,460 --> 00:08:04,870
this talk should you ever get stuck

00:08:02,640 --> 00:08:06,850
instead of asking yourself what Freddie

00:08:04,870 --> 00:08:09,070
Mercury would do ask yourself what that

00:08:06,850 --> 00:08:12,310
guy would do and you might actually find

00:08:09,070 --> 00:08:14,800
the answer so why Erlang from my

00:08:12,310 --> 00:08:16,690
perspective it's is seriously concurrent

00:08:14,800 --> 00:08:21,370
and it was built for that

00:08:16,690 --> 00:08:22,690
so most CPU and i/o concurrency and you

00:08:21,370 --> 00:08:25,060
don't have to bother what do you want to

00:08:22,690 --> 00:08:27,580
use a non-blocking i/o blocking i/o

00:08:25,060 --> 00:08:30,490
event machine and stuff like that it's

00:08:27,580 --> 00:08:32,290
just built in there you can do oh and

00:08:30,490 --> 00:08:33,910
you can have singles calls and a

00:08:32,290 --> 00:08:37,960
synchronous calls it's just there for

00:08:33,910 --> 00:08:40,570
you and it is built with actors which is

00:08:37,960 --> 00:08:43,120
a great model of concurrency that it

00:08:40,570 --> 00:08:46,660
uses message passing and make sure that

00:08:43,120 --> 00:08:47,860
you have no shared data that could get

00:08:46,660 --> 00:08:50,440
corrupted and you have to date with

00:08:47,860 --> 00:08:53,050
locks to make sure only one person at

00:08:50,440 --> 00:08:56,569
the time is actually accessing that data

00:08:53,050 --> 00:08:58,550
and you can see actors in a ruby world

00:08:56,569 --> 00:09:01,399
even if friends in the framework called

00:08:58,550 --> 00:09:04,120
celluloid which is filling an actor

00:09:01,399 --> 00:09:06,889
framework for that and which was

00:09:04,120 --> 00:09:11,089
actually quite nice on JRuby and

00:09:06,889 --> 00:09:14,120
Rubinius and it is distributed so

00:09:11,089 --> 00:09:16,730
networking is almost trivial in Erlang

00:09:14,120 --> 00:09:18,740
talking to other machines building other

00:09:16,730 --> 00:09:21,410
services talking about service-oriented

00:09:18,740 --> 00:09:24,560
architecture if you want it's just right

00:09:21,410 --> 00:09:26,810
in there in Erlang and you can see the

00:09:24,560 --> 00:09:29,269
power of it if you look at this you get

00:09:26,810 --> 00:09:30,829
it data bases like how to be or react

00:09:29,269 --> 00:09:33,199
that are written in Erlang

00:09:30,829 --> 00:09:35,420
so this article is one two core strings

00:09:33,199 --> 00:09:40,459
of Erlang another one is it's for a

00:09:35,420 --> 00:09:42,980
tolerant Erlang systems are built to run

00:09:40,459 --> 00:09:45,110
all the time and it's they expect

00:09:42,980 --> 00:09:47,029
failure and one or two lots of phases

00:09:45,110 --> 00:09:49,279
actually let it crash because if

00:09:47,029 --> 00:09:51,079
infrastructures that will restart things

00:09:49,279 --> 00:09:52,970
and they go wrong and here you can

00:09:51,079 --> 00:09:54,589
really find great strategies what

00:09:52,970 --> 00:09:56,629
happens when something goes wrong what

00:09:54,589 --> 00:09:59,959
gets restarted and can build up whole

00:09:56,629 --> 00:10:02,660
hierarchies and I'll let explain one of

00:09:59,959 --> 00:10:08,720
my favorite features by Bill O'Reilly

00:10:02,660 --> 00:10:10,910
will do it live okay do it live do it

00:10:08,720 --> 00:10:18,709
live I can go write it and we'll do it

00:10:10,910 --> 00:10:23,329
live thing sucks for three

00:10:18,709 --> 00:10:25,759
so that ever happened to you that you

00:10:23,329 --> 00:10:27,170
actually wanted to do stuff life on the

00:10:25,759 --> 00:10:29,750
production system because you were

00:10:27,170 --> 00:10:31,040
running out of time and you didn't and

00:10:29,750 --> 00:10:33,050
you wanted to go home we wanted to go to

00:10:31,040 --> 00:10:34,670
bed or something and it just weren't in

00:10:33,050 --> 00:10:37,100
the mood to apply the proper tools it

00:10:34,670 --> 00:10:39,250
just needed a quick fix and early is a

00:10:37,100 --> 00:10:42,170
compare compiled language remember that

00:10:39,250 --> 00:10:45,500
so but it allows you to do hot swapping

00:10:42,170 --> 00:10:46,910
so you never have to take down the whole

00:10:45,500 --> 00:10:48,319
virtual machine you know have to take

00:10:46,910 --> 00:10:50,839
down the whole system it has

00:10:48,319 --> 00:10:53,449
infrastructures to upgrade your codes to

00:10:50,839 --> 00:10:55,220
reload your codes and you can go and

00:10:53,449 --> 00:10:57,019
compile code and change stuff around and

00:10:55,220 --> 00:10:58,399
reload it without ever taking it down

00:10:57,019 --> 00:11:00,140
but it also has a lot of good

00:10:58,399 --> 00:11:04,100
infrastructure to do this in a very

00:11:00,140 --> 00:11:06,080
old way if you want to and you have a

00:11:04,100 --> 00:11:08,810
remote shell you can attach to every

00:11:06,080 --> 00:11:11,900
node in your in your airline cluster and

00:11:08,810 --> 00:11:14,120
get like an IRB but within the context

00:11:11,900 --> 00:11:16,250
of the running virtual machine so you

00:11:14,120 --> 00:11:18,320
can inspect processes you can expect

00:11:16,250 --> 00:11:22,520
memories you can turn on login for

00:11:18,320 --> 00:11:24,770
certain users and so on and so forth so

00:11:22,520 --> 00:11:27,830
the way we use Erlang at Mooga that's

00:11:24,770 --> 00:11:29,870
the company I work for the way the

00:11:27,830 --> 00:11:33,290
reason why we started using it is

00:11:29,870 --> 00:11:38,960
because we do games on Facebook and on

00:11:33,290 --> 00:11:40,880
iOS games like Monster World where you

00:11:38,960 --> 00:11:42,740
share data with your friends you can

00:11:40,880 --> 00:11:44,450
look at the Gordon of your friends you

00:11:42,740 --> 00:11:47,300
create your own friends with nice little

00:11:44,450 --> 00:11:48,950
decorations and you can go your friends

00:11:47,300 --> 00:11:51,860
Gordon and help them out what are their

00:11:48,950 --> 00:11:55,520
plants send them magic gifts in these

00:11:51,860 --> 00:11:57,440
videos however the review technical

00:11:55,520 --> 00:12:00,470
challenges involved when you when it

00:11:57,440 --> 00:12:05,060
comes to a back-end system because our

00:12:00,470 --> 00:12:07,970
biggest game Dimond - has roughly 20

00:12:05,060 --> 00:12:11,270
million users every month I think it

00:12:07,970 --> 00:12:14,000
took that data early October and they on

00:12:11,270 --> 00:12:17,870
a daily basis that is like almost four

00:12:14,000 --> 00:12:19,760
million users so for a back-end system

00:12:17,870 --> 00:12:22,250
that can mean I meet a lot of traffic

00:12:19,760 --> 00:12:23,930
that you have to deal with so the peak

00:12:22,250 --> 00:12:25,930
that I took from that game monster world

00:12:23,930 --> 00:12:28,520
that I showed earlier with the Gordon

00:12:25,930 --> 00:12:32,960
was six thousand five hundred requests

00:12:28,520 --> 00:12:36,590
per second and that it would be always a

00:12:32,960 --> 00:12:38,240
product depending on the traffic but the

00:12:36,590 --> 00:12:41,420
problem is for us it's the database

00:12:38,240 --> 00:12:45,140
where it really hurts and the reason why

00:12:41,420 --> 00:12:48,530
that is once requests are rights so you

00:12:45,140 --> 00:12:52,100
classic go-to solutions like caching

00:12:48,530 --> 00:12:55,010
adding read slaves it's not gonna cut it

00:12:52,100 --> 00:12:58,100
so we optimized our databases for a long

00:12:55,010 --> 00:13:00,410
long time until we figured well there

00:12:58,100 --> 00:13:03,200
must be something else and all of one of

00:13:00,410 --> 00:13:04,970
our engineers that came up with a great

00:13:03,200 --> 00:13:09,139
different architecture

00:13:04,970 --> 00:13:10,910
that he decided to build and this is my

00:13:09,139 --> 00:13:12,649
interpretation of it and he never said

00:13:10,910 --> 00:13:16,069
that but this is my interpretation of it

00:13:12,649 --> 00:13:19,370
is that no database we're gonna have a

00:13:16,069 --> 00:13:21,680
stateful application so the user session

00:13:19,370 --> 00:13:24,980
will live in memory and we tried

00:13:21,680 --> 00:13:28,759
everything on s3 just get rid of the

00:13:24,980 --> 00:13:31,850
pain point database completely and the

00:13:28,759 --> 00:13:34,670
way it was set up was imagine you go to

00:13:31,850 --> 00:13:37,819
Facebook you click on the link you start

00:13:34,670 --> 00:13:40,629
playing your game a login calls gets to

00:13:37,819 --> 00:13:44,060
the server a coordinator system service

00:13:40,629 --> 00:13:47,000
will assign a new worker to it or create

00:13:44,060 --> 00:13:50,389
one which then will make the lock that

00:13:47,000 --> 00:13:51,829
data will lock that user session so to

00:13:50,389 --> 00:13:55,160
make sure nobody else is fighting to s3

00:13:51,829 --> 00:13:57,170
while it's on and then you load it from

00:13:55,160 --> 00:13:58,819
s3 and from that all the user would

00:13:57,170 --> 00:14:01,430
actually play to the data in memory

00:13:58,819 --> 00:14:02,990
right away and the sync rescinded back

00:14:01,430 --> 00:14:03,550
in the background in inserting into

00:14:02,990 --> 00:14:07,399
walls

00:14:03,550 --> 00:14:09,620
it would save it back to us three so if

00:14:07,399 --> 00:14:11,420
you if you if you lose a few minutes of

00:14:09,620 --> 00:14:14,689
data normally it's not that big of a

00:14:11,420 --> 00:14:18,290
deal for those kinda games and the log

00:14:14,689 --> 00:14:20,180
out this reverse released a log right

00:14:18,290 --> 00:14:23,180
back to three and release the lock and

00:14:20,180 --> 00:14:24,709
terminated session and typically for the

00:14:23,180 --> 00:14:28,189
game that was initially built four

00:14:24,709 --> 00:14:30,620
fingers on roughly 20 minutes and the

00:14:28,189 --> 00:14:32,300
reason why you wanted to build that in

00:14:30,620 --> 00:14:36,319
Erlang is because if Erlang processes

00:14:32,300 --> 00:14:38,809
are cheap so every user session is a

00:14:36,319 --> 00:14:41,480
process and you can run 30 cells and

00:14:38,809 --> 00:14:44,750
user sessions on one machine if you want

00:14:41,480 --> 00:14:46,819
to try that in Ruby try to fork 30 cells

00:14:44,750 --> 00:14:49,370
and Ruby processes on one machine it's

00:14:46,819 --> 00:14:51,350
just not gonna work so the weight is set

00:14:49,370 --> 00:14:54,949
up in Erlang is your processes live

00:14:51,350 --> 00:14:57,350
inside your virtual machine and if one

00:14:54,949 --> 00:15:00,860
correct there is one operating system

00:14:57,350 --> 00:15:03,199
threads per CPU that along with VM is

00:15:00,860 --> 00:15:05,870
managing and it will make sure it runs

00:15:03,199 --> 00:15:08,389
concurrently and this is also better way

00:15:05,870 --> 00:15:11,029
of thinking you just move stuff out into

00:15:08,389 --> 00:15:12,500
processes that you can also move around

00:15:11,029 --> 00:15:14,140
because you don't need to know where the

00:15:12,500 --> 00:15:16,089
process is it could be on your machine

00:15:14,140 --> 00:15:18,310
it could be on another machine if you

00:15:16,089 --> 00:15:21,959
know it's PID edges can talk to it which

00:15:18,310 --> 00:15:27,940
is a really powerful construct over LAN

00:15:21,959 --> 00:15:32,860
so let's talk about BPS i want to talk

00:15:27,940 --> 00:15:37,529
about environments logging as we know it

00:15:32,860 --> 00:15:43,779
from Ruby and rails and Sinatra testing

00:15:37,529 --> 00:15:46,180
and actually deploying it to Heroku the

00:15:43,779 --> 00:15:47,680
first tool that he that I normally use

00:15:46,180 --> 00:15:50,920
for many of those things is called

00:15:47,680 --> 00:15:54,640
reborn which is a mixture between your

00:15:50,920 --> 00:15:56,320
rails command and Ruby gems it was

00:15:54,640 --> 00:15:59,860
written by basher the guys who built

00:15:56,320 --> 00:16:02,560
react so to start out you create a new

00:15:59,860 --> 00:16:06,730
application like this and this will

00:16:02,560 --> 00:16:09,220
create your skeleton for you and Erlang

00:16:06,730 --> 00:16:11,140
has this concept of applications built

00:16:09,220 --> 00:16:12,790
right in so your application might

00:16:11,140 --> 00:16:15,130
actually exist over several applications

00:16:12,790 --> 00:16:18,250
let you start think of it this is think

00:16:15,130 --> 00:16:19,899
of it as services that you use or you

00:16:18,250 --> 00:16:24,880
can also look at it as chance depending

00:16:19,899 --> 00:16:29,620
on what you do so so let's set up that

00:16:24,880 --> 00:16:31,180
structure and then of course you know we

00:16:29,620 --> 00:16:32,829
have a lot of dependencies in your code

00:16:31,180 --> 00:16:34,329
that you want to write talking about

00:16:32,829 --> 00:16:38,110
external libraries that you want to have

00:16:34,329 --> 00:16:40,240
a my sequel client or a certain piece of

00:16:38,110 --> 00:16:41,829
functionality and web server things like

00:16:40,240 --> 00:16:46,029
that something you normally specified

00:16:41,829 --> 00:16:48,730
hmph I write Reaper does this again for

00:16:46,029 --> 00:16:50,920
you and then you know it gives you the

00:16:48,730 --> 00:16:54,220
commands to get to dependencies to

00:16:50,920 --> 00:16:55,630
compile them compile your code in the

00:16:54,220 --> 00:16:57,790
pile the dependences code those are the

00:16:55,630 --> 00:16:58,500
most commonly used commands that are

00:16:57,790 --> 00:17:02,040
using

00:16:58,500 --> 00:17:04,730
in rebar and a configuration file looks

00:17:02,040 --> 00:17:04,730
a little bit like this

00:17:09,660 --> 00:17:15,569
I know it's not pretty but there is our

00:17:12,929 --> 00:17:19,350
proper Erlang structure so we tell it

00:17:15,569 --> 00:17:20,850
the name of the application tell it what

00:17:19,350 --> 00:17:23,010
revision you want what give me positive

00:17:20,850 --> 00:17:26,669
is it is and what your vision you want

00:17:23,010 --> 00:17:29,330
and then you run rebar get dependencies

00:17:26,669 --> 00:17:31,770
and you will fetch all the dependencies

00:17:29,330 --> 00:17:34,410
the next thing we need is a web server

00:17:31,770 --> 00:17:37,440
there are a couple of ones in Erlang one

00:17:34,410 --> 00:17:38,700
of this is there's much evap there is

00:17:37,440 --> 00:17:42,690
wet machine

00:17:38,700 --> 00:17:46,110
there's cowboy there is yours on we

00:17:42,690 --> 00:17:50,520
however can you one of our engineers we

00:17:46,110 --> 00:17:52,080
actually built our own server not for

00:17:50,520 --> 00:17:54,179
some reason we didn't like everything in

00:17:52,080 --> 00:17:57,270
cowboy and we wanted to have more

00:17:54,179 --> 00:17:59,100
control of the request lifecycle and get

00:17:57,270 --> 00:18:02,429
more insight in what's happening inside

00:17:59,100 --> 00:18:03,809
a request which is a really important

00:18:02,429 --> 00:18:05,669
trust for monitoring yeah a lot of

00:18:03,809 --> 00:18:07,230
dashboards and really really make want

00:18:05,669 --> 00:18:10,470
to make sure we detect problems early

00:18:07,230 --> 00:18:13,470
and so here we can actually see on a

00:18:10,470 --> 00:18:15,330
socket level what's happening and it's

00:18:13,470 --> 00:18:16,650
very little code I even contributed sir

00:18:15,330 --> 00:18:19,650
Sam when I think there's a couple pages

00:18:16,650 --> 00:18:22,980
of codes a complete web server in Erlang

00:18:19,650 --> 00:18:24,450
that is quite fast it's a lot faster

00:18:22,980 --> 00:18:29,250
than every rupee thing that I've seen so

00:18:24,450 --> 00:18:30,510
far so it's the first airline code but I

00:18:29,250 --> 00:18:33,630
think you all since you're all familiar

00:18:30,510 --> 00:18:37,200
with it I will skip the details about

00:18:33,630 --> 00:18:39,419
modules and functions so you passing a

00:18:37,200 --> 00:18:42,059
callback module which is like your C

00:18:39,419 --> 00:18:43,679
natural base class any passing that

00:18:42,059 --> 00:18:46,919
implement certain functions that get

00:18:43,679 --> 00:18:51,480
called and request comes in and you pass

00:18:46,919 --> 00:18:54,000
a report and next thing you want to do

00:18:51,480 --> 00:18:57,120
it's relics rights because only having

00:18:54,000 --> 00:18:59,610
one endpoint normally doesn't cut it and

00:18:57,120 --> 00:19:02,640
so I've looked into it and I are I built

00:18:59,610 --> 00:19:05,549
my own router I look something like that

00:19:02,640 --> 00:19:10,200
I've built my own rails style router

00:19:05,549 --> 00:19:11,440
where you can define a path an HTTP

00:19:10,200 --> 00:19:14,960
method and

00:19:11,440 --> 00:19:18,110
here define if this route is happening

00:19:14,960 --> 00:19:19,580
with this HTTP verb then call my handler

00:19:18,110 --> 00:19:23,330
with that method with those arguments

00:19:19,580 --> 00:19:26,650
and then you will match it if you find

00:19:23,330 --> 00:19:28,460
it well you get a 404 or something and

00:19:26,650 --> 00:19:31,250
otherwise he will actually call that

00:19:28,460 --> 00:19:32,930
function on that module I know it took

00:19:31,250 --> 00:19:35,630
me one morning to write that I never is

00:19:32,930 --> 00:19:37,840
extremely proud and I talked to every

00:19:35,630 --> 00:19:42,170
one of our more seasoned programmers

00:19:37,840 --> 00:19:44,900
Erlang programmers that is it was just

00:19:42,170 --> 00:19:49,250
laughing at me he said you're doing it

00:19:44,900 --> 00:19:50,450
wrong what he only told me a couple of

00:19:49,250 --> 00:19:53,210
weeks later is that he made the same

00:19:50,450 --> 00:19:54,410
mistake I think two years ago but at

00:19:53,210 --> 00:19:58,820
first you wouldn't tell that me would

00:19:54,410 --> 00:20:00,140
actually make fun of me so he said you

00:19:58,820 --> 00:20:02,470
have to use pattern matching it's

00:20:00,140 --> 00:20:04,910
everybody familiar with pattern matching

00:20:02,470 --> 00:20:06,830
I've got me to change tech questions is

00:20:04,910 --> 00:20:08,840
anybody not familiar repair pattern

00:20:06,830 --> 00:20:12,680
matching okay

00:20:08,840 --> 00:20:15,350
so here it is what you can do in Erlang

00:20:12,680 --> 00:20:18,890
is and also other functional languages

00:20:15,350 --> 00:20:21,680
is you can extract certain parts of your

00:20:18,890 --> 00:20:24,500
data by giving if you have an equal sign

00:20:21,680 --> 00:20:27,290
you can have your data on the left and a

00:20:24,500 --> 00:20:29,090
pattern how you want to instruct your

00:20:27,290 --> 00:20:30,830
date on the right and on the left of to

00:20:29,090 --> 00:20:33,440
kun-sun you can have a pattern how you

00:20:30,830 --> 00:20:37,220
want to extract that data for instance

00:20:33,440 --> 00:20:40,130
if you would if you look at the foobar

00:20:37,220 --> 00:20:43,760
method this is a function definition

00:20:40,130 --> 00:20:47,240
header so you already say okay I expect

00:20:43,760 --> 00:20:50,090
a string which is it get and as expect a

00:20:47,240 --> 00:20:52,520
list as a second argument with the two

00:20:50,090 --> 00:20:54,770
items foo and bar which is displayed

00:20:52,520 --> 00:20:57,170
pass as a waste that you're getting from

00:20:54,770 --> 00:20:59,480
Helena so it can automatically extract

00:20:57,170 --> 00:21:01,700
it and if that doesn't work if Erlang

00:20:59,480 --> 00:21:03,470
cannot match that pattern it will go

00:21:01,700 --> 00:21:06,560
through all those methods until it

00:21:03,470 --> 00:21:08,320
eventually comes here because this is

00:21:06,560 --> 00:21:10,390
sort of your wild card matching

00:21:08,320 --> 00:21:13,750
you can think stars in regular

00:21:10,390 --> 00:21:15,670
expressions something so much that it is

00:21:13,750 --> 00:21:18,580
extremely powerful concepts that you

00:21:15,670 --> 00:21:20,860
also use inside your functions but this

00:21:18,580 --> 00:21:22,150
is you have this often directing your

00:21:20,860 --> 00:21:25,300
functions your functions with the same

00:21:22,150 --> 00:21:26,800
name and but different parameter

00:21:25,300 --> 00:21:27,880
settings and different specific

00:21:26,800 --> 00:21:30,190
matchings which gives you a really

00:21:27,880 --> 00:21:33,130
powerful and really dramatic way of

00:21:30,190 --> 00:21:36,280
doing things because here if you look at

00:21:33,130 --> 00:21:39,880
method number 5 on line number 5 you

00:21:36,280 --> 00:21:42,190
know this is a get request on to slash

00:21:39,880 --> 00:21:44,200
bar right so the slash is sort of

00:21:42,190 --> 00:21:45,820
emitted away but everything else is

00:21:44,200 --> 00:21:50,650
actually really clear and yep it really

00:21:45,820 --> 00:21:54,400
central like you know it from Sinatra so

00:21:50,650 --> 00:21:55,200
middleware who here likes rack

00:21:54,400 --> 00:22:01,510
middleware

00:21:55,200 --> 00:22:03,610
though he uses it right I'm a big fan

00:22:01,510 --> 00:22:06,360
because you can abstract functionality

00:22:03,610 --> 00:22:09,370
that is generic and just take it out

00:22:06,360 --> 00:22:11,500
into its own thing and reuse it across

00:22:09,370 --> 00:22:15,040
applications yeah for instance for

00:22:11,500 --> 00:22:16,960
logging or monitoring for exception

00:22:15,040 --> 00:22:19,600
tracking you could just pop that into

00:22:16,960 --> 00:22:20,770
your rectum anywhere and we wanted to

00:22:19,600 --> 00:22:25,810
have that as well for Ellie

00:22:20,770 --> 00:22:27,670
and so that built it and way how you do

00:22:25,810 --> 00:22:29,290
it it's it's what similar to how you

00:22:27,670 --> 00:22:32,170
tell it which is the main entry point

00:22:29,290 --> 00:22:34,330
for your web api you just give it the

00:22:32,170 --> 00:22:37,600
name of your module theorem that our

00:22:34,330 --> 00:22:39,910
middleware and they will again get

00:22:37,600 --> 00:22:42,310
called certain events that happened

00:22:39,910 --> 00:22:46,480
inside Ellie there's a list of those

00:22:42,310 --> 00:22:48,820
events so most of them might not be of

00:22:46,480 --> 00:22:50,590
very interesting to you I mean the most

00:22:48,820 --> 00:22:53,890
interesting normally for me is request

00:22:50,590 --> 00:22:55,900
complete but also you can tell whether

00:22:53,890 --> 00:22:58,900
the client close sort of client timeout

00:22:55,900 --> 00:23:00,250
did time it on your connection honestly

00:22:58,900 --> 00:23:03,790
I don't really know how you would detect

00:23:00,250 --> 00:23:05,620
that in in rails that the client hangout

00:23:03,790 --> 00:23:08,200
and frosting is actually sometimes

00:23:05,620 --> 00:23:09,700
important especially and we have

00:23:08,200 --> 00:23:16,630
long-running connections that are

00:23:09,700 --> 00:23:19,809
dopinder here this is directly request

00:23:16,630 --> 00:23:22,899
complete event that it would get so the

00:23:19,809 --> 00:23:26,350
beauty of this is look at all the events

00:23:22,899 --> 00:23:30,580
that you get you can actually tell when

00:23:26,350 --> 00:23:34,840
the requests started when the headers

00:23:30,580 --> 00:23:37,480
and it invented body ended and the

00:23:34,840 --> 00:23:39,460
request ended so with all those you can

00:23:37,480 --> 00:23:41,019
actually detect more clients for

00:23:39,460 --> 00:23:44,019
instance there are a lot of clients that

00:23:41,019 --> 00:23:45,909
will start sending the header and then

00:23:44,019 --> 00:23:50,350
it will take forever until they start

00:23:45,909 --> 00:23:52,539
sending the body so and with that you

00:23:50,350 --> 00:23:55,269
can actually detect that so that allows

00:23:52,539 --> 00:23:57,010
for awesome monitoring solutions we

00:23:55,269 --> 00:23:59,740
normally use something like you really

00:23:57,010 --> 00:24:02,200
any relic in Ruby there isn't support in

00:23:59,740 --> 00:24:05,260
Erlang yeah and some of our guys

00:24:02,200 --> 00:24:08,110
actually working on that so you can

00:24:05,260 --> 00:24:10,210
build crazy good dashboards with you and

00:24:08,110 --> 00:24:11,710
just plug in a dashboard middleware that

00:24:10,210 --> 00:24:13,690
will collect data and send it off to a

00:24:11,710 --> 00:24:15,010
dashboard service and you convert

00:24:13,690 --> 00:24:17,340
because you have all that information

00:24:15,010 --> 00:24:19,929
about users without actually touching

00:24:17,340 --> 00:24:24,399
your core functionality of your web

00:24:19,929 --> 00:24:26,169
service here or when something goes

00:24:24,399 --> 00:24:29,980
wrong if you want to do exceptional

00:24:26,169 --> 00:24:31,510
tracking so if the request gets wrong if

00:24:29,980 --> 00:24:35,409
it get exit or if there's an error in

00:24:31,510 --> 00:24:38,529
channel okay let's move on to

00:24:35,409 --> 00:24:40,630
environments alright if you have this

00:24:38,529 --> 00:24:43,330
more or less serious application you

00:24:40,630 --> 00:24:44,950
will have a testing environment we will

00:24:43,330 --> 00:24:46,269
have a staging environment UCI

00:24:44,950 --> 00:24:49,659
environment and a production environment

00:24:46,269 --> 00:24:53,200
and they probably have a different

00:24:49,659 --> 00:24:54,519
configuration so I looked into all the

00:24:53,200 --> 00:24:56,679
solutions that I could find in the

00:24:54,519 --> 00:24:59,679
Erlang world and there are many of them

00:24:56,679 --> 00:25:02,500
there is some stuff with dynamic model

00:24:59,679 --> 00:25:04,299
module loading there is setting up a

00:25:02,500 --> 00:25:07,029
configuration server inside your

00:25:04,299 --> 00:25:10,029
application but it was there's almost a

00:25:07,029 --> 00:25:12,190
bit too complicated for me and I almost

00:25:10,029 --> 00:25:15,960
gave up until I found the most obvious

00:25:12,190 --> 00:25:18,070
solution possible you can pass in a

00:25:15,960 --> 00:25:21,940
config parameter in

00:25:18,070 --> 00:25:24,760
the Erlang command-line utility so me

00:25:21,940 --> 00:25:27,790
reading the main page of the tools

00:25:24,760 --> 00:25:32,200
you're using sometimes really helps it

00:25:27,790 --> 00:25:36,340
could it spares you a lot of time config

00:25:32,200 --> 00:25:40,090
file so this is an hour long property

00:25:36,340 --> 00:25:43,600
list where you can locate doesn't like a

00:25:40,090 --> 00:25:46,000
key value thing where it's in a tuple

00:25:43,600 --> 00:25:47,770
the first value is the key and the

00:25:46,000 --> 00:25:49,810
second value the second value is the

00:25:47,770 --> 00:25:52,060
actual value okay

00:25:49,810 --> 00:25:54,520
and here we defined for our aloha

00:25:52,060 --> 00:25:58,210
application will define the work report

00:25:54,520 --> 00:25:59,800
and later on we have other applications

00:25:58,210 --> 00:26:02,260
that we're using inside applications

00:25:59,800 --> 00:26:03,900
that we defined here and you walk into

00:26:02,260 --> 00:26:07,870
that right away

00:26:03,900 --> 00:26:10,990
logging you can learn a lot from your

00:26:07,870 --> 00:26:12,070
log files especially for operations and

00:26:10,990 --> 00:26:14,200
see what's going on

00:26:12,070 --> 00:26:17,020
and specifically turn on login for

00:26:14,200 --> 00:26:19,630
certain users see you slow queries and

00:26:17,020 --> 00:26:21,970
there's no database queries see see

00:26:19,630 --> 00:26:23,320
certain user events that happened I get

00:26:21,970 --> 00:26:26,380
a better idea what happened with that

00:26:23,320 --> 00:26:27,550
user at that time for instance and then

00:26:26,380 --> 00:26:30,970
your conference to take all that data

00:26:27,550 --> 00:26:32,590
and push it into a dashboard service or

00:26:30,970 --> 00:26:35,800
a graph and visualize what's happening

00:26:32,590 --> 00:26:38,010
so for operations this is a really

00:26:35,800 --> 00:26:41,140
excellent tool to have great login

00:26:38,010 --> 00:26:44,500
however the standard airline solution is

00:26:41,140 --> 00:26:46,390
not what I had in mind it's you have a

00:26:44,500 --> 00:26:49,540
logger class and you can have the

00:26:46,390 --> 00:26:54,160
regular log water log levels and you

00:26:49,540 --> 00:26:59,320
have also something called sessile which

00:26:54,160 --> 00:27:02,170
is a more complex error log your logging

00:26:59,320 --> 00:27:03,730
solution and a slash service that gives

00:27:02,170 --> 00:27:06,640
you a lot of information and you can do

00:27:03,730 --> 00:27:10,710
complex stuff however the problem is

00:27:06,640 --> 00:27:14,560
this it generates way too much content

00:27:10,710 --> 00:27:18,910
it's you don't even need to know most of

00:27:14,560 --> 00:27:20,630
that and I was looking more for having

00:27:18,910 --> 00:27:24,620
beautiful

00:27:20,630 --> 00:27:29,030
in Linux like you know from Apache from

00:27:24,620 --> 00:27:31,250
syslog or from services or from nginx

00:27:29,030 --> 00:27:34,010
you know those great in the one-liners

00:27:31,250 --> 00:27:36,470
where it's timestamp and then some log

00:27:34,010 --> 00:27:38,630
entries I can visually pass around into

00:27:36,470 --> 00:27:40,310
syslog and distributed over your system

00:27:38,630 --> 00:27:42,050
or whatever you want to do with it and

00:27:40,310 --> 00:27:44,450
they're a lot easier to parse with your

00:27:42,050 --> 00:27:47,630
standard Linux tools right so using grep

00:27:44,450 --> 00:27:49,310
on something like this gets really

00:27:47,630 --> 00:27:51,320
complicated because then you get one

00:27:49,310 --> 00:27:53,180
line but you don't know the context

00:27:51,320 --> 00:27:56,960
where anybody came from because the date

00:27:53,180 --> 00:28:01,220
is a line about so yeah how about more

00:27:56,960 --> 00:28:03,050
Linux tile version of it turns out

00:28:01,220 --> 00:28:03,500
there's another tool also written by

00:28:03,050 --> 00:28:05,630
Pasha

00:28:03,500 --> 00:28:07,970
as it happens so it looks like they have

00:28:05,630 --> 00:28:09,380
many of similar ideas that other people

00:28:07,970 --> 00:28:13,010
have as well that they want to have in

00:28:09,380 --> 00:28:15,710
their line and we looked at it the

00:28:13,010 --> 00:28:19,640
contact before so from starting from

00:28:15,710 --> 00:28:22,970
line seven to nine seventeen you can

00:28:19,640 --> 00:28:25,940
config everything out a flogger that you

00:28:22,970 --> 00:28:29,210
possibly ever need we have file backends

00:28:25,940 --> 00:28:30,650
you have search log backends and they

00:28:29,210 --> 00:28:32,750
add those brackets you can enable

00:28:30,650 --> 00:28:37,190
tracing for certain functions so when

00:28:32,750 --> 00:28:38,980
requests go through you can enable that

00:28:37,190 --> 00:28:42,470
and logger will do that for you as well

00:28:38,980 --> 00:28:44,420
so it's a very versatile solution and

00:28:42,470 --> 00:28:46,280
very flexible in terms of logging and it

00:28:44,420 --> 00:28:51,740
gives you this nice little one-liners

00:28:46,280 --> 00:28:55,070
that you can wrap just as easily and the

00:28:51,740 --> 00:28:58,550
way you use logger this is your

00:28:55,070 --> 00:29:00,800
application file that people are created

00:28:58,550 --> 00:29:02,660
for you when it generated it and so you

00:29:00,800 --> 00:29:03,920
have to start a blogger but not only

00:29:02,660 --> 00:29:05,840
have you start a blogger you have to

00:29:03,920 --> 00:29:09,680
start a to more applications here it's

00:29:05,840 --> 00:29:11,090
compiler and syntax tools then Locker

00:29:09,680 --> 00:29:13,880
doesn't tell you this and I think it's

00:29:11,090 --> 00:29:15,500
not possible that it can and this is a

00:29:13,880 --> 00:29:20,320
common problem I'm happy to our line is

00:29:15,500 --> 00:29:23,740
I never knew what dependencies in Erlang

00:29:20,320 --> 00:29:26,529
to a library that was using hat so this

00:29:23,740 --> 00:29:28,929
is like a ruby gem that has not

00:29:26,529 --> 00:29:31,480
specified its dependencies probably in a

00:29:28,929 --> 00:29:33,490
chimp file but actually you go on a hunt

00:29:31,480 --> 00:29:36,519
right you try to run it out this is

00:29:33,490 --> 00:29:38,289
missing install that oh this is missing

00:29:36,519 --> 00:29:43,179
install there and you get really annoyed

00:29:38,289 --> 00:29:44,370
by that so there's a fix then one of our

00:29:43,179 --> 00:29:46,840
guys wrote

00:29:44,370 --> 00:29:48,549
because whatever like does if you start

00:29:46,840 --> 00:29:51,159
an application one of its dependencies

00:29:48,549 --> 00:29:53,320
cannot be started it will actually tell

00:29:51,159 --> 00:29:57,750
you that it cannot be started and which

00:29:53,320 --> 00:29:57,750
one it was so you just start that

00:30:02,190 --> 00:30:08,930
is everybody good with the amount of

00:30:04,710 --> 00:30:08,930
Erlang code or is it going too fast I

00:30:09,530 --> 00:30:20,130
take the knowing as the s Oh unisex so

00:30:14,250 --> 00:30:24,420
yeah then you get the classic Aloha I'm

00:30:20,130 --> 00:30:27,120
gonna run em big does everybody know

00:30:24,420 --> 00:30:28,800
what the Freak set is I'm surfing it's

00:30:27,120 --> 00:30:30,540
it's a set of waves that actually does

00:30:28,800 --> 00:30:32,310
the only waist break at a certain point

00:30:30,540 --> 00:30:33,330
and this is where the line up is where

00:30:32,310 --> 00:30:35,730
you see all the server's paddling around

00:30:33,330 --> 00:30:39,720
and when a freak sight comes in its food

00:30:35,730 --> 00:30:41,930
around so in that norm is not a big

00:30:39,720 --> 00:30:44,910
problem unless you have really big waves

00:30:41,930 --> 00:30:46,680
for instant Mavericks there when you see

00:30:44,910 --> 00:30:48,840
a freaks that coming in you see people

00:30:46,680 --> 00:30:50,790
paddling for their lives to get just out

00:30:48,840 --> 00:30:53,940
of there otherwise they get buried under

00:30:50,790 --> 00:30:57,150
their way so freaks that is is a warning

00:30:53,940 --> 00:31:00,300
and if you don't consider the warning

00:30:57,150 --> 00:31:03,980
you eventually actually wipeout talking

00:31:00,300 --> 00:31:06,360
about unit testing important tool and

00:31:03,980 --> 00:31:10,260
want to user language unit testing as

00:31:06,360 --> 00:31:13,860
well the standards that everybody is

00:31:10,260 --> 00:31:15,410
using is called unit good enough I kind

00:31:13,860 --> 00:31:19,080
of like it and he used it initially

00:31:15,410 --> 00:31:21,420
until I noticed something you don't get

00:31:19,080 --> 00:31:25,040
stack traces in you for a long time you

00:31:21,420 --> 00:31:27,810
have stack traces in Erlang at all

00:31:25,040 --> 00:31:29,730
nothing under 14 and with 15 you

00:31:27,810 --> 00:31:33,600
actually have stack traces which is a

00:31:29,730 --> 00:31:35,340
big improvement you can get a unit to

00:31:33,600 --> 00:31:37,290
give you stack traces but you need to

00:31:35,340 --> 00:31:39,030
patch your Erlang

00:31:37,290 --> 00:31:41,850
somebody told me that the patch didn't

00:31:39,030 --> 00:31:43,650
make it into the release so which really

00:31:41,850 --> 00:31:46,920
was a no-go because you run a test and

00:31:43,650 --> 00:31:49,290
as an error message you get undeath and

00:31:46,920 --> 00:31:52,050
you have no idea where it happened what

00:31:49,290 --> 00:31:55,020
test it was you're just standing there

00:31:52,050 --> 00:31:56,850
looking it under so you start

00:31:55,020 --> 00:32:00,660
uncommenting code until you figured out

00:31:56,850 --> 00:32:04,670
what the problem is so we have a test

00:32:00,660 --> 00:32:07,220
for that which is essentially like any

00:32:04,670 --> 00:32:09,150
unit testing framework you can think of

00:32:07,220 --> 00:32:11,490
there's nothing special

00:32:09,150 --> 00:32:15,090
yeah that's a classic setup and teardown

00:32:11,490 --> 00:32:20,520
methods it has a certain message like a

00:32:15,090 --> 00:32:26,370
certain equal and those are not gross in

00:32:20,520 --> 00:32:28,470
the Erlang world and of course there's a

00:32:26,370 --> 00:32:30,740
lot more markers but you can look that

00:32:28,470 --> 00:32:33,120
up you don't need me to tell all this

00:32:30,740 --> 00:32:36,230
and then have a nice little test runner

00:32:33,120 --> 00:32:40,640
which is actually written in Ruby

00:32:36,230 --> 00:32:40,640
because it was built by goo because

00:32:46,270 --> 00:32:52,910
how about integration testing we're

00:32:48,830 --> 00:32:54,650
building MEP services here there are big

00:32:52,910 --> 00:32:57,020
integration testing fur goes for Erlang

00:32:54,650 --> 00:33:00,110
and it always took me way too long to

00:32:57,020 --> 00:33:03,800
get that to work set up the HTTP client

00:33:00,110 --> 00:33:06,050
to do stuff and so some of our guys also

00:33:03,800 --> 00:33:09,410
figured that was a problem and I came up

00:33:06,050 --> 00:33:18,680
with an extension to a unit not EU was

00:33:09,410 --> 00:33:24,290
it D test and here we go it's called a

00:33:18,680 --> 00:33:25,400
test HTTP same structure here it's

00:33:24,290 --> 00:33:27,170
important that you start up your

00:33:25,400 --> 00:33:28,520
application before you run requests

00:33:27,170 --> 00:33:30,320
against it because we don't start up the

00:33:28,520 --> 00:33:31,850
application it will not accept any HTTP

00:33:30,320 --> 00:33:36,310
requests so this is actually doing

00:33:31,850 --> 00:33:39,340
proper HTTP as you can see in line 20

00:33:36,310 --> 00:33:42,400
they will turn with the proper request

00:33:39,340 --> 00:33:45,020
and you can assert your status your body

00:33:42,400 --> 00:33:46,940
there's support built in for chasing

00:33:45,020 --> 00:33:48,830
because most of the api's we do are

00:33:46,940 --> 00:33:51,350
actually chasing so don't have to go

00:33:48,830 --> 00:33:54,370
manually all the time Jason parse

00:33:51,350 --> 00:33:57,470
I figure that out so it does it for you

00:33:54,370 --> 00:34:00,050
when you're running the same way one of

00:33:57,470 --> 00:34:02,620
my favorite features alderman Lowe it's

00:34:00,050 --> 00:34:05,750
a remember it's a compiled language

00:34:02,620 --> 00:34:08,810
classic use case is you write your code

00:34:05,750 --> 00:34:10,130
you save you compile you start the

00:34:08,810 --> 00:34:12,230
application then you change something

00:34:10,130 --> 00:34:15,410
you would stop the chip make your code

00:34:12,230 --> 00:34:16,970
compile stop the application is to kill

00:34:15,410 --> 00:34:19,340
the application and started again so

00:34:16,970 --> 00:34:20,900
this cycle always takes a few seconds

00:34:19,340 --> 00:34:22,610
and it's just getting you really slow

00:34:20,900 --> 00:34:25,190
especially if you're like messing around

00:34:22,610 --> 00:34:26,450
with it and not necessarily to test

00:34:25,190 --> 00:34:27,670
through development it's just messing

00:34:26,450 --> 00:34:31,280
around with it right

00:34:27,670 --> 00:34:35,360
and since Berlin allows you this hot

00:34:31,280 --> 00:34:38,000
code reloading you can do it and and you

00:34:35,360 --> 00:34:40,920
don't have to build yourself mochi web

00:34:38,000 --> 00:34:44,370
which is good but

00:34:40,920 --> 00:34:46,620
server written in Erlang insight in its

00:34:44,370 --> 00:34:50,310
source code you find a builder module

00:34:46,620 --> 00:34:53,610
that you can just install and tweak it

00:34:50,310 --> 00:34:54,360
to your likings and then you just start

00:34:53,610 --> 00:34:56,790
your reloader

00:34:54,360 --> 00:34:59,490
in your application startup and that's

00:34:56,790 --> 00:35:01,860
it what able do able monitor your beam

00:34:59,490 --> 00:35:06,630
files which article compiling the source

00:35:01,860 --> 00:35:10,790
files if then it will if they changed

00:35:06,630 --> 00:35:10,790
even reload the code for that module

00:35:11,120 --> 00:35:18,420
there is however one little exception

00:35:14,270 --> 00:35:20,820
which are the native extensions in a

00:35:18,420 --> 00:35:24,360
repeater ruby version of it that

00:35:20,820 --> 00:35:28,080
connects native interfaces with

00:35:24,360 --> 00:35:31,440
reloading is it only works the first

00:35:28,080 --> 00:35:32,780
time and the second time it just pulls

00:35:31,440 --> 00:35:35,490
up in your face

00:35:32,780 --> 00:35:39,000
to an extent it kills your whole

00:35:35,490 --> 00:35:42,750
Erland virtual machine when I try to

00:35:39,000 --> 00:35:44,880
reload chikki which is a chaser see by a

00:35:42,750 --> 00:35:47,370
library that we are using fast Jason

00:35:44,880 --> 00:35:49,950
Parsons I think they're working on it to

00:35:47,370 --> 00:35:54,240
make it work to make chippie work with

00:35:49,950 --> 00:35:57,870
hot code reloading but you might need to

00:35:54,240 --> 00:35:59,510
change your reloading code to not reload

00:35:57,870 --> 00:36:02,640
certain libraries

00:35:59,510 --> 00:36:05,130
auto compiled nothing for all your Ruby

00:36:02,640 --> 00:36:09,030
experts small gain no-brainer

00:36:05,130 --> 00:36:12,780
I'm using quartz because I think it's

00:36:09,030 --> 00:36:14,730
written by Swiss guys I don't have any

00:36:12,780 --> 00:36:16,940
references that just showing you God but

00:36:14,730 --> 00:36:21,480
you can use whatever this watcher this

00:36:16,940 --> 00:36:22,800
FS events essentially you check for all

00:36:21,480 --> 00:36:26,520
these source files and then you're gonna

00:36:22,800 --> 00:36:28,920
be bar compiled then your auto reload

00:36:26,520 --> 00:36:31,080
code is going to up is going up so this

00:36:28,920 --> 00:36:34,170
way you can actually just change code

00:36:31,080 --> 00:36:35,940
hit save and play around with it and

00:36:34,170 --> 00:36:37,680
your code is getting reload it and it's

00:36:35,940 --> 00:36:39,630
executed you don't have to go through

00:36:37,680 --> 00:36:42,860
the whole life cycle again manually so

00:36:39,630 --> 00:36:45,150
it becomes a lot like Sinatra or rails

00:36:42,860 --> 00:36:46,779
development in development mode but I

00:36:45,150 --> 00:36:49,509
don't have to restart the whole world

00:36:46,779 --> 00:36:51,999
to see it as one little change I'm

00:36:49,509 --> 00:36:55,659
you're almost done all we need to do is

00:36:51,999 --> 00:36:58,150
to point it now try Roku I just learned

00:36:55,659 --> 00:37:00,359
that last week - and you actually can do

00:36:58,150 --> 00:37:00,359
that

00:37:01,839 --> 00:37:08,279
I'm just waiting for a local employee to

00:37:05,619 --> 00:37:08,279
take a picture

00:37:12,160 --> 00:37:20,710
so who here uses Heroku for whatever you

00:37:17,530 --> 00:37:23,350
know side-project fun projects awesome

00:37:20,710 --> 00:37:25,450
no that's lowest of you so we can go

00:37:23,350 --> 00:37:29,650
through that quickly so you create your

00:37:25,450 --> 00:37:31,000
oh crap that standard then you have

00:37:29,650 --> 00:37:33,990
wicked cheddar stack you have those

00:37:31,000 --> 00:37:36,670
build packs so you can run different

00:37:33,990 --> 00:37:40,450
architectures different languages inside

00:37:36,670 --> 00:37:42,250
Heroku so you're not no longer

00:37:40,450 --> 00:37:44,350
restricted just to Ruby or whatever hero

00:37:42,250 --> 00:37:48,070
who gets you you can build your own bill

00:37:44,350 --> 00:37:51,240
perks to run whatever local building one

00:37:48,070 --> 00:37:56,380
isn't brittle ahead of your problems

00:37:51,240 --> 00:37:59,140
luckily somebody at Heroku builds this

00:37:56,380 --> 00:38:01,300
one is only a long version or fourteen I

00:37:59,140 --> 00:38:04,480
can get the word get it to work with

00:38:01,300 --> 00:38:07,060
around 15 I'll have to look into that

00:38:04,480 --> 00:38:11,590
but yeah you just add the build pack URL

00:38:07,060 --> 00:38:13,440
and you're set it runs early the proc

00:38:11,590 --> 00:38:16,990
file that you need to start and stop

00:38:13,440 --> 00:38:19,090
your Hello Co application is also

00:38:16,990 --> 00:38:21,640
straightforward in Erlang worlds you

00:38:19,090 --> 00:38:24,970
have your arrow command you have to give

00:38:21,640 --> 00:38:26,620
it a path to your dependencies so or I

00:38:24,970 --> 00:38:30,250
can find all your modules and all the

00:38:26,620 --> 00:38:34,120
codes then have your no shell no inputs

00:38:30,250 --> 00:38:36,100
to make sure it's not getting in it's

00:38:34,120 --> 00:38:37,990
not doing something interactive and

00:38:36,100 --> 00:38:39,310
you're passing in your configuration and

00:38:37,990 --> 00:38:44,230
then this is what I really like about

00:38:39,310 --> 00:38:47,320
Erlang you can actually pass in here to

00:38:44,230 --> 00:38:50,380
Italy to start up the application

00:38:47,320 --> 00:38:55,690
Aloha app so we will do is fully with go

00:38:50,380 --> 00:39:01,450
application start Aloha and and start it

00:38:55,690 --> 00:39:03,910
up for you and that's almost it I you

00:39:01,450 --> 00:39:06,310
don't really know in which port Heroku

00:39:03,910 --> 00:39:09,550
is talking to you or I couldn't figure

00:39:06,310 --> 00:39:11,890
that out so what actually found is that

00:39:09,550 --> 00:39:15,670
you you have an environment variable or

00:39:11,890 --> 00:39:17,980
port where did that says what you have

00:39:15,670 --> 00:39:21,290
to listen on and

00:39:17,980 --> 00:39:23,560
so the Erlang version for it is actually

00:39:21,290 --> 00:39:26,120
you know it's here the nitty-gritty oh

00:39:23,560 --> 00:39:29,440
here this is probably how you read out

00:39:26,120 --> 00:39:31,820
your configuration on line seven

00:39:29,440 --> 00:39:34,400
whatever we had in our application

00:39:31,820 --> 00:39:36,350
configuration this is under the key a

00:39:34,400 --> 00:39:40,760
little huh and then you have our work

00:39:36,350 --> 00:39:45,290
reports and here we check if there's an

00:39:40,760 --> 00:39:48,230
environment variable called port he used

00:39:45,290 --> 00:39:51,500
that if not and convert it into an

00:39:48,230 --> 00:39:54,710
integer if not which is already fault so

00:39:51,500 --> 00:40:01,700
development version works Foreman then

00:39:54,710 --> 00:40:07,430
they use format start that's it the

00:40:01,700 --> 00:40:09,980
actual deploy um it's beautiful how

00:40:07,430 --> 00:40:12,380
simple that is real cool you all know

00:40:09,980 --> 00:40:16,880
that it's just get push there Oakland

00:40:12,380 --> 00:40:20,000
master and there you go and then you get

00:40:16,880 --> 00:40:21,020
some of them a lot of output it compiles

00:40:20,000 --> 00:40:25,160
her thing and it fetches all the

00:40:21,020 --> 00:40:27,980
dependencies and voila

00:40:25,160 --> 00:40:32,480
you can curl this is actually lie and

00:40:27,980 --> 00:40:35,960
built that Aloha Earl Heroku app calm -

00:40:32,480 --> 00:40:38,360
Aloha and it will get back in response I

00:40:35,960 --> 00:40:41,060
think something that took from Wikipedia

00:40:38,360 --> 00:40:43,060
it's something about the house so you'll

00:40:41,060 --> 00:40:45,220
figure it out

00:40:43,060 --> 00:40:47,710
and this is the app and this is also

00:40:45,220 --> 00:40:49,450
where you will find all the codes that

00:40:47,710 --> 00:40:50,830
are talked about we will find a

00:40:49,450 --> 00:40:54,490
ready-made application that you can

00:40:50,830 --> 00:40:57,310
start using and start building your web

00:40:54,490 --> 00:40:59,050
services and I'm also planning to turn

00:40:57,310 --> 00:41:01,420
that morning flick generator so it's

00:40:59,050 --> 00:41:03,610
more like unveils command so you say I

00:41:01,420 --> 00:41:05,950
need a new web service with le and bold

00:41:03,610 --> 00:41:08,460
it sets up everything for you because

00:41:05,950 --> 00:41:12,580
right now I had to do editing manually

00:41:08,460 --> 00:41:14,230
so yes I go out and write your first web

00:41:12,580 --> 00:41:17,800
service in Erlang learn something about

00:41:14,230 --> 00:41:19,420
a new language learn new paradigms get

00:41:17,800 --> 00:41:22,120
new ideas how to improve your Ruby

00:41:19,420 --> 00:41:24,550
skills how your programming skills learn

00:41:22,120 --> 00:41:26,410
new concurrency patterns what about the

00:41:24,550 --> 00:41:29,460
actor model there's so much great stuff

00:41:26,410 --> 00:41:31,870
inside airline that haven't covered here

00:41:29,460 --> 00:41:33,130
because airline was built for something

00:41:31,870 --> 00:41:35,230
completely different what we normally do

00:41:33,130 --> 00:41:36,610
is build for telecommunication stuff

00:41:35,230 --> 00:41:38,770
that's always up stuff that's

00:41:36,610 --> 00:41:41,770
distributed stuff that's always fault

00:41:38,770 --> 00:41:45,670
tolerant so they're putting a lot of

00:41:41,770 --> 00:41:47,850
thought and work into that that's all I

00:41:45,670 --> 00:41:47,850
got

00:41:47,970 --> 00:41:54,419
[Applause]

00:41:54,640 --> 00:42:02,390
[Music]

00:42:02,050 --> 00:42:05,310
you

00:42:02,390 --> 00:42:05,310

YouTube URL: https://www.youtube.com/watch?v=DlgFpDWj_eE


