Title: Aloha Ruby Conf 2012 Refactoring from Good to Great by Ben Orenstein
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Most developers know enough about refactoring to write code that's pretty good. They create short methods, and classes with one responsibility. They're also familiar with a good handful of refactorings, and the code smells that motivate them.

This talk is about the next level of knowledge: the things advanced developers know that let them turn good code into great. Code that's easy to read and a breeze to change.

These topics will be covered solely by LIVE CODING; no slides. We'll boldly refactor right on stage, and pray the tests stay green. You might even learn some vim tricks as well as an expert user shows you his workflow.

Topics include:

The Open-Closed Principle The types of coupling, and their dangers Why composition is so damn great A powerful refactoring that Kent Beck refers to as "deep deep magic" How to destroy conditionals with a NullObject The beauty of the Decorator pattern Testing smells, including Mystery Guest and stubbing the system under test The stuff from the last halves of Refactoring and Clean Code that you never quite got to.

Help us caption & translate this video!

http://amara.org/v/FGgU/
Captions: 
	00:00:14,719 --> 00:00:22,050
good afternoon Aloha

00:00:17,160 --> 00:00:25,439
Ruby how's it going yes everybody doing

00:00:22,050 --> 00:00:28,349
well good lunch raise your hand if

00:00:25,439 --> 00:00:30,300
you're in Hawaii right now not bad right

00:00:28,349 --> 00:00:32,220
I've been to worst conference locations

00:00:30,300 --> 00:00:35,399
I got to tell you so it's interesting I

00:00:32,220 --> 00:00:39,420
realized earlier this is the first time

00:00:35,399 --> 00:00:41,250
I've given a talk twice in a week so on

00:00:39,420 --> 00:00:43,320
Thursday I gave this actually this exact

00:00:41,250 --> 00:00:45,870
sample very similar version this talk at

00:00:43,320 --> 00:00:48,450
magic Ruby which is in Disneyworld

00:00:45,870 --> 00:00:50,640
so I fluid roughly from Orlando to here

00:00:48,450 --> 00:00:52,590
so my life is rough

00:00:50,640 --> 00:00:55,290
you can send sympathy cards to my

00:00:52,590 --> 00:00:56,940
address so just a little bit of

00:00:55,290 --> 00:00:58,140
administration before we get started my

00:00:56,940 --> 00:01:00,270
name is Ben Ornstein I work at

00:00:58,140 --> 00:01:01,829
thoughtbot in Boston and this talk is

00:01:00,270 --> 00:01:03,239
refactoring from good to great and this

00:01:01,829 --> 00:01:05,759
is basically about things I've learned

00:01:03,239 --> 00:01:08,280
in the last year or so that I think

00:01:05,759 --> 00:01:09,240
improve the quality of my code so I'm

00:01:08,280 --> 00:01:11,009
just going to share that with you guys

00:01:09,240 --> 00:01:11,670
now I don't want you to think of this as

00:01:11,009 --> 00:01:13,740
a lecture

00:01:11,670 --> 00:01:15,180
this isn't me standing here and telling

00:01:13,740 --> 00:01:18,240
you all these things that are absolute

00:01:15,180 --> 00:01:20,999
truth think of this as pairing I'm now

00:01:18,240 --> 00:01:23,819
pair programming with all of you so as a

00:01:20,999 --> 00:01:25,439
result of that if you have questions say

00:01:23,819 --> 00:01:26,520
something if you disagree you say

00:01:25,439 --> 00:01:28,170
something you get suggestions say

00:01:26,520 --> 00:01:30,090
something I love that back and forth

00:01:28,170 --> 00:01:30,719
during the talks don't be shy about

00:01:30,090 --> 00:01:33,749
interrupting

00:01:30,719 --> 00:01:36,770
I love diving into stuff so so go for

00:01:33,749 --> 00:01:38,789
that now let's dive right into this I

00:01:36,770 --> 00:01:41,689
want to show you my first example take a

00:01:38,789 --> 00:01:41,689
second and read this code

00:01:51,430 --> 00:01:56,710
now this is based on some code I wrote

00:01:54,130 --> 00:01:58,840
recently it's a slim polite version this

00:01:56,710 --> 00:02:00,820
is basically a very simple report that

00:01:58,840 --> 00:02:02,950
takes a collection of orders a start

00:02:00,820 --> 00:02:08,979
date and end date and return the total

00:02:02,950 --> 00:02:10,509
sales of those orders order has an

00:02:08,979 --> 00:02:14,350
attribute called placed at that we used

00:02:10,509 --> 00:02:18,100
to check the date range now about a year

00:02:14,350 --> 00:02:20,500
ago I would have committed this pushed

00:02:18,100 --> 00:02:22,780
it up and been done with it now when I

00:02:20,500 --> 00:02:26,050
look at this I look at it I think it's

00:02:22,780 --> 00:02:28,870
about B ish it's about a B B - it's

00:02:26,050 --> 00:02:30,430
decent if I if I was pretty confident

00:02:28,870 --> 00:02:32,080
that I would never come back to this

00:02:30,430 --> 00:02:34,090
code and change it or extend it I'd

00:02:32,080 --> 00:02:35,560
probably just say whatever good enough

00:02:34,090 --> 00:02:38,560
push it up and let's move on to the next

00:02:35,560 --> 00:02:39,580
thing but these days I actually there's

00:02:38,560 --> 00:02:41,709
some stuff I would do to it to improve

00:02:39,580 --> 00:02:43,450
it so the first thing I'd like to do

00:02:41,709 --> 00:02:45,340
notice we've got this temp variable

00:02:43,450 --> 00:02:46,630
right here we're figuring out the orders

00:02:45,340 --> 00:02:48,160
within range we're sticking him in a

00:02:46,630 --> 00:02:51,100
temp and then we're doing something with

00:02:48,160 --> 00:02:52,480
it I'd actually do a Strack this into

00:02:51,100 --> 00:02:53,950
its own method I'm gonna pull this into

00:02:52,480 --> 00:02:58,209
a private method I've recorded a macro

00:02:53,950 --> 00:03:01,090
that does this for me don't freak out so

00:02:58,209 --> 00:03:03,459
here's the before temp is in that method

00:03:01,090 --> 00:03:05,110
here's the after I made a private method

00:03:03,459 --> 00:03:07,870
with the same name and I'm just

00:03:05,110 --> 00:03:09,370
referencing it from up here so this is

00:03:07,870 --> 00:03:11,110
something I actually do a lot these days

00:03:09,370 --> 00:03:12,730
pull out these ten this is this is a

00:03:11,110 --> 00:03:15,040
factoring name for this called extract

00:03:12,730 --> 00:03:17,140
temp to query and this is something I do

00:03:15,040 --> 00:03:18,910
a lot now why do I do this why is this

00:03:17,140 --> 00:03:20,860
worth it well the first thing to notice

00:03:18,910 --> 00:03:23,070
is we've gone from one method with two

00:03:20,860 --> 00:03:24,760
lines to two methods with one line each

00:03:23,070 --> 00:03:27,880
now I'm not going to tell you that

00:03:24,760 --> 00:03:30,940
that's always an improvement but it

00:03:27,880 --> 00:03:33,130
usually is I'm starting to think these

00:03:30,940 --> 00:03:35,680
days that methods longer than a line or

00:03:33,130 --> 00:03:37,209
a code smell and I should define what

00:03:35,680 --> 00:03:38,590
code smell is just in case a code smell

00:03:37,209 --> 00:03:40,330
is something that indicates there may be

00:03:38,590 --> 00:03:43,120
a problem not that there is a problem

00:03:40,330 --> 00:03:44,980
that there may be a problem these days I

00:03:43,120 --> 00:03:46,510
tried really hard to get down to methods

00:03:44,980 --> 00:03:48,400
that are one line and it usually results

00:03:46,510 --> 00:03:50,620
in really good code because my methods

00:03:48,400 --> 00:03:53,170
are focused so that's one win the next

00:03:50,620 --> 00:03:54,370
is that we can reuse this so I think

00:03:53,170 --> 00:03:56,320
it's reasonably likely given that we

00:03:54,370 --> 00:03:57,670
have total sales or the date range the

00:03:56,320 --> 00:03:59,019
next thing that the stakeholder asked

00:03:57,670 --> 00:04:01,389
for is something like average sales

00:03:59,019 --> 00:04:03,830
within date range now when the code

00:04:01,389 --> 00:04:05,210
looks like this you have the logic

00:04:03,830 --> 00:04:08,240
for selecting those orders within range

00:04:05,210 --> 00:04:09,320
locked up in one method it's more likely

00:04:08,240 --> 00:04:12,290
I'm going to duplicate that later

00:04:09,320 --> 00:04:13,910
whereas if I have like this I think it's

00:04:12,290 --> 00:04:17,570
more likely to for me to reuse it so I

00:04:13,910 --> 00:04:19,580
think that's another win finally the

00:04:17,570 --> 00:04:21,410
nice thing about this is when the code

00:04:19,580 --> 00:04:22,700
looks like this for whatever reason

00:04:21,410 --> 00:04:25,820
because we're programmers because we

00:04:22,700 --> 00:04:28,220
read code when we see code like this we

00:04:25,820 --> 00:04:29,810
read it so the first thing your eye does

00:04:28,220 --> 00:04:31,460
when you see okay orin-san range equals

00:04:29,810 --> 00:04:32,900
okay let me figure out what this is

00:04:31,460 --> 00:04:35,360
let me figure out what this is doing

00:04:32,900 --> 00:04:35,930
when it looks like this when it's its

00:04:35,360 --> 00:04:38,000
own method

00:04:35,930 --> 00:04:40,010
my eye is more likely to see or does it

00:04:38,000 --> 00:04:40,970
in range okay this is private method I'm

00:04:40,010 --> 00:04:41,740
just gonna assume that selects all the

00:04:40,970 --> 00:04:45,560
orders that are within the date range

00:04:41,740 --> 00:04:48,110
what's it do next I'm more likely to

00:04:45,560 --> 00:04:49,610
ignore those details and in fact by

00:04:48,110 --> 00:04:51,920
extracting this method and moving it

00:04:49,610 --> 00:04:54,830
into a private method I've given you a

00:04:51,920 --> 00:04:56,870
hint and the hint is this code is not

00:04:54,830 --> 00:04:58,250
important this is an implementation

00:04:56,870 --> 00:05:00,710
detail that you don't really need to

00:04:58,250 --> 00:05:01,910
care about if you care about exactly

00:05:00,710 --> 00:05:03,620
what's going on in that method you can

00:05:01,910 --> 00:05:05,510
dive into it but it's not super

00:05:03,620 --> 00:05:08,360
important to what this report is about

00:05:05,510 --> 00:05:10,040
so I think the winds are sort of small

00:05:08,360 --> 00:05:13,310
but in the aggregate they're theirs

00:05:10,040 --> 00:05:14,630
they're worth doing so let's keep moving

00:05:13,310 --> 00:05:15,950
though I think we can K make this better

00:05:14,630 --> 00:05:19,550
let's look at this method we've created

00:05:15,950 --> 00:05:22,280
now oars within range and now within

00:05:19,550 --> 00:05:24,830
this method we're asking order about

00:05:22,280 --> 00:05:26,180
things about itself we're saying hey you

00:05:24,830 --> 00:05:27,830
place that after the start date and

00:05:26,180 --> 00:05:30,020
before the end date and then we're using

00:05:27,830 --> 00:05:31,640
that information to make a decision has

00:05:30,020 --> 00:05:34,850
anybody heard of a concept called tell

00:05:31,640 --> 00:05:37,400
don't ask okay cool so this is it this

00:05:34,850 --> 00:05:38,330
is an idea it's not a law but it's

00:05:37,400 --> 00:05:40,190
something that can sometimes lead to

00:05:38,330 --> 00:05:42,710
better code and what tell don't ask is

00:05:40,190 --> 00:05:45,410
is it says it's generally better to send

00:05:42,710 --> 00:05:48,730
a mess that send an object a message and

00:05:45,410 --> 00:05:51,410
have it perform work rather than ask

00:05:48,730 --> 00:05:55,190
that object about its internal state and

00:05:51,410 --> 00:05:57,140
decide what to do on its behalf not a

00:05:55,190 --> 00:05:59,240
law but it's a maximum it tends to lead

00:05:57,140 --> 00:06:02,030
to better code this code actually

00:05:59,240 --> 00:06:03,560
violates tell don't ask you can see I'm

00:06:02,030 --> 00:06:05,810
trying to select some orders and to do

00:06:03,560 --> 00:06:08,000
that I asked order about things asked

00:06:05,810 --> 00:06:11,360
order things about itself and then make

00:06:08,000 --> 00:06:12,710
a decision on its behalf so I'd rather

00:06:11,360 --> 00:06:13,930
actually change this code to look a

00:06:12,710 --> 00:06:21,880
little bit differently

00:06:13,930 --> 00:06:27,250
so what if instead you did something

00:06:21,880 --> 00:06:27,940
like this so now this sort of looks like

00:06:27,250 --> 00:06:29,889
an ask

00:06:27,940 --> 00:06:31,870
but the logic has moved I'm actually

00:06:29,889 --> 00:06:34,210
telling order something I'm saying tell

00:06:31,870 --> 00:06:37,210
me if you're placed between these two

00:06:34,210 --> 00:06:38,949
dates as opposed to pay order what's

00:06:37,210 --> 00:06:40,750
your internal status what are the what

00:06:38,949 --> 00:06:41,979
kind of attributes do you have and then

00:06:40,750 --> 00:06:43,870
I'll make a decision based on that so

00:06:41,979 --> 00:06:46,210
this is actually closer to following

00:06:43,870 --> 00:06:49,060
tell don't ask so I have specs for this

00:06:46,210 --> 00:06:50,680
which I'm going to run right now and

00:06:49,060 --> 00:06:52,449
that blows up because I use local

00:06:50,680 --> 00:06:58,900
variables when I meant instance

00:06:52,449 --> 00:07:00,010
variables let's do that again okay

00:06:58,900 --> 00:07:02,380
there's the order there's the error we

00:07:00,010 --> 00:07:03,850
want undefined method placed at we're

00:07:02,380 --> 00:07:05,590
calling a method on order I'm

00:07:03,850 --> 00:07:07,990
effectively doing TDD by writing the

00:07:05,590 --> 00:07:09,099
code I wished what wish were there so

00:07:07,990 --> 00:07:12,699
let's actually add that method to order

00:07:09,099 --> 00:07:14,949
now and we actually want not placed at

00:07:12,699 --> 00:07:16,860
we want place between that's a better

00:07:14,949 --> 00:07:19,690
name all right so let's define that

00:07:16,860 --> 00:07:24,460
place between takes a start date and an

00:07:19,690 --> 00:07:28,630
end date and then we're going to say is

00:07:24,460 --> 00:07:36,820
my start is start date after is it

00:07:28,630 --> 00:07:42,270
before placed at and is end date look

00:07:36,820 --> 00:07:45,400
got it backwards so I let's do this over

00:07:42,270 --> 00:07:50,909
placed at this will be easier to read is

00:07:45,400 --> 00:07:50,909
place that after start date and is it

00:07:51,120 --> 00:07:56,500
before end date right so there's our

00:07:54,970 --> 00:08:00,180
place between method let's run the test

00:07:56,500 --> 00:08:00,180
again we're back to green

00:08:01,590 --> 00:08:04,410
so the question was what about a range

00:08:02,820 --> 00:08:06,960
include and that's a great idea and I

00:08:04,410 --> 00:08:08,760
get there yep we're doing little steps

00:08:06,960 --> 00:08:10,500
but this guy is totally right we will

00:08:08,760 --> 00:08:11,670
end up there eventually but not quite

00:08:10,500 --> 00:08:14,340
what you said something a little bit

00:08:11,670 --> 00:08:16,590
slightly better look good question so

00:08:14,340 --> 00:08:18,480
okay so is this an improvement yes I

00:08:16,590 --> 00:08:21,240
think it is we've moved this logic over

00:08:18,480 --> 00:08:23,820
to order we've stopped pulling out

00:08:21,240 --> 00:08:25,380
interior pieces of order and fiddling

00:08:23,820 --> 00:08:27,750
with them understand just sending

00:08:25,380 --> 00:08:28,230
messages this is a good old principle to

00:08:27,750 --> 00:08:30,420
follow

00:08:28,230 --> 00:08:32,850
don't let the internal details of

00:08:30,420 --> 00:08:35,070
something like order leak out into code

00:08:32,850 --> 00:08:37,020
surrounding it that's the that's the

00:08:35,070 --> 00:08:39,840
core idea behind tell don't ask so I

00:08:37,020 --> 00:08:41,340
think we have a nice win here again I'm

00:08:39,840 --> 00:08:44,340
happier with where this logic is living

00:08:41,340 --> 00:08:47,130
but now we've sort of I see now a new

00:08:44,340 --> 00:08:50,700
problem a problem that's made evident

00:08:47,130 --> 00:08:53,670
now that we have a couple places where

00:08:50,700 --> 00:08:54,810
I'm passing start date and end date so

00:08:53,670 --> 00:08:57,180
notice I pass start date and end date

00:08:54,810 --> 00:08:59,970
into the initialize of this report and

00:08:57,180 --> 00:09:02,940
then I'm doing it again down here and I

00:08:59,970 --> 00:09:06,330
have start date end date here this is

00:09:02,940 --> 00:09:07,800
another smell when you have a pair of

00:09:06,330 --> 00:09:09,600
arguments at least two that you're

00:09:07,800 --> 00:09:11,270
passing together all the time there's a

00:09:09,600 --> 00:09:15,240
name for that that's called a data clump

00:09:11,270 --> 00:09:17,520
and now a data clump is a great hint

00:09:15,240 --> 00:09:20,970
that you should have tracked an object

00:09:17,520 --> 00:09:22,110
instead to hold those values a good way

00:09:20,970 --> 00:09:23,820
to test if you have a data clump by the

00:09:22,110 --> 00:09:25,710
way say oh these two pieces data have

00:09:23,820 --> 00:09:27,710
started an end date if I took one away

00:09:25,710 --> 00:09:30,300
with the remaining one makes sense

00:09:27,710 --> 00:09:31,770
not really right what would it mean to

00:09:30,300 --> 00:09:33,720
pass it just create an orders report

00:09:31,770 --> 00:09:35,100
with just an end date does really makes

00:09:33,720 --> 00:09:36,600
sense so if these things are always

00:09:35,100 --> 00:09:39,270
going to live together there's an

00:09:36,600 --> 00:09:40,830
implicit reliance on each other right it

00:09:39,270 --> 00:09:42,780
is implicit that I need a start date and

00:09:40,830 --> 00:09:44,670
an end date whereas if I made this thing

00:09:42,780 --> 00:09:47,190
into one object like a date range

00:09:44,670 --> 00:09:49,230
it becomes explicit that I need both of

00:09:47,190 --> 00:09:50,040
those that's another great Maxim to

00:09:49,230 --> 00:09:52,350
think about when you're writing your

00:09:50,040 --> 00:09:54,360
code imagine you have to show explain

00:09:52,350 --> 00:09:56,010
your code to somebody else any line they

00:09:54,360 --> 00:09:57,000
have to go okay well we're always going

00:09:56,010 --> 00:09:58,380
to start did an end date

00:09:57,000 --> 00:10:00,390
anything that's implicit in the code

00:09:58,380 --> 00:10:02,460
that you can take out and somehow make

00:10:00,390 --> 00:10:04,430
explicit and more obvious that's

00:10:02,460 --> 00:10:07,440
generally going to be a really big win

00:10:04,430 --> 00:10:11,370
so let's do this and we'll start in the

00:10:07,440 --> 00:10:13,140
spec here's my spec it's really simple

00:10:11,370 --> 00:10:14,260
I have an order within range and then

00:10:13,140 --> 00:10:15,940
out of range

00:10:14,260 --> 00:10:17,860
and then it's then this date range and

00:10:15,940 --> 00:10:19,810
then I make sure that the total sales

00:10:17,860 --> 00:10:22,630
number is correct so let's pull out a

00:10:19,810 --> 00:10:30,250
date range right now and again I'm going

00:10:22,630 --> 00:10:36,360
to write the code I wish I had come on

00:10:30,250 --> 00:10:37,750
baby oh my gosh I'm getting too hard

00:10:36,360 --> 00:10:42,120
there we go

00:10:37,750 --> 00:10:45,610
and then here I'll pass in the range

00:10:42,120 --> 00:10:47,710
cool so far we're going to run this it

00:10:45,610 --> 00:10:49,750
blows up uninitialized constant date

00:10:47,710 --> 00:10:51,460
range as expected because I just

00:10:49,750 --> 00:10:57,820
referenced a constant that's not real

00:10:51,460 --> 00:10:59,470
let's go make that error go away okay

00:10:57,820 --> 00:11:01,660
now there's gonna be a handful of errors

00:10:59,470 --> 00:11:04,630
as I run this right because suddenly raw

00:11:01,660 --> 00:11:06,070
number of arguments this actually I'm

00:11:04,630 --> 00:11:08,110
calling date range new and passing an

00:11:06,070 --> 00:11:09,970
arguments but it doesn't expect them so

00:11:08,110 --> 00:11:14,590
let's just make a quick struct to hold

00:11:09,970 --> 00:11:16,300
the start date in the end date and now I

00:11:14,590 --> 00:11:18,190
have roughly the error I want which is

00:11:16,300 --> 00:11:20,710
wrong number of arguments in two orders

00:11:18,190 --> 00:11:22,950
report I'm passing two arguments right

00:11:20,710 --> 00:11:25,300
here it used to expecting three up here

00:11:22,950 --> 00:11:26,980
so now I need to thread this new date

00:11:25,300 --> 00:11:29,230
range through I'm gonna do this in sort

00:11:26,980 --> 00:11:33,910
of a compressed series of steps so again

00:11:29,230 --> 00:11:37,780
don't freak out let's pass in the date

00:11:33,910 --> 00:11:40,860
range now there's no such thing as start

00:11:37,780 --> 00:11:44,110
date end date it's just date range and

00:11:40,860 --> 00:11:47,770
same deal here in that method we wrote

00:11:44,110 --> 00:11:52,570
an order it's just a date range and now

00:11:47,770 --> 00:11:55,390
we need to ask the date range about it

00:11:52,570 --> 00:12:03,370
start in an end date see if we're green

00:11:55,390 --> 00:12:04,840
again boom okay so is this a win yes

00:12:03,370 --> 00:12:07,990
it's a win I think it is I think this is

00:12:04,840 --> 00:12:09,700
worth doing now Bob Martin has said he

00:12:07,990 --> 00:12:10,960
thinks that most intermediate

00:12:09,700 --> 00:12:15,550
object-oriented program

00:12:10,960 --> 00:12:17,950
are too reluctant to extract classes you

00:12:15,550 --> 00:12:20,170
should be fairly aggressive about

00:12:17,950 --> 00:12:21,550
willing being willing to extract small

00:12:20,170 --> 00:12:25,170
classes like this look at date range

00:12:21,550 --> 00:12:27,790
it's super simple right it's very basic

00:12:25,170 --> 00:12:28,240
but again it's made something that used

00:12:27,790 --> 00:12:31,380
to be in

00:12:28,240 --> 00:12:36,640
plus it in our code it's not better

00:12:31,380 --> 00:12:38,350
better or worse all right it's made

00:12:36,640 --> 00:12:41,500
something that used to be implicit

00:12:38,350 --> 00:12:45,399
explicit now now date range you know is

00:12:41,500 --> 00:12:46,330
a pair of values this class doesn't have

00:12:45,399 --> 00:12:48,070
any behavior on it

00:12:46,330 --> 00:12:50,649
but I think this is still worth doing

00:12:48,070 --> 00:12:52,180
I've created a name for something I've

00:12:50,649 --> 00:12:54,250
pulled out an explicit name that's

00:12:52,180 --> 00:12:56,589
almost always an improvement but there's

00:12:54,250 --> 00:12:59,110
another one here which is we've reduced

00:12:56,589 --> 00:13:00,640
coupling now what's coupling coupling is

00:12:59,110 --> 00:13:03,910
the degree to which two components in a

00:13:00,640 --> 00:13:06,550
system rely on each other so if

00:13:03,910 --> 00:13:09,430
component a and component B have zero

00:13:06,550 --> 00:13:11,020
coupling you can change a as much as you

00:13:09,430 --> 00:13:15,100
want and in any way you want and you'll

00:13:11,020 --> 00:13:17,560
never break B vice versa right so that's

00:13:15,100 --> 00:13:19,779
with no coupling let's say that a and B

00:13:17,560 --> 00:13:22,060
are extremely coupled that means it's

00:13:19,779 --> 00:13:26,260
really hard to make changes to either

00:13:22,060 --> 00:13:28,330
one without breaking the other now as

00:13:26,260 --> 00:13:31,209
you might imagine low coupling is good

00:13:28,330 --> 00:13:33,279
high coupling is bad because couple low

00:13:31,209 --> 00:13:35,470
coupling makes change easier and that's

00:13:33,279 --> 00:13:36,100
what's hard about software is responding

00:13:35,470 --> 00:13:38,260
to change

00:13:36,100 --> 00:13:41,500
I saw a keynote by Dave Thomas and he

00:13:38,260 --> 00:13:43,180
said the only thing worrying about worth

00:13:41,500 --> 00:13:46,510
worrying about when you look at code is

00:13:43,180 --> 00:13:47,680
is it easy to change so low coupling

00:13:46,510 --> 00:13:51,990
makes things easier to change and let's

00:13:47,680 --> 00:13:51,990
look at a quick example of some coupling

00:13:52,380 --> 00:13:59,170
so there's different types of coupling

00:13:55,170 --> 00:14:01,450
this is called parameter coupling so

00:13:59,170 --> 00:14:03,940
notice that notify user of failure

00:14:01,450 --> 00:14:06,910
passes in an object called failure into

00:14:03,940 --> 00:14:10,149
another method within that method within

00:14:06,910 --> 00:14:15,370
print to console we call two-sentence on

00:14:10,149 --> 00:14:17,020
that parameter now if I passed nil into

00:14:15,370 --> 00:14:19,029
print a console this would blow up right

00:14:17,020 --> 00:14:21,970
no method error two-sentence is not

00:14:19,029 --> 00:14:24,730
defined if I passed if i pass something

00:14:21,970 --> 00:14:26,050
else let's say it an integer into

00:14:24,730 --> 00:14:27,910
printer console this will blow up right

00:14:26,050 --> 00:14:31,990
because two-sentence is not defined on

00:14:27,910 --> 00:14:33,310
integers at least I hope it's not so

00:14:31,990 --> 00:14:36,310
there's actually coupling between these

00:14:33,310 --> 00:14:39,310
two methods notify user of failure has

00:14:36,310 --> 00:14:40,630
to know what print a console is going to

00:14:39,310 --> 00:14:44,050
call on it

00:14:40,630 --> 00:14:46,930
ammeter if I change print a console I

00:14:44,050 --> 00:14:49,060
could make notify user of failure blow

00:14:46,930 --> 00:14:50,710
up because they're coupled through the

00:14:49,060 --> 00:14:52,930
parameter now parameter coupling isn't

00:14:50,710 --> 00:14:56,140
bad but less coupling is almost always

00:14:52,930 --> 00:14:59,800
good so something to notice is methods

00:14:56,140 --> 00:15:02,110
that take no arguments are superior to

00:14:59,800 --> 00:15:04,330
methods that take one because they do

00:15:02,110 --> 00:15:05,790
not have parameter coupling first time I

00:15:04,330 --> 00:15:09,400
heard that that blew my mind

00:15:05,790 --> 00:15:10,870
also if we keep using induction methods

00:15:09,400 --> 00:15:12,940
that take one argument are better than

00:15:10,870 --> 00:15:14,050
ones that take two and methods to take

00:15:12,940 --> 00:15:15,970
two arguments are better than the ones

00:15:14,050 --> 00:15:19,330
that take three because in each example

00:15:15,970 --> 00:15:20,950
we're lowering parameter coupling so

00:15:19,330 --> 00:15:23,380
notice what happened here we just

00:15:20,950 --> 00:15:28,090
slimmed down our argument lists from

00:15:23,380 --> 00:15:29,850
three to two and that's a win so

00:15:28,090 --> 00:15:32,320
coupling is reduced

00:15:29,850 --> 00:15:33,700
that's one win we've made something

00:15:32,320 --> 00:15:36,310
explicitly used to be implicit that's

00:15:33,700 --> 00:15:39,730
another win but also we now have a great

00:15:36,310 --> 00:15:40,960
place to hang behavior in

00:15:39,730 --> 00:15:43,180
object-oriented programming it's a

00:15:40,960 --> 00:15:45,310
really good idea to group behavior with

00:15:43,180 --> 00:15:49,240
the data operates on and now that I look

00:15:45,310 --> 00:15:51,550
at this figuring out if a date is

00:15:49,240 --> 00:15:52,930
between two and two bounds is not

00:15:51,550 --> 00:15:55,180
actually really good responsibility for

00:15:52,930 --> 00:15:56,260
order but it's a great responsibility

00:15:55,180 --> 00:15:58,360
for date range

00:15:56,260 --> 00:16:01,270
I can imagine wanting to know if other

00:15:58,360 --> 00:16:03,880
objects have a date place between two

00:16:01,270 --> 00:16:07,060
two end points and we can reuse date

00:16:03,880 --> 00:16:10,390
range so what other to do now is move

00:16:07,060 --> 00:16:15,550
this logic into date range so why don't

00:16:10,390 --> 00:16:18,340
we say what we want this to look like so

00:16:15,550 --> 00:16:25,390
why don't I ask date range hey does this

00:16:18,340 --> 00:16:28,420
include my place that that looks good to

00:16:25,390 --> 00:16:35,420
me that blows up as expected because

00:16:28,420 --> 00:16:40,550
this method doesn't exist date

00:16:35,420 --> 00:16:47,480
and then we'll say is date after the

00:16:40,550 --> 00:16:51,140
start date and before the end date let's

00:16:47,480 --> 00:16:53,329
see if that works for us it does so now

00:16:51,140 --> 00:16:57,110
order just knows how to ask something

00:16:53,329 --> 00:16:58,160
else if its place that is included and I

00:16:57,110 --> 00:16:59,839
like this because order should know

00:16:58,160 --> 00:17:02,149
about place that I'm okay referencing

00:16:59,839 --> 00:17:04,819
this bit of data which is on order

00:17:02,149 --> 00:17:06,410
within order and I'm okay with date

00:17:04,819 --> 00:17:09,110
range knowing how to find if a date is

00:17:06,410 --> 00:17:11,750
between two dates perfect exactly where

00:17:09,110 --> 00:17:13,429
I want this logic to live now lets this

00:17:11,750 --> 00:17:14,750
guy asked about a little refactoring so

00:17:13,429 --> 00:17:16,939
let's do that right now there's actually

00:17:14,750 --> 00:17:20,480
a handy way of writing this so I can ask

00:17:16,939 --> 00:17:24,880
if start date end date the range if it

00:17:20,480 --> 00:17:27,679
includes date right back to green good

00:17:24,880 --> 00:17:31,190
but a little thing that that I gave this

00:17:27,679 --> 00:17:35,840
talk somewhere maybe Scottish rubyconf

00:17:31,190 --> 00:17:41,809
and Jose valium told me this cover cover

00:17:35,840 --> 00:17:43,549
or covers let's see no cover yeah so

00:17:41,809 --> 00:17:45,200
when you ask a range if it includes

00:17:43,549 --> 00:17:48,290
something Ruby is going to instantiate

00:17:45,200 --> 00:17:50,270
every object within that range and then

00:17:48,290 --> 00:17:52,160
check if the object you pass it to

00:17:50,270 --> 00:17:54,380
include it exists in there if you ask

00:17:52,160 --> 00:17:55,250
cover it's just going to figure out it's

00:17:54,380 --> 00:17:57,080
going to stand she ate the two end

00:17:55,250 --> 00:17:58,250
points and then use some logic to figure

00:17:57,080 --> 00:17:59,960
out if the thing you passed in is in

00:17:58,250 --> 00:18:02,210
between this so if we had a date range

00:17:59,960 --> 00:18:03,080
that was three hundred years long this

00:18:02,210 --> 00:18:06,070
actually could be a lot faster

00:18:03,080 --> 00:18:06,070
performance wise yeah question

00:18:15,260 --> 00:18:19,860
that's a great point his point was that

00:18:18,390 --> 00:18:22,080
my tests aren't really thorough enough

00:18:19,860 --> 00:18:23,190
I'm not testing the edge conditions in

00:18:22,080 --> 00:18:24,330
there and that's actually a really good

00:18:23,190 --> 00:18:27,150
point I should go back and improve those

00:18:24,330 --> 00:18:29,160
tests I think you can probably that it

00:18:27,150 --> 00:18:30,480
works enough for now but yeah that's it

00:18:29,160 --> 00:18:31,950
that's a good thing I should I'll be

00:18:30,480 --> 00:18:40,910
 the coverage on that guy that's a

00:18:31,950 --> 00:18:40,910
very good point other questions yeah

00:18:43,740 --> 00:18:51,580
No

00:18:46,320 --> 00:18:53,530
yeah feature in good point yeah so the

00:18:51,580 --> 00:18:55,300
code smell that motivates this kind of

00:18:53,530 --> 00:18:58,060
refactoring is called feature envy and

00:18:55,300 --> 00:18:59,470
feature Envy is when one class seems

00:18:58,060 --> 00:19:01,390
very concerned with the internals of

00:18:59,470 --> 00:19:02,740
another class when it's asking a lot of

00:19:01,390 --> 00:19:04,270
questions about its internal data and

00:19:02,740 --> 00:19:06,250
working with it that's usually a good

00:19:04,270 --> 00:19:08,710
hint that you want to move that logic on

00:19:06,250 --> 00:19:10,810
to the class itself the the code the

00:19:08,710 --> 00:19:12,640
client code has envy of what that other

00:19:10,810 --> 00:19:13,900
class knows and so it's asking a lot of

00:19:12,640 --> 00:19:16,510
questions and fiddling around with the

00:19:13,900 --> 00:19:18,400
data thank you that's good so a couple

00:19:16,510 --> 00:19:20,380
little quick things I would do now tree

00:19:18,400 --> 00:19:25,390
fat to finish this up I'm going to move

00:19:20,380 --> 00:19:27,100
on to a new example so this is kind of

00:19:25,390 --> 00:19:27,640
ugly right this is pretty janky when I

00:19:27,100 --> 00:19:29,440
read this

00:19:27,640 --> 00:19:30,700
yes I'm mapping the amount and I'm doing

00:19:29,440 --> 00:19:32,050
this and I'm summing this way but if you

00:19:30,700 --> 00:19:34,150
read this you're just really calculating

00:19:32,050 --> 00:19:35,800
the total sales right so whenever I have

00:19:34,150 --> 00:19:38,110
a bunch of kind of ugly code that I

00:19:35,800 --> 00:19:39,940
wouldn't just wouldn't use the words oh

00:19:38,110 --> 00:19:41,860
I'm going to map the amount and then

00:19:39,940 --> 00:19:43,330
inject what 0 is the default and add the

00:19:41,860 --> 00:19:45,190
sum what I'd really say if I would

00:19:43,330 --> 00:19:47,350
describe this to you is then I'll add up

00:19:45,190 --> 00:19:48,730
the total sales so when you look at your

00:19:47,350 --> 00:19:50,590
code and it doesn't read like you would

00:19:48,730 --> 00:19:54,480
say it make it read like you would say

00:19:50,590 --> 00:19:54,480
it so what I really would say is

00:19:55,170 --> 00:19:58,410
something like that

00:20:02,140 --> 00:20:14,800
oh we're my type of sorters within range

00:20:09,540 --> 00:20:16,960
all right back to green so now take a

00:20:14,800 --> 00:20:18,640
look at this top level method the total

00:20:16,960 --> 00:20:20,560
sales here's the name total sales within

00:20:18,640 --> 00:20:23,020
date range are the total sales of the

00:20:20,560 --> 00:20:25,660
orders within range that is how I want

00:20:23,020 --> 00:20:27,520
my code to look that's like brain dead

00:20:25,660 --> 00:20:29,680
simple right and this is my only prime

00:20:27,520 --> 00:20:31,570
only public method I'm extra aggressive

00:20:29,680 --> 00:20:33,040
about making my public methods read like

00:20:31,570 --> 00:20:34,990
this because it's really likely that

00:20:33,040 --> 00:20:37,570
someone that comes into this code mostly

00:20:34,990 --> 00:20:39,610
cares about this method these I'm

00:20:37,570 --> 00:20:40,720
slightly less aggressive about that but

00:20:39,610 --> 00:20:42,610
people want to know about your public

00:20:40,720 --> 00:20:45,070
API your public API should be super

00:20:42,610 --> 00:20:46,510
super clear your private API should be

00:20:45,070 --> 00:20:48,100
as well but it's a little bit less

00:20:46,510 --> 00:20:51,250
important it's less likely that people

00:20:48,100 --> 00:20:53,020
care about those details but even so I'm

00:20:51,250 --> 00:20:55,030
gonna change this guy right here just to

00:20:53,020 --> 00:20:59,940
be a slightly quick little hack with

00:20:55,030 --> 00:21:05,680
Ruby 1:9 I don't need the ampersand

00:20:59,940 --> 00:21:06,700
symbol plus oh my goodness so it calls

00:21:05,680 --> 00:21:14,290
to proc on that for me

00:21:06,700 --> 00:21:15,370
oh that's wonderful that's cool okay so

00:21:14,290 --> 00:21:16,360
apparently we don't need to you don't

00:21:15,370 --> 00:21:17,560
need to call to proc out you can just

00:21:16,360 --> 00:21:18,070
pass in a similar argument which is

00:21:17,560 --> 00:21:22,830
wonderful

00:21:18,070 --> 00:21:22,830
I think else I heard some murmuring

00:21:24,540 --> 00:21:30,190
sakura-san adobe the zero but he is only

00:21:27,640 --> 00:21:32,650
partially right if I don't have any

00:21:30,190 --> 00:21:34,330
orders this will blow up and funny

00:21:32,650 --> 00:21:36,010
enough I didn't have the zero originally

00:21:34,330 --> 00:21:37,690
and then in the middle of a talk Jim why

00:21:36,010 --> 00:21:38,830
rick is like what happens if you don't

00:21:37,690 --> 00:21:43,930
have any orders within range

00:21:38,830 --> 00:21:45,550
and I was like map will bring up an

00:21:43,930 --> 00:21:47,320
empty array and then I'll checked over

00:21:45,550 --> 00:21:48,640
it and what do I get if I don't have it

00:21:47,320 --> 00:21:53,080
I guess I'll return an empty array as

00:21:48,640 --> 00:22:02,430
opposed to zero right if I inject plus

00:21:53,080 --> 00:22:06,160
on zero yeah right if I just have this

00:22:02,430 --> 00:22:09,820
that's going to blow up right nil as

00:22:06,160 --> 00:22:13,330
opposed to zero so Jim where I rec beat

00:22:09,820 --> 00:22:14,710
you on that one Cory sorry you should

00:22:13,330 --> 00:22:16,180
see my commit message look Jim Wyrick

00:22:14,710 --> 00:22:18,550
found a bug in my talk I was really

00:22:16,180 --> 00:22:20,200
excited okay so we've been working hard

00:22:18,550 --> 00:22:24,030
so I want to show you as a quick means

00:22:20,200 --> 00:22:24,030
of a break my most important Finn plugin

00:22:26,250 --> 00:22:34,950
mmm this is the only vim plugin I use

00:22:29,800 --> 00:22:36,670
obviously not really but hey alright

00:22:34,950 --> 00:22:40,930
let's move on let's do something

00:22:36,670 --> 00:22:45,250
different there's another bit of code I

00:22:40,930 --> 00:22:51,400
like you to look over now this code

00:22:45,250 --> 00:22:55,390
represents a job site as in the place

00:22:51,400 --> 00:22:56,260
we're doing some construction work we're

00:22:55,390 --> 00:22:59,390
cutting off the top of the screen a

00:22:56,260 --> 00:23:01,640
little bit let's go up here there you

00:22:59,390 --> 00:23:03,530
now all job sites have a location

00:23:01,640 --> 00:23:05,480
because you're always doing work

00:23:03,530 --> 00:23:08,450
somewhere but not every job site is

00:23:05,480 --> 00:23:10,790
going to have a contact contact could be

00:23:08,450 --> 00:23:14,230
no that's optional we might not know who

00:23:10,790 --> 00:23:16,190
the contact is at a particular job site

00:23:14,230 --> 00:23:18,350
so notice I've just described something

00:23:16,190 --> 00:23:19,400
implicit about this code right it's not

00:23:18,350 --> 00:23:22,010
obvious from looking at this that a

00:23:19,400 --> 00:23:24,260
contact is optional but you can start to

00:23:22,010 --> 00:23:25,250
see it at these ugly conditionals look

00:23:24,260 --> 00:23:27,110
what happens if I want to pull up the

00:23:25,250 --> 00:23:28,970
contact name I've got to check for the

00:23:27,110 --> 00:23:29,590
presence of contact otherwise I provide

00:23:28,970 --> 00:23:32,750
a default

00:23:29,590 --> 00:23:34,010
likewise with contact phone and if I

00:23:32,750 --> 00:23:35,299
want to email the contact I have to make

00:23:34,010 --> 00:23:40,549
sure he exists first before I try to

00:23:35,299 --> 00:23:42,890
call a method on it so how is this code

00:23:40,549 --> 00:23:45,380
well his codes okay it's not great

00:23:42,890 --> 00:23:47,570
what's what's the problem well it turns

00:23:45,380 --> 00:23:49,370
out in a slightly more hidden way we're

00:23:47,570 --> 00:23:52,100
still violating tell don't ask vital

00:23:49,370 --> 00:23:54,890
until don't ask again so we're actually

00:23:52,100 --> 00:23:57,350
every time we ask contact something we

00:23:54,890 --> 00:24:00,140
say hey do you evaluate to a truth eval

00:23:57,350 --> 00:24:03,440
you and if you do I know what to do and

00:24:00,140 --> 00:24:05,200
if not I'll do something else so what

00:24:03,440 --> 00:24:08,390
we'd rather do is just send contact

00:24:05,200 --> 00:24:10,309
contact name tell me your name and if

00:24:08,390 --> 00:24:13,059
you do exist return what your name is

00:24:10,309 --> 00:24:15,290
and if you don't exist tell me no name

00:24:13,059 --> 00:24:18,919
so what's actually happened here is

00:24:15,290 --> 00:24:20,570
we've co-opted nil because when content

00:24:18,919 --> 00:24:22,400
doesn't exist at contact will be new and

00:24:20,570 --> 00:24:24,950
so I'm actually passing around the nil

00:24:22,400 --> 00:24:27,470
object the nil singleton as my contact

00:24:24,950 --> 00:24:28,669
that's not a very good idea and at least

00:24:27,470 --> 00:24:31,370
this ugly conditionals

00:24:28,669 --> 00:24:34,400
like the one on 12 so how do I prove

00:24:31,370 --> 00:24:36,110
this well oh and one other bad thing

00:24:34,400 --> 00:24:37,760
this obscures the point of the code

00:24:36,110 --> 00:24:39,590
right contact that name really just

00:24:37,760 --> 00:24:41,360
cares about the contacts name but I have

00:24:39,590 --> 00:24:42,799
this annoying handling in here it's

00:24:41,360 --> 00:24:46,220
making it harder to actually see what

00:24:42,799 --> 00:24:47,750
this code really does so the way around

00:24:46,220 --> 00:24:51,169
this is with the pattern reasonably

00:24:47,750 --> 00:24:54,200
common one called null object pattern so

00:24:51,169 --> 00:24:56,630
rather than having nil stand-in to mean

00:24:54,200 --> 00:24:59,360
when there is no contact I'm going to

00:24:56,630 --> 00:25:01,940
actually create an explicit object to

00:24:59,360 --> 00:25:03,919
stand in for that case and since this

00:25:01,940 --> 00:25:05,150
uses the null object pattern and I

00:25:03,919 --> 00:25:08,179
believe it's a good idea to actually use

00:25:05,150 --> 00:25:09,200
pattern names in class names which will

00:25:08,179 --> 00:25:11,360
some people want to fight to the death

00:25:09,200 --> 00:25:12,190
about that one I'm gonna call it Mel

00:25:11,360 --> 00:25:13,750
contact

00:25:12,190 --> 00:25:16,300
so if we don't actually have a contact

00:25:13,750 --> 00:25:19,030
passed in assign a null contact that new

00:25:16,300 --> 00:25:24,190
let's run our tests oops

00:25:19,030 --> 00:25:26,500
get their own test going boom and things

00:25:24,190 --> 00:25:29,500
blow up the first error was that there's

00:25:26,500 --> 00:25:31,650
no null contact so let's make that

00:25:29,500 --> 00:25:31,650
happen

00:25:36,310 --> 00:25:40,880
now we have more errors and now what's

00:25:38,660 --> 00:25:42,500
happening here is I have tests that

00:25:40,880 --> 00:25:44,810
don't pass in a contact they just pass

00:25:42,500 --> 00:25:47,420
in passing nothing and so it's assigning

00:25:44,810 --> 00:25:48,680
a new null contact here but then no

00:25:47,420 --> 00:25:50,450
client it doesn't respond to things like

00:25:48,680 --> 00:25:52,070
contact that name it's just a brand new

00:25:50,450 --> 00:25:53,600
class got nothing on it so let's add

00:25:52,070 --> 00:25:56,000
these things so we're gonna add name

00:25:53,600 --> 00:25:57,770
we're gonna add phone then we're going

00:25:56,000 --> 00:25:59,050
to add deliver personalized email on to

00:25:57,770 --> 00:26:02,270
our adult contact class

00:25:59,050 --> 00:26:04,040
so here's name just when there's no

00:26:02,270 --> 00:26:11,690
contact the thing I want to return is no

00:26:04,040 --> 00:26:16,550
name or no email deliver personalized

00:26:11,690 --> 00:26:18,170
email takes a email body but I'm just

00:26:16,550 --> 00:26:19,760
gonna leave a blank I'm not gonna have

00:26:18,170 --> 00:26:25,790
to do anything so there's not a contact

00:26:19,760 --> 00:26:30,970
just do nothing so if I run this oh I'm

00:26:25,790 --> 00:26:36,440
gonna find method phone up phone right

00:26:30,970 --> 00:26:42,740
phone yeah okay

00:26:36,440 --> 00:26:44,450
back to green and now we're green but

00:26:42,740 --> 00:26:46,460
what can I do now I can do what every

00:26:44,450 --> 00:26:51,440
programmer favorite thing is which is

00:26:46,460 --> 00:26:53,390
what delete code no one ever fails to

00:26:51,440 --> 00:26:55,730
know what that is that is so universally

00:26:53,390 --> 00:26:58,910
the programmers favorite thing everyone

00:26:55,730 --> 00:27:00,710
gets that so let's lay some code oh yeah

00:26:58,910 --> 00:27:08,990
oh yeah

00:27:00,710 --> 00:27:11,720
oh my god ah and we're still green how

00:27:08,990 --> 00:27:13,670
great is that right yeah thank you fit

00:27:11,720 --> 00:27:14,240
that guys yes like I like snot contact a

00:27:13,670 --> 00:27:17,660
lot me too

00:27:14,240 --> 00:27:21,050
okay so for the cost of this stupidly

00:27:17,660 --> 00:27:22,580
simple null contact class I've blown

00:27:21,050 --> 00:27:24,370
away three conditionals

00:27:22,580 --> 00:27:27,260
you ain't add about twelve lines of code

00:27:24,370 --> 00:27:30,500
made these methods more obvious and more

00:27:27,260 --> 00:27:33,740
direct all for the cost of one little

00:27:30,500 --> 00:27:36,860
class also notice we're no longer valid

00:27:33,740 --> 00:27:39,250
until don't ask we always tell some sort

00:27:36,860 --> 00:27:42,380
of contact yo dude I need your name

00:27:39,250 --> 00:27:44,990
we never care about whether it's an

00:27:42,380 --> 00:27:47,540
actual contact or a null contact the

00:27:44,990 --> 00:27:48,210
client code doesn't know and it doesn't

00:27:47,540 --> 00:27:49,769
care

00:27:48,210 --> 00:27:51,960
so that's awesome this is actually a

00:27:49,769 --> 00:27:53,369
great win this pattern it's simple but

00:27:51,960 --> 00:27:55,200
once you understand it you see

00:27:53,369 --> 00:27:58,529
opportunities to to work with it all the

00:27:55,200 --> 00:28:02,749
time and it's great now there's a

00:27:58,529 --> 00:28:02,749
downside now right what's the downside

00:28:03,470 --> 00:28:08,999
that's now I basically have to keep two

00:28:06,389 --> 00:28:10,559
api's in sync right if I add new methods

00:28:08,999 --> 00:28:12,720
to contact I'm going to need to add them

00:28:10,559 --> 00:28:14,580
to no contact as well that's a bit of a

00:28:12,720 --> 00:28:17,159
pain in the ass but it turns out it's

00:28:14,580 --> 00:28:19,139
generally worth it a lot of code ends up

00:28:17,159 --> 00:28:21,419
with these big hairy nasty conditionals

00:28:19,139 --> 00:28:23,190
and null contact just like destroys them

00:28:21,419 --> 00:28:25,080
like that by the way this refactoring is

00:28:23,190 --> 00:28:27,690
called replaced conditional with

00:28:25,080 --> 00:28:30,629
polymorphism which means rather than

00:28:27,690 --> 00:28:32,549
doing ifs just send that same message to

00:28:30,629 --> 00:28:35,549
multiple different classes that's

00:28:32,549 --> 00:28:37,200
polymorphism right you just always send

00:28:35,549 --> 00:28:38,700
a message to varying different types of

00:28:37,200 --> 00:28:40,769
objects and objects know how to respond

00:28:38,700 --> 00:28:43,289
to it in different ways so it's a bit of

00:28:40,769 --> 00:28:45,720
a cost to this so you have to weigh that

00:28:43,289 --> 00:28:47,820
to see if it's worth it nothing I'm

00:28:45,720 --> 00:28:49,799
teaching you today always works

00:28:47,820 --> 00:28:52,679
there's no referring that is always a

00:28:49,799 --> 00:28:54,990
great idea you always have to say is

00:28:52,679 --> 00:28:57,629
this worth it given the components of my

00:28:54,990 --> 00:28:59,549
system as they are so that's the

00:28:57,629 --> 00:29:01,499
downside we talked about the good signs

00:28:59,549 --> 00:29:05,039
there's a lot going on how many people

00:29:01,499 --> 00:29:07,649
by the way have code in a rails app that

00:29:05,039 --> 00:29:07,980
looks like if current user yada yada

00:29:07,649 --> 00:29:12,389
yada

00:29:07,980 --> 00:29:14,639
here's your hand yeah can you see how

00:29:12,389 --> 00:29:16,950
this would apply to that so rather than

00:29:14,639 --> 00:29:19,980
have current user returned a user object

00:29:16,950 --> 00:29:22,499
or nil and then constantly need to check

00:29:19,980 --> 00:29:28,669
if current user is nil have current user

00:29:22,499 --> 00:29:28,669
returned user or a null user yeah

00:29:29,429 --> 00:29:32,429
yes

00:29:37,410 --> 00:29:40,410
yeah

00:29:42,140 --> 00:29:44,799
yes

00:29:53,029 --> 00:29:58,639
it's a great question the question was

00:29:55,309 --> 00:30:00,049
Mel content is defined in this class do

00:29:58,639 --> 00:30:01,269
I leave it in the class or do I pull it

00:30:00,049 --> 00:30:04,189
out and make it sort of a first-class

00:30:01,269 --> 00:30:05,929
citizen in my business logic and the

00:30:04,189 --> 00:30:07,759
answer is it varies usually with

00:30:05,929 --> 00:30:09,349
something like a null contact I will

00:30:07,759 --> 00:30:11,839
pull this out I'll put it in at models

00:30:09,349 --> 00:30:14,149
I'll call it a null contact are B it

00:30:11,839 --> 00:30:17,959
will live as a top level important class

00:30:14,149 --> 00:30:20,209
in my app occasionally I will define

00:30:17,959 --> 00:30:22,279
classes that only live inside the

00:30:20,209 --> 00:30:24,169
context of like one other class right so

00:30:22,279 --> 00:30:26,359
like if you are being aggressive about

00:30:24,169 --> 00:30:28,909
extracting small classes like Bob Martin

00:30:26,359 --> 00:30:29,989
says you should be there are times where

00:30:28,909 --> 00:30:31,099
you'll find that you've written a small

00:30:29,989 --> 00:30:32,749
class that's really just like a little

00:30:31,099 --> 00:30:35,089
data container or something very basic

00:30:32,749 --> 00:30:37,509
that's only used in one class and in

00:30:35,089 --> 00:30:40,399
those cases I'll just leave that class

00:30:37,509 --> 00:30:41,749
inside the original parent class I'll

00:30:40,399 --> 00:30:43,999
even make it private so I know nothing

00:30:41,749 --> 00:30:46,219
will ever talk to it it's just for that

00:30:43,999 --> 00:30:48,949
that top-level class by the way in that

00:30:46,219 --> 00:30:50,839
case I wouldn't read explicit tests for

00:30:48,949 --> 00:30:52,489
that class if it's private to another

00:30:50,839 --> 00:30:53,599
class I'm not going to test it I'm not

00:30:52,489 --> 00:30:55,879
gonna test private methods ever actually

00:30:53,599 --> 00:30:58,549
nothing with private but if I do promote

00:30:55,879 --> 00:30:59,959
it and to be a top-level class then I'm

00:30:58,549 --> 00:31:02,029
going to write separate unit tests for

00:30:59,959 --> 00:31:05,449
this to make sure it works it's a great

00:31:02,029 --> 00:31:07,839
question other questions about this or

00:31:05,449 --> 00:31:07,839
anything else

00:31:10,440 --> 00:31:15,450
all right we got one more example and

00:31:12,750 --> 00:31:17,300
then a quick wrap-up and I got some

00:31:15,450 --> 00:31:25,100
recommendations and things like that so

00:31:17,300 --> 00:31:25,100
onward and upward let's go to this guy

00:31:25,910 --> 00:31:29,900
take a second and read this code

00:31:44,450 --> 00:31:51,889
okay so let's talk about an idea called

00:31:48,590 --> 00:31:53,059
depend upon abstractions now most

00:31:51,889 --> 00:31:55,909
programmers are aware that's a good idea

00:31:53,059 --> 00:31:57,590
to depend upon abstractions so most

00:31:55,909 --> 00:32:00,169
people will use for example active

00:31:57,590 --> 00:32:01,999
record to have it generate sequel for

00:32:00,169 --> 00:32:03,739
them rather than write sequel by hand

00:32:01,999 --> 00:32:05,269
unless you're in a horribly ugly

00:32:03,739 --> 00:32:06,529
situation where sometimes that's the

00:32:05,269 --> 00:32:10,399
only way out but hopefully you don't get

00:32:06,529 --> 00:32:12,950
there also most people won't just shove

00:32:10,399 --> 00:32:16,159
bytes into a socket they'll use a

00:32:12,950 --> 00:32:17,539
library like net HTTP so most

00:32:16,159 --> 00:32:18,859
programmers are aware of this idea in

00:32:17,539 --> 00:32:20,330
general like you want to you'd rather

00:32:18,859 --> 00:32:22,609
keep pulling up a level of abstraction

00:32:20,330 --> 00:32:24,109
and you'd rather depend upon those

00:32:22,609 --> 00:32:26,359
abstractions than particular

00:32:24,109 --> 00:32:27,919
implementation details for instance

00:32:26,359 --> 00:32:30,049
that's why you pull a lot of stuff to be

00:32:27,919 --> 00:32:32,210
private inside an object you don't want

00:32:30,049 --> 00:32:34,159
other things outside that code to depend

00:32:32,210 --> 00:32:37,039
on your internals you want to depend on

00:32:34,159 --> 00:32:37,940
an abstraction that you're providing the

00:32:37,039 --> 00:32:40,970
thing that a lot of people don't realize

00:32:37,940 --> 00:32:43,369
is that abstractions are fractal you can

00:32:40,970 --> 00:32:45,200
keep going higher and higher and you

00:32:43,369 --> 00:32:46,730
should be relatively aggressive about

00:32:45,200 --> 00:32:48,950
creating abstractions within your

00:32:46,730 --> 00:32:52,190
application one great rule of thumb is

00:32:48,950 --> 00:32:53,509
that you want the hole to be simpler

00:32:52,190 --> 00:32:55,429
than the sum of its parts

00:32:53,509 --> 00:32:56,899
that's a great rule I took from the book

00:32:55,429 --> 00:32:59,179
called growing object-oriented software

00:32:56,899 --> 00:33:01,009
guided by tests which has the longest

00:32:59,179 --> 00:33:02,389
book title I've ever recommended I'm

00:33:01,009 --> 00:33:03,950
going to show you a link to that later

00:33:02,389 --> 00:33:06,409
cuz it's an awesome book that's a great

00:33:03,950 --> 00:33:08,149
rule of thumb the sum should be simpler

00:33:06,409 --> 00:33:09,919
to work with than its parts

00:33:08,149 --> 00:33:12,320
so if you've got a few models or a few

00:33:09,919 --> 00:33:14,149
classes in your app wrap a class around

00:33:12,320 --> 00:33:16,549
that bad boy make a simple API that's

00:33:14,149 --> 00:33:18,320
easier to use create an abstraction that

00:33:16,549 --> 00:33:22,759
your other things can depend upon rather

00:33:18,320 --> 00:33:24,559
than the low details within your app one

00:33:22,759 --> 00:33:26,480
place I see this violate a lot is ideas

00:33:24,559 --> 00:33:28,489
like this so I have all this code here

00:33:26,480 --> 00:33:30,109
and this code is concerned with charging

00:33:28,489 --> 00:33:33,139
people thing for things braintree by the

00:33:30,109 --> 00:33:34,940
way as a payment processor so I pull

00:33:33,139 --> 00:33:37,429
down the Braintree gem which is good

00:33:34,940 --> 00:33:39,619
it's better than writing direct calls to

00:33:37,429 --> 00:33:41,989
Braintree as API shoving bytes down a

00:33:39,619 --> 00:33:44,299
socket I've extracted a bit it's using

00:33:41,989 --> 00:33:45,529
an HTTP API but my code doesn't know

00:33:44,299 --> 00:33:48,200
about that it doesn't know that this is

00:33:45,529 --> 00:33:51,730
an HTTP API which is good we've gone

00:33:48,200 --> 00:33:54,799
pretty far this is nice it's not great

00:33:51,730 --> 00:33:56,059
notice that user is concerned with

00:33:54,799 --> 00:33:57,550
things like how do I find my own

00:33:56,059 --> 00:33:59,200
Braintree ID

00:33:57,550 --> 00:34:00,670
and then once I do how do I charge for a

00:33:59,200 --> 00:34:03,370
subscription and how much should I

00:34:00,670 --> 00:34:05,920
charge or how do I create myself as a

00:34:03,370 --> 00:34:08,080
customer with inside Braintree and then

00:34:05,920 --> 00:34:10,330
refund is concerned with other problems

00:34:08,080 --> 00:34:12,220
how do I find the transaction ID of the

00:34:10,330 --> 00:34:13,560
thing I billed for and then how do I

00:34:12,220 --> 00:34:15,909
refund that

00:34:13,560 --> 00:34:18,460
so we've depending upon the Braintree

00:34:15,909 --> 00:34:21,070
gem as an abstraction but we can go more

00:34:18,460 --> 00:34:22,690
abstract than that this has some this to

00:34:21,070 --> 00:34:25,630
have some weaknesses right now if I

00:34:22,690 --> 00:34:27,550
wanted to change which gem we use to

00:34:25,630 --> 00:34:30,490
bill with Braintree I suddenly need to

00:34:27,550 --> 00:34:32,350
open up user that seems like the wrong

00:34:30,490 --> 00:34:33,460
thing right oh I need to change which

00:34:32,350 --> 00:34:34,929
payment processing gem I'm using

00:34:33,460 --> 00:34:38,530
therefore let me open up the user class

00:34:34,929 --> 00:34:41,020
right that's a great smell there's this

00:34:38,530 --> 00:34:42,970
idea called shotgun surgery where if you

00:34:41,020 --> 00:34:45,100
need to make a change in your app I need

00:34:42,970 --> 00:34:46,330
to open up 30 files you're doing surgery

00:34:45,100 --> 00:34:47,409
with a shotgun regular blow and stuff

00:34:46,330 --> 00:34:48,880
code everywhere you're affecting

00:34:47,409 --> 00:34:49,659
everything you're breaking stuff it's so

00:34:48,880 --> 00:34:51,010
much more likely that you're going to

00:34:49,659 --> 00:34:53,169
break things you're going to do it wrong

00:34:51,010 --> 00:34:55,600
wouldn't you love to just open up one

00:34:53,169 --> 00:34:57,690
file and change your payment processing

00:34:55,600 --> 00:34:59,530
gem there yes you would

00:34:57,690 --> 00:35:01,330
isn't it likely that you might change

00:34:59,530 --> 00:35:02,580
payment processors yes it absolutely is

00:35:01,330 --> 00:35:04,420
I've done it before

00:35:02,580 --> 00:35:07,170
here we have to open up all these

00:35:04,420 --> 00:35:10,960
classes so how do we improve upon this

00:35:07,170 --> 00:35:13,840
well we do something like I would do

00:35:10,960 --> 00:35:15,700
something like this I make a new class

00:35:13,840 --> 00:35:18,730
as you might have guessed so I love

00:35:15,700 --> 00:35:20,830
classes called payment gateway I've

00:35:18,730 --> 00:35:22,050
moved that constant inside payment

00:35:20,830 --> 00:35:24,430
gateway it's a nice place to hang it and

00:35:22,050 --> 00:35:27,880
I set up my gateway which by default is

00:35:24,430 --> 00:35:32,950
Braintree gem and I move that logic in

00:35:27,880 --> 00:35:36,250
there and then my client code this stuff

00:35:32,950 --> 00:35:38,440
only knows about payment gateway and the

00:35:36,250 --> 00:35:42,310
method names and it just passes itself

00:35:38,440 --> 00:35:44,680
in now all that logic lives inside

00:35:42,310 --> 00:35:46,810
payment gateway it hasn't leaked into my

00:35:44,680 --> 00:35:49,300
application if I want to change payment

00:35:46,810 --> 00:35:51,730
processors there's only one file that

00:35:49,300 --> 00:35:54,310
needs to change that's the power of

00:35:51,730 --> 00:35:55,480
depending upon abstraction one file

00:35:54,310 --> 00:35:57,790
needs to change when I'm going to change

00:35:55,480 --> 00:35:59,320
not shotgun surgery that's actually a

00:35:57,790 --> 00:36:00,520
really big win it makes it easier to

00:35:59,320 --> 00:36:03,090
change stuff which is the thing that

00:36:00,520 --> 00:36:06,130
really matters

00:36:03,090 --> 00:36:09,100
finally notice now if I want to test

00:36:06,130 --> 00:36:11,880
this guy thoroughly I have to stub

00:36:09,100 --> 00:36:15,099
methods on Braintree

00:36:11,880 --> 00:36:17,410
which is a great way to make yourself

00:36:15,099 --> 00:36:19,809
wanting to have a bad day you're going

00:36:17,410 --> 00:36:21,039
to have a bad time if you stub other

00:36:19,809 --> 00:36:21,670
people's methods you're going to have a

00:36:21,039 --> 00:36:24,969
bad time

00:36:21,670 --> 00:36:27,009
Braintree gem hit API is reasonably

00:36:24,969 --> 00:36:28,989
likely to change you update versions

00:36:27,009 --> 00:36:30,609
your tests are stubbed out

00:36:28,989 --> 00:36:32,769
you don't realize those methods have

00:36:30,609 --> 00:36:34,630
been changed until you run this thing in

00:36:32,769 --> 00:36:36,339
production and it blows up and you can't

00:36:34,630 --> 00:36:40,449
build people for stuff and people are

00:36:36,339 --> 00:36:42,549
really upset in this version you can

00:36:40,449 --> 00:36:44,170
stub your own methods if you stub your

00:36:42,549 --> 00:36:44,799
own methods you're going to have a good

00:36:44,170 --> 00:36:47,829
time

00:36:44,799 --> 00:36:49,779
I'm totally fine stubbing out charge for

00:36:47,829 --> 00:36:52,599
subscription or create customer because

00:36:49,779 --> 00:36:55,059
I control them so this thing just got

00:36:52,599 --> 00:36:56,739
easier to test with the introduction of

00:36:55,059 --> 00:36:59,199
a new abstraction that's a great sign

00:36:56,739 --> 00:37:00,219
that's a positive code smell when you're

00:36:59,199 --> 00:37:01,900
writing your tests

00:37:00,219 --> 00:37:03,910
pay attention they're telling you things

00:37:01,900 --> 00:37:04,930
if it's hard to test something if you

00:37:03,910 --> 00:37:05,469
have to do something that makes you feel

00:37:04,930 --> 00:37:08,109
dirty

00:37:05,469 --> 00:37:10,359
don't do it listen to those tests and

00:37:08,109 --> 00:37:11,979
instead figure out how you can test it

00:37:10,359 --> 00:37:13,930
and figure out a change you can make to

00:37:11,979 --> 00:37:17,049
it to test it in an easy and

00:37:13,930 --> 00:37:19,779
straightforward way I don't always do

00:37:17,049 --> 00:37:22,869
things like this but when I notice that

00:37:19,779 --> 00:37:25,059
I've got the concerns of billing spread

00:37:22,869 --> 00:37:27,099
out through the app I'm more unpretty

00:37:25,059 --> 00:37:30,699
likely to do it I don't like to see

00:37:27,099 --> 00:37:32,259
things like gem names popping up or gem

00:37:30,699 --> 00:37:34,539
class names popping out through all my

00:37:32,259 --> 00:37:36,400
business logic I'm just concerned this

00:37:34,539 --> 00:37:39,400
is a payment gateway I'm not concerned

00:37:36,400 --> 00:37:42,609
that I'm using Braintree to do it depend

00:37:39,400 --> 00:37:44,499
upon abstractions okay so we've talked a

00:37:42,609 --> 00:37:49,569
bit about some different ways of

00:37:44,499 --> 00:37:50,679
refactoring so when do you refactor well

00:37:49,569 --> 00:37:52,929
the best time to refactor is when you

00:37:50,679 --> 00:37:55,179
want to make changes to the code it's

00:37:52,929 --> 00:37:56,619
actually rare for me to just be like

00:37:55,179 --> 00:37:59,859
wake up a Monday morning like you know

00:37:56,619 --> 00:38:01,420
what one or a fact or some stuff there's

00:37:59,859 --> 00:38:03,160
that user class that sucks I'm gonna

00:38:01,420 --> 00:38:06,579
refactor it now part of that is because

00:38:03,160 --> 00:38:08,769
I'm a consultant right and consulting

00:38:06,579 --> 00:38:10,479
code is a little different than product

00:38:08,769 --> 00:38:12,549
code if you're a product company guy

00:38:10,479 --> 00:38:13,869
versus a consulting guy like at the end

00:38:12,549 --> 00:38:15,910
of every week I need to point to stuff

00:38:13,869 --> 00:38:17,739
that I've done and that justifies the

00:38:15,910 --> 00:38:19,719
value that I've just charged for so

00:38:17,739 --> 00:38:21,099
there's there's a bit of a a bit of a

00:38:19,719 --> 00:38:22,420
paradigm situation there which maybe

00:38:21,099 --> 00:38:24,069
doesn't match yours but I don't just

00:38:22,420 --> 00:38:25,640
wake up and say I'm to refactor stuff

00:38:24,069 --> 00:38:27,289
but

00:38:25,640 --> 00:38:29,359
when I go any money to change something

00:38:27,289 --> 00:38:30,980
I am very likely to go refactor it so

00:38:29,359 --> 00:38:33,859
Kent Beck had this great tweet which is

00:38:30,980 --> 00:38:36,289
if you need to make a change refactor

00:38:33,859 --> 00:38:39,289
the code so that the change is easy note

00:38:36,289 --> 00:38:42,019
this part might be hard then make the

00:38:39,289 --> 00:38:44,660
easy change it's a great way of thinking

00:38:42,019 --> 00:38:46,160
about it when you get to some code and

00:38:44,660 --> 00:38:48,789
you think oh man I got to change this

00:38:46,160 --> 00:38:51,829
widget to take a foo widget instead

00:38:48,789 --> 00:38:53,599
think about how you can make the change

00:38:51,829 --> 00:38:55,849
that you're about to make really simple

00:38:53,599 --> 00:38:58,880
and straightforward refactor it that way

00:38:55,849 --> 00:39:00,890
and then make your change so don't just

00:38:58,880 --> 00:39:03,410
refactor willy-nilly especially if your

00:39:00,890 --> 00:39:05,450
consultant okay so that's a great time

00:39:03,410 --> 00:39:07,309
to refactor what are some good things to

00:39:05,450 --> 00:39:10,400
refactor what are good candidates for a

00:39:07,309 --> 00:39:11,950
factoring well the first my favorite

00:39:10,400 --> 00:39:14,990
things to refactor are God objects

00:39:11,950 --> 00:39:16,940
that's a god objects a God object is a

00:39:14,990 --> 00:39:19,519
class in your system that everything

00:39:16,940 --> 00:39:21,859
seems to rely on or everything seems to

00:39:19,519 --> 00:39:23,990
interact with and a great rule of thumb

00:39:21,859 --> 00:39:26,930
is that rails apps almost always have

00:39:23,990 --> 00:39:29,630
two god objects the first one is user

00:39:26,930 --> 00:39:31,970
and the second one is whatever that app

00:39:29,630 --> 00:39:34,930
is about so if it's a to-do list

00:39:31,970 --> 00:39:38,059
application the other god object is what

00:39:34,930 --> 00:39:40,190
to do if it's an e-commerce application

00:39:38,059 --> 00:39:44,420
the other god object is what order

00:39:40,190 --> 00:39:46,099
exactly - god objects at least some apps

00:39:44,420 --> 00:39:47,240
have more the bigger they are the more

00:39:46,099 --> 00:39:49,519
level you've got a handful of God

00:39:47,240 --> 00:39:51,980
objects so how do you find these guys

00:39:49,519 --> 00:39:53,539
how do you be aware of them well a great

00:39:51,980 --> 00:39:55,460
way is to walk into your app models

00:39:53,539 --> 00:39:56,890
directory i've anonymized this one to

00:39:55,460 --> 00:39:59,329
protect the guilty

00:39:56,890 --> 00:40:01,490
let's get a word count of lines of every

00:39:59,329 --> 00:40:05,900
object every every model of ours and

00:40:01,490 --> 00:40:08,630
then let's sort them and you'll see that

00:40:05,900 --> 00:40:11,299
I'm not totally crazy this is an

00:40:08,630 --> 00:40:14,809
e-commerce app how can you tell well

00:40:11,299 --> 00:40:16,460
user is a god object order is right

00:40:14,809 --> 00:40:18,650
behind it and this one actually kind of

00:40:16,460 --> 00:40:24,049
has three merchants is arguably a god

00:40:18,650 --> 00:40:26,619
object do you think a 600 line class has

00:40:24,049 --> 00:40:28,640
only one responsibility

00:40:26,619 --> 00:40:30,650
probably not you've heard of the single

00:40:28,640 --> 00:40:31,819
responsibility principle right every

00:40:30,650 --> 00:40:34,009
class should only have one

00:40:31,819 --> 00:40:36,319
responsibility a singular responsibility

00:40:34,009 --> 00:40:38,269
the first rule of classes is that they

00:40:36,319 --> 00:40:39,170
should be very small the second rule of

00:40:38,269 --> 00:40:42,520
classes is

00:40:39,170 --> 00:40:42,520
they should be even smaller than that

00:40:42,579 --> 00:40:48,589
this app is violating that user is huge

00:40:45,950 --> 00:40:50,839
and because of that it is a pain to work

00:40:48,589 --> 00:40:53,059
with user so when I'm working with user

00:40:50,839 --> 00:40:54,380
I refactor it if you want me to change

00:40:53,059 --> 00:40:56,390
something about user I'm going to make

00:40:54,380 --> 00:40:58,339
damn sure when I push up those changes

00:40:56,390 --> 00:41:00,650
user is smaller than when I started

00:40:58,339 --> 00:41:02,839
I'm extremely aggressive about

00:41:00,650 --> 00:41:03,500
refactoring responsibilities out of god

00:41:02,839 --> 00:41:05,089
objects

00:41:03,500 --> 00:41:06,589
I don't want user to get any bigger I

00:41:05,089 --> 00:41:08,030
want to get it smaller same thing with

00:41:06,589 --> 00:41:09,200
order same thing with merchants it's a

00:41:08,030 --> 00:41:11,540
great way of thinking that these things

00:41:09,200 --> 00:41:13,460
be aware of your god objects and be

00:41:11,540 --> 00:41:15,920
completely reluctant to add additional

00:41:13,460 --> 00:41:18,490
lines of code to them it's going to make

00:41:15,920 --> 00:41:18,490
your life a lot better

00:41:18,520 --> 00:41:24,549
whereas what else is a great time to

00:41:20,450 --> 00:41:26,420
refactor I turn files

00:41:24,549 --> 00:41:29,240
what's churn churn is when you're

00:41:26,420 --> 00:41:31,250
changing a file a lot I keep having to

00:41:29,240 --> 00:41:34,000
come back to user and change it and

00:41:31,250 --> 00:41:36,410
change it and change it and change it

00:41:34,000 --> 00:41:37,400
pay attention to that how do you how do

00:41:36,410 --> 00:41:38,540
you notice that well maybe you just

00:41:37,400 --> 00:41:42,619
notice it but maybe you use a gem like

00:41:38,540 --> 00:41:45,380
this it's a gem called churn this will

00:41:42,619 --> 00:41:45,950
look through your git history or SVN if

00:41:45,380 --> 00:41:49,790
you're crazy

00:41:45,950 --> 00:41:52,520
and it will tell you the files that

00:41:49,790 --> 00:41:54,140
change the most if a file is changing

00:41:52,520 --> 00:41:56,299
all the time it's because you don't

00:41:54,140 --> 00:41:59,119
really understand it it's a great

00:41:56,299 --> 00:42:00,589
candidate for refactoring if change it

00:41:59,119 --> 00:42:02,930
want to make it easy to change that file

00:42:00,589 --> 00:42:04,790
in the future so give it a good a good

00:42:02,930 --> 00:42:07,220
happy dose of refactoring another great

00:42:04,790 --> 00:42:09,020
place to look for refactorings our files

00:42:07,220 --> 00:42:12,619
in which you find bugs and you know why

00:42:09,020 --> 00:42:15,380
because bugs love company if there's a

00:42:12,619 --> 00:42:18,109
lot a bug on line 10 chances are there's

00:42:15,380 --> 00:42:20,359
a bug on line 11 and the reason is the

00:42:18,109 --> 00:42:22,430
code was too complicated for you to

00:42:20,359 --> 00:42:24,829
understand it that's why the bug is

00:42:22,430 --> 00:42:27,680
there it was too hard for you to see the

00:42:24,829 --> 00:42:28,970
bug so if you've got a file where bugs

00:42:27,680 --> 00:42:31,160
are showing up all the time

00:42:28,970 --> 00:42:35,540
refactor it make it easier to understand

00:42:31,160 --> 00:42:36,859
give the bugs fewer places to hide so

00:42:35,540 --> 00:42:39,410
that's when I like to refactor so a

00:42:36,859 --> 00:42:41,359
couple recommendations before I go first

00:42:39,410 --> 00:42:46,609
is if you ever read this book read this

00:42:41,359 --> 00:42:48,589
book this is about the best like

00:42:46,609 --> 00:42:50,960
intermediate to advanced to sort of

00:42:48,589 --> 00:42:53,450
advanced beginner ish book

00:42:50,960 --> 00:42:56,900
for general programming knowledge like

00:42:53,450 --> 00:43:00,490
it it's just great read this book after

00:42:56,900 --> 00:43:00,490
you've read that book read this book

00:43:02,800 --> 00:43:07,220
there's basically nothing I'd talked

00:43:04,880 --> 00:43:09,380
about today that isn't in this book this

00:43:07,220 --> 00:43:10,640
is the Bible you've got to know this

00:43:09,380 --> 00:43:11,930
book you should know the names in it you

00:43:10,640 --> 00:43:15,470
should know the techniques in it it is

00:43:11,930 --> 00:43:17,420
wonderful also these two guys Bob Martin

00:43:15,470 --> 00:43:19,609
over here and Martin Fowler over here

00:43:17,420 --> 00:43:21,500
are just the best damn software authors

00:43:19,609 --> 00:43:22,609
there are no one writes about software

00:43:21,500 --> 00:43:26,450
and programming better than these guys

00:43:22,609 --> 00:43:29,869
in my opinion finally this is a great

00:43:26,450 --> 00:43:32,210
book this one is like the least known of

00:43:29,869 --> 00:43:33,230
those three books the other two a lot of

00:43:32,210 --> 00:43:35,900
people have read or at least I've heard

00:43:33,230 --> 00:43:37,730
of this book is sort of an unknown it's

00:43:35,900 --> 00:43:40,220
awesome it's a beginner book it's an

00:43:37,730 --> 00:43:44,150
advanced book it talks about the ideas

00:43:40,220 --> 00:43:45,819
in oo programming and TDD that I sort of

00:43:44,150 --> 00:43:48,349
roughly knew implicitly but very

00:43:45,819 --> 00:43:50,630
cogently very explicitly it made these

00:43:48,349 --> 00:43:52,609
ideas make a lot more sense it presented

00:43:50,630 --> 00:43:53,540
them in ways I've never thought of and

00:43:52,609 --> 00:43:57,799
gave me a lot of really good rules of

00:43:53,540 --> 00:43:59,240
thumb so check out those books refactor

00:43:57,799 --> 00:44:02,799
when you got to do it right some good

00:43:59,240 --> 00:44:02,799
code thank you

00:44:16,940 --> 00:44:19,000

YouTube URL: https://www.youtube.com/watch?v=DC-pQPq0acs


