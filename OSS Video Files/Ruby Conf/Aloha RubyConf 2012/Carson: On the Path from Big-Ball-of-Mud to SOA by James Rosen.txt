Title: Carson: On the Path from Big-Ball-of-Mud to SOA by James Rosen
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGg0/
Captions: 
	00:00:14,960 --> 00:00:25,890
Aloha my name is James I work at zendesk

00:00:20,369 --> 00:00:28,050
I am a senior user happiness engineer

00:00:25,890 --> 00:00:29,820
you can find me on Twitter at James a

00:00:28,050 --> 00:00:31,410
rosin you can find me on github at James

00:00:29,820 --> 00:00:33,600
Lee Rosen you can find me pretty much

00:00:31,410 --> 00:00:36,120
everywhere at James a rosin the a is

00:00:33,600 --> 00:00:41,730
important because James Rosen is a fox

00:00:36,120 --> 00:00:44,070
news contributor and I am NOT i'm here

00:00:41,730 --> 00:00:47,820
to talk to you about Carson you can find

00:00:44,070 --> 00:00:51,060
these slides on github as well as most

00:00:47,820 --> 00:00:55,650
of the content written out for review

00:00:51,060 --> 00:00:59,340
later an introduction about five years

00:00:55,650 --> 00:01:01,140
ago zendesk was born as a rails 1.2

00:00:59,340 --> 00:01:03,450
application it was a pretty standard

00:01:01,140 --> 00:01:06,750
application over the years we've

00:01:03,450 --> 00:01:10,670
upgraded it many times sometimes

00:01:06,750 --> 00:01:12,930
slightly less successfully than others

00:01:10,670 --> 00:01:15,930
over the years we've also added a lot of

00:01:12,930 --> 00:01:19,350
non rails services we started out with

00:01:15,930 --> 00:01:23,249
Sphinx for search we change that out to

00:01:19,350 --> 00:01:26,880
solar after a while we added eg a birdie

00:01:23,249 --> 00:01:30,649
for chat we switch that out to node we

00:01:26,880 --> 00:01:33,479
added rescue for background jobs and

00:01:30,649 --> 00:01:36,749
over the years the code base has grown a

00:01:33,479 --> 00:01:38,340
lot the red line is test the blue line

00:01:36,749 --> 00:01:40,049
is code so you can see that our

00:01:38,340 --> 00:01:43,319
engineers are pretty good about keeping

00:01:40,049 --> 00:01:46,020
our test coverage up so that's very good

00:01:43,319 --> 00:01:49,229
but over time when you have a single app

00:01:46,020 --> 00:01:54,380
like this grow your developer happiness

00:01:49,229 --> 00:01:54,380
starts high and drinks

00:01:54,940 --> 00:01:59,170
and the primary reason for this

00:01:57,610 --> 00:02:00,730
developer I guess there are two primary

00:01:59,170 --> 00:02:05,490
reasons for this developer unhappiness

00:02:00,730 --> 00:02:10,090
test time and interdependencies or

00:02:05,490 --> 00:02:14,040
dependency management so the first thing

00:02:10,090 --> 00:02:17,080
we took a stab at was the test time and

00:02:14,040 --> 00:02:20,530
Corey Haines had a great talk about a

00:02:17,080 --> 00:02:23,280
year and a half ago at gogi ruko where

00:02:20,530 --> 00:02:26,710
he talked about a fast test suite and he

00:02:23,280 --> 00:02:28,570
showed us the holy grail of fast testing

00:02:26,710 --> 00:02:30,490
he ran his whole rails app test suite in

00:02:28,570 --> 00:02:32,710
point three seconds or something it was

00:02:30,490 --> 00:02:34,480
great everybody who's wowed what it

00:02:32,710 --> 00:02:37,450
turns out he did was he just extracted

00:02:34,480 --> 00:02:40,320
all of his code from its dependencies on

00:02:37,450 --> 00:02:43,390
slow things like the database like rails

00:02:40,320 --> 00:02:47,050
and so then he could run his tests as a

00:02:43,390 --> 00:02:48,880
very pure isolated Ruby this is a change

00:02:47,050 --> 00:02:54,460
to your test but it's also a change to

00:02:48,880 --> 00:02:56,790
your code so it does make you write

00:02:54,460 --> 00:03:00,640
better code over time if you use a fast

00:02:56,790 --> 00:03:03,550
test-driven method you will come away

00:03:00,640 --> 00:03:05,200
with very nicely interconnected blocks

00:03:03,550 --> 00:03:08,290
of code that are easy to test and thus

00:03:05,200 --> 00:03:09,520
they are nice to have clients of we

00:03:08,290 --> 00:03:14,380
started out with this for a little while

00:03:09,520 --> 00:03:16,930
it went well but it wasn't enough we had

00:03:14,380 --> 00:03:18,550
many many lines of code and we couldn't

00:03:16,930 --> 00:03:20,080
get all of our test Suites over too fast

00:03:18,550 --> 00:03:22,870
tests and we were still running at an

00:03:20,080 --> 00:03:24,970
hour for a test suite and just a minute

00:03:22,870 --> 00:03:27,070
or two to run a single test just to boot

00:03:24,970 --> 00:03:29,440
up the rails process so we were still

00:03:27,070 --> 00:03:33,220
pretty pretty far down on that developer

00:03:29,440 --> 00:03:36,160
happiness trough we learned the hard way

00:03:33,220 --> 00:03:37,840
Conway's rule organizations that design

00:03:36,160 --> 00:03:40,030
systems are constrained to produce

00:03:37,840 --> 00:03:41,920
designs that are copies of the

00:03:40,030 --> 00:03:44,130
communication structures of these

00:03:41,920 --> 00:03:44,130
organizations

00:03:46,220 --> 00:03:50,840
so what we found out was if we wanted to

00:03:49,160 --> 00:03:52,400
have fast tests and we wanted to have

00:03:50,840 --> 00:03:56,090
individual components we had to have

00:03:52,400 --> 00:03:57,740
teams that looked like that if you want

00:03:56,090 --> 00:04:02,240
to break up your rails app break up your

00:03:57,740 --> 00:04:06,470
teams our first such project was called

00:04:02,240 --> 00:04:10,600
sea monster the CMS sea monster was a

00:04:06,470 --> 00:04:14,270
very classic rails to engine HTML pages

00:04:10,600 --> 00:04:16,579
nah no real API activity very little

00:04:14,270 --> 00:04:19,010
JavaScript not much in the way of assets

00:04:16,579 --> 00:04:21,709
or custom styling we just bootstrapped

00:04:19,010 --> 00:04:24,320
upon our existing infrastructure our

00:04:21,709 --> 00:04:26,300
admin interface and similar so we wrote

00:04:24,320 --> 00:04:28,100
this as a rails to engine the team was

00:04:26,300 --> 00:04:30,830
pretty separate it went very well it's

00:04:28,100 --> 00:04:32,450
still running in production today what

00:04:30,830 --> 00:04:35,300
we did learn from this though was that

00:04:32,450 --> 00:04:38,780
rails to is not very good at asset

00:04:35,300 --> 00:04:40,730
control for engines this is fixed in

00:04:38,780 --> 00:04:42,950
rails 3 the asset pipeline is really

00:04:40,730 --> 00:04:46,669
nice it handles engines well so if you

00:04:42,950 --> 00:04:49,669
drop in style sheets JavaScript images

00:04:46,669 --> 00:04:51,950
they just show up in your rails app and

00:04:49,669 --> 00:04:53,960
you can reference them directly in a

00:04:51,950 --> 00:04:55,820
class in a rails to you have to run a

00:04:53,960 --> 00:04:58,040
rake task to copy them in and it's kind

00:04:55,820 --> 00:04:59,720
of a nightmare to manage so when we got

00:04:58,040 --> 00:05:03,110
to our next project the zendesk app

00:04:59,720 --> 00:05:06,680
market we decided that it was time to

00:05:03,110 --> 00:05:08,810
get up to rails 3 it was a very

00:05:06,680 --> 00:05:11,360
JavaScript heavy app it's basically an

00:05:08,810 --> 00:05:15,020
API plus JavaScript clients there's

00:05:11,360 --> 00:05:17,660
almost no HTML pages to render so

00:05:15,020 --> 00:05:19,460
although it's a good fit for rails it's

00:05:17,660 --> 00:05:22,250
a good fit for sort of the API version

00:05:19,460 --> 00:05:25,430
of rails so rails to wasn't to be good

00:05:22,250 --> 00:05:27,850
we go for rails 3 so we build out a

00:05:25,430 --> 00:05:31,100
proof of concept of sindbis gaps and

00:05:27,850 --> 00:05:33,080
after I do that I go to Zaphod our head

00:05:31,100 --> 00:05:35,840
of operations not his real name but it

00:05:33,080 --> 00:05:38,270
would be cool if it were and I say hey

00:05:35,840 --> 00:05:42,650
Zaphod we've got this nifty new rails 3

00:05:38,270 --> 00:05:44,540
app we're ready to to launch how can we

00:05:42,650 --> 00:05:46,010
get it running in production what can I

00:05:44,540 --> 00:05:48,350
do to help you guys get it running and

00:05:46,010 --> 00:05:50,390
Zaphod looked at me like I had exactly

00:05:48,350 --> 00:05:53,300
the wrong number of heads we're not

00:05:50,390 --> 00:05:55,789
ready to provision mounted monitor and

00:05:53,300 --> 00:05:57,500
deploy an entire new rails 3 stack we're

00:05:55,789 --> 00:05:58,240
very comfortable with our rails to stack

00:05:57,500 --> 00:06:03,000
and

00:05:58,240 --> 00:06:07,479
that's it so here is where I may have

00:06:03,000 --> 00:06:10,270
misjudged Zaphod stress level and I said

00:06:07,479 --> 00:06:12,069
but Zaphod rails 3 is the way of the

00:06:10,270 --> 00:06:13,690
future multiple apps is the way of the

00:06:12,069 --> 00:06:15,190
future service-oriented architect

00:06:13,690 --> 00:06:17,020
architects single responsibility

00:06:15,190 --> 00:06:18,759
principle everything's going to be great

00:06:17,020 --> 00:06:23,590
if we have a thousand rails apps running

00:06:18,759 --> 00:06:26,919
in production he was not happy so

00:06:23,590 --> 00:06:32,470
meetings were held and coffee was drunk

00:06:26,919 --> 00:06:36,190
and Carson was born Carson is our

00:06:32,470 --> 00:06:42,509
compromise takeaway here is communicate

00:06:36,190 --> 00:06:42,509
and love your ops team what is Carson

00:06:42,630 --> 00:06:46,080
believe it with quote

00:06:47,969 --> 00:06:54,299
Carson is baby steps into so ax I

00:06:51,409 --> 00:06:56,099
managed to negotiate with the

00:06:54,299 --> 00:06:58,139
infrastructure team that we could have a

00:06:56,099 --> 00:07:00,360
rails to app and a rails 3 app but we

00:06:58,139 --> 00:07:02,549
wouldn't go any further than that we

00:07:00,360 --> 00:07:05,639
wouldn't have hundreds or even dozens of

00:07:02,549 --> 00:07:08,459
rails apps just to and and we could work

00:07:05,639 --> 00:07:11,129
from there I was happy with this so

00:07:08,459 --> 00:07:15,419
Carson is a rails 3 app that isn't a nap

00:07:11,129 --> 00:07:20,429
all it has is configuration gem file and

00:07:15,419 --> 00:07:23,369
some integration tests if you want to

00:07:20,429 --> 00:07:26,629
build a vertical feature a new feature

00:07:23,369 --> 00:07:29,669
in Zendesk you build a Carson engine so

00:07:26,629 --> 00:07:31,709
they the provisioning team builds a

00:07:29,669 --> 00:07:33,569
provisioning engine the email management

00:07:31,709 --> 00:07:35,879
team builds an email management engine

00:07:33,569 --> 00:07:37,799
so if you have a vertical feature you

00:07:35,879 --> 00:07:40,189
build an engine if you have some sort of

00:07:37,799 --> 00:07:42,629
cross-cutting concern logging or

00:07:40,189 --> 00:07:45,119
database internationalization all that

00:07:42,629 --> 00:07:47,610
sort of stuff those are classical gems

00:07:45,119 --> 00:07:50,339
and then the only code that goes in

00:07:47,610 --> 00:07:52,999
carson is initializers things to sort of

00:07:50,339 --> 00:07:52,999
set up the environment

00:07:57,900 --> 00:08:03,630
so did this work on what from one

00:08:01,650 --> 00:08:06,330
respect yes we have small test suites

00:08:03,630 --> 00:08:09,530
across multiple projects they run very

00:08:06,330 --> 00:08:12,810
fast people are pretty happy with those

00:08:09,530 --> 00:08:16,320
one extra nice thing is that each

00:08:12,810 --> 00:08:18,030
project only gets the CI build failure

00:08:16,320 --> 00:08:19,650
notifications for that project so you

00:08:18,030 --> 00:08:23,160
don't end up with a lot of noise across

00:08:19,650 --> 00:08:25,199
teams that's nice but we're not really

00:08:23,160 --> 00:08:26,910
running our tests in real environment

00:08:25,199 --> 00:08:29,639
we're running them in a very fake

00:08:26,910 --> 00:08:32,370
isolated environment and so you need

00:08:29,639 --> 00:08:34,919
some integration tests and this has been

00:08:32,370 --> 00:08:37,589
borne out by engines stepping on one

00:08:34,919 --> 00:08:39,990
another toes and I'll cover some how to

00:08:37,589 --> 00:08:43,800
not how to avoid that later but a few

00:08:39,990 --> 00:08:45,810
integration tests go a long way the next

00:08:43,800 --> 00:08:49,800
benefit is semantic versioning you have

00:08:45,810 --> 00:08:51,660
decoupled deploy schedules so I don't

00:08:49,800 --> 00:08:53,760
know if you've been in this scenario you

00:08:51,660 --> 00:08:56,130
develop a feature you merge it into

00:08:53,760 --> 00:08:58,110
master you're all excited for it to go

00:08:56,130 --> 00:09:00,420
out next thursday with the next release

00:08:58,110 --> 00:09:02,459
and somebody else merges but there's a

00:09:00,420 --> 00:09:04,950
bug QA holds up the deploy because

00:09:02,459 --> 00:09:07,440
somebody else's code now your code can't

00:09:04,950 --> 00:09:12,120
go out because there's conflict on

00:09:07,440 --> 00:09:15,000
somebody else's carson is nice because

00:09:12,120 --> 00:09:17,580
these engines are built as separate gems

00:09:15,000 --> 00:09:19,529
that are semantically versioned so you

00:09:17,580 --> 00:09:22,709
merge your stuff into master you bump

00:09:19,529 --> 00:09:24,330
the version you then redeploy carson

00:09:22,709 --> 00:09:27,209
with your updated version but you can

00:09:24,330 --> 00:09:28,890
deploy at will because everybody else's

00:09:27,209 --> 00:09:33,589
gems are locked to their current

00:09:28,890 --> 00:09:35,880
versions it's a really nice way to avoid

00:09:33,589 --> 00:09:38,570
coupling these deploy schedules if

00:09:35,880 --> 00:09:41,760
everybody can work on their own time if

00:09:38,570 --> 00:09:44,220
you want patch updates and you avoid you

00:09:41,760 --> 00:09:47,790
obey semantic versioning then it's as

00:09:44,220 --> 00:09:50,730
easily as bundle update my engine if you

00:09:47,790 --> 00:09:53,250
use the tilde operator then you'll just

00:09:50,730 --> 00:09:55,279
get patch updates to that engine and

00:09:53,250 --> 00:09:57,690
those can go out pretty much at will

00:09:55,279 --> 00:10:01,740
because they are intentionally don't

00:09:57,690 --> 00:10:03,270
have any functionality change it's a

00:10:01,740 --> 00:10:05,040
little Pam and painful to do this

00:10:03,270 --> 00:10:07,589
without an internal gem server so if

00:10:05,040 --> 00:10:10,170
you're going to try these baby steps get

00:10:07,589 --> 00:10:11,459
an internal gem server running if you're

00:10:10,170 --> 00:10:14,100
without an internal gem

00:10:11,459 --> 00:10:17,910
server you're constantly doing these get

00:10:14,100 --> 00:10:19,980
to a get URL or get hash in your gem

00:10:17,910 --> 00:10:21,509
file and you just have to be bumping

00:10:19,980 --> 00:10:23,790
those all the time you'll end up

00:10:21,509 --> 00:10:28,199
spending an hour a day on just a gem

00:10:23,790 --> 00:10:30,420
file the holy grail is to get here where

00:10:28,199 --> 00:10:33,240
our continuous deploy continuous

00:10:30,420 --> 00:10:37,410
integration server can basically run all

00:10:33,240 --> 00:10:40,499
of the patch updates and redeploy every

00:10:37,410 --> 00:10:42,959
15 minutes so every engine if it has

00:10:40,499 --> 00:10:44,699
patch deploys they go out and then if

00:10:42,959 --> 00:10:48,019
you want functionality deploys big

00:10:44,699 --> 00:10:53,009
version bumps you do those manually

00:10:48,019 --> 00:10:55,050
dependency management is fun this title

00:10:53,009 --> 00:10:57,329
type this talk was almost titled Carson

00:10:55,050 --> 00:10:59,579
because dependency management is fun you

00:10:57,329 --> 00:11:02,220
do find that when you're working on

00:10:59,579 --> 00:11:03,660
isolated teams that need to coordinate

00:11:02,220 --> 00:11:05,819
especially when they need to coordinate

00:11:03,660 --> 00:11:09,209
within a single run time you do have

00:11:05,819 --> 00:11:10,860
more meetings around dependencies in a

00:11:09,209 --> 00:11:12,300
classic version though you should have

00:11:10,860 --> 00:11:14,249
been having the same meetings you just

00:11:12,300 --> 00:11:15,959
probably weren't you would go into your

00:11:14,249 --> 00:11:18,629
gym file and update the gem and then you

00:11:15,959 --> 00:11:20,759
would hope that nothing breaks maybe you

00:11:18,629 --> 00:11:22,110
would run the tests and that would give

00:11:20,759 --> 00:11:23,399
you some indication that's nothing that

00:11:22,110 --> 00:11:27,149
nothing is breaking but that would be

00:11:23,399 --> 00:11:29,160
about it here the advantage is that the

00:11:27,149 --> 00:11:31,110
gem specs tell you who is relying on

00:11:29,160 --> 00:11:33,540
what versions and a little bit about why

00:11:31,110 --> 00:11:35,790
although still pretty limited

00:11:33,540 --> 00:11:37,649
information so it is pretty hard to

00:11:35,790 --> 00:11:40,110
break other people's code by just

00:11:37,649 --> 00:11:42,110
updating a dependency if we update JSON

00:11:40,110 --> 00:11:43,889
the provisioning team can't and

00:11:42,110 --> 00:11:46,619
provisioning team can't work with the

00:11:43,889 --> 00:11:49,009
current the new version of JSON it won't

00:11:46,619 --> 00:11:54,420
bundle and we won't be able to deploy it

00:11:49,009 --> 00:11:56,189
does mean more meetings and again

00:11:54,420 --> 00:11:58,290
without an internal gem server you end

00:11:56,189 --> 00:12:01,319
up with sort of more maintenance around

00:11:58,290 --> 00:12:04,920
your gem file in your gem spec so stand

00:12:01,319 --> 00:12:08,730
up an internal gem server another

00:12:04,920 --> 00:12:11,279
benefit is deployment so here you were

00:12:08,730 --> 00:12:13,799
very possibly deploying a classic big

00:12:11,279 --> 00:12:16,559
bowl of mud rails app with Capistrano

00:12:13,799 --> 00:12:19,829
you get the same thing here and whenever

00:12:16,559 --> 00:12:21,480
a new project joins or starts up they

00:12:19,829 --> 00:12:23,379
get free deployment they don't have to

00:12:21,480 --> 00:12:26,199
build their own deployment mechanisms

00:12:23,379 --> 00:12:27,699
just jump on Tom on top of Carson stick

00:12:26,199 --> 00:12:29,439
something in the gem file and they get

00:12:27,699 --> 00:12:31,720
deployed just like everybody else so

00:12:29,439 --> 00:12:36,099
that's a nice advantage over a real true

00:12:31,720 --> 00:12:39,249
so uh and you can add as many features

00:12:36,099 --> 00:12:40,839
as you can fit in that run time it does

00:12:39,249 --> 00:12:42,609
mean you can't scale them independently

00:12:40,839 --> 00:12:44,470
so if you have one service that receives

00:12:42,609 --> 00:12:46,569
a hundred requests a day in one server

00:12:44,470 --> 00:12:49,720
that receives a million requests a day

00:12:46,569 --> 00:12:53,999
they're running in the same vm and you

00:12:49,720 --> 00:12:53,999
just have to scale for the largest load

00:12:55,619 --> 00:13:00,699
one downside is that you're going to

00:12:57,909 --> 00:13:02,679
have one single central database you

00:13:00,699 --> 00:13:04,569
have a single app server so it really

00:13:02,679 --> 00:13:07,179
can't communicate to multiple databases

00:13:04,569 --> 00:13:08,589
there are some rails active record

00:13:07,179 --> 00:13:13,389
add-ons that will communicate to

00:13:08,589 --> 00:13:15,549
multiple databases it's tricky really

00:13:13,389 --> 00:13:17,379
here this is a downside against real so

00:13:15,549 --> 00:13:20,099
although it's no worse than what you're

00:13:17,379 --> 00:13:22,569
doing if you're going in this direction

00:13:20,099 --> 00:13:24,849
Thunderbolt Labs has a great essay about

00:13:22,569 --> 00:13:27,339
why single central databases are bad

00:13:24,849 --> 00:13:30,119
mostly results revolves around the idea

00:13:27,339 --> 00:13:32,499
of who is in charge of the schema if

00:13:30,119 --> 00:13:35,259
multiple services need to interact with

00:13:32,499 --> 00:13:37,269
the same tables or the same data there's

00:13:35,259 --> 00:13:42,819
really no way to know who is updating

00:13:37,269 --> 00:13:44,229
them at what time so on to some patterns

00:13:42,819 --> 00:13:48,759
and some anti-patterns if you're going

00:13:44,229 --> 00:13:51,359
to work with this stuff first is

00:13:48,759 --> 00:13:53,979
namespacing each engine gets a name

00:13:51,359 --> 00:13:58,239
provisioning for example it gets a

00:13:53,979 --> 00:14:00,239
database table prefix and oh a ruby

00:13:58,239 --> 00:14:03,309
prefix a database table prefix

00:14:00,239 --> 00:14:06,100
internationalization keys it has a set

00:14:03,309 --> 00:14:08,229
of routes for HTML pages a set of routes

00:14:06,100 --> 00:14:10,619
for assets and a set of reps for API

00:14:08,229 --> 00:14:13,929
endpoints and all this makes it easy to

00:14:10,619 --> 00:14:19,089
know who owns what part of what piece of

00:14:13,929 --> 00:14:20,829
functionality anti-pattern unexpected

00:14:19,089 --> 00:14:24,399
global state so we got bitten by this

00:14:20,829 --> 00:14:26,379
pretty early on there's a lot of global

00:14:24,399 --> 00:14:28,269
state in a rails app even before you

00:14:26,379 --> 00:14:30,399
introduce any so it's very easy to

00:14:28,269 --> 00:14:34,689
introduce global state Ruby classes or

00:14:30,399 --> 00:14:36,350
global any class methods are global but

00:14:34,689 --> 00:14:38,990
before you get to your code there

00:14:36,350 --> 00:14:41,210
rails and you've got I 8nn locale the

00:14:38,990 --> 00:14:43,160
back end the translation data the

00:14:41,210 --> 00:14:45,500
database schema the rack middleware the

00:14:43,160 --> 00:14:47,990
mime type mappings the list goes on it's

00:14:45,500 --> 00:14:50,300
very easy to run across global state in

00:14:47,990 --> 00:14:53,120
a rails app here's an example from our

00:14:50,300 --> 00:14:55,790
code base so the provisioning engine had

00:14:53,120 --> 00:14:58,520
an initializer that would set up a new

00:14:55,790 --> 00:15:01,430
internationalization backend for itself

00:14:58,520 --> 00:15:04,550
and it just added its own translation

00:15:01,430 --> 00:15:05,690
llamo files to the set but that meant

00:15:04,550 --> 00:15:08,870
that the next time we deployed the

00:15:05,690 --> 00:15:10,880
zendesk apps engine didn't have any

00:15:08,870 --> 00:15:15,740
translations because this was clobbering

00:15:10,880 --> 00:15:17,720
hours so the way to solve this is agree

00:15:15,740 --> 00:15:20,960
on a convention and then encode that

00:15:17,720 --> 00:15:22,700
convention as a gem don't just agree on

00:15:20,960 --> 00:15:26,330
it somebody's going to forget to do it

00:15:22,700 --> 00:15:28,490
so actually write code that expresses

00:15:26,330 --> 00:15:30,470
what you are agreeing on and then each

00:15:28,490 --> 00:15:33,590
engine or each engine that cares about

00:15:30,470 --> 00:15:34,910
that convention includes that and so

00:15:33,590 --> 00:15:38,020
when you want to change the convention

00:15:34,910 --> 00:15:43,070
then you have to update all of the gems

00:15:38,020 --> 00:15:45,080
so here the convention was something the

00:15:43,070 --> 00:15:47,600
convention we agreed upon was that each

00:15:45,080 --> 00:15:49,850
engine could register its own things but

00:15:47,600 --> 00:15:52,070
it couldn't overwrite the global it

00:15:49,850 --> 00:15:55,850
could only ask to be added to the list

00:15:52,070 --> 00:15:59,560
and we've encoded that as a Zendesk i18n

00:15:55,850 --> 00:16:02,210
gem and each engine just initializes

00:15:59,560 --> 00:16:04,670
itself its own internationalization and

00:16:02,210 --> 00:16:09,650
whatever we've written inside that gem

00:16:04,670 --> 00:16:13,160
handles how to arbitrate among gems so

00:16:09,650 --> 00:16:17,470
beware of global state as a bonus take

00:16:13,160 --> 00:16:17,470
away encode your conventions as gems a

00:16:17,530 --> 00:16:21,980
pattern activesupport notifications if

00:16:20,270 --> 00:16:23,930
you're working in rails 3 this is a

00:16:21,980 --> 00:16:31,390
great framework I hope everybody is

00:16:23,930 --> 00:16:34,100
using it you can get great cross domain

00:16:31,390 --> 00:16:38,800
notifications not cross HTTP domain but

00:16:34,100 --> 00:16:40,460
cross your your own modeling domain

00:16:38,800 --> 00:16:43,280
communication by using these

00:16:40,460 --> 00:16:44,329
notifications so every time an account

00:16:43,280 --> 00:16:46,489
is updated

00:16:44,329 --> 00:16:48,319
we announced that the account has been

00:16:46,489 --> 00:16:51,499
updated in anyone who cares can listen

00:16:48,319 --> 00:16:54,170
caching but also all sorts of other

00:16:51,499 --> 00:16:55,910
things that care about accounts so users

00:16:54,170 --> 00:16:58,459
for all of those accounts may get

00:16:55,910 --> 00:17:01,639
notices even better than this though is

00:16:58,459 --> 00:17:03,259
if you use very domain specific events

00:17:01,639 --> 00:17:05,779
so instead of just announcing that the

00:17:03,259 --> 00:17:08,240
account was changed announced that the

00:17:05,779 --> 00:17:10,699
ssl certificate was updated that way the

00:17:08,240 --> 00:17:15,289
people who care about ssl certificates

00:17:10,699 --> 00:17:17,870
don't have to parse into the the the

00:17:15,289 --> 00:17:20,360
object that's sent with the notification

00:17:17,870 --> 00:17:22,250
message and find out and the people who

00:17:20,360 --> 00:17:24,889
don't care about ssl certificate changes

00:17:22,250 --> 00:17:30,320
don't have to receive and then throw

00:17:24,889 --> 00:17:33,230
away a message if there is one big

00:17:30,320 --> 00:17:37,039
takeaway from this it is this

00:17:33,230 --> 00:17:40,940
anti-pattern shared mutable objects for

00:17:37,039 --> 00:17:42,830
those who were in the evented talk

00:17:40,940 --> 00:17:48,429
earlier and those who watched the

00:17:42,830 --> 00:17:51,110
keynote about parallelization p 312 n

00:17:48,429 --> 00:17:54,230
you know that shared mutable objects are

00:17:51,110 --> 00:17:55,490
a great way to commit a denial of

00:17:54,230 --> 00:17:58,100
service attack against your fellow

00:17:55,490 --> 00:18:02,990
programmers it's really easy to step on

00:17:58,100 --> 00:18:06,230
each other's toes avoid it so about a

00:18:02,990 --> 00:18:08,419
year ago reg Braithwaite wrote a great

00:18:06,230 --> 00:18:11,360
article called Williams master of the

00:18:08,419 --> 00:18:13,600
come from where he described a former

00:18:11,360 --> 00:18:17,120
co-worker who had a particularly

00:18:13,600 --> 00:18:20,899
ingenious form of dependency injection

00:18:17,120 --> 00:18:23,720
and decoupling this was Williams

00:18:20,899 --> 00:18:25,909
Williams is a classic rails app approach

00:18:23,720 --> 00:18:27,889
when you have a person that has many

00:18:25,909 --> 00:18:30,500
comments a comment belongs to a person

00:18:27,889 --> 00:18:33,350
each model knows about its own

00:18:30,500 --> 00:18:35,990
relationship to the other in a Williams

00:18:33,350 --> 00:18:38,630
rails app though he would analyze what

00:18:35,990 --> 00:18:40,610
parts of the app depended on others so

00:18:38,630 --> 00:18:42,200
the person system can exist alone but

00:18:40,610 --> 00:18:44,419
the commenting system can't exist

00:18:42,200 --> 00:18:49,419
without the person system so he would

00:18:44,419 --> 00:18:52,100
write this as this in the person module

00:18:49,419 --> 00:18:53,389
it would just know about people and in

00:18:52,100 --> 00:18:55,370
the commenting module it would know

00:18:53,389 --> 00:18:57,410
about both

00:18:55,370 --> 00:18:59,720
at first glance this seems like a really

00:18:57,410 --> 00:19:02,030
good fit for a Carson engine the engine

00:18:59,720 --> 00:19:03,380
that knows about people knows about

00:19:02,030 --> 00:19:05,260
people and the engine that knows about

00:19:03,380 --> 00:19:09,140
commenting knows about people and

00:19:05,260 --> 00:19:11,180
comment it turns out this is actually a

00:19:09,140 --> 00:19:13,040
really bad idea again it's an easy way

00:19:11,180 --> 00:19:15,830
to commit a denial of service attack

00:19:13,040 --> 00:19:18,410
against your fellow programmers if in

00:19:15,830 --> 00:19:22,070
the commenting module you monkey patch

00:19:18,410 --> 00:19:24,920
in a validation that isn't actually

00:19:22,070 --> 00:19:26,330
needed for other engines then you can

00:19:24,920 --> 00:19:29,150
prevent people from signing up to your

00:19:26,330 --> 00:19:30,230
site that's a pretty obvious one it's

00:19:29,150 --> 00:19:33,020
probably one that most people in this

00:19:30,230 --> 00:19:36,080
room wouldn't commit but a slightly more

00:19:33,020 --> 00:19:38,330
nefarious one is just an before save

00:19:36,080 --> 00:19:41,059
callback that could possibly fail using

00:19:38,330 --> 00:19:44,420
some third third party service or some

00:19:41,059 --> 00:19:47,600
other service of your own like an email

00:19:44,420 --> 00:19:50,330
notification service so if you had an

00:19:47,600 --> 00:19:53,150
email if you have a communication email

00:19:50,330 --> 00:19:55,030
communication engine you might try to

00:19:53,150 --> 00:19:57,770
monkey patch this into person and then

00:19:55,030 --> 00:20:01,309
blow up your sign ups when your email

00:19:57,770 --> 00:20:03,620
server goes down so the rule is if it's

00:20:01,309 --> 00:20:07,130
not your data and it's not your code you

00:20:03,620 --> 00:20:09,559
don't get to change it so one solution

00:20:07,130 --> 00:20:12,679
we've come up with is copies of model

00:20:09,559 --> 00:20:15,559
classes they're backed by the same

00:20:12,679 --> 00:20:18,530
database table but it's not your code

00:20:15,559 --> 00:20:20,840
and it's not your data so you're not

00:20:18,530 --> 00:20:23,570
allowed to change it so in the

00:20:20,840 --> 00:20:27,050
commenting engine you would have a

00:20:23,570 --> 00:20:28,580
version of people called authors it uses

00:20:27,050 --> 00:20:30,350
the same database table but it's

00:20:28,580 --> 00:20:32,929
read-only you can't write back to

00:20:30,350 --> 00:20:35,120
another person's table and that way you

00:20:32,929 --> 00:20:36,320
can read in their data you can build

00:20:35,120 --> 00:20:37,790
your own relationships with those

00:20:36,320 --> 00:20:40,220
objects and you're not monkey patching

00:20:37,790 --> 00:20:41,750
in monkey patching somebody else's code

00:20:40,220 --> 00:20:44,990
and you're not writing to their data

00:20:41,750 --> 00:20:47,780
this works pretty well it's it's a very

00:20:44,990 --> 00:20:49,760
good start let's look at the

00:20:47,780 --> 00:20:51,050
dependencies so we've got we're

00:20:49,760 --> 00:20:53,090
dependent on the fact that we're running

00:20:51,050 --> 00:20:55,100
against the same database as long as

00:20:53,090 --> 00:20:59,660
we're inside this Carson container

00:20:55,100 --> 00:21:01,580
that's fine we're depending on the fact

00:20:59,660 --> 00:21:04,130
that there's a people table and that has

00:21:01,580 --> 00:21:06,350
a primary key column called ID and those

00:21:04,130 --> 00:21:08,090
are all pretty stable dependencies so

00:21:06,350 --> 00:21:08,600
I'm alright with those if you start to

00:21:08,090 --> 00:21:10,670
get more

00:21:08,600 --> 00:21:12,290
dependencies like you want more of the

00:21:10,670 --> 00:21:14,690
columns from the people table you're

00:21:12,290 --> 00:21:17,210
doing more than just having something on

00:21:14,690 --> 00:21:19,400
to which to hook a relationship a

00:21:17,210 --> 00:21:21,260
belongs to relationship then you start

00:21:19,400 --> 00:21:23,300
to get more unstable because the people

00:21:21,260 --> 00:21:25,820
engine could change its database schemas

00:21:23,300 --> 00:21:27,230
since it owns those tables at any time

00:21:25,820 --> 00:21:28,850
and you have no idea what's going to

00:21:27,230 --> 00:21:30,590
happen if you will start loading in

00:21:28,850 --> 00:21:33,190
people and their roles and their

00:21:30,590 --> 00:21:35,870
permission sets and their permissions I

00:21:33,190 --> 00:21:40,100
would avoid you know this kind of a

00:21:35,870 --> 00:21:41,600
structure for that basically what it

00:21:40,100 --> 00:21:44,480
comes down to is you have an engine

00:21:41,600 --> 00:21:46,460
depending on another engine rather than

00:21:44,480 --> 00:21:51,110
an engine depending on a cross-cutting

00:21:46,460 --> 00:21:54,800
concern so slightly better we can have

00:21:51,110 --> 00:21:58,310
the people engine declare a public API

00:21:54,800 --> 00:21:59,990
that all the other engines can use they

00:21:58,310 --> 00:22:02,240
declare a public method called look up

00:21:59,990 --> 00:22:03,980
and it returns to you something that

00:22:02,240 --> 00:22:06,410
quacks like a person maybe it is a

00:22:03,980 --> 00:22:08,240
person that's been modified here that's

00:22:06,410 --> 00:22:10,160
what we're doing we're just returning an

00:22:08,240 --> 00:22:12,410
instance of person and we're marking it

00:22:10,160 --> 00:22:14,840
as read the read only but this API could

00:22:12,410 --> 00:22:18,110
be changed internally to make it more

00:22:14,840 --> 00:22:20,830
protected or add features or anything as

00:22:18,110 --> 00:22:24,140
long as we obey the contract of look up

00:22:20,830 --> 00:22:25,820
this is pretty good this is uh I would

00:22:24,140 --> 00:22:29,420
say this is a step better than sharing

00:22:25,820 --> 00:22:30,740
the database tables again we're

00:22:29,420 --> 00:22:33,860
depending on the fact that the engines

00:22:30,740 --> 00:22:35,300
are in the same container because to

00:22:33,860 --> 00:22:38,030
make that Ruby call you've got to make

00:22:35,300 --> 00:22:40,520
it in the inside the vm you're depending

00:22:38,030 --> 00:22:42,050
on the people person class and that it

00:22:40,520 --> 00:22:45,830
has a method look up a method called

00:22:42,050 --> 00:22:48,740
look up that takes an ID and those are

00:22:45,830 --> 00:22:51,020
all again pretty stable so I'm fine with

00:22:48,740 --> 00:22:53,000
those again though we have this sort of

00:22:51,020 --> 00:22:55,100
engine depending on engine it's calling

00:22:53,000 --> 00:22:58,760
directly into another engine instead of

00:22:55,100 --> 00:23:00,200
using a service layer the other problem

00:22:58,760 --> 00:23:01,820
is that Ruby doesn't have package

00:23:00,200 --> 00:23:03,320
privacy and this is the one point where

00:23:01,820 --> 00:23:08,380
i'm going to say I wish I were writing

00:23:03,320 --> 00:23:11,590
Java now we're going to say that again

00:23:08,380 --> 00:23:14,930
you could in the commenting engine say

00:23:11,590 --> 00:23:17,090
people person all nothing prevents you

00:23:14,930 --> 00:23:18,950
from doing that other than convention

00:23:17,090 --> 00:23:21,800
and this is what we want to avoid

00:23:18,950 --> 00:23:27,470
getting an actual writable version of

00:23:21,800 --> 00:23:29,300
somebody else's object the best thing is

00:23:27,470 --> 00:23:30,890
something I learned from I think some of

00:23:29,300 --> 00:23:32,960
the square engineers we're talking about

00:23:30,890 --> 00:23:35,360
this a little while ago before they

00:23:32,960 --> 00:23:37,700
write a service they write the client to

00:23:35,360 --> 00:23:38,720
the service so the very first thing they

00:23:37,700 --> 00:23:40,610
do when they're standing on a new

00:23:38,720 --> 00:23:43,700
feature is they write the API client

00:23:40,610 --> 00:23:46,340
maybe it's in Ruby maybe it's bash maybe

00:23:43,700 --> 00:23:48,770
it's just HTTP JavaScript and a web page

00:23:46,340 --> 00:23:51,800
whatever it is it defines what the

00:23:48,770 --> 00:23:54,410
service is going to be so when the

00:23:51,800 --> 00:23:56,330
people team is building their service

00:23:54,410 --> 00:23:58,640
the first thing they do is they build a

00:23:56,330 --> 00:24:02,240
service layer for that that all of the

00:23:58,640 --> 00:24:07,580
other gems can consume and this thing

00:24:02,240 --> 00:24:09,680
defines the person look up method the

00:24:07,580 --> 00:24:11,750
nice thing is that this lets you change

00:24:09,680 --> 00:24:14,390
the underlying implementation here we've

00:24:11,750 --> 00:24:19,000
changed it from memory look up to one

00:24:14,390 --> 00:24:23,780
that's an external service call / JSON

00:24:19,000 --> 00:24:25,220
this means that if we decide we want to

00:24:23,780 --> 00:24:26,930
go from Carson to a real service

00:24:25,220 --> 00:24:29,210
oriented architecture we can just

00:24:26,930 --> 00:24:32,660
extract the people service into its own

00:24:29,210 --> 00:24:35,900
runtime and as long as it has declared

00:24:32,660 --> 00:24:43,010
the client properly nobody else has to

00:24:35,900 --> 00:24:45,860
change any code so each feature builds a

00:24:43,010 --> 00:24:49,580
consumer gem and there are no engine to

00:24:45,860 --> 00:24:52,400
engine dependencies very good you also

00:24:49,580 --> 00:24:54,470
get semantic versioning so if the people

00:24:52,400 --> 00:24:57,050
engine decides it wants to change its

00:24:54,470 --> 00:25:00,320
API it changes the client along with it

00:24:57,050 --> 00:25:05,200
and all of the gems have to update if

00:25:00,320 --> 00:25:11,020
there are API changes public API changes

00:25:05,200 --> 00:25:13,490
so only modify your own code or data

00:25:11,020 --> 00:25:19,010
chapter 5 future

00:25:13,490 --> 00:25:21,650
which I'm going to lie it out Carson is

00:25:19,010 --> 00:25:24,170
no worse than a big ball of mud it's

00:25:21,650 --> 00:25:25,400
worse in some ways and why would you do

00:25:24,170 --> 00:25:28,130
it you would do it because it's a

00:25:25,400 --> 00:25:36,920
stepping stone to so ax and is it a

00:25:28,130 --> 00:25:39,710
stepping stone sort of Carson is a good

00:25:36,920 --> 00:25:41,990
way to think about how to start

00:25:39,710 --> 00:25:44,690
decoupling your application so if you

00:25:41,990 --> 00:25:47,510
have a big ball of mud right now I would

00:25:44,690 --> 00:25:49,070
say think about these slides think about

00:25:47,510 --> 00:25:50,780
doing it I'm not necessarily

00:25:49,070 --> 00:25:54,020
recommending that everybody rush out and

00:25:50,780 --> 00:25:55,720
build this architecture it has a number

00:25:54,020 --> 00:25:59,540
of drawbacks particularly around

00:25:55,720 --> 00:26:00,530
dependency management coordination but

00:25:59,540 --> 00:26:03,620
these are things that you're going to

00:26:00,530 --> 00:26:04,850
have trouble with either in a Carson

00:26:03,620 --> 00:26:06,380
like environment or a real so

00:26:04,850 --> 00:26:08,000
environment so I think it starts to

00:26:06,380 --> 00:26:13,220
raise the right questions as you're

00:26:08,000 --> 00:26:16,370
getting away from big bowl of mud it is

00:26:13,220 --> 00:26:19,300
easier for a team to move to this than

00:26:16,370 --> 00:26:22,580
it is to start extracting full services

00:26:19,300 --> 00:26:24,710
the one caveat is that it's may be easy

00:26:22,580 --> 00:26:26,420
to get stuck in this and if this is

00:26:24,710 --> 00:26:29,840
going to hold you back from real so I

00:26:26,420 --> 00:26:32,540
would avoid that but if it's going to

00:26:29,840 --> 00:26:35,929
help you get there I would use it this

00:26:32,540 --> 00:26:38,900
is a stepping stone I I hope we don't

00:26:35,929 --> 00:26:41,090
end up staying here for you know years

00:26:38,900 --> 00:26:44,120
months it's fine I'm happy with that

00:26:41,090 --> 00:26:46,660
it's gotten us some good games in terms

00:26:44,120 --> 00:26:48,710
of developer speed in terms of

00:26:46,660 --> 00:26:52,490
deployability I think there are a lot of

00:26:48,710 --> 00:26:57,710
good things here in the short term I

00:26:52,490 --> 00:26:59,690
work for Zendesk we are hiring and I've

00:26:57,710 --> 00:27:02,690
got a whole bunch of extra reading if

00:26:59,690 --> 00:27:06,020
you're interested all sorts of great

00:27:02,690 --> 00:27:08,230
stuff and I would like to open it up for

00:27:06,020 --> 00:27:08,230
questions

00:27:13,560 --> 00:27:18,780
how do we handle database migrations so

00:27:16,200 --> 00:27:21,120
in rails 3 this is really nice each

00:27:18,780 --> 00:27:25,170
engine can build can write its own

00:27:21,120 --> 00:27:29,100
migrations and then in Carson you or the

00:27:25,170 --> 00:27:31,890
the rails container you do rake your

00:27:29,100 --> 00:27:33,720
engine name migration install migrations

00:27:31,890 --> 00:27:35,970
and it will copy those migrations over

00:27:33,720 --> 00:27:39,270
into the host application which then

00:27:35,970 --> 00:27:40,920
runs them we internally at Zendesk have

00:27:39,270 --> 00:27:42,690
a little problem with this in with that

00:27:40,920 --> 00:27:44,730
we have the rails to application and the

00:27:42,690 --> 00:27:47,400
rails 3 application so it's hard to know

00:27:44,730 --> 00:27:49,050
who is in charge of the migrations we've

00:27:47,400 --> 00:27:51,300
just settled that those all go into the

00:27:49,050 --> 00:27:53,070
rails to but if you have a single big

00:27:51,300 --> 00:27:54,990
ball of mud that's already on rails 3

00:27:53,070 --> 00:27:59,070
this is really easy this is a no-brainer

00:27:54,990 --> 00:28:01,530
for rails 3 app for rails to you have to

00:27:59,070 --> 00:28:03,600
copy in those migrations manually I

00:28:01,530 --> 00:28:06,270
believe someone has written a gem that

00:28:03,600 --> 00:28:07,830
will do that for you just sort of

00:28:06,270 --> 00:28:10,320
backported the functionality from rails

00:28:07,830 --> 00:28:12,980
3 but i would have to find it if you're

00:28:10,320 --> 00:28:12,980
interested let me know

00:28:24,800 --> 00:28:29,030
so the question is how do you decide

00:28:26,960 --> 00:28:35,180
which pieces to break off first where do

00:28:29,030 --> 00:28:37,370
you go for services so I think for me

00:28:35,180 --> 00:28:40,160
the best answer is let your tests guide

00:28:37,370 --> 00:28:43,250
you find out what's very hard to test

00:28:40,160 --> 00:28:45,560
and try to write tests for it and as you

00:28:43,250 --> 00:28:48,200
try to write tests for it it will tell

00:28:45,560 --> 00:28:51,140
you what what a real client would like

00:28:48,200 --> 00:28:54,020
out of that service so a test is just

00:28:51,140 --> 00:28:56,210
any other client and anything that has a

00:28:54,020 --> 00:29:02,950
good API for tests has a good API for

00:28:56,210 --> 00:29:07,430
other clients by and large look for

00:29:02,950 --> 00:29:11,360
things that I can be offloaded or

00:29:07,430 --> 00:29:13,280
delayed so if you were in Zach Holman's

00:29:11,360 --> 00:29:15,170
talk earlier he talked about how at

00:29:13,280 --> 00:29:17,090
github they have a button that says

00:29:15,170 --> 00:29:20,630
download a zip file archive of this

00:29:17,090 --> 00:29:22,370
project that doesn't really fit with the

00:29:20,630 --> 00:29:25,160
rest of the rendering of the web page

00:29:22,370 --> 00:29:27,680
you don't need to rebuild zip files for

00:29:25,160 --> 00:29:29,090
because it's so rarely used so there

00:29:27,680 --> 00:29:31,000
that's another good service it's

00:29:29,090 --> 00:29:33,740
something that can be done sort of

00:29:31,000 --> 00:29:37,340
offline separately from the regular

00:29:33,740 --> 00:29:39,890
rails app so things that are hard to

00:29:37,340 --> 00:29:44,450
test things that have a very different

00:29:39,890 --> 00:29:47,840
performance criteria things that have a

00:29:44,450 --> 00:29:49,640
very different usage criteria so at

00:29:47,840 --> 00:29:51,530
zendesk we have sort of three major

00:29:49,640 --> 00:29:54,560
categories of users we have the end

00:29:51,530 --> 00:29:57,080
users who are our customers customers we

00:29:54,560 --> 00:30:00,140
have them in huge numbers visiting the

00:29:57,080 --> 00:30:02,540
site each one only have performs a few

00:30:00,140 --> 00:30:06,020
requests per session they'll check out a

00:30:02,540 --> 00:30:10,360
ticket read through some latest comments

00:30:06,020 --> 00:30:13,250
and comment back then we have agents who

00:30:10,360 --> 00:30:15,320
you know vary widely in scope we have

00:30:13,250 --> 00:30:16,910
some mom and pops that just do a few

00:30:15,320 --> 00:30:18,950
tickets a day but we have agents who are

00:30:16,910 --> 00:30:19,940
in their 20 you know teams of agents

00:30:18,950 --> 00:30:21,350
that are in there twenty-four/seven

00:30:19,940 --> 00:30:23,990
someone who's working there for eight

00:30:21,350 --> 00:30:25,670
hours in a row and that's a very

00:30:23,990 --> 00:30:28,460
different performance characteristic and

00:30:25,670 --> 00:30:30,440
then we have admins who pop in and out

00:30:28,460 --> 00:30:32,600
just to configure so we sort of have

00:30:30,440 --> 00:30:34,520
three different products we have the end

00:30:32,600 --> 00:30:37,570
user product the agent product and the

00:30:34,520 --> 00:30:40,380
administration or settings product

00:30:37,570 --> 00:30:45,330
and those makes for some pretty good

00:30:40,380 --> 00:30:47,740
divisions so where it's painful to test

00:30:45,330 --> 00:30:49,000
where you have different performance and

00:30:47,740 --> 00:30:56,220
where you have different usage

00:30:49,000 --> 00:30:56,220
characteristics anything else yeah

00:31:00,299 --> 00:31:12,779
yeah so we have a small handful of

00:31:06,610 --> 00:31:17,409
engines in rails 3 we have I would say

00:31:12,779 --> 00:31:19,630
maybe three or four features in rails

00:31:17,409 --> 00:31:24,009
three and we have probably on order of

00:31:19,630 --> 00:31:27,460
30 to 50 features in rails two depending

00:31:24,009 --> 00:31:29,440
on how you break up a feature I think

00:31:27,460 --> 00:31:31,299
our strategy right now is to upgrade the

00:31:29,440 --> 00:31:34,570
classic app to rails three and then sort

00:31:31,299 --> 00:31:36,250
of merge these rather than break pieces

00:31:34,570 --> 00:31:37,720
off of rails to and move them over to

00:31:36,250 --> 00:31:40,269
the rails three but the nice thing about

00:31:37,720 --> 00:31:42,730
this is that at any point if we decide

00:31:40,269 --> 00:31:45,879
we want to have more services each of

00:31:42,730 --> 00:31:49,690
these engines can just be stood up as an

00:31:45,879 --> 00:31:53,320
independent rail service so in rails 3

00:31:49,690 --> 00:31:54,610
an engine is sorry a rails app is an

00:31:53,320 --> 00:31:57,179
engine if you were to go into the

00:31:54,610 --> 00:32:00,669
console and you say my application dot

00:31:57,179 --> 00:32:03,580
ancestors rails engine would be one of

00:32:00,669 --> 00:32:05,860
them so it's really easy to take an

00:32:03,580 --> 00:32:10,960
engine and upgrade it to a rails app you

00:32:05,860 --> 00:32:13,120
just add a config folder your

00:32:10,960 --> 00:32:14,500
notifications would cease to work so you

00:32:13,120 --> 00:32:16,149
would need you would then need to have

00:32:14,500 --> 00:32:18,149
your service layer have a better

00:32:16,149 --> 00:32:21,700
notifications you know something like

00:32:18,149 --> 00:32:25,809
zeromq or some things to do cross vm

00:32:21,700 --> 00:32:28,110
communications notifications that's a

00:32:25,809 --> 00:32:28,110
good point

00:32:28,660 --> 00:32:36,850
who else nothing all right

00:32:48,350 --> 00:32:52,700
so I think the thing that I've heard

00:32:49,880 --> 00:32:54,799
most people talk about lately was in

00:32:52,700 --> 00:32:57,470
Zendesk part of the business model is

00:32:54,799 --> 00:33:00,490
you can build background sort of

00:32:57,470 --> 00:33:04,400
processors that will act upon tickets as

00:33:00,490 --> 00:33:06,860
agents automatically called automations

00:33:04,400 --> 00:33:09,049
there's also target triggers which

00:33:06,860 --> 00:33:11,750
happen sort of in an invented model

00:33:09,049 --> 00:33:14,960
rather than a timed model and those are

00:33:11,750 --> 00:33:16,520
two things that to an earlier point have

00:33:14,960 --> 00:33:19,520
very different performance and usage

00:33:16,520 --> 00:33:21,620
characteristics than the website so

00:33:19,520 --> 00:33:24,230
those might be good candidates for for

00:33:21,620 --> 00:33:25,610
breaking out also again the admin

00:33:24,230 --> 00:33:27,950
interface would be a good candidate for

00:33:25,610 --> 00:33:29,960
breaking out so I think the rules that i

00:33:27,950 --> 00:33:32,510
said earlier are exactly what we've been

00:33:29,960 --> 00:33:34,909
looking at and we're always looking for

00:33:32,510 --> 00:33:38,210
opportunities to find a service that

00:33:34,909 --> 00:33:39,770
makes that is a good fit for for

00:33:38,210 --> 00:33:42,140
something external of course there's

00:33:39,770 --> 00:33:43,580
also the argument of if you have

00:33:42,140 --> 00:33:45,559
something that really needs to run on a

00:33:43,580 --> 00:33:47,870
different kind of run time you know we

00:33:45,559 --> 00:33:51,380
run our chat on node because there isn't

00:33:47,870 --> 00:33:55,580
a really solid evented framework that we

00:33:51,380 --> 00:33:56,900
had the skill set for in Ruby so that

00:33:55,580 --> 00:33:59,110
was a piece that really is a separate

00:33:56,900 --> 00:33:59,110
service

00:34:03,360 --> 00:34:11,330
and that nope all right well that's all

00:34:09,000 --> 00:34:11,330
I've got

00:34:25,520 --> 00:34:27,580

YouTube URL: https://www.youtube.com/watch?v=q0DmmLDJ-vQ


