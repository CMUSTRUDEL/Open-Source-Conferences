Title: Message in a Bottle by Konstantin Haase
Publication date: 2020-01-28
Playlist: Aloha RubyConf 2012
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGfe/
Captions: 
	00:00:14,660 --> 00:00:24,480
hi everybody can you hear me perfect

00:00:18,560 --> 00:00:28,680
okay so I going to give my talk message

00:00:24,480 --> 00:00:32,930
in a bottle so here it goes Ruby 18 is

00:00:28,680 --> 00:00:38,250
slow because it's interpreted surprise

00:00:32,930 --> 00:00:45,540
Ruby 19 is interpreted to thanks any

00:00:38,250 --> 00:00:48,840
questions okay i'm konstantine this is

00:00:45,540 --> 00:00:50,790
my insanely long twitter handle you're

00:00:48,840 --> 00:00:52,200
welcome to follow me it's actually it

00:00:50,790 --> 00:00:55,079
just seems long it's actually not too

00:00:52,200 --> 00:00:57,600
bad it's Constantine until here like my

00:00:55,079 --> 00:01:03,090
first name and then hase it's my last

00:00:57,600 --> 00:01:08,479
name and on github so you guys probably

00:01:03,090 --> 00:01:13,670
know peer hub it's the sticker company

00:01:08,479 --> 00:01:17,659
turns out they also do code hosting and

00:01:13,670 --> 00:01:21,450
on their code hosting platform I am r KH

00:01:17,659 --> 00:01:23,100
you might know me from the last time you

00:01:21,450 --> 00:01:31,950
did a Google image search for bike

00:01:23,100 --> 00:01:35,100
shedding and my face popped up I work

00:01:31,950 --> 00:01:40,439
for a company / open source project

00:01:35,100 --> 00:01:48,389
called Travis CI who in here has not

00:01:40,439 --> 00:01:51,090
heard of Travis CI ok so you too we do

00:01:48,389 --> 00:01:53,639
continuous integration for open source

00:01:51,090 --> 00:01:58,880
project for nearly 25,000 open source

00:01:53,639 --> 00:02:02,609
projects now we also now have service

00:01:58,880 --> 00:02:05,849
for private project on if you have them

00:02:02,609 --> 00:02:09,149
on github we can run your tests just

00:02:05,849 --> 00:02:11,700
grab me after this talk we obviously

00:02:09,149 --> 00:02:14,400
will charge for the service that is how

00:02:11,700 --> 00:02:17,400
we try to finance the work on the open

00:02:14,400 --> 00:02:20,310
source project and if you're willing to

00:02:17,400 --> 00:02:22,590
sign up before we go public then I can

00:02:20,310 --> 00:02:26,460
give you a sweet coupon so just talk to

00:02:22,590 --> 00:02:33,540
me this is our berlin-based team

00:02:26,460 --> 00:02:37,890
the stache one of our sponsors is agile

00:02:33,540 --> 00:02:39,990
animal and it's also thanks to them that

00:02:37,890 --> 00:02:42,270
I'm actually able to speak here they

00:02:39,990 --> 00:02:44,550
paid for my travels otherwise I would be

00:02:42,270 --> 00:02:48,060
sitting in rainy Berlin right now way

00:02:44,550 --> 00:02:52,350
colder and having to work on Travis

00:02:48,060 --> 00:02:54,990
instead of giving some fun talks when I

00:02:52,350 --> 00:02:57,750
when I edit that slide I actually had to

00:02:54,990 --> 00:03:04,130
have to use the google image search for

00:02:57,750 --> 00:03:06,690
agile animal stuff like that comes up

00:03:04,130 --> 00:03:10,860
highly recommend that there are many

00:03:06,690 --> 00:03:15,300
agile animals out there okay so let's

00:03:10,860 --> 00:03:17,700
get to the talk I do a lot of chitchat

00:03:15,300 --> 00:03:21,660
before the talk because when I go up and

00:03:17,700 --> 00:03:24,630
talk I get nervous and so to come down

00:03:21,660 --> 00:03:39,690
myself what I do is I wonder what would

00:03:24,630 --> 00:03:45,120
Aaron Patterson do okay so but this talk

00:03:39,690 --> 00:03:48,870
is actually about Ruby especially about

00:03:45,120 --> 00:03:52,530
Ruby internals and well what I want to

00:03:48,870 --> 00:03:55,740
really focus on is some core aspects of

00:03:52,530 --> 00:04:01,280
all the Ruby implementations that have

00:03:55,740 --> 00:04:05,850
to do with performance and bear with me

00:04:01,280 --> 00:04:10,110
it might be that some stuff I show on my

00:04:05,850 --> 00:04:11,790
sides is not obvious right away or you

00:04:10,110 --> 00:04:16,260
don't have to understand all the code

00:04:11,790 --> 00:04:17,730
I'll show C++ code C code bytecode you

00:04:16,260 --> 00:04:20,850
don't have to get all of that it's

00:04:17,730 --> 00:04:25,430
important that you get like the general

00:04:20,850 --> 00:04:27,390
picture of what it's going on here so I

00:04:25,430 --> 00:04:29,040
already said I going to talk about

00:04:27,390 --> 00:04:31,410
different Ruby implementations any

00:04:29,040 --> 00:04:35,430
guesses as to how many Ruby

00:04:31,410 --> 00:04:40,790
implementations there are the screen

00:04:35,430 --> 00:04:40,790
numbers 28 okay

00:04:42,210 --> 00:04:49,030
55-51 okay you guys are good I gave the

00:04:46,360 --> 00:04:55,540
talk and Barcelona and they were going

00:04:49,030 --> 00:04:59,950
like 58 they're actually I think it's 59

00:04:55,540 --> 00:05:02,770
or something I found including stuff

00:04:59,950 --> 00:05:05,290
like Ruby motion or hot rod robe is

00:05:02,770 --> 00:05:09,700
actually cool that's a implementation of

00:05:05,290 --> 00:05:11,440
the Ruby VM in JavaScript so you compile

00:05:09,700 --> 00:05:18,070
your Ruby to bytecode and then run it in

00:05:11,440 --> 00:05:19,900
a browser it's by co EG i think going

00:05:18,070 --> 00:05:25,090
chiefs asada the guy who is also behind

00:05:19,900 --> 00:05:27,400
the java Ruby VM I'm going to focus on

00:05:25,090 --> 00:05:29,440
the two large ones which are the two I

00:05:27,400 --> 00:05:30,700
would that are the three large ones

00:05:29,440 --> 00:05:33,880
which are the three Ruby implementations

00:05:30,700 --> 00:05:39,280
that I would personally consider if I

00:05:33,880 --> 00:05:43,420
going to deploy a rails app Ruby 19 or

00:05:39,280 --> 00:05:48,520
the coming Ruby 20 JRuby and Rubinius

00:05:43,420 --> 00:05:51,610
and what I want to look at is how they

00:05:48,520 --> 00:05:53,770
make the method dispatch fast because it

00:05:51,610 --> 00:05:55,450
turns out when you run Ruby what you're

00:05:53,770 --> 00:05:59,590
doing all the times actually doing a

00:05:55,450 --> 00:06:02,830
method dispatch so for MRI we're going

00:05:59,590 --> 00:06:05,500
to look at method dispatch and execution

00:06:02,830 --> 00:06:07,810
in general for Rubinius we're going to

00:06:05,500 --> 00:06:09,580
look at in line care system and for

00:06:07,810 --> 00:06:11,470
JRuby we're going to look at invoke

00:06:09,580 --> 00:06:13,600
dynamic this doesn't mean that only

00:06:11,470 --> 00:06:15,640
those implementations do those things

00:06:13,600 --> 00:06:17,980
obviously all the implementations do

00:06:15,640 --> 00:06:21,550
method dispatch all the implementations

00:06:17,980 --> 00:06:23,620
do some sort of caching etc etc and the

00:06:21,550 --> 00:06:26,920
code we going to look at is this nice

00:06:23,620 --> 00:06:29,530
code example it's really handy I hereby

00:06:26,920 --> 00:06:32,800
release this as public domain you may

00:06:29,530 --> 00:06:35,290
use this and what it does is actually

00:06:32,800 --> 00:06:39,100
gives you a deep fault class the checks

00:06:35,290 --> 00:06:42,270
if the ultimate answer is 42 or whatever

00:06:39,100 --> 00:06:47,440
your pulse in here and it accepts both

00:06:42,270 --> 00:06:50,050
integers and strings and we're going to

00:06:47,440 --> 00:06:51,889
look especially at this one line always

00:06:50,050 --> 00:06:55,490
under the assumption that

00:06:51,889 --> 00:06:57,409
42 is passed in his argument so one

00:06:55,490 --> 00:07:00,080
thing you have to know about all those

00:06:57,409 --> 00:07:03,949
Ruby implementations is they just love

00:07:00,080 --> 00:07:06,379
bytecode so let's look at the bytecode

00:07:03,949 --> 00:07:09,919
for just this statement while you value

00:07:06,379 --> 00:07:13,310
2s on so all the by coats they're

00:07:09,919 --> 00:07:15,259
actually like encoding and the

00:07:13,310 --> 00:07:17,150
instructions but you can also write them

00:07:15,259 --> 00:07:19,879
as the instruction names kind of the

00:07:17,150 --> 00:07:22,729
assembler language of the bytecode so

00:07:19,879 --> 00:07:26,300
for MRI this was would actually look

00:07:22,729 --> 00:07:29,900
like this get value and then sent to us

00:07:26,300 --> 00:07:32,569
with no arguments to it for Rubinius it

00:07:29,900 --> 00:07:34,490
would look like this push local zero

00:07:32,569 --> 00:07:38,629
because it's the first local variable we

00:07:34,490 --> 00:07:40,789
have and for JRuby depending on the

00:07:38,629 --> 00:07:43,400
jruby version and the JVM version you're

00:07:40,789 --> 00:07:45,560
on it might look something like this

00:07:43,400 --> 00:07:49,069
with some parts missing here there and

00:07:45,560 --> 00:07:51,650
over there and when you look at that you

00:07:49,069 --> 00:07:57,529
might feel like I have no idea what I'm

00:07:51,650 --> 00:08:02,449
doing best thing is the shoes you see

00:07:57,529 --> 00:08:04,159
that so let's pick up a little and you

00:08:02,449 --> 00:08:05,689
might already know that you might not

00:08:04,159 --> 00:08:07,520
depending on if you've played with

00:08:05,689 --> 00:08:10,370
implementing programming languages and

00:08:07,520 --> 00:08:12,139
general a programming language or in the

00:08:10,370 --> 00:08:14,629
Ruby case especially it works like this

00:08:12,139 --> 00:08:17,539
you start with the source code which is

00:08:14,629 --> 00:08:19,539
just a text stream that goes through the

00:08:17,539 --> 00:08:22,639
parser that generates a parse tree and

00:08:19,539 --> 00:08:27,770
the parse tree is just a tree in memory

00:08:22,639 --> 00:08:30,349
like plus 11 you might know that from CS

00:08:27,770 --> 00:08:32,630
if you took it and then you can

00:08:30,349 --> 00:08:35,839
interpret that directly which will

00:08:32,630 --> 00:08:39,440
basically walk the tree and send out CPU

00:08:35,839 --> 00:08:41,810
instructions which is what Ruby 18 does

00:08:39,440 --> 00:08:46,490
for instance or you could generate a

00:08:41,810 --> 00:08:48,920
bytecode from that and then interpret

00:08:46,490 --> 00:08:51,110
that by code which basically is a big

00:08:48,920 --> 00:08:53,779
while loop that get the next bite and

00:08:51,110 --> 00:08:55,910
then get the see what instruction that

00:08:53,779 --> 00:08:59,779
is rid of some more bites if needed and

00:08:55,910 --> 00:09:03,769
again execute CPU instructions which is

00:08:59,779 --> 00:09:04,899
what 19 always does or you could take

00:09:03,769 --> 00:09:07,509
the bytecode

00:09:04,899 --> 00:09:09,100
from that by code generated machine code

00:09:07,509 --> 00:09:11,379
which is basically the same as byte code

00:09:09,100 --> 00:09:13,600
except the part of the system that

00:09:11,379 --> 00:09:16,470
understands the bytes and reads and more

00:09:13,600 --> 00:09:22,059
bytes is no longer software by your CPU

00:09:16,470 --> 00:09:27,879
and so that machine code equals CPU

00:09:22,059 --> 00:09:30,519
instructions and the general plan one

00:09:27,879 --> 00:09:36,429
like we are the BM and we have to do

00:09:30,519 --> 00:09:39,610
this past this part down here so general

00:09:36,429 --> 00:09:42,429
plan we have is we have to find a method

00:09:39,610 --> 00:09:46,720
and then we have to execute a method but

00:09:42,429 --> 00:09:50,350
we want to do that fast so how do we

00:09:46,720 --> 00:09:52,720
speed that up well we can find the

00:09:50,350 --> 00:09:55,329
method faster and we can execute the

00:09:52,720 --> 00:09:59,319
method faster as easy as that isn't it

00:09:55,329 --> 00:10:01,119
amazing they're actually tricks for

00:09:59,319 --> 00:10:04,689
doing that for finding faster we can do

00:10:01,119 --> 00:10:06,730
inline caches or cold side caches we can

00:10:04,689 --> 00:10:11,980
do look up caches which is what MRI is

00:10:06,730 --> 00:10:15,490
doing we can do in lining go into that

00:10:11,980 --> 00:10:18,399
later on and well then for executing

00:10:15,490 --> 00:10:19,990
faster we can reduce the operations that

00:10:18,399 --> 00:10:23,379
is actually a feature that's coming in

00:10:19,990 --> 00:10:26,499
MRI so instead of going the loop around

00:10:23,379 --> 00:10:28,120
three times for taking that or two times

00:10:26,499 --> 00:10:30,399
for taking value and then sending to us

00:10:28,120 --> 00:10:33,550
via can could be an operation that does

00:10:30,399 --> 00:10:36,339
take value and send s so to reduce the

00:10:33,550 --> 00:10:39,639
interpretation overhead it can do just

00:10:36,339 --> 00:10:42,339
in time compilation and most importantly

00:10:39,639 --> 00:10:44,410
we can speed up search faster search

00:10:42,339 --> 00:10:45,939
equals faster execution was of the time

00:10:44,410 --> 00:10:47,709
because you're just going to call

00:10:45,939 --> 00:10:55,540
another method that's again being looked

00:10:47,709 --> 00:10:58,839
at ok let's look at MRI first of all the

00:10:55,540 --> 00:11:02,619
search one way you can search for a

00:10:58,839 --> 00:11:04,420
method is by asking for the RB method

00:11:02,619 --> 00:11:07,089
entry that's actually a see method that

00:11:04,420 --> 00:11:10,600
you can call it's a from the public Ruby

00:11:07,089 --> 00:11:13,660
API this one will call RB method entry

00:11:10,600 --> 00:11:16,480
without cash unless it has cashed in the

00:11:13,660 --> 00:11:18,320
lookup cash what method actually to find

00:11:16,480 --> 00:11:23,720
and what I mean by finding a method

00:11:18,320 --> 00:11:25,820
is I have the object and the name of the

00:11:23,720 --> 00:11:28,130
method and I want to find that piece of

00:11:25,820 --> 00:11:30,830
byte code that I now have to execute and

00:11:28,130 --> 00:11:32,540
in the end it will end up in search

00:11:30,830 --> 00:11:34,580
method which is actually a pretty clean

00:11:32,540 --> 00:11:36,530
method and if you want to hack on Ruby

00:11:34,580 --> 00:11:40,120
that's a nice method to play with and

00:11:36,530 --> 00:11:43,910
just see what happens this is the method

00:11:40,120 --> 00:11:46,580
so the argument is the class which if

00:11:43,910 --> 00:11:47,900
the object has a singleton class and the

00:11:46,580 --> 00:11:50,090
argument will be the singer in class

00:11:47,900 --> 00:11:54,470
otherwise it will be the proper class

00:11:50,090 --> 00:11:56,920
and ID is the identifier basically see

00:11:54,470 --> 00:12:00,950
version of the symbol the method name

00:11:56,920 --> 00:12:02,740
and whatever basically will do is a will

00:12:00,950 --> 00:12:05,450
loop through the inheritance chain all

00:12:02,740 --> 00:12:11,020
the like the super class of the class

00:12:05,450 --> 00:12:14,570
etc etc including all the modules and

00:12:11,020 --> 00:12:21,410
look up if in the method table of their

00:12:14,570 --> 00:12:25,040
class there is a method entry and if the

00:12:21,410 --> 00:12:26,900
class at some point is null Neal then we

00:12:25,040 --> 00:12:28,670
reach the end of the inheritance chain

00:12:26,900 --> 00:12:32,510
and still haven't found it in return 0

00:12:28,670 --> 00:12:36,470
and otherwise we already found it so we

00:12:32,510 --> 00:12:38,900
have it down here and return it now we

00:12:36,470 --> 00:12:43,460
have to speed that up we have to run the

00:12:38,900 --> 00:12:47,330
method we have to execute it at some

00:12:43,460 --> 00:12:49,010
point you will end up there different

00:12:47,330 --> 00:12:51,380
ways of executing a method once you get

00:12:49,010 --> 00:12:55,010
ahold of it but at some point you will

00:12:51,380 --> 00:12:58,430
end up at an internal method called vm

00:12:55,010 --> 00:13:00,620
called 0 which takes a ton of arguments

00:12:58,430 --> 00:13:05,240
really not important the general

00:13:00,620 --> 00:13:08,330
structure is here has the vm loop the vm

00:13:05,240 --> 00:13:10,850
loop is not a while instead it's a

00:13:08,330 --> 00:13:13,850
switch which actually had a lot of

00:13:10,850 --> 00:13:15,590
points as nested switches which is kind

00:13:13,850 --> 00:13:17,600
of weird getting this method is really

00:13:15,590 --> 00:13:21,410
really long so it kind of cut out a lot

00:13:17,600 --> 00:13:23,870
of stuff and what it has all over the

00:13:21,410 --> 00:13:25,209
place is a go to again which is

00:13:23,870 --> 00:13:31,509
basically implementing the

00:13:25,209 --> 00:13:37,600
the loop and what you see here is if you

00:13:31,509 --> 00:13:42,129
have an instruction will actually vm xik

00:13:37,600 --> 00:13:45,300
that instruction which is now a real

00:13:42,129 --> 00:13:47,709
bytecode instruction so how does it know

00:13:45,300 --> 00:13:49,689
what to execute when it sees that

00:13:47,709 --> 00:13:52,179
instruction it looks at AB in an

00:13:49,689 --> 00:13:54,279
instruction manual it's actually a file

00:13:52,179 --> 00:13:57,639
in there that's called instructions def

00:13:54,279 --> 00:14:00,399
I think same goes for Rubinius where you

00:13:57,639 --> 00:14:03,550
have defined if i see the following

00:14:00,399 --> 00:14:05,860
instruction executes the following code

00:14:03,550 --> 00:14:11,019
it actually looks like this if you see

00:14:05,860 --> 00:14:13,240
an instruction called send fetch the

00:14:11,019 --> 00:14:15,730
class search for the method again will

00:14:13,240 --> 00:14:18,600
trigger search which is why speeding up

00:14:15,730 --> 00:14:22,709
search will speed of execution and then

00:14:18,600 --> 00:14:29,829
execute the method that is being called

00:14:22,709 --> 00:14:33,910
ok who's still awake let's look at

00:14:29,829 --> 00:14:37,860
Rubinius the nice thing about Rubinius

00:14:33,910 --> 00:14:41,490
is you can play with all that from Ruby

00:14:37,860 --> 00:14:45,610
you have the same structure you just saw

00:14:41,490 --> 00:14:49,119
with C exposed as Ruby objects every

00:14:45,610 --> 00:14:51,309
module has a method table and that

00:14:49,119 --> 00:14:55,119
method table has buckets and those

00:14:51,309 --> 00:14:57,160
packets contain compiled code and so you

00:14:55,119 --> 00:15:00,279
could implement the search for the

00:14:57,160 --> 00:15:01,959
method or in Ruby idiomatic the same

00:15:00,279 --> 00:15:04,199
code we just saw on search method would

00:15:01,959 --> 00:15:07,119
be something like this you get the

00:15:04,199 --> 00:15:11,439
object singleton class and you don't

00:15:07,119 --> 00:15:13,779
have the method right now and as long as

00:15:11,439 --> 00:15:16,569
it's basically the same code with the

00:15:13,779 --> 00:15:18,939
wire as long as there is a class and we

00:15:16,569 --> 00:15:23,439
haven't found the method at check-in the

00:15:18,939 --> 00:15:25,089
lookup table for the method and continue

00:15:23,439 --> 00:15:26,949
with the direct superclass you can say

00:15:25,089 --> 00:15:31,899
super classy because there would skip

00:15:26,949 --> 00:15:33,579
included modules and then what they will

00:15:31,899 --> 00:15:35,439
give you is actually something called

00:15:33,579 --> 00:15:36,050
compiled code the compiled code incense

00:15:35,439 --> 00:15:40,630
and you can

00:15:36,050 --> 00:15:43,220
she play with that so if you look up

00:15:40,630 --> 00:15:45,820
ultimate answer and the method table of

00:15:43,220 --> 00:15:49,160
deep thought and ask it for its method

00:15:45,820 --> 00:15:51,649
you can decode the method which will

00:15:49,160 --> 00:15:53,930
give you this you can look at the

00:15:51,649 --> 00:15:55,910
opcodes which will give you this which

00:15:53,930 --> 00:15:58,640
is basically a representation of the

00:15:55,910 --> 00:16:01,579
bytes so those will be as bites on the

00:15:58,640 --> 00:16:03,290
byte code stream which can also be

00:16:01,579 --> 00:16:04,670
written to a file and then executed

00:16:03,290 --> 00:16:07,640
directly from there and you can check

00:16:04,670 --> 00:16:11,690
out the literals which are 2 s 42 and

00:16:07,640 --> 00:16:16,070
equals equals let's take let's take a

00:16:11,690 --> 00:16:19,399
close look at that so I just rearranged

00:16:16,070 --> 00:16:21,769
it up here are the literals the locals

00:16:19,399 --> 00:16:23,540
there the bytes and then if you group

00:16:21,769 --> 00:16:25,279
the bytes in wherever there's an

00:16:23,540 --> 00:16:27,410
instruction and we can actually see

00:16:25,279 --> 00:16:31,820
what's going on so the first bite on the

00:16:27,410 --> 00:16:34,640
stream is 20 now Rubinius looks up what

00:16:31,820 --> 00:16:36,800
is trendy what's the opcode 20 and it

00:16:34,640 --> 00:16:40,339
turns out 20 is push local and push

00:16:36,800 --> 00:16:42,589
local takes one argument so Rubinius is

00:16:40,339 --> 00:16:45,649
going to read the next byte and that is

00:16:42,589 --> 00:16:47,899
0 so it's actually push local 0 meaning

00:16:45,649 --> 00:16:50,450
push the first local so we're going to

00:16:47,899 --> 00:16:52,550
check what are the locals well our first

00:16:50,450 --> 00:16:56,720
locals 42 so we're going to push for the

00:16:52,550 --> 00:16:59,959
two other stack next instruction is sin

00:16:56,720 --> 00:17:04,010
stack to s 0 so we actually send to s2

00:16:59,959 --> 00:17:06,910
what other is on this deck and rip so we

00:17:04,010 --> 00:17:09,709
pop off what's on the stack and push on

00:17:06,910 --> 00:17:12,679
this on to the stack the result of that

00:17:09,709 --> 00:17:16,520
method call so its 42 as a string then

00:17:12,679 --> 00:17:19,400
we push literal number one which is the

00:17:16,520 --> 00:17:22,970
second literal for the two onto the

00:17:19,400 --> 00:17:25,339
stick so 42 42 is on the stick then we

00:17:22,970 --> 00:17:27,740
do a string DUP to whatever we pushed on

00:17:25,339 --> 00:17:30,800
the stack this is because theres

00:17:27,740 --> 00:17:32,990
forty-two a string hard coded in in the

00:17:30,800 --> 00:17:37,280
code and if someone would modify that we

00:17:32,990 --> 00:17:39,950
say replace then they would modify it

00:17:37,280 --> 00:17:42,410
for all subsequent calls unless there

00:17:39,950 --> 00:17:43,820
would be a do pet happening so all the

00:17:42,410 --> 00:17:47,330
Ruby implementations have to do that

00:17:43,820 --> 00:17:50,120
there and then here is an opcode that up

00:17:47,330 --> 00:17:53,480
I is equals equals fall out of cases and

00:17:50,120 --> 00:17:55,549
it will actually take those pop those

00:17:53,480 --> 00:17:58,490
two off the stick and pushed you onto it

00:17:55,549 --> 00:18:00,590
and then 11 is the bytecode for return

00:17:58,490 --> 00:18:07,159
which will just pop off the last thing

00:18:00,590 --> 00:18:09,590
on a stick now since this is a ruby

00:18:07,159 --> 00:18:11,929
object and this is a real Ruby object

00:18:09,590 --> 00:18:14,090
not just the whole thing is not just a

00:18:11,929 --> 00:18:16,640
representation for reflection on to it

00:18:14,090 --> 00:18:19,399
that Ruby object is actually used for

00:18:16,640 --> 00:18:22,399
execution so you can modify it and those

00:18:19,399 --> 00:18:24,639
modification will take effect and that

00:18:22,399 --> 00:18:27,110
is actually what Rubinius is using

00:18:24,639 --> 00:18:29,120
internally for implementing in line

00:18:27,110 --> 00:18:30,860
Kesha so what you could do now is you

00:18:29,120 --> 00:18:33,440
could replace in the literal you could

00:18:30,860 --> 00:18:37,010
take the compiled method at runtime and

00:18:33,440 --> 00:18:39,860
for instance replace 42 and the literals

00:18:37,010 --> 00:18:43,639
tuple it's not an array it's a tuple so

00:18:39,860 --> 00:18:47,570
like a fixed size array and replace it

00:18:43,639 --> 00:18:50,809
with 23 and then from there on only 23

00:18:47,570 --> 00:18:52,850
will be the ultimate answer you can do

00:18:50,809 --> 00:18:57,860
the same with the bytes so you could

00:18:52,850 --> 00:19:00,529
replace you could add something just

00:18:57,860 --> 00:19:02,419
remove the 11 add some bytes that do

00:19:00,529 --> 00:19:04,789
something else and then at the 11 again

00:19:02,419 --> 00:19:07,909
and then modify the return value that

00:19:04,789 --> 00:19:11,360
way for instance and Rubinius actually

00:19:07,909 --> 00:19:17,179
uses that internally to implement inline

00:19:11,360 --> 00:19:20,600
caches so if we take a look at the bytes

00:19:17,179 --> 00:19:23,480
that with their representation we have

00:19:20,600 --> 00:19:26,750
push local zero cents tech to s 0 in

00:19:23,480 --> 00:19:29,870
there and the 2's is the symbol object

00:19:26,750 --> 00:19:32,600
and what Rubinius does the first time it

00:19:29,870 --> 00:19:35,779
sees the code in the execution in the BM

00:19:32,600 --> 00:19:38,360
it replaces the 2's with an inline cash

00:19:35,779 --> 00:19:41,179
and then the next time I will just ask

00:19:38,360 --> 00:19:43,820
that when it encounters sense deck it

00:19:41,179 --> 00:19:48,080
will just ask the inline cash for the

00:19:43,820 --> 00:19:53,570
method to be executed and the inline

00:19:48,080 --> 00:19:56,360
cash holds the reference directly to the

00:19:53,570 --> 00:19:59,929
compiled code to the bytes of the

00:19:56,360 --> 00:20:00,500
compiled code so when an object comes in

00:19:59,929 --> 00:20:03,950
and it's

00:20:00,500 --> 00:20:06,590
sent us on to that object it doesn't

00:20:03,950 --> 00:20:09,740
actually have to go through the look up

00:20:06,590 --> 00:20:11,870
again it might already have the code at

00:20:09,740 --> 00:20:16,100
hand and just say oh cool here's the

00:20:11,870 --> 00:20:19,340
code just run this and what did what it

00:20:16,100 --> 00:20:23,540
actually has to do is it has to verify

00:20:19,340 --> 00:20:25,520
that the code it has at hand is the

00:20:23,540 --> 00:20:28,700
correct code to execute that's the big

00:20:25,520 --> 00:20:31,610
issue with late binding if you would

00:20:28,700 --> 00:20:33,830
have aesthetically typed language

00:20:31,610 --> 00:20:36,260
without late binding then you could just

00:20:33,830 --> 00:20:37,970
at compile-time decide what code to call

00:20:36,260 --> 00:20:43,450
somewhere which is actually what's

00:20:37,970 --> 00:20:47,270
happening when you compile a code so it

00:20:43,450 --> 00:20:50,840
holds a reference through to the code to

00:20:47,270 --> 00:20:55,880
execute and it does do a type check so

00:20:50,840 --> 00:20:57,440
every class gets a type I'm not sure

00:20:55,880 --> 00:21:00,890
what they are but it's basically just an

00:20:57,440 --> 00:21:04,730
integer so for array the type might be

00:21:00,890 --> 00:21:08,030
17 and then when the object comes in it

00:21:04,730 --> 00:21:11,600
just checks is that object type 17 and

00:21:08,030 --> 00:21:13,760
now if it's not an array or a sub-clause

00:21:11,600 --> 00:21:15,830
or if it has a singer and clouds and the

00:21:13,760 --> 00:21:18,800
type will be something else it knows oh

00:21:15,830 --> 00:21:21,320
I don't have the code for this so I have

00:21:18,800 --> 00:21:22,910
to do a look up again and now the nice

00:21:21,320 --> 00:21:25,190
thing about why it's not just checking

00:21:22,910 --> 00:21:27,500
is this array but is this like 17 or

00:21:25,190 --> 00:21:29,620
whatever is that when you add a method

00:21:27,500 --> 00:21:31,850
to array override a method to array or

00:21:29,620 --> 00:21:34,730
remove a method to array the type of

00:21:31,850 --> 00:21:36,650
array will change because it might

00:21:34,730 --> 00:21:40,640
actually be that the method you have to

00:21:36,650 --> 00:21:43,280
execute has changed and the nice thing

00:21:40,640 --> 00:21:45,530
about this is that the check can that

00:21:43,280 --> 00:21:48,530
way actually be reduced to a single CPU

00:21:45,530 --> 00:21:50,630
instruction so the overhead compared to

00:21:48,530 --> 00:21:54,620
doing a full look up is really really

00:21:50,630 --> 00:21:59,170
low it's really really cheap another

00:21:54,620 --> 00:22:04,370
cool thing is that it can actually

00:21:59,170 --> 00:22:06,550
change what it's pointing to the machine

00:22:04,370 --> 00:22:08,680
code

00:22:06,550 --> 00:22:10,180
called machine code it's an odd machine

00:22:08,680 --> 00:22:13,090
code at that point it just means that

00:22:10,180 --> 00:22:15,100
these are instructions the naming gets a

00:22:13,090 --> 00:22:16,750
bit confusing sometimes and they just

00:22:15,100 --> 00:22:20,830
have been renamed this used to be

00:22:16,750 --> 00:22:25,870
compiled method and this used to be just

00:22:20,830 --> 00:22:30,400
code or something anyway why would I

00:22:25,870 --> 00:22:34,110
want to change it because when you

00:22:30,400 --> 00:22:40,990
change it you can get specialized method

00:22:34,110 --> 00:22:44,290
so as I said the default thing is I have

00:22:40,990 --> 00:22:47,080
the cash byte code one cool thing is it

00:22:44,290 --> 00:22:49,060
can keep the code with breakpoints you

00:22:47,080 --> 00:22:52,720
know how when you turn on the debugger

00:22:49,060 --> 00:22:56,710
on MRI everything gets slow that's not

00:22:52,720 --> 00:22:58,450
the case in Rubinius because they can

00:22:56,710 --> 00:23:00,190
have all the optimized code and all the

00:22:58,450 --> 00:23:02,800
methods except the one you set a

00:23:00,190 --> 00:23:05,740
breakpoint in there it uses to the

00:23:02,800 --> 00:23:08,620
debuggable a version and and then

00:23:05,740 --> 00:23:12,990
execute that and if you step through it

00:23:08,620 --> 00:23:16,030
into another method by a just stepping

00:23:12,990 --> 00:23:18,580
it will actually take the unoptimized

00:23:16,030 --> 00:23:20,710
version so you can go step through step

00:23:18,580 --> 00:23:23,290
to the step but as soon as you say

00:23:20,710 --> 00:23:25,000
continue it will run all the optimized

00:23:23,290 --> 00:23:26,590
versions again and there will be no

00:23:25,000 --> 00:23:29,920
overhead for running with the debugger

00:23:26,590 --> 00:23:32,770
which is also why you can to running

00:23:29,920 --> 00:23:34,930
Rubinius process attached over network

00:23:32,770 --> 00:23:38,650
and start debugging it which you cannot

00:23:34,930 --> 00:23:42,430
do an MRI and you can specialize it for

00:23:38,650 --> 00:23:47,920
arguments you can basically in line byte

00:23:42,430 --> 00:23:50,170
code or change branching etc etc to run

00:23:47,920 --> 00:23:54,730
faster for certain arguments that come

00:23:50,170 --> 00:23:57,210
in and well you can also did it so if a

00:23:54,730 --> 00:23:59,680
method has been called often enough

00:23:57,210 --> 00:24:01,870
Rubinius will actually compile it to

00:23:59,680 --> 00:24:03,790
machine code and then keep a reference

00:24:01,870 --> 00:24:05,620
to the machine code the thing is that

00:24:03,790 --> 00:24:07,930
compiling to machine code is actually

00:24:05,620 --> 00:24:10,660
expensive which is why you don't do it

00:24:07,930 --> 00:24:12,940
all the time and what the machine code

00:24:10,660 --> 00:24:14,950
is you're compiling to depends on the

00:24:12,940 --> 00:24:17,200
whole system state which is why it also

00:24:14,950 --> 00:24:18,080
makes no sense to compile to machine

00:24:17,200 --> 00:24:21,080
code in a

00:24:18,080 --> 00:24:23,779
or not a lot of sense with the way we

00:24:21,080 --> 00:24:25,159
develop ruby applications um for

00:24:23,779 --> 00:24:30,919
compiling to machine code it uses

00:24:25,159 --> 00:24:34,210
something called llvm besides having a

00:24:30,919 --> 00:24:37,580
cool logo llvm is really really useful

00:24:34,210 --> 00:24:43,250
so our Rubinius has to do is take the

00:24:37,580 --> 00:24:47,870
Rubinius bytecode translate it into what

00:24:43,250 --> 00:24:50,840
is called llvm immediate representation

00:24:47,870 --> 00:24:52,880
llvm stands for low-level virtual

00:24:50,840 --> 00:24:56,450
machine even though it is not a virtual

00:24:52,880 --> 00:25:00,710
machine in the sense we like robinus is

00:24:56,450 --> 00:25:04,100
so it doesn't actually execute interpret

00:25:00,710 --> 00:25:07,519
the the immediate and representation

00:25:04,100 --> 00:25:11,059
instead it always compiles it to native

00:25:07,519 --> 00:25:14,260
code and it sets two advantages it can

00:25:11,059 --> 00:25:16,220
run a ton of optimizations on the

00:25:14,260 --> 00:25:18,889
intermediate representation it can

00:25:16,220 --> 00:25:21,230
inline stuff and do basically all the

00:25:18,889 --> 00:25:23,450
optimizations revenus in the sense that

00:25:21,230 --> 00:25:29,769
Rubinius is doing on the bytecode it can

00:25:23,450 --> 00:25:31,490
do on the IR and also it the

00:25:29,769 --> 00:25:33,409
intermediate representation is

00:25:31,490 --> 00:25:36,649
independent of your CPU architecture and

00:25:33,409 --> 00:25:39,159
llvm knows all the CPU architectures and

00:25:36,649 --> 00:25:41,779
knows tricks to optimize for them so

00:25:39,159 --> 00:25:46,519
Rubinius doesn't actually have to care

00:25:41,779 --> 00:25:49,460
about int'l instructions about arm

00:25:46,519 --> 00:25:55,690
instructions etc etc that's all taken

00:25:49,460 --> 00:25:55,690
care of by lvm okay

00:25:56,670 --> 00:26:09,190
who's still awake jruby I assume you

00:26:07,780 --> 00:26:10,720
might not want to hear that much about

00:26:09,190 --> 00:26:15,400
jruby or otherwise you would be at the

00:26:10,720 --> 00:26:17,350
other talk anyways let's still talk

00:26:15,400 --> 00:26:19,600
about Jay so the nice thing about the

00:26:17,350 --> 00:26:21,880
jruby chart being at the same talk at

00:26:19,600 --> 00:26:26,950
the same time as my chart is Charlie

00:26:21,880 --> 00:26:28,810
can't call on my slides is this

00:26:26,950 --> 00:26:35,230
I'm sorry for saying on

00:26:28,810 --> 00:26:37,960
television okay so when you were

00:26:35,230 --> 00:26:40,090
following the bars around jruby you

00:26:37,960 --> 00:26:45,340
might have heard of something called

00:26:40,090 --> 00:26:50,500
invoke dynamic who in here has heard of

00:26:45,340 --> 00:26:52,710
invoke dynamic raise your hand okay who

00:26:50,500 --> 00:26:55,390
of these that just raised their hand

00:26:52,710 --> 00:27:07,360
feels comfortable in explaining how

00:26:55,390 --> 00:27:10,090
invoke dynamic works ah ok Matt so let's

00:27:07,360 --> 00:27:14,850
look at the bytecode or snippets from

00:27:10,090 --> 00:27:18,240
the bytecode that JRuby generates on

00:27:14,850 --> 00:27:21,220
with or without invoke dynamic so

00:27:18,240 --> 00:27:23,790
without invoke dynamic the bytecode

00:27:21,220 --> 00:27:27,820
looks something like this you have the

00:27:23,790 --> 00:27:32,710
invoke virtual instruction so in work

00:27:27,820 --> 00:27:35,320
virtual is basically the set of all one

00:27:32,710 --> 00:27:38,490
of the set method sends instruction of

00:27:35,320 --> 00:27:41,050
Java of the Java world there's also

00:27:38,490 --> 00:27:43,930
invoke static but since those are

00:27:41,050 --> 00:27:47,470
virtual methods we are calling usually

00:27:43,930 --> 00:27:52,750
invoke virtual is the default send a

00:27:47,470 --> 00:27:55,180
method to something so but JRuby cannot

00:27:52,750 --> 00:27:59,260
use that with the actual method name

00:27:55,180 --> 00:28:01,150
which is 2's in that case instead it

00:27:59,260 --> 00:28:07,420
needs to implement its own look up so

00:28:01,150 --> 00:28:09,220
what it does is send to the current so

00:28:07,420 --> 00:28:11,200
the current object is the current ex

00:28:09,220 --> 00:28:13,240
the object on the stack is the current

00:28:11,200 --> 00:28:18,070
execution context whatever something

00:28:13,240 --> 00:28:20,549
like that and it just says get called

00:28:18,070 --> 00:28:23,940
side one which is an object that

00:28:20,549 --> 00:28:27,970
encapsulate the method the Ruby method

00:28:23,940 --> 00:28:30,400
look up and so that will end up on the

00:28:27,970 --> 00:28:33,700
stick and we'll push some arguments like

00:28:30,400 --> 00:28:36,610
the method name arguments that are given

00:28:33,700 --> 00:28:39,130
the thread context onto it and then it

00:28:36,610 --> 00:28:45,370
really call a call on that object with

00:28:39,130 --> 00:28:48,880
these arguments and it should be pretty

00:28:45,370 --> 00:28:52,030
obvious that if now the JVM these

00:28:48,880 --> 00:28:54,159
optimizations similar to the

00:28:52,030 --> 00:28:56,650
optimizations Rubinius does while it

00:28:54,159 --> 00:29:01,330
optimizes is the get cold side warm and

00:28:56,650 --> 00:29:05,679
the call not actually the Ruby method

00:29:01,330 --> 00:29:07,860
dispatch so the nice thing is that the

00:29:05,679 --> 00:29:10,840
JVM seven gives us invoke dynamic and

00:29:07,860 --> 00:29:14,590
there are changes the first call just

00:29:10,840 --> 00:29:18,640
goes away and the second call gets

00:29:14,590 --> 00:29:21,520
replaced by call to s and invoke would

00:29:18,640 --> 00:29:24,250
invoke dynamic basically says instead of

00:29:21,520 --> 00:29:26,020
doing a job I method look up just I

00:29:24,250 --> 00:29:28,929
going to give you some object it's going

00:29:26,020 --> 00:29:30,940
to take care of all that trust me and

00:29:28,929 --> 00:29:36,720
the are you going to give you some

00:29:30,940 --> 00:29:39,340
object trust me part looks like this so

00:29:36,720 --> 00:29:43,620
the first three arguments are actually

00:29:39,340 --> 00:29:51,090
the same arguments as our past to invoke

00:29:43,620 --> 00:29:51,090
virtual calls so those are actually the

00:29:51,539 --> 00:29:57,610
the three things we pushed onto the

00:29:54,580 --> 00:30:00,640
stack it's the threat context for the

00:29:57,610 --> 00:30:04,510
current execution it's the object that

00:30:00,640 --> 00:30:08,830
we send the method to and some other

00:30:04,510 --> 00:30:10,450
context object feel free to bother

00:30:08,830 --> 00:30:12,070
Charlie about this it's actually not

00:30:10,450 --> 00:30:15,780
that important for understanding what's

00:30:12,070 --> 00:30:20,799
going on and the return value is again a

00:30:15,780 --> 00:30:22,240
ruby object and then the new thing with

00:30:20,799 --> 00:30:32,230
invoke dynamic is

00:30:22,240 --> 00:30:35,500
is that you pass a linker into it and at

00:30:32,230 --> 00:30:40,630
the end arguments there will be passed

00:30:35,500 --> 00:30:42,220
to the method itself let's look at the

00:30:40,630 --> 00:30:45,790
linker the rest is really not that

00:30:42,220 --> 00:30:50,260
interesting the linker did three

00:30:45,790 --> 00:30:55,059
different things it does a bootstrap it

00:30:50,260 --> 00:30:57,730
has a guard and it has a fallback and it

00:30:55,059 --> 00:31:03,820
points to the bytecode of another JVM

00:30:57,730 --> 00:31:07,240
method so the first time the invoked

00:31:03,820 --> 00:31:09,480
dynamic instruction is encountered JVM

00:31:07,240 --> 00:31:16,179
will actually call the bootstrap method

00:31:09,480 --> 00:31:21,220
and so at the point in the bytecode the

00:31:16,179 --> 00:31:24,570
JVM will have a reference to a call site

00:31:21,220 --> 00:31:26,980
a call site is in that case basically a

00:31:24,570 --> 00:31:30,880
JVM method so we'll have a reference to

00:31:26,980 --> 00:31:33,730
a JVM method and that's not there in the

00:31:30,880 --> 00:31:35,020
beginning because the JVM doesn't know

00:31:33,730 --> 00:31:38,530
where it should come from because the

00:31:35,020 --> 00:31:41,800
JVM doesn't know the dispatch so it's

00:31:38,530 --> 00:31:44,140
going to call the bootstrap for the

00:31:41,800 --> 00:31:46,120
linker to set everything up and in the

00:31:44,140 --> 00:31:48,510
case of JRuby the bootstrap bill

00:31:46,120 --> 00:31:54,970
internally called the fall back because

00:31:48,510 --> 00:31:58,059
what's usually the case is if the JVM

00:31:54,970 --> 00:32:01,330
should encounter it again and there's no

00:31:58,059 --> 00:32:03,520
method that is part of that no no byte

00:32:01,330 --> 00:32:06,429
code that will call the fall back to

00:32:03,520 --> 00:32:09,250
fetch the bytecode or to do something

00:32:06,429 --> 00:32:11,770
else it doesn't actually have to set up

00:32:09,250 --> 00:32:13,300
the method but if you don't set up the

00:32:11,770 --> 00:32:19,540
method all the optimizations won't

00:32:13,300 --> 00:32:22,420
happen so assumingly it looks up the

00:32:19,540 --> 00:32:25,090
method links the method again called the

00:32:22,420 --> 00:32:27,790
bytecode executed all is good next time

00:32:25,090 --> 00:32:33,400
it encounters that point again and calls

00:32:27,790 --> 00:32:36,010
to s it could just run the bytecode now

00:32:33,400 --> 00:32:39,820
or optimized on it the way Rubinius

00:32:36,010 --> 00:32:41,560
and in other crazy ways to but it might

00:32:39,820 --> 00:32:44,520
actually be that it's currently pointing

00:32:41,560 --> 00:32:47,200
at the wrong bytecode so what it does is

00:32:44,520 --> 00:32:49,470
basically the same thing Reuben Eustace

00:32:47,200 --> 00:32:52,960
internally it calls the guard and says

00:32:49,470 --> 00:32:55,870
dear God or dear linker please check up

00:32:52,960 --> 00:32:57,940
everything still ok and then J will be

00:32:55,870 --> 00:33:00,310
just like Rubinius again there's a type

00:32:57,940 --> 00:33:04,270
check and it says yep everything's

00:33:00,310 --> 00:33:06,790
alright and if it doesn't say

00:33:04,270 --> 00:33:08,980
everything's alright then the reference

00:33:06,790 --> 00:33:13,570
to the bytecode will be removed and the

00:33:08,980 --> 00:33:15,520
fallback will be called and that way jvm

00:33:13,570 --> 00:33:19,380
doesn't have to know anything about Ruby

00:33:15,520 --> 00:33:24,430
dispatch and can still do all the crazy

00:33:19,380 --> 00:33:28,320
optimizations in there so update JVM and

00:33:24,430 --> 00:33:28,320
JRuby and get a free performance boost

00:33:30,420 --> 00:33:39,460
ok so to summarize things we want to do

00:33:36,580 --> 00:33:41,230
if we implement a ruby if we implement

00:33:39,460 --> 00:33:42,490
Ruby or if you want to contribute or

00:33:41,230 --> 00:33:44,980
want to write your own language or just

00:33:42,490 --> 00:33:46,750
want to see why some code is so why some

00:33:44,980 --> 00:33:48,220
code is fast why some ruby

00:33:46,750 --> 00:33:51,790
implementation is better for some

00:33:48,220 --> 00:33:56,650
scenarios than another is reducing CPU

00:33:51,790 --> 00:33:59,890
instructions reducing jumps like you can

00:33:56,650 --> 00:34:03,250
now inline code and there will reduce

00:33:59,890 --> 00:34:05,880
jumps both on the bytecode level and

00:34:03,250 --> 00:34:08,860
even on the machine code level because

00:34:05,880 --> 00:34:12,070
CPUs can optimize for subsequent calls

00:34:08,860 --> 00:34:16,030
but not that well for actual jump

00:34:12,070 --> 00:34:18,820
instructions and at the same time doing

00:34:16,030 --> 00:34:22,750
all that which is C compiler can also do

00:34:18,820 --> 00:34:25,990
but without breaking late binding and we

00:34:22,750 --> 00:34:29,230
have a few tools at our hand amongst

00:34:25,990 --> 00:34:34,360
them cashing in lining the

00:34:29,230 --> 00:34:39,899
guards and remember fast lookup usually

00:34:34,360 --> 00:34:39,899
equals fast execution thanks

00:34:52,970 --> 00:34:55,030

YouTube URL: https://www.youtube.com/watch?v=1MKsTx_pBKw


