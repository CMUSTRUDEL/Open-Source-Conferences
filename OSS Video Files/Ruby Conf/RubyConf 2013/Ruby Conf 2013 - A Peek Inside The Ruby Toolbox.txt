Title: Ruby Conf 2013 - A Peek Inside The Ruby Toolbox
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Loren Segal 

You can usually judge the maturity of a programming language ecosystem by the breadth of its tooling. For example, Java has a plethora of IDEs that each, in turn, have many well maintained refactoring and code quality plugins (like FindBugs and PMD). C/C++ is equally well established in this space. Even JavaScript is becoming well represented, with a number of static code analyzers and language supersets (like Dart and TypeScript) aimed at improving tooling in the language. But where is Ruby in all of this? This talk will shed some light on the existing tools available in the Ruby world as well as some new tools just starting to be built out in the areas of static analysis, formal verification, and code quality checking. We will look at what kind of tools the Ruby community is good at building, what kind of tools we are bad at, and most of all, some of the tooling we should be working on to really improve our ecosystem and drive more developers to this wonderful language.

Help us caption & translate this video!

http://amara.org/v/FG5W/
Captions: 
	00:00:17,000 --> 00:00:19,300
LOREN SEGAL: I'm actually really happy to be like the

00:00:19,380 --> 00:00:21,210
first technical talk, because that means

00:00:21,210 --> 00:00:23,230
I get to relax for the rest of the conference.

00:00:23,230 --> 00:00:25,319
It also means you guys are probably

00:00:25,319 --> 00:00:26,769
not skipping out on the talks yet,

00:00:26,769 --> 00:00:29,149
so you're all here. It's a full room.

00:00:29,149 --> 00:00:30,319
So that's good.

00:00:30,319 --> 00:00:32,759
Welcome to RubyConf, guys. I'm really excited to be

00:00:32,759 --> 00:00:35,219
in Miami.

00:00:35,219 --> 00:00:37,690
I want to start my talk with a question.

00:00:37,690 --> 00:00:40,140
And that question is, are Rubyists good at testing

00:00:40,140 --> 00:00:44,760
because they have good tools, or do Rubyists have

00:00:44,760 --> 00:00:48,399
good tools because they're good at testing?

00:00:48,399 --> 00:00:50,190
It seems to me like this one is sort

00:00:50,190 --> 00:00:54,230
of the wrong question to ask, because there's, there's

00:00:54,230 --> 00:00:57,550
nothing, to me there's nothing innate about Rubyists that

00:00:57,550 --> 00:01:00,969
make us good at testing. First of all, a

00:01:00,969 --> 00:01:04,610
lot of Rubyists are also Java programmers, Python programmers,

00:01:04,610 --> 00:01:09,110
Go programmers, and you know, when we're programming Go,

00:01:09,110 --> 00:01:11,930
we're not all of a sudden bad testers. And

00:01:11,930 --> 00:01:13,330
when we switch back to Ruby, we don't become

00:01:13,330 --> 00:01:15,930
magically good testers again.

00:01:15,930 --> 00:01:17,570
Clearly there's something about the tools that we have

00:01:17,570 --> 00:01:20,120
as Rubyists that make it efficient for us to

00:01:20,120 --> 00:01:23,400
be good at testing.

00:01:23,400 --> 00:01:25,600
You can also look at, sort of the ways

00:01:25,600 --> 00:01:30,990
we've advanced our civilization as humans. So the way

00:01:30,990 --> 00:01:32,970
we've been able to survive as humans, so for

00:01:32,970 --> 00:01:37,990
the centuries and millennia, has been through the advancements

00:01:37,990 --> 00:01:40,860
of technology and tooling.

00:01:40,860 --> 00:01:42,770
Humans are actually kind of weak creatures. We're not

00:01:42,770 --> 00:01:47,970
very good at physical, you know, dominance. So we've

00:01:47,970 --> 00:01:51,330
always used our ability to advance technology as our

00:01:51,330 --> 00:01:56,190
survival mechanism. And I think the advancements of, the

00:01:56,190 --> 00:01:58,300
advancement of tooling has always sort of been central

00:01:58,300 --> 00:02:00,780
to the advancement of technology, which has sort of

00:02:00,780 --> 00:02:04,270
given us better tools. And then we've finally gotten

00:02:04,270 --> 00:02:06,480
mastery over our crafts.

00:02:06,480 --> 00:02:13,480
So clearly tools are important. And I think, just

00:02:14,380 --> 00:02:16,420
because tools are important we should talk about what

00:02:16,420 --> 00:02:18,560
tools are available to us, and, and, figure out

00:02:18,560 --> 00:02:20,620
how we can use the tools that we have.

00:02:20,620 --> 00:02:23,390
And figure out how we can make better tools.

00:02:23,390 --> 00:02:27,090
So, in the Ruby community, we have, we do

00:02:27,090 --> 00:02:30,110
have good tools available to us. And there's plenty

00:02:30,110 --> 00:02:34,680
to talk about. But sometimes we don't really have

00:02:34,680 --> 00:02:36,750
such great tools, and I want to focus this

00:02:36,750 --> 00:02:38,490
talk, even though there's a lot of great things

00:02:38,490 --> 00:02:40,670
to say, I want to focus the talk on

00:02:40,670 --> 00:02:42,250
the not so good tools that are available to

00:02:42,250 --> 00:02:45,840
us, and the things that we need to improve.

00:02:45,840 --> 00:02:47,990
So the couple of goals in this talk. The

00:02:47,990 --> 00:02:50,900
first one is to introduce the different set of

00:02:50,900 --> 00:02:54,130
tools that you might not be aware of. Look

00:02:54,130 --> 00:02:56,630
at, let's look at other languages, see what, what

00:02:56,630 --> 00:03:01,050
other languages provide to developers as tools - Java,

00:03:01,050 --> 00:03:03,440
C#, Go.

00:03:03,440 --> 00:03:06,930
After we look at different tools we can figure

00:03:06,930 --> 00:03:09,370
out sort of what tools we are missing from

00:03:09,370 --> 00:03:11,740
our languages, and sort of reflect on that and

00:03:11,740 --> 00:03:14,630
figure out why we're missing those tools. Are there

00:03:14,630 --> 00:03:16,800
any problems with the fact that we don't have

00:03:16,800 --> 00:03:21,300
those tools? And should we be improving ourselves?

00:03:21,300 --> 00:03:23,580
And the third one is, I kind of want

00:03:23,580 --> 00:03:25,630
this talk to be, hopefully, an inspiration to you

00:03:25,630 --> 00:03:29,400
guys to actually go out there, find a problem

00:03:29,400 --> 00:03:32,240
that hasn't been solved yet, and write a tool

00:03:32,240 --> 00:03:34,680
for our community. Write something that can make us

00:03:34,680 --> 00:03:41,590
better. Become a garbage collector, as Matz said earlier.

00:03:41,590 --> 00:03:43,740
So I'm gonna be naming a bunch of different

00:03:43,740 --> 00:03:45,900
tools, and I'm gonna be glossing over a lot

00:03:45,900 --> 00:03:48,090
of different things in this talk. And I didn't

00:03:48,090 --> 00:03:50,099
have time to actually give URLs to everything, and

00:03:50,099 --> 00:03:52,180
you probably wouldn't be able to read them, cause

00:03:52,180 --> 00:03:53,700
usually some of them are long.

00:03:53,700 --> 00:03:55,790
So if you Google just the tool name and

00:03:55,790 --> 00:03:56,880
the language, you should be able to find most

00:03:56,880 --> 00:03:58,430
of the things I'm referencing in a talk. If

00:03:58,430 --> 00:04:00,880
you don't, come and find me. I will gladly

00:04:00,880 --> 00:04:03,989
point you in the right direction.

00:04:03,989 --> 00:04:06,180
So let's jump into the kinds of tools that

00:04:06,180 --> 00:04:09,630
are available to developers.

00:04:09,630 --> 00:04:11,220
There's tons of kinds of tools, and I'm not

00:04:11,220 --> 00:04:13,220
gonna be able to cover everything. And this isn't

00:04:13,220 --> 00:04:16,370
even a complete list. But there are tool types

00:04:16,370 --> 00:04:21,729
like deployment operation tools, documentation tools, testing tools, visualization

00:04:21,729 --> 00:04:26,900
tools, debugging, linting, static analysis tools.

00:04:26,900 --> 00:04:28,960
I'm going to focus on sort of the bottom

00:04:28,960 --> 00:04:32,469
half of this, starting from visualization down. We pretty

00:04:32,469 --> 00:04:35,439
much have deployment and operations down pat. We are

00:04:35,439 --> 00:04:37,580
very good at this in the Ruby community. We

00:04:37,580 --> 00:04:40,999
have pretty good documentation tools. We have very good

00:04:40,999 --> 00:04:42,939
testing tools. We're sort of like the kings of

00:04:42,939 --> 00:04:44,509
testing, as it were.

00:04:44,509 --> 00:04:48,419
Visualization, debugging, linting, and static analysis, I think are

00:04:48,419 --> 00:04:49,749
areas where we have a lot of room to

00:04:49,749 --> 00:04:53,620
grow and improve. So I'm gonna talk about those

00:04:53,620 --> 00:04:57,099
four areas.

00:04:57,099 --> 00:05:00,529
So let's jump into visualization.

00:05:00,529 --> 00:05:02,629
I think that some of the most important tools

00:05:02,629 --> 00:05:07,339
that are out there are visualization tools. Visualization tools

00:05:07,339 --> 00:05:13,229
kind of encompass, for me, encompass debugging, refactoring tools,

00:05:13,229 --> 00:05:16,139
general actual visualization tools that you can like, see

00:05:16,139 --> 00:05:18,860
how your code works and stuff like that. Profiling

00:05:18,860 --> 00:05:19,909
tools I think are also visualization.

00:05:19,909 --> 00:05:21,509
So there's a lot, it's a kind of a

00:05:21,509 --> 00:05:24,259
broad spectrum, but anything that lets you see what

00:05:24,259 --> 00:05:28,430
your code does is useful.

00:05:28,430 --> 00:05:30,419
Visualization tools effectively let you know what you're code

00:05:30,419 --> 00:05:34,529
is doing. So without any visibility into your code,

00:05:34,529 --> 00:05:37,809
you kind of have no idea what you're doing.

00:05:37,809 --> 00:05:39,620
Imagine that you have a thread in a sealed

00:05:39,620 --> 00:05:45,900
box. Is it dead or is it alive?

00:05:45,900 --> 00:05:49,379
So visibility let's us answer that question. Peek into

00:05:49,379 --> 00:05:51,939
that box and actually see what our code is

00:05:51,939 --> 00:05:54,879
doing.

00:05:54,879 --> 00:05:56,740
This is a screen shot of visual studio, the

00:05:56,740 --> 00:05:59,039
lightest build of visual studio. And this is a

00:05:59,039 --> 00:06:01,520
new feature that they added called a diagnostics hub,

00:06:01,520 --> 00:06:03,869
and it's sort of this profiling tool that gives

00:06:03,869 --> 00:06:08,770
you some pretty cool input into sort of very

00:06:08,770 --> 00:06:11,979
detailed parts of your code, like how long it

00:06:11,979 --> 00:06:15,830
takes to load things, what the actual CPU utilization

00:06:15,830 --> 00:06:19,499
is of different components of your code. Very granular

00:06:19,499 --> 00:06:20,259
stuff.

00:06:20,259 --> 00:06:24,270
You also get FPS through, through, for, GUI application,

00:06:24,270 --> 00:06:27,029
if you have a GUI running. You get FPS

00:06:27,029 --> 00:06:28,990
going up, which I think is kind of cool.

00:06:28,990 --> 00:06:31,919
So you get a lot of visualization stuff from

00:06:31,919 --> 00:06:35,360
a tool like this.

00:06:35,360 --> 00:06:38,699
Visual Studio also has a debugger in addition to

00:06:38,699 --> 00:06:41,319
the profiling stuff, and Visual Studios debugger has always

00:06:41,319 --> 00:06:44,659
been pretty good. I'm really excited about this, the

00:06:44,659 --> 00:06:46,529
feature on the right there that shows you not

00:06:46,529 --> 00:06:49,469
only the list of call, the call graph as

00:06:49,469 --> 00:06:52,819
a two dimensional list, but you also get the

00:06:52,819 --> 00:06:56,029
call graph as this tree of things where you,

00:06:56,029 --> 00:06:57,889
you know, where you are in your code.

00:06:57,889 --> 00:07:00,279
And the useful thing about that is, you not

00:07:00,279 --> 00:07:01,949
only see where you are and where you came

00:07:01,949 --> 00:07:03,680
from, but you also see where that thing that

00:07:03,680 --> 00:07:06,139
came from was as well. So you see that

00:07:06,139 --> 00:07:09,689
the item, item view on click up there also

00:07:09,689 --> 00:07:12,490
came from activating, or called activate instance and then

00:07:12,490 --> 00:07:15,300
called on navigate from, and now is calling on

00:07:15,300 --> 00:07:17,249
navigated to.

00:07:17,249 --> 00:07:18,529
And you, and you get this, you get this

00:07:18,529 --> 00:07:21,349
very cool tree of, of where you are in

00:07:21,349 --> 00:07:24,430
your code, and how that effects the components. And

00:07:24,430 --> 00:07:27,180
I think that's pretty useful if you're doing very

00:07:27,180 --> 00:07:31,270
large, working on very large systems that interact with

00:07:31,270 --> 00:07:33,430
one another.

00:07:33,430 --> 00:07:35,860
This is XCode, and this is XCode's profiler, and

00:07:35,860 --> 00:07:37,949
it's not very language specific. It can pretty much

00:07:37,949 --> 00:07:41,229
run any, profile any binary. But what I like

00:07:41,229 --> 00:07:45,159
about this is the user interface view at the

00:07:45,159 --> 00:07:46,830
top, where you can actually see what user interface

00:07:46,830 --> 00:07:49,349
portions have been activated. I think that's a pretty

00:07:49,349 --> 00:07:56,349
cool kind of functionality to have for a UI

00:07:57,449 --> 00:07:57,539
profiler.

00:07:57,539 --> 00:08:01,020
This is VisualVM, and this comes standard with the

00:08:01,020 --> 00:08:03,110
JVM oracles, JVM, you can pretty much use this

00:08:03,110 --> 00:08:05,860
out of the box on any JVM code. And

00:08:05,860 --> 00:08:08,699
there's nothing really special about this profiler. It gives

00:08:08,699 --> 00:08:11,309
you the standard stuff that you'd expect, except this

00:08:11,309 --> 00:08:13,529
one kind of comes with the JVM, so it

00:08:13,529 --> 00:08:15,969
shows you how, how integral this is to the

00:08:15,969 --> 00:08:22,929
actual, you know, programming cycle.

00:08:22,929 --> 00:08:28,379
So visualization is really about discoverability. Knowing what your

00:08:28,379 --> 00:08:30,499
code is doing is one thing, but being able

00:08:30,499 --> 00:08:32,149
to kind of find out what you didn't know

00:08:32,149 --> 00:08:34,579
about your code is also extremely useful. Probably even

00:08:34,579 --> 00:08:36,849
more useful than knowing what you already know about

00:08:36,849 --> 00:08:38,149
your code.

00:08:38,149 --> 00:08:42,169
So discoverability is a really important feature of good

00:08:42,169 --> 00:08:44,779
visualization tools. And if you found Waldo, by the

00:08:44,779 --> 00:08:51,250
way, just, has anyone, has anyone found Waldo? OK.

00:08:51,250 --> 00:08:51,970
Good.

00:08:51,970 --> 00:08:55,440
So this is Eclipse. A couple of views that

00:08:55,440 --> 00:08:59,019
you get from Eclipse. The first one is the

00:08:59,019 --> 00:09:02,009
implementors, kind of, view that you get. You get

00:09:02,009 --> 00:09:05,720
to see what classes implement a specific method in

00:09:05,720 --> 00:09:09,440
your code. That's kind of useful for seeing, like,

00:09:09,440 --> 00:09:14,060
I implemented this method, set, redraw, where who's using

00:09:14,060 --> 00:09:16,829
it, and if I refactor this method, who will

00:09:16,829 --> 00:09:19,199
I break? And that's kind of useful, especially if

00:09:19,199 --> 00:09:21,870
you're doing a lot of refactoring.

00:09:21,870 --> 00:09:24,930
There's also a call references graph that you get

00:09:24,930 --> 00:09:28,100
to see, which shows you all things from the

00:09:28,100 --> 00:09:30,180
other side. All things that are calling a specific

00:09:30,180 --> 00:09:33,380
method in your, at your, in your code.

00:09:33,380 --> 00:09:36,490
So if I call this is_running method, I know

00:09:36,490 --> 00:09:39,050
that, if I have this is_running method I have

00:09:39,050 --> 00:09:42,180
defined, I know who's actually using this is_running method.

00:09:42,180 --> 00:09:45,209
The cool thing about having staticly typed languages is

00:09:45,209 --> 00:09:46,470
that you not only get the actual - it's

00:09:46,470 --> 00:09:48,560
not just like a search over your code base

00:09:48,560 --> 00:09:52,230
for the is_running string. You're actually finding things that

00:09:52,230 --> 00:09:55,480
are finding that specific implementation of is_running. So if

00:09:55,480 --> 00:09:57,329
you were to search for to_s on your Ruby

00:09:57,329 --> 00:10:01,480
code, you wouldn't actually get interesting data. But if

00:10:01,480 --> 00:10:04,360
you were looking for to_string on a specific Java

00:10:04,360 --> 00:10:06,290
class, you'd be able to actually find the things

00:10:06,290 --> 00:10:10,129
that are actually calling that specific to_string method.

00:10:10,129 --> 00:10:13,230
So that's pretty useful if you're actually refactoring code

00:10:13,230 --> 00:10:17,220
and moving stuff around.

00:10:17,220 --> 00:10:19,300
You don't just need to have an IDE to

00:10:19,300 --> 00:10:20,879
have visualization tools. A lot of the things I

00:10:20,879 --> 00:10:25,310
showed were part of IDEs. But it's not necessary

00:10:25,310 --> 00:10:27,660
that you have full-fledged IDE just to have this

00:10:27,660 --> 00:10:31,980
visualization stuff. There's nothing specific about IDEs here.

00:10:31,980 --> 00:10:34,879
And I can, I can prove it because of

00:10:34,879 --> 00:10:37,220
this tool right here. And this tool is not

00:10:37,220 --> 00:10:40,589
an IDE by any means. It's the FireBug web

00:10:40,589 --> 00:10:43,639
inspector. If you were fortunate enough to use it

00:10:43,639 --> 00:10:46,230
when it was, like, the thing to use, a

00:10:46,230 --> 00:10:48,889
couple years back, you know that this sort of

00:10:48,889 --> 00:10:51,540
saved you, saved your life a billion times.

00:10:51,540 --> 00:10:55,839
Nowadays we use stuff like the Chrome web inspector

00:10:55,839 --> 00:10:59,300
and other web inspectors, and they're awesome, and Firebug,

00:10:59,300 --> 00:11:04,410
Firebug's still around and it's awesome too, but.

00:11:04,410 --> 00:11:05,990
The real question is, do you remember what web

00:11:05,990 --> 00:11:10,379
development like, was like before Firebug?

00:11:10,379 --> 00:11:12,459
And if you don't remember, it's probably because you

00:11:12,459 --> 00:11:17,800
blacked it out. Because it was really horrible. And

00:11:17,800 --> 00:11:19,550
the reason why it was so horrible is because

00:11:19,550 --> 00:11:22,149
you had no visibility into what your code was

00:11:22,149 --> 00:11:23,269
doing.

00:11:23,269 --> 00:11:27,959
The, the, when Firebug came around, it sort of

00:11:27,959 --> 00:11:32,240
changed web development. I, I actually attribute the HTML5

00:11:32,240 --> 00:11:35,829
adoption, a lot of the social media adoption, social

00:11:35,829 --> 00:11:40,019
websites, to the existence of Firebug and better tooling

00:11:40,019 --> 00:11:44,220
around HTML on JavaScript development.

00:11:44,220 --> 00:11:45,870
The fact that we're able to iterate so much

00:11:45,870 --> 00:11:48,629
more quickly with these tools, I think had a

00:11:48,629 --> 00:11:50,819
huge impact on how we're able to actually put

00:11:50,819 --> 00:11:52,649
code out there.

00:11:52,649 --> 00:11:54,970
So I think it's really import- I think Firebug

00:11:54,970 --> 00:11:58,259
is a great example of how visualization can actually

00:11:58,259 --> 00:12:01,240
effect development, and how it can be a really

00:12:01,240 --> 00:12:05,029
powerful tool.

00:12:05,029 --> 00:12:07,759
So this is the Ember web inspec- Ember Inspector.

00:12:07,759 --> 00:12:10,300
It's part of the Chrome Web Inspector. It's sort

00:12:10,300 --> 00:12:12,730
of this, like, component that you can add in.

00:12:12,730 --> 00:12:16,069
And this is similar to a standard web inspector

00:12:16,069 --> 00:12:18,889
that you would see inside of Chrome, except it

00:12:18,889 --> 00:12:22,620
adds extra functionality, high-level functionality specific to your application.

00:12:22,620 --> 00:12:25,639
Like you can see your routes that you've assigned,

00:12:25,639 --> 00:12:27,829
you can see your Ember date that you've pulled

00:12:27,829 --> 00:12:30,199
in from your data sources.

00:12:30,199 --> 00:12:33,360
You can see, another application, you can see the

00:12:33,360 --> 00:12:36,019
view tree and see what things are sort of

00:12:36,019 --> 00:12:37,720
nested hierarchically.

00:12:37,720 --> 00:12:40,149
I think it's really useful if you're doing Ember

00:12:40,149 --> 00:12:43,579
stuff. And having this high level stuff would be

00:12:43,579 --> 00:12:46,040
really cool. Having something similar for Rails, where you

00:12:46,040 --> 00:12:48,410
can actually see your client's side of stuff would

00:12:48,410 --> 00:12:52,360
be similarly cool.

00:12:52,360 --> 00:12:54,290
And finally I want to talk about one last

00:12:54,290 --> 00:12:57,899
thing and that's Smalltalk. So this is a screenshot

00:12:57,899 --> 00:13:02,019
of Smalltalk. One of the earlier versions of Smalltalk.

00:13:02,019 --> 00:13:05,230
And Smalltalk was, is interesting because it was designed

00:13:05,230 --> 00:13:07,689
as a language that was meant to be inherently

00:13:07,689 --> 00:13:08,779
visual.

00:13:08,779 --> 00:13:10,779
It was always meant to be attached to an

00:13:10,779 --> 00:13:14,730
IDE. The design goal was that you were able

00:13:14,730 --> 00:13:16,819
to see everything that you were touching, and you

00:13:16,819 --> 00:13:19,360
would be able to touch stuff and play with

00:13:19,360 --> 00:13:24,420
it and modify it. The concept of visualizing your

00:13:24,420 --> 00:13:28,399
development environment was sort of pioneered from Smalltalk.

00:13:28,399 --> 00:13:30,449
And I think we have a lot to owe

00:13:30,449 --> 00:13:33,529
to this language and, you know, the people who

00:13:33,529 --> 00:13:36,259
developed it to, to a lot of the visualization

00:13:36,259 --> 00:13:38,790
tools that we have today.

00:13:38,790 --> 00:13:40,749
So yeah, it was, it was an inherently visual

00:13:40,749 --> 00:13:43,660
language, and I think, I think it worked out

00:13:43,660 --> 00:13:46,100
pretty well.

00:13:46,100 --> 00:13:48,040
So where do we stand with visualization in the

00:13:48,040 --> 00:13:50,749
Ruby community?

00:13:50,749 --> 00:13:52,930
So we have, you know, the standard IDEs, I

00:13:52,930 --> 00:13:55,600
mean, we have RubyMine. We don't have very many

00:13:55,600 --> 00:14:00,079
IDEs. We have RubyMine and RubyMine is your standard

00:14:00,079 --> 00:14:02,560
run of the mill IDE. It provides you your

00:14:02,560 --> 00:14:05,480
basic set of visualization. You can see your Rails

00:14:05,480 --> 00:14:10,029
routes. You can have a basic debugger, UI.

00:14:10,029 --> 00:14:12,259
But we don't get, we don't get too, we

00:14:12,259 --> 00:14:14,499
don't get too in depth on visualization tools. And

00:14:14,499 --> 00:14:17,339
we don't have very many visualization tools when it

00:14:17,339 --> 00:14:22,439
comes to refactoring, when it comes to seeing where

00:14:22,439 --> 00:14:25,129
what implements what, where your code, how your code

00:14:25,129 --> 00:14:27,649
is structured. We don't have a lot of that,

00:14:27,649 --> 00:14:28,829
and there's a lot of room for us to

00:14:28,829 --> 00:14:31,220
actually improve on that, catch up with, to other

00:14:31,220 --> 00:14:34,209
languages.

00:14:34,209 --> 00:14:36,180
What about profilers?

00:14:36,180 --> 00:14:40,589
So a couple years back there was a library

00:14:40,589 --> 00:14:44,139
called Memprof and it was really awesome. It kind

00:14:44,139 --> 00:14:47,720
of went away. It doesn't really support Ruby 1.9.

00:14:47,720 --> 00:14:49,910
If someone wants to resurrect this tool, it's really

00:14:49,910 --> 00:14:52,779
cool. I would like to see that.

00:14:52,779 --> 00:14:54,870
In the meantime we have a tool called Perftools

00:14:54,870 --> 00:14:59,499
dot rb. This one can generate, can run through

00:14:59,499 --> 00:15:03,759
your code and generate this graph, this diagram of

00:15:03,759 --> 00:15:07,209
how your code is running through everything, including percentage,

00:15:07,209 --> 00:15:09,509
CPU time and stuff like that.

00:15:09,509 --> 00:15:10,949
So you can see there for instance, your garbage

00:15:10,949 --> 00:15:13,839
collector took twelve percent of your, of your running

00:15:13,839 --> 00:15:16,819
time. This is a pretty useful tool if you're

00:15:16,819 --> 00:15:19,249
doing performance, and I think the fact that it

00:15:19,249 --> 00:15:26,249
does, generates a graph, this diagram is extremely useful.

00:15:26,560 --> 00:15:29,499
If you're running JRuby, then you kind of get

00:15:29,499 --> 00:15:31,699
the advantage of having the JVM, and once you

00:15:31,699 --> 00:15:34,670
have the JVM, you can use things like VisualVM,

00:15:34,670 --> 00:15:38,259
and you can use NetBeans to do your visualization.

00:15:38,259 --> 00:15:40,410
You get all the power of, most of, a

00:15:40,410 --> 00:15:42,199
lot of the power, not all the power, a

00:15:42,199 --> 00:15:43,470
lot of the power of the profiling tool that

00:15:43,470 --> 00:15:46,189
are available in NetBeans and other tools.

00:15:46,189 --> 00:15:50,040
So this is not an endorsement, but if you're

00:15:50,040 --> 00:15:54,470
using the JVM you get some of the powers.

00:15:54,470 --> 00:15:57,470
So that's visualization. I want to jump over now

00:15:57,470 --> 00:16:00,790
to sort of linting tools and how we can,

00:16:00,790 --> 00:16:07,790
where we are in that kind of area.

00:16:07,990 --> 00:16:13,410
So Lint is this tool that was developed in

00:16:13,410 --> 00:16:17,879
sort of the seventies for the C programming language.

00:16:17,879 --> 00:16:19,160
And Lint was a tool that was meant to

00:16:19,160 --> 00:16:21,329
sort of find these common errors in our code

00:16:21,329 --> 00:16:24,259
bases. It was meant to catch things like divide

00:16:24,259 --> 00:16:30,079
by zeros, uninitialized variables, and other, like, very common,

00:16:30,079 --> 00:16:32,499
easy to find bugs.

00:16:32,499 --> 00:16:34,779
But it also did some basic style checking, like

00:16:34,779 --> 00:16:37,300
you're using this kind of tab with your formatting

00:16:37,300 --> 00:16:40,670
is this sort of direc- way, and it looks

00:16:40,670 --> 00:16:43,029
good.

00:16:43,029 --> 00:16:45,059
So that's, that's sort of, when we say linting,

00:16:45,059 --> 00:16:47,399
we're sort of saying, are you really, do you

00:16:47,399 --> 00:16:50,350
have this kind of sort of basic bug checking

00:16:50,350 --> 00:16:52,370
tool.

00:16:52,370 --> 00:16:54,220
So where do we stand with Ruby when it

00:16:54,220 --> 00:16:58,529
comes to linting tools?

00:16:58,529 --> 00:17:00,639
In the Ruby community we have three tools that

00:17:00,639 --> 00:17:03,370
are kind of use together in some way. It's

00:17:03,370 --> 00:17:06,350
called, they're called Reek, Flog, and Flay. And they

00:17:06,350 --> 00:17:10,560
basically detect code smells in your code. The thing

00:17:10,560 --> 00:17:11,990
that they don't do, and I'll touch on this

00:17:11,990 --> 00:17:13,810
in a bit, is they don't, they don't find

00:17:13,810 --> 00:17:17,600
semantic errors in your code. They basically just find

00:17:17,600 --> 00:17:21,520
syntactic kind of weirdnesses.

00:17:21,520 --> 00:17:23,589
The assumption that these tools make is that pretty

00:17:23,589 --> 00:17:25,200
code is correct code, so if you have code

00:17:25,200 --> 00:17:29,930
that looks good it's really good.

00:17:29,930 --> 00:17:32,990
If you're using, if you're using Code Climate, you

00:17:32,990 --> 00:17:35,800
probably already used these tools, cause Code Climate kind

00:17:35,800 --> 00:17:38,100
of uses these under the hood, and you get

00:17:38,100 --> 00:17:41,990
a grade point average for whether your reek outputs

00:17:41,990 --> 00:17:45,410
tells you that your code is good or whatever.

00:17:45,410 --> 00:17:48,320
The important point here is that these tools are

00:17:48,320 --> 00:17:50,170
telling you whether your code is ugly, not whether

00:17:50,170 --> 00:17:53,660
your code is correct. And I wanted to figure

00:17:53,660 --> 00:17:55,520
out a way to like show this the best

00:17:55,520 --> 00:17:58,420
way I could, and I decided that I would

00:17:58,420 --> 00:18:00,970
write a really large Ruby application that looked really

00:18:00,970 --> 00:18:03,710
nice but didn't actually do anything.

00:18:03,710 --> 00:18:05,080
And then I realized that writing a really large

00:18:05,080 --> 00:18:07,160
Ruby application would take me a really long time,

00:18:07,160 --> 00:18:10,590
so I wrote a program to write Ruby programs.

00:18:10,590 --> 00:18:13,630
And I wrote a Ruby program, I generate a

00:18:13,630 --> 00:18:17,710
Ruby program with 134 classes and pass it through

00:18:17,710 --> 00:18:19,560
Code Climate, and Code Climate seems to think it's

00:18:19,560 --> 00:18:22,760
awesome.

00:18:22,760 --> 00:18:25,320
But I'm just gonna pop it up here. This

00:18:25,320 --> 00:18:27,180
is my, this is part of the Ruby code

00:18:27,180 --> 00:18:33,880
that I wrote.

00:18:33,880 --> 00:18:37,800
So it doesn't, it doesn't do anything.

00:18:37,800 --> 00:18:44,800
So yeah. Code correct, not necessarily true.

00:18:46,570 --> 00:18:49,390
By the way, I love Code Climate. I think

00:18:49,390 --> 00:18:50,900
it's a really awesome tool. I think you guys

00:18:50,900 --> 00:18:54,300
should probably be using it. The important point here

00:18:54,300 --> 00:18:56,050
is that you really need to understand what your

00:18:56,050 --> 00:18:59,030
tools are doing, and to realize that Code Climate

00:18:59,030 --> 00:19:00,820
does not replace testing. So you can't just be

00:19:00,820 --> 00:19:02,910
like, oh, Code Climate says my code is correct.

00:19:02,910 --> 00:19:04,260
It's not, that's not what it's saying. It's saying

00:19:04,260 --> 00:19:08,640
your code is maintainable, effectively.

00:19:08,640 --> 00:19:11,560
So you guys should continue testing, which we already

00:19:11,560 --> 00:19:15,530
do, so. Non-statement right there.

00:19:15,530 --> 00:19:19,500
There's a tool called Ruby-lint. It's pretty new and

00:19:19,500 --> 00:19:20,910
I haven't really had a chance to check it

00:19:20,910 --> 00:19:23,390
out. If you're interesting in writing a linting tool

00:19:23,390 --> 00:19:25,340
or helping out with a linting tool, this is

00:19:25,340 --> 00:19:26,870
a good place to start.

00:19:26,870 --> 00:19:29,030
I think you just google ruby dash lint, you'll

00:19:29,030 --> 00:19:32,090
find the project on GitHub.

00:19:32,090 --> 00:19:33,900
I haven't really looked at, I think I tried

00:19:33,900 --> 00:19:37,250
to run Ruby-lint against this, the code base that

00:19:37,250 --> 00:19:39,730
I just showed and it kind of crashed, so.

00:19:39,730 --> 00:19:44,430
There's, there's work there to make it better.

00:19:44,430 --> 00:19:46,160
The point I was, I want to make is

00:19:46,160 --> 00:19:49,460
that nothing really comes standard in the Ruby community

00:19:49,460 --> 00:19:50,820
when it comes to linting tools. We don't really

00:19:50,820 --> 00:19:52,650
have a linting tool that we go to and

00:19:52,650 --> 00:19:55,050
say, you know, why aren't you using this linting

00:19:55,050 --> 00:19:55,740
tool.

00:19:55,740 --> 00:19:59,400
So we could certainly benefit from having one.

00:19:59,400 --> 00:20:04,800
How do other languages fare when it comes to

00:20:04,800 --> 00:20:06,430
lint tools?

00:20:06,430 --> 00:20:11,770
So these are some examples of pretty standard lint

00:20:11,770 --> 00:20:15,090
tools in other languages. JavaScript has JSHint, it used

00:20:15,090 --> 00:20:18,110
to be JSLint, and that sort of fell out

00:20:18,110 --> 00:20:22,410
of favor. Python has PyLint, which is widely adopted.

00:20:22,410 --> 00:20:25,380
Java has FindBugs, which you'll pretty much see everywhere

00:20:25,380 --> 00:20:28,320
where people are doing linting in Java. C# has

00:20:28,320 --> 00:20:30,290
FxCop, and I think it has some others as

00:20:30,290 --> 00:20:30,740
well.

00:20:30,740 --> 00:20:33,810
But FxCop is pretty standard.

00:20:33,810 --> 00:20:35,990
All these are widely used and sort of widely

00:20:35,990 --> 00:20:38,690
adopted and accepted as the thing that you should

00:20:38,690 --> 00:20:42,260
be using. Why don't we have something like this

00:20:42,260 --> 00:20:44,170
in Ruby? We should at least have some kind

00:20:44,170 --> 00:20:47,660
of sanity checking tool for us to use and

00:20:47,660 --> 00:20:50,940
sort of define what our good standards are.

00:20:50,940 --> 00:20:52,360
If we're gonna be having these goods, if we're

00:20:52,360 --> 00:20:54,570
gonna have these good standards, we should have a

00:20:54,570 --> 00:20:57,630
tool that sort of verifies that we have, that

00:20:57,630 --> 00:20:57,900
we're meeting-

00:20:57,900 --> 00:21:02,900
So I'm gonna jump down the rabbit hole here,

00:21:02,900 --> 00:21:05,010
a little bit, and talk a little bit about

00:21:05,010 --> 00:21:10,460
some more technical stuff. And talk about static analysis.

00:21:10,460 --> 00:21:12,890
So static analysis is sort of like a lint

00:21:12,890 --> 00:21:15,800
plus plus. It's, you're doing bug checking, but you're

00:21:15,800 --> 00:21:19,690
doing much more in depth bug checking. Static analysis

00:21:19,690 --> 00:21:21,760
however is kind of a huge field, so very

00:21:21,760 --> 00:21:24,890
vague term for a lot of different things.

00:21:24,890 --> 00:21:28,620
And if you actually Google static analysis or a

00:21:28,620 --> 00:21:31,640
scholar dot google search for static analysis, look for

00:21:31,640 --> 00:21:33,790
papers on this subject, you'll find that there is

00:21:33,790 --> 00:21:36,010
over two and a half million to two point

00:21:36,010 --> 00:21:39,010
two million papers on the subject. That's a lot

00:21:39,010 --> 00:21:41,020
of papers on a subject.

00:21:41,020 --> 00:21:43,620
If you kind of average two to three papers

00:21:43,620 --> 00:21:48,160
per researcher, you're talking, like, 500,000 to a million

00:21:48,160 --> 00:21:50,750
researchers with different research topics.

00:21:50,750 --> 00:21:53,440
So there's a lot of fields of static analysis

00:21:53,440 --> 00:21:55,040
and there's a lot of things to talk about

00:21:55,040 --> 00:21:59,450
in this, on this subject.

00:21:59,450 --> 00:22:02,500
There's a lot of different types of static analysis.

00:22:02,500 --> 00:22:05,990
There's defect finding. There's memory checking and fuzz testing.

00:22:05,990 --> 00:22:08,840
There's extended static checking and model checking, data flow

00:22:08,840 --> 00:22:10,630
analysis and symbolic execution.

00:22:10,630 --> 00:22:12,920
I'm gonna cover some of these and sort of

00:22:12,920 --> 00:22:15,380
gloss over some of these as well. And so

00:22:15,380 --> 00:22:18,330
let's jump into static analysis.

00:22:18,330 --> 00:22:22,170
So first I'm gonna talk about defect finding. Defect

00:22:22,170 --> 00:22:25,470
finding is basically like lint. It sort of has

00:22:25,470 --> 00:22:28,250
a little less emphasis on syntax, so there's less

00:22:28,250 --> 00:22:31,330
of the, does your code have proper white spacing

00:22:31,330 --> 00:22:33,820
stuff, and more of the, does your code have

00:22:33,820 --> 00:22:36,650
initialized variables stuff.

00:22:36,650 --> 00:22:38,870
So because most of the tools that I mentioned

00:22:38,870 --> 00:22:42,090
before have sort of those capabilities, where they can

00:22:42,090 --> 00:22:45,140
check divide by zeros or whatever you need in

00:22:45,140 --> 00:22:47,980
those languages, most of those other languages already have

00:22:47,980 --> 00:22:51,680
those linting tools. So PyLint will do some kind

00:22:51,680 --> 00:22:56,200
of defect finding, FindBugs in Java is named specifically

00:22:56,200 --> 00:22:58,190
for the ability to find bugs, so it's kind

00:22:58,190 --> 00:23:01,080
of a defect-finding tool.

00:23:01,080 --> 00:23:04,710
In Ruby, we have a tool called Brakeman, which

00:23:04,710 --> 00:23:07,440
is specific to Ruby on Rails, but this is

00:23:07,440 --> 00:23:10,270
sort of a defect finding tool, and if you

00:23:10,270 --> 00:23:11,680
haven't heard of it or checked it out I

00:23:11,680 --> 00:23:13,630
would suggest looking at this tool. I think it's

00:23:13,630 --> 00:23:15,880
a pretty good tool. I ran it on a

00:23:15,880 --> 00:23:18,060
couple of Rails projects and had some pretty good

00:23:18,060 --> 00:23:20,080
success with it.

00:23:20,080 --> 00:23:24,600
It basically finds common flaws in Rails code, so

00:23:24,600 --> 00:23:27,230
it'll look for cross site scripting, SQL injection, mass

00:23:27,230 --> 00:23:32,710
assignment issues. This is what a report looks like,

00:23:32,710 --> 00:23:33,960
and it'll tell you that you know you have

00:23:33,960 --> 00:23:36,910
a potential SQL injection, missed method - it does

00:23:36,910 --> 00:23:41,150
some static analysis to find these, using heuristics it

00:23:41,150 --> 00:23:43,370
does static analysis to find, oh, he didn't do

00:23:43,370 --> 00:23:47,410
any sanity checking on his prims, hash, and stuff

00:23:47,410 --> 00:23:47,890
like that.

00:23:47,890 --> 00:23:49,730
So it's kind of a useful tool to look

00:23:49,730 --> 00:23:55,360
at. It does have false positives, but I think

00:23:55,360 --> 00:23:56,960
even if, even if it did have a couple

00:23:56,960 --> 00:24:00,070
false positives in this list, just for that one

00:24:00,070 --> 00:24:03,410
product controller SQL injection statement, I think it's worth

00:24:03,410 --> 00:24:05,070
it.

00:24:05,070 --> 00:24:10,010
So yeah, it's a useful tool to look at.

00:24:10,010 --> 00:24:12,750
So this is a paper that was written on

00:24:12,750 --> 00:24:17,040
static analysis, static detection of security vulnerabilities in scripting

00:24:17,040 --> 00:24:18,420
languages.

00:24:18,420 --> 00:24:20,880
I bring this up because it was a, it

00:24:20,880 --> 00:24:25,360
was a pretty cool paper to read through. The

00:24:25,360 --> 00:24:27,510
interesting part about this paper is they found a

00:24:27,510 --> 00:24:30,760
way to, using data flower analysis, to actually figure

00:24:30,760 --> 00:24:34,260
out through code paths where code was being used

00:24:34,260 --> 00:24:37,560
that wasn't sanity checked coming from user input.

00:24:37,560 --> 00:24:39,810
And the interesting thing about this is that they

00:24:39,810 --> 00:24:42,000
actually ran, they actually wrote a proof of concept

00:24:42,000 --> 00:24:45,230
of this tool that they defined in their paper,

00:24:45,230 --> 00:24:48,920
and they ran it against existing real-world code. They

00:24:48,920 --> 00:24:52,060
targeted PHP in their talk, but PHP is a

00:24:52,060 --> 00:24:54,950
dynamic language, it's dynamically typed, it's actually looser typed

00:24:54,950 --> 00:24:58,080
than Ruby is. So you could, you could very

00:24:58,080 --> 00:25:03,100
easily take that concept and move it over to

00:25:03,100 --> 00:25:03,730
Ruby.

00:25:03,730 --> 00:25:06,340
The really interesting part is that they, they, they

00:25:06,340 --> 00:25:09,310
actually test this on sizeable code bases, we're talking

00:25:09,310 --> 00:25:13,410
thirty thousand lines of code, six thousand lines of

00:25:13,410 --> 00:25:15,500
code, you know, large code bases. And they were

00:25:15,500 --> 00:25:19,920
able to find, on versions of these code bases

00:25:19,920 --> 00:25:22,890
with existing known bugs, they were able to find

00:25:22,890 --> 00:25:25,100
all of those bugs with zero false positives.

00:25:25,100 --> 00:25:27,740
So, it, they were able to prove that it's

00:25:27,740 --> 00:25:30,920
a very effective way to actually find bugs. So

00:25:30,920 --> 00:25:32,830
if you are interested in some of that defect

00:25:32,830 --> 00:25:35,090
finding stuff, this is a really interesting paper to

00:25:35,090 --> 00:25:39,060
read through. It's not that hard to read through.

00:25:39,060 --> 00:25:41,130
So I would look at it if you want

00:25:41,130 --> 00:25:46,650
to implement something like this, I would start here.

00:25:46,650 --> 00:25:48,870
So that was defect finding. Let's talk about fuzz

00:25:48,870 --> 00:25:52,150
testing. Fuzz testing is interesting to us as sort

00:25:52,150 --> 00:25:59,040
of web developers because it's very relevent to us.

00:25:59,040 --> 00:26:02,270
Basically the idea is that fuzz testers test the

00:26:02,270 --> 00:26:05,010
fact that when you get user input you can

00:26:05,010 --> 00:26:08,520
potentially get invalid or malicious user input, so fuzz

00:26:08,520 --> 00:26:10,150
testers will throw a bunch of garbage into your

00:26:10,150 --> 00:26:12,530
application and see what breaks it.

00:26:12,530 --> 00:26:15,540
Hopefully nothing breaks it.

00:26:15,540 --> 00:26:17,520
There's a lot of existing fuzz testing tools out

00:26:17,520 --> 00:26:21,740
there. For C, Java, JavaScript, Python. There's a lot.

00:26:21,740 --> 00:26:25,190
You can go Google fuzz tester for JavaScript or

00:26:25,190 --> 00:26:28,220
whatever, and you'll find lots of tools.

00:26:28,220 --> 00:26:30,090
There are also lots of papers on the subject,

00:26:30,090 --> 00:26:31,830
so if you're interested in sort of implementing one

00:26:31,830 --> 00:26:34,910
there's a lot of resources out there. This is

00:26:34,910 --> 00:26:36,950
one of the papers that I've found on the

00:26:36,950 --> 00:26:40,340
subject that I thought was interesting. So Microsoft, internally

00:26:40,340 --> 00:26:44,240
they have this tool called Sage, and they implement,

00:26:44,240 --> 00:26:46,720
this tool actually runs across all, a lot of

00:26:46,720 --> 00:26:49,390
their code bases that they release to the public,

00:26:49,390 --> 00:26:53,450
and they implemented this thing called automated whitebox fuzz

00:26:53,450 --> 00:26:56,200
testing in Sage. And they were able to find

00:26:56,200 --> 00:26:59,710
a lot of defects with this methodology of serve

00:26:59,710 --> 00:27:02,830
- fuzz testing typically you have a hard coded

00:27:02,830 --> 00:27:04,250
set of data that you want to pass through

00:27:04,250 --> 00:27:07,660
so you know a log in form can do

00:27:07,660 --> 00:27:10,510
SQL injections, so you'll have this like where one

00:27:10,510 --> 00:27:12,710
equals one string that you always pass through to

00:27:12,710 --> 00:27:14,710
a log-in form so that you have a bunch

00:27:14,710 --> 00:27:16,570
of hard-coded values.

00:27:16,570 --> 00:27:18,620
But, I think what they did here is they

00:27:18,620 --> 00:27:21,880
had some heuristics to say, oh, maybe if I

00:27:21,880 --> 00:27:24,570
fiddle this bit based on the code path here,

00:27:24,570 --> 00:27:28,010
I can actually make something work. And make something

00:27:28,010 --> 00:27:29,450
break.

00:27:29,450 --> 00:27:31,080
So this is an interesting paper, and they sort

00:27:31,080 --> 00:27:33,180
of describe how they do fuzz testing in Microsoft.

00:27:33,180 --> 00:27:35,150
It's interesting. It just, if you're interested about, like

00:27:35,150 --> 00:27:37,630
how Microsoft does development, and how they do static

00:27:37,630 --> 00:27:42,040
analysis. It's kind of interesting to read anyway.

00:27:42,040 --> 00:27:43,850
So where do we stand as Rubyists when it

00:27:43,850 --> 00:27:46,110
comes to fuzz testing?

00:27:46,110 --> 00:27:50,780
We have a tool called Heckle, which is kind

00:27:50,780 --> 00:27:53,350
of a little older now. It was written by

00:27:53,350 --> 00:27:58,040
Ryan Davis and Kevin Clark, Seattle RB stuff. And

00:27:58,040 --> 00:28:01,680
basically what it does is it finds your if

00:28:01,680 --> 00:28:04,850
statements, your numbers, your conditions and everything, and it

00:28:04,850 --> 00:28:07,700
just twiddles the bits, basically. It just, it turns

00:28:07,700 --> 00:28:10,120
that if into an unless. It turns the greater

00:28:10,120 --> 00:28:12,230
than to like a less than. It turns a

00:28:12,230 --> 00:28:14,450
number into like some other number that wasn't -

00:28:14,450 --> 00:28:15,870
and it tries to see if your tests fail.

00:28:15,870 --> 00:28:17,570
And if your tests fail it means that you

00:28:17,570 --> 00:28:20,480
didn't have a test that can cover that piece

00:28:20,480 --> 00:28:20,810
case.

00:28:20,810 --> 00:28:22,590
So it's very kind of basic, and it doesn't

00:28:22,590 --> 00:28:24,400
really, it's not really a fuzz testing tool. But

00:28:24,400 --> 00:28:26,670
it is, it is an interesting look at how

00:28:26,670 --> 00:28:28,990
we could do stuff like that. There's another tool,

00:28:28,990 --> 00:28:33,240
and this is more relev- newer, it's maintained and

00:28:33,240 --> 00:28:35,720
it's still actively maintained. It's called Mutant, and it's

00:28:35,720 --> 00:28:38,750
basically inspired by Heckle so it's the same thing.

00:28:38,750 --> 00:28:40,690
I would take a look at this tool and,

00:28:40,690 --> 00:28:42,170
and play with it and see if you like

00:28:42,170 --> 00:28:45,710
it. But we could really use a, like a

00:28:45,710 --> 00:28:48,360
real fuzz testing tool. Something that works more similarly

00:28:48,360 --> 00:28:51,010
to other fuzz testing tools that are out there.

00:28:51,010 --> 00:28:52,780
Something that takes user input, throws it into your

00:28:52,780 --> 00:28:54,220
code.

00:28:54,220 --> 00:28:57,440
So there's definitely room to improve there. There's a

00:28:57,440 --> 00:29:02,320
tool called FuzzBert, written by Martin Bosslet. It's available

00:29:02,320 --> 00:29:03,570
there. I hadn't actually had a chance to play

00:29:03,570 --> 00:29:05,440
with it, so I'm not really sure like how

00:29:05,440 --> 00:29:07,290
well it works or if it works at all.

00:29:07,290 --> 00:29:10,410
But if you're interested in doing fuzz testing stuff,

00:29:10,410 --> 00:29:12,270
take a look at that, submit some requests, play

00:29:12,270 --> 00:29:15,750
around with it.

00:29:15,750 --> 00:29:17,380
Yeah.

00:29:17,380 --> 00:29:20,120
As I mentioned, fuzz testing kind of gets a

00:29:20,120 --> 00:29:22,740
lot of papers written about it, because it's, it's

00:29:22,740 --> 00:29:25,030
security stuff, and security stuff usually gets a lot

00:29:25,030 --> 00:29:28,240
of papers on the subject, so. A lot of

00:29:28,240 --> 00:29:32,480
resources about fuzz testing out there.

00:29:32,480 --> 00:29:35,720
So let's get mathematical, let's get a little more

00:29:35,720 --> 00:29:40,120
technical, and let's go down into symbolic execution.

00:29:40,120 --> 00:29:44,710
So we talked about, about defect finding, and, and

00:29:44,710 --> 00:29:47,350
fuzz testing and all that high level stuff. SYmbolic

00:29:47,350 --> 00:29:50,000
execution is interesting because it's a lot more, it's

00:29:50,000 --> 00:29:52,340
sort of this underlying thing that sort of guides

00:29:52,340 --> 00:29:56,100
a lot of these other tools.

00:29:56,100 --> 00:29:58,470
Basically what symbolic execution does is it runs your

00:29:58,470 --> 00:30:02,400
code with no immediate values. It sort of, so,

00:30:02,400 --> 00:30:06,580
you sort of have this algorithm that does math

00:30:06,580 --> 00:30:09,060
power, like, two to the power of eight or

00:30:09,060 --> 00:30:11,510
something. It will run it without actually using any

00:30:11,510 --> 00:30:14,150
of the numbers, and so it'll get this mathematical

00:30:14,150 --> 00:30:16,370
formula at the end. And that mathematical formula at

00:30:16,370 --> 00:30:18,480
the end is just basically your, a bunch of

00:30:18,480 --> 00:30:21,690
your code path just like concadded together, and then

00:30:21,690 --> 00:30:24,910
it just runs, it throws numbers and values into

00:30:24,910 --> 00:30:28,140
that, that mathematical equation, and it gets values out

00:30:28,140 --> 00:30:31,000
on the other end.

00:30:31,000 --> 00:30:32,750
It's similar to extended static checking, which I didn't

00:30:32,750 --> 00:30:39,640
talk about. But so, the cool thing about symbolic

00:30:39,640 --> 00:30:41,770
execution is you don't need to tell your code

00:30:41,770 --> 00:30:45,030
what you're doing. And you will see what the

00:30:45,030 --> 00:30:47,190
means in a bit.

00:30:47,190 --> 00:30:48,900
But the other thing is you can tell which

00:30:48,900 --> 00:30:52,820
inputs generate what output, because I pass in, I

00:30:52,820 --> 00:30:54,770
have this big mathematical formula, and I pass it

00:30:54,770 --> 00:30:56,140
in a two here and I get an eight

00:30:56,140 --> 00:30:59,490
out there. I can control the input and output

00:30:59,490 --> 00:31:02,440
states, all right. I know what they are.

00:31:02,440 --> 00:31:07,140
So think automatic test case generation. I can automatically

00:31:07,140 --> 00:31:09,560
generate input values that will generate this output value

00:31:09,560 --> 00:31:11,450
that I know, that I want to hit. Or

00:31:11,450 --> 00:31:14,360
the other way around.

00:31:14,360 --> 00:31:16,020
So this is a bunch of C code that

00:31:16,020 --> 00:31:19,750
implements the power, although it's very convoluted and I

00:31:19,750 --> 00:31:22,820
wouldn't recommend implementing math power this way. But just

00:31:22,820 --> 00:31:26,290
for example, you might have this complex code that

00:31:26,290 --> 00:31:31,000
implements some function, and if you read through this

00:31:31,000 --> 00:31:32,260
code, if you had a chance to read through

00:31:32,260 --> 00:31:34,600
it, you'll see that there is a potential bug

00:31:34,600 --> 00:31:36,580
there if you kind of do math two to

00:31:36,580 --> 00:31:38,970
the power of three will index out of bounds

00:31:38,970 --> 00:31:42,440
on that array.

00:31:42,440 --> 00:31:45,620
So a symbolic execution engine can actually figure out

00:31:45,620 --> 00:31:48,080
that we're hitting an array out of bounds there,

00:31:48,080 --> 00:31:50,620
and using its magic and all this math theory

00:31:50,620 --> 00:31:52,990
stuff, it's able to actually generate a report for

00:31:52,990 --> 00:31:55,150
you saying, hey if I pass one in five

00:31:55,150 --> 00:31:57,520
and I get one out of this function. If

00:31:57,520 --> 00:31:59,310
I pass two and eight I get two fifty

00:31:59,310 --> 00:32:01,110
six. But if I try to pass one and

00:32:01,110 --> 00:32:04,280
zero, I get an array out of bounds error.

00:32:04,280 --> 00:32:06,270
And then if I try one and thirty-three I

00:32:06,270 --> 00:32:08,270
also get an array out of bounds error. And

00:32:08,270 --> 00:32:09,840
the way it picks numbers is sort of based

00:32:09,840 --> 00:32:12,240
on heuristics. It'll look at your array size and

00:32:12,240 --> 00:32:15,140
it'll say, oh, thirty-two so I'm gonna try thirty-three

00:32:15,140 --> 00:32:17,120
and I'm gonna try negative one or something.

00:32:17,120 --> 00:32:19,610
So it, the symbolic execution engine is sort of

00:32:19,610 --> 00:32:22,020
based on a bunch of heuristics, but it's able

00:32:22,020 --> 00:32:25,280
to sort of intelligently figure out what values it

00:32:25,280 --> 00:32:27,790
needs to throw into a function, and so you

00:32:27,790 --> 00:32:30,310
can find these errors very quickly, and then we

00:32:30,310 --> 00:32:34,880
can generate test cases based on this automatically.

00:32:34,880 --> 00:32:38,150
So if my power function wants to accept, or

00:32:38,150 --> 00:32:40,310
doesn't really, I could say like hey, don't pass

00:32:40,310 --> 00:32:42,840
thirty-three in cause my function doesn't accept that. I

00:32:42,840 --> 00:32:46,110
can also tell my symbolic execution engine, hey, don't

00:32:46,110 --> 00:32:49,310
try that number, and it can intelligently say, OK,

00:32:49,310 --> 00:32:51,490
fine, I won't try thirty-three, I won't try negative

00:32:51,490 --> 00:32:56,040
one, because that's, those are the contracts.

00:32:56,040 --> 00:33:01,250
So, what tools are out there for symbolic execution

00:33:01,250 --> 00:33:05,050
and stuff like that?

00:33:05,050 --> 00:33:08,400
If you use LLVM or LLVM based languages, there's

00:33:08,400 --> 00:33:11,530
a symbolic execution engine called KLEE, which can basically

00:33:11,530 --> 00:33:15,500
execute LLVM code, and turn those into, like, symbolically

00:33:15,500 --> 00:33:18,720
execute that. If you're using JavaScript there is a

00:33:18,720 --> 00:33:21,360
tool called Kudzu - I haven't, I haven't tried

00:33:21,360 --> 00:33:22,870
Kudzu so I don't really know how well it

00:33:22,870 --> 00:33:25,440
works, but it could do the same thing in

00:33:25,440 --> 00:33:26,410
JavaScript.

00:33:26,410 --> 00:33:29,350
And in Java and this other language called SPARK

00:33:29,350 --> 00:33:32,900
there's a tool called Kiasan, which is a symbolic

00:33:32,900 --> 00:33:36,350
execution engine for those languages.

00:33:36,350 --> 00:33:39,570
We don't have anything for Ruby in this space.

00:33:39,570 --> 00:33:43,490
I know this because I actually did my Master's

00:33:43,490 --> 00:33:47,030
on this subject, and that, that's my Masters there

00:33:47,030 --> 00:33:49,740
where I wrote a proof of concept for symbolic

00:33:49,740 --> 00:33:51,770
execution in Ruby, but it's very basic and I

00:33:51,770 --> 00:33:54,860
wouldn't recommend using it in any sense.

00:33:54,860 --> 00:33:59,260
But, but it, I mean, the, there is some

00:33:59,260 --> 00:34:04,350
work there, and it definitely needs more work.

00:34:04,350 --> 00:34:06,660
A lot of the reason that we don't have

00:34:06,660 --> 00:34:10,240
these kinds of low level linting and static analysis

00:34:10,240 --> 00:34:13,570
tools is because Ruby doesn't really have a scientific

00:34:13,570 --> 00:34:16,860
community. And I think that's kind of a really

00:34:16,860 --> 00:34:19,510
sad thing for us to like not really have

00:34:19,510 --> 00:34:22,790
the scientific community that Python has, or other languages

00:34:22,790 --> 00:34:26,909
have. Because we get things like those tools when

00:34:26,909 --> 00:34:28,659
we, when we have a scientific community. When we

00:34:28,659 --> 00:34:32,149
have these people who are interested in those things.

00:34:32,149 --> 00:34:35,810
And it's really a chicken and egg problem, because

00:34:35,810 --> 00:34:37,030
we don't have the tools that are available for

00:34:37,030 --> 00:34:39,510
scientists and then we sort of wonder why we

00:34:39,510 --> 00:34:42,840
don't have scientists that are using our language. So

00:34:42,840 --> 00:34:49,110
we really need to start developing these tools.

00:34:49,110 --> 00:34:53,200
So Bryan Liles is actually speaking today. He, he

00:34:53,200 --> 00:34:56,570
spoke about this at [00:34:54]?? RubyConf, and he's actually

00:34:56,570 --> 00:35:01,410
giving a talk on scientific Ruby code, you know,

00:35:01,410 --> 00:35:05,340
using Ruby code with, in scientific applications. And he's

00:35:05,340 --> 00:35:08,510
probably gonna mention this, this Python versus Ruby thing,

00:35:08,510 --> 00:35:14,310
and basically, yeah, we definitely need more, we, it,

00:35:14,310 --> 00:35:18,070
we don't really have enough scientific tools in our

00:35:18,070 --> 00:35:20,530
community, and we could definitely use more.

00:35:20,530 --> 00:35:23,570
So I'm just gonna sort of jump over what

00:35:23,570 --> 00:35:30,140
I talked about here. We are really good at

00:35:30,140 --> 00:35:33,490
testing, deployment tools, web frameworks. We have really awesome

00:35:33,490 --> 00:35:37,290
tools for those subjects. We have RSpec, we have

00:35:37,290 --> 00:35:39,610
mini tasks, we have like literally hundreds of gems

00:35:39,610 --> 00:35:41,270
when it comes to testing.

00:35:41,270 --> 00:35:46,870
WE do really good at those subjects, but we

00:35:46,870 --> 00:35:49,770
sort of get really focused on those subjects and

00:35:49,770 --> 00:35:52,880
we don't really do well on other subjects. So

00:35:52,880 --> 00:35:56,260
we're not very good at visualization, refactoring tools, profiling

00:35:56,260 --> 00:35:58,310
tools - we don't really have very many. And

00:35:58,310 --> 00:36:00,300
when we do they don't really work well, so

00:36:00,300 --> 00:36:05,130
Ruby, Ruby debug 1.9, this Ruby debug 1.9 gem,

00:36:05,130 --> 00:36:06,910
that took three years after Ruby 1.9 came out

00:36:06,910 --> 00:36:10,410
to actually exist, is an example of that kind

00:36:10,410 --> 00:36:17,270
of thing that we're missing.

00:36:17,270 --> 00:36:19,820
We attract, we tend to attract web developers because

00:36:19,820 --> 00:36:21,900
we have the tools for web developers. We have

00:36:21,900 --> 00:36:24,060
good testing tools, we have good web frameworks, we

00:36:24,060 --> 00:36:29,810
have good deployment tools. So we attract web developers.

00:36:29,810 --> 00:36:33,500
Should we not try to attract a different set

00:36:33,500 --> 00:36:37,090
of developers to our language, by developing tools for

00:36:37,090 --> 00:36:40,620
those people?

00:36:40,620 --> 00:36:44,390
Having a broader audience is, when you have a

00:36:44,390 --> 00:36:49,390
language, is important, and it's important because when a

00:36:49,390 --> 00:36:52,100
broader audience comes to your language, they come in

00:36:52,100 --> 00:36:57,690
with a broader set of priorities. So a scientific,

00:36:57,690 --> 00:37:00,580
a science, someone who's doing science with Ruby is

00:37:00,580 --> 00:37:02,600
going to be much more interested in the performance

00:37:02,600 --> 00:37:05,940
of your interpreter than someone who's doing web development.

00:37:05,940 --> 00:37:08,350
Doesn't really have a CPU ?? [00:37:08]

00:37:08,350 --> 00:37:10,640
And so if we had more of these, of

00:37:10,640 --> 00:37:12,470
the people in the scientific community, in the Ruby

00:37:12,470 --> 00:37:15,520
community, we would probably have a larger priority on

00:37:15,520 --> 00:37:18,560
improving performance of our interpreter.

00:37:18,560 --> 00:37:19,870
And then we might end up with a much

00:37:19,870 --> 00:37:22,510
faster interpreter in the end. SO having this broader

00:37:22,510 --> 00:37:28,450
audience definitely improves the language in the end.

00:37:28,450 --> 00:37:29,990
We have to take responsibility of the fact that

00:37:29,990 --> 00:37:33,110
we don't have a scinetific community. They're not here,

00:37:33,110 --> 00:37:34,930
it's not, we can't just say, oh why aren't

00:37:34,930 --> 00:37:37,440
scientific, why isn't the scientific community here, or why

00:37:37,440 --> 00:37:40,590
isn't the engineering community here. It's sort of our

00:37:40,590 --> 00:37:42,550
fault because we don't have the tools available for

00:37:42,550 --> 00:37:45,320
them. SO I think it's important to actually say,

00:37:45,320 --> 00:37:47,280
like, if you actually are interested in this kind

00:37:47,280 --> 00:37:48,700
of thing, that you go out there and you

00:37:48,700 --> 00:37:53,940
do become a garbage collector and write these tools.

00:37:53,940 --> 00:37:56,360
The good thing is that there are great tool

00:37:56,360 --> 00:38:01,010
ideas just waiting to be implemented. There are literally

00:38:01,010 --> 00:38:04,990
tons of research papers in the fields I mentioned.

00:38:04,990 --> 00:38:07,430
If you go trolling on scholar dot google dot

00:38:07,430 --> 00:38:09,070
com, you will, and just type in some field

00:38:09,070 --> 00:38:11,830
that you're interested in, there are literally tons of

00:38:11,830 --> 00:38:14,310
papers on this stuff.

00:38:14,310 --> 00:38:16,590
I had a whole section on some of my

00:38:16,590 --> 00:38:19,660
favorite research papers on, in this talk, and I

00:38:19,660 --> 00:38:21,050
had to cut it out cause there's not enough

00:38:21,050 --> 00:38:23,150
time, but if you want to talk about this

00:38:23,150 --> 00:38:25,210
stuff, you can come find me and I can

00:38:25,210 --> 00:38:27,730
list off some titles of some really cool talks,

00:38:27,730 --> 00:38:31,110
some really cool papers. Reading papers might seem daunting

00:38:31,110 --> 00:38:32,540
if you've never done it before, and it was

00:38:32,540 --> 00:38:35,230
to me before I had, and once you read

00:38:35,230 --> 00:38:38,600
a couple, and you sort of, like, ingest it

00:38:38,600 --> 00:38:41,040
slowly, it becomes much more natural, and it's really

00:38:41,040 --> 00:38:43,800
not as scary as it seems. So I would

00:38:43,800 --> 00:38:47,240
recommend not being scared by research papers.

00:38:47,240 --> 00:38:51,920
Some of them actually read very nicely. And with

00:38:51,920 --> 00:38:54,540
that, I want to thank you guys for letting

00:38:54,540 --> 00:38:59,120
me speak. If there are any questions, feel free

00:38:59,120 --> 00:39:01,000

YouTube URL: https://www.youtube.com/watch?v=RkTtyo2kydg


