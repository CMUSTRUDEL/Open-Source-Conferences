Title: Ruby Conf 2013 - That's Not Very Ruby of You by Ernie Miller
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	How Ruby is your Ruby? As we've found our way to Ruby, we've all brought with us habits and idioms from the languages we know and love (or hate). Sometimes, these habits serve us well, and other times, they make our lives more difficult. More often, they make life difficult for our collaborators, who don't expect to see C, Java, or PHP in their Ruby codebase.

Not only that, as many new Rubyists have found their way to Ruby from Rails, they've brought along various Rails-isms, some of which aren't even a good idea in Rails-land (callbacks, anyone?), or dependencies on libraries like ActiveSupport which are overkill for their real needs.

We'll talk about some of the baggage we bring to our Ruby code, and some simple techniques that will help us leave it behind.

Help us caption & translate this video!

http://amara.org/v/FG4z/
Captions: 
	00:00:16,000 --> 00:00:20,300
ERNIE MILLER: Good morning. Wow. Now it's all downhill from here.

00:00:20,380 --> 00:00:24,300
I am really, really excited and blessed to be

00:00:24,300 --> 00:00:28,009
here with you all today. I'm, I just started

00:00:28,009 --> 00:00:31,359
doing talks this year. You may know that if

00:00:31,359 --> 00:00:33,760
you've seen any of the other ones. And I

00:00:33,760 --> 00:00:35,150
never in a million years thought that, when I

00:00:35,150 --> 00:00:37,180
made a New Years resolution to speak that, by

00:00:37,180 --> 00:00:38,190
the end of the year, I would be here

00:00:38,190 --> 00:00:41,040
with some of the best minds in the community

00:00:41,040 --> 00:00:42,470
that I call home.

00:00:42,470 --> 00:00:45,190
So I'm really psyched about that. It's weird, because,

00:00:45,190 --> 00:00:49,120
in previous years, I had always found myself being

00:00:49,120 --> 00:00:50,530
asked, like, what's your talk on. I'm like, I

00:00:50,530 --> 00:00:52,870
don't speak, what are you talking about?

00:00:52,870 --> 00:00:55,600
For whatever reason, this year, most people have been

00:00:55,600 --> 00:00:59,270
asking me two questions. Who are you? And, oh,

00:00:59,270 --> 00:01:01,870
you're speaking? And, so yesterday morning, I had the

00:01:01,870 --> 00:01:05,350
opportunity to meet one of our Opportunity Scholars, and

00:01:05,350 --> 00:01:09,200
her guide. And I was talking to the guide,

00:01:09,200 --> 00:01:11,539
and I introduced myself. He says, oh, Ernie Miller.

00:01:11,539 --> 00:01:15,299
I know you. Why do I know you? And

00:01:15,299 --> 00:01:18,960
I'm thinking, yeah, yeah, finally somebody actually knows, like,

00:01:18,960 --> 00:01:20,060
what I'm doing here.

00:01:20,060 --> 00:01:27,060
And he says, you're the bird guy! So I

00:01:29,409 --> 00:01:32,659
may be the bird guy to you. That's OK.

00:01:32,659 --> 00:01:34,420
I think that's pretty cool. Lord of the birds.

00:01:34,420 --> 00:01:37,159
Lord of the gulls.

00:01:37,159 --> 00:01:38,999
You should totally ask me about Appriss. I just

00:01:38,999 --> 00:01:41,560
started working there about three weeks ago, and it's

00:01:41,560 --> 00:01:44,729
a very meaningful job that I'm doing. We literally

00:01:44,729 --> 00:01:48,259
save lives. And they were so awesome to be

00:01:48,259 --> 00:01:50,240
like, two and a half weeks into my employment,

00:01:50,240 --> 00:01:52,579
sure, yeah, we'll send you to RubyConf, no problem.

00:01:52,579 --> 00:01:54,409
I would very much like them to continue to

00:01:54,409 --> 00:01:56,509
do things like this for me. So ask me

00:01:56,509 --> 00:01:58,719
about Appriss.

00:01:58,719 --> 00:02:01,090
So if you were at RailsConf, you saw Erin's

00:02:01,090 --> 00:02:05,999
keynote. It was A flat. And it really, let's

00:02:05,999 --> 00:02:09,179
just say, it struck a chord with me. I

00:02:09,179 --> 00:02:14,390
mean it, it really set the bar. It made

00:02:14,390 --> 00:02:20,500
me want to. It made me want to be

00:02:20,500 --> 00:02:21,849
a better coda.

00:02:21,849 --> 00:02:26,519
All right. All right. More, more than fugue of

00:02:26,519 --> 00:02:28,360
you look to be getting tired of this. I

00:02:28,360 --> 00:02:30,500
better stop fiddling around before I beat it to

00:02:30,500 --> 00:02:34,810
death. OK. Let's duet.

00:02:34,810 --> 00:02:36,319
So this is my, gonna be my keynote. I

00:02:36,319 --> 00:02:39,989
really thought, really long and hard about it. It's

00:02:39,989 --> 00:02:45,379
C#. You, you may have heard of it. I

00:02:45,379 --> 00:02:47,920
think it's gonna be huge. It's gonna be, it's

00:02:47,920 --> 00:02:49,170
gonna be awesome.

00:02:49,170 --> 00:02:52,189
So what is Ruby? That seems like a really

00:02:52,189 --> 00:02:53,849
kind of silly question to ask a room full

00:02:53,849 --> 00:02:59,040
of Rubyists. So I ask it, because, like, is

00:02:59,040 --> 00:03:03,099
this Ruby? No? That looks like C to me.

00:03:03,099 --> 00:03:04,719
It looks like C written by somebody who sucks

00:03:04,719 --> 00:03:06,569
at it.

00:03:06,569 --> 00:03:13,040
How about now? Is it Ruby?

00:03:13,040 --> 00:03:14,560
How about now?

00:03:14,560 --> 00:03:21,420
It runs. Oh, it gets worse from here, guys.

00:03:21,420 --> 00:03:26,930
How about this? Is this Ruby? I think we

00:03:26,930 --> 00:03:30,680
all can agree we're thankful that it's not. What

00:03:30,680 --> 00:03:37,680
about now? What about now? Is it Ruby?

00:03:42,129 --> 00:03:48,840
So, so one thing, this is obvious very different

00:03:48,840 --> 00:03:52,989
from PHP. The, the method naming and argument order

00:03:52,989 --> 00:03:57,390
is much more consistent in this. So.

00:03:57,390 --> 00:03:58,489
It runs.

00:03:58,489 --> 00:04:01,870
How about this? What's this look like? Is this,

00:04:01,870 --> 00:04:04,189
is this Ruby?

00:04:04,189 --> 00:04:06,249
What if I change the function keywords to stabby

00:04:06,249 --> 00:04:10,599
lambdas and I add a period before that check

00:04:10,599 --> 00:04:17,599
over there? How about now? I'm especially proud of

00:04:20,519 --> 00:04:22,940
this comment.

00:04:22,940 --> 00:04:29,180
All right, one more. I think I'm making my

00:04:29,180 --> 00:04:33,310
point. How about this? So I learned something about

00:04:33,310 --> 00:04:35,389
Python. I haven't spent a lot of time doing

00:04:35,389 --> 00:04:38,970
Python. That it's basically just a bucket of attributes.

00:04:38,970 --> 00:04:43,160
You can assign anything to anything, essentially. I was

00:04:43,160 --> 00:04:45,270
kind of surprised by that. There's no, like, real

00:04:45,270 --> 00:04:46,800
instance variables.

00:04:46,800 --> 00:04:50,139
OK, you might say, you might say that using

00:04:50,139 --> 00:04:51,889
a one, I'm not sure if you can tell,

00:04:51,889 --> 00:04:54,919
these are ones now. You might say that's cheating.

00:04:54,919 --> 00:05:00,370
I say it makes it extra leet, personally.

00:05:00,370 --> 00:05:03,639
Is it Ruby now? This tiny little bit of

00:05:03,639 --> 00:05:08,400
code here. It makes it work.

00:05:08,400 --> 00:05:10,699
One more question for you. If your code has

00:05:10,699 --> 00:05:17,699
a syntax error, does it stop being Ruby?

00:05:20,360 --> 00:05:22,120
So I guess the point I'm trying to make

00:05:22,120 --> 00:05:25,970
is that I don't believe that it's the interpreter

00:05:25,970 --> 00:05:30,789
that decides what is and isn't Ruby, right. I

00:05:30,789 --> 00:05:34,020
think it's the people.

00:05:34,020 --> 00:05:38,139
And that's cool, because Matz designed Ruby to increase

00:05:38,139 --> 00:05:41,419
programmer happiness, right. Interpreters don't get happy, right. People

00:05:41,419 --> 00:05:43,990
get happy. So then the answer to what is

00:05:43,990 --> 00:05:48,340
Ruby is, duh, Ruby is a language.

00:05:48,340 --> 00:05:51,550
But what is a language, really? A language is

00:05:51,550 --> 00:05:56,599
a tool for telling stories. And so by extension

00:05:56,599 --> 00:06:01,160
then, that makes us storytellers. And, I mean, even

00:06:01,160 --> 00:06:03,370
when you think you're not telling a story, you're

00:06:03,370 --> 00:06:05,629
telling a story.

00:06:05,629 --> 00:06:08,310
For instance, anybody that's working on a team has

00:06:08,310 --> 00:06:11,110
probably opened a file in their repo to something

00:06:11,110 --> 00:06:18,110
like this. It tells a story.

00:06:19,150 --> 00:06:22,169
Or this one. This one, this one here just

00:06:22,169 --> 00:06:25,349
cries out, like, I have no idea how I'm

00:06:25,349 --> 00:06:29,720
gonna make this work. All kinds of puts statements

00:06:29,720 --> 00:06:32,470
all over the place commented out and left in.

00:06:32,470 --> 00:06:33,720
And if there was any doubt that Ruby was

00:06:33,720 --> 00:06:36,930
a language, it also has dialects, right.

00:06:36,930 --> 00:06:38,949
So you all may be familiar with this style

00:06:38,949 --> 00:06:45,949
of coding. It tells a story as well.

00:06:51,259 --> 00:06:54,120
So before we go any further, I want to

00:06:54,120 --> 00:06:56,349
talk a little bit about some knits that I

00:06:56,349 --> 00:06:59,639
want to pick. I don't want to waste anyone's

00:06:59,639 --> 00:07:00,690
time, but you know, they did let me come

00:07:00,690 --> 00:07:02,270
up here on stage, so I definitely have to

00:07:02,270 --> 00:07:03,810
pick a few knits.

00:07:03,810 --> 00:07:07,349
Does this make you recoil? It makes me recoil

00:07:07,349 --> 00:07:11,099
when I see it, right. So one thing that

00:07:11,099 --> 00:07:13,199
defines Ruby, for me, is the way that we

00:07:13,199 --> 00:07:17,280
format our code, in a lot of ways.

00:07:17,280 --> 00:07:19,300
This makes me feel a lot better, like, just

00:07:19,300 --> 00:07:22,639
seeing it like this, right.

00:07:22,639 --> 00:07:24,550
Soft tabs and two spaces. That's the way we

00:07:24,550 --> 00:07:29,039
format. The, the train has left the station. Sorry,

00:07:29,039 --> 00:07:31,849
people that want hard tabs. And also, if you

00:07:31,849 --> 00:07:35,389
can use vertical space to separate ideas, you'll make

00:07:35,389 --> 00:07:39,150
life much, much easier for your coworkers.

00:07:39,150 --> 00:07:42,440
Here's another thing that really drives me nuts. Really

00:07:42,440 --> 00:07:45,229
makes me crazy. I'm not sure if there's like

00:07:45,229 --> 00:07:47,919
a byte shortage or something like we need to,

00:07:47,919 --> 00:07:49,889
we need to save the bytes, but if it's

00:07:49,889 --> 00:07:54,930
not self-explanatory, your variables are definitely not x, unless,

00:07:54,930 --> 00:07:59,310
you know, right.

00:07:59,310 --> 00:08:04,409
OK. Here's another one. I'm sure you guys now

00:08:04,409 --> 00:08:07,050
are, like, oh you don't want short variable names,

00:08:07,050 --> 00:08:14,050
I'll show you. Yeah.

00:08:16,580 --> 00:08:18,449
You're very original.

00:08:18,449 --> 00:08:21,169
Though, to be fair, I would much rather see

00:08:21,169 --> 00:08:22,669
that than x and i.

00:08:22,669 --> 00:08:27,689
Oh, how about this one. You seen Ruby code

00:08:27,689 --> 00:08:34,689
like this? Uh-huh, every day is hump day, right.

00:08:36,550 --> 00:08:39,909
So we have a lot of refugees from Java

00:08:39,909 --> 00:08:43,990
in our community. I don't know why they would

00:08:43,990 --> 00:08:46,560
really want to bring that baggage along with them,

00:08:46,560 --> 00:08:49,220
but, also there's a link down in the bottom.

00:08:49,220 --> 00:08:52,019
It'll be in the slides when we put them

00:08:52,019 --> 00:08:55,120
online. It's a study about how CamelCase is actually

00:08:55,120 --> 00:08:56,029
slower to read.

00:08:56,029 --> 00:08:59,790
And we read, we read and pick out parts

00:08:59,790 --> 00:09:02,430
of code much more frequently than we write it.

00:09:02,430 --> 00:09:06,550
So optimizing for readability - again, we're storytellers.

00:09:06,550 --> 00:09:10,290
This is another one. Explicit return. I don't know

00:09:10,290 --> 00:09:12,300
why it makes me so crazy. It's just like,

00:09:12,300 --> 00:09:15,670
extra words. Not necessary. Everything has a value. Simplest

00:09:15,670 --> 00:09:18,510
case, you can remove it. More likely, if you're

00:09:18,510 --> 00:09:20,370
a Rubyist, you're gonna say something like this. You're

00:09:20,370 --> 00:09:22,589
gonna actually just return 100 at the begin, say

00:09:22,589 --> 00:09:25,290
OK, we're gonna normalize zero to a hundred, and

00:09:25,290 --> 00:09:28,510
avoid that more expensive normalized_distance calculation.

00:09:28,510 --> 00:09:31,320
Everything's backwards but it's gonna be all right. So

00:09:31,320 --> 00:09:33,779
those are my nitpicks. Let's go on to some

00:09:33,779 --> 00:09:36,370
baggage that we bring.

00:09:36,370 --> 00:09:40,260
I came to Ruby from Perl, which is a

00:09:40,260 --> 00:09:42,750
much more procedural style language.

00:09:42,750 --> 00:09:45,709
A good friend of mine, and you know, it's

00:09:45,709 --> 00:09:48,019
not uncommon for us to write things like this,

00:09:48,019 --> 00:09:51,560
in more procedural style languages, if we're making our

00:09:51,560 --> 00:09:56,000
life miserable for good reason. And a friend of

00:09:56,000 --> 00:09:57,800
mine used to describe my code, back when I

00:09:57,800 --> 00:10:01,660
was writing Perl, as looking like a space ship.

00:10:01,660 --> 00:10:05,730
And he's right. It, it, it does. It totally

00:10:05,730 --> 00:10:07,810
looks like a space ship.

00:10:07,810 --> 00:10:10,930
If you zoom out, especially, it really does.

00:10:10,930 --> 00:10:16,839
You know, that tells a story, too. It's trying

00:10:16,839 --> 00:10:21,639
to decipher, trying to decipher this code is like

00:10:21,639 --> 00:10:23,550
reading a which way book or choose your own

00:10:23,550 --> 00:10:26,899
adventure book from front to back. It, it's very,

00:10:26,899 --> 00:10:29,649
very difficult to make sense of.

00:10:29,649 --> 00:10:32,100
So I guess my point there would be that,

00:10:32,100 --> 00:10:33,700
you know, in procedural languages, we tend to just

00:10:33,700 --> 00:10:35,680
kind of create these buckets of logic, and we

00:10:35,680 --> 00:10:37,060
just throw them in a method and that's all

00:10:37,060 --> 00:10:39,810
we do.

00:10:39,810 --> 00:10:41,920
You can't have that. That's not good. One thing

00:10:41,920 --> 00:10:43,889
that I've used, and this is gonna get some

00:10:43,889 --> 00:10:48,029
mixed response I assume, is 80-column lines. That's a

00:10:48,029 --> 00:10:51,639
constraint I put on myself. Not because, like, screen

00:10:51,639 --> 00:10:54,620
real estate is that expensive, but it's an early

00:10:54,620 --> 00:10:56,040
warning system.

00:10:56,040 --> 00:10:58,630
And also, again, I talk about making code more

00:10:58,630 --> 00:11:01,990
readable, we are storytellers. Do you open up a

00:11:01,990 --> 00:11:05,029
newspaper and look at it like this? I mean,

00:11:05,029 --> 00:11:07,339
I don't. I, I read things much easier when

00:11:07,339 --> 00:11:09,430
I can scan lines and, and so I think

00:11:09,430 --> 00:11:11,040
that short lines help.

00:11:11,040 --> 00:11:12,690
If nothing else, it stops you and makes you

00:11:12,690 --> 00:11:14,380
think, do I, am I really, if it starts

00:11:14,380 --> 00:11:16,470
to get uncomfortable, am I really doing the right

00:11:16,470 --> 00:11:17,720
thing here?

00:11:17,720 --> 00:11:22,760
Here's something else I used to do. We create

00:11:22,760 --> 00:11:24,839
these sort of buckets of methods because we don't

00:11:24,839 --> 00:11:26,560
know where the things need to live, and we

00:11:26,560 --> 00:11:29,610
make a utility module or utility class. You can't

00:11:29,610 --> 00:11:33,519
have buckets of methods. That's not OK.

00:11:33,519 --> 00:11:36,720
And class is a descendant of module. So it's

00:11:36,720 --> 00:11:38,730
important to remember that what applies to module also

00:11:38,730 --> 00:11:42,579
applies to class.

00:11:42,579 --> 00:11:46,010
Something else that we tend to do. We think,

00:11:46,010 --> 00:11:48,540
and I'm not gonna name names here, certain, certain

00:11:48,540 --> 00:11:52,829
libraries maybe have hashes that they use for, for

00:11:52,829 --> 00:11:57,449
lists of attributes that respond to a particular object.

00:11:57,449 --> 00:11:59,310
That works out OK at first, and then you

00:11:59,310 --> 00:12:01,839
decide you need to type cast those attributes and

00:12:01,839 --> 00:12:03,810
so now the type casting logic lives in the

00:12:03,810 --> 00:12:06,850
thing that's holding the hash.

00:12:06,850 --> 00:12:11,089
You can't have buckets of data, either. And something

00:12:11,089 --> 00:12:13,060
that you might want to do instead is to

00:12:13,060 --> 00:12:16,730
have an attributes object, right, because that's what we

00:12:16,730 --> 00:12:18,990
do. And then it can handle that casting for

00:12:18,990 --> 00:12:19,660
you.

00:12:19,660 --> 00:12:21,019
But we don't normally see it in these kind

00:12:21,019 --> 00:12:23,779
of isolated cases. Usually we get to some place

00:12:23,779 --> 00:12:26,310
like this, first. Don't read it, it's just gonna

00:12:26,310 --> 00:12:32,769
hurt you. We normally catch ourselves around this point,

00:12:32,769 --> 00:12:36,040
and thinking in terms of objects helps us to

00:12:36,040 --> 00:12:37,829
get from this to this.

00:12:37,829 --> 00:12:40,589
Now I'm not saying this is a good refactoring,

00:12:40,589 --> 00:12:42,670
necessarily, but it does at least mean that someone

00:12:42,670 --> 00:12:47,269
has given some thought to, at creating some objects,

00:12:47,269 --> 00:12:48,949
right. I'm not sure this is the right level

00:12:48,949 --> 00:12:51,120
of refactoring, I guess is what I'm saying.

00:12:51,120 --> 00:12:54,970
But, it's certainly better than the alternative.

00:12:54,970 --> 00:12:57,800
So you may be saying that's way too many

00:12:57,800 --> 00:13:00,250
objects. And I'm, again, I'm not arguing the modeling

00:13:00,250 --> 00:13:04,959
is perfect, but we are working in object-oriented programming,

00:13:04,959 --> 00:13:09,220
are we not? If we were doing awesome-oriented programming,

00:13:09,220 --> 00:13:11,230
would you be telling me, that's just too much

00:13:11,230 --> 00:13:15,860
awesome. We can't, we can't have that much awesome.

00:13:15,860 --> 00:13:18,889
And, and modeling is really where the magic happens.

00:13:18,889 --> 00:13:24,100
It's where you move from these buckets of things

00:13:24,100 --> 00:13:27,209
and you start to begin to, to describe things

00:13:27,209 --> 00:13:29,910
in terms of objects. You go from a descriptive

00:13:29,910 --> 00:13:34,019
description of the situation to being prescriptive, to being

00:13:34,019 --> 00:13:37,199
able to say, here is my mental model, right.

00:13:37,199 --> 00:13:39,860
It's, the value in doing this modeling activity is

00:13:39,860 --> 00:13:42,079
that you get to go ahead and re-frame the

00:13:42,079 --> 00:13:44,769
problem, right.

00:13:44,769 --> 00:13:50,769
And it's all about naming things. So we all

00:13:50,769 --> 00:13:53,740
know Sandy's got a list of rules that is

00:13:53,740 --> 00:13:59,430
about creating more maintainable code. And we love rules,

00:13:59,430 --> 00:14:05,540
as a community. I think one of the biggest

00:14:05,540 --> 00:14:09,180
pay-offs of following rules, like having short method names,

00:14:09,180 --> 00:14:13,170
having short class names, is that it forces us

00:14:13,170 --> 00:14:16,779
to give names to the code.

00:14:16,779 --> 00:14:20,820
Any Game of Thrones fans out there? Yeah? How

00:14:20,820 --> 00:14:23,790
many of you actually read the books? All right.

00:14:23,790 --> 00:14:25,600
I'm gonna find out if you're lying later.

00:14:25,600 --> 00:14:29,380
All right. So, have you ever tried discussing the

00:14:29,380 --> 00:14:32,300
Song of Ice and Fire series with someone?

00:14:32,300 --> 00:14:36,490
It's, it's tricky, right. There's a lot going on.

00:14:36,490 --> 00:14:38,360
You want to do it in hard mode, try

00:14:38,360 --> 00:14:40,399
having a conversation about a Song of Ice and

00:14:40,399 --> 00:14:46,170
Fire without using any names. Just describe the, you

00:14:46,170 --> 00:14:48,300
know, this guy over here who's the son- you'd

00:14:48,300 --> 00:14:49,839
have to go all the way back to the

00:14:49,839 --> 00:14:52,339
beginning, right, to describe anything.

00:14:52,339 --> 00:14:55,360
But, the names are what we attach characteristics and

00:14:55,360 --> 00:14:59,320
relationships to. I can say Terrian Lannister - you

00:14:59,320 --> 00:15:01,509
know who it is. I can say Red Wedding.

00:15:01,509 --> 00:15:03,269
You know what I'm referring to, and if you're

00:15:03,269 --> 00:15:06,740
just watching the show, I'm not gonna explain it.

00:15:06,740 --> 00:15:12,310
We are storytellers. Putting things in random buckets doesn't

00:15:12,310 --> 00:15:15,810
work. You need to name your characters, your classes,

00:15:15,810 --> 00:15:18,279
your modules. You need to name their actions, the

00:15:18,279 --> 00:15:20,829
methods that they perform.

00:15:20,829 --> 00:15:23,410
We find it hard to name things because naming

00:15:23,410 --> 00:15:25,620
something requires us to have some idea of what

00:15:25,620 --> 00:15:30,279
we think it's going to be. But the naming

00:15:30,279 --> 00:15:33,690
often comes before the knowing. Don't get too hung

00:15:33,690 --> 00:15:36,850
up, early on. We all know you can change

00:15:36,850 --> 00:15:40,800
names. Ah, OK, a few of you actually read

00:15:40,800 --> 00:15:45,430
the books. You know what I'm talking about.

00:15:45,430 --> 00:15:48,579
So if we are storytellers, here's a, here's a

00:15:48,579 --> 00:15:50,899
book for us. We've all probably had to look

00:15:50,899 --> 00:15:55,230
at it. Oh, hey. Wow, it has fans. OK.

00:15:55,230 --> 00:15:57,610
Who would have thought?

00:15:57,610 --> 00:15:59,579
There is a, there is a paragraph in that

00:15:59,579 --> 00:16:01,470
book that I think applies to coding as much

00:16:01,470 --> 00:16:03,860
as it applies to, to any other kind of

00:16:03,860 --> 00:16:09,170
language. Vigorous writing is concise. A sentence should contain

00:16:09,170 --> 00:16:12,360
no unnecessary words. A paragraph, no unnecessary sentences, for

00:16:12,360 --> 00:16:14,829
the same reason that a drawing should have no

00:16:14,829 --> 00:16:19,579
unnecessary lines and a machine no unnecessary parts.

00:16:19,579 --> 00:16:23,019
This requires not that the writer make all sentences

00:16:23,019 --> 00:16:25,889
short, or avoid all detail and treat subjects only

00:16:25,889 --> 00:16:30,290
in outline, but that every word tell.

00:16:30,290 --> 00:16:32,589
We get really, moving on from baggage from other

00:16:32,589 --> 00:16:36,329
languages, in the Ruby community, we get very, very

00:16:36,329 --> 00:16:39,519
focused on expressiveness. We like to throw that term

00:16:39,519 --> 00:16:44,290
around, right. And it's an extremely powerful language. We

00:16:44,290 --> 00:16:46,990
can redefine things to do exactly what we want

00:16:46,990 --> 00:16:51,949
them to do, with mixed results.

00:16:51,949 --> 00:16:54,959
Ruby reads beautifully out of the box. And it

00:16:54,959 --> 00:16:56,959
also gives us this power to extend the language

00:16:56,959 --> 00:16:59,120
that we require. In fact I think that it's

00:16:59,120 --> 00:17:01,440
flexibility is one of its most endearing qualities. It

00:17:01,440 --> 00:17:02,829
gets out of the way and lets you tell

00:17:02,829 --> 00:17:05,440
the story that you want to tell. It's, one

00:17:05,440 --> 00:17:07,380
of the things that makes me really happy. But

00:17:07,380 --> 00:17:08,850
if there's one thing we've learned from Peter Parker's

00:17:08,850 --> 00:17:15,150
Uncle Ben, it's that, with great power comes- right.

00:17:15,150 --> 00:17:16,550
Great responsibility.

00:17:16,550 --> 00:17:20,640
So let's talk a little about monkey patching.

00:17:20,640 --> 00:17:27,640
Yeah. Evan sighs very loudly. All right.

00:17:27,940 --> 00:17:29,950
So, somewhere along the line, we started to get

00:17:29,950 --> 00:17:32,700
the idea that expressiveness is the same thing as

00:17:32,700 --> 00:17:37,010
making it English-like. The thing about it is, is

00:17:37,010 --> 00:17:39,980
Ruby is a language of its own. Just like

00:17:39,980 --> 00:17:41,520
English, right.

00:17:41,520 --> 00:17:45,460
In English, we borrow words, like cappuccino, like espresso,

00:17:45,460 --> 00:17:47,250
right, but it doesn't mean that for the entire

00:17:47,250 --> 00:17:48,820
time that we're in the coffee shop we must

00:17:48,820 --> 00:17:53,910
speak Italian. Ruby borrows language from English when it

00:17:53,910 --> 00:17:56,390
makes sense.

00:17:56,390 --> 00:17:59,060
So we know arrays have a first and a

00:17:59,060 --> 00:18:01,220
last method, right. We can refer to the first

00:18:01,220 --> 00:18:07,670
or last element in our array. It's handy. So

00:18:07,670 --> 00:18:11,710
along comes someone and says, well, if first and

00:18:11,710 --> 00:18:15,030
last are good, let's have second and third and

00:18:15,030 --> 00:18:19,330
fourth and fifth and forty-two, not forty-second. Because that

00:18:19,330 --> 00:18:22,090
gotta be, that has to be better, right.

00:18:22,090 --> 00:18:28,190
I say why stop there? I mean, array penultimate.

00:18:28,190 --> 00:18:31,970
Array ante penultimate. Why not? I mean, it works.

00:18:31,970 --> 00:18:37,120
Look how expressive.

00:18:37,120 --> 00:18:41,130
If only there were some way that we, as

00:18:41,130 --> 00:18:43,890
people, could, could index into any element in the

00:18:43,890 --> 00:18:45,510
array, so we wouldn't have to define all these

00:18:45,510 --> 00:18:48,960
methods. I mean, I don't know, like we could

00:18:48,960 --> 00:18:52,780
use, like positive numbers to go forward and negative

00:18:52,780 --> 00:18:55,290
numbers to go from the back. It would be

00:18:55,290 --> 00:18:59,200
really handy, wouldn't it?

00:18:59,200 --> 00:19:01,710
So we all know we can ask an array

00:19:01,710 --> 00:19:06,390
to tell us if it includes an object. Some

00:19:06,390 --> 00:19:07,810
point along the line, we decided it would be

00:19:07,810 --> 00:19:09,440
better to ask the object whether or not it's

00:19:09,440 --> 00:19:13,140
in something. This is simplified from the real code.

00:19:13,140 --> 00:19:18,450
And, I mean, I guess it reads like English,

00:19:18,450 --> 00:19:21,780
right. Second in array. But there's one problem with

00:19:21,780 --> 00:19:24,290
this, right. Objects should be in the dark about

00:19:24,290 --> 00:19:29,080
where they're living, right. You ask an object to

00:19:29,080 --> 00:19:31,520
tell you whether it contains something. You don't ask

00:19:31,520 --> 00:19:33,400
an object to know what - I mean, this

00:19:33,400 --> 00:19:35,890
sounds like, super like, philosophical, right - for an

00:19:35,890 --> 00:19:41,440
object to find itself, right.

00:19:41,440 --> 00:19:43,840
The container knows what it contains. So here are

00:19:43,840 --> 00:19:45,640
a couple of questions you might want to ask

00:19:45,640 --> 00:19:49,310
yourself before you monkey patch.

00:19:49,310 --> 00:19:51,700
Does it address a real problem? You know, maybe

00:19:51,700 --> 00:19:53,730
it simplifies a pattern you see all over your

00:19:53,730 --> 00:19:56,570
app. Symbol to proc is a great example of

00:19:56,570 --> 00:19:58,130
this, right. I love that. That came from a

00:19:58,130 --> 00:20:02,030
monkey patch.

00:20:02,030 --> 00:20:04,470
Does it follow OO principles, right? Does it make

00:20:04,470 --> 00:20:06,190
sense for the method to live in the class

00:20:06,190 --> 00:20:09,510
you're patching? Are you adding functionality to a class

00:20:09,510 --> 00:20:11,140
in order to use it as the stand-in for

00:20:11,140 --> 00:20:13,670
a real object? That's a no-no, that's a really

00:20:13,670 --> 00:20:15,200
smelly smell.

00:20:15,200 --> 00:20:17,680
And this is pertaining to applications, right. If you're

00:20:17,680 --> 00:20:19,980
writing gems on top of that, you also want

00:20:19,980 --> 00:20:21,510
to be very careful that you're not stomping all

00:20:21,510 --> 00:20:24,100
over, you know, namespaces that other people might want

00:20:24,100 --> 00:20:27,020
to use.

00:20:27,020 --> 00:20:30,890
So with that in mind, let's talk about class

00:20:30,890 --> 00:20:33,840
macros. This is something that we love in the

00:20:33,840 --> 00:20:37,160
Ruby community, right. The fun thing about metaprogramming is

00:20:37,160 --> 00:20:39,590
that the problem is boring, writing the program to

00:20:39,590 --> 00:20:41,940
solve the problem makes it more interesting, and we

00:20:41,940 --> 00:20:44,500
like interesting, right.

00:20:44,500 --> 00:20:51,060
And it's, it's been said that good programmers are

00:20:51,060 --> 00:20:53,330
lazy. So if we can write code that writes

00:20:53,330 --> 00:20:55,350
code for us, it's a win, right. I mean,

00:20:55,350 --> 00:20:57,850
plus let's face it, class macros, they're just plain

00:20:57,850 --> 00:21:00,880
cool. They really feel like they're cheating. And when

00:21:00,880 --> 00:21:03,330
you first discover you can do it, it's so

00:21:03,330 --> 00:21:07,050
natural to get carried away with it, right.

00:21:07,050 --> 00:21:09,390
And Ruby comes bundled with a perfect example of

00:21:09,390 --> 00:21:14,060
a class macro, right. Attr_reader, writer, accessor. These are

00:21:14,060 --> 00:21:15,960
great class macros. I mean, they save us a

00:21:15,960 --> 00:21:19,630
lot of busywork, right. And they're very declarative, all

00:21:19,630 --> 00:21:20,520
right.

00:21:20,520 --> 00:21:24,080
It's a good thing.

00:21:24,080 --> 00:21:28,800
ActiveRecord has class macros. has_many :posts. I'm actually OK

00:21:28,800 --> 00:21:30,930
with that - I mean, something has_many :posts. I'm

00:21:30,930 --> 00:21:34,130
OK with that syntax. I'd even give a pass

00:21:34,130 --> 00:21:37,680
to inverse of user, right. OK, you're still kind

00:21:37,680 --> 00:21:41,050
of describing what it is.

00:21:41,050 --> 00:21:43,470
But we all know that that's not what happens,

00:21:43,470 --> 00:21:47,500
right. This is what happens, right. I'd like to

00:21:47,500 --> 00:21:51,290
point this part out, particular. That's fun.

00:21:51,290 --> 00:21:55,120
All right, this is not, not a good class

00:21:55,120 --> 00:21:59,600
macro, when it has to do this, right. Here's

00:21:59,600 --> 00:22:03,580
another example. We have delegate. This is the ActiveSupport

00:22:03,580 --> 00:22:06,220
version of delegate, not forwardable or simpledelegate.

00:22:06,220 --> 00:22:11,290
Pretty straightforward. Delete :work, :to => :owner, which is

00:22:11,290 --> 00:22:17,580
what cat's do. You can prefix it. Still describing

00:22:17,580 --> 00:22:18,960
what it is, I think, at that point. It's

00:22:18,960 --> 00:22:22,120
a little iffy but I'll, I'd say OK.

00:22:22,120 --> 00:22:24,220
But then there's option :allow_nil, where a whole bunch

00:22:24,220 --> 00:22:28,880
of extra behavior comes in, right. For instance, if

00:22:28,880 --> 00:22:33,080
you say :allow_nil, if the option's not set and

00:22:33,080 --> 00:22:34,900
you have a nil there, it immediately raises an

00:22:34,900 --> 00:22:39,110
error. If it is set, it delegates to nil

00:22:39,110 --> 00:22:40,840
if nil happens to respond to the method, but

00:22:40,840 --> 00:22:43,990
otherwise it just returns nil.

00:22:43,990 --> 00:22:46,420
And you can see this kind of indecision in,

00:22:46,420 --> 00:22:48,920
in the implementation. Again, this is small for a

00:22:48,920 --> 00:22:50,180
reason. You don't want to read it. I'm protecting

00:22:50,180 --> 00:22:52,650
you. I'm gonna put some arrows in here.

00:22:52,650 --> 00:22:54,970
These are all the branching points in the code.

00:22:54,970 --> 00:22:56,860
These are all the places where the code branches

00:22:56,860 --> 00:22:59,280
off to, to make a decision, right.

00:22:59,280 --> 00:23:01,640
If prefix is true instead of a string, for

00:23:01,640 --> 00:23:03,600
instance, it'll use the value of two as the

00:23:03,600 --> 00:23:06,400
default prefix. But only if you're delegating to a

00:23:06,400 --> 00:23:08,170
method name, not if you're delegating to an object

00:23:08,170 --> 00:23:11,910
that's an instance variable or a constant.

00:23:11,910 --> 00:23:14,220
It also checks explicitly for a two of class

00:23:14,220 --> 00:23:16,300
and prefixes it with self, so you're not referencing

00:23:16,300 --> 00:23:17,150
the keyword.

00:23:17,150 --> 00:23:19,130
All right. If we were to make a few

00:23:19,130 --> 00:23:21,560
minor changes to this API, and again, for, for

00:23:21,560 --> 00:23:25,380
parody with the one that was there, we'll just

00:23:25,380 --> 00:23:28,170
keep it in module, we can reduce the number

00:23:28,170 --> 00:23:31,310
of branches necessary to something like this.

00:23:31,310 --> 00:23:33,390
We split out the :allow_nil behavior to a different

00:23:33,390 --> 00:23:35,180
macro and we say, OK, this is a different

00:23:35,180 --> 00:23:40,210
thing, right, it's, it's different. And, and we can

00:23:40,210 --> 00:23:42,230
kind of simplify the method that we actually use.

00:23:42,230 --> 00:23:43,990
I mean it's, it's, it's now, it's now one

00:23:43,990 --> 00:23:48,090
line. This is a one-line method that we generate.

00:23:48,090 --> 00:23:49,630
And the main thing is we can dog-food it

00:23:49,630 --> 00:23:52,290
inside an object to delegate those things to nil

00:23:52,290 --> 00:23:53,760
that nil responds to. We keep the same behavior

00:23:53,760 --> 00:23:55,370
and I'm not arguing this is the right behavior,

00:23:55,370 --> 00:23:59,770
I'm arguing this is, you know, equivalent.

00:23:59,770 --> 00:24:01,100
So it's something to think about when you're writing

00:24:01,100 --> 00:24:02,900
class macros. Maybe you actually have more than one

00:24:02,900 --> 00:24:05,670
thing.

00:24:05,670 --> 00:24:08,990
So how about this one? Right, this must be

00:24:08,990 --> 00:24:11,610
great, because it has no options, right. This is

00:24:11,610 --> 00:24:15,110
horrible, right, because Ruby already has class macros that

00:24:15,110 --> 00:24:16,520
do this for us.

00:24:16,520 --> 00:24:20,950
This is what they're called. And if you really

00:24:20,950 --> 00:24:22,270
read, really need to make use of the hooks,

00:24:22,270 --> 00:24:23,590
go ahead and make use of the hooks as

00:24:23,590 --> 00:24:27,100
well. It's OK. I mean, it's better than adding

00:24:27,100 --> 00:24:29,920
new vocabulary that's nobody's gonna know. And they don't

00:24:29,920 --> 00:24:34,830
know where the file is to look for.

00:24:34,830 --> 00:24:38,460
So everybody loves rules, right. We talked about it

00:24:38,460 --> 00:24:41,110
earlier. In the Ruby community, we love rules. So

00:24:41,110 --> 00:24:44,090
here are five rules that we can apply whenever

00:24:44,090 --> 00:24:46,610
we're considering whether or not something needs to be

00:24:46,610 --> 00:24:49,640
a class macro, and how to implement it.

00:24:49,640 --> 00:24:52,200
In my opinion, they let me give my opinion

00:24:52,200 --> 00:24:56,600
while I'm up here, it's cool. Class macros should,

00:24:56,600 --> 00:25:02,450
first off, describe what, not how. They should be

00:25:02,450 --> 00:25:07,080
idempotent. If you run them multiple times, running the

00:25:07,080 --> 00:25:10,210
same class macro is not going to change things

00:25:10,210 --> 00:25:13,260
repeatedly.

00:25:13,260 --> 00:25:16,610
They should be order independent. If you run the

00:25:16,610 --> 00:25:19,590
same macro with slightly different options, then it should

00:25:19,590 --> 00:25:24,940
be building some aggregate amount of information, versus changing

00:25:24,940 --> 00:25:28,070
what you had said earlier. Because that way you

00:25:28,070 --> 00:25:30,650
can reason about each thing independently.

00:25:30,650 --> 00:25:33,600
They should be straightforward. What you, what you see

00:25:33,600 --> 00:25:36,210
should be as close to what you get as

00:25:36,210 --> 00:25:42,040
possible. You shouldn't necessarily get surprised by what happens,

00:25:42,040 --> 00:25:43,350
is a better way of saying it. And you

00:25:43,350 --> 00:25:45,930
shouldn't have to comb through pages and pages of

00:25:45,930 --> 00:25:48,280
documentation just to understand how to use a class

00:25:48,280 --> 00:25:50,010
macro. That's a really good sign that this would

00:25:50,010 --> 00:25:53,510
be better, better factored into some objects.

00:25:53,510 --> 00:25:56,730
And lastly, both the definition and the implementation should

00:25:56,730 --> 00:26:01,180
be free of branching, if possible. So if you're

00:26:01,180 --> 00:26:02,750
branching a lot in the macro implementation, there's a

00:26:02,750 --> 00:26:04,020
good chance you have more than one macro, which

00:26:04,020 --> 00:26:05,250
I mentioned earlier.

00:26:05,250 --> 00:26:07,290
Or maybe a macro that takes a class or

00:26:07,290 --> 00:26:11,730
an object to be a strategy. SO here's the

00:26:11,730 --> 00:26:14,510
rules again. And most of you probably are saying,

00:26:14,510 --> 00:26:18,780
that's impossible. I would say, it's not necessarily impossible,

00:26:18,780 --> 00:26:21,140
and that those built-ins that I said, the attr_reader,

00:26:21,140 --> 00:26:23,270
attr_accessor and so forth, they actually do this today.

00:26:23,270 --> 00:26:25,750
They, they satisfy all those criteria.

00:26:25,750 --> 00:26:28,630
But I'll admit, I'm kind of screwing with you.

00:26:28,630 --> 00:26:33,750
Obviously, like, any set of rules, it's OK to

00:26:33,750 --> 00:26:36,050
break them if you have a reason, right. That's

00:26:36,050 --> 00:26:37,930
what makes it fun. I'm breaking the rules. Look

00:26:37,930 --> 00:26:40,650
at me, I'm wild.

00:26:40,650 --> 00:26:42,570
It's really about happiness, right. A good reason to

00:26:42,570 --> 00:26:45,380
break the rules is if you're going to increase

00:26:45,380 --> 00:26:49,860
the happiness of the users of your code. Short-term

00:26:49,860 --> 00:26:53,160
is good. Long-term happiness is better.

00:26:53,160 --> 00:26:54,880
Think about the people that are come, gonna come

00:26:54,880 --> 00:26:57,410
along and read this stuff later. Not just the

00:26:57,410 --> 00:27:00,320
fact that you saved some keystrokes on the writing.

00:27:00,320 --> 00:27:02,910
And, you know, there are, there are two kinds

00:27:02,910 --> 00:27:08,010
of surprises, right. There are good surprises - OMG

00:27:08,010 --> 00:27:12,360
this works so well! It's so intuitive! Right.

00:27:12,360 --> 00:27:14,550
Let's talk about callbacks.

00:27:14,550 --> 00:27:21,550
We love callbacks. And, you know, I hate to

00:27:22,300 --> 00:27:26,880
keep harping on callbacks, but the thing is, is

00:27:26,880 --> 00:27:28,430
there are a lot of libraries out there that

00:27:28,430 --> 00:27:32,660
have actually taken the ActiveSupport style of callbacks and

00:27:32,660 --> 00:27:36,600
begun to re-implement that functionality, right, and it, you'll

00:27:36,600 --> 00:27:39,670
see, it's like, these callbacks are inspired by ActiveSupport

00:27:39,670 --> 00:27:42,890
style callbacks. So this is, this is happening frequently

00:27:42,890 --> 00:27:45,770
enough that I think it probably needs to be

00:27:45,770 --> 00:27:48,010
reiterated.

00:27:48,010 --> 00:27:50,880
So here's someone using callbacks. Oh, here's a before

00:27:50,880 --> 00:27:56,670
save. You know, here's an after safe. Around safe.

00:27:56,670 --> 00:27:59,840
Holy heck, what is this? Why is my code

00:27:59,840 --> 00:28:04,840
all awful? Everything is terrible. Everything is miserable. I

00:28:04,840 --> 00:28:07,480
don't even understand.

00:28:07,480 --> 00:28:09,170
Right?

00:28:09,170 --> 00:28:16,170
Right - that's not funny at all. All right.

00:28:20,500 --> 00:28:23,020
So let's assume we have a base class. For,

00:28:23,020 --> 00:28:26,400
of course, the only real reason we should ever

00:28:26,400 --> 00:28:28,630
have a base class - to model a military

00:28:28,630 --> 00:28:33,830
base with lasers. Right.

00:28:33,830 --> 00:28:40,830
So, with callbacks, you call one macro to name

00:28:41,790 --> 00:28:44,200
the callback chain. Then you add callbacks to the

00:28:44,200 --> 00:28:48,400
chain with set callback. And then, in the methods

00:28:48,400 --> 00:28:51,550
that actually want to take and use the callbacks,

00:28:51,550 --> 00:28:53,830
you have to wrap everything in a black, a

00:28:53,830 --> 00:28:57,120
run, a run, a run callbacks call.

00:28:57,120 --> 00:29:00,450
And then it yields to your code, right. So

00:29:00,450 --> 00:29:04,140
let's compare that to the rules.

00:29:04,140 --> 00:29:11,140
All right, so, if you're pointing at a method,

00:29:13,540 --> 00:29:15,290
it might actually describe what if the method is

00:29:15,290 --> 00:29:18,950
well-named, you may be describing what, right.

00:29:18,950 --> 00:29:21,700
But if you make two calls to set callback,

00:29:21,700 --> 00:29:23,250
you're gonna get two identical callbacks, you're gonna repeat

00:29:23,250 --> 00:29:27,420
the work. So they're not idempotent, right. And the

00:29:27,420 --> 00:29:29,070
order you define the callbacks in is the order

00:29:29,070 --> 00:29:31,720
they're gonna get called, unless you're doing an after

00:29:31,720 --> 00:29:34,770
callback, in which case it's the reverse order, or

00:29:34,770 --> 00:29:36,790
an around callback, in which case they wrap each

00:29:36,790 --> 00:29:39,400
other in ways that look like the before and

00:29:39,400 --> 00:29:40,500
the after.

00:29:40,500 --> 00:29:46,500
And, I mean, straightforward, definitely not. And you've seen

00:29:46,500 --> 00:29:48,550
some of the implementation. By the way, Erin did

00:29:48,550 --> 00:29:52,720
an amazing amount of work refactoring the callback implementation

00:29:52,720 --> 00:29:54,760
in ActiveSupport. If you saw the ActiveRecord talk that

00:29:54,760 --> 00:29:57,700
I gave before, where we talked about the implementation

00:29:57,700 --> 00:30:00,650
being very string-heavy, building up these strings, he refactored

00:30:00,650 --> 00:30:03,650
it to be probably about as good as something

00:30:03,650 --> 00:30:05,320
like that is ever going to be. Thank you

00:30:05,320 --> 00:30:07,020
so much Erin for, for that hard work, because

00:30:07,020 --> 00:30:14,020
it was not easy. Can we give him a

00:30:16,070 --> 00:30:16,510
hand?

00:30:16,510 --> 00:30:20,550
He's over there hanging his head. He's like, oh,

00:30:20,550 --> 00:30:21,450
it's horrible.

00:30:21,450 --> 00:30:24,880
All right, so here's where it gets really interesting,

00:30:24,880 --> 00:30:26,880
right. I talk about how it's branching, it, it's

00:30:26,880 --> 00:30:30,910
branching so much it's an honorary tree. We can

00:30:30,910 --> 00:30:35,130
say, sorry, go back, we can say - and

00:30:35,130 --> 00:30:36,930
I took my own advice and said :arm_weapons instead

00:30:36,930 --> 00:30:40,140
of giving a lambda there - but we can

00:30:40,140 --> 00:30:44,570
say :if => :not_armed?, we can say, :unless =>

00:30:44,570 --> 00:30:49,650
:training_mode?, right. And then we won't auto arm.

00:30:49,650 --> 00:30:51,500
And then we can have other cards, and say

00:30:51,500 --> 00:30:56,640
subclasses like SecretBases. And they can skip callbacks, again,

00:30:56,640 --> 00:30:59,740
with an unless or an if controlling whether or

00:30:59,740 --> 00:31:01,240
not the callbacks get skipped.

00:31:01,240 --> 00:31:02,700
So we're treating this code as kind of a

00:31:02,700 --> 00:31:05,750
big blob of stuff, right, and we're, we're, it

00:31:05,750 --> 00:31:08,040
turns out really, that it's not just tricky to

00:31:08,040 --> 00:31:09,600
rock, to rhyme, to rock a rhyme that's right

00:31:09,600 --> 00:31:12,500
on time.

00:31:12,500 --> 00:31:16,670
It's, it's also tricky to use callbacks in a

00:31:16,670 --> 00:31:20,270
way that doesn't ruin your life. And we have,

00:31:20,270 --> 00:31:23,740
we have alternatives, right. We have, we have these,

00:31:23,740 --> 00:31:29,160
these, these wonderful things. Inclusion, extension, prepension.

00:31:29,160 --> 00:31:32,920
And, you know, it's OK, it's OK for your

00:31:32,920 --> 00:31:35,550
characters, that characters in your stories, to have demands

00:31:35,550 --> 00:31:38,350
and expectations of one another. Have you ever included

00:31:38,350 --> 00:31:41,880
a numerable and defined an each? All right, you

00:31:41,880 --> 00:31:45,040
benefited from this. You're defining an interface. You're just,

00:31:45,040 --> 00:31:47,160
you have an interface and you, you, you conform

00:31:47,160 --> 00:31:48,820
to it and you get all this great functionality

00:31:48,820 --> 00:31:51,910
for free.

00:31:51,910 --> 00:31:58,910
So we might potentially consider, apparently this thing's a

00:31:59,610 --> 00:32:03,140
little crazy - we might consider doing something like

00:32:03,140 --> 00:32:04,780
this. It's gonna blow your, blow your method cache

00:32:04,780 --> 00:32:06,620
by the way, don't do this, like, for real.

00:32:06,620 --> 00:32:10,150
But like, it is an option. You can extend

00:32:10,150 --> 00:32:11,580
something, like you can have an AutoArming method that

00:32:11,580 --> 00:32:14,080
simply calls super, or an AutoArming module that simply

00:32:14,080 --> 00:32:16,630
calls super and its fire_lasers method.

00:32:16,630 --> 00:32:19,330
You implement fire_lasers on the thing that extends it.

00:32:19,330 --> 00:32:21,860
You can get that behavior, that same behavior that

00:32:21,860 --> 00:32:24,130
we, we just had before.

00:32:24,130 --> 00:32:28,690
Better, in Ruby two, which you're all running now,

00:32:28,690 --> 00:32:33,860
right? Yeah. Is, it's so much better. You can

00:32:33,860 --> 00:32:39,120
simply prepend, prepend AutoArming. Get the same behavior. And

00:32:39,120 --> 00:32:41,670
if you have rules, like, about, whether something should

00:32:41,670 --> 00:32:44,190
AutoArm, you can, again, define an interface, right, and

00:32:44,190 --> 00:32:46,790
you can say like, OK, so when you, when

00:32:46,790 --> 00:32:51,090
you extend or you prepend AutoArming, you get this

00:32:51,090 --> 00:32:53,510
should_autoarm? that's automatically set to true, but if you

00:32:53,510 --> 00:32:55,840
want to override that in a subclass, you're totally

00:32:55,840 --> 00:32:56,610
cool to do that.

00:32:56,610 --> 00:32:58,470
It's gonna determine whether or not, you know, you

00:32:58,470 --> 00:33:01,590
should actually do the thing or not. You can

00:33:01,590 --> 00:33:05,400
get that same behavior in a way that's readable.

00:33:05,400 --> 00:33:07,940
So if we compare the rules that we looked

00:33:07,940 --> 00:33:11,400
at again, it definitely defines what, not how, because

00:33:11,400 --> 00:33:13,360
all you can do is say the name of

00:33:13,360 --> 00:33:16,540
thing that you're, you're extending or you're, you're prepending,

00:33:16,540 --> 00:33:19,540
right. It's idempotent - you include, you extend, you

00:33:19,540 --> 00:33:22,280
prepend. If you do it a second time, it's

00:33:22,280 --> 00:33:26,620
not gonna change the inheritance hierarchy of your object.

00:33:26,620 --> 00:33:31,110
And, speaking of, it does sort of depend on

00:33:31,110 --> 00:33:34,150
the order. Like, I mean, it might - if,

00:33:34,150 --> 00:33:35,960
depending on the implementation, right, certainly it could be

00:33:35,960 --> 00:33:38,540
order dependent. What you're calling in super is gonna,

00:33:38,540 --> 00:33:42,530
again, because it's, it's related to the inheritance hierarchy.

00:33:42,530 --> 00:33:44,500
It's straightforward, though. I mean, you know exactly where

00:33:44,500 --> 00:33:47,760
to go look for that code, right. No surprises

00:33:47,760 --> 00:33:49,530
there.

00:33:49,530 --> 00:33:51,520
And it's about as, as free as you're going

00:33:51,520 --> 00:33:53,750
to be as branching, in that you have the

00:33:53,750 --> 00:33:57,320
keyword, you have, you have the, the class or

00:33:57,320 --> 00:33:59,570
the, or the class module that you're extending or

00:33:59,570 --> 00:34:01,900
prepending or whatever. That's about as much as you're

00:34:01,900 --> 00:34:03,410
gonna be able to do. Now certainly implementations can

00:34:03,410 --> 00:34:06,120
vary. But that's not my problem.

00:34:06,120 --> 00:34:12,690
So the other huge win with this, right, is

00:34:12,690 --> 00:34:14,690
like with callbacks, how do you really know the

00:34:14,690 --> 00:34:16,520
behavior that's attached to something? I mean, you can

00:34:16,520 --> 00:34:19,280
ask for the callbacks and you get this, like,

00:34:19,280 --> 00:34:23,960
array-like thing, callback chain. But if you're actually adding

00:34:23,960 --> 00:34:25,560
things to the inheritance hierarchy of the object, you

00:34:25,560 --> 00:34:29,340
can start to ask about what that object has.

00:34:29,340 --> 00:34:33,550
And you can see, for instance, the order that

00:34:33,550 --> 00:34:37,010
things are being executed very easily. And it's just

00:34:37,010 --> 00:34:41,480
Ruby, right. Like, it leverages stuff, it leverages stuff

00:34:41,480 --> 00:34:44,570
that we already know. We just, it brings us

00:34:44,570 --> 00:34:47,130
back to, you know, making every word count, right.

00:34:47,130 --> 00:34:50,120
Like, if somebody already understands a concept, why create

00:34:50,120 --> 00:34:52,370
an artificial learning curve for them? Is there, is

00:34:52,370 --> 00:34:53,159
there value there?

00:34:53,159 --> 00:34:57,410
I don't know. I mean, to me, I think

00:34:57,410 --> 00:34:59,270
that's really what it comes down to. You can

00:34:59,270 --> 00:35:04,200
reduce the cognitive load for understanding, for understanding code,

00:35:04,200 --> 00:35:05,760
and that is a bigger win. Like, if, if

00:35:05,760 --> 00:35:10,590
good programmers are lazy, then, I mean, this is,

00:35:10,590 --> 00:35:12,520
this makes you a great programmer, right. Because you're

00:35:12,520 --> 00:35:14,700
gonna read this code much more often than you're

00:35:14,700 --> 00:35:16,700
gonna write it.

00:35:16,700 --> 00:35:18,060
And if you make it more readable, then every

00:35:18,060 --> 00:35:19,260
time you go back to it, you won't have

00:35:19,260 --> 00:35:23,890
to wonder, oh, how was that macro implemented, again?

00:35:23,890 --> 00:35:29,380
Now look, it's obvious that not one pattern is

00:35:29,380 --> 00:35:32,490
going to apply everywhere, OK. I'm not advocating that

00:35:32,490 --> 00:35:36,520
you just blindly go, oh Ernie said do this

00:35:36,520 --> 00:35:39,250
so I'm gonna go do this, right. It's totally

00:35:39,250 --> 00:35:43,140
OK, it's really fine that - and stories, stories

00:35:43,140 --> 00:35:44,640
would be really boring if they were all the

00:35:44,640 --> 00:35:48,660
same. What I'm asking you to do is think.

00:35:48,660 --> 00:35:52,400
Think about the story that you're trying to tell.

00:35:52,400 --> 00:35:56,900
We're storytellers, right. I mean, and Ruby is such

00:35:56,900 --> 00:36:00,370
a wonderful language, a wonderful tool for telling stories.

00:36:00,370 --> 00:36:03,080
I love it. I mean, I, I am a

00:36:03,080 --> 00:36:05,770
little bit, maybe too passionate about it at times.

00:36:05,770 --> 00:36:07,290
I mean, I go to other languages and I'm

00:36:07,290 --> 00:36:09,420
just like, ah, I wish I had what I

00:36:09,420 --> 00:36:11,120
had in Ruby.

00:36:11,120 --> 00:36:13,200
It's an awesome tool for telling stories, and I'm

00:36:13,200 --> 00:36:17,910
so grateful that we have it. So put thought

00:36:17,910 --> 00:36:20,720
into what you're trying to say, and make every

00:36:20,720 --> 00:36:21,850
word count.

00:36:23,960 --> 00:36:26,920

YouTube URL: https://www.youtube.com/watch?v=OB-xFC8AN_s


