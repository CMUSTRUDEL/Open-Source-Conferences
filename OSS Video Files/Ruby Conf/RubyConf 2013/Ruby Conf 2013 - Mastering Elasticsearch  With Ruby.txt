Title: Ruby Conf 2013 - Mastering Elasticsearch  With Ruby
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Luca Bonmassar

Users have come to expect state-of-the-art search features in every part of their online experience. The good news for developers is that features like autosuggest, spell-correct, and personalized search are becoming easier to develop thanks to services like Elasticsearch. Integrating Elasticsearch into ruby apps is now relatively straightforward thanks to the Tire wrapper library. The talk will examine how to build an Elasticsearch cluster, create indexes, load data, and format and execute robust search features using the ruby Tire library.

Help us caption & translate this video!

http://amara.org/v/FG5P/
Captions: 
	00:00:16,300 --> 00:00:18,180
LUCA BONMASSAR: I'm Luca Bonmassar.

00:00:18,200 --> 00:00:21,259
Even though my badge say Bonsommar.

00:00:21,260 --> 00:00:24,201
My real name is Bonmassar. I'm thirty-one.

00:00:24,240 --> 00:00:28,618
I am Italian and I live in San Francisco.

00:00:28,640 --> 00:00:30,450
I work at Gild, and today

00:00:30,450 --> 00:00:33,901
I'll talk about search using Elasticsearch.

00:00:33,901 --> 00:00:36,460
I have a lot of content to show, and

00:00:36,460 --> 00:00:39,459
I have - here - a ticker that tell

00:00:39,520 --> 00:00:42,441
me the time, so I'll just jump into the

00:00:42,441 --> 00:00:44,100
talk.

00:00:44,100 --> 00:00:47,229
So let's start by defining what we will discuss

00:00:47,260 --> 00:00:50,060
here. Search is a very broad topic, so we

00:00:50,080 --> 00:00:54,701
won't do, like, clarify what's our use case. What

00:00:54,701 --> 00:00:57,480
we're discussing here is, you're building a product, and

00:00:57,480 --> 00:01:00,469
you want to integrate some search experience in your

00:01:00,540 --> 00:01:03,700
product. So we're not talking here to build a

00:01:03,700 --> 00:01:06,931
search engine. We're not trying to compete with Google.

00:01:06,960 --> 00:01:09,290
So we want to implement that little box that

00:01:09,290 --> 00:01:12,510
every website has, so that the user, the general

00:01:12,620 --> 00:01:16,670
use case, is you have user generated content, and

00:01:16,670 --> 00:01:19,830
you have other user that have to be able

00:01:19,830 --> 00:01:23,160
to find and discover this content.

00:01:23,160 --> 00:01:26,830
So, why we have to discuss this. The reason

00:01:26,840 --> 00:01:30,840
is that search is not easy. It usually starts

00:01:30,840 --> 00:01:33,300
when you have to build some search capabilities in

00:01:33,340 --> 00:01:37,280
your product by saying, hey, our primary data storage

00:01:37,280 --> 00:01:40,400
has some search capabilities. We're not using that.

00:01:40,440 --> 00:01:43,550
And then you start by adding some sort of

00:01:43,560 --> 00:01:46,630
SQL queries, where you can try to search in

00:01:46,630 --> 00:01:50,390
your database. But then the user are picky, and

00:01:50,390 --> 00:01:52,440
they want more. They want not just be able

00:01:52,500 --> 00:01:55,490
to search by exec name, they want also to,

00:01:55,490 --> 00:01:58,380
for example, enter a long, long string and be

00:01:58,420 --> 00:02:01,750
able to find products in your, in your, in

00:02:01,750 --> 00:02:03,090
your system.

00:02:03,090 --> 00:02:06,290
And then you want to support Nqueries, or not,

00:02:06,300 --> 00:02:11,080
and your little where_name becomes a function that has

00:02:11,080 --> 00:02:14,560
to pass parameter. You don't want only to search

00:02:14,560 --> 00:02:17,660
on a specific field but you soon start searching

00:02:17,660 --> 00:02:19,860
on multiple fields in your database, so you need

00:02:19,860 --> 00:02:22,080
to start indexing and indexing.

00:02:22,080 --> 00:02:24,380
And in your product, what happens is that you

00:02:24,380 --> 00:02:27,520
start with a very simple function and you become

00:02:27,520 --> 00:02:30,610
building your own search engine in your product.

00:02:30,610 --> 00:02:32,400
That's probably not what you want to do, because

00:02:32,400 --> 00:02:35,160
you want to focus your development effort on the

00:02:35,160 --> 00:02:39,120
core functionality for your product and not rebuilding yet

00:02:39,120 --> 00:02:41,120
another search engine.

00:02:41,120 --> 00:02:44,230
So the agenda, what I want to show here

00:02:44,230 --> 00:02:48,600
is not a search engine. I want to speak

00:02:48,600 --> 00:02:52,430
a pet project. And talk about search on that

00:02:52,440 --> 00:02:56,080
project so that it's easier to discuss the various

00:02:56,080 --> 00:02:58,950
step that we have to take to introduce search

00:02:58,950 --> 00:03:02,210
in the project rather than talking about search for,

00:03:02,240 --> 00:03:03,880
like, anything.

00:03:03,880 --> 00:03:06,340
We will see some, several boilerplate that we have

00:03:06,340 --> 00:03:09,310
to go through to like download the code, the,

00:03:09,320 --> 00:03:11,710
download the elasticsearch, installing staffolding,

00:03:11,710 --> 00:03:15,150
configuring, et cetera, et cetera.

00:03:15,160 --> 00:03:18,350
And we will see a very simple website that

00:03:18,350 --> 00:03:22,660
we can build, integrating search functionalities. And then see

00:03:22,660 --> 00:03:25,620
how you can refine, improving and adding more capabilities

00:03:25,620 --> 00:03:29,990
for our search. And then, as homework, other capabilities

00:03:30,000 --> 00:03:33,010
that elasticsearch give that I don't have time to

00:03:33,010 --> 00:03:37,640
discuss here. But with almost no effort you can

00:03:37,640 --> 00:03:40,240
integrate in your product.

00:03:40,240 --> 00:03:42,740
So the idea of why we start from a

00:03:42,740 --> 00:03:46,060
real project and not taking, like, the search as

00:03:46,060 --> 00:03:51,010
a separate topic is because it's - I can

00:03:51,020 --> 00:03:52,710
use this.

00:03:52,710 --> 00:03:57,699
It's, it's easier to understand each use case and

00:03:57,700 --> 00:04:00,280
understand why there are some decisions taken here and

00:04:00,280 --> 00:04:04,060
there if we talk about something concrete rather than

00:04:04,080 --> 00:04:06,751
any possible search. And we'll see, for example, a

00:04:06,760 --> 00:04:11,030
few features that are not, like, it's, they're not

00:04:11,030 --> 00:04:13,350
easy to understand why there is this feature there,

00:04:13,350 --> 00:04:16,110
but in the project it makes lot of sense.

00:04:16,110 --> 00:04:18,429
Because, oh, yeah, you could do this.

00:04:18,440 --> 00:04:23,030
So our project start from RubyGems. Everyone has seen,

00:04:23,050 --> 00:04:27,711
is familiar with RubyGems. And RubyGems has the functionality

00:04:27,720 --> 00:04:31,239
to search gems in the database they have, and

00:04:31,240 --> 00:04:33,661
they have implemented the, the search in the same

00:04:33,661 --> 00:04:34,840
way I describe before.

00:04:34,840 --> 00:04:36,630
So if you look at the RubyGems, the source

00:04:36,630 --> 00:04:39,719
code in GitHub, what they are doing here is

00:04:39,740 --> 00:04:44,250
a SQL query, name, like, what you're inputting. And

00:04:44,250 --> 00:04:47,471
they can detect the, if the result from the,

00:04:47,480 --> 00:04:52,089
the result is an exec match or something similar.

00:04:52,089 --> 00:04:53,552
But it's a pity because they have so many

00:04:53,560 --> 00:04:56,499
more information in their database you could look up

00:04:56,500 --> 00:04:59,329
for dependencies, you could look up for, not just

00:04:59,329 --> 00:05:01,880
the name, but also the info, the summary, the

00:05:01,880 --> 00:05:02,771
build.

00:05:02,780 --> 00:05:05,250
So what we want to do is extending their

00:05:05,250 --> 00:05:07,740
search capabilities in a way that we can do

00:05:07,740 --> 00:05:09,159
all of this.

00:05:09,160 --> 00:05:13,190
Clearly we don't have access to, like, their database.

00:05:13,190 --> 00:05:16,630
So our project will start by getting the content

00:05:16,640 --> 00:05:21,420
through a web spider. We will import the data

00:05:21,420 --> 00:05:24,880
into a Mongo database - I'll clarify why the

00:05:24,880 --> 00:05:29,260
decision of going for MongoDB for the sample project.

00:05:29,260 --> 00:05:31,681
We will see Elastic Search in action and then

00:05:31,681 --> 00:05:35,580
we'll build a very simple Rails application that expose

00:05:35,580 --> 00:05:38,180
the, the function, right, of search that we want

00:05:38,180 --> 00:05:41,919
to for the Ruby gems project.

00:05:41,920 --> 00:05:44,961
So let's start from the crawler. The code is

00:05:44,961 --> 00:05:48,009
available there. I'm not spending too much time here

00:05:48,020 --> 00:05:50,950
because is not the purpose of the talk. But

00:05:50,950 --> 00:05:53,930
the idea is RubyGems dot org slash gems provide

00:05:53,940 --> 00:05:57,250
the least of all the gems name. They are

00:05:57,260 --> 00:06:00,500
paginated by names. So we can go one by

00:06:00,500 --> 00:06:03,660
one, collect all the name using ?? [00:06:03].

00:06:03,660 --> 00:06:08,121
And then, using the gem's, the gem's own API,

00:06:08,121 --> 00:06:10,819
we can download for each gem the JSON of

00:06:10,820 --> 00:06:12,970
the, of that gem.

00:06:12,980 --> 00:06:16,180
So all of these, when it runs, and in

00:06:16,180 --> 00:06:19,830
this, so. I'm not expecting you to, like, parse

00:06:19,830 --> 00:06:21,570
all the content, but the idea is now we

00:06:21,580 --> 00:06:26,020
have the, inside Mongo a JSON file representing all

00:06:26,020 --> 00:06:28,330
the data available for each gem. In this case,

00:06:28,330 --> 00:06:29,760
the Twitter gem.

00:06:29,760 --> 00:06:33,151
This now clarify why we want to go for

00:06:33,160 --> 00:06:35,729
Mongo. Because we don't want to map data between

00:06:35,729 --> 00:06:39,200
what the gem's API return, whatever they return in

00:06:39,200 --> 00:06:42,260
term of data structure. We just dump the JSON

00:06:42,260 --> 00:06:44,540
into Mongo and it's there. It's available for us

00:06:44,540 --> 00:06:46,560
to manipulate and work on that.

00:06:46,560 --> 00:06:50,901
So we are now to the stage that we

00:06:50,901 --> 00:06:55,249
have the crawler running. We have the data imported

00:06:55,260 --> 00:06:57,370
into the system and it's also available at dump

00:06:57,370 --> 00:06:58,711
of the data in case you want to play

00:06:58,720 --> 00:06:59,799
with that.

00:06:59,800 --> 00:07:03,670
And, let's start building our very simple interface. So

00:07:03,670 --> 00:07:07,360
this is the starting point of our project. So

00:07:07,360 --> 00:07:10,100
here there is nothing else than just a scaffold

00:07:10,100 --> 00:07:13,711
Rails application showing all the gems that are available,

00:07:13,720 --> 00:07:17,030
which support pagination, and you can open any of

00:07:17,030 --> 00:07:20,859
these. And here is basically reporting all the data

00:07:20,860 --> 00:07:23,290
that we have here.

00:07:23,300 --> 00:07:24,990
So this is the starting point, like, this is

00:07:24,990 --> 00:07:29,801
my generic product, where I want to implement here

00:07:29,801 --> 00:07:33,580
our little search. And the, let's see how we

00:07:33,580 --> 00:07:37,460
do that. So the first step is to introduce

00:07:37,460 --> 00:07:41,069
Elastic Search. So we're not gonna implement all the

00:07:41,080 --> 00:07:43,600
logic of a search engine, but we just use

00:07:43,600 --> 00:07:45,640
something that does that for us.

00:07:45,640 --> 00:07:49,610
This is Elastic Search, that is cool, bonsai cool.

00:07:49,610 --> 00:07:53,140
What is Elastic Search? Here is a long list

00:07:53,140 --> 00:07:55,991
of answers, but let's say that is an OpenSource

00:07:56,000 --> 00:08:00,539
search engine. They also provide analytics capabilities, so you

00:08:00,540 --> 00:08:04,160
can also use the same engine to get the

00:08:04,160 --> 00:08:07,221
sort of map reviews on your data.

00:08:07,221 --> 00:08:11,629
It's distributed, meaning that the, it's easy to scale

00:08:11,629 --> 00:08:15,560
somehow, because the data is not monolithic. You can

00:08:15,560 --> 00:08:17,961
split it into multiple shards.

00:08:17,961 --> 00:08:21,539
You can have multiple note that you can distribute

00:08:21,540 --> 00:08:24,780
your data on, and each shard can be replicated

00:08:24,780 --> 00:08:27,450
so it's also very good for, like, the resilience

00:08:27,450 --> 00:08:29,060
of your application.

00:08:29,100 --> 00:08:33,090
It supports almost near time search, that, in the

00:08:33,090 --> 00:08:35,681
short terms means that you can index new data

00:08:35,681 --> 00:08:39,219
and almost in real time you can have this

00:08:39,220 --> 00:08:40,560
data available for search.

00:08:40,560 --> 00:08:45,171
It's multi tenant. That means that you can have

00:08:45,180 --> 00:08:48,670
multiple indexes, not just one. And you can do

00:08:48,670 --> 00:08:53,370
cool stuff as in you can swap indexes and

00:08:53,370 --> 00:08:56,379
the application doesn't see any change. So you can

00:08:56,380 --> 00:08:59,541
deploy new indexes and you have almost no downtime

00:08:59,541 --> 00:09:01,059
for your application.

00:09:01,060 --> 00:09:03,541
That's very cool when you're building your application, iteration

00:09:03,541 --> 00:09:07,759
and every time you change something in your index.

00:09:07,760 --> 00:09:09,981
And unless you want to index all the data

00:09:10,000 --> 00:09:13,060
and keeping the website off for awhile, you can

00:09:13,060 --> 00:09:18,170
just swap, offswap data in the database.

00:09:18,170 --> 00:09:20,129
And the last thing is build on top of

00:09:20,140 --> 00:09:23,241
Apache Lucene. There are also other project that use

00:09:23,241 --> 00:09:27,110
the same technology. But Apache Lucene is a Java

00:09:27,110 --> 00:09:30,210
library for manipulating text that is very powerful.

00:09:30,210 --> 00:09:32,739
All this is nice, but as a developer what

00:09:32,740 --> 00:09:35,101
is really interesting is that we have this magic

00:09:35,101 --> 00:09:38,400
box that is able to do search and expose

00:09:38,400 --> 00:09:41,840
its capabilities using a rest API. And the language

00:09:41,840 --> 00:09:44,720
to communicate with this magic box is JSON.

00:09:44,720 --> 00:09:47,509
So we can send JSON documents in and we

00:09:47,509 --> 00:09:51,252
can, even with the core command, we can query

00:09:51,260 --> 00:09:53,699
the server.

00:09:53,720 --> 00:09:55,420
So here is a list now of things that

00:09:55,420 --> 00:09:58,460
we have to do to have the entire Elastic

00:09:58,460 --> 00:10:02,519
Search ready for us to play with our product.

00:10:02,520 --> 00:10:06,020
We have clearly to download the Elastic Search code,

00:10:06,020 --> 00:10:08,281
set it up. Define some settings. We will see

00:10:08,281 --> 00:10:13,799
some default and something that you have to change.

00:10:13,800 --> 00:10:16,150
Optionally we have to define update and mapping in

00:10:16,150 --> 00:10:19,520
Elastic Search world, data mapping is the equivalent of

00:10:19,520 --> 00:10:25,009
defining a database or table in the database world.

00:10:25,009 --> 00:10:28,800
It's optional because Elastic Search is schema-less. So you

00:10:28,800 --> 00:10:32,091
could just ignore that and just start injecting data

00:10:32,100 --> 00:10:35,259
into Elastic Search. You only have to do that

00:10:35,260 --> 00:10:38,320
if you don't want the default assumption that Elastic

00:10:38,320 --> 00:10:41,531
Search does on it's field. So if you want,

00:10:41,540 --> 00:10:45,129
for example, that specific field gets tokenized or parsed

00:10:45,129 --> 00:10:47,231
in very special ways you have to define your

00:10:47,240 --> 00:10:50,100
own data mapping.

00:10:50,100 --> 00:10:52,530
Then the next two steps are, first, we need

00:10:52,530 --> 00:10:57,670
to load data into the Elastic Search cluster. So

00:10:57,670 --> 00:11:00,410
we have to transfer data from the MongolDB to

00:11:00,420 --> 00:11:05,020
Elastic Search cluster. And the last thing that is

00:11:05,020 --> 00:11:06,770
a thing that we want to do is we

00:11:06,770 --> 00:11:08,770
want to start doing search.

00:11:08,780 --> 00:11:11,239
Since it's a rest API and JSON document, we

00:11:11,240 --> 00:11:14,591
can even do that by using the comma line,

00:11:14,600 --> 00:11:17,840
and we can parse the results because they are

00:11:17,840 --> 00:11:20,560
JSON so they are very easy to read from

00:11:20,560 --> 00:11:21,480
the terminal.

00:11:21,480 --> 00:11:25,240
So let's start from the deboiler plate. This is

00:11:25,240 --> 00:11:28,550
the procedure that works on any environment. So Elastic

00:11:28,550 --> 00:11:31,199
Search is a Java beast, so you need the

00:11:31,200 --> 00:11:35,741
Java on your, in your machine. Hopefully not any

00:11:35,741 --> 00:11:38,900
Java but the Oracle Java. You can also run

00:11:38,900 --> 00:11:41,999
it with the new Java but very often you

00:11:42,000 --> 00:11:44,971
run into weird issues and the Oracle Java -

00:11:44,980 --> 00:11:47,329
it's definitely better.

00:11:47,329 --> 00:11:49,852
If you're running on a Mac or a Linux

00:11:49,861 --> 00:11:53,698
you can clearly do the installation using the, the

00:11:53,700 --> 00:12:00,580
package distribution like Pro or Port or APT.

00:12:00,580 --> 00:12:03,231
And we go for the configuration. So the very

00:12:03,240 --> 00:12:07,139
basic configuration is logging, where you have to define

00:12:07,140 --> 00:12:10,530
the repository of your logs. But also where to

00:12:10,530 --> 00:12:13,950
log and what to log at any stage, like

00:12:13,950 --> 00:12:17,370
production, development staging.

00:12:17,380 --> 00:12:19,050
And then you have the long list of config

00:12:19,050 --> 00:12:22,810
setting for Elastic Search. By default, if you want

00:12:22,820 --> 00:12:25,331
to run it on dev box, you don't have

00:12:25,340 --> 00:12:26,970
to configure anything.

00:12:26,970 --> 00:12:29,020
You can assume that all the settings are good

00:12:29,020 --> 00:12:32,580
enough for development environment. There is actually one only

00:12:32,580 --> 00:12:35,350
parameter that you have absolutely to change. That is

00:12:35,350 --> 00:12:38,960
the name of the cluster. And the reason is

00:12:38,960 --> 00:12:42,179
that, by default, the name of the cluster is

00:12:42,180 --> 00:12:46,031
Elastic Search and the, we, as we say, the

00:12:46,040 --> 00:12:48,489
Elastic Search is a distributed system.

00:12:48,489 --> 00:12:51,091
So if you run on a network where your

00:12:51,100 --> 00:12:53,970
developer friends are on the same network running Elastic

00:12:53,970 --> 00:12:56,999
Search, they will start discovering each other and they

00:12:57,000 --> 00:13:00,110
will start building their own cluster. What it means

00:13:00,120 --> 00:13:02,661
is that if you're operating on your local host,

00:13:02,661 --> 00:13:07,030
you're actually operating on all your developer team.

00:13:07,030 --> 00:13:10,020
And it's a nightmare troubleshooting because I can wipe

00:13:10,020 --> 00:13:12,299
out the entire database and everyone else that is

00:13:12,300 --> 00:13:15,160
working on that doesn't realize what's happening.

00:13:15,180 --> 00:13:17,260
So it's very good that at least you change

00:13:17,260 --> 00:13:19,830
the name of your cluster.

00:13:19,830 --> 00:13:22,981
Many of the other parameters are like one time

00:13:22,981 --> 00:13:25,350
only. You set it and forget it. The first

00:13:25,350 --> 00:13:30,500
are the topology of your cluster, like, how the

00:13:30,520 --> 00:13:33,879
cluster is gonna look like, how many shards, or

00:13:33,880 --> 00:13:36,791
how do you want to split the data. How

00:13:36,800 --> 00:13:39,689
many replicas for each shards. You're going to find

00:13:39,689 --> 00:13:43,870
where are the things on your local system.

00:13:43,870 --> 00:13:47,651
Elastic Search is extensible through plugins in Java. So

00:13:47,660 --> 00:13:50,679
you can also either write your own classes and

00:13:50,680 --> 00:13:53,891
inject into the cluster or you can download any

00:13:53,900 --> 00:13:56,179
of the plugins that are available. There are many

00:13:56,180 --> 00:13:59,390
for monitoring and controlling of the cluster.

00:13:59,390 --> 00:14:01,310
The sad thing where you will spend the majority

00:14:01,310 --> 00:14:04,990
of your time in production is the memory. Elastic

00:14:05,000 --> 00:14:08,940
Search is a Java beast and you will need

00:14:08,940 --> 00:14:13,180
a lot of tuning for the JVM. In particular

00:14:13,180 --> 00:14:16,050
to not run out of memory every time you

00:14:16,050 --> 00:14:18,590
run a facets query.

00:14:18,600 --> 00:14:21,420
And everyone else, again, it's for, like, you set

00:14:21,420 --> 00:14:24,440
it once and you forget it.

00:14:24,440 --> 00:14:28,500
So we're almost there, in term of boilerplate. We

00:14:28,500 --> 00:14:32,310
can finally start our Elastic Search cluster. And using

00:14:32,310 --> 00:14:35,131
curl we can test if it's alive. There are

00:14:35,140 --> 00:14:38,790
tons of APIs available to check the out of

00:14:38,790 --> 00:14:42,900
the cluster, each node and also the consistency of

00:14:42,900 --> 00:14:45,880
its index, or to see if, for example, your

00:14:45,880 --> 00:14:49,280
index is all line or not, if it's corrupted

00:14:49,280 --> 00:14:52,460
or what is the link? Sometimes it's like synchronizing

00:14:52,460 --> 00:14:55,849
data between nodes, so through this API you can

00:14:55,860 --> 00:14:56,110
do that.

00:14:56,110 --> 00:14:58,850
And you can also shut down each node or

00:14:58,860 --> 00:15:00,990
the entire cluster using APIs.

00:15:00,990 --> 00:15:05,201
We're done, so we are finally ready to be

00:15:05,220 --> 00:15:07,749
an Elastic Search expert. We can tell the ward

00:15:07,749 --> 00:15:10,540
that we are Elastic Search expert and let our

00:15:10,540 --> 00:15:15,651
friends endorsing us. And I'm sure that as soon

00:15:15,660 --> 00:15:17,390
as you put it all your friends will start

00:15:17,390 --> 00:15:19,559
saying yeah, it's an expert! So it's a good

00:15:19,560 --> 00:15:23,341
thing to put it on your resume.

00:15:23,341 --> 00:15:26,330
So let's, let's take a step back and see

00:15:26,340 --> 00:15:29,239
what else, where we are and what is missing

00:15:29,240 --> 00:15:32,570
for our project. So we, we have the elastic

00:15:32,570 --> 00:15:35,941
search running. We have Mongo running. What else we

00:15:35,941 --> 00:15:36,630
have to do?

00:15:36,640 --> 00:15:39,939
We have to start telling our project something about

00:15:39,940 --> 00:15:43,230
Elastic Search. And we have to start moving the

00:15:43,230 --> 00:15:47,821
data between Mongo and Elastic Search. And last, that's

00:15:47,821 --> 00:15:49,859
just the step where we want to get, is

00:15:49,860 --> 00:15:52,810
able to do queries so that we can implement

00:15:52,820 --> 00:15:55,930
our search capabilities in our product.

00:15:55,930 --> 00:15:58,451
So the first step is then to tell something

00:15:58,460 --> 00:16:02,960
to our app of where is Elastic Search and

00:16:02,960 --> 00:16:05,210
how to communicate with that, so the client side

00:16:05,210 --> 00:16:08,510
of the Elastic Search. We can use Tire, the

00:16:08,520 --> 00:16:13,770
gem, that unfortunately has been renamed Re-Tire in September.

00:16:13,770 --> 00:16:16,309
And the reason is that the Elastic Search group

00:16:16,320 --> 00:16:19,250
is now building their own official gem, so the

00:16:19,250 --> 00:16:22,151
author is now deprecating the gem.

00:16:22,160 --> 00:16:26,689
However, in term of maturity and complexity, probably they

00:16:26,689 --> 00:16:29,631
are like at least one year or more behind,

00:16:29,640 --> 00:16:33,710
so Tire is the way to go for now.

00:16:33,710 --> 00:16:36,450
And Tire provides not only a way to interact

00:16:36,460 --> 00:16:40,020
- so you could do everything through HTTP, your

00:16:40,020 --> 00:16:44,809
favorite HTTP or Ruby library like HTTP party. But

00:16:44,809 --> 00:16:47,861
unless you want to, like, be at the, the,

00:16:47,880 --> 00:16:51,010
meta-level, you want something that wrap hold the complexity

00:16:51,010 --> 00:16:54,881
of interacting with its single, like, timeout and Tire

00:16:54,881 --> 00:16:56,999
can do that for you.

00:16:57,000 --> 00:16:59,461
It also support a nice active model integration, so

00:16:59,461 --> 00:17:02,169
if you're using Rails you basically can forget about

00:17:02,180 --> 00:17:04,651
Elastic Search. You will have a few needles that

00:17:04,660 --> 00:17:08,390
you can operate on the class, and all the

00:17:08,390 --> 00:17:11,720
complexities - it's totally hidden.

00:17:11,720 --> 00:17:14,420
And last it provides a set of utilities and

00:17:14,420 --> 00:17:17,860
tasks to perform operation that you will do it

00:17:17,860 --> 00:17:21,610
by end, and like for example, important data. And

00:17:21,610 --> 00:17:25,120
I'll show you a couple of cases.

00:17:25,120 --> 00:17:27,350
So we need to set the, the gem out

00:17:27,360 --> 00:17:29,480
to do that. We put it in our gem

00:17:29,480 --> 00:17:31,910
file and we bundle install. There is a ??

00:17:31,910 --> 00:17:33,780
[00:17:32] if you do that you'll probably override the

00:17:33,780 --> 00:17:36,980
entire gem find.

00:17:36,980 --> 00:17:41,730
You, the configuration, it's pretty easy. It depends on,

00:17:41,730 --> 00:17:45,850
like, if it's the Rails or traditional Ruby, but

00:17:45,890 --> 00:17:48,220
the idea is you just set where is the,

00:17:48,240 --> 00:17:51,020
the entrypoint of your cluster, and that's the only

00:17:51,020 --> 00:17:52,580
thing that you have to do.

00:17:52,580 --> 00:17:56,070
A second configuration, if you want to log, that's

00:17:56,070 --> 00:18:00,370
very, very interesting for debugging whilst Tire is doing.

00:18:00,370 --> 00:18:03,180
If you set it up, you can have a

00:18:03,180 --> 00:18:06,900
log file from the client side. And the format

00:18:06,900 --> 00:18:09,570
of this log, it's in Curl, so you can

00:18:09,580 --> 00:18:12,540
cut and paste any of this comment in your

00:18:12,540 --> 00:18:16,150
terminal, and you can physically replace every single step

00:18:16,150 --> 00:18:18,340
of what Tire is doing, and you can also

00:18:18,340 --> 00:18:23,420
then inspect each single result coming from Elastic Search.

00:18:23,420 --> 00:18:27,340
So now we can start talking about code.

00:18:27,340 --> 00:18:31,350
So, the Ruby gem is the wrapper for Mongo,

00:18:31,350 --> 00:18:34,290
so a Ruby gem class in our little project,

00:18:34,300 --> 00:18:38,690
it's a single Mongo document. What we do is

00:18:38,700 --> 00:18:42,320
we extend that with the Tire DSL, so at

00:18:42,320 --> 00:18:46,810
line 5 and 6 we can add Tire.

00:18:46,810 --> 00:18:49,320
And everything else here is optional. I like to,

00:18:49,320 --> 00:18:52,770
to, like oversell, but everything that is here is

00:18:52,780 --> 00:18:56,420
optional. So we define our own mapping, that is

00:18:56,420 --> 00:18:59,280
the format of the record in Elastic Search.

00:18:59,280 --> 00:19:01,930
So here we basically define a few fields, like

00:19:01,930 --> 00:19:06,450
ID, name, original name, info licenses and so on.

00:19:06,480 --> 00:19:08,380
You don't need to do that, because, by default,

00:19:08,380 --> 00:19:10,330
the first time that Elastic Search see any of

00:19:10,330 --> 00:19:13,170
this field, will pretend that all this fields are

00:19:13,170 --> 00:19:15,040
there.

00:19:15,040 --> 00:19:19,500
It's here, just as a sort of live documentation,

00:19:19,500 --> 00:19:21,810
so that if tomorrow you have to put the

00:19:21,820 --> 00:19:23,480
ans again on the core at least you know

00:19:23,480 --> 00:19:25,820
which are the fields that are supposed to be

00:19:25,820 --> 00:19:26,660
in Elastic Search.

00:19:26,660 --> 00:19:28,900
And you have to do this in case some

00:19:28,900 --> 00:19:31,510
of the field you have to override. Any of

00:19:31,510 --> 00:19:34,340
the properties, like telling that for example, for a

00:19:34,340 --> 00:19:37,400
couple of fields, like, ID and original name, Elastic

00:19:37,400 --> 00:19:39,960
Search, please store it but don't do any logic

00:19:39,960 --> 00:19:41,360
on top of that, we want to keep it

00:19:41,360 --> 00:19:44,400
the field as it is.

00:19:44,400 --> 00:19:47,420
And these define the structure of the record. The

00:19:47,420 --> 00:19:51,670
second thing that you should do is override a

00:19:51,680 --> 00:19:55,640
metric called to_index JSON. That's part of the Tire

00:19:55,640 --> 00:19:59,140
DSL. The idea is that you have to convert

00:19:59,140 --> 00:20:01,730
your record, that in our case is JSON because

00:20:01,730 --> 00:20:04,960
this is Mongo, into some other JSON for Elastic

00:20:04,960 --> 00:20:06,220
Search.

00:20:06,220 --> 00:20:09,830
You can also ignore the entire metric here if

00:20:09,840 --> 00:20:12,530
you want to just have a one-to-one maaping, so

00:20:12,530 --> 00:20:14,310
whatever is in Mongo is going to be in

00:20:14,310 --> 00:20:15,430
Elastic Search.

00:20:15,440 --> 00:20:18,550
However, if you don't want to overkill Elastic Search

00:20:18,550 --> 00:20:21,380
with every sort of parameter that is in Mongo,

00:20:21,410 --> 00:20:24,140
you want to find the structure of your own

00:20:24,140 --> 00:20:27,630
record. So here we just define an hash for

00:20:27,630 --> 00:20:31,030
these records and we convert it to JSON.

00:20:31,040 --> 00:20:34,610
So if we recap what we have done here,

00:20:34,620 --> 00:20:37,020
we can fire our Rails console and take the

00:20:37,020 --> 00:20:41,260
first Ruby gem record. We can call the two

00:20:41,260 --> 00:20:45,110
index JSON on that record, and that is like

00:20:45,110 --> 00:20:47,890
the representation in JSON for your record in Elastic

00:20:47,900 --> 00:20:49,030
Search.

00:20:49,030 --> 00:20:53,520
If on that record we call update_index, what Tire

00:20:53,520 --> 00:20:56,790
is gonna do is to call your to_index JSON,

00:20:56,800 --> 00:21:00,790
so it take the record, it generates JSON, and

00:21:00,790 --> 00:21:03,280
then execute a push on Elastic Search.

00:21:03,280 --> 00:21:06,550
So this is, like, the log that we can

00:21:06,560 --> 00:21:09,560
enable on the client's side. And the, you can

00:21:09,560 --> 00:21:13,380
see what is happening. It's posting on the Ruby

00:21:13,380 --> 00:21:17,020
gems index for the Ruby gem type, which a

00:21:17,020 --> 00:21:21,920
specific ID, and then the payload of the JSON

00:21:21,920 --> 00:21:24,150
that it's loading into Elastic Search.

00:21:24,150 --> 00:21:26,410
And Elastic Search is returning us 200, so the

00:21:26,420 --> 00:21:30,480
rest- So the operation succeeded. So now we know

00:21:30,480 --> 00:21:32,450
how to index at least one record.

00:21:32,450 --> 00:21:35,140
We have to replicate these for all the data

00:21:35,140 --> 00:21:38,200
that we have available. The naive way would be,

00:21:38,200 --> 00:21:40,590
let's iterate through every record that we have in

00:21:40,600 --> 00:21:44,650
the database, let's call update_index and we are done.

00:21:44,650 --> 00:21:48,020
It works. Particularly in development mode.

00:21:48,040 --> 00:21:50,570
The way it works is to execute one single

00:21:50,570 --> 00:21:54,110
post for each single record. You won't notice any

00:21:54,110 --> 00:21:57,200
performance issue is running if you're running everything in

00:21:57,200 --> 00:21:58,880
local host.

00:21:58,880 --> 00:22:01,470
Clearly if you are running with, like Elastic Search,

00:22:01,480 --> 00:22:05,000
it's in one box and you're on another box,

00:22:05,000 --> 00:22:07,750
the data transfer - it's huge, cause you have

00:22:07,750 --> 00:22:10,510
a lot of round-trip time. What you can do

00:22:10,520 --> 00:22:13,710
is you can use a bulk API from Elastic

00:22:13,710 --> 00:22:16,990
Search, and upload a thousand records at a time.

00:22:17,000 --> 00:22:20,180
And here we have a bundle stack, right, provided

00:22:20,180 --> 00:22:22,820
by Tire that does everything for you. So you

00:22:22,820 --> 00:22:26,370
can just fire that comment and it's showing you

00:22:26,370 --> 00:22:32,180
the upload of all your record into Elastic Search.

00:22:32,200 --> 00:22:36,160
And we're finally done with all the infrastructure, setting

00:22:36,160 --> 00:22:38,730
and we can now focus on the search.

00:22:38,740 --> 00:22:40,640
As usual, I like the put more things that

00:22:40,640 --> 00:22:45,420
aren't needed just for showing you, like, the capabilities

00:22:45,420 --> 00:22:48,740
of the gem, but everything besides line 7, 8,

00:22:48,740 --> 00:22:50,680
9 it's optional.

00:22:50,680 --> 00:22:52,920
So here I'm not using, for example, any digression

00:22:52,920 --> 00:22:55,860
with ActiveModel. I'm going to Tire and asking for

00:22:55,860 --> 00:22:58,460
a search. I could have done Ruby gem dot

00:22:58,460 --> 00:23:01,250
search and I wouldn't have to pass the name

00:23:01,250 --> 00:23:03,980
of the index.

00:23:03,980 --> 00:23:08,410
In the Tire search we designate/define how our search

00:23:08,420 --> 00:23:10,090
is gonna look like.

00:23:10,090 --> 00:23:13,090
We ask to not the load false is an

00:23:13,100 --> 00:23:16,430
option, so by default what Tire does is to

00:23:16,430 --> 00:23:19,480
match the result coming from Elastic Search to your

00:23:19,480 --> 00:23:22,870
original record in your primary storage. But that means

00:23:22,880 --> 00:23:25,220
that if you get twenty-five results back, for each

00:23:25,220 --> 00:23:27,840
one is gonna go on the database and load

00:23:27,840 --> 00:23:30,790
the original record to give you the result.

00:23:30,790 --> 00:23:32,720
If you don't need that data, because for example

00:23:32,720 --> 00:23:35,420
you have enough data in Elastic Search record to

00:23:35,420 --> 00:23:38,080
present it to the view, you don't want to

00:23:38,080 --> 00:23:40,900
do that, because it's much faster just parsing the

00:23:40,900 --> 00:23:42,290
results coming back from Elastic Search.

00:23:42,300 --> 00:23:44,690
So in this case we just tell, please don't

00:23:44,690 --> 00:23:47,580
load data coming from Mongo.

00:23:47,580 --> 00:23:49,920
And here is the query part. In the query

00:23:49,920 --> 00:23:54,180
part, we get a search terms. The search terms

00:23:54,200 --> 00:23:57,190
is, it's a string. It's whatever the user is

00:23:57,190 --> 00:23:59,970
gonna type in for our search. And we ask

00:23:59,970 --> 00:24:03,260
Elastic Search to search into name, info, owners, and

00:24:03,260 --> 00:24:04,490
authors.

00:24:04,500 --> 00:24:07,120
We als- and that's everything that we have to

00:24:07,140 --> 00:24:07,960
do.

00:24:07,960 --> 00:24:10,480
Then we also ask a few other things to

00:24:10,480 --> 00:24:13,780
Elastic Search. We ask not just, don't just give

00:24:13,780 --> 00:24:16,270
me back results, but also tell me for each

00:24:16,270 --> 00:24:18,540
results where did you find the match, because we

00:24:18,540 --> 00:24:20,300
don't want to confuse the user. Because now we

00:24:20,300 --> 00:24:23,100
are searching also for example owners and authors.

00:24:23,100 --> 00:24:26,700
And maybe you're searching Twitter and you get a

00:24:26,700 --> 00:24:31,260
gem that's called something else but the author's was

00:24:31,260 --> 00:24:33,690
called Twitter and you don't get why you get

00:24:33,690 --> 00:24:36,240
this result back.

00:24:36,240 --> 00:24:40,060
We ask a specific sorting. By default, Elastic Search

00:24:40,060 --> 00:24:45,170
provides a score for each record of how, how

00:24:45,170 --> 00:24:49,010
that record is significant for the search. It's a

00:24:49,020 --> 00:24:53,470
sort of, not page rank, but the search rank

00:24:53,470 --> 00:24:56,750
on each document. And it's based on multiple different

00:24:56,760 --> 00:24:59,800
factor, for example, how many times the occurency of

00:24:59,800 --> 00:25:03,310
that word appear, the frequency, the position and so

00:25:03,310 --> 00:25:04,210
on.

00:25:04,220 --> 00:25:07,180
Here we just override and, by saying don't bother

00:25:07,180 --> 00:25:10,840
sorting by that, sort by the original name. And

00:25:10,840 --> 00:25:13,700
the last thing is to implement pagination.

00:25:13,700 --> 00:25:16,750
So the two API here are from and size,

00:25:16,750 --> 00:25:19,620
so we define what's the page size and where

00:25:19,620 --> 00:25:21,550
are you in the stream so that you can

00:25:21,560 --> 00:25:24,690
jump to page two, three, four, five.

00:25:24,690 --> 00:25:26,390
That's all we have to do to implement the

00:25:26,400 --> 00:25:28,750
search. So what we can do next, it's playing

00:25:28,750 --> 00:25:32,260
with the search from comma line. We can again

00:25:32,260 --> 00:25:35,110
fire a Rails consol, and on the Ruby gem

00:25:35,120 --> 00:25:37,330
we can call simple search, and this time search

00:25:37,330 --> 00:25:40,360
for Twitter and Bootstrap but not Rails.

00:25:40,360 --> 00:25:44,540
And we can print the first twenty-five results back.

00:25:44,540 --> 00:25:47,020
So we are done in term of logic. We

00:25:47,020 --> 00:25:51,750
can go now to the UI and implement our

00:25:51,760 --> 00:25:56,240
little input box that just generate a get request.

00:25:56,240 --> 00:25:58,880
Whatever the user types in we pass to the

00:25:58,880 --> 00:26:02,860
simple search metric. And here is also the highlighting

00:26:02,860 --> 00:26:05,760
running, so we also show that if you're searching

00:26:05,760 --> 00:26:09,240
Twitter and Bootstrap not Rails. This is for each

00:26:09,240 --> 00:26:13,230
record where it's coming from, in full name, authors.

00:26:13,230 --> 00:26:17,050
And where in the string that matched.

00:26:17,060 --> 00:26:18,930
I want just to show you how the highlighting

00:26:18,930 --> 00:26:23,130
works, and then I'll jump on the, on the

00:26:23,140 --> 00:26:26,570
running product. So if we execute again a simple

00:26:26,570 --> 00:26:29,990
search for Twitter and Bootstrap not Rails, and we

00:26:30,000 --> 00:26:32,980
get the term, the results, that results is the

00:26:32,980 --> 00:26:35,090
- first of all, it's not a real Ruby

00:26:35,090 --> 00:26:40,090
gem class. It's an item wrapping a Ruby gem.

00:26:40,090 --> 00:26:43,860
And implements other metric decorating the Ruby gem class,

00:26:43,880 --> 00:26:49,160
for example, the highlights, print us back the key,

00:26:49,160 --> 00:26:52,590
as a key, where you define that result, and

00:26:52,590 --> 00:26:55,230
as a sort of HTML with emphasis, where, so

00:26:55,240 --> 00:26:59,230
you can add easily CSS to, to highlight and

00:26:59,240 --> 00:27:01,840
show it in your, in your UI.

00:27:01,840 --> 00:27:04,960
You can also change the way it's stacked. Instead

00:27:04,960 --> 00:27:08,570
of EM, you can use anything that you want.

00:27:08,570 --> 00:27:12,620
So if we go here, this is where we

00:27:12,620 --> 00:27:13,240
are now.

00:27:13,240 --> 00:27:16,890
So, we have implemented the very simple search. But

00:27:16,900 --> 00:27:20,510
there is one problem. So if you, in every

00:27:20,510 --> 00:27:23,820
simple search, if you search, for example, by author,

00:27:23,820 --> 00:27:27,320
since we search everywhere, at least in those four

00:27:27,320 --> 00:27:30,540
fields, we can get an expect the results.

00:27:30,540 --> 00:27:33,660
OK, so I'm searching for author and I also

00:27:33,660 --> 00:27:35,940
matched authors. That's clear because that's what we have

00:27:35,940 --> 00:27:39,180
built and what we were looking for. But the,

00:27:39,180 --> 00:27:43,590
while this can work, you want your user to

00:27:43,600 --> 00:27:46,250
be able to go into an advanced mode, where

00:27:46,250 --> 00:27:48,890
he can specify, I want to search here and

00:27:48,900 --> 00:27:52,190
there. So this time we implement that this feature

00:27:52,190 --> 00:27:53,980
going the other way around. We start from the

00:27:54,000 --> 00:27:56,650
interface and we go back to the code.

00:27:56,650 --> 00:27:58,240
So this is more or less what a user

00:27:58,240 --> 00:27:59,920
would see.

00:27:59,920 --> 00:28:01,840
So we continue to show here the results, but

00:28:01,840 --> 00:28:04,790
on top instead of just giving an input box,

00:28:04,790 --> 00:28:07,090
we give a list of input box, so that

00:28:07,100 --> 00:28:10,140
the user has more control on the search.

00:28:10,140 --> 00:28:12,880
And also here we could give more control to

00:28:12,880 --> 00:28:15,510
the user, like, on what do you want to

00:28:15,510 --> 00:28:17,930
sort the results - do you want to sort

00:28:17,940 --> 00:28:21,230
by name, by something else? We could also ask

00:28:21,230 --> 00:28:26,190
the user to show, to request how many results

00:28:26,200 --> 00:28:29,820
per page do you want, for example.

00:28:29,820 --> 00:28:31,560
When implementing these, one of the things that you

00:28:31,560 --> 00:28:34,900
have to wonder is, what's the logic for all

00:28:34,900 --> 00:28:37,930
the fields? So if I'm searching something in name

00:28:37,930 --> 00:28:42,640
and info, what should we search? By default we

00:28:42,640 --> 00:28:44,640
could be a an 'or' or can be an

00:28:44,640 --> 00:28:46,300
'and'. So do you want the search, if I

00:28:46,300 --> 00:28:49,490
put multiple fields to restrict your search or to

00:28:49,500 --> 00:28:52,720
grow, like expand your search?

00:28:52,720 --> 00:28:55,820
So in our case, we decide that if you

00:28:55,820 --> 00:28:58,520
search for name and author, so you put this

00:28:58,520 --> 00:29:00,550
in name and in authors, we will search by

00:29:00,550 --> 00:29:02,190
'and'.

00:29:02,220 --> 00:29:05,730
So we go back here, and this is the

00:29:05,730 --> 00:29:09,500
interface that we have built. And the, let's look

00:29:09,500 --> 00:29:12,190
at the code. SO it's not very different, so

00:29:12,190 --> 00:29:15,770
everything looks the same, and like, just cut and

00:29:15,770 --> 00:29:18,510
paste the code to the advanced search.

00:29:18,520 --> 00:29:20,680
The only thing here that we change is the

00:29:20,680 --> 00:29:24,580
way we execute the query block. We tell Elastic

00:29:24,580 --> 00:29:27,320
Search that this is the boolean search. The search

00:29:27,320 --> 00:29:30,570
condition now is not anymore a string. It's an

00:29:30,570 --> 00:29:34,200
hash of condition that the user, it's whatever comes

00:29:34,200 --> 00:29:38,580
from the form. So it's a list of different

00:29:38,600 --> 00:29:40,830
keys and names.

00:29:40,830 --> 00:29:42,840
And we just iterate for the fields that are

00:29:42,840 --> 00:29:45,930
set by the user. We execute a search by

00:29:45,930 --> 00:29:49,010
saying please put this as an 'and' condition.

00:29:49,020 --> 00:29:51,450
That's everything that you have to do. And it

00:29:51,450 --> 00:29:53,070
just works.

00:29:53,080 --> 00:29:56,880
So if we go here back, we can now

00:29:56,880 --> 00:30:03,880
search for author here.

00:30:03,920 --> 00:30:06,710
And we just filter out everything that wasn't name,

00:30:06,710 --> 00:30:10,230
and we can iterate by searching in something else

00:30:10,240 --> 00:30:12,910
- probably if I search here it will be

00:30:12,920 --> 00:30:17,110
empty. Empty search. Because now those are in 'and',

00:30:17,110 --> 00:30:20,410
and there's no project that's called Tor and has

00:30:20,420 --> 00:30:22,900
an author of Tor.

00:30:22,900 --> 00:30:23,520
Success.

00:30:23,520 --> 00:30:27,230
So let's iterate again and let's make the search

00:30:27,230 --> 00:30:32,290
interface a little bit more, like, professional. Let's look

00:30:32,300 --> 00:30:36,310
about facets. So facets are a way to organize

00:30:36,310 --> 00:30:39,850
your results so that when you search for something,

00:30:39,860 --> 00:30:42,060
in this case it's a link to a page,

00:30:42,060 --> 00:30:44,520
and it's search for a Ruby developer. What we

00:30:44,540 --> 00:30:47,690
can do is in our results set, we can

00:30:47,690 --> 00:30:50,620
have certain amount of categories.

00:30:50,620 --> 00:30:54,690
For example, in this case, relationship, location, current company.

00:30:54,690 --> 00:30:56,820
And in real time the search engine can tell

00:30:56,820 --> 00:31:00,890
you for each category it can propose you specific

00:31:00,890 --> 00:31:04,820
sub categories, like first connection, second connection.

00:31:04,820 --> 00:31:07,120
And how many results are you gonna get if

00:31:07,120 --> 00:31:10,100
you are clicking on that, and like narrowing down

00:31:10,100 --> 00:31:11,600
your search.

00:31:11,600 --> 00:31:14,400
So facets, it's a very cool way to explore

00:31:14,400 --> 00:31:17,090
the data, because even the, like the one hundred

00:31:17,100 --> 00:31:20,960
thousand results that got back, I can very quickly

00:31:20,960 --> 00:31:24,180
filter and narrow my search back to a few

00:31:24,180 --> 00:31:25,350
results.

00:31:25,350 --> 00:31:27,880
So how complex is to implement this with Elastic

00:31:27,880 --> 00:31:30,600
Search? So it's kind of easy. It's the same

00:31:30,600 --> 00:31:32,590
code as before. The only thing that changed is

00:31:32,600 --> 00:31:36,440
the line 34 to 38. So here we define

00:31:36,440 --> 00:31:38,710
facets. So if the user has clicked on the

00:31:38,710 --> 00:31:42,710
check box facets, we define four categories.

00:31:42,720 --> 00:31:46,550
So we want to group our results by license.

00:31:46,550 --> 00:31:49,250
We want to group our results by version. And

00:31:49,260 --> 00:31:51,840
we want to group our results by when the

00:31:51,840 --> 00:31:55,410
gem was built. The difference between the global license

00:31:55,410 --> 00:31:58,070
and the current license is the facets by default

00:31:58,080 --> 00:32:01,330
are related to the result of your query.

00:32:01,330 --> 00:32:04,800
So whatever you search it classify the results of

00:32:04,820 --> 00:32:07,490
your query. But you can also specify don't bother

00:32:07,490 --> 00:32:11,370
about my query. Give me the results of the

00:32:11,380 --> 00:32:15,840
entire data that you have in Elastic Search.

00:32:15,840 --> 00:32:19,700
So if we try these on comma line, so

00:32:19,700 --> 00:32:23,220
the only difference, it's face, it's true when we

00:32:23,220 --> 00:32:27,140
enable that option. The results already get decorated by

00:32:27,140 --> 00:32:30,040
a meter called facets. And if we inspect what's

00:32:30,040 --> 00:32:33,790
inside the facets we get back from Elastic Search

00:32:33,790 --> 00:32:36,660
a key value where keys are what we have

00:32:36,660 --> 00:32:40,870
to find in our facets. So global licenses, current

00:32:40,880 --> 00:32:44,110
licenses, current version, and the date.

00:32:44,110 --> 00:32:47,230
And we get some statistic of how many documents

00:32:47,240 --> 00:32:50,190
have that property, how many they were found, how

00:32:50,190 --> 00:32:54,250
many they don't have anything like that. But in

00:32:54,260 --> 00:32:58,880
particular within terms or entries you get key values

00:32:58,880 --> 00:33:02,670
of how many for that specific category match. So

00:33:02,670 --> 00:33:06,250
how you can plug in these into your view.

00:33:06,260 --> 00:33:09,000
Well you can on the left implement the same

00:33:09,000 --> 00:33:11,510
thing that we saw before in LinkedIn.

00:33:11,510 --> 00:33:13,750
So when you run a query, you get the

00:33:13,760 --> 00:33:15,670
first one that is global. So you get a

00:33:15,670 --> 00:33:19,570
categorization by licenses. So that's global for the entire

00:33:19,580 --> 00:33:23,860
population of gems that we have available.

00:33:23,860 --> 00:33:25,700
Based on your query you can have a breakdown

00:33:25,720 --> 00:33:27,740
of the licenses. For example in this case of

00:33:27,740 --> 00:33:30,390
Twitter, and if you click on that you just

00:33:30,390 --> 00:33:34,970
refine your search by narrowing down on that category.

00:33:34,970 --> 00:33:39,840
Three other things that you can expand after we

00:33:39,840 --> 00:33:41,550
are reached this stage of the project.

00:33:41,560 --> 00:33:44,090
The first one, it's implementing a did you mean

00:33:44,090 --> 00:33:48,570
capability, that similar to my badge that was misspelled.

00:33:48,570 --> 00:33:51,410
If you misspell something, it can tell you, hey,

00:33:51,410 --> 00:33:57,480
you typed in Bonsmar. You probably meant Bonmassar. And

00:33:57,580 --> 00:34:00,260
it's a simple API. When you execute a search,

00:34:00,260 --> 00:34:03,780
you ask for suggestions, in the second case, and

00:34:03,780 --> 00:34:07,510
it's gonna give you like frequency and probability of,

00:34:07,510 --> 00:34:09,580
yeah, probably meant this other thing.

00:34:09,580 --> 00:34:13,609
So behind it's implementing like let's define distance to

00:34:13,620 --> 00:34:17,541
find matches, and you can specify several configuration on

00:34:17,541 --> 00:34:21,359
what, for you, means similar, because clearly you can

00:34:21,360 --> 00:34:24,291
say that anything is similar or, like, one or

00:34:24,300 --> 00:34:28,149
two letter should be mispelled.

00:34:28,149 --> 00:34:31,390
Something other, one cycle that you can have out

00:34:31,390 --> 00:34:34,061
of the box from Elastic Search is the implement

00:34:34,061 --> 00:34:36,020
the similar to these, that you can find, for

00:34:36,020 --> 00:34:37,330
example in Google.

00:34:37,340 --> 00:34:39,060
When you find the result that you really, really

00:34:39,060 --> 00:34:42,560
like, for example, you are building a website where,

00:34:42,560 --> 00:34:45,680
you're searching for apartments, and you finally find an

00:34:45,680 --> 00:34:48,639
apartment that you really like, but unfortunately it's not

00:34:48,640 --> 00:34:52,640
available today. You can execute a new search asking,

00:34:52,640 --> 00:34:55,341
give me more results that are similar to this.

00:34:55,341 --> 00:34:58,800
The results on an API for that. And basically

00:34:58,800 --> 00:35:01,300
you tell, OK, I really like this document, give

00:35:01,300 --> 00:35:04,120
me something that is similar. You can specify what

00:35:04,120 --> 00:35:08,350
similar should look like. And, again, it, Elastic Search

00:35:08,350 --> 00:35:10,800
will compute the distance from that document to what

00:35:10,800 --> 00:35:13,080
it has in its database and provide you other

00:35:13,080 --> 00:35:17,030
documents that are very similar to that.

00:35:17,040 --> 00:35:19,350
The last Bonsai- Bonsai Cool API that I want

00:35:19,350 --> 00:35:23,200
to show is Percolate. This is one of the

00:35:23,200 --> 00:35:25,060
API that when you read the first time, you

00:35:25,060 --> 00:35:27,180
don't understand what you can do with that. It's

00:35:27,200 --> 00:35:30,250
a reverse search. So usually you search for a

00:35:30,250 --> 00:35:32,950
term and you get back a list of documents

00:35:32,950 --> 00:35:35,700
that match that query. Percolate is the other way

00:35:35,700 --> 00:35:36,250
around.

00:35:36,280 --> 00:35:38,770
You give a list of queries and then a

00:35:38,770 --> 00:35:41,560
single document, and you can get back which query

00:35:41,560 --> 00:35:44,560
would match. What you can do with that is,

00:35:44,560 --> 00:35:47,950
for example, going back to the example of the,

00:35:47,950 --> 00:35:52,430
of the product where you search apartments. You could

00:35:52,430 --> 00:35:55,690
have a query as a user of apartments in

00:35:55,690 --> 00:35:58,780
Miami, because this is what you are looking for.

00:35:58,800 --> 00:36:01,460
What you can do is to save your search,

00:36:01,460 --> 00:36:03,830
and every time there is a new apartment in

00:36:03,830 --> 00:36:07,200
this product, the product can search for any queries

00:36:07,200 --> 00:36:10,040
that have been searched by a user and notify

00:36:10,040 --> 00:36:13,720
you when a new apartment is available. Because now

00:36:13,720 --> 00:36:16,160
that match your query, and then you can notify

00:36:16,160 --> 00:36:18,370
the user, hey, come back, there is an apartment

00:36:18,380 --> 00:36:21,980
that could be interesting for you.

00:36:21,980 --> 00:36:26,350
And closing on this, a couple of comments on

00:36:26,350 --> 00:36:30,900
deployment option. So everything was more or less around

00:36:30,900 --> 00:36:34,710
development. But consideration about deployment:

00:36:34,720 --> 00:36:38,470
Option number one is the do it yourself. So

00:36:38,470 --> 00:36:41,510
the pro is that you have total control on

00:36:41,520 --> 00:36:44,350
installation and you can have any topology and you

00:36:44,350 --> 00:36:48,010
can specify. You can also inject Java code and

00:36:48,010 --> 00:36:53,940
extend the cluster. The cost is that, my experience,

00:36:54,020 --> 00:36:56,950
it's a nightmare. In particular, the early version were

00:36:56,960 --> 00:37:01,690
very, very hard to run and manage. Some of

00:37:01,690 --> 00:37:05,170
the learning that we have found doing that, first

00:37:05,180 --> 00:37:07,800
of all, there is something that you have to

00:37:07,800 --> 00:37:09,540
be aware when you're moving from a cluster of

00:37:09,540 --> 00:37:12,270
three nodes to something more than three nodes: till

00:37:12,270 --> 00:37:15,790
three nodes, everything is fine. Unicorn and rainbow. After

00:37:15,800 --> 00:37:19,430
three nodes you have to specify a set of

00:37:19,430 --> 00:37:22,470
settings that, if you forget about that, you lose

00:37:22,480 --> 00:37:25,190
all your data. So be aware of that.

00:37:25,190 --> 00:37:27,220
And the reason is that there is an arbiter

00:37:27,220 --> 00:37:30,000
mechanism that automatically define who is master, who is

00:37:30,000 --> 00:37:33,260
slave. Till you are below three nodes, everything is

00:37:33,260 --> 00:37:37,840
fine. After awhile, unless you specify those parameter that

00:37:37,840 --> 00:37:40,830
you can find in documentation, weird thing can happen.

00:37:40,830 --> 00:37:43,280
Like, you can have, everyone is a master and

00:37:43,300 --> 00:37:46,470
then everyone will start saying, delete the data I'm

00:37:46,470 --> 00:37:49,380
the master. No, I'm the master. And- be aware

00:37:49,380 --> 00:37:50,490
of that.

00:37:50,500 --> 00:37:53,870
And the other consideration is about meta, the memory

00:37:53,870 --> 00:37:58,960
profiling. There are some operation in Elastic Search like

00:37:58,960 --> 00:38:03,180
the facets that, where, unless you read carefully in

00:38:03,180 --> 00:38:06,080
documentation, they load all the data in memory. So

00:38:06,080 --> 00:38:08,040
if you have enough data you can go out

00:38:08,040 --> 00:38:09,470
of memory very quickly.

00:38:09,480 --> 00:38:12,150
And you have also to tweak several times the

00:38:12,150 --> 00:38:15,560
garbage collector to say, please, like, keep all the

00:38:15,560 --> 00:38:18,780
memory. Reserve it to me. Or the priority system

00:38:18,780 --> 00:38:20,670
will take your Elastic Search out.

00:38:20,670 --> 00:38:23,860
A easy way, in case you want just to

00:38:23,880 --> 00:38:26,510
spend some money, is to go as a service.

00:38:26,510 --> 00:38:29,600
There are a few companies doing that as a

00:38:29,600 --> 00:38:33,810
service. The, the, this is really beautiful, because you

00:38:33,820 --> 00:38:36,170
just need a credit card. Swipe the credit card

00:38:36,170 --> 00:38:39,230
and you have the cluster up and running in

00:38:39,240 --> 00:38:44,700
a minute. Also you buy support. That's very important

00:38:44,700 --> 00:38:47,370
when you're playing around with API and you don't

00:38:47,370 --> 00:38:50,550
understand why your query is always putting the cluster

00:38:50,560 --> 00:38:52,700
out of memory.

00:38:52,700 --> 00:38:55,910
The consequences - it's expensive. The second thing is

00:38:55,910 --> 00:38:57,870
that you could be in the wrong region. For

00:38:57,880 --> 00:39:00,640
example, in our case we run in the US

00:39:00,640 --> 00:39:04,490
west, but all these companies and also other that

00:39:04,490 --> 00:39:06,870
you can find are on the US east. You

00:39:06,870 --> 00:39:09,080
can find something also for more space, but that's

00:39:09,100 --> 00:39:10,620
also tricky.

00:39:10,640 --> 00:39:13,790
And the other two consideration is, it's expensive. And

00:39:13,790 --> 00:39:17,430
it's expensive. Really expensive.

00:39:17,430 --> 00:39:19,740
So this is all I got. Here is the

00:39:19,740 --> 00:39:22,020
code, and the results of demo and the data

00:39:22,020 --> 00:39:23,760
so that if you want you can play with

00:39:23,760 --> 00:39:27,340
that. There is also a machine running with that.

00:39:27,340 --> 00:39:30,270
Please me nice with that, because it's a little

00:39:30,270 --> 00:39:32,970
micro and everything is running that.

00:39:32,980 --> 00:39:37,300
And that's it, so. I have ten seconds left.

00:39:37,300 --> 00:39:40,440

YouTube URL: https://www.youtube.com/watch?v=H81IiLUJavI


