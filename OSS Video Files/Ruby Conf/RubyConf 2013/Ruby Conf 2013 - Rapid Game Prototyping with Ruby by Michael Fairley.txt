Title: Ruby Conf 2013 - Rapid Game Prototyping with Ruby by Michael Fairley
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	Just as Ruby is great for getting a new web project off the ground and into production, Ruby is equally awesome for quickly building games up from scratch and continuing to iterate on them. This talk explores the basics of how computer games work, shows the tools available for building games in Ruby, and has a live demonstration of creating a simple game.

Help us caption & translate this video!

http://amara.org/v/FG4r/
Captions: 
	00:00:16,200 --> 00:00:17,539
MICHAEL FAIRLEY: Hi everybody.

00:00:17,539 --> 00:00:18,720
My name is Michael Fairley,

00:00:18,720 --> 00:00:20,300
and I'm gonna talk to you a little bit about

00:00:20,300 --> 00:00:22,919
making computer games with Ruby.

00:00:22,919 --> 00:00:25,320
A little bit, before I get started though, I'm

00:00:25,320 --> 00:00:27,439
gonna tell you about my employer. I work at

00:00:27,439 --> 00:00:31,320
BrainTree Payments, and we make it possible for businesses

00:00:31,320 --> 00:00:34,790
of any size to easily take payments online. We

00:00:34,790 --> 00:00:37,620
work with thousands of really awesome merchants, including some

00:00:37,620 --> 00:00:39,930
of these that you probably recognize. And we're love

00:00:39,930 --> 00:00:41,180
to work with you, too.

00:00:41,180 --> 00:00:43,480
So if you have any payment-related questions, please come

00:00:43,480 --> 00:00:47,220
find me later.

00:00:47,220 --> 00:00:50,080
I'm assuming that most people in here are web

00:00:50,080 --> 00:00:52,740
developers that, the Ruby you get paid to write

00:00:52,740 --> 00:00:54,960
is part of a Rails app or a Sinatra

00:00:54,960 --> 00:00:57,850
app. And the libraries you work on intend- you

00:00:57,850 --> 00:01:00,990
intend to end up inside of a web application.

00:01:00,990 --> 00:01:03,640
Or to be used to test a web application.

00:01:03,640 --> 00:01:04,769
And I'm in the same camp. As long as

00:01:04,769 --> 00:01:07,549
I've been doing Ruby professionally, I've mostly been working

00:01:07,549 --> 00:01:10,159
on Rails applications.

00:01:10,159 --> 00:01:12,359
But computer games are what got me into programming

00:01:12,359 --> 00:01:15,299
as a kid, and even though I have sort

00:01:15,299 --> 00:01:17,259
of given up on my professional aspirations of doing

00:01:17,259 --> 00:01:20,719
that, there's still something that I've been exploring as

00:01:20,719 --> 00:01:22,569
a hobby, and something I do sort of nights

00:01:22,569 --> 00:01:23,829
and weekends, and I have a lot of fun

00:01:23,829 --> 00:01:26,840
with. So I'm gonna tell you a little bit

00:01:26,840 --> 00:01:31,259
about what game programming is in the abstract, show

00:01:31,259 --> 00:01:33,280
you some of tools we have in Ruby for

00:01:33,280 --> 00:01:36,749
doing game programming, take you through a brief demo

00:01:36,749 --> 00:01:39,159
of building a game up from scratch, and then

00:01:39,159 --> 00:01:41,369
leave you with some pointers for next steps to

00:01:41,369 --> 00:01:42,689
take if you found this interesting.

00:01:42,689 --> 00:01:46,399
But first I have to answer the question, is

00:01:46,399 --> 00:01:49,189
Ruby really the right tool for doing game development?

00:01:49,189 --> 00:01:51,090
Isn't Ruby slow, and don't games need to be

00:01:51,090 --> 00:01:54,159
fast and not have long GC pauses in them?

00:01:54,159 --> 00:01:57,729
And, yes, but, most of the Ruby libraries are

00:01:57,729 --> 00:02:02,119
actually wrappers around C libraries that are quite fast,

00:02:02,119 --> 00:02:04,590
and if you don't believe me, I have a

00:02:04,590 --> 00:02:08,479
small existence proof here of a pure Ruby Minecraft

00:02:08,479 --> 00:02:11,260
clone I've been working on.

00:02:11,260 --> 00:02:13,670
This is eight hundred lines of Ruby, and it's

00:02:13,670 --> 00:02:20,670
plenty fast. And so if that's possible, then just

00:02:21,470 --> 00:02:24,709
about anything you want to make is possible. And

00:02:24,709 --> 00:02:27,319
obviously the next Grand Theft Auto or Call of

00:02:27,319 --> 00:02:29,010
Duty, won't be written in Ruby. But if you

00:02:29,010 --> 00:02:30,700
just want to have some fun, Ruby's a great

00:02:30,700 --> 00:02:34,629
tool for doing it.

00:02:34,629 --> 00:02:37,540
So at a very high-level, almost every game has

00:02:37,540 --> 00:02:41,000
what's called the game loop at its core. The

00:02:41,000 --> 00:02:43,200
game does a little bit of initialization at the

00:02:43,200 --> 00:02:45,159
beginning, just to get the state of the game

00:02:45,159 --> 00:02:47,040
set up, and then as long as the game

00:02:47,040 --> 00:02:49,650
is running, it repeatedly updates the state of the

00:02:49,650 --> 00:02:53,180
game world based on player input or timing. And

00:02:53,180 --> 00:02:55,090
then it takes this state and renders it out

00:02:55,090 --> 00:02:57,150
onto the screen so that your human player can

00:02:57,150 --> 00:02:57,870
see it.

00:02:57,870 --> 00:03:01,349
And I'm gonna dive into each of these steps

00:03:01,349 --> 00:03:03,840
in a little more detail.

00:03:03,840 --> 00:03:05,349
So the setup is where you things, where you

00:03:05,349 --> 00:03:08,469
get the game ready to go. And while you're

00:03:08,469 --> 00:03:13,340
prototyping, you'll probably just hardcode some Ruby. And, you

00:03:13,340 --> 00:03:17,799
know, construct some classes directly and assign instance variables.

00:03:17,799 --> 00:03:19,950
But as your game grows and you have different

00:03:19,950 --> 00:03:25,579
levels or different maps, you'll probably want to load

00:03:25,579 --> 00:03:27,200
your set up code from some sort of external

00:03:27,200 --> 00:03:30,219
file format, where you declared what sort of items

00:03:30,219 --> 00:03:32,290
and enemies to place in the game, and what

00:03:32,290 --> 00:03:34,760
the map layout looks like.

00:03:34,760 --> 00:03:36,640
And once you let your players save their games,

00:03:36,640 --> 00:03:38,650
you'll need to be able to serialize the game

00:03:38,650 --> 00:03:40,180
out, and then load it back up later in

00:03:40,180 --> 00:03:42,060
a different instance of the game. And these are

00:03:42,060 --> 00:03:46,829
all different forms of set up. The update part

00:03:46,829 --> 00:03:48,150
of the loop is where the real meat of

00:03:48,150 --> 00:03:50,500
the game happens. It's where you, all of your

00:03:50,500 --> 00:03:53,299
game logic lives. It's where the player interactions and

00:03:53,299 --> 00:03:55,409
timing and all sorts of other things come in,

00:03:55,409 --> 00:03:56,090
come into play.

00:03:56,090 --> 00:03:58,129
So I'm gonna show you a couple different things

00:03:58,129 --> 00:04:00,189
that you can be doing during the update portion

00:04:00,189 --> 00:04:02,280
of the loop.

00:04:02,280 --> 00:04:05,060
So one of the biggest factors that comes into

00:04:05,060 --> 00:04:09,790
play is the previous state of your game. So,

00:04:09,790 --> 00:04:12,590
in a world with gravity, every, every tick through

00:04:12,590 --> 00:04:14,909
the loop, you probably update the players position based

00:04:14,909 --> 00:04:17,989
on some sort of vertical velocity they have, and

00:04:17,989 --> 00:04:19,690
then also you can change that vertical velocity with

00:04:19,690 --> 00:04:21,690
some sort of gravitational affects.

00:04:21,690 --> 00:04:23,550
And so here, the new state of the game,

00:04:23,550 --> 00:04:28,699
is deterministically derived from the previous state of the

00:04:28,699 --> 00:04:34,330
game. User input is also a huge factor of

00:04:34,330 --> 00:04:36,990
taking actions during the update step. So here, maybe

00:04:36,990 --> 00:04:39,900
your user presses a, and that causes their character

00:04:39,900 --> 00:04:46,780
to jump. Timing is also something that you use

00:04:46,780 --> 00:04:49,100
during the game loop to cause things to happen.

00:04:49,100 --> 00:04:51,530
So if you have a fire-breathing turtle that's supposed

00:04:51,530 --> 00:04:54,400
to spit a fireball every two seconds, every time

00:04:54,400 --> 00:04:56,310
through the game loop you can check and say,

00:04:56,310 --> 00:04:58,389
is the last time I spat fire more than

00:04:58,389 --> 00:05:01,180
two seconds ago? If so, spit fire. And that

00:05:01,180 --> 00:05:03,419
will give you a nice fireball coming out every

00:05:03,419 --> 00:05:05,680
two seconds.

00:05:05,680 --> 00:05:07,430
And most games also have some sort of random

00:05:07,430 --> 00:05:12,270
component to them. So if our Italian plumber hero

00:05:12,270 --> 00:05:13,810
hits a block and a random item is supposed

00:05:13,810 --> 00:05:16,060
to come out of it, we might randomly pick

00:05:16,060 --> 00:05:18,710
among possible outfits that could pop out of the

00:05:18,710 --> 00:05:21,889
top of it for him to wear.

00:05:21,889 --> 00:05:24,910
And finally, the rendering is how your, the human

00:05:24,910 --> 00:05:26,470
playing your game actually gets to see what's going

00:05:26,470 --> 00:05:27,960
on.

00:05:27,960 --> 00:05:29,720
In a simple 2D game, you probably have something

00:05:29,720 --> 00:05:31,729
like this, where you just draw a bunch of

00:05:31,729 --> 00:05:34,030
images to fixed locations on the screen that are

00:05:34,030 --> 00:05:37,160
based on some of the current state. But you

00:05:37,160 --> 00:05:39,630
could also draw a text or 3D models or

00:05:39,630 --> 00:05:44,099
simpler shapes. And what's important to note is that

00:05:44,099 --> 00:05:46,389
the render method doesn't modify the state of the

00:05:46,389 --> 00:05:48,039
game at all.

00:05:48,039 --> 00:05:49,460
You can call it over and over again and

00:05:49,460 --> 00:05:50,880
you should always get the same image out of

00:05:50,880 --> 00:05:54,490
it, without modifying the state at all.

00:05:54,490 --> 00:05:58,250
So we have an awesome tool in libr- in

00:05:58,250 --> 00:06:03,780
Ruby for making mostly simple 2D games called Gosu.

00:06:03,780 --> 00:06:05,470
And Gosu, in its entirety, is about a hundred

00:06:05,470 --> 00:06:08,229
five methods, so you can master it in almost

00:06:08,229 --> 00:06:10,080
a weekend, and I'm gonna give you a brief

00:06:10,080 --> 00:06:13,970
tour of Gosu right now.

00:06:13,970 --> 00:06:16,800
At the core of Gosu is the Gosu::Window class.

00:06:16,800 --> 00:06:19,440
You're expected to sub class it and implement three

00:06:19,440 --> 00:06:23,160
methods on it: initialize, update, and draw. And you'll

00:06:23,160 --> 00:06:24,750
notice that these are the three methods from the

00:06:24,750 --> 00:06:26,819
game loop. Here, the setup is called initialize and

00:06:26,819 --> 00:06:29,629
render is called draw, but Gosu handles all of

00:06:29,629 --> 00:06:31,240
the hard work of getting the window to show

00:06:31,240 --> 00:06:33,879
up and managing the timing of the game loop.

00:06:33,879 --> 00:06:36,099
And you're just responsible for implementing your actual game

00:06:36,099 --> 00:06:38,449
logic in these three methods.

00:06:38,449 --> 00:06:41,259
And Gosu also provides a bunch of helpers for

00:06:41,259 --> 00:06:46,389
actually implementing parts of these methods. So Gosu has

00:06:46,389 --> 00:06:48,780
a bunch of drawing helpers. A commonly used one

00:06:48,780 --> 00:06:52,849
is draw_quad, where you pass it four points, consisting

00:06:52,849 --> 00:06:56,169
an x, a y coordinate, and a color, and

00:06:56,169 --> 00:06:58,039
it draws a quadrilateral on the screen.

00:06:58,039 --> 00:07:04,150
And there's also draw_triangle and draw_line. Similarly, you can

00:07:04,150 --> 00:07:06,650
construct an image with the window you're gonna end

00:07:06,650 --> 00:07:08,990
up drawing it onto, and a file name of,

00:07:08,990 --> 00:07:11,789
say, a PNG file, and just draw that image

00:07:11,789 --> 00:07:14,370
out to a given point on the screen.

00:07:14,370 --> 00:07:16,629
And you can also construct a font with the

00:07:16,629 --> 00:07:18,449
name of the font and a size and render

00:07:18,449 --> 00:07:24,389
text out onto the screen. Gosu also makes getting

00:07:24,389 --> 00:07:27,180
input from your player pretty easy. So the button

00:07:27,180 --> 00:07:29,229
down method will return true if a given button

00:07:29,229 --> 00:07:30,879
is being held down, whether it's a button on

00:07:30,879 --> 00:07:34,849
the keyboard, a mouse, or a gamepad or joystick.

00:07:34,849 --> 00:07:37,110
And if you have mouse interaction in your game,

00:07:37,110 --> 00:07:38,960
you can both set and read the positions of

00:07:38,960 --> 00:07:43,569
the mouse through mouse_x and mouse_y.

00:07:43,569 --> 00:07:46,409
Sounds are pretty simple, pretty similar to images. You

00:07:46,409 --> 00:07:48,930
can construct a sample with a window and a

00:07:48,930 --> 00:07:51,099
file name of the sound file, and then every

00:07:51,099 --> 00:07:54,199
time you call play, the sound will come out

00:07:54,199 --> 00:07:58,139
of your speakers.

00:07:58,139 --> 00:08:00,500
And then Gosu also includes some math helpers for

00:08:00,500 --> 00:08:02,949
a lot of 2D geometry you'll find yourself doing

00:08:02,949 --> 00:08:07,699
while making 2D games. So, offset_x and offset_y. If

00:08:07,699 --> 00:08:11,020
you traveled distance units across angle, it'll tell you

00:08:11,020 --> 00:08:12,530
how much of that traveling was on the x

00:08:12,530 --> 00:08:15,930
axis versus the y axis. Gosu.distance will give you

00:08:15,930 --> 00:08:19,009
the distance between two points.

00:08:19,009 --> 00:08:23,900
I've written a library called Hasu that makes rapid

00:08:23,900 --> 00:08:26,539
iteration on Gosu games possible, and it does this

00:08:26,539 --> 00:08:28,830
in a couple of ways. The main one is

00:08:28,830 --> 00:08:31,909
hot code loading. So normally with Gosu, if you're

00:08:31,909 --> 00:08:33,729
playing your game and you see something that you

00:08:33,729 --> 00:08:36,099
want to change, even after you change the code,

00:08:36,099 --> 00:08:37,719
you have to exit the game, start it back

00:08:37,719 --> 00:08:39,800
up again, and play again until you get to

00:08:39,800 --> 00:08:41,289
the point where you can see your change take

00:08:41,289 --> 00:08:42,620
effect.

00:08:42,620 --> 00:08:45,160
With Hasu, it watches all of your Ruby files,

00:08:45,160 --> 00:08:47,260
and as you change them, it reloads them into

00:08:47,260 --> 00:08:48,970
your running game, and you'll see the effect on

00:08:48,970 --> 00:08:52,269
the next cycle through the loop.

00:08:52,269 --> 00:08:55,060
Similarly, if you cause an exception in your Gosu

00:08:55,060 --> 00:08:56,709
game, it crashes out and you have to fix

00:08:56,709 --> 00:08:58,829
it, then start the game back up, find your

00:08:58,829 --> 00:09:00,450
way back to where you were when you caused

00:09:00,450 --> 00:09:02,470
the exception, and make sure it doesn't happen again.

00:09:02,470 --> 00:09:04,790
Gosu, or Hasu on the other hand, will catch

00:09:04,790 --> 00:09:07,649
your exceptions, pause your game, and then after you

00:09:07,649 --> 00:09:10,550
fixed them, resume the game and let you keep

00:09:10,550 --> 00:09:14,579
playing right from where you left off.

00:09:14,579 --> 00:09:17,779
And because Gosu does its initialization, it does its

00:09:17,779 --> 00:09:19,870
setup in its initialize method, you only get one

00:09:19,870 --> 00:09:22,019
shot at it, because you're only constructing the window

00:09:22,019 --> 00:09:25,480
once. Hasu, on the other hand, lets you define

00:09:25,480 --> 00:09:28,070
your initialization in a reset method that you can

00:09:28,070 --> 00:09:30,740
call at any time by pressing the r key,

00:09:30,740 --> 00:09:33,350
letting you iterate on your setup as well.

00:09:33,350 --> 00:09:36,240
And with that, I've shown you probably a solid

00:09:36,240 --> 00:09:38,440
quarter of Gosu's API and told you a little

00:09:38,440 --> 00:09:40,480
bit about Hasu, so now I'm gonna show you

00:09:40,480 --> 00:09:43,170
how to stick all the pieces together and make

00:09:43,170 --> 00:09:46,200
a complete game. And we're gonna do a pseudo

00:09:46,200 --> 00:09:48,800
live-coding demo of building pong from scratch.

00:09:48,800 --> 00:09:51,320
And I say pseudo cause most the typing is

00:09:51,320 --> 00:09:53,600
pre-recorded, so you don't have to watch me make

00:09:53,600 --> 00:09:57,190
a grievous typos or get lost or get stuck

00:09:57,190 --> 00:10:04,190
in some funny emax mode.

00:10:10,980 --> 00:10:13,250
So we'll start off by installing Hasu, which will

00:10:13,250 --> 00:10:15,100
also install Gosu.

00:10:15,100 --> 00:10:22,100
And we'll put our code in pong dot rb.

00:10:22,100 --> 00:10:23,839
And our pong class is going to sub class

00:10:23,839 --> 00:10:28,029
Hasu::Window, and I'll give it a width and a

00:10:28,029 --> 00:10:34,010
height that are about 75% of this screen.

00:10:34,010 --> 00:10:35,610
In our constructor, we're gonna have to call up

00:10:35,610 --> 00:10:37,740
to Gosu's constructor to give it the size of

00:10:37,740 --> 00:10:39,410
our window and the fact that we don't want

00:10:39,410 --> 00:10:41,100
it to be full screen.

00:10:41,100 --> 00:10:43,920
And at the bottom of the file, I'll run

00:10:43,920 --> 00:10:44,660
this class.

00:10:44,660 --> 00:10:47,639
In a new tab, I can run that file,

00:10:47,639 --> 00:10:49,920
and we end up with a blank window. So

00:10:49,920 --> 00:10:51,209
it's time to get some things showing up here,

00:10:51,209 --> 00:10:56,790
and I'm gonna start with the ball.

00:10:56,790 --> 00:10:58,529
So for Hasu hot code loading, you have to

00:10:58,529 --> 00:11:03,670
use Hasu dot load instead of require. And in

00:11:03,670 --> 00:11:05,930
our setup, we'll just construct a ball and assign

00:11:05,930 --> 00:11:11,880
it to the instance variable.

00:11:11,880 --> 00:11:13,389
And in the draw method, we can tell the

00:11:13,389 --> 00:11:16,980
draw, the ball to draw itself onto the window.

00:11:16,980 --> 00:11:21,709
And our ball's gonna start out being pretty simple.

00:11:21,709 --> 00:11:23,569
It's gonna have two attributes - x and y

00:11:23,569 --> 00:11:30,569
- that represent the center of the ball. And

00:11:30,720 --> 00:11:36,389
they'll default to the center of the window.

00:11:36,389 --> 00:11:42,910
And for drawing, I'll use the draw quad method

00:11:42,910 --> 00:11:49,910
that I showed you back during the slides. Here,

00:11:50,120 --> 00:11:53,570
x1 is gonna be the left edge of the

00:11:53,570 --> 00:11:57,170
window, of the ball. Y1 will be the top.

00:11:57,170 --> 00:11:59,199
X2 will be the right side of the ball

00:11:59,199 --> 00:12:01,399
and Y2 will be the bottom. And we'll define

00:12:01,399 --> 00:12:03,399
those in just a few seconds.

00:12:03,399 --> 00:12:06,790
And we'll use the Gosu red constant for the

00:12:06,790 --> 00:12:13,790
color of the ball. So the left edge of

00:12:14,649 --> 00:12:16,630
the ball is just gonna be the horizontal center

00:12:16,630 --> 00:12:19,180
of the ball minus half its size, which we

00:12:19,180 --> 00:12:26,180
have to define. And x2 and y1 and y2

00:12:26,550 --> 00:12:28,410
are all pretty similar. They're just half the ball's

00:12:28,410 --> 00:12:35,410
size offset from their center.

00:12:38,930 --> 00:12:40,350
And after we reset, we have a ball on

00:12:40,350 --> 00:12:42,209
the screen. And it's a little small so I'm

00:12:42,209 --> 00:12:45,160
gonna bump the size up. And as soon as

00:12:45,160 --> 00:12:47,459
we tabbed back, the larger, the new code was

00:12:47,459 --> 00:12:49,829
taking effect and we see the larger ball. And

00:12:49,829 --> 00:12:55,480
it's time to make this move.

00:12:55,480 --> 00:12:59,769
So we'll add the update method to our window.

00:12:59,769 --> 00:13:02,970
And each update we'll just tell the ball to

00:13:02,970 --> 00:13:06,680
move itself. And so the ball's gonna need an

00:13:06,680 --> 00:13:13,100
angle and a speed, and I'll default the angle

00:13:13,100 --> 00:13:15,360
to up and to the right, and the speed

00:13:15,360 --> 00:13:17,290
be four pixels per tick.

00:13:17,290 --> 00:13:20,610
And that move method will be pretty simple. We'll

00:13:20,610 --> 00:13:22,490
use the offset x and offset y that we

00:13:22,490 --> 00:13:26,810
saw earlier to calculate deltas for the x and

00:13:26,810 --> 00:13:33,810
the y position. And then we can add those

00:13:35,180 --> 00:13:37,839
deltas to the actual x and y position, and

00:13:37,839 --> 00:13:43,350
that'll give us our movement.

00:13:43,350 --> 00:13:48,380
And it's a little slow, so I'm gonna bump

00:13:48,380 --> 00:13:54,779
the speed up just a little bit. And this

00:13:54,779 --> 00:13:56,930
is cool, except that the ball is moving off

00:13:56,930 --> 00:13:59,000
the top edge of the screen. So let's make

00:13:59,000 --> 00:14:02,170
it bounce.

00:14:02,170 --> 00:14:06,529
At the bottom of the move method, we'll check

00:14:06,529 --> 00:14:08,070
and see if we've just moved the ball off

00:14:08,070 --> 00:14:10,370
the top edge of the window, we should move

00:14:10,370 --> 00:14:12,949
it back down, and then flip the y component

00:14:12,949 --> 00:14:14,860
of the ball's angle to give us a natural

00:14:14,860 --> 00:14:21,860
bounce. And same thing for when the ball's heading

00:14:27,089 --> 00:14:32,459
towards the bottom of the screen. We'll check if

00:14:32,459 --> 00:14:33,660
the ball's moved off of the bottom of the

00:14:33,660 --> 00:14:36,399
screen, and if it has we'll nudge it back

00:14:36,399 --> 00:14:38,579
up to where it belongs, and, again, flip the

00:14:38,579 --> 00:14:45,579
y component of its angle.

00:14:47,170 --> 00:14:48,649
And I'm gonna extract out this flipping of the

00:14:48,649 --> 00:14:50,310
y component of the angle into a new method

00:14:50,310 --> 00:14:53,889
called bounce_off_edge. This dries up our code a little

00:14:53,889 --> 00:14:55,259
bit, but it would also be a great place

00:14:55,259 --> 00:14:58,259
to hook in a sound effect.

00:14:58,259 --> 00:15:05,259
And it looks like we don't have access to

00:15:08,440 --> 00:15:10,420
dx and dy in this method. So we'll need

00:15:10,420 --> 00:15:12,660
to pull them out of move into their own

00:15:12,660 --> 00:15:19,660
methods, and they'll prove useful as we move on.

00:15:23,529 --> 00:15:29,920
And so it looks like the refactoring worked. It's

00:15:29,920 --> 00:15:32,100
a little boring that the ball is headed in

00:15:32,100 --> 00:15:34,670
the same direction each time the game starts. So

00:15:34,670 --> 00:15:39,009
I'm gonna randomize it just a little bit.

00:15:39,009 --> 00:15:41,029
These numbers will cause it to start somewhere in

00:15:41,029 --> 00:15:43,089
a cone facing to the right, so it never

00:15:43,089 --> 00:15:45,540
is moving straight up or straight down. And then

00:15:45,540 --> 00:15:48,130
half the time I'll also flip it so that

00:15:48,130 --> 00:15:54,690
it heads to the left.

00:15:54,690 --> 00:15:57,329
OK, so now we need to do something about

00:15:57,329 --> 00:15:59,180
the fact that the ball is flying off the

00:15:59,180 --> 00:16:00,980
left and right edge of the screen, and in

00:16:00,980 --> 00:16:03,540
pong, the left player and the right player will

00:16:03,540 --> 00:16:05,540
each have a score. And any time they hit

00:16:05,540 --> 00:16:08,670
the ball across their opponent's line, they get a

00:16:08,670 --> 00:16:13,269
new point and the game starts over.

00:16:13,269 --> 00:16:15,949
So back in our reset method, we'll start off

00:16:15,949 --> 00:16:21,440
each player with the score of zero. And we'll

00:16:21,440 --> 00:16:22,850
construct a font object that we can use to

00:16:22,850 --> 00:16:29,850
draw these scores onto the screen.

00:16:31,750 --> 00:16:33,810
And we'll draw the left player's score in the

00:16:33,810 --> 00:16:39,500
top left corner of the window, and we'll put

00:16:39,500 --> 00:16:45,350
the right player's score in the top right corner.

00:16:45,350 --> 00:16:52,040
And then each time through the update method, we

00:16:52,040 --> 00:16:53,769
can ask the ball if it's moved off the

00:16:53,769 --> 00:16:56,009
left edge of the screen, and if it has,

00:16:56,009 --> 00:16:58,440
we should increment the right player's score and reset

00:16:58,440 --> 00:17:05,440
the ball, and if the ball's moved off the

00:17:06,410 --> 00:17:08,610
right side, we should give the left player a

00:17:08,610 --> 00:17:09,230
point.

00:17:09,230 --> 00:17:12,270
And so I'm gonna pause here for a little

00:17:12,270 --> 00:17:14,980
bit and point out something about my development work

00:17:14,980 --> 00:17:17,520
flow when I'm doing games. You'll notice I'm not

00:17:17,520 --> 00:17:19,380
writing tests like you normally would in a Rails

00:17:19,380 --> 00:17:22,570
application, but I am writing my code outside in,

00:17:22,570 --> 00:17:24,610
and I still get this outside in feedback, like

00:17:24,610 --> 00:17:27,650
I would while doing outside in TDD.

00:17:27,650 --> 00:17:29,570
So here, this exception is telling me that I

00:17:29,570 --> 00:17:32,080
haven't defined off_left, and then that's the next thing

00:17:32,080 --> 00:17:39,080
to do. So off_left and off_right are incredibly straight-forward.

00:17:41,000 --> 00:17:43,480
Basically, is the left-edge of the ball hanging off

00:17:43,480 --> 00:17:47,020
the left-edge of the window. Or is the right-edge

00:17:47,020 --> 00:17:49,050
of the ball hanging off the right-edge of the

00:17:49,050 --> 00:17:51,510
window.

00:17:51,510 --> 00:17:56,000
And now we have the score going up every

00:17:56,000 --> 00:17:58,260
time the ball crosses the opposite side of the

00:17:58,260 --> 00:18:01,300
screen, which is exactly what we want. But it's

00:18:01,300 --> 00:18:03,350
a little mean to give these players scores when

00:18:03,350 --> 00:18:05,910
they don't really have much control over the course

00:18:05,910 --> 00:18:07,300
of the game.

00:18:07,300 --> 00:18:09,920
So we need some paddles.

00:18:09,920 --> 00:18:13,720
Unsurprisingly, the paddle code will go in paddle dot

00:18:13,720 --> 00:18:19,000
rb. And we'll start the game with, with two

00:18:19,000 --> 00:18:26,000
paddles. One on the left and another on the

00:18:26,950 --> 00:18:32,100
right.

00:18:32,100 --> 00:18:33,140
And like we did with the ball, we'll tell

00:18:33,140 --> 00:18:40,140
the paddles to draw themselves onto the screen. And

00:18:52,130 --> 00:18:54,670
the paddle will have two attributes. Its side and

00:18:54,670 --> 00:18:58,510
its vertical center. And we'll use the side that

00:18:58,510 --> 00:19:04,300
was passed in. And like the ball, the paddles

00:19:04,300 --> 00:19:06,670
will start off centered in the window.

00:19:06,670 --> 00:19:12,970
And I'm gonna cheat here and copy the ball's

00:19:12,970 --> 00:19:15,910
draw method, cause this is actually a generic rectangle

00:19:15,910 --> 00:19:18,450
drawing method. But if we had more time, we

00:19:18,450 --> 00:19:20,800
could extract this out into a common superclass or

00:19:20,800 --> 00:19:24,960
a mixin that both paddle and ball would use.

00:19:24,960 --> 00:19:28,780
And so the left edge of the paddle is

00:19:28,780 --> 00:19:30,200
actually gonna depend on which side of the screen

00:19:30,200 --> 00:19:32,470
its on. So the left paddle's left edge is

00:19:32,470 --> 00:19:34,380
gonna be flush against the left edge of the

00:19:34,380 --> 00:19:38,480
window, and the right paddle's left edge is gonna

00:19:38,480 --> 00:19:42,080
be, the right edge of the window minus the

00:19:42,080 --> 00:19:43,010
paddle's width.

00:19:43,010 --> 00:19:46,010
And I'll give paddle a width and a height

00:19:46,010 --> 00:19:53,010
that I think look pretty decent. And the right

00:19:55,300 --> 00:19:56,690
edge of the paddle is just gonna be th

00:19:56,690 --> 00:20:00,880
left edge plus the width. And like the ball,

00:20:00,880 --> 00:20:03,930
the top will be its center minus half its

00:20:03,930 --> 00:20:08,700
height and the bottom will be the top plus

00:20:08,700 --> 00:20:13,060
the height.

00:20:13,060 --> 00:20:15,780
And we reset and half some decent looking paddles.

00:20:15,780 --> 00:20:18,990
And it's time to make them move.

00:20:18,990 --> 00:20:23,440
So I'm gonna have the left paddle be controlled

00:20:23,440 --> 00:20:25,940
by the w and s keys on the keyboard.

00:20:25,940 --> 00:20:28,070
So while the w key is being held down,

00:20:28,070 --> 00:20:35,070
the left paddle will move up. And up is

00:20:39,280 --> 00:20:41,540
pretty simple. We just add, or we subtract a

00:20:41,540 --> 00:20:45,330
little bit off of y, and whenever I hit

00:20:45,330 --> 00:20:49,380
w the paddle will move up.

00:20:49,380 --> 00:20:51,060
And down is the same thing, but we add

00:20:51,060 --> 00:20:58,060
instead of subtract. And I'll wire the s key

00:20:58,260 --> 00:21:05,260
up to control down.

00:21:08,770 --> 00:21:10,310
And the right player will use the up and

00:21:10,310 --> 00:21:17,310
down arrows to control their paddle. And so our

00:21:22,810 --> 00:21:25,420
paddles are moving, but there's a problem.

00:21:25,420 --> 00:21:27,940
Actually I'm gonna extract out this magic number into

00:21:27,940 --> 00:21:30,030
a constant and bump it up just a little

00:21:30,030 --> 00:21:36,210
bit so that our paddles are a little zippier.

00:21:36,210 --> 00:21:38,480
But there's a small problem with the paddles' movement,

00:21:38,480 --> 00:21:40,310
and that's that they can move off the edges

00:21:40,310 --> 00:21:43,630
of the screen. But this is easy enough to

00:21:43,630 --> 00:21:50,630
fix. When we're moving down - when we're moving

00:21:50,770 --> 00:21:52,490
up, if the top edge of the paddle has

00:21:52,490 --> 00:21:54,890
crossed the top edge of the screen, we push

00:21:54,890 --> 00:22:01,890
the, the paddle back down to where it belongs.

00:22:03,180 --> 00:22:04,770
And if its bottom edge has crossed the bottom

00:22:04,770 --> 00:22:08,150
edge of the window, we can bump it back

00:22:08,150 --> 00:22:15,150
up.

00:22:20,990 --> 00:22:22,050
And now it's time for the real meat of

00:22:22,050 --> 00:22:26,470
the game. Getting the ball and the paddles to

00:22:26,470 --> 00:22:30,580
interact. So every tick through the game, we'll ask

00:22:30,580 --> 00:22:34,460
the ball if its intersecting the left paddle, and

00:22:34,460 --> 00:22:36,850
if it is, we'll tell it to bounce off

00:22:36,850 --> 00:22:43,850
of the left paddle. And same thing for the

00:22:45,300 --> 00:22:52,300
right paddle.

00:22:52,770 --> 00:22:54,880
And it's not important to understand exactly what this

00:22:54,880 --> 00:22:57,400
intersect method is doing right now, just know that

00:22:57,400 --> 00:23:00,550
it's the generic formula for determining if two rectangles

00:23:00,550 --> 00:23:03,430
are overlapping. I don't really have enough time to

00:23:03,430 --> 00:23:10,430
dive into the details of exactly how this works,

00:23:11,150 --> 00:23:13,280
though.

00:23:13,280 --> 00:23:19,750
And when it hits the paddle, we don't have

00:23:19,750 --> 00:23:26,750
our bounce_off_paddle defined yet, so that's the next task.

00:23:30,020 --> 00:23:31,650
So when the ball hits the left paddle, we'll

00:23:31,650 --> 00:23:33,290
need to move the ball a little to the

00:23:33,290 --> 00:23:35,200
right, so that it's no longer overlapping the left

00:23:35,200 --> 00:23:36,520
side of the paddle, or possibly hanging off the

00:23:36,520 --> 00:23:38,730
edge of the screen, and conversely when it hits

00:23:38,730 --> 00:23:40,290
the right paddle, we'll have to move it back

00:23:40,290 --> 00:23:44,700
to the left.

00:23:44,700 --> 00:23:46,410
And then similarly to when the ball hit the

00:23:46,410 --> 00:23:48,660
top or the bottom, we can flip the x

00:23:48,660 --> 00:23:51,560
component of the angle so that the ball heads

00:23:51,560 --> 00:23:58,060
back in the other direction. And this works, but

00:23:58,060 --> 00:24:01,200
it leads to a slightly boring game, where the

00:24:01,200 --> 00:24:04,130
ball doesn't do much interesting.

00:24:04,130 --> 00:24:07,490
So to fix this, when the ball hits near

00:24:07,490 --> 00:24:09,040
the center of the paddle, I'm gonna have it

00:24:09,040 --> 00:24:11,520
come off at a very steep angle. But when

00:24:11,520 --> 00:24:12,930
it hits towards the edges, I'll have it come

00:24:12,930 --> 00:24:16,780
off more shallow.

00:24:16,780 --> 00:24:18,560
So to do this, we can take the difference

00:24:18,560 --> 00:24:21,160
of the vertical position between the ball and the

00:24:21,160 --> 00:24:23,540
paddle and divide it by the paddle's height, and

00:24:23,540 --> 00:24:25,800
this'll give us a number between negative point five

00:24:25,800 --> 00:24:28,960
and point five. And we can multiply that by

00:24:28,960 --> 00:24:32,970
120 to get us a cone, and then tilt

00:24:32,970 --> 00:24:36,240
that cone to the right. And then if we're

00:24:36,240 --> 00:24:37,580
hitting the right paddle, we actually want to flip

00:24:37,580 --> 00:24:44,580
the cone back so it's facing the left.

00:24:45,840 --> 00:24:47,310
And so now the ball's doing what we want.

00:24:47,310 --> 00:24:48,860
When it hits near the center of the paddle,

00:24:48,860 --> 00:24:52,500
it comes off in a horizontal direction. But when

00:24:52,500 --> 00:24:54,030
it hits near the edges of the paddle, it

00:24:54,030 --> 00:24:58,270
comes off much more vertically.

00:24:58,270 --> 00:24:59,530
And to make things a little more interesting, we

00:24:59,530 --> 00:25:01,870
can also speed up the ball every time it

00:25:01,870 --> 00:25:04,490
hits the paddle. So after ten or so bounces,

00:25:04,490 --> 00:25:11,490
the game actually gets pretty challenging.

00:25:21,030 --> 00:25:22,510
And I'm a little tired of having my left

00:25:22,510 --> 00:25:29,510
hand play against my right hand. So I'm gonna

00:25:30,310 --> 00:25:34,580
build a simple AI that I can play against.

00:25:34,580 --> 00:25:38,550
So we'll have the left paddle be the AI.

00:25:38,550 --> 00:25:42,870
And so if the left paddle is the AI,

00:25:42,870 --> 00:25:48,270
then it'll control its own movement, rather than letting

00:25:48,270 --> 00:25:52,140
the human control it with the keyboard.

00:25:52,140 --> 00:25:58,050
And we'll pass in a new argument to the

00:25:58,050 --> 00:26:00,630
paddle's constructor noting that it should be controlled by

00:26:00,630 --> 00:26:07,630
the computer. We'll add the new field and take

00:26:09,300 --> 00:26:10,960
it in in the constructor, but have it default

00:26:10,960 --> 00:26:13,000
to false so that the right player is still

00:26:13,000 --> 00:26:15,950
human controlled.

00:26:15,950 --> 00:26:19,900
And the AI movement is gonna be pretty simple.

00:26:19,900 --> 00:26:22,850
If the paddle is below the ball, it should

00:26:22,850 --> 00:26:29,850
move up. Otherwise it should move down. And after

00:26:33,160 --> 00:26:35,990
we reset and have the left paddle controlled by

00:26:35,990 --> 00:26:38,920
the AI, it works, but we get this weird

00:26:38,920 --> 00:26:43,460
sort of jittering, which is easy enough to fix.

00:26:43,460 --> 00:26:50,460
I jumped past that, sorry. So, I've shown you

00:26:52,260 --> 00:26:53,420
enough for now, but we still don't have a

00:26:53,420 --> 00:26:55,300
way to quit the game. So we can define

00:26:55,300 --> 00:26:58,880
a button down call back in the window, and

00:26:58,880 --> 00:27:02,020
when the escape key is pressed, you can tell

00:27:02,020 --> 00:27:03,610
the window to close itself and end the game

00:27:03,610 --> 00:27:10,610
And that was pong in fifteen minutes.

00:27:18,490 --> 00:27:20,590
So we didn't necessarily end up with the prettiest

00:27:20,590 --> 00:27:24,980
looking code, and the update method got pretty unwieldy.

00:27:24,980 --> 00:27:27,530
But you saw how easy it was to notice

00:27:27,530 --> 00:27:29,270
a bug or find a feature you wanted to

00:27:29,270 --> 00:27:31,100
add, and write ten or twenty lines of code

00:27:31,100 --> 00:27:32,600
in a minute or two and build the game

00:27:32,600 --> 00:27:34,750
up from nothing.

00:27:34,750 --> 00:27:35,890
I've put all of the code for this on

00:27:35,890 --> 00:27:40,120
my GitHub, and the commits are roughly ordered in

00:27:40,120 --> 00:27:41,790
vid - with the videos I just showed you.

00:27:41,790 --> 00:27:43,030
So if you want to see it get built

00:27:43,030 --> 00:27:48,710
up again, you can just follow the commits.

00:27:48,710 --> 00:27:49,930
So if you found this interesting, I have a

00:27:49,930 --> 00:27:53,630
few more pointers of other things to look into.

00:27:53,630 --> 00:27:56,340
And this link in the top left will, top

00:27:56,340 --> 00:27:59,180
right, sorry, will take you to a git that

00:27:59,180 --> 00:28:00,710
has links to everything else I'm about to talk

00:28:00,710 --> 00:28:02,080
to you.

00:28:02,080 --> 00:28:05,790
So Gosu actually has a decent ecosystem going on.

00:28:05,790 --> 00:28:09,650
Metra, Gamebox, and Chingo, are all frameworks built on

00:28:09,650 --> 00:28:11,610
top of Gosu that provide you a little more

00:28:11,610 --> 00:28:14,780
structure and help you deal with common tasks like

00:28:14,780 --> 00:28:17,360
mapping keys on the keyboard to method calls on

00:28:17,360 --> 00:28:21,280
your models, or dealing with menus or pausing.

00:28:21,280 --> 00:28:25,540
Chipmunk is a Ruby wrapper around the Chipmunk's physics

00:28:25,540 --> 00:28:28,150
library, so the physics in pong wasn't too complex,

00:28:28,150 --> 00:28:30,400
but as you start getting into gravity and having

00:28:30,400 --> 00:28:33,140
dozens or hundreds of objects all interacting, getting the

00:28:33,140 --> 00:28:36,350
math right is really hard, especially for corner cases.

00:28:36,350 --> 00:28:38,170
And the Chipmunk library has this all taken care

00:28:38,170 --> 00:28:41,150
of for you.

00:28:41,150 --> 00:28:43,770
The Releasy gem makes it easy to package Ruby

00:28:43,770 --> 00:28:47,520
applications, including Gosu games, up into Windows executables or

00:28:47,520 --> 00:28:49,580
Mac apps. So you can put them online for

00:28:49,580 --> 00:28:51,980
people to download and not force them to install

00:28:51,980 --> 00:28:56,290
Ruby and RVM and a bunch of gems.

00:28:56,290 --> 00:28:58,390
And Gosu also lets you drop down to sort

00:28:58,390 --> 00:29:01,120
of raw, open GL code, when you're interested in

00:29:01,120 --> 00:29:03,590
learning about 3D graphics, which is exactly what I

00:29:03,590 --> 00:29:08,300
did in the Minecraft demo I showed earlier.

00:29:08,300 --> 00:29:10,480
And then Gosu also has some somewhat active forums,

00:29:10,480 --> 00:29:13,290
where people are showing off games they've made and

00:29:13,290 --> 00:29:15,750
pointing to their Gosu source code, and showing off

00:29:15,750 --> 00:29:18,660
tools that they've built to help them make games

00:29:18,660 --> 00:29:22,990
more quickly.

00:29:22,990 --> 00:29:25,870
So game programming patterns is a freely available online

00:29:25,870 --> 00:29:28,760
book that I think is really awesome. When I

00:29:28,760 --> 00:29:32,600
started doing game programming, the patterns and best practices

00:29:32,600 --> 00:29:35,280
I knew from web development didn't really translate over

00:29:35,280 --> 00:29:38,120
to help me structure my games. So game programming

00:29:38,120 --> 00:29:39,970
patterns is written by a veteran of the games'

00:29:39,970 --> 00:29:42,340
industry, and he talks about a lot of the

00:29:42,340 --> 00:29:45,290
common problems that games face as they grow in

00:29:45,290 --> 00:29:48,240
size, and what the, what the industry has learned

00:29:48,240 --> 00:29:50,820
over the decades on how to structure those solutions,

00:29:50,820 --> 00:29:52,790
and sort of the trade-offs that come into place

00:29:52,790 --> 00:29:57,600
while, while taking advantage of these patterns.

00:29:57,600 --> 00:29:59,610
And if you need an excuse to take a

00:29:59,610 --> 00:30:01,910
weekend to learn how to make a game, you've

00:30:01,910 --> 00:30:04,450
got one coming up in about a month. Ludum

00:30:04,450 --> 00:30:08,820
Dare is a forty-eight hour game development contest. Saturday

00:30:08,820 --> 00:30:11,730
at midnight, they announce a theme, and thousands of

00:30:11,730 --> 00:30:15,140
people all over the world start developing games, and

00:30:15,140 --> 00:30:17,270
by Sunday night you turn it in and there's

00:30:17,270 --> 00:30:18,840
an online gallery of all the games that were

00:30:18,840 --> 00:30:21,040
made that weekend, that all follow the same theme.

00:30:21,040 --> 00:30:23,740
And I think Gosu and Hasu are perfect tools

00:30:23,740 --> 00:30:25,920
for just trying to learn something over a weekend

00:30:25,920 --> 00:30:28,530
and finish a game from, finish a game from

00:30:28,530 --> 00:30:31,150
start to finish.

00:30:31,150 --> 00:30:33,390
And with that, thank you and please go have

00:30:33,390 --> 00:30:36,150

YouTube URL: https://www.youtube.com/watch?v=irMfy8I2OVQ


