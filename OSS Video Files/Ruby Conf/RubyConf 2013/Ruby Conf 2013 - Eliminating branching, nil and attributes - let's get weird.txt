Title: Ruby Conf 2013 - Eliminating branching, nil and attributes - let's get weird
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By David Copeland


Although "being OO" isn't an end unto itself, we can often learn a great deal about programming by taking things to the extreme. Branching, nil checks, and attributes are not very "OO" and are often the source of great complication in our code. What would our code look like if we did everything we could to avoid them?

In this talk, we'll create some odd-looking constructs and write some weird code in an attempt to understand just how useful branching, nil, and attributes really are. Do these constructs make our code easier to read and understand, or are they vestiges from our shared programming backgrounds like C, PHP, and Java?

Help us caption & translate this video!

http://amara.org/v/FG5G/
Captions: 
	00:00:17,280 --> 00:00:20,160
DAVID COPELAND: All right. Has everyone enjoyed their lunch?

00:00:20,160 --> 00:00:25,089
Ready to talk about some really strange and weird code?

00:00:25,089 --> 00:00:27,240
So thanks a lot for coming. My talk is

00:00:27,260 --> 00:00:30,381
called eliminating branching, nil, and attributes - let's get

00:00:30,381 --> 00:00:34,039
weird. So we're gonna see some really strange code.

00:00:34,040 --> 00:00:36,250
Briefly, about me, I work at a company called

00:00:36,250 --> 00:00:39,950
Stitch Fix. We're a personal styling service for women's

00:00:39,950 --> 00:00:42,180
clothes. I'd love to talk about all the cool

00:00:42,200 --> 00:00:44,290
things that we're doing, but that's not what this

00:00:44,290 --> 00:00:44,920
talk is about.

00:00:44,920 --> 00:00:47,540
I wrote this book about writing command-line apps in

00:00:47,540 --> 00:00:49,610
Ruby, which you should buy and read and do.

00:00:49,610 --> 00:00:52,310
Also, not really what the talk is about. I

00:00:52,310 --> 00:00:55,160
also wrote another book about how to do everything

00:00:55,160 --> 00:00:57,140
to be a great programmer except for the actual

00:00:57,140 --> 00:01:00,010
programming part. Again, it's not really what I'd like

00:01:00,020 --> 00:01:00,650
to talk about.

00:01:00,650 --> 00:01:02,780
I'd like to talk about Top Chef. Anybody watch

00:01:02,780 --> 00:01:05,699
Top Chef? All right. My wife and I have

00:01:05,700 --> 00:01:07,571
watched it for years. It's one of my favorite

00:01:07,600 --> 00:01:09,880
shows. I'm very excited when it shows up. I

00:01:09,880 --> 00:01:11,590
haven't been home for about a month, so no

00:01:11,590 --> 00:01:14,760
spoilers about the current season.

00:01:14,760 --> 00:01:16,389
What I love, and if you're not familiar with

00:01:16,400 --> 00:01:18,281
it, it's a reality show about cooking, so these

00:01:18,281 --> 00:01:21,520
chef's will compete each week and, at the end

00:01:21,520 --> 00:01:23,899
of each episode, a chef will be eliminated, and

00:01:23,900 --> 00:01:25,830
at the end of the season, one chef wins

00:01:25,830 --> 00:01:28,850
a bunch of money and some kudos and other

00:01:28,850 --> 00:01:29,581
things like that.

00:01:29,581 --> 00:01:31,209
What I like about it is that, unlike a

00:01:31,220 --> 00:01:34,000
lot of reality shows that are about dramatic personalities

00:01:34,000 --> 00:01:36,630
arguing in some house that they live together, on

00:01:36,640 --> 00:01:40,640
Top Chef, you're watching experts execute things that they're

00:01:40,640 --> 00:01:43,610
good at. You're watching these people cook this amazing

00:01:43,610 --> 00:01:47,310
food under intense pressure and just watching experts work,

00:01:47,320 --> 00:01:48,480
I always find fascinating.

00:01:48,480 --> 00:01:50,811
So what's also fascinating is that the show's format

00:01:50,811 --> 00:01:54,969
hasn't really changed over the years. And so when

00:01:54,969 --> 00:01:57,170
you see experts doing things in a very similar

00:01:57,180 --> 00:02:00,170
format over many years, patterns start to emerge that

00:02:00,180 --> 00:02:01,960
I find interesting.

00:02:01,960 --> 00:02:04,230
So the beginning of each show, there's what they

00:02:04,230 --> 00:02:06,091
call the Quick Fire challenge. So the chefs are

00:02:06,100 --> 00:02:09,619
given a short amount of time to make a

00:02:09,620 --> 00:02:12,401
dish. So, for example, they may have to make

00:02:12,401 --> 00:02:17,069
an Asian inspired dish that features the dycon radish,

00:02:17,069 --> 00:02:19,540
and they might have thirty minutes to do it.

00:02:19,540 --> 00:02:21,531
And so it's very intense watching them try to

00:02:21,540 --> 00:02:24,519
do this. Now, what always happens in the show,

00:02:24,520 --> 00:02:25,931
and if you watch Top Chef, you watch it

00:02:25,931 --> 00:02:28,710
for years, you'll know exactly where I'm going, they're

00:02:28,720 --> 00:02:30,709
will always be one chef who works in an

00:02:30,709 --> 00:02:33,391
Asian restaurant, who makes Asian food. This chef grew

00:02:33,400 --> 00:02:36,829
up on a dycon radish farm, knows everything about

00:02:36,829 --> 00:02:39,810
everything in this particular challenge. So he is very

00:02:39,820 --> 00:02:41,990
confident. He is, like, I got this. I know

00:02:41,990 --> 00:02:44,230
how to do all these things. No one's gonna,

00:02:44,240 --> 00:02:46,270
no one's gonna beat me. I'm gonna get the

00:02:46,270 --> 00:02:48,010
advantage later in the show by winning the Quick

00:02:48,020 --> 00:02:48,690
Fire challenge.

00:02:48,690 --> 00:02:51,171
And, of course, there's always another chef, and she

00:02:51,180 --> 00:02:53,250
is a French pastry chef. She doesn't know what

00:02:53,250 --> 00:02:55,610
a dycon radish is. She doesn't like Asian food.

00:02:55,610 --> 00:02:58,439
She's never cooked Asian food. And she's very worried

00:02:58,460 --> 00:03:00,391
that not only is she not going to win,

00:03:00,391 --> 00:03:02,610
but she's going to lose the Quick Fire challenge,

00:03:02,620 --> 00:03:05,159
which comes with a disadvantage later, which means that

00:03:05,160 --> 00:03:07,580
her chance of getting eliminated is very high. So

00:03:07,580 --> 00:03:12,440
she's very upset about this particular challenge.

00:03:12,440 --> 00:03:15,611
Now what happens is our chef who works in

00:03:15,611 --> 00:03:17,569
the Asian restaurant will do what he always does.

00:03:17,569 --> 00:03:20,071
Produce what he always produces. And he will produce

00:03:20,080 --> 00:03:22,509
a mediocre dish, because the level of competition is

00:03:22,509 --> 00:03:24,950
so high, when he just executes these things that

00:03:24,950 --> 00:03:27,371
he knows how to do, he's not really rising

00:03:27,400 --> 00:03:29,829
to the level of his competition. Which is kind

00:03:29,829 --> 00:03:30,721
of unsurprising.

00:03:30,721 --> 00:03:32,990
But what's more surprising is that our French pastry

00:03:32,990 --> 00:03:35,870
chef will, invariable - oh, I forgot to hit

00:03:35,870 --> 00:03:40,739
start on this thing. Will invariably win the competition,

00:03:40,740 --> 00:03:42,421
even though she technically has no idea what she's

00:03:42,421 --> 00:03:45,459
doing, right. Because she has the abilities of a

00:03:45,460 --> 00:03:48,680
chef, she understands the basic tools of cooking, and

00:03:48,700 --> 00:03:50,340
even though she doesn't know how Asian food is

00:03:50,340 --> 00:03:52,611
supposed to be made, or what you're supposed to

00:03:52,620 --> 00:03:55,670
do with the dycon radish, she's forced to get

00:03:55,670 --> 00:03:57,110
creative.

00:03:57,120 --> 00:03:58,640
This happens all the time on the show, and

00:03:58,640 --> 00:04:04,420
I think it's interesting to note the, being, being

00:04:04,420 --> 00:04:08,049
constrained and being forced to work without the things

00:04:08,049 --> 00:04:10,581
that are comfortable to you can force people to

00:04:10,581 --> 00:04:13,559
become creative and can force people to do something

00:04:13,560 --> 00:04:16,061
that they wouldn't have thought of because they're outside

00:04:16,061 --> 00:04:17,390
of their comfort zone.

00:04:17,390 --> 00:04:19,080
So that's what this talk is about. We're going

00:04:19,100 --> 00:04:22,720
to talk about some things, like nil, like branching,

00:04:22,720 --> 00:04:25,380
like attributes, that we use all the time and

00:04:25,380 --> 00:04:27,550
are very useful, and are comfortable to us, and

00:04:27,550 --> 00:04:29,550
we're gonna take those away and see what the

00:04:29,560 --> 00:04:32,600
code looks like without those and see if that

00:04:32,600 --> 00:04:35,620
kind of makes us get a little more creative

00:04:35,620 --> 00:04:37,370
or think of things that we wouldn't normally have

00:04:37,370 --> 00:04:39,890
thought of.

00:04:39,890 --> 00:04:41,570
So I want to first talk about the billion

00:04:41,580 --> 00:04:46,230
dollar mistake. Anybody familiar with this term? So it

00:04:46,230 --> 00:04:50,480
was coined by Tony Harr, who is a luminary

00:04:50,480 --> 00:04:53,380
in the world of database research. If you've ever

00:04:53,380 --> 00:04:55,880
used a relational database, you have him to thank

00:04:55,880 --> 00:04:58,310
for how it works.

00:04:58,320 --> 00:05:01,320
And in 1965, before most of us were probably

00:05:01,320 --> 00:05:04,350
born, before most of us were probably programming, he

00:05:04,350 --> 00:05:07,869
was working on an object-oriented programming language. He has

00:05:07,869 --> 00:05:08,950
this to say.

00:05:08,960 --> 00:05:11,971
"I was designing the first comprehensive type system for

00:05:11,980 --> 00:05:15,950
references in an object oriented language-" Remember, 1965. "I

00:05:15,950 --> 00:05:17,750
couldn't resist the temptation to put in a nul

00:05:17,750 --> 00:05:21,389
reference, simply because it was so easy to implement.

00:05:21,400 --> 00:05:24,180
This has lead to innumerable errors, vulnerabilities, and system

00:05:24,200 --> 00:05:26,461
crashes, which have probably caused a billion dollars of

00:05:26,461 --> 00:05:29,840
pain and damage in the last forty years."

00:05:29,840 --> 00:05:32,789
I think it's probably been fifty years since, since

00:05:32,789 --> 00:05:36,280
that happened, and it's interesting to think about. The

00:05:36,280 --> 00:05:37,651
whole time I've been programming, there's been nul. There's

00:05:37,660 --> 00:05:40,340
nul everywhere. Nul's in SQL, it's in C, it's

00:05:40,340 --> 00:05:42,940
in C++, it's in Java, it's in JavaScript, it's

00:05:42,940 --> 00:05:44,699
in Ruby, it's in Python. It's just everywhere. Like,

00:05:44,700 --> 00:05:46,901
and you always use it for, I don't know

00:05:46,901 --> 00:05:50,060
or unassigned or nothing.

00:05:50,060 --> 00:05:52,270
So what if he hadn't done that? What if

00:05:52,270 --> 00:05:54,680
he had resisted that temptation? So what if Ruby

00:05:54,680 --> 00:05:57,580
didn't have nil at all, right?

00:05:57,580 --> 00:05:59,900
Specifically, that would mean that every single variable would

00:05:59,900 --> 00:06:02,189
have to have a value, cause there is no

00:06:02,189 --> 00:06:06,650
default stand-in value. And it would also mean that

00:06:06,660 --> 00:06:08,901
there's no handy global system you can reach for

00:06:08,901 --> 00:06:11,150
everywhere that means nothing.

00:06:11,150 --> 00:06:15,420
So let's say Ruby didn't have this at all.

00:06:15,420 --> 00:06:17,600
Would we be able to get our work done?

00:06:17,620 --> 00:06:20,479
So here's some code. It is a person. A

00:06:20,480 --> 00:06:22,181
person has a name and a birth date, and

00:06:22,181 --> 00:06:23,599
as you can see in the little highlighted line

00:06:23,600 --> 00:06:25,980
here, it's title, person may or may not have

00:06:25,980 --> 00:06:28,361
a title. So typically we'll, we'll default that to

00:06:28,361 --> 00:06:30,930
nil so that you can create people without specifying

00:06:30,930 --> 00:06:33,020
explicitly nil or anything like that.

00:06:33,020 --> 00:06:35,950
So you can see how this optional title affects

00:06:35,950 --> 00:06:39,100
our code. Title is nil. We say, "Hello, Bob."

00:06:39,100 --> 00:06:41,079
But if Bob has a title, we say, "Hello,

00:06:41,080 --> 00:06:42,321
Mr. Bob."

00:06:42,321 --> 00:06:43,850
This is, you know, it's very simplistic, but it's

00:06:43,850 --> 00:06:46,609
pretty typical of code that we write around nil.

00:06:46,620 --> 00:06:49,000
So if we don't have nil, we can't do

00:06:49,020 --> 00:06:51,191
this. So how would we solve the problem of

00:06:51,200 --> 00:06:53,350
having people, some of whom have titles and some

00:06:53,350 --> 00:06:54,970
of whom don't have titles?

00:06:54,970 --> 00:06:58,490
Well, why don't we use the type system, right?

00:06:58,500 --> 00:07:00,480
So we can make a person that just has

00:07:00,480 --> 00:07:02,420
the attributes that all people have. A name and

00:07:02,420 --> 00:07:04,090
a birth date. So we can see the greeting

00:07:04,090 --> 00:07:07,160
method is very simple: "Hello, Bob." And then we'll

00:07:07,180 --> 00:07:10,510
make a subclass called TitledPerson, and that will have

00:07:10,510 --> 00:07:13,130
a title, and then the, it will override greeting,

00:07:13,130 --> 00:07:15,370
to say, "Hello, Mr. Bob."

00:07:15,400 --> 00:07:18,330
So now we know, everywhere we have a titled

00:07:18,330 --> 00:07:20,149
person, we know there's a title. If we don't

00:07:20,149 --> 00:07:21,761
have a titled person, we don't have a title.

00:07:21,780 --> 00:07:25,139
So we didn't need to check for nil. Unfortunately,

00:07:25,140 --> 00:07:28,551
this technique is - it's great for giant slides

00:07:28,551 --> 00:07:31,730
with giant fonts on them. But, in reality, right,

00:07:31,740 --> 00:07:32,960
think of an object in your system that has

00:07:32,960 --> 00:07:35,180
a lot of optional values.

00:07:35,180 --> 00:07:37,960
It would be super complex to do this with

00:07:37,960 --> 00:07:39,560
lots and lots of optional values. You could use

00:07:39,560 --> 00:07:42,979
modules. It gets kind of weird, but it also

00:07:42,980 --> 00:07:45,950
kind of shows, like, a, this is not really

00:07:45,950 --> 00:07:48,291
the most Ruby way to solve this problem, right.

00:07:48,300 --> 00:07:50,710
Ruby, yes, you make classes and they create objects,

00:07:50,710 --> 00:07:53,020
but having lots of finegrained types like this is

00:07:53,020 --> 00:07:54,939
not as helpful as it might be in, like,

00:07:54,940 --> 00:07:56,130
a statically typed language.

00:07:56,140 --> 00:07:58,281
So if we were doing Scala we might want

00:07:58,281 --> 00:07:59,650
to write a routine that says, I need a

00:07:59,650 --> 00:08:02,279
person that has a title, so I'm gonna require

00:08:02,280 --> 00:08:03,780
you to pass in a titled person and the

00:08:03,780 --> 00:08:06,331
compiler will refuse to compile your code if you

00:08:06,340 --> 00:08:09,009
don't do that. Ruby doesn't work that way, and

00:08:09,009 --> 00:08:11,421
it's, no offense, I'm glad it doesn't work that

00:08:11,421 --> 00:08:14,850
way. The point is, if we're using types like

00:08:14,850 --> 00:08:16,310
this, we end up having to check the types

00:08:16,310 --> 00:08:18,259
of things, or have our tests check the types

00:08:18,260 --> 00:08:20,331
of things, and that's just kind of strange to

00:08:20,340 --> 00:08:22,750
be adding these degenerate type systems to our tests

00:08:22,760 --> 00:08:24,350
and code.

00:08:24,350 --> 00:08:26,700
So we really do need some concept of nul

00:08:26,720 --> 00:08:28,470
or some concept of, like, there is no value

00:08:28,470 --> 00:08:29,809
here or I don't know. Like, we do need

00:08:29,820 --> 00:08:32,691
that concept. We can't skirt it just by using

00:08:32,691 --> 00:08:35,750
types and modules.

00:08:35,760 --> 00:08:37,159
So we could do this, right. But let's think

00:08:37,160 --> 00:08:39,061
harder than this. Let's try a little harder than

00:08:39,061 --> 00:08:43,070
just recreating nil. Let's think about what nil means.

00:08:43,070 --> 00:08:46,519
So nil means a variable hasn't been set. It

00:08:46,520 --> 00:08:48,591
could mean that we don't know the value of

00:08:48,600 --> 00:08:51,000
a variable yet, but we might later. It could

00:08:51,000 --> 00:08:52,529
mean that there is no value. We know that

00:08:52,529 --> 00:08:55,291
there is no value. We know someone doesn't have

00:08:55,300 --> 00:08:59,200
a title. It could mean some vague concept of

00:08:59,200 --> 00:09:00,640
So if we want to model these four things,

00:09:00,640 --> 00:09:02,610
I don't think nil would be the way we'd

00:09:02,610 --> 00:09:04,450
go about it. I don't think we'd want to

00:09:04,460 --> 00:09:06,720
have a single symbol represent all of these four

00:09:06,720 --> 00:09:09,120
concepts, because they're different, and there's no way to

00:09:09,120 --> 00:09:12,069
tell the difference between a unset variable and a

00:09:12,069 --> 00:09:14,641
variable whose value we don't know, if they're both

00:09:14,641 --> 00:09:15,820
nil.

00:09:15,820 --> 00:09:21,179
So let's, let's create four symbols - sorry about

00:09:21,180 --> 00:09:22,611
the zoom here. So four symbols, each one represents

00:09:22,640 --> 00:09:25,420
one of those concepts. So now we can tell

00:09:25,420 --> 00:09:27,880
the difference. And so if we look back at

00:09:27,880 --> 00:09:31,019
our person code, again, we're going back to the

00:09:31,020 --> 00:09:34,351
kind of the original version, but here, you'll notice

00:09:34,351 --> 00:09:37,790
we're giving title the default value of unknown. So

00:09:37,790 --> 00:09:41,680
because now there are four different things we've created,

00:09:41,700 --> 00:09:43,839
we can make a design decision about what title

00:09:43,840 --> 00:09:44,701
should default to.

00:09:44,701 --> 00:09:46,820
We could decide that a title has no value

00:09:46,820 --> 00:09:49,130
by default. We could decide that it's unknown by

00:09:49,130 --> 00:09:50,490
default. So that's a design decision that we get

00:09:50,490 --> 00:09:53,530
to make that expresses something about our person that

00:09:53,530 --> 00:09:56,460
we couldn't do before. So we're gonna call, we're

00:09:56,460 --> 00:09:59,320
gonna just say a person is unknown. A person's

00:09:59,320 --> 00:10:02,200
title is unknown by default.

00:10:02,200 --> 00:10:04,309
So our greet method, you know, we could do

00:10:04,320 --> 00:10:07,541
it like this, and, you know, this is not

00:10:07,541 --> 00:10:10,490
gonna work. Obviously this is buggy, right, because if

00:10:10,490 --> 00:10:11,670
we give no value, then, "Hello, No Value Bob."

00:10:11,680 --> 00:10:14,090
Like that's not right.

00:10:14,090 --> 00:10:18,080
But more, moreso, since there's so many different symbols

00:10:18,080 --> 00:10:21,650
that represent some type of no value, we can't

00:10:21,660 --> 00:10:23,730
just get away with comparing it. Like, with nil,

00:10:23,730 --> 00:10:25,999
it's handy. We know there's only one nil. And

00:10:26,020 --> 00:10:27,270
even though we know we should be calling the

00:10:27,280 --> 00:10:29,541
dot nil method, we tend to compare it to

00:10:29,541 --> 00:10:31,720
nil a lot. But that's OK because there's only

00:10:31,720 --> 00:10:32,440
one of them.

00:10:32,440 --> 00:10:34,420
Well, in this world of no nil, there isn't

00:10:34,420 --> 00:10:36,209
one of them, there's four, and it would be

00:10:36,209 --> 00:10:39,450
pretty darn ugly to be checking title against all

00:10:39,460 --> 00:10:42,911
four values. What we really need is some sort

00:10:42,911 --> 00:10:45,310
of API around this, some messages that we can

00:10:45,310 --> 00:10:48,499
send to make this a little simpler.

00:10:48,520 --> 00:10:50,911
So what if we had something like this? We

00:10:50,911 --> 00:10:53,990
had a message called when_value that everybody responds to,

00:10:54,000 --> 00:10:56,220
and if the person we're sending that message to

00:10:56,220 --> 00:10:58,810
happens to be a value, it will execute this

00:10:58,820 --> 00:11:03,300
code, "Hello, Mr. Bob." And if title isn't a

00:11:03,300 --> 00:11:06,850
value, is some sort of nil-like thing, it will

00:11:06,850 --> 00:11:07,600
execute this: "Hello, Bob."

00:11:07,600 --> 00:11:11,259
So this is pretty easy to implement. BasicObject, right,

00:11:11,260 --> 00:11:13,520
is the root of all objects in Ruby. And

00:11:13,520 --> 00:11:16,140
all objects are values, by default, so when_value will

00:11:16,140 --> 00:11:19,401
just call the block given to it, and, or_else

00:11:19,401 --> 00:11:21,460
is a nil-op? cause since our basic objects are

00:11:21,460 --> 00:11:24,100
values, we don't want to do this or_else thing.

00:11:24,100 --> 00:11:26,870
Now for these four special nil-like things, we'll make

00:11:26,870 --> 00:11:30,490
the superclass called NilLikeSentinal, which is the best name

00:11:30,500 --> 00:11:32,320
I could come up with without using one of

00:11:32,320 --> 00:11:34,290
the names of these objects, and it does the

00:11:34,320 --> 00:11:36,630
opposite, right. So when value is nothing, it's a

00:11:36,630 --> 00:11:38,389
no op, but or_else, because these are not actual

00:11:38,389 --> 00:11:41,391
real values, will execute. And then we give all

00:11:41,400 --> 00:11:44,210
these guys a new superclass.

00:11:44,210 --> 00:11:46,860
So that makes that work, which is kind of

00:11:46,860 --> 00:11:51,160
interesting. It's a little bit strange-looking, right, because we've

00:11:51,160 --> 00:11:53,439
got this method called or_else, but Ruby also has

00:11:53,460 --> 00:11:56,241
this else thing, it's kind of like we're branching,

00:11:56,241 --> 00:11:58,029
but we're not. It's, it's a little bit weird,

00:11:58,029 --> 00:11:59,510
and it's kind of the same lines of code

00:11:59,510 --> 00:12:02,051
as our nil-checking thing.

00:12:02,060 --> 00:12:04,280
So, you know, I would probably want to know,

00:12:04,280 --> 00:12:07,180
is there any advantage to doing it this way?

00:12:07,180 --> 00:12:10,560
Well, let's consider if our greeting method gets a

00:12:10,560 --> 00:12:14,100
little more complex, and now what we want to

00:12:14,100 --> 00:12:16,079
do is, if we have a title, we want

00:12:16,080 --> 00:12:18,661
to say, "Hello Mr. Bob." But if we don't

00:12:18,661 --> 00:12:20,750
have a title but we know that a person

00:12:20,750 --> 00:12:23,309
has no title, right, we know you have no

00:12:23,309 --> 00:12:25,331
title, we'll say, "Hello Bob," but if we're not

00:12:25,360 --> 00:12:27,360
sure, if the title is unknown or we haven't

00:12:27,360 --> 00:12:29,550
been told what the title is, we want to

00:12:29,550 --> 00:12:31,629
say, "I'm not sure how to greet you Bob."

00:12:31,629 --> 00:12:33,301
So these are, these are different things, right. We

00:12:33,301 --> 00:12:35,429
know a person doesn't have a title is different

00:12:35,429 --> 00:12:38,891
from not knowing what a person's title is.

00:12:38,900 --> 00:12:42,540
So with Nil, this would be very hard, but

00:12:42,560 --> 00:12:46,570
now it's kind of, let's expand our little Nil-like

00:12:46,570 --> 00:12:50,550
API to have this concept of when_known. So does

00:12:50,550 --> 00:12:53,379
this value, this thing we have is a value

00:12:53,400 --> 00:12:55,851
or not, is it something known? Do we have

00:12:55,851 --> 00:12:59,220
knowledge about something? So, of course, BasicObjects, since they

00:12:59,220 --> 00:13:02,319
are values, we know they are that value.

00:13:02,320 --> 00:13:06,501
Nil-like objects, again, are not known by default, and

00:13:06,501 --> 00:13:10,439
then we'll have our known Nil-like sentinel, which will

00:13:10,440 --> 00:13:14,171
represent things that are not values but represent knowledge

00:13:14,180 --> 00:13:17,019
that we have. So no value at empty, represent

00:13:17,020 --> 00:13:20,361
that, and now, our code looks like this.

00:13:20,361 --> 00:13:23,110
And this is what I love about Ruby. title.when_value,

00:13:23,110 --> 00:13:26,790
"Hello Mr. Bob." when_known, "Hello Bob" or_else, "Not sure

00:13:26,800 --> 00:13:28,079
how to greet you Bob."

00:13:28,080 --> 00:13:30,131
I can just read you the code and it

00:13:30,131 --> 00:13:32,699
sounds like a sentence. It sounds like what it

00:13:32,700 --> 00:13:33,820
does.

00:13:33,820 --> 00:13:35,411
So this is actually a little bit more interesting.

00:13:35,420 --> 00:13:38,790
It's definitely strange-looking, but you'll notice that we've lost

00:13:38,790 --> 00:13:40,740
all of that deep nesting that we might have

00:13:40,750 --> 00:13:43,170
had. Everything's kind of typographically the same, which it

00:13:43,170 --> 00:13:45,381
should be because these are all equally likely to

00:13:45,420 --> 00:13:49,990
happen in our world. And it's just, you know,

00:13:49,990 --> 00:13:51,800
it kind of reads nice.

00:13:51,800 --> 00:13:53,699
And it's important to point out, if we were

00:13:53,700 --> 00:13:56,111
using Nil, we probably would never have come up

00:13:56,120 --> 00:13:57,279
with any of this, and to be able to

00:13:57,280 --> 00:13:59,971
tell a Nil title, does that mean unknown or

00:13:59,971 --> 00:14:02,800
does that mean I know that there is no

00:14:02,800 --> 00:14:04,720
title? Like, you'd have to have some boolean flag

00:14:04,720 --> 00:14:07,249
to keep track of that or some magical symbol.

00:14:07,249 --> 00:14:09,180
So, instead what we've done is we've just created

00:14:09,200 --> 00:14:12,421
objects and messages to model the actual thing we

00:14:12,421 --> 00:14:13,529
want to do.

00:14:13,529 --> 00:14:15,330
So that's kind of cool.

00:14:15,340 --> 00:14:18,921
Now, you'll notice that I didn't make methods called

00:14:18,921 --> 00:14:23,029
is_value or is_known or anything like that. And that

00:14:23,029 --> 00:14:26,211
leads to the next -oh, also, this is the

00:14:26,220 --> 00:14:28,329
best part of this so I can't believe I

00:14:28,329 --> 00:14:28,580
forgot.

00:14:28,580 --> 00:14:30,051
Wouldn't it be nice to get that in your

00:14:30,060 --> 00:14:32,529
stackTrace, or that, instead of no such value for

00:14:32,529 --> 00:14:34,811
nilClass? Like, who knows what that means? But this,

00:14:34,820 --> 00:14:37,430
right, this means I didn't handle some logic, and

00:14:37,430 --> 00:14:40,150
this means that I screwed up. So that's another

00:14:40,150 --> 00:14:42,559
kind of side-benefit of, of doing this.

00:14:42,560 --> 00:14:43,921
So, to get back to the Nil method or

00:14:43,921 --> 00:14:46,869
the value method or is_known method like, you, you

00:14:46,869 --> 00:14:49,110
might think that I should have added those, and

00:14:49,120 --> 00:14:51,451
based my logic on that. So I want to

00:14:51,460 --> 00:14:53,590
talk about attributes.

00:14:53,590 --> 00:14:55,879
Those are kind of a form of attributes. And

00:14:55,880 --> 00:15:00,651
so, what I mean is attr_accessor, attr_reader, attr_writer. These

00:15:00,660 --> 00:15:03,430
give the appearance of being able to access the

00:15:03,440 --> 00:15:05,829
internal state of our objects and the ability to

00:15:05,829 --> 00:15:09,551
change, directly, the internal state of our objects.

00:15:09,560 --> 00:15:12,300
Ruby helps by allowing this method named foo equals

00:15:12,300 --> 00:15:16,050
to be cooled with foo space equals, so it

00:15:16,050 --> 00:15:17,749
really does give the appearance that our objects are

00:15:17,749 --> 00:15:20,281
these dumb structs that we can just kind of

00:15:20,300 --> 00:15:21,320
change willy-nilly.

00:15:21,320 --> 00:15:23,621
Because it's so darn handy and so easy, and

00:15:23,621 --> 00:15:26,110
especially when we're manipulating things in a database, we

00:15:26,110 --> 00:15:29,230
tend to write code like this a lot. But

00:15:29,230 --> 00:15:32,499
I think that is potentially bad. So let me

00:15:32,500 --> 00:15:34,881
try to make that point by describing how you

00:15:34,881 --> 00:15:37,400
might buy something by using attributes.

00:15:37,400 --> 00:15:41,320
So you take out your wallet. Hand your entire

00:15:41,320 --> 00:15:43,900
wallet over to the clerk. The clerk will then

00:15:43,900 --> 00:15:46,410
rifle through your wallet to find whatever combination of

00:15:46,420 --> 00:15:50,179
cash, credit cards, gift cards he decides that you

00:15:50,200 --> 00:15:53,590
should use to pay to oversee the transaction, and

00:15:53,590 --> 00:15:54,781
hands you back your wallet in whatever state he

00:15:54,781 --> 00:15:56,509
felt like leaving it in.

00:15:56,520 --> 00:16:00,020
So, right? Some countries don't even take your credit

00:16:00,020 --> 00:16:01,270
card. They give you a machine to run your

00:16:01,270 --> 00:16:02,890
credit card through, right. No one buys things like

00:16:02,900 --> 00:16:04,640
this. This is crazy.

00:16:04,640 --> 00:16:06,650
But when you write code that makes heavy use

00:16:06,650 --> 00:16:10,101
of attributes, it's kind of like how you're coding,

00:16:10,101 --> 00:16:13,749
right? So let's say that Ruby doesn't allow this

00:16:13,749 --> 00:16:15,361
sort of thing. Let's say that Ruby doesn't have

00:16:15,361 --> 00:16:18,710
this little nice equals method deal and that the

00:16:18,710 --> 00:16:21,410
standard library doesn't provide attr_accessor or attr_reader or attr_writer.

00:16:21,420 --> 00:16:23,900
It doesn't provide any of that stuff.

00:16:23,900 --> 00:16:26,100
So if you've ever coded in JavaScript or Java,

00:16:26,100 --> 00:16:28,350
you know what that's like, cause they, those languages

00:16:28,350 --> 00:16:29,359
don't provide that.

00:16:29,380 --> 00:16:32,591
Ooh boy, that got really zoomed.

00:16:32,600 --> 00:16:36,050
OK, that's not too bad. So here's some code

00:16:36,050 --> 00:16:37,629
that, that, that we, that we will not be

00:16:37,629 --> 00:16:39,791
allowed to write. So we have a very sophisticated

00:16:39,800 --> 00:16:42,259
greeting method now that is going to give you

00:16:42,260 --> 00:16:44,260
a casual greeting: "Hi Bob" if we know your

00:16:44,260 --> 00:16:47,041
first name. If we don't, but you have a

00:16:47,041 --> 00:16:49,129
last name, then we're gonna see if you have

00:16:49,140 --> 00:16:51,631
a gender, and if your gender also has a

00:16:51,631 --> 00:16:54,559
gender-specific salutation, and if all that is true, we

00:16:54,560 --> 00:16:57,961
will say, "Hello Mr. Jones" and if not, we'll

00:16:57,961 --> 00:16:59,730
say "Hello Jones," and if all else false, we'll

00:16:59,730 --> 00:17:00,110
say, "Hello."

00:17:00,120 --> 00:17:02,670
So this is convoluted, but I'm sure we've all

00:17:02,670 --> 00:17:04,690
written code that looks more or less like this.

00:17:04,690 --> 00:17:07,070
Asking things for their things and checking their things

00:17:07,080 --> 00:17:08,740
against other things.

00:17:08,740 --> 00:17:10,500
So if we can't do any of this, if

00:17:10,500 --> 00:17:13,070
we can't create easily an API like this, right,

00:17:13,070 --> 00:17:15,560
what would we do? So, getting back to the

00:17:15,580 --> 00:17:17,650
Java and JavaScript part, we all know what those

00:17:17,650 --> 00:17:20,750
languages do. They make methods called getters and setters

00:17:20,760 --> 00:17:25,620
that look like crappy versions of attributes.

00:17:25,620 --> 00:17:27,180
And the, that makes sense for those languages cause

00:17:27,180 --> 00:17:30,470
those languages aren't terribly powerful compared to Ruby. But

00:17:30,470 --> 00:17:33,760
Ruby has more features available to us that might

00:17:33,760 --> 00:17:37,330
not lead us down that path.

00:17:37,330 --> 00:17:41,060
So what if we did something like this? We

00:17:41,060 --> 00:17:42,710
have a method called with_attributes - hang on, I'm

00:17:42,720 --> 00:17:46,110
sorry these are so small. There we go.

00:17:46,110 --> 00:17:47,890
And so if the first name is there, then

00:17:47,900 --> 00:17:50,500
we'll run this bucket code. If we didn't, but

00:17:50,500 --> 00:17:52,450
we have a gendered salutation and a last name,

00:17:52,450 --> 00:17:56,670
run this block of code, et cetera. So I

00:17:56,680 --> 00:17:59,050
should point out, this absolutely works. A lambda has

00:17:59,060 --> 00:18:02,140
access to not only the number of parameters, but

00:18:02,140 --> 00:18:03,660
the names of those parameters. So you could just

00:18:03,660 --> 00:18:08,310
look at the parameter list to figure out what

00:18:08,310 --> 00:18:11,910
attributes are being asked for.

00:18:11,920 --> 00:18:14,570
So this is kind of strange, right. But you

00:18:14,570 --> 00:18:17,140
could imagine, if the standard library provided something like

00:18:17,140 --> 00:18:20,170
this, this would start to look kind of normal,

00:18:20,170 --> 00:18:23,280
and again, right, we've lost, we've lost that big

00:18:23,280 --> 00:18:25,840
huge cone of nesting, and now we have a

00:18:25,840 --> 00:18:29,110
nice, nice little typographically organized thing for each thing

00:18:29,120 --> 00:18:32,900
that could possibly happen. It's nice.

00:18:32,900 --> 00:18:34,740
But there's another couple things that are nice about

00:18:34,760 --> 00:18:40,070
this that we wouldn't have gotten with this craziness.

00:18:40,070 --> 00:18:44,350
One is that we have an API that differentiates

00:18:44,350 --> 00:18:46,890
a request for information and actually being given that

00:18:46,890 --> 00:18:50,900
information. So that allows us some more flexibility. So

00:18:50,920 --> 00:18:53,530
if we wanted to have logic that says, you

00:18:53,530 --> 00:18:55,920
know, maybe someone has a gender salutation and they

00:18:55,920 --> 00:18:57,820
have a last name, but if someone asked for

00:18:57,840 --> 00:18:59,380
them both at the same time we want to

00:18:59,380 --> 00:19:00,170
do something else.

00:19:00,170 --> 00:19:01,800
Like, we could do that with a structure like

00:19:01,800 --> 00:19:04,090
this. We couldn't do that by just allowing people

00:19:04,090 --> 00:19:06,650
to have access to whatever they wanted. So that's

00:19:06,650 --> 00:19:08,670
kind of interesting. But what's more interesting is, when

00:19:08,680 --> 00:19:09,960
you think about the scope of some of these

00:19:09,960 --> 00:19:11,180
variables.

00:19:11,180 --> 00:19:16,860
So here, the, the, the scope over which first

00:19:16,880 --> 00:19:18,520
name, last name, gender, all this stuff, it's all

00:19:18,520 --> 00:19:20,770
global to this method, right. All those values could

00:19:20,770 --> 00:19:22,830
be accessed anywhere, and although this is a very

00:19:22,840 --> 00:19:25,270
short method, I think we all know that the

00:19:25,270 --> 00:19:28,020
larger the scope of a variable is, the harder

00:19:28,020 --> 00:19:30,160
a routine is to understand, because you have to

00:19:30,160 --> 00:19:31,970
keep a lot of things in your head to

00:19:31,970 --> 00:19:34,500
understand what is going on and what might happen.

00:19:34,500 --> 00:19:37,550
Here, the scope of first name is just here.

00:19:37,550 --> 00:19:40,300
The scope of gender_salutation and last_name is just here.

00:19:40,300 --> 00:19:43,240
Now, even though these are one-liners, each of these

00:19:43,240 --> 00:19:45,300
blocks, each of these alternatives, is still going to

00:19:45,300 --> 00:19:47,480
be smaller than the entire routine.

00:19:47,480 --> 00:19:49,040
So we've actually made the code a little simpler

00:19:49,040 --> 00:19:52,720
to understand by reducing the scope of the variables

00:19:52,720 --> 00:19:54,730
that we need to do our job. But we

00:19:54,730 --> 00:19:56,930
haven't taken away any power. You still have access

00:19:56,930 --> 00:19:59,430
to these things. And it's kind of the same

00:19:59,430 --> 00:20:01,980
lines of code. So that's kind of interesting I

00:20:01,980 --> 00:20:03,060
think.

00:20:03,060 --> 00:20:04,660
Where it gets really interesting is when we want

00:20:04,660 --> 00:20:08,750
to change the internal state of an object. So

00:20:08,760 --> 00:20:12,950
again, we might want to change a person's city

00:20:12,950 --> 00:20:15,880
to normalize it or something like that. And you

00:20:15,900 --> 00:20:18,280
know whatever your feelings are on mutable state and

00:20:18,280 --> 00:20:21,020
changing things like, our programs do need to make

00:20:21,020 --> 00:20:23,660
changes to something somewhere sometimes, so we have to

00:20:23,660 --> 00:20:26,870
have an ability to change something about something.

00:20:26,880 --> 00:20:30,130
So if we can't do something like this little

00:20:30,130 --> 00:20:33,660
magic, magicness here, and we're not doing setters cause

00:20:33,660 --> 00:20:37,300
setters are weak, what are we gonna do? Well

00:20:37,300 --> 00:20:40,030
what if we made, we'll follow along our with_attributes

00:20:40,030 --> 00:20:43,570
concept and we'll make a method that records all

00:20:43,570 --> 00:20:46,000
of the changes a caller might want to make

00:20:46,000 --> 00:20:48,370
to us and then we can decide what to

00:20:48,380 --> 00:20:48,910
do with that.

00:20:48,910 --> 00:20:51,500
So maybe that looks like this. Person has this

00:20:51,520 --> 00:20:54,610
update method, takes a block, and inside that block

00:20:54,610 --> 00:20:58,640
we will use the update object to record, let's

00:20:58,640 --> 00:21:00,910
say a bunch of requests of changes and, you

00:21:00,920 --> 00:21:02,370
know, I'd like to update the city to this

00:21:02,370 --> 00:21:04,510
and blah, blah, blah.

00:21:04,540 --> 00:21:06,530
So again it's the same lines of code but

00:21:06,530 --> 00:21:11,060
now we have a level of indirection between what

00:21:11,060 --> 00:21:12,700
we would like to do and having those changes

00:21:12,700 --> 00:21:15,240
actually made, which is kind of interesting, right. Because

00:21:15,240 --> 00:21:17,370
it gives us some, a little bit more power

00:21:17,380 --> 00:21:20,020
that we wouldn't get with these, these equals methods

00:21:20,020 --> 00:21:21,970
that we use so often.

00:21:21,970 --> 00:21:25,330
So, you know, a naive implementation might just be

00:21:25,330 --> 00:21:27,240
to just do what equals methods do, right, so

00:21:27,240 --> 00:21:28,790
we could kind of default to that if we

00:21:28,790 --> 00:21:30,890
wanted to. So we're getting the exact same thing

00:21:30,900 --> 00:21:35,320
with about the same lines of code. And, but

00:21:35,320 --> 00:21:36,770
we could do more interesting things. What if we

00:21:36,780 --> 00:21:38,790
wanted to run this in a database transaction?

00:21:38,790 --> 00:21:41,000
Well, if you've done Rails programming, then the way

00:21:41,000 --> 00:21:43,180
to do this is either you, the caller, must

00:21:43,180 --> 00:21:45,500
put everything in a transaction, or you have to

00:21:45,520 --> 00:21:48,030
use a Rails-specific magic method that only some objects

00:21:48,030 --> 00:21:50,660
have that is known and documented to put things

00:21:50,660 --> 00:21:51,980
in a transaction.

00:21:51,980 --> 00:21:54,510
So me, being the object who's being changed, I

00:21:54,510 --> 00:21:55,990
don't really have a lot of control over that.

00:21:55,990 --> 00:21:57,320
So this would allow me to do that if

00:21:57,320 --> 00:22:00,710
I wanted. What's more interesting is that since we

00:22:00,740 --> 00:22:02,090
have all of the changes that we want to

00:22:02,090 --> 00:22:04,160
make to an object in one place without them

00:22:04,160 --> 00:22:07,030
haven't actually being made, we can examine them before

00:22:07,030 --> 00:22:08,360
doing anything.

00:22:08,380 --> 00:22:11,290
So we could decide that if you're changing the

00:22:11,290 --> 00:22:14,110
zip code and city together at the same time,

00:22:14,120 --> 00:22:15,550
then we want to make sure that those are

00:22:15,550 --> 00:22:17,630
consistent with each other, and we want to blow

00:22:17,630 --> 00:22:20,540
up if not. So doing this with equals methods

00:22:20,540 --> 00:22:22,690
would be tricky. It would be really hard to

00:22:22,690 --> 00:22:26,620
get it exactly right in every case.

00:22:26,620 --> 00:22:28,970
But it's, you know, it is kind of, it's

00:22:29,000 --> 00:22:30,260
kind of strange looking, but I, you know, I

00:22:30,260 --> 00:22:32,260
think, like, I would be used to this if

00:22:32,260 --> 00:22:33,930
this was just kind of how you did things.

00:22:33,930 --> 00:22:36,210
And it's kind of interesting that by not using

00:22:36,220 --> 00:22:39,230
these handy things that we think are easy, we

00:22:39,230 --> 00:22:44,240
get a lot more power available to us.

00:22:44,260 --> 00:22:50,650
So, you may have noticed that the before and

00:22:50,680 --> 00:22:53,200
after, the after didn't have any if statements in

00:22:53,200 --> 00:22:56,070
it. And that was sort of intentional but sort

00:22:56,070 --> 00:22:58,250
of a kind of side-effect of just the way

00:22:58,250 --> 00:23:00,230
we went about solving those problems. But that makes

00:23:00,240 --> 00:23:03,010
me wonder, right. What if we don't have if

00:23:03,010 --> 00:23:05,500
statements? Which is a crazy notions, right. I kind

00:23:05,500 --> 00:23:07,850
of feel like programmers jobs are to write if

00:23:07,850 --> 00:23:08,530
statements, right.

00:23:08,530 --> 00:23:10,590
If I didn't need to write an if statement,

00:23:10,620 --> 00:23:13,320
programming would be easy. And if you think about,

00:23:13,320 --> 00:23:16,160
like, what are the features of assembly language, that

00:23:16,160 --> 00:23:18,530
are also in Ruby. If statements is one of

00:23:18,530 --> 00:23:20,350
them, right. You can't write an assembly language without

00:23:20,350 --> 00:23:23,040
some method of branching the code. You have to

00:23:23,040 --> 00:23:24,830
direct the code to go one place in a

00:23:24,830 --> 00:23:27,530
certain case and another place in another case.

00:23:27,540 --> 00:23:29,730
So what if Ruby didn't have if statements? There's

00:23:29,740 --> 00:23:32,130
no if. There's no unless. No else. No switch.

00:23:32,140 --> 00:23:35,130
None of that stuff. How in the heck would

00:23:35,130 --> 00:23:38,110
we get anything done without if statements? Let's find

00:23:38,110 --> 00:23:39,400
out.

00:23:39,400 --> 00:23:41,240
So here, so we're gonna get away from the

00:23:41,260 --> 00:23:44,020
exciting world of greeting people to a little bit

00:23:44,020 --> 00:23:45,920
more of the real world of getting their money

00:23:45,920 --> 00:23:49,050
from them. So here is an imaginary routine, so

00:23:49,050 --> 00:23:51,360
let's so we've been given this credit card service

00:23:51,360 --> 00:23:53,530
and the idea here is we want to charge

00:23:53,530 --> 00:23:55,460
somebody some money, and then if anything goes wrong

00:23:55,480 --> 00:23:57,730
we're gonna give them a reasonable explanation.

00:23:57,730 --> 00:24:00,650
And so this is a pretty typical pattern, right.

00:24:00,650 --> 00:24:02,960
We get back some blob of data. We ask

00:24:02,960 --> 00:24:05,690
the blob of data some stuff and do things

00:24:05,690 --> 00:24:07,960
based on that stuff. Right, that's pretty reasonable. Like,

00:24:07,960 --> 00:24:10,260
if it's a success, fine. If it's not we

00:24:10,260 --> 00:24:12,800
compare the error code to some magic value and

00:24:12,800 --> 00:24:15,990
that means expired and, and I, and else must

00:24:16,000 --> 00:24:18,910
mean declined, and because we're doing network programming we

00:24:18,910 --> 00:24:21,530
gotta, you know, we gotta rescue everything. Cause, you

00:24:21,540 --> 00:24:25,100
know, that might, something might go wrong there.

00:24:25,100 --> 00:24:28,150
So without if statements, how might we implement something

00:24:28,150 --> 00:24:29,990
like this?

00:24:30,000 --> 00:24:33,340
Well, if there were no if statements, I would

00:24:33,340 --> 00:24:35,420
bet that the creator and designer of the credit

00:24:35,420 --> 00:24:38,610
card service might design an API a little differently,

00:24:38,610 --> 00:24:40,910
right. This design of passing back a blob of

00:24:40,940 --> 00:24:42,810
data and hoping you know what to do with

00:24:42,810 --> 00:24:45,090
it is a lot more difficult if you don't

00:24:45,090 --> 00:24:47,230
have these branching structures.

00:24:47,230 --> 00:24:49,110
So the credit card service might be designed in

00:24:49,120 --> 00:24:51,310
a way that doesn't require having if statements. So

00:24:51,310 --> 00:24:53,520
let's see what that might look like, right.

00:24:53,520 --> 00:24:57,140
What it might do instead is map every possible

00:24:57,140 --> 00:25:00,430
thing that could happen to some code. SO I'm

00:25:00,440 --> 00:25:03,520
the caller. I'm gonna say, for every possible outcome,

00:25:03,520 --> 00:25:05,110
here's the code I'd like you to run if

00:25:05,110 --> 00:25:07,470
that happens, and then the credit card service will

00:25:07,480 --> 00:25:10,680
sort out what outcome actually did happen and call

00:25:10,680 --> 00:25:11,950
the right code.

00:25:11,950 --> 00:25:15,640
So that might look something like this. Right, on

00:25:15,640 --> 00:25:20,500
success do nothing, on decline, on expiration, on exception.

00:25:20,500 --> 00:25:23,000
So this is kind of interesting, right. What, for,

00:25:23,000 --> 00:25:27,260
for one thing, again, typographically, everything's together. It's kind

00:25:27,260 --> 00:25:29,310
of nice. We, we've brought this exception up to

00:25:29,340 --> 00:25:31,890
where it belongs, because exceptions are just as likely

00:25:31,890 --> 00:25:33,960
to happen, so it should, it doesn't deserve its

00:25:33,960 --> 00:25:36,910
special place down at the end.

00:25:36,910 --> 00:25:38,630
And this also reads a lot clearer, right. I

00:25:38,630 --> 00:25:40,900
don't have to make that mental shift of like,

00:25:40,900 --> 00:25:43,640
if some field equals some magic value then that

00:25:43,640 --> 00:25:46,350
means the concept of expiration. I can just call

00:25:46,380 --> 00:25:49,930
a method that says what it is.

00:25:49,930 --> 00:25:51,520
So that's kind of cool, right. We skirted the

00:25:51,520 --> 00:25:53,950
issue by redesigning the API to not need if

00:25:53,950 --> 00:25:58,510
statements. And, but this, there's some negatives, right. Like

00:25:58,510 --> 00:26:02,950
this is totally custom, totally proprietary to this service.

00:26:02,960 --> 00:26:04,980
So this isn't like a generalized language construct that

00:26:05,000 --> 00:26:07,020
we might be able to use. It's, it's very

00:26:07,020 --> 00:26:08,640
one-off.

00:26:08,640 --> 00:26:10,610
If statements are, are handy, because when we talk

00:26:10,610 --> 00:26:12,120
about what code is supposed to do we use

00:26:12,120 --> 00:26:15,070
the word if. That's why it's in the language.

00:26:15,070 --> 00:26:16,480
SO this gets rid of that. So you could

00:26:16,480 --> 00:26:18,500
say that, that if you have a large code

00:26:18,500 --> 00:26:20,780
base, had lots of things that worked like this,

00:26:20,780 --> 00:26:22,730
it could be kind of strange.

00:26:22,730 --> 00:26:24,680
So I'm gonna ask again, what does this let

00:26:24,680 --> 00:26:28,090
us do that this if statement approach didn't let

00:26:28,100 --> 00:26:31,710
us do? So let's say I screw up when

00:26:31,710 --> 00:26:34,430
I'm implementing my credit charge handler, and I forget

00:26:34,440 --> 00:26:37,220
to handle the case where someone's card is expired.

00:26:37,220 --> 00:26:38,450
SO I just have this code. And again, it

00:26:38,450 --> 00:26:41,030
looks nice. It reads nice. Everything is good. My

00:26:41,060 --> 00:26:42,400
tests all pass.

00:26:42,400 --> 00:26:45,870
The failure was that I didn't understand every possible

00:26:45,870 --> 00:26:47,980
outcome that could happen when I'm using the credit

00:26:47,980 --> 00:26:50,480
card service, right. So I am living in the

00:26:50,480 --> 00:26:53,000
fantasy world where I can charge credit cards, and

00:26:53,000 --> 00:26:54,760
the garbage collector who has made the credit card

00:26:54,760 --> 00:26:58,410
service for me has, has to explain to me

00:26:58,410 --> 00:27:00,180
at some level what I need to do.

00:27:00,180 --> 00:27:02,360
And I haven't, I haven't understood that. Now, if

00:27:02,380 --> 00:27:05,120
I did make this mistake, it's really hard to

00:27:05,120 --> 00:27:07,160
find out that this happened, right. You might have

00:27:07,160 --> 00:27:11,150
people buying things and being told that they successfully

00:27:11,150 --> 00:27:13,100
purchased, but then they never get their item, which

00:27:13,100 --> 00:27:15,540
is bad. Or worse, they could be told that

00:27:15,540 --> 00:27:17,170
they successfully purchased and then they did get their

00:27:17,180 --> 00:27:19,040
item. So we're giving away things for free.

00:27:19,040 --> 00:27:21,800
This is a very hard mistake to find. And

00:27:21,800 --> 00:27:25,920
it has disastrous consequences. And so the hope, right,

00:27:25,920 --> 00:27:27,490
the way that we prevent ourselves from making a

00:27:27,490 --> 00:27:29,660
mistake like this is we hope that our garbage

00:27:29,660 --> 00:27:32,400
collector, who created our credit card service wrote enough

00:27:32,400 --> 00:27:36,060
documentation and explained things well enough that we understand.

00:27:36,060 --> 00:27:38,210
And that we read that documentation and totally understood

00:27:38,220 --> 00:27:41,980
how to use this API.

00:27:41,980 --> 00:27:43,860
So with the way that we normally do thing,

00:27:43,860 --> 00:27:47,130
that's what we have. We have hope. Here we

00:27:47,130 --> 00:27:49,590
could actually check, right. Because what we're doing, this

00:27:49,600 --> 00:27:52,830
code isn't actually running. This code is mapping outcomes

00:27:52,830 --> 00:27:56,080
to code. But it's not actually running the code.

00:27:56,080 --> 00:27:58,310
This guy, the credit card service is actually running

00:27:58,320 --> 00:27:59,160
the code.

00:27:59,160 --> 00:28:02,150
So before the credit card service runs the code,

00:28:02,150 --> 00:28:03,970
it could check to see if I handled everything.

00:28:03,980 --> 00:28:06,200
It could check and it could notice, I didn't

00:28:06,200 --> 00:28:09,770
provide any code for the on expiration case. And

00:28:09,770 --> 00:28:12,330
it could decide, dude, you did not understand how

00:28:12,340 --> 00:28:14,860
to use me. I'm not gonna go forward because

00:28:14,860 --> 00:28:17,860
you, something is broken. You have failed. If you

00:28:17,860 --> 00:28:19,960
want to give away products, that is cool with

00:28:19,960 --> 00:28:21,590
me, the credit card service, but you need to

00:28:21,590 --> 00:28:24,030
tell me explicitly that you knew that there was

00:28:24,040 --> 00:28:25,700
this case to handle and that you handled it

00:28:25,700 --> 00:28:28,080
in some way.

00:28:28,080 --> 00:28:30,450
That's kind of cool, right. You can't do that

00:28:30,450 --> 00:28:32,640
with if statements. It's impossible to do with if

00:28:32,640 --> 00:28:34,450
statements, unless you remember to call some magic method

00:28:34,450 --> 00:28:37,980
or something. And here, instead of relying on documentation

00:28:38,000 --> 00:28:40,440
and my ability to read and understand how to

00:28:40,440 --> 00:28:43,170
use this credit card service, the API itself can

00:28:43,170 --> 00:28:45,710
bake in all of this safety. It can, it

00:28:45,710 --> 00:28:48,870
can encapsulate the knowledge that our garbage collector has

00:28:48,870 --> 00:28:52,370
so that we can live in fantasy land.

00:28:52,380 --> 00:28:55,240
Which is kind of cool. So it's something, and

00:28:55,260 --> 00:28:56,790
I should point out, I didn't come up with

00:28:56,790 --> 00:28:59,480
this, this little pattern and then write a talk

00:28:59,480 --> 00:29:00,270
around it. I just came up with the talk

00:29:00,270 --> 00:29:03,470
and I just tried to, tried to write this

00:29:03,470 --> 00:29:05,790
code without if statements, and that's kind of what

00:29:05,820 --> 00:29:07,320
I came up with. So it's kind of interesting

00:29:07,320 --> 00:29:09,170
that that is something that fell out, that I

00:29:09,170 --> 00:29:12,510
can do more things.

00:29:12,510 --> 00:29:15,100
But I've skated the issue of the if statement,

00:29:15,120 --> 00:29:17,330
right. I've, I've changed the rules so I didn't

00:29:17,330 --> 00:29:19,980
need an if statement to implement this. But somebody,

00:29:19,980 --> 00:29:22,610
somewhere, is gonna have to figure out, did the

00:29:22,610 --> 00:29:25,560
credit card succeed or not, and do something or

00:29:25,580 --> 00:29:27,160
do something else. So somebody has to do that

00:29:27,160 --> 00:29:28,340
somewhere.

00:29:28,340 --> 00:29:30,790
So let's delve more into our imagined credit card

00:29:30,790 --> 00:29:33,560
service. And, and see where that, see where that

00:29:33,560 --> 00:29:36,020
leads us. SO we can imagine that the way

00:29:36,020 --> 00:29:39,190
this works is it'll sort out some URL. It'll

00:29:39,190 --> 00:29:41,430
call the URL over the internet, get some status

00:29:41,430 --> 00:29:46,340
back, and then we'll have the outcome class kind

00:29:46,340 --> 00:29:48,000
of handle figuring out what that result means.

00:29:48,020 --> 00:29:49,790
So the outcome class, since it has all these

00:29:49,790 --> 00:29:52,080
blocks of code that we gave it, it's going

00:29:52,100 --> 00:29:54,500
to look at the results of our restful API

00:29:54,500 --> 00:29:56,440
call, figure out what it means and figure out

00:29:56,440 --> 00:29:58,160
what block of code to call.

00:29:58,160 --> 00:30:01,010
That sounds like a job for if statements. So

00:30:01,010 --> 00:30:03,640
taking a step deeper, right, our, our method has

00:30:03,640 --> 00:30:07,560
kind of three parts. It gets status from result,

00:30:07,560 --> 00:30:10,260
it'll call on the private method that, that sorts

00:30:10,260 --> 00:30:12,510
out what that status means. It returns the name

00:30:12,510 --> 00:30:14,030
of a method and then we will call that

00:30:14,040 --> 00:30:16,280
method on ourselves.

00:30:16,280 --> 00:30:18,950
So the what to call method is where we

00:30:18,950 --> 00:30:20,310
have these if statements. So this might be how

00:30:20,310 --> 00:30:23,250
we would do it if we, we had if

00:30:23,260 --> 00:30:26,780
statements. But we don't. So we could do this

00:30:26,780 --> 00:30:29,010
outcome type thing again, we could just keep doing

00:30:29,020 --> 00:30:31,570
outcomes within outcomes and all that, but somebody somewhere's

00:30:31,580 --> 00:30:33,630
gonna have to compare two values and decide to

00:30:33,630 --> 00:30:35,450
do one thing or the other.

00:30:35,450 --> 00:30:37,430
So let's not do the outcome thing here. Let's

00:30:37,430 --> 00:30:40,430
try to do this a different way.

00:30:40,440 --> 00:30:42,880
The result is gonna be super strange.

00:30:42,880 --> 00:30:44,700
So we made a little pseudo code here. So

00:30:44,700 --> 00:30:48,190
we, what we have is we have some expressions

00:30:48,190 --> 00:30:49,820
and if this expression is true we want to

00:30:49,820 --> 00:30:51,690
do this, and if this is true we want

00:30:51,700 --> 00:30:52,860
to do this, and all else we could do

00:30:52,860 --> 00:30:55,850
that. Right, that's the basic logic that we want.

00:30:55,850 --> 00:30:58,350
So since we don't have these if statements, how

00:30:58,380 --> 00:31:00,650
can we capture these expressions in some way that

00:31:00,650 --> 00:31:03,760
we can evaluate them. Well, we could wrap them

00:31:03,760 --> 00:31:06,340
in a lambda. So now we have a mapping

00:31:06,340 --> 00:31:10,160
of a lambda representing our expression to some symbol.

00:31:10,160 --> 00:31:11,140
So what we want to do is we want

00:31:11,140 --> 00:31:13,290
to go through all of these lambdas that we

00:31:13,290 --> 00:31:16,090
have and find the first one that's true.

00:31:16,090 --> 00:31:17,750
So if we had them in a list, say,

00:31:17,780 --> 00:31:20,070
right, so now we have a list of pairs.

00:31:20,070 --> 00:31:22,240
Each pair is a lambda representing our expression and

00:31:22,240 --> 00:31:24,890
the method to call. So we want the first

00:31:24,890 --> 00:31:27,260
one in this list, so that's detect. And so

00:31:27,280 --> 00:31:29,410
detect, if you don't know, it, it finds the

00:31:29,410 --> 00:31:31,820
first element in a list for which a particular

00:31:31,820 --> 00:31:33,470
condition holds.

00:31:33,470 --> 00:31:35,750
So in that case, that condition is to call

00:31:35,760 --> 00:31:37,570
our lambdas and see if they return true with

00:31:37,570 --> 00:31:41,060
our input. So that is going to return one

00:31:41,060 --> 00:31:43,570
of our pairs. Our pair being the, the lambda

00:31:43,580 --> 00:31:45,420
and the method. Of course, we don't care about

00:31:45,420 --> 00:31:48,400
the lambda. So we destructure it and we get

00:31:48,400 --> 00:31:49,010
the method.

00:31:49,010 --> 00:31:50,990
And if detect didn't find anything, it's going to

00:31:50,990 --> 00:31:53,480
return nil, which means we will return call on

00:31:53,500 --> 00:31:55,480
exception. So that is how you do that without

00:31:55,480 --> 00:31:57,400
any if statements.

00:31:57,400 --> 00:31:59,260
That is weird, right. I mean, does this look

00:31:59,260 --> 00:32:03,750
normal to anyone? If I came across this, it

00:32:03,760 --> 00:32:06,340
would take me a long time to learn that

00:32:06,340 --> 00:32:08,910
this was an if statement and I would venture

00:32:08,910 --> 00:32:11,780
to say a language for which this was the

00:32:11,780 --> 00:32:14,140
primary way to direct logic would probably not be

00:32:14,140 --> 00:32:15,680
a successful language.

00:32:15,680 --> 00:32:19,780
Cause this is very strange.

00:32:19,780 --> 00:32:21,690
So I must ask myself, is there something I

00:32:21,700 --> 00:32:23,100
can do with this, is there some advantage to

00:32:23,100 --> 00:32:27,280
this that I didn't get with these if statements?

00:32:27,280 --> 00:32:30,560
So let's suppose I made, I made an error.

00:32:30,560 --> 00:32:32,610
Now, this is very simplified, right. You can see

00:32:32,610 --> 00:32:35,240
here that two hundred is less than five hundred.

00:32:35,240 --> 00:32:38,040
So this code is never gonna be called. Now

00:32:38,040 --> 00:32:40,070
this is super simple. You can kind of see

00:32:40,070 --> 00:32:42,460
by inspection that there's a problem, and it would

00:32:42,460 --> 00:32:44,140
be very simple to write a test that reveals

00:32:44,160 --> 00:32:45,790
this and you would probably have those tests.

00:32:45,790 --> 00:32:48,970
So I'm asking you to remember that code that

00:32:48,980 --> 00:32:51,400
you have fully tested but yet was buggy, because

00:32:51,400 --> 00:32:53,660
there is something you forgot, or a bunch of

00:32:53,660 --> 00:32:56,200
if statements that were very hard to understand all

00:32:56,200 --> 00:33:00,480
at once, right. And that you have totally tested,

00:33:00,480 --> 00:33:01,700
and it went to production and then it didn't

00:33:01,700 --> 00:33:04,620
work because of something like this.

00:33:04,620 --> 00:33:08,190
So the only way, right, the only way to

00:33:08,190 --> 00:33:10,240
solve this is to have a lot of tests

00:33:10,240 --> 00:33:13,980
and just be diligent, right. Just try harder. But

00:33:13,980 --> 00:33:16,220
is there a way with this other crazy structure

00:33:16,220 --> 00:33:19,230
that we could do that? And so you might

00:33:19,240 --> 00:33:20,950
be wondering why, you might have noticed that I

00:33:20,950 --> 00:33:23,500
used a list, right, instead of a map between

00:33:23,500 --> 00:33:24,790
the map and all that stuff. That's because the

00:33:24,790 --> 00:33:27,470
list retains the order. And so the order in

00:33:27,480 --> 00:33:31,570
which we evaluate these things is very important.

00:33:31,570 --> 00:33:34,850
So how could we, how could we detect this

00:33:34,880 --> 00:33:38,920
error? So, since our logic is not encoded in

00:33:38,920 --> 00:33:41,080
the programming language, but is actually encoded in a

00:33:41,080 --> 00:33:43,710
data structure, we could examine this data structure and,

00:33:43,710 --> 00:33:45,910
and find out things about it. So if we

00:33:45,910 --> 00:33:47,940
assumed that our crazy version of Ruby that has

00:33:47,940 --> 00:33:50,510
no if statements and requires us to do this

00:33:50,510 --> 00:33:54,590
exists, it seems logical that it might have a

00:33:54,620 --> 00:33:59,010
class that helps us write this weird if statement.

00:33:59,010 --> 00:34:01,070
So, and, again, all of this code works. There's

00:34:01,080 --> 00:34:03,370
a link at the end. This all absolutely works.

00:34:03,370 --> 00:34:05,580
So let's say this logic class here handles all

00:34:05,580 --> 00:34:07,880
that mumbo jumbo with going through the list and

00:34:07,880 --> 00:34:10,090
detect and all that crap. So all we have

00:34:10,100 --> 00:34:11,760
to do is this. Now, I'm not saying this

00:34:11,760 --> 00:34:15,300
is not weird - this is still strange. But

00:34:15,300 --> 00:34:18,020
it kind of creates a class concept here.

00:34:18,020 --> 00:34:22,280
So when we evaluate the logic, given an input,

00:34:22,280 --> 00:34:25,169
the logic could say, hey, that input is true

00:34:25,169 --> 00:34:28,011
for more than one expression. So I don't know

00:34:28,020 --> 00:34:29,500
which one you meant. I don't know what to

00:34:29,500 --> 00:34:31,850
do. I'm just gonna assume that you haven't thought

00:34:31,850 --> 00:34:33,810
this through, you've screwed something up, and I'm just

00:34:33,820 --> 00:34:35,540
gonna, I'm just gonna blow up.

00:34:35,540 --> 00:34:39,290
With a nonexclusive disjunction error. That's the best name

00:34:39,290 --> 00:34:41,060
I could come up with for that, for that

00:34:41,060 --> 00:34:44,050
concept. It took a lot of Wikipedia sleuthing to

00:34:44,050 --> 00:34:46,530
figure that out.

00:34:46,530 --> 00:34:49,609
So that's kind of handy, right. So if every

00:34:49,620 --> 00:34:52,211
crazy set of conditionals I ever wrote could be

00:34:52,220 --> 00:34:54,270
evaluated by someone smarter than me and tell me

00:34:54,270 --> 00:34:56,369
that I didn't think it through and things aren't

00:34:56,369 --> 00:34:59,781
mutually exclusive, that would be useful to me.

00:34:59,800 --> 00:35:02,300
So to fix it, we have to do this,

00:35:02,300 --> 00:35:05,020
right. Now these two things are mutually exclusive. They

00:35:05,020 --> 00:35:08,340
will never be true for the same input. But,

00:35:08,340 --> 00:35:12,490
but, right, everybody's bothered by this repetition I hope.

00:35:12,490 --> 00:35:15,050
Cause this bothers me. Like, I don't like having

00:35:15,060 --> 00:35:16,200
to say the same thing twice. That's what the

00:35:16,200 --> 00:35:19,230
if statement gave us - the else concept.

00:35:19,230 --> 00:35:21,270
But this is just blocks and, and lambdas, so

00:35:21,270 --> 00:35:24,080
we could extract them and reuse them. And now

00:35:24,080 --> 00:35:26,240
look at our code, right. Logic on success, then

00:35:26,240 --> 00:35:28,700
return call and success. Logic on decline, then return

00:35:28,720 --> 00:35:31,860
call and decline. Logic evaluate status or else call

00:35:31,860 --> 00:35:32,620
on exception.

00:35:32,620 --> 00:35:34,580
It has that awesome Ruby-like quality where you can

00:35:34,580 --> 00:35:37,660
just read the code out and it's like, executable

00:35:37,660 --> 00:35:40,030
pseudo code. Like that's kind of cool. Even though,

00:35:40,030 --> 00:35:41,970
like, it's kind of weird what we're doing, it's

00:35:41,970 --> 00:35:43,590
pretty easy to understand. And this is a lot

00:35:43,600 --> 00:35:46,570
easier to understand than that crazy list of, and

00:35:46,570 --> 00:35:48,300
detect and all that.

00:35:48,320 --> 00:35:50,610
So I could see a language that had this

00:35:50,610 --> 00:35:52,700
as the way of branching. That might be a

00:35:52,720 --> 00:35:55,340
little more successful than, than our other one.

00:35:55,340 --> 00:36:01,170
So, yeah, that's, that's, that's, that's kind of crazy.

00:36:01,170 --> 00:36:03,990
So that was a lot of weird stuff, and,

00:36:03,990 --> 00:36:05,560
like I said, it all works, and, and I

00:36:05,560 --> 00:36:07,290
can, I'll show you the link at the end.

00:36:07,290 --> 00:36:09,410
I'm not telling you you should do that ever.

00:36:09,440 --> 00:36:10,700
I'm not saying you should put that in your

00:36:10,700 --> 00:36:13,130
production code base. I certainly haven't.

00:36:13,130 --> 00:36:18,470
But what you should take away is that sometimes

00:36:18,470 --> 00:36:21,770
more interesting things can come if you remove tools,

00:36:21,770 --> 00:36:24,050
if you remove techniques. If those things that you

00:36:24,060 --> 00:36:27,580
are really hold dear or think that there's no

00:36:27,580 --> 00:36:30,160
way I could ever do without X - well,

00:36:30,180 --> 00:36:32,250
try solving the problem without X and see what

00:36:32,250 --> 00:36:34,000
happens. You might be surprised. You might come up

00:36:34,000 --> 00:36:37,730
with something that is actually really useful, and maybe

00:36:37,740 --> 00:36:38,470
gives you more power.

00:36:38,470 --> 00:36:41,150
I mean this, this business with the credit card

00:36:41,150 --> 00:36:43,980
service where you map the outcome to the code

00:36:44,000 --> 00:36:45,630
and it blows up if you haven't thought of

00:36:45,630 --> 00:36:48,440
everything, like, that seems actually kind of useful, like,

00:36:48,440 --> 00:36:50,890
especially for something as critical as like taking money

00:36:50,900 --> 00:36:52,130
from people. Like I kind of want to get

00:36:52,130 --> 00:36:53,730
that really right.

00:36:53,740 --> 00:36:56,260
So it's kind of interesting. So I'd encourage you

00:36:56,260 --> 00:36:58,390
to do the same things.

00:36:58,390 --> 00:36:59,780
That's all I've got. I do want to pitch

00:36:59,780 --> 00:37:02,330
from my company, we are small. We have a

00:37:02,340 --> 00:37:04,620
business model that works and is easy to understand,

00:37:04,620 --> 00:37:08,440
which I hope you find interesting. If you're interested

00:37:08,440 --> 00:37:11,030
at all, come talk to me. Here's the links

00:37:11,030 --> 00:37:14,110
for everything. The book, Senior Software Engineer, that I

00:37:14,120 --> 00:37:15,560
told you I wouldn't talk about cause it's not

00:37:15,560 --> 00:37:17,640
relevant, well, you can buy it today for $10

00:37:17,640 --> 00:37:20,050
if you'd like. That's all I got.

00:37:20,050 --> 00:37:21,870
I think we have a few time for questions

00:37:21,880 --> 00:37:25,190
if anyone, if anyone has them.

00:37:26,980 --> 00:37:28,540
Cool. Well, if you got any other questions, come

00:37:28,560 --> 00:37:31,260
up and talk to me and I really appreciate

00:37:31,260 --> 00:37:33,760

YouTube URL: https://www.youtube.com/watch?v=inU7MEtI51g


