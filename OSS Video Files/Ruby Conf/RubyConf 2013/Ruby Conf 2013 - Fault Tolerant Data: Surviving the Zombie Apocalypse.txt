Title: Ruby Conf 2013 - Fault Tolerant Data: Surviving the Zombie Apocalypse
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	by Casey Rosenthal

Acute Zombielepsy has broken out, and the CDC has turned to you to store the first one million records of victims in the U.S. including the subject's name, DNA sample, geo, etc. You must store this crucial data in a resilient manner in case one or more data centers are compromised by the outbreak. The CDC also needs to query the data in several ways; for example, they want to see the outbreak on a map to visualize geographic clusters. Naturally, you turn a fault-tolerant NoSQL database to store this data. But since you come from a relational background, you find it difficult at first to model the data properly for the types of queries that the CDC wants to run. Learn about advanced data modeling on a key-value database in Ruby -- distributed indexes, convergent data types, geohashes, and more -- on a truly fault tolerant database infrastructure. Keep calm; the fate of the human race depends on you.

Help us caption & translate this video!

http://amara.org/v/FG5V/
Captions: 
	00:00:16,510 --> 00:00:18,560
CASEY ROSENTHAL: Hi.

00:00:18,560 --> 00:00:20,620
Hope everybody had a good lunch.

00:00:20,620 --> 00:00:29,340
I'd like to start by reading the title of my presentation.

00:00:29,340 --> 00:00:32,610
Fault Tolerant Data: Surviving the Zombie Apocalypse.

00:00:32,610 --> 00:00:35,250
I'm Casey Rosenthal.

00:00:35,250 --> 00:00:37,460
That's my Twitter handle.

00:00:37,460 --> 00:00:38,460
If you're

00:00:38,460 --> 00:00:39,460
interested in some of the stuff I talk about,

00:00:39,460 --> 00:00:41,030
I figure the most efficient way for me to

00:00:41,030 --> 00:00:42,870
get links to you is I'll, I'll Tweet the

00:00:42,870 --> 00:00:47,340
links after the talk.

00:00:47,340 --> 00:00:48,940
Very small bit of background on me - I

00:00:48,940 --> 00:00:51,060
worked for a company called Basho.

00:00:51,060 --> 00:00:52,060
Our icons look

00:00:52,060 --> 00:00:55,629
like this because it's named after a Japanese poet.

00:00:55,629 --> 00:00:56,730
So that's me.

00:00:56,730 --> 00:00:58,360
I get to work with a

00:00:58,360 --> 00:01:00,729
really good team of consultants.

00:01:00,729 --> 00:01:02,409
That's the consulting team

00:01:02,409 --> 00:01:04,750
I've had the opportunity to work with.

00:01:04,750 --> 00:01:09,290
And we set up distributed databases for critical data

00:01:09,290 --> 00:01:11,390
for large enterprises.

00:01:11,390 --> 00:01:16,460
So recording things like internet traffic,

00:01:16,460 --> 00:01:19,100
transactions and things that lives depend on, like medical

00:01:19,100 --> 00:01:20,910
records and video game scores.

00:01:20,910 --> 00:01:23,910
Really important things like

00:01:23,910 --> 00:01:24,910
that.

00:01:24,910 --> 00:01:28,011
And to give you a sense of where, what

00:01:28,011 --> 00:01:33,920
my motivation is - I love working with data.

00:01:33,920 --> 00:01:38,300
And I'm gonna make the, you can call databases

00:01:38,300 --> 00:01:42,990
sequel versus no sequel, new sequel, no dbs, there's

00:01:42,990 --> 00:01:45,480
a bunch of different ways of chopping up the

00:01:45,480 --> 00:01:47,890
database space right now.

00:01:47,890 --> 00:01:49,220
But from a software engineer's

00:01:49,220 --> 00:01:52,410
perspective, I'm gonna draw a primary distinction between sequel

00:01:52,410 --> 00:01:54,690
and other, OK.

00:01:54,690 --> 00:02:00,500
So I work particularly with a distributed key-value database.

00:02:00,500 --> 00:02:02,380
Most of the data modeling techniques I'm gonna talk

00:02:02,380 --> 00:02:09,000
about are applicable to distributed key-value and other kinds

00:02:09,000 --> 00:02:11,190
of distributed databases.

00:02:11,190 --> 00:02:12,190
Not just the one that I

00:02:12,190 --> 00:02:15,430
happen to work with most, which is Reaq??

00:02:15,430 --> 00:02:16,590
[00:02:15].

00:02:16,590 --> 00:02:19,780
So the reason that I love this category is

00:02:19,780 --> 00:02:24,140
other is because I'm gonna generalize, I'm totally gonna

00:02:24,140 --> 00:02:26,639
generalize about your experience.

00:02:26,639 --> 00:02:27,639
Most of you have worked

00:02:27,639 --> 00:02:29,190
with relational databases.

00:02:29,190 --> 00:02:30,450
I don't really care if that's

00:02:30,450 --> 00:02:31,690
true, I'm just gonna assume it.

00:02:31,690 --> 00:02:35,490
So I also come from a background with sequel,

00:02:35,490 --> 00:02:41,030
with relational databases, and over many, many years working

00:02:41,030 --> 00:02:44,110
in other languages, but also Ruby, I got to

00:02:44,110 --> 00:02:46,599
the point where, OK, I kind of understood what

00:02:46,599 --> 00:02:49,239
an MBC framework looked like.

00:02:49,239 --> 00:02:50,239
I'm not gonna come

00:02:50,239 --> 00:02:52,849
across any new surprises there.

00:02:52,849 --> 00:02:56,220
With the decades of institutional knowledge we have about

00:02:56,220 --> 00:02:59,569
sequel databases, nothing is really gonna surprise me about

00:02:59,569 --> 00:03:01,719
how to write, how to data- how to mile

00:03:01,719 --> 00:03:05,200
data on a relational database.

00:03:05,200 --> 00:03:07,580
And if you know your design patterns, and you

00:03:07,580 --> 00:03:11,319
probably have a couple that you use regularly, it's

00:03:11,319 --> 00:03:13,750
unlikely that you're gonna come across a design pattern

00:03:13,750 --> 00:03:16,110
that, like, completely blows your mind and changes how

00:03:16,110 --> 00:03:18,909
you do everything.

00:03:18,909 --> 00:03:22,730
In the category of other databases, that happens on

00:03:22,730 --> 00:03:24,590
a regular basis.

00:03:24,590 --> 00:03:26,900
New databases come along that completely

00:03:26,900 --> 00:03:30,890
change, not only how you understand modeling your data,

00:03:30,890 --> 00:03:33,599
but the kinds of applications you're able to build,

00:03:33,599 --> 00:03:36,650
because they have different properties, they can do new

00:03:36,650 --> 00:03:39,540
things, they look at data in a different way

00:03:39,540 --> 00:03:42,810
that you didn't have the capability of accessing before.

00:03:42,810 --> 00:03:44,780
So it's really cutting edge and it changes a

00:03:44,780 --> 00:03:49,749
lot and it's a good brain exercise.

00:03:49,749 --> 00:03:52,180
So part of that is just the computology aspect.

00:03:52,180 --> 00:03:54,531
I happen to like reading white papers, and there's

00:03:54,531 --> 00:03:57,620
a lot of great academic work going on right

00:03:57,620 --> 00:04:01,079
now in the other database and the distributed systems

00:04:01,079 --> 00:04:02,999
sphere.

00:04:02,999 --> 00:04:04,959
There are a lot of unsolved problems, still.

00:04:04,959 --> 00:04:05,959
There

00:04:05,959 --> 00:04:07,909
are cases where we don't know the implications of

00:04:07,909 --> 00:04:10,689
setting up certain kinds of distributed architectures.

00:04:10,689 --> 00:04:12,319
And I'll

00:04:12,319 --> 00:04:15,849
touch on a couple of them.

00:04:15,849 --> 00:04:18,780
The other reason this field is exciting to me

00:04:18,780 --> 00:04:24,960
is because of this principle of high availability.

00:04:24,960 --> 00:04:28,990
Yeah.

00:04:28,990 --> 00:04:33,030
Zing.

00:04:33,030 --> 00:04:38,600
So think for a moment about Google, right.

00:04:38,600 --> 00:04:39,600
When

00:04:39,600 --> 00:04:43,430
you go to search something, you don't necessarily expect

00:04:43,430 --> 00:04:47,630
that it has everything indexed up to the exact

00:04:47,630 --> 00:04:51,430
second that you hit the search button, right.

00:04:51,430 --> 00:04:52,430
We

00:04:52,430 --> 00:04:53,700
allow a little bit of fuziness in the results.

00:04:53,700 --> 00:04:55,251
In fact, we don't even expect that if you

00:04:55,251 --> 00:04:58,650
search here, you're gonna get the same exact results

00:04:58,650 --> 00:05:01,230
at the same time as if somebody did the

00:05:01,230 --> 00:05:04,060
same exact search in LA, right.

00:05:04,060 --> 00:05:06,250
We allow for a little bit of oddness there.

00:05:06,250 --> 00:05:08,650
What we do expect is that Google will show

00:05:08,650 --> 00:05:09,650
up.

00:05:09,650 --> 00:05:11,700
If we get a 500 or a 400,

00:05:11,700 --> 00:05:14,730
we'll probably start checking our internet connection first, before

00:05:14,730 --> 00:05:17,180
we think, Google is down, right.

00:05:17,180 --> 00:05:20,370
That's high, that's a form of high availability.

00:05:20,370 --> 00:05:21,370
To

00:05:21,370 --> 00:05:22,370
give you another example - email.

00:05:22,370 --> 00:05:23,370
If you use

00:05:23,370 --> 00:05:25,820
email on your phone, and your phone goes out

00:05:25,820 --> 00:05:27,960
of range, you don't expect that you all of

00:05:27,960 --> 00:05:29,430
the sudden won't be able to read your email

00:05:29,430 --> 00:05:31,700
and not be able to write email.

00:05:31,700 --> 00:05:32,700
You expect

00:05:32,700 --> 00:05:33,700
that when the internet connects again.

00:05:33,700 --> 00:05:34,700
Anything you've written

00:05:34,700 --> 00:05:35,700
gets sent out.

00:05:35,700 --> 00:05:37,070
You know, and so that's another

00:05:37,070 --> 00:05:39,510
form of high availability, that the key ingredient here

00:05:39,510 --> 00:05:42,920
is there is not a global state that exists,

00:05:42,920 --> 00:05:46,770
that is consistent, at any given point in time.

00:05:46,770 --> 00:05:49,190
Of course, health records.

00:05:49,190 --> 00:05:51,750
You don't expect, when you

00:05:51,750 --> 00:05:54,760
buy insurance or update your, your, or go to

00:05:54,760 --> 00:05:57,650
the doctor, that immediately that's gonna be reflected on

00:05:57,650 --> 00:05:59,610
your health record.

00:05:59,610 --> 00:06:00,830
But you do expect that when

00:06:00,830 --> 00:06:02,770
you go to the health insurance website, it will

00:06:02,770 --> 00:06:03,770
be up.

00:06:03,770 --> 00:06:05,440
And it will have, like, historical data

00:06:05,440 --> 00:06:07,970
available to you.

00:06:07,970 --> 00:06:10,960
So that's really interesting, because that's the expectation that

00:06:10,960 --> 00:06:14,040
most of us have, most people familiar with the

00:06:14,040 --> 00:06:16,520
internet have, about using the internet.

00:06:16,520 --> 00:06:17,520
Is that it's

00:06:17,520 --> 00:06:19,990
highly available and not strongly consistent.

00:06:19,990 --> 00:06:20,990
It doesn't have

00:06:20,990 --> 00:06:23,320
one global state at any given point in time.

00:06:23,320 --> 00:06:26,180
And there's kind of this tension between the two.

00:06:26,180 --> 00:06:29,340
Well if that's the expectation, the interesting thing is

00:06:29,340 --> 00:06:32,520
sequel was designed to be strongly consistent.

00:06:32,520 --> 00:06:37,140
So the database that we use intrinsically is not

00:06:37,140 --> 00:06:39,800
the one that follows the paradigm that most of

00:06:39,800 --> 00:06:45,090
our expectations using online applications follow.

00:06:45,090 --> 00:06:46,930
Other databases are

00:06:46,930 --> 00:06:50,010
built with high availability in mind.

00:06:50,010 --> 00:06:51,850
So they might not be strong consistent at a

00:06:51,850 --> 00:06:52,850
given point in time.

00:06:52,850 --> 00:06:54,030
They might be eventually consistent.

00:06:54,030 --> 00:06:58,610
There's allowance for data that hasn't propogated to all

00:06:58,610 --> 00:07:02,390
of the machines in the cluster to get around

00:07:02,390 --> 00:07:05,240
to it.

00:07:05,240 --> 00:07:08,670
So to really hammer home this distinction, I'm gonna

00:07:08,670 --> 00:07:13,750
focus on two different mindsets when we're building applications.

00:07:13,750 --> 00:07:17,370
This is your brain SQL.

00:07:17,370 --> 00:07:18,460
And nobody's rushing the

00:07:18,460 --> 00:07:20,220
screen, which is a good sign, so there's no

00:07:20,220 --> 00:07:23,500
zombies in here.

00:07:23,500 --> 00:07:26,330
When you're building - so, as an engineer, you

00:07:26,330 --> 00:07:28,080
get a use case and you're gonna build this

00:07:28,080 --> 00:07:29,870
application on SQL.

00:07:29,870 --> 00:07:32,580
Again, I'm just gonna generalize some

00:07:32,580 --> 00:07:33,790
experience here.

00:07:33,790 --> 00:07:35,990
So you take the use case, you

00:07:35,990 --> 00:07:38,800
figure out what data's in there - say, addresses,

00:07:38,800 --> 00:07:41,400
companies, users, whatever.

00:07:41,400 --> 00:07:42,470
And you break those down into

00:07:42,470 --> 00:07:43,640
tables.

00:07:43,640 --> 00:07:45,580
Figure out what the relationships between those tables

00:07:45,580 --> 00:07:49,080
are, and denormalize your data.

00:07:49,080 --> 00:07:50,280
Do a lot of other things that, again, we

00:07:50,280 --> 00:07:53,660
have decades of institutional knowledge, how to structure tables

00:07:53,660 --> 00:07:57,820
and rows and indexes in relational databases.

00:07:57,820 --> 00:07:58,820
And if

00:07:58,820 --> 00:08:02,090
we do that right, according to best practices, if

00:08:02,090 --> 00:08:05,470
we do that well, then we have a pretty

00:08:05,470 --> 00:08:09,400
good level of confidense that when we go to

00:08:09,400 --> 00:08:11,540
build an application on top of it, we'll be

00:08:11,540 --> 00:08:13,910
able to get the data out in a way

00:08:13,910 --> 00:08:16,420
that we want to present it to the client,

00:08:16,420 --> 00:08:18,889
whether the client is another computer or person or

00:08:18,889 --> 00:08:19,889
whatever.

00:08:19,889 --> 00:08:20,889
OK.

00:08:20,889 --> 00:08:23,320
Model your data, do that well, then show

00:08:23,320 --> 00:08:25,530
it to the client.

00:08:25,530 --> 00:08:31,190
By contrast, when you're building, when, an application on

00:08:31,190 --> 00:08:33,710
top of a key-value system, you have to have

00:08:33,710 --> 00:08:35,519
a different mindset.

00:08:35,519 --> 00:08:36,769
And that mindset is, is kind

00:08:36,769 --> 00:08:37,940
of the reverse.

00:08:37,940 --> 00:08:38,940
You look at the use case

00:08:38,940 --> 00:08:40,810
and you focus on how is this gonna look

00:08:40,810 --> 00:08:41,810
to the client?

00:08:41,810 --> 00:08:44,950
Again, whether the client is another machine, or a

00:08:44,950 --> 00:08:48,360
user or a terminal or whatever, how, how is

00:08:48,360 --> 00:08:50,570
it gonna be presented at the end?

00:08:50,570 --> 00:08:51,570
If you

00:08:51,570 --> 00:08:53,780
can figure that out, then modeling the data kind

00:08:53,780 --> 00:08:56,060
of falls out, OK.

00:08:56,060 --> 00:08:58,270
Figure out how it's gonna be presented, and then

00:08:58,270 --> 00:09:00,150
with a high degree of confidense you know you'll

00:09:00,150 --> 00:09:03,260
be able to model the data in a K/V.

00:09:03,260 --> 00:09:06,340
It's not that one is better than the other

00:09:06,340 --> 00:09:08,980
in terms of data modeling.

00:09:08,980 --> 00:09:10,150
The difference is that

00:09:10,150 --> 00:09:18,940
SQL is more flexible, but harder to scale.

00:09:18,940 --> 00:09:23,080
And that's not a principle, that's an observation.

00:09:23,080 --> 00:09:24,080
So

00:09:24,080 --> 00:09:27,040
I'm not saying that in principle SQL is harder

00:09:27,040 --> 00:09:28,040
to scale.

00:09:28,040 --> 00:09:29,850
But I will make the observation, that

00:09:29,850 --> 00:09:33,250
the more sophisticated the query planner is in your

00:09:33,250 --> 00:09:36,810
database, the more difficult it is to scale that

00:09:36,810 --> 00:09:39,910
database in a way that's highly available or fault

00:09:39,910 --> 00:09:42,560
tolerant in particular.

00:09:42,560 --> 00:09:43,560
OK.

00:09:43,560 --> 00:09:45,940
K/V, that's the simplest kind of database you

00:09:45,940 --> 00:09:47,110
could have, right.

00:09:47,110 --> 00:09:48,110
You give a database a key

00:09:48,110 --> 00:09:50,260
and a value, it'll store the value.

00:09:50,260 --> 00:09:51,260
You give

00:09:51,260 --> 00:09:52,680
it just the key, it gives back the value.

00:09:52,680 --> 00:09:56,390
There's really no query planning going on there, so

00:09:56,390 --> 00:09:58,830
the design of the database can do other interesting

00:09:58,830 --> 00:10:01,290
things, like focus on making it highly available and

00:10:01,290 --> 00:10:05,210
fault tolerant and scale horizontally.

00:10:05,210 --> 00:10:06,880
So I want to put this in a perspective

00:10:06,880 --> 00:10:10,060
that we can all relate to.

00:10:10,060 --> 00:10:11,140
So the situation

00:10:11,140 --> 00:10:13,760
we've all had, well maybe you don't all take

00:10:13,760 --> 00:10:16,671
the subway, but you know I get up, go

00:10:16,671 --> 00:10:20,070
to work, get on the subway, and look over

00:10:20,070 --> 00:10:22,700
and there's somebody else who's obviously going to work,

00:10:22,700 --> 00:10:28,820
but they look a little not right.

00:10:28,820 --> 00:10:31,490
We've all had this experience.

00:10:31,490 --> 00:10:32,490
We see that there's

00:10:32,490 --> 00:10:36,320
a zombie on the subway and we know that,

00:10:36,320 --> 00:10:38,410
you know, the apocalypse is upon us.

00:10:38,410 --> 00:10:39,410
So it's

00:10:39,410 --> 00:10:42,360
a common theme in our careers.

00:10:42,360 --> 00:10:44,290
Zombies!

00:10:44,290 --> 00:10:46,220
Right.

00:10:46,220 --> 00:10:48,870
So we've all had this experience, and you

00:10:48,870 --> 00:10:53,060
know, maybe the acute zombielepsy breaks out, as it

00:10:53,060 --> 00:10:55,330
does, and you know, maybe the zombies start here

00:10:55,330 --> 00:10:58,029
in Miami, and you got to admit, some of

00:10:58,029 --> 00:11:00,390
those zombies can run fast.

00:11:00,390 --> 00:11:03,430
So they spread and

00:11:03,430 --> 00:11:06,520
pretty soon there's, let's say, a million zombies around

00:11:06,520 --> 00:11:07,940
the country.

00:11:07,940 --> 00:11:12,741
So, again, as frequently happens to me, and I'm

00:11:12,741 --> 00:11:15,690
sure to all of you, the CDC comes and

00:11:15,690 --> 00:11:18,790
says, hey, we need to get a handle on

00:11:18,790 --> 00:11:19,790
this.

00:11:19,790 --> 00:11:21,151
We need to store all of this zombie

00:11:21,151 --> 00:11:22,151
data.

00:11:22,151 --> 00:11:25,371
We need to do it quickly, so, you

00:11:25,371 --> 00:11:29,170
know, we want an application built in Ruby, because

00:11:29,170 --> 00:11:31,420
developer time is of the essence.

00:11:31,420 --> 00:11:32,420
We want this

00:11:32,420 --> 00:11:33,420
to be agile.

00:11:33,420 --> 00:11:34,420
We don't know exactly what kind

00:11:34,420 --> 00:11:36,420
of things we're gonna have to do with the

00:11:36,420 --> 00:11:38,600
data.

00:11:38,600 --> 00:11:41,350
And we have this database that we need to

00:11:41,350 --> 00:11:42,710
store it in.

00:11:42,710 --> 00:11:43,710
OK.

00:11:43,710 --> 00:11:46,300
I'm sure anybody can do

00:11:46,300 --> 00:11:47,300
this.

00:11:47,300 --> 00:11:48,300
This isn't too sophisticated.

00:11:48,300 --> 00:11:49,300
What does the data look like?

00:11:49,300 --> 00:11:50,300
Well, here's an

00:11:50,300 --> 00:11:54,279
example of a value that's just in JSON.

00:11:54,279 --> 00:11:55,279
SO

00:11:55,279 --> 00:11:58,420
we've got some DNA, DNA sample, of the zombie.

00:11:58,420 --> 00:12:01,640
Their gender, their name, address, city, zip.

00:12:01,640 --> 00:12:02,640
Weight, height,

00:12:02,640 --> 00:12:03,640
latitude, longitude.

00:12:03,640 --> 00:12:05,029
I left some out - blood type,

00:12:05,029 --> 00:12:07,839
phone number, social security number, stuff like that.

00:12:07,839 --> 00:12:10,890
But the situation's a little bit more complicated.

00:12:10,890 --> 00:12:11,890
The

00:12:11,890 --> 00:12:16,000
CDC actually has databases all around the country.

00:12:16,000 --> 00:12:17,000
And

00:12:17,000 --> 00:12:19,160
they all need to store this data.

00:12:19,160 --> 00:12:20,160
And they're

00:12:20,160 --> 00:12:22,410
kind of hooked up in a weird way because,

00:12:22,410 --> 00:12:25,399
intertubes, mhmm.

00:12:25,399 --> 00:12:27,790
So the data has to replicate between the data

00:12:27,790 --> 00:12:31,430
centers like this, OK.

00:12:31,430 --> 00:12:32,540
This is, this is not

00:12:32,540 --> 00:12:38,560
an uncommon situation with big data.

00:12:38,560 --> 00:12:41,390
This can be done with the SQL database, but

00:12:41,390 --> 00:12:43,840
it would kind of be a pain in the

00:12:43,840 --> 00:12:46,680
ass so far, right, to set up the load

00:12:46,680 --> 00:12:49,310
balancers and figure out the replication strategies.

00:12:49,310 --> 00:12:52,740
Anyway, let's make it a little bit more interesting.

00:12:52,740 --> 00:12:54,670
So what else could happen?

00:12:54,670 --> 00:12:55,960
Well, the CDC knows

00:12:55,960 --> 00:12:58,410
that this could happen, right.

00:12:58,410 --> 00:12:59,410
The CDC is not

00:12:59,410 --> 00:13:02,649
yet immune to the acute zombielepsy.

00:13:02,649 --> 00:13:03,649
So there could

00:13:03,649 --> 00:13:06,630
be a scenario in which we lose data centers.

00:13:06,630 --> 00:13:09,220
I know what you're thinking - this never happens,

00:13:09,220 --> 00:13:10,220
right.

00:13:10,220 --> 00:13:15,720
The whole East coast never goes down.

00:13:15,720 --> 00:13:18,200
So if that happens, then we lose those connections.

00:13:18,200 --> 00:13:22,220
But, you know, if the human race is to

00:13:22,220 --> 00:13:24,460
survive, we can't just ignore these guys out here.

00:13:24,460 --> 00:13:27,800
They have to be able to continue to accept

00:13:27,800 --> 00:13:30,030
reads and writes.

00:13:30,030 --> 00:13:33,450
And this is one of the stricter definitions of

00:13:33,450 --> 00:13:35,850
high availability, which is that if you can connect

00:13:35,850 --> 00:13:38,310
to any part of the system, any part of

00:13:38,310 --> 00:13:42,730
the database, it will accept reads and writes.

00:13:42,730 --> 00:13:43,990
OK,

00:13:43,990 --> 00:13:46,870
it'll serve you whatever data it has access to,

00:13:46,870 --> 00:13:49,910
and if you write data, it will contain, it

00:13:49,910 --> 00:13:53,520
will take it.

00:13:53,520 --> 00:13:55,660
That's very difficult to do with the SQL database.

00:13:55,660 --> 00:13:58,110
SQL databases just aren't designed to do that sort

00:13:58,110 --> 00:13:59,110
of thing.

00:13:59,110 --> 00:14:01,370
But a lot of the other databases are.

00:14:01,370 --> 00:14:06,900
OK, so this is, this is getting kind of

00:14:06,900 --> 00:14:08,180
interesting.

00:14:08,180 --> 00:14:09,510
So let's take another, a closer look at

00:14:09,510 --> 00:14:13,589
that database.

00:14:13,589 --> 00:14:19,029
Well, it's big.

00:14:19,029 --> 00:14:23,080
We're storing DNA, right, so that's about, your genome,

00:14:23,080 --> 00:14:24,560
well, I don't know about yours.

00:14:24,560 --> 00:14:25,560
Everybody else's genome

00:14:25,560 --> 00:14:29,770
is about 1.5 gigabytes per person.

00:14:29,770 --> 00:14:31,730
So 1.5 gigs,

00:14:31,730 --> 00:14:33,220
that's getting to be a large database.

00:14:33,220 --> 00:14:34,220
It won't

00:14:34,220 --> 00:14:35,220
fit on one server.

00:14:35,220 --> 00:14:36,870
So we're gonna have to store it on several

00:14:36,870 --> 00:14:38,710
servers.

00:14:38,710 --> 00:14:42,860
Again, other databases are designed to do this.

00:14:42,860 --> 00:14:43,860
They

00:14:43,860 --> 00:14:46,080
will automatically do one of two things.

00:14:46,080 --> 00:14:47,080
They'll either

00:14:47,080 --> 00:14:50,650
have a logical router that knows by looking at

00:14:50,650 --> 00:14:53,510
the key, where the data's supposed to be stored,

00:14:53,510 --> 00:14:55,649
or they have some sort of meta data server

00:14:55,649 --> 00:14:58,450
that keeps track of where all of the object

00:14:58,450 --> 00:14:59,670
and the database are stored.

00:14:59,670 --> 00:15:00,670
Those are the two

00:15:00,670 --> 00:15:05,350
major paradigms for how a distributed database stores data.

00:15:05,350 --> 00:15:08,630
And this also has to be fault tolerant.

00:15:08,630 --> 00:15:13,230
Let me just put a definition on that phrase,

00:15:13,230 --> 00:15:14,230
fault tolerant.

00:15:14,230 --> 00:15:17,220
That's the optimistic view that stuff is

00:15:17,220 --> 00:15:20,670
gonna happen, that bad stuff is gonna happen.

00:15:20,670 --> 00:15:21,670
Optimistically,

00:15:21,670 --> 00:15:24,130
if you have a fault tolerant system, you're expecting

00:15:24,130 --> 00:15:25,890
bad things to happen.

00:15:25,890 --> 00:15:27,910
So in this case, server's

00:15:27,910 --> 00:15:28,950
gonna die.

00:15:28,950 --> 00:15:30,340
It's gonna catch on fire.

00:15:30,340 --> 00:15:31,540
The barings in the

00:15:31,540 --> 00:15:33,510
harddrive are gonna dip, the rate is gonna dive

00:15:33,510 --> 00:15:36,000
- something, something's gonna happen and a server's gonna

00:15:36,000 --> 00:15:37,000
die.

00:15:37,000 --> 00:15:39,850
And in a fault tolerant system, that's OK.

00:15:39,850 --> 00:15:40,850
It

00:15:40,850 --> 00:15:41,940
continues to run.

00:15:41,940 --> 00:15:46,300
In some cases worse, a cable

00:15:46,300 --> 00:15:47,300
comes unplugged.

00:15:47,300 --> 00:15:48,730
You know, zombies get into the data

00:15:48,730 --> 00:15:51,200
center, chasing the ops guys and trip over a

00:15:51,200 --> 00:15:52,200
cable, right.

00:15:52,200 --> 00:15:53,200
And so now we've got part of

00:15:53,200 --> 00:15:55,410
the cluster is connected and another part of the

00:15:55,410 --> 00:15:58,330
cluster is not connected, OK.

00:15:58,330 --> 00:16:01,890
Again, I'll leave time for questions - we can

00:16:01,890 --> 00:16:04,730
talk more about how databases have different strategies of

00:16:04,730 --> 00:16:09,480
dealing with fault tolerance and replication and anti-entropy -

00:16:09,480 --> 00:16:16,790
entropy being when data sets get out of sync.

00:16:16,790 --> 00:16:19,190
But let's continue talking about the requirements.

00:16:19,190 --> 00:16:20,190
OK.

00:16:20,190 --> 00:16:23,740
So we're gonna store this as key/value data model,

00:16:23,740 --> 00:16:27,890
thank you mister, or CDC person.

00:16:27,890 --> 00:16:28,890
So this is

00:16:28,890 --> 00:16:31,310
the value - we need a key.

00:16:31,310 --> 00:16:35,270
Well, fortunately they have a system for establishing a

00:16:35,270 --> 00:16:39,170
UUID for a key, so in this case it'll

00:16:39,170 --> 00:16:40,370
be patient0.

00:16:40,370 --> 00:16:41,560
When we want to look up this

00:16:41,560 --> 00:16:45,600
data, we give the system patient0, and it gives

00:16:45,600 --> 00:16:47,860
us back the data that we need to, to

00:16:47,860 --> 00:16:50,350
do research on.

00:16:50,350 --> 00:16:52,769
And CDC person says, oh, and also I want

00:16:52,769 --> 00:16:55,290
to sometimes look it up by zip code.

00:16:55,290 --> 00:16:56,290
I

00:16:56,290 --> 00:16:58,170
want all of the zombies in a given zip

00:16:58,170 --> 00:16:59,320
code.

00:16:59,320 --> 00:17:00,480
OK.

00:17:00,480 --> 00:17:03,589
A strict key value doesn't have a second

00:17:03,589 --> 00:17:05,679
way of looking things up.

00:17:05,679 --> 00:17:06,679
So here's where we

00:17:06,679 --> 00:17:10,350
have to start consider, considering data modeling.

00:17:10,350 --> 00:17:11,350
We can

00:17:11,350 --> 00:17:14,100
always look this record up by the key patient0,

00:17:14,100 --> 00:17:15,100
that makes sense.

00:17:15,100 --> 00:17:16,100
How do we look it up

00:17:16,100 --> 00:17:18,939
by 33436, that zip code?

00:17:18,939 --> 00:17:21,360
Well, if we've got the data on a bunch

00:17:21,360 --> 00:17:25,530
of servers, right, the zombie data comes in, we

00:17:25,530 --> 00:17:27,209
store it on one machine - in this case,

00:17:27,209 --> 00:17:28,970
the upper right machine.

00:17:28,970 --> 00:17:31,210
And the system knows that

00:17:31,210 --> 00:17:36,000
patient0 key points to that machine.

00:17:36,000 --> 00:17:37,000
So that's how

00:17:37,000 --> 00:17:40,540
it knows to get that data.

00:17:40,540 --> 00:17:44,750
But say we have these three zombies in that

00:17:44,750 --> 00:17:46,080
zip code.

00:17:46,080 --> 00:17:47,400
We don't have a way of asking

00:17:47,400 --> 00:17:51,500
key value system how to find those three zombies

00:17:51,500 --> 00:17:53,560
who are in the zip code.

00:17:53,560 --> 00:17:57,980
The solution is to create an inverted index.

00:17:57,980 --> 00:17:58,980
This

00:17:58,980 --> 00:18:02,260
is an inverted index because a field from the

00:18:02,260 --> 00:18:06,040
data in the value of the object is pointing

00:18:06,040 --> 00:18:09,430
back to the objects that contain it.

00:18:09,430 --> 00:18:10,430
So that's

00:18:10,430 --> 00:18:11,720
the inversion.

00:18:11,720 --> 00:18:13,880
And the index is really simple, in this case,

00:18:13,880 --> 00:18:15,850
we'll just say, hey, and object with a key

00:18:15,850 --> 00:18:20,680
zip underscore 33436 contains the objects patient0, patient45, and

00:18:20,680 --> 00:18:25,260
patient3924.

00:18:25,260 --> 00:18:28,640
We're getting more zombies here.

00:18:28,640 --> 00:18:30,990
OK.

00:18:30,990 --> 00:18:35,870
So how do we store that index?

00:18:35,870 --> 00:18:39,490
We know that this is zip object should point

00:18:39,490 --> 00:18:42,920
to those three zombie values.

00:18:42,920 --> 00:18:43,920
So if we represent

00:18:43,920 --> 00:18:47,121
that index as this green star thing, where do

00:18:47,121 --> 00:18:48,360
we put it?

00:18:48,360 --> 00:18:51,430
We have two options.

00:18:51,430 --> 00:18:53,730
One is, when the zombie object comes into the

00:18:53,730 --> 00:18:58,470
system, we save the index on the same machine

00:18:58,470 --> 00:19:00,240
with that document.

00:19:00,240 --> 00:19:02,480
This is called document based inverted

00:19:02,480 --> 00:19:05,460
indexing, because we're partitioning the index with the document,

00:19:05,460 --> 00:19:08,440
the object that we're indexing.

00:19:08,440 --> 00:19:13,010
So as time goes on, we now have an

00:19:13,010 --> 00:19:18,760
index for zip 33, 33436, on the upper right

00:19:18,760 --> 00:19:21,320
machine, and on this lower left machine, because those

00:19:21,320 --> 00:19:23,500
all have zombies in that zip code.

00:19:23,500 --> 00:19:27,270
OK, let's think about the performance implications here.

00:19:27,270 --> 00:19:28,270
We

00:19:28,270 --> 00:19:32,620
save an object, the system locally indexes it, and

00:19:32,620 --> 00:19:35,090
saves that index locally.

00:19:35,090 --> 00:19:38,660
Super efficient for a write,

00:19:38,660 --> 00:19:40,130
right.

00:19:40,130 --> 00:19:41,750
Save the object, index it yourself.

00:19:41,750 --> 00:19:42,840
OK, that's easily

00:19:42,840 --> 00:19:43,840
done.

00:19:43,840 --> 00:19:44,910
Now how do we read it?

00:19:44,910 --> 00:19:47,080
Well we have to go to each of the

00:19:47,080 --> 00:19:49,600
machines and say, you know, top one - do

00:19:49,600 --> 00:19:50,990
you have anybody in that zip?

00:19:50,990 --> 00:19:51,990
Nope.

00:19:51,990 --> 00:19:52,990
Second one

00:19:52,990 --> 00:19:53,990
- yup, I've got these two guys.

00:19:53,990 --> 00:19:54,990
OK.

00:19:54,990 --> 00:19:55,990
Nope.

00:19:55,990 --> 00:19:56,990
Yup, one.

00:19:56,990 --> 00:19:57,990
Nope.

00:19:57,990 --> 00:19:58,990
And then we put together

00:19:58,990 --> 00:19:59,990
the results in one answer.

00:19:59,990 --> 00:20:00,990
That was a really

00:20:00,990 --> 00:20:03,410
inefficient read, right.

00:20:03,410 --> 00:20:04,580
But that's, but it was inefficient

00:20:04,580 --> 00:20:05,580
right.

00:20:05,580 --> 00:20:07,610
SO that's one way to do it.

00:20:07,610 --> 00:20:09,530
Another way to do it is a zombie comes

00:20:09,530 --> 00:20:13,740
in, we index them before we save them, and

00:20:13,740 --> 00:20:16,831
then we save the index someplace else, a specific

00:20:16,831 --> 00:20:18,860
place in the cluster.

00:20:18,860 --> 00:20:20,110
OK, this is called term

00:20:20,110 --> 00:20:21,530
based inverted index.

00:20:21,530 --> 00:20:22,790
So it's a different partitioning scheme

00:20:22,790 --> 00:20:23,790
for the index.

00:20:23,790 --> 00:20:24,970
We're partitioning by the term that

00:20:24,970 --> 00:20:27,650
we're searching on.

00:20:27,650 --> 00:20:28,919
More zombies come in.

00:20:28,919 --> 00:20:30,730
And it's always updating that

00:20:30,730 --> 00:20:33,860
same object, which is someplace else in the cluster.

00:20:33,860 --> 00:20:37,450
So let's think about the performance profile of this.

00:20:37,450 --> 00:20:39,630
For every zombie value that we write to the

00:20:39,630 --> 00:20:42,590
database, we have to fetch the index from some

00:20:42,590 --> 00:20:45,471
place else, add to it, and write to it

00:20:45,471 --> 00:20:47,390
and save it back.

00:20:47,390 --> 00:20:48,750
So that's an inefficient write

00:20:48,750 --> 00:20:51,340
pattern, but now look at the read.

00:20:51,340 --> 00:20:52,340
When we

00:20:52,340 --> 00:20:53,410
want to know who's in that zip, we only

00:20:53,410 --> 00:20:59,450
have to read from one machine.

00:20:59,450 --> 00:21:00,540
So these are the two.

00:21:00,540 --> 00:21:02,290
We got document-based inverted

00:21:02,290 --> 00:21:04,929
index and term-based inverted index.

00:21:04,929 --> 00:21:05,929
These are the two

00:21:05,929 --> 00:21:09,420
paradigms for inverted indexes that we've considered.

00:21:09,420 --> 00:21:13,530
Again, document-based: fast read - fast write, inefficient read.

00:21:13,530 --> 00:21:16,200
And term-based inverted index has a fast read but

00:21:16,200 --> 00:21:18,450
an inefficient write.

00:21:18,450 --> 00:21:21,210
The point being that, when we look at the

00:21:21,210 --> 00:21:26,179
use case, that's what should determine how we model

00:21:26,179 --> 00:21:28,419
the data.

00:21:28,419 --> 00:21:31,720
We have to understand from the CDC person, is

00:21:31,720 --> 00:21:34,640
this data gonna be written a lot, this index?

00:21:34,640 --> 00:21:36,490
Or is it gonna be read a lot?

00:21:36,490 --> 00:21:37,490
OK.

00:21:37,490 --> 00:21:41,010
It's a much different way of looking at

00:21:41,010 --> 00:21:44,130
the problem than using a relational database, where we

00:21:44,130 --> 00:21:48,890
just would have indexed that as a separate thing,

00:21:48,890 --> 00:21:52,020
as a secondary index in a relational database.

00:21:52,020 --> 00:21:56,070
So, consider- it's an important distinction in this kind

00:21:56,070 --> 00:21:59,290
of thing, and if you like charts, I'll link

00:21:59,290 --> 00:22:03,030
to some charts later that show some comparisons that

00:22:03,030 --> 00:22:07,070
we did between different distributed databases and the way

00:22:07,070 --> 00:22:12,929
that, or different partitioning schemes in a distributed database.

00:22:12,929 --> 00:22:16,100
So back to zombies.

00:22:16,100 --> 00:22:18,350
Because these guys haven't stopped eating brains yet.

00:22:18,350 --> 00:22:21,890
All right, so in this scenario, where we've got

00:22:21,890 --> 00:22:26,020
two data centers down, three are still up, two

00:22:26,020 --> 00:22:27,790
are connected.

00:22:27,790 --> 00:22:32,799
Consider the situation where data comes in

00:22:32,799 --> 00:22:39,540
to the top data center, writing to record patient0.

00:22:39,540 --> 00:22:42,380
And somebody down in Southern California also writes data

00:22:42,380 --> 00:22:48,690
to patient0.

00:22:48,690 --> 00:22:52,710
How would you handle this in a SQL database?

00:22:52,710 --> 00:22:54,380
Let's make the problem worse.

00:22:54,380 --> 00:22:56,720
Then because, you know,

00:22:56,720 --> 00:23:00,170
the crisis is happening, somebody runs along cable between

00:23:00,170 --> 00:23:02,280
those two data centers, and connects them and so

00:23:02,280 --> 00:23:04,100
now they have to replicate their data with each

00:23:04,100 --> 00:23:08,650
other.

00:23:08,650 --> 00:23:11,030
How do we reconcile these two different versions of

00:23:11,030 --> 00:23:12,650
patient0?

00:23:12,650 --> 00:23:17,190
First, first attempt might be, OK, let's take the

00:23:17,190 --> 00:23:20,970
one with the last time stamp on it.

00:23:20,970 --> 00:23:21,970
Two

00:23:21,970 --> 00:23:22,970
problems with that.

00:23:22,970 --> 00:23:24,190
One, obviously, you might lose data.

00:23:24,190 --> 00:23:28,020
Two, time stamps in a distributed system are entirely

00:23:28,020 --> 00:23:31,210
unreliable, OK.

00:23:31,210 --> 00:23:32,710
If you want to sync your clocks in a

00:23:32,710 --> 00:23:35,860
distributed system, that's a particular kind of pain that

00:23:35,860 --> 00:23:40,440
I just wouldn't want to get into.

00:23:40,440 --> 00:23:45,840
So in the simplest case, we have a system

00:23:45,840 --> 00:23:49,270
that has what are called siblings for that particular

00:23:49,270 --> 00:23:52,049
key/value object.

00:23:52,049 --> 00:23:55,580
And basically the system would get two

00:23:55,580 --> 00:23:57,799
versions of data and just say, oh, I don't

00:23:57,799 --> 00:23:59,559
know which is which, so I'm just gonna store

00:23:59,559 --> 00:24:01,230
both.

00:24:01,230 --> 00:24:02,230
And then when you go to read it,

00:24:02,230 --> 00:24:03,780
it says, well I've got this value and this

00:24:03,780 --> 00:24:05,180
value.

00:24:05,180 --> 00:24:08,000
These siblings.

00:24:08,000 --> 00:24:09,410
Here.

00:24:09,410 --> 00:24:10,730
And at the application level, we can do a

00:24:10,730 --> 00:24:11,900
couple things with that, right.

00:24:11,900 --> 00:24:13,080
In the simplest case,

00:24:13,080 --> 00:24:15,460
none of the data overlaps.

00:24:15,460 --> 00:24:16,460
So we can just

00:24:16,460 --> 00:24:18,140
combine them, right.

00:24:18,140 --> 00:24:20,559
None of that data overlaps.

00:24:20,559 --> 00:24:21,780
None of it overwrote

00:24:21,780 --> 00:24:23,350
it, so we just combined them.

00:24:23,350 --> 00:24:24,360
What if that's not the case?

00:24:24,360 --> 00:24:25,360
Well then we

00:24:25,360 --> 00:24:26,360
can do a couple things.

00:24:26,360 --> 00:24:27,360
We can write our

00:24:27,360 --> 00:24:28,360
own policy.

00:24:28,360 --> 00:24:30,000
We could just present both versions to

00:24:30,000 --> 00:24:32,299
CDC person on screen, and say I don't know

00:24:32,299 --> 00:24:34,620
- you pick, right.

00:24:34,620 --> 00:24:36,731
This is a problem that I didn't have to

00:24:36,731 --> 00:24:39,620
think about as an engineer with the SQL database,

00:24:39,620 --> 00:24:41,380
because it was impossible to have siblings in a

00:24:41,380 --> 00:24:43,640
SQL database.

00:24:43,640 --> 00:24:49,669
But with this highly available, huge fault tolerant database,

00:24:49,669 --> 00:24:51,490
this kind of stuff has to be considered.

00:24:51,490 --> 00:24:55,630
There's a whole field of research into what are

00:24:55,630 --> 00:25:00,380
called CRDT, commative or convergent replicated data types, that

00:25:00,380 --> 00:25:06,230
specifically analyzes the, the, specifies the kinds of data

00:25:06,230 --> 00:25:12,490
structures that you can build that you can automatically

00:25:12,490 --> 00:25:16,910
converge into one value without human intervention, right, without

00:25:16,910 --> 00:25:21,250
any side effects or conflicts.

00:25:21,250 --> 00:25:23,200
And that's an on-going field of study.

00:25:23,200 --> 00:25:24,200
We don't,

00:25:24,200 --> 00:25:26,330
we haven't, like, numerated all of the possible data

00:25:26,330 --> 00:25:28,570
types that we can do that for.

00:25:28,570 --> 00:25:29,570
I'll give

00:25:29,570 --> 00:25:34,410
you an example of one simple one.

00:25:34,410 --> 00:25:40,240
Think of an array that has unique values and

00:25:40,240 --> 00:25:42,300
only grows.

00:25:42,300 --> 00:25:43,380
It only gets bigger.

00:25:43,380 --> 00:25:44,380
YOu never remove

00:25:44,380 --> 00:25:45,410
a value from it.

00:25:45,410 --> 00:25:46,410
This is kind of the

00:25:46,410 --> 00:25:48,820
simplest case for CRDT.

00:25:48,820 --> 00:25:50,060
So say up in the

00:25:50,060 --> 00:25:54,720
north west, we had somebody write this object with

00:25:54,720 --> 00:25:59,630
patient0, 45, 3924, and in the southwest, we had

00:25:59,630 --> 00:26:03,440
somebody write this object that the zip index with

00:26:03,440 --> 00:26:08,520
patient73 and 9217.

00:26:08,520 --> 00:26:10,540
If we want to combine these two, since we

00:26:10,540 --> 00:26:14,090
know none of those objects can ever be taken

00:26:14,090 --> 00:26:17,350
out, we can simply add them all together into

00:26:17,350 --> 00:26:21,090
the list and call unique on it, right.

00:26:21,090 --> 00:26:22,090
Problem

00:26:22,090 --> 00:26:23,090
solved.

00:26:23,090 --> 00:26:26,270
What if you were gonna allow items to be

00:26:26,270 --> 00:26:27,270
removed.

00:26:27,270 --> 00:26:31,240
Problem gets a lot more difficult.

00:26:31,240 --> 00:26:33,600
And that's a whole other area of research that,

00:26:33,600 --> 00:26:35,500
again, is very interesting.

00:26:35,500 --> 00:26:36,500
Other topics - I want

00:26:36,500 --> 00:26:38,650
to take some questions, so I won't get into

00:26:38,650 --> 00:26:39,880
this too much, but.

00:26:39,880 --> 00:26:41,660
Other research topics with distributed

00:26:41,660 --> 00:26:45,830
systems: GeoHashes, right.

00:26:45,830 --> 00:26:50,860
If you want to store longitutde

00:26:50,860 --> 00:26:53,809
and latitude for an object, and then you want

00:26:53,809 --> 00:26:56,230
to know, hey, find me all of the things

00:26:56,230 --> 00:27:01,460
that are within a mile, if that's on one

00:27:01,460 --> 00:27:05,059
computer, we have algorithms that do that.

00:27:05,059 --> 00:27:06,870
What if you're trying to contain that data set

00:27:06,870 --> 00:27:09,049
on many computers?

00:27:09,049 --> 00:27:10,330
That becomes a much more difficult

00:27:10,330 --> 00:27:12,910
problem, because you can't just ask one computer, give

00:27:12,910 --> 00:27:15,640
me all the thigns within a mile, because some

00:27:15,640 --> 00:27:17,770
of those things might be on another computer.

00:27:17,770 --> 00:27:18,770
So

00:27:18,770 --> 00:27:20,840
what do you do, ask all of the computers?

00:27:20,840 --> 00:27:22,020
That's an inefficient read.

00:27:22,020 --> 00:27:23,539
A lot of interesting research

00:27:23,539 --> 00:27:27,650
going on there, and acid transactions.

00:27:27,650 --> 00:27:28,650
The 'I' is

00:27:28,650 --> 00:27:30,730
lowercase on purpose.

00:27:30,730 --> 00:27:34,700
So in a highly available system, you know a

00:27:34,700 --> 00:27:40,840
couple years ago people - I was asked, can

00:27:40,840 --> 00:27:43,679
you have acid compliant transactions on top of a

00:27:43,679 --> 00:27:46,720
highly available system, and the general consensus was no

00:27:46,720 --> 00:27:51,110
- as little as two years ago.

00:27:51,110 --> 00:27:53,700
Now, we know that that's not the case.

00:27:53,700 --> 00:27:54,700
It

00:27:54,700 --> 00:27:57,419
turns out that the 'i' in ACiD actually means

00:27:57,419 --> 00:27:58,820
a lot of things.

00:27:58,820 --> 00:28:00,570
And in a sequel database,

00:28:00,570 --> 00:28:05,820
you probably think it means that one transaction starts,

00:28:05,820 --> 00:28:10,031
does stuff, stops, and then another one starts, does

00:28:10,031 --> 00:28:13,190
stuff, stops.

00:28:13,190 --> 00:28:15,790
Most SQL databases that we use here - again,

00:28:15,790 --> 00:28:20,350
I'm just making a huge generalization - don't actually

00:28:20,350 --> 00:28:22,870
work that way.

00:28:22,870 --> 00:28:25,070
Or they rely on serialization at

00:28:25,070 --> 00:28:26,920
the resource level to give you that kind of

00:28:26,920 --> 00:28:28,669
result.

00:28:28,669 --> 00:28:31,470
But they have other levels of protection called,

00:28:31,470 --> 00:28:35,230
you know, repeatable reads, or read committed, where, when

00:28:35,230 --> 00:28:40,180
one transaction starts, maybe another one starts, too, and

00:28:40,180 --> 00:28:43,120
does some work before the first one ends.

00:28:43,120 --> 00:28:46,309
OK, by default, a lot of the databases, the

00:28:46,309 --> 00:28:49,320
SQL databases that we use do that.

00:28:49,320 --> 00:28:50,320
That kind

00:28:50,320 --> 00:28:52,750
of transaction, you can build on top of a

00:28:52,750 --> 00:28:55,650
highly available system.

00:28:55,650 --> 00:28:56,650
And you can model your data

00:28:56,650 --> 00:28:59,429
in a way to give you those properties if

00:28:59,429 --> 00:29:05,380
you require them.

00:29:05,380 --> 00:29:10,230
So to sum up, keep calm.

00:29:10,230 --> 00:29:11,230
Always bring a

00:29:11,230 --> 00:29:12,230
towel.

00:29:12,230 --> 00:29:13,230
The fate of the human race depends on

00:29:13,230 --> 00:29:14,230
you.

00:29:14,230 --> 00:29:20,130
Distributed data, distributed databases like this, highly available

00:29:20,130 --> 00:29:24,180
databases, can help you survive the next zombie apocalypse.

00:29:24,180 --> 00:29:26,020
We've all been through them before.

00:29:26,020 --> 00:29:27,020
There's no reason

00:29:27,020 --> 00:29:28,510
for us to expect we won't go through more

00:29:28,510 --> 00:29:30,570
in the future.

00:29:30,570 --> 00:29:36,030
And, I will, again, Tweet links to this, or

00:29:36,030 --> 00:29:37,400
you can just copy it - it's zombies dot

00:29:37,400 --> 00:29:39,960
samples dot basher dot com.

00:29:39,960 --> 00:29:43,780
We have a, an application that uses the data

00:29:43,780 --> 00:29:46,549
modeling that I talked about online.

00:29:46,549 --> 00:29:47,549
It has a

00:29:47,549 --> 00:29:50,230
maps that you can see where the zombies in

00:29:50,230 --> 00:29:54,240
the area are, and it allows you to search

00:29:54,240 --> 00:29:57,290
using those two different indexing methods that I mentioned:

00:29:57,290 --> 00:30:01,750
term based inverted indexing, and document based inverted indexing

00:30:01,750 --> 00:30:04,659
for the zombies in a given zip code.

00:30:04,659 --> 00:30:08,620
You can also search for them by GeoHash.

00:30:08,620 --> 00:30:09,910
There

00:30:09,910 --> 00:30:15,530
is a blog post describing how that's done.

00:30:15,530 --> 00:30:16,530
And

00:30:16,530 --> 00:30:19,240
the code is available in Ruby, and a little

00:30:19,240 --> 00:30:21,780
bit of JavaScript.

00:30:21,780 --> 00:30:23,900
OK.

00:30:23,900 --> 00:30:26,150
And that is my presentation.

00:30:26,150 --> 00:30:27,150
So I would like

00:30:27,150 --> 00:30:30,430
to thank four of my colleagues - Drew Kerrigan,

00:30:30,430 --> 00:30:33,760
Dan Kerrigan, for writing the application that I spoke

00:30:33,760 --> 00:30:34,760
about.

00:30:34,760 --> 00:30:36,110
Nathan Aschbacher for some of the material and

00:30:36,110 --> 00:30:38,980
John Newman for the artwork.

00:30:38,980 --> 00:30:41,010
And I will include

00:30:41,010 --> 00:30:44,570
links to all the things that I just referenced

00:30:44,570 --> 00:30:48,860
there in Twitter, shortly.

00:30:48,860 --> 00:30:50,720
So my time is up.

00:30:50,720 --> 00:30:52,830
Find me in the

00:30:52,830 --> 00:30:53,830
halls.

00:30:53,830 --> 00:30:54,010

YouTube URL: https://www.youtube.com/watch?v=iEkeDp70jvo


