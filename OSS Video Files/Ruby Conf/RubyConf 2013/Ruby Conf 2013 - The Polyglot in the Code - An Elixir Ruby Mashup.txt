Title: Ruby Conf 2013 - The Polyglot in the Code - An Elixir Ruby Mashup
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Johnny Winn

As programmers, change is our only constant. Whether it's innovations in our current stack or the emergence of new languages and frameworks, there is always a new technology to explore. For many of us, that is one of the reasons we were drawn to programming. There is a profound curiosity that drives us and it's that curiosity that can lead to a Polyglot lifestyle. However, just knowing multiple languages isn't enough to claim a Polyglot lifestyle, one must actually utilize their skills. A great example is using one language to explore another. Because of it's flexibility and dynamic nature, Ruby is a great fit for this role. But where to start? In this talk we are going to explore the new functional language Elixir by using Ruby to fill in the gaps. We will look at how Ruby can be used in conjunction with the primary language to handle some of the secondary tasks seamlessly. If your interested in propagating your polyglot potential, join me in embracing Polyglot lifestyle.

Help us caption & translate this video!

http://amara.org/v/FG5E/
Captions: 
	00:00:16,000 --> 00:00:19,800
JOHNNY WINN: That's good. So I hear you guys want a talk,

00:00:19,849 --> 00:00:21,310
not just watch me stand up here, so.

00:00:21,310 --> 00:00:23,419
We're gonna kind of get going. How about that?

00:00:23,419 --> 00:00:25,150
My name is Johnny Winn. I work at Hash

00:00:25,150 --> 00:00:28,579
Rocket in Jacksonville Beach, Florida. You can hit me

00:00:28,579 --> 00:00:31,800
up on Twitter at johnny underscore rugger. The rugger

00:00:31,800 --> 00:00:34,190
is from rugby. A lot of people kind of

00:00:34,190 --> 00:00:35,250
get me like I didn't know how to spell

00:00:35,250 --> 00:00:40,640
Ruby. But, no, it's actually rugger. Rugby.

00:00:40,640 --> 00:00:42,240
Before we begin, I wanna tell you a few

00:00:42,240 --> 00:00:45,280
tidbits about myself that might help you understand some

00:00:45,280 --> 00:00:49,190
of my motivations behind this talk. But also maybe

00:00:49,190 --> 00:00:52,110
drum up some sympathy for me.

00:00:52,110 --> 00:00:54,740
So I'm married to this brilliant woman with a

00:00:54,740 --> 00:00:57,620
degree in education. That's not the part I need

00:00:57,620 --> 00:01:04,220
sympathy about. Together we have seven kids. Yes. Seven

00:01:04,220 --> 00:01:08,140
kids. All of which are homeschooled, because we like

00:01:08,140 --> 00:01:12,270
torture even more. And three of them are still

00:01:12,270 --> 00:01:14,070
being homeschooled right now.

00:01:14,070 --> 00:01:16,439
Needless to say, we spend a great deal of

00:01:16,439 --> 00:01:19,950
time working on teaching methodologies, because we want to

00:01:19,950 --> 00:01:21,520
make sure that we're doing the best things when

00:01:21,520 --> 00:01:24,280
it comes to educating them. So we want to

00:01:24,280 --> 00:01:27,060
try to understand the learning process and like what

00:01:27,060 --> 00:01:29,840
goes on as a child actually grows up.

00:01:29,840 --> 00:01:32,009
And a lot of that can actually come back

00:01:32,009 --> 00:01:34,770
and help us as adults. Almost all the time,

00:01:34,770 --> 00:01:37,450
these, these things that I learn about teaching methodologies

00:01:37,450 --> 00:01:40,840
transcends into my everyday work, work habits.

00:01:40,840 --> 00:01:42,479
Maybe.

00:01:42,479 --> 00:01:49,479
All right. You might be asking yourself why. Well,

00:01:57,270 --> 00:01:59,619
why am I sharing this with you? Well, in

00:01:59,619 --> 00:02:03,819
part because there's some hitting messages in my talk.

00:02:03,819 --> 00:02:06,039
I want to actually spark some of that curiosity

00:02:06,039 --> 00:02:08,439
that brought a lot of us into programming. I

00:02:08,439 --> 00:02:09,840
think a lot of us find ourselves in a

00:02:09,840 --> 00:02:12,709
particular area of expertise and we don't really want

00:02:12,709 --> 00:02:16,370
to venture out of that. Sometimes it's, it's for

00:02:16,370 --> 00:02:18,980
various reasons. Sometimes it's because you don't feel comfortable.

00:02:18,980 --> 00:02:20,430
Sometimes you're, you're not sure, you don't want to

00:02:20,430 --> 00:02:24,470
tread into, to new waters.

00:02:24,470 --> 00:02:26,299
But that's what brought most of us to programming

00:02:26,299 --> 00:02:29,170
anyway. So I want to, I want to instill

00:02:29,170 --> 00:02:31,209
some of our, I want to spark some of

00:02:31,209 --> 00:02:33,840
that curiosity. But it's one thing to be curious.

00:02:33,840 --> 00:02:37,000
But sometimes we need direction in our efforts so

00:02:37,000 --> 00:02:41,220
that it doesn't seem wasted.

00:02:41,220 --> 00:02:44,700
Relating stories about my kids to what I actually

00:02:44,700 --> 00:02:47,379
do actually helps bring a lot of insight in

00:02:47,379 --> 00:02:51,260
how we learn as adults. Plus, what's more entertaining

00:02:51,260 --> 00:02:54,909
that hearing stories about a stranger's kids, right?

00:02:54,909 --> 00:03:00,040
Pictures of sto- of strangers' kids! Yes. A long

00:03:00,040 --> 00:03:02,290
time ago I actually had kids this small. That's

00:03:02,290 --> 00:03:05,599
my second to youngest there, stirring. This isn't actually

00:03:05,599 --> 00:03:08,239
the picture that I wanted. Cause the picture that

00:03:08,239 --> 00:03:09,180
I wanted is the one that I had in

00:03:09,180 --> 00:03:11,120
my head, and most parents know you have the

00:03:11,120 --> 00:03:13,599
pictures in your head much better.

00:03:13,599 --> 00:03:16,439
But as they were younger, they would actually go

00:03:16,439 --> 00:03:21,900
into the kitchen and experiment by cooking. As a

00:03:21,900 --> 00:03:22,829
dad, most of the time I just kind of

00:03:22,829 --> 00:03:25,659
saw it as making a mess. My wife, of

00:03:25,659 --> 00:03:29,150
course, looked at everything as a learning experience and

00:03:29,150 --> 00:03:31,299
tried to convince me of that.

00:03:31,299 --> 00:03:33,269
But they didn't actually understand anything that they were

00:03:33,269 --> 00:03:36,400
doing. They just kind of threw things together and,

00:03:36,400 --> 00:03:38,030
as you can imagine it becomes a hodge podge

00:03:38,030 --> 00:03:41,579
of just, this that and the other and, well,

00:03:41,579 --> 00:03:43,010
a mess.

00:03:43,010 --> 00:03:47,250
But they didn't get frustrated.

00:03:47,250 --> 00:03:50,010
When learning, it's important to tap into those, the,

00:03:50,010 --> 00:03:52,790
the prior knowledge that we've gained. Like, my kids,

00:03:52,790 --> 00:03:55,109
all of us at one point in time were

00:03:55,109 --> 00:03:57,609
novices. We were fumbling around to some degree or

00:03:57,609 --> 00:03:59,599
another until we kind of found something that we

00:03:59,599 --> 00:04:02,150
would relate to, we could relate to. And that

00:04:02,150 --> 00:04:07,890
helped ease our transition into understanding.

00:04:07,890 --> 00:04:11,650
Those same tools, we can take advantage of.

00:04:11,650 --> 00:04:16,060
An education, the theory of constructivism, states that knowledge

00:04:16,060 --> 00:04:19,380
is constructed, not acquired. That being said, that means

00:04:19,380 --> 00:04:22,090
that everything that we do, we actually can take

00:04:22,090 --> 00:04:24,130
and build on the next thing with. It's not

00:04:24,130 --> 00:04:26,120
just one day you wake up and you know

00:04:26,120 --> 00:04:28,720
Ruby. You actually have built things along the way

00:04:28,720 --> 00:04:31,169
that have helped you grow.

00:04:31,169 --> 00:04:34,100
This seems obvious from an evolutionary standpoint, when you

00:04:34,100 --> 00:04:35,759
think about it. If you're trying to figure out

00:04:35,759 --> 00:04:38,539
how to light a fire and you successfully do

00:04:38,539 --> 00:04:40,360
it, do you really care about the hundred ways

00:04:40,360 --> 00:04:43,110
that it failed? Or the one that you got

00:04:43,110 --> 00:04:44,819
it right?

00:04:44,819 --> 00:04:47,699
Keeping that, keeping that knowledge is sometimes good enough

00:04:47,699 --> 00:04:51,199
to get us to move forward.

00:04:51,199 --> 00:04:56,000
This brings us to scaffolding. Ironically, scaffolding theory has

00:04:56,000 --> 00:05:00,220
nothing to do with Rails apps. But it's actually

00:05:00,220 --> 00:05:04,539
a theory that emerged as the predominate, predominate acquisition

00:05:04,539 --> 00:05:08,849
of language in English as a second language students.

00:05:08,849 --> 00:05:10,400
What they found is that if they give the

00:05:10,400 --> 00:05:13,199
students something that they kind of know, so that

00:05:13,199 --> 00:05:15,770
they don't have to worry about, it makes the

00:05:15,770 --> 00:05:20,590
progression, the new language even easier. So this makes

00:05:20,590 --> 00:05:23,150
sense, right. If you're not worried about the things

00:05:23,150 --> 00:05:25,830
that you don't have or you don't know, because

00:05:25,830 --> 00:05:27,860
you can count on something, it's easier to move

00:05:27,860 --> 00:05:31,990
forward.

00:05:31,990 --> 00:05:34,220
This is all great stuff. But now you're probably

00:05:34,220 --> 00:05:38,509
thinking, what does this have to do with programming?

00:05:38,509 --> 00:05:39,599
Or even better, what does it have to do

00:05:39,599 --> 00:05:41,830
with being a polyglot?

00:05:41,830 --> 00:05:43,830
So it's inevitable new languages, they're gonna come and

00:05:43,830 --> 00:05:46,490
they're gonna go. You can either stay with your

00:05:46,490 --> 00:05:49,020
old language, or you can move forward into new

00:05:49,020 --> 00:05:52,229
languages. Not every language you explore, you have to

00:05:52,229 --> 00:05:54,830
become the next thing. Sometimes you just learn it

00:05:54,830 --> 00:05:59,039
to bring something back to your core language.

00:05:59,039 --> 00:06:00,919
And because learning a new language doesn't mean we

00:06:00,919 --> 00:06:04,990
have to abandon our old. Now, using one language

00:06:04,990 --> 00:06:07,680
to learn another language is part of the polyglot

00:06:07,680 --> 00:06:12,280
lifestyle.

00:06:12,280 --> 00:06:15,389
So how do you live that polyglot lifestyle? Many

00:06:15,389 --> 00:06:17,940
of you, probably, I guarantee, know at least one

00:06:17,940 --> 00:06:22,419
or two languages, if not more. Ruby, JavaScript, possibly

00:06:22,419 --> 00:06:26,199
some CoffeeScript. SQL, at least, I bet you this

00:06:26,199 --> 00:06:29,259
room covers that.

00:06:29,259 --> 00:06:32,539
But the line isn't just about multiple language and

00:06:32,539 --> 00:06:34,949
a lifestyle. It's about how you take advantage of

00:06:34,949 --> 00:06:38,550
those languages. And using it, using one language to

00:06:38,550 --> 00:06:41,660
learn another is an example of this. And for

00:06:41,660 --> 00:06:44,220
that, I say, you're all lucky, because you're Rubyists.

00:06:44,220 --> 00:06:48,860
Ruby is a flexible and dynamic tool that lends

00:06:48,860 --> 00:06:52,500
itself well to bridging gaps between languages. You can

00:06:52,500 --> 00:06:56,009
actually scaffold around another language to help ease some

00:06:56,009 --> 00:07:01,220
of the transition. So today, we're gonna go over

00:07:01,220 --> 00:07:02,800
a couple of things.

00:07:02,800 --> 00:07:06,800
First, it couldn't be an Elixir/Ruby mashup without just

00:07:06,800 --> 00:07:10,840
enough Elixir. So we'll discuss Elixir, we'll get into

00:07:10,840 --> 00:07:13,539
some of the relevant mechanisms. I can't actually teach

00:07:13,539 --> 00:07:15,319
you all of Elixir today, but hopefully I can

00:07:15,319 --> 00:07:18,220
spark some curiosity to get you to go out

00:07:18,220 --> 00:07:19,259
and learn.

00:07:19,259 --> 00:07:22,220
We'll also have a look at some of Elixir's

00:07:22,220 --> 00:07:26,240
emerging frameworks, like Dynamo, which is a Sinatra-like web

00:07:26,240 --> 00:07:29,770
app, or, a Sinatra web framework, and Echto, which

00:07:29,770 --> 00:07:34,479
is a database integration tool.

00:07:34,479 --> 00:07:39,889
Next, we'll touch on Ruby. We'll throw it in

00:07:39,889 --> 00:07:42,379
there. It'll move in with its Elixir code, and

00:07:42,379 --> 00:07:43,849
we'll see how we can use Ruby to fill

00:07:43,849 --> 00:07:46,050
in some of the gaps that are missing in

00:07:46,050 --> 00:07:51,389
our Elixir implementation. And finally, I'll wrap things up

00:07:51,389 --> 00:07:53,460
in a nice, neat package that you can take

00:07:53,460 --> 00:07:56,889
home.

00:07:56,889 --> 00:07:58,930
So in case you haven't heard about Elixir -

00:07:58,930 --> 00:08:01,110
has anybody, has everybody heard about Elixir? Most everybody.

00:08:01,110 --> 00:08:04,610
Has anybody used it? I have, too, I suppose

00:08:04,610 --> 00:08:07,580
I should raise my hand. But you may have

00:08:07,580 --> 00:08:08,240
guessed that.

00:08:08,240 --> 00:08:10,120
Well, I'm gonna throw out the quick elevator pitch

00:08:10,120 --> 00:08:14,729
first. Elixir is a functional language. It was created

00:08:14,729 --> 00:08:17,319
by Jose Valim and, if you're familiar with Jose

00:08:17,319 --> 00:08:19,889
Valim, he was a Rails core team member, a

00:08:19,889 --> 00:08:24,669
Ruby hero. And he wrote some little authentication library,

00:08:24,669 --> 00:08:28,509
Devise, you may have heard of.

00:08:28,509 --> 00:08:30,830
It runs on the Erlang virtual machine. Yeah, that's

00:08:30,830 --> 00:08:34,779
right. I said Erlang. We won't get into that.

00:08:34,779 --> 00:08:37,490
But both Elixir and Erlang compile into the same

00:08:37,490 --> 00:08:40,310
byte code. This is actually quite handy because they

00:08:40,310 --> 00:08:42,200
share data types.

00:08:42,200 --> 00:08:44,570
So it makes the, so there is actually no

00:08:44,570 --> 00:08:47,850
performance issues or conversion issues when you're calling one

00:08:47,850 --> 00:08:50,680
language from the other. You can literally call Erlang

00:08:50,680 --> 00:08:56,410
directly from your Elixir code and vice versa.

00:08:56,410 --> 00:08:59,100
So with Jose Valim at the helm, you can

00:08:59,100 --> 00:09:02,060
imagine it looks very similar to Ruby.

00:09:02,060 --> 00:09:06,910
Syntactically. But it can be deceptive. And we'll get

00:09:06,910 --> 00:09:09,829
into that, you'll see in just a minute. SO

00:09:09,829 --> 00:09:12,420
this actually sets itself up quite well for, for

00:09:12,420 --> 00:09:16,519
part of our polyglot experiment.

00:09:16,519 --> 00:09:20,930
So let's put the fun in function. Ruby is

00:09:20,930 --> 00:09:22,190
taking on the main role in this, in this

00:09:22,190 --> 00:09:24,959
talk, but we need to understand a little bit

00:09:24,959 --> 00:09:28,910
about Elixir and a little bit about, a little

00:09:28,910 --> 00:09:30,760
bit more than just that elevator pitch to really

00:09:30,760 --> 00:09:34,470
provoke the curiosity. And so that when you're looking

00:09:34,470 --> 00:09:36,140
at the code, you kind of understand what's going

00:09:36,140 --> 00:09:38,760
on.

00:09:38,760 --> 00:09:44,110
So let's dive head first.

00:09:44,110 --> 00:09:47,750
We'll start with functions. Elixir supports both named and

00:09:47,750 --> 00:09:51,200
anonymous functions. Right here we are creating an anonymous

00:09:51,200 --> 00:09:54,990
function, which we use the keyword f(n) defines our

00:09:54,990 --> 00:10:00,160
function out, and then we can just execute, and

00:10:00,160 --> 00:10:04,440
look. Hello RubyConf.

00:10:04,440 --> 00:10:06,690
If you'll notice, there's a dot in between the

00:10:06,690 --> 00:10:10,310
execution, or, or between the variable and the execution

00:10:10,310 --> 00:10:12,170
of the function. That's just to let the system

00:10:12,170 --> 00:10:14,160
know that it is, I don't want to get

00:10:14,160 --> 00:10:15,440
too into that. I know it's a little confusing

00:10:15,440 --> 00:10:17,019
right now. But there's a lot of talk in

00:10:17,019 --> 00:10:19,600
the group about that going away altogether. So no

00:10:19,600 --> 00:10:22,860
sense in going over that too much.

00:10:22,860 --> 00:10:26,970
But unlike Ruby, named functions are, cannot be defined

00:10:26,970 --> 00:10:30,930
outside a module. So when you go into the

00:10:30,930 --> 00:10:32,690
repl and you actually try to create it, you're

00:10:32,690 --> 00:10:34,940
gonna get a syntax error because it has to

00:10:34,940 --> 00:10:37,910
be set in a module. That's part of the

00:10:37,910 --> 00:10:42,279
deceptive part. Remember, it's not Ruby.

00:10:42,279 --> 00:10:45,420
Now named functions within the module can easily be

00:10:45,420 --> 00:10:50,350
invoked by defining the module, defining the function, and

00:10:50,350 --> 00:10:53,420
then calling. And you can do this right in

00:10:53,420 --> 00:10:56,510
the repl. The repl by the way is called

00:10:56,510 --> 00:11:00,440
IVX instead or IRB.

00:11:00,440 --> 00:11:02,610
And then we can go ahead and call greet

00:11:02,610 --> 00:11:07,279
today. Hello.

00:11:07,279 --> 00:11:11,370
So if you notice, the do blocks. Yes. Those

00:11:11,370 --> 00:11:17,970
are do blocks. Every body of a function, or

00:11:17,970 --> 00:11:22,350
actually, most things in Elixir, takes a do block.

00:11:22,350 --> 00:11:25,240
It's essentially a call to a macro def, which

00:11:25,240 --> 00:11:27,000
takes a name in the do block. The do

00:11:27,000 --> 00:11:29,339
block is just the code to be executed.

00:11:29,339 --> 00:11:32,220
With that opens up a whole realm of metaprogramming

00:11:32,220 --> 00:11:36,610
possibilities, where you could literally use Elixir to rewrite

00:11:36,610 --> 00:11:39,610
Elixir, which is kind of weird and way more

00:11:39,610 --> 00:11:42,500
than a forty-five minute talk, probably.

00:11:42,500 --> 00:11:46,329
But this pattern is used throughout Elixir. So it's

00:11:46,329 --> 00:11:50,459
good to be familiar with it.

00:11:50,459 --> 00:11:52,579
And really, the do block itself is just some

00:11:52,579 --> 00:11:56,630
syntactical sugar for an inline function, where the do

00:11:56,630 --> 00:11:58,680
is just a named parameter, and you can see

00:11:58,680 --> 00:12:01,570
when we actually do an inline function, the same

00:12:01,570 --> 00:12:03,180
thing can happened.

00:12:03,180 --> 00:12:06,370
Now, we're gonna move onto pattern matching, which is

00:12:06,370 --> 00:12:10,720
really important to understand in Elixir. Dave Thomas does

00:12:10,720 --> 00:12:14,190
a great explanation of the general pattern matching in

00:12:14,190 --> 00:12:16,290
Elixir. So I'll leave that to him.

00:12:16,290 --> 00:12:20,220
But how functions use pattern matching is really important

00:12:20,220 --> 00:12:24,269
for the way we, or, for this talk. So

00:12:24,269 --> 00:12:26,930
it's important to know how they actually work.

00:12:26,930 --> 00:12:29,510
Elixir uses pattern matching to bind arguments to the

00:12:29,510 --> 00:12:34,130
function's parameter list. So we can do things like

00:12:34,130 --> 00:12:37,410
this where we have a function that we can

00:12:37,410 --> 00:12:42,230
say, if Johnny is it, it's just you Johnny.

00:12:42,230 --> 00:12:45,050
If it's any other name, then we'll actually send

00:12:45,050 --> 00:12:47,459
a message to them.

00:12:47,459 --> 00:12:51,310
And so the same function is called when we

00:12:51,310 --> 00:12:53,760
pass to Johnny, we get, oh it's just you

00:12:53,760 --> 00:13:00,760
Johnny. When we call it again, say Matz, oh,

00:13:01,399 --> 00:13:05,660
I've always wanted to meet you.

00:13:05,660 --> 00:13:11,130
So another way of differentiating functions is why Guard

00:13:11,130 --> 00:13:14,019
clauses. I'm a big fan of Guard clauses. When

00:13:14,019 --> 00:13:16,279
you see my Elixir code, I use them quite

00:13:16,279 --> 00:13:18,709
often. But we can easily convert our pattern matching

00:13:18,709 --> 00:13:20,630
from the parameters to a guard clause.

00:13:20,630 --> 00:13:22,470
And what we have is we have a when

00:13:22,470 --> 00:13:28,019
clause that says, when the name equals Johnny, do.

00:13:28,019 --> 00:13:32,740
It's just Johnny. Hmm.

00:13:32,740 --> 00:13:38,250
Now, another thing that we're gonna encounter is recursive

00:13:38,250 --> 00:13:42,089
calls. This right here is something pretty simple, where

00:13:42,089 --> 00:13:43,959
we pass, basically pass in an array. It's just

00:13:43,959 --> 00:13:46,230
the summing of an array. But if you'll notice,

00:13:46,230 --> 00:13:49,259
there's a head pipe tail. What this actually does

00:13:49,259 --> 00:13:52,350
is split the first, or the first item in

00:13:52,350 --> 00:13:55,199
an array and the last item in an array.

00:13:55,199 --> 00:13:57,610
We can then take and say, the first item

00:13:57,610 --> 00:14:00,790
plus the sum of the last set of items,

00:14:00,790 --> 00:14:03,589
which it'll continue iterating over until it reaches an

00:14:03,589 --> 00:14:06,579
empty array and then pass back a zero, which

00:14:06,579 --> 00:14:11,470
actually cause everything to add up all the way.

00:14:11,470 --> 00:14:13,449
When we invoke this, when we invoke this sum

00:14:13,449 --> 00:14:17,790
and pass it an array, we actually get the

00:14:17,790 --> 00:14:22,089
total, ten.

00:14:22,089 --> 00:14:23,779
So that's just some syntax that you're gonna wanna

00:14:23,779 --> 00:14:26,019
know so that you recognize it when we hit

00:14:26,019 --> 00:14:29,199
it later in the talk. But before we get

00:14:29,199 --> 00:14:31,130
too much further, we need to discuss mix.

00:14:31,130 --> 00:14:33,009
All right, if you're familiar with Elixir, you're probably

00:14:33,009 --> 00:14:37,540
familiar with mix. It's similar to Clojure's line again,

00:14:37,540 --> 00:14:40,000
and it's basically used for a variety of tasks,

00:14:40,000 --> 00:14:43,130
anything from bootstrapping your Elixir projects to managing your

00:14:43,130 --> 00:14:49,550
dependencies and executing your test suite.

00:14:49,550 --> 00:14:54,459
Mix utilizes configural environments to scope compilation settings. This

00:14:54,459 --> 00:14:55,790
is handy for us, so that we can actually

00:14:55,790 --> 00:14:57,420
know whether or not we're running in a test

00:14:57,420 --> 00:14:59,769
environment or a dev environment based on mix and

00:14:59,769 --> 00:15:05,199
we can actually set that in our code.

00:15:05,199 --> 00:15:07,480
Another thing that we need to talk about is

00:15:07,480 --> 00:15:09,970
Dynamo. Dynamo is a web framework in Elixir. Like

00:15:09,970 --> 00:15:13,730
I said earlier, it's similar to Sinatra. It also

00:15:13,730 --> 00:15:16,290
has a template in its, a template engine built

00:15:16,290 --> 00:15:18,829
into it that's comparable to, say, the syntax of

00:15:18,829 --> 00:15:21,139
ERB.

00:15:21,139 --> 00:15:24,290
It's designed to stay out of your way. It's

00:15:24,290 --> 00:15:28,850
supposed to create high performance concurrent applications. There's a

00:15:28,850 --> 00:15:32,600
number of other frameworks coming out in Elixir right

00:15:32,600 --> 00:15:34,610
now. Weber might be one that you want to

00:15:34,610 --> 00:15:37,860
look at that's an MVC framework similar to Rails.

00:15:37,860 --> 00:15:39,709
But Dynamo does exactly what we want for this

00:15:39,709 --> 00:15:40,610
experiment.

00:15:40,610 --> 00:15:42,430
What happened?

00:15:42,430 --> 00:15:49,430
OK. I don't know what happened there. SO anyway,

00:15:50,600 --> 00:15:54,209
that, and that brings us to Ecto. Ecto will

00:15:54,209 --> 00:15:57,639
handle our database interactions. So we're gonna use that

00:15:57,639 --> 00:15:59,339
to implement our solutions.

00:15:59,339 --> 00:16:02,250
Now, the key to know about Ecto is that

00:16:02,250 --> 00:16:07,589
it divides structures into repository entity model and queries.

00:16:07,589 --> 00:16:12,230
This decoupling separates storage data and behavior.

00:16:12,230 --> 00:16:14,319
The main thing that we're gonna be concerning ourselves

00:16:14,319 --> 00:16:17,470
is with the storage and the data details. But

00:16:17,470 --> 00:16:19,279
it's actually a handy way to break things up,

00:16:19,279 --> 00:16:22,300
so it's a little different thinking in - I

00:16:22,300 --> 00:16:25,399
guess, coming from an object-oriented background, it's a little

00:16:25,399 --> 00:16:28,339
different to think of everything as modules than it

00:16:28,339 --> 00:16:30,860
is as objects.

00:16:30,860 --> 00:16:34,670
So this is all great. So you're probably thinking,

00:16:34,670 --> 00:16:39,220
well, what's missing? I'm sure I could rattle off

00:16:39,220 --> 00:16:41,550
any number of gems that would be easy, that

00:16:41,550 --> 00:16:43,069
you probably use on a day to day basis

00:16:43,069 --> 00:16:46,029
that would ease any type of transition for you.

00:16:46,029 --> 00:16:49,120
But we only have a few time, or, we

00:16:49,120 --> 00:16:51,279
only have so much time. I always say that

00:16:51,279 --> 00:16:54,660
with enough time and money that anything's possible, but

00:16:54,660 --> 00:16:56,569
we're limited today.

00:16:56,569 --> 00:16:57,720
So there's a couple areas that I want to

00:16:57,720 --> 00:17:03,160
focus. Although Elixir has Xunit, which is great for

00:17:03,160 --> 00:17:05,320
doing unit testing, but it doesn't really help us

00:17:05,320 --> 00:17:08,940
with, like, say, behavior driven development. That's something that's

00:17:08,940 --> 00:17:10,780
really important to us at Hash Rocket. So when

00:17:10,780 --> 00:17:12,640
we want to do project, especially a web project,

00:17:12,640 --> 00:17:15,020
I want to actually utilize some of those testing

00:17:15,020 --> 00:17:16,470
features.

00:17:16,470 --> 00:17:19,460
The other thing that, that Ecto doesn't have is

00:17:19,460 --> 00:17:22,660
data migrations, which you'll find that as you, as

00:17:22,660 --> 00:17:24,690
you're working with a project that you're having to

00:17:24,690 --> 00:17:27,000
do a lot of database interactions with, it's a

00:17:27,000 --> 00:17:28,890
real pain to try to manage those. So if

00:17:28,890 --> 00:17:30,280
we can have a tool that will allow us

00:17:30,280 --> 00:17:33,300
to use migrations outside of the scope of the

00:17:33,300 --> 00:17:36,460
project it'll make our life a little easier.

00:17:36,460 --> 00:17:40,580
So what do we need to do? Ruby. We'll

00:17:40,580 --> 00:17:43,590
throw in a touch of Ruby. Ruby does a

00:17:43,590 --> 00:17:46,600
perfect job of, of bridging those gaps that are

00:17:46,600 --> 00:17:48,770
missing I know that one thing that I've found,

00:17:48,770 --> 00:17:51,400
like I said earlier when I was learning Elixir,

00:17:51,400 --> 00:17:52,940
I spent a lot of time going, man, if

00:17:52,940 --> 00:17:54,550
I could only do this, or, or I wish

00:17:54,550 --> 00:17:57,320
I had this. And I was like, why don't

00:17:57,320 --> 00:17:58,860
I just use it?

00:17:58,860 --> 00:18:02,680
It's real easy to inject Ruby inside another project,

00:18:02,680 --> 00:18:04,680
and so that's where we're actually gonna begin. We're

00:18:04,680 --> 00:18:10,170
gonna cover behavior-driven development, oh, sorry, this is slow.

00:18:10,170 --> 00:18:15,760
Behavior driven development and integration te, or, migrations.

00:18:15,760 --> 00:18:18,720
So let's first look at the behavior-driven development solution.

00:18:18,720 --> 00:18:22,570
Capybara, Cucumber, and Rspec are a trio that work

00:18:22,570 --> 00:18:26,660
perfect for behavior-driven development, and it's real simple to

00:18:26,660 --> 00:18:29,820
incorporate. Assuming that we have our dynamo project up

00:18:29,820 --> 00:18:33,660
and running, we can go ahead and create a

00:18:33,660 --> 00:18:38,550
project and then in the, in the root of

00:18:38,550 --> 00:18:42,710
that, oh. Before we get that far, sorry, we

00:18:42,710 --> 00:18:45,750
have to actually add our Ecto and our, our

00:18:45,750 --> 00:18:48,130
adaptor for PostGres so that way we'll actually be

00:18:48,130 --> 00:18:50,090
able to integrate with PostGres.

00:18:50,090 --> 00:18:53,810
And this is actually in the mix, ESS file

00:18:53,810 --> 00:18:58,510
that we go ahead and add these in. Then

00:18:58,510 --> 00:19:03,140
we can start the server. Yay! Server starts.

00:19:03,140 --> 00:19:09,370
Tada! So then we go in and add a

00:19:09,370 --> 00:19:15,060
gemfile. And add our Cucumber, Capybara, and Rspec gems.

00:19:15,060 --> 00:19:18,230
Once we actually go ahead and bundle that, we'll

00:19:18,230 --> 00:19:21,410
have Cucumber available to us. Now, when you try

00:19:21,410 --> 00:19:25,930
to run Cucumber in a typical scenario, it's gonna

00:19:25,930 --> 00:19:28,890
want to spin up a server. Capybara spins up

00:19:28,890 --> 00:19:30,770
the server. Well, we don't want that, cause we're

00:19:30,770 --> 00:19:34,400
gonna actually inject this into mix, so we want

00:19:34,400 --> 00:19:38,820
everything to be scoped underneath the mix, testing environment.

00:19:38,820 --> 00:19:40,880
So what we can do is we can actually

00:19:40,880 --> 00:19:44,550
add a Cucumber conf file and go ahead and

00:19:44,550 --> 00:19:47,230
we want to shut off Capybara's running, running of

00:19:47,230 --> 00:19:49,410
the server. And that's as simple as just setting

00:19:49,410 --> 00:19:51,000
it to false. But we also want to give

00:19:51,000 --> 00:19:54,290
it the, the app host to actually call to,

00:19:54,290 --> 00:19:58,130
which is the default, default instance for the server

00:19:58,130 --> 00:20:04,460
that's run through mix, which is the 8888 port.

00:20:04,460 --> 00:20:10,120
Now, that's great. But we actually need mix to

00:20:10,120 --> 00:20:12,690
run this. So now this is an actual mix

00:20:12,690 --> 00:20:14,530
test, and so what we can do is we

00:20:14,530 --> 00:20:16,330
can drop in on the shell and pass the

00:20:16,330 --> 00:20:19,660
command for Cucumber, tell it where our features are,

00:20:19,660 --> 00:20:22,420
and then, this we're just formatting into Progress so

00:20:22,420 --> 00:20:25,280
it'll, it will just get the dots run through.

00:20:25,280 --> 00:20:32,280
But we can then execute mix test, and there.

00:20:33,960 --> 00:20:36,850
So mix test is now actually firing the environment,

00:20:36,850 --> 00:20:39,000
scoping it under the test environment, but then running

00:20:39,000 --> 00:20:45,130
Cucumber. This is a little boring cause there's nothing

00:20:45,130 --> 00:20:47,480
there, so we should probably go ahead and add

00:20:47,480 --> 00:20:50,080
a feature. We'll just do a simple feature where

00:20:50,080 --> 00:20:53,440
we add some posts, throw it on the homepage,

00:20:53,440 --> 00:20:56,750
and then we should see those posts.

00:20:56,750 --> 00:21:01,450
We'll run this and, is anybody surprised?

00:21:01,450 --> 00:21:04,900
Of course we don't have any steps. We just

00:21:04,900 --> 00:21:06,820
threw the feature together. So we'll go ahead and

00:21:06,820 --> 00:21:11,830
add our steps in there. And then now we

00:21:11,830 --> 00:21:14,830
have failures. And this is actually how the failures

00:21:14,830 --> 00:21:18,230
work - so this is gonna kill that. And

00:21:18,230 --> 00:21:20,950
then we actually would get our failure within our

00:21:20,950 --> 00:21:26,070
other mix messages.

00:21:26,070 --> 00:21:27,410
So now that we have our test suite set

00:21:27,410 --> 00:21:29,340
up and our first test, it's time to look

00:21:29,340 --> 00:21:35,200
at data migrations.

00:21:35,200 --> 00:21:39,910
This is actually really easy to, to implement. And

00:21:39,910 --> 00:21:42,690
really handy if they don't exist. So we go

00:21:42,690 --> 00:21:46,520
ahead and we add our, our ActiveRecord, our PostGress

00:21:46,520 --> 00:21:49,290
gem, and builder. Now the reason I'm adding builder

00:21:49,290 --> 00:21:52,720
into this is because Cucumber actually has a fixed

00:21:52,720 --> 00:21:55,280
version of, of builder, and so if you try

00:21:55,280 --> 00:21:57,270
to not add builder, it's, you're actually gonna get

00:21:57,270 --> 00:21:58,800
an error. SO that has to be added manually.

00:21:58,800 --> 00:22:00,370
That's why that one's in there.

00:22:00,370 --> 00:22:04,730
Other than that, it's ActiveRecord and PostGres are the

00:22:04,730 --> 00:22:07,220
important ones.

00:22:07,220 --> 00:22:10,060
So we need to tell it where. Where are

00:22:10,060 --> 00:22:12,630
migrations gonna be located? We can create a Rake

00:22:12,630 --> 00:22:14,160
file, and then at the top of our Rake

00:22:14,160 --> 00:22:17,760
file, we actually set the path and just require

00:22:17,760 --> 00:22:20,600
all the, all the migrations that are in there.

00:22:20,600 --> 00:22:23,700
We also - because you're Rubyists.

00:22:23,700 --> 00:22:26,130
We're gonna create a DSL similar to Rails, just

00:22:26,130 --> 00:22:27,760
cause it's handy and more people are familiar with

00:22:27,760 --> 00:22:29,540
it. So we create the DB namespace in our

00:22:29,540 --> 00:22:32,850
Rake file. We give it a configuration for our,

00:22:32,850 --> 00:22:36,500
for our server, and then we can run migrations

00:22:36,500 --> 00:22:39,810
by establishing a connection and then, what I actually

00:22:39,810 --> 00:22:42,830
do is I loop through all the descendants of

00:22:42,830 --> 00:22:46,400
migration, and so it'll pick up the route there

00:22:46,400 --> 00:22:49,890
and actually load the, or, it'll run, execute them,

00:22:49,890 --> 00:22:52,230
based on the direction that we send into migration.

00:22:52,230 --> 00:22:53,520
So if you want to take something up or

00:22:53,520 --> 00:22:56,160
down, roll something back, you can go ahead and

00:22:56,160 --> 00:23:00,260
add that in there. And we also want to

00:23:00,260 --> 00:23:02,800
create one for test. Now, we are gonna run

00:23:02,800 --> 00:23:05,640
two different servers here, based on the environment. So

00:23:05,640 --> 00:23:08,880
we're gonna have a test server and a dev

00:23:08,880 --> 00:23:10,560
server. So when we run tests, we want to

00:23:10,560 --> 00:23:13,950
make sure that we're scoping our migrations to test,

00:23:13,950 --> 00:23:17,960
and that's how we're gonna accomplish that here.

00:23:17,960 --> 00:23:22,790
Now we can run it and that was anti-climactic.

00:23:22,790 --> 00:23:28,120
Well, we don't have any yet. So we should

00:23:28,120 --> 00:23:32,860
probably go ahead and add some. Now here's a

00:23:32,860 --> 00:23:35,780
migration that I'll create, and you just go in

00:23:35,780 --> 00:23:37,890
here, you create your SQL, and then add- put

00:23:37,890 --> 00:23:39,120
your SQL in there, and then any time you

00:23:39,120 --> 00:23:41,840
run up or down, it'll go ahead and create

00:23:41,840 --> 00:23:42,170
that.

00:23:42,170 --> 00:23:44,650
Now, to prevent the table from constantly getting errors,

00:23:44,650 --> 00:23:46,250
you just run a if not exist, and that

00:23:46,250 --> 00:23:47,970
way you can do it. now, if you want

00:23:47,970 --> 00:23:49,770
to go ahead and do an update, I would

00:23:49,770 --> 00:23:52,750
do that as a separate migration.

00:23:52,750 --> 00:23:54,690
if you're doing this just for fun, keep in

00:23:54,690 --> 00:23:56,990
mind that these are all just gonna run in

00:23:56,990 --> 00:24:00,790
alphabetical order. So you might want to actually, either

00:24:00,790 --> 00:24:03,370
work on your naming. You don't actually have the

00:24:03,370 --> 00:24:06,520
same type of naming conventions as you would in

00:24:06,520 --> 00:24:10,010
a Rails application. But for an experimental purpose, this

00:24:10,010 --> 00:24:17,010
gets you started.

00:24:19,690 --> 00:24:26,140
Now. OK.

00:24:26,140 --> 00:24:31,830
Now, remember we left this. I don't know if

00:24:31,830 --> 00:24:34,750
anybody caught that. But we need to generate some

00:24:34,750 --> 00:24:38,280
posts, otherwise, every time we run the test there's

00:24:38,280 --> 00:24:41,450
not gonna be anything to, to look at. We

00:24:41,450 --> 00:24:43,450
can go back to our Cucumber rb file and

00:24:43,450 --> 00:24:45,430
add this little snippet of code, which is basically

00:24:45,430 --> 00:24:48,280
establishing the connection and then giving it the test

00:24:48,280 --> 00:24:52,110
database to call.

00:24:52,110 --> 00:24:55,460
Then we add a post class to actually be

00:24:55,460 --> 00:24:58,350
the migration, and then we can do inserts and

00:24:58,350 --> 00:25:01,770
deletes straight from here. So as the step runs,

00:25:01,770 --> 00:25:05,040
it calls the upstep, inserts whatever you want. One

00:25:05,040 --> 00:25:07,280
of the cool things is that I actually went,

00:25:07,280 --> 00:25:09,120
like, it's further into the project when you get

00:25:09,120 --> 00:25:10,960
a little deeper into it, is you could actually

00:25:10,960 --> 00:25:13,630
use naming of these so that you can, you

00:25:13,630 --> 00:25:16,040
know, define tags in your Cucumber strip that are

00:25:16,040 --> 00:25:18,700
gonna run specific ones and you can use faker

00:25:18,700 --> 00:25:22,430
to create unique items that go into the database.

00:25:22,430 --> 00:25:23,890
Anytime you want to do like massive amounts of

00:25:23,890 --> 00:25:26,610
data or things like that. But for our purposes

00:25:26,610 --> 00:25:29,670
right now, just a simple insert will get us

00:25:29,670 --> 00:25:35,660
where we want to go.

00:25:35,660 --> 00:25:38,890
So we add our posts up there, and it'll

00:25:38,890 --> 00:25:40,900
actually do our insert for us. Like I said,

00:25:40,900 --> 00:25:45,170
tags also work really well with that. But we

00:25:45,170 --> 00:25:48,080
also want to do some clean up. So after

00:25:48,080 --> 00:25:50,700
our Cucumber, we go back to our Cucumber configuration

00:25:50,700 --> 00:25:52,820
and just add an after through each scenario so

00:25:52,820 --> 00:25:55,490
that it goes through and tears down or deletes

00:25:55,490 --> 00:25:57,300
the ones that are there.

00:25:57,300 --> 00:26:00,190
So it kind of cleans up after itself.

00:26:00,190 --> 00:26:03,680
I think that's enough ruby to get us started.

00:26:03,680 --> 00:26:08,340
So now for the Elixir. I'm sure this is

00:26:08,340 --> 00:26:12,750
the part that everybody loves to see.

00:26:12,750 --> 00:26:15,020
So now we need to actually go back to

00:26:15,020 --> 00:26:18,170
our Elixir project and we're gonna do a few

00:26:18,170 --> 00:26:20,140
things. We want to get our database, our call

00:26:20,140 --> 00:26:23,010
setup. it uses a repo cla- or, yeah, a

00:26:23,010 --> 00:26:26,640
repository class. We're just gonna name it Repo.

00:26:26,640 --> 00:26:28,010
This is as simple as it is to define

00:26:28,010 --> 00:26:32,020
a repository in Elixir for Ecto. And we just

00:26:32,020 --> 00:26:35,970
make a call out. The mix environment is determined

00:26:35,970 --> 00:26:38,160
at runtime, and then we can actually send that

00:26:38,160 --> 00:26:41,350
over to, to our URL so that they can

00:26:41,350 --> 00:26:43,340
actually come back, and whether or not we're running

00:26:43,340 --> 00:26:45,710
in test or dev it'll actually set us to

00:26:45,710 --> 00:26:50,480
the right, the correct repository.

00:26:50,480 --> 00:26:52,370
The next step is to define some models and

00:26:52,370 --> 00:26:55,920
some core modules. Our all function is actually a

00:26:55,920 --> 00:27:00,270
remapping of the records that come back, cause we

00:27:00,270 --> 00:27:02,620
basically want to create a tuple, and we're gonna

00:27:02,620 --> 00:27:05,010
actually do that through an anonymous function. So it's

00:27:05,010 --> 00:27:07,340
gonna iterate over all the records and then divide

00:27:07,340 --> 00:27:08,960
them up into tuples, so it'll actually make it

00:27:08,960 --> 00:27:11,140
a little easier to do pattern matching in our

00:27:11,140 --> 00:27:13,930
template later on down the road.

00:27:13,930 --> 00:27:16,710
because, keep in mind, everything's gonna go across the

00:27:16,710 --> 00:27:19,450
web, it's gonna come through as more like a

00:27:19,450 --> 00:27:21,430
JSON object. And so it's a little easier to

00:27:21,430 --> 00:27:24,960
just iterate over it if it's already divided out.

00:27:24,960 --> 00:27:29,880
Now, onto the dynamo routers. Routers are an important

00:27:29,880 --> 00:27:31,750
part of the way Dynamo works, and it's the

00:27:31,750 --> 00:27:37,140
entrypoint to the application. So, and, anybody that uses

00:27:37,140 --> 00:27:41,400
Sinatra, Sinatra fans, folks here? OK. So this should

00:27:41,400 --> 00:27:44,150
look pretty similar to a typical Sinatra.

00:27:44,150 --> 00:27:49,430
One thing to note is the con, con variable,

00:27:49,430 --> 00:27:52,470
which if you see we're assigning it and then

00:27:52,470 --> 00:27:55,530
passing it back. This is actually not assignment. This

00:27:55,530 --> 00:27:58,020
is pattern matching. It's saying that the value on

00:27:58,020 --> 00:28:00,990
the right could be the value on the, could

00:28:00,990 --> 00:28:02,940
be equal to the value on the left, so

00:28:02,940 --> 00:28:04,080
then they therefore match.

00:28:04,080 --> 00:28:05,200
So what you end up having to do is

00:28:05,200 --> 00:28:06,900
you have to do the assignment and then set

00:28:06,900 --> 00:28:10,580
it and then pass it back through the render.

00:28:10,580 --> 00:28:13,610
Now all this is just currently the way Dynamo

00:28:13,610 --> 00:28:16,180
works. Everything is still kind of in flux so

00:28:16,180 --> 00:28:18,130
this might change. But it's just something to note

00:28:18,130 --> 00:28:21,980
when you're looking at a router in Dynamo.

00:28:21,980 --> 00:28:24,970
And finally, we have the template. And the template,

00:28:24,970 --> 00:28:28,180
we actually use a list comprehension to iterate over

00:28:28,180 --> 00:28:31,910
the set, which is that tople, or tuple set,

00:28:31,910 --> 00:28:33,510
and if you notice that we have another score

00:28:33,510 --> 00:28:35,650
for that first argument. That's because we don't really

00:28:35,650 --> 00:28:37,220
care about the ID at this point. We just

00:28:37,220 --> 00:28:40,400
want to display the information on the screen. And

00:28:40,400 --> 00:28:43,080
so we just kind of want to iterate over

00:28:43,080 --> 00:28:43,790
it.

00:28:43,790 --> 00:28:46,900
This is actually enough to get us up and

00:28:46,900 --> 00:28:48,440
running.

00:28:48,440 --> 00:28:54,270
So, let's see. we should be able to go

00:28:54,270 --> 00:28:56,440
over here to our.

00:28:56,440 --> 00:29:03,440
Hold on, let me get it to work. Hold

00:29:10,300 --> 00:29:11,840
on.

00:29:11,840 --> 00:29:15,860
Elixir. We should be able to go to our

00:29:15,860 --> 00:29:22,860
directory here. And actually I'm gonna switch this.

00:29:27,970 --> 00:29:34,970
So this way we'll run our mix tests and

00:29:39,070 --> 00:29:44,020
you'll be able to see it actually run, doing

00:29:44,020 --> 00:29:47,480
our scenarios. Did you all see that. The fish

00:29:47,480 --> 00:29:49,880
full of dollars pops up. So that is actually

00:29:49,880 --> 00:29:52,970
what that actually is is Ruby is being executed

00:29:52,970 --> 00:29:55,910
from inside the, the environment. It's hitting the test

00:29:55,910 --> 00:29:58,990
database. It's populating the test database. And then it

00:29:58,990 --> 00:30:02,210
actually cleans up afterwards.

00:30:02,210 --> 00:30:05,170
But it's actually running it. So we've actually used

00:30:05,170 --> 00:30:07,920
Ruby at this point now to handle some of

00:30:07,920 --> 00:30:10,840
the gaps within Elixir.

00:30:10,840 --> 00:30:17,840
Sorry, just one second. Let me switch back to.

00:30:27,740 --> 00:30:34,740
All right. So I've been developing software for the

00:30:35,440 --> 00:30:39,760
better part of fifteen years. I've seen languages come

00:30:39,760 --> 00:30:41,630
and go. Some of them better than others. Some

00:30:41,630 --> 00:30:42,240
of their implementations are better than others. And we

00:30:42,240 --> 00:30:44,130
can argue until we're blue in the face about

00:30:44,130 --> 00:30:45,720
which ones are the best.

00:30:45,720 --> 00:30:47,220
But one thing that I do know is that

00:30:47,220 --> 00:30:50,880
Ruby is a great tool for using with other

00:30:50,880 --> 00:30:54,400
languages, regardless of what you're trying to do. If

00:30:54,400 --> 00:30:57,510
you're looking to run a tested application that's untested,

00:30:57,510 --> 00:31:00,950
run migrations on something. You could easily incorporate Ruby

00:31:00,950 --> 00:31:03,950
into those applications so that it can handle some

00:31:03,950 --> 00:31:06,660
of the gaps that maybe don't exist or covers

00:31:06,660 --> 00:31:10,520
what's not there yet.

00:31:10,520 --> 00:31:13,650
Technology is moving forward. There's always some new kid

00:31:13,650 --> 00:31:16,020
on the block. So the, the idea that you

00:31:16,020 --> 00:31:19,600
can actually use a tool like Ruby is something

00:31:19,600 --> 00:31:20,700
that, excuse me.

00:31:20,700 --> 00:31:27,250
The idea that you can use Ruby to learn

00:31:27,250 --> 00:31:31,450
other language and progress is actually using constructivism to

00:31:31,450 --> 00:31:35,950
build upon prior knowledge. It's important to remember that

00:31:35,950 --> 00:31:39,220
these tools that we use, every day, are beneficial

00:31:39,220 --> 00:31:41,700
outside of the scope of what we do nine

00:31:41,700 --> 00:31:42,970
to five.

00:31:42,970 --> 00:31:49,970

YouTube URL: https://www.youtube.com/watch?v=71v21C-zx3Y


