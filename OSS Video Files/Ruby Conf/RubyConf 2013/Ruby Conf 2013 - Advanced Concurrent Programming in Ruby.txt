Title: Ruby Conf 2013 - Advanced Concurrent Programming in Ruby
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Jerry D'Antonio

Rumor has it that you can't write concurrent programs in Ruby. People once believed that the world was flat and we all know how that turned out. Between the native threads introduced in MRI 1.9 and the JVM threading available to JRuby, Ruby is now a valid platform for concurrent applications. What we've been missing--until now--are the advanced concurrency tools available to other languages like Clojure, Scala, Erlang, and Go. In this session we'll talk about the specific challenges faced when writing concurrent applications; we'll explore modern concurrency techniques such as agents, futures, promises, reactors, and supervisors; and we'll use various open source tools to craft safe, reliable, and efficient concurrent code. We'll write most of our code using the Concurrent Ruby gem but we'll also explore EventMachine and Celluloid.

Help us caption & translate this video!

http://amara.org/v/FG56/
Captions: 
	00:00:16,520 --> 00:00:18,420
JERRY D'ANTONIO: Good afternoon everyone.

00:00:18,420 --> 00:00:19,800
Hope you guys had a good lunch.

00:00:19,800 --> 00:00:21,500
Hopefully you're not gonna fall asleep on me.

00:00:21,509 --> 00:00:25,779
I'll do my best to keep that from happening.

00:00:25,779 --> 00:00:27,210
As the slide here says, my name is Jerry

00:00:27,210 --> 00:00:30,949
D'Antonio. I work for a company called VHT, formerly

00:00:30,949 --> 00:00:33,890
Virtual Holes Technology, and we are an Erlang and

00:00:33,890 --> 00:00:36,650
Ruby shop out of Akron, Ohio. And, again as

00:00:36,650 --> 00:00:37,780
the slide says, I'm here to talk to you

00:00:37,780 --> 00:00:39,200
guys about concurrency.

00:00:39,200 --> 00:00:42,720
So, yesterday I was monitoring the Tweets for the

00:00:42,720 --> 00:00:44,390
conference, and somebody sent out a Tweet that I

00:00:44,390 --> 00:00:46,380
thought was very interesting, and it asked the question,

00:00:46,380 --> 00:00:50,070
it said something to the effect of, RubyConf should

00:00:50,070 --> 00:00:53,330
give me a reason why I want to use

00:00:53,330 --> 00:00:55,020
Ruby in 2014.

00:00:55,020 --> 00:00:58,380
Now, I assume, like the rest of you guys,

00:00:58,380 --> 00:01:00,090
I really love Ruby. And I think there's a

00:01:00,090 --> 00:01:02,250
million reasons why people would want to continue using

00:01:02,250 --> 00:01:06,219
Ruby in the future. Unfortunately, when the question comes

00:01:06,219 --> 00:01:08,929
to concurrency, selling Ruby is a little bit harder

00:01:08,929 --> 00:01:10,990
of a sell, all right.

00:01:10,990 --> 00:01:13,579
Now, I'm not talking here about interpretive issues. I'm

00:01:13,579 --> 00:01:16,310
not talking about the global interpreter lock. I'm talking

00:01:16,310 --> 00:01:17,479
about any of that kind of stuff. I'm talking

00:01:17,479 --> 00:01:19,579
about abstraction. All right, let me give you a

00:01:19,579 --> 00:01:21,159
brief bit of history.

00:01:21,159 --> 00:01:23,020
Years ago, I used to work in banking systems,

00:01:23,020 --> 00:01:26,960
and we wrote highly performant, highly concurrent systems in

00:01:26,960 --> 00:01:29,259
C++. Now, if you've ever had to deal with

00:01:29,259 --> 00:01:32,189
concurrency in a language like C++, you realize that

00:01:32,189 --> 00:01:33,780
it is full of a lot of pain and

00:01:33,780 --> 00:01:36,859
agony. You spawn a bunch of threads, and a

00:01:36,859 --> 00:01:40,719
bunch of low-level concur- locking, you know, in terms

00:01:40,719 --> 00:01:43,600
of, of kernel-level objects to try and synchronize those

00:01:43,600 --> 00:01:46,109
threads. And it's very easy to get wrong. It

00:01:46,109 --> 00:01:47,619
was so easy to get wrong that we actually

00:01:47,619 --> 00:01:51,079
have whole categories oc bugs named after common concurrency

00:01:51,079 --> 00:01:52,319
errors, all right.

00:01:52,319 --> 00:01:53,880
So like most people who do that work, eventually

00:01:53,880 --> 00:01:54,700
I had to get out of it because it

00:01:54,700 --> 00:01:57,090
was just too painful, right. But five, six years

00:01:57,090 --> 00:01:59,329
ago I discovered Ruby. I've been using Ruby ever

00:01:59,329 --> 00:02:01,319
since, and I love Ruby.

00:02:01,319 --> 00:02:04,529
Unfortunately, the concurrency tools that Ruby provides to us

00:02:04,529 --> 00:02:06,829
are pretty much the same things that I was

00:02:06,829 --> 00:02:10,489
using fifteen years ago in C++. We had thread

00:02:10,489 --> 00:02:13,689
dot new, we have mutex, where we can cross-synchronize,

00:02:13,689 --> 00:02:15,530
and we can do all this low-level stuff which

00:02:15,530 --> 00:02:17,430
is every bit as painful, right.

00:02:17,430 --> 00:02:19,220
Now, if you look at what's going on in

00:02:19,220 --> 00:02:23,250
other languages, with respect to concurrency, today we have

00:02:23,250 --> 00:02:26,230
this thing called asynchronous concurrency, k. Rather than trying

00:02:26,230 --> 00:02:27,830
to place a bunch of different threads and place

00:02:27,830 --> 00:02:29,450
a bunch of locks on a bunch of things

00:02:29,450 --> 00:02:33,950
and get a bunch of contention, instead, we send

00:02:33,950 --> 00:02:36,709
operations off onto different threads or different processes. They

00:02:36,709 --> 00:02:40,409
do their thing, and then we coordinate those, right.

00:02:40,409 --> 00:02:41,510
And if you look around at a lot of

00:02:41,510 --> 00:02:43,379
the languages not called Ruby, you see a lot

00:02:43,379 --> 00:02:45,890
of really cool things going on, right. Languages like

00:02:45,890 --> 00:02:50,360
Erlang and Clojure and Scala and, even JavaScript and

00:02:50,360 --> 00:02:53,079
Java and C# are doing some very interesting things

00:02:53,079 --> 00:02:54,280
with respect to concurrency.

00:02:54,280 --> 00:02:56,829
Now, Ruby, being the great language it is, we

00:02:56,829 --> 00:02:59,829
can actually use these same abstractions in Ruby if

00:02:59,829 --> 00:03:02,799
we take the time to build them, K. They

00:03:02,799 --> 00:03:04,420
don't exist in our standard library right now. They

00:03:04,420 --> 00:03:07,680
don't exist in the, the language itself. But we

00:03:07,680 --> 00:03:09,129
can still build them and we can still use

00:03:09,129 --> 00:03:09,769
them.

00:03:09,769 --> 00:03:11,709
So my goal today is to give you a

00:03:11,709 --> 00:03:15,430
survey of some of the asynchronous concurrency techniques that

00:03:15,430 --> 00:03:18,500
are being used in other languages. And show you

00:03:18,500 --> 00:03:21,250
how you can use those in Ruby today.

00:03:21,250 --> 00:03:23,950
This is going to be an incredibly code-heavy presentation,

00:03:23,950 --> 00:03:26,920
all right. Pretty much every slide in here is

00:03:26,920 --> 00:03:30,329
either a picture or code, right. Now, there's a

00:03:30,329 --> 00:03:31,599
lot of stuff to cover and I'm not gonna

00:03:31,599 --> 00:03:33,319
be able to go over everything in detail, so

00:03:33,319 --> 00:03:35,670
my goal here is - all of the, in

00:03:35,670 --> 00:03:38,959
this presentation, in its entirety, with extensive notes and

00:03:38,959 --> 00:03:40,670
all of the source code samples are up on

00:03:40,670 --> 00:03:41,219
GitHub.

00:03:41,219 --> 00:03:42,879
So you can go out there, you can clone

00:03:42,879 --> 00:03:44,170
the repo, you can pull this down. You can

00:03:44,170 --> 00:03:45,810
run all the code I'm gonna show you. So

00:03:45,810 --> 00:03:46,980
as I go through this, I'm gonna ask that

00:03:46,980 --> 00:03:49,150
you focus on the concepts that we're gonna talk

00:03:49,150 --> 00:03:52,129
about. Cause these concepts for things that are independent

00:03:52,129 --> 00:03:55,239
of any particular programming languages, and they are concepts

00:03:55,239 --> 00:03:57,159
that will allow you, once you understand them, to

00:03:57,159 --> 00:03:59,769
start thinking about your code differently and start solving

00:03:59,769 --> 00:04:00,989
problems differently.

00:04:00,989 --> 00:04:02,790
And so that's really my hope is that after

00:04:02,790 --> 00:04:04,629
you leave here today, you'll have some new ways

00:04:04,629 --> 00:04:07,090
that you can think about code in terms of

00:04:07,090 --> 00:04:08,519
concurrency, and you'll have an interest in going out

00:04:08,519 --> 00:04:11,310
and starting to write more concurrent code, K.

00:04:11,310 --> 00:04:12,280
Most of the code we're gonna look at today

00:04:12,280 --> 00:04:13,530
is gonna be from a gem that I put

00:04:13,530 --> 00:04:17,840
together called concurrent_ruby. It's MIT License, opensource, available on

00:04:17,840 --> 00:04:20,410
GitHub. It's something that we use at VHT today,

00:04:20,410 --> 00:04:22,199
because we had some very specific needs we wanted

00:04:22,199 --> 00:04:22,600
to fulfill.

00:04:22,600 --> 00:04:24,610
And I'm gonna show you that gem, because it's

00:04:24,610 --> 00:04:26,590
the one I know the best. But it is

00:04:26,590 --> 00:04:29,710
by no means the, the best or canonical or

00:04:29,710 --> 00:04:32,699
right way to do it. These concepts, like I

00:04:32,699 --> 00:04:35,880
said, are concepts that are independent of any language

00:04:35,880 --> 00:04:37,280
and can be implemented in many different ways. I'm

00:04:37,280 --> 00:04:40,100
just gonna show you one possible way to use

00:04:40,100 --> 00:04:42,199
these particular ideas within Ruby.

00:04:42,199 --> 00:04:45,300
All right. So that being said, let's go ahead

00:04:45,300 --> 00:04:46,350
and move forward.

00:04:46,350 --> 00:04:47,440
In order to do this, we're gonna need a

00:04:47,440 --> 00:04:51,789
crash test dummy, all right. When writing code examples

00:04:51,789 --> 00:04:53,930
of concurrent code, often times we throw in these

00:04:53,930 --> 00:04:56,830
random sleep statements, and we say, something important happened

00:04:56,830 --> 00:04:58,740
here, all right. It's kind of fake when we

00:04:58,740 --> 00:05:00,250
do that. It sort of gets the point across,

00:05:00,250 --> 00:05:01,970
but it's not a really good example.

00:05:01,970 --> 00:05:03,990
So for this presentation, I created a class that

00:05:03,990 --> 00:05:06,139
we're gonna use as our crash test dummy in

00:05:06,139 --> 00:05:08,039
most of the examples that we're gonna go over

00:05:08,039 --> 00:05:10,419
today. And I put this class together on purpose,

00:05:10,419 --> 00:05:13,860
not to show good object-oriented design, because it's a

00:05:13,860 --> 00:05:17,180
really crappy design, but this class will express a

00:05:17,180 --> 00:05:19,880
couple of ideas that are very important to us

00:05:19,880 --> 00:05:21,080
when writing concurrent code.

00:05:21,080 --> 00:05:22,819
So let me show you the crash test dummy

00:05:22,819 --> 00:05:24,710
we're gonna use, K.

00:05:24,710 --> 00:05:26,770
This is a very simple class. It does one

00:05:26,770 --> 00:05:30,050
simple thing. When you create this, an instance of

00:05:30,050 --> 00:05:32,000
this, you're gonna pass a name of a company

00:05:32,000 --> 00:05:35,520
in. Yahoo, Microsoft, Apple, Google - whatever. When you

00:05:35,520 --> 00:05:37,810
call update on this, it's gonna go out to

00:05:37,810 --> 00:05:41,699
this Yahoo API, it's gonna retrieve information about what

00:05:41,699 --> 00:05:45,810
ticker symbols that company trades at, under, on different

00:05:45,810 --> 00:05:48,250
stock exchanges around the world, that data's gonna come

00:05:48,250 --> 00:05:50,569
back with some Ajax wrapper stuff around it, so

00:05:50,569 --> 00:05:51,759
we're gonna strip that off, and then we're gonna

00:05:51,759 --> 00:05:55,979
update this internal member variable with that data. Now.

00:05:55,979 --> 00:05:57,910
Here's a couple things to keep in mind. How

00:05:57,910 --> 00:06:01,060
many people here have heard that shared, mutable data

00:06:01,060 --> 00:06:04,699
is bad? All right. Whatever you were told is

00:06:04,699 --> 00:06:08,270
a lie. It's ter- it is ten times worse

00:06:08,270 --> 00:06:13,960
than that, right. Shared mutable data in concurrent programming

00:06:13,960 --> 00:06:15,729
is really bad.

00:06:15,729 --> 00:06:18,410
This thing is fat with shared mutable data. All

00:06:18,410 --> 00:06:20,940
right, first this thing goes out and it performs

00:06:20,940 --> 00:06:23,090
blocking IO, right. That's good for us in respect

00:06:23,090 --> 00:06:25,190
to concurrency, because blocking IO is one reason why

00:06:25,190 --> 00:06:26,860
we want to write concurrent code.

00:06:26,860 --> 00:06:29,759
But it then goes, and the object itself mutates

00:06:29,759 --> 00:06:32,080
when we go and we update it, which means,

00:06:32,080 --> 00:06:34,900
now, this thing, if we share it across threads,

00:06:34,900 --> 00:06:37,990
is shared mutable data. Even worse, this has an

00:06:37,990 --> 00:06:42,120
internal member variable which is an array of hashes,

00:06:42,120 --> 00:06:44,990
which we expose through and attribute reader. Which means

00:06:44,990 --> 00:06:47,500
we now are passing a reference to a mutable

00:06:47,500 --> 00:06:50,650
object outside of this thing, potentially across threads.

00:06:50,650 --> 00:06:53,949
So this thing is very, very dangerous, and that's

00:06:53,949 --> 00:06:55,639
why we're gonna use this as our example, because

00:06:55,639 --> 00:06:57,620
we're gonna show different ways that we can use

00:06:57,620 --> 00:07:01,120
this thing in a concurrent environment, and hopefully not

00:07:01,120 --> 00:07:02,919
keep ourselves up late trying to debug all kinds

00:07:02,919 --> 00:07:04,150
of weird bugs.

00:07:04,150 --> 00:07:06,759
So, with that, let's talk about the first concurrency

00:07:06,759 --> 00:07:09,099
object that we're gonna look at. It's called Future.

00:07:09,099 --> 00:07:11,009
How many people have heard of Future in terms

00:07:11,009 --> 00:07:13,150
of asynchronous concurrency? Cool.

00:07:13,150 --> 00:07:16,580
A Future is a general term to describe any

00:07:16,580 --> 00:07:21,199
particular operation that gets started and returns a result

00:07:21,199 --> 00:07:23,650
at some point in the future. OK, so it's

00:07:23,650 --> 00:07:27,550
a class of different types of, of asynchronous concurrency

00:07:27,550 --> 00:07:29,150
objects.

00:07:29,150 --> 00:07:32,400
Future also, very specifically, is one of the two

00:07:32,400 --> 00:07:36,020
core concurrency abstractions in the Clojure programming language. For

00:07:36,020 --> 00:07:37,840
those of you not familiar with Clojure, it's a

00:07:37,840 --> 00:07:40,069
Lisp-like language run from the JVM, which is designed

00:07:40,069 --> 00:07:42,849
specifically to be concurrency friendly.

00:07:42,849 --> 00:07:44,919
So here's how a future works - very simple.

00:07:44,919 --> 00:07:47,620
It's probably the simplest and more pure asynchronous concurrency

00:07:47,620 --> 00:07:49,270
abstraction. Here's how it works.

00:07:49,270 --> 00:07:51,169
You create a future and you give it some

00:07:51,169 --> 00:07:56,099
operation. At that point, the runtime schedules that operation

00:07:56,099 --> 00:07:59,680
as soon as possible, OK. A future has three

00:07:59,680 --> 00:08:02,830
states. It can be pending, which is what happens

00:08:02,830 --> 00:08:05,689
on creation. It's not done yet. Once the operation

00:08:05,689 --> 00:08:09,060
completes, it can be either fulfilled or rejected, K.

00:08:09,060 --> 00:08:11,970
If the operation completes successfully, it becomes fulfilled. If

00:08:11,970 --> 00:08:15,580
the operation throws it an exception, that exception gets

00:08:15,580 --> 00:08:20,970
swallowed, and the, the, the state becomes rejected.

00:08:20,970 --> 00:08:23,310
At that point, you can then retrieve either the

00:08:23,310 --> 00:08:26,689
value for the successful operation, or you can retrieve

00:08:26,689 --> 00:08:28,500
the reason for the rejection, which would be the,

00:08:28,500 --> 00:08:32,360
the exception that was thrown. So very simple. Very

00:08:32,360 --> 00:08:34,659
straight-forward. You basically throw this thing off on another

00:08:34,659 --> 00:08:37,120
thread, let the runtime schedule it, do important stuff,

00:08:37,120 --> 00:08:38,810
and then later on you come back and you

00:08:38,810 --> 00:08:40,550
ask, what was the result of that operation? And

00:08:40,550 --> 00:08:43,079
if it blows up, your program doesn't blow up,

00:08:43,079 --> 00:08:45,510
it just tells you that your operation blew up.

00:08:45,510 --> 00:08:46,110
So that's great.

00:08:46,110 --> 00:08:47,910
It's very simple, and it's a very easy way

00:08:47,910 --> 00:08:51,209
to start adding concurrency to your programs. Now, how

00:08:51,209 --> 00:08:54,120
many people are JavaScript programmers here? Right. So you

00:08:54,120 --> 00:08:57,420
guys are all familiar with call-backs, right? Whenever you're

00:08:57,420 --> 00:09:00,380
dealing with asynchronous concurrency, there are two ways that

00:09:00,380 --> 00:09:03,890
you can retrieve the results of the asynchronous operation.

00:09:03,890 --> 00:09:06,839
One, as we see here, is query the object,

00:09:06,839 --> 00:09:09,250
and say, what happened? The other way is to

00:09:09,250 --> 00:09:12,480
attach a call-back, right. This is the JavaScript way

00:09:12,480 --> 00:09:15,100
of doing things - we attach call-backs. Ruby, it

00:09:15,100 --> 00:09:18,839
turns out, has a very serviceable call-back mechanism built

00:09:18,839 --> 00:09:20,579
into the standard library.

00:09:20,579 --> 00:09:22,120
How many people here have heard of the observable

00:09:22,120 --> 00:09:25,529
module? Right. There you go. The observable module, which

00:09:25,529 --> 00:09:29,000
we know is based upon the game-of-four pattern observer,

00:09:29,000 --> 00:09:32,899
actually can work as a very fine call-back mechanism

00:09:32,899 --> 00:09:34,920
for any kind of asynchronous object.

00:09:34,920 --> 00:09:37,490
So in this particular library, I've tried to make

00:09:37,490 --> 00:09:39,630
it as consistent as possible and dependent only on

00:09:39,630 --> 00:09:41,519
the Ruby standard library. So in this case, this

00:09:41,519 --> 00:09:45,370
future class implementation is observable. So you can attach

00:09:45,370 --> 00:09:47,820
an observer to that, and then when the operation

00:09:47,820 --> 00:09:50,720
completes, the observable will be called, it will be

00:09:50,720 --> 00:09:52,810
given the time that the operation finished, it'll be

00:09:52,810 --> 00:09:56,390
given the value of the operation for the exception

00:09:56,390 --> 00:09:58,480
that was thrown. Very simple.

00:09:58,480 --> 00:10:00,610
Now, I want to take a step away from

00:10:00,610 --> 00:10:02,490
future for a second, and talk about a very

00:10:02,490 --> 00:10:05,339
important concept that is not unique to future but

00:10:05,339 --> 00:10:08,329
applies to all asynchronous concurrency, all right.

00:10:08,329 --> 00:10:12,610
There is a code smell on this string. Right.

00:10:12,610 --> 00:10:13,920
I'll even give you a hint to where it's

00:10:13,920 --> 00:10:17,260
at. It is up here on line eighteen. Now

00:10:17,260 --> 00:10:19,399
there's code smell. Think about it for a second,

00:10:19,399 --> 00:10:23,839
and I'll give you the answer what it is,

00:10:23,839 --> 00:10:24,019
all right.

00:10:24,019 --> 00:10:28,430
All advanced asynchronous concurrency abstractions try as much as

00:10:28,430 --> 00:10:32,290
possible to hide the details of concurrency from us.

00:10:32,290 --> 00:10:34,720
They try and hide the locking and the threading

00:10:34,720 --> 00:10:36,470
and all this other stuff that has to go

00:10:36,470 --> 00:10:38,529
on. But what we cannot do is change the

00:10:38,529 --> 00:10:41,519
actual nature of concurrent operations. And when we're dealing

00:10:41,519 --> 00:10:45,560
with concurrency, the order of operations is non-deterministic, OK.

00:10:45,560 --> 00:10:48,670
I'm sure you've heard that term before. It's non-deterministic.

00:10:48,670 --> 00:10:52,130
We cannot guarantee at what order things happen. So

00:10:52,130 --> 00:10:54,040
line eighteen right here, which looks fairly innocuous, is

00:10:54,040 --> 00:10:57,440
very interesting because, once we create this future on

00:10:57,440 --> 00:11:00,920
line seventeen, that block is scheduled for operation, and

00:11:00,920 --> 00:11:03,970
we have no control over when that thing occurs

00:11:03,970 --> 00:11:06,040
with respect to anything else.

00:11:06,040 --> 00:11:09,389
So it is theoretically possible that that operation could

00:11:09,389 --> 00:11:13,420
complete before we add the observer on line eighteen,

00:11:13,420 --> 00:11:16,639
K. That's just the nature of non-determinism.

00:11:16,639 --> 00:11:21,180
Now, in this particular case, right, this particular future

00:11:21,180 --> 00:11:24,290
implementation is aware of that and the add-observer method

00:11:24,290 --> 00:11:27,120
here behaves in a way that you would expect

00:11:27,120 --> 00:11:31,290
it to, despite that non-determinism. But the take-away from

00:11:31,290 --> 00:11:32,850
this, and this'll apply to everything we talk about

00:11:32,850 --> 00:11:37,050
today, is concurrency is non-deterministic, and that can never

00:11:37,050 --> 00:11:40,389
change, so always when using these concurrent abstractions, in

00:11:40,389 --> 00:11:43,029
any language, keep that non-determinism in mind.

00:11:43,029 --> 00:11:45,290
OK. So that's a future. We're gonna refer back

00:11:45,290 --> 00:11:46,560
to this a lot because you're gonna see the

00:11:46,560 --> 00:11:49,410
API of this future several times.

00:11:49,410 --> 00:11:51,209
Let's talk about another very interesting abstraction that comes

00:11:51,209 --> 00:11:54,480
out of Clojure. Let's talk about the Agent. Clojure

00:11:54,480 --> 00:11:58,680
has two core concurrency abstractions: future and agent, right.

00:11:58,680 --> 00:12:00,829
Agent is, Clojure is the only language I know

00:12:00,829 --> 00:12:02,250
of that does something like agent. It's very fascinating,

00:12:02,250 --> 00:12:04,029
and that's why I like to talk about it.

00:12:04,029 --> 00:12:06,550
I'll give you an example. Let's say you're writing

00:12:06,550 --> 00:12:08,649
a video game, and that video game is old-school

00:12:08,649 --> 00:12:10,949
arcade-style video game, and there's a score, all right,

00:12:10,949 --> 00:12:13,149
and you've got all kinds of threads running around

00:12:13,149 --> 00:12:14,630
doing different things, and each one of those threads

00:12:14,630 --> 00:12:15,699
wants to update the score.

00:12:15,699 --> 00:12:17,920
And the way we would do that in the

00:12:17,920 --> 00:12:20,540
old-school days was then put some kind of lock

00:12:20,540 --> 00:12:23,649
around that score, and every thread that wanted to

00:12:23,649 --> 00:12:26,050
change the score would have to obtain that lock

00:12:26,050 --> 00:12:27,769
and it would have to block until it got

00:12:27,769 --> 00:12:29,329
that lock and then it would update the score.

00:12:29,329 --> 00:12:31,010
So it happens that you have all these threads

00:12:31,010 --> 00:12:32,430
that want to be doing these different things, but

00:12:32,430 --> 00:12:33,649
every time they have to update the score, they

00:12:33,649 --> 00:12:35,570
have to block and go into contention with another.

00:12:35,570 --> 00:12:40,209
It's very inefficient, right. So the agent, from Clojure,

00:12:40,209 --> 00:12:42,829
turns that on its head and says, rather than

00:12:42,829 --> 00:12:47,029
putting the lock on the, the value that we

00:12:47,029 --> 00:12:50,850
want to change, let's instead queue up the operations

00:12:50,850 --> 00:12:53,779
against that value and do it sans-locking.

00:12:53,779 --> 00:12:55,589
So here's how the agent works.

00:12:55,589 --> 00:12:56,579
Right, and it's really fascinating.

00:12:56,579 --> 00:12:58,910
Create an agent and give it an initial value.

00:12:58,910 --> 00:13:01,360
The value can be anything, and the score the

00:13:01,360 --> 00:13:04,320
input would be like zero. K, then, when a

00:13:04,320 --> 00:13:07,380
thread wants to change that value, rather than getting

00:13:07,380 --> 00:13:11,089
the current value instead, it throws an operation at

00:13:11,089 --> 00:13:13,620
the agent, which is running on its own thread,

00:13:13,620 --> 00:13:18,540
and it says, perform this operation against that value.

00:13:18,540 --> 00:13:20,740
The agent itself then queues up all of these

00:13:20,740 --> 00:13:23,579
different operations, runs them one at a time, in

00:13:23,579 --> 00:13:26,279
order, so there's no contention amongst those operations. When

00:13:26,279 --> 00:13:28,660
an operation runs, it has complete access to that

00:13:28,660 --> 00:13:32,949
value. Another great thing about is that the operation

00:13:32,949 --> 00:13:35,440
we're sending doesn't have to have top-level knowledge of

00:13:35,440 --> 00:13:36,920
what the value is.

00:13:36,920 --> 00:13:39,759
When that block runs, the agent gives the block

00:13:39,759 --> 00:13:42,100
the current value, and the block returns what the

00:13:42,100 --> 00:13:45,850
new value is, right. And, much like many of

00:13:45,850 --> 00:13:48,149
the things in this library, this particular implementation of

00:13:48,149 --> 00:13:51,720
agent also supports the observable interface. So we can

00:13:51,720 --> 00:13:53,060
hang an observer off of this.

00:13:53,060 --> 00:13:54,600
So now let's go back to that video game

00:13:54,600 --> 00:13:57,610
score example. In that case, every thread, we create

00:13:57,610 --> 00:14:00,009
an agent, set its initial value to zero, and

00:14:00,009 --> 00:14:01,829
every thread that wants to then update the score

00:14:01,829 --> 00:14:03,820
can throw a block operation at that threa- at

00:14:03,820 --> 00:14:06,519
that agent. At any point in time, anything can

00:14:06,519 --> 00:14:09,449
retrieve the value of the agent. That retrieval, though,

00:14:09,449 --> 00:14:11,839
will get you the value at that time, irrespective

00:14:11,839 --> 00:14:14,820
if things are still queued up, right.

00:14:14,820 --> 00:14:17,350
But, we can then hang an observer off of

00:14:17,350 --> 00:14:20,110
that and make it the observer's responsibility to update

00:14:20,110 --> 00:14:22,339
the score on the screen, and now we can

00:14:22,339 --> 00:14:25,690
take that, that video game score type scenario and

00:14:25,690 --> 00:14:28,820
we can run that using agent with absolutely zero

00:14:28,820 --> 00:14:31,560
locking and zero blocking of our worker threads.

00:14:31,560 --> 00:14:34,399
And it's a very fascinating approach. Like I said,

00:14:34,399 --> 00:14:36,630
the idea for this comes from the language Clojure.

00:14:36,630 --> 00:14:39,500
Now, again I'm gonna take a step aside. We

00:14:39,500 --> 00:14:40,800
took a step aside a minute ago and talked

00:14:40,800 --> 00:14:43,540
about non-determinism. I'm gonna take a step aside and

00:14:43,540 --> 00:14:46,550
talk about another concept that's very important in concurrent

00:14:46,550 --> 00:14:48,130
programming.

00:14:48,130 --> 00:14:52,180
This code right here is horribly, horribly broken. All

00:14:52,180 --> 00:14:55,040
right. The agent does exactly what it's supposed to

00:14:55,040 --> 00:14:56,839
do, but the way I use the agent in

00:14:56,839 --> 00:14:59,839
this code is ridiculously broken and bad. Take a

00:14:59,839 --> 00:15:01,259
second to look at it and think about it

00:15:01,259 --> 00:15:02,690
and I'll tell you what the problem is.

00:15:02,690 --> 00:15:05,949
K. I gave you a hint earlier on, during

00:15:05,949 --> 00:15:08,060
the introduction. I said there's something that we really

00:15:08,060 --> 00:15:10,380
need to worry about that's really, really, really bad.

00:15:10,380 --> 00:15:13,910
And that's mutation, K.

00:15:13,910 --> 00:15:16,420
The value that we gave to that agent is

00:15:16,420 --> 00:15:19,040
an array, right. And that is an array of

00:15:19,040 --> 00:15:23,529
hashes. And those are mutable data structures. So whenever

00:15:23,529 --> 00:15:26,320
we retrieve the value from that agent, we are

00:15:26,320 --> 00:15:30,670
retrieving a reference to a mutable data structure.

00:15:30,670 --> 00:15:33,319
So although that agent will queue up those operations

00:15:33,319 --> 00:15:35,300
on one thread to make sure they don't compete

00:15:35,300 --> 00:15:38,040
with one another, any thread that has a handle

00:15:38,040 --> 00:15:40,300
to that agent and wants to get that value

00:15:40,300 --> 00:15:44,300
is gonna be retrieving a mutable reference, right. And

00:15:44,300 --> 00:15:46,160
that's really bad. That can lead to a lot

00:15:46,160 --> 00:15:49,290
of pain and agony. Don't do that.

00:15:49,290 --> 00:15:50,500
So here's the question - how do we avoid

00:15:50,500 --> 00:15:52,420
doing that? Cause, let's be honest. We're working in

00:15:52,420 --> 00:15:54,899
Ruby. A lot of the languages that are concurrency-friendly

00:15:54,899 --> 00:15:58,300
are things like Clojure and Erlang and Haskel that

00:15:58,300 --> 00:16:02,019
have immutable variables. Ruby does not have immutable variables.

00:16:02,019 --> 00:16:02,560
Problem.

00:16:02,560 --> 00:16:04,990
So how do we solve this problem? In this

00:16:04,990 --> 00:16:10,040
case, we solve it with a hamster.

00:16:10,040 --> 00:16:12,459
Did anybody see that coming?

00:16:12,459 --> 00:16:14,149
In 2000, a gentleman named Phill Bagwell started doing

00:16:14,149 --> 00:16:15,910
some research into something called a tri. All right,

00:16:15,910 --> 00:16:19,000
a tri is a high-performance tree-like data structure which

00:16:19,000 --> 00:16:21,670
every node has at least two hundred and fifty-six

00:16:21,670 --> 00:16:23,490
other nodes hanging off of it.

00:16:23,490 --> 00:16:25,300
By having two-hundred and fifty-six nodes off of every

00:16:25,300 --> 00:16:28,440
node, we can have one million nodes in a

00:16:28,440 --> 00:16:31,069
tri with only three levels deep, which gives us

00:16:31,069 --> 00:16:34,459
incredibly fast access to those nodes.

00:16:34,459 --> 00:16:36,470
He then followed that up with something called an

00:16:36,470 --> 00:16:38,589
ideal hash tree. Has anybody heard of an ideal

00:16:38,589 --> 00:16:40,850
hash tree? All right, an ideal hash tree is

00:16:40,850 --> 00:16:44,480
a very high-performance data structure which allows you to

00:16:44,480 --> 00:16:48,339
create immutable data structures, but have them perform very

00:16:48,339 --> 00:16:50,839
fast, because what you're doing is in the tree,

00:16:50,839 --> 00:16:53,790
you're storing indexes to the objects, you're not, and

00:16:53,790 --> 00:16:56,040
when you copy things, you are now copying the

00:16:56,040 --> 00:16:57,829
indexes, not the objects themselves.

00:16:57,829 --> 00:17:01,779
An ideal hash tree is the underlying engine that

00:17:01,779 --> 00:17:03,310
makes Clojure work.

00:17:03,310 --> 00:17:08,730
Clojure gets its immutable variables with high performance list

00:17:08,730 --> 00:17:11,970
comprehensions because the underlying engine is this thing called

00:17:11,970 --> 00:17:15,630
an ideal hash tree. Well, fortunately for us, a

00:17:15,630 --> 00:17:18,120
couple of Rubyists went and read the same papers

00:17:18,120 --> 00:17:20,320
by Phil Bagwell and had the same ideas, and

00:17:20,320 --> 00:17:22,230
they created a library for us that provides us

00:17:22,230 --> 00:17:25,720
with high performance immutable data structures, and that particular

00:17:25,720 --> 00:17:27,790
library is called Hamster, k.

00:17:27,790 --> 00:17:32,300
Hamster's an opensource gem. It proves a threadsafe, immutable,

00:17:32,300 --> 00:17:34,640
high-performance data structure. So now what we've done in

00:17:34,640 --> 00:17:37,080
this case is we've replaced that example of the

00:17:37,080 --> 00:17:39,700
agent we used before, getting rid of the array,

00:17:39,700 --> 00:17:42,550
which is not safe, putting in our Hamster vector

00:17:42,550 --> 00:17:44,670
instead. Now every time we operate in that vector

00:17:44,670 --> 00:17:46,720
we of course have to replace the vector, cause

00:17:46,720 --> 00:17:49,110
it's a non-mutable struct- immutable data structure.

00:17:49,110 --> 00:17:51,790
But really all we're doing is internally just replacing

00:17:51,790 --> 00:17:54,170
the indexing, and it's doing it for me fast.

00:17:54,170 --> 00:17:57,320
So now we've created a thread safe immutable data

00:17:57,320 --> 00:17:58,890
structure inside of our agent, and now we get

00:17:58,890 --> 00:18:02,230
the behavior that we wanted with absolute and complete

00:18:02,230 --> 00:18:02,970
safety, k.

00:18:02,970 --> 00:18:06,440
So the point to understand is in Ruby, we

00:18:06,440 --> 00:18:09,640
have mutable variables. Mutable variables are bad in concurrency,

00:18:09,640 --> 00:18:12,880
so when you are using variables, passing variables across

00:18:12,880 --> 00:18:16,700
threads, make sure you, whenever possible, make them immutable.

00:18:16,700 --> 00:18:19,960
Now, the second example is an important one for

00:18:19,960 --> 00:18:20,310
comparison.

00:18:20,310 --> 00:18:22,690
This, the second example is from a library called

00:18:22,690 --> 00:18:25,720
thread_safe. It's written by one of the people from

00:18:25,720 --> 00:18:29,340
the JRuby core team, and it provides thread-safe implementations

00:18:29,340 --> 00:18:32,730
of Ruby's hash and array. It is a really,

00:18:32,730 --> 00:18:34,580
really great library that does really, really great work,

00:18:34,580 --> 00:18:36,490
and it's something you should definitely know about if

00:18:36,490 --> 00:18:39,870
you're doing concurrent code, because thread safety is important.

00:18:39,870 --> 00:18:42,290
But notice, with that, we still have the same

00:18:42,290 --> 00:18:45,630
problem we had before, cause it's still mutable, K.

00:18:45,630 --> 00:18:48,890
We're still passing mutable records. So, you definitely should

00:18:48,890 --> 00:18:50,480
get to know thread_safe, you definitely should get to

00:18:50,480 --> 00:18:52,680
know Hamster. You should definitely be aware of thread-safety,

00:18:52,680 --> 00:18:57,020
but remember, whenever possible, immutability is the best.

00:18:57,020 --> 00:19:00,310
So. So there's JavaScript programmers. How many JavaScript programmers

00:19:00,310 --> 00:19:04,140
in here are familiar with promises? All right.

00:19:04,140 --> 00:19:08,220
So a promise is a contract between you and

00:19:08,220 --> 00:19:10,690
something that happens on another thread. A promise is

00:19:10,690 --> 00:19:13,570
a very popular data struct- or excuse me, concurrency

00:19:13,570 --> 00:19:17,630
abstraction in JavaScript, and it's divined by two specifications.

00:19:17,630 --> 00:19:20,290
Promises a and promises a plus.

00:19:20,290 --> 00:19:23,410
Promise is basically a future, right. It's part of

00:19:23,410 --> 00:19:24,970
that general class of future. We send it this

00:19:24,970 --> 00:19:27,730
thing off with the promise, and it promises to

00:19:27,730 --> 00:19:29,080
us that it will get us a value at

00:19:29,080 --> 00:19:30,630
some point.

00:19:30,630 --> 00:19:33,160
Promises as expressed in JavaScript are very different than

00:19:33,160 --> 00:19:36,120
the future that we saw earlier in one special

00:19:36,120 --> 00:19:39,820
way. Promises are chainable, K. The future we looked

00:19:39,820 --> 00:19:42,470
at earlier was a one-shot deal. Send it out

00:19:42,470 --> 00:19:44,160
there, it does its thing, it returns a value

00:19:44,160 --> 00:19:47,260
and it becomes immutable at that point. Done.

00:19:47,260 --> 00:19:49,400
Promises are chainable. A promise can beget a promise

00:19:49,400 --> 00:19:51,110
can beget a promise can beget a promise. They're

00:19:51,110 --> 00:19:53,160
not only chainable, but you can make trees out

00:19:53,160 --> 00:19:55,860
of them as well, K. In order to make

00:19:55,860 --> 00:19:58,260
that work, there are some actual some error-handling semantics

00:19:58,260 --> 00:20:00,930
built on there, too. You can say, when this

00:20:00,930 --> 00:20:03,260
happens, rescue this, on error this and so on

00:20:03,260 --> 00:20:03,940
and sort forth.

00:20:03,940 --> 00:20:06,480
So a promise is very much like a future

00:20:06,480 --> 00:20:09,600
in this implementation a promise supports all the same

00:20:09,600 --> 00:20:11,700
methods we saw earlier on future. The idea of

00:20:11,700 --> 00:20:15,000
state being pending, fulfilled, rejected. Value, reason and so

00:20:15,000 --> 00:20:18,460
forth. The difference is, however, the chainability of this.

00:20:18,460 --> 00:20:21,720
There's greater internal plexy to make that happen, but

00:20:21,720 --> 00:20:23,410
you can then use that in a very similar

00:20:23,410 --> 00:20:25,520
way, especially for chaining.

00:20:25,520 --> 00:20:30,820
In this particular case, promise does not implement observable,

00:20:30,820 --> 00:20:32,420
and the reason why is that in this case,

00:20:32,420 --> 00:20:35,290
the call-back mechanism is built into promise through the,

00:20:35,290 --> 00:20:37,860
the chaining, right. So promise, like I said this

00:20:37,860 --> 00:20:41,580
particular implementation is very true to promises a and

00:20:41,580 --> 00:20:44,410
a plus specifications from JavaScript, but it's a Ruby-ish

00:20:44,410 --> 00:20:45,120
library.

00:20:45,120 --> 00:20:49,940
OK. How many people know what Chron is? That

00:20:49,940 --> 00:20:52,660
should be everybody in the room. So one of

00:20:52,660 --> 00:20:54,520
the things that we oftentimes want to do is

00:20:54,520 --> 00:20:56,660
we want to have a task or something that

00:20:56,660 --> 00:20:59,130
occurs at a very specific time. If you're in

00:20:59,130 --> 00:21:01,050
Rails land, there are gems that allow us to

00:21:01,050 --> 00:21:03,290
do this, right. But if you're outside of Rails

00:21:03,290 --> 00:21:05,640
land, not quite so easy.

00:21:05,640 --> 00:21:09,250
So looking at Java, of all languages, Java provides

00:21:09,250 --> 00:21:11,700
this really cool abstraction that allows us to handle

00:21:11,700 --> 00:21:13,630
this thing where we want to have something happen

00:21:13,630 --> 00:21:16,400
at a certain time. Now of course because it's

00:21:16,400 --> 00:21:18,630
Java, it has a really stupid name. It's called

00:21:18,630 --> 00:21:22,440
the scheduled executor service.

00:21:22,440 --> 00:21:24,790
But it's actually a really cool abstraction. And so

00:21:24,790 --> 00:21:27,400
because I'm not a Java person I'm gonna call

00:21:27,400 --> 00:21:30,760
it schedule task. So this implementation schedule_task is based

00:21:30,760 --> 00:21:34,000
upon Java scheduled executive service, and it does basically

00:21:34,000 --> 00:21:36,900
the same thing. You create this thing, you pass

00:21:36,900 --> 00:21:38,030
it a block. And you say, I want this

00:21:38,030 --> 00:21:40,510
operation to occur at a certain time, right.

00:21:40,510 --> 00:21:42,750
And then you can say either this many seconds

00:21:42,750 --> 00:21:45,360
from now, or at this specific time. Right. Then

00:21:45,360 --> 00:21:47,960
it just goes off and it does that, right.

00:21:47,960 --> 00:21:50,630
This supports the same, for consistency, supports the same

00:21:50,630 --> 00:21:52,490
kind of interface that we saw in future earlier,

00:21:52,490 --> 00:21:54,420
cause I'm, I'm not that smart and I like

00:21:54,420 --> 00:21:56,460
things to work the same so I can remember

00:21:56,460 --> 00:21:57,010
them.

00:21:57,010 --> 00:21:58,870
So it provides us with a state that's pending

00:21:58,870 --> 00:22:02,030
and fulfilled and reject, and provides us value and

00:22:02,030 --> 00:22:03,450
reason and so forth. And this can go ahead

00:22:03,450 --> 00:22:05,510
and go on and make that operation occur at

00:22:05,510 --> 00:22:08,400
a specific time. Now, the astute among you might

00:22:08,400 --> 00:22:10,250
be saying, all right, Jerry, that's really cool, but

00:22:10,250 --> 00:22:12,500
how is that different from just basically creating a

00:22:12,500 --> 00:22:14,510
future and making the thing go to sleep, you

00:22:14,510 --> 00:22:15,870
know, when you first create it?

00:22:15,870 --> 00:22:17,890
Well, it really isn't. I mean, I could literally

00:22:17,890 --> 00:22:19,400
do the same thing by creating a future and

00:22:19,400 --> 00:22:21,450
having the first line of the block I passed

00:22:21,450 --> 00:22:24,110
the future be sleep. There's two reasons why I

00:22:24,110 --> 00:22:24,690
don't.

00:22:24,690 --> 00:22:27,990
One, is cancel-ability, right. The intent of a future

00:22:27,990 --> 00:22:30,340
is to say go and do this right now.

00:22:30,340 --> 00:22:33,490
The intent of a scheduled task is go and

00:22:33,490 --> 00:22:35,200
do this later. So a scheduled task can be

00:22:35,200 --> 00:22:37,240
canceled. You can't cancel a future. Once you set

00:22:37,240 --> 00:22:39,760
that thing in motion it's done, right. It's just

00:22:39,760 --> 00:22:40,510
gonna work.

00:22:40,510 --> 00:22:42,660
This allows us to cancel it. There's another reason.

00:22:42,660 --> 00:22:45,130
It's more important, and again, this is something that,

00:22:45,130 --> 00:22:47,840
it transcends this particular implementation but is true of

00:22:47,840 --> 00:22:50,620
concurrency abstractions in general, K.

00:22:50,620 --> 00:22:54,470
And it's the idea of intent. You'll notice as

00:22:54,470 --> 00:22:56,350
we've gone through this that we've worked very hard

00:22:56,350 --> 00:22:59,600
to decouple our business logic from our concurrency logic.

00:22:59,600 --> 00:23:02,260
It's done on purpose, all right. If you've ever

00:23:02,260 --> 00:23:05,430
tried to test concurrent business logic, you found out

00:23:05,430 --> 00:23:08,780
that it's probably very hard and painful, all right.

00:23:08,780 --> 00:23:10,500
When we test, we set things at a known

00:23:10,500 --> 00:23:13,220
state, we change that state and verify that the

00:23:13,220 --> 00:23:16,050
new state is what it's supposed to be. Concurrency

00:23:16,050 --> 00:23:19,420
is non-deterministic. It is very hard in a concurrent

00:23:19,420 --> 00:23:22,260
environment to create a known state. That's the whole

00:23:22,260 --> 00:23:22,950
problem.

00:23:22,950 --> 00:23:27,080
So if you decouple your business logic from your

00:23:27,080 --> 00:23:29,880
concurrency logic, you can test the business logic in

00:23:29,880 --> 00:23:32,380
a way that's not concurrent, make sure that your

00:23:32,380 --> 00:23:34,500
business logic does exactly what it's supposed to do

00:23:34,500 --> 00:23:37,450
- our crash test dummy example being that. Make

00:23:37,450 --> 00:23:39,120
sure it does what it's supposed to do.

00:23:39,120 --> 00:23:42,850
Then you can take a concurrency abstraction that is

00:23:42,850 --> 00:23:45,370
tested and that has defined behavior and does a

00:23:45,370 --> 00:23:48,130
specific thing, and you can put the two together

00:23:48,130 --> 00:23:50,650
with a very minimal intersection, and now you're testing

00:23:50,650 --> 00:23:52,850
a concurrency becomes minimal, because you just have to

00:23:52,850 --> 00:23:54,940
test an intersection, right.

00:23:54,940 --> 00:23:57,100
So when we do that, now we have code

00:23:57,100 --> 00:24:00,630
that very clearly expresses intent. When I'm looking at

00:24:00,630 --> 00:24:03,990
code and you see something that says schedule task,

00:24:03,990 --> 00:24:06,620
that expresses intent. It has meaning. It tells you

00:24:06,620 --> 00:24:09,270
that there are certain concurrent behaviors going on.

00:24:09,270 --> 00:24:12,170
You see something called future. That expresses intent. You

00:24:12,170 --> 00:24:15,500
see something called agent, that expresses intent. So although

00:24:15,500 --> 00:24:19,180
in this case we could have simulated schedule task

00:24:19,180 --> 00:24:21,710
with future, or in fact we could have simulated

00:24:21,710 --> 00:24:23,020
all of these things with something called actor that

00:24:23,020 --> 00:24:25,610
we're gonna look at later on. By having a

00:24:25,610 --> 00:24:28,460
abstraction that does one thing very well we better

00:24:28,460 --> 00:24:33,240
express intent and we allow ourselves to optimize that

00:24:33,240 --> 00:24:35,500
abstraction for the thing it needs to do.

00:24:35,500 --> 00:24:38,300
So, schedule_task, in this case, looks very much like

00:24:38,300 --> 00:24:40,600
future, but it has that scheduling.

00:24:40,600 --> 00:24:41,740
Now for all of us who like to use

00:24:41,740 --> 00:24:44,770
Chrone - oh, and also, in this particular case,

00:24:44,770 --> 00:24:47,270
this implementation schedule_task does, of course, support observer as

00:24:47,270 --> 00:24:49,490
well, so that we can have that call-back type

00:24:49,490 --> 00:24:51,810
ability, right. Again, I'm not very bright. I like

00:24:51,810 --> 00:24:53,720
my things to work consistently so I can remember

00:24:53,720 --> 00:24:56,650
how they go. So this observ- is observable as

00:24:56,650 --> 00:24:57,300
well.

00:24:57,300 --> 00:24:59,290
So getting back to that Chrone example, we have

00:24:59,290 --> 00:25:02,170
another reason to use Chrone is repetition. We want

00:25:02,170 --> 00:25:03,980
something to happen over and over and over and

00:25:03,980 --> 00:25:06,310
over again. Whether it's every five seconds or every

00:25:06,310 --> 00:25:09,640
minute or every ten minutes or whatever, K.

00:25:09,640 --> 00:25:11,710
Java provides us with a really cool abstraction to

00:25:11,710 --> 00:25:16,420
do that too. And unlike scheduled executor service, the

00:25:16,420 --> 00:25:18,660
abstraction for this in Java actually has a name

00:25:18,660 --> 00:25:23,250
that's not entirely stupid. It's called a timer_task, right.

00:25:23,250 --> 00:25:26,960
So a timer_task is simply this. It says, here's

00:25:26,960 --> 00:25:29,350
an operation I want you to perform. I want

00:25:29,350 --> 00:25:32,570
to perform at this particular interval, five seconds- however

00:25:32,570 --> 00:25:35,670
many seconds, right - and if that tasks takes

00:25:35,670 --> 00:25:38,160
longer than a certain timeout value, kill it.

00:25:38,160 --> 00:25:41,340
Now this is broken, K. You know, I notice

00:25:41,340 --> 00:25:43,500
though, one thing different about this from the things

00:25:43,500 --> 00:25:45,610
we saw before is this is a run method

00:25:45,610 --> 00:25:47,870
that we're calling on here, on line nine.

00:25:47,870 --> 00:25:48,960
Remember that when we come back to that in

00:25:48,960 --> 00:25:49,670
a minute, K.

00:25:49,670 --> 00:25:51,880
So I create this timer task, we give it

00:25:51,880 --> 00:25:53,960
the timer values, we send this thing off and

00:25:53,960 --> 00:25:55,350
just say just go do this thing over and

00:25:55,350 --> 00:25:58,450
over and over again, K. Shouldn't surprise you by

00:25:58,450 --> 00:26:02,290
now that, in this particular implementation, cause, you know,

00:26:02,290 --> 00:26:05,800
we like consistency, it also supports observability as well,

00:26:05,800 --> 00:26:08,050
K. So we can have this timer task go,

00:26:08,050 --> 00:26:09,610
we can run it, we can attach an observer

00:26:09,610 --> 00:26:11,860
to it, and every time that it occurs, we

00:26:11,860 --> 00:26:14,180
can have the observer or observers respond to that

00:26:14,180 --> 00:26:16,130
in a call-back like fashion, K.

00:26:16,130 --> 00:26:20,090
Now, so one of the things that this does,

00:26:20,090 --> 00:26:21,250
one of my co-workers is using this in a

00:26:21,250 --> 00:26:23,770
project he's working on, he came to me and

00:26:23,770 --> 00:26:25,420
said, how do I stop this thing once it's

00:26:25,420 --> 00:26:27,770
started? I'm like, what do you mean, it's supposed

00:26:27,770 --> 00:26:28,550
to go forever.

00:26:28,550 --> 00:26:30,640
You can call stop on it, but you'd call

00:26:30,640 --> 00:26:32,240
that, but I don't wanna, see, but I don't

00:26:32,240 --> 00:26:33,870
wanna call stop from main thread. He said, what

00:26:33,870 --> 00:26:36,930
happens if within the block that's running, there's something

00:26:36,930 --> 00:26:39,870
occurs, and I want to, based upon that logic,

00:26:39,870 --> 00:26:41,230
change the execution whenever I want to shut this

00:26:41,230 --> 00:26:42,060
thing down?

00:26:42,060 --> 00:26:44,250
So I thought, it's a good use case I

00:26:44,250 --> 00:26:45,700
hadn't thought of. but it's very smart one. So,

00:26:45,700 --> 00:26:47,650
based upon that, him and I sat down. We

00:26:47,650 --> 00:26:49,330
paired and created small changes and said, you know

00:26:49,330 --> 00:26:52,170
what, let's just, inside that block, every time it

00:26:52,170 --> 00:26:56,200
executes, lets pass a reference to the task itself.

00:26:56,200 --> 00:27:00,290
Basically, self. Right. Within the block, self isn't gonna

00:27:00,290 --> 00:27:01,570
be what we want it to be, so we'll

00:27:01,570 --> 00:27:05,490
pass that task in. Now, that scheduled task has

00:27:05,490 --> 00:27:07,780
the ability to change its own life cycle within

00:27:07,780 --> 00:27:10,990
the block by changing its own timer values or

00:27:10,990 --> 00:27:15,610
by making or stopping itself if necessary. OK.

00:27:15,610 --> 00:27:17,590
Now last, a really important topic we're gonna talk

00:27:17,590 --> 00:27:19,980
about, well, not the last topic, but really, a

00:27:19,980 --> 00:27:22,650
big topic. Let me ask this question: How many

00:27:22,650 --> 00:27:26,540
people have heard of the actor model for concurrency?

00:27:26,540 --> 00:27:27,660
OK.

00:27:27,660 --> 00:27:31,390
Good. How many people have heard - so, Always

00:27:31,390 --> 00:27:33,980
Sunny in Philadelphia for those of you who don't

00:27:33,980 --> 00:27:34,590
know.

00:27:34,590 --> 00:27:37,110
How many people here have heard that Erlang implements

00:27:37,110 --> 00:27:40,980
the actor model for concurrency? A few? All right.

00:27:40,980 --> 00:27:43,600
So actor model is sort of a big deal

00:27:43,600 --> 00:27:46,030
these days. Now here's the interesting - now, I've

00:27:46,030 --> 00:27:47,480
been doing this a long time, nearly twenty years,

00:27:47,480 --> 00:27:48,790
and if there's one thing I've learned in twenty

00:27:48,790 --> 00:27:50,850
years of being a programmer, is if there's anything

00:27:50,850 --> 00:27:53,470
that programmers want to talk about, apparently it's also

00:27:53,470 --> 00:27:56,340
worth getting into ridiculous flame wars over.

00:27:56,340 --> 00:27:59,510
And actor, the actor model for concurrency is the

00:27:59,510 --> 00:28:02,270
same thing. K. This is surprisingly controversial in some

00:28:02,270 --> 00:28:05,020
circles, K. There are some people who think that

00:28:05,020 --> 00:28:07,260
the actor model can only do concurrency and everything

00:28:07,260 --> 00:28:08,750
else should just go away, and there are people

00:28:08,750 --> 00:28:10,450
who think that they're completely wrong, right.

00:28:10,450 --> 00:28:12,680
Not gonna weigh into that debate. Just understand that

00:28:12,680 --> 00:28:16,260
debate, they exist. There's also a debate about what,

00:28:16,260 --> 00:28:19,900
exactly, an actor is. So here's the thing, at,

00:28:19,900 --> 00:28:23,640
the actor model was first proposed in 1973, right.

00:28:23,640 --> 00:28:27,920
A gentleman named Caller Hewitt and his associates working

00:28:27,920 --> 00:28:30,910
at the MIT Artificial Intelligence lab, published a paper

00:28:30,910 --> 00:28:32,910
called The Actor Model for Concurrency.

00:28:32,910 --> 00:28:35,870
Well, it shouldn't surprise you that in the past

00:28:35,870 --> 00:28:39,090
forty years, a lot has changed with respect to

00:28:39,090 --> 00:28:42,420
programming. What they really described in this paper was

00:28:42,420 --> 00:28:44,590
a pattern, right. They weren't, they weren't using the

00:28:44,590 --> 00:28:46,690
term pattern the same way back then. So they

00:28:46,690 --> 00:28:48,840
don't call it a pattern. But they said, we've

00:28:48,840 --> 00:28:50,970
seen a bunch of things that behave a certain

00:28:50,970 --> 00:28:53,420
way, and we're gonna document the way these things

00:28:53,420 --> 00:28:53,810
behave.

00:28:53,810 --> 00:28:56,120
And anything that behaves this way we're gonna retroactively

00:28:56,120 --> 00:28:58,800
call an actor. Right. This is also before the

00:28:58,800 --> 00:29:01,040
days of object orientation, long before Gang of Four

00:29:01,040 --> 00:29:04,640
wrote their book, so we didn't have great diagramming

00:29:04,640 --> 00:29:07,770
techniques for creating class and object designs.

00:29:07,770 --> 00:29:09,990
So they used the only notation that they knew

00:29:09,990 --> 00:29:13,120
at the time, which was a mathematical notation, which

00:29:13,120 --> 00:29:15,920
means this paper, which is very fascinating to read,

00:29:15,920 --> 00:29:20,290
is, has very limited direct applicability to today. The

00:29:20,290 --> 00:29:22,380
ideas, forty years later, are still very good, but

00:29:22,380 --> 00:29:24,770
the paper, as far as being a blueprint for

00:29:24,770 --> 00:29:27,370
creating an actor, is very limited.

00:29:27,370 --> 00:29:30,480
So as a result, today in 2013, there is

00:29:30,480 --> 00:29:36,090
no single universally agreed upon strict definition of what

00:29:36,090 --> 00:29:39,690
an actor is. Additionally, there is no one canonical

00:29:39,690 --> 00:29:42,510
implementation of actor. If you look at everything that

00:29:42,510 --> 00:29:45,160
people- that claims to be an actor, and things

00:29:45,160 --> 00:29:47,370
that people claim are actors even when they don't

00:29:47,370 --> 00:29:49,350
claim to be actors themselves - they all look

00:29:49,350 --> 00:29:51,160
very, very different.

00:29:51,160 --> 00:29:52,640
And so that leads to a lot of debate

00:29:52,640 --> 00:29:54,620
within the actor community about what really an actor

00:29:54,620 --> 00:29:57,300
should look like. K.

00:29:57,300 --> 00:29:59,450
So for the purposes of this presentation, I'm going

00:29:59,450 --> 00:30:01,950
to give you my definition of actor. OK, I'm

00:30:01,950 --> 00:30:03,610
sure I'm gonna get flamed for it by somebody,

00:30:03,610 --> 00:30:05,480
but, you know, we have to move forward.

00:30:05,480 --> 00:30:08,090
So here's my definition of actor. An actor is

00:30:08,090 --> 00:30:15,090
an independent single purpose concurrent computational entity. Again, an

00:30:16,020 --> 00:30:23,020
independent single purpose concurrent computational entity that communicates via

00:30:23,980 --> 00:30:28,700
messages, K. It's gotta, it's gotta do something. It's

00:30:28,700 --> 00:30:31,750
got to be independent computational entity that does something.

00:30:31,750 --> 00:30:35,400
A class called actor is not an actor. A

00:30:35,400 --> 00:30:38,970
class called actor can create an object which behaves

00:30:38,970 --> 00:30:41,640
as an actor, but it's gotta be something that

00:30:41,640 --> 00:30:42,180
does something.

00:30:42,180 --> 00:30:44,010
It has to be concurrent. All right, that was

00:30:44,010 --> 00:30:45,720
one of the key things about the original paper.

00:30:45,720 --> 00:30:48,660
And it has to be single-purpose. Now this is

00:30:48,660 --> 00:30:51,670
critical. When Hewitt and his colleagues wrote this paper,

00:30:51,670 --> 00:30:57,200
they, their examples were people performing a play on

00:30:57,200 --> 00:30:58,990
a stage.

00:30:58,990 --> 00:31:02,900
Every actor fulfills a role. Every actor plays that

00:31:02,900 --> 00:31:06,120
role. There is not a tremendous amount of, there's

00:31:06,120 --> 00:31:09,670
no overriding control of those actors. They're all acting

00:31:09,670 --> 00:31:13,970
independently. But they coordinate amongst themselves to do something

00:31:13,970 --> 00:31:16,320
greater than the sum of its parts.

00:31:16,320 --> 00:31:19,260
So an actor must perform a role in order

00:31:19,260 --> 00:31:21,670
to be an actor, K. And one of the

00:31:21,670 --> 00:31:23,880
key things about the original Huett paper was it

00:31:23,880 --> 00:31:26,510
said, y ou must communicate via messages, K. Now

00:31:26,510 --> 00:31:29,740
they didn't define what a message is, and that's

00:31:29,740 --> 00:31:31,690
one of the areas where there's a lot of

00:31:31,690 --> 00:31:33,780
contention these days is, what constitutes a message?

00:31:33,780 --> 00:31:36,930
Now, if you were using Erlang, or using Scala,

00:31:36,930 --> 00:31:40,030
or some language like that, they have built-in inter-process

00:31:40,030 --> 00:31:44,090
messaging systems, right. The bang operator in Erlang is

00:31:44,090 --> 00:31:46,480
a way of one process sending a message to

00:31:46,480 --> 00:31:47,120
another process.

00:31:47,120 --> 00:31:49,960
A message in that case is pretty cut and

00:31:49,960 --> 00:31:53,880
dry. In Ruby, we have no similar underlying communication

00:31:53,880 --> 00:31:57,110
mechanism to define a message. Therefore in Ruby it's

00:31:57,110 --> 00:31:59,670
kind of hard to decide what constitutes a message.

00:31:59,670 --> 00:32:00,080
So.

00:32:00,080 --> 00:32:01,790
The example I'm gonna show you, the example I

00:32:01,790 --> 00:32:05,030
like the best, is by no means the right

00:32:05,030 --> 00:32:07,410
example or the canonical example and I'm sure a

00:32:07,410 --> 00:32:08,570
lot of people will think that my choice is

00:32:08,570 --> 00:32:10,910
not good, and that's fine, but the example I'm

00:32:10,910 --> 00:32:13,850
gonna show you is based upon Scala's actor class

00:32:13,850 --> 00:32:16,840
for, a trait, excuse me, from the Scala standard

00:32:16,840 --> 00:32:17,910
library.

00:32:17,910 --> 00:32:21,120
Now Scala has since deprecated this particular trait and

00:32:21,120 --> 00:32:25,360
moved on to the acka library. But this particular

00:32:25,360 --> 00:32:28,830
implementation of actor from Scala served Scala programmers very

00:32:28,830 --> 00:32:31,380
well for a number of years, and it exhibits

00:32:31,380 --> 00:32:32,950
all of the things an actor is supposed to

00:32:32,950 --> 00:32:34,690
exhibit, and its also very simple. And I'm a

00:32:34,690 --> 00:32:37,170
simple guy. I like simple libraries that are loosely

00:32:37,170 --> 00:32:39,720
coupled and that give me things that work really

00:32:39,720 --> 00:32:41,190
well by themselves.

00:32:41,190 --> 00:32:42,920
So here's how this works.

00:32:42,920 --> 00:32:47,000
Straightforward. You extend the actor class. The actor class

00:32:47,000 --> 00:32:50,290
there, then gives your object all of the message

00:32:50,290 --> 00:32:53,540
patching semantics it needs. It gives it the threading

00:32:53,540 --> 00:32:54,980
it needs so this thing can run on its

00:32:54,980 --> 00:32:58,210
own thread, right, and it handles queuing of the

00:32:58,210 --> 00:33:01,460
messages. Every time a message comes in, it calls

00:33:01,460 --> 00:33:05,560
the act methods, which you, in your subclass, override,

00:33:05,560 --> 00:33:07,820
in order to give your actor some behavior, right.

00:33:07,820 --> 00:33:09,620
In this case, this is a pretty simple example,

00:33:09,620 --> 00:33:11,950
all its gonna do is basically echo the message

00:33:11,950 --> 00:33:13,450
to the screen, K.

00:33:13,450 --> 00:33:16,610
Straightforward - very simple. Now, the problem with that,

00:33:16,610 --> 00:33:19,040
when you give each actor its own thread, or

00:33:19,040 --> 00:33:21,190
its own process, the problem you run into is

00:33:21,190 --> 00:33:24,540
one of contention. Blocking. Right.

00:33:24,540 --> 00:33:28,230
If your actor performs some lengthy operation such as

00:33:28,230 --> 00:33:30,990
blocking IO, you run the risk of having a

00:33:30,990 --> 00:33:34,060
whole bunch of stuff back up in the queue.

00:33:34,060 --> 00:33:36,890
So most actor implementations will give you some ability

00:33:36,890 --> 00:33:40,760
to pool actors off of some shared mailbox, right.

00:33:40,760 --> 00:33:42,940
So that that way you can have a whole

00:33:42,940 --> 00:33:44,660
bunch of threads running with a whole bunch of

00:33:44,660 --> 00:33:46,320
different actors and you can send messages to one

00:33:46,320 --> 00:33:47,120
place, K.

00:33:47,120 --> 00:33:51,630
F#'s mailbox processor works this way. Acka works this

00:33:51,630 --> 00:33:54,250
way. Scala's original acka works this way, cellular works

00:33:54,250 --> 00:33:56,770
this way, right. The idea of a pool. So

00:33:56,770 --> 00:33:57,880
the way you get a pool out of this

00:33:57,880 --> 00:34:00,310
particular implementation is you just call the pool method

00:34:00,310 --> 00:34:02,650
off of the, the class, tell it how many

00:34:02,650 --> 00:34:05,060
things you want, then we return a whole bunch

00:34:05,060 --> 00:34:08,590
of actors that all share one mailbox, and it'll

00:34:08,590 --> 00:34:10,710
return the mailbox, right. It's very simple.

00:34:10,710 --> 00:34:12,200
You can then run each of the things in

00:34:12,200 --> 00:34:13,870
the pool and you can start sending messages at

00:34:13,870 --> 00:34:15,149
it, and all those things in the pool will

00:34:15,149 --> 00:34:19,810
then start handling those messages, K. It's very straightforward,

00:34:19,810 --> 00:34:20,310
K.

00:34:20,310 --> 00:34:22,220
And again this is a very Scala-ish way of

00:34:22,220 --> 00:34:26,520
doing things. So when, now you'll notice though when

00:34:26,520 --> 00:34:28,060
you call post and you send the message in

00:34:28,060 --> 00:34:29,880
there there's no way to then interact with that

00:34:29,880 --> 00:34:32,990
message or that result later on, K. That was

00:34:32,990 --> 00:34:37,929
by design in Scala's actor class, because the original

00:34:37,929 --> 00:34:42,460
actor model paper from 1973 said actors only interact

00:34:42,460 --> 00:34:44,700
with each other via messages, K.

00:34:44,700 --> 00:34:47,440
Now, again, a lot's changed in forty years and

00:34:47,440 --> 00:34:48,970
that's not necessarily that efficient, and so sometimes you

00:34:48,970 --> 00:34:50,620
want to have other ways to interact with that,

00:34:50,620 --> 00:34:54,030
and so Scala, Martin O'Dersky being a very smart

00:34:54,030 --> 00:34:56,880
guy, decided to create other ways to interact with

00:34:56,880 --> 00:35:00,480
the actor. So here's two other ways that you

00:35:00,480 --> 00:35:03,360
can interact with this particular actor when sending messages.

00:35:03,360 --> 00:35:05,520
The first one is the post question mark, all

00:35:05,520 --> 00:35:07,980
right. What that does is it sends a message

00:35:07,980 --> 00:35:11,580
to the actor and it returns a future object,

00:35:11,580 --> 00:35:15,370
K. This is a very common paradigm in asynchronous

00:35:15,370 --> 00:35:18,360
programming where we send something off for processing and

00:35:18,360 --> 00:35:20,670
we get back a future. In this case, that

00:35:20,670 --> 00:35:22,610
future object behaves exactly the same as if you

00:35:22,610 --> 00:35:26,630
put a future object in the beginning: pending, fulfilled,

00:35:26,630 --> 00:35:29,160
rejected, value, reason, K.

00:35:29,160 --> 00:35:30,710
So when I send this thing off to the

00:35:30,710 --> 00:35:32,720
actor I get my future object back, I go

00:35:32,720 --> 00:35:34,470
through my very important stuff and later on I

00:35:34,470 --> 00:35:37,390
query that object to see how it occurred.

00:35:37,390 --> 00:35:40,220
The second example is post bang, all right. There

00:35:40,220 --> 00:35:42,290
are cases where you may want to use an

00:35:42,290 --> 00:35:46,470
actor in a synchronous capacity, but here's the problem.

00:35:46,470 --> 00:35:49,310
An actor's trying to queue up these operations, so

00:35:49,310 --> 00:35:51,850
as to prevent locking. So we don't have to

00:35:51,850 --> 00:35:53,350
lock so that we can have these happen one

00:35:53,350 --> 00:35:55,160
at a time. If we try and use an

00:35:55,160 --> 00:35:59,030
actor synchronously and asynchronously at the same time we

00:35:59,030 --> 00:36:01,970
run the risk of breaking things very badly.

00:36:01,970 --> 00:36:03,760
So any case where you might want to use

00:36:03,760 --> 00:36:06,490
this thing synchronously - and again Scala provided the

00:36:06,490 --> 00:36:11,150
same capability - you're gonna call this method post

00:36:11,150 --> 00:36:14,560
bang, which will then block and wait for the

00:36:14,560 --> 00:36:18,450
operation to complete, thus imitating synchronous behavior. Now the

00:36:18,450 --> 00:36:21,170
problem with that is when that occurs, there's no

00:36:21,170 --> 00:36:23,240
way of knowing what the result is other than

00:36:23,240 --> 00:36:25,550
the return value of the, of the method.

00:36:25,550 --> 00:36:28,980
This case, on success, this will return the, the

00:36:28,980 --> 00:36:32,590
result of the, the processing of the message, right.

00:36:32,590 --> 00:36:34,460
So in this particular case, this is one of

00:36:34,460 --> 00:36:36,040
the few places in this library we're gonna see

00:36:36,040 --> 00:36:39,430
any kind of exceptions being raised, all right. If

00:36:39,430 --> 00:36:40,380
this thing times out, we're gonna raise a time

00:36:40,380 --> 00:36:43,140
out exception, if, for some reason the message can't

00:36:43,140 --> 00:36:45,460
be queued, we're gonna get a life cycle exception.

00:36:45,460 --> 00:36:48,980
If our operation throws an exception, the actor will

00:36:48,980 --> 00:36:51,210
then handle that internally the way it handles all

00:36:51,210 --> 00:36:53,890
other exceptions, and then reraise that exception out of

00:36:53,890 --> 00:36:55,090
this particular method, all right.

00:36:55,090 --> 00:36:56,990
And that way it allows us to treat this

00:36:56,990 --> 00:36:59,210
in a very synchronous way, but we're given a

00:36:59,210 --> 00:37:01,210
very strong warning that, really, what we're doing might

00:37:01,210 --> 00:37:02,680
not be quite the best way to do it

00:37:02,680 --> 00:37:04,500
and we're gonna get exceptions, so we're gonna want

00:37:04,500 --> 00:37:05,980
to wrap that in a rescue block, OK.

00:37:05,980 --> 00:37:08,310
And, at this point it should be no surprise

00:37:08,310 --> 00:37:12,010
to you that this particular actor implementation also supports

00:37:12,010 --> 00:37:14,290
observers, because it's very common in the case of

00:37:14,290 --> 00:37:17,340
actor frameworks to provide some sort of call back

00:37:17,340 --> 00:37:20,240
against messages being processed successfully.

00:37:20,240 --> 00:37:23,700
So here we leverage that observer again. And if

00:37:23,700 --> 00:37:25,340
you're familiar with actors, you know that the canonical

00:37:25,340 --> 00:37:27,860
actor example, the hello world of actors, is a

00:37:27,860 --> 00:37:30,320
ping pong example, so for completeness, here is a

00:37:30,320 --> 00:37:32,580
ping pong example using this particular actor implementation.

00:37:32,580 --> 00:37:36,050
That actually, I took that directly from the Scala

00:37:36,050 --> 00:37:39,370
tutorial on actors and, and rebuilt it using Ruby,

00:37:39,370 --> 00:37:40,310
K.

00:37:40,310 --> 00:37:43,930
So last concept. How many people here have heard

00:37:43,930 --> 00:37:48,040
about Erlang being a very fault-tolerant language. Nine-nine's availability

00:37:48,040 --> 00:37:50,440
in some cases (00:37:49). How many people would like

00:37:50,440 --> 00:37:53,100
to have their Ruby programs have nine nines of

00:37:53,100 --> 00:37:55,830
uptime? All right, that should be everybody in the

00:37:55,830 --> 00:37:56,800
room.

00:37:56,800 --> 00:37:58,970
There's nothing magic about Erlang. You probably have heard

00:37:58,970 --> 00:38:02,280
of the let-it-fail philosophy of Erlang, all right. There

00:38:02,280 --> 00:38:05,130
really, truly is nothing magical about Erlang. In the

00:38:05,130 --> 00:38:07,500
language or the virtual machine itself. This, it's a

00:38:07,500 --> 00:38:09,330
great language and does some really cool things but

00:38:09,330 --> 00:38:14,750
then the actual nine-nine fault tolerance comes from something

00:38:14,750 --> 00:38:17,650
called the supervisor, all right.

00:38:17,650 --> 00:38:19,550
How many - how many people have heard of

00:38:19,550 --> 00:38:22,370
the supervisor in Erlang? OK. This is such a

00:38:22,370 --> 00:38:25,240
powerful concept that you see supervisors all the time

00:38:25,240 --> 00:38:27,850
in concurrency libraries. You see supervisors in Acka, you

00:38:27,850 --> 00:38:31,100
see supervisors in Celluloid, you see supervisors all the

00:38:31,100 --> 00:38:31,320
time.

00:38:31,320 --> 00:38:33,330
So what is a supervisor? The idea in Erlang

00:38:33,330 --> 00:38:36,220
is, when we create these processes, we send them

00:38:36,220 --> 00:38:38,770
out to do things, and if something goes wrong

00:38:38,770 --> 00:38:41,070
we want to let them crash. Why do we

00:38:41,070 --> 00:38:42,180
let them crash?

00:38:42,180 --> 00:38:43,950
WE let them crash because we don't want to

00:38:43,950 --> 00:38:46,520
have anything in some kind of intermediate state, K.

00:38:46,520 --> 00:38:48,320
If you're like me you've probably programmed some kind

00:38:48,320 --> 00:38:49,860
of wrapper at some point in your life, where

00:38:49,860 --> 00:38:52,100
you thought I'm gonna put this really great simple

00:38:52,100 --> 00:38:55,090
O-O wrapped around some whole bunch of complex stuff.

00:38:55,090 --> 00:38:57,410
And I've got connections and all these various things

00:38:57,410 --> 00:38:58,790
in there, and then one of those things blows

00:38:58,790 --> 00:39:00,640
up. Now I've got this mess, and I've got

00:39:00,640 --> 00:39:02,180
to dig through all this kind of crap and

00:39:02,180 --> 00:39:04,450
figure out what state is this thing in so

00:39:04,450 --> 00:39:06,790
I can get the broken pieces back where they

00:39:06,790 --> 00:39:07,820
need to be.

00:39:07,820 --> 00:39:10,800
Erlang says no. Don't do that. There's only two

00:39:10,800 --> 00:39:12,300
states. Good or bad. If it's good, great. If

00:39:12,300 --> 00:39:13,990
it's not, you should just kill it and let

00:39:13,990 --> 00:39:17,190
it die. Right, and that works only if there's

00:39:17,190 --> 00:39:20,150
a way to restart it, all right. This philosophy

00:39:20,150 --> 00:39:21,850
is really good because now it's very easy, it's

00:39:21,850 --> 00:39:24,530
very freeing. So I've got this complex thing, something

00:39:24,530 --> 00:39:26,200
blows up, I'm just gonna kill everything.

00:39:26,200 --> 00:39:27,740
All right. But that depends if I have something

00:39:27,740 --> 00:39:31,210
that restarts it. And in Erlang, that's the supervisor,

00:39:31,210 --> 00:39:35,560
K. This right here is a functionally complete implementation

00:39:35,560 --> 00:39:39,950
of Erlang's supervisor module, K. It's a, the Erlang's

00:39:39,950 --> 00:39:42,440
supervisor module provides a lot of really great capabilities.

00:39:42,440 --> 00:39:45,670
It provides something called restart strategies, which allows you

00:39:45,670 --> 00:39:47,700
to define when one thing dies, what would you

00:39:47,700 --> 00:39:48,690
do with the other things (00:39:49). It allows you

00:39:48,690 --> 00:39:52,410
to find child-types that could be permanent, temporary, transient,

00:39:52,410 --> 00:39:54,380
as meanings (00:39:53). You can provide a sliding window

00:39:54,380 --> 00:39:57,500
of, of intervals. You can say if we get

00:39:57,500 --> 00:40:00,030
x number of crashes within y period of time,

00:40:00,030 --> 00:40:02,140
we're gonna shut the whole thing down.

00:40:02,140 --> 00:40:04,580
And one of the best things about Erlang's supervisor

00:40:04,580 --> 00:40:09,430
is something called supervisor trees. Supervisors can manage supervisors

00:40:09,430 --> 00:40:11,610
which can manage other supervisors. So if you look

00:40:11,610 --> 00:40:15,440
at Erlang's documentation on how to build fault-tolerant systems,

00:40:15,440 --> 00:40:18,710
they discuss a bunch of very different tree structures,

00:40:18,710 --> 00:40:19,450
K.

00:40:19,450 --> 00:40:23,040
This particular implementation here is a functionally complete version

00:40:23,040 --> 00:40:25,810
of Erlang supervisor, and here's how it works. You

00:40:25,810 --> 00:40:28,780
can give this thing anything that supports three methods.

00:40:28,780 --> 00:40:31,380
A blocking run method, a runable predicate method -

00:40:31,380 --> 00:40:34,100
excuse me, a running predicate method, and this stock

00:40:34,100 --> 00:40:36,000
method. You can use that to - and then

00:40:36,000 --> 00:40:37,830
you use the run method to start it and

00:40:37,830 --> 00:40:40,440
the stop method to shut it down.

00:40:40,440 --> 00:40:41,560
That's why we looked at a couple of things

00:40:41,560 --> 00:40:43,610
earlier that had that run method. So what we're

00:40:43,610 --> 00:40:45,230
doing in this case, we're gonna create a super-

00:40:45,230 --> 00:40:48,180
we're gonna create an actor. From that, from the

00:40:48,180 --> 00:40:50,130
actor class we create a pool of actors, all

00:40:50,130 --> 00:40:53,110
right. We're gonna create a couple timer tasks, which,

00:40:53,110 --> 00:40:55,220
that have random intervals. We're gonna create a supervisor.

00:40:55,220 --> 00:40:57,450
We're gonna tell the supervisor, manage and monitor all

00:40:57,450 --> 00:41:00,690
of these things, here, add_worker, add_worker, add_worker. We then

00:41:00,690 --> 00:41:04,280
start the supervisor, and it runs, all right. And

00:41:04,280 --> 00:41:05,550
at that point it starts up all of those

00:41:05,550 --> 00:41:07,020
things, and all of those things run, and they

00:41:07,020 --> 00:41:08,270
all do all the things they want to do

00:41:08,270 --> 00:41:10,370
and the supervisor monitors them, and if any of

00:41:10,370 --> 00:41:13,350
them should crash, the supervisor will restart them based

00:41:13,350 --> 00:41:15,350
upon the restart strategy.

00:41:15,350 --> 00:41:18,410
And if you want, you can have supervisors monitor

00:41:18,410 --> 00:41:19,930
supervisors, so that that way, if something's wrong with

00:41:19,930 --> 00:41:22,320
the supervisor, it can restart that whole thing. All

00:41:22,320 --> 00:41:24,280
right, and thus you can get a supervisor tree

00:41:24,280 --> 00:41:27,690
and that is how languages like Erlang, and libraries

00:41:27,690 --> 00:41:30,700
like Celluloid and Acka and so forth, get their,

00:41:30,700 --> 00:41:35,510
their fault-tolerant abilities, by using acts- supervisors to manage

00:41:35,510 --> 00:41:37,250
those processes.

00:41:37,250 --> 00:41:39,660
OK. Now this is a really long presentation and

00:41:39,660 --> 00:41:40,580
we don't have a lot of times, so I

00:41:40,580 --> 00:41:42,050
want to mention two of the libraries that are

00:41:42,050 --> 00:41:45,860
very, that, that, express some really cool ideas in

00:41:45,860 --> 00:41:47,810
terms of concurrency. And the first one is gonna

00:41:47,810 --> 00:41:49,860
be something called a vent machine. Vent machine is

00:41:49,860 --> 00:41:53,350
based upon the reactor pattern, right. Reactor pattern was

00:41:53,350 --> 00:41:56,240
first documented in 2000.

00:41:56,240 --> 00:41:57,740
We like vent machine a lot at VHT. A

00:41:57,740 --> 00:42:03,320
vent machine's basically like node.js4 for Ruby, K. Oh,

00:42:03,320 --> 00:42:05,360
again, all these slides are gonna be up on

00:42:05,360 --> 00:42:06,940
GitHub as well as all the coding samples.

00:42:06,940 --> 00:42:09,550
Then the other thing is Celluloid. Celluloid is a

00:42:09,550 --> 00:42:13,830
fairly well-known, fairly popular actor-based library, written in Ruby,

00:42:13,830 --> 00:42:16,190
all right. It's got a good following, it's got

00:42:16,190 --> 00:42:19,570
a very good community. And the Celluloid library makes

00:42:19,570 --> 00:42:24,390
it, has the expressed interest in making it easy

00:42:24,390 --> 00:42:28,140
for you to add concurrency to your code.

00:42:28,140 --> 00:42:29,960
This right here is the original example we showed

00:42:29,960 --> 00:42:31,630
at the very beginning of our crash test dummy,

00:42:31,630 --> 00:42:33,910
with one change. Up at the very top, you

00:42:33,910 --> 00:42:39,600
see include Celluloid. That makes this object inherently asynchronous.

00:42:39,600 --> 00:42:43,600
It becomes something you can create actors from, K.

00:42:43,600 --> 00:42:47,190
The Celluloid is a great library for making your

00:42:47,190 --> 00:42:51,020
job easy. But this particular implementation I'm showing you

00:42:51,020 --> 00:42:53,350
here is horrible broken because it violates a bunch

00:42:53,350 --> 00:42:55,550
of Celluloid rules, K.

00:42:55,550 --> 00:42:59,540
Celluloid is, has a very tightly coupled and very,

00:42:59,540 --> 00:43:01,830
it's very powerful, but it's very tightly coupled and

00:43:01,830 --> 00:43:07,020
it has a very, a lot of complexity internally.

00:43:07,020 --> 00:43:08,650
Because it's providing a lot of auto magic in

00:43:08,650 --> 00:43:12,290
order to prevent you from harming yourself through concurrency.

00:43:12,290 --> 00:43:16,010
So when you look at Celluloid documentation, there's a

00:43:16,010 --> 00:43:19,220
page of gotchas, which describe the, the idiomatic way

00:43:19,220 --> 00:43:20,400
in which you need to use Celluloid.

00:43:20,400 --> 00:43:22,950
So Celluloid is another very powerful library for doing

00:43:22,950 --> 00:43:29,240
actors, and for doing supervisors. And, and - but,

00:43:29,240 --> 00:43:32,410
using Celluloid properly requires a little bit of work.

00:43:32,410 --> 00:43:35,560
So I encourage you to look not only at

00:43:35,560 --> 00:43:38,530
the library that I put together, but the vent

00:43:38,530 --> 00:43:40,790
machine and also Celluloid. Make sure when using each

00:43:40,790 --> 00:43:42,880
of those libraries that you are aware of the

00:43:42,880 --> 00:43:44,520
idiosyncrasies of those libraries and how they work. And

00:43:44,520 --> 00:43:47,780
remember, you can never escape the underlying realities of

00:43:47,780 --> 00:43:52,580
concurrency, which are non-determinism and shared mutable data.

00:43:52,580 --> 00:43:55,360
So with that, my final thought is this. All

00:43:55,360 --> 00:43:57,030
right. My challenge to you is to go out

00:43:57,030 --> 00:44:00,880
and write code, K. If you've never written concurrent

00:44:00,880 --> 00:44:04,150
code before, you should know that writing good concurrent

00:44:04,150 --> 00:44:06,930
code is something that requires effort. You can't learn

00:44:06,930 --> 00:44:09,570
about it by reading. You have to do it.

00:44:09,570 --> 00:44:13,080
Concurrent systems don't behave the way non-concurrent systems work.

00:44:13,080 --> 00:44:15,260
They have different design patterns that make them work.

00:44:15,260 --> 00:44:17,790
They have different ways of testing and debugging and

00:44:17,790 --> 00:44:19,170
the only way to learn this is to write

00:44:19,170 --> 00:44:20,810
the code.

00:44:20,810 --> 00:44:22,410
Over the past forty-five minutes, we've looked at a

00:44:22,410 --> 00:44:24,390
tremendous amount of code that did a lot of

00:44:24,390 --> 00:44:26,910
very, very powerful things, and we never, ever once

00:44:26,910 --> 00:44:30,100
had to type thread dot new. We never once

00:44:30,100 --> 00:44:34,410
had to type dot synchronize off a mutex object,

00:44:34,410 --> 00:44:35,260
K.

00:44:35,260 --> 00:44:37,700
You can go out, using the libraries that we've

00:44:37,700 --> 00:44:39,020
looked at today, using the code that I've put

00:44:39,020 --> 00:44:42,570
up on GitHub, and you can write concurrent code.

00:44:42,570 --> 00:44:45,310
So if you think concurrency is important, which you

00:44:45,310 --> 00:44:48,770
should, if you think that learning to program concurrency

00:44:48,770 --> 00:44:50,900
is good for you at your job and your

00:44:50,900 --> 00:44:53,650
career, which you should, and if you think concurrency

00:44:53,650 --> 00:44:55,280
is something that is going to become just more

00:44:55,280 --> 00:44:58,850
important in the near future, which it is, then

00:44:58,850 --> 00:45:01,390
you need to go out and write code.

00:45:01,390 --> 00:45:05,820
So add my GitHub page, all of the slides,

00:45:05,820 --> 00:45:08,570
detailed notes, all of the source code in RB

00:45:08,570 --> 00:45:11,150
files, and even a gem file. So that's my

00:45:11,150 --> 00:45:14,060
challenge to you. Pull out your computer, get clon-

00:45:14,060 --> 00:45:17,390
open up your favorite editor, git clone, bundle install,

00:45:17,390 --> 00:45:19,970
and write concurrent code. And with that, I'm out

00:45:19,970 --> 00:45:20,510
of time.

00:45:20,510 --> 00:45:22,470

YouTube URL: https://www.youtube.com/watch?v=VVmENBTc1jM


