Title: Ruby Conf 2013 - REPL driven development with Pry by Conrad Irwin
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	Pry is a featureful irb replacement that provides Ruby programmers with a seriously souped-up REPL.

Using some real-life examples, I'll explain how to use Pry to program more effectively.

We'll start with the basics of exploring libaries and experimenting with code at lightning speed. Then we'll move up a level and discuss how to dig into, debug and even modify existing programs. Finally we'll cover a few of the plugins that make Pry a truly indispensible tool.

Help us caption & translate this video!

http://amara.org/v/FG5X/
Captions: 
	00:00:16,560 --> 00:00:17,280
CONRAD IRWIN: I'm Confrad.

00:00:17,280 --> 00:00:19,751
I'm one of the maintainers of Pry.

00:00:19,751 --> 00:00:21,240
And today I want to talk with you guys

00:00:21,240 --> 00:00:23,939
a bit about REPL-driven development.

00:00:23,940 --> 00:00:25,331
So REPLs have been really popular

00:00:25,340 --> 00:00:27,340
since the Lisp days - the 1960s,

00:00:27,340 --> 00:00:30,160
that's a long time ago now, when they realized

00:00:30,160 --> 00:00:32,969
that there's not much difference between

00:00:32,969 --> 00:00:34,221
the data in your program

00:00:34,221 --> 00:00:36,350
and the code that your program is running.

00:00:36,350 --> 00:00:37,809
So wouldn't it be nice if you could just

00:00:37,809 --> 00:00:40,081
take a string and then run it as though

00:00:40,081 --> 00:00:42,090
it were code? And that gives you the eval

00:00:42,100 --> 00:00:44,510
function, which is the core to making something like

00:00:44,510 --> 00:00:46,209
a REPL work.

00:00:46,220 --> 00:00:48,230
So in Lisp days, they had Lisp, they had

00:00:48,230 --> 00:00:50,571
a REPL, and the idea is that you read

00:00:50,580 --> 00:00:53,080
in a line from the user, you run it,

00:00:53,080 --> 00:00:55,080
you eval it, see what it does, print out

00:00:55,080 --> 00:00:57,069
the output, and then you just loop around to

00:00:57,069 --> 00:01:00,220
start again. And all the modern scripting languages, so

00:01:00,220 --> 00:01:03,170
Python, JavaScript, Ruby, they all have an eval function

00:01:03,180 --> 00:01:07,401
and they all have REPLs built with that.

00:01:07,401 --> 00:01:09,760
In Ruby, building a REPL is really, really easy.

00:01:09,780 --> 00:01:12,090
It looks exactly like it says on the tin.

00:01:12,090 --> 00:01:15,890
You just read a line, eval it, puts it,

00:01:15,890 --> 00:01:19,670
and loop back around again. Indeed, like, IOB ships

00:01:19,670 --> 00:01:21,830
with Ruby. In principle. They've added a bit of

00:01:21,840 --> 00:01:24,080
fluff to make it work better, but under the

00:01:24,080 --> 00:01:26,130
hood is this one line of code that's pairing

00:01:26,130 --> 00:01:28,450
IOB.

00:01:28,460 --> 00:01:30,950
It's exactly the same line of code that started,

00:01:30,950 --> 00:01:32,880
I don't know, Pry started exactly the same. Pry

00:01:32,880 --> 00:01:35,460
is a REPL. Started with this line of code

00:01:35,480 --> 00:01:37,890
and then the first git revision is about seventy-five

00:01:37,890 --> 00:01:40,340
lines that wrap this to make it better. So

00:01:40,340 --> 00:01:42,690
John Mare was the guy who originally created it.

00:01:42,690 --> 00:01:44,300
He's at Bannister Fiend if you want to follow

00:01:44,320 --> 00:01:46,850
him on Twitter. He's kind of cool. Writes developer

00:01:46,850 --> 00:01:48,910
tools all the time.

00:01:48,910 --> 00:01:50,970
So we started from this one line of code,

00:01:50,980 --> 00:01:53,390
git revision one was seventy-five lines of code. And

00:01:53,390 --> 00:01:55,630
because nothing ever gets smaller, we're now at twelve

00:01:55,640 --> 00:01:59,150
thousand lines of Ruby. Which is a lot. But

00:01:59,150 --> 00:02:01,530
we've done quite a lot to improve on this.

00:02:01,540 --> 00:02:04,290
So, there are about three majors areas in which

00:02:04,290 --> 00:02:08,140
Pry beats this one line. Firstly, and most obviously,

00:02:08,140 --> 00:02:11,580
if you look here, if you do anything wrong

00:02:11,580 --> 00:02:14,700
in that readline and it crashes, the entire REPL

00:02:14,700 --> 00:02:16,610
just falls apart and you have to restart it

00:02:16,620 --> 00:02:19,410
and go from scratch. So Pry will catch exceptions.

00:02:19,410 --> 00:02:21,060
It will tell you what's going wrong. And it

00:02:21,060 --> 00:02:22,750
won't make a fuss about it. It's not like

00:02:22,760 --> 00:02:24,620
a massive stack trace. It's just, hey, you have

00:02:24,620 --> 00:02:27,620
an exception, maybe you want to try again.

00:02:27,620 --> 00:02:29,180
We've also made it so if you want to

00:02:29,180 --> 00:02:30,870
define a method, if you want to do something

00:02:30,880 --> 00:02:33,390
that takes multiple lines, you can do that. So

00:02:33,390 --> 00:02:35,610
robustness is something we've really worked on. We have

00:02:35,610 --> 00:02:38,200
about four million downloads now, so everyone is hammering

00:02:38,200 --> 00:02:40,260
it. Pry just kind of works out of the

00:02:40,260 --> 00:02:42,929
box.

00:02:42,940 --> 00:02:45,311
The second major area we've improved is making it

00:02:45,320 --> 00:02:48,449
fun and easy to use. So the one line

00:02:48,449 --> 00:02:52,391
there is just puts. We do kind of pretty

00:02:52,400 --> 00:02:56,600
inspection. We do syntax highlighting both input and output.

00:02:56,600 --> 00:02:58,290
We ma- try and make it really easy to

00:02:58,290 --> 00:03:00,790
read what's coming out. We've also added things like

00:03:00,790 --> 00:03:03,620
tab completion. IRB has a bit of tab completion.

00:03:03,620 --> 00:03:05,690
Pry takes that to the next level.

00:03:05,700 --> 00:03:08,620
Just to make it easy to interact with. You

00:03:08,620 --> 00:03:10,939
don't need to always type everything out correctly, just

00:03:10,940 --> 00:03:12,611
tab complete and that will fill in method names

00:03:12,620 --> 00:03:14,330
for you.

00:03:14,330 --> 00:03:16,180
And the third way in which we've improved Pry

00:03:16,180 --> 00:03:19,200
is we've added introspection commands. So Ruby is an

00:03:19,200 --> 00:03:21,750
awesome language and has all kinds of dynamic features

00:03:21,750 --> 00:03:24,550
for looking around and seeing what your program is

00:03:24,560 --> 00:03:26,790
doing. Most obvious one of this is if you

00:03:26,790 --> 00:03:29,630
call the class method on an object, it says

00:03:29,640 --> 00:03:32,020
I am this class. So it, you can get

00:03:32,020 --> 00:03:34,520
ActiveRecord base, so you can get whatever out.

00:03:34,520 --> 00:03:37,040
And there are other more complicated ones, like dot

00:03:37,040 --> 00:03:39,189
methods, will give you the list of methods that

00:03:39,189 --> 00:03:41,930
you can call on an object. Pry knows all

00:03:41,940 --> 00:03:43,741
about all of these things, and knows all about

00:03:43,741 --> 00:03:45,969
the bugs and the edge cases in them. And

00:03:45,969 --> 00:03:47,311
it wraps them up and tries to make them

00:03:47,320 --> 00:03:48,460
easy to use.

00:03:48,460 --> 00:03:49,570
And so a big part of the later bit

00:03:49,570 --> 00:03:51,319
of this talk is going to be demonstrating how

00:03:51,320 --> 00:03:55,070
Pry's commands can help you explore Ruby programs without

00:03:55,080 --> 00:04:00,131
having to go through so much effort yourself. The

00:04:00,140 --> 00:04:02,809
question you should all really be asking, though, is

00:04:02,809 --> 00:04:06,201
twelve-thousand lines of Ruby. That's a lot.

00:04:06,201 --> 00:04:09,100
And it is. Why did we, just like, four

00:04:09,120 --> 00:04:10,470
or five of us on the code team, there's

00:04:10,470 --> 00:04:12,510
thirty or forty people who've sent poll requests -

00:04:12,520 --> 00:04:15,640
why was it worth doing that? Instead of just

00:04:15,640 --> 00:04:19,220
using the hack-y one line whenever we needed it?

00:04:19,220 --> 00:04:23,870
And the answer, I think, is REPL-driven development. So

00:04:23,870 --> 00:04:27,020
the idea is kind of similar to test-driven development.

00:04:27,020 --> 00:04:30,180
Don't write code first. And, with REPL-driven development, it's

00:04:30,180 --> 00:04:34,120
not even writing tests, so don't write tests first.

00:04:34,120 --> 00:04:36,890
Instead, work out the code you're going to write

00:04:36,890 --> 00:04:40,980
using a REPL. And then start documenting it and

00:04:40,980 --> 00:04:42,640
writing it down properly.

00:04:42,640 --> 00:04:44,520
And the reason for doing this is that if

00:04:44,520 --> 00:04:46,399
you're in a REPL, and something goes wrong, it

00:04:46,400 --> 00:04:48,381
takes no time to fix it. You can just

00:04:48,381 --> 00:04:50,610
loop around and loop around. And so, once you've

00:04:50,620 --> 00:04:52,330
used a REPL, the chances are the line of

00:04:52,330 --> 00:04:55,320
code you've written actually works. Which you can't say

00:04:55,320 --> 00:04:58,500
if you've just added it to a text editor.

00:04:58,500 --> 00:05:01,160
So test-driven development is very much about maintainability, about

00:05:01,160 --> 00:05:04,910
writing nice APIs. REPL-driven development is about writing code

00:05:04,910 --> 00:05:06,790
that works first time, or making it way, way

00:05:06,800 --> 00:05:10,270
faster to get to working code. REPLs are so

00:05:10,270 --> 00:05:12,460
awesome that you can even find celebrities like Spoc

00:05:12,460 --> 00:05:13,650
using them.

00:05:13,650 --> 00:05:20,640
That's the only way to make code perfect.

00:05:22,500 --> 00:05:25,230
So as a developer, I have a kind of

00:05:25,240 --> 00:05:28,060
problem, and I hope that you all share it

00:05:28,080 --> 00:05:31,160
with me, otherwise this is gonna be quite embarrassing.

00:05:31,160 --> 00:05:34,390
But about eighty percent of the time, if I

00:05:34,390 --> 00:05:37,620
write down a line of code, it crashes. This

00:05:37,620 --> 00:05:39,359
is usually for something really, really simple. I have

00:05:39,360 --> 00:05:41,860
a typo. I have spelt the method name wrong.

00:05:41,860 --> 00:05:45,011
Or, you know, I've just missed a plus. I'm

00:05:45,040 --> 00:05:47,180
doing the wrong maths.

00:05:47,180 --> 00:05:50,290
And this is kind of unacceptable. If I pushed

00:05:50,290 --> 00:05:52,100
code out and it crashed eighty percent of the

00:05:52,100 --> 00:05:55,560
time, no one would use anything I'd written. And

00:05:55,560 --> 00:05:57,409
you can see that really clearly when you look

00:05:57,409 --> 00:06:00,120
at GitHub's status page. So they actually publish how

00:06:00,120 --> 00:06:03,150
crash-y GitHub is. When I was writing these slides,

00:06:03,150 --> 00:06:06,411
they crash on about, not point not not not

00:06:06,420 --> 00:06:08,440
eight percent of requests.

00:06:08,440 --> 00:06:12,260
What makes that number so astounding is that GitHub

00:06:12,260 --> 00:06:14,820
isn't just one bit of code anymore. There's probably

00:06:14,820 --> 00:06:17,239
thousands of method calls, or thousands of chunks of

00:06:17,240 --> 00:06:20,601
code that go into serving each request. And if

00:06:20,601 --> 00:06:23,209
you multiply those out, that kind of works out

00:06:23,209 --> 00:06:26,012
that each method call on GitHub dot com has

00:06:26,020 --> 00:06:28,379
a failure rate of about eight in a billion

00:06:28,380 --> 00:06:29,620
times.

00:06:29,620 --> 00:06:32,090
And that's embarrassing for me because that's about a

00:06:32,090 --> 00:06:37,880
hundred million times better than what I manage. So

00:06:37,900 --> 00:06:39,290
what do I do to fix this?

00:06:39,300 --> 00:06:42,630
Well, three simple things. If you run the code,

00:06:42,630 --> 00:06:44,699
that'll tell you about all the typos. That'll tell

00:06:44,700 --> 00:06:46,821
you about all the stupid little things that you've

00:06:46,821 --> 00:06:50,150
just got slightly wrong. It's very quick to do.

00:06:50,160 --> 00:06:51,459
You just run the code, and then you have

00:06:51,460 --> 00:06:53,761
reasonable confidence. That's one of the reasons that test-driven

00:06:53,761 --> 00:06:57,198
development exists. It ensures that you've actually run the

00:06:57,200 --> 00:07:00,310
code before you deployed.

00:07:00,310 --> 00:07:02,020
The other things you can do. You can read

00:07:02,020 --> 00:07:04,830
the code around that. So if you're working on

00:07:04,840 --> 00:07:07,780
an application, each line of code isn't in isolation.

00:07:07,780 --> 00:07:11,080
You're calling methods. There are methods calling you. If

00:07:11,080 --> 00:07:13,500
you just read those methods, the chances are you

00:07:13,500 --> 00:07:16,530
can get a good idea for what the code

00:07:16,530 --> 00:07:19,240
you're writing should expect. You can see how other

00:07:19,240 --> 00:07:21,900
people are handling nils in the surrounding code.

00:07:21,920 --> 00:07:23,749
You can get a feel for how you're code

00:07:23,749 --> 00:07:26,150
should be written to work the best.

00:07:26,150 --> 00:07:27,860
And so it's not as good as running the

00:07:27,860 --> 00:07:29,771
code. I mean, if you run the code, you

00:07:29,780 --> 00:07:32,119
have a very high degree of confidence that it

00:07:32,120 --> 00:07:34,620
works. But it lets you get another level better,

00:07:34,620 --> 00:07:39,270
or, you know, one further level down the line.

00:07:39,270 --> 00:07:41,421
And it's also reasonably quick to do. Reading a

00:07:41,440 --> 00:07:44,720
few methods doesn't require understanding the code. You're just

00:07:44,720 --> 00:07:47,720
looking around to see if you can spot anything

00:07:47,720 --> 00:07:49,380
obvious.

00:07:49,380 --> 00:07:52,390
Understanding the code is kind of the end goal.

00:07:52,390 --> 00:07:54,699
If you can write code in a code base

00:07:54,700 --> 00:07:57,321
that you completely understand, you can probably get away

00:07:57,321 --> 00:07:59,419
without running it. I mean, you should check for

00:07:59,420 --> 00:08:01,461
typos and things, but the chances are, if you

00:08:01,461 --> 00:08:04,359
fully understand your code base, you're not going to

00:08:04,360 --> 00:08:06,461
make silly mistakes, or you're going to make them

00:08:06,461 --> 00:08:09,919
less often. And so like the ideal goal for

00:08:09,920 --> 00:08:11,961
everyone should be to understand the code. But the

00:08:11,961 --> 00:08:16,009
obvious problem is that can literally take forever.

00:08:16,020 --> 00:08:17,591
If you're in the Lodge Rails app, there's the

00:08:17,600 --> 00:08:19,969
whole of Rails. I don't know if anyone has

00:08:19,969 --> 00:08:22,870
the whole of Rails in their head anymore. And

00:08:22,870 --> 00:08:26,991
any app, like, of non, of substantial size will

00:08:27,000 --> 00:08:28,619
be tens of thousands of lines of code. It's

00:08:28,640 --> 00:08:30,111
going to take you days or even months to

00:08:30,111 --> 00:08:32,420
understand that stuff.

00:08:32,420 --> 00:08:34,490
So I tend to leave the understanding the code

00:08:34,490 --> 00:08:38,720
until the first two approaches have failed me. I

00:08:38,720 --> 00:08:40,420
run the code. It will take a few seconds.

00:08:40,420 --> 00:08:42,439
I can just iterate on that a few times.

00:08:42,440 --> 00:08:44,140
I'll read the code around if I need higher

00:08:44,140 --> 00:08:46,271
degrees of confidence. So if I'm changing something deep

00:08:46,280 --> 00:08:48,930
in our data lair, I'm like, this could be

00:08:48,940 --> 00:08:51,850
dangerous. I'll start reading around and checking that my

00:08:51,850 --> 00:08:53,800
assumptions are lining up with the assumptions in the

00:08:53,800 --> 00:08:55,449
rest of the code.

00:08:55,460 --> 00:08:58,011
And this doesn't take me very long.

00:08:58,011 --> 00:09:00,630
It takes me particularly less time because I use

00:09:00,640 --> 00:09:03,029
Pry to do it. And this is where everything

00:09:03,029 --> 00:09:06,020
ties together. If you have a REPL, it makes

00:09:06,020 --> 00:09:08,191
it really, really fast to run code. You literally

00:09:08,200 --> 00:09:11,510
just pitch it in, run it, done. Pry has

00:09:11,510 --> 00:09:13,260
features to make it really, really easy to read

00:09:13,260 --> 00:09:14,810
code as well.

00:09:14,820 --> 00:09:16,480
You can just look at a method and it'll

00:09:16,480 --> 00:09:19,060
tell you the source code.

00:09:19,060 --> 00:09:20,820
I'd like to think that it helps with understanding

00:09:20,820 --> 00:09:23,380
as well, because if you can inspect your program

00:09:23,380 --> 00:09:26,100
while it's running, it's easier to understand. But I've

00:09:26,100 --> 00:09:28,080
noticed for myself that if I need to understand

00:09:28,080 --> 00:09:30,050
a gem, I'll git clone it. So Pry still

00:09:30,050 --> 00:09:31,650
has some way to go there.

00:09:31,650 --> 00:09:34,250
And what I'd like to do now is just

00:09:34,250 --> 00:09:36,160
show you a little bit of, you know, how

00:09:36,160 --> 00:09:38,030
Pry works. This is going to be embarrassing, because

00:09:38,040 --> 00:09:40,610
I'm going to deliberately make mistakes on stage so

00:09:40,610 --> 00:09:43,780
that I can debug them.

00:09:43,780 --> 00:09:45,990
So opening Pry is just like IRB. You just

00:09:46,000 --> 00:09:48,280
type in Pry. You have to have gem installed

00:09:48,280 --> 00:09:51,610
at first. And this is a task I had

00:09:51,620 --> 00:09:53,600
to do when I started at my new job.

00:09:53,600 --> 00:09:54,880
So I started a new job a few months

00:09:54,880 --> 00:09:57,810
ago. We're using Mongo. Before I'd only ever used

00:09:57,810 --> 00:10:00,430
Postgres. So I was like, eh, what's this thing?

00:10:00,430 --> 00:10:01,900
What do I do?

00:10:01,900 --> 00:10:04,290
So all I know is there's this local database,

00:10:04,300 --> 00:10:06,819
dollar Mongo - it's just a Ruby global variable.

00:10:06,820 --> 00:10:09,440
And you can see here how Pry's already starting

00:10:09,440 --> 00:10:11,651
to help. So we've got dark green for globals.

00:10:11,660 --> 00:10:15,170
It's like, maybe you shouldn't be using this.

00:10:15,170 --> 00:10:18,400
Then classes are blue and strings, et cetera, et

00:10:18,400 --> 00:10:21,100
cetera. So you can see that this Mongo object

00:10:21,100 --> 00:10:24,280
is actually a moped session object. Well, I have

00:10:24,280 --> 00:10:26,590
no idea what one of those is. But I

00:10:26,600 --> 00:10:28,100
can look it up really easily. I don't need

00:10:28,100 --> 00:10:29,300
to go to GitHub. I don't need to go

00:10:29,300 --> 00:10:31,090
to Google and try and work it out. I

00:10:31,090 --> 00:10:33,439
can just type question mark dollar Mongo.

00:10:33,440 --> 00:10:35,991
The full name for this command is show-doc, but

00:10:36,000 --> 00:10:37,820
why would you ever type eight characters when one

00:10:37,820 --> 00:10:38,960
will do?

00:10:38,960 --> 00:10:41,009
So question mark Mongo is going to look up

00:10:41,009 --> 00:10:43,411
the documentation for moped session and then show it

00:10:43,420 --> 00:10:45,940
to me in the terminal. And you'll see that

00:10:45,940 --> 00:10:48,639
took no time at all. Why? Because Ruby code

00:10:48,640 --> 00:10:50,241
is all local. It doesn't have to go to

00:10:50,241 --> 00:10:52,259
the internet. It's just all there.

00:10:52,260 --> 00:10:53,971
And so if I skin read this, I can

00:10:53,980 --> 00:10:55,779
see that a session in Moped is the root

00:10:55,780 --> 00:10:58,251
for interactions with Mongo. It can talk to a

00:10:58,251 --> 00:11:01,449
single database or dynamically multiple databases. But what I'm

00:11:01,449 --> 00:11:03,151
interested in here is this example.

00:11:03,160 --> 00:11:05,759
It's like, here's how to use Mongo. This is

00:11:05,760 --> 00:11:07,421
exactly what I want.

00:11:07,421 --> 00:11:09,340
So I want to find a user in the

00:11:09,340 --> 00:11:11,250
user's table. I want to look up my user,

00:11:11,250 --> 00:11:12,819
so I have an admin user, and I want

00:11:12,820 --> 00:11:15,151
to just find it. And so this should be

00:11:15,160 --> 00:11:19,590
easy to do. I can just ask Mongo for

00:11:19,590 --> 00:11:22,730
it's user's collection, and then find the one that

00:11:22,730 --> 00:11:26,119
has the name of Conrad.

00:11:26,120 --> 00:11:29,180
And that didn't do what I wanted. Why not?

00:11:29,180 --> 00:11:30,941
I don't know.

00:11:30,941 --> 00:11:32,660
So let's have a look at the find method

00:11:32,680 --> 00:11:35,360
and see what it's actually doing. So just like

00:11:35,360 --> 00:11:38,450
question mark is for showing documentation, dollar is for

00:11:38,450 --> 00:11:41,160
showing source code. That's also show-source if you type

00:11:41,160 --> 00:11:43,139
it out fully.

00:11:43,140 --> 00:11:45,731
And if I run that, I can see, oh.

00:11:45,740 --> 00:11:48,649
Well, the find method doesn't actually find anything. All

00:11:48,649 --> 00:11:51,721
it's doing is creating a new query. So my

00:11:51,721 --> 00:11:55,590
next question is going to be, well, thanks Mongo.

00:11:55,590 --> 00:11:56,689
What do I do now?

00:11:56,689 --> 00:11:59,961
AUDIENCE MEMBER: [indecipherable - 00:11:58]

00:11:59,961 --> 00:12:02,410
C.I.: Oh, sure.

00:12:02,420 --> 00:12:05,700
Yeah. Doesn't help, no.

00:12:05,700 --> 00:12:07,270
I'm not sure I can make this - maybe

00:12:07,270 --> 00:12:13,090
I can do something like this. Cool.

00:12:13,090 --> 00:12:18,640
Is that high enough? Cool.

00:12:18,660 --> 00:12:21,999
OK, so I have this find method. It's returning

00:12:22,000 --> 00:12:24,091
me a moped query. What do I do with

00:12:24,100 --> 00:12:26,550
one of those? Well, this is the third Pry

00:12:26,550 --> 00:12:28,960
command I want to show you. Ls shows you

00:12:28,960 --> 00:12:31,720
the list of methods on classes, or methods on

00:12:31,720 --> 00:12:35,569
objects. So I can just ls Moped::Query and it

00:12:35,569 --> 00:12:37,151
shows you, well, here are all the things you

00:12:37,160 --> 00:12:38,210
might do with a query.

00:12:38,210 --> 00:12:40,559
So you can iterate over them with each, you

00:12:40,560 --> 00:12:42,060
can use one or first to find one of

00:12:42,060 --> 00:12:44,141
them. And so that's now what I'm going to

00:12:44,141 --> 00:12:47,480
do. So I just use the upper arr- up

00:12:47,480 --> 00:12:50,100
arrow a few times. I'm back here. I can

00:12:50,100 --> 00:12:53,290
find one user and that's fine. That's not actually

00:12:53,300 --> 00:12:54,790
the user I was looking for, though. If you

00:12:54,790 --> 00:12:57,190
notice here it's not the admin user that I

00:12:57,220 --> 00:12:58,339
was hoping to find.

00:12:58,340 --> 00:13:01,881
Maybe if I get all of them that'll work.

00:13:01,881 --> 00:13:05,149
But still not. Doesn't matter - Mongo has a

00:13:05,149 --> 00:13:08,722
way of querying for everything in an array. So

00:13:08,740 --> 00:13:10,200
here I'm going to look up everything in Mongo

00:13:10,200 --> 00:13:14,029
that has my name or my full name, and

00:13:14,029 --> 00:13:17,510
I run that and Pry says, no.

00:13:17,510 --> 00:13:19,601
Why does it say no? Well, if you look

00:13:19,601 --> 00:13:21,460
you can see this dollar in has been highlighted

00:13:21,460 --> 00:13:23,770
like it's a global variable. And so it turns

00:13:23,770 --> 00:13:25,700
out you can't use the new hash syntax unless

00:13:25,700 --> 00:13:28,920
you have valid symbols. So we just go back

00:13:28,940 --> 00:13:31,040
the old fashioned way, us a string and make

00:13:31,040 --> 00:13:33,139
that dollar in.

00:13:33,140 --> 00:13:34,770
And then finally I find both the users I'm

00:13:34,770 --> 00:13:36,891
looking for. So here's the admin user with the

00:13:36,900 --> 00:13:39,540
full name. Here's the non-admin user with just my

00:13:39,540 --> 00:13:39,750
temporary name.

00:13:39,750 --> 00:13:44,660
So hopefully it was obvious that most of those

00:13:44,660 --> 00:13:48,700
things were deliberate. If you're in doubt let me

00:13:48,700 --> 00:13:50,850
know later.

00:13:50,860 --> 00:13:53,030
And this is just the three commands I showed

00:13:53,030 --> 00:13:54,970
you. So this is the core bread and butter

00:13:54,970 --> 00:13:57,270
of using Pry to work out how to write

00:13:57,280 --> 00:14:00,600
code. I mean, you can just type lines of

00:14:00,600 --> 00:14:01,879
code in - I couldn't fit that on the

00:14:01,880 --> 00:14:04,771
slide in an easier to say way. But type

00:14:04,780 --> 00:14:07,040
in lines of code, watch it crash, fix it.

00:14:07,040 --> 00:14:08,329
It takes no time.

00:14:08,329 --> 00:14:09,820
It's even quicker if you're not trying to explain

00:14:09,820 --> 00:14:13,271
what you're doing as you're going. Then we have

00:14:13,280 --> 00:14:17,530
introspection commands. So ls wraps object dot methods, it

00:14:17,530 --> 00:14:19,369
shows you all the methods. It groups them by

00:14:19,369 --> 00:14:21,901
which class they're defined in. It highlights them depending

00:14:21,901 --> 00:14:24,320
on whether they're public or private. And you can

00:14:24,320 --> 00:14:26,520
use ls dash dash grep to find some of

00:14:26,520 --> 00:14:27,840
the specific names.

00:14:27,840 --> 00:14:29,580
So ls is kind of the work horse of

00:14:29,580 --> 00:14:34,040
Pry. In the same way ls and bash is

00:14:34,040 --> 00:14:36,179
basically the workhorse of Bash. Every time you CD

00:14:36,180 --> 00:14:37,761
someway, you write ls, and then you can see

00:14:37,761 --> 00:14:40,070
what's going on.

00:14:40,080 --> 00:14:42,900
Dollar, otherwise known as show source, shows you the

00:14:42,900 --> 00:14:45,869
code and question mark, or show documentation, or show

00:14:45,869 --> 00:14:49,461
doc, shows the documentation. I find almost always show

00:14:49,461 --> 00:14:52,200
source is more useful. I'm not sure whether that's

00:14:52,200 --> 00:14:54,480
because people don't document very well or just I

00:14:54,480 --> 00:14:56,670
don't know. Ruby is easy to read, I think,

00:14:56,680 --> 00:14:59,400
is the kind way of saying that.

00:14:59,400 --> 00:15:01,020
So those are the three things that, if you

00:15:01,020 --> 00:15:02,780
want to learn anything about how to use Pry,

00:15:02,780 --> 00:15:05,129
more than it's just IRB, other things you should

00:15:05,129 --> 00:15:05,870
remember.

00:15:05,880 --> 00:15:06,641
Uh-huh?

00:15:06,641 --> 00:15:09,670
AUDIENCE MEMBER: [inaudible - 00:15:10]

00:15:09,670 --> 00:15:13,679
C.I.: Yes. Yes. So, actually what's the- one of

00:15:13,680 --> 00:15:15,541
the funny things with the ls in Bash is

00:15:15,560 --> 00:15:17,730
it has a bug filed against it, which is

00:15:17,730 --> 00:15:20,509
too many options, cause there are twenty-seven also. Pry

00:15:20,509 --> 00:15:24,331
could probably do the same bug.

00:15:24,340 --> 00:15:26,030
So you can give it, like dash p will

00:15:26,030 --> 00:15:28,380
show you more, dash v will show you more,

00:15:28,400 --> 00:15:30,800
cause my default we hide all the ones on

00:15:30,800 --> 00:15:33,420
object because they're the same for every single thing.

00:15:33,420 --> 00:15:39,340
Yeah. Thanks. If anyone else has questions, I'm happy

00:15:39,340 --> 00:15:43,280
to take them at any point.

00:15:43,280 --> 00:15:45,250
AUDIENCE: [indecipherable - 00:15:44]

00:15:45,250 --> 00:15:48,540
C.I.: I- so you can give them method names.

00:15:48,540 --> 00:15:51,379
So you can do like, show source puts. You

00:15:51,380 --> 00:15:53,421
can also, if you know which class they're on,

00:15:53,421 --> 00:15:56,670
do kernel pound puts. And if they're on an

00:15:56,670 --> 00:15:59,619
object you can do sort of dollar Mongo dot

00:15:59,620 --> 00:16:02,300
find. In theory you could put any Ruby expression

00:16:02,300 --> 00:16:04,550
in there, but the tokenizer's a bit weak sometimes.

00:16:04,550 --> 00:16:11,500
So generally object dot is the safest.

00:16:12,600 --> 00:16:14,800
So let's say I want to define REPL. I

00:16:14,800 --> 00:16:16,520
just do that, and you can see my prompts

00:16:16,520 --> 00:16:19,340
changed to have the star, which means hey, you

00:16:19,340 --> 00:16:21,249
started writing a Ruby expression, and then I can

00:16:21,249 --> 00:16:27,954
just do loop puts eval readline, and then you're

00:16:28,000 --> 00:16:28,630
done.

00:16:28,630 --> 00:16:30,821
So that just works. And you can see it's

00:16:30,821 --> 00:16:32,570
syntax how I did it is indented it for

00:16:32,580 --> 00:16:33,980
me. I didn't have to type tab at all.

00:16:33,980 --> 00:16:38,900
It just worked.

00:16:38,900 --> 00:16:43,999
So REPLs are great. But, and this is kind

00:16:44,000 --> 00:16:48,051
of more into maintenance mode. So we have GitHub.

00:16:48,060 --> 00:16:49,790
They have an exception rate of like 8 in

00:16:49,790 --> 00:16:52,240
a billion method calls. I still wonder how they

00:16:52,240 --> 00:16:54,590
do that. They can't just be writing every line

00:16:54,590 --> 00:16:56,770
of code right. They must be writing it in

00:16:56,780 --> 00:16:58,509
a cohesive way.

00:16:58,509 --> 00:17:00,791
And REPLs aren't great for this. They don't keep

00:17:00,800 --> 00:17:02,379
a record of the things that you've found that

00:17:02,380 --> 00:17:04,841
went wrong. If you try and change stuff you

00:17:04,860 --> 00:17:06,959
have to test it again manually. And as you're

00:17:06,960 --> 00:17:08,851
app gets larger and larger it can be really,

00:17:08,851 --> 00:17:10,980
really hard to construct one line of code in

00:17:10,980 --> 00:17:15,230
a REPL that actually tests anything useful.

00:17:15,230 --> 00:17:17,619
And so the obvious solution to this is, well,

00:17:17,620 --> 00:17:20,110
let's use tests as well. And so the way

00:17:20,110 --> 00:17:22,441
I tend to develop is finding the solution in

00:17:22,441 --> 00:17:23,869
the REPL. I am a really, really big fan

00:17:23,880 --> 00:17:25,840
of this because, as I said, eighty percent of

00:17:25,840 --> 00:17:27,370
the time when I write code it doesn't actually

00:17:27,370 --> 00:17:30,010
work. So I can iterate really fast in the

00:17:30,020 --> 00:17:32,551
REPL, get a line of code that works, then

00:17:32,560 --> 00:17:34,960
kind of put it somewhere. Write some tests that

00:17:34,960 --> 00:17:37,509
test what it should do and then duel the

00:17:37,509 --> 00:17:40,600
wiring, which is basically all the code app's use,

00:17:40,600 --> 00:17:42,671
have to, have left to write.

00:17:42,680 --> 00:17:44,330
I'd like it if that let me write code

00:17:44,330 --> 00:17:46,519
that works first time. It still doesn't seem to

00:17:46,520 --> 00:17:48,921
always work. But it's a lot, lot better than

00:17:48,921 --> 00:17:54,200
eighty percent. I don't knoq quite how much better.

00:17:54,200 --> 00:17:57,170
So when you're code gets- code base gets large,

00:17:57,180 --> 00:17:59,219
you need to start thinking about maintenance. You need

00:17:59,220 --> 00:18:01,321
to start thinking about, every line of code I

00:18:01,321 --> 00:18:04,109
change has a potential to break the entire app.

00:18:04,109 --> 00:18:06,311
Wouldn't it be nice if there were something automatically

00:18:06,320 --> 00:18:09,310
testing stuff? And that's exactly what tests are for.

00:18:09,310 --> 00:18:12,060
The test-driven, test-driven development guys also really love the

00:18:12,060 --> 00:18:16,039
idea of designing your API via tests. Because if

00:18:16,040 --> 00:18:19,640
you start building an object by calling it, you

00:18:19,640 --> 00:18:21,340
end up with a much natural, more easy to

00:18:21,340 --> 00:18:23,850
use object than if you're trying to take the

00:18:23,850 --> 00:18:25,610
really complicated bit of code you just wrote and

00:18:25,610 --> 00:18:27,391
then build an API outwards. You end up with

00:18:27,420 --> 00:18:28,879
something much more ugly.

00:18:28,900 --> 00:18:31,831
And the third thing, and kind of subtle thing

00:18:31,831 --> 00:18:35,169
they're really useful for, is for documenting assumptions. If

00:18:35,169 --> 00:18:37,191
there's a test that says, when I pass nil

00:18:37,200 --> 00:18:40,119
in here, it shouldn't crash, that probably means that

00:18:40,120 --> 00:18:42,451
someone is assuming they can pass nil in. So

00:18:42,460 --> 00:18:44,600
if I break that, it's going to break something

00:18:44,600 --> 00:18:46,710
else, and I can then use the fact that

00:18:46,710 --> 00:18:49,509
it's been tested to try and find where in

00:18:49,509 --> 00:18:52,610
the code this is a problem.

00:18:52,610 --> 00:18:57,150
Tests aren't the be all and end all, though.

00:18:57,160 --> 00:19:00,990
So the least favorite thing I have with them

00:19:00,990 --> 00:19:04,210
is they're slow to run. Because this means they're

00:19:04,220 --> 00:19:06,480
slow to write, because they're just code. So eighty

00:19:06,480 --> 00:19:09,090
percent of the time, I write one, it fails

00:19:09,090 --> 00:19:10,730
for the wrong reason or it passes when it

00:19:10,740 --> 00:19:13,290
should fail. It jut doesn't work. And that means

00:19:13,290 --> 00:19:15,520
I'm having to run these tests over and over

00:19:15,540 --> 00:19:15,841
again.

00:19:15,841 --> 00:19:17,299
And if you were at the performance talk just

00:19:17,300 --> 00:19:20,571
now, they were improving it. But still loading a

00:19:20,580 --> 00:19:24,190
Rails environment isn't going to be instant, ever. And

00:19:24,190 --> 00:19:26,499
so it's these first two I want to fix.

00:19:26,500 --> 00:19:27,711
The bottom one I've just put in because it's

00:19:27,720 --> 00:19:30,309
annoying. But in theory if you write really good

00:19:30,309 --> 00:19:36,490
tests that shouldn't happen.

00:19:36,490 --> 00:19:40,421
Obvious solution - let's use a REPL again. So

00:19:40,421 --> 00:19:46,329
Pry itself doesn't have integrations with individual frameworks. It

00:19:46,329 --> 00:19:49,829
doesn't really have any C extensions. Pry itself will

00:19:49,840 --> 00:19:52,160
run on Ruby 1.8 or run on RBX. It

00:19:52,160 --> 00:19:55,230
will run on JRuby. But Pry plus is where

00:19:55,240 --> 00:19:56,961
all the cool stuff is.

00:19:56,961 --> 00:19:59,419
So if you're running on Ruby 1.9 or Ruby

00:19:59,420 --> 00:20:01,530
2.0, install Pry plus and you'll get a whole

00:20:01,530 --> 00:20:04,520
load more magic up along with your Pry. And

00:20:04,540 --> 00:20:06,560
the two things I want to point out or

00:20:06,560 --> 00:20:11,490
ought to mention specifically are pry-rescue/minitest and pry-rescue/rspec.

00:20:11,490 --> 00:20:14,740
These things are kind of magic. What they do

00:20:14,740 --> 00:20:17,581
is, when your tests fail, instead of having to

00:20:17,581 --> 00:20:20,169
wait for the other 452 tests to pass, and

00:20:20,169 --> 00:20:23,201
then seeing the error message underneath, they just pause

00:20:23,220 --> 00:20:25,700
you right there and say, this test failed. Maybe

00:20:25,700 --> 00:20:27,200
you should look at it right now. It will

00:20:27,200 --> 00:20:30,279
save you time.

00:20:30,280 --> 00:20:31,850
We have it for minitest, we have it for

00:20:31,850 --> 00:20:34,280
rspec. If other people are using better testing frameworks,

00:20:34,280 --> 00:20:38,211
we can talk about integrating those afterwards.

00:20:38,220 --> 00:20:41,840
How does this work?

00:20:41,840 --> 00:20:43,139
So I have a test file - I'm actually

00:20:43,140 --> 00:20:44,870
going to be testing that line of code we

00:20:44,870 --> 00:20:47,350
just, I just showed you in the REPL. I

00:20:47,350 --> 00:20:49,571
run the test, it's going to fail. So Pry's

00:20:49,580 --> 00:20:53,649
going to open. It says, I expected to find

00:20:53,649 --> 00:20:56,790
two users. So here it's finding users, which is

00:20:56,790 --> 00:20:59,181
the line of code, it should find both the

00:20:59,181 --> 00:21:01,300
non-admin user called Conrad and the admin user called

00:21:01,300 --> 00:21:02,259
Conrad Irwin.

00:21:02,260 --> 00:21:07,000
But for some reason it's only finding one.

00:21:07,000 --> 00:21:08,890
I don't really know what the problem is yet,

00:21:08,920 --> 00:21:10,831
but the chances are it's inside the find user

00:21:10,831 --> 00:21:12,769
method. And so what I'm going to do is

00:21:12,769 --> 00:21:14,201
I'm going to add a break point using the

00:21:14,201 --> 00:21:16,259
break command at the find user method.

00:21:16,260 --> 00:21:19,890
This means next time the find_user method gets called,

00:21:19,890 --> 00:21:22,041
instead of running the code, it's going to dump

00:21:22,060 --> 00:21:23,049
me into Pry.

00:21:23,049 --> 00:21:25,162
So I've added that break point. It's kind of

00:21:25,162 --> 00:21:27,440
verbose, but here it is. Break point on Mongo

00:21:27,440 --> 00:21:30,190
dot RB line three. And you can see that's

00:21:30,200 --> 00:21:32,619
exactly where I was talking.

00:21:32,620 --> 00:21:34,951
All I need to do now is call find_user

00:21:34,960 --> 00:21:36,430
again. But I don't want to have to type

00:21:36,430 --> 00:21:38,779
stuff in manually because the chances are I'll do

00:21:38,780 --> 00:21:43,030
it wrong. So instead I can just run try-again.

00:21:43,030 --> 00:21:45,740
Try-again comes from Pry rescue. And in the context

00:21:45,740 --> 00:21:48,561
of minitest or Rspec will just rerun the failing

00:21:48,561 --> 00:21:51,739
test. That means you can get, that means you

00:21:51,740 --> 00:21:53,530
can just keep cycling over this test until it

00:21:53,540 --> 00:21:55,801
passes. You're not having to wait for the Rails

00:21:55,820 --> 00:21:57,840
environment to load. You're not having to wait for

00:21:57,840 --> 00:21:59,599
matches to be set up or anything. It's literally

00:21:59,600 --> 00:22:02,870
the smallest amount it can try again, it's going

00:22:02,870 --> 00:22:03,980
to do.

00:22:03,980 --> 00:22:06,050
If you use Pry rescue with Rails, try-again will

00:22:06,060 --> 00:22:08,130
like rerun the web request. If you're using Pry

00:22:08,130 --> 00:22:10,350
rescue on just a stand-alone script, it will rerun

00:22:10,350 --> 00:22:12,340
the script from the start. So this is kind

00:22:12,340 --> 00:22:15,040
of the power, let's do stuff again and again

00:22:15,040 --> 00:22:18,600
and again, to see when it breaks.

00:22:18,600 --> 00:22:20,311
I run try-again, and you can see that my

00:22:20,320 --> 00:22:23,159
break point's been hit. So up here, break point

00:22:23,160 --> 00:22:25,990
1 first hit, and then here's the little arrow

00:22:25,990 --> 00:22:28,890
that says, and you're ready to start debugging find

00:22:28,900 --> 00:22:29,850
user.

00:22:29,850 --> 00:22:31,850
I can use step or next to move the

00:22:31,850 --> 00:22:35,901
arrow down a line. The difference is step, if

00:22:35,920 --> 00:22:38,279
there are any function calls, would step into them

00:22:38,280 --> 00:22:40,701
so I could debug the sub functions. Next is

00:22:40,701 --> 00:22:43,379
just working over the top. And so if I

00:22:43,400 --> 00:22:45,480
do that again, I'm on line six. Line six

00:22:45,480 --> 00:22:47,290
looks like the scary one. So it's probably the

00:22:47,290 --> 00:22:48,660
broken one.

00:22:48,660 --> 00:22:50,630
I don't want to step over it yet, because

00:22:50,630 --> 00:22:52,400
I want to debug it. And so I can

00:22:52,420 --> 00:22:55,150
use the play command and just say play line

00:22:55,150 --> 00:22:55,760
six.

00:22:55,760 --> 00:22:57,990
What this is going to do is, it's as

00:22:57,990 --> 00:23:00,551
though I stepped over it, but instead it's just

00:23:00,560 --> 00:23:02,310
going to run it and leave my arrow where

00:23:02,320 --> 00:23:04,599
it is.

00:23:04,600 --> 00:23:07,100
So indeed, we can see, playing line six gives

00:23:07,100 --> 00:23:09,800
me only one user back. It's only finding the

00:23:09,800 --> 00:23:12,680
admin user. It's not finding that cognito Conrad user

00:23:12,680 --> 00:23:14,130
I had before.

00:23:14,130 --> 00:23:16,050
And that's kind of surprising, because looking at line

00:23:16,050 --> 00:23:18,061
six, that's exactly what we had in the REPL.

00:23:18,061 --> 00:23:20,729
Why is it broken? Well, I'm guessing the problem

00:23:20,729 --> 00:23:24,110
is names. It involves the only thing I've changed.

00:23:24,140 --> 00:23:26,091
And if I look at names, you can see,

00:23:26,091 --> 00:23:28,249
well, there's missing a space. So if I show

00:23:28,249 --> 00:23:31,191
you the source of the current method, show source

00:23:31,200 --> 00:23:33,499
with no arguments does that, you can see that

00:23:33,500 --> 00:23:35,140
when I added the first and last name together

00:23:35,140 --> 00:23:37,480
I forgot you need to join them with a

00:23:37,480 --> 00:23:37,780
space.

00:23:37,780 --> 00:23:39,451
This is the kind of mistake I make all

00:23:39,460 --> 00:23:40,950
the time. I don't know whether you guys are

00:23:40,950 --> 00:23:45,799
just better programmers than me, but that's how it

00:23:45,800 --> 00:23:49,040
is. Edit is Pry's way of saying, OK, we've

00:23:49,040 --> 00:23:51,760
found the problem. Let's fix it. So edit dash

00:23:51,760 --> 00:23:54,380
m is edit the current method.

00:23:54,380 --> 00:23:56,811
And this is obviously very easy to do. I

00:23:56,820 --> 00:23:59,499
just add a space in here.

00:23:59,500 --> 00:24:03,430
And once I've done that, the find_user method is

00:24:03,430 --> 00:24:05,300
now fixed. Pry is reloaded it for me. I

00:24:05,300 --> 00:24:06,800
don't have to close everything and start it up

00:24:06,800 --> 00:24:09,470
again. Pry will take care of that. So all

00:24:09,470 --> 00:24:11,630
I need to do is disable this break point

00:24:11,630 --> 00:24:14,190
on find_user - I think it's, disable the first

00:24:14,220 --> 00:24:16,530
break point.

00:24:16,530 --> 00:24:19,230
And now I can stop debugging and just try

00:24:19,230 --> 00:24:21,780
again. And hopefully now the test will pass. Because

00:24:21,780 --> 00:24:25,620
I fixed the methods so that find_user actually works.

00:24:25,620 --> 00:24:28,290
And indeed, when I run it, that's true.

00:24:28,290 --> 00:24:30,530
So you can see I had one test, and

00:24:30,540 --> 00:24:32,790
it thinks no failures just because I called them

00:24:32,790 --> 00:24:39,770
and rescued them for it.

00:24:45,220 --> 00:24:47,470
So the whole idea here is I run the

00:24:47,470 --> 00:24:50,551
test once. I loaded Rails once. I loaded everything

00:24:50,560 --> 00:24:53,149
just once. And I was able to run several

00:24:53,149 --> 00:24:56,860
lines of code, fix the problem, really interactively, and

00:24:56,860 --> 00:24:58,980
then move on the next thing. If I'd had

00:24:58,980 --> 00:25:00,500
many failing tests, it would have just dumped me

00:25:00,500 --> 00:25:01,791
in Pry the next time as well. And then

00:25:01,820 --> 00:25:06,269
I could have fixed it.

00:25:06,269 --> 00:25:08,360
A few more commands this time. So the top

00:25:08,360 --> 00:25:12,280
few are from Pry plus. Try-again is Pry rescue,

00:25:12,280 --> 00:25:14,880
and it gives you this idea of let's rerun

00:25:14,880 --> 00:25:17,451
the tiniest bit that failed again and see if

00:25:17,460 --> 00:25:19,570
it still fails.

00:25:19,570 --> 00:25:22,039
Then break is adding break points. If you've used

00:25:22,040 --> 00:25:24,670
the Chrome developer tools, though, Eclipse, or any other

00:25:24,670 --> 00:25:26,740
debugger, you'll know there are break points support. You

00:25:26,740 --> 00:25:29,080
just say, please stop on this line of code.

00:25:29,100 --> 00:25:31,260
Pry, you just name the method. You can name

00:25:31,260 --> 00:25:32,740
a file on a line if you want to.

00:25:32,740 --> 00:25:35,071
And that will just work.

00:25:35,071 --> 00:25:38,430
Then step and next are moving around once you

00:25:38,430 --> 00:25:40,469
stop the debugger. You can also use continue to

00:25:40,469 --> 00:25:43,671
say stop debugging now, or finish, to finish the

00:25:43,680 --> 00:25:47,539
current function and go back up to the previous

00:25:47,540 --> 00:25:48,380
one.

00:25:48,380 --> 00:25:51,150
Play is actually core Pry, and it's basically a

00:25:51,150 --> 00:25:53,561
copy and paste helper. I could have just copied

00:25:53,561 --> 00:25:55,109
and pasted that line into Pry, and it would

00:25:55,140 --> 00:25:57,300
have had the same effect. But the chances are

00:25:57,300 --> 00:25:59,310
I'd have copied, like, that line number at the

00:25:59,310 --> 00:26:01,240
start, or something else would have gone wrong.

00:26:01,240 --> 00:26:02,900
So if I can use play, that's just more

00:26:02,900 --> 00:26:04,010
reliable.

00:26:04,010 --> 00:26:07,780
There's also the edit command. Edit is just magic

00:26:07,780 --> 00:26:10,410
meta-programming, and I'm very, very glad that Ruby lets

00:26:10,410 --> 00:26:12,620
you do things like this. But we save the

00:26:12,620 --> 00:26:14,811
file and then we read it again, and that

00:26:14,820 --> 00:26:17,509
causes the methods to be redefined. It causes everything

00:26:17,509 --> 00:26:20,140
to just get back into a good state.

00:26:20,140 --> 00:26:22,421
So it's really nice that Ruby lets you do

00:26:22,421 --> 00:26:24,639
that, and Pry just wraps it in a nice

00:26:24,640 --> 00:26:30,431
and easy to use way.

00:26:30,440 --> 00:26:34,769
So even with testing, stuff still goes wrong. So

00:26:34,769 --> 00:26:37,110
bugs just get through the net. Either because they

00:26:37,120 --> 00:26:39,540
don't happen very often, like GitHub eight in a

00:26:39,540 --> 00:26:42,610
billion is very good, but it's not zero. And

00:26:42,610 --> 00:26:45,710
the problem with this kind of bug is they

00:26:45,720 --> 00:26:48,350
get really hard to find. They get really hard

00:26:48,350 --> 00:26:51,500
to fix. Because the chances are they happen, like,

00:26:51,500 --> 00:26:53,640
only in production, and you never see them. Or

00:26:53,640 --> 00:26:56,931
they happen if Mongo takes more than five seconds

00:26:56,940 --> 00:26:59,759
but less than seven seconds to reply. Or something

00:26:59,760 --> 00:27:00,340
like that.

00:27:00,340 --> 00:27:01,821
And you just have to use your ingenuity to

00:27:01,821 --> 00:27:04,459
find them. The company I'm working at now is

00:27:04,460 --> 00:27:06,821
bugsnag, and we try and help you with this.

00:27:06,821 --> 00:27:09,810
So we're like, OK, we know you've REPLd stuff.

00:27:09,810 --> 00:27:13,170
We know you've tested stuff. Everything's working in development.

00:27:13,180 --> 00:27:15,629
But still some stuff's going wrong in production.

00:27:15,629 --> 00:27:17,480
And so what we do is when that happens,

00:27:17,480 --> 00:27:19,850
we send you an email, we say, hey, user

00:27:19,860 --> 00:27:22,840
Fred just requested this page. It crashed for him.

00:27:22,840 --> 00:27:24,821
This is what we think is why and then

00:27:24,840 --> 00:27:26,739
we let you try and fix it yourself.

00:27:26,740 --> 00:27:30,310
How do you fix bugs that happen in production?

00:27:30,310 --> 00:27:32,130
Well, three steps.

00:27:32,130 --> 00:27:35,480
Firstly, reproduce them. If you can't reproduce the bug,

00:27:35,480 --> 00:27:37,941
there's no way you know if you've fixed it.

00:27:37,941 --> 00:27:41,469
Because you can't tell. And this is, like, a

00:27:41,469 --> 00:27:45,320
really difficult thing. This requires guesswork, almost. You can

00:27:45,320 --> 00:27:48,370
just be, you can see what's gone wrong. You

00:27:48,380 --> 00:27:49,691
can try and work out from the request if

00:27:49,700 --> 00:27:52,539
there's anything odd happening. But in the end, you

00:27:52,540 --> 00:27:54,191
just have to try stuff and see if you

00:27:54,200 --> 00:27:56,909
can get the same exception.

00:27:56,909 --> 00:27:59,340
Once you have that, you then have to find

00:27:59,340 --> 00:28:02,140
the problem. So there's a big difference between the

00:28:02,140 --> 00:28:04,480
place where an exception was raised and the place

00:28:04,480 --> 00:28:06,880
where your code is broken. So even once you're

00:28:06,880 --> 00:28:09,860
reproducing an exception locally, finding the actual point of

00:28:09,860 --> 00:28:12,120
the problem can be tricky.

00:28:12,120 --> 00:28:13,681
Fixing it should be easy. Fixing it is just

00:28:13,681 --> 00:28:15,619
writing code. I've already shown you how to do

00:28:15,620 --> 00:28:17,750
that. You just use a REPL. You can then

00:28:17,750 --> 00:28:19,640
write some tests so that the code never breaks

00:28:19,640 --> 00:28:22,650
again. That's easy. You just use a REPL.

00:28:22,650 --> 00:28:24,120
So the thing I really want to concentrate on

00:28:24,120 --> 00:28:28,350
now is how do you find the problem?

00:28:28,360 --> 00:28:30,311
And so this is the third and last kind

00:28:30,320 --> 00:28:35,289
of Pry show-off session. I have a file, run

00:28:35,289 --> 00:28:37,480
dot rb, and when I run it, I get

00:28:37,480 --> 00:28:41,130
this exception. Undefined method plus for nil.

00:28:41,130 --> 00:28:44,740
Anyone seen that one before?

00:28:44,740 --> 00:28:46,780
And the worst thing about it is, that's not

00:28:46,800 --> 00:28:49,040
going to be where the problem is. So this

00:28:49,040 --> 00:28:51,910
exception's happening on line 5 of Mongo dot rb.

00:28:51,910 --> 00:28:53,811
So let's have a look. Well, this is the

00:28:53,820 --> 00:28:58,070
method we've seen before. This line is crashing.

00:28:58,070 --> 00:28:59,589
For the purposes of today, I'm just gonna add

00:28:59,600 --> 00:29:01,100
a binding dot Pry, because I want to show

00:29:01,100 --> 00:29:02,470
you guys this.

00:29:02,470 --> 00:29:04,380
In real life, I would have just rerun the

00:29:04,380 --> 00:29:06,530
command with rescue instead of Ruby, and that would

00:29:06,530 --> 00:29:09,431
have intercepted it with Pry rescue, just like the

00:29:09,440 --> 00:29:12,859
minitest example. But here's how you do stuff manually.

00:29:12,860 --> 00:29:14,801
So if you put a binding dot Pry in,

00:29:14,801 --> 00:29:16,539
this is going to open Pry on the current

00:29:16,540 --> 00:29:20,840
binding. Bindings are magic Ruby objects that just encapsulate

00:29:20,840 --> 00:29:22,950
the currently running code.

00:29:22,950 --> 00:29:24,880
So this binding has access to names, it has

00:29:24,880 --> 00:29:27,820
access to self, it has access to everything that

00:29:27,820 --> 00:29:31,210
running code has access to. And there are kind

00:29:31,220 --> 00:29:33,691
of three uses for binding dot Pry. One is

00:29:33,700 --> 00:29:36,229
finding why exceptions failed, which is what we're going

00:29:36,229 --> 00:29:37,910
to see now.

00:29:37,910 --> 00:29:40,530
Another is for understanding code. If you have some

00:29:40,540 --> 00:29:43,171
complicated algorithm, and you can see the input's coming

00:29:43,180 --> 00:29:44,749
in here, you can see it's returning the right

00:29:44,749 --> 00:29:47,530
result, but you still don't know why, if you

00:29:47,540 --> 00:29:49,380
add a binding dot pry in, the chances are

00:29:49,380 --> 00:29:51,640
you can print out the values from inside Pry

00:29:51,640 --> 00:29:53,590
and just get a feel for what the algorithm

00:29:53,590 --> 00:29:56,120
is actually doing.

00:29:56,140 --> 00:29:58,810
The third use case is kind of edge case-y,

00:29:58,810 --> 00:29:59,970
but I've used it a few times, and it's

00:29:59,970 --> 00:30:03,051
good fun. Have you ever been implementing something and

00:30:03,060 --> 00:30:05,719
you're like, I wish someone else had implemented that

00:30:05,720 --> 00:30:09,110
other method? Well, what you can do is implement

00:30:09,110 --> 00:30:11,150
the method, but instead of writing the code, just

00:30:11,150 --> 00:30:13,330
put a binding dot Pry in, and then when

00:30:13,340 --> 00:30:16,040
that sub-function gets called, you just return the right

00:30:16,040 --> 00:30:18,400
value from Pry, and the calling code can tend

00:30:18,400 --> 00:30:19,921
to continue to run.

00:30:19,921 --> 00:30:21,639
So in that way you can kind of debug

00:30:21,640 --> 00:30:24,510
one function, even if it's dependents haven't been written

00:30:24,510 --> 00:30:28,530
yet. But for now we're just going to use

00:30:28,540 --> 00:30:31,240
the first use case. Something is going wrong on

00:30:31,240 --> 00:30:32,760
the next line, and I want to know what

00:30:32,760 --> 00:30:34,450
it is. So I'm going to add a binding

00:30:34,460 --> 00:30:37,350
dot pry in just before it crashes. If I

00:30:37,350 --> 00:30:40,410
run, run dot rb again, instead of crashing, it

00:30:40,410 --> 00:30:43,200
now opens Pry. And I can show you the

00:30:43,220 --> 00:30:44,140
play command again.

00:30:44,140 --> 00:30:46,740
If I play line six over this now I

00:30:46,740 --> 00:30:49,710
get this crash that I've seen before. Undefined method

00:30:49,710 --> 00:30:56,390
plus for nil class. Well, OK, that was great.

00:30:56,390 --> 00:30:58,291
But how am I going to debug this? Clearly

00:30:58,300 --> 00:31:01,849
first is nil. Something is wrong somewhere else in

00:31:01,849 --> 00:31:04,530
the code. And this is where Pry stack explorer

00:31:04,530 --> 00:31:08,770
comes in. So the up command is one of

00:31:08,780 --> 00:31:11,680
the methods that it provides for accessing this stack.

00:31:11,700 --> 00:31:13,900
So programs that all organize into a call stacks,

00:31:13,900 --> 00:31:16,020
it starts at the top and then each thing

00:31:16,040 --> 00:31:19,170
calls down into the function below. So something is

00:31:19,180 --> 00:31:21,280
passing nil down the stack. We want to go

00:31:21,280 --> 00:31:22,960
up and have a look at what it is.

00:31:22,960 --> 00:31:24,960
We can just run up.

00:31:24,960 --> 00:31:26,480
And you can see now, I've moved to line

00:31:26,480 --> 00:31:29,110
five of run dot rb and something is calling

00:31:29,110 --> 00:31:33,240
find_user with request dot first_name. I would reckon that

00:31:33,240 --> 00:31:35,311
request dot first_name is going to be nil.

00:31:35,320 --> 00:31:38,399
And indeed it is. Why?

00:31:38,400 --> 00:31:43,010
Well, I don't know yet. I'm not inside request.

00:31:43,010 --> 00:31:44,321
So you can use up and down to move

00:31:44,321 --> 00:31:46,539
around the call stack, and then you can use

00:31:46,540 --> 00:31:49,580
cd to just move around sideways. So I've moved

00:31:49,580 --> 00:31:51,130
up one level, and now I'm going to move

00:31:51,130 --> 00:31:54,230
sideways into request. CD comes from Bash, same as

00:31:54,230 --> 00:31:56,480
ls. You should be - you should feel familiar

00:31:56,480 --> 00:31:57,970
with them is the idea.

00:31:58,000 --> 00:32:00,640
I cd into request. Out of habit I run

00:32:00,640 --> 00:32:03,490
an ls and you can see that there's a

00:32:03,490 --> 00:32:05,870
first_name and a last_name method. There's this crazy Pry

00:32:05,870 --> 00:32:09,280
method which is just Pry internals. You can see

00:32:09,280 --> 00:32:11,440
it has a instance variable at data, and then

00:32:11,440 --> 00:32:14,750
there's all of these local variables. As a general

00:32:14,750 --> 00:32:16,430
rule, anything that starts and ends with underscore is

00:32:16,440 --> 00:32:19,650
Pry-related. And this is no exception.

00:32:19,650 --> 00:32:21,541
I want to highlight three of these which are

00:32:21,541 --> 00:32:23,009
useful, and the rest you can pretty much ignore

00:32:23,020 --> 00:32:24,811
forever.

00:32:24,820 --> 00:32:26,449
So let's say I do something like seven plus

00:32:26,449 --> 00:32:30,390
eight. Fifteen. That's great. Now in the next line

00:32:30,390 --> 00:32:32,690
I want to reference that output, fifteen. I can

00:32:32,720 --> 00:32:35,140
just use underscore instead. And underscore is going to

00:32:35,140 --> 00:32:38,571
be fifteen, because it always refers to the last

00:32:38,571 --> 00:32:39,159
output.

00:32:39,160 --> 00:32:41,220
Underscore underscore is there because sometimes you just want

00:32:41,220 --> 00:32:46,960
to go one before. It does the same thing.

00:32:46,960 --> 00:32:49,230
You can use underscore out underscore to get further

00:32:49,230 --> 00:32:51,990
back, but it's a bit complicated. The other useful

00:32:51,990 --> 00:32:54,530
one, however, is underscore ex underscore. Which is the

00:32:54,540 --> 00:32:56,500
most recently raised exception.

00:32:56,500 --> 00:32:58,820
So there's actually the thing we're trying to debug

00:32:58,820 --> 00:33:01,210
right now, and you can do things like get

00:33:01,210 --> 00:33:06,541
its backtrace, ex dot backtrace. But because that's a

00:33:06,560 --> 00:33:08,639
really common thing to do, Pry actually has a

00:33:08,640 --> 00:33:11,600
command to help you. And chances are exceptions annoy

00:33:11,600 --> 00:33:15,421
you a bit, so if you just run wtf

00:33:15,440 --> 00:33:16,570
it gives you the first five lines of the

00:33:16,570 --> 00:33:18,989
backtrace.

00:33:19,040 --> 00:33:26,040
There you go.

00:33:26,300 --> 00:33:31,229
Anyway. We were debugging this thing. What's wrong? So

00:33:31,229 --> 00:33:35,330
the first_name method is returning nil. Why? I don't

00:33:35,340 --> 00:33:36,740
know. Let's look at the source code.

00:33:36,760 --> 00:33:39,370
So there's dollar again, or show source. It's just

00:33:39,370 --> 00:33:40,730
going to let me have a look and to

00:33:40,730 --> 00:33:43,551
see what's happening. Well, the first_name method is just

00:33:43,560 --> 00:33:46,389
reading the first name out of the data. That

00:33:46,389 --> 00:33:49,090
looks fine. The only thing that could possibly be

00:33:49,100 --> 00:33:52,450
wrong is if first_name isn't in data.

00:33:52,460 --> 00:33:54,640
And if you look, you'll see I've committed kind

00:33:54,640 --> 00:33:58,210
of the cardinal Ruby sin. These are strings. That's

00:33:58,210 --> 00:34:02,460
a symbol. It doesn't work. Yeah. My least favorite

00:34:02,460 --> 00:34:05,600
thing. I can use the edit command. It takes

00:34:05,600 --> 00:34:08,400
a method as well. Edit dash m will be

00:34:08,400 --> 00:34:10,751
the current method. If you give it a first_name

00:34:10,760 --> 00:34:12,609
method it will edit the first_name method.

00:34:12,620 --> 00:34:13,971
And then I can quickly fix this. I see

00:34:13,971 --> 00:34:17,810
last_name has exactly the same mistake.

00:34:17,810 --> 00:34:21,509
And so now I've fixed these things. Pry has

00:34:21,509 --> 00:34:24,421
reloaded them automatically. I can call first_name immediately. There

00:34:24,421 --> 00:34:27,700
you go. It's fixed. So I'm done debugging. I

00:34:27,700 --> 00:34:30,499
can cd back out again - dot dot, straight

00:34:30,500 --> 00:34:33,010
from Bash. And then - what was I looking

00:34:33,020 --> 00:34:36,070
at? Whereami is going to just show me where

00:34:36,070 --> 00:34:36,870
I am.

00:34:36,880 --> 00:34:39,050
So if you've done a lot of cd'ing around,

00:34:39,060 --> 00:34:40,760
it gets hard to keep track. If you've moved

00:34:40,760 --> 00:34:42,580
up and down the call stack a few times,

00:34:42,580 --> 00:34:44,491
it's hard to keep track. So whereami, it'll just

00:34:44,500 --> 00:34:45,960
get you centered back in.

00:34:45,960 --> 00:34:46,779
Yeah?

00:34:46,780 --> 00:34:49,241
AUDIENCE: [indecipherable - 00:34:49]

00:34:49,241 --> 00:34:53,909
C.I.: I think there's - you call a thing

00:34:53,909 --> 00:34:57,371
called pi- pry-backtrace, which is just where you open

00:34:57,380 --> 00:35:00,650
Pry and the backtrace up there. So here, it

00:35:00,650 --> 00:35:04,420
will be - not paged, but that's essentially what

00:35:04,420 --> 00:35:04,930
it does.

00:35:04,930 --> 00:35:06,460
AUDIENCE: [indecipherable - 00:35:06]

00:35:06,460 --> 00:35:09,710
C.I.: Yeah. And it will do that. The, I

00:35:09,710 --> 00:35:12,900
think that's the best command for using it.

00:35:12,900 --> 00:35:15,360
So if I ran whereami, it's showing me I'm

00:35:15,360 --> 00:35:18,499
here. I can run down and then I'm back

00:35:18,500 --> 00:35:21,471
into find_user, and this is where I was.

00:35:21,480 --> 00:35:23,819
Now I'm going to remove that binding dot pry.

00:35:23,820 --> 00:35:25,391
This is one of the bad things about Pry.

00:35:25,400 --> 00:35:26,460
If you forget to remove it, it's just going

00:35:26,460 --> 00:35:28,720
to pause and wait for you forever. So I

00:35:28,720 --> 00:35:31,789
remove binding dot pry. This program crashed because I

00:35:31,789 --> 00:35:34,411
didn't fix it fast enough. It had already called

00:35:34,420 --> 00:35:36,720
find_user with nil. But now when I run ruby

00:35:36,720 --> 00:35:39,259
run dot rb, it's gonna print out my email

00:35:39,260 --> 00:35:39,951
addresses.

00:35:39,960 --> 00:35:42,359
So it's fixed. And I had to run it

00:35:42,360 --> 00:35:44,850
once. Luckily this would have been a really quick

00:35:44,850 --> 00:35:46,701
trip to run over and over again. But imagine

00:35:46,701 --> 00:35:48,700
if that were something in a Rails initializer, or

00:35:48,700 --> 00:35:50,019
something else that's going to take ten or fifteen

00:35:50,020 --> 00:35:53,251
seconds every single time you run it. It gets

00:35:53,260 --> 00:35:54,609
frustrating.

00:35:54,609 --> 00:35:58,040
Quick recap of the commands I've shown you. Binding

00:35:58,040 --> 00:36:00,431
dot pry - not really a command, but the

00:36:00,440 --> 00:36:03,069
reason ?? or ?? of Pry [00:36:03]. So this

00:36:03,069 --> 00:36:05,651
was the reason that John Mare was like, yeah,

00:36:05,660 --> 00:36:07,849
we need to, we need to share this code.

00:36:07,849 --> 00:36:09,701
If you can open a REPL anywhere in your

00:36:09,701 --> 00:36:11,920
app, it enables so much cool stuff. You can

00:36:11,920 --> 00:36:14,839
understand things, you can debug things. You can even

00:36:14,840 --> 00:36:18,991
just, you know, intercept it and return manual values.

00:36:19,000 --> 00:36:21,799
Then there's cd. If you want to look inside

00:36:21,800 --> 00:36:23,931
an object, if you want to call private methods,

00:36:23,931 --> 00:36:26,120
if you want to get at instance variables, cd

00:36:26,120 --> 00:36:27,950
into the object. It will let you do whatever

00:36:27,950 --> 00:36:30,230
you like. It's as though you're running code inside

00:36:30,240 --> 00:36:32,059
that method.

00:36:32,060 --> 00:36:34,151
Up and down let you move around the call

00:36:34,160 --> 00:36:37,140
stack. If you have a nil bug, chances are

00:36:37,140 --> 00:36:39,880
it's not doing it nil plus in the code.

00:36:39,880 --> 00:36:41,890
Something has passed a nil in. And so being

00:36:41,890 --> 00:36:43,519
able to move around the call stack lets you

00:36:43,520 --> 00:36:44,741
debug stuff like that.

00:36:44,741 --> 00:36:48,009
If you've been using those three for awhile, whereami

00:36:48,009 --> 00:36:50,201
will show you where you are. I didn't actually

00:36:50,201 --> 00:36:52,470
show you the help command. We touched on it

00:36:52,470 --> 00:36:55,249
earlier. But if you're inside Pry and you're like,

00:36:55,260 --> 00:36:58,411
I wonder what Pry can do - try running

00:36:58,420 --> 00:37:00,759
help, and shield your eyes a little bit cause

00:37:00,760 --> 00:37:03,371
it goes on for awhile.

00:37:03,380 --> 00:37:05,039
But the basic useful ones are at the top.

00:37:05,039 --> 00:37:07,451
Here you've got cd, you've got ls, you've got

00:37:07,460 --> 00:37:10,849
pry-backtrace that I just mentioned. Then there's various other

00:37:10,849 --> 00:37:14,330
things. Whereami, wtf. The more question marks you add

00:37:14,330 --> 00:37:19,790
to wtf, the more backtrace if gives you.

00:37:19,800 --> 00:37:21,850
And then various commands for dealing with source code.

00:37:21,860 --> 00:37:24,181
Edit, play, et cetera, et cetera. Right down at

00:37:24,181 --> 00:37:28,880
the bottom you'll find that I have, and I

00:37:28,880 --> 00:37:32,059
get that various gems installed, these almost all come

00:37:32,060 --> 00:37:35,461
from the Pry plus package. So there's more documentation.

00:37:35,461 --> 00:37:38,940
Pry plus gives you documentation for Ruby syntax as

00:37:38,940 --> 00:37:42,420
well as standard library and gems as well.

00:37:42,420 --> 00:37:46,370
Pry-em is just eventmachine. Integration, if you guys are

00:37:46,370 --> 00:37:48,910
using eventmachine, that's pretty useful. Git lets you do

00:37:48,910 --> 00:37:51,680
git operations with system methods. And then the two

00:37:51,680 --> 00:37:56,200
at the bottom are the real meta-programm-y ones. Catch

00:37:56,200 --> 00:38:03,200
unhandled exception and move around in the call stack.

00:38:04,820 --> 00:38:07,161
So in summary, you should be using a REPL.

00:38:07,161 --> 00:38:09,309
If you're not using it at all at the

00:38:09,309 --> 00:38:11,520
moment, then use it a little bit. If you're

00:38:11,520 --> 00:38:13,141
using it a little bit, use it more. It's

00:38:13,141 --> 00:38:15,819
not going to waste time. The chances are, when

00:38:15,820 --> 00:38:18,991
you write code, it actually doesn't work. And so

00:38:19,000 --> 00:38:21,279
if you can get very, very quickly to a

00:38:21,280 --> 00:38:23,651
point where you have confidence in the code, that's

00:38:23,651 --> 00:38:24,849
going to save you time.

00:38:24,849 --> 00:38:27,181
I also like to think it improves the quality

00:38:27,181 --> 00:38:29,640
of code. If it takes no time to write

00:38:29,660 --> 00:38:31,539
a line of code that works, you have no

00:38:31,540 --> 00:38:33,181
incentive to go, well I'm not gonna touch that

00:38:33,181 --> 00:38:36,309
code because it's scary. You can just fix it.

00:38:36,309 --> 00:38:38,501
And in that way of just really getting in

00:38:38,501 --> 00:38:41,440
touch with your code base is very useful.

00:38:41,440 --> 00:38:44,990
It's obviously also a lot of fun. If you're

00:38:45,000 --> 00:38:46,619
going to use a REPL and you're using Ruby,

00:38:46,620 --> 00:38:49,330
you should use Pry. IRB is OK, but Pry

00:38:49,330 --> 00:38:54,431
has color and commands and it's robust and it

00:38:54,440 --> 00:38:56,510
works. And that's about all I wanted to say.

00:38:56,510 --> 00:38:57,039

YouTube URL: https://www.youtube.com/watch?v=D9j_Mf91M0I


