Title: Ruby Conf 2013 - Recommendation Engines with Redis and Ruby by Evan Light
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	A couple of years ago, a client asked me to build a recommendation engine for them. Coming into this with a minimal knowledge of statistical math, I ultimately built a relatively simple recommendation engine in Ruby. The design made heavy use of Redis Sets, Lists, and Hashes in order to greatly reduce the number of SQL queries to provide recommendations.

This talk will be a case study discussing the object-oriented considerations in designing a scalable service, how Redis was a good fit for the project, and some of the painful lessons that I learned along the way so that you don't have to repeat them.

Help us caption & translate this video!

http://amara.org/v/FG4w/
Captions: 
	00:00:16,020 --> 00:00:18,020
EVAN LIGHT: OK, so it's 2:01.

00:00:18,020 --> 00:00:20,040
I guess we better get started, cause I was told that,

00:00:20,040 --> 00:00:21,809
all right I have to hit this little button,

00:00:21,820 --> 00:00:24,910
that once I run out of time this little doo-hicky here

00:00:24,910 --> 00:00:25,800
is gonna make lots of noise

00:00:25,840 --> 00:00:27,121
and then they're gonna bring out the,

00:00:27,140 --> 00:00:29,338
the gong, and it won't be pretty.

00:00:29,338 --> 00:00:34,351
So yeah, that's me. And we're, so right. I'm

00:00:34,360 --> 00:00:35,930
mixed up. I'm Xavier Shay. I'm here to talk

00:00:35,930 --> 00:00:37,880
about Ruby Profiling. If you were looking for this

00:00:37,880 --> 00:00:39,530
Evan Light guy, he's in that other room.

00:00:39,530 --> 00:00:41,920
Oh, wait, no that's not right. Yeah, OK. We're

00:00:41,940 --> 00:00:43,960
- I'm Evan Light and we're talking about recommendation

00:00:43,960 --> 00:00:46,010
engines with Ruby and Redis, and why are there

00:00:46,010 --> 00:00:49,800
more people in here than I expected? OK.

00:00:49,800 --> 00:00:52,520
So, very briefly about me - I created and

00:00:52,520 --> 00:00:55,140
run this event out in northern Virginia called Ruby

00:00:55,140 --> 00:00:58,730
DCamp. It's a three-day nerd commune in the woods

00:00:58,730 --> 00:01:01,650
for Ruby programmers. If you haven't heard about it,

00:01:01,660 --> 00:01:03,640
there are a bunch of handy, a bunch people,

00:01:03,640 --> 00:01:07,870
participants here who have been before. So, but, in

00:01:07,880 --> 00:01:11,549
a nutshell, you come out in the woods, you

00:01:11,549 --> 00:01:13,341
hack on Ruby code, you hang out with awesome

00:01:13,341 --> 00:01:14,940
programmers, you are not allowed to leave until the

00:01:14,940 --> 00:01:16,580
very end.

00:01:16,580 --> 00:01:19,510
And the attendees decide on basically everything and they

00:01:19,520 --> 00:01:20,619
have to do all the chores. And that sounds

00:01:20,620 --> 00:01:21,860
like a lot of work, but it's really an

00:01:21,860 --> 00:01:24,021
awful lot of fun. Oh, and free. But you

00:01:24,021 --> 00:01:25,760
have to get, you have to get a code

00:01:25,760 --> 00:01:27,160
in order to be able to attend.

00:01:27,160 --> 00:01:29,531
Also, I work for this little company called rackspace.

00:01:29,531 --> 00:01:31,539
Can you guys raise your hands if you've heard

00:01:31,540 --> 00:01:34,140
of us before? Oh, that's pretty good. How many

00:01:34,140 --> 00:01:38,271
of you guys use us? Or, well, I guess

00:01:38,280 --> 00:01:42,889
I'll say currently use us. Hmm. That's not too

00:01:42,889 --> 00:01:44,761
many. We need to work on that some.

00:01:44,761 --> 00:01:47,260
So I'm a, a what they call developer advocate

00:01:47,260 --> 00:01:50,039
for rackspace. That is, that I'm here for you

00:01:50,040 --> 00:01:52,780
guys. Truly. And that's why I took the job.

00:01:52,780 --> 00:01:54,420
I wanted the job where I could do more

00:01:54,420 --> 00:01:56,920
for the Ruby community, and they basically said, great,

00:01:56,920 --> 00:01:58,661
that's the kind of person we want.

00:01:58,661 --> 00:02:00,949
So if there's anything I can do to make

00:02:00,960 --> 00:02:02,841
your lives, those few of you here, we need

00:02:02,841 --> 00:02:06,469
more, who use rackspace, make your lives better with

00:02:06,469 --> 00:02:09,131
rackspace, great. And for those of you who don't,

00:02:09,140 --> 00:02:10,509
if there's anything you can think of that would

00:02:10,509 --> 00:02:12,521
make you want to - yeah, we'd like to

00:02:12,521 --> 00:02:14,360
hear that, too.

00:02:14,360 --> 00:02:17,460
Let's see. So moving right along. In a nutshell,

00:02:17,460 --> 00:02:20,039
here's what we're gonna talk about. This is a

00:02:20,040 --> 00:02:24,821
case study of sorts for which I, a client

00:02:24,821 --> 00:02:26,399
whose problem I solved with a recommendation engine, we'll

00:02:26,400 --> 00:02:29,211
talk about that. So we'll talk about the context,

00:02:29,220 --> 00:02:30,670
the solution that I used - I need to

00:02:30,670 --> 00:02:34,619
not look at my phone. Some Redis-related tangents, because

00:02:34,620 --> 00:02:37,141
this is a really all about Redis and Ruby,

00:02:37,141 --> 00:02:40,100
and some painful lessons I learned along the way.

00:02:40,140 --> 00:02:42,580
So the context. The client of mine, who shall

00:02:42,580 --> 00:02:45,110
remain nameless, just so that way I can be

00:02:45,140 --> 00:02:49,459
a little freer with discussion. They had a soccer,

00:02:49,460 --> 00:02:51,380
or have, I should say, a soccer social network.

00:02:51,380 --> 00:02:53,171
So imagine Facebook but for soccer.

00:02:53,171 --> 00:02:55,850
Like, Facebook for blah blah blah, that's pretty common

00:02:55,850 --> 00:02:58,870
in California, right. But in their case, what made

00:02:58,870 --> 00:03:00,830
them really interesting is that they have a live

00:03:00,840 --> 00:03:03,540
feed of soccer data coming in all the time.

00:03:03,560 --> 00:03:06,159
So, as games are being played, every time there's

00:03:06,160 --> 00:03:08,001
a red card or a yellow card, or someone

00:03:08,001 --> 00:03:10,219
scores a goal or there's a penalty, they get

00:03:10,220 --> 00:03:12,591
a notification about it.

00:03:12,591 --> 00:03:13,910
And what they wanted to be able to do

00:03:13,920 --> 00:03:15,989
is they wanted their users to be able to

00:03:15,989 --> 00:03:21,281
see popular events, popular posts on their site, so

00:03:21,281 --> 00:03:24,789
the, the soccer event feed, as it's coming in,

00:03:24,800 --> 00:03:27,990
would be automatically spewed out into the website as

00:03:27,990 --> 00:03:31,120
a series of posts. And they would be contextualized,

00:03:31,120 --> 00:03:33,070
that is, that they would have tags instead, we'll

00:03:33,070 --> 00:03:35,090
see more on that later.

00:03:35,100 --> 00:03:37,010
So they wanted the, the users to be able

00:03:37,010 --> 00:03:41,340
to see popular posts and relevant posts. And in

00:03:41,340 --> 00:03:43,571
near real-time, in that in near real-time part means

00:03:43,580 --> 00:03:46,380
that there's a little bit more exciting.

00:03:46,380 --> 00:03:49,849
So recommendation engines - I'm sure that most of

00:03:49,849 --> 00:03:51,222
you are at least familiar with the idea, because

00:03:51,222 --> 00:03:53,939
you use this thing called Google, probably. Maybe you've

00:03:53,960 --> 00:03:58,801
heard of it. So recommendation engines are an approximation,

00:03:58,801 --> 00:04:02,160
and they are based on, obviously, large sets of

00:04:02,160 --> 00:04:07,380
data, ideally. And in this case, we want two

00:04:07,380 --> 00:04:08,899
different kinds of recommendations.

00:04:08,900 --> 00:04:13,361
Again, we want what's popular - that's pretty straightforward.

00:04:13,361 --> 00:04:16,990
But what's relevant - and that's very subjective.

00:04:16,990 --> 00:04:19,179
So they're based in statistics. But this is me

00:04:19,180 --> 00:04:22,541
an statistics. And, and, and, and this to me

00:04:22,541 --> 00:04:25,160
is actually what makes this talk interesting, because I

00:04:25,180 --> 00:04:30,740
built a recommendation engine being that dog.

00:04:30,740 --> 00:04:34,000
So statistics - so recommendation engines are canonically based

00:04:34,000 --> 00:04:38,240
in the statistical methods and, yeah. Statistical methods and

00:04:38,240 --> 00:04:39,900
I, we don't get along so great. So this

00:04:39,940 --> 00:04:41,160
is basically about how you do it with brute

00:04:41,160 --> 00:04:43,930
force and still get away with it.

00:04:43,930 --> 00:04:46,400
So other than being ignorant to statistical methods, quite

00:04:46,400 --> 00:04:47,990
frankly, I couldn't get the client to pay me

00:04:48,000 --> 00:04:50,139
for a day or two of research. I asked

00:04:50,140 --> 00:04:52,351
them - I said, wouldn't you like to do

00:04:52,351 --> 00:04:55,189
the, the right thing rather than just, just, than

00:04:55,189 --> 00:04:58,710
something probably ugly that'll work? And they said, no

00:04:58,710 --> 00:05:01,730
basically we trust you, so just go build it.

00:05:01,760 --> 00:05:03,611
But I'm telling you, it'd be better if I

00:05:03,611 --> 00:05:04,960
did a little research in advance.

00:05:04,960 --> 00:05:07,350
No, no - just go build it.

00:05:07,360 --> 00:05:07,979
OK.

00:05:07,980 --> 00:05:11,061
Cause I like being paid.

00:05:11,061 --> 00:05:13,090
So, why Ruby?

00:05:13,090 --> 00:05:16,540
Well, kind of the same thing there. Their developers

00:05:16,540 --> 00:05:19,610
knew Ruby. They knew JavaScript. I said maybe we

00:05:19,610 --> 00:05:22,899
should use something faster, you know, Java - which,

00:05:22,920 --> 00:05:24,621
I feel is really funny to say, having been

00:05:24,621 --> 00:05:26,460
a programmer for awhile. If you said Java was

00:05:26,460 --> 00:05:28,770
fast twenty years ago, you'd, I would, or if

00:05:28,770 --> 00:05:30,100
I'd said it, I'd be laughed out of the

00:05:30,100 --> 00:05:30,570
room.

00:05:30,580 --> 00:05:33,440
Nowadays, you have Java - fast. Go - fast.

00:05:33,440 --> 00:05:36,259
C - fast. Even, JVM languages. I said Clojure

00:05:36,260 --> 00:05:40,301
because I like Clojure. But, nope. They wanted Ruby.

00:05:40,301 --> 00:05:44,069
So, OK, Ruby it is. No statistical methods, really,

00:05:44,069 --> 00:05:47,071
fine. I'll figure something out.

00:05:47,080 --> 00:05:48,930
So let's talk about the system a little bit.

00:05:48,930 --> 00:05:51,939
Like, every social network, it has the typical nouns

00:05:51,940 --> 00:05:55,690
of users, posts, comments. You're used to this. But

00:05:55,690 --> 00:05:57,370
then we have a few new ones. We have

00:05:57,370 --> 00:06:01,211
teams, players. I forget, I think they, they had

00:06:01,220 --> 00:06:02,810
a match as a noun, but really a match

00:06:02,820 --> 00:06:05,809
to me was just two teams playing. An event

00:06:05,809 --> 00:06:07,561
with two teams on it.

00:06:07,580 --> 00:06:10,940
And then we had a series of verbs. So

00:06:10,940 --> 00:06:13,270
submitting a post - I'm sure you're familiar with

00:06:13,270 --> 00:06:16,059
that. Except that I alluded to this a little

00:06:16,060 --> 00:06:20,321
bit earlier - posts have tags. They're taggable polymorphically.

00:06:20,321 --> 00:06:22,790
So you could put any old thing on them,

00:06:22,800 --> 00:06:24,930
but usually you would see teams and players, and

00:06:24,930 --> 00:06:26,860
that's really all they wanted out of the recommendation

00:06:26,860 --> 00:06:27,290
engine.

00:06:27,290 --> 00:06:29,750
It's important to mention. More on that later.

00:06:29,750 --> 00:06:31,870
And it's not that import - it's really not

00:06:31,900 --> 00:06:34,080
that important, it's just a fun point later.

00:06:34,080 --> 00:06:35,949
So you can comment on a post - big

00:06:35,949 --> 00:06:38,280
surprise. Again, social network, you probably didn't expect to

00:06:38,280 --> 00:06:41,220
see that. But you can tag posts, you can

00:06:41,220 --> 00:06:44,451
tag, sorry, comments, with users - kind of like

00:06:44,460 --> 00:06:46,599
you could in Facebook. It was a little bit

00:06:46,600 --> 00:06:49,730
more of a nuissance because they didn't have a,

00:06:49,730 --> 00:06:52,750
a tagging mechanism per se for users, like Facebook

00:06:52,760 --> 00:06:54,771
does. I just had to write something to scan

00:06:54,771 --> 00:06:57,529
the text. Not entirely relevant to the rest of

00:06:57,529 --> 00:07:00,451
the discussion, so. We'll just keep on going.

00:07:00,460 --> 00:07:02,570
Other verbs that kind of mattered a bit -

00:07:02,570 --> 00:07:05,889
favoriting teams or players. This isn't something that, that

00:07:05,900 --> 00:07:07,650
Facebook had. More like a FourSquare thing, when you

00:07:07,660 --> 00:07:09,660
say, I love this. I love this team. I

00:07:09,660 --> 00:07:14,200
love this player. And then liking posts. Pretty typical

00:07:14,200 --> 00:07:14,941
stuff.

00:07:14,941 --> 00:07:18,879
So given a, a model that looks a- something

00:07:18,880 --> 00:07:22,350
a little like this, leaving out comments and likes

00:07:22,350 --> 00:07:24,321
and favorites for now. Let's say you have a

00:07:24,321 --> 00:07:27,589
user, in this case he's user 2, he has,

00:07:27,589 --> 00:07:30,101
he posted three posts. The first two posts are

00:07:30,101 --> 00:07:32,209
really the important ones, and the first two posts

00:07:32,220 --> 00:07:34,470
talk about tags one, two, and three.

00:07:34,480 --> 00:07:37,281
So say we're given this. And maybe we have

00:07:37,281 --> 00:07:41,490
something like this, but we don't initially, where we

00:07:41,500 --> 00:07:43,400
can say this other - we have this other

00:07:43,400 --> 00:07:46,961
guy and he's interested in these tags. So those

00:07:46,961 --> 00:07:49,059
might be teams or players.

00:07:49,060 --> 00:07:52,680
And they have these scalar values associated, this user

00:07:52,680 --> 00:07:55,220
has these scalar values associated with each of these,

00:07:55,220 --> 00:07:57,870
say, teams or players. So given those things, what

00:07:57,870 --> 00:07:59,800
we want, ultimately, is that.

00:07:59,800 --> 00:08:02,061
We want to be able to say, this user

00:08:02,061 --> 00:08:04,929
is going to be interested in these posts and

00:08:04,929 --> 00:08:07,871
not that post. So post three and - going

00:08:07,880 --> 00:08:12,519
back two slides - had tag four. And post,

00:08:12,540 --> 00:08:15,211
and user 1 only cared about tags one, two,

00:08:15,211 --> 00:08:17,059
and three. Not tag four.

00:08:17,060 --> 00:08:19,291
So he's only interes- he should only have a

00:08:19,300 --> 00:08:21,360
score for post one, post two, and he shouldn't

00:08:21,360 --> 00:08:23,229
have anything for post three because he just doesn't

00:08:23,229 --> 00:08:26,601
care. So we want something like that.

00:08:26,601 --> 00:08:30,179
So this part here is where the, the interesting-ness

00:08:30,180 --> 00:08:32,361
came in. When the client approached me, they said,

00:08:32,361 --> 00:08:34,670
well we have this idea for how a recommendation

00:08:34,670 --> 00:08:37,120
engine would work. We'll just, we'll just have a

00:08:37,140 --> 00:08:39,969
weight associated with each one of these events as

00:08:39,969 --> 00:08:40,851
they occur.

00:08:40,860 --> 00:08:43,919
Well, that's all well and good, but going from

00:08:43,920 --> 00:08:46,511
the first diagram with the post and the tags

00:08:46,511 --> 00:08:49,350
to, oh, I have this in a single step

00:08:49,350 --> 00:08:51,009
doesn't really make any sense.

00:08:51,020 --> 00:08:52,741
I needed some kind of lens in order to,

00:08:52,741 --> 00:08:56,490
to figure out what the user, what content the

00:08:56,490 --> 00:09:00,120
user would actually care about. So I needed intermediate

00:09:00,140 --> 00:09:01,490
value - I needed some intermediate values to get

00:09:01,500 --> 00:09:05,220
a sense of what does the user care about?

00:09:05,220 --> 00:09:09,680
So moving on. We start with ActiveRecord. Every good

00:09:09,680 --> 00:09:13,010
application does - not really. But it was a

00:09:13,010 --> 00:09:15,520
Rails app, so yeah, we had ActiveRecord. But really

00:09:15,520 --> 00:09:21,100
we're talking about ActiveRecord::Observers. So that's to say that

00:09:21,100 --> 00:09:25,690
we would capture, or would capture the lifecycle events

00:09:25,700 --> 00:09:29,930
of the nouns I described earlier. And, well, we

00:09:29,930 --> 00:09:31,989
would have some data that we would feed into

00:09:32,020 --> 00:09:34,701
something and we'll get there in just a minute.

00:09:34,701 --> 00:09:37,220
So to reiterate, we cared about two different kinds

00:09:37,220 --> 00:09:40,260
of posts. Really, they're, well, posts are posts. But

00:09:40,260 --> 00:09:43,019
we care about quantifying them in two different buckets.

00:09:43,020 --> 00:09:45,761
Popular, which is a global thing, and relevant, which

00:09:45,761 --> 00:09:48,250
is subjective to the individual user.

00:09:48,250 --> 00:09:51,259
So popularity is pretty straightforward. It, it could be

00:09:51,260 --> 00:09:53,731
made a little more complex, in this. Popularity, if

00:09:53,740 --> 00:09:59,390
I recall, is based on comments and likes. And

00:09:59,390 --> 00:10:02,699
I forget which was worth more. Because we, we

00:10:02,700 --> 00:10:03,991
would - and that's kind of irrelevent. The point

00:10:04,000 --> 00:10:05,870
is, they would have different weightings.

00:10:05,870 --> 00:10:08,090
So for a trending this standpoint, a comment might

00:10:08,090 --> 00:10:09,530
be worth than a like or a like might

00:10:09,540 --> 00:10:11,600
be worth more than a comment. One thing that

00:10:11,600 --> 00:10:12,990
we had talked about doing that if we hadn't

00:10:12,990 --> 00:10:15,050
done would have made life a lot more interesting,

00:10:15,050 --> 00:10:17,340
is to have a notion of taste makers. And

00:10:17,340 --> 00:10:19,751
that is, people who are super jazzed about a

00:10:19,751 --> 00:10:24,079
topic having their, their likes and their comments being

00:10:24,080 --> 00:10:29,070
more valuable in terms of popularity than other people's.

00:10:29,070 --> 00:10:31,531
If you instantly start thinking about gaming the sytem

00:10:31,540 --> 00:10:33,280
when I say something like that, then you're basically

00:10:33,280 --> 00:10:35,329
reading my mind. Because I kept going back to

00:10:35,340 --> 00:10:37,241
the client over and over again about that, and

00:10:37,241 --> 00:10:40,160
their response was, oh to have such problems. And,

00:10:40,160 --> 00:10:41,420
well I had to agree with them.

00:10:41,420 --> 00:10:43,339
If someone games your system, well then you're doing

00:10:43,340 --> 00:10:44,851
pretty well for someone to care enough to do

00:10:44,851 --> 00:10:45,920
it.

00:10:45,920 --> 00:10:48,480
Relevence is really where it gets a little more

00:10:48,480 --> 00:10:51,120
interesting, or a lot more interesting. So we have

00:10:51,120 --> 00:10:52,980
these verbs, or I guess these statements, like if

00:10:52,980 --> 00:10:55,360
you go and favorite DC United, or you submit

00:10:55,360 --> 00:10:57,629
a post tag with DC United - let's say

00:10:57,640 --> 00:11:00,261
you like DC United, or you comment on a

00:11:00,261 --> 00:11:02,959
post that is tagged with DC United, or the

00:11:02,960 --> 00:11:05,770
really confusing one, you're mentioned in a comment on

00:11:05,770 --> 00:11:07,861
a post tagged DC United.

00:11:07,861 --> 00:11:09,480
If your head hurts on that one, I understand.

00:11:09,480 --> 00:11:11,639
It took me awhile to wrap my brain around

00:11:11,640 --> 00:11:12,121
it too.

00:11:12,121 --> 00:11:13,400
So obviously, if you hadn't figured out, there was

00:11:13,400 --> 00:11:16,009
a time in my life when I liked DC

00:11:16,020 --> 00:11:19,861
United. But I'm not really much into sports anymore.

00:11:19,861 --> 00:11:24,670
But moving right along. So, relevence is, in this

00:11:24,670 --> 00:11:27,329
system, is defined by an algorithm kind of like

00:11:27,340 --> 00:11:28,030
this.

00:11:28,030 --> 00:11:32,161
So given an arbitrary event defined by an AR

00:11:32,180 --> 00:11:36,200
observer, or essentially serialized by an AR obvserver, for

00:11:36,200 --> 00:11:40,040
each tag on that event, for each user interested

00:11:40,040 --> 00:11:44,209
in that tag, go score the user's interest in

00:11:44,209 --> 00:11:46,531
that tag, or go rescore assuming that there's an

00:11:46,540 --> 00:11:48,519
interest already.

00:11:48,520 --> 00:11:50,421
So if you hadn't figured out already, that's a

00:11:50,421 --> 00:11:52,160
Big O events squared algorithm, if you're in computer

00:11:52,160 --> 00:11:55,379
science. And that's a bad, bad, bad thing. Damn

00:11:55,380 --> 00:11:57,321
- I was hoping they might have been more

00:11:57,321 --> 00:12:02,389
Pacific Rim fans in the audience, but. Oh well.

00:12:02,400 --> 00:12:06,122
So yeah, Big O N squared algorithm. I'm up

00:12:06,122 --> 00:12:08,600
against it, so I'm thinking there's - this, this,

00:12:08,600 --> 00:12:10,930
this is bad. What am I gonna do with

00:12:10,930 --> 00:12:14,840
this situation? Well, how could we cheat?

00:12:14,840 --> 00:12:18,009
So, it occurred to me, we're talking about soccer

00:12:18,009 --> 00:12:21,961
matches, about sports games. We're talking about wanting timely

00:12:21,980 --> 00:12:25,459
recommendations. Why do we care about stuff that's in

00:12:25,460 --> 00:12:27,061
the past? WE shouldn't. So I went to the

00:12:27,061 --> 00:12:28,899
client and said, what if we just say, have

00:12:28,900 --> 00:12:30,851
a window of three days and then after that

00:12:30,851 --> 00:12:32,449
we just don't care anymore?

00:12:32,460 --> 00:12:34,471
And they said thumbs up, and I thought, oh

00:12:34,471 --> 00:12:35,990
great, now there's a whole lot of data I

00:12:35,990 --> 00:12:38,270
don't have to worry about. So, Big O N

00:12:38,270 --> 00:12:40,790
squared is bad, but N just got a whole

00:12:40,820 --> 00:12:42,769
lot smaller.

00:12:42,769 --> 00:12:44,931
By the way, sorry, computer science parlence. Big O

00:12:44,940 --> 00:12:46,709
of N squared is to say it's a nested

00:12:46,709 --> 00:12:50,901
loop, and N is some arbitrarily large constant. It's

00:12:50,901 --> 00:12:54,090
the largest, if, I think, we're being concrete about

00:12:54,100 --> 00:12:56,380
it, the size of the largest data structure would

00:12:56,380 --> 00:12:59,020
be iterating over. So the big O is worst

00:12:59,020 --> 00:13:03,181
case run time of this algorithm would be looping

00:13:03,181 --> 00:13:07,380
over the longest structure in a nested fashion. And

00:13:07,380 --> 00:13:09,410
that's generally very slow - you don't want to

00:13:09,410 --> 00:13:11,100
do that.

00:13:11,100 --> 00:13:13,620
So we only care about recent posts, as I

00:13:13,620 --> 00:13:17,230
said a moment ago. But now we, we've narrowed

00:13:17,240 --> 00:13:19,630
down what events we care about. We need some

00:13:19,630 --> 00:13:21,939
kind of event consumer. So how many of you

00:13:21,940 --> 00:13:24,411
are familiar with resque?

00:13:24,420 --> 00:13:28,300
Hmm, OK. About half. I wasn't sure what to

00:13:28,300 --> 00:13:28,950
expect. Interesting.

00:13:28,960 --> 00:13:32,320
So Resque is a, a queuing system for processing

00:13:32,320 --> 00:13:35,541
background tasks, and it's written using this thing called

00:13:35,541 --> 00:13:38,189
Redis, which was in the talks. I assume you

00:13:38,189 --> 00:13:40,120
might be vaguely interested in this thing called Redis.

00:13:40,120 --> 00:13:42,781
How many people know about Redis, are kind of

00:13:42,781 --> 00:13:43,890
comfortable with it?

00:13:43,890 --> 00:13:45,559
OK, that's a little more than half. Pretty good.

00:13:45,560 --> 00:13:47,211
So I'll keep this short.

00:13:47,240 --> 00:13:50,970
Again, don't time me. So Redis is a key

00:13:50,970 --> 00:13:52,850
value store, which is to say it's a little

00:13:52,860 --> 00:13:54,360
bit like a mem hash, or if you just

00:13:54,360 --> 00:13:57,139
want to speak more Ruby parlence, it's basically like

00:13:57,140 --> 00:14:00,441
a glorified hash, except it runs as a server,

00:14:00,441 --> 00:14:02,899
as a daemon process basically.

00:14:02,900 --> 00:14:06,111
It lives, or, it's storage is in-memory, but it

00:14:06,111 --> 00:14:08,439
can persist to disk, and there are a couple

00:14:08,440 --> 00:14:10,481
of different persistence options that give you a little

00:14:10,481 --> 00:14:14,990
bit of flexibility about how often, how reliable it

00:14:14,990 --> 00:14:16,670
persists.

00:14:16,680 --> 00:14:18,800
And the interesting thing about Redis is it's not

00:14:18,800 --> 00:14:20,710
just a straight key-value storage, it's not just a

00:14:20,720 --> 00:14:22,630
hash, or I guess you could say it is

00:14:22,630 --> 00:14:24,460
a lot like a Ruby hash in some ways,

00:14:24,460 --> 00:14:26,579
because the value doesn't have to just be a

00:14:26,580 --> 00:14:28,471
string. The value could be some kind of data

00:14:28,480 --> 00:14:31,889
structure. And Redis supports, well, the ones listed here.

00:14:31,900 --> 00:14:36,841
So lists, so lists allow repitition. And they're sorted.

00:14:36,841 --> 00:14:39,450
Well, they're sorted based on insertion order, I should

00:14:39,450 --> 00:14:39,711
say.

00:14:39,720 --> 00:14:42,170
A hash, as you might expect, so actually, so

00:14:42,170 --> 00:14:44,730
key-value is by virt- by nature a lot like

00:14:44,730 --> 00:14:46,520
a hash, so basically you can have hashes in

00:14:46,540 --> 00:14:49,899
your hashes. You don't necessarily want to use those,

00:14:49,900 --> 00:14:52,051
and we'll talk about that soon.

00:14:52,051 --> 00:14:55,949
Sets. So a list where the insertion order doesn't

00:14:55,949 --> 00:14:58,581
necessarily matter, but no repetition is allowed, and sorted

00:14:58,600 --> 00:15:01,070
sets, which are pretty darn interesting because they don't

00:15:01,070 --> 00:15:03,910
allow repetition and they maintain a sorting order, and

00:15:03,920 --> 00:15:08,420
you're, so you're inserting a value and some sortable

00:15:08,420 --> 00:15:09,649
value to go with it.

00:15:09,649 --> 00:15:12,440
Well, and again, more on that later.

00:15:12,440 --> 00:15:13,890
Maybe one of the most interesting parts to me

00:15:13,900 --> 00:15:16,700
about Redis is that it supports adding a time

00:15:16,700 --> 00:15:20,711
to live, an arbitrary time to live, user-definable, to

00:15:20,720 --> 00:15:24,190
any given key that you put in Redis. Now

00:15:24,190 --> 00:15:26,620
when I say key, I need to be very

00:15:26,620 --> 00:15:29,269
specific. Key, at the macro level of key-value for

00:15:29,269 --> 00:15:32,141
Redis. So if you store a hash, a hash

00:15:32,141 --> 00:15:34,610
has a single key that refers to the whole

00:15:34,610 --> 00:15:35,950
hash.

00:15:35,960 --> 00:15:37,670
If you're storing a list or a set or

00:15:37,680 --> 00:15:39,640
a sorted set, there is one key that points

00:15:39,640 --> 00:15:41,721
to the whole thing. So you put a TTL

00:15:41,721 --> 00:15:43,920
on that, and what that says is, I want

00:15:43,920 --> 00:15:46,339
this value to just go away after this amount

00:15:46,340 --> 00:15:48,890
of time. That can be pretty handy. So when

00:15:48,890 --> 00:15:51,861
I mentioned that three day window earlier, the TTL

00:15:51,861 --> 00:15:54,660
is very handy there.

00:15:54,660 --> 00:15:57,650
That's just a little too big font, font-wise. So

00:15:57,660 --> 00:16:02,410
the AR::Observers were pushing events out to Resque. And

00:16:02,410 --> 00:16:04,069
the event would look something like this. It'd be

00:16:04,080 --> 00:16:07,200
pushing JSON up. So the event would have the

00:16:07,200 --> 00:16:12,030
type, the noun, essentially, the action - I think

00:16:12,030 --> 00:16:16,031
we were only concerned with creates, and occassionally deletes.

00:16:16,040 --> 00:16:18,839
But we didn't really care about updates.

00:16:18,840 --> 00:16:21,251
I offered to add that. It wasn't, this was

00:16:21,251 --> 00:16:22,879
a one-over lease, it just wasn't something that mattered

00:16:22,880 --> 00:16:23,690
that much at the time.

00:16:23,700 --> 00:16:25,650
Then we would have the ID of whatever the

00:16:25,650 --> 00:16:28,101
thing was, the user ID, because that very much

00:16:28,101 --> 00:16:31,030
matters here since we're talking about the user's interest

00:16:31,040 --> 00:16:34,019
in things. And then the names of the tags

00:16:34,020 --> 00:16:35,460
associated.

00:16:35,460 --> 00:16:38,311
But, we have all this stuff queued up, but

00:16:38,311 --> 00:16:40,220
one does not simply share the load. We have

00:16:40,220 --> 00:16:43,840
to define our workers. So the worker that I,

00:16:43,840 --> 00:16:47,319
I created, I called a calculator because I figured

00:16:47,320 --> 00:16:51,841
we're calculating a score, and the calculator originally was

00:16:51,841 --> 00:16:55,199
just one giant class. And it was aweful.

00:16:55,200 --> 00:16:58,241
So a TDD very quickly showed me how bad

00:16:58,241 --> 00:17:00,350
of an idea this was, as my tests grew

00:17:00,360 --> 00:17:02,410
to be more and more hard. SO then I

00:17:02,410 --> 00:17:04,840
started to break it out into three different kinds

00:17:04,840 --> 00:17:09,520
of calculators that formed a sort of workflow. And

00:17:09,520 --> 00:17:13,210
also I, I learned through more TDD suffering that

00:17:13,210 --> 00:17:16,200
I shouldn't even have my calculate, individual calculators think

00:17:16,220 --> 00:17:19,800
about persistence, because then that made their already busy

00:17:19,800 --> 00:17:22,340
life of trying to compute things even busier by

00:17:22,340 --> 00:17:23,610
trying to worry about, well, where do I put

00:17:23,610 --> 00:17:25,050
this stuff when I'm done.

00:17:25,050 --> 00:17:28,900
So instead I just had the outer level calculator

00:17:28,900 --> 00:17:31,740
act as a sort of strategy, I guess, in

00:17:31,740 --> 00:17:34,790
the object-oriented sense. And, so he was the Resque

00:17:34,800 --> 00:17:36,990
worker, and he handled all the persistence, and he

00:17:37,000 --> 00:17:38,700
just directed the other guys to do work. He

00:17:38,700 --> 00:17:40,880
would call one guy, get his output, pass it

00:17:40,880 --> 00:17:43,130
on to the other and so forth.

00:17:43,130 --> 00:17:45,350
So persistence was handled by Redis, but I created

00:17:45,360 --> 00:17:49,960
a very simple abstraction around it, just a class,

00:17:49,960 --> 00:17:53,800
so that way the customer could decide later, oh

00:17:53,800 --> 00:17:55,810
well, storing everything in memory is kind of sucking,

00:17:55,820 --> 00:17:58,060
so Redis is costing us hundreds of dollars now.

00:17:58,060 --> 00:18:01,550
A month, or more. Because Redis again is all

00:18:01,550 --> 00:18:03,420
memory, and memory gets a lot more expensive when

00:18:03,420 --> 00:18:05,440
you start getting bigger and bigger and bigger chunks

00:18:05,440 --> 00:18:08,100
of RAM. So I thought at some point they

00:18:08,100 --> 00:18:12,430
might want something like, dare I say, MongoDB -

00:18:12,440 --> 00:18:16,280
not a big fan, but. Something like that, maybe.

00:18:16,280 --> 00:18:18,210
So I put that there. It wasn't something I

00:18:18,210 --> 00:18:20,290
really had to worry about too much while I

00:18:20,300 --> 00:18:22,190
was working with them again for 1.0 version, but

00:18:22,190 --> 00:18:23,870
it seemed like an easy win.

00:18:23,880 --> 00:18:28,710
So getting into the individual calculators. The trengingness calculator,

00:18:28,710 --> 00:18:31,590
just like the, the, my discussion about popularity earlier,

00:18:31,600 --> 00:18:34,160
this guy was really straightforward. You like something. That

00:18:34,160 --> 00:18:36,900
bumps up the score on a post. You comment

00:18:36,900 --> 00:18:38,250
on something, that bumps up the score on a

00:18:38,250 --> 00:18:40,500
post. Really dumb.

00:18:40,500 --> 00:18:42,280
And then it outputs, so it would get the

00:18:42,280 --> 00:18:43,810
event, it would output a new score for that

00:18:43,810 --> 00:18:45,530
individual post.

00:18:45,530 --> 00:18:48,160
The way that data was stored was just as

00:18:48,160 --> 00:18:51,480
a simple key-value pair in Redis. So you would

00:18:51,480 --> 00:18:54,610
have, and this was actually a, I guess as

00:18:54,610 --> 00:18:56,590
a brief aside, this was a little uncommon for

00:18:56,600 --> 00:18:57,680
me. I was trying to find lots of ways

00:18:57,700 --> 00:19:00,140
to use Redis data structures, and for whatever reason

00:19:00,140 --> 00:19:02,430
this made more sense to me as a key-value

00:19:02,430 --> 00:19:03,330
pair.

00:19:03,330 --> 00:19:04,840
As it turned out, it probably would have been

00:19:04,860 --> 00:19:07,540
better as something else. But that's in the lessons

00:19:07,540 --> 00:19:08,930
learned section.

00:19:08,930 --> 00:19:12,050
So I would munge the keys so I could,

00:19:12,060 --> 00:19:14,350
you know, name space the values I was storing.

00:19:14,350 --> 00:19:15,840
Because if I just had the post ID in

00:19:15,840 --> 00:19:17,380
Redis, then I would have a key of forty-two

00:19:17,380 --> 00:19:21,090
and, well, if that's the, if that's the post

00:19:21,180 --> 00:19:22,320
ID, if I wanted to store anything else for

00:19:22,340 --> 00:19:24,270
that key, well, I would overwrite whatever was there

00:19:24,270 --> 00:19:25,600
and that would suck.

00:19:25,600 --> 00:19:27,530
So I would put something up front, like say,

00:19:27,530 --> 00:19:31,020
trend for trendingness. That's pretty common in key-value stores

00:19:31,040 --> 00:19:34,830
to have long munged names sometimes just for namespacing

00:19:34,830 --> 00:19:37,790
purposes.

00:19:37,800 --> 00:19:40,880
So let's see, right. In the key-value, the trendingness

00:19:40,880 --> 00:19:42,720
scores had the three day TTL that I talked

00:19:42,720 --> 00:19:45,870
about earlier. The one part that I regretted here

00:19:45,880 --> 00:19:49,180
was that these values were sorted in Ruby at

00:19:49,180 --> 00:19:51,750
run-time, when trendingness was requested. Now remember we're only

00:19:51,750 --> 00:19:53,950
talking about three days worth of posts.

00:19:53,960 --> 00:19:56,310
And this was for a fairly new social network.

00:19:56,310 --> 00:19:58,380
So, again, going back to the remark I made

00:19:58,380 --> 00:20:00,340
about gaming, you know, oh to have such problems,

00:20:00,340 --> 00:20:04,090
where sorting in Ruby would be that painful. But

00:20:04,100 --> 00:20:06,570
I would far rather sort and say something like,

00:20:06,570 --> 00:20:09,290
C or Java, which is like 100 times faster,

00:20:09,300 --> 00:20:11,560
so that sorting wouldn't be as painful as soon,

00:20:11,560 --> 00:20:13,990
but alas.

00:20:13,990 --> 00:20:15,640
So the user interest calculator. This is where we

00:20:15,660 --> 00:20:18,410
start getting into that, that relevance business. Deciding which

00:20:18,410 --> 00:20:22,490
users care about what. So it would get the

00:20:22,490 --> 00:20:26,480
event, and but it's important to mention that on

00:20:26,480 --> 00:20:28,370
a, for a given even there might be multiple

00:20:28,380 --> 00:20:30,770
users that might care about the event. And the

00:20:30,770 --> 00:20:33,180
reason for that is because, you have the person

00:20:33,180 --> 00:20:35,370
who posted the original post, but then you have

00:20:35,400 --> 00:20:36,890
all the commenters, you have all the likers.

00:20:36,890 --> 00:20:38,760
So you have to aggregate all of those people

00:20:38,760 --> 00:20:42,780
together because if anything else happens in this event,

00:20:42,780 --> 00:20:47,570
these people have expressed some degree of interest in

00:20:47,570 --> 00:20:49,600
the tags that are involved. I don't think I

00:20:49,620 --> 00:20:51,850
have a slide for this - so I wish

00:20:51,850 --> 00:20:54,330
I had, I'll take a brief aside to mention

00:20:54,330 --> 00:20:56,600
that every single one of those verbs had a

00:20:56,600 --> 00:20:58,580
waiting factor associated with it.

00:20:58,600 --> 00:21:01,260
So I'm just computer scalars here. I did have

00:21:01,260 --> 00:21:04,530
an AI class twenty years ago, back in college.

00:21:04,530 --> 00:21:08,160
So I learned a little, little bit.

00:21:08,160 --> 00:21:10,550
So each one of those events would have some

00:21:10,560 --> 00:21:13,060
kind of waiting associated with it, so when we

00:21:13,060 --> 00:21:14,410
had a scalar value we would know it was

00:21:14,410 --> 00:21:17,360
based primarily on this, and a little bit of

00:21:17,360 --> 00:21:18,440
that, and a little bit less of this and

00:21:18,440 --> 00:21:20,010
a little bit less of that, like, when you

00:21:20,020 --> 00:21:22,270
favorite something, that's a big, large declaration to say,

00:21:22,270 --> 00:21:25,780
I love this! When you comment on something -

00:21:25,780 --> 00:21:28,620
well, maybe I kind of like it, and if

00:21:28,620 --> 00:21:32,020
you are tagged on a comment belonging to a

00:21:32,020 --> 00:21:35,140
post - eh, OK, that's a pretty weak attachment

00:21:35,140 --> 00:21:36,950
but that connotes some degree of interest, cause you're

00:21:36,950 --> 00:21:39,560
associated with someone who cares about something else.

00:21:39,580 --> 00:21:41,720
So that's a very weak association, but it is

00:21:41,720 --> 00:21:43,480
some form of association.

00:21:43,480 --> 00:21:45,560
So all of those users needed to have their

00:21:45,560 --> 00:21:49,520
interests rescored. Right, and I just mentioned arbitrarily assign

00:21:49,520 --> 00:21:51,390
the weights for event times, so that was all

00:21:51,390 --> 00:21:52,860
I had, that one bullet. So I think the

00:21:52,860 --> 00:21:56,340
aside was worth it.

00:21:56,340 --> 00:21:59,450
So this is how we get this structure, that

00:21:59,450 --> 00:22:01,120
we have a user and we have a score

00:22:01,120 --> 00:22:04,850
for each tag based on that big nasty big

00:22:04,850 --> 00:22:07,690
O n squared algorithm that we defined earlier.

00:22:07,700 --> 00:22:09,590
So internally in Redis this is how I would

00:22:09,590 --> 00:22:13,980
store it. I would have one hash per user,

00:22:14,000 --> 00:22:18,660
and the field, so that the key would be,

00:22:18,660 --> 00:22:21,580
something like UI - the User ID, the user

00:22:21,580 --> 00:22:23,040
interest. It's something that we would look up an

00:22:23,040 --> 00:22:26,090
awful lot, so having a nice short key seemed

00:22:26,090 --> 00:22:29,420
important. Having it munged kind of essential because, again,

00:22:29,420 --> 00:22:31,860
we don't want to step on User ID values

00:22:31,860 --> 00:22:34,830
with something else later.

00:22:34,830 --> 00:22:38,530
I think Redis calls the individual keys in a

00:22:38,540 --> 00:22:40,900
hash fields - I don't remember if I have

00:22:40,900 --> 00:22:43,860
my Redis nomenclature right. But the field names were

00:22:43,880 --> 00:22:47,040
just the tag names, and then the values were

00:22:47,040 --> 00:22:48,730
the scalar interests.

00:22:48,730 --> 00:22:50,360
And intentionally I did not want to put any

00:22:50,360 --> 00:22:52,890
kind of time to live on that hash, because

00:22:52,900 --> 00:22:54,900
users interests are one thing we know are gonna

00:22:54,900 --> 00:22:56,740
live on and on and on and on.

00:22:56,740 --> 00:22:59,230
Downside is the user interests, the users' interests are

00:22:59,230 --> 00:23:00,540
something that will live on and on and on

00:23:00,540 --> 00:23:02,210
and on. So you know that they're just gonna

00:23:02,220 --> 00:23:05,270
take up more and more space. Tags are not

00:23:05,270 --> 00:23:07,750
something that, that leave the system very often, because

00:23:07,750 --> 00:23:11,210
players tend to play for awhile, and even if

00:23:11,220 --> 00:23:13,120
they retire they might get mentioned again in the

00:23:13,120 --> 00:23:16,610
social network, so I don't know that the players

00:23:16,610 --> 00:23:19,140
are gonna leave the system often. Teams likewise.

00:23:19,140 --> 00:23:20,650
So it just made sense to just basically leave

00:23:20,650 --> 00:23:23,320
these datastructures alone and let them grow. That said,

00:23:23,340 --> 00:23:25,800
having those in Redis, neh, it bugged me a

00:23:25,800 --> 00:23:29,740
little. But, again, one O system, it wasn't a

00:23:29,740 --> 00:23:30,800
big concern.

00:23:30,800 --> 00:23:35,650
So post score calculator is, I think I got

00:23:35,650 --> 00:23:37,110
mixed up there. Post score calculator is where the

00:23:37,120 --> 00:23:40,030
big big o n squared nastiness came in. So

00:23:40,040 --> 00:23:43,640
now we've rescored all these users' interests. WE need

00:23:43,640 --> 00:23:47,740
to go propogate this throughout the system.

00:23:47,740 --> 00:23:49,080
And so again we have, back to the, excuse

00:23:49,080 --> 00:23:54,230
me I'm so sorry - but I discovered after

00:23:54,230 --> 00:23:56,560
the fact a name for this pattern that I

00:23:56,560 --> 00:24:01,460
came upon. It's called inverted indices. And inverted index,

00:24:01,460 --> 00:24:02,640
that's a link by the way - these will

00:24:02,640 --> 00:24:04,430
go up on GitHub at some point. This is

00:24:04,440 --> 00:24:06,400
all HTML. You'll be able to click through. You

00:24:06,400 --> 00:24:07,930
don't have to take any notes, if by chance

00:24:07,930 --> 00:24:08,830
you are.

00:24:08,840 --> 00:24:12,550
An inverted index is basically just an index of

00:24:12,550 --> 00:24:15,510
the content to where the content is stored. So

00:24:15,510 --> 00:24:19,580
I had a few difference sets I would, for,

00:24:19,580 --> 00:24:21,300
let's see, a post, I would have the set

00:24:21,300 --> 00:24:24,130
of all the tags, and let's see, and I

00:24:24,130 --> 00:24:25,760
actually have to read this cause I don't remember

00:24:25,760 --> 00:24:26,840
off the top of my head.

00:24:26,860 --> 00:24:29,170
And then I had a set of right, the

00:24:29,170 --> 00:24:31,550
interested user IDs by tag. And that would save

00:24:31,580 --> 00:24:32,780
me from having to go out to the database

00:24:32,780 --> 00:24:34,060
all the time to perform a whole bunch of

00:24:34,060 --> 00:24:36,200
expensive queries. I could just go to Redis and

00:24:36,200 --> 00:24:39,980
say hey just give me and boom, there I

00:24:39,980 --> 00:24:40,750
go.

00:24:40,750 --> 00:24:43,370
And the user post scores were also stored in

00:24:43,370 --> 00:24:46,280
Redis as a hash, very much like the user

00:24:46,280 --> 00:24:48,320
interest scores. It's just instead of having the tag

00:24:48,320 --> 00:24:50,940
you had a post.

00:24:50,940 --> 00:24:54,190
So this structure, I, I showed you earlier, it's

00:24:54,190 --> 00:24:56,220
a workflow, but really what it also could be

00:24:56,220 --> 00:24:58,150
is a series of queues. It's not a big

00:24:58,160 --> 00:25:01,260
truck. You don't just dump stuff on it. Thank

00:25:01,280 --> 00:25:05,220
you - I'm so glad somebody appreciated that one.

00:25:05,220 --> 00:25:10,620
So some other design considerations that came up as

00:25:10,620 --> 00:25:15,250
we went along. So I'm, I've alluded a few

00:25:15,250 --> 00:25:17,670
times. I was trying to aggressively optimize the RBDMS

00:25:17,680 --> 00:25:20,810
out of the equation. The client very much did

00:25:20,810 --> 00:25:22,770
not want the recommendation engine to make the Rails

00:25:22,770 --> 00:25:24,690
app run slower, because, well, they're on, they, let's

00:25:24,690 --> 00:25:28,050
see, they're on Heroku and, you know, ?? [00:25:27]

00:25:28,060 --> 00:25:28,790
cost money.

00:25:28,800 --> 00:25:34,070
And we already talked about using inverted indices to

00:25:34,070 --> 00:25:37,310
some effect, again reducing - further reducing the need

00:25:37,310 --> 00:25:41,330
for database queries. And I already talked about those

00:25:41,360 --> 00:25:42,450
examples.

00:25:42,450 --> 00:25:45,740
Now the other thing I, that I, I've mentioned,

00:25:45,740 --> 00:25:47,500
that I broke the calculator down into a trendingness

00:25:47,500 --> 00:25:50,960
calculator and a user interest score calculator and post

00:25:50,980 --> 00:25:54,510
score calculator, and no one's made any kind of

00:25:54,510 --> 00:25:58,040
rude gestures, but those names really suck. I'm sorry.

00:25:58,040 --> 00:25:59,850
Post score calculator - just, it's German. Take a

00:25:59,850 --> 00:26:03,500
whole bunch of words together and mush them together.

00:26:03,500 --> 00:26:05,770
Is it good enough? Well, it ran in production,

00:26:05,770 --> 00:26:09,250
and the customer was happy. So yay.

00:26:09,260 --> 00:26:14,220
Was I ashamed of a lot of the code

00:26:14,240 --> 00:26:17,830
I wrote? Oh god yes. Would it scale? Well,

00:26:17,830 --> 00:26:22,420
I was limited by Redis, so memory, RAM. And

00:26:22,420 --> 00:26:25,210
I knew I'd be limited by CPU. But what

00:26:25,220 --> 00:26:26,760
they were conc- what they were concerned with was

00:26:26,760 --> 00:26:28,700
getting a one-over lease out the door, something that

00:26:28,700 --> 00:26:30,750
people could use right away, and if they'd be

00:26:30,750 --> 00:26:33,480
successful, well, worst case they would rewrite it. But

00:26:33,480 --> 00:26:37,450
there was potential to refactor and scale it further.

00:26:37,450 --> 00:26:39,600
One of the little interesting things that happened along

00:26:39,600 --> 00:26:43,010
the way is, because a post, the post is

00:26:43,040 --> 00:26:47,910
polymorphically taggable, you could just throw anything on it.

00:26:47,910 --> 00:26:51,890
So the engine originally didn't just care about teams

00:26:51,900 --> 00:26:53,460
and players - it just took any old tag

00:26:53,460 --> 00:26:56,020
you gave it. And the, the client later said

00:26:56,020 --> 00:26:57,460
yeah, I really only want the other teams and

00:26:57,460 --> 00:27:00,570
players, but the interesting side effect was, well users

00:27:00,570 --> 00:27:02,470
would get thrown in their as tags too.

00:27:02,480 --> 00:27:03,730
So I thought, you know, maybe a side business

00:27:03,730 --> 00:27:06,540
is a sports dating site or something, because all

00:27:06,540 --> 00:27:07,740
of the sudden it would say, hey, this is

00:27:07,740 --> 00:27:09,580
how interested I am in this person versus that

00:27:09,580 --> 00:27:10,330
person.

00:27:10,340 --> 00:27:13,570
But, no, I took that out and hard-coded it

00:27:13,570 --> 00:27:15,740
to just teams and players.

00:27:15,740 --> 00:27:19,760
So, so lessons learned along the way.

00:27:19,760 --> 00:27:22,400
Statistical methods - obviously would have been nice, because

00:27:22,400 --> 00:27:23,730
any time I had to write a big O

00:27:23,730 --> 00:27:25,330
N squared algorithm and I know Ns gonna keep

00:27:25,330 --> 00:27:28,300
getting bigger, I get really anxious. I did not

00:27:28,300 --> 00:27:30,420
like writing this.

00:27:30,420 --> 00:27:32,720
The lesson learned for me, if I were still

00:27:32,720 --> 00:27:34,460
freelancing, but even though I'm not I work at

00:27:34,460 --> 00:27:36,520
rackspace, is when I know something is right, I

00:27:36,520 --> 00:27:38,220
need to argue for it, just a little bit

00:27:38,220 --> 00:27:41,380
more.

00:27:41,400 --> 00:27:44,980
Prefer straight key-value over hashes. I've mentioned TTLs and

00:27:44,980 --> 00:27:47,780
I think I mentioned TTLs and I mentioned TTLs.

00:27:47,780 --> 00:27:50,780
You can't put a TTL on a field on

00:27:50,780 --> 00:27:54,290
hash. So you can't say I want this for

00:27:54,290 --> 00:27:57,210
this user, this post score to expire some time

00:27:57,220 --> 00:27:59,700
in the future. No, you're stuck with that guy.

00:27:59,700 --> 00:28:01,510
So there is a way around that. That's, I

00:28:01,520 --> 00:28:03,930
think, the next slide. But that's more work.

00:28:03,930 --> 00:28:05,780
What I could have done instead is just had

00:28:05,780 --> 00:28:09,820
longer munge names. Said, like, user ID, user ID

00:28:09,820 --> 00:28:12,910
blah blah blah, post ID blah blah blah, and

00:28:12,910 --> 00:28:14,510
then just had a value and put a TTL

00:28:14,510 --> 00:28:16,570
on that and then it would just disappear in

00:28:16,580 --> 00:28:19,480
three days and life would have been better.

00:28:19,480 --> 00:28:22,570
Extracing small - OK, so one more slide. Extracting

00:28:22,570 --> 00:28:24,950
smaller workers - when I said this is a

00:28:24,960 --> 00:28:27,470
series of queues, what I was getting at was

00:28:27,470 --> 00:28:30,620
I designed this system expecting that post score calculator

00:28:30,640 --> 00:28:34,140
would inevitable get more CPU than the other guys.

00:28:34,140 --> 00:28:37,760
So it, there're all written as Resque workers, but

00:28:37,760 --> 00:28:40,450
only the outside calculator is a Resque worker.

00:28:40,460 --> 00:28:41,970
It would have been fairly trivial to extract the

00:28:41,970 --> 00:28:44,140
other three, give them all their each, give them

00:28:44,140 --> 00:28:46,330
each their own queue. The only thing I would

00:28:46,330 --> 00:28:47,770
have had to have done is I would have

00:28:47,780 --> 00:28:49,700
had to add persistence capability to them, and that

00:28:49,700 --> 00:28:53,180
could have been something dependency injectable, for example.

00:28:53,180 --> 00:28:55,820
And that would have been kind of simple.

00:28:55,820 --> 00:28:56,980
The other thing that would have been nice is

00:28:56,980 --> 00:28:59,580
each one of those little guys basically runs on

00:28:59,580 --> 00:29:02,410
a case statement, and that's the big giant oh,

00:29:02,410 --> 00:29:04,950
oh, scream of please extract me, please extract me

00:29:04,950 --> 00:29:08,390
and, well. Oh well.

00:29:08,400 --> 00:29:12,070
Less chattiness with Redis. So I just was making

00:29:12,070 --> 00:29:14,170
individual calls to Redis if I needed to get

00:29:14,180 --> 00:29:15,840
a set, I would just make a single call.

00:29:15,840 --> 00:29:17,820
If I needed to do, push a key value

00:29:17,840 --> 00:29:20,210
pair, at least a single call. It was enough.

00:29:20,210 --> 00:29:24,610
It worked well enough. Individual calls on AWS from

00:29:24,610 --> 00:29:26,440
Heroku to Redis - I did actually bench it.

00:29:26,460 --> 00:29:28,130
It was something like 2 milliseconds.

00:29:28,130 --> 00:29:29,890
They add up, but if you're, only if you're

00:29:29,890 --> 00:29:32,080
making a ton of them. This was still way

00:29:32,100 --> 00:29:34,630
faster than the Rails app, so it, it really

00:29:34,630 --> 00:29:36,800
wasn't a big concern. But something to be aware

00:29:36,800 --> 00:29:37,490
of.

00:29:37,490 --> 00:29:41,420
Redis supports two different features that, only one at

00:29:41,420 --> 00:29:44,360
the time when I wrote this recommendation engine, that

00:29:44,380 --> 00:29:46,390
would have helped here. Pipelining, which allows you to

00:29:46,390 --> 00:29:50,260
just batch up commands. You get futures back, which

00:29:50,260 --> 00:29:52,160
is basically saying here, this is where you result

00:29:52,160 --> 00:29:54,120
will go later. And then all of the results

00:29:54,120 --> 00:29:57,430
come back, and you just access the futures to

00:29:57,440 --> 00:29:58,810
get the results.

00:29:58,810 --> 00:30:00,710
So you send one big request with all of

00:30:00,710 --> 00:30:02,200
your different commands, and then you get a bunch

00:30:02,220 --> 00:30:06,920
of little responses back when they're ready. And that

00:30:06,920 --> 00:30:09,210
will result in less network chattiness, which means you're

00:30:09,210 --> 00:30:10,830
app will run faster.

00:30:10,840 --> 00:30:14,460
The second one, and this one is very dangerous

00:30:14,460 --> 00:30:17,640
because Redis is an evented key-value store, I didn't

00:30:17,640 --> 00:30:21,150
mention. Which means there's one thread. You can script

00:30:21,150 --> 00:30:24,410
inside of Redis. If you script badly inside of

00:30:24,420 --> 00:30:27,960
Redis you might occupy that one thread for awhile,

00:30:27,960 --> 00:30:29,710
and when you send commands to Redis, it might

00:30:29,710 --> 00:30:31,810
say, sorry I'm busy right now.

00:30:31,810 --> 00:30:33,270
So that would be bad. You know, like crossing

00:30:33,270 --> 00:30:36,140
the streams in ghost busters.

00:30:36,140 --> 00:30:39,390
So pruning. When I mentioned not wanting to use

00:30:39,400 --> 00:30:42,820
hashes so much in Redis, if you are gonna

00:30:42,820 --> 00:30:45,000
use something that's gonna grow and grow and grow

00:30:45,000 --> 00:30:47,270
and nothing ever expires and you want things to

00:30:47,270 --> 00:30:51,020
be removed eventually, one option is to put a,

00:30:51,020 --> 00:30:54,180
a timestamp in every value that you're gonna put

00:30:54,180 --> 00:30:54,920
in that hash.

00:30:54,940 --> 00:30:57,140
So instead of just putting straight values into a

00:30:57,140 --> 00:31:00,330
hash, just integers for example, you just put JSON

00:31:00,330 --> 00:31:02,340
in, like we do with Resque, and that might

00:31:02,360 --> 00:31:04,700
have a timestamp and then the value. And then

00:31:04,700 --> 00:31:08,220
what that means is periodically, although I've heard that

00:31:08,220 --> 00:31:10,470
the, the best practice is maybe every time you

00:31:10,470 --> 00:31:13,120
do an insertion into a structure - also go

00:31:13,120 --> 00:31:15,070
through and prune that structure, look for things that

00:31:15,080 --> 00:31:19,100
you can remove that have outlived their usefulness.

00:31:19,100 --> 00:31:21,570
But I mentioned earlier, still, better to prefer a

00:31:21,570 --> 00:31:24,700
key-value where you can just set a TTL than

00:31:24,700 --> 00:31:26,430
to go and have to deal with pruning. Pruning

00:31:26,430 --> 00:31:28,020
is more work. I told the client that was

00:31:28,040 --> 00:31:30,930
something was concerned about for later. Again, for 1.0

00:31:30,930 --> 00:31:32,690
they didn't care. They were like, I could wash

00:31:32,690 --> 00:31:34,290
my hands of it and walk away, but it,

00:31:34,300 --> 00:31:36,840
still, I didn't like knowing memory would just grow.

00:31:36,840 --> 00:31:39,380
I used to code in C and Java and

00:31:39,380 --> 00:31:43,290
you don't like leaking memory.

00:31:43,290 --> 00:31:45,810
So one other thing I realized actually just today

00:31:45,810 --> 00:31:48,490
was the calculator, because it was stateless, could have

00:31:48,500 --> 00:31:52,530
benefited a lot from a functional programming style using

00:31:52,530 --> 00:31:55,520
what's called referential transparency. And really that's just a

00:31:55,540 --> 00:31:58,470
fancy way of saying the output from one function

00:31:58,480 --> 00:31:59,810
is the input to the next function. And you

00:31:59,810 --> 00:32:03,610
just accumulate state by taking that output from, from

00:32:03,610 --> 00:32:05,640
one function, passing that as your input to the

00:32:05,660 --> 00:32:07,860
next, along with whatever stuff you need to, and

00:32:07,860 --> 00:32:09,780
just keep accumulating and your final output's what you

00:32:09,780 --> 00:32:10,960
care about.

00:32:10,960 --> 00:32:12,340
That might have been pretty nice to do. It

00:32:12,340 --> 00:32:13,610
might have made the code a little bit readable

00:32:13,610 --> 00:32:16,580
because the imperative style can be a bit hard

00:32:16,580 --> 00:32:19,610
to follow sometimes. I know I was, as I

00:32:19,720 --> 00:32:21,680
said I wasn't thrilled with the end result of

00:32:21,680 --> 00:32:23,070
the code, and I tried really hard to make

00:32:23,070 --> 00:32:25,280
it readable, but the imperative style didn't look too

00:32:25,280 --> 00:32:28,240
good in the calculator.

00:32:28,240 --> 00:32:29,860
And the final lesson learned is you do something

00:32:29,860 --> 00:32:32,670
faster in Ruby.

00:32:32,670 --> 00:32:35,340
So, but that, that was really just a joke.

00:32:35,340 --> 00:32:37,950
Because Ruby was actually adequate to the task. It

00:32:37,950 --> 00:32:39,420
wasn't a problem. So this is the part where

00:32:39,420 --> 00:32:40,880
I get to say I've got seven minutes and

00:32:40,880 --> 00:32:44,660
forty-one seconds. Are there any questions, heckling, or other

00:32:44,680 --> 00:32:47,670
statements, remarks, something?

00:32:49,300 --> 00:32:52,380
No? OK. Cool, well. Three minutes left, so thanks

00:32:52,420 --> 00:32:53,040

YouTube URL: https://www.youtube.com/watch?v=mohCfOJOn6A


