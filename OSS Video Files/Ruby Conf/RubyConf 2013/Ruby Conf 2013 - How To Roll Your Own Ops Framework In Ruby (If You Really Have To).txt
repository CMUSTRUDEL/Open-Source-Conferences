Title: Ruby Conf 2013 - How To Roll Your Own Ops Framework In Ruby (If You Really Have To)
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Sandy Vanderbleek

There are currently a great crop of tools out that for doing Ops in Ruby, but when you need real certainty about your infrastructure for a specific provider the only way to test is through provisioning actual resources and making assertions about them. Currently the tools aren't quiete there.and you might be better off rapidly developing your own deployment framework with integration testing in mind. This talk will discuss what we've done at CardSpring to develop our own Ops as a Service and provide developers with a stress free deployment API using Ruby, Chef, and AWS and backed by full RSpec coverage.

Help us caption & translate this video!

http://amara.org/v/FG5S/
Captions: 
	00:00:16,000 --> 00:00:18,000
SANDY VANDERBLEEK: OK. So I'm gonna talk

00:00:18,930 --> 00:00:22,990
about how to write your own operations framework,

00:00:22,990 --> 00:00:26,020
if you really have to. And that's the first question.

00:00:26,020 --> 00:00:30,100
Do you really have to? No. You don't. Other

00:00:30,100 --> 00:00:33,570
people have written lots of different things, and if

00:00:33,570 --> 00:00:36,780
you're working in Ruby, Chef is pretty great and

00:00:36,780 --> 00:00:40,910
it'll get you really far. So, and you know,

00:00:40,910 --> 00:00:42,770
if you have to roll your own thing, it

00:00:42,770 --> 00:00:46,989
doesn't mean you can't keep using Chef. We're using

00:00:46,989 --> 00:00:52,530
Chef, and the problems we're trying to solve are-

00:00:52,530 --> 00:00:55,059
We want something that is very testable. That is

00:00:55,059 --> 00:01:00,420
our first key desirable. And we need to be

00:01:00,420 --> 00:01:03,219
able to test things rapidly at the unit level

00:01:03,219 --> 00:01:06,860
and then integrate it, and then the biggest area

00:01:06,860 --> 00:01:08,920
of testing is acceptance testing.

00:01:08,920 --> 00:01:12,770
We want to have our framework bring up real

00:01:12,770 --> 00:01:15,770
machines and make assertions about the state of those

00:01:15,770 --> 00:01:19,520
machines. And we want to know that our framework

00:01:19,520 --> 00:01:22,000
can bring up the machine's - you know, we

00:01:22,000 --> 00:01:25,670
want continuous test running so we know we can

00:01:25,670 --> 00:01:27,799
deploy our infrastructure.

00:01:27,799 --> 00:01:29,950
So we know we can build our infrastructure at

00:01:29,950 --> 00:01:32,060
all times, so at, you know, three in the

00:01:32,060 --> 00:01:34,909
morning when things are going bad, we don't also

00:01:34,909 --> 00:01:39,970
have to deal with debugging our deployment code. So

00:01:39,970 --> 00:01:41,759
that is the main desirable.

00:01:41,759 --> 00:01:47,140
Right, before we decided to write our own framework

00:01:47,140 --> 00:01:51,259
at the company I'm working at, we've been using

00:01:51,259 --> 00:01:56,140
CloudWatch on AWBS. Not CloudWatch. Cloud Formation Templates. And

00:01:56,140 --> 00:02:00,250
stuff like that. They're slow and it was hard,

00:02:00,250 --> 00:02:03,450
they're hard to test. So just, designing this framework

00:02:03,450 --> 00:02:08,110
with tests first is a big, big thing.

00:02:08,110 --> 00:02:10,749
So, and then the, the rest of the standard

00:02:10,749 --> 00:02:13,489
stuff. We need to be available. Everything for us

00:02:13,489 --> 00:02:16,430
is based around high availability. Everything is pretty much

00:02:16,430 --> 00:02:20,090
a cluster with a load balancer. So we have

00:02:20,090 --> 00:02:20,919
no single point of failure.

00:02:20,919 --> 00:02:23,189
And this has to apply to our, what's running

00:02:23,189 --> 00:02:27,349
our, you know, operations framework, too. The, the servers

00:02:27,349 --> 00:02:29,700
that our ops is running on need to be

00:02:29,700 --> 00:02:33,489
high availa- highly available, too. So it needs to

00:02:33,489 --> 00:02:37,329
bootstrap itself from a local machine into a cluster

00:02:37,329 --> 00:02:40,180
mode, and run like that.

00:02:40,180 --> 00:02:44,559
Debugability is big. When a deployment fails we need

00:02:44,559 --> 00:02:46,809
to get on our machines, see why it fails,

00:02:46,809 --> 00:02:49,790
see what's going on. The whole system is based

00:02:49,790 --> 00:02:51,969
on the system of swapping out an already running

00:02:51,969 --> 00:02:55,319
cluster with the new, newly deployed custer. So, and

00:02:55,319 --> 00:02:58,309
we, we want to keep that old cluster around,

00:02:58,309 --> 00:02:59,969
if you can, I mean that'd be nice, in

00:02:59,969 --> 00:03:02,209
case the new one has some problems - just

00:03:02,209 --> 00:03:03,609
swap back.

00:03:03,609 --> 00:03:06,999
So, also audit-able is a big thing. We want

00:03:06,999 --> 00:03:12,900
to know what's going on every transition of our

00:03:12,900 --> 00:03:16,139
operations resource, we want to know why it triggered

00:03:16,139 --> 00:03:17,849
and it wasn't successful. You know, how long has

00:03:17,849 --> 00:03:20,169
it taken, we want to know average deploy times,

00:03:20,169 --> 00:03:24,579
average fail times, et cetera. Want to be able

00:03:24,579 --> 00:03:26,529
to run those analytics.

00:03:26,529 --> 00:03:30,809
So what's wrong with just Chef? So Chef server

00:03:30,809 --> 00:03:32,279
is what you would go to to kind of

00:03:32,279 --> 00:03:34,930
provide this whole, you know, framework for managing your

00:03:34,930 --> 00:03:39,049
settings, managing your machines, doing service discovery, stuff like

00:03:39,049 --> 00:03:46,040
that. And to make that highly available is non-trivial.

00:03:46,040 --> 00:03:48,519
And you know Chef-spec, the testing, you know that,

00:03:48,519 --> 00:03:50,400
one of the testing libraries that is out there

00:03:50,400 --> 00:03:53,659
for it, it's just pretty much a unit test.

00:03:53,659 --> 00:03:56,989
It just doesn't actually do anything. It just tests

00:03:56,989 --> 00:03:59,999
your code, and you know, can it run.

00:03:59,999 --> 00:04:01,739
And there are some other tools out there, like

00:04:01,739 --> 00:04:08,739
Cucumber-Chef, which it comes from this bug test-driven infrastructure

00:04:08,739 --> 00:04:12,609
using chef, and you get to write cucumber tests

00:04:12,609 --> 00:04:16,879
that say, like, real machines, it deploys actual AWS

00:04:16,879 --> 00:04:20,979
resources and then runs your tests on those servers.

00:04:20,979 --> 00:04:24,810
So that's a pretty cool tool. It's, it's not

00:04:24,810 --> 00:04:29,330
really under active development right now, and it's not

00:04:29,330 --> 00:04:32,699
quite flexible for what we wanted to do. And

00:04:32,699 --> 00:04:34,830
something really cool that's coming out with the same

00:04:34,830 --> 00:04:36,680
people who did Chef-Spec is Test Kitchen.

00:04:36,680 --> 00:04:39,139
I don't know if anyone's seen this, but it,

00:04:39,139 --> 00:04:41,819
it definitely is what we're aiming to do from

00:04:41,819 --> 00:04:46,520
the testing standpoint. So, but it's under wraps and

00:04:46,520 --> 00:04:47,509
all that.

00:04:47,509 --> 00:04:50,520
So here are the components that I came up

00:04:50,520 --> 00:04:53,870
with for this framework. It's all API based. So

00:04:53,870 --> 00:04:57,759
we have ops, basically, as a API service where,

00:04:57,759 --> 00:05:02,479
and, just, developers can make API calls from a,

00:05:02,479 --> 00:05:05,759
from Perl or whatever. Or there's also a front-end

00:05:05,759 --> 00:05:08,900
component that I built in JavaScript.

00:05:08,900 --> 00:05:14,039
So the API is like, you know, access, it's

00:05:14,039 --> 00:05:17,289
just your, your single point of control. Then all

00:05:17,289 --> 00:05:20,210
the, you know, our business logic is in the

00:05:20,210 --> 00:05:24,340
domain. The domain layer. And that's things like, what

00:05:24,340 --> 00:05:27,710
we consider part of our deployment process. We built

00:05:27,710 --> 00:05:33,139
images, we deploy clusters, we have some settings and

00:05:33,139 --> 00:05:37,150
users with permissions. So that's basically our domain.

00:05:37,150 --> 00:05:39,090
And then the ops is like the whole meat

00:05:39,090 --> 00:05:41,569
of it. This is all the nasty stuff, working

00:05:41,569 --> 00:05:45,960
with your cloud library, working with, you know, Unix,

00:05:45,960 --> 00:05:48,300
getting all of the things done that you need

00:05:48,300 --> 00:05:51,340
to get done to make your domain a reality.

00:05:51,340 --> 00:05:55,639
We have a database for persistence. We're using MongoDB

00:05:55,639 --> 00:06:00,509
in a cluster. So the database isn't that important.

00:06:00,509 --> 00:06:04,449
Whatever you're gonna use just needs to be reliable.

00:06:04,449 --> 00:06:07,449
And then the frontend - it can be a

00:06:07,449 --> 00:06:12,050
app, a command line, whatever. That's why you make

00:06:12,050 --> 00:06:14,509
the API, so you have that flexibility at the

00:06:14,509 --> 00:06:15,870
front-end level.

00:06:15,870 --> 00:06:19,610
So the API - we have end points. It's

00:06:19,610 --> 00:06:23,900
just rack, so it's pretty simple. We're using Grape.

00:06:23,900 --> 00:06:28,949
Grape is really nice for writing quick APIs in

00:06:28,949 --> 00:06:34,210
Ruby. Grape has entities which are map, domain objects

00:06:34,210 --> 00:06:38,270
to the JSON representation. We're just using JSON and

00:06:38,270 --> 00:06:40,210
JSON out.

00:06:40,210 --> 00:06:42,870
So and then when we consume a representation that

00:06:42,870 --> 00:06:46,449
a client has messed with, it's called a representation

00:06:46,449 --> 00:06:48,800
right now which is not a great name. But

00:06:48,800 --> 00:06:51,650
that's to take a representation and go back into

00:06:51,650 --> 00:06:57,669
the domain layer from there. Then services kind of

00:06:57,669 --> 00:06:59,240
act as the interface to the domain and ops

00:06:59,240 --> 00:07:02,509
layer for the API, so it's not highly coupled

00:07:02,509 --> 00:07:04,990
to what's going on there.

00:07:04,990 --> 00:07:09,199
And the client's, the API provides some clients, just

00:07:09,199 --> 00:07:12,979
rest clients basically. Everything is restful. So there are,

00:07:12,979 --> 00:07:14,969
there are a couple of client objects in the

00:07:14,969 --> 00:07:16,849
API layer that you could use for a command

00:07:16,849 --> 00:07:20,129
line inside the ops.

00:07:20,129 --> 00:07:24,590
Wherever you need it. And executation is a abstraction

00:07:24,590 --> 00:07:27,900
for the API to say go do something, I'm

00:07:27,900 --> 00:07:30,509
gonna respond to the client, and some work is

00:07:30,509 --> 00:07:32,449
gonna go on in the background.

00:07:32,449 --> 00:07:34,560
And there's a, I extracted it because there's a

00:07:34,560 --> 00:07:37,669
couple different ways, just for getting started. Just want

00:07:37,669 --> 00:07:42,009
to fork, you know, but we use AWS flows

00:07:42,009 --> 00:07:43,770
a lot, to do a lot of our work,

00:07:43,770 --> 00:07:45,800
so. I wanted to make it flexible enough so

00:07:45,800 --> 00:07:49,300
that when we plug it into our flow infrastructure,

00:07:49,300 --> 00:07:53,779
we can run our tasks like that.

00:07:53,779 --> 00:07:56,099
So at the domain layer we have resources which

00:07:56,099 --> 00:07:59,719
have states and logic, and then there are provisioners,

00:07:59,719 --> 00:08:04,240
which are state machines over these resources. So states,

00:08:04,240 --> 00:08:08,189
for example, image has a pending state, a building

00:08:08,189 --> 00:08:11,770
state, a built state, a destroyed state, et cetera.

00:08:11,770 --> 00:08:14,340
And the provisioner is the state machine that's gonna

00:08:14,340 --> 00:08:17,830
run through all those states which transitions using success

00:08:17,830 --> 00:08:22,289
and failure, and all this happens in the background,

00:08:22,289 --> 00:08:24,620
usually when you ask for a resource to change

00:08:24,620 --> 00:08:27,229
state. Provisioner is gonna determine what it needs to

00:08:27,229 --> 00:08:29,400
do to change that state, and then go about

00:08:29,400 --> 00:08:30,479
doing that.

00:08:30,479 --> 00:08:34,849
And that uses the ops layer, where the providers

00:08:34,849 --> 00:08:38,000
are basically controlled by the provisioners in the machines.

00:08:38,000 --> 00:08:41,289
They communicate using just success and failure and pass

00:08:41,289 --> 00:08:44,190
an options hash. And then the ops has a

00:08:44,190 --> 00:08:46,790
lot of, you know, tools to use the cloud

00:08:46,790 --> 00:08:48,649
services, so we can get things done on the

00:08:48,649 --> 00:08:49,699
cloud.

00:08:49,699 --> 00:08:52,360
And very important are the testing tools to prove

00:08:52,360 --> 00:08:54,180
that the things actually got done on the cloud.

00:08:54,180 --> 00:08:57,160
We want to know processes are running, files, directories,

00:08:57,160 --> 00:09:01,889
everything is set up. Everything is good. OK.

00:09:01,889 --> 00:09:03,670
And the database. It's just a database. We use

00:09:03,670 --> 00:09:07,420
it to store data. There are mappers that map

00:09:07,420 --> 00:09:10,750
the resources to MongoDB and back. It uses the

00:09:10,750 --> 00:09:15,250
data mapper pattern. Perpetuity is a cool gem. Right

00:09:15,250 --> 00:09:17,260
now it just works with Mongo, but they're adding

00:09:17,260 --> 00:09:20,010
a postgres SQL to it.

00:09:20,010 --> 00:09:23,300
So I also looked into Ram, RV, which is

00:09:23,300 --> 00:09:27,810
pretty cool, but definitely not ready for use. Tried

00:09:27,810 --> 00:09:34,029
to keep the, you know, model persistence out of

00:09:34,029 --> 00:09:38,660
the domain layer, you know, not ActiveRecord style. Data

00:09:38,660 --> 00:09:42,480
mapper is a, is the pattern. It's in patterns

00:09:42,480 --> 00:09:46,410
of enterprise architecture. If you haven't heard of it,

00:09:46,410 --> 00:09:48,360
definitely check it out.

00:09:48,360 --> 00:09:52,880
So the resources transition between states. Transitions are also

00:09:52,880 --> 00:09:55,519
resourced. This is part of the audibility. You want

00:09:55,519 --> 00:10:00,779
to know, you know, every transition. So our resources

00:10:00,779 --> 00:10:04,730
are image clusters, settings, users, permissions, right now. It's

00:10:04,730 --> 00:10:08,399
pretty simple.

00:10:08,399 --> 00:10:13,550
The providers are the implementations of each resource state.

00:10:13,550 --> 00:10:16,089
So this is in the ops layer. And you

00:10:16,089 --> 00:10:18,430
write a provider, you'll write, like a method called

00:10:18,430 --> 00:10:21,709
build, if you're image provider, and then you'll have

00:10:21,709 --> 00:10:26,970
like a method pending, build pending, and just, that

00:10:26,970 --> 00:10:29,790
method is called when that resource is gonna go

00:10:29,790 --> 00:10:32,870
into that state. So you need to do everything

00:10:32,870 --> 00:10:35,230
that will make that resource in the state, and

00:10:35,230 --> 00:10:37,850
then say success inside the provider if you, you

00:10:37,850 --> 00:10:39,949
know, if you achieved it.

00:10:39,949 --> 00:10:43,399
And then the provisioner will actually update the client

00:10:43,399 --> 00:10:46,040
and let the resource know that it is in

00:10:46,040 --> 00:10:50,720
that state at the API level. So the provisioner

00:10:50,720 --> 00:10:53,670
is just the control object. It knows about the

00:10:53,670 --> 00:10:57,480
client and the only transition events are success and

00:10:57,480 --> 00:10:58,279
failure.

00:10:58,279 --> 00:11:02,920
So it runs inside an execution with the run

00:11:02,920 --> 00:11:06,259
ID as the transition. So a nice feature that

00:11:06,259 --> 00:11:08,339
we don't have yet will be to take that

00:11:08,339 --> 00:11:13,759
run ID and cancel, cancel transitions.

00:11:13,759 --> 00:11:16,970
So another explaine flow, for images for us is,

00:11:16,970 --> 00:11:20,490
we start in pending, we set up our, our

00:11:20,490 --> 00:11:24,029
image on AWS. We go into a build_pending and

00:11:24,029 --> 00:11:27,660
we, you know, run our, we install Ruby on

00:11:27,660 --> 00:11:29,370
it. We do everything we want to have the

00:11:29,370 --> 00:11:33,709
image set up. It takes awhile. And, well that's

00:11:33,709 --> 00:11:36,240
actually the building state, sorry.

00:11:36,240 --> 00:11:38,250
And then when it's built, we, you know, make

00:11:38,250 --> 00:11:42,240
sure it's registered properly and everything like that. So

00:11:42,240 --> 00:11:44,930
this framework lets us think in terms of state

00:11:44,930 --> 00:11:47,139
machines, which I think is really valuable. Think about

00:11:47,139 --> 00:11:50,990
state transitions and think about all your operations resources

00:11:50,990 --> 00:11:53,199
- all your operations, you know, things as resources

00:11:53,199 --> 00:11:55,339
that have states that are gonna go through state

00:11:55,339 --> 00:11:59,579
provisions as state transitions as you, you know, deploy

00:11:59,579 --> 00:12:02,630
things, make things happen.

00:12:02,630 --> 00:12:04,589
So how do I make it, you know, more

00:12:04,589 --> 00:12:08,449
of a framework, something reusable for everybody?

00:12:08,449 --> 00:12:10,839
So right now it's, it's kind of hard. You

00:12:10,839 --> 00:12:13,490
build your own subclass of resource provision or provider

00:12:13,490 --> 00:12:16,829
for, you know, your domain object, something you want,

00:12:16,829 --> 00:12:19,449
you know, to act as a operations resource for

00:12:19,449 --> 00:12:22,370
you. And then you also have to do your

00:12:22,370 --> 00:12:25,329
entity and endpoint service. And write the mapper for

00:12:25,329 --> 00:12:26,480
the database.

00:12:26,480 --> 00:12:29,589
And so it's really like seven, at least seven

00:12:29,589 --> 00:12:33,899
classes you're gonna create to make on operations resource.

00:12:33,899 --> 00:12:36,339
So that's pretty hard.

00:12:36,339 --> 00:12:39,660
I've looked into trying to make a DSL to

00:12:39,660 --> 00:12:43,709
build the resource and provisioner, because they're very related.

00:12:43,709 --> 00:12:47,740
It's basically the states and the state machine. But

00:12:47,740 --> 00:12:50,060
the state machine is already - I'm using a

00:12:50,060 --> 00:12:54,209
workflow, it's already a state machine DSL. So, it's

00:12:54,209 --> 00:12:57,649
hard to, to make frameworks on top of frameworks

00:12:57,649 --> 00:13:02,100
sometimes. And lots of fast-level native programming.

00:13:02,100 --> 00:13:03,399
So.

00:13:03,399 --> 00:13:05,560
But it's interesting, and definitely the real map is

00:13:05,560 --> 00:13:09,620
to do that. There's already a DSL for the

00:13:09,620 --> 00:13:13,069
API. It's great. And the frontend - I made

00:13:13,069 --> 00:13:16,199
some interesting decisions cause I'm a former front end

00:13:16,199 --> 00:13:20,149
developer. So I'm using EmberJs to just work with

00:13:20,149 --> 00:13:23,610
JSON. There's no frontend server. It's a static JavaScript

00:13:23,610 --> 00:13:28,880
app, self-contained. So would people be interested in that?

00:13:28,880 --> 00:13:33,220
It's kind of crazy. Also Emblem is a templating

00:13:33,220 --> 00:13:36,569
language, and it's lime HML with handlebars. It's kind

00:13:36,569 --> 00:13:40,069
of cool. Some cool stuff. So the goal is

00:13:40,069 --> 00:13:43,620
definitely to opensource, you know, the work we've done,

00:13:43,620 --> 00:13:47,600
and of course, profit. So what are our key

00:13:47,600 --> 00:13:49,839
process benefits from this?

00:13:49,839 --> 00:13:52,339
So we write acceptance tests using RSpect matchers. They

00:13:52,339 --> 00:13:55,389
run on the instances created by the API, that

00:13:55,389 --> 00:13:59,459
is really big. Cause we, we could have had

00:13:59,459 --> 00:14:01,709
a broken deployment for weeks, and had no idea

00:14:01,709 --> 00:14:05,970
previously. You know, cause we weren't constanly testing our

00:14:05,970 --> 00:14:08,620
deployment infrastructure.

00:14:08,620 --> 00:14:11,009
So when a deployment fails, we have SSH to

00:14:11,009 --> 00:14:13,449
access the machine. We have a one stop shop

00:14:13,449 --> 00:14:17,899
for settings and service discovery. Fail overs is a

00:14:17,899 --> 00:14:21,860
fundamental construct. Swapping clusters back and forth.

00:14:21,860 --> 00:14:24,980
And it is self-documenting, which is pretty cool, using

00:14:24,980 --> 00:14:29,110
Grape. You write a couple descriptions of your end

00:14:29,110 --> 00:14:31,940
points, of your, you know, gets and puts, and

00:14:31,940 --> 00:14:35,529
then I made a, an endpoint to represent the

00:14:35,529 --> 00:14:38,339
endpoints, actually. So there's an entity for the endpoint.

00:14:38,339 --> 00:14:41,399
So the actual API endpoints can be, output is

00:14:41,399 --> 00:14:44,440
JSON representations, and then you can ask for documentation

00:14:44,440 --> 00:14:45,600
is JSON.

00:14:45,600 --> 00:14:49,980
So that was pretty cool. But, yeah, it's not

00:14:49,980 --> 00:14:52,940
done yet. Lots of work. And right now it's

00:14:52,940 --> 00:14:55,120
kind of monolithic, which is a little bit a

00:14:55,120 --> 00:14:58,060
problem because we need to integrate lots of different

00:14:58,060 --> 00:15:01,720
tools that ops developers are building, and they don't

00:15:01,720 --> 00:15:05,029
all fit or, you know, they already work, and

00:15:05,029 --> 00:15:08,019
how do we in them into this provisioner or

00:15:08,019 --> 00:15:10,019
provider model. It's a little heavy weight for some

00:15:10,019 --> 00:15:12,160
lightweight tools.

00:15:12,160 --> 00:15:16,160
So I'm gonna show a couple examples of the

00:15:16,160 --> 00:15:17,550
frontend.

00:15:17,550 --> 00:15:22,920
So bootstrap three. It's very nice and clean. We

00:15:22,920 --> 00:15:26,709
have the resource dates on the clusters, pending down

00:15:26,709 --> 00:15:30,329
up, some actions and we have a little menu

00:15:30,329 --> 00:15:33,750
to go through our deployments. Some of these, these

00:15:33,750 --> 00:15:36,839
are just mocks, basically. The whole thing's not working.

00:15:36,839 --> 00:15:41,279
We want monitors eventually. We get paged a lot

00:15:41,279 --> 00:15:44,009
and sometimes we don't know if, well if we

00:15:44,009 --> 00:15:45,709
got paged or if it was just transient.

00:15:45,709 --> 00:15:47,410
So we want a page to look at really

00:15:47,410 --> 00:15:50,920
quick, you know, just to see if, basically a

00:15:50,920 --> 00:15:53,040
sanity check to see if, do we really need

00:15:53,040 --> 00:15:54,480
to, you know, get up at three in the

00:15:54,480 --> 00:15:57,189
morning, get on the computer and get on these

00:15:57,189 --> 00:15:59,410
servers and see what's up.

00:15:59,410 --> 00:16:02,480
So, oh yeah. And the nice thing about using

00:16:02,480 --> 00:16:04,410
this with bootstrap is it's definitely gonna work on

00:16:04,410 --> 00:16:08,959
a mobile phone, so you'll be able to locate

00:16:08,959 --> 00:16:14,139
it on your phone in bed. Yeah.

00:16:14,139 --> 00:16:16,139
And this will change our life. This is a

00:16:16,139 --> 00:16:17,810
big pain point for us is how we manage

00:16:17,810 --> 00:16:21,329
our settings. We run Chef solo, right now we

00:16:21,329 --> 00:16:24,089
don't use Chef's server, and our settings are in

00:16:24,089 --> 00:16:26,519
a bunch of S3 buckets. We have rigged tools

00:16:26,519 --> 00:16:28,970
you know to update all our buckets, but it's

00:16:28,970 --> 00:16:31,480
definitely not the easiest to visualize. So.

00:16:31,480 --> 00:16:34,720
It's gonna help us a lot.

00:16:34,720 --> 00:16:37,680
So here's some of the, some of my inspiration

00:16:37,680 --> 00:16:42,009
while doing this. Test-driven infrastructure with Chef. It's a

00:16:42,009 --> 00:16:44,740
really quick read, it's like 70 pages. If you're

00:16:44,740 --> 00:16:48,670
interested in, you know, testing, your deployment process, check

00:16:48,670 --> 00:16:52,009
that out. It's kind of hand wave-y, but, there

00:16:52,009 --> 00:16:55,000
is the code, there is the Chef, Cucumber Chef.

00:16:55,000 --> 00:16:56,899
That the guy who wrote the book wrote, so

00:16:56,899 --> 00:16:58,509
you can check that out too.

00:16:58,509 --> 00:17:03,120
DevOps Weekly is a great, great newsletter. I pretty

00:17:03,120 --> 00:17:05,050
much read every week. They bring up some really

00:17:05,050 --> 00:17:08,540
cool tools and things people are working on. Just

00:17:08,540 --> 00:17:12,250
release it is a very cool book in the

00:17:12,250 --> 00:17:17,140
pragmatic programmer series or whoever releases that. It's, it's

00:17:17,140 --> 00:17:20,420
Java based, but it's, it's all about, you know,

00:17:20,420 --> 00:17:23,800
handling failure, and how important failure is a concept

00:17:23,800 --> 00:17:25,080
to operations.

00:17:25,080 --> 00:17:27,870
And, of course, you know, when you're building a

00:17:27,870 --> 00:17:30,990
framework and you're really trying to find these, this

00:17:30,990 --> 00:17:35,680
structure, patterns of enterprise architecture is a classic, and

00:17:35,680 --> 00:17:38,570
Growing Object Oriented Software Guided By Tests, two really

00:17:38,570 --> 00:17:41,510
great books, you know. The whole idea is to

00:17:41,510 --> 00:17:44,620
you know start with your unit tests, then write

00:17:44,620 --> 00:17:46,400
your class, so.

00:17:46,400 --> 00:17:47,990
It's good.

00:17:47,990 --> 00:17:53,120
That was actually pretty quick. So does anyone have

00:17:53,120 --> 00:17:54,460
any questions?

00:17:55,200 --> 00:17:59,000

YouTube URL: https://www.youtube.com/watch?v=KRuIXiq3eMc


