Title: Ruby Conf 2013 - Beneath The Surface: Harnessing the True Power of Regular Expressions in Ruby
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Nell Shamrell

Many of us approach regular expressions with a certain fear and trepidation, using them only when absolutely necessary. We can get by when we need to use them, but we hesitate to dive any deeper into their cryptic world. Ruby has so much more to offer us. This talk showcases the incredible power of Ruby and the Onigmo regex library Ruby runs on. It takes you on a journey beneath the surface, exploring the beauty, elegance, and power of regular expressions. You will discover the flexible, dynamic, and eloquent ways to harness this beauty and power in your own code.

Help us caption & translate this video!

http://amara.org/v/FG5U/
Captions: 
	00:00:16,000 --> 00:00:20,000
NELL SHAMRELL: My name is Nell, and I used to be intimidated by regular expressions.

00:00:20,029 --> 00:00:23,769
Has anyone else felt intimidated by regular expressions? I

00:00:23,769 --> 00:00:27,230
see a lot of hands that just went up.

00:00:27,230 --> 00:00:28,970
I used to look at a reg ex like

00:00:28,970 --> 00:00:30,980
this, and I would feel a sense of dread

00:00:30,980 --> 00:00:34,320
in my heart. Now what this reg ex does,

00:00:34,320 --> 00:00:38,160
is it validates visa credit card numbers. Now once

00:00:38,160 --> 00:00:40,730
I knew the context, I could kind of see

00:00:40,730 --> 00:00:42,550
what was going on. Kind of pick out clues

00:00:42,550 --> 00:00:44,530
here or there. But I had no idea how

00:00:44,530 --> 00:00:48,600
I'd ever write something like this.

00:00:48,600 --> 00:00:52,040
It's human nature to fear what we don't understand.

00:00:52,040 --> 00:00:54,390
Now it took time. But once I understood how

00:00:54,390 --> 00:00:57,660
a reg ex parser actually works, how it does

00:00:57,660 --> 00:00:59,410
that magic where it finds that match in the

00:00:59,410 --> 00:01:03,340
string, I realized it was simply a process. A

00:01:03,340 --> 00:01:07,780
logical process like any program that I could grasp.

00:01:07,780 --> 00:01:09,759
Then I knew how to use reg ex without

00:01:09,759 --> 00:01:12,810
fear. How to harness their power to match exactly

00:01:12,810 --> 00:01:16,999
what I wanted, exactly when I wanted.

00:01:16,999 --> 00:01:19,969
I'm here today to share this knowledge with you.

00:01:19,969 --> 00:01:22,929
To help you move beyond your fear by understanding

00:01:22,929 --> 00:01:26,749
how regular expressions work beneath the surface. When it

00:01:26,749 --> 00:01:30,740
comes to reg exes, knowledge truly is power, and

00:01:30,740 --> 00:01:32,799
today I'm going to show you how that power

00:01:32,799 --> 00:01:38,049
can be yours.

00:01:38,049 --> 00:01:40,659
Ruby and regular expressions work together in a harmony,

00:01:40,659 --> 00:01:43,759
in a symphony of code. If I was really

00:01:43,759 --> 00:01:46,459
gonna learn regular expressions anywhere, I'm so glad I

00:01:46,459 --> 00:01:50,030
learned them in Ruby. What we see in Ruby,

00:01:50,030 --> 00:01:52,299
however, when we use things like the match method,

00:01:52,299 --> 00:01:55,740
is just the tip of a very large iceberg.

00:01:55,740 --> 00:01:58,299
A lot more goes on beneath the surface in

00:01:58,299 --> 00:02:01,170
the Onigmo regular expressions library.

00:02:01,170 --> 00:02:03,759
Let's take a dive together beneath that surface.

00:02:03,759 --> 00:02:08,170
The Onigmo regular expressions engine was introduced in Ruby

00:02:08,170 --> 00:02:11,790
2 point 0. Ruby passes regular expressions and strings

00:02:11,790 --> 00:02:15,620
to Onigmo, and Onigmo handles the actual matching. Now

00:02:15,620 --> 00:02:19,080
Onigmo is actually a fork of the Oniguruma reg

00:02:19,080 --> 00:02:20,700
ex engine that was used in Ruby 1 point

00:02:20,700 --> 00:02:22,010
9.

00:02:22,010 --> 00:02:23,819
Both of these provide the standard reg ex features

00:02:23,819 --> 00:02:26,280
you'd find in any engine. But what these two

00:02:26,280 --> 00:02:30,010
do, is they handle multi-byte characters such as Japanese

00:02:30,010 --> 00:02:34,819
text, particularly well. Onigmo adds some new features that

00:02:34,819 --> 00:02:37,599
were introduced in Perl 5.

00:02:37,599 --> 00:02:39,599
Now Patrick Shaughnessy, who I know is in attendance

00:02:39,599 --> 00:02:41,470
here - there he is - has a great

00:02:41,470 --> 00:02:45,370
article entitled Exploring Ruby's Regular Expressions Algorithm. I'll include

00:02:45,370 --> 00:02:47,409
a link to that in my resource notes.

00:02:47,409 --> 00:02:50,950
Now in this article, he lays out the workflow

00:02:50,950 --> 00:02:54,069
of Onigmo. When Ruby first passes a reg ex

00:02:54,069 --> 00:02:57,750
to Onigmo, Onigmo reads the reg ex and parses

00:02:57,750 --> 00:03:01,629
it into an abstract syntax tree. And abstract syntax

00:03:01,629 --> 00:03:04,310
tree simply represents some code - in our case,

00:03:04,310 --> 00:03:06,700
a regular expression - in a tree form that's

00:03:06,700 --> 00:03:09,090
easier for Onigmo to compile.

00:03:09,090 --> 00:03:12,269
Onigmo then compiles this tree into a series of

00:03:12,269 --> 00:03:16,689
instructions for the engine to execute. Now these instructions

00:03:16,689 --> 00:03:19,780
can be represented by a finite state machine. Now

00:03:19,780 --> 00:03:22,430
what on earth is that?

00:03:22,430 --> 00:03:25,269
A Finite State Machine is a mathematical model that

00:03:25,269 --> 00:03:28,689
shows how something works. It's like a diagram or

00:03:28,689 --> 00:03:30,359
a map that shows how something can get from

00:03:30,359 --> 00:03:32,909
one state to being in the other state. This'll

00:03:32,909 --> 00:03:34,700
be clearer with the example, so let's go ahead

00:03:34,700 --> 00:03:36,730
and create one.

00:03:36,730 --> 00:03:38,629
I'm first going to create a Finite State Machine

00:03:38,629 --> 00:03:41,680
for a dog. In particular, this is my parents'

00:03:41,680 --> 00:03:44,390
dog, Annie. She's a very cute whippet Irish terrier

00:03:44,390 --> 00:03:47,569
mix. And, like most dogs, she loves to go

00:03:47,569 --> 00:03:49,329
in and out of the house all day, every

00:03:49,329 --> 00:03:51,170
day.

00:03:51,170 --> 00:03:53,900
So each of these two circles, these nodes, represent

00:03:53,900 --> 00:03:55,620
a state that Annie can be in at any

00:03:55,620 --> 00:03:57,900
given time. She can either be in the state

00:03:57,900 --> 00:03:59,749
of being in the house or she can be

00:03:59,749 --> 00:04:01,370
in the state of being out of the house.

00:04:01,370 --> 00:04:03,749
So how does she get from one state to

00:04:03,749 --> 00:04:04,450
the other?

00:04:04,450 --> 00:04:06,969
Well, if she's in the state of being in

00:04:06,969 --> 00:04:09,019
the house, she can go through her doggy door

00:04:09,019 --> 00:04:10,499
and transition to the state of being out of

00:04:10,499 --> 00:04:15,010
the house. Likewise, when she gets bored outside, she

00:04:15,010 --> 00:04:16,870
can go through the doggy door again and be

00:04:16,870 --> 00:04:20,229
in the state of being in the house.

00:04:20,229 --> 00:04:22,789
So that's an example of a Finite State Machine.

00:04:22,789 --> 00:04:25,259
But even with an example, a very cute example

00:04:25,259 --> 00:04:28,580
if I do say so myself, just those words,

00:04:28,580 --> 00:04:32,160
Finite State Machine are still quite a mouthful.

00:04:32,160 --> 00:04:33,770
Let's break it down.

00:04:33,770 --> 00:04:36,500
The machine is what I'm modeling. In our example,

00:04:36,500 --> 00:04:39,319
it was Annie the dog.

00:04:39,319 --> 00:04:42,110
State means we're modeling states that Annie- or, pardon

00:04:42,110 --> 00:04:44,639
me, modeling states that a machine can be in.

00:04:44,639 --> 00:04:46,080
In the case of Annie, she can either be

00:04:46,080 --> 00:04:47,569
in the house, or she can be out of

00:04:47,569 --> 00:04:49,810
the house.

00:04:49,810 --> 00:04:51,699
Finite means there are a limited number of states

00:04:51,699 --> 00:04:54,990
our machine can be in. States are often limited

00:04:54,990 --> 00:04:58,770
by physical reality. Annie really can't suddenly be under

00:04:58,770 --> 00:05:01,060
the ocean - unless she's in Miami and playing

00:05:01,060 --> 00:05:03,030
on the beach, I suppose - or suddenly be

00:05:03,030 --> 00:05:04,970
on the moon.

00:05:04,970 --> 00:05:08,500
In a computer, physical memory is not infinite. There's

00:05:08,500 --> 00:05:11,020
only so much a computer can process before it

00:05:11,020 --> 00:05:14,770
will crash. Therefore the number of states a computer

00:05:14,770 --> 00:05:17,819
process can be in is usually limited by physical

00:05:17,819 --> 00:05:18,870
memory.

00:05:18,870 --> 00:05:21,590
Now, before I move on, I want to mention

00:05:21,590 --> 00:05:24,039
that, like many dogs, Annie loves to stand halfway

00:05:24,039 --> 00:05:26,180
in the house and halfway out of the house.

00:05:26,180 --> 00:05:29,930
Now, in these cases, she is in multiple states

00:05:29,930 --> 00:05:33,979
simultaneously. There are ways a computer process can be

00:05:33,979 --> 00:05:38,240
in multiple states simultaneously as well, including reg exes.

00:05:38,240 --> 00:05:40,470
Now it's out of the scope of this presentation,

00:05:40,470 --> 00:05:42,819
but the article Regular Expression Matching Can be Fun

00:05:42,819 --> 00:05:46,229
and Fast by Russ Cox delves into an algorithm

00:05:46,229 --> 00:05:48,310
by Ken Thompson that allows for this.

00:05:48,310 --> 00:05:49,889
I'll also include a link to this in my

00:05:49,889 --> 00:05:52,490
resource notes.

00:05:52,490 --> 00:05:54,270
So let's make a Finite State Machine for this

00:05:54,270 --> 00:05:55,449
reg ex.

00:05:55,449 --> 00:05:57,699
This reg ex looks for the word force in

00:05:57,699 --> 00:06:00,650
any string that I pass to it. So when

00:06:00,650 --> 00:06:02,080
I use this reg ex in Ruby, I'm gonna

00:06:02,080 --> 00:06:05,050
declare it. I'm gonna declare my string. Then I'm

00:06:05,050 --> 00:06:06,770
gonna call match on my reg ex and pass

00:06:06,770 --> 00:06:08,879
it my string.

00:06:08,879 --> 00:06:10,800
After Onigmo reads the reg ex and parses it

00:06:10,800 --> 00:06:13,650
into that abstract sync- syntax tree, then compiles it

00:06:13,650 --> 00:06:16,780
into those instructions, my Finite State Machine will look

00:06:16,780 --> 00:06:18,750
something like this.

00:06:18,750 --> 00:06:21,419
A regular expression tries to match a string one

00:06:21,419 --> 00:06:25,610
character at a time, starting with the left-most character.

00:06:25,610 --> 00:06:27,620
So the first character this reg ex sees is

00:06:27,620 --> 00:06:30,770
that capital letter U. Now that doesn't match the

00:06:30,770 --> 00:06:32,500
path to the next state - it would need

00:06:32,500 --> 00:06:34,349
a lower-case F for that.

00:06:34,349 --> 00:06:37,849
So it stays there on that starting state. Next

00:06:37,849 --> 00:06:40,590
it sees the lower-case S. Now that still doesn't

00:06:40,590 --> 00:06:42,910
match, so it still doesn't move from that starting

00:06:42,910 --> 00:06:45,830
state. Now it's gonna do this for several characters,

00:06:45,830 --> 00:06:47,569
so let's go ahead and fast-forward.

00:06:47,569 --> 00:06:50,599
When we come to this lower-case F, now things

00:06:50,599 --> 00:06:52,830
start to get interesting.

00:06:52,830 --> 00:06:55,629
A character in the string matches the path, which

00:06:55,629 --> 00:06:57,889
means my Finite State Machine can move on to

00:06:57,889 --> 00:07:01,000
the next state. Then it sees the lower-case O

00:07:01,000 --> 00:07:03,819
in the string. Once again, that matches the path

00:07:03,819 --> 00:07:06,460
to the next state. Does the same with the

00:07:06,460 --> 00:07:11,460
R and the C and the E - and

00:07:11,460 --> 00:07:13,289
we have a match.

00:07:13,289 --> 00:07:16,060
We've reached that final state in our Finite State

00:07:16,060 --> 00:07:20,280
Machine, which means we're at a matching state. Onigmo

00:07:20,280 --> 00:07:22,720
passes the information back to Ruby, then Ruby returns

00:07:22,720 --> 00:07:25,449
a MatchData object containing our match. In this case,

00:07:25,449 --> 00:07:28,319
it's the word force.

00:07:28,319 --> 00:07:31,150
Now that was a pretty simple example. For our

00:07:31,150 --> 00:07:34,970
next example, let's try something a little more complicated.

00:07:34,970 --> 00:07:39,990
Let's try a regular expression that uses alternation.

00:07:39,990 --> 00:07:43,210
This regular expression with match a capital letter Y,

00:07:43,210 --> 00:07:46,580
followed by either the characters O-L-K, or the characters

00:07:46,580 --> 00:07:50,840
O-D-A. I'm providing two alternate ways my regular expression

00:07:50,840 --> 00:07:53,449
can find a match.

00:07:53,449 --> 00:07:55,610
So in Ruby, again, I'm going to declare my

00:07:55,610 --> 00:07:57,970
reg ex, declare my string - the word Yoda.

00:07:57,970 --> 00:08:00,060
I'm gonna call match on my reg ex and

00:08:00,060 --> 00:08:02,770
pass it that string, and this time my Finite

00:08:02,770 --> 00:08:06,000
State Machine looks a little bit different.

00:08:06,000 --> 00:08:07,919
There are two paths that can lead to a

00:08:07,919 --> 00:08:10,949
successful match. So after it matches the Y in

00:08:10,949 --> 00:08:15,000
my string, it now has to make a choice.

00:08:15,000 --> 00:08:18,419
Which path should it try first?

00:08:18,419 --> 00:08:21,060
In the case of alternates, a reg ex engine

00:08:21,060 --> 00:08:25,110
will always try the left-most alternate first. But before

00:08:25,110 --> 00:08:28,720
it tries that o-l-k path, it saves both the

00:08:28,720 --> 00:08:30,960
point in the string where it is, and the

00:08:30,960 --> 00:08:32,769
state it's at, to what what's called the back-track

00:08:32,769 --> 00:08:36,709
stack. Every time a reg-ex chooses one path over

00:08:36,709 --> 00:08:39,039
the other, it saves the string and the state

00:08:39,039 --> 00:08:41,010
just in case the match fails and it needs

00:08:41,010 --> 00:08:42,550
to try the other option.

00:08:42,550 --> 00:08:43,760
I like to think of it as being kind

00:08:43,760 --> 00:08:48,310
of like a choose-your-own-adventure book. It's marking a place

00:08:48,310 --> 00:08:51,610
that it can come back to. And it's a

00:08:51,610 --> 00:08:53,779
good thing it did. As soon as it sees

00:08:53,779 --> 00:08:55,980
that 'd' in the string it knows it has

00:08:55,980 --> 00:08:57,870
no way to get from its current state to

00:08:57,870 --> 00:08:59,800
that finishing matching state.

00:08:59,800 --> 00:09:02,820
Now, normally, having no paths to the finishing state

00:09:02,820 --> 00:09:06,630
would cause the reg-ex to fail. However, because it

00:09:06,630 --> 00:09:11,470
has something in that back-track state- stack, it can

00:09:11,470 --> 00:09:13,300
back-track back to the point where it chose which

00:09:13,300 --> 00:09:17,170
path to follow and try the other one.

00:09:17,170 --> 00:09:19,720
This time things go better. After it matches the

00:09:19,720 --> 00:09:21,760
lower-case o, it's next able to match the d,

00:09:21,760 --> 00:09:26,589
and the a, and hoorah! This time we have

00:09:26,589 --> 00:09:29,089
a match.

00:09:29,089 --> 00:09:31,250
Back in Ruby, it returns the MatchData object containing

00:09:31,250 --> 00:09:33,070
your match, which is the entire string in this

00:09:33,070 --> 00:09:36,310
case - Yoda.

00:09:36,310 --> 00:09:39,110
Now Finite State Machines become even more interesting when

00:09:39,110 --> 00:09:42,360
we use quantifiers.

00:09:42,360 --> 00:09:44,279
Now it's easy to look at this regular expression

00:09:44,279 --> 00:09:46,920
with our human brains and see the word no

00:09:46,920 --> 00:09:50,630
followed by a plus sign. However, Onigmo sees this

00:09:50,630 --> 00:09:53,610
as a capitol letter n, followed by a lower-case

00:09:53,610 --> 00:09:57,630
o, and a plus sign quantifier. That plus sign

00:09:57,630 --> 00:10:00,620
after the o means the o can appear one

00:10:00,620 --> 00:10:03,370
or more times.

00:10:03,370 --> 00:10:05,200
So in Ruby, again, I'll declare my reg ex

00:10:05,200 --> 00:10:07,139
and my string. This time, the string is the

00:10:07,139 --> 00:10:09,850
word Noooo, famously yelled by Luke Skywalker in The

00:10:09,850 --> 00:10:12,940
Empire Strikes Back.

00:10:12,940 --> 00:10:15,019
I'm gonna call match on my reg ex and

00:10:15,019 --> 00:10:17,360
pass it that string. And this is what my

00:10:17,360 --> 00:10:20,760
Finite State Machine looks like. It's pretty simple at

00:10:20,760 --> 00:10:24,690
first. It matches that capitol n, then it matches

00:10:24,690 --> 00:10:28,180
the first lower-case o, and now our reg ex

00:10:28,180 --> 00:10:28,850
has a dilemma.

00:10:28,850 --> 00:10:33,740
Technically, it has a correct match right here. It

00:10:33,740 --> 00:10:35,300
has a viable match. It can go ahead and

00:10:35,300 --> 00:10:37,600
return this back to Ruby and declare it found

00:10:37,600 --> 00:10:39,339
that match.

00:10:39,339 --> 00:10:42,110
But it also sees more lower-case o's in the

00:10:42,110 --> 00:10:46,000
string. It could either return the match here or

00:10:46,000 --> 00:10:48,300
it could follow that curved o path and loop

00:10:48,300 --> 00:10:51,589
back on itself into the same state.

00:10:51,589 --> 00:10:55,399
So what should it choose?

00:10:55,399 --> 00:10:58,010
It chooses to keep looping and match that second

00:10:58,010 --> 00:11:01,720
o. By default, the plus sign quantifier is a

00:11:01,720 --> 00:11:06,350
greedy quantifier. A greedy quantifier will always keep looping

00:11:06,350 --> 00:11:10,060
as long as there is more string to match.

00:11:10,060 --> 00:11:12,810
A greedy quantifier will always match as much of

00:11:12,810 --> 00:11:14,370
the string as it can get its greedy little

00:11:14,370 --> 00:11:18,459
arms around. Even if it has a successful match,

00:11:18,459 --> 00:11:22,720
it will always be hungry for more. It's greedy.

00:11:22,720 --> 00:11:27,399
A greedy quantifier uses maximum effort for maximum return.

00:11:27,399 --> 00:11:30,010
It will try every permutation of the reg ex

00:11:30,010 --> 00:11:32,079
to see if it can get the biggest match

00:11:32,079 --> 00:11:34,990
possible from the string.

00:11:34,990 --> 00:11:36,639
So it just keeps on looping. It matches that

00:11:36,639 --> 00:11:41,290
third o. Then the next o. And we have

00:11:41,290 --> 00:11:44,490
a match. Back in Ruby, I'm gonna get my

00:11:44,490 --> 00:11:47,500
MatchData object back and it matched the entire string.

00:11:47,500 --> 00:11:49,470
Capitol letter n with all four of the lower-case

00:11:49,470 --> 00:11:51,300
o's.

00:11:51,300 --> 00:11:54,410
But what if I want the opposite behavior?

00:11:54,410 --> 00:11:56,190
What if I want to match as little of

00:11:56,190 --> 00:12:00,519
the string as possible? I would use a lazy

00:12:00,519 --> 00:12:05,980
quantifier. Woah.

00:12:05,980 --> 00:12:08,010
Did someone just lean on the light? Oh. It's

00:12:08,010 --> 00:12:15,010
OK! It was mood lighting. Lazy quantifiers deserve darkness.

00:12:15,760 --> 00:12:18,860
So lazy quantifiers do the opposite of greedy quantifiers.

00:12:18,860 --> 00:12:23,339
They match the least number of characters possible. Lazy

00:12:23,339 --> 00:12:28,490
quantifiers use minimum effort for minimum return. They're lazy.

00:12:28,490 --> 00:12:30,019
They do just enough to get the job done

00:12:30,019 --> 00:12:32,050
and then they stop.

00:12:32,050 --> 00:12:36,260
I make a quantifier lazy by adding a question

00:12:36,260 --> 00:12:39,139
mark right after the quantifier. The plus sign is

00:12:39,139 --> 00:12:42,420
the quantifier. The question mark is a modifier on

00:12:42,420 --> 00:12:47,579
that quantifier that makes that quantifier lazy.

00:12:47,579 --> 00:12:49,829
So when I match my string using this reg-ex,

00:12:49,829 --> 00:12:52,560
again, declare my reg ex and my string, calling

00:12:52,560 --> 00:12:54,089
match on my reg ex and passing it that

00:12:54,089 --> 00:12:57,449
string, it's gonna start off the same. It's gonna

00:12:57,449 --> 00:13:02,930
match that capitol letter n, then that lower-case o,

00:13:02,930 --> 00:13:06,149
and now it finds itself with that same choice.

00:13:06,149 --> 00:13:08,199
Should it keep looping? Or should it go ahead

00:13:08,199 --> 00:13:10,449
and return the match right here?

00:13:10,449 --> 00:13:14,269
Well, because this is a lazy quantifier, it chooses

00:13:14,269 --> 00:13:16,600
to go ahead and return the match. It's done

00:13:16,600 --> 00:13:20,410
just enough to get the job done. It's done.

00:13:20,410 --> 00:13:21,959
And back in Ruby, I'm gonna get my match

00:13:21,959 --> 00:13:23,540
back, and notice that I have the capitol letter

00:13:23,540 --> 00:13:27,740
n and only one lower-case o this time. This

00:13:27,740 --> 00:13:30,970
choice, whether to keep looping or return the match,

00:13:30,970 --> 00:13:35,050
is the essence of greedy and lazy quantifiers.

00:13:35,050 --> 00:13:37,970
The difference between them is that a greezy- greedy

00:13:37,970 --> 00:13:41,009
quantifier will always choose to keep looping whenever able,

00:13:41,009 --> 00:13:43,459
and a lazy quantifier will always return the match

00:13:43,459 --> 00:13:47,040
as soon as it has a viable one. Now

00:13:47,040 --> 00:13:50,389
even though greedy quantifiers are greedy, they're also reasonable.

00:13:50,389 --> 00:13:54,360
If a greedy quantifier matches an extra character, but

00:13:54,360 --> 00:13:56,240
then that character is needed later in the reg

00:13:56,240 --> 00:13:58,480
ex to make a successful match, it will go

00:13:58,480 --> 00:14:02,430
ahead and give the character back. It will always

00:14:02,430 --> 00:14:05,269
choose to allow for an over-all match versus holding

00:14:05,269 --> 00:14:08,540
on to any extra characters.

00:14:08,540 --> 00:14:10,500
So let's try another example, but this time let's

00:14:10,500 --> 00:14:11,810
use the star quantifier.

00:14:11,810 --> 00:14:14,730
Now, before I continue, I should recommend that you

00:14:14,730 --> 00:14:19,149
use the star quantifier with caution. Star quantifier after

00:14:19,149 --> 00:14:21,639
character means that a character can appear any number

00:14:21,639 --> 00:14:25,649
of times, and any number of times includes zero

00:14:25,649 --> 00:14:29,970
times. So the dot character matches any character. Then

00:14:29,970 --> 00:14:32,050
we have the star quantifier - it'll be any

00:14:32,050 --> 00:14:34,839
character appearing any number of times, followed by the

00:14:34,839 --> 00:14:37,699
word moon.

00:14:37,699 --> 00:14:39,519
So in Ruby I'm gonna declare my reg ex,

00:14:39,519 --> 00:14:41,079
and declare my string - in this case it's

00:14:41,079 --> 00:14:43,550
another of my favorite lines from Star Wars. It's,

00:14:43,550 --> 00:14:45,839
'That's no moon.' And then call match on my

00:14:45,839 --> 00:14:48,740
reg ex and pass it the string. And in

00:14:48,740 --> 00:14:51,220
my Finite State Machine, it first sees that capitol

00:14:51,220 --> 00:14:55,230
letter T. Now that matches the dot meta-character path,

00:14:55,230 --> 00:14:56,910
so it's able to move on to the next

00:14:56,910 --> 00:15:00,130
state, and when it gets to this state, there

00:15:00,130 --> 00:15:02,630
are two paths that it can take.

00:15:02,630 --> 00:15:04,290
If it finds a lower-case m in the string,

00:15:04,290 --> 00:15:05,740
it can go ahead and move on to that

00:15:05,740 --> 00:15:08,750
next state. Or if it finds any character at

00:15:08,750 --> 00:15:10,810
all, it can again loop back in, in on

00:15:10,810 --> 00:15:13,820
itself, follow that dot character path, and be back

00:15:13,820 --> 00:15:15,500
at the same state.

00:15:15,500 --> 00:15:19,339
So h, lower-case h, matches any character. So it

00:15:19,339 --> 00:15:22,019
goes ahead and matches it. It then sees the

00:15:22,019 --> 00:15:24,730
lower-case a in the string, and again, that matches

00:15:24,730 --> 00:15:27,029
the any character path. So it's gonna do this

00:15:27,029 --> 00:15:28,980
for awhile. So let's go ahead and fast-forward a

00:15:28,980 --> 00:15:32,250
little bit, until we get to that lower-case m.

00:15:32,250 --> 00:15:34,829
This is where things start to get interesting. My

00:15:34,829 --> 00:15:37,709
reg ex has a dilemma. It can either take

00:15:37,709 --> 00:15:40,660
that path that matches the lower-case m, or it

00:15:40,660 --> 00:15:44,290
could take that looped any-character path. Which should it

00:15:44,290 --> 00:15:45,449
choose?

00:15:45,449 --> 00:15:49,209
Well, because that star quantifier on the dot character

00:15:49,209 --> 00:15:51,730
in my reg ex is greedy, it keeps on

00:15:51,730 --> 00:15:54,670
looping over that any character path. It does this

00:15:54,670 --> 00:15:58,769
again for the o, and the second o, and

00:15:58,769 --> 00:16:02,769
the n, and... uh-oh.

00:16:02,769 --> 00:16:04,790
My reg ex has no more characters left in

00:16:04,790 --> 00:16:06,420
the string for it to match. And it's still

00:16:06,420 --> 00:16:09,209
not at that finishing matching state. So it now

00:16:09,209 --> 00:16:12,420
has to make another choice.

00:16:12,420 --> 00:16:14,560
Should it back-track and give back some of those

00:16:14,560 --> 00:16:17,380
characters that matched, or should it declare the match

00:16:17,380 --> 00:16:18,540
a failure?

00:16:18,540 --> 00:16:24,570
Well, remember. Greedy quantifiers are reasonable. The star quantifier

00:16:24,570 --> 00:16:26,040
- or, pardon me, the dot with the star

00:16:26,040 --> 00:16:29,029
quantifier, goes ahead and surrenders some of the characters

00:16:29,029 --> 00:16:31,630
that it matched, starting with the most recent one

00:16:31,630 --> 00:16:33,069
it matched.

00:16:33,069 --> 00:16:35,850
So it surrenders that lower-case n, and that doesn't

00:16:35,850 --> 00:16:38,100
make things better. So it goes to the next

00:16:38,100 --> 00:16:42,269
one, that lower-case o. Still no match for that

00:16:42,269 --> 00:16:46,250
m path. Then it surrenders the next o. Still

00:16:46,250 --> 00:16:47,930
no match. Things are looking grim.

00:16:47,930 --> 00:16:53,060
Until it gives back that lower-case m. Now we

00:16:53,060 --> 00:16:55,339
have a match, and we can move on to

00:16:55,339 --> 00:16:59,410
the next state, where it again matches the lower-case

00:16:59,410 --> 00:17:04,700
o, then the second o, then the n. And

00:17:04,700 --> 00:17:08,030
huzzah! We now have a match.

00:17:08,030 --> 00:17:10,280
Back in Ruby, I'll get back my matched data

00:17:10,280 --> 00:17:14,260
object, which is the entire string, "That's no moon."

00:17:14,260 --> 00:17:16,690
So with back-tracking, we were able to find a

00:17:16,690 --> 00:17:23,690
successful match. But back-tracking tends to be slow. When

00:17:23,850 --> 00:17:26,090
you hear someone complain about how regular expressions are

00:17:26,090 --> 00:17:30,170
slow, they're probably complaining about backtracking.

00:17:30,170 --> 00:17:32,450
It's great when backtracking lets my reg ex find

00:17:32,450 --> 00:17:34,900
a match when it otherwise wouldn't have, but when

00:17:34,900 --> 00:17:37,820
it doesn't find that match, when my match fails,

00:17:37,820 --> 00:17:40,950
all that work, all that extra memory it used,

00:17:40,950 --> 00:17:43,210
is for nothing.

00:17:43,210 --> 00:17:45,750
So let's look at an example of this. This

00:17:45,750 --> 00:17:48,060
reg ex will match the capitol letter n, followed

00:17:48,060 --> 00:17:50,940
by the lower-case o appearing one or more times,

00:17:50,940 --> 00:17:54,560
followed by a lower-case w appearing one or more

00:17:54,560 --> 00:17:55,550
times.

00:17:55,550 --> 00:17:57,730
In Ruby, I once again declare my reg ex.

00:17:57,730 --> 00:18:00,610
I'm matching the string Nooo again. And call match

00:18:00,610 --> 00:18:03,900
on my reg ex and pass it that string.

00:18:03,900 --> 00:18:05,990
In my Finite State Machine, it matches the capitol

00:18:05,990 --> 00:18:10,330
letter n, then it matches the lower-case o, then

00:18:10,330 --> 00:18:12,260
it loops and matches the other os, but it's,

00:18:12,260 --> 00:18:14,160
because remember that plus sign on the lower-case o

00:18:14,160 --> 00:18:19,920
is greedy, then the next o, and the next,

00:18:19,920 --> 00:18:22,320
and the next, and - uh-oh. Once again, it's

00:18:22,320 --> 00:18:23,800
at the end of the string and it hasn't

00:18:23,800 --> 00:18:26,180
reached that final matching state.

00:18:26,180 --> 00:18:29,220
It hasn't found that lower-case w appearing one more

00:18:29,220 --> 00:18:32,890
times. Now it has to make a choice. Should

00:18:32,890 --> 00:18:35,320
it fail the match now or should it try

00:18:35,320 --> 00:18:39,290
to backtrack? Well, because it's a greedy quantifier and

00:18:39,290 --> 00:18:42,770
therefore reasonable, it goes ahead and backtracks. It gives

00:18:42,770 --> 00:18:43,560
back some of the characters.

00:18:43,560 --> 00:18:45,560
So it gives back that lower case o at

00:18:45,560 --> 00:18:49,000
the end, still no match. It's not a w.

00:18:49,000 --> 00:18:51,910
Then it goes to the next o, and the

00:18:51,910 --> 00:18:55,180
next one until it gets here. That's the last

00:18:55,180 --> 00:18:58,050
lower-case o it can backtrack over, and there's definitely

00:18:58,050 --> 00:19:01,560
no way it can make a match now.

00:19:01,560 --> 00:19:04,450
So it fails the match. Now that backtracking was

00:19:04,450 --> 00:19:07,430
a lot of extra effort. Sometimes that effort is

00:19:07,430 --> 00:19:10,290
worth it. But when it's not, there's a third

00:19:10,290 --> 00:19:14,060
kind of quantifier. The possessive quantifier.

00:19:14,060 --> 00:19:17,500
A possessive quantifier allows you to control the backtracking

00:19:17,500 --> 00:19:22,830
in your reg ex. Possessive quantifiers do not backtrack.

00:19:22,830 --> 00:19:24,670
They either make a match on the first try

00:19:24,670 --> 00:19:27,070
or they fail the match. So let's look at

00:19:27,070 --> 00:19:29,040
an example of this.

00:19:29,040 --> 00:19:32,540
I make a quantifier possessive by adding a plus

00:19:32,540 --> 00:19:35,320
sign after it. This reg ex matches a capitol

00:19:35,320 --> 00:19:38,160
letter n followed by a lower-case o appearing one

00:19:38,160 --> 00:19:40,700
or more times, and now I've added a second

00:19:40,700 --> 00:19:43,720
plus sign after it. One of these plus signs

00:19:43,720 --> 00:19:46,280
is the actual one or more quantifier, and the

00:19:46,280 --> 00:19:48,760
other is, again, a modifier on that quantifier that

00:19:48,760 --> 00:19:51,350
makes it possessive.

00:19:51,350 --> 00:19:53,280
After the o, my reg ex also looks for

00:19:53,280 --> 00:19:57,500
a lower-case w appearing one or more times.

00:19:57,500 --> 00:19:59,730
In my Finite State Machine, my reg ex first

00:19:59,730 --> 00:20:03,030
matches the capitol letter N, then it matches the

00:20:03,030 --> 00:20:06,980
lower-case o, and it proceeds the same, matches the

00:20:06,980 --> 00:20:11,820
next lower-case o and the next and the next

00:20:11,820 --> 00:20:16,510
one, until it comes to here, where it has

00:20:16,510 --> 00:20:18,700
that same dilemma.

00:20:18,700 --> 00:20:21,370
It hasn't yet found that lower-case w appearing one

00:20:21,370 --> 00:20:23,660
or more times. It didn't find it on the

00:20:23,660 --> 00:20:26,830
first try through the string. It has to decide

00:20:26,830 --> 00:20:28,830
whether it should backtrack and give back some of

00:20:28,830 --> 00:20:30,950
those extra o's in the hopes it might find

00:20:30,950 --> 00:20:34,150
that lower-case w somewhere, or it needs to give

00:20:34,150 --> 00:20:37,040
up and fail right now.

00:20:37,040 --> 00:20:40,850
A possessive quantifier always chooses to fail rather than

00:20:40,850 --> 00:20:44,830
give up any of the characters that it matched.

00:20:44,830 --> 00:20:47,520
Possessive quantifiers save both time and memory by making

00:20:47,520 --> 00:20:51,440
a reg ex fail faster. You use a possessive

00:20:51,440 --> 00:20:53,310
quantifier when you know there's a point in your

00:20:53,310 --> 00:20:57,080
reg ex where continuing or backtracking would be pointless.

00:20:57,080 --> 00:20:59,290
The match will fail no matter how many permutations

00:20:59,290 --> 00:21:01,410
it tries.

00:21:01,410 --> 00:21:05,240
Use possessive quantifiers with caution. They can potentially cause

00:21:05,240 --> 00:21:08,840
unexpected failures. Generally I've found the best place to

00:21:08,840 --> 00:21:12,850
use them is within smaller sub-expressions or nested quantifiers

00:21:12,850 --> 00:21:16,460
within your regular expression. When used carefully, they can

00:21:16,460 --> 00:21:21,550
significantly speed up a regular expression's matching.

00:21:21,550 --> 00:21:23,190
So far, I've taken you through the bits and

00:21:23,190 --> 00:21:26,750
pieces of how regular expression works. It's good information

00:21:26,750 --> 00:21:29,350
to know and great theory to understand, but it

00:21:29,350 --> 00:21:32,250
doesn't explain how to practically use a reg ex

00:21:32,250 --> 00:21:35,470
in your every day code.

00:21:35,470 --> 00:21:37,930
Crafting a regular expression for a specific need is

00:21:37,930 --> 00:21:41,020
as much an art as a science. In this

00:21:41,020 --> 00:21:43,260
last section, I'm going to take you through crafting

00:21:43,260 --> 00:21:46,070
a regular expression from scratch for use in real

00:21:46,070 --> 00:21:48,840
functioning code.

00:21:48,840 --> 00:21:51,360
Back in May, Avdi Grimm Tweeted a regular expression

00:21:51,360 --> 00:21:54,620
challenge. It was to create Ruby code using the

00:21:54,620 --> 00:21:56,610
GSUD method on a reg ex that would convert

00:21:56,610 --> 00:21:59,660
a snake_case string into a CamelCase string.

00:21:59,660 --> 00:22:02,220
Now, I was away on vacation and unplugged at

00:22:02,220 --> 00:22:03,860
the time, so I didn't see this until much

00:22:03,860 --> 00:22:06,660
later. I'd like to present my solution for you

00:22:06,660 --> 00:22:09,380
now, and take you step-by-step through how I developed

00:22:09,380 --> 00:22:11,830
it.

00:22:11,830 --> 00:22:15,880
First step was to white-board the requirements for my

00:22:15,880 --> 00:22:18,720
solution. First thing it needs to do is find

00:22:18,720 --> 00:22:21,540
the first letter of the string and capitalize it.

00:22:21,540 --> 00:22:24,120
Then it needs to find any character that follows

00:22:24,120 --> 00:22:27,880
an underscore and capitalize that one. Finally, it needs

00:22:27,880 --> 00:22:31,040
to remove the underscores from the string.

00:22:31,040 --> 00:22:34,430
These steps will transform a snake_case string into a

00:22:34,430 --> 00:22:35,680
CamelCase string.

00:22:35,680 --> 00:22:38,580
So let's start with that first step.

00:22:38,580 --> 00:22:40,150
I need to find the first letter of my

00:22:40,150 --> 00:22:44,290
string and capitalize it. Now I'm a test-driven developer,

00:22:44,290 --> 00:22:46,310
and I develop my regular expressions through the same

00:22:46,310 --> 00:22:51,510
red-green refactor method. Red-green refactor process, pardon me.

00:22:51,510 --> 00:22:52,990
So first I write a spec where I define

00:22:52,990 --> 00:22:55,700
the basic structure of my program. I'm creating a

00:22:55,700 --> 00:22:59,860
class called case_converter, and I'm adding a method to

00:22:59,860 --> 00:23:03,760
that class called upcase_chars. I expect when I pass

00:23:03,760 --> 00:23:08,150
a lower-case string to upcase_chars it will return that

00:23:08,150 --> 00:23:11,040
string with the first letter capitalized.

00:23:11,040 --> 00:23:14,980
Next, I draft a regular expression just to capture

00:23:14,980 --> 00:23:17,960
that first character in the string. I'm gonna use

00:23:17,960 --> 00:23:20,510
the slash A short hand, which anchors my regular

00:23:20,510 --> 00:23:24,270
expression to the beginning of my string. Next it's

00:23:24,270 --> 00:23:25,860
gonna need to find the first letter at the

00:23:25,860 --> 00:23:27,250
beginning of the string.

00:23:27,250 --> 00:23:29,000
In my first draft of this reg ex, I

00:23:29,000 --> 00:23:31,540
used the slash w short-hand, which will match any

00:23:31,540 --> 00:23:35,390
word character. So let's plug this into the actual

00:23:35,390 --> 00:23:37,410
upcase chars method.

00:23:37,410 --> 00:23:41,120
I define my reg ex, then I call gsub

00:23:41,120 --> 00:23:44,130
on my string and pass it that reg ex.

00:23:44,130 --> 00:23:45,770
Next I use a block and tell it every

00:23:45,770 --> 00:23:49,230
character that reg ex matches, call upcase on that

00:23:49,230 --> 00:23:53,330
character. So when I run my spec, my spec

00:23:53,330 --> 00:23:55,720
passes.

00:23:55,720 --> 00:23:59,530
But there's a problem with this reg ex.

00:23:59,530 --> 00:24:02,210
I want to capitalize the first letter of my

00:24:02,210 --> 00:24:06,410
string, even when that string starts with an underscore.

00:24:06,410 --> 00:24:07,730
Now in this spec, I state that when I

00:24:07,730 --> 00:24:10,940
pass it the string, underscore method, I should expect

00:24:10,940 --> 00:24:13,600
to, to the upcase chars method, I expect to

00:24:13,600 --> 00:24:16,880
receive that string back with the first letter capitalized.

00:24:16,880 --> 00:24:18,970
Now when I run this with my current code,

00:24:18,970 --> 00:24:24,890
with that current regular expression, this spec fails. Let's

00:24:24,890 --> 00:24:26,620
take a look at the error message from that

00:24:26,620 --> 00:24:28,270
spec.

00:24:28,270 --> 00:24:29,840
I expected to get back a string with a

00:24:29,840 --> 00:24:32,950
lower-case m capitalized, but I got back a lower-case

00:24:32,950 --> 00:24:38,430
string instead. Something is not right here. There's a

00:24:38,430 --> 00:24:41,840
problem with the slash w shorthand. Sure, it matches

00:24:41,840 --> 00:24:44,670
all word characters, but in its mind, all word

00:24:44,670 --> 00:24:49,220
characters includes underscores.

00:24:49,220 --> 00:24:50,890
If I pass it a string that starts with

00:24:50,890 --> 00:24:53,960
an underscore, it will match the underscore, not the

00:24:53,960 --> 00:24:56,670
first letter. My Ruby code will then call upcase

00:24:56,670 --> 00:25:00,140
on the underscore, and, naturally, nothing will happen. I

00:25:00,140 --> 00:25:03,140
was presenting a draft of this, and I, I

00:25:03,140 --> 00:25:05,640
was watching a chat from some students, and when

00:25:05,640 --> 00:25:07,880
I said this line, someone else responded, sure, if

00:25:07,880 --> 00:25:14,200
you upcase an underscore it becomes a hyphen.

00:25:14,200 --> 00:25:17,260
It doesn't.

00:25:17,260 --> 00:25:19,480
I need to be more specific. Instead of the

00:25:19,480 --> 00:25:23,330
slash w shorthand, I'm gonna use a character class.

00:25:23,330 --> 00:25:25,820
This character class will match any lowercase letter from

00:25:25,820 --> 00:25:27,800
a to z, which is exactly what I need

00:25:27,800 --> 00:25:30,970
to capitalize, and nothing more.

00:25:30,970 --> 00:25:36,110
Next- furthermore, I'm gonna allow my reg ex to

00:25:36,110 --> 00:25:39,640
match one underscore at the beginning of the string.

00:25:39,640 --> 00:25:42,870
Finally, I'm gonna add in a question mark after

00:25:42,870 --> 00:25:46,920
that underscore that makes that underscore optional. This reg

00:25:46,920 --> 00:25:48,660
ex will match both a string with an underscore

00:25:48,660 --> 00:25:50,670
at the beginning of it and a string without

00:25:50,670 --> 00:25:53,120
an underscore at the beginning of it.

00:25:53,120 --> 00:25:55,150
So my code, I'm gonna plug in this reg

00:25:55,150 --> 00:25:58,230
ex into my upcase chars method, and this time

00:25:58,230 --> 00:26:00,370
my spec passes.

00:26:00,370 --> 00:26:01,730
So I'm ready to move on to the next

00:26:01,730 --> 00:26:05,650
requirement for my solution.

00:26:05,650 --> 00:26:09,030
Find any character that follows an underscore and capitalize

00:26:09,030 --> 00:26:10,930
that character.

00:26:10,930 --> 00:26:14,460
Again, I'm going to define a spec. I expect

00:26:14,460 --> 00:26:17,080
that when I pass the string some underscore method

00:26:17,080 --> 00:26:21,100
to my upcase_chars method, it will return that same

00:26:21,100 --> 00:26:23,460
string, but with the letter s and the letter

00:26:23,460 --> 00:26:26,110
m capitalized.

00:26:26,110 --> 00:26:27,490
So to do this in my reg ex, I

00:26:27,490 --> 00:26:29,210
now need a reg ex that will match both

00:26:29,210 --> 00:26:31,860
the first lowercase letter of the string and any

00:26:31,860 --> 00:26:35,700
lowercase letter it- char, letter directly following an underscore.

00:26:35,700 --> 00:26:38,890
I take my current reg ex, and I add

00:26:38,890 --> 00:26:41,790
an alternate to it. This will now match the

00:26:41,790 --> 00:26:44,600
first lowercase letter of a string or any lowercase

00:26:44,600 --> 00:26:47,160
letter in the string. Now to make that alternate

00:26:47,160 --> 00:26:51,350
specific to lowercase letters that follow underscores, I add

00:26:51,350 --> 00:26:55,160
in a look behind. This look behind adds a

00:26:55,160 --> 00:26:58,950
context to that last character class, to that alternate.

00:26:58,950 --> 00:27:01,760
It states that it will only match a look,

00:27:01,760 --> 00:27:04,810
the lowercase letter if it directly fo- is, pardon

00:27:04,810 --> 00:27:07,250
me, if it directly follows an underscore.

00:27:07,250 --> 00:27:09,870
So when I add this reg ex to my

00:27:09,870 --> 00:27:14,850
code and run my spec, my spec passes.

00:27:14,850 --> 00:27:16,090
Now it's time to move on to the final

00:27:16,090 --> 00:27:19,270
requirement for my solution. I need to remove any

00:27:19,270 --> 00:27:21,400
underscores from the string.

00:27:21,400 --> 00:27:25,090
Again, I create a spec. For this requirement I'm

00:27:25,090 --> 00:27:27,480
going to have a separate method in my case_converter

00:27:27,480 --> 00:27:31,540
class called remove underscores.

00:27:31,540 --> 00:27:33,130
When I pass it a string with an underscore

00:27:33,130 --> 00:27:35,500
in it, I expect to get back that same

00:27:35,500 --> 00:27:38,470
string with the underscore removed.

00:27:38,470 --> 00:27:40,750
Now my reg ex for this method is actually

00:27:40,750 --> 00:27:43,420
pretty easy. I just need to find a literal

00:27:43,420 --> 00:27:47,260
underscore in my string. Some of my char- case

00:27:47,260 --> 00:27:50,330
converter class, I create my method, remove underscores. I

00:27:50,330 --> 00:27:52,070
declare my reg ex, which is just a literal

00:27:52,070 --> 00:27:56,380
underscore. Then I call gsub on the string I

00:27:56,380 --> 00:27:58,720
pass into it and I tell it that anything

00:27:58,720 --> 00:28:00,860
that matches this reg ex, replace it with an

00:28:00,860 --> 00:28:02,050
empty string.

00:28:02,050 --> 00:28:06,650
This effectively removes all underscores from the string.

00:28:06,650 --> 00:28:08,380
Then I pass both the reg ex and the

00:28:08,380 --> 00:28:12,660
empty string, and when I run my spec, my

00:28:12,660 --> 00:28:15,450
spec passes.

00:28:15,450 --> 00:28:19,010
So finally I now have two separate methods for

00:28:19,010 --> 00:28:22,080
my solution. I need to combine them into one

00:28:22,080 --> 00:28:26,300
method, to combine the results together. I create another

00:28:26,300 --> 00:28:29,220
spec. This one for a method called .snake_to_camel in

00:28:29,220 --> 00:28:30,740
my case_converter class.

00:28:30,740 --> 00:28:33,740
When I provide it a string with all lowercase

00:28:33,740 --> 00:28:36,850
letters and an underscore, I expect the method will

00:28:36,850 --> 00:28:39,520
return that string with the letter s and the

00:28:39,520 --> 00:28:44,570
letter m capitalized and the underscore removed.

00:28:44,570 --> 00:28:48,120
My snake_to_camel method will first call upcase_chars on the

00:28:48,120 --> 00:28:52,130
string that's passed into it, then call remove_underscores on

00:28:52,130 --> 00:28:55,900
the result of that upcase_chars method. When I run

00:28:55,900 --> 00:29:00,270
my spec, my spec passes.

00:29:00,270 --> 00:29:02,740
The code I presented here is available at this

00:29:02,740 --> 00:29:06,100
GitHub address. I'll also be Tweeting out this address

00:29:06,100 --> 00:29:09,390
after this presentation. There is definitely more than one

00:29:09,390 --> 00:29:11,790
solution to this challenge, and I highly recommend anyone

00:29:11,790 --> 00:29:14,870
who's interested, please submit a pull request, or Tweet

00:29:14,870 --> 00:29:17,190
out a solution. I'll re-Tweet it. It'd be great

00:29:17,190 --> 00:29:20,920
to have some discussion going.

00:29:20,920 --> 00:29:23,660
Life with reg exes is a journey.

00:29:23,660 --> 00:29:27,790
A journey that is at first fraught with peril.

00:29:27,790 --> 00:29:30,280
But it becomes much easier as you learn and

00:29:30,280 --> 00:29:33,870
understand what happens beneath the surface. Here are a

00:29:33,870 --> 00:29:36,590
few tips to help you along your way.

00:29:36,590 --> 00:29:41,420
Powerful, elegant regular expressions are not developed all at

00:29:41,420 --> 00:29:45,670
once. Develop your reg exes in small pieces. Make

00:29:45,670 --> 00:29:48,840
sure those individual pieces work, then combine them together

00:29:48,840 --> 00:29:50,990
into larger wholes.

00:29:50,990 --> 00:29:53,730
When you write a regular expression, you are programming

00:29:53,730 --> 00:29:56,700
in another language. The language of the reg ex

00:29:56,700 --> 00:29:59,880
parser. Like any program, reg ex need to be

00:29:59,880 --> 00:30:04,380
developed iteratively. They come in drafts.

00:30:04,380 --> 00:30:06,140
Whenever I'm crafting a regular expression for use in

00:30:06,140 --> 00:30:10,150
Ruby, I first develop it in Rubular. Rubular is

00:30:10,150 --> 00:30:12,830
a fantastic site that allows you to easily create

00:30:12,830 --> 00:30:16,210
and test regular expressions on test strings. Now a

00:30:16,210 --> 00:30:18,320
tip I picked up from Maryn Marsten on the

00:30:18,320 --> 00:30:21,710
Rogue's Parlay list, was to, whenever I create a

00:30:21,710 --> 00:30:24,780
regular expression in Rubular, make a perma link of

00:30:24,780 --> 00:30:26,880
it. Rubular allows you to make perma links of

00:30:26,880 --> 00:30:29,860
any regular expression you create on there.

00:30:29,860 --> 00:30:31,990
Then copy the url for that perma link and

00:30:31,990 --> 00:30:35,240
paste it into a comment in my code.

00:30:35,240 --> 00:30:37,070
This has been enormously helpful whenever I've needed to

00:30:37,070 --> 00:30:38,890
come back to regular expressions that I wrote a

00:30:38,890 --> 00:30:41,570
few weeks ago. Or anyone who's not as into

00:30:41,570 --> 00:30:43,500
regular expressions as I am needs to edit my

00:30:43,500 --> 00:30:46,600
code.

00:30:46,600 --> 00:30:49,190
Regular expressions are a programming language of their very

00:30:49,190 --> 00:30:54,000
own. Like any programming language, they can be learned.

00:30:54,000 --> 00:30:56,190
They are a logical system and process that, at

00:30:56,190 --> 00:30:58,630
their core, is no different from any program that

00:30:58,630 --> 00:31:00,730
takes in a certain input and returns a certain

00:31:00,730 --> 00:31:03,520
output.

00:31:03,520 --> 00:31:07,330
Regular expressions are powerful. So powerful, they inspire fear

00:31:07,330 --> 00:31:09,880
in many of us. But that fear will be

00:31:09,880 --> 00:31:13,760
overcome through understanding. Here's the call to action.

00:31:13,760 --> 00:31:17,440
Fire up Rubular. Experiment with greedy, lazy, and possessive

00:31:17,440 --> 00:31:21,340
quantifiers. Play with regular expressions. Have fun with them.

00:31:21,340 --> 00:31:23,740
Move past your fear and take a dive beneath

00:31:23,740 --> 00:31:24,570
the surface.

00:31:24,570 --> 00:31:28,970
I think you'll be amazed at what you find.

00:31:28,970 --> 00:31:32,150
I'm Nell Shamrell. I'm an engineer with Blue Box.

00:31:32,150 --> 00:31:35,090
That's my Twitter handle. I used a ton of

00:31:35,090 --> 00:31:38,340
resources in putting this presentation together. That's a link

00:31:38,340 --> 00:31:40,410
to all of them. All of them are fantastic.

00:31:40,410 --> 00:31:42,280
I'll Tweet up that link after this presentation as

00:31:42,280 --> 00:31:43,300
well.

00:31:43,300 --> 00:31:45,850
Please check it out. Explore all these awesome works

00:31:45,850 --> 00:31:48,220
by many authors that help me put this together.

00:31:48,220 --> 00:31:50,510
And with that, I'm ready for any questions. We

00:31:51,820 --> 00:31:53,940

YouTube URL: https://www.youtube.com/watch?v=JfwS4ibJFDw


