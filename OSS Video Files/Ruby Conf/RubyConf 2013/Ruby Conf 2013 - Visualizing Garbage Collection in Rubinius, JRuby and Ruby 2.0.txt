Title: Ruby Conf 2013 - Visualizing Garbage Collection in Rubinius, JRuby and Ruby 2.0
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Pat Shaughnessy

In this talk we'll dive into Ruby internals and take a close look at an ugly topic: garbage collection. How do these Ruby VM's allocate memory for new objects? How do they identify unused objects? How do they reclaim memory from garbage objects, allowing it to be used again?

You can learn a lot about someone from their garbage. Using a series of diagrams, we'll visually compare and contrast the complex algorithms these very different Ruby implementations use. What computer science research is behind each garbage collector? We'll also look at the GC changes planned for the upcoming Ruby 2.1 release.

Help us caption & translate this video!

http://amara.org/v/FG5D/
Captions: 
	00:00:16,960 --> 00:00:18,800
PAT SHAUGHNESSY: So I'm Pat. My name's Pat Shaugnessy.

00:00:18,800 --> 00:00:19,850
I'm really excited to be here.

00:00:19,850 --> 00:00:21,731
Today I'm gonna talk about garbage collection.

00:00:21,740 --> 00:00:24,210
It's almost like the theme of the conference this

00:00:24,220 --> 00:00:28,140
weekend. So Matz, I actually stole Matz's slide. Complete

00:00:28,140 --> 00:00:31,599
coincidence, as a matter of fact. But Matz told

00:00:31,600 --> 00:00:34,621
us all to be garbage collectors, and then Koichi

00:00:34,621 --> 00:00:36,309
Sasada did a great talk yesterday. It was a

00:00:36,309 --> 00:00:38,331
lot of fun to hear about what's coming in

00:00:38,340 --> 00:00:42,080
Ruby 2 point 1 with garbage collection.

00:00:42,080 --> 00:00:43,549
And I want to talk about garbage collection, how

00:00:43,549 --> 00:00:46,991
it works in, in three different versions of Ruby.

00:00:47,000 --> 00:00:49,569
Standard Ruby or MRI. MRI stands for Matz's Ruby

00:00:49,580 --> 00:00:52,371
Interpreter. I also want to talk about two alternative

00:00:52,371 --> 00:00:57,380
implementations of Ruby called JRuby and Rubinius. I, I

00:00:57,380 --> 00:00:58,639
know a couple of those guys are here, so

00:00:58,640 --> 00:01:01,811
you guys can correct me whenever I get, when

00:01:01,820 --> 00:01:02,760
I get into trouble.

00:01:02,760 --> 00:01:03,649
But before we get into the technical stuff, like

00:01:03,649 --> 00:01:08,041
what is garbage collection, how does it work, why

00:01:08,041 --> 00:01:09,750
do we want to talk about garbage collection? Why

00:01:09,750 --> 00:01:11,160
are we talking about it so much at this

00:01:11,160 --> 00:01:13,820
conference? It seems like a boring, dry technical topic.

00:01:13,820 --> 00:01:16,600
You know, there was a blog post recently in,

00:01:16,600 --> 00:01:18,880
it's been a couple months now, where someone said

00:01:18,880 --> 00:01:21,410
if you Tweet your garbage collection settings, you could

00:01:21,410 --> 00:01:23,290
get your test suite to run twenty percent faster.

00:01:23,300 --> 00:01:25,370
You know and that's great. I certainly admit that

00:01:25,370 --> 00:01:28,030
garbage collection is important. It's important that we run

00:01:28,040 --> 00:01:30,870
our tests fast. It's important that our apps run

00:01:30,870 --> 00:01:34,050
fast and users don't have to wait for long

00:01:34,060 --> 00:01:36,760
pauses while garbage collection is going on. But is

00:01:36,760 --> 00:01:39,380
it really interesting? Is it really exciting? Like how

00:01:39,380 --> 00:01:41,140
many of you here are getting excited by garbage

00:01:41,140 --> 00:01:41,680
collections?

00:01:41,680 --> 00:01:43,860
AUDIENCE: Whoo! Yeah! Whoo!

00:01:43,860 --> 00:01:46,490
P.S.: That's not what I- you guys all need

00:01:46,490 --> 00:01:47,880
to get a life, all right. This is really

00:01:47,880 --> 00:01:50,600
boring stuff. This is like computer science text book

00:01:50,600 --> 00:01:54,600
stuff. But, of course, I agree. I actually think

00:01:54,600 --> 00:01:56,740
garbage collection is really exciting and interesting. I think

00:01:56,740 --> 00:01:59,370
it's one of the most fascinating parts of computer

00:01:59,370 --> 00:01:59,710
science theory.

00:01:59,710 --> 00:02:02,540
And, you know, that's why, I think there's two

00:02:02,540 --> 00:02:05,060
real good reasons why to study garbage collection. One

00:02:05,060 --> 00:02:06,450
is, it's a great way to sort of go

00:02:06,460 --> 00:02:08,620
back to the classroom. You know, if you majored

00:02:08,620 --> 00:02:10,329
in computer science a long time ago, it's a

00:02:10,329 --> 00:02:11,891
great way to go back and sort of relearn

00:02:11,900 --> 00:02:14,189
what you already know, or if you're like me,

00:02:14,189 --> 00:02:16,210
maybe you came into Ruby and you never majored

00:02:16,220 --> 00:02:18,610
in computer science. You came from some other place,

00:02:18,610 --> 00:02:20,770
some other pack. So studying, so then like this

00:02:20,780 --> 00:02:22,481
can be a great way to sort of get

00:02:22,481 --> 00:02:25,930
your feet wet with real computer science theory.

00:02:25,930 --> 00:02:27,670
And there's another interesting reason why we should, I

00:02:27,700 --> 00:02:29,980
think, look at garbage collection. The way I like

00:02:29,980 --> 00:02:31,269
to put it is, you can learn a lot

00:02:31,269 --> 00:02:33,631
about someone from their trash, from their garbage. You

00:02:33,640 --> 00:02:34,950
know, if you go outside of a house, like

00:02:34,950 --> 00:02:36,489
a big fancy mansion and you look at what

00:02:36,489 --> 00:02:38,200
they throw out, you can get a sense of

00:02:38,220 --> 00:02:41,410
what's going on inside the house. Or, you know,

00:02:41,410 --> 00:02:44,540
archaeologists, when they go study ancient civilizations like ancient

00:02:44,540 --> 00:02:46,801
Greece or ancient Rome or whatever. You know, what

00:02:46,801 --> 00:02:48,619
are they doing? They're going into, they're pulling stuff

00:02:48,620 --> 00:02:50,400
out of the ground that people threw out thousands

00:02:50,400 --> 00:02:53,240
of years ago. And from that trash they can

00:02:53,240 --> 00:02:54,710
sort of figure out what was going on in

00:02:54,720 --> 00:02:56,070
that culture, in that city.

00:02:56,070 --> 00:02:57,790
And so even with Ruby, I think we look

00:02:57,790 --> 00:02:59,730
at how Ruby handles trash and garbage, we can

00:02:59,740 --> 00:03:02,040
get a sense of, at least, how the rest

00:03:02,040 --> 00:03:05,400
of that Ruby implementation works. But even the name

00:03:05,400 --> 00:03:07,850
garbage collection is a little bit of a misnomer.

00:03:07,850 --> 00:03:10,620
Garbage collectors don't just collect garbage. In fact they

00:03:10,620 --> 00:03:13,780
do three things. They allocate memory for new objects,

00:03:13,780 --> 00:03:16,109
so new values, so every time you create a

00:03:16,140 --> 00:03:19,050
Ruby object you're actually interacting with the garbage collector.

00:03:19,050 --> 00:03:23,240
It's kind of interesting and, and unexpected, but true.

00:03:23,240 --> 00:03:25,721
The second thing is they identify garbage objects. So

00:03:25,721 --> 00:03:27,759
they figure out which objects you're actually using in

00:03:27,760 --> 00:03:30,301
your code and which ones you're not. The garbage

00:03:30,301 --> 00:03:33,209
objects. And then they reclaim memory from those garbage

00:03:33,209 --> 00:03:33,461
objects.

00:03:33,461 --> 00:03:35,400
And just how do they do that? How do

00:03:35,400 --> 00:03:37,150
you get memory back from garbage and, you know,

00:03:37,160 --> 00:03:40,209
reuse it again for allocating more objects? It's cool

00:03:40,220 --> 00:03:42,121
if you think about it, it makes perfect sense

00:03:42,121 --> 00:03:45,200
that garbage collectors both allocate memory for new objects

00:03:45,200 --> 00:03:47,719
and reclaim memory from garbage objects. It's sort of

00:03:47,720 --> 00:03:49,720
two sides of the same coin so it works

00:03:49,720 --> 00:03:50,431
really well.

00:03:50,431 --> 00:03:53,099
So, an analogy I like to draw about this

00:03:53,100 --> 00:03:56,221
is if you're application is the human body, you

00:03:56,221 --> 00:03:58,259
know, let's say all of your code, all of

00:03:58,260 --> 00:04:01,380
your business logic, your beautiful algorithms, everything that you

00:04:01,380 --> 00:04:03,350
do is the brain, right, the intelligence of the

00:04:03,350 --> 00:04:05,200
body. So what part of the body do you

00:04:05,220 --> 00:04:07,380
think the garbage collector is?

00:04:07,380 --> 00:04:09,360
Kidneys. Liver.

00:04:09,360 --> 00:04:11,341
AUDIENCE: Gallbladder.

00:04:11,341 --> 00:04:15,650
P.S.: Gallbladder. Wow I'm getting a lot interesting answers.

00:04:15,650 --> 00:04:17,909
What was that? The heart.

00:04:17,909 --> 00:04:19,711
AUDIENCE: The heart. Right.

00:04:19,720 --> 00:04:22,120
P.S.: That's my answer. The heart.

00:04:22,120 --> 00:04:23,880
But one other interesting answer I got last few,

00:04:23,880 --> 00:04:25,600
last month at another conference is somebody said it's

00:04:25,600 --> 00:04:27,660
the immune system. You know, the white blood cells

00:04:27,660 --> 00:04:30,420
that go looking for viruses and bacteria. But yeah,

00:04:30,500 --> 00:04:32,100
I think it's the heart. I agree with you.

00:04:32,100 --> 00:04:34,880
I think that garbage collectors are actually the beating

00:04:34,880 --> 00:04:36,730
heart inside your application.

00:04:36,740 --> 00:04:38,540
You know, just as your real heart, if your

00:04:38,540 --> 00:04:40,580
heart stopped beating you'd be dead in seconds. You

00:04:40,580 --> 00:04:43,940
know, if your garbage collector stopped working, your application

00:04:43,940 --> 00:04:45,590
would be dead. You know, just the way that

00:04:45,590 --> 00:04:47,690
your heart provides blood and nutrients to the rest

00:04:47,700 --> 00:04:50,010
of the body, the garbage collectors provide a memory

00:04:50,010 --> 00:04:52,750
and objects for your application to use. And what,

00:04:52,760 --> 00:04:54,910
you know, if you had heart disease, if your

00:04:54,910 --> 00:04:57,440
heart slowed down, if you've had clogged arteries inside

00:04:57,440 --> 00:05:00,690
your garbage collector, your application would slow down and

00:05:00,700 --> 00:05:02,190
slow down and eventually die.

00:05:02,190 --> 00:05:03,940
OK, so what I want to do today is

00:05:03,940 --> 00:05:06,510
talk about how garbage collection works and just to

00:05:06,520 --> 00:05:08,310
give us something to talk about, I'm not gonna

00:05:08,310 --> 00:05:10,000
use really a lot of code today or actually

00:05:10,000 --> 00:05:12,620
very, almost, almost no code. I'm not gonna show

00:05:12,620 --> 00:05:14,310
any C code details. But I, what I do

00:05:14,320 --> 00:05:15,750
want to do is put a little class on

00:05:15,750 --> 00:05:17,970
the screen that we can use as an example

00:05:17,980 --> 00:05:19,230
as something to talk about.

00:05:19,230 --> 00:05:21,450
So the node class, kind of a boring name,

00:05:21,450 --> 00:05:24,100
I apologize. Initialize method - it just saves a

00:05:24,100 --> 00:05:26,380
value in an instance variable. And that's just a

00:05:26,380 --> 00:05:28,430
way for me to, you know, remember which node

00:05:28,440 --> 00:05:29,840
is which. So I can say, node dot new

00:05:29,840 --> 00:05:32,560
one. Node dot new two. And, you know, we

00:05:32,560 --> 00:05:34,700
would know which node is no. Which node is

00:05:34,700 --> 00:05:35,850
which.

00:05:35,860 --> 00:05:38,400
So let's start with allocation. So what happens inside

00:05:38,400 --> 00:05:40,920
of Ruby when I allocate a new object? You

00:05:40,920 --> 00:05:42,560
know, what kind of work does Ruby need to

00:05:42,560 --> 00:05:44,770
do? And the amazing thing about this is when

00:05:44,770 --> 00:05:47,410
I learned this is Ruby actually does very little.

00:05:47,420 --> 00:05:49,360
The reason why is that ahead of time, Ruby's

00:05:49,360 --> 00:05:52,810
actually creating thousands of objects when it starts up.

00:05:52,810 --> 00:05:55,080
So before your application ever runs, before a single

00:05:55,080 --> 00:05:57,830
line of your code runs, Ruby has, while it's

00:05:57,830 --> 00:06:01,820
starting up, created actually around ten thousand objects and

00:06:01,820 --> 00:06:03,710
put them in a linked list.

00:06:03,720 --> 00:06:05,210
So I'm gonna show you a bunch of diagrams

00:06:05,220 --> 00:06:08,920
today. What these squares are, representing are objects, there's

00:06:08,920 --> 00:06:11,590
actually C structures inside of Ruby. By the way,

00:06:11,590 --> 00:06:13,590
when I talk about standard MRI Ruby I'm gonna

00:06:13,600 --> 00:06:14,710
put a red Ruby at the top of the

00:06:14,710 --> 00:06:16,720
slide so we don't get confused about which one

00:06:16,720 --> 00:06:18,260
we're talking about.

00:06:18,260 --> 00:06:20,380
So each one of these squares is a, is

00:06:20,380 --> 00:06:23,320
an object that's been cre- pre-created ahead of time,

00:06:23,320 --> 00:06:24,820
and it's sort of ready and waiting for me

00:06:24,820 --> 00:06:26,410
to use it. So when I call the new

00:06:26,410 --> 00:06:28,490
method and I create an object and I say

00:06:28,490 --> 00:06:31,470
n1 is node dot new of ABC, right, so

00:06:31,480 --> 00:06:33,220
here I have this n1 variable, this is like

00:06:33,220 --> 00:06:35,970
a pointer or a reference up to a node

00:06:35,970 --> 00:06:38,160
object, and I'm gonna draw this one in gray

00:06:38,160 --> 00:06:40,180
now, because this is a live, active object that

00:06:40,180 --> 00:06:42,290
I'm actually using in my code.

00:06:42,300 --> 00:06:44,540
The other ones remain white, because they're not being

00:06:44,560 --> 00:06:46,620
used yet. They're wai- they're waiting for me to

00:06:46,620 --> 00:06:49,960
use them. So they stay on the linked list.

00:06:49,960 --> 00:06:51,830
And so what you can see is, Ruby actually

00:06:51,830 --> 00:06:53,460
doesn't do anything. When I create a new object,

00:06:53,460 --> 00:06:55,160
all it has to do is pull one off

00:06:55,160 --> 00:06:55,880
the list and give it to me. So it's

00:06:55,880 --> 00:06:57,480
very cool.

00:06:57,480 --> 00:06:59,710
If I create another one - n2 is node

00:06:59,720 --> 00:07:02,500
new of DEF, same thing. Ruby does very little.

00:07:02,500 --> 00:07:04,470
It just gives me one up ahead of the

00:07:04,470 --> 00:07:06,420
list. The list gets a little shorter. I have

00:07:06,420 --> 00:07:08,730
now two objects. And, you know, if I do

00:07:08,730 --> 00:07:11,590
it again, I have node new GHI. Same, same

00:07:11,590 --> 00:07:12,330
story.

00:07:12,360 --> 00:07:14,130
So this algorithm is called the free list. This

00:07:14,130 --> 00:07:16,860
is the free list algorithm, algorithm, and it's actually

00:07:16,860 --> 00:07:19,500
nothing new, nothing new to Ruby. It was invented

00:07:19,500 --> 00:07:23,150
a long, long time ago by this man here.

00:07:23,150 --> 00:07:26,490
Is this actually Mike Bernstein from Code Climate? Wait.

00:07:26,490 --> 00:07:28,750
It, ladies and gentlemen, I think Mike Bernstein is

00:07:28,780 --> 00:07:31,620
in the audience somewhere today. There he is. There

00:07:31,620 --> 00:07:34,030
he is. All right. Fantastic. So we have a

00:07:34,030 --> 00:07:38,190
legendary computer scientist with us today. Well, actually, while

00:07:38,190 --> 00:07:40,900
it's true that Code Climate has some legendary computer

00:07:40,900 --> 00:07:42,770
scientists working there, this is actually a man named

00:07:42,780 --> 00:07:46,010
John McCarthy. He is a professor, he was a

00:07:46,010 --> 00:07:48,260
professor at MIT. Actually spent most of his career

00:07:48,260 --> 00:07:48,810
at Stanford.

00:07:48,810 --> 00:07:51,290
While he was at MIT he invented a programming

00:07:51,300 --> 00:07:54,240
language called Lisp. You've probably all heard of that.

00:07:54,260 --> 00:07:56,490
It's famous for being the first, or one of

00:07:56,490 --> 00:07:59,280
the first functional programming languages, and a lot of

00:07:59,280 --> 00:08:01,920
what's in Ruby comes from Lisp. All the ideas

00:08:01,920 --> 00:08:05,720
around blocks and closures and, and other things as

00:08:05,720 --> 00:08:07,260
well. Functional techniques.

00:08:07,260 --> 00:08:08,950
But what I want to talk about today is

00:08:08,960 --> 00:08:12,110
garbage collection. And in fact John McCarthy invented garbage

00:08:12,110 --> 00:08:15,220
collection in 1960, when he built Lisp. So Lisp

00:08:15,220 --> 00:08:17,340
is not only famous for the language itself, it's

00:08:17,340 --> 00:08:19,920
famous for how it was built and what John

00:08:19,920 --> 00:08:23,100
McCarthy put inside of it.

00:08:23,100 --> 00:08:24,900
So he invented the free storage, he called the

00:08:24,900 --> 00:08:26,590
free storage algorithm. He wrote about it in his

00:08:26,600 --> 00:08:29,930
academic paper from 1960. So this is 53 years

00:08:29,930 --> 00:08:34,589
ago. Re- it's called recursive functions of symbolic expressions

00:08:34,589 --> 00:08:38,150
and their computation by machine part one. The cool

00:08:38,160 --> 00:08:39,780
thing about this is part one was good enough.

00:08:39,780 --> 00:08:41,351
There was never a part two or a part

00:08:41,360 --> 00:08:44,209
three. Like, he got it right the first time.

00:08:44,209 --> 00:08:45,351
And you could read all about this. You could

00:08:45,360 --> 00:08:46,990
stop right here. You could see Lisp stands for

00:08:46,990 --> 00:08:50,290
List-processor. And lots of cool stuff in here. One

00:08:50,290 --> 00:08:51,999
of the things that he mentions is the free

00:08:52,000 --> 00:08:54,341
storage list algorithm. And so he, you know, for

00:08:54,341 --> 00:08:57,280
good or for bad, Ruby actually uses exactly the

00:08:57,280 --> 00:09:00,309
same algorithm that John McCarthy invented 53 years ago.

00:09:00,309 --> 00:09:02,310
I'll just give you a sense of how long

00:09:02,320 --> 00:09:03,550
ago that was. This is the first computer that

00:09:03,560 --> 00:09:07,361
ran Lisp. This is called the IBM 704. This

00:09:07,361 --> 00:09:11,699
photo was taken in 1963. And you can see,

00:09:11,700 --> 00:09:12,880
there it is, up in the back, that whole

00:09:12,880 --> 00:09:15,671
cabinet is the computer. And, of course, you know,

00:09:15,680 --> 00:09:17,790
all of us have cell phones and smart phones

00:09:17,790 --> 00:09:20,189
in our pockets that have thousands or millions of

00:09:20,200 --> 00:09:22,481
times as much memory and CPU power.

00:09:22,481 --> 00:09:24,889
but the point here is, that computer ran the

00:09:24,889 --> 00:09:27,601
same algorithm that Ruby uses today for garbage collection.

00:09:27,601 --> 00:09:28,739
Pretty amazing.

00:09:28,740 --> 00:09:32,281
Now, I'm gonna switch gears and talk about the

00:09:32,281 --> 00:09:35,889
other two alternative versions of Ruby. One is JRuby.

00:09:35,889 --> 00:09:38,021
I'm gonna put a little red bird for JRuby

00:09:38,021 --> 00:09:41,640
- I think that's the JRuby icon, or logo.

00:09:41,640 --> 00:09:43,790
And for Rubinius we'll have a black R. So

00:09:43,800 --> 00:09:45,369
just to keep track of which is which so

00:09:45,380 --> 00:09:48,460
we don't get confused.

00:09:48,460 --> 00:09:50,200
And so what happens, how does allocation work for

00:09:50,200 --> 00:09:53,340
these versions of Ruby? So they work very differently.

00:09:53,340 --> 00:09:54,989
They also create things ahead of time, but what

00:09:54,989 --> 00:09:56,800
they do instead of creating a linked list of

00:09:56,820 --> 00:09:59,710
different objects of all the same size, they allocate

00:09:59,710 --> 00:10:03,091
this big stretch of continuous memory called the heap.

00:10:03,100 --> 00:10:04,269
And then when I allocate new or whe I

00:10:04,269 --> 00:10:06,651
create new objects, it allocates memory from the heap

00:10:06,660 --> 00:10:08,920
using a pointer. I'm calling it next, I don't

00:10:08,920 --> 00:10:10,879
know what it's called inside of the JVM.

00:10:10,880 --> 00:10:13,710
Remember, JRuby is Ruby implemented with Java, so I'm

00:10:13,710 --> 00:10:16,661
really talking about how the JVM works here. And

00:10:16,661 --> 00:10:20,110
Rubinius also, Rubinius is Ruby implemented with Ruby, but

00:10:20,110 --> 00:10:23,400
it uses its own virtual machine written in C++.

00:10:23,400 --> 00:10:25,729
So both of them actually allocate this big heap,

00:10:25,729 --> 00:10:28,230
and then as I create new objects, you know

00:10:28,240 --> 00:10:31,260
ABC, DEF, or GHI, same story, what happens is

00:10:31,260 --> 00:10:33,420
you can see this next pointer moves across from

00:10:33,420 --> 00:10:37,480
left to right. And they allocate adjacent bits of

00:10:37,480 --> 00:10:39,841
memory one after the other from the same heap

00:10:39,860 --> 00:10:42,990
in this way. This algorithm is called bump allocation.

00:10:42,990 --> 00:10:46,049
Cause we're, you know, bumping this pointer along from

00:10:46,049 --> 00:10:48,740
left to right. So kind of a cool idea.

00:10:48,740 --> 00:10:52,540
Now, of course, my diagrams are super simple simplifications

00:10:52,540 --> 00:10:54,711
of reality. So what's actually going on here is

00:10:54,740 --> 00:10:56,849
a lot more complicated, you know, back to standard

00:10:56,849 --> 00:10:58,940
Ruby, when I create a new node I'm actually

00:10:58,940 --> 00:11:00,741
creating a lot of different things. I have the

00:11:00,741 --> 00:11:03,029
object over here and some of the C structure

00:11:03,029 --> 00:11:04,950
names down here. I don't really want to get

00:11:04,950 --> 00:11:08,180
into this sort of detail today, but what's interesting

00:11:08,260 --> 00:11:09,540
here is, or what I want to point out

00:11:09,540 --> 00:11:11,360
is, you know, I have the object here and

00:11:11,360 --> 00:11:13,649
then the string I saved inside of it is

00:11:13,649 --> 00:11:15,121
over here. And then there's something else over here

00:11:15,121 --> 00:11:16,520
- this is the node class called the R

00:11:16,520 --> 00:11:17,490
class structure.

00:11:17,490 --> 00:11:19,029
The point I want to make is that all

00:11:19,060 --> 00:11:21,410
the things that we use in standard Ruby might

00:11:21,440 --> 00:11:24,101
be located in different places. And there are pointers

00:11:24,101 --> 00:11:26,100
that point from one to the other. So it's

00:11:26,100 --> 00:11:28,319
likely that these values or objects are not all

00:11:28,320 --> 00:11:31,041
together in the same stretch of memory. But if

00:11:31,041 --> 00:11:32,180
we look at, oh in fact if I create

00:11:32,180 --> 00:11:33,699
a new node and I put in more than

00:11:33,700 --> 00:11:36,380
23 characters, in fact, those letters don't even fit

00:11:36,380 --> 00:11:38,661
inside of the R string anymore. It puts them

00:11:38,661 --> 00:11:40,509
out, it has to allocate a different str, stretch

00:11:40,509 --> 00:11:43,781
of memories and put the letters somewhere else. So

00:11:43,781 --> 00:11:45,530
once again we see that, in order to use

00:11:45,530 --> 00:11:47,220
these values, Ruby has to go get stuff from

00:11:47,220 --> 00:11:49,189
different places in memory.

00:11:49,189 --> 00:11:51,331
And that's different, and again, this is oversimplifying, but

00:11:51,360 --> 00:11:54,220
it's different from how JRuby and Rubinius work, because

00:11:54,220 --> 00:11:57,439
they're allocating things from the same heap. It's more

00:11:57,440 --> 00:12:00,101
likely that these things are gonna be located nearby

00:12:00,101 --> 00:12:03,100
each other, that have similar memory addresses. But that's

00:12:03,100 --> 00:12:06,579
important for is that when your CPU actually caches

00:12:06,580 --> 00:12:09,471
RAM, and it's faster, it runs faster if it's

00:12:09,471 --> 00:12:12,660
getting values repeatedly from the same area of memory.

00:12:12,660 --> 00:12:15,290
So if it's hitting that cache more often. And,

00:12:15,290 --> 00:12:17,289
you know, even the, the letters of that longer

00:12:17,300 --> 00:12:20,060
string are gonna be located in the same net,

00:12:20,060 --> 00:12:21,360
same initial heap.

00:12:21,360 --> 00:12:24,690
OK. So let's move on to identify, how do

00:12:24,690 --> 00:12:29,870
garbage collectors identify garbage objects and, later, what do

00:12:29,870 --> 00:12:31,271
they do with them? But how do they find

00:12:31,300 --> 00:12:32,819
them in the first place? So let's go back

00:12:32,820 --> 00:12:35,200
to standard Ruby, the red Ruby icon. I have

00:12:35,200 --> 00:12:37,750
my free list. I've got three nodes already. So

00:12:37,750 --> 00:12:39,630
let's say I continue to run my program. I

00:12:39,640 --> 00:12:42,570
create some more objects. OK, this time I say,

00:12:42,570 --> 00:12:45,550
n1 is node new object JKL. OK, we've seen

00:12:45,560 --> 00:12:47,870
this before, we kind of get it pat.

00:12:47,870 --> 00:12:49,140
All right, let's move on. Get the, get to

00:12:49,140 --> 00:12:51,570
the point. All right, I'm creating more and more

00:12:51,570 --> 00:12:53,031
nodes. You can see what's happening here is I'm

00:12:53,040 --> 00:12:56,699
using up the free list. And eventually, you know,

00:12:56,700 --> 00:12:58,640
obviously the free list will run out. Something has

00:12:58,640 --> 00:13:00,630
to give.

00:13:00,630 --> 00:13:02,221
But there's another interesting detail here I want to

00:13:02,221 --> 00:13:04,780
point out, which isn't as obvious. You know, since

00:13:04,780 --> 00:13:08,119
I'm changing the value of n1, that variable or

00:13:08,120 --> 00:13:11,780
reference over here, I'm moving it over here, repeatedly

00:13:11,800 --> 00:13:14,790
to point at different nodes. Different objects. But the

00:13:14,790 --> 00:13:18,201
old objects are still there. They remain behind. So

00:13:18,201 --> 00:13:21,349
Ruby actually doesn't clean up after itself. No. Working

00:13:21,380 --> 00:13:22,981
as a Ruby collector, you need to get used

00:13:22,981 --> 00:13:24,339
to the fact that you're sort of, it's sort

00:13:24,339 --> 00:13:26,550
of like living in a really messy house.

00:13:26,560 --> 00:13:27,841
You know, when I got out of college, I

00:13:27,841 --> 00:13:29,359
lived with a few graduate students for about a

00:13:29,360 --> 00:13:31,560
year in a shared apartment. You know, I've been

00:13:31,560 --> 00:13:33,510
there. I know what that's like. They didn't clean

00:13:33,510 --> 00:13:35,750
the dishes. They didn't, like, they threw dirty clothes

00:13:35,750 --> 00:13:37,701
all over the floor. It was a disaster. You

00:13:37,701 --> 00:13:39,499
know, I'm not a neat-freak by any means, but

00:13:39,520 --> 00:13:42,101
it was a painful experience. And you know with

00:13:42,101 --> 00:13:44,419
Ruby, the same thing is going on. As I'm,

00:13:44,420 --> 00:13:46,731
you know, using objects, they're just left behind when

00:13:46,740 --> 00:13:49,290
I'm done with them. So eventually the free list

00:13:49,290 --> 00:13:50,859
runs out. Then what happens?

00:13:50,860 --> 00:13:53,180
You know, life can't go on. The house fills

00:13:53,180 --> 00:13:55,221
with trash and something has to give. So what

00:13:55,221 --> 00:13:57,859
Ruby does at this point is something called stop

00:13:57,860 --> 00:14:00,240
the world marking. So it stops your program. Your

00:14:00,240 --> 00:14:03,151
program is no longer running. And instead Ruby starts

00:14:03,160 --> 00:14:06,339
to do garbage collection, which means it starts to

00:14:06,340 --> 00:14:09,930
mark all the objects that your application is using.

00:14:09,930 --> 00:14:13,070
So, again, oversimplification, but it goes to all the

00:14:13,070 --> 00:14:15,961
different variables in my code, different references. It has

00:14:15,961 --> 00:14:17,830
a lot of its own references inside the virtual

00:14:17,840 --> 00:14:20,480
machine inside of Ruby. And it goes to the

00:14:20,480 --> 00:14:21,970
objects that these things point to and it marks

00:14:21,970 --> 00:14:24,080
them. I'll put a little m here for mark.

00:14:24,100 --> 00:14:25,819
In fact, there is, the way this works technically

00:14:25,820 --> 00:14:29,161
is there is a bit, so there's zeros and

00:14:29,161 --> 00:14:31,720
ones that indicate whether objects are marked or not.

00:14:31,720 --> 00:14:33,709
This is actually saved, starting with Ruby 2 point

00:14:33,709 --> 00:14:35,981
0, this is saved in a separate stretch of

00:14:35,981 --> 00:14:37,960
memory called the free bit map, and I think

00:14:37,960 --> 00:14:40,030
the author, the inventor of that system is here

00:14:40,030 --> 00:14:42,140
with us too. Nari San, I know he's here

00:14:42,140 --> 00:14:43,689
at the conference.

00:14:43,700 --> 00:14:45,651
So this is called bit map marking. This is

00:14:45,660 --> 00:14:47,619
new in 2 point 0. It allows Ruby to

00:14:47,620 --> 00:14:50,580
run faster and take advantage of something called Unix

00:14:50,580 --> 00:14:53,241
copy-on write optimization, so. I'm not gonna get in

00:14:53,241 --> 00:14:54,619
to that today. If you're interested in that sort

00:14:54,620 --> 00:14:56,611
of thing, I wrote an article about that you

00:14:56,611 --> 00:14:58,239
can check out online.

00:14:58,240 --> 00:15:00,870
But the point today is all the objects I'm

00:15:00,870 --> 00:15:03,430
actually using, what are called live objects, I'm showing

00:15:03,430 --> 00:15:07,261
here in gray, are marked. And the remaining objects,

00:15:07,261 --> 00:15:09,719
the white ones, since I'm not using them they're

00:15:09,720 --> 00:15:12,660
not marked. So they're, they must be garbage objects.

00:15:12,660 --> 00:15:15,941
So, by marking the live objects, Ruby has indirectly

00:15:15,941 --> 00:15:19,760
identified all of the garbage objects. Now, like I

00:15:19,760 --> 00:15:22,649
said, there's a, this is a big oversimplification, so.

00:15:22,680 --> 00:15:25,491
An actual program has, you know, hundreds and thousands,

00:15:25,491 --> 00:15:27,179
many thousands of objects that are all pointing to

00:15:27,180 --> 00:15:30,120
each other, in complicated ways. So there's actually, you

00:15:30,120 --> 00:15:31,661
can think of it as what's called an object

00:15:31,661 --> 00:15:34,900
graph. So there's a big network, or, you know,

00:15:34,900 --> 00:15:36,939
tree of objects, and they're all referencing each other.

00:15:36,940 --> 00:15:38,730
And so the code, the marking code inside of

00:15:38,740 --> 00:15:42,340
Ruby has to traverse this tree somehow and mark

00:15:42,340 --> 00:15:44,260
all these different things. So it's a very complicated.

00:15:44,260 --> 00:15:46,770
And this is why Ruby stops the world. So

00:15:46,770 --> 00:15:50,601
that it can do this without getting confused. Now,

00:15:50,601 --> 00:15:53,460
let's go and shift over to JRuby and Rubinius.

00:15:53,460 --> 00:15:55,549
So they do something similar. They also mark their

00:15:55,549 --> 00:15:57,781
objects so they know which are garbage and which

00:15:57,800 --> 00:15:59,649
are not, but they can do it while your

00:15:59,649 --> 00:16:02,490
application is running, at least some versions of the

00:16:02,490 --> 00:16:05,470
garbage collector in the JVM, and Rubinius does as

00:16:05,470 --> 00:16:06,011
well.

00:16:06,040 --> 00:16:09,420
So let's talk about how this works. So I'll,

00:16:09,420 --> 00:16:11,170
I'll put the word collector in this big blue

00:16:11,170 --> 00:16:14,340
arrow. This represents the garbage collector, OK. So the

00:16:14,340 --> 00:16:17,569
code that's inside of, of the JVM or inside

00:16:17,569 --> 00:16:20,760
the Rubinius VM, that's going through this object graph

00:16:20,780 --> 00:16:23,361
and marking all the different objects. So in this

00:16:23,361 --> 00:16:25,439
example it's marked the three along the top, it's

00:16:25,440 --> 00:16:27,411
come down to this one and in a moment

00:16:27,411 --> 00:16:28,970
it's, you know, in a microsecond it's gonna move

00:16:28,980 --> 00:16:31,199
on and mark these other two ones here that

00:16:31,200 --> 00:16:31,690
remain.

00:16:31,690 --> 00:16:33,760
So what happens next? So let's suppose that my

00:16:33,760 --> 00:16:36,800
application or your application is actually running at the

00:16:36,800 --> 00:16:38,640
same time as the garbage collector, maybe in a

00:16:38,640 --> 00:16:41,541
different thread. So let's say it comes over here,

00:16:41,541 --> 00:16:43,379
and I'm gonna represent this application with this other

00:16:43,380 --> 00:16:46,830
blue arrow, and I'm labeling it the Mutator. So

00:16:46,840 --> 00:16:48,140
this is one of the funny things if you

00:16:48,140 --> 00:16:51,630
read garbage collection literature, like academic papers from computer

00:16:51,630 --> 00:16:53,721
science, they refer to, you know, the nice innocent

00:16:53,721 --> 00:16:55,710
garbage collector over here, which is trying to do

00:16:55,710 --> 00:16:58,159
its work, and the evil mutator, which comes in

00:16:58,160 --> 00:16:59,970
at the last minute and starts changing things while

00:16:59,970 --> 00:17:01,951
it's trying to do garbage collection.

00:17:01,980 --> 00:17:03,889
But it's a little bizarre. But it's how computer

00:17:03,889 --> 00:17:06,690
scientists see the world. It's like its backwards. But

00:17:06,690 --> 00:17:09,361
what they do is, so imagine your application runs

00:17:09,380 --> 00:17:11,929
and it create an object, let's say, that one

00:17:11,929 --> 00:17:13,790
over there is a hash or an array, and

00:17:13,800 --> 00:17:16,141
I stick something into that array, a new object

00:17:16,141 --> 00:17:18,740
over here. But the new object, notice it's white,

00:17:18,740 --> 00:17:21,579
it's not marked yet. It's just been created.

00:17:21,580 --> 00:17:23,670
So since I'm running my app while the marking

00:17:23,670 --> 00:17:26,290
is going on, the collector, the poor innocent collector's

00:17:26,290 --> 00:17:29,150
over here, it doesn't know that happened. So it's

00:17:29,160 --> 00:17:31,091
gonna, well, what is it gonna do? It's gonna

00:17:31,100 --> 00:17:33,090
continue and mark these last two ones. And it's

00:17:33,090 --> 00:17:34,050
done. It's marked all the objects.

00:17:34,050 --> 00:17:36,649
So now it knows that everything that's marked is

00:17:36,649 --> 00:17:40,301
live. But what about this one? This wasn't marked.

00:17:40,320 --> 00:17:42,779
It's not garbage, though. If it collects that, if

00:17:42,800 --> 00:17:44,961
it releases that, then this is a huge problem,

00:17:44,961 --> 00:17:48,669
and actually Koichi Sasada, talked about this yesterday in

00:17:48,669 --> 00:17:51,550
a different context for generational garbage collection.

00:17:51,560 --> 00:17:53,300
But if we free that it's gonna be a

00:17:53,300 --> 00:17:56,150
huge big problem. We're gonna blow away validate on

00:17:56,150 --> 00:17:59,270
your application. So what do we do about this?

00:17:59,280 --> 00:18:01,141
So we go back to computer science theory. So

00:18:01,141 --> 00:18:03,490
this is going back to the 1960s again. I'm

00:18:03,490 --> 00:18:05,810
gonna get this pronunciation wrong. This is another legendary

00:18:05,820 --> 00:18:12,240
computer scientist called Edsgard Dykstra. I hope that's right.

00:18:12,240 --> 00:18:14,580
So he's also from Ho- he's from Holand, and

00:18:14,580 --> 00:18:18,299
he invented this idea called tri-color marking, which I'll

00:18:18,300 --> 00:18:20,020
explain in a second. He wrote a, he wrote

00:18:20,020 --> 00:18:22,071
an interesting paper about it. He called it On-the-fly

00:18:22,071 --> 00:18:24,470
garbage collection: an exercise in cooperation.

00:18:24,470 --> 00:18:26,899
So, well, on-the-fly, we kind of get that. It

00:18:26,900 --> 00:18:29,280
means you're doing garbage collection while your application is

00:18:29,300 --> 00:18:31,641
running. But what is cooperation? What is that all

00:18:31,641 --> 00:18:34,919
about? So he's talking about cooperation between the garbage

00:18:34,920 --> 00:18:38,020
collector and the application that's actually running.

00:18:38,020 --> 00:18:39,381
So again this is a very old idea. None

00:18:39,381 --> 00:18:42,049
of this is new to Ruby or to the

00:18:42,049 --> 00:18:44,520
JVM or anything like that. This is from the

00:18:44,520 --> 00:18:47,201
1960s. And how does it work? So again in

00:18:47,201 --> 00:18:49,810
JRuby and Rubinius, certain versions of the garbage collector

00:18:49,820 --> 00:18:52,750
in JRuby and also Rubinius use this tri-color marking.

00:18:52,750 --> 00:18:54,440
So the way it works is we divide up

00:18:54,440 --> 00:18:57,720
objects into three colors. White, gray, and black. We'll

00:18:57,720 --> 00:19:00,250
get to black in a minute. But initially all

00:19:00,260 --> 00:19:02,340
the objects are considered white. That means we haven't,

00:19:02,340 --> 00:19:04,580
we don't know anything about them. In the middle

00:19:04,580 --> 00:19:07,210
we'll have some gray objects. Initially we put what

00:19:07,210 --> 00:19:09,049
are called root objects here. These are like the

00:19:09,049 --> 00:19:11,900
roots of those, of that object rack tree.

00:19:11,900 --> 00:19:13,790
So these are objects that we know are live,

00:19:13,790 --> 00:19:15,671
that the virtual machine itself is using or your

00:19:15,680 --> 00:19:18,060
code has, you know, in a global variable or

00:19:18,080 --> 00:19:20,100
something. And then the collector, again, the blue arrow

00:19:20,100 --> 00:19:22,240
is gonna go through these gray objects and process

00:19:22,240 --> 00:19:23,919
them one at a time. And as it goes

00:19:23,920 --> 00:19:26,310
through those, it's going to mark them.

00:19:26,310 --> 00:19:27,410
And then it, when it marks them it'll move

00:19:27,410 --> 00:19:29,941
them over here to on the left and it'll

00:19:29,960 --> 00:19:31,809
color them in. Of course nothing is really going

00:19:31,809 --> 00:19:35,111
on, but colors is just a metaphor for describing

00:19:35,120 --> 00:19:37,429
the algorithm. but it will consider them black and

00:19:37,429 --> 00:19:39,601
put them over here on the left. And they're

00:19:39,601 --> 00:19:41,080
marked. So these are the objects that we know

00:19:41,080 --> 00:19:43,669
are marked. And on the right are the remaining

00:19:43,669 --> 00:19:45,581
objects that we don't know anything about. And the

00:19:45,600 --> 00:19:47,850
gray objects, think of these as the objects that

00:19:47,850 --> 00:19:50,169
are in the list or in the process of

00:19:50,180 --> 00:19:51,961
getting marked. So that you can call this the

00:19:51,961 --> 00:19:54,450
marked stack. It's like a list of objects we

00:19:54,450 --> 00:19:55,990
need to mark.

00:19:55,990 --> 00:19:58,629
And the other important detail here is, every time

00:19:58,629 --> 00:20:00,620
we mark one of these, we also check to

00:20:00,620 --> 00:20:03,530
see if it has a child object or objects

00:20:03,560 --> 00:20:06,020
over in this category. So the idea, as the

00:20:06,020 --> 00:20:09,670
process runs, the idea is that objects move gradually

00:20:09,670 --> 00:20:11,800
from the right and from the white to the

00:20:11,800 --> 00:20:13,991
gray over to the black. And then when we're

00:20:14,000 --> 00:20:16,179
done, we have a bunch of marked objects on

00:20:16,180 --> 00:20:18,361
the left that are black and we have some

00:20:18,361 --> 00:20:21,580
other garbage objects left behind that are white.

00:20:21,580 --> 00:20:23,240
So, you know, what's the big deal. Why are

00:20:23,240 --> 00:20:25,720
we doing all this stuff with colors? What's neat

00:20:25,720 --> 00:20:27,549
about this is it allows you to do concurrent

00:20:27,549 --> 00:20:29,841
marking. So what do I mean by that? Let's

00:20:29,841 --> 00:20:32,610
suppose that while I'm marking the gray objects in

00:20:32,610 --> 00:20:35,409
the middle, the mutator comes along and, and does

00:20:35,409 --> 00:20:37,150
something. It changes one of these things.

00:20:37,160 --> 00:20:38,931
This was, let's say this was over here. I

00:20:38,940 --> 00:20:41,370
had already marked it. It was black. But then

00:20:41,370 --> 00:20:43,840
I modified it by adding a reference from it

00:20:43,880 --> 00:20:46,600
to some other new object. So at the moment

00:20:46,600 --> 00:20:49,309
that I do that, the collector, what it can

00:20:49,309 --> 00:20:51,481
do is it can move it back into the

00:20:51,481 --> 00:20:54,480
marked stack. Or it could move the new object

00:20:54,480 --> 00:20:56,320
into the marked stack. Either way, I think Rubinius

00:20:56,320 --> 00:20:58,120
does the second thing.

00:20:58,120 --> 00:20:59,860
And what's neat about that is that we allow

00:20:59,860 --> 00:21:03,860
the application that second blue arrow to continue to

00:21:03,860 --> 00:21:05,970
run and go about its business. But the trick

00:21:05,970 --> 00:21:08,600
here is somehow the garbage collector needs to know

00:21:08,600 --> 00:21:11,570
that this happened. It needs to know when to

00:21:11,570 --> 00:21:13,320
move one of these black objects and make it

00:21:13,320 --> 00:21:15,700
gray again. So how does it do that?

00:21:15,720 --> 00:21:17,610
What it does is - actually there's a great

00:21:17,610 --> 00:21:22,340
article by Dirkjan Bussink from, from the Rubinius team

00:21:22,340 --> 00:21:25,730
about this exact issue. And it's a fantastic read.

00:21:25,740 --> 00:21:28,720
Check this out online on the Rubinius blog. Well,

00:21:28,720 --> 00:21:30,190
what he talks about is how you use write

00:21:30,190 --> 00:21:33,470
barriers. So I'll represent that with this sort of

00:21:33,470 --> 00:21:36,590
conceptual dotted line around the object. In fact it's

00:21:36,620 --> 00:21:37,809
around every object.

00:21:37,809 --> 00:21:39,491
A write barrier is just a little piece of

00:21:39,500 --> 00:21:42,929
code that allows the garbage collector to know when

00:21:42,929 --> 00:21:46,760
we, when the application, when you modify some object.

00:21:46,760 --> 00:21:48,471
And when that, when you do that, when you

00:21:48,480 --> 00:21:51,039
modify something, this calls the garbage collector and gives

00:21:51,040 --> 00:21:53,640
it a chance to move this one back into

00:21:53,640 --> 00:21:56,611
that gray category. So that's how concurrent marking works

00:21:56,611 --> 00:21:59,460
and how, with certain versions of the JVM and

00:21:59,460 --> 00:22:02,840
with Rubinius, you can run your application without or,

00:22:02,840 --> 00:22:06,399
at least, with very short runs and few minor

00:22:06,400 --> 00:22:07,800
GC processes.

00:22:07,800 --> 00:22:11,241
OK, so now we've identified our objects as garbage.

00:22:11,241 --> 00:22:12,110
What do we do with them? How do we

00:22:12,110 --> 00:22:15,759
reclaim memory from these things?

00:22:15,760 --> 00:22:17,971
So let's go back to standard Ruby with the

00:22:17,980 --> 00:22:20,230
free list. We have these three live objects and

00:22:20,230 --> 00:22:22,860
we have five garbage objects. So what do we

00:22:22,860 --> 00:22:25,060
do? How do we give those back to your

00:22:25,060 --> 00:22:27,560
program to use again? Well it's actually quite simple.

00:22:27,560 --> 00:22:29,279
We've done the marking, now we do what's called

00:22:29,280 --> 00:22:33,520
sweeping. So the, the standard Ruby or CRuby algorithm

00:22:33,520 --> 00:22:35,051
is called mark and sweep.

00:22:35,060 --> 00:22:37,320
This is the sweep part. So we copy all

00:22:37,320 --> 00:22:39,139
these objects and put them back on the free

00:22:39,140 --> 00:22:41,800
list. And I just said copy but that's not

00:22:41,800 --> 00:22:43,650
true. The neat thing about this is we're not

00:22:43,650 --> 00:22:46,431
actually copying anything. Since this was a linked list,

00:22:46,440 --> 00:22:48,269
all we have to do is sort of modify

00:22:48,269 --> 00:22:51,571
these pointers inside those objects to re- to put

00:22:51,580 --> 00:22:53,350
them back on the linked list, to reform the

00:22:53,350 --> 00:22:53,600
list.

00:22:53,620 --> 00:22:55,909
So it's actually quite fast and there's not copying

00:22:55,909 --> 00:22:56,910
involved.

00:22:56,910 --> 00:23:00,861
Now what about, back to JRuby and Rubinius? How

00:23:00,861 --> 00:23:03,389
do they work? How do they reclaim memory from

00:23:03,389 --> 00:23:06,731
garbage objects? So this is actually a really cool

00:23:06,740 --> 00:23:08,920
algorithm. Let me take a couple minutes and explain

00:23:08,920 --> 00:23:11,009
this. I was really impressed by this when I

00:23:11,009 --> 00:23:11,471
learned about it.

00:23:11,480 --> 00:23:14,269
So what I said earlier is actually not true.

00:23:14,280 --> 00:23:16,910
The JVM and Rubinius don't allocate just one big

00:23:16,920 --> 00:23:20,191
stretch of memory for allocating objects. It allocates two.

00:23:20,191 --> 00:23:22,840
One is called the from space. The other is

00:23:22,840 --> 00:23:24,789
called the to space. it's not called that in

00:23:24,800 --> 00:23:27,341
the code but it's called that in, you know,

00:23:27,341 --> 00:23:28,779
academic literature.

00:23:28,780 --> 00:23:30,930
This algorithm again this is a algorithm from the

00:23:30,930 --> 00:23:34,110
1970s. This is not, not anything new even for

00:23:34,110 --> 00:23:37,119
the JVM. SO the way this works is once

00:23:37,120 --> 00:23:39,510
I've identified all the live objects - those are

00:23:39,510 --> 00:23:41,980
the gray ones - and all the white spaces

00:23:42,000 --> 00:23:44,390
in between are the garbage objects, what I do

00:23:44,390 --> 00:23:47,040
is I copy those ones. I copy the live

00:23:47,060 --> 00:23:50,491
objects, not the garbage objects, from the from space

00:23:50,491 --> 00:23:52,860
and to the to space.

00:23:52,860 --> 00:23:54,180
So what that means is that I copy the

00:23:54,180 --> 00:23:57,200
live objects and actually physically copying memory around at

00:23:57,200 --> 00:24:00,200
this point. This idea is called copying garbage collection.

00:24:00,200 --> 00:24:02,470
And I put them in the other heap which

00:24:02,470 --> 00:24:04,909
is of the same size, just in case everything

00:24:04,909 --> 00:24:07,010
was live and in that case there'd be enough

00:24:07,020 --> 00:24:10,451
room to copy everything. And then I move that

00:24:10,460 --> 00:24:12,769
allocation pointer over so if I want to allocate

00:24:12,780 --> 00:24:15,331
more memory I know where to allocate it from.

00:24:15,331 --> 00:24:18,019
Now, here's where the elegant part comes in. So

00:24:18,020 --> 00:24:20,760
what the JVM and Rubinius do is then they

00:24:20,760 --> 00:24:23,851
swap the two spaces. So they swap the from

00:24:23,860 --> 00:24:26,550
space, I'm sorry, the to space up to be

00:24:26,550 --> 00:24:28,999
the new from space and they swap that old

00:24:29,000 --> 00:24:30,561
from space down to be the to space. And

00:24:30,561 --> 00:24:32,399
so now what we're end, what we end up

00:24:32,400 --> 00:24:35,520
with is a new heap with all of just

00:24:35,520 --> 00:24:38,270
the live objects in it and the remaining space

00:24:38,280 --> 00:24:40,290
is now ready for me to start allocating more

00:24:40,290 --> 00:24:42,571
new objects efficiently.

00:24:42,600 --> 00:24:44,440
now what's beautiful about this algorithm is that it's

00:24:44,440 --> 00:24:47,880
a very elegant way of compacting the heap. So

00:24:47,880 --> 00:24:50,049
when I did the copying, notice that all these

00:24:50,049 --> 00:24:52,650
objects, you know, went from different places in top

00:24:52,650 --> 00:24:55,530
feed and all ended up in the left side

00:24:55,540 --> 00:24:58,191
of the new one. SO it's not only getting

00:24:58,200 --> 00:25:00,500
rid of all the garbage, it's, it's moving the

00:25:00,500 --> 00:25:02,659
live objects together. It's a really elegant way to

00:25:02,660 --> 00:25:03,930
do this.

00:25:03,930 --> 00:25:05,890
And, like I said, this is from 1970. It

00:25:05,890 --> 00:25:10,331
was invented by the guy C.J. Cheney. Another computer

00:25:10,340 --> 00:25:12,509
scientist worked in garbage collection. We won't read all

00:25:12,520 --> 00:25:14,881
his stuff. And there's a variation on this called

00:25:14,881 --> 00:25:17,200
the baker algorithm that does the same thing but

00:25:17,200 --> 00:25:18,649
also works concurrently.

00:25:18,649 --> 00:25:19,600
Yes?

00:25:19,600 --> 00:25:22,480
AUDIENCE: (indecipherable - 00:25:23)

00:25:22,480 --> 00:25:26,980
P.S.: Conceptually. Theoretically, yes. So there's a lot more

00:25:26,980 --> 00:25:29,610
going on here. In fact one of the details

00:25:29,610 --> 00:25:32,039
is, there's a third heap I didn't mention called

00:25:32,040 --> 00:25:34,311
the Eden Heap. It means like the Garden of

00:25:34,320 --> 00:25:36,380
Eden. So this is where, I love this stuff,

00:25:36,380 --> 00:25:39,870
it's like out of fantasy land. So, so this

00:25:39,870 --> 00:25:41,640
is the Garden Eden because it's where we create

00:25:41,640 --> 00:25:43,540
all new objects. So life begins in the Garden

00:25:43,540 --> 00:25:45,681
of Eden, and then things are copied down. SO

00:25:45,681 --> 00:25:48,580
that's a third heap, and actually we'll get to

00:25:48,580 --> 00:25:51,249
generational garbage collection in a moment. SO there's even

00:25:51,249 --> 00:25:56,660
more heaps. So the answer is it's really complicated.

00:25:56,660 --> 00:25:57,931
But I lo- I like to get rid of

00:25:57,940 --> 00:26:00,610
the complicated stuff and focus on sort of the

00:26:00,610 --> 00:26:03,379
basic ideas and theories behind what's going on here.

00:26:03,380 --> 00:26:06,740
Cause it's really cool stuff to understand this. So

00:26:06,760 --> 00:26:09,491
it's, so let's get to generational garbage collection right

00:26:09,500 --> 00:26:09,759
now.

00:26:09,760 --> 00:26:12,471
So Koichi Sasada talked about this yesterday with MRI

00:26:12,480 --> 00:26:16,049
Ruby. But let's start with JRuby and Rubinius. SO

00:26:16,049 --> 00:26:19,371
how does the JVM and Rubinius do generational garbage

00:26:19,500 --> 00:26:20,480
collection?

00:26:20,480 --> 00:26:22,731
So one of the things about copying garbage collection

00:26:22,740 --> 00:26:24,590
- so we just saw how its copying these

00:26:24,590 --> 00:26:27,600
objects down. It seems like this would be really

00:26:27,620 --> 00:26:30,039
slow, doesn't it. Like it seems like a really

00:26:30,040 --> 00:26:32,571
bad idea, like why would you want to be

00:26:32,580 --> 00:26:35,399
copying objects around in memory, back and forth, and

00:26:35,400 --> 00:26:37,420
you know, we're swapping these, we're repeatedly copying things

00:26:37,420 --> 00:26:39,490
back and forth and back and forth. It doesn't

00:26:39,490 --> 00:26:40,730
seem like that would be a very fast way

00:26:40,730 --> 00:26:42,301
to do stuff.

00:26:42,340 --> 00:26:44,950
But the, the cool thing here is it only

00:26:44,950 --> 00:26:47,419
copies the live objects. SO this will work very

00:26:47,420 --> 00:26:50,530
well when there are very few live objects. When

00:26:50,530 --> 00:26:53,140
most of the objects are in fact garbage. And

00:26:53,160 --> 00:26:55,941
that's actually the case quite often. So if you

00:26:55,941 --> 00:26:58,419
create a new object, chances are you're not gonna

00:26:58,420 --> 00:27:01,390
use this for very long. Chances are that this

00:27:01,390 --> 00:27:04,451
is some sort of intermediate value inside a calculation

00:27:04,460 --> 00:27:06,470
or your uses, you create this and use it

00:27:06,470 --> 00:27:08,659
inside of one method. The method returns and you

00:27:08,660 --> 00:27:11,170
pop the stack and the object is released or

00:27:11,170 --> 00:27:12,790
it becomes garbage.

00:27:12,800 --> 00:27:16,221
So most of the time, most objects live for

00:27:16,221 --> 00:27:18,490
a very short period of time. So, and Koichi

00:27:18,490 --> 00:27:21,230
talked about this yesterday, this is called the weak

00:27:21,230 --> 00:27:23,800
generational hypothesis. If you didn't see that, check out

00:27:23,800 --> 00:27:26,070
his slides. He had some great graphs of actual

00:27:26,070 --> 00:27:29,160
data of how long objects typically live inside of

00:27:29,160 --> 00:27:32,220
Ruby. but this is a fancy way of saying,

00:27:32,240 --> 00:27:35,539
new objects die young. That's just the way object-oriented

00:27:35,540 --> 00:27:37,750
programming tends to work, and that's why they say

00:27:37,750 --> 00:27:40,101
this is a hypothesis. It's hard to prove this

00:27:40,101 --> 00:27:42,800
is the case and you can make pathological examples

00:27:42,800 --> 00:27:44,869
where this is not the case. But most of

00:27:44,869 --> 00:27:47,240
the time what happens is here is that there's

00:27:47,240 --> 00:27:50,201
very few objects that have to be copied down,

00:27:50,201 --> 00:27:52,258
and when some objects do live on for a

00:27:52,260 --> 00:27:54,860
longer period of time - so some objects do

00:27:54,860 --> 00:27:58,701
become old objects or mature objects, these might be,

00:27:58,701 --> 00:28:02,220
you know, configuration values or class objects, classes that

00:28:02,220 --> 00:28:05,460
you create, you need for the entire lifetime of

00:28:05,460 --> 00:28:06,190
your app.

00:28:06,190 --> 00:28:08,450
So what the JVM and Rubinius do is they

00:28:08,480 --> 00:28:11,169
promote, they get rid of those objects that last

00:28:11,169 --> 00:28:13,760
longer than a certain number of slots. A certain

00:28:13,760 --> 00:28:17,900
number of copy operations. So in fact what happens

00:28:17,900 --> 00:28:19,331
is for these, for this, this is called the

00:28:19,340 --> 00:28:22,870
young generation. For young objects or new objects, they're

00:28:22,870 --> 00:28:26,200
frequently not copied because they only live for a

00:28:26,200 --> 00:28:27,509
short period of time.

00:28:27,520 --> 00:28:29,660
So it's a really cool thing. Not where do

00:28:29,660 --> 00:28:32,691
these promoted objects or mature objects go? So it

00:28:32,691 --> 00:28:34,769
turns out, so this is called the young generation.

00:28:34,769 --> 00:28:36,750
This is where the garden of eden was and

00:28:36,750 --> 00:28:38,520
all this copying is going on, and on the

00:28:38,520 --> 00:28:40,400
top is the mature generation where we need to

00:28:40,400 --> 00:28:44,120
deal with these, you know, pesky old objects. How

00:28:44,140 --> 00:28:46,311
do we get rid of these?

00:28:46,320 --> 00:28:48,230
So what happens up there? So the answer is

00:28:48,230 --> 00:28:51,810
it depends. It depends on which garbage collector you're

00:28:51,820 --> 00:28:53,919
using. Well, what do you mean which garbage collector?

00:28:53,920 --> 00:28:57,020
Well it turns out in JRuby and, and if

00:28:57,020 --> 00:28:59,731
you use the JVM for any Java application, you

00:28:59,731 --> 00:29:01,810
can actually pick which garbage collector you want to

00:29:01,810 --> 00:29:03,989
use. I never knew this until recently when I

00:29:03,989 --> 00:29:06,191
started studying this stuff. It has this sort of

00:29:06,200 --> 00:29:08,820
plug-in play API for garbage collection.

00:29:08,820 --> 00:29:10,779
So in the JVM you can say I want

00:29:10,780 --> 00:29:14,380
to use the good-old-fashioned serial garbage collector, and that

00:29:14,380 --> 00:29:16,920
actually works. That uses stop the world. It stops

00:29:16,920 --> 00:29:19,050
your application and it sort of works similar to

00:29:19,050 --> 00:29:21,941
how standard Ruby works. You could, you can decide

00:29:21,960 --> 00:29:25,470
to use the parallel GC. This means, really the

00:29:25,470 --> 00:29:27,930
same thing as a serial GC except during that

00:29:27,930 --> 00:29:31,200
stop the world phase, while it's doing the marking,

00:29:31,200 --> 00:29:33,040
it does that at least in parallel in different

00:29:33,040 --> 00:29:34,861
threads. It speeds it up a little bit.

00:29:34,861 --> 00:29:36,820
Then there's a really cool new one called -

00:29:36,820 --> 00:29:38,879
it's not new actually, but -there's another one called

00:29:38,880 --> 00:29:41,420
the concurrent mark and sweep GC. So this one

00:29:41,420 --> 00:29:43,221
is designed to do the concurrent marking, what I

00:29:43,221 --> 00:29:47,240
talked about earlier for Java programs. And so with

00:29:47,240 --> 00:29:49,490
JRuby, of course, the nice thing about JRuby is

00:29:49,500 --> 00:29:51,480
you're using the JVM. So you can take advantage

00:29:51,480 --> 00:29:54,440
of, even though you're writing Ruby code, you can

00:29:54,440 --> 00:29:56,919
take advantage of the years and years of work

00:29:56,920 --> 00:29:59,380
that have gone into the JVM.

00:29:59,380 --> 00:30:01,530
So you can choose to use that concurrent mark

00:30:01,530 --> 00:30:03,130
and sweep GC if you want. You just turn

00:30:03,130 --> 00:30:04,821
it on. There's even a new one, this other

00:30:04,821 --> 00:30:08,289
experimental garbage collector. This one's called G1GC. This stands

00:30:08,289 --> 00:30:11,880
for garbage first garbage collection. I'm not gonna get

00:30:11,900 --> 00:30:13,800
into the details. I don't even pretend to understand

00:30:13,800 --> 00:30:14,941
how it works.

00:30:14,941 --> 00:30:17,389
But like anything there's these great academic papers you

00:30:17,389 --> 00:30:19,290
can go and read about all this stuff. So

00:30:19,290 --> 00:30:20,860
like I said this is a chance, an excuse

00:30:20,880 --> 00:30:22,420
for you to go back to school. You know,

00:30:22,420 --> 00:30:24,650
Loren Segal was talking about this yesterday, how, you

00:30:24,650 --> 00:30:27,451
know, I think for generally for Ruby tools and

00:30:27,460 --> 00:30:30,200
I think he was talking about security stuff, there's

00:30:30,200 --> 00:30:31,820
all kinds of academic papers out there. You can

00:30:31,820 --> 00:30:33,720
go and read this and learn about it. So

00:30:33,720 --> 00:30:36,249
it's really great. So use this as an excuse

00:30:36,249 --> 00:30:38,030
to go back to school and read about this.

00:30:38,040 --> 00:30:42,061
This is how the, the third one here concurrent

00:30:42,061 --> 00:30:45,139
mark and sweep GC. That algorithm is described here.

00:30:45,140 --> 00:30:47,991
It's actually mostly concurrent GC cause it does still

00:30:48,000 --> 00:30:51,970
stop your app for brief periods of time. There's

00:30:51,970 --> 00:30:55,419
another article called, about the garbage first garbage collection.

00:30:55,420 --> 00:30:58,241
You're, you'll read about that one here. This one's

00:30:58,241 --> 00:31:01,070
from 2000. This is 2004. So you know we're

00:31:01,070 --> 00:31:02,700
getting into at least the same century that we're

00:31:02,700 --> 00:31:03,450
in now.

00:31:03,450 --> 00:31:06,560
And what about Rubinius? You know, let's not forget

00:31:06,580 --> 00:31:08,739
about Rubinius. They actually use an algorithm from 2008.

00:31:08,740 --> 00:31:11,530
This is called Immix. Again, I don't pretend to

00:31:11,540 --> 00:31:13,471
understand this. It's quite complicated. But you can read

00:31:13,471 --> 00:31:16,739
about it here. And these two people invented that

00:31:16,740 --> 00:31:20,620
recently. I think for both this one, Immix, and

00:31:20,620 --> 00:31:22,611
this garbage first stuff they kind of divide up

00:31:22,620 --> 00:31:25,279
the memory to different regions, and I think they

00:31:25,280 --> 00:31:27,780
call them cards, and it's very complicated. The idea's

00:31:27,780 --> 00:31:30,611
to efficiently manage where objects are and move them

00:31:30,611 --> 00:31:33,320
around so you can give memory back to the

00:31:33,320 --> 00:31:35,169
operating system effectively.

00:31:35,169 --> 00:31:38,270
OK, so what about standard Ruby? You know all

00:31:38,270 --> 00:31:41,191
this great stuff with generational garbage collection. We're now

00:31:41,200 --> 00:31:42,670
getting, you know, all the work that Koichi is

00:31:42,670 --> 00:31:44,979
doing in the core team, it's coming to your

00:31:44,980 --> 00:31:48,041
regular old standard Ruby with the 2 point 1

00:31:48,060 --> 00:31:48,350
release.

00:31:48,350 --> 00:31:50,899
He went through this yesterday and he really explained

00:31:50,900 --> 00:31:52,630
it very well. So I'm just gonna blow through

00:31:52,630 --> 00:31:54,900
these slides super fast and just repeat the same

00:31:54,920 --> 00:31:56,331
stuff.

00:31:56,340 --> 00:31:58,940
So with standard Ruby, we have, we're gonna have

00:31:58,940 --> 00:32:01,450
two generations - young and mature. So we'll do

00:32:01,450 --> 00:32:03,710
the marking the way that we saw earlier. But

00:32:03,710 --> 00:32:05,769
once something's been marked, once an object's been marked

00:32:05,769 --> 00:32:08,370
once it will never be marked again. So if

00:32:08,400 --> 00:32:10,670
an object lives long enough so that the marking

00:32:10,670 --> 00:32:13,550
process occurs, it'll get moved over here to this

00:32:13,550 --> 00:32:14,551
mature generation.

00:32:14,560 --> 00:32:17,460
now, again, it's not getting moved. It's not getting

00:32:17,460 --> 00:32:21,060
copied, like things are getting copied in the JVM.

00:32:21,060 --> 00:32:23,850
In, in MRI Ruby, there's no copying. It's just

00:32:23,850 --> 00:32:26,239
consit- I'm just conceptually considering these to be in

00:32:26,240 --> 00:32:28,750
a different category. And it just means that once

00:32:28,750 --> 00:32:32,860
something's been marked it won't be marked again.

00:32:32,860 --> 00:32:34,880
And so what happens is every time the garbage

00:32:34,880 --> 00:32:37,431
collector runs, it'll do at least a young generat-

00:32:37,440 --> 00:32:40,249
a young garbage collection or minor one, it'll mark

00:32:40,260 --> 00:32:42,611
all the young objects, the way that it normally

00:32:42,620 --> 00:32:44,720
does. But they'll just skip these ones. And so

00:32:44,720 --> 00:32:46,309
by just skipping them it speeds it up and

00:32:46,309 --> 00:32:48,640
runs faster. Doesn't take as long and it reduces

00:32:48,640 --> 00:32:50,520
the amount of time you're waiting for your garbage

00:32:50,520 --> 00:32:53,201
collector to work.

00:32:53,201 --> 00:32:55,239
But we have the same problem the Koichi talked

00:32:55,240 --> 00:32:57,510
about yesterday, and actually the same thing, a very

00:32:57,520 --> 00:32:59,790
similar problem to what I just talked about with

00:32:59,790 --> 00:33:03,240
concurrent marking. What happens if you create, and this

00:33:03,240 --> 00:33:05,731
doesn't have to be concurrent, it can happen at

00:33:05,740 --> 00:33:08,309
any time between one garbage collection and the next

00:33:08,309 --> 00:33:10,880
one - what happens if I create an object

00:33:10,880 --> 00:33:14,990
and I, you know, modify a mature object? And

00:33:14,990 --> 00:33:16,490
so this again might be a hash or an

00:33:16,490 --> 00:33:19,051
array and I'm inserting something into it.

00:33:19,060 --> 00:33:21,019
So the problem is with only marking the ones

00:33:21,040 --> 00:33:24,760
over here, I'm not marking these ones again. This

00:33:24,760 --> 00:33:28,780
won't get marked. It's a very similar problem and

00:33:28,780 --> 00:33:29,930
actually Dirkjan - I don't know where he is

00:33:29,930 --> 00:33:32,160
- his blog post describes some of this stuff.

00:33:32,160 --> 00:33:34,380
And it's really cool how the same solution applies

00:33:34,380 --> 00:33:36,000
cause it's a similar problem.

00:33:36,000 --> 00:33:39,240
So by using, again, write barriers, by putting a

00:33:39,240 --> 00:33:42,841
write barrier around these mature objects, I can detect,

00:33:42,841 --> 00:33:45,430
Ruby can detect when you modify one of those.

00:33:45,440 --> 00:33:48,389
And so by notice, by noticing that, by using

00:33:48,389 --> 00:33:50,920
this write barrier, and by telling the garbage collector

00:33:50,920 --> 00:33:53,500
that something happened, it can include, you know, this

00:33:53,500 --> 00:33:56,821
particular object can include that one in the marking

00:33:56,821 --> 00:34:00,930
and therefore mark that one in the middle, too.

00:34:00,930 --> 00:34:02,470
So, actually this is what I said is not

00:34:02,480 --> 00:34:04,869
true. I just learned a couple days ago that

00:34:04,869 --> 00:34:08,021
Koichi just committed something to Ruby that is going

00:34:08,021 --> 00:34:10,420
to use three generations. So this, these diagrams are

00:34:10,420 --> 00:34:12,730
actually not accurate anymore. We need to see what

00:34:12,740 --> 00:34:15,379
they, what these guys do, and I think Koichi

00:34:15,380 --> 00:34:17,741
said that they're still evaluating this, whether this is

00:34:17,741 --> 00:34:20,139
a good idea or not, so, I'll let you

00:34:20,140 --> 00:34:21,731
talk about that when you figure out what to

00:34:21,740 --> 00:34:22,329
do.

00:34:22,329 --> 00:34:24,591
So, but this is still under development and might

00:34:24,600 --> 00:34:27,120
change in the next few weeks or months.

00:34:27,120 --> 00:34:29,781
Anyway, that said, my name is Pat Shawnisee. I

00:34:29,781 --> 00:34:32,490
just wrote a book called Ruby Under a Microscope,

00:34:32,490 --> 00:34:35,490
which describes how Ruby works under the hood internally

00:34:35,490 --> 00:34:38,599
and this actually was a synopsis of chapter twelve,

00:34:38,600 --> 00:34:40,630
which is the last chapter on garbage collection. The

00:34:40,640 --> 00:34:43,370
book describes really everything going on inside of Ruby,

00:34:43,370 --> 00:34:44,790
so. That's it. I don't know if we have

00:34:44,800 --> 00:34:47,681
any time for questions, I might have run on.

00:34:47,681 --> 00:34:49,579
I hear noise outside. We're probably way over time.

00:34:49,580 --> 00:34:52,580
I'm happy to hang around, chat to anyone who

00:34:52,580 --> 00:34:53,870

YouTube URL: https://www.youtube.com/watch?v=yl_zYzPiDto


