Title: Ruby Conf 2013 - The Big Picture by Jim Weirich
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	They say a picture is worth a thousand words. Does that mean a diagram is worth a thousand lines of code? Maybe.

Most Rubyists don't bother with drawing diagrams. We've found that our code is so expressive, that the need to explain the code in high level diagrams is greatly reduced. But greatly reduced doesn't mean never. There are times when a well drawn diagram can help us visualize the global properties of a program that are hard to see when looking at the individual source files.

Since Rubyists don't draw diagrams, we aren't aware of the rich meaning that a good diagram can convey. In this where we learn that UML is not a four letter word, but is just another tool in a well rounded developer's tool chest. Diagrams are not about big design up front, but about conveying meaning to other developers. Come join us and learn to see the big picture.

Help us caption & translate this video!

http://amara.org/v/FG4n/
Captions: 
	00:00:16,460 --> 00:00:18,520
JIM WEIRICH: I think that means it's about time to start.

00:00:18,580 --> 00:00:25,840
Are you guys enjoying Miami? Awesome!

00:00:25,840 --> 00:00:28,640
So why are you in here and not down at the beach?

00:00:28,640 --> 00:00:30,200
AUDIENCE: Cause you're cool!

00:00:30,200 --> 00:00:32,689
J.W.: Oh, yes, thank you. Yeah.

00:00:32,689 --> 00:00:36,281
How many people recognize this picture, right here? Yeah.

00:00:36,281 --> 00:00:38,379
Can you name it?

00:00:38,380 --> 00:00:42,531
Nighthawks yeah by Edward Hopper. It was painted in

00:00:42,540 --> 00:00:46,209
1942. If you recognize it, it might be because

00:00:46,209 --> 00:00:49,310
it's one of the standard Mac backgrounds that you

00:00:49,320 --> 00:00:51,351
can select on your desktop. And I had this

00:00:51,360 --> 00:00:53,930
on my desktop for a long time. And I

00:00:53,930 --> 00:00:56,350
really, really enjoy this picture. This is a really

00:00:56,350 --> 00:00:57,550
cool picture.

00:00:57,560 --> 00:01:00,389
Just a little bit of details about it. It

00:01:00,389 --> 00:01:03,741
was painted in 1942, I believe. It was sold

00:01:03,741 --> 00:01:07,020
to the Chicago Art Institute for about $3,000 just

00:01:07,020 --> 00:01:09,840
a few months after it was painted. It's hanging

00:01:09,840 --> 00:01:12,720
up in the Institute since that time.

00:01:12,740 --> 00:01:17,220
My daughter, who is a, goes to art school,

00:01:17,220 --> 00:01:20,060
said she took a field trip to Chicago and

00:01:20,060 --> 00:01:21,909
actually saw the actual painting up there. So while

00:01:21,909 --> 00:01:24,430
I was describing it to her, she immediately recognized

00:01:24,430 --> 00:01:28,621
it, said, oh yeah that's, that's the Hopper picture.

00:01:28,621 --> 00:01:30,599
But this is, this is fascinating to look at.

00:01:30,620 --> 00:01:32,701
And because it was on my background, I would,

00:01:32,701 --> 00:01:34,869
I would open my laptop up and I would

00:01:34,869 --> 00:01:38,970
see this and I would think about, maybe the

00:01:38,970 --> 00:01:41,371
story behind it. I mean, look at this. It's

00:01:41,380 --> 00:01:44,730
a diner. It's in New York somewhere. It's got

00:01:44,740 --> 00:01:46,110
a cigar add at the top - it's hard

00:01:46,110 --> 00:01:48,469
to see in the washed-out lighting here - for

00:01:48,469 --> 00:01:52,231
five cent cigars. It's dark outside but the inside

00:01:52,240 --> 00:01:55,469
of the diner is bright light and there's a

00:01:55,469 --> 00:01:56,880
couple characters in there.

00:01:56,880 --> 00:02:00,060
I mean look at this couple. Look at their

00:02:00,060 --> 00:02:03,931
body language. What is their body language telling you

00:02:03,940 --> 00:02:07,380
about them? They're sitting together. They're some kind of

00:02:07,380 --> 00:02:10,609
couple. But notice how closed off they are. Their

00:02:10,609 --> 00:02:16,261
hands are almost touching but not touching. Look at

00:02:16,261 --> 00:02:19,380
her face - how serious she looks, the dark

00:02:19,380 --> 00:02:21,880
eyes. Maybe she's been crying. Maybe she's sad.

00:02:21,880 --> 00:02:24,090
I can't quite tell what she's holding in her

00:02:24,090 --> 00:02:25,679
hand, but it looks like it might be a

00:02:25,680 --> 00:02:27,850
wad of money of some type. Maybe a little

00:02:27,850 --> 00:02:30,501
bit of money. Maybe this, these two people are

00:02:30,520 --> 00:02:34,170
a couple that are having problems. Maybe it's money-related

00:02:34,170 --> 00:02:36,700
problems. That's why she's looking at the money so

00:02:36,700 --> 00:02:37,010
hard.

00:02:37,020 --> 00:02:39,680
Look at the guy's face. He is not a

00:02:39,680 --> 00:02:46,579
happy camper. Someone wrote a poem about this picture,

00:02:46,580 --> 00:02:49,821
and she says, and the poem says, I bet

00:02:49,821 --> 00:02:51,770
she wrote him a letter and he is no

00:02:51,770 --> 00:02:56,300
longer the guy that reads her letters twice. Wow.

00:02:56,320 --> 00:02:57,410
Wow.

00:02:57,420 --> 00:03:01,390
Night Hawks, probably so named because the Hawk beak

00:03:01,390 --> 00:03:04,170
of the nose for this guy actually. That's an

00:03:04,170 --> 00:03:07,150
interesting little tidbit. So there's something wrong there. You

00:03:07,150 --> 00:03:09,800
know, a couple problems. Money problems, maybe something about

00:03:09,800 --> 00:03:13,020
other kinds of problems. But definitely tension in that

00:03:13,020 --> 00:03:13,690
couple.

00:03:13,700 --> 00:03:15,799
Now from a distance, I looked at this guy

00:03:15,800 --> 00:03:17,360
and I thought, oh wow, he looks like he's

00:03:17,360 --> 00:03:19,681
really happy to have these customers late at night

00:03:19,681 --> 00:03:22,439
in his diner. But when I zoomed in and

00:03:22,440 --> 00:03:24,610
looked closer, that's not a smile he has on

00:03:24,610 --> 00:03:27,600
his face. That's a grimace.

00:03:27,600 --> 00:03:29,901
And he's looking at that couple. So what is

00:03:29,901 --> 00:03:31,879
going on with the couple that is making the

00:03:31,880 --> 00:03:36,531
waiter unhappy? You know, is, did they just get

00:03:36,540 --> 00:03:38,299
done with a fight and they're sitting there sullenly

00:03:38,300 --> 00:03:41,571
and he's like, OK, what's gonna happen next? You

00:03:41,580 --> 00:03:45,140
know, it's, it's, you know, there's some interaction going

00:03:45,140 --> 00:03:46,729
on there as well.

00:03:46,729 --> 00:03:50,061
And then this guy. What's he doing there? He's

00:03:50,061 --> 00:03:54,249
sitting alone. He's all by himself. He's got a

00:03:54,249 --> 00:03:57,171
newspaper under his left elbow there, I believe that's

00:03:57,180 --> 00:03:58,520
a newspaper. You can see it just a little

00:03:58,520 --> 00:04:00,090
bit in the photo. It looks like he's holding

00:04:00,090 --> 00:04:01,560
a glass of water. He's got a cup of

00:04:01,560 --> 00:04:02,849
coffee right by him.

00:04:02,860 --> 00:04:04,371
I don't actually see any food in front of

00:04:04,380 --> 00:04:06,679
him but it looks like he's drinking something. And

00:04:06,680 --> 00:04:08,531
he's sitting there all alone kind of in the

00:04:08,540 --> 00:04:10,840
shadows, his hat's kind of down over his eyes

00:04:10,840 --> 00:04:12,290
so you can't see what's going on. Is he

00:04:12,290 --> 00:04:15,780
watching the other couple? Is he tailing them? Is

00:04:15,780 --> 00:04:19,009
this a gangster type thing, where maybe they're involved

00:04:19,009 --> 00:04:20,451
in some kind of gangster thing and that's the

00:04:20,460 --> 00:04:22,730
money problem and he's an enforcer and he's fo

00:04:22,730 --> 00:04:23,510
- I don't know.

00:04:23,510 --> 00:04:26,280
I mean the possibilities of this are, are wild.

00:04:26,280 --> 00:04:28,960
And notice he's got- his pocket, his coat pocket

00:04:28,960 --> 00:04:32,880
right down there, is, is open. He's got something

00:04:32,880 --> 00:04:35,139
in it. Is that his, is that his gun

00:04:35,140 --> 00:04:37,271
that he's got in his coat pocket? I don't

00:04:37,280 --> 00:04:39,380
know. I don't - there's all kinds of possibilities

00:04:39,380 --> 00:04:39,959
with this picture.

00:04:39,960 --> 00:04:42,131
That's why I love this picture. I don't know

00:04:42,140 --> 00:04:45,350
what it's about exactly, but the possibilities of the

00:04:45,350 --> 00:04:50,000
stories behind this is really interesting. Now this painting

00:04:50,000 --> 00:04:55,030
has been referenced in, in literature. There's been stories

00:04:55,030 --> 00:04:58,440
about it. Speigal did a - published five short

00:04:58,440 --> 00:05:02,639
stories based upon what author's thought might be going

00:05:02,640 --> 00:05:04,721
on in this picture. So five different stories. At

00:05:04,740 --> 00:05:07,090
least one of which ended in a massacre.

00:05:07,090 --> 00:05:13,190
It's used in movies, I think, Pennies, Pennies from

00:05:13,190 --> 00:05:19,960
Heaven reproduced this scene when, oh the guy's name

00:05:20,000 --> 00:05:22,320
escapes me. Who did, who did Blade Runner?

00:05:22,320 --> 00:05:24,670
AUDIENCE: (indecipherable guesses)

00:05:24,670 --> 00:05:27,310
J.W.: No, the director.

00:05:27,310 --> 00:05:28,530
AUDIENCE: Ridley Scott.

00:05:28,540 --> 00:05:29,760
J.W.: Ridley Scott. Ridley Scott. Thank you.

00:05:29,760 --> 00:05:32,070
When Ridley Scott did Blade Runner, he would take

00:05:32,070 --> 00:05:34,520
a reproduction of this film and shove it under

00:05:34,520 --> 00:05:37,720
the noses of his production team and saying, this

00:05:37,720 --> 00:05:40,370
is the feel that I want for my movie.

00:05:40,380 --> 00:05:44,560
This kind of dark noir feel. And that's kind

00:05:44,560 --> 00:05:47,519
of what pushed Blade Runner, the feel of Blade

00:05:47,520 --> 00:05:50,441
Runner was inspired, very much, by the feel of

00:05:50,441 --> 00:05:52,769
this picture as well.

00:05:52,769 --> 00:05:55,901
Art says a lot. Pictures speak a lot. Now

00:05:55,901 --> 00:05:58,130
they don't say exactly what's going on but they

00:05:58,140 --> 00:06:01,019
open up so many other questions. And I find

00:06:01,020 --> 00:06:03,591
it fascinating to look at pictures.

00:06:03,600 --> 00:06:05,860
So I'm Jim Weirich. I am Chief Scientist for

00:06:05,860 --> 00:06:08,570
Neo and I'm here to talk to you about

00:06:08,570 --> 00:06:11,630
the big picture. People have been asking me this

00:06:11,630 --> 00:06:13,430
week, Jim, what are you gonna talk about at

00:06:13,440 --> 00:06:15,670
RubyConf? What's your talk about? And I say, I'm

00:06:15,670 --> 00:06:20,419
going to talk about UML at a Ruby conference.

00:06:20,420 --> 00:06:27,420
Yeah. Yeah. I get two reactions from that. Oops.

00:06:32,760 --> 00:06:35,400
Yeah, like, huh, what's UML? I do not know

00:06:35,440 --> 00:06:37,440
of this UML of which you speak. The other

00:06:37,440 --> 00:06:43,840
reaction is - this is probably the Java developer

00:06:43,840 --> 00:06:46,470
who has been immersed in UML for so long,

00:06:46,470 --> 00:06:48,190
he is sick and tired of it and never

00:06:48,200 --> 00:06:49,750
wants to see it again.

00:06:49,750 --> 00:06:52,039
Truthfully, as I work with other Rubyists, I discover

00:06:52,040 --> 00:06:56,811
that they have not used diagramming to any great

00:06:56,820 --> 00:07:00,399
degree, and they're not aware of what UML can

00:07:00,400 --> 00:07:01,751
do for you. So I'm here to give you

00:07:01,760 --> 00:07:05,320
some very basics in UML.

00:07:05,320 --> 00:07:06,290
What I'm gonna do is I'm gonna give you

00:07:06,290 --> 00:07:10,030
a vocabulary. A vocabulary in pictures that you can

00:07:10,030 --> 00:07:12,419
use to build diagrams. And then I'm going to

00:07:12,420 --> 00:07:15,431
talk about three or maybe four of my own

00:07:15,440 --> 00:07:18,940
libraries and the diagrams that I drew of those

00:07:18,940 --> 00:07:22,740
libraries, and then what I learned from those diagrams

00:07:22,740 --> 00:07:25,460
that I did not see by just looking at

00:07:25,460 --> 00:07:26,169
the code.

00:07:26,169 --> 00:07:28,371
So it's kind of my plan for this talk.

00:07:28,380 --> 00:07:30,840
That's a road map. That's where we're gonna go.

00:07:30,840 --> 00:07:33,349
So let's start talk, and just mention UML just

00:07:33,349 --> 00:07:36,500
a little bit. There are basically three ways people

00:07:36,500 --> 00:07:37,190
use UML.

00:07:37,190 --> 00:07:41,751
One is the sketch language, to capture quick ideas

00:07:41,760 --> 00:07:43,350
and to get them down on paper so they

00:07:43,350 --> 00:07:47,459
can communicate with each other. UML as sketch omits

00:07:47,460 --> 00:07:52,171
details. UML as a sketch will lie about the

00:07:52,180 --> 00:07:54,469
software, because the lie is better than what the

00:07:54,469 --> 00:07:57,561
reality is there. You want to convey an idea,

00:07:57,561 --> 00:08:00,810
you know, the idea's what's important, not necessarily the

00:08:00,810 --> 00:08:03,550
details. So UML as sketch.

00:08:03,560 --> 00:08:04,829
You can use it in both ways. You can

00:08:04,829 --> 00:08:08,271
sketch up an idea before you implement it, just

00:08:08,280 --> 00:08:10,109
to kind of get an idea of the roadmap

00:08:10,109 --> 00:08:11,961
you want to go to. You can take an

00:08:11,961 --> 00:08:15,359
existing piece of code and draw the diagrams afterwards

00:08:15,360 --> 00:08:17,640
to kind of get a better understanding of what

00:08:17,640 --> 00:08:20,070
the software's doing. That's what I've done on the

00:08:20,080 --> 00:08:22,020
examples that follow.

00:08:22,020 --> 00:08:25,080
UML as a blueprint is probably what most, gives

00:08:25,080 --> 00:08:29,291
most Java developers the eh feeling. It's when you

00:08:29,300 --> 00:08:32,309
use UML down to such a detailed degree that

00:08:32,309 --> 00:08:36,681
a designer- architect can take the UML diagram and

00:08:36,681 --> 00:08:38,920
hand it off to a coder and the coder

00:08:38,920 --> 00:08:40,720
just implements it.

00:08:40,720 --> 00:08:42,800
I don't believe that works very well at all,

00:08:42,800 --> 00:08:45,050
and I'm not a fan of UML as a

00:08:45,050 --> 00:08:48,770
blueprint. Even worse than UML as a blueprint is

00:08:48,780 --> 00:08:52,249
UML as a programming language. I used to work

00:08:52,249 --> 00:08:55,041
for a company called CompuWare. We had a product

00:08:55,041 --> 00:08:59,280
called OptimalJ, and the salesman for CompuWare, they said,

00:08:59,280 --> 00:09:01,280
Jim, you gotta push OptimalJ for us, you know.

00:09:01,280 --> 00:09:04,660
It's so great. You just draw the pictures, and

00:09:04,660 --> 00:09:07,460
then you push a button and you get an

00:09:07,460 --> 00:09:09,749
application out of it.

00:09:09,760 --> 00:09:12,291
Yeah. That's exactly what I did. I said, uh-huh,

00:09:12,300 --> 00:09:14,440
yeah. I laughed. But Jim it really works. It's

00:09:14,440 --> 00:09:17,960
got to work. We use it. Patterns. And I

00:09:17,960 --> 00:09:20,449
said, you don't, guys, really don't know what patterns

00:09:20,449 --> 00:09:20,901
are, do you?

00:09:20,901 --> 00:09:25,470
No, but we know they're good.

00:09:25,470 --> 00:09:28,499
So I was never a big believer in OptimalJ.

00:09:28,500 --> 00:09:31,481
It turns out that when you dig deeper, for

00:09:31,481 --> 00:09:34,190
every diagram you draw, you have to accompany it

00:09:34,200 --> 00:09:37,569
with something called the expression language, to kind of

00:09:37,580 --> 00:09:38,731
tie it down and kind of map it into

00:09:38,740 --> 00:09:41,350
a programming language. I, and I told my sales'

00:09:41,350 --> 00:09:43,860
guys, this kind of looks like programming right here.

00:09:43,860 --> 00:09:45,540
He says, oh no, no, it's not. It's not.

00:09:45,540 --> 00:09:48,740
Don't worry. It's nothing like programming. OK.

00:09:48,740 --> 00:09:51,509
So UML as a programming language, no. I'm not

00:09:51,509 --> 00:09:53,901
a big believer in that. But UML as sketch,

00:09:53,901 --> 00:09:56,259
I am still a big fan of.

00:09:56,260 --> 00:09:57,521
So let's go ahead and start. Let's start with

00:09:57,521 --> 00:10:00,550
the first example. And this is talking about dependencies

00:10:00,550 --> 00:10:02,059
in my software. I think this is one of

00:10:02,060 --> 00:10:04,191
the strongest features of UML is to get a

00:10:04,200 --> 00:10:10,129
broad overview of what your code depends on.

00:10:10,129 --> 00:10:11,240
Before we do that, I got to build up

00:10:11,240 --> 00:10:14,060
the vocabulary of the diagram so you know what

00:10:14,060 --> 00:10:15,481
I'm talk about.

00:10:15,481 --> 00:10:19,639
First of call, if you have a class in

00:10:19,640 --> 00:10:22,290
Ruby, such as a Car class, you can represent

00:10:22,300 --> 00:10:24,480
it as a diagram. It's just a simple box

00:10:24,480 --> 00:10:26,420
with the name of the class right in here.

00:10:26,420 --> 00:10:29,390
This represents this bit of code right here.

00:10:29,390 --> 00:10:30,840
If you wish to get more detailed and you

00:10:30,840 --> 00:10:33,260
wish to include the methods in it, you can

00:10:33,280 --> 00:10:35,769
add a second box. Divide your box in too.

00:10:35,769 --> 00:10:38,401
The name goes on the top and the methods

00:10:38,401 --> 00:10:40,790
go down here into this second box. So you

00:10:40,790 --> 00:10:44,799
talk about particular methods on that particular class.

00:10:44,800 --> 00:10:47,471
And like I said, UML, a sketch means that

00:10:47,480 --> 00:10:49,259
you include the methods that you wish to talk

00:10:49,260 --> 00:10:52,781
about right now. You don't include every single method.

00:10:52,781 --> 00:10:55,059
You just include what's important to the idea that

00:10:55,060 --> 00:10:57,771
you wish to convey in that particular diagram.

00:10:57,780 --> 00:11:01,090
If you want to get even more detailed, and

00:11:01,090 --> 00:11:03,759
I rarely do this, is that if there are

00:11:03,760 --> 00:11:06,310
internal attributes, you can list them in a third

00:11:06,310 --> 00:11:09,401
box that goes between the name and above, below

00:11:09,401 --> 00:11:12,080
the name and above the actual methods.

00:11:12,080 --> 00:11:15,780
I, like I said, I rarely go to the

00:11:15,780 --> 00:11:17,700
attribute level.

00:11:17,700 --> 00:11:20,170
If one class uses another class, and you can

00:11:20,180 --> 00:11:21,930
always tell it uses it because it will reference

00:11:21,930 --> 00:11:25,980
the class by name, here, if so, then you

00:11:25,980 --> 00:11:29,880
could create a dependency between this class and that

00:11:29,880 --> 00:11:32,350
class. The direction of the array goes in the

00:11:32,360 --> 00:11:35,020
direction of the dependency, and this is always, always,

00:11:35,020 --> 00:11:38,840
always true in UML. Whenever you draw an arrow,

00:11:38,840 --> 00:11:40,360
it means it's a dependency, and it goes in

00:11:40,360 --> 00:11:43,450
the direction of the thing that's doing the depending

00:11:43,460 --> 00:11:46,770
towards the thing that it is being depended on.

00:11:46,770 --> 00:11:49,280
This means that if I use an Engine object,

00:11:49,280 --> 00:11:51,530
I can use it independently. But if ever I

00:11:51,540 --> 00:11:54,200
used a car object, I also need to drag

00:11:54,200 --> 00:11:57,410
in an engine object along with it. And we

00:11:57,410 --> 00:11:59,710
can see that because, man, we're referencing Engine right

00:11:59,720 --> 00:12:02,950
here in the code base. That's a dependency, and

00:12:02,950 --> 00:12:05,970
UML is great for capturing these dependencies.

00:12:05,980 --> 00:12:09,900
Here's a dependency for cars also using wheel, and

00:12:09,900 --> 00:12:11,770
you can say on your dependency line, you can

00:12:11,770 --> 00:12:16,460
say one car has many wheels. In this case,

00:12:16,460 --> 00:12:18,780
four wheels. You could put a four here for

00:12:18,780 --> 00:12:20,730
the star, or you could just say star, it

00:12:20,740 --> 00:12:22,369
says x, one to many. So it's kind of

00:12:22,369 --> 00:12:25,050
a one to many relationship right there. Again. Dependency

00:12:25,060 --> 00:12:29,021
goes from Car to Wheel.

00:12:29,021 --> 00:12:32,910
If you inherit, the inheritance relationship is also an

00:12:32,910 --> 00:12:36,220
arrow. This arrow is an open triangle pointing from

00:12:36,220 --> 00:12:38,929
the subclass to the superclass. So, again, I can

00:12:38,940 --> 00:12:40,901
use car by itself, but if I want to

00:12:40,901 --> 00:12:43,950
use a SportsCar class, I get Car automatically because

00:12:43,950 --> 00:12:48,850
it's dragged in by that dependency.

00:12:48,850 --> 00:12:53,220
Ruby has modules. And this is how I designate

00:12:53,240 --> 00:12:56,860
modules in a UML diagram when I'm using, talking

00:12:56,860 --> 00:13:00,210
about Ruby, is essentially the same as a class,

00:13:00,210 --> 00:13:04,730
but I put this, it's called a stereotype. I

00:13:04,740 --> 00:13:08,499
say it's a module in this, I use angle

00:13:08,500 --> 00:13:11,130
brackets, but what they really should be are French

00:13:11,130 --> 00:13:15,550
quotes, which I cannot pronounce the real name for.

00:13:15,560 --> 00:13:17,940
But that's a stereotype right there, and that says

00:13:17,940 --> 00:13:19,521
it's, it's kind of like a class but it

00:13:19,521 --> 00:13:22,150
has these special properties and it's a module. And

00:13:22,150 --> 00:13:23,559
if you're doing Ruby programming, you know what a

00:13:23,560 --> 00:13:25,791
module is. And that's all it's telling you, that

00:13:25,800 --> 00:13:27,439
Driveable is a module.

00:13:27,440 --> 00:13:31,601
I use the same arrow to indicate include as

00:13:31,601 --> 00:13:35,790
inheritance here, because essentially it's the same relationship. The

00:13:35,790 --> 00:13:39,100
difference between inheritance and including a module in Ruby

00:13:39,100 --> 00:13:42,739
is very subtle and I don't really call out

00:13:42,740 --> 00:13:47,031
the difference in a UML diagram because of that.

00:13:47,040 --> 00:13:50,629
OK. So there's one more thing I want to

00:13:50,629 --> 00:13:56,810
show you and this is really important. Here, Car

00:13:56,820 --> 00:14:02,060
is being passed an Engine object. And so there

00:14:02,060 --> 00:14:04,521
is no longer a direct reference to the Engine

00:14:04,521 --> 00:14:09,200
class inside my Car class anymore. So Car no

00:14:09,200 --> 00:14:13,189
longer depends upon the Engine class, but it does

00:14:13,189 --> 00:14:16,990
depend upon some kind of object that behaves like

00:14:17,020 --> 00:14:18,181
an Engine does.

00:14:18,181 --> 00:14:21,779
In other words it does, it's duck-typed to an

00:14:21,780 --> 00:14:25,520
Engine. I capture this in U- in Java. If

00:14:25,520 --> 00:14:27,381
you're doing this in Java, this would be an

00:14:27,381 --> 00:14:29,959
interface. And you have to actually write code that

00:14:29,960 --> 00:14:32,171
had the start and stop method on it and

00:14:32,171 --> 00:14:34,660
say this is an interface and that the Engine

00:14:34,660 --> 00:14:38,540
implements the interface. In Ruby, the stuff for this

00:14:38,540 --> 00:14:41,410
thing right here doesn't exist. There is no source

00:14:41,410 --> 00:14:43,939
code for this box right here. But it's an

00:14:43,940 --> 00:14:47,111
important concept, which you need to capture and be

00:14:47,120 --> 00:14:49,100
able to talk about.

00:14:49,100 --> 00:14:51,280
Car does not depend upon Engine, but it does

00:14:51,280 --> 00:14:55,000
depend upon an object that obeys this protocol, this

00:14:55,000 --> 00:14:59,900
start and stop method on it.

00:14:59,900 --> 00:15:02,900
Engine implements that protocol. So it gets, it's kind

00:15:02,900 --> 00:15:05,170
of like the inheritance line, but dotted instead of

00:15:05,170 --> 00:15:08,129
solid. And so I'm saying Engine implements this car

00:15:08,129 --> 00:15:11,891
independence- uses it, Car does not depend upon Engine.

00:15:11,900 --> 00:15:13,770
That means if I want to test a Car,

00:15:13,770 --> 00:15:16,499
I can just drop anything in that acts sufficiently

00:15:16,500 --> 00:15:19,511
like a Car- or, sufficiently like an Engine for

00:15:19,520 --> 00:15:22,480
my testing, and I can test Car without having

00:15:22,480 --> 00:15:24,090
an Engine available at all.

00:15:24,090 --> 00:15:26,930
And this is an important concept in drawing these

00:15:26,930 --> 00:15:30,110
dependency diagrams is to recognize that, hey, that dependency

00:15:30,140 --> 00:15:32,249
no longer goes all the way to Engine, but

00:15:32,249 --> 00:15:34,152
is just using a protocol at that point.

00:15:34,160 --> 00:15:37,939
All right. So now we got some basic vocabulary

00:15:37,940 --> 00:15:43,100
to talk about dependencies in our programs.

00:15:43,100 --> 00:15:46,499
So this is a pretty standard Rails application right

00:15:46,500 --> 00:15:49,851
here. This is actually an implementation of the pay

00:15:49,860 --> 00:15:55,559
employee problem that is common in literature. You probably

00:15:55,560 --> 00:15:58,060
run into it. You have three kinds of employees.

00:15:58,060 --> 00:16:00,151
Hourly, salaried, and commissioned.

00:16:00,160 --> 00:16:02,980
Hourly employees are paid according to the time cards

00:16:02,980 --> 00:16:05,949
they turn in. Salaried employees are paid a yearly

00:16:05,949 --> 00:16:08,701
salary, paid once a month. So they get one

00:16:08,701 --> 00:16:11,330
twelfth of their annual salary once a month. Commissioned

00:16:11,330 --> 00:16:14,190
employees get a salary plus a commission based upon

00:16:14,200 --> 00:16:16,210
the sales receipts that they turn in. So there's

00:16:16,210 --> 00:16:20,580
three different ways of calculating their pay check.

00:16:20,580 --> 00:16:22,890
Here, what's important to notice, is that in this

00:16:22,900 --> 00:16:27,600
Rails version of this solution, we have an employee

00:16:27,600 --> 00:16:31,429
controller. It inherits from application controller, which inherits from

00:16:31,429 --> 00:16:34,521
action, action controller base.

00:16:34,521 --> 00:16:39,010
The red classes are Rails classes. They are part

00:16:39,020 --> 00:16:42,770
of Rails. The pink classes are our application classes

00:16:42,770 --> 00:16:45,840
that depend upon Rails. So, if I want to

00:16:45,840 --> 00:16:48,739
test my employee controller, I've gotta bring in Rails

00:16:48,740 --> 00:16:50,060
to do it. If I want to test my

00:16:50,060 --> 00:16:53,321
employee object, I gotta bring in ActiveRecord to do

00:16:53,321 --> 00:16:54,440
that testing.

00:16:54,440 --> 00:16:58,200
So they are dependent upon the framework. However, the

00:16:58,200 --> 00:17:01,130
way I chose to implement the salary calculation was

00:17:01,140 --> 00:17:05,350
as a set of strategies that the employee picks

00:17:05,350 --> 00:17:08,340
a strategy based upon what type of employee he

00:17:08,340 --> 00:17:11,679
is and then just calls the strategy. Hourly paycheck,

00:17:11,680 --> 00:17:15,300
salaried paycheck, commissioned paycheck, with all implement the protocol

00:17:15,300 --> 00:17:18,821
that includes calculating pay amount and gets passed in

00:17:18,821 --> 00:17:20,039
an employee object.

00:17:20,040 --> 00:17:23,251
There is nothing in these guys that directly reference

00:17:23,260 --> 00:17:26,600
the employee class. They just depend upon something that

00:17:26,600 --> 00:17:30,350
acts like an employee. That means these guys can

00:17:30,350 --> 00:17:32,960
be tested very simply by - like, if I

00:17:32,960 --> 00:17:35,389
want to test Salaried Paycheck, I just need to

00:17:35,400 --> 00:17:38,241
pass in an object that has an annual salary

00:17:38,241 --> 00:17:41,070
field on it and I can test that without

00:17:41,070 --> 00:17:43,420
loading Rails at all. That's why they are green.

00:17:43,420 --> 00:17:45,639
These can be tested, the green things can be

00:17:45,640 --> 00:17:47,270
run very quickly and very safely.

00:17:47,280 --> 00:17:50,400
And we can tell that by examining the arrows.

00:17:50,400 --> 00:17:54,131
Notice that in this dotted box here, all of

00:17:54,140 --> 00:17:57,539
the arrows are pointing inwards. There is nothing pointing

00:17:57,540 --> 00:18:01,061
outwards from this box. That means I do not

00:18:01,061 --> 00:18:03,260
depend upon the framework and that tells me I

00:18:03,260 --> 00:18:07,000
can test those very efficiently and very quickly.

00:18:07,000 --> 00:18:09,330
However, if I want to test the employee object

00:18:09,330 --> 00:18:10,990
directly, I've got to load Rails. If I want

00:18:10,990 --> 00:18:13,980
to test controller directly, I've gotta load Rails again.

00:18:13,980 --> 00:18:18,279
I'm teaching a class with Bob Kauss right now,

00:18:18,280 --> 00:18:21,361
on testing in Rails and refactoring in patterns and

00:18:21,361 --> 00:18:23,130
things like this, and we use this example in

00:18:23,140 --> 00:18:26,800
our class.

00:18:26,800 --> 00:18:28,630
One of the things we do is to push

00:18:28,630 --> 00:18:31,649
this system. You see how much we can get

00:18:31,660 --> 00:18:36,441
decoupled from the Rails framework. So we can test

00:18:36,441 --> 00:18:39,850
as much logic as we possibly can without invoking

00:18:39,850 --> 00:18:40,700
Rails.

00:18:40,700 --> 00:18:42,820
One of the techniques we use is, some of

00:18:42,820 --> 00:18:46,320
the techniques from the hexagonal architecture concept Matt Winn

00:18:46,320 --> 00:18:49,180
does, and Kevin Rutheford has done.

00:18:49,180 --> 00:18:51,009
And if you look at that, they have basically

00:18:51,009 --> 00:18:58,949
take this approach. And this concentrates on the controller

00:18:58,949 --> 00:19:02,070
now. They take the employee controller, and they say

00:19:02,070 --> 00:19:05,130
some of the logic in the controller is Rails

00:19:05,130 --> 00:19:08,730
dependent. Things that say redirect to this URL. Render

00:19:08,740 --> 00:19:13,620
this template. Here is the params hash. Those are

00:19:13,620 --> 00:19:15,420
our Rails things.

00:19:15,420 --> 00:19:19,220
However, some of the logic is really business logic.

00:19:19,220 --> 00:19:22,019
Even in the standard dumb Rails controller, there's still

00:19:22,020 --> 00:19:24,851
business logic in there. How do I create an

00:19:24,860 --> 00:19:27,810
employee object? How do I save an employee object?

00:19:27,810 --> 00:19:30,870
What ha- how do I validate and how do

00:19:30,870 --> 00:19:33,460
I, what, you know, how do I detect whether

00:19:33,460 --> 00:19:37,310
it's saved or not? Validated or not? It's all

00:19:37,320 --> 00:19:38,860
really kind of business logic.

00:19:38,860 --> 00:19:42,740
So they very carefully picked that controller apart into

00:19:42,740 --> 00:19:45,970
two pieces. One piece remains here in the controller.

00:19:45,980 --> 00:19:48,180
The other piece, they pull out and, I'm calling

00:19:48,180 --> 00:19:50,490
it a runner, cause they, they tend to give

00:19:50,490 --> 00:19:54,060
it the method called run. And the run, into

00:19:54,060 --> 00:19:55,670
the run they pass in a couple things.

00:19:55,670 --> 00:19:58,690
They pass in a protocol that is essentially the

00:19:58,700 --> 00:20:02,720
context object, which is the controller. They pan, and

00:20:02,720 --> 00:20:06,810
I have also pulled out a repository object here,

00:20:06,810 --> 00:20:09,470
so all the database related stuff is done through

00:20:09,480 --> 00:20:12,470
a repository. And it's, it's a little tedious but

00:20:12,470 --> 00:20:14,509
it's really not hard, at all. You can almost

00:20:14,520 --> 00:20:18,061
automate that piece very easily.

00:20:18,061 --> 00:20:21,289
So the runner now depends upon something that has

00:20:21,289 --> 00:20:25,121
save and find_employee type methods on it. It depends

00:20:25,121 --> 00:20:28,850
upon some call backs the context provides. But there

00:20:28,860 --> 00:20:32,039
is no direct reference to Rails anywhere in the

00:20:32,040 --> 00:20:33,061
runner anymore.

00:20:33,061 --> 00:20:34,990
That means I can test the business logic in

00:20:35,000 --> 00:20:37,680
here very carefully. Now I've got a whole bunch

00:20:37,680 --> 00:20:41,580
more logic that is totally free from Rails, and

00:20:41,580 --> 00:20:43,850
then I can easily test.

00:20:43,850 --> 00:20:47,060
There's one more stage I like to do, and

00:20:47,080 --> 00:20:48,890
this - I'd like to get most of the

00:20:48,890 --> 00:20:51,930
business logic in here free from Rails as well.

00:20:51,930 --> 00:20:57,220
There's many ways to do this. Here's one.

00:20:57,220 --> 00:21:01,450
Let's treat employee, the ActiveRecord employee object, as a

00:21:01,450 --> 00:21:05,259
dumb data holder. I'd, I'm gonna let three things

00:21:05,260 --> 00:21:09,311
go in there. Number one, I let database fields

00:21:09,320 --> 00:21:12,080
be in that object. I let relationships be in

00:21:12,080 --> 00:21:14,519
that object, cause Rails is really good at defining

00:21:14,520 --> 00:21:16,931
relationships. Doesn't make sense to pull those out.

00:21:16,940 --> 00:21:20,279
Likewise, validations are in that object. You can make

00:21:20,280 --> 00:21:22,300
an argument, you could pull validations out - yeah,

00:21:22,300 --> 00:21:24,731
OK, you can do that too. I tend to

00:21:24,740 --> 00:21:25,820
leave them in.

00:21:25,820 --> 00:21:28,010
So it tends to be dumb, without any business

00:21:28,010 --> 00:21:33,330
logic in it. Then I create a business employee

00:21:33,330 --> 00:21:36,060
object. I usually just namespace that, put it in

00:21:36,060 --> 00:21:40,010
a module called biz or whatever. And then key

00:21:40,010 --> 00:21:44,420
proxies to the employee object and all he needs

00:21:44,420 --> 00:21:46,810
to do is assume that he has an object

00:21:46,820 --> 00:21:50,580
that supports the dumb data portions of employee.

00:21:50,580 --> 00:21:53,840
That means he knows about the employee name. He

00:21:53,840 --> 00:21:56,800
knows about the annual salary. But that's all. There's

00:21:56,800 --> 00:22:00,130
no business logic in here, or represented by this

00:22:00,130 --> 00:22:04,500
protocol at all. Now my whole application can use

00:22:04,500 --> 00:22:08,060
this business employee as if it were the ActiveRecord

00:22:08,060 --> 00:22:11,450
object. But he himself doesn't actually depend upon ActiveRecord,

00:22:11,460 --> 00:22:14,960
he just depends upon the protocol for dumb data.

00:22:14,960 --> 00:22:17,789
This is pretty easy actually.

00:22:17,789 --> 00:22:23,280
And now, with that, the whole thing here actually

00:22:23,280 --> 00:22:26,701
my entire application is now inside the red box.

00:22:26,720 --> 00:22:30,130
I can test stories here at this level, cause

00:22:30,130 --> 00:22:34,510
the, you know the, create a employee stories is

00:22:34,510 --> 00:22:39,290
actually implemented by this code here. The employee specific

00:22:39,300 --> 00:22:41,630
business is in here, and all I have to

00:22:41,630 --> 00:22:43,310
do, you know, so I can test all of

00:22:43,320 --> 00:22:46,370
this very easily. I can actually run unit tests

00:22:46,370 --> 00:22:47,879
at this level.

00:22:47,880 --> 00:22:49,431
If I want to, I can go ahead include

00:22:49,460 --> 00:22:52,330
the ActiveRecord part of this, and do story-level testing

00:22:52,330 --> 00:22:55,049
all the way to the database without going through

00:22:55,049 --> 00:22:57,851
the web interface, cause I'm hitting this guy right

00:22:57,860 --> 00:23:01,240
here. And then I can do just a little-

00:23:01,240 --> 00:23:02,820
the only thing outside the box is now is

00:23:02,820 --> 00:23:04,430
just a little bit of wiring that happens in

00:23:04,430 --> 00:23:07,399
the controller. I can easily test that at a

00:23:07,400 --> 00:23:09,640
integration level test by hitting the web UI.

00:23:09,660 --> 00:23:12,981
So my web UI testing is light-weight and small

00:23:12,981 --> 00:23:15,000
and just enough to make sure the connections are

00:23:15,000 --> 00:23:17,850
made. My story-level testing gets here and can go

00:23:17,850 --> 00:23:20,200
all the way to the database. And then my

00:23:20,200 --> 00:23:22,470
unit tests - excuse me, my unit tests are

00:23:22,480 --> 00:23:24,590
this level here, and they can be fast and

00:23:24,590 --> 00:23:26,990
very fine-grained and have a lot of them to

00:23:26,990 --> 00:23:28,529
really exercise the logic.

00:23:28,529 --> 00:23:31,581
I think that's a good division of labor between

00:23:31,581 --> 00:23:34,090
your tests. And I really like the architecture that

00:23:34,100 --> 00:23:36,670
I've been experimenting here with this idea. But notice

00:23:36,670 --> 00:23:39,540
how the diagram tells you all that information. I

00:23:39,540 --> 00:23:41,410
can look at this diagram. I can tell, here

00:23:41,410 --> 00:23:42,879
are the arrows, and this is the direction they

00:23:42,900 --> 00:23:45,491
poi- are pointing and this green stuff has no

00:23:45,500 --> 00:23:48,850
arrows leaving it, going after any of my ActiveRecord

00:23:48,850 --> 00:23:49,190
stuff.

00:23:49,190 --> 00:23:53,690
So the diagram really helps convey that information without

00:23:53,700 --> 00:23:55,320
me going through and showing you a lot of

00:23:55,320 --> 00:23:57,610
code, code, code.

00:23:57,620 --> 00:24:02,590
OK. Next example, let's talk about structure.

00:24:02,590 --> 00:24:05,320
Excuse me.

00:24:05,320 --> 00:24:11,590
This is a diagram I drew based on Rake.

00:24:11,600 --> 00:24:14,019
I was actually rather surprised when I got done

00:24:14,020 --> 00:24:17,181
with this thing, diagram. This had, has very little

00:24:17,181 --> 00:24:20,629
mapping in, in how my mind thinks about Rake.

00:24:20,640 --> 00:24:23,899
So the diagram, to me, was very interesting.

00:24:23,900 --> 00:24:25,721
First of all, the first thing that kind came

00:24:25,721 --> 00:24:27,380
out to me is that Rake has a lot

00:24:27,380 --> 00:24:31,649
of large classes with lots of methods on it.

00:24:31,649 --> 00:24:34,381
So few classes, but the classes have lots of

00:24:34,381 --> 00:24:35,649
meth- and you don't see all the methods here

00:24:35,649 --> 00:24:39,390
because this is sketch. And I omitted the methods

00:24:39,420 --> 00:24:41,081
I wasn't interested in showing.

00:24:41,081 --> 00:24:43,830
But as I was going through the diagram, I

00:24:43,830 --> 00:24:47,279
saw, oh, this task manager's got a bazillion methods

00:24:47,280 --> 00:24:51,681
on it. Application has a lot of methods on

00:24:51,681 --> 00:24:54,180
it. Task has a bazillion and a half methods

00:24:54,180 --> 00:24:59,110
on it. They're just not being shown here.

00:24:59,110 --> 00:25:00,450
So that was kind of odd. I was kind

00:25:00,450 --> 00:25:03,320
of surprised by that. The other thing I miss-

00:25:03,320 --> 00:25:06,050
noticed, is there's lots of things in here, domain

00:25:06,060 --> 00:25:08,830
knowledge about Rake that is not represented anywhere by

00:25:08,830 --> 00:25:12,190
a class. This bothers me just a little bit.

00:25:12,200 --> 00:25:14,350
Rake has a concept of rules. There is no

00:25:14,360 --> 00:25:17,310
rules class in Rake at all.

00:25:17,310 --> 00:25:19,649
That's kind of odd.

00:25:19,660 --> 00:25:23,501
Rake also attacks locations where a task is defined

00:25:23,501 --> 00:25:25,010
so you can find it easily in your source

00:25:25,010 --> 00:25:29,110
code. There's no domain object representing locations in Rake.

00:25:29,110 --> 00:25:31,070
And this is kind of bothersome to me as

00:25:31,080 --> 00:25:33,710
well.

00:25:33,710 --> 00:25:35,629
And this one's really odd. So what is happening?

00:25:35,640 --> 00:25:38,760
Your task manager is the guy who contains the

00:25:38,760 --> 00:25:41,400
tasks. And the way Rake is designed, task manager

00:25:41,400 --> 00:25:43,871
is a module that is included into your application

00:25:43,880 --> 00:25:46,789
so your application is the thing that holds the

00:25:46,789 --> 00:25:50,871
tasks. It attracts the current scope. There are name

00:25:50,880 --> 00:25:53,590
spaces in Rake. And that's represented by the scope.

00:25:53,600 --> 00:25:55,330
But I really like this part about, this has

00:25:55,330 --> 00:25:58,180
worked really well here, but it's a little bit

00:25:58,180 --> 00:26:01,010
odd in that, as you read a Rake file,

00:26:01,010 --> 00:26:03,130
the scope is constantly changing, and I'm defining a

00:26:03,130 --> 00:26:05,019
task in this name space, I pop out of

00:26:05,040 --> 00:26:06,831
the name space, and as you're doing it, the

00:26:06,840 --> 00:26:08,480
current scope keeps changing.

00:26:08,480 --> 00:26:10,850
And as you define a task, he gets, he

00:26:10,850 --> 00:26:13,840
grabs whatever current scope the task manager has at

00:26:13,840 --> 00:26:15,980
that point. And that works fairly well, but what

00:26:15,980 --> 00:26:18,700
I end up with is a flat list of

00:26:18,700 --> 00:26:21,110
all the tasks in the system, and there's nothing

00:26:21,110 --> 00:26:24,370
that captures the structure of the name spaces at

00:26:24,380 --> 00:26:26,360
all. And I was kind of surprised by that,

00:26:26,360 --> 00:26:28,110
when I went back and actually looked at how

00:26:28,110 --> 00:26:31,509
I implemented it, it seemed a little bit weird.

00:26:31,509 --> 00:26:34,991
The other weird thing is that file_task essentially ignores

00:26:35,000 --> 00:26:38,509
scope, because they're defining files and files have no

00:26:38,509 --> 00:26:40,571
idea of what the name space are, so they,

00:26:40,600 --> 00:26:43,610
they kind of ignore scope when they're do- being

00:26:43,610 --> 00:26:46,230
defined. So why does file_task inherit from a task

00:26:46,230 --> 00:26:49,470
which has a scope?

00:26:49,470 --> 00:26:51,860
That struck me in, in reading this diagram as

00:26:51,860 --> 00:26:55,019
something a little bit odd. So maybe I should

00:26:55,020 --> 00:27:02,020
rewrite Rake. Version 20, yeah.

00:27:04,120 --> 00:27:05,700
And here's an idea, here's one way I might

00:27:05,700 --> 00:27:08,220
approach it. So this is now UML as a

00:27:08,220 --> 00:27:12,909
sketch, kind of exploring an idea that we could

00:27:12,920 --> 00:27:15,821
go in. So here's your application, but rather than

00:27:15,821 --> 00:27:20,380
inheriting from task manager, make task manager a object

00:27:20,380 --> 00:27:23,080
in and of itself. And task manager is now

00:27:23,080 --> 00:27:27,720
responsible for managing all the tasks in that scope,

00:27:27,720 --> 00:27:29,710
but no other scope.

00:27:29,710 --> 00:27:32,879
The scope object kind of goes away, and rather

00:27:32,880 --> 00:27:34,711
than a linked list, the task manager now becomes

00:27:34,720 --> 00:27:38,110
a tree of name spaces. Now I can represent

00:27:38,110 --> 00:27:40,450
the name space structure of your Rake file explicitly

00:27:40,460 --> 00:27:42,480
in my code base. Seems to me that would

00:27:42,480 --> 00:27:46,210
be a good thing.

00:27:46,210 --> 00:27:47,789
Tasks still have - and this is mis-labeled, this

00:27:47,789 --> 00:27:51,051
should say scope right here. That's another problem with

00:27:51,060 --> 00:27:56,690
UML. It doesn't always accurately reflect your code base.

00:27:56,690 --> 00:27:58,999
I would, this would actually be scope not task.

00:27:59,000 --> 00:28:01,870
But there would have one task would point to

00:28:01,870 --> 00:28:06,311
a particular scope. Task manager would have many tasks.

00:28:06,320 --> 00:28:09,210
And then task and rule and file_task would all

00:28:09,220 --> 00:28:13,009
implement some kind of task protocol that's there.

00:28:13,009 --> 00:28:14,890
And I think that might be an interesting way

00:28:14,900 --> 00:28:16,760
to go. It might be worth exploring through. The

00:28:16,780 --> 00:28:19,441
problem, of course, is Rake is a well-defined application

00:28:19,441 --> 00:28:21,760
and if I change the internal structure too much

00:28:21,760 --> 00:28:24,510
I might break somebody's code, so. Gotta treat this

00:28:24,510 --> 00:28:25,620
with care.

00:28:25,620 --> 00:28:29,360
But here's an idea of a direction to go.

00:28:29,360 --> 00:28:33,600
So, so how am I representing scopes now in

00:28:33,600 --> 00:28:36,350
here? So I gotta give you some new vocabulary.

00:28:36,350 --> 00:28:39,509
So now, let's talk about objects rather than classes,

00:28:39,509 --> 00:28:42,071
we'll talk about objects. So here is a Car

00:28:42,100 --> 00:28:44,909
object, my car, and we can represent that in

00:28:44,909 --> 00:28:48,261
UML as my_car colon Car, and we underline the

00:28:48,261 --> 00:28:49,620
whole thing. And it looks a lot like a

00:28:49,620 --> 00:28:52,340
class box except it's got an underline thing in

00:28:52,340 --> 00:28:56,570
it that means it's an object, not a class.

00:28:56,570 --> 00:28:57,930
If we don't care what the thing is called,

00:28:57,930 --> 00:28:59,869
we can leave off the name. If we don't

00:28:59,880 --> 00:29:01,451
care what class it is and we just want

00:29:01,460 --> 00:29:03,409
to talk about this object with this name, we

00:29:03,420 --> 00:29:06,001
can leave off the colon and the class name.

00:29:06,001 --> 00:29:07,809
So either way works. Any three of these are

00:29:07,809 --> 00:29:09,390
valid.

00:29:09,390 --> 00:29:12,410
So here is a car with an engine and

00:29:12,410 --> 00:29:18,561
four wheels. So this object diagram, so, so a

00:29:18,561 --> 00:29:22,950
class captures kind of a static nature of the

00:29:22,950 --> 00:29:27,129
class relationship. An object diagram captures a snapshot in

00:29:27,160 --> 00:29:30,040
time of an object and what it has. At

00:29:30,040 --> 00:29:33,181
this point in time, this car has an engine

00:29:33,181 --> 00:29:35,169
and a wheel.

00:29:35,169 --> 00:29:36,701
If I leave it out on the street and

00:29:36,701 --> 00:29:40,769
somewhere steels the hu- the wheels off of it

00:29:40,769 --> 00:29:42,711
and all of the sudden it's got less wheels.

00:29:42,720 --> 00:29:44,550
So that would be a different snapshot in time.

00:29:44,550 --> 00:29:46,930
Or someone takes out the engine and replaces the

00:29:46,940 --> 00:29:49,029
engine. Well that would be a different snapshot.

00:29:49,029 --> 00:29:51,760
So an object diagram captures, this is how your

00:29:51,760 --> 00:29:55,611
objects look right now at this point in time.

00:29:55,620 --> 00:29:58,019
So this is how Rake might look at a

00:29:58,020 --> 00:30:02,201
point in time. Here we have a top-level task

00:30:02,201 --> 00:30:05,740
manager name space and we have a test name

00:30:05,760 --> 00:30:08,159
space here and he has a task called units,

00:30:08,160 --> 00:30:11,550
so test colon units would be the name of

00:30:11,550 --> 00:30:15,550
this task. DB test prepare would be the name

00:30:15,550 --> 00:30:18,530
of this task. DB migrate would be the name

00:30:18,530 --> 00:30:19,681
of this task.

00:30:19,681 --> 00:30:22,420
So I'm representing the scopes and the name spaces

00:30:22,420 --> 00:30:25,009
of Rake in a data structure inside of Rake

00:30:25,020 --> 00:30:28,780
as well. So object diagram can capture that kind

00:30:28,780 --> 00:30:31,561
of snapshot idea of your program. And I really

00:30:31,561 --> 00:30:34,050
like that. OK.

00:30:34,050 --> 00:30:39,739
Let's talk about creation of objects.

00:30:42,240 --> 00:30:44,840
I have a goal this year to talk about

00:30:44,880 --> 00:30:51,100
flying robots in every single talk I give. I-

00:30:51,100 --> 00:30:55,500
Thank you. Thank you. I think I've only missed

00:30:55,500 --> 00:30:56,970
on talk so far, and I slipped it kind

00:30:56,970 --> 00:30:58,509
of in in the comments so then at the

00:30:58,509 --> 00:30:58,780
end.

00:30:58,780 --> 00:31:01,490
So here. So let's talk about the flying robot

00:31:01,500 --> 00:31:03,410
that we're playing with back in the office. This

00:31:03,410 --> 00:31:06,181
is a parrot AR drone. It's a quadacopter. It

00:31:06,181 --> 00:31:09,160
has two cameras on it. It runs Linux on

00:31:09,160 --> 00:31:12,259
the copter itself. And it talks to your laptop

00:31:12,260 --> 00:31:14,671
via wifi.

00:31:14,680 --> 00:31:18,529
I have written a library called Argus that you

00:31:18,529 --> 00:31:21,181
can use to control an AR drone. And here's

00:31:21,181 --> 00:31:23,470
a simple program where we create a drone, we

00:31:23,480 --> 00:31:26,800
tell it to start, all its subprocesses up. We

00:31:26,800 --> 00:31:28,610
tell the drone to take off, tell it to

00:31:28,610 --> 00:31:32,410
turn right, turn left, hover, and then land, and

00:31:32,420 --> 00:31:33,550
then shut down.

00:31:33,560 --> 00:31:38,830
So let's see if that program works. K. Take

00:31:38,830 --> 00:31:43,710
off. Turn right. I think I actually turn right

00:31:43,710 --> 00:31:50,700
for five seconds instead of two. Turn left. Hover

00:31:50,820 --> 00:31:52,009
and then land.

00:31:52,020 --> 00:31:55,030
OK. So cool. So that's, that's, that's all controlled

00:31:55,040 --> 00:31:58,481
by Ruby.

00:31:58,481 --> 00:32:03,440
A good way to talk about the Argus library

00:32:03,440 --> 00:32:05,789
is to use an Argus diagram. I can show

00:32:05,789 --> 00:32:07,451
you this diagram and I can talk about the

00:32:07,460 --> 00:32:11,560
pieces of this architecture and how, what the responsibilities

00:32:11,560 --> 00:32:14,380
for each piece is. The drone object is the

00:32:14,380 --> 00:32:16,730
drone that the application plays with. It is the

00:32:16,740 --> 00:32:20,049
front facing object that you send all your commands

00:32:20,049 --> 00:32:22,471
to. You don't have to worry about anything behind

00:32:22,480 --> 00:32:23,899
the drone.

00:32:23,900 --> 00:32:28,831
The controller is responsible for, for translating these high-level

00:32:28,831 --> 00:32:30,960
commands like go up, go down, turn left, turn

00:32:30,960 --> 00:32:35,419
right, into lower-level drone commands. And then taking those

00:32:35,420 --> 00:32:37,650
commands and then calling the right commands on the

00:32:37,650 --> 00:32:43,171
AT commander. AT, AT because every command on the

00:32:43,180 --> 00:32:45,860
drone begins with the letters AT. It's like the

00:32:45,860 --> 00:32:48,220
guy who wrote this protocol was really hung out

00:32:48,220 --> 00:32:50,930
up on the haze modem protocol.

00:32:50,930 --> 00:32:56,080
It's AT star, the name of the command, and

00:32:56,080 --> 00:32:59,720
then strings after that, yeah. So, so the high-level

00:32:59,720 --> 00:33:02,480
commands here, like turn left, get turned into a

00:33:02,480 --> 00:33:05,129
progress command, a key command here, with a particular

00:33:05,129 --> 00:33:08,780
amount of data. This class is responsible for generating

00:33:08,780 --> 00:33:12,291
the stream of text messages that get sent to

00:33:12,300 --> 00:33:15,100
the drone and then the UDP sender class is

00:33:15,100 --> 00:33:18,899
responsible for actually sending this packet over the wire.

00:33:18,900 --> 00:33:21,101
So it's very clear division of responsibility. I really

00:33:21,120 --> 00:33:22,789
like this design.

00:33:22,789 --> 00:33:25,260
On this side we have a nav naviga- nav

00:33:25,260 --> 00:33:28,621
monitor, which monitors the navigation coming back from the

00:33:28,621 --> 00:33:31,889
drone. So it watches for commands like saying, OK,

00:33:31,889 --> 00:33:34,321
I am now this high. Oh, my battery is

00:33:34,321 --> 00:33:36,279
running out, somebody do something, you know, a little

00:33:36,300 --> 00:33:39,300
messages like that come back over the navigation data

00:33:39,300 --> 00:33:42,410
stream. And then the nav streamer is responsible for

00:33:42,410 --> 00:33:45,780
handing timeout issues on that navigation stream.

00:33:45,780 --> 00:33:48,381
We'll get more on the nav streamer here in

00:33:48,381 --> 00:33:49,070
a moment.

00:33:49,070 --> 00:33:53,330
But this is an object diagram. So I thought

00:33:53,330 --> 00:33:54,749
it would be interesting to look at the class

00:33:54,760 --> 00:33:59,270
diagram for this, and it looks like this.

00:33:59,270 --> 00:34:02,711
We can still see the seven objects listed here,

00:34:02,720 --> 00:34:05,340
but now we're showing them at a protocol level.

00:34:05,340 --> 00:34:09,330
Protocol's the implement. So the drone uses, assumes something

00:34:09,330 --> 00:34:15,559
with this protocol. The controller implements the protocol. The

00:34:15,580 --> 00:34:20,501
drone also then uses a AT commander protocol, which

00:34:20,501 --> 00:34:22,050
the controller also uses.

00:34:22,050 --> 00:34:24,980
The nav monitor uses this protocol and so on

00:34:24,980 --> 00:34:26,849
and so forth. And so this is really nice.

00:34:26,880 --> 00:34:28,551
This seems I can test each of these concrete

00:34:28,551 --> 00:34:32,589
classes very easily, despite providing something that responds to

00:34:32,589 --> 00:34:34,431
the protocol, and they can all be tested independently.

00:34:34,440 --> 00:34:37,540
It's a little weird, though, looking at this diagram,

00:34:37,540 --> 00:34:39,649
because I have these objects hanging out here that

00:34:39,649 --> 00:34:43,541
nothing connects to. And so this diagram lies just

00:34:43,541 --> 00:34:46,690
a little bit. What's really going on is that

00:34:46,690 --> 00:34:48,609
I have code that looks like this in the

00:34:48,609 --> 00:34:55,191
drone. It says, OK, create these concrete objects here,

00:34:55,200 --> 00:34:56,970
unless you override it with something. So I can

00:34:56,980 --> 00:34:59,860
override any of the concrete implementations very easily. So

00:34:59,860 --> 00:35:02,720
it's a really cheap kind of dependency injection technique

00:35:02,720 --> 00:35:05,040
that you can use in Ruby.

00:35:05,040 --> 00:35:07,130
So that makes it easier to test, but makes

00:35:07,130 --> 00:35:08,540
it so that if I just use it by

00:35:08,540 --> 00:35:11,819
default, the right things get built up and used.

00:35:11,820 --> 00:35:14,851
So let's go ahead and draw these relationships in

00:35:14,860 --> 00:35:17,309
and let's mark it with a style that says

00:35:17,309 --> 00:35:20,211
create, and I'm gonna, I'm gonna do these lines

00:35:20,220 --> 00:35:22,640
in red so we can see them. So the

00:35:22,660 --> 00:35:25,490
drone will create the monitor, will create the controller.

00:35:25,490 --> 00:35:28,150
It'll create the AT sender. Now everything is attached

00:35:28,220 --> 00:35:29,540
by lines.

00:35:29,540 --> 00:35:35,849
Notice anything really unusual in this diagram?

00:35:35,849 --> 00:35:38,840
The drone does almost all the creation, but almost

00:35:38,840 --> 00:35:41,151
all the creation, except for this guy right down

00:35:41,160 --> 00:35:43,920
here. And for some reason nav monitor thought it

00:35:43,920 --> 00:35:46,920
was his responsibility to create the nav streamer down

00:35:46,920 --> 00:35:51,430
here. I'm not sure why.

00:35:51,430 --> 00:35:54,660
And it wasn't apparent to me, looking at the

00:35:54,660 --> 00:35:56,250
code, this did not stand out to me looking

00:35:56,250 --> 00:35:57,650
at the code, until I kind of drew the

00:35:57,650 --> 00:36:00,980
diagram and saw the create lines pop up here

00:36:00,980 --> 00:36:03,150
that was different from all of the others. So

00:36:03,160 --> 00:36:05,510
again, the diagram helped me see things that I

00:36:05,520 --> 00:36:10,700
did not see in the code itself.

00:36:10,700 --> 00:36:16,700
I think, I want talk about that nav streamer

00:36:16,700 --> 00:36:18,790
thing that handles time outs. but then to do

00:36:18,790 --> 00:36:20,620
that we need to be able to talk about

00:36:20,620 --> 00:36:25,270
dynamic behavior. So here is a UML diagram that's

00:36:25,280 --> 00:36:26,890
different than we've seen before. This is a state

00:36:26,900 --> 00:36:32,490
diagram and essentially says this class here, this toggle

00:36:32,520 --> 00:36:36,530
class has two states, on and off, ands when,

00:36:36,530 --> 00:36:38,170
OK so you start in the off state so

00:36:38,240 --> 00:36:42,030
the black dot indicates where you start.

00:36:42,030 --> 00:36:44,480
The arrows are transition from state to state and

00:36:44,480 --> 00:36:47,720
the transition happens when you hit a trigger. The

00:36:47,720 --> 00:36:50,410
trigger here is called button push and we implement

00:36:50,410 --> 00:36:54,190
triggers as methods on objects. When you're in the

00:36:54,190 --> 00:36:56,319
off state and you hit a button, then the

00:36:56,320 --> 00:36:59,381
action you want to take is called turn on.

00:36:59,400 --> 00:37:02,930
So the trigger happens, button, you look at your

00:37:02,930 --> 00:37:04,890
state you say oh we're off, then we want

00:37:04,890 --> 00:37:08,930
to turn ourselves on then we switch the state

00:37:08,930 --> 00:37:11,390
to being on as well. So thats the next

00:37:11,420 --> 00:37:12,400
state there.

00:37:12,400 --> 00:37:14,280
So you can look at this, this is a

00:37:14,280 --> 00:37:19,050
pretty simple state implementation here, but looking at the

00:37:19,050 --> 00:37:26,040
diagram here gives you a lot more information. OK,

00:37:26,160 --> 00:37:27,550
here is another one, I just wanted to show

00:37:27,550 --> 00:37:29,880
this, this is a recognizer for an imager, you

00:37:29,880 --> 00:37:31,510
start here on the empty state if you get

00:37:31,520 --> 00:37:34,390
a digit, then you're good as you move to

00:37:34,390 --> 00:37:36,270
the integer state as long as you keep getting

00:37:36,280 --> 00:37:39,500
in digits you get that. If you get non-digit

00:37:39,520 --> 00:37:41,060
then you say, oh yep, we're done, we got

00:37:41,060 --> 00:37:43,960
our integer. It's just a little recognizer here. The

00:37:43,960 --> 00:37:46,410
dot with the circle is the stop state.

00:37:46,410 --> 00:37:50,150
So let's talk about the nav streamer now. Nav

00:37:50,150 --> 00:37:54,319
streamer is responsible for handling time outs. This is

00:37:54,320 --> 00:37:56,361
how it works: we start up, we go into

00:37:56,361 --> 00:38:01,660
the wait state. In the wait state everything, unless

00:38:01,680 --> 00:38:03,680
the thing we expect to get is a start

00:38:03,680 --> 00:38:06,859
command. The start will issue a reconnect that will

00:38:06,860 --> 00:38:11,870
essentially go out and create a UDP socket and

00:38:11,870 --> 00:38:16,641
will start listening on it right away. It also

00:38:16,660 --> 00:38:19,560
requests the nav data as well. Going to a

00:38:19,560 --> 00:38:22,180
wait state and as soon as we receive data,

00:38:22,180 --> 00:38:24,700
we go into a run-state. This is the expected

00:38:24,700 --> 00:38:27,220
place to be in. If we time out during

00:38:27,220 --> 00:38:29,810
the run state, either with a short time out,

00:38:29,820 --> 00:38:31,140
we ignore it.

00:38:31,140 --> 00:38:32,790
We receive data in the run state. We stay

00:38:32,790 --> 00:38:33,760
in the run state. But if we get a

00:38:33,760 --> 00:38:37,690
long time out, long time out is, I think

00:38:37,690 --> 00:38:42,270
a second or so. Short time outs are like

00:38:42,270 --> 00:38:44,470
fifty milliseconds, the longer timeouts are like a second.

00:38:44,480 --> 00:38:46,559
So if we get a long time out then

00:38:46,560 --> 00:38:48,771
I need to reconnect, I need to clobber my

00:38:48,780 --> 00:38:53,589
UDP socket object, recreate it, re-request the nav data

00:38:53,589 --> 00:38:55,231
and go back to the wait until I receive

00:38:55,240 --> 00:38:56,630
data again.

00:38:56,630 --> 00:38:58,110
And in the wait state, if I get a

00:38:58,110 --> 00:39:00,440
short out, short time out, I gotta keep requesting

00:39:00,440 --> 00:39:02,690
the nav data because the UDP, it might have

00:39:02,700 --> 00:39:04,720
missed it. I gotta resend it. So this very

00:39:04,720 --> 00:39:10,860
succinctly tells me exactly the algorithm used by the

00:39:10,860 --> 00:39:15,110
time out mechanism in UD... in nav streamer. So,

00:39:15,110 --> 00:39:16,720
I like state diagrams, I think we should use

00:39:16,720 --> 00:39:19,950
more of them.

00:39:19,980 --> 00:39:23,810
Let's see, what are we dong on time here?

00:39:23,810 --> 00:39:27,520
You know what? I'm in trouble because I didn't

00:39:27,520 --> 00:39:31,220
hit the start button on my timer up here.

00:39:31,220 --> 00:39:34,550
So we've got 10 minutes? Thank you. All right,

00:39:34,560 --> 00:39:37,530
interactions. We'll go through this really quick.

00:39:37,530 --> 00:39:41,790
Here's flex-mock, a library I wrote for mocking. It

00:39:41,790 --> 00:39:44,720
contains a mock container. Mock containers are responsible for

00:39:44,740 --> 00:39:47,700
managing mocks within a test. This is the mock

00:39:47,700 --> 00:39:50,530
object right here, so a mock container contain many

00:39:50,530 --> 00:39:55,030
mock objects. The mock object records by method names,

00:39:55,030 --> 00:40:00,130
a set of expectations here, and particular detailed expectations

00:40:00,130 --> 00:40:01,880
here.

00:40:01,880 --> 00:40:04,280
Describing this whole thing here and how these interact

00:40:04,300 --> 00:40:07,150
is very hard to do in words. It's even

00:40:07,160 --> 00:40:09,280
harder to look at the code and figure out

00:40:09,280 --> 00:40:11,560
what's going on, so we need a new vocabulary

00:40:11,560 --> 00:40:15,540
to talk about these. And these are sequence diagrams.

00:40:15,540 --> 00:40:18,260
They're essentially objects here, so it's like a object

00:40:18,260 --> 00:40:21,760
diagram with life times on it. So here in

00:40:21,760 --> 00:40:24,030
this class we call def drive, def drive calls

00:40:24,030 --> 00:40:29,079
go_faster, go_faster calls accelerate.engine. def drive is- so this

00:40:29,080 --> 00:40:30,971
is the method called def drive, this is how

00:40:30,980 --> 00:40:34,280
long its alive. Def drive calls go_faster, so this

00:40:34,280 --> 00:40:37,760
is go_faster right here. Inside of go_faster we call

00:40:37,760 --> 00:40:40,720
accelerte.engine. accelerate.engine returns the result. Returns here, go_faster returns

00:40:40,720 --> 00:40:43,490
to def drive and then def drive returns to

00:40:43,490 --> 00:40:45,829
the bottom here. It's just a sequence of calls

00:40:45,829 --> 00:40:51,050
and kind of timing related. So here is the

00:40:51,050 --> 00:40:53,171
interaction in flux-mock.

00:40:53,180 --> 00:40:59,290
This is, let's walk through this. A mock gets

00:40:59,290 --> 00:41:05,289
a message called foo. That triggers a method, a

00:41:05,300 --> 00:41:08,810
message missing, which goes into here. So this is

00:41:08,810 --> 00:41:12,721
message missing right here. Message missing immediately creates a

00:41:12,721 --> 00:41:15,329
call record to record the fact that foo has

00:41:15,340 --> 00:41:18,001
been called. So we can query it later to

00:41:18,001 --> 00:41:20,809
see what messages have been called, and then goes

00:41:20,809 --> 00:41:24,681
and locates the proper expectation director. That's based upon

00:41:24,681 --> 00:41:26,809
the name foo. So that's just a hash look

00:41:26,820 --> 00:41:27,080
up.

00:41:27,080 --> 00:41:28,641
I didn't record the hash look up in my

00:41:28,641 --> 00:41:31,680
sequence director because the detail I don't want to

00:41:31,680 --> 00:41:34,599
talk about right now. So then we call call

00:41:34,600 --> 00:41:38,671
on the hash expectation director and give in the

00:41:38,680 --> 00:41:43,260
arguments to foo and the call record . So

00:41:43,260 --> 00:41:47,440
then expectation director immediately calls find_expectation on itself, passing

00:41:47,440 --> 00:41:49,589
in the arguments. And then it goes to each

00:41:49,589 --> 00:41:55,291
of the expectations that it's managing and says oh,

00:41:55,300 --> 00:41:57,460
expectation one, do you match the argument that just

00:41:57,540 --> 00:42:01,370
got passed in and expectation one says, nope, false,

00:42:01,370 --> 00:42:01,850
return.

00:42:01,860 --> 00:42:06,070
Director says let's go to expectation two. And do

00:42:06,070 --> 00:42:08,440
we match the arguments for this? And this expectation

00:42:08,440 --> 00:42:11,690
says yes, I expect to be called with no

00:42:11,690 --> 00:42:13,780
arguments, and thats exactly how we're calling foo. So

00:42:13,780 --> 00:42:16,510
yes, I match and I return true and then

00:42:16,510 --> 00:42:18,910
the director says, oh so you match the arguments.

00:42:18,910 --> 00:42:21,420
Now are you eligible to be called? We ask

00:42:21,440 --> 00:42:24,540
eligible because some expectations expect to be called once

00:42:24,540 --> 00:42:28,270
or twice or three times and so have we

00:42:28,270 --> 00:42:30,569
run out of times you're allowed to call this

00:42:30,580 --> 00:42:32,791
expectation or not, are we eligible? And says yeah,

00:42:32,800 --> 00:42:34,809
yeah you can still call on me. So eligible

00:42:34,809 --> 00:42:41,421
returns true. Find_expectation returns expectation two here. That's the

00:42:41,421 --> 00:42:44,349
return value to here, to our call thing.

00:42:44,349 --> 00:42:47,080
Call then sets the expectation field on the call

00:42:47,080 --> 00:42:52,241
record to indicate which expectation we called, and then

00:42:52,260 --> 00:42:56,059
it calls verify_call and then it asks the expectation

00:42:56,060 --> 00:43:01,681
to calculate the return value for this mocked call.

00:43:01,681 --> 00:43:04,569
And then it returns here to call. Call returns

00:43:04,580 --> 00:43:08,831
for Message Missing and foo returns from there. So

00:43:08,840 --> 00:43:11,971
that's how we find the expectations in flux-mock.

00:43:11,971 --> 00:43:13,790
That's a lot of details there, but when I

00:43:13,790 --> 00:43:17,319
walk you through this, and kind of walk you

00:43:17,320 --> 00:43:19,661
through it, it's a very easy way to describe

00:43:19,661 --> 00:43:24,180
it. I like , I like and dislike sequence

00:43:24,200 --> 00:43:27,500
diagrams. They are the most fragile diagram to write

00:43:27,500 --> 00:43:29,079
because they break all the time. As soon as

00:43:29,080 --> 00:43:32,631
I change anything, this diagram will be critically wrong

00:43:32,631 --> 00:43:38,260
in some manner. They're also a pain to draw.

00:43:38,260 --> 00:43:40,089
There's lots of details in here and getting everything

00:43:40,089 --> 00:43:42,411
to match up right, ehh, thats a pain. This

00:43:42,420 --> 00:43:44,589
took me probably the longest diagram of anything to

00:43:44,589 --> 00:43:46,231
call and to draw it. I have to run

00:43:46,240 --> 00:43:48,990
through the code myself to understand it.

00:43:49,000 --> 00:43:52,349
However, the process of walking through the code to

00:43:52,349 --> 00:43:55,651
draw this diagram is worth everything. This is one

00:43:55,660 --> 00:43:59,410
case where I feel the diagram, eh, I have

00:43:59,410 --> 00:44:02,450
ambivalent feelings about it. But the process of writing

00:44:02,460 --> 00:44:04,640
the diagram means I really gotta understand what's going

00:44:04,640 --> 00:44:06,690
on down underneath the covers and that, to me,

00:44:06,690 --> 00:44:09,099
is the big win of this kind of thing.

00:44:09,100 --> 00:44:12,181
So UML, you, I find, I draw diagrams, not

00:44:12,181 --> 00:44:14,960
so much for the diagram's benefit, but a lot

00:44:14,960 --> 00:44:18,000
for the learning that happens when I draw the

00:44:18,000 --> 00:44:22,819
diagram. So lets summarize here, just really quickly. UML

00:44:22,820 --> 00:44:26,871
is great for detecting dependencies, and that's my favorite

00:44:26,880 --> 00:44:30,470
thing about UML all together. Yeah, lets knock down

00:44:30,470 --> 00:44:33,450
the sign. I guess my favorite thing about UML

00:44:33,450 --> 00:44:38,010
is doing the dependency looks there, looking at structure,

00:44:38,010 --> 00:44:40,730
looking for anomalies in structure when I draw the

00:44:40,740 --> 00:44:43,470
diagram there, it's good for that. It's good for

00:44:43,470 --> 00:44:46,280
denoting dynamic behavior in a way that the code

00:44:46,280 --> 00:44:49,829
kind of obscures sometimes. And then object iteration is

00:44:49,840 --> 00:44:53,481
another feature of UML that is, probably, a less-used

00:44:53,481 --> 00:44:56,099
feature of UML that I personally use, but well-worth

00:44:56,100 --> 00:44:56,881
knowing about.

00:44:56,881 --> 00:45:00,530
Some tips, if you want to start drawing diagrams,

00:45:00,530 --> 00:45:03,980
here's some ideas. Decide what idea you want to

00:45:03,980 --> 00:45:07,309
communicate with this particular diagram and draw it with

00:45:07,309 --> 00:45:10,810
that in mind. Don't worry about capturing all the

00:45:10,820 --> 00:45:13,511
details, capture only enough detail so that the diagram

00:45:13,520 --> 00:45:16,270
makes sense to the audience that you're addressing, so

00:45:16,280 --> 00:45:18,910
they can understand the idea that you wish to

00:45:18,910 --> 00:45:22,299
convey.

00:45:22,300 --> 00:45:24,991
Explore ideas, like I did with that rake re-design

00:45:25,000 --> 00:45:27,530
thing. Maybe we could re-do it like this. Now,

00:45:27,530 --> 00:45:30,030
that diagram is probably wrong, I probably missed some

00:45:30,030 --> 00:45:33,069
details somewhere, but it was worth exploring, gives me

00:45:33,080 --> 00:45:34,871
an idea of where I might want to go

00:45:34,880 --> 00:45:40,270
in the future. I recommended you draw the diagram.

00:45:40,270 --> 00:45:43,250
Don't depend upon automated drawing tools that examine your

00:45:43,250 --> 00:45:45,910
source code and put up diagrams. They put way

00:45:45,910 --> 00:45:48,480
too many details in the diagram, they don't convey

00:45:48,480 --> 00:45:51,380
an idea, they convey exactly what the source code

00:45:51,400 --> 00:45:53,050
conveys, so you might as well just look at

00:45:53,050 --> 00:45:55,549
the source code at that point. It's the editing

00:45:55,560 --> 00:45:58,961
process that makes the diagram useful.

00:45:58,961 --> 00:46:04,290
And keep the ephemeral. Don't try to generate lots

00:46:04,290 --> 00:46:06,200
and lots of diagrams for your application, thinking, oh,

00:46:06,200 --> 00:46:08,200
its going to help lots and lots of programmers

00:46:08,200 --> 00:46:12,950
in the future. A few well-designed, high level UML

00:46:12,950 --> 00:46:16,799
diagrams, placed in the document directory: excellent. Lots of

00:46:16,800 --> 00:46:20,101
detailed diagrams, placed in the document directory: gonna get

00:46:20,101 --> 00:46:21,740
out of date before you know it. It's just

00:46:21,740 --> 00:46:23,970
not worth it. So, keep the ephemeral. And I

00:46:23,980 --> 00:46:26,020
love white boards for drawing UML.

00:46:26,020 --> 00:46:30,290
Presentation tips. If you're going to do a talk

00:46:30,290 --> 00:46:32,740
and you're putting UML documents up, make the lines

00:46:32,740 --> 00:46:37,370
two pixels. Who knew they look so much better

00:46:37,380 --> 00:46:39,819
like that? They look like, oh they mean something.

00:46:39,820 --> 00:46:44,471
This is, ah, this is wimpy. A good book

00:46:44,480 --> 00:46:47,990
on UML is UML Distilled. It's this thin book,

00:46:47,990 --> 00:46:49,990
unlike the thick books you've been buying on UML

00:46:49,990 --> 00:46:52,350
that go into all the gory details. UML Distilled

00:46:52,360 --> 00:46:54,790
talks about just the essentials of UML and can

00:46:54,790 --> 00:46:56,569
get you going in getting your diagrams up and

00:46:56,600 --> 00:46:59,260
running. It's still pretty good. Some tools? White boards,

00:46:59,260 --> 00:47:01,079
get a white board. We have an office that

00:47:01,080 --> 00:47:05,781
has three walls of white boards. Humm, I love

00:47:05,781 --> 00:47:09,900
it. If you want to do it programmeticlly, on

00:47:09,900 --> 00:47:15,140
the cheap, I recommend UMLet. It is a Java

00:47:15,140 --> 00:47:18,440
application. It's really lightweight, it's got a really unusual

00:47:18,440 --> 00:47:21,040
editing feature, but you can get good looking diagrams

00:47:21,040 --> 00:47:24,349
up and running fairly quickly with UMLet.

00:47:24,349 --> 00:47:25,951
All the diagrams I did for this talk were

00:47:25,960 --> 00:47:29,880
done with OmniGraffle, which is, does really pretty diagrams.

00:47:33,260 --> 00:47:35,230
If pretty is important.

00:47:35,230 --> 00:47:37,490
I think sometimes making them pretty makes you feel

00:47:37,490 --> 00:47:40,079
like you need to keep them around longer than

00:47:40,100 --> 00:47:44,330
you need to. So I'm not actually recommending UML

00:47:44,330 --> 00:47:46,850
for your day to day UML diagram. White boards

00:47:46,860 --> 00:47:49,661
is my first choice, UMLet is my second choice.

00:47:49,661 --> 00:47:51,319
If you're doing a presentation and you want it

00:47:51,320 --> 00:47:54,541
to look pretty, OmniGraffle then is a good choice

00:47:54,541 --> 00:47:55,359
for that.

00:47:55,360 --> 00:47:56,870
OK, so you're all gonna go and start drawing

00:47:56,870 --> 00:47:58,621
diagrams instead of writing ruby code?

00:47:58,621 --> 00:48:01,981

YouTube URL: https://www.youtube.com/watch?v=VyuMWYzl9gM


