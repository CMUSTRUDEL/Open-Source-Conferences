Title: Ruby Conf 2013 - Compilers For Free by Tom Stuart
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	Partial evaluation is a powerful tool for timeshifting some aspects of a program's execution from the future into the present. Among other things, it gives us an automatic way to turn a general, abstract program into a faster, more specialized one.

This math-free talk uses Ruby to explain how partial evaluation works, how it can be used to make programs go faster, and how it compares to ideas like currying and partial application from the world of functional programming. It then investigates what happens when you run a partial evaluator on itself, and reveals some surprising results about how these techniques can be used to automatically generate compilers instead of writing them from scratch.

Help us caption & translate this video!

http://amara.org/v/FG55/
Captions: 
	00:00:16,630 --> 00:00:19,000
TOM STUART: Good morning everyone.

00:00:19,960 --> 00:00:23,199
Thanks for coming to this talk. I'm Tom Stuart.

00:00:23,200 --> 00:00:24,300
I'm gonna talk about, well,

00:00:24,300 --> 00:00:27,460
I'm gonna talk about getting compilers for free.

00:00:27,460 --> 00:00:30,439
Although, actually, my agenda today

00:00:30,439 --> 00:00:33,480
is that I'm fascinated by programming,

00:00:33,480 --> 00:00:36,860
or, to be more specific, I'm fascinated by metaprogramming.

00:00:36,860 --> 00:00:39,059
It's something I'm really interested in.

00:00:39,059 --> 00:00:42,620
So let's talk about metaprogramming.

00:00:42,620 --> 00:00:45,600
As Ruby programmers, we're already kind of intuitively, we

00:00:45,600 --> 00:00:49,180
already intuitively understand the power of metaprogramming, right? Programs

00:00:49,180 --> 00:00:52,019
that write programs. So let's, in Ruby we've got

00:00:52,019 --> 00:00:54,699
things like instance eval and define method and method

00:00:54,699 --> 00:00:56,360
missing and all these kind of tools for making

00:00:56,360 --> 00:00:58,930
programs that grow new functionality at run-time that wasn't,

00:00:58,930 --> 00:01:02,189
like, present in the static program that we started

00:01:02,189 --> 00:01:03,199
out with.

00:01:03,199 --> 00:01:04,799
Now, there's another thing that I find even more

00:01:04,799 --> 00:01:06,979
interesting than that, which still kind of counts as

00:01:06,979 --> 00:01:10,570
metaprogramming, which is programs that manipulate representations of other

00:01:10,570 --> 00:01:13,479
programs, right. Programs that operate on data, which itself

00:01:13,479 --> 00:01:16,009
represents a program, and then does something with that

00:01:16,009 --> 00:01:18,900
representation, like analyzes it, or evaluates it, or translates

00:01:18,900 --> 00:01:21,659
it, or transforms it. So this is kind of

00:01:21,659 --> 00:01:24,920
the world of compilers and interpreters and static analyzers.

00:01:24,920 --> 00:01:27,319
And, and I think it's really fascinating. In a

00:01:27,319 --> 00:01:29,319
way, it's kind of the purest, or the most

00:01:29,319 --> 00:01:33,060
self-referential kind of software that you can write. So

00:01:33,060 --> 00:01:34,700
in this talk today, I'd like to make you

00:01:34,700 --> 00:01:37,499
look at programs differently. I don't have a complicated,

00:01:37,499 --> 00:01:40,049
technical point to make. I just want to tell

00:01:40,049 --> 00:01:42,310
you a cool story and hopefully convince you that

00:01:42,310 --> 00:01:45,780
programs which manipulate other programs are interesting, and hopefully

00:01:45,780 --> 00:01:47,299
kind of inspire you to find out some more

00:01:47,299 --> 00:01:48,359
about them.

00:01:48,359 --> 00:01:50,759
So I'm gonna start out by just talking about

00:01:50,759 --> 00:01:55,359
something we're all familiar with, which is executing programs.

00:01:55,359 --> 00:01:57,100
So you write a program, right? You have a

00:01:57,100 --> 00:01:59,299
program written down that you want to run. And

00:01:59,299 --> 00:02:02,249
you have a machine that you can run that

00:02:02,249 --> 00:02:04,270
program on. So you put that program into the

00:02:04,270 --> 00:02:07,539
machine, and then you've got some inputs for that

00:02:07,539 --> 00:02:10,330
program. And those might be command line arguments or

00:02:10,330 --> 00:02:13,610
configuration files or standard input or whatever.

00:02:13,610 --> 00:02:14,849
And you feed all of those inputs into the

00:02:14,849 --> 00:02:17,260
machine that's got the program inside it, and the

00:02:17,260 --> 00:02:19,599
program executes on the machine and it produces some

00:02:19,599 --> 00:02:21,250
output. I think we're all kind of familiar with

00:02:21,250 --> 00:02:25,080
how computers work, right? But that only works if

00:02:25,080 --> 00:02:26,710
the program that you wrote is written in a

00:02:26,710 --> 00:02:29,480
language that the machine kind of natively understands.

00:02:29,480 --> 00:02:31,470
So in terms of a real machine, that'll be,

00:02:31,470 --> 00:02:32,870
you know, the program has to be written in

00:02:32,870 --> 00:02:35,760
machine code, and if it's, if the program's written

00:02:35,760 --> 00:02:37,370
in a higher-level language, then maybe you can run

00:02:37,370 --> 00:02:39,630
it on some kind of, like, virtual machine, that

00:02:39,630 --> 00:02:41,260
understands that language specifically.

00:02:41,260 --> 00:02:43,890
But, if your program's written in a language that's

00:02:43,890 --> 00:02:46,050
unfamiliar to the machine, then you're gonna need an

00:02:46,050 --> 00:02:48,190
interpreter or a compiler to be able to execute

00:02:48,190 --> 00:02:50,600
it, right? So interpreters.

00:02:50,600 --> 00:02:54,850
How does an interpreter work? Well, very kind of

00:02:54,850 --> 00:02:57,060
roughly, the way it works is, it reads in

00:02:57,060 --> 00:02:58,890
some source code of the program you want to

00:02:58,890 --> 00:03:01,420
execute and then it builds an abstract syntax tree

00:03:01,420 --> 00:03:03,960
by pausing that source code, and then it evaluates

00:03:03,960 --> 00:03:06,590
the program by walking over the abstract syntax tree

00:03:06,590 --> 00:03:09,070
and performing the instructions that it finds inside the

00:03:09,070 --> 00:03:09,430
tree.

00:03:09,430 --> 00:03:12,590
And this is basically how, you know, MRI, pre

00:03:12,590 --> 00:03:15,210
1 point 9, did its job, right. So I'm

00:03:15,210 --> 00:03:17,030
gonna show you a little demo of how this

00:03:17,030 --> 00:03:19,810
works, by just introducing this, a language that I'm

00:03:19,810 --> 00:03:21,770
gonna call simple. It's just a toy language --

00:03:21,770 --> 00:03:24,880
simple is like an abbreviation for simple imperative language.

00:03:24,880 --> 00:03:27,340
This language is really straightforward. It looks a little

00:03:27,340 --> 00:03:29,490
bit like Ruby, but not exactly the same. State,

00:03:29,490 --> 00:03:33,340
statements look like this. So simple's got expressions and

00:03:33,340 --> 00:03:36,120
statements, unlike Ruby, it's got expressions like nineteen plus

00:03:36,120 --> 00:03:39,200
twenty-three. Expressions just evaluate to a value.

00:03:39,200 --> 00:03:41,820
It's also got statements, like assignments. So a equals

00:03:41,820 --> 00:03:45,360
nineteen plus twenty-three is a statement, and that statement

00:03:45,360 --> 00:03:48,370
is gonna have a, is gonna modify the lexical

00:03:48,370 --> 00:03:50,540
environment. So when you evaluate a statement, it's gonna

00:03:50,540 --> 00:03:53,860
update the bindings between variable names and their values.

00:03:53,860 --> 00:03:55,540
So the effect of executing that statement, is that

00:03:55,540 --> 00:03:58,570
after the statement is executed, a has got the

00:03:58,570 --> 00:03:59,590
value forty-two, right.

00:03:59,590 --> 00:04:01,910
Some other statements, you know it's got sequencing in

00:04:01,910 --> 00:04:05,360
it. It's got conditionals in it. It's got while

00:04:05,360 --> 00:04:07,460
loops in it. Right, very basic language. It's not

00:04:07,460 --> 00:04:09,430
quite Ruby because it's got curly braces and stuff,

00:04:09,430 --> 00:04:11,240
but it's kind of close enough to Ruby that

00:04:11,240 --> 00:04:13,160
you recognize what it's trying to do.

00:04:13,160 --> 00:04:14,900
So given that you're at RubyConf, you probably already

00:04:14,900 --> 00:04:17,130
know about this gem called treetop, which we can

00:04:17,130 --> 00:04:20,000
use to pause languages, like build pauses, and I'm

00:04:20,000 --> 00:04:22,090
just gonna very, very quickly show you how we

00:04:22,090 --> 00:04:25,889
can build a grammar for that simple language.

00:04:25,889 --> 00:04:27,600
The grammar for this language looks like this. You

00:04:27,600 --> 00:04:29,470
just write the file, and you say, this is

00:04:29,470 --> 00:04:31,240
a grammar for the simple language, and then you

00:04:31,240 --> 00:04:32,920
just need to write rules that explain what the

00:04:32,920 --> 00:04:35,270
syntax for each of the different kind of statements

00:04:35,270 --> 00:04:36,730
and expressions in your language look like.

00:04:36,730 --> 00:04:38,810
So I can say, a sequence is two statements

00:04:38,810 --> 00:04:41,380
separated by a semi-colon. A while loop says while

00:04:41,380 --> 00:04:43,650
bracket and then a condition and then, you know,

00:04:43,650 --> 00:04:45,370
curly braces around the body of the while loop.

00:04:45,370 --> 00:04:46,790
And assignment looks like a variable name and an

00:04:46,790 --> 00:04:47,990
equal sign.

00:04:47,990 --> 00:04:52,380
There's some more rules there. A conditional, binary expressions

00:04:52,380 --> 00:04:55,410
here, less than, add and multiply, and then down

00:04:55,410 --> 00:04:56,660
at the bottom you get to, kind of, the

00:04:56,660 --> 00:05:00,310
atomic things like numbers and Booleans and variables, right.

00:05:00,310 --> 00:05:01,760
So I'm just gonna scoot past that, but you,

00:05:01,760 --> 00:05:03,100
if you, if you write a file like that

00:05:03,100 --> 00:05:05,130
that explains what your programming language looks like, you

00:05:05,130 --> 00:05:07,350
can use the treetop gem to load that grammar

00:05:07,350 --> 00:05:10,139
file and it will generate you a parser file

00:05:10,139 --> 00:05:12,240
named after the grammar, and then I can extenuate

00:05:12,240 --> 00:05:14,430
that parser class, and say make me a new

00:05:14,430 --> 00:05:15,639
parser, and then parse this string.

00:05:15,639 --> 00:05:17,630
And what treetop will do is give you back

00:05:17,630 --> 00:05:19,970
this big data structure called a concrete syntax tree,

00:05:19,970 --> 00:05:21,770
or a parse tree. And this has got a

00:05:21,770 --> 00:05:24,600
lot of information in it about the exact sort

00:05:24,600 --> 00:05:26,300
of lexical structure of the string you gave it,

00:05:26,300 --> 00:05:27,440
and how it breaks down and through all its

00:05:27,440 --> 00:05:29,360
component parts. There's a lot of information in there

00:05:29,360 --> 00:05:31,470
that we're not very interested in. But that's a

00:05:31,470 --> 00:05:33,430
good start. We don't want a concrete syntax tree,

00:05:33,430 --> 00:05:35,060
we want an abstract syntax tree, which is like

00:05:35,060 --> 00:05:37,380
a more useful representation of the structure of the,

00:05:37,380 --> 00:05:39,340
the statement we gave it.

00:05:39,340 --> 00:05:41,270
And we can make an abstract syntax tree by

00:05:41,270 --> 00:05:43,040
first, we can declare a bunch of classes that

00:05:43,040 --> 00:05:44,960
we're gonna use to instantiate to make their nodes

00:05:44,960 --> 00:05:46,180
to make the abstract syntax tree, and I'm just

00:05:46,180 --> 00:05:47,770
gonna use struct to do that.

00:05:47,770 --> 00:05:49,330
So I'm gonna define a new class for each

00:05:49,330 --> 00:05:52,830
kind of, each different kind of expression and statement,

00:05:52,830 --> 00:05:54,310
and some of them, so all these binary expressions

00:05:54,310 --> 00:05:57,780
have got a left and a right sub-expression. Assignments

00:05:57,780 --> 00:05:59,340
have got the variable name and the expression is

00:05:59,340 --> 00:06:02,410
being assigned to it, and so on.

00:06:02,410 --> 00:06:04,380
Now, going back to the grammar. In each of

00:06:04,380 --> 00:06:06,730
these rules that matches a particular kind of syntax,

00:06:06,730 --> 00:06:08,380
you can put some Ruby code in here and

00:06:08,380 --> 00:06:10,419
say, whenever I get one of these number nodes

00:06:10,419 --> 00:06:12,370
in the abstract, in the concrete syntax tree, I

00:06:12,370 --> 00:06:15,040
want to define a method on that called to_ast,

00:06:15,040 --> 00:06:17,010
which is arbitrary -- I've made that up.

00:06:17,010 --> 00:06:18,250
And then when I call that, I want that

00:06:18,250 --> 00:06:20,610
to manufacture a new instance of the number class,

00:06:20,610 --> 00:06:22,419
in this case, and that just needs to contain

00:06:22,419 --> 00:06:24,750
the integer version of the text string that was

00:06:24,750 --> 00:06:26,680
inside, you know, that was the number.

00:06:26,680 --> 00:06:29,020
And I can define versions of those for, you

00:06:29,020 --> 00:06:31,100
know, the Booleans and variables, and each of these

00:06:31,100 --> 00:06:32,830
is just building a new instance of my custom

00:06:32,830 --> 00:06:35,830
abstract syntax tree classes, right.

00:06:35,830 --> 00:06:38,260
So looking at those, these are just three definitions

00:06:38,260 --> 00:06:40,139
of the same method on different kinds of concrete

00:06:40,139 --> 00:06:42,130
syntax tree nodes that will help me create one

00:06:42,130 --> 00:06:44,650
of these abstract syntax tree nodes, you know, from

00:06:44,650 --> 00:06:45,020
it.

00:06:45,020 --> 00:06:46,889
And similarly for things like these statements, I can

00:06:46,889 --> 00:06:48,930
go in and put, you know, put more of

00:06:48,930 --> 00:06:52,090
these method definitions in. These are mostly just recursively

00:06:52,090 --> 00:06:55,850
converting their sub-expressions or sub-statements into abstract syntax trees

00:06:55,850 --> 00:06:57,600
and then gluing them together with the right, the

00:06:57,600 --> 00:06:59,470
right kind of node class.

00:06:59,470 --> 00:07:00,940
So once I've done all of that work, I

00:07:00,940 --> 00:07:02,800
can get treetop to build me a concrete syntax

00:07:02,800 --> 00:07:04,340
tree and then I can call to_ast on the

00:07:04,340 --> 00:07:06,610
root node, and then that'll recursively convert the whole

00:07:06,610 --> 00:07:08,320
thing into an abstract syntax tree, which is a

00:07:08,320 --> 00:07:10,810
nice data structure that's made out of instances of

00:07:10,810 --> 00:07:12,949
classes that I defined, right.

00:07:12,949 --> 00:07:15,070
So this is saying that this statement here is,

00:07:15,070 --> 00:07:18,240
you know, a sequence of assignments, and actually, just

00:07:18,240 --> 00:07:19,990
to visualize that, you can see that this statement

00:07:19,990 --> 00:07:22,370
is a sequence of two assignments. The first assignment

00:07:22,370 --> 00:07:24,360
is assigning the number two to x and the

00:07:24,360 --> 00:07:27,790
second assignment is assigning the result of multiplying x

00:07:27,790 --> 00:07:30,620
and three to y, right.

00:07:30,620 --> 00:07:32,419
So now I've got this abstract syntax tree, I

00:07:32,419 --> 00:07:35,180
can evaluate the abstract syntax tree by recursively walking

00:07:35,180 --> 00:07:36,949
over it. And the easiest way to do that

00:07:36,949 --> 00:07:38,889
is just to define a method on all of

00:07:38,889 --> 00:07:40,490
the different kinds of node, and then I can

00:07:40,490 --> 00:07:41,930
call the method on the root node, and it'll

00:07:41,930 --> 00:07:44,260
recursively -- I can define it so it recursively

00:07:44,260 --> 00:07:45,400
walks over the tree.

00:07:45,400 --> 00:07:48,710
So, again, just briefly, I'm gonna run an evaluate

00:07:48,710 --> 00:07:51,870
method on each of those abstract syntax tree classes

00:07:51,870 --> 00:07:54,210
and the evaluate method is gonna take an environment,

00:07:54,210 --> 00:07:56,060
which is the lexical environment -- it's a hash

00:07:56,060 --> 00:07:59,110
that says what the value of each variable currently

00:07:59,110 --> 00:08:01,479
is. So if you were evaluating a number or

00:08:01,479 --> 00:08:03,960
a Boolean, it doesn't care what's in the environment.

00:08:03,960 --> 00:08:05,520
You always just get out the value that you

00:08:05,520 --> 00:08:06,759
stored inside that node.

00:08:06,759 --> 00:08:08,650
If you are evaluating a variable then it looks

00:08:08,650 --> 00:08:10,570
in the environment and pulls out the variable with

00:08:10,570 --> 00:08:13,370
that name, right. So that means that I can,

00:08:13,370 --> 00:08:15,710
if I make a new number instance and evaluate

00:08:15,710 --> 00:08:17,310
that in an empty environment, I just get the

00:08:17,310 --> 00:08:20,729
original number back. Same with Booleans. If I evaluate

00:08:20,729 --> 00:08:23,620
a variable y in this particular environment, it gives

00:08:23,620 --> 00:08:25,320
y the value of eleven, then I'll get eleven,

00:08:25,320 --> 00:08:27,460
whereas if I evaluate in a different environment it

00:08:27,460 --> 00:08:29,180
gives y a different value, I get the different

00:08:29,180 --> 00:08:30,560
value out, right.

00:08:30,560 --> 00:08:33,440
So those are the simplest possible expressions to evaluate.

00:08:33,440 --> 00:08:35,639
These are the definitions of evaluate for those binary

00:08:35,639 --> 00:08:38,449
expressions, and these just recursively evaluate the left and

00:08:38,449 --> 00:08:40,860
right sub-expressions and then they perform the operation that

00:08:40,860 --> 00:08:42,519
corresponds to the kind of node that we've got.

00:08:42,519 --> 00:08:44,079
So if it's an add node, we add them.

00:08:44,079 --> 00:08:45,820
If it's multiply, we multiply them. If it's less

00:08:45,820 --> 00:08:48,509
than, we compare them with less than.

00:08:48,509 --> 00:08:49,930
So that means I can make something like a

00:08:49,930 --> 00:08:52,850
multiply expression, x times y, and evaluate that inside

00:08:52,850 --> 00:08:54,790
this environment, and I get the result six. If

00:08:54,790 --> 00:08:57,060
I make a less than node instead that says

00:08:57,060 --> 00:08:59,000
is x less than y, the answer is true,

00:08:59,000 --> 00:09:00,440
in that particular environment.

00:09:00,440 --> 00:09:03,210
And I can do that again for statements. I'm

00:09:03,210 --> 00:09:04,540
not gonna go into any detail out here, but,

00:09:04,540 --> 00:09:06,930
for example, you can see that the, for assignment

00:09:06,930 --> 00:09:09,420
statements -- oh, so statements don't return a value.

00:09:09,420 --> 00:09:11,320
They return the new environment. So when I do

00:09:11,320 --> 00:09:14,310
an assignment, for example, I recursively evaluate the expression

00:09:14,310 --> 00:09:17,520
inside the assignment and then I update the environment

00:09:17,520 --> 00:09:19,360
to have a new mapping from the variable name

00:09:19,360 --> 00:09:21,149
to the new value of that sub-expression, and so

00:09:21,149 --> 00:09:22,750
on for all of these, the rest of these

00:09:22,750 --> 00:09:23,120
things.

00:09:23,120 --> 00:09:26,370
You know, sequence kind of evaluates the first, you

00:09:26,370 --> 00:09:29,250
know, the first statement first, to get an updated

00:09:29,250 --> 00:09:31,550
environment, and then it evaluates the second statement in

00:09:31,550 --> 00:09:33,910
the updated environment to get the final environment and

00:09:33,910 --> 00:09:35,050
so on.

00:09:35,050 --> 00:09:36,380
So what's I've done all of that stuff, I

00:09:36,380 --> 00:09:38,160
can now do things like, when I evaluate an

00:09:38,160 --> 00:09:40,270
assignment that is x is assigned the value y,

00:09:40,270 --> 00:09:42,540
and if I start with an empty environment and

00:09:42,540 --> 00:09:43,570
I evaluate it, I get a new environment where

00:09:43,570 --> 00:09:45,350
x has got the value one. If I do

00:09:45,350 --> 00:09:47,740
a sequence of assignments, x equals one and then

00:09:47,740 --> 00:09:49,480
x equals two in an empty environment, I end

00:09:49,480 --> 00:09:51,230
up with x equals two, because that's kind of

00:09:51,230 --> 00:09:52,830
cobbled the first assignment.

00:09:52,830 --> 00:09:54,070
And the point of doing all this is so

00:09:54,070 --> 00:09:55,800
that I can chain things together and say use

00:09:55,800 --> 00:09:59,490
the parser to parse this, this program, and then

00:09:59,490 --> 00:10:02,149
evaluate the abstract syntax tree in an empty environment.

00:10:02,149 --> 00:10:03,880
So if I evaluate x equals two, y equals

00:10:03,880 --> 00:10:06,230
x times three in an empty environment, I get

00:10:06,230 --> 00:10:07,600
x is two, y is six. That's like the

00:10:07,600 --> 00:10:09,370
result of my program.

00:10:09,370 --> 00:10:10,529
And I can do that with the, you know,

00:10:10,529 --> 00:10:12,430
a more sophisticated program that's got a while loop

00:10:12,430 --> 00:10:13,770
in it. This is just a little program that

00:10:13,770 --> 00:10:16,230
starts out x at one, and it keeps multiplying

00:10:16,230 --> 00:10:18,640
it by three until the value becomes greater than

00:10:18,640 --> 00:10:20,410
five, and then that finishes up with x being

00:10:20,410 --> 00:10:21,770
the value of nine.

00:10:21,770 --> 00:10:23,940
So that all works. It's all fairly straightforward. That's

00:10:23,940 --> 00:10:26,540
what an interpreter is, really. The point of an

00:10:26,540 --> 00:10:30,350
interpreter is it provides what I'm calling single-stage execution.

00:10:30,350 --> 00:10:32,450
And what I mean by that is, you've got

00:10:32,450 --> 00:10:36,930
your interpreter, and you provide a source program into

00:10:36,930 --> 00:10:38,930
the interpreter, and then in general, though we didn't

00:10:38,930 --> 00:10:40,730
do it in the case I just showed you,

00:10:40,730 --> 00:10:42,740
we'll also provide some input to the program.

00:10:42,740 --> 00:10:45,430
So if the interpreter is Ruby, you'll provide a

00:10:45,430 --> 00:10:47,420
Ruby program as the source, and then the input

00:10:47,420 --> 00:10:50,300
will be whatever standard input or command line arguments

00:10:50,300 --> 00:10:52,230
or whatever. So you provide all of that stuff

00:10:52,230 --> 00:10:54,800
to the interpreter, and then the interpreter is what

00:10:54,800 --> 00:10:56,980
runs on the machine, and then that produces the

00:10:56,980 --> 00:10:58,640
output.

00:10:58,640 --> 00:11:00,370
And of course, here we're assuming that the interpreter

00:11:00,370 --> 00:11:02,290
is already written in the language that can run

00:11:02,290 --> 00:11:05,170
on the underlying, on the underlying machine. This doesn't

00:11:05,170 --> 00:11:07,120
need to be, because we're using the interpreter to

00:11:07,120 --> 00:11:11,600
run the source program on the underlying machine, right.

00:11:11,600 --> 00:11:13,339
And this all happens at the same time. This

00:11:13,339 --> 00:11:15,399
is the single stage of program execution. That's what

00:11:15,399 --> 00:11:18,350
I'm calling run-time. That's what you would call run-time.

00:11:18,350 --> 00:11:20,370
So what about compilers, how are they different?

00:11:20,370 --> 00:11:22,680
Well, they're pretty similar, really. They work in a

00:11:22,680 --> 00:11:25,589
similar kind of way. They read some source code,

00:11:25,589 --> 00:11:27,339
and then they build an abstract syntax tree by

00:11:27,339 --> 00:11:28,720
parsing the source code. But then they do a

00:11:28,720 --> 00:11:31,610
different thing, which is, rather than perform the instructions

00:11:31,610 --> 00:11:34,010
they find in the abstract syntax tree, they generate

00:11:34,010 --> 00:11:36,490
some target code by walking over the abstract syntax

00:11:36,490 --> 00:11:39,360
tree and emitting some instructions as they find them.

00:11:39,360 --> 00:11:40,490
So I'm not gonna -- I don't have time

00:11:40,490 --> 00:11:42,260
to go into any detail of how to, how

00:11:42,260 --> 00:11:43,700
to do this properly, but I am gonna show

00:11:43,700 --> 00:11:45,209
you an example.

00:11:45,209 --> 00:11:48,360
So here's a version of, instead of having two,

00:11:48,360 --> 00:11:51,000
instead of having evaluate defined on those abstract syntax

00:11:51,000 --> 00:11:53,930
tree nodes, I could define a method called to_javascript,

00:11:53,930 --> 00:11:55,990
and this is just gonna return a string which

00:11:55,990 --> 00:11:58,890
contains some JavaScript code that does whatever that node

00:11:58,890 --> 00:11:59,779
is supposed to do.

00:11:59,779 --> 00:12:02,200
And the, the JavaScript code I'm generating here, rather

00:12:02,200 --> 00:12:04,520
than using real JavaScript variables and having to deal

00:12:04,520 --> 00:12:07,310
with all of JavaScript's, like, weird variable scoping stuff,

00:12:07,310 --> 00:12:09,700
I'm just turning every piece of, every simple program

00:12:09,700 --> 00:12:13,050
into a JavaScript function that takes an object that's

00:12:13,050 --> 00:12:15,209
got mappings of variables names to values and then

00:12:15,209 --> 00:12:16,830
kind of updates the environment.

00:12:16,830 --> 00:12:20,930
So, or, in this case, when you have expressions,

00:12:20,930 --> 00:12:22,500
like a number is gonna turn into a function

00:12:22,500 --> 00:12:24,670
that just returns a constant number, and a Boolean

00:12:24,670 --> 00:12:26,760
is gonna return a constant Boolean, and a variable

00:12:26,760 --> 00:12:29,450
is gonna look up the variable in the environment.

00:12:29,450 --> 00:12:31,500
So this is a JavaScript variable, and then it's

00:12:31,500 --> 00:12:33,110
gonna look up the right value in that, in

00:12:33,110 --> 00:12:34,410
that JavaScript object.

00:12:34,410 --> 00:12:37,399
Just very quickly, same for these kind of binary

00:12:37,399 --> 00:12:39,870
expressions, I just like recursively convert the left and

00:12:39,870 --> 00:12:42,350
right sub-expressions to JavaScript and then add them together

00:12:42,350 --> 00:12:44,649
or multiply them together or whatever. And then, you

00:12:44,649 --> 00:12:46,089
know, don't try to read all this, but this

00:12:46,089 --> 00:12:48,110
is how, for all of the statements, I'm really

00:12:48,110 --> 00:12:51,180
just generating the JavaScript syntax. So an if turns

00:12:51,180 --> 00:12:54,040
into a JavaScript if, and a sequence turns into

00:12:54,040 --> 00:12:56,200
kind of JavaScript sequencing and a while turns into

00:12:56,200 --> 00:12:57,240
a JavaScript while loop.

00:12:57,240 --> 00:12:58,899
So it's all pretty straightforward. And the point of

00:12:58,899 --> 00:13:01,240
doing that is so that I can take, like,

00:13:01,240 --> 00:13:03,250
this program that I showed you before, x equals

00:13:03,250 --> 00:13:04,870
one while x is less than five, turn that

00:13:04,870 --> 00:13:07,490
into JavaScript, and now that's kind of being compiled

00:13:07,490 --> 00:13:10,209
into an admittedly much longer JavaScript program.

00:13:10,209 --> 00:13:11,959
And this is a JavaScript program that does the

00:13:11,959 --> 00:13:13,790
same thing as the program I started with that

00:13:13,790 --> 00:13:16,209
was written in a different language. And so I

00:13:16,209 --> 00:13:18,300
can take that big JavaScript program -- this is

00:13:18,300 --> 00:13:20,660
the same program formatted more nicely, place it on

00:13:20,660 --> 00:13:24,200
the nodes js console and say, look, here's my

00:13:24,200 --> 00:13:26,070
program, and then you can see on the bottom

00:13:26,070 --> 00:13:28,040
here, when I run this program in JavaScript, I

00:13:28,040 --> 00:13:30,170
get the result x is nine.

00:13:30,170 --> 00:13:32,830
So that compiler I just showed you is extremely

00:13:32,830 --> 00:13:34,740
stupid. It's not a good compiler. But it does

00:13:34,740 --> 00:13:38,800
let us execute those simple programs if our machine

00:13:38,800 --> 00:13:41,930
only understands JavaScript, right.

00:13:41,930 --> 00:13:43,800
So the difference between an interpreter and a compiler

00:13:43,800 --> 00:13:47,260
really is that a compiler provides two-stage execution. When

00:13:47,260 --> 00:13:49,920
you've got a compiler, you just give it the

00:13:49,920 --> 00:13:53,050
source program as input, and then the compiler runs

00:13:53,050 --> 00:13:54,600
and it generates some, and it's usually called a

00:13:54,600 --> 00:13:58,459
target program. And then later on, at a different

00:13:58,459 --> 00:14:00,519
time, you can take the target program, which is

00:14:00,519 --> 00:14:03,529
just data when the compiler emitted it, and put

00:14:03,529 --> 00:14:06,360
the target program inside a machine and run it.

00:14:06,360 --> 00:14:07,910
And that's when you provide the input to your

00:14:07,910 --> 00:14:10,490
program, and then your target program and you get

00:14:10,490 --> 00:14:11,860
the output out.

00:14:11,860 --> 00:14:13,200
So we've still achieved the same thing as with

00:14:13,200 --> 00:14:15,529
an interpreter, but now it's been kind of staged

00:14:15,529 --> 00:14:17,269
in two pieces. And the first piece is what

00:14:17,269 --> 00:14:19,450
we call compile time and the second piece is

00:14:19,450 --> 00:14:22,450
what we call run time.

00:14:22,450 --> 00:14:25,070
So the good news about compilers is that compiled

00:14:25,070 --> 00:14:29,310
programs run faster. Staging the computation like this removes

00:14:29,310 --> 00:14:32,070
the interpretive overhead at runtime. And by interpretive overhead,

00:14:32,070 --> 00:14:34,019
I mean all of that faff of parsing the

00:14:34,019 --> 00:14:36,540
program and walking over the ast and like deciding

00:14:36,540 --> 00:14:37,750
what you're gonna do with it. That all gets

00:14:37,750 --> 00:14:39,980
done at compile time, and by the time the

00:14:39,980 --> 00:14:42,029
program runs, that work's already been done.

00:14:42,029 --> 00:14:43,640
So if you're gonna run the program a million

00:14:43,640 --> 00:14:45,540
times, it makes sense to do the interpreting stuff

00:14:45,540 --> 00:14:47,850
once and then just run the target code that

00:14:47,850 --> 00:14:49,420
doesn't have all of that kind of overhead.

00:14:49,420 --> 00:14:52,339
There are other kind of performance benefits that I'm

00:14:52,339 --> 00:14:54,310
not talking about in this talk. But, for example,

00:14:54,310 --> 00:14:56,480
your compiler can use, like, clever data structure or

00:14:56,480 --> 00:14:59,029
clever optimizations to make the target program more and

00:14:59,029 --> 00:15:01,829
more efficient, especially in those without the underlying architecture

00:15:01,829 --> 00:15:03,730
of the machine and stuff like that.

00:15:03,730 --> 00:15:04,980
So that's the good news. The bad news is

00:15:04,980 --> 00:15:07,420
that compilation is just hard to, to do than

00:15:07,420 --> 00:15:10,170
interpretation. So there are a few reasons for that.

00:15:10,170 --> 00:15:11,700
The first is, you have to think about two

00:15:11,700 --> 00:15:14,079
times instead of one. You're not just, when you

00:15:14,079 --> 00:15:16,160
write an interpreter, you're just thinking, well I'm running

00:15:16,160 --> 00:15:18,670
right now. I'm the interpreter. I've written a program

00:15:18,670 --> 00:15:20,279
and I'm gonna do what that program says to

00:15:20,279 --> 00:15:21,100
do, right now.

00:15:21,100 --> 00:15:22,959
When you're writing a compiler, you're thinking about compile

00:15:22,959 --> 00:15:24,899
time and run time. So in your head you

00:15:24,899 --> 00:15:26,370
have to have this model of like, well what

00:15:26,370 --> 00:15:28,260
am I doing now is the compiler. And then

00:15:28,260 --> 00:15:29,959
what's the target program gonna do later when it

00:15:29,959 --> 00:15:31,800
actually gets executed? So that's harder.

00:15:31,800 --> 00:15:34,839
You also have to implement in two languages instead

00:15:34,839 --> 00:15:37,550
of one. With an interpreter, you're just implementing in

00:15:37,550 --> 00:15:39,970
the interpreter language. With that compiler I showed you,

00:15:39,970 --> 00:15:42,529
the compiler was implemented in Ruby, but what it

00:15:42,529 --> 00:15:44,970
did was generate some JavaScript code. So to write

00:15:44,970 --> 00:15:47,370
the compiler, I was actually writing in two programming

00:15:47,370 --> 00:15:50,220
languages kind of intertwined. And that's harder to kind

00:15:50,220 --> 00:15:51,950
of get your head around.

00:15:51,950 --> 00:15:54,769
And also, in a very vague hand-wavy sense, compiling

00:15:54,769 --> 00:15:57,149
dynamic languages is fundamentally challenging. If you want to

00:15:57,149 --> 00:15:59,649
compile a language like Ruby or JavaScript or something,

00:15:59,649 --> 00:16:01,079
you can't, it's not enough to just look at

00:16:01,079 --> 00:16:03,350
the static program and then convert it into some

00:16:03,350 --> 00:16:06,300
kind of target program, because the static program doesn't

00:16:06,300 --> 00:16:08,010
tell you everything about what might happen at run

00:16:08,010 --> 00:16:09,990
time, right. If you've got things like define method

00:16:09,990 --> 00:16:11,709
and you can create new classes and things like

00:16:11,709 --> 00:16:14,019
that, it's just hard to write a compiler for

00:16:14,019 --> 00:16:16,570
languages that kind of, where the programs can change

00:16:16,570 --> 00:16:18,649
dynamically as they execute.

00:16:18,649 --> 00:16:21,519
So long story short, writing an interpreter is easier

00:16:21,519 --> 00:16:24,370
than writing a compiler, but interpreters are slower than

00:16:24,370 --> 00:16:27,339
compilers, right. Interpreters only run at one time. They

00:16:27,339 --> 00:16:29,430
only use one language, and they can be as

00:16:29,430 --> 00:16:31,620
dynamic as you like. If the program changes when

00:16:31,620 --> 00:16:33,279
it runs, then that's fine, because you can just

00:16:33,279 --> 00:16:35,350
change the abstract syntax tree as the program runs,

00:16:35,350 --> 00:16:37,339
and the interpreter will just keep working.

00:16:37,339 --> 00:16:40,019
So ideally, we would just write interpreters for our

00:16:40,019 --> 00:16:44,220
programming languages, but unfortunately, they're slower, and so usually

00:16:44,220 --> 00:16:45,850
we end up writing compilers.

00:16:45,850 --> 00:16:48,040
So I want to tell you about a third

00:16:48,040 --> 00:16:50,329
kind of thing, which is like interpreters and compilers,

00:16:50,329 --> 00:16:53,260
and these are called partial evaluators.

00:16:53,260 --> 00:16:55,610
Now, a partial evaluator is like a cross between

00:16:55,610 --> 00:16:59,610
an interpreter and a compiler. An interpreter kind of

00:16:59,610 --> 00:17:02,839
does this job of executing a program right now

00:17:02,839 --> 00:17:06,250
and compilers do this job of generating a program

00:17:06,250 --> 00:17:09,299
now and then executing it later.

00:17:09,299 --> 00:17:13,059
Now, partial evaluators kind of live in the middle.

00:17:13,059 --> 00:17:15,470
Now, like, a hybrid of these two things. They

00:17:15,470 --> 00:17:18,230
execute some of the code now, and then leave

00:17:18,230 --> 00:17:22,020
the rest of it for execution later. So what

00:17:22,020 --> 00:17:24,150
that means is you give a partial evaluator your

00:17:24,150 --> 00:17:26,419
subject program, it's called, you know, the program you

00:17:26,419 --> 00:17:28,169
want it to partially evaluate, and you give it

00:17:28,169 --> 00:17:30,630
some of the inputs for that program, and it

00:17:30,630 --> 00:17:32,990
evaluates only the parts of the program that depend

00:17:32,990 --> 00:17:35,299
on the inputs that you've provided, and then whatever's

00:17:35,299 --> 00:17:37,970
left afterward is called the residual program. It's like

00:17:37,970 --> 00:17:39,110
what you have left, you know, if you've like

00:17:39,110 --> 00:17:41,030
boiled a liquid and you've got a residue left

00:17:41,030 --> 00:17:42,929
over. This is kind of the residual program after

00:17:42,929 --> 00:17:46,240
you've done your partial evaluation.

00:17:46,240 --> 00:17:49,830
So what this looks like is instead of taking

00:17:49,830 --> 00:17:52,059
your subject program and running it directly on a

00:17:52,059 --> 00:17:54,340
machine, and sort of providing an arbitrary number of

00:17:54,340 --> 00:17:56,690
inputs to your program -- again, like command line

00:17:56,690 --> 00:17:59,380
arguments, or standard input or config files or whatever

00:17:59,380 --> 00:18:01,490
-- and then executing it and getting an output

00:18:01,490 --> 00:18:04,230
-- again this is like a single-stage computation --

00:18:04,230 --> 00:18:06,240
what partial evaluation lets you do is kind of

00:18:06,240 --> 00:18:08,910
pick out part of this process, say like, the

00:18:08,910 --> 00:18:11,960
first input being fed into the subject program, and

00:18:11,960 --> 00:18:13,250
kind of do it earlier.

00:18:13,250 --> 00:18:14,830
You can kind of time shift it into the

00:18:14,830 --> 00:18:17,150
parse, and say, well, this is, this is the

00:18:17,150 --> 00:18:18,960
computation I ultimately want to do at some point

00:18:18,960 --> 00:18:20,309
in the future. But I want to do this

00:18:20,309 --> 00:18:22,960
part of it now. And save the rest for

00:18:22,960 --> 00:18:25,400
later. So by time shifting this stuff into the

00:18:25,400 --> 00:18:27,750
parse, that means you take the program and the

00:18:27,750 --> 00:18:29,760
input, and instead of running this program, you treat

00:18:29,760 --> 00:18:32,370
it as data, treat it as input to a

00:18:32,370 --> 00:18:33,840
partial evaluator.

00:18:33,840 --> 00:18:35,960
So this is like a compiler or interpreter. It

00:18:35,960 --> 00:18:37,720
will read in a program and it will read

00:18:37,720 --> 00:18:39,330
in some of the input for that program, and

00:18:39,330 --> 00:18:41,590
then when you execute the partial evaluator or produce

00:18:41,590 --> 00:18:44,620
this residual program. And then later you can take

00:18:44,620 --> 00:18:47,410
that residual program and run it on a machine,

00:18:47,410 --> 00:18:49,090
and feed in the rest of the input to

00:18:49,090 --> 00:18:50,510
the original program.

00:18:50,510 --> 00:18:53,360
That will run and give you the final output.

00:18:53,360 --> 00:18:55,020
So the idea of a partial evaluator is it

00:18:55,020 --> 00:18:57,480
lets you kind of split a single-stage execution into

00:18:57,480 --> 00:19:00,100
two stages, by sort of time shifting the processing

00:19:00,100 --> 00:19:02,790
of some of the input from the future, where

00:19:02,790 --> 00:19:04,610
you're going to run the program, to the present.

00:19:04,610 --> 00:19:07,580
You can do some of the work earlier.

00:19:07,580 --> 00:19:09,200
So that's easy, easy enough to say, but, like,

00:19:09,200 --> 00:19:11,500
how, how do these partial evaluators work? Well, they

00:19:11,500 --> 00:19:13,530
work a lot like compilers and interpreters. They're just

00:19:13,530 --> 00:19:15,690
more complicated. And I don't have time to show

00:19:15,690 --> 00:19:18,500
you how to build one in Ruby, but briefly

00:19:18,500 --> 00:19:21,540
what happens is you read in some source code,

00:19:21,540 --> 00:19:23,950
just like an interpreter or a compiler. You build

00:19:23,950 --> 00:19:25,780
an abstract syntax tree just like an interpreter or

00:19:25,780 --> 00:19:28,179
a compiler, and- but then, you read some of

00:19:28,179 --> 00:19:29,570
the inputs to that program.

00:19:29,570 --> 00:19:31,250
And once you've read some of the inputs to

00:19:31,250 --> 00:19:33,520
the program, you analyze the program. You walk over

00:19:33,520 --> 00:19:35,360
the abstract syntax tree. You do, usually just a

00:19:35,360 --> 00:19:38,340
stacked analysis, to find all of the places where

00:19:38,340 --> 00:19:40,929
the inputs have been provided are used in the

00:19:40,929 --> 00:19:41,100
program.

00:19:41,100 --> 00:19:43,880
And once you've found those places, you can partially

00:19:43,880 --> 00:19:45,429
evaluate the program by going to all of those

00:19:45,429 --> 00:19:48,580
places where the inputs are being used, and evaluating

00:19:48,580 --> 00:19:50,880
them and then putting, like, new code in to

00:19:50,880 --> 00:19:53,679
replace them with the results of the evaluation. And

00:19:53,679 --> 00:19:55,309
then once you've finished doing that, you've got this

00:19:55,309 --> 00:19:58,299
residual program that you can emit.

00:19:58,299 --> 00:19:59,799
So I'd, you know, I can't really give you

00:19:59,799 --> 00:20:02,220
a whole-program example in Ruby in the time I've

00:20:02,220 --> 00:20:03,070
got, but I just want to show you a

00:20:03,070 --> 00:20:05,080
really basic example to just kind of give you

00:20:05,080 --> 00:20:06,340
a feel of what's going on here.

00:20:06,340 --> 00:20:08,690
So just for demo purposes I'm gonna show you

00:20:08,690 --> 00:20:10,200
this on the, on the, on the level of

00:20:10,200 --> 00:20:12,460
an individual method. So imagine we've got a, imagine

00:20:12,460 --> 00:20:14,340
we've got a partial evaluator for Ruby, and I've

00:20:14,340 --> 00:20:16,320
got this Ruby method which is power. So this

00:20:16,320 --> 00:20:18,140
is raised x to the power of n. So

00:20:18,140 --> 00:20:20,370
if I, if I passed in three as the

00:20:20,370 --> 00:20:23,419
value as n here, it's gonna do x multiplied

00:20:23,419 --> 00:20:26,419
by power of two, x is gonna recursively multiply

00:20:26,419 --> 00:20:29,000
x by itself three times, right.

00:20:29,000 --> 00:20:31,289
So say that I've my partial evaluator that I

00:20:31,289 --> 00:20:33,020
know that this method is gonna be called with

00:20:33,020 --> 00:20:34,850
five as the first argument. So I know I'm

00:20:34,850 --> 00:20:36,870
gonna be calling it with the value of n

00:20:36,870 --> 00:20:39,890
being five. So what the partial evaluator's gonna do

00:20:39,890 --> 00:20:41,820
is kind of start looking at this method and

00:20:41,820 --> 00:20:43,760
say, OK, so I know what the value of

00:20:43,760 --> 00:20:45,390
n is going to be, so I can find

00:20:45,390 --> 00:20:47,160
all of the other places where n is used

00:20:47,160 --> 00:20:48,780
and by doing that I can find all of

00:20:48,780 --> 00:20:50,830
the sub-expressions in this method that I can, I

00:20:50,830 --> 00:20:51,750
can evaluate now.

00:20:51,750 --> 00:20:52,960
I don't have to wait to find out what

00:20:52,960 --> 00:20:54,919
the value of x is, because these expressions are

00:20:54,919 --> 00:20:57,880
independent of the value of x. So once it's

00:20:57,880 --> 00:21:00,289
found those expressions it can start, like, evaluating them

00:21:00,289 --> 00:21:01,450
and replacing them.

00:21:01,450 --> 00:21:02,860
So what we're gonna do is, instead of having

00:21:02,860 --> 00:21:05,230
this power method that takes two arguments, we're gonna

00:21:05,230 --> 00:21:08,700
make a method called power_5, that only takes one

00:21:08,700 --> 00:21:11,010
argument, x, and the value of n is gonna

00:21:11,010 --> 00:21:13,130
be like fixed in this method. So all of

00:21:13,130 --> 00:21:15,190
those instances of n I'm just gonna turn into

00:21:15,190 --> 00:21:18,610
five, and then we can start partially evaluating this

00:21:18,610 --> 00:21:20,200
and say, well, I can already tell you what

00:21:20,200 --> 00:21:22,210
the value of five dot zero is gonna be.

00:21:22,210 --> 00:21:23,910
That's gonna be false.

00:21:23,910 --> 00:21:25,520
And then once you've done that, you've now got

00:21:25,520 --> 00:21:27,640
a conditional here, which you are able, so by

00:21:27,640 --> 00:21:30,059
sort of propogating the information about what expressions are

00:21:30,059 --> 00:21:32,080
available, you can say, well I know that this

00:21:32,080 --> 00:21:34,809
thing is just gonna evaluate to this guy here,

00:21:34,809 --> 00:21:36,890
right. Because it was, it's false. And now I've

00:21:36,890 --> 00:21:38,880
got this five minus one, I can evaluate that

00:21:38,880 --> 00:21:41,270
to get four. And then I can do some

00:21:41,270 --> 00:21:43,429
kind of, I can inline the body of this

00:21:43,429 --> 00:21:45,059
method here. If I know that I'm gonna be

00:21:45,059 --> 00:21:46,860
calling power with four and x, then I can

00:21:46,860 --> 00:21:49,700
just get this code in here with four substituted

00:21:49,700 --> 00:21:51,610
for the value of n. And then you can

00:21:51,610 --> 00:21:53,059
just keep doing the same thing -- you can

00:21:53,059 --> 00:21:55,160
say, well, four dot zero is gonna be false.

00:21:55,160 --> 00:21:56,630
So that means that bit of the program's gonna

00:21:56,630 --> 00:21:58,570
be x times power four minus one, and that's

00:21:58,570 --> 00:22:00,990
gonna be power three x and you can keep

00:22:00,990 --> 00:22:03,480
going, so you know, two, one, zero -- you

00:22:03,480 --> 00:22:05,660
keep generating more multiply by x's.

00:22:05,660 --> 00:22:07,039
When you get down to zero, you get into

00:22:07,039 --> 00:22:09,390
this situation where now you're saying, if zero dot

00:22:09,390 --> 00:22:11,770
zero, which is gonna evaluate to true, which means

00:22:11,770 --> 00:22:14,100
you're gonna end up with one there. So just

00:22:14,100 --> 00:22:15,580
to tidy that up a bit, you end up

00:22:15,580 --> 00:22:17,559
with a definition of power five that is just

00:22:17,559 --> 00:22:20,130
x multiplied by itself five times, then multiplied by

00:22:20,130 --> 00:22:22,280
one. And actually most partial evaluators will be smart

00:22:22,280 --> 00:22:24,100
enough to realize that if you've got something which

00:22:24,100 --> 00:22:26,049
is a number, and you multiply it by one,

00:22:26,049 --> 00:22:27,669
then you can just get rid of that.

00:22:27,669 --> 00:22:29,850
So this is kind of the residual program that's

00:22:29,850 --> 00:22:33,150
left over after the partial evaluation. And you can

00:22:33,150 --> 00:22:36,039
see it's made of bits of the original program,

00:22:36,039 --> 00:22:38,510
just kind of like rearranged and stuck together in

00:22:38,510 --> 00:22:41,450
different ways. The partial evaluator hasn't made any new

00:22:41,450 --> 00:22:43,350
Ruby. It's just used all of the existing Ruby

00:22:43,350 --> 00:22:44,840
and kind of moved bits of it around and

00:22:44,840 --> 00:22:47,190
figured out, like, what it should look like.

00:22:47,190 --> 00:22:48,500
And the point of doing this, of course, is

00:22:48,500 --> 00:22:51,770
that this version of power_5 should be faster, you

00:22:51,770 --> 00:22:54,320
know, this doesn't make any recursive method calls. It

00:22:54,320 --> 00:22:56,470
just multiplies x by itself five times, whereas this

00:22:56,470 --> 00:22:59,059
thing has got, like a, every recursive call, you've

00:22:59,059 --> 00:23:00,900
got a new stack frame, it does the conditional

00:23:00,900 --> 00:23:03,240
and then it does another multiplication and stuff like

00:23:03,240 --> 00:23:03,559
that.

00:23:03,559 --> 00:23:04,990
So this is like a better version of the

00:23:04,990 --> 00:23:06,799
original method if you, if you know that n

00:23:06,799 --> 00:23:09,150
is gonna be five.

00:23:09,150 --> 00:23:10,530
And just as a side note, this isn't the

00:23:10,530 --> 00:23:12,830
same thing as partial application, which you might be

00:23:12,830 --> 00:23:15,289
thinking about, which what partial application is when you've

00:23:15,289 --> 00:23:16,840
got a method like this, and you make a

00:23:16,840 --> 00:23:19,190
new method that just fixes one of the arguments

00:23:19,190 --> 00:23:21,520
to it. So I could define power_5 by just

00:23:21,520 --> 00:23:23,419
saying, well, call power with five as its first

00:23:23,419 --> 00:23:25,230
argument, and if I run that on the console

00:23:25,230 --> 00:23:27,610
then that does work, you know, power five of

00:23:27,610 --> 00:23:28,990
two is thirty-two, cause that's two to the power

00:23:28,990 --> 00:23:31,059
of five.

00:23:31,059 --> 00:23:33,380
But this new version of the method isn't any,

00:23:33,380 --> 00:23:35,450
isn't better than the original one. I mean, actually

00:23:35,450 --> 00:23:36,870
calling, this is gonna be slightly slower, because you

00:23:36,870 --> 00:23:39,870
get another stack frame. There's another method execution going

00:23:39,870 --> 00:23:40,179
on there.

00:23:40,179 --> 00:23:41,660
Another way of doing this in Ruby is, instead

00:23:41,660 --> 00:23:43,429
of defining a new method here, what I could

00:23:43,429 --> 00:23:45,900
do is turn this power method into a proc,

00:23:45,900 --> 00:23:47,750
and then I could use the curry method to

00:23:47,750 --> 00:23:49,490
turn it into a curry proc, and then I

00:23:49,490 --> 00:23:52,169
could call that with one argument, and that'll return

00:23:52,169 --> 00:23:53,780
me a new proc, which when I call it

00:23:53,780 --> 00:23:55,700
with a second argument, it gives me a new

00:23:55,700 --> 00:23:56,240
value back.

00:23:56,240 --> 00:23:59,409
So partial application is a little bit similar, but

00:23:59,409 --> 00:24:01,500
partial application is a technique that you do inside

00:24:01,500 --> 00:24:04,150
your program. You make new values, new function values,

00:24:04,150 --> 00:24:07,520
in sort of functional programming terms, that allow you

00:24:07,520 --> 00:24:09,340
to fix the arguments to some of your other

00:24:09,340 --> 00:24:12,350
functions. But partial evaluation is something that happens from

00:24:12,350 --> 00:24:14,409
the outside of your program. It's like a source-level

00:24:14,409 --> 00:24:17,320
transformation of your program that hopefully makes it sort

00:24:17,320 --> 00:24:21,580
of faster and more specialized to particular input values.

00:24:21,580 --> 00:24:22,549
So I just wanted to note that there are

00:24:22,549 --> 00:24:27,000
a couple of, like, useful applications of this technology.

00:24:27,000 --> 00:24:29,080
The main point of this is that you can

00:24:29,080 --> 00:24:32,110
take a general program and a partial evaluator can

00:24:32,110 --> 00:24:34,840
specialize it for you for a fixed input. So

00:24:34,840 --> 00:24:36,419
this is kind of the best of both worlds.

00:24:36,419 --> 00:24:39,620
You can write a general program that is, you

00:24:39,620 --> 00:24:42,130
know, maximally general and can accept lots of different

00:24:42,130 --> 00:24:44,500
kinds of input, but then you can use a

00:24:44,500 --> 00:24:47,400
partial evaluator to reach a specialized version of it

00:24:47,400 --> 00:24:49,870
that has got all of the overhead involved in

00:24:49,870 --> 00:24:51,450
choosing what kind of thing you're dealing with kind

00:24:51,450 --> 00:24:53,159
of baked out of it. And you can run

00:24:53,159 --> 00:24:55,179
the specialized version of the program, which'll hopefully be

00:24:55,179 --> 00:24:56,059
faster.

00:24:56,059 --> 00:24:58,409
So that's, that's pretty good. Some of the things

00:24:58,409 --> 00:25:00,120
you could do with that, for example, if you've

00:25:00,120 --> 00:25:03,720
got a web-server like Apache or, or EngineX, you

00:25:03,720 --> 00:25:05,530
know, that reads in a config file when it

00:25:05,530 --> 00:25:08,020
starts, after the config file controls the execution of

00:25:08,020 --> 00:25:10,030
the web-server, and you have to imagine that the

00:25:10,030 --> 00:25:12,940
web-server is spending some of its execution cycles, like,

00:25:12,940 --> 00:25:15,270
checking stuff that it has been configured to do.

00:25:15,270 --> 00:25:17,039
And so in principle what you could do is

00:25:17,039 --> 00:25:20,280
specialize the whole, you know, web-server, and give it

00:25:20,280 --> 00:25:22,590
just your config file as the input, and the

00:25:22,590 --> 00:25:24,330
partial evaluator will generate you a new version of

00:25:24,330 --> 00:25:27,820
the web-server that's designed just to run your config

00:25:27,820 --> 00:25:29,299
file, and hopefully all of the overhead of reading

00:25:29,299 --> 00:25:31,700
the config file and checking config flags is not

00:25:31,700 --> 00:25:33,309
gonna be part of the program anymore. It will

00:25:33,309 --> 00:25:35,190
have been partially evaluated.

00:25:35,190 --> 00:25:37,980
Similarly, this is the classic example in the partial

00:25:37,980 --> 00:25:40,000
evaluation literature, is like a ray tracer. If you

00:25:40,000 --> 00:25:42,140
had a three dimensional scene and you wanted to

00:25:42,140 --> 00:25:44,860
fly a camera through it, then you might end

00:25:44,860 --> 00:25:46,990
up rendering a million frames with your array tracer

00:25:46,990 --> 00:25:48,760
as your camera moves through the scene. But the

00:25:48,760 --> 00:25:50,900
scene's the same every time. So you could take

00:25:50,900 --> 00:25:53,010
a general ray tracer and specialize it with a

00:25:53,010 --> 00:25:56,059
respect to a particular scene file, and the partial

00:25:56,059 --> 00:25:57,929
evaluator would generate you a new ray tracer that

00:25:57,929 --> 00:26:00,260
can only ray trace that scene, and then if

00:26:00,260 --> 00:26:02,030
you run that a million times, and each time

00:26:02,030 --> 00:26:04,230
you move the camera slightly, all of the overhead

00:26:04,230 --> 00:26:06,669
of building all of the polygons and stuff in

00:26:06,669 --> 00:26:08,900
the scene and, you know, figuring out what all

00:26:08,900 --> 00:26:10,700
the directives in the scene file mean and stuff

00:26:10,700 --> 00:26:12,970
like that, will have gone away.

00:26:12,970 --> 00:26:15,850
And a third sort slightly more practical but more

00:26:15,850 --> 00:26:20,620
questionable example is, in, in Mac OS ten, the

00:26:20,620 --> 00:26:24,200
OpenGL pipline is bits of the OpenGL pipeline are

00:26:24,200 --> 00:26:29,850
written in LVM intermediate language, and it has implementations

00:26:29,850 --> 00:26:33,080
of stuff which is implemented in hardware on some

00:26:33,080 --> 00:26:37,570
GPUs. So Apple ships all of the software implementation

00:26:37,570 --> 00:26:39,220
of all the stuff that your GPU may or

00:26:39,220 --> 00:26:42,450
may not do, in LLVM intermediate representation, and then

00:26:42,450 --> 00:26:44,850
when you actually run it on your machine, and

00:26:44,850 --> 00:26:47,140
it can see what your GPU is capable of,

00:26:47,140 --> 00:26:49,299
all of the stuff that your GPU already does

00:26:49,299 --> 00:26:51,640
kind of gets, gets partially evaluated away, and it

00:26:51,640 --> 00:26:53,720
just get runs on hardware, whereas all the, all

00:26:53,720 --> 00:26:56,120
the features that your GPU doesn't have is gonna

00:26:56,120 --> 00:26:59,809
stay in the OpenGL pipeline written as software, right.

00:26:59,809 --> 00:27:03,179
So, anyway, at the beginning, I promised you I

00:27:03,179 --> 00:27:04,980
was gonna tell you a cool story. So here's

00:27:04,980 --> 00:27:07,429
the cool story.

00:27:07,429 --> 00:27:12,409
In 1971, this guy, Yoshihiko Futamura, realized something cool

00:27:12,409 --> 00:27:15,890
when he was working at Hitachi Central Research Laboratory.

00:27:15,890 --> 00:27:18,030
He was thinking about partial evaluation. He was thinking

00:27:18,030 --> 00:27:21,020
about how, with partial evaluation, you have your inputs

00:27:21,020 --> 00:27:23,470
and your subject program and you get your output,

00:27:23,470 --> 00:27:25,730
and you can use partial evaluation to time shift

00:27:25,730 --> 00:27:28,370
that bit to do, to earlier, so that you

00:27:28,370 --> 00:27:31,200
get this residual program that you can run later.

00:27:31,200 --> 00:27:32,730
And he was thinking about that in the context

00:27:32,730 --> 00:27:35,980
of interpreters and thinking, well, an interpreter is just

00:27:35,980 --> 00:27:38,570
a computer program, and it's just a program that

00:27:38,570 --> 00:27:41,140
I provide inputs to, and then that program runs

00:27:41,140 --> 00:27:42,850
and then I get some output. I mean, one

00:27:42,850 --> 00:27:44,860
of the inputs happens to be a program, but

00:27:44,860 --> 00:27:46,820
it's basically just a box that takes two inputs

00:27:46,820 --> 00:27:49,730
and I get some output out.

00:27:49,730 --> 00:27:51,860
So what would happen if I used partial evaluation

00:27:51,860 --> 00:27:53,909
to time, to sort of time shift some of

00:27:53,909 --> 00:27:56,340
this work, if I did this part of the

00:27:56,340 --> 00:27:58,520
computation earlier, so that I could do the rest

00:27:58,520 --> 00:28:01,299
of it later with the residual program. So here's

00:28:01,299 --> 00:28:03,309
what happens -- if you treat the interpreter as

00:28:03,309 --> 00:28:05,900
data rather than executing it as a program, you

00:28:05,900 --> 00:28:09,000
feed the interpreter into a partial evaluator, and you

00:28:09,000 --> 00:28:10,799
get this residual program out.

00:28:10,799 --> 00:28:12,230
So this is called, this is called kind of

00:28:12,230 --> 00:28:15,330
partially evaluating the interpreter with respect to the source

00:28:15,330 --> 00:28:17,770
program, so this is an input to the interpreter,

00:28:17,770 --> 00:28:19,360
and you put both of them into the partial

00:28:19,360 --> 00:28:21,279
evaluator, you get a residual program out, right? Which

00:28:21,279 --> 00:28:24,490
has done half of the work of the interpreter.

00:28:24,490 --> 00:28:26,159
And then at some later time you can take

00:28:26,159 --> 00:28:28,669
that residual program, run it, we know, with the

00:28:28,669 --> 00:28:30,690
original input to that program, and you get the

00:28:30,690 --> 00:28:33,850
output.

00:28:33,850 --> 00:28:36,140
So he was looking at this and thinking about

00:28:36,140 --> 00:28:38,580
it, and sort of saying, well, this thing I've

00:28:38,580 --> 00:28:42,570
got down here, that reads an input, and then

00:28:42,570 --> 00:28:45,169
produces output, like that's usually what we'd call the

00:28:45,169 --> 00:28:47,679
target program. This is a version of the source

00:28:47,679 --> 00:28:50,299
program that will execute directly on the underlying machine,

00:28:50,299 --> 00:28:51,929
so what I've got myself there is a target

00:28:51,929 --> 00:28:53,860
program. So that means that what I got out

00:28:53,860 --> 00:28:56,830
of the partial evaluator was a target program.

00:28:56,830 --> 00:28:59,059
So there's something up here which is read in

00:28:59,059 --> 00:29:01,690
a source program, and it's generated a target program,

00:29:01,690 --> 00:29:04,909
which I can run later. So what is this

00:29:04,909 --> 00:29:07,390
thing that I've got in the green box, anyone?

00:29:07,390 --> 00:29:10,549
Right, that's a compiler, right. So there's your compiler

00:29:10,549 --> 00:29:14,620
for free -- no refunds.

00:29:14,620 --> 00:29:16,990
So that's, that's pretty cool. How does that work?

00:29:16,990 --> 00:29:19,200
Does that, I mean that seems like, too good

00:29:19,200 --> 00:29:22,080
to be true, right. Let's just go through a

00:29:22,080 --> 00:29:23,039
quick example.

00:29:23,039 --> 00:29:27,169
So here's my, here's my simple interpreter written in

00:29:27,169 --> 00:29:29,669
Ruby. I've added some furniture, right. So the actual

00:29:29,669 --> 00:29:32,159
overall program that works as a simple interpreter is

00:29:32,159 --> 00:29:34,690
gonna read in the source and the starting environment

00:29:34,690 --> 00:29:37,919
by binding some variables to their values, from somewhere.

00:29:37,919 --> 00:29:39,960
It's gonna somehow acquire the source code in the

00:29:39,960 --> 00:29:42,929
environment, and just use treetop to load the grammar

00:29:42,929 --> 00:29:45,240
and then it's gonna, it's gonna make, instantiate the

00:29:45,240 --> 00:29:47,370
parse and then turn it into an abstract syntax

00:29:47,370 --> 00:29:49,010
tree, and then let's say it's just gonna print

00:29:49,010 --> 00:29:51,480
out the result of evaluating the original program in

00:29:51,480 --> 00:29:53,429
the environment that you provided, right.

00:29:53,429 --> 00:29:55,409
So if we're gonna, if we're gonna do what

00:29:55,409 --> 00:29:58,220
Futumura suggested, we're gonna take, we're gonna feed this

00:29:58,220 --> 00:30:00,120
into a partial evaluator and we're gonna give it

00:30:00,120 --> 00:30:03,500
the simple source program as like partial input, and

00:30:03,500 --> 00:30:05,419
then we're gonna evaluate as much of the program

00:30:05,419 --> 00:30:07,409
as we can and see what's left over.

00:30:07,409 --> 00:30:10,029
So that means that we're gonna provide a particular

00:30:10,029 --> 00:30:12,010
source, so one way or another, we're gonna arrange

00:30:12,010 --> 00:30:13,789
that when this thing tries to read its source

00:30:13,789 --> 00:30:15,740
it actually gets the string of a simple program,

00:30:15,740 --> 00:30:17,760
say so this x equals two, y equals x

00:30:17,760 --> 00:30:20,309
times three. It's just an arbitrary program.

00:30:20,309 --> 00:30:22,500
So, firstly our partial evaluator can do some stacked

00:30:22,500 --> 00:30:24,429
analysis of this program and can do some constant

00:30:24,429 --> 00:30:26,330
propagation and say well if source is gonna be

00:30:26,330 --> 00:30:28,850
that guy, then actually this instance of source here

00:30:28,850 --> 00:30:30,460
is gonna be that code, and we don't even

00:30:30,460 --> 00:30:33,570
need source anymore, it's not mentioned anywhere. And, and

00:30:33,570 --> 00:30:36,419
now it knows what the value of this string

00:30:36,419 --> 00:30:38,690
is, it can partial evaluate all of this stuff,

00:30:38,690 --> 00:30:41,360
so this treetop loading the grammar, and then building

00:30:41,360 --> 00:30:44,809
the, building the ast by parsing this string and

00:30:44,809 --> 00:30:47,159
then calling to_ast on it, that's, we've already got

00:30:47,159 --> 00:30:49,020
all the code to do that, and now we've

00:30:49,020 --> 00:30:50,820
got all of the inputs to do that. I

00:30:50,820 --> 00:30:52,700
mean, I guess we're also assuming that this, the,

00:30:52,700 --> 00:30:54,360
the grammar is available.

00:30:54,360 --> 00:30:56,490
So assuming we just do all of that work,

00:30:56,490 --> 00:30:58,159
we end up with a program that looks like

00:30:58,159 --> 00:31:00,150
this, which is just the abstract syntax tree should

00:31:00,150 --> 00:31:02,350
be the result of parsing that program and turning

00:31:02,350 --> 00:31:03,770
it into an abstract syntax tree, which is the

00:31:03,770 --> 00:31:05,870
stuff I showed you before.

00:31:05,870 --> 00:31:07,390
So it's able to do all of this work

00:31:07,390 --> 00:31:09,620
up front, because it knows what the source program's

00:31:09,620 --> 00:31:11,700
going to be. So all that this program does

00:31:11,700 --> 00:31:14,690
now is it reads in an environment from somewhere,

00:31:14,690 --> 00:31:17,010
and then it constructs the abstract syntax tree, this

00:31:17,010 --> 00:31:19,700
literal one, and then it just calls evaluate on

00:31:19,700 --> 00:31:23,000
it, with whatever the environment is.

00:31:23,000 --> 00:31:25,360
So what does calling evaluate on this abstract syntax

00:31:25,360 --> 00:31:26,500
tree do? Well, we've already got all the code

00:31:26,500 --> 00:31:27,929
to do that as well -- that's already part

00:31:27,929 --> 00:31:29,539
of the interpreter. I haven't showed it all on

00:31:29,539 --> 00:31:31,110
this slide, but I'm assuming that we've got all

00:31:31,110 --> 00:31:34,470
of that stuff built into the simple grammar, right.

00:31:34,470 --> 00:31:37,700
So this is the abstract syntax tree that we've

00:31:37,700 --> 00:31:39,220
got, and each one of these nodes, each one

00:31:39,220 --> 00:31:41,669
of these instances of a syntax class has got

00:31:41,669 --> 00:31:43,570
a definition of evaluate on it. So if a

00:31:43,570 --> 00:31:47,669
sequence evaluate looks like evaluate the first statement in

00:31:47,669 --> 00:31:49,470
the environment and then use that as the input

00:31:49,470 --> 00:31:52,029
to evaluate and the second statement in the environment,

00:31:52,029 --> 00:31:55,770
these assignments have got definitions that say evaluate the

00:31:55,770 --> 00:31:58,320
expression and then update the environment with a mapping

00:31:58,320 --> 00:32:00,220
from the variable named to the, to the value

00:32:00,220 --> 00:32:02,730
of evaluate in that expression.

00:32:02,730 --> 00:32:06,340
That multiply just says evaluate the left-hand expression, evaluate

00:32:06,340 --> 00:32:08,399
the right-hand one, multiply them together, and all of

00:32:08,399 --> 00:32:10,520
these things, like number, number and variable just have

00:32:10,520 --> 00:32:13,149
these simple definitions that either just return their value

00:32:13,149 --> 00:32:14,870
or in this case just pulls a value out

00:32:14,870 --> 00:32:16,220
of the environment.

00:32:16,220 --> 00:32:18,039
So we've got all of the data in this

00:32:18,039 --> 00:32:19,789
abstract syntax tree and we've got all of the

00:32:19,789 --> 00:32:22,690
code, and actually the partial evaluator can boil all

00:32:22,690 --> 00:32:24,350
of this down to just a couple of lines

00:32:24,350 --> 00:32:26,130
of Ruby code, right. So firstly, all of these

00:32:26,130 --> 00:32:29,100
places where, here we've got value and name and

00:32:29,100 --> 00:32:30,320
value, well we know that the value is two

00:32:30,320 --> 00:32:32,159
and we know that the name is x and

00:32:32,159 --> 00:32:33,740
we know that the value is three there, so

00:32:33,740 --> 00:32:35,460
all of those things can just be inlined in

00:32:35,460 --> 00:32:38,570
those definitions of those methods by the partial evaluator.

00:32:38,570 --> 00:32:40,260
And then all of these places where we're saying

00:32:40,260 --> 00:32:43,929
evaluate the expression, evaluate the left expression, evaluate the

00:32:43,929 --> 00:32:45,890
right expression, we know that they're gonna be two

00:32:45,890 --> 00:32:48,620
and environment x and three, so we can inline

00:32:48,620 --> 00:32:51,460
all of those things into these definitions here. And

00:32:51,460 --> 00:32:53,120
then again here we can see that the name

00:32:53,120 --> 00:32:55,409
is gonna be x, the name here's gonna be

00:32:55,409 --> 00:32:57,500
y, and the result of evaluating this expression is

00:32:57,500 --> 00:33:00,049
gonna be environment x times three, so we can,

00:33:00,049 --> 00:33:02,070
like, inline all of that stuff, and then finally

00:33:02,070 --> 00:33:04,840
up here we can see, well, evaluate the first

00:33:04,840 --> 00:33:07,169
expression is just gonna be this environment dot merge

00:33:07,169 --> 00:33:09,690
x maps to two, and this evaluate the second

00:33:09,690 --> 00:33:13,470
expression is, the second statement, sorry, is gonna be

00:33:13,470 --> 00:33:15,970
update the environment. It's a little bit tricky because

00:33:15,970 --> 00:33:17,390
the environment gets mentioned twice here.

00:33:17,390 --> 00:33:19,500
So what I'm gonna need to do is, you

00:33:19,500 --> 00:33:21,020
know, the partial evaluator will be able to do

00:33:21,020 --> 00:33:23,940
this just, evaluate that first expression and assign it

00:33:23,940 --> 00:33:26,330
to a variable and then use that variable here.

00:33:26,330 --> 00:33:27,350
So I've got to go out of scope, a

00:33:27,350 --> 00:33:28,880
lot of detail there, you can see that all

00:33:28,880 --> 00:33:30,460
of the code and data that you need is

00:33:30,460 --> 00:33:32,409
there for the taking, and it can all be

00:33:32,409 --> 00:33:33,409
filed down.

00:33:33,409 --> 00:33:34,909
So the code I've ended up with, just tidied

00:33:34,909 --> 00:33:37,500
up slightly, is that, right. Calling evaluate on the

00:33:37,500 --> 00:33:39,570
root node of that abstract syntax tree is gonna

00:33:39,570 --> 00:33:42,529
do this. The environment is the result of updating

00:33:42,529 --> 00:33:44,350
the environment with x is mapped to two, and

00:33:44,350 --> 00:33:45,870
then we make a new environment where y is

00:33:45,870 --> 00:33:48,059
mapped to whatever the value of x is times

00:33:48,059 --> 00:33:48,620
three.

00:33:48,620 --> 00:33:50,380
So going back to this original thing here, when

00:33:50,380 --> 00:33:52,789
we call ast dot evaluate with environment, we can

00:33:52,789 --> 00:33:55,029
replace all of this stuff with just that code

00:33:55,029 --> 00:33:57,250
that we just generate, right. So this is what

00:33:57,250 --> 00:33:59,809
we end up with. Read in the environment, make

00:33:59,809 --> 00:34:01,929
a new one by making x equal to two,

00:34:01,929 --> 00:34:04,429
and then print out the result of merging in

00:34:04,429 --> 00:34:06,309
y is equal to whatever the value of x

00:34:06,309 --> 00:34:08,510
is times three.

00:34:08,510 --> 00:34:10,950
And so comparing that to the simple program that

00:34:10,950 --> 00:34:14,760
we started with, that, in a, like, wave of

00:34:14,760 --> 00:34:16,099
my hand through all of that, but we can

00:34:16,099 --> 00:34:19,210
see that we've sort of compiled this simple program

00:34:19,210 --> 00:34:21,399
into Ruby now. We've got a Ruby program that

00:34:21,399 --> 00:34:24,129
does what this thing does. I mean, there's some

00:34:24,129 --> 00:34:27,109
machinery involving environments and stuff, but basically we've turned

00:34:27,109 --> 00:34:28,379
it into Ruby.

00:34:28,379 --> 00:34:29,440
But in order to do that, I didn't have

00:34:29,440 --> 00:34:32,069
to write any new Ruby. This thing here is

00:34:32,069 --> 00:34:35,149
just bits of the interpreter stuck together, and the

00:34:35,149 --> 00:34:37,639
partial evaluator has stuck together bits of source code

00:34:37,639 --> 00:34:39,349
from the interpreter in such a way that it's

00:34:39,349 --> 00:34:42,059
now a Ruby implementation of the program we started

00:34:42,059 --> 00:34:44,229
with. So that's kind of how you can compile

00:34:44,229 --> 00:34:46,709
stuff with partial evaluation.

00:34:46,709 --> 00:34:50,239
So this is called the first Futamura Projection, right.

00:34:50,239 --> 00:34:52,769
If you partially evaluate an interpreter with respect to

00:34:52,769 --> 00:34:57,190
some source code, you get a target program.

00:34:57,190 --> 00:34:59,049
So that's really good. Futamura was pretty pleased with

00:34:59,049 --> 00:35:02,430
himself when he realized that. So this is the

00:35:02,430 --> 00:35:04,259
picture I showed you before. When he was thinking

00:35:04,259 --> 00:35:06,969
about this, specifically he was thinking about the first

00:35:06,969 --> 00:35:09,019
part of this, and he was thinking, well, when

00:35:09,019 --> 00:35:11,200
I'm feeding an interpreter and a source program into

00:35:11,200 --> 00:35:13,329
the partial evaluator and getting a target program out

00:35:13,329 --> 00:35:16,400
later, I'm really just passing inputs into a program,

00:35:16,400 --> 00:35:19,569
so what would happen if I used partial evaluation

00:35:19,569 --> 00:35:22,089
to time shift some of this in, and do

00:35:22,089 --> 00:35:26,329
it earlier, if I, if I fed the interpreter

00:35:26,329 --> 00:35:28,579
into the partial evaluator first and got a residual

00:35:28,579 --> 00:35:30,489
program out that I could then feed the source

00:35:30,489 --> 00:35:31,450
program into, would that work?

00:35:31,450 --> 00:35:34,380
So he tried that. Here's what happens. So treating

00:35:34,380 --> 00:35:37,450
the partial evaluator's input, you can feed the partial

00:35:37,450 --> 00:35:40,119
evaluator and the interpreter into the partial evaluator, and

00:35:40,119 --> 00:35:41,839
when that runs, you get a residual program out.

00:35:41,839 --> 00:35:44,450
When you've got the residual program then later on

00:35:44,450 --> 00:35:45,989
you can run that with the source program as

00:35:45,989 --> 00:35:47,769
input, and you get a target program out, and

00:35:47,769 --> 00:35:50,299
then later on, you can run the target program

00:35:50,299 --> 00:35:52,140
with the original input to the program as input

00:35:52,140 --> 00:35:54,029
and get some output out, right.

00:35:54,029 --> 00:35:56,160
So that makes sense. That's just, we've just split

00:35:56,160 --> 00:35:58,369
it apart with more, you know, with time again.

00:35:58,369 --> 00:36:00,420
But when he looked at this, he thought, well

00:36:00,420 --> 00:36:01,430
that's what I've got here is that I've got

00:36:01,430 --> 00:36:04,039
a source program going in, into the residual program,

00:36:04,039 --> 00:36:06,619
and I get out the target program, so what

00:36:06,619 --> 00:36:09,349
is this residual program that I've got?

00:36:09,349 --> 00:36:12,729
Right. That's the compiler. So that means that what

00:36:12,729 --> 00:36:14,299
I got out of the thing here was the

00:36:14,299 --> 00:36:15,979
compiler, so that means that what I've got myself

00:36:15,979 --> 00:36:20,089
here is a compiler generator. So if, this means

00:36:20,089 --> 00:36:22,339
that if you've got any interpreter, you can geed

00:36:22,339 --> 00:36:25,200
it in, you can specialize, you can partially evaluate

00:36:25,200 --> 00:36:28,299
a partial evaluator with respect to that interpreter and

00:36:28,299 --> 00:36:30,979
you can get a compiler for that language.

00:36:30,979 --> 00:36:32,779
So this is sort of a higher order version

00:36:32,779 --> 00:36:33,650
of what I showed you the first time. This

00:36:33,650 --> 00:36:35,979
gives you a mechanism for generating a compiler, and

00:36:35,979 --> 00:36:37,739
then you can feed any source program into it.

00:36:37,739 --> 00:36:39,739
You don't need to involve the partial evaluator at

00:36:39,739 --> 00:36:42,319
this point. You've just got a bonified compiler that

00:36:42,319 --> 00:36:44,739
you can run and it will compile your language.

00:36:44,739 --> 00:36:46,979
So that's really cool. That's called the Second Futamura

00:36:46,979 --> 00:36:49,729
Projection. If you partially evaluate a partial evaluator with

00:36:49,729 --> 00:36:52,789
respect to an interpreter, you get a compiler.

00:36:52,789 --> 00:36:55,619
So Futamura was pretty pleased with himself when he

00:36:55,619 --> 00:36:58,459
realized that. And he was thinking about this, and

00:36:58,459 --> 00:37:00,709
specifically he was thinking about this first bit.

00:37:00,709 --> 00:37:05,390
And he was looking at this and thinking, well,

00:37:05,390 --> 00:37:07,150
really the parti- this is really just feeding input

00:37:07,150 --> 00:37:13,239
into a program. So what would happen if, if

00:37:13,239 --> 00:37:15,329
I time shifted this part of the execution and

00:37:15,329 --> 00:37:16,989
did it earlier so that I could get a

00:37:16,989 --> 00:37:19,069
residual program out, and then I could feed the

00:37:19,069 --> 00:37:22,219
interpreter into it later to do what I'm doing

00:37:22,219 --> 00:37:22,670
here.

00:37:22,670 --> 00:37:26,259
So here's what happens if you do that. So

00:37:26,259 --> 00:37:28,619
you treat the partial evaluator as input, and so

00:37:28,619 --> 00:37:31,380
you feed the partial evaluator and the partial evaluator

00:37:31,380 --> 00:37:35,049
into the partial evaluator. And you get out is

00:37:35,049 --> 00:37:37,219
a residual program, and then later on you feed

00:37:37,219 --> 00:37:39,299
the interpreter into the residual program and then that

00:37:39,299 --> 00:37:41,119
runs and then you get a compiler, and then

00:37:41,119 --> 00:37:43,709
later on you run the compiler with the source

00:37:43,709 --> 00:37:44,920
program as input and then you get a target

00:37:44,920 --> 00:37:47,499
program, and then later on, you run the target

00:37:47,499 --> 00:37:49,789
program with input as input and you get the

00:37:49,789 --> 00:37:50,579
output.

00:37:50,579 --> 00:37:53,410
But this thing here, the residual program that takes

00:37:53,410 --> 00:37:56,799
an interpreter and turns it into a compiler, is

00:37:56,799 --> 00:37:59,229
a compiler generator. So that means that what we

00:37:59,229 --> 00:38:00,799
got out of the thing here was the compiler

00:38:00,799 --> 00:38:04,769
generator. So what's this thing we've got up top?

00:38:04,769 --> 00:38:10,789
It's a compiler generator generator.

00:38:10,789 --> 00:38:13,619
So this is the Third Futamura Projection, right. If

00:38:13,619 --> 00:38:16,459
you partially evaluate a partial evaluator with respect to

00:38:16,459 --> 00:38:20,160
a partial evaluator, you get a compiler generator, and

00:38:20,160 --> 00:38:22,979
thankfully, we can't take it any further than that,

00:38:22,979 --> 00:38:24,979
because if you did this again, you'd just be,

00:38:24,979 --> 00:38:27,269
you'd still be partially evaluating a partial evaluator with

00:38:27,269 --> 00:38:29,099
respect to a partial evaluator. So there are only

00:38:29,099 --> 00:38:31,640
three Futamura Projections.

00:38:31,640 --> 00:38:33,459
So this is really cool, and this is why

00:38:33,459 --> 00:38:34,499
I wanted to tell you about this. I think

00:38:34,499 --> 00:38:38,329
it's funny and interesting and like unusual. However, it

00:38:38,329 --> 00:38:40,619
doesn't mean that we don't need compiler writers anymore,

00:38:40,619 --> 00:38:43,829
right. Partial evaluation is a fully general technique for

00:38:43,829 --> 00:38:46,170
evaluating bits of computer programs. SO it gets rid

00:38:46,170 --> 00:38:49,559
of the interpretive overhead of the com-= of the,

00:38:49,559 --> 00:38:52,609
of evaluating a program, but it doesn't do any

00:38:52,609 --> 00:38:54,969
of the clever stuff like inventing new data structures

00:38:54,969 --> 00:38:59,119
or optimizations or doing anything kind of platform-specific. So

00:38:59,119 --> 00:39:01,299
we still need smart people to write compilers to

00:39:01,299 --> 00:39:02,789
make our programs go fast.

00:39:02,789 --> 00:39:06,779
But this technique does remove some of the overhead

00:39:06,779 --> 00:39:09,900
of interpretation, right. It removes all of that stuff,

00:39:09,900 --> 00:39:13,609
that involves parsing and generating code and all of

00:39:13,609 --> 00:39:15,930
that stuff. So if you're sufficiently interested in this,

00:39:15,930 --> 00:39:18,259
that you'd like to learn more, then there's a

00:39:18,259 --> 00:39:22,190
really interesting book called Partial Evaluation and Automatic Program

00:39:22,190 --> 00:39:24,819
Generation, which is res- which is now available for

00:39:24,819 --> 00:39:27,809
free, so I've, if you go to that url

00:39:27,809 --> 00:39:29,209
there you can download a copy of that. It's

00:39:29,209 --> 00:39:32,089
a really good text book. I recommend it.

00:39:32,089 --> 00:39:34,200
Also, various bits of software that you may or

00:39:34,200 --> 00:39:36,049
may not be familiar with, you use techniques like

00:39:36,049 --> 00:39:38,440
this, or like the git and LLVM, and the

00:39:38,440 --> 00:39:41,650
bits of the PyPy toolchains like Rpython and the,

00:39:41,650 --> 00:39:43,869
the VM and the git that underlied that, used

00:39:43,869 --> 00:39:47,219
some of these program specialization techniques.

00:39:47,219 --> 00:39:49,160
Rubinius sits on top of LLVM, so when you

00:39:49,160 --> 00:39:51,359
use Rubinius, stuff that's a little bit like this

00:39:51,359 --> 00:39:54,229
is happening, and, and there's a Ruby implementation called

00:39:54,229 --> 00:39:57,180
Topaz, that sits on top of the PyPy toolchain

00:39:57,180 --> 00:39:59,759
and is a Ruby implementation that's written in Python.

00:39:59,759 --> 00:40:02,140
So if you use Topax Ruby implementation then it's

00:40:02,140 --> 00:40:04,719
kind of stuff like this is happening inside Topaz

00:40:04,719 --> 00:40:06,249
when you run your program. It happens at run

00:40:06,249 --> 00:40:09,089
time rather than compile time.

00:40:09,089 --> 00:40:13,170
And quite aside from the partial evaluation stuff, Rubinius

00:40:13,170 --> 00:40:16,229
and JRuby are great because they are compilers that

00:40:16,229 --> 00:40:19,359
have got, like, interesting and accessible implementation. So if

00:40:19,359 --> 00:40:21,699
you feel like you could become interested, sort of

00:40:21,699 --> 00:40:23,869
in the spirit of Matz's keynote yesterday, if you

00:40:23,869 --> 00:40:25,440
feel like you want to get involved with stuff

00:40:25,440 --> 00:40:27,160
and you're interested in these kind of programs that

00:40:27,160 --> 00:40:29,690
generate programs, then you could do a lot worse

00:40:29,690 --> 00:40:31,819
than cracking open Rubinius or JRuby and having a

00:40:31,819 --> 00:40:33,900
look at how they work and maybe, you know,

00:40:33,900 --> 00:40:35,979
submitting a pull request or something.

00:40:35,979 --> 00:40:38,799
So much more generally than that, if you're generally

00:40:38,799 --> 00:40:40,749
interested in this sort of thing, I've written a

00:40:40,749 --> 00:40:43,380
book about all this sort of thing, which uses

00:40:43,380 --> 00:40:44,999
Ruby to go over all of these kinds of

00:40:44,999 --> 00:40:48,339
things and interperters and compilers and the lambic calculus

00:40:48,339 --> 00:40:51,029
and cellular atomator and stuff? So if you're interested

00:40:51,029 --> 00:40:52,509
there's a book that you can read.

00:40:52,509 --> 00:40:55,119
There's a website for it. I've already given a

00:40:55,119 --> 00:40:56,789
discount card so you can get fifty percent off

00:40:56,789 --> 00:40:59,079
if you use RubyConf as the discount code.

00:40:59,079 --> 00:41:01,329

YouTube URL: https://www.youtube.com/watch?v=n_k6O50Nd-4


