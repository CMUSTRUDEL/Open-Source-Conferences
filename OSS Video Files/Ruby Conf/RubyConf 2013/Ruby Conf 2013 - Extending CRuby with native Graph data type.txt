Title: Ruby Conf 2013 - Extending CRuby with native Graph data type
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Andy Pliszka

Reading of the CRuby (MRI) source code provides unparalleled insight into the Ruby language. During the talk we will add new native Graph data type to CRuby. The new Graph data structure will be simple but on par with other native types such as Array or Hash. This talk will demonstrate that it is easy to experiment with CRuby and extend it in C. We will experience the speed advantage of using C to boost Ruby performance. We will implement a few of the greatest hits of graph algorithms: Breath First Search, Dijkstra, and Minimum Spanning Tree.

Help us caption & translate this video!

http://amara.org/v/FG5R/
Captions: 
	00:00:16,560 --> 00:00:17,480
ANDY PLISZKA: My name is Andy.

00:00:17,660 --> 00:00:20,560
I work at Pivotal Labs in New York City.

00:00:20,630 --> 00:00:21,619
And today I'm gonna show you

00:00:21,619 --> 00:00:24,840
how to extend Ruby in C.

00:00:24,840 --> 00:00:26,300
And we're gonna concentrate on CRuby,

00:00:26,300 --> 00:00:29,710
and I'll show you how to build Ruby and extend it.

00:00:29,710 --> 00:00:32,649
So this is pretty much the agenda. I'm gonna,

00:00:32,649 --> 00:00:34,100
I'm gonna explain a couple of problems that I'm

00:00:34,100 --> 00:00:36,750
trying to solve with this talk, and then we're

00:00:36,750 --> 00:00:39,260
gonna build Ruby, set up Debugger, look at the

00:00:39,260 --> 00:00:43,170
CRuby source code, write a couple of simple extensions,

00:00:43,170 --> 00:00:44,399
and then, at the end, we're gonna write a

00:00:44,399 --> 00:00:46,819
simple graph implementation in, in CRuby.

00:00:46,819 --> 00:00:49,960
K. So what are the problems? If you are

00:00:49,960 --> 00:00:52,449
addressing a big, big dat- big graph or big

00:00:52,449 --> 00:00:54,260
data problems, what do you need? You need a

00:00:54,260 --> 00:00:58,190
lot of memory. You need speed, and write algorithms,

00:00:58,190 --> 00:00:58,960
right.

00:00:58,960 --> 00:01:01,559
Then, and when you think about big data problems

00:01:01,559 --> 00:01:04,960
and big data, big graph problems, usually you're gonna

00:01:04,960 --> 00:01:08,240
face this: that Ruby is slow. I think everyone

00:01:08,240 --> 00:01:13,090
faced this kind of question in our professional life.

00:01:13,090 --> 00:01:16,740
And I do not totally agree with this statement

00:01:16,740 --> 00:01:19,140
because, what I think is that objects are slow.

00:01:19,140 --> 00:01:22,490
So object-oriented abstractions are slow.

00:01:22,490 --> 00:01:26,000
So objects actually have a lot of overhead. They

00:01:26,000 --> 00:01:29,659
require extra memory. They require a lot of indirection

00:01:29,659 --> 00:01:32,100
and they result in fragmented memory, so you can

00:01:32,100 --> 00:01:35,640
actually lose some of the performance. And that gets

00:01:35,640 --> 00:01:38,299
even worse when you work with arrays of objects.

00:01:38,299 --> 00:01:40,320
And now you, if you have an array, it

00:01:40,320 --> 00:01:42,579
doesn't really matter if you, if you have, let's

00:01:42,579 --> 00:01:44,219
say, ten thousand objects, but if you have a

00:01:44,219 --> 00:01:46,859
million or a billion of objects, that overhead is

00:01:46,859 --> 00:01:48,270
really substantial.

00:01:48,270 --> 00:01:51,560
And it prevents you from actually solving problems. So

00:01:51,560 --> 00:01:53,490
when you work with arrays of objects, you have

00:01:53,490 --> 00:01:57,409
more int- overhead, more indirection, more memory fragmentation, and

00:01:57,409 --> 00:01:59,859
then all the CPU caches and all the optimization

00:01:59,859 --> 00:02:01,969
that you get from the CPUs are pretty, pretty

00:02:01,969 --> 00:02:03,890
much wasted.

00:02:03,890 --> 00:02:06,539
And it's not only a Ruby problem. It's, it's

00:02:06,539 --> 00:02:10,319
a problem really with every object-oriented language. So that

00:02:10,319 --> 00:02:12,080
was a problem at the beginning of the Smalltalk,

00:02:12,080 --> 00:02:14,010
right, when pretty much you had to have the

00:02:14,010 --> 00:02:17,400
most powerful computer to run Smalltalk. Java had the

00:02:17,400 --> 00:02:19,750
same problem in the beginning. That's why, why, that's

00:02:19,750 --> 00:02:21,760
one of the reasons why Java has primitive types.

00:02:21,760 --> 00:02:23,970
So you can actually work with bytes of, bytes

00:02:23,970 --> 00:02:27,890
in memory instead of arrays of objects. And Python,

00:02:27,890 --> 00:02:30,780
Python is actually solving it by, by using NumPy

00:02:30,780 --> 00:02:34,540
and actually using C extensions. And even C, when

00:02:34,540 --> 00:02:37,510
you talk to people who are doing high-frequency trading,

00:02:37,510 --> 00:02:39,570
for example, they also have a lot of tricks

00:02:39,570 --> 00:02:42,460
that, to speed up C++. So it's not only

00:02:42,460 --> 00:02:45,110
Ruby that's, that's slow but it's a lot of

00:02:45,110 --> 00:02:46,920
languages that have this problem.

00:02:46,920 --> 00:02:48,740
So what is the solution? Solution is Ruby plus

00:02:48,740 --> 00:02:51,190
C. We can do it. You can combine Ruby

00:02:51,190 --> 00:02:53,850
productivity and ecosystem, all the gems and all the

00:02:53,850 --> 00:02:56,160
tools that we have, especially for testing - like

00:02:56,160 --> 00:02:59,430
RSpec or MiniTest - with C efficiency, speed, and

00:02:59,430 --> 00:03:01,740
algorithms. Because when you really think about it, most

00:03:01,740 --> 00:03:04,040
of the algorithms are already written in C, right,

00:03:04,040 --> 00:03:05,660
they originally were written in C.

00:03:05,660 --> 00:03:07,660
So why even rewrite them in Ruby if you

00:03:07,660 --> 00:03:12,090
can use them directly? So what you get is

00:03:12,090 --> 00:03:14,960
you can put all your high-level abstractions in Ruby.

00:03:14,960 --> 00:03:18,590
So all the modeling, all the algorithm coordination, all

00:03:18,590 --> 00:03:21,540
the analysis and scripting, do it in Ruby. But

00:03:21,540 --> 00:03:24,690
all of the low-level operations, like algorithm implementation and

00:03:24,690 --> 00:03:28,870
manipulation of large in-memory data structures, you can do

00:03:28,870 --> 00:03:29,840
it in C.

00:03:29,840 --> 00:03:33,350
And in this way you can also integrate with,

00:03:33,350 --> 00:03:37,070
with you know, linear algebra libraries and improve that

00:03:37,070 --> 00:03:39,430
and other stuff. So you can make this stuff

00:03:39,430 --> 00:03:41,680
that matters and that requires speed you can write

00:03:41,680 --> 00:03:43,660
it in C, but you can actually control it

00:03:43,660 --> 00:03:45,920
from Ruby.

00:03:45,920 --> 00:03:49,590
So my goal for this talk today is to

00:03:49,590 --> 00:03:52,050
give you a tool set so you can go

00:03:52,050 --> 00:03:56,580
home and actually experiment with CRuby on your own

00:03:56,580 --> 00:03:59,910
at home. And the first step in that journey

00:03:59,910 --> 00:04:03,090
is actually building your own version of Ruby. And

00:04:03,090 --> 00:04:05,660
that's what we're gonna do. So the first, first

00:04:05,660 --> 00:04:08,920
we have to check it out from, from GitHub,

00:04:08,920 --> 00:04:12,770
right. Set up the, set up the, check out

00:04:12,770 --> 00:04:16,039
the stable version of Ruby. This is Ruby 2.0,

00:04:16,039 --> 00:04:16,759
build 247.

00:04:16,759 --> 00:04:20,039
And then you have to configure it. So if

00:04:20,039 --> 00:04:21,470
you are running on Mac, you probably want to

00:04:21,470 --> 00:04:24,759
install OpenSSL because you will need it for RubyGems.

00:04:24,759 --> 00:04:28,390
Then you run auto configuration tool and then you

00:04:28,390 --> 00:04:32,760
have to configure your, your Ruby source code. And

00:04:32,760 --> 00:04:34,760
you can just copy and paste this into terminal.

00:04:34,760 --> 00:04:36,980
What it does - I'll explain what each element

00:04:36,980 --> 00:04:37,210
does.

00:04:37,210 --> 00:04:39,760
For example, this prefix, it says that the Ruby

00:04:39,760 --> 00:04:42,010
that you, you are building, you want to install

00:04:42,010 --> 00:04:45,470
it in your home folder under myRuby. You want

00:04:45,470 --> 00:04:48,060
to use this OpenSSL that comes from, from brew,

00:04:48,060 --> 00:04:52,790
from the brew cellar, and you want optimization flags

00:04:52,790 --> 00:04:56,970
set to O zero. This is basically no optimization

00:04:56,970 --> 00:04:59,470
because you want to set up a Ruby version

00:04:59,470 --> 00:05:02,750
that has no optimizations so it's easier to debug,

00:05:02,750 --> 00:05:04,740
because if you set this to a higher level,

00:05:04,740 --> 00:05:07,900
actually compiler will rearrange the code and it makes

00:05:07,900 --> 00:05:09,570
debugging much harder.

00:05:09,570 --> 00:05:13,340
And then you have to specify dash g for,

00:05:13,340 --> 00:05:17,150
for full debugging, so. And I use disable install-doc

00:05:17,150 --> 00:05:19,020
just to make it faster so we don't install

00:05:19,020 --> 00:05:21,490
docs. So once you have, once you configure it,

00:05:21,490 --> 00:05:23,070
and you run it, this is pretty much what

00:05:23,070 --> 00:05:25,320
you will get. Just for your sanity check, this

00:05:25,320 --> 00:05:26,720
is pretty much the result that you should get.

00:05:26,720 --> 00:05:28,290
It's gonna run for a couple of minutes, then

00:05:28,290 --> 00:05:31,000
it's gonna finish and you will have a configured

00:05:31,000 --> 00:05:32,510
version of Ruby.

00:05:32,510 --> 00:05:34,430
If you are running on Linux, it's slightly different

00:05:34,430 --> 00:05:37,040
but only a little bit. Instead of using brew

00:05:37,040 --> 00:05:40,770
you can use apt-get to install SSL, auto configure

00:05:40,770 --> 00:05:43,860
it. And the flags are almost exactly the same

00:05:43,860 --> 00:05:46,170
except for the debugger because on, on Mac we

00:05:46,170 --> 00:05:49,750
use LLDB and on Linux you use GDB. So

00:05:49,750 --> 00:05:51,800
that's the only difference really.

00:05:51,800 --> 00:05:54,380
So once you configure it, well you have to

00:05:54,380 --> 00:05:56,610
compile it and build it. And you can do

00:05:56,610 --> 00:06:00,110
it with just single command make. This first compile

00:06:00,110 --> 00:06:03,720
takes couple of minutes, incremental compiles are much faster.

00:06:03,720 --> 00:06:05,460
And this is pretty much what you should get

00:06:05,460 --> 00:06:07,770
on your screen. It basically should say that it's

00:06:07,770 --> 00:06:10,790
linking Ruby and you should have your Ruby version

00:06:10,790 --> 00:06:13,700
built.

00:06:13,700 --> 00:06:16,210
Once you build your, your, your Ruby, what, what

00:06:16,210 --> 00:06:20,510
you want to do is run Unit tests. CRuby

00:06:20,510 --> 00:06:23,520
actually comes with around fourteen thousand tests that you

00:06:23,520 --> 00:06:27,330
can run by running make check, and it will

00:06:27,330 --> 00:06:28,820
tell, take some time but it will give you

00:06:28,820 --> 00:06:32,050
confidence that all the configuration and the whole build

00:06:32,050 --> 00:06:36,110
that you have is actually correct. And one note,

00:06:36,110 --> 00:06:37,970
if you, if you're gonna run into couple of

00:06:37,970 --> 00:06:41,480
errors, what's important is make sure that you run

00:06:41,480 --> 00:06:45,919
this command. This actually fixes some of the security

00:06:45,919 --> 00:06:49,220
on, on the folder. And the, what I notice

00:06:49,220 --> 00:06:51,450
is without running that command some of the tests

00:06:51,450 --> 00:06:54,419
around like fourteen tests actually fails and it's a

00:06:54,419 --> 00:06:56,610
false negative.

00:06:56,610 --> 00:06:58,790
Once you run the check and everything is green,

00:06:58,790 --> 00:07:00,550
well you can install it. And you can install

00:07:00,550 --> 00:07:04,030
it by running make install. And you can see

00:07:04,030 --> 00:07:07,550
here that it actually installed in, in that myRuby

00:07:07,550 --> 00:07:10,310
folder. So this will actually copy all the binaries

00:07:10,310 --> 00:07:14,010
and put it in the tilde slash my, myRuby

00:07:14,010 --> 00:07:17,750
folder. So you can use, you can always, you

00:07:17,750 --> 00:07:20,210
always know that it's there. And it will install

00:07:20,210 --> 00:07:23,470
a couple of basic gems and you are almost

00:07:23,470 --> 00:07:25,800
ready to use it.

00:07:25,800 --> 00:07:27,449
What you have to do next, you have to

00:07:27,449 --> 00:07:31,169
configure the terminal that you are in. You, you

00:07:31,169 --> 00:07:34,320
set the path to myruby path, so it, it

00:07:34,320 --> 00:07:37,730
first searches in the bin folder under myRuby, and

00:07:37,730 --> 00:07:39,919
you also want to configure gem home and gem

00:07:39,919 --> 00:07:42,370
path so that it includes myRuby. So my goal

00:07:42,370 --> 00:07:45,080
here is to give you a single terminal where

00:07:45,080 --> 00:07:48,449
you have your own version of Ruby for experimentation

00:07:48,449 --> 00:07:51,900
without actually changing any shell script configuration files so

00:07:51,900 --> 00:07:54,180
your RVM, it doesn't really effect your RVM. This

00:07:54,180 --> 00:07:56,870
is your private send box that it can, you

00:07:56,870 --> 00:07:58,960
can, you can run all your code and experiment.

00:07:58,960 --> 00:08:00,620
So even if you break your Ruby you will

00:08:00,620 --> 00:08:04,340
not break your, your work set up, et cetera.

00:08:04,340 --> 00:08:06,300
So once you set up these paths, you can

00:08:06,300 --> 00:08:09,120
verify that Ruby is installed correctly just by running

00:08:09,120 --> 00:08:11,800
which and you see all these, all these commands

00:08:11,800 --> 00:08:14,490
actually include myRuby. And you can even test if

00:08:14,490 --> 00:08:17,490
irb, by raising, you should see myRuby in that,

00:08:17,490 --> 00:08:20,010
in that path. This is pretty much a sanity

00:08:20,010 --> 00:08:24,669
check for you that everything is set up correctly.

00:08:24,669 --> 00:08:26,960
Next thing that you have to cor- verify is

00:08:26,960 --> 00:08:31,180
make sure that the gem, gem set up correctly.

00:08:31,180 --> 00:08:34,250
Because, what I want you to do is to

00:08:34,250 --> 00:08:37,459
be able to use your own compiled version of

00:08:37,459 --> 00:08:39,990
Ruby to run pretty much any Ruby software that

00:08:39,990 --> 00:08:42,940
you can imagine. Your production software or, you know,

00:08:42,940 --> 00:08:45,540
Rails applications, et cetera, so you can experiment with

00:08:45,540 --> 00:08:48,619
your, with the software that you use every day.

00:08:48,619 --> 00:08:52,189
So here you run gem environment. Always myRuby should

00:08:52,189 --> 00:08:56,009
be there. You can verify it that way. These

00:08:56,009 --> 00:08:58,869
are the gems that I installed by default. And

00:08:58,869 --> 00:09:03,689
they are stored in this folder, right. So pretty

00:09:03,689 --> 00:09:05,689
much we are, we are ready to install Rails,

00:09:05,689 --> 00:09:08,689
now, actually use our own compiled version of Ruby

00:09:08,689 --> 00:09:11,970
to install Rails and run a Rails application.

00:09:11,970 --> 00:09:14,029
So when you run gem install in the same

00:09:14,029 --> 00:09:17,829
terminal it will actually install all the required gems,

00:09:17,829 --> 00:09:20,220
and then you can create a new Rails app

00:09:20,220 --> 00:09:22,680
and, and run it and pretty much, this, this

00:09:22,680 --> 00:09:25,709
Rails app is actually using your own compiled version

00:09:25,709 --> 00:09:28,769
of Ruby. So within roughly thirty minutes you have

00:09:28,769 --> 00:09:34,490
your own sandbox for experimentation with C, C code.

00:09:34,490 --> 00:09:36,339
If you're using RubyMine, the set up is also

00:09:36,339 --> 00:09:38,939
easy. Just open RubyMine and set up DSDK to

00:09:38,939 --> 00:09:42,910
point to myRuby version of Ruby. And that pretty

00:09:42,910 --> 00:09:45,389
much completes the, the level one. So you, we

00:09:45,389 --> 00:09:48,050
build our own version of Ruby so we have

00:09:48,050 --> 00:09:50,050
all the source code, source code for Ruby. We

00:09:50,050 --> 00:09:51,759
can actually go there and play with it and

00:09:51,759 --> 00:09:54,949
modify it and experiment with it. And you, you

00:09:54,949 --> 00:09:58,529
can, you can even run Rails apps. It's just

00:09:58,529 --> 00:10:00,769
like any, like, like Ruby that you would install

00:10:00,769 --> 00:10:03,100
using RVM. And it shouldn't take you longer than

00:10:03,100 --> 00:10:06,749
thirty minutes. So that's the first step in our

00:10:06,749 --> 00:10:07,470
journey.

00:10:07,470 --> 00:10:09,410
The next step is, because we're gonna do a

00:10:09,410 --> 00:10:14,300
lot of C, C coding, well, it's always useful,

00:10:14,300 --> 00:10:17,869
very useful to have a debugger set up. So

00:10:17,869 --> 00:10:19,579
there are multiple options that you can use. If

00:10:19,579 --> 00:10:21,600
you are on Mac you can LLDB, if you're

00:10:21,600 --> 00:10:24,470
on Linux you can use GDB. And the, if

00:10:24,470 --> 00:10:27,689
you prefer GUIs you can use Xcode. And of

00:10:27,689 --> 00:10:30,990
course very VIM and emacs are also supported.

00:10:30,990 --> 00:10:36,579
So this is how you would actually debug Ruby

00:10:36,579 --> 00:10:41,889
running the upstring Ruby file using LLDB. So you

00:10:41,889 --> 00:10:45,240
basically provide a path to the binary, provide the

00:10:45,240 --> 00:10:47,339
string, provide it, provide a name with a file

00:10:47,339 --> 00:10:50,860
and the file is just basically upcasing hello. And

00:10:50,860 --> 00:10:53,329
then when you run, when you enter LLDB, you

00:10:53,329 --> 00:10:55,839
would set a break point at a line, at

00:10:55,839 --> 00:10:58,619
this line in this file. This is the, the

00:10:58,619 --> 00:11:01,480
actual, the first line of the upcase method that's

00:11:01,480 --> 00:11:02,839
implemented in C.

00:11:02,839 --> 00:11:05,079
And then when you run it, it will actually

00:11:05,079 --> 00:11:08,970
run, run your code, run Ruby interpreter on, on

00:11:08,970 --> 00:11:11,499
that, on that upstring rb file. And what actually

00:11:11,499 --> 00:11:13,610
stop, you can see the little arrow here. It

00:11:13,610 --> 00:11:17,339
was gonna stop on the first, first line of

00:11:17,339 --> 00:11:20,699
the upcase in string. String dot c. So this

00:11:20,699 --> 00:11:22,879
allows you to debug from command line, and if

00:11:22,879 --> 00:11:25,759
you're on Mac, you can actually use Xcode to

00:11:25,759 --> 00:11:30,009
debug your, your CRuby source code.

00:11:30,009 --> 00:11:35,819
OK, so now we have, we have Ruby compiled

00:11:35,819 --> 00:11:37,519
and we can debug it. So the next step

00:11:37,519 --> 00:11:39,439
is actually take a look, we will take a

00:11:39,439 --> 00:11:42,559
look at the C Ruby source code. And we'll

00:11:42,559 --> 00:11:46,649
take a look at the folder structure.

00:11:46,649 --> 00:11:49,850
So this is my, this is pretty much the

00:11:49,850 --> 00:11:53,369
folder when I downloaded check out Ruby from, from

00:11:53,369 --> 00:11:57,220
GitHub. Pretty much 99% of the files that you

00:11:57,220 --> 00:12:00,649
want to worry about are, are files here. The,

00:12:00,649 --> 00:12:02,970
the, the C files in the main folder, like

00:12:02,970 --> 00:12:08,600
things like array, or big num, class. Most of

00:12:08,600 --> 00:12:11,449
the important files are in the root folder, and

00:12:11,449 --> 00:12:13,819
the only additional folder that you want to check

00:12:13,819 --> 00:12:16,439
out at the very beginning is probably the extension

00:12:16,439 --> 00:12:17,069
folder.

00:12:17,069 --> 00:12:20,420
So here, for example, you will find things like

00:12:20,420 --> 00:12:25,699
psych, all the extensions that, that you, you probably

00:12:25,699 --> 00:12:30,509
use. Json. And these extensions are actually a good

00:12:30,509 --> 00:12:33,459
learning tool because they are usually small, so you

00:12:33,459 --> 00:12:35,689
can actually see how they were implemented. So for

00:12:35,689 --> 00:12:38,249
example, JSON, JSON's a little bit harder, could be,

00:12:38,249 --> 00:12:40,420
but find one that is only a few files

00:12:40,420 --> 00:12:42,939
and just try to understand how it's implemented. It's

00:12:42,939 --> 00:12:45,259
a good exercise.

00:12:45,259 --> 00:12:46,279
So let's take a look at a couple of

00:12:46,279 --> 00:12:50,069
files that, that we have here. So let's start

00:12:50,069 --> 00:12:53,879
with, let's see how fixnum is actually implemented in

00:12:53,879 --> 00:12:56,720
C, right. So it's gonna be in numeric, numeric

00:12:56,720 --> 00:13:02,439
dev C file. So every file that you open,

00:13:02,439 --> 00:13:03,839
you probably want to go to the bottom of

00:13:03,839 --> 00:13:06,410
the file and then you scroll up and look

00:13:06,410 --> 00:13:07,269
for init function.

00:13:07,269 --> 00:13:14,269
It's a big file. There we go. You are

00:13:14,290 --> 00:13:17,470
looking for this init function, and this is the

00:13:17,470 --> 00:13:22,629
entry point for every class that's defined in C.

00:13:22,629 --> 00:13:29,629
And here for example and you can find that,

00:13:30,959 --> 00:13:33,920
for example, here, there's a definition of an integer

00:13:33,920 --> 00:13:39,399
class using rb define class integer, and you can

00:13:39,399 --> 00:13:43,660
see that actually you can inherit from cNumeric. Here

00:13:43,660 --> 00:13:47,399
are the definitions of all the, all the methods

00:13:47,399 --> 00:13:48,739
for, on the integers.

00:13:48,739 --> 00:13:51,350
So for examples, all the methods that we use

00:13:51,350 --> 00:13:55,139
every day, odd, even, upto, downto, times, if you

00:13:55,139 --> 00:13:57,389
scroll a bit lower you will actually find definition

00:13:57,389 --> 00:14:00,309
of a fixnum. So this is actually where you

00:14:00,309 --> 00:14:02,360
are using fixnum you are not actually using a

00:14:02,360 --> 00:14:04,920
class that is defined in Ruby. You are using

00:14:04,920 --> 00:14:07,239
a class that was defined in, in C. And

00:14:07,239 --> 00:14:11,670
all the methods are actually implemented in C.

00:14:11,670 --> 00:14:13,709
So for example, here you can, you can find

00:14:13,709 --> 00:14:17,079
fix, so here is the definition for the fixnum

00:14:17,079 --> 00:14:19,079
for the class method, right. So I can find

00:14:19,079 --> 00:14:22,379
it here for you. And this is, well definitely,

00:14:22,379 --> 00:14:25,970
probably this one, this line is what does the

00:14:25,970 --> 00:14:29,350
actual addition. but there's a lot of wrapping code

00:14:29,350 --> 00:14:31,720
around it. For example you can do, if you

00:14:31,720 --> 00:14:33,839
want to play a prank on someone, you can

00:14:33,839 --> 00:14:35,809
just compile your own version of Ruby and just

00:14:35,809 --> 00:14:39,149
change it. And then you know you can watch

00:14:39,149 --> 00:14:40,970
someone try to figure it out for a couple

00:14:40,970 --> 00:14:42,160
of hours.

00:14:42,160 --> 00:14:45,129
yes, so you can use, you know, this is

00:14:45,129 --> 00:14:46,269
the first thing that you can do. You want

00:14:46,269 --> 00:14:48,559
to play with it. It's just that you can

00:14:48,559 --> 00:14:51,029
play, start with pranking other people, but this is

00:14:51,029 --> 00:14:54,899
a really good tool to understand how Ruby works,

00:14:54,899 --> 00:14:57,699
right. How this stuff is implemented, how you can

00:14:57,699 --> 00:15:02,970
actually extend Ruby not only in Ruby but using

00:15:02,970 --> 00:15:05,589
C and make your code much faster, right. So

00:15:05,589 --> 00:15:06,989
this is, this is fixnum.

00:15:06,989 --> 00:15:11,149
Let's actually find another class. Let's say string, right.

00:15:11,149 --> 00:15:13,709
So string is implemented in string C, and I'm

00:15:13,709 --> 00:15:15,299
gonna, wanna do the same thing. I'm gonna go

00:15:15,299 --> 00:15:17,209
all the way to the bottom, I'm gonna scroll

00:15:17,209 --> 00:15:22,239
up and find this init method. There you go.

00:15:22,239 --> 00:15:24,999
And the pattern is exactly the same. like once

00:15:24,999 --> 00:15:27,569
you start looking at couple of files, one or,

00:15:27,569 --> 00:15:30,540
one, three, four files, you see that the patterns

00:15:30,540 --> 00:15:32,189
are, are exactly the same.

00:15:32,189 --> 00:15:34,759
So you first start with definition of a class,

00:15:34,759 --> 00:15:38,449
you give its name, you basically specify which class

00:15:38,449 --> 00:15:44,319
it inherits from. And here also we, we can

00:15:44,319 --> 00:15:48,420
see that rb include module, so string class actually

00:15:48,420 --> 00:15:51,689
includes comparable, right. there's arrow function. and there are

00:15:51,689 --> 00:15:57,649
all the functions, string functions like, equals, hash. All

00:15:57,649 --> 00:16:01,230
this stuff is actually implemented here. and the method,

00:16:01,230 --> 00:16:03,709
method implementations are actually above.

00:16:03,709 --> 00:16:06,019
let's take a look at one more class -

00:16:06,019 --> 00:16:10,959
array, right. so here is the array. yet again,

00:16:10,959 --> 00:16:13,470
init method, define class. i think you can see

00:16:13,470 --> 00:16:19,100
the pattern. and it's real easy to understand what's

00:16:19,100 --> 00:16:21,339
going on ebcause you already have a lot of

00:16:21,339 --> 00:16:23,639
knowledge about how ruby works so you know the

00:16:23,639 --> 00:16:27,019
method names. so it's very useful actually to see

00:16:27,019 --> 00:16:30,779
for example how the, where is length - something

00:16:30,779 --> 00:16:32,569
simple - there we go, here is the definition

00:16:32,569 --> 00:16:34,779
of the length method on array, right. so you

00:16:34,779 --> 00:16:39,600
can actually find it and actually see how it's

00:16:39,600 --> 00:16:42,769
implemented, k, I'm gonna find it. there we go.

00:16:42,769 --> 00:16:45,609
That's all it takes to implement the, the array

00:16:45,609 --> 00:16:51,350
length method. that's the actual C implementation.

00:16:51,350 --> 00:16:56,239
So that's the folder structure. Fixnum, string, and array.

00:16:56,239 --> 00:17:00,790
So how do you actually define classes in C?

00:17:00,790 --> 00:17:03,399
Right. So let's take a look. Let's take a

00:17:03,399 --> 00:17:06,270
look at array again. pretty much all you have

00:17:06,270 --> 00:17:09,100
to do is to create a file in this

00:17:09,100 --> 00:17:12,540
case if I were defining a new array I

00:17:12,540 --> 00:17:15,040
would call it array dot c, right. define this

00:17:15,040 --> 00:17:19,019
method init array, and then I would call this

00:17:19,019 --> 00:17:22,329
Ruby define class, give the, give it the class

00:17:22,329 --> 00:17:25,250
name and give it the ba- the, the, the

00:17:25,250 --> 00:17:28,630
base object which is, which is Ruby object.

00:17:28,630 --> 00:17:31,440
And this is pretty much equivalent to this, to

00:17:31,440 --> 00:17:36,130
this Ruby code, right. You can also see that

00:17:36,130 --> 00:17:40,110
it references this value, which is RBC array. And

00:17:40,110 --> 00:17:42,059
that's actually defined at the very top of the

00:17:42,059 --> 00:17:47,120
file. And you can see, as defined here, and

00:17:47,120 --> 00:17:50,010
every time you see this value in CRuby source

00:17:50,010 --> 00:17:52,440
code, think about it. It's a reference to an

00:17:52,440 --> 00:17:55,659
object. It's pretty much an object. So when we

00:17:55,659 --> 00:18:00,419
define this array here, when you look at this

00:18:00,419 --> 00:18:03,269
Ruby define class, what it really does, it actually

00:18:03,269 --> 00:18:05,240
creates an instance of a class, right.

00:18:05,240 --> 00:18:07,440
if you are interested how metaprogramming actually works in

00:18:07,440 --> 00:18:11,120
Ruby, actually looking at the C, CRuby source code

00:18:11,120 --> 00:18:14,440
will probably give you the most insight how the

00:18:14,440 --> 00:18:17,720
metaprogramming is actually implemented. Because I think without actually

00:18:17,720 --> 00:18:21,519
understanding how, how this CRuby code works, it's very

00:18:21,519 --> 00:18:25,340
difficult to understand the, all the details of metaprogramming.

00:18:25,340 --> 00:18:27,559
So for example, you know that everything in Ruby

00:18:27,559 --> 00:18:29,809
is an object, right? This is pretty much what

00:18:29,809 --> 00:18:33,610
it does. It creates a class object for Ruby

00:18:33,610 --> 00:18:36,559
array and stores it in this reference. Then it

00:18:36,559 --> 00:18:42,309
actually includes a module in that class, right. innumerable

00:18:42,309 --> 00:18:45,470
module in the array class. and then also specifies

00:18:45,470 --> 00:18:48,159
the allocation function and there is, if you, if

00:18:48,159 --> 00:18:51,010
you are interested in a metaprogramming in Ruby, so

00:18:51,010 --> 00:18:54,679
these, these actually, these method actually define singleton methods,

00:18:54,679 --> 00:18:57,610
but they are define singleton methods not on the

00:18:57,610 --> 00:18:59,950
instances of an array but actually on the instance

00:18:59,950 --> 00:19:02,889
of an array class, right.

00:19:02,889 --> 00:19:07,299
So yeah there's, there's, you can even define aliases

00:19:07,299 --> 00:19:09,500
pretty much you can just by looking, just by

00:19:09,500 --> 00:19:12,000
reading these methods and looking at them you can

00:19:12,000 --> 00:19:18,470
connect them with, with Ruby equivalents. So all you

00:19:18,470 --> 00:19:22,909
really need is create a new file, C file,

00:19:22,909 --> 00:19:27,450
create init methods, define a method, provide allocation function

00:19:27,450 --> 00:19:30,139
and provide, define couple of methods, right, that's all

00:19:30,139 --> 00:19:35,220
you need. Literally six lines of code.

00:19:35,220 --> 00:19:37,250
K.

00:19:37,250 --> 00:19:39,440
So that's defining class. And I'm also gonna show

00:19:39,440 --> 00:19:43,990
you a complete example in couple of minutes. So

00:19:43,990 --> 00:19:47,120
what about methods? So to define a method on,

00:19:47,120 --> 00:19:49,510
on a class, for example, array class, you have

00:19:49,510 --> 00:19:55,830
to use this define method, pass in the reference

00:19:55,830 --> 00:19:59,029
to the object of the class, right, specify the

00:19:59,029 --> 00:20:01,679
name and then point it to a function, C

00:20:01,679 --> 00:20:04,799
function that actually implements it. And the last argument

00:20:04,799 --> 00:20:08,120
is the number of arguments that this function takes.

00:20:08,120 --> 00:20:09,760
For example, it could be minus one if you

00:20:09,760 --> 00:20:12,870
want to use variable number of arguments. If it's

00:20:12,870 --> 00:20:16,070
zero it means that there's no arguments. And then

00:20:16,070 --> 00:20:19,580
you have to actually implement the C implementation of

00:20:19,580 --> 00:20:21,950
the function. So here, here is the implementation of

00:20:21,950 --> 00:20:24,299
array length. And you can see that it is

00:20:24,299 --> 00:20:27,289
a static function. It returns a value, and every

00:20:27,289 --> 00:20:29,269
time you see a value, you should think an

00:20:29,269 --> 00:20:32,470
object. So it returns an object, takes an object,

00:20:32,470 --> 00:20:34,600
and this object is actually self.

00:20:34,600 --> 00:20:37,830
It's the reference to the instance of the object

00:20:37,830 --> 00:20:41,649
that we are calling the length on. So if

00:20:41,649 --> 00:20:45,779
you would write that a equals Array.new, this would

00:20:45,779 --> 00:20:49,700
be the reference to a. And then we use,

00:20:49,700 --> 00:20:52,009
this is using a macro to extract the length

00:20:52,009 --> 00:20:53,649
of the array as a long. So this is

00:20:53,649 --> 00:20:57,690
a C, C data type. Because Ruby only knows

00:20:57,690 --> 00:21:01,240
about objects, every time you have C types like

00:21:01,240 --> 00:21:05,000
leng- long, integer, or float, you have to actually

00:21:05,000 --> 00:21:07,779
convert it back to a, to a value object.

00:21:07,779 --> 00:21:08,559
To an object.

00:21:08,559 --> 00:21:11,269
And you can use these macros. I'm gonna, I'm

00:21:11,269 --> 00:21:14,120
gonna talk, talk about it a little bit more

00:21:14,120 --> 00:21:15,399
in couple of minutes.

00:21:15,399 --> 00:21:18,110
So you see pretty much to implement the length

00:21:18,110 --> 00:21:21,200
method you literally need couple of lines of code

00:21:21,200 --> 00:21:24,580
and you can monkey patch your classes in C.

00:21:24,580 --> 00:21:29,009
OK, so what's important to understand when you are

00:21:29,009 --> 00:21:31,610
trying to extend Ruby in C is that there

00:21:31,610 --> 00:21:33,799
are really two worlds that you have to be

00:21:33,799 --> 00:21:37,470
aware of. There is the C world where you

00:21:37,470 --> 00:21:41,600
work directly with memory, there is no garbage collection,

00:21:41,600 --> 00:21:45,590
and you allocate and, and free memory using mailoc

00:21:45,590 --> 00:21:46,700
and free.

00:21:46,700 --> 00:21:48,450
And there's the other world, where, where, where you're

00:21:48,450 --> 00:21:52,590
in Ruby realm, and you work with heap and

00:21:52,590 --> 00:21:55,169
objects and everything is done for you using garbage

00:21:55,169 --> 00:21:57,809
collection. And every time you, you switch from one

00:21:57,809 --> 00:22:00,289
world to the other, you have to make sure

00:22:00,289 --> 00:22:04,130
that you take precautions and you convert the types

00:22:04,130 --> 00:22:06,269
correctly.

00:22:06,269 --> 00:22:07,779
So these are the data types that you have

00:22:07,779 --> 00:22:09,860
access to in, in C. You have pretty much

00:22:09,860 --> 00:22:12,399
all equivalents to the, to the data types that

00:22:12,399 --> 00:22:14,919
we have in Ruby. And this is how you

00:22:14,919 --> 00:22:19,779
actually do conversions. So assuming that you have a,

00:22:19,779 --> 00:22:23,149
let's say a method parameter that's Ruby fixnum, and

00:22:23,149 --> 00:22:26,169
you want to convert it to C type long,

00:22:26,169 --> 00:22:28,080
all you have to do is use this macro,

00:22:28,080 --> 00:22:30,450
num to long, and you're gonna get, get the

00:22:30,450 --> 00:22:31,679
value back.

00:22:31,679 --> 00:22:33,279
If you want to go the other way, from

00:22:33,279 --> 00:22:35,970
C long to Ruby fixnum, what you have to

00:22:35,970 --> 00:22:39,090
call the long to num function and it's gonna

00:22:39,090 --> 00:22:41,980
do it for you. And you have to remember

00:22:41,980 --> 00:22:45,399
that you call this conversion every time you call

00:22:45,399 --> 00:22:47,480
C code from Ruby and every time you return

00:22:47,480 --> 00:22:50,480
values from C back to Ruby.

00:22:50,480 --> 00:22:55,130
OK, so at this point, we have compiled version

00:22:55,130 --> 00:22:57,990
of Ruby, we know how to debug it, we

00:22:57,990 --> 00:23:01,529
pretty much have a basic understanding what, what is

00:23:01,529 --> 00:23:04,970
the folder structure, how to define a class, how

00:23:04,970 --> 00:23:07,830
to define a method, and how to convert data

00:23:07,830 --> 00:23:10,190
between C and Ruby, right.

00:23:10,190 --> 00:23:12,080
So we can actually take a look at couple

00:23:12,080 --> 00:23:19,039
of examples of, of Ruby extensions. OK, so let's

00:23:19,039 --> 00:23:22,429
start with something simple, right. So this is how

00:23:22,429 --> 00:23:25,889
we would monkey patch fixnum in Ruby to add

00:23:25,889 --> 00:23:32,070
a Fibonacci number to fixnum, right. So what you

00:23:32,070 --> 00:23:34,620
would do, you would reopen the class and you

00:23:34,620 --> 00:23:38,070
would define a method. And this is equivalent C

00:23:38,070 --> 00:23:39,340
implementation, right.

00:23:39,340 --> 00:23:41,559
The algorithm is pretty much the same. If you

00:23:41,559 --> 00:23:43,669
write the algorithm it doesn't really matter that, that

00:23:43,669 --> 00:23:47,659
control structures are different. The problem is that you

00:23:47,659 --> 00:23:52,269
cannot really use C implementations directly, because remember that

00:23:52,269 --> 00:23:56,929
Ruby only knows about objects, and C only cares

00:23:56,929 --> 00:23:59,659
about memory locations and pointers, right.

00:23:59,659 --> 00:24:03,600
So Ruby doesn't really understand what long is. Ruby

00:24:03,600 --> 00:24:06,379
only understand those value objects, right. So what you

00:24:06,379 --> 00:24:08,730
have to do, you have to actually convert the

00:24:08,730 --> 00:24:12,720
C implementation, the plain C implementation, into, I call

00:24:12,720 --> 00:24:16,470
it CRuby version. The version that's aware of objects.

00:24:16,470 --> 00:24:17,759
And the way you do it, well you have

00:24:17,759 --> 00:24:19,559
to change the signature of the method, so in

00:24:19,559 --> 00:24:21,840
this case, instead of taking a long and then

00:24:21,840 --> 00:24:25,470
returning a long, you're actually taking a value, reading

00:24:25,470 --> 00:24:27,429
between lines that it's an object, and you actually

00:24:27,429 --> 00:24:30,460
return a value. And then when you actually use

00:24:30,460 --> 00:24:32,690
those values in C, you have to convert them

00:24:32,690 --> 00:24:36,970
from, from objects to longs, right. And then when

00:24:36,970 --> 00:24:40,809
you return a value back, back to Ruby, you

00:24:40,809 --> 00:24:43,340
have to also convert V. In this case, you

00:24:43,340 --> 00:24:45,129
can see here that is a long. So you

00:24:45,129 --> 00:24:47,139
have to long to num convert it into a

00:24:47,139 --> 00:24:48,620
numeric value and return it.

00:24:48,620 --> 00:24:50,720
And that's all you have to do to pretty

00:24:50,720 --> 00:24:55,519
much convert a C function into a CRuby, CRuby

00:24:55,519 --> 00:24:59,669
function. And then of course you have to define,

00:24:59,669 --> 00:25:02,669
define this method in, in, in the, in this

00:25:02,669 --> 00:25:04,590
case numeric, that's C.

00:25:04,590 --> 00:25:08,179
Let me actually show you this in the, in

00:25:08,179 --> 00:25:15,179
the editor. So let's open numeric, numeric C. K,

00:25:15,980 --> 00:25:19,919
I'm gonna find- it's C fib, right, C fib,

00:25:19,919 --> 00:25:23,190
OK. So this is pretty much an example how

00:25:23,190 --> 00:25:29,690
you would monkey patch fixnum directly in C, right.

00:25:29,690 --> 00:25:32,429
So I, I, because we have this send box

00:25:32,429 --> 00:25:34,179
that we set up in the, in the step

00:25:34,179 --> 00:25:36,600
one, we can pretty much modify this whole C

00:25:36,600 --> 00:25:39,190
source code, and we know they're gonna break anything

00:25:39,190 --> 00:25:41,590
so you can do pretty much whatever you want.

00:25:41,590 --> 00:25:45,669
And we d-defined a method like fib, and here's

00:25:45,669 --> 00:25:48,690
the implementation, right, this is exactly what we had,

00:25:48,690 --> 00:25:51,460
what we had on the screen. And now if,

00:25:51,460 --> 00:25:53,289
I think I have it compiled, so if I

00:25:53,289 --> 00:25:57,490
run IRB and, let's say I'm gonna do 10

00:25:57,490 --> 00:26:00,110
dot cfib - there you go.

00:26:00,110 --> 00:26:02,690
So this actually, it's already, I didn't have to

00:26:02,690 --> 00:26:06,379
require any file, so that proves that I actually

00:26:06,379 --> 00:26:10,360
modified the original Ruby source code. So this is

00:26:10,360 --> 00:26:14,940
the 10th Fibonacci number, right. And this is calling

00:26:14,940 --> 00:26:21,629
the, the, the C, C function directly, right. And

00:26:21,629 --> 00:26:24,779
you can debug it. I, I have, I showed

00:26:24,779 --> 00:26:26,850
you before that you can actually, I can actually

00:26:26,850 --> 00:26:31,620
debug it in Xcode, and, and experiment with it.

00:26:31,620 --> 00:26:35,940
So why would you do such a thing as,

00:26:35,940 --> 00:26:38,210
you know, why, why choose C over, over, instead

00:26:38,210 --> 00:26:41,269
of monkey patching in Ruby, why would you do

00:26:41,269 --> 00:26:44,860
it in C? Well, if you need performance, that's,

00:26:44,860 --> 00:26:46,799
that's going back to the problems that I described

00:26:46,799 --> 00:26:49,110
at the very beginning of the talk, which is,

00:26:49,110 --> 00:26:50,559
you know, if you are dealing with a lot

00:26:50,559 --> 00:26:53,610
of data, well you need performance, right. So for

00:26:53,610 --> 00:26:57,039
example, this is a benchmark, just simple benchmark, trivial

00:26:57,039 --> 00:27:03,850
benchmark of running fib(80) a million times, right.

00:27:03,850 --> 00:27:06,669
We run both, both of them directly from Ruby,

00:27:06,669 --> 00:27:10,899
and the CRuby implementation takes twenty-six seconds and, and,

00:27:10,899 --> 00:27:13,080
and C implementation takes like, less than a second.

00:27:13,080 --> 00:27:15,610
So roughly we are thirty-times faster. And this is

00:27:15,610 --> 00:27:19,960
really trivial. And remember that we actually compiled Ruby

00:27:19,960 --> 00:27:23,220
without any optimization. So if you would bump optimization

00:27:23,220 --> 00:27:25,379
to all three, for example, you would probably get

00:27:25,379 --> 00:27:27,429
even better performance.

00:27:27,429 --> 00:27:31,970
So what's important here is that it's not that

00:27:31,970 --> 00:27:37,779
Ruby is slow, but what you can do, you

00:27:37,779 --> 00:27:40,999
can choose your battles. And do the stuff that's

00:27:40,999 --> 00:27:44,019
high level, high-level abstraction, you can do everything in

00:27:44,019 --> 00:27:47,370
Ruby but the critical paths, all the algorith- low-level

00:27:47,370 --> 00:27:49,769
algorithms, you can implement in C, and make your

00:27:49,769 --> 00:27:51,470
application much faster, right.

00:27:51,470 --> 00:27:53,220
If you are, if you are working, let's say,

00:27:53,220 --> 00:27:56,490
I don't know, with Facebook graphs or Twitter, Twitter

00:27:56,490 --> 00:27:59,950
feeds, right, that have millions of records, I think

00:27:59,950 --> 00:28:01,509
it makes a difference if you can do it

00:28:01,509 --> 00:28:04,200
twenty-times, thirty-times faster, right. You can be ahead of

00:28:04,200 --> 00:28:07,440
your competition. You can, and you can really, if

00:28:07,440 --> 00:28:09,809
you need thirty servers to run something, if you

00:28:09,809 --> 00:28:11,999
rewrite it in C you probably only need two

00:28:11,999 --> 00:28:14,019
or three. Right, so if you need to save

00:28:14,019 --> 00:28:14,759
money. OK.

00:28:14,759 --> 00:28:17,950
Let's go to the next example. So next example

00:28:17,950 --> 00:28:20,450
is prime, right. Testing for prime. Also very simple

00:28:20,450 --> 00:28:23,669
algorithm. We just go through all the numbers and

00:28:23,669 --> 00:28:25,899
make sure that we are not divisible by, by

00:28:25,899 --> 00:28:31,080
any number below the, below the, the self number.

00:28:31,080 --> 00:28:34,370
So this is already, this algorithm is pretty much

00:28:34,370 --> 00:28:37,649
identical. The only thing that we're using, we could

00:28:37,649 --> 00:28:40,080
use for loop, but just we're using opt-to here.

00:28:40,080 --> 00:28:45,210
So this is already converted to CRuby style. And

00:28:45,210 --> 00:28:46,529
you can see there's not a lot of, of

00:28:46,529 --> 00:28:50,740
differences. It's very easy to rewrite this code into

00:28:50,740 --> 00:28:53,460
C. That's going from Ruby to C, right.

00:28:53,460 --> 00:28:55,269
But when you really think about it, most of

00:28:55,269 --> 00:28:58,600
the algorithms are already written in C. So usually

00:28:58,600 --> 00:29:00,610
go, you go the other way around, right. So

00:29:00,610 --> 00:29:02,639
you get the algorithm like in the book or

00:29:02,639 --> 00:29:05,749
numerical methods book, you find the C implementation and

00:29:05,749 --> 00:29:07,379
you try to implement it in Ruby.

00:29:07,379 --> 00:29:10,429
And you really can avoid that by just interfacing

00:29:10,429 --> 00:29:14,940
your code directly with, with C. So here, again,

00:29:14,940 --> 00:29:17,809
you monkey patch prime. This is C prime. You

00:29:17,809 --> 00:29:20,950
define the method. And the thing I also have

00:29:20,950 --> 00:29:26,490
it running here, so, I don't know. 11.cprime.

00:29:26,490 --> 00:29:32,399
There we go. So with couple of lines of

00:29:32,399 --> 00:29:36,580
code you can monkey patch fixnum and, and, you

00:29:36,580 --> 00:29:39,450
know, experiment with it. These are just simple examples

00:29:39,450 --> 00:29:42,970
but you can go with much more advanced functionality.

00:29:42,970 --> 00:29:46,039
So again, if we compare the performance, in this

00:29:46,039 --> 00:29:50,240
case, if we test one of marked primes, it

00:29:50,240 --> 00:29:53,749
takes thirty-one seconds using C, using Ruby. And it

00:29:53,749 --> 00:29:57,049
takes two seconds using C. So it's seventeen times

00:29:57,049 --> 00:30:00,340
faster, right. And that's even without any optimization.

00:30:00,340 --> 00:30:02,499
So I think you can see that there are

00:30:02,499 --> 00:30:06,889
benefits, especially if you, if you are, if you-

00:30:06,889 --> 00:30:09,389
definitely you don't want to rewrite your GUIs and,

00:30:09,389 --> 00:30:12,340
and web applications in, in, in C. But what

00:30:12,340 --> 00:30:14,129
you want to do, if there are certain algorithms

00:30:14,129 --> 00:30:18,019
that you have that are critical for your application,

00:30:18,019 --> 00:30:19,559
you can rewrite it in C and get a

00:30:19,559 --> 00:30:22,350
lot of benefits. Especially if you operate on a

00:30:22,350 --> 00:30:25,289
lot of, on large arrays of objects or lists

00:30:25,289 --> 00:30:27,629
of objects.

00:30:27,629 --> 00:30:29,840
So that was simple monkey patching. But what about

00:30:29,840 --> 00:30:33,370
if you want to create a completely new class

00:30:33,370 --> 00:30:35,980
in C, right? This is all it takes. All

00:30:35,980 --> 00:30:39,820
you have to do is to define init method,

00:30:39,820 --> 00:30:42,580
specify and define class, C long array, that it

00:30:42,580 --> 00:30:46,340
inherits from an object. Define a lock function for

00:30:46,340 --> 00:30:50,990
it. Define a constructor for it. And also we,

00:30:50,990 --> 00:30:53,919
here we gonna demonstrate that, that the quick service

00:30:53,919 --> 00:30:56,539
slightly faster when we are running directly on longs

00:30:56,539 --> 00:30:59,249
and we have to access our methods, right.

00:30:59,249 --> 00:31:02,700
So if we look at it, the, the lock

00:31:02,700 --> 00:31:06,629
function is really simple. Couple of lines of code.

00:31:06,629 --> 00:31:10,159
WE use this date, data make struct macro. What

00:31:10,159 --> 00:31:12,940
it does, it will actually take this C structure

00:31:12,940 --> 00:31:15,669
and wrap it in an, in Ruby object. Once

00:31:15,669 --> 00:31:17,429
you wrap it in a Ruby object, you can

00:31:17,429 --> 00:31:19,830
return it. So this self is, so we start

00:31:19,830 --> 00:31:22,720
with this array T, which is a C construct,

00:31:22,720 --> 00:31:25,950
and we get back, by calling this data make

00:31:25,950 --> 00:31:29,080
struct, we gonna get an ob- a C, a

00:31:29,080 --> 00:31:31,580
Ruby object that we can return and we can

00:31:31,580 --> 00:31:34,480
use it in a Ruby code.

00:31:34,480 --> 00:31:35,929
This is the initialization. So this is how we

00:31:35,929 --> 00:31:38,759
would call it from Ruby, right. C long Array.new

00:31:38,759 --> 00:31:41,580
10. Ten is basically the size of the array.

00:31:41,580 --> 00:31:44,100
It's a really simple implementation of an array with

00:31:44,100 --> 00:31:48,659
a fixed size. When you initialize it, use this

00:31:48,659 --> 00:31:51,309
ga- data get struct to get access to the

00:31:51,309 --> 00:31:55,409
actual array pointer. So basically unwrap the, the Ruby

00:31:55,409 --> 00:31:57,529
object and get access to the pointer to the

00:31:57,529 --> 00:31:59,450
memory to where the data is stored.

00:31:59,450 --> 00:32:02,309
And then you can just use CRu- C mailoc

00:32:02,309 --> 00:32:04,249
and allocate enough room for let's say, in this

00:32:04,249 --> 00:32:07,889
case, ten numbers, right. And you store the size

00:32:07,889 --> 00:32:09,710
and you can return the object. So at this

00:32:09,710 --> 00:32:11,769
time you have enough room to store ten objects

00:32:11,769 --> 00:32:16,960
in it. And to access array limit- elements, so

00:32:16,960 --> 00:32:20,259
it works exactly like Ruby, a Ruby array. You

00:32:20,259 --> 00:32:25,240
can just define this square brackets function and it

00:32:25,240 --> 00:32:27,490
does the same thing. It extracts the, the pointer

00:32:27,490 --> 00:32:33,779
to, to array, converts the index, which it comes

00:32:33,779 --> 00:32:36,029
as a fixnum, and convert it to a long.

00:32:36,029 --> 00:32:38,320
And then we just access it, access this through,

00:32:38,320 --> 00:32:41,460
through a pointer, and we, we convert it back

00:32:41,460 --> 00:32:44,749
to a fixnum and we send it back to

00:32:44,749 --> 00:32:46,690
Ruby. And this is how we would set the

00:32:46,690 --> 00:32:46,940
value.

00:32:46,940 --> 00:32:49,590
It's exactly the same except for it's 99, which

00:32:49,590 --> 00:32:51,409
is the value that we, that we set it

00:32:51,409 --> 00:32:53,970
to. And it's, the difference is only here. Instead

00:32:53,970 --> 00:32:56,220
of returning the value at this index, we're actually

00:32:56,220 --> 00:32:59,720
setting it. OK, and this is, this is a

00:32:59,720 --> 00:33:02,399
quick sort of implementation, right. I'm doing something different

00:33:02,399 --> 00:33:04,580
here. SO instead of actually converting the C, the

00:33:04,580 --> 00:33:09,480
C example quicksort code to CRuby convention, actually I

00:33:09,480 --> 00:33:13,950
ha- I'm using this wrapper function that abstracts all

00:33:13,950 --> 00:33:17,090
the objects. It, it converts all the objects to

00:33:17,090 --> 00:33:20,330
C data structures and it actually calls the C

00:33:20,330 --> 00:33:21,210
function directly.

00:33:21,210 --> 00:33:23,840
So you can see it here. This, this function,

00:33:23,840 --> 00:33:28,629
this quicksort function, it's pretty much, doesn't know anything

00:33:28,629 --> 00:33:32,119
about Ruby, anything about the objects. This function, array

00:33:32,119 --> 00:33:35,730
quick_sort, actually converts everything for it. So you can,

00:33:35,730 --> 00:33:38,159
you can get this directly from any website that

00:33:38,159 --> 00:33:41,100
lists algorithms, and you can use it directly in

00:33:41,100 --> 00:33:41,929
your code.

00:33:41,929 --> 00:33:44,419
And if you compare performance, when you really thinking,

00:33:44,419 --> 00:33:47,340
quick, sorting stuff is a really fundamental feature in

00:33:47,340 --> 00:33:51,049
a lot of algorithms, right. And just by using

00:33:51,049 --> 00:33:54,240
this array and this quick_sort implementation, you can get

00:33:54,240 --> 00:33:56,480
a ten times faster sorting.

00:33:56,480 --> 00:34:00,059
For example here we're sorting one million numbers, and

00:34:00,059 --> 00:34:03,190
in C it takes two hundred milliseconds, and in,

00:34:03,190 --> 00:34:07,940
in, in Ruby it takes two seconds, right. So

00:34:07,940 --> 00:34:11,230
that pretty much demonstrates that we can monkey patch

00:34:11,230 --> 00:34:14,610
fixnum in C directly in C. It's thirty times

00:34:14,610 --> 00:34:16,850
faster. This one is seventeen. And we can even

00:34:16,850 --> 00:34:19,470
implement our own classes directly in C.

00:34:19,470 --> 00:34:24,610
OK, so that brings us to graphs. So this

00:34:24,610 --> 00:34:29,290
is really simple implementation. We are, we will work

00:34:29,290 --> 00:34:31,780
with this grid graph, which is, you just, just

00:34:31,780 --> 00:34:34,860
a, just a square. A four-by-four so it has

00:34:34,860 --> 00:34:37,910
sixteen nodes. This is the presentation that we are

00:34:37,910 --> 00:34:40,640
using. It's pretty much a list of linked list.

00:34:40,640 --> 00:34:43,280
So, for example, one is just all the elements

00:34:43,280 --> 00:34:45,170
that we are connected to. So one is connected

00:34:45,170 --> 00:34:47,620
to two and five. So one is connected to

00:34:47,620 --> 00:34:49,940
two and five. So we'll be using linked list-

00:34:49,940 --> 00:34:52,370
basically an array of linked lists.

00:34:52,370 --> 00:34:55,060
And this is the, the data structure, C data

00:34:55,060 --> 00:34:56,730
structure that we use for the graph, so it

00:34:56,730 --> 00:34:59,580
has this side. So it has how many nodes

00:34:59,580 --> 00:35:03,140
we have on the side. And the, a, a

00:35:03,140 --> 00:35:05,540
link to this array of linked lists. And this

00:35:05,540 --> 00:35:07,160
is just a node in the list. This is

00:35:07,160 --> 00:35:09,980
pretty much one of the squares. It has the

00:35:09,980 --> 00:35:12,470
value of the node and the pointer to the

00:35:12,470 --> 00:35:13,680
next node.

00:35:13,680 --> 00:35:17,930
OK, C graph, although we are implementing pretty complicated

00:35:17,930 --> 00:35:21,130
data structure like graph, this is not getting much

00:35:21,130 --> 00:35:23,860
complicated, if you compare it to the array, right.

00:35:23,860 --> 00:35:26,120
You still define the class. We give it a

00:35:26,120 --> 00:35:28,490
name, it inherits from an object. We still need

00:35:28,490 --> 00:35:31,680
allocation function. We need a constructor that takes one

00:35:31,680 --> 00:35:34,450
argument and in this case we have three methods.

00:35:34,450 --> 00:35:41,340
We have ref_first_search, def_first_search, and, and prims spanning tree.

00:35:41,340 --> 00:35:43,960
So alloc is exactly, almost exactly the same. The

00:35:43,960 --> 00:35:47,140
only thing that's, that's different is this bolded, bolded

00:35:47,140 --> 00:35:50,070
text, which is, before we had array, we had

00:35:50,070 --> 00:35:53,100
array underscore t, now we have a graph, because

00:35:53,100 --> 00:35:54,810
we are using a different data structure. So this

00:35:54,810 --> 00:35:58,040
is exactly almost the same as in the array

00:35:58,040 --> 00:36:00,340
example. And init is a little bit more complicated

00:36:00,340 --> 00:36:03,960
because, yet again we extract the pointer to, to

00:36:03,960 --> 00:36:06,270
the data. This graph it points to the, to

00:36:06,270 --> 00:36:08,880
the location in memory where the graph is stored.

00:36:08,880 --> 00:36:11,880
We store this side. WE convert it from, from

00:36:11,880 --> 00:36:15,120
a fixnum to, to a long, and then we

00:36:15,120 --> 00:36:18,840
call this method implementation of that method, basically what

00:36:18,840 --> 00:36:22,120
it does, it just generates the, the grid graph

00:36:22,120 --> 00:36:23,670
for us. So it links up all the, all

00:36:23,670 --> 00:36:26,540
the nodes together. So you would have to do

00:36:26,540 --> 00:36:32,330
it anyway. So this is the actual, the, the

00:36:32,330 --> 00:36:35,420
adapter function that we use for calling BFS C

00:36:35,420 --> 00:36:39,120
implementation. So we have this plain CBFS which is,

00:36:39,120 --> 00:36:42,430
this code is completely unaware of Ruby. It just,

00:36:42,430 --> 00:36:45,730
it's a textbook example of, you know, using queue

00:36:45,730 --> 00:36:48,730
to perform a BFS search.

00:36:48,730 --> 00:36:51,880
And here what we do is actually first we

00:36:51,880 --> 00:36:55,590
get access to those values that are passed in,

00:36:55,590 --> 00:36:58,310
right. We get, we get this graph will point

00:36:58,310 --> 00:37:02,000
to the memory location when that graph is stored,

00:37:02,000 --> 00:37:05,560
and we actually pass it here directly. We also

00:37:05,560 --> 00:37:07,770
pass in the long that is the size of

00:37:07,770 --> 00:37:10,020
the, of the, of the graph, and we also

00:37:10,020 --> 00:37:12,370
pass the source node, so the node where you

00:37:12,370 --> 00:37:13,330
want to start the BFS search.

00:37:13,330 --> 00:37:17,660
And you call this method, right. So this method

00:37:17,660 --> 00:37:19,740
will go through the graph and it will actually

00:37:19,740 --> 00:37:23,280
return this path. And this path is all the

00:37:23,280 --> 00:37:27,220
nodes that you explore during the, the graph search.

00:37:27,220 --> 00:37:29,990
And this is, this is a C structure, so

00:37:29,990 --> 00:37:33,390
what you have to do is create this trace.

00:37:33,390 --> 00:37:35,620
We create a new array, this is a Ruby

00:37:35,620 --> 00:37:38,690
array, and we basically go over all the elements

00:37:38,690 --> 00:37:42,380
in this path and we push all the elements

00:37:42,380 --> 00:37:45,430
from path onto a trace by converting it to

00:37:45,430 --> 00:37:48,150
a, to a Ruby object, right.

00:37:48,150 --> 00:37:50,320
So pretty much we are trying to get the

00:37:50,320 --> 00:37:55,080
C structure completely converted into complete Ruby array, and

00:37:55,080 --> 00:37:58,070
we pass back that array to a calling, calling

00:37:58,070 --> 00:38:00,580
code. And before that we also free some memory

00:38:00,580 --> 00:38:04,450
here. So it's a little bit more complicated, but

00:38:04,450 --> 00:38:06,880
the complexity is here are not really that important.

00:38:06,880 --> 00:38:10,370
What's important here is how easy it is, like

00:38:10,370 --> 00:38:12,730
literally without, without, with couple of lines of code,

00:38:12,730 --> 00:38:15,490
you can, you can start using really complicated graph

00:38:15,490 --> 00:38:17,910
algorithms directly from Ruby, and you can speed up

00:38:17,910 --> 00:38:19,440
your Ruby, Ruby code.

00:38:19,440 --> 00:38:22,230
So for example here, we have, we have a

00:38:22,230 --> 00:38:25,640
graph with four million nodes. This is just creation

00:38:25,640 --> 00:38:27,480
of the graph. And if you want to create

00:38:27,480 --> 00:38:30,550
it in Ruby, it's gonna take you twenty-seven seconds.

00:38:30,550 --> 00:38:31,600
And if you do it in C, it's gonna

00:38:31,600 --> 00:38:34,160
take you half a second. So it's, in this

00:38:34,160 --> 00:38:36,350
case it's actually, C Ruby is actually fifty times

00:38:36,350 --> 00:38:38,890
faster than, than Ruby. I think that's, that's worth

00:38:38,890 --> 00:38:40,290
the effort, and all you have to do is

00:38:40,290 --> 00:38:42,840
just write a couple of lines of C and

00:38:42,840 --> 00:38:45,750
you can speed up your code fifty times.

00:38:45,750 --> 00:38:48,970
And if it comes to actual BFS implementation, given

00:38:48,970 --> 00:38:52,560
a graph with one million nodes, the full BF-

00:38:52,560 --> 00:38:55,200
b?? search in that graph (00:38:58) in C takes

00:38:55,200 --> 00:38:58,630
two hundred milliseconds and in Ruby takes nineteen min-

00:38:58,630 --> 00:39:03,240
nineteen times slower, four thousand milliseconds on MacPro.

00:39:03,240 --> 00:39:07,180
So this was just a simple graph example. You

00:39:07,180 --> 00:39:09,110
can go much deeper than that, but I think

00:39:09,110 --> 00:39:11,920
for, for presentation it doesn't really make sense. But

00:39:11,920 --> 00:39:13,640
what this proves that you can really easy in

00:39:13,640 --> 00:39:14,990
couple of lines of code, I think there was

00:39:14,990 --> 00:39:17,250
like thirty lines of code, you can create your

00:39:17,250 --> 00:39:20,850
own CRuby implementation of a graph in Ruby that's

00:39:20,850 --> 00:39:23,740
gonna play really well with Ruby. You can write

00:39:23,740 --> 00:39:26,060
implementation in BFS and you can make it twenty

00:39:26,060 --> 00:39:27,540
times faster.

00:39:27,540 --> 00:39:29,240
So when you really think about it, if you,

00:39:29,240 --> 00:39:32,480
if you working with graphs such as, let's say,

00:39:32,480 --> 00:39:36,200
Facebook, right, of your friends. Well, very quickly that

00:39:36,200 --> 00:39:38,300
graph grows. Like if you have hundred friends, and

00:39:38,300 --> 00:39:41,320
all of your friends have hundred friends, that graph

00:39:41,320 --> 00:39:43,980
goes into millions really quickly, right. So if you

00:39:43,980 --> 00:39:46,850
can do something twenty or fifty times faster, that's

00:39:46,850 --> 00:39:49,740
the difference between not being able to do something

00:39:49,740 --> 00:39:51,530
or being able to do something, right.

00:39:51,530 --> 00:39:54,910
If something takes twenty hours, you can, you can

00:39:54,910 --> 00:39:58,130
get it done in an hour, right. So, it

00:39:58,130 --> 00:40:00,220
might be also a base for a business model

00:40:00,220 --> 00:40:00,620
if you want to, if you want to start

00:40:00,620 --> 00:40:02,390
a start up.

00:40:02,390 --> 00:40:05,990
OK, so what are the conclusions? The conclusions are

00:40:05,990 --> 00:40:09,720
that you can use C to speed up your

00:40:09,720 --> 00:40:12,900
Ruby algorithms, especially if they are low-level algorithms like,

00:40:12,900 --> 00:40:15,320
for example, sorting. Like I showed you that really

00:40:15,320 --> 00:40:16,860
with a simple code you can speed up your

00:40:16,860 --> 00:40:19,590
sorting ten times.

00:40:19,590 --> 00:40:21,430
You can also go a little bit deeper and,

00:40:21,430 --> 00:40:23,590
you know, there's a lot of like numerical methods

00:40:23,590 --> 00:40:26,940
books where they have very elaborate algorithms, algorithms, so

00:40:26,940 --> 00:40:28,870
you can actually take them and use them directly

00:40:28,870 --> 00:40:31,400
in Ruby.

00:40:31,400 --> 00:40:33,150
Rewrites in, in C are, I think I, I,

00:40:33,150 --> 00:40:35,820
I showed you that they are not that complicated.

00:40:35,820 --> 00:40:38,080
Most of them are straightforward. And you can write

00:40:38,080 --> 00:40:41,330
by using those wrapper functions that convert objects in

00:40:41,330 --> 00:40:44,330
C data structures and then call the C functions,

00:40:44,330 --> 00:40:47,340
you can actually use a lot of algorithms directly.

00:40:47,340 --> 00:40:49,970
So you don't have to worry about the fact

00:40:49,970 --> 00:40:51,640
that you will break the algorithm. You can just

00:40:51,640 --> 00:40:54,080
use, you can use it verbatim and just provide

00:40:54,080 --> 00:40:57,750
it this adapter function.

00:40:57,750 --> 00:41:01,050
If you do some trivial CRuby rewrites, like the

00:41:01,050 --> 00:41:05,470
Fibonacci or prime, you're gonna get immediately ten extra,

00:41:05,470 --> 00:41:08,650
fifty extra speed performance bump. And if you want

00:41:08,650 --> 00:41:11,870
better performance you pretty much, you can go and

00:41:11,870 --> 00:41:15,380
you can, you know, look what people are, let's

00:41:15,380 --> 00:41:20,520
say, doing a high performance, high frequency trading, right.

00:41:20,520 --> 00:41:22,230
There's other tricks that you can use.

00:41:22,230 --> 00:41:25,670
But just with simple rewrite of your, of your

00:41:25,670 --> 00:41:28,330
crucial algorithms in C, you can, you can get

00:41:28,330 --> 00:41:31,040
ten to fifty times x performance bump.

00:41:31,040 --> 00:41:34,620

YouTube URL: https://www.youtube.com/watch?v=BjGa3dWGXCs


