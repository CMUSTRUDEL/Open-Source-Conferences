Title: Ruby Conf 2013 - The Future of JRuby by Charles Nutter and Thomas Enebo
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	JRuby is a fast, compliant Ruby implementation which can make use of many features of the Java platform. What more is there to do? Can it be made faster? Will it ever load faster? Any plans on making cross-implementation native C extension API?

This presentation will answer questions like this and give some examples of exciting future projects involving JRuby. If you want a good insight into where JRuby is going then this talk is for you.

Help us caption & translate this video!

http://amara.org/v/FG4q/
Captions: 
	00:00:16,320 --> 00:00:18,140
CHARLES NUTTER: So we're gonna get right into it.

00:00:18,140 --> 00:00:20,149
I talk a little bit about the future of JRuby.

00:00:20,149 --> 00:00:22,871
We've got a little short intro of what it is.

00:00:22,880 --> 00:00:26,970
But, like Tom said, we've got a lot of slides so we're gonna get right into it.

00:00:26,970 --> 00:00:29,909
So first of all, basically, what is JRuby? How

00:00:29,920 --> 00:00:33,221
many people have used JRuby for something? Awesome. How

00:00:33,221 --> 00:00:36,200
many people have something in production right now with

00:00:36,200 --> 00:00:37,200
JRuby? All right.

00:00:37,200 --> 00:00:39,819
So like, three-quarters and about a half of the

00:00:39,820 --> 00:00:41,390
room. That's cool. We expected that most of you

00:00:41,390 --> 00:00:43,071
coming to this would probably be more on the

00:00:43,080 --> 00:00:44,939
JRuby side of things.

00:00:44,940 --> 00:00:47,501
So JRuby of course is Ruby on the JVM,

00:00:47,501 --> 00:00:48,799
and this means a lot of things to a

00:00:48,800 --> 00:00:51,471
lot of people. A lot of them aren't good

00:00:51,480 --> 00:00:55,269
things, unfortunately. You get stuff like this and, and,

00:00:55,269 --> 00:00:58,271
you know, people - it's all about applets, and

00:00:58,280 --> 00:01:01,249
the JVM sucks, and people, people actually go to

00:01:01,249 --> 00:01:03,350
our code base and look for stuff like that.

00:01:03,350 --> 00:01:06,470
But, I mean, the bottom line, the bottom line

00:01:10,300 --> 00:01:12,370
we always try to get across is really that

00:01:12,370 --> 00:01:15,540
JRuby is just Ruby. It's a Ruby implementation. It

00:01:15,540 --> 00:01:18,670
happens to be written partially in Java. It happens

00:01:18,670 --> 00:01:20,030
to run on the JVM. But it's just a

00:01:20,040 --> 00:01:21,740
Ruby implementation.

00:01:21,740 --> 00:01:24,150
So basics about JRuby, before we get into talking

00:01:24,150 --> 00:01:27,120
about futures, where we're going with it. It, right

00:01:27,120 --> 00:01:30,270
now it's compatible with Ruby 1.8.7, and 1.9.3. This

00:01:30,270 --> 00:01:32,150
is gonna change in the future, as we'll talk

00:01:32,160 --> 00:01:33,770
about.

00:01:33,770 --> 00:01:36,080
Mostly written in Java. More and more code being

00:01:36,080 --> 00:01:38,400
written in Ruby. But, even the Java code we

00:01:38,400 --> 00:01:41,640
have is pretty clean. We've got a pretty standard

00:01:41,640 --> 00:01:44,630
coding conventions that we like our committers and contributors

00:01:44,640 --> 00:01:46,590
to follow.

00:01:46,590 --> 00:01:48,960
And the coolest part about JRuby, and the reason

00:01:48,960 --> 00:01:50,830
that most people come to JRuby is because the

00:01:50,840 --> 00:01:53,770
entire world of the JVM is available to you.

00:01:53,770 --> 00:01:56,440
The GCs that we've got available, all the different

00:01:56,440 --> 00:01:59,350
platforms. The GIT runtime. And then of course all

00:01:59,360 --> 00:02:01,110
of the libraries and languages that are on the

00:02:01,110 --> 00:02:02,220
JVM.

00:02:02,220 --> 00:02:04,350
So it's, it's a Ruby on top of this

00:02:04,360 --> 00:02:06,620
platform that brings a lot more than just Ruby

00:02:06,620 --> 00:02:07,750
to the table.

00:02:07,750 --> 00:02:10,060
TOM ENEBO: OK. I'm gonna talk a little bit

00:02:10,060 --> 00:02:13,860
about JRuby. How we version and branch and how

00:02:13,860 --> 00:02:17,750
we've evolved our development a little bit. When we

00:02:17,760 --> 00:02:20,570
do a significant release of JRuby, we do all

00:02:20,580 --> 00:02:23,940
of our development on Master. Once we hit that

00:02:23,940 --> 00:02:27,190
1.6.0, as you know, any project that hits 1.6.0

00:02:27,190 --> 00:02:30,380
isn't, like, quite ready to be used yet.

00:02:30,380 --> 00:02:32,680
So, we usually do one or more point release

00:02:32,700 --> 00:02:34,690
until we feel confident, and then we create a

00:02:34,690 --> 00:02:39,360
maintenance branch. In the case of 1.6, we did

00:02:39,360 --> 00:02:42,910
it after 1.6.1, JRuby 1.6 was gonna be the

00:02:42,920 --> 00:02:48,740
great 1.9 release for JRuby, and it wasn't.

00:02:48,740 --> 00:02:52,550
Most of the 1.9 stuff was there, except for

00:02:52,550 --> 00:02:54,400
encoding, which was a-

00:02:54,420 --> 00:02:56,930
C.N.: Turned out to be kind of important.

00:02:56,930 --> 00:03:01,020
T.E.: A tremendous amount of work. And so time

00:03:01,020 --> 00:03:03,189
marches on. A year later we put out a

00:03:03,189 --> 00:03:06,540
preview release on 1.7. We're plugging away on Master,

00:03:06,540 --> 00:03:08,101
working on the next great thing.

00:03:08,101 --> 00:03:11,210
Oh, another five months, 1.7.0 comes out. So for

00:03:11,240 --> 00:03:13,840
a year and a half, we're on this dual-branch

00:03:13,840 --> 00:03:17,459
development mode, and what ended up happening is, we

00:03:17,460 --> 00:03:20,151
had so much fun in master that not a

00:03:20,151 --> 00:03:22,740
lot of stuff made it to 1.6, and the

00:03:22,740 --> 00:03:27,080
branches kept getting further apart. And we did merge

00:03:27,080 --> 00:03:29,640
stuff when people asked for it, but this was

00:03:29,640 --> 00:03:31,050
not something that we wanted to repeat.

00:03:31,050 --> 00:03:32,910
C.N.: Right. We really want to keep our releases

00:03:32,920 --> 00:03:36,559
short and closer together. And, and keep fixes going

00:03:36,560 --> 00:03:38,421
to the right places. To the, to the releases

00:03:38,421 --> 00:03:39,339
people are using.

00:03:39,340 --> 00:03:43,251
T.E.: So when we started working on 1.7, you'll

00:03:43,260 --> 00:03:45,720
see that we didn't actually create a maintenance branch

00:03:45,720 --> 00:03:49,400
until after 1.7.5. This was us-

00:03:49,400 --> 00:03:53,760
C.N.: Right, keep it real.

00:03:53,760 --> 00:03:56,090
T.E.: Yeah, I mean. It's discipline and pain. I

00:03:56,090 --> 00:03:57,330
was trying to think of the right word to

00:03:57,340 --> 00:03:58,380
represent pain.

00:03:58,380 --> 00:04:01,720
C.N.: Rather than going off on, on a completely

00:04:01,720 --> 00:04:04,319
new version of JRuby, we forced ourselves to do

00:04:04,320 --> 00:04:06,441
a lot of incremental releases for 1.7, to keep

00:04:06,441 --> 00:04:07,200
improving it.

00:04:07,200 --> 00:04:08,650
T.E.: And we knew that we're gonna be working

00:04:08,650 --> 00:04:10,710
on a major release. So we wanted to make

00:04:10,710 --> 00:04:12,719
sure that things are really solid by the time

00:04:12,740 --> 00:04:13,781
we started doing that.

00:04:13,781 --> 00:04:16,729
And in fact we almost did this at 1.7.3,

00:04:16,729 --> 00:04:19,230
then realized that we were still missing encoding work

00:04:19,230 --> 00:04:22,730
on zlib. And coding's really hard.

00:04:25,040 --> 00:04:26,170
So the other things that we're gonna try to

00:04:26,180 --> 00:04:28,821
do to try to make this dual-branch development work

00:04:28,821 --> 00:04:30,919
better, is we're gonna make sure that we put

00:04:30,940 --> 00:04:34,170
out a release at least every three weeks.

00:04:34,170 --> 00:04:36,261
This is to keep us honest. If we go

00:04:36,261 --> 00:04:37,830
and put out a release in three weeks and

00:04:37,830 --> 00:04:39,459
it only has one fix in it, then we're

00:04:39,460 --> 00:04:42,101
not really doing our job, so. This'll keep us

00:04:42,101 --> 00:04:43,280
honest.

00:04:43,280 --> 00:04:45,179
And the other big change is that anything that

00:04:45,180 --> 00:04:49,370
involves compatibility, we're gonna apply to 1.7 first. And

00:04:49,380 --> 00:04:52,601
we're constantly merging back to Master. Things'll be golden.

00:04:52,601 --> 00:04:58,100
I think we've finally found our sweet spot here.

00:04:58,100 --> 00:05:01,189
So let's talk about the next major release.

00:05:01,200 --> 00:05:03,140
One big change, Charlie will show some stats in

00:05:03,140 --> 00:05:05,970
a little bit, but we're only gonna support Ruby

00:05:05,970 --> 00:05:08,891
2 point 1. It's coming out sometime next year.

00:05:08,900 --> 00:05:11,240
It should line up good with MRI.

00:05:11,240 --> 00:05:13,710
This is gonna be awesome. Supporting multiple modes of

00:05:13,710 --> 00:05:17,459
Ruby at the same time is really painful.

00:05:17,460 --> 00:05:19,671
We're probably gonna be Java 7 and higher. If

00:05:19,680 --> 00:05:22,789
there's any people that use Java 6, and you're

00:05:22,789 --> 00:05:25,371
not gonna be able to migrate by next year,

00:05:25,380 --> 00:05:26,831
just talk to us. We want to hear who

00:05:26,831 --> 00:05:28,709
those people are and what your stories are.

00:05:28,709 --> 00:05:31,790
We want to be modular, both at a packaging

00:05:31,790 --> 00:05:35,530
level - cause platforms like Android, they want to

00:05:35,540 --> 00:05:37,900
have as small a jar as possible, and also

00:05:37,900 --> 00:05:40,890
at the source level, because things like Google app

00:05:40,890 --> 00:05:43,801
engine, they don't support sockets. So they shouldn't have

00:05:43,801 --> 00:05:48,249
to compile against that.

00:05:48,260 --> 00:05:50,971
Look at this picture. And now look at this

00:05:50,980 --> 00:05:53,450
next slide.

00:05:53,450 --> 00:05:55,780
We're gonna be breaking lots of APIs. This is

00:05:55,780 --> 00:05:58,119
the first time that we've actually decided to break

00:05:58,120 --> 00:06:00,950
a lot of APIs. It's been ten years, or

00:06:00,960 --> 00:06:04,791
maybe more than ten years. So we're going to

00:06:04,800 --> 00:06:06,900
just clean up all the crap that we've hated

00:06:06,900 --> 00:06:08,680
for ten years, and we're gonna have a lot

00:06:08,680 --> 00:06:09,749
of fun doing it.

00:06:09,749 --> 00:06:14,380
C.N.: This mostly affects, like, JRuby Java-based extensions. Obviously

00:06:14,380 --> 00:06:17,740
the Ruby compatibility won't hurt at all, but libraries

00:06:17,740 --> 00:06:19,630
that are written in Java for JRuby may have

00:06:19,630 --> 00:06:20,591
to make some changes.

00:06:20,620 --> 00:06:22,429
T.E.: And we have a plan for reducing the

00:06:22,429 --> 00:06:24,940
pain with regards to embedding, and I'll talk about

00:06:24,940 --> 00:06:27,530
that a little bit later. And we're also gonna

00:06:27,530 --> 00:06:29,541
have a brand new runtime, which we'll talk about

00:06:29,541 --> 00:06:31,890
later.

00:06:31,900 --> 00:06:33,659
So I haven't said what the major version number

00:06:33,660 --> 00:06:36,920
is yet. The natural one would have been 1

00:06:36,920 --> 00:06:39,320
point 8, but JRuby 1 point 8, which supports

00:06:39,320 --> 00:06:41,611
Ruby 2 point 1, would have been kind of

00:06:41,611 --> 00:06:44,629
weird. 1 point 9, 2 point 0, same thing.

00:06:44,640 --> 00:06:46,730
2 point 1? That one actually does kind of

00:06:46,730 --> 00:06:49,110
make sense, cause we will support 2 point 1,

00:06:49,120 --> 00:06:52,160
but then we'd release a 2 point 2 before

00:06:52,160 --> 00:06:56,310
MRI did, and that would be weird. So.

00:06:56,310 --> 00:06:57,920
We should have did this for our version number

00:06:57,920 --> 00:07:00,000
- we should have went from 1.7 to 8,

00:07:00,000 --> 00:07:05,761
like Java. But we're weird like that. We, well,

00:07:05,761 --> 00:07:07,579
we'll see.

00:07:07,580 --> 00:07:09,330
We could have picked X and went to ten

00:07:09,340 --> 00:07:12,720
like Apple.

00:07:12,720 --> 00:07:14,741
We kept joking. Ah, we'll just call it nine

00:07:14,741 --> 00:07:16,121
thousand.

00:07:22,480 --> 00:07:24,980
I hope people can hear this.

00:07:24,980 --> 00:07:25,540
-VIDEO-

00:07:25,540 --> 00:07:27,120
Character: What does the scouter say about his power

00:07:27,120 --> 00:07:27,740
level?

00:07:28,100 --> 00:07:30,580
OTHER: It's over nine thousand!!!

00:07:30,580 --> 00:07:33,040
Character: What, nine thousand? There is no way that

00:07:33,040 --> 00:07:34,680
can be right!

00:07:37,240 --> 00:07:40,080
T.E.: OK, and if you couldn't hear that, he

00:07:40,080 --> 00:07:44,840
said it's over nine thousand.

00:07:44,840 --> 00:07:47,780
But our next version is actually JRuby 9000.

00:07:53,900 --> 00:07:55,640
And for those people who don't like it, it's

00:07:55,640 --> 00:07:58,100
just a number. Get over it.

00:07:58,100 --> 00:08:02,841
C.N.: Now that - the work on JRuby 9000's

00:08:02,841 --> 00:08:05,399
actually already started. It's been going faster than we

00:08:05,400 --> 00:08:08,630
expected. This is just some, some simple stats comparing

00:08:08,630 --> 00:08:12,010
the JRuby 1.7 line with Master. And we're stripping

00:08:12,020 --> 00:08:15,850
out a ton of code by removing 1.8 support,

00:08:15,850 --> 00:08:18,350
removing, not having two or three copies of standard

00:08:18,360 --> 00:08:20,091
library.

00:08:20,100 --> 00:08:23,239
Getting the whole of JRuby much smaller. Probably the

00:08:23,240 --> 00:08:25,541
best one here is the, the complete jar, which

00:08:25,541 --> 00:08:28,609
is JRuby plus the entire standard library all in

00:08:28,609 --> 00:08:31,531
one file, is already down by about four meg,

00:08:31,540 --> 00:08:33,790
so we're, we're getting better and better at shrinking

00:08:33,790 --> 00:08:34,889
down the runtime.

00:08:34,889 --> 00:08:37,570
We'll talk a little bit about what we're doing

00:08:37,580 --> 00:08:40,281
to improve the ecosystem going forward. Probably the most

00:08:40,281 --> 00:08:43,660
difficult part of developing JRuby, and we're definitely spent

00:08:43,660 --> 00:08:46,960
the most amount of time, is simply on compatibility.

00:08:46,960 --> 00:08:50,400
We're constantly chasing a moving target - MRI, which

00:08:50,400 --> 00:08:54,569
has, at various times, had very fast development progress,

00:08:54,569 --> 00:08:55,951
added large features.

00:08:55,980 --> 00:08:57,880
And so we've always kind of been trying to

00:08:57,880 --> 00:09:00,790
catch up. What we're hoping is that with JRuby

00:09:00,790 --> 00:09:03,009
9000, we'll be able to match directly up with

00:09:03,009 --> 00:09:06,341
the 2 point 1 compatibility, hopefully right around when

00:09:06,341 --> 00:09:09,220
they do 2 point 1 release of MRI.

00:09:09,220 --> 00:09:11,270
We'll have all the features implemented. And then we'll

00:09:11,270 --> 00:09:13,580
be at our leisure to release or continue working

00:09:13,580 --> 00:09:16,700
on performance runtime stuff. But hopefully now, being able

00:09:16,700 --> 00:09:19,249
to stay in lock step with MRI and the

00:09:19,260 --> 00:09:20,820
features that they add.

00:09:20,820 --> 00:09:22,231
So the things that we know are still missing.

00:09:22,240 --> 00:09:25,509
From 1 point 9, spawn plus all of the

00:09:25,509 --> 00:09:28,601
different file opening options and redirects and other things.

00:09:28,601 --> 00:09:31,150
There's a lot of those pieces missing. Largely missing

00:09:31,150 --> 00:09:34,850
because the JVMs own process management APIs don't support

00:09:34,860 --> 00:09:37,210
most of them. It's very difficult to do them.

00:09:37,210 --> 00:09:38,830
We'll probably have to do a native call-out to

00:09:38,840 --> 00:09:41,860
do these in full, have full support for them.

00:09:41,860 --> 00:09:44,330
We do have full transcoding support now, and it

00:09:44,330 --> 00:09:46,700
does work well. We fixed a ton of issues

00:09:46,700 --> 00:09:49,270
and did a complete rewrite of IO transcoding and

00:09:49,280 --> 00:09:52,759
coding stuff for 1.7.5 that seems to be doing

00:09:52,760 --> 00:09:55,060
well. We haven't gotten any real major issues with

00:09:55,060 --> 00:09:55,591
it.

00:09:55,600 --> 00:10:00,269
But we're using all the JVMs character-based UTF16 transcoders,

00:10:00,269 --> 00:10:02,690
so everything has to go to UTF16 and then

00:10:02,700 --> 00:10:05,241
back out to the target encoding. That's overhead we'd

00:10:05,241 --> 00:10:07,980
like to eliminate by porting over the same byte

00:10:07,980 --> 00:10:10,569
array based transcoding support that MRI has.

00:10:10,569 --> 00:10:12,521
And that's probably gonna come up soon.

00:10:12,521 --> 00:10:15,030
2 point 1 stuff that we know we're missing.

00:10:15,030 --> 00:10:17,359
Prepend. We don't have it in there yet. Shouldn't

00:10:17,360 --> 00:10:20,071
be too difficult. Refinements are going to be officially

00:10:20,080 --> 00:10:23,629
a feature in 2.1. I've worked pretty closely with

00:10:23,629 --> 00:10:25,100
a lot of the MRI folks to try and

00:10:25,100 --> 00:10:27,131
strip down the feature a little bit, make it

00:10:27,140 --> 00:10:30,069
not as invasive, not as damaging to performance. And

00:10:30,069 --> 00:10:32,691
I think we're, we're confident now that we can

00:10:32,700 --> 00:10:35,450
implement it in JRuby without a major impact.

00:10:35,450 --> 00:10:37,280
But it's not there yet. We'll have that hopefully

00:10:37,280 --> 00:10:39,929
by the time MRI 2 point 1 comes out.

00:10:39,940 --> 00:10:42,211
And then there's enumerator enhancements that are not quite

00:10:42,220 --> 00:10:45,110
there yet. Size is there, lazy stuff - size

00:10:45,110 --> 00:10:47,770
isn't there, lazy is. Little bits and pieces from

00:10:47,780 --> 00:10:50,280
2 point 1 that we, we still need to

00:10:50,280 --> 00:10:50,910
implement.

00:10:50,920 --> 00:10:53,100
We're always trying to work on improving the, the

00:10:53,100 --> 00:10:57,089
platform in general. Not just for JRuby either. For

00:10:57,089 --> 00:10:58,531
example, lots of gems for thread safety - I'll

00:10:58,540 --> 00:11:02,300
talk about later. Gems, like FFI, for calling out

00:11:02,300 --> 00:11:05,910
to native libraries. Database access, image stuff. All this

00:11:05,910 --> 00:11:08,069
thing- all these things to fill in the blanks

00:11:08,080 --> 00:11:09,960
for JRuby users.

00:11:09,960 --> 00:11:13,760
We're constantly working with gem authors to improve performance

00:11:13,760 --> 00:11:16,150
of their libraries on JRuby and performance in general,

00:11:16,150 --> 00:11:19,500
in a lot of cases. Fixed threading problems. More

00:11:19,500 --> 00:11:23,000
and more Ruby gem authors and library authors have

00:11:23,000 --> 00:11:25,380
started to pay attention to threading, testing stuff on

00:11:25,380 --> 00:11:28,461
JRuby, testing in concurrent situations. So we're looking pretty

00:11:28,461 --> 00:11:30,769
good in that area, too.

00:11:30,780 --> 00:11:33,121
Probably the biggest thing is trying to get more

00:11:33,121 --> 00:11:37,170
Rubyists testing their stuff on JRuby. Travis is a

00:11:37,170 --> 00:11:39,530
nice, easy way to do it, otherwise, an RVM

00:11:39,540 --> 00:11:41,730
set-up, getting something local that you can test on,

00:11:41,730 --> 00:11:44,069
to help improve the whole platform.

00:11:44,069 --> 00:11:47,161
We're also going to continue trying to improve how

00:11:47,161 --> 00:11:49,849
closely we work with MRI. I've been active on

00:11:49,860 --> 00:11:52,430
a lot of issues. All of JRuby team members

00:11:52,430 --> 00:11:54,560
have been active on issues in the Ruby bug

00:11:54,560 --> 00:11:58,620
tracker, especially feature-related futures for Ruby that are going

00:11:58,620 --> 00:11:59,620
to affect JRuby.

00:11:59,620 --> 00:12:02,951
Trying to do more on that. Especially since JRuby's

00:12:02,960 --> 00:12:05,419
kind of leaned away on concurrency and parallel execution

00:12:05,420 --> 00:12:08,240
of Ruby code, trying to push that forward and,

00:12:08,240 --> 00:12:10,281
and take the lead on figuring out how that's

00:12:10,281 --> 00:12:11,330
supposed to look.

00:12:11,330 --> 00:12:12,999
I'm actually a committer on MRI, and I've fixed

00:12:13,000 --> 00:12:15,550
a few things. Hopefully doing more of that in

00:12:15,560 --> 00:12:17,731
the future, try and clean up standard library. Get

00:12:17,740 --> 00:12:21,629
some threading utilities in there, get some cleanup done.

00:12:21,629 --> 00:12:23,260
And, and just in general trying to help improve

00:12:23,280 --> 00:12:25,700
the process of evolving Ruby based on how we

00:12:25,700 --> 00:12:27,371
do JRuby development.

00:12:27,371 --> 00:12:30,160
So let's talk a little bit about performance that

00:12:30,160 --> 00:12:32,769
we're gonna work on in the future. So there's

00:12:32,769 --> 00:12:34,670
a lot that we can do to continue making

00:12:34,670 --> 00:12:38,271
JRuby faster, make Ruby in general faster.

00:12:38,280 --> 00:12:40,290
The challenges are, we've got lots and lots of

00:12:40,290 --> 00:12:44,429
dynamic calls, very dynamic object structures, lots of indirection

00:12:44,440 --> 00:12:47,760
around. The structure of the objects isn't even fixed

00:12:47,760 --> 00:12:50,750
at startup time. It's defined as instance variables up

00:12:50,750 --> 00:12:52,891
here. So there's more and more we need to

00:12:52,920 --> 00:12:54,069
do.

00:12:54,069 --> 00:12:55,690
The first step of what we do as far

00:12:55,690 --> 00:12:58,000
as performance is basically just compiling things down to

00:12:58,000 --> 00:13:01,981
byte code. The JVM likes byte code, obviously, and

00:13:01,981 --> 00:13:04,929
that's what it optimizes. So that's the simple first

00:13:04,929 --> 00:13:05,711
step.

00:13:05,720 --> 00:13:08,520
What we can do more of here is generating

00:13:08,520 --> 00:13:11,549
real classes for the Ruby classes that you create,

00:13:11,549 --> 00:13:15,341
so the JVM sees a normal Java class object.

00:13:15,341 --> 00:13:18,249
Generating instance variable tables that are directly in the

00:13:18,260 --> 00:13:21,091
object rather than ass a tag-a-long data structure. Shrinking

00:13:21,100 --> 00:13:23,490
everything down, reducing the amount of indirection that we

00:13:23,490 --> 00:13:25,080
have.

00:13:25,080 --> 00:13:27,919
We've also been hitting invoke dynamic pretty hard. Invoke

00:13:27,920 --> 00:13:31,031
dynamic is a feature added to Java 7, that

00:13:31,040 --> 00:13:34,100
basically makes it possible for dynamic languages to plug

00:13:34,100 --> 00:13:37,519
directly into the JVM and optimize, like, any statically

00:13:37,520 --> 00:13:38,890
typed language.

00:13:38,890 --> 00:13:42,070
It has a byte code, of course, that represents

00:13:42,070 --> 00:13:46,180
a dynamic call, and then a series of handles

00:13:46,180 --> 00:13:50,470
and, and manipulators, and argument modifiers to basically describe

00:13:50,480 --> 00:13:52,570
how to do the dynamic call in a way

00:13:52,570 --> 00:13:54,310
the JVM can optimize straight through.

00:13:54,320 --> 00:13:56,951
Now does this actually work? Does this actually optimize

00:13:56,960 --> 00:13:57,269
well?

00:13:57,269 --> 00:14:00,130
Well, this is one of the bench marks I've

00:14:00,130 --> 00:14:03,430
been showing. It's, the red-black tree C-extension, and the

00:14:03,460 --> 00:14:07,140
Java extension, compared to pure Ruby version.

00:14:07,140 --> 00:14:09,471
So if we look at Ruby 1.9 and 2.0

00:14:09,471 --> 00:14:12,069
with the pure Ruby version, Ruby 2 does a

00:14:12,069 --> 00:14:14,740
ton of stuff to improve performance. Some of these

00:14:14,740 --> 00:14:17,370
are inspired by what we've done in JRuby, reducing

00:14:17,370 --> 00:14:20,000
call overhead and so on, but there's definitely a

00:14:20,000 --> 00:14:22,730
good improvement in 2.0 and 2.1 as far as

00:14:22,740 --> 00:14:25,370
straight-line performance of Ruby code.

00:14:25,370 --> 00:14:27,870
Maglov and MacRuby, I don't know if anybody's using

00:14:27,880 --> 00:14:31,010
those lately. They, they do better. They have actually

00:14:31,010 --> 00:14:33,550
git optimizations that they do, and then are able

00:14:33,560 --> 00:14:35,081
to be about twice as fast as Ruby 2.0

00:14:35,081 --> 00:14:38,869
just by doing some fairly simply gitting.

00:14:38,869 --> 00:14:41,680
Rubinius has more of an optimizing git, and so

00:14:41,680 --> 00:14:43,550
it, running Ruby code, it actually starts to get

00:14:43,560 --> 00:14:47,250
comparable to the CRuby versions running with the C

00:14:47,250 --> 00:14:47,961
extension.

00:14:47,961 --> 00:14:49,909
The overhead of the Ruby code that wraps the

00:14:49,920 --> 00:14:52,661
C extension, and the call-outs to the C extension

00:14:52,661 --> 00:14:56,030
start to become more overhead for MRI here. And

00:14:56,030 --> 00:14:59,249
now these are the cool ones actually.

00:14:59,260 --> 00:15:02,471
So this is JRuby on invoke dynamic on Java

00:15:02,480 --> 00:15:05,280
7 or 8, with the pure Ruby version in

00:15:05,280 --> 00:15:08,090
the gray here. And it's actually, you know, not

00:15:08,090 --> 00:15:10,669
quite twice as fast as Ruby 2.0 with the

00:15:10,669 --> 00:15:12,870
C extension. So we're actually able to run the

00:15:12,880 --> 00:15:16,281
Ruby version of the red-black tree extension, or red/black

00:15:16,281 --> 00:15:19,489
tree library, almost as fast, a lot faster in

00:15:19,489 --> 00:15:21,310
some cases, as the C extension.

00:15:21,320 --> 00:15:23,360
And then of course JRuby in the Java extension.

00:15:23,360 --> 00:15:25,291
Since it all just looks like Java, regardless of

00:15:25,300 --> 00:15:27,650
whether you're calling into a Java library or calling

00:15:27,650 --> 00:15:29,989
from Ruby code, the JVM is able to do

00:15:29,989 --> 00:15:32,860
a significant optimization on that.

00:15:32,860 --> 00:15:35,980
Now, this is great, and invoke dynamic definitely works,

00:15:35,980 --> 00:15:37,331
as far as the performance you can get out

00:15:37,340 --> 00:15:40,660
of it. But there is a caveat here.

00:15:40,660 --> 00:15:42,330
So invoke dynamic, when it first came out in

00:15:42,330 --> 00:15:45,010
Java 7, was very slow. It got fast in

00:15:45,020 --> 00:15:48,340
the first, the, the second update to Java 7,

00:15:48,340 --> 00:15:50,700
but that was also broken. There was some severe

00:15:50,700 --> 00:15:53,950
issues that, when you deployed in production it wouldn't

00:15:53,950 --> 00:15:54,960
run properly.

00:15:54,960 --> 00:15:58,640
7, update 40, rewrote it, and it is now

00:15:58,640 --> 00:16:02,200
100% compatible, 100% no bugs with it. But it's

00:16:02,200 --> 00:16:04,630
very slow to warm up, and it uses significantly

00:16:04,640 --> 00:16:08,109
more memory than the original implementation did.

00:16:08,109 --> 00:16:10,821
So it's probably going to settle more on Java

00:16:10,821 --> 00:16:13,219
8. We have had a few users using Java

00:16:13,220 --> 00:16:15,071
8 with invoke dynamic, not reporting any of the

00:16:15,080 --> 00:16:17,739
issues that we had during the Java 7 time

00:16:17,740 --> 00:16:18,161
frame.

00:16:18,161 --> 00:16:19,780
So if you're interested in getting the best performance

00:16:19,800 --> 00:16:21,870
out of it, the Java 8 preview builds would

00:16:21,870 --> 00:16:23,629
be a good way to test it out.

00:16:23,629 --> 00:16:25,750
Now, because of all these issues we continue to

00:16:25,750 --> 00:16:27,720
look at other options. One of them that came

00:16:27,720 --> 00:16:31,321
up recently is a couple non-JVM git projects out

00:16:31,321 --> 00:16:34,219
of Oracle, call- there's one called Graal, which is

00:16:34,220 --> 00:16:38,060
basically an API directly to the git in the

00:16:38,060 --> 00:16:41,321
JVM, and Truffle, which allows you to take languages

00:16:41,321 --> 00:16:45,140
AST, abstract syntax tree, and, and basically convert it

00:16:45,140 --> 00:16:47,690
directly into Graal calls, and optimize it down.

00:16:47,690 --> 00:16:50,979
Now the early numbers on this have looked good.

00:16:51,000 --> 00:16:53,180
Oracle did spend about six months doing a proof

00:16:53,180 --> 00:16:56,550
of concept Ruby implementation on top of Truffle. That's

00:16:56,550 --> 00:17:00,081
about five or six times faster than JRuby, but

00:17:00,081 --> 00:17:02,640
the problem here is that they've only got about

00:17:02,640 --> 00:17:06,150
half of the, in this case, Ruby spec passing,

00:17:06,160 --> 00:17:07,680
and there's a lot more that needs to be

00:17:07,680 --> 00:17:09,420
done. There's probably two or three years worth of

00:17:09,440 --> 00:17:11,270
work to get that going.

00:17:11,270 --> 00:17:12,760
What we're hoping is that maybe we'll have some

00:17:12,760 --> 00:17:15,650
time to explore building a Truffle of Graal based

00:17:15,650 --> 00:17:17,200
backend in JRuby itself.

00:17:17,200 --> 00:17:18,860
T.E.: And, and once you add some of the

00:17:18,860 --> 00:17:22,300
extra vagries of what Ruby does, that performance is

00:17:22,300 --> 00:17:23,210
probably going to drop.

00:17:23,210 --> 00:17:24,770
C.N.: Yeah, exactly. There's a lot of other stuff

00:17:24,780 --> 00:17:26,230
that they have to put in there. And, and

00:17:26,230 --> 00:17:29,500
these libraries are a big part of performance, too.

00:17:29,500 --> 00:17:30,000
So.

00:17:30,000 --> 00:17:32,550
And, I'll hand it over here to talk a

00:17:32,560 --> 00:17:34,060
little bit more about the new IR-based compiler that

00:17:34,060 --> 00:17:36,640
we're also working on.

00:17:36,640 --> 00:17:41,450
T.E.: Yeah, so, IR stands for internal representation, which

00:17:41,450 --> 00:17:43,670
is probably not the most inventive name that we

00:17:43,680 --> 00:17:46,190
could have come up with. But it's our new

00:17:46,200 --> 00:17:53,190
runtime. Subramanya Swarovski created the bulk of IR up

00:17:53,740 --> 00:17:56,450
to this point. He's the guy who got a

00:17:56,450 --> 00:18:01,540
PhD in writing a Java optimizing compiler.

00:18:01,560 --> 00:18:04,720
And he basically created an architecture that's very similar

00:18:04,720 --> 00:18:07,560
to a compiler architecture, if you read like the

00:18:07,560 --> 00:18:12,740
Dragon book, or took a course at university.

00:18:12,740 --> 00:18:14,950
And we really wanted to create a new runtime

00:18:14,960 --> 00:18:17,230
because we were fed-up with trying to do these

00:18:17,230 --> 00:18:23,240
optimizations directly from AST. We also wanted something that

00:18:23,240 --> 00:18:25,310
we weren't going to want to rewrite five years

00:18:25,310 --> 00:18:27,300
from now. So we wanted it to be easy

00:18:27,300 --> 00:18:29,860
to go and plug in to optimizations and have

00:18:29,860 --> 00:18:33,130
a lot of growth.

00:18:33,160 --> 00:18:35,120
So here's what IR sort of looks like at

00:18:35,120 --> 00:18:39,680
the top, for JRuby 1.7 and below we'll, will

00:18:39,680 --> 00:18:42,620
lex and parse Ruby code and generate an abstract

00:18:42,620 --> 00:18:46,090
syntax tree, and then will either interpret that until

00:18:46,090 --> 00:18:48,690
it gets warm, and then we'll translate it to

00:18:48,690 --> 00:18:52,810
Java byte code as part of a git, but

00:18:52,820 --> 00:18:56,900
in the new IR landscape for 9k, we'll perform

00:18:56,900 --> 00:19:00,900
some semantic analysis and translate that syntax tree into

00:19:00,900 --> 00:19:04,420
a set of instructions and operands that represent Ruby

00:19:04,420 --> 00:19:07,040
semantics, instead of just syntax.

00:19:07,040 --> 00:19:09,370
We'll create some supplementary data centers, like a control

00:19:09,370 --> 00:19:13,260
flow graph. After that, we can run a series

00:19:13,260 --> 00:19:17,400
of optimizations on that, create some more data structures,

00:19:17,400 --> 00:19:21,680
change some of these existing ones, and then hopefully

00:19:21,680 --> 00:19:24,290
we'll build a maintain a very thin layer for

00:19:24,290 --> 00:19:29,000
an interpreter. Pretty simple byte code generation layer, and

00:19:29,020 --> 00:19:30,940
we'll be able to expand it out later on

00:19:30,940 --> 00:19:31,690
to things like Dalvik.

00:19:31,690 --> 00:19:32,670
C.N.: Ideally trying to do as many optimizations as

00:19:32,670 --> 00:19:35,780
possible, before we even get to the point of

00:19:35,780 --> 00:19:38,520
generating byte code.

00:19:38,520 --> 00:19:41,900
T.E.: So here's our first look at what the

00:19:41,900 --> 00:19:45,480
instructions are. I'll just go down a few of

00:19:45,480 --> 00:19:45,780
these.

00:19:45,780 --> 00:19:47,430
At the very top, we make sure that there's

00:19:47,440 --> 00:19:51,800
two required arguments with check_arity. The next three instructions

00:19:51,800 --> 00:19:54,870
we assign the parameters, a, b, but then we

00:19:54,870 --> 00:19:58,030
also assign the closure, in case someone actually supplied

00:19:58,060 --> 00:20:00,330
a block to it.

00:20:00,330 --> 00:20:02,390
Down at line six you can see c equals

00:20:02,400 --> 00:20:06,150
one, looks like the left side, and lines eight

00:20:06,150 --> 00:20:09,710
and nine represent d equals a plus c. This

00:20:09,710 --> 00:20:13,450
one doesn't quite read as nice, but it's still

00:20:13,460 --> 00:20:17,880
pretty simple.

00:20:17,880 --> 00:20:20,160
We can do all the optimizations that you would

00:20:20,160 --> 00:20:22,660
expect if you took a compiler's course. If we

00:20:22,660 --> 00:20:25,000
find code that we can remove that won't effect

00:20:25,000 --> 00:20:28,820
how the program runs, we can just eliminate it.

00:20:28,820 --> 00:20:32,070
If we, if we see a constant value that

00:20:32,070 --> 00:20:34,730
we know doesn't change, we can just propagate that

00:20:34,740 --> 00:20:36,750
to where it's used and get rid of the,

00:20:36,750 --> 00:20:40,280
the dereferencing from the variable.

00:20:40,280 --> 00:20:42,500
We can inline methods and blocks that we're not

00:20:42,520 --> 00:20:43,990
actually using a lot yet.

00:20:43,990 --> 00:20:46,540
C.N.: We do have some early inlines for it

00:20:46,540 --> 00:20:48,900
though, so it is possible we have managed to

00:20:48,900 --> 00:20:49,290
make it work.

00:20:49,290 --> 00:20:51,250
T.E.: Oh it, it totally works. It's just figuring

00:20:51,250 --> 00:20:52,750
out when to do it is, is a much

00:20:52,780 --> 00:20:57,380
harder problem than we realized.

00:20:57,380 --> 00:20:59,010
So here, if we run a couple passes, you

00:20:59,010 --> 00:21:01,340
can see that we got rid of about half

00:21:01,340 --> 00:21:03,330
the lines of code. You can see we didn't

00:21:03,330 --> 00:21:05,890
use closure, so we just eliminated that, same with

00:21:05,910 --> 00:21:11,940
the variable b. On line six equals one, we

00:21:11,940 --> 00:21:14,780
know that it never changes, so we propagate the

00:21:14,780 --> 00:21:18,250
value one down to the plus call, so now

00:21:18,260 --> 00:21:19,920
we're doing a plus one instead of a plus

00:21:20,000 --> 00:21:20,300
c.

00:21:20,300 --> 00:21:26,980
And, in general, we're reducing overhead. We have things

00:21:26,980 --> 00:21:30,570
like block that is given, littered through our code

00:21:30,570 --> 00:21:35,140
base. This is a check that's really fast. But

00:21:35,140 --> 00:21:37,630
it's not free. If you compare that to the

00:21:37,640 --> 00:21:43,120
dead code elimination aspect of receiving this block as

00:21:43,120 --> 00:21:45,050
an instruction, if we can eliminate it, then we're

00:21:45,050 --> 00:21:48,250
doing absolutely no work, and no work's better than

00:21:48,260 --> 00:21:48,650
some work.

00:21:48,650 --> 00:21:49,850
C.N.: And then as we're able to do some

00:21:49,860 --> 00:21:52,950
more inlining, a lot of these same optimizations will

00:21:52,950 --> 00:21:55,820
propagate through multiple methods. Like if it turns out

00:21:55,820 --> 00:21:59,230
that a plus one, a was also a fixnum,

00:21:59,240 --> 00:22:00,890
while maybe we inline it and just turns in

00:22:00,890 --> 00:22:02,510
to it at that point.

00:22:02,520 --> 00:22:04,190
So there's a lot of stuff that we can

00:22:04,190 --> 00:22:06,630
do to, to optimize through code once we get

00:22:06,640 --> 00:22:07,140
the inlining working.

00:22:07,140 --> 00:22:08,930
T.E.: And you can just keep reapplying some of

00:22:08,930 --> 00:22:11,340
the same optimizations after that inlining and just-

00:22:11,340 --> 00:22:11,730
C.N.: Right.

00:22:11,740 --> 00:22:12,530
T.E.: -keeps boiling down.

00:22:12,530 --> 00:22:14,760
C.N.: That's the black magic of compiler optimization. When

00:22:14,760 --> 00:22:16,650
do you stop?

00:22:16,660 --> 00:22:19,990
All right, so concurrency-wise, most folks know that this

00:22:19,990 --> 00:22:23,520
is the, the situation in general. Ruby 1.8 was

00:22:23,520 --> 00:22:27,090
green-threaded, Ruby 1.9 plus all have actual native threads

00:22:27,100 --> 00:22:29,410
but don't allow parallel execution because of the global

00:22:29,410 --> 00:22:30,560
lock.

00:22:30,560 --> 00:22:32,230
Whereas on JRuby, because it's on the JVM, the

00:22:32,240 --> 00:22:35,320
JVM's had real parallel threads for a long time,

00:22:35,320 --> 00:22:37,860
we do actually have real threads, you can actually

00:22:37,860 --> 00:22:41,620
saturate an entire machine with just one JRuby process.

00:22:41,620 --> 00:22:43,730
And where this really comes into play is the

00:22:43,730 --> 00:22:47,110
cost of deploying wide applications for a lot of

00:22:47,120 --> 00:22:51,550
users. You look at a ten-way concurrent in MRI,

00:22:51,550 --> 00:22:54,230
each process is maybe a hundred, two hundred megabytes.

00:22:54,240 --> 00:22:57,120
If it's two hundred megabytes, that's two gigabytes of

00:22:57,120 --> 00:22:58,830
memory that you need to allocate. And that's not

00:22:58,830 --> 00:23:00,800
a, that's not a trivial instance. It's not a

00:23:00,800 --> 00:23:01,830
huge on.

00:23:01,840 --> 00:23:03,490
But then, what if we need to scale this

00:23:03,490 --> 00:23:04,800
thing up? And what if we need to handle

00:23:04,800 --> 00:23:07,230
a hundred concurrent users? Well, then we need to

00:23:07,240 --> 00:23:09,810
have a hundred-way concurrency in MRI, which means a

00:23:09,820 --> 00:23:12,300
hundred processes. Now we're getting into twenty gig. This

00:23:12,300 --> 00:23:14,730
is getting into the very high, very expensive end

00:23:14,730 --> 00:23:17,780
of, for example EC2 instances.

00:23:17,780 --> 00:23:20,750
We recently had someone make a migration to JRuby

00:23:20,750 --> 00:23:23,670
and save something like fifteen thousand dollars a month

00:23:23,680 --> 00:23:26,880
by moving from a whole set of extra larges,

00:23:26,880 --> 00:23:28,920
down to like, five mediums.

00:23:28,920 --> 00:23:31,020
And so there are real, tangible benefits to making

00:23:31,040 --> 00:23:34,430
a move to JRuby and, and getting threading working

00:23:34,430 --> 00:23:36,080
well for your application.

00:23:36,080 --> 00:23:38,330
Look at how it is in JRuby. One instance,

00:23:38,330 --> 00:23:39,740
it's going to be a little bit more, a

00:23:39,760 --> 00:23:41,810
little bit larger as a base cost, but you

00:23:41,810 --> 00:23:44,280
can handle ten instances, ten concurrent, you can handle

00:23:44,280 --> 00:23:46,540
a hundred concurrent. You can handle whatever the machine's

00:23:46,540 --> 00:23:49,080
capable of handling, pretty much with one process. Maybe

00:23:49,080 --> 00:23:51,400
you have one for fall back, but it's, it's

00:23:51,400 --> 00:23:55,100
a tremendous difference as far as scaling.

00:23:55,100 --> 00:23:56,880
But there's challenges here, too, and this is where

00:23:56,880 --> 00:23:58,550
a lot of the future work needs to come

00:23:58,550 --> 00:24:00,520
in. The Ruby world and the Ruby libraries out

00:24:00,520 --> 00:24:03,050
there are still kind of growing into concurrency, growing

00:24:03,050 --> 00:24:05,890
into parallelism. And there hasn't been a big emphasis

00:24:05,900 --> 00:24:09,070
on threading or concurrent execution in the Ruby world.

00:24:09,080 --> 00:24:10,500
And so there's more that we need to do.

00:24:10,500 --> 00:24:12,210
We need tools to make it easier. We need

00:24:12,210 --> 00:24:13,560
a lot, we need to help make these libraries

00:24:13,560 --> 00:24:15,410
thread safe.

00:24:15,410 --> 00:24:17,480
These are some of the key unsafe operations that

00:24:17,480 --> 00:24:20,850
you're gonna see in, in libraries that aren't thread

00:24:20,860 --> 00:24:24,500
safe. Concurrent read and write on, on data structures,

00:24:24,500 --> 00:24:26,370
like array, hash - those are not guaranteed to

00:24:26,380 --> 00:24:28,630
be thread safe. So if you're not doing mutexing

00:24:28,630 --> 00:24:30,450
around those they can be a problem.

00:24:30,450 --> 00:24:32,980
A lot of people don't realize that, that calls

00:24:32,980 --> 00:24:37,940
like this are not done automatically in any implementation.

00:24:37,940 --> 00:24:40,330
There's a possibility of a thread jumping in there

00:24:40,360 --> 00:24:42,030
and doing the same increment at the same time.

00:24:42,030 --> 00:24:43,900
You get different results out of it.

00:24:43,900 --> 00:24:46,780
In this one, if my cache really, really needs

00:24:46,780 --> 00:24:49,220
to be allocated only once, this is not a

00:24:49,220 --> 00:24:51,120
safe way to do it, because it's very possible

00:24:51,120 --> 00:24:52,860
that you may allocate two of them if two

00:24:52,860 --> 00:24:55,930
threads get to that code at the same time.

00:24:55,930 --> 00:24:58,370
Thread pooling's tough, we need better libraries to do

00:24:58,380 --> 00:25:01,210
that. Ideally some things that start to get into

00:25:01,210 --> 00:25:03,590
Ruby core. And then just coordinating between threads. Better

00:25:03,600 --> 00:25:06,900
ways of communicating and synchronizing threads together.

00:25:06,900 --> 00:25:09,390
So a few gems that we, we, we like,

00:25:09,390 --> 00:25:11,760
some of these we maintain, some are from friends

00:25:11,760 --> 00:25:15,630
of ours. The thread_safe gem provides concurrency-safe hash and

00:25:15,630 --> 00:25:18,560
array. It also provides, I'm not showing here, a

00:25:18,560 --> 00:25:22,740
cache class, which is very, it's hash-like, but it

00:25:22,800 --> 00:25:25,360
uses some of the techniques that the, the Java

00:25:25,360 --> 00:25:28,660
concurrency engineers use for concurrent hash map to do

00:25:28,660 --> 00:25:30,770
fast multi-threaded hash map implementation.

00:25:30,770 --> 00:25:33,860
But otherwise pretty simple. You construct it, you use

00:25:33,880 --> 00:25:35,690
it like a normal hash almost. And it works

00:25:35,690 --> 00:25:39,250
pretty much the same way.

00:25:39,250 --> 00:25:42,850
Hamster is a set of persistent collections for Ruby.

00:25:42,860 --> 00:25:45,060
The difference with persistent collections is that you never

00:25:45,060 --> 00:25:48,580
mutate it in place. Every mutation operation gives you

00:25:48,580 --> 00:25:52,130
a new reference, which is that old collection with

00:25:52,140 --> 00:25:54,090
this change applied to it.

00:25:54,090 --> 00:25:55,850
So the object you have in hand is always

00:25:55,850 --> 00:25:59,010
basically read-only, and you know that no other mutations

00:25:59,010 --> 00:26:02,420
happening in the system will impact your reads of

00:26:02,440 --> 00:26:02,800
it.

00:26:02,800 --> 00:26:03,660
So it's a hundred percent safe as far as

00:26:03,660 --> 00:26:06,360
concurrency goes, and the nice thing about it is

00:26:06,360 --> 00:26:08,600
it avoids any sort of locking or magic tricks

00:26:08,600 --> 00:26:11,530
under the cover. You just getting a new view

00:26:11,530 --> 00:26:14,110
of this data structure that everyone still has their

00:26:14,110 --> 00:26:14,370
old view of.

00:26:14,370 --> 00:26:17,780
I won't walk through the whole example here but,

00:26:17,780 --> 00:26:20,600
it's, it's fairly simple to use. Every other mutation,

00:26:20,620 --> 00:26:23,260
you just assign the result and then you've got

00:26:23,260 --> 00:26:25,040
your new collection as a result.

00:26:25,040 --> 00:26:28,290
So for those atomic updates, or equals, plus equals

00:26:28,300 --> 00:26:31,820
and so on, there's the atomic gem. Atomic gem

00:26:31,820 --> 00:26:34,130
basically gives you a wrapped value that you can

00:26:34,130 --> 00:26:38,040
do atomic updates to. Increment it atomically, perform some

00:26:38,040 --> 00:26:41,710
Ruby action atomically, and will only happen if nobody

00:26:41,710 --> 00:26:44,200
else jumps in. So, so you'll get the atomic

00:26:44,200 --> 00:26:47,020
right. Other threads will have to retry again. But

00:26:47,020 --> 00:26:49,090
it guarantees that no one's gonna step on each

00:26:49,090 --> 00:26:49,500
other.

00:26:49,500 --> 00:26:52,420
This is a simple example. We create an atomic

00:26:52,420 --> 00:26:55,010
object at the top, which is just a fixnum

00:26:55,020 --> 00:26:57,180
zero. We can get the value out, we can

00:26:57,180 --> 00:26:59,740
swap it for another value. And then the more

00:26:59,740 --> 00:27:02,790
interesting one's doing compare and swap, if the existing

00:27:02,800 --> 00:27:06,120
value is two, put three in there. And then

00:27:06,120 --> 00:27:07,930
the second line, since we know it's not two

00:27:07,930 --> 00:27:09,670
anymore, that's not gonna happen. This is how we

00:27:09,670 --> 00:27:12,130
keep threads from stepping on each other's updates.

00:27:12,130 --> 00:27:14,190
You can try to make an update, only if

00:27:14,200 --> 00:27:17,710
it's the same state you expect. Down here, doing

00:27:17,720 --> 00:27:21,730
more advanced atomic updates. Update with a block will

00:27:21,730 --> 00:27:23,980
only make that change if no other thread jumps

00:27:23,980 --> 00:27:25,230
in there at the same time.

00:27:25,240 --> 00:27:27,630
And if the, if you need the, if another

00:27:27,640 --> 00:27:30,870
thread jumps in, it'll try and make the change.

00:27:30,880 --> 00:27:33,100
It'll eith- in this case, it'll redo that block

00:27:33,100 --> 00:27:34,890
and down here it'll raise an error. You can

00:27:34,890 --> 00:27:36,820
decide whether you want to try to continue doing

00:27:36,820 --> 00:27:40,480
this update.

00:27:40,480 --> 00:27:42,500
So the bottom line for these libraries is that

00:27:42,500 --> 00:27:45,010
concurrency really can work in Ruby, and there's a

00:27:45,010 --> 00:27:47,690
lot of people doing highly concurrent applications on JRuby

00:27:47,690 --> 00:27:49,640
right now. But we need the right kind of

00:27:49,640 --> 00:27:52,160
tools and the right patterns to do it.

00:27:52,160 --> 00:27:54,740
Immutability really helps. Having some of these sort of

00:27:54,740 --> 00:27:58,040
data structures helps. And testing on JRuby is really

00:27:58,040 --> 00:28:00,760
the only way to know if your library is

00:28:00,760 --> 00:28:03,350
gonna be thread safe. We've got the most extensive

00:28:03,350 --> 00:28:04,870
threading support, and we've had it for the longest,

00:28:04,870 --> 00:28:07,020
so it's just best if you test it on

00:28:07,020 --> 00:28:07,880
JRuby to make sure.

00:28:07,880 --> 00:28:10,850
T.E.: OK, I mentioned earlier that I wanted to

00:28:10,850 --> 00:28:14,550
talk about improving embedding, especially since we're moving to

00:28:14,560 --> 00:28:19,360
a new major version that's gonna break APIs.

00:28:19,360 --> 00:28:21,730
First thing is, public is similar to public in

00:28:21,730 --> 00:28:24,720
Ruby in that once something's marked public, anything can

00:28:24,720 --> 00:28:28,410
call it. We have a huge code base and

00:28:28,420 --> 00:28:30,330
we need to mark a bunch of things public.

00:28:30,330 --> 00:28:34,460
Unfortunately, because it's public, then any native extension can

00:28:34,460 --> 00:28:35,600
call it as well.

00:28:35,600 --> 00:28:37,590
And I don't blame people for doing it. They're

00:28:37,600 --> 00:28:40,850
calling these methods cause they have to. And they

00:28:40,850 --> 00:28:44,470
probably represent gaps in our embedding API. But we

00:28:44,480 --> 00:28:47,330
need to actually signal our intent that we think

00:28:47,330 --> 00:28:50,660
that these are blessed APIs you can use, versus

00:28:50,660 --> 00:28:52,220
we don't want you to use them.

00:28:52,220 --> 00:28:55,110
So we're gonna also provide a tool, and let's

00:28:55,120 --> 00:28:57,170
look at the solution - or part of the

00:28:57,170 --> 00:28:57,470
solution.

00:28:57,480 --> 00:28:59,700
C.N.: This is actually a problem that MRI is

00:28:59,700 --> 00:29:02,740
faced with the C extension API. Without hiding some

00:29:02,760 --> 00:29:04,720
of it, everything becomes the public API, and that's

00:29:04,720 --> 00:29:09,040
a big reason why C extensions are hard or

00:29:09,040 --> 00:29:09,950
impossible to support other implementations.

00:29:09,950 --> 00:29:11,880
T.E.: Well, C doesn't have visibility at all, so

00:29:11,880 --> 00:29:14,290
we get a little bit more protection, but not,

00:29:14,300 --> 00:29:17,230
not a lot. So I'm not gonna teach people

00:29:17,230 --> 00:29:19,260
how to go and write annotations in Java. This

00:29:19,260 --> 00:29:23,830
is RubyConf. But this is really great. I'm just

00:29:23,830 --> 00:29:26,120
gonna talk about annotations a little bit.

00:29:26,140 --> 00:29:28,890
This is metadata that you can attach to first

00:29:28,890 --> 00:29:32,740
class concepts in the language. So in this case

00:29:32,740 --> 00:29:36,300
we're creating an annotation called extension that we can

00:29:36,300 --> 00:29:39,130
attach to methods. So we'll just put, add extension

00:29:39,130 --> 00:29:45,300
in front of our method declaration and, and then

00:29:45,360 --> 00:29:49,150
we specify that it has a runtime binding, which

00:29:49,180 --> 00:29:52,480
means in your live-running Java program you could actually

00:29:52,480 --> 00:29:54,740
ask that Java method at runtime, are you an

00:29:54,740 --> 00:29:55,480
extension method?

00:29:55,480 --> 00:30:00,450
So this metadata concept is, is really cool. In

00:30:00,450 --> 00:30:03,240
usage, in our source we'll just mark the methods

00:30:03,260 --> 00:30:06,890
that we have as extensions. And then, in our

00:30:06,890 --> 00:30:10,700
native extensions we can use those and then run

00:30:10,700 --> 00:30:14,850
a tool. We haven't actually wrote the tool, but

00:30:14,850 --> 00:30:18,120
it'll be integrated into JRuby lint. It'll examine your

00:30:18,120 --> 00:30:20,450
jar and it'll give you a report of things

00:30:20,460 --> 00:30:23,620
that you are using that aren't blessed.

00:30:23,620 --> 00:30:25,550
C.N.: Right. This is part of the transition. We

00:30:25,560 --> 00:30:26,750
know we're gonna break some of those external APIs,

00:30:26,750 --> 00:30:29,220
but we know the ones we're going to bless

00:30:29,220 --> 00:30:32,840
as official, and can give reports to any library

00:30:32,840 --> 00:30:35,890
that's out there using the bad APIs, what they're

00:30:35,900 --> 00:30:37,700
using now and what they need to change to.

00:30:37,700 --> 00:30:39,790
T.E.: We kind of get a double benefit as

00:30:39,790 --> 00:30:43,030
well, because we can actually write a documentation generator

00:30:43,030 --> 00:30:46,450
and we can actually generate an embedding document from

00:30:46,450 --> 00:30:48,100
these annotations.

00:30:48,100 --> 00:30:49,260
And the reason why I spent a little extra

00:30:49,260 --> 00:30:51,710
time on this was because, wouldn't it be really

00:30:51,720 --> 00:30:54,190
great if in Ruby 3 we actually added a

00:30:54,200 --> 00:30:56,560
metadata facility so that we could go and attach

00:30:56,560 --> 00:30:59,440
stuff to methods? There's just so many uses for

00:30:59,440 --> 00:31:02,520
this, it'd be really nice to consider adding something

00:31:02,520 --> 00:31:06,500
similar to Java annotations.

00:31:06,500 --> 00:31:09,200
We're gonna go and cover some projects associated with

00:31:09,200 --> 00:31:12,770
Google Summer of Code. JRuby actually had its own

00:31:12,770 --> 00:31:17,680
organization for this and, well, examples are probably the

00:31:17,680 --> 00:31:19,360
best way to show.

00:31:19,360 --> 00:31:21,340
C.N.: We're, we have some Google Summer of Code

00:31:21,340 --> 00:31:23,220
people here. There's one in front - OK. I

00:31:23,240 --> 00:31:25,490
think some of the other ones that might, there's,

00:31:25,490 --> 00:31:27,410
there's one other that's here, I think. I haven't

00:31:27,410 --> 00:31:29,440
seen him around yet but, we had about, we

00:31:29,440 --> 00:31:30,890
had ten people this year. How many did we

00:31:30,900 --> 00:31:31,240
have last year?

00:31:31,240 --> 00:31:33,070
T.E.: It was more.

00:31:33,070 --> 00:31:34,410
C.N.: It was more, I think it was like-

00:31:34,410 --> 00:31:35,030
T.E.: It was like fourteen.

00:31:35,040 --> 00:31:37,300
C.N.: Thirteen? Thirteen students last year. Ten students this

00:31:37,300 --> 00:31:39,650
year. So we're really trying to help get more

00:31:39,650 --> 00:31:43,720
students into JRuby and into Ruby in general.

00:31:43,720 --> 00:31:48,010
T.E.: The first one is actually from last year.

00:31:48,020 --> 00:31:49,600
But it kind of fits into the talk about

00:31:49,600 --> 00:31:53,950
opt IR. We realized we had a problem with

00:31:53,950 --> 00:31:57,760
IR, and we sort of still have that problem.

00:31:57,760 --> 00:32:04,440
This diagram totally shows it. We're doing more work.

00:32:04,440 --> 00:32:06,340
If you think about JRuby, the one thing that

00:32:06,340 --> 00:32:07,830
we're known for that we don't want to be

00:32:07,830 --> 00:32:09,750
known for is our startup time.

00:32:09,760 --> 00:32:11,290
C.N.: It sucks.

00:32:11,290 --> 00:32:13,670
T.E.: So our startup time's getting-

00:32:13,680 --> 00:32:14,190
C.N.: Want a little more overhead?

00:32:14,190 --> 00:32:16,620
T.E.: Yeah. Let's add more overhead.

00:32:16,620 --> 00:32:20,460
But we realized this, in, well before 2012, and

00:32:20,460 --> 00:32:24,270
we had Aliaksei make a, work on a persistence

00:32:24,270 --> 00:32:27,720
project, basically similar to just a compiler. You just

00:32:27,720 --> 00:32:30,250
save your persistent data and then you read it

00:32:30,260 --> 00:32:32,580
in, instead of having to recompile.

00:32:32,580 --> 00:32:37,640
So, if the file's up-to-date, and it's been saved,

00:32:37,640 --> 00:32:41,330
you just read that and save having to compile.

00:32:41,330 --> 00:32:44,260
And ultimately, we have a break-even point. We have

00:32:44,260 --> 00:32:45,760
to build and read that off a disk faster

00:32:45,760 --> 00:32:48,410
than we can compile. And this is kind of

00:32:48,410 --> 00:32:50,330
a lie. We actually have to be faster than

00:32:50,340 --> 00:32:53,700
1.7 today, or people are gonna go, why did

00:32:53,700 --> 00:32:59,450
you slow JRuby down even more for startup?

00:32:59,450 --> 00:33:02,290
Unfortunately for this project, it ended up taking longer

00:33:02,320 --> 00:33:03,710
to read the data in than it took to

00:33:03,710 --> 00:33:08,250
actually compile it. But it basically boiled down to,

00:33:08,250 --> 00:33:11,210
we were saving way too much data. Size really

00:33:11,210 --> 00:33:14,290
does matter for, for read speed.

00:33:14,320 --> 00:33:17,230
Also, we realized that a majority of the stuff

00:33:17,230 --> 00:33:19,300
that we were actually reading in, we never actually

00:33:19,300 --> 00:33:24,110
used. So we want to be more lazy. I'm

00:33:24,120 --> 00:33:27,620
not gonna talk about interning. I was, but we'll

00:33:27,620 --> 00:33:28,760
cut down.

00:33:28,760 --> 00:33:32,910
So we're gonna use a binary format. And the

00:33:32,910 --> 00:33:36,230
most important part is that we're gonna do incrementally

00:33:36,230 --> 00:33:39,360
loading to be lazy, and this diagram will show

00:33:39,360 --> 00:33:42,250
you why. If you look at all the basic

00:33:42,250 --> 00:33:44,590
operations you would do on a day-to-day basis, you'll

00:33:44,600 --> 00:33:48,410
notice this really strange ratio. It's an eighty-twenty ratio.

00:33:48,410 --> 00:33:50,950
Eighty percent of the code that you actually load

00:33:50,960 --> 00:33:54,410
when you startup, each of these activities is never

00:33:54,420 --> 00:33:58,100
actually called. Now maybe for a longer running application

00:33:58,100 --> 00:34:00,590
it does get called. But it seems like for

00:34:00,590 --> 00:34:05,100
startup and, and common activities, the eighty-twenty rule applies.

00:34:05,100 --> 00:34:06,280
Which is really, really weird.

00:34:06,300 --> 00:34:08,639
C.N.: Yeah, it's weird that that ratio applied almost

00:34:08,640 --> 00:34:09,781
across the board.

00:34:09,781 --> 00:34:11,679
T.E.: So if we define the methods but we

00:34:11,680 --> 00:34:13,630
don't actually parse any of the bodies, then we're

00:34:13,630 --> 00:34:18,660
obviously going to be doing a lot less parsing.

00:34:18,660 --> 00:34:25,660
RSense was updated. Eric West is here. Stand up

00:34:26,060 --> 00:34:33,060
quick. I have to embarrass him a little bit.

00:34:36,240 --> 00:34:41,349
If you haven't seen RSense, it's a library that

00:34:41,380 --> 00:34:43,951
you can go and install, and put in to

00:34:43,951 --> 00:34:47,520
your editors, like VI or eMacs, and it can

00:34:47,520 --> 00:34:52,399
do simple things like code completion. But it actually

00:34:52,400 --> 00:34:56,150
makes smart choices, because it actually is a full-type

00:34:56,150 --> 00:34:58,861
inference engine.

00:34:58,861 --> 00:35:00,930
In this case, this is a pretty simple form

00:35:00,940 --> 00:35:03,590
of type inference, but it can figure out a

00:35:03,600 --> 00:35:08,550
surprising amount of stuff. So it, it's something worth

00:35:08,550 --> 00:35:12,350
looking into. But before I talk about how to

00:35:12,350 --> 00:35:17,060
do that, let's describe the project.

00:35:17,060 --> 00:35:19,420
The person who originally wrote it, wrote against JRuby,

00:35:19,420 --> 00:35:22,690
and he wrote it against JRuby 1 point 3.

00:35:22,700 --> 00:35:25,000
At some point after JRuby 1 point 3, we

00:35:25,000 --> 00:35:26,550
ripped a bunch of stuff that he needed out

00:35:26,550 --> 00:35:30,170
of it and put it into its own library,

00:35:30,180 --> 00:35:33,390
and then, like all great opensource projects, it went

00:35:33,390 --> 00:35:35,870
into decay.

00:35:35,880 --> 00:35:37,900
But one of the downsides is you could still

00:35:37,900 --> 00:35:40,590
use it today, but it would only support 1.8

00:35:40,600 --> 00:35:43,110
syntax, which is a problem. And so Eric wanted

00:35:43,110 --> 00:35:44,380
to fix that.

00:35:44,380 --> 00:35:47,200
A second goal we had was that, if there

00:35:47,200 --> 00:35:52,120
was any really interesting functionality that was in, our

00:35:52,120 --> 00:35:54,350
sense that would be useful for the JRuby parser

00:35:54,360 --> 00:35:57,370
project itself, that he would go in and move

00:35:57,370 --> 00:36:02,480
that in. Or implement it differently, but move it

00:36:02,480 --> 00:36:03,270
in.

00:36:03,280 --> 00:36:06,280
So he did that. And it's good to go

00:36:06,280 --> 00:36:09,270
except RSense hasn't been released. So we have to

00:36:09,270 --> 00:36:12,250
talk to Matzuyama's son and figure out how to

00:36:12,250 --> 00:36:14,710
get this released as a new gem.

00:36:14,710 --> 00:36:19,780
Eric added this really cool tree differencing support, so

00:36:19,780 --> 00:36:22,840
you can compare two different sub-trees and do all

00:36:22,840 --> 00:36:25,680
sorts of things with it. And one thing that

00:36:25,680 --> 00:36:27,670
he did with it concretely is he made a

00:36:27,700 --> 00:36:32,420
gem called smart_diff, so if you go and take

00:36:32,420 --> 00:36:36,780
a diff between two files, you'll get an HTML

00:36:36,780 --> 00:36:39,990
file that looks like this. YOu'll see the blue

00:36:39,990 --> 00:36:43,360
and grey highlighting back and forth.

00:36:43,360 --> 00:36:45,980
Smart_diff is actually able to tell that I just

00:36:45,980 --> 00:36:49,880
switched the order of these two files. And then

00:36:49,880 --> 00:36:51,970
you would see the typical green and red output

00:36:51,980 --> 00:36:55,650
for things that are added or deleted. It's, it's,

00:36:55,650 --> 00:36:56,690
it's pretty cool.

00:36:56,690 --> 00:36:59,960
So you can, you can use this just gem

00:36:59,960 --> 00:37:00,520
install.

00:37:00,520 --> 00:37:03,030
C.N.: It's just built on top of RSense. It

00:37:03,030 --> 00:37:04,070
was a lot, obviously a lot more stuff we

00:37:04,080 --> 00:37:04,890
could do with this.

00:37:04,890 --> 00:37:07,410
T.E.: Oh, this is actually just built on JRuby

00:37:07,420 --> 00:37:07,960
parser.

00:37:07,960 --> 00:37:11,670
C.N.: Oh it's just built on the parser.

00:37:11,680 --> 00:37:12,480
T.E.: Yeah.

00:37:12,480 --> 00:37:17,950
jruby_visualizer is by Maximilian Konzack. He's not here today.

00:37:17,950 --> 00:37:21,800
We need to have better tools to go and

00:37:21,800 --> 00:37:24,370
analyze stuff at the IR level. We have a

00:37:24,370 --> 00:37:30,290
lot of compiler passes running and, in particular, eventually

00:37:30,320 --> 00:37:31,920
we want to get this tool to the point

00:37:31,920 --> 00:37:35,290
where you can go and run your application and

00:37:35,290 --> 00:37:37,570
it'll generate an event stream. You can save that

00:37:37,570 --> 00:37:39,890
event stream, give it to us, and we can

00:37:39,890 --> 00:37:41,560
look at all the changes that are happening in

00:37:41,560 --> 00:37:43,230
the IR and figure out what went wrong.

00:37:43,240 --> 00:37:44,810
C.N.: Right. See why it's not optimizing what it

00:37:44,820 --> 00:37:46,230
should be.

00:37:46,230 --> 00:37:48,810
T.E.: It's a GUI based application. It's certainly written

00:37:48,810 --> 00:37:51,530
on top of the JRubyFX gem, which is something

00:37:51,540 --> 00:37:57,130
that, myself, Eric, and Max, worked along with mostly

00:37:57,130 --> 00:37:58,320
byte IT 101.

00:37:58,320 --> 00:38:00,880
I don't, I can't pronounce his last name, so

00:38:00,880 --> 00:38:03,580
I'm just gonna use his handle. But it's an

00:38:03,580 --> 00:38:08,390
awesome GUI toolkit on JRubyFX. Use it.

00:38:08,390 --> 00:38:12,480
OK. So here's just a couple of screen shots.

00:38:12,500 --> 00:38:14,150
If you go and click on the AST in

00:38:14,150 --> 00:38:17,040
the left, it'll just scroll to wherever on the

00:38:17,060 --> 00:38:19,660
right and show you what code that is. So

00:38:19,660 --> 00:38:22,830
there's a little bit of trace ability introduced. At

00:38:22,830 --> 00:38:24,760
any point - I don't expect you to read

00:38:24,760 --> 00:38:27,880
that - but it's more IR output. Actually that's

00:38:27,900 --> 00:38:32,970
bigger than I thought.

00:38:32,970 --> 00:38:36,220
It'll actually ask for the compiler passes executed, and

00:38:36,220 --> 00:38:39,290
you can step through those and then pop up

00:38:39,290 --> 00:38:41,500
the IR view to see what's changed. We actually

00:38:41,500 --> 00:38:44,560
want this to be a more smart diff format

00:38:44,560 --> 00:38:47,560
to actually get better information how it's changed, but

00:38:47,560 --> 00:38:50,000
it's a Google Summer of Code project. A guy

00:38:50,000 --> 00:38:52,840
can only do so much.

00:38:52,840 --> 00:38:54,730
And lastly you can go and look through the

00:38:54,730 --> 00:38:56,620
control flow graph. And we want to go in

00:38:56,620 --> 00:39:00,950
and add more windows for more stuff. So.

00:39:00,980 --> 00:39:01,930
MK.

00:39:01,930 --> 00:39:06,040
C.N.: Another project we had this summer, Chamila worked

00:39:06,040 --> 00:39:09,300
on DTrace Support for us. So Ruby 2 point

00:39:09,300 --> 00:39:12,380
1 added DTrace probes. I think that was, Erin

00:39:12,380 --> 00:39:14,720
Patterson added that.

00:39:14,720 --> 00:39:17,200
We wanted to add the same thing, and Chamila

00:39:17,200 --> 00:39:18,740
came along and decided that that was the project

00:39:18,740 --> 00:39:20,270
that he'd like to do for Google Summer of

00:39:20,270 --> 00:39:23,560
Code. It turns out OpenJDK does have DTrace support

00:39:23,560 --> 00:39:26,020
in it, so we could just build on top

00:39:26,020 --> 00:39:29,020
of those existing APIs.

00:39:29,040 --> 00:39:31,010
Now what we have right now, it's about 90%

00:39:31,010 --> 00:39:34,050
complete. And it passes a lot of MRIs tests

00:39:34,050 --> 00:39:37,170
for the, the functionality that we've implemented. But the

00:39:37,170 --> 00:39:39,530
thing we found out during the process is that,

00:39:39,540 --> 00:39:42,810
unfortunately the DTrace support in OpenJDK only exists on

00:39:42,820 --> 00:39:44,470
Solaris right now.

00:39:44,470 --> 00:39:47,700
So, we're looking at other options, pulling the DTrace

00:39:47,720 --> 00:39:50,210
support over to the BSDs, like OS ten where

00:39:50,210 --> 00:39:53,340
we have DTrace. Pulling over the same APIs where

00:39:53,340 --> 00:39:56,610
we have Linux equivalents of DTrace. Or possible calling

00:39:56,610 --> 00:39:58,770
out to a, an external library.

00:39:58,770 --> 00:40:00,890
But we do have the code available. We're gonna

00:40:00,900 --> 00:40:02,650
try to get it merged in at least for

00:40:02,650 --> 00:40:04,350
the Solaris platforms and see what we can do

00:40:04,360 --> 00:40:06,160
for others.

00:40:06,160 --> 00:40:10,970
Shoes. Shoes4 was another project that came along this

00:40:10,970 --> 00:40:13,460
summer. We've also did some work last summer too,

00:40:13,480 --> 00:40:17,030
Tobias worked on this one. So Shoes is basically

00:40:17,030 --> 00:40:20,300
why the lucky stiff's GUI environment. It's very clean,

00:40:20,300 --> 00:40:22,170
very simple to use. He wanted to come up

00:40:22,170 --> 00:40:24,850
with something that would be really trivial and fun

00:40:24,860 --> 00:40:28,310
to build complex GUI applications with.

00:40:28,310 --> 00:40:31,400
Shoes4 actually made the decision, last year some time

00:40:31,400 --> 00:40:34,339
I think, to move to a JRuby-only backend. There's

00:40:34,340 --> 00:40:36,681
a lot of reasons for this. Most of them,

00:40:36,681 --> 00:40:39,040
portability, not having to build the libraries over and

00:40:39,060 --> 00:40:41,620
over again, and having a consistent experience across all

00:40:41,620 --> 00:40:46,000
platforms. Building it on top of GTK or Win32

00:40:46,000 --> 00:40:49,530
or whatever else never worked great across platforms. Things

00:40:49,540 --> 00:40:51,840
always developed a little bit different and it was

00:40:51,840 --> 00:40:55,020
very difficult to ship applications, since everybody needed to

00:40:55,020 --> 00:40:57,110
install those extra libraries and build them for that

00:40:57,110 --> 00:40:58,920
platform.

00:40:58,920 --> 00:41:01,520
In the other room, in one of the salons,

00:41:01,520 --> 00:41:05,810
there's actually a talk on an application that uses

00:41:05,810 --> 00:41:10,330
DRb and Shoes4 to do a Space Team-like pirate

00:41:10,340 --> 00:41:14,580
game. And that's Davy, Eric, and Ryan are talking

00:41:14,580 --> 00:41:16,240
about that in the other room. And since they

00:41:16,240 --> 00:41:18,630
couldn't be here and we couldn't be there, I

00:41:18,640 --> 00:41:20,609
thought we'd get a video from them to show

00:41:20,609 --> 00:41:22,341
this application running.

00:41:22,341 --> 00:41:24,570
And so this is just all, this is written

00:41:24,580 --> 00:41:27,100
all in Ruby code, using Shoes, which is backed

00:41:27,100 --> 00:41:31,680
by SWT, one of the JVM GUI libraries. Anybody

00:41:31,680 --> 00:41:34,880
play - any Space Team players here? Not too

00:41:34,880 --> 00:41:35,340
many.

00:41:35,340 --> 00:41:37,260
The goal, basically, is you have two or three

00:41:37,260 --> 00:41:40,930
or four people, and it shouts out commands to

00:41:40,930 --> 00:41:42,710
you, and you have to do them quickly. Or

00:41:42,720 --> 00:41:44,860
yell it out to your friends so that they'll

00:41:44,860 --> 00:41:45,740
do the commands.

00:41:45,740 --> 00:41:49,040
So, there you go. So that was, that's fun,

00:41:49,040 --> 00:41:50,680
and it's cool that, that it's actually being used

00:41:50,680 --> 00:41:51,920
now.

00:41:51,920 --> 00:41:54,610
Some more Google Summer of Code stuff we don't

00:41:54,610 --> 00:41:57,350
have time to cover - more work on Ruboto,

00:41:57,350 --> 00:41:59,840
which is JRuby on Android, trying to strip down

00:41:59,840 --> 00:42:02,980
the runtime, improve performance, make it easier to build

00:42:02,980 --> 00:42:07,640
Android applications entirely in Ruby. Asakawa Ryu did that.

00:42:07,640 --> 00:42:12,260
Shoes4 HacketyHack support. Faraaz did that. We don't, we

00:42:12,260 --> 00:42:14,510
mostly let the Shoes guy mentor that, so we

00:42:14,520 --> 00:42:15,800
didn't track that very much.

00:42:15,800 --> 00:42:17,580
For the second year in a row we had

00:42:17,580 --> 00:42:20,240
two students working on Krypt. Krypt is a new

00:42:20,240 --> 00:42:27,240
encryption, encoding library for Ruby, intended to, hopefully, replace

00:42:27,580 --> 00:42:31,530
OpenSSL at some point. But, implemented in Ruby, where

00:42:31,540 --> 00:42:35,430
it can be native where possible, and supporting all

00:42:35,430 --> 00:42:37,440
the implementations at the same time. So we've always

00:42:37,460 --> 00:42:40,180
got a good solid encryption library.

00:42:40,180 --> 00:42:41,370
And we're very happy that we're able to support

00:42:41,380 --> 00:42:43,280
that every year in Google Summer of Code.

00:42:43,280 --> 00:42:45,460
And we also had a student explore JRuby on

00:42:45,460 --> 00:42:48,490
embedded devices like raspberry pies and stuff like that.

00:42:48,490 --> 00:42:50,580
He basically came up with a bunch of different

00:42:50,580 --> 00:42:54,280
matrices of which libraries, which JRuby, which JRuby versions

00:42:54,280 --> 00:42:58,200
work on which platforms with which embedded JVMs. And

00:42:58,200 --> 00:43:01,290
we've got all that information available on, in the

00:43:01,300 --> 00:43:03,780
JRuby organization on GitHub.

00:43:03,780 --> 00:43:07,430
So. Wrapping things up. Emphasizing that JRuby is just

00:43:07,430 --> 00:43:08,980
Ruby - it just happens to be on the

00:43:08,980 --> 00:43:12,100
JVM. We're working with the MRI and the community

00:43:12,100 --> 00:43:14,930
a lot more, more and more in the future.

00:43:14,930 --> 00:43:17,070
If anybody has gems or libraries you're releasing, please,

00:43:17,070 --> 00:43:20,970
please turn on JRuby and Travis. If it's not

00:43:20,980 --> 00:43:22,490
passing, let us know and we'll help you figure

00:43:22,490 --> 00:43:23,780
out why.

00:43:23,800 --> 00:43:26,120
And, you know, if you're not trying JRuby right

00:43:26,120 --> 00:43:27,950
now, give it a shot. Let us know how

00:43:27,950 --> 00:43:29,590
it goes for you and let us know what

00:43:29,590 --> 00:43:32,130

YouTube URL: https://www.youtube.com/watch?v=4TAwkq0aQdE


