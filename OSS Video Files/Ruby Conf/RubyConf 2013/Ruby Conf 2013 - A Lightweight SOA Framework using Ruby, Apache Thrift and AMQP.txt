Title: Ruby Conf 2013 - A Lightweight SOA Framework using Ruby, Apache Thrift and AMQP
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Stephen Henrie

Service-oriented architecture (SOA) is an evolution of distributed computing based upon the request/response design pattern (aka RPC) for communication between independent system components. These components modularize system functionality and encapsulate their business logic that is presented as Services to be consumed by client applications or other services.

Help us caption & translate this video!

http://amara.org/v/FG59/
Captions: 
	00:00:16,000 --> 00:00:18,000
STEPHEN HENRIE: Hi. So my name is Stephen Henrie,

00:00:18,439 --> 00:00:20,689
and I'm the manager of application development

00:00:20,689 --> 00:00:24,349
over at Sony Computer Entertainment of America.

00:00:24,349 --> 00:00:27,519
And one of the things I wanted to discuss at this conference

00:00:27,519 --> 00:00:31,640
is something that I went through, going through a project myself recently.

00:00:31,640 --> 00:00:34,320
Evaluating some different technologies,

00:00:34,320 --> 00:00:37,780
and what we came up with uses as a base architecture.

00:00:37,780 --> 00:00:42,300
A lightweight SOA framework, we just say,

00:00:42,300 --> 00:00:45,120
using Ruby, Apache Thrift, and AMQP.

00:00:45,120 --> 00:00:48,820
But before we get started, I knew that my

00:00:48,820 --> 00:00:50,510
talk here was right after lunch, so a lot

00:00:50,510 --> 00:00:51,820
of us are probably in a food coma or

00:00:51,820 --> 00:00:54,980
whatnot. So I wanted to make my graphics a

00:00:54,980 --> 00:00:57,109
little visually stimulating. And I also just wanted to

00:00:57,109 --> 00:00:59,399
let everyone know who Sony Computer Entertainment of America

00:00:59,399 --> 00:01:02,000
is, in case you just weren't sure.

00:01:02,000 --> 00:01:09,000
So hopefully this'll wake everybody up.

00:01:09,090 --> 00:01:12,680
VIDEO

00:01:12,680 --> 00:01:19,680
V.O.: Hello world.

00:01:23,440 --> 00:01:30,440
[song lyrics]

00:01:30,610 --> 00:01:37,610
CRITTER: Oh, dude. Totally freaked me out. You scared

00:02:02,890 --> 00:02:09,890
the crap out of me, man.

00:02:24,409 --> 00:02:28,000
VIDEO

00:02:28,000 --> 00:02:35,000
S.H.: So we are the Playstation people. And as

00:02:36,249 --> 00:02:37,379
you can imagine, we have a pretty big week,

00:02:37,379 --> 00:02:38,700
some of you might know, coming up is our

00:02:38,700 --> 00:02:43,099
Playstation 4 console coming out this week. So what

00:02:43,099 --> 00:02:44,140
I want to do is cover a little bit

00:02:44,140 --> 00:02:46,659
of background on what it is we do.

00:02:46,659 --> 00:02:50,879
So I manage a group of software developers, which,

00:02:50,879 --> 00:02:53,569
we all use Ruby, and we work on internal

00:02:53,569 --> 00:02:56,530
applications that support the development and the hosting of

00:02:56,530 --> 00:02:58,579
the titles. And so the, of the game titles.

00:02:58,579 --> 00:03:01,469
And so this can be internal tools that manage

00:03:01,469 --> 00:03:03,989
the Q-A process, for example, when we get software,

00:03:03,989 --> 00:03:07,099
or games from both internal Sony Studios as well

00:03:07,099 --> 00:03:13,540
as external companies, to doing business intelligence, business mapping,

00:03:13,540 --> 00:03:16,370
data mapping, and also hosting.

00:03:16,370 --> 00:03:18,010
And so one of the things that I always

00:03:18,010 --> 00:03:20,730
have to do is, I'm a fairly new-to-Ruby over

00:03:20,730 --> 00:03:24,170
in the last year here, and one of my

00:03:24,170 --> 00:03:26,060
recent tasks has been to come up and work

00:03:26,060 --> 00:03:28,040
with some of the other hosting engineers to develop

00:03:28,040 --> 00:03:31,909
a new architecture for doing some, you know, cloud

00:03:31,909 --> 00:03:35,290
management software. The titles can be a little bit

00:03:35,290 --> 00:03:37,239
tricky, the games themselves, cause they're not standard, out

00:03:37,239 --> 00:03:40,379
of the box applications, as you might imagine. So

00:03:40,379 --> 00:03:41,999
they have a lot of intricacies involved.

00:03:41,999 --> 00:03:45,430
And so I was evaluating with others and different

00:03:45,430 --> 00:03:48,090
technologies, and I just kind of wanted to share

00:03:48,090 --> 00:03:51,510
with the group here what some of those technologies

00:03:51,510 --> 00:03:53,060
were and what we ended up coming up with

00:03:53,060 --> 00:03:56,650
as the basis for what we're doing.

00:03:56,650 --> 00:03:57,810
So what I'm going to cover today, just to

00:03:57,810 --> 00:03:59,389
make sure everybody's kind of, we're on the same

00:03:59,389 --> 00:04:02,579
page, if you will, what service-oriented architecture is. A

00:04:02,579 --> 00:04:06,730
very high-level background. What remote procedure calls are, just

00:04:06,730 --> 00:04:11,370
so we're on the same terminology. What messaging means.

00:04:11,370 --> 00:04:14,540
What advanced messaging queueing protocol is - AMQP, if

00:04:14,540 --> 00:04:17,700
you're not familiar with that, and then Apache Thrift.

00:04:17,700 --> 00:04:21,890
And then we're gonna bring all that together to,

00:04:21,890 --> 00:04:23,340
to do what it is that, as an application.

00:04:23,340 --> 00:04:29,250
So, so what is service-oriented architecture? It's an evolution

00:04:29,250 --> 00:04:31,310
of distributed computing. Most of you know, or are

00:04:31,310 --> 00:04:34,040
familiar with that from the internet and what that

00:04:34,040 --> 00:04:39,000
all means. The, it's a collection of loosely coupled,

00:04:39,000 --> 00:04:42,190
independent system components. And what that means is, all

00:04:42,190 --> 00:04:45,880
of these components should be able to operate independently,

00:04:45,880 --> 00:04:49,050
without having to know what each other is doing.

00:04:49,050 --> 00:04:53,020
Each op- each component should, itself, encapsulate some business

00:04:53,020 --> 00:04:58,110
logic, and the communication between those is typically using

00:04:58,110 --> 00:04:59,710
RPC. I don't know if that's gonna mean anything

00:04:59,710 --> 00:05:00,240
to anybody else.

00:05:00,240 --> 00:05:05,260
And one of my favorite quotes about SOA is

00:05:05,260 --> 00:05:06,750
right here, what it says. If we build our

00:05:06,750 --> 00:05:09,950
systems as components, we can build and maintain them

00:05:09,950 --> 00:05:13,250
independently. SOA is a set of design patterns, effectively,

00:05:13,250 --> 00:05:16,510
that guide us in building and integrating these mini-application.

00:05:16,510 --> 00:05:18,980
So rather than sitting around and building a giant,

00:05:18,980 --> 00:05:21,440
monolithic, old-school application, we can build these things as

00:05:21,440 --> 00:05:24,700
components, and then over time, as the system evolves

00:05:24,700 --> 00:05:27,450
and the needs of the business evolve, we can,

00:05:27,450 --> 00:05:30,020
you know, work on individual pieces.

00:05:30,020 --> 00:05:32,780
Where it gets a little tricky, of course, is

00:05:32,780 --> 00:05:33,820
when you're talking about, well how do these things

00:05:33,820 --> 00:05:36,340
communicate with one another? And that's where messaging comes

00:05:36,340 --> 00:05:38,340
in. It, and, as you'll see, it forms a

00:05:38,340 --> 00:05:41,410
nice abstraction layer between how you communicate between these

00:05:41,410 --> 00:05:44,100
components.

00:05:44,100 --> 00:05:47,280
So what are, exactly, service components? They should be

00:05:47,280 --> 00:05:52,360
single-purpose. They should be encapsulated, in terms of, I

00:05:52,360 --> 00:05:55,770
shouldn't care what, how this service does its work.

00:05:55,770 --> 00:05:58,730
There should be a publicly defined contract that we

00:05:58,730 --> 00:06:01,580
both agree to - that's the protocol, if you

00:06:01,580 --> 00:06:04,240
will. With the API and the message types, the

00:06:04,240 --> 00:06:06,240
data that gets passed back and forth is agreed

00:06:06,240 --> 00:06:07,880
upon.

00:06:07,880 --> 00:06:11,080
It should be context free, in terms of, when

00:06:11,080 --> 00:06:12,970
I'm ready to pass something off to you to

00:06:12,970 --> 00:06:14,850
do as another service, you should be able to

00:06:14,850 --> 00:06:17,010
handle that on your own without needing anything extra

00:06:17,010 --> 00:06:19,220
from me. And of course these things should be

00:06:19,220 --> 00:06:21,910
independently deployable and testable, so that they can follow

00:06:21,910 --> 00:06:25,070
standard development practices of test-driven development and things like

00:06:25,070 --> 00:06:28,430
that.

00:06:28,430 --> 00:06:31,680
Communication between SOA components should just be, like, as

00:06:31,680 --> 00:06:33,580
I was saying, support both things before, so they

00:06:33,580 --> 00:06:37,860
should be decoupled and have contracts that can communicate

00:06:37,860 --> 00:06:39,350
between them to find the end points.

00:06:39,350 --> 00:06:41,890
The end points themselves should be decoupled, in terms

00:06:41,890 --> 00:06:44,330
of, I shouldn't have to know exactly where my

00:06:44,330 --> 00:06:47,030
message is going if I'm sending it. The underlying

00:06:47,030 --> 00:06:49,150
system can do some of that work for us

00:06:49,150 --> 00:06:52,830
through routing. The, it should support temporal decoupling, in

00:06:52,830 --> 00:06:54,650
that, I can be able to bring up and

00:06:54,650 --> 00:06:56,840
bring down services, and the system as a whole

00:06:56,840 --> 00:06:59,490
should continue to function, if you will.

00:06:59,490 --> 00:07:03,340
And the messaging between components should be low-latency and,

00:07:03,340 --> 00:07:07,150
of course, follow open standards.

00:07:07,150 --> 00:07:12,320
So, as I said, most SOA systems depend upon

00:07:12,320 --> 00:07:14,940
something called remote procedure calls, which are, of course,

00:07:14,940 --> 00:07:17,820
should be, like, function calls from the business logic's

00:07:17,820 --> 00:07:22,090
point of view. What typically happens in RPC process

00:07:22,090 --> 00:07:24,870
is that you have a caller on one machine

00:07:24,870 --> 00:07:28,210
that is, is unaware of where the actual service

00:07:28,210 --> 00:07:32,090
is being fulfilled, so there's a representative of, representation

00:07:32,090 --> 00:07:33,740
of that code in the form of a stub

00:07:33,740 --> 00:07:35,520
that exists on the same machine.

00:07:35,520 --> 00:07:38,200
So the local business logic is calling that stub.

00:07:38,200 --> 00:07:40,370
The stub itself is going to marshal that data

00:07:40,370 --> 00:07:43,220
onto the network using the infrastructure that we're talking

00:07:43,220 --> 00:07:48,030
about later. And then that data's sent across, sent

00:07:48,030 --> 00:07:51,220
to a skeleton, which is the API interface, if

00:07:51,220 --> 00:07:54,430
you will, to the underlying framework, which then, itself,

00:07:54,430 --> 00:07:56,950
is going to call the business logic handling on

00:07:56,950 --> 00:07:58,890
the second machine.

00:07:58,890 --> 00:08:01,050
The functionality is gonna occur. The data's gonna be

00:08:01,050 --> 00:08:04,370
sent back, following the same pathway. This is typically

00:08:04,370 --> 00:08:08,640
how most RPCs work.

00:08:08,640 --> 00:08:11,700
So messaging to the rescue, right. So messaging provides

00:08:11,700 --> 00:08:14,950
an easy way to communicate between distributed and loosely-coupled

00:08:14,950 --> 00:08:18,660
components. It also allows, with the framework, for developers

00:08:18,660 --> 00:08:21,100
to focus on the business logic, whatever it is

00:08:21,100 --> 00:08:23,010
that they're trying to do in each service, and

00:08:23,010 --> 00:08:24,880
not on the underlying infrastructure, as long as the

00:08:24,880 --> 00:08:27,890
framework is the same, then, and, and set out

00:08:27,890 --> 00:08:31,090
there and common across the infrastructure, it will do

00:08:31,090 --> 00:08:32,630
all the messaging for you.

00:08:32,630 --> 00:08:36,199
You can also move services around and messages will

00:08:36,199 --> 00:08:38,680
follow. The business logic itself doesn't have to care

00:08:38,680 --> 00:08:40,029
about things like that. It doesn't have to care

00:08:40,029 --> 00:08:43,579
about, typically, governance and, and how you do security,

00:08:43,579 --> 00:08:45,660
because hopefully your infrastructure is going to handle all

00:08:45,660 --> 00:08:48,459
that for it. This also allows for message formats

00:08:48,459 --> 00:08:50,970
can evolve over time with the business logic. So

00:08:50,970 --> 00:08:53,529
as you decide, three months later, you need to

00:08:53,529 --> 00:08:56,240
add a new parameter to a function in some

00:08:56,240 --> 00:08:59,649
business logic function, you message format itself can change

00:08:59,649 --> 00:09:02,620
along with it, and the underlying infrastructure should be

00:09:02,620 --> 00:09:05,060
able to marshal that data and handle all the

00:09:05,060 --> 00:09:08,050
conversions as well in the versioning.

00:09:08,050 --> 00:09:10,839
Messaging is secure and scalable, and, of course, it

00:09:10,839 --> 00:09:16,399
supports the RPC pattern amongst many others.

00:09:16,399 --> 00:09:18,470
So this is an example of an SOA architecture

00:09:18,470 --> 00:09:21,589
that I'm putting together with some others at Playstation

00:09:21,589 --> 00:09:23,860
that we're using for some hosting operations. And, really,

00:09:23,860 --> 00:09:26,689
I'm not gonna get into the details of that,

00:09:26,689 --> 00:09:28,509
but what I wanted to kind of showcase here

00:09:28,509 --> 00:09:32,399
is that, the boxes in the light blue represent

00:09:32,399 --> 00:09:35,610
kind of services themselves, that are operating independently as

00:09:35,610 --> 00:09:39,089
the loosely-coupled components, and they all communicate with each

00:09:39,089 --> 00:09:41,829
other through the AMQP messaging broker.

00:09:41,829 --> 00:09:44,459
Now of course they're doing routing, is happening inside

00:09:44,459 --> 00:09:47,100
that broker, so if I'm calling, if service a

00:09:47,100 --> 00:09:50,029
is calling service b, it's passing that off to

00:09:50,029 --> 00:09:53,660
the broker and the broker's doing that transfer. But

00:09:53,660 --> 00:09:55,800
it also allows for service, for service messaging as

00:09:55,800 --> 00:09:58,870
well, so if I'm sitting on GUI and I

00:09:58,870 --> 00:10:01,499
say I want to provision the new VM in

00:10:01,499 --> 00:10:03,209
the cloud, there's gonna be a message that's gonna

00:10:03,209 --> 00:10:06,240
come through the API gateway down through the broker,

00:10:06,240 --> 00:10:08,029
maybe goes to the environment service to get some

00:10:08,029 --> 00:10:10,660
information from the database. Then it's gonna go ahead

00:10:10,660 --> 00:10:13,100
and send a message over to the provisioning service,

00:10:13,100 --> 00:10:14,559
and we have a workflow service in there which

00:10:14,559 --> 00:10:17,339
is, of course, delegating out all kinds of messages

00:10:17,339 --> 00:10:18,959
and doing orchestration.

00:10:18,959 --> 00:10:20,579
But the idea here is that all of these

00:10:20,579 --> 00:10:23,920
components work independently and there's messaging going on between

00:10:23,920 --> 00:10:25,649
all of them. The other thing I like to

00:10:25,649 --> 00:10:28,889
point out is, we have services over here, which,

00:10:28,889 --> 00:10:32,009
as you can see, are like Amazon, OpenStack, whatnot,

00:10:32,009 --> 00:10:33,660
and you can put a facade service following the

00:10:33,660 --> 00:10:36,339
facade design pattern, just on top of anything externally,

00:10:36,339 --> 00:10:39,220
and then, and be able to invoke that using

00:10:39,220 --> 00:10:40,579
your internal messaging.

00:10:40,579 --> 00:10:43,389
It's, it's, it's an easy way to bring other

00:10:43,389 --> 00:10:46,740
functionality into the system over time as the needs

00:10:46,740 --> 00:10:53,740
of your, your business evolve.

00:10:54,740 --> 00:10:58,410
So what is AMQP? The advanced message queueing protocol.

00:10:58,410 --> 00:11:02,019
It's an open standard for doing messaging. Just a

00:11:02,019 --> 00:11:02,800
quick background here.

00:11:02,800 --> 00:11:04,860
The message in AMQP is very simple. It basically

00:11:04,860 --> 00:11:07,589
has a header and a body. The header contains,

00:11:07,589 --> 00:11:11,579
basically, like a dictionary of name-value pair keys, and

00:11:11,579 --> 00:11:15,309
it's used for contextual information to describe the message

00:11:15,309 --> 00:11:17,199
or whatnot. And it's also used for routing and

00:11:17,199 --> 00:11:20,639
other things that the broker itself can use.

00:11:20,639 --> 00:11:24,430
AMQP in particular, what I like about it, is

00:11:24,430 --> 00:11:26,579
it's, it's got a nice abstraction to it with

00:11:26,579 --> 00:11:28,980
the concept of the exchange of where you send

00:11:28,980 --> 00:11:31,100
messages to is kind of broken away from the

00:11:31,100 --> 00:11:34,279
actual queues, by a binding mechanism. And so it

00:11:34,279 --> 00:11:37,059
allows for a lot of different flexible configurations. And

00:11:37,059 --> 00:11:38,809
you could do a whole talk just on AMQP

00:11:38,809 --> 00:11:40,550
and the benefits of that as well.

00:11:40,550 --> 00:11:44,259
But, at its very simple core, what you see

00:11:44,259 --> 00:11:47,470
is a publishing process. It sends a, or publishes

00:11:47,470 --> 00:11:50,199
a message to exchange, and based upon the routing

00:11:50,199 --> 00:11:54,999
that's put into the message, the exchange will route

00:11:54,999 --> 00:11:57,170
it into the appropriate queue, and there's gonna be

00:11:57,170 --> 00:11:59,730
a process sitting on the other end, hopefully, that

00:11:59,730 --> 00:12:01,420
is subscribed to that queue, and it's gonna be

00:12:01,420 --> 00:12:04,749
receiving messages. And in a nutshell, that's basically how

00:12:04,749 --> 00:12:06,129
it works.

00:12:06,129 --> 00:12:09,829
It supports basic pub sub messaging, RPC and content-based

00:12:09,829 --> 00:12:14,529
writing. It's secure, reliable, and, quote on quote, transactual

00:12:14,529 --> 00:12:16,869
in nature, in terms of how the transfer of

00:12:16,869 --> 00:12:20,449
data happens. Because it's a binary wire protocol and

00:12:20,449 --> 00:12:22,420
it allows for that, it's, it can even operate

00:12:22,420 --> 00:12:25,100
across languages and platforms, because ultimately it's just a

00:12:25,100 --> 00:12:27,529
bucket of bits, and it's up to the application

00:12:27,529 --> 00:12:30,029
how you want to use those bits.

00:12:30,029 --> 00:12:34,180
Centralized broker is also scalable, clusterable, and easy to

00:12:34,180 --> 00:12:39,579
configure, and, of course, open standards and all that.

00:12:39,579 --> 00:12:42,319
So how does the RPC over AMQP work? Well

00:12:42,319 --> 00:12:46,399
it's quite simple. A client sends a message to

00:12:46,399 --> 00:12:49,300
an exchange and it sends a routing key of

00:12:49,300 --> 00:12:52,279
what service, for example, that it wants to send

00:12:52,279 --> 00:12:56,449
to. On the other side, there's a service process

00:12:56,449 --> 00:12:58,939
running somewhere off in the cloud, let's say, we

00:12:58,939 --> 00:13:01,939
don't know where. And it's going to subscribe to

00:13:01,939 --> 00:13:05,399
the queue, named OPQ, here, for operation queue. So

00:13:05,399 --> 00:13:07,279
when the client sends a message and it's, let's

00:13:07,279 --> 00:13:09,649
say, we'll assume it's a blocking call, it will

00:13:09,649 --> 00:13:13,949
also create its own queue for receiving responses, and

00:13:13,949 --> 00:13:15,999
then sit and wait and block.

00:13:15,999 --> 00:13:18,769
Meanwhile, the service is just sitting there, waiting to

00:13:18,769 --> 00:13:22,199
hear for messages. When the broker receives the message

00:13:22,199 --> 00:13:23,889
and is routed to that queue, it will notify

00:13:23,889 --> 00:13:27,290
the subscription process that there's a queue waiting, and

00:13:27,290 --> 00:13:29,670
it'll push the data out to it. The service

00:13:29,670 --> 00:13:31,699
can do its business logic or whatever, come up

00:13:31,699 --> 00:13:35,129
with a response, and then, in the keys, in

00:13:35,129 --> 00:13:36,829
the header section of the message, there's a reply

00:13:36,829 --> 00:13:39,350
to that it's set to the response queue. So

00:13:39,350 --> 00:13:41,399
it'll send and publish the message back into the

00:13:41,399 --> 00:13:44,240
exchange. It will get routed the response queue, and

00:13:44,240 --> 00:13:46,279
then the broker will once again notify the client

00:13:46,279 --> 00:13:49,050
process that, hey, you have a response. And there's

00:13:49,050 --> 00:13:49,649
RPC.

00:13:49,649 --> 00:13:52,790
Of course we build timeouts into all this stuff,

00:13:52,790 --> 00:13:56,170
so that, you know, make sure that processes don't

00:13:56,170 --> 00:13:56,970
stick around.

00:13:56,970 --> 00:13:58,850
The other nice thing about it is there's automatic

00:13:58,850 --> 00:14:01,429
load balancing can be built in by, you can

00:14:01,429 --> 00:14:04,910
scale out, by just having more subscribers sitting on

00:14:04,910 --> 00:14:06,879
your queue. And in that case you'll have additional

00:14:06,879 --> 00:14:12,240
worker processes that'll handle the load as you need

00:14:12,240 --> 00:14:13,059
to.

00:14:13,059 --> 00:14:14,759
So I've used the term wire protocol - what

00:14:14,759 --> 00:14:18,420
does that mean? Well, you're sitting around a bucket

00:14:18,420 --> 00:14:21,129
of bits, and one side is writing- is written

00:14:21,129 --> 00:14:23,769
in Python, and another side is written in Ruby,

00:14:23,769 --> 00:14:25,379
how are you gonna know how to communicate?

00:14:25,379 --> 00:14:27,139
So the wire protocol is just that - it

00:14:27,139 --> 00:14:32,399
defines what data's being sent in what format. Typically

00:14:32,399 --> 00:14:35,889
it's built around, you know, base data types, ints,

00:14:35,889 --> 00:14:39,850
strings, things like that, that are common across most

00:14:39,850 --> 00:14:43,309
programming languages. And so then it allows for me,

00:14:43,309 --> 00:14:46,379
as a service or client, to communicate with another

00:14:46,379 --> 00:14:48,610
service, and I don't care what language it's written

00:14:48,610 --> 00:14:53,579
in. And this is where thrift comes into play.

00:14:53,579 --> 00:14:55,809
So where Apache Thrift comes in is a project

00:14:55,809 --> 00:14:57,839
that was, I believe, it's an evolution of the

00:14:57,839 --> 00:15:00,779
Google protocol buffers, and it was started by the

00:15:00,779 --> 00:15:04,490
Facebook people and made into an opensource project. It's

00:15:04,490 --> 00:15:07,369
got some benefits that it's language independent. It's a

00:15:07,369 --> 00:15:11,829
binary communication protocol. It allows you cre- it comes

00:15:11,829 --> 00:15:14,540
with an interface definition language, which allows you to

00:15:14,540 --> 00:15:17,189
define those contracts that we talked about earlier between

00:15:17,189 --> 00:15:18,170
components.

00:15:18,170 --> 00:15:21,179
It also includes a code generator and a service

00:15:21,179 --> 00:15:24,790
framework, so it's a lot of stuff for free.

00:15:24,790 --> 00:15:27,069
If you assume that, in a networking stack, you've

00:15:27,069 --> 00:15:31,309
got the raw transport of TCP or whatnot underneath

00:15:31,309 --> 00:15:33,509
it, where Apache Thrift comes in is it allows

00:15:33,509 --> 00:15:35,699
you define a protocol, whether it be in binary,

00:15:35,699 --> 00:15:39,529
JSON, whatever. It's, how that data is being structured

00:15:39,529 --> 00:15:41,569
and used across the underlying transport.

00:15:41,569 --> 00:15:45,029
It, it generates out a processor, which of those

00:15:45,029 --> 00:15:49,079
skeleton stubs that we talked about earlier, and then

00:15:49,079 --> 00:15:52,069
it provides for a ability to have a server

00:15:52,069 --> 00:15:54,889
mechanism built on top that can handle requests as

00:15:54,889 --> 00:15:58,129
they come in and be able to marshal the

00:15:58,129 --> 00:16:03,269
data, decrypt it, whatever is involved.

00:16:03,269 --> 00:16:04,769
And so just a cover, make sure we're still

00:16:04,769 --> 00:16:06,470
covering a lot of backgrounds here cause we're built

00:16:06,470 --> 00:16:08,790
on the shoulders of giants, is the power of

00:16:08,790 --> 00:16:11,279
an interface definition language. And so this is the

00:16:11,279 --> 00:16:14,499
language that is typically, even though it's a language

00:16:14,499 --> 00:16:18,040
in itself, is the programming language independent. It allows

00:16:18,040 --> 00:16:23,019
you to specify your APIs, message specification, validation. Of

00:16:23,019 --> 00:16:25,160
course, like I said, it's strongly typed, because you

00:16:25,160 --> 00:16:28,050
have to know what data is being sent and

00:16:28,050 --> 00:16:29,480
what type it is.

00:16:29,480 --> 00:16:32,800
And, this is what is used to generate those

00:16:32,800 --> 00:16:35,309
stubs and skeletons as I showed in that previous

00:16:35,309 --> 00:16:36,329
slide.

00:16:36,329 --> 00:16:38,489
And so here's a, kind of a, like a

00:16:38,489 --> 00:16:42,929
high-level example of the tutorial. The Apache Thrift comes

00:16:42,929 --> 00:16:45,629
with a calculator tutorial, so I've just kind of

00:16:45,629 --> 00:16:48,889
extended that with an AMQP transport to show us,

00:16:48,889 --> 00:16:51,279
to demo this, but what you can see here

00:16:51,279 --> 00:16:53,809
is that the service that is in the calculate

00:16:53,809 --> 00:16:58,369
service, basically has a few operations, such as add,

00:16:58,369 --> 00:17:01,379
calculate - and I've added one for updating JSON,

00:17:01,379 --> 00:17:06,339
because we found that the strongly typed transport becomes

00:17:06,339 --> 00:17:08,010
a little bit restricting sometimes, and it's nice to

00:17:08,010 --> 00:17:09,779
be able to send back flexible amounts of data.

00:17:09,779 --> 00:17:11,970
And of course JSON can be string-i-fied, so it

00:17:11,970 --> 00:17:13,610
makes it really easy for things like that.

00:17:13,610 --> 00:17:17,140
But this is an example of an IDL, where

00:17:17,140 --> 00:17:19,760
you specify the contract, if you will. So this

00:17:19,760 --> 00:17:23,209
service says, these operations are what I support, and

00:17:23,209 --> 00:17:25,990
these are the messages, if you will, these, the

00:17:25,990 --> 00:17:29,330
parameters and the return types become the messages of

00:17:29,330 --> 00:17:31,669
the operations that gets passed back and forth. And

00:17:31,669 --> 00:17:33,809
it can also throw exceptions, if you will.

00:17:33,809 --> 00:17:38,130
So Thrift supports the ability to define a exception,

00:17:38,130 --> 00:17:39,750
so when things get back, it can be sent

00:17:39,750 --> 00:17:42,909
back in itself and it becomes a message. You

00:17:42,909 --> 00:17:46,519
can also do non-blocking, using like a one-way modifier,

00:17:46,519 --> 00:17:48,720
which says basically I'm gonna fire the message off

00:17:48,720 --> 00:17:55,720
and then move on with my life.

00:17:56,190 --> 00:17:57,279
So just to make sure that we're all on

00:17:57,279 --> 00:17:59,320
the same page of what I'm gonna demonstrate here

00:17:59,320 --> 00:18:02,190
in a minute. This is the Apache Thrift tutorial,

00:18:02,190 --> 00:18:06,610
if you will, kind of broken out. The area,

00:18:06,610 --> 00:18:08,630
the boxes in blue are what the developer would

00:18:08,630 --> 00:18:10,850
write. So they would write the client-side, how they're

00:18:10,850 --> 00:18:13,120
gonna call the operation, what they're gonna do with

00:18:13,120 --> 00:18:15,460
it. They wold oper- they would write that thrift,

00:18:15,460 --> 00:18:18,549
like I showed you, the thrift IDL, and then

00:18:18,549 --> 00:18:20,500
they would write the handler on the back, and

00:18:20,500 --> 00:18:22,340
that would show the, the code that would handle

00:18:22,340 --> 00:18:25,070
the messages when they're actually being received.

00:18:25,070 --> 00:18:28,000
And then they'd write the surrounding server code, to

00:18:28,000 --> 00:18:30,940
run it as a service. The boxes in yellow

00:18:30,940 --> 00:18:33,360
represent the generated code. So when you write the

00:18:33,360 --> 00:18:36,240
IDL, you'll see, if you run the Apache Thrift

00:18:36,240 --> 00:18:39,370
tutorial itself, you generate - there's a compiler that

00:18:39,370 --> 00:18:41,100
comes with it. That's the biggest part of the

00:18:41,100 --> 00:18:44,370
installation is generating and creating the compiler.

00:18:44,370 --> 00:18:46,909
And it will generate these stub files that are

00:18:46,909 --> 00:18:49,760
used to transfer the data around. And then the

00:18:49,760 --> 00:18:53,590
underlying pink are what would come normally with Thrift.

00:18:53,590 --> 00:18:55,419
Now Thrift doesn't come with AMQP out of the

00:18:55,419 --> 00:18:57,950
box. This is something I wrote and I'm putting

00:18:57,950 --> 00:19:00,659
out there for anyone to use if they want.

00:19:00,659 --> 00:19:04,120
But the idea is that you can choose the

00:19:04,120 --> 00:19:06,830
binary protocols or JSON protocols or whatever that come

00:19:06,830 --> 00:19:10,110
with thrift, and the AMQP transport just becomes yet

00:19:10,110 --> 00:19:13,350
another transport you can use along with anything else.

00:19:13,350 --> 00:19:16,730
But the idea behind the, the calculator tutorial is

00:19:16,730 --> 00:19:18,809
if I'm a client application and I'm gonna call

00:19:18,809 --> 00:19:21,929
one of those operations, like add or calculate or

00:19:21,929 --> 00:19:26,169
whatnot, I make those calls, the data flows down

00:19:26,169 --> 00:19:30,460
through the generated client code, gets put into the

00:19:30,460 --> 00:19:33,519
protocol binary as the end of the message. Put

00:19:33,519 --> 00:19:37,220
on the AMQP transport, which writes the message out

00:19:37,220 --> 00:19:39,510
to the service queue. The server is over there

00:19:39,510 --> 00:19:41,909
listening on the other end, it receives the message,

00:19:41,909 --> 00:19:44,840
goes up the stack, comes up with the result,

00:19:44,840 --> 00:19:47,809
writes another message back out to the response queue,

00:19:47,809 --> 00:19:51,620
and then it's, it's heard from the client return,

00:19:51,620 --> 00:19:52,500
so.

00:19:52,500 --> 00:19:55,260
So, now I want to look at some code

00:19:55,260 --> 00:19:58,340
here.

00:19:58,340 --> 00:20:01,769
So basically, this would be the Thrift IDL, if

00:20:01,769 --> 00:20:06,179
you will, as I kind of already showed. Get

00:20:06,179 --> 00:20:08,580
rid of this guy.

00:20:08,580 --> 00:20:11,039
And, it's pretty much like I showed earlier. You

00:20:11,039 --> 00:20:14,769
have operations, and you define pretty much what the

00:20:14,769 --> 00:20:17,750
base types are. Integer thirty-twos if you will. Or

00:20:17,750 --> 00:20:20,200
you can also do structures, which are nice. An

00:20:20,200 --> 00:20:23,779
example of a work structure I think is above.

00:20:23,779 --> 00:20:27,149
Yeah. So you can pass in, this is, their

00:20:27,149 --> 00:20:29,730
IDL is in C format, of course. But you

00:20:29,730 --> 00:20:34,600
can do optional parameters as well. And that code

00:20:34,600 --> 00:20:37,279
you would normally just generate, and it would come

00:20:37,279 --> 00:20:40,370
up with, this would be generated code, which represents

00:20:40,370 --> 00:20:43,190
the calculator class. And you'll see in the way

00:20:43,190 --> 00:20:45,730
they're doing it, both sides of the skeletons and

00:20:45,730 --> 00:20:48,419
stubs are generated, so on the client side, you'd

00:20:48,419 --> 00:20:50,929
have a class, which is called, there, call client,

00:20:50,929 --> 00:20:53,500
and it's, and it includes all the Thrift client

00:20:53,500 --> 00:20:56,019
base stuff, but then you'll see for every operation

00:20:56,019 --> 00:20:59,059
there's a send and receive function that comes along.

00:20:59,059 --> 00:21:02,029
So from the client's point of view, the developer

00:21:02,029 --> 00:21:04,590
client's point of view, you call the ping operation,

00:21:04,590 --> 00:21:07,200
for example, it internally then generates all this stuff

00:21:07,200 --> 00:21:09,710
to do a send-receive of the ping, and then

00:21:09,710 --> 00:21:12,220
you get your data back. And there's one of

00:21:12,220 --> 00:21:15,860
those generators for every single operation, on this, on

00:21:15,860 --> 00:21:17,860
the service side there's the same thing. There's a

00:21:17,860 --> 00:21:21,779
process ping, thrift does everything in turns of streams.

00:21:21,779 --> 00:21:23,860
So you got a protocol for your inter, for

00:21:23,860 --> 00:21:25,860
your incoming stream and your outgoing stream.

00:21:25,860 --> 00:21:28,049
So it kind of follows the same pattern. You

00:21:28,049 --> 00:21:29,960
read the arguments out of the string which is

00:21:29,960 --> 00:21:34,799
your message format. And it calls the handler, it

00:21:34,799 --> 00:21:36,669
calls a function in the handler that will ultimately

00:21:36,669 --> 00:21:40,870
delegate out to the business logic that the developer's

00:21:40,870 --> 00:21:43,080
responsible for writing. And then it writes the results

00:21:43,080 --> 00:21:46,159
back that it receives onto the stream that gets

00:21:46,159 --> 00:21:46,980
sent back.

00:21:46,980 --> 00:21:49,899
And it includes all kinds of other built-in arguments,

00:21:49,899 --> 00:21:54,000
checking, validation, the fields and all that stuff. And

00:21:54,000 --> 00:21:58,019
this is, like I said, all generated. Ultimately, the

00:21:58,019 --> 00:22:01,480
developer's responsible for writing the handler. So in the

00:22:01,480 --> 00:22:04,269
calculator handler, what do I do when I get

00:22:04,269 --> 00:22:07,289
a ping. What do I do when I receive

00:22:07,289 --> 00:22:09,240
an add. What do I do when I receive

00:22:09,240 --> 00:22:09,620
a calculate.

00:22:09,620 --> 00:22:11,570
And so what happens when it, when that message

00:22:11,570 --> 00:22:14,659
comes into the, the generated code, ultimately it's going

00:22:14,659 --> 00:22:18,260
to be passed out through here. And then on

00:22:18,260 --> 00:22:20,840
the, when you start up the service object itself,

00:22:20,840 --> 00:22:23,909
I haven't, have examples for doing sockets for HTTP

00:22:23,909 --> 00:22:26,130
in here, as well. But effectively all you're doing

00:22:26,130 --> 00:22:27,720
is starting the server, and then it just sits

00:22:27,720 --> 00:22:29,029
there and runs.

00:22:29,029 --> 00:22:31,779
And so what's happening under the surface in the

00:22:31,779 --> 00:22:34,570
AMQP code is, when the service starts up it's

00:22:34,570 --> 00:22:39,639
obviously making connections to the, to the broker. Then

00:22:39,639 --> 00:22:40,919
it's gonna come down here in the serve and

00:22:40,919 --> 00:22:46,340
it's gonna just basically hit this queue subscribe method,

00:22:46,340 --> 00:22:49,250
and it's gonna just block. And only when a

00:22:49,250 --> 00:22:51,539
message is received from the broker then is it

00:22:51,539 --> 00:22:54,120
gonna enter into this block, and then proceed to

00:22:54,120 --> 00:22:54,639
do something.

00:22:54,639 --> 00:22:58,289
In this case, if it, if it, can handle

00:22:58,289 --> 00:23:00,700
it, it's gonna spawn up a new thread, and

00:23:00,700 --> 00:23:02,620
then from there it's going to, down here at

00:23:02,620 --> 00:23:04,760
the very bottom here, you can see, it's gonna

00:23:04,760 --> 00:23:08,840
delegate off to the processor, which was generated. The

00:23:08,840 --> 00:23:12,240
data that was received in the message.

00:23:12,240 --> 00:23:14,389
One thing that's interesting about, this is using the

00:23:14,389 --> 00:23:17,620
bunny gem, is that, with AMQP, is you cannot

00:23:17,620 --> 00:23:20,260
share conn- you can share connections across chi, threads,

00:23:20,260 --> 00:23:23,549
but you can't share channels. So the idea is

00:23:23,549 --> 00:23:25,220
that every time you spawn up a new thread,

00:23:25,220 --> 00:23:30,809
you create a new channel and then you'll be

00:23:30,809 --> 00:23:35,169
fine. Once the process is done with its thing,

00:23:35,169 --> 00:23:38,269
it, we rewind the stream and pull the response

00:23:38,269 --> 00:23:40,630
back, and then you go ahead and write and

00:23:40,630 --> 00:23:43,269
publish out a message back under the queue, or

00:23:43,269 --> 00:23:46,200
onto the exchange, and it gets forwarded on to

00:23:46,200 --> 00:23:47,380
the client.

00:23:47,380 --> 00:23:49,720
So the same thing is happening on the other

00:23:49,720 --> 00:23:54,899
side. So the caller basically starts up and it's

00:23:54,899 --> 00:23:57,380
gonna just simply, this is where it gets real

00:23:57,380 --> 00:24:01,570
easy for a, for a developer, is you're creating

00:24:01,570 --> 00:24:02,330
- if I can find it right here -

00:24:02,330 --> 00:24:07,049
you're creating the client, the calculator client, and then

00:24:07,049 --> 00:24:08,970
you're just calling functions on it, as if you're

00:24:08,970 --> 00:24:11,070
doing anything else, and you're passing your parameters, and

00:24:11,070 --> 00:24:12,870
you're gonna get your results back.

00:24:12,870 --> 00:24:14,509
So the logic is very simple. You don't even

00:24:14,509 --> 00:24:17,929
know that messaging is happening under the covers. And

00:24:17,929 --> 00:24:20,080
that's pretty much what's going on with the client.

00:24:20,080 --> 00:24:22,759
And so you're dealing with it like normal function

00:24:22,759 --> 00:24:23,870
programming.

00:24:23,870 --> 00:24:27,840
On the AMQP side of things, what's happening is

00:24:27,840 --> 00:24:30,250
Thrift is ultimately boiling all this down to this

00:24:30,250 --> 00:24:34,740
flush operation. And it's publishing a message out onto

00:24:34,740 --> 00:24:37,779
the exchange, sending the appropriate data, saying what queue

00:24:37,779 --> 00:24:39,259
does it want to go to for the service

00:24:39,259 --> 00:24:43,100
in general. And then the reply-to is what queue

00:24:43,100 --> 00:24:44,690
am I going to be listening to on the

00:24:44,690 --> 00:24:46,620
way back, and so then, if it's a blocking

00:24:46,620 --> 00:24:48,919
call, it'll go ahead and do the same thing.

00:24:48,919 --> 00:24:50,769
It'll subscribe to that reply queue, and it'll just

00:24:50,769 --> 00:24:52,769
wait for the response to come back.

00:24:52,769 --> 00:24:55,059
Of course we've got timeout stuff built into all

00:24:55,059 --> 00:24:57,600
this so that things, you know, key threads and

00:24:57,600 --> 00:25:00,580
processes aren't stuck. And then that's pretty much it.

00:25:00,580 --> 00:25:03,409
So what does that look like in real time,

00:25:03,409 --> 00:25:06,090
is that I can just basically start up my

00:25:06,090 --> 00:25:09,730
Ruby server, that Ruby calculator server, and I run

00:25:09,730 --> 00:25:12,570
the Ruby client, and so what you're seeing here

00:25:12,570 --> 00:25:17,019
is the operations are going off the simple calculator

00:25:17,019 --> 00:25:18,740
operations. And I have debugging on to help see

00:25:18,740 --> 00:25:21,179
this, but what you can see here is that

00:25:21,179 --> 00:25:23,370
a message gets received, these are the headers that

00:25:23,370 --> 00:25:25,779
come across in it. And the data's in binary

00:25:25,779 --> 00:25:27,789
form so you can't really see it too well.

00:25:27,789 --> 00:25:29,460
But you can see that for ping it's, it's

00:25:29,460 --> 00:25:32,399
just doing basically a ping. For adding, it's taking

00:25:32,399 --> 00:25:34,649
the 101 and then its response will be -

00:25:34,649 --> 00:25:40,149
I guess I didn't print that part out. But

00:25:40,149 --> 00:25:42,440
that's pretty much what's going on there. And so

00:25:42,440 --> 00:25:44,889
if you wanted to do then load balancing, you'd

00:25:44,889 --> 00:25:48,970
basically just start up a second version of the

00:25:48,970 --> 00:25:53,380
software and so running it again just means both

00:25:53,380 --> 00:25:58,470
of them are now handling messages.

00:25:58,470 --> 00:26:05,470
So it's a pretty simple, straightforward.

00:26:07,240 --> 00:26:08,840
So one of the nice things about Thrift is

00:26:08,840 --> 00:26:12,120
that it does allow for handling versioning and compatibility

00:26:12,120 --> 00:26:15,480
issues as you're business logics evolves over time, because

00:26:15,480 --> 00:26:18,380
functionality evolves over time. Your protocols need to evolve

00:26:18,380 --> 00:26:21,240
over time. And again, protocols here mean the wired

00:26:21,240 --> 00:26:25,529
protocol. So Thrift supports the ability to add additional

00:26:25,529 --> 00:26:28,840
parameters to your messages, and it will handle situations

00:26:28,840 --> 00:26:32,009
where if you have older code still running, it'll

00:26:32,009 --> 00:26:33,549
still handle that data.

00:26:33,549 --> 00:26:35,169
Your old code obviously won't do anything with it,

00:26:35,169 --> 00:26:36,750
but then when you start up new code, it'll,

00:26:36,750 --> 00:26:39,809
it'll handle it as well. And if you follow

00:26:39,809 --> 00:26:41,480
some of the key things that they point out

00:26:41,480 --> 00:26:45,539
in their documentation, there's some best practices. You can

00:26:45,539 --> 00:26:46,870
handle versioning pretty straightforward.

00:26:46,870 --> 00:26:49,500
And as I always- already pointed out, you can

00:26:49,500 --> 00:26:53,230
do server-load balancing by having multiple worker processes that

00:26:53,230 --> 00:26:55,700
sit there and subscribe to the same queue so

00:26:55,700 --> 00:26:58,970
those messages come onto the queue. It'll distribute them

00:26:58,970 --> 00:27:03,809
across workers and you get some load balancing based

00:27:03,809 --> 00:27:06,679
in. The, this does require your services to be

00:27:06,679 --> 00:27:11,120
built stateless so that you can handle messages, but

00:27:11,120 --> 00:27:13,880
that's pretty much it.

00:27:13,880 --> 00:27:15,610
So I'm gonna end up with just showing some

00:27:15,610 --> 00:27:17,919
references. If you download these slides, I'll put them

00:27:17,919 --> 00:27:23,360
up and post it somewhere. There's some interesting documentation

00:27:23,360 --> 00:27:26,059
online that kind of helps backup some of the

00:27:26,059 --> 00:27:28,519
things I've been talking about, if you can get

00:27:28,519 --> 00:27:29,070
into that.

00:27:29,070 --> 00:27:31,720
And that's pretty much it. If you have any

00:27:31,720 --> 00:27:33,559
questions I'd be glad to take them. I did

00:27:33,559 --> 00:27:38,929
bring some Playstation swag to encourage questions, so. That's

00:27:38,929 --> 00:27:40,840

YouTube URL: https://www.youtube.com/watch?v=HTVoQ6_iVuc


