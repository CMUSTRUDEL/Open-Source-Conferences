Title: Ruby Conf 2013 - Ruby-Core dilemmas by Marc-AndrÃ© Lafortune
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	Ruby-core is where Ruby features are born and bugs gets squashed. Get a glimpse of what this entails and test your Ruby knowledge and intuition at the same time. 

How surely can you differentiate unexpected behavior from normality? How in tune is Matz's principle of least surprise with yours? Can you distinguish bugs from features?

We will figure it out through a series of questions inspired by actual bug reports and feature requests, spiced up with a couple of trick questions. Each question is a dilemma and everyone gets to pick if they think it's a bug or a feature.

To uncover the answers, we'll have to explore unchartered territories. We'll dig deep in recursion, battle failing specs, encounter exotic Floats and other infinities, and decipher arcane C code.

Rubyists of all levels, from beginners to hardcore pros are invited in this informal challenge. Be sure to check your ego at the door, as no-one will escape unscathed; even top notch ruby-core committers don't always get right answers! Let's discover what can lie under the apparent simplicity of Ruby without forgetting to have fun.

Help us caption & translate this video!

http://amara.org/v/FG46/
Captions: 
	00:00:15,890 --> 00:00:20,490
so I'm going to start by the most

00:00:18,660 --> 00:00:23,600
difficult thing well first of all

00:00:20,490 --> 00:00:27,119
everyone should have these little cutie

00:00:23,600 --> 00:00:28,830
cardboard things if you don't well grab

00:00:27,119 --> 00:00:31,800
some next to you because there really

00:00:28,830 --> 00:00:33,000
should be plenty for everyone and this

00:00:31,800 --> 00:00:36,239
is going to be for the second part of

00:00:33,000 --> 00:00:38,970
the talk so if you stay that long all

00:00:36,239 --> 00:00:41,129
right so my name is matt connolly laugh

00:00:38,970 --> 00:00:43,110
often and that's i'm sorry it's not my

00:00:41,129 --> 00:00:46,020
fault i'm from montreal the french part

00:00:43,110 --> 00:00:48,090
of canada and we you know most people

00:00:46,020 --> 00:00:50,190
speak french there so you can call me

00:00:48,090 --> 00:00:53,730
mark it's pretty easier for most of you

00:00:50,190 --> 00:00:56,420
and today i'm going to talk about some

00:00:53,730 --> 00:00:58,590
rubik or dilemmas I think might be

00:00:56,420 --> 00:01:01,920
interesting and we're going to delve

00:00:58,590 --> 00:01:06,119
into a bit of code Ruby a lot and some

00:01:01,920 --> 00:01:08,070
even see code don't be too afraid um so

00:01:06,119 --> 00:01:10,890
that's the title of the talk but really

00:01:08,070 --> 00:01:13,890
it could be you know record dilemmas and

00:01:10,890 --> 00:01:16,020
how I became a garbage collector so

00:01:13,890 --> 00:01:17,729
actually I'm going to first start as to

00:01:16,020 --> 00:01:19,700
how i became a garbage collector and

00:01:17,729 --> 00:01:24,150
then we're going to look at some

00:01:19,700 --> 00:01:26,040
potential garbage together so let's go

00:01:24,150 --> 00:01:29,610
back five years ago when I fell in love

00:01:26,040 --> 00:01:32,369
with Ruby and I was having some weird

00:01:29,610 --> 00:01:34,830
difficulties that you know I'm playing

00:01:32,369 --> 00:01:37,619
around with it and just asking 42 if it

00:01:34,830 --> 00:01:39,479
was odd or calling methods like fine

00:01:37,619 --> 00:01:41,880
index it was giving me no method air and

00:01:39,479 --> 00:01:46,549
I was like what's going on well on my

00:01:41,880 --> 00:01:48,750
Mac there was Ruby 186 installed and

00:01:46,549 --> 00:01:54,090
these were actually features only

00:01:48,750 --> 00:01:56,310
available in 187 or 19 because 187

00:01:54,090 --> 00:01:58,140
actually introduced quite a bit of new

00:01:56,310 --> 00:02:01,380
features i mean it's officially just a

00:01:58,140 --> 00:02:04,409
point release but you know 185

00:02:01,380 --> 00:02:10,170
introduced to changes to the API 1863

00:02:04,409 --> 00:02:12,930
changes and 187 137 and of those 137

00:02:10,170 --> 00:02:15,799
changes many of them are quite fun quite

00:02:12,930 --> 00:02:19,560
interesting and I wanted to use them um

00:02:15,799 --> 00:02:21,989
so what do I do this was before rvm now

00:02:19,560 --> 00:02:24,080
with our VM it's so cool you can juggle

00:02:21,989 --> 00:02:27,350
change versions as you

00:02:24,080 --> 00:02:29,150
fit try jruby Rubinius but at the time I

00:02:27,350 --> 00:02:32,090
was like oh my god this there's already

00:02:29,150 --> 00:02:33,650
a ruby install do I override it do i do

00:02:32,090 --> 00:02:35,750
another one how do I do with my pants

00:02:33,650 --> 00:02:39,700
I'm really bad with the terminal I just

00:02:35,750 --> 00:02:42,620
didn't want to touch any of that so I

00:02:39,700 --> 00:02:44,120
was just lazy and I said screw that I'm

00:02:42,620 --> 00:02:45,980
not gonna I'm not going to overwrite

00:02:44,120 --> 00:02:48,380
anything I'm going to find another way

00:02:45,980 --> 00:02:50,180
so of course another way is just not use

00:02:48,380 --> 00:02:52,460
the new functions and if you have a

00:02:50,180 --> 00:02:54,650
library that uses them then don't use

00:02:52,460 --> 00:02:56,630
the library it was like no that's that's

00:02:54,650 --> 00:02:59,150
not the Ruby why it's you know there's a

00:02:56,630 --> 00:03:01,970
beautiful feature for me I want to use

00:02:59,150 --> 00:03:05,240
it so I did what you're not supposed to

00:03:01,970 --> 00:03:08,720
do I monkey patch the basic concepts to

00:03:05,240 --> 00:03:12,020
try to replicate the behavior so for

00:03:08,720 --> 00:03:15,350
instance here i'm defining the odd

00:03:12,020 --> 00:03:19,610
method for fixed nam and fine index with

00:03:15,350 --> 00:03:21,950
array and i did a couple of those for my

00:03:19,610 --> 00:03:26,330
first project this was cool it worked

00:03:21,950 --> 00:03:27,680
and then i did a second one so you know

00:03:26,330 --> 00:03:30,380
I didn't want to copy the whole thing so

00:03:27,680 --> 00:03:33,650
let's create a job so I start with my

00:03:30,380 --> 00:03:36,920
first gem and I released that my first

00:03:33,650 --> 00:03:41,630
version on april first 2009 and it had

00:03:36,920 --> 00:03:47,600
like 12 of the backboards i wanted and

00:03:41,630 --> 00:03:51,320
had written so today the backboards jim

00:03:47,600 --> 00:03:54,200
has over 250 backwards and quite a bit

00:03:51,320 --> 00:03:58,700
of some some gems uses it so i get a

00:03:54,200 --> 00:04:01,459
whole bunch of downloads but back then

00:03:58,700 --> 00:04:03,890
nobody knew about them so a friend of

00:04:01,459 --> 00:04:08,120
mine on my blog said well is it going to

00:04:03,890 --> 00:04:10,420
work with rails and why answer duh I

00:04:08,120 --> 00:04:12,410
mean rails at the time to argue at 186

00:04:10,420 --> 00:04:16,310
so I'm just adding new functionality

00:04:12,410 --> 00:04:18,380
there's no way it should break rails now

00:04:16,310 --> 00:04:21,530
the nice thing is real says this really

00:04:18,380 --> 00:04:24,410
huge massive test suite so I just ran it

00:04:21,530 --> 00:04:26,240
but including backwards first and it

00:04:24,410 --> 00:04:28,880
wasn't supposed to change anything but

00:04:26,240 --> 00:04:32,680
of course I was wrong and they were

00:04:28,880 --> 00:04:36,289
major many many failures they were

00:04:32,680 --> 00:04:37,440
mostly due to G sub so this was the code

00:04:36,289 --> 00:04:40,680
i had for Jesus

00:04:37,440 --> 00:04:42,600
it looks a bit complicated but in 187 if

00:04:40,680 --> 00:04:44,900
you call jisa without a block and with

00:04:42,600 --> 00:04:48,360
no argument that returns enumerator I

00:04:44,900 --> 00:04:51,120
wanted to do the same thing here so let

00:04:48,360 --> 00:04:54,510
me simplify it for you imagine that you

00:04:51,120 --> 00:05:00,330
monkey patch jisub this way should this

00:04:54,510 --> 00:05:02,820
change anything the answer is it's not

00:05:00,330 --> 00:05:06,450
going to work and this is an example

00:05:02,820 --> 00:05:09,330
where instead of giving you the result

00:05:06,450 --> 00:05:11,880
you want it is going to give you an

00:05:09,330 --> 00:05:14,250
error on nil I was like why is that

00:05:11,880 --> 00:05:16,530
what's going on here I mean dollar one

00:05:14,250 --> 00:05:18,630
is one of those funky global variables i

00:05:16,530 --> 00:05:20,640
never used but I mean you know anything

00:05:18,630 --> 00:05:22,950
starting with dollar is just you know

00:05:20,640 --> 00:05:25,350
you're not supposed to use them I don't

00:05:22,950 --> 00:05:27,420
use them and a good Ruby citizen by and

00:05:25,350 --> 00:05:29,760
some people do what's what's up with

00:05:27,420 --> 00:05:31,770
that what actually dollar one is not

00:05:29,760 --> 00:05:34,350
really a global variable if you try to

00:05:31,770 --> 00:05:37,200
set it for instance it will and will

00:05:34,350 --> 00:05:38,580
tell you can't okay let's go in the C

00:05:37,200 --> 00:05:40,440
code because I've got no idea what's

00:05:38,580 --> 00:05:41,610
going on with this and if you do you'll

00:05:40,440 --> 00:05:44,460
find that there's a whole bunch of

00:05:41,610 --> 00:05:47,040
virtual variables and they're defined

00:05:44,460 --> 00:05:49,169
like this in a seek out so okay I can't

00:05:47,040 --> 00:05:51,840
play around with the dollar one and

00:05:49,169 --> 00:05:54,330
because of the block context it doesn't

00:05:51,840 --> 00:05:56,130
work anymore so i removed the G sub

00:05:54,330 --> 00:06:01,230
backboard there's really no way around

00:05:56,130 --> 00:06:04,200
that and every other feature basically

00:06:01,230 --> 00:06:06,800
of 187 I was actually able to to

00:06:04,200 --> 00:06:09,390
backward but the question was now I

00:06:06,800 --> 00:06:11,400
think I'm not breaking anything but

00:06:09,390 --> 00:06:15,300
maybe I'm breaking stuff and Jay will be

00:06:11,400 --> 00:06:17,720
our Rubinius and Sean was curious what

00:06:15,300 --> 00:06:21,030
tests we do these guys have well

00:06:17,720 --> 00:06:24,300
Rubinius has this really great suite

00:06:21,030 --> 00:06:26,910
called Ruby spec and Ruby spec is really

00:06:24,300 --> 00:06:28,020
testing will be the language and it's

00:06:26,910 --> 00:06:30,930
really meant actually for all

00:06:28,020 --> 00:06:35,070
implementations of Ruby including Ruby

00:06:30,930 --> 00:06:38,190
MRI so I thought I should be able to run

00:06:35,070 --> 00:06:42,960
Ruby specs for my back port and it

00:06:38,190 --> 00:06:44,760
should ideally pass right um okay this

00:06:42,960 --> 00:06:47,220
is an example when you run Ruby specs

00:06:44,760 --> 00:06:50,720
just to show you that today there is

00:06:47,220 --> 00:06:53,420
over 150,000 expectations when you run

00:06:50,720 --> 00:06:54,680
sweet and it runs pretty quickly there's

00:06:53,420 --> 00:06:59,630
still some errors today I don't know why

00:06:54,680 --> 00:07:01,100
but anyway so I hear we're going to see

00:06:59,630 --> 00:07:03,830
a bit what Ruby spec is about and what

00:07:01,100 --> 00:07:06,050
writing a simple back port is about this

00:07:03,830 --> 00:07:09,170
is a stack overflow a real Sakura full

00:07:06,050 --> 00:07:11,720
question this guy is stuck with 187 and

00:07:09,170 --> 00:07:13,700
he wants to use rotate on an array and

00:07:11,720 --> 00:07:15,170
he says hey I want this and you know I

00:07:13,700 --> 00:07:19,870
don't want to upgrade these lazy like me

00:07:15,170 --> 00:07:23,180
and what can I do so the best answer was

00:07:19,870 --> 00:07:25,280
just shift call shift you're going to

00:07:23,180 --> 00:07:27,650
get your element and push it back so

00:07:25,280 --> 00:07:30,470
it's going to push it at the end all

00:07:27,650 --> 00:07:34,700
right so this gives us our version one

00:07:30,470 --> 00:07:39,320
of the rotate back board and let's see

00:07:34,700 --> 00:07:42,350
what their Ruby specs are saying so the

00:07:39,320 --> 00:07:44,540
first test is usually a very very basic

00:07:42,350 --> 00:07:46,669
test so in this case you take a very

00:07:44,540 --> 00:07:49,940
simple array and you try to rotate it

00:07:46,669 --> 00:07:51,410
and you see that it you know what what

00:07:49,940 --> 00:07:54,200
resulted gives you and if we actually

00:07:51,410 --> 00:07:56,900
try to pass it with our simple

00:07:54,200 --> 00:07:59,630
implementation we pass but do we pass

00:07:56,900 --> 00:08:04,400
all the specs well no the first one we

00:07:59,630 --> 00:08:06,440
get is it tells us that we should return

00:08:04,400 --> 00:08:09,950
a copy of the array when the length is 0

00:08:06,440 --> 00:08:12,200
or 1 and the example here is with an

00:08:09,950 --> 00:08:14,540
empty array if you try to rotate then

00:08:12,200 --> 00:08:16,340
our backboard just doesn't work so oh

00:08:14,540 --> 00:08:18,470
yeah we didn't think of this but if you

00:08:16,340 --> 00:08:20,450
shift from an empty array you get nil

00:08:18,470 --> 00:08:22,520
which you're pushing back to the array

00:08:20,450 --> 00:08:23,870
and you get an array containing nail

00:08:22,520 --> 00:08:26,900
instead of the empty array you were

00:08:23,870 --> 00:08:29,560
expecting okay so version 2 of rotate

00:08:26,900 --> 00:08:32,690
you can even make it gem release right

00:08:29,560 --> 00:08:35,210
you just don't do anything if it's empty

00:08:32,690 --> 00:08:37,370
because you're happy with your your

00:08:35,210 --> 00:08:39,969
solution okay so now we pass this test

00:08:37,370 --> 00:08:42,050
but we have another test that fails

00:08:39,969 --> 00:08:44,300
already rotated with an argument and

00:08:42,050 --> 00:08:47,890
returns blah blah blah oh yeah right

00:08:44,300 --> 00:08:51,070
rotate takes an argument so let's do

00:08:47,890 --> 00:08:53,870
let's add an argument default is one and

00:08:51,070 --> 00:08:56,510
it's quite nice because shift accepts an

00:08:53,870 --> 00:08:59,060
argument so we get an array and we use

00:08:56,510 --> 00:09:02,889
comcast and sort of push we should be

00:08:59,060 --> 00:09:05,259
good no we're not really good actually

00:09:02,889 --> 00:09:07,929
the test says that we should really do a

00:09:05,259 --> 00:09:10,299
mod on the sides because if the number

00:09:07,929 --> 00:09:13,739
is negative or it's too high it should

00:09:10,299 --> 00:09:16,149
still work and but shift won't so okay

00:09:13,739 --> 00:09:17,949
this gives us a solution we add lon

00:09:16,149 --> 00:09:20,350
we're at version four of our rutted

00:09:17,949 --> 00:09:23,470
surely we must be you know pretty close

00:09:20,350 --> 00:09:26,470
to passing aspects well we still have a

00:09:23,470 --> 00:09:29,230
failure we're not supposed to mutate the

00:09:26,470 --> 00:09:31,839
receiver all right there's two rotates

00:09:29,230 --> 00:09:34,059
there's rotate Bay and rotate without

00:09:31,839 --> 00:09:35,589
the bag and it's only rotated with the

00:09:34,059 --> 00:09:37,720
bang that supposed to mutate the

00:09:35,589 --> 00:09:39,459
receiver so okay now we have two back

00:09:37,720 --> 00:09:41,799
points for the price of one we're at

00:09:39,459 --> 00:09:43,660
version 5 pretty proud of our work so

00:09:41,799 --> 00:09:45,730
you see what i did with rotate i just

00:09:43,660 --> 00:09:49,509
called up and then I call the rotate

00:09:45,730 --> 00:09:52,209
bang version ok now we pass that test

00:09:49,509 --> 00:09:54,220
but there's another speck Michelle we're

00:09:52,209 --> 00:10:00,459
supposed to return a runtime error on a

00:09:54,220 --> 00:10:03,369
frozen array so the example that we fail

00:10:00,459 --> 00:10:08,679
actually is an auntie Rae because on an

00:10:03,369 --> 00:10:10,959
empty array we don't do anything so we

00:10:08,679 --> 00:10:13,119
don't raise an error if the array is not

00:10:10,959 --> 00:10:15,759
empty we're trying to shift and this

00:10:13,119 --> 00:10:17,889
will raise an error I mean Ruby will

00:10:15,759 --> 00:10:20,649
raise an error for us but in the case

00:10:17,889 --> 00:10:23,169
it's empty we have to do something the

00:10:20,649 --> 00:10:25,600
reason we have to do something is Ruby

00:10:23,169 --> 00:10:27,910
in general wants to fail early so in

00:10:25,600 --> 00:10:30,339
theory you should be able to call rotate

00:10:27,910 --> 00:10:33,009
bang on a frozen array but because it's

00:10:30,339 --> 00:10:35,559
not really doing anything but in

00:10:33,009 --> 00:10:38,019
practice we prefer to raise an error

00:10:35,559 --> 00:10:39,610
because normally you we expect that you

00:10:38,019 --> 00:10:44,559
are a is probably not going to be empty

00:10:39,610 --> 00:10:47,289
in those cases you would get an error so

00:10:44,559 --> 00:10:50,739
we have to modify this a bit and try to

00:10:47,289 --> 00:10:53,980
shift 0 if it's empty so this will also

00:10:50,739 --> 00:10:59,079
raise the air for us so weird version 6

00:10:53,980 --> 00:11:02,129
and do we pass the specs yet no okay we

00:10:59,079 --> 00:11:05,829
have to return it we should not return

00:11:02,129 --> 00:11:08,590
subclass instance for array subclasses

00:11:05,829 --> 00:11:12,820
now what the hell is this

00:11:08,590 --> 00:11:15,970
I need to talk about covariance imagine

00:11:12,820 --> 00:11:17,830
that you decide to subclass array now in

00:11:15,970 --> 00:11:20,560
practice I don't know have you ever

00:11:17,830 --> 00:11:22,240
subclass the base class maybe hash I

00:11:20,560 --> 00:11:24,400
think I've subclassed hash couple of

00:11:22,240 --> 00:11:28,330
times and rails actually subclasses

00:11:24,400 --> 00:11:30,490
string for their safe buffer but in

00:11:28,330 --> 00:11:31,900
general you don't typically do this but

00:11:30,490 --> 00:11:33,730
imagine you did and we're not even

00:11:31,900 --> 00:11:36,400
adding any method we're just doing this

00:11:33,730 --> 00:11:40,630
for fun we're creating an instance of

00:11:36,400 --> 00:11:43,830
that subclass if we call rotate and ask

00:11:40,630 --> 00:11:46,570
what's the class of the returned value

00:11:43,830 --> 00:11:49,570
it's actually array and that's our

00:11:46,570 --> 00:11:50,980
problem we called up and up will really

00:11:49,570 --> 00:11:53,260
make a duplicate it will give us an

00:11:50,980 --> 00:11:56,050
instance of sub so just for the fun of

00:11:53,260 --> 00:11:58,750
it do you guys know if we call flattened

00:11:56,050 --> 00:12:03,130
if it will in turn sub or if it will

00:11:58,750 --> 00:12:05,230
return array here I heard one sub and

00:12:03,130 --> 00:12:07,290
he's right so i think everyone agreed

00:12:05,230 --> 00:12:10,450
with him that's why everyone is silent

00:12:07,290 --> 00:12:13,690
really good job all right if you ask the

00:12:10,450 --> 00:12:18,310
first two elements of an array of verb

00:12:13,690 --> 00:12:20,920
an instance of class sub get array if

00:12:18,310 --> 00:12:27,190
you ask for the first two elements but

00:12:20,920 --> 00:12:34,660
with the slice upward and get some if

00:12:27,190 --> 00:12:37,180
you add two sub instances you're going

00:12:34,660 --> 00:12:42,390
to ring and if you multiply an instance

00:12:37,180 --> 00:12:44,340
by 2 you get sub all right so that's

00:12:42,390 --> 00:12:47,350
that can be a little bit

00:12:44,340 --> 00:12:49,360
counterintuitive but the funny part is

00:12:47,350 --> 00:12:52,420
that in ruby specs this kind of behavior

00:12:49,360 --> 00:12:54,370
is actually tested because when you're

00:12:52,420 --> 00:12:57,670
reimplemented Ruby you're saying okay I

00:12:54,370 --> 00:12:59,530
don't really know why you know the see

00:12:57,670 --> 00:13:01,660
Ruby does this but we might as well try

00:12:59,530 --> 00:13:05,310
to do exactly the same thing so if ever

00:13:01,660 --> 00:13:09,100
someone depends on that we're compatible

00:13:05,310 --> 00:13:12,280
and the covariance question is you know

00:13:09,100 --> 00:13:15,840
goes for for a lot of things just

00:13:12,280 --> 00:13:19,500
comparing two things like substring

00:13:15,840 --> 00:13:21,400
versus an actual string hash time

00:13:19,500 --> 00:13:24,060
usually

00:13:21,400 --> 00:13:26,980
see Ruby will check that you are a

00:13:24,060 --> 00:13:30,040
string but you don't have to be a string

00:13:26,980 --> 00:13:33,870
you have to be just not instance of but

00:13:30,040 --> 00:13:36,760
kind of if I'm not confusing the two and

00:13:33,870 --> 00:13:39,550
but I noticed when writing in the specs

00:13:36,760 --> 00:13:42,400
that if she do that with range it didn't

00:13:39,550 --> 00:13:44,740
work so I was like wow that's that's got

00:13:42,400 --> 00:13:47,200
to be a bug so that was my bug or

00:13:44,740 --> 00:13:52,060
feature and I was like I think there's

00:13:47,200 --> 00:13:54,610
something wrong here so I submitted a my

00:13:52,060 --> 00:13:56,530
first bug report I went to the C code

00:13:54,610 --> 00:13:59,050
tries to find where the hell this was

00:13:56,530 --> 00:14:01,600
happening it was pretty simple to change

00:13:59,050 --> 00:14:03,670
actually there were two lines in my

00:14:01,600 --> 00:14:06,820
patch I was like gotta get my first

00:14:03,670 --> 00:14:13,150
patch accepted and see Ruby and I had to

00:14:06,820 --> 00:14:14,890
wait six months and I had to convince

00:14:13,150 --> 00:14:16,540
mats and everyone else yeah it's bug

00:14:14,890 --> 00:14:17,830
because look at all the other cases it

00:14:16,540 --> 00:14:22,270
works and it really should be working

00:14:17,830 --> 00:14:28,210
and that's how it is so I in 191 and

00:14:22,270 --> 00:14:30,220
over it actually returns true okay so if

00:14:28,210 --> 00:14:32,950
we go back to our version 6 of rotate

00:14:30,220 --> 00:14:35,290
and we want to be a good citizen and

00:14:32,950 --> 00:14:37,630
return just an array we reach we just

00:14:35,290 --> 00:14:40,690
need to replace the DUP with array new

00:14:37,630 --> 00:14:43,420
of self and call rotate bang and now

00:14:40,690 --> 00:14:50,830
surely we must be with our super version

00:14:43,420 --> 00:14:54,280
7 of rotate passing specs we don't so we

00:14:50,830 --> 00:14:56,860
actually have two more failures and the

00:14:54,280 --> 00:15:02,680
argument that is passed needs to be

00:14:56,860 --> 00:15:07,060
cursed with calling to int so basically

00:15:02,680 --> 00:15:10,090
MRI always uses duck typing it doesn't

00:15:07,060 --> 00:15:12,370
require you to pass an integer it you

00:15:10,090 --> 00:15:14,140
can pass any object and it's going to if

00:15:12,370 --> 00:15:15,850
it needs an integer is going to call to

00:15:14,140 --> 00:15:20,440
end if you needs a string it's going to

00:15:15,850 --> 00:15:22,270
call to STR and make sure that what you

00:15:20,440 --> 00:15:25,570
return in those cases are an actual

00:15:22,270 --> 00:15:28,990
string or an actual integer and we also

00:15:25,570 --> 00:15:31,720
have some cases where we don't actually

00:15:28,990 --> 00:15:34,480
look at what is passed so for instance

00:15:31,720 --> 00:15:36,760
it again in the empty case

00:15:34,480 --> 00:15:39,339
here we're just disregarding whatever

00:15:36,760 --> 00:15:41,380
was passed and we're writing zero but if

00:15:39,339 --> 00:15:44,079
whatever was passed was complete garbage

00:15:41,380 --> 00:15:46,660
we actually need to raise an error so

00:15:44,079 --> 00:15:48,519
this is left as an exercise for all of

00:15:46,660 --> 00:15:50,680
you or you can look at the backboards

00:15:48,519 --> 00:15:52,510
code that actually goes through the

00:15:50,680 --> 00:15:54,190
trouble of doing the curtain and

00:15:52,510 --> 00:15:59,560
checking the result and and everything

00:15:54,190 --> 00:16:03,820
to actually pass their respects and this

00:15:59,560 --> 00:16:05,620
is the the spec example of what it's

00:16:03,820 --> 00:16:08,860
trying to do if ever you want to

00:16:05,620 --> 00:16:12,690
contribute to Ruby specs it's using em

00:16:08,860 --> 00:16:16,920
spec which is a version of our spec and

00:16:12,690 --> 00:16:20,889
this is the kind of thing it looks like

00:16:16,920 --> 00:16:24,220
alright so and we're getting in the

00:16:20,889 --> 00:16:25,779
second half of the talk and this is

00:16:24,220 --> 00:16:27,910
where I I'm going to want you to use

00:16:25,779 --> 00:16:33,310
these things I'm going to present a

00:16:27,910 --> 00:16:36,399
couple of examples of Ruby code and I'll

00:16:33,310 --> 00:16:39,639
want you to tell me if you think that

00:16:36,399 --> 00:16:42,730
the behavior you see is possible should

00:16:39,639 --> 00:16:44,680
be possible and if it's correct if it's

00:16:42,730 --> 00:16:47,139
a feature or it actually is a bug that

00:16:44,680 --> 00:16:51,069
needs to be fixed and you need to post

00:16:47,139 --> 00:16:53,949
on bugs Ruby languor so this is an

00:16:51,069 --> 00:16:55,930
example with covariance where we're not

00:16:53,949 --> 00:16:58,899
passing a string to partition we're

00:16:55,930 --> 00:17:04,179
passing an object that has a method to

00:16:58,899 --> 00:17:08,350
STR and if we do that we get actually

00:17:04,179 --> 00:17:11,799
different results is this a bug or is

00:17:08,350 --> 00:17:14,470
this a future raised whichever you think

00:17:11,799 --> 00:17:16,240
is a feature bug I aw come on I want

00:17:14,470 --> 00:17:18,339
more more than that even if you don't

00:17:16,240 --> 00:17:19,929
know just take a wild guess you're on

00:17:18,339 --> 00:17:23,709
cam and the whole internet will know

00:17:19,929 --> 00:17:28,540
that you were wrong okay okay so in this

00:17:23,709 --> 00:17:31,240
case and there's a really wish in all

00:17:28,540 --> 00:17:32,830
cases of did I say covariance before and

00:17:31,240 --> 00:17:35,710
I snuck over that's just a duck typing

00:17:32,830 --> 00:17:38,290
in all cases of duck typing see Ruby

00:17:35,710 --> 00:17:41,530
must behave exactly the same way if you

00:17:38,290 --> 00:17:43,090
pass an object that is string like or if

00:17:41,530 --> 00:17:46,929
you pass an actual strength so in this

00:17:43,090 --> 00:17:47,920
case this is a bug and 20 minutes later

00:17:46,929 --> 00:17:50,650
after I

00:17:47,920 --> 00:17:53,380
submitted a patch it was merchand by a

00:17:50,650 --> 00:17:56,110
no boo no boo I don't know if you've

00:17:53,380 --> 00:17:58,750
been to the cochise great talk he had

00:17:56,110 --> 00:18:03,660
this really awesome ya know boo is that

00:17:58,750 --> 00:18:03,660
is with us so no boo is that

00:18:09,880 --> 00:18:15,169
so I could say that nobody is the number

00:18:12,500 --> 00:18:16,909
one commuter in COV but that wouldn't

00:18:15,169 --> 00:18:19,220
really be share because if you've been

00:18:16,909 --> 00:18:21,980
to Cochise excellent talk there was this

00:18:19,220 --> 00:18:26,120
huge pie graph of the number of commits

00:18:21,980 --> 00:18:28,940
and one-third are from Nobu so all the

00:18:26,120 --> 00:18:30,919
others are like tiny slices all around

00:18:28,940 --> 00:18:35,120
and nobody is just taking the whole bulk

00:18:30,919 --> 00:18:40,280
of things so thanks know before merging

00:18:35,120 --> 00:18:42,260
this so quickly this was easier to to

00:18:40,280 --> 00:18:43,850
show that it was a bug because you could

00:18:42,260 --> 00:18:45,530
actually crash Ruby in this case when

00:18:43,850 --> 00:18:50,960
you were playing with the result so it

00:18:45,530 --> 00:18:54,260
was it was fun um all right so bugger

00:18:50,960 --> 00:18:57,470
feature you take an array called values

00:18:54,260 --> 00:19:00,559
at with a range that extends past the

00:18:57,470 --> 00:19:03,740
array so if you ask the range from 1 to

00:19:00,559 --> 00:19:07,850
42 inclusive you get two and three and

00:19:03,740 --> 00:19:11,210
if you ask 41 to 43 exclusive right

00:19:07,850 --> 00:19:20,419
that's where the three dots mean you get

00:19:11,210 --> 00:19:23,330
to three and nil bugger feature all

00:19:20,419 --> 00:19:25,400
right I see it's like a little bit more

00:19:23,330 --> 00:19:28,429
red than green but there's a bit of a

00:19:25,400 --> 00:19:30,620
mixture well don't be don't be a you

00:19:28,429 --> 00:19:34,490
know a shame because when this was

00:19:30,620 --> 00:19:39,289
submitted by mark rata on the mailing

00:19:34,490 --> 00:19:42,320
list first response was from ue from

00:19:39,289 --> 00:19:46,309
naruse he's a another asik emitter he's

00:19:42,320 --> 00:19:49,039
the responsible for the to the upcoming

00:19:46,309 --> 00:19:51,230
Ruby 2 point 1 he's the release manager

00:19:49,039 --> 00:19:54,289
he worked a lot on multilingual ization

00:19:51,230 --> 00:19:56,600
and he does a whole lot of stuff he

00:19:54,289 --> 00:20:00,830
actually commits also a lot to Ruby spec

00:19:56,600 --> 00:20:03,890
so he's like is this a bad guy I'm not

00:20:00,830 --> 00:20:05,670
sure Nobu said I it's definitely not a

00:20:03,890 --> 00:20:09,060
bug so

00:20:05,670 --> 00:20:10,890
okay everyone that raised the the green

00:20:09,060 --> 00:20:13,170
checkmark can feel confident that you

00:20:10,890 --> 00:20:15,390
know nobody agrees with you but I was

00:20:13,170 --> 00:20:20,700
like no no no way this has to be a bug

00:20:15,390 --> 00:20:24,030
right so in those cases what do we do we

00:20:20,700 --> 00:20:39,330
do nothing we do nothing and we went and

00:20:24,030 --> 00:20:42,270
one day max comes in and says I've

00:20:39,330 --> 00:20:47,040
thought about this very well and the

00:20:42,270 --> 00:20:48,900
trailing nil must be a bug ok so the nil

00:20:47,040 --> 00:20:52,230
is is not good there's something wrong

00:20:48,900 --> 00:20:55,140
going on next question of course is ok

00:20:52,230 --> 00:21:00,120
do we want it to have any nails art we

00:20:55,140 --> 00:21:04,110
want a bunch of nails right so is this a

00:21:00,120 --> 00:21:11,340
bug if we modify Ruby so that it returns

00:21:04,110 --> 00:21:14,400
this or is it a feature lots of green

00:21:11,340 --> 00:21:17,690
that's what green this is really good so

00:21:14,400 --> 00:21:24,560
it's a feature since Ruby 2 point 0 and

00:21:17,690 --> 00:21:24,560
why is it a feature because matt says

00:21:29,770 --> 00:21:35,660
that's really the definition right I

00:21:32,120 --> 00:21:38,240
mean it's a bug or feature depending on

00:21:35,660 --> 00:21:40,520
what Matt's the science in this case it

00:21:38,240 --> 00:21:42,890
was actually something that could change

00:21:40,520 --> 00:21:45,770
potentially some codes we included in

00:21:42,890 --> 00:21:51,340
the news file but some others are not so

00:21:45,770 --> 00:21:55,190
clear all right I'm going to acute 14 um

00:21:51,340 --> 00:21:56,840
you have a string of you have a string

00:21:55,190 --> 00:21:58,490
that's nine characters long ok so now

00:21:56,840 --> 00:22:01,000
I'm cheating a bit ok the question mark

00:21:58,490 --> 00:22:03,230
is not an actual question like it's a

00:22:01,000 --> 00:22:05,540
character I'm not telling you which so

00:22:03,230 --> 00:22:08,000
I'm just you know adding a bit to the

00:22:05,540 --> 00:22:09,440
mystery ok so I'm just telling you that

00:22:08,000 --> 00:22:13,790
you have a string it's nine characters

00:22:09,440 --> 00:22:16,490
long exactly and I call to sim so I'm

00:22:13,790 --> 00:22:24,680
getting a symbol and I call to s on it

00:22:16,490 --> 00:22:29,690
and i get plus bug or feature lots of

00:22:24,680 --> 00:22:32,660
red lots of red well you're wrong ok but

00:22:29,690 --> 00:22:34,250
if you try this with any version of root

00:22:32,660 --> 00:22:38,960
you have on your computer including

00:22:34,250 --> 00:22:41,600
jruby and Rubinius Ruby 18 19 or 20 with

00:22:38,960 --> 00:22:44,660
plus in parenthesis binary you're going

00:22:41,600 --> 00:22:47,270
to get plus all right and you can check

00:22:44,660 --> 00:22:50,270
in Ruby specs I don't actually know who

00:22:47,270 --> 00:22:52,790
wrote the spec but someone went and said

00:22:50,270 --> 00:22:54,560
wow there are these special cases we

00:22:52,790 --> 00:22:58,190
have to include them in the Ruby specs

00:22:54,560 --> 00:23:00,110
and it also works for minors binary if

00:22:58,190 --> 00:23:03,280
you're really interested and you get the

00:23:00,110 --> 00:23:06,440
symbol of Michael's now this actually

00:23:03,280 --> 00:23:08,750
was brought to me by kenichi kamiya who

00:23:06,440 --> 00:23:15,560
said he was going to be here today is he

00:23:08,750 --> 00:23:17,060
here easier or and child probably so I

00:23:15,560 --> 00:23:18,590
brought this up and I sent Matt does

00:23:17,060 --> 00:23:20,990
this make some sense he agreed with me

00:23:18,590 --> 00:23:22,510
so this is no longer going to be the

00:23:20,990 --> 00:23:26,480
case there's no longer are going to be

00:23:22,510 --> 00:23:29,990
these well bugs or features I'll leave

00:23:26,480 --> 00:23:32,690
it up to you all right 0 plus 1 plus 0

00:23:29,990 --> 00:23:38,720
plus 2 is equal to 0 plus 3 you get

00:23:32,690 --> 00:23:41,960
false is that a bug is that a feature ok

00:23:38,720 --> 00:23:45,440
lots of green couple of reds

00:23:41,960 --> 00:23:47,870
well I'm very happy for you those people

00:23:45,440 --> 00:23:50,179
that raised the red flag that means that

00:23:47,870 --> 00:23:53,570
you don't deal too much with floats and

00:23:50,179 --> 00:23:55,399
this is this is probably very good for

00:23:53,570 --> 00:23:58,460
your sanity okies because there's so

00:23:55,399 --> 00:24:00,350
many little bugs with the floats it's

00:23:58,460 --> 00:24:05,149
not even funny so actually this is a

00:24:00,350 --> 00:24:11,240
feature it's called it's got I saw

00:24:05,149 --> 00:24:13,520
something and this is an actual website

00:24:11,240 --> 00:24:16,279
a I'm not I'm not inventing that you can

00:24:13,520 --> 00:24:18,380
go there it has a small explanation some

00:24:16,279 --> 00:24:20,659
links to Wikipedia and it in solution

00:24:18,380 --> 00:24:21,890
hints for depending on your language you

00:24:20,659 --> 00:24:24,919
know and it's going to tell you that in

00:24:21,890 --> 00:24:28,039
Ruby to avoid these kinds of issues you

00:24:24,919 --> 00:24:31,429
can use bigdecimal or rational depending

00:24:28,039 --> 00:24:33,950
on what you need to use so this is

00:24:31,429 --> 00:24:36,679
because floats are actually not exact

00:24:33,950 --> 00:24:40,220
numbers they really represent very very

00:24:36,679 --> 00:24:42,500
tiny ranges of real values and when you

00:24:40,220 --> 00:24:46,059
actually play with them they're going to

00:24:42,500 --> 00:24:49,190
give you sometimes unexpected results

00:24:46,059 --> 00:24:52,100
all right I'm getting back with my

00:24:49,190 --> 00:24:55,490
question marks here so I'm writing this

00:24:52,100 --> 00:24:59,210
float number and if I ask for the string

00:24:55,490 --> 00:25:00,590
representation I get 0.21 does it seem

00:24:59,210 --> 00:25:08,779
like a bug or does it seem like a

00:25:00,590 --> 00:25:11,809
feature okay lots of green that's a

00:25:08,779 --> 00:25:13,990
feature because if you ask too many to

00:25:11,809 --> 00:25:17,750
store too many decimals in your float

00:25:13,990 --> 00:25:19,700
you know Ruby uses the normal double 64

00:25:17,750 --> 00:25:22,070
bits of resolution is going to say well

00:25:19,700 --> 00:25:23,990
really you're talking about 0.2 one

00:25:22,070 --> 00:25:25,940
that's weird shits in the range I'm

00:25:23,990 --> 00:25:28,130
going to simplify it for you and we're

00:25:25,940 --> 00:25:33,140
just going to talk about 0.2 one it's

00:25:28,130 --> 00:25:37,340
good bugger feature I have less decimals

00:25:33,140 --> 00:25:40,039
this time this time and I ask are we to

00:25:37,340 --> 00:25:42,409
get me a string and get me back my float

00:25:40,039 --> 00:25:44,840
but it doesn't give me back the float I

00:25:42,409 --> 00:25:50,000
started with is that a feature or is

00:25:44,840 --> 00:25:51,740
that a buck Oh lots of green wow that's

00:25:50,000 --> 00:25:54,920
a bug

00:25:51,740 --> 00:25:57,710
because in in most versions of Ruby 18

00:25:54,920 --> 00:26:00,350
there were specific float values that

00:25:57,710 --> 00:26:02,540
wouldn't round trip like this but really

00:26:00,350 --> 00:26:07,760
you can type in a whole bunch of numbers

00:26:02,540 --> 00:26:09,710
but when Ruby prints to you a number it

00:26:07,760 --> 00:26:12,050
should always be the minimum

00:26:09,710 --> 00:26:14,600
representation that has all the

00:26:12,050 --> 00:26:15,380
information about that float so it

00:26:14,600 --> 00:26:18,590
should contain all the information

00:26:15,380 --> 00:26:22,070
enough to two round-trip but no more and

00:26:18,590 --> 00:26:23,570
in some cases ruby was not giving you

00:26:22,070 --> 00:26:27,250
enough information so she tried two

00:26:23,570 --> 00:26:30,350
round-trip it would fail all right so

00:26:27,250 --> 00:26:33,559
let's did you know that you could round

00:26:30,350 --> 00:26:35,809
integers you have to it doesn't make

00:26:33,559 --> 00:26:37,070
sense to give positive values I mean

00:26:35,809 --> 00:26:39,410
it's going to give you back your integer

00:26:37,070 --> 00:26:41,480
but if you give negative values it's

00:26:39,410 --> 00:26:44,240
going to strip off some of the

00:26:41,480 --> 00:26:46,580
information so if you start with 321 you

00:26:44,240 --> 00:26:49,880
get 220 you got 300 and then you get

00:26:46,580 --> 00:26:53,330
zero because there's no a thousand units

00:26:49,880 --> 00:26:56,410
and then if you go down down down down

00:26:53,330 --> 00:27:02,000
at some point you get zero point zero

00:26:56,410 --> 00:27:05,390
bugger feature lots of red couple of

00:27:02,000 --> 00:27:08,929
greens so yeah ideally you would want to

00:27:05,390 --> 00:27:10,700
have always zero because it doesn't make

00:27:08,929 --> 00:27:13,040
sense that at some point it starts to be

00:27:10,700 --> 00:27:15,650
afloat I mean you start with an integer

00:27:13,040 --> 00:27:18,740
you ask it to be rounded up you want to

00:27:15,650 --> 00:27:20,870
you want to fix num so this was fixed

00:27:18,740 --> 00:27:23,840
and we're actually that's because i was

00:27:20,870 --> 00:27:25,850
back porting round i was writing some

00:27:23,840 --> 00:27:28,400
rubies bags in writing the Ruby specs

00:27:25,850 --> 00:27:30,920
they were actually failing in movie I

00:27:28,400 --> 00:27:32,900
was like what's going on and I was

00:27:30,920 --> 00:27:34,640
trying to test the extreme cases and

00:27:32,900 --> 00:27:37,309
then I looked at the code and found some

00:27:34,640 --> 00:27:39,470
other bugs so I'm going to be going a

00:27:37,309 --> 00:27:42,710
little bit quicker here and but these

00:27:39,470 --> 00:27:45,380
are kind of funny funny examples where

00:27:42,710 --> 00:27:48,679
you're like what is going on with this

00:27:45,380 --> 00:27:51,140
you know and if you delve in the code

00:27:48,679 --> 00:27:54,230
well you see that sometimes you need to

00:27:51,140 --> 00:27:56,480
you can't you know exponentiate two with

00:27:54,230 --> 00:28:00,020
two high values and so you take some

00:27:56,480 --> 00:28:03,840
shortcuts and once you if you make some

00:28:00,020 --> 00:28:13,260
small mistakes and it could bite you

00:28:03,840 --> 00:28:16,409
another funny example and even some

00:28:13,260 --> 00:28:18,510
basic basic arithmetic with no arguments

00:28:16,409 --> 00:28:21,120
no nothing would give you the wrong

00:28:18,510 --> 00:28:23,340
results on some platforms so if you have

00:28:21,120 --> 00:28:25,260
the behavior that's changes from

00:28:23,340 --> 00:28:27,510
platform to platform that's a really

00:28:25,260 --> 00:28:30,630
really big sign that this is what you

00:28:27,510 --> 00:28:34,400
should be raising all right bug or

00:28:30,630 --> 00:28:38,700
feature we have three objects in onp and

00:28:34,400 --> 00:28:41,399
they are all equal to one another but if

00:28:38,700 --> 00:28:45,149
you do one over N 1 over 0 or 1 over P

00:28:41,399 --> 00:28:50,429
you get three different results varga

00:28:45,149 --> 00:28:54,090
feature I'm impressed lots of green

00:28:50,429 --> 00:28:56,730
check marks so yeah if you have zero

00:28:54,090 --> 00:29:00,510
zero point zero and minus zero point

00:28:56,730 --> 00:29:03,779
zero and they're all equal with the

00:29:00,510 --> 00:29:04,950
equal sign but if you do if you inverse

00:29:03,779 --> 00:29:10,380
them you're going to get different

00:29:04,950 --> 00:29:15,299
results there's actually the equal the

00:29:10,380 --> 00:29:18,029
eql ? method just to distinguish 0.0

00:29:15,299 --> 00:29:20,279
from zero and 1.0 from one and it

00:29:18,029 --> 00:29:23,690
doesn't even distinguish minus 0 and 0

00:29:20,279 --> 00:29:26,429
point 0 from 0 as far as I know the only

00:29:23,690 --> 00:29:27,990
the best way to distinguish them if ever

00:29:26,429 --> 00:29:31,320
you need to distinguish them and then I

00:29:27,990 --> 00:29:34,610
I really pity you it's two is to take

00:29:31,320 --> 00:29:39,919
the inverse and check for the cosine

00:29:34,610 --> 00:29:44,520
alright so X is equal to something and s

00:29:39,919 --> 00:29:50,549
equal X equal X returns false burger

00:29:44,520 --> 00:29:52,820
feature Oh lots of red it's actually a

00:29:50,549 --> 00:29:52,820
feature

00:29:53,470 --> 00:30:00,080
so congratulations to the few green

00:29:56,360 --> 00:30:02,260
green check marks because actually not

00:30:00,080 --> 00:30:05,390
the number is the as far as i know only

00:30:02,260 --> 00:30:12,770
well it is the only built-in object that

00:30:05,390 --> 00:30:16,400
is not equal to itself all right um foo

00:30:12,770 --> 00:30:21,440
and bar two very simple objects and I

00:30:16,400 --> 00:30:24,679
ask the modulo of foo and bar or I send

00:30:21,440 --> 00:30:29,120
the modulo symbol with bar as an

00:30:24,679 --> 00:30:32,360
argument and I get different results is

00:30:29,120 --> 00:30:34,880
that a bug or is that a feature oh yeah

00:30:32,360 --> 00:30:37,630
cool I'm very happy that most people

00:30:34,880 --> 00:30:40,280
found it it's a bug you'd really should

00:30:37,630 --> 00:30:42,710
give you the same result I mean if you

00:30:40,280 --> 00:30:44,270
call a method and you send it there's

00:30:42,710 --> 00:30:47,360
really no reason to get a different

00:30:44,270 --> 00:30:49,669
result so when I saw that I actually

00:30:47,360 --> 00:30:52,190
couldn't believe my eyes I was like I

00:30:49,669 --> 00:30:54,169
didn't see how this was impossible I

00:30:52,190 --> 00:30:56,870
mean what's going on in the C code that

00:30:54,169 --> 00:30:59,120
it knows if it's if it was called with

00:30:56,870 --> 00:31:02,470
sand or if it was called like directly

00:30:59,120 --> 00:31:05,990
with you know with the the operator and

00:31:02,470 --> 00:31:07,730
and well a second question is what's the

00:31:05,990 --> 00:31:10,100
right result is it not a number is it

00:31:07,730 --> 00:31:11,419
4.2 so I'm going to start with this

00:31:10,100 --> 00:31:15,620
second question because that's the

00:31:11,419 --> 00:31:18,380
easiest to find if you ask 4.2 and you

00:31:15,620 --> 00:31:22,130
take the modulo with big numbers you get

00:31:18,380 --> 00:31:25,910
4.0 so add the limit you really should

00:31:22,130 --> 00:31:28,280
be you should be getting 4.2 and we can

00:31:25,910 --> 00:31:29,570
even think of what's going on a bit

00:31:28,280 --> 00:31:31,760
because when you actually want to

00:31:29,570 --> 00:31:34,510
calculate the modulo that the like

00:31:31,760 --> 00:31:37,190
easiest way is to make the division

00:31:34,510 --> 00:31:40,700
truncate the result to an integer and

00:31:37,190 --> 00:31:42,860
then subtract that number from what you

00:31:40,700 --> 00:31:46,340
started from but if you do that then you

00:31:42,860 --> 00:31:48,169
get with infinity you have a problem

00:31:46,340 --> 00:31:49,850
you're multiplying zero with infinity

00:31:48,169 --> 00:31:51,950
this gives you another number and

00:31:49,850 --> 00:31:54,559
another number is going to propagate to

00:31:51,950 --> 00:31:57,650
basically any mathematical expression

00:31:54,559 --> 00:32:00,770
you have all right so let's get to how

00:31:57,650 --> 00:32:03,140
is this possible and to that we have to

00:32:00,770 --> 00:32:05,090
delve in the C code so this is the

00:32:03,140 --> 00:32:06,650
method that actually does both the

00:32:05,090 --> 00:32:09,700
division in the modulo

00:32:06,650 --> 00:32:15,350
see Ruby and you see there's this ifdef

00:32:09,700 --> 00:32:18,080
have f mod and there's two things so you

00:32:15,350 --> 00:32:22,370
either call this f mon f mud method

00:32:18,080 --> 00:32:26,750
which is a method from math h or you do

00:32:22,370 --> 00:32:29,360
it by yourself in exactly the same way i

00:32:26,750 --> 00:32:31,850
said you first divide then you re

00:32:29,360 --> 00:32:35,380
multiply and you remove that from what

00:32:31,850 --> 00:32:40,580
you started with you get your module and

00:32:35,380 --> 00:32:43,640
we f mod is actually the built-in method

00:32:40,580 --> 00:32:46,820
of C but only on some machines and ruby

00:32:43,640 --> 00:32:48,620
wants to be compatible with really a lot

00:32:46,820 --> 00:32:50,630
of platforms so that's why there's an

00:32:48,620 --> 00:32:53,480
ifdef that still doesn't explain

00:32:50,630 --> 00:32:55,910
anything what it really means is on some

00:32:53,480 --> 00:32:57,980
platforms that have f mod you might not

00:32:55,910 --> 00:33:00,470
get the same result as on platforms

00:32:57,980 --> 00:33:02,510
where you don't but online platform is

00:33:00,470 --> 00:33:04,130
not going to decide that it has f mod or

00:33:02,510 --> 00:33:06,230
not depending on if i call stand or not

00:33:04,130 --> 00:33:10,520
right so there was something else going

00:33:06,230 --> 00:33:15,590
on and i found the solution in a fire

00:33:10,520 --> 00:33:18,290
call I n s and s def now this is not

00:33:15,590 --> 00:33:21,140
even real Seco there's kind of weird

00:33:18,290 --> 00:33:24,170
stuff going on here and I'm not going to

00:33:21,140 --> 00:33:27,050
go too deep into this but if you want to

00:33:24,170 --> 00:33:31,480
learn here we are actually in yard we're

00:33:27,050 --> 00:33:36,590
in the bytecode interpreter of Ruby and

00:33:31,480 --> 00:33:39,710
if you call the modulo operator before

00:33:36,590 --> 00:33:44,420
calling the method is going to check is

00:33:39,710 --> 00:33:49,730
the receiver float is the argument

00:33:44,420 --> 00:33:52,190
afloat and was the modulo method

00:33:49,730 --> 00:33:55,880
redefined if it's not been redefined

00:33:52,190 --> 00:33:58,910
then we know what to do and it goes on

00:33:55,880 --> 00:34:01,400
and does the simplistic version of

00:33:58,910 --> 00:34:04,220
calculating the mod so that's what

00:34:01,400 --> 00:34:07,040
happens actually because your optimizes

00:34:04,220 --> 00:34:11,090
the when you call directly a plus and

00:34:07,040 --> 00:34:13,250
equal in a couple of methods some of the

00:34:11,090 --> 00:34:15,560
code might be duplicated so the solution

00:34:13,250 --> 00:34:17,570
here was just to call the same code and

00:34:15,560 --> 00:34:19,850
actually be a little bit more careful

00:34:17,570 --> 00:34:22,790
with the highlighted code to

00:34:19,850 --> 00:34:26,720
check for infinities and we're back to

00:34:22,790 --> 00:34:31,040
sanity all right an ill little example

00:34:26,720 --> 00:34:33,610
here x and y you call X smaller than Y

00:34:31,040 --> 00:34:40,130
and you get neither true nor false

00:34:33,610 --> 00:34:43,730
burger feature you guys are good a lot

00:34:40,130 --> 00:34:46,400
of green and yeah I cheated a bit we're

00:34:43,730 --> 00:34:48,380
off the floats if you ask that for

00:34:46,400 --> 00:34:51,440
classes it could return nil of the

00:34:48,380 --> 00:34:54,680
classes are not related so we just have

00:34:51,440 --> 00:34:57,290
to remember that some of the operators

00:34:54,680 --> 00:34:59,480
are actually not there just method calls

00:34:57,290 --> 00:35:05,870
in the end and yard will not optimize

00:34:59,480 --> 00:35:09,190
that all right x and y are some objects

00:35:05,870 --> 00:35:18,260
and x is equal to y or y is equal to x

00:35:09,190 --> 00:35:20,480
do not return the same thing okay well

00:35:18,260 --> 00:35:25,850
i'm putting big question marks here and

00:35:20,480 --> 00:35:27,530
i'm cheating a little bit and because

00:35:25,850 --> 00:35:32,090
you know the question marks were

00:35:27,530 --> 00:35:36,290
replaced by actually two expressions i'm

00:35:32,090 --> 00:35:40,190
building here an array called x you know

00:35:36,290 --> 00:35:42,050
i am adding x 2 itself and i'm comparing

00:35:40,190 --> 00:35:45,200
it to an array containing an array

00:35:42,050 --> 00:35:50,330
containing X and I'm getting true and

00:35:45,200 --> 00:35:53,180
false so I think in general equal should

00:35:50,330 --> 00:35:55,520
be reflective i'm not sure what the word

00:35:53,180 --> 00:35:58,430
is but it really should be independent

00:35:55,520 --> 00:36:00,560
of the order so i delved into the code

00:35:58,430 --> 00:36:03,290
and was wondering what's going on so i

00:36:00,560 --> 00:36:06,230
need to talk a bit about recursion you

00:36:03,290 --> 00:36:10,360
all know the definition of recursion see

00:36:06,230 --> 00:36:10,360
recursion from the hackers dictionary

00:36:10,660 --> 00:36:17,840
usually we talk of recursion for

00:36:13,160 --> 00:36:19,580
functions or methods and it's recursion

00:36:17,840 --> 00:36:22,580
is the calling of a function from within

00:36:19,580 --> 00:36:28,700
that same function but we have recursive

00:36:22,580 --> 00:36:31,340
structures like arrays here and we these

00:36:28,700 --> 00:36:32,820
are can be quite fun to play with so

00:36:31,340 --> 00:36:35,250
here I'm just giving an example

00:36:32,820 --> 00:36:40,290
where my array contains 12 and then I'm

00:36:35,250 --> 00:36:42,120
adding myself i'm adding XX and i can go

00:36:40,290 --> 00:36:43,920
on and asking for the last element last

00:36:42,120 --> 00:36:45,990
element last element last element and i

00:36:43,920 --> 00:36:50,430
can go on forever and i'm still going to

00:36:45,990 --> 00:36:53,010
get x and ruby is actually really good

00:36:50,430 --> 00:36:54,450
in handling recursion if you ask a

00:36:53,010 --> 00:36:56,850
string representation i know if you've

00:36:54,450 --> 00:36:58,050
ever seen the little three dots saying

00:36:56,850 --> 00:36:59,820
you know i'm not going to go there

00:36:58,050 --> 00:37:02,990
because otherwise I'm just never going

00:36:59,820 --> 00:37:05,640
to finish and you can actually serialize

00:37:02,990 --> 00:37:07,830
recursive structures both with Marshall

00:37:05,640 --> 00:37:09,900
and llamo and if you try to do something

00:37:07,830 --> 00:37:12,000
a bit crazy like flattening it or

00:37:09,900 --> 00:37:15,090
joining it is going to tell you I can't

00:37:12,000 --> 00:37:18,600
do it and it's going to tell you why but

00:37:15,090 --> 00:37:21,180
for comparison I wasn't sure that the

00:37:18,600 --> 00:37:26,600
behavior was was ok so let's see exactly

00:37:21,180 --> 00:37:30,750
how Ruby does it this here is the array

00:37:26,600 --> 00:37:34,740
inspect function and it calls are be

00:37:30,750 --> 00:37:38,610
exact recursive with a function argument

00:37:34,740 --> 00:37:43,020
inspect re so our be exact recursive

00:37:38,610 --> 00:37:46,080
will pass a argument to detect recursion

00:37:43,020 --> 00:37:48,390
and gives the chance to the function to

00:37:46,080 --> 00:37:49,860
to do something special if we're in the

00:37:48,390 --> 00:37:52,200
recursive case so in this case we have

00:37:49,860 --> 00:37:54,330
the little three dots signifying that we

00:37:52,200 --> 00:37:57,840
are in a recursive structure otherwise

00:37:54,330 --> 00:38:00,300
it just builds the the inspect as you

00:37:57,840 --> 00:38:03,420
would think it would and it has to call

00:38:00,300 --> 00:38:05,910
of course RB inspect to call inspect on

00:38:03,420 --> 00:38:12,090
each element and this is how you could

00:38:05,910 --> 00:38:15,300
get a recursion now to get into what are

00:38:12,090 --> 00:38:16,710
be exact recursive does I'm going to

00:38:15,300 --> 00:38:19,020
simplify it a bit for you we're going to

00:38:16,710 --> 00:38:20,480
go in Rubinius where the implementation

00:38:19,020 --> 00:38:23,160
is in Ruby so it's going to be it is

00:38:20,480 --> 00:38:26,460
going to be a bit easier to understand

00:38:23,160 --> 00:38:29,760
and the 2s and inspect version are

00:38:26,460 --> 00:38:31,860
exactly very very similar to the sea

00:38:29,760 --> 00:38:35,310
version and the equivalent here is

00:38:31,860 --> 00:38:37,770
thread detect recursion so let's see

00:38:35,310 --> 00:38:39,990
what's the definition of thread detect

00:38:37,770 --> 00:38:42,300
recursion I love you guys play with

00:38:39,990 --> 00:38:44,550
Rubinius but if you ask the source

00:38:42,300 --> 00:38:45,990
location of a method even if it's a

00:38:44,550 --> 00:38:46,350
built-in method it actually gives you

00:38:45,990 --> 00:38:49,470
the

00:38:46,350 --> 00:38:51,300
right place to look at so that's really

00:38:49,470 --> 00:38:53,280
really cool compared to having to dig

00:38:51,300 --> 00:38:58,430
through the see Ruby code to know

00:38:53,280 --> 00:39:01,950
whether each method and functions are so

00:38:58,430 --> 00:39:03,960
the idea is quite simple when we visit

00:39:01,950 --> 00:39:05,790
an object we're going to remember we're

00:39:03,960 --> 00:39:08,970
going to store that that we've been here

00:39:05,790 --> 00:39:11,490
and then we're going to let the flow of

00:39:08,970 --> 00:39:14,700
instruction go if we ever go back and

00:39:11,490 --> 00:39:18,450
we've encountered ourselves we've seen

00:39:14,700 --> 00:39:22,950
ourselves we stop and we just return yes

00:39:18,450 --> 00:39:25,170
we are in the recursive mode so this

00:39:22,950 --> 00:39:29,070
doesn't actually work for comparing

00:39:25,170 --> 00:39:33,900
because you might detect recursion at

00:39:29,070 --> 00:39:36,570
the wrong time in one case where we're

00:39:33,900 --> 00:39:39,690
calling it we're detecting it early so

00:39:36,570 --> 00:39:44,250
we stop and in the other case we don't

00:39:39,690 --> 00:39:46,590
detect it before at the same time so the

00:39:44,250 --> 00:39:49,350
right way to do that for comparison is

00:39:46,590 --> 00:39:52,190
actually to stop the behavior when

00:39:49,350 --> 00:39:54,810
you've encountered both objects being

00:39:52,190 --> 00:39:57,330
verified at the same time you just you

00:39:54,810 --> 00:40:00,960
don't just store the idea of one of the

00:39:57,330 --> 00:40:03,300
of the collar and when you do that

00:40:00,960 --> 00:40:05,130
you're going to get the same results

00:40:03,300 --> 00:40:08,400
because you're going to detect recursion

00:40:05,130 --> 00:40:13,560
at the same time now I'm going to ask

00:40:08,400 --> 00:40:20,190
you one last question should these two

00:40:13,560 --> 00:40:23,790
arrays be the same or not so if we had X

00:40:20,190 --> 00:40:30,270
in bracket bracket X be false would that

00:40:23,790 --> 00:40:34,740
be a bug or feature I think half of the

00:40:30,270 --> 00:40:40,410
room is sleeping right now ok as an

00:40:34,740 --> 00:40:43,950
evenly-matched thing so you have to

00:40:40,410 --> 00:40:45,390
think of it in the other way why when

00:40:43,950 --> 00:40:48,210
are they not equal and they're not

00:40:45,390 --> 00:40:51,060
equally of the size is different or if

00:40:48,210 --> 00:40:54,930
when you go through them you get to a

00:40:51,060 --> 00:40:58,620
different element and the right solution

00:40:54,930 --> 00:40:59,940
is to return true and you have other

00:40:58,620 --> 00:41:02,440
cases

00:40:59,940 --> 00:41:05,289
where the structure might seem a bit

00:41:02,440 --> 00:41:08,529
different and you still want to be true

00:41:05,289 --> 00:41:12,400
so this is a little graph of what we

00:41:08,529 --> 00:41:14,619
have here the top box is X that contains

00:41:12,400 --> 00:41:18,249
itself and if you put that in an array

00:41:14,619 --> 00:41:21,489
and in an array you get this thing here

00:41:18,249 --> 00:41:23,799
is this one this one is this and this is

00:41:21,489 --> 00:41:25,809
the other example I gave and you might

00:41:23,799 --> 00:41:27,489
say all the grass very different but if

00:41:25,809 --> 00:41:29,470
you actually try to unfold them and

00:41:27,489 --> 00:41:32,619
imagine that you've got infinite time

00:41:29,470 --> 00:41:35,410
they all give you the same straight line

00:41:32,619 --> 00:41:39,569
and the shape is the same so they really

00:41:35,410 --> 00:41:42,220
should be equal and after that patch

00:41:39,569 --> 00:41:47,920
Ruby really supports recursion perfectly

00:41:42,220 --> 00:41:50,920
for serialization and comparison that

00:41:47,920 --> 00:41:56,140
was my second bug report there's been

00:41:50,920 --> 00:41:59,619
quite a few in the meantime um I'm going

00:41:56,140 --> 00:42:01,960
to conclude by quoting mats that Ruby is

00:41:59,619 --> 00:42:04,059
quite simple when you use it but if you

00:42:01,960 --> 00:42:07,779
dig a little bit further you get some

00:42:04,059 --> 00:42:10,989
strange and weird cases and behavior i

00:42:07,779 --> 00:42:14,049
invite you to question what you see in

00:42:10,989 --> 00:42:16,329
Ruby this really feature is this really

00:42:14,049 --> 00:42:19,150
bug is this what I expected why didn't I

00:42:16,329 --> 00:42:20,829
expect that and why has it been designed

00:42:19,150 --> 00:42:23,220
this way it might actually be a bug or

00:42:20,829 --> 00:42:26,369
it might be feature you can ask Matt

00:42:23,220 --> 00:42:26,369

YouTube URL: https://www.youtube.com/watch?v=fyq8Z6E5E14


