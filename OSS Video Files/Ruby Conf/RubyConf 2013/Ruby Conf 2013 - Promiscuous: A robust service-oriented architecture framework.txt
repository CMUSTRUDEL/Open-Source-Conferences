Title: Ruby Conf 2013 - Promiscuous: A robust service-oriented architecture framework
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	For anyone who has built an application that's larger than what a small team can build in a few months, the euphoria of working with frameworks like Rails or Sinatra is quickly lost to the pain of a sprawling disorganized code base, slow tests, and long ramp up time for new developers. Extracting Service Objects or abandoning MVC for something like MOVE only complicates the code base and fails to make things simpler. Moving to Javascript MVC helps extract a lot of view logic but you're still left with a monolithic backend. The solution we propose is to split up your monolithic app into many smaller, easy to maintain, applications.

Splitting applications is challenging for numerous reasons. One of the biggest challenge is to keep all the applications' data in sync. We introduce Promiscuous[1], an open source replication framework that facilitates data replication across applications in a safe and consistent manner. Unlike traditional approaches such as Stripe's MoSQL[2] and LinkedIn's Databus[3], which operate at the database level, Promiscuous transparently instruments the ActiveModel interface to replicate model operations by using Redis and RabbitMQ. This makes it a great solution for separation of concerns, heterogeneous database replication, and asynchronous triggers in the datacenter.

By Nicolas Viennot & Kareem Kouddous

We'll dive into the mechanics of Promiscuous and how we used it to split our monolithic application into eight small, single purpose applications. We will also show our findings in scalability, deployment, migration, unit/integration testing, and general architecture best practices laced with real world examples.

Help us caption & translate this video!

http://amara.org/v/FG4Z/
Captions: 
	00:00:16,000 --> 00:00:20,400
KAREEN KOUDDOUS: All right. Let's get started.

00:00:20,470 --> 00:00:24,289
Hi, I'm Kareem Kouddous. I'm currently CTO

00:00:24,289 --> 00:00:27,829
and founder at Crowdtap. I'm also a side project addict.

00:00:27,829 --> 00:00:32,020
You can find me on GitHub and Twitter at kareemk.

00:00:32,020 --> 00:00:34,690
So Ruby is cute. And what I mean by

00:00:34,690 --> 00:00:38,969
that is, you know, it's optimized for developer joy.

00:00:38,969 --> 00:00:43,149
I mean, anyone who attended Matz's keynote, you know,

00:00:43,149 --> 00:00:46,289
can, can feel that. I personally wanted to go

00:00:46,289 --> 00:00:48,679
up and hug him after the keynote. It's so

00:00:48,679 --> 00:00:51,440
clear that, you know, the genesis of Ruby came

00:00:51,440 --> 00:00:55,539
from a place of wanting to create joy in

00:00:55,539 --> 00:01:00,179
what you do every day. Happiness in web development.

00:01:00,179 --> 00:01:02,940
You know, and Rails, arguably could be cuter. You

00:01:02,940 --> 00:01:06,950
know, Rails took those same principles of really loving

00:01:06,950 --> 00:01:10,040
what you do every day as a web developer

00:01:10,040 --> 00:01:14,370
or software engineer and taking that to the web

00:01:14,370 --> 00:01:17,330
stack. And, I'm sure all of you remember the,

00:01:17,330 --> 00:01:19,360
you know, blog in fifteen minutes. And that was

00:01:19,360 --> 00:01:22,120
magical, because it was so painful before to get

00:01:22,120 --> 00:01:24,490
a web application up and running.

00:01:24,490 --> 00:01:26,640
And Rails changed everything.

00:01:26,640 --> 00:01:29,240
But, I'm sure, as a lot of you also

00:01:29,240 --> 00:01:34,670
know, over time as your team grows and you

00:01:34,670 --> 00:01:41,670
start to actually build very interesting features, you, you

00:01:42,390 --> 00:01:46,200
tend to, things start to get difficult. You know,

00:01:46,200 --> 00:01:48,830
tests start to take a long time. You know,

00:01:48,830 --> 00:01:52,610
there's great testing ethos in the Ruby community, but,

00:01:52,610 --> 00:01:53,510
you know, you have a lot of tests, you

00:01:53,510 --> 00:01:55,040
build a lot of features and things start to

00:01:55,040 --> 00:01:55,700
get slow.

00:01:55,700 --> 00:01:57,740
And what does that do, you know, instead of

00:01:57,740 --> 00:01:59,950
being able to push out code into your staging

00:01:59,950 --> 00:02:02,940
or production environment immediately, you have to wait, you

00:02:02,940 --> 00:02:05,810
know, minutes, maybe even hours, before that gets in

00:02:05,810 --> 00:02:08,539
there and you lose flow. You have to context

00:02:08,539 --> 00:02:12,610
switch. That's horrible. You know. Your fat models become

00:02:12,610 --> 00:02:14,420
obese.

00:02:14,420 --> 00:02:16,740
You know, suddenly, you know, you have six engineers

00:02:16,740 --> 00:02:20,670
touching your user model and people are repeating the

00:02:20,670 --> 00:02:22,290
code all over the place, because they're trying to

00:02:22,290 --> 00:02:25,410
do, you know, something that's the same but slightly

00:02:25,410 --> 00:02:28,700
different. And, you know, instead of trying to refactor

00:02:28,700 --> 00:02:30,230
the app, you know, you want to push features

00:02:30,230 --> 00:02:34,980
out. They're duplicating code. And then these things become

00:02:34,980 --> 00:02:40,280
really hard to work with and less joyful.

00:02:40,280 --> 00:02:42,090
You know, you start to use a lot of

00:02:42,090 --> 00:02:43,920
gems, and that's great. You know, that's one of

00:02:43,920 --> 00:02:46,690
the wonderful things about the Ruby community is there's

00:02:46,690 --> 00:02:48,590
a lot of us and we've contributed so much

00:02:48,590 --> 00:02:51,180
to it. But then you, your app starts to

00:02:51,180 --> 00:02:53,270
take a long time and, you know, you're building

00:02:53,270 --> 00:02:54,910
an interesting application so it has a lot of

00:02:54,910 --> 00:02:56,750
features and you have a lot of gems and

00:02:56,750 --> 00:02:59,830
that takes a long time. And you stop experimenting.

00:02:59,830 --> 00:03:02,900
You stop just putting up console and trying stuff.

00:03:02,900 --> 00:03:06,240
That joy of, that first experience with Rails or

00:03:06,240 --> 00:03:10,230
Ruby, you know, starts to erode. And then hugs

00:03:10,230 --> 00:03:14,840
turn into yelling, right. You, you're in the, you

00:03:14,840 --> 00:03:17,410
know, you're in your chat room, just trying to

00:03:17,410 --> 00:03:19,940
figure out what's going on, and yelling at each

00:03:19,940 --> 00:03:23,200
other. It's, it's, it's no longer joyful.

00:03:23,200 --> 00:03:24,920
And fundamentally what that means is you've lost your

00:03:24,920 --> 00:03:26,910
agility. And I think that's what Matz was really

00:03:26,910 --> 00:03:31,260
trying to say is, agility is about happiness, right.

00:03:31,260 --> 00:03:33,459
If you're happy and free to do what you

00:03:33,459 --> 00:03:36,470
want with your code, you're gonna take, you're gonna

00:03:36,470 --> 00:03:38,750
innovate. You're gonna do interesting things. You're gonna be

00:03:38,750 --> 00:03:39,650
creative.

00:03:39,650 --> 00:03:43,349
And, as your app, though, this, this starts to

00:03:43,349 --> 00:03:45,280
change, and you lose your agility, and we're back

00:03:45,280 --> 00:03:48,590
to, you know, waterfall, but, you know, same pain

00:03:48,590 --> 00:03:51,660
points, but just manifested in a different way. So.

00:03:51,660 --> 00:03:57,080
So, you know, what was really cute, you know,

00:03:57,080 --> 00:04:03,930
suddenly is this really scary, ugly thing that has

00:04:03,930 --> 00:04:06,300
appeared in your life, and you don't know what

00:04:06,300 --> 00:04:09,520
to do with it. You know, you, you want

00:04:09,520 --> 00:04:11,790
to figure out a way to solve this, and

00:04:11,790 --> 00:04:13,620
so you need to figure out what the root

00:04:13,620 --> 00:04:16,049
cause is, right. That's how you solve problems.

00:04:16,049 --> 00:04:17,919
So you need to figure out the root cause

00:04:17,919 --> 00:04:19,609
and solve this problem. You want this guy out

00:04:19,609 --> 00:04:21,989
of your life.

00:04:21,989 --> 00:04:24,969
So to illustrate that, I'm gonna go through how

00:04:24,969 --> 00:04:29,029
this manifested itself, this problem, this beast in, at

00:04:29,029 --> 00:04:32,870
Crowdtap, and, and walk through that to show how

00:04:32,870 --> 00:04:36,389
we got to where we are now. And, I'm

00:04:36,389 --> 00:04:38,629
gonna start by just giving you a quick overview

00:04:38,629 --> 00:04:41,779
of what Crowdtap is. You know, it's, we're the

00:04:41,779 --> 00:04:45,300
leading social influence marketing platform. You know we, we

00:04:45,300 --> 00:04:48,469
ally with big brands, collaborate with their customers which

00:04:48,469 --> 00:04:52,169
inspires advocacy and drives unmatched social activity.

00:04:52,169 --> 00:04:53,969
And what all this marketing speak boils down to

00:04:53,969 --> 00:04:59,909
is we create awesome tasks, engaging fun tasks, for

00:04:59,909 --> 00:05:03,189
the brand's launch that users complete to help brands

00:05:03,189 --> 00:05:05,879
market. And those tasks span the full marketing life

00:05:05,879 --> 00:05:09,629
cycle. Everything from completing a poll to taking a

00:05:09,629 --> 00:05:11,520
photo of doing something fun and sharing that on

00:05:11,520 --> 00:05:14,789
Facebook, to getting free product from the brand, sharing

00:05:14,789 --> 00:05:17,050
that with friends, throwing a party around it. And

00:05:17,050 --> 00:05:20,339
we're constantly adding different tasks, engaging, fun, engaging tasks,

00:05:20,339 --> 00:05:23,680
so that the brands can collaborate with their consumers

00:05:23,680 --> 00:05:26,629
to market, instead of just shouting at them.

00:05:26,629 --> 00:05:29,240
And that's what our vision is for, for Crowdtap.

00:05:29,240 --> 00:05:30,879
So let's, let's take a look at this and

00:05:30,879 --> 00:05:33,050
you know, a screenshot. And this is one of

00:05:33,050 --> 00:05:36,419
our more popular actions, which is a poll. Brands

00:05:36,419 --> 00:05:39,509
can get real time feedback on whatever they want.

00:05:39,509 --> 00:05:42,699
And here they're asking, specifically, you know, what Cable

00:05:42,699 --> 00:05:47,289
networks do, does, do the users currently watch, or

00:05:47,289 --> 00:05:48,120
receive.

00:05:48,120 --> 00:05:51,749
And the really powerful thing with Crowdtap is we

00:05:51,749 --> 00:05:55,990
take all this data that a user, that, that

00:05:55,990 --> 00:06:00,020
users generate from answering all these questions and participating

00:06:00,020 --> 00:06:03,469
with the brand, and we give the brands very

00:06:03,469 --> 00:06:06,749
rich and deep targeting ability, so that not only

00:06:06,749 --> 00:06:08,839
can they target based on all the demographic data

00:06:08,839 --> 00:06:11,559
on the user: their age, income, et cetera, which

00:06:11,559 --> 00:06:15,499
we collect. We, they can also target based on

00:06:15,499 --> 00:06:18,419
everything that user has done. The entire history of

00:06:18,419 --> 00:06:22,089
what that user has done with, with that brand.

00:06:22,089 --> 00:06:23,270
And they can also target based on what they

00:06:23,270 --> 00:06:26,719
haven't done. So, it's a very, very rich targeting

00:06:26,719 --> 00:06:29,740
engine. But as you can imagine, this becomes a

00:06:29,740 --> 00:06:34,589
performance bottleneck very quickly, because on every page load,

00:06:34,589 --> 00:06:38,550
we need to know which tasks are available for

00:06:38,550 --> 00:06:40,969
a user, and, if targeting, we need to -

00:06:40,969 --> 00:06:42,490
you can target based on anything that user has

00:06:42,490 --> 00:06:44,039
done. You have to load up the entire history

00:06:44,039 --> 00:06:45,979
of that user.

00:06:45,979 --> 00:06:48,089
And so, to be clear, this is a really

00:06:48,089 --> 00:06:51,610
big performance bottleneck. And this was the first painpoint

00:06:51,610 --> 00:06:56,389
that we encountered. Or, or, a major painpoint that

00:06:56,389 --> 00:06:59,629
we encountered, along with everything I was discussing. So

00:06:59,629 --> 00:07:03,259
we need, you know, we needed to solve this.

00:07:03,259 --> 00:07:06,180
And the way to solve this is, you know,

00:07:06,180 --> 00:07:08,909
we need to tailor our data structure for the

00:07:08,909 --> 00:07:11,069
problem at hand. So, what I mean by that

00:07:11,069 --> 00:07:14,259
is, we're generating data, everything that that user is

00:07:14,259 --> 00:07:15,860
doing, and we're collecting it in a way from

00:07:15,860 --> 00:07:19,770
our main application that makes sense, you know, when

00:07:19,770 --> 00:07:21,680
you're doing just basic CRUD. But then we want

00:07:21,680 --> 00:07:23,729
to take that data and we want to have

00:07:23,729 --> 00:07:27,219
the freedom to denormalize the data. Maybe put in

00:07:27,219 --> 00:07:30,210
caching. Maybe use a different database technology.

00:07:30,210 --> 00:07:34,080
We want the freedom to experiment and explore with

00:07:34,080 --> 00:07:37,330
this data to be able to solve the problem.

00:07:37,330 --> 00:07:39,399
And at the same time, we want to do

00:07:39,399 --> 00:07:42,229
it in a way that takes us back to

00:07:42,229 --> 00:07:45,460
the joy. Back to the little cute, fuzzy animals

00:07:45,460 --> 00:07:47,719
we had in our lives and not these beasts,

00:07:47,719 --> 00:07:48,659
right.

00:07:48,659 --> 00:07:51,279
So how do you do this? So, you know,

00:07:51,279 --> 00:07:53,319
the first thing we thought was, OK, we've been

00:07:53,319 --> 00:07:56,179
reading, people have blogged about the services. What about

00:07:56,179 --> 00:07:58,659
just extracting and, you know, this functionality in services?

00:07:58,659 --> 00:08:01,270
But that doesn't work, right. Because even if you

00:08:01,270 --> 00:08:03,679
extract your functionality into services, what you really care

00:08:03,679 --> 00:08:06,149
about is your models. Right, that's your data.

00:08:06,149 --> 00:08:09,289
So if you, there, we're not talking about extracting

00:08:09,289 --> 00:08:13,129
business logic, you know, into, you know, single purpose

00:08:13,129 --> 00:08:16,629
files. We're, we're talking about being able to work

00:08:16,629 --> 00:08:18,309
with our data in a flexible way. And so

00:08:18,309 --> 00:08:22,159
extracting it to services doesn't really help.

00:08:22,159 --> 00:08:24,779
And, you know, Rails, what about a Rails engine

00:08:24,779 --> 00:08:27,729
or gem extraction. Essentially this is all the same

00:08:27,729 --> 00:08:30,099
thing. It's just moving furniture around. What you really

00:08:30,099 --> 00:08:32,630
want to do is be able to mutate your

00:08:32,630 --> 00:08:34,000
data. You want to be able to play with

00:08:34,000 --> 00:08:39,800
your, your data structure, and have freedom there.

00:08:39,800 --> 00:08:42,560
And this brought us to, you know, what about

00:08:42,560 --> 00:08:45,329
app extraction? Why don't we extract this into a

00:08:45,329 --> 00:08:47,990
separate app? You know, we can go back to

00:08:47,990 --> 00:08:51,389
the, the little cute animal because it's a smaller

00:08:51,389 --> 00:08:53,769
app and solve all of those other painpoints. But

00:08:53,769 --> 00:08:55,889
at the same time, have, you know, some freedom

00:08:55,889 --> 00:08:58,440
to solve the performance problem which was a very

00:08:58,440 --> 00:09:00,079
big business problem for us.

00:09:00,079 --> 00:09:02,560
And so the first thing we considered is, how

00:09:02,560 --> 00:09:04,920
about extracting the app and sharing the database? Well,

00:09:04,920 --> 00:09:08,380
this def, this doesn't work, right. Because all, everything

00:09:08,380 --> 00:09:09,899
you need to do with your data is in

00:09:09,899 --> 00:09:12,060
your main app. Your main app holds that model.

00:09:12,060 --> 00:09:13,690
And so if you're gonna do anything interesting with

00:09:13,690 --> 00:09:14,630
your data, you're gonna have to do it in

00:09:14,630 --> 00:09:16,459
your main app, so what have you done?

00:09:16,459 --> 00:09:18,970
Your targeting app isn't, the splitting up of the

00:09:18,970 --> 00:09:23,889
app is not solving anything, right? OK. So let's

00:09:23,889 --> 00:09:26,279
do this. Let's to synchronous API. And this is,

00:09:26,279 --> 00:09:28,480
this is probably what most people think of as

00:09:28,480 --> 00:09:32,240
SOA, right. SOA is some RPC mechanism between apps.

00:09:32,240 --> 00:09:35,690
But, again, this does not solve this problem, because,

00:09:35,690 --> 00:09:37,199
if you're gonna do anything interesting with your data

00:09:37,199 --> 00:09:38,810
and you want to mutate your data, you're gonna

00:09:38,810 --> 00:09:40,899
have to do that in your main app.

00:09:40,899 --> 00:09:43,060
And so you're, you're adding complexity to your main

00:09:43,060 --> 00:09:45,110
app. We want to remove complexity from the main

00:09:45,110 --> 00:09:47,630
app and put it somewhere else, right, and, and

00:09:47,630 --> 00:09:50,079
deal with it somewhere else. So this doesn't, this

00:09:50,079 --> 00:09:53,870
doesn't solve the problem. This just adds more layers.

00:09:53,870 --> 00:09:58,670
So I hope, by now, it's clear what the

00:09:58,670 --> 00:10:01,220
right way to do this is. And for us,

00:10:01,220 --> 00:10:02,050
it was.

00:10:02,050 --> 00:10:05,579
You, we need to have a separate database for

00:10:05,579 --> 00:10:08,089
this, for our targeting application, and we need to

00:10:08,089 --> 00:10:12,899
replicate data from our main application into this separate

00:10:12,899 --> 00:10:15,310
app, and have the freedom in our main application

00:10:15,310 --> 00:10:18,480
to mutate the data as we wish, experiment with

00:10:18,480 --> 00:10:23,360
different databases, really go back to being agile in

00:10:23,360 --> 00:10:25,740
solving, in solving the problem.

00:10:25,740 --> 00:10:26,940
And that's what we did. And it's at that

00:10:26,940 --> 00:10:29,100
point that the heavens parted and Nico fell into

00:10:29,100 --> 00:10:32,860
our laps. And, and helped us take this architecture

00:10:32,860 --> 00:10:34,490
to the next level. So I'll just, just pass

00:10:34,490 --> 00:10:36,350
this onto Nico.

00:10:36,350 --> 00:10:40,519
NICOLAS VIENNOT: Hello. How are you? My name is

00:10:40,519 --> 00:10:43,810
Nico. I'm a PhD student at Columbia University in

00:10:43,810 --> 00:10:46,329
the system department. I love, I love opensource, and

00:10:46,329 --> 00:10:48,589
you can find me on Twitter and GitHub at

00:10:48,589 --> 00:10:50,259
nviennot.

00:10:50,259 --> 00:10:52,329
So last year, I came at Crowdtap, and they

00:10:52,329 --> 00:10:56,089
just extracted that targeting logic to its own separate

00:10:56,089 --> 00:10:58,410
app that we call Sniper. So that was a

00:10:58,410 --> 00:11:01,670
great win, because we were able to finally see

00:11:01,670 --> 00:11:04,459
the big picture of this application, of that logic,

00:11:04,459 --> 00:11:06,819
and that, and so when we extracted that it

00:11:06,819 --> 00:11:08,899
was like ten, I mean, five thousand, five thousand

00:11:08,899 --> 00:11:12,889
lines of code. And since we, we were on

00:11:12,889 --> 00:11:15,430
that app, we could really refactor it quickly because

00:11:15,430 --> 00:11:18,269
the tests were running in, like, you know, thirty

00:11:18,269 --> 00:11:18,639
seconds.

00:11:18,639 --> 00:11:20,740
And, and we, we got to a point where

00:11:20,740 --> 00:11:22,759
the app was just less than a thousand lines

00:11:22,759 --> 00:11:25,490
of code, because now, because it, it, it got

00:11:25,490 --> 00:11:28,220
really intuitive - oh, look, we should put our

00:11:28,220 --> 00:11:30,560
data structure like this. What if, what if we

00:11:30,560 --> 00:11:32,660
generalize this way around and all? Which we couldn't

00:11:32,660 --> 00:11:35,350
do in the main application because everything was kind

00:11:35,350 --> 00:11:37,269
of coupled together and it was really hard to

00:11:37,269 --> 00:11:39,300
see, you know, the big picture of things.

00:11:39,300 --> 00:11:42,620
So, performance went really well after that. We went

00:11:42,620 --> 00:11:44,670
from, you know, a second or two to fifty

00:11:44,670 --> 00:11:47,569
milliseconds. That was like, yay! Big win!

00:11:47,569 --> 00:11:50,319
But, we came to another problem, which was data

00:11:50,319 --> 00:11:54,449
replication. And it's actually hard. So, so what we

00:11:54,449 --> 00:11:57,980
did first was something pretty naive. So, on the

00:11:57,980 --> 00:12:00,550
main application, the publisher's side, we're like, well, let's

00:12:00,550 --> 00:12:05,329
just add some callbacks and post the, the data

00:12:05,329 --> 00:12:08,040
to Sniper. And then Sniper, the subscribers can be

00:12:08,040 --> 00:12:10,680
like, oh, I can take that data and save

00:12:10,680 --> 00:12:13,050
it to its database.

00:12:13,050 --> 00:12:15,170
But things started to break down in production. We're

00:12:15,170 --> 00:12:16,920
like, it's funny, these two databases don't have the

00:12:16,920 --> 00:12:20,879
same user count. It's weird. Because, so, we realized,

00:12:20,879 --> 00:12:22,959
wait, it's in a different system. Things fail all

00:12:22,959 --> 00:12:23,560
the time.

00:12:23,560 --> 00:12:27,019
So, for example, if your web server, right after

00:12:27,019 --> 00:12:30,620
writing its data to the database, dies, and is

00:12:30,620 --> 00:12:33,310
not able to the callback, then, oops, Sniper doesn't

00:12:33,310 --> 00:12:36,470
know about it. What if Sniper is down? Well,

00:12:36,470 --> 00:12:38,560
it won't receive some updates for five minutes.

00:12:38,560 --> 00:12:40,790
So that's a problem.

00:12:40,790 --> 00:12:42,899
So we're like, OK, so this is, this is

00:12:42,899 --> 00:12:45,579
a problem. And, and at the same time, we're

00:12:45,579 --> 00:12:47,800
looking at this. We're like, oh, that's funny. That

00:12:47,800 --> 00:12:50,410
looks really like an observer, like in the Rails

00:12:50,410 --> 00:12:53,649
sense, right, like, the Sni- the subscriber is really

00:12:53,649 --> 00:12:56,439
like observing the data that's changing on the other

00:12:56,439 --> 00:12:59,230
app. And we're like, well, that's, that's a cool

00:12:59,230 --> 00:13:01,470
concept. What can it do, then? And what we

00:13:01,470 --> 00:13:03,970
really want to do with that is to have,

00:13:03,970 --> 00:13:06,199
to split our app in a lot of different

00:13:06,199 --> 00:13:06,730
services, right.

00:13:06,730 --> 00:13:09,459
Like, if we could have this remote observer and,

00:13:09,459 --> 00:13:11,899
and rip the data around, we're like, well, why

00:13:11,899 --> 00:13:14,860
don't we apply the same thoughts to the email

00:13:14,860 --> 00:13:18,139
service. But we couldn't just add callbacks and see

00:13:18,139 --> 00:13:21,079
the production system kind of like blowing away like

00:13:21,079 --> 00:13:22,149
this.

00:13:22,149 --> 00:13:24,949
Which is why we introduced Promiscuous. Promiscuous is a

00:13:24,949 --> 00:13:28,579
transparent application level causally consistent data replication framework for

00:13:28,579 --> 00:13:31,939
service-oriented architecture. And, I'm gonna explain to you what

00:13:31,939 --> 00:13:34,300
it all means.

00:13:34,300 --> 00:13:37,660
So Promiscuous is essentially the glue between all of

00:13:37,660 --> 00:13:40,459
your services. So you can think of it as

00:13:40,459 --> 00:13:43,350
a message bus, where you're gonna have services publishing

00:13:43,350 --> 00:13:46,050
their data, and then you're gonna have subscriber apps

00:13:46,050 --> 00:13:47,889
that are like, oh, I'm intruding that model and

00:13:47,889 --> 00:13:50,160
this one and that, and it's gonna do something

00:13:50,160 --> 00:13:51,360
interesting.

00:13:51,360 --> 00:13:55,149
And Promiscuous sits at, on your models, between the

00:13:55,149 --> 00:13:57,800
models and the database layer. So everything that the

00:13:57,800 --> 00:14:01,449
publisher would do, it's gonna propagate those changes down

00:14:01,449 --> 00:14:04,019
to the subscriber models that have a view to

00:14:04,019 --> 00:14:05,639
anything.

00:14:05,639 --> 00:14:07,870
So that's Promiscuous in a nutshell.

00:14:07,870 --> 00:14:10,850
And, and because we are really trying to get

00:14:10,850 --> 00:14:14,069
back that joy and the simplicity of Rails and

00:14:14,069 --> 00:14:17,970
Ruby, Promiscuous had to, like, to, to provide those

00:14:17,970 --> 00:14:19,230
three key features.

00:14:19,230 --> 00:14:22,870
So first, it tackles data replication in a novel

00:14:22,870 --> 00:14:27,720
way, which scales and is actually consistent. It provides

00:14:27,720 --> 00:14:29,839
a very simple API, because as a developer, like,

00:14:29,839 --> 00:14:31,220
we just want to write one line of code

00:14:31,220 --> 00:14:33,040
and be done with it. And, of course, since

00:14:33,040 --> 00:14:35,870
we're Rubyists, we want a good testing framework.

00:14:35,870 --> 00:14:38,680
So I'm gonna go through all these three points.

00:14:38,680 --> 00:14:43,249
So data replication. It's pretty hard to, to get

00:14:43,249 --> 00:14:45,319
your head around this. But let's go through an

00:14:45,319 --> 00:14:47,720
example. So say you have some sort of Facebook

00:14:47,720 --> 00:14:50,480
app where you have users and they can send

00:14:50,480 --> 00:14:52,120
messages to each other.

00:14:52,120 --> 00:14:54,490
And, and so here, like, say I want to

00:14:54,490 --> 00:14:57,269
implement an email service that sends an email to

00:14:57,269 --> 00:15:01,649
whoever receive a message, right. Simple. So here, if,

00:15:01,649 --> 00:15:04,129
if you would to subscribe to the data that

00:15:04,129 --> 00:15:06,350
is interesting, you would see, oh, our user just

00:15:06,350 --> 00:15:08,160
signed up. So create user.

00:15:08,160 --> 00:15:09,730
And then, that guy just sent a message to

00:15:09,730 --> 00:15:12,439
another guy. OK. Create message, great. So when you

00:15:12,439 --> 00:15:14,779
create message, you're gonna be like, oh, fetch from

00:15:14,779 --> 00:15:17,189
my database. Oh, OK, I have that user, I

00:15:17,189 --> 00:15:20,920
can send random a email. OK, hi, whoever, oh

00:15:20,920 --> 00:15:22,689
hi and all that.

00:15:22,689 --> 00:15:25,009
But since we need to scale, because, you know,

00:15:25,009 --> 00:15:26,889
we have a lot of users, we're gonna add

00:15:26,889 --> 00:15:29,370
some more curves. So that's what's gonna happen. On

00:15:29,370 --> 00:15:33,620
your email service, we can have, say, two workers,

00:15:33,620 --> 00:15:35,990
and now, since we need to process this message

00:15:35,990 --> 00:15:39,170
in parallel, what's gonna happen? Well, if worker one

00:15:39,170 --> 00:15:42,949
is a bit slow sometimes, maybe it's not gonna

00:15:42,949 --> 00:15:45,639
process that create user quick enough to put in

00:15:45,639 --> 00:15:47,889
database, and so the worker two is gonna be

00:15:47,889 --> 00:15:49,939
like, oh, who is, who is that user? Oh,

00:15:49,939 --> 00:15:51,499
well I don't find it in my database. Boom

00:15:51,499 --> 00:15:53,089
exception. So that's a problem.

00:15:53,089 --> 00:15:55,999
And that's, that's a consistency problem.

00:15:55,999 --> 00:15:59,199
But promiscuous, it is going to solve this problem

00:15:59,199 --> 00:16:02,519
for you, under, transparently, without you having to do

00:16:02,519 --> 00:16:05,999
anything. And so it's going to try to paralyze

00:16:05,999 --> 00:16:09,800
as much as, messages that it can, but still

00:16:09,800 --> 00:16:11,850
serialize the messages that are important.

00:16:11,850 --> 00:16:16,240
For example, the create user happens before the create

00:16:16,240 --> 00:16:20,300
message. And that's what we mean by causal consistency.

00:16:20,300 --> 00:16:22,689
So as in cause and effect.

00:16:22,689 --> 00:16:25,149
So let's see how that kind of works. So

00:16:25,149 --> 00:16:29,559
why, how is the, is doing this transparently?

00:16:29,559 --> 00:16:31,059
So when you send, so when you have a

00:16:31,059 --> 00:16:32,970
user that wants to send a message to another

00:16:32,970 --> 00:16:35,309
user, it's gonna hit your controller in some ways.

00:16:35,309 --> 00:16:36,889
In your controller, what you're gonna do, you're gonna

00:16:36,889 --> 00:16:39,050
interact with your models. So what you gonna do?

00:16:39,050 --> 00:16:41,740
You're gonna fetch, first of all the current user,

00:16:41,740 --> 00:16:44,139
from his cookie, and then you're gonna do user

00:16:44,139 --> 00:16:46,769
find on his friend, and then you're gonna finally

00:16:46,769 --> 00:16:50,379
create the message with the frame keys that go

00:16:50,379 --> 00:16:51,019
by.

00:16:51,019 --> 00:16:53,980
And, since Promiscuous sits at your model, on your

00:16:53,980 --> 00:16:55,759
models, it can be like, oh, that's what you

00:16:55,759 --> 00:16:58,699
did. So he going to infer that the message

00:16:58,699 --> 00:17:01,709
create depends on those two piece of data. And

00:17:01,709 --> 00:17:04,690
that's how it's able to serialize the messages that

00:17:04,690 --> 00:17:08,920
are important and paralyze the ones that are not.

00:17:08,920 --> 00:17:10,900
So you could say, well, that's a bit overkill.

00:17:10,900 --> 00:17:14,370
Because why don't I just retry until, you know,

00:17:14,370 --> 00:17:16,630
the user is in my database because it would

00:17:16,630 --> 00:17:19,700
have an exception, right? But it's, it's actually moreso

00:17:19,700 --> 00:17:22,650
than that. SO let's take another example to illustrate

00:17:22,650 --> 00:17:23,280
this.

00:17:23,280 --> 00:17:26,440
SO say you're on Facebook and you have people

00:17:26,440 --> 00:17:28,540
posting pictures and you want to provide an email

00:17:28,540 --> 00:17:31,260
service that send an email of the picture to

00:17:31,260 --> 00:17:34,350
your, all of your friends. So say you have

00:17:34,350 --> 00:17:36,100
a user, consider that scenario where you have a

00:17:36,100 --> 00:17:38,290
user coming back from spring break, and he deletes

00:17:38,290 --> 00:17:40,690
his parents from his friends list and then he

00:17:40,690 --> 00:17:43,000
posts a compromising picture, K.

00:17:43,000 --> 00:17:46,720
So what happens if you reverse the processing of

00:17:46,720 --> 00:17:49,550
the two messages? Well you're gonna send the picture

00:17:49,550 --> 00:17:51,970
before having to remove the parents. And you're not

00:17:51,970 --> 00:17:53,620
gonna have an exception, you're gonna have a funk

00:17:53,620 --> 00:17:55,560
up.

00:17:55,560 --> 00:18:00,680
So, so this is how, so, Promiscuous has you

00:18:00,680 --> 00:18:03,370
covered. And you don't want to, when you're developing

00:18:03,370 --> 00:18:06,920
event-driven services, you, you don't want to, to think

00:18:06,920 --> 00:18:08,820
about all the races you could have and all

00:18:08,820 --> 00:18:12,560
that. Like, it's way too complicated. But we still

00:18:12,560 --> 00:18:17,440
want a very simple API. So.

00:18:17,440 --> 00:18:22,050
So essentially, Promiscuous is, is your main databus, right.

00:18:22,050 --> 00:18:25,970
And it does, so, so under the cover you

00:18:25,970 --> 00:18:27,780
have, you have RabiitMQ which is, which is a

00:18:27,780 --> 00:18:31,070
message broker, so you're gonna have publisher applications that

00:18:31,070 --> 00:18:35,710
are gonna send their messages on RabbitMQ, and then

00:18:35,710 --> 00:18:38,570
you're gonna have subscriber applications that are gonna connect

00:18:38,570 --> 00:18:40,880
to RabbitMQ and each of the services can have

00:18:40,880 --> 00:18:43,450
their own queue, I think, going to, to receive

00:18:43,450 --> 00:18:45,180
those messages through RabbitMQ.

00:18:45,180 --> 00:18:47,490
So no subscriber actually talk to the publisher app

00:18:47,490 --> 00:18:51,570
directly. So you're gonna have some good decoupling mechanism.

00:18:51,570 --> 00:18:54,920
And because we need to synchronize all the workers

00:18:54,920 --> 00:18:58,830
together, we use Reddis. So for example, that worker's

00:18:58,830 --> 00:19:00,840
like, oh wait, so before I can create that

00:19:00,840 --> 00:19:02,770
message I need for you to wait to create

00:19:02,770 --> 00:19:04,340
the user, OK. I'm gonna wait for you a

00:19:04,340 --> 00:19:06,770
little bit. Oh, you died. Well, in that case

00:19:06,770 --> 00:19:08,950
I'm going to process that message. So all of

00:19:08,950 --> 00:19:12,330
that is done through Reddis.

00:19:12,330 --> 00:19:14,400
So let's, let's see a bit of the API

00:19:14,400 --> 00:19:16,540
of Promiscuous. So on the top, I have a

00:19:16,540 --> 00:19:20,700
publisher application running with ActiveRecord on PosGres, for example,

00:19:20,700 --> 00:19:22,700
and on the bottom I have a subscriber application

00:19:22,700 --> 00:19:24,540
running on MongoDB.

00:19:24,540 --> 00:19:26,200
So all I need to do as a developer

00:19:26,200 --> 00:19:29,780
is to include the Promiscuous publisher mixin and publish

00:19:29,780 --> 00:19:32,620
the field that I'm, I'm interested in, for example,

00:19:32,620 --> 00:19:33,510
email and name.

00:19:33,510 --> 00:19:36,090
On the subscriber's side, I'm going to include the

00:19:36,090 --> 00:19:40,130
Promiscuous subscriber mixin and, and, in my subscribe block,

00:19:40,130 --> 00:19:41,690
I'm going to put the fields I'm interested in,

00:19:41,690 --> 00:19:42,750
too. And that's it.

00:19:42,750 --> 00:19:44,330
That's all you need to do. That's the entire

00:19:44,330 --> 00:19:45,740
API. That's it.

00:19:45,740 --> 00:19:50,650
So, of course, once you start developing this, you

00:19:50,650 --> 00:19:53,490
want to start testing that. And Promiscuous provides you

00:19:53,490 --> 00:19:56,650
with a testing framework. So, for us, we leave

00:19:56,650 --> 00:19:59,580
that interpretation tests are extremely important, and we, we

00:19:59,580 --> 00:20:01,940
have to, to test our subscribers in a way

00:20:01,940 --> 00:20:04,760
that is decoupled from the publishers.

00:20:04,760 --> 00:20:08,970
So the publishers actually, so Promiscuous allows publishers to,

00:20:08,970 --> 00:20:11,170
to create a gem to publish a gem with

00:20:11,170 --> 00:20:15,010
factories that represent the kind of data that, if

00:20:15,010 --> 00:20:17,280
you were to subscribe to their model, you, the

00:20:17,280 --> 00:20:19,130
kind of data that you would get.

00:20:19,130 --> 00:20:22,770
So to illustrate this, I'm going to show you,

00:20:22,770 --> 00:20:25,970
an, a real test of Sniper, and you can

00:20:25,970 --> 00:20:28,800
see, on the top, like, we just do create

00:20:28,800 --> 00:20:33,060
Crowdtap member instead of the regular Crowdtap create member.

00:20:33,060 --> 00:20:36,160
And so by doing this, Promiscuous is going to

00:20:36,160 --> 00:20:39,770
take the factory of Crowdtap and, and package the

00:20:39,770 --> 00:20:43,020
payload that you have received for real in production

00:20:43,020 --> 00:20:45,410
and send it through your, your cloud client. And

00:20:45,410 --> 00:20:48,900
so you're gonna be able to test a really

00:20:48,900 --> 00:20:53,500
well your application as if it was in production.

00:20:53,500 --> 00:20:57,610
So to really demonstrate how easy it is to

00:20:57,610 --> 00:21:01,490
use Promiscuous, Kareem is going to show you a

00:21:01,490 --> 00:21:04,300
live demonstration.

00:21:04,300 --> 00:21:11,300
K.K.: Hello. Thanks Nico. All right. Let's, let's show

00:21:21,190 --> 00:21:23,210
you guys how awesome this is.

00:21:23,210 --> 00:21:27,070
OK, so what I'm gonna do is I'm gonna

00:21:27,070 --> 00:21:31,460
show, show you guys adding, taking one of our

00:21:31,460 --> 00:21:35,300
existing models on our, on, on one of our

00:21:35,300 --> 00:21:37,740
apps, and subscribing to it in another. So on

00:21:37,740 --> 00:21:41,270
the, on the left side, we've got Crowdtap. And

00:21:41,270 --> 00:21:43,430
I've got the, one of our models that we're

00:21:43,430 --> 00:21:47,110
actually not publishing yet, which is Package, and so

00:21:47,110 --> 00:21:49,330
we're gonna take this and we're going to publish

00:21:49,330 --> 00:21:51,690
this model, and then, on the, on the other

00:21:51,690 --> 00:21:54,190
side, which is Sniper on the right side, which

00:21:54,190 --> 00:21:57,220
is the targeting app we were discussing, I'm going

00:21:57,220 --> 00:22:00,730
to subscribe to that model so that any changes

00:22:00,730 --> 00:22:03,870
to the publisher app are reflected to the, to,

00:22:03,870 --> 00:22:06,030
on the subscriber app. And I'm also gonna put

00:22:06,030 --> 00:22:08,610
some callbacks in there to bind to any changes

00:22:08,610 --> 00:22:10,270
that are happening.

00:22:10,270 --> 00:22:13,500
So let's, let's go ahead and do that. So,

00:22:13,500 --> 00:22:15,570
all you need to do first is just include,

00:22:15,570 --> 00:22:18,910
you know, the Promiscuous publisher, which Nico showed you

00:22:18,910 --> 00:22:23,170
in that API example. And then just wrap, you

00:22:23,170 --> 00:22:26,500
know, whatever fields you want to publish in a

00:22:26,500 --> 00:22:28,070
publish block. And so this case, you don't need

00:22:28,070 --> 00:22:31,270
to publish everything. And, and that's important, you want

00:22:31,270 --> 00:22:33,770
to figure out what's your public, what's your API,

00:22:33,770 --> 00:22:36,230
right, and doesn't need to be the entire model.

00:22:36,230 --> 00:22:37,900
So you publish what you want, so in this

00:22:37,900 --> 00:22:42,550
case, let's publish name and features. And that's it

00:22:42,550 --> 00:22:45,240
on the publisher's side, and so let's go ahead

00:22:45,240 --> 00:22:48,460
and do the, or, write the subscriber. So the

00:22:48,460 --> 00:22:49,450
only thing you need to do is create a

00:22:49,450 --> 00:22:52,550
model with exactly the same name - so, Package.

00:22:52,550 --> 00:22:57,040
You know, we're gonna store it in Mongo.

00:22:57,040 --> 00:22:59,250
Include the Promiscuous subscriber, so we're, you know, reflection

00:22:59,250 --> 00:23:04,470
of the Promiscuous publisher. And then mirror, again, the

00:23:04,470 --> 00:23:07,500
publish block with the subscribe block. And let's only

00:23:07,500 --> 00:23:12,230
subscribe to the, the name. Just for this example.

00:23:12,230 --> 00:23:13,720
And then let's print out the name every time

00:23:13,720 --> 00:23:18,180
the name changes. OK.

00:23:18,180 --> 00:23:19,950
So that's it. So that's all the code you

00:23:19,950 --> 00:23:24,280
have to write. So let's start up the Promiscuous

00:23:24,280 --> 00:23:31,280
subscriber and take a look at RabbitMQ.

00:23:31,640 --> 00:23:36,250
So RabbitMQ, it's an awesome admin AP- UI, and

00:23:36,250 --> 00:23:38,090
we just started the subscriber. There are no queues

00:23:38,090 --> 00:23:43,220
here. We should see a queue any second now.

00:23:43,220 --> 00:23:50,220
I type bad.

00:23:50,490 --> 00:23:57,490
There we go.

00:23:57,750 --> 00:24:00,950
So we have a queue in, in Rabbit. We're

00:24:00,950 --> 00:24:04,700
gonna kill the worker. Let's go back to Rabbit,

00:24:04,700 --> 00:24:07,410
and this is a reason that we, we, we

00:24:07,410 --> 00:24:09,790
chose Rabbit is it supports persistent queues. And what

00:24:09,790 --> 00:24:12,330
that means is, even if a worker dies, your

00:24:12,330 --> 00:24:16,450
queue is still there. It's pers- it's durable. And

00:24:16,450 --> 00:24:19,730
any messages that would be consumed or buffered by

00:24:19,730 --> 00:24:21,020
Rabbit, and when you start the worker up again

00:24:21,020 --> 00:24:21,940
you get those messages.

00:24:21,940 --> 00:24:23,500
So you guarantee that those messages are gonna be

00:24:23,500 --> 00:24:23,920
delivered.

00:24:23,920 --> 00:24:26,880
And that's a property that Rabbit gives you. It's

00:24:26,880 --> 00:24:31,740
awesome. So let's go back and let's, let's publish

00:24:31,740 --> 00:24:34,080
some of these. So first let's make sure we

00:24:34,080 --> 00:24:39,340
save this. Let's reload. Just to get those changes.

00:24:39,340 --> 00:24:42,800
And then I want to also illustrate how dependencies

00:24:42,800 --> 00:24:44,410
are tracked, so let's do a read, so I'm

00:24:44,410 --> 00:24:46,780
just gonna read the last member that we have

00:24:46,780 --> 00:24:49,540
in our database, and then let's actually create a

00:24:49,540 --> 00:24:56,540
package.

00:24:57,550 --> 00:25:04,550
Ok. So there we go. We've created that package

00:25:08,380 --> 00:25:11,770
on Crowdtap. Let's, let's pop over back to Rabbit

00:25:11,770 --> 00:25:15,270
and take a look at the payload of that

00:25:15,270 --> 00:25:17,700
message.

00:25:17,700 --> 00:25:20,390
And so here it is. So you can see

00:25:20,390 --> 00:25:23,190
a lot of metadata here. Types is, you know,

00:25:23,190 --> 00:25:25,940
the class we support inheritance, so you can, you

00:25:25,940 --> 00:25:28,190
can publish an entire inheritance tree. You can publish

00:25:28,190 --> 00:25:32,070
embedded documents. If you're using Mongoid, that's all supported.

00:25:32,070 --> 00:25:35,180
Which, you know, is very powerful. Obviously, the ID,

00:25:35,180 --> 00:25:38,940
the attributes that changed, the operation, here's some more

00:25:38,940 --> 00:25:41,240
metadata. Importantly in the namespace so it's the name

00:25:41,240 --> 00:25:45,530
of the app. Crowdtap. Some more information helps debugging,

00:25:45,530 --> 00:25:48,090
like the host that was published from. Current user

00:25:48,090 --> 00:25:50,870
if you're in a controller and you're, you're logged

00:25:50,870 --> 00:25:54,060
in. Publish that. That's really useful for debugging, and

00:25:54,060 --> 00:25:56,570
then, the most interesting part is the dependencies.

00:25:56,570 --> 00:25:58,770
So we did a read in, in console, and

00:25:58,770 --> 00:26:01,820
here's the associated dependency on that user. So here's

00:26:01,820 --> 00:26:04,510
the ID and the version. WE use versioning to

00:26:04,510 --> 00:26:07,030
make sure that when this message is consumed on

00:26:07,030 --> 00:26:10,680
the subscriber's side, that user exists in that exact

00:26:10,680 --> 00:26:10,990
state.

00:26:10,990 --> 00:26:13,210
So that's how we manage all the dependencies and

00:26:13,210 --> 00:26:17,020
do causal consistencies, and here's the right dependency which

00:26:17,020 --> 00:26:19,830
is the, the creation, the object that we just

00:26:19,830 --> 00:26:20,600
created.

00:26:20,600 --> 00:26:22,470
So that's it. That's the payload. So let's, let's

00:26:22,470 --> 00:26:23,980
go ahead and subscribe. And so what we should

00:26:23,980 --> 00:26:28,580
see here is you know, hello world being printed

00:26:28,580 --> 00:26:33,660
out. Drum roll.

00:26:33,660 --> 00:26:35,350
Magic!

00:26:35,350 --> 00:26:40,350
OK, so let's, you know, let's show that, let's

00:26:40,350 --> 00:26:47,350
show update. OK. Much easier to type when you're

00:26:50,500 --> 00:26:57,500
in your room than in front of people. OK.

00:27:01,090 --> 00:27:05,090
OK.

00:27:05,090 --> 00:27:12,090
All right. Sorry guys.

00:27:21,080 --> 00:27:28,080
OK. Well. For some reason this isn't working. But,

00:27:32,580 --> 00:27:39,580
we, let me try once more.

00:27:40,020 --> 00:27:47,020
OK.That's weird. I'm like typing. OK. Let's, if, if,

00:27:51,190 --> 00:27:52,980
if I had typed any change, it would be

00:27:52,980 --> 00:27:56,970
immediate propogated over to the publisher's side and trust

00:27:56,970 --> 00:28:00,690
me, it works. I can show you after.

00:28:00,690 --> 00:28:06,520
So let's, you know, so, so, let's, you know,

00:28:06,520 --> 00:28:08,010
what did this to us? So we started, you

00:28:08,010 --> 00:28:10,780
know, with these two applications. The main app, which

00:28:10,780 --> 00:28:14,140
is Crowdtap, and the targeting app, which is, you

00:28:14,140 --> 00:28:18,310
know, Sniper, because it's targeting. And then we pulled

00:28:18,310 --> 00:28:21,100
out all of our analytics in fiancé. You now

00:28:21,100 --> 00:28:25,290
fiancé because it's tracks engagements, obviously.

00:28:25,290 --> 00:28:27,240
And Bobby, you know, because he's the policeman that

00:28:27,240 --> 00:28:29,630
makes sure that, you know, when people are posting

00:28:29,630 --> 00:28:32,860
stuff, that you know, it's not spam or, and

00:28:32,860 --> 00:28:35,360
if it's awesome, that it gets starred. So, you

00:28:35,360 --> 00:28:38,220
know, we can iterate on using, you know, AEI

00:28:38,220 --> 00:28:42,920
techniques here to, to moderate our, our, our posts.

00:28:42,920 --> 00:28:45,910
And then Paparazzi, you know, is out there scraping

00:28:45,910 --> 00:28:48,290
Facebook and Twitter and gathering, you know, data, so

00:28:48,290 --> 00:28:52,720
that we can report on that for our clients.

00:28:52,720 --> 00:28:56,010
And then Casanova, you know, generates CSVs and it's

00:28:56,010 --> 00:29:02,030
Casanova because, because it works, because it spreads the

00:29:02,030 --> 00:29:04,940
love. I still don't, I still don't get that

00:29:04,940 --> 00:29:06,340
name.

00:29:06,340 --> 00:29:11,750
But. You know. WE have creative developers. And then

00:29:11,750 --> 00:29:15,520
email service, Iris, which is the, the, the nor,

00:29:15,520 --> 00:29:22,520
the notification God, and then most interestingly is, at

00:29:22,570 --> 00:29:24,910
least in my perspective is Captain Planet. And Captain

00:29:24,910 --> 00:29:27,280
Planet came out of a two day hack-a-thon that

00:29:27,280 --> 00:29:32,040
we recently had, where a developer was able to,

00:29:32,040 --> 00:29:35,340
on his, on his laptop, subscribe to the production

00:29:35,340 --> 00:29:39,300
database, production Rabbit, and generate ten reports off of

00:29:39,300 --> 00:29:41,460
that data to solve a really big pain point

00:29:41,460 --> 00:29:43,910
that we have that our account team has, and

00:29:43,910 --> 00:29:47,270
actually do that in a completely isolated way that

00:29:47,270 --> 00:29:49,920
didn't impact the production system at all.

00:29:49,920 --> 00:29:51,890
And was actually running that on his laptop, just

00:29:51,890 --> 00:29:54,580
like the fire hose of production data, on his

00:29:54,580 --> 00:29:56,820
laptop, and did that in a couple of days

00:29:56,820 --> 00:29:59,830
and worked with it. That is, that's joy, right.

00:29:59,830 --> 00:30:01,710
That's back to the joy of the fifteen minute

00:30:01,710 --> 00:30:05,700
blog. That's taking a really complex system and making

00:30:05,700 --> 00:30:08,150
it, you know, easy to use, and it took,

00:30:08,150 --> 00:30:11,560
you know, this, and went back to something ugly

00:30:11,560 --> 00:30:15,570
to a lot of little cute fun cuddly apps

00:30:15,570 --> 00:30:18,230
that we, that we now have.

00:30:18,230 --> 00:30:19,650
And with that, I'm gonna pass it back to

00:30:19,650 --> 00:30:22,740
Nico to wrap things up.

00:30:22,740 --> 00:30:26,730
N.V.: So to wrap things up, we've seen that

00:30:26,730 --> 00:30:31,250
Promiscuous is very useful to do event-driven services. So

00:30:31,250 --> 00:30:33,280
you can trigger callbacks realtime. For example, you want

00:30:33,280 --> 00:30:35,640
to send emails when some piece of data is

00:30:35,640 --> 00:30:39,210
changing. You want to keep your caches warm. Whenever,

00:30:39,210 --> 00:30:42,030
or, say, you know, whenever some piece of data

00:30:42,030 --> 00:30:44,590
changes, you wanna is, instead of invalidating your caches,

00:30:44,590 --> 00:30:46,960
you can actually reconfig the, the right thing.

00:30:46,960 --> 00:30:50,130
You could push data asynchronously to your browsers to

00:30:50,130 --> 00:30:52,780
improve the user experience. And we want to do

00:30:52,780 --> 00:30:57,990
all that also by, and also doing database replication,

00:30:57,990 --> 00:31:00,030
but different kind of databases, right. So I want

00:31:00,030 --> 00:31:02,390
to be able to replicate my PosGres database to

00:31:02,390 --> 00:31:06,640
ElasticSearch and maybe MongoDB and maybe Riot - whatever

00:31:06,640 --> 00:31:09,400
it is. And I want this to be decoupled,

00:31:09,400 --> 00:31:11,110
and I want this to be, do this at

00:31:11,110 --> 00:31:13,870
scale and with good consistency.

00:31:13,870 --> 00:31:16,470
So that was gonna allow you to, to really

00:31:16,470 --> 00:31:19,430
see the data that you want for the feature

00:31:19,430 --> 00:31:22,030
that you need to implement. And so real time

00:31:22,030 --> 00:31:25,190
is really, really important these days. And, and if

00:31:25,190 --> 00:31:29,530
you can embrace the arch, the, the asynchronous layer

00:31:29,530 --> 00:31:32,930
of your application and to really, to really unleash

00:31:32,930 --> 00:31:36,770
the power of your data, right. So you can

00:31:36,770 --> 00:31:40,310
really innovate now. You can hire some interns for

00:31:40,310 --> 00:31:43,130
a summer and get them to do some matching

00:31:43,130 --> 00:31:46,960
learning project directly in production without having you to

00:31:46,960 --> 00:31:49,440
be worrying about, oh my god, they're gonna drop

00:31:49,440 --> 00:31:52,100
my system and they're gonna pollute the code and

00:31:52,100 --> 00:31:52,680
all that.

00:31:52,680 --> 00:31:54,980
Like, if you don't like their stuff, eventually you

00:31:54,980 --> 00:31:57,930
just delete their app and you're done, right. So,

00:31:57,930 --> 00:31:59,720
so you can really go back to being agile

00:31:59,720 --> 00:32:02,220
and try things really with, without having, oh my

00:32:02,220 --> 00:32:04,280
god it's, I need to change so much things.

00:32:04,280 --> 00:32:07,740
Like, you, you get back to, to really the,

00:32:07,740 --> 00:32:11,180
to the agility of, of, of your team.

00:32:11,180 --> 00:32:13,460
So that's, that's about it. So we invite you

00:32:13,460 --> 00:32:17,300
to try it out. It's on GitHub, on Promiscuous

00:32:17,300 --> 00:32:19,890
dash io slash Promiscuous. So we've been using it

00:32:19,890 --> 00:32:22,020
in production for a year now and we're very

00:32:22,020 --> 00:32:23,790
happy with it. But it requires a bit of

00:32:23,790 --> 00:32:25,640
babysitting for now.

00:32:25,640 --> 00:32:28,440
So we're still working on it, and we're trying

00:32:28,440 --> 00:32:30,950
to make it really a hands-free experience. So that

00:32:30,950 --> 00:32:32,760
you can just plug it in and you have

00:32:32,760 --> 00:32:34,670
nothing to worry about and you have all the

00:32:34,670 --> 00:32:38,040
different recovery mechanism that kicks in at the right

00:32:38,040 --> 00:32:40,290
time and everything.

00:32:40,290 --> 00:32:42,360
So if you feel adventurous, you can try to

00:32:42,360 --> 00:32:45,230
extract your email logic out of your main application

00:32:45,230 --> 00:32:47,980
because that's, like, the obvious, like, you have no,

00:32:47,980 --> 00:32:49,620
it's an observer, really.

00:32:49,620 --> 00:32:52,770
And, and perhaps build some reporting service, also, for

00:32:52,770 --> 00:32:56,690
some, some of your fancy clients. So, if you

00:32:56,690 --> 00:32:58,960
try it out, we'll be super happy to help

00:32:58,960 --> 00:33:03,320
you with the, to go, with Promiscuous. And we,

00:33:03,320 --> 00:33:06,320
you can find us on Twitter and GitHub, kareemk

00:33:06,320 --> 00:33:06,780
and nviennot.

00:33:06,780 --> 00:33:10,160

YouTube URL: https://www.youtube.com/watch?v=KsiQXAXsQDQ


