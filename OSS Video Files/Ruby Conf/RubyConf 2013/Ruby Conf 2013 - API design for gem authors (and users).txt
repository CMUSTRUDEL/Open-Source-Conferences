Title: Ruby Conf 2013 - API design for gem authors (and users)
Publication date: 2020-01-27
Playlist: RubyConf 2013
Description: 
	By Emily Stolfo

Ruby applications are becoming more complex and unwieldy (think MonoRails). An increasing number of us are trying to address this by separating our apps into gems without knowing best practices on how to write APIs or how to manage dependencies and versioning. The discussion we often have around good APIs should not stop with Ruby OO design, but should also consider the public APIs of gems.

This talk is intended for gem authors and users. It will share though many practical examples using the Ruby driver to MongoDB 1) Principles of good gem API design, 2) How to make your gem API optimal for users and how to best use the API of a gem, 3) Guidelines for introducing and anticipating gem API changes and managing dependencies.

Help us caption & translate this video!

http://amara.org/v/FG5C/
Captions: 
	00:00:16,609 --> 00:00:17,849
EMILY SOLFO: My name is Emily Solfo.

00:00:17,849 --> 00:00:22,130
I work for MongoDB, where I co-maintain the Ruby driver to the database.

00:00:22,130 --> 00:00:26,890
It's the Mongo in JSON gem, if you've used the Ruby driver at all.

00:00:26,890 --> 00:00:31,890
And I'm gonna talk about gem API design for gem authors and users.

00:00:31,890 --> 00:00:34,670
Even if you're not a gem author, this will

00:00:34,670 --> 00:00:36,960
cover a bunch of concepts that are relevant to

00:00:36,960 --> 00:00:40,140
software engineering in general as well.

00:00:40,140 --> 00:00:41,739
So why am I talking about this? Well, I

00:00:41,739 --> 00:00:45,969
do co-maintain these, this Ruby driver at MongoDB. But

00:00:45,969 --> 00:00:48,469
I also realize that many of us have become

00:00:48,469 --> 00:00:51,939
gem authors through one of two ways: one way

00:00:51,939 --> 00:00:54,930
we could have become a gem author is by

00:00:54,930 --> 00:00:59,110
working on a Rails application at our company and

00:00:59,110 --> 00:01:01,920
realizing, over the course of time, that our application

00:01:01,920 --> 00:01:05,960
has become unwieldy, really complex, trying to do too

00:01:05,960 --> 00:01:08,600
many things, and we've decided as a team to

00:01:08,600 --> 00:01:12,399
break up our application into multiple services and tie

00:01:12,399 --> 00:01:14,310
everything together with a gem.

00:01:14,310 --> 00:01:17,200
Put all of the business logic in one place,

00:01:17,200 --> 00:01:19,479
centralize all of our data models, and maintain this

00:01:19,479 --> 00:01:22,990
gem internally at our company along with our colleagues.

00:01:22,990 --> 00:01:23,960
That's one way.

00:01:23,960 --> 00:01:27,360
The other way is by adopting a gem and

00:01:27,360 --> 00:01:31,020
becoming a gem maintainer, or by building a gem,

00:01:31,020 --> 00:01:33,560
opensourcing it, and becoming a gem author or opensource

00:01:33,560 --> 00:01:35,390
gem maintainer.

00:01:35,390 --> 00:01:39,369
So the point of this, though, is that there

00:01:39,369 --> 00:01:41,799
was a transition at some point. You are, were

00:01:41,799 --> 00:01:45,590
a web-developer before, and then you transitioned into becoming

00:01:45,590 --> 00:01:48,490
a gem maintainer, a gem author.

00:01:48,490 --> 00:01:52,030
And before your code was serving people who were

00:01:52,030 --> 00:01:54,450
using a browser and a mouse. So it was

00:01:54,450 --> 00:01:57,280
good enough that your code worked. Didn't really matter

00:01:57,280 --> 00:01:59,310
what you called your variables. If you wanted to

00:01:59,310 --> 00:02:01,229
use curse words, that was fine as well. It

00:02:01,229 --> 00:02:04,270
was sort of funny. But now it's not the

00:02:04,270 --> 00:02:08,280
same thing. Your code, now, serves other developers. It

00:02:08,280 --> 00:02:11,689
serves other people who are looking to your gem

00:02:11,689 --> 00:02:14,250
to provide some kind of functionality in their own

00:02:14,250 --> 00:02:15,510
applications.

00:02:15,510 --> 00:02:19,140
And these other developers are your future self, your

00:02:19,140 --> 00:02:24,170
future colleagues, your current colleagues, opensource users. Regardless of

00:02:24,170 --> 00:02:26,590
whether you're gem author inside a company, and the

00:02:26,590 --> 00:02:29,170
gem you're working on is proprietary, or it's an

00:02:29,170 --> 00:02:32,230
opensource gem, the things you need to think about

00:02:32,230 --> 00:02:34,540
are the same. And they're not quite the same

00:02:34,540 --> 00:02:36,959
things you need to think about as a web

00:02:36,959 --> 00:02:37,450
developer.

00:02:37,450 --> 00:02:40,300
So my personal story is that, I was a

00:02:40,300 --> 00:02:43,060
Rails developer about two years ago, and we had

00:02:43,060 --> 00:02:46,450
this, this web application that was serving up pages

00:02:46,450 --> 00:02:49,930
to customers, they were buying things on our site.

00:02:49,930 --> 00:02:53,510
But this Rails application was also serving us internally.

00:02:53,510 --> 00:02:57,910
It was helping our third party vendors print things

00:02:57,910 --> 00:03:00,500
and move them around. It was helping us to

00:03:00,500 --> 00:03:03,560
run analytics on user behavior. It was helping us

00:03:03,560 --> 00:03:07,940
run analytics on financial data. It was helping us

00:03:07,940 --> 00:03:10,950
manage inventory. It was doing all of these things,

00:03:10,950 --> 00:03:12,520
all in one application.

00:03:12,520 --> 00:03:15,629
And it was super complex and just really horrible

00:03:15,629 --> 00:03:19,310
to maintain. So, as I said, like along with

00:03:19,310 --> 00:03:20,819
a lot of you, I'm sure, we split it

00:03:20,819 --> 00:03:24,110
up into two different applications, and we created a

00:03:24,110 --> 00:03:26,030
gem that had all of the business logic, all

00:03:26,030 --> 00:03:28,250
of the data models in one place. And then

00:03:28,250 --> 00:03:31,170
we maintained it amongst ourselves and managed dependencies and

00:03:31,170 --> 00:03:33,300
versioning and all of that.

00:03:33,300 --> 00:03:36,110
And the other transition that I went through was

00:03:36,110 --> 00:03:38,099
that as I moved on from being a Rails

00:03:38,099 --> 00:03:41,220
developer to working at MongoDB where I now co-maintain

00:03:41,220 --> 00:03:44,849
these, this Mongo in JSON gem, I realized that

00:03:44,849 --> 00:03:47,110
it's not quite the same thing, in the same

00:03:47,110 --> 00:03:49,300
way that it wasn't quite the same thing maintaining

00:03:49,300 --> 00:03:51,709
this gem at the, at my past company.

00:03:51,709 --> 00:03:54,269
I need to think about users. I need to

00:03:54,269 --> 00:03:57,819
think about other developers, like myself, using my code.

00:03:57,819 --> 00:04:02,349
This is a gem, a quote from someone commenting

00:04:02,349 --> 00:04:04,379
on a gem, that a lot of people use.

00:04:04,379 --> 00:04:06,010
It's really popular. I didn't want to put the

00:04:06,010 --> 00:04:08,440
gem on the spot and say it sucks, but

00:04:08,440 --> 00:04:10,959
the point here is that this gem is used

00:04:10,959 --> 00:04:13,330
by, I'm sure, the majority of people in this

00:04:13,330 --> 00:04:16,900
room, and someone said, I love the contribution to

00:04:16,900 --> 00:04:20,250
opensource. But it's not very obvious what's going on

00:04:20,250 --> 00:04:22,270
when I look at the code. It's an example

00:04:22,270 --> 00:04:26,940
of poor OOP design, poor documentation. It's sort of

00:04:26,940 --> 00:04:28,490
a black box. It seems like there's a lot

00:04:28,490 --> 00:04:31,060
of magic. I don't really know what's going on.

00:04:31,060 --> 00:04:33,889
But as I said, I appreciate the contribution to

00:04:33,889 --> 00:04:37,550
opensource. So people will appreciate your contribution. But if

00:04:37,550 --> 00:04:39,300
you want your gem to be used, if you

00:04:39,300 --> 00:04:41,610
want people to contribute to your gem, if you

00:04:41,610 --> 00:04:44,360
want it to be this living, breathing thing that,

00:04:44,360 --> 00:04:46,419
that people like and use, you need to think

00:04:46,419 --> 00:04:49,349
about something beyond just, does my code work, do

00:04:49,349 --> 00:04:50,610
my tests pass.

00:04:50,610 --> 00:04:53,749
So gem API design is UX design. Is user

00:04:53,749 --> 00:04:57,129
experience design - it's about users. And that's the

00:04:57,129 --> 00:05:01,979
fundamental difference between writing a web application and maintaining

00:05:01,979 --> 00:05:04,999
a library that other people use.

00:05:04,999 --> 00:05:07,039
So why is it important to think about things

00:05:07,039 --> 00:05:11,849
as user experience tasks? Or why is user experience

00:05:11,849 --> 00:05:12,069
important?

00:05:12,069 --> 00:05:15,089
So there was something called a UX Fund experiment

00:05:15,089 --> 00:05:19,629
that was run in 2006 to 2007 by a

00:05:19,629 --> 00:05:23,539
design firm in Toronto. And what they did was

00:05:23,539 --> 00:05:25,839
they decided, they made up a list of ten

00:05:25,839 --> 00:05:28,990
companies that they deemed to have superior user experiences.

00:05:28,990 --> 00:05:32,839
These are companies like Google, Apple, JetFlew - all

00:05:32,839 --> 00:05:34,939
of the, the companies that you probably think of

00:05:34,939 --> 00:05:37,349
when you think of a great user experience.

00:05:37,349 --> 00:05:39,680
And what they did was, they wanted to prove

00:05:39,680 --> 00:05:43,080
a theory that they had, that great user experience

00:05:43,080 --> 00:05:46,770
is directly reflected in stock prices, or directly reflected

00:05:46,770 --> 00:05:47,919
in revenue and profit.

00:05:47,919 --> 00:05:50,289
So what they did was, was they invested fifty

00:05:50,289 --> 00:05:52,619
thousand dollars in each one of these, or, not

00:05:52,619 --> 00:05:55,330
each one, but, in all of these companies. And

00:05:55,330 --> 00:05:57,789
watched over a year each one of those companies

00:05:57,789 --> 00:05:59,710
stock price go up.

00:05:59,710 --> 00:06:02,779
And they concluded that great user experience is directly

00:06:02,779 --> 00:06:05,629
reflected in stock price. So they proved their theory.

00:06:05,629 --> 00:06:08,999
Now, we as Rubyists don't have a stock market.

00:06:08,999 --> 00:06:11,309
We're not talking about money. But we do have

00:06:11,309 --> 00:06:15,809
the community and we do have RubyGems. We have

00:06:15,809 --> 00:06:17,529
different libraries that we can choose from when we

00:06:17,529 --> 00:06:20,259
want to do certain things. We have numbers and

00:06:20,259 --> 00:06:23,819
metrics. We have people maintaining these projects. We have

00:06:23,819 --> 00:06:26,649
a number of ways that we can determine whether

00:06:26,649 --> 00:06:28,869
or not a gem is successful or not.

00:06:28,869 --> 00:06:32,369
So one example is RSpec. RSpec became really popular

00:06:32,369 --> 00:06:36,309
because it had a great UI. Another example is,

00:06:36,309 --> 00:06:40,939
I can never say this, HTTParty. Was a, is

00:06:40,939 --> 00:06:43,159
another example of a gem that was doing something

00:06:43,159 --> 00:06:45,929
similar to what some other gems did, but it

00:06:45,929 --> 00:06:48,710
sort of became popular because the UI, the user

00:06:48,710 --> 00:06:51,259
experience was superior to some of the others.

00:06:51,259 --> 00:06:54,389
So user experience is extremely important as you're building

00:06:54,389 --> 00:06:55,210
a gem.

00:06:55,210 --> 00:07:01,379
And even beyond that, at MongoDB, arguably, MongoDB became

00:07:01,379 --> 00:07:04,749
really popular really quickly, because we really focused on

00:07:04,749 --> 00:07:07,929
the, the developer experience. And it's known for this

00:07:07,929 --> 00:07:11,149
great user experience. We still focus on this, even

00:07:11,149 --> 00:07:13,740
as we grow.

00:07:13,740 --> 00:07:16,149
I'm on a team called the Driver's Team. We're

00:07:16,149 --> 00:07:19,689
about twenty-two people, and we support, officially, twelve different

00:07:19,689 --> 00:07:21,990
languages. And on this Driver's Team, I'm on a

00:07:21,990 --> 00:07:24,919
bigger team called the Developer Experience team that consists

00:07:24,919 --> 00:07:29,399
of docs, tools, and some other things.

00:07:29,399 --> 00:07:31,809
And it is our focus, on this team, to

00:07:31,809 --> 00:07:34,379
make sure that no matter what product you're using

00:07:34,379 --> 00:07:37,330
or what interface, entry point you have to using

00:07:37,330 --> 00:07:41,869
MongoDB, it's consistent across each one of those products.

00:07:41,869 --> 00:07:46,240
And, and we've found that, like, MongoDB, like, everybody

00:07:46,240 --> 00:07:50,209
knows what MongoDB is. And it's been, it's become

00:07:50,209 --> 00:07:53,339
so, like, popular just because we've really focused on

00:07:53,339 --> 00:07:55,139
the community in this way.

00:07:55,139 --> 00:07:57,999
Another good example of how we focus on developer

00:07:57,999 --> 00:08:01,869
experience is the shell. So for those of you

00:08:01,869 --> 00:08:04,189
who have used the MongoDB shell, what language do

00:08:04,189 --> 00:08:05,580
you use in the shell?

00:08:05,580 --> 00:08:10,409
JavaScript, right? So JavaScript is a great entry point,

00:08:10,409 --> 00:08:14,050
or a great way to allow developers to interact

00:08:14,050 --> 00:08:16,779
with the database, because many of us are familiar

00:08:16,779 --> 00:08:18,979
with JavaScript. And so this is one way that

00:08:18,979 --> 00:08:21,169
we are able to get so many users so

00:08:21,169 --> 00:08:21,929
quickly.

00:08:21,929 --> 00:08:25,749
So more specifically, gem API design is UX design.

00:08:25,749 --> 00:08:27,809
So how is it UX design? Let's talk about

00:08:27,809 --> 00:08:30,209
some UX design concepts. User experience concepts.

00:08:30,209 --> 00:08:33,919
Well, first of all, obviously, you have users, right.

00:08:33,919 --> 00:08:35,260
So what do you do with your users? You're

00:08:35,260 --> 00:08:38,089
not coding in a vacuum. You have users who

00:08:38,089 --> 00:08:39,979
are consuming your code. How do you think about

00:08:39,979 --> 00:08:41,339
your users?

00:08:41,339 --> 00:08:43,909
Well, one thing is that you should really know

00:08:43,909 --> 00:08:46,399
your users. Who are these users? As I said,

00:08:46,399 --> 00:08:49,319
they could be opensource users. They could be your

00:08:49,319 --> 00:08:52,220
future colleagues, your future self, your current colleagues. Who

00:08:52,220 --> 00:08:54,139
are these users and how are they going to

00:08:54,139 --> 00:08:55,410
use their gem - your gem?

00:08:55,410 --> 00:08:58,870
How do you want them to use your gem?

00:08:58,870 --> 00:09:00,720
You need to listen in. So how do you

00:09:00,720 --> 00:09:03,350
listen in? There's so many channels through which you

00:09:03,350 --> 00:09:05,610
can find out how people are using the Ruby

00:09:05,610 --> 00:09:07,550
language, and what projects people are building - what

00:09:07,550 --> 00:09:10,750
needs they have and how your gem can fulfill

00:09:10,750 --> 00:09:11,970
those needs.

00:09:11,970 --> 00:09:16,699
Read blogs. Use Twitter. Talk to users. Give presentations.

00:09:16,699 --> 00:09:19,329
I come to a lot of conferences. I do

00:09:19,329 --> 00:09:22,190
really enjoy giving presentations. But I also really like

00:09:22,190 --> 00:09:26,100
just listening to conversations. And watching other presentations, listening

00:09:26,100 --> 00:09:28,250
to what you guys don't like, what you do

00:09:28,250 --> 00:09:31,459
like. How are you using the language, what, what's

00:09:31,459 --> 00:09:33,339
the future of Ruby and what do people see

00:09:33,339 --> 00:09:36,120
themselves doing with the language in the future?

00:09:36,120 --> 00:09:39,779
This is extremely important input, as you maintain a

00:09:39,779 --> 00:09:42,740
gem. Get to know your users. They're people.

00:09:42,740 --> 00:09:45,560
And, as you get to know your users and

00:09:45,560 --> 00:09:47,550
you build this gem, you want to establish trust

00:09:47,550 --> 00:09:49,839
with them. So what does that mean?

00:09:49,839 --> 00:09:53,170
If they're relying on your gem in their application,

00:09:53,170 --> 00:09:55,740
you want to make sure that changes you make

00:09:55,740 --> 00:09:57,980
to the software they depend on is not going

00:09:57,980 --> 00:10:00,420
to break their code. That seems sort of obvious,

00:10:00,420 --> 00:10:03,079
right. But we have this set of principles called

00:10:03,079 --> 00:10:07,350
semantic versioning that we all preach, and we say

00:10:07,350 --> 00:10:09,750
that we stick by, but I can't emphasize enough

00:10:09,750 --> 00:10:11,360
how important this is.

00:10:11,360 --> 00:10:14,230
So we had an experience once where we were

00:10:14,230 --> 00:10:17,579
exposing something, and we didn't mean to expose. And

00:10:17,579 --> 00:10:19,439
someone had sort of started to use it. It

00:10:19,439 --> 00:10:21,269
was supposed to be private but it wasn't marked

00:10:21,269 --> 00:10:23,560
as private. And then we had changed it in

00:10:23,560 --> 00:10:26,019
a patched version and it broke in their code.

00:10:26,019 --> 00:10:28,189
And it didn't go over so well. We didn't

00:10:28,189 --> 00:10:31,560
intentionally do that, but the user was disappointed in

00:10:31,560 --> 00:10:35,529
the gem, disappointed in us, because the, we had

00:10:35,529 --> 00:10:38,019
broken this contract and this trust we had with

00:10:38,019 --> 00:10:38,600
the user.

00:10:38,600 --> 00:10:40,720
Extremely important.

00:10:40,720 --> 00:10:42,620
The other way that you can get to know

00:10:42,620 --> 00:10:44,519
your users, and have this sort of open communication

00:10:44,519 --> 00:10:48,149
with your users, is identifying star users, or super

00:10:48,149 --> 00:10:52,310
users, and maintain an open communication channel with them.

00:10:52,310 --> 00:10:56,649
So for example, a couple weeks ago, well, so,

00:10:56,649 --> 00:10:59,290
at MongoDB, the Ruby team is building a new

00:10:59,290 --> 00:11:01,170
driver. We call it Ruby 2 point 0. And

00:11:01,170 --> 00:11:02,939
we're trying, so the driver is like pretty old.

00:11:02,939 --> 00:11:05,589
It's a couple years old. And we want to

00:11:05,589 --> 00:11:08,089
rebuild it and use an architecture that's more consistent

00:11:08,089 --> 00:11:11,410
across some of the other drivers at MongoDB.

00:11:11,410 --> 00:11:14,949
And we have some customers who are very active

00:11:14,949 --> 00:11:16,649
and like to give us a lot of feedback,

00:11:16,649 --> 00:11:20,879
either positive or negative. And so we were, this

00:11:20,879 --> 00:11:24,160
one customer, a couple weeks ago, had asked for

00:11:24,160 --> 00:11:27,639
a specific time mount on a socket. And we

00:11:27,639 --> 00:11:30,069
didn't provide this specific timeout. And so we were

00:11:30,069 --> 00:11:31,750
talking about this, we were trying to decide whether

00:11:31,750 --> 00:11:34,220
or not this was something we should support. But

00:11:34,220 --> 00:11:38,319
after this whole conversation was concluded, I said, actually,

00:11:38,319 --> 00:11:40,660
you know what, like, in Ruby Driver 2 point

00:11:40,660 --> 00:11:42,730
0, what do you want? What kind of timeouts

00:11:42,730 --> 00:11:44,100
do you want to see in the driver?

00:11:44,100 --> 00:11:46,269
And then we just had this discussion about what

00:11:46,269 --> 00:11:47,810
he would want. So you don't have to pull

00:11:47,810 --> 00:11:51,810
like twenty thousand people or, like, you know, hundreds

00:11:51,810 --> 00:11:54,870
of users, but if you just ask a couple,

00:11:54,870 --> 00:11:58,370
you'll find that even with three user feedback, or

00:11:58,370 --> 00:12:01,089
like, five users even, you'll have a pretty good

00:12:01,089 --> 00:12:02,759
idea of what users want.

00:12:02,759 --> 00:12:05,399
So make sure you, like, really keep- maybe, like,

00:12:05,399 --> 00:12:08,220
identify, like, three particular people who are willing to

00:12:08,220 --> 00:12:12,209
test out your gem in a test environment, or

00:12:12,209 --> 00:12:14,639
your RCs, and just give you feedback as you

00:12:14,639 --> 00:12:16,689
develop and as you release.

00:12:16,689 --> 00:12:20,819
Which I, I skipped this, but releases also. Like,

00:12:20,819 --> 00:12:22,850
make sure you stick to that in your semantic

00:12:22,850 --> 00:12:25,529
versioning. Like, if you're going to add features and

00:12:25,529 --> 00:12:28,329
you, you've released an RC one, don't continue adding

00:12:28,329 --> 00:12:31,149
features in RC two. Like, stick to that really

00:12:31,149 --> 00:12:33,019
well as well. It doesn't just go for breaking

00:12:33,019 --> 00:12:34,029
peoples' code.

00:12:34,029 --> 00:12:38,410
OK, so that's users. So obviously user experience involves

00:12:38,410 --> 00:12:42,600
users. Get to know your users. Identify star users.

00:12:42,600 --> 00:12:46,160
The second thing is concepts. So we have a

00:12:46,160 --> 00:12:50,149
number of user experience concepts that, I'm not a

00:12:50,149 --> 00:12:52,129
user experience expert, but there are a couple of

00:12:52,129 --> 00:12:55,069
them that do apply to gem API design and

00:12:55,069 --> 00:12:58,109
development. So we're gonna focus on three of them

00:12:58,109 --> 00:13:01,779
- consistency, simplicity, and mapping.

00:13:01,779 --> 00:13:06,499
Consistency is what you might think of as maybe,

00:13:06,499 --> 00:13:09,439
like, a symbol in your system or an interface

00:13:09,439 --> 00:13:12,519
element that a user interacts with that has a

00:13:12,519 --> 00:13:15,629
specific effect on the system. And every time you

00:13:15,629 --> 00:13:19,379
show that symbol, or provide that thing, that interface

00:13:19,379 --> 00:13:21,089
component, to a user, you want to make sure

00:13:21,089 --> 00:13:24,339
it has a similar or parallel effect, if not

00:13:24,339 --> 00:13:25,870
the same effect on the system.

00:13:25,870 --> 00:13:28,120
So a great example of this is button colors.

00:13:28,120 --> 00:13:30,810
So we all know that red buttons mean danger

00:13:30,810 --> 00:13:35,769
or cancel. Blue buttons mean information. Greyed out buttons

00:13:35,769 --> 00:13:39,300
mean something not important or defaults. And green buttons

00:13:39,300 --> 00:13:41,709
mean success. And every time you see these buttons

00:13:41,709 --> 00:13:44,189
everywhere, you probably don't even read them. You just

00:13:44,189 --> 00:13:46,730
look at the color. And that's because these interfaces

00:13:46,730 --> 00:13:47,939
are consistent.

00:13:47,939 --> 00:13:50,279
We recognize these symbols and we know what's go-

00:13:50,279 --> 00:13:52,930
what they mean.

00:13:52,930 --> 00:13:58,040
Another interface component, or user experience concept, is simplicity.

00:13:58,040 --> 00:14:03,249
Simplicity is not exposing implementation details or too much

00:14:03,249 --> 00:14:07,559
information to a user. You, as the gem designer,

00:14:07,559 --> 00:14:10,100
and the gem developer, know way more than the

00:14:10,100 --> 00:14:13,350
user. And the user doesn't need to know everything

00:14:13,350 --> 00:14:15,779
you know. You only want to expose the user

00:14:15,779 --> 00:14:18,430
what concerns them and what concerns their code.

00:14:18,430 --> 00:14:22,120
So this, this is, especially relevant at MongoDB, as

00:14:22,120 --> 00:14:24,639
we developer the driver. There are so many little

00:14:24,639 --> 00:14:27,019
things that we know about the server that the

00:14:27,019 --> 00:14:29,420
user doesn't need to know about. The user- we

00:14:29,420 --> 00:14:31,189
need to focus on the, the little things, the

00:14:31,189 --> 00:14:34,410
little knobs that the user can actually play with,

00:14:34,410 --> 00:14:36,970
and that would have an effect on their own

00:14:36,970 --> 00:14:39,410
code or their own understanding what's going on.

00:14:39,410 --> 00:14:42,339
That's, it's actually really difficult to divine- to design

00:14:42,339 --> 00:14:45,860
something super simple to someone who only needs to

00:14:45,860 --> 00:14:49,769
know a certain amount of what you know.

00:14:49,769 --> 00:14:53,379
And mapping. So mapping is the, the last concept

00:14:53,379 --> 00:14:58,110
that I'm going to show through user, user experience

00:14:58,110 --> 00:15:01,990
design for gem APIs. This example, I think, is

00:15:01,990 --> 00:15:06,199
really great. Mapping is where you have interface components

00:15:06,199 --> 00:15:08,959
that have effects on the system, and it's obvious

00:15:08,959 --> 00:15:11,600
what effect it has based on how you interact

00:15:11,600 --> 00:15:13,309
with the interface.

00:15:13,309 --> 00:15:15,600
And the state of the system is really obvious

00:15:15,600 --> 00:15:17,980
to the user after the user makes them change.

00:15:17,980 --> 00:15:21,680
So a great example here is a stove. So

00:15:21,680 --> 00:15:25,319
there's both a bad example and a good example.

00:15:25,319 --> 00:15:27,670
The top example shows a number of burners on

00:15:27,670 --> 00:15:30,180
a stove and they're arranged in some fashion, and

00:15:30,180 --> 00:15:32,480
then you have all these knobs that manipulate these

00:15:32,480 --> 00:15:34,600
burners, but the knows are in a row. So

00:15:34,600 --> 00:15:37,670
it's not obvious to a user which knob goes

00:15:37,670 --> 00:15:40,899
to which burner. And then the stove on the

00:15:40,899 --> 00:15:45,589
bottom shows a layout of burners and then knobs

00:15:45,589 --> 00:15:47,399
that are in the same exact layout.

00:15:47,399 --> 00:15:50,160
So there's a really good mapping here. This knob

00:15:50,160 --> 00:15:52,259
has an effect on this burner, because I can

00:15:52,259 --> 00:15:55,269
make an association between where it's placed in the

00:15:55,269 --> 00:15:58,670
mini mapping and the greater mapping. And then it's

00:15:58,670 --> 00:16:00,540
really obvious to me when a burner turns on

00:16:00,540 --> 00:16:03,170
that this state has changed and what effect that

00:16:03,170 --> 00:16:04,939
knob has had on the system.

00:16:04,939 --> 00:16:08,850
OK. So consistency, simplicity, and mapping. How does this

00:16:08,850 --> 00:16:11,100
relate to gem API design? What do you need

00:16:11,100 --> 00:16:15,119
to consider as you maintain or develop a new

00:16:15,119 --> 00:16:15,649
gem?

00:16:15,649 --> 00:16:19,399
We're going to talk about three consistency considerations, four

00:16:19,399 --> 00:16:23,220
simplicity suggestions, and five mapping mantras, and look at

00:16:23,220 --> 00:16:28,759
examples using the MongoDB Ruby driver to see how,

00:16:28,759 --> 00:16:30,610
over the course of the last year and a

00:16:30,610 --> 00:16:34,209
half, we've changed some features and developed the API

00:16:34,209 --> 00:16:37,899
to adhere to some of these user experience concepts.

00:16:37,899 --> 00:16:40,209
Three consistency considerations.

00:16:40,209 --> 00:16:44,829
Consider consistent naming. This might seem super obvious, but

00:16:44,829 --> 00:16:47,529
as I said before, variables are really important. People

00:16:47,529 --> 00:16:49,660
are going to look at your code and want

00:16:49,660 --> 00:16:52,059
to understand just by looking at it what's going

00:16:52,059 --> 00:16:52,930
on.

00:16:52,930 --> 00:16:58,059
Use consistent variable names across classes. Use consistent module

00:16:58,059 --> 00:17:02,529
names. Use consistent method names. Use consistent ops names,

00:17:02,529 --> 00:17:05,860
like option names. If you have a class that's

00:17:05,860 --> 00:17:09,439
called something, and then you create an instance of

00:17:09,439 --> 00:17:11,390
it in some other class and refer to it,

00:17:11,390 --> 00:17:13,199
refer to it by the same name, or refer

00:17:13,199 --> 00:17:15,240
to it as some name that evokes what that

00:17:15,240 --> 00:17:18,760
thing is. Don't, don't get too creative with your

00:17:18,760 --> 00:17:20,720
variable names. You want your code to be as

00:17:20,720 --> 00:17:24,209
clear as possible, and consistent.

00:17:24,209 --> 00:17:28,679
Consider consistent style. So there are a number of

00:17:28,679 --> 00:17:31,649
things - someone gave a talk this morning about

00:17:31,649 --> 00:17:34,220
winters and ways that you can run your code

00:17:34,220 --> 00:17:38,600
through some sanitization cross-use to figure out if your

00:17:38,600 --> 00:17:41,500
code is consistent in style. We, on the Ruby

00:17:41,500 --> 00:17:43,480
driver 2 point 0, have chosen to Rubucop. There

00:17:43,480 --> 00:17:45,770
are a number of other ones out there.

00:17:45,770 --> 00:17:49,370
This goes for spacing in hashes. This goes for

00:17:49,370 --> 00:17:53,190
method length. This goes for how you're doing argument

00:17:53,190 --> 00:17:57,460
chaining. There are a number of configurations you can

00:17:57,460 --> 00:17:59,659
do with RubuCop. But the reason we do this

00:17:59,659 --> 00:18:02,100
is so that amongst our team, which is fairly

00:18:02,100 --> 00:18:04,620
small in number, but amongst our team we have

00:18:04,620 --> 00:18:07,669
a consistent style, as well as when people want

00:18:07,669 --> 00:18:10,029
to make a contribution to our gem, they have

00:18:10,029 --> 00:18:12,020
the same style as us.

00:18:12,020 --> 00:18:13,320
And we want to make sure that over the

00:18:13,320 --> 00:18:17,260
course of time, this style stays in tact, and

00:18:17,260 --> 00:18:19,860
consistent, so you don't have these, these sort of,

00:18:19,860 --> 00:18:23,020
like, bits of your code that, like, really exude

00:18:23,020 --> 00:18:24,789
one personality over another. You want to keep it

00:18:24,789 --> 00:18:28,830
as consistent and smooth as possible across all elements

00:18:28,830 --> 00:18:30,350
of your code base.

00:18:30,350 --> 00:18:35,600
The third thing with consistency is consider consistent behavior.

00:18:35,600 --> 00:18:37,510
I think a good example of this is how

00:18:37,510 --> 00:18:39,820
you raise warnings and exceptions, or how you alert

00:18:39,820 --> 00:18:41,909
the user about something. So there are a number

00:18:41,909 --> 00:18:45,299
of behaviors that you can think about to keep

00:18:45,299 --> 00:18:47,490
consistent, but in this case, I can think of

00:18:47,490 --> 00:18:50,419
a particular example a couple weeks ago, where we

00:18:50,419 --> 00:18:53,700
have, you can do a map produce in your

00:18:53,700 --> 00:18:56,090
replica set in MongoDB. And you can choose a

00:18:56,090 --> 00:18:58,380
particular node in that replica set to do that

00:18:58,380 --> 00:18:59,960
map reduce on.

00:18:59,960 --> 00:19:02,140
You can't do, under some conditions, you can't do

00:19:02,140 --> 00:19:04,390
your map produce on the secondary, but if you

00:19:04,390 --> 00:19:07,080
say to do it on the secondary, in the

00:19:07,080 --> 00:19:09,789
past, we would just raise an exception, say hey,

00:19:09,789 --> 00:19:12,730
you can't do it on a secondary, choose, a

00:19:12,730 --> 00:19:14,740
- we call it re-preference - choose a re-preference

00:19:14,740 --> 00:19:16,130
of primary.

00:19:16,130 --> 00:19:18,070
And then we were doing something else, an aggregation

00:19:18,070 --> 00:19:19,980
framework, which is similar to map reduce, and then

00:19:19,980 --> 00:19:22,740
you can choose a secondary there. And it had

00:19:22,740 --> 00:19:25,390
a similar problem to map reduce. And then we

00:19:25,390 --> 00:19:28,090
realized, according to spec, that we needed to actually,

00:19:28,090 --> 00:19:31,919
behind the scenes, reroute the query to the primary.

00:19:31,919 --> 00:19:31,990
And then we were like, wait a minute, this

00:19:31,990 --> 00:19:34,730
is not consistent style. We can't raise an exception

00:19:34,730 --> 00:19:37,510
for one case, and then something very similar just

00:19:37,510 --> 00:19:39,830
raises a warning, or do something sort of behind

00:19:39,830 --> 00:19:41,350
the scenes that the user's not aware of and

00:19:41,350 --> 00:19:43,360
may be surprised later on when they find this

00:19:43,360 --> 00:19:46,070
job's running on a node they didn't expect.

00:19:46,070 --> 00:19:48,830
But the point here is not that, whether or

00:19:48,830 --> 00:19:50,950
not you're warning the user or raised an exception,

00:19:50,950 --> 00:19:53,159
it's just that you need to be consistent with

00:19:53,159 --> 00:19:55,380
the behavior of your gem and how the user

00:19:55,380 --> 00:19:56,850
interacts with it.

00:19:56,850 --> 00:20:01,029
So those are consistency considerations.

00:20:01,029 --> 00:20:04,110
Simplicity suggestions. So as I said, simplicity, remember, it's

00:20:04,110 --> 00:20:08,179
not giving the user over-exposing implementation details to the

00:20:08,179 --> 00:20:11,590
user. It's giving the user access to certain interface

00:20:11,590 --> 00:20:13,899
components that are relevant to the user and the

00:20:13,899 --> 00:20:14,840
user's code.

00:20:14,840 --> 00:20:18,600
So first - give classes a single responsibility. We

00:20:18,600 --> 00:20:21,690
hear this all the time. I think it pretty

00:20:21,690 --> 00:20:23,649
much speaks for itself, but to give you a

00:20:23,649 --> 00:20:26,549
concrete example in Ruby driver 2 point 0, I

00:20:26,549 --> 00:20:29,830
don't know about you but client, cluster, collection, cursor,

00:20:29,830 --> 00:20:32,720
database, errors, node - it's super clear to me

00:20:32,720 --> 00:20:35,000
what each one of those classes does, what their

00:20:35,000 --> 00:20:39,440
functions are, and how they interact with each other.

00:20:39,440 --> 00:20:41,570
You want to stick to this, cause when people

00:20:41,570 --> 00:20:43,100
open up your gem, they start looking at the

00:20:43,100 --> 00:20:44,980
source code, you want them to be able to

00:20:44,980 --> 00:20:46,980
know where to go to lear- to look for

00:20:46,980 --> 00:20:50,149
certain functions, and they want to know how things

00:20:50,149 --> 00:20:51,659
sort of work together. And it gives them an

00:20:51,659 --> 00:20:53,370
idea of the architecture as well.

00:20:53,370 --> 00:20:55,860
It's, it's really clear, and there's a lot of

00:20:55,860 --> 00:20:59,960
transparency, when you keep classes having a single responsibility.

00:20:59,960 --> 00:21:03,760
Another example is, I was refactoring some code recently,

00:21:03,760 --> 00:21:06,440
and, along the lines of read preferences, which I

00:21:06,440 --> 00:21:08,470
mentioned before, which is where you choose a particular

00:21:08,470 --> 00:21:10,850
node to do a certain operation in your replica

00:21:10,850 --> 00:21:14,340
set, I realized that, actually, I was refactoring the

00:21:14,340 --> 00:21:16,720
code having to do with the, the map reduce

00:21:16,720 --> 00:21:18,740
problem, and I was looking for the code that

00:21:18,740 --> 00:21:20,539
could determine if you could do something on a

00:21:20,539 --> 00:21:23,289
secondary, and I found some code - we had

00:21:23,289 --> 00:21:25,840
this re-preferences module where if, but I found some

00:21:25,840 --> 00:21:29,899
relevant code in a utils module as well.

00:21:29,899 --> 00:21:32,940
So, single responsibility doesn't just go for classes. It

00:21:32,940 --> 00:21:35,539
goes for modules, also. People are going to look

00:21:35,539 --> 00:21:38,390
for specific functions in specific modules, and you need

00:21:38,390 --> 00:21:40,909
to make sure that that's centralized and clear as

00:21:40,909 --> 00:21:41,320
possible.

00:21:41,320 --> 00:21:44,450
This wasn't necessarily bad design, it was just a,

00:21:44,450 --> 00:21:47,010
just a, an oversight when we were refactoring at

00:21:47,010 --> 00:21:50,120
some point and extracting some code out into a

00:21:50,120 --> 00:21:52,120
read-preferences module. So it made more sense to put

00:21:52,120 --> 00:21:55,149
this code all in one place called read_preferences, because

00:21:55,149 --> 00:21:57,340
as a user, when I look at the code

00:21:57,340 --> 00:21:59,470
base, I will look at a read_preferences module for

00:21:59,470 --> 00:22:01,760
all the logic having to do with read_preferences.

00:22:01,760 --> 00:22:06,700
Second thing - hide implementation details. This goes along

00:22:06,700 --> 00:22:09,750
the same lines. Don't expose all of your knowledge

00:22:09,750 --> 00:22:12,799
to the user. The user doesn't need to know

00:22:12,799 --> 00:22:14,760
all of the knowledge. Only give them access to

00:22:14,760 --> 00:22:18,549
certain things that are relevant to them.

00:22:18,549 --> 00:22:22,870
So use the protected keyword private. Only expose things

00:22:22,870 --> 00:22:25,279
to your user that they should be interacting with.

00:22:25,279 --> 00:22:27,470
I realize, though, that there is going to be

00:22:27,470 --> 00:22:31,110
a public API within your gem itself, and sometimes

00:22:31,110 --> 00:22:35,399
you may unintentionally expose something that the user could

00:22:35,399 --> 00:22:37,340
use, but the user shouldn't be using.

00:22:37,340 --> 00:22:38,970
And this is actually a case in which you

00:22:38,970 --> 00:22:41,950
need to be really careful with your documentation, and

00:22:41,950 --> 00:22:44,789
make sure you say never use this method as

00:22:44,789 --> 00:22:48,679
directly to the user. And only allow your, and

00:22:48,679 --> 00:22:53,659
emphasize that it's an internal public API.

00:22:53,659 --> 00:22:56,640
Be frugal with helpers. You may feel like, in

00:22:56,640 --> 00:22:59,840
the beginning, that an API is really great if

00:22:59,840 --> 00:23:03,059
you abstract everything, and you provide all of these

00:23:03,059 --> 00:23:06,289
different methods to the user that are, that are

00:23:06,289 --> 00:23:09,659
wrapping all these underlying concepts. What you want to

00:23:09,659 --> 00:23:12,620
do, instead, is really think about how the user

00:23:12,620 --> 00:23:14,950
is going to be using your gem, and only

00:23:14,950 --> 00:23:17,200
provide helpers for the things that they will be

00:23:17,200 --> 00:23:17,750
doing.

00:23:17,750 --> 00:23:19,450
So an example of this in the Ruby driver

00:23:19,450 --> 00:23:22,690
is, we have lots of different types of indexes

00:23:22,690 --> 00:23:26,600
in MongoDB. We have geospacial indexes, we have text

00:23:26,600 --> 00:23:31,350
indexes, we have ascending, descending, unique, goes on.

00:23:31,350 --> 00:23:35,059
Instead of providing a helper for each one of

00:23:35,059 --> 00:23:38,580
these different types of indexes in MongoDB, we've chosen

00:23:38,580 --> 00:23:41,429
to keep it simple and say, create_index, and then

00:23:41,429 --> 00:23:43,720
we have a constant corresponding to the string that

00:23:43,720 --> 00:23:47,000
determines which index is which type, and then you

00:23:47,000 --> 00:23:49,260
can just use it as the user.

00:23:49,260 --> 00:23:50,820
Why did we choose to do it this way,

00:23:50,820 --> 00:23:53,370
and not provide a helper for each one?

00:23:53,370 --> 00:23:57,100
Well, I don't think the number of indexes, or

00:23:57,100 --> 00:23:59,450
the types of indexes we have, is going to

00:23:59,450 --> 00:24:01,940
remain the same forever and ever. They are going

00:24:01,940 --> 00:24:04,750
to be indexes added over the course of time.

00:24:04,750 --> 00:24:07,580
We might need to update indexes for backwards compatibility.

00:24:07,580 --> 00:24:09,860
We're just going to have the number of methods

00:24:09,860 --> 00:24:12,120
growing and growing. If we change the name of

00:24:12,120 --> 00:24:14,990
the, the, the string constant of one of the

00:24:14,990 --> 00:24:15,200
indexes.

00:24:15,200 --> 00:24:18,010
This is where something really simple, like create_index, and

00:24:18,010 --> 00:24:20,139
then you just do something like that, that's simple

00:24:20,139 --> 00:24:22,480
enough for a user. You don't need to over

00:24:22,480 --> 00:24:27,460
abstract everything and provide helpers where it's not necessary.

00:24:27,460 --> 00:24:28,889
And the other thing is, this is a great

00:24:28,889 --> 00:24:33,159
exercise. Design your API first. Pretend you're the user.

00:24:33,159 --> 00:24:35,799
Build a little app. And actually write some lines

00:24:35,799 --> 00:24:38,559
where you're using the gem that you're building. And

00:24:38,559 --> 00:24:40,570
then do the implementation later on.

00:24:40,570 --> 00:24:43,419
So at MongoDB, we as at the Driver's Team,

00:24:43,419 --> 00:24:45,940
as I said, we're twelve different languages, and we,

00:24:45,940 --> 00:24:48,620
we talk amongst ourselves all the time, regardless of

00:24:48,620 --> 00:24:51,990
whether it's Java or Scala or Python, Ruby, Perl,

00:24:51,990 --> 00:24:54,389
or PHP, we couldn't be any different in terms

00:24:54,389 --> 00:24:57,899
of what languages we use on a daily basis,

00:24:57,899 --> 00:25:00,710
but we all talk amongst ourselves and try to

00:25:00,710 --> 00:25:03,500
make sure that this user experience at MongoDB is

00:25:03,500 --> 00:25:07,510
consistent and that the API between all these drivers

00:25:07,510 --> 00:25:09,380
is as consistent as possible.

00:25:09,380 --> 00:25:11,909
So we have this initiative to try to take

00:25:11,909 --> 00:25:14,750
some of the, the commands that you can run

00:25:14,750 --> 00:25:18,500
in MongoDB that are potentially really confusing or overly

00:25:18,500 --> 00:25:21,690
complex and not super transparent to a user, and

00:25:21,690 --> 00:25:24,610
try to build these helpers around them that, in

00:25:24,610 --> 00:25:27,470
one, in reading, just even the name of this

00:25:27,470 --> 00:25:30,970
helper, it is immediately apparent to the user what

00:25:30,970 --> 00:25:32,010
that thing does.

00:25:32,010 --> 00:25:37,210
So for example, we have a command called find_and_modify.

00:25:37,210 --> 00:25:39,380
I only put three parameters here, or options here,

00:25:39,380 --> 00:25:44,340
and there are actually seven, and so, for example,

00:25:44,340 --> 00:25:46,730
new => true, what does that mean? That means

00:25:46,730 --> 00:25:48,960
that when you, when you do a find_and_modify, it

00:25:48,960 --> 00:25:51,289
will do a find and get a certain number

00:25:51,289 --> 00:25:54,159
of results, choose one of those results to either

00:25:54,159 --> 00:25:57,139
remove, manipulate, or do an upstart - there are

00:25:57,139 --> 00:25:58,419
a bunch of things that you can do. New

00:25:58,419 --> 00:26:01,179
=> true means return the document after it has

00:26:01,179 --> 00:26:03,820
been modified or created or removed.

00:26:03,820 --> 00:26:05,519
You can do new => false, which obviously will

00:26:05,519 --> 00:26:09,500
return the document before it has been modified, removed,

00:26:09,500 --> 00:26:12,539
or upstarted.

00:26:12,539 --> 00:26:14,710
And so in this case, like, as I said,

00:26:14,710 --> 00:26:17,159
there are seven options you can pass to find_and_modify.

00:26:17,159 --> 00:26:19,330
So it's not, it doesn't really make a lot

00:26:19,330 --> 00:26:22,490
of sense to force the user to use this

00:26:22,490 --> 00:26:24,429
command, and then go consult the documentation, maybe on

00:26:24,429 --> 00:26:27,070
MongoDB's site where it lists out all the intricacies

00:26:27,070 --> 00:26:29,990
of each one of these parameters. It's much easier

00:26:29,990 --> 00:26:33,070
and much better experience for the user to provide

00:26:33,070 --> 00:26:34,000
something like update_one_then_get.

00:26:34,000 --> 00:26:36,669
It's, like, really simple, and it says just in

00:26:36,669 --> 00:26:40,590
one reading what that does. So think about, like,

00:26:40,590 --> 00:26:43,850
it's sort of this nice balance between, like, when

00:26:43,850 --> 00:26:46,419
you want to expose implementation details or allow the

00:26:46,419 --> 00:26:49,539
user to do things as, as hands-on or directly

00:26:49,539 --> 00:26:52,110
as possible, and where you want to add helpers,

00:26:52,110 --> 00:26:54,909
where there might be some, some convolution or some

00:26:54,909 --> 00:26:58,990
complexity that's just not even worth exposing to the

00:26:58,990 --> 00:26:59,789
user.

00:26:59,789 --> 00:27:02,620
So those were simplicity suggestions.

00:27:02,620 --> 00:27:05,230
Mapping mantras. So again, mapping is where you have

00:27:05,230 --> 00:27:09,940
an interface component that is very obviously related, or

00:27:09,940 --> 00:27:12,850
direct, has a direct effect on some element of

00:27:12,850 --> 00:27:14,740
the system. And you want to make sure that

00:27:14,740 --> 00:27:16,970
whenever there's a change in the system, the user

00:27:16,970 --> 00:27:21,070
gets some feedback and knows what effect that interface

00:27:21,070 --> 00:27:22,980
component has had on the system.

00:27:22,980 --> 00:27:25,750
So first of all, monkey-patching is mean.

00:27:25,750 --> 00:27:28,809
Monkey-patching is a bad idea. I don't think there's

00:27:28,809 --> 00:27:33,279
ever a good case for monkey-patching. I don't want

00:27:33,279 --> 00:27:35,330
to embarrass a past colleague, but I think this

00:27:35,330 --> 00:27:38,590
example is too good not to share. We found,

00:27:38,590 --> 00:27:40,380
in our code, at some point, I'm gonna breeze

00:27:40,380 --> 00:27:44,220
past this really quickly, we found a method called

00:27:44,220 --> 00:27:47,000
lock_with_hack, that was - that was really quick -

00:27:47,000 --> 00:27:50,720
lock_with_hack that was aliased on lock in a mutex.

00:27:50,720 --> 00:27:51,789
Not a good idea.

00:27:51,789 --> 00:27:54,750
So use refinements instead. We've just support back to

00:27:54,750 --> 00:27:56,700
1.8.7, so we can't actually use refinements. So it

00:27:56,700 --> 00:27:58,509
might not, it might not be an option for

00:27:58,509 --> 00:28:02,919
you. People sometimes say use inheritance, if you find

00:28:02,919 --> 00:28:05,380
that you need to monkey-patch something, maybe you're design's

00:28:05,380 --> 00:28:07,919
a little off and you need to re-evaluate your

00:28:07,919 --> 00:28:10,750
design, there's no quick fix or, like, quick answer

00:28:10,750 --> 00:28:14,090
to getting around monkey-patching but, in general, if you

00:28:14,090 --> 00:28:16,029
can avoid it, avoid it like the plague.

00:28:16,029 --> 00:28:20,669
Two. Side effects are surprising. That sort of speaks

00:28:20,669 --> 00:28:24,350
for itself. But, to give you a concrete example,

00:28:24,350 --> 00:28:27,500
if someone is passing in ops to a method

00:28:27,500 --> 00:28:29,830
that they potentially could be using over and over

00:28:29,830 --> 00:28:35,860
again, don't mutate their op. So, for example, here,

00:28:35,860 --> 00:28:37,539
if I pass in ops to a map reduce,

00:28:37,539 --> 00:28:39,809
it could, as going back to read_preferences, it could

00:28:39,809 --> 00:28:43,259
say use a secondary node for this map_reduce, and

00:28:43,259 --> 00:28:45,850
if you, if you extract or you delete one

00:28:45,850 --> 00:28:48,809
key from that hash, the reference is going to

00:28:48,809 --> 00:28:51,450
be used over and over again and future map_reduces

00:28:51,450 --> 00:28:54,610
in their own code and potentially be su- have

00:28:54,610 --> 00:28:56,259
surprising effects to the user.

00:28:56,259 --> 00:28:59,130
So make sure you do something here, like, do

00:28:59,130 --> 00:29:01,419
the opts that you're working with a local copy.

00:29:01,419 --> 00:29:04,200
So avoid side-effects that, that's breaking the trust that

00:29:04,200 --> 00:29:06,730
you have with your user.

00:29:06,730 --> 00:29:10,940
Requiring method chaining is impolite. Why is it impolite?

00:29:10,940 --> 00:29:13,919
Because you make your user's code look ugly. Make

00:29:13,919 --> 00:29:18,100
sure that, this is, this is a train-wreck violating

00:29:18,100 --> 00:29:19,100
the law of demand (?? - 00:29:19) or whatever

00:29:19,100 --> 00:29:22,399
you want to call it. If you are, if

00:29:22,399 --> 00:29:25,330
you are not giving your users access to the

00:29:25,330 --> 00:29:28,370
right things, their code might end up looking super

00:29:28,370 --> 00:29:30,080
ugly and you want to avoid this. You want

00:29:30,080 --> 00:29:32,889
to make sure that the API you're providing to

00:29:32,889 --> 00:29:35,130
the users allows them to work with your code

00:29:35,130 --> 00:29:38,700
in the cleanest, most elegant way possible.

00:29:38,700 --> 00:29:44,559
Information error messages are imperative. I know, I love

00:29:44,559 --> 00:29:48,149
MongoDB, blah, blah, blah, but I think Mongoid is

00:29:48,149 --> 00:29:51,789
one of the best examples of great error messages.

00:29:51,789 --> 00:29:54,480
This is an error message, not a blog post.

00:29:54,480 --> 00:29:57,980
So, user dot find, with a certain ID, you

00:29:57,980 --> 00:30:00,789
get the, the like basic error. It says error:

00:30:00,789 --> 00:30:03,580
document not find. Then you have problem: document not

00:30:03,580 --> 00:30:07,350
found for class user with IDs 123. Summary: When

00:30:07,350 --> 00:30:09,659
calling user dot find with ID blah, blah, blah

00:30:09,659 --> 00:30:11,490
- so you have this nice summary, even, of

00:30:11,490 --> 00:30:11,909
what happened.

00:30:11,909 --> 00:30:14,720
And then, what's even better, it tells you resolution.

00:30:14,720 --> 00:30:16,899
It tells you what to do. It gives you

00:30:16,899 --> 00:30:18,659
two options of what you can do. This is

00:30:18,659 --> 00:30:20,460
the best error message ever.

00:30:20,460 --> 00:30:22,830
So think about your users, like what - they're

00:30:22,830 --> 00:30:24,600
gonna be frustrated when they get an error. You

00:30:24,600 --> 00:30:26,850
want to give them as many, as much information

00:30:26,850 --> 00:30:28,840
as possible, so they can solve the problem on

00:30:28,840 --> 00:30:31,570
their own. Because, otherwise you're going to get issues

00:30:31,570 --> 00:30:33,340
logged against your gem that you're gonna have to

00:30:33,340 --> 00:30:35,279
go through and write out an answer and tell

00:30:35,279 --> 00:30:36,259
them what to do.

00:30:36,259 --> 00:30:38,909
So save yourself the time. Save your users the

00:30:38,909 --> 00:30:41,200
frustration and write nice error messages.

00:30:41,200 --> 00:30:45,659
And the last thing is documentation. So I went

00:30:45,659 --> 00:30:49,630
to a presentation recently, and someone said inline comments

00:30:49,630 --> 00:30:52,529
are a code smell. I totally disagree. I think

00:30:52,529 --> 00:30:57,240
inline comments are extremely important, in particular if you're

00:30:57,240 --> 00:31:00,620
writing a gem against something like a database, for

00:31:00,620 --> 00:31:04,080
example, that might have some obscure, obscurities, or like

00:31:04,080 --> 00:31:06,289
some weird things about it that you need to

00:31:06,289 --> 00:31:09,460
write some fancy code around, or some, something that

00:31:09,460 --> 00:31:11,769
might not be totally obvious to a user looking

00:31:11,769 --> 00:31:12,809
at the code.

00:31:12,809 --> 00:31:15,590
If you find yourself writing lines of code that

00:31:15,590 --> 00:31:17,009
seem sort of confusing to you, you have to

00:31:17,009 --> 00:31:19,059
stop and think about it really hard before you

00:31:19,059 --> 00:31:21,679
write it, write an inline comment for anybody looking

00:31:21,679 --> 00:31:23,700
at their code. It might even be you in

00:31:23,700 --> 00:31:25,129
a couple of weeks when you forget what you

00:31:25,129 --> 00:31:25,740
did.

00:31:25,740 --> 00:31:29,629
So, for example, the, the server, the MongoDB server,

00:31:29,629 --> 00:31:32,500
a couple weeks ago decided to create this option

00:31:32,500 --> 00:31:36,830
called digest_password. And what digest_password is, in the context

00:31:36,830 --> 00:31:40,870
of authentication, is tells the server that you need

00:31:40,870 --> 00:31:43,240
to digest the password because I haven't on my

00:31:43,240 --> 00:31:43,610
end.

00:31:43,610 --> 00:31:46,389
So the, the driver has to, we digest the

00:31:46,389 --> 00:31:50,799
password driver-side, but then we set this, this field

00:31:50,799 --> 00:31:52,809
saying digest_password false, because when it's sent to the

00:31:52,809 --> 00:31:55,309
server, it's telling the server that you shouldn't digest

00:31:55,309 --> 00:31:57,679
the password. But a user looking at this code

00:31:57,679 --> 00:32:02,679
is gonna see, OK, digest_password, digest_password equals false. That

00:32:02,679 --> 00:32:04,590
doesn't seem to make any sense at all.

00:32:04,590 --> 00:32:06,899
So, my colleagues who did a code review, kindly

00:32:06,899 --> 00:32:08,500
told me, why don't you just put an inline

00:32:08,500 --> 00:32:10,330
comment here so that someone looking at it is

00:32:10,330 --> 00:32:12,059
not like, why are you digesting the password and

00:32:12,059 --> 00:32:14,250
then setting digest_password to false?

00:32:14,250 --> 00:32:16,659
So inline comments are great. Not, you know, not

00:32:16,659 --> 00:32:22,169
like paragraphs, like the Mongoid exception or the Mongoing

00:32:22,169 --> 00:32:25,090
exception summary, but make sure that inline comments are

00:32:25,090 --> 00:32:27,879
just little notes for yourself that are super clear.

00:32:27,879 --> 00:32:29,960
Think about them actually as notes to yourself. Make

00:32:29,960 --> 00:32:32,299
them super clear because other users will find them

00:32:32,299 --> 00:32:34,929
really useful.

00:32:34,929 --> 00:32:36,980
Documentation tools - we use Yard. It's really great.

00:32:36,980 --> 00:32:39,690
I think the documentation looks great. It's really easy

00:32:39,690 --> 00:32:44,070
to use. All the tags are wonderful. Readme -

00:32:44,070 --> 00:32:47,269
Readmes should be short and sweet. They should not

00:32:47,269 --> 00:32:50,710
be guides. They should not be tutorials. They should

00:32:50,710 --> 00:32:52,620
be sort of like an abstract for your gem.

00:32:52,620 --> 00:32:55,700
So someone who is looking to evaluate your gem,

00:32:55,700 --> 00:32:58,309
just quickly decide if it fulfills a need that

00:32:58,309 --> 00:33:00,500
they have, if it's something that they want to

00:33:00,500 --> 00:33:02,980
use, if they like the API, make sure you

00:33:02,980 --> 00:33:05,350
put these things in your, in your readme, because

00:33:05,350 --> 00:33:07,029
this is what people are gonna look at quickly

00:33:07,029 --> 00:33:08,639
when they want to decide whether or not to

00:33:08,639 --> 00:33:09,669
use your gem.

00:33:09,669 --> 00:33:14,429
So those were mapping mantras. We talked about consistency.

00:33:14,429 --> 00:33:16,580
We talked about simplicity. And we talked about mapping.

00:33:16,580 --> 00:33:20,919
These are user experience concepts that are super relevant

00:33:20,919 --> 00:33:24,129
to gem API design as well as software design,

00:33:24,129 --> 00:33:27,179
whether you're a gem author or user.

00:33:27,179 --> 00:33:30,049
And if you're looking, you haven't authored a gem

00:33:30,049 --> 00:33:32,740
or maintained, had the opportunity to maintain a gem,

00:33:32,740 --> 00:33:35,039
and you just want to try it out, there's

00:33:35,039 --> 00:33:37,750
a blog post by Daniel Doubrovkine, where he -

00:33:37,750 --> 00:33:41,059
it's called Your First Ruby Gem. And it's really

00:33:41,059 --> 00:33:43,429
excellent. He goes through sort of this checklist of

00:33:43,429 --> 00:33:45,039
things that you have to do as you're building

00:33:45,039 --> 00:33:47,100
a gem. Like check the name, create a readme,

00:33:47,100 --> 00:33:51,450
add a license, a gem file. It's really useful

00:33:51,450 --> 00:33:53,049
for if you just want to even try it

00:33:53,049 --> 00:33:55,129
out personally on your own, you know, on your

00:33:55,129 --> 00:33:57,830
own time, and not even share it with anybody.

00:33:57,830 --> 00:34:01,830
It's a great resource for getting started. So think

00:34:01,830 --> 00:34:04,220
like a UX designer. It's not just about writing

00:34:04,220 --> 00:34:06,820
code in a vaccuum. And I want to end

00:34:06,820 --> 00:34:10,659
on a quote from Golden Gate Ruby Conference. James

00:34:10,659 --> 00:34:14,840
Edward Gray the second gave a phenomenal presentation about

00:34:14,840 --> 00:34:17,120
what it's like being a programmer, and his own

00:34:17,120 --> 00:34:19,389
personal experience being a programmer.

00:34:19,389 --> 00:34:23,040
And he said, Programming is easy. Anybody can program.

00:34:23,040 --> 00:34:25,030
But to be a programmer, that's what gets you

00:34:25,030 --> 00:34:28,080
to the next level. So get social. Get to

00:34:28,080 --> 00:34:30,390
know your users and talk to me about the

00:34:30,390 --> 00:34:30,870

YouTube URL: https://www.youtube.com/watch?v=ieiAyfTwekA


