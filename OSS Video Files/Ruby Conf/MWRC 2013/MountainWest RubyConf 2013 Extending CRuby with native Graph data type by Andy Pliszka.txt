Title: MountainWest RubyConf 2013 Extending CRuby with native Graph data type by Andy Pliszka
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Reading of the CRuby source code can provide unparalleled insight into the Ruby language. During this talk we will add new native Graph data type to CRuby. The new Graph data structure will be simple but on par with other native types such as Array or Hash. This talk will demonstrate that it is easy to experiment with CRuby and extend it. We will also demonstrate the speed advantage of using C to boost Ruby performance. We will implement a few of the greatest hits of graph algorithms: Breath First Search, Dijkstra, and Minimum Spanning Tree.

Help us caption & translate this video!

http://amara.org/v/FGbR/
Captions: 
	00:00:01,170 --> 00:00:18,649
[Music]

00:00:19,780 --> 00:00:25,850
okay so today I'll show you briefly a

00:00:23,390 --> 00:00:27,260
quick introduction to graphs and then

00:00:25,850 --> 00:00:29,300
we're gonna walk through a Serie B

00:00:27,260 --> 00:00:33,230
source code and at the end we will try

00:00:29,300 --> 00:00:35,450
to add a class using C Ruby class using

00:00:33,230 --> 00:00:38,059
C so basically define a data native

00:00:35,450 --> 00:00:39,950
datatype straight from directly from C

00:00:38,059 --> 00:00:43,100
and use it from Ruby

00:00:39,950 --> 00:00:44,449
so why graphs are important so let me

00:00:43,100 --> 00:00:47,030
show you quick demo

00:00:44,449 --> 00:00:50,570
this is my my social network this is my

00:00:47,030 --> 00:00:53,800
Facebook network social network that I

00:00:50,570 --> 00:00:56,239
applied very simple algorithm which is

00:00:53,800 --> 00:01:00,290
connected components strongly connected

00:00:56,239 --> 00:01:01,730
components and because of the way how

00:01:00,290 --> 00:01:04,100
people are connect with each other on

00:01:01,730 --> 00:01:06,140
Facebook if you can see that it created

00:01:04,100 --> 00:01:09,290
multiple clusters and for example these

00:01:06,140 --> 00:01:11,149
guys you can clearly see the companies

00:01:09,290 --> 00:01:13,250
that I work for because all the people

00:01:11,149 --> 00:01:15,259
who work at those companies are strongly

00:01:13,250 --> 00:01:16,790
connected between themselves and this is

00:01:15,259 --> 00:01:19,340
actually very simple algorithm that it

00:01:16,790 --> 00:01:23,119
can run you basically iran def first

00:01:19,340 --> 00:01:25,130
search algorithm on on a graph twice in

00:01:23,119 --> 00:01:27,770
two different directions and at the end

00:01:25,130 --> 00:01:30,710
you end up with a clearly marked and

00:01:27,770 --> 00:01:33,650
nodes that basically they are marked by

00:01:30,710 --> 00:01:35,270
the network that they belong to so

00:01:33,650 --> 00:01:38,240
there's different company that I work

00:01:35,270 --> 00:01:40,780
for there's my family so this this can

00:01:38,240 --> 00:01:43,220
show you how even with really trivial

00:01:40,780 --> 00:01:45,700
trivial roots you can extract a lot of

00:01:43,220 --> 00:01:51,710
data from your from your social networks

00:01:45,700 --> 00:01:54,619
ok so how how do we represent graphs in

00:01:51,710 --> 00:01:57,740
code so this is just just an expert from

00:01:54,619 --> 00:02:00,950
an algorithm book so we have a simple

00:01:57,740 --> 00:02:04,430
graph with five nodes it's it's a it's

00:02:00,950 --> 00:02:06,110
it's not fully connected and the way we

00:02:04,430 --> 00:02:07,670
would represent it in memory one of the

00:02:06,110 --> 00:02:09,890
efficient ways of representing a graph

00:02:07,670 --> 00:02:13,630
in memory is using linked lists so right

00:02:09,890 --> 00:02:16,010
here you can see a list of lists and

00:02:13,630 --> 00:02:18,200
basically for each node you have a list

00:02:16,010 --> 00:02:20,329
of nodes that that particular node is

00:02:18,200 --> 00:02:22,549
connected to so for example node one is

00:02:20,329 --> 00:02:24,650
connected to two two and five and you

00:02:22,549 --> 00:02:26,030
can clearly see here that one is

00:02:24,650 --> 00:02:28,220
connected to two and five and it's ended

00:02:26,030 --> 00:02:30,980
the linked list has ended this is this

00:02:28,220 --> 00:02:32,989
is more based on on C but in Ruby is the

00:02:30,980 --> 00:02:33,240
same the same principle you can create a

00:02:32,989 --> 00:02:36,570
link

00:02:33,240 --> 00:02:39,920
list using erase or or or hashes we can

00:02:36,570 --> 00:02:47,010
you can actually use hashes to restore

00:02:39,920 --> 00:02:50,240
graphs in Ruby okay so what is I'm going

00:02:47,010 --> 00:02:52,890
to show you I choose as a demonstration

00:02:50,240 --> 00:02:55,680
breadth-first search and just to

00:02:52,890 --> 00:02:58,020
familiar you know refresh your memory

00:02:55,680 --> 00:03:00,240
this how this is how a breadth first

00:02:58,020 --> 00:03:03,330
search algorithm works so this is an

00:03:00,240 --> 00:03:05,100
example of a grid graph it's very it's

00:03:03,330 --> 00:03:06,630
very good graph to demonstrate this

00:03:05,100 --> 00:03:08,190
algorithm because you will you will see

00:03:06,630 --> 00:03:10,020
that it looks like basically we are

00:03:08,190 --> 00:03:12,930
flooding the whole graph with red

00:03:10,020 --> 00:03:14,340
pigment and the way it works you started

00:03:12,930 --> 00:03:17,070
with a source node which is marked here

00:03:14,340 --> 00:03:19,320
as red and the first thing that you do

00:03:17,070 --> 00:03:21,210
you explore all its neighbors and then

00:03:19,320 --> 00:03:26,040
neighbors of those neighbors and so

00:03:21,210 --> 00:03:28,650
forth so you can see first we we explore

00:03:26,040 --> 00:03:30,840
first four nodes that are connected to

00:03:28,650 --> 00:03:33,810
it directly then there their neighbors

00:03:30,840 --> 00:03:35,610
and and as far as we can go and we end

00:03:33,810 --> 00:03:39,090
when we explore the whole graph so what

00:03:35,610 --> 00:03:42,390
you can do using this approach you can

00:03:39,090 --> 00:03:45,320
for example find notes that have certain

00:03:42,390 --> 00:03:48,270
elements so imagine that this is my

00:03:45,320 --> 00:03:51,210
social graph I can find people for

00:03:48,270 --> 00:03:54,870
example who have a lot of followers or I

00:03:51,210 --> 00:03:57,690
can find people with certain skills like

00:03:54,870 --> 00:04:01,290
people who put on their profile that

00:03:57,690 --> 00:04:02,850
they for example use Ruby okay so that

00:04:01,290 --> 00:04:05,730
pretty much finishes my quick

00:04:02,850 --> 00:04:10,050
introduction and let's take a look at C

00:04:05,730 --> 00:04:12,000
Ruby source code so when I was when I

00:04:10,050 --> 00:04:14,340
started looking at at Ruby you know I

00:04:12,000 --> 00:04:16,200
like the fact that how it's a great

00:04:14,340 --> 00:04:17,070
language but I wanted to understand how

00:04:16,200 --> 00:04:19,080
it actually works

00:04:17,070 --> 00:04:20,970
and one of the ways you can do it you

00:04:19,080 --> 00:04:24,180
can actually look at the serial resource

00:04:20,970 --> 00:04:26,430
code and as an exercise to facilitate

00:04:24,180 --> 00:04:29,040
that ecstatics pleurae ssin I said to

00:04:26,430 --> 00:04:31,500
myself why don't I implement a graph

00:04:29,040 --> 00:04:35,010
data structure just like we have an

00:04:31,500 --> 00:04:37,890
array or hash and before I was able to

00:04:35,010 --> 00:04:39,360
do it I started exploring C Ruby and I

00:04:37,890 --> 00:04:42,000
want to show you how easy it is to

00:04:39,360 --> 00:04:44,790
actually understand what's going on in

00:04:42,000 --> 00:04:46,599
the in although it is C but because of

00:04:44,790 --> 00:04:49,669
our knowledge of Ruby and our

00:04:46,599 --> 00:04:51,229
you know knowledge of the API you can

00:04:49,669 --> 00:04:54,409
really quickly orient yourself in the

00:04:51,229 --> 00:04:55,729
source code and I was able literally to

00:04:54,409 --> 00:04:57,830
add start playing with it adding

00:04:55,729 --> 00:05:01,009
different methods and new methods within

00:04:57,830 --> 00:05:04,789
couple literally within an hour so let's

00:05:01,009 --> 00:05:07,789
take a look at first class which is

00:05:04,789 --> 00:05:10,490
array it's an array that's C and what

00:05:07,789 --> 00:05:13,129
you will see in all this C classes

00:05:10,490 --> 00:05:15,039
pretty much all of them have this init

00:05:13,129 --> 00:05:18,580
array init underscore something

00:05:15,039 --> 00:05:21,319
procedure and what this is is basically

00:05:18,580 --> 00:05:24,289
this is where the class is actually

00:05:21,319 --> 00:05:27,680
declared and in this case this is where

00:05:24,289 --> 00:05:30,370
in c array class is declared so you can

00:05:27,680 --> 00:05:32,599
see here we have this really nice method

00:05:30,370 --> 00:05:34,819
the code is also written in a very

00:05:32,599 --> 00:05:38,539
descriptive way so it's very easy to

00:05:34,819 --> 00:05:41,120
understand what's going on so first we

00:05:38,539 --> 00:05:42,770
define class just like in Ruby source

00:05:41,120 --> 00:05:44,840
but right class array this is pretty

00:05:42,770 --> 00:05:51,860
much equivalent of it so we declare a

00:05:44,840 --> 00:05:54,020
class we with with with array name and

00:05:51,860 --> 00:05:56,810
the class inherits from the object right

00:05:54,020 --> 00:05:59,960
just exactly as the array class as we

00:05:56,810 --> 00:06:03,440
know it from from our everyday everyday

00:05:59,960 --> 00:06:05,060
life next what we see it's that this

00:06:03,440 --> 00:06:07,219
class actually includes module

00:06:05,060 --> 00:06:12,229
enumerable right and you can see

00:06:07,219 --> 00:06:14,360
equivalent code in Ruby there so this is

00:06:12,229 --> 00:06:17,060
pretty it was really really simple for

00:06:14,360 --> 00:06:18,889
me to add a new class like widget just

00:06:17,060 --> 00:06:21,620
by literally implementing those two

00:06:18,889 --> 00:06:27,680
those two methods actually only this one

00:06:21,620 --> 00:06:30,129
and and one more initializer yeah okay

00:06:27,680 --> 00:06:31,909
so you will find this kind of

00:06:30,129 --> 00:06:34,219
initialization and creation in

00:06:31,909 --> 00:06:37,610
declaration of classes in almost every

00:06:34,219 --> 00:06:42,289
every every C Ruby class this will be in

00:06:37,610 --> 00:06:45,589
hash fix nouns big noms next next there

00:06:42,289 --> 00:06:49,120
are two important methods here which are

00:06:45,589 --> 00:06:53,629
you can see we there's an allocation

00:06:49,120 --> 00:06:56,330
function and initialization function the

00:06:53,629 --> 00:06:59,060
reason why a lock is actually important

00:06:56,330 --> 00:06:59,920
is because we are in C R in C so we have

00:06:59,060 --> 00:07:02,560
to

00:06:59,920 --> 00:07:04,660
allocate the memory by ourselves we

00:07:02,560 --> 00:07:06,700
cannot depend on you know the the

00:07:04,660 --> 00:07:08,590
services that really provides us so you

00:07:06,700 --> 00:07:11,590
have to actually declare a declare and

00:07:08,590 --> 00:07:15,420
allocate memory on your own and then we

00:07:11,590 --> 00:07:21,640
have this class which is initialize

00:07:15,420 --> 00:07:24,880
which simply is equivalent of other a

00:07:21,640 --> 00:07:26,920
new right then you can pass this mind

00:07:24,880 --> 00:07:29,860
this minus one at the end it's actually

00:07:26,920 --> 00:07:33,100
indicates that to this method you can

00:07:29,860 --> 00:07:35,890
pass in valuable number of parameters

00:07:33,100 --> 00:07:39,010
and as you know from the array API you

00:07:35,890 --> 00:07:41,260
can actually pass pass multiple multiple

00:07:39,010 --> 00:07:43,780
arguments to array that new you can

00:07:41,260 --> 00:07:46,720
specify the capacity also you can

00:07:43,780 --> 00:07:48,610
specify a block that will be called to

00:07:46,720 --> 00:07:51,070
initialize all the elements in the array

00:07:48,610 --> 00:07:56,160
ok so let's take a look quick look at

00:07:51,070 --> 00:07:56,160
the first method which is array a lock

00:07:56,520 --> 00:08:03,280
here we go so there's nothing really

00:08:00,840 --> 00:08:05,410
difficult about this basically what we

00:08:03,280 --> 00:08:07,600
do is it's a static function that

00:08:05,410 --> 00:08:09,010
returns value and most of your of your

00:08:07,600 --> 00:08:10,540
functions will actually if you if you

00:08:09,010 --> 00:08:12,580
try to extend C Ruby

00:08:10,540 --> 00:08:14,320
most of your function will actually turn

00:08:12,580 --> 00:08:17,080
in value which is a reference to an

00:08:14,320 --> 00:08:19,180
object first thing that we do we create

00:08:17,080 --> 00:08:22,600
a new object and you can see that it's

00:08:19,180 --> 00:08:25,150
referencing our array structure which is

00:08:22,600 --> 00:08:28,150
C struct that I will show you in a

00:08:25,150 --> 00:08:31,530
minute and we do some object setup we

00:08:28,150 --> 00:08:33,760
set a couple of flags on the objects

00:08:31,530 --> 00:08:36,040
these two are actually very very

00:08:33,760 --> 00:08:37,960
specific to the array they are not you

00:08:36,040 --> 00:08:40,030
can you don't have to do it in your

00:08:37,960 --> 00:08:41,380
class you you will not be you will there

00:08:40,030 --> 00:08:44,260
will be no need for you to do it in your

00:08:41,380 --> 00:08:47,070
simple classes and that's pretty much

00:08:44,260 --> 00:08:50,620
too much it this actually creates and

00:08:47,070 --> 00:08:55,350
allocates the memory for you let's take

00:08:50,620 --> 00:08:59,470
a look at the initialization class

00:08:55,350 --> 00:09:00,700
initialization function so the

00:08:59,470 --> 00:09:04,240
initialization is a little bit longer

00:09:00,700 --> 00:09:06,790
and that's because as you know array

00:09:04,240 --> 00:09:08,620
that new accepts valuable number of

00:09:06,790 --> 00:09:11,779
parameters and it also accepts a block

00:09:08,620 --> 00:09:13,670
so let's go to some and look

00:09:11,779 --> 00:09:15,740
something that's simple so for example

00:09:13,670 --> 00:09:17,810
come focus your attention on this one

00:09:15,740 --> 00:09:20,240
this is this block so you can see that

00:09:17,810 --> 00:09:22,819
if number of arguments passed to the

00:09:20,240 --> 00:09:24,410
array that nu is one which indicates

00:09:22,819 --> 00:09:26,480
that we were passing the size of the

00:09:24,410 --> 00:09:30,110
array that you want to allocate it

00:09:26,480 --> 00:09:32,509
actually what it does it checks the size

00:09:30,110 --> 00:09:38,499
of the array but then actually replaces

00:09:32,509 --> 00:09:42,230
the array replaces the array with

00:09:38,499 --> 00:09:43,759
basically swaps array it's a ruby array

00:09:42,230 --> 00:09:45,769
replace it's a utility method that

00:09:43,759 --> 00:09:51,680
basically reallocates the array for you

00:09:45,769 --> 00:09:56,779
with we've given size okay so next thing

00:09:51,680 --> 00:10:00,680
that you want to look at is you can see

00:09:56,779 --> 00:10:04,189
that there is a lot of this defined

00:10:00,680 --> 00:10:07,399
method calls and what they do they

00:10:04,189 --> 00:10:09,740
actually link see functions for your

00:10:07,399 --> 00:10:14,990
Ruby source code so for example if you

00:10:09,740 --> 00:10:17,779
look at something familiar fast right so

00:10:14,990 --> 00:10:20,389
something that you call in Ruby by a dot

00:10:17,779 --> 00:10:23,120
first the way it gets linked to the

00:10:20,389 --> 00:10:28,279
actual C implementation is via this

00:10:23,120 --> 00:10:30,980
define method procedure here and what it

00:10:28,279 --> 00:10:34,850
does it actually links the CRA C class

00:10:30,980 --> 00:10:37,220
array object with with the name of the

00:10:34,850 --> 00:10:37,879
method first and it links it to this

00:10:37,220 --> 00:10:43,399
function

00:10:37,879 --> 00:10:45,139
Ruby array first and if you look at this

00:10:43,399 --> 00:10:49,730
method there's nothing really special

00:10:45,139 --> 00:10:52,610
about as well so you can see that it it

00:10:49,730 --> 00:10:55,129
follows the the traditional C convention

00:10:52,610 --> 00:11:00,769
that where you pass the number of

00:10:55,129 --> 00:11:04,129
arguments first and here followed by an

00:11:00,769 --> 00:11:05,600
array of the arguments and so you can

00:11:04,129 --> 00:11:07,339
access actually how many how many

00:11:05,600 --> 00:11:08,720
arguments have been passed and based on

00:11:07,339 --> 00:11:11,329
that you can make decision so for

00:11:08,720 --> 00:11:14,449
example in this case think about when

00:11:11,329 --> 00:11:16,910
you are using a that first and you don't

00:11:14,449 --> 00:11:19,459
pass any elements you expect it to

00:11:16,910 --> 00:11:22,939
either return nil right when the array

00:11:19,459 --> 00:11:25,560
is empty array list length is equal to 0

00:11:22,939 --> 00:11:29,100
or the first element 0 of element

00:11:25,560 --> 00:11:31,770
the array right or if you pass an

00:11:29,100 --> 00:11:34,290
element you want to get the first first

00:11:31,770 --> 00:11:40,770
n elements that's facilitated by this

00:11:34,290 --> 00:11:44,460
function and if you if you just open

00:11:40,770 --> 00:11:46,170
this array that C file and just browse

00:11:44,460 --> 00:11:47,910
through through the the bottom of the

00:11:46,170 --> 00:11:49,170
file and look at all those mappings you

00:11:47,910 --> 00:11:52,740
will find all the methods that we use

00:11:49,170 --> 00:11:55,800
every day when we are using array

00:11:52,740 --> 00:11:57,150
objects okay so the next thing when I

00:11:55,800 --> 00:11:59,370
was taught when I was talking about the

00:11:57,150 --> 00:12:01,980
allocation I told you about this truck

00:11:59,370 --> 00:12:03,900
Ruby our array and this is actually

00:12:01,980 --> 00:12:04,710
defined in a different different file

00:12:03,900 --> 00:12:10,260
called Ruby

00:12:04,710 --> 00:12:14,339
it's include file Ruby dot H and yes so

00:12:10,260 --> 00:12:16,620
even without any knowledge of of C you

00:12:14,339 --> 00:12:21,390
can clearly see that each array isn't

00:12:16,620 --> 00:12:24,210
actually has the structure or basic

00:12:21,390 --> 00:12:32,040
which is basic object we can take a look

00:12:24,210 --> 00:12:35,070
at it so basic object has only two

00:12:32,040 --> 00:12:37,650
members which is flags for example flags

00:12:35,070 --> 00:12:40,190
are used during garbage collection so

00:12:37,650 --> 00:12:44,100
all the objects in use will be marked as

00:12:40,190 --> 00:12:46,800
in use by by it basically flag in flags

00:12:44,100 --> 00:12:48,360
it's a almost like a bitmap and class is

00:12:46,800 --> 00:12:51,270
just referenced to the class that this

00:12:48,360 --> 00:12:57,300
object belongs to next thing so that was

00:12:51,270 --> 00:13:00,510
basic object right sorry that was basic

00:12:57,300 --> 00:13:03,570
object and the next to it you have error

00:13:00,510 --> 00:13:05,430
object right and this is this is the

00:13:03,570 --> 00:13:08,310
actual object that that you usually

00:13:05,430 --> 00:13:10,290
inherit from if you don't specify the

00:13:08,310 --> 00:13:13,140
the parent class when you declare a

00:13:10,290 --> 00:13:15,360
class in in Ruby and you can see that it

00:13:13,140 --> 00:13:17,910
still uses our object but it also has

00:13:15,360 --> 00:13:21,839
this access it this it has this truck

00:13:17,910 --> 00:13:24,150
that includes num IV as well as this

00:13:21,839 --> 00:13:25,740
pointer and what this is it's the number

00:13:24,150 --> 00:13:28,140
of Ivor's that you have in your class

00:13:25,740 --> 00:13:31,140
and this is actually array to all those

00:13:28,140 --> 00:13:34,339
Ivor's so you can in C you can have

00:13:31,140 --> 00:13:39,770
actually access to all your aivars

00:13:34,339 --> 00:13:39,770
okay let's go back to to the array

00:13:41,470 --> 00:13:46,339
so what array has something everything

00:13:45,050 --> 00:13:49,550
that they would expect from the Reg like

00:13:46,339 --> 00:13:52,910
it has a length as well as capacity and

00:13:49,550 --> 00:13:55,160
as a pointer to to where the actual

00:13:52,910 --> 00:13:57,290
array elements are stored and there's

00:13:55,160 --> 00:13:59,660
also really interesting optimization

00:13:57,290 --> 00:14:01,070
here if you if you look here if you look

00:13:59,660 --> 00:14:03,649
at this piece of code it basically

00:14:01,070 --> 00:14:07,970
creates a really small array directly on

00:14:03,649 --> 00:14:10,670
our array and its size is three you can

00:14:07,970 --> 00:14:13,070
see it here so basically what it means

00:14:10,670 --> 00:14:15,649
that if you create an empty array or an

00:14:13,070 --> 00:14:17,750
array that has less than less than four

00:14:15,649 --> 00:14:19,760
elements or three or less it will not

00:14:17,750 --> 00:14:21,470
actually create anything on the heap it

00:14:19,760 --> 00:14:25,160
will actually store that those values

00:14:21,470 --> 00:14:28,339
directly on our array so this means that

00:14:25,160 --> 00:14:31,339
the performance-wise it's just much

00:14:28,339 --> 00:14:33,079
faster because in our code you usually

00:14:31,339 --> 00:14:34,339
usually create arrays that are empty

00:14:33,079 --> 00:14:36,230
right that's not what that's what we

00:14:34,339 --> 00:14:38,959
start with and there's a lot of empty

00:14:36,230 --> 00:14:41,329
arrays and there is actually it's much

00:14:38,959 --> 00:14:44,269
it's very beneficial to to have

00:14:41,329 --> 00:14:48,260
optimized code path for arrays that are

00:14:44,269 --> 00:14:50,720
very small okay so this pretty much

00:14:48,260 --> 00:14:54,050
covers the Declaration declaration of

00:14:50,720 --> 00:14:57,110
the array as well as the creation of the

00:14:54,050 --> 00:14:58,519
of the memory that we create for it so

00:14:57,110 --> 00:15:01,100
the next thing that we have to worry

00:14:58,519 --> 00:15:06,440
about when you are creating a new type

00:15:01,100 --> 00:15:14,570
in NC is memory allocation which happens

00:15:06,440 --> 00:15:16,760
in ng c dot C and as you know Ruby is a

00:15:14,570 --> 00:15:18,519
dynamic language and it uses garbage

00:15:16,760 --> 00:15:20,779
collection and it's using mark-and-sweep

00:15:18,519 --> 00:15:23,660
garbage collection and what it means is

00:15:20,779 --> 00:15:26,360
that if Ruby runs out of memory and you

00:15:23,660 --> 00:15:29,000
want to allocate a new object it will

00:15:26,360 --> 00:15:32,690
mark it will go through all the objects

00:15:29,000 --> 00:15:34,940
that are in use and mark them as as in

00:15:32,690 --> 00:15:38,060
use and that's that's the mark part of

00:15:34,940 --> 00:15:39,980
the garbage collection process and then

00:15:38,060 --> 00:15:41,600
the next step is sweep which is the

00:15:39,980 --> 00:15:43,699
allocation of all those objects and

00:15:41,600 --> 00:15:45,260
reclaim it will reclaim the memory for

00:15:43,699 --> 00:15:48,470
all the objects that they have not been

00:15:45,260 --> 00:15:50,540
marked as we in use so for example I'm

00:15:48,470 --> 00:15:51,800
not going to go in into a lot of detail

00:15:50,540 --> 00:15:53,520
here but

00:15:51,800 --> 00:15:55,650
something that it's really easy to

00:15:53,520 --> 00:15:57,030
understand which happens for the array

00:15:55,650 --> 00:16:00,930
so you can see here that there is this

00:15:57,030 --> 00:16:05,490
type T array and what it does here for

00:16:00,930 --> 00:16:06,960
example is array we get the length of

00:16:05,490 --> 00:16:08,610
the array and that we actually go

00:16:06,960 --> 00:16:12,600
through all the elements of the array

00:16:08,610 --> 00:16:14,460
and we mark them as in use so what

00:16:12,600 --> 00:16:17,220
happens here is that if you have

00:16:14,460 --> 00:16:19,800
containers like an array or hash or any

00:16:17,220 --> 00:16:22,140
or any custom today is that you're gonna

00:16:19,800 --> 00:16:23,970
write you are responsible for marking

00:16:22,140 --> 00:16:27,540
all the objects that are that are in use

00:16:23,970 --> 00:16:29,820
as in use and so they wouldn't be

00:16:27,540 --> 00:16:32,130
garbage collected from under you

00:16:29,820 --> 00:16:34,980
another thing they can see here is you

00:16:32,130 --> 00:16:39,500
know this is how hash does it all the

00:16:34,980 --> 00:16:43,890
built-in classes actually have have a

00:16:39,500 --> 00:16:46,860
they handle in various ways the the mark

00:16:43,890 --> 00:16:49,850
part of the of the prop of the garbage

00:16:46,860 --> 00:16:52,530
collection process okay so this was

00:16:49,850 --> 00:16:56,910
really quick introduction how how the

00:16:52,530 --> 00:16:58,650
array is implemented in C so I went

00:16:56,910 --> 00:17:00,650
ahead and basically implemented my own

00:16:58,650 --> 00:17:03,720
widget which is

00:17:00,650 --> 00:17:05,970
array as my prototype and I try to get

00:17:03,720 --> 00:17:09,240
it to work with GC and all the memory

00:17:05,970 --> 00:17:11,190
allocation requirements of C Ruby so you

00:17:09,240 --> 00:17:13,440
can see here that I create a define a

00:17:11,190 --> 00:17:15,990
class widget that you know inherits from

00:17:13,440 --> 00:17:17,730
object I also declared an allocation

00:17:15,990 --> 00:17:21,150
method that allocates memory for my

00:17:17,730 --> 00:17:23,160
object and I also created a couple of C

00:17:21,150 --> 00:17:26,850
methods the construct on you know widget

00:17:23,160 --> 00:17:30,360
that new I also added inspect and I

00:17:26,850 --> 00:17:33,210
alius inspect to to string as well as I

00:17:30,360 --> 00:17:38,550
created a couple of breadth-first search

00:17:33,210 --> 00:17:41,220
implementation using widget and i can

00:17:38,550 --> 00:17:45,750
show you how it's done here for example

00:17:41,220 --> 00:17:47,460
allocation so here's as i said it's

00:17:45,750 --> 00:17:49,500
pretty much three lines three lines of

00:17:47,460 --> 00:17:51,930
code that all you have to do to actually

00:17:49,500 --> 00:17:54,240
allocate an object so i have my custom

00:17:51,930 --> 00:17:54,570
struct our widget that i'll show you in

00:17:54,240 --> 00:17:58,680
a minute

00:17:54,570 --> 00:18:01,080
and i I basically only declared this tea

00:17:58,680 --> 00:18:04,150
widget constant and I was able to

00:18:01,080 --> 00:18:06,610
basically allocate an object

00:18:04,150 --> 00:18:10,600
next thing initialization this is

00:18:06,610 --> 00:18:14,230
basically widget that new so I only

00:18:10,600 --> 00:18:17,650
handle one argument so what I do I first

00:18:14,230 --> 00:18:20,260
convert to the first argument from from

00:18:17,650 --> 00:18:22,750
from Ruby object here so now I'm too

00:18:20,260 --> 00:18:24,250
long what it does you have to yeah

00:18:22,750 --> 00:18:26,650
there's a lot of utility methods that

00:18:24,250 --> 00:18:30,850
you can use to convert between Ruby

00:18:26,650 --> 00:18:33,100
objects and c c data types and in this

00:18:30,850 --> 00:18:35,860
case i'm able to convert like something

00:18:33,100 --> 00:18:38,350
like fixnum into a long so i can get the

00:18:35,860 --> 00:18:39,820
actual requested length of the of the

00:18:38,350 --> 00:18:43,570
graph that's encapsulated in the widget

00:18:39,820 --> 00:18:45,340
and i do the same thing here and i you

00:18:43,570 --> 00:18:48,360
know i create a graph that's all zeros

00:18:45,340 --> 00:18:52,750
with the size given what when I created

00:18:48,360 --> 00:18:54,880
when I request widget that Neil and I on

00:18:52,750 --> 00:18:57,190
top of that I create the the grid graph

00:18:54,880 --> 00:19:01,930
and I said a pointer to the grid graph

00:18:57,190 --> 00:19:10,090
that I was created so this also required

00:19:01,930 --> 00:19:12,700
me to add in here my widget struct which

00:19:10,090 --> 00:19:18,570
basically has reference to our basic it

00:19:12,700 --> 00:19:21,520
has a length it has a graph and and here

00:19:18,570 --> 00:19:22,960
so this is not complete but this

00:19:21,520 --> 00:19:32,140
basically prints every time there is a

00:19:22,960 --> 00:19:35,080
mark mark GC mark face I basically print

00:19:32,140 --> 00:19:38,680
that my my object was my widget was

00:19:35,080 --> 00:19:42,190
requested to be GC marked so this is

00:19:38,680 --> 00:19:44,200
this is a one way of doing it in Ruby in

00:19:42,190 --> 00:19:45,400
C Ruby and it's kind of complicated you

00:19:44,200 --> 00:19:47,050
can definitely tell that there's a lot

00:19:45,400 --> 00:19:48,820
of things that you have to be careful

00:19:47,050 --> 00:19:51,760
especially with memory management in GC

00:19:48,820 --> 00:19:53,650
it's it's it's do it it's a very good

00:19:51,760 --> 00:19:55,510
exercise because what you can you can do

00:19:53,650 --> 00:19:57,400
you can really learn how Ruby works like

00:19:55,510 --> 00:20:00,100
see Ruby works what's going on how the

00:19:57,400 --> 00:20:02,590
memory is allocated and you can also no

00:20:00,100 --> 00:20:04,120
experience by looking at the code all

00:20:02,590 --> 00:20:06,460
those little bit optimizations that have

00:20:04,120 --> 00:20:09,280
been added to make you to be faster but

00:20:06,460 --> 00:20:13,120
there is also a much faster way to get

00:20:09,280 --> 00:20:17,050
to that to that point so if you that if

00:20:13,120 --> 00:20:17,830
you clone Ruby get github repo you will

00:20:17,050 --> 00:20:19,809
see that there's

00:20:17,830 --> 00:20:23,320
a lot of subfolders but one that's

00:20:19,809 --> 00:20:25,419
really interesting is this ext folder

00:20:23,320 --> 00:20:27,279
where you will find a lot of classes

00:20:25,419 --> 00:20:29,350
that we that we are familiar with like

00:20:27,279 --> 00:20:31,690
for example psych psych they are all

00:20:29,350 --> 00:20:33,279
implemented as extensions to Ruby but

00:20:31,690 --> 00:20:36,720
they are written in C for example psych

00:20:33,279 --> 00:20:40,990
was is written C at least partially and

00:20:36,720 --> 00:20:44,890
you can follow this path which requires

00:20:40,990 --> 00:20:46,690
you only to create two files and it's

00:20:44,890 --> 00:20:51,149
really the one is really really simple

00:20:46,690 --> 00:20:53,590
and you can also use there is a helper

00:20:51,149 --> 00:20:55,269
there's three helper methods that see

00:20:53,590 --> 00:20:58,510
Ruby provides to you that's you that's

00:20:55,269 --> 00:21:01,960
using data data object that basically

00:20:58,510 --> 00:21:04,750
creates an adapter on top of your C

00:21:01,960 --> 00:21:06,820
structs it creates an adapter that is

00:21:04,750 --> 00:21:08,620
aware of garbage collection and it's a

00:21:06,820 --> 00:21:10,269
good good citizen of the garbage

00:21:08,620 --> 00:21:13,990
collected will go away collection word

00:21:10,269 --> 00:21:17,289
word so the first file that you have to

00:21:13,990 --> 00:21:20,320
create is this accession count that Ruby

00:21:17,289 --> 00:21:22,179
if you have created gem or or a library

00:21:20,320 --> 00:21:24,039
that uses C you already probably are

00:21:22,179 --> 00:21:25,830
familiar with this file the only thing

00:21:24,039 --> 00:21:29,309
that you have to do is basically name it

00:21:25,830 --> 00:21:31,659
so I named it adjacency list graph and

00:21:29,309 --> 00:21:34,240
what it will do it will actually create

00:21:31,659 --> 00:21:37,090
a make file for you if you have whatever

00:21:34,240 --> 00:21:39,130
work with C you probably remember the C

00:21:37,090 --> 00:21:40,450
file it makes makes also pretty

00:21:39,130 --> 00:21:42,760
difficult especially if you have a lot

00:21:40,450 --> 00:21:45,399
of dependencies and this pretty much

00:21:42,760 --> 00:21:47,139
takes care of almost everything all you

00:21:45,399 --> 00:21:49,210
have to literally you have to you have

00:21:47,139 --> 00:21:50,830
to write those two lines of code and and

00:21:49,210 --> 00:21:53,380
you are done it will create the the

00:21:50,830 --> 00:21:56,110
proper make file for you and the next

00:21:53,380 --> 00:21:59,649
file is very similar to the widget which

00:21:56,110 --> 00:22:03,370
is that C it's even simpler so we still

00:21:59,649 --> 00:22:06,130
have this init method the only the only

00:22:03,370 --> 00:22:10,500
important thing is that this identifier

00:22:06,130 --> 00:22:12,850
adjacency list graph matches with this

00:22:10,500 --> 00:22:15,549
right they have to be the same the same

00:22:12,850 --> 00:22:18,340
because otherwise C Ruby will not be

00:22:15,549 --> 00:22:20,279
able to initialize your class so what

00:22:18,340 --> 00:22:22,809
I'm doing here I'm defining the class

00:22:20,279 --> 00:22:24,909
you know CIJ since this graph that

00:22:22,809 --> 00:22:27,789
inherits from object I create the

00:22:24,909 --> 00:22:31,190
allocation allocation function as well

00:22:27,789 --> 00:22:34,070
as in basically CI Jason C graph

00:22:31,190 --> 00:22:36,820
graph that new and I have one method

00:22:34,070 --> 00:22:40,010
that executes breadth-first search graph

00:22:36,820 --> 00:22:42,740
breadth-first search on that addiction

00:22:40,010 --> 00:22:45,290
to this graph we can quickly take a look

00:22:42,740 --> 00:22:50,420
at the allocation so what's the most

00:22:45,290 --> 00:22:53,180
important here is that this date data

00:22:50,420 --> 00:22:56,830
makes truck is the helper that suitably

00:22:53,180 --> 00:23:00,260
provides provides us that basically

00:22:56,830 --> 00:23:02,210
provides you an object adapter on top of

00:23:00,260 --> 00:23:04,070
your C Ruby struct and the only thing

00:23:02,210 --> 00:23:05,960
that you have to do you have to provide

00:23:04,070 --> 00:23:07,460
the C type that you are using in this

00:23:05,960 --> 00:23:09,860
case it's a struct called graph

00:23:07,460 --> 00:23:12,800
underscore t you have to provide a

00:23:09,860 --> 00:23:15,170
function that will be called during the

00:23:12,800 --> 00:23:18,050
mark phase of the garbage collection and

00:23:15,170 --> 00:23:19,580
you also have to provide a function that

00:23:18,050 --> 00:23:22,640
will be called where where the memory

00:23:19,580 --> 00:23:24,590
has to be free and you can see that I

00:23:22,640 --> 00:23:26,030
have those methods here so this one

00:23:24,590 --> 00:23:28,400
doesn't have to do anything because I do

00:23:26,030 --> 00:23:31,400
not allocate any Ruby objects everything

00:23:28,400 --> 00:23:33,380
lives in C in my case and you know when

00:23:31,400 --> 00:23:35,180
I when when I have to free the memory I

00:23:33,380 --> 00:23:37,340
basically extract the pointer to the

00:23:35,180 --> 00:23:40,040
graph and I free it because previously I

00:23:37,340 --> 00:23:44,600
basically malloc the I'm out of the

00:23:40,040 --> 00:23:50,240
graph and that's pretty much it except

00:23:44,600 --> 00:23:52,220
the last function which is graph so this

00:23:50,240 --> 00:23:55,250
is the the high-level function that

00:23:52,220 --> 00:23:57,650
interfaces my Ruby code with low-level

00:23:55,250 --> 00:24:02,420
breadth-first search implementation in C

00:23:57,650 --> 00:24:04,490
so I'm using here data get struck which

00:24:02,420 --> 00:24:04,940
is part of the zero B API or what it

00:24:04,490 --> 00:24:07,130
does

00:24:04,940 --> 00:24:10,970
once I allocated and kind of created

00:24:07,130 --> 00:24:13,730
this this shield on top of C Ruby

00:24:10,970 --> 00:24:17,330
structure I can use the date data gets

00:24:13,730 --> 00:24:20,060
tracked to extract the data they to get

00:24:17,330 --> 00:24:23,300
to the C data directly it will basically

00:24:20,060 --> 00:24:25,550
populate that star graph pointer for me

00:24:23,300 --> 00:24:27,650
and I then I can start accessing that

00:24:25,550 --> 00:24:30,950
graph you can see here graph I'm getting

00:24:27,650 --> 00:24:35,200
the length of the graph then then I I

00:24:30,950 --> 00:24:38,930
run at the C pure C implementation of

00:24:35,200 --> 00:24:41,270
the of the breadth-first search and the

00:24:38,930 --> 00:24:43,160
last thing that i have to do so you have

00:24:41,270 --> 00:24:44,570
to remember that so far we were only in

00:24:43,160 --> 00:24:46,759
we were working in c

00:24:44,570 --> 00:24:48,019
if I would pass that data ruby wouldn't

00:24:46,759 --> 00:24:50,149
even know what to do with it because

00:24:48,019 --> 00:24:52,309
it's tightly packed Long's you know in

00:24:50,149 --> 00:24:53,870
an array in a chunk of memory so what we

00:24:52,309 --> 00:24:57,679
have to do we have to actually get that

00:24:53,870 --> 00:24:59,570
data and convert it to a ruby array so

00:24:57,679 --> 00:25:02,539
in this case what I do basically I call

00:24:59,570 --> 00:25:03,919
RB underscore array underscore new which

00:25:02,539 --> 00:25:07,580
basically creates for me

00:25:03,919 --> 00:25:08,990
a ruby array then what you have to do

00:25:07,580 --> 00:25:10,429
you have to be very careful of garbage

00:25:08,990 --> 00:25:11,870
at this point you you have to be a

00:25:10,429 --> 00:25:12,980
little bit careful with garbage

00:25:11,870 --> 00:25:15,529
collection because this is something

00:25:12,980 --> 00:25:18,080
that Michael a CEO who works at pivotal

00:25:15,529 --> 00:25:22,370
he suggested that that I should do this

00:25:18,080 --> 00:25:25,399
basically what it does is it marks this

00:25:22,370 --> 00:25:27,159
trace variable that I declared here that

00:25:25,399 --> 00:25:30,049
it should not be garbage collected

00:25:27,159 --> 00:25:32,809
because what happens here on this line

00:25:30,049 --> 00:25:35,210
is I'm creating a lot of new fixed

00:25:32,809 --> 00:25:40,279
numbers and every time you create a new

00:25:35,210 --> 00:25:42,950
you new a new object in Ruby even

00:25:40,279 --> 00:25:46,700
through long - nom you you run a risk

00:25:42,950 --> 00:25:48,769
that a garbage collection will run and

00:25:46,700 --> 00:25:51,049
this will actually prevent it prevent

00:25:48,769 --> 00:25:53,299
the trace from being garbage collected

00:25:51,049 --> 00:25:56,240
from under you so then you basically

00:25:53,299 --> 00:25:59,059
have a have a you have a loop that grabs

00:25:56,240 --> 00:26:01,399
all the see Ruby values long values and

00:25:59,059 --> 00:26:04,250
adds them to the array as fixed numbers

00:26:01,399 --> 00:26:06,529
then I just unregistered trace 3 the

00:26:04,250 --> 00:26:08,870
memory that I allocated in C and return

00:26:06,529 --> 00:26:11,600
the trace and I can this trace is now a

00:26:08,870 --> 00:26:14,570
fully featured Ruby Ruby array that I

00:26:11,600 --> 00:26:17,690
can use in my Ruby code and this is

00:26:14,570 --> 00:26:20,559
pretty much all you have to do and this

00:26:17,690 --> 00:26:23,360
is so why why I've been doing this I

00:26:20,559 --> 00:26:27,019
kind of knew that C will be faster than

00:26:23,360 --> 00:26:31,029
Ruby because for various reasons and I

00:26:27,019 --> 00:26:33,950
run a couple of tests comparing pure

00:26:31,029 --> 00:26:35,840
pure C implement a pure Ruby

00:26:33,950 --> 00:26:37,639
implementation with super you see Ruby

00:26:35,840 --> 00:26:39,799
implementation and using the same

00:26:37,639 --> 00:26:41,509
algorithm so basically I'm following the

00:26:39,799 --> 00:26:43,340
same steps the only difference that I'm

00:26:41,509 --> 00:26:45,740
the only difference is that I'm not

00:26:43,340 --> 00:26:50,120
using object but I'm using basically

00:26:45,740 --> 00:26:52,970
memory cells in C and I knew it's going

00:26:50,120 --> 00:26:55,530
to be faster and I was able to run some

00:26:52,970 --> 00:26:58,740
benchmarks and

00:26:55,530 --> 00:26:58,740
[Music]

00:26:58,769 --> 00:27:05,799
so here so when you compare it and run

00:27:04,000 --> 00:27:10,600
it when you run both are both

00:27:05,799 --> 00:27:13,740
implementations on sure when you run it

00:27:10,600 --> 00:27:16,840
on a graph with you know 22:56 by 256

00:27:13,740 --> 00:27:18,909
which is 65 thousand nodes see

00:27:16,840 --> 00:27:21,070
implementation only takes roughly 10

00:27:18,909 --> 00:27:24,340
milliseconds and ruby is already at 1

00:27:21,070 --> 00:27:26,590
minute and so c is pretty much hundred

00:27:24,340 --> 00:27:28,659
times faster when you go a little bit

00:27:26,590 --> 00:27:31,450
bigger and you go you know you process a

00:27:28,659 --> 00:27:33,970
graph with 1 million nodes then Ruby

00:27:31,450 --> 00:27:36,850
takes stuff takes taking basically

00:27:33,970 --> 00:27:39,429
minutes and obviously when you go in

00:27:36,850 --> 00:27:42,929
much higher just it just it just takes

00:27:39,429 --> 00:27:47,320
takes days in Ruby when in in C it takes

00:27:42,929 --> 00:27:51,000
roughly hours so why is this happening

00:27:47,320 --> 00:27:53,590
why C is so much faster than than Ruby

00:27:51,000 --> 00:27:56,169
the problem is that when you for example

00:27:53,590 --> 00:27:58,450
allocate all the 65,000 nodes when you

00:27:56,169 --> 00:28:03,130
are doing it in Ruby you actually are

00:27:58,450 --> 00:28:05,470
locating 65,000 object an object each

00:28:03,130 --> 00:28:06,850
object is it's very expensive when

00:28:05,470 --> 00:28:08,919
you're creating in especially if you are

00:28:06,850 --> 00:28:10,960
creating thousands of them then Ruby

00:28:08,919 --> 00:28:13,240
it's starting to starting to show show

00:28:10,960 --> 00:28:14,769
its inefficiency when dealing with a lot

00:28:13,240 --> 00:28:17,100
of data and another thing is that

00:28:14,769 --> 00:28:21,610
objects take usually more memory than

00:28:17,100 --> 00:28:26,080
basic C data types so if you if you

00:28:21,610 --> 00:28:29,049
allocating 65,000 objects' they take

00:28:26,080 --> 00:28:31,480
more memory and you know once you start

00:28:29,049 --> 00:28:33,429
running the processor when runs it

00:28:31,480 --> 00:28:36,580
invalidates all the level one two three

00:28:33,429 --> 00:28:38,769
caches and also the CPU all the

00:28:36,580 --> 00:28:42,700
branching protects prediction and all

00:28:38,769 --> 00:28:45,130
the optimizations that CPU has are kind

00:28:42,700 --> 00:28:48,429
of loose you losing their utility and

00:28:45,130 --> 00:28:50,590
when you run really tight code in C C is

00:28:48,429 --> 00:28:52,570
able to take advantage of the CPU

00:28:50,590 --> 00:28:56,139
optimization and memory caching and

00:28:52,570 --> 00:28:58,960
therefore really quickly C is able to

00:28:56,139 --> 00:29:02,289
outperform pretty much every object in

00:28:58,960 --> 00:29:05,830
the language and you can see it

00:29:02,289 --> 00:29:08,220
definitely here so so what what's the

00:29:05,830 --> 00:29:10,890
conclusion that I would like to

00:29:08,220 --> 00:29:12,480
tell you well the first thing is that

00:29:10,890 --> 00:29:14,909
Serie B is actually really easy to

00:29:12,480 --> 00:29:16,799
understand you saw when just by looking

00:29:14,909 --> 00:29:18,929
at a raid at C you really quickly can

00:29:16,799 --> 00:29:20,520
can understand what's going on what's

00:29:18,929 --> 00:29:22,830
going on what kind of methods are

00:29:20,520 --> 00:29:24,539
implemented what they are doing so we

00:29:22,830 --> 00:29:27,030
can really quickly get your bearings

00:29:24,539 --> 00:29:28,740
another thing the only complicated part

00:29:27,030 --> 00:29:31,409
is GC dealing with garbage collection

00:29:28,740 --> 00:29:35,100
what what you can do the second method

00:29:31,409 --> 00:29:38,580
that I showed you by using a data data

00:29:35,100 --> 00:29:42,870
object they tell the rapper data a

00:29:38,580 --> 00:29:44,730
rapper you can simplify that and really

00:29:42,870 --> 00:29:47,370
quickly you can write rewrite your code

00:29:44,730 --> 00:29:50,159
that it was slow in Ruby and we write in

00:29:47,370 --> 00:29:51,990
C and still have your high abstractions

00:29:50,159 --> 00:29:55,940
in Ruby where you are really productive

00:29:51,990 --> 00:30:00,350
and take advantage of speed of C and

00:29:55,940 --> 00:30:00,350
implement all your number crunching in C

00:30:05,060 --> 00:30:44,049
[Applause]

00:30:12,520 --> 00:30:44,049

YouTube URL: https://www.youtube.com/watch?v=0ZzGhHdWJnY


