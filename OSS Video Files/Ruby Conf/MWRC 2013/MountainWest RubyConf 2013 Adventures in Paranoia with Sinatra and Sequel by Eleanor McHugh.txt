Title: MountainWest RubyConf 2013 Adventures in Paranoia with Sinatra and Sequel by Eleanor McHugh
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	This session is a jolly romp through the realm of practical data privacy using pure Ruby. We'll start by looking at how to obfuscate data using Ruby's OpenSSL bindings, exploring the possibilities of symmetric and public key cryptography as well as the role of hashing algorithms.
Once the basic principles have been established we'll turn our attention to designing databases with a strong privacy component, using Sequel to demonstrate how encrypted keys can be used to support privacy in the relational model. There will be some meta-programming involved which should also be of interest to ActiveRecord users. This will naturally lead into a brief discussion of the seeming difficulty of searching encrypted data along with a strategy for making this practical.
We'll round out the session by turning our attention to the transport layer with a simple scheme for securing web application sessions using a custom Rack middleware.
The discussion will be backed by code examples inspired by real-world systems.

Help us caption & translate this video!

http://amara.org/v/FGbS/
Captions: 
	00:00:19,699 --> 00:00:26,160
okay um yeah be kind of brutal with me

00:00:24,720 --> 00:00:30,269
because this has to go in 30 minutes and

00:00:26,160 --> 00:00:32,189
there's 180 slides okay it's not as bad

00:00:30,269 --> 00:00:33,120
as it sounds quite a lot of code where

00:00:32,189 --> 00:00:35,159
there's quite a lot of slides that

00:00:33,120 --> 00:00:36,690
explain a single piece of code because

00:00:35,159 --> 00:00:41,790
there's a lot of code in here and before

00:00:36,690 --> 00:00:43,379
it there's a lot of wuffle so yep I'll

00:00:41,790 --> 00:00:44,940
make some kind of gesture when orders go

00:00:43,379 --> 00:00:49,229
firstly I've got you all here I'm do a

00:00:44,940 --> 00:00:50,939
bit of a false pretense I never planned

00:00:49,229 --> 00:00:53,159
this is a 30 minute talk I planned it's

00:00:50,939 --> 00:00:56,280
a 45 so I've cut everything to do with

00:00:53,159 --> 00:00:57,570
Sinatra that's nothing against an ultra

00:00:56,280 --> 00:00:59,879
it's just I'm very rational and logical

00:00:57,570 --> 00:01:01,049
when I build a slide deck and I tunnel

00:00:59,879 --> 00:01:03,269
my way up from the bottom of what I'm

00:01:01,049 --> 00:01:06,619
talking about and Sinatra is the top of

00:01:03,269 --> 00:01:08,880
what I was going to talk about so and

00:01:06,619 --> 00:01:11,689
there's always a caveat because every

00:01:08,880 --> 00:01:13,979
bit of code I ever present is dangerous

00:01:11,689 --> 00:01:15,990
partly because it probably doesn't work

00:01:13,979 --> 00:01:17,460
as intended and partly because it's

00:01:15,990 --> 00:01:23,550
often dealing with things that most of

00:01:17,460 --> 00:01:28,950
us don't know a lot about so very

00:01:23,550 --> 00:01:29,909
important disclaimers worse than not

00:01:28,950 --> 00:01:32,970
being too qualified security

00:01:29,909 --> 00:01:34,409
professional I'm a next physicist so I

00:01:32,970 --> 00:01:38,760
approached everything involving data

00:01:34,409 --> 00:01:40,670
with a very strange perspective go we're

00:01:38,760 --> 00:01:43,860
going to talk about two things basically

00:01:40,670 --> 00:01:52,500
adventure and here's a nice dictionary

00:01:43,860 --> 00:01:56,180
definition of it and paranoia the real

00:01:52,500 --> 00:01:56,180
meaning of paranoia in internet systems

00:01:58,410 --> 00:02:05,800
okay so everything that we do on the net

00:02:02,800 --> 00:02:08,050
involves trust somehow we have to anchor

00:02:05,800 --> 00:02:09,760
trust we have to make sure we know who

00:02:08,050 --> 00:02:10,840
we're dealing with and they have to be

00:02:09,760 --> 00:02:14,020
certain that they know who they're

00:02:10,840 --> 00:02:18,460
dealing with as well and building a web

00:02:14,020 --> 00:02:20,800
app most of the time we rely on other

00:02:18,460 --> 00:02:22,780
people's ideas of how to do that and we

00:02:20,800 --> 00:02:25,270
don't look under the hood at how to do

00:02:22,780 --> 00:02:28,570
things and therefore one day things bite

00:02:25,270 --> 00:02:32,350
us so today we're going to start with a

00:02:28,570 --> 00:02:36,010
brutally low-level pure Ruby approach to

00:02:32,350 --> 00:02:37,960
doing our own security badly doing it

00:02:36,010 --> 00:02:43,300
well is an exercise to everybody who

00:02:37,960 --> 00:02:47,620
reads this deck there's a very simple

00:02:43,300 --> 00:02:49,420
recipe for securing anything you want to

00:02:47,620 --> 00:02:52,540
have a well-known presence somewhere a

00:02:49,420 --> 00:02:55,600
place that you can guarantee it people

00:02:52,540 --> 00:02:57,820
confined you and you want to make sure

00:02:55,600 --> 00:03:02,770
that everybody you deal with is globally

00:02:57,820 --> 00:03:04,570
unique this idea of accepting or pake

00:03:02,770 --> 00:03:05,920
credentials is that the only person you

00:03:04,570 --> 00:03:10,530
should understand the credentials are

00:03:05,920 --> 00:03:13,090
come in are you not the outside world

00:03:10,530 --> 00:03:16,930
storage and transport sort of go without

00:03:13,090 --> 00:03:19,660
saying really and then the separation of

00:03:16,930 --> 00:03:21,280
authentication and authorization means

00:03:19,660 --> 00:03:22,840
that if somebody breaks one half of your

00:03:21,280 --> 00:03:27,010
security they don't necessarily

00:03:22,840 --> 00:03:28,090
compromise the other half so and we're

00:03:27,010 --> 00:03:29,890
very going to really talk about four

00:03:28,090 --> 00:03:33,600
bits of that today because all of that

00:03:29,890 --> 00:03:33,600
together would be a couple of hours

00:03:33,989 --> 00:03:42,340
first globally unique identifier secure

00:03:39,850 --> 00:03:46,209
random lives in Ruby standard library

00:03:42,340 --> 00:03:47,620
and it basically wraps / dev / e random

00:03:46,209 --> 00:03:51,580
and things like that and it will give

00:03:47,620 --> 00:03:54,730
you genuine random numbers and when you

00:03:51,580 --> 00:03:56,920
want to have a unique identity it's good

00:03:54,730 --> 00:04:01,450
to start with a random number and the

00:03:56,920 --> 00:04:03,489
uuid in their uses a RFC I can't me with

00:04:01,450 --> 00:04:06,819
its 42 12 or something like that anyway

00:04:03,489 --> 00:04:11,230
it's all in the documentation highway

00:04:06,819 --> 00:04:13,120
yeah and the opaque credentials means we

00:04:11,230 --> 00:04:15,849
want to hash stuff because hashes are

00:04:13,120 --> 00:04:18,250
one way so people can't come back from

00:04:15,849 --> 00:04:21,699
what they get to what we had to start

00:04:18,250 --> 00:04:24,099
with we only need hashes because we can

00:04:21,699 --> 00:04:25,330
match on hashes but how she's don't give

00:04:24,099 --> 00:04:29,410
away what somebody else thought was a

00:04:25,330 --> 00:04:32,080
useful secret and we're going to talk

00:04:29,410 --> 00:04:34,840
only in terms of char 512 that char two

00:04:32,080 --> 00:04:38,250
at 512 bits and I know there many people

00:04:34,840 --> 00:04:41,949
who like to use bcrypt for doing all

00:04:38,250 --> 00:04:45,070
kinds of stuff in there crypto sha-512

00:04:41,949 --> 00:04:48,729
has advantages that it's part of flips

00:04:45,070 --> 00:04:51,070
180 or 190 to I don't do numbers well on

00:04:48,729 --> 00:04:52,389
stage for memory but basically you can

00:04:51,070 --> 00:04:53,680
get away with using it with banks and

00:04:52,389 --> 00:04:55,449
you can get away with using it for

00:04:53,680 --> 00:04:56,530
government whereas bcrypt you can't get

00:04:55,449 --> 00:04:59,320
away with using with banks and

00:04:56,530 --> 00:05:02,889
government we're also going to talk

00:04:59,320 --> 00:05:05,110
about public key crypto we're going to

00:05:02,889 --> 00:05:06,940
which is our essay we're going to talk

00:05:05,110 --> 00:05:08,919
about symmetric ciphers with AES and

00:05:06,940 --> 00:05:11,979
we're also going to talk about only ever

00:05:08,919 --> 00:05:13,259
using keys once although I co to

00:05:11,979 --> 00:05:17,500
demonstrate that he's not here today

00:05:13,259 --> 00:05:19,060
I've finally we're going to think about

00:05:17,500 --> 00:05:25,990
secure transport but we're not going to

00:05:19,060 --> 00:05:29,229
have time to get into it we are however

00:05:25,990 --> 00:05:32,500
going to get to play with H map those

00:05:29,229 --> 00:05:34,090
are message authentification hashes so

00:05:32,500 --> 00:05:36,550
they give you even less info from a hash

00:05:34,090 --> 00:05:38,110
than the hash itself does which makes

00:05:36,550 --> 00:05:42,250
them very handy for doing fingerprints

00:05:38,110 --> 00:05:44,949
fine um Ruby's actually really good for

00:05:42,250 --> 00:05:48,610
crypto because it's got an open SSL

00:05:44,949 --> 00:05:53,440
binding and it's not always the best of

00:05:48,610 --> 00:05:55,030
openssl bindings there have been

00:05:53,440 --> 00:05:57,280
troubles with it in the past and it I

00:05:55,030 --> 00:05:59,530
can't company for example get Ruby to to

00:05:57,280 --> 00:06:02,199
build under snow leopard because I can't

00:05:59,530 --> 00:06:04,659
get it to bind to the version of openssl

00:06:02,199 --> 00:06:07,530
I've actually got on but overall Ruby is

00:06:04,659 --> 00:06:10,659
a pretty good language to decrypt her in

00:06:07,530 --> 00:06:12,099
so first off secure vandamm is an

00:06:10,659 --> 00:06:14,530
actually part of openssl this just comes

00:06:12,099 --> 00:06:16,810
with Ruby simple example of generating a

00:06:14,530 --> 00:06:19,330
byte stream

00:06:16,810 --> 00:06:20,830
I couldn't really think of a useful

00:06:19,330 --> 00:06:23,790
example so this just generates a

00:06:20,830 --> 00:06:25,660
randomly long string of random stuff

00:06:23,790 --> 00:06:31,090
they're all kinds of places where that's

00:06:25,660 --> 00:06:32,620
useful in communications openssl you

00:06:31,090 --> 00:06:35,800
either love it or you hate it nearly

00:06:32,620 --> 00:06:38,790
everybody I know hates it especially

00:06:35,800 --> 00:06:42,250
security people however it keeps them in

00:06:38,790 --> 00:06:47,290
shiny toys and probably as a pension

00:06:42,250 --> 00:06:50,160
scheme for the rest of their lives so

00:06:47,290 --> 00:06:52,050
first char two cryptographic hashes

00:06:50,160 --> 00:06:54,700
these are one these are one-way

00:06:52,050 --> 00:06:57,220
algorithms where you pump some data in

00:06:54,700 --> 00:06:59,889
and it turns it into something that's a

00:06:57,220 --> 00:07:01,840
more entropic form of it that means it's

00:06:59,889 --> 00:07:04,750
noisy and you can't go back to what you

00:07:01,840 --> 00:07:06,040
started with basically a lot of stuff in

00:07:04,750 --> 00:07:09,270
cryptography is to do with increasing

00:07:06,040 --> 00:07:13,380
entropy of things making things look

00:07:09,270 --> 00:07:15,490
ugly I think the best way to put it and

00:07:13,380 --> 00:07:17,800
here we got a simple example I've

00:07:15,490 --> 00:07:21,280
written wrapper classes for all of these

00:07:17,800 --> 00:07:23,740
things in here because the standard the

00:07:21,280 --> 00:07:24,970
standard way of using openssl is to keep

00:07:23,740 --> 00:07:26,620
me initializing stuff that you're going

00:07:24,970 --> 00:07:29,140
and really I quite like to just create

00:07:26,620 --> 00:07:36,160
objects that have keys and stuff in them

00:07:29,140 --> 00:07:40,240
keep them live so so first up you have

00:07:36,160 --> 00:07:41,530
to create some kind so in this case

00:07:40,240 --> 00:07:44,650
we're going to keep full piece of

00:07:41,530 --> 00:07:46,810
information about it we're going to keep

00:07:44,650 --> 00:07:49,570
the digest itself we're going to keep a

00:07:46,810 --> 00:07:51,190
salt value which we shove in to create

00:07:49,570 --> 00:07:53,229
even more entropy in the string that

00:07:51,190 --> 00:07:54,760
comes out we're going to keep a number

00:07:53,229 --> 00:07:56,440
of rounds because that's our workload

00:07:54,760 --> 00:07:58,030
and we're going to go round and round

00:07:56,440 --> 00:08:00,700
and round 100,000 times on average

00:07:58,030 --> 00:08:02,889
whenever we do a hat that's really cheap

00:08:00,700 --> 00:08:04,810
it sounds awfully expensive but it's

00:08:02,889 --> 00:08:06,340
really cheap and the main thing it does

00:08:04,810 --> 00:08:08,020
it means if somebody else wants to crack

00:08:06,340 --> 00:08:10,720
a hash when they find it they've got to

00:08:08,020 --> 00:08:13,120
get how many rounds you did so in a

00:08:10,720 --> 00:08:15,550
secure app you make that use a specific

00:08:13,120 --> 00:08:16,660
number so that every hash in your

00:08:15,550 --> 00:08:18,520
database has a different number of

00:08:16,660 --> 00:08:21,330
rounds and then you store that in a

00:08:18,520 --> 00:08:23,680
separate system so nobody can look at it

00:08:21,330 --> 00:08:27,310
trivial very inexpensive makes it very

00:08:23,680 --> 00:08:28,510
difficult for people to use rainbow

00:08:27,310 --> 00:08:30,200
attacks which your way of building big

00:08:28,510 --> 00:08:33,560
tables full of nothing but

00:08:30,200 --> 00:08:35,480
hashes that they can then map back I'm

00:08:33,560 --> 00:08:40,630
also going to keep a signing key and

00:08:35,480 --> 00:08:43,970
that's how we generate a H Mac so far

00:08:40,630 --> 00:08:47,750
we've got to do some kind of encoding to

00:08:43,970 --> 00:08:50,030
actually make this useful and this is

00:08:47,750 --> 00:08:52,220
trivial stuff i mean at each step we get

00:08:50,030 --> 00:08:53,360
a hex digest we passed the hex digest

00:08:52,220 --> 00:08:56,810
back in and we get another one and go

00:08:53,360 --> 00:09:02,660
around around it's dull code and that's

00:08:56,810 --> 00:09:05,870
how you sign things so that is a shower

00:09:02,660 --> 00:09:10,580
to class in all its glory with iterative

00:09:05,870 --> 00:09:14,630
workload and signing Keys fire okay I a

00:09:10,580 --> 00:09:16,280
yes this is the crypto that we all think

00:09:14,630 --> 00:09:18,140
about when we're kids and we read spy

00:09:16,280 --> 00:09:19,670
books and they tell us that we can have

00:09:18,140 --> 00:09:22,640
ciphers that can go this way and then

00:09:19,670 --> 00:09:24,200
back again um AES is slightly more

00:09:22,640 --> 00:09:26,150
complicated than that uses all kinds of

00:09:24,200 --> 00:09:28,880
modular arithmetic to make that quite

00:09:26,150 --> 00:09:30,650
difficult to crack but basically it's no

00:09:28,880 --> 00:09:35,390
difference to a letter substitution in

00:09:30,650 --> 00:09:37,790
concept I'm wrapping it up yet again is

00:09:35,390 --> 00:09:40,940
quite easy I come up with a slightly

00:09:37,790 --> 00:09:42,170
different API for this firstly there are

00:09:40,940 --> 00:09:45,740
two pieces of information are actually

00:09:42,170 --> 00:09:47,210
important in a yes one is the actual key

00:09:45,740 --> 00:09:50,450
you're going to use and the other is a

00:09:47,210 --> 00:09:51,500
random initialization vector so you want

00:09:50,450 --> 00:09:53,750
to keep both of those bits of

00:09:51,500 --> 00:09:56,210
information and sometimes when you

00:09:53,750 --> 00:09:57,710
transfer the key around well sometimes

00:09:56,210 --> 00:09:59,840
when you transfer around the encrypted

00:09:57,710 --> 00:10:01,040
thing you want to transfer around the

00:09:59,840 --> 00:10:02,660
initialization vector because without

00:10:01,040 --> 00:10:04,850
the initialization vector even if you

00:10:02,660 --> 00:10:06,290
have the key you can't get back but the

00:10:04,850 --> 00:10:08,090
initialize invasion vector you can pass

00:10:06,290 --> 00:10:10,420
around because cryptographers say it's

00:10:08,090 --> 00:10:13,970
safe to do it where's the key it isn't

00:10:10,420 --> 00:10:17,150
so I've never quite understood that

00:10:13,970 --> 00:10:18,800
myself we also have this little thing

00:10:17,150 --> 00:10:20,030
called update because under the hood

00:10:18,800 --> 00:10:25,460
we're going to want to do this a couple

00:10:20,030 --> 00:10:27,170
of times that's just enjoying this but

00:10:25,460 --> 00:10:29,810
I'm not going to talk at all about that

00:10:27,170 --> 00:10:31,280
dangling CBC at the end there are

00:10:29,810 --> 00:10:32,870
several different modes in which you can

00:10:31,280 --> 00:10:35,660
use AES some of which are designed for

00:10:32,870 --> 00:10:37,760
using with streams of data others are

00:10:35,660 --> 00:10:39,800
designed for using blocks of data and

00:10:37,760 --> 00:10:42,650
some are if you want you to encrypt your

00:10:39,800 --> 00:10:45,910
whole hard drive CBC happens to be

00:10:42,650 --> 00:10:45,910
generally quite used

00:10:46,649 --> 00:10:52,330
also you'll notice that the Ruby opener

00:10:50,230 --> 00:10:55,089
self ssl stuff will quite happily

00:10:52,330 --> 00:10:57,130
generate keys for you and IVs for you

00:10:55,089 --> 00:10:59,019
you want the only way you can never

00:10:57,130 --> 00:11:01,480
capture those is at the point here where

00:10:59,019 --> 00:11:05,079
you generate them because there's no way

00:11:01,480 --> 00:11:08,320
to then ask an aes cipher what its keen

00:11:05,079 --> 00:11:12,790
is ivy were so that's why this rapper is

00:11:08,320 --> 00:11:15,070
here and then encoding it's quite

00:11:12,790 --> 00:11:16,390
trivial you always reset the cipher if

00:11:15,070 --> 00:11:18,880
you want to do stuff and then do an ink

00:11:16,390 --> 00:11:21,670
wit encrypt and I like to store off keys

00:11:18,880 --> 00:11:31,390
and IVs again for reasons that I don't

00:11:21,670 --> 00:11:34,300
really want to go into that bit of code

00:11:31,390 --> 00:11:36,160
at the bottom is a nasty nasty outcome

00:11:34,300 --> 00:11:40,779
of my three and a half years as go

00:11:36,160 --> 00:11:42,790
programmer normally we just chuck some

00:11:40,779 --> 00:11:44,380
data in there and if it turned out it

00:11:42,790 --> 00:11:46,060
wasn't a string we'd catch an exception

00:11:44,380 --> 00:11:49,240
further up that can be quite confusing

00:11:46,060 --> 00:11:51,880
in a crypto program so generally if

00:11:49,240 --> 00:11:55,810
something doesn't turn into a string I

00:11:51,880 --> 00:11:58,990
rescue it there and use a blankly will

00:11:55,810 --> 00:12:00,880
see that a couple of more times d code

00:11:58,990 --> 00:12:02,680
is really just encode the other way

00:12:00,880 --> 00:12:03,940
around but we do a little bit of extra

00:12:02,680 --> 00:12:05,410
checking to make sure we got something

00:12:03,940 --> 00:12:07,120
that's actually got some length because

00:12:05,410 --> 00:12:11,380
we should be passing back in your value

00:12:07,120 --> 00:12:12,940
if we don't successfully decode um and

00:12:11,380 --> 00:12:14,350
this is the packing stuff up into an

00:12:12,940 --> 00:12:19,810
array I hope all of you are familiar

00:12:14,350 --> 00:12:22,270
with the way back I'm just using the

00:12:19,810 --> 00:12:24,610
standard binary for an away but there's

00:12:22,270 --> 00:12:25,959
also bourbon coding in there for people

00:12:24,610 --> 00:12:30,160
who wants to asn.1 and stuff like that

00:12:25,959 --> 00:12:36,430
so oh and this is just the same thing

00:12:30,160 --> 00:12:38,050
but with ya unpacking once you yeah okay

00:12:36,430 --> 00:12:42,550
always say this is more interesting

00:12:38,050 --> 00:12:43,720
stuff it's mostly because a lot of

00:12:42,550 --> 00:12:47,050
people put a lot more faith in this and

00:12:43,720 --> 00:12:49,899
they should write think about public key

00:12:47,050 --> 00:12:52,420
encryption is it's not actually very

00:12:49,899 --> 00:12:53,620
strong on a particular bit length we're

00:12:52,420 --> 00:12:55,120
just relying on the fact that we have

00:12:53,620 --> 00:12:56,209
two separate keys and they're both

00:12:55,120 --> 00:12:58,970
bloody long

00:12:56,209 --> 00:13:02,449
so I think there's a note in wikipedia

00:12:58,970 --> 00:13:04,850
that 768 bit RSA has now been broken

00:13:02,449 --> 00:13:08,360
which is quite disturbing for people who

00:13:04,850 --> 00:13:10,699
are still using 256 bit RSA on things as

00:13:08,360 --> 00:13:12,679
time goes on it's an exponential problem

00:13:10,699 --> 00:13:14,300
to try and crack it but as we know

00:13:12,679 --> 00:13:19,429
Moore's law tends to make things a lot

00:13:14,300 --> 00:13:22,339
faster anyway so similar sort of rapper

00:13:19,429 --> 00:13:24,050
but this is a lot simpler there's very

00:13:22,339 --> 00:13:27,800
little extra that one would want to do

00:13:24,050 --> 00:13:29,779
with it should auto fill in some color

00:13:27,800 --> 00:13:32,420
and stuff so firstly we're going to

00:13:29,779 --> 00:13:35,059
create a private key public private key

00:13:32,420 --> 00:13:37,429
pair this will allow you to pass in a

00:13:35,059 --> 00:13:41,269
key or it will work from key size I find

00:13:37,429 --> 00:13:43,040
that quite a nice API next up it should

00:13:41,269 --> 00:13:45,139
probably talk about these two things you

00:13:43,040 --> 00:13:47,179
could always get a publishable full

00:13:45,139 --> 00:13:50,749
version of both the public and private

00:13:47,179 --> 00:13:54,920
key so as PEM files of what you known

00:13:50,749 --> 00:13:57,559
you pass these around us and then

00:13:54,920 --> 00:14:01,009
encrypt and decrypt are trivial we don't

00:13:57,559 --> 00:14:02,749
have to do anything with those so I

00:14:01,009 --> 00:14:04,129
where it becomes more interesting of

00:14:02,749 --> 00:14:07,399
course is we want to store encrypted

00:14:04,129 --> 00:14:09,889
data there are many ways of doing this

00:14:07,399 --> 00:14:10,970
and most of them are bad some of the

00:14:09,889 --> 00:14:12,499
stuff i'm going to show is quite bad

00:14:10,970 --> 00:14:17,179
because it doesn't go as far as it

00:14:12,499 --> 00:14:21,740
should do hmmm Oh 13 minutes may just be

00:14:17,179 --> 00:14:23,449
possible ok fine ok so we're going to do

00:14:21,740 --> 00:14:24,679
this with sequel because the project I

00:14:23,449 --> 00:14:26,209
was working on my I built particular

00:14:24,679 --> 00:14:29,299
thing that I decided to extract this

00:14:26,209 --> 00:14:31,509
kind of code from I decided to use

00:14:29,299 --> 00:14:34,100
sequel because I happen to like sequel

00:14:31,509 --> 00:14:35,480
nothing more than that everything we're

00:14:34,100 --> 00:14:39,049
going to do here can be done in active

00:14:35,480 --> 00:14:42,110
record so and that's kind of neat

00:14:39,049 --> 00:14:43,369
because there's a magic in there so

00:14:42,110 --> 00:14:45,889
first off this is the sort of thing you

00:14:43,369 --> 00:14:49,369
might find in a database as an account

00:14:45,889 --> 00:14:52,879
table for user a name and an email

00:14:49,369 --> 00:14:55,040
address some indexing I think if you

00:14:52,879 --> 00:14:56,329
click it should fill in some stuff and

00:14:55,040 --> 00:14:58,670
talk about it there's some stuff that's

00:14:56,329 --> 00:15:01,970
specific to sequel which is to do with

00:14:58,670 --> 00:15:04,790
the ddl coming up is a plug-in via

00:15:01,970 --> 00:15:07,580
schema and then there's validation

00:15:04,790 --> 00:15:16,490
helpers which does he's nice validate

00:15:07,580 --> 00:15:19,280
um go back one you want take it yep back

00:15:16,490 --> 00:15:21,980
to this is the trouble we putting auto

00:15:19,280 --> 00:15:23,480
bombs in right you'll notice up here

00:15:21,980 --> 00:15:25,130
we've got a primary key this we're not

00:15:23,480 --> 00:15:26,510
specify what the type is that's going to

00:15:25,130 --> 00:15:28,520
be a 32-bit interview and that's going

00:15:26,510 --> 00:15:30,950
to be Auto incremented on the table this

00:15:28,520 --> 00:15:32,210
is a stupid idea for any kind of

00:15:30,950 --> 00:15:33,890
database that's going to track unique

00:15:32,210 --> 00:15:38,660
identities so the first thing we're

00:15:33,890 --> 00:15:39,650
going to do is solve that and what we're

00:15:38,660 --> 00:15:41,120
going to do is you just basically going

00:15:39,650 --> 00:15:43,460
to say primary keys just happen to be

00:15:41,120 --> 00:15:45,350
some string of bytes we don't really

00:15:43,460 --> 00:15:46,100
care what the bites are and we're not

00:15:45,350 --> 00:15:49,070
gonna say anything about how they

00:15:46,100 --> 00:15:50,780
generated yet in sequel this means we

00:15:49,070 --> 00:15:52,460
actually have to use this unrestrictor

00:15:50,780 --> 00:15:54,710
I'm wiki directive otherwise we get all

00:15:52,460 --> 00:15:56,230
kinds of errors and it's also kind of

00:15:54,710 --> 00:15:58,550
nice if we validate that that is unique

00:15:56,230 --> 00:16:04,490
because now we can't guarantee this

00:15:58,550 --> 00:16:08,960
uniquely incremented so what do I put

00:16:04,490 --> 00:16:10,460
that one there keep going ok so the

00:16:08,960 --> 00:16:11,900
first thing is there's quite a lot of oh

00:16:10,460 --> 00:16:13,430
yeah that's because there's a lack of

00:16:11,900 --> 00:16:14,420
dryness in that so the first thing I'm

00:16:13,430 --> 00:16:17,560
going to do is we're going to introduce

00:16:14,420 --> 00:16:24,260
a model module so if you go back to the

00:16:17,560 --> 00:16:26,390
previous you might have to go back to ok

00:16:24,260 --> 00:16:27,800
I mean this is quite trivial stuff we're

00:16:26,390 --> 00:16:29,360
just going to do a bit mod eval and

00:16:27,800 --> 00:16:32,090
we're going to shove something in and

00:16:29,360 --> 00:16:35,120
we're going to use the module to bind a

00:16:32,090 --> 00:16:36,440
couple of plugins on so far off there's

00:16:35,120 --> 00:16:42,650
quite a lot of more Julie value in here

00:16:36,440 --> 00:16:44,330
so yeah because what we're going to do

00:16:42,650 --> 00:16:47,120
is we're going to basically build our

00:16:44,330 --> 00:16:48,980
own language to handle the encryption

00:16:47,120 --> 00:16:50,300
automatically so that we can write to

00:16:48,980 --> 00:16:51,800
and reef in the database without ever

00:16:50,300 --> 00:16:57,680
having to care there's an encrypted data

00:16:51,800 --> 00:17:00,020
in it so and we're also going to stick

00:16:57,680 --> 00:17:01,820
this retrieve on because it will come in

00:17:00,020 --> 00:17:05,780
handy at some point it just happened to

00:17:01,820 --> 00:17:07,490
look nice here and we're going to put a

00:17:05,780 --> 00:17:13,250
binding on so that we can actually check

00:17:07,490 --> 00:17:16,010
entity identity convenience really so

00:17:13,250 --> 00:17:19,189
I do believe these things sometimes keep

00:17:16,010 --> 00:17:20,630
going okay we've actually got to think

00:17:19,189 --> 00:17:22,459
that about how it going to generate IDs

00:17:20,630 --> 00:17:24,260
in the application that i was working on

00:17:22,459 --> 00:17:26,660
we did not generate ideas using secure

00:17:24,260 --> 00:17:28,520
random we generated IDs based on

00:17:26,660 --> 00:17:30,020
specific other properties because we

00:17:28,520 --> 00:17:31,910
wanted to be able to have them in

00:17:30,020 --> 00:17:35,840
chronological order and that's a whole

00:17:31,910 --> 00:17:39,070
different can of worms but for just

00:17:35,840 --> 00:17:41,780
random unique ideas this is good and

00:17:39,070 --> 00:17:45,080
then we're going to automatically assign

00:17:41,780 --> 00:17:48,020
that ID when we actually create the

00:17:45,080 --> 00:17:49,510
record so you just write a record you

00:17:48,020 --> 00:17:53,480
never have to worry about creating an ID

00:17:49,510 --> 00:17:54,980
so we've got some other stuff in there

00:17:53,480 --> 00:17:57,560
that I'm not really happy about people

00:17:54,980 --> 00:17:59,210
seeing I mean it kind of makes me feel

00:17:57,560 --> 00:18:01,460
nervous that somebody might physically

00:17:59,210 --> 00:18:03,560
get at the database and see the email

00:18:01,460 --> 00:18:07,310
addresses of all my use it so we're now

00:18:03,560 --> 00:18:08,540
going to make that problem go away this

00:18:07,310 --> 00:18:10,730
means we got to introduce some kind of

00:18:08,540 --> 00:18:11,570
encryption to the model and this means

00:18:10,730 --> 00:18:14,780
you're going to have a whole pile more

00:18:11,570 --> 00:18:16,630
metaprogramming Stuart so first up we're

00:18:14,780 --> 00:18:18,560
going to have some encrypted fields

00:18:16,630 --> 00:18:19,820
because it kind of nice to say those

00:18:18,560 --> 00:18:20,780
fields are all encryption and then we

00:18:19,820 --> 00:18:25,190
can deal with all of them in one

00:18:20,780 --> 00:18:27,610
directive and so there we are encrypted

00:18:25,190 --> 00:18:29,720
fields you manager this does nothing yet

00:18:27,610 --> 00:18:31,190
this is my equivalent of live coding

00:18:29,720 --> 00:18:33,220
because i'ma lousy of that so I do it's

00:18:31,190 --> 00:18:35,240
sorta like for three days in advance so

00:18:33,220 --> 00:18:37,310
first we want to talk about field

00:18:35,240 --> 00:18:38,840
encryption and just to give ourselves a

00:18:37,310 --> 00:18:43,540
bit of an extra challenge we want to be

00:18:38,840 --> 00:18:45,890
able to search the encrypted field so

00:18:43,540 --> 00:18:47,750
this means we want to be automatically

00:18:45,890 --> 00:18:49,310
encrypt when restore we want to

00:18:47,750 --> 00:18:52,940
automatically decrypt when we retrieve

00:18:49,310 --> 00:18:55,340
and without encrypting or decrypting we

00:18:52,940 --> 00:18:56,750
want to do an equality search so we can

00:18:55,340 --> 00:19:03,800
match records based on the Equality for

00:18:56,750 --> 00:19:05,900
something yeah this is basically the

00:19:03,800 --> 00:19:09,740
pseudocode for what it is Ruby its

00:19:05,900 --> 00:19:12,380
executable so we're going to start off

00:19:09,740 --> 00:19:17,180
with the field encryption so we need to

00:19:12,380 --> 00:19:19,520
create some basically every single model

00:19:17,180 --> 00:19:21,050
needs to have a symmetric well

00:19:19,520 --> 00:19:23,210
potentially every single field needs to

00:19:21,050 --> 00:19:26,020
have its own symmetric key so this will

00:19:23,210 --> 00:19:28,210
just basically automatically set up and

00:19:26,020 --> 00:19:31,480
a symmetric key for particular field by

00:19:28,210 --> 00:19:33,070
off engine we're going to have to add in

00:19:31,480 --> 00:19:35,290
a pair of extra blobs we need to keep

00:19:33,070 --> 00:19:37,990
the key and the ivy and anybody who

00:19:35,290 --> 00:19:40,300
doesn't obviously spot that this is not

00:19:37,990 --> 00:19:45,670
how they should be stored isn't doing

00:19:40,300 --> 00:19:48,220
the job so far off and this is just

00:19:45,670 --> 00:19:49,660
basically create key do some stuff this

00:19:48,220 --> 00:19:54,820
is dull code so as soon as it gets the

00:19:49,660 --> 00:19:56,770
end of the auto flip it so we then need

00:19:54,820 --> 00:20:02,140
field validation this is also going to

00:19:56,770 --> 00:20:08,500
be trivial we're just injecting some

00:20:02,140 --> 00:20:11,050
more stuff exciting equality surges how

00:20:08,500 --> 00:20:13,540
do you search and encrypted database for

00:20:11,050 --> 00:20:16,000
encrypted things I should warn you in

00:20:13,540 --> 00:20:18,640
advance this is not guaranteed to only

00:20:16,000 --> 00:20:20,710
find the encrypted things you want but

00:20:18,640 --> 00:20:23,470
it's going to be close enough given the

00:20:20,710 --> 00:20:28,390
load collision rate of char 512 that it

00:20:23,470 --> 00:20:30,220
probably will most of the time so Oh God

00:20:28,390 --> 00:20:32,920
but we've going to have to have some

00:20:30,220 --> 00:20:34,840
kind of keys to go with the fields and

00:20:32,920 --> 00:20:37,630
then we're going to have to have some

00:20:34,840 --> 00:20:39,340
kind of way of doing a char 5 12 h Mack

00:20:37,630 --> 00:20:42,570
on the field and then we're going to

00:20:39,340 --> 00:20:45,100
inject all of this stuff somehow and

00:20:42,570 --> 00:20:46,480
just to be perverse about it for what I

00:20:45,100 --> 00:20:49,660
was actually doing it made more sense to

00:20:46,480 --> 00:20:51,690
do it actually into the class module and

00:20:49,660 --> 00:20:54,730
then have a way of getting back to it so

00:20:51,690 --> 00:20:57,130
that's an implementation detail field

00:20:54,730 --> 00:20:59,560
excesses this is my favorite bit I love

00:20:57,130 --> 00:21:04,410
this because it's pure magic it made me

00:20:59,560 --> 00:21:08,710
feel so good when I got it working right

00:21:04,410 --> 00:21:11,230
there's three things we need we need a

00:21:08,710 --> 00:21:14,920
getter and setter we know that but we

00:21:11,230 --> 00:21:16,390
also need some way of generating and

00:21:14,920 --> 00:21:18,430
getting at fingerprints for each record

00:21:16,390 --> 00:21:20,860
we put in those finger bits have to be

00:21:18,430 --> 00:21:21,910
sick cryptographically secure so that

00:21:20,860 --> 00:21:23,530
people can't just take all the

00:21:21,910 --> 00:21:26,710
fingerprints and know what the records

00:21:23,530 --> 00:21:27,730
are but at the same time they have to be

00:21:26,710 --> 00:21:30,400
something that's cheap for us to

00:21:27,730 --> 00:21:32,740
calculate on the fly so that we can do

00:21:30,400 --> 00:21:34,900
our search and every time we search we

00:21:32,740 --> 00:21:36,460
just take that one value that we

00:21:34,900 --> 00:21:38,330
calculate based on what we're given and

00:21:36,460 --> 00:21:42,519
see if we can find a match

00:21:38,330 --> 00:21:48,429
so it can be grouped forced very slowly

00:21:42,519 --> 00:21:52,070
um fun so this is what we end up with

00:21:48,429 --> 00:21:53,809
happening to our our model now so we've

00:21:52,070 --> 00:21:56,830
now got a fingerprint for every

00:21:53,809 --> 00:21:59,720
encrypted field we've got a key at

00:21:56,830 --> 00:22:02,570
initialization vector that somehow

00:21:59,720 --> 00:22:04,240
mapped to that field that shouldn't live

00:22:02,570 --> 00:22:07,340
in this database book county does and

00:22:04,240 --> 00:22:11,330
then we've got some indexes so that we

00:22:07,340 --> 00:22:12,470
can find things quickly and that

00:22:11,330 --> 00:22:15,440
unfortunate is why I ran out of time

00:22:12,470 --> 00:22:18,470
although I must admit that's almost 180

00:22:15,440 --> 00:22:23,539
slides we 20 21 minutes to go into that

00:22:18,470 --> 00:22:25,240
I don't believe a word of it um that

00:22:23,539 --> 00:22:28,210
would much faster than I thought so

00:22:25,240 --> 00:22:33,889
there are other bits that go with this

00:22:28,210 --> 00:22:34,850
file firstly table encryption we can't

00:22:33,889 --> 00:22:37,190
have those keys and initialization

00:22:34,850 --> 00:22:39,409
vectors just lurking there now there are

00:22:37,190 --> 00:22:40,789
two ways to solve that problem one you

00:22:39,409 --> 00:22:42,590
swap it off into another service

00:22:40,789 --> 00:22:44,299
somewhere and then you have another way

00:22:42,590 --> 00:22:47,419
of getting at the service that secure or

00:22:44,299 --> 00:22:49,580
two you do the cheap way which is

00:22:47,419 --> 00:22:52,669
actually to use public/private key pairs

00:22:49,580 --> 00:22:55,309
on the table that will only know into

00:22:52,669 --> 00:22:56,510
the application and then you can sort of

00:22:55,309 --> 00:22:58,820
stick them off in sort of a known

00:22:56,510 --> 00:23:00,980
directory on unix and use permissions or

00:22:58,820 --> 00:23:05,480
something to protect them all I wouldn't

00:23:00,980 --> 00:23:07,460
recommend that so the second thought go

00:23:05,480 --> 00:23:11,000
back didn't do that did I idea too sure

00:23:07,460 --> 00:23:12,260
so if you can stop it on the next one I

00:23:11,000 --> 00:23:15,789
might have gotten carried away with that

00:23:12,260 --> 00:23:18,169
so second there's Transport Security

00:23:15,789 --> 00:23:20,240
which is just having it secure in the

00:23:18,169 --> 00:23:21,590
database is good enough we still have to

00:23:20,240 --> 00:23:24,289
talk to somebody on the other side of

00:23:21,590 --> 00:23:26,929
the internet we don't want anything that

00:23:24,289 --> 00:23:28,700
goes to them being visible so obviously

00:23:26,929 --> 00:23:30,620
we're at least going to use a yes to

00:23:28,700 --> 00:23:32,419
encrypt the stuff we sent them on code

00:23:30,620 --> 00:23:34,399
back and then that means we've got to

00:23:32,419 --> 00:23:35,480
put digital signatures on because we've

00:23:34,399 --> 00:23:39,470
got to make sure they haven't tampered

00:23:35,480 --> 00:23:40,490
we won't be sent so and it will go back

00:23:39,470 --> 00:23:42,980
one

00:23:40,490 --> 00:23:44,120
and then the piece de resistance will

00:23:42,980 --> 00:23:46,250
actually have time to write it up

00:23:44,120 --> 00:23:49,910
because I've got all the code is this

00:23:46,250 --> 00:23:53,510
idea of federated private data now you

00:23:49,910 --> 00:23:56,480
should break apart any database that you

00:23:53,510 --> 00:23:58,280
want to keep protected from external or

00:23:56,480 --> 00:23:59,510
unauthorized access you should have

00:23:58,280 --> 00:24:02,600
little bits of it in different places

00:23:59,510 --> 00:24:04,610
each with their own keys each talking

00:24:02,600 --> 00:24:05,929
over very clean interfaces so not so

00:24:04,610 --> 00:24:09,290
happens to be beautiful for this because

00:24:05,929 --> 00:24:10,250
you can build incredibly trivial rest

00:24:09,290 --> 00:24:14,240
apps i guess for one of a better

00:24:10,250 --> 00:24:16,670
description that will mean that you have

00:24:14,240 --> 00:24:20,090
hardly any code to manage to present

00:24:16,670 --> 00:24:21,350
those api's finally this is where you

00:24:20,090 --> 00:24:22,790
will be able to find the slides when I

00:24:21,350 --> 00:24:26,870
get back to the hotel and I put them all

00:24:22,790 --> 00:24:29,000
up on SlideShare there's quite a lot of

00:24:26,870 --> 00:24:30,740
code in there not as much actually

00:24:29,000 --> 00:24:32,660
reading it as it was writing it so those

00:24:30,740 --> 00:24:35,240
because obviously with slides it's the

00:24:32,660 --> 00:24:38,270
layout as the problem but it bears a lot

00:24:35,240 --> 00:24:40,340
of it bears studying it's a good starter

00:24:38,270 --> 00:24:42,140
point I hope it a second later point

00:24:40,340 --> 00:24:43,370
this year to find another conference and

00:24:42,140 --> 00:24:46,400
wants me to come and fill in the part

00:24:43,370 --> 00:24:47,690
too if anybody here does organize

00:24:46,400 --> 00:24:49,820
conferences it wants to fly me from the

00:24:47,690 --> 00:24:51,980
UK specifically to do that put me up in

00:24:49,820 --> 00:24:53,900
a five-star hotel and feed me absolutely

00:24:51,980 --> 00:24:57,950
luxuries for five days I'd be happy to

00:24:53,900 --> 00:25:00,110
do it alternatively it could turn up

00:24:57,950 --> 00:25:01,670
anywhere depending on who really you

00:25:00,110 --> 00:25:06,640
know has a spare slot must've see the

00:25:01,670 --> 00:25:06,640

YouTube URL: https://www.youtube.com/watch?v=entIQBaOTqA


