Title: MountainWest RubyConf 2013 Ruby Batteries Included by Daniel Huckstep
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	The ruby standard library is full of great code. It's also full of dragons. I'll show you some of fun parts, parts that you may not be using and may not even know about. I'll show you that you don't have to install everything on GitHub to build your application. I'll also look at some of nasty parts, and how to put a training collar on some of those dragons.

Help us caption & translate this video!

http://amara.org/v/FGbO/
Captions: 
	00:00:01,170 --> 00:00:18,649
[Music]

00:00:19,610 --> 00:00:26,250
I'm really nervous go easy on me before

00:00:24,360 --> 00:00:28,920
I start since nobody's done it yet give

00:00:26,250 --> 00:00:30,280
a big round of applause to Mike and the

00:00:28,920 --> 00:00:34,380
rest of the Mountain West crew

00:00:30,280 --> 00:00:35,970
[Applause]

00:00:34,380 --> 00:00:38,800
[Music]

00:00:35,970 --> 00:00:46,540
and also to the fine folks at confreaks

00:00:38,800 --> 00:00:51,970
that are recording all this so I gave my

00:00:46,540 --> 00:00:54,370
mom the URL so hi mom so I'm gonna talk

00:00:51,970 --> 00:00:58,180
about Ruby batteries included Ruby can

00:00:54,370 --> 00:00:59,890
standard library and so can you so how

00:00:58,180 --> 00:01:01,870
many gems does it take to build your

00:00:59,890 --> 00:01:04,089
application does

00:01:01,870 --> 00:01:06,220
I know Fletcher down here how many how

00:01:04,089 --> 00:01:11,500
many gems is blue box use on a regular

00:01:06,220 --> 00:01:12,910
basis this does anybody know like how

00:01:11,500 --> 00:01:13,990
many gems you got in your gem file you

00:01:12,910 --> 00:01:16,750
open up your gem file and it's just

00:01:13,990 --> 00:01:22,119
pages and pages out oh that's a lot of

00:01:16,750 --> 00:01:23,979
gems well so there's you know you could

00:01:22,119 --> 00:01:26,110
look in the gem file that you explicitly

00:01:23,979 --> 00:01:28,270
depend on and then there's those gems

00:01:26,110 --> 00:01:30,970
that they depend on and then just a big

00:01:28,270 --> 00:01:32,560
chain of dependencies right so this is a

00:01:30,970 --> 00:01:35,890
quick dirty way to look in your gem file

00:01:32,560 --> 00:01:38,910
that's what our applet yardstick does

00:01:35,890 --> 00:01:41,399
135 gems there's like six for rescue

00:01:38,910 --> 00:01:45,250
right there's rescue rescue namespace

00:01:41,399 --> 00:01:47,350
retry the scheduler and like you know

00:01:45,250 --> 00:01:51,550
there's unique jobs and all this fun

00:01:47,350 --> 00:01:52,810
stuff so do we really need 135 gems yeah

00:01:51,550 --> 00:01:56,110
you know you got to talk to a database

00:01:52,810 --> 00:01:58,690
and you know maybe you really don't like

00:01:56,110 --> 00:02:00,910
er B but okay and we need to do some

00:01:58,690 --> 00:02:02,950
CoffeeScript but there's probably a few

00:02:00,910 --> 00:02:04,360
that we can clean out of those and the

00:02:02,950 --> 00:02:06,729
standard library can actually do a

00:02:04,360 --> 00:02:08,950
pretty good job of getting you there you

00:02:06,729 --> 00:02:10,149
know maybe maybe you have to write a

00:02:08,950 --> 00:02:13,209
little bit more code but hey we're all

00:02:10,149 --> 00:02:14,319
programmers so let's write some code so

00:02:13,209 --> 00:02:16,120
we're gonna look at the standard library

00:02:14,319 --> 00:02:18,250
and it's actually broken into two

00:02:16,120 --> 00:02:22,209
sections there's the core which is stuff

00:02:18,250 --> 00:02:23,950
like enumerable string things like that

00:02:22,209 --> 00:02:26,080
that are kind of built in part of the

00:02:23,950 --> 00:02:28,750
language and then there's the standard

00:02:26,080 --> 00:02:32,140
library which is stuff that is there but

00:02:28,750 --> 00:02:33,459
it's not you have you have to require it

00:02:32,140 --> 00:02:34,930
and you don't have to use it but it's

00:02:33,459 --> 00:02:37,959
just kind of they're packaged as part of

00:02:34,930 --> 00:02:39,489
the part of the language distribution so

00:02:37,959 --> 00:02:41,050
we'll use these handy images in the

00:02:39,489 --> 00:02:42,160
bottom right corners there's the core

00:02:41,050 --> 00:02:46,150
which is a fantastic movie

00:02:42,160 --> 00:02:48,300
and that's Ghost Busters there in the

00:02:46,150 --> 00:02:48,300
library

00:02:51,110 --> 00:02:56,160
so a quick dirty way to figure out how

00:02:54,150 --> 00:02:59,970
many classes that I don't sure how

00:02:56,160 --> 00:03:01,440
accurate that is but you know what 552

00:02:59,970 --> 00:03:03,180
let's get going

00:03:01,440 --> 00:03:04,350
we got a lot to cover we're not gonna do

00:03:03,180 --> 00:03:06,360
all of them we're gonna go through some

00:03:04,350 --> 00:03:08,180
basic things that you should probably be

00:03:06,360 --> 00:03:11,700
using on a day to day basis maybe

00:03:08,180 --> 00:03:13,170
performance things to measure

00:03:11,700 --> 00:03:15,780
performance and help improve performance

00:03:13,170 --> 00:03:20,430
and then we'll go beyond that into all

00:03:15,780 --> 00:03:24,150
the beyond section not all this works in

00:03:20,430 --> 00:03:26,370
1:8 so don't be like Brian use just use

00:03:24,150 --> 00:03:28,650
Ruby - Oh where's Matz he's happy about

00:03:26,370 --> 00:03:33,480
Ruby - oh so we should all be Matz uses

00:03:28,650 --> 00:03:36,570
Ruby - oh so we should use Ruby - oh so

00:03:33,480 --> 00:03:38,430
we'll start with the basics where's

00:03:36,570 --> 00:03:41,790
where's Ward how many how many has these

00:03:38,430 --> 00:03:44,100
have these he has he used all right so

00:03:41,790 --> 00:03:45,480
set the set data type everybody's

00:03:44,100 --> 00:03:48,030
probably used an array and just called

00:03:45,480 --> 00:03:49,410
unique on it shoveled some values in and

00:03:48,030 --> 00:03:52,950
then yeah we don't want unique values

00:03:49,410 --> 00:03:55,709
yeah but we use a set this comes with

00:03:52,950 --> 00:04:00,030
Ruby it's free you shovel things in like

00:03:55,709 --> 00:04:02,070
an array you can iterate over it but of

00:04:00,030 --> 00:04:03,750
course it's a set so it enforces unique

00:04:02,070 --> 00:04:06,240
value constraints so if you put

00:04:03,750 --> 00:04:08,400
something in twice it's not good it's

00:04:06,240 --> 00:04:10,260
not gonna go in twice so your choir set

00:04:08,400 --> 00:04:11,940
we can make a new set and say I've tried

00:04:10,260 --> 00:04:14,370
to put one in four times but of course

00:04:11,940 --> 00:04:18,000
it only went in once another advantage

00:04:14,370 --> 00:04:20,040
was set is that inclusion checks like if

00:04:18,000 --> 00:04:21,840
you do not include on it it's very very

00:04:20,040 --> 00:04:24,930
quick whereas with an array you've got

00:04:21,840 --> 00:04:26,430
to iterate through the whole thing has

00:04:24,930 --> 00:04:35,070
anybody used set I've used it a few

00:04:26,430 --> 00:04:38,280
times yeah good stuff yeah so the other

00:04:35,070 --> 00:04:40,620
thing with this is that iteration order

00:04:38,280 --> 00:04:42,840
isn't you can't rely on it I think in

00:04:40,620 --> 00:04:44,820
Ruby one night and above it will kind of

00:04:42,840 --> 00:04:46,890
iterate in the same order that you put

00:04:44,820 --> 00:04:48,540
things into because one nine preserves

00:04:46,890 --> 00:04:50,360
hash insertion order but I wouldn't

00:04:48,540 --> 00:04:53,580
count on it

00:04:50,360 --> 00:04:56,040
speaking on our speaking of iteration

00:04:53,580 --> 00:04:57,870
enumerable everybody uses enumerable I'm

00:04:56,040 --> 00:04:58,960
sure some of you right now are typing

00:04:57,870 --> 00:05:03,430
dot each

00:04:58,960 --> 00:05:06,039
something right so innumerable gives you

00:05:03,430 --> 00:05:09,130
all of those dot each dot map each with

00:05:06,039 --> 00:05:11,410
index reduce collect blah blah blah they

00:05:09,130 --> 00:05:13,300
give you all of those things fun part is

00:05:11,410 --> 00:05:16,449
you can implement this or you can use

00:05:13,300 --> 00:05:18,250
the enumerable module yourself we've got

00:05:16,449 --> 00:05:20,380
a thing here and it doesn't do anything

00:05:18,250 --> 00:05:23,380
terribly exciting imagine that it would

00:05:20,380 --> 00:05:26,050
change files but basically we include

00:05:23,380 --> 00:05:28,350
enumerable some other stuff happens we

00:05:26,050 --> 00:05:30,789
shovel things into our files array and

00:05:28,350 --> 00:05:32,410
then I define the each method where I

00:05:30,789 --> 00:05:35,259
just iterate over the files and I yield

00:05:32,410 --> 00:05:36,759
some stuff we can then do some other

00:05:35,259 --> 00:05:40,060
things with it where we shovel some

00:05:36,759 --> 00:05:42,430
files in we call each with index wait a

00:05:40,060 --> 00:05:45,580
minute and we call map I would call

00:05:42,430 --> 00:05:47,650
reduce but I didn't define any of those

00:05:45,580 --> 00:05:49,960
methods I just defined the each method

00:05:47,650 --> 00:05:52,360
and included the enumerable module

00:05:49,960 --> 00:05:53,860
because all in numerable needs is that

00:05:52,360 --> 00:05:57,930
each method and it implements all the

00:05:53,860 --> 00:06:03,520
other ones in terms of each so this all

00:05:57,930 --> 00:06:05,260
unsurprisingly works we actually I just

00:06:03,520 --> 00:06:07,659
I just merged a poor requester I just

00:06:05,260 --> 00:06:09,820
reviewed a pull request in her code

00:06:07,659 --> 00:06:11,380
basic yardstick where a guy included

00:06:09,820 --> 00:06:14,380
enumerable because he needed each with

00:06:11,380 --> 00:06:16,180
index and you know we get we get all

00:06:14,380 --> 00:06:17,860
this stuff for free and yeah well yeah

00:06:16,180 --> 00:06:19,120
you could implement each with index but

00:06:17,860 --> 00:06:23,110
screw it and your Roble gives it to you

00:06:19,120 --> 00:06:26,710
for free to go along with enumerable we

00:06:23,110 --> 00:06:29,770
can do a numerator so in Ruby - we got

00:06:26,710 --> 00:06:31,599
the lazy enumeration stuff you can

00:06:29,770 --> 00:06:35,020
implement the lazy stuff in Ruby 187

00:06:31,599 --> 00:06:36,759
with a numerator like that in fact we

00:06:35,020 --> 00:06:40,830
have a file called lazy dot RB in our

00:06:36,759 --> 00:06:43,120
app because it's 187 and rails 2/3 so

00:06:40,830 --> 00:06:47,110
with the numerator you can build your

00:06:43,120 --> 00:06:50,169
own enumerators on the fly so you can

00:06:47,110 --> 00:06:53,020
also that's a little far over but you

00:06:50,169 --> 00:06:55,330
can also kind of doing this works the

00:06:53,020 --> 00:06:57,159
same way it you can build an enumerator

00:06:55,330 --> 00:07:00,639
from something that is enumerable and

00:06:57,159 --> 00:07:02,199
it'll work the same way the other fun

00:07:00,639 --> 00:07:03,669
stuff is we're gonna build all the

00:07:02,199 --> 00:07:06,039
natural numbers so we're gonna have a

00:07:03,669 --> 00:07:08,460
new enumerator and that Y is the yield

00:07:06,039 --> 00:07:11,200
err so you can shovel things into that

00:07:08,460 --> 00:07:12,669
we're gonna use the naturals in shovel

00:07:11,200 --> 00:07:14,620
out just the odds

00:07:12,669 --> 00:07:16,030
we're gonna do a really naive prime

00:07:14,620 --> 00:07:19,780
check and we're gonna get all the primes

00:07:16,030 --> 00:07:22,180
and then we can take the primes because

00:07:19,780 --> 00:07:23,740
the enumerator is just an enumerable so

00:07:22,180 --> 00:07:25,449
I just take the first 10 Prime's and it

00:07:23,740 --> 00:07:28,180
doesn't I didn't need a big list of

00:07:25,449 --> 00:07:30,729
primes it just generated those on the

00:07:28,180 --> 00:07:33,370
fly so if you want to do something lazy

00:07:30,729 --> 00:07:36,069
like you got a big array of stuff maybe

00:07:33,370 --> 00:07:37,900
don't use you know dot map and dot this

00:07:36,069 --> 00:07:40,210
and dot that because it'll actually

00:07:37,900 --> 00:07:40,719
build an array each time you can do it

00:07:40,210 --> 00:07:42,580
lazily

00:07:40,719 --> 00:07:44,710
and again in Ruby - oh you can just do

00:07:42,580 --> 00:07:48,689
not lazy but if you're in the dark ages

00:07:44,710 --> 00:07:48,689
like I am you can use a numerator

00:07:49,020 --> 00:07:57,069
simpledelegator everybody's read 7,000

00:07:54,340 --> 00:07:58,599
blog post about DCI right you have the

00:07:57,069 --> 00:08:00,189
data context interaction where things

00:07:58,599 --> 00:08:02,259
don't have the methods you want them to

00:08:00,189 --> 00:08:04,599
until some point in time when they

00:08:02,259 --> 00:08:06,639
actually need to do stuff so the

00:08:04,599 --> 00:08:09,039
problems with DCI are that oh we use

00:08:06,639 --> 00:08:11,039
extend and then we blow it the method

00:08:09,039 --> 00:08:14,249
cache and everything becomes slow

00:08:11,039 --> 00:08:17,349
simpledelegator can help you with that

00:08:14,249 --> 00:08:20,069
you require delegate because it's in the

00:08:17,349 --> 00:08:22,449
standard library as opposed to the core

00:08:20,069 --> 00:08:24,339
and we're just gonna hear it from it I

00:08:22,449 --> 00:08:27,520
made a fancy string and it just has

00:08:24,339 --> 00:08:31,449
another method on it that checks if it

00:08:27,520 --> 00:08:34,539
is in fact fancy so we make a fancy

00:08:31,449 --> 00:08:36,579
string with the string fancy and of

00:08:34,539 --> 00:08:39,010
course it responds to fancy question

00:08:36,579 --> 00:08:41,320
mark and it also responds to length

00:08:39,010 --> 00:08:43,149
because it just simply delegates all of

00:08:41,320 --> 00:08:45,070
the other methods down to the underlying

00:08:43,149 --> 00:08:46,720
object so you can treat it like a string

00:08:45,070 --> 00:08:49,240
but then it also has this other method

00:08:46,720 --> 00:08:51,779
or whatever whatever other methods on

00:08:49,240 --> 00:08:51,779
top of it

00:08:52,959 --> 00:08:59,680
simpledelegator x' friend is forwardable

00:08:55,440 --> 00:09:02,260
this goes the opposite way so we can

00:08:59,680 --> 00:09:05,500
require fordable and I'm gonna use a

00:09:02,260 --> 00:09:06,970
struct here and it's gonna take in a

00:09:05,500 --> 00:09:08,740
string and we're going to extend for

00:09:06,970 --> 00:09:11,230
double and then you get def delegator

00:09:08,740 --> 00:09:13,600
and def delegate errs so def delegator

00:09:11,230 --> 00:09:17,320
is just going to delegate a single

00:09:13,600 --> 00:09:19,000
method while renaming it so we can call

00:09:17,320 --> 00:09:21,010
fancy lengths and it'll be the same as

00:09:19,000 --> 00:09:23,360
length and the other one down here we're

00:09:21,010 --> 00:09:26,690
going to delegate a number of methods

00:09:23,360 --> 00:09:29,930
without renaming them so we can make a

00:09:26,690 --> 00:09:33,740
new fancy string again include is gonna

00:09:29,930 --> 00:09:35,270
work because we delegated it and fancy

00:09:33,740 --> 00:09:37,250
length is gonna work but bite size is

00:09:35,270 --> 00:09:39,230
not gonna work because we didn't

00:09:37,250 --> 00:09:44,150
explicitly delegate it so it hides hides

00:09:39,230 --> 00:09:45,860
things that you you don't want has

00:09:44,150 --> 00:09:50,570
anybody use simpledelegator affordable

00:09:45,860 --> 00:09:52,940
and their stuff I'm I find it pretty

00:09:50,570 --> 00:09:58,070
useful you can you know if you want like

00:09:52,940 --> 00:10:00,500
a simple something like Draper like like

00:09:58,070 --> 00:10:02,360
just a view kind of model thing that you

00:10:00,500 --> 00:10:03,890
want to wrap you can throw something

00:10:02,360 --> 00:10:05,990
together really quick with with

00:10:03,890 --> 00:10:08,030
simpledelegator to just add some sugar

00:10:05,990 --> 00:10:11,480
on top of your active record models or

00:10:08,030 --> 00:10:13,850
something like that so that's the that's

00:10:11,480 --> 00:10:16,730
the end of the basic stuff these are all

00:10:13,850 --> 00:10:18,110
things that you know I think you can use

00:10:16,730 --> 00:10:20,150
on a regular basis like I say everybody

00:10:18,110 --> 00:10:22,690
uses a numerable set it's pretty popular

00:10:20,150 --> 00:10:26,180
and delegating forward will are also

00:10:22,690 --> 00:10:28,220
pretty solid so we'll look at the

00:10:26,180 --> 00:10:29,540
performance stuff this is the kind of

00:10:28,220 --> 00:10:35,690
stuff you can do if you build your own

00:10:29,540 --> 00:10:37,040
web framework that's DHHS car so

00:10:35,690 --> 00:10:40,310
benchmark everybody loves benchmarking

00:10:37,040 --> 00:10:43,130
code right then this package is probably

00:10:40,310 --> 00:10:52,970
the starter of more arguments on hacker

00:10:43,130 --> 00:10:54,710
news than Bitcoin so this is in the

00:10:52,970 --> 00:10:56,240
standard library we can get from the

00:10:54,710 --> 00:10:58,610
Ghostbusters down there we're gonna

00:10:56,240 --> 00:11:00,830
require the benchmark package and we can

00:10:58,610 --> 00:11:03,470
do just a simple measure that'll just

00:11:00,830 --> 00:11:05,260
measure that block of code and I put out

00:11:03,470 --> 00:11:07,910
the results and it comes out as a string

00:11:05,260 --> 00:11:09,980
but it's actually a results object and

00:11:07,910 --> 00:11:11,780
you can call there's you know four

00:11:09,980 --> 00:11:14,480
methods to get the CPU time in the

00:11:11,780 --> 00:11:15,560
system time and the user time and the

00:11:14,480 --> 00:11:20,480
important one is the one on the end

00:11:15,560 --> 00:11:22,640
which is your wall clock time again it

00:11:20,480 --> 00:11:24,590
defaults to just a string which is or

00:11:22,640 --> 00:11:26,930
formats it's off to a string which is

00:11:24,590 --> 00:11:31,580
the same format as the unix-like time

00:11:26,930 --> 00:11:33,980
command we can also benchmark separate

00:11:31,580 --> 00:11:35,480
blocks of code in a report format so if

00:11:33,980 --> 00:11:37,080
you want to say well what does this do

00:11:35,480 --> 00:11:39,480
compared to this we can benchmark

00:11:37,080 --> 00:11:42,890
two blocks so you know standard a little

00:11:39,480 --> 00:11:45,570
three different ways to do a loop

00:11:42,890 --> 00:11:47,730
sometimes that's you know that just

00:11:45,570 --> 00:11:49,640
outputs three lines like the previous

00:11:47,730 --> 00:11:51,840
line up there that's kind of boring so

00:11:49,640 --> 00:11:56,070
we're actually gonna include some labels

00:11:51,840 --> 00:11:58,890
and the ten is just the two column width

00:11:56,070 --> 00:12:00,270
for your labels and even if you wanna go

00:11:58,890 --> 00:12:03,570
one step further you probably should be

00:12:00,270 --> 00:12:06,210
doing a warm-up which just runs the code

00:12:03,570 --> 00:12:08,220
and then runs it again the warm-up is

00:12:06,210 --> 00:12:10,440
just for you know to make sure the CPU

00:12:08,220 --> 00:12:13,740
cache is happy make sure everything kind

00:12:10,440 --> 00:12:15,450
of settles down so I mean if you're if

00:12:13,740 --> 00:12:17,130
you're looking for code you can you can

00:12:15,450 --> 00:12:19,740
do your thread profiling stuff you can

00:12:17,130 --> 00:12:21,060
use new relic or you can just bust out

00:12:19,740 --> 00:12:22,890
benchmark if you got something really

00:12:21,060 --> 00:12:26,130
simple and straightforward throw

00:12:22,890 --> 00:12:27,990
benchmark at it think about how you're

00:12:26,130 --> 00:12:31,830
benchmarking code maybe read some

00:12:27,990 --> 00:12:33,690
statistics books and then use the BB M

00:12:31,830 --> 00:12:37,410
method there to do a warm-up with a

00:12:33,690 --> 00:12:40,470
report and everything looks beautiful so

00:12:37,410 --> 00:12:42,660
you've found some method you found your

00:12:40,470 --> 00:12:45,650
Fibonacci method is slow because your

00:12:42,660 --> 00:12:45,650
app has a Fibonacci method

00:12:46,399 --> 00:12:53,540
there's like you know users login users

00:12:49,939 --> 00:12:58,069
log out lame Fibonacci that's it's every

00:12:53,540 --> 00:12:59,749
app so maybe you wrote you wrote a

00:12:58,069 --> 00:13:03,889
standard you know tail recursive

00:12:59,749 --> 00:13:07,160
Fibonacci method but Ruby on its own it

00:13:03,889 --> 00:13:09,589
has tail recursion support to optimize

00:13:07,160 --> 00:13:10,970
this basically into a loop but it

00:13:09,589 --> 00:13:13,370
doesn't do it by default so if you just

00:13:10,970 --> 00:13:19,100
run this it's gonna explode the stacks

00:13:13,370 --> 00:13:21,170
gonna die and you go home sad and but

00:13:19,100 --> 00:13:23,209
this guy on this blog post this isn't

00:13:21,170 --> 00:13:26,449
stuff I found out on my own this guy did

00:13:23,209 --> 00:13:31,579
it we can go to the Ruby VM instruction

00:13:26,449 --> 00:13:33,649
sequence and this is 1 9 and up so we

00:13:31,579 --> 00:13:35,540
can set up some compile options to tell

00:13:33,649 --> 00:13:38,629
it to do tail call optimization holy

00:13:35,540 --> 00:13:42,110
 and the trace instruction also

00:13:38,629 --> 00:13:43,639
needs to be false so there's two ways we

00:13:42,110 --> 00:13:45,470
can actually make use of this you can

00:13:43,639 --> 00:13:48,769
actually you can just like load a file

00:13:45,470 --> 00:13:51,220
after this load some dot RB name or you

00:13:48,769 --> 00:13:54,230
can just valve

00:13:51,220 --> 00:13:56,199
like that and then you have the fib and

00:13:54,230 --> 00:13:58,879
a CC method in your in your scope here

00:13:56,199 --> 00:13:59,870
so this method is it's exactly the same

00:13:58,879 --> 00:14:01,910
as what was on the previous slide

00:13:59,870 --> 00:14:03,800
haven't done anything with it now it

00:14:01,910 --> 00:14:05,509
runs that runs almost instantly on my

00:14:03,800 --> 00:14:12,889
laptop and you get a digit

00:14:05,509 --> 00:14:13,790
you know big long number so I mean

00:14:12,889 --> 00:14:15,740
you're probably not going to do this

00:14:13,790 --> 00:14:19,220
that often but if you have something

00:14:15,740 --> 00:14:22,699
that is naturally tail-recursive Ruby

00:14:19,220 --> 00:14:28,699
can do it we can do it and you don't

00:14:22,699 --> 00:14:30,920
blow up your stack so it's okay so you

00:14:28,699 --> 00:14:33,800
optimized your Ruby but it's still not

00:14:30,920 --> 00:14:35,199
fast enough and we need to go we need to

00:14:33,800 --> 00:14:37,850
go out to a C library

00:14:35,199 --> 00:14:39,709
okay so there's gems that glue into the

00:14:37,850 --> 00:14:43,459
C library you can write a C extension

00:14:39,709 --> 00:14:45,439
there's Ruby in line and whatnot but if

00:14:43,459 --> 00:14:49,009
you just want to call out to a single

00:14:45,439 --> 00:14:54,230
method in some dynamic library we can

00:14:49,009 --> 00:14:56,120
use fiddle it's sort of like Fi I guess

00:14:54,230 --> 00:14:56,629
it basically is a fire it's just not F

00:14:56,120 --> 00:14:59,269
of five

00:14:56,629 --> 00:15:00,170
this comes with Ruby as well we can

00:14:59,269 --> 00:15:01,670
require fiddle

00:15:00,170 --> 00:15:03,140
and I'm just going to include fiddle so

00:15:01,670 --> 00:15:08,300
I can make the code shorter and make the

00:15:03,140 --> 00:15:10,630
font bigger the DL module comes with it

00:15:08,300 --> 00:15:13,370
so you open you dynamically open some

00:15:10,630 --> 00:15:16,430
thing and because I'm on a Mac I have to

00:15:13,370 --> 00:15:20,960
do the dy Lib on Linux you're gonna do a

00:15:16,430 --> 00:15:23,660
dot ISO file so we get a Lib and this is

00:15:20,960 --> 00:15:26,030
just the math library we can get ahold

00:15:23,660 --> 00:15:28,730
of the function which is in this case

00:15:26,030 --> 00:15:30,440
the square root function we set up the

00:15:28,730 --> 00:15:31,760
arguments we tell it it's a type double

00:15:30,440 --> 00:15:36,050
so of course that comes from the fiddle

00:15:31,760 --> 00:15:37,580
namespace and it returns a double and we

00:15:36,050 --> 00:15:41,270
make a new fiddle function out of it

00:15:37,580 --> 00:15:43,070
and then we can call it I didn't have to

00:15:41,270 --> 00:15:47,450
do a whole lot there I just I called out

00:15:43,070 --> 00:15:49,760
to a C function just just like that so I

00:15:47,450 --> 00:15:51,770
mean if you have if you need to call out

00:15:49,760 --> 00:15:53,150
to something like this you don't I mean

00:15:51,770 --> 00:15:55,280
really think about whether or not you

00:15:53,150 --> 00:15:57,170
need to pull in some big gem to do it or

00:15:55,280 --> 00:15:59,360
whether or not you can just call out to

00:15:57,170 --> 00:16:01,430
a single function maybe you hack up a

00:15:59,360 --> 00:16:02,930
little shared library that does a lot of

00:16:01,430 --> 00:16:04,790
the work and C for you and then that

00:16:02,930 --> 00:16:08,560
gives you one lot or one function to

00:16:04,790 --> 00:16:12,650
call into and fiddle can get you there

00:16:08,560 --> 00:16:15,110
so we've got our CPU down everything's

00:16:12,650 --> 00:16:18,080
running fast but maybe we're kind of

00:16:15,110 --> 00:16:19,760
loading on memory a little bit and maybe

00:16:18,080 --> 00:16:22,250
we're pulling in some things we want to

00:16:19,760 --> 00:16:24,370
kind of keep them around but if they get

00:16:22,250 --> 00:16:28,010
garbage collect it's not big of a deal

00:16:24,370 --> 00:16:30,080
so we newsweek ref with weak ref you

00:16:28,010 --> 00:16:32,620
probably want to be on Ruby too there

00:16:30,080 --> 00:16:34,790
was a lot of improvements done to it

00:16:32,620 --> 00:16:36,890
specifically if you're on like the Ruby

00:16:34,790 --> 00:16:39,440
voice if you're using the Ruby racer for

00:16:36,890 --> 00:16:41,600
something they make a point about saying

00:16:39,440 --> 00:16:42,950
use Ruby two because the weak ref gem or

00:16:41,600 --> 00:16:47,240
the weak ref implementation is a lot

00:16:42,950 --> 00:16:50,180
better so weak ref will wrap something

00:16:47,240 --> 00:16:51,980
whatever you give it in a weak reference

00:16:50,180 --> 00:16:54,470
meaning that it can be garbage collected

00:16:51,980 --> 00:16:54,830
so you can use it and do your stuff with

00:16:54,470 --> 00:16:57,310
it

00:16:54,830 --> 00:16:59,690
but when the garbage collector runs

00:16:57,310 --> 00:17:03,740
it'll be a candidate for collection and

00:16:59,690 --> 00:17:05,570
it might go away so we're just gonna

00:17:03,740 --> 00:17:09,170
require weak ref and I'm gonna read some

00:17:05,570 --> 00:17:10,970
HTML for from some big page and wrap it

00:17:09,170 --> 00:17:12,940
in a weak ref and I can put it out and

00:17:10,970 --> 00:17:14,910
it looks like a string as far as its

00:17:12,940 --> 00:17:16,960
but then I can also check if it's alive

00:17:14,910 --> 00:17:20,200
meaning the garbage collector hasn't

00:17:16,960 --> 00:17:22,780
collected it yet so we can run the GC

00:17:20,200 --> 00:17:25,150
and now we check that it's alive and

00:17:22,780 --> 00:17:27,580
it's it's dead now so it's gone you

00:17:25,150 --> 00:17:29,290
can't do anything with it so I mean you

00:17:27,580 --> 00:17:32,140
could you could take this and wrap it in

00:17:29,290 --> 00:17:34,090
some sort of some sort of a cache and if

00:17:32,140 --> 00:17:36,700
it's just an in-memory cache and you

00:17:34,090 --> 00:17:38,680
want things to be collected sort of like

00:17:36,700 --> 00:17:40,870
you know sort of like an in process

00:17:38,680 --> 00:17:42,280
memcache or something this will let

00:17:40,870 --> 00:17:44,440
things get collected by the garbage

00:17:42,280 --> 00:17:49,390
collector so you're not blowing all that

00:17:44,440 --> 00:17:52,000
memory if you don't care that much so

00:17:49,390 --> 00:17:53,950
that's it for performance stuff does any

00:17:52,000 --> 00:17:57,340
of that sound interesting everybody's

00:17:53,950 --> 00:17:58,900
use benchmark right everybody don't

00:17:57,340 --> 00:18:01,350
don't even lie you're posting on hacker

00:17:58,900 --> 00:18:01,350
news yesterday

00:18:04,560 --> 00:18:15,820
so beyond it's a platypus so we're gonna

00:18:13,840 --> 00:18:18,310
build an application and we need random

00:18:15,820 --> 00:18:21,370
numbers well you know what Ruby comes

00:18:18,310 --> 00:18:22,780
with secure random and it's secure you

00:18:21,370 --> 00:18:23,710
know it's not math.random where you give

00:18:22,780 --> 00:18:25,810
it a seed and you have a nice

00:18:23,710 --> 00:18:30,280
unpredictable chain of things it's

00:18:25,810 --> 00:18:32,530
secure random so don't don't be going

00:18:30,280 --> 00:18:34,960
and you know building out an array of A

00:18:32,530 --> 00:18:36,250
to Z and then render my random sample

00:18:34,960 --> 00:18:38,920
from you know don't don't do that just

00:18:36,250 --> 00:18:41,110
use a secure random you can get base64

00:18:38,920 --> 00:18:43,030
values you can get hex value you can get

00:18:41,110 --> 00:18:45,220
random bytes you get a random number a

00:18:43,030 --> 00:18:47,380
float and then you're gonna random

00:18:45,220 --> 00:18:48,970
number and int I really don't like that

00:18:47,380 --> 00:18:52,180
because it'll return a float or an int

00:18:48,970 --> 00:18:54,910
depending on the argument oh and you can

00:18:52,180 --> 00:18:56,350
also get you you you IDs the only thing

00:18:54,910 --> 00:18:57,790
special about the you you IDs is the

00:18:56,350 --> 00:19:00,760
version number everything else in it is

00:18:57,790 --> 00:19:02,860
random so cool we got our app we're

00:19:00,760 --> 00:19:06,580
building where that's secure random

00:19:02,860 --> 00:19:10,060
numbers but somebody came back from a

00:19:06,580 --> 00:19:13,300
conference II and saw 4 talks about

00:19:10,060 --> 00:19:14,590
service-oriented architecture so we got

00:19:13,300 --> 00:19:17,280
to put this it we got to make a service

00:19:14,590 --> 00:19:19,840
we got to make a random number service

00:19:17,280 --> 00:19:21,940
but we're not going to do HTTP we're

00:19:19,840 --> 00:19:23,260
going to just do TCP because hey we want

00:19:21,940 --> 00:19:26,130
it to be fast and we don't want

00:19:23,260 --> 00:19:29,410
we don't even want to load Sinatra so

00:19:26,130 --> 00:19:30,850
we're gonna do G servers and it has does

00:19:29,410 --> 00:19:32,490
this ring a bell for anybody has anybody

00:19:30,850 --> 00:19:36,760
use G server

00:19:32,490 --> 00:19:41,590
yeah that's expected but ok G server

00:19:36,760 --> 00:19:44,169
gives you a threaded TCP server threaded

00:19:41,590 --> 00:19:46,240
ok its thread safe it's happy it takes

00:19:44,169 --> 00:19:49,270
care of all of the connection and

00:19:46,240 --> 00:19:52,630
disconnection and all that junk for you

00:19:49,270 --> 00:19:54,640
so all you have to do inherit from G

00:19:52,630 --> 00:19:58,929
server and define serve which takes an i

00:19:54,640 --> 00:20:00,730
ohmic an i/o object that's it I'm gonna

00:19:58,929 --> 00:20:02,320
read you know four characters from it

00:20:00,730 --> 00:20:03,910
and then check the command and if we get

00:20:02,320 --> 00:20:05,320
hex I'm gonna send back some hex to know

00:20:03,910 --> 00:20:09,730
if I can get you UID I'm gonna send back

00:20:05,320 --> 00:20:12,490
some UID so we're going to start up or

00:20:09,730 --> 00:20:14,320
make a server on port 1 0 1 0 1 start it

00:20:12,490 --> 00:20:16,540
and just join on the thread to block

00:20:14,320 --> 00:20:19,660
wait for it so you can now telnet to

00:20:16,540 --> 00:20:22,870
localhost 1 0 1 0 1 type in hex and

00:20:19,660 --> 00:20:25,630
it'll spit you back a hex value excuse

00:20:22,870 --> 00:20:28,600
me and and then close the connection or

00:20:25,630 --> 00:20:29,380
you can do UID and it'll give you if you

00:20:28,600 --> 00:20:30,490
give it something else

00:20:29,380 --> 00:20:34,179
it'll just close the connection and

00:20:30,490 --> 00:20:35,770
you're done so cool we have our

00:20:34,179 --> 00:20:36,190
service-oriented architecture we're done

00:20:35,770 --> 00:20:38,290
right

00:20:36,190 --> 00:20:40,950
well no somebody else came back from

00:20:38,290 --> 00:20:47,320
another meetup conference user group

00:20:40,950 --> 00:20:49,200
hackfest and they were doing rust they

00:20:47,320 --> 00:20:52,299
were hanging out with Steve cloud neck

00:20:49,200 --> 00:20:55,059
so we need to shell out now because they

00:20:52,299 --> 00:20:58,419
wrote a random random number generator

00:20:55,059 --> 00:21:00,220
thing in rust but we can't load rust

00:20:58,419 --> 00:21:05,679
from within Ruby's so we got a shell out

00:21:00,220 --> 00:21:10,809
to it so renames kernel spawn spawn is

00:21:05,679 --> 00:21:13,799
like system plus exec fork exec on

00:21:10,809 --> 00:21:13,799
steroids

00:21:15,730 --> 00:21:22,940
this method here if you know we're going

00:21:19,940 --> 00:21:26,060
with great names for methods captures IO

00:21:22,940 --> 00:21:28,750
of a command the spawn method in there

00:21:26,060 --> 00:21:31,760
takes a command and some other arguments

00:21:28,750 --> 00:21:34,120
which include where standardout goes

00:21:31,760 --> 00:21:39,290
where standard error goes standard in

00:21:34,120 --> 00:21:41,000
environment variables you mask directory

00:21:39,290 --> 00:21:42,380
to exact int like it has a whole bunch

00:21:41,000 --> 00:21:44,540
stuff and the docs for this method are

00:21:42,380 --> 00:21:48,770
fantastic it just gives you like a big

00:21:44,540 --> 00:21:50,030
blob of this is what we accept so pretty

00:21:48,770 --> 00:21:52,220
much anything you'd want to do with

00:21:50,030 --> 00:21:54,110
exacting some external process you can

00:21:52,220 --> 00:21:55,730
do it with spawn and it just gives it

00:21:54,110 --> 00:21:57,530
gives you back a pig so we're gonna pass

00:21:55,730 --> 00:21:59,630
in a pipe and wait on the pig in blah

00:21:57,530 --> 00:22:01,520
blah blah so we wrote our rust

00:21:59,630 --> 00:22:08,390
randomizer program and we're gonna shell

00:22:01,520 --> 00:22:10,490
out to that and capture the output if

00:22:08,390 --> 00:22:12,470
you're doing a lot of shelling out like

00:22:10,490 --> 00:22:16,790
the github guys where they had to use

00:22:12,470 --> 00:22:18,650
POSIX spawn I'm not sure of the exact

00:22:16,790 --> 00:22:21,350
implementation details underneath how

00:22:18,650 --> 00:22:23,150
this happens so if you're doing a lot of

00:22:21,350 --> 00:22:30,070
shelling out like they were you might

00:22:23,150 --> 00:22:35,810
need POSIX spawn but now we've also

00:22:30,070 --> 00:22:38,600
somebody read an academic paper and that

00:22:35,810 --> 00:22:41,300
always works out well and we figured out

00:22:38,600 --> 00:22:44,270
a new way to generate random stuff based

00:22:41,300 --> 00:22:46,100
on already securely random stuff so we

00:22:44,270 --> 00:22:48,440
need some input from the user actually

00:22:46,100 --> 00:22:50,450
and we need to pipe that down to this

00:22:48,440 --> 00:22:52,430
thing so we're gonna actually take some

00:22:50,450 --> 00:22:55,750
some input and use shell words and we

00:22:52,430 --> 00:23:00,230
already saw a shell words so yesterday

00:22:55,750 --> 00:23:02,240
earlier today I can remember so shell

00:23:00,230 --> 00:23:04,490
words I mean normally you're gonna run

00:23:02,240 --> 00:23:06,380
system or something like this and it'll

00:23:04,490 --> 00:23:08,240
take an argument comma another argument

00:23:06,380 --> 00:23:10,280
comma another argument and that'll get

00:23:08,240 --> 00:23:11,930
passed down and the operating system

00:23:10,280 --> 00:23:13,640
will take care of that so that you don't

00:23:11,930 --> 00:23:15,260
have to worry about escaping things and

00:23:13,640 --> 00:23:18,460
you don't have to worry about users

00:23:15,260 --> 00:23:20,630
sending RM dash RF to your system

00:23:18,460 --> 00:23:22,370
sometimes though you need to actually

00:23:20,630 --> 00:23:24,100
just send a string down because you want

00:23:22,370 --> 00:23:26,200
the shell expansion to happen

00:23:24,100 --> 00:23:28,450
you you want like star dot RB to

00:23:26,200 --> 00:23:31,390
actually go down to the shale and expand

00:23:28,450 --> 00:23:35,049
on all the Ruby objects or Ruby files so

00:23:31,390 --> 00:23:36,400
well how do you then cram user input

00:23:35,049 --> 00:23:38,549
into that string so it's not going to

00:23:36,400 --> 00:23:41,830
blow up will you do it with shale words

00:23:38,549 --> 00:23:43,419
so we can require shale words we have

00:23:41,830 --> 00:23:44,890
some pattern from the user and that's

00:23:43,419 --> 00:23:49,600
you know I don't want that run in my

00:23:44,890 --> 00:23:52,059
system but I can run this assuming you

00:23:49,600 --> 00:23:53,679
know we can we can pass this in to a

00:23:52,059 --> 00:23:55,090
randomizer thing it's gonna pass that as

00:23:53,679 --> 00:23:56,530
the first argument and then for some

00:23:55,090 --> 00:23:59,409
reason it needs a list of all the dev

00:23:56,530 --> 00:24:01,360
devices so we can do pattern nutshell

00:23:59,409 --> 00:24:03,990
escape and that will go in and be all

00:24:01,360 --> 00:24:07,150
happy it's not gonna actually run that

00:24:03,990 --> 00:24:12,460
and the shale expansion on dev slash

00:24:07,150 --> 00:24:14,440
star works so if we try to do it like

00:24:12,460 --> 00:24:16,240
this assuming assuming the capture

00:24:14,440 --> 00:24:18,429
command a few slides ago worked like

00:24:16,240 --> 00:24:21,039
system this wouldn't work because it

00:24:18,429 --> 00:24:23,200
would get instead of getting a big long

00:24:21,039 --> 00:24:25,299
list of all of the devices on your

00:24:23,200 --> 00:24:31,659
machine it would get slash dev slash

00:24:25,299 --> 00:24:33,429
star and that's not actual file so so

00:24:31,659 --> 00:24:35,320
cool we got our TCP server that's

00:24:33,429 --> 00:24:41,890
serving random numbers written by a rust

00:24:35,320 --> 00:24:43,240
program that now takes user input well I

00:24:41,890 --> 00:24:45,220
guess we better audit this right we need

00:24:43,240 --> 00:24:48,130
to like store these random numbers to

00:24:45,220 --> 00:24:49,630
really make sure that you know we're not

00:24:48,130 --> 00:24:53,200
giving random numbers that we've seen

00:24:49,630 --> 00:24:55,630
before right that's it's the obvious

00:24:53,200 --> 00:24:57,700
next step so for that we're gonna use P

00:24:55,630 --> 00:25:00,130
store we don't need no Postgres or

00:24:57,700 --> 00:25:03,309
or awful scale no js' Devin all database

00:25:00,130 --> 00:25:07,059
we can use P store that was a lot of

00:25:03,309 --> 00:25:08,980
buzzwords in there so P star comes with

00:25:07,059 --> 00:25:16,570
the again and this it's in the standard

00:25:08,980 --> 00:25:19,690
library and it is a it uses Marshall to

00:25:16,570 --> 00:25:21,490
serialize stuff to disk oh the kicker is

00:25:19,690 --> 00:25:24,280
it's thread safe it can be ultra safe

00:25:21,490 --> 00:25:26,860
which protects you against io problems

00:25:24,280 --> 00:25:29,380
like it'll write the file and then do an

00:25:26,860 --> 00:25:30,970
atomic move as opposed to just

00:25:29,380 --> 00:25:32,559
overwriting the file and maybe you ran

00:25:30,970 --> 00:25:32,750
it a disk space and now your whole thing

00:25:32,559 --> 00:25:34,750
is

00:25:32,750 --> 00:25:38,420
drop so we're gonna make it thread-safe

00:25:34,750 --> 00:25:41,090
and ultra safe and oh it has

00:25:38,420 --> 00:25:44,450
transactions and it uses Marshall so we

00:25:41,090 --> 00:25:47,810
can just store stuff in it and Rick goes

00:25:44,450 --> 00:25:50,560
to disk so we're going to store our app

00:25:47,810 --> 00:25:52,790
name and you know random number and

00:25:50,560 --> 00:25:54,680
we're gonna read out the random number

00:25:52,790 --> 00:25:59,300
and it'll give us you know whatever that

00:25:54,680 --> 00:26:01,400
thing returned and we can also abort a

00:25:59,300 --> 00:26:03,110
transaction so that change won't take

00:26:01,400 --> 00:26:06,950
effect or you know or an exception gets

00:26:03,110 --> 00:26:09,050
raised and then now the thing shows the

00:26:06,950 --> 00:26:10,970
exact what it was before so you don't

00:26:09,050 --> 00:26:13,130
you know if you have like some little

00:26:10,970 --> 00:26:15,260
app you don't necessarily need to dump

00:26:13,130 --> 00:26:19,460
in a database you have P store there's

00:26:15,260 --> 00:26:21,500
also like DB M and G DBM and it's like

00:26:19,460 --> 00:26:23,690
for other DBMS depending on which way

00:26:21,500 --> 00:26:27,200
you compiled Ruby and what libraries you

00:26:23,690 --> 00:26:29,210
had available P store is kind of you

00:26:27,200 --> 00:26:32,110
know the Ruby friendly version where it

00:26:29,210 --> 00:26:34,690
should work everywhere it's thread safe

00:26:32,110 --> 00:26:37,100
transactions and use marshals so you can

00:26:34,690 --> 00:26:42,590
so you can store pretty much anything in

00:26:37,100 --> 00:26:43,880
it and of course I haven't even talked

00:26:42,590 --> 00:26:46,900
about testing we've been writing this

00:26:43,880 --> 00:26:49,910
app and we haven't even tested the thing

00:26:46,900 --> 00:26:51,950
so you've built your app with no

00:26:49,910 --> 00:26:54,230
external dependencies but now this

00:26:51,950 --> 00:26:56,030
douchebags gonna you know make you

00:26:54,230 --> 00:26:57,980
install six things to just run the test

00:26:56,030 --> 00:26:59,900
you clone the gem rake test and it's

00:26:57,980 --> 00:27:01,840
like ah you need to bundle install and

00:26:59,900 --> 00:27:05,480
install half of the world

00:27:01,840 --> 00:27:09,170
never fear mini test is here this comes

00:27:05,480 --> 00:27:10,880
with Ruby has many tests in there you

00:27:09,170 --> 00:27:13,600
know standard test unit syntax and it's

00:27:10,880 --> 00:27:16,100
got our spec syntax and it's got mocks

00:27:13,600 --> 00:27:17,900
mocks earned you know you have to

00:27:16,100 --> 00:27:21,890
manually verify them there might be a

00:27:17,900 --> 00:27:25,220
way to do that a nicer way and now I'm

00:27:21,890 --> 00:27:28,940
getting head shakes so this comes with

00:27:25,220 --> 00:27:30,410
Ruby and using something like mini tests

00:27:28,940 --> 00:27:33,500
especially if you have like a gem that

00:27:30,410 --> 00:27:35,420
you want people to hack on if they have

00:27:33,500 --> 00:27:38,310
to install a bunch of things okay it's

00:27:35,420 --> 00:27:41,190
easy with bundler and you know

00:27:38,310 --> 00:27:43,260
but if they can just clone the code and

00:27:41,190 --> 00:27:46,020
run rake tests and they see a bunch of

00:27:43,260 --> 00:27:48,030
green dots fly by that's awesome if they

00:27:46,020 --> 00:27:52,260
see oh I'm sorry you need to install

00:27:48,030 --> 00:27:55,860
r-spec and mocha and web mock and blah

00:27:52,260 --> 00:27:57,720
blah blah cool I like r-spec I like

00:27:55,860 --> 00:27:59,760
mocha I like web mock they have their

00:27:57,720 --> 00:28:01,890
places but if you're building a small

00:27:59,760 --> 00:28:03,750
gem maybe just think about using mini

00:28:01,890 --> 00:28:09,060
tests it's there it's free you don't

00:28:03,750 --> 00:28:11,430
have to do anything so that's our that's

00:28:09,060 --> 00:28:15,420
the Beyond section with our random

00:28:11,430 --> 00:28:21,560
number generated service-oriented no

00:28:15,420 --> 00:28:25,500
sequel store audited tested application

00:28:21,560 --> 00:28:27,060
so other fun things we've got option

00:28:25,500 --> 00:28:28,710
parsers there's two option parsing

00:28:27,060 --> 00:28:31,680
libraries in the standard library two of

00:28:28,710 --> 00:28:33,210
them and another gem just went up the

00:28:31,680 --> 00:28:34,890
other day and not to you know criticize

00:28:33,210 --> 00:28:39,210
the author of the project or the code

00:28:34,890 --> 00:28:41,930
but we got we got two of them and

00:28:39,210 --> 00:28:45,590
they're pretty good we've got web brick

00:28:41,930 --> 00:28:48,360
HTTP server we have an RSS package guys

00:28:45,590 --> 00:28:50,340
we can build Google Reader okay at the

00:28:48,360 --> 00:28:52,940
hackfest build Google Reader with the

00:28:50,340 --> 00:28:55,800
standard library you can do it come on

00:28:52,940 --> 00:28:58,340
we've got dr bees so we can exploit I

00:28:55,800 --> 00:29:01,230
mean have a distributed object system

00:28:58,340 --> 00:29:03,300
you can iterate over the file system you

00:29:01,230 --> 00:29:07,620
can parse Ruby files and get like a a

00:29:03,300 --> 00:29:09,510
big an ast out of it for doing thread

00:29:07,620 --> 00:29:12,870
stuff you can use threads wait to wait

00:29:09,510 --> 00:29:14,880
on a list of threads and then get a

00:29:12,870 --> 00:29:17,190
callback when one finishes as opposed to

00:29:14,880 --> 00:29:19,770
just mapping over your array of threads

00:29:17,190 --> 00:29:22,290
and calling join and well now of course

00:29:19,770 --> 00:29:23,610
with queue and size queue those are I

00:29:22,290 --> 00:29:27,060
think the only thread safe data

00:29:23,610 --> 00:29:29,190
structures in the language so you can

00:29:27,060 --> 00:29:31,050
shovel things in pop things out with

00:29:29,190 --> 00:29:32,910
monitor mixing you get a synchronized

00:29:31,050 --> 00:29:34,500
method that takes a block so you can

00:29:32,910 --> 00:29:37,740
make your own data structures thread

00:29:34,500 --> 00:29:40,950
safe of course there's the net packages

00:29:37,740 --> 00:29:46,020
so we can talk email we can talk FTP and

00:29:40,950 --> 00:29:50,160
we can talk in some weird dialect HTTP

00:29:46,020 --> 00:29:58,630
it's not if you follow one specific

00:29:50,160 --> 00:29:59,560
incantation it works not too bad so you

00:29:58,630 --> 00:30:03,450
know when you're when you're building

00:29:59,560 --> 00:30:06,610
your app or your gym maybe just you know

00:30:03,450 --> 00:30:09,160
we have a big ecosystem of gems we got

00:30:06,610 --> 00:30:12,310
ruby gems we got github and there's a

00:30:09,160 --> 00:30:15,220
ton of code out there but maybe you

00:30:12,310 --> 00:30:19,000
don't need to use all of it maybe you

00:30:15,220 --> 00:30:21,580
know you know if you have if you have

00:30:19,000 --> 00:30:25,440
something that you can write your little

00:30:21,580 --> 00:30:27,460
20 line class and it does 90% of the job

00:30:25,440 --> 00:30:29,350
maybe maybe do that and then we don't

00:30:27,460 --> 00:30:31,090
have to depend on somebody else's gem

00:30:29,350 --> 00:30:34,240
and we don't have to install this thing

00:30:31,090 --> 00:30:37,750
in CI server it takes like 10 minutes to

00:30:34,240 --> 00:30:43,810
install all those gems on Travis ten

00:30:37,750 --> 00:30:45,760
minutes so yeah don't don't be don't

00:30:43,810 --> 00:30:47,740
don't cry when you try to install all

00:30:45,760 --> 00:30:49,360
your gems and just think about your code

00:30:47,740 --> 00:30:51,400
maybe maybe the standard library already

00:30:49,360 --> 00:30:54,730
has something that can take care of

00:30:51,400 --> 00:30:56,110
business for you so thanks that's me

00:30:54,730 --> 00:31:00,310
thanks to yardstick for sending me here

00:30:56,110 --> 00:31:03,390
my bosses over there and I blog and

00:31:00,310 --> 00:31:03,390
tweet and write code

00:31:03,730 --> 00:31:43,240
[Applause]

00:31:11,720 --> 00:31:43,240

YouTube URL: https://www.youtube.com/watch?v=BAfy3IgVpjY


