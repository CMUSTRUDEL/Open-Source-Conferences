Title: MountainWest RubyConf 2013 Trolls of 2013 by Ryan Davis
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Help us caption & translate this video!

http://amara.org/v/FGbT/
Captions: 
	00:00:19,700 --> 00:00:26,100
okay when I mean we're sitting out the

00:00:22,500 --> 00:00:29,570
other day my talk is gonna be trouble

00:00:26,100 --> 00:00:33,390
2013 I'm I guess SI larki some

00:00:29,570 --> 00:00:36,000
expectations this is all of my talk I

00:00:33,390 --> 00:00:40,350
would be walking tomorrow a flipper sex

00:00:36,000 --> 00:00:41,520
but I eat last year SKT every it's

00:00:40,350 --> 00:00:44,000
a hundred of these lives of three

00:00:41,520 --> 00:00:49,589
minutes for 13 / and then so I'm have to

00:00:44,000 --> 00:00:51,900
bring back so please would rush to a lot

00:00:49,589 --> 00:00:55,530
what really happened it was like we did

00:00:51,900 --> 00:00:59,040
I was done with a sly explore not

00:00:55,530 --> 00:01:02,790
blessed and someone that I found out of

00:00:59,040 --> 00:01:06,300
control last year success so when

00:01:02,790 --> 00:01:09,390
I guess 10 microns tool 2013 so for fun

00:01:06,300 --> 00:01:28,050
I got together my outsider to troll

00:01:09,390 --> 00:01:30,800
troll kids yeah is what I'm

00:01:28,050 --> 00:01:32,930
actually doing is 165 three minute

00:01:30,800 --> 00:01:35,000
please / per minute I do have uploaded

00:01:32,930 --> 00:01:36,940
content most of this book and I was

00:01:35,000 --> 00:01:39,830
asked to do this summer to perforate

00:01:36,940 --> 00:01:42,440
every intention of doing that I only

00:01:39,830 --> 00:01:44,600
going to readily fast much of what I go

00:01:42,440 --> 00:01:47,150
over the pattern and will visit many

00:01:44,600 --> 00:01:49,460
many times so you don't even understand

00:01:47,150 --> 00:01:52,970
the first thing to do % third so just

00:01:49,460 --> 00:01:55,250
bear with me and shook Joe I was told

00:01:52,970 --> 00:01:57,140
few days go to my father's been 25

00:01:55,250 --> 00:01:59,540
minutes I did we miss this for 30

00:01:57,140 --> 00:02:04,040
minutes and that's going to stick to so

00:01:59,540 --> 00:02:07,310
I had a 15 minutes again whoa so when

00:02:04,040 --> 00:02:12,140
the real first question is why never

00:02:07,310 --> 00:02:15,200
what to do this festival talks of people

00:02:12,140 --> 00:02:17,630
last night as basically no we use

00:02:15,200 --> 00:02:20,330
interpreters Raj Ruby's meterpreter

00:02:17,630 --> 00:02:21,860
fascism stripper the internet we made

00:02:20,330 --> 00:02:26,840
our efforts of the trigger one way or

00:02:21,860 --> 00:02:28,310
another but I think conceptually this is

00:02:26,840 --> 00:02:31,070
one of those things like let's bring

00:02:28,310 --> 00:02:34,940
learning it alters your brains are very

00:02:31,070 --> 00:02:38,510
useful ways so it's not entirely number

00:02:34,940 --> 00:02:40,790
I am besides this is one of my nerdy

00:02:38,510 --> 00:02:44,870
perversions but really is because we can

00:02:40,790 --> 00:02:46,490
because it will ultimately so real quick

00:02:44,870 --> 00:02:48,980
show of hands

00:02:46,490 --> 00:02:51,530
you have CS backgrounds that took at a

00:02:48,980 --> 00:03:05,570
firm language theory or otherwise

00:02:51,530 --> 00:03:07,640
roadtrippers this cool so this box is

00:03:05,570 --> 00:03:11,570
not necessarily to you but I went over

00:03:07,640 --> 00:03:14,120
to lay with Mike latitude so brandoni

00:03:11,570 --> 00:03:17,360
Ruby interpreter is a very small subset

00:03:14,120 --> 00:03:21,790
of Ruby's is going to contain branching

00:03:17,360 --> 00:03:27,290
logic while loops local variables with

00:03:21,790 --> 00:03:29,480
algonquin versions of I functions this

00:03:27,290 --> 00:03:31,130
is the most complex chunk of code I

00:03:29,480 --> 00:03:33,530
expect you to be able to understand this

00:03:31,130 --> 00:03:35,900
talk anything my house with larger I

00:03:33,530 --> 00:03:37,940
might have a colostomy word on purpose

00:03:35,900 --> 00:03:40,640
or on the way to winning a detail Danny

00:03:37,940 --> 00:03:44,030
it's really the details about that for a

00:03:40,640 --> 00:03:45,920
larger than this in this function you

00:03:44,030 --> 00:03:47,810
can see that we have local variables we

00:03:45,920 --> 00:03:49,550
have what's called primitive function

00:03:47,810 --> 00:03:51,650
also has been supported cottage

00:03:49,550 --> 00:03:54,140
underline run and we have these

00:03:51,650 --> 00:03:58,070
different functions and in this case the

00:03:54,140 --> 00:04:00,260
function calls are person so the new

00:03:58,070 --> 00:04:03,650
road map looks been like this we have a

00:04:00,260 --> 00:04:05,540
parser with run high the environments

00:04:03,650 --> 00:04:07,790
and a top of that loop variable

00:04:05,540 --> 00:04:11,960
conditionals and then on top of all that

00:04:07,790 --> 00:04:17,150
stuff or obviously functions I do all my

00:04:11,960 --> 00:04:20,870
person using a jump every person it will

00:04:17,150 --> 00:04:23,210
take Ruby source move like this and on

00:04:20,870 --> 00:04:25,940
to parse it and output something

00:04:23,210 --> 00:04:28,640
conceptually looks like this it is

00:04:25,940 --> 00:04:32,050
confusing at first but eventually you

00:04:28,640 --> 00:04:32,050
will see blondes brunettes and redheads

00:04:36,340 --> 00:04:42,290
but for now we're just going to pull

00:04:38,840 --> 00:04:44,630
apart the clusters one at a time until

00:04:42,290 --> 00:04:46,730
you can start to see some powder for the

00:04:44,630 --> 00:04:48,590
structure itself and eventually we'll

00:04:46,730 --> 00:04:52,390
see something looks like this in the

00:04:48,590 --> 00:04:56,150
green fifth note that if node has

00:04:52,390 --> 00:04:59,720
conditioned case the top box set the sex

00:04:56,150 --> 00:05:01,400
box the suitcase and a false case that

00:04:59,720 --> 00:05:04,250
has the sum of two recursive calls all

00:05:01,400 --> 00:05:05,540
know there's five hospital what we're

00:05:04,250 --> 00:05:07,250
going to be looking at though we're not

00:05:05,540 --> 00:05:12,400
pretty little boxes this coating has

00:05:07,250 --> 00:05:14,840
about that it looks like this instead

00:05:12,400 --> 00:05:16,400
look at this and you study it for a

00:05:14,840 --> 00:05:18,920
little bit you're going to see one two

00:05:16,400 --> 00:05:20,690
three four five pockets where we have if

00:05:18,920 --> 00:05:23,480
conditions your base false case with

00:05:20,690 --> 00:05:25,130
some shooters it's exactly the same

00:05:23,480 --> 00:05:27,350
thing one to one with the diagram before

00:05:25,130 --> 00:05:30,830
and this is what we're going to be

00:05:27,350 --> 00:05:33,200
gained since vocabulary real quick this

00:05:30,830 --> 00:05:36,740
is called an S expression we get that

00:05:33,200 --> 00:05:38,900
terminology from this purse we are

00:05:36,740 --> 00:05:41,450
henceforth no two sections they have a

00:05:38,900 --> 00:05:45,620
head which markings is going to be the

00:05:41,450 --> 00:05:48,890
type of the note that we first in this

00:05:45,620 --> 00:05:51,230
plan that's also known as the car we're

00:05:48,890 --> 00:05:54,430
going to have the rest the list by

00:05:51,230 --> 00:05:59,840
medical cooter and that rest may have

00:05:54,430 --> 00:06:01,700
some so we get all that the free using

00:05:59,840 --> 00:06:04,310
the reverse again I'm not going to go

00:06:01,700 --> 00:06:06,440
over it anymore parts is really hard is

00:06:04,310 --> 00:06:09,110
its own

00:06:06,440 --> 00:06:12,020
semester and I think it's rather winding

00:06:09,110 --> 00:06:14,450
the actual purpose if you want to study

00:06:12,020 --> 00:06:16,220
up on a person with burner Michael

00:06:14,450 --> 00:06:18,410
Jackson gave a talk two years ago called

00:06:16,220 --> 00:06:22,730
parsing expressions in Ruby the video is

00:06:18,410 --> 00:06:24,500
up on conference is very good he is

00:06:22,730 --> 00:06:26,360
going over a different type of coarser

00:06:24,500 --> 00:06:30,410
than the type that I amazing but that's

00:06:26,360 --> 00:06:33,440
actually a consequential report on so

00:06:30,410 --> 00:06:38,810
let's talk about interpreter so just

00:06:33,440 --> 00:06:40,250
meet runtime how to UM get 750 + for the

00:06:38,810 --> 00:06:42,680
first thing that happens in to start the

00:06:40,250 --> 00:06:44,720
service you ask our street or whatever

00:06:42,680 --> 00:06:49,490
the price you have a parson you can get

00:06:44,720 --> 00:06:52,910
an AST back in space ssp you process my

00:06:49,490 --> 00:06:55,190
type first with the inter goggles now

00:06:52,910 --> 00:06:57,050
this is how most languages to it really

00:06:55,190 --> 00:06:59,810
does it pretty much everything else

00:06:57,050 --> 00:07:02,660
you've ever used best ball into the word

00:06:59,810 --> 00:07:05,390
evaluation but it's not someone who just

00:07:02,660 --> 00:07:07,490
choose not to that gives them a lot of

00:07:05,390 --> 00:07:11,750
flexibility basically it allows them to

00:07:07,490 --> 00:07:14,540
do macro systems about ecosystems then

00:07:11,750 --> 00:07:18,290
how do you do yours is entirely too so

00:07:14,540 --> 00:07:22,040
we start off with that lik3 and we

00:07:18,290 --> 00:07:25,730
interpret its value to be free we move

00:07:22,040 --> 00:07:28,340
on to the next in Subsection and the

00:07:25,730 --> 00:07:29,960
trip reports in school then we move

00:07:28,340 --> 00:07:34,310
along the outer know where we have a

00:07:29,960 --> 00:07:36,020
call three plus four and in this case

00:07:34,310 --> 00:07:39,410
let's say we look at the top that

00:07:36,020 --> 00:07:44,930
represents the addition operation and we

00:07:39,410 --> 00:07:47,990
call that pop with three and four out of

00:07:44,930 --> 00:07:50,520
seven this is just one way to do it from

00:07:47,990 --> 00:07:53,580
Ruby itself to define and measure

00:07:50,520 --> 00:07:55,050
dimensions of this language this is

00:07:53,580 --> 00:08:06,120
sometimes referred to as a mess circle

00:07:55,050 --> 00:08:10,380
around here maybe Mike okay sex p

00:08:06,120 --> 00:08:12,180
processor provides us with a dispatch to

00:08:10,380 --> 00:08:14,670
process methods based on the node type

00:08:12,180 --> 00:08:16,710
so when we come across lit three and we

00:08:14,670 --> 00:08:18,930
ask sex we processor processor to

00:08:16,710 --> 00:08:21,890
process it it's going to dispatch it off

00:08:18,930 --> 00:08:26,610
to process lit based on that first node

00:08:21,890 --> 00:08:27,480
first symbol in the SEC speed we're also

00:08:26,610 --> 00:08:29,880
going to be doing test-driven

00:08:27,480 --> 00:08:31,290
interpreters that adds another box to

00:08:29,880 --> 00:08:33,960
our roadmap that spans the entire thing

00:08:31,290 --> 00:08:36,870
and we're going to be doing unit tests

00:08:33,960 --> 00:08:38,969
that have an input source and an

00:08:36,870 --> 00:08:40,650
expected value and just do an assert

00:08:38,969 --> 00:08:43,260
equal there's nothing really important

00:08:40,650 --> 00:08:46,440
about this or magic about this it's the

00:08:43,260 --> 00:08:48,330
way I would do most projects but for the

00:08:46,440 --> 00:08:50,730
sake of time I'm going to prematurely

00:08:48,330 --> 00:08:53,130
refactor this into a cert of Val it's

00:08:50,730 --> 00:08:55,260
going to be calling Lang dot eval on the

00:08:53,130 --> 00:08:57,870
source itself get the value back and

00:08:55,260 --> 00:08:59,910
assert the the result to be equal to

00:08:57,870 --> 00:09:02,480
what we expect in this way we can say a

00:08:59,910 --> 00:09:05,010
certain about seven from three plus four

00:09:02,480 --> 00:09:07,440
so let's work on that let's get our

00:09:05,010 --> 00:09:09,930
sanity fest working let's implement our

00:09:07,440 --> 00:09:11,880
runtime let's implement our test

00:09:09,930 --> 00:09:13,380
infrastructure I'm going to prematurely

00:09:11,880 --> 00:09:14,490
refactor some of our infrastructure I'm

00:09:13,380 --> 00:09:16,860
going to start off with a setup and

00:09:14,490 --> 00:09:19,770
normally wouldn't do that but i am going

00:09:16,860 --> 00:09:21,840
to fit this into 21 more minutes let's

00:09:19,770 --> 00:09:24,390
instantiate an OB interpreter instance

00:09:21,840 --> 00:09:27,480
let's define a cert a vowel and give us

00:09:24,390 --> 00:09:30,270
an access ER to the interpreter and then

00:09:27,480 --> 00:09:33,630
I'm going to add our first test new code

00:09:30,270 --> 00:09:36,390
is going to be bold old code is going to

00:09:33,630 --> 00:09:38,220
be emitted and so to start we're going

00:09:36,390 --> 00:09:40,920
to interpret the atom three and expect

00:09:38,220 --> 00:09:44,310
the value of three and then we're going

00:09:40,920 --> 00:09:48,630
to parse three plus four or interpret 3

00:09:44,310 --> 00:09:50,790
plus 4 and expect the value of 7 3 plus

00:09:48,630 --> 00:09:52,320
4 is a standard sanity test from small

00:09:50,790 --> 00:09:54,000
talk when you're bootstrapping a new one

00:09:52,320 --> 00:09:56,339
that's generally what you start with to

00:09:54,000 --> 00:09:59,470
prove that you have gotten as far as you

00:09:56,339 --> 00:10:01,720
have and I'm going to honor that

00:09:59,470 --> 00:10:03,600
so the first thing that happens when we

00:10:01,720 --> 00:10:05,530
save that and run it is we get

00:10:03,600 --> 00:10:07,990
uninitialized constant Ruby interpreter

00:10:05,530 --> 00:10:09,190
it is really simple we haven't

00:10:07,990 --> 00:10:11,350
implemented anything so it doesn't know

00:10:09,190 --> 00:10:13,990
what the hell we're talking about so we

00:10:11,350 --> 00:10:15,550
sub class XP interpreter we named it ubi

00:10:13,990 --> 00:10:17,650
interpreter I throw in a version

00:10:15,550 --> 00:10:21,160
constant in order to make my rake tasks

00:10:17,650 --> 00:10:23,920
shut up and we move on to a slightly

00:10:21,160 --> 00:10:27,400
confusing error because I named it eval

00:10:23,920 --> 00:10:29,520
our entry point into this and that is

00:10:27,400 --> 00:10:32,530
overriding the eval method and Colonel

00:10:29,520 --> 00:10:34,270
but we haven't implemented it yet we're

00:10:32,530 --> 00:10:37,390
getting a private method error instead

00:10:34,270 --> 00:10:39,820
of a regular no method or that's fine so

00:10:37,390 --> 00:10:43,450
we move on to implementing some meat in

00:10:39,820 --> 00:10:46,240
our interpreter this is a vowel and

00:10:43,450 --> 00:10:48,400
friends and the only thing you need to

00:10:46,240 --> 00:10:50,230
worry about is that red line so we take

00:10:48,400 --> 00:10:52,780
the source that you are asked being

00:10:50,230 --> 00:10:55,030
asked to eval we pass that off to the

00:10:52,780 --> 00:10:56,920
parser and get a sec speed back and then

00:10:55,030 --> 00:10:59,260
we pass that off to sex be interpreters

00:10:56,920 --> 00:11:01,540
process method we've inherited that so

00:10:59,260 --> 00:11:02,950
we don't need to worry about it and we

00:11:01,540 --> 00:11:05,680
finally get to the error message that I

00:11:02,950 --> 00:11:07,570
want us to see we finally get unknown

00:11:05,680 --> 00:11:09,670
node type lids that's because we came

00:11:07,570 --> 00:11:13,020
across a node that the system hasn't

00:11:09,670 --> 00:11:16,350
defined yet and so sex p interpreter

00:11:13,020 --> 00:11:18,640
goes ahead and raises this error for us

00:11:16,350 --> 00:11:20,590
so we've talked about process lit a

00:11:18,640 --> 00:11:22,540
number of times now so we're just going

00:11:20,590 --> 00:11:23,980
to implement it as is and that's going

00:11:22,540 --> 00:11:26,140
to move us on to our second desertion

00:11:23,980 --> 00:11:28,900
where we get unknown node type call

00:11:26,140 --> 00:11:30,340
calls more complex I'm not going to

00:11:28,900 --> 00:11:32,410
cheat on this one so what I'm going to

00:11:30,340 --> 00:11:34,660
do instead is I'm going to raise on the

00:11:32,410 --> 00:11:36,850
inspect of the S expression to begin

00:11:34,660 --> 00:11:39,370
with it's kind of a roundabout way to do

00:11:36,850 --> 00:11:41,530
it but it allows us to see the pieces as

00:11:39,370 --> 00:11:44,020
they come and allows us to deal with

00:11:41,530 --> 00:11:45,400
this in small incremental changes I've

00:11:44,020 --> 00:11:47,110
color coded this so that we can help

00:11:45,400 --> 00:11:49,720
connect the dots we can see here that we

00:11:47,110 --> 00:11:52,690
have the node type of call a receiver of

00:11:49,720 --> 00:11:55,930
the literal 3 the message plus and a

00:11:52,690 --> 00:11:57,940
single argument of the literal form so

00:11:55,930 --> 00:11:59,620
now that we've seen the pieces we're

00:11:57,940 --> 00:12:02,560
going to use multiple assignment to

00:11:59,620 --> 00:12:04,510
non-destructively unpack that from s

00:12:02,560 --> 00:12:06,580
into named arguments so that we can deal

00:12:04,510 --> 00:12:08,560
with them easier so we unpack into

00:12:06,580 --> 00:12:10,060
underscore for the node type since we

00:12:08,560 --> 00:12:12,820
don't care about it

00:12:10,060 --> 00:12:14,680
receiver message and star args to get

00:12:12,820 --> 00:12:17,230
the rest of it we're going to change our

00:12:14,680 --> 00:12:20,260
arrays to show the components as they

00:12:17,230 --> 00:12:23,290
are rerun the test and see that we did

00:12:20,260 --> 00:12:25,360
it correctly from here we know that we

00:12:23,290 --> 00:12:27,370
can work on the sub sex peas so we go

00:12:25,360 --> 00:12:29,830
ahead and implement that we say that the

00:12:27,370 --> 00:12:32,680
receiver is equal to the recursive

00:12:29,830 --> 00:12:35,470
process of receiver that's the lit three

00:12:32,680 --> 00:12:37,960
and then we walk over args and map bang

00:12:35,470 --> 00:12:40,210
that to the recursion on them that's in

00:12:37,960 --> 00:12:41,590
this case the lit for we leave the Rays

00:12:40,210 --> 00:12:43,990
the same so that we can see that we did

00:12:41,590 --> 00:12:47,410
this correctly so now we're getting boom

00:12:43,990 --> 00:12:48,880
three plus and the array of four so now

00:12:47,410 --> 00:12:51,100
we know that this is right this looks

00:12:48,880 --> 00:12:52,540
absolutely perfect for what we want I'm

00:12:51,100 --> 00:12:54,370
going to go ahead and cheat and allow

00:12:52,540 --> 00:12:56,140
Ruby to do this for us I'll call

00:12:54,370 --> 00:12:58,330
receiver dots end with the message and

00:12:56,140 --> 00:12:59,590
then the arguments I'm going to mark

00:12:58,330 --> 00:13:01,620
that as a big old pack because we're

00:12:59,590 --> 00:13:05,110
going to revisit it a couple times that

00:13:01,620 --> 00:13:06,940
gets us our first stop this is good and

00:13:05,110 --> 00:13:08,200
this actually took about this long and I

00:13:06,940 --> 00:13:10,600
was working on the first pass of this

00:13:08,200 --> 00:13:14,200
implementation so let's go over what we

00:13:10,600 --> 00:13:16,510
have we've subclass XP interpreter we

00:13:14,200 --> 00:13:19,180
have instantiated a parser and defined a

00:13:16,510 --> 00:13:21,520
valve to parse and then process we've

00:13:19,180 --> 00:13:24,160
defined process lint and process call so

00:13:21,520 --> 00:13:26,290
what exactly do we have essentially an

00:13:24,160 --> 00:13:28,570
overblown calculate at this point so

00:13:26,290 --> 00:13:31,360
let's make it more useful let's add

00:13:28,570 --> 00:13:32,410
conditionals and define truthiness I'm

00:13:31,360 --> 00:13:33,640
going to go a little faster this time

00:13:32,410 --> 00:13:35,110
because we've already had our pattern

00:13:33,640 --> 00:13:36,940
two or three times and we're going to

00:13:35,110 --> 00:13:38,980
keep going on that so let's hit

00:13:36,940 --> 00:13:41,980
conditionals we're going to add three

00:13:38,980 --> 00:13:45,100
assertions one for the truth II case and

00:13:41,980 --> 00:13:46,930
two for the folsom cases and I'm going

00:13:45,100 --> 00:13:49,030
to follow Ruby's lead on this and say

00:13:46,930 --> 00:13:51,280
that fall see is just vanilla and false

00:13:49,030 --> 00:13:53,500
I could have said that it's just false

00:13:51,280 --> 00:13:55,930
and gone with that and that's fine but

00:13:53,500 --> 00:13:58,360
in this case i'd like to follow suit and

00:13:55,930 --> 00:14:01,720
then I'm just going to test true for the

00:13:58,360 --> 00:14:02,980
truth II case and move on so the first

00:14:01,720 --> 00:14:05,320
thing that happens we get unknown no

00:14:02,980 --> 00:14:07,330
type if exactly what we'd expect to get

00:14:05,320 --> 00:14:09,040
we go ahead and define that generically

00:14:07,330 --> 00:14:11,170
we go ahead and look at the components

00:14:09,040 --> 00:14:13,870
and here we can see the if node type the

00:14:11,170 --> 00:14:18,340
condition the true case in the false

00:14:13,870 --> 00:14:20,470
case so we go ahead and unpack using

00:14:18,340 --> 00:14:21,880
multiple assignment in to see tnf we

00:14:20,470 --> 00:14:23,530
process

00:14:21,880 --> 00:14:28,060
and then depending on the truthiness of

00:14:23,530 --> 00:14:30,700
C we process either t or F why would we

00:14:28,060 --> 00:14:32,440
evaluate see before tnf after all in the

00:14:30,700 --> 00:14:36,010
call code we went and did all the args

00:14:32,440 --> 00:14:38,380
at once well if you were evaluating code

00:14:36,010 --> 00:14:39,850
like this and it evaluated both sides

00:14:38,380 --> 00:14:45,310
before decided which one was the real

00:14:39,850 --> 00:14:47,110
one you'd have a bad day so the next

00:14:45,310 --> 00:14:48,730
thing that happens and we start to

00:14:47,110 --> 00:14:50,230
process the condition case and we can

00:14:48,730 --> 00:14:53,230
see here that we get unknown no type

00:14:50,230 --> 00:14:54,790
true and unknown no type nil those are

00:14:53,230 --> 00:14:56,560
easy enough so we go ahead and define

00:14:54,790 --> 00:15:00,340
them straight up and we use Ruby's nil

00:14:56,560 --> 00:15:03,670
and true that gets us to the third

00:15:00,340 --> 00:15:07,360
assertion unknown 0 type false no magic

00:15:03,670 --> 00:15:09,100
here and we get more dots this is the

00:15:07,360 --> 00:15:12,250
test driven process for an interpreter

00:15:09,100 --> 00:15:15,130
you add the failing test you get the

00:15:12,250 --> 00:15:17,560
error on an unknown node type you add a

00:15:15,130 --> 00:15:19,780
generic node type so you can see the

00:15:17,560 --> 00:15:23,470
components you get the failure on those

00:15:19,780 --> 00:15:26,170
sub sex B's you process the sub sex

00:15:23,470 --> 00:15:29,740
piece you get the test to pass and you

00:15:26,170 --> 00:15:31,360
repeat and it is this fast I use

00:15:29,740 --> 00:15:34,390
something called auto tests other people

00:15:31,360 --> 00:15:36,070
use guard whatever this is what it looks

00:15:34,390 --> 00:15:37,810
like when I code I have Emacs full

00:15:36,070 --> 00:15:39,790
screened I have the code and the test on

00:15:37,810 --> 00:15:41,460
the left and I have a hot key to flip

00:15:39,790 --> 00:15:43,600
back and forth between them

00:15:41,460 --> 00:15:45,790
intelligently based on naming convention

00:15:43,600 --> 00:15:47,530
and on the right I have auto test

00:15:45,790 --> 00:15:49,750
intelligently running my tests every

00:15:47,530 --> 00:15:52,150
time I save anything it knows how to

00:15:49,750 --> 00:15:54,670
rerun just failures when I go from a

00:15:52,150 --> 00:15:55,870
fail from red to green it reruns

00:15:54,670 --> 00:15:59,230
everything that make sure I didn't break

00:15:55,870 --> 00:16:01,750
anything else and an emacs auto test is

00:15:59,230 --> 00:16:04,230
going to hyperlink the airlines and the

00:16:01,750 --> 00:16:06,100
stack traces in order to make them

00:16:04,230 --> 00:16:10,720
clickable and you can go straight to the

00:16:06,100 --> 00:16:13,250
code I hope your brain hurts because I

00:16:10,720 --> 00:16:15,970
haven't even warmed up

00:16:13,250 --> 00:16:18,410
let's get on to actually storing state

00:16:15,970 --> 00:16:21,770
that's going to involve defining an

00:16:18,410 --> 00:16:24,170
environment and then parsing or

00:16:21,770 --> 00:16:27,110
interpreting the assignment of variables

00:16:24,170 --> 00:16:30,080
and the fetching of variables so we do a

00:16:27,110 --> 00:16:32,120
very simple test x equals 42 semicolon X

00:16:30,080 --> 00:16:35,360
we expect for you to come out of that

00:16:32,120 --> 00:16:36,740
first thing that happens is wait no we

00:16:35,360 --> 00:16:39,020
don't know what this is we didn't ask

00:16:36,740 --> 00:16:41,810
for this but let's just go ahead and use

00:16:39,020 --> 00:16:44,360
our irregular pattern to investigate so

00:16:41,810 --> 00:16:46,700
we define process block we look at it

00:16:44,360 --> 00:16:48,380
and we can see here that yes we had a

00:16:46,700 --> 00:16:49,820
semicolon in our code we have multiple

00:16:48,380 --> 00:16:52,580
expressions in that code that we're

00:16:49,820 --> 00:16:54,620
interpreting and therefore Ruby parser

00:16:52,580 --> 00:16:56,270
wrap that up in a block node you can see

00:16:54,620 --> 00:16:58,550
here that we have an l a-- sign for

00:16:56,270 --> 00:17:02,870
local variable assign and l VAR for

00:16:58,550 --> 00:17:04,459
fetch so i'm going to follow a ruby suit

00:17:02,870 --> 00:17:06,589
on this one as well and say that the

00:17:04,459 --> 00:17:08,630
last expression evaluated in any given

00:17:06,589 --> 00:17:11,630
piece of code is the value of that code

00:17:08,630 --> 00:17:13,850
so we define result equals no we walk

00:17:11,630 --> 00:17:15,230
over all the expressions we process each

00:17:13,850 --> 00:17:18,560
one and assign that to result in

00:17:15,230 --> 00:17:20,480
whoever's last wins and comes out that

00:17:18,560 --> 00:17:24,709
allows us to move on to ella sign is

00:17:20,480 --> 00:17:26,510
undefined we define it generically we

00:17:24,709 --> 00:17:28,940
look at its components here we can see

00:17:26,510 --> 00:17:34,970
that it is a plain name and a value of

00:17:28,940 --> 00:17:36,770
some sort we add a stupid table i'm

00:17:34,970 --> 00:17:38,390
going to define something called em and

00:17:36,770 --> 00:17:40,610
i'm going to sign a plain hash to it and

00:17:38,390 --> 00:17:42,530
then inside process ella sign i'm going

00:17:40,610 --> 00:17:45,410
to unpack the name and the value and

00:17:42,530 --> 00:17:50,180
then NM i'm going to assign to the name

00:17:45,410 --> 00:17:53,540
the process of that value that winds up

00:17:50,180 --> 00:17:54,680
at the table looks sort of like this now

00:17:53,540 --> 00:17:56,510
we need to be able to read because we've

00:17:54,680 --> 00:17:59,030
moved on to unknown node type l VAR

00:17:56,510 --> 00:18:01,160
that's really simple we get the name and

00:17:59,030 --> 00:18:02,330
we access the name now normally we'd

00:18:01,160 --> 00:18:04,400
want to do something here where we would

00:18:02,330 --> 00:18:06,440
warn if we were accessing something that

00:18:04,400 --> 00:18:07,490
wasn't defined before or raise or

00:18:06,440 --> 00:18:09,410
whatever you want for the semantics of

00:18:07,490 --> 00:18:13,840
your language i'm just going to let it

00:18:09,410 --> 00:18:13,840
go for now and we get more dots

00:18:14,710 --> 00:18:20,750
my brain hurts but that's because I'm

00:18:16,880 --> 00:18:22,190
caffeinated it does get better because

00:18:20,750 --> 00:18:24,950
we're moving onto functions the real

00:18:22,190 --> 00:18:27,950
meat so let's move on to functions and

00:18:24,950 --> 00:18:29,870
get this going so let's start off with

00:18:27,950 --> 00:18:34,760
something really simple double of n is 2

00:18:29,870 --> 00:18:36,110
times n call double 21 and expect 42 so

00:18:34,760 --> 00:18:38,620
the first thing that happens is exactly

00:18:36,110 --> 00:18:41,750
what we expect unknown node type deafen

00:18:38,620 --> 00:18:43,790
we define that generically we look at

00:18:41,750 --> 00:18:45,680
its components we can see here that we

00:18:43,790 --> 00:18:48,860
have the node type the name double an

00:18:45,680 --> 00:18:53,030
argument node with plain names in it and

00:18:48,860 --> 00:18:55,640
then whatever code follows we go ahead

00:18:53,030 --> 00:18:57,920
and unpack that using a multiple

00:18:55,640 --> 00:18:59,180
assignment we splat out the body because

00:18:57,920 --> 00:19:02,480
there could be multiple expressions in

00:18:59,180 --> 00:19:03,950
there and because this is a function

00:19:02,480 --> 00:19:05,540
that we're not running right now we're

00:19:03,950 --> 00:19:07,220
going to be storing it to run later

00:19:05,540 --> 00:19:08,660
we're not going to process it instead

00:19:07,220 --> 00:19:11,060
we're going to save off the body raw

00:19:08,660 --> 00:19:12,890
along with the arguments and put that in

00:19:11,060 --> 00:19:14,750
the environment that looks something

00:19:12,890 --> 00:19:18,200
like this here we can see the double is

00:19:14,750 --> 00:19:22,040
an array with args N and then an array

00:19:18,200 --> 00:19:24,530
of the code of the body next thing that

00:19:22,040 --> 00:19:26,360
happens is we call double 21 except that

00:19:24,530 --> 00:19:28,520
we get a no method or undefined method

00:19:26,360 --> 00:19:30,020
double for nil but if we look at the

00:19:28,520 --> 00:19:32,900
stack trace we can see that we are in

00:19:30,020 --> 00:19:34,910
process call where we expect to be but

00:19:32,900 --> 00:19:38,680
we're hitting that scent we're hitting

00:19:34,910 --> 00:19:40,970
that send on nil what's happened is

00:19:38,680 --> 00:19:42,620
there is no receiver we're calling

00:19:40,970 --> 00:19:44,960
double of 21 there's nothing on the

00:19:42,620 --> 00:19:47,840
front normally that might be self but in

00:19:44,960 --> 00:19:49,430
our case that's just no so what we want

00:19:47,840 --> 00:19:51,140
to do is we want to isolate that case

00:19:49,430 --> 00:19:55,130
based on the receiver I'm going to wrap

00:19:51,140 --> 00:19:57,350
that up in if receiver if we do have a

00:19:55,130 --> 00:20:00,250
receiver we go ahead and and execute

00:19:57,350 --> 00:20:02,750
that I mark it as less of a hack now and

00:20:00,250 --> 00:20:06,010
in the other case we're going to raise

00:20:02,750 --> 00:20:10,550
and we can see that we isolate our error

00:20:06,010 --> 00:20:12,770
so bear with me here now we add code to

00:20:10,550 --> 00:20:14,930
call a user method but what does that

00:20:12,770 --> 00:20:17,000
really entail when you call any function

00:20:14,930 --> 00:20:19,370
the first thing that happens is the

00:20:17,000 --> 00:20:21,380
arguments to that function wind up being

00:20:19,370 --> 00:20:23,870
local variables in your current scope

00:20:21,380 --> 00:20:25,280
that's what this code is doing so we

00:20:23,870 --> 00:20:26,870
unpacked the declarations of the

00:20:25,280 --> 00:20:29,960
function and the body using multiple

00:20:26,870 --> 00:20:31,520
assignment from the M and then we run a

00:20:29,960 --> 00:20:33,590
blob of code which I'm going to go into

00:20:31,520 --> 00:20:37,460
in a sec and then we can process the

00:20:33,590 --> 00:20:39,740
block of code so I'm sure you're

00:20:37,460 --> 00:20:42,110
thinking this to some extent but let's

00:20:39,740 --> 00:20:44,840
go into it we have this go that we're

00:20:42,110 --> 00:20:47,390
calling double of 21 we have the

00:20:44,840 --> 00:20:49,700
arguments which are now values we've

00:20:47,390 --> 00:20:52,010
already interpreted the values and we

00:20:49,700 --> 00:20:54,170
have the declaration for the function so

00:20:52,010 --> 00:20:57,920
we go ahead and take that code and get

00:20:54,170 --> 00:21:01,370
the names of the declarations and zip

00:20:57,920 --> 00:21:04,040
them against the values of the call that

00:21:01,370 --> 00:21:07,040
looks something like this n zip 21 each

00:21:04,040 --> 00:21:10,490
do and that winds up looking like this M

00:21:07,040 --> 00:21:12,710
sub n equals 21 and as you can see here

00:21:10,490 --> 00:21:16,010
we already had n in our environment and

00:21:12,710 --> 00:21:18,679
we have assigned over that while it gets

00:21:16,010 --> 00:21:22,520
our test to pass what it really means is

00:21:18,679 --> 00:21:25,040
that we just need more tests so let's

00:21:22,520 --> 00:21:28,790
fix them let's move on to Fibonacci make

00:21:25,040 --> 00:21:32,240
this harder so we define test fit with

00:21:28,790 --> 00:21:35,300
our usual definition and then expect

00:21:32,240 --> 00:21:37,340
that fib 6 is going to return 8 and what

00:21:35,300 --> 00:21:39,740
happens is it runs this time first time

00:21:37,340 --> 00:21:42,559
ever but we don't get the result that we

00:21:39,740 --> 00:21:45,860
expect we get three instead of eight so

00:21:42,559 --> 00:21:48,110
remember that stupid table something was

00:21:45,860 --> 00:21:50,179
in there and it got overwritten and that

00:21:48,110 --> 00:21:51,890
can happen multiple times so what

00:21:50,179 --> 00:21:55,520
happens is we start off with any eight

00:21:51,890 --> 00:21:58,660
we call fib six because fibs argument is

00:21:55,520 --> 00:22:01,390
n that's going to overwrite the table 26

00:21:58,660 --> 00:22:04,970
can for gets called when it recursive

00:22:01,390 --> 00:22:07,670
happens again and so on what we actually

00:22:04,970 --> 00:22:10,550
want is for that environment to be smart

00:22:07,670 --> 00:22:14,750
about where we are in our code we want

00:22:10,550 --> 00:22:18,170
two stacked hash we want it to on each

00:22:14,750 --> 00:22:20,450
call look like a flattened version of

00:22:18,170 --> 00:22:22,580
that original hash but we want it to

00:22:20,450 --> 00:22:24,500
maintain that stack as we go along so as

00:22:22,580 --> 00:22:26,840
we pop back out we get our previous

00:22:24,500 --> 00:22:28,580
results we're going to call that the

00:22:26,840 --> 00:22:30,110
environment class we're going to make it

00:22:28,580 --> 00:22:33,080
so that assignments happen to the top of

00:22:30,110 --> 00:22:35,720
the stack at all times but fetches will

00:22:33,080 --> 00:22:37,280
happen anywhere that code looks like

00:22:35,720 --> 00:22:39,080
this you don't need to understand this

00:22:37,280 --> 00:22:40,190
code all you need to understand is that

00:22:39,080 --> 00:22:42,200
gets

00:22:40,190 --> 00:22:45,769
we'll call all and read from everything

00:22:42,200 --> 00:22:48,740
that assignments will call last to

00:22:45,769 --> 00:22:51,320
assign to the top that all will flatten

00:22:48,740 --> 00:22:53,029
in the newest one wins and that we have

00:22:51,320 --> 00:22:55,669
a method a helper method called scope

00:22:53,029 --> 00:22:57,679
which pushes on a new scope yields to

00:22:55,669 --> 00:22:59,659
the code and then make sure that that

00:22:57,679 --> 00:23:03,019
scope gets popped back off so we never

00:22:59,659 --> 00:23:04,610
have a mystic we're going to go ahead

00:23:03,019 --> 00:23:06,740
and replace our stupid hash with

00:23:04,610 --> 00:23:08,929
environment and then we're going to take

00:23:06,740 --> 00:23:11,570
our calls and wrap them up in that scope

00:23:08,929 --> 00:23:14,570
helper that's going to allow the

00:23:11,570 --> 00:23:16,159
recursion to go down and pop all the way

00:23:14,570 --> 00:23:18,559
back up and have the right values of

00:23:16,159 --> 00:23:24,049
each step finally we get all of our dots

00:23:18,559 --> 00:23:25,909
so at this point to show that we have

00:23:24,049 --> 00:23:29,049
something solid and because I have more

00:23:25,909 --> 00:23:30,950
time and to make this touring complete

00:23:29,049 --> 00:23:33,409
let's tie everything together with a

00:23:30,950 --> 00:23:35,809
much harder construct or much harder

00:23:33,409 --> 00:23:38,179
test pretty easy construct overall

00:23:35,809 --> 00:23:40,009
that's going to tie a lot of the other

00:23:38,179 --> 00:23:45,409
concepts together and really just wrap

00:23:40,009 --> 00:23:47,269
this up this section took me about 10

00:23:45,409 --> 00:23:48,950
minutes to implement another 20 minutes

00:23:47,269 --> 00:23:49,850
for the slides so the fact that the

00:23:48,950 --> 00:23:54,409
slides are harder than the

00:23:49,850 --> 00:23:58,460
implementation says something so we

00:23:54,409 --> 00:24:01,519
refactor Fibonacci and then we add a new

00:23:58,460 --> 00:24:02,419
test test while some up fibs what we

00:24:01,519 --> 00:24:04,549
want to do is we're going to calculate

00:24:02,419 --> 00:24:06,769
the sum of the Fibonacci series from 1

00:24:04,549 --> 00:24:08,600
to 10 as you can see here we're using

00:24:06,769 --> 00:24:11,120
local variables we're using primitive

00:24:08,600 --> 00:24:12,980
calls we're using a recursive user calls

00:24:11,120 --> 00:24:17,299
and all of that's heavily using the

00:24:12,980 --> 00:24:19,009
environment across everything next thing

00:24:17,299 --> 00:24:21,139
that happens is we get the unknown node

00:24:19,009 --> 00:24:24,019
type while as we expect we go ahead and

00:24:21,139 --> 00:24:26,269
define it generically we look at the sub

00:24:24,019 --> 00:24:28,429
sex piece we see the wild node type we

00:24:26,269 --> 00:24:31,279
see the condition code and then we see

00:24:28,429 --> 00:24:34,100
the body of code for the actual loop and

00:24:31,279 --> 00:24:35,480
then we have this true artifact that

00:24:34,100 --> 00:24:37,789
comes from Ruby parser and we're going

00:24:35,480 --> 00:24:39,529
to ignore that for now that defines

00:24:37,789 --> 00:24:41,210
whether or not this is a pre or post

00:24:39,529 --> 00:24:42,679
while condition and we're not going to

00:24:41,210 --> 00:24:45,919
support that we're only support in one

00:24:42,679 --> 00:24:49,639
form so we unpack into cond and splat

00:24:45,919 --> 00:24:53,280
body we pop off that true then while we

00:24:49,639 --> 00:24:54,870
can process cond to a truth value we

00:24:53,280 --> 00:24:58,590
go ahead and process block and wrap up

00:24:54,870 --> 00:25:01,530
body into a block and run it that works

00:24:58,590 --> 00:25:03,030
the first time through not necessarily

00:25:01,530 --> 00:25:08,400
something we've seen before but it is

00:25:03,030 --> 00:25:11,180
that simple so what have we done we've

00:25:08,400 --> 00:25:14,160
written a fairly small amount of code

00:25:11,180 --> 00:25:16,230
we've subclass sexby interpreter we have

00:25:14,160 --> 00:25:19,020
instantiated a parser in an environment

00:25:16,230 --> 00:25:24,780
we've defined a vow we've processed

00:25:19,020 --> 00:25:28,980
blocks calls methods or functions false

00:25:24,780 --> 00:25:32,430
if L assign lit l VAR nil true and while

00:25:28,980 --> 00:25:35,550
we've defined a stacked hash and we've

00:25:32,430 --> 00:25:37,710
written some tests for all this the ubi

00:25:35,550 --> 00:25:39,810
language supports basic numeric types to

00:25:37,710 --> 00:25:42,150
folsom known it supports conditional

00:25:39,810 --> 00:25:43,890
branching and looping it has primitive

00:25:42,150 --> 00:25:46,380
functions and user-defined functions

00:25:43,890 --> 00:25:48,120
which can be recursive has local

00:25:46,380 --> 00:25:50,580
variables and variable scoping it is

00:25:48,120 --> 00:25:53,280
test-driven it is extensible is the

00:25:50,580 --> 00:25:54,690
patterns based design it took about two

00:25:53,280 --> 00:25:56,820
hours to write the first implementation

00:25:54,690 --> 00:25:59,490
of it it's about a hundred and thirty

00:25:56,820 --> 00:26:01,650
lines of implementation about 70 lines

00:25:59,490 --> 00:26:04,920
of tests and most importantly it fits in

00:26:01,650 --> 00:26:06,990
one head what else can we do with this

00:26:04,920 --> 00:26:10,290
we can add richer types we can add

00:26:06,990 --> 00:26:12,600
strings arrays hashes graphs any type of

00:26:10,290 --> 00:26:14,370
thing you want to add to it we can

00:26:12,600 --> 00:26:17,010
enforce different scoping rules like

00:26:14,370 --> 00:26:20,330
rubies def doesn't see outer locals and

00:26:17,010 --> 00:26:23,670
ours dots ours is a lot more like scheme

00:26:20,330 --> 00:26:25,590
we can implement recursive tail calls we

00:26:23,670 --> 00:26:28,160
can add an object system we can change

00:26:25,590 --> 00:26:31,530
the way functions are called themselves

00:26:28,160 --> 00:26:33,000
for further study I highly recommend the

00:26:31,530 --> 00:26:36,870
structure and interpretation of computer

00:26:33,000 --> 00:26:38,880
programs to this day Gerald Sussman is

00:26:36,870 --> 00:26:41,160
given the best talk I've ever been to

00:26:38,880 --> 00:26:43,980
the signal and noise is through the roof

00:26:41,160 --> 00:26:46,170
and we had five people collaboratively

00:26:43,980 --> 00:26:50,160
editing one text document trying to keep

00:26:46,170 --> 00:26:53,760
up with him it was hard afterwards you

00:26:50,160 --> 00:26:57,330
get to say that you know sicp

00:26:53,760 --> 00:26:59,670
I also highly recommend the little

00:26:57,330 --> 00:27:01,800
schemer and the season schemer these

00:26:59,670 --> 00:27:05,220
books are written and Socratic dialogue

00:27:01,800 --> 00:27:08,130
in and of itself that's weird and you

00:27:05,220 --> 00:27:09,930
need to read it just to get a notion of

00:27:08,130 --> 00:27:11,610
what that means they start from absolute

00:27:09,930 --> 00:27:13,230
scratch you don't have to know any less

00:27:11,610 --> 00:27:16,050
per scheme whatsoever to get started and

00:27:13,230 --> 00:27:17,550
by the time you're done you're Jim

00:27:16,050 --> 00:27:22,020
wyrick because you actually know the Y

00:27:17,550 --> 00:27:24,000
Combinator there's a follow-up book

00:27:22,020 --> 00:27:26,700
called the seat of the reasons schemer

00:27:24,000 --> 00:27:29,880
and that implements a prologue like

00:27:26,700 --> 00:27:32,340
inference system on top of scheme if you

00:27:29,880 --> 00:27:34,830
get the chance grab this book and then

00:27:32,340 --> 00:27:38,130
immediately before you even open it go

00:27:34,830 --> 00:27:40,430
watch it was Friedman and bird gave a

00:27:38,130 --> 00:27:45,150
talk at closure comp last year which was

00:27:40,430 --> 00:27:47,310
mind-boggling they they run this

00:27:45,150 --> 00:27:49,740
interpreter through a prologue inference

00:27:47,310 --> 00:27:53,490
system to have it derived code for the

00:27:49,740 --> 00:27:54,540
result they want think about that I'm

00:27:53,490 --> 00:27:55,920
assuming that I have no time for

00:27:54,540 --> 00:27:59,720
questions so please grab me in the

00:27:55,920 --> 00:27:59,720
hallway thank

00:28:08,000 --> 00:28:13,650
because I do have two minutes left I'm

00:28:10,380 --> 00:28:16,590
going to do a little bonus round I love

00:28:13,650 --> 00:28:18,420
this typeface it kills me every time I

00:28:16,590 --> 00:28:19,980
look at it I think it has absolutely

00:28:18,420 --> 00:28:22,950
gorgeous lettering and even more

00:28:19,980 --> 00:28:25,170
gorgeous ligatures so what I did instead

00:28:22,950 --> 00:28:28,080
of working on this talk is I wrote some

00:28:25,170 --> 00:28:29,580
Ruby code to score all the words in the

00:28:28,080 --> 00:28:33,390
English language for how ligature they

00:28:29,580 --> 00:28:35,130
can beat and in doing so figured out

00:28:33,390 --> 00:28:42,140
that one of the top five words is anti

00:28:35,130 --> 00:28:42,140
productivity it might have been a clue

00:28:45,280 --> 00:28:50,280
so as promised some of my foster kittens

00:28:50,730 --> 00:28:58,110
this was this was my last batch thank

00:29:03,740 --> 00:29:11,250
just some questions 2 questions let's do

00:29:06,540 --> 00:29:18,060
some questions how do you do be in what

00:29:11,250 --> 00:29:20,910
sense I do not have a gem out there I

00:29:18,060 --> 00:29:23,130
could do that this afternoon I do have

00:29:20,910 --> 00:29:27,330
the PDF up there I tweeted it last night

00:29:23,130 --> 00:29:31,140
on my the underscores end spider Twitter

00:29:27,330 --> 00:29:36,300
account does anyone know the person owns

00:29:31,140 --> 00:29:40,850
and spider you punch them any other

00:29:36,300 --> 00:29:40,850
questions hands back

00:29:50,530 --> 00:29:55,040
the question is with the environment

00:29:53,420 --> 00:29:56,330
class that I have adding closures

00:29:55,040 --> 00:29:58,760
wouldn't actually be all that difficult

00:29:56,330 --> 00:30:02,080
would it the answer is no it probably

00:29:58,760 --> 00:30:05,000
would not if you have it so that a given

00:30:02,080 --> 00:30:08,210
closure construct can point to the stack

00:30:05,000 --> 00:30:09,950
at the time that it was created then it

00:30:08,210 --> 00:30:13,610
would keep that reference alive forever

00:30:09,950 --> 00:30:17,600
and would act as its environment yeah it

00:30:13,610 --> 00:30:19,820
should totally work I might have my

00:30:17,600 --> 00:30:21,260
stack operating in the wrong direction

00:30:19,820 --> 00:30:22,670
we might have to change the environment

00:30:21,260 --> 00:30:24,860
class a little bit so that it would

00:30:22,670 --> 00:30:30,680
actually fan out its tree but other than

00:30:24,860 --> 00:30:34,100
that it should work anyone else brains

00:30:30,680 --> 00:30:37,340
bloated yes okay now because I came to

00:30:34,100 --> 00:30:41,920
the system and entered two point nine

00:30:37,340 --> 00:30:41,920
nine nine minutes for my lightning talk

00:30:45,280 --> 00:30:52,610
the talk real quick about fuzzy

00:30:47,450 --> 00:30:56,090
duplication detection and flight so who

00:30:52,610 --> 00:30:59,480
here knows what Flay is who here has

00:30:56,090 --> 00:31:03,340
never heard of fly you guys are in for a

00:30:59,480 --> 00:31:05,180
treat okay so who's heard of flog

00:31:03,340 --> 00:31:07,100
actually wait I don't care about those

00:31:05,180 --> 00:31:09,170
hands of the people who raised your

00:31:07,100 --> 00:31:12,620
hands that have never heard of Flay who

00:31:09,170 --> 00:31:16,040
has heard of flock two three four

00:31:12,620 --> 00:31:17,570
awesome even better go look at both I'm

00:31:16,040 --> 00:31:20,090
only going to talk about fly so what is

00:31:17,570 --> 00:31:24,920
flight flight detects duplicate meaning

00:31:20,090 --> 00:31:28,040
identical code in Ruby it detects

00:31:24,920 --> 00:31:29,360
structurally similar code which is a

00:31:28,040 --> 00:31:30,980
little confusing as to what that might

00:31:29,360 --> 00:31:33,440
mean it is actually language independent

00:31:30,980 --> 00:31:35,390
it does work on a STS generically it

00:31:33,440 --> 00:31:37,130
doesn't actually care what language it

00:31:35,390 --> 00:31:39,590
was originally it does work out of the

00:31:37,130 --> 00:31:43,010
box with Ruby and ER be it could work

00:31:39,590 --> 00:31:44,480
with Hamel or anything else javascript

00:31:43,010 --> 00:31:46,160
see all those things are possible as

00:31:44,480 --> 00:31:48,110
long as there's a parser for it Ruby we

00:31:46,160 --> 00:31:50,150
can hook it up so what is structurally

00:31:48,110 --> 00:31:51,710
similar mean these two things are

00:31:50,150 --> 00:31:53,090
structurally similar they are not the

00:31:51,710 --> 00:31:55,220
same code they do not come up with the

00:31:53,090 --> 00:31:58,580
same results but they are candidates for

00:31:55,220 --> 00:32:00,680
refactoring if you want to flay points

00:31:58,580 --> 00:32:01,260
these two things out as possible

00:32:00,680 --> 00:32:03,750
candidates

00:32:01,260 --> 00:32:07,110
refactoring so for fun let's pick on

00:32:03,750 --> 00:32:12,600
rails it's easy pickins if we go ahead

00:32:07,110 --> 00:32:13,920
and Flay rails so Flay scores basically

00:32:12,600 --> 00:32:16,290
we'll give you a number and then details

00:32:13,920 --> 00:32:18,360
if you ask for it on the structural

00:32:16,290 --> 00:32:20,520
similarities and the duplicate code in

00:32:18,360 --> 00:32:24,120
your code base it'll give you a number

00:32:20,520 --> 00:32:26,250
that number is only meaningful relative

00:32:24,120 --> 00:32:28,200
two more runs against the same code

00:32:26,250 --> 00:32:31,110
those things are not absolute values you

00:32:28,200 --> 00:32:33,660
can't compare one person's projects flay

00:32:31,110 --> 00:32:36,780
value to another person's projects flay

00:32:33,660 --> 00:32:38,730
value that's meaningless but over time

00:32:36,780 --> 00:32:40,800
your project will have Flay go up or

00:32:38,730 --> 00:32:46,110
down and that's actually very very

00:32:40,800 --> 00:32:52,440
useful right now place scores rails at a

00:32:46,110 --> 00:32:56,280
whopping just less than 73,000 shoot 400

00:32:52,440 --> 00:32:57,810
is a good score it points out that the

00:32:56,280 --> 00:33:00,030
number one worst thing in it is the

00:32:57,810 --> 00:33:02,900
identical code found across all of those

00:33:00,030 --> 00:33:06,090
files which looks oops looks like this

00:33:02,900 --> 00:33:07,830
and you know you look at that code for a

00:33:06,090 --> 00:33:09,960
little bit and you think well you know

00:33:07,830 --> 00:33:12,720
what that might actually be useful for

00:33:09,960 --> 00:33:16,250
other people writing tests maybe we

00:33:12,720 --> 00:33:19,530
should refractor this the answer is duh

00:33:16,250 --> 00:33:22,350
it should probably be available in the

00:33:19,530 --> 00:33:24,150
the generic test case that's available

00:33:22,350 --> 00:33:25,980
in rails so that everyone can take

00:33:24,150 --> 00:33:28,580
advantage of it because time zones are

00:33:25,980 --> 00:33:32,130
kind of a it also points out

00:33:28,580 --> 00:33:33,930
similar code across files doesn't matter

00:33:32,130 --> 00:33:36,270
where the code is it can figure it out

00:33:33,930 --> 00:33:40,910
and if you want it can show you the

00:33:36,270 --> 00:33:40,910
similarities with kind of a n way diff

00:33:41,930 --> 00:33:48,870
this code is the same across about a

00:33:46,260 --> 00:33:49,950
hundred lines with the three exceptions

00:33:48,870 --> 00:33:52,500
I don't have a room to show the third

00:33:49,950 --> 00:33:53,880
one and the exceptions are really really

00:33:52,500 --> 00:33:56,520
straightforward so this is a very good

00:33:53,880 --> 00:33:59,310
candidate for refactoring in fact this

00:33:56,520 --> 00:34:03,900
is a very good candidate for sub classic

00:33:59,310 --> 00:34:05,820
such a hard concept so I've added this

00:34:03,900 --> 00:34:07,380
thing recently I haven't published it

00:34:05,820 --> 00:34:12,149
but I've been working on this thing that

00:34:07,380 --> 00:34:13,670
I'm calling fuzzy detection so given

00:34:12,149 --> 00:34:17,340
this code

00:34:13,670 --> 00:34:21,080
def a B and C right now Flay will say

00:34:17,340 --> 00:34:23,670
you know what a and C are very similar

00:34:21,080 --> 00:34:25,590
while they don't it doesn't Flay doesn't

00:34:23,670 --> 00:34:28,560
care about names it cares about

00:34:25,590 --> 00:34:31,740
structure and the AST for def a looks

00:34:28,560 --> 00:34:34,560
very similar to the AST for def see they

00:34:31,740 --> 00:34:38,150
have the same number of calls and the

00:34:34,560 --> 00:34:40,590
same structure over all be however

00:34:38,150 --> 00:34:44,100
despite the fact that it is only one

00:34:40,590 --> 00:34:45,660
statement different from a does not get

00:34:44,100 --> 00:34:48,780
reported and i've been wondering how to

00:34:45,660 --> 00:34:52,410
do that for a while well i've added it

00:34:48,780 --> 00:34:56,070
and it winds up doing things like this

00:34:52,410 --> 00:35:00,000
it will say that this block of code four

00:34:56,070 --> 00:35:01,740
times in this file are pretty close to

00:35:00,000 --> 00:35:03,900
each other and at three of them had to

00:35:01,740 --> 00:35:05,730
be modified in this case by only one

00:35:03,900 --> 00:35:09,780
expression to make it the same something

00:35:05,730 --> 00:35:12,930
else so if we look at that code we can

00:35:09,780 --> 00:35:15,420
see that we have this test here and that

00:35:12,930 --> 00:35:18,800
test there so the only thing that

00:35:15,420 --> 00:35:23,730
changes between them are the test name

00:35:18,800 --> 00:35:27,510
that only value and one assert not know

00:35:23,730 --> 00:35:31,980
that could be easily refracted and made

00:35:27,510 --> 00:35:37,590
much cleaner so when we do Flay rails we

00:35:31,980 --> 00:35:41,600
get 70 2947 when we do it with fuzzy we

00:35:37,590 --> 00:35:45,960
get 80 2411 or an increase of nearly

00:35:41,600 --> 00:35:48,270
9500 I'm not done with this yet I'm not

00:35:45,960 --> 00:35:52,140
really ready to publish it yet i'm still

00:35:48,270 --> 00:35:55,650
doing attacks on the code to try to make

00:35:52,140 --> 00:35:56,610
it more useful and faster but it's

00:35:55,650 --> 00:35:59,220
coming along and i would love to

00:35:56,610 --> 00:36:01,310
demonstrate it to anyone wants to thank

00:35:59,220 --> 00:36:01,310
you

00:36:16,079 --> 00:36:18,109
Oh

00:36:36,300 --> 00:36:38,330

YouTube URL: https://www.youtube.com/watch?v=r1JMxJ06I98


