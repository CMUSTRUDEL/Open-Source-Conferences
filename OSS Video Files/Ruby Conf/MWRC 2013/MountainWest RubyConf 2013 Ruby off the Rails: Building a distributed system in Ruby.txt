Title: MountainWest RubyConf 2013 Ruby off the Rails: Building a distributed system in Ruby
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Title: Ruby off the Rails: Building a distributed system in Ruby
Presented by: Matthew Kocher

Devops Borat said "is turtle all way down but at bottom is perl script, but in the case of Cloud Foundry there's Ruby at the bottom. Rails is the right choice for building a web site, but the elegance of ruby can be applied to many other things including a Platform as a Service. A full deploy of Cloud Foundry requires many different kinds of nodes, with multiple Sinatra apps, event machine based daemons, shared ruby gems, and small amounts of code in other languages like Lua, Go and C where it makes sense. I'd like to take you on a tour of an open source codebase and project that really shows where you can go with Ruby.

Help us caption & translate this video!

http://amara.org/v/FGbQ/
Captions: 
	00:00:16,380 --> 00:00:19,380
hey

00:00:20,029 --> 00:00:28,439
right so I'm a developer at pivotal labs

00:00:26,550 --> 00:00:31,289
I've been working on Cloud Foundry for

00:00:28,439 --> 00:00:33,210
the last six months or so it's been a

00:00:31,289 --> 00:00:35,600
really fun system to work on it's a

00:00:33,210 --> 00:00:38,309
large distributed system written in Ruby

00:00:35,600 --> 00:00:39,690
that's a platform as a service I'll get

00:00:38,309 --> 00:00:42,600
into a little bit more about what it is

00:00:39,690 --> 00:00:44,309
as a talk goes on I wanted to go over

00:00:42,600 --> 00:00:46,170
sort of the bad old days of what we

00:00:44,309 --> 00:00:48,150
talked about yesterday which was how we

00:00:46,170 --> 00:00:50,220
deploy applications if we're not using

00:00:48,150 --> 00:00:51,329
pass which is first we get to write the

00:00:50,220 --> 00:00:53,879
code which is what we're spending the

00:00:51,329 --> 00:00:55,559
two days talking about and then we have

00:00:53,879 --> 00:00:58,620
all of these other manual steps that we

00:00:55,559 --> 00:01:00,750
talked about yesterday provisioning

00:00:58,620 --> 00:01:02,760
servers installing a runtime installing

00:01:00,750 --> 00:01:05,100
database is setting up the NS setting up

00:01:02,760 --> 00:01:07,259
load balancers all of this stuff is

00:01:05,100 --> 00:01:10,170
stuff that some developers really love

00:01:07,259 --> 00:01:12,479
getting into and some developers would

00:01:10,170 --> 00:01:14,820
much rather not have to talk not have to

00:01:12,479 --> 00:01:17,280
deal with it at all so sort of the new

00:01:14,820 --> 00:01:20,550
workflow that we're looking a lot sorry

00:01:17,280 --> 00:01:23,009
a lot of times I've worked on small

00:01:20,550 --> 00:01:26,550
startups where we've used Heroku and the

00:01:23,009 --> 00:01:28,560
first day we deploy and it's one you

00:01:26,550 --> 00:01:30,240
know it's it's 30 minutes to deploy and

00:01:28,560 --> 00:01:32,190
then if you work for a large company

00:01:30,240 --> 00:01:33,420
where you're still in the old process

00:01:32,190 --> 00:01:35,340
you feel like this is what their data

00:01:33,420 --> 00:01:38,130
center still looks like it's a data

00:01:35,340 --> 00:01:40,349
center out of the 1950s where you file a

00:01:38,130 --> 00:01:43,470
ticket and the operator will get back to

00:01:40,349 --> 00:01:46,020
you when it's ready so we have a new

00:01:43,470 --> 00:01:48,300
plan for deployment which is steal the

00:01:46,020 --> 00:01:49,979
underpants deploy code and profit I

00:01:48,300 --> 00:01:51,119
think there's one step in here that we

00:01:49,979 --> 00:01:55,229
don't need but I haven't able to figure

00:01:51,119 --> 00:01:57,690
out which one it is so what I like to

00:01:55,229 --> 00:02:02,099
say is there's an app for that and it's

00:01:57,690 --> 00:02:06,200
cloud foundry so what Cloud Foundry is

00:02:02,099 --> 00:02:08,489
is a system that mimics what you see or

00:02:06,200 --> 00:02:10,110
which makes it very easy to deploy

00:02:08,489 --> 00:02:11,099
applications you want to be able to give

00:02:10,110 --> 00:02:13,260
it code and you want to see your

00:02:11,099 --> 00:02:17,580
application running on the internet in a

00:02:13,260 --> 00:02:20,400
matter of minutes it's entirely open

00:02:17,580 --> 00:02:24,360
source and the vast majority of it is

00:02:20,400 --> 00:02:26,040
written in Ruby so I think a lot of

00:02:24,360 --> 00:02:28,469
developers sort of get started with Ruby

00:02:26,040 --> 00:02:30,030
on written with rails and they've seen

00:02:28,469 --> 00:02:31,560
web apps written in Ruby they may have

00:02:30,030 --> 00:02:33,540
seen a couple gems

00:02:31,560 --> 00:02:35,280
but this is a system that looks entirely

00:02:33,540 --> 00:02:37,470
different it has all sorts of Ruby

00:02:35,280 --> 00:02:39,780
demons a lot of them most of them

00:02:37,470 --> 00:02:42,239
written with event machine a lot of them

00:02:39,780 --> 00:02:45,510
communicating over a message bus and

00:02:42,239 --> 00:02:47,280
have having very little you I a set

00:02:45,510 --> 00:02:49,650
aside from monitoring and monitoring

00:02:47,280 --> 00:02:51,630
endpoints so but for the vast majority

00:02:49,650 --> 00:02:54,000
of its Ruby so it's really fun to go

00:02:51,630 --> 00:02:56,040
through it took me probably a week

00:02:54,000 --> 00:02:57,630
before I had any idea what I was looking

00:02:56,040 --> 00:03:00,390
at when i first started looking at the

00:02:57,630 --> 00:03:02,340
code i sort of sat down on my computer

00:03:00,390 --> 00:03:04,380
and like well let's start setting it up

00:03:02,340 --> 00:03:07,230
and a week later I sort of came back and

00:03:04,380 --> 00:03:09,000
was like oh I've got it set up now so my

00:03:07,230 --> 00:03:11,340
goal with this talk is sort of give you

00:03:09,000 --> 00:03:13,560
an idea of what these components are

00:03:11,340 --> 00:03:15,209
that you have to set up and how they fit

00:03:13,560 --> 00:03:16,980
together I'm not going to go into all

00:03:15,209 --> 00:03:21,450
the edge cases because we'd be here for

00:03:16,980 --> 00:03:24,269
a week the first part of cloud foundry

00:03:21,450 --> 00:03:26,190
that you encounter is a simple gem we

00:03:24,269 --> 00:03:28,110
recently renamed this to CF because the

00:03:26,190 --> 00:03:30,510
used to be called vmc and we didn't know

00:03:28,110 --> 00:03:33,510
what vmc stood for so we figured CF made

00:03:30,510 --> 00:03:37,890
a lot more sense this is probably the

00:03:33,510 --> 00:03:43,980
most clear Ruby code in the system it's

00:03:37,890 --> 00:03:46,350
a gem we're as Ruby developers we're

00:03:43,980 --> 00:03:48,959
used to dealing with gems we know what

00:03:46,350 --> 00:03:51,329
they look like you do gemma you do gem

00:03:48,959 --> 00:03:53,010
install you download it you run you run

00:03:51,329 --> 00:03:56,250
CF it tells you what you need to do to

00:03:53,010 --> 00:03:57,930
interact with the system and once you

00:03:56,250 --> 00:04:00,480
enter commands it eventually assembles

00:03:57,930 --> 00:04:03,480
your commands into HTTP requests that it

00:04:00,480 --> 00:04:06,299
sends up the cloud foundry it's pretty

00:04:03,480 --> 00:04:08,730
easy to work with we've recently

00:04:06,299 --> 00:04:10,829
rewritten a lot of this there's still a

00:04:08,730 --> 00:04:15,239
lot of refactoring to go but it's

00:04:10,829 --> 00:04:16,530
getting better so this is sort of the

00:04:15,239 --> 00:04:18,000
diagram that we have right now what

00:04:16,530 --> 00:04:19,919
you've heard about so far is we have

00:04:18,000 --> 00:04:21,930
some developers and we have a CF gem

00:04:19,919 --> 00:04:23,160
they're out on the internets this

00:04:21,930 --> 00:04:24,660
doesn't get you very far when you're

00:04:23,160 --> 00:04:27,419
trying to deploy an application in the

00:04:24,660 --> 00:04:29,729
cloud you can enter some commands but

00:04:27,419 --> 00:04:31,050
eventually nothing actually happens so

00:04:29,729 --> 00:04:33,419
we're going to need to add something to

00:04:31,050 --> 00:04:35,510
this the component that we add is sort

00:04:33,419 --> 00:04:38,880
of the central brain of cloud foundry

00:04:35,510 --> 00:04:42,590
which is an API that we call the cloud

00:04:38,880 --> 00:04:45,240
controller this is a Sinatra application

00:04:42,590 --> 00:04:48,060
that's also written with event machine

00:04:45,240 --> 00:04:49,259
the sits on the message bus as well so

00:04:48,060 --> 00:04:51,509
it can talk to the rest of the

00:04:49,259 --> 00:04:53,639
distributed system but it also talks to

00:04:51,509 --> 00:04:55,349
the outside world the cloud controllers

00:04:53,639 --> 00:04:57,900
main responsibility in the whole system

00:04:55,349 --> 00:04:59,520
is maintaining the desired state for

00:04:57,900 --> 00:05:02,430
what the system should look like at any

00:04:59,520 --> 00:05:03,630
given time so if you register with the

00:05:02,430 --> 00:05:05,759
cloud controller it should know that

00:05:03,630 --> 00:05:07,410
your user exists if you create an

00:05:05,759 --> 00:05:09,300
application it knows how many the

00:05:07,410 --> 00:05:11,370
applications there it knows how many

00:05:09,300 --> 00:05:13,229
instances you want of an application it

00:05:11,370 --> 00:05:15,599
knows how many URLs you want map to that

00:05:13,229 --> 00:05:17,340
application and what they should be the

00:05:15,599 --> 00:05:18,659
cloud controller and then once it sort

00:05:17,340 --> 00:05:20,539
of knows the state of what you want it

00:05:18,659 --> 00:05:23,669
to be the cognate roller takes actions

00:05:20,539 --> 00:05:26,210
to try and keep the state of the system

00:05:23,669 --> 00:05:28,650
in sync with what you've told it to do

00:05:26,210 --> 00:05:32,669
the cognate role used to be written in

00:05:28,650 --> 00:05:34,500
rails a whiff event machine as well it

00:05:32,669 --> 00:05:36,990
was recently rewritten in Sinatra with

00:05:34,500 --> 00:05:39,389
the sequel gem it's a little cleaner I

00:05:36,990 --> 00:05:41,220
think that there wasn't really a good

00:05:39,389 --> 00:05:42,990
reason to use Sinatra or rails other

00:05:41,220 --> 00:05:45,479
than it's just an API so people thought

00:05:42,990 --> 00:05:47,130
they didn't need rails I wasn't involved

00:05:45,479 --> 00:05:49,259
in that decision I tend to like rails

00:05:47,130 --> 00:05:50,490
for api's but it sort of proves that you

00:05:49,259 --> 00:05:51,990
doesn't really matter which one you're

00:05:50,490 --> 00:05:57,599
looking at most of the code ends up

00:05:51,990 --> 00:06:01,229
looking the same so what we end up with

00:05:57,599 --> 00:06:02,880
a system now that has users out or users

00:06:01,229 --> 00:06:04,440
out in the world with their CF gem

00:06:02,880 --> 00:06:05,849
installed and they can talk to this

00:06:04,440 --> 00:06:09,780
cloud controller that's running in the

00:06:05,849 --> 00:06:11,909
cloud so what they do is they send a

00:06:09,780 --> 00:06:14,460
message up to the cloud controller this

00:06:11,909 --> 00:06:16,110
is an HTTP rest call that says I've got

00:06:14,460 --> 00:06:18,780
my hello world app we're going to

00:06:16,110 --> 00:06:21,539
pretend it's a Sinatra app as well could

00:06:18,780 --> 00:06:23,460
you here's the code for it and here's

00:06:21,539 --> 00:06:25,620
the URL I'd like running for that I'd

00:06:23,460 --> 00:06:27,569
like to be able to access this app so if

00:06:25,620 --> 00:06:29,280
i go to hello world com the earth cloud

00:06:27,569 --> 00:06:34,289
foundry com I should be able to see my

00:06:29,280 --> 00:06:38,520
app so cloud the CF gem uploads the code

00:06:34,289 --> 00:06:40,380
to the cloud controller which is great

00:06:38,520 --> 00:06:43,729
because now the controller has this code

00:06:40,380 --> 00:06:46,800
and we're ready to go except we're not

00:06:43,729 --> 00:06:48,409
because what we have is code and what we

00:06:46,800 --> 00:06:51,569
want in our terminology is a droplet

00:06:48,409 --> 00:06:53,400
because as many people know when you

00:06:51,569 --> 00:06:55,469
have code you can't just download it and

00:06:53,400 --> 00:06:57,920
run it unless you're only using the Ruby

00:06:55,469 --> 00:07:00,810
standard library

00:06:57,920 --> 00:07:04,740
most of you are using gems as we

00:07:00,810 --> 00:07:07,470
established earlier and most of you want

00:07:04,740 --> 00:07:09,030
to use a specific version of Ruby not

00:07:07,470 --> 00:07:11,940
just whatever when we happen to have

00:07:09,030 --> 00:07:14,190
installed in the system so what we

00:07:11,940 --> 00:07:17,660
really want to do is take any code that

00:07:14,190 --> 00:07:20,550
has been uploaded into the system and

00:07:17,660 --> 00:07:23,100
transform it into something that we can

00:07:20,550 --> 00:07:25,590
run so what we have is what we call a

00:07:23,100 --> 00:07:29,670
staging process where we take the code

00:07:25,590 --> 00:07:31,560
and we run what we actually do now is

00:07:29,670 --> 00:07:33,540
that we run the same code that Heroku

00:07:31,560 --> 00:07:36,420
uses when they're building your apps we

00:07:33,540 --> 00:07:39,180
out for quite a while had separate

00:07:36,420 --> 00:07:42,090
implementations of what Heric was built

00:07:39,180 --> 00:07:44,280
packs we had staging libraries and we

00:07:42,090 --> 00:07:46,290
took a step back a few months ago and

00:07:44,280 --> 00:07:48,090
said it doesn't make sense to maintain

00:07:46,290 --> 00:07:50,760
two things as open source projects to do

00:07:48,090 --> 00:07:54,480
the exact same thing and we said what's

00:07:50,760 --> 00:07:56,310
used to Roku's as a side note we said we

00:07:54,480 --> 00:07:58,110
don't like how they do Java we're going

00:07:56,310 --> 00:08:00,210
to do Java differently but we're going

00:07:58,110 --> 00:08:01,500
to for rails what Heroku is done for

00:08:00,210 --> 00:08:03,030
rails makes plenty of sense that's

00:08:01,500 --> 00:08:05,580
exactly what people expect when they're

00:08:03,030 --> 00:08:07,770
deploying a rails app so what we want to

00:08:05,580 --> 00:08:09,240
do is take our code run the build pack

00:08:07,770 --> 00:08:13,080
which is really a transformation

00:08:09,240 --> 00:08:14,970
function and end up with a droplet the

00:08:13,080 --> 00:08:16,890
goal of a droplet is that no matter what

00:08:14,970 --> 00:08:21,660
you uploaded no matter if the Java app a

00:08:16,890 --> 00:08:23,430
play app ask Allah app go app it doesn't

00:08:21,660 --> 00:08:25,290
matter what you end up with at the end

00:08:23,430 --> 00:08:27,180
is something that you can untie ur and

00:08:25,290 --> 00:08:30,590
call start on and give it a port and

00:08:27,180 --> 00:08:33,419
it'll run it'll run on the system and

00:08:30,590 --> 00:08:35,220
start up that app once you have this

00:08:33,419 --> 00:08:37,590
sort of abstraction of I have this thing

00:08:35,220 --> 00:08:39,720
that I can ontar and call start on you

00:08:37,590 --> 00:08:42,240
basically have something that looks very

00:08:39,720 --> 00:08:44,010
much like an executable it doesn't

00:08:42,240 --> 00:08:45,450
you've compiled it down into something

00:08:44,010 --> 00:08:49,440
that's binary compatible with your

00:08:45,450 --> 00:08:52,740
system and you can run it anywhere so

00:08:49,440 --> 00:08:55,020
the challenge for doing this staging

00:08:52,740 --> 00:08:57,510
this staging process is that we need

00:08:55,020 --> 00:09:00,000
somewhere to run it we need to be able

00:08:57,510 --> 00:09:01,350
to run the code somewhere and we need to

00:09:00,000 --> 00:09:02,730
be able to run the users code which

00:09:01,350 --> 00:09:05,670
means the users code could be doing

00:09:02,730 --> 00:09:08,470
anything it wants to do this is frankly

00:09:05,670 --> 00:09:12,370
incredibly scary to take users code

00:09:08,470 --> 00:09:16,540
and run it in your system so what we

00:09:12,370 --> 00:09:18,700
have ended up at is a a component that

00:09:16,540 --> 00:09:27,810
we call the DEA or droplet execution

00:09:18,700 --> 00:09:31,240
agent thank you I which is where any any

00:09:27,810 --> 00:09:35,170
users provided code is going to run the

00:09:31,240 --> 00:09:36,430
DEA is another Ruby demon written with

00:09:35,170 --> 00:09:39,760
event machine that listens on the

00:09:36,430 --> 00:09:41,410
message bus it has no other UI but so

00:09:39,760 --> 00:09:44,920
what you end up doing is you run this on

00:09:41,410 --> 00:09:48,070
a on a server and you also run on the

00:09:44,920 --> 00:09:50,020
same server warden warden is a demon

00:09:48,070 --> 00:09:52,660
that we wrote that is very similar to

00:09:50,020 --> 00:09:54,760
lxc or if you've been reading the news

00:09:52,660 --> 00:09:56,320
lately docker it uses the same

00:09:54,760 --> 00:09:59,740
technologies how many of you are

00:09:56,320 --> 00:10:02,200
familiar with cgroups some but not all

00:09:59,740 --> 00:10:03,910
okay see groups are awesome they were

00:10:02,200 --> 00:10:07,210
originally contributed to the Linux

00:10:03,910 --> 00:10:09,100
kernel by Google and Google just sort of

00:10:07,210 --> 00:10:11,110
sent the patch over to the colonel and

00:10:09,100 --> 00:10:13,840
said here use this and nobody really

00:10:11,110 --> 00:10:16,120
knew what to do with it exactly shortly

00:10:13,840 --> 00:10:19,750
thereafter the LXE project sprang up to

00:10:16,120 --> 00:10:21,280
actually make cgroups usable what you

00:10:19,750 --> 00:10:24,850
end up with when you have a see group is

00:10:21,280 --> 00:10:28,600
being able to launch processes on a box

00:10:24,850 --> 00:10:30,250
and lock them down into a jail where

00:10:28,600 --> 00:10:32,800
they can't see anything else on the box

00:10:30,250 --> 00:10:35,020
they're in at rooted filesystem their

00:10:32,800 --> 00:10:36,940
process table only has their processes

00:10:35,020 --> 00:10:39,070
in it and they even have their own

00:10:36,940 --> 00:10:40,810
network card attached to the system and

00:10:39,070 --> 00:10:43,840
they use virtual networking to actually

00:10:40,810 --> 00:10:45,700
attach to the host system so it sounds

00:10:43,840 --> 00:10:47,740
very much like virtualization except

00:10:45,700 --> 00:10:49,240
that you at you don't have your own

00:10:47,740 --> 00:10:51,190
kernel running you're actually sharing

00:10:49,240 --> 00:10:53,830
the kernel with the system that's

00:10:51,190 --> 00:10:55,780
running this means they're extremely

00:10:53,830 --> 00:10:59,860
lightweight we can spin up one of these

00:10:55,780 --> 00:11:03,040
in about two seconds and uh and it'll be

00:10:59,860 --> 00:11:05,080
ready to go ready to run a ready-to-run

00:11:03,040 --> 00:11:06,640
users application code in a fairly

00:11:05,080 --> 00:11:08,260
secure manner unless there's a kernel

00:11:06,640 --> 00:11:10,380
vulnerability you're not going to be

00:11:08,260 --> 00:11:13,000
able to get out of the warden container

00:11:10,380 --> 00:11:18,220
so what we have is we have application

00:11:13,000 --> 00:11:19,870
code we get this message that slide

00:11:18,220 --> 00:11:22,060
doesn't believe it we the cloud

00:11:19,870 --> 00:11:24,880
controller sends a message to the DA

00:11:22,060 --> 00:11:27,000
which says here's some application code

00:11:24,880 --> 00:11:30,460
could you go and stage it for me and

00:11:27,000 --> 00:11:33,130
call it hello world the DEA will spin up

00:11:30,460 --> 00:11:34,480
a warden container so the Cloud

00:11:33,130 --> 00:11:36,670
Controller talks to a different box over

00:11:34,480 --> 00:11:38,410
the message bus that box will then go

00:11:36,670 --> 00:11:42,580
download the code put it in a word in

00:11:38,410 --> 00:11:44,050
container and it will start running the

00:11:42,580 --> 00:11:47,830
build pack associated with that

00:11:44,050 --> 00:11:52,140
application and transforming it into a

00:11:47,830 --> 00:11:54,670
stage droplet so once this is done the

00:11:52,140 --> 00:11:57,820
DEA will then respond back to the cloud

00:11:54,670 --> 00:11:59,380
controller with i took that code you

00:11:57,820 --> 00:12:00,790
gave me i made it into something that

00:11:59,380 --> 00:12:05,380
you can actually run in the system

00:12:00,790 --> 00:12:08,050
here's the URL for it so this comes back

00:12:05,380 --> 00:12:10,270
into the cloud controller separate bot

00:12:08,050 --> 00:12:14,650
and it says okay great i need to do

00:12:10,270 --> 00:12:16,180
something with that so it says okay i

00:12:14,650 --> 00:12:19,360
need to actually find somewhere on the

00:12:16,180 --> 00:12:23,310
system to run this and tell that da to

00:12:19,360 --> 00:12:25,690
actually run the application this is

00:12:23,310 --> 00:12:27,220
sort of an interesting problem because

00:12:25,690 --> 00:12:28,930
you have to find somewhere in your large

00:12:27,220 --> 00:12:31,420
system where you can actually run this

00:12:28,930 --> 00:12:33,490
application we've actually gone through

00:12:31,420 --> 00:12:36,310
a couple different algorithms for

00:12:33,490 --> 00:12:40,300
selecting where in the system to place

00:12:36,310 --> 00:12:42,160
the app the first algorithm used a time

00:12:40,300 --> 00:12:45,040
delay to indicate how busy the system

00:12:42,160 --> 00:12:46,840
what the individual DEA was so we would

00:12:45,040 --> 00:12:49,900
send out a broadcast request to the

00:12:46,840 --> 00:12:52,060
entire cluster who can run this app for

00:12:49,900 --> 00:12:55,480
me it's you know five needs 512 Meg's of

00:12:52,060 --> 00:12:57,730
memory and each DEA would calculate a

00:12:55,480 --> 00:12:59,170
number based on how busy it was and

00:12:57,730 --> 00:13:02,170
sleep that amount of time before

00:12:59,170 --> 00:13:04,000
responding back this was a very nice her

00:13:02,170 --> 00:13:05,740
istic but as soon as you have any sort

00:13:04,000 --> 00:13:07,330
of network delay it becomes a challenge

00:13:05,740 --> 00:13:09,640
because the ones that are further away

00:13:07,330 --> 00:13:11,080
from the cloud controller never have to

00:13:09,640 --> 00:13:13,450
do any work the ones that are right next

00:13:11,080 --> 00:13:16,930
door to it have to do all the work until

00:13:13,450 --> 00:13:19,450
they get loaded up so we recently rolled

00:13:16,930 --> 00:13:22,960
out a change to this selection algorithm

00:13:19,450 --> 00:13:25,720
where the DEA is actually broadcast into

00:13:22,960 --> 00:13:28,690
the system regularly with how loaded

00:13:25,720 --> 00:13:30,730
they are so how much memory they have

00:13:28,690 --> 00:13:33,280
how much memory is in use and similarly

00:13:30,730 --> 00:13:35,590
with the cpu and then the cloud

00:13:33,280 --> 00:13:37,720
controllers all keep an in-memory

00:13:35,590 --> 00:13:40,420
table of all the DA's they've heard back

00:13:37,720 --> 00:13:42,280
from they've heard from recently and how

00:13:40,420 --> 00:13:44,470
loaded they are so when the cog

00:13:42,280 --> 00:13:46,120
controller goes to start up a nap it can

00:13:44,470 --> 00:13:48,520
actually look at its table and say I've

00:13:46,120 --> 00:13:50,950
heard from 50 DDA's in the last minute

00:13:48,520 --> 00:13:52,690
this one has the least load in it let me

00:13:50,950 --> 00:13:55,380
send it a directed message over the

00:13:52,690 --> 00:13:59,590
message bus just start this this app up

00:13:55,380 --> 00:14:02,560
and start it when it goes to do this it

00:13:59,590 --> 00:14:05,740
also passes the environment hash of what

00:14:02,560 --> 00:14:08,440
we want to start up with this app so if

00:14:05,740 --> 00:14:09,820
you want to you often want to set rails

00:14:08,440 --> 00:14:12,240
ends and you want to pass in what

00:14:09,820 --> 00:14:13,960
database it is this is another sort of

00:14:12,240 --> 00:14:15,220
situation where it's starting to look

00:14:13,960 --> 00:14:16,810
very much like an operating system

00:14:15,220 --> 00:14:19,480
because now we're passing it an

00:14:16,810 --> 00:14:21,340
executable and an environment which is

00:14:19,480 --> 00:14:23,050
exactly what defines a process when you

00:14:21,340 --> 00:14:25,330
want to launch a process on your local

00:14:23,050 --> 00:14:27,790
box so it's very much the same thing but

00:14:25,330 --> 00:14:29,620
we're doing it across any number of

00:14:27,790 --> 00:14:31,780
nodes we don't care where in the system

00:14:29,620 --> 00:14:33,700
it runs we just know that we need n copy

00:14:31,780 --> 00:14:36,850
of this of this thing this process

00:14:33,700 --> 00:14:40,030
running with this environment so we send

00:14:36,850 --> 00:14:41,980
this startup command to the DEA and this

00:14:40,030 --> 00:14:43,870
is really about what our system looks

00:14:41,980 --> 00:14:45,250
like at this point we've got our users

00:14:43,870 --> 00:14:47,080
they're using the gem they're talking to

00:14:45,250 --> 00:14:50,140
Cloud Controller the Cloud Controller

00:14:47,080 --> 00:14:52,000
talks to the DA's and they spin up apps

00:14:50,140 --> 00:14:54,070
and this is great because now we've got

00:14:52,000 --> 00:14:56,050
apps running what you can do at this

00:14:54,070 --> 00:14:58,570
point is you can mine bitcoins pretty

00:14:56,050 --> 00:15:00,370
effectively unfortunately what you can't

00:14:58,570 --> 00:15:03,280
do is actually have any users hit your

00:15:00,370 --> 00:15:05,070
app because our app is sort of running

00:15:03,280 --> 00:15:07,600
in the forest with no way to get to it

00:15:05,070 --> 00:15:09,610
so what we have to do is introduce

00:15:07,600 --> 00:15:13,890
another component actually route traffic

00:15:09,610 --> 00:15:17,320
to this application and we call this

00:15:13,890 --> 00:15:19,000
conveniently the router the current one

00:15:17,320 --> 00:15:22,420
is called go router for reasons I'll get

00:15:19,000 --> 00:15:24,130
into you probably guess but we haven't

00:15:22,420 --> 00:15:25,810
come up with a better name we don't

00:15:24,130 --> 00:15:27,430
really think it's a mess yet so we're

00:15:25,810 --> 00:15:31,690
not calling it a mesh and besides that's

00:15:27,430 --> 00:15:34,180
taken our router is random if you ever

00:15:31,690 --> 00:15:36,430
before you ask about it random works

00:15:34,180 --> 00:15:40,210
just fine but I don't want to get into

00:15:36,430 --> 00:15:43,630
it any more than that the routing layer

00:15:40,210 --> 00:15:44,830
is actually a really interesting part of

00:15:43,630 --> 00:15:46,300
the system because it's part of the

00:15:44,830 --> 00:15:46,819
system that's evolved quite a lot since

00:15:46,300 --> 00:15:50,539
the sister

00:15:46,819 --> 00:15:52,129
launched when we first when Cod foundry

00:15:50,539 --> 00:15:53,839
first launched the routing layer was

00:15:52,129 --> 00:15:57,289
simply a Sinatra app that would take

00:15:53,839 --> 00:16:00,229
incoming connections it would know where

00:15:57,289 --> 00:16:02,389
in the system the app the various apps

00:16:00,229 --> 00:16:04,579
were and it would proxy the connections

00:16:02,389 --> 00:16:08,869
through as you can imagine Ruby isn't

00:16:04,579 --> 00:16:11,119
the best language for being in the

00:16:08,869 --> 00:16:14,839
request for every app coming into the

00:16:11,119 --> 00:16:19,579
system so what we the next generation of

00:16:14,839 --> 00:16:21,919
the router used engine X with loot with

00:16:19,579 --> 00:16:24,949
lua scripts embedded in the engine X

00:16:21,919 --> 00:16:26,720
config to actually do a request outside

00:16:24,949 --> 00:16:30,169
to astronaut wrap that was running on

00:16:26,720 --> 00:16:31,999
that exact on that box locally that had

00:16:30,169 --> 00:16:34,369
a routing table of all the apps and all

00:16:31,999 --> 00:16:36,949
the ports in the system and where they

00:16:34,369 --> 00:16:39,139
were so every request coming into the

00:16:36,949 --> 00:16:40,819
system would hit engine X it would go

00:16:39,139 --> 00:16:42,949
through Lua it would go out to Sinatra

00:16:40,819 --> 00:16:44,509
it would come back into Lua which would

00:16:42,949 --> 00:16:46,789
tell engine X where to forward that

00:16:44,509 --> 00:16:48,410
request on to this was actually much

00:16:46,789 --> 00:16:50,779
better than having Ruby doing the actual

00:16:48,410 --> 00:16:52,850
proxying but it still left us with

00:16:50,779 --> 00:16:55,779
memory usages issues with engine X

00:16:52,850 --> 00:16:58,039
memory usage of issues with Sinatra and

00:16:55,779 --> 00:17:01,069
not really the greatest experience

00:16:58,039 --> 00:17:02,629
overall and from the product side we

00:17:01,069 --> 00:17:04,639
also wanted to start supporting web

00:17:02,629 --> 00:17:07,339
sockets which wasn't something we could

00:17:04,639 --> 00:17:09,319
do with engine X at that point I think

00:17:07,339 --> 00:17:11,750
as of a week or two ago you now may be

00:17:09,319 --> 00:17:13,970
able to support web sockets but this was

00:17:11,750 --> 00:17:17,240
a little bit further back than that so

00:17:13,970 --> 00:17:18,889
the third iteration of the router we

00:17:17,240 --> 00:17:23,329
actually took a step back and we ended

00:17:18,889 --> 00:17:25,309
up rewriting it in go so the router

00:17:23,329 --> 00:17:27,649
that's running now is written entirely

00:17:25,309 --> 00:17:29,600
and go and it's a pretty simple piece of

00:17:27,649 --> 00:17:31,639
code that listens on a message bus and

00:17:29,600 --> 00:17:33,470
just proxies requests through we've been

00:17:31,639 --> 00:17:36,200
really happy with the stability of it

00:17:33,470 --> 00:17:37,879
and I think we're sort of looking at go

00:17:36,200 --> 00:17:40,309
is being sort of this alternative

00:17:37,879 --> 00:17:42,320
language when we need it but it's not

00:17:40,309 --> 00:17:44,000
there aren't very many components in the

00:17:42,320 --> 00:17:45,820
system like this that actually need that

00:17:44,000 --> 00:17:50,149
high performance high scalability

00:17:45,820 --> 00:17:52,159
because most of this is most of this is

00:17:50,149 --> 00:17:53,870
really just a thin layer around a whole

00:17:52,159 --> 00:17:56,120
lot of computation that's going on in

00:17:53,870 --> 00:17:58,279
user apps this the amount of resources

00:17:56,120 --> 00:17:59,800
we use for running Cloud Foundry should

00:17:58,279 --> 00:18:01,600
be minimal compared to the amount of

00:17:59,800 --> 00:18:06,220
resources for all of these applications

00:18:01,600 --> 00:18:07,990
that were running in the system so once

00:18:06,220 --> 00:18:10,570
we have this router we can have a

00:18:07,990 --> 00:18:12,430
message from our DEA our DEA is now

00:18:10,570 --> 00:18:16,060
downloaded the application code that

00:18:12,430 --> 00:18:17,650
we've staged and what the DEA does is

00:18:16,060 --> 00:18:22,450
then call start on that it says listen

00:18:17,650 --> 00:18:25,060
on port 3002 and it actually waits for

00:18:22,450 --> 00:18:26,560
that containers port on 3002 to actually

00:18:25,060 --> 00:18:27,850
be listening for connections because we

00:18:26,560 --> 00:18:31,480
don't want to start forwarding traffic

00:18:27,850 --> 00:18:33,310
into a nap before connections before

00:18:31,480 --> 00:18:35,080
it's actually listening so we wait for

00:18:33,310 --> 00:18:38,410
that thing to start listening on a port

00:18:35,080 --> 00:18:40,120
and then we send out a message on the

00:18:38,410 --> 00:18:43,060
bus to all of the routers in the system

00:18:40,120 --> 00:18:46,120
I'm over here here's my IP address and

00:18:43,060 --> 00:18:48,280
here's the port it's running on we also

00:18:46,120 --> 00:18:51,190
have to set up a net forwarding rule

00:18:48,280 --> 00:18:52,660
into the container from the DEA because

00:18:51,190 --> 00:18:54,280
the DEA is what has the public IP

00:18:52,660 --> 00:18:57,310
address the containers don't have public

00:18:54,280 --> 00:18:58,360
IPS so much like your home router we

00:18:57,310 --> 00:19:00,610
have this whole little separate

00:18:58,360 --> 00:19:02,410
networking system inside each DEA and we

00:19:00,610 --> 00:19:04,960
need to set up port forwarding along

00:19:02,410 --> 00:19:06,940
that so what this once this happens the

00:19:04,960 --> 00:19:09,040
router gets this request and now when

00:19:06,940 --> 00:19:12,940
you hit hello world cloud foundry com

00:19:09,040 --> 00:19:15,390
the request will come in and get routed

00:19:12,940 --> 00:19:18,340
i will get routed to your application

00:19:15,390 --> 00:19:19,570
correctly the request the response will

00:19:18,340 --> 00:19:21,580
go back through the router and out to

00:19:19,570 --> 00:19:24,250
the clients so we finally have an app

00:19:21,580 --> 00:19:27,970
running and accessible in the cloud this

00:19:24,250 --> 00:19:29,170
is great this is great and this is about

00:19:27,970 --> 00:19:33,280
what it looks like you can see the

00:19:29,170 --> 00:19:34,960
things fully filled in here the sort of

00:19:33,280 --> 00:19:36,790
interesting part that I left out earlier

00:19:34,960 --> 00:19:38,710
is that the cloud controller actually

00:19:36,790 --> 00:19:40,900
functions just like any other app in the

00:19:38,710 --> 00:19:43,510
system it doesn't run inside of the DEA

00:19:40,900 --> 00:19:46,600
but it registers with the routers just

00:19:43,510 --> 00:19:48,190
like any other app and so all HTTP

00:19:46,600 --> 00:19:50,140
traffic to the system comes in through

00:19:48,190 --> 00:19:53,380
the routing layer and gets forwarded off

00:19:50,140 --> 00:19:55,000
to either running either applications

00:19:53,380 --> 00:19:56,530
that the systems running or it gets

00:19:55,000 --> 00:19:58,000
forwarded to the cloud controller to

00:19:56,530 --> 00:20:02,680
actually deal with requests that the end

00:19:58,000 --> 00:20:04,210
user is making and so that's about the

00:20:02,680 --> 00:20:06,160
steady state of the system as long as

00:20:04,210 --> 00:20:07,810
everything goes according to plan we're

00:20:06,160 --> 00:20:09,370
in great shape we're going to be running

00:20:07,810 --> 00:20:11,650
forever we'll have the one copy of your

00:20:09,370 --> 00:20:13,149
app it'll be great it'll be great until

00:20:11,650 --> 00:20:15,639
you have an AWS

00:20:13,149 --> 00:20:18,279
you and trust me you will have an AWS

00:20:15,639 --> 00:20:20,529
issue at some point in the future or in

00:20:18,279 --> 00:20:24,070
your on-premise cloud you will have an

00:20:20,529 --> 00:20:26,649
issue but at some point things go wrong

00:20:24,070 --> 00:20:28,690
and the system gets out of sync this may

00:20:26,649 --> 00:20:31,239
be you know one of the simplest case

00:20:28,690 --> 00:20:33,460
here is that one of your DEA DEA knows

00:20:31,239 --> 00:20:35,529
just disappears and in a large system

00:20:33,460 --> 00:20:37,029
one of your nodes are just your nodes

00:20:35,529 --> 00:20:38,549
are disappearing all the time and need

00:20:37,029 --> 00:20:42,070
something you should be counting on and

00:20:38,549 --> 00:20:45,009
so what we have is a component that we

00:20:42,070 --> 00:20:46,899
call the health manager and the health

00:20:45,009 --> 00:20:48,999
manager is an interesting component in

00:20:46,899 --> 00:20:51,129
the system because in a perfect world it

00:20:48,999 --> 00:20:53,679
does nothing but in the real world that

00:20:51,129 --> 00:20:55,599
does quite a bit and what it does is it

00:20:53,679 --> 00:20:57,039
listens on the message bus for

00:20:55,599 --> 00:21:00,129
everything that's happening in the

00:20:57,039 --> 00:21:01,869
system and tries to build up a picture

00:21:00,129 --> 00:21:04,389
of what it actually sees in the world

00:21:01,869 --> 00:21:05,769
and what's actually happening and then

00:21:04,389 --> 00:21:07,479
it goes and ask the cloud controller

00:21:05,769 --> 00:21:10,599
what have you actually mean to have

00:21:07,479 --> 00:21:13,029
happen here and so and it has these two

00:21:10,599 --> 00:21:15,249
tables and it basically just reconciles

00:21:13,029 --> 00:21:16,629
the two tables and says well you're

00:21:15,249 --> 00:21:19,149
supposed to have three copies but you

00:21:16,629 --> 00:21:20,349
only have to start up in it then it

00:21:19,149 --> 00:21:22,749
sends a message to the cloud controller

00:21:20,349 --> 00:21:25,749
to start one more there are all sorts of

00:21:22,749 --> 00:21:27,460
edge cases here that you tend to not

00:21:25,749 --> 00:21:30,249
realize at first that you have to deal

00:21:27,460 --> 00:21:33,999
with if the user pushes a new version of

00:21:30,249 --> 00:21:35,830
the app you may only upgrade three out

00:21:33,999 --> 00:21:37,960
of four copies of the app and the fourth

00:21:35,830 --> 00:21:40,200
copy may just never actually get

00:21:37,960 --> 00:21:44,080
upgraded and so you need to actually

00:21:40,200 --> 00:21:48,099
look at what version of each application

00:21:44,080 --> 00:21:51,549
you're running and go through and kill

00:21:48,099 --> 00:21:54,159
old ones and scale up scale down and

00:21:51,549 --> 00:21:57,249
deal with the imperfect world that we

00:21:54,159 --> 00:21:59,409
live in the health manager is really

00:21:57,249 --> 00:22:01,599
interesting because if you're interested

00:21:59,409 --> 00:22:03,690
learning more you can go read the readme

00:22:01,599 --> 00:22:05,739
we recently spent a lot of time actually

00:22:03,690 --> 00:22:06,999
documenting how the whole thing works

00:22:05,739 --> 00:22:08,649
this is sort of going to be the model

00:22:06,999 --> 00:22:10,659
for how we document all of the

00:22:08,649 --> 00:22:12,249
components going forward we haven't been

00:22:10,659 --> 00:22:14,669
great about it before it sort of been

00:22:12,249 --> 00:22:19,570
this black box of repos on github and

00:22:14,669 --> 00:22:21,039
one of the our product team was actually

00:22:19,570 --> 00:22:22,239
complaining that it was impossible to

00:22:21,039 --> 00:22:23,859
figure out how these things went

00:22:22,239 --> 00:22:25,510
together and you're like whoa just put a

00:22:23,859 --> 00:22:27,190
story into tracker and some

00:22:25,510 --> 00:22:29,320
can spend half a day documenting it and

00:22:27,190 --> 00:22:31,300
so we actually did we had two people go

00:22:29,320 --> 00:22:33,790
through and really detail how it works

00:22:31,300 --> 00:22:38,950
so it's a fun read if you're looking for

00:22:33,790 --> 00:22:40,690
something like that so the one topic I

00:22:38,950 --> 00:22:42,220
haven't covered here terribly and I'm

00:22:40,690 --> 00:22:45,040
not going to go into in detail is

00:22:42,220 --> 00:22:46,660
services what we've gotten to now is

00:22:45,040 --> 00:22:49,720
something that can run application code

00:22:46,660 --> 00:22:51,820
but has no persistence layer it's not

00:22:49,720 --> 00:22:53,350
terribly interesting from an application

00:22:51,820 --> 00:22:55,570
developer perspective if you don't have

00:22:53,350 --> 00:22:57,790
a persistence layer with Cloud Foundry

00:22:55,570 --> 00:23:02,890
we actually have five services that we

00:22:57,790 --> 00:23:07,650
deploy we run a I could name a postgres

00:23:02,890 --> 00:23:10,930
my sequel rabbitmq and Redis as

00:23:07,650 --> 00:23:12,970
services these are all very small sort

00:23:10,930 --> 00:23:15,790
of not production grade services at this

00:23:12,970 --> 00:23:18,490
point we what we find when people really

00:23:15,790 --> 00:23:20,500
go to use cloud foundry at a larger

00:23:18,490 --> 00:23:22,630
scale is they end up calling out to a

00:23:20,500 --> 00:23:24,340
larger day a different database cluster

00:23:22,630 --> 00:23:26,320
that they're managing by hand a lot of

00:23:24,340 --> 00:23:28,360
people want to deploy databases on real

00:23:26,320 --> 00:23:30,430
hardware or they want to have people

00:23:28,360 --> 00:23:32,620
looking of really managing them and

00:23:30,430 --> 00:23:34,360
that's a hard problem and so we're

00:23:32,620 --> 00:23:37,720
looking at that and sort of looking to

00:23:34,360 --> 00:23:40,930
see where we should invest time to make

00:23:37,720 --> 00:23:42,820
a system that can automatically manage a

00:23:40,930 --> 00:23:44,920
database much like we're automatically

00:23:42,820 --> 00:23:47,710
managing apps but right now we just sort

00:23:44,920 --> 00:23:49,150
of have this naive view that well since

00:23:47,710 --> 00:23:51,580
it's a VMware project and we're using

00:23:49,150 --> 00:23:53,080
vSphere high availability any app any

00:23:51,580 --> 00:23:55,210
instance that crashes is just going to

00:23:53,080 --> 00:23:56,680
come back somewhere in the system in the

00:23:55,210 --> 00:23:59,320
real world we don't want to count on

00:23:56,680 --> 00:24:02,560
that and we want the system to be able

00:23:59,320 --> 00:24:04,540
to detect when a Postgres database goes

00:24:02,560 --> 00:24:06,670
away and actually transfer load to a

00:24:04,540 --> 00:24:11,680
different Postgres database seamlessly

00:24:06,670 --> 00:24:14,440
we're not there yet so it's but we're

00:24:11,680 --> 00:24:15,970
not there yet for reliability but we do

00:24:14,440 --> 00:24:18,790
have code that allows developers to

00:24:15,970 --> 00:24:20,680
actually have a workflow of I need a

00:24:18,790 --> 00:24:22,810
postgres instance let me provision one

00:24:20,680 --> 00:24:24,370
and when I'm ready to go to production i

00:24:22,810 --> 00:24:30,190
can actually provision one outside of

00:24:24,370 --> 00:24:33,100
cloud foundry so for me this is a really

00:24:30,190 --> 00:24:34,600
exciting problem to work in I really

00:24:33,100 --> 00:24:36,790
enjoy being a developer but I enjoy

00:24:34,600 --> 00:24:38,640
operations a lot and I think it really

00:24:36,790 --> 00:24:40,560
is where the to tend to me

00:24:38,640 --> 00:24:42,180
and it's a really interesting use of

00:24:40,560 --> 00:24:43,650
Ruby because they're all these different

00:24:42,180 --> 00:24:46,290
components that are talking to each

00:24:43,650 --> 00:24:50,040
other and it looks nothing like any

00:24:46,290 --> 00:24:52,320
other Ruby code I've seen and so it's

00:24:50,040 --> 00:24:54,510
really it's a fun thing to dig into it's

00:24:52,320 --> 00:24:56,070
a little challenging to get started but

00:24:54,510 --> 00:24:59,220
I encourage everybody to check it out

00:24:56,070 --> 00:25:02,160
and if and get involved look at it

00:24:59,220 --> 00:25:04,590
there's a mailing list you can find if

00:25:02,160 --> 00:25:06,600
you have any questions or you can even

00:25:04,590 --> 00:25:08,550
better you can find me tomorrow at the

00:25:06,600 --> 00:25:11,700
pivotal labs drink up which is after the

00:25:08,550 --> 00:25:14,180
conference and you can find my slides

00:25:11,700 --> 00:25:17,570
online and you can find me on Twitter so

00:25:14,180 --> 00:25:17,570
thank you very much

00:25:28,610 --> 00:25:31,610
member

00:25:41,789 --> 00:25:43,850

YouTube URL: https://www.youtube.com/watch?v=G1VAjiesXio


