Title: MountainWest RubyConf 2013 DIY::Thread.profile -- Light-Weight Profiling in Pure Ruby
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Title: DIY::Thread.profile -- Light-Weight Profiling in Pure Ruby
Presented by: Jason Clark

Whether your application is concurrent or not, there's insight to be gained from Ruby's threading support.
This talk demonstrates building a light-weight sampling profiler in pure Ruby. The techniques are simple enough to integrate into almost any application, and fast enough for even a production environment. If you've ever wondered exactly what your application is doing at any given moment, this will show you how to find out.
Along the way we'll expose gotchas and pitfalls of thread introspection on the many versions and implementations of Ruby. Based on experience implementing thread profiling for New Relic, we'll also touch on how to debug and work around problems when they come up

Help us caption & translate this video!

http://amara.org/v/FGbu/
Captions: 
	00:00:19,810 --> 00:00:25,880
alright so my name is Jason Clark I work

00:00:23,480 --> 00:00:27,500
for New Relic on the Ruby agent team if

00:00:25,880 --> 00:00:30,050
any of you have ever used the New Relic

00:00:27,500 --> 00:00:33,520
underscore rpm gym that's the piece of

00:00:30,050 --> 00:00:36,050
code that i work on to to maintain so

00:00:33,520 --> 00:00:38,360
let's talk a little bit about threads

00:00:36,050 --> 00:00:41,059
and talk about what we're going to do

00:00:38,360 --> 00:00:43,340
with them today so this is not a talk

00:00:41,059 --> 00:00:45,230
that's purely about concurrency this

00:00:43,340 --> 00:00:47,420
isn't a talk about jruby and Rubinius

00:00:45,230 --> 00:00:49,910
and why we care about concurrency and

00:00:47,420 --> 00:00:51,500
why the Gil makes life hard it's not a

00:00:49,910 --> 00:00:54,079
talk about you know how you write

00:00:51,500 --> 00:00:55,550
concurrent program what it is about is

00:00:54,079 --> 00:00:57,559
it's going to be about how we can use

00:00:55,550 --> 00:01:00,590
the thread api's that are present in the

00:00:57,559 --> 00:01:02,360
Ruby standard library to get some extra

00:01:00,590 --> 00:01:04,250
insight into what our applications are

00:01:02,360 --> 00:01:06,229
doing the interesting bit about this is

00:01:04,250 --> 00:01:08,090
that even if your application is not

00:01:06,229 --> 00:01:09,530
multi-threaded you can still get value

00:01:08,090 --> 00:01:11,690
out of these techniques you don't have

00:01:09,530 --> 00:01:14,810
to be spawning a bunch of threads to be

00:01:11,690 --> 00:01:16,850
able to get some value out of this so

00:01:14,810 --> 00:01:18,080
where are we going to go today we're

00:01:16,850 --> 00:01:19,910
going to talk a little bit about how you

00:01:18,080 --> 00:01:21,950
profile an application there's a couple

00:01:19,910 --> 00:01:24,619
of different major approaches that you

00:01:21,950 --> 00:01:26,180
can take to getting data and we'll talk

00:01:24,619 --> 00:01:27,710
a little bit about the pros and cons of

00:01:26,180 --> 00:01:29,570
each of those then we're going to look

00:01:27,710 --> 00:01:32,540
at some code and build a simple profiler

00:01:29,570 --> 00:01:34,159
ourselves here and then we will look at

00:01:32,540 --> 00:01:35,450
how we present that data because

00:01:34,159 --> 00:01:36,830
presenting the data and getting

00:01:35,450 --> 00:01:38,720
meaningful information out if it

00:01:36,830 --> 00:01:40,700
actually ends up being one of the the

00:01:38,720 --> 00:01:43,189
harder parts of this problem and then

00:01:40,700 --> 00:01:44,950
we'll talk about a few gotchas that come

00:01:43,189 --> 00:01:49,850
with the technique that will demonstrate

00:01:44,950 --> 00:01:52,280
so let's talk about how we profile there

00:01:49,850 --> 00:01:54,740
are two major ways that we can go about

00:01:52,280 --> 00:01:57,259
profiling an application the first of

00:01:54,740 --> 00:01:58,579
them is instrumenting the application so

00:01:57,259 --> 00:02:00,729
this would be an approach where we would

00:01:58,579 --> 00:02:05,090
use something like set trace funk or

00:02:00,729 --> 00:02:07,340
ruby prof and we would wrap basically

00:02:05,090 --> 00:02:09,829
every method call that gets made in ruby

00:02:07,340 --> 00:02:12,709
and we get an exact duration on how long

00:02:09,829 --> 00:02:14,750
that took this is awesome it gives us

00:02:12,709 --> 00:02:16,640
all sorts of information and timings

00:02:14,750 --> 00:02:18,980
about what's going on gives us all of

00:02:16,640 --> 00:02:21,140
the details that we want and so this is

00:02:18,980 --> 00:02:22,670
just a great way to get a complete

00:02:21,140 --> 00:02:24,860
picture of what your application is

00:02:22,670 --> 00:02:27,140
doing so why don't we just run out and

00:02:24,860 --> 00:02:28,610
do this let's just instrument everything

00:02:27,140 --> 00:02:31,750
so we can get all of the data about

00:02:28,610 --> 00:02:35,920
what's going on in our application well

00:02:31,750 --> 00:02:37,750
not so fast Ruby prof on their page to

00:02:35,920 --> 00:02:41,200
their credit they have put significant

00:02:37,750 --> 00:02:44,440
effort into you know making this fast

00:02:41,200 --> 00:02:47,220
optimizing it so it only makes your app

00:02:44,440 --> 00:02:49,420
twice as slow when you're running us

00:02:47,220 --> 00:02:51,070
this is clearly something that's an

00:02:49,420 --> 00:02:53,170
awesome tool for development and this

00:02:51,070 --> 00:02:54,459
this approach is great for that but this

00:02:53,170 --> 00:02:56,200
is not something that you're going to be

00:02:54,459 --> 00:02:57,340
able to run in production or in any sort

00:02:56,200 --> 00:03:00,220
of place where you're taking a

00:02:57,340 --> 00:03:02,620
significant amount of traffic so maybe

00:03:00,220 --> 00:03:05,280
there's another way maybe we could just

00:03:02,620 --> 00:03:09,010
instrument some things some of the time

00:03:05,280 --> 00:03:11,410
this is actually an approach that can

00:03:09,010 --> 00:03:13,780
work in production if we imagine that we

00:03:11,410 --> 00:03:16,390
have some sort of stack typical web

00:03:13,780 --> 00:03:17,680
stack here and the the colored boxes for

00:03:16,390 --> 00:03:20,020
the the red and the blue kind of

00:03:17,680 --> 00:03:21,880
represent a couple of the most important

00:03:20,020 --> 00:03:23,650
methods that we're talking about how

00:03:21,880 --> 00:03:24,790
about we just wrap those in some sort of

00:03:23,650 --> 00:03:27,640
time and so that we can get that

00:03:24,790 --> 00:03:30,040
information well working for New Relic

00:03:27,640 --> 00:03:31,870
obviously this is something that we do

00:03:30,040 --> 00:03:34,000
in practice this is how we take some of

00:03:31,870 --> 00:03:36,010
the transaction traces and things that

00:03:34,000 --> 00:03:38,739
give you these nice graphs of what goes

00:03:36,010 --> 00:03:40,600
on in your app but I've highlighted the

00:03:38,739 --> 00:03:43,660
line there that kind of shows when this

00:03:40,600 --> 00:03:46,540
can fall down application code well

00:03:43,660 --> 00:03:49,420
what's that what's happening within that

00:03:46,540 --> 00:03:51,220
that application code block well if we

00:03:49,420 --> 00:03:53,200
can't instrument it if we haven't chosen

00:03:51,220 --> 00:03:54,850
that as one of the methods that we're

00:03:53,200 --> 00:03:57,190
going to dig deeper on and put our hooks

00:03:54,850 --> 00:03:59,140
into we can't really give you more

00:03:57,190 --> 00:04:01,720
information about what's going on when

00:03:59,140 --> 00:04:03,730
that's happening so this is what pushes

00:04:01,720 --> 00:04:06,310
us to take a totally different tact as

00:04:03,730 --> 00:04:09,610
well in how we profile our applications

00:04:06,310 --> 00:04:12,940
so in instead of instrumenting we can do

00:04:09,610 --> 00:04:14,709
something called sample so to give an

00:04:12,940 --> 00:04:16,810
example of how this sort of stamping

00:04:14,709 --> 00:04:18,820
would work here's the same sort of stack

00:04:16,810 --> 00:04:20,470
that we have for the purpose of the the

00:04:18,820 --> 00:04:22,360
next couple of slides I've you know

00:04:20,470 --> 00:04:24,820
boiled it down to some icons it'll be

00:04:22,360 --> 00:04:26,800
there so if we imagine that we are

00:04:24,820 --> 00:04:29,110
looking at our application and time

00:04:26,800 --> 00:04:31,000
flows to the right we take a peek at

00:04:29,110 --> 00:04:33,310
what's happening in our system at one

00:04:31,000 --> 00:04:35,440
moment and we see that we are currently

00:04:33,310 --> 00:04:38,020
all the way down in our sequel we're

00:04:35,440 --> 00:04:40,210
executing some sort of database query

00:04:38,020 --> 00:04:43,090
pretty common thing for us to be doing

00:04:40,210 --> 00:04:44,860
we let a little time pass and then we

00:04:43,090 --> 00:04:45,760
query again and this time we find that

00:04:44,860 --> 00:04:47,260
we're actually an

00:04:45,760 --> 00:04:49,420
rails controller that's where we're

00:04:47,260 --> 00:04:51,430
executing your logic for doing doing

00:04:49,420 --> 00:04:53,800
something there let a little bit more

00:04:51,430 --> 00:04:55,240
time pass we take another snapshot of

00:04:53,800 --> 00:04:56,860
what's happening and we find that we're

00:04:55,240 --> 00:04:59,170
all the way down and in the database

00:04:56,860 --> 00:05:02,050
again and then you know we let another

00:04:59,170 --> 00:05:03,400
another tick go and we peak again and

00:05:02,050 --> 00:05:06,820
we're all the way down at the database

00:05:03,400 --> 00:05:08,950
so what does this picture give us this

00:05:06,820 --> 00:05:10,870
doesn't tell us how long each of those

00:05:08,950 --> 00:05:13,120
calls took this doesn't tell us how long

00:05:10,870 --> 00:05:15,280
it took for queries to run how long our

00:05:13,120 --> 00:05:18,250
controllers took but what it does give

00:05:15,280 --> 00:05:20,170
us is a statistical picture over time of

00:05:18,250 --> 00:05:22,270
how often we are in each of those

00:05:20,170 --> 00:05:24,310
different methods and if we run this for

00:05:22,270 --> 00:05:26,050
a long enough period of time we can

00:05:24,310 --> 00:05:28,510
build up a picture of what our app is

00:05:26,050 --> 00:05:29,980
doing without having to instrument every

00:05:28,510 --> 00:05:32,590
single one of those methods to get the

00:05:29,980 --> 00:05:35,710
timing now it gives us part of the

00:05:32,590 --> 00:05:37,120
information that instrumenting does it

00:05:35,710 --> 00:05:39,160
doesn't give us all those great times

00:05:37,120 --> 00:05:41,680
but we can get a picture of things that

00:05:39,160 --> 00:05:45,820
we can't viably instrument in a

00:05:41,680 --> 00:05:46,870
production system all right so what

00:05:45,820 --> 00:05:48,880
we're going to take a look at is

00:05:46,870 --> 00:05:51,760
building a sampling profiler based on

00:05:48,880 --> 00:05:54,460
this so let's take a look at the pieces

00:05:51,760 --> 00:05:56,290
that go into making that everything that

00:05:54,460 --> 00:05:58,180
you need to be able to build this comes

00:05:56,290 --> 00:06:01,000
out of the thread class which is in the

00:05:58,180 --> 00:06:02,350
core of Ruby and most of this is

00:06:01,000 --> 00:06:04,900
something that you might have noticed

00:06:02,350 --> 00:06:06,580
before but there may be a little pieces

00:06:04,900 --> 00:06:09,760
that you might not have been aware of

00:06:06,580 --> 00:06:12,400
the first one is the easy part so

00:06:09,760 --> 00:06:14,410
spawning a new thread is as simple as

00:06:12,400 --> 00:06:16,780
calling thread new and providing it with

00:06:14,410 --> 00:06:18,660
a block of code that block thing gets

00:06:16,780 --> 00:06:20,860
handed off to a thread that runs

00:06:18,660 --> 00:06:23,050
asynchronously in this case this will

00:06:20,860 --> 00:06:25,480
just loop forever not particularly

00:06:23,050 --> 00:06:27,760
useful but you know it shows how you get

00:06:25,480 --> 00:06:29,350
that code running this is going to be a

00:06:27,760 --> 00:06:31,960
critical part of building our sampling

00:06:29,350 --> 00:06:33,430
profiler because we are not going to get

00:06:31,960 --> 00:06:34,690
called by the application the

00:06:33,430 --> 00:06:36,670
application that we're wanting to

00:06:34,690 --> 00:06:39,070
profile isn't going to tell us hey why

00:06:36,670 --> 00:06:41,650
don't you go check things out so we need

00:06:39,070 --> 00:06:43,630
a separate thread of execution that we

00:06:41,650 --> 00:06:46,510
can run on so that we can do our

00:06:43,630 --> 00:06:49,900
sampling at a certain interval once

00:06:46,510 --> 00:06:51,250
we've gotten into that loop we can take

00:06:49,900 --> 00:06:53,770
a look at the threads that are there in

00:06:51,250 --> 00:06:55,420
our process so thread dot list will

00:06:53,770 --> 00:06:57,430
return us a collection of these thread

00:06:55,420 --> 00:06:59,580
objects and gives us a little bit

00:06:57,430 --> 00:07:01,379
information about their state

00:06:59,580 --> 00:07:03,539
we can introspect everything that's

00:07:01,379 --> 00:07:05,280
going on now what comes out of this list

00:07:03,539 --> 00:07:07,259
is going to vary dramatically based on

00:07:05,280 --> 00:07:08,719
your application if you're running you

00:07:07,259 --> 00:07:11,669
know web wreck or something like that

00:07:08,719 --> 00:07:14,490
locally you may have three threads if

00:07:11,669 --> 00:07:16,020
you're running puma under JRuby I've

00:07:14,490 --> 00:07:17,610
heard cases where people are running

00:07:16,020 --> 00:07:19,740
hundreds of threads can currently that

00:07:17,610 --> 00:07:21,539
show up in this list but whatever is

00:07:19,740 --> 00:07:24,030
happening in the process you're going to

00:07:21,539 --> 00:07:27,270
get a snapshot of what's happening there

00:07:24,030 --> 00:07:29,750
with those threads and then the last

00:07:27,270 --> 00:07:32,759
piece of our puzzle is the back-trace

00:07:29,750 --> 00:07:34,590
method so each of those thread objects

00:07:32,759 --> 00:07:36,690
exposes a method that will give us an

00:07:34,590 --> 00:07:39,330
array of strings that represents where

00:07:36,690 --> 00:07:40,889
in the code it's currently located so

00:07:39,330 --> 00:07:42,569
this is kind of a simplified example

00:07:40,889 --> 00:07:44,699
that I'll be using throughout you know

00:07:42,569 --> 00:07:47,310
the paths like shrunk a bit to fit on

00:07:44,699 --> 00:07:48,659
the slides but this is what the

00:07:47,310 --> 00:07:50,580
back-trace looks like it's just a

00:07:48,659 --> 00:07:52,949
collection of these formatted strings

00:07:50,580 --> 00:07:54,029
that tell us the file the line number

00:07:52,949 --> 00:07:56,520
and the method that we're currently

00:07:54,029 --> 00:07:59,340
executing in this may look a little bit

00:07:56,520 --> 00:08:02,490
familiar you may have seen it in another

00:07:59,340 --> 00:08:05,009
context so when an application throws an

00:08:02,490 --> 00:08:07,110
exception in rails or wherever the

00:08:05,009 --> 00:08:09,240
exception also has a back trace attached

00:08:07,110 --> 00:08:11,159
to it it's the exact same format of the

00:08:09,240 --> 00:08:12,870
information but we're getting it from

00:08:11,159 --> 00:08:14,610
all of the running threads rather than

00:08:12,870 --> 00:08:18,180
only in error cases where that's

00:08:14,610 --> 00:08:21,120
happening so with those pieces from the

00:08:18,180 --> 00:08:26,219
thread thread class we are ready so

00:08:21,120 --> 00:08:28,020
let's go build a profiler the beginning

00:08:26,219 --> 00:08:30,120
place for us is that we need to get our

00:08:28,020 --> 00:08:31,919
profiler started so we have a start

00:08:30,120 --> 00:08:35,219
method this would be within a profiler

00:08:31,919 --> 00:08:37,260
class and it's pretty straightforward

00:08:35,219 --> 00:08:39,060
what it does is it spawns off that

00:08:37,260 --> 00:08:42,719
separate threads so we get to execute

00:08:39,060 --> 00:08:45,300
next to the application and then runs

00:08:42,719 --> 00:08:48,000
for a while and takes those samples so

00:08:45,300 --> 00:08:50,010
our thread get this out so we are

00:08:48,000 --> 00:08:51,930
running asynchronously we're running

00:08:50,010 --> 00:08:54,240
next to all the application code our

00:08:51,930 --> 00:08:55,980
loop we ask whether we should keep

00:08:54,240 --> 00:08:58,380
running you know this is something where

00:08:55,980 --> 00:08:59,699
how you want to do this could vary you

00:08:58,380 --> 00:09:01,709
could run this type of profiler

00:08:59,699 --> 00:09:04,769
persistently and just that could be a

00:09:01,709 --> 00:09:06,810
wall true and let it go forever new

00:09:04,769 --> 00:09:09,270
relics product with it we do it 4 to 2

00:09:06,810 --> 00:09:11,579
15 minutes to take kind of a snapshot at

00:09:09,270 --> 00:09:12,720
profile and so that method would tell

00:09:11,579 --> 00:09:15,540
you whether you're finished

00:09:12,720 --> 00:09:18,340
we also sleep for a certain interval

00:09:15,540 --> 00:09:20,290
that's necessary so that this thread

00:09:18,340 --> 00:09:22,300
doesn't try to gobble up all the CPU you

00:09:20,290 --> 00:09:25,060
know we don't want to be sampling all of

00:09:22,300 --> 00:09:26,620
the time that we possibly can New Relic

00:09:25,060 --> 00:09:28,990
thread profile or does it about ten

00:09:26,620 --> 00:09:31,270
times a second and doing that over the

00:09:28,990 --> 00:09:32,650
course of about 2 to 15 minutes can

00:09:31,270 --> 00:09:35,560
build up a pretty good picture of what

00:09:32,650 --> 00:09:37,150
what your app is doing and we'll we'll

00:09:35,560 --> 00:09:40,090
take a little bit closer look at some of

00:09:37,150 --> 00:09:44,320
those numbers later on inside of that

00:09:40,090 --> 00:09:46,570
loop we just take samples so we run we

00:09:44,320 --> 00:09:48,910
take a snapshot of what the list of

00:09:46,570 --> 00:09:52,450
threads is and we'll take a peek into

00:09:48,910 --> 00:09:54,490
how that method works next so this is

00:09:52,450 --> 00:09:57,400
the most complicated part of our

00:09:54,490 --> 00:10:00,910
profiler here so we when we take a

00:09:57,400 --> 00:10:02,200
sample will enumerate the list of

00:10:00,910 --> 00:10:05,910
threads that are currently there in the

00:10:02,200 --> 00:10:08,650
process will step through each of those

00:10:05,910 --> 00:10:10,810
this next line here we're checking

00:10:08,650 --> 00:10:13,060
whether the back-trace is nil now this

00:10:10,810 --> 00:10:14,890
is kind of looks like a little bit of a

00:10:13,060 --> 00:10:18,010
wart but it's something that it's good

00:10:14,890 --> 00:10:20,290
to be aware of in some cases if a thread

00:10:18,010 --> 00:10:22,870
has died so the thread has finished its

00:10:20,290 --> 00:10:25,150
execution we may actually get called to

00:10:22,870 --> 00:10:27,670
do a sampling before the Ruby objects

00:10:25,150 --> 00:10:29,650
for it have completely gone away when a

00:10:27,670 --> 00:10:31,390
thread is in a dead state it's back

00:10:29,650 --> 00:10:33,370
trace is nil it doesn't return as an

00:10:31,390 --> 00:10:35,860
empty array or something something nice

00:10:33,370 --> 00:10:37,450
and tidy like that so we have to be

00:10:35,860 --> 00:10:40,750
careful that we may be in a state where

00:10:37,450 --> 00:10:43,120
we're going to get mills in there once

00:10:40,750 --> 00:10:44,740
we have that list of back traces then we

00:10:43,120 --> 00:10:46,690
can step through each of the lines that

00:10:44,740 --> 00:10:50,200
are there in that array and then we'll

00:10:46,690 --> 00:10:51,910
do something interesting with them in in

00:10:50,200 --> 00:10:54,130
this case what we're going to do for the

00:10:51,910 --> 00:10:56,140
simplified model here is we're just

00:10:54,130 --> 00:10:59,200
going to count how often we've seen each

00:10:56,140 --> 00:11:01,930
of the individual points in the code so

00:10:59,200 --> 00:11:04,450
those back traces again look like this

00:11:01,930 --> 00:11:06,880
so each of those lines is what we're

00:11:04,450 --> 00:11:09,310
enumerated over in that array and those

00:11:06,880 --> 00:11:14,710
lines will get passed into our account

00:11:09,310 --> 00:11:16,540
back trace line method so to track this

00:11:14,710 --> 00:11:17,890
information like I said what we're going

00:11:16,540 --> 00:11:20,860
to do is we're just going to keep a

00:11:17,890 --> 00:11:22,660
simple hash that's going to key off of

00:11:20,860 --> 00:11:24,600
each of those specific locations within

00:11:22,660 --> 00:11:27,269
the code it

00:11:24,600 --> 00:11:29,699
comes from the file name the line number

00:11:27,269 --> 00:11:31,649
in the methods there now it for this

00:11:29,699 --> 00:11:33,720
really simple case I could have just

00:11:31,649 --> 00:11:35,519
used the straight line as I as we

00:11:33,720 --> 00:11:38,399
receive it as the key but it actually

00:11:35,519 --> 00:11:41,459
was useful to bust that up into a little

00:11:38,399 --> 00:11:43,529
bit more interesting format for some of

00:11:41,459 --> 00:11:45,089
the presentation purposes and some of

00:11:43,529 --> 00:11:48,120
the other ways that you might want to

00:11:45,089 --> 00:11:50,310
collate this information it's it's

00:11:48,120 --> 00:11:53,579
useful to have it as more than just a

00:11:50,310 --> 00:11:55,620
straight out of the stack trace to break

00:11:53,579 --> 00:11:59,190
that line up we just use very simple

00:11:55,620 --> 00:12:00,240
regex here and for these purposes we're

00:11:59,190 --> 00:12:02,339
just going to take the list of the

00:12:00,240 --> 00:12:05,310
captures that come out of that the array

00:12:02,339 --> 00:12:08,759
there and treat that as the key so in

00:12:05,310 --> 00:12:10,560
the case of this particular line the

00:12:08,759 --> 00:12:13,319
resulting key that we would come up with

00:12:10,560 --> 00:12:15,480
would have the Hat barbie then why

00:12:13,319 --> 00:12:18,360
number five and then the call method

00:12:15,480 --> 00:12:20,759
that was happening there when this goes

00:12:18,360 --> 00:12:23,100
into our hash that's just going to be

00:12:20,759 --> 00:12:24,600
there as the key that prior call that we

00:12:23,100 --> 00:12:26,639
had had and then we're going to have an

00:12:24,600 --> 00:12:28,079
incrementing count so each time that we

00:12:26,639 --> 00:12:33,110
go through and do one of these sampling

00:12:28,079 --> 00:12:33,110
runs we're going to increment that count

00:12:33,620 --> 00:12:38,069
so with that we've actually been able to

00:12:36,540 --> 00:12:40,470
gather all of the information that we

00:12:38,069 --> 00:12:42,630
need to be able to build some sort of

00:12:40,470 --> 00:12:45,060
presentation out of this so let's take a

00:12:42,630 --> 00:12:47,699
look at a sample application and how

00:12:45,060 --> 00:12:50,069
that works out so on the Ruby agent team

00:12:47,699 --> 00:12:51,389
we we use the term trample when somebody

00:12:50,069 --> 00:12:54,329
stomped on something that they shouldn't

00:12:51,389 --> 00:12:57,089
so this could be you know somebody walks

00:12:54,329 --> 00:12:58,949
over a value of variable and

00:12:57,089 --> 00:13:00,839
multi-threaded context somebody stomps

00:12:58,949 --> 00:13:02,790
on your get commit so I made a little

00:13:00,839 --> 00:13:06,480
application to track trembles that's

00:13:02,790 --> 00:13:08,939
that's what the setup is here so in this

00:13:06,480 --> 00:13:11,220
application we have a trump method on

00:13:08,939 --> 00:13:12,779
our controller and this does some you

00:13:11,220 --> 00:13:14,759
know totally reasonable things to be

00:13:12,779 --> 00:13:17,250
doing in an application it'll you know

00:13:14,759 --> 00:13:19,500
calculate some Fibonacci numbers for us

00:13:17,250 --> 00:13:21,720
and it'll do a big n plus one just to

00:13:19,500 --> 00:13:25,649
give us a nice juicy target for the the

00:13:21,720 --> 00:13:27,660
threat profiling to hook on to FID looks

00:13:25,649 --> 00:13:31,110
pretty much like you would expect it to

00:13:27,660 --> 00:13:32,790
and the n plus 1 also looks pretty much

00:13:31,110 --> 00:13:38,000
like you don't want to actually do in

00:13:32,790 --> 00:13:41,600
your application don't use this code so

00:13:38,000 --> 00:13:43,760
when we run our profiler we can get this

00:13:41,600 --> 00:13:45,050
sort of output so you see the file the

00:13:43,760 --> 00:13:47,120
method in the line that we've come up

00:13:45,050 --> 00:13:49,700
with this is basically that information

00:13:47,120 --> 00:13:51,230
that we had extracted from it and so we

00:13:49,700 --> 00:13:54,710
run it for a little bit and then we take

00:13:51,230 --> 00:13:56,000
a look and it's kind of not exactly what

00:13:54,710 --> 00:13:59,090
we might have been expecting to find

00:13:56,000 --> 00:14:00,560
like where's our actual code where's the

00:13:59,090 --> 00:14:03,320
stuff that we wrote there's all this

00:14:00,560 --> 00:14:05,120
noise the noise make sense when you

00:14:03,320 --> 00:14:07,070
think about it every time we look at the

00:14:05,120 --> 00:14:10,070
thing to sample the root of our web

00:14:07,070 --> 00:14:12,410
server is running so all of those layers

00:14:10,070 --> 00:14:15,020
of rails and or whatever you're running

00:14:12,410 --> 00:14:17,150
is going to show up every time you look

00:14:15,020 --> 00:14:18,980
into that sample and so we need to do a

00:14:17,150 --> 00:14:21,680
little bit of filtering to get this

00:14:18,980 --> 00:14:24,200
information in a more useful format so

00:14:21,680 --> 00:14:25,670
we've got a little hide framework button

00:14:24,200 --> 00:14:28,550
here this worked with just some simple

00:14:25,670 --> 00:14:30,380
matching and once we clear out some of

00:14:28,550 --> 00:14:31,880
those pieces we get a little bit better

00:14:30,380 --> 00:14:33,860
picture we're starting to see some of

00:14:31,880 --> 00:14:35,300
our controller actions come through some

00:14:33,860 --> 00:14:38,390
of the code that we've actually written

00:14:35,300 --> 00:14:41,210
but well we still have a little bit of

00:14:38,390 --> 00:14:43,790
noise here at the top this is the

00:14:41,210 --> 00:14:45,830
profiler so the profiler is running in a

00:14:43,790 --> 00:14:48,170
threat itself so it sees itself

00:14:45,830 --> 00:14:50,540
executing and you know that may be a

00:14:48,170 --> 00:14:52,750
little bit of fun but it's not something

00:14:50,540 --> 00:14:56,570
that's particularly useful to us so

00:14:52,750 --> 00:14:59,600
we'll just hide that information and we

00:14:56,570 --> 00:15:01,910
end up coming down to a pretty concise

00:14:59,600 --> 00:15:04,910
view of just the application code that

00:15:01,910 --> 00:15:07,130
we really care about so this is a very

00:15:04,910 --> 00:15:08,930
simplified view of how that that can be

00:15:07,130 --> 00:15:11,720
presented and it does have some

00:15:08,930 --> 00:15:13,700
drawbacks if the Fibonacci method for

00:15:11,720 --> 00:15:15,440
instance was being called for multiple

00:15:13,700 --> 00:15:17,720
controller actions one of the drawbacks

00:15:15,440 --> 00:15:19,190
of the sort of simple list is that we

00:15:17,720 --> 00:15:21,740
don't see anything about where that

00:15:19,190 --> 00:15:23,780
comes from there's another way of

00:15:21,740 --> 00:15:25,130
viewing this information there's

00:15:23,780 --> 00:15:26,240
probably a number of different ways but

00:15:25,130 --> 00:15:29,660
there's another major way of visualizing

00:15:26,240 --> 00:15:32,030
it they will get us past that and that's

00:15:29,660 --> 00:15:34,760
a call tree so this is an image from the

00:15:32,030 --> 00:15:37,370
from you relics thread profiler and this

00:15:34,760 --> 00:15:39,500
shows you had a hierarchical view of

00:15:37,370 --> 00:15:41,089
where that code descends from this is

00:15:39,500 --> 00:15:43,010
information that we can get out of those

00:15:41,089 --> 00:15:45,140
back traces and build up from the way

00:15:43,010 --> 00:15:46,790
that we gathered it so let's take a

00:15:45,140 --> 00:15:48,800
quick look we're not going to see code

00:15:46,790 --> 00:15:50,300
but walk through kind of the algorithm

00:15:48,800 --> 00:15:50,640
for how that would work for building a

00:15:50,300 --> 00:15:53,250
call

00:15:50,640 --> 00:15:55,830
so again to remind this is the the stack

00:15:53,250 --> 00:15:58,710
trace that we came in with just our

00:15:55,830 --> 00:16:01,170
simplified model so the stack traces

00:15:58,710 --> 00:16:02,850
start from the bottom so our application

00:16:01,170 --> 00:16:04,350
is is the first thing and so we'll start

00:16:02,850 --> 00:16:07,380
from the bottom of the list and work our

00:16:04,350 --> 00:16:08,880
way up we will create nodes that will be

00:16:07,380 --> 00:16:11,190
represented as the tree that kind of

00:16:08,880 --> 00:16:12,990
will grow over there on the left so we

00:16:11,190 --> 00:16:14,490
come in we look at this line and we

00:16:12,990 --> 00:16:16,650
don't have a node that represents this

00:16:14,490 --> 00:16:18,180
in our collection yet and so we will

00:16:16,650 --> 00:16:21,960
just create it and we'll create it with

00:16:18,180 --> 00:16:24,270
a count of 1 we step to our next line

00:16:21,960 --> 00:16:26,730
and this is our controllers index method

00:16:24,270 --> 00:16:28,410
and so again we find that we haven't

00:16:26,730 --> 00:16:31,760
seen that before and so will append that

00:16:28,410 --> 00:16:33,840
in as a child of the app now the

00:16:31,760 --> 00:16:35,070
parent-child relationship there is the

00:16:33,840 --> 00:16:38,100
thing that's going to let us build that

00:16:35,070 --> 00:16:41,400
tree in in the view that we saw

00:16:38,100 --> 00:16:43,920
previously and then finally our fine

00:16:41,400 --> 00:16:46,920
method is going to come in and we have a

00:16:43,920 --> 00:16:49,530
very basic fairly boring tree so let's

00:16:46,920 --> 00:16:51,720
apply another stack trace so this is

00:16:49,530 --> 00:16:54,120
similar it calls into our model at the

00:16:51,720 --> 00:16:55,590
same sort of location but our controller

00:16:54,120 --> 00:16:58,320
action is a different action this will

00:16:55,590 --> 00:17:01,110
be the show that we do so when we come

00:16:58,320 --> 00:17:03,120
into parsing our stack trace we see that

00:17:01,110 --> 00:17:05,459
the lowest level is going to be the same

00:17:03,120 --> 00:17:07,500
location same entry point for our app so

00:17:05,459 --> 00:17:11,280
instead of creating a new node we end up

00:17:07,500 --> 00:17:12,360
incrementing the count we look to the

00:17:11,280 --> 00:17:14,250
next line that's going to be the

00:17:12,360 --> 00:17:16,589
controller and it looks a lot like that

00:17:14,250 --> 00:17:18,180
node but the action is different this is

00:17:16,589 --> 00:17:19,530
actually a unique location that we've

00:17:18,180 --> 00:17:22,199
captured in the code that we haven't

00:17:19,530 --> 00:17:24,660
seen before and so what we'll do instead

00:17:22,199 --> 00:17:26,400
is we span off a different child out of

00:17:24,660 --> 00:17:29,340
the app the different spots that we're

00:17:26,400 --> 00:17:31,470
going to be at and then in this model as

00:17:29,340 --> 00:17:33,840
well we don't share nodes between those

00:17:31,470 --> 00:17:35,580
various branches the leaves don't share

00:17:33,840 --> 00:17:39,270
once they've separated and so although

00:17:35,580 --> 00:17:41,100
we have the same model 300 find that we

00:17:39,270 --> 00:17:43,410
were calling from the other location we

00:17:41,100 --> 00:17:46,770
will represent that as a distinct note

00:17:43,410 --> 00:17:48,750
in this tree so from this I think it's

00:17:46,770 --> 00:17:50,640
it should hopefully be pretty clear how

00:17:48,750 --> 00:17:52,770
we can get this sort of presentation

00:17:50,640 --> 00:17:55,040
with those percentages those counts and

00:17:52,770 --> 00:17:57,690
the parent-child relationship is

00:17:55,040 --> 00:18:00,440
represented directly in that tree that

00:17:57,690 --> 00:18:00,440
we were looking at

00:18:01,830 --> 00:18:09,310
so what are the gotchas with this

00:18:04,750 --> 00:18:11,560
approach one of the big gotchas is that

00:18:09,310 --> 00:18:13,600
this is statistical you know this is

00:18:11,560 --> 00:18:16,630
something where we are sampling over a

00:18:13,600 --> 00:18:18,580
period of time and how frequently we do

00:18:16,630 --> 00:18:20,470
that what sort of traffic it's under and

00:18:18,580 --> 00:18:23,050
the size of the tasks that you're trying

00:18:20,470 --> 00:18:24,640
to catch matters you know if you had

00:18:23,050 --> 00:18:26,890
some sort of application where things

00:18:24,640 --> 00:18:28,480
you most of the work that you were

00:18:26,890 --> 00:18:30,550
interested in trying to capture only

00:18:28,480 --> 00:18:32,290
took a millisecond you know you're going

00:18:30,550 --> 00:18:34,060
to have a hard time capturing that in

00:18:32,290 --> 00:18:35,590
your sampling loop if you have things

00:18:34,060 --> 00:18:37,570
that are taking you know tens or

00:18:35,590 --> 00:18:39,280
hundreds of milliseconds it becomes a

00:18:37,570 --> 00:18:41,290
lot more plausible that the sampling

00:18:39,280 --> 00:18:43,960
thread is going to get a chance to run

00:18:41,290 --> 00:18:45,610
and get that introspection and as well

00:18:43,960 --> 00:18:47,920
if there's not a significant amount of

00:18:45,610 --> 00:18:49,390
traffic going to your application you

00:18:47,920 --> 00:18:51,190
know you're just going to see the web

00:18:49,390 --> 00:18:53,650
server sitting there idling in a loop

00:18:51,190 --> 00:18:56,110
you need to have some sort of very

00:18:53,650 --> 00:18:58,390
traffic being applied to it for this to

00:18:56,110 --> 00:19:00,520
give you interesting information because

00:18:58,390 --> 00:19:02,310
it's just based on the statistics of

00:19:00,520 --> 00:19:06,250
what we saw during that period of time

00:19:02,310 --> 00:19:07,450
it's also a little bit prone to effects

00:19:06,250 --> 00:19:09,670
from the fact that this is

00:19:07,450 --> 00:19:12,550
multi-threaded I've noticed that it

00:19:09,670 --> 00:19:14,800
seems as though I owe based operations

00:19:12,550 --> 00:19:16,930
kind of show up a little more often than

00:19:14,800 --> 00:19:18,790
the strict timings for compute based

00:19:16,930 --> 00:19:21,040
operations and it sort of makes sense

00:19:18,790 --> 00:19:23,050
because our sampling thread is more

00:19:21,040 --> 00:19:24,730
likely to get run while we're waiting

00:19:23,050 --> 00:19:27,520
for i 0 from another part of the process

00:19:24,730 --> 00:19:29,320
than it is when some things got CPU

00:19:27,520 --> 00:19:31,330
pegged and is going to use up the full

00:19:29,320 --> 00:19:34,660
amount of time it has before it lets

00:19:31,330 --> 00:19:36,010
things go another question that people

00:19:34,660 --> 00:19:40,540
might have about this sort of approach

00:19:36,010 --> 00:19:42,250
is the overhead to it so that was a very

00:19:40,540 --> 00:19:43,840
interesting thing you know we we checked

00:19:42,250 --> 00:19:46,060
it out a lot with the feature when we

00:19:43,840 --> 00:19:47,770
ship this with New Relic and we actually

00:19:46,060 --> 00:19:50,230
added a metric in to check what the

00:19:47,770 --> 00:19:51,640
polling time was so the polling time for

00:19:50,230 --> 00:19:53,890
each of those times when we take the

00:19:51,640 --> 00:19:56,800
snapshot and aggregated into the data

00:19:53,890 --> 00:19:58,900
structure and what we found over the

00:19:56,800 --> 00:20:01,120
past several months this is across

00:19:58,900 --> 00:20:03,400
probably about a thousand profiles was

00:20:01,120 --> 00:20:05,920
that on average it took about 1.7

00:20:03,400 --> 00:20:08,230
milliseconds for each of those samples

00:20:05,920 --> 00:20:10,480
which is pretty good you know I mean

00:20:08,230 --> 00:20:13,240
that's something that you could consider

00:20:10,480 --> 00:20:14,300
depending on your app running in a

00:20:13,240 --> 00:20:16,280
production

00:20:14,300 --> 00:20:18,230
setting especially for a short period of

00:20:16,280 --> 00:20:19,970
time to try and help diagnose problems

00:20:18,230 --> 00:20:22,070
you know if you know that you have some

00:20:19,970 --> 00:20:23,300
action that's happening or you know that

00:20:22,070 --> 00:20:25,460
you have something that you can't get

00:20:23,300 --> 00:20:27,620
visibility into this will give you a

00:20:25,460 --> 00:20:30,140
chance to to take a snapshot of what's

00:20:27,620 --> 00:20:32,090
really going on at the lowest level the

00:20:30,140 --> 00:20:34,340
there is additional overhead as well

00:20:32,090 --> 00:20:36,620
with this approach for just the memory

00:20:34,340 --> 00:20:38,990
for holding whatever data storage you're

00:20:36,620 --> 00:20:42,260
you're hanging on to so that that call

00:20:38,990 --> 00:20:43,850
tree or that hash for new relics

00:20:42,260 --> 00:20:45,950
purposes we hold on to it for the

00:20:43,850 --> 00:20:47,510
duration until the profiling period is

00:20:45,950 --> 00:20:49,250
done and then it gets cleared out and

00:20:47,510 --> 00:20:51,020
sent up to the collector if you were

00:20:49,250 --> 00:20:53,090
doing this more persistently across a

00:20:51,020 --> 00:20:54,500
long long period of time you might want

00:20:53,090 --> 00:20:57,170
to do something where you you know

00:20:54,500 --> 00:20:59,900
pruned it at certain levels and made

00:20:57,170 --> 00:21:01,760
sure that you didn't gather too many too

00:20:59,900 --> 00:21:06,110
many bits of data into there and consume

00:21:01,760 --> 00:21:09,350
too much memory another gotcha is that

00:21:06,110 --> 00:21:10,580
this is only available on 19 you can

00:21:09,350 --> 00:21:13,490
list the threads you can obviously

00:21:10,580 --> 00:21:15,620
obviously start new threads back on Ruby

00:21:13,490 --> 00:21:17,780
18 but the back-trace method is not

00:21:15,620 --> 00:21:21,500
there so you're pretty much dead ended

00:21:17,780 --> 00:21:23,390
at that point it is there on one line so

00:21:21,500 --> 00:21:26,000
that's that's what you can get this sort

00:21:23,390 --> 00:21:30,200
of visibility we also found that in

00:21:26,000 --> 00:21:33,050
testing the 191 version of Ruby an MRI

00:21:30,200 --> 00:21:35,210
was a bit flaky about some of these back

00:21:33,050 --> 00:21:37,370
trace methods this has ended up not

00:21:35,210 --> 00:21:39,620
being a big issue for us because of the

00:21:37,370 --> 00:21:41,660
seven versions of Ruby that we're

00:21:39,620 --> 00:21:44,450
currently supporting this is actually

00:21:41,660 --> 00:21:46,940
just about the smallest with 186 being

00:21:44,450 --> 00:21:49,730
think the only one that has fewer people

00:21:46,940 --> 00:21:50,930
on it so if you happen to be running 191

00:21:49,730 --> 00:21:52,340
you know you might want to take some

00:21:50,930 --> 00:21:55,790
care with taking this sort of approach

00:21:52,340 --> 00:22:00,330
but 192 and higher it's worked out great

00:21:55,790 --> 00:22:02,830
for us hmm

00:22:00,330 --> 00:22:06,220
yes there's a reason that there's not

00:22:02,830 --> 00:22:09,240
very many of our users on that so the

00:22:06,220 --> 00:22:11,800
other odd bit that we ran into was JRuby

00:22:09,240 --> 00:22:14,140
JRuby does an awesome job of providing

00:22:11,800 --> 00:22:17,410
real concurrency and running things in

00:22:14,140 --> 00:22:19,870
in separate threads and buys you a lot

00:22:17,410 --> 00:22:22,690
of those sorts of parallel things that

00:22:19,870 --> 00:22:24,670
you want with threading the back traces

00:22:22,690 --> 00:22:26,710
that we found with them occasionally

00:22:24,670 --> 00:22:28,570
we're coming out with some odd data and

00:22:26,710 --> 00:22:30,520
occasionally we're null it looked as

00:22:28,570 --> 00:22:32,980
though some of the Java threads that the

00:22:30,520 --> 00:22:34,990
the jruby stuff behind the scenes was

00:22:32,980 --> 00:22:37,300
using we're getting kind of adopted up

00:22:34,990 --> 00:22:39,580
into Ruby and then we couldn't take back

00:22:37,300 --> 00:22:41,050
traces on them we filed issues with the

00:22:39,580 --> 00:22:42,790
JRuby team and we're working with them

00:22:41,050 --> 00:22:44,500
on both of these but again you know if

00:22:42,790 --> 00:22:45,610
you try to do this yourself or look into

00:22:44,500 --> 00:22:47,860
some of these things don't be too

00:22:45,610 --> 00:22:51,160
surprised if you see a few odd results

00:22:47,860 --> 00:22:52,840
in there the code for the sample

00:22:51,160 --> 00:22:55,000
application that I wrote on this is

00:22:52,840 --> 00:22:56,670
available on github and i'm jason r

00:22:55,000 --> 00:22:59,790
clark on twitter and github as well

00:22:56,670 --> 00:22:59,790
thank you

00:23:24,210 --> 00:23:27,210
member

00:23:35,270 --> 00:23:37,780

YouTube URL: https://www.youtube.com/watch?v=sOJaGIP03As


